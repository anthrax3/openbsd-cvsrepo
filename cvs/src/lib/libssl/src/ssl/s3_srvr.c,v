head	1.126;
access;
symbols
	OPENBSD_6_0:1.126.0.2
	OPENBSD_6_0_BASE:1.126
	OPENBSD_5_9:1.124.0.2
	OPENBSD_5_9_BASE:1.124
	OPENBSD_5_8:1.112.0.4
	OPENBSD_5_8_BASE:1.112
	OPENBSD_5_7:1.100.0.4
	OPENBSD_5_7_BASE:1.100
	OPENBSD_5_6:1.79.0.4
	OPENBSD_5_6_BASE:1.79
	butholakala:1.30
	openssl_1_0_1_g:1.1.1.16
	OPENBSD_5_5:1.29.0.8
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.4
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	openssl_1_0_1_c:1.1.1.15
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	openssl_1_0_0_f:1.1.1.14
	openssl_1_0_0_e:1.1.1.13
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	openssh_1_0_0_a:1.1.1.12
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	openssl_0_9_8_k:1.1.1.11
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	openssl_0_9_8_j:1.1.1.11
	openssl_0_9_8_h:1.1.1.10
	pre_openssl_0_9_8h:1.20
	OPENBSD_4_4:1.20.0.10
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.8
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	openssl_0_9_7j:1.1.1.9
	openssl:1.1.1
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENSSL_0_9_7G:1.1.1.8
	OPENBSD_3_7:1.18.0.6
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENSSL_0_9_7D:1.1.1.7
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENSSL_0_9_7C:1.1.1.6
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENSSL_0_9_7B:1.1.1.5
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.4
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.126
date	2016.05.30.13.42.54;	author beck;	state Exp;
branches;
next	1.125;
commitid	P66xC6CnwAnLazTN;

1.125
date	2016.03.11.07.08.45;	author mmcc;	state Exp;
branches;
next	1.124;
commitid	MTdM7aVFdRMAzAYE;

1.124
date	2016.01.27.02.06.16;	author beck;	state Exp;
branches;
next	1.123;
commitid	VB2FDvGQ3jhs0Dye;

1.123
date	2015.09.13.12.39.16;	author jsing;	state Exp;
branches;
next	1.122;
commitid	6DGtvZOYHvZomwfr;

1.122
date	2015.09.13.09.20.19;	author jsing;	state Exp;
branches;
next	1.121;
commitid	yX3x2j9ZNO5kDaVV;

1.121
date	2015.09.12.16.10.07;	author doug;	state Exp;
branches;
next	1.120;
commitid	VR022UcxWVmcgSOF;

1.120
date	2015.09.12.15.03.39;	author jsing;	state Exp;
branches;
next	1.119;
commitid	86J9jDyJ44W6WCGe;

1.119
date	2015.09.12.13.03.06;	author jsing;	state Exp;
branches;
next	1.118;
commitid	lTf37hrXhDilhDFO;

1.118
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.117;
commitid	pa8oXRlJthT375Ws;

1.117
date	2015.09.10.17.57.50;	author jsing;	state Exp;
branches;
next	1.116;
commitid	T35skZJCouRaXVVY;

1.116
date	2015.09.10.15.56.26;	author jsing;	state Exp;
branches;
next	1.115;
commitid	vHznCDK3idwNEFz4;

1.115
date	2015.09.01.13.38.27;	author jsing;	state Exp;
branches;
next	1.114;
commitid	181x6cJx2ceVnn0a;

1.114
date	2015.08.29.16.51.17;	author doug;	state Exp;
branches;
next	1.113;
commitid	dB5GbUaVT2h1CFUT;

1.113
date	2015.08.27.06.21.15;	author doug;	state Exp;
branches;
next	1.112;
commitid	81GzeBdk0eOTcvRE;

1.112
date	2015.07.29.19.16.09;	author miod;	state Exp;
branches
	1.112.4.1;
next	1.111;
commitid	bdidqCSralexpgXw;

1.111
date	2015.07.18.01.42.26;	author doug;	state Exp;
branches;
next	1.110;
commitid	LjIP0S5CJ9sr9Mac;

1.110
date	2015.07.14.05.16.47;	author doug;	state Exp;
branches;
next	1.109;
commitid	WA5llXDPxPLCdE0S;

1.109
date	2015.06.20.17.04.07;	author doug;	state Exp;
branches;
next	1.108;
commitid	BwlAsesibyQzcgUw;

1.108
date	2015.06.18.22.51.05;	author doug;	state Exp;
branches;
next	1.107;
commitid	AcOny6o1iDzXgvTz;

1.107
date	2015.06.17.07.29.33;	author doug;	state Exp;
branches;
next	1.106;
commitid	cvhmfDoLDdIR1Efl;

1.106
date	2015.06.15.05.32.58;	author doug;	state Exp;
branches;
next	1.105;
commitid	1aCIJCoHWVyZ3XBP;

1.105
date	2015.06.15.05.16.56;	author doug;	state Exp;
branches;
next	1.104;
commitid	HZbFGzkFdWRFiL9B;

1.104
date	2015.06.15.03.32.59;	author doug;	state Exp;
branches;
next	1.103;
commitid	Rv7ayT36UkgKI0N2;

1.103
date	2015.05.15.11.00.14;	author jsg;	state Exp;
branches;
next	1.102;
commitid	DVhfXEEmSZcth64F;

1.102
date	2015.04.15.16.25.43;	author jsing;	state Exp;
branches;
next	1.101;
commitid	pvAlLTVkoLxmS3rG;

1.101
date	2015.03.27.12.29.54;	author jsing;	state Exp;
branches;
next	1.100;
commitid	GlMku1cNd3nfgnVW;

1.100
date	2015.02.25.03.49.21;	author bcook;	state Exp;
branches
	1.100.4.1;
next	1.99;
commitid	LgY60rVIVE9bk4ym;

1.99
date	2015.02.07.08.56.39;	author jsing;	state Exp;
branches;
next	1.98;
commitid	r6TLSniZTKxwlBFr;

1.98
date	2015.02.06.10.04.07;	author jsing;	state Exp;
branches;
next	1.97;
commitid	gUE6WvuaAot5gdDi;

1.97
date	2015.02.06.08.30.23;	author jsing;	state Exp;
branches;
next	1.96;
commitid	K5MXFl39zEkHakNY;

1.96
date	2014.12.29.16.12.59;	author tedu;	state Exp;
branches;
next	1.95;
commitid	dvJmVzmXCsNmF1Oa;

1.95
date	2014.12.15.00.46.53;	author doug;	state Exp;
branches;
next	1.94;
commitid	I2ue40Sqz1Sg9KmB;

1.94
date	2014.12.14.14.34.43;	author jsing;	state Exp;
branches;
next	1.93;
commitid	JlmRntBjnvBE29Fz;

1.93
date	2014.12.10.15.43.31;	author jsing;	state Exp;
branches;
next	1.92;
commitid	9GGF3DCNTm9Bs8E3;

1.92
date	2014.12.10.15.36.47;	author jsing;	state Exp;
branches;
next	1.91;
commitid	x50cturILyXAfPoH;

1.91
date	2014.11.18.05.33.43;	author miod;	state Exp;
branches;
next	1.90;
commitid	81uwsCsokEuKDUjo;

1.90
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.89;
commitid	M3pvHgIFoWUHNqJn;

1.89
date	2014.10.31.15.25.55;	author jsing;	state Exp;
branches;
next	1.88;
commitid	NOaAgwTtK29a9Ncs;

1.88
date	2014.10.31.14.51.01;	author jsing;	state Exp;
branches;
next	1.87;
commitid	cMCIoWtrOiPFZWnD;

1.87
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.86;
commitid	cGE1JG2i0h4NcVDi;

1.86
date	2014.10.03.13.58.18;	author jsing;	state Exp;
branches;
next	1.85;
commitid	TTuHOVoRSWSvd6HI;

1.85
date	2014.09.27.11.03.43;	author jsing;	state Exp;
branches;
next	1.84;
commitid	SaXgw4tkjiclDQMM;

1.84
date	2014.09.19.14.32.24;	author tedu;	state Exp;
branches;
next	1.83;
commitid	bjh5IPF6NiPe7iWK;

1.83
date	2014.09.07.12.16.23;	author jsing;	state Exp;
branches;
next	1.82;
commitid	oAt7EW2Y0Fwu0XNB;

1.82
date	2014.08.24.14.36.45;	author jsing;	state Exp;
branches;
next	1.81;
commitid	1vOBE9WdltEkCa6G;

1.81
date	2014.08.11.04.46.42;	author miod;	state Exp;
branches;
next	1.80;
commitid	1JW8cRgVd0eEqGnT;

1.80
date	2014.08.10.14.42.56;	author jsing;	state Exp;
branches;
next	1.79;
commitid	wihJupNvfkdpKL9O;

1.79
date	2014.07.28.04.23.12;	author guenther;	state Exp;
branches;
next	1.78;
commitid	9823pc9SeqrqIVJr;

1.78
date	2014.07.12.22.33.39;	author jsing;	state Exp;
branches;
next	1.77;
commitid	JT7oO4AHgBkjVLfZ;

1.77
date	2014.07.12.13.11.53;	author jsing;	state Exp;
branches;
next	1.76;
commitid	tJhRneQ4w1l9LuV2;

1.76
date	2014.07.12.10.06.04;	author jsing;	state Exp;
branches;
next	1.75;
commitid	NW1vqt0lC8ZwMk18;

1.75
date	2014.07.11.22.57.25;	author miod;	state Exp;
branches;
next	1.74;
commitid	n7W5lBeOlkdDXzQO;

1.74
date	2014.07.11.15.18.52;	author miod;	state Exp;
branches;
next	1.73;
commitid	BKepDJvCQl9czIEO;

1.73
date	2014.07.11.12.24.51;	author miod;	state Exp;
branches;
next	1.72;
commitid	oiRfL3uFXW1zQWWy;

1.72
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.71;
commitid	cCGiAdDteN08GytD;

1.71
date	2014.07.10.21.36.49;	author bcook;	state Exp;
branches;
next	1.70;
commitid	zae2SDrjYbDaXCeb;

1.70
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.69;
commitid	lsH7iukeZYSZBx6F;

1.69
date	2014.07.10.08.25.00;	author guenther;	state Exp;
branches;
next	1.68;
commitid	w11OIjBmQPrJwUQI;

1.68
date	2014.07.09.11.25.42;	author jsing;	state Exp;
branches;
next	1.67;
commitid	N5P2FUkVkAd7ODs9;

1.67
date	2014.06.30.14.13.27;	author tedu;	state Exp;
branches;
next	1.66;
commitid	H5OTJxdwtWPzPQfq;

1.66
date	2014.06.19.21.29.51;	author tedu;	state Exp;
branches;
next	1.65;
commitid	CIpPjhmVWPbqgxVA;

1.65
date	2014.06.18.04.51.31;	author miod;	state Exp;
branches;
next	1.64;
commitid	tINXcDFJ8pII8tuw;

1.64
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	mJUVYpkFBZ0Zv2bG;

1.63
date	2014.06.11.15.44.10;	author jsing;	state Exp;
branches;
next	1.62;
commitid	atiHl7idnrYpOeRd;

1.62
date	2014.06.11.01.53.03;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	4evB2EbwDYaBfe0g;

1.61
date	2014.06.07.22.23.12;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	4IX3BI6FoxwuHgdS;

1.60
date	2014.06.07.14.10.35;	author jsing;	state Exp;
branches;
next	1.59;
commitid	AgFmutmGDUehZZeH;

1.59
date	2014.06.05.15.46.24;	author jsing;	state Exp;
branches;
next	1.58;
commitid	iKdQmUaYF0SZSn3g;

1.58
date	2014.06.04.14.10.23;	author tedu;	state Exp;
branches;
next	1.57;
commitid	GMbAFZ4Hukhh97U1;

1.57
date	2014.05.31.13.55.45;	author jsing;	state Exp;
branches;
next	1.56;

1.56
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.55;

1.55
date	2014.05.30.14.01.11;	author jsing;	state Exp;
branches;
next	1.54;

1.54
date	2014.05.29.21.25.16;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2014.05.29.18.11.13;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2014.05.28.13.03.24;	author jsing;	state Exp;
branches;
next	1.51;

1.51
date	2014.05.25.16.23.10;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2014.05.24.12.44.48;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2014.05.22.17.33.17;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.18.16.10.26;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2014.04.24.13.06.52;	author mcbride;	state Exp;
branches;
next	1.45;

1.45
date	2014.04.23.05.13.57;	author beck;	state Exp;
branches;
next	1.44;

1.44
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2014.04.17.23.35.40;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.17.13.37.50;	author beck;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.16.20.39.09;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.16.18.05.55;	author beck;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.16.17.59.16;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.16.01.43.06;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.16.00.13.30;	author mcbride;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.14.17.45.38;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.14.16.43.25;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches
	1.29.4.1
	1.29.8.1;
next	1.28;

1.28
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.15.09.42.29;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.10.09.09.40;	author markus;	state Exp;
branches
	1.24.2.1
	1.24.4.1;
next	1.23;

1.23
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches
	1.23.2.1
	1.23.6.1;
next	1.22;

1.22
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches
	1.20.8.1
	1.20.10.1;
next	1.19;

1.19
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.17.14.22.02;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.30.21.30.28;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2003.03.19.23.03.01;	author markus;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.09.14.11.18.03;	author markus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.05.22.12.11;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.30.21.05.53;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.30.16.00.16;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.30.11.08.06;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches
	1.7.2.1
	1.7.4.1;
next	1.6;

1.6
date	2001.04.22.23.33.04;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.58.38;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.50;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.30;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.28;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.36;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.15;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.52.44;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.36.42;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.11.11.21.21.10;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.20.42.06;	author markus;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.04.29.05.37.27;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2011.11.03.02.32.21;	author djm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2012.01.05.22.59.09;	author djm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.7.2.1
date	2002.07.30.11.07.33;	author miod;	state Exp;
branches;
next	;

1.7.4.1
date	2002.07.30.15.47.52;	author jason;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.03.19.23.25.40;	author miod;	state Exp;
branches;
next	;

1.14.2.1
date	2003.03.19.23.39.12;	author margarida;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2003.10.01.22.46.19;	author brad;	state Exp;
branches;
next	;

1.15.2.1
date	2003.10.01.15.58.04;	author margarida;	state Exp;
branches;
next	;

1.16.2.1
date	2003.10.31.00.13.15;	author brad;	state Exp;
branches;
next	;

1.20.8.1
date	2009.01.09.11.40.50;	author djm;	state Exp;
branches;
next	;

1.20.10.1
date	2009.01.09.11.40.35;	author djm;	state Exp;
branches;
next	;

1.23.2.1
date	2009.11.17.14.34.37;	author sthen;	state Exp;
branches;
next	;

1.23.6.1
date	2009.11.17.14.34.52;	author sthen;	state Exp;
branches;
next	;

1.24.2.1
date	2010.12.15.09.44.23;	author jasper;	state Exp;
branches;
next	;

1.24.4.1
date	2010.12.15.09.43.53;	author jasper;	state Exp;
branches;
next	;

1.29.4.1
date	2014.06.05.20.37.47;	author sthen;	state Exp;
branches;
next	1.29.4.2;
commitid	V8zSJibrIbY4vAzC;

1.29.4.2
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.29.8.1
date	2014.06.05.17.05.16;	author sthen;	state Exp;
branches;
next	1.29.8.2;
commitid	PBa7adr1t6pFSi7e;

1.29.8.2
date	2014.08.09.16.54.58;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;

1.100.4.1
date	2016.01.27.02.11.34;	author beck;	state Exp;
branches;
next	;
commitid	W3frwqvOqFQSSXSA;

1.112.4.1
date	2016.01.27.02.09.51;	author beck;	state Exp;
branches;
next	;
commitid	z2xz1yYwPRWVfmVV;


desc
@@


1.126
log
@deprecate internal use of EVP_[Cipher|Encrypt|Decrypt]_Final.
14 years ago these were changed in OpenSSL to be the same
as the _ex functions. We use the _ex functions only internally
to ensure it is obvious the ctx must be cleared.
ok bcook@@
@
text
@/* $OpenBSD: s3_srvr.c,v 1.125 2016/03/11 07:08:45 mmcc Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the OpenSSL open source
 * license provided above.
 *
 * ECC cipher suite support in OpenSSL originally written by
 * Vipul Gupta and Sumit Gupta of Sun Microsystems Laboratories.
 *
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/bn.h>
#include <openssl/buffer.h>
#include <openssl/evp.h>
#include <openssl/dh.h>
#ifndef OPENSSL_NO_GOST
#include <openssl/gost.h>
#endif
#include <openssl/hmac.h>
#include <openssl/md5.h>
#include <openssl/objects.h>
#include <openssl/x509.h>

#include "bytestring.h"

int
ssl3_accept(SSL *s)
{
	unsigned long alg_k;
	void (*cb)(const SSL *ssl, int type, int val) = NULL;
	int ret = -1;
	int new_state, state, skip = 0;

	ERR_clear_error();
	errno = 0;

	if (s->info_callback != NULL)
		cb = s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb = s->ctx->info_callback;

	/* init things to blank */
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s))
		SSL_clear(s);

	if (s->cert == NULL) {
		SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_NO_CERTIFICATE_SET);
		ret = -1;
		goto end;
	}

	for (;;) {
		state = s->state;

		switch (s->state) {
		case SSL_ST_RENEGOTIATE:
			s->renegotiate = 1;
			/* s->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server = 1;
			if (cb != NULL)
				cb(s, SSL_CB_HANDSHAKE_START, 1);

			if ((s->version >> 8) != 3) {
				SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
				ret = -1;
				goto end;
			}
			s->type = SSL_ST_ACCEPT;

			if (!ssl3_setup_init_buffer(s)) {
				ret = -1;
				goto end;
			}
			if (!ssl3_setup_buffers(s)) {
				ret = -1;
				goto end;
			}

			s->init_num = 0;

			if (s->state != SSL_ST_RENEGOTIATE) {
				/*
				 * Ok, we now need to push on a buffering BIO
				 * so that the output is sent in a way that
				 * TCP likes :-)
				 */
				if (!ssl_init_wbio_buffer(s, 1)) {
					ret = -1;
					goto end;
				}

				if (!tls1_init_finished_mac(s)) {
					ret = -1;
					goto end;
				}

				s->state = SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
			} else if (!s->s3->send_connection_binding) {
				/*
				 * Server attempting to renegotiate with
				 * client that doesn't support secure
				 * renegotiation.
				 */
				SSLerr(SSL_F_SSL3_ACCEPT,
				    SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_HANDSHAKE_FAILURE);
				ret = -1;
				goto end;
			} else {
				/*
				 * s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest
				 */
				s->ctx->stats.sess_accept_renegotiate++;
				s->state = SSL3_ST_SW_HELLO_REQ_A;
			}
			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->shutdown = 0;
			ret = ssl3_send_hello_request(s);
			if (ret <= 0)
				goto end;
			s->s3->tmp.next_state = SSL3_ST_SW_HELLO_REQ_C;
			s->state = SSL3_ST_SW_FLUSH;
			s->init_num = 0;

			if (!tls1_init_finished_mac(s)) {
				ret = -1;
				goto end;
			}
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->state = SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			s->shutdown = 0;
			if (s->rwstate != SSL_X509_LOOKUP) {
				ret = ssl3_get_client_hello(s);
				if (ret <= 0)
					goto end;
			}

			s->renegotiate = 2;
			s->state = SSL3_ST_SW_SRVR_HELLO_A;
			s->init_num = 0;
			break;

		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			ret = ssl3_send_server_hello(s);
			if (ret <= 0)
				goto end;
			if (s->hit) {
				if (s->tlsext_ticket_expected)
					s->state = SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state = SSL3_ST_SW_CHANGE_A;
			}
			else
				s->state = SSL3_ST_SW_CERT_A;
			s->init_num = 0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH or anon ECDH. */
			if (!(s->s3->tmp.new_cipher->algorithm_auth &
			    SSL_aNULL)) {
				ret = ssl3_send_server_certificate(s);
				if (ret <= 0)
					goto end;
				if (s->tlsext_status_expected)
					s->state = SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state = SSL3_ST_SW_KEY_EXCH_A;
			} else {
				skip = 1;
				s->state = SSL3_ST_SW_KEY_EXCH_A;
			}
			s->init_num = 0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
		case SSL3_ST_SW_KEY_EXCH_B:
			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;

			/*
			 * Only send if using a DH key exchange.
			 *
			 * For ECC ciphersuites, we send a ServerKeyExchange
			 * message only if the cipher suite is ECDHE. In other
			 * cases, the server certificate contains the server's
			 * public key for key exchange.
			 */
			if (alg_k & (SSL_kDHE|SSL_kECDHE)) {
				ret = ssl3_send_server_key_exchange(s);
				if (ret <= 0)
					goto end;
			} else
				skip = 1;

			s->state = SSL3_ST_SW_CERT_REQ_A;
			s->init_num = 0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			/*
			 * Determine whether or not we need to request a
			 * certificate.
			 *
			 * Do not request a certificate if:
			 *
			 * - We did not ask for it (SSL_VERIFY_PEER is unset).
			 *
			 * - SSL_VERIFY_CLIENT_ONCE is set and we are
			 *   renegotiating.
			 *
			 * - We are using an anonymous ciphersuites
			 *   (see section "Certificate request" in SSL 3 drafts
			 *   and in RFC 2246) ... except when the application
			 *   insists on verification (against the specs, but
			 *   s3_clnt.c accepts this for SSL 3).
			 */
			if (!(s->verify_mode & SSL_VERIFY_PEER) ||
			    ((s->session->peer != NULL) &&
			     (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
			    ((s->s3->tmp.new_cipher->algorithm_auth &
			     SSL_aNULL) && !(s->verify_mode &
			     SSL_VERIFY_FAIL_IF_NO_PEER_CERT))) {
				/* No cert request */
				skip = 1;
				s->s3->tmp.cert_request = 0;
				s->state = SSL3_ST_SW_SRVR_DONE_A;
				if (s->s3->handshake_buffer) {
					if (!tls1_digest_cached_records(s)) {
						ret = -1;
						goto end;
					}
				}
			} else {
				s->s3->tmp.cert_request = 1;
				ret = ssl3_send_certificate_request(s);
				if (ret <= 0)
					goto end;
				s->state = SSL3_ST_SW_SRVR_DONE_A;
				s->init_num = 0;
			}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			ret = ssl3_send_server_done(s);
			if (ret <= 0)
				goto end;
			s->s3->tmp.next_state = SSL3_ST_SR_CERT_A;
			s->state = SSL3_ST_SW_FLUSH;
			s->init_num = 0;
			break;

		case SSL3_ST_SW_FLUSH:

			/*
			 * This code originally checked to see if
			 * any data was pending using BIO_CTRL_INFO
			 * and then flushed. This caused problems
			 * as documented in PR#1939. The proposed
			 * fix doesn't completely resolve this issue
			 * as buggy implementations of BIO_CTRL_PENDING
			 * still exist. So instead we just flush
			 * unconditionally.
			 */

			s->rwstate = SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0) {
				ret = -1;
				goto end;
			}
			s->rwstate = SSL_NOTHING;

			s->state = s->s3->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			if (s->s3->tmp.cert_request) {
				ret = ssl3_get_client_certificate(s);
				if (ret <= 0)
					goto end;
			}
			s->init_num = 0;
			s->state = SSL3_ST_SR_KEY_EXCH_A;
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret = ssl3_get_client_key_exchange(s);
			if (ret <= 0)
				goto end;
			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
			if (ret == 2) {
				/*
				 * For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 * Also for GOST ciphersuites when
				 * the client uses its key from the certificate
				 * for key exchange.
				 */
				if (s->s3->next_proto_neg_seen)
					s->state = SSL3_ST_SR_NEXT_PROTO_A;
				else
					s->state = SSL3_ST_SR_FINISHED_A;
				s->init_num = 0;
			} else if (SSL_USE_SIGALGS(s) || (alg_k & SSL_kGOST)) {
				s->state = SSL3_ST_SR_CERT_VRFY_A;
				s->init_num = 0;
				if (!s->session->peer)
					break;
				/*
				 * For sigalgs freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer) {
					SSLerr(SSL_F_SSL3_ACCEPT,
					    ERR_R_INTERNAL_ERROR);
					ret = -1;
					goto end;
				}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!tls1_digest_cached_records(s)) {
					ret = -1;
					goto end;
				}
			} else {
				int offset = 0;
				int dgst_num;

				s->state = SSL3_ST_SR_CERT_VRFY_A;
				s->init_num = 0;

				/*
				 * We need to get hashes here so if there is
				 * a client cert, it can be verified
				 * FIXME - digest processing for
				 * CertificateVerify should be generalized.
				 * But it is next step
				 */
				if (s->s3->handshake_buffer) {
					if (!tls1_digest_cached_records(s)) {
						ret = -1;
						goto end;
					}
				}
				for (dgst_num = 0; dgst_num < SSL_MAX_DIGEST;
				    dgst_num++)
					if (s->s3->handshake_dgst[dgst_num]) {
					int dgst_size;

					s->method->ssl3_enc->cert_verify_mac(s,
					    EVP_MD_CTX_type(
					    s->s3->handshake_dgst[dgst_num]),
					    &(s->s3->tmp.cert_verify_md[offset]));
					dgst_size = EVP_MD_CTX_size(
					    s->s3->handshake_dgst[dgst_num]);
					if (dgst_size < 0) {
						ret = -1;
						goto end;
					}
					offset += dgst_size;
				}
			}
			break;

		case SSL3_ST_SR_CERT_VRFY_A:
		case SSL3_ST_SR_CERT_VRFY_B:
			s->s3->flags |= SSL3_FLAGS_CCS_OK;

			/* we should decide if we expected this one */
			ret = ssl3_get_cert_verify(s);
			if (ret <= 0)
				goto end;

			if (s->s3->next_proto_neg_seen)
				s->state = SSL3_ST_SR_NEXT_PROTO_A;
			else
				s->state = SSL3_ST_SR_FINISHED_A;
			s->init_num = 0;
			break;

		case SSL3_ST_SR_NEXT_PROTO_A:
		case SSL3_ST_SR_NEXT_PROTO_B:
			ret = ssl3_get_next_proto(s);
			if (ret <= 0)
				goto end;
			s->init_num = 0;
			s->state = SSL3_ST_SR_FINISHED_A;
			break;

		case SSL3_ST_SR_FINISHED_A:
		case SSL3_ST_SR_FINISHED_B:
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
			ret = ssl3_get_finished(s, SSL3_ST_SR_FINISHED_A,
			    SSL3_ST_SR_FINISHED_B);
			if (ret <= 0)
				goto end;
			if (s->hit)
				s->state = SSL_ST_OK;
			else if (s->tlsext_ticket_expected)
				s->state = SSL3_ST_SW_SESSION_TICKET_A;
			else
				s->state = SSL3_ST_SW_CHANGE_A;
			s->init_num = 0;
			break;

		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret = ssl3_send_newsession_ticket(s);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_SW_CHANGE_A;
			s->init_num = 0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret = ssl3_send_cert_status(s);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_SW_KEY_EXCH_A;
			s->init_num = 0;
			break;


		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher = s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s)) {
				ret = -1;
				goto end;
			}

			ret = ssl3_send_change_cipher_spec(s,
			    SSL3_ST_SW_CHANGE_A, SSL3_ST_SW_CHANGE_B);

			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_SW_FINISHED_A;
			s->init_num = 0;

			if (!s->method->ssl3_enc->change_cipher_state(
			    s, SSL3_CHANGE_CIPHER_SERVER_WRITE)) {
				ret = -1;
				goto end;
			}

			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret = ssl3_send_finished(s,
			SSL3_ST_SW_FINISHED_A, SSL3_ST_SW_FINISHED_B,
			s->method->ssl3_enc->server_finished_label,
			s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_SW_FLUSH;
			if (s->hit) {
				if (s->s3->next_proto_neg_seen) {
					s->s3->flags |= SSL3_FLAGS_CCS_OK;
					s->s3->tmp.next_state =
					    SSL3_ST_SR_NEXT_PROTO_A;
				} else
					s->s3->tmp.next_state =
					    SSL3_ST_SR_FINISHED_A;
			} else
				s->s3->tmp.next_state = SSL_ST_OK;
			s->init_num = 0;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			tls1_cleanup_key_block(s);

			BUF_MEM_free(s->init_buf);
			s->init_buf = NULL;

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->init_num = 0;

			/* skipped if we just sent a HelloRequest */
			if (s->renegotiate == 2) {
				s->renegotiate = 0;
				s->new_session = 0;

				ssl_update_cache(s, SSL_SESS_CACHE_SERVER);

				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func = ssl3_accept;

				if (cb != NULL)
					cb(s, SSL_CB_HANDSHAKE_DONE, 1);
			}

			ret = 1;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_SSL3_ACCEPT,
			    SSL_R_UNKNOWN_STATE);
			ret = -1;
			goto end;
			/* break; */
		}

		if (!s->s3->tmp.reuse_message && !skip) {
			if (s->debug) {
				if ((ret = BIO_flush(s->wbio)) <= 0)
					goto end;
			}


			if ((cb != NULL) && (s->state != state)) {
				new_state = s->state;
				s->state = state;
				cb(s, SSL_CB_ACCEPT_LOOP, 1);
				s->state = new_state;
			}
		}
		skip = 0;
	}
end:
	/* BIO_flush(s->wbio); */

	s->in_handshake--;
	if (cb != NULL)
		cb(s, SSL_CB_ACCEPT_EXIT, ret);
	return (ret);
}

int
ssl3_send_hello_request(SSL *s)
{
	if (s->state == SSL3_ST_SW_HELLO_REQ_A) {
		ssl3_handshake_msg_start(s, SSL3_MT_HELLO_REQUEST);
		ssl3_handshake_msg_finish(s, 0);

		s->state = SSL3_ST_SW_HELLO_REQ_B;
	}

	/* SSL3_ST_SW_HELLO_REQ_B */
	return (ssl3_handshake_write(s));
}

int
ssl3_get_client_hello(SSL *s)
{
	int i, j, ok, al, ret = -1;
	unsigned int cookie_len;
	long n;
	unsigned long id;
	unsigned char *p, *d;
	SSL_CIPHER *c;
	STACK_OF(SSL_CIPHER) *ciphers = NULL;
	unsigned long alg_k;

	/*
	 * We do this so that we will respond with our native type.
	 * If we are TLSv1 and we get SSLv3, we will respond with TLSv1,
	 * This down switching should be handled by a different method.
	 * If we are SSLv3, we will respond with SSLv3, even if prompted with
	 * TLSv1.
	 */
	if (s->state == SSL3_ST_SR_CLNT_HELLO_A) {
		s->state = SSL3_ST_SR_CLNT_HELLO_B;
	}
	s->first_packet = 1;
	n = s->method->ssl_get_message(s, SSL3_ST_SR_CLNT_HELLO_B,
	    SSL3_ST_SR_CLNT_HELLO_C, SSL3_MT_CLIENT_HELLO,
	    SSL3_RT_MAX_PLAIN_LENGTH, &ok);

	if (!ok)
		return ((int)n);
	s->first_packet = 0;
	d = p = (unsigned char *)s->init_msg;

	if (2 > n)
		goto truncated;
	/*
	 * Use version from inside client hello, not from record header.
	 * (may differ: see RFC 2246, Appendix E, second paragraph)
	 */
	s->client_version = (((int)p[0]) << 8)|(int)p[1];
	p += 2;

	if ((s->version == DTLS1_VERSION && s->client_version > s->version) ||
	    (s->version != DTLS1_VERSION && s->client_version < s->version)) {
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
		    SSL_R_WRONG_VERSION_NUMBER);
		if ((s->client_version >> 8) == SSL3_VERSION_MAJOR &&
			!s->enc_write_ctx && !s->write_hash) {
			/*
			 * Similar to ssl3_get_record, send alert using remote
			 * version number
			 */
			s->version = s->client_version;
		}
		al = SSL_AD_PROTOCOL_VERSION;
		goto f_err;
	}

	/*
	 * If we require cookies and this ClientHello doesn't
	 * contain one, just return since we do not want to
	 * allocate any memory yet. So check cookie length...
	 */
	if (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) {
		unsigned int session_length, cookie_length;

		session_length = *(p + SSL3_RANDOM_SIZE);
		cookie_length = *(p + SSL3_RANDOM_SIZE + session_length + 1);

		if (cookie_length == 0)
			return (1);
	}

	if (p + SSL3_RANDOM_SIZE + 1 - d > n)
		goto truncated;

	/* load the client random */
	memcpy(s->s3->client_random, p, SSL3_RANDOM_SIZE);
	p += SSL3_RANDOM_SIZE;

	/* get the session-id */
	j= *(p++);
	if (p + j - d > n)
		goto truncated;

	s->hit = 0;
	/*
	 * Versions before 0.9.7 always allow clients to resume sessions in
	 * renegotiation. 0.9.7 and later allow this by default, but optionally
	 * ignore resumption requests with flag
	 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (it's a new flag
	 * rather than a change to default behavior so that applications
	 * relying on this for security won't even compile against older
	 * library versions).
	 *
	 * 1.0.1 and later also have a function SSL_renegotiate_abbreviated()
	 * to request renegotiation but not a new session (s->new_session
	 * remains unset): for servers, this essentially just means that the
	 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION setting will be
	 * ignored.
	 */
	if ((s->new_session && (s->options &
	    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION))) {
		if (!ssl_get_new_session(s, 1))
			goto err;
	} else {
		i = ssl_get_prev_session(s, p, j, d + n);
		if (i == 1) { /* previous session */
			s->hit = 1;
		} else if (i == -1)
			goto err;
		else {
			/* i == 0 */
			if (!ssl_get_new_session(s, 1))
				goto err;
		}
	}

	p += j;

	if (SSL_IS_DTLS(s)) {
		/* cookie stuff */
		if (p + 1 - d > n)
			goto truncated;
		cookie_len = *(p++);

		/*
		 * The ClientHello may contain a cookie even if the
		 * HelloVerify message has not been sent--make sure that it
		 * does not cause an overflow.
		 */
		if (cookie_len > sizeof(s->d1->rcvd_cookie)) {
			/* too much data */
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
			    SSL_R_COOKIE_MISMATCH);
			goto f_err;
		}

		if (p + cookie_len - d > n)
			goto truncated;

		/* verify the cookie if appropriate option is set. */
		if ((SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&
		    cookie_len > 0) {
			memcpy(s->d1->rcvd_cookie, p, cookie_len);

			if (s->ctx->app_verify_cookie_cb != NULL) {
				if (s->ctx->app_verify_cookie_cb(s,
				    s->d1->rcvd_cookie, cookie_len) == 0) {
					al = SSL_AD_HANDSHAKE_FAILURE;
					SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
					    SSL_R_COOKIE_MISMATCH);
					goto f_err;
				}
				/* else cookie verification succeeded */
			} else if (timingsafe_memcmp(s->d1->rcvd_cookie, s->d1->cookie,
			    s->d1->cookie_len) != 0) {
				/* default verification */
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
				    SSL_R_COOKIE_MISMATCH);
				goto f_err;
			}

			ret = 2;
		}

		p += cookie_len;
	}

	if (p + 2 - d > n)
		goto truncated;
	n2s(p, i);
	if ((i == 0) && (j != 0)) {
		/* we need a cipher if we are not resuming a session */
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
		    SSL_R_NO_CIPHERS_SPECIFIED);
		goto f_err;
	}
	if (p + i - d > n)
		goto truncated;
	if (i > 0) {
		if ((ciphers = ssl_bytes_to_cipher_list(s, p, i)) == NULL)
			goto err;
	}
	p += i;

	/* If it is a hit, check that the cipher is in the list */
	if ((s->hit) && (i > 0)) {
		j = 0;
		id = s->session->cipher->id;

		for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {
			c = sk_SSL_CIPHER_value(ciphers, i);
			if (c->id == id) {
				j = 1;
				break;
			}
		}
		if (j == 0) {
			/*
			 * We need to have the cipher in the cipher
			 * list if we are asked to reuse it
			 */
			al = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
			    SSL_R_REQUIRED_CIPHER_MISSING);
			goto f_err;
		}
	}

	/* compression */
	if (p + 1 - d > n)
		goto truncated;
	i= *(p++);
	if (p + i - d > n)
		goto truncated;
	for (j = 0; j < i; j++) {
		if (p[j] == 0)
			break;
	}

	p += i;
	if (j >= i) {
		/* no compress */
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
		    SSL_R_NO_COMPRESSION_SPECIFIED);
		goto f_err;
	}

	/* TLS extensions*/
	if (!ssl_parse_clienthello_tlsext(s, &p, d, n, &al)) {
		/* 'al' set by ssl_parse_clienthello_tlsext */
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_PARSE_TLSEXT);
		goto f_err;
	}
	if (ssl_check_clienthello_tlsext_early(s) <= 0) {
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
		    SSL_R_CLIENTHELLO_TLSEXT);
		goto err;
	}

	/*
	 * Check if we want to use external pre-shared secret for this
	 * handshake for not reused session only. We need to generate
	 * server_random before calling tls_session_secret_cb in order to allow
	 * SessionTicket processing to use it in key derivation.
	 */
	arc4random_buf(s->s3->server_random, SSL3_RANDOM_SIZE);

	if (!s->hit && s->tls_session_secret_cb) {
		SSL_CIPHER *pref_cipher = NULL;

		s->session->master_key_length = sizeof(s->session->master_key);
		if (s->tls_session_secret_cb(s, s->session->master_key,
		    &s->session->master_key_length, ciphers, &pref_cipher,
		    s->tls_session_secret_cb_arg)) {
			s->hit = 1;
			s->session->ciphers = ciphers;
			s->session->verify_result = X509_V_OK;

			ciphers = NULL;

			/* check if some cipher was preferred by call back */
			pref_cipher = pref_cipher ? pref_cipher :
			    ssl3_choose_cipher(s, s->session->ciphers,
			    SSL_get_ciphers(s));
			if (pref_cipher == NULL) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
				    SSL_R_NO_SHARED_CIPHER);
				goto f_err;
			}

			s->session->cipher = pref_cipher;

			if (s->cipher_list)
				sk_SSL_CIPHER_free(s->cipher_list);

			if (s->cipher_list_by_id)
				sk_SSL_CIPHER_free(s->cipher_list_by_id);

			s->cipher_list = sk_SSL_CIPHER_dup(s->session->ciphers);
			s->cipher_list_by_id =
			    sk_SSL_CIPHER_dup(s->session->ciphers);
		}
	}

	/*
	 * Given s->session->ciphers and SSL_get_ciphers, we must
	 * pick a cipher
	 */

	if (!s->hit) {
		if (s->session->ciphers != NULL)
			sk_SSL_CIPHER_free(s->session->ciphers);
		s->session->ciphers = ciphers;
		if (ciphers == NULL) {
			al = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
			    SSL_R_NO_CIPHERS_PASSED);
			goto f_err;
		}
		ciphers = NULL;
		c = ssl3_choose_cipher(s, s->session->ciphers,
		SSL_get_ciphers(s));

		if (c == NULL) {
			al = SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
			    SSL_R_NO_SHARED_CIPHER);
			goto f_err;
		}
		s->s3->tmp.new_cipher = c;
	} else {
		s->s3->tmp.new_cipher = s->session->cipher;
	}

	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	if (!(SSL_USE_SIGALGS(s) || (alg_k & SSL_kGOST)) ||
	    !(s->verify_mode & SSL_VERIFY_PEER)) {
		if (!tls1_digest_cached_records(s)) {
			al = SSL_AD_INTERNAL_ERROR;
			goto f_err;
		}
	}

	/*
	 * We now have the following setup.
	 * client_random
	 * cipher_list 		- our prefered list of ciphers
	 * ciphers 		- the clients prefered list of ciphers
	 * compression		- basically ignored right now
	 * ssl version is set	- sslv3
	 * s->session		- The ssl session has been setup.
	 * s->hit		- session reuse flag
	 * s->tmp.new_cipher	- the new cipher to use.
	 */

	/* Handles TLS extensions that we couldn't check earlier */
	if (ssl_check_clienthello_tlsext_late(s) <= 0) {
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
		goto err;
	}

	if (ret < 0)
		ret = 1;
	if (0) {
truncated:
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_BAD_PACKET_LENGTH);
f_err:
		ssl3_send_alert(s, SSL3_AL_FATAL, al);
	}
err:
	if (ciphers != NULL)
		sk_SSL_CIPHER_free(ciphers);
	return (ret);
}

int
ssl3_send_server_hello(SSL *s)
{
	unsigned char *bufend;
	unsigned char *p, *d;
	int sl;

	if (s->state == SSL3_ST_SW_SRVR_HELLO_A) {
		d = p = ssl3_handshake_msg_start(s, SSL3_MT_SERVER_HELLO);

		*(p++) = s->version >> 8;
		*(p++) = s->version & 0xff;

		/* Random stuff */
		memcpy(p, s->s3->server_random, SSL3_RANDOM_SIZE);
		p += SSL3_RANDOM_SIZE;

		/*
		 * There are several cases for the session ID to send
		 * back in the server hello:
		 *
		 * - For session reuse from the session cache,
		 *   we send back the old session ID.
		 * - If stateless session reuse (using a session ticket)
		 *   is successful, we send back the client's "session ID"
		 *   (which doesn't actually identify the session).
		 * - If it is a new session, we send back the new
		 *   session ID.
		 * - However, if we want the new session to be single-use,
		 *   we send back a 0-length session ID.
		 *
		 * s->hit is non-zero in either case of session reuse,
		 * so the following won't overwrite an ID that we're supposed
		 * to send back.
		 */
		if (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER)
		    && !s->hit)
			s->session->session_id_length = 0;

		sl = s->session->session_id_length;
		if (sl > (int)sizeof(s->session->session_id)) {
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO,
			    ERR_R_INTERNAL_ERROR);
			return (-1);
		}
		*(p++) = sl;
		memcpy(p, s->session->session_id, sl);
		p += sl;

		/* put the cipher */
		s2n(ssl3_cipher_get_value(s->s3->tmp.new_cipher), p);

		/* put the compression method */
		*(p++) = 0;

		bufend = (unsigned char *)s->init_buf->data +
		    SSL3_RT_MAX_PLAIN_LENGTH;
		if ((p = ssl_add_serverhello_tlsext(s, p, bufend)) == NULL) {
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO,
			    ERR_R_INTERNAL_ERROR);
			return (-1);
		}

		ssl3_handshake_msg_finish(s, p - d);
	}

	/* SSL3_ST_SW_SRVR_HELLO_B */
	return (ssl3_handshake_write(s));
}

int
ssl3_send_server_done(SSL *s)
{
	if (s->state == SSL3_ST_SW_SRVR_DONE_A) {
		ssl3_handshake_msg_start(s, SSL3_MT_SERVER_DONE);
		ssl3_handshake_msg_finish(s, 0);

		s->state = SSL3_ST_SW_SRVR_DONE_B;
	}

	/* SSL3_ST_SW_SRVR_DONE_B */
	return (ssl3_handshake_write(s));
}

int
ssl3_send_server_key_exchange(SSL *s)
{
	unsigned char *q;
	int j, num;
	unsigned char md_buf[MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH];
	unsigned int u;
	DH *dh = NULL, *dhp;
	EC_KEY *ecdh = NULL, *ecdhp;
	unsigned char *encodedPoint = NULL;
	int encodedlen = 0;
	int curve_id = 0;
	BN_CTX *bn_ctx = NULL;

	EVP_PKEY *pkey;
	const EVP_MD *md = NULL;
	unsigned char *p, *d;
	int al, i;
	unsigned long type;
	int n;
	CERT *cert;
	BIGNUM *r[4];
	int nr[4], kn;
	BUF_MEM *buf;
	EVP_MD_CTX md_ctx;

	EVP_MD_CTX_init(&md_ctx);
	if (s->state == SSL3_ST_SW_KEY_EXCH_A) {
		type = s->s3->tmp.new_cipher->algorithm_mkey;
		cert = s->cert;

		buf = s->init_buf;

		r[0] = r[1] = r[2] = r[3] = NULL;
		n = 0;
		if (type & SSL_kDHE) {
			if (s->cert->dh_tmp_auto != 0) {
				if ((dhp = ssl_get_auto_dh(s)) == NULL) {
					al = SSL_AD_INTERNAL_ERROR;
					SSLerr(
					    SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
					    ERR_R_INTERNAL_ERROR);
					goto f_err;
				}
			} else
				dhp = cert->dh_tmp;

			if (dhp == NULL && s->cert->dh_tmp_cb != NULL)
				dhp = s->cert->dh_tmp_cb(s, 0,
				    SSL_C_PKEYLENGTH(s->s3->tmp.new_cipher));

			if (dhp == NULL) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    SSL_R_MISSING_TMP_DH_KEY);
				goto f_err;
			}

			if (s->s3->tmp.dh != NULL) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}

			if (s->cert->dh_tmp_auto != 0) {
				dh = dhp;
			} else if ((dh = DHparams_dup(dhp)) == NULL) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				goto err;
			}
			s->s3->tmp.dh = dh;
			if (!DH_generate_key(dh)) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				goto err;
			}
			r[0] = dh->p;
			r[1] = dh->g;
			r[2] = dh->pub_key;
		} else if (type & SSL_kECDHE) {
			const EC_GROUP *group;

			ecdhp = cert->ecdh_tmp;
			if (s->cert->ecdh_tmp_auto != 0) {
				int nid = tls1_get_shared_curve(s);
				if (nid != NID_undef)
					ecdhp = EC_KEY_new_by_curve_name(nid);
			} else if (ecdhp == NULL &&
			    s->cert->ecdh_tmp_cb != NULL) {
				ecdhp = s->cert->ecdh_tmp_cb(s, 0,
				    SSL_C_PKEYLENGTH(s->s3->tmp.new_cipher));
			}
			if (ecdhp == NULL) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    SSL_R_MISSING_TMP_ECDH_KEY);
				goto f_err;
			}

			if (s->s3->tmp.ecdh != NULL) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}

			/* Duplicate the ECDH structure. */
			if (s->cert->ecdh_tmp_auto != 0) {
				ecdh = ecdhp;
			} else if ((ecdh = EC_KEY_dup(ecdhp)) == NULL) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_ECDH_LIB);
				goto err;
			}
			s->s3->tmp.ecdh = ecdh;

			if ((EC_KEY_get0_public_key(ecdh) == NULL) ||
			    (EC_KEY_get0_private_key(ecdh) == NULL) ||
			    (s->options & SSL_OP_SINGLE_ECDH_USE)) {
				if (!EC_KEY_generate_key(ecdh)) {
					SSLerr(
					    SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
					    ERR_R_ECDH_LIB);
					goto err;
				}
			}

			if (((group = EC_KEY_get0_group(ecdh)) == NULL) ||
			    (EC_KEY_get0_public_key(ecdh)  == NULL) ||
			    (EC_KEY_get0_private_key(ecdh) == NULL)) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_ECDH_LIB);
				goto err;
			}

			/*
			 * XXX: For now, we only support ephemeral ECDH
			 * keys over named (not generic) curves. For
			 * supported named curves, curve_id is non-zero.
			 */
			if ((curve_id = tls1_ec_nid2curve_id(
			    EC_GROUP_get_curve_name(group))) == 0) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);
				goto err;
			}

			/*
			 * Encode the public key.
			 * First check the size of encoding and
			 * allocate memory accordingly.
			 */
			encodedlen = EC_POINT_point2oct(group,
			    EC_KEY_get0_public_key(ecdh),
			    POINT_CONVERSION_UNCOMPRESSED,
			    NULL, 0, NULL);

			encodedPoint = malloc(encodedlen);

			bn_ctx = BN_CTX_new();
			if ((encodedPoint == NULL) || (bn_ctx == NULL)) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}


			encodedlen = EC_POINT_point2oct(group,
			    EC_KEY_get0_public_key(ecdh),
			    POINT_CONVERSION_UNCOMPRESSED,
			    encodedPoint, encodedlen, bn_ctx);

			if (encodedlen == 0) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_ECDH_LIB);
				goto err;
			}

			BN_CTX_free(bn_ctx);
			bn_ctx = NULL;

			/*
			 * XXX: For now, we only support named (not
			 * generic) curves in ECDH ephemeral key exchanges.
			 * In this situation, we need four additional bytes
			 * to encode the entire ServerECDHParams
			 * structure.
			 */
			n = 4 + encodedlen;

			/*
			 * We'll generate the serverKeyExchange message
			 * explicitly so we can set these to NULLs
			 */
			r[0] = NULL;
			r[1] = NULL;
			r[2] = NULL;
			r[3] = NULL;
		} else
		{
			al = SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
			    SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
			goto f_err;
		}
		for (i = 0; i < 4 && r[i] != NULL; i++) {
			nr[i] = BN_num_bytes(r[i]);
			n += 2 + nr[i];
		}

		if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)) {
			if ((pkey = ssl_get_sign_pkey(
			    s, s->s3->tmp.new_cipher, &md)) == NULL) {
				al = SSL_AD_DECODE_ERROR;
				goto f_err;
			}
			kn = EVP_PKEY_size(pkey);
		} else {
			pkey = NULL;
			kn = 0;
		}

		if (!BUF_MEM_grow_clean(buf, ssl3_handshake_msg_hdr_len(s) +
		    n + kn)) {
			SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
			    ERR_LIB_BUF);
			goto err;
		}

		d = p = ssl3_handshake_msg_start(s,
		    SSL3_MT_SERVER_KEY_EXCHANGE);

		for (i = 0; i < 4 && r[i] != NULL; i++) {
			s2n(nr[i], p);
			BN_bn2bin(r[i], p);
			p += nr[i];
		}

		if (type & SSL_kECDHE) {
			/*
			 * XXX: For now, we only support named (not generic)
			 * curves.
			 * In this situation, the serverKeyExchange message has:
			 * [1 byte CurveType], [2 byte CurveName]
			 * [1 byte length of encoded point], followed by
			 * the actual encoded point itself
			 */
			*p = NAMED_CURVE_TYPE;
			p += 1;
			*p = 0;
			p += 1;
			*p = curve_id;
			p += 1;
			*p = encodedlen;
			p += 1;
			memcpy((unsigned char*)p,
			    (unsigned char *)encodedPoint, encodedlen);
			free(encodedPoint);
			encodedPoint = NULL;
			p += encodedlen;
		}


		/* not anonymous */
		if (pkey != NULL) {
			/*
			 * n is the length of the params, they start at &(d[4])
			 * and p points to the space at the end.
			 */
			if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s)) {
				q = md_buf;
				j = 0;
				for (num = 2; num > 0; num--) {
					if (!EVP_DigestInit_ex(&md_ctx,
					    (num == 2) ? s->ctx->md5 :
					    s->ctx->sha1, NULL))
						goto err;
					EVP_DigestUpdate(&md_ctx,
					    s->s3->client_random,
					    SSL3_RANDOM_SIZE);
					EVP_DigestUpdate(&md_ctx,
					    s->s3->server_random,
					    SSL3_RANDOM_SIZE);
					EVP_DigestUpdate(&md_ctx, d, n);
					EVP_DigestFinal_ex(&md_ctx, q,
					    (unsigned int *)&i);
					q += i;
					j += i;
				}
				if (RSA_sign(NID_md5_sha1, md_buf, j,
				    &(p[2]), &u, pkey->pkey.rsa) <= 0) {
					SSLerr(
					    SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
					    ERR_LIB_RSA);
					goto err;
				}
				s2n(u, p);
				n += u + 2;
			} else if (md) {
				/* Send signature algorithm. */
				if (SSL_USE_SIGALGS(s)) {
					if (!tls12_get_sigandhash(p, pkey, md)) {
						/* Should never happen */
						al = SSL_AD_INTERNAL_ERROR;
						SSLerr(
						    SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
						    ERR_R_INTERNAL_ERROR);
						goto f_err;
					}
					p += 2;
				}
				EVP_SignInit_ex(&md_ctx, md, NULL);
				EVP_SignUpdate(&md_ctx,
				    s->s3->client_random,
				    SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,
				    s->s3->server_random,
				    SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx, d, n);
				if (!EVP_SignFinal(&md_ctx, &p[2],
					(unsigned int *)&i, pkey)) {
					SSLerr(
					    SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
					    ERR_LIB_EVP);
					goto err;
				}
				s2n(i, p);
				n += i + 2;
				if (SSL_USE_SIGALGS(s))
					n += 2;
			} else {
				/* Is this error check actually needed? */
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    SSL_R_UNKNOWN_PKEY_TYPE);
				goto f_err;
			}
		}

		ssl3_handshake_msg_finish(s, n);
	}

	s->state = SSL3_ST_SW_KEY_EXCH_B;
	EVP_MD_CTX_cleanup(&md_ctx);

	return (ssl3_handshake_write(s));
	
f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	free(encodedPoint);
	BN_CTX_free(bn_ctx);
	EVP_MD_CTX_cleanup(&md_ctx);
	return (-1);
}

int
ssl3_send_certificate_request(SSL *s)
{
	unsigned char *p, *d;
	int i, j, nl, off, n;
	STACK_OF(X509_NAME) *sk = NULL;
	X509_NAME *name;
	BUF_MEM *buf;

	if (s->state == SSL3_ST_SW_CERT_REQ_A) {
		buf = s->init_buf;

		d = p = ssl3_handshake_msg_start(s,
		    SSL3_MT_CERTIFICATE_REQUEST);

		/* get the list of acceptable cert types */
		p++;
		n = ssl3_get_req_cert_type(s, p);
		d[0] = n;
		p += n;
		n++;

		if (SSL_USE_SIGALGS(s)) {
			nl = tls12_get_req_sig_algs(s, p + 2);
			s2n(nl, p);
			p += nl + 2;
			n += nl + 2;
		}

		off = n;
		p += 2;
		n += 2;

		sk = SSL_get_client_CA_list(s);
		nl = 0;
		if (sk != NULL) {
			for (i = 0; i < sk_X509_NAME_num(sk); i++) {
				name = sk_X509_NAME_value(sk, i);
				j = i2d_X509_NAME(name, NULL);
				if (!BUF_MEM_grow_clean(buf,
				    ssl3_handshake_msg_hdr_len(s) + n + j
				    + 2)) {
					SSLerr(
					    SSL_F_SSL3_SEND_CERTIFICATE_REQUEST,
					    ERR_R_BUF_LIB);
					goto err;
				}
				p = ssl3_handshake_msg_start(s,
				    SSL3_MT_CERTIFICATE_REQUEST) + n;
				s2n(j, p);
				i2d_X509_NAME(name, &p);
				n += 2 + j;
				nl += 2 + j;
			}
		}
		/* else no CA names */
		p = ssl3_handshake_msg_start(s,
		    SSL3_MT_CERTIFICATE_REQUEST) + off;
		s2n(nl, p);

		ssl3_handshake_msg_finish(s, n);

		s->state = SSL3_ST_SW_CERT_REQ_B;
	}

	/* SSL3_ST_SW_CERT_REQ_B */
	return (ssl3_handshake_write(s));
err:
	return (-1);
}

int
ssl3_get_client_key_exchange(SSL *s)
{
	int i, al, ok;
	long n;
	unsigned long alg_k;
	unsigned char *d, *p;
	RSA *rsa = NULL;
	EVP_PKEY *pkey = NULL;
	BIGNUM *pub = NULL;
	DH *dh_srvr;

	EC_KEY *srvr_ecdh = NULL;
	EVP_PKEY *clnt_pub_pkey = NULL;
	EC_POINT *clnt_ecpoint = NULL;
	BN_CTX *bn_ctx = NULL;

	/* 2048 maxlen is a guess.  How long a key does that permit? */
	n = s->method->ssl_get_message(s, SSL3_ST_SR_KEY_EXCH_A,
	    SSL3_ST_SR_KEY_EXCH_B, SSL3_MT_CLIENT_KEY_EXCHANGE, 2048, &ok);
	if (!ok)
		return ((int)n);
	d = p = (unsigned char *)s->init_msg;

	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;

	if (alg_k & SSL_kRSA) {
		char fakekey[SSL_MAX_MASTER_KEY_LENGTH];

		arc4random_buf(fakekey, sizeof(fakekey));
		fakekey[0] = s->client_version >> 8;
		fakekey[1] = s->client_version & 0xff;

		pkey = s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey;
		if ((pkey == NULL) || (pkey->type != EVP_PKEY_RSA) ||
		    (pkey->pkey.rsa == NULL)) {
			al = SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_MISSING_RSA_CERTIFICATE);
			goto f_err;
		}
		rsa = pkey->pkey.rsa;

		if (2 > n)
			goto truncated;
		n2s(p, i);
		if (n != i + 2) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
			goto err;
		} else
			n = i;

		i = RSA_private_decrypt((int)n, p, p, rsa, RSA_PKCS1_PADDING);

		ERR_clear_error();

		al = -1;

		if (i != SSL_MAX_MASTER_KEY_LENGTH) {
			al = SSL_AD_DECODE_ERROR;
			/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT); */
		}

		if (p + 2 - d > n)	/* needed in the SSL3 case */
			goto truncated;
		if ((al == -1) && !((p[0] == (s->client_version >> 8)) &&
		    (p[1] == (s->client_version & 0xff)))) {
			/*
			 * The premaster secret must contain the same version
			 * number as the ClientHello to detect version rollback
			 * attacks (strangely, the protocol does not offer such
			 * protection for DH ciphersuites).
			 * However, buggy clients exist that send the negotiated
			 * protocol version instead if the server does not
			 * support the requested protocol version.
			 * If SSL_OP_TLS_ROLLBACK_BUG is set, tolerate such
			 * clients.
			 */
			if (!((s->options & SSL_OP_TLS_ROLLBACK_BUG) &&
			    (p[0] == (s->version >> 8)) &&
			    (p[1] == (s->version & 0xff)))) {
				al = SSL_AD_DECODE_ERROR;
				/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER); */

				/*
				 * The Klima-Pokorny-Rosa extension of
				 * Bleichenbacher's attack
				 * (http://eprint.iacr.org/2003/052/) exploits
				 * the version number check as a "bad version
				 * oracle" -- an alert would reveal that the
				 * plaintext corresponding to some ciphertext
				 * made up by the adversary is properly
				 * formatted except that the version number is
				 * wrong.
				 * To avoid such attacks, we should treat this
				 * just like any other decryption error.
				 */
			}
		}

		if (al != -1) {
			/*
			 * Some decryption failure -- use random value instead
			 * as countermeasure against Bleichenbacher's attack
			 * on PKCS #1 v1.5 RSA padding (see RFC 2246,
			 * section 7.4.7.1).
			 */
			i = SSL_MAX_MASTER_KEY_LENGTH;
			p = fakekey;
		}

		s->session->master_key_length =
		    s->method->ssl3_enc->generate_master_secret(s,
		    s->session->master_key,
		    p, i);
		explicit_bzero(p, i);
	} else if (alg_k & SSL_kDHE) {
		if (2 > n)
			goto truncated;
		n2s(p, i);
		if (n != i + 2) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
			goto err;
		}

		if (n == 0L) {
			/* the parameters are in the cert */
			al = SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_UNABLE_TO_DECODE_DH_CERTS);
			goto f_err;
		} else {
			if (s->s3->tmp.dh == NULL) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    SSL_R_MISSING_TMP_DH_KEY);
				goto f_err;
			} else
				dh_srvr = s->s3->tmp.dh;
		}

		pub = BN_bin2bn(p, i, NULL);
		if (pub == NULL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_BN_LIB);
			goto err;
		}

		i = DH_compute_key(p, pub, dh_srvr);

		if (i <= 0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_DH_LIB);
			BN_clear_free(pub);
			goto err;
		}

		DH_free(s->s3->tmp.dh);
		s->s3->tmp.dh = NULL;

		BN_clear_free(pub);
		pub = NULL;
		s->session->master_key_length =
		    s->method->ssl3_enc->generate_master_secret(
		        s, s->session->master_key, p, i);
		explicit_bzero(p, i);
	} else

	if (alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe)) {
		int ret = 1;
		int key_size;
		const EC_KEY   *tkey;
		const EC_GROUP *group;
		const BIGNUM *priv_key;

		/* Initialize structures for server's ECDH key pair. */
		if ((srvr_ecdh = EC_KEY_new()) == NULL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}

		/* Let's get server private key and group information. */
		if (alg_k & (SSL_kECDHr|SSL_kECDHe)) {
			/* Use the certificate */
			tkey = s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec;
		} else {
			/*
			 * Use the ephermeral values we saved when
			 * generating the ServerKeyExchange msg.
			 */
			tkey = s->s3->tmp.ecdh;
		}

		group = EC_KEY_get0_group(tkey);
		priv_key = EC_KEY_get0_private_key(tkey);

		if (!EC_KEY_set_group(srvr_ecdh, group) ||
		    !EC_KEY_set_private_key(srvr_ecdh, priv_key)) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_EC_LIB);
			goto err;
		}

		/* Let's get client's public key */
		if ((clnt_ecpoint = EC_POINT_new(group)) == NULL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}

		if (n == 0L) {
			/* Client Publickey was in Client Certificate */

			if (alg_k & SSL_kECDHE) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    SSL_R_MISSING_TMP_ECDH_KEY);
				goto f_err;
			}
			if (((clnt_pub_pkey = X509_get_pubkey(
			    s->session->peer)) == NULL) ||
			    (clnt_pub_pkey->type != EVP_PKEY_EC)) {
				/*
				 * XXX: For now, we do not support client
				 * authentication using ECDH certificates
				 * so this branch (n == 0L) of the code is
				 * never executed. When that support is
				 * added, we ought to ensure the key
				 * received in the certificate is
				 * authorized for key agreement.
				 * ECDH_compute_key implicitly checks that
				 * the two ECDH shares are for the same
				 * group.
				 */
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    SSL_R_UNABLE_TO_DECODE_ECDH_CERTS);
				goto f_err;
			}

			if (EC_POINT_copy(clnt_ecpoint,
			    EC_KEY_get0_public_key(clnt_pub_pkey->pkey.ec))
			    == 0) {
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    ERR_R_EC_LIB);
				goto err;
			}
			ret = 2; /* Skip certificate verify processing */
		} else {
			/*
			 * Get client's public key from encoded point
			 * in the ClientKeyExchange message.
			 */
			if ((bn_ctx = BN_CTX_new()) == NULL) {
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}

			/* Get encoded point length */
			i = *p;

			p += 1;
			if (n != 1 + i) {
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    ERR_R_EC_LIB);
				goto err;
			}
			if (EC_POINT_oct2point(group,
				clnt_ecpoint, p, i, bn_ctx) == 0) {
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    ERR_R_EC_LIB);
				goto err;
			}
			/*
			 * p is pointing to somewhere in the buffer
			 * currently, so set it to the start.
			 */
			p = (unsigned char *)s->init_buf->data;
		}

		/* Compute the shared pre-master secret */
		key_size = ECDH_size(srvr_ecdh);
		if (key_size <= 0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_ECDH_LIB);
			goto err;
		}
		i = ECDH_compute_key(p, key_size, clnt_ecpoint, srvr_ecdh,
		    NULL);
		if (i <= 0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_ECDH_LIB);
			goto err;
		}

		EVP_PKEY_free(clnt_pub_pkey);
		EC_POINT_free(clnt_ecpoint);
		EC_KEY_free(srvr_ecdh);
		BN_CTX_free(bn_ctx);
		EC_KEY_free(s->s3->tmp.ecdh);
		s->s3->tmp.ecdh = NULL;


		/* Compute the master secret */
		s->session->master_key_length = s->method->ssl3_enc-> \
		    generate_master_secret(s, s->session->master_key, p, i);

		explicit_bzero(p, i);
		return (ret);
	} else
	if (alg_k & SSL_kGOST) {
		int ret = 0;
		EVP_PKEY_CTX *pkey_ctx;
		EVP_PKEY *client_pub_pkey = NULL, *pk = NULL;
		unsigned char premaster_secret[32], *start;
		size_t outlen = 32, inlen;
		unsigned long alg_a;
		int Ttag, Tclass;
		long Tlen;

		/* Get our certificate private key*/
		alg_a = s->s3->tmp.new_cipher->algorithm_auth;
		if (alg_a & SSL_aGOST01)
			pk = s->cert->pkeys[SSL_PKEY_GOST01].privatekey;

		pkey_ctx = EVP_PKEY_CTX_new(pk, NULL);
		EVP_PKEY_decrypt_init(pkey_ctx);
		/*
		 * If client certificate is present and is of the same type,
		 * maybe use it for key exchange.
		 * Don't mind errors from EVP_PKEY_derive_set_peer, because
		 * it is completely valid to use a client certificate for
		 * authorization only.
		 */
		client_pub_pkey = X509_get_pubkey(s->session->peer);
		if (client_pub_pkey) {
			if (EVP_PKEY_derive_set_peer(pkey_ctx,
			    client_pub_pkey) <= 0)
				ERR_clear_error();
		}
		if (2 > n)
			goto truncated;
		/* Decrypt session key */
		if (ASN1_get_object((const unsigned char **)&p, &Tlen, &Ttag,
		    &Tclass, n) != V_ASN1_CONSTRUCTED ||
		    Ttag != V_ASN1_SEQUENCE || Tclass != V_ASN1_UNIVERSAL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DECRYPTION_FAILED);
			goto gerr;
		}
		start = p;
		inlen = Tlen;
		if (EVP_PKEY_decrypt(pkey_ctx, premaster_secret, &outlen,
		    start, inlen) <=0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DECRYPTION_FAILED);
			goto gerr;
		}
		/* Generate master secret */
		s->session->master_key_length =
		    s->method->ssl3_enc->generate_master_secret(
		    s, s->session->master_key, premaster_secret, 32);
		/* Check if pubkey from client certificate was used */
		if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, -1,
		    EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0)
			ret = 2;
		else
			ret = 1;
gerr:
		EVP_PKEY_free(client_pub_pkey);
		EVP_PKEY_CTX_free(pkey_ctx);
		if (ret)
			return (ret);
		else
			goto err;
	} else {
		al = SSL_AD_HANDSHAKE_FAILURE;
		SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
		    SSL_R_UNKNOWN_CIPHER_TYPE);
		goto f_err;
	}

	return (1);
truncated:
	al = SSL_AD_DECODE_ERROR;
	SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_BAD_PACKET_LENGTH);
f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	EVP_PKEY_free(clnt_pub_pkey);
	EC_POINT_free(clnt_ecpoint);
	EC_KEY_free(srvr_ecdh);
	BN_CTX_free(bn_ctx);
	return (-1);
}

int
ssl3_get_cert_verify(SSL *s)
{
	EVP_PKEY *pkey = NULL;
	unsigned char *p;
	int al, ok, ret = 0;
	long n;
	int type = 0, i, j;
	X509 *peer;
	const EVP_MD *md = NULL;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);

	n = s->method->ssl_get_message(s, SSL3_ST_SR_CERT_VRFY_A,
	    SSL3_ST_SR_CERT_VRFY_B, -1, SSL3_RT_MAX_PLAIN_LENGTH, &ok);
	if (!ok)
		return ((int)n);

	if (s->session->peer != NULL) {
		peer = s->session->peer;
		pkey = X509_get_pubkey(peer);
		type = X509_certificate_type(peer, pkey);
	} else {
		peer = NULL;
		pkey = NULL;
	}

	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY) {
		s->s3->tmp.reuse_message = 1;
		if (peer != NULL) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_MISSING_VERIFY_MESSAGE);
			goto f_err;
		}
		ret = 1;
		goto end;
	}

	if (peer == NULL) {
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
		    SSL_R_NO_CLIENT_CERT_RECEIVED);
		al = SSL_AD_UNEXPECTED_MESSAGE;
		goto f_err;
	}

	if (!(type & EVP_PKT_SIGN)) {
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
		    SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
		al = SSL_AD_ILLEGAL_PARAMETER;
		goto f_err;
	}

	if (s->s3->change_cipher_spec) {
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
		    SSL_R_CCS_RECEIVED_EARLY);
		al = SSL_AD_UNEXPECTED_MESSAGE;
		goto f_err;
	}

	/* we now have a signature that we need to verify */
	p = (unsigned char *)s->init_msg;
	/*
	 * Check for broken implementations of GOST ciphersuites.
	 *
	 * If key is GOST and n is exactly 64, it is a bare
	 * signature without length field.
	 */
	if (n == 64 && (pkey->type == NID_id_GostR3410_94 ||
	    pkey->type == NID_id_GostR3410_2001) ) {
		i = 64;
	} else {
		if (SSL_USE_SIGALGS(s)) {
			int sigalg = tls12_get_sigid(pkey);
			/* Should never happen */
			if (sigalg == -1) {
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
				    ERR_R_INTERNAL_ERROR);
				al = SSL_AD_INTERNAL_ERROR;
				goto f_err;
			}
			if (2 > n)
				goto truncated;
			/* Check key type is consistent with signature */
			if (sigalg != (int)p[1]) {
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
				    SSL_R_WRONG_SIGNATURE_TYPE);
				al = SSL_AD_DECODE_ERROR;
				goto f_err;
			}
			md = tls12_get_hash(p[0]);
			if (md == NULL) {
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
				    SSL_R_UNKNOWN_DIGEST);
				al = SSL_AD_DECODE_ERROR;
				goto f_err;
			}
			p += 2;
			n -= 2;
		}
		if (2 > n)
			goto truncated;
		n2s(p, i);
		n -= 2;
		if (i > n)
			goto truncated;
	}
	j = EVP_PKEY_size(pkey);
	if ((i > j) || (n > j) || (n <= 0)) {
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
		    SSL_R_WRONG_SIGNATURE_SIZE);
		al = SSL_AD_DECODE_ERROR;
		goto f_err;
	}

	if (SSL_USE_SIGALGS(s)) {
		long hdatalen = 0;
		void *hdata;
		hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
		if (hdatalen <= 0) {
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    ERR_R_INTERNAL_ERROR);
			al = SSL_AD_INTERNAL_ERROR;
			goto f_err;
		}
		if (!EVP_VerifyInit_ex(&mctx, md, NULL) ||
		    !EVP_VerifyUpdate(&mctx, hdata, hdatalen)) {
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    ERR_R_EVP_LIB);
			al = SSL_AD_INTERNAL_ERROR;
			goto f_err;
		}

		if (EVP_VerifyFinal(&mctx, p, i, pkey) <= 0) {
			al = SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_BAD_SIGNATURE);
			goto f_err;
		}
	} else
	if (pkey->type == EVP_PKEY_RSA) {
		i = RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,
		    MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH, p, i,
		    pkey->pkey.rsa);
		if (i < 0) {
			al = SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_BAD_RSA_DECRYPT);
			goto f_err;
		}
		if (i == 0) {
			al = SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_BAD_RSA_SIGNATURE);
			goto f_err;
		}
	} else
	if (pkey->type == EVP_PKEY_DSA) {
		j = DSA_verify(pkey->save_type,
		    &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
		    SHA_DIGEST_LENGTH, p, i, pkey->pkey.dsa);
		if (j <= 0) {
			/* bad signature */
			al = SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_BAD_DSA_SIGNATURE);
			goto f_err;
		}
	} else
	if (pkey->type == EVP_PKEY_EC) {
		j = ECDSA_verify(pkey->save_type,
		    &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
		    SHA_DIGEST_LENGTH, p, i, pkey->pkey.ec);
		if (j <= 0) {
			/* bad signature */
			al = SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_BAD_ECDSA_SIGNATURE);
			goto f_err;
		}
	} else
#ifndef OPENSSL_NO_GOST
	if (pkey->type == NID_id_GostR3410_94 ||
	    pkey->type == NID_id_GostR3410_2001) {
		long hdatalen = 0;
		void *hdata;
		unsigned char signature[128];
		unsigned int siglen = sizeof(signature);
		int nid;
		EVP_PKEY_CTX *pctx;

		hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
		if (hdatalen <= 0) {
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    ERR_R_INTERNAL_ERROR);
			al = SSL_AD_INTERNAL_ERROR;
			goto f_err;
		}
		if (!EVP_PKEY_get_default_digest_nid(pkey, &nid) ||
				!(md = EVP_get_digestbynid(nid))) {
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
					ERR_R_EVP_LIB);
			al = SSL_AD_INTERNAL_ERROR;
			goto f_err;
		}
		pctx = EVP_PKEY_CTX_new(pkey, NULL);
		if (!pctx) {
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    ERR_R_EVP_LIB);
			al = SSL_AD_INTERNAL_ERROR;
			goto f_err;
		}
		if (!EVP_DigestInit_ex(&mctx, md, NULL) ||
		    !EVP_DigestUpdate(&mctx, hdata, hdatalen) ||
		    !EVP_DigestFinal(&mctx, signature, &siglen) ||
		    (EVP_PKEY_verify_init(pctx) <= 0) ||
		    (EVP_PKEY_CTX_set_signature_md(pctx, md) <= 0) ||
		    (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_VERIFY,
				       EVP_PKEY_CTRL_GOST_SIG_FORMAT,
				       GOST_SIG_FORMAT_RS_LE,
				       NULL) <= 0)) {
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    ERR_R_EVP_LIB);
			al = SSL_AD_INTERNAL_ERROR;
			EVP_PKEY_CTX_free(pctx);
			goto f_err;
		}

		if (EVP_PKEY_verify(pctx, p, i, signature, siglen) <= 0) {
			al = SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_BAD_SIGNATURE);
			EVP_PKEY_CTX_free(pctx);
			goto f_err;
		}

		EVP_PKEY_CTX_free(pctx);
	} else
#endif
	{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
		    ERR_R_INTERNAL_ERROR);
		al = SSL_AD_UNSUPPORTED_CERTIFICATE;
		goto f_err;
	}


	ret = 1;
	if (0) {
truncated:
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_PACKET_LENGTH);
f_err:
		ssl3_send_alert(s, SSL3_AL_FATAL, al);
	}
end:
	if (s->s3->handshake_buffer) {
		BIO_free(s->s3->handshake_buffer);
		s->s3->handshake_buffer = NULL;
		s->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;
	}
	EVP_MD_CTX_cleanup(&mctx);
	EVP_PKEY_free(pkey);
	return (ret);
}

int
ssl3_get_client_certificate(SSL *s)
{
	CBS cbs, client_certs;
	int i, ok, al, ret = -1;
	X509 *x = NULL;
	long n;
	const unsigned char *q;
	STACK_OF(X509) *sk = NULL;

	n = s->method->ssl_get_message(s, SSL3_ST_SR_CERT_A, SSL3_ST_SR_CERT_B,
	    -1, s->max_cert_list, &ok);

	if (!ok)
		return ((int)n);

	if (s->s3->tmp.message_type == SSL3_MT_CLIENT_KEY_EXCHANGE) {
		if ((s->verify_mode & SSL_VERIFY_PEER) &&
		    (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {
		    	SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
			    SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
			al = SSL_AD_HANDSHAKE_FAILURE;
			goto f_err;
		}
		/*
		 * If tls asked for a client cert,
		 * the client must return a 0 list.
		 */
		if (s->s3->tmp.cert_request) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
			    SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST
			    );
			al = SSL_AD_UNEXPECTED_MESSAGE;
			goto f_err;
		}
		s->s3->tmp.reuse_message = 1;
		return (1);
	}

	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE) {
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
		    SSL_R_WRONG_MESSAGE_TYPE);
		goto f_err;
	}

	if (n < 0)
		goto truncated;

	CBS_init(&cbs, s->init_msg, n);

	if ((sk = sk_X509_new_null()) == NULL) {
		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
		    ERR_R_MALLOC_FAILURE);
		goto err;
	}

	if (!CBS_get_u24_length_prefixed(&cbs, &client_certs) ||
	    CBS_len(&cbs) != 0)
		goto truncated;

	while (CBS_len(&client_certs) > 0) {
		CBS cert;

		if (!CBS_get_u24_length_prefixed(&client_certs, &cert)) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
			    SSL_R_CERT_LENGTH_MISMATCH);
			goto f_err;
		}

		q = CBS_data(&cert);
		x = d2i_X509(NULL, &q, CBS_len(&cert));
		if (x == NULL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
			    ERR_R_ASN1_LIB);
			goto err;
		}
		if (q != CBS_data(&cert) + CBS_len(&cert)) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
			    SSL_R_CERT_LENGTH_MISMATCH);
			goto f_err;
		}
		if (!sk_X509_push(sk, x)) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}
		x = NULL;
	}

	if (sk_X509_num(sk) <= 0) {
		/*
		 * TLS does not mind 0 certs returned.
		 * Fail for TLS only if we required a certificate.
		 */
		if ((s->verify_mode & SSL_VERIFY_PEER) &&
		    (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
			    SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
			al = SSL_AD_HANDSHAKE_FAILURE;
			goto f_err;
		}
		/* No client certificate so digest cached records */
		if (s->s3->handshake_buffer && !tls1_digest_cached_records(s)) {
			al = SSL_AD_INTERNAL_ERROR;
			goto f_err;
		}
	} else {
		i = ssl_verify_cert_chain(s, sk);
		if (i <= 0) {
			al = ssl_verify_alarm_type(s->verify_result);
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
			    SSL_R_NO_CERTIFICATE_RETURNED);
			goto f_err;
		}
	}

	X509_free(s->session->peer);
	s->session->peer = sk_X509_shift(sk);
	s->session->verify_result = s->verify_result;

	/*
	 * With the current implementation, sess_cert will always be NULL
	 * when we arrive here
	 */
	if (s->session->sess_cert == NULL) {
		s->session->sess_cert = ssl_sess_cert_new();
		if (s->session->sess_cert == NULL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}
	if (s->session->sess_cert->cert_chain != NULL)
		sk_X509_pop_free(s->session->sess_cert->cert_chain, X509_free);
	s->session->sess_cert->cert_chain = sk;

	/*
	 * Inconsistency alert: cert_chain does *not* include the
	 * peer's own certificate, while we do include it in s3_clnt.c
	 */

	sk = NULL;

	ret = 1;
	if (0) {
truncated:
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
		    SSL_R_BAD_PACKET_LENGTH);
f_err:
		ssl3_send_alert(s, SSL3_AL_FATAL, al);
	}
err:
	X509_free(x);
	if (sk != NULL)
		sk_X509_pop_free(sk, X509_free);
	return (ret);
}

int
ssl3_send_server_certificate(SSL *s)
{
	unsigned long l;
	X509 *x;

	if (s->state == SSL3_ST_SW_CERT_A) {
		x = ssl_get_server_send_cert(s);
		if (x == NULL) {
			SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
			    ERR_R_INTERNAL_ERROR);
			return (0);
		}

		l = ssl3_output_cert_chain(s, x);
		s->state = SSL3_ST_SW_CERT_B;
		s->init_num = (int)l;
		s->init_off = 0;
	}

	/* SSL3_ST_SW_CERT_B */
	return (ssl3_handshake_write(s));
}

/* send a new session ticket (not necessarily for a new session) */
int
ssl3_send_newsession_ticket(SSL *s)
{
	if (s->state == SSL3_ST_SW_SESSION_TICKET_A) {
		unsigned char *d, *p, *senc, *macstart;
		const unsigned char *const_p;
		int len, slen_full, slen;
		SSL_SESSION *sess;
		unsigned int hlen;
		EVP_CIPHER_CTX ctx;
		HMAC_CTX hctx;
		SSL_CTX *tctx = s->initial_ctx;
		unsigned char iv[EVP_MAX_IV_LENGTH];
		unsigned char key_name[16];

		/* get session encoding length */
		slen_full = i2d_SSL_SESSION(s->session, NULL);
		/*
		 * Some length values are 16 bits, so forget it if session is
 		 * too long
 		 */
		if (slen_full > 0xFF00)
			return (-1);
		senc = malloc(slen_full);
		if (!senc)
			return (-1);
		p = senc;
		i2d_SSL_SESSION(s->session, &p);

		/*
		 * Create a fresh copy (not shared with other threads) to
		 * clean up
		 */
		const_p = senc;
		sess = d2i_SSL_SESSION(NULL, &const_p, slen_full);
		if (sess == NULL) {
			free(senc);
			return (-1);
		}

		/* ID is irrelevant for the ticket */
		sess->session_id_length = 0;

		slen = i2d_SSL_SESSION(sess, NULL);
		if (slen > slen_full) {
			/* shouldn't ever happen */
			free(senc);
			return (-1);
		}
		p = senc;
		i2d_SSL_SESSION(sess, &p);
		SSL_SESSION_free(sess);

		/*
		 * Grow buffer if need be: the length calculation is as
 		 * follows 1 (size of message name) + 3 (message length
 		 * bytes) + 4 (ticket lifetime hint) + 2 (ticket length) +
 		 * 16 (key name) + max_iv_len (iv length) +
 		 * session_length + max_enc_block_size (max encrypted session
 		 * length) + max_md_size (HMAC).
 		 */
		if (!BUF_MEM_grow(s->init_buf, ssl3_handshake_msg_hdr_len(s) +
		    22 + EVP_MAX_IV_LENGTH + EVP_MAX_BLOCK_LENGTH +
		    EVP_MAX_MD_SIZE + slen)) {
			free(senc);
			return (-1);
		}

		d = p = ssl3_handshake_msg_start(s, SSL3_MT_NEWSESSION_TICKET);

		EVP_CIPHER_CTX_init(&ctx);
		HMAC_CTX_init(&hctx);

		/*
		 * Initialize HMAC and cipher contexts. If callback present
		 * it does all the work otherwise use generated values
		 * from parent ctx.
		 */
		if (tctx->tlsext_ticket_key_cb) {
			if (tctx->tlsext_ticket_key_cb(s, key_name, iv, &ctx,
			    &hctx, 1) < 0) {
				free(senc);
				EVP_CIPHER_CTX_cleanup(&ctx);
				return (-1);
			}
		} else {
			arc4random_buf(iv, 16);
			EVP_EncryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,
			    tctx->tlsext_tick_aes_key, iv);
			HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
			    tlsext_tick_md(), NULL);
			memcpy(key_name, tctx->tlsext_tick_key_name, 16);
		}

		/*
		 * Ticket lifetime hint (advisory only):
		 * We leave this unspecified for resumed session
		 * (for simplicity), and guess that tickets for new
		 * sessions will live as long as their sessions.
		 */
		l2n(s->hit ? 0 : s->session->timeout, p);

		/* Skip ticket length for now */
		p += 2;
		/* Output key name */
		macstart = p;
		memcpy(p, key_name, 16);
		p += 16;
		/* output IV */
		memcpy(p, iv, EVP_CIPHER_CTX_iv_length(&ctx));
		p += EVP_CIPHER_CTX_iv_length(&ctx);
		/* Encrypt session data */
		EVP_EncryptUpdate(&ctx, p, &len, senc, slen);
		p += len;
		EVP_EncryptFinal_ex(&ctx, p, &len);
		p += len;
		EVP_CIPHER_CTX_cleanup(&ctx);

		HMAC_Update(&hctx, macstart, p - macstart);
		HMAC_Final(&hctx, p, &hlen);
		HMAC_CTX_cleanup(&hctx);
		p += hlen;

		/* Now write out lengths: p points to end of data written */
		/* Total length */
		len = p - d;

		/* Skip ticket lifetime hint. */
		p = d + 4;
		s2n(len - 6, p); /* Message length */

		ssl3_handshake_msg_finish(s, len);

		s->state = SSL3_ST_SW_SESSION_TICKET_B;

		free(senc);
	}

	/* SSL3_ST_SW_SESSION_TICKET_B */
	return (ssl3_handshake_write(s));
}

int
ssl3_send_cert_status(SSL *s)
{
	unsigned char *p;

	if (s->state == SSL3_ST_SW_CERT_STATUS_A) {
		/*
		 * Grow buffer if need be: the length calculation is as
 		 * follows 1 (message type) + 3 (message length) +
 		 * 1 (ocsp response type) + 3 (ocsp response length)
 		 * + (ocsp response)
 		 */
		if (!BUF_MEM_grow(s->init_buf, SSL3_HM_HEADER_LENGTH + 4 +
		    s->tlsext_ocsp_resplen))
			return (-1);

		p = ssl3_handshake_msg_start(s, SSL3_MT_CERTIFICATE_STATUS);

		*(p++) = s->tlsext_status_type;
		l2n3(s->tlsext_ocsp_resplen, p);
		memcpy(p, s->tlsext_ocsp_resp, s->tlsext_ocsp_resplen);

		ssl3_handshake_msg_finish(s, s->tlsext_ocsp_resplen + 4);

		s->state = SSL3_ST_SW_CERT_STATUS_B;
	}

	/* SSL3_ST_SW_CERT_STATUS_B */
	return (ssl3_handshake_write(s));
}

/*
 * ssl3_get_next_proto reads a Next Protocol Negotiation handshake message.
 * It sets the next_proto member in s if found
 */
int
ssl3_get_next_proto(SSL *s)
{
	CBS cbs, proto, padding;
	int ok;
	long n;
	size_t len;

	/*
	 * Clients cannot send a NextProtocol message if we didn't see the
	 * extension in their ClientHello
	 */
	if (!s->s3->next_proto_neg_seen) {
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO,
		    SSL_R_GOT_NEXT_PROTO_WITHOUT_EXTENSION);
		return (-1);
	}

	/* 514 maxlen is enough for the payload format below */
	n = s->method->ssl_get_message(s, SSL3_ST_SR_NEXT_PROTO_A,
	    SSL3_ST_SR_NEXT_PROTO_B, SSL3_MT_NEXT_PROTO, 514, &ok);
	if (!ok)
		return ((int)n);

	/*
	 * s->state doesn't reflect whether ChangeCipherSpec has been received
	 * in this handshake, but s->s3->change_cipher_spec does (will be reset
	 * by ssl3_get_finished).
	 */
	if (!s->s3->change_cipher_spec) {
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO,
		    SSL_R_GOT_NEXT_PROTO_BEFORE_A_CCS);
		return (-1);
	}

	if (n < 2)
		return (0);
	/* The body must be > 1 bytes long */

	CBS_init(&cbs, s->init_msg, s->init_num);

	/*
	 * The payload looks like:
	 *   uint8 proto_len;
	 *   uint8 proto[proto_len];
	 *   uint8 padding_len;
	 *   uint8 padding[padding_len];
	 */
	if (!CBS_get_u8_length_prefixed(&cbs, &proto) ||
	    !CBS_get_u8_length_prefixed(&cbs, &padding) ||
	    CBS_len(&cbs) != 0)
		return 0;

	/*
	 * XXX We should not NULL it, but this matches old behavior of not
	 * freeing before malloc.
	 */
	s->next_proto_negotiated = NULL;
	s->next_proto_negotiated_len = 0;

	if (!CBS_stow(&proto, &s->next_proto_negotiated, &len)) {
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO,
		    ERR_R_MALLOC_FAILURE);
		return (0);
	}
	s->next_proto_negotiated_len = (uint8_t)len;

	return (1);
}
@


1.125
log
@X509_free(3) is NULL-safe, so remove NULL checks before its calls.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.124 2016/01/27 02:06:16 beck Exp $ */
d2561 1
a2561 1
		EVP_EncryptFinal(&ctx, p, &len);
@


1.124
log
@deprecate SSL_OP_SINGLE_DH_USE
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.123 2015/09/13 12:39:16 jsing Exp $ */
d2379 1
a2379 2
	if (s->session->peer != NULL) /* This should not be needed */
		X509_free(s->session->peer);
d2416 1
a2416 2
	if (x != NULL)
		X509_free(x);
@


1.123
log
@Use ECDH_size() instead of rolling our own.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.122 2015/09/13 09:20:19 jsing Exp $ */
d1239 4
a1242 19

			if ((dhp->pub_key == NULL || dhp->priv_key == NULL ||
			    (s->options & SSL_OP_SINGLE_DH_USE))) {
				if (!DH_generate_key(dh)) {
					SSLerr(
					    SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
					    ERR_R_DH_LIB);
					goto err;
				}
			} else {
				dh->pub_key = BN_dup(dhp->pub_key);
				dh->priv_key = BN_dup(dhp->priv_key);
				if ((dh->pub_key == NULL) ||
					(dh->priv_key == NULL)) {
					SSLerr(
					    SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
					    ERR_R_DH_LIB);
					goto err;
				}
@


1.122
log
@The *_accept() functions increment in_handshake at the start of the function,
then decrement it and call a callback on exit from the function. As such,
these functions should not return in the middle, otherwise in_handshake is
never decremented and the callback never called.

ok beck@@ "with many sighs" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.121 2015/09/12 16:10:07 doug Exp $ */
d1781 1
a1781 1
		int field_size = 0;
d1894 2
a1895 2
		field_size = EC_GROUP_get_degree(group);
		if (field_size <= 0) {
d1900 2
a1901 2
		i = ECDH_compute_key(p, (field_size + 7)/8, clnt_ecpoint,
		    srvr_ecdh, NULL);
@


1.121
log
@Remove most of the SSLv3 version checks and a few TLS v1.0.

We can now assume >= TLS v1.0 since SSL2_VERSION, SSL3_VERSION and
DTLS1_BAD_VER support was removed.

"reads ok" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.120 2015/09/12 15:03:39 jsing Exp $ */
d191 3
a193 3
		SSLerr(SSL_F_SSL3_ACCEPT,
		    SSL_R_NO_CERTIFICATE_SET);
		return (-1);
d214 3
a216 3
				SSLerr(SSL_F_SSL3_ACCEPT,
				    ERR_R_INTERNAL_ERROR);
				return (-1);
d395 6
a400 3
				if (s->s3->handshake_buffer)
					if (!tls1_digest_cached_records(s))
						return (-1);
d488 2
a489 1
					return (-1);
d492 4
a495 2
				if (!tls1_digest_cached_records(s))
					return (-1);
d510 6
a515 3
				if (s->s3->handshake_buffer)
					if (!tls1_digest_cached_records(s))
						return (-1);
@


1.120
log
@Move handshake message header length determination into a separate
ssl3_handshake_msg_hdr_len() function. Use this to correct several places
that have magic numbers with header lengths hardcoded as '4'.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.119 2015/09/12 13:03:06 jsing Exp $ */
d945 4
a948 7
	if (s->version >= SSL3_VERSION) {
		if (!ssl_parse_clienthello_tlsext(s, &p, d, n, &al)) {
			/* 'al' set by ssl_parse_clienthello_tlsext */
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
			    SSL_R_PARSE_TLSEXT);
			goto f_err;
		}
d964 1
a964 1
	if (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb) {
d1054 3
a1056 6
	if (s->version >= SSL3_VERSION) {
		if (ssl_check_clienthello_tlsext_late(s) <= 0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
			    SSL_R_CLIENTHELLO_TLSEXT);
			goto err;
		}
d1643 9
a1651 12
		/* TLS and [incidentally] DTLS{0xFEFF} */
		if (s->version > SSL3_VERSION) {
			if (2 > n)
				goto truncated;
			n2s(p, i);
			if (n != i + 2) {
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
				goto err;
			} else
				n = i;
		}
d2294 1
a2294 1
		if ((s->version > SSL3_VERSION) && s->s3->tmp.cert_request) {
d2359 5
a2363 9
		/* TLS does not mind 0 certs returned */
		if (s->version == SSL3_VERSION) {
			al = SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
			    SSL_R_NO_CERTIFICATES_RETURNED);
			goto f_err;
		}
		/* Fail for TLS only if we required a certificate */
		else if ((s->verify_mode & SSL_VERIFY_PEER) &&
@


1.119
log
@Convert the rest of the server handshake functions to ssl3_handshake_msg_*.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.118 2015/09/11 18:08:21 jsing Exp $ */
d1401 2
a1402 1
		if (!BUF_MEM_grow_clean(buf, n + 4 + kn)) {
d1574 3
a1576 1
				if (!BUF_MEM_grow_clean(buf, 4 + n + j + 2)) {
d2529 2
a2530 2
		if (!BUF_MEM_grow(s->init_buf,
		    26 + EVP_MAX_IV_LENGTH + EVP_MAX_BLOCK_LENGTH +
@


1.118
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.117 2015/09/10 17:57:50 jsing Exp $ */
d1259 1
a1259 2
		} else
		if (type & SSL_kECDHE) {
d1406 3
a1408 2
		d = (unsigned char *)s->init_buf->data;
		p = &d[4];
d1461 1
a1461 1
					EVP_DigestUpdate(&md_ctx, &d[4], n);
d1496 1
a1496 1
				EVP_SignUpdate(&md_ctx, &d[4], n);
d1517 1
a1517 6
		*(d++) = SSL3_MT_SERVER_KEY_EXCHANGE;
		l2n3(n, d);

		/* we should now have things packed up, so lets send it off */
		s->init_num = n + 4;
		s->init_off = 0;
d1522 3
a1524 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
d1546 2
a1547 1
		d = p = (unsigned char *)&(buf->data[4]);
d1579 2
a1580 1
				p = (unsigned char *)&(buf->data[4 + n]);
d1588 2
a1589 1
		p = (unsigned char *)&(buf->data[4 + off]);
d1592 1
a1592 7
		d = (unsigned char *)buf->data;
		*(d++) = SSL3_MT_CERTIFICATE_REQUEST;
		l2n3(n, d);

		/* we should now have things packed up, so lets send it off */
		s->init_num = n + 4;
		s->init_off = 0;
d1598 1
a1598 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
d2461 1
a2461 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
d2469 1
a2469 1
		unsigned char *p, *senc, *macstart;
d2533 2
a2534 5
		p = (unsigned char *)s->init_buf->data;
		/* do the header */
		*(p++) = SSL3_MT_NEWSESSION_TICKET;
		/* Skip message length for now */
		p += 3;
d2537 1
d2586 1
a2587 1
		p += hlen;
d2590 7
a2596 6
		len = p - (unsigned char *)s->init_buf->data;
		p = (unsigned char *)s->init_buf->data + 1;
		l2n3(len - 4, p); /* Message length */
		p += 4;
		s2n(len - 10, p);
		/* Ticket length */
a2597 2
		/* number of bytes to write */
		s->init_num = len;
d2599 1
a2599 1
		s->init_off = 0;
d2604 1
a2604 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
@


1.117
log
@Remove support for DTLS_BAD_VER. We do not support non-standard and
incomplete implementations just so that we can interoperate with products
from vendors who have not bothered to fix things in the last ~10 years.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.116 2015/09/10 15:56:26 jsing Exp $ */
d242 1
a242 1
				if (!ssl3_init_finished_mac(s)) {
d282 1
a282 1
			if (!ssl3_init_finished_mac(s)) {
d396 1
a396 1
					if (!ssl3_digest_cached_records(s))
d488 1
a488 1
				if (!ssl3_digest_cached_records(s))
d505 1
a505 1
					if (!ssl3_digest_cached_records(s))
d636 1
a636 1
			ssl3_cleanup_key_block(s);
d1038 1
a1038 1
		if (!ssl3_digest_cached_records(s)) {
d2387 1
a2387 1
		if (s->s3->handshake_buffer && !ssl3_digest_cached_records(s)) {
@


1.116
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.115 2015/09/01 13:38:27 jsing Exp $ */
d1653 1
a1653 1
		if (s->version > SSL3_VERSION && s->version != DTLS1_BAD_VER) {
@


1.115
log
@Remove the ssl_prepare_{client,server}hello_tlsext() functions, which are
now nothing more than noops.

ok bcook@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.114 2015/08/29 16:51:17 doug Exp $ */
d1728 1
a1728 1
		OPENSSL_cleanse(p, i);
d1779 1
a1779 1
		OPENSSL_cleanse(p, i);
d1923 1
a1923 1
		OPENSSL_cleanse(p, i);
@


1.114
log
@Remove SSLv3 method data structs and unlink s3_meth.c from the build.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.113 2015/08/27 06:21:15 doug Exp $ */
a1134 5
		if (ssl_prepare_serverhello_tlsext(s) <= 0) {
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO,
			    SSL_R_SERVERHELLO_TLSEXT);
			return (-1);
		}
@


1.113
log
@Remove SSLv3 support from LibreSSL.

This is the first wave of SSLv3 removal which removes the main SSLv3
functions.  Future commits will remove the rest of the SSLv3 support.

Discussed the plan at c2k15.  Input from jsing@@, beck@@, miod@@, bcook@@,
sthen@@, naddy@@, and deraadt@@.

ok jsing@@, beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.112 2015/07/29 19:16:09 miod Exp $ */
a167 40

static const SSL_METHOD *ssl3_get_server_method(int ver);

const SSL_METHOD SSLv3_server_method_data = {
	.version = SSL3_VERSION,
	.ssl_new = ssl3_new,
	.ssl_clear = ssl3_clear,
	.ssl_free = ssl3_free,
	.ssl_accept = ssl3_accept,
	.ssl_connect = ssl_undefined_function,
	.ssl_read = ssl3_read,
	.ssl_peek = ssl3_peek,
	.ssl_write = ssl3_write,
	.ssl_shutdown = ssl3_shutdown,
	.ssl_renegotiate = ssl3_renegotiate,
	.ssl_renegotiate_check = ssl3_renegotiate_check,
	.ssl_get_message = ssl3_get_message,
	.ssl_read_bytes = ssl3_read_bytes,
	.ssl_write_bytes = ssl3_write_bytes,
	.ssl_dispatch_alert = ssl3_dispatch_alert,
	.ssl_ctrl = ssl3_ctrl,
	.ssl_ctx_ctrl = ssl3_ctx_ctrl,
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
	.ssl_pending = ssl3_pending,
	.num_ciphers = ssl3_num_ciphers,
	.get_cipher = ssl3_get_cipher,
	.get_ssl_method = ssl3_get_server_method,
	.get_timeout = ssl3_default_timeout,
	.ssl3_enc = &SSLv3_enc_data,
	.ssl_version = ssl_undefined_void_function,
	.ssl_callback_ctrl = ssl3_callback_ctrl,
	.ssl_ctx_callback_ctrl = ssl3_ctx_callback_ctrl,
};

static const SSL_METHOD *
ssl3_get_server_method(int ver)
{
	return (NULL);
}
@


1.112
log
@Add linker warnings in case SSLv3_{,client,server}_method are referenced.

Use of this symbols proves the existence of a code path willingly using SSLv3,
even with OPENSSL_NO_SSL3 being defined, which hints that it needs fixing.

Discussed with the LibreSSL cabal during c2k15; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.111 2015/07/18 01:42:26 doug Exp $ */
a168 6
#ifdef __OpenBSD__
#include <sys/cdefs.h>
__warn_references(SSLv3_server_method,
    "SSLv3_server_method() enables the use of insecure protocols");
#endif

a202 6
const SSL_METHOD *
SSLv3_server_method(void)
{
	return &SSLv3_server_method_data;
}

a205 2
	if (ver == SSL3_VERSION)
		return (SSLv3_server_method());
@


1.112.4.1
log
@deprecate SSL_OP_SINGLE_DH_USE
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.112 2015/07/29 19:16:09 miod Exp $ */
d1295 19
a1313 4
			if (!DH_generate_key(dh)) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				goto err;
@


1.111
log
@Remove support for the SSL_OP_TLS_D5_BUG compat hack from SSLeay.

This is a 17 year old workaround from SSLeay 0.9.0b.  It was for
clients that send RSA client key exchange in TLS using SSLv3 format
(no length prefix).

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.110 2015/07/14 05:16:47 doug Exp $ */
d168 6
@


1.110
log
@Convert ssl3_get_client_certificate to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.109 2015/06/20 17:04:07 doug Exp $ */
d1711 3
a1713 7
				if (!(s->options & SSL_OP_TLS_D5_BUG)) {
					SSLerr(
					    SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					    SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
					goto err;
				} else
					p -= 2;
@


1.109
log
@Convert ssl3_get_next_proto to CBS.

tweak + ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.108 2015/06/18 22:51:05 doug Exp $ */
d2338 1
d2341 2
a2342 2
	unsigned long l, nc, llen, n;
	const unsigned char *p, *q;
d2380 5
a2384 1
	p = (const unsigned char *)s->init_msg;
d2392 2
a2393 1
	if (3 > n)
d2395 5
a2399 6
	n2l3(p, llen);
	if (llen + 3 != n)
		goto truncated;
	for (nc = 0; nc < llen;) {
		n2l3(p, l);
		if (l + nc + 3 > llen) {
d2406 2
a2407 2
		q = p;
		x = d2i_X509(NULL, &p, l);
d2413 1
a2413 1
		if (p != (q + l)) {
a2424 1
		nc += l + 3;
@


1.108
log
@Remove Microsoft Server Gated Crypto.

Another relic due to the old US crypto policy.

From OpenSSL commit 63eab8a620944a990ab3985620966ccd9f48d681 and
95275599399e277e71d064790a1f828a99fc661a.

ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.107 2015/06/17 07:29:33 doug Exp $ */
d167 2
d2707 1
a2708 1
	int proto_len, padding_len;
d2710 1
a2710 1
	const unsigned char *p;
d2743 1
a2743 1
	p = (unsigned char *)s->init_msg;
d2752 11
a2762 6
	proto_len = p[0];
	if (proto_len + 2 > s->init_num)
		return (0);
	padding_len = p[proto_len + 1];
	if (proto_len + padding_len + 2 != s->init_num)
		return (0);
d2764 1
a2764 2
	s->next_proto_negotiated = malloc(proto_len);
	if (!s->next_proto_negotiated) {
d2769 1
a2769 2
	memcpy(s->next_proto_negotiated, p + 1, proto_len);
	s->next_proto_negotiated_len = proto_len;
@


1.107
log
@KNF whitespace.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.106 2015/06/15 05:32:58 doug Exp $ */
a275 1
			s->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE;
d489 4
a492 14
			/* Check for second client hello (MS SGC) */
			ret = ssl3_check_client_hello(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				s->state = SSL3_ST_SR_CLNT_HELLO_C;
			else {
				if (s->s3->tmp.cert_request) {
					ret = ssl3_get_client_certificate(s);
					if (ret <= 0)
						goto end;
				}
				s->init_num = 0;
				s->state = SSL3_ST_SR_KEY_EXCH_A;
d494 2
a755 40
}

int
ssl3_check_client_hello(SSL *s)
{
	int ok;
	long n;

	/*
	 * This function is called when we really expect a Certificate message,
	 * so permit appropriate message length
	 */
	n = s->method->ssl_get_message(s, SSL3_ST_SR_CERT_A,
	    SSL3_ST_SR_CERT_B, -1, s->max_cert_list, &ok);
	if (!ok)
		return ((int)n);
	s->s3->tmp.reuse_message = 1;
	if (s->s3->tmp.message_type == SSL3_MT_CLIENT_HELLO) {
		/*
		 * We only allow the client to restart the handshake once per
		 * negotiation.
		 */
		if (s->s3->flags & SSL3_FLAGS_SGC_RESTART_DONE) {
			SSLerr(SSL_F_SSL3_CHECK_CLIENT_HELLO,
			    SSL_R_MULTIPLE_SGC_RESTARTS);
			return (-1);
		}
		/*
		 * Throw away what we have done so far in the current handshake,
		 * which will now be aborted. (A full SSL_clear would be too
		 * much.)
		 */
		DH_free(s->s3->tmp.dh);
		s->s3->tmp.dh = NULL;
		EC_KEY_free(s->s3->tmp.ecdh);
		s->s3->tmp.ecdh = NULL;
		s->s3->flags |= SSL3_FLAGS_SGC_RESTART_DONE;
		return (2);
	}
	return (1);
@


1.106
log
@Remove ancient SSL_OP_NETSCAPE_CA_DN_BUG from SSLeay days.

This commit matches the OpenSSL removal in commit
3c33c6f6b10864355553961e638514a6d1bb00f6.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.105 2015/06/15 05:16:56 doug Exp $ */
d1410 2
a1411 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,					    ERR_R_ECDH_LIB);
@


1.105
log
@Remove ancient compat hack SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG.

This was imported into OpenSSL from SSLeay.  It was recently deleted
in OpenSSL commit 7a4dadc3a6a487db92619622b820eb4f7be512c9
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.104 2015/06/15 03:32:59 doug Exp $ */
d1681 4
a1684 14
				if (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG)) {
					s2n(j, p);
					i2d_X509_NAME(name, &p);
					n += 2 + j;
					nl += 2 + j;
				} else {
					d = p;
					i2d_X509_NAME(name, &p);
					j -= 2;
					s2n(j, d);
					j += 2;
					n += j;
					nl += j;
				}
@


1.104
log
@Remove 1997's compat hack SSL_OP_SSLEAY_080_CLIENT_DH_BUG.

This is a hack for an old version of SSLeay which predates OpenSSL.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.103 2015/05/15 11:00:14 jsg Exp $ */
a150 2
#define REUSE_CIPHER_BUG

a1126 21
		/* Session-id reuse */
#ifdef REUSE_CIPHER_BUG
		STACK_OF(SSL_CIPHER) *sk;
		SSL_CIPHER *nc = NULL;
		SSL_CIPHER *ec = NULL;

		if (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG) {
			sk = s->session->ciphers;
			for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {
				c = sk_SSL_CIPHER_value(sk, i);
				if (c->algorithm_enc & SSL_eNULL)
					nc = c;
			}
			if (nc != NULL)
				s->s3->tmp.new_cipher = nc;
			else if (ec != NULL)
				s->s3->tmp.new_cipher = ec;
			else
				s->s3->tmp.new_cipher = s->session->cipher;
		} else
#endif
@


1.103
log
@Fix return paths with missing EVP_CIPHER_CTX_cleanup() calls.
ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.102 2015/04/15 16:25:43 jsing Exp $ */
d1870 3
a1872 8
			if (!(s->options & SSL_OP_SSLEAY_080_CLIENT_DH_BUG)) {
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
				goto err;
			} else {
				p -= 2;
				i = (int)n;
			}
@


1.102
log
@Clean up the ssl_bytes_to_cipher_list() API - rather than having the
ability to pass or not pass a STACK_OF(SSL_CIPHER) *, which is then either
zeroed or if NULL a new one is allocated, always allocate one and return it
directly.

Inspired by simliar changes in BoringSSL.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.101 2015/03/27 12:29:54 jsing Exp $ */
d2692 1
@


1.101
log
@Factor out the init_buf initialisation code, rather than duplicating it
in four different places.

ok doug@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.100 2015/02/25 03:49:21 bcook Exp $ */
d991 3
a993 3
	if ((i > 0) &&
	    (ssl_bytes_to_cipher_list(s, p, i, &(ciphers)) == NULL)) {
		goto err;
@


1.100
log
@Fix CVE-2015-0205: Do not accept client authentication with Diffie-Hellman
certificates without requiring a CertificateVerify message.

From OpenSSL commit:
https://github.com/openssl/openssl/commit/1421e0c584ae9120ca1b88098f13d6d2e90b83a3

Thanks to Karthikeyan Bhargavan for reporting this.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.99 2015/02/07 08:56:39 jsing Exp $ */
d268 3
a270 13
			if (s->init_buf == NULL) {
				BUF_MEM *buf;
				if ((buf = BUF_MEM_new()) == NULL) {
					ret = -1;
					goto end;
				}
				if (!BUF_MEM_grow(buf,
				    SSL3_RT_MAX_PLAIN_LENGTH)) {
					BUF_MEM_free(buf);
					ret = -1;
					goto end;
				}
				s->init_buf = buf;
a271 1

@


1.100.4.1
log
@deprecate SSL_OP_SINGLE_DH_USE
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.100 2015/02/25 03:49:21 bcook Exp $ */
d1370 19
a1388 4
			if (!DH_generate_key(dh)) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				goto err;
@


1.99
log
@Convert several of the server side handshake functions to the new handshake
message handling routines.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.98 2015/02/06 10:04:07 jsing Exp $ */
d2193 1
a2193 1
		if ((peer != NULL) && (type & EVP_PKT_SIGN)) {
@


1.98
log
@Unifdef NETSCAPE_HANG_BUG.

If you're still using a buggy version of Netscape from 2000, for HTTPS with
client certificates, it is probably a good time to find a new browser.

"kill it softly... with napalm and kisses" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.97 2015/02/06 08:30:23 jsing Exp $ */
a768 2
	unsigned char *p;

d770 2
a771 5
		p = (unsigned char *)s->init_buf->data;
		*(p++) = SSL3_MT_HELLO_REQUEST;
		*(p++) = 0;
		*(p++) = 0;
		*(p++) = 0;
a773 3
		/* number of bytes to write */
		s->init_num = 4;
		s->init_off = 0;
d777 1
a777 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
d1212 1
a1212 1
	unsigned char *buf;
a1213 1
	unsigned long l;
d1217 1
a1217 3
		buf = (unsigned char *)s->init_buf->data;
		/* Do the message type and length last */
		d = p= &(buf[4]);
d1220 1
a1220 1
		*(p++) = s->version&0xff;
d1263 1
d1269 3
a1271 2
		if ((p = ssl_add_serverhello_tlsext(s, p,
		    buf + SSL3_RT_MAX_PLAIN_LENGTH)) == NULL) {
a1275 5
		/* do the header */
		l = (p - d);
		d = buf;
		*(d++) = SSL3_MT_SERVER_HELLO;
		l2n3(l, d);
d1277 1
a1277 4
		s->state = SSL3_ST_SW_SRVR_HELLO_B;
		/* number of bytes to write */
		s->init_num = p - buf;
		s->init_off = 0;
d1281 1
a1281 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
a1286 2
	unsigned char *p;

d1288 2
a1289 7
		p = (unsigned char *)s->init_buf->data;

		/* do the header */
		*(p++) = SSL3_MT_SERVER_DONE;
		*(p++) = 0;
		*(p++) = 0;
		*(p++) = 0;
a1291 3
		/* number of bytes to write */
		s->init_num = 4;
		s->init_off = 0;
d1295 1
a1295 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
d2766 2
a2768 1
		unsigned char *p;
d2775 2
a2776 1
		if (!BUF_MEM_grow(s->init_buf, 8 + s->tlsext_ocsp_resplen))
d2779 1
a2779 1
		p = (unsigned char *)s->init_buf->data;
a2780 5
		/* do the header */
		*(p++) = SSL3_MT_CERTIFICATE_STATUS;
		/* message length */
		l2n3(s->tlsext_ocsp_resplen + 4, p);
		/* status type */
a2781 1
		/* length of OCSP response */
a2782 1
		/* actual response */
d2784 3
a2786 2
		/* number of bytes to write */
		s->init_num = 8 + s->tlsext_ocsp_resplen;
a2787 1
		s->init_off = 0;
d2791 1
a2791 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
@


1.97
log
@Bring back the horrible API that is get_cipher_by_char/put_cipher_by_char.

This API was intended to be an internal only, however like many things in
OpenSSL, it is exposed externally and parts of the software ecosystem are
now using it since there is no real alternative within the public API.

ok doug@@, tedu@@ and reluctantly miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.96 2014/12/29 16:12:59 tedu Exp $ */
a151 1
#define NETSCAPE_HANG_BUG
a462 1
#ifndef NETSCAPE_HANG_BUG
a463 4
#else
				s->state = SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state = SSL3_ST_SR_CERT_A;
#endif
a1768 15
#ifdef NETSCAPE_HANG_BUG
		if (!BUF_MEM_grow(buf, s->init_num + 4)) {
			SSLerr(SSL_F_SSL3_SEND_CERTIFICATE_REQUEST,
			    ERR_R_BUF_LIB);
			goto err;
		}
		p = (unsigned char *)buf->data + s->init_num;

		/* do the header */
		*(p++) = SSL3_MT_SERVER_DONE;
		*(p++) = 0;
		*(p++) = 0;
		*(p++) = 0;
		s->init_num += 4;
#endif
@


1.96
log
@don't leak timing info about padding errors by generating a fake key
afterwards. openssl has a more complicated fix, but it's less intrusive
for now to simply hoist the expensive part (fake key generation) up without
sweating a branch or two.
ok bcook jsing
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.95 2014/12/15 00:46:53 doug Exp $ */
d191 2
@


1.95
log
@Add error handling for EVP_DigestInit_ex().

A few EVP_DigestInit_ex() calls were left alone since reporting an
error would change the public API.

Changed internal ssl3_cbc_digest_record() to return a value due to the above
change.  It will also now set md_out_size=0 on failure.

This is based on part of BoringSSL's commit to fix malloc crashes:
https://boringssl.googlesource.com/boringssl/+/69a01608f33ab6fe2c3485d94aef1fe9eacf5364

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.94 2014/12/14 14:34:43 jsing Exp $ */
d1825 6
d1860 2
a1912 1
			ERR_clear_error();
d1914 1
a1914 3
			p[0] = s->client_version >> 8;
			p[1] = s->client_version & 0xff;
			arc4random_buf(p + 2, i - 2);
@


1.94
log
@unifdef OPENSSL_NO_NEXTPROTONEG, which is one of the last standing #ifndef
mazes in libssl. NPN is being replaced by ALPN, however it is still going
to be around for a while yet.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.93 2014/12/10 15:43:31 jsing Exp $ */
d1615 1
a1615 1
					EVP_DigestInit_ex(&md_ctx,
d1617 2
a1618 1
					    s->ctx->sha1, NULL);
@


1.93
log
@ssl3_init_finished_mac() calls BIO_new() which can fail since it in turn
calls malloc(). Instead of silently continuing on failure, check the return
value of BIO_new() and propagate failure back to the caller for appropriate
handling.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.92 2014/12/10 15:36:47 jsing Exp $ */
a539 3
#ifdef OPENSSL_NO_NEXTPROTONEG
				s->state = SSL3_ST_SR_FINISHED_A;
#else
a543 1
#endif
a607 3
#ifdef OPENSSL_NO_NEXTPROTONEG
			s->state = SSL3_ST_SR_FINISHED_A;
#else
a611 1
#endif
a614 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a622 1
#endif
a693 3
#ifdef OPENSSL_NO_NEXTPROTONEG
				s->s3->tmp.next_state = SSL3_ST_SR_FINISHED_A;
#else
a700 1
#endif
a2838 1
# ifndef OPENSSL_NO_NEXTPROTONEG
a2908 1
# endif
@


1.92
log
@Remove support for GOST R 34.10-94 signature authentication, along with
the two ciphersuites that use it. GOST94 public/private keys have been
long obsoleted and libcrypto does not have support for them anyway.

Discussed with Dmitry Eremin-Solenikov.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.91 2014/11/18 05:33:43 miod Exp $ */
d301 5
a305 1
				ssl3_init_finished_mac(s);
d341 4
a344 1
			ssl3_init_finished_mac(s);
@


1.91
log
@Update the GOST code in libssl, as contributed by Dmitry Eremin-Solenikov.

This causes a libssl major version bump as this affects the layout of some
internal-but-unfortunately-made-visible structs.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.90 2014/11/16 14:12:47 jsing Exp $ */
d2137 1
a2137 3
		if (alg_a & SSL_aGOST94)
			pk = s->cert->pkeys[SSL_PKEY_GOST94].privatekey;
		else if (alg_a & SSL_aGOST01)
@


1.90
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.89 2014/10/31 15:25:55 jsing Exp $ */
d162 3
d522 1
d542 1
a542 1
			} else if (SSL_USE_SIGALGS(s)) {
d849 1
d1183 3
a1185 1
	if (!SSL_USE_SIGALGS(s) || !(s->verify_mode & SSL_VERIFY_PEER)) {
d2346 1
a2346 1
		if (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0) {
d2394 1
d2397 5
a2401 2
		unsigned char signature[64];
		int idx;
d2403 3
a2405 2
	       
		if (i != 64) {
d2407 9
a2415 2
			    SSL_R_WRONG_SIGNATURE_SIZE);
			al = SSL_AD_DECODE_ERROR;
d2419 1
a2419 1
		if (pctx == NULL) {
d2421 17
a2437 2
			    ERR_R_INTERNAL_ERROR);
			al = SSL_AD_DECODE_ERROR;
d2440 2
a2441 7
		EVP_PKEY_verify_init(pctx);
		for (idx = 0; idx < 64; idx++)
			signature[63 - idx] = p[idx];
		j = EVP_PKEY_verify(pctx, signature, 64,
		    s->s3->tmp.cert_verify_md, 32);
		EVP_PKEY_CTX_free(pctx);
		if (j <= 0) {
d2444 2
a2445 1
			    SSL_R_BAD_ECDSA_SIGNATURE);
d2448 5
a2452 1
	} else {
@


1.89
log
@Add support for automatic DH ephemeral keys.

This allows an SSL server to enable DHE ciphers with a single setting,
which results in an DH key being generated based on the server key length.

Partly based on OpenSSL.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.88 2014/10/31 14:51:01 jsing Exp $ */
d155 1
d157 2
a159 1
#include <openssl/objects.h>
d161 1
d163 2
a165 3
#include <openssl/dh.h>
#include <openssl/bn.h>
#include <openssl/md5.h>
@


1.88
log
@Remove support for ephemeral/temporary RSA private keys.

The only use for these is via SSL_OP_EPHEMERAL_RSA (which is effectively
a standards violation) and for RSA sign-only, should only be possible if
you are using an export cipher and have an RSA private key that is more
than 512 bits in size (however we no longer support export ciphers).

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.87 2014/10/18 16:13:16 jsing Exp $ */
d1363 12
a1374 2
			dhp = cert->dh_tmp;
			if ((dhp == NULL) && (s->cert->dh_tmp_cb != NULL))
d1377 1
d1391 3
a1393 1
			if ((dh = DHparams_dup(dhp)) == NULL) {
@


1.87
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.86 2014/10/03 13:58:18 jsing Exp $ */
d395 1
a395 19
			 * Clear this, it may get reset by
			 * send_server_key_exchange.
			 */
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
			    )
				/*
				 * option SSL_OP_EPHEMERAL_RSA sends temporary
				 * RSA key even when forbidden by protocol
				 * specs (handshake may fail as clients are
				 * not required to be able to handle this)
				 */
				s->s3->tmp.use_rsa_tmp = 1;
			else
				s->s3->tmp.use_rsa_tmp = 0;


			/*
			 * Only send if a DH key exchange, fortezza or
			 * RSA but we have a sign only certificate.
d397 3
a399 4
			 * For ECC ciphersuites, we send a serverKeyExchange
			 * message only if the cipher suite is either
			 * ECDH-anon or ECDHE. In other cases, the
			 * server certificate contains the server's
d402 1
a402 5
			if (s->s3->tmp.use_rsa_tmp ||
			    (alg_k & (SSL_kDHE|SSL_kECDHE)) ||
			    ((alg_k & SSL_kRSA) &&
			     (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey ==
			     NULL))) {
a1331 1
	RSA *rsa;
a1361 25
		if (type & SSL_kRSA) {
			rsa = cert->rsa_tmp;
			if ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL)) {
				rsa = s->cert->rsa_tmp_cb(s, 0,
				    SSL_C_PKEYLENGTH(s->s3->tmp.new_cipher));
				if (rsa == NULL) {
					al = SSL_AD_HANDSHAKE_FAILURE;
					SSLerr(
					    SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
					    SSL_R_ERROR_GENERATING_TMP_RSA_KEY);
					goto f_err;
				}
				RSA_up_ref(rsa);
				cert->rsa_tmp = rsa;
			}
			if (rsa == NULL) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    SSL_R_MISSING_TMP_RSA_KEY);
				goto f_err;
			}
			r[0] = rsa->n;
			r[1] = rsa->e;
			s->s3->tmp.use_rsa_tmp = 1;
		} else
d1809 7
a1815 25
		/* FIX THIS UP EAY EAY EAY EAY */
		if (s->s3->tmp.use_rsa_tmp) {
			if ((s->cert != NULL) && (s->cert->rsa_tmp != NULL))
				rsa = s->cert->rsa_tmp;
			/*
			 * Don't do a callback because rsa_tmp should
			 * be sent already
			 */
			if (rsa == NULL) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    SSL_R_MISSING_TMP_RSA_PKEY);
				goto f_err;

			}
		} else {
			pkey = s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey;
			if ((pkey == NULL) || (pkey->type != EVP_PKEY_RSA) ||
			    (pkey->pkey.rsa == NULL)) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    SSL_R_MISSING_RSA_CERTIFICATE);
				goto f_err;
			}
			rsa = pkey->pkey.rsa;
d1817 1
@


1.86
log
@Add support for automatic ephemeral EC keys.

This allows an SSL server to enable ECDHE ciphers with a single setting,
which results in an EC key being generated using the first preference
shared curve.

Based on OpenSSL with inspiration from boringssl.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.85 2014/09/27 11:03:43 jsing Exp $ */
a156 1
#include <openssl/rand.h>
d1108 1
a1108 5
	{
		unsigned char *pos;
		pos = s->s3->server_random;
		RAND_pseudo_bytes(pos, SSL3_RANDOM_SIZE);
	}
d1959 1
a1959 1
			RAND_bytes(p+2, i-2);
d2772 1
a2772 1
			RAND_pseudo_bytes(iv, 16);
@


1.85
log
@There is not much point checking ecdhp is not NULL... twice.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.84 2014/09/19 14:32:24 tedu Exp $ */
d1468 6
a1473 1
			if (ecdhp == NULL && s->cert->ecdh_tmp_cb != NULL)
d1476 1
d1491 3
a1493 1
			if ((ecdh = EC_KEY_dup(ecdhp)) == NULL) {
@


1.84
log
@remove obfuscating parens. man operator is your friend.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.83 2014/09/07 12:16:23 jsing Exp $ */
d1439 1
a1440 1
			s->s3->tmp.dh = dh;
a1484 5
			if (ecdhp == NULL) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    ERR_R_ECDH_LIB);
				goto err;
			}
d1490 1
a1491 1
			s->s3->tmp.ecdh = ecdh;
@


1.83
log
@Remove SSL_kDHr, SSL_kDHd and SSL_aDH. No supported ciphersuites use them,
nor do we plan on supporting them.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.82 2014/08/24 14:36:45 jsing Exp $ */
d1608 1
a1608 1
		p = &(d[4]);
d1655 1
a1655 1
					    &(s->s3->client_random[0]),
d1658 1
a1658 1
					    &(s->s3->server_random[0]),
d1660 1
a1660 1
					EVP_DigestUpdate(&md_ctx, &(d[4]), n);
d1690 1
a1690 1
				    &(s->s3->client_random[0]),
d1693 1
a1693 1
				    &(s->s3->server_random[0]),
d1695 2
a1696 2
				EVP_SignUpdate(&md_ctx, &(d[4]), n);
				if (!EVP_SignFinal(&md_ctx, &(p[2]),
@


1.82
log
@Replace the remaining uses of ssl3_put_cipher_by_char() with s2n and a
ssl3_cipher_get_value() helper function, which returns the cipher suite
value for the given cipher.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.81 2014/08/11 04:46:42 miod Exp $ */
d423 1
a423 2
			    (alg_k & (SSL_kDHr|SSL_kDHd|SSL_kDHE)) ||
			    (alg_k & SSL_kECDHE) ||
d1969 1
a1969 2
	} else
	if (alg_k & (SSL_kDHE|SSL_kDHr|SSL_kDHd)) {
@


1.81
log
@Unchecked memory allocation and potential leak upon error in
ssl3_get_cert_verify().
ok guenther@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.80 2014/08/10 14:42:56 jsing Exp $ */
a1252 1
	int i, sl;
d1254 1
d1301 1
a1301 2
		i = ssl3_put_cipher_by_char(s->s3->tmp.new_cipher, p);
		p += i;
@


1.80
log
@Since we no longer need to support SSLv2-style cipher lists, start
unravelling the maze of function pointers and callbacks by directly
calling ssl3_{get,put}_cipher_by_char() and removing the
ssl_{get,put}_cipher_by_char macros.

Prompted by similar changes in boringssl.

ok guenther.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.79 2014/07/28 04:23:12 guenther Exp $ */
d2447 2
a2448 2
		EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey, NULL);
		EVP_PKEY_verify_init(pctx);
d2455 9
a2463 1
		for (idx = 0; idx < 64; idx++) {
a2464 1
		}
@


1.79
log
@The RSA, DH, and ECDH temporary key callbacks expect the number of keybits
for the key (expressed in RSA key bits, which makes *no sense* for ECDH) as
their second argument, not zero.

(jsing@@ notes that the RSA callback is only invoked for 'export' ciphers,
which have been removed from LibreSSL, and for the SSL_OP_EPHEMERAL_RSA
option, which is makes the application non-compliant.  More fuel for the
tedu fire...)

jasper@@ noted the breakage and bisected it down to the diff that broke this
ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.78 2014/07/12 22:33:39 jsing Exp $ */
a186 2
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
@


1.78
log
@The correct name for EDH is DHE, likewise EECDH should be ECDHE.

Based on changes to OpenSSL trunk.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.77 2014/07/12 13:11:53 jsing Exp $ */
d1398 2
a1399 1
				rsa = s->cert->rsa_tmp_cb(s, 0, 0);
d1423 2
a1424 1
				dhp = s->cert->dh_tmp_cb(s, 0, 0);
d1473 2
a1474 1
				ecdhp = s->cert->ecdh_tmp_cb(s, 0, 0);
@


1.77
log
@Remove remnants from PSK, KRB5 and SRP.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.76 2014/07/12 10:06:04 jsing Exp $ */
d425 2
a426 2
			    (alg_k & (SSL_kDHr|SSL_kDHd|SSL_kEDH)) ||
			    (alg_k & SSL_kEECDH) ||
d1419 1
a1419 1
		if (type & SSL_kEDH) {
d1466 1
a1466 1
		if (type & SSL_kEECDH) {
d1617 1
a1617 1
		if (type & SSL_kEECDH) {
d1971 1
a1971 1
	if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd)) {
d2029 1
a2029 1
	if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) {
d2075 1
a2075 1
			if (alg_k & SSL_kEECDH) {
@


1.76
log
@Place comments in a block above the if statement, rather than attempting
to interleave them within the conditions. Also fix wrapping and
indentation.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.75 2014/07/11 22:57:25 miod Exp $ */
d376 3
a378 7
			/* Check if it is anon DH or anon ECDH, */
			/* normal PSK or KRB5 or SRP */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
			    && !(s->s3->tmp.new_cipher->algorithm_mkey &
			    SSL_kPSK)
			    && !(s->s3->tmp.new_cipher->algorithm_auth &
			    SSL_aKRB5)) {
d416 1
a416 4
			 * RSA but we have a sign only certificate
			 *
			 * PSK: send ServerKeyExchange if PSK identity
			 * hint is provided
d424 6
a429 7
			if (s->s3->tmp.use_rsa_tmp
			    || (alg_k & (SSL_kDHr|SSL_kDHd|SSL_kEDH))
			    || (alg_k & SSL_kEECDH)
			    || ((alg_k & SSL_kRSA)
			    && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey ==
			    NULL
			    ))) {
a457 5
			 *
			 * - We are using a Kerberos ciphersuite.
			 *
			 * - We are using normal PSK certificates and
			 *   Certificate Requests are omitted
d464 1
a464 5
			     SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
			    (s->s3->tmp.new_cipher->algorithm_auth &
			     SSL_aKRB5) ||
			    (s->s3->tmp.new_cipher->algorithm_mkey &
			     SSL_kPSK)) {
d1591 1
a1591 2
		if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
		    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {
d2666 3
a2668 9
			/* VRS: allow null cert if auth == KRB5 */
			if ((s->s3->tmp.new_cipher->algorithm_auth !=
			    SSL_aKRB5) ||
			    (s->s3->tmp.new_cipher->algorithm_mkey &
			    SSL_kKRB5)) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
				    ERR_R_INTERNAL_ERROR);
				return (0);
			}
@


1.75
log
@As reported by David Ramos, most consumer of ssl_get_message() perform late
bounds check, after reading the 2-, 3- or 4-byte size of the next chunk to
process. But the size fields themselves are not checked for being entirely
contained in the buffer.

Since reading past your bounds is bad practice, and may not possible if you
are using a secure memory allocator, we need to add the necessary bounds check,
at the expense of some readability.

As a bonus, a wrong size GOST session key will now trigger an error instead of
a printf to stderr and it being handled as if it had the correct size.

Creating this diff made my eyes bleed (in the real sense); reviewing it
made guenther@@'s and beck@@'s eyes bleed too (in the literal sense).

ok guenther@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.74 2014/07/11 15:18:52 miod Exp $ */
d450 23
a472 6
			if (/* Don't request cert unless asked for it: */
			    !(s->verify_mode & SSL_VERIFY_PEER) ||
				/*
				 * If SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation:
				 */
d474 1
a474 6
			    (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/*
				 * Never request cert in anonymous ciphersuites
				 * (see section "Certificate request" in SSL 3
				 * drafts and in RFC 2246):
				 */
d476 6
a481 16
			    SSL_aNULL) &&
				 /*
				  * ... except when the application insists on
				  * verification (against the specs, but
				  * s3_clnt.c accepts this for SSL 3)
				  */
			    !(s->verify_mode &
			    SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
			/* never request cert in Kerberos ciphersuites */
			    (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
				/*
				 * With normal PSK Certificates and
				 * Certificate Requests are omitted
				 */
			    || (s->s3->tmp.new_cipher->algorithm_mkey &
			    SSL_kPSK)) {
@


1.74
log
@In ssl3_get_cert_verify(), allow for larger messages to accomodate keys
larger than 4096-bit RSA which the most paranoid of us are using; OpenSSL
PR #319 via OpenSSL trunk.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.73 2014/07/11 12:24:51 miod Exp $ */
d897 3
a899 6
	n = s->method->ssl_get_message(s,
	SSL3_ST_SR_CLNT_HELLO_B,
	SSL3_ST_SR_CLNT_HELLO_C,
	SSL3_MT_CLIENT_HELLO,
	SSL3_RT_MAX_PLAIN_LENGTH,
	&ok);
d904 1
a904 1
	d = p=(unsigned char *)s->init_msg;
d906 2
d946 3
d955 2
d995 2
d1012 3
d1044 2
d1054 2
a1055 7
	if ((p + i) >= (d + n)) {
		/* not enough data */
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
		    SSL_R_LENGTH_MISMATCH);
		goto f_err;
	}
d1087 2
d1090 2
a1091 7
	if ((p + i) > (d + n)) {
		/* not enough data */
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
		    SSL_R_LENGTH_MISMATCH);
		goto f_err;
	}
d1253 3
d1856 1
a1856 1
	unsigned char *p;
d1872 1
a1872 1
	p = (unsigned char *)s->init_msg;
d1906 2
d1930 2
d1988 2
d2221 2
d2259 1
a2259 1
		SSL_R_UNKNOWN_CIPHER_TYPE);
d2264 3
d2358 2
d2377 2
d2381 2
a2382 6
		if (i > n) {
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_LENGTH_MISMATCH);
			al = SSL_AD_DECODE_ERROR;
			goto f_err;
		}
d2465 4
a2468 1
			fprintf(stderr, "GOST signature length is %d", i);
d2492 3
a2515 1
	unsigned char *d;
d2553 1
a2553 1
	p = d = (unsigned char *)s->init_msg;
d2561 2
d2564 2
a2565 6
	if (llen + 3 != n) {
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
		    SSL_R_LENGTH_MISMATCH);
		goto f_err;
	}
d2568 1
a2568 1
		if ((l + nc + 3) > llen) {
d2658 4
@


1.73
log
@In ssl3_get_client_key_exchange() parsing a GOST session key, invoke the
regular ASN.1 parser rather than trying to handroll one and potentially
misbehave; OpenSSL PR #3335 via OpenSSL trunk.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.72 2014/07/11 09:24:44 beck Exp $ */
a2272 1
	/* 516 maxlen is enough for 4096 bit RSA key with TLS v1.2 */
d2274 1
a2274 1
	    SSL3_ST_SR_CERT_VRFY_B, -1, 516, &ok);
@


1.72
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.71 2014/07/10 21:36:49 bcook Exp $ */
d2184 2
d2210 3
a2212 12
		if ((*p != ( V_ASN1_SEQUENCE| V_ASN1_CONSTRUCTED))) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DECRYPTION_FAILED);
			goto gerr;
		}
		if (p[1] == 0x81) {
			start = p + 3;
			inlen = p[2];
		} else if (p[1] < 0x80) {
			start = p + 2;
			inlen = p[1];
		} else {
d2217 2
@


1.71
log
@remove unused variable from ssl3_get_client_hello

ok tedu@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.70 2014/07/10 08:51:14 tedu Exp $ */
a431 3
#ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
a1382 3
#ifndef OPENSSL_NO_PSK
	size_t pskhintlen = 0;
#endif
a1588 7
#ifndef OPENSSL_NO_PSK
		if (type & SSL_kPSK) {
			pskhintlen = strlen(s->ctx->psk_identity_hint);
			/* reserve size for record length and PSK identity hint*/
			n += 2 + pskhintlen;
		} else
#endif /* !OPENSSL_NO_PSK */
a1650 9
#ifndef OPENSSL_NO_PSK
		if (type & SSL_kPSK) {
			/* copy PSK identity hint */
			s2n(pskhintlen, p);

			memcpy(p, s->ctx->psk_identity_hint, pskhintlen);
			p += pskhintlen;
		}
#endif
a2176 85
#ifndef OPENSSL_NO_PSK
	if (alg_k & SSL_kPSK) {
		unsigned char *t = NULL;
		unsigned char psk_or_pre_ms[PSK_MAX_PSK_LEN*2 + 4];
		unsigned int pre_ms_len = 0, psk_len = 0;
		int psk_err = 1;
		char tmp_id[PSK_MAX_IDENTITY_LEN + 1];

		al = SSL_AD_HANDSHAKE_FAILURE;

		n2s(p, i);
		if (n != i + 2) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_LENGTH_MISMATCH);
			goto psk_err;
		}
		if (i > PSK_MAX_IDENTITY_LEN) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto psk_err;
		}
		if (s->psk_server_callback == NULL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_PSK_NO_SERVER_CB);
			goto psk_err;
		}

		/*
		 * Create guaranteed NULL-terminated identity
		 * string for the callback
		 */
		memcpy(tmp_id, p, i);
		memset(tmp_id + i, 0, PSK_MAX_IDENTITY_LEN + 1 - i);
		psk_len = s->psk_server_callback(s, tmp_id,
		    psk_or_pre_ms, sizeof(psk_or_pre_ms));
		OPENSSL_cleanse(tmp_id, PSK_MAX_IDENTITY_LEN + 1);

		if (psk_len > PSK_MAX_PSK_LEN) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
			goto psk_err;
		} else if (psk_len == 0) {
			/* PSK related to the given identity not found */
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_PSK_IDENTITY_NOT_FOUND);
			al = SSL_AD_UNKNOWN_PSK_IDENTITY;
			goto psk_err;
		}

		/* create PSK pre_master_secret */
		pre_ms_len = 2 + psk_len + 2 + psk_len;
		t = psk_or_pre_ms;
		memmove(psk_or_pre_ms + psk_len + 4, psk_or_pre_ms, psk_len);
		s2n(psk_len, t);
		memset(t, 0, psk_len);
		t += psk_len;
		s2n(psk_len, t);

		free(s->session->psk_identity);
		s->session->psk_identity = BUF_strdup((char *)p);
		if (s->session->psk_identity == NULL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto psk_err;
		}

		free(s->session->psk_identity_hint);
		s->session->psk_identity_hint = BUF_strdup(s->ctx->psk_identity_hint);
		if (s->ctx->psk_identity_hint != NULL &&
			s->session->psk_identity_hint == NULL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto psk_err;
		}

		s->session->master_key_length =
		    s->method->ssl3_enc->generate_master_secret(
		        s, s->session->master_key, psk_or_pre_ms, pre_ms_len);
		psk_err = 0;
		psk_err:
		OPENSSL_cleanse(psk_or_pre_ms, sizeof(psk_or_pre_ms));
		if (psk_err != 0)
			goto f_err;
	} else
#endif
@


1.70
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.69 2014/07/10 08:25:00 guenther Exp $ */
d885 1
a885 1
	unsigned char *p, *d, *q;
a1091 1
	q = p;
@


1.69
log
@KNF comments, reflowing and moving out of the middle of argument lists in
places

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.68 2014/07/09 11:25:42 jsing Exp $ */
a886 3
#ifndef OPENSSL_NO_COMP
	SSL_COMP *comp = NULL;
#endif
a1172 80
	 * Worst case, we will use the NULL compression, but if we have other
	 * options, we will now look for them.  We have i-1 compression
	 * algorithms from the client, starting at q.
	 */
	s->s3->tmp.new_compression = NULL;
#ifndef OPENSSL_NO_COMP
	/* This only happens if we have a cache hit */
	if (s->session->compress_meth != 0) {
		int m, comp_id = s->session->compress_meth;
		/* Perform sanity checks on resumed compression algorithm */
		/* Can't disable compression */
		if (s->options & SSL_OP_NO_COMPRESSION) {
			al = SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
			    SSL_R_INCONSISTENT_COMPRESSION);
			goto f_err;
		}
		/* Look for resumed compression method */
		for (m = 0; m < sk_SSL_COMP_num(s->ctx->comp_methods); m++) {
			comp = sk_SSL_COMP_value(s->ctx->comp_methods, m);
			if (comp_id == comp->id) {
				s->s3->tmp.new_compression = comp;
				break;
			}
		}
		if (s->s3->tmp.new_compression == NULL) {
			al = SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
			    SSL_R_INVALID_COMPRESSION_ALGORITHM);
			goto f_err;
		}
		/* Look for resumed method in compression list */
		for (m = 0; m < i; m++) {
			if (q[m] == comp_id)
				break;
		}
		if (m >= i) {
			al = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
			    SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING);
			goto f_err;
		}
	} else if (s->hit)
		comp = NULL;
	else if (!(s->options & SSL_OP_NO_COMPRESSION) && s->ctx->comp_methods)
	{ /* See if we have a match */
		int m, nn, o, v, done = 0;

		nn = sk_SSL_COMP_num(s->ctx->comp_methods);
		for (m = 0; m < nn; m++) {
			comp = sk_SSL_COMP_value(s->ctx->comp_methods, m);
			v = comp->id;
			for (o = 0; o < i; o++) {
				if (v == q[o]) {
					done = 1;
					break;
				}
			}
			if (done)
				break;
		}
		if (done)
			s->s3->tmp.new_compression = comp;
		else
			comp = NULL;
	}
#else
	/*
	 * If compression is disabled we'd better not try to resume a session
	 * using compression.
	 */
	if (s->session->compress_meth != 0) {
		al = SSL_AD_INTERNAL_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
		    SSL_R_INCONSISTENT_COMPRESSION);
		goto f_err;
	}
#endif

	/*
a1177 5
#ifdef OPENSSL_NO_COMP
		s->session->compress_meth = 0;
#else
		s->session->compress_meth = (comp == NULL) ? 0 : comp->id;
#endif
a1319 1
#ifdef OPENSSL_NO_COMP
a1320 6
#else
		if (s->s3->tmp.new_compression == NULL)
			*(p++) = 0;
		else
			*(p++) = s->s3->tmp.new_compression->id;
#endif
@


1.68
log
@tedu the SSL export cipher handling - since we do not have enabled export
ciphers we no longer need the flags or code to support it.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.67 2014/06/30 14:13:27 tedu Exp $ */
d315 4
a318 2
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
d409 3
a411 3
				 * RSA key even when forbidden by protocol specs
				 * (handshake may fail as clients are not
				 * required to be able to handle this)
d418 2
a419 1
			/* only send if a DH key exchange, fortezza or
d422 2
a423 1
			 * PSK: may send PSK identity hints
a431 2
			/* PSK: send ServerKeyExchange if PSK identity
			 * hint if provided */
d1075 4
a1078 2
			/* we need to have the cipher in the cipher
			 * list if we are asked to reuse it */
d1848 1
a1848 2
		/* we should now have things packed up, so lets send
		 * it off */
d1934 1
a1934 3
		/* we should now have things packed up, so lets send
		 * it off */

d1979 1
a1979 1

d1981 1
a1981 2
	    SSL3_ST_SR_KEY_EXCH_B, SSL3_MT_CLIENT_KEY_EXCHANGE,
	    2048, /* ??? */ &ok);
d1993 4
a1996 2
			/* Don't do a callback because rsa_tmp should
			 * be sent already */
d2059 2
a2060 1
				/* The Klima-Pokorny-Rosa extension of
d2233 2
a2234 1
			/* Get client's public key from encoded point
d2481 1
d2483 1
a2483 2
	    SSL3_ST_SR_CERT_VRFY_B, -1,
	    516, /* Enough for 4096 bit RSA key with TLS v1.2 */ &ok);
d2822 4
a2825 2
	/* With the current implementation, sess_cert will always be NULL
	 * when we arrive here. */
d2837 5
a2841 2
	/* Inconsistency alert: cert_chain does *not* include the
	 * peer's own certificate, while we do include it in s3_clnt.c */
d3092 1
d3094 1
a3094 2
	    SSL3_ST_SR_NEXT_PROTO_B, SSL3_MT_NEXT_PROTO,
	    514,  /* See the payload format below */ &ok);
@


1.67
log
@fix the identical leak in three different files.
reported by Brent Cook, original diff by logan
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.66 2014/06/19 21:29:51 tedu Exp $ */
d438 1
a438 5
			    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
			    && EVP_PKEY_size(
			    s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) * 8
			    > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher
			    ))))) {
a1294 2
				if (SSL_C_IS_EXPORT(c))
					ec = c;
d1505 1
a1505 3
				rsa = s->cert->rsa_tmp_cb(s,
				SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
d1529 1
a1529 3
				dhp = s->cert->dh_tmp_cb(s,
			SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
			SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
d1577 2
a1578 6
			if ((ecdhp == NULL) && (s->cert->ecdh_tmp_cb != NULL)) {
				ecdhp = s->cert->ecdh_tmp_cb(
				    s, SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				    SSL_C_EXPORT_PKEYLENGTH(
				    s->s3->tmp.new_cipher));
			}
a1619 7
				goto err;
			}

			if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
			    (EC_GROUP_get_degree(group) > 163)) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
@


1.66
log
@convert CRYPTO_memcmp to timingsafe_memcmp based on current policy favoring
libc interfaces over libcrypto interfaces. for now we also prefer
timingsafe_memcmp over timingsafe_bcmp, even when the latter is acceptable.
ok beck deraadt matthew miod
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.65 2014/06/18 04:51:31 miod Exp $ */
a216 1
	BUF_MEM *buf;
d266 1
d273 1
@


1.65
log
@In ssl3_send_newsession_ticket(), fix a memory leak in an error path.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_srvr.c,v 1.64 2014/06/12 15:49:31 deraadt Exp $ */
d1027 1
a1027 1
			} else if (CRYPTO_memcmp(s->d1->rcvd_cookie, s->d1->cookie,
@


1.64
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d2963 2
a2964 1
		    EVP_MAX_MD_SIZE + slen))
d2966 1
@


1.63
log
@Stop setting the EVP_MD_CTX_FLAG_NON_FIPS_ALLOW - it has been ignored since
OpenSSL 1.0.0.

ok miod@@ (a little while back)
@
text
@d1 1
a1 1
/* ssl/s3_srvr.c */
@


1.62
log
@c-file-style hints, begone; ok beck
@
text
@a1795 2
					EVP_MD_CTX_set_flags(&md_ctx,
					    EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
@


1.61
log
@http://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2016265dfbab162ec30718b5e7480add42598158
Don't know the full story, but it looks like a "can't do random
perfectly, so do it god awful" problem was found in 2013, and
replaced with "only do it badly if a flag is set".  New flags
(SSL_MODE_SEND_SERVERHELLO_TIME and SSL_MODE_SEND_SERVERHELLO_TIME)
were added [Ben Laurie?] to support the old scheme of "use time_t
for first 4 bytes of the random buffer".

Nothing uses these flags [ecosystem scan by sthen]

Fully discourage use of these flags in the future by removing
support & definition of them.  The buflen < 4 check is also interesting,
because no entropy would be returned.  No callers passed such small
buffers.
ok miod sthen
@
text
@d1 1
a1 1
/* ssl/s3_srvr.c -*- mode:C; c-file-style: "eay" -*- */
@


1.60
log
@The DH_free, EC_KEY_free, EVP_PKEY_free and RSA_free functions all have
implicit NULL checks, so there is no point ensuring that the pointer is
non-NULL before calling them.
@
text
@d1133 1
a1133 4
		if (ssl_fill_hello_random(s, 1, pos, SSL3_RANDOM_SIZE) <= 0) {
			al = SSL_AD_INTERNAL_ERROR;
			goto f_err;
		}
@


1.59
log
@Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret.

For a detailed analysis see:

  https://www.imperialviolet.org/2014/06/05/earlyccs.html

This is a fix for CVE-2014-0224, from OpenSSL.

This issue was reported to OpenSSL by KIKUCHI Masashi. Unfortunately the
recent OpenSSL commit was the first we were made aware of the issue.

ok deraadt@@ sthen@@
@
text
@d869 4
a872 8
		if (s->s3->tmp.dh != NULL) {
			DH_free(s->s3->tmp.dh);
			s->s3->tmp.dh = NULL;
		}
		if (s->s3->tmp.ecdh != NULL) {
			EC_KEY_free(s->s3->tmp.ecdh);
			s->s3->tmp.ecdh = NULL;
		}
d2464 1
a2464 1
		gerr:
d2484 1
a2484 2
	if (srvr_ecdh != NULL)
		EC_KEY_free(srvr_ecdh);
@


1.58
log
@without overthinking it, replace a few memcmp calls with CRYPTO_memcmp
where it is feasible to do so. better safe than sorry.
@
text
@d638 1
d669 1
d740 2
a741 1
				if (s->s3->next_proto_neg_seen)
d744 1
a744 1
				else
@


1.57
log
@More manual OPENSSL_NO_EC and OPENSSL_NO_TLSEXT cleanup.
@
text
@d1028 1
a1028 1
			} else if (memcmp(s->d1->rcvd_cookie, s->d1->cookie,
@


1.56
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@d573 1
a573 1
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
d644 1
a644 1
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
d655 1
a655 1
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
d735 1
a735 1
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
@


1.55
log
@Make use of SSL_IS_DTLS, SSL_USE_EXPLICIT_IV, SSL_USE_SIGALGS and
SSL_USE_TLS1_2_CIPHERS.

Largely based on OpenSSL head.
@
text
@a359 1
#ifndef OPENSSL_NO_TLSEXT
a365 4
#else
			if (s->hit)
				s->state = SSL3_ST_SW_CHANGE_A;
#endif
a382 1
#ifndef OPENSSL_NO_TLSEXT
a390 6
#else
			} else
				skip = 1;

			s->state = SSL3_ST_SW_KEY_EXCH_A;
#endif
a673 1
#ifndef OPENSSL_NO_TLSEXT
a675 1
#endif
a680 1
#ifndef OPENSSL_NO_TLSEXT
a698 1
#endif
a1109 1
#ifndef OPENSSL_NO_TLSEXT
a1176 1
#endif
a1365 5
#ifdef OPENSSL_NO_TLSEXT
		p = s->s3->server_random;
		if (ssl_fill_hello_random(s, 1, p, SSL3_RANDOM_SIZE) <= 0)
			return (-1);
#endif
a1420 1
#ifndef OPENSSL_NO_TLSEXT
a1431 1
#endif
a2905 1
#ifndef OPENSSL_NO_TLSEXT
a3156 1
#endif
@


1.54
log
@the comment says RAND_pseudo_bytes should be RAND_bytes. make it so.
ok deraadt
@
text
@d594 1
a594 1
			} else if (TLS1_get_version(s) >= TLS1_2_VERSION) {
d600 1
a600 1
				 * For TLS v1.2 freeze the handshake buffer
d983 1
a983 1
         * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (it's a new flag
d1013 1
a1013 1
	if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER) {
d1334 1
a1334 2
	if (TLS1_get_version(s) < TLS1_2_VERSION ||
	    !(s->verify_mode & SSL_VERIFY_PEER)) {
d1821 1
a1821 2
			if (pkey->type == EVP_PKEY_RSA
				&& TLS1_get_version(s) < TLS1_2_VERSION) {
d1851 3
a1853 7
			} else
			if (md) {
				/*
				 * For TLS1.2 and later send signature
				 * algorithm
				 */
				if (TLS1_get_version(s) >= TLS1_2_VERSION) {
d1881 1
a1881 1
				if (TLS1_get_version(s) >= TLS1_2_VERSION)
d1934 1
a1934 1
		if (TLS1_get_version(s) >= TLS1_2_VERSION) {
d2589 1
a2589 1
		if (TLS1_get_version(s) >= TLS1_2_VERSION) {
d2632 1
a2632 1
	if (TLS1_get_version(s) >= TLS1_2_VERSION) {
@


1.53
log
@unidef DH, ECDH, and ECDSA. there's no purpose to a libssl without them.
ok deraadt jsing
@
text
@d2140 1
a2140 6
			/*
			 * Should be RAND_bytes, but we cannot work around a
			 * failure.
			 */
			if (RAND_pseudo_bytes(p+2, i-2) <= 0)
				goto err;
@


1.52
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@a161 1
#ifndef OPENSSL_NO_DH
a162 1
#endif
a881 1
#ifndef OPENSSL_NO_DH
a885 2
#endif
#ifndef OPENSSL_NO_ECDH
a889 1
#endif
a1505 1
#ifndef OPENSSL_NO_DH
a1506 2
#endif
#ifndef OPENSSL_NO_ECDH
a1512 1
#endif
a1562 1
#ifndef OPENSSL_NO_DH
a1611 2
#endif
#ifndef OPENSSL_NO_ECDH
a1736 1
#endif /* !OPENSSL_NO_ECDH */
a1781 1
#ifndef OPENSSL_NO_ECDH
a1804 1
#endif
a1912 1
#ifndef OPENSSL_NO_ECDH
a1914 1
#endif
a2026 1
#ifndef OPENSSL_NO_DH
a2028 1
#endif
a2029 1
#ifndef OPENSSL_NO_ECDH
a2034 1
#endif
a2153 1
#ifndef OPENSSL_NO_DH
a2208 1
#endif
a2209 1
#ifndef OPENSSL_NO_ECDH
a2352 1
#endif
a2518 1
#ifndef OPENSSL_NO_ECDH
a2523 1
#endif
a2696 1
#ifndef OPENSSL_NO_ECDSA
a2708 1
#endif
@


1.51
log
@Remove TLS_DEBUG, SSL_DEBUG, CIPHER_DEBUG and OPENSSL_RI_DEBUG. Much of
this is sporadic, hacked up and can easily be put back in an improved form
should we ever need it.

ok miod@@
@
text
@d1930 1
a1930 2
	if (encodedPoint != NULL)
		free(encodedPoint);
d2437 1
a2437 2
		if (s->session->psk_identity != NULL)
			free(s->session->psk_identity);
d2445 1
a2445 2
		if (s->session->psk_identity_hint != NULL)
			free(s->session->psk_identity_hint);
@


1.50
log
@DeIMPLEMENT libssl. Expand the IMPLEMENT_* macros since it is far more
readable and one less layer of abstraction. Use C99 initialisers for
clarity, grepability and to protect from future field reordering/removal.

ok miod@@ (tedu@@ also thought it was a wonderful idea, beck@@ also agreed,
but ran away squealing since it reminded him of the VOP layer...)
@
text
@a1090 3
#ifdef CIPHER_DEBUG
		printf("client sent %d ciphers\n", sk_num(ciphers));
#endif
a1092 4
#ifdef CIPHER_DEBUG
			printf("client [%2d of %2d]:%s\n",
			i, sk_num(ciphers), SSL_CIPHER_get_name(c));
#endif
a1885 4
#ifdef SSL_DEBUG
				fprintf(stderr, "Using hash %s\n",
				    EVP_MD_name(md));
#endif
a2653 4
#ifdef SSL_DEBUG
			fprintf(stderr, "USING TLSv1.2 HASH %s\n",
			    EVP_MD_name(md));
#endif
a2683 4
#ifdef SSL_DEBUG
		fprintf(stderr, "Using TLS 1.2 with client verify alg %s\n",
		    EVP_MD_name(md));
#endif
@


1.49
log
@Stop including kssl_lcl.h and nuke it from orbit - it is a no-op now.

ok beck@@ miod@@
@
text
@d170 38
a214 4


IMPLEMENT_ssl3_meth_func(SSLv3_server_method,
    ssl3_accept, ssl_undefined_function, ssl3_get_server_method)
@


1.48
log
@In ssl3_send_certificate_request(), when adding the extra payload if
NETSCAPE_HANG_BUG is defined, make sure we BUF_MEM_grow() the buffer to
accomodate for the payload size.

Issue reported by David Ramos; ok beck@@
@
text
@a155 1
#include "kssl_lcl.h"
@


1.47
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@d1991 6
a1996 1
		p = (unsigned char *)s->init_buf->data + s->init_num;
@


1.46
log
@More KNF, things that couldn't be verified with md5(1), and some whitespace
I missed on the first go around.
@
text
@a166 3
#ifndef OPENSSL_NO_KRB5
#include <openssl/krb5_asn.h>
#endif
a178 24
#ifndef OPENSSL_NO_SRP
static int
ssl_check_srp_ext_ClientHello(SSL *s, int *al)
{
	int ret = SSL_ERROR_NONE;

	*al = SSL_AD_UNRECOGNIZED_NAME;

	if ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) &&
		(s->srp_ctx.TLS_ext_srp_username_callback != NULL)) {
		if (s->srp_ctx.login == NULL) {
			/*
			 * RFC 5054 says SHOULD reject,
			 * we do so if There is no srp login name
			 */
			ret = SSL3_AL_FATAL;
			*al = SSL_AD_UNKNOWN_PSK_IDENTITY;
		} else {
			ret = SSL_srp_server_param_with_username(s, al);
		}
	}
	return (ret);
}
#endif
a317 33
#ifndef OPENSSL_NO_SRP
			{
				int al;
				if ((ret =
				    ssl_check_srp_ext_ClientHello(s, &al))
				    < 0) {
					/*
					 * Callback indicates further work to
					 * be done.
					 */
					s->rwstate = SSL_X509_LOOKUP;
					goto end;
				}
				if (ret != SSL_ERROR_NONE) {
					ssl3_send_alert(s, SSL3_AL_FATAL, al);

					/*
					 * This is not really an error but the
					 * only means for a client to detect
					 * whether srp is supported.
					 */
					if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY)
						SSLerr(SSL_F_SSL3_ACCEPT,
						    SSL_R_CLIENTHELLO_TLSEXT);

					ret = SSL_TLSEXT_ERR_ALERT_FATAL;

					ret = -1;
					goto end;

				}
			}
#endif		
a383 3
#ifndef OPENSSL_NO_KRB5
			    && !(alg_k & SSL_kKRB5)
#endif /* OPENSSL_NO_KRB5 */
a412 4
#ifndef OPENSSL_NO_SRP
			/* SRP: send ServerKeyExchange */
			    || (alg_k & SSL_kSRP)
#endif
a1731 14
#ifndef OPENSSL_NO_SRP
		if (type & SSL_kSRP) {
			if ((s->srp_ctx.N == NULL) || (s->srp_ctx.g == NULL) ||
			    (s->srp_ctx.s == NULL) || (s->srp_ctx.B == NULL)) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
				    SSL_R_MISSING_SRP_PARAM);
				goto err;
			}
			r[0] = s->srp_ctx.N;
			r[1] = s->srp_ctx.g;
			r[2] = s->srp_ctx.s;
			r[3] = s->srp_ctx.B;
		} else
#endif
a1739 5
#ifndef OPENSSL_NO_SRP
			if ((i == 2) && (type & SSL_kSRP))
				n += 1 + nr[i];
			else
#endif
a1764 6
#ifndef OPENSSL_NO_SRP
			if ((i == 2) && (type & SSL_kSRP)) {
				*p = nr[i];
				p++;
			} else
#endif
a2022 3
#ifndef OPENSSL_NO_KRB5
	KSSL_ERR kssl_err;
#endif /* OPENSSL_NO_KRB5 */
a2206 185
#ifndef OPENSSL_NO_KRB5
	if (alg_k & SSL_kKRB5) {
		krb5_error_code		krb5rc;
		krb5_data		enc_ticket;
		krb5_data		authenticator;
		krb5_data		enc_pms;
		KSSL_CTX		*kssl_ctx = s->kssl_ctx;
		EVP_CIPHER_CTX		ciph_ctx;
		const EVP_CIPHER	*enc = NULL;
		unsigned char		iv[EVP_MAX_IV_LENGTH];
		unsigned char		pms[SSL_MAX_MASTER_KEY_LENGTH
		+ EVP_MAX_BLOCK_LENGTH];
		int		     padl, outl;
		krb5_timestamp		authtime = 0;
		krb5_ticket_times	ttimes;

		EVP_CIPHER_CTX_init(&ciph_ctx);

		if (!kssl_ctx)
			kssl_ctx = kssl_ctx_new();

		n2s(p, i);
		enc_ticket.length = i;

		if (n < (long)(enc_ticket.length + 6)) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
		}

		enc_ticket.data = (char *)p;
		p += enc_ticket.length;

		n2s(p, i);
		authenticator.length = i;

		if (n < (long)(enc_ticket.length + authenticator.length + 6)) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
		}

		authenticator.data = (char *)p;
		p += authenticator.length;

		n2s(p, i);
		enc_pms.length = i;
		enc_pms.data = (char *)p;
		p += enc_pms.length;

		/*
		 * Note that the length is checked again below,
		 * after decryption
		 */
		if (enc_pms.length > sizeof pms) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
		}

		if (n != (long)(enc_ticket.length + authenticator.length +
		    enc_pms.length + 6)) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
		}

		if ((krb5rc = kssl_sget_tkt(kssl_ctx, &enc_ticket, &ttimes,
		    &kssl_err)) != 0) {
#ifdef KSSL_DEBUG
			printf("kssl_sget_tkt rtn %d [%d]\n",
			krb5rc, kssl_err.reason);
			if (kssl_err.text)
				printf("kssl_err text= %s\n", kssl_err.text);
#endif	/* KSSL_DEBUG */
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			kssl_err.reason);
			goto err;
		}

		/*  Note: no authenticator is not considered an error,
		**  but will return authtime == 0.
		*/
		if ((krb5rc = kssl_check_authent(kssl_ctx, &authenticator,
		    &authtime, &kssl_err)) != 0) {
#ifdef KSSL_DEBUG
			printf("kssl_check_authent rtn %d [%d]\n",
			krb5rc, kssl_err.reason);
			if (kssl_err.text)
				printf("kssl_err text= %s\n", kssl_err.text);
#endif	/* KSSL_DEBUG */
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    kssl_err.reason);
			goto err;
		}

		if ((krb5rc = kssl_validate_times(authtime, &ttimes)) != 0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    krb5rc);
			goto err;
		}

#ifdef KSSL_DEBUG
		kssl_ctx_show(kssl_ctx);
#endif	/* KSSL_DEBUG */

		enc = kssl_map_enc(kssl_ctx->enctype);
		if (enc == NULL)
			goto err;

		memset(iv, 0, sizeof iv);	/* per RFC 1510 */

		if (!EVP_DecryptInit_ex(&ciph_ctx, enc, NULL,
		    kssl_ctx->key, iv)) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DECRYPTION_FAILED);
			goto err;
		}
		if (!EVP_DecryptUpdate(&ciph_ctx, pms, &outl,
		    (unsigned char *)enc_pms.data, enc_pms.length)) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DECRYPTION_FAILED);
			goto err;
		}
		if (outl > SSL_MAX_MASTER_KEY_LENGTH) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
		}
		if (!EVP_DecryptFinal_ex(&ciph_ctx, &(pms[outl]), &padl)) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DECRYPTION_FAILED);
			goto err;
		}
		outl += padl;
		if (outl > SSL_MAX_MASTER_KEY_LENGTH) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
		}
		if (!((pms[0] == (s->client_version >> 8)) && (pms[1] == (s->client_version & 0xff)))) {
			/*
			 * The premaster secret must contain the same version
			 * number as the ClientHello to detect version rollback
			 * attacks (strangely, the protocol does not offer such
			 * protection for DH ciphersuites).
			 * However, buggy clients exist that send random bytes
			 * instead of the protocol version.
			 *
			 * If SSL_OP_TLS_ROLLBACK_BUG is set, tolerate such
			 * clients.
			 * (Perhaps we should have a separate BUG value for
			 * the Kerberos cipher)
			 */
			if (!(s->options & SSL_OP_TLS_ROLLBACK_BUG)) {
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    SSL_AD_DECODE_ERROR);
				goto err;
			}
		}

		EVP_CIPHER_CTX_cleanup(&ciph_ctx);

		s->session->master_key_length =
		s->method->ssl3_enc->generate_master_secret(s,
		    s->session->master_key, pms, outl);

		if (kssl_ctx->client_princ) {
			size_t len = strlen(kssl_ctx->client_princ);
			if (len < SSL_MAX_KRB5_PRINCIPAL_LENGTH ) {
				s->session->krb5_client_princ_len = len;
				memcpy(s->session->krb5_client_princ,
				    kssl_ctx->client_princ, len);
			}
		}


		/*
		 * Was doing kssl_ctx_free() here, but it caused problems for
		 * apache.
		 * kssl_ctx = kssl_ctx_free(kssl_ctx);
		 * if (s->kssl_ctx)  s->kssl_ctx = NULL;
		 */
	} else
#endif	/* OPENSSL_NO_KRB5 */
a2439 37
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP) {
		int param_len;

		n2s(p, i);
		param_len = i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_BAD_SRP_A_LENGTH);
			goto f_err;
		}
		if (!(s->srp_ctx.A = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		if (s->session->srp_username != NULL)
			free(s->session->srp_username);
		s->session->srp_username = BUF_strdup(s->srp_ctx.login);
		if (s->session->srp_username == NULL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}

		if ((s->session->master_key_length =
		    SRP_generate_server_master_secret(s,
		    s->session->master_key)) < 0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}

		p += i;
	} else
#endif	/* OPENSSL_NO_SRP */
@


1.45
log
@Make libssl and libcrypto compile with -Werror
ok miod@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d114 1
a114 1
 * Portions of the attached software ("Contribution") are developed by 
d193 4
a196 2
			/* RFC 5054 says SHOULD reject, 
			   we do so if There is no srp login name */
d203 1
a203 1
	return ret;
d233 2
a234 1
		SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_NO_CERTIFICATE_SET);
d256 3
a258 2
				SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
d349 1
a349 1
				    ssl_check_srp_ext_ClientHello(s, &al)) 
d538 1
a538 1
						return -1;
d642 1
a642 1
					return -1;
d646 1
a646 1
					return -1;
d654 1
a654 1
				/* 
d663 1
a663 1
						return -1;
d834 2
a835 1
			SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNKNOWN_STATE);
d911 1
a911 1
			return -1;
d931 1
a931 1
		return 2;
d933 1
a933 1
	return 1;
d982 2
a983 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_WRONG_VERSION_NUMBER);
d1008 1
a1008 1
			return 1;
d1057 1
a1057 1
		/* 
d1103 2
a1104 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_CIPHERS_SPECIFIED);
d1110 2
a1111 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
d1154 2
a1155 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
d1184 2
a1185 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
d1390 1
a1390 1
	 * We now have the following setup. 
d1435 1
a1435 1
			return -1;
d1473 1
a1473 1
			return -1;
d1496 1
a1496 1
			return -1;
d1502 1
a1502 1
			return -1;
d1727 1
a1727 1
			/* 
d1729 1
a1729 1
			 * keys over named (not generic) curves. For 
d1739 1
a1739 1
			/* 
d1773 2
a1774 2
			/* 
			 * XXX: For now, we only support named (not 
d1778 1
a1778 1
			 * structure. 
d1803 2
a1804 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_MISSING_SRP_PARAM);
d1815 2
a1816 1
			SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
d1937 1
a1937 1
				/* 
d2399 2
a2400 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, krb5rc);
d2452 1
a2452 1
			 * clients. 
d2479 1
a2479 1
		/* 
d2544 1
a2544 1
				/* 
d2549 2
a2550 2
				 * added, we ought to ensure the key 
				 * received in the certificate is 
d2598 1
a2598 1
			 */ 
d2824 1
a2824 1
			return ret;
d2913 1
a2913 1
	 * 
d2962 2
a2963 1
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_WRONG_SIGNATURE_SIZE);
d2984 2
a2985 1
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);
d2992 2
a2993 1
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_SIGNATURE);
d3062 2
a3063 1
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
d3297 1
a3297 1
			return -1;
d3300 1
a3300 1
			return -1;
d3312 1
a3312 1
			return -1;
d3322 1
a3322 1
			return -1;
d3328 1
a3328 1
		/* 
d3339 1
a3339 1
			return -1;
d3357 1
a3357 1
				return -1;
d3429 1
a3429 1
			return -1;
d3473 1
a3473 1
		return -1;
d3490 1
a3490 1
		return -1;
d3494 1
a3494 1
		return 0;
d3508 1
a3508 1
		return 0;
d3511 1
a3511 1
		return 0;
d3515 3
a3517 2
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO, ERR_R_MALLOC_FAILURE);
		return 0;
d3522 1
a3522 1
	return 1;
@


1.44
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@d1555 1
a1555 1
	size_t pskhintlen;
@


1.43
log
@More KNF and style consistency tweaks
@
text
@d1739 1
a1739 2
			encodedPoint = (unsigned char *)
			malloc(encodedlen*sizeof(unsigned char));
@


1.42
log
@whack a bunch of disabled code. ok beck lteo
@
text
@d174 2
a175 2
static const SSL_METHOD
*ssl3_get_server_method(int ver)
d179 1
a179 2
	else
		return (NULL);
@


1.41
log
@always build in RSA and DSA. ok deraadt miod
@
text
@a1131 18
/*
 * Disabled because it can be used in a ciphersuite downgrade
 * attack: CVE-2010-4180.
 */
#if 0
		if (j == 0 && (s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_SSL_CIPHER_num(ciphers) == 1)) {
			/* Special case as client bug workaround: the previously used cipher may
			 * not be in the current list, the client instead might be trying to
			 * continue using a cipher that before wasn't chosen due to server
			 * preferences.  We'll have to reject the connection if the cipher is not
			 * enabled, though. */
			c = sk_SSL_CIPHER_value(ciphers, 0);
			if (sk_SSL_CIPHER_find(SSL_get_ciphers(s), c) >= 0) {
				s->session->cipher = c;
				j = 1;
			}
		}
#endif
@


1.40
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a1556 1
#ifndef OPENSSL_NO_RSA
a1561 1
#endif
a1596 1
#ifndef OPENSSL_NO_RSA
a1622 1
#endif
a1911 1
#ifndef OPENSSL_NO_RSA
a1943 1
#endif
a2116 1
#ifndef OPENSSL_NO_RSA
a2118 1
#endif
a2143 1
#ifndef OPENSSL_NO_RSA
a2252 1
#endif
a2843 1
#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH) || defined(OPENSSL_NO_SRP)
a2844 1
#endif
a3000 1
#ifndef OPENSSL_NO_RSA 
a3017 2
#endif
#ifndef OPENSSL_NO_DSA
a3029 1
#endif
@


1.39
log
@add back SRP. i was being too greedy.
@
text
@d1763 1
a1763 1
			OPENSSL_malloc(encodedlen*sizeof(unsigned char));
d1894 1
a1894 1
			OPENSSL_free(encodedPoint);
d2015 1
a2015 1
		OPENSSL_free(encodedPoint);
d2709 1
a2709 1
			OPENSSL_free(s->session->psk_identity);
d2718 1
a2718 1
			OPENSSL_free(s->session->psk_identity_hint);
d2755 1
a2755 1
			OPENSSL_free(s->session->srp_username);
d3317 1
a3317 1
		senc = OPENSSL_malloc(slen_full);
d3330 1
a3330 1
			OPENSSL_free(senc);
d3340 1
a3340 1
			OPENSSL_free(senc);
d3375 1
a3375 1
				OPENSSL_free(senc);
d3429 1
a3429 1
		OPENSSL_free(senc);
d3532 1
a3532 1
	s->next_proto_negotiated = OPENSSL_malloc(proto_len);
@


1.38
log
@Thanks to the knobs in http://tools.ietf.org/html/rfc5746, we have a knob
to say "allow this connection to negotiate insecurely". de-fang the code
that respects this option to ignore it.
ok miod@@
@
text
@d183 22
d342 33
d473 4
d1813 13
d1833 5
d1863 6
d2737 37
d2854 1
d2856 1
@


1.37
log
@disentangle SRP code from TLS
@
text
@d272 1
a272 3
			} else if (!s->s3->send_connection_binding &&
			    !(s->options &
			    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
@


1.36
log
@strncpy(d, s, strlen(s)) is a special kind of stupid. even when it's right,
it looks wrong. replace with auditable code and eliminate many strlen calls
to improve efficiency. (wait, did somebody say FASTER?) ok beck
@
text
@a182 22
#ifndef OPENSSL_NO_SRP
static int
ssl_check_srp_ext_ClientHello(SSL *s, int *al)
{
	int ret = SSL_ERROR_NONE;

	*al = SSL_AD_UNRECOGNIZED_NAME;

	if ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) &&
		(s->srp_ctx.TLS_ext_srp_username_callback != NULL)) {
		if (s->srp_ctx.login == NULL) {
			/* RFC 5054 says SHOULD reject, 
			   we do so if There is no srp login name */
			ret = SSL3_AL_FATAL;
			*al = SSL_AD_UNKNOWN_PSK_IDENTITY;
		} else {
			ret = SSL_srp_server_param_with_username(s, al);
		}
	}
	return ret;
}
#endif
a321 33
#ifndef OPENSSL_NO_SRP
			{
				int al;
				if ((ret =
				    ssl_check_srp_ext_ClientHello(s, &al)) 
				    < 0) {
					/*
					 * Callback indicates further work to
					 * be done.
					 */
					s->rwstate = SSL_X509_LOOKUP;
					goto end;
				}
				if (ret != SSL_ERROR_NONE) {
					ssl3_send_alert(s, SSL3_AL_FATAL, al);

					/*
					 * This is not really an error but the
					 * only means for a client to detect
					 * whether srp is supported.
					 */
					if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY)
						SSLerr(SSL_F_SSL3_ACCEPT,
						    SSL_R_CLIENTHELLO_TLSEXT);

					ret = SSL_TLSEXT_ERR_ALERT_FATAL;

					ret = -1;
					goto end;

				}
			}
#endif		
a419 4
#ifndef OPENSSL_NO_SRP
			/* SRP: send ServerKeyExchange */
			    || (alg_k & SSL_kSRP)
#endif
a1755 13
#ifndef OPENSSL_NO_SRP
		if (type & SSL_kSRP) {
			if ((s->srp_ctx.N == NULL) || (s->srp_ctx.g == NULL) ||
			    (s->srp_ctx.s == NULL) || (s->srp_ctx.B == NULL)) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_MISSING_SRP_PARAM);
				goto err;
			}
			r[0] = s->srp_ctx.N;
			r[1] = s->srp_ctx.g;
			r[2] = s->srp_ctx.s;
			r[3] = s->srp_ctx.B;
		} else
#endif
a1762 5
#ifndef OPENSSL_NO_SRP
			if ((i == 2) && (type & SSL_kSRP))
				n += 1 + nr[i];
			else
#endif
a1787 6
#ifndef OPENSSL_NO_SRP
			if ((i == 2) && (type & SSL_kSRP)) {
				*p = nr[i];
				p++;
			} else
#endif
a2655 37
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP) {
		int param_len;

		n2s(p, i);
		param_len = i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    SSL_R_BAD_SRP_A_LENGTH);
			goto f_err;
		}
		if (!(s->srp_ctx.A = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		if (s->session->srp_username != NULL)
			OPENSSL_free(s->session->srp_username);
		s->session->srp_username = BUF_strdup(s->srp_ctx.login);
		if (s->session->srp_username == NULL) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}

		if ((s->session->master_key_length =
		    SRP_generate_server_master_secret(s,
		    s->session->master_key)) < 0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}

		p += i;
	} else
#endif	/* OPENSSL_NO_SRP */
a2735 1
#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH) || defined(OPENSSL_NO_SRP)
a2736 1
#endif
@


1.35
log
@KNF
@
text
@d1577 3
d1810 3
a1812 4
			/*
			 * Reserve size for record length and PSK identity hint.
			 */
			n += 2 + strlen(s->ctx->psk_identity_hint);
d1905 1
a1905 1
			s2n(strlen(s->ctx->psk_identity_hint), p);
d1907 2
a1908 3
			strncpy((char *)p, s->ctx->psk_identity_hint,
			   strlen(s->ctx->psk_identity_hint));
			p += strlen(s->ctx->psk_identity_hint);
@


1.34
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@d264 2
a265 1
				if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {
d281 4
a284 2
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
d295 4
a298 2
			    !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
				/* Server attempting to renegotiate with
d302 4
a305 2
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
				ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
d347 7
a353 2
				if ((ret = ssl_check_srp_ext_ClientHello(s, &al))  < 0) {
					/* callback indicates firther work to be done */
d360 5
a364 2
				/* This is not really an error but the only means to
                                   for a client to detect whether srp is supported. */
d366 2
a367 1
						SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_CLIENTHELLO_TLSEXT);
d409 4
a412 2
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
			&& !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)) {
d438 4
a441 2
			/* clear this, it may get reset by
			 * send_server_key_exchange */
d447 6
a452 4
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
				 * even when forbidden by protocol specs
				 * (handshake may fail as clients are not required to
				 * be able to handle this) */
d482 2
a483 1
			    && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
d485 4
a488 5
			    && EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
			    )
			    )
			    )
			    ) {
d501 1
a501 1
			if (/* don't request cert unless asked for it: */
d503 4
a506 2
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
d509 14
a522 7
				/* never request cert in anonymous ciphersuites
				 * (see section "Certificate request" in SSL 3 drafts
				 * and in RFC 2246): */
			    ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
			    !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
d525 7
a531 4
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
			    || (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {
				/* no cert request */
d565 2
a566 1
			/* This code originally checked to see if
d611 2
a612 1
				/* For the ECDH ciphersuites when
d634 2
a635 1
				/* For TLS v1.2 freeze the handshake buffer
d639 2
a640 1
					SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
d653 2
a654 1
				/* We need to get hashes here so if there is
d656 3
a658 2
				 * FIXME - digest processing for CertificateVerify
				 * should be generalized. But it is next step
d663 2
a664 1
				for (dgst_num = 0; dgst_num < SSL_MAX_DIGEST; dgst_num++)
d668 6
a673 2
					s->method->ssl3_enc->cert_verify_mac(s, EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]), &(s->s3->tmp.cert_verify_md[offset]));
					dgst_size = EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);
d761 1
a761 1
			SSL3_ST_SW_CHANGE_A, SSL3_ST_SW_CHANGE_B);
d790 2
a791 1
					s->s3->tmp.next_state = SSL3_ST_SR_NEXT_PROTO_A;
d793 2
a794 1
					s->s3->tmp.next_state = SSL3_ST_SR_FINISHED_A;
d813 2
a814 2
			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
			{
d892 6
a897 8
	/* this function is called when we really expect a Certificate message,
	 * so permit appropriate message length */
	n = s->method->ssl_get_message(s,
	SSL3_ST_SR_CERT_A,
	SSL3_ST_SR_CERT_B,
	-1,
	s->max_cert_list,
	&ok);
d902 4
a905 2
		/* We only allow the client to restart the handshake once per
		 * negotiation. */
d907 2
a908 1
			SSLerr(SSL_F_SSL3_CHECK_CLIENT_HELLO, SSL_R_MULTIPLE_SGC_RESTARTS);
d911 5
a915 2
		/* Throw away what we have done so far in the current handshake,
		 * which will now be aborted. (A full SSL_clear would be too much.) */
d948 2
a949 1
	/* We do this so that we will respond with our native type.
d971 4
a974 2
	/* use version from inside client hello, not from record header
	 * (may differ: see RFC 2246, Appendix E, second paragraph) */
d983 4
a986 1
			/* similar to ssl3_get_record, send alert using remote version number */
d993 2
a994 1
	/* If we require cookies and this ClientHello doesn't
d1016 8
a1023 5
	/* Versions before 0.9.7 always allow clients to resume sessions in renegotiation.
	 * 0.9.7 and later allow this by default, but optionally ignore resumption requests
	 * with flag SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (it's a new flag rather
	 * than a change to default behavior so that applications relying on this for security
	 * won't even compile against older library versions).
d1025 5
a1029 4
	 * 1.0.1 and later also have a function SSL_renegotiate_abbreviated() to request
	 * renegotiation but not a new session (s->new_session remains unset): for servers,
	 * this essentially just means that the SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
	 * setting will be ignored.
d1031 2
a1032 1
	if ((s->new_session && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION))) {
d1037 1
a1037 2
		if (i == 1)
				{ /* previous session */
d1041 2
a1042 2
		else /* i == 0 */
		{
d1062 2
a1063 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
d1073 2
a1074 2
				if (s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,
					cookie_len) == 0) {
d1077 1
a1077 1
					SSL_R_COOKIE_MISMATCH);
d1082 2
a1083 2
			    s->d1->cookie_len) != 0) /* default verification */
			{
d1086 1
a1086 1
				SSL_R_COOKIE_MISMATCH);
d1134 2
a1135 1
/* Disabled because it can be used in a ciphersuite downgrade
d1156 2
a1157 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_REQUIRED_CIPHER_MISSING);
d1180 2
a1181 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_COMPRESSION_SPECIFIED);
d1190 2
a1191 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_PARSE_TLSEXT);
d1200 2
a1201 1
	/* Check if we want to use external pre-shared secret for this
d1204 2
a1205 1
	 * SessionTicket processing to use it in key derivation. */
d1219 3
a1221 2
		if (s->tls_session_secret_cb(s, s->session->master_key, &s->session->master_key_length,
			ciphers, &pref_cipher, s->tls_session_secret_cb_arg)) {
d1229 3
a1231 1
			pref_cipher = pref_cipher ? pref_cipher : ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));
d1234 2
a1235 1
				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);
d1248 2
a1249 1
			s->cipher_list_by_id = sk_SSL_CIPHER_dup(s->session->ciphers);
d1254 2
a1255 1
	/* Worst case, we will use the NULL compression, but if we have other
d1257 2
a1258 1
	 * algorithms from the client, starting at q. */
d1268 2
a1269 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_INCONSISTENT_COMPRESSION);
d1282 2
a1283 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_INVALID_COMPRESSION_ALGORITHM);
d1293 2
a1294 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING);
d1322 2
a1323 1
	/* If compression is disabled we'd better not try to resume a session
d1328 2
a1329 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_INCONSISTENT_COMPRESSION);
d1334 4
a1337 2
	/* Given s->session->ciphers and SSL_get_ciphers, we must
	 * pick a cipher */
d1350 2
a1351 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_CIPHERS_PASSED);
d1360 2
a1361 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);
d1392 2
a1393 1
	if (TLS1_get_version(s) < TLS1_2_VERSION || !(s->verify_mode & SSL_VERIFY_PEER)) {
d1400 2
a1401 1
	/* we now have the following setup. 
d1415 2
a1416 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
d1458 2
a1459 1
		/* There are several cases for the session ID to send
d1461 1
d1471 1
d1477 2
a1478 2
			&& !s->hit)
		s->session->session_id_length = 0;
d1482 2
a1483 1
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO, ERR_R_INTERNAL_ERROR);
d1505 2
a1506 1
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO, SSL_R_SERVERHELLO_TLSEXT);
d1509 4
a1512 2
		if ((p = ssl_add_serverhello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH)) == NULL) {
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO, ERR_R_INTERNAL_ERROR);
d1607 3
a1609 1
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_ERROR_GENERATING_TMP_RSA_KEY);
d1617 2
a1618 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_MISSING_TMP_RSA_KEY);
d1635 2
a1636 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_MISSING_TMP_DH_KEY);
d1641 2
a1642 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d1647 2
a1648 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_DH_LIB);
d1656 3
a1658 2
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
					ERR_R_DH_LIB);
d1666 3
a1668 1
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_DH_LIB);
d1685 2
a1686 1
				    SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
d1690 2
a1691 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_MISSING_TMP_ECDH_KEY);
d1696 2
a1697 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d1703 2
a1704 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_ECDH_LIB);
d1708 2
a1709 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_ECDH_LIB);
d1718 3
a1720 1
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_ECDH_LIB);
d1728 1
a1728 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_ECDH_LIB);
d1734 2
a1735 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
d1739 2
a1740 1
			/* XXX: For now, we only support ephemeral ECDH
d1746 2
a1747 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);
d1751 2
a1752 1
			/* Encode the public key.
d1757 3
a1759 3
			EC_KEY_get0_public_key(ecdh),
			POINT_CONVERSION_UNCOMPRESSED,
			NULL, 0, NULL);
d1766 2
a1767 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
d1773 3
a1775 3
			EC_KEY_get0_public_key(ecdh),
			POINT_CONVERSION_UNCOMPRESSED,
			encodedPoint, encodedlen, bn_ctx);
d1778 2
a1779 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_ECDH_LIB);
d1786 2
a1787 1
			/* XXX: For now, we only support named (not 
d1795 2
a1796 1
			/* We'll generate the serverKeyExchange message
d1807 3
a1809 1
			/* reserve size for record length and PSK identity hint*/
d1855 2
a1856 1
			SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_BUF);
d1876 3
a1878 1
			/* XXX: For now, we only support named (not generic) curves.
d1905 2
a1906 1
			strncpy((char *)p, s->ctx->psk_identity_hint, strlen(s->ctx->psk_identity_hint));
d1913 4
a1916 2
			/* n is the length of the params, they start at &(d[4])
			 * and p points to the space at the end. */
d1924 1
a1924 1
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d1926 8
a1933 3
					    (num == 2) ? s->ctx->md5 : s->ctx->sha1, NULL);
					EVP_DigestUpdate(&md_ctx, &(s->s3->client_random[0]), SSL3_RANDOM_SIZE);
					EVP_DigestUpdate(&md_ctx, &(s->s3->server_random[0]), SSL3_RANDOM_SIZE);
d1935 2
a1936 1
					EVP_DigestFinal_ex(&md_ctx, q, (unsigned int *)&i);
d1942 3
a1944 1
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_RSA);
d1952 4
a1955 2
				/* For TLS1.2 and later send signature
				 * algorithm */
d1960 3
a1962 1
						SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d1969 1
a1969 1
				EVP_MD_name(md));
d1972 6
a1977 2
				EVP_SignUpdate(&md_ctx, &(s->s3->client_random[0]), SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx, &(s->s3->server_random[0]), SSL3_RANDOM_SIZE);
d1981 3
a1983 1
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_EVP);
d1993 2
a1994 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_UNKNOWN_PKEY_TYPE);
d2062 3
a2064 1
					SSLerr(SSL_F_SSL3_SEND_CERTIFICATE_REQUEST, ERR_R_BUF_LIB);
d2163 2
a2164 1
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_MISSING_TMP_RSA_PKEY);
d2173 2
a2174 1
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_MISSING_RSA_CERTIFICATE);
d2185 3
a2187 1
					SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
d2204 13
a2216 8
		if ((al == -1) && !((p[0] == (s->client_version >> 8)) && (p[1] == (s->client_version & 0xff)))) {
			/* The premaster secret must contain the same version number as the
			 * ClientHello to detect version rollback attacks (strangely, the
			 * protocol does not offer such protection for DH ciphersuites).
			 * However, buggy clients exist that send the negotiated protocol
			 * version instead if the server does not support the requested
			 * protocol version.
			 * If SSL_OP_TLS_ROLLBACK_BUG is set, tolerate such clients. */
d2218 2
a2219 1
				(p[0] == (s->version >> 8)) && (p[1] == (s->version & 0xff)))) {
d2223 12
a2234 7
				/* The Klima-Pokorny-Rosa extension of Bleichenbacher's attack
				 * (http://eprint.iacr.org/2003/052/) exploits the version
				 * number check as a "bad version oracle" -- an alert would
				 * reveal that the plaintext corresponding to some ciphertext
				 * made up by the adversary is properly formatted except
				 * that the version number is wrong.  To avoid such attacks,
				 * we should treat this just like any other decryption error. */
d2239 6
a2244 3
			/* Some decryption failure -- use random value instead as countermeasure
			 * against Bleichenbacher's attack on PKCS #1 v1.5 RSA padding
			 * (see RFC 2246, section 7.4.7.1). */
d2249 5
a2253 1
			if (RAND_pseudo_bytes(p+2, i-2) <= 0) /* should be RAND_bytes, but we cannot work around a failure */
d2258 3
a2260 3
		s->method->ssl3_enc->generate_master_secret(s,
		s->session->master_key,
		p, i);
d2269 2
a2270 1
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
d2278 2
a2279 2
		if (n == 0L) /* the parameters are in the cert */
		{
d2281 2
a2282 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_UNABLE_TO_DECODE_DH_CERTS);
d2287 2
a2288 1
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_MISSING_TMP_DH_KEY);
d2296 2
a2297 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_BN_LIB);
d2304 2
a2305 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);
d2347 1
a2347 1
			SSL_R_DATA_LENGTH_TOO_LONG);
d2359 1
a2359 1
			SSL_R_DATA_LENGTH_TOO_LONG);
d2371 4
a2374 3
		/* Note that the length is checked again below,
		** after decryption
		*/
d2377 1
a2377 1
			SSL_R_DATA_LENGTH_TOO_LONG);
d2384 1
a2384 1
			SSL_R_DATA_LENGTH_TOO_LONG);
d2413 1
a2413 1
			kssl_err.reason);
d2432 2
a2433 1
		if (!EVP_DecryptInit_ex(&ciph_ctx, enc, NULL, kssl_ctx->key, iv)) {
d2435 1
a2435 1
			SSL_R_DECRYPTION_FAILED);
d2441 1
a2441 1
			SSL_R_DECRYPTION_FAILED);
d2446 1
a2446 1
			SSL_R_DATA_LENGTH_TOO_LONG);
d2451 1
a2451 1
			SSL_R_DECRYPTION_FAILED);
d2457 1
a2457 1
			SSL_R_DATA_LENGTH_TOO_LONG);
d2461 13
a2473 8
		    /* The premaster secret must contain the same version number as the
		     * ClientHello to detect version rollback attacks (strangely, the
		     * protocol does not offer such protection for DH ciphersuites).
		     * However, buggy clients exist that send random bytes instead of
		     * the protocol version.
		     * If SSL_OP_TLS_ROLLBACK_BUG is set, tolerate such clients. 
		     * (Perhaps we should have a separate BUG value for the Kerberos cipher)
		     */
d2476 1
a2476 1
				SSL_AD_DECODE_ERROR);
d2485 1
a2485 1
		s->session->master_key, pms, outl);
d2491 2
a2492 1
				memcpy(s->session->krb5_client_princ, kssl_ctx->client_princ, len);
d2497 6
a2502 5
		/*  Was doing kssl_ctx_free() here,
		**  but it caused problems for apache.
		**  kssl_ctx = kssl_ctx_free(kssl_ctx);
		**  if (s->kssl_ctx)  s->kssl_ctx = NULL;
		*/
d2514 1
a2514 1
		/* initialize structures for server's ECDH key pair */
d2517 1
a2517 1
			ERR_R_MALLOC_FAILURE);
d2521 1
a2521 1
		/* Let's get server private key and group information */
d2523 1
a2523 1
			/* use the certificate */
d2526 2
a2527 1
			/* use the ephermeral values we saved when
d2537 1
a2537 1
			!EC_KEY_set_private_key(srvr_ecdh, priv_key)) {
d2539 1
a2539 1
			ERR_R_EC_LIB);
d2546 1
a2546 1
			ERR_R_MALLOC_FAILURE);
d2555 2
a2556 1
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_MISSING_TMP_ECDH_KEY);
d2562 2
a2563 1
				/* XXX: For now, we do not support client
d2576 1
a2576 1
				SSL_R_UNABLE_TO_DECODE_ECDH_CERTS);
d2581 2
a2582 1
				EC_KEY_get0_public_key(clnt_pub_pkey->pkey.ec)) == 0) {
d2584 1
a2584 1
				ERR_R_EC_LIB);
d2594 1
a2594 1
				ERR_R_MALLOC_FAILURE);
d2604 1
a2604 1
				ERR_R_EC_LIB);
d2610 1
a2610 1
				ERR_R_EC_LIB);
d2613 3
a2615 2
			/* p is pointing to somewhere in the buffer
			 * currently, so set it to the start 
d2624 1
a2624 1
			ERR_R_ECDH_LIB);
d2627 2
a2628 1
		i = ECDH_compute_key(p, (field_size + 7)/8, clnt_ecpoint, srvr_ecdh, NULL);
d2631 1
a2631 1
			ERR_R_ECDH_LIB);
d2664 1
a2664 1
			SSL_R_LENGTH_MISMATCH);
d2669 1
a2669 1
			SSL_R_DATA_LENGTH_TOO_LONG);
d2674 1
a2674 1
			SSL_R_PSK_NO_SERVER_CB);
d2678 4
a2681 2
		/* Create guaranteed NULL-terminated identity
		 * string for the callback */
d2685 1
a2685 1
		psk_or_pre_ms, sizeof(psk_or_pre_ms));
d2690 1
a2690 1
			ERR_R_INTERNAL_ERROR);
d2695 1
a2695 1
			SSL_R_PSK_IDENTITY_NOT_FOUND);
d2714 1
a2714 1
			ERR_R_MALLOC_FAILURE);
d2724 1
a2724 1
			ERR_R_MALLOC_FAILURE);
d2746 2
a2747 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_BAD_SRP_A_LENGTH);
d2751 2
a2752 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_BN_LIB);
d2760 1
a2760 1
			ERR_R_MALLOC_FAILURE);
d2764 5
a2768 2
		if ((s->session->master_key_length = SRP_generate_server_master_secret(s, s->session->master_key)) < 0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d2792 7
a2798 4
			/* If client certificate is present and is of the same type, maybe
			 * use it for key exchange.  Don't mind errors from
			 * EVP_PKEY_derive_set_peer, because it is completely valid to use
			 * a client certificate for authorization only. */
d2801 2
a2802 1
			if (EVP_PKEY_derive_set_peer(pkey_ctx, client_pub_pkey) <= 0)
d2807 2
a2808 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_DECRYPTION_FAILED);
d2818 2
a2819 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_DECRYPTION_FAILED);
d2822 4
a2825 4
		if (EVP_PKEY_decrypt(pkey_ctx, premaster_secret, &outlen, start, inlen) <=0)

		{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_DECRYPTION_FAILED);
d2831 1
a2831 1
		        s, s->session->master_key, premaster_secret, 32);
d2833 2
a2834 1
		if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0)
d2900 2
a2901 1
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_MISSING_VERIFY_MESSAGE);
d2909 2
a2910 1
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_NO_CLIENT_CERT_RECEIVED);
d2916 2
a2917 1
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
d2923 2
a2924 1
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_CCS_RECEIVED_EARLY);
d2931 6
a2936 3
	/* Check for broken implementations of GOST ciphersuites */
	/* If key is GOST and n is exactly 64, it is bare
	 * signature without length field */
d2945 2
a2946 1
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
d2952 2
a2953 1
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_WRONG_SIGNATURE_TYPE);
d2959 2
a2960 1
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_UNKNOWN_DIGEST);
d2965 2
a2966 1
			fprintf(stderr, "USING TLSv1.2 HASH %s\n", EVP_MD_name(md));
d2974 2
a2975 1
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_LENGTH_MISMATCH);
d2992 2
a2993 1
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
d2999 1
a2999 1
		EVP_MD_name(md));
d3017 2
a3018 2
		MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH, p, i,
		pkey->pkey.rsa);
d3021 2
a3022 1
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_RSA_DECRYPT);
d3027 2
a3028 1
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_RSA_SIGNATURE);
d3036 2
a3037 2
		&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
		SHA_DIGEST_LENGTH, p, i, pkey->pkey.dsa);
d3041 2
a3042 1
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_DSA_SIGNATURE);
d3056 1
a3056 1
			SSL_R_BAD_ECDSA_SIGNATURE);
d3061 2
a3062 1
	if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) {
d3073 2
a3074 1
		j = EVP_PKEY_verify(pctx, signature, 64, s->s3->tmp.cert_verify_md, 32);
d3079 1
a3079 1
			SSL_R_BAD_ECDSA_SIGNATURE);
d3115 2
a3116 6
	n = s->method->ssl_get_message(s,
	SSL3_ST_SR_CERT_A,
	SSL3_ST_SR_CERT_B,
	-1,
	s->max_cert_list,
	&ok);
d3123 3
a3125 2
			(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
d3129 4
a3132 1
		/* If tls asked for a client cert, the client must return a 0 list */
d3134 3
a3136 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST);
d3146 2
a3147 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_WRONG_MESSAGE_TYPE);
d3153 2
a3154 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);
d3161 2
a3162 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_LENGTH_MISMATCH);
d3169 2
a3170 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_CERT_LENGTH_MISMATCH);
d3177 2
a3178 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_ASN1_LIB);
d3183 2
a3184 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_CERT_LENGTH_MISMATCH);
d3188 2
a3189 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);
d3200 2
a3201 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_NO_CERTIFICATES_RETURNED);
d3207 2
a3208 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
d3221 2
a3222 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_NO_CERTIFICATE_RETURNED);
d3237 2
a3238 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);
d3273 6
a3278 3
			if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
				(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
				SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
d3312 2
a3313 1
		/* Some length values are 16 bits, so forget it if session is
d3324 4
a3327 1
		/* create a fresh copy (not shared with other threads) to clean up */
d3334 3
a3336 1
		sess->session_id_length = 0; /* ID is irrelevant for the ticket */
d3339 2
a3340 2
		if (slen > slen_full) /* shouldn't ever happen */
		{
d3348 2
a3349 1
		/* Grow buffer if need be: the length calculation is as
d3357 3
a3359 3
			26 + EVP_MAX_IV_LENGTH + EVP_MAX_BLOCK_LENGTH +
		EVP_MAX_MD_SIZE + slen))
		return -1;
d3368 2
a3369 1
		/* Initialize HMAC and cipher contexts. If callback present
d3388 6
a3393 4
		/* Ticket lifetime hint (advisory only):
		 * We leave this unspecified for resumed session (for simplicity),
		 * and guess that tickets for new sessions will live as long
		 * as their sessions. */
d3442 2
a3443 1
		/* Grow buffer if need be: the length calculation is as
d3474 4
a3477 2
/* ssl3_get_next_proto reads a Next Protocol Negotiation handshake message. It
 * sets the next_proto member in s if found */
d3486 4
a3489 2
	/* Clients cannot send a NextProtocol message if we didn't see the
	 * extension in their ClientHello */
d3491 2
a3492 1
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO, SSL_R_GOT_NEXT_PROTO_WITHOUT_EXTENSION);
d3502 2
a3503 1
	/* s->state doesn't reflect whether ChangeCipherSpec has been received
d3505 2
a3506 1
	 * by ssl3_get_finished). */
d3508 2
a3509 1
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO, SSL_R_GOT_NEXT_PROTO_BEFORE_A_CCS);
d3519 2
a3520 1
	/* The payload looks like:
@


1.33
log
@So the OpenSSL codebase does "get the time, add it as a random seed"
in a bunch of places inside the TLS engine, to try to keep entropy high.
I wonder if their moto is "If you can't solve a problem, at least try
to do it badly".
ok miod
@
text
@a235 11
#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending) {
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
	}
#endif

@


1.32
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d213 1
a213 1
	unsigned long alg_k, Time = (unsigned long)time(NULL);
a217 1
	RAND_add(&Time, sizeof(Time), 0);
@


1.31
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@d174 3
a176 2
static const SSL_METHOD *ssl3_get_server_method(int ver)
	{
d178 1
a178 1
		return(SSLv3_server_method());
d180 2
a181 2
		return(NULL);
	}
d184 3
a186 2
static int ssl_check_srp_ext_ClientHello(SSL *s, int *al)
	{
d192 2
a193 4
	    (s->srp_ctx.TLS_ext_srp_username_callback != NULL))
		{
		if(s->srp_ctx.login == NULL)
			{
d198 2
a199 5
			}
		else
			{
			ret = SSL_srp_server_param_with_username(s,al);
			}
d201 1
d203 1
a203 1
	}
d207 1
a207 3
			ssl3_accept,
			ssl_undefined_function,
			ssl3_get_server_method)
d209 3
a211 2
int ssl3_accept(SSL *s)
	{
d213 4
a216 4
	unsigned long alg_k,Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;
d218 1
a218 1
	RAND_add(&Time,sizeof(Time),0);
d223 1
a223 1
		cb=s->info_callback;
d225 1
a225 1
		cb=s->ctx->info_callback;
d229 2
a230 1
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);
d232 4
a235 5
	if (s->cert == NULL)
		{
		SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}
d242 1
a242 2
	if (s->tlsext_hb_pending)
		{
d245 1
a245 1
		}
d248 2
a249 3
	for (;;)
		{
		state=s->state;
d251 1
a251 2
		switch (s->state)
			{
d253 1
a253 1
			s->renegotiate=1;
d261 3
a263 2
			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
d265 1
a265 2
			if ((s->version>>8) != 3)
				{
d268 2
a269 2
				}
			s->type=SSL_ST_ACCEPT;
d271 3
a273 5
			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
d275 3
a277 4
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
a278 2
					}
				s->init_buf=buf;
d280 2
d283 2
a284 3
			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
d286 1
a286 1
				}
d288 1
a288 1
			s->init_num=0;
d291 1
a291 2
			if (s->state != SSL_ST_RENEGOTIATE)
				{
d295 5
a299 2
				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
				
d301 1
a301 1
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
d303 2
a304 4
				}
			else if (!s->s3->send_connection_binding &&
				!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
				{
d310 1
a310 1
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
d313 1
a313 3
				}
			else
				{
d317 2
a318 2
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}
d324 7
a330 6
			s->shutdown=0;
			ret=ssl3_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
d336 1
a336 1
			s->state=SSL_ST_OK;
d343 5
a347 5
			s->shutdown=0;
			if (s->rwstate != SSL_X509_LOOKUP)
			{
				ret=ssl3_get_client_hello(s);
				if (ret <= 0) goto end;
d351 2
a352 3
			int al;
			if ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)
					{
d354 1
a354 1
					s->rwstate=SSL_X509_LOOKUP;
d356 4
a359 4
					}
			if (ret != SSL_ERROR_NONE)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,al);	
d362 8
a369 5
 				   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) 	
					SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);			
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;			
				ret= -1;
				goto end;	
d373 1
a373 1
			
d375 2
a376 2
			s->state=SSL3_ST_SW_SRVR_HELLO_A;
			s->init_num=0;
d381 3
a383 2
			ret=ssl3_send_server_hello(s);
			if (ret <= 0) goto end;
d385 1
a385 2
			if (s->hit)
				{
d387 1
a387 1
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
d389 2
a390 2
					s->state=SSL3_ST_SW_CHANGE_A;
				}
d393 1
a393 1
					s->state=SSL3_ST_SW_CHANGE_A;
d396 2
a397 2
				s->state=SSL3_ST_SW_CERT_A;
			s->init_num=0;
d406 4
a409 4
				&& !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
				{
				ret=ssl3_send_server_certificate(s);
				if (ret <= 0) goto end;
d412 1
a412 1
					s->state=SSL3_ST_SW_CERT_STATUS_A;
d414 2
a415 4
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
d417 2
a418 2
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
d420 2
a421 3
				}
			else
				skip=1;
d423 1
a423 1
			s->state=SSL3_ST_SW_KEY_EXCH_A;
d425 1
a425 1
			s->init_num=0;
d436 1
a436 1
				&& !(alg_k & SSL_kKRB5)
d438 1
a438 1
				)
d443 1
a443 1
				s->s3->tmp.use_rsa_tmp=1;
d445 1
a445 1
				s->s3->tmp.use_rsa_tmp=0;
d466 1
a466 1
			    /* SRP: send ServerKeyExchange */
d472 5
a476 6
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
d478 6
a483 6
				{
				ret=ssl3_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;
d485 2
a486 2
			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
d492 1
a492 1
				!(s->verify_mode & SSL_VERIFY_PEER) ||
d495 2
a496 2
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
d500 1
a500 1
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
d503 3
a505 3
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
d508 1
a508 2
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
d510 3
a512 3
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
d516 5
a520 6
				}
			else
				{
				s->s3->tmp.cert_request=1;
				ret=ssl3_send_certificate_request(s);
				if (ret <= 0) goto end;
d522 1
a522 1
				s->state=SSL3_ST_SW_SRVR_DONE_A;
d524 2
a525 2
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
d527 2
a528 2
				s->init_num=0;
				}
d533 6
a538 5
			ret=ssl3_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
d540 1
a540 1
		
d553 3
a555 4
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
d557 2
a558 2
				}
			s->rwstate=SSL_NOTHING;
d560 1
a560 1
			s->state=s->s3->tmp.next_state;
d572 7
a578 7
				if (s->s3->tmp.cert_request)
					{
					ret=ssl3_get_client_certificate(s);
					if (ret <= 0) goto end;
					}
				s->init_num=0;
				s->state=SSL3_ST_SR_KEY_EXCH_A;
d584 1
a584 1
			ret=ssl3_get_client_key_exchange(s);
d587 1
a587 2
			if (ret == 2)
				{
d597 1
a597 1
				s->state=SSL3_ST_SR_FINISHED_A;
d600 1
a600 1
					s->state=SSL3_ST_SR_NEXT_PROTO_A;
d602 1
a602 1
					s->state=SSL3_ST_SR_FINISHED_A;
d605 3
a607 5
				}
			else if (TLS1_get_version(s) >= TLS1_2_VERSION)
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
d613 2
a614 3
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);
d616 1
a616 1
					}
d620 2
a621 4
				}
			else
				{
				int offset=0;
d624 2
a625 2
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
d635 11
a645 14
				for (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)	
					if (s->s3->handshake_dgst[dgst_num]) 
						{
						int dgst_size;

						s->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));
						dgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);
						if (dgst_size < 0)
							{
							ret = -1;
							goto end;
							}
						offset+=dgst_size;
						}		
d647 1
d654 3
a656 2
			ret=ssl3_get_cert_verify(s);
			if (ret <= 0) goto end;
d659 1
a659 1
			s->state=SSL3_ST_SR_FINISHED_A;
d662 1
a662 1
				s->state=SSL3_ST_SR_NEXT_PROTO_A;
d664 1
a664 1
				s->state=SSL3_ST_SR_FINISHED_A;
d666 1
a666 1
			s->init_num=0;
d672 3
a674 2
			ret=ssl3_get_next_proto(s);
			if (ret <= 0) goto end;
d676 1
a676 1
			s->state=SSL3_ST_SR_FINISHED_A;
d682 4
a685 3
			ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
				SSL3_ST_SR_FINISHED_B);
			if (ret <= 0) goto end;
d687 1
a687 1
				s->state=SSL_ST_OK;
d690 1
a690 1
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
d693 2
a694 2
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
d700 5
a704 4
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
d709 5
a713 4
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
d721 17
a737 15
			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }

			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);

			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
d739 1
a739 1
				}
d745 8
a752 8
			ret=ssl3_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
d754 1
a754 1
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
d757 1
a757 1
					s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;
d759 1
a759 1
					s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
d761 3
a763 4
				}
			else
				s->s3->tmp.next_state=SSL_ST_OK;
			s->init_num=0;
d771 1
a771 1
			s->init_buf=NULL;
d776 1
a776 1
			s->init_num=0;
d779 6
a784 6
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
d787 5
a791 1
				s->handshake_func=ssl3_accept;
a792 3
				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
d798 2
a799 2
			SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
d802 6
a808 8
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}
d811 5
a815 7
			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
a816 1
		skip=0;
d818 2
d825 3
a827 3
		cb(s,SSL_CB_ACCEPT_EXIT,ret);
	return(ret);
	}
d829 3
a831 2
int ssl3_send_hello_request(SSL *s)
	{
d834 6
a839 7
	if (s->state == SSL3_ST_SW_HELLO_REQ_A)
		{
		p=(unsigned char *)s->init_buf->data;
		*(p++)=SSL3_MT_HELLO_REQUEST;
		*(p++)=0;
		*(p++)=0;
		*(p++)=0;
d841 1
a841 1
		s->state=SSL3_ST_SW_HELLO_REQ_B;
d843 3
a845 3
		s->init_num=4;
		s->init_off=0;
		}
d848 2
a849 2
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
	}
d851 3
a853 2
int ssl3_check_client_hello(SSL *s)
	{
d859 8
a866 7
	n=s->method->ssl_get_message(s,
		SSL3_ST_SR_CERT_A,
		SSL3_ST_SR_CERT_B,
		-1,
		s->max_cert_list,
		&ok);
	if (!ok) return((int)n);
d868 1
a868 2
	if (s->s3->tmp.message_type == SSL3_MT_CLIENT_HELLO)
		{
d871 1
a871 2
		if (s->s3->flags & SSL3_FLAGS_SGC_RESTART_DONE)
			{
d874 1
a874 1
			}
d878 1
a878 2
		if (s->s3->tmp.dh != NULL)
			{
d881 1
a881 1
			}
d884 1
a884 2
		if (s->s3->tmp.ecdh != NULL)
			{
d887 1
a887 1
			}
d891 1
a891 1
		}
d895 4
a898 3
int ssl3_get_client_hello(SSL *s)
	{
	int i,j,ok,al,ret= -1;
d902 1
a902 1
	unsigned char *p,*d,*q;
d905 1
a905 1
	SSL_COMP *comp=NULL;
d907 1
a907 1
	STACK_OF(SSL_CIPHER) *ciphers=NULL;
d915 15
a929 16
	if (s->state == SSL3_ST_SR_CLNT_HELLO_A
		)
		{
		s->state=SSL3_ST_SR_CLNT_HELLO_B;
		}
	s->first_packet=1;
	n=s->method->ssl_get_message(s,
		SSL3_ST_SR_CLNT_HELLO_B,
		SSL3_ST_SR_CLNT_HELLO_C,
		SSL3_MT_CLIENT_HELLO,
		SSL3_RT_MAX_PLAIN_LENGTH,
		&ok);

	if (!ok) return((int)n);
	s->first_packet=0;
	d=p=(unsigned char *)s->init_msg;
d933 2
a934 2
	s->client_version=(((int)p[0])<<8)|(int)p[1];
	p+=2;
d937 1
a937 2
	    (s->version != DTLS1_VERSION && s->client_version < s->version))
		{
d939 2
a940 3
		if ((s->client_version>>8) == SSL3_VERSION_MAJOR && 
			!s->enc_write_ctx && !s->write_hash)
			{
d943 1
a943 1
			}
d946 1
a946 1
		}
d952 1
a952 2
	if (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE)
		{
d954 1
a954 1
		
d960 1
a960 1
		}
d963 2
a964 2
	memcpy(s->s3->client_random,p,SSL3_RANDOM_SIZE);
	p+=SSL3_RANDOM_SIZE;
d969 1
a969 1
	s->hit=0;
d981 2
a982 3
	if ((s->new_session && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION)))
		{
		if (!ssl_get_new_session(s,1))
d984 2
a985 4
		}
	else
		{
		i=ssl_get_prev_session(s, p, j, d + n);
d987 3
a989 4
			{ /* previous session */
			s->hit=1;
			}
		else if (i == -1)
d992 2
a993 2
			{
			if (!ssl_get_new_session(s,1))
a994 1
			}
d996 1
d998 1
a998 1
	p+=j;
d1000 1
a1000 2
	if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)
		{
d1009 1
a1009 2
		if ( cookie_len > sizeof(s->d1->rcvd_cookie))
			{
d1014 1
a1014 1
			}
d1018 1
a1018 2
			cookie_len > 0)
			{
d1021 6
a1026 8
			if ( s->ctx->app_verify_cookie_cb != NULL)
				{
				if ( s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,
					cookie_len) == 0)
					{
					al=SSL_AD_HANDSHAKE_FAILURE;
					SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, 
						SSL_R_COOKIE_MISMATCH);
d1028 1
a1028 1
					}
d1030 8
a1037 9
				}
			else if ( memcmp(s->d1->rcvd_cookie, s->d1->cookie, 
						  s->d1->cookie_len) != 0) /* default verification */
				{
					al=SSL_AD_HANDSHAKE_FAILURE;
					SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, 
						SSL_R_COOKIE_MISMATCH);
					goto f_err;
				}
d1040 1
a1040 1
			}
d1043 1
a1043 1
		}
d1045 2
a1046 3
	n2s(p,i);
	if ((i == 0) && (j != 0))
		{
d1048 2
a1049 2
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_SPECIFIED);
d1051 2
a1052 3
		}
	if ((p+i) >= (d+n))
		{
d1054 2
a1055 2
		al=SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);
d1057 3
a1059 4
		}
	if ((i > 0) && (ssl_bytes_to_cipher_list(s,p,i,&(ciphers))
		== NULL))
		{
d1061 2
a1062 2
		}
	p+=i;
d1065 3
a1067 4
	if ((s->hit) && (i > 0))
		{
		j=0;
		id=s->session->cipher->id;
d1070 1
a1070 1
		printf("client sent %d ciphers\n",sk_num(ciphers));
d1072 2
a1073 3
		for (i=0; i<sk_SSL_CIPHER_num(ciphers); i++)
			{
			c=sk_SSL_CIPHER_value(ciphers,i);
d1076 1
a1076 1
				i,sk_num(ciphers),SSL_CIPHER_get_name(c));
d1078 2
a1079 3
			if (c->id == id)
				{
				j=1;
a1080 1
				}
d1082 1
d1087 1
a1087 2
		if (j == 0 && (s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_SSL_CIPHER_num(ciphers) == 1))
			{
d1094 1
a1094 2
			if (sk_SSL_CIPHER_find(SSL_get_ciphers(s), c) >= 0)
				{
a1096 1
				}
d1098 1
d1100 1
a1100 2
		if (j == 0)
			{
d1103 2
a1104 2
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_REQUIRED_CIPHER_MISSING);
a1105 1
			}
d1107 1
d1111 1
a1111 2
	if ((p+i) > (d+n))
		{
d1113 2
a1114 2
		al=SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);
d1116 6
a1121 6
		}
	q=p;
	for (j=0; j<i; j++)
		{
		if (p[j] == 0) break;
		}
d1123 2
a1124 3
	p+=i;
	if (j >= i)
		{
d1126 2
a1127 2
		al=SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_COMPRESSION_SPECIFIED);
d1129 1
a1129 1
		}
d1133 2
a1134 4
	if (s->version >= SSL3_VERSION)
		{
		if (!ssl_parse_clienthello_tlsext(s,&p,d,n, &al))
			{
d1136 1
a1136 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_PARSE_TLSEXT);
a1137 5
			}
		}
		if (ssl_check_clienthello_tlsext_early(s) <= 0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_CLIENTHELLO_TLSEXT);
			goto err;
d1139 5
d1151 3
a1153 4
		pos=s->s3->server_random;
		if (ssl_fill_hello_random(s, 1, pos, SSL3_RANDOM_SIZE) <= 0)
			{
			al=SSL_AD_INTERNAL_ERROR;
d1155 1
a1155 1
			}
d1158 2
a1159 3
	if (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb)
		{
		SSL_CIPHER *pref_cipher=NULL;
d1161 6
a1166 7
		s->session->master_key_length=sizeof(s->session->master_key);
		if(s->tls_session_secret_cb(s, s->session->master_key, &s->session->master_key_length,
			ciphers, &pref_cipher, s->tls_session_secret_cb_arg))
			{
			s->hit=1;
			s->session->ciphers=ciphers;
			s->session->verify_result=X509_V_OK;
d1168 1
a1168 1
			ciphers=NULL;
d1171 4
a1174 5
			pref_cipher=pref_cipher ? pref_cipher : ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));
			if (pref_cipher == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_SHARED_CIPHER);
d1176 1
a1176 1
				}
d1178 1
a1178 1
			s->session->cipher=pref_cipher;
a1187 1
			}
d1189 1
d1195 1
a1195 1
	s->s3->tmp.new_compression=NULL;
d1198 1
a1198 2
	if (s->session->compress_meth != 0)
		{
d1202 3
a1204 4
		if (s->options & SSL_OP_NO_COMPRESSION)
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_INCONSISTENT_COMPRESSION);
d1206 1
a1206 1
			}
d1208 4
a1211 6
		for (m = 0; m < sk_SSL_COMP_num(s->ctx->comp_methods); m++)
			{
			comp=sk_SSL_COMP_value(s->ctx->comp_methods,m);
			if (comp_id == comp->id)
				{
				s->s3->tmp.new_compression=comp;
a1212 1
				}
d1214 4
a1217 4
		if (s->s3->tmp.new_compression == NULL)
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_INVALID_COMPRESSION_ALGORITHM);
d1219 1
a1219 1
			}
d1221 1
a1221 2
		for (m = 0; m < i; m++)
			{
d1224 4
a1227 5
			}
		if (m >= i)
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING);
a1228 1
			}
d1230 1
a1230 1
	else if (s->hit)
d1233 2
a1234 2
		{ /* See if we have a match */
		int m,nn,o,v,done=0;
d1236 7
a1242 10
		nn=sk_SSL_COMP_num(s->ctx->comp_methods);
		for (m=0; m<nn; m++)
			{
			comp=sk_SSL_COMP_value(s->ctx->comp_methods,m);
			v=comp->id;
			for (o=0; o<i; o++)
				{
				if (v == q[o])
					{
					done=1;
a1243 1
					}
a1244 1
			if (done) break;
d1246 3
d1250 1
a1250 1
			s->s3->tmp.new_compression=comp;
d1252 2
a1253 2
			comp=NULL;
		}
d1258 3
a1260 4
	if (s->session->compress_meth != 0)
		{
		al=SSL_AD_INTERNAL_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_INCONSISTENT_COMPRESSION);
d1262 1
a1262 1
		}
d1268 1
a1268 2
	if (!s->hit)
		{
d1270 1
a1270 1
		s->session->compress_meth=0;
d1272 1
a1272 1
		s->session->compress_meth=(comp == NULL)?0:comp->id;
d1276 4
a1279 5
		s->session->ciphers=ciphers;
		if (ciphers == NULL)
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_PASSED);
d1281 4
a1284 4
			}
		ciphers=NULL;
		c=ssl3_choose_cipher(s,s->session->ciphers,
				     SSL_get_ciphers(s));
d1286 3
a1288 4
		if (c == NULL)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_SHARED_CIPHER);
a1289 2
			}
		s->s3->tmp.new_cipher=c;
d1291 2
a1292 2
	else
		{
d1296 2
a1297 2
		SSL_CIPHER *nc=NULL;
		SSL_CIPHER *ec=NULL;
d1299 4
a1302 6
		if (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG)
			{
			sk=s->session->ciphers;
			for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
				{
				c=sk_SSL_CIPHER_value(sk,i);
d1304 1
a1304 1
					nc=c;
d1306 2
a1307 2
					ec=c;
				}
d1309 1
a1309 1
				s->s3->tmp.new_cipher=nc;
d1311 1
a1311 1
				s->s3->tmp.new_cipher=ec;
d1313 2
a1314 3
				s->s3->tmp.new_cipher=s->session->cipher;
			}
		else
d1316 2
a1317 2
		s->s3->tmp.new_cipher=s->session->cipher;
		}
d1319 2
a1320 4
	if (TLS1_get_version(s) < TLS1_2_VERSION || !(s->verify_mode & SSL_VERIFY_PEER))
		{
		if (!ssl3_digest_cached_records(s))
			{
a1322 1
			}
d1324 2
a1325 1
	
d1338 2
a1339 4
	if (s->version >= SSL3_VERSION)
		{
		if (ssl_check_clienthello_tlsext_late(s) <= 0)
			{
a1341 1
			}
d1343 1
d1345 3
a1347 3
	if (ret < 0) ret=1;
	if (0)
		{
d1349 2
a1350 2
		ssl3_send_alert(s,SSL3_AL_FATAL,al);
		}
d1352 4
a1355 3
	if (ciphers != NULL) sk_SSL_CIPHER_free(ciphers);
	return(ret);
	}
d1357 3
a1359 2
int ssl3_send_server_hello(SSL *s)
	{
d1361 2
a1362 2
	unsigned char *p,*d;
	int i,sl;
d1365 2
a1366 3
	if (s->state == SSL3_ST_SW_SRVR_HELLO_A)
		{
		buf=(unsigned char *)s->init_buf->data;
d1368 1
a1368 1
		p=s->s3->server_random;
d1373 1
a1373 1
		d=p= &(buf[4]);
d1375 2
a1376 2
		*(p++)=s->version>>8;
		*(p++)=s->version&0xff;
d1379 2
a1380 2
		memcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);
		p+=SSL3_RANDOM_SIZE;
d1399 1
a1399 1
			s->session->session_id_length=0;
d1401 2
a1402 3
		sl=s->session->session_id_length;
		if (sl > (int)sizeof(s->session->session_id))
			{
d1405 4
a1408 4
			}
		*(p++)=sl;
		memcpy(p,s->session->session_id,sl);
		p+=sl;
d1411 2
a1412 2
		i=ssl3_put_cipher_by_char(s->s3->tmp.new_cipher,p);
		p+=i;
d1416 1
a1416 1
			*(p++)=0;
d1419 1
a1419 1
			*(p++)=0;
d1421 1
a1421 1
			*(p++)=s->s3->tmp.new_compression->id;
d1424 2
a1425 3
		if (ssl_prepare_serverhello_tlsext(s) <= 0)
			{
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);
d1427 3
a1429 4
			}
		if ((p = ssl_add_serverhello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
			{
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO,ERR_R_INTERNAL_ERROR);
d1431 1
a1431 1
			}
d1434 4
a1437 4
		l=(p-d);
		d=buf;
		*(d++)=SSL3_MT_SERVER_HELLO;
		l2n3(l,d);
d1439 1
a1439 1
		s->state=SSL3_ST_SW_SRVR_HELLO_B;
d1441 3
a1443 3
		s->init_num=p-buf;
		s->init_off=0;
		}
d1446 2
a1447 2
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
	}
d1449 3
a1451 2
int ssl3_send_server_done(SSL *s)
	{
d1454 2
a1455 3
	if (s->state == SSL3_ST_SW_SRVR_DONE_A)
		{
		p=(unsigned char *)s->init_buf->data;
d1458 4
a1461 4
		*(p++)=SSL3_MT_SERVER_DONE;
		*(p++)=0;
		*(p++)=0;
		*(p++)=0;
d1463 1
a1463 1
		s->state=SSL3_ST_SW_SRVR_DONE_B;
d1465 3
a1467 3
		s->init_num=4;
		s->init_off=0;
		}
d1470 2
a1471 2
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
	}
d1473 3
a1475 2
int ssl3_send_server_key_exchange(SSL *s)
	{
d1478 1
a1478 1
	int j,num;
d1480 1
a1480 1
	unsigned char md_buf[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];
d1484 1
a1484 1
	DH *dh=NULL,*dhp;
d1487 1
a1487 1
	EC_KEY *ecdh=NULL, *ecdhp;
d1491 2
a1492 1
	BN_CTX *bn_ctx = NULL; 
d1496 2
a1497 2
	unsigned char *p,*d;
	int al,i;
d1502 1
a1502 1
	int nr[4],kn;
d1507 3
a1509 4
	if (s->state == SSL3_ST_SW_KEY_EXCH_A)
		{
		type=s->s3->tmp.new_cipher->algorithm_mkey;
		cert=s->cert;
d1511 1
a1511 1
		buf=s->init_buf;
d1513 2
a1514 2
		r[0]=r[1]=r[2]=r[3]=NULL;
		n=0;
d1516 9
a1524 12
		if (type & SSL_kRSA)
			{
			rsa=cert->rsa_tmp;
			if ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL))
				{
				rsa=s->cert->rsa_tmp_cb(s,
				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
				if(rsa == NULL)
				{
					al=SSL_AD_HANDSHAKE_FAILURE;
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_ERROR_GENERATING_TMP_RSA_KEY);
d1528 5
a1532 6
				cert->rsa_tmp=rsa;
				}
			if (rsa == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_KEY);
a1533 4
				}
			r[0]=rsa->n;
			r[1]=rsa->e;
			s->s3->tmp.use_rsa_tmp=1;
d1535 4
a1538 1
		else
d1541 2
a1542 3
			if (type & SSL_kEDH)
			{
			dhp=cert->dh_tmp;
d1544 6
a1549 7
				dhp=s->cert->dh_tmp_cb(s,
				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
			if (dhp == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_DH_KEY);
d1551 1
a1551 1
				}
d1553 1
a1553 2
			if (s->s3->tmp.dh != NULL)
				{
d1556 1
a1556 1
				}
d1558 2
a1559 3
			if ((dh=DHparams_dup(dhp)) == NULL)
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);
d1561 1
a1561 1
				}
d1563 7
a1569 11
			s->s3->tmp.dh=dh;
			if ((dhp->pub_key == NULL ||
			     dhp->priv_key == NULL ||
			     (s->options & SSL_OP_SINGLE_DH_USE)))
				{
				if(!DH_generate_key(dh))
				    {
				    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
					   ERR_R_DH_LIB);
				    goto err;
				    }
d1571 3
a1573 4
			else
				{
				dh->pub_key=BN_dup(dhp->pub_key);
				dh->priv_key=BN_dup(dhp->priv_key);
d1575 2
a1576 3
					(dh->priv_key == NULL))
					{
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);
a1577 1
					}
a1578 3
			r[0]=dh->p;
			r[1]=dh->g;
			r[2]=dh->pub_key;
d1580 4
a1583 1
		else 
d1586 1
a1586 2
			if (type & SSL_kEECDH)
			{
d1589 9
a1597 11
			ecdhp=cert->ecdh_tmp;
			if ((ecdhp == NULL) && (s->cert->ecdh_tmp_cb != NULL))
				{
				ecdhp=s->cert->ecdh_tmp_cb(s,
				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
				}
			if (ecdhp == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);
d1599 1
a1599 1
				}
d1601 1
a1601 2
			if (s->s3->tmp.ecdh != NULL)
				{
d1604 1
a1604 1
				}
d1607 2
a1608 3
			if (ecdhp == NULL)
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
d1610 3
a1612 4
				}
			if ((ecdh = EC_KEY_dup(ecdhp)) == NULL)
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
d1614 1
a1614 1
				}
d1616 1
a1616 1
			s->s3->tmp.ecdh=ecdh;
d1619 4
a1622 7
			    (s->options & SSL_OP_SINGLE_ECDH_USE))
				{
				if(!EC_KEY_generate_key(ecdh))
				    {
				    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				    goto err;
				    }
d1624 1
d1628 2
a1629 3
			    (EC_KEY_get0_private_key(ecdh) == NULL))
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
d1631 1
a1631 1
				}
d1634 2
a1635 3
			    (EC_GROUP_get_degree(group) > 163)) 
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
d1637 1
a1637 1
				}
d1643 3
a1645 5
			if ((curve_id = 
			    tls1_ec_nid2curve_id(EC_GROUP_get_curve_name(group)))
			    == 0)
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);
d1647 1
a1647 1
				}
d1653 7
a1659 4
			encodedlen = EC_POINT_point2oct(group, 
			    EC_KEY_get0_public_key(ecdh),
			    POINT_CONVERSION_UNCOMPRESSED, 
			    NULL, 0, NULL);
a1660 2
			encodedPoint = (unsigned char *) 
			    OPENSSL_malloc(encodedlen*sizeof(unsigned char)); 
d1662 2
a1663 3
			if ((encodedPoint == NULL) || (bn_ctx == NULL))
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d1665 2
a1666 1
				}
d1668 4
d1673 2
a1674 8
			encodedlen = EC_POINT_point2oct(group, 
			    EC_KEY_get0_public_key(ecdh), 
			    POINT_CONVERSION_UNCOMPRESSED, 
			    encodedPoint, encodedlen, bn_ctx);

			if (encodedlen == 0) 
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
d1676 1
a1676 1
				}
d1678 2
a1679 1
			BN_CTX_free(bn_ctx);  bn_ctx=NULL;
d1692 5
a1696 6
			r[0]=NULL;
			r[1]=NULL;
			r[2]=NULL;
			r[3]=NULL;
			}
		else 
d1699 4
a1702 6
			if (type & SSL_kPSK)
				{
				/* reserve size for record length and PSK identity hint*/
				n+=2+strlen(s->ctx->psk_identity_hint);
				}
			else
d1705 4
a1708 8
		if (type & SSL_kSRP)
			{
			if ((s->srp_ctx.N == NULL) ||
				(s->srp_ctx.g == NULL) ||
				(s->srp_ctx.s == NULL) ||
				(s->srp_ctx.B == NULL))
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_SRP_PARAM);
a1709 5
				}
			r[0]=s->srp_ctx.N;
			r[1]=s->srp_ctx.g;
			r[2]=s->srp_ctx.s;
			r[3]=s->srp_ctx.B;
d1711 5
a1715 1
		else 
d1717 3
a1719 3
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
d1721 3
a1723 4
			}
		for (i=0; i < 4 && r[i] != NULL; i++)
			{
			nr[i]=BN_num_bytes(r[i]);
d1726 1
a1726 1
				n+=1+nr[i];
d1729 2
a1730 2
			n+=2+nr[i];
			}
d1732 5
a1736 7
		if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
			&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
			{
			if ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher,&md))
				== NULL)
				{
				al=SSL_AD_DECODE_ERROR;
a1737 7
				}
			kn=EVP_PKEY_size(pkey);
			}
		else
			{
			pkey=NULL;
			kn=0;
d1739 5
d1745 2
a1746 3
		if (!BUF_MEM_grow_clean(buf,n+4+kn))
			{
			SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_BUF);
d1748 3
a1750 3
			}
		d=(unsigned char *)s->init_buf->data;
		p= &(d[4]);
d1752 1
a1752 2
		for (i=0; i < 4 && r[i] != NULL; i++)
			{
d1754 1
a1754 2
			if ((i == 2) && (type & SSL_kSRP))
				{
d1757 1
a1757 2
				}
			else
d1759 4
a1762 4
			s2n(nr[i],p);
			BN_bn2bin(r[i],p);
			p+=nr[i];
			}
d1765 1
a1765 2
		if (type & SSL_kEECDH) 
			{
d1780 2
a1781 3
			memcpy((unsigned char*)p, 
			    (unsigned char *)encodedPoint, 
			    encodedlen);
d1785 1
a1785 1
			}
d1789 1
a1789 2
		if (type & SSL_kPSK)
			{
d1791 2
a1792 1
			s2n(strlen(s->ctx->psk_identity_hint), p); 
d1794 2
a1795 2
			p+=strlen(s->ctx->psk_identity_hint);
			}
d1799 1
a1799 2
		if (pkey != NULL)
			{
d1804 4
a1807 6
					&& TLS1_get_version(s) < TLS1_2_VERSION)
				{
				q=md_buf;
				j=0;
				for (num=2; num > 0; num--)
					{
d1809 10
a1818 11
						EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
					EVP_DigestInit_ex(&md_ctx,(num == 2)
						?s->ctx->md5:s->ctx->sha1, NULL);
					EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
					EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
					EVP_DigestUpdate(&md_ctx,&(d[4]),n);
					EVP_DigestFinal_ex(&md_ctx,q,
						(unsigned int *)&i);
					q+=i;
					j+=i;
					}
d1820 2
a1821 3
					&(p[2]), &u, pkey->pkey.rsa) <= 0)
					{
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_RSA);
a1822 3
					}
				s2n(u,p);
				n+=u+2;
d1824 3
a1826 1
			else
d1828 1
a1828 2
			if (md)
				{
d1831 2
a1832 4
				if (TLS1_get_version(s) >= TLS1_2_VERSION)
					{
					if (!tls12_get_sigandhash(p, pkey, md))
						{
d1834 2
a1835 2
						al=SSL_AD_INTERNAL_ERROR;
						SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
a1836 2
						}
					p+=2;
d1838 2
d1842 1
a1842 1
							EVP_MD_name(md));
d1845 6
a1850 7
				EVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(d[4]),n);
				if (!EVP_SignFinal(&md_ctx,&(p[2]),
					(unsigned int *)&i,pkey))
					{
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_EVP);
d1852 3
a1854 3
					}
				s2n(i,p);
				n+=i+2;
d1856 2
a1857 4
					n+= 2;
				}
			else
				{
d1859 2
a1860 2
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_PKEY_TYPE);
a1861 1
				}
d1863 1
d1865 2
a1866 2
		*(d++)=SSL3_MT_SERVER_KEY_EXCHANGE;
		l2n3(n,d);
d1870 3
a1872 3
		s->init_num=n+4;
		s->init_off=0;
		}
d1876 1
a1876 1
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
d1878 1
a1878 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d1881 2
a1882 1
	if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
d1886 2
a1887 2
	return(-1);
	}
d1889 6
a1894 5
int ssl3_send_certificate_request(SSL *s)
	{
	unsigned char *p,*d;
	int i,j,nl,off,n;
	STACK_OF(X509_NAME) *sk=NULL;
d1898 2
a1899 3
	if (s->state == SSL3_ST_SW_CERT_REQ_A)
		{
		buf=s->init_buf;
d1901 1
a1901 1
		d=p=(unsigned char *)&(buf->data[4]);
d1905 3
a1907 3
		n=ssl3_get_req_cert_type(s,p);
		d[0]=n;
		p+=n;
d1910 1
a1910 2
		if (TLS1_get_version(s) >= TLS1_2_VERSION)
			{
d1915 5
a1919 1
			}
d1921 8
a1928 15
		off=n;
		p+=2;
		n+=2;

		sk=SSL_get_client_CA_list(s);
		nl=0;
		if (sk != NULL)
			{
			for (i=0; i<sk_X509_NAME_num(sk); i++)
				{
				name=sk_X509_NAME_value(sk,i);
				j=i2d_X509_NAME(name,NULL);
				if (!BUF_MEM_grow_clean(buf,4+n+j+2))
					{
					SSLerr(SSL_F_SSL3_SEND_CERTIFICATE_REQUEST,ERR_R_BUF_LIB);
d1930 15
a1944 17
					}
				p=(unsigned char *)&(buf->data[4+n]);
				if (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG))
					{
					s2n(j,p);
					i2d_X509_NAME(name,&p);
					n+=2+j;
					nl+=2+j;
					}
				else
					{
					d=p;
					i2d_X509_NAME(name,&p);
					j-=2; s2n(j,d); j+=2;
					n+=j;
					nl+=j;
					}
d1947 1
d1949 2
a1950 2
		p=(unsigned char *)&(buf->data[4+off]);
		s2n(nl,p);
d1952 3
a1954 3
		d=(unsigned char *)buf->data;
		*(d++)=SSL3_MT_CERTIFICATE_REQUEST;
		l2n3(n,d);
d1959 2
a1960 2
		s->init_num=n+4;
		s->init_off=0;
d1962 1
a1962 1
		p=(unsigned char *)s->init_buf->data + s->init_num;
d1965 4
a1968 4
		*(p++)=SSL3_MT_SERVER_DONE;
		*(p++)=0;
		*(p++)=0;
		*(p++)=0;
d1973 1
a1973 1
		}
d1976 1
a1976 1
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
d1978 2
a1979 2
	return(-1);
	}
d1981 4
a1984 3
int ssl3_get_client_key_exchange(SSL *s)
	{
	int i,al,ok;
d1989 2
a1990 2
	RSA *rsa=NULL;
	EVP_PKEY *pkey=NULL;
d1993 1
a1993 1
	BIGNUM *pub=NULL;
d2004 2
a2005 1
	BN_CTX *bn_ctx = NULL; 
d2008 6
a2013 6
	n=s->method->ssl_get_message(s,
		SSL3_ST_SR_KEY_EXCH_A,
		SSL3_ST_SR_KEY_EXCH_B,
		SSL3_MT_CLIENT_KEY_EXCHANGE,
		2048, /* ??? */
		&ok);
d2015 1
a2015 4
	if (!ok) return((int)n);
	p=(unsigned char *)s->init_msg;

	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
d2018 1
a2018 2
	if (alg_k & SSL_kRSA)
		{
d2020 1
a2020 2
		if (s->s3->tmp.use_rsa_tmp)
			{
d2022 1
a2022 1
				rsa=s->cert->rsa_tmp;
d2025 3
a2027 4
			if (rsa == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_PKEY);
a2029 1
				}
d2031 6
a2036 9
		else
			{
			pkey=s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey;
			if (	(pkey == NULL) ||
				(pkey->type != EVP_PKEY_RSA) ||
				(pkey->pkey.rsa == NULL))
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_RSA_CERTIFICATE);
a2037 2
				}
			rsa=pkey->pkey.rsa;
d2039 2
d2043 5
a2047 8
		if (s->version > SSL3_VERSION && s->version != DTLS1_BAD_VER)
			{
			n2s(p,i);
			if (n != i+2)
				{
				if (!(s->options & SSL_OP_TLS_D5_BUG))
					{
					SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
d2049 5
a2053 7
					}
				else
					p-=2;
				}
			else
				n=i;
			}
d2055 1
a2055 1
		i=RSA_private_decrypt((int)n,p,p,rsa,RSA_PKCS1_PADDING);
d2058 3
a2060 4
		
		if (i != SSL_MAX_MASTER_KEY_LENGTH)
			{
			al=SSL_AD_DECODE_ERROR;
d2062 1
a2062 1
			}
d2064 1
a2064 2
		if ((al == -1) && !((p[0] == (s->client_version>>8)) && (p[1] == (s->client_version & 0xff))))
			{
d2073 2
a2074 3
				(p[0] == (s->version>>8)) && (p[1] == (s->version & 0xff))))
				{
				al=SSL_AD_DECODE_ERROR;
a2083 1
				}
d2085 1
d2087 1
a2087 2
		if (al != -1)
			{
a2096 7
			}
	
		s->session->master_key_length=
			s->method->ssl3_enc->generate_master_secret(s,
				s->session->master_key,
				p,i);
		OPENSSL_cleanse(p,i);
d2098 7
a2104 1
	else
d2107 9
a2115 15
		if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
		{
		n2s(p,i);
		if (n != i+2)
			{
			if (!(s->options & SSL_OP_SSLEAY_080_CLIENT_DH_BUG))
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
				goto err;
				}
			else
				{
				p-=2;
				i=(int)n;
				}
d2117 1
d2120 3
a2122 3
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_DECODE_DH_CERTS);
d2124 4
a2127 7
			}
		else
			{
			if (s->s3->tmp.dh == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_DH_KEY);
d2129 3
a2131 4
				}
			else
				dh_srvr=s->s3->tmp.dh;
			}
d2133 3
a2135 4
		pub=BN_bin2bn(p,i,NULL);
		if (pub == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BN_LIB);
d2137 1
a2137 1
			}
d2139 1
a2139 1
		i=DH_compute_key(p,pub,dh_srvr);
d2141 2
a2142 3
		if (i <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
d2145 1
a2145 1
			}
d2148 1
a2148 1
		s->s3->tmp.dh=NULL;
d2151 7
a2157 8
		pub=NULL;
		s->session->master_key_length=
			s->method->ssl3_enc->generate_master_secret(s,
				s->session->master_key,p,i);
		OPENSSL_cleanse(p,i);
		}
	else
#endif
d2159 1
a2159 2
	if (alg_k & SSL_kKRB5)
		{
d2169 1
a2169 1
					       + EVP_MAX_BLOCK_LENGTH];
d2176 2
a2177 1
		if (!kssl_ctx)  kssl_ctx = kssl_ctx_new();
d2179 1
a2179 1
		n2s(p,i);
d2182 1
a2182 2
		if (n < (long)(enc_ticket.length + 6))
			{
d2184 1
a2184 1
				SSL_R_DATA_LENGTH_TOO_LONG);
d2186 1
a2186 1
			}
d2189 1
a2189 1
		p+=enc_ticket.length;
d2191 1
a2191 1
		n2s(p,i);
d2194 1
a2194 2
		if (n < (long)(enc_ticket.length + authenticator.length + 6))
			{
d2196 1
a2196 1
				SSL_R_DATA_LENGTH_TOO_LONG);
d2198 1
a2198 1
			}
d2201 1
a2201 1
		p+=authenticator.length;
d2203 1
a2203 1
		n2s(p,i);
d2206 1
a2206 1
		p+=enc_pms.length;
d2211 1
a2211 2
		if(enc_pms.length > sizeof pms)
			{
d2213 1
a2213 1
			       SSL_R_DATA_LENGTH_TOO_LONG);
d2215 1
a2215 1
			}
d2218 1
a2218 2
						enc_pms.length + 6))
			{
d2220 1
a2220 1
				SSL_R_DATA_LENGTH_TOO_LONG);
d2222 1
a2222 1
			}
d2225 1
a2225 2
					&kssl_err)) != 0)
			{
d2228 1
a2228 1
				krb5rc, kssl_err.reason);
d2233 1
a2233 1
				kssl_err.reason);
d2235 1
a2235 1
			}
d2241 1
a2241 2
					&authtime, &kssl_err)) != 0)
			{
d2244 1
a2244 1
				krb5rc, kssl_err.reason);
d2249 1
a2249 1
				kssl_err.reason);
d2251 1
a2251 1
			}
d2253 1
a2253 2
		if ((krb5rc = kssl_validate_times(authtime, &ttimes)) != 0)
			{
d2256 1
a2256 1
			}
d2264 1
a2264 1
		    goto err;
d2268 1
a2268 2
		if (!EVP_DecryptInit_ex(&ciph_ctx,enc,NULL,kssl_ctx->key,iv))
			{
d2270 1
a2270 1
				SSL_R_DECRYPTION_FAILED);
d2272 3
a2274 4
			}
		if (!EVP_DecryptUpdate(&ciph_ctx, pms,&outl,
					(unsigned char *)enc_pms.data, enc_pms.length))
			{
d2276 1
a2276 1
				SSL_R_DECRYPTION_FAILED);
d2278 2
a2279 3
			}
		if (outl > SSL_MAX_MASTER_KEY_LENGTH)
			{
d2281 1
a2281 1
				SSL_R_DATA_LENGTH_TOO_LONG);
d2283 2
a2284 3
			}
		if (!EVP_DecryptFinal_ex(&ciph_ctx,&(pms[outl]),&padl))
			{
d2286 1
a2286 1
				SSL_R_DECRYPTION_FAILED);
d2288 1
a2288 1
			}
d2290 1
a2290 2
		if (outl > SSL_MAX_MASTER_KEY_LENGTH)
			{
d2292 1
a2292 1
				SSL_R_DATA_LENGTH_TOO_LONG);
d2294 2
a2295 3
			}
		if (!((pms[0] == (s->client_version>>8)) && (pms[1] == (s->client_version & 0xff))))
		    {
d2304 4
a2307 5
		    if (!(s->options & SSL_OP_TLS_ROLLBACK_BUG))
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			       SSL_AD_DECODE_ERROR);
			goto err;
d2309 1
a2309 1
		    }
d2313 3
a2315 3
		s->session->master_key_length=
			s->method->ssl3_enc->generate_master_secret(s,
				s->session->master_key, pms, outl);
d2317 1
a2317 2
		if (kssl_ctx->client_princ)
			{
d2319 1
a2319 2
			if ( len < SSL_MAX_KRB5_PRINCIPAL_LENGTH ) 
				{
d2321 1
a2321 2
				memcpy(s->session->krb5_client_princ,kssl_ctx->client_princ,len);
				}
d2323 1
d2331 1
a2331 2
		}
	else
d2335 1
a2335 2
		if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe))
		{
d2343 1
a2343 2
		if ((srvr_ecdh = EC_KEY_new()) == NULL) 
			{
d2345 1
a2345 1
			    ERR_R_MALLOC_FAILURE);
d2347 1
a2347 1
			}
d2350 1
a2350 2
		if (alg_k & (SSL_kECDHr|SSL_kECDHe))
			{ 
d2353 1
a2353 3
			}
		else
			{
d2358 1
a2358 1
			}
d2360 1
a2360 1
		group    = EC_KEY_get0_group(tkey);
d2364 1
a2364 2
		    !EC_KEY_set_private_key(srvr_ecdh, priv_key))
			{
d2366 1
a2366 1
			       ERR_R_EC_LIB);
d2368 1
a2368 1
			}
d2371 1
a2371 2
		if ((clnt_ecpoint = EC_POINT_new(group)) == NULL)
			{
d2373 1
a2373 1
			    ERR_R_MALLOC_FAILURE);
d2375 1
a2375 1
			}
d2377 1
a2377 2
		if (n == 0L) 
			{
d2380 8
a2387 10
			 if (alg_k & SSL_kEECDH)
				 {
				 al=SSL_AD_HANDSHAKE_FAILURE;
				 SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);
				 goto f_err;
				 }
			if (((clnt_pub_pkey=X509_get_pubkey(s->session->peer))
			    == NULL) || 
			    (clnt_pub_pkey->type != EVP_PKEY_EC))
				{
d2399 5
a2403 5
			   	al=SSL_AD_HANDSHAKE_FAILURE;
			   	SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    SSL_R_UNABLE_TO_DECODE_ECDH_CERTS);
			   	goto f_err;
			   	}
d2406 1
a2406 2
			    EC_KEY_get0_public_key(clnt_pub_pkey->pkey.ec)) == 0)
				{
d2408 1
a2408 1
					ERR_R_EC_LIB);
d2410 1
a2410 1
				}
d2412 1
a2412 3
			}
		else
			{
d2416 1
a2416 2
			if ((bn_ctx = BN_CTX_new()) == NULL)
				{
d2418 1
a2418 1
				    ERR_R_MALLOC_FAILURE);
d2420 1
a2420 1
				}
d2423 2
a2424 1
			i = *p; 
d2426 1
a2426 2
			if (n != 1 + i)
				{
d2428 1
a2428 1
				    ERR_R_EC_LIB);
d2430 3
a2432 4
				}
			if (EC_POINT_oct2point(group, 
			    clnt_ecpoint, p, i, bn_ctx) == 0)
				{
d2434 1
a2434 1
				    ERR_R_EC_LIB);
d2436 1
a2436 1
				}
d2440 2
a2441 2
			p=(unsigned char *)s->init_buf->data;
			}
d2445 3
a2447 4
		if (field_size <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, 
			       ERR_R_ECDH_LIB);
d2449 3
a2451 4
			}
		i = ECDH_compute_key(p, (field_size+7)/8, clnt_ecpoint, srvr_ecdh, NULL);
		if (i <= 0)
			{
d2453 1
a2453 1
			    ERR_R_ECDH_LIB);
d2455 1
a2455 1
			}
d2462 2
a2463 1
		s->s3->tmp.ecdh = NULL; 
d2468 1
a2468 1
		
d2471 1
a2471 2
		}
	else
d2474 8
a2481 29
		if (alg_k & SSL_kPSK)
			{
			unsigned char *t = NULL;
			unsigned char psk_or_pre_ms[PSK_MAX_PSK_LEN*2+4];
			unsigned int pre_ms_len = 0, psk_len = 0;
			int psk_err = 1;
			char tmp_id[PSK_MAX_IDENTITY_LEN+1];

			al=SSL_AD_HANDSHAKE_FAILURE;

			n2s(p,i);
			if (n != i+2)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					SSL_R_LENGTH_MISMATCH);
				goto psk_err;
				}
			if (i > PSK_MAX_IDENTITY_LEN)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					SSL_R_DATA_LENGTH_TOO_LONG);
				goto psk_err;
				}
			if (s->psk_server_callback == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				       SSL_R_PSK_NO_SERVER_CB);
				goto psk_err;
				}
d2483 16
a2498 7
			/* Create guaranteed NULL-terminated identity
			 * string for the callback */
			memcpy(tmp_id, p, i);
			memset(tmp_id+i, 0, PSK_MAX_IDENTITY_LEN+1-i);
			psk_len = s->psk_server_callback(s, tmp_id,
				psk_or_pre_ms, sizeof(psk_or_pre_ms));
			OPENSSL_cleanse(tmp_id, PSK_MAX_IDENTITY_LEN+1);
d2500 7
a2506 14
			if (psk_len > PSK_MAX_PSK_LEN)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					ERR_R_INTERNAL_ERROR);
				goto psk_err;
				}
			else if (psk_len == 0)
				{
				/* PSK related to the given identity not found */
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				       SSL_R_PSK_IDENTITY_NOT_FOUND);
				al=SSL_AD_UNKNOWN_PSK_IDENTITY;
				goto psk_err;
				}
d2508 29
a2536 18
			/* create PSK pre_master_secret */
			pre_ms_len=2+psk_len+2+psk_len;
			t = psk_or_pre_ms;
			memmove(psk_or_pre_ms+psk_len+4, psk_or_pre_ms, psk_len);
			s2n(psk_len, t);
			memset(t, 0, psk_len);
			t+=psk_len;
			s2n(psk_len, t);

			if (s->session->psk_identity != NULL)
				OPENSSL_free(s->session->psk_identity);
			s->session->psk_identity = BUF_strdup((char *)p);
			if (s->session->psk_identity == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto psk_err;
				}
d2538 9
a2546 10
			if (s->session->psk_identity_hint != NULL)
				OPENSSL_free(s->session->psk_identity_hint);
			s->session->psk_identity_hint = BUF_strdup(s->ctx->psk_identity_hint);
			if (s->ctx->psk_identity_hint != NULL &&
				s->session->psk_identity_hint == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto psk_err;
				}
d2548 4
a2551 4
			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key, psk_or_pre_ms, pre_ms_len);
			psk_err = 0;
d2553 4
a2556 5
			OPENSSL_cleanse(psk_or_pre_ms, sizeof(psk_or_pre_ms));
			if (psk_err != 0)
				goto f_err;
			}
		else
d2559 2
a2560 3
		if (alg_k & SSL_kSRP)
			{
			int param_len;
d2562 19
a2580 22
			n2s(p,i);
			param_len=i+2;
			if (param_len > n)
				{
				al=SSL_AD_DECODE_ERROR;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_SRP_A_LENGTH);
				goto f_err;
				}
			if (!(s->srp_ctx.A=BN_bin2bn(p,i,NULL)))
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,ERR_R_BN_LIB);
				goto err;
				}
			if (s->session->srp_username != NULL)
				OPENSSL_free(s->session->srp_username);
			s->session->srp_username = BUF_strdup(s->srp_ctx.login);
			if (s->session->srp_username == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto err;
				}
d2582 4
a2585 5
			if ((s->session->master_key_length = SRP_generate_server_master_secret(s,s->session->master_key))<0)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
				goto err;
				}
d2587 2
a2588 3
			p+=i;
			}
		else
d2590 14
a2603 15
		if (alg_k & SSL_kGOST) 
			{
			int ret = 0;
			EVP_PKEY_CTX *pkey_ctx;
			EVP_PKEY *client_pub_pkey = NULL, *pk = NULL;
			unsigned char premaster_secret[32], *start;
			size_t outlen=32, inlen;
			unsigned long alg_a;

			/* Get our certificate private key*/
			alg_a = s->s3->tmp.new_cipher->algorithm_auth;
			if (alg_a & SSL_aGOST94)
				pk = s->cert->pkeys[SSL_PKEY_GOST94].privatekey;
			else if (alg_a & SSL_aGOST01)
				pk = s->cert->pkeys[SSL_PKEY_GOST01].privatekey;
d2605 2
a2606 2
			pkey_ctx = EVP_PKEY_CTX_new(pk,NULL);
			EVP_PKEY_decrypt_init(pkey_ctx);
d2611 35
a2645 42
			client_pub_pkey = X509_get_pubkey(s->session->peer);
			if (client_pub_pkey)
				{
				if (EVP_PKEY_derive_set_peer(pkey_ctx, client_pub_pkey) <= 0)
					ERR_clear_error();
				}
			/* Decrypt session key */
			if ((*p!=( V_ASN1_SEQUENCE| V_ASN1_CONSTRUCTED))) 
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_DECRYPTION_FAILED);
				goto gerr;
				}
			if (p[1] == 0x81)
				{
				start = p+3;
				inlen = p[2];
				}
			else if (p[1] < 0x80)
				{
				start = p+2;
				inlen = p[1];
				}
			else
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_DECRYPTION_FAILED);
				goto gerr;
				}
			if (EVP_PKEY_decrypt(pkey_ctx,premaster_secret,&outlen,start,inlen) <=0) 

				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_DECRYPTION_FAILED);
				goto gerr;
				}
			/* Generate master secret */
			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,premaster_secret,32);
			/* Check if pubkey from client certificate was used */
			if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0)
				ret = 2;
			else
				ret = 1;
d2647 4
a2650 7
			EVP_PKEY_free(client_pub_pkey);
			EVP_PKEY_CTX_free(pkey_ctx);
			if (ret)
				return ret;
			else
				goto err;
			}
d2652 3
a2654 2
		{
		al=SSL_AD_HANDSHAKE_FAILURE;
d2656 1
a2656 1
				SSL_R_UNKNOWN_CIPHER_TYPE);
d2658 1
a2658 1
		}
d2660 1
a2660 1
	return(1);
d2662 1
a2662 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d2669 1
a2669 1
	if (srvr_ecdh != NULL) 
d2673 2
a2674 2
	return(-1);
	}
d2676 4
a2679 3
int ssl3_get_cert_verify(SSL *s)
	{
	EVP_PKEY *pkey=NULL;
d2681 1
a2681 1
	int al,ok,ret=0;
d2683 1
a2683 1
	int type=0,i,j;
d2689 5
a2693 6
	n=s->method->ssl_get_message(s,
		SSL3_ST_SR_CERT_VRFY_A,
		SSL3_ST_SR_CERT_VRFY_B,
		-1,
		516, /* Enough for 4096 bit RSA key with TLS v1.2 */
		&ok);
d2695 8
a2702 1
	if (!ok) return((int)n);
d2704 6
a2709 5
	if (s->session->peer != NULL)
		{
		peer=s->session->peer;
		pkey=X509_get_pubkey(peer);
		type=X509_certificate_type(peer,pkey);
d2711 1
a2711 16
	else
		{
		peer=NULL;
		pkey=NULL;
		}

	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)
		{
		s->s3->tmp.reuse_message=1;
		if ((peer != NULL) && (type & EVP_PKT_SIGN))
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);
			goto f_err;
			}
		ret=1;
d2713 1
a2713 1
		}
d2715 3
a2717 4
	if (peer == NULL)
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);
		al=SSL_AD_UNEXPECTED_MESSAGE;
d2719 1
a2719 1
		}
d2721 3
a2723 4
	if (!(type & EVP_PKT_SIGN))
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
		al=SSL_AD_ILLEGAL_PARAMETER;
d2725 1
a2725 1
		}
d2727 3
a2729 4
	if (s->s3->change_cipher_spec)
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
		al=SSL_AD_UNEXPECTED_MESSAGE;
d2731 1
a2731 1
		}
d2734 1
a2734 1
	p=(unsigned char *)s->init_msg;
d2738 5
a2742 9
	if (n==64 && (pkey->type==NID_id_GostR3410_94 ||
		pkey->type == NID_id_GostR3410_2001) )
		{
		i=64;
		} 
	else 
		{	
		if (TLS1_get_version(s) >= TLS1_2_VERSION)
			{
d2745 3
a2747 4
			if (sigalg == -1)
				{
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);
				al=SSL_AD_INTERNAL_ERROR;
d2749 1
a2749 1
				}
d2751 3
a2753 4
			if (sigalg != (int)p[1])
				{
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_TYPE);
				al=SSL_AD_DECODE_ERROR;
d2755 1
a2755 1
				}
d2757 3
a2759 4
			if (md == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_UNKNOWN_DIGEST);
				al=SSL_AD_DECODE_ERROR;
d2761 1
a2761 1
				}
d2763 1
a2763 1
fprintf(stderr, "USING TLSv1.2 HASH %s\n", EVP_MD_name(md));
d2767 6
a2772 7
			}
		n2s(p,i);
		n-=2;
		if (i > n)
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
			al=SSL_AD_DECODE_ERROR;
d2774 6
a2779 7
			}
    	}
	j=EVP_PKEY_size(pkey);
	if ((i > j) || (n > j) || (n <= 0))
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);
		al=SSL_AD_DECODE_ERROR;
d2781 1
a2781 1
		}
d2783 1
a2783 2
	if (TLS1_get_version(s) >= TLS1_2_VERSION)
		{
d2787 1
a2787 2
		if (hdatalen <= 0)
			{
d2789 1
a2789 1
			al=SSL_AD_INTERNAL_ERROR;
d2791 1
a2791 1
			}
d2794 1
a2794 1
							EVP_MD_name(md));
d2796 2
a2797 3
		if (!EVP_VerifyInit_ex(&mctx, md, NULL)
			|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))
			{
d2799 1
a2799 1
			al=SSL_AD_INTERNAL_ERROR;
d2801 1
a2801 1
			}
d2803 3
a2805 4
		if (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);
a2806 1
			}
d2808 1
a2808 1
	else
d2810 7
a2816 9
	if (pkey->type == EVP_PKEY_RSA)
		{
		i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,
			MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, 
							pkey->pkey.rsa);
		if (i < 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);
d2818 4
a2821 5
			}
		if (i == 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);
a2822 1
			}
d2824 1
a2824 1
	else
d2827 5
a2831 7
		if (pkey->type == EVP_PKEY_DSA)
		{
		j=DSA_verify(pkey->save_type,
			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
			SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);
		if (j <= 0)
			{
d2833 2
a2834 2
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);
a2835 1
			}
d2837 1
a2837 1
	else
d2840 5
a2844 7
		if (pkey->type == EVP_PKEY_EC)
		{
		j=ECDSA_verify(pkey->save_type,
			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
			SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);
		if (j <= 0)
			{
d2846 1
a2846 1
			al=SSL_AD_DECRYPT_ERROR;
d2848 1
a2848 1
			    SSL_R_BAD_ECDSA_SIGNATURE);
a2849 1
			}
d2851 1
a2851 1
	else
d2853 18
a2870 20
	if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)
		{   unsigned char signature[64];
			int idx;
			EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);
			EVP_PKEY_verify_init(pctx);
			if (i!=64) {
				fprintf(stderr,"GOST signature length is %d",i);
			}	
			for (idx=0;idx<64;idx++) {
				signature[63-idx]=p[idx];
			}	
			j=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);
			EVP_PKEY_CTX_free(pctx);
			if (j<=0) 
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
					SSL_R_BAD_ECDSA_SIGNATURE);
				goto f_err;
				}	
d2872 3
a2874 4
	else	
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);
		al=SSL_AD_UNSUPPORTED_CERTIFICATE;
d2876 1
a2876 1
		}
d2879 2
a2880 3
	ret=1;
	if (0)
		{
d2882 2
a2883 2
		ssl3_send_alert(s,SSL3_AL_FATAL,al);
		}
d2885 1
a2885 2
	if (s->s3->handshake_buffer)
		{
d2889 1
a2889 1
		}
d2892 2
a2893 2
	return(ret);
	}
d2895 7
a2901 6
int ssl3_get_client_certificate(SSL *s)
	{
	int i,ok,al,ret= -1;
	X509 *x=NULL;
	unsigned long l,nc,llen,n;
	const unsigned char *p,*q;
d2903 1
a2903 1
	STACK_OF(X509) *sk=NULL;
d2905 6
a2910 6
	n=s->method->ssl_get_message(s,
		SSL3_ST_SR_CERT_A,
		SSL3_ST_SR_CERT_B,
		-1,
		s->max_cert_list,
		&ok);
d2912 2
a2913 1
	if (!ok) return((int)n);
d2915 5
a2919 7
	if	(s->s3->tmp.message_type == SSL3_MT_CLIENT_KEY_EXCHANGE)
		{
		if (	(s->verify_mode & SSL_VERIFY_PEER) &&
			(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
			al=SSL_AD_HANDSHAKE_FAILURE;
d2921 1
a2921 1
			}
d2923 3
a2925 4
		if ((s->version > SSL3_VERSION) && s->s3->tmp.cert_request)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST);
			al=SSL_AD_UNEXPECTED_MESSAGE;
a2926 3
			}
		s->s3->tmp.reuse_message=1;
		return(1);
d2928 3
d2932 3
a2934 4
	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_WRONG_MESSAGE_TYPE);
d2936 2
a2937 2
		}
	p=d=(unsigned char *)s->init_msg;
d2939 2
a2940 3
	if ((sk=sk_X509_new_null()) == NULL)
		{
		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_MALLOC_FAILURE);
d2942 1
a2942 1
		}
d2944 4
a2947 5
	n2l3(p,llen);
	if (llen+3 != n)
		{
		al=SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_LENGTH_MISMATCH);
d2949 7
a2956 9
	for (nc=0; nc<llen; )
		{
		n2l3(p,l);
		if ((l+nc+3) > llen)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);
			goto f_err;
			}
d2958 4
a2961 5
		q=p;
		x=d2i_X509(NULL,&p,l);
		if (x == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_ASN1_LIB);
d2963 4
a2966 5
			}
		if (p != (q+l))
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);
d2968 3
a2970 4
			}
		if (!sk_X509_push(sk,x))
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_MALLOC_FAILURE);
a2971 3
			}
		x=NULL;
		nc+=l+3;
d2973 3
d2977 1
a2977 2
	if (sk_X509_num(sk) <= 0)
		{
d2979 3
a2981 4
		if (s->version == SSL3_VERSION)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_NO_CERTIFICATES_RETURNED);
d2983 1
a2983 1
			}
d2986 3
a2988 4
			 (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
			al=SSL_AD_HANDSHAKE_FAILURE;
d2990 1
a2990 1
			}
d2992 2
a2993 3
		if (s->s3->handshake_buffer && !ssl3_digest_cached_records(s))
			{
			al=SSL_AD_INTERNAL_ERROR;
a2994 1
			}
d2996 5
a3000 7
	else
		{
		i=ssl_verify_cert_chain(s,sk);
		if (i <= 0)
			{
			al=ssl_verify_alarm_type(s->verify_result);
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_NO_CERTIFICATE_RETURNED);
a3001 1
			}
d3003 1
d3007 1
a3007 1
	s->session->peer=sk_X509_shift(sk);
d3012 1
a3012 2
	if (s->session->sess_cert == NULL)
		{
d3014 1
a3014 2
		if (s->session->sess_cert == NULL)
			{
a3016 1
			}
d3018 1
d3021 1
a3021 1
	s->session->sess_cert->cert_chain=sk;
d3025 1
a3025 1
	sk=NULL;
d3027 2
a3028 3
	ret=1;
	if (0)
		{
d3030 2
a3031 2
		ssl3_send_alert(s,SSL3_AL_FATAL,al);
		}
d3033 6
a3038 4
	if (x != NULL) X509_free(x);
	if (sk != NULL) sk_X509_pop_free(sk,X509_free);
	return(ret);
	}
d3040 3
a3042 2
int ssl3_send_server_certificate(SSL *s)
	{
d3046 3
a3048 5
	if (s->state == SSL3_ST_SW_CERT_A)
		{
		x=ssl_get_server_send_cert(s);
		if (x == NULL)
			{
d3051 3
a3053 5
			    (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5))
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,ERR_R_INTERNAL_ERROR);
				return(0);
				}
d3055 1
d3057 5
a3061 5
		l=ssl3_output_cert_chain(s,x);
		s->state=SSL3_ST_SW_CERT_B;
		s->init_num=(int)l;
		s->init_off=0;
		}
d3064 2
a3065 2
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
	}
d3069 4
a3072 4
int ssl3_send_newsession_ticket(SSL *s)
	{
	if (s->state == SSL3_ST_SW_SESSION_TICKET_A)
		{
d3100 1
a3100 2
		if (sess == NULL)
			{
d3103 1
a3103 1
			}
d3108 1
a3108 1
			{
d3111 1
a3111 1
			}
d3125 2
a3126 2
			EVP_MAX_MD_SIZE + slen))
			return -1;
d3128 1
a3128 1
		p=(unsigned char *)s->init_buf->data;
d3130 1
a3130 1
		*(p++)=SSL3_MT_NEWSESSION_TICKET;
d3139 1
a3139 2
		if (tctx->tlsext_ticket_key_cb)
			{
d3141 1
a3141 2
							 &hctx, 1) < 0)
				{
a3143 1
				}
d3145 1
a3145 2
		else
			{
d3148 1
a3148 1
					tctx->tlsext_tick_aes_key, iv);
d3150 1
a3150 1
					tlsext_tick_md(), NULL);
d3152 1
a3152 1
			}
d3184 1
a3184 1
		p=(unsigned char *)s->init_buf->data + 1;
d3187 2
a3188 1
		s2n(len - 10, p);  /* Ticket length */
d3191 3
a3193 3
		s->init_num= len;
		s->state=SSL3_ST_SW_SESSION_TICKET_B;
		s->init_off=0;
d3195 1
a3195 1
		}
d3198 2
a3199 2
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
	}
d3201 4
a3204 4
int ssl3_send_cert_status(SSL *s)
	{
	if (s->state == SSL3_ST_SW_CERT_STATUS_A)
		{
d3214 1
a3214 1
		p=(unsigned char *)s->init_buf->data;
d3217 1
a3217 1
		*(p++)=SSL3_MT_CERTIFICATE_STATUS;
d3221 1
a3221 1
		*(p++)= s->tlsext_status_type;
d3228 1
a3228 1
		s->state=SSL3_ST_SW_CERT_STATUS_B;
d3230 1
a3230 1
		}
d3233 2
a3234 2
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
	}
d3239 3
a3241 2
int ssl3_get_next_proto(SSL *s)
	{
d3249 2
a3250 3
	if (!s->s3->next_proto_neg_seen)
		{
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO,SSL_R_GOT_NEXT_PROTO_WITHOUT_EXTENSION);
d3252 1
a3252 8
		}

	n=s->method->ssl_get_message(s,
		SSL3_ST_SR_NEXT_PROTO_A,
		SSL3_ST_SR_NEXT_PROTO_B,
		SSL3_MT_NEXT_PROTO,
		514,  /* See the payload format below */
		&ok);
d3254 3
d3258 1
a3258 1
		return((int)n);
d3263 2
a3264 3
	if (!s->s3->change_cipher_spec)
		{
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO,SSL_R_GOT_NEXT_PROTO_BEFORE_A_CCS);
d3266 1
a3266 1
		}
d3269 2
a3270 1
		return 0;  /* The body must be > 1 bytes long */
d3272 1
a3272 1
	p=(unsigned char *)s->init_msg;
d3288 2
a3289 3
	if (!s->next_proto_negotiated)
		{
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO,ERR_R_MALLOC_FAILURE);
d3291 1
a3291 1
		}
d3296 1
a3296 1
	}
@


1.30
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d223 1
a223 1
	clear_sys_error();
@


1.29
log
@resolve conflicts
@
text
@d194 2
a195 1
			/* There isn't any srp login extension !!! */
d382 1
d961 2
a962 1
		if ((s->client_version>>8) == SSL3_VERSION_MAJOR)
d1187 1
a1187 1
		if (ssl_check_clienthello_tlsext(s) <= 0) {
a1196 1
		unsigned long Time;
a1197 1
		Time=(unsigned long)time(NULL);			/* Time */
d1199 1
a1199 2
		l2n(Time,pos);
		if (RAND_pseudo_bytes(pos,SSL3_RANDOM_SIZE-4) <= 0)
d1392 2
d1395 1
d1409 10
a1435 3
#ifdef OPENSSL_NO_TLSEXT
	unsigned long Time;
#endif
d1442 1
a1442 4
		/* Generate server_random if it was not needed previously */
		Time=(unsigned long)time(NULL);			/* Time */
		l2n(Time,p);
		if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
d1833 1
a1833 1
		for (i=0; r[i] != NULL && i<4; i++)
d1869 1
a1869 1
		for (i=0; r[i] != NULL && i<4; i++)
@


1.29.4.1
log
@MFC ChangeCipherSpec fixes (CVE-2014-0224 and additional safeguard), ok jsing@@

"Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret." From s3_clnt.c r1.64, s3_pkt.c r1.42,
s3_srvr.c r1.59, ssl3.h r1.19 - note that the ssl3.h change has been
applied to s3_locl.h instead to simplify patching.

"Ensure that we do not process a ChangeCipherSpec with an empty master
secret. This is an additional safeguard against early ChangeCipherSpec
handling."  From s3_pkt.c:1.43
@
text
@a672 1
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
a700 1
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
d770 1
a770 2
				if (s->s3->next_proto_neg_seen) {
					s->s3->flags |= SSL3_FLAGS_CCS_OK;
d772 1
a772 1
				} else
@


1.29.4.2
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@a2783 7
			if (BN_ucmp(s->srp_ctx.A, s->srp_ctx.N) >= 0
				|| BN_is_zero(s->srp_ctx.A))
				{
				al=SSL_AD_ILLEGAL_PARAMETER;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_WRONG_CIPHER_RETURNED);
				goto f_err;
				}
@


1.29.8.1
log
@MFC ChangeCipherSpec fixes (CVE-2014-0224 and additional safeguard), ok jsing@@

"Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret." From s3_clnt.c r1.64, s3_pkt.c r1.42,
s3_srvr.c r1.59, ssl3.h r1.19 - note that the ssl3.h change has been
applied to s3_locl.h instead to simplify patching.

"Ensure that we do not process a ChangeCipherSpec with an empty master
secret. This is an additional safeguard against early ChangeCipherSpec
handling."  From s3_pkt.c:1.43
@
text
@a672 1
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
a700 1
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
d770 1
a770 2
				if (s->s3->next_proto_neg_seen) {
					s->s3->flags |= SSL3_FLAGS_CCS_OK;
d772 1
a772 1
				} else
@


1.29.8.2
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@a2783 7
			if (BN_ucmp(s->srp_ctx.A, s->srp_ctx.N) >= 0
				|| BN_is_zero(s->srp_ctx.A))
				{
				al=SSL_AD_ILLEGAL_PARAMETER;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_WRONG_CIPHER_RETURNED);
				goto f_err;
				}
@


1.28
log
@OpenSSL 1.0.0f: merge
@
text
@d182 25
d239 12
d258 1
a258 1
			s->new_session=1;
d354 28
a381 4
			ret=ssl3_get_client_hello(s);
			if (ret <= 0) goto end;
			
			s->new_session = 2;
d410 1
a410 1
			/* normal PSK or KRB5 */
d475 4
d525 3
d610 1
d612 6
d620 18
d678 1
d680 6
d689 10
d704 2
d707 1
a707 1
			if (s->tlsext_ticket_expected)
a708 5
			else if (s->hit)
				s->state=SSL_ST_OK;
#else
			if (s->hit)
				s->state=SSL_ST_OK;
d766 2
d769 7
d793 1
a793 1
			if (s->new_session == 2) /* skipped if we just sent a HelloRequest */
d795 1
a795 3
				/* actually not necessarily a 'new' session unless
				 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
				
a872 8
	/* We only allow the client to restart the handshake once per
	 * negotiation. */
	if (s->s3->flags & SSL3_FLAGS_SGC_RESTART_DONE)
		{
		SSLerr(SSL_F_SSL3_CHECK_CLIENT_HELLO, SSL_R_MULTIPLE_SGC_RESTARTS);
		return -1;
		}

d885 7
d933 2
a934 1
	if (s->state == SSL3_ST_SR_CLNT_HELLO_A)
d991 10
a1000 7
	/* Versions before 0.9.7 always allow session reuse during renegotiation
	 * (i.e. when s->new_session is true), option
	 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is new with 0.9.7.
	 * Maybe this optional behaviour should always have been the default,
	 * but we cannot safely change the default behaviour (or new applications
	 * might be written that become totally unsecure when compiled with
	 * an earlier library version)
d1389 5
a1393 2
	if (!ssl3_digest_cached_records(s))
		goto f_err;
d1448 14
a1461 14
		/* now in theory we have 3 options to sending back the
		 * session id.  If it is a re-use, we send back the
		 * old session-id, if it is a new session, we send
		 * back the new session-id or we send back a 0 length
		 * session-id if we want it to be single use.
		 * Currently I will not implement the '0' length session-id
		 * 12-Jan-98 - I'll now support the '0' length stuff.
		 *
		 * We also have an additional case where stateless session
		 * resumption is successful: we always send back the old
		 * session id. In this case s->hit is non zero: this can
		 * only happen if stateless session resumption is succesful
		 * if session caching is disabled so existing functionality
		 * is unaffected.
d1562 1
d1803 18
d1826 1
a1826 1
		for (i=0; r[i] != NULL; i++)
d1829 5
d1840 1
a1840 1
			if ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher))
d1862 1
a1862 1
		for (i=0; r[i] != NULL; i++)
d1864 8
d1919 2
a1920 1
			if (pkey->type == EVP_PKEY_RSA)
d1926 2
d1949 1
a1949 2
#if !defined(OPENSSL_NO_DSA)
				if (pkey->type == EVP_PKEY_DSA)
d1951 3
a1953 7
				/* lets do DSS */
				EVP_SignInit_ex(&md_ctx,EVP_dss1(), NULL);
				EVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(d[4]),n);
				if (!EVP_SignFinal(&md_ctx,&(p[2]),
					(unsigned int *)&i,pkey))
d1955 8
a1962 2
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_DSA);
					goto err;
d1964 3
a1966 4
				s2n(i,p);
				n+=i+2;
				}
			else
d1968 1
a1968 5
#if !defined(OPENSSL_NO_ECDSA)
				if (pkey->type == EVP_PKEY_EC)
				{
				/* let's do ECDSA */
				EVP_SignInit_ex(&md_ctx,EVP_ecdsa(), NULL);
d1975 1
a1975 1
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_ECDSA);
d1980 2
a1983 1
#endif
d2036 8
d2763 38
d2884 1
a2884 1
#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH)
d2905 3
d2913 1
a2913 1
		514, /* 514? */
d2933 1
a2933 1
		if ((peer != NULL) && (type | EVP_PKT_SIGN))
d2976 30
d3023 31
d3144 7
d3263 6
d3345 1
d3347 1
d3353 3
a3355 1
		int len, slen;
d3364 1
a3364 1
		slen = i2d_SSL_SESSION(s->session, NULL);
d3368 4
a3371 1
		if (slen > 0xFF00)
d3373 23
a3406 5
		senc = OPENSSL_malloc(slen);
		if (!senc)
			return -1;
		p = senc;
		i2d_SSL_SESSION(s->session, &p);
d3437 7
a3443 1
		l2n(s->session->tlsext_tick_lifetime_hint, p);
d3518 68
@


1.27
log
@openssl-1.0.0e: resolve conflicts
@
text
@d261 1
d759 8
d795 1
d2143 1
@


1.26
log
@Security fix for CVE-2010-4180 as mentioned in http://www.openssl.org/news/secadv_20101202.txt.
where clients could modify the stored session
cache ciphersuite and in some cases even downgrade the suite to weaker ones.

This code is not enabled by default.

ok djm@@
@
text
@d771 1
a771 3
		 * which will now be aborted. (A full SSL_clear would be too much.)
		 * I hope that tmp.dh is the only thing that may need to be cleared
		 * when a handshake is not completed ... */
d779 7
a1498 1
				DH_free(dh);
a1558 1
				EC_KEY_free(s->s3->tmp.ecdh); 
d1569 1
a1569 1
			if (!EC_KEY_up_ref(ecdhp))
a1573 1
			ecdh = ecdhp;
d1736 1
d2446 6
d2596 1
a2596 1
			EVP_PKEY *client_pub_pkey = NULL;
d2598 2
a2599 1
			size_t outlen=32, inlen;			
d2602 7
a2608 1
			pkey_ctx = EVP_PKEY_CTX_new(s->cert->key->privatekey,NULL);	
@


1.25
log
@resolve conflicts, fix local changes
@
text
@d988 4
d1006 1
@


1.24
log
@pull Ben Lauries blind prefix injection fix for CVE-2009-3555 from
openssl 0.9.8l; crank minor version; ok djm@@ deraadt@@; initially from jsg@@
@
text
@d1 1
a1 1
/* ssl/s3_srvr.c */
d59 1
a59 1
 * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
d124 26
d172 1
a172 4
static SSL_METHOD *ssl3_get_server_method(int ver);
#ifndef OPENSSL_NO_ECDH
static int nid2curve_id(int nid);
#endif
d174 1
a174 1
static SSL_METHOD *ssl3_get_server_method(int ver)
d190 1
a190 1
	unsigned long l,Time=(unsigned long)time(NULL);
a191 1
	long num1;
d273 12
d318 1
d347 5
a351 3
			/* Check if it is anon DH or anon ECDH or KRB5 */
			if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithms & SSL_aKRB5))
d378 1
a378 1
			l=s->s3->tmp.new_cipher->algorithms;
d384 1
a384 1
				&& !(l & SSL_KRB5)
d399 2
d404 1
a404 1
			 * server certificate contains the server's 
d408 8
a415 3
			    || (l & SSL_kECDHE)
			    || (l & (SSL_DH|SSL_kFZA))
			    || ((l & SSL_kRSA)
d445 1
a445 1
				((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) &&
d449 5
a453 2
                                 /* never request cert in Kerberos ciphersuites */
                                (s->s3->tmp.new_cipher->algorithms & SSL_aKRB5))
d485 16
a500 8
			/* number of bytes to be flushed */
			num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);
			if (num1 > 0)
				{
				s->rwstate=SSL_WRITING;
				num1=BIO_flush(s->wbio);
				if (num1 <= 0) { ret= -1; goto end; }
				s->rwstate=SSL_NOTHING;
d502 1
d529 1
a529 1
			if (ret <= 0) 
d537 3
d544 1
a544 1
			else   
d546 3
d554 20
a573 7
				 */ 
				s->method->ssl3_enc->cert_verify_mac(s,
				    &(s->s3->finish_dgst1),
				    &(s->s3->tmp.cert_verify_md[0]));
				s->method->ssl3_enc->cert_verify_mac(s,
				    &(s->s3->finish_dgst2),
				    &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
d593 6
a600 3
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
a798 8
	if (s->new_session
	    && !(s->s3->flags&SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
		{
		al=SSL_AD_HANDSHAKE_FAILURE;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
		goto f_err;
		}

d830 1
a830 1
		if ((s->client_version>>8) == SSL3_VERSION_MAJOR) 
d839 15
d893 1
a893 1
	if (s->version == DTLS1_VERSION)
a897 12
		if ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&
			s->d1->send_cookie == 0)
			{
			/* HelloVerifyMessage has already been sent */
			if ( cookie_len != s->d1->cookie_len)
				{
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
				goto f_err;
				}
			}

d912 1
a912 1
		if ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&
d937 2
d1038 1
a1038 1
	if (s->version > SSL3_VERSION)
d1051 53
d1105 1
d1111 44
a1154 1
	if (s->ctx->comp_methods != NULL)
d1178 5
a1182 7
#endif

	/* TLS does not mind if there is extra stuff */
#if 0   /* SSL 3.0 does not mind either, so we should disable this test
         * (was enabled in 0.9.6d through 0.9.6j and 0.9.7 through 0.9.7b,
         * in earlier SSLeay/OpenSSL releases this test existed but was buggy) */
	if (s->version == SSL3_VERSION)
d1184 3
a1186 8
		if (p < (d+n))
			{
			/* wrong number of bytes,
			 * there could be more to follow */
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);
			goto f_err;
			}
d1235 1
a1235 1
				if (c->algorithms & SSL_eNULL)
d1251 3
d1266 1
a1266 1
	ret=1;
d1282 4
a1285 1
	unsigned long l,Time;
d1290 1
d1292 1
d1297 1
d1351 5
d1435 1
a1435 1
		type=s->s3->tmp.new_cipher->algorithms & SSL_MKEY_MASK;
d1530 1
a1530 1
			if (type & SSL_kECDHE)
d1600 1
a1600 1
			    nid2curve_id(EC_GROUP_get_curve_name(group)))
d1657 8
d1676 2
a1677 1
		if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))
d1709 1
a1709 1
		if (type & SSL_kECDHE) 
d1733 10
a1754 2
					EVP_MD_CTX_set_flags(&md_ctx,
						EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d1938 1
a1938 1
	unsigned long l;
d1949 1
a1949 1
        KSSL_ERR kssl_err;
d1969 1
a1969 1
	l=s->s3->tmp.new_cipher->algorithms;
d1972 1
a1972 1
	if (l & SSL_kRSA)
d2003 2
a2004 3
		/* TLS and [incidentally] DTLS, including pre-0.9.8f */
		if (s->version > SSL3_VERSION &&
		    s->client_version != DTLS1_BAD_VER)
d2078 1
a2078 1
		if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
d2141 3
a2143 3
        if (l & SSL_kKRB5)
                {
                krb5_error_code		krb5rc;
d2147 1
a2147 1
                KSSL_CTX		*kssl_ctx = s->kssl_ctx;
d2149 1
a2149 1
		EVP_CIPHER		*enc = NULL;
d2152 2
a2153 2
                                               + EVP_MAX_BLOCK_LENGTH];
		int                     padl, outl;
d2159 1
a2159 1
                if (!kssl_ctx)  kssl_ctx = kssl_ctx_new();
d2164 1
a2164 1
		if (n < (int)enc_ticket.length + 6)
d2177 1
a2177 1
		if (n < (int)(enc_ticket.length + authenticator.length) + 6)
d2210 1
a2210 1
                if ((krb5rc = kssl_sget_tkt(kssl_ctx, &enc_ticket, &ttimes,
d2212 1
a2212 1
                        {
d2214 4
a2217 4
                        printf("kssl_sget_tkt rtn %d [%d]\n",
                                krb5rc, kssl_err.reason);
                        if (kssl_err.text)
                                printf("kssl_err text= %s\n", kssl_err.text);
d2219 4
a2222 4
                        SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
                                kssl_err.reason);
                        goto err;
                        }
d2231 4
a2234 4
                        printf("kssl_check_authent rtn %d [%d]\n",
                                krb5rc, kssl_err.reason);
                        if (kssl_err.text)
                                printf("kssl_err text= %s\n", kssl_err.text);
d2236 3
a2238 3
                        SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
                                kssl_err.reason);
                        goto err;
d2244 1
a2244 1
                        goto err;
d2248 1
a2248 1
                kssl_ctx_show(kssl_ctx);
d2252 2
a2253 2
                if (enc == NULL)
                    goto err;
d2300 1
a2300 1
		        {
d2309 13
a2321 13
                s->session->master_key_length=
                        s->method->ssl3_enc->generate_master_secret(s,
                                s->session->master_key, pms, outl);

                if (kssl_ctx->client_princ)
                        {
                        size_t len = strlen(kssl_ctx->client_princ);
                        if ( len < SSL_MAX_KRB5_PRINCIPAL_LENGTH ) 
                                {
                                s->session->krb5_client_princ_len = len;
                                memcpy(s->session->krb5_client_princ,kssl_ctx->client_princ,len);
                                }
                        }
d2324 1
a2324 1
                /*  Was doing kssl_ctx_free() here,
d2326 4
a2329 4
                **  kssl_ctx = kssl_ctx_free(kssl_ctx);
                **  if (s->kssl_ctx)  s->kssl_ctx = NULL;
                */
                }
d2334 1
a2334 1
		if ((l & SSL_kECDH) || (l & SSL_kECDHE))
d2342 1
a2342 1
                /* initialize structures for server's ECDH key pair */
d2345 1
a2345 1
                	SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
d2347 1
a2347 1
                	goto err;
d2351 1
a2351 1
		if (l & SSL_kECDH) 
d2353 1
a2353 1
                        /* use the certificate */
d2383 2
a2384 2
                if (n == 0L) 
                        {
d2387 1
a2387 1
			 if (l & SSL_kECDHE) 
d2393 1
a2393 1
                        if (((clnt_pub_pkey=X509_get_pubkey(s->session->peer))
d2396 1
a2396 1
                        	{
d2408 2
a2409 2
                           	al=SSL_AD_HANDSHAKE_FAILURE;
                           	SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
d2411 2
a2412 2
                           	goto f_err;
                           	}
d2421 4
a2424 4
                        ret = 2; /* Skip certificate verify processing */
                        }
                else
                        {
d2435 2
a2436 2
                        /* Get encoded point length */
                        i = *p; 
d2438 1
a2438 1
                        if (EC_POINT_oct2point(group, 
d2445 5
a2449 5
                        /* p is pointing to somewhere in the buffer
                         * currently, so set it to the start 
                         */ 
                        p=(unsigned char *)s->init_buf->data;
                        }
d2460 3
a2462 3
                if (i <= 0)
                        {
                        SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
d2464 2
a2465 2
                        goto err;
                        }
d2469 1
a2469 2
		if (srvr_ecdh != NULL) 
			EC_KEY_free(srvr_ecdh);
d2471 2
d2475 1
a2475 1
                s->session->master_key_length = s->method->ssl3_enc-> \
d2478 2
a2479 2
                OPENSSL_cleanse(p, i);
                return (ret);
d2483 161
d2733 19
a2751 9
	n2s(p,i);
	n-=2;
	if (i > n)
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
		al=SSL_AD_DECODE_ERROR;
		goto f_err;
		}

d2814 22
d3018 1
a3018 5
		if (x == NULL &&
                        /* VRS: allow null cert if auth == KRB5 */
                        (s->s3->tmp.new_cipher->algorithms
                                & (SSL_MKEY_MASK|SSL_AUTH_MASK))
                        != (SSL_aKRB5|SSL_kKRB5))
d3020 7
a3026 2
			SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,ERR_R_INTERNAL_ERROR);
			return(0);
a3037 64


#ifndef OPENSSL_NO_ECDH
/* This is the complement of curve_id2nid in s3_clnt.c. */
static int nid2curve_id(int nid)
{
	/* ECC curves from draft-ietf-tls-ecc-01.txt (Mar 15, 2001)
	 * (no changes in draft-ietf-tls-ecc-03.txt [June 2003]) */
	switch (nid) {
	case NID_sect163k1: /* sect163k1 (1) */
		return 1;
	case NID_sect163r1: /* sect163r1 (2) */
		return 2;
	case NID_sect163r2: /* sect163r2 (3) */
		return 3;
	case NID_sect193r1: /* sect193r1 (4) */ 
		return 4;
	case NID_sect193r2: /* sect193r2 (5) */ 
		return 5;
	case NID_sect233k1: /* sect233k1 (6) */
		return 6;
	case NID_sect233r1: /* sect233r1 (7) */ 
		return 7;
	case NID_sect239k1: /* sect239k1 (8) */ 
		return 8;
	case NID_sect283k1: /* sect283k1 (9) */
		return 9;
	case NID_sect283r1: /* sect283r1 (10) */ 
		return 10;
	case NID_sect409k1: /* sect409k1 (11) */ 
		return 11;
	case NID_sect409r1: /* sect409r1 (12) */
		return 12;
	case NID_sect571k1: /* sect571k1 (13) */ 
		return 13;
	case NID_sect571r1: /* sect571r1 (14) */ 
		return 14;
	case NID_secp160k1: /* secp160k1 (15) */
		return 15;
	case NID_secp160r1: /* secp160r1 (16) */ 
		return 16;
	case NID_secp160r2: /* secp160r2 (17) */ 
		return 17;
	case NID_secp192k1: /* secp192k1 (18) */
		return 18;
	case NID_X9_62_prime192v1: /* secp192r1 (19) */ 
		return 19;
	case NID_secp224k1: /* secp224k1 (20) */ 
		return 20;
	case NID_secp224r1: /* secp224r1 (21) */
		return 21;
	case NID_secp256k1: /* secp256k1 (22) */ 
		return 22;
	case NID_X9_62_prime256v1: /* secp256r1 (23) */ 
		return 23;
	case NID_secp384r1: /* secp384r1 (24) */
		return 24;
	case NID_secp521r1:  /* secp521r1 (25) */	
		return 25;
	default:
		return 0;
	}
}
#endif
d3048 1
d3087 1
a3087 1
		if (s->ctx->tlsext_ticket_key_cb)
d3089 1
a3089 1
			if (s->ctx->tlsext_ticket_key_cb(s, key_name, iv, &ctx,
d3100 2
a3101 2
					s->ctx->tlsext_tick_aes_key, iv);
			HMAC_Init_ex(&hctx, s->ctx->tlsext_tick_hmac_key, 16,
d3103 1
a3103 1
			memcpy(key_name, s->ctx->tlsext_tick_key_name, 16);
@


1.24.2.1
log
@Security fix for CVE-2010-4180 as mentioned in http://www.openssl.org/news/secadv_20101202.txt.
where clients could modify the stored session
cache ciphersuite and in some cases even downgrade the suite to weaker ones.

This code is not enabled by default.

ok djm@@
@
text
@a912 4
/* Disabled because it can be used in a ciphersuite downgrade
 * attack: CVE-2010-4180.
 */
#if 0
a926 1
#endif
@


1.24.4.1
log
@Security fix for CVE-2010-4180 as mentioned in http://www.openssl.org/news/secadv_20101202.txt.
where clients could modify the stored session
cache ciphersuite and in some cases even downgrade the suite to weaker ones.

This code is not enabled by default.

ok djm@@
@
text
@a912 4
/* Disabled because it can be used in a ciphersuite downgrade
 * attack: CVE-2010-4180.
 */
#if 0
a926 1
#endif
@


1.23
log
@resolve conflicts
@
text
@d721 8
@


1.23.6.1
log
@Pull Ben Lauries blind prefix injection fix for CVE-2009-3555 from
openssl 0.9.8l.

As suggested by markus@@, for -stable the header change is being
restricted to a private file, so the minor version is not cranked here.

Discussed with markus, djm, deraadt.
@
text
@a720 8
	if (s->new_session
	    && !(s->s3->flags&SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
		{
		al=SSL_AD_HANDSHAKE_FAILURE;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
		goto f_err;
		}

@


1.23.2.1
log
@Pull Ben Lauries blind prefix injection fix for CVE-2009-3555 from
openssl 0.9.8l.

As suggested by markus@@, for -stable the header change is being
restricted to a private file, so the minor version is not cranked here.

Discussed with markus, djm, deraadt.
@
text
@a720 8
	if (s->new_session
	    && !(s->s3->flags&SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
		{
		al=SSL_AD_HANDSHAKE_FAILURE;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
		goto f_err;
		}

@


1.22
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d905 1
a905 1
		if (j == 0)
d907 7
a913 1
			if ((s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_SSL_CIPHER_num(ciphers) == 1))
d915 2
a916 10
				/* Very bad for multi-threading.... */
				s->session->cipher=sk_SSL_CIPHER_value(ciphers, 0);
				}
			else
				{
				/* we need to have the cipher in the cipher
				 * list if we are asked to reuse it */
				al=SSL_AD_ILLEGAL_PARAMETER;
				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_REQUIRED_CIPHER_MISSING);
				goto f_err;
d918 8
d2569 1
a2569 1
		if (!i)
@


1.21
log
@resolve conflicts
@
text
@d1175 1
a1175 1
		s->state=SSL3_ST_CW_CLNT_HELLO_B;
d1181 1
a1181 1
	/* SSL3_ST_CW_CLNT_HELLO_B */
d1205 1
a1205 1
	/* SSL3_ST_CW_CLNT_HELLO_B */
d1543 2
@


1.20
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
d111 13
a127 1

d135 1
d137 4
a144 1
#include <openssl/fips.h>
d147 3
a149 10
static int ssl3_get_client_hello(SSL *s);
static int ssl3_check_client_hello(SSL *s);
static int ssl3_send_server_hello(SSL *s);
static int ssl3_send_server_key_exchange(SSL *s);
static int ssl3_send_certificate_request(SSL *s);
static int ssl3_send_server_done(SSL *s);
static int ssl3_get_client_key_exchange(SSL *s);
static int ssl3_get_client_certificate(SSL *s);
static int ssl3_get_cert_verify(SSL *s);
static int ssl3_send_hello_request(SSL *s);
d159 4
a162 22
SSL_METHOD *SSLv3_server_method(void)
	{
	static int init=1;
	static SSL_METHOD SSLv3_server_data;

	if (init)
		{
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);

		if (init)
			{
			memcpy((char *)&SSLv3_server_data,(char *)sslv3_base_method(),
				sizeof(SSL_METHOD));
			SSLv3_server_data.ssl_accept=ssl3_accept;
			SSLv3_server_data.get_ssl_method=ssl3_get_server_method;
			init=0;
			}
			
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);
		}
	return(&SSLv3_server_data);
	}
d293 9
a301 1

d303 2
a304 1
				s->state=SSL3_ST_SW_CHANGE_A;
d312 3
a314 2
			/* Check if it is anon DH */
			if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))
d318 12
d333 1
d335 1
d358 1
d360 8
a367 1
			 * RSA but we have a sign only certificate */
d369 1
d473 16
a488 12
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SR_CERT_VRFY_A;
			s->init_num=0;

			/* We need to get hashes here so if there is
			 * a client cert, it can be verified */ 
			s->method->ssl3_enc->cert_verify_mac(s,
				&(s->s3->finish_dgst1),
				&(s->s3->tmp.cert_verify_md[0]));
			s->method->ssl3_enc->cert_verify_mac(s,
				&(s->s3->finish_dgst2),
				&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
d490 10
d520 4
d529 19
d653 1
a653 1
static int ssl3_send_hello_request(SSL *s)
d675 1
a675 1
static int ssl3_check_client_hello(SSL *s)
d682 1
a682 1
	n=ssl3_get_message(s,
d708 1
a708 1
static int ssl3_get_client_hello(SSL *s)
d711 1
d716 1
d718 1
a728 1
		s->first_packet=1;
d731 2
a732 1
	n=ssl3_get_message(s,
d740 1
d748 2
a749 1
	if (s->client_version < s->version)
d777 1
a777 1
	if (j == 0 || (s->new_session && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION)))
d784 1
a784 1
		i=ssl_get_prev_session(s,p,j);
d799 62
d910 1
a910 2
				s->session->cipher=sk_SSL_CIPHER_value(ciphers,
								       0);
d947 16
d967 1
d992 1
d1016 3
d1020 1
d1095 1
a1095 1
static int ssl3_send_server_hello(SSL *s)
d1108 1
a1108 1
		if(RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
d1127 7
d1135 2
a1136 1
		if (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER))
d1140 1
a1140 1
		if (sl > sizeof s->session->session_id)
d1154 3
d1161 8
a1168 1

d1185 1
a1185 1
static int ssl3_send_server_done(SSL *s)
d1209 1
a1209 1
static int ssl3_send_server_key_exchange(SSL *s)
d1221 7
d1336 128
d1506 25
a1542 2
					EVP_MD_CTX_set_flags(&md_ctx,
						EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d1583 19
d1625 4
d1633 1
a1633 1
static int ssl3_send_certificate_request(SSL *s)
d1722 1
a1722 1
static int ssl3_get_client_key_exchange(SSL *s)
d1740 8
a1747 1
	n=ssl3_get_message(s,
d1791 3
a1793 2
		/* TLS */
		if (s->version > SSL3_VERSION)
d1854 1
a1854 1
			if(RAND_pseudo_bytes(p+2, i-2) <= 0)  /* should be RAND_bytes, but we cannot work around a failure */
d1953 1
a1953 1
		if (n < (long)enc_ticket.length + 6)
d1966 1
a1966 1
		if (n < (long)(enc_ticket.length + authenticator.length + 6))
d2008 1
a2008 1
                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
d2025 1
a2025 1
                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
d2032 1
a2032 1
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, krb5rc);
d2078 18
d2104 1
a2104 1
                        int len = strlen(kssl_ctx->client_princ);
d2121 150
d2281 1
a2281 1
#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA)
d2284 7
d2294 1
a2294 1
static int ssl3_get_cert_verify(SSL *s)
d2303 1
a2303 1
	n=ssl3_get_message(s,
d2414 17
d2449 1
a2449 1
static int ssl3_get_client_certificate(SSL *s)
d2454 2
a2455 1
	unsigned char *p,*d,*q;
d2458 1
a2458 1
	n=ssl3_get_message(s,
d2493 1
a2493 1
	d=p=(unsigned char *)s->init_msg;
d2632 206
@


1.20.8.1
log
@Fix CVE-2008-5077: Incorrect checks for malformed signatures
@
text
@d2012 1
a2012 1
		if (i <= 0)
@


1.20.10.1
log
@Fix CVE-2008-5077: Incorrect checks for malformed signatures
@
text
@d2012 1
a2012 1
		if (i <= 0)
@


1.19
log
@resolve conflicts
@
text
@d176 1
a176 1
	unsigned long l,Time=time(NULL);
d957 1
a957 1
		Time=time(NULL);			/* Time */
@


1.18
log
@out-of-bounds read in (unused) kerberos ciphersuites (CAN-2004-0112)
@
text
@d128 1
d959 2
a960 1
		RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));
d1216 2
d1498 2
a1499 1
			RAND_pseudo_bytes(p+2, i-2); /* should be RAND_bytes, but we cannot work around a failure */
d1597 1
a1597 1
		if (n < enc_ticket.length + 6)
d1610 1
a1610 1
		if (n < enc_ticket.length + authenticator.length + 6)
d1635 2
a1636 2
		if (n != enc_ticket.length + authenticator.length +
						enc_pms.length + 6)
@


1.17
log
@more fixes from 0.9.7c, ok deraadt, cloder
@
text
@d1591 8
d1604 8
@


1.16
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d435 5
a439 4
				/* could be sent for a DH cert, even if we
				 * have not asked for it :-) */
				ret=ssl3_get_client_certificate(s);
				if (ret <= 0) goto end;
d849 3
d863 1
d1361 1
@


1.16.2.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@d435 4
a438 5
				if (s->s3->tmp.cert_request)
					{
					ret=ssl3_get_client_certificate(s);
					if (ret <= 0) goto end;
					}
a847 3
#if 0   /* SSL 3.0 does not mind either, so we should disable this test
         * (was enabled in 0.9.6d through 0.9.6j and 0.9.7 through 0.9.7b,
         * in earlier SSLeay/OpenSSL releases this test existed but was buggy) */
a858 1
#endif
a1355 1
		s->state = SSL3_ST_SW_CERT_REQ_B;
@


1.15
log
@Fix for Klima-Pokorny-Rosa attack on RSA in SSL/TLS, see
http://marc.theaimsgroup.com/?l=bugtraq&m=104811162730834&w=2
@
text
@d156 12
a167 5
		memcpy((char *)&SSLv3_server_data,(char *)sslv3_base_method(),
			sizeof(SSL_METHOD));
		SSLv3_server_data.ssl_accept=ssl3_accept;
		SSLv3_server_data.get_ssl_method=ssl3_get_server_method;
		init=0;
d1182 1
a1182 1
		if (!BUF_MEM_grow(buf,n+4+kn))
d1309 1
a1309 1
				if (!BUF_MEM_grow(buf,4+n+j+2))
a1475 1
				p[0] = (char)(int) "CAN-2003-0131 patch 2003-03-20";
d1495 1
a1495 1
		memset(p,0,i);
d1558 1
a1558 1
		memset(p,0,i);
d1661 1
a1661 1
		memset(iv, 0, EVP_MAX_IV_LENGTH);	/* per RFC 1510 */
d1749 1
a1749 1
		512, /* 512? */
@


1.15.2.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@d428 4
a431 5
				if (s->s3->tmp.cert_request)
					{
					ret=ssl3_get_client_certificate(s);
					if (ret <= 0) goto end;
					}
a840 3
#if 0   /* SSL 3.0 does not mind either, so we should disable this test
         * (was enabled in 0.9.6d through 0.9.6j and 0.9.7 through 0.9.7b,
         * in earlier SSLeay/OpenSSL releases this test existed but was buggy) */
a851 1
#endif
a1348 1
		s->state = SSL3_ST_SW_CERT_REQ_B;
@


1.14
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d1444 1
a1444 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);
d1460 10
a1469 2
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER);
				goto f_err;
a1474 3
#if 0
			goto f_err;
#else
d1477 1
a1477 6
			 * (see RFC 2246, section 7.4.7.1).
			 * But note that due to length and protocol version checking, the
			 * attack is impractical anyway (see section 5 in D. Bleichenbacher:
			 * "Chosen Ciphertext Attacks Against Protocols Based on the RSA
			 * Encryption Standard PKCS #1", CRYPTO '98, LNCS 1462, pp. 1-12).
			 */
a1482 1
#endif
@


1.14.2.1
log
@Errata #11 (markus):
Fix for Klima-Pokorny-Rosa attack on RSA in SSL/TLS
@
text
@d1444 1
a1444 1
			/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT); */
d1460 2
a1461 10
				/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER); */

				/* The Klima-Pokorny-Rosa extension of Bleichenbacher's attack
				 * (http://eprint.iacr.org/2003/052/) exploits the version
				 * number check as a "bad version oracle" -- an alert would
				 * reveal that the plaintext corresponding to some ciphertext
				 * made up by the adversary is properly formatted except
				 * that the version number is wrong.  To avoid such attacks,
				 * we should treat this just like any other decryption error. */
				p[0] = (char)(int) "CAN-2003-0131 patch 2003-03-20";
d1467 3
d1472 6
a1477 1
			 * (see RFC 2246, section 7.4.7.1). */
d1483 1
@


1.14.2.2
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@d428 4
a431 5
				if (s->s3->tmp.cert_request)
					{
					ret=ssl3_get_client_certificate(s);
					if (ret <= 0) goto end;
					}
a840 3
#if 0   /* SSL 3.0 does not mind either, so we should disable this test
         * (was enabled in 0.9.6d through 0.9.6j and 0.9.7 through 0.9.7b,
         * in earlier SSLeay/OpenSSL releases this test existed but was buggy) */
a851 1
#endif
a1348 1
		s->state = SSL3_ST_SW_CERT_REQ_B;
@


1.13
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d969 5
a973 1
		die(sl <= sizeof s->session->session_id);
@


1.12
log
@merge with 0.9.7-beta1
@
text
@d117 2
a125 1
#include "kssl_lcl.h"
a127 1
#include "ssl_locl.h"
@


1.11
log
@protect <openssl/krb5_asn.h> with OPENSSL_NO_KRB5
@
text
@a116 2
#include "ssl_locl.h"
#include "kssl_lcl.h"
d124 1
d127 1
@


1.10
log
@sync with http://www.openssl.org/news/patch_20020730_0_9_7.txt
(adds fix for unused kerberos and engine code, and some more
assertions, as well as a 64bit integer string fix for conf_mod.c)
@
text
@d124 1
d126 1
@


1.9
log
@apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@d117 2
a124 2
#include "ssl_locl.h"
#include "kssl_lcl.h"
d1563 2
a1564 2
						+ EVP_MAX_IV_LENGTH + 1];
		int 			padl, outl = sizeof(pms);
d1586 10
@


1.8
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d967 1
@


1.7
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d58 53
a119 2
#include <openssl/md5.h>
#include <openssl/sha.h>
d122 1
d124 2
d167 1
a167 1
	void (*cb)()=NULL;
d182 1
a183 1
	s->in_handshake++;
d211 1
a211 1
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_INTERNAL_ERROR);
a236 5
			/* Ok, we now need to push on a buffering BIO so that
			 * the output is sent in a way that TCP likes :-)
			 */
			if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }

d241 5
d252 2
d274 1
a274 3
			ret=1;
			goto end;
			/* break; */
d283 1
d320 9
a328 1
			if (s->options & SSL_OP_EPHEMERAL_RSA)
d370 3
a372 1
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)))
a523 1
			s->new_session=0;
d526 12
a537 8
			ssl_update_cache(s,SSL_SESS_CACHE_SERVER);

			s->ctx->stats.sess_accept_good++;
			/* s->server=1; */
			s->handshake_func=ssl3_accept;
			ret=1;

			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
d539 4
d575 1
a577 1
	s->in_handshake--;
d608 2
d614 1
a614 1
		SSL3_RT_MAX_PLAIN_LENGTH,
d624 1
a624 1
#ifndef NO_DH
d665 1
a665 1
	d=p=(unsigned char *)s->init_buf->data;
d672 12
d692 9
a700 1
	if (j == 0)
d730 1
a730 1
	if ((i+p) > (d+n))
d787 7
d841 1
a841 1
		if (p > (d+n))
d851 1
a851 1
	/* Given s->session->ciphers and ssl_get_ciphers_by_id(s), we must
d868 1
a868 1
				     ssl_get_ciphers_by_id(s));
d1023 1
a1023 1
#ifndef NO_RSA
d1030 1
a1030 1
#ifndef NO_DH
d1044 1
d1054 1
a1054 1
#ifndef NO_RSA
d1069 1
a1069 1
				CRYPTO_add(&rsa->references,1,CRYPTO_LOCK_RSA);
d1084 1
a1084 1
#ifndef NO_DH
d1102 1
a1102 1
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, SSL_R_INTERNAL_ERROR);
d1188 1
a1188 1
#ifndef NO_RSA
d1195 2
a1196 2
					EVP_DigestInit(&md_ctx,(num == 2)
						?s->ctx->md5:s->ctx->sha1);
d1200 1
a1200 1
					EVP_DigestFinal(&md_ctx,q,
d1216 1
a1216 1
#if !defined(NO_DSA)
d1220 1
a1220 1
				EVP_SignInit(&md_ctx,EVP_dss1());
d1253 1
d1258 1
d1356 1
a1356 1
#ifndef NO_RSA
d1360 1
a1360 1
#ifndef NO_DH
d1364 3
d1372 1
a1372 1
		400, /* ???? */
d1376 1
a1376 1
	p=(unsigned char *)s->init_buf->data;
d1380 1
a1380 1
#ifndef NO_RSA
d1487 1
a1487 1
#ifndef NO_DH
d1550 148
d1700 2
a1701 1
		SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_UNKNOWN_CIPHER_TYPE);
d1708 1
a1708 1
#if !defined(NO_DH) || !defined(NO_RSA)
d1779 1
a1779 1
	p=(unsigned char *)s->init_buf->data;
d1797 1
a1797 1
#ifndef NO_RSA 
d1818 1
a1818 1
#ifndef NO_DSA
d1835 1
a1835 1
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_INTERNAL_ERROR);
d1864 1
a1864 5
#if defined(MSDOS) && !defined(WIN32)
		1024*30, /* 30k max cert list :-) */
#else
		1024*100, /* 100k max cert list :-) */
#endif
d1895 1
a1895 1
	d=p=(unsigned char *)s->init_buf->data;
d2015 5
a2019 1
		if (x == NULL)
d2021 1
a2021 1
			SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,SSL_R_INTERNAL_ERROR);
@


1.7.4.1
log
@Pull in patch from current:
Fix (markus), errata 013:
apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@a71 1
#include "ssl_locl.h"
a865 1
		die(sl <= sizeof s->session->session_id);
@


1.7.4.2
log
@Errata #025 (markus):
Fix for Klima-Pokorny-Rosa attack on RSA in SSL/TLS
@
text
@d72 1
d1332 1
a1332 1
			/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT); */
d1348 2
a1349 10
				/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER); */

				/* The Klima-Pokorny-Rosa extension of Bleichenbacher's attack
				 * (http://eprint.iacr.org/2003/052/) exploits the version
				 * number check as a "bad version oracle" -- an alert would
				 * reveal that the plaintext corresponding to some ciphertext
				 * made up by the adversary is properly formatted except
				 * that the version number is wrong.  To avoid such attacks,
				 * we should treat this just like any other decryption error. */
				p[0] = (char)(int) "CAN-2003-0131 patch 2003-03-20";
d1355 3
d1360 6
a1365 1
			 * (see RFC 2246, section 7.4.7.1). */
d1371 1
@


1.7.2.1
log
@Errata #030 (markus):
Fixes for the "OpenSSL Security Advisory [30 July 2002]"
@
text
@a71 1
#include "ssl_locl.h"
a865 1
		die(sl <= sizeof s->session->session_id);
@


1.6
log
@CRT and DH+SSL fix from 0.9.6a, ok provos@@/deraadt@@
@
text
@d1325 2
a1330 1
			goto f_err;
d1333 1
a1333 1
		if (!((p[0] == (s->client_version>>8)) && (p[1] == (s->client_version & 0xff))))
d1351 21
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d1417 1
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d156 4
a159 1
				abort();
d988 1
a988 1
				      !SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
d1332 1
a1332 1
		if ((p[0] != (s->client_version>>8)) || (p[1] != (s->client_version & 0xff)))
d1334 14
a1347 3
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER);
			goto f_err;
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d1701 2
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d60 2
d75 1
a79 1
static int ssl3_get_cert_verify(SSL *s);
d82 1
d118 1
a118 1
	RAND_seed(&Time,sizeof(Time));
a156 1
			/* s->version=SSL3_VERSION; */
d189 1
a190 1
				ssl3_init_finished_mac(s);
d273 2
a274 2
				    || (SSL_IS_EXPORT(l)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_EXPORT_PKEYLENGTH(l)
d292 4
a295 1
			if (!(s->verify_mode & SSL_VERIFY_PEER) ||
d297 8
a304 1
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)))
d316 1
d318 4
d351 14
a364 6
			/* could be sent for a DH cert, even if we
			 * have not asked for it :-) */
			ret=ssl3_get_client_certificate(s);
			if (ret <= 0) goto end;
			s->init_num=0;
			s->state=SSL3_ST_SR_KEY_EXCH_A;
d378 1
a378 1
				&(s->s3->tmp.finish_md[0]));
d381 1
a381 1
				&(s->s3->tmp.finish_md[MD5_DIGEST_LENGTH]));
d435 2
a436 2
				s->method->ssl3_enc->server_finished,
				s->method->ssl3_enc->server_finished_len);
d513 1
a513 1
		*(p++)=SSL3_MT_CLIENT_REQUEST;
d528 31
d590 3
a592 4
	/* The version number has already been checked in ssl3_get_message.
	 * I a native TLSv1/SSLv3 method, the match must be correct except
	 * perhaps for the first message */
/*	s->client_version=(((int)p[0])<<8)|(int)p[1]; */
d812 1
a812 1
	 * s->hit		- sesson reuse flag
d840 1
a840 1
		RAND_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));
d924 1
d927 1
a927 1
	DH *dh,*dhp;
d958 6
d993 8
d1100 2
a1101 3
				i=RSA_private_encrypt(j,md_buf,&(p[2]),
					pkey->pkey.rsa,RSA_PKCS1_PADDING);
				if (i <= 0)
d1106 2
a1107 2
				s2n(i,p);
				n+=i+2;
d1147 1
a1147 1
	/* SSL3_ST_SW_KEY_EXCH_B */
d1224 11
a1321 25
#if 1
		/* If a bad decrypt, use a random master key */
		if ((i != SSL_MAX_MASTER_KEY_LENGTH) ||
			((p[0] != (s->client_version>>8)) ||
			 (p[1] != (s->client_version & 0xff))))
			{
			int bad=1;

			if ((i == SSL_MAX_MASTER_KEY_LENGTH) &&
				(p[0] == (s->version>>8)) &&
				(p[1] == 0))
				{
				if (s->options & SSL_OP_TLS_ROLLBACK_BUG)
					bad=0;
				}
			if (bad)
				{
				p[0]=(s->version>>8);
				p[1]=(s->version & 0xff);
				RAND_bytes(&(p[2]),SSL_MAX_MASTER_KEY_LENGTH-2);
				i=SSL_MAX_MASTER_KEY_LENGTH;
				}
			/* else, an SSLeay bug, ssl only server, tls client */
			}
#else
d1329 1
a1329 1
		if ((p[0] != (s->version>>8)) || (p[1] != (s->version & 0xff)))
a1334 1
#endif
d1507 3
a1509 1
		i=RSA_public_decrypt(i,p,p,pkey->pkey.rsa,RSA_PKCS1_PADDING);
d1516 1
a1516 3
		if ((i != (MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH)) ||
			memcmp(&(s->s3->tmp.finish_md[0]),p,
				MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH))
d1529 1
a1529 1
			&(s->s3->tmp.finish_md[MD5_DIGEST_LENGTH]),
d1589 1
a1589 1
		/* If tls asked for a client cert we must return a 0 list */
d1685 1
@


1.1
log
@Initial revision
@
text
@d62 7
a68 5
#include "buffer.h"
#include "rand.h"
#include "objects.h"
#include "evp.h"
#include "x509.h"
d71 1
a71 9
#define BREAK	break
/* SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_MALLOC_FAILURE);
 * SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,ERR_R_MALLOC_FAILURE);
 * SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
 * SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_MALLOC_FAILURE);
 * SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_MALLOC_FAILURE);
 */

#ifndef NOPROTO
d82 1
a82 16
#else

static int ssl3_get_client_hello();
static int ssl3_send_server_hello();
static int ssl3_send_server_key_exchange();
static int ssl3_send_certificate_request();
static int ssl3_send_server_done();
static int ssl3_get_cert_verify();
static int ssl3_get_client_key_exchange();
static int ssl3_get_client_certificate();
static int ssl3_send_hello_request();

#endif

static SSL_METHOD *ssl3_get_server_method(ver)
int ver;
d90 1
a90 1
SSL_METHOD *SSLv3_server_method()
a96 1
		init=0;
d101 1
d106 1
a106 2
int ssl3_accept(s)
SSL *s;
a112 2
	CERT *ct;
	BIO *under;
d115 1
a115 1
	RAND_seed((unsigned char *)&Time,sizeof(Time));
d128 1
a128 5
#ifdef undef
	/* FIX THIS EAY EAY EAY */
	/* we don't actually need a cert, we just need a cert or a DH_tmp */
	if (((s->session == NULL) || (s->session->cert == NULL)) &&
		(s->cert == NULL))
d131 1
a131 2
		ret= -1;
		goto end;
a132 1
#endif
d149 1
d189 1
a189 1
				s->ctx->sess_accept++;
d193 1
a193 1
				s->ctx->sess_accept_renegotiate++;
a211 9
			/* remove buffering on output */
			under=BIO_pop(s->wbio);
			if (under != NULL)
				s->wbio=under;
			else
				abort(); /* ok */
			BIO_free(s->bbio);
			s->bbio=NULL;

a256 14
			if (s->session->cert == NULL)
				{
				if (s->cert != NULL)
					{
					CRYPTO_add(&s->cert->references,1,CRYPTO_LOCK_SSL_CERT);
					s->session->cert=s->cert;
					}
				else
					{
					CRYPTO_add(&s->ctx->default_cert->references,1,CRYPTO_LOCK_SSL_CERT);
					s->session->cert=s->ctx->default_cert;
					}
				}
			ct=s->session->cert;
d267 9
a275 8
			if ( s->s3->tmp.use_rsa_tmp ||
			    (l & (SSL_DH|SSL_kFZA)) ||
			    ((l & SSL_kRSA) &&
			     ((ct->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL)||
			      ((l & SSL_EXPORT) &&
			       (EVP_PKEY_size(ct->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > 512)
			      )
			     )
a276 1
			   )
d429 1
a429 7
			under=BIO_pop(s->wbio);
			if (under != NULL)
				s->wbio=under;
			else
				abort(); /* ok */
			BIO_free(s->bbio);
			s->bbio=NULL;
d436 1
a436 1
			s->ctx->sess_accept_good++;
d481 1
a481 2
static int ssl3_send_hello_request(s)
SSL *s;
d503 1
a503 2
static int ssl3_get_client_hello(s)
SSL *s;
d508 1
a508 1
	unsigned char *p,*d;
d510 2
a511 1
	STACK *ciphers=NULL;
d537 1
d560 3
a562 1
		else
d598 4
a601 1
		for (i=0; i<sk_num(ciphers); i++)
d603 5
a607 1
			c=(SSL_CIPHER *)sk_value(ciphers,i);
d616 1
a616 1
			if ((s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_num(ciphers) == 1))
d619 2
a620 2
				s->session->cipher=
					(SSL_CIPHER *)sk_value(ciphers,0);
d635 1
d637 1
d639 1
d650 29
a691 2
	/* do nothing with compression */

d697 1
d699 1
a699 1
			sk_free(s->session->ciphers);
d709 1
a709 1
			ssl_get_ciphers_by_id(s));
d723 1
a723 1
		STACK *sk;
d730 1
a730 1
			for (i=0; i<sk_num(sk); i++)
d732 1
a732 1
				c=(SSL_CIPHER *)sk_value(sk,i);
d735 1
a735 1
				if (c->algorithms & SSL_EXP)
d768 1
a768 1
	if (ciphers != NULL) sk_free(ciphers);
d772 1
a772 2
static int ssl3_send_server_hello(s)
SSL *s;
d817 4
a820 1
		*(p++)=0;
d838 1
a838 2
static int ssl3_send_server_done(s)
SSL *s;
d862 1
a862 2
static int ssl3_send_server_key_exchange(s)
SSL *s;
d887 1
a887 1
		cert=s->session->cert;
d897 1
a897 1
			if ((rsa == NULL) && (s->ctx->default_cert->rsa_tmp_cb != NULL))
d899 3
a901 3
				rsa=s->ctx->default_cert->rsa_tmp_cb(s,
					(s->s3->tmp.new_cipher->algorithms|
					SSL_NOT_EXP)?0:1);
d921 4
a924 4
			if ((dhp == NULL) && (cert->dh_tmp_cb != NULL))
				dhp=cert->dh_tmp_cb(s,
					(s->s3->tmp.new_cipher->algorithms|
					SSL_NOT_EXP)?0:1);
d938 10
a947 7
			if (((dhp->pub_key == NULL) ||
			     (dhp->priv_key == NULL) ||
			     (s->options & SSL_OP_SINGLE_DH_USE)) &&
			    (!DH_generate_key(dh)))
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);
				goto err;
d1086 1
a1086 2
static int ssl3_send_certificate_request(s)
SSL *s;
d1090 1
a1090 1
	STACK *sk=NULL;
d1115 1
a1115 1
			for (i=0; i<sk_num(sk); i++)
d1117 1
a1117 1
				name=(X509_NAME *)sk_value(sk,i);
d1163 1
a1163 2
static int ssl3_get_client_key_exchange(s)
SSL *s;
d1169 1
d1172 1
d1196 2
a1197 6
			if ((s->session->cert != NULL) &&
				(s->session->cert->rsa_tmp != NULL))
				rsa=s->session->cert->rsa_tmp;
			else if ((s->ctx->default_cert != NULL) &&
				(s->ctx->default_cert->rsa_tmp != NULL))
				rsa=s->ctx->default_cert->rsa_tmp;
d1243 1
a1243 1
		/* If a bad decrypt, use a dud master key */
d1245 2
a1246 2
			((p[0] != (s->version>>8)) ||
			 (p[1] != (s->version & 0xff))))
d1248 17
a1264 4
			p[0]=(s->version>>8);
			p[1]=(s->version & 0xff);
			RAND_bytes(&(p[2]),SSL_MAX_MASTER_KEY_LENGTH-2);
			i=SSL_MAX_MASTER_KEY_LENGTH;
d1367 1
a1367 2
static int ssl3_get_cert_verify(s)
SSL *s;
d1501 1
d1505 1
a1505 2
static int ssl3_get_client_certificate(s)
SSL *s;
d1511 1
a1511 1
	STACK *sk=NULL;
d1554 1
a1554 1
	if ((sk=sk_new_null()) == NULL)
d1590 1
a1590 1
		if (!sk_push(sk,(char *)x))
d1599 1
a1599 1
	if (sk_num(sk) <= 0)
d1628 1
a1628 2
	/* This should not be needed */
	if (s->session->peer != NULL)
d1630 18
a1647 1
	s->session->peer=(X509 *)sk_shift(sk);
d1657 1
a1657 1
	if (sk != NULL) sk_pop_free(sk,X509_free);
d1661 1
a1661 2
int ssl3_send_server_certificate(s)
SSL *s;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
a59 2
#define NETSCAPE_HANG_BUG

d62 5
a66 6
#include <openssl/buffer.h>
#include <openssl/rand.h>
#include <openssl/objects.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/krb5_asn.h>
a67 2
#include "kssl_lcl.h"
#include <openssl/md5.h>
d69 9
a77 1
static SSL_METHOD *ssl3_get_server_method(int ver);
a78 1
static int ssl3_check_client_hello(SSL *s);
d83 1
a85 1
static int ssl3_get_cert_verify(SSL *s);
d88 16
a103 1
static SSL_METHOD *ssl3_get_server_method(int ver)
d111 1
a111 1
SSL_METHOD *SSLv3_server_method(void)
d118 1
a122 1
		init=0;
d127 2
a128 1
int ssl3_accept(SSL *s)
d132 1
a132 1
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
d135 2
d139 1
a139 1
	RAND_add(&Time,sizeof(Time),0);
d149 1
a150 1
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);
d152 5
a156 1
	if (s->cert == NULL)
d159 2
a160 1
		return(-1);
d162 1
a178 1
			s->server=1;
d182 2
a183 4
				{
				SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
				}
d207 5
d216 1
a216 5
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 */
				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
				
d218 1
a218 2
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
d222 1
a222 3
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->stats.sess_accept_renegotiate++;
d241 9
d251 3
a253 1
			break;
a261 1
			s->new_session = 2;
d295 14
d312 1
a312 9
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
#ifndef OPENSSL_NO_KRB5
				&& !(l & SSL_KRB5)
#endif /* OPENSSL_NO_KRB5 */
				)
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
				 * even when forbidden by protocol specs
				 * (handshake may fail as clients are not required to
				 * be able to handle this) */
d319 8
a326 9
			if (s->s3->tmp.use_rsa_tmp
			    || (l & (SSL_DH|SSL_kFZA))
			    || ((l & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
d328 1
d342 1
a342 4
			if (/* don't request cert unless asked for it: */
				!(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
d344 1
a344 10
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section "Certificate request" in SSL 3 drafts
				 * and in RFC 2246): */
				((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
                                 /* never request cert in Kerberos ciphersuites */
                                (s->s3->tmp.new_cipher->algorithms & SSL_aKRB5))
a355 1
#ifndef NETSCAPE_HANG_BUG
a356 4
#else
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
#endif
d386 6
a391 14
			/* Check for second client hello (MS SGC) */
			ret = ssl3_check_client_hello(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				s->state = SSL3_ST_SR_CLNT_HELLO_C;
			else {
				/* could be sent for a DH cert, even if we
				 * have not asked for it :-) */
				ret=ssl3_get_client_certificate(s);
				if (ret <= 0) goto end;
				s->init_num=0;
				s->state=SSL3_ST_SR_KEY_EXCH_A;
			}
d405 1
a405 1
				&(s->s3->tmp.cert_verify_md[0]));
d408 1
a408 1
				&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
d462 2
a463 2
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
d481 7
a487 1
			ssl_free_wbio_buffer(s);
d489 1
d492 8
a499 12
			if (s->new_session == 2) /* skipped if we just sent a HelloRequest */
				{
				/* actually not necessarily a 'new' session unless
				 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
				
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func=ssl3_accept;
a500 4
				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
			ret = 1;
a532 1
	s->in_handshake--;
d535 1
d539 2
a540 1
static int ssl3_send_hello_request(SSL *s)
d547 1
a547 1
		*(p++)=SSL3_MT_HELLO_REQUEST;
d562 2
a563 34
static int ssl3_check_client_hello(SSL *s)
	{
	int ok;
	long n;

	/* this function is called when we really expect a Certificate message,
	 * so permit appropriate message length */
	n=ssl3_get_message(s,
		SSL3_ST_SR_CERT_A,
		SSL3_ST_SR_CERT_B,
		-1,
		s->max_cert_list,
		&ok);
	if (!ok) return((int)n);
	s->s3->tmp.reuse_message = 1;
	if (s->s3->tmp.message_type == SSL3_MT_CLIENT_HELLO)
		{
		/* Throw away what we have done so far in the current handshake,
		 * which will now be aborted. (A full SSL_clear would be too much.)
		 * I hope that tmp.dh is the only thing that may need to be cleared
		 * when a handshake is not completed ... */
#ifndef OPENSSL_NO_DH
		if (s->s3->tmp.dh != NULL)
			{
			DH_free(s->s3->tmp.dh);
			s->s3->tmp.dh = NULL;
			}
#endif
		return 2;
		}
	return 1;
}

static int ssl3_get_client_hello(SSL *s)
d568 1
a568 1
	unsigned char *p,*d,*q;
d570 1
a570 2
	SSL_COMP *comp=NULL;
	STACK_OF(SSL_CIPHER) *ciphers=NULL;
d591 1
a591 1
	d=p=(unsigned char *)s->init_msg;
d593 3
a595 3
	/* use version from inside client hello, not from record header
	 * (may differ: see RFC 2246, Appendix E, second paragraph) */
	s->client_version=(((int)p[0])<<8)|(int)p[1];
a597 12
	if (s->client_version < s->version)
		{
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_WRONG_VERSION_NUMBER);
		if ((s->client_version>>8) == SSL3_VERSION_MAJOR) 
			{
			/* similar to ssl3_get_record, send alert using remote version number */
			s->version = s->client_version;
			}
		al = SSL_AD_PROTOCOL_VERSION;
		goto f_err;
		}

d606 1
a606 9
	/* Versions before 0.9.7 always allow session reuse during renegotiation
	 * (i.e. when s->new_session is true), option
	 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is new with 0.9.7.
	 * Maybe this optional behaviour should always have been the default,
	 * but we cannot safely change the default behaviour (or new applications
	 * might be written that become totally unsecure when compiled with
	 * an earlier library version)
	 */
	if (j == 0 || (s->new_session && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION)))
d618 1
a618 3
		else if (i == -1)
			goto err;
		else /* i == 0 */
d634 1
a634 1
	if ((p+i) >= (d+n))
d654 1
a654 4
#ifdef CIPHER_DEBUG
		printf("client sent %d ciphers\n",sk_num(ciphers));
#endif
		for (i=0; i<sk_SSL_CIPHER_num(ciphers); i++)
d656 1
a656 5
			c=sk_SSL_CIPHER_value(ciphers,i);
#ifdef CIPHER_DEBUG
			printf("client [%2d of %2d]:%s\n",
				i,sk_num(ciphers),SSL_CIPHER_get_name(c));
#endif
d665 1
a665 1
			if ((s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_SSL_CIPHER_num(ciphers) == 1))
d668 2
a669 2
				s->session->cipher=sk_SSL_CIPHER_value(ciphers,
								       0);
a683 8
	if ((p+i) > (d+n))
		{
		/* not enough data */
		al=SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);
		goto f_err;
		}
	q=p;
a684 1
		{
a685 1
		}
a695 29
	/* Worst case, we will use the NULL compression, but if we have other
	 * options, we will now look for them.  We have i-1 compression
	 * algorithms from the client, starting at q. */
	s->s3->tmp.new_compression=NULL;
	if (s->ctx->comp_methods != NULL)
		{ /* See if we have a match */
		int m,nn,o,v,done=0;

		nn=sk_SSL_COMP_num(s->ctx->comp_methods);
		for (m=0; m<nn; m++)
			{
			comp=sk_SSL_COMP_value(s->ctx->comp_methods,m);
			v=comp->id;
			for (o=0; o<i; o++)
				{
				if (v == q[o])
					{
					done=1;
					break;
					}
				}
			if (done) break;
			}
		if (done)
			s->s3->tmp.new_compression=comp;
		else
			comp=NULL;
		}

d699 1
a699 1
		if (p < (d+n))
d709 3
a711 1
	/* Given s->session->ciphers and SSL_get_ciphers, we must
a715 1
		s->session->compress_meth=(comp == NULL)?0:comp->id;
d717 1
a717 1
			sk_SSL_CIPHER_free(s->session->ciphers);
d727 1
a727 1
				     SSL_get_ciphers(s));
d741 1
a741 1
		STACK_OF(SSL_CIPHER) *sk;
d748 1
a748 1
			for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
d750 1
a750 1
				c=sk_SSL_CIPHER_value(sk,i);
d753 1
a753 1
				if (SSL_C_IS_EXPORT(c))
d775 1
a775 1
	 * s->hit		- session reuse flag
d786 1
a786 1
	if (ciphers != NULL) sk_SSL_CIPHER_free(ciphers);
d790 2
a791 1
static int ssl3_send_server_hello(SSL *s)
d804 1
a804 1
		RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));
d836 1
a836 4
		if (s->s3->tmp.new_compression == NULL)
			*(p++)=0;
		else
			*(p++)=s->s3->tmp.new_compression->id;
d854 2
a855 1
static int ssl3_send_server_done(SSL *s)
d879 2
a880 1
static int ssl3_send_server_key_exchange(SSL *s)
d882 1
a882 1
#ifndef OPENSSL_NO_RSA
a886 1
	unsigned int u;
d888 2
a889 2
#ifndef OPENSSL_NO_DH
	DH *dh=NULL,*dhp;
a901 1
	EVP_MD_CTX_init(&md_ctx);
d905 1
a905 1
		cert=s->cert;
d911 1
a911 1
#ifndef OPENSSL_NO_RSA
d915 1
a915 1
			if ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL))
d917 4
a920 10
				rsa=s->cert->rsa_tmp_cb(s,
				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
				if(rsa == NULL)
				{
					al=SSL_AD_HANDSHAKE_FAILURE;
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_ERROR_GENERATING_TMP_RSA_KEY);
					goto f_err;
				}
				RSA_up_ref(rsa);
d935 1
a935 1
#ifndef OPENSSL_NO_DH
d939 4
a942 4
			if ((dhp == NULL) && (s->cert->dh_tmp_cb != NULL))
				dhp=s->cert->dh_tmp_cb(s,
				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
d949 1
a949 2

			if (s->s3->tmp.dh != NULL)
d951 1
a951 2
				DH_free(dh);
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d955 5
a959 1
			if ((dh=DHparams_dup(dhp)) == NULL)
a963 13

			s->s3->tmp.dh=dh;
			if ((dhp->pub_key == NULL ||
			     dhp->priv_key == NULL ||
			     (s->options & SSL_OP_SINGLE_DH_USE)))
				{
				if(!DH_generate_key(dh))
				    {
				    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
					   ERR_R_DH_LIB);
				    goto err;
				    }
				}
d1028 1
a1028 1
#ifndef OPENSSL_NO_RSA
d1035 2
a1036 2
					EVP_DigestInit_ex(&md_ctx,(num == 2)
						?s->ctx->md5:s->ctx->sha1, NULL);
d1040 1
a1040 1
					EVP_DigestFinal_ex(&md_ctx,q,
d1045 3
a1047 2
				if (RSA_sign(NID_md5_sha1, md_buf, j,
					&(p[2]), &u, pkey->pkey.rsa) <= 0)
d1052 2
a1053 2
				s2n(u,p);
				n+=u+2;
d1057 1
a1057 1
#if !defined(OPENSSL_NO_DSA)
d1061 1
a1061 1
				EVP_SignInit_ex(&md_ctx,EVP_dss1(), NULL);
d1093 1
a1093 2
	s->state = SSL3_ST_SW_KEY_EXCH_B;
	EVP_MD_CTX_cleanup(&md_ctx);
a1097 1
	EVP_MD_CTX_cleanup(&md_ctx);
d1101 2
a1102 1
static int ssl3_send_certificate_request(SSL *s)
d1106 1
a1106 1
	STACK_OF(X509_NAME) *sk=NULL;
d1131 1
a1131 1
			for (i=0; i<sk_X509_NAME_num(sk); i++)
d1133 1
a1133 1
				name=sk_X509_NAME_value(sk,i);
a1170 11
#ifdef NETSCAPE_HANG_BUG
		p=(unsigned char *)s->init_buf->data + s->init_num;

		/* do the header */
		*(p++)=SSL3_MT_SERVER_DONE;
		*(p++)=0;
		*(p++)=0;
		*(p++)=0;
		s->init_num += 4;
#endif

d1179 2
a1180 1
static int ssl3_get_client_key_exchange(SSL *s)
a1185 1
#ifndef OPENSSL_NO_RSA
d1188 1
a1188 2
#endif
#ifndef OPENSSL_NO_DH
a1191 3
#ifndef OPENSSL_NO_KRB5
        KSSL_ERR kssl_err;
#endif /* OPENSSL_NO_KRB5 */
d1197 1
a1197 1
		2048, /* ??? */
d1201 1
a1201 1
	p=(unsigned char *)s->init_msg;
d1205 1
a1205 1
#ifndef OPENSSL_NO_RSA
d1211 6
a1216 2
			if ((s->cert != NULL) && (s->cert->rsa_tmp != NULL))
				rsa=s->cert->rsa_tmp;
d1261 12
a1272 2
		al = -1;
		
d1277 1
d1280 1
a1280 1
		if ((al == -1) && !((p[0] == (s->client_version>>8)) && (p[1] == (s->client_version & 0xff))))
d1282 3
a1284 14
			/* The premaster secret must contain the same version number as the
			 * ClientHello to detect version rollback attacks (strangely, the
			 * protocol does not offer such protection for DH ciphersuites).
			 * However, buggy clients exist that send the negotiated protocol
			 * version instead if the server does not support the requested
			 * protocol version.
			 * If SSL_OP_TLS_ROLLBACK_BUG is set, tolerate such clients. */
			if (!((s->options & SSL_OP_TLS_ROLLBACK_BUG) &&
				(p[0] == (s->version>>8)) && (p[1] == (s->version & 0xff))))
				{
				al=SSL_AD_DECODE_ERROR;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER);
				goto f_err;
				}
d1286 1
a1287 21
		if (al != -1)
			{
#if 0
			goto f_err;
#else
			/* Some decryption failure -- use random value instead as countermeasure
			 * against Bleichenbacher's attack on PKCS #1 v1.5 RSA padding
			 * (see RFC 2246, section 7.4.7.1).
			 * But note that due to length and protocol version checking, the
			 * attack is impractical anyway (see section 5 in D. Bleichenbacher:
			 * "Chosen Ciphertext Attacks Against Protocols Based on the RSA
			 * Encryption Standard PKCS #1", CRYPTO '98, LNCS 1462, pp. 1-12).
			 */
			ERR_clear_error();
			i = SSL_MAX_MASTER_KEY_LENGTH;
			p[0] = s->client_version >> 8;
			p[1] = s->client_version & 0xff;
			RAND_pseudo_bytes(p+2, i-2); /* should be RAND_bytes, but we cannot work around a failure */
#endif
			}
	
d1296 1
a1296 1
#ifndef OPENSSL_NO_DH
a1354 1
		memset(p,0,i);
a1357 148
#ifndef OPENSSL_NO_KRB5
        if (l & SSL_kKRB5)
                {
                krb5_error_code		krb5rc;
		krb5_data		enc_ticket;
		krb5_data		authenticator;
		krb5_data		enc_pms;
                KSSL_CTX		*kssl_ctx = s->kssl_ctx;
		EVP_CIPHER_CTX		ciph_ctx;
		EVP_CIPHER		*enc = NULL;
		unsigned char		iv[EVP_MAX_IV_LENGTH];
		unsigned char		pms[SSL_MAX_MASTER_KEY_LENGTH
						+ EVP_MAX_IV_LENGTH + 1];
		int 			padl, outl = sizeof(pms);
		krb5_timestamp		authtime = 0;
		krb5_ticket_times	ttimes;

		EVP_CIPHER_CTX_init(&ciph_ctx);

                if (!kssl_ctx)  kssl_ctx = kssl_ctx_new();

		n2s(p,i);
		enc_ticket.length = i;
		enc_ticket.data = (char *)p;
		p+=enc_ticket.length;

		n2s(p,i);
		authenticator.length = i;
		authenticator.data = (char *)p;
		p+=authenticator.length;

		n2s(p,i);
		enc_pms.length = i;
		enc_pms.data = (char *)p;
		p+=enc_pms.length;

		if (n != enc_ticket.length + authenticator.length +
						enc_pms.length + 6)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
			}

                if ((krb5rc = kssl_sget_tkt(kssl_ctx, &enc_ticket, &ttimes,
					&kssl_err)) != 0)
                        {
#ifdef KSSL_DEBUG
                        printf("kssl_sget_tkt rtn %d [%d]\n",
                                krb5rc, kssl_err.reason);
                        if (kssl_err.text)
                                printf("kssl_err text= %s\n", kssl_err.text);
#endif	/* KSSL_DEBUG */
                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
                                kssl_err.reason);
                        goto err;
                        }

		/*  Note: no authenticator is not considered an error,
		**  but will return authtime == 0.
		*/
		if ((krb5rc = kssl_check_authent(kssl_ctx, &authenticator,
					&authtime, &kssl_err)) != 0)
			{
#ifdef KSSL_DEBUG
                        printf("kssl_check_authent rtn %d [%d]\n",
                                krb5rc, kssl_err.reason);
                        if (kssl_err.text)
                                printf("kssl_err text= %s\n", kssl_err.text);
#endif	/* KSSL_DEBUG */
                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
                                kssl_err.reason);
                        goto err;
			}

		if ((krb5rc = kssl_validate_times(authtime, &ttimes)) != 0)
			{
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, krb5rc);
                        goto err;
			}

#ifdef KSSL_DEBUG
                kssl_ctx_show(kssl_ctx);
#endif	/* KSSL_DEBUG */

		enc = kssl_map_enc(kssl_ctx->enctype);
                if (enc == NULL)
                    goto err;

		memset(iv, 0, EVP_MAX_IV_LENGTH);	/* per RFC 1510 */

		if (!EVP_DecryptInit_ex(&ciph_ctx,enc,NULL,kssl_ctx->key,iv))
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				SSL_R_DECRYPTION_FAILED);
			goto err;
			}
		if (!EVP_DecryptUpdate(&ciph_ctx, pms,&outl,
					(unsigned char *)enc_pms.data, enc_pms.length))
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				SSL_R_DECRYPTION_FAILED);
			goto err;
			}
		if (outl > SSL_MAX_MASTER_KEY_LENGTH)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
			}
		if (!EVP_DecryptFinal_ex(&ciph_ctx,&(pms[outl]),&padl))
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				SSL_R_DECRYPTION_FAILED);
			goto err;
			}
		outl += padl;
		if (outl > SSL_MAX_MASTER_KEY_LENGTH)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
			}
		EVP_CIPHER_CTX_cleanup(&ciph_ctx);

                s->session->master_key_length=
                        s->method->ssl3_enc->generate_master_secret(s,
                                s->session->master_key, pms, outl);

                if (kssl_ctx->client_princ)
                        {
                        int len = strlen(kssl_ctx->client_princ);
                        if ( len < SSL_MAX_KRB5_PRINCIPAL_LENGTH ) 
                                {
                                s->session->krb5_client_princ_len = len;
                                memcpy(s->session->krb5_client_princ,kssl_ctx->client_princ,len);
                                }
                        }


                /*  Was doing kssl_ctx_free() here,
		**  but it caused problems for apache.
                **  kssl_ctx = kssl_ctx_free(kssl_ctx);
                **  if (s->kssl_ctx)  s->kssl_ctx = NULL;
                */
                }
	else
#endif	/* OPENSSL_NO_KRB5 */
d1360 1
a1360 2
		SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				SSL_R_UNKNOWN_CIPHER_TYPE);
d1367 1
a1367 1
#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA)
d1373 2
a1374 1
static int ssl3_get_cert_verify(SSL *s)
d1439 1
a1439 1
	p=(unsigned char *)s->init_msg;
d1457 1
a1457 1
#ifndef OPENSSL_NO_RSA 
d1460 1
a1460 3
		i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,
			MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, 
							pkey->pkey.rsa);
d1467 3
a1469 1
		if (i == 0)
d1478 1
a1478 1
#ifndef OPENSSL_NO_DSA
d1482 1
a1482 1
			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
d1495 1
a1495 1
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);
a1507 1
	EVP_PKEY_free(pkey);
d1511 2
a1512 1
static int ssl3_get_client_certificate(SSL *s)
d1518 1
a1518 1
	STACK_OF(X509) *sk=NULL;
d1524 5
a1528 1
		s->max_cert_list,
d1542 1
a1542 1
		/* If tls asked for a client cert, the client must return a 0 list */
d1559 1
a1559 1
	d=p=(unsigned char *)s->init_msg;
d1561 1
a1561 1
	if ((sk=sk_X509_new_null()) == NULL)
d1597 1
a1597 1
		if (!sk_X509_push(sk,x))
d1606 1
a1606 1
	if (sk_X509_num(sk) <= 0)
d1635 2
a1636 1
	if (s->session->peer != NULL) /* This should not be needed */
d1638 1
a1638 21
	s->session->peer=sk_X509_shift(sk);
	s->session->verify_result = s->verify_result;

	/* With the current implementation, sess_cert will always be NULL
	 * when we arrive here. */
	if (s->session->sess_cert == NULL)
		{
		s->session->sess_cert = ssl_sess_cert_new();
		if (s->session->sess_cert == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);
			goto err;
			}
		}
	if (s->session->sess_cert->cert_chain != NULL)
		sk_X509_pop_free(s->session->sess_cert->cert_chain, X509_free);
	s->session->sess_cert->cert_chain=sk;
	/* Inconsistency alert: cert_chain does *not* include the
	 * peer's own certificate, while we do include it in s3_clnt.c */

	sk=NULL;
d1648 1
a1648 1
	if (sk != NULL) sk_X509_pop_free(sk,X509_free);
d1652 2
a1653 1
int ssl3_send_server_certificate(SSL *s)
d1661 1
a1661 5
		if (x == NULL &&
                        /* VRS: allow null cert if auth == KRB5 */
                        (s->s3->tmp.new_cipher->algorithms
                                & (SSL_MKEY_MASK|SSL_AUTH_MASK))
                        != (SSL_aKRB5|SSL_kKRB5))
d1663 1
a1663 1
			SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,ERR_R_INTERNAL_ERROR);
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a116 2
#include "ssl_locl.h"
#include "kssl_lcl.h"
d123 2
a125 1
#include "cryptlib.h"
a966 1
		die(sl <= sizeof s->session->session_id);
d1562 2
a1563 2
                                               + EVP_MAX_BLOCK_LENGTH];
		int                     padl, outl;
a1584 10

		/* Note that the length is checked again below,
		** after decryption
		*/
		if(enc.pms_length > sizeof pms)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			       SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
			}
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d968 1
a968 5
		if (sl > sizeof s->session->session_id)
			{
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO, ERR_R_INTERNAL_ERROR);
			return -1;
			}
d1591 1
a1591 1
		if(enc_pms.length > sizeof pms)
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@d155 5
a159 12
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);

		if (init)
			{
			memcpy((char *)&SSLv3_server_data,(char *)sslv3_base_method(),
				sizeof(SSL_METHOD));
			SSLv3_server_data.ssl_accept=ssl3_accept;
			SSLv3_server_data.get_ssl_method=ssl3_get_server_method;
			init=0;
			}
			
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);
d1174 1
a1174 1
		if (!BUF_MEM_grow_clean(buf,n+4+kn))
d1301 1
a1301 1
				if (!BUF_MEM_grow_clean(buf,4+n+j+2))
d1443 1
a1443 1
			/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT); */
d1459 2
a1460 9
				/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER); */

				/* The Klima-Pokorny-Rosa extension of Bleichenbacher's attack
				 * (http://eprint.iacr.org/2003/052/) exploits the version
				 * number check as a "bad version oracle" -- an alert would
				 * reveal that the plaintext corresponding to some ciphertext
				 * made up by the adversary is properly formatted except
				 * that the version number is wrong.  To avoid such attacks,
				 * we should treat this just like any other decryption error. */
d1466 3
d1471 6
a1476 1
			 * (see RFC 2246, section 7.4.7.1). */
d1482 1
d1489 1
a1489 1
		OPENSSL_cleanse(p,i);
d1552 1
a1552 1
		OPENSSL_cleanse(p,i);
d1655 1
a1655 1
		memset(iv, 0, sizeof iv);	/* per RFC 1510 */
d1743 1
a1743 1
		514, /* 514? */
@


1.1.1.6
log
@import 0.9.7c
@
text
@d434 4
a437 5
				if (s->s3->tmp.cert_request)
					{
					ret=ssl3_get_client_certificate(s);
					if (ret <= 0) goto end;
					}
a846 3
#if 0   /* SSL 3.0 does not mind either, so we should disable this test
         * (was enabled in 0.9.6d through 0.9.6j and 0.9.7 through 0.9.7b,
         * in earlier SSLeay/OpenSSL releases this test existed but was buggy) */
a857 1
#endif
a1354 1
		s->state = SSL3_ST_SW_CERT_REQ_B;
@


1.1.1.7
log
@import openssl-0.9.7d
@
text
@a123 1
#ifndef OPENSSL_NO_KRB5
a124 1
#endif
d126 1
a1589 8

		if (n < enc_ticket.length + 6)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
			}

a1594 8

		if (n < enc_ticket.length + authenticator.length + 6)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
			}

@


1.1.1.8
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a127 1
#include <openssl/fips.h>
d958 1
a958 2
		if(RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
			return -1;
a1213 2
					EVP_MD_CTX_set_flags(&md_ctx,
						EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d1494 1
a1494 2
			if(RAND_pseudo_bytes(p+2, i-2) <= 0)  /* should be RAND_bytes, but we cannot work around a failure */
				goto err;
d1592 1
a1592 1
		if (n < (long)enc_ticket.length + 6)
d1605 1
a1605 1
		if (n < (long)(enc_ticket.length + authenticator.length + 6))
d1630 2
a1631 2
		if (n != (long)(enc_ticket.length + authenticator.length +
						enc_pms.length + 6))
@


1.1.1.9
log
@import of openssl-0.9.7j
@
text
@d176 1
a176 1
	unsigned long l,Time=(unsigned long)time(NULL);
d957 1
a957 1
		Time=(unsigned long)time(NULL);			/* Time */
@


1.1.1.10
log
@import of OpenSSL 0.9.8h
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
a110 13
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by 
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the OpenSSL open source
 * license provided above.
 *
 * ECC cipher suite support in OpenSSL originally written by
 * Vipul Gupta and Sumit Gupta of Sun Microsystems Laboratories.
 *
 */
d115 1
a122 1
#include <openssl/hmac.h>
a123 4
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
#include <openssl/bn.h>
d128 1
d131 10
a140 3
#ifndef OPENSSL_NO_ECDH
static int nid2curve_id(int nid);
#endif
d150 22
a171 4
IMPLEMENT_ssl3_meth_func(SSLv3_server_method,
			ssl3_accept,
			ssl_undefined_function,
			ssl3_get_server_method)
d302 1
a302 1
#ifndef OPENSSL_NO_TLSEXT
d304 1
a304 10
				{
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
				}
#else
			if (s->hit)
					s->state=SSL3_ST_SW_CHANGE_A;
#endif
d312 2
a313 3
			/* Check if it is anon DH or anon ECDH or KRB5 */
			if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithms & SSL_aKRB5))
a316 12
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
a319 1

a320 1
#endif
a342 1

d344 1
a344 8
			 * RSA but we have a sign only certificate
			 *
			 * For ECC ciphersuites, we send a serverKeyExchange
			 * message only if the cipher suite is either
			 * ECDH-anon or ECDHE. In other cases, the
			 * server certificate contains the server's 
			 * public key for key exchange.
			 */
a345 1
			    || (l & SSL_kECDHE)
d449 12
a460 16
			if (ret <= 0) 
				goto end;
			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 */
				s->state=SSL3_ST_SR_FINISHED_A;
				s->init_num = 0;
				}
			else   
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
a461 10
				/* We need to get hashes here so if there is
				 * a client cert, it can be verified
				 */ 
				s->method->ssl3_enc->cert_verify_mac(s,
				    &(s->s3->finish_dgst1),
				    &(s->s3->tmp.cert_verify_md[0]));
				s->method->ssl3_enc->cert_verify_mac(s,
				    &(s->s3->finish_dgst2),
				    &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
				}
a481 4
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
a486 19
#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

d592 1
a592 1
int ssl3_send_hello_request(SSL *s)
d614 1
a614 1
int ssl3_check_client_hello(SSL *s)
d621 1
a621 1
	n=s->method->ssl_get_message(s,
d647 1
a647 1
int ssl3_get_client_hello(SSL *s)
a649 1
	unsigned int cookie_len;
a653 1
#ifndef OPENSSL_NO_COMP
a654 1
#endif
d665 1
d668 1
a668 2
	s->first_packet=1;
	n=s->method->ssl_get_message(s,
a675 1
	s->first_packet=0;
d683 1
a683 2
	if ((s->version == DTLS1_VERSION && s->client_version > s->version) ||
	    (s->version != DTLS1_VERSION && s->client_version < s->version))
d711 1
a711 1
	if ((s->new_session && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION)))
d718 1
a718 1
		i=ssl_get_prev_session(s, p, j, d + n);
a732 62

	if (s->version == DTLS1_VERSION)
		{
		/* cookie stuff */
		cookie_len = *(p++);

		if ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&
			s->d1->send_cookie == 0)
			{
			/* HelloVerifyMessage has already been sent */
			if ( cookie_len != s->d1->cookie_len)
				{
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
				goto f_err;
				}
			}

		/* 
		 * The ClientHello may contain a cookie even if the
		 * HelloVerify message has not been sent--make sure that it
		 * does not cause an overflow.
		 */
		if ( cookie_len > sizeof(s->d1->rcvd_cookie))
			{
			/* too much data */
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
			goto f_err;
			}

		/* verify the cookie if appropriate option is set. */
		if ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&
			cookie_len > 0)
			{
			memcpy(s->d1->rcvd_cookie, p, cookie_len);

			if ( s->ctx->app_verify_cookie_cb != NULL)
				{
				if ( s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,
					cookie_len) == 0)
					{
					al=SSL_AD_HANDSHAKE_FAILURE;
					SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, 
						SSL_R_COOKIE_MISMATCH);
					goto f_err;
					}
				/* else cookie verification succeeded */
				}
			else if ( memcmp(s->d1->rcvd_cookie, s->d1->cookie, 
						  s->d1->cookie_len) != 0) /* default verification */
				{
					al=SSL_AD_HANDSHAKE_FAILURE;
					SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, 
						SSL_R_COOKIE_MISMATCH);
					goto f_err;
				}
			}

		p += cookie_len;
		}

d782 2
a783 1
				s->session->cipher=sk_SSL_CIPHER_value(ciphers, 0);
a819 16
#ifndef OPENSSL_NO_TLSEXT
	/* TLS extensions*/
	if (s->version > SSL3_VERSION)
		{
		if (!ssl_parse_clienthello_tlsext(s,&p,d,n, &al))
			{
			/* 'al' set by ssl_parse_clienthello_tlsext */
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_PARSE_TLSEXT);
			goto f_err;
			}
		}
		if (ssl_check_clienthello_tlsext(s) <= 0) {
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_CLIENTHELLO_TLSEXT);
			goto err;
		}
#endif
a823 1
#ifndef OPENSSL_NO_COMP
a847 1
#endif
a870 3
#ifdef OPENSSL_NO_COMP
		s->session->compress_meth=0;
#else
a871 1
#endif
d946 1
a946 1
int ssl3_send_server_hello(SSL *s)
d959 1
a959 1
		if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
a977 7
		 *
		 * We also have an additional case where stateless session
		 * resumption is successful: we always send back the old
		 * session id. In this case s->hit is non zero: this can
		 * only happen if stateless session resumption is succesful
		 * if session caching is disabled so existing functionality
		 * is unaffected.
d979 1
a979 2
		if (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER)
			&& !s->hit)
d983 1
a983 1
		if (sl > (int)sizeof(s->session->session_id))
a996 3
#ifdef OPENSSL_NO_COMP
			*(p++)=0;
#else
d1001 1
a1001 8
#endif
#ifndef OPENSSL_NO_TLSEXT
		if ((p = ssl_add_serverhello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
			{
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO,ERR_R_INTERNAL_ERROR);
			return -1;
			}
#endif
d1018 1
a1018 1
int ssl3_send_server_done(SSL *s)
d1042 1
a1042 1
int ssl3_send_server_key_exchange(SSL *s)
a1053 7
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh=NULL, *ecdhp;
	unsigned char *encodedPoint = NULL;
	int encodedlen = 0;
	int curve_id = 0;
	BN_CTX *bn_ctx = NULL; 
#endif
a1161 128
#ifndef OPENSSL_NO_ECDH
			if (type & SSL_kECDHE)
			{
			const EC_GROUP *group;

			ecdhp=cert->ecdh_tmp;
			if ((ecdhp == NULL) && (s->cert->ecdh_tmp_cb != NULL))
				{
				ecdhp=s->cert->ecdh_tmp_cb(s,
				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
				}
			if (ecdhp == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);
				goto f_err;
				}

			if (s->s3->tmp.ecdh != NULL)
				{
				EC_KEY_free(s->s3->tmp.ecdh); 
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
				goto err;
				}

			/* Duplicate the ECDH structure. */
			if (ecdhp == NULL)
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				goto err;
				}
			if (!EC_KEY_up_ref(ecdhp))
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				goto err;
				}
			ecdh = ecdhp;

			s->s3->tmp.ecdh=ecdh;
			if ((EC_KEY_get0_public_key(ecdh) == NULL) ||
			    (EC_KEY_get0_private_key(ecdh) == NULL) ||
			    (s->options & SSL_OP_SINGLE_ECDH_USE))
				{
				if(!EC_KEY_generate_key(ecdh))
				    {
				    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				    goto err;
				    }
				}

			if (((group = EC_KEY_get0_group(ecdh)) == NULL) ||
			    (EC_KEY_get0_public_key(ecdh)  == NULL) ||
			    (EC_KEY_get0_private_key(ecdh) == NULL))
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				goto err;
				}

			if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
			    (EC_GROUP_get_degree(group) > 163)) 
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
				goto err;
				}

			/* XXX: For now, we only support ephemeral ECDH
			 * keys over named (not generic) curves. For 
			 * supported named curves, curve_id is non-zero.
			 */
			if ((curve_id = 
			    nid2curve_id(EC_GROUP_get_curve_name(group)))
			    == 0)
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);
				goto err;
				}

			/* Encode the public key.
			 * First check the size of encoding and
			 * allocate memory accordingly.
			 */
			encodedlen = EC_POINT_point2oct(group, 
			    EC_KEY_get0_public_key(ecdh),
			    POINT_CONVERSION_UNCOMPRESSED, 
			    NULL, 0, NULL);

			encodedPoint = (unsigned char *) 
			    OPENSSL_malloc(encodedlen*sizeof(unsigned char)); 
			bn_ctx = BN_CTX_new();
			if ((encodedPoint == NULL) || (bn_ctx == NULL))
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
				goto err;
				}


			encodedlen = EC_POINT_point2oct(group, 
			    EC_KEY_get0_public_key(ecdh), 
			    POINT_CONVERSION_UNCOMPRESSED, 
			    encodedPoint, encodedlen, bn_ctx);

			if (encodedlen == 0) 
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				goto err;
				}

			BN_CTX_free(bn_ctx);  bn_ctx=NULL;

			/* XXX: For now, we only support named (not 
			 * generic) curves in ECDH ephemeral key exchanges.
			 * In this situation, we need four additional bytes
			 * to encode the entire ServerECDHParams
			 * structure. 
			 */
			n = 4 + encodedlen;

			/* We'll generate the serverKeyExchange message
			 * explicitly so we can set these to NULLs
			 */
			r[0]=NULL;
			r[1]=NULL;
			r[2]=NULL;
			r[3]=NULL;
			}
		else 
#endif /* !OPENSSL_NO_ECDH */
a1203 25
#ifndef OPENSSL_NO_ECDH
		if (type & SSL_kECDHE) 
			{
			/* XXX: For now, we only support named (not generic) curves.
			 * In this situation, the serverKeyExchange message has:
			 * [1 byte CurveType], [2 byte CurveName]
			 * [1 byte length of encoded point], followed by
			 * the actual encoded point itself
			 */
			*p = NAMED_CURVE_TYPE;
			p += 1;
			*p = 0;
			p += 1;
			*p = curve_id;
			p += 1;
			*p = encodedlen;
			p += 1;
			memcpy((unsigned char*)p, 
			    (unsigned char *)encodedPoint, 
			    encodedlen);
			OPENSSL_free(encodedPoint);
			p += encodedlen;
			}
#endif

d1216 2
a1257 19
#if !defined(OPENSSL_NO_ECDSA)
				if (pkey->type == EVP_PKEY_EC)
				{
				/* let's do ECDSA */
				EVP_SignInit_ex(&md_ctx,EVP_ecdsa(), NULL);
				EVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(d[4]),n);
				if (!EVP_SignFinal(&md_ctx,&(p[2]),
					(unsigned int *)&i,pkey))
					{
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_ECDSA);
					goto err;
					}
				s2n(i,p);
				n+=i+2;
				}
			else
#endif
a1280 4
#ifndef OPENSSL_NO_ECDH
	if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
	BN_CTX_free(bn_ctx);
#endif
d1285 1
a1285 1
int ssl3_send_certificate_request(SSL *s)
d1374 1
a1374 1
int ssl3_get_client_key_exchange(SSL *s)
d1392 1
a1392 8
#ifndef OPENSSL_NO_ECDH
	EC_KEY *srvr_ecdh = NULL;
	EVP_PKEY *clnt_pub_pkey = NULL;
	EC_POINT *clnt_ecpoint = NULL;
	BN_CTX *bn_ctx = NULL; 
#endif

	n=s->method->ssl_get_message(s,
d1436 2
a1437 3
		/* TLS and [incidentally] DTLS, including pre-0.9.8f */
		if (s->version > SSL3_VERSION &&
		    s->client_version != DTLS1_BAD_VER)
d1498 1
a1498 1
			if (RAND_pseudo_bytes(p+2, i-2) <= 0) /* should be RAND_bytes, but we cannot work around a failure */
d1597 1
a1597 1
		if (n < (int)enc_ticket.length + 6)
d1610 1
a1610 1
		if (n < (int)(enc_ticket.length + authenticator.length) + 6)
d1652 1
a1652 1
                        SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
d1669 1
a1669 1
                        SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
d1676 1
a1676 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, krb5rc);
a1721 18
		if (!((pms[0] == (s->client_version>>8)) && (pms[1] == (s->client_version & 0xff))))
		    {
		    /* The premaster secret must contain the same version number as the
		     * ClientHello to detect version rollback attacks (strangely, the
		     * protocol does not offer such protection for DH ciphersuites).
		     * However, buggy clients exist that send random bytes instead of
		     * the protocol version.
		     * If SSL_OP_TLS_ROLLBACK_BUG is set, tolerate such clients. 
		     * (Perhaps we should have a separate BUG value for the Kerberos cipher)
		     */
		    if (!(s->options & SSL_OP_TLS_ROLLBACK_BUG))
		        {
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			       SSL_AD_DECODE_ERROR);
			goto err;
			}
		    }

d1730 1
a1730 1
                        size_t len = strlen(kssl_ctx->client_princ);
a1746 150

#ifndef OPENSSL_NO_ECDH
		if ((l & SSL_kECDH) || (l & SSL_kECDHE))
		{
		int ret = 1;
		int field_size = 0;
		const EC_KEY   *tkey;
		const EC_GROUP *group;
		const BIGNUM *priv_key;

                /* initialize structures for server's ECDH key pair */
		if ((srvr_ecdh = EC_KEY_new()) == NULL) 
			{
                	SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
                	goto err;
			}

		/* Let's get server private key and group information */
		if (l & SSL_kECDH) 
			{ 
                        /* use the certificate */
			tkey = s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec;
			}
		else
			{
			/* use the ephermeral values we saved when
			 * generating the ServerKeyExchange msg.
			 */
			tkey = s->s3->tmp.ecdh;
			}

		group    = EC_KEY_get0_group(tkey);
		priv_key = EC_KEY_get0_private_key(tkey);

		if (!EC_KEY_set_group(srvr_ecdh, group) ||
		    !EC_KEY_set_private_key(srvr_ecdh, priv_key))
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			       ERR_R_EC_LIB);
			goto err;
			}

		/* Let's get client's public key */
		if ((clnt_ecpoint = EC_POINT_new(group)) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
			}

                if (n == 0L) 
                        {
			/* Client Publickey was in Client Certificate */

			 if (l & SSL_kECDHE) 
				 {
				 al=SSL_AD_HANDSHAKE_FAILURE;
				 SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);
				 goto f_err;
				 }
                        if (((clnt_pub_pkey=X509_get_pubkey(s->session->peer))
			    == NULL) || 
			    (clnt_pub_pkey->type != EVP_PKEY_EC))
                        	{
				/* XXX: For now, we do not support client
				 * authentication using ECDH certificates
				 * so this branch (n == 0L) of the code is
				 * never executed. When that support is
				 * added, we ought to ensure the key 
				 * received in the certificate is 
				 * authorized for key agreement.
				 * ECDH_compute_key implicitly checks that
				 * the two ECDH shares are for the same
				 * group.
				 */
                           	al=SSL_AD_HANDSHAKE_FAILURE;
                           	SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    SSL_R_UNABLE_TO_DECODE_ECDH_CERTS);
                           	goto f_err;
                           	}

			if (EC_POINT_copy(clnt_ecpoint,
			    EC_KEY_get0_public_key(clnt_pub_pkey->pkey.ec)) == 0)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					ERR_R_EC_LIB);
				goto err;
				}
                        ret = 2; /* Skip certificate verify processing */
                        }
                else
                        {
			/* Get client's public key from encoded point
			 * in the ClientKeyExchange message.
			 */
			if ((bn_ctx = BN_CTX_new()) == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
				}

                        /* Get encoded point length */
                        i = *p; 
			p += 1;
                        if (EC_POINT_oct2point(group, 
			    clnt_ecpoint, p, i, bn_ctx) == 0)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    ERR_R_EC_LIB);
				goto err;
				}
                        /* p is pointing to somewhere in the buffer
                         * currently, so set it to the start 
                         */ 
                        p=(unsigned char *)s->init_buf->data;
                        }

		/* Compute the shared pre-master secret */
		field_size = EC_GROUP_get_degree(group);
		if (field_size <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, 
			       ERR_R_ECDH_LIB);
			goto err;
			}
		i = ECDH_compute_key(p, (field_size+7)/8, clnt_ecpoint, srvr_ecdh, NULL);
                if (i <= 0)
                        {
                        SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
			    ERR_R_ECDH_LIB);
                        goto err;
                        }

		EVP_PKEY_free(clnt_pub_pkey);
		EC_POINT_free(clnt_ecpoint);
		if (srvr_ecdh != NULL) 
			EC_KEY_free(srvr_ecdh);
		BN_CTX_free(bn_ctx);

		/* Compute the master secret */
                s->session->master_key_length = s->method->ssl3_enc-> \
		    generate_master_secret(s, s->session->master_key, p, i);
		
                OPENSSL_cleanse(p, i);
                return (ret);
		}
	else
#endif
d1757 1
a1757 1
#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH)
a1759 7
#ifndef OPENSSL_NO_ECDH
	EVP_PKEY_free(clnt_pub_pkey);
	EC_POINT_free(clnt_ecpoint);
	if (srvr_ecdh != NULL) 
		EC_KEY_free(srvr_ecdh);
	BN_CTX_free(bn_ctx);
#endif
d1763 1
a1763 1
int ssl3_get_cert_verify(SSL *s)
d1772 1
a1772 1
	n=s->method->ssl_get_message(s,
a1882 17
#ifndef OPENSSL_NO_ECDSA
		if (pkey->type == EVP_PKEY_EC)
		{
		j=ECDSA_verify(pkey->save_type,
			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
			SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);
		if (j <= 0)
			{
			/* bad signature */
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_BAD_ECDSA_SIGNATURE);
			goto f_err;
			}
		}
	else
#endif
d1901 1
a1901 1
int ssl3_get_client_certificate(SSL *s)
d1906 1
a1906 2
	const unsigned char *p,*q;
	unsigned char *d;
d1909 1
a1909 1
	n=s->method->ssl_get_message(s,
d1944 1
a1944 1
	p=d=(unsigned char *)s->init_msg;
a2082 206


#ifndef OPENSSL_NO_ECDH
/* This is the complement of curve_id2nid in s3_clnt.c. */
static int nid2curve_id(int nid)
{
	/* ECC curves from draft-ietf-tls-ecc-01.txt (Mar 15, 2001)
	 * (no changes in draft-ietf-tls-ecc-03.txt [June 2003]) */
	switch (nid) {
	case NID_sect163k1: /* sect163k1 (1) */
		return 1;
	case NID_sect163r1: /* sect163r1 (2) */
		return 2;
	case NID_sect163r2: /* sect163r2 (3) */
		return 3;
	case NID_sect193r1: /* sect193r1 (4) */ 
		return 4;
	case NID_sect193r2: /* sect193r2 (5) */ 
		return 5;
	case NID_sect233k1: /* sect233k1 (6) */
		return 6;
	case NID_sect233r1: /* sect233r1 (7) */ 
		return 7;
	case NID_sect239k1: /* sect239k1 (8) */ 
		return 8;
	case NID_sect283k1: /* sect283k1 (9) */
		return 9;
	case NID_sect283r1: /* sect283r1 (10) */ 
		return 10;
	case NID_sect409k1: /* sect409k1 (11) */ 
		return 11;
	case NID_sect409r1: /* sect409r1 (12) */
		return 12;
	case NID_sect571k1: /* sect571k1 (13) */ 
		return 13;
	case NID_sect571r1: /* sect571r1 (14) */ 
		return 14;
	case NID_secp160k1: /* secp160k1 (15) */
		return 15;
	case NID_secp160r1: /* secp160r1 (16) */ 
		return 16;
	case NID_secp160r2: /* secp160r2 (17) */ 
		return 17;
	case NID_secp192k1: /* secp192k1 (18) */
		return 18;
	case NID_X9_62_prime192v1: /* secp192r1 (19) */ 
		return 19;
	case NID_secp224k1: /* secp224k1 (20) */ 
		return 20;
	case NID_secp224r1: /* secp224r1 (21) */
		return 21;
	case NID_secp256k1: /* secp256k1 (22) */ 
		return 22;
	case NID_X9_62_prime256v1: /* secp256r1 (23) */ 
		return 23;
	case NID_secp384r1: /* secp384r1 (24) */
		return 24;
	case NID_secp521r1:  /* secp521r1 (25) */	
		return 25;
	default:
		return 0;
	}
}
#endif
#ifndef OPENSSL_NO_TLSEXT
int ssl3_send_newsession_ticket(SSL *s)
	{
	if (s->state == SSL3_ST_SW_SESSION_TICKET_A)
		{
		unsigned char *p, *senc, *macstart;
		int len, slen;
		unsigned int hlen;
		EVP_CIPHER_CTX ctx;
		HMAC_CTX hctx;
		unsigned char iv[EVP_MAX_IV_LENGTH];
		unsigned char key_name[16];

		/* get session encoding length */
		slen = i2d_SSL_SESSION(s->session, NULL);
		/* Some length values are 16 bits, so forget it if session is
 		 * too long
 		 */
		if (slen > 0xFF00)
			return -1;
		/* Grow buffer if need be: the length calculation is as
 		 * follows 1 (size of message name) + 3 (message length
 		 * bytes) + 4 (ticket lifetime hint) + 2 (ticket length) +
 		 * 16 (key name) + max_iv_len (iv length) +
 		 * session_length + max_enc_block_size (max encrypted session
 		 * length) + max_md_size (HMAC).
 		 */
		if (!BUF_MEM_grow(s->init_buf,
			26 + EVP_MAX_IV_LENGTH + EVP_MAX_BLOCK_LENGTH +
			EVP_MAX_MD_SIZE + slen))
			return -1;
		senc = OPENSSL_malloc(slen);
		if (!senc)
			return -1;
		p = senc;
		i2d_SSL_SESSION(s->session, &p);

		p=(unsigned char *)s->init_buf->data;
		/* do the header */
		*(p++)=SSL3_MT_NEWSESSION_TICKET;
		/* Skip message length for now */
		p += 3;
		EVP_CIPHER_CTX_init(&ctx);
		HMAC_CTX_init(&hctx);
		/* Initialize HMAC and cipher contexts. If callback present
		 * it does all the work otherwise use generated values
		 * from parent ctx.
		 */
		if (s->ctx->tlsext_ticket_key_cb)
			{
			if (s->ctx->tlsext_ticket_key_cb(s, key_name, iv, &ctx,
							 &hctx, 1) < 0)
				{
				OPENSSL_free(senc);
				return -1;
				}
			}
		else
			{
			RAND_pseudo_bytes(iv, 16);
			EVP_EncryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,
					s->ctx->tlsext_tick_aes_key, iv);
			HMAC_Init_ex(&hctx, s->ctx->tlsext_tick_hmac_key, 16,
					tlsext_tick_md(), NULL);
			memcpy(key_name, s->ctx->tlsext_tick_key_name, 16);
			}
		l2n(s->session->tlsext_tick_lifetime_hint, p);
		/* Skip ticket length for now */
		p += 2;
		/* Output key name */
		macstart = p;
		memcpy(p, key_name, 16);
		p += 16;
		/* output IV */
		memcpy(p, iv, EVP_CIPHER_CTX_iv_length(&ctx));
		p += EVP_CIPHER_CTX_iv_length(&ctx);
		/* Encrypt session data */
		EVP_EncryptUpdate(&ctx, p, &len, senc, slen);
		p += len;
		EVP_EncryptFinal(&ctx, p, &len);
		p += len;
		EVP_CIPHER_CTX_cleanup(&ctx);

		HMAC_Update(&hctx, macstart, p - macstart);
		HMAC_Final(&hctx, p, &hlen);
		HMAC_CTX_cleanup(&hctx);

		p += hlen;
		/* Now write out lengths: p points to end of data written */
		/* Total length */
		len = p - (unsigned char *)s->init_buf->data;
		p=(unsigned char *)s->init_buf->data + 1;
		l2n3(len - 4, p); /* Message length */
		p += 4;
		s2n(len - 10, p);  /* Ticket length */

		/* number of bytes to write */
		s->init_num= len;
		s->state=SSL3_ST_SW_SESSION_TICKET_B;
		s->init_off=0;
		OPENSSL_free(senc);
		}

	/* SSL3_ST_SW_SESSION_TICKET_B */
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
	}

int ssl3_send_cert_status(SSL *s)
	{
	if (s->state == SSL3_ST_SW_CERT_STATUS_A)
		{
		unsigned char *p;
		/* Grow buffer if need be: the length calculation is as
 		 * follows 1 (message type) + 3 (message length) +
 		 * 1 (ocsp response type) + 3 (ocsp response length)
 		 * + (ocsp response)
 		 */
		if (!BUF_MEM_grow(s->init_buf, 8 + s->tlsext_ocsp_resplen))
			return -1;

		p=(unsigned char *)s->init_buf->data;

		/* do the header */
		*(p++)=SSL3_MT_CERTIFICATE_STATUS;
		/* message length */
		l2n3(s->tlsext_ocsp_resplen + 4, p);
		/* status type */
		*(p++)= s->tlsext_status_type;
		/* length of OCSP response */
		l2n3(s->tlsext_ocsp_resplen, p);
		/* actual response */
		memcpy(p, s->tlsext_ocsp_resp, s->tlsext_ocsp_resplen);
		/* number of bytes to write */
		s->init_num = 8 + s->tlsext_ocsp_resplen;
		s->state=SSL3_ST_SW_CERT_STATUS_B;
		s->init_off = 0;
		}

	/* SSL3_ST_SW_CERT_STATUS_B */
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
	}
#endif
@


1.1.1.11
log
@import openssl-0.9.8j
@
text
@d905 1
a905 1
		if (j == 0 && (s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_SSL_CIPHER_num(ciphers) == 1))
d907 6
a912 7
			/* Special case as client bug workaround: the previously used cipher may
			 * not be in the current list, the client instead might be trying to
			 * continue using a cipher that before wasn't chosen due to server
			 * preferences.  We'll have to reject the connection if the cipher is not
			 * enabled, though. */
			c = sk_SSL_CIPHER_value(ciphers, 0);
			if (sk_SSL_CIPHER_find(SSL_get_ciphers(s), c) >= 0)
d914 5
a918 2
				s->session->cipher = c;
				j = 1;
a920 8
		if (j == 0)
			{
			/* we need to have the cipher in the cipher
			 * list if we are asked to reuse it */
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_REQUIRED_CIPHER_MISSING);
			goto f_err;
			}
d1175 1
a1175 1
		s->state=SSL3_ST_SW_SRVR_HELLO_B;
d1181 1
a1181 1
	/* SSL3_ST_SW_SRVR_HELLO_B */
d1205 1
a1205 1
	/* SSL3_ST_SW_SRVR_DONE_B */
a1542 2
					EVP_MD_CTX_set_flags(&md_ctx,
						EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d2561 1
a2561 1
		if (i <= 0)
@


1.1.1.12
log
@import OpenSSL-1.0.0a
@
text
@d1 1
a1 1
/* ssl/s3_srvr.c -*- mode:C; c-file-style: "eay" -*- */
d59 1
a59 1
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
a123 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
d146 4
a149 1
static const SSL_METHOD *ssl3_get_server_method(int ver);
d151 1
a151 1
static const SSL_METHOD *ssl3_get_server_method(int ver)
d167 1
a167 1
	unsigned long alg_k,Time=(unsigned long)time(NULL);
d169 1
a250 12
			else if (!s->s3->send_connection_binding &&
				!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
				{
				/* Server attempting to renegotiate with
				 * client that doesn't support secure
				 * renegotiation.
				 */
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
				ret = -1;
				goto end;
				}
a283 1
			
d312 3
a314 5
			/* Check if it is anon DH or anon ECDH, */
			/* normal PSK or KRB5 */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
				&& !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
d341 1
a341 1
			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
d347 1
a347 1
				&& !(alg_k & SSL_kKRB5)
a361 2
			 * PSK: may send PSK identity hints
			 *
d365 1
a365 1
			 * server certificate contains the server's
d369 3
a371 8
			/* PSK: send ServerKeyExchange if PSK identity
			 * hint if provided */
#ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
			    || (alg_k & (SSL_kDHr|SSL_kDHd|SSL_kEDH))
			    || (alg_k & SSL_kEECDH)
			    || ((alg_k & SSL_kRSA)
d401 1
a401 1
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
d405 2
a406 5
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
d438 8
a445 16

			/* This code originally checked to see if
			 * any data was pending using BIO_CTRL_INFO
			 * and then flushed. This caused problems
			 * as documented in PR#1939. The proposed
			 * fix doesn't completely resolve this issue
			 * as buggy implementations of BIO_CTRL_PENDING
			 * still exist. So instead we just flush
			 * unconditionally.
			 */

			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
a446 1
			s->rwstate=SSL_NOTHING;
d473 1
a473 1
			if (ret <= 0)
a480 3
				 * Also for GOST ciphersuites when
				 * the client uses its key from the certificate
				 * for key exchange.
d485 1
a485 1
			else
a486 3
				int offset=0;
				int dgst_num;

d492 7
a498 20
				 * FIXME - digest processing for CertificateVerify
				 * should be generalized. But it is next step
				 */
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				for (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)	
					if (s->s3->handshake_dgst[dgst_num]) 
						{
						int dgst_size;

						s->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));
						dgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);
						if (dgst_size < 0)
							{
							ret = -1;
							goto end;
							}
						offset+=dgst_size;
						}		
d518 2
d521 1
a521 1
			if (s->tlsext_ticket_expected)
a522 5
			else if (s->hit)
				s->state=SSL_ST_OK;
#else
			if (s->hit)
				s->state=SSL_ST_OK;
d752 1
a752 1
		if ((s->client_version>>8) == SSL3_VERSION_MAJOR)
a760 15
	/* If we require cookies and this ClientHello doesn't
	 * contain one, just return since we do not want to
	 * allocate any memory yet. So check cookie length...
	 */
	if (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE)
		{
		unsigned int session_length, cookie_length;
		
		session_length = *(p + SSL3_RANDOM_SIZE);
		cookie_length = *(p + SSL3_RANDOM_SIZE + session_length + 1);

		if (cookie_length == 0)
			return 1;
		}

d800 1
a800 1
	if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)
d805 12
d831 1
a831 1
		if ((SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&
a855 2

			ret = 2;
d955 1
a955 1
	if (s->version >= SSL3_VERSION)
a967 53

	/* Check if we want to use external pre-shared secret for this
	 * handshake for not reused session only. We need to generate
	 * server_random before calling tls_session_secret_cb in order to allow
	 * SessionTicket processing to use it in key derivation. */
	{
		unsigned long Time;
		unsigned char *pos;
		Time=(unsigned long)time(NULL);			/* Time */
		pos=s->s3->server_random;
		l2n(Time,pos);
		if (RAND_pseudo_bytes(pos,SSL3_RANDOM_SIZE-4) <= 0)
			{
			al=SSL_AD_INTERNAL_ERROR;
			goto f_err;
			}
	}

	if (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb)
		{
		SSL_CIPHER *pref_cipher=NULL;

		s->session->master_key_length=sizeof(s->session->master_key);
		if(s->tls_session_secret_cb(s, s->session->master_key, &s->session->master_key_length,
			ciphers, &pref_cipher, s->tls_session_secret_cb_arg))
			{
			s->hit=1;
			s->session->ciphers=ciphers;
			s->session->verify_result=X509_V_OK;

			ciphers=NULL;

			/* check if some cipher was preferred by call back */
			pref_cipher=pref_cipher ? pref_cipher : ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));
			if (pref_cipher == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_SHARED_CIPHER);
				goto f_err;
				}

			s->session->cipher=pref_cipher;

			if (s->cipher_list)
				sk_SSL_CIPHER_free(s->cipher_list);

			if (s->cipher_list_by_id)
				sk_SSL_CIPHER_free(s->cipher_list_by_id);

			s->cipher_list = sk_SSL_CIPHER_dup(s->session->ciphers);
			s->cipher_list_by_id = sk_SSL_CIPHER_dup(s->session->ciphers);
			}
		}
a968 1

d974 1
a974 44
	/* This only happens if we have a cache hit */
	if (s->session->compress_meth != 0)
		{
		int m, comp_id = s->session->compress_meth;
		/* Perform sanity checks on resumed compression algorithm */
		/* Can't disable compression */
		if (s->options & SSL_OP_NO_COMPRESSION)
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_INCONSISTENT_COMPRESSION);
			goto f_err;
			}
		/* Look for resumed compression method */
		for (m = 0; m < sk_SSL_COMP_num(s->ctx->comp_methods); m++)
			{
			comp=sk_SSL_COMP_value(s->ctx->comp_methods,m);
			if (comp_id == comp->id)
				{
				s->s3->tmp.new_compression=comp;
				break;
				}
			}
		if (s->s3->tmp.new_compression == NULL)
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_INVALID_COMPRESSION_ALGORITHM);
			goto f_err;
			}
		/* Look for resumed method in compression list */
		for (m = 0; m < i; m++)
			{
			if (q[m] == comp_id)
				break;
			}
		if (m >= i)
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING);
			goto f_err;
			}
		}
	else if (s->hit)
		comp = NULL;
	else if (!(s->options & SSL_OP_NO_COMPRESSION) && s->ctx->comp_methods)
d998 7
a1004 5
#else
	/* If compression is disabled we'd better not try to resume a session
	 * using compression.
	 */
	if (s->session->compress_meth != 0)
d1006 8
a1013 3
		al=SSL_AD_INTERNAL_ERROR;
		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_INCONSISTENT_COMPRESSION);
		goto f_err;
d1062 1
a1062 1
				if (c->algorithm_enc & SSL_eNULL)
a1077 3

	if (!ssl3_digest_cached_records(s))
		goto f_err;
d1090 1
a1090 1
	if (ret < 0) ret=1;
d1106 1
a1106 4
	unsigned long l;
#ifdef OPENSSL_NO_TLSEXT
	unsigned long Time;
#endif
a1110 1
#ifdef OPENSSL_NO_TLSEXT
a1111 1
		/* Generate server_random if it was not needed previously */
a1115 1
#endif
a1168 5
		if (ssl_prepare_serverhello_tlsext(s) <= 0)
			{
			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);
			return -1;
			}
d1248 1
a1248 1
		type=s->s3->tmp.new_cipher->algorithm_mkey;
d1343 1
a1343 1
			if (type & SSL_kEECDH)
d1413 1
a1413 1
			    tls1_ec_nid2curve_id(EC_GROUP_get_curve_name(group)))
a1469 8
#ifndef OPENSSL_NO_PSK
			if (type & SSL_kPSK)
				{
				/* reserve size for record length and PSK identity hint*/
				n+=2+strlen(s->ctx->psk_identity_hint);
				}
			else
#endif /* !OPENSSL_NO_PSK */
d1481 1
a1481 2
		if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
			&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
d1513 1
a1513 1
		if (type & SSL_kEECDH) 
a1536 10
#ifndef OPENSSL_NO_PSK
		if (type & SSL_kPSK)
			{
			/* copy PSK identity hint */
			s2n(strlen(s->ctx->psk_identity_hint), p); 
			strncpy((char *)p, s->ctx->psk_identity_hint, strlen(s->ctx->psk_identity_hint));
			p+=strlen(s->ctx->psk_identity_hint);
			}
#endif

d1549 2
d1734 1
a1734 1
	unsigned long alg_k;
d1745 1
a1745 1
	KSSL_ERR kssl_err;
d1765 1
a1765 1
	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
d1768 1
a1768 1
	if (alg_k & SSL_kRSA)
d1799 3
a1801 2
		/* TLS and [incidentally] DTLS{0xFEFF} */
		if (s->version > SSL3_VERSION && s->version != DTLS1_BAD_VER)
d1875 1
a1875 1
		if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
d1938 3
a1940 3
	if (alg_k & SSL_kKRB5)
		{
		krb5_error_code		krb5rc;
d1944 1
a1944 1
		KSSL_CTX		*kssl_ctx = s->kssl_ctx;
d1946 1
a1946 1
		const EVP_CIPHER	*enc = NULL;
d1949 2
a1950 2
					       + EVP_MAX_BLOCK_LENGTH];
		int		     padl, outl;
d1956 1
a1956 1
		if (!kssl_ctx)  kssl_ctx = kssl_ctx_new();
d1961 1
a1961 1
		if (n < (long)(enc_ticket.length + 6))
d1974 1
a1974 1
		if (n < (long)(enc_ticket.length + authenticator.length + 6))
d2007 1
a2007 1
		if ((krb5rc = kssl_sget_tkt(kssl_ctx, &enc_ticket, &ttimes,
d2009 1
a2009 1
			{
d2011 4
a2014 4
			printf("kssl_sget_tkt rtn %d [%d]\n",
				krb5rc, kssl_err.reason);
			if (kssl_err.text)
				printf("kssl_err text= %s\n", kssl_err.text);
d2016 4
a2019 4
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				kssl_err.reason);
			goto err;
			}
d2028 4
a2031 4
			printf("kssl_check_authent rtn %d [%d]\n",
				krb5rc, kssl_err.reason);
			if (kssl_err.text)
				printf("kssl_err text= %s\n", kssl_err.text);
d2033 3
a2035 3
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				kssl_err.reason);
			goto err;
d2041 1
a2041 1
			goto err;
d2045 1
a2045 1
		kssl_ctx_show(kssl_ctx);
d2049 2
a2050 2
		if (enc == NULL)
		    goto err;
d2097 1
a2097 1
			{
d2106 13
a2118 13
		s->session->master_key_length=
			s->method->ssl3_enc->generate_master_secret(s,
				s->session->master_key, pms, outl);

		if (kssl_ctx->client_princ)
			{
			size_t len = strlen(kssl_ctx->client_princ);
			if ( len < SSL_MAX_KRB5_PRINCIPAL_LENGTH ) 
				{
				s->session->krb5_client_princ_len = len;
				memcpy(s->session->krb5_client_princ,kssl_ctx->client_princ,len);
				}
			}
d2121 1
a2121 1
		/*  Was doing kssl_ctx_free() here,
d2123 4
a2126 4
		**  kssl_ctx = kssl_ctx_free(kssl_ctx);
		**  if (s->kssl_ctx)  s->kssl_ctx = NULL;
		*/
		}
d2131 1
a2131 1
		if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe))
d2139 1
a2139 1
		/* initialize structures for server's ECDH key pair */
d2142 1
a2142 1
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
d2144 1
a2144 1
			goto err;
d2148 1
a2148 1
		if (alg_k & (SSL_kECDHr|SSL_kECDHe))
d2150 1
a2150 1
			/* use the certificate */
d2180 2
a2181 2
		if (n == 0L) 
			{
d2184 1
a2184 1
			 if (alg_k & SSL_kEECDH)
d2190 1
a2190 1
			if (((clnt_pub_pkey=X509_get_pubkey(s->session->peer))
d2193 1
a2193 1
				{
d2205 2
a2206 2
			   	al=SSL_AD_HANDSHAKE_FAILURE;
			   	SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
d2208 2
a2209 2
			   	goto f_err;
			   	}
d2218 4
a2221 4
			ret = 2; /* Skip certificate verify processing */
			}
		else
			{
d2232 2
a2233 2
			/* Get encoded point length */
			i = *p; 
d2235 1
a2235 1
			if (EC_POINT_oct2point(group, 
d2242 5
a2246 5
			/* p is pointing to somewhere in the buffer
			 * currently, so set it to the start 
			 */ 
			p=(unsigned char *)s->init_buf->data;
			}
d2257 3
a2259 3
		if (i <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
d2261 2
a2262 2
			goto err;
			}
d2266 2
a2267 1
		EC_KEY_free(srvr_ecdh);
a2268 2
		EC_KEY_free(s->s3->tmp.ecdh);
		s->s3->tmp.ecdh = NULL; 
d2271 1
a2271 1
		s->session->master_key_length = s->method->ssl3_enc-> \
d2274 2
a2275 2
		OPENSSL_cleanse(p, i);
		return (ret);
a2278 161
#ifndef OPENSSL_NO_PSK
		if (alg_k & SSL_kPSK)
			{
			unsigned char *t = NULL;
			unsigned char psk_or_pre_ms[PSK_MAX_PSK_LEN*2+4];
			unsigned int pre_ms_len = 0, psk_len = 0;
			int psk_err = 1;
			char tmp_id[PSK_MAX_IDENTITY_LEN+1];

			al=SSL_AD_HANDSHAKE_FAILURE;

			n2s(p,i);
			if (n != i+2)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					SSL_R_LENGTH_MISMATCH);
				goto psk_err;
				}
			if (i > PSK_MAX_IDENTITY_LEN)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					SSL_R_DATA_LENGTH_TOO_LONG);
				goto psk_err;
				}
			if (s->psk_server_callback == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				       SSL_R_PSK_NO_SERVER_CB);
				goto psk_err;
				}

			/* Create guaranteed NULL-terminated identity
			 * string for the callback */
			memcpy(tmp_id, p, i);
			memset(tmp_id+i, 0, PSK_MAX_IDENTITY_LEN+1-i);
			psk_len = s->psk_server_callback(s, tmp_id,
				psk_or_pre_ms, sizeof(psk_or_pre_ms));
			OPENSSL_cleanse(tmp_id, PSK_MAX_IDENTITY_LEN+1);

			if (psk_len > PSK_MAX_PSK_LEN)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					ERR_R_INTERNAL_ERROR);
				goto psk_err;
				}
			else if (psk_len == 0)
				{
				/* PSK related to the given identity not found */
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				       SSL_R_PSK_IDENTITY_NOT_FOUND);
				al=SSL_AD_UNKNOWN_PSK_IDENTITY;
				goto psk_err;
				}

			/* create PSK pre_master_secret */
			pre_ms_len=2+psk_len+2+psk_len;
			t = psk_or_pre_ms;
			memmove(psk_or_pre_ms+psk_len+4, psk_or_pre_ms, psk_len);
			s2n(psk_len, t);
			memset(t, 0, psk_len);
			t+=psk_len;
			s2n(psk_len, t);

			if (s->session->psk_identity != NULL)
				OPENSSL_free(s->session->psk_identity);
			s->session->psk_identity = BUF_strdup((char *)p);
			if (s->session->psk_identity == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto psk_err;
				}

			if (s->session->psk_identity_hint != NULL)
				OPENSSL_free(s->session->psk_identity_hint);
			s->session->psk_identity_hint = BUF_strdup(s->ctx->psk_identity_hint);
			if (s->ctx->psk_identity_hint != NULL &&
				s->session->psk_identity_hint == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto psk_err;
				}

			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key, psk_or_pre_ms, pre_ms_len);
			psk_err = 0;
		psk_err:
			OPENSSL_cleanse(psk_or_pre_ms, sizeof(psk_or_pre_ms));
			if (psk_err != 0)
				goto f_err;
			}
		else
#endif
		if (alg_k & SSL_kGOST) 
			{
			int ret = 0;
			EVP_PKEY_CTX *pkey_ctx;
			EVP_PKEY *client_pub_pkey = NULL;
			unsigned char premaster_secret[32], *start;
			size_t outlen=32, inlen;			

			/* Get our certificate private key*/
			pkey_ctx = EVP_PKEY_CTX_new(s->cert->key->privatekey,NULL);	
			EVP_PKEY_decrypt_init(pkey_ctx);
			/* If client certificate is present and is of the same type, maybe
			 * use it for key exchange.  Don't mind errors from
			 * EVP_PKEY_derive_set_peer, because it is completely valid to use
			 * a client certificate for authorization only. */
			client_pub_pkey = X509_get_pubkey(s->session->peer);
			if (client_pub_pkey)
				{
				if (EVP_PKEY_derive_set_peer(pkey_ctx, client_pub_pkey) <= 0)
					ERR_clear_error();
				}
			/* Decrypt session key */
			if ((*p!=( V_ASN1_SEQUENCE| V_ASN1_CONSTRUCTED))) 
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_DECRYPTION_FAILED);
				goto gerr;
				}
			if (p[1] == 0x81)
				{
				start = p+3;
				inlen = p[2];
				}
			else if (p[1] < 0x80)
				{
				start = p+2;
				inlen = p[1];
				}
			else
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_DECRYPTION_FAILED);
				goto gerr;
				}
			if (EVP_PKEY_decrypt(pkey_ctx,premaster_secret,&outlen,start,inlen) <=0) 

				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_DECRYPTION_FAILED);
				goto gerr;
				}
			/* Generate master secret */
			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,premaster_secret,32);
			/* Check if pubkey from client certificate was used */
			if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0)
				ret = 2;
			else
				ret = 1;
		gerr:
			EVP_PKEY_free(client_pub_pkey);
			EVP_PKEY_CTX_free(pkey_ctx);
			if (ret)
				return ret;
			else
				goto err;
			}
		else
d2368 9
a2376 19
	/* Check for broken implementations of GOST ciphersuites */
	/* If key is GOST and n is exactly 64, it is bare
	 * signature without length field */
	if (n==64 && (pkey->type==NID_id_GostR3410_94 ||
		pkey->type == NID_id_GostR3410_2001) )
		{
		i=64;
		} 
	else 
		{	
		n2s(p,i);
		n-=2;
		if (i > n)
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
			al=SSL_AD_DECODE_ERROR;
			goto f_err;
			}
    	}
a2438 22
	if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)
		{   unsigned char signature[64];
			int idx;
			EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);
			EVP_PKEY_verify_init(pctx);
			if (i!=64) {
				fprintf(stderr,"GOST signature length is %d",i);
			}	
			for (idx=0;idx<64;idx++) {
				signature[63-idx]=p[idx];
			}	
			j=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);
			EVP_PKEY_CTX_free(pctx);
			if (j<=0) 
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
					SSL_R_BAD_ECDSA_SIGNATURE);
				goto f_err;
				}	
		}
	else	
d2621 5
a2625 1
		if (x == NULL)
d2627 2
a2628 7
			/* VRS: allow null cert if auth == KRB5 */
			if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
			    (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5))
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,ERR_R_INTERNAL_ERROR);
				return(0);
				}
d2640 64
a2713 1
		SSL_CTX *tctx = s->initial_ctx;
d2752 1
a2752 1
		if (tctx->tlsext_ticket_key_cb)
d2754 1
a2754 1
			if (tctx->tlsext_ticket_key_cb(s, key_name, iv, &ctx,
d2765 2
a2766 2
					tctx->tlsext_tick_aes_key, iv);
			HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
d2768 1
a2768 1
			memcpy(key_name, tctx->tlsext_tick_key_name, 16);
@


1.1.1.13
log
@import OpenSSL 1.0.0e
@
text
@d771 3
a773 1
		 * which will now be aborted. (A full SSL_clear would be too much.) */
a780 7
#ifndef OPENSSL_NO_ECDH
		if (s->s3->tmp.ecdh != NULL)
			{
			EC_KEY_free(s->s3->tmp.ecdh);
			s->s3->tmp.ecdh = NULL;
			}
#endif
a987 4
/* Disabled because it can be used in a ciphersuite downgrade
 * attack: CVE-2010-4180.
 */
#if 0
a1001 1
#endif
d1489 1
d1550 1
d1561 1
a1561 1
			if ((ecdh = EC_KEY_dup(ecdhp)) == NULL)
d1566 1
a1728 1
			encodedPoint = NULL;
a2437 6
			if (n != 1 + i)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
				    ERR_R_EC_LIB);
				goto err;
				}
d2582 1
a2582 1
			EVP_PKEY *client_pub_pkey = NULL, *pk = NULL;
d2584 1
a2584 2
			size_t outlen=32, inlen;
			unsigned long alg_a;
d2587 1
a2587 7
			alg_a = s->s3->tmp.new_cipher->algorithm_auth;
			if (alg_a & SSL_aGOST94)
				pk = s->cert->pkeys[SSL_PKEY_GOST94].privatekey;
			else if (alg_a & SSL_aGOST01)
				pk = s->cert->pkeys[SSL_PKEY_GOST01].privatekey;

			pkey_ctx = EVP_PKEY_CTX_new(pk,NULL);
@


1.1.1.14
log
@OpenSSL 1.0.0f: import upstream source
@
text
@a260 1
			s->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE;
a757 8
	/* We only allow the client to restart the handshake once per
	 * negotiation. */
	if (s->s3->flags & SSL3_FLAGS_SGC_RESTART_DONE)
		{
		SSLerr(SSL_F_SSL3_CHECK_CLIENT_HELLO, SSL_R_MULTIPLE_SGC_RESTARTS);
		return -1;
		}

a785 1
		s->s3->flags |= SSL3_FLAGS_SGC_RESTART_DONE;
a2132 1
			BN_clear_free(pub);
@


1.1.1.15
log
@import OpenSSL-1.0.1c
@
text
@a181 25
#ifndef OPENSSL_NO_SRP
static int ssl_check_srp_ext_ClientHello(SSL *s, int *al)
	{
	int ret = SSL_ERROR_NONE;

	*al = SSL_AD_UNRECOGNIZED_NAME;

	if ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) &&
	    (s->srp_ctx.TLS_ext_srp_username_callback != NULL))
		{
		if(s->srp_ctx.login == NULL)
			{
			/* There isn't any srp login extension !!! */
			ret = SSL3_AL_FATAL;
			*al = SSL_AD_UNKNOWN_PSK_IDENTITY;
			}
		else
			{
			ret = SSL_srp_server_param_with_username(s,al);
			}
		}
	return ret;
	}
#endif

a213 12
#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

d221 1
a221 1
			s->renegotiate=1;
d317 4
a320 28
			if (s->rwstate != SSL_X509_LOOKUP)
			{
				ret=ssl3_get_client_hello(s);
				if (ret <= 0) goto end;
			}
#ifndef OPENSSL_NO_SRP
			{
			int al;
			if ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)
					{
					/* callback indicates firther work to be done */
					s->rwstate=SSL_X509_LOOKUP;
					goto end;
					}
			if (ret != SSL_ERROR_NONE)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,al);	
				/* This is not really an error but the only means to
                                   for a client to detect whether srp is supported. */
 				   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) 	
					SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);			
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;			
				ret= -1;
				goto end;	
				}
			}
#endif		
			s->renegotiate = 2;
d349 1
a349 1
			/* normal PSK or KRB5 or SRP */
a413 4
#ifndef OPENSSL_NO_SRP
			    /* SRP: send ServerKeyExchange */
			    || (alg_k & SSL_kSRP)
#endif
a459 3
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
a541 1
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
a542 6
#else
				if (s->s3->next_proto_neg_seen)
					s->state=SSL3_ST_SR_NEXT_PROTO_A;
				else
					s->state=SSL3_ST_SR_FINISHED_A;
#endif
a544 18
			else if (TLS1_get_version(s) >= TLS1_2_VERSION)
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
				if (!s->session->peer)
					break;
				/* For TLS v1.2 freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);
					return -1;
					}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!ssl3_digest_cached_records(s))
					return -1;
				}
a584 1
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
a585 6
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_SR_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_SR_FINISHED_A;
#endif
a588 10
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_SR_NEXT_PROTO_A:
		case SSL3_ST_SR_NEXT_PROTO_B:
			ret=ssl3_get_next_proto(s);
			if (ret <= 0) goto end;
			s->init_num = 0;
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
#endif

d594 6
a601 3
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
a658 2
				{
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
a659 7
#else
				if (s->s3->next_proto_neg_seen)
					s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;
				else
					s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
#endif
				}
d677 1
a677 1
			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
d679 3
a681 1
				s->renegotiate=0;
d759 8
a778 7
		/* We only allow the client to restart the handshake once per
		 * negotiation. */
		if (s->s3->flags & SSL3_FLAGS_SGC_RESTART_DONE)
			{
			SSLerr(SSL_F_SSL3_CHECK_CLIENT_HELLO, SSL_R_MULTIPLE_SGC_RESTARTS);
			return -1;
			}
d820 1
a820 2
	if (s->state == SSL3_ST_SR_CLNT_HELLO_A
		)
d877 7
a883 10
	/* Versions before 0.9.7 always allow clients to resume sessions in renegotiation.
	 * 0.9.7 and later allow this by default, but optionally ignore resumption requests
	 * with flag SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (it's a new flag rather
	 * than a change to default behavior so that applications relying on this for security
	 * won't even compile against older library versions).
	 *
	 * 1.0.1 and later also have a function SSL_renegotiate_abbreviated() to request
	 * renegotiation but not a new session (s->new_session remains unset): for servers,
	 * this essentially just means that the SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
	 * setting will be ignored.
d1272 2
a1273 5
	if (TLS1_get_version(s) < TLS1_2_VERSION || !(s->verify_mode & SSL_VERIFY_PEER))
		{
		if (!ssl3_digest_cached_records(s))
			goto f_err;
		}
d1328 14
a1341 14
		/* There are several cases for the session ID to send
		 * back in the server hello:
		 * - For session reuse from the session cache,
		 *   we send back the old session ID.
		 * - If stateless session reuse (using a session ticket)
		 *   is successful, we send back the client's "session ID"
		 *   (which doesn't actually identify the session).
		 * - If it is a new session, we send back the new
		 *   session ID.
		 * - However, if we want the new session to be single-use,
		 *   we send back a 0-length session ID.
		 * s->hit is non-zero in either case of session reuse,
		 * so the following won't overwrite an ID that we're supposed
		 * to send back.
a1441 1
	const EVP_MD *md = NULL;
a1681 18
#ifndef OPENSSL_NO_SRP
		if (type & SSL_kSRP)
			{
			if ((s->srp_ctx.N == NULL) ||
				(s->srp_ctx.g == NULL) ||
				(s->srp_ctx.s == NULL) ||
				(s->srp_ctx.B == NULL))
				{
				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_SRP_PARAM);
				goto err;
				}
			r[0]=s->srp_ctx.N;
			r[1]=s->srp_ctx.g;
			r[2]=s->srp_ctx.s;
			r[3]=s->srp_ctx.B;
			}
		else 
#endif
d1687 1
a1687 1
		for (i=0; r[i] != NULL && i<4; i++)
a1689 5
#ifndef OPENSSL_NO_SRP
			if ((i == 2) && (type & SSL_kSRP))
				n+=1+nr[i];
			else
#endif
d1696 1
a1696 1
			if ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher,&md))
d1718 1
a1718 1
		for (i=0; r[i] != NULL && i<4; i++)
a1719 8
#ifndef OPENSSL_NO_SRP
			if ((i == 2) && (type & SSL_kSRP))
				{
				*p = nr[i];
				p++;
				}
			else
#endif
d1767 1
a1767 2
			if (pkey->type == EVP_PKEY_RSA
					&& TLS1_get_version(s) < TLS1_2_VERSION)
a1772 2
					EVP_MD_CTX_set_flags(&md_ctx,
						EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d1794 2
a1795 1
			if (md)
d1797 7
a1803 3
				/* For TLS1.2 and later send signature
				 * algorithm */
				if (TLS1_get_version(s) >= TLS1_2_VERSION)
d1805 2
a1806 8
					if (!tls12_get_sigandhash(p, pkey, md))
						{
						/* Should never happen */
						al=SSL_AD_INTERNAL_ERROR;
						SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
						goto f_err;
						}
					p+=2;
d1808 4
a1811 3
#ifdef SSL_DEBUG
				fprintf(stderr, "Using hash %s\n",
							EVP_MD_name(md));
d1813 5
a1817 1
				EVP_SignInit_ex(&md_ctx, md, NULL);
d1824 1
a1824 1
					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_EVP);
a1828 2
				if (TLS1_get_version(s) >= TLS1_2_VERSION)
					n+= 2;
d1831 1
a1883 8
		if (TLS1_get_version(s) >= TLS1_2_VERSION)
			{
			nl = tls12_get_req_sig_algs(s, p + 2);
			s2n(nl, p);
			p += nl + 2;
			n += nl + 2;
			}

a2602 38
#ifndef OPENSSL_NO_SRP
		if (alg_k & SSL_kSRP)
			{
			int param_len;

			n2s(p,i);
			param_len=i+2;
			if (param_len > n)
				{
				al=SSL_AD_DECODE_ERROR;
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_SRP_A_LENGTH);
				goto f_err;
				}
			if (!(s->srp_ctx.A=BN_bin2bn(p,i,NULL)))
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,ERR_R_BN_LIB);
				goto err;
				}
			if (s->session->srp_username != NULL)
				OPENSSL_free(s->session->srp_username);
			s->session->srp_username = BUF_strdup(s->srp_ctx.login);
			if (s->session->srp_username == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto err;
				}

			if ((s->session->master_key_length = SRP_generate_server_master_secret(s,s->session->master_key))<0)
				{
				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
				goto err;
				}

			p+=i;
			}
		else
#endif	/* OPENSSL_NO_SRP */
d2686 1
a2686 1
#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH) || defined(OPENSSL_NO_SRP)
a2706 3
	const EVP_MD *md = NULL;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);
d2712 1
a2712 1
		516, /* Enough for 4096 bit RSA key with TLS v1.2 */
d2732 1
a2732 1
		if ((peer != NULL) && (type & EVP_PKT_SIGN))
a2774 30
		if (TLS1_get_version(s) >= TLS1_2_VERSION)
			{
			int sigalg = tls12_get_sigid(pkey);
			/* Should never happen */
			if (sigalg == -1)
				{
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);
				al=SSL_AD_INTERNAL_ERROR;
				goto f_err;
				}
			/* Check key type is consistent with signature */
			if (sigalg != (int)p[1])
				{
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_TYPE);
				al=SSL_AD_DECODE_ERROR;
				goto f_err;
				}
			md = tls12_get_hash(p[0]);
			if (md == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_UNKNOWN_DIGEST);
				al=SSL_AD_DECODE_ERROR;
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, "USING TLSv1.2 HASH %s\n", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
a2791 31
	if (TLS1_get_version(s) >= TLS1_2_VERSION)
		{
		long hdatalen = 0;
		void *hdata;
		hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
		if (hdatalen <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
			al=SSL_AD_INTERNAL_ERROR;
			goto f_err;
			}
#ifdef SSL_DEBUG
		fprintf(stderr, "Using TLS 1.2 with client verify alg %s\n",
							EVP_MD_name(md));
#endif
		if (!EVP_VerifyInit_ex(&mctx, md, NULL)
			|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);
			al=SSL_AD_INTERNAL_ERROR;
			goto f_err;
			}

		if (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);
			goto f_err;
			}
		}
	else
a2881 7
	if (s->s3->handshake_buffer)
		{
		BIO_free(s->s3->handshake_buffer);
		s->s3->handshake_buffer = NULL;
		s->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;
		}
	EVP_MD_CTX_cleanup(&mctx);
a2993 6
		/* No client certificate so digest cached records */
		if (s->s3->handshake_buffer && !ssl3_digest_cached_records(s))
			{
			al=SSL_AD_INTERNAL_ERROR;
			goto f_err;
			}
a3069 1

a3070 1
/* send a new session ticket (not necessarily for a new session) */
d3076 1
a3076 3
		const unsigned char *const_p;
		int len, slen_full, slen;
		SSL_SESSION *sess;
d3085 1
a3085 1
		slen_full = i2d_SSL_SESSION(s->session, NULL);
d3089 1
a3089 4
		if (slen_full > 0xFF00)
			return -1;
		senc = OPENSSL_malloc(slen_full);
		if (!senc)
a3090 23
		p = senc;
		i2d_SSL_SESSION(s->session, &p);

		/* create a fresh copy (not shared with other threads) to clean up */
		const_p = senc;
		sess = d2i_SSL_SESSION(NULL, &const_p, slen_full);
		if (sess == NULL)
			{
			OPENSSL_free(senc);
			return -1;
			}
		sess->session_id_length = 0; /* ID is irrelevant for the ticket */

		slen = i2d_SSL_SESSION(sess, NULL);
		if (slen > slen_full) /* shouldn't ever happen */
			{
			OPENSSL_free(senc);
			return -1;
			}
		p = senc;
		i2d_SSL_SESSION(sess, &p);
		SSL_SESSION_free(sess);

d3102 5
d3137 1
a3137 7

		/* Ticket lifetime hint (advisory only):
		 * We leave this unspecified for resumed session (for simplicity),
		 * and guess that tickets for new sessions will live as long
		 * as their sessions. */
		l2n(s->hit ? 0 : s->session->timeout, p);

a3211 68

# ifndef OPENSSL_NO_NEXTPROTONEG
/* ssl3_get_next_proto reads a Next Protocol Negotiation handshake message. It
 * sets the next_proto member in s if found */
int ssl3_get_next_proto(SSL *s)
	{
	int ok;
	int proto_len, padding_len;
	long n;
	const unsigned char *p;

	/* Clients cannot send a NextProtocol message if we didn't see the
	 * extension in their ClientHello */
	if (!s->s3->next_proto_neg_seen)
		{
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO,SSL_R_GOT_NEXT_PROTO_WITHOUT_EXTENSION);
		return -1;
		}

	n=s->method->ssl_get_message(s,
		SSL3_ST_SR_NEXT_PROTO_A,
		SSL3_ST_SR_NEXT_PROTO_B,
		SSL3_MT_NEXT_PROTO,
		514,  /* See the payload format below */
		&ok);

	if (!ok)
		return((int)n);

	/* s->state doesn't reflect whether ChangeCipherSpec has been received
	 * in this handshake, but s->s3->change_cipher_spec does (will be reset
	 * by ssl3_get_finished). */
	if (!s->s3->change_cipher_spec)
		{
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO,SSL_R_GOT_NEXT_PROTO_BEFORE_A_CCS);
		return -1;
		}

	if (n < 2)
		return 0;  /* The body must be > 1 bytes long */

	p=(unsigned char *)s->init_msg;

	/* The payload looks like:
	 *   uint8 proto_len;
	 *   uint8 proto[proto_len];
	 *   uint8 padding_len;
	 *   uint8 padding[padding_len];
	 */
	proto_len = p[0];
	if (proto_len + 2 > s->init_num)
		return 0;
	padding_len = p[proto_len + 1];
	if (proto_len + padding_len + 2 != s->init_num)
		return 0;

	s->next_proto_negotiated = OPENSSL_malloc(proto_len);
	if (!s->next_proto_negotiated)
		{
		SSLerr(SSL_F_SSL3_GET_NEXT_PROTO,ERR_R_MALLOC_FAILURE);
		return 0;
		}
	memcpy(s->next_proto_negotiated, p + 1, proto_len);
	s->next_proto_negotiated_len = proto_len;

	return 1;
	}
# endif
@


1.1.1.16
log
@Import OpenSSL 1.0.1g
@
text
@d194 1
a194 2
			/* RFC 5054 says SHOULD reject, 
			   we do so if There is no srp login name */
a380 1
			
d959 1
a959 2
		if ((s->client_version>>8) == SSL3_VERSION_MAJOR && 
			!s->enc_write_ctx && !s->write_hash)
d1184 1
a1184 1
		if (ssl_check_clienthello_tlsext_early(s) <= 0) {
d1194 1
d1196 1
d1198 2
a1199 1
		if (ssl_fill_hello_random(s, 1, pos, SSL3_RANDOM_SIZE) <= 0)
a1391 2
			{
			al = SSL_AD_INTERNAL_ERROR;
a1392 1
			}
a1405 10
	/* Handles TLS extensions that we couldn't check earlier */
	if (s->version >= SSL3_VERSION)
		{
		if (ssl_check_clienthello_tlsext_late(s) <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
			goto err;
			}
		}

d1423 3
d1432 4
a1435 1
		if (ssl_fill_hello_random(s, 1, p, SSL3_RANDOM_SIZE) <= 0)
d1826 1
a1826 1
		for (i=0; i < 4 && r[i] != NULL; i++)
d1862 1
a1862 1
		for (i=0; i < 4 && r[i] != NULL; i++)
@


