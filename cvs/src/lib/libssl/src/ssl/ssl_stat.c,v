head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	butholakala:1.6
	openssl_1_0_1_g:1.1.1.4
	OPENBSD_5_5:1.6.0.16
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.12
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.10
	OPENBSD_5_3_BASE:1.6
	openssl_1_0_1_c:1.1.1.4
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	openssl_1_0_0_f:1.1.1.4
	openssl_1_0_0_e:1.1.1.4
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	openssh_1_0_0_a:1.1.1.4
	OPENBSD_4_8:1.5.0.8
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	openssl_0_9_8_k:1.1.1.3
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	openssl_0_9_8_j:1.1.1.3
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.4
	OPENBSD_4_4:1.4.0.26
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.24
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.22
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.20
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.18
	OPENBSD_4_0_BASE:1.4
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.11;
commitid	M3pvHgIFoWUHNqJn;

1.11
date	2014.07.13.00.08.44;	author jsing;	state Exp;
branches;
next	1.10;
commitid	3EcE2iqzmd9phLc8;

1.10
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	mJUVYpkFBZ0Zv2bG;

1.9
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.15.21.47.56;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.14.13.10.35;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.06.12.17.54;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.34;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.30;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.13;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.13;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.43;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Sort and group includes.
@
text
@/* $OpenBSD: ssl_stat.c,v 1.11 2014/07/13 00:08:44 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#include <stdio.h>

#include "ssl_locl.h"

const char *
SSL_state_string_long(const SSL *s)
{
	const char *str;

	switch (s->state) {
	case SSL_ST_BEFORE:
		str = "before SSL initialization";
		break;
	case SSL_ST_ACCEPT:
		str = "before accept initialization";
		break;
	case SSL_ST_CONNECT:
		str = "before connect initialization";
		break;
	case SSL_ST_OK:
		str = "SSL negotiation finished successfully";
		break;
	case SSL_ST_RENEGOTIATE:
		str = "SSL renegotiate ciphers";
		break;
	case SSL_ST_BEFORE|SSL_ST_CONNECT:
		str = "before/connect initialization";
		break;
	case SSL_ST_OK|SSL_ST_CONNECT:
		str = "ok/connect SSL initialization";
		break;
	case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		str = "before/accept initialization";
		break;
	case SSL_ST_OK|SSL_ST_ACCEPT:
		str = "ok/accept SSL initialization";
		break;

	/* SSLv3 additions */
	case SSL3_ST_CW_CLNT_HELLO_A:
		str = "SSLv3 write client hello A";
		break;
	case SSL3_ST_CW_CLNT_HELLO_B:
		str = "SSLv3 write client hello B";
		break;
	case SSL3_ST_CR_SRVR_HELLO_A:
		str = "SSLv3 read server hello A";
		break;
	case SSL3_ST_CR_SRVR_HELLO_B:
		str = "SSLv3 read server hello B";
		break;
	case SSL3_ST_CR_CERT_A:
		str = "SSLv3 read server certificate A";
		break;
	case SSL3_ST_CR_CERT_B:
		str = "SSLv3 read server certificate B";
		break;
	case SSL3_ST_CR_KEY_EXCH_A:
		str = "SSLv3 read server key exchange A";
		break;
	case SSL3_ST_CR_KEY_EXCH_B:
		str = "SSLv3 read server key exchange B";
		break;
	case SSL3_ST_CR_CERT_REQ_A:
		str = "SSLv3 read server certificate request A";
		break;
	case SSL3_ST_CR_CERT_REQ_B:
		str = "SSLv3 read server certificate request B";
		break;
	case SSL3_ST_CR_SESSION_TICKET_A:
		str = "SSLv3 read server session ticket A";
		break;
	case SSL3_ST_CR_SESSION_TICKET_B:
		str = "SSLv3 read server session ticket B";
		break;
	case SSL3_ST_CR_SRVR_DONE_A:
		str = "SSLv3 read server done A";
		break;
	case SSL3_ST_CR_SRVR_DONE_B:
		str = "SSLv3 read server done B";
		break;
	case SSL3_ST_CW_CERT_A:
		str = "SSLv3 write client certificate A";
		break;
	case SSL3_ST_CW_CERT_B:
		str = "SSLv3 write client certificate B";
		break;
	case SSL3_ST_CW_CERT_C:
		str = "SSLv3 write client certificate C";
		break;
	case SSL3_ST_CW_CERT_D:
		str = "SSLv3 write client certificate D";
		break;
	case SSL3_ST_CW_KEY_EXCH_A:
		str = "SSLv3 write client key exchange A";
		break;
	case SSL3_ST_CW_KEY_EXCH_B:
		str = "SSLv3 write client key exchange B";
		break;
	case SSL3_ST_CW_CERT_VRFY_A:
		str = "SSLv3 write certificate verify A";
		break;
	case SSL3_ST_CW_CERT_VRFY_B:
		str = "SSLv3 write certificate verify B";
		break;

	case SSL3_ST_CW_CHANGE_A:
	case SSL3_ST_SW_CHANGE_A:
		str = "SSLv3 write change cipher spec A";
		break;
	case SSL3_ST_CW_CHANGE_B:
	case SSL3_ST_SW_CHANGE_B:
		str = "SSLv3 write change cipher spec B";
		break;
	case SSL3_ST_CW_FINISHED_A:
	case SSL3_ST_SW_FINISHED_A:
		str = "SSLv3 write finished A";
		break;
	case SSL3_ST_CW_FINISHED_B:
	case SSL3_ST_SW_FINISHED_B:
		str = "SSLv3 write finished B";
		break;
	case SSL3_ST_CR_CHANGE_A:
	case SSL3_ST_SR_CHANGE_A:
		str = "SSLv3 read change cipher spec A";
		break;
	case SSL3_ST_CR_CHANGE_B:
	case SSL3_ST_SR_CHANGE_B:
		str = "SSLv3 read change cipher spec B";
		break;
	case SSL3_ST_CR_FINISHED_A:
	case SSL3_ST_SR_FINISHED_A:
		str = "SSLv3 read finished A";
		break;
	case SSL3_ST_CR_FINISHED_B:
	case SSL3_ST_SR_FINISHED_B:
		str = "SSLv3 read finished B";
		break;

	case SSL3_ST_CW_FLUSH:
	case SSL3_ST_SW_FLUSH:
		str = "SSLv3 flush data";
		break;

	case SSL3_ST_SR_CLNT_HELLO_A:
		str = "SSLv3 read client hello A";
		break;
	case SSL3_ST_SR_CLNT_HELLO_B:
		str = "SSLv3 read client hello B";
		break;
	case SSL3_ST_SR_CLNT_HELLO_C:
		str = "SSLv3 read client hello C";
		break;
	case SSL3_ST_SW_HELLO_REQ_A:
		str = "SSLv3 write hello request A";
		break;
	case SSL3_ST_SW_HELLO_REQ_B:
		str = "SSLv3 write hello request B";
		break;
	case SSL3_ST_SW_HELLO_REQ_C:
		str = "SSLv3 write hello request C";
		break;
	case SSL3_ST_SW_SRVR_HELLO_A:
		str = "SSLv3 write server hello A";
		break;
	case SSL3_ST_SW_SRVR_HELLO_B:
		str = "SSLv3 write server hello B";
		break;
	case SSL3_ST_SW_CERT_A:
		str = "SSLv3 write certificate A";
		break;
	case SSL3_ST_SW_CERT_B:
		str = "SSLv3 write certificate B";
		break;
	case SSL3_ST_SW_KEY_EXCH_A:
		str = "SSLv3 write key exchange A";
		break;
	case SSL3_ST_SW_KEY_EXCH_B:
		str = "SSLv3 write key exchange B";
		break;
	case SSL3_ST_SW_CERT_REQ_A:
		str = "SSLv3 write certificate request A";
		break;
	case SSL3_ST_SW_CERT_REQ_B:
		str = "SSLv3 write certificate request B";
		break;
	case SSL3_ST_SW_SESSION_TICKET_A:
		str = "SSLv3 write session ticket A";
		break;
	case SSL3_ST_SW_SESSION_TICKET_B:
		str = "SSLv3 write session ticket B";
		break;
	case SSL3_ST_SW_SRVR_DONE_A:
		str = "SSLv3 write server done A";
		break;
	case SSL3_ST_SW_SRVR_DONE_B:
		str = "SSLv3 write server done B";
		break;
	case SSL3_ST_SR_CERT_A:
		str = "SSLv3 read client certificate A";
		break;
	case SSL3_ST_SR_CERT_B:
		str = "SSLv3 read client certificate B";
		break;
	case SSL3_ST_SR_KEY_EXCH_A:
		str = "SSLv3 read client key exchange A";
		break;
	case SSL3_ST_SR_KEY_EXCH_B:
		str = "SSLv3 read client key exchange B";
		break;
	case SSL3_ST_SR_CERT_VRFY_A:
		str = "SSLv3 read certificate verify A";
		break;
	case SSL3_ST_SR_CERT_VRFY_B:
		str = "SSLv3 read certificate verify B";
		break;

	/* DTLS */
	case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A:
		str = "DTLS1 read hello verify request A";
		break;
	case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B:
		str = "DTLS1 read hello verify request B";
		break;
	case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:
		str = "DTLS1 write hello verify request A";
		break;
	case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:
		str = "DTLS1 write hello verify request B";
		break;

	default:
		str = "unknown state";
		break;
	}
	return (str);
}

const char *
SSL_rstate_string_long(const SSL *s)
{
	const char *str;

	switch (s->rstate) {
	case SSL_ST_READ_HEADER:
		str = "read header";
		break;
	case SSL_ST_READ_BODY:
		str = "read body";
		break;
	case SSL_ST_READ_DONE:
		str = "read done";
		break;
	default:
		str = "unknown";
		break;
	}
	return (str);
}

const char *
SSL_state_string(const SSL *s)
{
	const char *str;

	switch (s->state) {
	case SSL_ST_BEFORE:
		str = "PINIT ";
		break;
	case SSL_ST_ACCEPT:
		str = "AINIT ";
		break;
	case SSL_ST_CONNECT:
		str = "CINIT ";
		break;
	case SSL_ST_OK:
		str = "SSLOK ";
		break;

	/* SSLv3 additions */
	case SSL3_ST_SW_FLUSH:
	case SSL3_ST_CW_FLUSH:
		str = "3FLUSH";
		break;
	case SSL3_ST_CW_CLNT_HELLO_A:
		str = "3WCH_A";
		break;
	case SSL3_ST_CW_CLNT_HELLO_B:
		str = "3WCH_B";
		break;
	case SSL3_ST_CR_SRVR_HELLO_A:
		str = "3RSH_A";
		break;
	case SSL3_ST_CR_SRVR_HELLO_B:
		str = "3RSH_B";
		break;
	case SSL3_ST_CR_CERT_A:
		str = "3RSC_A";
		break;
	case SSL3_ST_CR_CERT_B:
		str = "3RSC_B";
		break;
	case SSL3_ST_CR_KEY_EXCH_A:
		str = "3RSKEA";
		break;
	case SSL3_ST_CR_KEY_EXCH_B:
		str = "3RSKEB";
		break;
	case SSL3_ST_CR_CERT_REQ_A:
		str = "3RCR_A";
		break;
	case SSL3_ST_CR_CERT_REQ_B:
		str = "3RCR_B";
		break;
	case SSL3_ST_CR_SRVR_DONE_A:
		str = "3RSD_A";
		break;
	case SSL3_ST_CR_SRVR_DONE_B:
		str = "3RSD_B";
		break;
	case SSL3_ST_CW_CERT_A:
		str = "3WCC_A";
		break;
	case SSL3_ST_CW_CERT_B:
		str = "3WCC_B";
		break;
	case SSL3_ST_CW_CERT_C:
		str = "3WCC_C";
		break;
	case SSL3_ST_CW_CERT_D:
		str = "3WCC_D";
		break;
	case SSL3_ST_CW_KEY_EXCH_A:
		str = "3WCKEA";
		break;
	case SSL3_ST_CW_KEY_EXCH_B:
		str = "3WCKEB";
		break;
	case SSL3_ST_CW_CERT_VRFY_A:
		str = "3WCV_A";
		break;
	case SSL3_ST_CW_CERT_VRFY_B:
		str = "3WCV_B";
		break;

	case SSL3_ST_SW_CHANGE_A:
	case SSL3_ST_CW_CHANGE_A:
		str = "3WCCSA";
		break;
	case SSL3_ST_SW_CHANGE_B:
	case SSL3_ST_CW_CHANGE_B:
		str = "3WCCSB";
		break;
	case SSL3_ST_SW_FINISHED_A:
	case SSL3_ST_CW_FINISHED_A:
		str = "3WFINA";
		break;
	case SSL3_ST_SW_FINISHED_B:
	case SSL3_ST_CW_FINISHED_B:
		str = "3WFINB";
		break;
	case SSL3_ST_SR_CHANGE_A:
	case SSL3_ST_CR_CHANGE_A:
		str = "3RCCSA";
		break;
	case SSL3_ST_SR_CHANGE_B:
	case SSL3_ST_CR_CHANGE_B:
		str = "3RCCSB";
		break;
	case SSL3_ST_SR_FINISHED_A:
	case SSL3_ST_CR_FINISHED_A:
		str = "3RFINA";
		break;
	case SSL3_ST_SR_FINISHED_B:
	case SSL3_ST_CR_FINISHED_B:
		str = "3RFINB";
		break;

	case SSL3_ST_SW_HELLO_REQ_A:
		str = "3WHR_A";
		break;
	case SSL3_ST_SW_HELLO_REQ_B:
		str = "3WHR_B";
		break;
	case SSL3_ST_SW_HELLO_REQ_C:
		str = "3WHR_C";
		break;
	case SSL3_ST_SR_CLNT_HELLO_A:
		str = "3RCH_A";
		break;
	case SSL3_ST_SR_CLNT_HELLO_B:
		str = "3RCH_B";
		break;
	case SSL3_ST_SR_CLNT_HELLO_C:
		str = "3RCH_C";
		break;
	case SSL3_ST_SW_SRVR_HELLO_A:
		str = "3WSH_A";
		break;
	case SSL3_ST_SW_SRVR_HELLO_B:
		str = "3WSH_B";
		break;
	case SSL3_ST_SW_CERT_A:
		str = "3WSC_A";
		break;
	case SSL3_ST_SW_CERT_B:
		str = "3WSC_B";
		break;
	case SSL3_ST_SW_KEY_EXCH_A:
		str = "3WSKEA";
		break;
	case SSL3_ST_SW_KEY_EXCH_B:
		str = "3WSKEB";
		break;
	case SSL3_ST_SW_CERT_REQ_A:
		str = "3WCR_A";
		break;
	case SSL3_ST_SW_CERT_REQ_B:
		str = "3WCR_B";
		break;
	case SSL3_ST_SW_SRVR_DONE_A:
		str = "3WSD_A";
		break;
	case SSL3_ST_SW_SRVR_DONE_B:
		str = "3WSD_B";
		break;
	case SSL3_ST_SR_CERT_A:
		str = "3RCC_A";
		break;
	case SSL3_ST_SR_CERT_B:
		str = "3RCC_B";
		break;
	case SSL3_ST_SR_KEY_EXCH_A:
		str = "3RCKEA";
		break;
	case SSL3_ST_SR_KEY_EXCH_B:
		str = "3RCKEB";
		break;
	case SSL3_ST_SR_CERT_VRFY_A:
		str = "3RCV_A";
		break;
	case SSL3_ST_SR_CERT_VRFY_B:
		str = "3RCV_B";
		break;

	/* DTLS */
	case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A:
		str = "DRCHVA";
		break;
	case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B:
		str = "DRCHVB";
		break;
	case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:
		str = "DWCHVA";
		break;
	case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:
		str = "DWCHVB";
		break;

	default:
		str = "UNKWN ";
		break;
	}
	return (str);
}

const char *
SSL_alert_type_string_long(int value)
{
	value >>= 8;
	if (value == SSL3_AL_WARNING)
		return ("warning");
	else if (value == SSL3_AL_FATAL)
		return ("fatal");
	else
		return ("unknown");
}

const char *
SSL_alert_type_string(int value)
{
	value >>= 8;
	if (value == SSL3_AL_WARNING)
		return ("W");
	else if (value == SSL3_AL_FATAL)
		return ("F");
	else
		return ("U");
}

const char *
SSL_alert_desc_string(int value)
{
	const char *str;

	switch (value & 0xff) {
	case SSL3_AD_CLOSE_NOTIFY:
		str = "CN";
		break;
	case SSL3_AD_UNEXPECTED_MESSAGE:
		str = "UM";
		break;
	case SSL3_AD_BAD_RECORD_MAC:
		str = "BM";
		break;
	case SSL3_AD_DECOMPRESSION_FAILURE:
		str = "DF";
		break;
	case SSL3_AD_HANDSHAKE_FAILURE:
		str = "HF";
		break;
	case SSL3_AD_NO_CERTIFICATE:
		str = "NC";
		break;
	case SSL3_AD_BAD_CERTIFICATE:
		str = "BC";
		break;
	case SSL3_AD_UNSUPPORTED_CERTIFICATE:
		str = "UC";
		break;
	case SSL3_AD_CERTIFICATE_REVOKED:
		str = "CR";
		break;
	case SSL3_AD_CERTIFICATE_EXPIRED:
		str = "CE";
		break;
	case SSL3_AD_CERTIFICATE_UNKNOWN:
		str = "CU";
		break;
	case SSL3_AD_ILLEGAL_PARAMETER:
		str = "IP";
		break;
	case TLS1_AD_DECRYPTION_FAILED:
		str = "DC";
		break;
	case TLS1_AD_RECORD_OVERFLOW:
		str = "RO";
		break;
	case TLS1_AD_UNKNOWN_CA:
		str = "CA";
		break;
	case TLS1_AD_ACCESS_DENIED:
		str = "AD";
		break;
	case TLS1_AD_DECODE_ERROR:
		str = "DE";
		break;
	case TLS1_AD_DECRYPT_ERROR:
		str = "CY";
		break;
	case TLS1_AD_EXPORT_RESTRICTION:
		str = "ER";
		break;
	case TLS1_AD_PROTOCOL_VERSION:
		str = "PV";
		break;
	case TLS1_AD_INSUFFICIENT_SECURITY:
		str = "IS";
		break;
	case TLS1_AD_INTERNAL_ERROR:
		str = "IE";
		break;
	case TLS1_AD_USER_CANCELLED:
		str = "US";
		break;
	case TLS1_AD_NO_RENEGOTIATION:
		str = "NR";
		break;
	case TLS1_AD_UNSUPPORTED_EXTENSION:
		str = "UE";
		break;
	case TLS1_AD_CERTIFICATE_UNOBTAINABLE:
		str = "CO";
		break;
	case TLS1_AD_UNRECOGNIZED_NAME:
		str = "UN";
		break;
	case TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE:
		str = "BR";
		break;
	case TLS1_AD_BAD_CERTIFICATE_HASH_VALUE:
		str = "BH";
		break;
	case TLS1_AD_UNKNOWN_PSK_IDENTITY:
		str = "UP";
		break;
	default:
		str = "UK";
		break;
	}
	return (str);
}

const char *
SSL_alert_desc_string_long(int value)
{
	const char *str;

	switch (value & 0xff) {
	case SSL3_AD_CLOSE_NOTIFY:
		str = "close notify";
		break;
	case SSL3_AD_UNEXPECTED_MESSAGE:
		str = "unexpected_message";
		break;
	case SSL3_AD_BAD_RECORD_MAC:
		str = "bad record mac";
		break;
	case SSL3_AD_DECOMPRESSION_FAILURE:
		str = "decompression failure";
		break;
	case SSL3_AD_HANDSHAKE_FAILURE:
		str = "handshake failure";
		break;
	case SSL3_AD_NO_CERTIFICATE:
		str = "no certificate";
		break;
	case SSL3_AD_BAD_CERTIFICATE:
		str = "bad certificate";
		break;
	case SSL3_AD_UNSUPPORTED_CERTIFICATE:
		str = "unsupported certificate";
		break;
	case SSL3_AD_CERTIFICATE_REVOKED:
		str = "certificate revoked";
		break;
	case SSL3_AD_CERTIFICATE_EXPIRED:
		str = "certificate expired";
		break;
	case SSL3_AD_CERTIFICATE_UNKNOWN:
		str = "certificate unknown";
		break;
	case SSL3_AD_ILLEGAL_PARAMETER:
		str = "illegal parameter";
		break;
	case TLS1_AD_DECRYPTION_FAILED:
		str = "decryption failed";
		break;
	case TLS1_AD_RECORD_OVERFLOW:
		str = "record overflow";
		break;
	case TLS1_AD_UNKNOWN_CA:
		str = "unknown CA";
		break;
	case TLS1_AD_ACCESS_DENIED:
		str = "access denied";
		break;
	case TLS1_AD_DECODE_ERROR:
		str = "decode error";
		break;
	case TLS1_AD_DECRYPT_ERROR:
		str = "decrypt error";
		break;
	case TLS1_AD_EXPORT_RESTRICTION:
		str = "export restriction";
		break;
	case TLS1_AD_PROTOCOL_VERSION:
		str = "protocol version";
		break;
	case TLS1_AD_INSUFFICIENT_SECURITY:
		str = "insufficient security";
		break;
	case TLS1_AD_INTERNAL_ERROR:
		str = "internal error";
		break;
	case TLS1_AD_USER_CANCELLED:
		str = "user canceled";
		break;
	case TLS1_AD_NO_RENEGOTIATION:
		str = "no renegotiation";
		break;
	case TLS1_AD_UNSUPPORTED_EXTENSION:
		str = "unsupported extension";
		break;
	case TLS1_AD_CERTIFICATE_UNOBTAINABLE:
		str = "certificate unobtainable";
		break;
	case TLS1_AD_UNRECOGNIZED_NAME:
		str = "unrecognized name";
		break;
	case TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE:
		str = "bad certificate status response";
		break;
	case TLS1_AD_BAD_CERTIFICATE_HASH_VALUE:
		str = "bad certificate hash value";
		break;
	case TLS1_AD_UNKNOWN_PSK_IDENTITY:
		str = "unknown PSK identity";
		break;
	default:
		str = "unknown";
		break;
	}
	return (str);
}

const char *
SSL_rstate_string(const SSL *s)
{
	const char *str;

	switch (s->rstate) {
	case SSL_ST_READ_HEADER:
		str = "RH";
		break;
	case SSL_ST_READ_BODY:
		str = "RB";
		break;
	case SSL_ST_READ_DONE:
		str = "RD";
		break;
	default:
		str = "unknown";
		break;
	}
	return (str);
}
@


1.11
log
@Another large dose of KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_stat.c,v 1.10 2014/06/12 15:49:31 deraadt Exp $ */
d86 1
@


1.10
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d95 2
a96 1
		str="before SSL initialization"; break;
d98 2
a99 1
		str="before accept initialization"; break;
d101 2
a102 1
		str="before connect initialization"; break;
d104 2
a105 1
		str="SSL negotiation finished successfully"; break;
d107 2
a108 1
		str="SSL renegotiate ciphers"; break;
d110 2
a111 1
		str="before/connect initialization"; break;
d113 2
a114 1
		str="ok/connect SSL initialization"; break;
d116 2
a117 1
		str="before/accept initialization"; break;
d119 4
a122 2
		str="ok/accept SSL initialization"; break;
/* SSLv3 additions */
d124 2
a125 1
		str="SSLv3 write client hello A"; break;
d127 2
a128 1
		str="SSLv3 write client hello B"; break;
d130 2
a131 1
		str="SSLv3 read server hello A"; break;
d133 2
a134 1
		str="SSLv3 read server hello B"; break;
d136 2
a137 1
		str="SSLv3 read server certificate A"; break;
d139 2
a140 1
		str="SSLv3 read server certificate B"; break;
d142 2
a143 1
		str="SSLv3 read server key exchange A"; break;
d145 2
a146 1
		str="SSLv3 read server key exchange B"; break;
d148 2
a149 1
		str="SSLv3 read server certificate request A"; break;
d151 2
a152 1
		str="SSLv3 read server certificate request B"; break;
d154 2
a155 1
		str="SSLv3 read server session ticket A";break;
d157 2
a158 1
		str="SSLv3 read server session ticket B";break;
d160 2
a161 1
		str="SSLv3 read server done A"; break;
d163 2
a164 1
		str="SSLv3 read server done B"; break;
d166 2
a167 1
		str="SSLv3 write client certificate A"; break;
d169 2
a170 1
		str="SSLv3 write client certificate B"; break;
d172 2
a173 1
		str="SSLv3 write client certificate C"; break;
d175 2
a176 1
		str="SSLv3 write client certificate D"; break;
d178 2
a179 1
		str="SSLv3 write client key exchange A"; break;
d181 2
a182 1
		str="SSLv3 write client key exchange B"; break;
d184 2
a185 1
		str="SSLv3 write certificate verify A"; break;
d187 2
a188 1
		str="SSLv3 write certificate verify B"; break;
d190 1
a190 1
		case SSL3_ST_CW_CHANGE_A:
d192 3
a194 2
		str="SSLv3 write change cipher spec A"; break;
		case SSL3_ST_CW_CHANGE_B:
d196 3
a198 2
		str="SSLv3 write change cipher spec B"; break;
		case SSL3_ST_CW_FINISHED_A:
d200 3
a202 2
		str="SSLv3 write finished A"; break;
		case SSL3_ST_CW_FINISHED_B:
d204 3
a206 2
		str="SSLv3 write finished B"; break;
		case SSL3_ST_CR_CHANGE_A:
d208 3
a210 2
		str="SSLv3 read change cipher spec A"; break;
		case SSL3_ST_CR_CHANGE_B:
d212 3
a214 2
		str="SSLv3 read change cipher spec B"; break;
		case SSL3_ST_CR_FINISHED_A:
d216 3
a218 2
		str="SSLv3 read finished A"; break;
		case SSL3_ST_CR_FINISHED_B:
d220 2
a221 1
		str="SSLv3 read finished B"; break;
d223 1
a223 1
		case SSL3_ST_CW_FLUSH:
d225 2
a226 1
		str="SSLv3 flush data"; break;
d229 2
a230 1
		str="SSLv3 read client hello A"; break;
d232 2
a233 1
		str="SSLv3 read client hello B"; break;
d235 2
a236 1
		str="SSLv3 read client hello C"; break;
d238 2
a239 1
		str="SSLv3 write hello request A"; break;
d241 2
a242 1
		str="SSLv3 write hello request B"; break;
d244 2
a245 1
		str="SSLv3 write hello request C"; break;
d247 2
a248 1
		str="SSLv3 write server hello A"; break;
d250 2
a251 1
		str="SSLv3 write server hello B"; break;
d253 2
a254 1
		str="SSLv3 write certificate A"; break;
d256 2
a257 1
		str="SSLv3 write certificate B"; break;
d259 2
a260 1
		str="SSLv3 write key exchange A"; break;
d262 2
a263 1
		str="SSLv3 write key exchange B"; break;
d265 2
a266 1
		str="SSLv3 write certificate request A"; break;
d268 2
a269 1
		str="SSLv3 write certificate request B"; break;
d271 2
a272 1
		str="SSLv3 write session ticket A"; break;
d274 2
a275 1
		str="SSLv3 write session ticket B"; break;
d277 2
a278 1
		str="SSLv3 write server done A"; break;
d280 2
a281 1
		str="SSLv3 write server done B"; break;
d283 2
a284 1
		str="SSLv3 read client certificate A"; break;
d286 2
a287 1
		str="SSLv3 read client certificate B"; break;
d289 2
a290 1
		str="SSLv3 read client key exchange A"; break;
d292 2
a293 1
		str="SSLv3 read client key exchange B"; break;
d295 2
a296 1
		str="SSLv3 read certificate verify A"; break;
d298 2
a299 1
		str="SSLv3 read certificate verify B"; break;
d301 1
a301 1
/* DTLS */
d303 2
a304 1
		str="DTLS1 read hello verify request A"; break;
d306 2
a307 1
		str="DTLS1 read hello verify request B"; break;
d309 2
a310 1
		str="DTLS1 write hello verify request A"; break;
d312 2
a313 1
		str="DTLS1 write hello verify request B"; break;
d316 2
a317 1
		str="unknown state"; break;
d329 2
a330 1
		str="read header"; break;
d332 2
a333 1
		str="read body"; break;
d335 2
a336 1
		str="read done"; break;
d338 2
a339 1
		str="unknown"; break;
d351 2
a352 1
		str="PINIT "; break;
d354 2
a355 1
		str="AINIT "; break;
d357 2
a358 1
		str="CINIT "; break;
d360 2
a361 1
		str="SSLOK "; break;
d363 2
a364 2
/* SSLv3 additions */
		case SSL3_ST_SW_FLUSH:
d366 2
a367 1
		str="3FLUSH"; break;
d369 2
a370 1
		str="3WCH_A"; break;
d372 2
a373 1
		str="3WCH_B"; break;
d375 2
a376 1
		str="3RSH_A"; break;
d378 2
a379 1
		str="3RSH_B"; break;
d381 2
a382 1
		str="3RSC_A"; break;
d384 2
a385 1
		str="3RSC_B"; break;
d387 2
a388 1
		str="3RSKEA"; break;
d390 2
a391 1
		str="3RSKEB"; break;
d393 2
a394 1
		str="3RCR_A"; break;
d396 2
a397 1
		str="3RCR_B"; break;
d399 2
a400 1
		str="3RSD_A"; break;
d402 2
a403 1
		str="3RSD_B"; break;
d405 2
a406 1
		str="3WCC_A"; break;
d408 2
a409 1
		str="3WCC_B"; break;
d411 2
a412 1
		str="3WCC_C"; break;
d414 2
a415 1
		str="3WCC_D"; break;
d417 2
a418 1
		str="3WCKEA"; break;
d420 2
a421 1
		str="3WCKEB"; break;
d423 2
a424 1
		str="3WCV_A"; break;
d426 2
a427 1
		str="3WCV_B"; break;
d429 1
a429 1
		case SSL3_ST_SW_CHANGE_A:
d431 3
a433 2
		str="3WCCSA"; break;
		case SSL3_ST_SW_CHANGE_B:
d435 3
a437 2
		str="3WCCSB"; break;
		case SSL3_ST_SW_FINISHED_A:
d439 3
a441 2
		str="3WFINA"; break;
		case SSL3_ST_SW_FINISHED_B:
d443 3
a445 2
		str="3WFINB"; break;
		case SSL3_ST_SR_CHANGE_A:
d447 3
a449 2
		str="3RCCSA"; break;
		case SSL3_ST_SR_CHANGE_B:
d451 3
a453 2
		str="3RCCSB"; break;
		case SSL3_ST_SR_FINISHED_A:
d455 3
a457 2
		str="3RFINA"; break;
		case SSL3_ST_SR_FINISHED_B:
d459 2
a460 1
		str="3RFINB"; break;
d463 2
a464 1
		str="3WHR_A"; break;
d466 2
a467 1
		str="3WHR_B"; break;
d469 2
a470 1
		str="3WHR_C"; break;
d472 2
a473 1
		str="3RCH_A"; break;
d475 2
a476 1
		str="3RCH_B"; break;
d478 2
a479 1
		str="3RCH_C"; break;
d481 2
a482 1
		str="3WSH_A"; break;
d484 2
a485 1
		str="3WSH_B"; break;
d487 2
a488 1
		str="3WSC_A"; break;
d490 2
a491 1
		str="3WSC_B"; break;
d493 2
a494 1
		str="3WSKEA"; break;
d496 2
a497 1
		str="3WSKEB"; break;
d499 2
a500 1
		str="3WCR_A"; break;
d502 2
a503 1
		str="3WCR_B"; break;
d505 2
a506 1
		str="3WSD_A"; break;
d508 2
a509 1
		str="3WSD_B"; break;
d511 2
a512 1
		str="3RCC_A"; break;
d514 2
a515 1
		str="3RCC_B"; break;
d517 2
a518 1
		str="3RCKEA"; break;
d520 2
a521 1
		str="3RCKEB"; break;
d523 2
a524 1
		str="3RCV_A"; break;
d526 4
a529 2
		str="3RCV_B"; break;
/* DTLS */
d531 2
a532 1
		str="DRCHVA"; break;
d534 2
a535 1
		str="DRCHVB"; break;
d537 2
a538 1
		str="DWCHVA"; break;
d540 2
a541 1
		str="DWCHVB"; break;
d544 2
a545 1
		str="UNKWN "; break;
d553 1
a553 1
	value>>=8;
d555 1
a555 1
		return("warning");
d557 1
a557 1
		return("fatal");
d559 1
a559 1
		return("unknown");
d565 1
a565 1
	value>>=8;
d567 1
a567 1
		return("W");
d569 1
a569 1
		return("F");
d571 1
a571 1
		return("U");
d581 2
a582 1
		str="CN"; break;
d584 2
a585 1
		str="UM"; break;
d587 2
a588 1
		str="BM"; break;
d590 2
a591 1
		str="DF"; break;
d593 2
a594 1
		str="HF"; break;
d596 2
a597 1
		str="NC"; break;
d599 2
a600 1
		str="BC"; break;
d602 2
a603 1
		str="UC"; break;
d605 2
a606 1
		str="CR"; break;
d608 2
a609 1
		str="CE"; break;
d611 2
a612 1
		str="CU"; break;
d614 2
a615 1
		str="IP"; break;
d617 2
a618 1
		str="DC"; break;
d620 2
a621 1
		str="RO"; break;
d623 2
a624 1
		str="CA"; break;
d626 2
a627 1
		str="AD"; break;
d629 2
a630 1
		str="DE"; break;
d632 2
a633 1
		str="CY"; break;
d635 2
a636 1
		str="ER"; break;
d638 2
a639 1
		str="PV"; break;
d641 2
a642 1
		str="IS"; break;
d644 2
a645 1
		str="IE"; break;
d647 2
a648 1
		str="US"; break;
d650 2
a651 1
		str="NR"; break;
d653 2
a654 1
		str="UE"; break;
d656 2
a657 1
		str="CO"; break;
d659 2
a660 1
		str="UN"; break;
d662 2
a663 1
		str="BR"; break;
d665 2
a666 1
		str="BH"; break;
d668 2
a669 1
		str="UP"; break;
d671 2
a672 1
		str="UK"; break;
d684 1
a684 1
		str="close notify";
d687 1
a687 1
		str="unexpected_message";
d690 1
a690 1
		str="bad record mac";
d693 1
a693 1
		str="decompression failure";
d696 1
a696 1
		str="handshake failure";
d699 1
a699 1
		str="no certificate";
d702 1
a702 1
		str="bad certificate";
d705 1
a705 1
		str="unsupported certificate";
d708 1
a708 1
		str="certificate revoked";
d711 1
a711 1
		str="certificate expired";
d714 1
a714 1
		str="certificate unknown";
d717 1
a717 1
		str="illegal parameter";
d720 1
a720 1
		str="decryption failed";
d723 1
a723 1
		str="record overflow";
d726 1
a726 1
		str="unknown CA";
d729 1
a729 1
		str="access denied";
d732 1
a732 1
		str="decode error";
d735 1
a735 1
		str="decrypt error";
d738 1
a738 1
		str="export restriction";
d741 1
a741 1
		str="protocol version";
d744 1
a744 1
		str="insufficient security";
d747 1
a747 1
		str="internal error";
d750 1
a750 1
		str="user canceled";
d753 1
a753 1
		str="no renegotiation";
d756 1
a756 1
		str="unsupported extension";
d759 1
a759 1
		str="certificate unobtainable";
d762 1
a762 1
		str="unrecognized name";
d765 1
a765 1
		str="bad certificate status response";
d768 1
a768 1
		str="bad certificate hash value";
d771 1
a771 1
		str="unknown PSK identity";
d774 2
a775 1
		str="unknown"; break;
d787 2
a788 1
		str="RH"; break;
d790 2
a791 1
		str="RB"; break;
d793 2
a794 1
		str="RD"; break;
d796 2
a797 1
		str="unknown"; break;
@


1.9
log
@More KNF and style consistency tweaks
@
text
@d1 1
a1 1
/* ssl/ssl_stat.c */
@


1.8
log
@remove ssl2 support even more completely.
in the process, always include ssl3 and tls1, we don't need config options
for them. when the time comes to expire ssl3, it will be with an ax.
checked by miod
@
text
@d88 2
a89 2
const char
*SSL_state_string_long(const SSL *s)
d252 2
a253 2
const char
*SSL_rstate_string_long(const SSL *s)
d270 2
a271 2
const char
*SSL_state_string(const SSL *s)
d415 2
a416 2
const char
*SSL_alert_type_string_long(int value)
d427 2
a428 2
const char
*SSL_alert_type_string(int value)
d439 2
a440 2
const char
*SSL_alert_desc_string(int value)
d511 2
a512 2
const char
*SSL_alert_desc_string_long(int value)
d613 2
a614 2
const char
*SSL_rstate_string(const SSL *s)
@


1.7
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a111 80
#ifndef OPENSSL_NO_SSL2
	case SSL2_ST_CLIENT_START_ENCRYPTION:
		str="SSLv2 client start encryption"; break;
	case SSL2_ST_SERVER_START_ENCRYPTION:
		str="SSLv2 server start encryption"; break;
	case SSL2_ST_SEND_CLIENT_HELLO_A:
		str="SSLv2 write client hello A"; break;
	case SSL2_ST_SEND_CLIENT_HELLO_B:
		str="SSLv2 write client hello B"; break;
	case SSL2_ST_GET_SERVER_HELLO_A:
		str="SSLv2 read server hello A"; break;
	case SSL2_ST_GET_SERVER_HELLO_B:
		str="SSLv2 read server hello B"; break;
	case SSL2_ST_SEND_CLIENT_MASTER_KEY_A:
		str="SSLv2 write client master key A"; break;
	case SSL2_ST_SEND_CLIENT_MASTER_KEY_B:
		str="SSLv2 write client master key B"; break;
	case SSL2_ST_SEND_CLIENT_FINISHED_A:
		str="SSLv2 write client finished A"; break;
	case SSL2_ST_SEND_CLIENT_FINISHED_B:
		str="SSLv2 write client finished B"; break;
	case SSL2_ST_SEND_CLIENT_CERTIFICATE_A:
		str="SSLv2 write client certificate A"; break;
	case SSL2_ST_SEND_CLIENT_CERTIFICATE_B:
		str="SSLv2 write client certificate B"; break;
	case SSL2_ST_SEND_CLIENT_CERTIFICATE_C:
		str="SSLv2 write client certificate C"; break;
	case SSL2_ST_SEND_CLIENT_CERTIFICATE_D:
		str="SSLv2 write client certificate D"; break;
	case SSL2_ST_GET_SERVER_VERIFY_A:
		str="SSLv2 read server verify A"; break;
	case SSL2_ST_GET_SERVER_VERIFY_B:
		str="SSLv2 read server verify B"; break;
	case SSL2_ST_GET_SERVER_FINISHED_A:
		str="SSLv2 read server finished A"; break;
	case SSL2_ST_GET_SERVER_FINISHED_B:
		str="SSLv2 read server finished B"; break;
	case SSL2_ST_GET_CLIENT_HELLO_A:
		str="SSLv2 read client hello A"; break;
	case SSL2_ST_GET_CLIENT_HELLO_B:
		str="SSLv2 read client hello B"; break;
	case SSL2_ST_GET_CLIENT_HELLO_C:
		str="SSLv2 read client hello C"; break;
	case SSL2_ST_SEND_SERVER_HELLO_A:
		str="SSLv2 write server hello A"; break;
	case SSL2_ST_SEND_SERVER_HELLO_B:
		str="SSLv2 write server hello B"; break;
	case SSL2_ST_GET_CLIENT_MASTER_KEY_A:
		str="SSLv2 read client master key A"; break;
	case SSL2_ST_GET_CLIENT_MASTER_KEY_B:
		str="SSLv2 read client master key B"; break;
	case SSL2_ST_SEND_SERVER_VERIFY_A:
		str="SSLv2 write server verify A"; break;
	case SSL2_ST_SEND_SERVER_VERIFY_B:
		str="SSLv2 write server verify B"; break;
	case SSL2_ST_SEND_SERVER_VERIFY_C:
		str="SSLv2 write server verify C"; break;
	case SSL2_ST_GET_CLIENT_FINISHED_A:
		str="SSLv2 read client finished A"; break;
	case SSL2_ST_GET_CLIENT_FINISHED_B:
		str="SSLv2 read client finished B"; break;
	case SSL2_ST_SEND_SERVER_FINISHED_A:
		str="SSLv2 write server finished A"; break;
	case SSL2_ST_SEND_SERVER_FINISHED_B:
		str="SSLv2 write server finished B"; break;
	case SSL2_ST_SEND_REQUEST_CERTIFICATE_A:
		str="SSLv2 write request certificate A"; break;
	case SSL2_ST_SEND_REQUEST_CERTIFICATE_B:
		str="SSLv2 write request certificate B"; break;
	case SSL2_ST_SEND_REQUEST_CERTIFICATE_C:
		str="SSLv2 write request certificate C"; break;
	case SSL2_ST_SEND_REQUEST_CERTIFICATE_D:
		str="SSLv2 write request certificate D"; break;
	case SSL2_ST_X509_GET_SERVER_CERTIFICATE:
		str="SSLv2 X509 read server certificate"; break;
	case SSL2_ST_X509_GET_CLIENT_CERTIFICATE:
		str="SSLv2 X509 read client certificate"; break;
#endif

#ifndef OPENSSL_NO_SSL3
a234 19
#endif

#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
/* SSLv2/v3 compatibility states */
/* client */
	case SSL23_ST_CW_CLNT_HELLO_A:
		str="SSLv2/v3 write client hello A"; break;
	case SSL23_ST_CW_CLNT_HELLO_B:
		str="SSLv2/v3 write client hello B"; break;
	case SSL23_ST_CR_SRVR_HELLO_A:
		str="SSLv2/v3 read server hello A"; break;
	case SSL23_ST_CR_SRVR_HELLO_B:
		str="SSLv2/v3 read server hello B"; break;
/* server */
	case SSL23_ST_SR_CLNT_HELLO_A:
		str="SSLv2/v3 read client hello A"; break;
	case SSL23_ST_SR_CLNT_HELLO_B:
		str="SSLv2/v3 read client hello B"; break;
#endif
a283 78
#ifndef OPENSSL_NO_SSL2
	case SSL2_ST_CLIENT_START_ENCRYPTION:
		str="2CSENC"; break;
	case SSL2_ST_SERVER_START_ENCRYPTION:
		str="2SSENC"; break;
	case SSL2_ST_SEND_CLIENT_HELLO_A:
		str="2SCH_A"; break;
	case SSL2_ST_SEND_CLIENT_HELLO_B:
		str="2SCH_B"; break;
	case SSL2_ST_GET_SERVER_HELLO_A:
		str="2GSH_A"; break;
	case SSL2_ST_GET_SERVER_HELLO_B:
		str="2GSH_B"; break;
	case SSL2_ST_SEND_CLIENT_MASTER_KEY_A:
		str="2SCMKA"; break;
	case SSL2_ST_SEND_CLIENT_MASTER_KEY_B:
		str="2SCMKB"; break;
	case SSL2_ST_SEND_CLIENT_FINISHED_A:
		str="2SCF_A"; break;
	case SSL2_ST_SEND_CLIENT_FINISHED_B:
		str="2SCF_B"; break;
	case SSL2_ST_SEND_CLIENT_CERTIFICATE_A:
		str="2SCC_A"; break;
	case SSL2_ST_SEND_CLIENT_CERTIFICATE_B:
		str="2SCC_B"; break;
	case SSL2_ST_SEND_CLIENT_CERTIFICATE_C:
		str="2SCC_C"; break;
	case SSL2_ST_SEND_CLIENT_CERTIFICATE_D:
		str="2SCC_D"; break;
	case SSL2_ST_GET_SERVER_VERIFY_A:
		str="2GSV_A"; break;
	case SSL2_ST_GET_SERVER_VERIFY_B:
		str="2GSV_B"; break;
	case SSL2_ST_GET_SERVER_FINISHED_A:
		str="2GSF_A"; break;
	case SSL2_ST_GET_SERVER_FINISHED_B:
		str="2GSF_B"; break;
	case SSL2_ST_GET_CLIENT_HELLO_A:
		str="2GCH_A"; break;
	case SSL2_ST_GET_CLIENT_HELLO_B:
		str="2GCH_B"; break;
	case SSL2_ST_GET_CLIENT_HELLO_C:
		str="2GCH_C"; break;
	case SSL2_ST_SEND_SERVER_HELLO_A:
		str="2SSH_A"; break;
	case SSL2_ST_SEND_SERVER_HELLO_B:
		str="2SSH_B"; break;
	case SSL2_ST_GET_CLIENT_MASTER_KEY_A:
		str="2GCMKA"; break;
	case SSL2_ST_GET_CLIENT_MASTER_KEY_B:
		str="2GCMKA"; break;
	case SSL2_ST_SEND_SERVER_VERIFY_A:
		str="2SSV_A"; break;
	case SSL2_ST_SEND_SERVER_VERIFY_B:
		str="2SSV_B"; break;
	case SSL2_ST_SEND_SERVER_VERIFY_C:
		str="2SSV_C"; break;
	case SSL2_ST_GET_CLIENT_FINISHED_A:
		str="2GCF_A"; break;
	case SSL2_ST_GET_CLIENT_FINISHED_B:
		str="2GCF_B"; break;
	case SSL2_ST_SEND_SERVER_FINISHED_A:
		str="2SSF_A"; break;
	case SSL2_ST_SEND_SERVER_FINISHED_B:
		str="2SSF_B"; break;
	case SSL2_ST_SEND_REQUEST_CERTIFICATE_A:
		str="2SRC_A"; break;
	case SSL2_ST_SEND_REQUEST_CERTIFICATE_B:
		str="2SRC_B"; break;
	case SSL2_ST_SEND_REQUEST_CERTIFICATE_C:
		str="2SRC_C"; break;
	case SSL2_ST_SEND_REQUEST_CERTIFICATE_D:
		str="2SRC_D"; break;
	case SSL2_ST_X509_GET_SERVER_CERTIFICATE:
		str="2X9GSC"; break;
	case SSL2_ST_X509_GET_CLIENT_CERTIFICATE:
		str="2X9GCC"; break;
#endif
a284 1
#ifndef OPENSSL_NO_SSL3
a398 19
#endif

#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
/* SSLv2/v3 compatibility states */
/* client */
	case SSL23_ST_CW_CLNT_HELLO_A:
		str="23WCHA"; break;
	case SSL23_ST_CW_CLNT_HELLO_B:
		str="23WCHB"; break;
	case SSL23_ST_CR_SRVR_HELLO_A:
		str="23RSHA"; break;
	case SSL23_ST_CR_SRVR_HELLO_B:
		str="23RSHA"; break;
/* server */
	case SSL23_ST_SR_CLNT_HELLO_A:
		str="23RCHA"; break;
	case SSL23_ST_SR_CLNT_HELLO_B:
		str="23RCHB"; break;
#endif
@


1.6
log
@resolve conflicts, fix local changes
@
text
@d88 3
a90 2
const char *SSL_state_string_long(const SSL *s)
	{
d93 19
a111 11
	switch (s->state)
		{
case SSL_ST_BEFORE: str="before SSL initialization"; break;
case SSL_ST_ACCEPT: str="before accept initialization"; break;
case SSL_ST_CONNECT: str="before connect initialization"; break;
case SSL_ST_OK: str="SSL negotiation finished successfully"; break;
case SSL_ST_RENEGOTIATE:	str="SSL renegotiate ciphers"; break;
case SSL_ST_BEFORE|SSL_ST_CONNECT: str="before/connect initialization"; break;
case SSL_ST_OK|SSL_ST_CONNECT: str="ok/connect SSL initialization"; break;
case SSL_ST_BEFORE|SSL_ST_ACCEPT: str="before/accept initialization"; break;
case SSL_ST_OK|SSL_ST_ACCEPT: str="ok/accept SSL initialization"; break;
d113 76
a188 38
case SSL2_ST_CLIENT_START_ENCRYPTION: str="SSLv2 client start encryption"; break;
case SSL2_ST_SERVER_START_ENCRYPTION: str="SSLv2 server start encryption"; break;
case SSL2_ST_SEND_CLIENT_HELLO_A: str="SSLv2 write client hello A"; break;
case SSL2_ST_SEND_CLIENT_HELLO_B: str="SSLv2 write client hello B"; break;
case SSL2_ST_GET_SERVER_HELLO_A: str="SSLv2 read server hello A"; break;
case SSL2_ST_GET_SERVER_HELLO_B: str="SSLv2 read server hello B"; break;
case SSL2_ST_SEND_CLIENT_MASTER_KEY_A: str="SSLv2 write client master key A"; break;
case SSL2_ST_SEND_CLIENT_MASTER_KEY_B: str="SSLv2 write client master key B"; break;
case SSL2_ST_SEND_CLIENT_FINISHED_A: str="SSLv2 write client finished A"; break;
case SSL2_ST_SEND_CLIENT_FINISHED_B: str="SSLv2 write client finished B"; break;
case SSL2_ST_SEND_CLIENT_CERTIFICATE_A: str="SSLv2 write client certificate A"; break;
case SSL2_ST_SEND_CLIENT_CERTIFICATE_B: str="SSLv2 write client certificate B"; break;
case SSL2_ST_SEND_CLIENT_CERTIFICATE_C: str="SSLv2 write client certificate C"; break;
case SSL2_ST_SEND_CLIENT_CERTIFICATE_D: str="SSLv2 write client certificate D"; break;
case SSL2_ST_GET_SERVER_VERIFY_A: str="SSLv2 read server verify A"; break;
case SSL2_ST_GET_SERVER_VERIFY_B: str="SSLv2 read server verify B"; break;
case SSL2_ST_GET_SERVER_FINISHED_A: str="SSLv2 read server finished A"; break;
case SSL2_ST_GET_SERVER_FINISHED_B: str="SSLv2 read server finished B"; break;
case SSL2_ST_GET_CLIENT_HELLO_A: str="SSLv2 read client hello A"; break;
case SSL2_ST_GET_CLIENT_HELLO_B: str="SSLv2 read client hello B"; break;
case SSL2_ST_GET_CLIENT_HELLO_C: str="SSLv2 read client hello C"; break;
case SSL2_ST_SEND_SERVER_HELLO_A: str="SSLv2 write server hello A"; break;
case SSL2_ST_SEND_SERVER_HELLO_B: str="SSLv2 write server hello B"; break;
case SSL2_ST_GET_CLIENT_MASTER_KEY_A: str="SSLv2 read client master key A"; break;
case SSL2_ST_GET_CLIENT_MASTER_KEY_B: str="SSLv2 read client master key B"; break;
case SSL2_ST_SEND_SERVER_VERIFY_A: str="SSLv2 write server verify A"; break;
case SSL2_ST_SEND_SERVER_VERIFY_B: str="SSLv2 write server verify B"; break;
case SSL2_ST_SEND_SERVER_VERIFY_C: str="SSLv2 write server verify C"; break;
case SSL2_ST_GET_CLIENT_FINISHED_A: str="SSLv2 read client finished A"; break;
case SSL2_ST_GET_CLIENT_FINISHED_B: str="SSLv2 read client finished B"; break;
case SSL2_ST_SEND_SERVER_FINISHED_A: str="SSLv2 write server finished A"; break;
case SSL2_ST_SEND_SERVER_FINISHED_B: str="SSLv2 write server finished B"; break;
case SSL2_ST_SEND_REQUEST_CERTIFICATE_A: str="SSLv2 write request certificate A"; break;
case SSL2_ST_SEND_REQUEST_CERTIFICATE_B: str="SSLv2 write request certificate B"; break;
case SSL2_ST_SEND_REQUEST_CERTIFICATE_C: str="SSLv2 write request certificate C"; break;
case SSL2_ST_SEND_REQUEST_CERTIFICATE_D: str="SSLv2 write request certificate D"; break;
case SSL2_ST_X509_GET_SERVER_CERTIFICATE: str="SSLv2 X509 read server certificate"; break;
case SSL2_ST_X509_GET_CLIENT_CERTIFICATE: str="SSLv2 X509 read client certificate"; break;
d193 122
a314 67
case SSL3_ST_CW_CLNT_HELLO_A:	str="SSLv3 write client hello A"; break;
case SSL3_ST_CW_CLNT_HELLO_B:	str="SSLv3 write client hello B"; break;
case SSL3_ST_CR_SRVR_HELLO_A:	str="SSLv3 read server hello A"; break;
case SSL3_ST_CR_SRVR_HELLO_B:	str="SSLv3 read server hello B"; break;
case SSL3_ST_CR_CERT_A:		str="SSLv3 read server certificate A"; break;
case SSL3_ST_CR_CERT_B:		str="SSLv3 read server certificate B"; break;
case SSL3_ST_CR_KEY_EXCH_A:	str="SSLv3 read server key exchange A"; break;
case SSL3_ST_CR_KEY_EXCH_B:	str="SSLv3 read server key exchange B"; break;
case SSL3_ST_CR_CERT_REQ_A:	str="SSLv3 read server certificate request A"; break;
case SSL3_ST_CR_CERT_REQ_B:	str="SSLv3 read server certificate request B"; break;
case SSL3_ST_CR_SESSION_TICKET_A: str="SSLv3 read server session ticket A";break;
case SSL3_ST_CR_SESSION_TICKET_B: str="SSLv3 read server session ticket B";break;
case SSL3_ST_CR_SRVR_DONE_A:	str="SSLv3 read server done A"; break;
case SSL3_ST_CR_SRVR_DONE_B:	str="SSLv3 read server done B"; break;
case SSL3_ST_CW_CERT_A:		str="SSLv3 write client certificate A"; break;
case SSL3_ST_CW_CERT_B:		str="SSLv3 write client certificate B"; break;
case SSL3_ST_CW_CERT_C:		str="SSLv3 write client certificate C"; break;
case SSL3_ST_CW_CERT_D:		str="SSLv3 write client certificate D"; break;
case SSL3_ST_CW_KEY_EXCH_A:	str="SSLv3 write client key exchange A"; break;
case SSL3_ST_CW_KEY_EXCH_B:	str="SSLv3 write client key exchange B"; break;
case SSL3_ST_CW_CERT_VRFY_A:	str="SSLv3 write certificate verify A"; break;
case SSL3_ST_CW_CERT_VRFY_B:	str="SSLv3 write certificate verify B"; break;

case SSL3_ST_CW_CHANGE_A:
case SSL3_ST_SW_CHANGE_A:	str="SSLv3 write change cipher spec A"; break;
case SSL3_ST_CW_CHANGE_B:	
case SSL3_ST_SW_CHANGE_B:	str="SSLv3 write change cipher spec B"; break;
case SSL3_ST_CW_FINISHED_A:	
case SSL3_ST_SW_FINISHED_A:	str="SSLv3 write finished A"; break;
case SSL3_ST_CW_FINISHED_B:	
case SSL3_ST_SW_FINISHED_B:	str="SSLv3 write finished B"; break;
case SSL3_ST_CR_CHANGE_A:	
case SSL3_ST_SR_CHANGE_A:	str="SSLv3 read change cipher spec A"; break;
case SSL3_ST_CR_CHANGE_B:	
case SSL3_ST_SR_CHANGE_B:	str="SSLv3 read change cipher spec B"; break;
case SSL3_ST_CR_FINISHED_A:	
case SSL3_ST_SR_FINISHED_A:	str="SSLv3 read finished A"; break;
case SSL3_ST_CR_FINISHED_B:	
case SSL3_ST_SR_FINISHED_B:	str="SSLv3 read finished B"; break;

case SSL3_ST_CW_FLUSH:
case SSL3_ST_SW_FLUSH:		str="SSLv3 flush data"; break;

case SSL3_ST_SR_CLNT_HELLO_A:	str="SSLv3 read client hello A"; break;
case SSL3_ST_SR_CLNT_HELLO_B:	str="SSLv3 read client hello B"; break;
case SSL3_ST_SR_CLNT_HELLO_C:	str="SSLv3 read client hello C"; break;
case SSL3_ST_SW_HELLO_REQ_A:	str="SSLv3 write hello request A"; break;
case SSL3_ST_SW_HELLO_REQ_B:	str="SSLv3 write hello request B"; break;
case SSL3_ST_SW_HELLO_REQ_C:	str="SSLv3 write hello request C"; break;
case SSL3_ST_SW_SRVR_HELLO_A:	str="SSLv3 write server hello A"; break;
case SSL3_ST_SW_SRVR_HELLO_B:	str="SSLv3 write server hello B"; break;
case SSL3_ST_SW_CERT_A:		str="SSLv3 write certificate A"; break;
case SSL3_ST_SW_CERT_B:		str="SSLv3 write certificate B"; break;
case SSL3_ST_SW_KEY_EXCH_A:	str="SSLv3 write key exchange A"; break;
case SSL3_ST_SW_KEY_EXCH_B:	str="SSLv3 write key exchange B"; break;
case SSL3_ST_SW_CERT_REQ_A:	str="SSLv3 write certificate request A"; break;
case SSL3_ST_SW_CERT_REQ_B:	str="SSLv3 write certificate request B"; break;
case SSL3_ST_SW_SESSION_TICKET_A: str="SSLv3 write session ticket A"; break;
case SSL3_ST_SW_SESSION_TICKET_B: str="SSLv3 write session ticket B"; break;
case SSL3_ST_SW_SRVR_DONE_A:	str="SSLv3 write server done A"; break;
case SSL3_ST_SW_SRVR_DONE_B:	str="SSLv3 write server done B"; break;
case SSL3_ST_SR_CERT_A:		str="SSLv3 read client certificate A"; break;
case SSL3_ST_SR_CERT_B:		str="SSLv3 read client certificate B"; break;
case SSL3_ST_SR_KEY_EXCH_A:	str="SSLv3 read client key exchange A"; break;
case SSL3_ST_SR_KEY_EXCH_B:	str="SSLv3 read client key exchange B"; break;
case SSL3_ST_SR_CERT_VRFY_A:	str="SSLv3 read certificate verify A"; break;
case SSL3_ST_SR_CERT_VRFY_B:	str="SSLv3 read certificate verify B"; break;
d320 8
a327 4
case SSL23_ST_CW_CLNT_HELLO_A:	str="SSLv2/v3 write client hello A"; break;
case SSL23_ST_CW_CLNT_HELLO_B:	str="SSLv2/v3 write client hello B"; break;
case SSL23_ST_CR_SRVR_HELLO_A:	str="SSLv2/v3 read server hello A"; break;
case SSL23_ST_CR_SRVR_HELLO_B:	str="SSLv2/v3 read server hello B"; break;
d329 4
a332 2
case SSL23_ST_SR_CLNT_HELLO_A:	str="SSLv2/v3 read client hello A"; break;
case SSL23_ST_SR_CLNT_HELLO_B:	str="SSLv2/v3 read client hello B"; break;
d336 11
a346 8
case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A: str="DTLS1 read hello verify request A"; break;
case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B: str="DTLS1 read hello verify request B"; break;
case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A: str="DTLS1 write hello verify request A"; break;
case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B: str="DTLS1 write hello verify request B"; break;

default:	str="unknown state"; break;
		}
	return(str);
d348 2
d351 3
a353 2
const char *SSL_rstate_string_long(const SSL *s)
	{
d356 9
a364 8
	switch (s->rstate)
		{
	case SSL_ST_READ_HEADER: str="read header"; break;
	case SSL_ST_READ_BODY: str="read body"; break;
	case SSL_ST_READ_DONE: str="read done"; break;
	default: str="unknown"; break;
		}
	return(str);
d366 2
d369 3
a371 2
const char *SSL_state_string(const SSL *s)
	{
d374 9
a382 6
	switch (s->state)
		{
case SSL_ST_BEFORE:				str="PINIT "; break;
case SSL_ST_ACCEPT:				str="AINIT "; break;
case SSL_ST_CONNECT:				str="CINIT "; break;
case SSL_ST_OK:			 		str="SSLOK "; break;
d384 76
a459 38
case SSL2_ST_CLIENT_START_ENCRYPTION:		str="2CSENC"; break;
case SSL2_ST_SERVER_START_ENCRYPTION:		str="2SSENC"; break;
case SSL2_ST_SEND_CLIENT_HELLO_A:		str="2SCH_A"; break;
case SSL2_ST_SEND_CLIENT_HELLO_B:		str="2SCH_B"; break;
case SSL2_ST_GET_SERVER_HELLO_A:		str="2GSH_A"; break;
case SSL2_ST_GET_SERVER_HELLO_B:		str="2GSH_B"; break;
case SSL2_ST_SEND_CLIENT_MASTER_KEY_A:		str="2SCMKA"; break;
case SSL2_ST_SEND_CLIENT_MASTER_KEY_B:		str="2SCMKB"; break;
case SSL2_ST_SEND_CLIENT_FINISHED_A:		str="2SCF_A"; break;
case SSL2_ST_SEND_CLIENT_FINISHED_B:		str="2SCF_B"; break;
case SSL2_ST_SEND_CLIENT_CERTIFICATE_A:		str="2SCC_A"; break;
case SSL2_ST_SEND_CLIENT_CERTIFICATE_B:		str="2SCC_B"; break;
case SSL2_ST_SEND_CLIENT_CERTIFICATE_C:		str="2SCC_C"; break;
case SSL2_ST_SEND_CLIENT_CERTIFICATE_D:		str="2SCC_D"; break;
case SSL2_ST_GET_SERVER_VERIFY_A:		str="2GSV_A"; break;
case SSL2_ST_GET_SERVER_VERIFY_B:		str="2GSV_B"; break;
case SSL2_ST_GET_SERVER_FINISHED_A:		str="2GSF_A"; break;
case SSL2_ST_GET_SERVER_FINISHED_B:		str="2GSF_B"; break;
case SSL2_ST_GET_CLIENT_HELLO_A:		str="2GCH_A"; break;
case SSL2_ST_GET_CLIENT_HELLO_B:		str="2GCH_B"; break;
case SSL2_ST_GET_CLIENT_HELLO_C:		str="2GCH_C"; break;
case SSL2_ST_SEND_SERVER_HELLO_A:		str="2SSH_A"; break;
case SSL2_ST_SEND_SERVER_HELLO_B:		str="2SSH_B"; break;
case SSL2_ST_GET_CLIENT_MASTER_KEY_A:		str="2GCMKA"; break;
case SSL2_ST_GET_CLIENT_MASTER_KEY_B:		str="2GCMKA"; break;
case SSL2_ST_SEND_SERVER_VERIFY_A:		str="2SSV_A"; break;
case SSL2_ST_SEND_SERVER_VERIFY_B:		str="2SSV_B"; break;
case SSL2_ST_SEND_SERVER_VERIFY_C:		str="2SSV_C"; break;
case SSL2_ST_GET_CLIENT_FINISHED_A:		str="2GCF_A"; break;
case SSL2_ST_GET_CLIENT_FINISHED_B:		str="2GCF_B"; break;
case SSL2_ST_SEND_SERVER_FINISHED_A:		str="2SSF_A"; break;
case SSL2_ST_SEND_SERVER_FINISHED_B:		str="2SSF_B"; break;
case SSL2_ST_SEND_REQUEST_CERTIFICATE_A:	str="2SRC_A"; break;
case SSL2_ST_SEND_REQUEST_CERTIFICATE_B:	str="2SRC_B"; break;
case SSL2_ST_SEND_REQUEST_CERTIFICATE_C:	str="2SRC_C"; break;
case SSL2_ST_SEND_REQUEST_CERTIFICATE_D:	str="2SRC_D"; break;
case SSL2_ST_X509_GET_SERVER_CERTIFICATE:	str="2X9GSC"; break;
case SSL2_ST_X509_GET_CLIENT_CERTIFICATE:	str="2X9GCC"; break;
d464 113
a576 62
case SSL3_ST_SW_FLUSH:
case SSL3_ST_CW_FLUSH:				str="3FLUSH"; break;
case SSL3_ST_CW_CLNT_HELLO_A:			str="3WCH_A"; break;
case SSL3_ST_CW_CLNT_HELLO_B:			str="3WCH_B"; break;
case SSL3_ST_CR_SRVR_HELLO_A:			str="3RSH_A"; break;
case SSL3_ST_CR_SRVR_HELLO_B:			str="3RSH_B"; break;
case SSL3_ST_CR_CERT_A:				str="3RSC_A"; break;
case SSL3_ST_CR_CERT_B:				str="3RSC_B"; break;
case SSL3_ST_CR_KEY_EXCH_A:			str="3RSKEA"; break;
case SSL3_ST_CR_KEY_EXCH_B:			str="3RSKEB"; break;
case SSL3_ST_CR_CERT_REQ_A:			str="3RCR_A"; break;
case SSL3_ST_CR_CERT_REQ_B:			str="3RCR_B"; break;
case SSL3_ST_CR_SRVR_DONE_A:			str="3RSD_A"; break;
case SSL3_ST_CR_SRVR_DONE_B:			str="3RSD_B"; break;
case SSL3_ST_CW_CERT_A:				str="3WCC_A"; break;
case SSL3_ST_CW_CERT_B:				str="3WCC_B"; break;
case SSL3_ST_CW_CERT_C:				str="3WCC_C"; break;
case SSL3_ST_CW_CERT_D:				str="3WCC_D"; break;
case SSL3_ST_CW_KEY_EXCH_A:			str="3WCKEA"; break;
case SSL3_ST_CW_KEY_EXCH_B:			str="3WCKEB"; break;
case SSL3_ST_CW_CERT_VRFY_A:			str="3WCV_A"; break;
case SSL3_ST_CW_CERT_VRFY_B:			str="3WCV_B"; break;

case SSL3_ST_SW_CHANGE_A:
case SSL3_ST_CW_CHANGE_A:			str="3WCCSA"; break;
case SSL3_ST_SW_CHANGE_B:
case SSL3_ST_CW_CHANGE_B:			str="3WCCSB"; break;
case SSL3_ST_SW_FINISHED_A:
case SSL3_ST_CW_FINISHED_A:			str="3WFINA"; break;
case SSL3_ST_SW_FINISHED_B:
case SSL3_ST_CW_FINISHED_B:			str="3WFINB"; break;
case SSL3_ST_SR_CHANGE_A:
case SSL3_ST_CR_CHANGE_A:			str="3RCCSA"; break;
case SSL3_ST_SR_CHANGE_B:
case SSL3_ST_CR_CHANGE_B:			str="3RCCSB"; break;
case SSL3_ST_SR_FINISHED_A:
case SSL3_ST_CR_FINISHED_A:			str="3RFINA"; break;
case SSL3_ST_SR_FINISHED_B:
case SSL3_ST_CR_FINISHED_B:			str="3RFINB"; break;

case SSL3_ST_SW_HELLO_REQ_A:			str="3WHR_A"; break;
case SSL3_ST_SW_HELLO_REQ_B:			str="3WHR_B"; break;
case SSL3_ST_SW_HELLO_REQ_C:			str="3WHR_C"; break;
case SSL3_ST_SR_CLNT_HELLO_A:			str="3RCH_A"; break;
case SSL3_ST_SR_CLNT_HELLO_B:			str="3RCH_B"; break;
case SSL3_ST_SR_CLNT_HELLO_C:			str="3RCH_C"; break;
case SSL3_ST_SW_SRVR_HELLO_A:			str="3WSH_A"; break;
case SSL3_ST_SW_SRVR_HELLO_B:			str="3WSH_B"; break;
case SSL3_ST_SW_CERT_A:				str="3WSC_A"; break;
case SSL3_ST_SW_CERT_B:				str="3WSC_B"; break;
case SSL3_ST_SW_KEY_EXCH_A:			str="3WSKEA"; break;
case SSL3_ST_SW_KEY_EXCH_B:			str="3WSKEB"; break;
case SSL3_ST_SW_CERT_REQ_A:			str="3WCR_A"; break;
case SSL3_ST_SW_CERT_REQ_B:			str="3WCR_B"; break;
case SSL3_ST_SW_SRVR_DONE_A:			str="3WSD_A"; break;
case SSL3_ST_SW_SRVR_DONE_B:			str="3WSD_B"; break;
case SSL3_ST_SR_CERT_A:				str="3RCC_A"; break;
case SSL3_ST_SR_CERT_B:				str="3RCC_B"; break;
case SSL3_ST_SR_KEY_EXCH_A:			str="3RCKEA"; break;
case SSL3_ST_SR_KEY_EXCH_B:			str="3RCKEB"; break;
case SSL3_ST_SR_CERT_VRFY_A:			str="3RCV_A"; break;
case SSL3_ST_SR_CERT_VRFY_B:			str="3RCV_B"; break;
d582 8
a589 4
case SSL23_ST_CW_CLNT_HELLO_A:			str="23WCHA"; break;
case SSL23_ST_CW_CLNT_HELLO_B:			str="23WCHB"; break;
case SSL23_ST_CR_SRVR_HELLO_A:			str="23RSHA"; break;
case SSL23_ST_CR_SRVR_HELLO_B:			str="23RSHA"; break;
d591 4
a594 2
case SSL23_ST_SR_CLNT_HELLO_A:			str="23RCHA"; break;
case SSL23_ST_SR_CLNT_HELLO_B:			str="23RCHB"; break;
d597 11
a607 8
case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A: str="DRCHVA"; break;
case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B: str="DRCHVB"; break;
case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A: str="DWCHVA"; break;
case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B: str="DWCHVB"; break;

default:					str="UNKWN "; break;
		}
	return(str);
d609 2
d612 3
a614 2
const char *SSL_alert_type_string_long(int value)
	{
d622 1
a622 1
	}
d624 3
a626 2
const char *SSL_alert_type_string(int value)
	{
d634 1
a634 1
	}
d636 3
a638 2
const char *SSL_alert_desc_string(int value)
	{
d641 63
a703 35
	switch (value & 0xff)
		{
	case SSL3_AD_CLOSE_NOTIFY:		str="CN"; break;
	case SSL3_AD_UNEXPECTED_MESSAGE:	str="UM"; break;
	case SSL3_AD_BAD_RECORD_MAC:		str="BM"; break;
	case SSL3_AD_DECOMPRESSION_FAILURE:	str="DF"; break;
	case SSL3_AD_HANDSHAKE_FAILURE:		str="HF"; break;
	case SSL3_AD_NO_CERTIFICATE:		str="NC"; break;
	case SSL3_AD_BAD_CERTIFICATE:		str="BC"; break;
	case SSL3_AD_UNSUPPORTED_CERTIFICATE:	str="UC"; break;
	case SSL3_AD_CERTIFICATE_REVOKED:	str="CR"; break;
	case SSL3_AD_CERTIFICATE_EXPIRED:	str="CE"; break;
	case SSL3_AD_CERTIFICATE_UNKNOWN:	str="CU"; break;
	case SSL3_AD_ILLEGAL_PARAMETER:		str="IP"; break;
	case TLS1_AD_DECRYPTION_FAILED:		str="DC"; break;
	case TLS1_AD_RECORD_OVERFLOW:		str="RO"; break;
	case TLS1_AD_UNKNOWN_CA:		str="CA"; break;
	case TLS1_AD_ACCESS_DENIED:		str="AD"; break;
	case TLS1_AD_DECODE_ERROR:		str="DE"; break;
	case TLS1_AD_DECRYPT_ERROR:		str="CY"; break;
	case TLS1_AD_EXPORT_RESTRICTION:	str="ER"; break;
	case TLS1_AD_PROTOCOL_VERSION:		str="PV"; break;
	case TLS1_AD_INSUFFICIENT_SECURITY:	str="IS"; break;
	case TLS1_AD_INTERNAL_ERROR:		str="IE"; break;
	case TLS1_AD_USER_CANCELLED:		str="US"; break;
	case TLS1_AD_NO_RENEGOTIATION:		str="NR"; break;
	case TLS1_AD_UNSUPPORTED_EXTENSION:	str="UE"; break;
	case TLS1_AD_CERTIFICATE_UNOBTAINABLE:	str="CO"; break;
	case TLS1_AD_UNRECOGNIZED_NAME:		str="UN"; break;
	case TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE: str="BR"; break;
	case TLS1_AD_BAD_CERTIFICATE_HASH_VALUE: str="BH"; break;
	case TLS1_AD_UNKNOWN_PSK_IDENTITY:	str="UP"; break;
	default:				str="UK"; break;
		}
	return(str);
d705 2
d708 3
a710 2
const char *SSL_alert_desc_string_long(int value)
	{
d713 1
a713 2
	switch (value & 0xff)
		{
d804 2
a805 3
	default: str="unknown"; break;
		}
	return(str);
d807 2
d810 3
a812 2
const char *SSL_rstate_string(const SSL *s)
	{
d815 9
a823 8
	switch (s->rstate)
		{
	case SSL_ST_READ_HEADER:str="RH"; break;
	case SSL_ST_READ_BODY:	str="RB"; break;
	case SSL_ST_READ_DONE:	str="RD"; break;
	default: str="unknown"; break;
		}
	return(str);
d825 2
@


1.5
log
@resolve conflicts
@
text
@d58 26
d227 6
d380 5
d443 6
d531 18
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d130 2
d177 2
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d62 1
a62 1
char *SSL_state_string_long(SSL *s)
d64 1
a64 1
	char *str;
d77 1
a77 1
#ifndef NO_SSL2
d118 1
a118 1
#ifndef NO_SSL3
d139 1
a139 1
case SSL3_ST_CW_CERT_VRFY_B:	str="SSLv3 write certificate verify A"; break;
d148 1
a148 1
case SSL3_ST_SW_FINISHED_B:	str="SSLv3 write finished A"; break;
d185 1
a185 1
#if !defined(NO_SSL2) && !defined(NO_SSL3)
d202 1
a202 1
char *SSL_rstate_string_long(SSL *s)
d204 1
a204 1
	char *str;
d216 1
a216 1
char *SSL_state_string(SSL *s)
d218 1
a218 1
	char *str;
d226 1
a226 1
#ifndef NO_SSL2
d267 1
a267 1
#ifndef NO_SSL3
d333 1
a333 1
#if !defined(NO_SSL2) && !defined(NO_SSL3)
d350 1
a350 1
char *SSL_alert_type_string_long(int value)
d361 1
a361 1
char *SSL_alert_type_string(int value)
d372 1
a372 1
char *SSL_alert_desc_string(int value)
d374 1
a374 1
	char *str;
d390 12
d407 1
a407 1
char *SSL_alert_desc_string_long(int value)
d409 1
a409 1
	char *str;
d449 36
d490 1
a490 1
char *SSL_rstate_string(SSL *s)
d492 1
a492 1
	char *str;
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d186 1
a186 1
/* SSLv2/v3 compatablitity states */
d334 1
a334 1
/* SSLv2/v3 compatablitity states */
d405 1
a405 1
		str="unexected_message";
d432 1
a432 1
		str="certifcate unknown";
@


1.1
log
@Initial revision
@
text
@d62 1
a62 2
char *SSL_state_string_long(s)
SSL *s;
d68 3
a70 3
case SSL_ST_BEFORE: str="before SSL initalisation"; break;
case SSL_ST_ACCEPT: str="before accept initalisation"; break;
case SSL_ST_CONNECT: str="before connect initalisation"; break;
d73 4
a76 4
case SSL_ST_BEFORE|SSL_ST_CONNECT: str="before/connect initalisation"; break;
case SSL_ST_OK|SSL_ST_CONNECT: str="ok/connect SSL initalisation"; break;
case SSL_ST_BEFORE|SSL_ST_ACCEPT: str="before/accept initalisation"; break;
case SSL_ST_OK|SSL_ST_ACCEPT: str="ok/accept SSL initalisation"; break;
d134 2
d202 1
a202 2
char *SSL_rstate_string_long(s)
SSL *s;
d216 1
a216 2
char *SSL_state_string(s)
SSL *s;
d285 2
d350 1
a350 2
char *SSL_alert_type_string_long(value)
int value;
d361 1
a361 2
char *SSL_alert_type_string(value)
int value;
d372 1
a372 2
char *SSL_alert_desc_string(value)
int value;
d395 1
a395 2
char *SSL_alert_desc_string_long(value)
int value;
d442 1
a442 2
char *SSL_rstate_string(s)
SSL *s;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d62 2
a63 1
const char *SSL_state_string_long(const SSL *s)
d65 1
a65 1
	const char *str;
d69 3
a71 3
case SSL_ST_BEFORE: str="before SSL initialization"; break;
case SSL_ST_ACCEPT: str="before accept initialization"; break;
case SSL_ST_CONNECT: str="before connect initialization"; break;
d74 5
a78 5
case SSL_ST_BEFORE|SSL_ST_CONNECT: str="before/connect initialization"; break;
case SSL_ST_OK|SSL_ST_CONNECT: str="ok/connect SSL initialization"; break;
case SSL_ST_BEFORE|SSL_ST_ACCEPT: str="before/accept initialization"; break;
case SSL_ST_OK|SSL_ST_ACCEPT: str="ok/accept SSL initialization"; break;
#ifndef OPENSSL_NO_SSL2
d119 1
a119 1
#ifndef OPENSSL_NO_SSL3
a134 2
case SSL3_ST_CW_CERT_C:		str="SSLv3 write client certificate C"; break;
case SSL3_ST_CW_CERT_D:		str="SSLv3 write client certificate D"; break;
d138 1
a138 1
case SSL3_ST_CW_CERT_VRFY_B:	str="SSLv3 write certificate verify B"; break;
d147 1
a147 1
case SSL3_ST_SW_FINISHED_B:	str="SSLv3 write finished B"; break;
d184 2
a185 2
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
/* SSLv2/v3 compatibility states */
d201 2
a202 1
const char *SSL_rstate_string_long(const SSL *s)
d204 1
a204 1
	const char *str;
d216 2
a217 1
const char *SSL_state_string(const SSL *s)
d219 1
a219 1
	const char *str;
d227 1
a227 1
#ifndef OPENSSL_NO_SSL2
d268 1
a268 1
#ifndef OPENSSL_NO_SSL3
a285 2
case SSL3_ST_CW_CERT_C:				str="3WCC_C"; break;
case SSL3_ST_CW_CERT_D:				str="3WCC_D"; break;
d332 2
a333 2
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
/* SSLv2/v3 compatibility states */
d349 2
a350 1
const char *SSL_alert_type_string_long(int value)
d361 2
a362 1
const char *SSL_alert_type_string(int value)
d373 2
a374 1
const char *SSL_alert_desc_string(int value)
d376 1
a376 1
	const char *str;
a391 12
	case TLS1_AD_DECRYPTION_FAILED:		str="DC"; break;
	case TLS1_AD_RECORD_OVERFLOW:		str="RO"; break;
	case TLS1_AD_UNKNOWN_CA:		str="CA"; break;
	case TLS1_AD_ACCESS_DENIED:		str="AD"; break;
	case TLS1_AD_DECODE_ERROR:		str="DE"; break;
	case TLS1_AD_DECRYPT_ERROR:		str="CY"; break;
	case TLS1_AD_EXPORT_RESTRICTION:	str="ER"; break;
	case TLS1_AD_PROTOCOL_VERSION:		str="PV"; break;
	case TLS1_AD_INSUFFICIENT_SECURITY:	str="IS"; break;
	case TLS1_AD_INTERNAL_ERROR:		str="IE"; break;
	case TLS1_AD_USER_CANCELLED:		str="US"; break;
	case TLS1_AD_NO_RENEGOTIATION:		str="NR"; break;
d397 2
a398 1
const char *SSL_alert_desc_string_long(int value)
d400 1
a400 1
	const char *str;
d408 1
a408 1
		str="unexpected_message";
d435 1
a435 1
		str="certificate unknown";
a439 36
	case TLS1_AD_DECRYPTION_FAILED:
		str="decryption failed";
		break;
	case TLS1_AD_RECORD_OVERFLOW:
		str="record overflow";
		break;
	case TLS1_AD_UNKNOWN_CA:
		str="unknown CA";
		break;
	case TLS1_AD_ACCESS_DENIED:
		str="access denied";
		break;
	case TLS1_AD_DECODE_ERROR:
		str="decode error";
		break;
	case TLS1_AD_DECRYPT_ERROR:
		str="decrypt error";
		break;
	case TLS1_AD_EXPORT_RESTRICTION:
		str="export restriction";
		break;
	case TLS1_AD_PROTOCOL_VERSION:
		str="protocol version";
		break;
	case TLS1_AD_INSUFFICIENT_SECURITY:
		str="insufficient security";
		break;
	case TLS1_AD_INTERNAL_ERROR:
		str="internal error";
		break;
	case TLS1_AD_USER_CANCELLED:
		str="user canceled";
		break;
	case TLS1_AD_NO_RENEGOTIATION:
		str="no renegotiation";
		break;
d445 2
a446 1
const char *SSL_rstate_string(const SSL *s)
d448 1
a448 1
	const char *str;
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@a129 2
case SSL3_ST_CR_SESSION_TICKET_A: str="SSLv3 read server session ticket A";break;
case SSL3_ST_CR_SESSION_TICKET_B: str="SSLv3 read server session ticket B";break;
a174 2
case SSL3_ST_SW_SESSION_TICKET_A: str="SSLv3 write session ticket A"; break;
case SSL3_ST_SW_SESSION_TICKET_B: str="SSLv3 write session ticket B"; break;
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@a57 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
a200 6
/* DTLS */
case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A: str="DTLS1 read hello verify request A"; break;
case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B: str="DTLS1 read hello verify request B"; break;
case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A: str="DTLS1 write hello verify request A"; break;
case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B: str="DTLS1 write hello verify request B"; break;

a347 5
/* DTLS */
case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A: str="DRCHVA"; break;
case DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B: str="DRCHVB"; break;
case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A: str="DWCHVA"; break;
case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B: str="DWCHVB"; break;
a405 6
	case TLS1_AD_UNSUPPORTED_EXTENSION:	str="UE"; break;
	case TLS1_AD_CERTIFICATE_UNOBTAINABLE:	str="CO"; break;
	case TLS1_AD_UNRECOGNIZED_NAME:		str="UN"; break;
	case TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE: str="BR"; break;
	case TLS1_AD_BAD_CERTIFICATE_HASH_VALUE: str="BH"; break;
	case TLS1_AD_UNKNOWN_PSK_IDENTITY:	str="UP"; break;
a487 18
		break;
	case TLS1_AD_UNSUPPORTED_EXTENSION:
		str="unsupported extension";
		break;
	case TLS1_AD_CERTIFICATE_UNOBTAINABLE:
		str="certificate unobtainable";
		break;
	case TLS1_AD_UNRECOGNIZED_NAME:
		str="unrecognized name";
		break;
	case TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE:
		str="bad certificate status response";
		break;
	case TLS1_AD_BAD_CERTIFICATE_HASH_VALUE:
		str="bad certificate hash value";
		break;
	case TLS1_AD_UNKNOWN_PSK_IDENTITY:
		str="unknown PSK identity";
@


