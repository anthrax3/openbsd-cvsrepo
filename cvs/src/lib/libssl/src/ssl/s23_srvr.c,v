head	1.47;
access;
symbols
	OPENBSD_6_0:1.47.0.2
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.38.0.4
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.33.0.2
	OPENBSD_5_6_BASE:1.33
	butholakala:1.14
	openssl_1_0_1_g:1.1.1.10
	OPENBSD_5_5:1.14.0.8
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	openssl_1_0_1_c:1.1.1.10
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	openssl_1_0_0_f:1.1.1.9
	openssl_1_0_0_e:1.1.1.9
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	openssh_1_0_0_a:1.1.1.9
	OPENBSD_4_8:1.12.0.8
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.4
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	openssl_0_9_8_k:1.1.1.8
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	openssl_0_9_8_j:1.1.1.8
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2016.07.16.04.42.35;	author beck;	state Exp;
branches;
next	1.46;
commitid	DmP6xMczrglTsMVT;

1.46
date	2015.10.25.15.49.04;	author doug;	state Exp;
branches;
next	1.45;
commitid	UuNI402l1cl5ysya;

1.45
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.44;
commitid	pa8oXRlJthT375Ws;

1.44
date	2015.09.11.14.47.56;	author jsing;	state Exp;
branches;
next	1.43;
commitid	bCZtF23dsAmdEHr0;

1.43
date	2015.08.29.17.15.52;	author doug;	state Exp;
branches;
next	1.42;
commitid	J5Q7EI1v6Se5pITr;

1.42
date	2015.08.27.06.21.15;	author doug;	state Exp;
branches;
next	1.41;
commitid	81GzeBdk0eOTcvRE;

1.41
date	2015.07.19.07.30.06;	author doug;	state Exp;
branches;
next	1.40;
commitid	N7VdpUQsePnBwxuL;

1.40
date	2015.07.19.06.31.32;	author doug;	state Exp;
branches;
next	1.39;
commitid	as8DOqEY9XBrHJyu;

1.39
date	2015.03.27.12.29.54;	author jsing;	state Exp;
branches;
next	1.38;
commitid	GlMku1cNd3nfgnVW;

1.38
date	2015.02.06.08.30.23;	author jsing;	state Exp;
branches;
next	1.37;
commitid	K5MXFl39zEkHakNY;

1.37
date	2014.12.10.15.43.31;	author jsing;	state Exp;
branches;
next	1.36;
commitid	9GGF3DCNTm9Bs8E3;

1.36
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.35;
commitid	M3pvHgIFoWUHNqJn;

1.35
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.34;
commitid	cGE1JG2i0h4NcVDi;

1.34
date	2014.08.10.14.42.56;	author jsing;	state Exp;
branches;
next	1.33;
commitid	wihJupNvfkdpKL9O;

1.33
date	2014.08.07.19.46.31;	author miod;	state Exp;
branches;
next	1.32;
commitid	vayOLqnrIMw5dnz8;

1.32
date	2014.08.07.04.49.53;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	ivoSUQBG4KtmA7oR;

1.31
date	2014.07.11.08.17.36;	author miod;	state Exp;
branches;
next	1.30;
commitid	3cdQWc5wTDwlWJsQ;

1.30
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.29;
commitid	lsH7iukeZYSZBx6F;

1.29
date	2014.06.30.14.13.27;	author tedu;	state Exp;
branches;
next	1.28;
commitid	H5OTJxdwtWPzPQfq;

1.28
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	mJUVYpkFBZ0Zv2bG;

1.27
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.05.24.15.20.35;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2014.05.24.12.44.48;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.19.17.07.35;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.17.23.35.40;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.16.15.10.07;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.15.21.47.56;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.15.19.42.56;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.14.17.45.38;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.14.15.15.33;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches
	1.14.4.1
	1.14.8.1;
next	1.13;

1.13
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.11.14.49.22;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2003.05.12.02.18.39;	author markus;	state Exp;
branches
	1.7.6.1
	1.7.8.1;
next	1.6;

1.6
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.36;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.27;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.26;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.11;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.11;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.32;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.43.56;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.37;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.27;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.14.06;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	;

1.7.6.1
date	2005.10.12.18.48.45;	author brad;	state Exp;
branches;
next	;

1.7.8.1
date	2005.10.12.21.39.07;	author brad;	state Exp;
branches;
next	;

1.8.2.1
date	2005.11.01.01.01.12;	author brad;	state Exp;
branches;
next	;

1.14.4.1
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.14.8.1
date	2014.08.09.16.54.58;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;


desc
@@


1.47
log
@Limit the support of the "backward compatible" ssl2 handshake to only be
used if TLS 1.0 is enabled. Sugessted/discussed with jsing@@ and bcook@@.
ok guenther@@ sthen@@
@
text
@/* $OpenBSD: s23_srvr.c,v 1.46 2015/10/25 15:49:04 doug Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/buffer.h>
#include <openssl/evp.h>
#include <openssl/objects.h>

int ssl23_get_client_hello(SSL *s);

int
ssl23_accept(SSL *s)
{
	void (*cb)(const SSL *ssl, int type, int val) = NULL;
	int ret = -1;
	int new_state, state;

	ERR_clear_error();
	errno = 0;

	if (s->info_callback != NULL)
		cb = s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb = s->ctx->info_callback;

	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s))
		SSL_clear(s);

	for (;;) {
		state = s->state;

		switch (s->state) {
		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server = 1;
			if (cb != NULL)
				cb(s, SSL_CB_HANDSHAKE_START, 1);

			/* s->version=SSL3_VERSION; */
			s->type = SSL_ST_ACCEPT;

			if (!ssl3_setup_init_buffer(s)) {
				ret = -1;
				goto end;
			}
			if (!tls1_init_finished_mac(s)) {
				ret = -1;
				goto end;
			}

			s->state = SSL23_ST_SR_CLNT_HELLO_A;
			s->ctx->stats.sess_accept++;
			s->init_num = 0;
			break;

		case SSL23_ST_SR_CLNT_HELLO_A:
		case SSL23_ST_SR_CLNT_HELLO_B:

			s->shutdown = 0;
			ret = ssl23_get_client_hello(s);
			if (ret >= 0)
				cb = NULL;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_SSL23_ACCEPT, SSL_R_UNKNOWN_STATE);
			ret = -1;
			goto end;
			/* break; */
		}

		if ((cb != NULL) && (s->state != state)) {
			new_state = s->state;
			s->state = state;
			cb(s, SSL_CB_ACCEPT_LOOP, 1);
			s->state = new_state;
		}
	}

end:
	s->in_handshake--;
	if (cb != NULL)
		cb(s, SSL_CB_ACCEPT_EXIT, ret);

	return (ret);
}


int
ssl23_get_client_hello(SSL *s)
{
	char buf[11];
	/*
	 * sizeof(buf) == 11, because we'll need to request this many bytes in
	 * the initial read.
	 * We can detect SSL 3.0/TLS 1.0 Client Hellos ('type == 3') correctly
	 * only when the following is in a single record, which is not
	 * guaranteed by the protocol specification:
	 * Byte  Content
	 *  0     type            \
	 *  1/2   version          > record header
	 *  3/4   length          /
	 *  5     msg_type        \
	 *  6-8   length           > Client Hello message
	 *  9/10  client_version  /
	 */
	unsigned char *p, *d, *d_len, *dd;
	unsigned int i;
	unsigned int csl, sil, cl;
	int n = 0, j;
	int type = 0;
	int v[2];

	if (s->state ==	SSL23_ST_SR_CLNT_HELLO_A) {
		/* read the initial header */
		v[0] = v[1] = 0;

		if (!ssl3_setup_buffers(s))
			return -1;

		n = ssl23_read_bytes(s, sizeof buf);
		if (n != sizeof buf)
			return(n);

		p = s->packet;

		memcpy(buf, p, n);

		if ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO)) {
			/*
			 * SSLv2 header
			 */
			if ((p[3] == 0x00) && (p[4] == 0x02)) {
				/* SSLv2 support has been removed */
				goto unsupported;

			} else if (p[3] == SSL3_VERSION_MAJOR) {
				v[0] = p[3];
				v[1] = p[4];
				/* SSLv3/TLS */

				if (p[4] >= TLS1_VERSION_MINOR) {
					if (p[4] >= TLS1_2_VERSION_MINOR &&
					    !(s->options & SSL_OP_NO_TLSv1_2)) {
						s->version = TLS1_2_VERSION;
						s->state = SSL23_ST_SR_CLNT_HELLO_B;
					} else if (p[4] >= TLS1_1_VERSION_MINOR &&
					    !(s->options & SSL_OP_NO_TLSv1_1)) {
						s->version = TLS1_1_VERSION;
						/* type=2; */ /* done later to survive restarts */
						s->state = SSL23_ST_SR_CLNT_HELLO_B;
					} else if (!(s->options & SSL_OP_NO_TLSv1)) {
						s->version = TLS1_VERSION;
						/* type=2; */ /* done later to survive restarts */
						s->state = SSL23_ST_SR_CLNT_HELLO_B;
					} else {
						goto unsupported;
					}
				} else {
					/* SSLv3 support has been removed */
					goto unsupported;
				}
			}
		} else if ((p[0] == SSL3_RT_HANDSHAKE) &&
		    (p[1] == SSL3_VERSION_MAJOR) &&
		    (p[5] == SSL3_MT_CLIENT_HELLO) &&
		    ((p[3] == 0 && p[4] < 5 /* silly record length? */) ||
		    (p[9] >= p[1]))) {
			/*
			 * SSLv3 or tls1 header
			 */

			v[0] = p[1]; /* major version (= SSL3_VERSION_MAJOR) */
			/* We must look at client_version inside the Client Hello message
			 * to get the correct minor version.
			 * However if we have only a pathologically small fragment of the
			 * Client Hello message, this would be difficult, and we'd have
			 * to read more records to find out.
			 * No known SSL 3.0 client fragments ClientHello like this,
			 * so we simply reject such connections to avoid
			 * protocol version downgrade attacks. */
			if (p[3] == 0 && p[4] < 6) {
				SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
				    SSL_R_RECORD_TOO_SMALL);
				return -1;
			}
			/* if major version number > 3 set minor to a value
			 * which will use the highest version 3 we support.
			 * If TLS 2.0 ever appears we will need to revise
			 * this....
			 */
			if (p[9] > SSL3_VERSION_MAJOR)
				v[1] = 0xff;
			else
				v[1] = p[10]; /* minor version according to client_version */
			if (v[1] >= TLS1_VERSION_MINOR) {
				if (v[1] >= TLS1_2_VERSION_MINOR &&
				    !(s->options & SSL_OP_NO_TLSv1_2)) {
					s->version = TLS1_2_VERSION;
					type = 3;
				} else if (v[1] >= TLS1_1_VERSION_MINOR &&
				    !(s->options & SSL_OP_NO_TLSv1_1)) {
					s->version = TLS1_1_VERSION;
					type = 3;
				} else if (!(s->options & SSL_OP_NO_TLSv1)) {
					s->version = TLS1_VERSION;
					type = 3;
				} else {
					goto unsupported;
				}
			} else {
				/* SSLv3 */
				if (!(s->options & SSL_OP_NO_TLSv1)) {
					/* we won't be able to use TLS of course,
					 * but this will send an appropriate alert */
					s->version = TLS1_VERSION;
					type = 3;
				} else {
					goto unsupported;
				}
			}
		}
		else if ((strncmp("GET ", (char *)p, 4) == 0) ||
		    (strncmp("POST ",(char *)p, 5) == 0) ||
		    (strncmp("HEAD ",(char *)p, 5) == 0) ||
		    (strncmp("PUT ", (char *)p, 4) == 0)) {
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO, SSL_R_HTTP_REQUEST);
			return -1;
		} else if (strncmp("CONNECT", (char *)p, 7) == 0) {
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO, SSL_R_HTTPS_PROXY_REQUEST);
			return -1;
		}
	}

	if (s->state == SSL23_ST_SR_CLNT_HELLO_B) {
		/* we have SSLv3/TLSv1 in an SSLv2 header
		 * (other cases skip this state) */

		/*
		 * Limit the support of "backward compatible" headers
		 * only to "backward" versions of TLS. If we have moved
		 * on to modernity, just say no.
		 */
		if (s->options & SSL_OP_NO_TLSv1)
			goto unsupported;

		type = 2;
		p = s->packet;
		v[0] = p[3]; /* == SSL3_VERSION_MAJOR */
		v[1] = p[4];

		/* An SSLv3/TLSv1 backwards-compatible CLIENT-HELLO in an SSLv2
		 * header is sent directly on the wire, not wrapped as a TLS
		 * record. It's format is:
		 * Byte  Content
		 * 0-1   msg_length
		 * 2     msg_type
		 * 3-4   version
		 * 5-6   cipher_spec_length
		 * 7-8   session_id_length
		 * 9-10  challenge_length
		 * ...   ...
		 */
		n = ((p[0] & 0x7f) << 8) | p[1];
		if (n > (1024 * 4)) {
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO, SSL_R_RECORD_TOO_LARGE);
			return -1;
		}
		if (n < 9) {
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
			    SSL_R_RECORD_LENGTH_MISMATCH);
			return -1;
		}

		j = ssl23_read_bytes(s, n + 2);
		if (j != n + 2)
			return -1;

		tls1_finish_mac(s, s->packet + 2, s->packet_length - 2);
		if (s->msg_callback)
			s->msg_callback(0, SSL2_VERSION, 0, s->packet + 2,
			    s->packet_length - 2, s, s->msg_callback_arg);

		p = s->packet;
		p += 5;
		n2s(p, csl);
		n2s(p, sil);
		n2s(p, cl);
		d = (unsigned char *)s->init_buf->data;
		if ((csl + sil + cl + 11) != s->packet_length) {
			/*
			 * We can't have TLS extensions in SSL 2.0 format
			 * Client Hello, can we ? Error condition should be
			 * '>' otherwise
			 */
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
			    SSL_R_RECORD_LENGTH_MISMATCH);
			return -1;
		}

		/* record header: msg_type ... */
		*(d++) = SSL3_MT_CLIENT_HELLO;
		/* ... and length (actual value will be written later) */
		d_len = d;
		d += 3;

		/* client_version */
		*(d++) = SSL3_VERSION_MAJOR; /* == v[0] */
		*(d++) = v[1];

		/* lets populate the random area */
		/* get the challenge_length */
		i = (cl > SSL3_RANDOM_SIZE) ? SSL3_RANDOM_SIZE : cl;
		memset(d, 0, SSL3_RANDOM_SIZE);
		memcpy(&(d[SSL3_RANDOM_SIZE - i]), &(p[csl + sil]), i);
		d += SSL3_RANDOM_SIZE;

		/* no session-id reuse */
		*(d++) = 0;

		/* ciphers */
		j = 0;
		dd = d;
		d += 2;
		for (i = 0; i < csl; i += 3) {
			if (p[i] != 0)
				continue;
			*(d++) = p[i + 1];
			*(d++) = p[i + 2];
			j += 2;
		}
		s2n(j, dd);

		/* add in (no) COMPRESSION */
		*(d++) = 1;
		*(d++) = 0;

		i = (d - (unsigned char *)s->init_buf->data) - 4;
		l2n3((long)i, d_len);

		/* get the data reused from the init_buf */
		s->s3->tmp.reuse_message = 1;
		s->s3->tmp.message_type = SSL3_MT_CLIENT_HELLO;
		s->s3->tmp.message_size = i;
	}

	/* imaginary new state (for program structure): */
	/* s->state = SSL23_SR_CLNT_HELLO_C */

	if (type == 2 || type == 3) {
		/* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */

		if (!ssl_init_wbio_buffer(s, 1))
			return -1;

		/* we are in this state */
		s->state = SSL3_ST_SR_CLNT_HELLO_A;

		if (type == 3) {
			/* put the 'n' bytes we have read into the input buffer
			 * for SSLv3 */
			s->rstate = SSL_ST_READ_HEADER;
			s->packet_length = n;
			if (s->s3->rbuf.buf == NULL)
				if (!ssl3_setup_read_buffer(s))
					return -1;

			s->packet = &(s->s3->rbuf.buf[0]);
			memcpy(s->packet, buf, n);
			s->s3->rbuf.left = n;
			s->s3->rbuf.offset = 0;
		} else {
			s->packet_length = 0;
			s->s3->rbuf.left = 0;
			s->s3->rbuf.offset = 0;
		}
		if (s->version == TLS1_2_VERSION)
			s->method = TLSv1_2_server_method();
		else if (s->version == TLS1_1_VERSION)
			s->method = TLSv1_1_server_method();
		else if (s->version == TLS1_VERSION)
			s->method = TLSv1_server_method();
		else
			goto unsupported;
		s->handshake_func = s->method->ssl_accept;
	} else {
		/* bad, very bad */
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO, SSL_R_UNKNOWN_PROTOCOL);
		return -1;
	}
	s->init_num = 0;

	return (SSL_accept(s));

 unsupported:
	SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);
	return -1;
}
@


1.46
log
@Simplify ssl23_get_client_hello error handling.

ssl23_get_client_hello sets type=1 on error and continues processing.
It should return an error immediately to simplify things.  This also
allows us to start removing the last of SSL_OP_NO_SSL*.

Added extra paranoia for s->version to make sure it is set properly.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.45 2015/09/11 18:08:21 jsing Exp $ */
d354 8
@


1.45
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.44 2015/09/11 14:47:56 jsing Exp $ */
d250 3
a252 5
				v[0] = p[3];
				v[1] = p[4];
				/* SSLv2 */
				if (!(s->options & SSL_OP_NO_SSLv2))
					type = 1;
d256 2
a257 1
				/* SSLv3/TLSv1 */
d272 2
a273 4
					} else if (!(s->options & SSL_OP_NO_SSLv3)) {
						type = 1;
					} else if (!(s->options & SSL_OP_NO_SSLv2)) {
						type = 1;
d275 4
a278 5
				} else if (!(s->options & SSL_OP_NO_SSLv3)) {
					type = 1;
				} else if (!(s->options & SSL_OP_NO_SSLv2))
					type = 1;

d324 2
d328 1
d334 2
d458 1
a458 6
	if (type == 1) {
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);
		return -1;
	}

	if ((type == 2) || (type == 3)) {
d489 2
d492 1
a492 1
			s->method = TLSv1_server_method();
d494 1
a494 3
	}

	if ((type < 1) || (type > 3)) {
d502 4
@


1.44
log
@Put the *server_method* data structures and functions in the same place.
We can also now nuke ssl23_get_server_method() since it is the same as
tls1_get_server_method().

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.43 2015/08/29 17:15:52 doug Exp $ */
d161 1
a161 1
			if (!ssl3_init_finished_mac(s)) {
d386 1
a386 1
		ssl3_finish_mac(s, s->packet + 2, s->packet_length - 2);
@


1.43
log
@Now that SSLv3 is going away, TLS_* and SSLv23 are equivalent.

Remove the TLS method data and tls_any_* functions.  Point to SSLv23.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.42 2015/08/27 06:21:15 doug Exp $ */
a119 1
static const SSL_METHOD *ssl23_get_server_method(int ver);
a121 50
const SSL_METHOD SSLv23_server_method_data = {
	.version = TLS1_2_VERSION,
	.ssl_new = tls1_new,
	.ssl_clear = tls1_clear,
	.ssl_free = tls1_free,
	.ssl_accept = ssl23_accept,
	.ssl_connect = ssl_undefined_function,
	.ssl_read = ssl23_read,
	.ssl_peek = ssl23_peek,
	.ssl_write = ssl23_write,
	.ssl_shutdown = ssl_undefined_function,
	.ssl_renegotiate = ssl_undefined_function,
	.ssl_renegotiate_check = ssl_ok,
	.ssl_get_message = ssl3_get_message,
	.ssl_read_bytes = ssl3_read_bytes,
	.ssl_write_bytes = ssl3_write_bytes,
	.ssl_dispatch_alert = ssl3_dispatch_alert,
	.ssl_ctrl = ssl3_ctrl,
	.ssl_ctx_ctrl = ssl3_ctx_ctrl,
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
	.ssl_pending = ssl_undefined_const_function,
	.num_ciphers = ssl3_num_ciphers,
	.get_cipher = ssl3_get_cipher,
	.get_ssl_method = ssl23_get_server_method,
	.get_timeout = ssl23_default_timeout,
	.ssl3_enc = &ssl3_undef_enc_method,
	.ssl_version = ssl_undefined_void_function,
	.ssl_callback_ctrl = ssl3_callback_ctrl,
	.ssl_ctx_callback_ctrl = ssl3_ctx_callback_ctrl,
};

const SSL_METHOD *
SSLv23_server_method(void)
{
	return &SSLv23_server_method_data;
}

static const SSL_METHOD *
ssl23_get_server_method(int ver)
{
	if (ver == TLS1_VERSION)
		return (TLSv1_server_method());
	if (ver == TLS1_1_VERSION)
		return (TLSv1_1_server_method());
	if (ver == TLS1_2_VERSION)
		return (TLSv1_2_server_method());
	return (NULL);
}

a505 6
}

const SSL_METHOD *
TLS_server_method(void)
{
	return &SSLv23_server_method_data;
@


1.42
log
@Remove SSLv3 support from LibreSSL.

This is the first wave of SSLv3 removal which removes the main SSLv3
functions.  Future commits will remove the rest of the SSLv3 support.

Discussed the plan at c2k15.  Input from jsing@@, beck@@, miod@@, bcook@@,
sthen@@, naddy@@, and deraadt@@.

ok jsing@@, beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.41 2015/07/19 07:30:06 doug Exp $ */
a121 1
static const SSL_METHOD *tls_any_get_server_method(int ver);
a154 32
const SSL_METHOD TLS_server_method_data = {
	.version = TLS1_2_VERSION,
	.ssl_new = tls1_new,
	.ssl_clear = tls1_clear,
	.ssl_free = tls1_free,
	.ssl_accept = tls_any_accept,
	.ssl_connect = ssl_undefined_function,
	.ssl_read = ssl23_read,
	.ssl_peek = ssl23_peek,
	.ssl_write = ssl23_write,
	.ssl_shutdown = ssl_undefined_function,
	.ssl_renegotiate = ssl_undefined_function,
	.ssl_renegotiate_check = ssl_ok,
	.ssl_get_message = ssl3_get_message,
	.ssl_read_bytes = ssl3_read_bytes,
	.ssl_write_bytes = ssl3_write_bytes,
	.ssl_dispatch_alert = ssl3_dispatch_alert,
	.ssl_ctrl = ssl3_ctrl,
	.ssl_ctx_ctrl = ssl3_ctx_ctrl,
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
	.ssl_pending = ssl_undefined_const_function,
	.num_ciphers = ssl3_num_ciphers,
	.get_cipher = ssl3_get_cipher,
	.get_ssl_method = tls_any_get_server_method,
	.get_timeout = ssl23_default_timeout,
	.ssl3_enc = &ssl3_undef_enc_method,
	.ssl_version = ssl_undefined_void_function,
	.ssl_callback_ctrl = ssl3_callback_ctrl,
	.ssl_ctx_callback_ctrl = ssl3_ctx_callback_ctrl,
};

d562 1
a562 25
	return &TLS_server_method_data;
}

static const SSL_METHOD *
tls_any_get_server_method(int ver)
{
	if (ver == SSL3_VERSION)
		return (NULL);
	else
		return ssl23_get_server_method(ver);
}

int
tls_any_accept(SSL *s)
{
	int ret;
	unsigned long old_options;

	old_options = s->options;

	s->options |= SSL_OP_NO_SSLv3;
	ret = ssl23_accept(s);
	s->options = old_options;

	return ret;
@


1.41
log
@Fix symbol collision with libtls.

Pointed out by guenther.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.40 2015/07/19 06:31:32 doug Exp $ */
a196 2
	if (ver == SSL3_VERSION)
		return (SSLv3_server_method());
d358 1
a358 3
						s->version = SSL3_VERSION;
						/* type=2; */
						s->state = SSL23_ST_SR_CLNT_HELLO_B;
d363 1
a363 3
					s->version = SSL3_VERSION;
					/* type=2; */
					s->state = SSL23_ST_SR_CLNT_HELLO_B;
a411 3
				} else if (!(s->options & SSL_OP_NO_SSLv3)) {
					s->version = SSL3_VERSION;
					type = 3;
d414 1
a414 5
				/* client requests SSL 3.0 */
				if (!(s->options & SSL_OP_NO_SSLv3)) {
					s->version = SSL3_VERSION;
					type = 3;
				} else if (!(s->options & SSL_OP_NO_TLSv1)) {
d577 1
a577 1
		else if (s->version == TLS1_VERSION)
a578 2
		else
			s->method = SSLv3_server_method();
@


1.40
log
@Add TLS_method, TLS_client_method and TLS_server_method.

Use these instead of SSLv23_*method when you want to make sure TLS is
used.

By default, we disable SSLv3 but it's still possible for the user to
re-enable it.  TLS_*method does not allow SSLv3.

Both BoringSSL and (next version of) OpenSSL have these methods.
However, they have changed the implementation significantly.  We will
as well, but not right now.

Riding the libssl major bump.

ok miod@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.39 2015/03/27 12:29:54 jsing Exp $ */
d122 1
a122 1
static const SSL_METHOD *tls_get_server_method(int ver);
d161 1
a161 1
	.ssl_accept = tls_accept,
d180 1
a180 1
	.get_ssl_method = tls_get_server_method,
d614 1
a614 1
tls_get_server_method(int ver)
d623 1
a623 1
tls_accept(SSL *s)
@


1.39
log
@Factor out the init_buf initialisation code, rather than duplicating it
in four different places.

ok doug@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.38 2015/02/06 08:30:23 jsing Exp $ */
d122 1
d156 32
d605 30
@


1.38
log
@Bring back the horrible API that is get_cipher_by_char/put_cipher_by_char.

This API was intended to be an internal only, however like many things in
OpenSSL, it is exposed externally and parts of the software ecosystem are
now using it since there is no real alternative within the public API.

ok doug@@, tedu@@ and reluctantly miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.37 2014/12/10 15:43:31 jsing Exp $ */
d210 3
a212 12
			if (s->init_buf == NULL) {
				BUF_MEM *buf;
				if ((buf = BUF_MEM_new()) == NULL) {
					ret = -1;
					goto end;
				}
				if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {
					BUF_MEM_free(buf);
					ret = -1;
					goto end;
				}
				s->init_buf = buf;
a213 1

d248 1
d253 1
@


1.37
log
@ssl3_init_finished_mac() calls BIO_new() which can fail since it in turn
calls malloc(). Instead of silently continuing on failure, check the return
value of BIO_new() and propagate failure back to the caller for appropriate
handling.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.36 2014/11/16 14:12:47 jsing Exp $ */
d142 2
@


1.36
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.35 2014/10/18 16:13:16 jsing Exp $ */
d222 4
a225 1
			ssl3_init_finished_mac(s);
@


1.35
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.34 2014/08/10 14:42:56 jsing Exp $ */
d113 1
d115 1
d117 1
a118 1
#include <openssl/evp.h>
@


1.34
log
@Since we no longer need to support SSLv2-style cipher lists, start
unravelling the maze of function pointers and callbacks by directly
calling ssl3_{get,put}_cipher_by_char() and removing the
ssl_{get,put}_cipher_by_char macros.

Prompted by similar changes in boringssl.

ok guenther.
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.33 2014/08/07 19:46:31 miod Exp $ */
a114 1
#include <openssl/rand.h>
@


1.33
log
@When you expect a function to return a particular value, don't put a comment
saying that you expect it to return that value and compare it against zero
because it is supposedly faster, for this leads to bugs (especially given the
high rate of sloppy cut'n'paste within ssl3 and dtls1 routines in this
library).

Instead, compare for the exact value it ought to return upon success.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.32 2014/08/07 04:49:53 deraadt Exp $ */
a140 2
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl23_put_cipher_by_char,
@


1.32
log
@Fix CVE-2014-3511; TLS downgrade, verbatim diff
https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=280b1f1ad12131defcd986676a8fc9717aaa601b
ok guenther miod
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.31 2014/07/11 08:17:36 miod Exp $ */
d451 2
a452 5
		/* We previously read 11 bytes, so if j > 0, we must have
		 * j == n+2 == s->packet_length. We have at least 11 valid
		 * packet bytes. */
		if (j <= 0)
			return (j);
@


1.31
log
@No need to keep ssl23_foo() flavours mapping to ssl3_foo().
ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.30 2014/07/10 08:51:14 tedu Exp $ */
d361 2
a362 2
			 * so we simply assume TLS 1.0 to avoid protocol version downgrade
			 * attacks. */
d364 3
a366 1
				v[1] = TLS1_VERSION_MINOR;
d373 1
a373 1
			else if (p[9] > SSL3_VERSION_MAJOR)
d427 12
d444 5
d451 3
@


1.30
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.29 2014/06/30 14:13:27 tedu Exp $ */
d141 1
a141 1
	.get_cipher_by_char = ssl23_get_cipher_by_char,
d144 2
a145 2
	.num_ciphers = ssl23_num_ciphers,
	.get_cipher = ssl23_get_cipher,
@


1.29
log
@fix the identical leak in three different files.
reported by Brent Cook, original diff by logan
@
text
@d1 1
a1 1
/* $OpenBSD: s23_srvr.c,v 1.28 2014/06/12 15:49:31 deraadt Exp $ */
d490 1
a490 1
		/* COMPRESSION */
@


1.28
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a176 1
	BUF_MEM *buf;
d210 1
d216 1
@


1.27
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@d1 1
a1 1
/* ssl/s23_srvr.c */
@


1.26
log
@Code using malloc() in ssl23_get_client_hello() got removed 12 years ago,
it's time to remove the test for a possible need to free().
ok jsing@@
@
text
@a492 8
#if 0
		/* copy any remaining data with may be extensions */
		p = p + csl + sil + cl;
		while (p <  s->packet + s->packet_length) {
			*(d++)=*(p++);
		}
#endif

a544 3
#if 0 /* ssl3_get_client_hello does this */
		s->client_version = (v[0]<<8)|v[1];
#endif
@


1.25
log
@DeIMPLEMENT libssl. Expand the IMPLEMENT_* macros since it is far more
readable and one less layer of abstraction. Use C99 initialisers for
clarity, grepability and to protect from future field reordering/removal.

ok miod@@ (tedu@@ also thought it was a wonderful idea, beck@@ also agreed,
but ran away squealing since it reminded him of the VOP layer...)
@
text
@d264 15
a278 14
	char buf_space[11]; /* Request this many bytes in initial read.
	* We can detect SSL 3.0/TLS 1.0 Client Hellos
	* ('type == 3') correctly only when the following
	* is in a single record, which is not guaranteed by
	* the protocol specification:
	* Byte  Content
	*  0     type            \
	                     *  1/2   version          > record header
	*  3/4   length          /
	*  5     msg_type        \
	                     *  6-8   length           > Client Hello message
	*  9/10  client_version  /
	                     */
	char *buf = &(buf_space[0]);
d291 1
a291 1
			goto err;
d293 3
a295 3
		n = ssl23_read_bytes(s, sizeof buf_space);
		if (n != sizeof buf_space)
			return(n); /* n == -1 || n == 0 */
d408 1
a408 1
			goto err;
d411 1
a411 1
			goto err;
d427 1
a427 1
			goto err;
d453 1
a453 1
			goto err;
d515 1
a515 1
		goto err;
d522 1
a522 1
			goto err;
d534 1
a534 1
					goto err;
d562 1
a562 1
		goto err;
a565 2
	if (buf != buf_space)
		free(buf);
a566 4
err:
	if (buf != buf_space)
		free(buf);
	return (-1);
@


1.24
log
@More KNF.
@
text
@d121 39
a172 3

IMPLEMENT_ssl23_meth_func(SSLv23_server_method,
    ssl23_accept, ssl_undefined_function, ssl23_get_server_method)
@


1.23
log
@More KNF and style consistency tweaks
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d310 2
a311 2
		    ((p[3] == 0 && p[4] < 5 /* silly record length? */)
		    || (p[9] >= p[1]))) {
d400 1
a400 1
			    s->packet_length-2, s, s->msg_callback_arg);
d408 1
a408 2
		if ((csl + sil + cl + 11) != s->packet_length)
		{
d484 2
a485 1
		if (!ssl_init_wbio_buffer(s, 1)) goto err;
@


1.22
log
@whack a bunch of disabled code. ok beck lteo
@
text
@d126 1
a126 1
	else if (ver == TLS1_VERSION)
d128 1
a128 1
	else if (ver == TLS1_1_VERSION)
d130 1
a130 1
	else if (ver == TLS1_2_VERSION)
d132 1
a132 2
	else
		return (NULL);
@


1.21
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a326 4
#if 0
				SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO, SSL_R_RECORD_TOO_SMALL);
				goto err;
#else
a327 1
#endif
@


1.20
log
@Kill the bogus "send an SSLv3/TLS hello in SSLv2 format" crap from
the SSLv23_* client code.  The server continues to accept it.  It
also kills the bits for SSL2 SESSIONs; even when the server gets
an SSLv2-style compat handshake, the session that it creates has
the correct version internally.

ok tedu@@ beck@@
@
text
@d536 1
a536 1
		OPENSSL_free(buf);
d540 1
a540 1
		OPENSSL_free(buf);
@


1.19
log
@remove ssl2 support even more completely.
in the process, always include ssl3 and tls1, we don't need config options
for them. when the time comes to expire ssl3, it will be with an ax.
checked by miod
@
text
@d121 2
a122 2
static const SSL_METHOD
*ssl23_get_server_method(int ver)
d405 2
a406 1
			s->msg_callback(0, SSL2_VERSION, 0, s->packet + 2, s->packet_length-2, s, s->msg_callback_arg); /* CLIENT-HELLO */
d414 1
a414 3
		if ((csl + sil + cl + 11) != s->packet_length) /* We can't have TLS extensions in SSL 2.0 format
			* Client Hello, can we ? Error condition should be
		                                          * '>' otherweise */
d416 7
a422 1
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO, SSL_R_RECORD_LENGTH_MISMATCH);
@


1.18
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok miod
@
text
@a123 4
#ifndef OPENSSL_NO_SSL2
	if (ver == SSL2_VERSION)
		return (SSLv2_server_method());
#endif
a478 1
#ifdef OPENSSL_NO_SSL2
a480 39
#else
		/* we are talking sslv2 */
		/* we need to clean up the SSLv3/TLSv1 setup and put in the
		 * sslv2 stuff. */

		if (s->s2 == NULL) {
			if (!ssl2_new(s))
				goto err;
		} else
			ssl2_clear(s);

		if (s->s3 != NULL)
			ssl3_free(s);

		if (!BUF_MEM_grow_clean(s->init_buf,
			SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)) {
			goto err;
		}

		s->state = SSL2_ST_GET_CLIENT_HELLO_A;
		if (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)
			s->s2->ssl2_rollback = 0;
		else
			/* reject SSL 2.0 session if client supports SSL 3.0 or TLS 1.0
			 * (SSL 3.0 draft/RFC 2246, App. E.2) */
		s->s2->ssl2_rollback = 1;

		/* setup the n bytes we have read so we get them from
		 * the sslv2 buffer */
		s->rstate = SSL_ST_READ_HEADER;
		s->packet_length = n;
		s->packet = &(s->s2->rbuf[0]);
		memcpy(s->packet, buf, n);
		s->s2->rbuf_left = n;
		s->s2->rbuf_offs = 0;

		s->method = SSLv2_server_method();
		s->handshake_func = s->method->ssl_accept;
#endif
@


1.17
log
@So the OpenSSL codebase does "get the time, add it as a random seed"
in a bunch of places inside the TLS engine, to try to keep entropy high.
I wonder if their moto is "If you can't solve a problem, at least try
to do it badly".
ok miod
@
text
@a117 3
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif
a386 8

#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (s->version < TLS1_VERSION)) {
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
		    SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		goto err;
	}
#endif
@


1.16
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a149 1
	unsigned long Time = (unsigned long)time(NULL);
a153 1
	RAND_add(&Time, sizeof(Time), 0);
@


1.15
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@d124 3
a126 2
static const SSL_METHOD *ssl23_get_server_method(int ver)
	{
d129 1
a129 1
		return(SSLv2_server_method());
d132 1
a132 1
		return(SSLv3_server_method());
d134 1
a134 1
		return(TLSv1_server_method());
d136 1
a136 1
		return(TLSv1_1_server_method());
d138 1
a138 1
		return(TLSv1_2_server_method());
d140 2
a141 2
		return(NULL);
	}
d144 1
a144 3
			ssl23_accept,
			ssl_undefined_function,
			ssl23_get_server_method)
d146 3
a148 2
int ssl23_accept(SSL *s)
	{
d150 4
a153 4
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state;
d155 1
a155 1
	RAND_add(&Time,sizeof(Time),0);
d160 1
a160 1
		cb=s->info_callback;
d162 2
a163 2
		cb=s->ctx->info_callback;
	
d165 2
a166 1
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 
d168 2
a169 3
	for (;;)
		{
		state=s->state;
d171 1
a171 2
		switch(s->state)
			{
d177 3
a179 2
			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
d182 1
a182 1
			s->type=SSL_ST_ACCEPT;
d184 3
a186 5
			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
d188 3
a190 4
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
a191 2
					}
				s->init_buf=buf;
d193 2
d198 1
a198 1
			s->state=SSL23_ST_SR_CLNT_HELLO_A;
d200 1
a200 1
			s->init_num=0;
d206 4
a209 3
			s->shutdown=0;
			ret=ssl23_get_client_hello(s);
			if (ret >= 0) cb=NULL;
d214 2
a215 2
			SSLerr(SSL_F_SSL23_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
d218 1
a218 1
			}
d220 5
a224 7
		if ((cb != NULL) && (s->state != state))
			{
			new_state=s->state;
			s->state=state;
			cb(s,SSL_CB_ACCEPT_LOOP,1);
			s->state=new_state;
			}
d226 1
d230 3
a232 3
		cb(s,SSL_CB_ACCEPT_EXIT,ret);
	return(ret);
	}
d235 3
a237 2
int ssl23_get_client_hello(SSL *s)
	{
d239 6
a244 6
	                     * We can detect SSL 3.0/TLS 1.0 Client Hellos
	                     * ('type == 3') correctly only when the following
	                     * is in a single record, which is not guaranteed by
	                     * the protocol specification:
	                     * Byte  Content
	                     *  0     type            \
d246 2
a247 2
	                     *  3/4   length          /
	                     *  5     msg_type        \
d249 1
a249 1
	                     *  9/10  client_version  /
d251 2
a252 2
	char *buf= &(buf_space[0]);
	unsigned char *p,*d,*d_len,*dd;
d254 3
a256 3
	unsigned int csl,sil,cl;
	int n=0,j;
	int type=0;
d259 1
a259 2
	if (s->state ==	SSL23_ST_SR_CLNT_HELLO_A)
		{
d261 1
a261 1
		v[0]=v[1]=0;
d263 2
a264 1
		if (!ssl3_setup_buffers(s)) goto err;
d266 3
a268 2
		n=ssl23_read_bytes(s, sizeof buf_space);
		if (n != sizeof buf_space) return(n); /* n == -1 || n == 0 */
d270 1
a270 1
		p=s->packet;
d272 1
a272 1
		memcpy(buf,p,n);
d274 1
a274 2
		if ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))
			{
d278 3
a280 3
			if ((p[3] == 0x00) && (p[4] == 0x02))
				{
				v[0]=p[3]; v[1]=p[4];
d283 4
a286 5
					type=1;
				}
			else if (p[3] == SSL3_VERSION_MAJOR)
				{
				v[0]=p[3]; v[1]=p[4];
d288 1
a288 2
				if (p[4] >= TLS1_VERSION_MINOR)
					{
d290 6
a295 9
					   !(s->options & SSL_OP_NO_TLSv1_2))
						{
						s->version=TLS1_2_VERSION;
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (p[4] >= TLS1_1_VERSION_MINOR &&
					   !(s->options & SSL_OP_NO_TLSv1_1))
						{
						s->version=TLS1_1_VERSION;
d297 3
a299 5
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_TLSv1))
						{
						s->version=TLS1_VERSION;
d301 3
a303 5
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_SSLv3))
						{
						s->version=SSL3_VERSION;
d305 3
a307 6
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_SSLv2))
						{
						type=1;
						}
d309 2
a310 3
				else if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
d312 3
a314 4
					s->state=SSL23_ST_SR_CLNT_HELLO_B;
					}
				else if (!(s->options & SSL_OP_NO_SSLv2))
					type=1;
a315 1
				}
d317 5
a321 6
		else if ((p[0] == SSL3_RT_HANDSHAKE) &&
			 (p[1] == SSL3_VERSION_MAJOR) &&
			 (p[5] == SSL3_MT_CLIENT_HELLO) &&
			 ((p[3] == 0 && p[4] < 5 /* silly record length? */)
				|| (p[9] >= p[1])))
			{
d325 2
a326 2
			
			v[0]=p[1]; /* major version (= SSL3_VERSION_MAJOR) */
d335 1
a335 2
			if (p[3] == 0 && p[4] < 6)
				{
d337 1
a337 1
				SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);
d342 1
a342 1
				}
d349 1
a349 1
				v[1]=0xff;
d351 2
a352 3
				v[1]=p[10]; /* minor version according to client_version */
			if (v[1] >= TLS1_VERSION_MINOR)
				{
d354 13
a366 21
					!(s->options & SSL_OP_NO_TLSv1_2))
					{
					s->version=TLS1_2_VERSION;
					type=3;
					}
				else if (v[1] >= TLS1_1_VERSION_MINOR &&
					!(s->options & SSL_OP_NO_TLSv1_1))
					{
					s->version=TLS1_1_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_TLSv1))
					{
					s->version=TLS1_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					type=3;
					}
d368 1
a368 2
			else
				{
d370 4
a373 7
				if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_TLSv1))
					{
d376 2
a377 3
					s->version=TLS1_VERSION;
					type=3;
					}
d380 6
a385 6
		else if ((strncmp("GET ", (char *)p,4) == 0) ||
			 (strncmp("POST ",(char *)p,5) == 0) ||
			 (strncmp("HEAD ",(char *)p,5) == 0) ||
			 (strncmp("PUT ", (char *)p,4) == 0))
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);
d387 2
a388 4
			}
		else if (strncmp("CONNECT",(char *)p,7) == 0)
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);
a389 1
			}
d391 1
d394 1
a394 2
	if (FIPS_mode() && (s->version < TLS1_VERSION))
		{
d396 1
a396 1
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
d398 1
a398 1
		}
d401 1
a401 2
	if (s->state == SSL23_ST_SR_CLNT_HELLO_B)
		{
d405 2
a406 2
		type=2;
		p=s->packet;
d410 3
a412 4
		n=((p[0]&0x7f)<<8)|p[1];
		if (n > (1024*4))
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);
d414 1
a414 1
			}
d416 3
a418 2
		j=ssl23_read_bytes(s,n+2);
		if (j <= 0) return(j);
d420 1
a420 1
		ssl3_finish_mac(s, s->packet+2, s->packet_length-2);
d422 1
a422 1
			s->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg); /* CLIENT-HELLO */
d424 8
a431 8
		p=s->packet;
		p+=5;
		n2s(p,csl);
		n2s(p,sil);
		n2s(p,cl);
		d=(unsigned char *)s->init_buf->data;
		if ((csl+sil+cl+11) != s->packet_length) /* We can't have TLS extensions in SSL 2.0 format
		                                          * Client Hello, can we? Error condition should be
d433 2
a434 2
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);
d436 1
a436 1
			}
d450 4
a453 4
		i=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;
		memset(d,0,SSL3_RANDOM_SIZE);
		memcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);
		d+=SSL3_RANDOM_SIZE;
d456 1
a456 1
		*(d++)=0;
d459 11
a469 11
		j=0;
		dd=d;
		d+=2;
		for (i=0; i<csl; i+=3)
			{
			if (p[i] != 0) continue;
			*(d++)=p[i+1];
			*(d++)=p[i+2];
			j+=2;
			}
		s2n(j,dd);
d472 3
a474 3
		*(d++)=1;
		*(d++)=0;
		
d476 3
a478 4
                /* copy any remaining data with may be extensions */
	        p = p+csl+sil+cl;
		while (p <  s->packet+s->packet_length)
			{
d480 1
a480 1
			}
d483 1
a483 1
		i = (d-(unsigned char *)s->init_buf->data) - 4;
d487 4
a490 4
		s->s3->tmp.reuse_message=1;
		s->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;
		s->s3->tmp.message_size=i;
		}
d495 1
a495 2
	if (type == 1)
		{
d497 1
a497 1
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
d504 1
a504 2
		if (s->s2 == NULL)
			{
d507 1
a507 2
			}
		else
d510 2
a511 1
		if (s->s3 != NULL) ssl3_free(s);
d514 1
a514 2
			SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))
			{
d516 1
a516 1
			}
d518 1
a518 1
		s->state=SSL2_ST_GET_CLIENT_HELLO_A;
d520 1
a520 1
			s->s2->ssl2_rollback=0;
d524 1
a524 1
			s->s2->ssl2_rollback=1;
d528 6
a533 6
		s->rstate=SSL_ST_READ_HEADER;
		s->packet_length=n;
		s->packet= &(s->s2->rbuf[0]);
		memcpy(s->packet,buf,n);
		s->s2->rbuf_left=n;
		s->s2->rbuf_offs=0;
d535 2
a536 2
		s->method=SSLv2_server_method();
		s->handshake_func=s->method->ssl_accept;
d538 1
a538 1
		}
d540 1
a540 2
	if ((type == 2) || (type == 3))
		{
d543 1
a543 1
		if (!ssl_init_wbio_buffer(s,1)) goto err;
d546 1
a546 1
		s->state=SSL3_ST_SR_CLNT_HELLO_A;
d548 1
a548 2
		if (type == 3)
			{
d551 2
a552 2
			s->rstate=SSL_ST_READ_HEADER;
			s->packet_length=n;
d557 9
a565 11
			s->packet= &(s->s3->rbuf.buf[0]);
			memcpy(s->packet,buf,n);
			s->s3->rbuf.left=n;
			s->s3->rbuf.offset=0;
			}
		else
			{
			s->packet_length=0;
			s->s3->rbuf.left=0;
			s->s3->rbuf.offset=0;
			}
d575 1
a575 1
		s->client_version=(v[0]<<8)|v[1];
d577 4
a580 5
		s->handshake_func=s->method->ssl_accept;
		}
	
	if ((type < 1) || (type > 3))
		{
d582 1
a582 1
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);
d584 2
a585 2
		}
	s->init_num=0;
d587 3
a589 2
	if (buf != buf_space) OPENSSL_free(buf);
	return(SSL_accept(s));
d591 4
a594 3
	if (buf != buf_space) OPENSSL_free(buf);
	return(-1);
	}
@


1.14
log
@resolve conflicts
@
text
@d157 1
a157 1
	clear_sys_error();
@


1.14.4.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d351 2
a352 2
			 * so we simply reject such connections to avoid
			 * protocol version downgrade attacks. */
d355 1
d358 3
d367 1
a367 1
			if (p[9] > SSL3_VERSION_MAJOR)
a446 12
		/* An SSLv3/TLSv1 backwards-compatible CLIENT-HELLO in an SSLv2
		 * header is sent directly on the wire, not wrapped as a TLS
		 * record. It's format is:
		 * Byte  Content
		 * 0-1   msg_length
		 * 2     msg_type
		 * 3-4   version
		 * 5-6   cipher_spec_length
		 * 7-8   session_id_length
		 * 9-10  challenge_length
		 * ...   ...
		 */
a452 5
		if (n < 9)
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);
			goto err;
			}
a454 3
		/* We previously read 11 bytes, so if j > 0, we must have
		 * j == n+2 == s->packet_length. We have at least 11 valid
		 * packet bytes. */
@


1.14.8.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d351 2
a352 2
			 * so we simply reject such connections to avoid
			 * protocol version downgrade attacks. */
d355 1
d358 3
d367 1
a367 1
			if (p[9] > SSL3_VERSION_MAJOR)
a446 12
		/* An SSLv3/TLSv1 backwards-compatible CLIENT-HELLO in an SSLv2
		 * header is sent directly on the wire, not wrapped as a TLS
		 * record. It's format is:
		 * Byte  Content
		 * 0-1   msg_length
		 * 2     msg_type
		 * 3-4   version
		 * 5-6   cipher_spec_length
		 * 7-8   session_id_length
		 * 9-10  challenge_length
		 * ...   ...
		 */
a452 5
		if (n < 9)
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);
			goto err;
			}
a454 3
		/* We previously read 11 bytes, so if j > 0, we must have
		 * j == n+2 == s->packet_length. We have at least 11 valid
		 * packet bytes. */
@


1.13
log
@resolve conflicts, fix local changes
@
text
@d118 3
d134 4
d293 14
a306 1
					if (!(s->options & SSL_OP_NO_TLSv1))
d373 13
a385 1
				if (!(s->options & SSL_OP_NO_TLSv1))
d428 9
d611 5
a615 2

		if (s->version == TLS1_VERSION)
@


1.12
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d119 1
a119 1
static SSL_METHOD *ssl23_get_server_method(int ver);
d121 1
a121 1
static SSL_METHOD *ssl23_get_server_method(int ver)
d318 1
a318 1
				|| (p[9] == p[1])))
d342 7
a395 9
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (s->version < TLS1_VERSION))
		{
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		goto err;
		}
#endif

d426 3
a428 1
		if ((csl+sil+cl+11) != s->packet_length)
d471 9
d555 4
@


1.11
log
@resolve conflicts
@
text
@d389 9
@


1.10
log
@resolve conflicts
@
text
@d135 4
a138 22
SSL_METHOD *SSLv23_server_method(void)
	{
	static int init=1;
	static SSL_METHOD SSLv23_server_data;

	if (init)
		{
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);

		if (init)
			{
			memcpy((char *)&SSLv23_server_data,
				(char *)sslv23_base_method(),sizeof(SSL_METHOD));
			SSLv23_server_data.ssl_accept=ssl23_accept;
			SSLv23_server_data.get_ssl_method=ssl23_get_server_method;
			init=0;
			}

		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);
		}
	return(&SSLv23_server_data);
	}
a388 9
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (s->version < TLS1_VERSION))
		{
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		goto err;
		}
#endif

a567 1
	s->first_packet=1;
@


1.9
log
@fix potential SSL 2.0 rollback (http://www.openssl.org//news/secadv_20051011.txt)
from http://www.openssl.org/news/patch-CAN-2005-2969.txt
@
text
@d161 1
a161 1
	unsigned long Time=time(NULL);
a270 3
#ifndef OPENSSL_NO_RSA
	int use_sslv2_strong=0;
#endif
@


1.8
log
@resolve conflicts
@
text
@d531 1
a531 3
		if ((s->options & SSL_OP_MSIE_SSLV2_RSA_PADDING) ||
			use_sslv2_strong ||
			(s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3))
@


1.8.2.1
log
@MFC:
Fix by markus@@

fix potential SSL 2.0 rollback (http://www.openssl.org//news/secadv_20051011.txt)
from http://www.openssl.org/news/patch-CAN-2005-2969.txt
@
text
@d531 3
a533 1
		if (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d410 9
@


1.7.8.1
log
@MFC:
Fix by markus@@

fix potential SSL 2.0 rollback (http://www.openssl.org//news/secadv_20051011.txt)
from http://www.openssl.org/news/patch-CAN-2005-2969.txt
@
text
@d522 3
a524 1
		if (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)
@


1.7.6.1
log
@MFC:
Fix by markus@@

fix potential SSL 2.0 rollback (http://www.openssl.org//news/secadv_20051011.txt)
from http://www.openssl.org/news/patch-CAN-2005-2969.txt
@
text
@d522 3
a524 1
		if (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)
@


1.6
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d142 12
a153 5
		memcpy((char *)&SSLv23_server_data,
			(char *)sslv23_base_method(),sizeof(SSL_METHOD));
		SSLv23_server_data.ssl_accept=ssl23_accept;
		SSLv23_server_data.get_ssl_method=ssl23_get_server_method;
		init=0;
d515 1
a515 1
		if (!BUF_MEM_grow(s->init_buf,
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d113 1
a117 1
#include "ssl_locl.h"
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d58 53
d123 1
a123 1
#ifndef NO_SSL2
d155 1
a155 1
	void (*cb)()=NULL;
d168 1
a169 1
	s->in_handshake++;
d235 1
a237 1
	s->in_handshake--;
d258 1
a258 1
	unsigned char *p,*d,*dd;
d264 1
a264 1
#ifndef NO_RSA
a325 66
				if (s->options & SSL_OP_NON_EXPORT_FIRST)
					/* Not only utterly confusing, but broken
					 * ('fractured programming'?) -- the details
					 * of this block nearly make it work
					 * as intended in this environment, but on one
					 * of the fine points (w.r.t. restarts) it fails.
					 * The obvious fix would be even more devastating
					 * to program structure; if you want the functionality,
					 * throw this away and implement it in a way
					 * that makes sense */
					{
#if 0
					STACK_OF(SSL_CIPHER) *sk;
					SSL_CIPHER *c;
					int ne2,ne3;

					j=((p[0]&0x7f)<<8)|p[1];
					if (j > (1024*4))
						{
						SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);
						goto err;
						}

					n=ssl23_read_bytes(s,j+2);
					if (n <= 0) return(n);
					p=s->packet;

					if ((buf=OPENSSL_malloc(n)) == NULL)
						{
						SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,ERR_R_MALLOC_FAILURE);
						goto err;
						}
					memcpy(buf,p,n);

					p+=5;
					n2s(p,csl);
					p+=4;

					sk=ssl_bytes_to_cipher_list(
						s,p,csl,NULL);
					if (sk != NULL)
						{
						ne2=ne3=0;
						for (j=0; j<sk_SSL_CIPHER_num(sk); j++)
							{
							c=sk_SSL_CIPHER_value(sk,j);
							if (!SSL_C_IS_EXPORT(c))
								{
								if ((c->id>>24L) == 2L)
									ne2=1;
								else
									ne3=1;
								}
							}
						if (ne2 && !ne3)
							{
							type=1;
							use_sslv2_strong=1;
							goto next_bit;
							}
						}
#else
					SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_OPTION);
					goto err;
#endif
					}
d342 5
a346 5
			 * Client Hello message, this would be difficult, we'd have
			 * to read at least one additional record to find out.
			 * This doesn't usually happen in real life, so we just complain
			 * for now.
			 */
d349 1
d352 3
d356 2
a357 1
			v[1]=p[10]; /* minor version according to client_version */
d371 1
a371 1
			else if (!(s->options & SSL_OP_NO_SSLv3))
d373 13
a385 2
				s->version=SSL3_VERSION;
				type=3;
d423 3
a425 1
		ssl3_finish_mac(s,&(s->packet[2]),s->packet_length-2);
d439 7
d476 2
a477 1
		i=(d-(unsigned char *)s->init_buf->data);
d490 1
a490 1
#ifdef NO_SSL2
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d300 1
a300 1
					if ((buf=Malloc(n)) == NULL)
d351 1
a351 1
			v[0]=p[1]; /* major version */
d353 7
a359 6
			 * to get the correct minor version: */
			v[1]=p[10];
			/* However if we have only a pathologically small fragment of the
			 * Client Hello message, we simply use the version from the
			 * record header -- this is incorrect but unlikely to fail in
			 * practice */
d361 5
a365 1
				v[1]=p[2];
d503 2
a504 1
			use_sslv2_strong)
d507 2
d570 1
a570 1
	if (buf != buf_space) Free(buf);
d574 1
a574 1
	if (buf != buf_space) Free(buf);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d70 1
d73 1
d106 1
a106 1
	RAND_seed(&Time,sizeof(Time));
d191 13
a203 1
	char buf_space[8];
d208 2
a209 2
	int n=0,j,tls1=0;
	int type=0,use_sslv2_strong=0;
d211 3
a214 2
	/* read the initial header */
	v[0]=v[1]=0;
d217 3
d222 2
a223 2
		n=ssl23_read_bytes(s,7);
		if (n != 7) return(n); /* n == -1 || n == 0 */
d231 3
a233 1
			/* SSLv2 header */
d249 2
a250 1
						tls1=1;
d255 2
d265 3
d269 1
d274 9
d284 1
d334 4
d343 19
a361 5
			 (p[5] == SSL3_MT_CLIENT_HELLO))
			{
			v[0]=p[1]; v[1]=p[2];
			/* true SSLv3 or tls1 */
			if (p[2] >= TLS1_VERSION_MINOR)
d365 1
a366 1
					tls1=1;
d369 2
d372 1
d375 2
d378 1
a394 1
next_bit:
d397 3
a399 1
		/* we have a SSLv3/TLSv1 in a SSLv2 header */
d402 3
d429 2
a430 5
		*(d++)=SSL3_VERSION_MAJOR;
		if (tls1)
			*(d++)=TLS1_VERSION_MINOR;
		else
			*(d++)=SSL3_VERSION_MINOR;
d433 1
a433 1
		/* get the chalenge_length */
d467 3
d472 4
d503 1
a503 1
		/* setup the 5 bytes we have read so we get them from
d514 1
d519 1
a519 1
		/* we have SSLv3/TLSv1 */
d544 2
a545 5
		if (tls1)
			{
			s->version=TLS1_VERSION;
			s->method=TLSv1_server_method();
			}
d547 2
a548 4
			{
			s->version=SSL3_VERSION;
			s->method=SSLv3_server_method();
			}
d550 1
a568 1

@


1.1
log
@Initial revision
@
text
@d60 4
a63 4
#include "buffer.h"
#include "rand.h"
#include "objects.h"
#include "evp.h"
d66 1
a66 3
#define BREAK break

#ifndef NOPROTO
d68 1
a68 6
#else
int ssl23_get_client_hello();
#endif

static SSL_METHOD *ssl23_get_server_method(ver)
int ver;
d72 1
a72 1
	else if (ver == SSL3_VERSION)
d80 1
a80 1
SSL_METHOD *SSLv23_server_method()
a86 1
		init=0;
d91 1
d96 1
a96 2
int ssl23_accept(s)
SSL *s;
d104 1
a104 1
	RAND_seed((unsigned char *)&Time,sizeof(Time));
d127 1
d151 1
a151 1
			s->ctx->sess_accept++;
d162 1
a162 1
			break;
d187 1
a187 2
int ssl23_get_client_hello(s)
SSL *s;
d196 1
d199 1
d205 1
a205 1
		if (n != 7) return(n);
d216 1
d223 1
d236 4
d243 2
d248 1
a248 1
					STACK *sk;
d279 1
a279 1
						for (j=0; j<sk_num(sk); j++)
d281 2
a282 2
							c=(SSL_CIPHER *)sk_value(sk,j);
							if (!(c->algorithms & SSL_EXP))
d304 1
d319 4
a322 4
		else if ((strncmp("GET ", p,4) == 0) ||
			 (strncmp("POST ",p,5) == 0) ||
			 (strncmp("HEAD ",p,5) == 0) ||
			 (strncmp("PUT ", p,4) == 0))
d327 1
a327 1
		else if (strncmp("CONNECT",p,7) == 0)
d393 1
a393 1
		/* compression */
d484 1
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d60 4
a63 4
#include <openssl/buffer.h>
#include <openssl/rand.h>
#include <openssl/objects.h>
#include <openssl/evp.h>
d66 3
a68 1
static SSL_METHOD *ssl23_get_server_method(int ver);
d70 6
a75 1
static SSL_METHOD *ssl23_get_server_method(int ver)
a76 1
#ifndef OPENSSL_NO_SSL2
d79 1
a79 2
#endif
	if (ver == SSL3_VERSION)
d87 1
a87 1
SSL_METHOD *SSLv23_server_method(void)
d94 1
a98 1
		init=0;
d103 2
a104 1
int ssl23_accept(SSL *s)
d108 1
a108 1
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
d112 1
a112 1
	RAND_add(&Time,sizeof(Time),0);
d121 1
a122 1
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 
a134 1
			s->server=1;
d158 1
a158 1
			s->ctx->stats.sess_accept++;
d169 1
a169 1
			/* break; */
a186 1
	s->in_handshake--;
d189 1
d194 2
a195 1
int ssl23_get_client_hello(SSL *s)
d197 1
a197 13
	char buf_space[11]; /* Request this many bytes in initial read.
	                     * We can detect SSL 3.0/TLS 1.0 Client Hellos
	                     * ('type == 3') correctly only when the following
	                     * is in a single record, which is not guaranteed by
	                     * the protocol specification:
	                     * Byte  Content
	                     *  0     type            \
	                     *  1/2   version          > record header
	                     *  3/4   length          /
	                     *  5     msg_type        \
	                     *  6-8   length           > Client Hello message
	                     *  9/10  client_version  /
	                     */
d199 1
a199 1
	unsigned char *p,*d,*d_len,*dd;
d202 2
a203 6
	int n=0,j;
	int type=0;
	int v[2];
#ifndef OPENSSL_NO_RSA
	int use_sslv2_strong=0;
#endif
d205 1
a207 3
		/* read the initial header */
		v[0]=v[1]=0;

d210 2
a211 2
		n=ssl23_read_bytes(s, sizeof buf_space);
		if (n != sizeof buf_space) return(n); /* n == -1 || n == 0 */
d219 1
a219 3
			/*
			 * SSLv2 header
			 */
a221 1
				v[0]=p[3]; v[1]=p[4];
a227 1
				v[0]=p[3]; v[1]=p[4];
d233 1
a233 2
						s->version=TLS1_VERSION;
						/* type=2; */ /* done later to survive restarts */
a237 2
						s->version=SSL3_VERSION;
						/* type=2; */
a239 4
					else if (!(s->options & SSL_OP_NO_SSLv2))
						{
						type=1;
						}
d242 3
d246 49
a294 3
					s->version=SSL3_VERSION;
					/* type=2; */
					s->state=SSL23_ST_SR_CLNT_HELLO_B;
a295 3
				else if (!(s->options & SSL_OP_NO_SSLv2))
					type=1;

d300 4
a303 29
			 (p[5] == SSL3_MT_CLIENT_HELLO) &&
			 ((p[3] == 0 && p[4] < 5 /* silly record length? */)
				|| (p[9] == p[1])))
			{
			/*
			 * SSLv3 or tls1 header
			 */
			
			v[0]=p[1]; /* major version (= SSL3_VERSION_MAJOR) */
			/* We must look at client_version inside the Client Hello message
			 * to get the correct minor version.
			 * However if we have only a pathologically small fragment of the
			 * Client Hello message, this would be difficult, and we'd have
			 * to read more records to find out.
			 * No known SSL 3.0 client fragments ClientHello like this,
			 * so we simply assume TLS 1.0 to avoid protocol version downgrade
			 * attacks. */
			if (p[3] == 0 && p[4] < 6)
				{
#if 0
				SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);
				goto err;
#else
				v[1] = TLS1_VERSION_MINOR;
#endif
				}
			else
				v[1]=p[10]; /* minor version according to client_version */
			if (v[1] >= TLS1_VERSION_MINOR)
a306 1
					s->version=TLS1_VERSION;
d308 1
a310 18
					{
					s->version=SSL3_VERSION;
					type=3;
					}
				}
			else
				{
				/* client requests SSL 3.0 */
				if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_TLSv1))
					{
					/* we won't be able to use TLS of course,
					 * but this will send an appropriate alert */
					s->version=TLS1_VERSION;
a311 1
					}
d313 2
d316 4
a319 4
		else if ((strncmp("GET ", (char *)p,4) == 0) ||
			 (strncmp("POST ",(char *)p,5) == 0) ||
			 (strncmp("HEAD ",(char *)p,5) == 0) ||
			 (strncmp("PUT ", (char *)p,4) == 0))
d324 1
a324 1
		else if (strncmp("CONNECT",(char *)p,7) == 0)
d331 1
d334 1
a334 3
		/* we have SSLv3/TLSv1 in an SSLv2 header
		 * (other cases skip this state) */

a336 3
		v[0] = p[3]; /* == SSL3_VERSION_MAJOR */
		v[1] = p[4];

d347 1
a347 3
		ssl3_finish_mac(s, s->packet+2, s->packet_length-2);
		if (s->msg_callback)
			s->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg); /* CLIENT-HELLO */
d361 5
a365 9
		/* record header: msg_type ... */
		*(d++) = SSL3_MT_CLIENT_HELLO;
		/* ... and length (actual value will be written later) */
		d_len = d;
		d += 3;

		/* client_version */
		*(d++) = SSL3_VERSION_MAJOR; /* == v[0] */
		*(d++) = v[1];
d368 1
a368 1
		/* get the challenge_length */
d390 1
a390 1
		/* COMPRESSION */
d394 1
a394 2
		i = (d-(unsigned char *)s->init_buf->data) - 4;
		l2n3((long)i, d_len);
a401 3
	/* imaginary new state (for program structure): */
	/* s->state = SSL23_SR_CLNT_HELLO_C */

a403 4
#ifdef OPENSSL_NO_SSL2
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
		goto err;
#else
d426 1
a426 2
			use_sslv2_strong ||
			(s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3))
a428 2
			/* reject SSL 2.0 session if client supports SSL 3.0 or TLS 1.0
			 * (SSL 3.0 draft/RFC 2246, App. E.2) */
d431 1
a431 1
		/* setup the n bytes we have read so we get them from
a441 1
#endif
d446 1
a446 1
		/* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */
d471 5
a475 2
		if (s->version == TLS1_VERSION)
			s->method = TLSv1_server_method();
d477 4
a480 4
			s->method = SSLv3_server_method();
#if 0 /* ssl3_get_client_hello does this */
		s->client_version=(v[0]<<8)|v[1];
#endif
d492 1
a492 1
	if (buf != buf_space) OPENSSL_free(buf);
d496 1
a496 1
	if (buf != buf_space) OPENSSL_free(buf);
d499 1
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a112 1
#include "ssl_locl.h"
d117 1
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d142 5
a146 12
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);

		if (init)
			{
			memcpy((char *)&SSLv23_server_data,
				(char *)sslv23_base_method(),sizeof(SSL_METHOD));
			SSLv23_server_data.ssl_accept=ssl23_accept;
			SSLv23_server_data.get_ssl_method=ssl23_get_server_method;
			init=0;
			}

		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);
d508 1
a508 1
		if (!BUF_MEM_grow_clean(s->init_buf,
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a409 9
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (s->version < TLS1_VERSION))
		{
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		goto err;
		}
#endif

@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@d161 1
a161 1
	unsigned long Time=(unsigned long)time(NULL);
d271 3
d531 3
a533 1
		if (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d135 22
a156 4
IMPLEMENT_ssl23_meth_func(SSLv23_server_method,
			ssl23_accept,
			ssl_undefined_function,
			ssl23_get_server_method)
d407 9
d595 1
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a388 9
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (s->version < TLS1_VERSION))
		{
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		goto err;
		}
#endif

@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
d119 1
a119 1
static const SSL_METHOD *ssl23_get_server_method(int ver);
d121 1
a121 1
static const SSL_METHOD *ssl23_get_server_method(int ver)
d318 1
a318 1
				|| (p[9] >= p[1])))
a341 7
			/* if major version number > 3 set minor to a value
			 * which will use the highest version 3 we support.
			 * If TLS 2.0 ever appears we will need to revise
			 * this....
			 */
			else if (p[9] > SSL3_VERSION_MAJOR)
				v[1]=0xff;
d389 9
d428 1
a428 3
		if ((csl+sil+cl+11) != s->packet_length) /* We can't have TLS extensions in SSL 2.0 format
		                                          * Client Hello, can we? Error condition should be
		                                          * '>' otherweise */
a470 9
#if 0
                /* copy any remaining data with may be extensions */
	        p = p+csl+sil+cl;
		while (p <  s->packet+s->packet_length)
			{
			*(d++)=*(p++);
			}
#endif

a545 4
			if (s->s3->rbuf.buf == NULL)
				if (!ssl3_setup_read_buffer(s))
					goto err;

@


1.1.1.10
log
@import OpenSSL-1.0.1c
@
text
@a117 3
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif
a130 4
	else if (ver == TLS1_1_VERSION)
		return(TLSv1_1_server_method());
	else if (ver == TLS1_2_VERSION)
		return(TLSv1_2_server_method());
d286 1
a286 14
					if (p[4] >= TLS1_2_VERSION_MINOR &&
					   !(s->options & SSL_OP_NO_TLSv1_2))
						{
						s->version=TLS1_2_VERSION;
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (p[4] >= TLS1_1_VERSION_MINOR &&
					   !(s->options & SSL_OP_NO_TLSv1_1))
						{
						s->version=TLS1_1_VERSION;
						/* type=2; */ /* done later to survive restarts */
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_TLSv1))
d353 1
a353 13
				if (v[1] >= TLS1_2_VERSION_MINOR &&
					!(s->options & SSL_OP_NO_TLSv1_2))
					{
					s->version=TLS1_2_VERSION;
					type=3;
					}
				else if (v[1] >= TLS1_1_VERSION_MINOR &&
					!(s->options & SSL_OP_NO_TLSv1_1))
					{
					s->version=TLS1_1_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_TLSv1))
a395 9
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (s->version < TLS1_VERSION))
		{
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		goto err;
		}
#endif

d570 2
a571 5
		if (s->version == TLS1_2_VERSION)
			s->method = TLSv1_2_server_method();
		else if (s->version == TLS1_1_VERSION)
			s->method = TLSv1_1_server_method();
		else if (s->version == TLS1_VERSION)
@


