head	1.139;
access;
symbols
	OPENBSD_6_0:1.138.0.2
	OPENBSD_6_0_BASE:1.138
	OPENBSD_5_9:1.136.0.2
	OPENBSD_5_9_BASE:1.136
	OPENBSD_5_8:1.121.0.4
	OPENBSD_5_8_BASE:1.121
	OPENBSD_5_7:1.108.0.2
	OPENBSD_5_7_BASE:1.108
	OPENBSD_5_6:1.85.0.2
	OPENBSD_5_6_BASE:1.85
	butholakala:1.27
	openssl_1_0_1_g:1.1.1.17
	OPENBSD_5_5:1.26.0.8
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.4
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	openssl_1_0_1_c:1.1.1.16
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	openssl_1_0_0_f:1.1.1.15
	openssl_1_0_0_e:1.1.1.14
	OPENBSD_5_0:1.23.0.4
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	openssh_1_0_0_a:1.1.1.13
	OPENBSD_4_8:1.21.0.8
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.4
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	openssl_0_9_8_k:1.1.1.12
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	openssl_0_9_8_j:1.1.1.11
	openssl_0_9_8_h:1.1.1.10
	pre_openssl_0_9_8h:1.18
	OPENBSD_4_4:1.18.0.10
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.8
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	openssl_0_9_7j:1.1.1.9
	openssl:1.1.1
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENSSL_0_9_7G:1.1.1.8
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENSSL_0_9_7D:1.1.1.7
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENSSL_0_9_7C:1.1.1.6
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENSSL_0_9_7B:1.1.1.5
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.4
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.139
date	2016.09.03.11.33.41;	author beck;	state dead;
branches;
next	1.138;
commitid	HnbXxsegngek41U2;

1.138
date	2016.03.27.00.55.38;	author mmcc;	state Exp;
branches;
next	1.137;
commitid	mCqKYYEQRsbN8dqS;

1.137
date	2016.03.11.07.08.45;	author mmcc;	state Exp;
branches;
next	1.136;
commitid	MTdM7aVFdRMAzAYE;

1.136
date	2015.10.02.14.30.10;	author jsing;	state Exp;
branches;
next	1.135;
commitid	tStAqbiixuLgNMVG;

1.135
date	2015.09.13.12.52.07;	author jsing;	state Exp;
branches;
next	1.134;
commitid	XZu4syEhOTRCJhMD;

1.134
date	2015.09.13.12.39.16;	author jsing;	state Exp;
branches;
next	1.133;
commitid	6DGtvZOYHvZomwfr;

1.133
date	2015.09.12.20.56.14;	author jsing;	state Exp;
branches;
next	1.132;
commitid	iAHnWvTD6csMbvQt;

1.132
date	2015.09.12.20.23.56;	author jsing;	state Exp;
branches;
next	1.131;
commitid	gaWGovNiX2dYPXyr;

1.131
date	2015.09.12.16.10.07;	author doug;	state Exp;
branches;
next	1.130;
commitid	VR022UcxWVmcgSOF;

1.130
date	2015.09.12.12.17.00;	author jsing;	state Exp;
branches;
next	1.129;
commitid	FEk6e776Gtc3UWyL;

1.129
date	2015.09.12.10.25.38;	author jsing;	state Exp;
branches;
next	1.128;
commitid	avEJD43ghh5zHznt;

1.128
date	2015.09.12.10.09.16;	author jsing;	state Exp;
branches;
next	1.127;
commitid	tWOqJI84VrE5rBLk;

1.127
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.126;
commitid	pa8oXRlJthT375Ws;

1.126
date	2015.09.10.15.56.26;	author jsing;	state Exp;
branches;
next	1.125;
commitid	vHznCDK3idwNEFz4;

1.125
date	2015.09.02.17.59.15;	author jsing;	state Exp;
branches;
next	1.124;
commitid	6qqbZhzSEFZnYRiq;

1.124
date	2015.09.01.13.38.27;	author jsing;	state Exp;
branches;
next	1.123;
commitid	181x6cJx2ceVnn0a;

1.123
date	2015.08.29.16.51.17;	author doug;	state Exp;
branches;
next	1.122;
commitid	dB5GbUaVT2h1CFUT;

1.122
date	2015.08.27.06.21.15;	author doug;	state Exp;
branches;
next	1.121;
commitid	81GzeBdk0eOTcvRE;

1.121
date	2015.07.29.19.16.09;	author miod;	state Exp;
branches;
next	1.120;
commitid	bdidqCSralexpgXw;

1.120
date	2015.07.19.07.34.52;	author doug;	state Exp;
branches;
next	1.119;
commitid	fuHwlbKRnrqYgsNE;

1.119
date	2015.07.15.22.22.54;	author beck;	state Exp;
branches;
next	1.118;
commitid	ggpMAxcJWQopXgo8;

1.118
date	2015.07.15.21.52.02;	author beck;	state Exp;
branches;
next	1.117;
commitid	jJhmu7uxSvJIDi81;

1.117
date	2015.07.15.18.35.34;	author beck;	state Exp;
branches;
next	1.116;
commitid	JY6O4DRAnDaT0LYP;

1.116
date	2015.07.14.03.33.16;	author doug;	state Exp;
branches;
next	1.115;
commitid	VMgRkLt8GzLweQum;

1.115
date	2015.07.14.03.27.20;	author doug;	state Exp;
branches;
next	1.114;
commitid	pqkdqXug8umFf9pA;

1.114
date	2015.06.24.09.44.18;	author jsing;	state Exp;
branches;
next	1.113;
commitid	1tyDfKWO71bTqjbn;

1.113
date	2015.06.20.18.19.56;	author doug;	state Exp;
branches;
next	1.112;
commitid	M5pMr104SNuP2rY3;

1.112
date	2015.06.15.05.32.58;	author doug;	state Exp;
branches;
next	1.111;
commitid	1aCIJCoHWVyZ3XBP;

1.111
date	2015.03.31.13.17.48;	author jsing;	state Exp;
branches;
next	1.110;
commitid	Gsu1fmdFKo5ZDsVm;

1.110
date	2015.03.27.12.29.54;	author jsing;	state Exp;
branches;
next	1.109;
commitid	GlMku1cNd3nfgnVW;

1.109
date	2015.03.11.19.34.06;	author tedu;	state Exp;
branches;
next	1.108;
commitid	Q2LAMpKkxuDncMI2;

1.108
date	2015.03.08.16.48.47;	author miod;	state Exp;
branches;
next	1.107;
commitid	7RjmcwLcGFp8G28O;

1.107
date	2015.02.07.05.46.01;	author jsing;	state Exp;
branches;
next	1.106;
commitid	kZmiX4Lm74epWPnx;

1.106
date	2015.02.06.09.58.52;	author jsing;	state Exp;
branches;
next	1.105;
commitid	7ntJD8tVTIX2ho3n;

1.105
date	2015.02.06.08.30.23;	author jsing;	state Exp;
branches;
next	1.104;
commitid	K5MXFl39zEkHakNY;

1.104
date	2015.01.23.14.40.59;	author jsing;	state Exp;
branches;
next	1.103;
commitid	wPD4zLQNkZ7JJrxK;

1.103
date	2014.12.15.00.46.53;	author doug;	state Exp;
branches;
next	1.102;
commitid	I2ue40Sqz1Sg9KmB;

1.102
date	2014.12.14.16.19.38;	author jsing;	state Exp;
branches;
next	1.101;
commitid	LQ4CRrGioEdszPsH;

1.101
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.100;
commitid	XNZawfRSWvnVv1VS;

1.100
date	2014.12.14.14.34.43;	author jsing;	state Exp;
branches;
next	1.99;
commitid	JlmRntBjnvBE29Fz;

1.99
date	2014.12.10.15.43.31;	author jsing;	state Exp;
branches;
next	1.98;
commitid	9GGF3DCNTm9Bs8E3;

1.98
date	2014.12.10.15.36.46;	author jsing;	state Exp;
branches;
next	1.97;
commitid	x50cturILyXAfPoH;

1.97
date	2014.12.06.14.24.26;	author jsing;	state Exp;
branches;
next	1.96;
commitid	R8J9s9ZDvNB7vidN;

1.96
date	2014.11.27.16.13.36;	author jsing;	state Exp;
branches;
next	1.95;
commitid	VrULImAH8Soqtnok;

1.95
date	2014.11.19.05.51.25;	author doug;	state Exp;
branches;
next	1.94;
commitid	402yEMShtjJg16bV;

1.94
date	2014.11.18.05.33.43;	author miod;	state Exp;
branches;
next	1.93;
commitid	81uwsCsokEuKDUjo;

1.93
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.92;
commitid	M3pvHgIFoWUHNqJn;

1.92
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.91;
commitid	cGE1JG2i0h4NcVDi;

1.91
date	2014.09.27.11.01.05;	author jsing;	state Exp;
branches;
next	1.90;
commitid	pg2itwAdFVptNvwc;

1.90
date	2014.09.19.14.32.23;	author tedu;	state Exp;
branches;
next	1.89;
commitid	bjh5IPF6NiPe7iWK;

1.89
date	2014.09.07.12.16.23;	author jsing;	state Exp;
branches;
next	1.88;
commitid	oAt7EW2Y0Fwu0XNB;

1.88
date	2014.08.23.14.52.41;	author jsing;	state Exp;
branches;
next	1.87;
commitid	hTkCFMErB7xMsqus;

1.87
date	2014.08.11.01.10.42;	author jsing;	state Exp;
branches;
next	1.86;
commitid	56Y8ICSiJFJMZq95;

1.86
date	2014.08.10.14.42.56;	author jsing;	state Exp;
branches;
next	1.85;
commitid	wihJupNvfkdpKL9O;

1.85
date	2014.08.07.01.24.10;	author deraadt;	state Exp;
branches
	1.85.2.1;
next	1.84;
commitid	OwxwFcaIlQJpgByP;

1.84
date	2014.07.17.11.32.21;	author miod;	state Exp;
branches;
next	1.83;
commitid	BW6UIjGrzYbGZasi;

1.83
date	2014.07.12.22.33.39;	author jsing;	state Exp;
branches;
next	1.82;
commitid	JT7oO4AHgBkjVLfZ;

1.82
date	2014.07.12.22.17.59;	author jsg;	state Exp;
branches;
next	1.81;
commitid	spL1hXllQ0onTJRh;

1.81
date	2014.07.12.18.37.28;	author jsing;	state Exp;
branches;
next	1.80;
commitid	d0dqh8Y3qBA0nZS8;

1.80
date	2014.07.12.18.10.21;	author jsing;	state Exp;
branches;
next	1.79;
commitid	h4iFNvD22lq9SjMe;

1.79
date	2014.07.12.13.11.53;	author jsing;	state Exp;
branches;
next	1.78;
commitid	tJhRneQ4w1l9LuV2;

1.78
date	2014.07.11.22.57.25;	author miod;	state Exp;
branches;
next	1.77;
commitid	n7W5lBeOlkdDXzQO;

1.77
date	2014.07.11.15.44.53;	author miod;	state Exp;
branches;
next	1.76;
commitid	KCcBAHDz3imPffEC;

1.76
date	2014.07.11.13.21.15;	author miod;	state Exp;
branches;
next	1.75;
commitid	m8dtRZoW6jRcscKn;

1.75
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.74;
commitid	cCGiAdDteN08GytD;

1.74
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.73;
commitid	lsH7iukeZYSZBx6F;

1.73
date	2014.07.09.11.25.42;	author jsing;	state Exp;
branches;
next	1.72;
commitid	N5P2FUkVkAd7ODs9;

1.72
date	2014.06.21.20.27.25;	author tedu;	state Exp;
branches;
next	1.71;
commitid	Kp8UIyI3HI6NHi39;

1.71
date	2014.06.19.21.29.51;	author tedu;	state Exp;
branches;
next	1.70;
commitid	CIpPjhmVWPbqgxVA;

1.70
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	mJUVYpkFBZ0Zv2bG;

1.69
date	2014.06.11.15.44.10;	author jsing;	state Exp;
branches;
next	1.68;
commitid	atiHl7idnrYpOeRd;

1.68
date	2014.06.07.22.23.12;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	4IX3BI6FoxwuHgdS;

1.67
date	2014.06.07.14.10.35;	author jsing;	state Exp;
branches;
next	1.66;
commitid	AgFmutmGDUehZZeH;

1.66
date	2014.06.05.17.47.16;	author jsing;	state Exp;
branches;
next	1.65;
commitid	oX2lT6GP1dJEZvFt;

1.65
date	2014.06.05.16.08.11;	author jsing;	state Exp;
branches;
next	1.64;
commitid	ZkWuDIGYQFXmCyzs;

1.64
date	2014.06.05.15.46.24;	author jsing;	state Exp;
branches;
next	1.63;
commitid	iKdQmUaYF0SZSn3g;

1.63
date	2014.06.05.14.31.44;	author jsing;	state Exp;
branches;
next	1.62;
commitid	G0FcbqHSjZyYrdgy;

1.62
date	2014.06.04.14.10.23;	author tedu;	state Exp;
branches;
next	1.61;
commitid	GMbAFZ4Hukhh97U1;

1.61
date	2014.05.31.13.55.45;	author jsing;	state Exp;
branches;
next	1.60;

1.60
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.59;

1.59
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2014.05.30.14.01.11;	author jsing;	state Exp;
branches;
next	1.57;

1.57
date	2014.05.29.18.23.25;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2014.05.29.18.19.57;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2014.05.29.18.11.13;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2014.05.28.13.07.47;	author jsing;	state Exp;
branches;
next	1.53;

1.53
date	2014.05.28.13.03.24;	author jsing;	state Exp;
branches;
next	1.52;

1.52
date	2014.05.25.16.23.10;	author jsing;	state Exp;
branches;
next	1.51;

1.51
date	2014.05.24.12.44.48;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2014.05.22.17.33.17;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2014.05.20.16.59.05;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2014.04.24.20.44.49;	author mcbride;	state Exp;
branches;
next	1.46;

1.46
date	2014.04.24.15.38.13;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2014.04.24.13.06.52;	author mcbride;	state Exp;
branches;
next	1.44;

1.44
date	2014.04.24.12.21.26;	author mcbride;	state Exp;
branches;
next	1.43;

1.43
date	2014.04.24.04.45.43;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2014.04.23.22.26.26;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.17.23.35.40;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.17.21.41.12;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.17.20.34.24;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.16.20.39.09;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.16.17.59.16;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.15.19.42.56;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.14.17.45.38;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.14.16.43.25;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches
	1.26.4.1
	1.26.8.1;
next	1.25;

1.25
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2010.12.15.09.42.29;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches
	1.21.4.1
	1.21.8.1;
next	1.20;

1.20
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches
	1.18.8.1
	1.18.10.1;
next	1.17;

1.17
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.08.08.03.15;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.30.21.30.28;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.06.21.08.06;	author millert;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.23.21.32.28;	author markus;	state Exp;
branches
	1.12.2.1
	1.12.4.1;
next	1.11;

1.11
date	2002.09.14.11.18.03;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.30.16.00.16;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.30.11.08.06;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.03.40;	author beck;	state Exp;
branches
	1.6.2.1
	1.6.4.1;
next	1.5;

1.5
date	2000.12.15.02.58.37;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.49;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.29;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.27;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.34;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.07;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.52.36;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.36.38;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.11.11.21.21.01;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.20.42.06;	author markus;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.04.29.05.37.27;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.04.06.06.30.07;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2011.11.03.02.32.19;	author djm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2012.01.05.22.59.09;	author djm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.6.2.1
date	2002.07.30.11.07.33;	author miod;	state Exp;
branches;
next	;

1.6.4.1
date	2002.07.30.15.47.52;	author jason;	state Exp;
branches;
next	;

1.12.2.1
date	2003.10.01.22.46.19;	author brad;	state Exp;
branches;
next	;

1.12.4.1
date	2003.10.01.15.58.04;	author margarida;	state Exp;
branches;
next	;

1.14.2.1
date	2003.10.31.00.13.15;	author brad;	state Exp;
branches;
next	;

1.18.8.1
date	2009.01.09.11.40.50;	author djm;	state Exp;
branches;
next	;

1.18.10.1
date	2009.01.09.11.40.35;	author djm;	state Exp;
branches;
next	;

1.21.4.1
date	2010.12.15.09.44.23;	author jasper;	state Exp;
branches;
next	;

1.21.8.1
date	2010.12.15.09.43.53;	author jasper;	state Exp;
branches;
next	;

1.26.4.1
date	2014.06.05.20.37.47;	author sthen;	state Exp;
branches;
next	1.26.4.2;
commitid	V8zSJibrIbY4vAzC;

1.26.4.2
date	2014.06.05.20.38.10;	author sthen;	state Exp;
branches;
next	1.26.4.3;
commitid	LfAz5sCH3asp2NvF;

1.26.4.3
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.26.8.1
date	2014.06.05.17.05.15;	author sthen;	state Exp;
branches;
next	1.26.8.2;
commitid	PBa7adr1t6pFSi7e;

1.26.8.2
date	2014.06.05.20.09.30;	author sthen;	state Exp;
branches;
next	1.26.8.3;
commitid	rslqkIc95rhtwKwy;

1.26.8.3
date	2014.08.09.16.54.58;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;

1.85.2.1
date	2015.03.11.19.52.37;	author tedu;	state Exp;
branches;
next	;
commitid	hkSvLV4ooBbkYqsi;


desc
@@


1.139
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: s3_clnt.c,v 1.138 2016/03/27 00:55:38 mmcc Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the OpenSSL open source
 * license provided above.
 *
 * ECC cipher suite support in OpenSSL originally written by
 * Vipul Gupta and Sumit Gupta of Sun Microsystems Laboratories.
 *
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#include <limits.h>
#include <stdint.h>
#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/bn.h>
#include <openssl/buffer.h>
#include <openssl/dh.h>
#include <openssl/evp.h>
#include <openssl/md5.h>
#include <openssl/objects.h>

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif
#ifndef OPENSSL_NO_GOST
#include <openssl/gost.h>
#endif

#include "bytestring.h"

static int ca_dn_cmp(const X509_NAME * const *a, const X509_NAME * const *b);

int
ssl3_connect(SSL *s)
{
	void   (*cb)(const SSL *ssl, int type, int val) = NULL;
	int	 ret = -1;
	int	 new_state, state, skip = 0;

	ERR_clear_error();
	errno = 0;

	if (s->info_callback != NULL)
		cb = s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb = s->ctx->info_callback;

	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s))
		SSL_clear(s);

	for (;;) {
		state = s->state;

		switch (s->state) {
		case SSL_ST_RENEGOTIATE:
			s->renegotiate = 1;
			s->state = SSL_ST_CONNECT;
			s->ctx->stats.sess_connect_renegotiate++;
			/* break */
		case SSL_ST_BEFORE:
		case SSL_ST_CONNECT:
		case SSL_ST_BEFORE|SSL_ST_CONNECT:
		case SSL_ST_OK|SSL_ST_CONNECT:

			s->server = 0;
			if (cb != NULL)
				cb(s, SSL_CB_HANDSHAKE_START, 1);

			if ((s->version & 0xff00 ) != 0x0300) {
				SSLerr(SSL_F_SSL3_CONNECT,
				    ERR_R_INTERNAL_ERROR);
				ret = -1;
				goto end;
			}

			/* s->version=SSL3_VERSION; */
			s->type = SSL_ST_CONNECT;

			if (!ssl3_setup_init_buffer(s)) {
				ret = -1;
				goto end;
			}
			if (!ssl3_setup_buffers(s)) {
				ret = -1;
				goto end;
			}
			if (!ssl_init_wbio_buffer(s, 0)) {
				ret = -1;
				goto end;
			}

			/* don't push the buffering BIO quite yet */

			if (!tls1_init_finished_mac(s)) {
				ret = -1;
				goto end;
			}

			s->state = SSL3_ST_CW_CLNT_HELLO_A;
			s->ctx->stats.sess_connect++;
			s->init_num = 0;
			break;

		case SSL3_ST_CW_CLNT_HELLO_A:
		case SSL3_ST_CW_CLNT_HELLO_B:

			s->shutdown = 0;
			ret = ssl3_client_hello(s);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_CR_SRVR_HELLO_A;
			s->init_num = 0;

			/* turn on buffering for the next lot of output */
			if (s->bbio != s->wbio)
				s->wbio = BIO_push(s->bbio, s->wbio);

			break;

		case SSL3_ST_CR_SRVR_HELLO_A:
		case SSL3_ST_CR_SRVR_HELLO_B:
			ret = ssl3_get_server_hello(s);
			if (ret <= 0)
				goto end;

			if (s->hit) {
				s->state = SSL3_ST_CR_FINISHED_A;
				if (s->tlsext_ticket_expected) {
					/* receive renewed session ticket */
					s->state = SSL3_ST_CR_SESSION_TICKET_A;
				}
			} else
				s->state = SSL3_ST_CR_CERT_A;
			s->init_num = 0;
			break;

		case SSL3_ST_CR_CERT_A:
		case SSL3_ST_CR_CERT_B:
			ret = ssl3_check_finished(s);
			if (ret <= 0)
				goto end;
			if (ret == 2) {
				s->hit = 1;
				if (s->tlsext_ticket_expected)
					s->state = SSL3_ST_CR_SESSION_TICKET_A;
				else
					s->state = SSL3_ST_CR_FINISHED_A;
				s->init_num = 0;
				break;
			}
			/* Check if it is anon DH/ECDH. */
			if (!(s->s3->tmp.new_cipher->algorithm_auth &
			    SSL_aNULL)) {
				ret = ssl3_get_server_certificate(s);
				if (ret <= 0)
					goto end;
				if (s->tlsext_status_expected)
					s->state = SSL3_ST_CR_CERT_STATUS_A;
				else
					s->state = SSL3_ST_CR_KEY_EXCH_A;
			} else {
				skip = 1;
				s->state = SSL3_ST_CR_KEY_EXCH_A;
			}
			s->init_num = 0;
			break;

		case SSL3_ST_CR_KEY_EXCH_A:
		case SSL3_ST_CR_KEY_EXCH_B:
			ret = ssl3_get_key_exchange(s);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_CR_CERT_REQ_A;
			s->init_num = 0;

			/*
			 * At this point we check that we have the
			 * required stuff from the server.
			 */
			if (!ssl3_check_cert_and_algorithm(s)) {
				ret = -1;
				goto end;
			}
			break;

		case SSL3_ST_CR_CERT_REQ_A:
		case SSL3_ST_CR_CERT_REQ_B:
			ret = ssl3_get_certificate_request(s);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_CR_SRVR_DONE_A;
			s->init_num = 0;
			break;

		case SSL3_ST_CR_SRVR_DONE_A:
		case SSL3_ST_CR_SRVR_DONE_B:
			ret = ssl3_get_server_done(s);
			if (ret <= 0)
				goto end;
			if (s->s3->tmp.cert_req)
				s->state = SSL3_ST_CW_CERT_A;
			else
				s->state = SSL3_ST_CW_KEY_EXCH_A;
			s->init_num = 0;

			break;

		case SSL3_ST_CW_CERT_A:
		case SSL3_ST_CW_CERT_B:
		case SSL3_ST_CW_CERT_C:
		case SSL3_ST_CW_CERT_D:
			ret = ssl3_send_client_certificate(s);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_CW_KEY_EXCH_A;
			s->init_num = 0;
			break;

		case SSL3_ST_CW_KEY_EXCH_A:
		case SSL3_ST_CW_KEY_EXCH_B:
			ret = ssl3_send_client_key_exchange(s);
			if (ret <= 0)
				goto end;
			/*
			 * EAY EAY EAY need to check for DH fix cert
			 * sent back
			 */
			/*
			 * For TLS, cert_req is set to 2, so a cert chain
			 * of nothing is sent, but no verify packet is sent
			 */
			/*
			 * XXX: For now, we do not support client
			 * authentication in ECDH cipher suites with
			 * ECDH (rather than ECDSA) certificates.
			 * We need to skip the certificate verify
			 * message when client's ECDH public key is sent
			 * inside the client certificate.
			 */
			if (s->s3->tmp.cert_req == 1) {
				s->state = SSL3_ST_CW_CERT_VRFY_A;
			} else {
				s->state = SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec = 0;
			}
			if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) {
				s->state = SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec = 0;
			}

			s->init_num = 0;
			break;

		case SSL3_ST_CW_CERT_VRFY_A:
		case SSL3_ST_CW_CERT_VRFY_B:
			ret = ssl3_send_client_verify(s);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_CW_CHANGE_A;
			s->init_num = 0;
			s->s3->change_cipher_spec = 0;
			break;

		case SSL3_ST_CW_CHANGE_A:
		case SSL3_ST_CW_CHANGE_B:
			ret = ssl3_send_change_cipher_spec(s,
			SSL3_ST_CW_CHANGE_A, SSL3_ST_CW_CHANGE_B);
			if (ret <= 0)
				goto end;

			if (s->s3->next_proto_neg_seen)
				s->state = SSL3_ST_CW_NEXT_PROTO_A;
			else
				s->state = SSL3_ST_CW_FINISHED_A;
			s->init_num = 0;

			s->session->cipher = s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s)) {
				ret = -1;
				goto end;
			}

			if (!s->method->ssl3_enc->change_cipher_state(s,
			    SSL3_CHANGE_CIPHER_CLIENT_WRITE)) {
				ret = -1;
				goto end;
			}

			break;

		case SSL3_ST_CW_NEXT_PROTO_A:
		case SSL3_ST_CW_NEXT_PROTO_B:
			ret = ssl3_send_next_proto(s);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_CW_FINISHED_A;
			break;

		case SSL3_ST_CW_FINISHED_A:
		case SSL3_ST_CW_FINISHED_B:
			ret = ssl3_send_finished(s, SSL3_ST_CW_FINISHED_A,
			    SSL3_ST_CW_FINISHED_B,
			    s->method->ssl3_enc->client_finished_label,
			    s->method->ssl3_enc->client_finished_label_len);
			if (ret <= 0)
				goto end;
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
			s->state = SSL3_ST_CW_FLUSH;

			/* clear flags */
			s->s3->flags &= ~SSL3_FLAGS_POP_BUFFER;
			if (s->hit) {
				s->s3->tmp.next_state = SSL_ST_OK;
				if (s->s3->flags &
				    SSL3_FLAGS_DELAY_CLIENT_FINISHED) {
					s->state = SSL_ST_OK;
					s->s3->flags|=SSL3_FLAGS_POP_BUFFER;
					s->s3->delay_buf_pop_ret = 0;
				}
			} else {
				/* Allow NewSessionTicket if ticket expected */
				if (s->tlsext_ticket_expected)
					s->s3->tmp.next_state =
					    SSL3_ST_CR_SESSION_TICKET_A;
				else

				s->s3->tmp.next_state = SSL3_ST_CR_FINISHED_A;
			}
			s->init_num = 0;
			break;

		case SSL3_ST_CR_SESSION_TICKET_A:
		case SSL3_ST_CR_SESSION_TICKET_B:
			ret = ssl3_get_new_session_ticket(s);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_CR_FINISHED_A;
			s->init_num = 0;
			break;

		case SSL3_ST_CR_CERT_STATUS_A:
		case SSL3_ST_CR_CERT_STATUS_B:
			ret = ssl3_get_cert_status(s);
			if (ret <= 0)
				goto end;
			s->state = SSL3_ST_CR_KEY_EXCH_A;
			s->init_num = 0;
			break;

		case SSL3_ST_CR_FINISHED_A:
		case SSL3_ST_CR_FINISHED_B:
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
			ret = ssl3_get_finished(s, SSL3_ST_CR_FINISHED_A,
			    SSL3_ST_CR_FINISHED_B);
			if (ret <= 0)
				goto end;

			if (s->hit)
				s->state = SSL3_ST_CW_CHANGE_A;
			else
				s->state = SSL_ST_OK;
			s->init_num = 0;
			break;

		case SSL3_ST_CW_FLUSH:
			s->rwstate = SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0) {
				ret = -1;
				goto end;
			}
			s->rwstate = SSL_NOTHING;
			s->state = s->s3->tmp.next_state;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			tls1_cleanup_key_block(s);

			if (s->init_buf != NULL) {
				BUF_MEM_free(s->init_buf);
				s->init_buf = NULL;
			}

			/*
			 * If we are not 'joining' the last two packets,
			 * remove the buffering now
			 */
			if (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))
				ssl_free_wbio_buffer(s);
			/* else do it later in ssl3_write */

			s->init_num = 0;
			s->renegotiate = 0;
			s->new_session = 0;

			ssl_update_cache(s, SSL_SESS_CACHE_CLIENT);
			if (s->hit)
				s->ctx->stats.sess_hit++;

			ret = 1;
			/* s->server=0; */
			s->handshake_func = ssl3_connect;
			s->ctx->stats.sess_connect_good++;

			if (cb != NULL)
				cb(s, SSL_CB_HANDSHAKE_DONE, 1);

			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_SSL3_CONNECT,
			    SSL_R_UNKNOWN_STATE);
			ret = -1;
			goto end;
			/* break; */
		}

		/* did we do anything */
		if (!s->s3->tmp.reuse_message && !skip) {
			if (s->debug) {
				if ((ret = BIO_flush(s->wbio)) <= 0)
					goto end;
			}

			if ((cb != NULL) && (s->state != state)) {
				new_state = s->state;
				s->state = state;
				cb(s, SSL_CB_CONNECT_LOOP, 1);
				s->state = new_state;
			}
		}
		skip = 0;
	}

end:
	s->in_handshake--;
	if (cb != NULL)
		cb(s, SSL_CB_CONNECT_EXIT, ret);

	return (ret);
}

int
ssl3_client_hello(SSL *s)
{
	unsigned char	*bufend, *p, *d;
	int		 i;

	if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {
		SSL_SESSION *sess = s->session;

		if ((sess == NULL) ||
		    (sess->ssl_version != s->version) ||
		    (!sess->session_id_length && !sess->tlsext_tick) ||
		    (sess->not_resumable)) {
			if (!ssl_get_new_session(s, 0))
				goto err;
		}
		/* else use the pre-loaded session */

		/*
		 * If a DTLS ClientHello message is being resent after a
		 * HelloVerifyRequest, we must retain the original client
		 * random value.
		 */
		if (!SSL_IS_DTLS(s) || s->d1->send_cookie == 0)
			arc4random_buf(s->s3->client_random, SSL3_RANDOM_SIZE);

		d = p = ssl3_handshake_msg_start(s, SSL3_MT_CLIENT_HELLO);

		/*
		 * Version indicates the negotiated version: for example from
		 * an SSLv2/v3 compatible client hello). The client_version
		 * field is the maximum version we permit and it is also
		 * used in RSA encrypted premaster secrets. Some servers can
		 * choke if we initially report a higher version then
		 * renegotiate to a lower one in the premaster secret. This
		 * didn't happen with TLS 1.0 as most servers supported it
		 * but it can with TLS 1.1 or later if the server only supports
		 * 1.0.
		 *
		 * Possible scenario with previous logic:
		 * 	1. Client hello indicates TLS 1.2
		 * 	2. Server hello says TLS 1.0
		 *	3. RSA encrypted premaster secret uses 1.2.
		 * 	4. Handhaked proceeds using TLS 1.0.
		 *	5. Server sends hello request to renegotiate.
		 *	6. Client hello indicates TLS v1.0 as we now
		 *	   know that is maximum server supports.
		 *	7. Server chokes on RSA encrypted premaster secret
		 *	   containing version 1.0.
		 *
		 * For interoperability it should be OK to always use the
		 * maximum version we support in client hello and then rely
		 * on the checking of version to ensure the servers isn't
		 * being inconsistent: for example initially negotiating with
		 * TLS 1.0 and renegotiating with TLS 1.2. We do this by using
		 * client_version in client hello and not resetting it to
		 * the negotiated version.
		 */
		*(p++) = s->client_version >> 8;
		*(p++) = s->client_version & 0xff;

		/* Random stuff */
		memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
		p += SSL3_RANDOM_SIZE;

		/* Session ID */
		if (s->new_session)
			i = 0;
		else
			i = s->session->session_id_length;
		*(p++) = i;
		if (i != 0) {
			if (i > (int)sizeof(s->session->session_id)) {
				SSLerr(SSL_F_SSL3_CLIENT_HELLO,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			memcpy(p, s->session->session_id, i);
			p += i;
		}

		/* DTLS Cookie. */
		if (SSL_IS_DTLS(s)) {
			if (s->d1->cookie_len > sizeof(s->d1->cookie)) {
				SSLerr(SSL_F_DTLS1_CLIENT_HELLO,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			*(p++) = s->d1->cookie_len;
			memcpy(p, s->d1->cookie, s->d1->cookie_len);
			p += s->d1->cookie_len;
		}

		/* Ciphers supported */
		i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &p[2]);
		if (i == 0) {
			SSLerr(SSL_F_SSL3_CLIENT_HELLO,
			    SSL_R_NO_CIPHERS_AVAILABLE);
			goto err;
		}
		s2n(i, p);
		p += i;

		/* add in (no) COMPRESSION */
		*(p++) = 1;
		*(p++) = 0; /* Add the NULL method */

		/* TLS extensions*/
		bufend = (unsigned char *)s->init_buf->data +
		    SSL3_RT_MAX_PLAIN_LENGTH;
		if ((p = ssl_add_clienthello_tlsext(s, p, bufend)) == NULL) {
			SSLerr(SSL_F_SSL3_CLIENT_HELLO,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}

		ssl3_handshake_msg_finish(s, p - d);

		s->state = SSL3_ST_CW_CLNT_HELLO_B;
	}

	/* SSL3_ST_CW_CLNT_HELLO_B */
	return (ssl3_handshake_write(s));

err:
	return (-1);
}

int
ssl3_get_server_hello(SSL *s)
{
	STACK_OF(SSL_CIPHER)	*sk;
	const SSL_CIPHER	*c;
	unsigned char		*p, *q, *d;
	int			 i, al, ok;
	unsigned int		 j;
	uint16_t		 cipher_value;
	long			 n;
	unsigned long		 alg_k;

	n = s->method->ssl_get_message(s, SSL3_ST_CR_SRVR_HELLO_A,
	    SSL3_ST_CR_SRVR_HELLO_B, -1, 20000, /* ?? */ &ok);

	if (!ok)
		return ((int)n);

	if (SSL_IS_DTLS(s)) {
		if (s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST) {
			if (s->d1->send_cookie == 0) {
				s->s3->tmp.reuse_message = 1;
				return (1);
			} else {
				/* Already sent a cookie. */
				al = SSL_AD_UNEXPECTED_MESSAGE;
				SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
				    SSL_R_BAD_MESSAGE_TYPE);
				goto f_err;
			}
		}
	}

	if (s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO) {
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_BAD_MESSAGE_TYPE);
		goto f_err;
	}

	d = p = (unsigned char *)s->init_msg;

	if (2 > n)
		goto truncated;
	if ((p[0] != (s->version >> 8)) || (p[1] != (s->version & 0xff))) {
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION);
		s->version = (s->version&0xff00) | p[1];
		al = SSL_AD_PROTOCOL_VERSION;
		goto f_err;
	}
	p += 2;

	/* load the server hello data */

	if (p + SSL3_RANDOM_SIZE + 1 - d > n)
		goto truncated;

	/* load the server random */
	memcpy(s->s3->server_random, p, SSL3_RANDOM_SIZE);
	p += SSL3_RANDOM_SIZE;

	/* get the session-id */
	j = *(p++);

	if ((j > sizeof s->session->session_id) ||
	    (j > SSL3_SESSION_ID_SIZE)) {
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_SSL3_SESSION_ID_TOO_LONG);
		goto f_err;
	}

	if (p + j + 2 - d > n)
		goto truncated;

	/* Get the cipher value. */
	q = p + j;
	n2s(q, cipher_value);

	/*
	 * Check if we want to resume the session based on external
	 * pre-shared secret
	 */
	if (s->tls_session_secret_cb) {
		SSL_CIPHER *pref_cipher = NULL;
		s->session->master_key_length = sizeof(s->session->master_key);
		if (s->tls_session_secret_cb(s, s->session->master_key,
		    &s->session->master_key_length, NULL, &pref_cipher,
		    s->tls_session_secret_cb_arg)) {
			s->session->cipher = pref_cipher ? pref_cipher :
			    ssl3_get_cipher_by_value(cipher_value);
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
		}
	}

	if (j != 0 && j == s->session->session_id_length &&
	    timingsafe_memcmp(p, s->session->session_id, j) == 0) {
		if (s->sid_ctx_length != s->session->sid_ctx_length ||
		    timingsafe_memcmp(s->session->sid_ctx,
		    s->sid_ctx, s->sid_ctx_length) != 0) {
			/* actually a client application bug */
			al = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
			    SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
			goto f_err;
		}
		s->s3->flags |= SSL3_FLAGS_CCS_OK;
		s->hit = 1;
	} else {
		/* a miss or crap from the other end */

		/* If we were trying for session-id reuse, make a new
		 * SSL_SESSION so we don't stuff up other people */
		s->hit = 0;
		if (s->session->session_id_length > 0) {
			if (!ssl_get_new_session(s, 0)) {
				al = SSL_AD_INTERNAL_ERROR;
				goto f_err;
			}
		}
		s->session->session_id_length = j;
		memcpy(s->session->session_id, p, j); /* j could be 0 */
	}
	p += j;

	if ((c = ssl3_get_cipher_by_value(cipher_value)) == NULL) {
		/* unknown cipher */
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_UNKNOWN_CIPHER_RETURNED);
		goto f_err;
	}

	/* TLS v1.2 only ciphersuites require v1.2 or later */
	if ((c->algorithm_ssl & SSL_TLSV1_2) &&
	    (TLS1_get_version(s) < TLS1_2_VERSION)) {
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_WRONG_CIPHER_RETURNED);
		goto f_err;
	}
	p += SSL3_CIPHER_VALUE_SIZE;

	sk = ssl_get_ciphers_by_id(s);
	i = sk_SSL_CIPHER_find(sk, c);
	if (i < 0) {
		/* we did not say we would use this cipher */
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_WRONG_CIPHER_RETURNED);
		goto f_err;
	}

	/*
	 * Depending on the session caching (internal/external), the cipher
	 * and/or cipher_id values may not be set. Make sure that
	 * cipher_id is set and use it for comparison.
	 */
	if (s->session->cipher)
		s->session->cipher_id = s->session->cipher->id;
	if (s->hit && (s->session->cipher_id != c->id)) {
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);
		goto f_err;
	}
	s->s3->tmp.new_cipher = c;
	/*
	 * Don't digest cached records if no sigalgs: we may need them for
	 * client authentication.
	 */
	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	if (!(SSL_USE_SIGALGS(s) || (alg_k & SSL_kGOST)) &&
	    !tls1_digest_cached_records(s)) {
		al = SSL_AD_INTERNAL_ERROR;
		goto f_err;
	}
	/* lets get the compression algorithm */
	/* COMPRESSION */
	if (p + 1 - d > n)
		goto truncated;
	if (*(p++) != 0) {
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
		goto f_err;
	}

	/* TLS extensions*/
	if (!ssl_parse_serverhello_tlsext(s, &p, d, n, &al)) {
		/* 'al' set by ssl_parse_serverhello_tlsext */
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_PARSE_TLSEXT);
		goto f_err;
	}
	if (ssl_check_serverhello_tlsext(s) <= 0) {
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_SERVERHELLO_TLSEXT);
		goto err;
	}

	if (p != d + n)
		goto truncated;

	return (1);

truncated:
	/* wrong packet length */
	al = SSL_AD_DECODE_ERROR;
	SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_PACKET_LENGTH);
f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	return (-1);
}

int
ssl3_get_server_certificate(SSL *s)
{
	int			 al, i, ok, ret = -1;
	long			 n;
	CBS			 cbs, cert_list;
	X509			*x = NULL;
	const unsigned char	*q;
	STACK_OF(X509)		*sk = NULL;
	SESS_CERT		*sc;
	EVP_PKEY		*pkey = NULL;

	n = s->method->ssl_get_message(s, SSL3_ST_CR_CERT_A,
	    SSL3_ST_CR_CERT_B, -1, s->max_cert_list, &ok);

	if (!ok)
		return ((int)n);

	if (s->s3->tmp.message_type == SSL3_MT_SERVER_KEY_EXCHANGE) {
		s->s3->tmp.reuse_message = 1;
		return (1);
	}

	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE) {
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
		    SSL_R_BAD_MESSAGE_TYPE);
		goto f_err;
	}


	if ((sk = sk_X509_new_null()) == NULL) {
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
		    ERR_R_MALLOC_FAILURE);
		goto err;
	}

	if (n < 0)
		goto truncated;

	CBS_init(&cbs, s->init_msg, n);
	if (CBS_len(&cbs) < 3)
		goto truncated;

	if (!CBS_get_u24_length_prefixed(&cbs, &cert_list) ||
	    CBS_len(&cbs) != 0) {
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
		    SSL_R_LENGTH_MISMATCH);
		goto f_err;
	}

	while (CBS_len(&cert_list) > 0) {
		CBS cert;

		if (CBS_len(&cert_list) < 3)
			goto truncated;
		if (!CBS_get_u24_length_prefixed(&cert_list, &cert)) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
			    SSL_R_CERT_LENGTH_MISMATCH);
			goto f_err;
		}

		q = CBS_data(&cert);
		x = d2i_X509(NULL, &q, CBS_len(&cert));
		if (x == NULL) {
			al = SSL_AD_BAD_CERTIFICATE;
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
			    ERR_R_ASN1_LIB);
			goto f_err;
		}
		if (q != CBS_data(&cert) + CBS_len(&cert)) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
			    SSL_R_CERT_LENGTH_MISMATCH);
			goto f_err;
		}
		if (!sk_X509_push(sk, x)) {
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}
		x = NULL;
	}

	i = ssl_verify_cert_chain(s, sk);
	if ((s->verify_mode != SSL_VERIFY_NONE) && (i <= 0)) {
		al = ssl_verify_alarm_type(s->verify_result);
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
		    SSL_R_CERTIFICATE_VERIFY_FAILED);
		goto f_err;

	}
	ERR_clear_error(); /* but we keep s->verify_result */

	sc = ssl_sess_cert_new();
	if (sc == NULL)
		goto err;
	if (s->session->sess_cert)
		ssl_sess_cert_free(s->session->sess_cert);
	s->session->sess_cert = sc;

	sc->cert_chain = sk;
	/*
	 * Inconsistency alert: cert_chain does include the peer's
	 * certificate, which we don't include in s3_srvr.c
	 */
	x = sk_X509_value(sk, 0);
	sk = NULL;
	/* VRS 19990621: possible memory leak; sk=null ==> !sk_pop_free() @@end*/

	pkey = X509_get_pubkey(x);

	if (pkey == NULL || EVP_PKEY_missing_parameters(pkey)) {
		x = NULL;
		al = SSL3_AL_FATAL;
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
		    SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);
		goto f_err;
	}

	i = ssl_cert_type(x, pkey);
	if (i < 0) {
		x = NULL;
		al = SSL3_AL_FATAL;
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
		    SSL_R_UNKNOWN_CERTIFICATE_TYPE);
		goto f_err;
	}

	sc->peer_cert_type = i;
	CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
	/*
	 * Why would the following ever happen?
	 * We just created sc a couple of lines ago.
	 */
	X509_free(sc->peer_pkeys[i].x509);
	sc->peer_pkeys[i].x509 = x;
	sc->peer_key = &(sc->peer_pkeys[i]);

	X509_free(s->session->peer);
	CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
	s->session->peer = x;
	s->session->verify_result = s->verify_result;

	x = NULL;
	ret = 1;

	if (0) {
truncated:
		/* wrong packet length */
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
		    SSL_R_BAD_PACKET_LENGTH);
f_err:
		ssl3_send_alert(s, SSL3_AL_FATAL, al);
	}
err:
	EVP_PKEY_free(pkey);
	X509_free(x);
	sk_X509_pop_free(sk, X509_free);
	return (ret);
}

int
ssl3_get_key_exchange(SSL *s)
{
	unsigned char	*q, md_buf[EVP_MAX_MD_SIZE*2];
	EVP_MD_CTX	 md_ctx;
	unsigned char	*param, *p;
	int		 al, i, j, param_len, ok;
	long		 n, alg_k, alg_a;
	EVP_PKEY	*pkey = NULL;
	const		 EVP_MD *md = NULL;
	RSA		*rsa = NULL;
	DH		*dh = NULL;
	EC_KEY		*ecdh = NULL;
	BN_CTX		*bn_ctx = NULL;
	EC_POINT	*srvr_ecpoint = NULL;
	int		 curve_nid = 0;
	int		 encoded_pt_len = 0;

	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	alg_a = s->s3->tmp.new_cipher->algorithm_auth;

	/*
	 * Use same message size as in ssl3_get_certificate_request()
	 * as ServerKeyExchange message may be skipped.
	 */
	n = s->method->ssl_get_message(s, SSL3_ST_CR_KEY_EXCH_A,
	    SSL3_ST_CR_KEY_EXCH_B, -1, s->max_cert_list, &ok);
	if (!ok)
		return ((int)n);
	
	EVP_MD_CTX_init(&md_ctx);

	if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE) {
		/*
		 * Do not skip server key exchange if this cipher suite uses
		 * ephemeral keys.
		 */
		if (alg_k & (SSL_kDHE|SSL_kECDHE)) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_UNEXPECTED_MESSAGE);
			al = SSL_AD_UNEXPECTED_MESSAGE;
			goto f_err;
		}

		s->s3->tmp.reuse_message = 1;
		EVP_MD_CTX_cleanup(&md_ctx);
		return (1);
	}

	if (s->session->sess_cert != NULL) {
		DH_free(s->session->sess_cert->peer_dh_tmp);
		s->session->sess_cert->peer_dh_tmp = NULL;

		EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
		s->session->sess_cert->peer_ecdh_tmp = NULL;
	} else {
		s->session->sess_cert = ssl_sess_cert_new();
		if (s->session->sess_cert == NULL)
			goto err;
	}

	param = p = (unsigned char *)s->init_msg;
	param_len = 0;

	if (alg_k & SSL_kDHE) {
		if ((dh = DH_new()) == NULL) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_DH_LIB);
			goto err;
		}
		if (2 > n)
			goto truncated;
		n2s(p, i);
		param_len = i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_DH_P_LENGTH);
			goto f_err;
		}
		if (!(dh->p = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		p += i;

		if (param_len + 2 > n)
			goto truncated;
		n2s(p, i);
		param_len += i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_DH_G_LENGTH);
			goto f_err;
		}
		if (!(dh->g = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		p += i;

		if (param_len + 2 > n)
			goto truncated;
		n2s(p, i);
		param_len += i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_DH_PUB_KEY_LENGTH);
			goto f_err;
		}
		if (!(dh->pub_key = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		p += i;
		n -= param_len;

		/*
		 * Check the strength of the DH key just constructed.
		 * Discard keys weaker than 1024 bits.
		 */

		if (DH_size(dh) < 1024 / 8) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_DH_P_LENGTH);
			goto err;
		}

		if (alg_a & SSL_aRSA)
			pkey = X509_get_pubkey(
			    s->session->sess_cert->peer_pkeys[
			    SSL_PKEY_RSA_ENC].x509);
		else if (alg_a & SSL_aDSS)
			pkey = X509_get_pubkey(
			    s->session->sess_cert->peer_pkeys[
			    SSL_PKEY_DSA_SIGN].x509);
		/* else anonymous DH, so no certificate or pkey. */

		s->session->sess_cert->peer_dh_tmp = dh;
		dh = NULL;
	} else if (alg_k & SSL_kECDHE) {
		const EC_GROUP *group;
		EC_GROUP *ngroup;

		if ((ecdh = EC_KEY_new()) == NULL) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}

		/*
		 * Extract elliptic curve parameters and the
		 * server's ephemeral ECDH public key.
		 * Keep accumulating lengths of various components in
		 * param_len and make sure it never exceeds n.
		 */

		/*
		 * XXX: For now we only support named (not generic) curves
		 * and the ECParameters in this case is just three bytes.
		 */
		param_len = 3;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
		}

		/*
		 * Check curve is one of our preferences, if not server has
		 * sent an invalid curve.
		 */
		if (tls1_check_curve(s, p, param_len) != 1) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_WRONG_CURVE);
			goto f_err;
		}

		if ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) {
			al = SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
			goto f_err;
		}

		ngroup = EC_GROUP_new_by_curve_name(curve_nid);
		if (ngroup == NULL) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_EC_LIB);
			goto err;
		}
		if (EC_KEY_set_group(ecdh, ngroup) == 0) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_EC_LIB);
			goto err;
		}
		EC_GROUP_free(ngroup);

		group = EC_KEY_get0_group(ecdh);

		p += 3;

		/* Next, get the encoded ECPoint */
		if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
		    ((bn_ctx = BN_CTX_new()) == NULL)) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}

		if (param_len + 1 > n)
			goto truncated;
		encoded_pt_len = *p;
		/* length of encoded point */
		p += 1;
		param_len += (1 + encoded_pt_len);
		if ((param_len > n) || (EC_POINT_oct2point(group, srvr_ecpoint,
		    p, encoded_pt_len, bn_ctx) == 0)) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_ECPOINT);
			goto f_err;
		}

		n -= param_len;
		p += encoded_pt_len;

		/*
		 * The ECC/TLS specification does not mention the use
		 * of DSA to sign ECParameters in the server key
		 * exchange message. We do support RSA and ECDSA.
		 */
		if (alg_a & SSL_aRSA)
			pkey = X509_get_pubkey(
			    s->session->sess_cert->peer_pkeys[
			    SSL_PKEY_RSA_ENC].x509);
		else if (alg_a & SSL_aECDSA)
			pkey = X509_get_pubkey(
			    s->session->sess_cert->peer_pkeys[
			    SSL_PKEY_ECC].x509);
		/* Else anonymous ECDH, so no certificate or pkey. */
		EC_KEY_set_public_key(ecdh, srvr_ecpoint);
		s->session->sess_cert->peer_ecdh_tmp = ecdh;
		ecdh = NULL;
		BN_CTX_free(bn_ctx);
		bn_ctx = NULL;
		EC_POINT_free(srvr_ecpoint);
		srvr_ecpoint = NULL;
	} else if (alg_k) {
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
		    SSL_R_UNEXPECTED_MESSAGE);
			goto f_err;
	}

	/* p points to the next byte, there are 'n' bytes left */

	/* if it was signed, check the signature */
	if (pkey != NULL) {
		if (SSL_USE_SIGALGS(s)) {
			int sigalg = tls12_get_sigid(pkey);
			/* Should never happen */
			if (sigalg == -1) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			/*
			 * Check key type is consistent
			 * with signature
			 */
			if (2 > n)
				goto truncated;
			if (sigalg != (int)p[1]) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_WRONG_SIGNATURE_TYPE);
				al = SSL_AD_DECODE_ERROR;
				goto f_err;
			}
			md = tls12_get_hash(p[0]);
			if (md == NULL) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_UNKNOWN_DIGEST);
				al = SSL_AD_DECODE_ERROR;
				goto f_err;
			}
			p += 2;
			n -= 2;
		} else
			md = EVP_sha1();

		if (2 > n)
			goto truncated;
		n2s(p, i);
		n -= 2;
		j = EVP_PKEY_size(pkey);

		if (i != n || n > j) {
			/* wrong packet length */
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_WRONG_SIGNATURE_LENGTH);
			goto f_err;
		}

		if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s)) {
			int num;

			j = 0;
			q = md_buf;
			for (num = 2; num > 0; num--) {
				if (!EVP_DigestInit_ex(&md_ctx,
				    (num == 2) ?  s->ctx->md5 : s->ctx->sha1,
				    NULL)) {
					al = SSL_AD_INTERNAL_ERROR;
					goto f_err;
				}
				EVP_DigestUpdate(&md_ctx,
				    s->s3->client_random,
				    SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,
				    s->s3->server_random,
				    SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx, param, param_len);
				EVP_DigestFinal_ex(&md_ctx, q,
				    (unsigned int *)&i);
				q += i;
				j += i;
			}
			i = RSA_verify(NID_md5_sha1, md_buf, j,
			    p, n, pkey->pkey.rsa);
			if (i < 0) {
				al = SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_BAD_RSA_DECRYPT);
				goto f_err;
			}
			if (i == 0) {
				/* bad signature */
				al = SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_BAD_SIGNATURE);
				goto f_err;
			}
		} else {
			EVP_VerifyInit_ex(&md_ctx, md, NULL);
			EVP_VerifyUpdate(&md_ctx, s->s3->client_random,
			    SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx, s->s3->server_random,
			    SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx, param, param_len);
			if (EVP_VerifyFinal(&md_ctx, p,(int)n, pkey) <= 0) {
				/* bad signature */
				al = SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_BAD_SIGNATURE);
				goto f_err;
			}
		}
	} else {
		/* aNULL does not need public keys. */
		if (!(alg_a & SSL_aNULL)) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}
		/* still data left over */
		if (n != 0) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_EXTRA_DATA_IN_MESSAGE);
			goto f_err;
		}
	}
	EVP_PKEY_free(pkey);
	EVP_MD_CTX_cleanup(&md_ctx);
	return (1);
truncated:
	/* wrong packet length */
	al = SSL_AD_DECODE_ERROR;
	SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_PACKET_LENGTH);
f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	EVP_PKEY_free(pkey);
	RSA_free(rsa);
	DH_free(dh);
	BN_CTX_free(bn_ctx);
	EC_POINT_free(srvr_ecpoint);
	EC_KEY_free(ecdh);
	EVP_MD_CTX_cleanup(&md_ctx);
	return (-1);
}

int
ssl3_get_certificate_request(SSL *s)
{
	int			 ok, ret = 0;
	long		 	 n;
	uint8_t			 ctype_num;
	CBS			 cert_request, ctypes, rdn_list;
	X509_NAME		*xn = NULL;
	const unsigned char	*q;
	STACK_OF(X509_NAME)	*ca_sk = NULL;

	n = s->method->ssl_get_message(s, SSL3_ST_CR_CERT_REQ_A,
	    SSL3_ST_CR_CERT_REQ_B, -1, s->max_cert_list, &ok);

	if (!ok)
		return ((int)n);

	s->s3->tmp.cert_req = 0;

	if (s->s3->tmp.message_type == SSL3_MT_SERVER_DONE) {
		s->s3->tmp.reuse_message = 1;
		/*
		 * If we get here we don't need any cached handshake records
		 * as we wont be doing client auth.
		 */
		if (s->s3->handshake_buffer) {
			if (!tls1_digest_cached_records(s))
				goto err;
		}
		return (1);
	}

	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_REQUEST) {
		ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
		    SSL_R_WRONG_MESSAGE_TYPE);
		goto err;
	}

	/* TLS does not like anon-DH with client cert */
	if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) {
		ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
		    SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER);
		goto err;
	}

	if (n < 0)
		goto truncated;
	CBS_init(&cert_request, s->init_msg, n);

	if ((ca_sk = sk_X509_NAME_new(ca_dn_cmp)) == NULL) {
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
		    ERR_R_MALLOC_FAILURE);
		goto err;
	}

	/* get the certificate types */
	if (!CBS_get_u8(&cert_request, &ctype_num))
		goto truncated;

	if (ctype_num > SSL3_CT_NUMBER)
		ctype_num = SSL3_CT_NUMBER;
	if (!CBS_get_bytes(&cert_request, &ctypes, ctype_num) ||
	    !CBS_write_bytes(&ctypes, s->s3->tmp.ctype,
	    sizeof(s->s3->tmp.ctype), NULL)) {
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
		    SSL_R_DATA_LENGTH_TOO_LONG);
		goto err;
	}

	if (SSL_USE_SIGALGS(s)) {
		CBS sigalgs;

		if (CBS_len(&cert_request) < 2) {
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
		}

		/* Check we have enough room for signature algorithms and
		 * following length value.
		 */
		if (!CBS_get_u16_length_prefixed(&cert_request, &sigalgs)) {
			ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
		}
		if ((CBS_len(&sigalgs) & 1) ||
		    !tls1_process_sigalgs(s, CBS_data(&sigalgs),
		    CBS_len(&sigalgs))) {
			ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
			    SSL_R_SIGNATURE_ALGORITHMS_ERROR);
			goto err;
		}
	}

	/* get the CA RDNs */
	if (CBS_len(&cert_request) < 2) {
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
		    SSL_R_DATA_LENGTH_TOO_LONG);
		goto err;
	}

	if (!CBS_get_u16_length_prefixed(&cert_request, &rdn_list) ||
	    CBS_len(&cert_request) != 0) {
		ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
		    SSL_R_LENGTH_MISMATCH);
		goto err;
	}

	while (CBS_len(&rdn_list) > 0) {
		CBS rdn;

		if (CBS_len(&rdn_list) < 2) {
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
		}

		if (!CBS_get_u16_length_prefixed(&rdn_list, &rdn)) {
			ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
			    SSL_R_CA_DN_TOO_LONG);
			goto err;
		}

		q = CBS_data(&rdn);
		if ((xn = d2i_X509_NAME(NULL, &q, CBS_len(&rdn))) == NULL) {
			ssl3_send_alert(s, SSL3_AL_FATAL,
			    SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
			    ERR_R_ASN1_LIB);
			goto err;
		}

		if (q != CBS_data(&rdn) + CBS_len(&rdn)) {
			ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
			    SSL_R_CA_DN_LENGTH_MISMATCH);
			goto err;
		}
		if (!sk_X509_NAME_push(ca_sk, xn)) {
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}
		xn = NULL;	/* avoid free in err block */
	}

	/* we should setup a certificate to return.... */
	s->s3->tmp.cert_req = 1;
	s->s3->tmp.ctype_num = ctype_num;
	if (s->s3->tmp.ca_names != NULL)
		sk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);
	s->s3->tmp.ca_names = ca_sk;
	ca_sk = NULL;

	ret = 1;
	if (0) {
truncated:
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
		    SSL_R_BAD_PACKET_LENGTH);
	}
err:
	X509_NAME_free(xn);
	if (ca_sk != NULL)
		sk_X509_NAME_pop_free(ca_sk, X509_NAME_free);
	return (ret);
}

static int
ca_dn_cmp(const X509_NAME * const *a, const X509_NAME * const *b)
{
	return (X509_NAME_cmp(*a, *b));
}

int
ssl3_get_new_session_ticket(SSL *s)
{
	int			 ok, al, ret = 0;
	uint32_t		 lifetime_hint;
	long			 n;
	CBS			 cbs, session_ticket;

	n = s->method->ssl_get_message(s, SSL3_ST_CR_SESSION_TICKET_A,
	    SSL3_ST_CR_SESSION_TICKET_B, -1, 16384, &ok);
	if (!ok)
		return ((int)n);

	if (s->s3->tmp.message_type == SSL3_MT_FINISHED) {
		s->s3->tmp.reuse_message = 1;
		return (1);
	}
	if (s->s3->tmp.message_type != SSL3_MT_NEWSESSION_TICKET) {
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,
		    SSL_R_BAD_MESSAGE_TYPE);
		goto f_err;
	}

	if (n < 0) {
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,
		    SSL_R_LENGTH_MISMATCH);
		goto f_err;
	}

	CBS_init(&cbs, s->init_msg, n);
	if (!CBS_get_u32(&cbs, &lifetime_hint) ||
#if UINT32_MAX > LONG_MAX
	    lifetime_hint > LONG_MAX ||
#endif
	    !CBS_get_u16_length_prefixed(&cbs, &session_ticket) ||
	    CBS_len(&cbs) != 0) {
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,
		    SSL_R_LENGTH_MISMATCH);
		goto f_err;
	}
	s->session->tlsext_tick_lifetime_hint = (long)lifetime_hint;

	if (!CBS_stow(&session_ticket, &s->session->tlsext_tick,
	    &s->session->tlsext_ticklen)) {
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,
		    ERR_R_MALLOC_FAILURE);
		goto err;
	}

	/*
	 * There are two ways to detect a resumed ticket sesion.
	 * One is to set an appropriate session ID and then the server
	 * must return a match in ServerHello. This allows the normal
	 * client session ID matching to work and we know much
	 * earlier that the ticket has been accepted.
	 *
	 * The other way is to set zero length session ID when the
	 * ticket is presented and rely on the handshake to determine
	 * session resumption.
	 *
	 * We choose the former approach because this fits in with
	 * assumptions elsewhere in OpenSSL. The session ID is set
	 * to the SHA256 (or SHA1 is SHA256 is disabled) hash of the
	 * ticket.
	 */
	EVP_Digest(CBS_data(&session_ticket), CBS_len(&session_ticket),
	    s->session->session_id, &s->session->session_id_length,
	    EVP_sha256(), NULL);
	ret = 1;
	return (ret);
f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	return (-1);
}

int
ssl3_get_cert_status(SSL *s)
{
	CBS			 cert_status, response;
	size_t			 stow_len;
	int			 ok, al;
	long			 n;
	uint8_t			 status_type;

	n = s->method->ssl_get_message(s, SSL3_ST_CR_CERT_STATUS_A,
	    SSL3_ST_CR_CERT_STATUS_B, SSL3_MT_CERTIFICATE_STATUS,
	    16384, &ok);

	if (!ok)
		return ((int)n);

	if (n < 0) {
		/* need at least status type + length */
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,
		    SSL_R_LENGTH_MISMATCH);
		goto f_err;
	}

	CBS_init(&cert_status, s->init_msg, n);
	if (!CBS_get_u8(&cert_status, &status_type) ||
	    CBS_len(&cert_status) < 3) {
		/* need at least status type + length */
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,
		    SSL_R_LENGTH_MISMATCH);
		goto f_err;
	}

	if (status_type != TLSEXT_STATUSTYPE_ocsp) {
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,
		    SSL_R_UNSUPPORTED_STATUS_TYPE);
		goto f_err;
	}

	if (!CBS_get_u24_length_prefixed(&cert_status, &response) ||
	    CBS_len(&cert_status) != 0) {
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,
		    SSL_R_LENGTH_MISMATCH);
		goto f_err;
	}

	if (!CBS_stow(&response, &s->tlsext_ocsp_resp,
	    &stow_len) || stow_len > INT_MAX) {
		s->tlsext_ocsp_resplen = 0;
 		al = SSL_AD_INTERNAL_ERROR;
 		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,
 		    ERR_R_MALLOC_FAILURE);
 		goto f_err;
 	}
	s->tlsext_ocsp_resplen = (int)stow_len;

	if (s->ctx->tlsext_status_cb) {
		int ret;
		ret = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);
		if (ret == 0) {
			al = SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE;
			SSLerr(SSL_F_SSL3_GET_CERT_STATUS,
			    SSL_R_INVALID_STATUS_RESPONSE);
			goto f_err;
		}
		if (ret < 0) {
			al = SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_STATUS,
			    ERR_R_MALLOC_FAILURE);
			goto f_err;
		}
	}
	return (1);
f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
	return (-1);
}

int
ssl3_get_server_done(SSL *s)
{
	int	ok, ret = 0;
	long	n;

	n = s->method->ssl_get_message(s, SSL3_ST_CR_SRVR_DONE_A,
	    SSL3_ST_CR_SRVR_DONE_B, SSL3_MT_SERVER_DONE,
	    30, /* should be very small, like 0 :-) */ &ok);

	if (!ok)
		return ((int)n);
	if (n > 0) {
		/* should contain no data */
		ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);
		SSLerr(SSL_F_SSL3_GET_SERVER_DONE, SSL_R_LENGTH_MISMATCH);
		return (-1);
	}
	ret = 1;
	return (ret);
}

static int
ssl3_send_client_kex_rsa(SSL *s, SESS_CERT *sess_cert, unsigned char *p,
    int *outlen)
{
	unsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
	EVP_PKEY *pkey = NULL;
	unsigned char *q;
	int ret = -1;
	int n;

	pkey = X509_get_pubkey(sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
	if (pkey == NULL || pkey->type != EVP_PKEY_RSA ||
	    pkey->pkey.rsa == NULL) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    ERR_R_INTERNAL_ERROR);
		goto err;
	}

	tmp_buf[0] = s->client_version >> 8;
	tmp_buf[1] = s->client_version & 0xff;
	arc4random_buf(&tmp_buf[2], sizeof(tmp_buf) - 2);

	s->session->master_key_length = sizeof(tmp_buf);

	q = p;
	p += 2;

	n = RSA_public_encrypt(sizeof(tmp_buf), tmp_buf, p, pkey->pkey.rsa,
	    RSA_PKCS1_PADDING);
	if (n <= 0) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    SSL_R_BAD_RSA_ENCRYPT);
		goto err;
	}

	s2n(n, q);
	n += 2;

	s->session->master_key_length =
	    s->method->ssl3_enc->generate_master_secret(s,
		s->session->master_key, tmp_buf, sizeof(tmp_buf));

	*outlen = n;
	ret = 1;

err:
	explicit_bzero(tmp_buf, sizeof(tmp_buf));
	EVP_PKEY_free(pkey);

	return (ret);
}

static int
ssl3_send_client_kex_dhe(SSL *s, SESS_CERT *sess_cert, unsigned char *p,
    int *outlen)
{
	DH *dh_srvr = NULL, *dh_clnt = NULL;
	unsigned char *key = NULL;
	int key_size, n;
	int ret = -1;

	/* Ensure that we have an ephemeral key for DHE. */
	if (sess_cert->peer_dh_tmp == NULL) {
		ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);
		goto err;
	}
	dh_srvr = sess_cert->peer_dh_tmp;

	/* Generate a new random key. */
	if ((dh_clnt = DHparams_dup(dh_srvr)) == NULL) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);
		goto err;
	}
	if (!DH_generate_key(dh_clnt)) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);
		goto err;
	}
	key_size = DH_size(dh_clnt);
	if ((key = malloc(key_size)) == NULL) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    ERR_R_MALLOC_FAILURE);
		goto err;
	}
	n = DH_compute_key(key, dh_srvr->pub_key, dh_clnt);
	if (n <= 0) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);
		goto err;
	}

	/* Generate master key from the result. */
	s->session->master_key_length =
	    s->method->ssl3_enc->generate_master_secret(s,
		s->session->master_key, key, n);

	/* Send off the data. */
	n = BN_num_bytes(dh_clnt->pub_key);
	s2n(n, p);
	BN_bn2bin(dh_clnt->pub_key, p);
	n += 2;

	*outlen = n;
	ret = 1;

err:
	DH_free(dh_clnt);
	if (key != NULL)
		explicit_bzero(key, key_size);
	free(key);

	return (ret);
}

static int
ssl3_send_client_kex_ecdh(SSL *s, SESS_CERT *sess_cert, unsigned char *p,
    int *outlen)
{
	EC_KEY *tkey, *clnt_ecdh = NULL;
	const EC_GROUP *srvr_group = NULL;
	const EC_POINT *srvr_ecpoint = NULL;
	EVP_PKEY *srvr_pub_pkey = NULL;
	BN_CTX *bn_ctx = NULL;
	unsigned char *encodedPoint = NULL;
	unsigned char *key = NULL;
	unsigned long alg_k;
	int encoded_pt_len = 0;
	int key_size, n;
	int ret = -1;

	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;

	/* Ensure that we have an ephemeral key for ECDHE. */
	if ((alg_k & SSL_kECDHE) && sess_cert->peer_ecdh_tmp == NULL) {
		ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    ERR_R_INTERNAL_ERROR);
		goto err;
	}
	tkey = sess_cert->peer_ecdh_tmp;

	if (alg_k & (SSL_kECDHr|SSL_kECDHe)) {
		/* Get the Server Public Key from certificate. */
		srvr_pub_pkey = X509_get_pubkey(
		    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
		if (srvr_pub_pkey != NULL && srvr_pub_pkey->type == EVP_PKEY_EC)
			tkey = srvr_pub_pkey->pkey.ec;
	}

	if (tkey == NULL) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    ERR_R_INTERNAL_ERROR);
		goto err;
	}

	srvr_group = EC_KEY_get0_group(tkey);
	srvr_ecpoint = EC_KEY_get0_public_key(tkey);

	if (srvr_group == NULL || srvr_ecpoint == NULL) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    ERR_R_INTERNAL_ERROR);
		goto err;
	}

	if ((clnt_ecdh = EC_KEY_new()) == NULL) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    ERR_R_MALLOC_FAILURE);
		goto err;
	}

	if (!EC_KEY_set_group(clnt_ecdh, srvr_group)) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
		goto err;
	}

	/* Generate a new ECDH key pair. */
	if (!(EC_KEY_generate_key(clnt_ecdh))) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);
		goto err;
	}
	key_size = ECDH_size(clnt_ecdh);
	if (key_size <= 0) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);
		goto err;
	}
	if ((key = malloc(key_size)) == NULL) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    ERR_R_MALLOC_FAILURE);
	}
	n = ECDH_compute_key(key, key_size, srvr_ecpoint, clnt_ecdh, NULL);
	if (n <= 0) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);
		goto err;
	}

	/* Generate master key from the result. */
	s->session->master_key_length =
	    s->method->ssl3_enc->generate_master_secret(s,
		s->session->master_key, key, n);

	/*
	 * First check the size of encoding and allocate memory accordingly.
	 */
	encoded_pt_len = EC_POINT_point2oct(srvr_group,
	    EC_KEY_get0_public_key(clnt_ecdh),
	    POINT_CONVERSION_UNCOMPRESSED, NULL, 0, NULL);

	bn_ctx = BN_CTX_new();
	encodedPoint = malloc(encoded_pt_len);
	if (encodedPoint == NULL || bn_ctx == NULL) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    ERR_R_MALLOC_FAILURE);
		goto err;
	}

	/* Encode the public key */
	n = EC_POINT_point2oct(srvr_group, EC_KEY_get0_public_key(clnt_ecdh),
	    POINT_CONVERSION_UNCOMPRESSED, encodedPoint, encoded_pt_len,
	    bn_ctx);

	*p = n; /* length of encoded point */
	/* Encoded point will be copied here */
	p += 1;

	/* copy the point */
	memcpy((unsigned char *)p, encodedPoint, n);
	/* increment n to account for length field */
	n += 1;

	*outlen = n;
	ret = 1;

err:
	if (key != NULL)
		explicit_bzero(key, key_size);
	free(key);

	BN_CTX_free(bn_ctx);
	free(encodedPoint);
	EC_KEY_free(clnt_ecdh);
	EVP_PKEY_free(srvr_pub_pkey);

	return (ret);
}

static int
ssl3_send_client_kex_gost(SSL *s, SESS_CERT *sess_cert, unsigned char *p,
    int *outlen)
{
	unsigned char premaster_secret[32], shared_ukm[32], tmp[256];
	EVP_PKEY *pub_key = NULL;
	EVP_PKEY_CTX *pkey_ctx;
	X509 *peer_cert;
	size_t msglen;
	unsigned int md_len;
	EVP_MD_CTX *ukm_hash;
	int ret = -1;
	int nid;
	int n;

	/* Get server sertificate PKEY and create ctx from it */
	peer_cert = sess_cert->peer_pkeys[SSL_PKEY_GOST01].x509;
	if (peer_cert == NULL) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);
		goto err;
	}

	pub_key = X509_get_pubkey(peer_cert);
	pkey_ctx = EVP_PKEY_CTX_new(pub_key, NULL);

	/*
	 * If we have send a certificate, and certificate key parameters match
	 * those of server certificate, use certificate key for key exchange.
	 * Otherwise, generate ephemeral key pair.
	 */
	EVP_PKEY_encrypt_init(pkey_ctx);

	/* Generate session key. */
	arc4random_buf(premaster_secret, 32);

	/*
	 * If we have client certificate, use its secret as peer key.
	 */
	if (s->s3->tmp.cert_req && s->cert->key->privatekey) {
		if (EVP_PKEY_derive_set_peer(pkey_ctx,
		    s->cert->key->privatekey) <=0) {
			/*
			 * If there was an error - just ignore it.
			 * Ephemeral key would be used.
			 */
			ERR_clear_error();
		}
	}

	/*
	 * Compute shared IV and store it in algorithm-specific context data.
	 */
	ukm_hash = EVP_MD_CTX_create();
	if (ukm_hash == NULL) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
		    ERR_R_MALLOC_FAILURE);
		goto err;
	}

	if (ssl_get_algorithm2(s) & SSL_HANDSHAKE_MAC_GOST94)
		nid = NID_id_GostR3411_94;
	else
		nid = NID_id_tc26_gost3411_2012_256;
	if (!EVP_DigestInit(ukm_hash, EVP_get_digestbynid(nid)))
		goto err;
	EVP_DigestUpdate(ukm_hash, s->s3->client_random, SSL3_RANDOM_SIZE);
	EVP_DigestUpdate(ukm_hash, s->s3->server_random, SSL3_RANDOM_SIZE);
	EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len);
	EVP_MD_CTX_destroy(ukm_hash);
	if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT,
	    EVP_PKEY_CTRL_SET_IV, 8, shared_ukm) < 0) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, SSL_R_LIBRARY_BUG);
		goto err;
	}

	/*
	 * Make GOST keytransport blob message, encapsulate it into sequence.
	 */
	*(p++) = V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED;
	msglen = 255;
	if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, premaster_secret,
	    32) < 0) {
		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, SSL_R_LIBRARY_BUG);
		goto err;
	}
	if (msglen >= 0x80) {
		*(p++) = 0x81;
		*(p++) = msglen & 0xff;
		n = msglen + 3;
	} else {
		*(p++) = msglen & 0xff;
		n = msglen + 2;
	}
	memcpy(p, tmp, msglen);

	/* Check if pubkey from client certificate was used. */
	if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2,
	    NULL) > 0) {
		/* Set flag "skip certificate verify". */
		s->s3->flags |= TLS1_FLAGS_SKIP_CERT_VERIFY;
	}
	EVP_PKEY_CTX_free(pkey_ctx);
	s->session->master_key_length =
	    s->method->ssl3_enc->generate_master_secret(s,
		s->session->master_key, premaster_secret, 32);

	*outlen = n;
	ret = 1;

err:
	explicit_bzero(premaster_secret, sizeof(premaster_secret));
	EVP_PKEY_free(pub_key);

	return (ret);
}

int
ssl3_send_client_key_exchange(SSL *s)
{
	SESS_CERT *sess_cert;
	unsigned long alg_k;
	unsigned char *p;
	int n = 0;

	if (s->state == SSL3_ST_CW_KEY_EXCH_A) {
		p = ssl3_handshake_msg_start(s, SSL3_MT_CLIENT_KEY_EXCHANGE);

		alg_k = s->s3->tmp.new_cipher->algorithm_mkey;

		if ((sess_cert = s->session->sess_cert) == NULL) {
			ssl3_send_alert(s, SSL3_AL_FATAL,
			    SSL_AD_UNEXPECTED_MESSAGE);
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}

		if (alg_k & SSL_kRSA) {
			if (ssl3_send_client_kex_rsa(s, sess_cert, p, &n) != 1)
				goto err;
		} else if (alg_k & SSL_kDHE) {
			if (ssl3_send_client_kex_dhe(s, sess_cert, p, &n) != 1)
				goto err;
		} else if (alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe)) {
			if (ssl3_send_client_kex_ecdh(s, sess_cert, p, &n) != 1)
				goto err;
		} else if (alg_k & SSL_kGOST) {
			if (ssl3_send_client_kex_gost(s, sess_cert, p, &n) != 1)
				goto err;
		} else {
			ssl3_send_alert(s, SSL3_AL_FATAL,
			    SSL_AD_HANDSHAKE_FAILURE);
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}

		ssl3_handshake_msg_finish(s, n);

		s->state = SSL3_ST_CW_KEY_EXCH_B;
	}

	/* SSL3_ST_CW_KEY_EXCH_B */
	return (ssl3_handshake_write(s));

err:
	return (-1);
}

int
ssl3_send_client_verify(SSL *s)
{
	unsigned char	*p;
	unsigned char	 data[MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH];
	EVP_PKEY	*pkey;
	EVP_PKEY_CTX	*pctx = NULL;
	EVP_MD_CTX	 mctx;
	unsigned	 u = 0;
	unsigned long	 n;
	int		 j;

	EVP_MD_CTX_init(&mctx);

	if (s->state == SSL3_ST_CW_CERT_VRFY_A) {
		p = ssl3_handshake_msg_start(s, SSL3_MT_CERTIFICATE_VERIFY);

		/*
		 * Create context from key and test if sha1 is allowed as
		 * digest.
		 */
		pkey = s->cert->key->privatekey;
		pctx = EVP_PKEY_CTX_new(pkey, NULL);
		EVP_PKEY_sign_init(pctx);
		if (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1()) > 0) {
			if (!SSL_USE_SIGALGS(s))
				s->method->ssl3_enc->cert_verify_mac(s,
				    NID_sha1, &(data[MD5_DIGEST_LENGTH]));
		} else {
			ERR_clear_error();
		}
		/*
		 * For TLS v1.2 send signature algorithm and signature
		 * using agreed digest and cached handshake records.
		 */
		if (SSL_USE_SIGALGS(s)) {
			long hdatalen = 0;
			void *hdata;
			const EVP_MD *md = s->cert->key->digest;
			hdatalen = BIO_get_mem_data(s->s3->handshake_buffer,
			    &hdata);
			if (hdatalen <= 0 ||
			    !tls12_get_sigandhash(p, pkey, md)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			p += 2;
			if (!EVP_SignInit_ex(&mctx, md, NULL) ||
			    !EVP_SignUpdate(&mctx, hdata, hdatalen) ||
			    !EVP_SignFinal(&mctx, p + 2, &u, pkey)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
				    ERR_R_EVP_LIB);
				goto err;
			}
			s2n(u, p);
			n = u + 4;
			if (!tls1_digest_cached_records(s))
				goto err;
		} else if (pkey->type == EVP_PKEY_RSA) {
			s->method->ssl3_enc->cert_verify_mac(
			    s, NID_md5, &(data[0]));
			if (RSA_sign(NID_md5_sha1, data,
			    MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH, &(p[2]),
			    &u, pkey->pkey.rsa) <= 0 ) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
				    ERR_R_RSA_LIB);
				goto err;
			}
			s2n(u, p);
			n = u + 2;
		} else if (pkey->type == EVP_PKEY_DSA) {
			if (!DSA_sign(pkey->save_type,
			    &(data[MD5_DIGEST_LENGTH]),
			    SHA_DIGEST_LENGTH, &(p[2]),
			    (unsigned int *)&j, pkey->pkey.dsa)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
				    ERR_R_DSA_LIB);
				goto err;
			}
			s2n(j, p);
			n = j + 2;
		} else if (pkey->type == EVP_PKEY_EC) {
			if (!ECDSA_sign(pkey->save_type,
			    &(data[MD5_DIGEST_LENGTH]),
			    SHA_DIGEST_LENGTH, &(p[2]),
			    (unsigned int *)&j, pkey->pkey.ec)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
				    ERR_R_ECDSA_LIB);
				goto err;
			}
			s2n(j, p);
			n = j + 2;
#ifndef OPENSSL_NO_GOST
		} else if (pkey->type == NID_id_GostR3410_94 ||
			   pkey->type == NID_id_GostR3410_2001) {
			unsigned char signbuf[128];
			long hdatalen = 0;
			void *hdata;
			const EVP_MD *md;
			int nid;
			size_t sigsize;

			hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
			if (hdatalen <= 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			if (!EVP_PKEY_get_default_digest_nid(pkey, &nid) ||
			    !(md = EVP_get_digestbynid(nid))) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
						ERR_R_EVP_LIB);
				goto err;
			}
			if (!EVP_DigestInit_ex(&mctx, md, NULL) ||
			    !EVP_DigestUpdate(&mctx, hdata, hdatalen) ||
			    !EVP_DigestFinal(&mctx, signbuf, &u) ||
			    (EVP_PKEY_CTX_set_signature_md(pctx, md) <= 0) ||
			    (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
					       EVP_PKEY_CTRL_GOST_SIG_FORMAT,
					       GOST_SIG_FORMAT_RS_LE,
					       NULL) <= 0) ||
			    (EVP_PKEY_sign(pctx, &(p[2]), &sigsize,
					   signbuf, u) <= 0)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
				    ERR_R_EVP_LIB);
				goto err;
			}
			if (!tls1_digest_cached_records(s))
				goto err;
			j = sigsize;
			s2n(j, p);
			n = j + 2;
#endif
		} else {
			SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}

		s->state = SSL3_ST_CW_CERT_VRFY_B;

		ssl3_handshake_msg_finish(s, n);
	}

	EVP_MD_CTX_cleanup(&mctx);
	EVP_PKEY_CTX_free(pctx);

	return (ssl3_handshake_write(s));

err:
	EVP_MD_CTX_cleanup(&mctx);
	EVP_PKEY_CTX_free(pctx);
	return (-1);
}

int
ssl3_send_client_certificate(SSL *s)
{
	X509		*x509 = NULL;
	EVP_PKEY	*pkey = NULL;
	int		 i;
	unsigned long	 l;

	if (s->state ==	SSL3_ST_CW_CERT_A) {
		if ((s->cert == NULL) || (s->cert->key->x509 == NULL) ||
		    (s->cert->key->privatekey == NULL))
			s->state = SSL3_ST_CW_CERT_B;
		else
			s->state = SSL3_ST_CW_CERT_C;
	}

	/* We need to get a client cert */
	if (s->state == SSL3_ST_CW_CERT_B) {
		/*
		 * If we get an error, we need to
		 * ssl->rwstate=SSL_X509_LOOKUP; return(-1);
		 * We then get retied later
		 */
		i = ssl_do_client_cert_cb(s, &x509, &pkey);
		if (i < 0) {
			s->rwstate = SSL_X509_LOOKUP;
			return (-1);
		}
		s->rwstate = SSL_NOTHING;
		if ((i == 1) && (pkey != NULL) && (x509 != NULL)) {
			s->state = SSL3_ST_CW_CERT_B;
			if (!SSL_use_certificate(s, x509) ||
			    !SSL_use_PrivateKey(s, pkey))
				i = 0;
		} else if (i == 1) {
			i = 0;
			SSLerr(SSL_F_SSL3_SEND_CLIENT_CERTIFICATE,
			    SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
		}

		X509_free(x509);
		EVP_PKEY_free(pkey);
		if (i == 0)
			s->s3->tmp.cert_req = 2;

		/* Ok, we have a cert */
		s->state = SSL3_ST_CW_CERT_C;
	}

	if (s->state == SSL3_ST_CW_CERT_C) {
		s->state = SSL3_ST_CW_CERT_D;
		l = ssl3_output_cert_chain(s,
		    (s->s3->tmp.cert_req == 2) ? NULL : s->cert->key->x509);
		s->init_num = (int)l;
		s->init_off = 0;
	}
	/* SSL3_ST_CW_CERT_D */
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}

#define has_bits(i,m)	(((i)&(m)) == (m))

int
ssl3_check_cert_and_algorithm(SSL *s)
{
	int		 i, idx;
	long		 alg_k, alg_a;
	EVP_PKEY	*pkey = NULL;
	SESS_CERT	*sc;
	DH		*dh;

	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	alg_a = s->s3->tmp.new_cipher->algorithm_auth;

	/* We don't have a certificate. */
	if (alg_a & SSL_aNULL)
		return (1);

	sc = s->session->sess_cert;
	if (sc == NULL) {
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
		    ERR_R_INTERNAL_ERROR);
		goto err;
	}
	dh = s->session->sess_cert->peer_dh_tmp;

	/* This is the passed certificate. */

	idx = sc->peer_cert_type;
	if (idx == SSL_PKEY_ECC) {
		if (ssl_check_srvr_ecc_cert_and_alg(
		    sc->peer_pkeys[idx].x509, s) == 0) {
			/* check failed */
			SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
			    SSL_R_BAD_ECC_CERT);
			goto f_err;
		} else {
			return (1);
		}
	}
	pkey = X509_get_pubkey(sc->peer_pkeys[idx].x509);
	i = X509_certificate_type(sc->peer_pkeys[idx].x509, pkey);
	EVP_PKEY_free(pkey);

	/* Check that we have a certificate if we require one. */
	if ((alg_a & SSL_aRSA) && !has_bits(i, EVP_PK_RSA|EVP_PKT_SIGN)) {
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
		    SSL_R_MISSING_RSA_SIGNING_CERT);
		goto f_err;
	} else if ((alg_a & SSL_aDSS) &&
	    !has_bits(i, EVP_PK_DSA|EVP_PKT_SIGN)) {
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
		    SSL_R_MISSING_DSA_SIGNING_CERT);
		goto f_err;
	}
	if ((alg_k & SSL_kRSA) &&
	    !has_bits(i, EVP_PK_RSA|EVP_PKT_ENC)) {
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
		    SSL_R_MISSING_RSA_ENCRYPTING_CERT);
		goto f_err;
	}
	if ((alg_k & SSL_kDHE) &&
	    !(has_bits(i, EVP_PK_DH|EVP_PKT_EXCH) || (dh != NULL))) {
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
		    SSL_R_MISSING_DH_KEY);
		goto f_err;
	}

	return (1);
f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
err:
	return (0);
}

int
ssl3_send_next_proto(SSL *s)
{
	unsigned int	 len, padding_len;
	unsigned char	*d, *p;

	if (s->state == SSL3_ST_CW_NEXT_PROTO_A) {
		d = p = ssl3_handshake_msg_start(s, SSL3_MT_NEXT_PROTO);

		len = s->next_proto_negotiated_len;
		padding_len = 32 - ((len + 2) % 32);
		*(p++) = len;
		memcpy(p, s->next_proto_negotiated, len);
		p += len;
		*(p++) = padding_len;
		memset(p, 0, padding_len);
		p += padding_len;

		ssl3_handshake_msg_finish(s, p - d);

		s->state = SSL3_ST_CW_NEXT_PROTO_B;
	}

	return (ssl3_handshake_write(s));
}

/*
 * Check to see if handshake is full or resumed. Usually this is just a
 * case of checking to see if a cache hit has occurred. In the case of
 * session tickets we have to check the next message to be sure.
 */

int
ssl3_check_finished(SSL *s)
{
	int	ok;
	long	n;

	/* If we have no ticket it cannot be a resumed session. */
	if (!s->session->tlsext_tick)
		return (1);
	/* this function is called when we really expect a Certificate
	 * message, so permit appropriate message length */
	n = s->method->ssl_get_message(s, SSL3_ST_CR_CERT_A,
	    SSL3_ST_CR_CERT_B, -1, s->max_cert_list, &ok);
	if (!ok)
		return ((int)n);
	s->s3->tmp.reuse_message = 1;
	if ((s->s3->tmp.message_type == SSL3_MT_FINISHED) ||
	    (s->s3->tmp.message_type == SSL3_MT_NEWSESSION_TICKET))
		return (2);

	return (1);
}

int
ssl_do_client_cert_cb(SSL *s, X509 **px509, EVP_PKEY **ppkey)
{
	int	i = 0;

#ifndef OPENSSL_NO_ENGINE
	if (s->ctx->client_cert_engine) {
		i = ENGINE_load_ssl_client_cert(s->ctx->client_cert_engine, s,
		SSL_get_client_CA_list(s),
		px509, ppkey, NULL, NULL, NULL);
		if (i != 0)
			return (i);
	}
#endif
	if (s->ctx->client_cert_cb)
		i = s->ctx->client_cert_cb(s, px509, ppkey);
	return (i);
}
@


1.138
log
@Merge a memleak fix from BoringSSL 6b6e0b2:

https://boringssl.googlesource.com/boringssl/+/6b6e0b20893e2be0e68af605a60ffa2cbb0ffa64%5E!/#F0

ok millert@@, beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.137 2016/03/11 07:08:45 mmcc Exp $ */
@


1.137
log
@X509_free(3) is NULL-safe, so remove NULL checks before its calls.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.136 2015/10/02 14:30:10 jsing Exp $ */
d1644 1
d1662 1
@


1.136
log
@s/ssl3_client_kex/ssl3_send_client_kex/ for consistency with the caller.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.135 2015/09/13 12:52:07 jsing Exp $ */
d1066 1
a1066 2
	if (sc->peer_pkeys[i].x509 != NULL)
		X509_free(sc->peer_pkeys[i].x509);
d1070 1
a1070 2
	if (s->session->peer != NULL)
		X509_free(s->session->peer);
d2466 1
a2466 2
		if (x509 != NULL)
			X509_free(x509);
@


1.135
log
@Stop generating private keys in a network buffer.

The current client key exchange code generates DH and ECDH keys into the
same buffer that we use to send data to the network - stop doing this and
malloc() a new buffer, which we explicit_bzero() and free() on return.
This also benefits from ASLR and means that the keys are no longer
generated in a well known location.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.133 2015/09/12 20:56:14 jsing Exp $ */
d1857 2
a1858 1
ssl3_client_kex_rsa(SSL *s, SESS_CERT *sess_cert, unsigned char *p, int *outlen)
d1909 2
a1910 1
ssl3_client_kex_dhe(SSL *s, SESS_CERT *sess_cert, unsigned char *p, int *outlen)
d1971 1
a1971 1
ssl3_client_kex_ecdh(SSL *s, SESS_CERT *sess_cert, unsigned char *p,
d2102 1
a2102 1
ssl3_client_kex_gost(SSL *s, SESS_CERT *sess_cert, unsigned char *p,
d2240 1
a2240 1
			if (ssl3_client_kex_rsa(s, sess_cert, p, &n) != 1)
d2243 1
a2243 1
			if (ssl3_client_kex_dhe(s, sess_cert, p, &n) != 1)
d2246 1
a2246 1
			if (ssl3_client_kex_ecdh(s, sess_cert, p, &n) != 1)
d2249 1
a2249 1
			if (ssl3_client_kex_gost(s, sess_cert, p, &n) != 1)
@


1.134
log
@Use ECDH_size() instead of rolling our own.

ok beck@@
@
text
@d1911 2
a1913 1
	int n;
d1933 7
a1939 6

	/*
	 * Use the 'p' output buffer for the DH key, but make sure to clear
	 * it out afterwards.
	 */
	n = DH_compute_key(p, dh_srvr->pub_key, dh_clnt);
d1948 1
a1948 4
		s->session->master_key, p, n);

	/* Clean up. */
	explicit_bzero(p, n);
d1961 3
d1972 1
a1972 1
	EC_KEY *clnt_ecdh = NULL;
d1978 1
d1981 1
a1981 2
	int key_size;
	EC_KEY *tkey;
a1982 1
	int n;
d2029 1
a2029 1
	/* Generate a new ECDH key pair */
a2033 5

	/*
	 * Use the 'p' output buffer for the ECDH key, but make sure to clear
	 * it out afterwards.
	 */
d2039 5
a2043 1
	n = ECDH_compute_key(p, key_size, srvr_ecpoint, clnt_ecdh, NULL);
d2052 1
a2052 4
		s->session->master_key, p, n);

	/* Clean up. */
	explicit_bzero(p, n);
d2087 4
a2090 1
	/* Free allocated memory */
d2222 1
a2222 1
	int n;
@


1.133
log
@Split ssl3_send_client_key_exchange() (387 lines of code) into five
functions. The original was written as a huge if/else if chain -
split out the handling for each key exchange type. This allows us to reduce
two levels of indentation, make the code far more readable and have single
return paths so that we can simplify clean up.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.129 2015/09/12 10:25:38 jsing Exp $ */
d1978 1
a1978 1
	int field_size = 0;
d2038 2
a2039 2
	field_size = EC_GROUP_get_degree(srvr_group);
	if (field_size <= 0) {
d2043 1
a2043 2
	n = ECDH_compute_key(p, (field_size + 7) / 8, srvr_ecpoint, clnt_ecdh,
	    NULL);
@


1.132
log
@explicit_bzero() the GOST premaster secret.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.131 2015/09/12 16:10:07 doug Exp $ */
d1856 53
a1908 2
int
ssl3_send_client_key_exchange(SSL *s)
d1910 52
a1961 10
	unsigned char	*p, *q;
	int		 n;
	unsigned long	 alg_k;
	EVP_PKEY	*pkey = NULL;
	EC_KEY		*clnt_ecdh = NULL;
	const EC_POINT	*srvr_ecpoint = NULL;
	EVP_PKEY	*srvr_pub_pkey = NULL;
	unsigned char	*encodedPoint = NULL;
	int		 encoded_pt_len = 0;
	BN_CTX		*bn_ctx = NULL;
d1963 2
a1964 2
	if (s->state == SSL3_ST_CW_KEY_EXCH_A) {
		p = ssl3_handshake_msg_start(s, SSL3_MT_CLIENT_KEY_EXCHANGE);
d1966 16
a1981 1
		alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
d1983 1
a1983 7
		if (s->session->sess_cert == NULL) {
			ssl3_send_alert(s, SSL3_AL_FATAL,
			    SSL_AD_UNEXPECTED_MESSAGE);
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}
d1985 8
a1992 3
		if (alg_k & SSL_kRSA) {
			RSA *rsa;
			unsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
d1994 7
a2000 13
			pkey = X509_get_pubkey(
			    s->session->sess_cert->peer_pkeys[
			    SSL_PKEY_RSA_ENC].x509);
			if ((pkey == NULL) ||
			    (pkey->type != EVP_PKEY_RSA) ||
			    (pkey->pkey.rsa == NULL)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				EVP_PKEY_free(pkey);
				goto err;
			}
			rsa = pkey->pkey.rsa;
			EVP_PKEY_free(pkey);
d2002 5
a2006 3
			tmp_buf[0] = s->client_version >> 8;
			tmp_buf[1] = s->client_version & 0xff;
			arc4random_buf(&tmp_buf[2], sizeof(tmp_buf) - 2);
d2008 2
a2009 1
			s->session->master_key_length = sizeof tmp_buf;
d2011 5
a2015 3
			q = p;
			/* Fix buf for TLS and beyond */
			p += 2;
d2017 5
a2021 7
			n = RSA_public_encrypt(sizeof tmp_buf,
			tmp_buf, p, rsa, RSA_PKCS1_PADDING);
			if (n <= 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_BAD_RSA_ENCRYPT);
				goto err;
			}
d2023 4
a2026 10
			/* Fix buf for TLS and beyond */
			s2n(n, q);
			n += 2;

			s->session->master_key_length =
			    s->method->ssl3_enc->generate_master_secret(
			    s, s->session->master_key, tmp_buf, sizeof tmp_buf);
			explicit_bzero(tmp_buf, sizeof tmp_buf);
		} else if (alg_k & SSL_kDHE) {
			DH *dh_srvr, *dh_clnt;
d2028 5
a2032 9
			/* Ensure that we have an ephemeral key for DHE. */
			if (s->session->sess_cert->peer_dh_tmp == NULL) {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_HANDSHAKE_FAILURE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);
				goto err;
			}
			dh_srvr = s->session->sess_cert->peer_dh_tmp;
d2034 15
a2048 12
			/* Generate a new random key. */
			if ((dh_clnt = DHparams_dup(dh_srvr)) == NULL) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				goto err;
			}
			if (!DH_generate_key(dh_clnt)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				DH_free(dh_clnt);
				goto err;
			}
d2050 4
a2053 11
			/*
			 * Use the 'p' output buffer for the DH key, but
			 * make sure to clear it out afterwards.
			 */
			n = DH_compute_key(p, dh_srvr->pub_key, dh_clnt);
			if (n <= 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				DH_free(dh_clnt);
				goto err;
			}
d2055 2
a2056 13
			/* Generate master key from the result. */
			s->session->master_key_length =
			    s->method->ssl3_enc->generate_master_secret(s,
				s->session->master_key, p, n);

			/* Clean up. */
			explicit_bzero(p, n);

			/* Send off the data. */
			n = BN_num_bytes(dh_clnt->pub_key);
			s2n(n, p);
			BN_bn2bin(dh_clnt->pub_key, p);
			n += 2;
d2058 14
a2071 1
			DH_free(dh_clnt);
d2073 13
a2085 16
			/* perhaps clean things up a bit EAY EAY EAY EAY*/
		} else if (alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe)) {
			const EC_GROUP *srvr_group = NULL;
			EC_KEY *tkey;
			int field_size = 0;

			/* Ensure that we have an ephemeral key for ECDHE. */
			if ((alg_k & SSL_kECDHE) &&
			    s->session->sess_cert->peer_ecdh_tmp == NULL) {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_HANDSHAKE_FAILURE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			tkey = s->session->sess_cert->peer_ecdh_tmp;
d2087 2
a2088 8
			if (alg_k & (SSL_kECDHr|SSL_kECDHe)) {
				/* Get the Server Public Key from Cert */
				srvr_pub_pkey = X509_get_pubkey(s->session-> \
				    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
				if (srvr_pub_pkey != NULL &&
				    srvr_pub_pkey->type == EVP_PKEY_EC)
					tkey = srvr_pub_pkey->pkey.ec;
			}
d2090 6
a2095 5
			if (tkey == NULL) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
d2097 2
a2098 2
			srvr_group = EC_KEY_get0_group(tkey);
			srvr_ecpoint = EC_KEY_get0_public_key(tkey);
d2100 22
a2121 5
			if ((srvr_group == NULL) || (srvr_ecpoint == NULL)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
d2123 2
a2124 5
			if ((clnt_ecdh = EC_KEY_new()) == NULL) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}
d2126 6
a2131 5
			if (!EC_KEY_set_group(clnt_ecdh, srvr_group)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_EC_LIB);
				goto err;
			}
d2133 2
a2134 6
			/* Generate a new ECDH key pair */
			if (!(EC_KEY_generate_key(clnt_ecdh))) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_ECDH_LIB);
				goto err;
			}
d2136 6
d2143 2
a2144 2
			 * Use the 'p' output buffer for the ECDH key, but
			 * make sure to clear it out afterwards.
d2146 49
a2194 13
			field_size = EC_GROUP_get_degree(srvr_group);
			if (field_size <= 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_ECDH_LIB);
				goto err;
			}
			n = ECDH_compute_key(p, (field_size + 7) / 8,
			    srvr_ecpoint, clnt_ecdh, NULL);
			if (n <= 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_ECDH_LIB);
				goto err;
			}
d2196 10
a2205 4
			/* generate master key from the result */
			s->session->master_key_length =
			    s->method->ssl3_enc->generate_master_secret(s,
				s->session->master_key, p, n);
d2207 2
a2208 2
			/* Clean up. */
			explicit_bzero(p, n);
d2210 3
a2212 16
			/*
			 * First check the size of encoding and
			 * allocate memory accordingly.
			 */
			encoded_pt_len = EC_POINT_point2oct(srvr_group,
			    EC_KEY_get0_public_key(clnt_ecdh),
			    POINT_CONVERSION_UNCOMPRESSED, NULL, 0, NULL);

			encodedPoint = malloc(encoded_pt_len);

			bn_ctx = BN_CTX_new();
			if ((encodedPoint == NULL) || (bn_ctx == NULL)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}
d2214 2
a2215 40
			/* Encode the public key */
			n = EC_POINT_point2oct(srvr_group,
			    EC_KEY_get0_public_key(clnt_ecdh),
			    POINT_CONVERSION_UNCOMPRESSED, encodedPoint,
			    encoded_pt_len, bn_ctx);

			*p = n; /* length of encoded point */
			/* Encoded point will be copied here */
			p += 1;

			/* copy the point */
			memcpy((unsigned char *)p, encodedPoint, n);
			/* increment n to account for length field */
			n += 1;

			/* Free allocated memory */
			BN_CTX_free(bn_ctx);
			free(encodedPoint);
			EC_KEY_free(clnt_ecdh);
			EVP_PKEY_free(srvr_pub_pkey);
		} else if (alg_k & SSL_kGOST) {
			/* GOST key exchange message creation */
			EVP_PKEY_CTX *pkey_ctx;
			X509 *peer_cert;

			size_t msglen;
			unsigned int md_len;
			unsigned char premaster_secret[32], shared_ukm[32],
			    tmp[256];
			EVP_MD_CTX *ukm_hash;
			EVP_PKEY *pub_key;
			int nid;

			/* Get server sertificate PKEY and create ctx from it */
			peer_cert = s->session->sess_cert->peer_pkeys[SSL_PKEY_GOST01].x509;
			if (!peer_cert) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);
				goto err;
			}
d2217 7
a2223 2
			pub_key = X509_get_pubkey(peer_cert);
			pkey_ctx = EVP_PKEY_CTX_new(pub_key, NULL);
d2225 2
a2226 7
			/*
			 * If we have send a certificate, and certificate key
			 * parameters match those of server certificate, use
			 * certificate key for key exchange.
			 * Otherwise, generate ephemeral key pair.
			 */
			EVP_PKEY_encrypt_init(pkey_ctx);
d2228 1
a2228 2
			/* Generate session key. */
			arc4random_buf(premaster_secret, 32);
d2230 7
a2236 14
			/*
			 * If we have client certificate, use its secret as
			 * peer key.
			 */
			if (s->s3->tmp.cert_req && s->cert->key->privatekey) {
				if (EVP_PKEY_derive_set_peer(pkey_ctx,
				    s->cert->key->privatekey) <=0) {
					/*
					 * If there was an error - just ignore
					 * it. Ephemeral key would be used.
					 */
					ERR_clear_error();
				}
			}
d2238 2
a2239 10
			/*
			 * Compute shared IV and store it in algorithm-specific
			 * context data.
			 */
			ukm_hash = EVP_MD_CTX_create();
			if (ukm_hash == NULL) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				explicit_bzero(premaster_secret,
				    sizeof(premaster_secret));
d2241 2
a2242 7
			}

			if (ssl_get_algorithm2(s) & SSL_HANDSHAKE_MAC_GOST94)
				nid = NID_id_GostR3411_94;
			else
				nid = NID_id_tc26_gost3411_2012_256;
			if (!EVP_DigestInit(ukm_hash, EVP_get_digestbynid(nid)))
d2244 2
a2245 12
			EVP_DigestUpdate(ukm_hash,
			    s->s3->client_random, SSL3_RANDOM_SIZE);
			EVP_DigestUpdate(ukm_hash,
			    s->s3->server_random, SSL3_RANDOM_SIZE);
			EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len);
			EVP_MD_CTX_destroy(ukm_hash);
			if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT,
			    EVP_PKEY_CTRL_SET_IV, 8, shared_ukm) < 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_LIBRARY_BUG);
				explicit_bzero(premaster_secret,
				    sizeof(premaster_secret));
d2247 2
a2248 12
			}

			/*
			 * Make GOST keytransport blob message, encapsulate it
			 * into sequence.
			 */
			*(p++) = V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED;
			msglen = 255;
			if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen,
			    premaster_secret, 32) < 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_LIBRARY_BUG);
a2249 23
			}
			if (msglen >= 0x80) {
				*(p++) = 0x81;
				*(p++) = msglen & 0xff;
				n = msglen + 3;
			} else {
				*(p++) = msglen & 0xff;
				n = msglen + 2;
			}
			memcpy(p, tmp, msglen);
			/* Check if pubkey from client certificate was used. */
			if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, -1,
			    EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0) {
				/* Set flag "skip certificate verify". */
				s->s3->flags |= TLS1_FLAGS_SKIP_CERT_VERIFY;
			}
			EVP_PKEY_CTX_free(pkey_ctx);
			s->session->master_key_length =
			    s->method->ssl3_enc->generate_master_secret(s,
			    s->session->master_key, premaster_secret, 32);
			EVP_PKEY_free(pub_key);
			explicit_bzero(premaster_secret,
			    sizeof(premaster_secret));
a2266 4
	BN_CTX_free(bn_ctx);
	free(encodedPoint);
	EC_KEY_free(clnt_ecdh);
	EVP_PKEY_free(srvr_pub_pkey);
@


1.131
log
@Remove most of the SSLv3 version checks and a few TLS v1.0.

We can now assume >= TLS v1.0 since SSL2_VERSION, SSL3_VERSION and
DTLS1_BAD_VER support was removed.

"reads ok" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.130 2015/09/12 12:17:00 jsing Exp $ */
d2162 2
d2183 2
d2220 2
a2221 1

@


1.130
log
@Use explicit_bzero() instead of memset() when clearing private keys.

ok bcook@@ beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.129 2015/09/12 10:25:38 jsing Exp $ */
d798 1
a798 1
	if (s->version >= TLS1_VERSION && s->tls_session_secret_cb) {
d904 8
a911 13
	if (s->version >= SSL3_VERSION) {
		if (!ssl_parse_serverhello_tlsext(s, &p, d, n, &al)) {
			/* 'al' set by ssl_parse_serverhello_tlsext */
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
			    SSL_R_PARSE_TLSEXT);
			goto f_err;

		}
		if (ssl_check_serverhello_tlsext(s) <= 0) {
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
			    SSL_R_SERVERHELLO_TLSEXT);
			goto err;
		}
d1536 5
a1540 8
	if (s->version > SSL3_VERSION) {
		if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) {
			ssl3_send_alert(s, SSL3_AL_FATAL,
			    SSL_AD_UNEXPECTED_MESSAGE);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
			    SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER);
			goto err;
		}
d1909 2
a1910 2
			if (s->version > SSL3_VERSION)
				p += 2;
d1920 2
a1921 4
			if (s->version > SSL3_VERSION) {
				s2n(n, q);
				n += 2;
			}
d2441 2
a2442 10
		if (i == 0) {
			if (s->version == SSL3_VERSION) {
				s->s3->tmp.cert_req = 0;
				ssl3_send_alert(s, SSL3_AL_WARNING,
				    SSL_AD_NO_CERTIFICATE);
				return (1);
			} else {
				s->s3->tmp.cert_req = 2;
			}
		}
@


1.129
log
@Pull variable assignment out from function call, fix indentation and set
state after calling ssl3_handshake_msg_finish().
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.128 2015/09/12 10:09:16 jsing Exp $ */
d1981 1
a1981 1
			memset(p, 0, n);
d2074 2
a2075 1
			memset(p, 0, n); /* clean up */
@


1.128
log
@style(9) and whitespace cleanups.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.127 2015/09/11 18:08:21 jsing Exp $ */
d1977 2
a1978 2
			s->method->ssl3_enc->generate_master_secret(s,
			    s->session->master_key, p, n);
d2134 2
a2135 3
			pkey_ctx = EVP_PKEY_CTX_new(
			    pub_key = X509_get_pubkey(peer_cert),
			    NULL);
d2234 2
a2236 2

		ssl3_handshake_msg_finish(s, n);
@


1.127
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.126 2015/09/10 15:56:26 jsing Exp $ */
a1967 1

a1996 1

d2046 1
a2046 2
				SSLerr(
				    SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
d2061 1
a2061 1
			n = ECDH_compute_key(p, (field_size + 7)/8,
d2070 3
a2072 3
			s->session->master_key_length = s->method->ssl3_enc \
			    -> generate_master_secret(s,
			    s->session->master_key, p, n);
d2080 3
a2082 5
			encoded_pt_len = EC_POINT_point2oct(
				srvr_group,
				EC_KEY_get0_public_key(clnt_ecdh),
				POINT_CONVERSION_UNCOMPRESSED,
				NULL, 0, NULL);
d2087 2
a2088 4
			if ((encodedPoint == NULL) ||
			    (bn_ctx == NULL)) {
				SSLerr(
				    SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
d2096 2
a2097 2
			    POINT_CONVERSION_UNCOMPRESSED,
			    encodedPoint, encoded_pt_len, bn_ctx);
d2137 1
d2144 1
a2145 1
			EVP_PKEY_encrypt_init(pkey_ctx);
d2148 1
d2150 2
a2151 2
			 * If we have client certificate, use its secret
			 * as peer key.
d2157 2
a2158 3
					 * If there was an error -
					 * just ignore it. Ephemeral key
					 * would be used
d2163 1
d2166 1
a2166 1
			 * context data
d2193 1
d2195 2
a2196 2
			 * Make GOST keytransport blob message,
			 * encapsulate it into sequence.
@


1.126
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.125 2015/09/02 17:59:15 jsing Exp $ */
d237 1
a237 1
			if (!ssl3_init_finished_mac(s)) {
d520 1
a520 1
			ssl3_cleanup_key_block(s);
d888 1
a888 1
	    !ssl3_digest_cached_records(s)) {
d1527 1
a1527 1
			if (!ssl3_digest_cached_records(s))
d2312 1
a2312 1
			if (!ssl3_digest_cached_records(s))
d2384 1
a2384 1
			if (!ssl3_digest_cached_records(s))
@


1.125
log
@Replace dtls1_client_hello() with ssl3_client_hello() - both are basically
the same code, with two slight differences for DTLS handling.

Also, make use of send_cookie to determine if the client random needs to
be preserved, rather than testing if it is zeroed (hopefully your random
number generator never returned all zeros, since the existing code would
break). Inspired by BoringSSL.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.124 2015/09/01 13:38:27 jsing Exp $ */
d1936 1
a1936 1
			OPENSSL_cleanse(tmp_buf, sizeof tmp_buf);
@


1.124
log
@Remove the ssl_prepare_{client,server}hello_tlsext() functions, which are
now nothing more than noops.

ok bcook@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.123 2015/08/29 16:51:17 doug Exp $ */
a586 1

d605 7
a611 1
		arc4random_buf(s->s3->client_random, SSL3_RANDOM_SIZE);
d668 12
d703 2
a705 2

		ssl3_handshake_msg_finish(s, p - d);
@


1.123
log
@Remove SSLv3 method data structs and unlink s3_meth.c from the build.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.122 2015/08/27 06:21:15 doug Exp $ */
a677 5
		if (ssl_prepare_clienthello_tlsext(s) <= 0) {
			SSLerr(SSL_F_SSL3_CLIENT_HELLO,
			    SSL_R_CLIENTHELLO_TLSEXT);
			goto err;
		}
@


1.122
log
@Remove SSLv3 support from LibreSSL.

This is the first wave of SSLv3 removal which removes the main SSLv3
functions.  Future commits will remove the rest of the SSLv3 support.

Discussed the plan at c2k15.  Input from jsing@@, beck@@, miod@@, bcook@@,
sthen@@, naddy@@, and deraadt@@.

ok jsing@@, beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.121 2015/07/29 19:16:09 miod Exp $ */
a172 1
static const SSL_METHOD *ssl3_get_client_method(int ver);
a173 38

const SSL_METHOD SSLv3_client_method_data = {
	.version = SSL3_VERSION,
	.ssl_new = ssl3_new,
	.ssl_clear = ssl3_clear,
	.ssl_free = ssl3_free,
	.ssl_accept = ssl_undefined_function,
	.ssl_connect = ssl3_connect,
	.ssl_read = ssl3_read,
	.ssl_peek = ssl3_peek,
	.ssl_write = ssl3_write,
	.ssl_shutdown = ssl3_shutdown,
	.ssl_renegotiate = ssl3_renegotiate,
	.ssl_renegotiate_check = ssl3_renegotiate_check,
	.ssl_get_message = ssl3_get_message,
	.ssl_read_bytes = ssl3_read_bytes,
	.ssl_write_bytes = ssl3_write_bytes,
	.ssl_dispatch_alert = ssl3_dispatch_alert,
	.ssl_ctrl = ssl3_ctrl,
	.ssl_ctx_ctrl = ssl3_ctx_ctrl,
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
	.ssl_pending = ssl3_pending,
	.num_ciphers = ssl3_num_ciphers,
	.get_cipher = ssl3_get_cipher,
	.get_ssl_method = ssl3_get_client_method,
	.get_timeout = ssl3_default_timeout,
	.ssl3_enc = &SSLv3_enc_data,
	.ssl_version = ssl_undefined_void_function,
	.ssl_callback_ctrl = ssl3_callback_ctrl,
	.ssl_ctx_callback_ctrl = ssl3_ctx_callback_ctrl,
};

static const SSL_METHOD *
ssl3_get_client_method(int ver)
{
	return (NULL);
}
@


1.121
log
@Add linker warnings in case SSLv3_{,client,server}_method are referenced.

Use of this symbols proves the existence of a code path willingly using SSLv3,
even with OPENSSL_NO_SSL3 being defined, which hints that it needs fixing.

Discussed with the LibreSSL cabal during c2k15; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.120 2015/07/19 07:34:52 doug Exp $ */
a172 6
#ifdef __OpenBSD__
#include <sys/cdefs.h>
__warn_references(SSLv3_client_method,
    "SSLv3_client_method() enables the use of insecure protocols");
#endif

a207 6
const SSL_METHOD *
SSLv3_client_method(void)
{
	return &SSLv3_client_method_data;
}

a210 2
	if (ver == SSL3_VERSION)
		return (SSLv3_client_method());
@


1.120
log
@Convert ssl3_get_certificate_request to CBS.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.119 2015/07/15 22:22:54 beck Exp $ */
d172 6
@


1.119
log
@check n before cbs_init, coverity - ID 125063
ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.118 2015/07/15 21:52:02 beck Exp $ */
d1540 3
a1542 2
	unsigned long		 n, nc, l;
	unsigned int		 llen, ctype_num, i;
d1544 1
a1544 2
	const unsigned char	*p, *q;
	unsigned char		*d;
d1586 3
a1588 1
	p = d = (unsigned char *)s->init_msg;
d1597 1
a1597 1
	if (1 > n)
d1599 1
a1599 1
	ctype_num= *(p++);
d1602 3
a1604 1
	if (p + ctype_num - d > n) {
a1609 3
	for (i = 0; i < ctype_num; i++)
		s->s3->tmp.ctype[i] = p[i];
	p += ctype_num;
d1611 3
a1613 1
		if (p + 2 - d > n) {
d1618 1
a1618 1
		n2s(p, llen);
d1622 1
a1622 1
		if ((unsigned long)(p - d + llen + 2) > n) {
d1628 3
a1630 1
		if ((llen & 1) || !tls1_process_sigalgs(s, p, llen)) {
a1635 1
		p += llen;
d1639 1
a1639 1
	if (p + 2 - d > n) {
a1643 1
	n2s(p, llen);
d1645 2
a1646 1
	if ((unsigned long)(p - d + llen) != n) {
d1653 4
a1656 2
	for (nc = 0; nc < llen; ) {
		if (p + 2 - d > n) {
d1661 2
a1662 2
		n2s(p, l);
		if ((l + nc + 2) > llen) {
d1669 2
a1670 3
		q = p;

		if ((xn = d2i_X509_NAME(NULL, &q, l)) == NULL) {
d1678 1
a1678 1
		if (q != (p + l)) {
a1688 3

		p += l;
		nc += l + 2;
@


1.118
log
@test for n<0 before use in CBS_init - mostly to shut up coverity.
reluctant ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.117 2015/07/15 18:35:34 beck Exp $ */
d1739 7
d1747 1
a1747 2

	if (n < 0 || !CBS_get_u32(&cbs, &lifetime_hint) ||
@


1.117
log
@Flense out dead code, we don't do ecdhe_clnt_cert.
coverity ID's 21691 21698
ok miod@@, "Fry it" jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.116 2015/07/14 03:33:16 doug Exp $ */
a998 1
	CBS_init(&cbs, s->init_msg, n);
d1006 5
a1010 1
	if (n < 0 || CBS_len(&cbs) < 3)
d1012 1
d1804 8
d1813 1
a1813 2

	if (n < 0 || !CBS_get_u8(&cert_status, &status_type) ||
@


1.116
log
@Convert ssl3_get_cert_status to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.115 2015/07/14 03:27:20 doug Exp $ */
a2011 1
			int ecdh_clnt_cert = 0;
a2013 28
			/*
			 * Did we send out the client's ECDH share for use
			 * in premaster computation as part of client
			 * certificate? If so, set ecdh_clnt_cert to 1.
			 */
			if ((alg_k & (SSL_kECDHr|SSL_kECDHe)) &&
			    (s->cert != NULL)) {
				/*
				 * XXX: For now, we do not support client
				 * authentication using ECDH certificates.
				 * To add such support, one needs to add
				 * code that checks for appropriate
				 * conditions and sets ecdh_clnt_cert to 1.
				 * For example, the cert have an ECC
				 * key on the same curve as the server's
				 * and the key should be authorized for
				 * key agreement.
				 *
				 * One also needs to add code in ssl3_connect
				 * to skip sending the certificate verify
				 * message.
				 *
				 * if ((s->cert->key->privatekey != NULL) &&
				 *     (s->cert->key->privatekey->type ==
				 *      EVP_PKEY_EC) && ...)
				 * ecdh_clnt_cert = 1;
				 */
			}
d2061 7
a2067 30
			if (ecdh_clnt_cert) {
				/*
				 * Reuse key info from our certificate
				 * We only need our private key to perform
				 * the ECDH computation.
				 */
				const BIGNUM *priv_key;
				tkey = s->cert->key->privatekey->pkey.ec;
				priv_key = EC_KEY_get0_private_key(tkey);
				if (priv_key == NULL) {
					SSLerr(
					    SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_MALLOC_FAILURE);
					goto err;
				}
				if (!EC_KEY_set_private_key(clnt_ecdh,
				    priv_key)) {
					SSLerr(
					    SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_EC_LIB);
					goto err;
				}
			} else {
				/* Generate a new ECDH key pair */
				if (!(EC_KEY_generate_key(clnt_ecdh))) {
					SSLerr(
					    SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_ECDH_LIB);
					goto err;
				}
d2095 20
a2114 24
			if (ecdh_clnt_cert) {
				/* Send empty client key exch message. */
				n = 0;
			} else {
				/*
				 * First check the size of encoding and
				 * allocate memory accordingly.
				 */
				encoded_pt_len = EC_POINT_point2oct(
				    srvr_group,
				    EC_KEY_get0_public_key(clnt_ecdh),
				    POINT_CONVERSION_UNCOMPRESSED,
				    NULL, 0, NULL);

				encodedPoint = malloc(encoded_pt_len);

				bn_ctx = BN_CTX_new();
				if ((encodedPoint == NULL) ||
				    (bn_ctx == NULL)) {
					SSLerr(
					    SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_MALLOC_FAILURE);
					goto err;
				}
d2116 14
a2129 16
				/* Encode the public key */
				n = EC_POINT_point2oct(srvr_group,
				    EC_KEY_get0_public_key(clnt_ecdh),
				    POINT_CONVERSION_UNCOMPRESSED,
				    encodedPoint, encoded_pt_len, bn_ctx);

				*p = n; /* length of encoded point */
				/* Encoded point will be copied here */
				p += 1;

				/* copy the point */
				memcpy((unsigned char *)p, encodedPoint, n);
				/* increment n to account for length field */
				n += 1;

			}
@


1.115
log
@Convert ssl3_get_server_certificate to CBS.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.114 2015/06/24 09:44:18 jsing Exp $ */
d1787 2
d1790 2
a1791 2
	unsigned long		 resplen, n;
	const unsigned char	*p;
d1799 5
a1803 1
	if (n < 4) {
d1810 2
a1811 2
	p = (unsigned char *)s->init_msg;
	if (*p++ != TLSEXT_STATUSTYPE_ocsp) {
d1817 3
a1819 2
	n2l3(p, resplen);
	if (resplen + 4 != n) {
d1825 11
a1835 9
	free(s->tlsext_ocsp_resp);
	if ((s->tlsext_ocsp_resp = malloc(resplen)) == NULL) {
		al = SSL_AD_INTERNAL_ERROR;
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,
		    ERR_R_MALLOC_FAILURE);
		goto f_err;
	}
	memcpy(s->tlsext_ocsp_resp, p, resplen);
	s->tlsext_ocsp_resplen = resplen;
@


1.114
log
@Stop using BUF_memdup() within the LibreSSL code base - it is correctly
spelt malloc+memcpy, which is what is used in all except two places.

ok deraadt@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.113 2015/06/20 18:19:56 doug Exp $ */
d973 2
a974 1
	unsigned long		 n, nc, llen, l;
d976 1
a976 2
	const unsigned char	*q, *p;
	unsigned char		*d;
d998 2
a999 1
	p = d = (unsigned char *)s->init_msg;
d1007 1
a1007 1
	if (p + 3 - d > n)
d1009 2
a1010 2
	n2l3(p, llen);
	if (llen + 3 != n) {
d1016 5
a1020 2
	for (nc = 0; nc < llen; ) {
		if (p + 3 - d > n)
d1022 1
a1022 2
		n2l3(p, l);
		if ((l + nc + 3) > llen) {
d1029 2
a1030 2
		q = p;
		x = d2i_X509(NULL, &q, l);
d1037 1
a1037 1
		if (q != (p + l)) {
a1048 2
		nc += l + 3;
		p = q;
@


1.113
log
@Convert ssl3_get_new_session_ticket to CBS.

tweak + ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.112 2015/06/15 05:32:58 doug Exp $ */
d1818 1
a1818 2
	s->tlsext_ocsp_resp = BUF_memdup(p, resplen);
	if (!s->tlsext_ocsp_resp) {
d1824 1
@


1.112
log
@Remove ancient SSL_OP_NETSCAPE_CA_DN_BUG from SSLeay days.

This commit matches the OpenSSL removal in commit
3c33c6f6b10864355553961e638514a6d1bb00f6.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.111 2015/03/31 13:17:48 jsing Exp $ */
d151 2
d171 2
d1713 2
a1714 1
	int			 ok, al, ret = 0, ticklen;
d1716 1
a1716 2
	const unsigned char	*p;
	unsigned char		*d;
d1733 9
a1741 2
	if (n < 6) {
		/* need at least ticket_lifetime_hint + ticket length */
d1747 1
d1749 2
a1750 14
	p = d = (unsigned char *)s->init_msg;
	n2l(p, s->session->tlsext_tick_lifetime_hint);
	n2s(p, ticklen);
	/* ticket_lifetime_hint + ticket_length + ticket */
	if (ticklen + 6 != n) {
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,
		    SSL_R_LENGTH_MISMATCH);
		goto f_err;
	}
	free(s->session->tlsext_tick);
	s->session->tlsext_ticklen = 0;
	s->session->tlsext_tick = malloc(ticklen);
	if (!s->session->tlsext_tick) {
d1755 1
a1755 2
	memcpy(s->session->tlsext_tick, p, ticklen);
	s->session->tlsext_ticklen = ticklen;
d1772 3
a1774 2
	EVP_Digest(p, ticklen, s->session->session_id,
	    &s->session->session_id_length, EVP_sha256(), NULL);
@


1.111
log
@Nuke the OPENSSL_MAX_TLS1_2_CIPHER_LENGTH hack - this has to be enabled at
compile time, which we do not do and are unlikely to ever do. Additionally,
there are two runtime configurable alternatives that exist.

ok bcook@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.110 2015/03/27 12:29:54 jsing Exp $ */
a1647 2
			if ((s->options & SSL_OP_NETSCAPE_CA_DN_BUG))
				goto cont; /* netscape bugs */
d1657 5
a1661 10
			/* If netscape tolerance is on, ignore errors */
			if (s->options & SSL_OP_NETSCAPE_CA_DN_BUG)
				goto cont;
			else {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_DECODE_ERROR);
				SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,
				    ERR_R_ASN1_LIB);
				goto err;
			}
a1677 5
	}

	if (0) {
cont:
		ERR_clear_error();
@


1.110
log
@Factor out the init_buf initialisation code, rather than duplicating it
in four different places.

ok doug@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.109 2015/03/11 19:34:06 tedu Exp $ */
a712 10
#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
			/*
			 * Some servers hang if client hello > 256 bytes
			 * as hack workaround chop number of supported ciphers
			 * to keep it well below this if we use TLS v1.2
			 */
		if (TLS1_get_version(s) >= TLS1_2_VERSION &&
		    i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
			i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
#endif
@


1.109
log
@delay EVP_MD_CTX_init so we don't forget to clean it up.
spotted by miod. ok miod.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.108 2015/03/08 16:48:47 miod Exp $ */
a220 1
	BUF_MEM	*buf = NULL;
d265 3
a267 12
			if (s->init_buf == NULL) {
				if ((buf = BUF_MEM_new()) == NULL) {
					ret = -1;
					goto end;
				}
				if (!BUF_MEM_grow(buf,
				    SSL3_RT_MAX_PLAIN_LENGTH)) {
					ret = -1;
					goto end;
				}
				s->init_buf = buf;
				buf = NULL;
a268 1

a272 2

			/* setup buffing BIO */
d621 1
a623 2
	if (buf != NULL)
		BUF_MEM_free(buf);
d626 1
@


1.108
log
@Reject DH keys sent by a server if they are considered too small; inspired
by a similar BoringSSL change, but raising the limit to 1024 bits.
ok jsing@@ markus@@ guenther@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.107 2015/02/07 05:46:01 jsing Exp $ */
a1170 2
	EVP_MD_CTX_init(&md_ctx);

d1179 2
d1195 1
@


1.107
log
@Clean up the {get,put}_cipher_by_char() implementations. Also use
ssl3_get_cipher_by_value() in other parts of the code where it simplifies
things.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.106 2015/02/06 09:58:52 jsing Exp $ */
d1270 11
@


1.106
log
@Add additional checks to ssl3_send_client_key_exchange() that ensures
ephemeral keys exist for SSL_kDHE and SSL_kECDHE.

This would have prevented CVE-2014-3572.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.104 2015/01/23 14:40:59 jsing Exp $ */
d776 1
a776 1
	unsigned int		 j, cipher_id;
a846 1
	cipher_id = SSL3_CK_ID | cipher_value;
d858 2
a859 2
			s->session->cipher = pref_cipher ?
			    pref_cipher : ssl3_get_cipher_by_id(cipher_id);
d894 1
a894 2
	c = ssl3_get_cipher_by_id(cipher_id);
	if (c == NULL) {
@


1.105
log
@Bring back the horrible API that is get_cipher_by_char/put_cipher_by_char.

This API was intended to be an internal only, however like many things in
OpenSSL, it is exposed externally and parts of the software ecosystem are
now using it since there is no real alternative within the public API.

ok doug@@, tedu@@ and reluctantly miod@@
@
text
@d1971 2
a1972 4
			if (s->session->sess_cert->peer_dh_tmp != NULL)
				dh_srvr = s->session->sess_cert->peer_dh_tmp;
			else {
				/* We get them from the cert. */
d1979 1
d2059 12
a2070 3
			if (s->session->sess_cert->peer_ecdh_tmp != NULL) {
				tkey = s->session->sess_cert->peer_ecdh_tmp;
			} else {
d2074 4
a2077 8
				if ((srvr_pub_pkey == NULL) ||
				    (srvr_pub_pkey->type != EVP_PKEY_EC) ||
				    (srvr_pub_pkey->pkey.ec == NULL)) {
					SSLerr(
					    SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_INTERNAL_ERROR);
					goto err;
				}
d2079 4
a2082 1
				tkey = srvr_pub_pkey->pkey.ec;
d2324 1
a2324 1
			ERR_R_INTERNAL_ERROR);
@


1.104
log
@Ensure that a ServerKeyExchange message is received if the selected cipher
suite uses ephemeral keys. This avoids an issue where an ECHDE cipher suite can
effectively be downgraded to ECDH, if the server omits the ServerKeyExchange
message and has provided a certificate with an ECC public key.

Issue reported to OpenSSL by Karthikeyan Bhargavan.

Based on OpenSSL.

Fixes CVE-2014-3572.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.103 2014/12/15 00:46:53 doug Exp $ */
d191 2
@


1.103
log
@Add error handling for EVP_DigestInit_ex().

A few EVP_DigestInit_ex() calls were left alone since reporting an
error would change the public API.

Changed internal ssl3_cbc_digest_record() to return a value due to the above
change.  It will also now set md_out_size=0 on failure.

This is based on part of BoringSSL's commit to fix malloc crashes:
https://boringssl.googlesource.com/boringssl/+/69a01608f33ab6fe2c3485d94aef1fe9eacf5364

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.102 2014/12/14 16:19:38 jsing Exp $ */
d1168 5
d1183 11
a1197 1
	param = p = (unsigned char *)s->init_msg;
d1210 1
a1211 3
	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	alg_a = s->s3->tmp.new_cipher->algorithm_auth;
	EVP_MD_CTX_init(&md_ctx);
@


1.102
log
@Convert all of the straight forward client handshake handling code to use
the new handshake functions.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.101 2014/12/14 15:30:50 jsing Exp $ */
d1442 1
a1442 1
				EVP_DigestInit_ex(&md_ctx,
d1444 4
a1447 1
				    NULL);
d2251 2
a2252 1
			EVP_DigestInit(ukm_hash, EVP_get_digestbynid(nid));
@


1.101
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.100 2014/12/14 14:34:43 jsing Exp $ */
d645 1
a645 2
	unsigned char	*buf;
	unsigned char	*p, *d;
a646 1
	unsigned long	 l;
a647 1
	buf = (unsigned char *)s->init_buf->data;
d650 1
d662 1
a662 2
		/* Do the message type and length last */
		d = p = &buf[4];
d747 3
a749 2
		if ((p = ssl_add_clienthello_tlsext(s, p,
		    buf + SSL3_RT_MAX_PLAIN_LENGTH)) == NULL) {
d755 1
a755 4
		l = (p - d);
		d = buf;
		*(d++) = SSL3_MT_CLIENT_HELLO;
		l2n3(l, d);
d757 1
a757 4
		s->state = SSL3_ST_CW_CLNT_HELLO_B;
		/* number of bytes to write */
		s->init_num = p - buf;
		s->init_off = 0;
d761 2
a762 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
d1880 1
a1880 1
	unsigned char	*p, *d;
a1882 1
	unsigned char	*q;
d1892 1
a1892 2
		d = (unsigned char *)s->init_buf->data;
		p = &(d[4]);
d1993 2
a1994 1
			s->session->master_key, p, n);
d2294 1
a2294 2
		}
		else {
d2296 1
a2296 1
			SSL_AD_HANDSHAKE_FAILURE);
d2302 1
a2302 2
		*(d++) = SSL3_MT_CLIENT_KEY_EXCHANGE;
		l2n3(n, d);
d2304 1
a2304 4
		s->state = SSL3_ST_CW_KEY_EXCH_B;
		/* number of bytes to write */
		s->init_num = n + 4;
		s->init_off = 0;
d2308 1
a2308 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
d2321 1
a2321 1
	unsigned char	*p, *d;
d2333 2
a2334 3
		d = (unsigned char *)s->init_buf->data;
		p = &(d[4]);
		pkey = s->cert->key->privatekey;
d2339 1
a2457 2
		*(d++) = SSL3_MT_CERTIFICATE_VERIFY;
		l2n3(n, d);
d2460 2
a2461 2
		s->init_num = (int)n + 4;
		s->init_off = 0;
d2463 1
d2466 3
a2468 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
d2623 1
a2623 1
	unsigned char	*d;
d2626 2
d2630 9
a2638 7
		d = (unsigned char *)s->init_buf->data;
		d[4] = len;
		memcpy(d + 5, s->next_proto_negotiated, len);
		d[5 + len] = padding_len;
		memset(d + 6 + len, 0, padding_len);
		*(d++) = SSL3_MT_NEXT_PROTO;
		l2n3(2 + len + padding_len, d);
a2639 2
		s->init_num = 4 + 2 + len + padding_len;
		s->init_off = 0;
d2642 1
a2642 1
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
@


1.100
log
@unifdef OPENSSL_NO_NEXTPROTONEG, which is one of the last standing #ifndef
mazes in libssl. NPN is being replaced by ALPN, however it is still going
to be around for a while yet.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.99 2014/12/10 15:43:31 jsing Exp $ */
d1199 1
a1199 1
			goto err; 
@


1.99
log
@ssl3_init_finished_mac() calls BIO_new() which can fail since it in turn
calls malloc(). Instead of silently continuing on failure, check the return
value of BIO_new() and propagate failure back to the caller for appropriate
handling.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.98 2014/12/10 15:36:46 jsing Exp $ */
a467 3
#ifdef OPENSSL_NO_NEXTPROTONEG
			s->state = SSL3_ST_CW_FINISHED_A;
#else
a471 1
#endif
a487 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a494 1
#endif
a2630 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a2653 1
#endif /* !OPENSSL_NO_NEXTPROTONEG */
@


1.98
log
@Remove support for GOST R 34.10-94 signature authentication, along with
the two ciphersuites that use it. GOST94 public/private keys have been
long obsoleted and libcrypto does not have support for them anyway.

Discussed with Dmitry Eremin-Solenikov.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.97 2014/12/06 14:24:26 jsing Exp $ */
d291 4
a294 1
			ssl3_init_finished_mac(s);
@


1.97
log
@Remove client handling of RSA in ServerKeyExchange messages, along with
the associated peer_rsa_tmp goop.

This was only needed for export cipher handling and intentional RFC
violations. The export cipher suites have already been removed and
previous cleanup means that we will never send ServerKeyExchange messages
from the server side for RSA.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.96 2014/11/27 16:13:36 jsing Exp $ */
a2209 2
			if (!peer_cert)
				peer_cert = s->session->sess_cert->peer_pkeys[SSL_PKEY_GOST94].x509;
@


1.96
log
@Ensure that sess_cert is not NULL at the start of
ssl3_send_client_key_exchange(), rather than checking it in the key
exchange algorithm specific code.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.95 2014/11/19 05:51:25 doug Exp $ */
a1193 3
		RSA_free(s->session->sess_cert->peer_rsa_tmp);
		s->session->sess_cert->peer_rsa_tmp = NULL;

d1210 1
a1210 57
	if (alg_k & SSL_kRSA) {
		if ((rsa = RSA_new()) == NULL) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (2 > n)
			goto truncated;
		n2s(p, i);
		param_len = i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_RSA_MODULUS_LENGTH);
			goto f_err;
		}
		if (!(rsa->n = BN_bin2bn(p, i, rsa->n))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		p += i;

		if (param_len + 2 > n)
			goto truncated;
		n2s(p, i);
		param_len += i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_RSA_E_LENGTH);
			goto f_err;
		}
		if (!(rsa->e = BN_bin2bn(p, i, rsa->e))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		p += i;
		n -= param_len;

		/*
		 * This should be because we are using an
		 * export cipher
		 */
		if (alg_a & SSL_aRSA)
			pkey = X509_get_pubkey(
			    s->session->sess_cert->peer_pkeys[
			    SSL_PKEY_RSA_ENC].x509);
		else {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
			goto err;
		}
		s->session->sess_cert->peer_rsa_tmp = rsa;
		rsa = NULL;
	} else if (alg_k & SSL_kDHE) {
d1920 8
a1927 16
			if (s->session->sess_cert->peer_rsa_tmp != NULL)
				rsa = s->session->sess_cert->peer_rsa_tmp;
			else {
				pkey = X509_get_pubkey(
				    s->session->sess_cert->peer_pkeys[
				    SSL_PKEY_RSA_ENC].x509);
				if ((pkey == NULL) ||
				    (pkey->type != EVP_PKEY_RSA) ||
				    (pkey->pkey.rsa == NULL)) {
					SSLerr(
					    SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_INTERNAL_ERROR);
					EVP_PKEY_free(pkey);
					goto err;
				}
				rsa = pkey->pkey.rsa;
d1929 1
d1931 2
a2569 1
	RSA		*rsa;
a2584 2

	rsa = s->session->sess_cert->peer_rsa_tmp;
d2617 1
a2617 1
	    !(has_bits(i, EVP_PK_RSA|EVP_PKT_ENC) || (rsa != NULL))) {
@


1.95
log
@Fix a memory leak with pkey in client key exchange

Based on boringssl commit: 1df112448b41c3568477f3fcd3b8fc820ce80066

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.94 2014/11/18 05:33:43 miod Exp $ */
d1967 8
a1978 8
			if (s->session->sess_cert == NULL) {
				/* We should always have a server
				 * certificate with SSL_kRSA. */
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}

a2028 8
			if (s->session->sess_cert == NULL) {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_UNEXPECTED_MESSAGE);
				goto err;
			}

a2086 8

			if (s->session->sess_cert == NULL) {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_UNEXPECTED_MESSAGE);
				goto err;
			}
@


1.94
log
@Update the GOST code in libssl, as contributed by Dmitry Eremin-Solenikov.

This causes a libssl major version bump as this affects the layout of some
internal-but-unfortunately-made-visible structs.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.93 2014/11/16 14:12:47 jsing Exp $ */
d1991 1
@


1.93
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.92 2014/10/18 16:13:16 jsing Exp $ */
d165 3
d787 1
d950 3
a952 1
	if (!SSL_USE_SIGALGS(s) && !ssl3_digest_cached_records(s)) {
a1945 1

a2280 1
			int keytype;
d2285 1
d2288 1
a2288 2
			peer_cert = s->session->sess_cert->peer_pkeys[(
			    keytype = SSL_PKEY_GOST01)].x509;
d2290 1
a2290 2
				peer_cert = s->session->sess_cert->peer_pkeys[
				    (keytype = SSL_PKEY_GOST94)].x509;
d2335 6
a2340 2
			EVP_DigestInit(ukm_hash,
			    EVP_get_digestbynid(NID_id_GostR3411_94));
d2508 1
d2510 10
a2519 8
		    pkey->type == NID_id_GostR3410_2001) {
			unsigned char signbuf[64];
			int i;
			size_t sigsize = 64;
			s->method->ssl3_enc->cert_verify_mac(s,
			    NID_id_GostR3411_94, data);
			if (EVP_PKEY_sign(pctx, signbuf, &sigsize, data, 32)
			    <= 0) {
d2524 19
a2542 2
			for (i = 63, j = 0; i >= 0; j++, i--) {
				p[2 + j] = signbuf[i];
d2544 3
d2549 1
@


1.92
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.91 2014/09/27 11:01:05 jsing Exp $ */
d152 1
d154 2
d157 1
a157 1
#include <openssl/objects.h>
d160 2
a161 2
#include <openssl/dh.h>
#include <openssl/bn.h>
@


1.91
log
@Check that the specified curve is one of the client preferences.

Based on OpenSSL.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.90 2014/09/19 14:32:23 tedu Exp $ */
a153 1
#include <openssl/rand.h>
d659 1
a659 2
		p = s->s3->client_random;
		RAND_pseudo_bytes(p, SSL3_RANDOM_SIZE);
d1991 1
a1991 2
			if (RAND_bytes(&(tmp_buf[2]), sizeof tmp_buf - 2) <= 0)
				goto err;
d2303 1
a2303 1
			RAND_bytes(premaster_secret, 32);
@


1.90
log
@remove obfuscating parens. man operator is your friend.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.89 2014/09/07 12:16:23 jsing Exp $ */
d1333 1
a1334 1
		const EC_GROUP *group;
d1354 18
a1371 2
		if ((param_len > n) || (*p != NAMED_CURVE_TYPE) ||
		    ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0)) {
@


1.89
log
@Remove SSL_kDHr, SSL_kDHd and SSL_aDH. No supported ciphersuites use them,
nor do we plan on supporting them.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.88 2014/08/23 14:52:41 jsing Exp $ */
d664 1
a664 1
		d = p = &(buf[4]);
d1492 1
a1492 1
				    &(s->s3->client_random[0]),
d1495 1
a1495 1
				    &(s->s3->server_random[0]),
d1520 1
a1520 1
			EVP_VerifyUpdate(&md_ctx, &(s->s3->client_random[0]),
d1522 1
a1522 1
			EVP_VerifyUpdate(&md_ctx, &(s->s3->server_random[0]),
@


1.88
log
@Replace the remaining ssl3_get_cipher_by_char() calls with n2s() and
ssl3_get_cipher_by_id().

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.87 2014/08/11 01:10:42 jsing Exp $ */
a1331 5
	} else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd)) {
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
		    SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
		goto f_err;
d2004 1
a2004 1
		} else if (alg_k & (SSL_kDHE|SSL_kDHr|SSL_kDHd)) {
d2609 1
a2609 1
	if (alg_a & (SSL_aDH|SSL_aNULL))
a2660 8
		goto f_err;
	} else if ((alg_k & SSL_kDHr) && !has_bits(i, EVP_PK_DH|EVP_PKS_RSA)) {
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
		    SSL_R_MISSING_DH_RSA_CERT);
		goto f_err;
	} else if ((alg_k & SSL_kDHd) && !has_bits(i, EVP_PK_DH|EVP_PKS_DSA)) {
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
		    SSL_R_MISSING_DH_DSA_CERT);
@


1.87
log
@Currently, ssl3_put_char_by_bytes(NULL, NULL) is just a long handed way
of writing "2". Add a define for the SSL3_CIPHER_VALUE_SIZE (rather than
using a less-readable hardcoded constant everywhere) and replace the
ssl3_put_char_by_bytes(NULL, NULL) calls with it.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.86 2014/08/10 14:42:56 jsing Exp $ */
d778 1
a778 1
	unsigned char		*p, *d;
d780 2
a781 1
	unsigned int		 j;
d834 1
a834 1
	j= *(p++);
d847 5
d863 1
a863 1
			    pref_cipher : ssl3_get_cipher_by_char(p + j);
d894 1
a894 1
		memcpy(s->session->session_id,p,j); /* j could be 0 */
d897 2
a898 1
	c = ssl3_get_cipher_by_char(p);
d906 1
@


1.86
log
@Since we no longer need to support SSLv2-style cipher lists, start
unravelling the maze of function pointers and callbacks by directly
calling ssl3_{get,put}_cipher_by_char() and removing the
ssl_{get,put}_cipher_by_char macros.

Prompted by similar changes in boringssl.

ok guenther.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.85 2014/08/07 01:24:10 deraadt Exp $ */
d907 1
a907 1
	p += ssl3_put_cipher_by_char(NULL, NULL);
@


1.85
log
@merge CVE-2014-3510; Fix DTLS anonymous EC(DH) denial of service
https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=17160033765480453be0a41335fa6b833691c049
ok bcook
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.84 2014/07/17 11:32:21 miod Exp $ */
a185 2
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
d720 1
a720 1
		i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);
d857 1
a857 1
			    pref_cipher : ssl_get_cipher_by_char(s, p + j);
d891 1
a891 1
	c = ssl_get_cipher_by_char(s, p);
d907 1
a907 1
	p += ssl_put_cipher_by_char(s, NULL, NULL);
@


1.85.2.1
log
@backport fixes to prevent connections from being downgraded to weak keys.
ok bluhm miod
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.85 2014/08/07 01:24:10 deraadt Exp $ */
a1164 3
	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	alg_a = s->s3->tmp.new_cipher->algorithm_auth;

a1172 2
	
	EVP_MD_CTX_init(&md_ctx);
a1174 11
		/*
		 * Do not skip server key exchange if this cipher suite uses
		 * ephemeral keys.
		 */
		if (alg_k & (SSL_kDHE|SSL_kECDHE)) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_UNEXPECTED_MESSAGE);
			al = SSL_AD_UNEXPECTED_MESSAGE;
			goto f_err;
		}

a1175 1
		EVP_MD_CTX_cleanup(&md_ctx);
d1179 1
d1181 3
a1194 1
	param = p = (unsigned char *)s->init_msg;
d1196 26
d1223 34
a1256 1
	if (alg_k & SSL_kDHE) {
a1313 11
		/*
		 * Check the strength of the DH key just constructed.
		 * Discard keys weaker than 1024 bits.
		 */

		if (DH_size(dh) < 1024 / 8) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_DH_P_LENGTH);
			goto err;
		}

d1956 15
a1970 8
			pkey = X509_get_pubkey(
			    s->session->sess_cert->peer_pkeys[
			    SSL_PKEY_RSA_ENC].x509);
			if ((pkey == NULL) ||
			    (pkey->type != EVP_PKEY_RSA) ||
			    (pkey->pkey.rsa == NULL)) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
a1971 1
				goto err;
a1972 2
			rsa = pkey->pkey.rsa;
			EVP_PKEY_free(pkey);
d2601 1
d2617 2
d2651 1
a2651 1
	    !has_bits(i, EVP_PK_RSA|EVP_PKT_ENC)) {
@


1.84
log
@Missing bounds check in ssl3_get_certificate_request(), was not spotted in
1.78; reported by Ilja Van Sprundel.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.83 2014/07/12 22:33:39 jsing Exp $ */
d1947 8
@


1.83
log
@The correct name for EDH is DHE, likewise EECDH should be ECDHE.

Based on changes to OpenSSL trunk.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.82 2014/07/12 22:17:59 jsg Exp $ */
d1681 5
@


1.82
log
@remove double brackets.  fixes build with clang.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.81 2014/07/12 18:37:28 jsing Exp $ */
d1256 1
a1256 1
	} else if (alg_k & SSL_kEDH) {
d1331 1
a1331 1
	} else if (alg_k & SSL_kEECDH) {
d1990 1
a1990 1
		} else if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd)) {
d2054 1
a2054 1
		} else if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) {
d2643 1
a2643 1
	if ((alg_k & SSL_kEDH) &&
@


1.81
log
@Remove extra parenthesis.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.80 2014/07/12 18:10:21 jsing Exp $ */
d1003 1
a1003 1
	if ((s->s3->tmp.message_type == SSL3_MT_SERVER_KEY_EXCHANGE)) {
@


1.80
log
@need_cert is now always true, so remove the variable and associated
conditionals.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.79 2014/07/12 13:11:53 jsing Exp $ */
d1094 1
a1094 1
	if (pkey == NULL || EVP_PKEY_missing_parameters(pkey))) {
@


1.79
log
@Remove remnants from PSK, KRB5 and SRP.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.78 2014/07/11 22:57:25 miod Exp $ */
a996 2
	int			 need_cert = 1;

d1094 1
a1094 2
	if (need_cert && ((pkey == NULL) ||
	    EVP_PKEY_missing_parameters(pkey))) {
d1103 1
a1103 1
	if (need_cert && i < 0) {
d1111 15
a1125 24
	if (need_cert) {
		sc->peer_cert_type = i;
		CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
		/*
		 * Why would the following ever happen?
		 * We just created sc a couple of lines ago.
		 */
		if (sc->peer_pkeys[i].x509 != NULL)
			X509_free(sc->peer_pkeys[i].x509);
		sc->peer_pkeys[i].x509 = x;
		sc->peer_key = &(sc->peer_pkeys[i]);

		if (s->session->peer != NULL)
			X509_free(s->session->peer);
		CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
		s->session->peer = x;
	} else {
		sc->peer_cert_type = i;
		sc->peer_key = NULL;

		if (s->session->peer != NULL)
			X509_free(s->session->peer);
		s->session->peer = NULL;
	}
d2612 2
a2613 2
		if (ssl_check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509,
		    s) == 0) {
d2626 1
a2626 1
	/* Check that we have a certificate if we require one */
@


1.78
log
@As reported by David Ramos, most consumer of ssl_get_message() perform late
bounds check, after reading the 2-, 3- or 4-byte size of the next chunk to
process. But the size fields themselves are not checked for being entirely
contained in the buffer.

Since reading past your bounds is bad practice, and may not possible if you
are using a secure memory allocator, we need to add the necessary bounds check,
at the expense of some readability.

As a bonus, a wrong size GOST session key will now trigger an error instead of
a printf to stderr and it being handled as if it had the correct size.

Creating this diff made my eyes bleed (in the real sense); reviewing it
made guenther@@'s and beck@@'s eyes bleed too (in the literal sense).

ok guenther@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.77 2014/07/11 15:44:53 miod Exp $ */
d342 1
a342 1
			/* Check if it is anon DH/ECDH or PSK */
d344 1
a344 3
			    SSL_aNULL) &&
			    !(s->s3->tmp.new_cipher->algorithm_mkey &
			    SSL_kPSK)) {
a996 1
	/* VRS: 0=> will allow null cert if auth == KRB5 */
d1005 1
a1005 3
	if ((s->s3->tmp.message_type == SSL3_MT_SERVER_KEY_EXCHANGE) ||
	    ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) &&
	    (s->s3->tmp.message_type == SSL3_MT_SERVER_DONE))) {
a1095 6
	/* VRS: allow null cert if auth == KRB5 */
	need_cert = ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5) &&
	    (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
	    ? 0 : 1;


d1545 2
a1546 2
		/* aNULL or kPSK do not need public keys */
		if (!(alg_a & SSL_aNULL) && !(alg_k & SSL_kPSK)) {
d2607 1
a2607 1
	if ((alg_a & (SSL_aDH|SSL_aNULL|SSL_aKRB5)) || (alg_k & SSL_kPSK))
@


1.77
log
@If the application uses tls_session_secret_cb for session resumption, set
the CCS_OK flag. From OpenSSL trunk.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.76 2014/07/11 13:21:15 miod Exp $ */
d817 2
d828 4
d847 3
d947 2
d972 2
a973 7
	if (p != (d + n)) {
		/* wrong packet length */
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_BAD_PACKET_LENGTH);
		goto f_err;
	}
d976 5
d1029 2
d1039 2
d1112 1
a1112 1
		SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);
d1121 1
a1121 1
		SSL_R_UNKNOWN_CERTIFICATE_TYPE);
d1155 5
d1229 2
d1246 2
d1285 2
d1302 2
d1319 2
d1409 2
d1470 2
d1490 2
d1496 1
a1496 1
		if ((i != n) || (n > j) || (n <= 0)) {
d1573 4
d1649 2
d1654 6
d1664 5
d1689 5
d1759 5
@


1.76
log
@Accept CCS again after `finished' has been sent by the client; at this point
keys have been correctly set up so it is ok to accept CCS from the server.
Without renegotiation can sometimes fail.

OpenSSL PR #3400 via OpenSSL trunk.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.75 2014/07/11 09:24:44 beck Exp $ */
d852 2
a853 1
			pref_cipher : ssl_get_cipher_by_char(s, p + j);
@


1.75
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.74 2014/07/10 08:51:14 tedu Exp $ */
d500 4
a503 4
			ret = ssl3_send_finished(s,
			SSL3_ST_CW_FINISHED_A, SSL3_ST_CW_FINISHED_B,
			s->method->ssl3_enc->client_finished_label,
			s->method->ssl3_enc->client_finished_label_len);
d506 1
@


1.74
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.73 2014/07/09 11:25:42 jsing Exp $ */
a1175 14
#ifndef OPENSSL_NO_PSK
		/*
		 * In plain PSK ciphersuite, ServerKeyExchange can be
		 * omitted if no identity hint is sent. Set session->sess_cert
		 * anyway to avoid problems later.
		 */
		if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK) {
			s->session->sess_cert = ssl_sess_cert_new();
			if (s->session->sess_cert == NULL)
				goto err; 
			free(s->ctx->psk_identity_hint);
			s->ctx->psk_identity_hint = NULL;
		}
#endif
a1200 44
#ifndef OPENSSL_NO_PSK
	if (alg_k & SSL_kPSK) {
		char tmp_id_hint[PSK_MAX_IDENTITY_LEN + 1];

		al = SSL_AD_HANDSHAKE_FAILURE;
		n2s(p, i);
		param_len = i + 2;
		/*
		 * Store PSK identity hint for later use, hint is used
		 * in ssl3_send_client_key_exchange.  Assume that the
		 * maximum length of a PSK identity hint can be as
		 * long as the maximum length of a PSK identity.
		 */
		if (i > PSK_MAX_IDENTITY_LEN) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_DATA_LENGTH_TOO_LONG);
			goto f_err;
		}
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);
			goto f_err;
		}
		/*
		 * If received PSK identity hint contains NULL
		 * characters, the hint is truncated from the first
		 * NULL. p may not be ending with NULL, so create a
		 * NULL-terminated string.
		 */
		memcpy(tmp_id_hint, p, i);
		memset(tmp_id_hint + i, 0, PSK_MAX_IDENTITY_LEN + 1 - i);
		free(s->ctx->psk_identity_hint);
		s->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);
		if (s->ctx->psk_identity_hint == NULL) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_MALLOC_FAILURE);
			goto f_err;
		}

		p += i;
		n -= param_len;
	} else
#endif /* !OPENSSL_NO_PSK */
a2307 77
#ifndef OPENSSL_NO_PSK
		else if (alg_k & SSL_kPSK) {
			char identity[PSK_MAX_IDENTITY_LEN];
			unsigned char *t = NULL;
			unsigned char psk_or_pre_ms[PSK_MAX_PSK_LEN*2 + 4];
			unsigned int pre_ms_len = 0, psk_len = 0;
			int psk_err = 1;

			n = 0;
			if (s->psk_client_callback == NULL) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_PSK_NO_CLIENT_CB);
				goto err;
			}

			psk_len = s->psk_client_callback(s,
			    s->ctx->psk_identity_hint, identity,
			    PSK_MAX_IDENTITY_LEN, psk_or_pre_ms,
			    sizeof(psk_or_pre_ms));
			if (psk_len > PSK_MAX_PSK_LEN) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto psk_err;
			} else if (psk_len == 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_PSK_IDENTITY_NOT_FOUND);
				goto psk_err;
			}

			/* create PSK pre_master_secret */
			pre_ms_len = 2 + psk_len + 2 + psk_len;
			t = psk_or_pre_ms;
			memmove(psk_or_pre_ms + psk_len + 4,
			    psk_or_pre_ms, psk_len);
			s2n(psk_len, t);
			memset(t, 0, psk_len);
			t += psk_len;
			s2n(psk_len, t);

			free(s->session->psk_identity_hint);
			s->session->psk_identity_hint =
			    BUF_strdup(s->ctx->psk_identity_hint);
			if (s->ctx->psk_identity_hint != NULL &&
			    s->session->psk_identity_hint == NULL) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto psk_err;
			}

			free(s->session->psk_identity);
			s->session->psk_identity = BUF_strdup(identity);
			if (s->session->psk_identity == NULL) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto psk_err;
			}

			s->session->master_key_length =
			    s->method->ssl3_enc->generate_master_secret(
			    s, s->session->master_key, psk_or_pre_ms,
			    pre_ms_len);

			n = strlen(identity);
			s2n(n, p);
			memcpy(p, identity, n);
			n += 2;
			psk_err = 0;
psk_err:
			OPENSSL_cleanse(identity, PSK_MAX_IDENTITY_LEN);
			OPENSSL_cleanse(psk_or_pre_ms, sizeof(psk_or_pre_ms));
			if (psk_err != 0) {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_HANDSHAKE_FAILURE);
				goto err;
			}
		}
#endif
@


1.73
log
@tedu the SSL export cipher handling - since we do not have enabled export
ciphers we no longer need the flags or code to support it.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.72 2014/06/21 20:27:25 tedu Exp $ */
a474 9
#ifdef OPENSSL_NO_COMP
			s->session->compress_meth = 0;
#else
			if (s->s3->tmp.new_compression == NULL)
				s->session->compress_meth = 0;
			else
				s->session->compress_meth =
				    s->s3->tmp.new_compression->id;
#endif
a649 4
#ifndef OPENSSL_NO_COMP
	int		 j;
	SSL_COMP	 *comp;
#endif
d742 1
a742 2
		/* COMPRESSION */
#ifdef OPENSSL_NO_COMP
a743 13
#else

		if ((s->options & SSL_OP_NO_COMPRESSION) ||
		    !s->ctx->comp_methods)
			j = 0;
		else
			j = sk_SSL_COMP_num(s->ctx->comp_methods);
		*(p++) = 1 + j;
		for (i = 0; i < j; i++) {
			comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);
			*(p++) = comp->id;
		}
#endif
a784 3
#ifndef OPENSSL_NO_COMP
	SSL_COMP		*comp;
#endif
a935 1
#ifdef OPENSSL_NO_COMP
a941 37
	/*
	 * If compression is disabled we'd better not try to resume a session
	 * using compression.
	 */
	if (s->session->compress_meth != 0) {
		al = SSL_AD_INTERNAL_ERROR;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_INCONSISTENT_COMPRESSION);
		goto f_err;
	}
#else
	j= *(p++);
	if (s->hit && j != s->session->compress_meth) {
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);
		goto f_err;
	}
	if (j == 0)
		comp = NULL;
	else if (s->options & SSL_OP_NO_COMPRESSION) {
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_COMPRESSION_DISABLED);
		goto f_err;
	} else
		comp = ssl3_comp_find(s->ctx->comp_methods, j);

	if ((j != 0) && (comp == NULL)) {
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
		goto f_err;
	} else {
		s->s3->tmp.new_compression = comp;
	}
#endif
@


1.72
log
@always compare memcmp against 0, for clarity.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.71 2014/06/19 21:29:51 tedu Exp $ */
a1492 8
		if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
		    (EC_GROUP_get_degree(group) > 163)) {
			al = SSL_AD_EXPORT_RESTRICTION;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
			goto f_err;
		}

a2818 22
	if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
	    !has_bits(i, EVP_PKT_EXP)) {
		if (alg_k & SSL_kRSA) {
			if (rsa == NULL || RSA_size(rsa) * 8 >
			    SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)) {
				SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
				    SSL_R_MISSING_EXPORT_TMP_RSA_KEY);
				goto f_err;
			}
		} else if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd)) {
			if (dh == NULL || DH_size(dh) * 8 >
			    SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)) {
				SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
				    SSL_R_MISSING_EXPORT_TMP_DH_KEY);
				goto f_err;
			}
		} else {
			SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
			    SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
			goto f_err;
		}
	}
@


1.71
log
@convert CRYPTO_memcmp to timingsafe_memcmp based on current policy favoring
libc interfaces over libcrypto interfaces. for now we also prefer
timingsafe_memcmp over timingsafe_bcmp, even when the latter is acceptable.
ok beck deraadt matthew miod
@
text
@d1 1
a1 1
/* $OpenBSD: s3_clnt.c,v 1.70 2014/06/12 15:49:31 deraadt Exp $ */
d889 1
a889 1
		    s->sid_ctx, s->sid_ctx_length)) {
@


1.70
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d886 1
a886 1
	    CRYPTO_memcmp(p, s->session->session_id, j) == 0) {
d888 1
a888 1
		    CRYPTO_memcmp(s->session->sid_ctx,
@


1.69
log
@Stop setting the EVP_MD_CTX_FLAG_NON_FIPS_ALLOW - it has been ignored since
OpenSSL 1.0.0.

ok miod@@ (a little while back)
@
text
@d1 1
a1 1
/* ssl/s3_clnt.c */
@


1.68
log
@http://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2016265dfbab162ec30718b5e7480add42598158
Don't know the full story, but it looks like a "can't do random
perfectly, so do it god awful" problem was found in 2013, and
replaced with "only do it badly if a flag is set".  New flags
(SSL_MODE_SEND_SERVERHELLO_TIME and SSL_MODE_SEND_SERVERHELLO_TIME)
were added [Ben Laurie?] to support the old scheme of "use time_t
for first 4 bytes of the random buffer".

Nothing uses these flags [ecosystem scan by sthen]

Fully discourage use of these flags in the future by removing
support & definition of them.  The buflen < 4 check is also interesting,
because no entropy would be returned.  No callers passed such small
buffers.
ok miod sthen
@
text
@a1605 2
				EVP_MD_CTX_set_flags(&md_ctx,
				EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
@


1.67
log
@The DH_free, EC_KEY_free, EVP_PKEY_free and RSA_free functions all have
implicit NULL checks, so there is no point ensuring that the pointer is
non-NULL before calling them.
@
text
@d677 1
a677 3

		if (ssl_fill_hello_random(s, 0, p, SSL3_RANDOM_SIZE) <= 0)
			goto err;
@


1.66
log
@Ensure that sess_cert is not NULL before trying to use it.

Fixes CVE-2014-3470, from OpenSSL.

ok deraadt@@
@
text
@d1677 2
a1678 4
	if (rsa != NULL)
		RSA_free(rsa);
	if (dh != NULL)
		DH_free(dh);
d1681 1
a1681 2
	if (ecdh != NULL)
		EC_KEY_free(ecdh);
d2333 1
a2333 2
			if (clnt_ecdh != NULL)
				EC_KEY_free(clnt_ecdh);
d2443 1
a2443 1
			    EVP_PKEY_free(pub_key);
d2542 1
d2546 1
a2546 2
	if (clnt_ecdh != NULL)
		EC_KEY_free(clnt_ecdh);
d2725 1
a2725 2
		if (pkey != NULL)
			EVP_PKEY_free(pkey);
@


1.65
log
@ssl_sess_cert_new() can return NULL. Fix two cases where the return value
is unchecked, which would result in a later null pointer dereference.

While here, RSA_free, DH_free and EC_KEY_free all have implicit NULL
checks, so avoid repeating them here.

ok beck@@
@
text
@d2159 8
@


1.64
log
@Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret.

For a detailed analysis see:

  https://www.imperialviolet.org/2014/06/05/earlyccs.html

This is a fix for CVE-2014-0224, from OpenSSL.

This issue was reported to OpenSSL by KIKUCHI Masashi. Unfortunately the
recent OpenSSL commit was the first we were made aware of the issue.

ok deraadt@@ sthen@@
@
text
@a1138 1

d1254 2
d1266 8
a1273 12
		if (s->session->sess_cert->peer_rsa_tmp != NULL) {
			RSA_free(s->session->sess_cert->peer_rsa_tmp);
			s->session->sess_cert->peer_rsa_tmp = NULL;
		}
		if (s->session->sess_cert->peer_dh_tmp) {
			DH_free(s->session->sess_cert->peer_dh_tmp);
			s->session->sess_cert->peer_dh_tmp = NULL;
		}
		if (s->session->sess_cert->peer_ecdh_tmp) {
			EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
			s->session->sess_cert->peer_ecdh_tmp = NULL;
		}
d1276 2
@


1.63
log
@More KNF.
@
text
@d559 1
a559 1

d898 1
@


1.62
log
@without overthinking it, replace a few memcmp calls with CRYPTO_memcmp
where it is feasible to do so. better safe than sorry.
@
text
@d829 2
a830 3
			}
			else /* already sent a cookie */
			{
d846 1
a846 1
	d = p=(unsigned char *)s->init_msg;
d849 2
a850 3
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
		    SSL_R_WRONG_SSL_VERSION);
		s->version = (s->version&0xff00)|p[1];
d899 2
a900 1
	} else	{ /* a miss or crap from the other end */
d1126 1
a1126 2
	if ((s->verify_mode != SSL_VERIFY_NONE) && (i <= 0)
	    ) {
d1739 1
a1739 1
	p = d=(unsigned char *)s->init_msg;
d2009 1
a2009 2
		SSLerr(SSL_F_SSL3_GET_SERVER_DONE,
		    SSL_R_LENGTH_MISMATCH);
d2089 1
a2089 2
		}
		else if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd)) {
d2153 1
a2153 3
		}

		else if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) {
d2331 1
a2331 2
		}
		else if (alg_k & SSL_kGOST) {
d2350 1
a2350 1
			if (!peer_cert)	{
d2606 1
a2606 2
		} else
		if (pkey->type == EVP_PKEY_RSA) {
d2618 1
a2618 2
		} else
		if (pkey->type == EVP_PKEY_DSA) {
d2629 1
a2629 2
		} else
		if (pkey->type == EVP_PKEY_EC) {
d2640 1
a2640 2
		} else
		if (pkey->type == NID_id_GostR3410_94 ||
d2783 2
a2784 2
		    s) == 0)
			{ /* check failed */
a2795 1

d2801 2
a2802 2
	}
	else if ((alg_a & SSL_aDSS) && !has_bits(i, EVP_PK_DSA|EVP_PKT_SIGN)) {
d2822 1
a2822 2
	}
	else if ((alg_k & SSL_kDHd) && !has_bits(i, EVP_PK_DH|EVP_PKS_DSA)) {
d2837 3
a2839 12
		} else
			if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd)) {
				if (dh == NULL || DH_size(dh) * 8 >
				    SSL_C_EXPORT_PKEYLENGTH(
				    s->s3->tmp.new_cipher)) {
					SSLerr(
					    SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
					    SSL_R_MISSING_EXPORT_TMP_DH_KEY);
					goto f_err;
				}
			} else
			{
d2841 1
a2841 1
				    SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
d2844 5
@


1.61
log
@More manual OPENSSL_NO_EC and OPENSSL_NO_TLSEXT cleanup.
@
text
@d890 1
a890 1
	    memcmp(p, s->session->session_id, j) == 0) {
d892 1
a892 1
		    memcmp(s->session->sid_ctx,
@


1.60
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@d464 1
a464 1
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
d497 1
a497 1
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
d2874 1
a2874 1
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
d2898 1
a2898 1
#endif  /* !OPENSSL_NO_TLSEXT && !OPENSSL_NO_NEXTPROTONEG */
@


1.59
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@a318 1
#ifndef OPENSSL_NO_TLSEXT
a322 1
#endif
a329 1
#ifndef OPENSSL_NO_TLSEXT
a341 1
#endif
a349 1
#ifndef OPENSSL_NO_TLSEXT
a357 6
#else
			} else
				skip = 1;

			s->state = SSL3_ST_CR_KEY_EXCH_A;
#endif
a527 1
#ifndef OPENSSL_NO_TLSEXT
a532 1
#endif
a538 1
#ifndef OPENSSL_NO_TLSEXT
a555 1
#endif
a668 3
#ifdef OPENSSL_NO_TLSEXT
		    !sess->session_id_length ||
#else
a669 1
#endif
a774 1
#ifndef OPENSSL_NO_TLSEXT
a786 1
#endif
a873 1
#ifndef OPENSSL_NO_TLSEXT
a887 1
#endif /* OPENSSL_NO_TLSEXT */
a1012 1
#ifndef OPENSSL_NO_TLSEXT
a1027 1
#endif
a1853 1
#ifndef OPENSSL_NO_TLSEXT
a1994 1
#endif
a2905 1
#ifndef OPENSSL_NO_TLSEXT
a2927 1
#endif
@


1.58
log
@Make use of SSL_IS_DTLS, SSL_USE_EXPLICIT_IV, SSL_USE_SIGALGS and
SSL_USE_TLS1_2_CIPHERS.

Largely based on OpenSSL head.
@
text
@a732 5
#if 0
		*(p++) = s->version >> 8;
		*(p++) = s->version&0xff;
		s->client_version = s->version;
#else
a734 1
#endif
@


1.57
log
@no space before label
@
text
@d851 1
a851 2
	if (SSL_version(s) == DTLS1_VERSION ||
	    SSL_version(s) == DTLS1_BAD_VER) {
d988 1
a988 1
	 * Don't digest cached records if TLS v1.2: we may need them for
d991 1
a991 2
	if (TLS1_get_version(s) < TLS1_2_VERSION &&
	    !ssl3_digest_cached_records(s)) {
d1593 1
a1593 1
		if (TLS1_get_version(s) >= TLS1_2_VERSION) {
d1635 1
a1635 2
		if (pkey->type == EVP_PKEY_RSA &&
		    TLS1_get_version(s) < TLS1_2_VERSION) {
d1787 1
a1787 1
	if (TLS1_get_version(s) >= TLS1_2_VERSION) {
d2612 1
a2612 1
			if (TLS1_get_version(s) < TLS1_2_VERSION)
d2622 1
a2622 1
		if (TLS1_get_version(s) >= TLS1_2_VERSION) {
@


1.56
log
@line up else better
@
text
@d657 1
a657 1
 end:
d828 1
a828 1
 err:
d1071 1
a1071 1
 f_err:
d1073 1
a1073 1
 err:
d1243 1
a1243 1
 f_err:
d1246 1
a1246 1
 err:
d1709 1
a1709 1
 f_err:
d1711 1
a1711 1
 err:
d1863 1
a1863 1
 cont:
d1876 1
a1876 1
 err:
d1960 1
a1960 1
 f_err:
d1962 1
a1962 1
 err:
d2026 1
a2026 1
 f_err:
d2552 1
a2552 1
 psk_err:
d2581 1
a2581 1
 err:
d2720 1
a2720 1
 err:
d2904 1
a2904 1
 f_err:
d2906 1
a2906 1
 err:
@


1.55
log
@unidef DH, ECDH, and ECDSA. there's no purpose to a libssl without them.
ok deraadt jsing
@
text
@d1416 1
a1416 2
	}
	else if (alg_k & SSL_kEDH) {
d1485 1
a1485 3
	}

	else if (alg_k & SSL_kEECDH) {
@


1.54
log
@EVP_MD_CTX_create() calls malloc and can return NULL. However, only one of
the calls in libssl actually checks the return value before using it. Add
NULL checks for the remaining three calls.

ok miod@@
@
text
@a157 1
#ifndef OPENSSL_NO_DH
a158 1
#endif
a1263 1
#ifndef OPENSSL_NO_DH
a1264 2
#endif
#ifndef OPENSSL_NO_ECDH
a1269 1
#endif
a1302 1
#ifndef OPENSSL_NO_DH
a1306 2
#endif
#ifndef OPENSSL_NO_ECDH
a1310 1
#endif
a1416 1
#ifndef OPENSSL_NO_DH
a1486 1
#endif /* !OPENSSL_NO_DH */
a1487 1
#ifndef OPENSSL_NO_ECDH
a1574 1
#ifndef OPENSSL_NO_ECDSA
a1578 1
#endif
a1592 1
#endif /* !OPENSSL_NO_ECDH */
a1717 1
#ifndef OPENSSL_NO_DH
a1719 2
#endif
#ifndef OPENSSL_NO_ECDH
a1723 1
#endif
a2066 1
#ifndef OPENSSL_NO_ECDH
a2072 1
#endif
a2131 1
#ifndef OPENSSL_NO_DH
a2196 1
#endif
a2197 1
#ifndef OPENSSL_NO_ECDH
a2376 1
#endif /* !OPENSSL_NO_ECDH */
a2584 1
#ifndef OPENSSL_NO_ECDH
a2589 1
#endif
a2677 1
#ifndef OPENSSL_NO_ECDSA
a2689 1
#endif
a2808 1
#ifndef OPENSSL_NO_DH
a2809 1
#endif
a2825 1
#ifndef OPENSSL_NO_DH
a2826 1
#endif
a2830 1
#ifndef OPENSSL_NO_ECDH
a2841 1
#endif
a2863 1
#ifndef OPENSSL_NO_DH
a2878 1
#endif
a2889 1
#ifndef OPENSSL_NO_DH
a2899 1
#endif
@


1.53
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@d2461 5
@


1.52
log
@Remove TLS_DEBUG, SSL_DEBUG, CIPHER_DEBUG and OPENSSL_RI_DEBUG. Much of
this is sporadic, hacked up and can easily be put back in an improved form
should we ever need it.

ok miod@@
@
text
@d1295 1
a1295 2
			if (s->ctx->psk_identity_hint)
				free(s->ctx->psk_identity_hint);
d1362 1
a1362 2
		if (s->ctx->psk_identity_hint != NULL)
			free(s->ctx->psk_identity_hint);
d1953 2
a1954 4
	if (s->session->tlsext_tick) {
		free(s->session->tlsext_tick);
		s->session->tlsext_ticklen = 0;
	}
d2023 1
a2023 2
	if (s->tlsext_ocsp_resp)
		free(s->tlsext_ocsp_resp);
d2397 1
a2397 2
			if (encodedPoint != NULL)
				free(encodedPoint);
d2548 1
a2548 2
			if (s->session->psk_identity_hint != NULL)
				free(s->session->psk_identity_hint);
d2558 1
a2558 2
			if (s->session->psk_identity != NULL)
				free(s->session->psk_identity);
d2608 1
a2608 2
	if (encodedPoint != NULL)
		free(encodedPoint);
@


1.51
log
@DeIMPLEMENT libssl. Expand the IMPLEMENT_* macros since it is far more
readable and one less layer of abstraction. Use C99 initialisers for
clarity, grepability and to protect from future field reordering/removal.

ok miod@@ (tedu@@ also thought it was a wonderful idea, beck@@ also agreed,
but ran away squealing since it reminded him of the VOP layer...)
@
text
@a1640 4
#ifdef SSL_DEBUG
			fprintf(stderr, "USING TLSv1.2 HASH %s\n",
			    EVP_MD_name(md));
#endif
a2672 4
#ifdef SSL_DEBUG
			fprintf(stderr, "Using TLS 1.2 with client alg %s\n",
			EVP_MD_name(md));
#endif
@


1.50
log
@Stop including kssl_lcl.h and nuke it from orbit - it is a no-op now.

ok beck@@ miod@@
@
text
@d169 38
a213 3

IMPLEMENT_ssl3_meth_func(SSLv3_client_method,
    ssl_undefined_function, ssl3_connect, ssl3_get_client_method)
@


1.49
log
@KSSL is dead... nuke KSSL_DEBUG from orbit.

ok beck@@ miod@@
@
text
@a152 1
#include "kssl_lcl.h"
@


1.48
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@a1161 7
#ifdef KSSL_DEBUG
	printf("pkey, x = %p, %p\n", pkey, x);
	printf("ssl_cert_type(x, pkey) = %d\n", ssl_cert_type(x, pkey));
	printf("cipher, alg, nc = %s, %lx, %lx, %d\n",
	    s->s3->tmp.new_cipher->name, s->s3->tmp.new_cipher->algorithm_mkey,
	    s->s3->tmp.new_cipher->algorithm_auth, need_cert);
#endif    /* KSSL_DEBUG */
@


1.47
log
@Fix indentation.
@
text
@a371 11
#ifndef OPENSSL_NO_SRP
			if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) {
				if ((ret = SRP_Calc_A_param(s)) <= 0) {
					SSLerr(SSL_F_SSL3_CONNECT,
					    SSL_R_SRP_A_CALC);
					ssl3_send_alert(s, SSL3_AL_FATAL,
					    SSL_AD_INTERNAL_ERROR);
					goto end;
				}
			}
#endif
a1128 4
#ifndef OPENSSL_NO_KRB5
	    && !((s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5) &&
	    (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
#endif /* OPENSSL_NO_KRB5 */
a1348 75
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP) {
		n2s(p, i);
		param_len = i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_SRP_N_LENGTH);
			goto f_err;
		}
		if (!(s->srp_ctx.N = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		p += i;

		n2s(p, i);
		param_len += i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_SRP_G_LENGTH);
			goto f_err;
		}
		if (!(s->srp_ctx.g = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		p += i;

		i = (unsigned int)(p[0]);
		p++;
		param_len += i + 1;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_SRP_S_LENGTH);
			goto f_err;
		}
		if (!(s->srp_ctx.s = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		p += i;

		n2s(p, i);
		param_len += i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_BAD_SRP_B_LENGTH);
			goto f_err;
		}
		if (!(s->srp_ctx.B = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    ERR_R_BN_LIB);
			goto err;
		}
		p += i;
		n -= param_len;

		/* We must check if there is a certificate */
		if (alg_a & SSL_aRSA)
			pkey = X509_get_pubkey(
			    s->session->sess_cert->peer_pkeys[
			    SSL_PKEY_RSA_ENC].x509);
		else if (alg_a & SSL_aDSS)
			pkey = X509_get_pubkey(
			    s->session->sess_cert->peer_pkeys[
			    SSL_PKEY_DSA_SIGN].x509);
	} else
#endif /* !OPENSSL_NO_SRP */
a2068 3
#ifndef OPENSSL_NO_KRB5
	KSSL_ERR	 kssl_err;
#endif /* OPENSSL_NO_KRB5 */
a2135 134
#ifndef OPENSSL_NO_KRB5
		else if (alg_k & SSL_kKRB5) {
			krb5_error_code	krb5rc;
			KSSL_CTX	*kssl_ctx = s->kssl_ctx;
			/*  krb5_data	krb5_ap_req;  */
			krb5_data	*enc_ticket;
			krb5_data	authenticator, *authp = NULL;
			EVP_CIPHER_CTX	ciph_ctx;
			const EVP_CIPHER *enc = NULL;
			unsigned char	iv[EVP_MAX_IV_LENGTH];
			unsigned char	tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
			unsigned char	epms[SSL_MAX_MASTER_KEY_LENGTH
					    + EVP_MAX_IV_LENGTH];
			int		padl, outl = sizeof(epms);

			EVP_CIPHER_CTX_init(&ciph_ctx);

#ifdef KSSL_DEBUG
			printf("ssl3_send_client_key_exchange(%lx & %lx)\n",
			    alg_k, SSL_kKRB5);
#endif	/* KSSL_DEBUG */

			authp = NULL;
#ifdef KRB5SENDAUTH
			if (KRB5SENDAUTH)
				authp = &authenticator;
#endif	/* KRB5SENDAUTH */

			krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket,
			    authp, &kssl_err);
			enc = kssl_map_enc(kssl_ctx->enctype);
			if (enc == NULL)
				goto err;
#ifdef KSSL_DEBUG
			{
				printf("kssl_cget_tkt rtn %d\n", krb5rc);
				if (krb5rc && kssl_err.text)
					printf("kssl_cget_tkt kssl_err=%s\n",
					    kssl_err.text);
			}
#endif	/* KSSL_DEBUG */

			if (krb5rc) {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_HANDSHAKE_FAILURE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    kssl_err.reason);
				goto err;
			}

			/*
			 * 20010406 VRS - Earlier versions used KRB5 AP_REQ
			 * in place of RFC 2712 KerberosWrapper, as in:
			 *
			 * Send ticket (copy to *p, set n = length)
			 * n = krb5_ap_req.length;
			 * memcpy(p, krb5_ap_req.data, krb5_ap_req.length);
			 * if (krb5_ap_req.data)
			 *   kssl_krb5_free_data_contents(NULL,&krb5_ap_req);
			 *
			 * Now using real RFC 2712 KerberosWrapper
			 * (Thanks to Simon Wilkinson <sxw@@sxw.org.uk>)
			 * Note: 2712 "opaque" types are here replaced
			 * with a 2-byte length followed by the value.
			 * Example:
			 * KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms
			 * Where "xx xx" = length bytes.  Shown here with
			 * optional authenticator omitted.
			 */

			/*  KerberosWrapper.Ticket */
			s2n(enc_ticket->length, p);
			memcpy(p, enc_ticket->data, enc_ticket->length);
			p += enc_ticket->length;
			n = enc_ticket->length + 2;

			/*  KerberosWrapper.Authenticator */
			if (authp && authp->length) {
				s2n(authp->length, p);
				memcpy(p, authp->data, authp->length);
				p += authp->length;
				n += authp->length + 2;

				free(authp->data);
				authp->data = NULL;
				authp->length = 0;
			} else {
				s2n(0,p);/*  null authenticator length	*/
				n += 2;
			}

			tmp_buf[0] = s->client_version >> 8;
			tmp_buf[1] = s->client_version & 0xff;
			if (RAND_bytes(&(tmp_buf[2]), sizeof tmp_buf - 2) <= 0)
				goto err;

			/*
			 * 20010420 VRS.  Tried it this way; failed.
			 * EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,NULL);
			 * EVP_CIPHER_CTX_set_key_length(&ciph_ctx,
			 *     kssl_ctx->length);
			 * EVP_EncryptInit_ex(&ciph_ctx,NULL, key,iv);
			 */

			memset(iv, 0, sizeof iv);
			/* per RFC 1510 */
			EVP_EncryptInit_ex(&ciph_ctx, enc, NULL,
			    kssl_ctx->key, iv);
			EVP_EncryptUpdate(&ciph_ctx, epms, &outl, tmp_buf,
			    sizeof tmp_buf);
			EVP_EncryptFinal_ex(&ciph_ctx, &(epms[outl]), &padl);
			outl += padl;
			if (outl > (int)sizeof epms) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			EVP_CIPHER_CTX_cleanup(&ciph_ctx);

			/* KerberosWrapper.EncryptedPreMasterSecret */
			s2n(outl, p);
			memcpy(p, epms, outl);
			p += outl;
			n += outl + 2;

			s->session->master_key_length =
			s->method->ssl3_enc->generate_master_secret(s,
			s->session->master_key,
			tmp_buf, sizeof tmp_buf);

			OPENSSL_cleanse(tmp_buf, sizeof tmp_buf);
			OPENSSL_cleanse(epms, outl);
		}
#endif
a2491 31
#ifndef OPENSSL_NO_SRP
		else if (alg_k & SSL_kSRP) {
			if (s->srp_ctx.A != NULL) {
				/* send off the data */
				n = BN_num_bytes(s->srp_ctx.A);
				s2n(n, p);
				BN_bn2bin(s->srp_ctx.A, p);
				n += 2;
			} else {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			if (s->session->srp_username != NULL)
				free(s->session->srp_username);
			s->session->srp_username = BUF_strdup(s->srp_ctx.login);
			if (s->session->srp_username == NULL) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}

			if ((s->session->master_key_length =
			    SRP_generate_client_master_secret(s,
			    s->session->master_key)) < 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
		}
#endif
@


1.46
log
@Make it compile again.
@
text
@d1439 33
a1471 52
		if (alg_k & SSL_kRSA) {
			if ((rsa = RSA_new()) == NULL) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}
			n2s(p, i);
			param_len = i + 2;
			if (param_len > n) {
				al = SSL_AD_DECODE_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_BAD_RSA_MODULUS_LENGTH);
				goto f_err;
			}
			if (!(rsa->n = BN_bin2bn(p, i, rsa->n))) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_BN_LIB);
				goto err;
			}
			p += i;

			n2s(p, i);
			param_len += i + 2;
			if (param_len > n) {
				al = SSL_AD_DECODE_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_BAD_RSA_E_LENGTH);
				goto f_err;
			}
			if (!(rsa->e = BN_bin2bn(p, i, rsa->e))) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_BN_LIB);
				goto err;
			}
			p += i;
			n -= param_len;

			/*
			 * This should be because we are using an
			 * export cipher
			 */
			if (alg_a & SSL_aRSA)
				pkey = X509_get_pubkey(
				    s->session->sess_cert->peer_pkeys[
				    SSL_PKEY_RSA_ENC].x509);
			else {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
			s->session->sess_cert->peer_rsa_tmp = rsa;
			rsa = NULL;
d1473 19
d1493 2
a1494 66
		else if (alg_k & SSL_kEDH) {
			if ((dh = DH_new()) == NULL) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_DH_LIB);
				goto err;
			}
			n2s(p, i);
			param_len = i + 2;
			if (param_len > n) {
				al = SSL_AD_DECODE_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_BAD_DH_P_LENGTH);
				goto f_err;
			}
			if (!(dh->p = BN_bin2bn(p, i, NULL))) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_BN_LIB);
				goto err;
			}
			p += i;

			n2s(p, i);
			param_len += i + 2;
			if (param_len > n) {
				al = SSL_AD_DECODE_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_BAD_DH_G_LENGTH);
				goto f_err;
			}
			if (!(dh->g = BN_bin2bn(p, i, NULL))) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_BN_LIB);
				goto err;
			}
			p += i;

			n2s(p, i);
			param_len += i + 2;
			if (param_len > n) {
				al = SSL_AD_DECODE_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_BAD_DH_PUB_KEY_LENGTH);
				goto f_err;
			}
			if (!(dh->pub_key = BN_bin2bn(p, i, NULL))) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_BN_LIB);
				goto err;
			}
			p += i;
			n -= param_len;

			if (alg_a & SSL_aRSA)
				pkey = X509_get_pubkey(
				    s->session->sess_cert->peer_pkeys[
				    SSL_PKEY_RSA_ENC].x509);
			else if (alg_a & SSL_aDSS)
				pkey = X509_get_pubkey(
				    s->session->sess_cert->peer_pkeys[
				    SSL_PKEY_DSA_SIGN].x509);
			/* else anonymous DH, so no certificate or pkey. */

			s->session->sess_cert->peer_dh_tmp = dh;
			dh = NULL;
		} else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd)) {
			al = SSL_AD_ILLEGAL_PARAMETER;
d1496 24
a1519 1
			    SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
d1522 41
d1566 87
a1652 90
		else if (alg_k & SSL_kEECDH) {
			EC_GROUP *ngroup;
			const EC_GROUP *group;

			if ((ecdh = EC_KEY_new()) == NULL) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}

			/*
			 * Extract elliptic curve parameters and the
			 * server's ephemeral ECDH public key.
			 * Keep accumulating lengths of various components in
			 * param_len and make sure it never exceeds n.
			 */

			/*
			 * XXX: For now we only support named (not generic)
			 * curves and the ECParameters in this case is just
			 * three bytes.
			 */
			param_len = 3;
			if ((param_len > n) || (*p != NAMED_CURVE_TYPE) ||
			    ((curve_nid = tls1_ec_curve_id2nid(*(p + 2)))
			    == 0)) {
				al = SSL_AD_INTERNAL_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
				goto f_err;
			}

			ngroup = EC_GROUP_new_by_curve_name(curve_nid);
			if (ngroup == NULL) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_EC_LIB);
				goto err;
			}
			if (EC_KEY_set_group(ecdh, ngroup) == 0) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_EC_LIB);
				goto err;
			}
			EC_GROUP_free(ngroup);

			group = EC_KEY_get0_group(ecdh);

			if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
				(EC_GROUP_get_degree(group) > 163)) {
				al = SSL_AD_EXPORT_RESTRICTION;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
				goto f_err;
			}

			p += 3;

			/* Next, get the encoded ECPoint */
			if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
			    ((bn_ctx = BN_CTX_new()) == NULL)) {
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}

			encoded_pt_len = *p;
			/* length of encoded point */
			p += 1;
			param_len += (1 + encoded_pt_len);
			if ((param_len > n) ||
			    (EC_POINT_oct2point(group, srvr_ecpoint,
			    p, encoded_pt_len, bn_ctx) == 0)) {
				al = SSL_AD_DECODE_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				    SSL_R_BAD_ECPOINT);
				goto f_err;
			}

			n -= param_len;
			p += encoded_pt_len;

			/*
			 * The ECC/TLS specification does not mention the use
			 * of DSA to sign ECParameters in the server key
			 * exchange message. We do support RSA and ECDSA.
			 */
			if (alg_a & SSL_aRSA)
				pkey = X509_get_pubkey(
				    s->session->sess_cert->peer_pkeys[
				    SSL_PKEY_RSA_ENC].x509);
d1654 4
a1657 4
			else if (alg_a & SSL_aECDSA)
				pkey = X509_get_pubkey(
				    s->session->sess_cert->peer_pkeys[
				    SSL_PKEY_ECC].x509);
d1659 12
a1670 12
			/* Else anonymous ECDH, so no certificate or pkey. */
			EC_KEY_set_public_key(ecdh, srvr_ecpoint);
			s->session->sess_cert->peer_ecdh_tmp = ecdh;
			ecdh = NULL;
			BN_CTX_free(bn_ctx);
			bn_ctx = NULL;
			EC_POINT_free(srvr_ecpoint);
			srvr_ecpoint = NULL;
		} else if (alg_k) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
			    SSL_R_UNEXPECTED_MESSAGE);
d1672 1
a1672 1
		}
@


1.45
log
@More KNF, things that couldn't be verified with md5(1), and some whitespace
I missed on the first go around.
@
text
@d3272 1
a3272 1
	return (i};
@


1.44
log
@KNF
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d114 1
a114 1
 * Portions of the attached software ("Contribution") are developed by 
d415 2
a416 2
			/* 
			 * XXX: For now, we do not support client 
d419 2
a420 2
			 * We need to skip the certificate verify 
			 * message when client's ECDH public key is sent 
d682 1
a682 1
		/* 
d835 1
a835 1
				return 1;
d1476 1
a1476 1
			/* 
d2041 1
a2041 1
	 * client session ID matching to work and we know much 
d2043 1
a2043 1
	 * 
d2052 1
a2052 1
	 */ 
d2070 3
a2072 6
	n = s->method->ssl_get_message(s,
	SSL3_ST_CR_CERT_STATUS_A,
	SSL3_ST_CR_CERT_STATUS_B,
	SSL3_MT_CERTIFICATE_STATUS,
	16384,
	&ok);
d2123 1
a2123 1
	return 1;
d2147 1
a2147 1
		return -1;
d2229 1
a2229 2
			        s, s->session->master_key, tmp_buf,
			        sizeof tmp_buf);
d2245 1
a2245 1
			int 		padl, outl = sizeof(epms);
d2282 1
a2282 1
			/*  
d2289 1
a2289 1
			 * if (krb5_ap_req.data)  
d2434 1
a2434 1
#ifndef OPENSSL_NO_ECDH 
d2448 1
a2448 1
				/* 
d2452 1
a2452 1
				 * code that checks for appropriate 
d2560 1
a2560 1
			    -> generate_master_secret(s, 
d2894 1
a2894 1
		/* 
d3023 2
a3024 1
		/* If we get an error, we need to
d3026 1
a3026 1
		 * We then get retied later 
d3120 1
a3120 1
			return 1;
d3221 1
a3221 1
	return ssl3_do_write(s, SSL3_RT_HANDSHAKE);
d3240 1
a3240 1
		return 1;
d3250 1
a3250 1
		return 2;
d3252 1
a3252 1
	return 1;
d3267 1
a3267 1
			return i;
d3272 1
a3272 1
	return i;
@


1.43
log
@remove redundant asign. from David Hill
@
text
@d184 4
a187 4
	BUF_MEM *buf = NULL;
	void (*cb)(const SSL *ssl, int type, int val) = NULL;
	int ret = -1;
	int new_state, state, skip = 0;
d220 2
a221 1
				SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);
d234 2
a235 1
				if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {
d314 5
a318 4
			/* Check if it is anon DH/ECDH */
			/* or PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				!(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {
d348 4
a351 2
			/* at this point we check that we have the
			 * required stuff from the server */
d375 4
a378 2
					SSLerr(SSL_F_SSL3_CONNECT, SSL_R_SRP_A_CALC);
					ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
d407 10
a416 5
			/* EAY EAY EAY need to check for DH fix cert
			 * sent back */
			/* For TLS, cert_req is set to 2, so a cert chain
			 * of nothing is sent, but no verify packet is sent */
			/* XXX: For now, we do not support client 
d472 1
a472 1
			s->s3->tmp.new_compression->id;
d480 1
a480 1
				SSL3_CHANGE_CIPHER_CLIENT_WRITE)) {
d511 2
a512 1
				if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED) {
d521 2
a522 1
					s->s3->tmp.next_state = SSL3_ST_CR_SESSION_TICKET_A;
d585 4
a588 2
			/* If we are not 'joining' the last two packets,
			 * remove the buffering now */
d613 2
a614 1
			SSLerr(SSL_F_SSL3_CONNECT, SSL_R_UNKNOWN_STATE);
d636 1
a636 1
end:
d649 4
a652 4
	unsigned char *buf;
	unsigned char *p, *d;
	int i;
	unsigned long l;
d654 2
a655 2
	int j;
	SSL_COMP *comp;
d680 1
a680 1
		d = p= &(buf[4]);
d682 2
a683 1
		/* version indicates the negotiated version: for example from
d718 1
a718 1
		*(p++) = s->client_version&0xff;
d733 2
a734 1
				SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
d744 2
a745 1
			SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
d749 2
a750 1
			/* Some servers hang if client hello > 256 bytes
d782 2
a783 1
			SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
d786 4
a789 2
		if ((p = ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH)) == NULL) {
			SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
d807 1
a807 1
err:
d814 6
a819 6
	STACK_OF(SSL_CIPHER) *sk;
	const SSL_CIPHER *c;
	unsigned char *p, *d;
	int i, al, ok;
	unsigned int j;
	long n;
d821 1
a821 1
	SSL_COMP *comp;
d830 2
a831 1
	if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER) {
d840 2
a841 1
				SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);
d849 2
a850 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);
d857 2
a858 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION);
d873 2
a874 1
	if ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE)) {
d876 2
a877 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_SSL3_SESSION_ID_TOO_LONG);
d882 4
a885 1
	/* check if we want to resume the session based on external pre-shared secret */
d901 2
a902 1
		    memcmp(s->session->sid_ctx, s->sid_ctx, s->sid_ctx_length)) {
d905 2
a906 1
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
d910 2
a911 3
	}
	else	/* a miss or crap from the other end */
	{
d929 2
a930 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNKNOWN_CIPHER_RETURNED);
d937 2
a938 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);
d948 2
a949 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);
d953 5
a957 3
	/* Depending on the session caching (internal/external), the cipher
	   and/or cipher_id values may not be set. Make sure that
	   cipher_id is set and use it for comparison. */
d962 2
a963 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);
d967 2
a968 1
	/* Don't digest cached records if TLS v1.2: we may need them for
d971 2
a972 1
	if (TLS1_get_version(s) < TLS1_2_VERSION && !ssl3_digest_cached_records(s)) {
d981 2
a982 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
d985 2
a986 1
	/* If compression is disabled we'd better not try to resume a session
d991 2
a992 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_INCONSISTENT_COMPRESSION);
d999 2
a1000 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);
d1007 2
a1008 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_COMPRESSION_DISABLED);
d1015 2
a1016 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
d1028 2
a1029 1
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_PARSE_TLSEXT);
d1034 2
a1035 1
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_SERVERHELLO_TLSEXT);
d1044 2
a1045 1
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_PACKET_LENGTH);
d1050 1
a1050 1
f_err:
d1052 1
a1052 1
err:
d1059 11
a1069 9
	int al, i, ok, ret = -1;
	unsigned long n, nc, llen, l;
	X509 *x = NULL;
	const unsigned char *q, *p;
	unsigned char *d;
	STACK_OF(X509) *sk = NULL;
	SESS_CERT *sc;
	EVP_PKEY *pkey = NULL;
	int need_cert = 1; /* VRS: 0=> will allow null cert if auth == KRB5 */
d1086 2
a1087 1
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, SSL_R_BAD_MESSAGE_TYPE);
d1093 2
a1094 1
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, ERR_R_MALLOC_FAILURE);
d1101 2
a1102 1
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, SSL_R_LENGTH_MISMATCH);
d1109 2
a1110 1
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, SSL_R_CERT_LENGTH_MISMATCH);
d1118 2
a1119 1
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, ERR_R_ASN1_LIB);
d1124 2
a1125 1
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, SSL_R_CERT_LENGTH_MISMATCH);
d1129 2
a1130 1
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, ERR_R_MALLOC_FAILURE);
d1146 2
a1147 1
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE, SSL_R_CERTIFICATE_VERIFY_FAILED);
d1162 4
a1165 2
	/* Inconsistency alert: cert_chain does include the peer's
	 * certificate, which we don't include in s3_srvr.c */
d1174 2
a1175 2
	(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
	? 0 : 1;
d1180 3
a1182 2
	printf("cipher, alg, nc = %s, %lx, %lx, %d\n", s->s3->tmp.new_cipher->name,
	s->s3->tmp.new_cipher->algorithm_mkey, s->s3->tmp.new_cipher->algorithm_auth, need_cert);
d1185 2
a1186 1
	if (need_cert && ((pkey == NULL) || EVP_PKEY_missing_parameters(pkey))) {
d1206 4
a1209 2
		/* Why would the following ever happen?
		 * We just created sc a couple of lines ago. */
d1233 1
a1233 1
f_err:
d1236 1
a1236 1
err:
d1246 8
a1253 8
	unsigned char *q, md_buf[EVP_MAX_MD_SIZE*2];
	EVP_MD_CTX md_ctx;
	unsigned char *param, *p;
	int al, i, j, param_len, ok;
	long n, alg_k, alg_a;
	EVP_PKEY *pkey = NULL;
	const EVP_MD *md = NULL;
	RSA *rsa = NULL;
d1255 1
a1255 1
	DH *dh = NULL;
d1258 5
a1262 5
	EC_KEY *ecdh = NULL;
	BN_CTX *bn_ctx = NULL;
	EC_POINT *srvr_ecpoint = NULL;
	int curve_nid = 0;
	int encoded_pt_len = 0;
d1265 4
a1268 2
	/* use same message size as in ssl3_get_certificate_request()
	 * as ServerKeyExchange message may be skipped */
d1276 5
a1280 4
		/* In plain PSK ciphersuite, ServerKeyExchange can be
		   omitted if no identity hint is sent. Set
		   session->sess_cert anyway to avoid problems
		   later.*/
d1326 2
a1327 1
		/* Store PSK identity hint for later use, hint is used
d1330 2
a1331 1
		 * long as the maximum length of a PSK identity. */
d1334 1
a1334 1
			SSL_R_DATA_LENGTH_TOO_LONG);
d1340 1
a1340 1
			SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);
d1343 2
a1344 1
		/* If received PSK identity hint contains NULL
d1347 2
a1348 1
		 * NULL-terminated string. */
d1355 2
a1356 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
d1370 2
a1371 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_N_LENGTH);
d1375 2
a1376 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
d1385 2
a1386 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_G_LENGTH);
d1390 2
a1391 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
d1401 2
a1402 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_S_LENGTH);
d1406 2
a1407 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
d1416 2
a1417 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_B_LENGTH);
d1421 2
a1422 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
d1428 1
a1428 1
/* We must check if there is a certificate */
d1430 3
a1432 1
			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
d1434 3
a1436 1
			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
d1439 20
a1458 17
	if (alg_k & SSL_kRSA) {
		if ((rsa = RSA_new()) == NULL) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
			goto err;
		}
		n2s(p, i);
		param_len = i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_MODULUS_LENGTH);
			goto f_err;
		}
		if (!(rsa->n = BN_bin2bn(p, i, rsa->n))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
			goto err;
		}
		p += i;
d1460 15
a1474 13
		n2s(p, i);
		param_len += i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_E_LENGTH);
			goto f_err;
		}
		if (!(rsa->e = BN_bin2bn(p, i, rsa->e))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
			goto err;
		}
		p += i;
		n -= param_len;
d1476 15
a1490 6
		/* this should be because we are using an export cipher */
		if (alg_a & SSL_aRSA)
			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
		else {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
			goto err;
a1491 3
		s->session->sess_cert->peer_rsa_tmp = rsa;
		rsa = NULL;
	}
d1493 35
a1527 17
	else if (alg_k & SSL_kEDH) {
		if ((dh = DH_new()) == NULL) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_DH_LIB);
			goto err;
		}
		n2s(p, i);
		param_len = i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_P_LENGTH);
			goto f_err;
		}
		if (!(dh->p = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
			goto err;
		}
		p += i;
d1529 15
a1543 12
		n2s(p, i);
		param_len += i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_G_LENGTH);
			goto f_err;
		}
		if (!(dh->g = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
			goto err;
		}
		p += i;
d1545 16
a1560 5
		n2s(p, i);
		param_len += i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_PUB_KEY_LENGTH);
a1562 20
		if (!(dh->pub_key = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
			goto err;
		}
		p += i;
		n -= param_len;

		if (alg_a & SSL_aRSA)
			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
		else if (alg_a & SSL_aDSS)
			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
		/* else anonymous DH, so no certificate or pkey. */

		s->session->sess_cert->peer_dh_tmp = dh;
		dh = NULL;
	} else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd)) {
		al = SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
		goto f_err;
	}
d1566 3
a1568 3
	else if (alg_k & SSL_kEECDH) {
		EC_GROUP *ngroup;
		const EC_GROUP *group;
d1570 5
a1574 4
		if ((ecdh = EC_KEY_new()) == NULL) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
			goto err;
		}
d1576 6
a1581 5
		/* Extract elliptic curve parameters and the
		 * server's ephemeral ECDH public key.
		 * Keep accumulating lengths of various components in
		 * param_len and make sure it never exceeds n.
		 */
d1583 14
a1596 11
		/* XXX: For now we only support named (not generic) curves
		 * and the ECParameters in this case is just three bytes.
		 */
		param_len = 3;
		if ((param_len > n) ||
			(*p != NAMED_CURVE_TYPE) ||
		((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0)) {
			al = SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
			goto f_err;
		}
d1598 12
a1609 10
		ngroup = EC_GROUP_new_by_curve_name(curve_nid);
		if (ngroup == NULL) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_EC_LIB);
			goto err;
		}
		if (EC_KEY_set_group(ecdh, ngroup) == 0) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_EC_LIB);
			goto err;
		}
		EC_GROUP_free(ngroup);
d1611 1
a1611 1
		group = EC_KEY_get0_group(ecdh);
d1613 7
a1619 6
		if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
			(EC_GROUP_get_degree(group) > 163)) {
			al = SSL_AD_EXPORT_RESTRICTION;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
			goto f_err;
		}
d1621 1
a1621 1
		p += 3;
d1623 7
a1629 6
		/* Next, get the encoded ECPoint */
		if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
			((bn_ctx = BN_CTX_new()) == NULL)) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
			goto err;
		}
d1631 12
a1642 11
		encoded_pt_len = *p;
		/* length of encoded point */
		p += 1;
		param_len += (1 + encoded_pt_len);
		if ((param_len > n) ||
			(EC_POINT_oct2point(group, srvr_ecpoint,
		p, encoded_pt_len, bn_ctx) == 0)) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_ECPOINT);
			goto f_err;
		}
d1644 2
a1645 2
		n -= param_len;
		p += encoded_pt_len;
d1647 9
a1655 6
		/* The ECC/TLS specification does not mention
		 * the use of DSA to sign ECParameters in the server
		 * key exchange message. We do support RSA and ECDSA.
		 */
		if (alg_a & SSL_aRSA)
			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
d1657 19
a1675 16
		else if (alg_a & SSL_aECDSA)
			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
#endif
		/* else anonymous ECDH, so no certificate or pkey. */
		EC_KEY_set_public_key(ecdh, srvr_ecpoint);
		s->session->sess_cert->peer_ecdh_tmp = ecdh;
		ecdh = NULL;
		BN_CTX_free(bn_ctx);
		bn_ctx = NULL;
		EC_POINT_free(srvr_ecpoint);
		srvr_ecpoint = NULL;
	} else if (alg_k) {
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);
		goto f_err;
	}
a1677 1

d1686 2
a1687 1
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d1690 4
a1693 1
			/* Check key type is consistent with signature */
d1695 2
a1696 1
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_WRONG_SIGNATURE_TYPE);
d1702 2
a1703 1
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNKNOWN_DIGEST);
d1708 2
a1709 1
			fprintf(stderr, "USING TLSv1.2 HASH %s\n", EVP_MD_name(md));
d1723 2
a1724 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_WRONG_SIGNATURE_LENGTH);
d1728 2
a1729 1
		if (pkey->type == EVP_PKEY_RSA && TLS1_get_version(s) < TLS1_2_VERSION) {
d1737 9
a1745 4
				EVP_DigestInit_ex(&md_ctx,(num == 2)
				?s->ctx->md5 : s->ctx->sha1, NULL);
				EVP_DigestUpdate(&md_ctx, &(s->s3->client_random[0]), SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx, &(s->s3->server_random[0]), SSL3_RANDOM_SIZE);
d1747 2
a1748 1
				EVP_DigestFinal_ex(&md_ctx, q,(unsigned int *)&i);
d1752 2
a1753 2
			i = RSA_verify(NID_md5_sha1, md_buf, j, p, n,
			pkey->pkey.rsa);
d1756 2
a1757 1
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_DECRYPT);
d1763 2
a1764 1
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);
d1767 1
a1767 2
		} else
		{
d1769 4
a1772 2
			EVP_VerifyUpdate(&md_ctx, &(s->s3->client_random[0]), SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx, &(s->s3->server_random[0]), SSL3_RANDOM_SIZE);
d1777 2
a1778 1
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);
d1783 4
a1786 4
		if (!(alg_a & SSL_aNULL) && !(alg_k & SSL_kPSK))
			/* aNULL or kPSK do not need public keys */
		{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d1792 2
a1793 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_EXTRA_DATA_IN_MESSAGE);
d1800 1
a1800 1
f_err:
d1802 1
a1802 1
err:
d1823 7
a1829 7
	int ok, ret = 0;
	unsigned long n, nc, l;
	unsigned int llen, ctype_num, i;
	X509_NAME *xn = NULL;
	const unsigned char *p, *q;
	unsigned char *d;
	STACK_OF(X509_NAME) *ca_sk = NULL;
d1831 2
a1832 6
	n = s->method->ssl_get_message(s,
	SSL3_ST_CR_CERT_REQ_A,
	SSL3_ST_CR_CERT_REQ_B,
	-1,
	s->max_cert_list,
	&ok);
d1841 2
a1842 1
		/* If we get here we don't need any cached handshake records
d1854 2
a1855 1
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_WRONG_MESSAGE_TYPE);
d1862 4
a1865 2
			ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER);
d1873 2
a1874 1
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);
d1892 2
a1893 1
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_DATA_LENGTH_TOO_LONG);
d1898 2
a1899 1
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_SIGNATURE_ALGORITHMS_ERROR);
d1910 2
a1911 1
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_LENGTH_MISMATCH);
d1921 2
a1922 1
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_CA_DN_TOO_LONG);
d1933 4
a1936 2
				ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);
				SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, ERR_R_ASN1_LIB);
d1943 2
a1944 1
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_CA_DN_LENGTH_MISMATCH);
d1948 2
a1949 1
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);
d1958 1
a1958 1
cont:
d1971 1
a1971 1
err:
d1987 4
a1990 4
	int ok, al, ret = 0, ticklen;
	long n;
	const unsigned char *p;
	unsigned char *d;
d2003 2
a2004 1
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_BAD_MESSAGE_TYPE);
d2010 2
a2011 1
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);
d2021 2
a2022 1
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);
d2031 2
a2032 1
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);
d2037 2
a2038 1
	/* There are two ways to detect a resumed ticket sesion.
d2053 2
a2054 3
	EVP_Digest(p, ticklen,
	s->session->session_id, &s->session->session_id_length,
	EVP_sha256(), NULL);
d2057 1
a2057 1
f_err:
d2059 1
a2059 1
err:
d2066 3
a2068 3
	int ok, al;
	unsigned long resplen, n;
	const unsigned char *p;
d2082 2
a2083 1
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_LENGTH_MISMATCH);
d2089 2
a2090 1
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_UNSUPPORTED_STATUS_TYPE);
d2096 2
a2097 1
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_LENGTH_MISMATCH);
d2105 2
a2106 1
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS, ERR_R_MALLOC_FAILURE);
d2115 2
a2116 1
			SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_INVALID_STATUS_RESPONSE);
d2121 2
a2122 1
			SSLerr(SSL_F_SSL3_GET_CERT_STATUS, ERR_R_MALLOC_FAILURE);
d2127 1
a2127 1
f_err:
d2136 2
a2137 2
	int ok, ret = 0;
	long n;
d2148 2
a2149 1
		SSLerr(SSL_F_SSL3_GET_SERVER_DONE, SSL_R_LENGTH_MISMATCH);
d2160 5
a2164 5
	unsigned char *p, *d;
	int n;
	unsigned long alg_k;
	unsigned char *q;
	EVP_PKEY *pkey = NULL;
d2166 1
a2166 1
	KSSL_ERR kssl_err;
d2169 6
a2174 6
	EC_KEY *clnt_ecdh = NULL;
	const EC_POINT *srvr_ecpoint = NULL;
	EVP_PKEY *srvr_pub_pkey = NULL;
	unsigned char *encodedPoint = NULL;
	int encoded_pt_len = 0;
	BN_CTX * bn_ctx = NULL;
d2190 3
a2192 1
				pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
d2196 3
a2198 1
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d2219 2
a2220 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, SSL_R_BAD_RSA_ENCRYPT);
d2248 1
a2248 1
			+ EVP_MAX_IV_LENGTH];
d2255 1
a2255 1
			alg_k, SSL_kKRB5);
d2273 2
a2274 1
					printf("kssl_cget_tkt kssl_err=%s\n", kssl_err.text);
d2280 1
a2280 1
				SSL_AD_HANDSHAKE_FAILURE);
d2282 1
a2282 1
				kssl_err.reason);
d2286 19
a2304 18
			/*  20010406 VRS - Earlier versions used KRB5 AP_REQ
			**  in place of RFC 2712 KerberosWrapper, as in:
			**
			**  Send ticket (copy to *p, set n = length)
			**  n = krb5_ap_req.length;
			**  memcpy(p, krb5_ap_req.data, krb5_ap_req.length);
			**  if (krb5_ap_req.data)  
			**    kssl_krb5_free_data_contents(NULL,&krb5_ap_req);
			**
			**  Now using real RFC 2712 KerberosWrapper
			**  (Thanks to Simon Wilkinson <sxw@@sxw.org.uk>)
			**  Note: 2712 "opaque" types are here replaced
			**  with a 2-byte length followed by the value.
			**  Example:
			**  KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms
			**  Where "xx xx" = length bytes.  Shown here with
			**  optional authenticator omitted.
			*/
d2306 1
a2306 1
			/*  KerberosWrapper.Ticket		*/
d2312 1
a2312 1
			/*  KerberosWrapper.Authenticator	*/
d2328 1
a2328 1
			tmp_buf[1] = s->client_version&0xff;
d2332 7
a2338 6
			/*  20010420 VRS.  Tried it this way; failed.
			**	EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,NULL);
			**	EVP_CIPHER_CTX_set_key_length(&ciph_ctx,
			**				kssl_ctx->length);
			**	EVP_EncryptInit_ex(&ciph_ctx,NULL, key,iv);
			*/
d2343 1
a2343 1
			kssl_ctx->key, iv);
d2345 1
a2345 1
			sizeof tmp_buf);
d2349 2
a2350 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d2355 1
a2355 1
			/*  KerberosWrapper.EncryptedPreMasterSecret	*/
d2375 4
a2378 2
				ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);
d2385 5
a2389 3
				/* we get them from the cert */
				ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);
d2393 1
a2393 1
			/* generate a new random key */
d2395 2
a2396 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);
d2400 2
a2401 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);
d2406 4
a2409 3
			/* use the 'p' output buffer for the DH key, but
			 * make sure to clear it out afterwards */

d2413 2
a2414 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);
d2419 1
a2419 1
			/* generate master key from the result */
d2423 1
a2423 1
			/* clean up */
d2426 1
a2426 1
			/* send off the data */
d2445 4
a2448 4
			/* Did we send out the client's
			 * ECDH share for use in premaster
			 * computation as part of client certificate?
			 * If so, set ecdh_clnt_cert to 1.
d2450 4
a2453 2
			if ((alg_k & (SSL_kECDHr|SSL_kECDHe)) && (s->cert != NULL)) {
				/* XXX: For now, we do not support client
d2481 5
a2485 4
					(srvr_pub_pkey->type != EVP_PKEY_EC) ||
				(srvr_pub_pkey->pkey.ec == NULL)) {
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					ERR_R_INTERNAL_ERROR);
d2497 1
a2497 1
				ERR_R_INTERNAL_ERROR);
d2502 2
a2503 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
d2508 2
a2509 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
d2513 2
a2514 1
				/* Reuse key info from our certificate
d2522 3
a2524 1
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
d2527 5
a2531 2
				if (!EC_KEY_set_private_key(clnt_ecdh, priv_key)) {
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
d2537 3
a2539 1
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);
d2544 3
a2546 2
			/* use the 'p' output buffer for the ECDH key, but
			 * make sure to clear it out afterwards
a2547 1

d2551 1
a2551 1
				ERR_R_ECDH_LIB);
d2554 2
a2555 1
			n = ECDH_compute_key(p, (field_size + 7)/8, srvr_ecpoint, clnt_ecdh, NULL);
d2558 1
a2558 1
				ERR_R_ECDH_LIB);
d2565 1
a2565 2
			s->session->master_key,
			p, n);
d2570 1
a2570 1
				/* Send empty client key exch message */
d2573 2
a2574 1
				/* First check the size of encoding and
d2577 5
a2581 5
				encoded_pt_len =
				   EC_POINT_point2oct(srvr_group,
				       EC_KEY_get0_public_key(clnt_ecdh),
				       POINT_CONVERSION_UNCOMPRESSED,
				       NULL, 0, NULL);
d2588 3
a2590 1
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
d2596 3
a2598 3
				EC_KEY_get0_public_key(clnt_ecdh),
				POINT_CONVERSION_UNCOMPRESSED,
				encodedPoint, encoded_pt_len, bn_ctx);
d2628 2
a2629 1
			unsigned char premaster_secret[32], shared_ukm[32], tmp[256];
d2634 2
a2635 1
			peer_cert = s->session->sess_cert->peer_pkeys[(keytype = SSL_PKEY_GOST01)].x509;
d2637 2
a2638 1
				peer_cert = s->session->sess_cert->peer_pkeys[(keytype = SSL_PKEY_GOST94)].x509;
d2640 2
a2641 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);
d2645 5
a2649 3
			pkey_ctx = EVP_PKEY_CTX_new(pub_key = X509_get_pubkey(peer_cert), NULL);
			/* If we have send a certificate, and certificate key

d2651 2
a2652 1
			 * certificate key for key exchange
a2654 2
			/* Otherwise, generate ephemeral key pair */

d2656 1
a2656 1
			/* Generate session key */
d2658 4
a2661 1
			/* If we have client certificate, use its secret as peer key */
d2663 7
a2669 4
				if (EVP_PKEY_derive_set_peer(pkey_ctx, s->cert->key->privatekey) <=0) {
					/* If there was an error - just ignore it. Ephemeral key
					* would be used
					*/
d2673 4
a2676 2
			/* Compute shared IV and store it in algorithm-specific
			 * context data */
d2678 6
a2683 3
			EVP_DigestInit(ukm_hash, EVP_get_digestbynid(NID_id_GostR3411_94));
			EVP_DigestUpdate(ukm_hash, s->s3->client_random, SSL3_RANDOM_SIZE);
			EVP_DigestUpdate(ukm_hash, s->s3->server_random, SSL3_RANDOM_SIZE);
d2686 2
a2687 2
			if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT, EVP_PKEY_CTRL_SET_IV,
				8, shared_ukm) < 0) {
d2689 1
a2689 1
				SSL_R_LIBRARY_BUG);
d2692 4
a2695 2
			/* Make GOST keytransport blob message */
			/*Encapsulate it into sequence */
d2698 2
a2699 1
			if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, premaster_secret, 32) < 0) {
d2701 1
a2701 1
				SSL_R_LIBRARY_BUG);
d2713 4
a2716 3
			/* Check if pubkey from client certificate was used */
			if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0) {
				/* Set flag "skip certificate verify" */
d2721 3
a2723 3
			s->method->ssl3_enc->generate_master_secret(s,
			s->session->master_key, premaster_secret, 32);
			EVP_PKEY_free(pub_key);
d2735 2
a2736 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d2744 1
a2744 1
				ERR_R_MALLOC_FAILURE);
d2748 5
a2752 2
			if ((s->session->master_key_length = SRP_generate_client_master_secret(s, s->session->master_key)) < 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
d2768 1
a2768 1
				SSL_R_PSK_NO_CLIENT_CB);
d2772 4
a2775 3
			psk_len = s->psk_client_callback(s, s->ctx->psk_identity_hint,
			identity, PSK_MAX_IDENTITY_LEN,
			psk_or_pre_ms, sizeof(psk_or_pre_ms));
d2778 1
a2778 1
				ERR_R_INTERNAL_ERROR);
d2782 1
a2782 1
				SSL_R_PSK_IDENTITY_NOT_FOUND);
d2789 2
a2790 1
			memmove(psk_or_pre_ms + psk_len + 4, psk_or_pre_ms, psk_len);
d2798 2
a2799 1
			s->session->psk_identity_hint = BUF_strdup(s->ctx->psk_identity_hint);
d2803 1
a2803 1
				ERR_R_MALLOC_FAILURE);
d2812 1
a2812 1
				ERR_R_MALLOC_FAILURE);
d2818 2
a2819 2
			        s, s->session->master_key, psk_or_pre_ms,
			        pre_ms_len);
d2826 1
a2826 1
			psk_err:
d2830 2
a2831 1
				ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
d2855 1
a2855 1
err:
d2870 8
a2877 8
	unsigned char *p, *d;
	unsigned char data[MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH];
	EVP_PKEY *pkey;
	EVP_PKEY_CTX *pctx = NULL;
	EVP_MD_CTX mctx;
	unsigned u = 0;
	unsigned long n;
	int j;
d2885 4
a2888 1
/* Create context from key and test if sha1 is allowed as digest */
d2894 1
a2894 2
			NID_sha1,
			&(data[MD5_DIGEST_LENGTH]));
d2898 2
a2899 1
		/* For TLS v1.2 send signature algorithm and signature
d2907 3
a2909 2
			&hdata);
			if (hdatalen <= 0 || !tls12_get_sigandhash(p, pkey, md)) {
d2911 1
a2911 1
				ERR_R_INTERNAL_ERROR);
d2923 1
a2923 1
				ERR_R_EVP_LIB);
d2937 2
a2938 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_RSA_LIB);
d2949 2
a2950 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_DSA_LIB);
d2963 1
a2963 1
				ERR_R_ECDSA_LIB);
d2970 2
a2971 1
		if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) {
d2976 3
a2978 3
			NID_id_GostR3411_94,
			data);
			if (EVP_PKEY_sign(pctx, signbuf, &sigsize, data, 32) <= 0) {
d2980 1
a2980 1
				ERR_R_INTERNAL_ERROR);
d2989 2
a2990 1
			SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
d3003 1
a3003 1
err:
d3012 4
a3015 4
	X509 *x509 = NULL;
	EVP_PKEY *pkey = NULL;
	int i;
	unsigned long l;
d3029 2
a3030 1
		 * We then get retied later */
d3044 2
a3045 1
			SSLerr(SSL_F_SSL3_SEND_CLIENT_CERTIFICATE, SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
d3055 2
a3056 1
				ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_CERTIFICATE);
d3070 1
a3070 1
		(s->s3->tmp.cert_req == 2) ? NULL : s->cert->key->x509);
d3083 5
a3087 5
	int i, idx;
	long alg_k, alg_a;
	EVP_PKEY *pkey = NULL;
	SESS_CERT *sc;
	RSA *rsa;
d3089 1
a3089 1
	DH *dh;
d3095 1
a3095 1
	/* we don't have a certificate */
d3101 2
a3102 1
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, ERR_R_INTERNAL_ERROR);
d3111 1
a3111 1
	/* This is the passed certificate */
d3117 1
a3117 1
			s) == 0)
d3119 2
a3120 1
			SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_BAD_ECC_CERT);
d3134 2
a3135 1
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_RSA_SIGNING_CERT);
d3139 2
a3140 1
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_DSA_SIGNING_CERT);
d3145 2
a3146 1
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_RSA_ENCRYPTING_CERT);
d3152 2
a3153 1
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_DH_KEY);
d3156 2
a3157 1
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_DH_RSA_CERT);
d3161 2
a3162 1
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_DH_DSA_CERT);
d3167 2
a3168 1
	if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) && !has_bits(i, EVP_PKT_EXP)) {
d3170 4
a3173 3
			if (rsa == NULL ||
			    RSA_size(rsa) * 8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)) {
				SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_EXPORT_TMP_RSA_KEY);
d3178 14
a3191 4
		if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd)) {
			if (dh == NULL ||
			    DH_size(dh) * 8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)) {
				SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_EXPORT_TMP_DH_KEY);
a3193 6
		} else
#endif
		{
			SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
			goto f_err;
		}
d3196 1
a3196 1
f_err:
d3198 1
a3198 1
err:
d3206 2
a3207 2
	unsigned int len, padding_len;
	unsigned char *d;
d3228 2
a3229 1
/* Check to see if handshake is full or resumed. Usually this is just a
d3238 3
a3240 2
	int ok;
	long n;
d3262 2
a3263 1
	int i = 0;
@


1.42
log
@Unifdef -UPKCS1_CHECK and remove SSL_OP_PKCS1_CHECK_[12], this is leftover
``debug'' code from a 15+ years old bugfix and the SSL_OP_PKCS1_CHECK_*
constants have had a value of zero since ages. No production code should use
them.

ok beck@@
@
text
@a2795 1
		i = 0;
@


1.41
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@a2048 6
#ifdef PKCS1_CHECK
			if (s->options & SSL_OP_PKCS1_CHECK_1)
				p[1]++;
			if (s->options & SSL_OP_PKCS1_CHECK_2)
				tmp_buf[0] = 0x70;
#endif
@


1.40
log
@More KNF and style consistency tweaks
@
text
@d2393 1
a2393 3
				encodedPoint =
				    (unsigned char *)malloc(
				        encoded_pt_len * sizeof(unsigned char));
@


1.39
log
@whack a bunch of disabled code. ok beck lteo
@
text
@d170 2
a171 2
static const SSL_METHOD
*ssl3_get_client_method(int ver)
d175 1
a175 2
	else
		return (NULL);
@


1.38
log
@no longer need to fool emacs indentation and other if (0) oddities.
@
text
@d923 3
a925 9
/* Workaround is now obsolete */
#if 0
		if (!(s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))
#endif
		{
			al = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);
			goto f_err;
		}
a1759 8
#if 0
	{
		FILE *out;
		out = fopen("/tmp/vsign.der", "w");
		fwrite(p, 1, llen, out);
		fclose(out);
	}
#endif
@


1.37
log
@always build in RSA and DSA. ok deraadt miod
@
text
@d1538 1
a1538 2
		if (0);
		else if (alg_a & SSL_aRSA)
d2033 1
a2033 4
		/* Fool emacs indentation */
		if (0) {
		}
		else if (alg_k & SSL_kRSA) {
@


1.36
log
@quick pass at removing ability to disable sha256 and sha512. ok miod
@
text
@a1185 1
#ifndef OPENSSL_NO_RSA
a1186 1
#endif
a1192 1
#ifndef OPENSSL_NO_RSA
a1193 1
#endif
a1230 1
#ifndef OPENSSL_NO_RSA
a1234 1
#endif
a1352 1
#ifndef OPENSSL_NO_RSA
a1354 5
#else
		if (0)
;
#endif
#ifndef OPENSSL_NO_DSA
a1356 1
#endif
a1358 1
#ifndef OPENSSL_NO_RSA
a1400 4
#else /* OPENSSL_NO_RSA */
	if (0)
;
#endif
a1446 1
#ifndef OPENSSL_NO_RSA
a1448 5
#else
		if (0)
;
#endif
#ifndef OPENSSL_NO_DSA
a1450 1
#endif
a1538 1
#ifndef OPENSSL_NO_RSA
a1540 1
#endif
a1602 1
#ifndef OPENSSL_NO_RSA
a1633 1
#endif
a1666 1
#ifndef OPENSSL_NO_RSA
a1668 1
#endif
a2013 1
#ifndef OPENSSL_NO_RSA
a2015 1
#endif
a2036 1
#ifndef OPENSSL_NO_RSA
a2090 1
#endif
a2727 1
#ifndef OPENSSL_NO_RSA
a2739 2
#endif
#ifndef OPENSSL_NO_DSA
a2750 1
#endif
a2877 1
#ifndef OPENSSL_NO_RSA
a2878 1
#endif
a2895 1
#ifndef OPENSSL_NO_RSA
a2896 1
#endif
a2925 1
#ifndef OPENSSL_NO_DSA
a2929 2
#endif
#ifndef OPENSSL_NO_RSA
a2934 1
#endif
a2943 1
#ifndef OPENSSL_NO_DSA
a2948 1
#endif
a2950 1
#ifndef OPENSSL_NO_RSA
a2957 1
#endif
@


1.35
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a1942 1
#ifndef OPENSSL_NO_SHA256
a1943 3
#else
	EVP_sha1(), NULL);
#endif
@


1.34
log
@add back SRP. i was being too greedy.
@
text
@d1225 1
a1225 1
				OPENSSL_free(s->ctx->psk_identity_hint);
d1291 1
a1291 1
			OPENSSL_free(s->ctx->psk_identity_hint);
d1916 1
a1916 1
		OPENSSL_free(s->session->tlsext_tick);
d1919 1
a1919 1
	s->session->tlsext_tick = OPENSSL_malloc(ticklen);
d1991 1
a1991 1
		OPENSSL_free(s->tlsext_ocsp_resp);
d2452 1
a2452 1
				    (unsigned char *)OPENSSL_malloc(
d2482 1
a2482 1
				OPENSSL_free(encodedPoint);
d2587 1
a2587 1
				OPENSSL_free(s->session->srp_username);
d2639 1
a2639 1
				OPENSSL_free(s->session->psk_identity_hint);
d2649 1
a2649 1
				OPENSSL_free(s->session->psk_identity);
d2699 1
a2699 1
		OPENSSL_free(encodedPoint);
@


1.33
log
@disentangle SRP code from TLS
@
text
@d368 9
d1302 70
d2574 27
@


1.32
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok miod
@
text
@a367 9
#ifndef OPENSSL_NO_SRP
			if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) {
				if ((ret = SRP_Calc_A_param(s)) <= 0) {
					SSLerr(SSL_F_SSL3_CONNECT, SSL_R_SRP_A_CALC);
					ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
					goto end;
				}
			}
#endif
a1292 70
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP) {
		n2s(p, i);
		param_len = i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_N_LENGTH);
			goto f_err;
		}
		if (!(s->srp_ctx.N = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
			goto err;
		}
		p += i;

		n2s(p, i);
		param_len += i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_G_LENGTH);
			goto f_err;
		}
		if (!(s->srp_ctx.g = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
			goto err;
		}
		p += i;

		i = (unsigned int)(p[0]);
		p++;
		param_len += i + 1;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_S_LENGTH);
			goto f_err;
		}
		if (!(s->srp_ctx.s = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
			goto err;
		}
		p += i;

		n2s(p, i);
		param_len += i + 2;
		if (param_len > n) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_B_LENGTH);
			goto f_err;
		}
		if (!(s->srp_ctx.B = BN_bin2bn(p, i, NULL))) {
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);
			goto err;
		}
		p += i;
		n -= param_len;

/* We must check if there is a certificate */
#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
	} else
#endif /* !OPENSSL_NO_SRP */
a2494 27
#ifndef OPENSSL_NO_SRP
		else if (alg_k & SSL_kSRP) {
			if (s->srp_ctx.A != NULL) {
				/* send off the data */
				n = BN_num_bytes(s->srp_ctx.A);
				s2n(n, p);
				BN_bn2bin(s->srp_ctx.A, p);
				n += 2;
			} else {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
				goto err;
			}
			if (s->session->srp_username != NULL)
				OPENSSL_free(s->session->srp_username);
			s->session->srp_username = BUF_strdup(s->srp_ctx.login);
			if (s->session->srp_username == NULL) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				ERR_R_MALLOC_FAILURE);
				goto err;
			}

			if ((s->session->master_key_length = SRP_generate_client_master_secret(s, s->session->master_key)) < 0) {
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
				goto err;
			}
		}
#endif
@


1.31
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@a158 3
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif
@


1.30
log
@So the OpenSSL codebase does "get the time, add it as a random seed"
in a bunch of places inside the TLS engine, to try to keep entropy high.
I wonder if their moto is "If you can't solve a problem, at least try
to do it badly".
ok miod
@
text
@a204 11
#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending) {
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
	}
#endif

@


1.29
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a188 1
	unsigned long Time = (unsigned long)time(NULL);
a192 1
	RAND_add(&Time, sizeof(Time), 0);
@


1.28
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@d171 1
a171 1
static int ca_dn_cmp(const X509_NAME * const *a,const X509_NAME * const *b);
d173 3
a175 2
static const SSL_METHOD *ssl3_get_client_method(int ver)
	{
d177 1
a177 1
		return(SSLv3_client_method());
d179 2
a180 2
		return(NULL);
	}
d183 1
a183 3
			ssl_undefined_function,
			ssl3_connect,
			ssl3_get_client_method)
d185 8
a192 7
int ssl3_connect(SSL *s)
	{
	BUF_MEM *buf=NULL;
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;
d194 1
a194 1
	RAND_add(&Time,sizeof(Time),0);
d199 1
a199 1
		cb=s->info_callback;
d201 2
a202 2
		cb=s->ctx->info_callback;
	
d204 2
a205 1
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 
d212 1
a212 2
	if (s->tlsext_hb_pending)
		{
d215 1
a215 1
		}
d218 2
a219 3
	for (;;)
		{
		state=s->state;
d221 1
a221 2
		switch(s->state)
			{
d223 2
a224 2
			s->renegotiate=1;
			s->state=SSL_ST_CONNECT;
d232 3
a234 2
			s->server=0;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
d236 1
a236 2
			if ((s->version & 0xff00 ) != 0x0300)
				{
d240 2
a241 2
				}
				
d243 1
a243 1
			s->type=SSL_ST_CONNECT;
d245 3
a247 5
			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
d249 3
a251 4
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
a252 3
					}
				s->init_buf=buf;
				buf=NULL;
d254 3
d258 4
a261 1
			if (!ssl3_setup_buffers(s)) { ret= -1; goto end; }
d264 4
a267 1
			if (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }
d273 1
a273 1
			s->state=SSL3_ST_CW_CLNT_HELLO_A;
d275 1
a275 1
			s->init_num=0;
d281 6
a286 5
			s->shutdown=0;
			ret=ssl3_client_hello(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_SRVR_HELLO_A;
			s->init_num=0;
d290 1
a290 1
				s->wbio=BIO_push(s->bbio,s->wbio);
d296 3
a298 2
			ret=ssl3_get_server_hello(s);
			if (ret <= 0) goto end;
d300 2
a301 3
			if (s->hit)
				{
				s->state=SSL3_ST_CR_FINISHED_A;
d303 1
a303 2
				if (s->tlsext_ticket_expected)
					{
d305 2
a306 2
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
					}
d308 3
a310 4
				}
			else
				s->state=SSL3_ST_CR_CERT_A;
			s->init_num=0;
d316 4
a319 4
			ret=ssl3_check_finished(s);
			if (ret <= 0) goto end;
			if (ret == 2)
				{
d322 1
a322 1
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
d324 2
a325 2
					s->state=SSL3_ST_CR_FINISHED_A;
				s->init_num=0;
d327 1
a327 1
				}
d332 4
a335 4
			    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				ret=ssl3_get_server_certificate(s);
				if (ret <= 0) goto end;
d338 1
a338 1
					s->state=SSL3_ST_CR_CERT_STATUS_A;
d340 2
a341 4
					s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
			else
				{
d343 2
a344 2
				s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
d346 2
a347 3
				}
			else
				skip=1;
d349 1
a349 1
			s->state=SSL3_ST_CR_KEY_EXCH_A;
d351 1
a351 1
			s->init_num=0;
d356 5
a360 4
			ret=ssl3_get_key_exchange(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_CERT_REQ_A;
			s->init_num=0;
d364 2
a365 3
			if (!ssl3_check_cert_and_algorithm(s))
				{
				ret= -1;
d367 1
a367 1
				}
d372 5
a376 4
			ret=ssl3_get_certificate_request(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_SRVR_DONE_A;
			s->init_num=0;
d381 3
a383 2
			ret=ssl3_get_server_done(s);
			if (ret <= 0) goto end;
d385 4
a388 6
			if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP)
				{
				if ((ret = SRP_Calc_A_param(s))<=0)
					{
					SSLerr(SSL_F_SSL3_CONNECT,SSL_R_SRP_A_CALC);
					ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_INTERNAL_ERROR);
a389 1
					}
d391 1
d394 1
a394 1
				s->state=SSL3_ST_CW_CERT_A;
d396 2
a397 2
				s->state=SSL3_ST_CW_KEY_EXCH_A;
			s->init_num=0;
d405 5
a409 4
			ret=ssl3_send_client_certificate(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_KEY_EXCH_A;
			s->init_num=0;
d414 3
a416 2
			ret=ssl3_send_client_key_exchange(s);
			if (ret <= 0) goto end;
d428 10
a437 14
			if (s->s3->tmp.cert_req == 1)
				{
				s->state=SSL3_ST_CW_CERT_VRFY_A;
				}
			else
				{
				s->state=SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec=0;
				}
			if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)
				{
				s->state=SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec=0;
				}
d439 1
a439 1
			s->init_num=0;
d444 6
a449 5
			ret=ssl3_send_client_verify(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_CHANGE_A;
			s->init_num=0;
			s->s3->change_cipher_spec=0;
d454 4
a457 3
			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);
			if (ret <= 0) goto end;
d460 1
a460 1
			s->state=SSL3_ST_CW_FINISHED_A;
d463 1
a463 1
				s->state=SSL3_ST_CW_NEXT_PROTO_A;
d465 1
a465 1
				s->state=SSL3_ST_CW_FINISHED_A;
d467 1
a467 1
			s->init_num=0;
d469 1
a469 1
			s->session->cipher=s->s3->tmp.new_cipher;
d471 1
a471 1
			s->session->compress_meth=0;
d474 1
a474 1
				s->session->compress_meth=0;
d476 2
a477 2
				s->session->compress_meth=
					s->s3->tmp.new_compression->id;
d479 2
a480 3
			if (!s->method->ssl3_enc->setup_key_block(s))
				{
				ret= -1;
d482 1
a482 1
				}
d485 2
a486 3
				SSL3_CHANGE_CIPHER_CLIENT_WRITE))
				{
				ret= -1;
d488 1
a488 1
				}
d495 4
a498 3
			ret=ssl3_send_next_proto(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_FINISHED_A;
d504 7
a510 6
			ret=ssl3_send_finished(s,
				SSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,
				s->method->ssl3_enc->client_finished_label,
				s->method->ssl3_enc->client_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_FLUSH;
d513 5
a517 7
			s->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;
			if (s->hit)
				{
				s->s3->tmp.next_state=SSL_ST_OK;
				if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)
					{
					s->state=SSL_ST_OK;
d519 1
a519 2
					s->s3->delay_buf_pop_ret=0;
					}
d521 1
a521 2
			else
				{
d525 1
a525 1
					s->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;
d528 4
a531 4
				
				s->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;
				}
			s->init_num=0;
d537 6
a542 5
			ret=ssl3_get_new_session_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_FINISHED_A;
			s->init_num=0;
		break;
d546 6
a551 5
			ret=ssl3_get_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_KEY_EXCH_A;
			s->init_num=0;
		break;
d557 4
a560 3
			ret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,
				SSL3_ST_CR_FINISHED_B);
			if (ret <= 0) goto end;
d563 1
a563 1
				s->state=SSL3_ST_CW_CHANGE_A;
d565 2
a566 2
				s->state=SSL_ST_OK;
			s->init_num=0;
d570 3
a572 4
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
d574 3
a576 3
				}
			s->rwstate=SSL_NOTHING;
			s->state=s->s3->tmp.next_state;
d583 1
a583 2
			if (s->init_buf != NULL)
				{
d585 2
a586 2
				s->init_buf=NULL;
				}
d594 3
a596 3
			s->init_num=0;
			s->renegotiate=0;
			s->new_session=0;
d598 3
a600 2
			ssl_update_cache(s,SSL_SESS_CACHE_CLIENT);
			if (s->hit) s->ctx->stats.sess_hit++;
d602 1
a602 1
			ret=1;
d604 1
a604 1
			s->handshake_func=ssl3_connect;
d607 2
a608 1
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
d612 1
a612 1
			
d614 2
a615 2
			SSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);
			ret= -1;
d618 1
a618 1
			}
d621 3
a623 5
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
d625 1
a625 1
				}
d627 5
a631 7
			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_CONNECT_LOOP,1);
				s->state=new_state;
				}
a632 1
		skip=0;
d634 2
d641 3
a643 3
		cb(s,SSL_CB_CONNECT_EXIT,ret);
	return(ret);
	}
d646 3
a648 2
int ssl3_client_hello(SSL *s)
	{
d650 1
a650 1
	unsigned char *p,*d;
d658 2
a659 3
	buf=(unsigned char *)s->init_buf->data;
	if (s->state == SSL3_ST_CW_CLNT_HELLO_A)
		{
d662 1
a662 1
			(sess->ssl_version != s->version) ||
d664 1
a664 1
			!sess->session_id_length ||
d666 1
a666 1
			(!sess->session_id_length && !sess->tlsext_tick) ||
d668 2
a669 3
			(sess->not_resumable))
			{
			if (!ssl_get_new_session(s,0))
d671 1
a671 1
			}
d674 1
a674 1
		p=s->s3->client_random;
d680 1
a680 1
		d=p= &(buf[4]);
d712 3
a714 3
		*(p++)=s->version>>8;
		*(p++)=s->version&0xff;
		s->client_version=s->version;
d716 2
a717 2
		*(p++)=s->client_version>>8;
		*(p++)=s->client_version&0xff;
d721 2
a722 2
		memcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);
		p+=SSL3_RANDOM_SIZE;
d726 1
a726 1
			i=0;
d728 4
a731 6
			i=s->session->session_id_length;
		*(p++)=i;
		if (i != 0)
			{
			if (i > (int)sizeof(s->session->session_id))
				{
a733 3
				}
			memcpy(p,s->session->session_id,i);
			p+=i;
d735 4
a738 1
		
d740 3
a742 4
		i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),0);
		if (i == 0)
			{
			SSLerr(SSL_F_SSL3_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);
d744 1
a744 1
			}
d750 3
a752 3
			if (TLS1_get_version(s) >= TLS1_2_VERSION
				&& i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
				i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
d754 2
a755 2
		s2n(i,p);
		p+=i;
d759 1
a759 1
		*(p++)=1;
d762 3
a764 3
		if ((s->options & SSL_OP_NO_COMPRESSION)
					|| !s->ctx->comp_methods)
			j=0;
d766 6
a771 7
			j=sk_SSL_COMP_num(s->ctx->comp_methods);
		*(p++)=1+j;
		for (i=0; i<j; i++)
			{
			comp=sk_SSL_COMP_value(s->ctx->comp_methods,i);
			*(p++)=comp->id;
			}
d773 1
a773 1
		*(p++)=0; /* Add the NULL method */
d777 2
a778 3
		if (ssl_prepare_clienthello_tlsext(s) <= 0)
			{
			SSLerr(SSL_F_SSL3_CLIENT_HELLO,SSL_R_CLIENTHELLO_TLSEXT);
d780 3
a782 4
			}
		if ((p = ssl_add_clienthello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
			{
			SSLerr(SSL_F_SSL3_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);
d784 1
a784 1
			}
a785 5
		
		l=(p-d);
		d=buf;
		*(d++)=SSL3_MT_CLIENT_HELLO;
		l2n3(l,d);
d787 6
a792 1
		s->state=SSL3_ST_CW_CLNT_HELLO_B;
d794 3
a796 3
		s->init_num=p-buf;
		s->init_off=0;
		}
d799 1
a799 1
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
d801 2
a802 2
	return(-1);
	}
d804 3
a806 2
int ssl3_get_server_hello(SSL *s)
	{
d809 2
a810 2
	unsigned char *p,*d;
	int i,al,ok;
d817 2
a818 6
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_SRVR_HELLO_A,
		SSL3_ST_CR_SRVR_HELLO_B,
		-1,
		20000, /* ?? */
		&ok);
d820 2
a821 1
	if (!ok) return((int)n);
d823 3
a825 6
	if ( SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
		{
		if ( s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST)
			{
			if ( s->d1->send_cookie == 0)
				{
d828 1
a828 1
				}
d830 3
a832 3
				{
				al=SSL_AD_UNEXPECTED_MESSAGE;
				SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);
a833 1
				}
d836 5
a840 5
	
	if ( s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);
d842 1
a842 1
		}
d844 1
a844 1
	d=p=(unsigned char *)s->init_msg;
d846 4
a849 5
	if ((p[0] != (s->version>>8)) || (p[1] != (s->version&0xff)))
		{
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_SSL_VERSION);
		s->version=(s->version&0xff00)|p[1];
		al=SSL_AD_PROTOCOL_VERSION;
d851 2
a852 2
		}
	p+=2;
d856 2
a857 2
	memcpy(s->s3->server_random,p,SSL3_RANDOM_SIZE);
	p+=SSL3_RANDOM_SIZE;
d862 3
a864 4
	if ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_LONG);
d866 1
a866 1
		}
d870 3
a872 4
	if (s->version >= TLS1_VERSION && s->tls_session_secret_cb)
		{
		SSL_CIPHER *pref_cipher=NULL;
		s->session->master_key_length=sizeof(s->session->master_key);
d874 2
a875 4
					     &s->session->master_key_length,
					     NULL, &pref_cipher,
					     s->tls_session_secret_cb_arg))
			{
d877 1
a877 2
				pref_cipher : ssl_get_cipher_by_char(s, p+j);
			}
d879 1
d882 8
a889 10
	if (j != 0 && j == s->session->session_id_length
	    && memcmp(p,s->session->session_id,j) == 0)
	    {
	    if(s->sid_ctx_length != s->session->sid_ctx_length
	       || memcmp(s->session->sid_ctx,s->sid_ctx,s->sid_ctx_length))
		{
		/* actually a client application bug */
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
		goto f_err;
d891 2
a892 2
	    s->hit=1;
	    }
d894 1
a894 1
		{
d897 4
a900 6
		s->hit=0;
		if (s->session->session_id_length > 0)
			{
			if (!ssl_get_new_session(s,0))
				{
				al=SSL_AD_INTERNAL_ERROR;
a901 1
				}
d903 2
a904 1
		s->session->session_id_length=j;
d906 4
a909 5
		}
	p+=j;
	c=ssl_get_cipher_by_char(s,p);
	if (c == NULL)
		{
d911 2
a912 2
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNKNOWN_CIPHER_RETURNED);
d914 1
a914 1
		}
d916 4
a919 5
	if ((c->algorithm_ssl & SSL_TLSV1_2) && 
		(TLS1_get_version(s) < TLS1_2_VERSION))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);
d921 2
a922 2
		}
	p+=ssl_put_cipher_by_char(s,NULL,NULL);
d924 3
a926 4
	sk=ssl_get_ciphers_by_id(s);
	i=sk_SSL_CIPHER_find(sk,c);
	if (i < 0)
		{
d928 2
a929 2
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);
d931 1
a931 1
		}
d938 1
a938 2
	if (s->hit && (s->session->cipher_id != c->id))
		{
d941 1
a941 2
		if (!(s->options &
			SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))
d943 3
a945 3
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);
a946 1
			}
d948 2
a949 1
	s->s3->tmp.new_cipher=c;
d953 1
a953 2
	if (TLS1_get_version(s) < TLS1_2_VERSION && !ssl3_digest_cached_records(s))
		{
d956 1
a956 1
		}
d960 3
a962 4
	if (*(p++) != 0)
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
d964 1
a964 1
		}
d968 3
a970 4
	if (s->session->compress_meth != 0)
		{
		al=SSL_AD_INTERNAL_ERROR;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_INCONSISTENT_COMPRESSION);
d972 1
a972 1
		}
d975 3
a977 4
	if (s->hit && j != s->session->compress_meth)
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);
d979 1
a979 1
		}
d981 11
a991 5
		comp=NULL;
	else if (s->options & SSL_OP_NO_COMPRESSION)
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_COMPRESSION_DISABLED);
d993 3
a995 14
		}
	else
		comp=ssl3_comp_find(s->ctx->comp_methods,j);
	
	if ((j != 0) && (comp == NULL))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
		goto f_err;
		}
	else
		{
		s->s3->tmp.new_compression=comp;
		}
d1000 2
a1001 4
	if (s->version >= SSL3_VERSION)
		{
		if (!ssl_parse_serverhello_tlsext(s,&p,d,n, &al))
			{
d1003 7
a1009 8
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_PARSE_TLSEXT);
			goto f_err; 
			}
		if (ssl_check_serverhello_tlsext(s) <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);
				goto err;
			}
d1011 1
d1014 1
a1014 2
	if (p != (d+n))
		{
d1016 2
a1017 2
		al=SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_PACKET_LENGTH);
d1019 1
a1019 1
		}
d1021 1
a1021 1
	return(1);
d1023 1
a1023 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d1025 2
a1026 2
	return(-1);
	}
d1028 7
a1034 6
int ssl3_get_server_certificate(SSL *s)
	{
	int al,i,ok,ret= -1;
	unsigned long n,nc,llen,l;
	X509 *x=NULL;
	const unsigned char *q,*p;
d1036 1
a1036 1
	STACK_OF(X509) *sk=NULL;
d1038 1
a1038 1
	EVP_PKEY *pkey=NULL;
d1041 2
a1042 6
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_CERT_A,
		SSL3_ST_CR_CERT_B,
		-1,
		s->max_cert_list,
		&ok);
d1044 2
a1045 1
	if (!ok) return((int)n);
d1048 5
a1052 6
		((s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) && 
		(s->s3->tmp.message_type == SSL3_MT_SERVER_DONE)))
		{
		s->s3->tmp.reuse_message=1;
		return(1);
		}
d1054 3
a1056 4
	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_BAD_MESSAGE_TYPE);
d1058 2
a1059 2
		}
	p=d=(unsigned char *)s->init_msg;
d1061 2
a1062 3
	if ((sk=sk_X509_new_null()) == NULL)
		{
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);
d1064 1
a1064 1
		}
d1066 4
a1069 5
	n2l3(p,llen);
	if (llen+3 != n)
		{
		al=SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_LENGTH_MISMATCH);
d1071 7
a1078 9
	for (nc=0; nc<llen; )
		{
		n2l3(p,l);
		if ((l+nc+3) > llen)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);
			goto f_err;
			}
d1080 5
a1084 6
		q=p;
		x=d2i_X509(NULL,&q,l);
		if (x == NULL)
			{
			al=SSL_AD_BAD_CERTIFICATE;
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_ASN1_LIB);
d1086 4
a1089 5
			}
		if (q != (p+l))
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);
d1091 3
a1093 4
			}
		if (!sk_X509_push(sk,x))
			{
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);
a1094 4
			}
		x=NULL;
		nc+=l+3;
		p=q;
d1096 4
d1101 1
a1101 1
	i=ssl_verify_cert_chain(s,sk);
d1105 1
a1105 1
		 (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
d1107 6
a1112 6
		)
		{
		al=ssl_verify_alarm_type(s->verify_result);
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERTIFICATE_VERIFY_FAILED);
		goto f_err; 
		}
d1115 3
a1117 2
	sc=ssl_sess_cert_new();
	if (sc == NULL) goto err;
d1119 3
a1121 2
	if (s->session->sess_cert) ssl_sess_cert_free(s->session->sess_cert);
	s->session->sess_cert=sc;
d1123 1
a1123 1
	sc->cert_chain=sk;
d1126 3
a1128 3
	x=sk_X509_value(sk,0);
	sk=NULL;
 	/* VRS 19990621: possible memory leak; sk=null ==> !sk_pop_free() @@end*/
d1130 1
a1130 1
	pkey=X509_get_pubkey(x);
d1134 2
a1135 2
	            (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
	            ? 0 : 1;
d1138 2
a1139 2
	printf("pkey,x = %p, %p\n", pkey,x);
	printf("ssl_cert_type(x,pkey) = %d\n", ssl_cert_type(x,pkey));
d1141 1
a1141 1
		s->s3->tmp.new_cipher->algorithm_mkey, s->s3->tmp.new_cipher->algorithm_auth, need_cert);
d1144 3
a1146 4
	if (need_cert && ((pkey == NULL) || EVP_PKEY_missing_parameters(pkey)))
		{
		x=NULL;
		al=SSL3_AL_FATAL;
d1148 1
a1148 1
			SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);
d1150 1
a1150 1
		}
d1152 4
a1155 5
	i=ssl_cert_type(x,pkey);
	if (need_cert && i < 0)
		{
		x=NULL;
		al=SSL3_AL_FATAL;
d1157 1
a1157 1
			SSL_R_UNKNOWN_CERTIFICATE_TYPE);
d1159 1
a1159 1
		}
d1161 3
a1163 4
	if (need_cert)
		{
		sc->peer_cert_type=i;
		CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
d1168 2
a1169 2
		sc->peer_pkeys[i].x509=x;
		sc->peer_key= &(sc->peer_pkeys[i]);
d1173 5
a1177 7
		CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
		s->session->peer=x;
		}
	else
		{
		sc->peer_cert_type=i;
		sc->peer_key= NULL;
d1181 2
a1182 2
		s->session->peer=NULL;
		}
d1185 2
a1186 2
	x=NULL;
	ret=1;
d1188 1
a1188 2
	if (0)
		{
d1190 2
a1191 2
		ssl3_send_alert(s,SSL3_AL_FATAL,al);
		}
d1195 3
a1197 3
	sk_X509_pop_free(sk,X509_free);
	return(ret);
	}
d1199 3
a1201 2
int ssl3_get_key_exchange(SSL *s)
	{
d1203 1
a1203 1
	unsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];
d1206 4
a1209 4
	unsigned char *param,*p;
	int al,i,j,param_len,ok;
	long n,alg_k,alg_a;
	EVP_PKEY *pkey=NULL;
d1212 1
a1212 1
	RSA *rsa=NULL;
d1215 1
a1215 1
	DH *dh=NULL;
d1227 4
a1230 7
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_KEY_EXCH_A,
		SSL3_ST_CR_KEY_EXCH_B,
		-1,
		s->max_cert_list,
		&ok);
	if (!ok) return((int)n);
d1232 1
a1232 2
	if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)
		{
d1238 2
a1239 3
		if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
			{
			s->session->sess_cert=ssl_sess_cert_new();
d1243 1
a1243 1
			}
d1245 3
a1247 3
		s->s3->tmp.reuse_message=1;
		return(1);
		}
d1249 2
a1250 3
	param=p=(unsigned char *)s->init_msg;
	if (s->session->sess_cert != NULL)
		{
d1252 1
a1252 2
		if (s->session->sess_cert->peer_rsa_tmp != NULL)
			{
d1254 2
a1255 2
			s->session->sess_cert->peer_rsa_tmp=NULL;
			}
d1258 1
a1258 2
		if (s->session->sess_cert->peer_dh_tmp)
			{
d1260 2
a1261 2
			s->session->sess_cert->peer_dh_tmp=NULL;
			}
d1264 1
a1264 2
		if (s->session->sess_cert->peer_ecdh_tmp)
			{
d1266 2
a1267 2
			s->session->sess_cert->peer_ecdh_tmp=NULL;
			}
d1269 3
a1271 5
		}
	else
		{
		s->session->sess_cert=ssl_sess_cert_new();
		}
d1273 3
a1275 3
	param_len=0;
	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
	alg_a=s->s3->tmp.new_cipher->algorithm_auth;
d1279 2
a1280 3
	if (alg_k & SSL_kPSK)
		{
		char tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];
d1282 3
a1284 3
		al=SSL_AD_HANDSHAKE_FAILURE;
		n2s(p,i);
		param_len=i+2;
d1289 1
a1289 2
		if (i > PSK_MAX_IDENTITY_LEN)
			{
d1291 1
a1291 1
				SSL_R_DATA_LENGTH_TOO_LONG);
d1293 3
a1295 4
			}
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
d1297 1
a1297 1
				SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);
d1299 1
a1299 1
			}
d1305 1
a1305 1
		memset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);
d1309 1
a1309 2
		if (s->ctx->psk_identity_hint == NULL)
			{
d1312 1
a1312 1
			}	   
d1314 3
a1316 4
		p+=i;
		n-=param_len;
		}
	else
d1319 6
a1324 8
	if (alg_k & SSL_kSRP)
		{
		n2s(p,i);
		param_len=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);
d1326 3
a1328 4
			}
		if (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
d1330 2
a1331 2
			}
		p+=i;
d1333 5
a1337 6
		n2s(p,i);
		param_len+=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);
d1339 3
a1341 4
			}
		if (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
d1343 2
a1344 2
			}
		p+=i;
d1348 4
a1351 5
		param_len+=i+1;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);
d1353 3
a1355 4
			}
		if (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
d1357 2
a1358 2
			}
		p+=i;
d1360 5
a1364 6
		n2s(p,i);
		param_len+=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);
d1366 3
a1368 4
			}
		if (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
d1370 3
a1372 3
			}
		p+=i;
		n-=param_len;
d1377 1
a1377 1
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
d1380 1
a1380 1
			;
d1384 1
a1384 1
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
d1386 1
a1386 2
		}
	else
d1389 3
a1391 5
	if (alg_k & SSL_kRSA)
		{
		if ((rsa=RSA_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d1393 6
a1398 7
			}
		n2s(p,i);
		param_len=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);
d1400 3
a1402 4
			}
		if (!(rsa->n=BN_bin2bn(p,i,rsa->n)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
d1404 2
a1405 2
			}
		p+=i;
d1407 5
a1411 6
		n2s(p,i);
		param_len+=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);
d1413 3
a1415 4
			}
		if (!(rsa->e=BN_bin2bn(p,i,rsa->e)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
d1417 3
a1419 3
			}
		p+=i;
		n-=param_len;
d1423 3
a1425 4
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
		else
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
a1426 3
			}
		s->session->sess_cert->peer_rsa_tmp=rsa;
		rsa=NULL;
d1428 3
d1433 1
a1433 1
		;
d1436 3
a1438 5
	else if (alg_k & SSL_kEDH)
		{
		if ((dh=DH_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);
d1440 6
a1445 7
			}
		n2s(p,i);
		param_len=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);
d1447 3
a1449 4
			}
		if (!(dh->p=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
d1451 2
a1452 2
			}
		p+=i;
d1454 5
a1458 6
		n2s(p,i);
		param_len+=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);
d1460 3
a1462 4
			}
		if (!(dh->g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
d1464 2
a1465 2
			}
		p+=i;
d1467 5
a1471 6
		n2s(p,i);
		param_len+=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);
d1473 3
a1475 4
			}
		if (!(dh->pub_key=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
d1477 3
a1479 3
			}
		p+=i;
		n-=param_len;
d1483 1
a1483 1
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
d1486 1
a1486 1
			;
d1490 1
a1490 1
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
d1494 5
a1498 7
		s->session->sess_cert->peer_dh_tmp=dh;
		dh=NULL;
		}
	else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
d1500 1
a1500 1
		}
d1504 1
a1504 2
	else if (alg_k & SSL_kEECDH)
		{
d1508 2
a1509 3
		if ((ecdh=EC_KEY_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d1511 1
a1511 1
			}
d1522 1
a1522 1
		param_len=3;
d1524 4
a1527 5
		    (*p != NAMED_CURVE_TYPE) || 
		    ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0)) 
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
d1529 1
a1529 1
			}
d1532 2
a1533 3
		if (ngroup == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
d1535 3
a1537 4
			}
		if (EC_KEY_set_group(ecdh, ngroup) == 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
d1539 1
a1539 1
			}
d1545 3
a1547 4
		    (EC_GROUP_get_degree(group) > 163))
			{
			al=SSL_AD_EXPORT_RESTRICTION;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
d1549 1
a1549 1
			}
d1551 1
a1551 1
		p+=3;
d1555 2
a1556 3
		    ((bn_ctx = BN_CTX_new()) == NULL))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d1558 1
a1558 1
			}
d1560 3
a1562 2
		encoded_pt_len = *p;  /* length of encoded point */
		p+=1;
d1565 4
a1568 5
		    (EC_POINT_oct2point(group, srvr_ecpoint, 
			p, encoded_pt_len, bn_ctx) == 0))
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);
d1570 1
a1570 1
			}
d1572 2
a1573 2
		n-=param_len;
		p+=encoded_pt_len;
d1579 1
a1579 1
		if (0) ;
d1582 1
a1582 1
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
d1586 1
a1586 1
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
d1590 2
a1591 2
		s->session->sess_cert->peer_ecdh_tmp=ecdh;
		ecdh=NULL;
d1596 3
a1598 5
		}
	else if (alg_k)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
d1600 1
a1600 1
		}
d1607 2
a1608 4
	if (pkey != NULL)
		{
		if (TLS1_get_version(s) >= TLS1_2_VERSION)
			{
d1611 2
a1612 3
			if (sigalg == -1)
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d1614 1
a1614 1
				}
d1616 3
a1618 4
			if (sigalg != (int)p[1])
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_TYPE);
				al=SSL_AD_DECODE_ERROR;
d1620 1
a1620 1
				}
d1622 3
a1624 4
			if (md == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNKNOWN_DIGEST);
				al=SSL_AD_DECODE_ERROR;
d1626 1
a1626 1
				}
d1628 1
a1628 1
fprintf(stderr, "USING TLSv1.2 HASH %s\n", EVP_MD_name(md));
d1632 1
a1632 2
			}
		else
a1633 4
			
		n2s(p,i);
		n-=2;
		j=EVP_PKEY_size(pkey);
d1635 5
a1639 2
		if ((i != n) || (n > j) || (n <= 0))
			{
d1641 2
a1642 2
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);
d1644 1
a1644 1
			}
d1647 1
a1647 2
		if (pkey->type == EVP_PKEY_RSA && TLS1_get_version(s) < TLS1_2_VERSION)
			{
d1650 3
a1652 4
			j=0;
			q=md_buf;
			for (num=2; num > 0; num--)
				{
d1654 1
a1654 1
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d1656 13
a1668 14
					?s->ctx->md5:s->ctx->sha1, NULL);
				EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,param,param_len);
				EVP_DigestFinal_ex(&md_ctx,q,(unsigned int *)&i);
				q+=i;
				j+=i;
				}
			i=RSA_verify(NID_md5_sha1, md_buf, j, p, n,
								pkey->pkey.rsa);
			if (i < 0)
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);
d1670 2
a1671 3
				}
			if (i == 0)
				{
d1673 2
a1674 2
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
a1675 1
				}
d1677 1
a1677 1
		else
d1679 1
a1679 1
			{
d1681 4
a1684 5
			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,param,param_len);
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
				{
d1686 2
a1687 2
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
a1688 1
				}
d1691 1
a1691 2
	else
		{
d1694 2
a1695 2
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d1697 1
a1697 1
			}
d1699 3
a1701 4
		if (n != 0)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);
a1702 1
			}
d1704 1
d1707 1
a1707 1
	return(1);
d1709 1
a1709 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d1727 2
a1728 2
	return(-1);
	}
d1730 8
a1737 7
int ssl3_get_certificate_request(SSL *s)
	{
	int ok,ret=0;
	unsigned long n,nc,l;
	unsigned int llen, ctype_num,i;
	X509_NAME *xn=NULL;
	const unsigned char *p,*q;
d1739 1
a1739 1
	STACK_OF(X509_NAME) *ca_sk=NULL;
d1741 6
a1746 6
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_CERT_REQ_A,
		SSL3_ST_CR_CERT_REQ_B,
		-1,
		s->max_cert_list,
		&ok);
d1748 2
a1749 1
	if (!ok) return((int)n);
d1751 1
a1751 1
	s->s3->tmp.cert_req=0;
d1753 2
a1754 3
	if (s->s3->tmp.message_type == SSL3_MT_SERVER_DONE)
		{
		s->s3->tmp.reuse_message=1;
d1758 1
a1758 2
		if (s->s3->handshake_buffer)
			{
a1760 2
			}
		return(1);
d1762 2
d1765 3
a1767 4
	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_REQUEST)
		{
		ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_WRONG_MESSAGE_TYPE);
d1769 1
a1769 1
		}
d1772 4
a1775 6
	if (s->version > SSL3_VERSION)
		{
		if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
			{
			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER);
a1776 1
			}
d1778 1
d1780 1
a1780 1
	p=d=(unsigned char *)s->init_msg;
d1782 2
a1783 3
	if ((ca_sk=sk_X509_NAME_new(ca_dn_cmp)) == NULL)
		{
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);
d1785 1
a1785 1
		}
d1790 5
a1794 6
		ctype_num=SSL3_CT_NUMBER;
	for (i=0; i<ctype_num; i++)
		s->s3->tmp.ctype[i]= p[i];
	p+=ctype_num;
	if (TLS1_get_version(s) >= TLS1_2_VERSION)
		{
d1799 3
a1801 4
		if ((unsigned long)(p - d + llen + 2) > n)
			{
			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_DATA_LENGTH_TOO_LONG);
d1803 4
a1806 5
			}
		if ((llen & 1) || !tls1_process_sigalgs(s, p, llen))
			{
			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_SIGNATURE_ALGORITHMS_ERROR);
d1808 1
a1808 1
			}
d1810 1
a1810 1
		}
d1813 1
a1813 1
	n2s(p,llen);
d1815 6
a1820 6
{
FILE *out;
out=fopen("/tmp/vsign.der","w");
fwrite(p,1,llen,out);
fclose(out);
}
d1823 3
a1825 4
	if ((unsigned long)(p - d + llen) != n)
		{
		ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_LENGTH_MISMATCH);
d1827 1
a1827 1
		}
d1829 3
a1831 5
	for (nc=0; nc<llen; )
		{
		n2s(p,l);
		if ((l+nc+2) > llen)
			{
d1834 2
a1835 2
			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_CA_DN_TOO_LONG);
d1837 1
a1837 1
			}
d1839 1
a1839 1
		q=p;
d1841 1
a1841 2
		if ((xn=d2i_X509_NAME(NULL,&q,l)) == NULL)
			{
d1845 3
a1847 4
			else
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
				SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_ASN1_LIB);
a1848 1
				}
d1850 1
d1852 3
a1854 4
		if (q != (p+l))
			{
			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_CA_DN_LENGTH_MISMATCH);
d1856 3
a1858 4
			}
		if (!sk_X509_NAME_push(ca_sk,xn))
			{
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);
d1860 1
a1860 1
			}
d1862 3
a1864 3
		p+=l;
		nc+=l+2;
		}
d1866 1
a1866 2
	if (0)
		{
d1869 1
a1869 1
		}
d1872 2
a1873 2
	s->s3->tmp.cert_req=1;
	s->s3->tmp.ctype_num=ctype_num;
d1875 3
a1877 3
		sk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);
	s->s3->tmp.ca_names=ca_sk;
	ca_sk=NULL;
d1879 1
a1879 1
	ret=1;
d1881 10
a1890 3
	if (ca_sk != NULL) sk_X509_NAME_pop_free(ca_sk,X509_NAME_free);
	return(ret);
	}
a1891 4
static int ca_dn_cmp(const X509_NAME * const *a, const X509_NAME * const *b)
	{
	return(X509_NAME_cmp(*a,*b));
	}
d1893 4
a1896 3
int ssl3_get_new_session_ticket(SSL *s)
	{
	int ok,al,ret=0, ticklen;
d1901 2
a1902 7
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_SESSION_TICKET_A,
		SSL3_ST_CR_SESSION_TICKET_B,
		-1,
		16384,
		&ok);

d1904 1
a1904 1
		return((int)n);
d1906 7
a1912 9
	if (s->s3->tmp.message_type == SSL3_MT_FINISHED)
		{
		s->s3->tmp.reuse_message=1;
		return(1);
		}
	if (s->s3->tmp.message_type != SSL3_MT_NEWSESSION_TICKET)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_BAD_MESSAGE_TYPE);
d1914 2
a1915 3
		}
	if (n < 6)
		{
d1918 1
a1918 1
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_LENGTH_MISMATCH);
d1920 1
a1920 1
		}
d1922 1
a1922 1
	p=d=(unsigned char *)s->init_msg;
d1926 1
a1926 2
	if (ticklen + 6 != n)
		{
d1928 1
a1928 1
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_LENGTH_MISMATCH);
d1930 2
a1931 3
		}
	if (s->session->tlsext_tick)
		{
d1934 1
a1934 1
		}
d1936 2
a1937 3
	if (!s->session->tlsext_tick)
		{
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,ERR_R_MALLOC_FAILURE);
d1939 1
a1939 1
		}
d1958 1
a1958 1
			s->session->session_id, &s->session->session_id_length,
d1960 1
a1960 1
							EVP_sha256(), NULL);
d1962 1
a1962 1
							EVP_sha1(), NULL);
d1964 2
a1965 2
	ret=1;
	return(ret);
d1967 1
a1967 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d1969 2
a1970 2
	return(-1);
	}
d1972 3
a1974 2
int ssl3_get_cert_status(SSL *s)
	{
d1976 1
a1976 1
	unsigned long resplen,n;
d1979 6
a1984 6
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_CERT_STATUS_A,
		SSL3_ST_CR_CERT_STATUS_B,
		SSL3_MT_CERTIFICATE_STATUS,
		16384,
		&ok);
d1986 3
a1988 3
	if (!ok) return((int)n);
	if (n < 4)
		{
d1991 1
a1991 1
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_LENGTH_MISMATCH);
d1993 1
a1993 1
		}
d1995 1
a1995 2
	if (*p++ != TLSEXT_STATUSTYPE_ocsp)
		{
d1997 1
a1997 1
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_UNSUPPORTED_STATUS_TYPE);
d1999 1
a1999 1
		}
d2001 1
a2001 2
	if (resplen + 4 != n)
		{
d2003 1
a2003 1
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_LENGTH_MISMATCH);
d2005 1
a2005 1
		}
d2009 1
a2009 2
	if (!s->tlsext_ocsp_resp)
		{
d2011 1
a2011 1
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,ERR_R_MALLOC_FAILURE);
d2013 1
a2013 1
		}
d2015 1
a2015 2
	if (s->ctx->tlsext_status_cb)
		{
d2018 1
a2018 2
		if (ret == 0)
			{
d2020 1
a2020 1
			SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_INVALID_STATUS_RESPONSE);
d2022 2
a2023 3
			}
		if (ret < 0)
			{
d2025 1
a2025 1
			SSLerr(SSL_F_SSL3_GET_CERT_STATUS,ERR_R_MALLOC_FAILURE);
a2026 1
			}
d2028 1
d2031 3
a2033 3
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
	return(-1);
	}
d2036 4
a2039 3
int ssl3_get_server_done(SSL *s)
	{
	int ok,ret=0;
d2042 3
a2044 6
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_SRVR_DONE_A,
		SSL3_ST_CR_SRVR_DONE_B,
		SSL3_MT_SERVER_DONE,
		30, /* should be very small, like 0 :-) */
		&ok);
d2046 3
a2048 3
	if (!ok) return((int)n);
	if (n > 0)
		{
d2050 2
a2051 2
		ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
		SSLerr(SSL_F_SSL3_GET_SERVER_DONE,SSL_R_LENGTH_MISMATCH);
a2052 3
		}
	ret=1;
	return(ret);
d2054 3
d2059 4
a2062 3
int ssl3_send_client_key_exchange(SSL *s)
	{
	unsigned char *p,*d;
d2067 1
a2067 1
	EVP_PKEY *pkey=NULL;
d2081 3
a2083 4
	if (s->state == SSL3_ST_CW_KEY_EXCH_A)
		{
		d=(unsigned char *)s->init_buf->data;
		p= &(d[4]);
d2085 1
a2085 1
		alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
d2088 2
a2089 1
		if (0) {}
d2091 1
a2091 2
		else if (alg_k & SSL_kRSA)
			{
d2096 3
a2098 4
				rsa=s->session->sess_cert->peer_rsa_tmp;
			else
				{
				pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
d2100 3
a2102 4
					(pkey->type != EVP_PKEY_RSA) ||
					(pkey->pkey.rsa == NULL))
					{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d2104 2
a2105 2
					}
				rsa=pkey->pkey.rsa;
d2107 6
a2112 6
				}
				
			tmp_buf[0]=s->client_version>>8;
			tmp_buf[1]=s->client_version&0xff;
			if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)
					goto err;
d2114 1
a2114 1
			s->session->master_key_length=sizeof tmp_buf;
d2116 1
a2116 1
			q=p;
d2119 3
a2121 3
				p+=2;
			n=RSA_public_encrypt(sizeof tmp_buf,
				tmp_buf,p,rsa,RSA_PKCS1_PADDING);
d2123 4
a2126 2
			if (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;
			if (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;
d2128 2
a2129 3
			if (n <= 0)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);
d2131 1
a2131 1
				}
d2134 11
a2144 12
			if (s->version > SSL3_VERSION)
				{
				s2n(n,q);
				n+=2;
				}

			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,
					tmp_buf,sizeof tmp_buf);
			OPENSSL_cleanse(tmp_buf,sizeof tmp_buf);
			}
d2147 1
a2147 2
		else if (alg_k & SSL_kKRB5)
			{
d2157 2
a2158 2
			unsigned char	epms[SSL_MAX_MASTER_KEY_LENGTH 
						+ EVP_MAX_IV_LENGTH];
d2165 1
a2165 1
				alg_k, SSL_kKRB5);
d2170 2
a2171 1
			if (KRB5SENDAUTH)  authp = &authenticator;
d2174 2
a2175 2
			krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,
				&kssl_err);
d2178 1
a2178 1
			    goto err;
d2181 3
a2183 3
			printf("kssl_cget_tkt rtn %d\n", krb5rc);
			if (krb5rc && kssl_err.text)
			  printf("kssl_cget_tkt kssl_err=%s\n", kssl_err.text);
d2187 3
a2189 4
			if (krb5rc)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,
						SSL_AD_HANDSHAKE_FAILURE);
d2191 1
a2191 1
						kssl_err.reason);
d2193 1
a2193 1
				}
d2215 1
a2215 1
			s2n(enc_ticket->length,p);
d2217 1
a2217 1
			p+= enc_ticket->length;
d2221 2
a2222 3
			if (authp  &&  authp->length)  
				{
				s2n(authp->length,p);
d2224 3
a2226 3
				p+= authp->length;
				n+= authp->length + 2;
				
d2230 1
a2230 3
				}
			else
				{
d2232 6
a2237 6
				n+=2;
				}
 
			    tmp_buf[0]=s->client_version>>8;
			    tmp_buf[1]=s->client_version&0xff;
			    if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)
d2247 7
a2253 6
			memset(iv, 0, sizeof iv);  /* per RFC 1510 */
			EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,
				kssl_ctx->key,iv);
			EVP_EncryptUpdate(&ciph_ctx,epms,&outl,tmp_buf,
				sizeof tmp_buf);
			EVP_EncryptFinal_ex(&ciph_ctx,&(epms[outl]),&padl);
d2255 1
a2255 2
			if (outl > (int)sizeof epms)
				{
d2258 1
a2258 1
				}
d2262 1
a2262 1
			s2n(outl,p);
d2264 2
a2265 2
			p+=outl;
			n+=outl + 2;
d2267 4
a2270 4
			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,
					tmp_buf, sizeof tmp_buf);
d2274 1
a2274 1
			}
d2277 2
a2278 3
		else if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
			{
			DH *dh_srvr,*dh_clnt;
d2280 3
a2282 4
			if (s->session->sess_cert == NULL) 
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
d2284 1
a2284 1
				}
d2287 2
a2288 3
				dh_srvr=s->session->sess_cert->peer_dh_tmp;
			else
				{
d2290 2
a2291 2
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);
d2293 2
a2294 2
				}
			
d2296 2
a2297 3
			if ((dh_clnt=DHparams_dup(dh_srvr)) == NULL)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
d2299 3
a2301 4
				}
			if (!DH_generate_key(dh_clnt))
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
d2304 1
a2304 1
				}
d2309 1
a2309 1
			n=DH_compute_key(p,dh_srvr->pub_key,dh_clnt);
d2311 2
a2312 3
			if (n <= 0)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
d2315 1
a2315 1
				}
d2318 3
a2320 3
			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,p,n);
d2322 1
a2322 1
			memset(p,0,n);
d2325 4
a2328 4
			n=BN_num_bytes(dh_clnt->pub_key);
			s2n(n,p);
			BN_bn2bin(dh_clnt->pub_key,p);
			n+=2;
d2333 1
a2333 1
			}
d2337 1
a2337 2
		else if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe))
			{
d2348 1
a2348 2
			if ((alg_k & (SSL_kECDHr|SSL_kECDHe)) && (s->cert != NULL)) 
				{
d2368 1
a2368 1
				}
d2370 1
a2370 2
			if (s->session->sess_cert->peer_ecdh_tmp != NULL)
				{
d2372 1
a2372 3
				}
			else
				{
d2377 2
a2378 3
				    (srvr_pub_pkey->type != EVP_PKEY_EC) ||
				    (srvr_pub_pkey->pkey.ec == NULL))
					{
d2380 1
a2380 1
					    ERR_R_INTERNAL_ERROR);
d2382 1
a2382 1
					}
d2385 1
a2385 1
				}
d2387 1
a2387 1
			srvr_group   = EC_KEY_get0_group(tkey);
d2390 1
a2390 2
			if ((srvr_group == NULL) || (srvr_ecpoint == NULL))
				{
d2392 1
a2392 1
				    ERR_R_INTERNAL_ERROR);
d2394 1
a2394 1
				}
d2396 2
a2397 3
			if ((clnt_ecdh=EC_KEY_new()) == NULL) 
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d2399 1
a2399 1
				}
d2401 2
a2402 3
			if (!EC_KEY_set_group(clnt_ecdh, srvr_group))
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
d2404 2
a2405 3
				}
			if (ecdh_clnt_cert) 
				{ 
d2413 2
a2414 3
				if (priv_key == NULL)
					{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d2416 3
a2418 4
					}
				if (!EC_KEY_set_private_key(clnt_ecdh, priv_key))
					{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
a2419 1
					}
d2421 1
a2421 2
			else 
				{
d2423 1
a2423 2
				if (!(EC_KEY_generate_key(clnt_ecdh)))
					{
a2425 1
					}
d2427 1
d2434 3
a2436 4
			if (field_size <= 0)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, 
				       ERR_R_ECDH_LIB);
d2438 5
a2442 6
				}
			n=ECDH_compute_key(p, (field_size+7)/8, srvr_ecpoint, clnt_ecdh, NULL);
			if (n <= 0)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, 
				       ERR_R_ECDH_LIB);
d2444 1
a2444 1
				}
d2449 2
a2450 2
				s->session->master_key,
				p, n);
d2454 1
a2454 2
			if (ecdh_clnt_cert) 
				{
d2457 1
a2457 3
				}
			else 
				{
d2461 10
a2470 9
				encoded_pt_len = 
				    EC_POINT_point2oct(srvr_group, 
					EC_KEY_get0_public_key(clnt_ecdh), 
					POINT_CONVERSION_UNCOMPRESSED, 
					NULL, 0, NULL);

				encodedPoint = (unsigned char *) 
				    OPENSSL_malloc(encoded_pt_len * 
					sizeof(unsigned char)); 
d2472 3
a2474 4
				if ((encodedPoint == NULL) || 
				    (bn_ctx == NULL)) 
					{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d2476 1
a2476 1
					}
d2479 4
a2482 4
				n = EC_POINT_point2oct(srvr_group, 
				    EC_KEY_get0_public_key(clnt_ecdh), 
				    POINT_CONVERSION_UNCOMPRESSED, 
				    encodedPoint, encoded_pt_len, bn_ctx);
d2486 2
a2487 1
				p += 1; 
d2491 3
a2493 2
				n += 1; 
				}
d2497 4
a2500 3
			if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
			if (clnt_ecdh != NULL) 
				 EC_KEY_free(clnt_ecdh);
d2502 1
a2502 1
			}
d2504 1
a2504 2
		else if (alg_k & SSL_kGOST) 
			{
d2507 2
a2508 1
			X509 *peer_cert; 
d2512 1
a2512 1
			unsigned char premaster_secret[32],shared_ukm[32], tmp[256];
d2517 9
a2525 9
			peer_cert=s->session->sess_cert->peer_pkeys[(keytype=SSL_PKEY_GOST01)].x509;
			if (!peer_cert) 
				peer_cert=s->session->sess_cert->peer_pkeys[(keytype=SSL_PKEY_GOST94)].x509;
			if (!peer_cert)		{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);
					goto err;
				}	
				
			pkey_ctx=EVP_PKEY_CTX_new(pub_key=X509_get_pubkey(peer_cert),NULL);
d2532 2
a2533 2
			 /* Otherwise, generate ephemeral key pair */
					
d2535 2
a2536 2
			  /* Generate session key */	
		    RAND_bytes(premaster_secret,32);
d2539 1
a2539 1
				if (EVP_PKEY_derive_set_peer(pkey_ctx,s->cert->key->privatekey) <=0) {
d2545 1
a2545 1
			}			
d2549 3
a2551 3
			EVP_DigestInit(ukm_hash,EVP_get_digestbynid(NID_id_GostR3411_94));
			EVP_DigestUpdate(ukm_hash,s->s3->client_random,SSL3_RANDOM_SIZE);
			EVP_DigestUpdate(ukm_hash,s->s3->server_random,SSL3_RANDOM_SIZE);
d2554 6
a2559 6
			if (EVP_PKEY_CTX_ctrl(pkey_ctx,-1,EVP_PKEY_OP_ENCRYPT,EVP_PKEY_CTRL_SET_IV,
				8,shared_ukm)<0) {
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
						SSL_R_LIBRARY_BUG);
					goto err;
				}	
d2562 5
a2566 5
			*(p++)=V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED;
			msglen=255;
			if (EVP_PKEY_encrypt(pkey_ctx,tmp,&msglen,premaster_secret,32)<0) {
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					SSL_R_LIBRARY_BUG);
d2569 8
a2576 11
			if (msglen >= 0x80)
				{
				*(p++)=0x81;
				*(p++)= msglen & 0xff;
				n=msglen+3;
				}
			else
				{
				*(p++)= msglen & 0xff;
				n=msglen+2;
				}
d2579 1
a2579 2
			if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0)
				{
d2582 1
a2582 1
				}
d2584 3
a2586 3
			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,premaster_secret,32);
d2589 1
a2589 1
			}
d2591 2
a2592 4
		else if (alg_k & SSL_kSRP)
			{
			if (s->srp_ctx.A != NULL)
				{
d2594 6
a2599 8
				n=BN_num_bytes(s->srp_ctx.A);
				s2n(n,p);
				BN_bn2bin(s->srp_ctx.A,p);
				n+=2;
				}
			else
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d2601 1
a2601 1
				}
d2605 1
a2605 2
			if (s->session->srp_username == NULL)
				{
d2607 1
a2607 1
					ERR_R_MALLOC_FAILURE);
d2609 1
a2609 1
				}
d2611 2
a2612 3
			if ((s->session->master_key_length = SRP_generate_client_master_secret(s,s->session->master_key))<0)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
a2613 1
				}
d2615 1
d2618 1
a2618 2
		else if (alg_k & SSL_kPSK)
			{
d2621 1
a2621 1
			unsigned char psk_or_pre_ms[PSK_MAX_PSK_LEN*2+4];
d2626 1
a2626 2
			if (s->psk_client_callback == NULL)
				{
d2628 1
a2628 1
					SSL_R_PSK_NO_CLIENT_CB);
d2630 1
a2630 1
				}
d2633 3
a2635 4
				identity, PSK_MAX_IDENTITY_LEN,
				psk_or_pre_ms, sizeof(psk_or_pre_ms));
			if (psk_len > PSK_MAX_PSK_LEN)
				{
d2637 1
a2637 1
					ERR_R_INTERNAL_ERROR);
d2639 1
a2639 3
				}
			else if (psk_len == 0)
				{
d2641 1
a2641 1
					SSL_R_PSK_IDENTITY_NOT_FOUND);
d2643 1
a2643 1
				}
d2646 1
a2646 1
			pre_ms_len = 2+psk_len+2+psk_len;
d2648 1
a2648 1
			memmove(psk_or_pre_ms+psk_len+4, psk_or_pre_ms, psk_len);
d2651 1
a2651 1
			t+=psk_len;
d2658 1
a2658 2
				s->session->psk_identity_hint == NULL)
				{
d2660 1
a2660 1
					ERR_R_MALLOC_FAILURE);
d2662 1
a2662 1
				}
d2667 1
a2667 2
			if (s->session->psk_identity == NULL)
				{
d2669 1
a2669 1
					ERR_R_MALLOC_FAILURE);
d2671 1
a2671 1
				}
d2674 4
a2677 3
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,
					psk_or_pre_ms, pre_ms_len); 
d2681 1
a2681 1
			n+=2;
d2683 1
a2683 1
		psk_err:
d2686 1
a2686 2
			if (psk_err != 0)
				{
a2688 1
				}
d2690 1
d2692 1
a2692 2
		else
			{
d2694 1
a2694 1
			    SSL_AD_HANDSHAKE_FAILURE);
d2696 1
a2696 1
			    ERR_R_INTERNAL_ERROR);
d2698 4
a2701 4
			}
		
		*(d++)=SSL3_MT_CLIENT_KEY_EXCHANGE;
		l2n3(n,d);
d2703 1
a2703 1
		s->state=SSL3_ST_CW_KEY_EXCH_B;
d2705 3
a2707 3
		s->init_num=n+4;
		s->init_off=0;
		}
d2710 1
a2710 1
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
d2714 3
a2716 2
	if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
	if (clnt_ecdh != NULL) 
d2720 2
a2721 2
	return(-1);
	}
d2723 5
a2727 4
int ssl3_send_client_verify(SSL *s)
	{
	unsigned char *p,*d;
	unsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];
d2729 1
a2729 1
	EVP_PKEY_CTX *pctx=NULL;
d2731 1
a2731 1
	unsigned u=0;
d2737 4
a2740 5
	if (s->state == SSL3_ST_CW_CERT_VRFY_A)
		{
		d=(unsigned char *)s->init_buf->data;
		p= &(d[4]);
		pkey=s->cert->key->privatekey;
d2742 1
a2742 1
		pctx = EVP_PKEY_CTX_new(pkey,NULL);
d2744 1
a2744 2
		if (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1())>0)
			{
d2747 3
a2749 5
						NID_sha1,
						&(data[MD5_DIGEST_LENGTH]));
			}
		else
			{
d2751 1
a2751 1
			}
d2755 1
a2755 2
		if (TLS1_get_version(s) >= TLS1_2_VERSION)
			{
d2760 2
a2761 3
								&hdata);
			if (hdatalen <= 0 || !tls12_get_sigandhash(p, pkey, md))
				{
d2763 1
a2763 1
						ERR_R_INTERNAL_ERROR);
d2765 1
a2765 1
				}
d2769 1
a2769 1
							EVP_MD_name(md));
d2771 3
a2773 4
			if (!EVP_SignInit_ex(&mctx, md, NULL)
				|| !EVP_SignUpdate(&mctx, hdata, hdatalen)
				|| !EVP_SignFinal(&mctx, p + 2, &u, pkey))
				{
d2775 1
a2775 1
						ERR_R_EVP_LIB);
d2777 2
a2778 2
				}
			s2n(u,p);
d2782 1
a2782 2
			}
		else
d2784 3
a2786 5
		if (pkey->type == EVP_PKEY_RSA)
			{
			s->method->ssl3_enc->cert_verify_mac(s,
				NID_md5,
			 	&(data[0]));
d2788 3
a2790 4
					 MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,
					&(p[2]), &u, pkey->pkey.rsa) <= 0 )
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);
a2791 3
				}
			s2n(u,p);
			n=u+2;
d2793 3
a2795 1
		else
d2798 1
a2798 2
			if (pkey->type == EVP_PKEY_DSA)
			{
d2800 4
a2803 5
				&(data[MD5_DIGEST_LENGTH]),
				SHA_DIGEST_LENGTH,&(p[2]),
				(unsigned int *)&j,pkey->pkey.dsa))
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB);
a2804 3
				}
			s2n(j,p);
			n=j+2;
d2806 3
a2808 1
		else
d2811 1
a2811 2
			if (pkey->type == EVP_PKEY_EC)
			{
d2813 3
a2815 4
				&(data[MD5_DIGEST_LENGTH]),
				SHA_DIGEST_LENGTH,&(p[2]),
				(unsigned int *)&j,pkey->pkey.ec))
				{
d2817 1
a2817 1
				    ERR_R_ECDSA_LIB);
a2818 3
				}
			s2n(j,p);
			n=j+2;
d2820 3
a2822 1
		else
d2824 5
a2828 6
		if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) 
		{
		unsigned char signbuf[64];
		int i;
		size_t sigsize=64;
		s->method->ssl3_enc->cert_verify_mac(s,
d2831 12
a2842 14
		if (EVP_PKEY_sign(pctx, signbuf, &sigsize, data, 32) <= 0) {
			SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
			ERR_R_INTERNAL_ERROR);
			goto err;
		}
		for (i=63,j=0; i>=0; j++, i--) {
			p[2+j]=signbuf[i];
		}	
		s2n(j,p);
		n=j+2;
		}
		else
		{
			SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);
d2845 2
a2846 2
		*(d++)=SSL3_MT_CERTIFICATE_VERIFY;
		l2n3(n,d);
d2848 4
a2851 4
		s->state=SSL3_ST_CW_CERT_VRFY_B;
		s->init_num=(int)n+4;
		s->init_off=0;
		}
d2854 1
a2854 1
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
d2858 2
a2859 2
	return(-1);
	}
d2861 5
a2865 4
int ssl3_send_client_certificate(SSL *s)
	{
	X509 *x509=NULL;
	EVP_PKEY *pkey=NULL;
d2869 4
a2872 6
	if (s->state ==	SSL3_ST_CW_CERT_A)
		{
		if ((s->cert == NULL) ||
			(s->cert->key->x509 == NULL) ||
			(s->cert->key->privatekey == NULL))
			s->state=SSL3_ST_CW_CERT_B;
d2874 2
a2875 2
			s->state=SSL3_ST_CW_CERT_C;
		}
d2878 1
a2878 2
	if (s->state == SSL3_ST_CW_CERT_B)
		{
d2882 1
a2882 1
		i=0;
d2884 26
a2909 33
		if (i < 0)
			{
			s->rwstate=SSL_X509_LOOKUP;
			return(-1);
			}
		s->rwstate=SSL_NOTHING;
		if ((i == 1) && (pkey != NULL) && (x509 != NULL))
			{
			s->state=SSL3_ST_CW_CERT_B;
			if (	!SSL_use_certificate(s,x509) ||
				!SSL_use_PrivateKey(s,pkey))
				i=0;
			}
		else if (i == 1)
			{
			i=0;
			SSLerr(SSL_F_SSL3_SEND_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
			}

		if (x509 != NULL) X509_free(x509);
		if (pkey != NULL) EVP_PKEY_free(pkey);
		if (i == 0)
			{
			if (s->version == SSL3_VERSION)
				{
				s->s3->tmp.cert_req=0;
				ssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_NO_CERTIFICATE);
				return(1);
				}
			else
				{
				s->s3->tmp.cert_req=2;
				}
d2911 1
d2914 2
a2915 2
		s->state=SSL3_ST_CW_CERT_C;
		}
d2917 7
a2923 8
	if (s->state == SSL3_ST_CW_CERT_C)
		{
		s->state=SSL3_ST_CW_CERT_D;
		l=ssl3_output_cert_chain(s,
			(s->s3->tmp.cert_req == 2)?NULL:s->cert->key->x509);
		s->init_num=(int)l;
		s->init_off=0;
		}
d2925 2
a2926 2
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
	}
d2930 6
a2935 5
int ssl3_check_cert_and_algorithm(SSL *s)
	{
	int i,idx;
	long alg_k,alg_a;
	EVP_PKEY *pkey=NULL;
d2944 2
a2945 2
	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
	alg_a=s->s3->tmp.new_cipher->algorithm_auth;
d2949 1
a2949 1
		return(1);
d2951 3
a2953 4
	sc=s->session->sess_cert;
	if (sc == NULL)
		{
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,ERR_R_INTERNAL_ERROR);
d2955 1
a2955 1
		}
d2958 1
a2958 1
	rsa=s->session->sess_cert->peer_rsa_tmp;
d2961 1
a2961 1
	dh=s->session->sess_cert->peer_dh_tmp;
d2966 1
a2966 1
	idx=sc->peer_cert_type;
d2968 1
a2968 2
	if (idx == SSL_PKEY_ECC)
		{
d2970 1
a2970 1
		    						s) == 0) 
d2972 1
a2972 1
			SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_BAD_ECC_CERT);
d2974 1
a2974 3
			}
		else 
			{
a2975 1
			}
d2977 1
d2979 2
a2980 2
	pkey=X509_get_pubkey(sc->peer_pkeys[idx].x509);
	i=X509_certificate_type(sc->peer_pkeys[idx].x509,pkey);
d2983 1
a2983 1
	
d2985 2
a2986 3
	if ((alg_a & SSL_aRSA) && !has_bits(i,EVP_PK_RSA|EVP_PKT_SIGN))
		{
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_RSA_SIGNING_CERT);
d2988 1
a2988 1
		}
d2990 2
a2991 3
	else if ((alg_a & SSL_aDSS) && !has_bits(i,EVP_PK_DSA|EVP_PKT_SIGN))
		{
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DSA_SIGNING_CERT);
d2993 1
a2993 1
		}
d2997 2
a2998 3
		!(has_bits(i,EVP_PK_RSA|EVP_PKT_ENC) || (rsa != NULL)))
		{
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_RSA_ENCRYPTING_CERT);
d3000 1
a3000 1
		}
d3004 2
a3005 3
		!(has_bits(i,EVP_PK_DH|EVP_PKT_EXCH) || (dh != NULL)))
		{
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_KEY);
d3007 2
a3008 4
		}
	else if ((alg_k & SSL_kDHr) && !has_bits(i,EVP_PK_DH|EVP_PKS_RSA))
		{
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_RSA_CERT);
d3010 1
a3010 1
		}
d3012 2
a3013 3
	else if ((alg_k & SSL_kDHd) && !has_bits(i,EVP_PK_DH|EVP_PKS_DSA))
		{
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_DSA_CERT);
d3015 1
a3015 1
		}
d3019 1
a3019 2
	if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) && !has_bits(i,EVP_PKT_EXP))
		{
d3021 4
a3024 6
		if (alg_k & SSL_kRSA)
			{
			if (rsa == NULL
			    || RSA_size(rsa)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
				{
				SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_EXPORT_TMP_RSA_KEY);
a3025 1
				}
d3027 1
a3027 1
		else
d3030 4
a3033 6
			if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
			    {
			    if (dh == NULL
				|| DH_size(dh)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
				{
				SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_EXPORT_TMP_DH_KEY);
a3034 1
				}
d3036 1
a3036 1
		else
d3038 2
a3039 2
			{
			SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
a3040 1
			}
d3042 2
a3043 1
	return(1);
d3045 1
a3045 1
	ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
d3047 2
a3048 2
	return(0);
	}
d3051 3
a3053 2
int ssl3_send_next_proto(SSL *s)
	{
d3057 1
a3057 2
	if (s->state == SSL3_ST_CW_NEXT_PROTO_A)
		{
d3065 1
a3065 1
		*(d++)=SSL3_MT_NEXT_PROTO;
d3070 1
a3070 1
		}
d3082 3
a3084 2
int ssl3_check_finished(SSL *s)
	{
d3092 4
a3095 7
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_CERT_A,
		SSL3_ST_CR_CERT_B,
		-1,
		s->max_cert_list,
		&ok);
	if (!ok) return((int)n);
d3097 2
a3098 2
	if ((s->s3->tmp.message_type == SSL3_MT_FINISHED)
		|| (s->s3->tmp.message_type == SSL3_MT_NEWSESSION_TICKET))
d3102 1
a3102 1
	}
d3105 3
a3107 2
int ssl_do_client_cert_cb(SSL *s, X509 **px509, EVP_PKEY **ppkey)
	{
d3110 1
a3110 2
	if (s->ctx->client_cert_engine)
		{
d3112 2
a3113 2
						SSL_get_client_CA_list(s),
						px509, ppkey, NULL, NULL, NULL);
d3116 1
a3116 1
		}
d3119 1
a3119 1
		i = s->ctx->client_cert_cb(s,px509,ppkey);
d3121 1
a3121 1
	}
@


1.27
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d196 1
a196 1
	clear_sys_error();
@


1.26
log
@resolve conflicts
@
text
@a461 1

d658 1
a658 1
	unsigned long Time,l;
d683 2
a684 3
		Time=(unsigned long)time(NULL);			/* Time */
		l2n(Time,p);
		if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
d988 2
d991 1
@


1.26.4.1
log
@MFC ChangeCipherSpec fixes (CVE-2014-0224 and additional safeguard), ok jsing@@

"Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret." From s3_clnt.c r1.64, s3_pkt.c r1.42,
s3_srvr.c r1.59, ssl3.h r1.19 - note that the ssl3.h change has been
applied to s3_locl.h instead to simplify patching.

"Ensure that we do not process a ChangeCipherSpec with an empty master
secret. This is an additional safeguard against early ChangeCipherSpec
handling."  From s3_pkt.c:1.43
@
text
@d562 1
a562 1
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
a919 1
	    s->s3->flags |= SSL3_FLAGS_CCS_OK;
@


1.26.4.2
log
@MFC sess_cert fix (CVE-2014-3470)

"Ensure that sess_cert is not NULL before trying to use it.
Fixes CVE-2014-3470, from OpenSSL." From s3_clnt.c r1.66
@
text
@a2512 8
			if (s->session->sess_cert == NULL) {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_UNEXPECTED_MESSAGE);
				goto err;
			}

@


1.26.4.3
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@a513 1
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
a904 1
	    		s->s3->flags |= SSL3_FLAGS_CCS_OK;
a955 9
#ifndef OPENSSL_NO_SRP
	if (((c->algorithm_mkey & SSL_kSRP) || (c->algorithm_auth & SSL_aSRP)) &&
		    !(s->srp_ctx.srp_Mask & SSL_kSRP))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);
		goto f_err;
		}
#endif /* OPENSSL_NO_SRP */
a1458 6
		if (!srp_verify_server_param(s, &al))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CIPHER_RETURNED);
			goto f_err;
			}

a2250 7

			if (s->session->sess_cert == NULL)
				{
				/* We should always have a server certificate with SSL_kRSA. */
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
				goto err;
				}
@


1.26.8.1
log
@MFC ChangeCipherSpec fixes (CVE-2014-0224 and additional safeguard), ok jsing@@

"Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret." From s3_clnt.c r1.64, s3_pkt.c r1.42,
s3_srvr.c r1.59, ssl3.h r1.19 - note that the ssl3.h change has been
applied to s3_locl.h instead to simplify patching.

"Ensure that we do not process a ChangeCipherSpec with an empty master
secret. This is an additional safeguard against early ChangeCipherSpec
handling."  From s3_pkt.c:1.43
@
text
@d562 1
a562 1
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
a919 1
	    s->s3->flags |= SSL3_FLAGS_CCS_OK;
@


1.26.8.2
log
@MFC sess_cert fix (CVE-2014-3470)

"Ensure that sess_cert is not NULL before trying to use it.
Fixes CVE-2014-3470, from OpenSSL." From s3_clnt.c r1.66
@
text
@a2512 8
			if (s->session->sess_cert == NULL) {
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    SSL_R_UNEXPECTED_MESSAGE);
				goto err;
			}

@


1.26.8.3
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@a513 1
			s->s3->flags |= SSL3_FLAGS_CCS_OK;
a904 1
	    		s->s3->flags |= SSL3_FLAGS_CCS_OK;
a955 9
#ifndef OPENSSL_NO_SRP
	if (((c->algorithm_mkey & SSL_kSRP) || (c->algorithm_auth & SSL_aSRP)) &&
		    !(s->srp_ctx.srp_Mask & SSL_kSRP))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);
		goto f_err;
		}
#endif /* OPENSSL_NO_SRP */
a1458 6
		if (!srp_verify_server_param(s, &al))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CIPHER_RETURNED);
			goto f_err;
			}

a2250 7

			if (s->session->sess_cert == NULL)
				{
				/* We should always have a server certificate with SSL_kRSA. */
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
				goto err;
				}
@


1.25
log
@OpenSSL 1.0.0f: merge
@
text
@d159 3
d206 12
d225 1
a225 1
			s->new_session=1;
d298 1
d300 8
d385 11
d461 3
d465 6
d498 9
d602 1
d692 30
d725 4
d758 9
d947 8
d986 4
a989 1
	if (!ssl3_digest_cached_records(s))
a990 1

d1269 1
d1393 80
d1720 32
d1765 1
a1765 1
		if (pkey->type == EVP_PKEY_RSA)
d1773 2
a1801 20
#ifndef OPENSSL_NO_DSA
			if (pkey->type == EVP_PKEY_DSA)
			{
			/* lets do DSS */
			EVP_VerifyInit_ex(&md_ctx,EVP_dss1(), NULL);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,param,param_len);
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		else
#endif
#ifndef OPENSSL_NO_ECDSA
			if (pkey->type == EVP_PKEY_EC)
d1803 1
a1803 2
			/* let's do ECDSA */
			EVP_VerifyInit_ex(&md_ctx,EVP_ecdsa(), NULL);
a1814 6
		else
#endif
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
d1861 1
a1861 1
	unsigned int llen,ctype_num,i;
d1881 8
d1925 20
d1957 1
a1957 1
	if ((llen+ctype_num+2+1) != n)
d2779 33
d2931 1
a2931 1
#ifndef OPENSSL_NO_RSA
a2932 1
#endif
d2936 2
d2948 2
a2949 1
			s->method->ssl3_enc->cert_verify_mac(s,
d2957 35
d3074 1
d3078 1
d3202 1
a3202 1
		    s->s3->tmp.new_cipher) == 0) 
d3297 26
@


1.24
log
@openssl-1.0.0e: resolve conflicts
@
text
@d956 1
a956 1
		goto err;
d1840 1
a1840 1
		al = SSL3_AL_FATAL,SSL_AD_DECODE_ERROR;
d1851 1
a1851 1
		al = SSL3_AL_FATAL,SSL_AD_DECODE_ERROR;
@


1.23
log
@Security fix for CVE-2010-4180 as mentioned in http://www.openssl.org/news/secadv_20101202.txt.
where clients could modify the stored session
cache ciphersuite and in some cases even downgrade the suite to weaker ones.

This code is not enabled by default.

ok djm@@
@
text
@d1514 1
d2246 1
d2258 1
@


1.22
log
@resolve conflicts, fix local changes
@
text
@d869 2
d873 1
@


1.21
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
d124 26
a158 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

d167 1
a167 1
static SSL_METHOD *ssl3_get_client_method(int ver);
a168 3
#ifndef OPENSSL_NO_TLSEXT
static int ssl3_check_finished(SSL *s);
#endif
d170 1
a170 6
#ifndef OPENSSL_NO_ECDH
static int curve_id2nid(int curve_id);
int check_srvr_ecc_cert_and_alg(X509 *x, SSL_CIPHER *cs);
#endif

static SSL_METHOD *ssl3_get_client_method(int ver)
d186 1
a186 2
	unsigned long Time=(unsigned long)time(NULL),l;
	long num1;
d281 1
d306 3
a308 1
			if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))
a382 1
			l=s->s3->tmp.new_cipher->algorithms;
d403 5
d522 5
a526 8
			/* number of bytes to be flushed */
			num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);
			if (num1 > 0)
				{
				s->rwstate=SSL_WRITING;
				num1=BIO_flush(s->wbio);
				if (num1 <= 0) { ret= -1; goto end; }
				s->rwstate=SSL_NOTHING;
d528 1
a528 1

d614 9
a622 3
		if ((s->session == NULL) ||
			(s->session->ssl_version != s->version) ||
			(s->session->not_resumable))
d677 3
a679 1
		if (s->ctx->comp_methods == NULL)
d691 1
d693 6
d704 2
a705 1
#endif		
d726 1
a726 1
	SSL_CIPHER *c;
d744 1
a744 1
	if ( SSL_version(s) == DTLS1_VERSION)
d795 17
d878 2
d890 9
d901 6
d909 6
d929 1
d932 1
a932 1
	if (s->version > SSL3_VERSION)
a947 1

d985 1
a985 1
		((s->s3->tmp.new_cipher->algorithms & SSL_aKRB5) && 
d1050 2
a1051 2
	        && (s->s3->tmp.new_cipher->algorithms & (SSL_MKEY_MASK|SSL_AUTH_MASK))
	        != (SSL_aKRB5|SSL_kKRB5)
d1053 1
a1053 1
	        )
d1077 3
a1079 3
	need_cert =	((s->s3->tmp.new_cipher->algorithms
	                 & (SSL_MKEY_MASK|SSL_AUTH_MASK))
	                 == (SSL_aKRB5|SSL_kKRB5))? 0: 1;
d1082 1
a1082 1
	printf("pkey,x = %p, %p\n", (void *)pkey,(void *)x);
d1084 2
a1085 2
	printf("cipher, alg, nc = %s, %lx, %d\n", s->s3->tmp.new_cipher->name,
	        s->s3->tmp.new_cipher->algorithms, need_cert);
d1157 1
a1157 1
	long n,alg;
a1180 1

d1185 13
a1202 1

d1233 2
a1234 1
	alg=s->s3->tmp.new_cipher->algorithms;
d1237 45
d1283 1
a1283 1
	if (alg & SSL_kRSA)
d1322 1
a1322 1
		if (alg & SSL_aRSA)
d1337 1
a1337 1
	else if (alg & SSL_kEDH)
d1391 1
a1391 1
		if (alg & SSL_aRSA)
d1398 1
a1398 1
		else if (alg & SSL_aDSS)
d1406 1
a1406 1
	else if ((alg & SSL_kDHr) || (alg & SSL_kDHd))
d1415 1
a1415 1
	else if (alg & SSL_kECDHE)
d1438 1
a1438 1
		    ((curve_nid = curve_id2nid(*(p + 2))) == 0)) 
d1499 1
a1499 1
		else if (alg & SSL_aRSA)
d1503 1
a1503 1
		else if (alg & SSL_aECDSA)
d1514 1
a1514 1
	else if (alg & SSL_kECDH)
a1520 6
	if (alg & SSL_aFZA)
		{
		al=SSL_AD_HANDSHAKE_FAILURE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
		goto f_err;
		}
a1548 2
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d1619 2
a1620 2
		/* still data left over */
		if (!(alg & SSL_aNULL))
d1625 1
d1695 1
a1695 2
		l=s->s3->tmp.new_cipher->algorithms;
		if (l & SSL_aNULL)
d1840 1
d1864 22
a1885 1
	
d1897 1
a1897 2
	unsigned long resplen;
	long n;
d1923 1
a1923 1
	if (resplen + 4 != (unsigned long)n)
d1992 1
a1992 1
	unsigned long l;
d2014 1
a2014 1
		l=s->s3->tmp.new_cipher->algorithms;
d2019 1
a2019 1
		else if (l & SSL_kRSA)
d2078 1
a2078 1
		else if (l & SSL_kKRB5)
d2086 1
a2086 1
			EVP_CIPHER	*enc = NULL;
d2097 1
a2097 1
			        l, SSL_kKRB5);
d2189 1
a2189 1
			if (outl > sizeof epms)
d2203 1
a2203 1
			        s->method->ssl3_enc->generate_master_secret(s,
d2212 1
a2212 1
		else if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
d2221 1
a2221 1
			        }
d2276 1
a2276 1
		else if ((l & SSL_kECDH) || (l & SSL_kECDHE))
d2288 1
a2288 1
			if ((l & SSL_kECDH) && (s->cert != NULL)) 
d2460 172
d2668 1
a2672 1
#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_ECDSA)
a2673 1
#endif
d2680 13
a2692 4

		s->method->ssl3_enc->cert_verify_mac(s,&(s->s3->finish_dgst2),
			&(data[MD5_DIGEST_LENGTH]));

d2697 2
a2698 1
				&(s->s3->finish_dgst1),&(data[0]));
d2744 21
a2764 1
			{
d2767 1
a2767 1
			}
d2775 1
d2778 1
d2863 1
a2863 1
	long algs;
d2873 2
a2874 3
	sc=s->session->sess_cert;

	algs=s->s3->tmp.new_cipher->algorithms;
d2877 1
a2877 1
	if (algs & (SSL_aDH|SSL_aNULL|SSL_aKRB5))
d2880 1
d2900 1
a2900 1
		if (check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509,
d2904 1
a2904 1
			goto f_err;			
d2918 1
a2918 1
	if ((algs & SSL_aRSA) && !has_bits(i,EVP_PK_RSA|EVP_PKT_SIGN))
d2924 1
a2924 1
	else if ((algs & SSL_aDSS) && !has_bits(i,EVP_PK_DSA|EVP_PKT_SIGN))
d2931 1
a2931 1
	if ((algs & SSL_kRSA) &&
d2939 1
a2939 1
	if ((algs & SSL_kEDH) &&
d2945 1
a2945 1
	else if ((algs & SSL_kDHr) && !has_bits(i,EVP_PK_DH|EVP_PKS_RSA))
d2951 1
a2951 1
	else if ((algs & SSL_kDHd) && !has_bits(i,EVP_PK_DH|EVP_PKS_DSA))
d2962 1
a2962 1
		if (algs & SSL_kRSA)
d2974 1
a2974 1
			if (algs & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
a2996 43

#ifndef OPENSSL_NO_ECDH
/* This is the complement of nid2curve_id in s3_srvr.c. */
static int curve_id2nid(int curve_id)
{
	/* ECC curves from draft-ietf-tls-ecc-01.txt (Mar 15, 2001)
	 * (no changes in draft-ietf-tls-ecc-03.txt [June 2003]) */
	static int nid_list[26] =
	{
		0,
		NID_sect163k1, /* sect163k1 (1) */
		NID_sect163r1, /* sect163r1 (2) */
		NID_sect163r2, /* sect163r2 (3) */
		NID_sect193r1, /* sect193r1 (4) */ 
		NID_sect193r2, /* sect193r2 (5) */ 
		NID_sect233k1, /* sect233k1 (6) */
		NID_sect233r1, /* sect233r1 (7) */ 
		NID_sect239k1, /* sect239k1 (8) */ 
		NID_sect283k1, /* sect283k1 (9) */
		NID_sect283r1, /* sect283r1 (10) */ 
		NID_sect409k1, /* sect409k1 (11) */ 
		NID_sect409r1, /* sect409r1 (12) */
		NID_sect571k1, /* sect571k1 (13) */ 
		NID_sect571r1, /* sect571r1 (14) */ 
		NID_secp160k1, /* secp160k1 (15) */
		NID_secp160r1, /* secp160r1 (16) */ 
		NID_secp160r2, /* secp160r2 (17) */ 
		NID_secp192k1, /* secp192k1 (18) */
		NID_X9_62_prime192v1, /* secp192r1 (19) */ 
		NID_secp224k1, /* secp224k1 (20) */ 
		NID_secp224r1, /* secp224r1 (21) */
		NID_secp256k1, /* secp256k1 (22) */ 
		NID_X9_62_prime256v1, /* secp256r1 (23) */ 
		NID_secp384r1, /* secp384r1 (24) */
		NID_secp521r1  /* secp521r1 (25) */	
	};
	
	if ((curve_id < 1) || (curve_id > 25)) return 0;

	return nid_list[curve_id];
}
#endif

d3003 1
a3003 1
static int ssl3_check_finished(SSL *s)
d3007 2
a3008 5
	/* If we have no ticket or session ID is non-zero length (a match of
	 * a non-zero session length would never reach here) it cannot be a
	 * resumed session.
	 */
	if (!s->session->tlsext_tick || s->session->session_id_length)
@


1.21.4.1
log
@Security fix for CVE-2010-4180 as mentioned in http://www.openssl.org/news/secadv_20101202.txt.
where clients could modify the stored session
cache ciphersuite and in some cases even downgrade the suite to weaker ones.

This code is not enabled by default.

ok djm@@
@
text
@a818 2
/* Workaround is now obsolete */
#if 0
a820 1
#endif
@


1.21.8.1
log
@Security fix for CVE-2010-4180 as mentioned in http://www.openssl.org/news/secadv_20101202.txt.
where clients could modify the stored session
cache ciphersuite and in some cases even downgrade the suite to weaker ones.

This code is not enabled by default.

ok djm@@
@
text
@a818 2
/* Workaround is now obsolete */
#if 0
a820 1
#endif
@


1.20
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d975 1
a975 1
	if ((s->verify_mode != SSL_VERIFY_NONE) && (!i)
d1009 1
a1009 1
	printf("pkey,x = %p, %p\n", pkey,x);
d1462 1
a1462 1
			if (!EVP_VerifyFinal(&md_ctx,p,(int)n,pkey))
d1480 1
a1480 1
			if (!EVP_VerifyFinal(&md_ctx,p,(int)n,pkey))
d1780 1
a1780 1
	if (resplen + 4 != n)
@


1.19
log
@resolve conflicts
@
text
@d133 4
d141 3
d1425 2
d2073 6
a2078 6
                        if (s->session->sess_cert == NULL) 
                                {
                                ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
                                goto err;
                                }
d2460 1
a2460 2
		if (s->ctx->client_cert_cb != NULL)
			i=s->ctx->client_cert_cb(s,&(x509),&(pkey));
d2727 18
@


1.18
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
d111 13
d133 4
a136 1
#include <openssl/fips.h>
a138 3
static int ssl3_client_hello(SSL *s);
static int ssl3_get_server_hello(SSL *s);
static int ssl3_get_certificate_request(SSL *s);
d140 9
a148 7
static int ssl3_get_server_done(SSL *s);
static int ssl3_send_client_verify(SSL *s);
static int ssl3_send_client_certificate(SSL *s);
static int ssl3_send_client_key_exchange(SSL *s);
static int ssl3_get_key_exchange(SSL *s);
static int ssl3_get_server_certificate(SSL *s);
static int ssl3_check_cert_and_algorithm(SSL *s);
d157 4
a160 22
SSL_METHOD *SSLv3_client_method(void)
	{
	static int init=1;
	static SSL_METHOD SSLv3_client_data;

	if (init)
		{
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);

		if (init)
			{
			memcpy((char *)&SSLv3_client_data,(char *)sslv3_base_method(),
				sizeof(SSL_METHOD));
			SSLv3_client_data.ssl_connect=ssl3_connect;
			SSLv3_client_data.get_ssl_method=ssl3_get_client_method;
			init=0;
			}

		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);
		}
	return(&SSLv3_client_data);
	}
d270 15
a284 1
			/* Check if it is anon DH */
d289 12
d304 1
d306 1
d365 7
d403 3
d411 1
d450 7
d462 18
d576 1
a576 1
static int ssl3_client_hello(SSL *s)
d580 1
a580 1
	int i,j;
d582 2
d585 1
d602 2
a603 2
		if(RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
		    goto err;
d624 1
a624 1
			if (i > sizeof s->session->session_id)
d644 3
d657 1
d659 7
a665 1
		
d683 1
a683 1
static int ssl3_get_server_hello(SSL *s)
d691 1
d693 1
d695 1
a695 1
	n=ssl3_get_message(s,
d698 2
a699 2
		SSL3_MT_SERVER_HELLO,
		300, /* ?? */
d703 26
d824 8
d848 19
d883 1
a883 1
static int ssl3_get_server_certificate(SSL *s)
d888 2
a889 1
	unsigned char *p,*d,*q;
d893 1
a893 1
        int need_cert = 1; /* VRS: 0=> will allow null cert if auth == KRB5 */
d895 1
a895 1
	n=ssl3_get_message(s,
d904 3
a906 1
	if (s->s3->tmp.message_type == SSL3_MT_SERVER_KEY_EXCHANGE)
d918 1
a918 1
	d=p=(unsigned char *)s->init_msg;
d970 2
a971 2
                && (s->s3->tmp.new_cipher->algorithms & (SSL_MKEY_MASK|SSL_AUTH_MASK))
                != (SSL_aKRB5|SSL_kKRB5)
d973 1
a973 1
                )
d996 4
a999 4
        /* VRS: allow null cert if auth == KRB5 */
        need_cert =	((s->s3->tmp.new_cipher->algorithms
			& (SSL_MKEY_MASK|SSL_AUTH_MASK))
                        == (SSL_aKRB5|SSL_kKRB5))? 0: 1;
d1005 1
a1005 1
                s->s3->tmp.new_cipher->algorithms, need_cert);
d1027 25
a1051 25
        if (need_cert)
                {
                sc->peer_cert_type=i;
                CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
                /* Why would the following ever happen?
                 * We just created sc a couple of lines ago. */
                if (sc->peer_pkeys[i].x509 != NULL)
                        X509_free(sc->peer_pkeys[i].x509);
                sc->peer_pkeys[i].x509=x;
                sc->peer_key= &(sc->peer_pkeys[i]);

                if (s->session->peer != NULL)
                        X509_free(s->session->peer);
                CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
                s->session->peer=x;
                }
        else
                {
                sc->peer_cert_type=i;
                sc->peer_key= NULL;

                if (s->session->peer != NULL)
                        X509_free(s->session->peer);
                s->session->peer=NULL;
                }
d1069 1
a1069 1
static int ssl3_get_key_exchange(SSL *s)
d1085 7
d1095 1
a1095 1
	n=ssl3_get_message(s,
d1128 7
d1276 108
a1393 1

a1417 2
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
a1422 1
				
d1463 18
d1516 6
d1526 1
a1526 1
static int ssl3_get_certificate_request(SSL *s)
d1532 2
a1533 1
	unsigned char *p,*d,*q;
d1536 1
a1536 1
	n=ssl3_get_message(s,
d1572 1
a1572 1
	d=p=(unsigned char *)s->init_msg;
d1673 14
d1688 124
a1811 1
static int ssl3_get_server_done(SSL *s)
d1816 1
a1816 1
	n=ssl3_get_message(s,
d1835 2
a1836 1
static int ssl3_send_client_key_exchange(SSL *s)
d1846 1
a1846 1
        KSSL_ERR kssl_err;
d1848 8
d1864 2
a1865 2
                /* Fool emacs indentation */
                if (0) {}
d1927 6
a1932 6
                        {
                        krb5_error_code	krb5rc;
                        KSSL_CTX	*kssl_ctx = s->kssl_ctx;
                        /*  krb5_data	krb5_ap_req;  */
                        krb5_data	*enc_ticket;
                        krb5_data	authenticator, *authp = NULL;
d1944 2
a1945 2
                        printf("ssl3_send_client_key_exchange(%lx & %lx)\n",
                                l, SSL_kKRB5);
d1953 1
a1953 1
                        krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,
d1956 2
a1957 2
                        if (enc == NULL)
                            goto err;
d1959 3
a1961 3
                        {
                        printf("kssl_cget_tkt rtn %d\n", krb5rc);
                        if (krb5rc && kssl_err.text)
d1963 1
a1963 1
                        }
d1966 3
a1968 3
                        if (krb5rc)
                                {
                                ssl3_send_alert(s,SSL3_AL_FATAL,
d1970 1
a1970 1
                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
d1972 2
a1973 2
                                goto err;
                                }
d1978 6
a1983 6
                        **  Send ticket (copy to *p, set n = length)
                        **  n = krb5_ap_req.length;
                        **  memcpy(p, krb5_ap_req.data, krb5_ap_req.length);
                        **  if (krb5_ap_req.data)  
                        **    kssl_krb5_free_data_contents(NULL,&krb5_ap_req);
                        **
d2018 4
a2021 2
			if (RAND_bytes(tmp_buf,sizeof tmp_buf) <= 0)
			    goto err;
d2050 2
a2051 2
                        s->session->master_key_length=
                                s->method->ssl3_enc->generate_master_secret(s,
d2057 1
a2057 1
                        }
d2064 7
d2122 186
d2310 4
a2313 2
			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d2329 7
d2339 1
a2339 1
static int ssl3_send_client_verify(SSL *s)
d2348 1
a2348 1
#ifndef OPENSSL_NO_DSA
d2394 17
d2427 1
a2427 1
static int ssl3_send_client_certificate(SSL *s)
d2506 1
a2506 1
static int ssl3_check_cert_and_algorithm(SSL *s)
d2521 6
a2532 6
	algs=s->s3->tmp.new_cipher->algorithms;

	/* we don't have a certificate */
	if (algs & (SSL_aDH|SSL_aNULL|SSL_aKRB5))
		return(1);

d2543 15
d2643 76
@


1.18.8.1
log
@Fix CVE-2008-5077: Incorrect checks for malformed signatures
@
text
@d836 1
a836 1
	if ((s->verify_mode != SSL_VERIFY_NONE) && (i <= 0)
d1203 1
a1203 1
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
@


1.18.10.1
log
@Fix CVE-2008-5077: Incorrect checks for malformed signatures
@
text
@d836 1
a836 1
	if ((s->verify_mode != SSL_VERIFY_NONE) && (i <= 0)
d1203 1
a1203 1
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
@


1.17
log
@resolve conflicts
@
text
@d168 1
a168 1
	unsigned long Time=time(NULL),l;
d536 1
a536 1
		Time=time(NULL);			/* Time */
d570 1
a570 1
		i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]));
@


1.16
log
@merge 0.9.7d
@
text
@d120 1
d538 2
a539 1
		RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));
d1165 2
d1172 1
@


1.15
log
@more fixes from 0.9.7c, ok deraadt, cloder
@
text
@d1949 1
a1949 1
			    || RSA_size(rsa) > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
d1961 1
a1961 1
				|| DH_size(dh) > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
@


1.14
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1771 1
@


1.14.2.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@a1770 1
		s->state=SSL3_ST_CW_CERT_VRFY_B;
@


1.13
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d171 1
a171 1
	int new_state,state,skip=0;;
@


1.12
log
@pull in fix from openssl-0.9.7-stable-SNAP-20020921:
  *) Don't impose a 16-byte length minimum on session IDs in ssl/s3_clnt.c
     (the SSL 3.0 and TLS 1.0 specifications allow any length up to 32 bytes).
     [Bodo Moeller]
@
text
@d148 12
a159 5
		init=0;
		memcpy((char *)&SSLv3_client_data,(char *)sslv3_base_method(),
			sizeof(SSL_METHOD));
		SSLv3_client_data.ssl_connect=ssl3_connect;
		SSLv3_client_data.get_ssl_method=ssl3_get_client_method;
d166 1
a166 1
	BUF_MEM *buf;
d227 1
d506 2
d650 1
d701 6
a706 1
	if (s->hit && (s->session->cipher != c))
d1464 1
a1464 1
			if (RAND_bytes(&(tmp_buf[2]),SSL_MAX_MASTER_KEY_LENGTH-2) <= 0)
d1467 1
a1467 1
			s->session->master_key_length=SSL_MAX_MASTER_KEY_LENGTH;
d1473 1
a1473 1
			n=RSA_public_encrypt(SSL_MAX_MASTER_KEY_LENGTH,
d1495 2
a1496 2
					tmp_buf,SSL_MAX_MASTER_KEY_LENGTH);
			memset(tmp_buf,0,SSL_MAX_MASTER_KEY_LENGTH);
d1592 1
a1592 1
			if (RAND_bytes(tmp_buf,SSL_MAX_MASTER_KEY_LENGTH) <= 0)
d1602 1
a1602 1
			memset(iv, 0, EVP_MAX_IV_LENGTH);  /* per RFC 1510 */
d1606 1
a1606 1
				SSL_MAX_MASTER_KEY_LENGTH);
d1625 1
a1625 1
					tmp_buf, SSL_MAX_MASTER_KEY_LENGTH);
d1627 2
a1628 2
			memset(tmp_buf, 0, SSL_MAX_MASTER_KEY_LENGTH);
			memset(epms, 0, outl);
@


1.12.2.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@a1754 1
		s->state=SSL3_ST_CW_CERT_VRFY_B;
@


1.12.4.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@a1754 1
		s->state=SSL3_ST_CW_CERT_VRFY_B;
@


1.11
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d634 1
a634 9
       if(j > sizeof s->session->session_id)
               {
               al=SSL_AD_ILLEGAL_PARAMETER;
               SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
                      SSL_R_SSL3_SESSION_ID_TOO_LONG);
               goto f_err;
               }

	if ((j != 0) && (j != SSL3_SESSION_ID_SIZE))
d636 3
a638 7
		/* SSLref returns 16 :-( */
		if (j < SSL2_SSL_SESSION_ID_LENGTH)
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_SHORT);
			goto f_err;
			}
d646 1
@


1.10
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d548 5
a552 1
			die(i <= sizeof s->session->session_id);
d1604 5
a1608 1
			die(outl <= sizeof epms);
@


1.9
log
@sync with http://www.openssl.org/news/patch_20020730_0_9_7.txt
(adds fix for unused kerberos and engine code, and some more
assertions, as well as a 64bit integer string fix for conf_mod.c)
@
text
@d113 2
a118 2
#include "ssl_locl.h"
#include "kssl_lcl.h"
@


1.8
log
@apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@d1600 1
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d548 1
d629 8
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d58 53
a115 2
#include <openssl/md5.h>
#include <openssl/sha.h>
d118 2
d162 1
a162 1
	void (*cb)()=NULL;
d175 1
a176 1
	s->in_handshake++;
d199 1
a199 1
				SSLerr(SSL_F_SSL3_CONNECT, SSL_R_INTERNAL_ERROR);
d497 1
a499 1
	s->in_handshake--;
d610 1
a610 1
	d=p=(unsigned char *)s->init_buf->data;
d743 1
d749 1
a749 5
#if defined(MSDOS) && !defined(WIN32)
		1024*30, /* 30k max cert list :-) */
#else
		1024*100, /* 100k max cert list :-) */
#endif
d766 1
a766 1
	d=p=(unsigned char *)s->init_buf->data;
d816 6
a821 1
	if ((s->verify_mode != SSL_VERIFY_NONE) && (!i))
d840 1
d844 13
a856 1
	if ((pkey == NULL) || EVP_PKEY_missing_parameters(pkey))
d860 2
a861 1
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);
d866 1
a866 1
	if (i < 0)
d870 2
a871 1
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNKNOWN_CERTIFICATE_TYPE);
d875 25
a899 13
	sc->peer_cert_type=i;
	CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
	if (sc->peer_pkeys[i].x509 != NULL) /* Why would this ever happen?
										 * We just created sc a couple of
										 * lines ago. */
		X509_free(sc->peer_pkeys[i].x509);
	sc->peer_pkeys[i].x509=x;
	sc->peer_key= &(sc->peer_pkeys[i]);

	if (s->session->peer != NULL)
		X509_free(s->session->peer);
	CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
	s->session->peer=x;
d919 1
a919 1
#ifndef NO_RSA
d927 1
a927 1
#ifndef NO_RSA
d930 1
a930 1
#ifndef NO_DH
d934 2
d940 1
a940 1
		1024*8, /* ?? */
d951 1
a951 1
	param=p=(unsigned char *)s->init_buf->data;
d955 1
a955 1
#ifndef NO_RSA
d962 1
a962 1
#ifndef NO_DH
d977 1
d979 1
a979 1
#ifndef NO_RSA
d1023 1
a1023 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_INTERNAL_ERROR);
d1029 1
a1029 1
#else /* NO_RSA */
d1033 1
a1033 1
#ifndef NO_DH
d1087 1
a1087 1
#ifndef NO_RSA
d1094 1
a1094 1
#ifndef NO_DSA
d1109 1
a1109 1
#endif /* !NO_DH */
d1136 1
a1136 1
#ifndef NO_RSA
d1145 2
a1146 2
				EVP_DigestInit(&md_ctx,(num == 2)
					?s->ctx->md5:s->ctx->sha1);
d1150 1
a1150 1
				EVP_DigestFinal(&md_ctx,q,(unsigned int *)&i);
d1172 1
a1172 1
#ifndef NO_DSA
d1176 1
a1176 1
			EVP_VerifyInit(&md_ctx,EVP_dss1());
d1191 1
a1191 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_INTERNAL_ERROR);
d1200 1
a1200 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_INTERNAL_ERROR);
d1211 1
d1217 1
a1217 1
#ifndef NO_RSA
d1221 1
a1221 1
#ifndef NO_DH
d1225 1
d1242 1
a1242 5
#if defined(MSDOS) && !defined(WIN32)
		1024*30,  /* 30k max cert list :-) */
#else
		1024*100, /* 100k max cert list :-) */
#endif
d1274 1
a1274 1
	d=p=(unsigned char *)s->init_buf->data;
d1394 1
d1405 1
a1405 1
#ifndef NO_RSA
d1409 3
d1420 4
a1423 2
#ifndef NO_RSA
		if (l & SSL_kRSA)
d1437 1
a1437 1
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_INTERNAL_ERROR);
a1479 1
		else
d1481 129
a1609 2
#ifndef NO_DH
		if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
d1663 1
a1664 1
#endif
d1667 1
a1667 1
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_INTERNAL_ERROR);
d1691 1
a1691 1
#ifndef NO_RSA
d1695 1
a1695 1
#ifndef NO_DSA
d1708 1
a1708 1
#ifndef NO_RSA
d1725 1
a1725 1
#ifndef NO_DSA
d1742 1
a1742 1
			SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,SSL_R_INTERNAL_ERROR);
d1841 1
a1841 1
#ifndef NO_RSA
d1844 1
a1844 1
#ifndef NO_DH
d1852 1
a1852 1
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_INTERNAL_ERROR);
d1859 1
a1859 1
	if (algs & (SSL_aDH|SSL_aNULL))
d1862 1
a1862 1
#ifndef NO_RSA
d1865 1
a1865 1
#ifndef NO_DH
d1883 1
a1883 1
#ifndef NO_DSA
d1890 1
a1890 1
#ifndef NO_RSA
d1898 1
a1898 1
#ifndef NO_DH
d1910 1
a1910 1
#ifndef NO_DSA
d1921 1
a1921 1
#ifndef NO_RSA
d1933 1
a1933 1
#ifndef NO_DH
@


1.6.4.1
log
@Pull in patch from current:
Fix (markus), errata 013:
apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@a66 1
#include "ssl_locl.h"
a494 1
			die(i <= sizeof s->session->session_id);
a574 8

       if(j > sizeof s->session->session_id)
               {
               al=SSL_AD_ILLEGAL_PARAMETER;
               SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
                      SSL_R_SSL3_SESSION_ID_TOO_LONG);
               goto f_err;
               }
@


1.6.2.1
log
@Errata #030 (markus):
Fixes for the "OpenSSL Security Advisory [30 July 2002]"
@
text
@a66 1
#include "ssl_locl.h"
a494 1
			die(i <= sizeof s->session->session_id);
a574 8

       if(j > sizeof s->session->session_id)
               {
               al=SSL_AD_ILLEGAL_PARAMETER;
               SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
                      SSL_R_SSL3_SESSION_ID_TOO_LONG);
               goto f_err;
               }
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d818 1
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d72 1
a72 1
static int ca_dn_cmp(X509_NAME **a,X509_NAME **b);
d145 6
a150 1
				abort();
d772 1
d943 3
a945 1
	else
d948 1
a948 1
		if (alg & SSL_kEDH)
d1004 3
a1006 1
		else
d1009 1
a1009 1
		if (alg & SSL_aDSS)
d1023 1
a1023 1
#endif
d1287 1
a1287 1
static int ca_dn_cmp(X509_NAME **a, X509_NAME **b)
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d775 2
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d113 1
a113 1
	RAND_seed(&Time,sizeof(Time));
d328 2
a329 2
				s->method->ssl3_enc->client_finished,
				s->method->ssl3_enc->client_finished_len);
d469 1
a469 1
		RAND_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));
d1056 3
a1058 3
			i=RSA_public_decrypt((int)n,p,p,pkey->pkey.rsa,
				RSA_PKCS1_PADDING);
			if (i <= 0)
d1064 1
a1064 1
			if ((j != i) || (memcmp(p,md_buf,i) != 0))
d1228 1
a1228 1
			/* If netscape tollerance is on, ignore errors */
d1261 1
a1261 1
	/* we should setup a certficate to return.... */
d1344 2
a1345 1
			RAND_bytes(&(tmp_buf[2]),SSL_MAX_MASTER_KEY_LENGTH-2);
d1464 1
a1464 1
	int i=0;
d1485 3
a1487 5
			i=RSA_private_encrypt(
				MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,
				data,&(p[2]),pkey->pkey.rsa,
				RSA_PKCS1_PADDING);
			if (i <= 0)
d1492 2
a1493 2
			s2n(i,p);
			n=i+2;
d1691 1
a1691 1
	if (SSL_IS_EXPORT(algs) && !has_bits(i,EVP_PKT_EXP))
d1697 1
a1697 1
			    || RSA_size(rsa) > SSL_EXPORT_PKEYLENGTH(algs))
d1709 1
a1709 1
				|| DH_size(dh) > SSL_EXPORT_PKEYLENGTH(algs))
@


1.1
log
@Initial revision
@
text
@d60 6
a65 4
#include "buffer.h"
#include "rand.h"
#include "objects.h"
#include "evp.h"
d68 1
a68 11
#define BREAK break
/* SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,ERR_R_MALLOC_FAILURE);
 * SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);
 * SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,ERR_R_MALLOC_FAILURE);
 * SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
 * SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);
 * SSLerr(SSL_F_SSL3_GET_SERVER_DONE,ERR_R_MALLOC_FAILURE);
SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_SHORT);
 */

#ifndef NOPROTO
d80 1
a80 16
#else
static int ssl3_client_hello();
static int ssl3_get_server_hello();
static int ssl3_get_certificate_request();
static int ca_dn_cmp();
static int ssl3_get_server_done();
static int ssl3_send_client_verify();
static int ssl3_send_client_certificate();
static int ssl3_send_client_key_exchange();
static int ssl3_get_key_exchange();
static int ssl3_get_server_certificate();
static int ssl3_check_cert_and_algorithm();
#endif

static SSL_METHOD *ssl3_get_client_method(ver)
int ver;
d88 1
a88 1
SSL_METHOD *SSLv3_client_method()
d104 1
a104 2
int ssl3_connect(s)
SSL *s;
a110 1
	BIO *under;
d113 1
a113 1
	RAND_seed((unsigned char *)&Time,sizeof(Time));
d134 1
a134 1
			s->ctx->sess_connect_renegotiate++;
d141 1
d174 1
a174 1
			s->ctx->sess_connect++;
d257 1
d304 5
d384 5
a388 2
			BUF_MEM_free(s->init_buf);
			s->init_buf=NULL;
d390 2
d393 2
a394 12
				{
				/* remove buffering */
				under=BIO_pop(s->wbio);
				if (under != NULL)
					s->wbio=under;
				else
					abort(); /* ok */

				BIO_free(s->bbio);
				s->bbio=NULL;
				}
			/* else do it later */
d400 1
a400 1
			if (s->hit) s->ctx->sess_hit++;
d405 1
a405 1
			s->ctx->sess_connect_good++;
d410 1
a410 1
			break;
d446 1
a446 2
static int ssl3_client_hello(s)
SSL *s;
d450 1
a450 1
	int i;
d452 1
d458 2
a459 1
			(s->session->ssl_version != s->version))
d469 1
a469 1
		RAND_bytes(&(p[4]),SSL3_RANDOM_SIZE-sizeof(Time));
d476 1
d504 12
a515 3
		/* hardwire in the NULL compression algorithm. */
		*(p++)=1;
		*(p++)=0;
d534 1
a534 2
static int ssl3_get_server_hello(s)
SSL *s;
d536 1
a536 1
	STACK *sk;
d542 1
d581 12
a592 3
	if ((j != 0) && (j == s->session->session_id_length) &&
		(memcmp(p,s->session->session_id,j) == 0))
		s->hit=1;
d621 1
a621 1
	i=sk_find(sk,(char *)c);
d643 1
d645 6
a650 1
	if (j != 0)
d656 4
d676 1
a676 2
static int ssl3_get_server_certificate(s)
SSL *s;
d682 2
a683 2
	STACK *sk=NULL;
	CERT *c;
d713 1
a713 1
	if ((sk=sk_new_null()) == NULL)
d750 1
a750 1
		if (!sk_push(sk,(char *)x))
d761 1
a761 1
        if ((s->verify_mode != SSL_VERIFY_NONE) && (!i))
d768 2
a769 2
	c=ssl_cert_new();
	if (c == NULL) goto err;
d771 2
a772 2
	if (s->session->cert) ssl_cert_free(s->session->cert);
	s->session->cert=c;
d774 2
a775 2
	c->cert_chain=sk;
	x=(X509 *)sk_value(sk,0);
d780 1
a780 1
	if (EVP_PKEY_missing_parameters(pkey))
d797 1
a797 1
	c->cert_type=i;
d799 6
a804 4
	if (c->pkeys[i].x509 != NULL)
		X509_free(c->pkeys[i].x509);
	c->pkeys[i].x509=x;
	c->key= &(c->pkeys[i]);
d806 1
a806 1
	if ((s->session != NULL) && (s->session->peer != NULL)) 
d820 3
a822 2
	if (x != NULL) X509_free(x);
	if (sk != NULL) sk_pop_free(sk,X509_free);
d826 1
a826 2
static int ssl3_get_key_exchange(s)
SSL *s;
d836 1
d838 1
d860 1
a860 1
	if (s->session->cert != NULL)
d863 1
a863 1
		if (s->session->cert->rsa_tmp != NULL)
d865 2
a866 2
			RSA_free(s->session->cert->rsa_tmp);
			s->session->cert->rsa_tmp=NULL;
d870 1
a870 1
		if (s->session->cert->dh_tmp)
d872 2
a873 2
			DH_free(s->session->cert->dh_tmp);
			s->session->cert->dh_tmp=NULL;
d879 1
a879 1
		s->session->cert=ssl_cert_new();
a923 1
/*		s->session->cert->rsa_tmp=rsa;*/
d926 1
a926 1
			pkey=X509_get_pubkey(s->session->cert->pkeys[SSL_PKEY_RSA_ENC].x509);
d932 2
a933 1
		s->session->cert->rsa_tmp=rsa;
d993 1
a993 1
			pkey=X509_get_pubkey(s->session->cert->pkeys[SSL_PKEY_RSA_ENC].x509);
d998 1
a998 1
			pkey=X509_get_pubkey(s->session->cert->pkeys[SSL_PKEY_DSA_SIGN].x509);
d1002 2
a1003 1
		s->session->cert->dh_tmp=dh;
d1012 7
d1035 1
a1035 1
			goto err;
d1112 1
a1112 1

d1117 9
d1129 1
a1129 2
static int ssl3_get_certificate_request(s)
SSL *s;
d1136 1
a1136 1
	STACK *ca_sk=NULL;
d1180 1
a1180 1
	if ((ca_sk=sk_new(ca_dn_cmp)) == NULL)
d1196 9
d1245 1
a1245 1
		if (!sk_push(ca_sk,(char *)xn))
d1265 1
a1265 1
		sk_pop_free(s->s3->tmp.ca_names,X509_NAME_free);
d1271 1
a1271 1
	if (ca_sk != NULL) sk_pop_free(ca_sk,X509_NAME_free);
d1275 1
a1275 2
static int ca_dn_cmp(a,b)
X509_NAME **a,**b;
d1280 1
a1280 2
static int ssl3_get_server_done(s)
SSL *s;
d1303 1
a1303 2
static int ssl3_send_client_key_exchange(s)
SSL *s;
d1305 1
a1305 1
	unsigned char *p,*q,*d;
d1308 2
d1311 1
d1324 1
a1324 1
			unsigned char tmp_buf[48];
d1326 2
a1327 2
			if (s->session->cert->rsa_tmp != NULL)
				rsa=s->session->cert->rsa_tmp;
d1330 1
a1330 1
				pkey=X509_get_pubkey(s->session->cert->pkeys[SSL_PKEY_RSA_ENC].x509);
d1339 1
d1342 2
a1343 2
			tmp_buf[0]=s->version>>8;
			tmp_buf[1]=s->version&0xff;
d1354 4
d1374 2
a1375 2
					tmp_buf,48);
			memset(tmp_buf,0,48);
d1384 2
a1385 2
			if (s->session->cert->dh_tmp != NULL)
				dh_srvr=s->session->cert->dh_tmp;
d1457 1
a1457 2
static int ssl3_send_client_verify(s)
SSL *s;
d1462 1
d1464 1
d1529 1
a1529 2
static int ssl3_send_client_certificate(s)
SSL *s;
d1608 1
a1608 2
static int ssl3_check_cert_and_algorithm(s)
SSL *s;
d1613 2
a1614 1
	CERT *c;
d1616 2
d1619 1
d1621 1
a1621 1
	c=s->session->cert;
d1623 1
a1623 1
	if (c == NULL)
d1635 6
a1640 2
	rsa=s->session->cert->rsa_tmp;
	dh=s->session->cert->dh_tmp;
d1644 4
a1647 3
	idx=c->cert_type;
	pkey=X509_get_pubkey(c->pkeys[idx].x509);
	i=X509_certificate_type(c->pkeys[idx].x509,pkey);
d1663 1
a1663 1

d1670 1
d1672 1
a1672 1
	else if ((algs & SSL_kEDH) &&
d1692 1
a1692 1
	if ((algs & SSL_EXP) && !has_bits(i,EVP_PKT_EXP))
d1697 2
a1698 1
			if ((rsa == NULL) || (RSA_size(rsa) > 512))
d1708 3
a1710 2
			{
			if ((dh == NULL) || (DH_size(dh) > 512))
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d60 4
a63 4
#include <openssl/buffer.h>
#include <openssl/rand.h>
#include <openssl/objects.h>
#include <openssl/evp.h>
a64 2
#include "kssl_lcl.h"
#include <openssl/md5.h>
d66 11
a76 1
static SSL_METHOD *ssl3_get_client_method(int ver);
d80 1
a80 1
static int ca_dn_cmp(const X509_NAME * const *a,const X509_NAME * const *b);
d88 16
a103 1
static SSL_METHOD *ssl3_get_client_method(int ver)
d111 1
a111 1
SSL_METHOD *SSLv3_client_method(void)
d127 2
a128 1
int ssl3_connect(SSL *s)
d133 1
a133 1
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
d135 1
d138 1
a138 1
	RAND_add(&Time,sizeof(Time),0);
d147 1
a148 1
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 
d159 1
a159 1
			s->ctx->stats.sess_connect_renegotiate++;
a165 1
			s->server=0;
d169 1
a169 6
				{
				SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);
				ret = -1;
				goto end;
				}
				
d198 1
a198 1
			s->ctx->stats.sess_connect++;
a280 1
		case SSL3_ST_CW_CERT_D:
a326 5
			if (s->s3->tmp.new_compression == NULL)
				s->session->compress_meth=0;
			else
				s->session->compress_meth=
					s->s3->tmp.new_compression->id;
d346 2
a347 2
				s->method->ssl3_enc->client_finished_label,
				s->method->ssl3_enc->client_finished_label_len);
d402 4
a405 1
			if (s->init_buf != NULL)
d407 9
a415 2
				BUF_MEM_free(s->init_buf);
				s->init_buf=NULL;
d417 1
a417 6

			/* If we are not 'joining' the last two packets,
			 * remove the buffering now */
			if (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))
				ssl_free_wbio_buffer(s);
			/* else do it later in ssl3_write */
d423 1
a423 1
			if (s->hit) s->ctx->stats.sess_hit++;
d428 1
a428 1
			s->ctx->stats.sess_connect_good++;
d433 1
a433 1
			/* break; */
a461 1
	s->in_handshake--;
d464 1
d469 2
a470 1
static int ssl3_client_hello(SSL *s)
d474 1
a474 1
	int i,j;
a475 1
	SSL_COMP *comp;
d481 1
a481 2
			(s->session->ssl_version != s->version) ||
			(s->session->not_resumable))
d491 1
a491 1
		RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));
a497 1
		s->client_version=s->version;
d525 3
a527 12
		/* COMPRESSION */
		if (s->ctx->comp_methods == NULL)
			j=0;
		else
			j=sk_SSL_COMP_num(s->ctx->comp_methods);
		*(p++)=1+j;
		for (i=0; i<j; i++)
			{
			comp=sk_SSL_COMP_value(s->ctx->comp_methods,i);
			*(p++)=comp->id;
			}
		*(p++)=0; /* Add the NULL method */
d546 2
a547 1
static int ssl3_get_server_hello(SSL *s)
d549 1
a549 1
	STACK_OF(SSL_CIPHER) *sk;
a554 1
	SSL_COMP *comp;
d564 1
a564 1
	d=p=(unsigned char *)s->init_msg;
d593 3
a595 12
	if (j != 0 && j == s->session->session_id_length
	    && memcmp(p,s->session->session_id,j) == 0)
	    {
	    if(s->sid_ctx_length != s->session->sid_ctx_length
	       || memcmp(s->session->sid_ctx,s->sid_ctx,s->sid_ctx_length))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
		goto f_err;
		}
	    s->hit=1;
	    }
d624 1
a624 1
	i=sk_SSL_CIPHER_find(sk,c);
a645 1
	/* COMPRESSION */
d647 1
a647 6
	if (j == 0)
		comp=NULL;
	else
		comp=ssl3_comp_find(s->ctx->comp_methods,j);
	
	if ((j != 0) && (comp == NULL))
a652 4
	else
		{
		s->s3->tmp.new_compression=comp;
		}
d669 2
a670 1
static int ssl3_get_server_certificate(SSL *s)
d676 2
a677 2
	STACK_OF(X509) *sk=NULL;
	SESS_CERT *sc;
a678 1
        int need_cert = 1; /* VRS: 0=> will allow null cert if auth == KRB5 */
d684 5
a688 1
		s->max_cert_list,
d705 1
a705 1
	d=p=(unsigned char *)s->init_msg;
d707 1
a707 1
	if ((sk=sk_X509_new_null()) == NULL)
d744 1
a744 1
		if (!sk_X509_push(sk,x))
d755 1
a755 6
	if ((s->verify_mode != SSL_VERIFY_NONE) && (!i)
#ifndef OPENSSL_NO_KRB5
                && (s->s3->tmp.new_cipher->algorithms & (SSL_MKEY_MASK|SSL_AUTH_MASK))
                != (SSL_aKRB5|SSL_kKRB5)
#endif /* OPENSSL_NO_KRB5 */
                )
a760 1
	ERR_clear_error(); /* but we keep s->verify_result */
d762 2
a763 2
	sc=ssl_sess_cert_new();
	if (sc == NULL) goto err;
d765 2
a766 2
	if (s->session->sess_cert) ssl_sess_cert_free(s->session->sess_cert);
	s->session->sess_cert=sc;
d768 2
a769 4
	sc->cert_chain=sk;
	/* Inconsistency alert: cert_chain does include the peer's
	 * certificate, which we don't include in s3_srvr.c */
	x=sk_X509_value(sk,0);
a770 1
 	/* VRS 19990621: possible memory leak; sk=null ==> !sk_pop_free() @@end*/
d774 1
a774 13
        /* VRS: allow null cert if auth == KRB5 */
        need_cert =	((s->s3->tmp.new_cipher->algorithms
			& (SSL_MKEY_MASK|SSL_AUTH_MASK))
                        == (SSL_aKRB5|SSL_kKRB5))? 0: 1;

#ifdef KSSL_DEBUG
	printf("pkey,x = %p, %p\n", pkey,x);
	printf("ssl_cert_type(x,pkey) = %d\n", ssl_cert_type(x,pkey));
	printf("cipher, alg, nc = %s, %lx, %d\n", s->s3->tmp.new_cipher->name,
                s->s3->tmp.new_cipher->algorithms, need_cert);
#endif    /* KSSL_DEBUG */

	if (need_cert && ((pkey == NULL) || EVP_PKEY_missing_parameters(pkey)))
d778 1
a778 2
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
			SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);
d783 1
a783 1
	if (need_cert && i < 0)
d787 1
a787 2
		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
			SSL_R_UNKNOWN_CERTIFICATE_TYPE);
d791 11
a801 26
        if (need_cert)
                {
                sc->peer_cert_type=i;
                CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
                /* Why would the following ever happen?
                 * We just created sc a couple of lines ago. */
                if (sc->peer_pkeys[i].x509 != NULL)
                        X509_free(sc->peer_pkeys[i].x509);
                sc->peer_pkeys[i].x509=x;
                sc->peer_key= &(sc->peer_pkeys[i]);

                if (s->session->peer != NULL)
                        X509_free(s->session->peer);
                CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
                s->session->peer=x;
                }
        else
                {
                sc->peer_cert_type=i;
                sc->peer_key= NULL;

                if (s->session->peer != NULL)
                        X509_free(s->session->peer);
                s->session->peer=NULL;
                }
	s->session->verify_result = s->verify_result;
d812 2
a813 3
	EVP_PKEY_free(pkey);
	X509_free(x);
	sk_X509_pop_free(sk,X509_free);
d817 2
a818 1
static int ssl3_get_key_exchange(SSL *s)
d820 1
a820 1
#ifndef OPENSSL_NO_RSA
a827 1
#ifndef OPENSSL_NO_RSA
d829 1
a829 2
#endif
#ifndef OPENSSL_NO_DH
a832 2
	/* use same message size as in ssl3_get_certificate_request()
	 * as ServerKeyExchange message may be skipped */
d837 1
a837 1
		s->max_cert_list,
d848 1
a848 1
	param=p=(unsigned char *)s->init_msg;
d850 1
a850 1
	if (s->session->sess_cert != NULL)
d852 2
a853 2
#ifndef OPENSSL_NO_RSA
		if (s->session->sess_cert->peer_rsa_tmp != NULL)
d855 2
a856 2
			RSA_free(s->session->sess_cert->peer_rsa_tmp);
			s->session->sess_cert->peer_rsa_tmp=NULL;
d859 2
a860 2
#ifndef OPENSSL_NO_DH
		if (s->session->sess_cert->peer_dh_tmp)
d862 2
a863 2
			DH_free(s->session->sess_cert->peer_dh_tmp);
			s->session->sess_cert->peer_dh_tmp=NULL;
d869 1
a869 1
		s->session->sess_cert=ssl_sess_cert_new();
a873 1
	EVP_MD_CTX_init(&md_ctx);
d875 1
a875 1
#ifndef OPENSSL_NO_RSA
d914 1
d917 1
a917 1
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
d920 1
a920 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d923 1
a923 2
		s->session->sess_cert->peer_rsa_tmp=rsa;
		rsa=NULL;
d925 1
a925 3
#else /* OPENSSL_NO_RSA */
	if (0)
		;
d927 2
a928 2
#ifndef OPENSSL_NO_DH
	else if (alg & SSL_kEDH)
d981 1
a981 1
#ifndef OPENSSL_NO_RSA
d983 2
a984 4
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
d986 3
a988 3
#ifndef OPENSSL_NO_DSA
		else if (alg & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
d992 1
a992 2
		s->session->sess_cert->peer_dh_tmp=dh;
		dh=NULL;
d1000 1
a1000 8
#endif /* !OPENSSL_NO_DH */
	if (alg & SSL_aFZA)
		{
		al=SSL_AD_HANDSHAKE_FAILURE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
		goto f_err;
		}

d1017 1
a1017 1
			goto f_err;
d1020 1
a1020 1
#ifndef OPENSSL_NO_RSA
d1029 2
a1030 2
				EVP_DigestInit_ex(&md_ctx,(num == 2)
					?s->ctx->md5:s->ctx->sha1, NULL);
d1034 1
a1034 1
				EVP_DigestFinal_ex(&md_ctx,q,(unsigned int *)&i);
d1038 3
a1040 3
			i=RSA_verify(NID_md5_sha1, md_buf, j, p, n,
								pkey->pkey.rsa);
			if (i < 0)
d1046 1
a1046 1
			if (i == 0)
d1056 1
a1056 1
#ifndef OPENSSL_NO_DSA
d1060 1
a1060 1
			EVP_VerifyInit_ex(&md_ctx,EVP_dss1(), NULL);
d1075 1
a1075 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d1084 1
a1084 1
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d1094 1
a1094 2
	EVP_PKEY_free(pkey);
	EVP_MD_CTX_cleanup(&md_ctx);
a1098 10
	EVP_PKEY_free(pkey);
#ifndef OPENSSL_NO_RSA
	if (rsa != NULL)
		RSA_free(rsa);
#endif
#ifndef OPENSSL_NO_DH
	if (dh != NULL)
		DH_free(dh);
#endif
	EVP_MD_CTX_cleanup(&md_ctx);
d1102 2
a1103 1
static int ssl3_get_certificate_request(SSL *s)
d1110 1
a1110 1
	STACK_OF(X509_NAME) *ca_sk=NULL;
d1116 5
a1120 1
		s->max_cert_list,
d1152 1
a1152 1
	d=p=(unsigned char *)s->init_msg;
d1154 1
a1154 1
	if ((ca_sk=sk_X509_NAME_new(ca_dn_cmp)) == NULL)
a1169 9
#if 0
{
FILE *out;
out=fopen("/tmp/vsign.der","w");
fwrite(p,1,llen,out);
fclose(out);
}
#endif

d1193 1
a1193 1
			/* If netscape tolerance is on, ignore errors */
d1210 1
a1210 1
		if (!sk_X509_NAME_push(ca_sk,xn))
d1226 1
a1226 1
	/* we should setup a certificate to return.... */
d1230 1
a1230 1
		sk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);
d1236 1
a1236 1
	if (ca_sk != NULL) sk_X509_NAME_pop_free(ca_sk,X509_NAME_free);
d1240 2
a1241 1
static int ca_dn_cmp(const X509_NAME * const *a, const X509_NAME * const *b)
d1246 2
a1247 1
static int ssl3_get_server_done(SSL *s)
a1264 1
		return -1;
d1270 2
a1271 1
static int ssl3_send_client_key_exchange(SSL *s)
d1273 1
a1273 1
	unsigned char *p,*d;
a1275 2
#ifndef OPENSSL_NO_RSA
	unsigned char *q;
a1276 4
#endif
#ifndef OPENSSL_NO_KRB5
        KSSL_ERR kssl_err;
#endif /* OPENSSL_NO_KRB5 */
d1285 2
a1286 4
                /* Fool emacs indentation */
                if (0) {}
#ifndef OPENSSL_NO_RSA
		else if (l & SSL_kRSA)
d1289 1
a1289 1
			unsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
d1291 2
a1292 2
			if (s->session->sess_cert->peer_rsa_tmp != NULL)
				rsa=s->session->sess_cert->peer_rsa_tmp;
d1295 1
a1295 1
				pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
d1300 1
a1300 1
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
a1303 1
				EVP_PKEY_free(pkey);
d1306 3
a1308 4
			tmp_buf[0]=s->client_version>>8;
			tmp_buf[1]=s->client_version&0xff;
			if (RAND_bytes(&(tmp_buf[2]),SSL_MAX_MASTER_KEY_LENGTH-2) <= 0)
					goto err;
a1317 4
#ifdef PKCS1_CHECK
			if (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;
			if (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;
#endif
d1334 2
a1335 2
					tmp_buf,SSL_MAX_MASTER_KEY_LENGTH);
			memset(tmp_buf,0,SSL_MAX_MASTER_KEY_LENGTH);
d1337 1
d1339 2
a1340 129
#ifndef OPENSSL_NO_KRB5
		else if (l & SSL_kKRB5)
                        {
                        krb5_error_code	krb5rc;
                        KSSL_CTX	*kssl_ctx = s->kssl_ctx;
                        /*  krb5_data	krb5_ap_req;  */
                        krb5_data	*enc_ticket;
                        krb5_data	authenticator, *authp = NULL;
			EVP_CIPHER_CTX	ciph_ctx;
			EVP_CIPHER	*enc = NULL;
			unsigned char	iv[EVP_MAX_IV_LENGTH];
			unsigned char	tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
			unsigned char	epms[SSL_MAX_MASTER_KEY_LENGTH 
						+ EVP_MAX_IV_LENGTH];
			int 		padl, outl = sizeof(epms);

			EVP_CIPHER_CTX_init(&ciph_ctx);

#ifdef KSSL_DEBUG
                        printf("ssl3_send_client_key_exchange(%lx & %lx)\n",
                                l, SSL_kKRB5);
#endif	/* KSSL_DEBUG */

			authp = NULL;
#ifdef KRB5SENDAUTH
			if (KRB5SENDAUTH)  authp = &authenticator;
#endif	/* KRB5SENDAUTH */

                        krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,
				&kssl_err);
			enc = kssl_map_enc(kssl_ctx->enctype);
                        if (enc == NULL)
                            goto err;
#ifdef KSSL_DEBUG
                        {
                        printf("kssl_cget_tkt rtn %d\n", krb5rc);
                        if (krb5rc && kssl_err.text)
			  printf("kssl_cget_tkt kssl_err=%s\n", kssl_err.text);
                        }
#endif	/* KSSL_DEBUG */

                        if (krb5rc)
                                {
                                ssl3_send_alert(s,SSL3_AL_FATAL,
						SSL_AD_HANDSHAKE_FAILURE);
                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
						kssl_err.reason);
                                goto err;
                                }

			/*  20010406 VRS - Earlier versions used KRB5 AP_REQ
			**  in place of RFC 2712 KerberosWrapper, as in:
			**
                        **  Send ticket (copy to *p, set n = length)
                        **  n = krb5_ap_req.length;
                        **  memcpy(p, krb5_ap_req.data, krb5_ap_req.length);
                        **  if (krb5_ap_req.data)  
                        **    kssl_krb5_free_data_contents(NULL,&krb5_ap_req);
                        **
			**  Now using real RFC 2712 KerberosWrapper
			**  (Thanks to Simon Wilkinson <sxw@@sxw.org.uk>)
			**  Note: 2712 "opaque" types are here replaced
			**  with a 2-byte length followed by the value.
			**  Example:
			**  KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms
			**  Where "xx xx" = length bytes.  Shown here with
			**  optional authenticator omitted.
			*/

			/*  KerberosWrapper.Ticket		*/
			s2n(enc_ticket->length,p);
			memcpy(p, enc_ticket->data, enc_ticket->length);
			p+= enc_ticket->length;
			n = enc_ticket->length + 2;

			/*  KerberosWrapper.Authenticator	*/
			if (authp  &&  authp->length)  
				{
				s2n(authp->length,p);
				memcpy(p, authp->data, authp->length);
				p+= authp->length;
				n+= authp->length + 2;
				
				free(authp->data);
				authp->data = NULL;
				authp->length = 0;
				}
			else
				{
				s2n(0,p);/*  null authenticator length	*/
				n+=2;
				}
 
			if (RAND_bytes(tmp_buf,SSL_MAX_MASTER_KEY_LENGTH) <= 0)
			    goto err;

			/*  20010420 VRS.  Tried it this way; failed.
			**	EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,NULL);
			**	EVP_CIPHER_CTX_set_key_length(&ciph_ctx,
			**				kssl_ctx->length);
			**	EVP_EncryptInit_ex(&ciph_ctx,NULL, key,iv);
			*/

			memset(iv, 0, EVP_MAX_IV_LENGTH);  /* per RFC 1510 */
			EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,
				kssl_ctx->key,iv);
			EVP_EncryptUpdate(&ciph_ctx,epms,&outl,tmp_buf,
				SSL_MAX_MASTER_KEY_LENGTH);
			EVP_EncryptFinal_ex(&ciph_ctx,&(epms[outl]),&padl);
			outl += padl;
			EVP_CIPHER_CTX_cleanup(&ciph_ctx);

			/*  KerberosWrapper.EncryptedPreMasterSecret	*/
			s2n(outl,p);
			memcpy(p, epms, outl);
			p+=outl;
			n+=outl + 2;

                        s->session->master_key_length=
                                s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,
					tmp_buf, SSL_MAX_MASTER_KEY_LENGTH);

			memset(tmp_buf, 0, SSL_MAX_MASTER_KEY_LENGTH);
			memset(epms, 0, outl);
                        }
#endif
#ifndef OPENSSL_NO_DH
		else if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
d1344 2
a1345 2
			if (s->session->sess_cert->peer_dh_tmp != NULL)
				dh_srvr=s->session->sess_cert->peer_dh_tmp;
d1394 1
a1395 1
		else
d1398 1
a1398 1
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
d1417 2
a1418 1
static int ssl3_send_client_verify(SSL *s)
d1423 1
a1423 3
#ifndef OPENSSL_NO_RSA
	unsigned u=0;
#endif
d1425 1
a1425 1
#ifndef OPENSSL_NO_DSA
d1438 1
a1438 1
#ifndef OPENSSL_NO_RSA
d1443 5
a1447 3
			if (RSA_sign(NID_md5_sha1, data,
					 MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,
					&(p[2]), &u, pkey->pkey.rsa) <= 0 )
d1452 2
a1453 2
			s2n(u,p);
			n=u+2;
d1457 1
a1457 1
#ifndef OPENSSL_NO_DSA
d1474 1
a1474 1
			SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);
d1488 2
a1489 1
static int ssl3_send_client_certificate(SSL *s)
d1568 2
a1569 1
static int ssl3_check_cert_and_algorithm(SSL *s)
d1574 1
a1574 2
	SESS_CERT *sc;
#ifndef OPENSSL_NO_RSA
a1575 2
#endif
#ifndef OPENSSL_NO_DH
a1576 1
#endif
d1578 1
a1578 1
	sc=s->session->sess_cert;
d1580 1
a1580 1
	if (sc == NULL)
d1582 1
a1582 1
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,ERR_R_INTERNAL_ERROR);
d1589 1
a1589 1
	if (algs & (SSL_aDH|SSL_aNULL|SSL_aKRB5))
d1592 2
a1593 6
#ifndef OPENSSL_NO_RSA
	rsa=s->session->sess_cert->peer_rsa_tmp;
#endif
#ifndef OPENSSL_NO_DH
	dh=s->session->sess_cert->peer_dh_tmp;
#endif
d1597 3
a1599 4
	idx=sc->peer_cert_type;
	pkey=X509_get_pubkey(sc->peer_pkeys[idx].x509);
	i=X509_certificate_type(sc->peer_pkeys[idx].x509,pkey);
	EVP_PKEY_free(pkey);
d1608 1
a1608 1
#ifndef OPENSSL_NO_DSA
d1615 1
a1615 1
#ifndef OPENSSL_NO_RSA
d1622 2
a1623 3
#endif
#ifndef OPENSSL_NO_DH
	if ((algs & SSL_kEDH) &&
d1634 1
a1634 1
#ifndef OPENSSL_NO_DSA
d1643 1
a1643 1
	if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) && !has_bits(i,EVP_PKT_EXP))
d1645 1
a1645 1
#ifndef OPENSSL_NO_RSA
d1648 1
a1648 2
			if (rsa == NULL
			    || RSA_size(rsa) > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
d1656 1
a1656 1
#ifndef OPENSSL_NO_DH
d1658 2
a1659 3
			    {
			    if (dh == NULL
				|| DH_size(dh) > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a112 2
#include "ssl_locl.h"
#include "kssl_lcl.h"
d117 2
a119 1
#include "cryptlib.h"
a547 1
			die(i <= sizeof s->session->session_id);
a628 8
       if(j > sizeof s->session->session_id)
               {
               al=SSL_AD_ILLEGAL_PARAMETER;
               SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
                      SSL_R_SSL3_SESSION_ID_TOO_LONG);
               goto f_err;
               }

a1590 1
			die(outl <= sizeof epms);
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d549 1
a549 5
			if (i > sizeof s->session->session_id)
				{
				SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
				goto err;
				}
d1601 1
a1601 5
			if (outl > sizeof epms)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
				goto err;
				}
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@d149 5
a153 12
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);

		if (init)
			{
			memcpy((char *)&SSLv3_client_data,(char *)sslv3_base_method(),
				sizeof(SSL_METHOD));
			SSLv3_client_data.ssl_connect=ssl3_connect;
			SSLv3_client_data.get_ssl_method=ssl3_get_client_method;
			init=0;
			}

		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);
d160 1
a160 1
	BUF_MEM *buf=NULL;
a220 1
				buf=NULL;
a498 2
	if (buf != NULL)
		BUF_MEM_free(buf);
d635 9
a643 1
	if ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE))
d645 7
a651 3
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_LONG);
		goto f_err;
a652 1

a658 1
		/* actually a client application bug */
d702 1
a702 6
	/* Depending on the session caching (internal/external), the cipher
	   and/or cipher_id values may not be set. Make sure that
	   cipher_id is set and use it for comparison. */
	if (s->session->cipher)
		s->session->cipher_id = s->session->cipher->id;
	if (s->hit && (s->session->cipher_id != c->id))
d1460 1
a1460 1
			if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)
d1463 1
a1463 1
			s->session->master_key_length=sizeof tmp_buf;
d1469 1
a1469 1
			n=RSA_public_encrypt(sizeof tmp_buf,
d1491 2
a1492 2
					tmp_buf,sizeof tmp_buf);
			OPENSSL_cleanse(tmp_buf,sizeof tmp_buf);
d1588 1
a1588 1
			if (RAND_bytes(tmp_buf,sizeof tmp_buf) <= 0)
d1598 1
a1598 1
			memset(iv, 0, sizeof iv);  /* per RFC 1510 */
d1602 1
a1602 1
				sizeof tmp_buf);
d1621 1
a1621 1
					tmp_buf, sizeof tmp_buf);
d1623 2
a1624 2
			OPENSSL_cleanse(tmp_buf, sizeof tmp_buf);
			OPENSSL_cleanse(epms, outl);
@


1.1.1.6
log
@import 0.9.7c
@
text
@a1771 1
		s->state=SSL3_ST_CW_CERT_VRFY_B;
@


1.1.1.7
log
@import openssl-0.9.7d
@
text
@d120 1
d1950 1
a1950 1
			    || RSA_size(rsa)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
d1962 1
a1962 1
				|| DH_size(dh)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
@


1.1.1.8
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a119 1
#include <openssl/fips.h>
d537 1
a537 2
		if(RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
		    goto err;
a1162 2
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
a1167 1
				
@


1.1.1.9
log
@import of openssl-0.9.7j
@
text
@d168 1
a168 1
	unsigned long Time=(unsigned long)time(NULL),l;
d536 1
a536 1
		Time=(unsigned long)time(NULL);			/* Time */
d570 1
a570 1
		i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),0);
@


1.1.1.10
log
@import of OpenSSL 0.9.8h
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
a110 13
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by 
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the OpenSSL open source
 * license provided above.
 *
 * ECC cipher suite support in OpenSSL originally written by
 * Vipul Gupta and Sumit Gupta of Sun Microsystems Laboratories.
 *
 */
d120 1
a120 4
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
#include <openssl/bn.h>
d123 3
d127 7
a133 9
#ifndef OPENSSL_NO_TLSEXT
static int ssl3_check_finished(SSL *s);
#endif

#ifndef OPENSSL_NO_ECDH
static int curve_id2nid(int curve_id);
int check_srvr_ecc_cert_and_alg(X509 *x, SSL_CIPHER *cs);
#endif

d142 22
a163 4
IMPLEMENT_ssl3_meth_func(SSLv3_client_method,
			ssl_undefined_function,
			ssl3_connect,
			ssl3_get_client_method)
d273 1
a273 15
#ifndef OPENSSL_NO_TLSEXT
			ret=ssl3_check_finished(s);
			if (ret <= 0) goto end;
			if (ret == 2)
				{
				s->hit = 1;
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_CR_FINISHED_A;
				s->init_num=0;
				break;
				}
#endif
			/* Check if it is anon DH/ECDH */
a277 12
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_CR_CERT_STATUS_A;
				else
					s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
#else
a280 1

a281 1
#endif
a339 7
			/* XXX: For now, we do not support client 
			 * authentication in ECDH cipher suites with
			 * ECDH (rather than ECDSA) certificates.
			 * We need to skip the certificate verify 
			 * message when client's ECDH public key is sent 
			 * inside the client certificate.
			 */
a370 3
#ifdef OPENSSL_NO_COMP
			s->session->compress_meth=0;
#else
a375 1
#endif
a413 7
#ifndef OPENSSL_NO_TLSEXT
				/* Allow NewSessionTicket if ticket expected */
				if (s->tlsext_ticket_expected)
					s->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;
				else
#endif
				
a418 18
#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_CR_SESSION_TICKET_A:
		case SSL3_ST_CR_SESSION_TICKET_B:
			ret=ssl3_get_new_session_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_FINISHED_A;
			s->init_num=0;
		break;

		case SSL3_ST_CR_CERT_STATUS_A:
		case SSL3_ST_CR_CERT_STATUS_B:
			ret=ssl3_get_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_KEY_EXCH_A;
			s->init_num=0;
		break;
#endif

d515 1
a515 1
int ssl3_client_hello(SSL *s)
d519 1
a519 1
	int i;
a520 2
#ifndef OPENSSL_NO_COMP
	int j;
a521 1
#endif
d538 2
a539 2
		if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
			goto err;
d560 1
a560 1
			if (i > (int)sizeof(s->session->session_id))
a579 3
#ifdef OPENSSL_NO_COMP
		*(p++)=1;
#else
a589 1
#endif
d591 1
a591 7
#ifndef OPENSSL_NO_TLSEXT
		if ((p = ssl_add_clienthello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
			{
			SSLerr(SSL_F_SSL3_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);
			goto err;
			}
#endif		
d609 1
a609 1
int ssl3_get_server_hello(SSL *s)
a616 1
#ifndef OPENSSL_NO_COMP
a617 1
#endif
d619 1
a619 1
	n=s->method->ssl_get_message(s,
d622 2
a623 2
		-1,
		20000, /* ?? */
a626 26

	if ( SSL_version(s) == DTLS1_VERSION)
		{
		if ( s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST)
			{
			if ( s->d1->send_cookie == 0)
				{
				s->s3->tmp.reuse_message = 1;
				return 1;
				}
			else /* already sent a cookie */
				{
				al=SSL_AD_UNEXPECTED_MESSAGE;
				SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);
				goto f_err;
				}
			}
		}
	
	if ( s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);
		goto f_err;
		}

a721 8
#ifdef OPENSSL_NO_COMP
	if (*(p++) != 0)
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
		goto f_err;
		}
#else
a737 19
#endif
#ifndef OPENSSL_NO_TLSEXT
	/* TLS extensions*/
	if (s->version > SSL3_VERSION)
		{
		if (!ssl_parse_serverhello_tlsext(s,&p,d,n, &al))
			{
			/* 'al' set by ssl_parse_serverhello_tlsext */
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_PARSE_TLSEXT);
			goto f_err; 
			}
		if (ssl_check_serverhello_tlsext(s) <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);
				goto err;
			}
		}
#endif

d754 1
a754 1
int ssl3_get_server_certificate(SSL *s)
d759 1
a759 2
	const unsigned char *q,*p;
	unsigned char *d;
d763 1
a763 1
	int need_cert = 1; /* VRS: 0=> will allow null cert if auth == KRB5 */
d765 1
a765 1
	n=s->method->ssl_get_message(s,
d774 1
a774 3
	if ((s->s3->tmp.message_type == SSL3_MT_SERVER_KEY_EXCHANGE) ||
		((s->s3->tmp.new_cipher->algorithms & SSL_aKRB5) && 
		(s->s3->tmp.message_type == SSL3_MT_SERVER_DONE)))
d786 1
a786 1
	p=d=(unsigned char *)s->init_msg;
d838 2
a839 2
	        && (s->s3->tmp.new_cipher->algorithms & (SSL_MKEY_MASK|SSL_AUTH_MASK))
	        != (SSL_aKRB5|SSL_kKRB5)
d841 1
a841 1
	        )
d864 4
a867 4
	/* VRS: allow null cert if auth == KRB5 */
	need_cert =	((s->s3->tmp.new_cipher->algorithms
	                 & (SSL_MKEY_MASK|SSL_AUTH_MASK))
	                 == (SSL_aKRB5|SSL_kKRB5))? 0: 1;
d873 1
a873 1
	        s->s3->tmp.new_cipher->algorithms, need_cert);
d895 25
a919 25
	if (need_cert)
		{
		sc->peer_cert_type=i;
		CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
		/* Why would the following ever happen?
		 * We just created sc a couple of lines ago. */
		if (sc->peer_pkeys[i].x509 != NULL)
			X509_free(sc->peer_pkeys[i].x509);
		sc->peer_pkeys[i].x509=x;
		sc->peer_key= &(sc->peer_pkeys[i]);

		if (s->session->peer != NULL)
			X509_free(s->session->peer);
		CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
		s->session->peer=x;
		}
	else
		{
		sc->peer_cert_type=i;
		sc->peer_key= NULL;

		if (s->session->peer != NULL)
			X509_free(s->session->peer);
		s->session->peer=NULL;
		}
d937 1
a937 1
int ssl3_get_key_exchange(SSL *s)
a952 7
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh = NULL;
	BN_CTX *bn_ctx = NULL;
	EC_POINT *srvr_ecpoint = NULL;
	int curve_nid = 0;
	int encoded_pt_len = 0;
#endif
d956 1
a956 1
	n=s->method->ssl_get_message(s,
a988 7
#ifndef OPENSSL_NO_ECDH
		if (s->session->sess_cert->peer_ecdh_tmp)
			{
			EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
			s->session->sess_cert->peer_ecdh_tmp=NULL;
			}
#endif
a1129 108

#ifndef OPENSSL_NO_ECDH
	else if (alg & SSL_kECDHE)
		{
		EC_GROUP *ngroup;
		const EC_GROUP *group;

		if ((ecdh=EC_KEY_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		/* Extract elliptic curve parameters and the
		 * server's ephemeral ECDH public key.
		 * Keep accumulating lengths of various components in
		 * param_len and make sure it never exceeds n.
		 */

		/* XXX: For now we only support named (not generic) curves
		 * and the ECParameters in this case is just three bytes.
		 */
		param_len=3;
		if ((param_len > n) ||
		    (*p != NAMED_CURVE_TYPE) || 
		    ((curve_nid = curve_id2nid(*(p + 2))) == 0)) 
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
			goto f_err;
			}

		ngroup = EC_GROUP_new_by_curve_name(curve_nid);
		if (ngroup == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		if (EC_KEY_set_group(ecdh, ngroup) == 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		EC_GROUP_free(ngroup);

		group = EC_KEY_get0_group(ecdh);

		if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
		    (EC_GROUP_get_degree(group) > 163))
			{
			al=SSL_AD_EXPORT_RESTRICTION;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
			goto f_err;
			}

		p+=3;

		/* Next, get the encoded ECPoint */
		if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
		    ((bn_ctx = BN_CTX_new()) == NULL))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		encoded_pt_len = *p;  /* length of encoded point */
		p+=1;
		param_len += (1 + encoded_pt_len);
		if ((param_len > n) ||
		    (EC_POINT_oct2point(group, srvr_ecpoint, 
			p, encoded_pt_len, bn_ctx) == 0))
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);
			goto f_err;
			}

		n-=param_len;
		p+=encoded_pt_len;

		/* The ECC/TLS specification does not mention
		 * the use of DSA to sign ECParameters in the server
		 * key exchange message. We do support RSA and ECDSA.
		 */
		if (0) ;
#ifndef OPENSSL_NO_RSA
		else if (alg & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#endif
#ifndef OPENSSL_NO_ECDSA
		else if (alg & SSL_aECDSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
#endif
		/* else anonymous ECDH, so no certificate or pkey. */
		EC_KEY_set_public_key(ecdh, srvr_ecpoint);
		s->session->sess_cert->peer_ecdh_tmp=ecdh;
		ecdh=NULL;
		BN_CTX_free(bn_ctx);
		EC_POINT_free(srvr_ecpoint);
		srvr_ecpoint = NULL;
		}
	else if (alg & SSL_kECDH)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
		goto f_err;
		}
#endif /* !OPENSSL_NO_ECDH */
d1140 1
d1165 2
d1172 1
a1212 18
#ifndef OPENSSL_NO_ECDSA
			if (pkey->type == EVP_PKEY_EC)
			{
			/* let's do ECDSA */
			EVP_VerifyInit_ex(&md_ctx,EVP_ecdsa(), NULL);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,param,param_len);
			if (!EVP_VerifyFinal(&md_ctx,p,(int)n,pkey))
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		else
#endif
a1247 6
#ifndef OPENSSL_NO_ECDH
	BN_CTX_free(bn_ctx);
	EC_POINT_free(srvr_ecpoint);
	if (ecdh != NULL)
		EC_KEY_free(ecdh);
#endif
d1252 1
a1252 1
int ssl3_get_certificate_request(SSL *s)
d1258 1
a1258 2
	const unsigned char *p,*q;
	unsigned char *d;
d1261 1
a1261 1
	n=s->method->ssl_get_message(s,
d1297 1
a1297 1
	p=d=(unsigned char *)s->init_msg;
a1397 14
#ifndef OPENSSL_NO_TLSEXT
int ssl3_get_new_session_ticket(SSL *s)
	{
	int ok,al,ret=0, ticklen;
	long n;
	const unsigned char *p;
	unsigned char *d;

	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_SESSION_TICKET_A,
		SSL3_ST_CR_SESSION_TICKET_B,
		-1,
		16384,
		&ok);
d1399 1
a1399 124
	if (!ok)
		return((int)n);

	if (s->s3->tmp.message_type == SSL3_MT_FINISHED)
		{
		s->s3->tmp.reuse_message=1;
		return(1);
		}
	if (s->s3->tmp.message_type != SSL3_MT_NEWSESSION_TICKET)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_BAD_MESSAGE_TYPE);
		goto f_err;
		}
	if (n < 6)
		{
		/* need at least ticket_lifetime_hint + ticket length */
		al = SSL3_AL_FATAL,SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_LENGTH_MISMATCH);
		goto f_err;
		}
	p=d=(unsigned char *)s->init_msg;
	n2l(p, s->session->tlsext_tick_lifetime_hint);
	n2s(p, ticklen);
	/* ticket_lifetime_hint + ticket_length + ticket */
	if (ticklen + 6 != n)
		{
		al = SSL3_AL_FATAL,SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_LENGTH_MISMATCH);
		goto f_err;
		}
	if (s->session->tlsext_tick)
		{
		OPENSSL_free(s->session->tlsext_tick);
		s->session->tlsext_ticklen = 0;
		}
	s->session->tlsext_tick = OPENSSL_malloc(ticklen);
	if (!s->session->tlsext_tick)
		{
		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,ERR_R_MALLOC_FAILURE);
		goto err;
		}
	memcpy(s->session->tlsext_tick, p, ticklen);
	s->session->tlsext_ticklen = ticklen;
	
	ret=1;
	return(ret);
f_err:
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
err:
	return(-1);
	}

int ssl3_get_cert_status(SSL *s)
	{
	int ok, al;
	unsigned long resplen;
	long n;
	const unsigned char *p;

	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_CERT_STATUS_A,
		SSL3_ST_CR_CERT_STATUS_B,
		SSL3_MT_CERTIFICATE_STATUS,
		16384,
		&ok);

	if (!ok) return((int)n);
	if (n < 4)
		{
		/* need at least status type + length */
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_LENGTH_MISMATCH);
		goto f_err;
		}
	p = (unsigned char *)s->init_msg;
	if (*p++ != TLSEXT_STATUSTYPE_ocsp)
		{
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_UNSUPPORTED_STATUS_TYPE);
		goto f_err;
		}
	n2l3(p, resplen);
	if (resplen + 4 != n)
		{
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_LENGTH_MISMATCH);
		goto f_err;
		}
	if (s->tlsext_ocsp_resp)
		OPENSSL_free(s->tlsext_ocsp_resp);
	s->tlsext_ocsp_resp = BUF_memdup(p, resplen);
	if (!s->tlsext_ocsp_resp)
		{
		al = SSL_AD_INTERNAL_ERROR;
		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,ERR_R_MALLOC_FAILURE);
		goto f_err;
		}
	s->tlsext_ocsp_resplen = resplen;
	if (s->ctx->tlsext_status_cb)
		{
		int ret;
		ret = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);
		if (ret == 0)
			{
			al = SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE;
			SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_INVALID_STATUS_RESPONSE);
			goto f_err;
			}
		if (ret < 0)
			{
			al = SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_STATUS,ERR_R_MALLOC_FAILURE);
			goto f_err;
			}
		}
	return 1;
f_err:
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
	return(-1);
	}
#endif

int ssl3_get_server_done(SSL *s)
d1404 1
a1404 1
	n=s->method->ssl_get_message(s,
d1423 1
a1423 2

int ssl3_send_client_key_exchange(SSL *s)
d1433 1
a1433 1
	KSSL_ERR kssl_err;
a1434 8
#ifndef OPENSSL_NO_ECDH
	EC_KEY *clnt_ecdh = NULL;
	const EC_POINT *srvr_ecpoint = NULL;
	EVP_PKEY *srvr_pub_pkey = NULL;
	unsigned char *encodedPoint = NULL;
	int encoded_pt_len = 0;
	BN_CTX * bn_ctx = NULL;
#endif
d1443 2
a1444 2
		/* Fool emacs indentation */
		if (0) {}
d1506 6
a1511 6
			{
			krb5_error_code	krb5rc;
			KSSL_CTX	*kssl_ctx = s->kssl_ctx;
			/*  krb5_data	krb5_ap_req;  */
			krb5_data	*enc_ticket;
			krb5_data	authenticator, *authp = NULL;
d1523 2
a1524 2
			printf("ssl3_send_client_key_exchange(%lx & %lx)\n",
			        l, SSL_kKRB5);
d1532 1
a1532 1
			krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,
d1535 2
a1536 2
			if (enc == NULL)
			    goto err;
d1538 3
a1540 3
			{
			printf("kssl_cget_tkt rtn %d\n", krb5rc);
			if (krb5rc && kssl_err.text)
d1542 1
a1542 1
			}
d1545 3
a1547 3
			if (krb5rc)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,
d1549 1
a1549 1
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
d1551 2
a1552 2
				goto err;
				}
d1557 6
a1562 6
			**  Send ticket (copy to *p, set n = length)
			**  n = krb5_ap_req.length;
			**  memcpy(p, krb5_ap_req.data, krb5_ap_req.length);
			**  if (krb5_ap_req.data)  
			**    kssl_krb5_free_data_contents(NULL,&krb5_ap_req);
			**
d1597 2
a1598 4
			    tmp_buf[0]=s->client_version>>8;
			    tmp_buf[1]=s->client_version&0xff;
			    if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)
				goto err;
d1627 2
a1628 2
			s->session->master_key_length=
			        s->method->ssl3_enc->generate_master_secret(s,
d1634 1
a1634 1
			}
a1640 7
                        if (s->session->sess_cert == NULL) 
                                {
                                ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
                                goto err;
                                }

a1691 186

#ifndef OPENSSL_NO_ECDH 
		else if ((l & SSL_kECDH) || (l & SSL_kECDHE))
			{
			const EC_GROUP *srvr_group = NULL;
			EC_KEY *tkey;
			int ecdh_clnt_cert = 0;
			int field_size = 0;

			/* Did we send out the client's
			 * ECDH share for use in premaster
			 * computation as part of client certificate?
			 * If so, set ecdh_clnt_cert to 1.
			 */
			if ((l & SSL_kECDH) && (s->cert != NULL)) 
				{
				/* XXX: For now, we do not support client
				 * authentication using ECDH certificates.
				 * To add such support, one needs to add
				 * code that checks for appropriate 
				 * conditions and sets ecdh_clnt_cert to 1.
				 * For example, the cert have an ECC
				 * key on the same curve as the server's
				 * and the key should be authorized for
				 * key agreement.
				 *
				 * One also needs to add code in ssl3_connect
				 * to skip sending the certificate verify
				 * message.
				 *
				 * if ((s->cert->key->privatekey != NULL) &&
				 *     (s->cert->key->privatekey->type ==
				 *      EVP_PKEY_EC) && ...)
				 * ecdh_clnt_cert = 1;
				 */
				}

			if (s->session->sess_cert->peer_ecdh_tmp != NULL)
				{
				tkey = s->session->sess_cert->peer_ecdh_tmp;
				}
			else
				{
				/* Get the Server Public Key from Cert */
				srvr_pub_pkey = X509_get_pubkey(s->session-> \
				    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
				if ((srvr_pub_pkey == NULL) ||
				    (srvr_pub_pkey->type != EVP_PKEY_EC) ||
				    (srvr_pub_pkey->pkey.ec == NULL))
					{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					    ERR_R_INTERNAL_ERROR);
					goto err;
					}

				tkey = srvr_pub_pkey->pkey.ec;
				}

			srvr_group   = EC_KEY_get0_group(tkey);
			srvr_ecpoint = EC_KEY_get0_public_key(tkey);

			if ((srvr_group == NULL) || (srvr_ecpoint == NULL))
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
				}

			if ((clnt_ecdh=EC_KEY_new()) == NULL) 
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
				goto err;
				}

			if (!EC_KEY_set_group(clnt_ecdh, srvr_group))
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
				goto err;
				}
			if (ecdh_clnt_cert) 
				{ 
				/* Reuse key info from our certificate
				 * We only need our private key to perform
				 * the ECDH computation.
				 */
				const BIGNUM *priv_key;
				tkey = s->cert->key->privatekey->pkey.ec;
				priv_key = EC_KEY_get0_private_key(tkey);
				if (priv_key == NULL)
					{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
					goto err;
					}
				if (!EC_KEY_set_private_key(clnt_ecdh, priv_key))
					{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
					goto err;
					}
				}
			else 
				{
				/* Generate a new ECDH key pair */
				if (!(EC_KEY_generate_key(clnt_ecdh)))
					{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);
					goto err;
					}
				}

			/* use the 'p' output buffer for the ECDH key, but
			 * make sure to clear it out afterwards
			 */

			field_size = EC_GROUP_get_degree(srvr_group);
			if (field_size <= 0)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, 
				       ERR_R_ECDH_LIB);
				goto err;
				}
			n=ECDH_compute_key(p, (field_size+7)/8, srvr_ecpoint, clnt_ecdh, NULL);
			if (n <= 0)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, 
				       ERR_R_ECDH_LIB);
				goto err;
				}

			/* generate master key from the result */
			s->session->master_key_length = s->method->ssl3_enc \
			    -> generate_master_secret(s, 
				s->session->master_key,
				p, n);

			memset(p, 0, n); /* clean up */

			if (ecdh_clnt_cert) 
				{
				/* Send empty client key exch message */
				n = 0;
				}
			else 
				{
				/* First check the size of encoding and
				 * allocate memory accordingly.
				 */
				encoded_pt_len = 
				    EC_POINT_point2oct(srvr_group, 
					EC_KEY_get0_public_key(clnt_ecdh), 
					POINT_CONVERSION_UNCOMPRESSED, 
					NULL, 0, NULL);

				encodedPoint = (unsigned char *) 
				    OPENSSL_malloc(encoded_pt_len * 
					sizeof(unsigned char)); 
				bn_ctx = BN_CTX_new();
				if ((encodedPoint == NULL) || 
				    (bn_ctx == NULL)) 
					{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
					goto err;
					}

				/* Encode the public key */
				n = EC_POINT_point2oct(srvr_group, 
				    EC_KEY_get0_public_key(clnt_ecdh), 
				    POINT_CONVERSION_UNCOMPRESSED, 
				    encodedPoint, encoded_pt_len, bn_ctx);

				*p = n; /* length of encoded point */
				/* Encoded point will be copied here */
				p += 1; 
				/* copy the point */
				memcpy((unsigned char *)p, encodedPoint, n);
				/* increment n to account for length field */
				n += 1; 
				}

			/* Free allocated memory */
			BN_CTX_free(bn_ctx);
			if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
			if (clnt_ecdh != NULL) 
				 EC_KEY_free(clnt_ecdh);
			EVP_PKEY_free(srvr_pub_pkey);
			}
#endif /* !OPENSSL_NO_ECDH */
d1694 2
a1695 4
			ssl3_send_alert(s, SSL3_AL_FATAL,
			    SSL_AD_HANDSHAKE_FAILURE);
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
			    ERR_R_INTERNAL_ERROR);
a1710 7
#ifndef OPENSSL_NO_ECDH
	BN_CTX_free(bn_ctx);
	if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
	if (clnt_ecdh != NULL) 
		EC_KEY_free(clnt_ecdh);
	EVP_PKEY_free(srvr_pub_pkey);
#endif
d1714 1
a1714 1
int ssl3_send_client_verify(SSL *s)
d1723 1
a1723 1
#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_ECDSA)
a1768 17
#ifndef OPENSSL_NO_ECDSA
			if (pkey->type == EVP_PKEY_EC)
			{
			if (!ECDSA_sign(pkey->save_type,
				&(data[MD5_DIGEST_LENGTH]),
				SHA_DIGEST_LENGTH,&(p[2]),
				(unsigned int *)&j,pkey->pkey.ec))
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
				    ERR_R_ECDSA_LIB);
				goto err;
				}
			s2n(j,p);
			n=j+2;
			}
		else
#endif
d1785 1
a1785 1
int ssl3_send_client_certificate(SSL *s)
d1864 1
a1864 1
int ssl3_check_cert_and_algorithm(SSL *s)
d1879 6
a1890 6
	if (sc == NULL)
		{
		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,ERR_R_INTERNAL_ERROR);
		goto err;
		}

a1900 15
#ifndef OPENSSL_NO_ECDH
	if (idx == SSL_PKEY_ECC)
		{
		if (check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509,
		    s->s3->tmp.new_cipher) == 0) 
			{ /* check failed */
			SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_BAD_ECC_CERT);
			goto f_err;			
			}
		else 
			{
			return 1;
			}
		}
#endif
a1985 76

#ifndef OPENSSL_NO_ECDH
/* This is the complement of nid2curve_id in s3_srvr.c. */
static int curve_id2nid(int curve_id)
{
	/* ECC curves from draft-ietf-tls-ecc-01.txt (Mar 15, 2001)
	 * (no changes in draft-ietf-tls-ecc-03.txt [June 2003]) */
	static int nid_list[26] =
	{
		0,
		NID_sect163k1, /* sect163k1 (1) */
		NID_sect163r1, /* sect163r1 (2) */
		NID_sect163r2, /* sect163r2 (3) */
		NID_sect193r1, /* sect193r1 (4) */ 
		NID_sect193r2, /* sect193r2 (5) */ 
		NID_sect233k1, /* sect233k1 (6) */
		NID_sect233r1, /* sect233r1 (7) */ 
		NID_sect239k1, /* sect239k1 (8) */ 
		NID_sect283k1, /* sect283k1 (9) */
		NID_sect283r1, /* sect283r1 (10) */ 
		NID_sect409k1, /* sect409k1 (11) */ 
		NID_sect409r1, /* sect409r1 (12) */
		NID_sect571k1, /* sect571k1 (13) */ 
		NID_sect571r1, /* sect571r1 (14) */ 
		NID_secp160k1, /* secp160k1 (15) */
		NID_secp160r1, /* secp160r1 (16) */ 
		NID_secp160r2, /* secp160r2 (17) */ 
		NID_secp192k1, /* secp192k1 (18) */
		NID_X9_62_prime192v1, /* secp192r1 (19) */ 
		NID_secp224k1, /* secp224k1 (20) */ 
		NID_secp224r1, /* secp224r1 (21) */
		NID_secp256k1, /* secp256k1 (22) */ 
		NID_X9_62_prime256v1, /* secp256r1 (23) */ 
		NID_secp384r1, /* secp384r1 (24) */
		NID_secp521r1  /* secp521r1 (25) */	
	};
	
	if ((curve_id < 1) || (curve_id > 25)) return 0;

	return nid_list[curve_id];
}
#endif

/* Check to see if handshake is full or resumed. Usually this is just a
 * case of checking to see if a cache hit has occurred. In the case of
 * session tickets we have to check the next message to be sure.
 */

#ifndef OPENSSL_NO_TLSEXT
static int ssl3_check_finished(SSL *s)
	{
	int ok;
	long n;
	/* If we have no ticket or session ID is non-zero length (a match of
	 * a non-zero session length would never reach here) it cannot be a
	 * resumed session.
	 */
	if (!s->session->tlsext_tick || s->session->session_id_length)
		return 1;
	/* this function is called when we really expect a Certificate
	 * message, so permit appropriate message length */
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_CERT_A,
		SSL3_ST_CR_CERT_B,
		-1,
		s->max_cert_list,
		&ok);
	if (!ok) return((int)n);
	s->s3->tmp.reuse_message = 1;
	if ((s->s3->tmp.message_type == SSL3_MT_FINISHED)
		|| (s->s3->tmp.message_type == SSL3_MT_NEWSESSION_TICKET))
		return 2;

	return 1;
	}
#endif
@


1.1.1.11
log
@import openssl-0.9.8j
@
text
@a132 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a136 3
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif
d968 1
a968 1
	if ((s->verify_mode != SSL_VERIFY_NONE) && (i <= 0)
d1002 1
a1002 1
	printf("pkey,x = %p, %p\n", (void *)pkey,(void *)x);
a1417 2
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d1453 1
a1453 1
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
d1471 1
a1471 1
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
d1771 1
a1771 1
	if (resplen + 4 != (unsigned long)n)
d2064 6
a2069 6
			if (s->session->sess_cert == NULL) 
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
				goto err;
			        }
d2451 2
a2452 1
		i = ssl_do_client_cert_cb(s, &x509, &pkey);
a2718 18

int ssl_do_client_cert_cb(SSL *s, X509 **px509, EVP_PKEY **ppkey)
	{
	int i = 0;
#ifndef OPENSSL_NO_ENGINE
	if (s->ctx->client_cert_engine)
		{
		i = ENGINE_load_ssl_client_cert(s->ctx->client_cert_engine, s,
						SSL_get_client_CA_list(s),
						px509, ppkey, NULL, NULL, NULL);
		if (i != 0)
			return i;
		}
#endif
	if (s->ctx->client_cert_cb)
		i = s->ctx->client_cert_cb(s,px509,ppkey);
	return i;
	}
@


1.1.1.12
log
@import of OpenSSL 0.9.8k
@
text
@d176 1
a176 1
	int new_state,state,skip=0;
@


1.1.1.13
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
a123 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
d133 4
d145 1
a145 1
static const SSL_METHOD *ssl3_get_client_method(int ver);
d147 3
d151 6
a156 1
static const SSL_METHOD *ssl3_get_client_method(int ver)
d172 2
a173 1
	unsigned long Time=(unsigned long)time(NULL);
a267 1

d292 1
a292 3
			/* or PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
			    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
d367 1
a387 5
			if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)
				{
				s->state=SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec=0;
				}
d502 8
a509 5
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
d511 1
a511 1
			s->rwstate=SSL_NOTHING;
d597 3
a599 9
		SSL_SESSION *sess = s->session;
		if ((sess == NULL) ||
			(sess->ssl_version != s->version) ||
#ifdef OPENSSL_NO_TLSEXT
			!sess->session_id_length ||
#else
			(!sess->session_id_length && !sess->tlsext_tick) ||
#endif
			(sess->not_resumable))
d654 1
a654 3

		if ((s->options & SSL_OP_NO_COMPRESSION)
					|| !s->ctx->comp_methods)
a665 1

a666 6
		/* TLS extensions*/
		if (ssl_prepare_clienthello_tlsext(s) <= 0)
			{
			SSLerr(SSL_F_SSL3_CLIENT_HELLO,SSL_R_CLIENTHELLO_TLSEXT);
			goto err;
			}
d672 1
a672 2
#endif
		
d693 1
a693 1
	const SSL_CIPHER *c;
d711 1
a711 1
	if ( SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
a761 17
#ifndef OPENSSL_NO_TLSEXT
	/* check if we want to resume the session based on external pre-shared secret */
	if (s->version >= TLS1_VERSION && s->tls_session_secret_cb)
		{
		SSL_CIPHER *pref_cipher=NULL;
		s->session->master_key_length=sizeof(s->session->master_key);
		if (s->tls_session_secret_cb(s, s->session->master_key,
					     &s->session->master_key_length,
					     NULL, &pref_cipher,
					     s->tls_session_secret_cb_arg))
			{
			s->session->cipher = pref_cipher ?
				pref_cipher : ssl_get_cipher_by_char(s, p+j);
			}
		}
#endif /* OPENSSL_NO_TLSEXT */

a827 2
	if (!ssl3_digest_cached_records(s))
		goto f_err;
a837 9
	/* If compression is disabled we'd better not try to resume a session
	 * using compression.
	 */
	if (s->session->compress_meth != 0)
		{
		al=SSL_AD_INTERNAL_ERROR;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_INCONSISTENT_COMPRESSION);
		goto f_err;
		}
a839 6
	if (s->hit && j != s->session->compress_meth)
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);
		goto f_err;
		}
a841 6
	else if (s->options & SSL_OP_NO_COMPRESSION)
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_COMPRESSION_DISABLED);
		goto f_err;
		}
a855 1

d858 1
a858 1
	if (s->version >= SSL3_VERSION)
d874 1
d912 1
a912 1
		((s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) && 
d977 2
a978 2
	    && !((s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5) &&
		 (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
d980 1
a980 1
		)
d1004 3
a1006 3
	need_cert = ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5) &&
	            (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
	            ? 0 : 1;
d1009 1
a1009 1
	printf("pkey,x = %p, %p\n", pkey,x);
d1011 2
a1012 2
	printf("cipher, alg, nc = %s, %lx, %lx, %d\n", s->s3->tmp.new_cipher->name,
		s->s3->tmp.new_cipher->algorithm_mkey, s->s3->tmp.new_cipher->algorithm_auth, need_cert);
d1084 1
a1084 1
	long n,alg_k,alg_a;
d1108 1
a1112 13
#ifndef OPENSSL_NO_PSK
		/* In plain PSK ciphersuite, ServerKeyExchange can be
		   omitted if no identity hint is sent. Set
		   session->sess_cert anyway to avoid problems
		   later.*/
		if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
			{
			s->session->sess_cert=ssl_sess_cert_new();
			if (s->ctx->psk_identity_hint)
				OPENSSL_free(s->ctx->psk_identity_hint);
			s->ctx->psk_identity_hint = NULL;
			}
#endif
d1118 1
d1149 1
a1149 2
	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
	alg_a=s->s3->tmp.new_cipher->algorithm_auth;
a1151 45
#ifndef OPENSSL_NO_PSK
	if (alg_k & SSL_kPSK)
		{
		char tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];

		al=SSL_AD_HANDSHAKE_FAILURE;
		n2s(p,i);
		param_len=i+2;
		/* Store PSK identity hint for later use, hint is used
		 * in ssl3_send_client_key_exchange.  Assume that the
		 * maximum length of a PSK identity hint can be as
		 * long as the maximum length of a PSK identity. */
		if (i > PSK_MAX_IDENTITY_LEN)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto f_err;
			}
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);
			goto f_err;
			}
		/* If received PSK identity hint contains NULL
		 * characters, the hint is truncated from the first
		 * NULL. p may not be ending with NULL, so create a
		 * NULL-terminated string. */
		memcpy(tmp_id_hint, p, i);
		memset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);
		if (s->ctx->psk_identity_hint != NULL)
			OPENSSL_free(s->ctx->psk_identity_hint);
		s->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);
		if (s->ctx->psk_identity_hint == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
			goto f_err;
			}	   

		p+=i;
		n-=param_len;
		}
	else
#endif /* !OPENSSL_NO_PSK */
d1153 1
a1153 1
	if (alg_k & SSL_kRSA)
d1192 1
a1192 1
		if (alg_a & SSL_aRSA)
d1207 1
a1207 1
	else if (alg_k & SSL_kEDH)
d1261 1
a1261 1
		if (alg_a & SSL_aRSA)
d1268 1
a1268 1
		else if (alg_a & SSL_aDSS)
d1276 1
a1276 1
	else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))
d1285 1
a1285 1
	else if (alg_k & SSL_kEECDH)
d1308 1
a1308 1
		    ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0)) 
d1369 1
a1369 1
		else if (alg_a & SSL_aRSA)
d1373 1
a1373 1
		else if (alg_a & SSL_aECDSA)
d1384 1
a1384 1
	else if (alg_k)
d1391 6
d1425 2
d1497 2
a1498 2
		if (!(alg_a & SSL_aNULL) && !(alg_k & SSL_kPSK))
			/* aNULL or kPSK do not need public keys */
a1502 1
		/* still data left over */
d1572 2
a1573 1
		if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
a1717 1

d1741 1
a1741 22
	/* There are two ways to detect a resumed ticket sesion.
	 * One is to set an appropriate session ID and then the server
	 * must return a match in ServerHello. This allows the normal
	 * client session ID matching to work and we know much 
	 * earlier that the ticket has been accepted.
	 * 
	 * The other way is to set zero length session ID when the
	 * ticket is presented and rely on the handshake to determine
	 * session resumption.
	 *
	 * We choose the former approach because this fits in with
	 * assumptions elsewhere in OpenSSL. The session ID is set
	 * to the SHA256 (or SHA1 is SHA256 is disabled) hash of the
	 * ticket.
	 */ 
	EVP_Digest(p, ticklen,
			s->session->session_id, &s->session->session_id_length,
#ifndef OPENSSL_NO_SHA256
							EVP_sha256(), NULL);
#else
							EVP_sha1(), NULL);
#endif
d1753 2
a1754 1
	unsigned long resplen,n;
d1780 1
a1780 1
	if (resplen + 4 != n)
d1849 1
a1849 1
	unsigned long alg_k;
d1871 1
a1871 1
		alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
d1876 1
a1876 1
		else if (alg_k & SSL_kRSA)
d1935 1
a1935 1
		else if (alg_k & SSL_kKRB5)
d1943 1
a1943 1
			const EVP_CIPHER *enc = NULL;
d1954 1
a1954 1
				alg_k, SSL_kKRB5);
d2046 1
a2046 1
			if (outl > (int)sizeof epms)
d2060 1
a2060 1
				s->method->ssl3_enc->generate_master_secret(s,
d2069 1
a2069 1
		else if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
d2078 1
a2078 1
				}
d2133 1
a2133 1
		else if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe))
d2145 1
a2145 1
			if ((alg_k & (SSL_kECDHr|SSL_kECDHe)) && (s->cert != NULL)) 
a2316 172
		else if (alg_k & SSL_kGOST) 
			{
			/* GOST key exchange message creation */
			EVP_PKEY_CTX *pkey_ctx;
			X509 *peer_cert; 
			size_t msglen;
			unsigned int md_len;
			int keytype;
			unsigned char premaster_secret[32],shared_ukm[32], tmp[256];
			EVP_MD_CTX *ukm_hash;
			EVP_PKEY *pub_key;

			/* Get server sertificate PKEY and create ctx from it */
			peer_cert=s->session->sess_cert->peer_pkeys[(keytype=SSL_PKEY_GOST01)].x509;
			if (!peer_cert) 
				peer_cert=s->session->sess_cert->peer_pkeys[(keytype=SSL_PKEY_GOST94)].x509;
			if (!peer_cert)		{
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);
					goto err;
				}	
				
			pkey_ctx=EVP_PKEY_CTX_new(pub_key=X509_get_pubkey(peer_cert),NULL);
			/* If we have send a certificate, and certificate key

			 * parameters match those of server certificate, use
			 * certificate key for key exchange
			 */

			 /* Otherwise, generate ephemeral key pair */
					
			EVP_PKEY_encrypt_init(pkey_ctx);
			  /* Generate session key */	
		    RAND_bytes(premaster_secret,32);
			/* If we have client certificate, use its secret as peer key */
			if (s->s3->tmp.cert_req && s->cert->key->privatekey) {
				if (EVP_PKEY_derive_set_peer(pkey_ctx,s->cert->key->privatekey) <=0) {
					/* If there was an error - just ignore it. Ephemeral key
					* would be used
					*/
					ERR_clear_error();
				}
			}			
			/* Compute shared IV and store it in algorithm-specific
			 * context data */
			ukm_hash = EVP_MD_CTX_create();
			EVP_DigestInit(ukm_hash,EVP_get_digestbynid(NID_id_GostR3411_94));
			EVP_DigestUpdate(ukm_hash,s->s3->client_random,SSL3_RANDOM_SIZE);
			EVP_DigestUpdate(ukm_hash,s->s3->server_random,SSL3_RANDOM_SIZE);
			EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len);
			EVP_MD_CTX_destroy(ukm_hash);
			if (EVP_PKEY_CTX_ctrl(pkey_ctx,-1,EVP_PKEY_OP_ENCRYPT,EVP_PKEY_CTRL_SET_IV,
				8,shared_ukm)<0) {
					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
						SSL_R_LIBRARY_BUG);
					goto err;
				}	
			/* Make GOST keytransport blob message */
			/*Encapsulate it into sequence */
			*(p++)=V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED;
			msglen=255;
			if (EVP_PKEY_encrypt(pkey_ctx,tmp,&msglen,premaster_secret,32)<0) {
			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					SSL_R_LIBRARY_BUG);
				goto err;
			}
			if (msglen >= 0x80)
				{
				*(p++)=0x81;
				*(p++)= msglen & 0xff;
				n=msglen+3;
				}
			else
				{
				*(p++)= msglen & 0xff;
				n=msglen+2;
				}
			memcpy(p, tmp, msglen);
			/* Check if pubkey from client certificate was used */
			if (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0)
				{
				/* Set flag "skip certificate verify" */
				s->s3->flags |= TLS1_FLAGS_SKIP_CERT_VERIFY;
				}
			EVP_PKEY_CTX_free(pkey_ctx);
			s->session->master_key_length=
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,premaster_secret,32);
			EVP_PKEY_free(pub_key);

			}
#ifndef OPENSSL_NO_PSK
		else if (alg_k & SSL_kPSK)
			{
			char identity[PSK_MAX_IDENTITY_LEN];
			unsigned char *t = NULL;
			unsigned char psk_or_pre_ms[PSK_MAX_PSK_LEN*2+4];
			unsigned int pre_ms_len = 0, psk_len = 0;
			int psk_err = 1;

			n = 0;
			if (s->psk_client_callback == NULL)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					SSL_R_PSK_NO_CLIENT_CB);
				goto err;
				}

			psk_len = s->psk_client_callback(s, s->ctx->psk_identity_hint,
				identity, PSK_MAX_IDENTITY_LEN,
				psk_or_pre_ms, sizeof(psk_or_pre_ms));
			if (psk_len > PSK_MAX_PSK_LEN)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					ERR_R_INTERNAL_ERROR);
				goto psk_err;
				}
			else if (psk_len == 0)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					SSL_R_PSK_IDENTITY_NOT_FOUND);
				goto psk_err;
				}

			/* create PSK pre_master_secret */
			pre_ms_len = 2+psk_len+2+psk_len;
			t = psk_or_pre_ms;
			memmove(psk_or_pre_ms+psk_len+4, psk_or_pre_ms, psk_len);
			s2n(psk_len, t);
			memset(t, 0, psk_len);
			t+=psk_len;
			s2n(psk_len, t);

			if (s->session->psk_identity_hint != NULL)
				OPENSSL_free(s->session->psk_identity_hint);
			s->session->psk_identity_hint = BUF_strdup(s->ctx->psk_identity_hint);
			if (s->ctx->psk_identity_hint != NULL &&
				s->session->psk_identity_hint == NULL)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto psk_err;
				}

			if (s->session->psk_identity != NULL)
				OPENSSL_free(s->session->psk_identity);
			s->session->psk_identity = BUF_strdup(identity);
			if (s->session->psk_identity == NULL)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto psk_err;
				}

			s->session->master_key_length =
				s->method->ssl3_enc->generate_master_secret(s,
					s->session->master_key,
					psk_or_pre_ms, pre_ms_len); 
			n = strlen(identity);
			s2n(n, p);
			memcpy(p, identity, n);
			n+=2;
			psk_err = 0;
		psk_err:
			OPENSSL_cleanse(identity, PSK_MAX_IDENTITY_LEN);
			OPENSSL_cleanse(psk_or_pre_ms, sizeof(psk_or_pre_ms));
			if (psk_err != 0)
				{
				ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
				goto err;
				}
			}
#endif
a2352 1
	EVP_PKEY_CTX *pctx=NULL;
d2357 1
d2359 1
d2366 4
a2369 13
/* Create context from key and test if sha1 is allowed as digest */
		pctx = EVP_PKEY_CTX_new(pkey,NULL);
		EVP_PKEY_sign_init(pctx);
		if (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1())>0)
			{
			s->method->ssl3_enc->cert_verify_mac(s,
						NID_sha1,
						&(data[MD5_DIGEST_LENGTH]));
			}
		else
			{
			ERR_clear_error();
			}
d2374 1
a2374 2
				NID_md5,
			 	&(data[0]));
d2420 1
a2420 21
		if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) 
		{
		unsigned char signbuf[64];
		int i;
		size_t sigsize=64;
		s->method->ssl3_enc->cert_verify_mac(s,
			NID_id_GostR3411_94,
			data);
		if (EVP_PKEY_sign(pctx, signbuf, &sigsize, data, 32) <= 0) {
			SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
			ERR_R_INTERNAL_ERROR);
			goto err;
		}
		for (i=63,j=0; i>=0; j++, i--) {
			p[2+j]=signbuf[i];
		}	
		s2n(j,p);
		n=j+2;
		}
		else
		{
d2423 1
a2423 1
		}
a2430 1
	EVP_PKEY_CTX_free(pctx);
a2432 1
	EVP_PKEY_CTX_free(pctx);
d2517 1
a2517 1
	long alg_k,alg_a;
d2527 3
a2529 2
	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
	alg_a=s->s3->tmp.new_cipher->algorithm_auth;
d2532 1
a2532 1
	if ((alg_a & (SSL_aDH|SSL_aNULL|SSL_aKRB5)) || (alg_k & SSL_kPSK))
a2534 1
	sc=s->session->sess_cert;
d2554 1
a2554 1
		if (ssl_check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509,
d2558 1
a2558 1
			goto f_err;
d2572 1
a2572 1
	if ((alg_a & SSL_aRSA) && !has_bits(i,EVP_PK_RSA|EVP_PKT_SIGN))
d2578 1
a2578 1
	else if ((alg_a & SSL_aDSS) && !has_bits(i,EVP_PK_DSA|EVP_PKT_SIGN))
d2585 1
a2585 1
	if ((alg_k & SSL_kRSA) &&
d2593 1
a2593 1
	if ((alg_k & SSL_kEDH) &&
d2599 1
a2599 1
	else if ((alg_k & SSL_kDHr) && !has_bits(i,EVP_PK_DH|EVP_PKS_RSA))
d2605 1
a2605 1
	else if ((alg_k & SSL_kDHd) && !has_bits(i,EVP_PK_DH|EVP_PKS_DSA))
d2616 1
a2616 1
		if (alg_k & SSL_kRSA)
d2628 1
a2628 1
			if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
d2651 43
d2700 1
a2700 1
int ssl3_check_finished(SSL *s)
d2704 5
a2708 2
	/* If we have no ticket it cannot be a resumed session. */
	if (!s->session->tlsext_tick)
@


1.1.1.14
log
@import OpenSSL 1.0.0e
@
text
@a868 2
/* Workaround is now obsolete */
#if 0
a870 1
#endif
a1510 1
		bn_ctx = NULL;
a2241 1
				DH_free(dh_clnt);
a2252 1
				DH_free(dh_clnt);
@


1.1.1.15
log
@OpenSSL 1.0.0f: import upstream source
@
text
@d956 1
a956 1
		goto f_err;
d1840 1
a1840 1
		al = SSL_AD_DECODE_ERROR;
d1851 1
a1851 1
		al = SSL_AD_DECODE_ERROR;
@


1.1.1.16
log
@import OpenSSL-1.0.1c
@
text
@a158 3
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif
a202 12
#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

d210 1
a210 1
			s->renegotiate=1;
a282 1
				{
a283 8
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_ticket_expected)
					{
					/* receive renewed session ticket */
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
					}
#endif
				}
a360 11
#ifndef OPENSSL_NO_SRP
			if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP)
				{
				if ((ret = SRP_Calc_A_param(s))<=0)
					{
					SSLerr(SSL_F_SSL3_CONNECT,SSL_R_SRP_A_CALC);
					ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_INTERNAL_ERROR);
					goto end;
					}
				}
#endif
a425 3


#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
a426 6
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_CW_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_CW_FINISHED_A;
#endif
a453 9
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_CW_NEXT_PROTO_A:
		case SSL3_ST_CW_NEXT_PROTO_B:
			ret=ssl3_send_next_proto(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_FINISHED_A;
			break;
#endif

a548 1
			s->renegotiate=0;
a637 30
		/* version indicates the negotiated version: for example from
		 * an SSLv2/v3 compatible client hello). The client_version
		 * field is the maximum version we permit and it is also
		 * used in RSA encrypted premaster secrets. Some servers can
		 * choke if we initially report a higher version then
		 * renegotiate to a lower one in the premaster secret. This
		 * didn't happen with TLS 1.0 as most servers supported it
		 * but it can with TLS 1.1 or later if the server only supports
		 * 1.0.
		 *
		 * Possible scenario with previous logic:
		 * 	1. Client hello indicates TLS 1.2
		 * 	2. Server hello says TLS 1.0
		 *	3. RSA encrypted premaster secret uses 1.2.
		 * 	4. Handhaked proceeds using TLS 1.0.
		 *	5. Server sends hello request to renegotiate.
		 *	6. Client hello indicates TLS v1.0 as we now
		 *	   know that is maximum server supports.
		 *	7. Server chokes on RSA encrypted premaster secret
		 *	   containing version 1.0.
		 *
		 * For interoperability it should be OK to always use the
		 * maximum version we support in client hello and then rely
		 * on the checking of version to ensure the servers isn't
		 * being inconsistent: for example initially negotiating with
		 * TLS 1.0 and renegotiating with TLS 1.2. We do this by using
		 * client_version in client hello and not resetting it to
		 * the negotiated version.
		 */
#if 0
a640 4
#else
		*(p++)=s->client_version>>8;
		*(p++)=s->client_version&0xff;
#endif
a669 9
#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
			/* Some servers hang if client hello > 256 bytes
			 * as hack workaround chop number of supported ciphers
			 * to keep it well below this if we use TLS v1.2
			 */
			if (TLS1_get_version(s) >= TLS1_2_VERSION
				&& i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
				i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
#endif
a849 8
	/* TLS v1.2 only ciphersuites require v1.2 or later */
	if ((c->algorithm_ssl & SSL_TLSV1_2) && 
		(TLS1_get_version(s) < TLS1_2_VERSION))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);
		goto f_err;
		}
d881 1
a881 4
	/* Don't digest cached records if TLS v1.2: we may need them for
	 * client authentication.
	 */
	if (TLS1_get_version(s) < TLS1_2_VERSION && !ssl3_digest_cached_records(s))
d883 1
a1161 1
	const EVP_MD *md = NULL;
a1284 80
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP)
		{
		n2s(p,i);
		param_len=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);
			goto f_err;
			}
		if (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		n2s(p,i);
		param_len+=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);
			goto f_err;
			}
		if (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		i = (unsigned int)(p[0]);
		p++;
		param_len+=i+1;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);
			goto f_err;
			}
		if (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		n2s(p,i);
		param_len+=i+2;
		if (param_len > n)
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);
			goto f_err;
			}
		if (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

/* We must check if there is a certificate */
#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		}
	else
#endif /* !OPENSSL_NO_SRP */
a1531 32
		if (TLS1_get_version(s) >= TLS1_2_VERSION)
			{
			int sigalg = tls12_get_sigid(pkey);
			/* Should never happen */
			if (sigalg == -1)
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
				goto err;
				}
			/* Check key type is consistent with signature */
			if (sigalg != (int)p[1])
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_TYPE);
				al=SSL_AD_DECODE_ERROR;
				goto f_err;
				}
			md = tls12_get_hash(p[0]);
			if (md == NULL)
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNKNOWN_DIGEST);
				al=SSL_AD_DECODE_ERROR;
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, "USING TLSv1.2 HASH %s\n", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
		else
			md = EVP_sha1();
			
d1545 1
a1545 1
		if (pkey->type == EVP_PKEY_RSA && TLS1_get_version(s) < TLS1_2_VERSION)
a1552 2
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d1580 20
d1601 2
a1602 1
			EVP_VerifyInit_ex(&md_ctx, md, NULL);
d1614 6
d1666 1
a1666 1
	unsigned int llen, ctype_num,i;
a1685 8
		/* If we get here we don't need any cached handshake records
		 * as we wont be doing client auth.
		 */
		if (s->s3->handshake_buffer)
			{
			if (!ssl3_digest_cached_records(s))
				goto err;
			}
a1721 20
	if (TLS1_get_version(s) >= TLS1_2_VERSION)
		{
		n2s(p, llen);
		/* Check we have enough room for signature algorithms and
		 * following length value.
		 */
		if ((unsigned long)(p - d + llen + 2) > n)
			{
			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_DATA_LENGTH_TOO_LONG);
			goto err;
			}
		if ((llen & 1) || !tls1_process_sigalgs(s, p, llen))
			{
			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_SIGNATURE_ALGORITHMS_ERROR);
			goto err;
			}
		p += llen;
		}
d1734 1
a1734 1
	if ((unsigned long)(p - d + llen) != n)
a2555 33
#ifndef OPENSSL_NO_SRP
		else if (alg_k & SSL_kSRP)
			{
			if (s->srp_ctx.A != NULL)
				{
				/* send off the data */
				n=BN_num_bytes(s->srp_ctx.A);
				s2n(n,p);
				BN_bn2bin(s->srp_ctx.A,p);
				n+=2;
				}
			else
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
				goto err;
				}
			if (s->session->srp_username != NULL)
				OPENSSL_free(s->session->srp_username);
			s->session->srp_username = BUF_strdup(s->srp_ctx.login);
			if (s->session->srp_username == NULL)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
					ERR_R_MALLOC_FAILURE);
				goto err;
				}

			if ((s->session->master_key_length = SRP_generate_client_master_secret(s,s->session->master_key))<0)
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
				goto err;
				}
			}
#endif
d2675 1
a2675 1
	EVP_MD_CTX mctx;
d2677 1
a2680 2
	EVP_MD_CTX_init(&mctx);

d2691 1
a2691 2
			if (TLS1_get_version(s) < TLS1_2_VERSION)
				s->method->ssl3_enc->cert_verify_mac(s,
a2698 35
		/* For TLS v1.2 send signature algorithm and signature
		 * using agreed digest and cached handshake records.
		 */
		if (TLS1_get_version(s) >= TLS1_2_VERSION)
			{
			long hdatalen = 0;
			void *hdata;
			const EVP_MD *md = s->cert->key->digest;
			hdatalen = BIO_get_mem_data(s->s3->handshake_buffer,
								&hdata);
			if (hdatalen <= 0 || !tls12_get_sigandhash(p, pkey, md))
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
						ERR_R_INTERNAL_ERROR);
				goto err;
				}
			p += 2;
#ifdef SSL_DEBUG
			fprintf(stderr, "Using TLS 1.2 with client alg %s\n",
							EVP_MD_name(md));
#endif
			if (!EVP_SignInit_ex(&mctx, md, NULL)
				|| !EVP_SignUpdate(&mctx, hdata, hdatalen)
				|| !EVP_SignFinal(&mctx, p + 2, &u, pkey))
				{
				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
						ERR_R_EVP_LIB);
				goto err;
				}
			s2n(u,p);
			n = u + 4;
			if (!ssl3_digest_cached_records(s))
				goto err;
			}
		else
a2780 1
	EVP_MD_CTX_cleanup(&mctx);
a2783 1
	EVP_MD_CTX_cleanup(&mctx);
d2907 1
a2907 1
		    						s) == 0) 
a3001 26

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
int ssl3_send_next_proto(SSL *s)
	{
	unsigned int len, padding_len;
	unsigned char *d;

	if (s->state == SSL3_ST_CW_NEXT_PROTO_A)
		{
		len = s->next_proto_negotiated_len;
		padding_len = 32 - ((len + 2) % 32);
		d = (unsigned char *)s->init_buf->data;
		d[4] = len;
		memcpy(d + 5, s->next_proto_negotiated, len);
		d[5 + len] = padding_len;
		memset(d + 6 + len, 0, padding_len);
		*(d++)=SSL3_MT_NEXT_PROTO;
		l2n3(2 + len + padding_len, d);
		s->state = SSL3_ST_CW_NEXT_PROTO_B;
		s->init_num = 4 + 2 + len + padding_len;
		s->init_off = 0;
		}

	return ssl3_do_write(s, SSL3_RT_HANDSHAKE);
}
#endif  /* !OPENSSL_NO_TLSEXT && !OPENSSL_NO_NEXTPROTONEG */
@


1.1.1.17
log
@Import OpenSSL 1.0.1g
@
text
@d462 1
d659 1
a659 1
	unsigned long l;
d684 3
a686 2

		if (ssl_fill_hello_random(s, 0, p, SSL3_RANDOM_SIZE) <= 0)
a989 2
		{
		al = SSL_AD_INTERNAL_ERROR;
a990 1
		}
@


