head	1.42;
access;
symbols
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.4
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	butholakala:1.16
	openssl_1_0_1_g:1.1.1.13
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	openssl_1_0_1_c:1.1.1.13
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	openssl_1_0_0_f:1.1.1.12
	openssl_1_0_0_e:1.1.1.12
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	openssh_1_0_0_a:1.1.1.11
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	openssl_0_9_8_k:1.1.1.10
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	openssl_0_9_8_j:1.1.1.10
	openssl_0_9_8_h:1.1.1.9
	pre_openssl_0_9_8h:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	openssl_0_9_7j:1.1.1.8
	openssl:1.1.1
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENSSL_0_9_7G:1.1.1.7
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENSSL_0_9_7D:1.1.1.6
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.5
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENSSL_0_9_7B:1.1.1.5
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.4
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.09.03.11.33.41;	author beck;	state dead;
branches;
next	1.41;
commitid	HnbXxsegngek41U2;

1.41
date	2016.03.11.07.08.45;	author mmcc;	state Exp;
branches;
next	1.40;
commitid	MTdM7aVFdRMAzAYE;

1.40
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.39;
commitid	XNZawfRSWvnVv1VS;

1.39
date	2014.10.20.12.55.21;	author bcook;	state Exp;
branches;
next	1.38;
commitid	G3iOYXyMAgsCy5E9;

1.38
date	2014.10.16.03.19.02;	author beck;	state Exp;
branches;
next	1.37;
commitid	id4pE5GZpJTmZzW6;

1.37
date	2014.07.13.23.34.39;	author jsing;	state Exp;
branches;
next	1.36;
commitid	QpAeiVe8iYGPs9NL;

1.36
date	2014.07.13.21.38.23;	author jsing;	state Exp;
branches;
next	1.35;
commitid	tVAB7FKki6dk1zQu;

1.35
date	2014.07.13.21.35.27;	author jsing;	state Exp;
branches;
next	1.34;
commitid	zdMylaHDNen3JH7t;

1.34
date	2014.07.13.17.56.56;	author jsing;	state Exp;
branches;
next	1.33;
commitid	rCpJnjl8FYUtlFrD;

1.33
date	2014.07.13.16.43.37;	author jsing;	state Exp;
branches;
next	1.32;
commitid	egO274bOWf620VbT;

1.32
date	2014.07.13.16.39.19;	author jsing;	state Exp;
branches;
next	1.31;
commitid	RH3MsAFApCV8QlNC;

1.31
date	2014.07.13.16.30.50;	author jsing;	state Exp;
branches;
next	1.30;
commitid	OYJgj9KNuHwE6h7p;

1.30
date	2014.07.13.00.30.07;	author jsing;	state Exp;
branches;
next	1.29;
commitid	w4bQKsXXg4KN2VIv;

1.29
date	2014.07.11.12.07.30;	author miod;	state Exp;
branches;
next	1.28;
commitid	etHVCKYqCAaVeefs;

1.28
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.27;
commitid	cCGiAdDteN08GytD;

1.27
date	2014.07.10.08.51.15;	author tedu;	state Exp;
branches;
next	1.26;
commitid	lsH7iukeZYSZBx6F;

1.26
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	mJUVYpkFBZ0Zv2bG;

1.25
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.20.12.48.19;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.13.37.50;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.16.20.39.09;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.16.17.59.16;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.16.15.10.07;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.14.13.10.35;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.14.11.18.03;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.30.11.08.06;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.40;	author beck;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2000.03.19.11.13.32;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.29;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.13;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.13;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.39;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.24;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.52.53;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.36.42;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.42.06;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.37.28;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2011.11.03.02.32.21;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2012.10.13.21.23.50;	author djm;	state Exp;
branches;
next	;

1.4.4.1
date	2002.07.30.11.07.33;	author miod;	state Exp;
branches;
next	;

1.4.6.1
date	2002.07.30.15.47.52;	author jason;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: ssl_asn1.c,v 1.41 2016/03/11 07:08:45 mmcc Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>
#include <stdlib.h>

#include "ssl_locl.h"

#include <openssl/objects.h>
#include <openssl/x509.h>

/* XXX - these are here to avoid including asn1_mac.h */
int asn1_GetSequence(ASN1_const_CTX *c, long *length);
void asn1_add_error(const unsigned char *address, int offset);

typedef struct ssl_session_asn1_st {
	ASN1_INTEGER version;
	ASN1_INTEGER ssl_version;
	ASN1_OCTET_STRING cipher;
	ASN1_OCTET_STRING master_key;
	ASN1_OCTET_STRING session_id;
	ASN1_OCTET_STRING session_id_context;
	ASN1_INTEGER time;
	ASN1_INTEGER timeout;
	ASN1_INTEGER verify_result;
	ASN1_OCTET_STRING tlsext_hostname;
	ASN1_INTEGER tlsext_tick_lifetime;
	ASN1_OCTET_STRING tlsext_tick;
} SSL_SESSION_ASN1;

int
i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp)
{
#define LSIZE2 (sizeof(long)*2)
	int v1 = 0, v2 = 0, v3 = 0, v4 = 0, v5 = 0, v6 = 0, v9 = 0, v10 = 0;
	unsigned char buf[4], ibuf1[LSIZE2], ibuf2[LSIZE2];
	unsigned char ibuf3[LSIZE2], ibuf4[LSIZE2], ibuf5[LSIZE2];
	unsigned char ibuf6[LSIZE2];
	SSL_SESSION_ASN1 a;
	unsigned char *p;
	int len = 0, ret;
	long l;

	if ((in == NULL) || ((in->cipher == NULL) && (in->cipher_id == 0)))
		return (0);

	/*
	 * Note that I cheat in the following 2 assignments.
	 * I know that if the ASN1_INTEGER passed to ASN1_INTEGER_set
	 * is > sizeof(long)+1, the buffer will not be re-malloc()ed.
	 * This is a bit evil but makes things simple, no dynamic allocation
	 * to clean up :-)
	 */
	a.version.length = LSIZE2;
	a.version.type = V_ASN1_INTEGER;
	a.version.data = ibuf1;
	ASN1_INTEGER_set(&(a.version), SSL_SESSION_ASN1_VERSION);
	len += i2d_ASN1_INTEGER(&(a.version), NULL);

	a.ssl_version.length = LSIZE2;
	a.ssl_version.type = V_ASN1_INTEGER;
	a.ssl_version.data = ibuf2;
	ASN1_INTEGER_set(&(a.ssl_version), in->ssl_version);
	len += i2d_ASN1_INTEGER(&(a.ssl_version), NULL);

	a.cipher.length = 2;
	a.cipher.type = V_ASN1_OCTET_STRING;
	l = (in->cipher == NULL) ? in->cipher_id : in->cipher->id;
	buf[0] = ((unsigned char)(l >> 8L)) & 0xff;
	buf[1] = ((unsigned char)(l)) & 0xff;
	a.cipher.data = buf;
	len += i2d_ASN1_OCTET_STRING(&(a.cipher), NULL);

	a.master_key.length = in->master_key_length;
	a.master_key.type = V_ASN1_OCTET_STRING;
	a.master_key.data = in->master_key;
	len += i2d_ASN1_OCTET_STRING(&(a.master_key), NULL);

	a.session_id.length = in->session_id_length;
	a.session_id.type = V_ASN1_OCTET_STRING;
	a.session_id.data = in->session_id;
	len += i2d_ASN1_OCTET_STRING(&(a.session_id), NULL);

	if (in->time != 0L) {
		a.time.length = LSIZE2;
		a.time.type = V_ASN1_INTEGER;
		a.time.data = ibuf3;
		ASN1_INTEGER_set(&(a.time), in->time);	/* XXX 2038 */
		v1 = i2d_ASN1_INTEGER(&(a.time), NULL);
		len += ASN1_object_size(1, v1, 1);
	}

	if (in->timeout != 0L) {
		a.timeout.length = LSIZE2;
		a.timeout.type = V_ASN1_INTEGER;
		a.timeout.data = ibuf4;
		ASN1_INTEGER_set(&(a.timeout), in->timeout);
		v2 = i2d_ASN1_INTEGER(&(a.timeout), NULL);
		len += ASN1_object_size(1, v2, 2);
	}

	if (in->peer != NULL) {
		v3 = i2d_X509(in->peer, NULL);
		len += ASN1_object_size(1, v3, 3);
	}

	a.session_id_context.length = in->sid_ctx_length;
	a.session_id_context.type = V_ASN1_OCTET_STRING;
	a.session_id_context.data = in->sid_ctx;
	v4 = i2d_ASN1_OCTET_STRING(&(a.session_id_context), NULL);
	len += ASN1_object_size(1, v4, 4);

	if (in->verify_result != X509_V_OK) {
		a.verify_result.length = LSIZE2;
		a.verify_result.type = V_ASN1_INTEGER;
		a.verify_result.data = ibuf5;
		ASN1_INTEGER_set(&a.verify_result, in->verify_result);
		v5 = i2d_ASN1_INTEGER(&(a.verify_result), NULL);
		len += ASN1_object_size(1, v5, 5);
	}

	if (in->tlsext_hostname) {
		a.tlsext_hostname.length = strlen(in->tlsext_hostname);
		a.tlsext_hostname.type = V_ASN1_OCTET_STRING;
		a.tlsext_hostname.data = (unsigned char *)in->tlsext_hostname;
		v6 = i2d_ASN1_OCTET_STRING(&(a.tlsext_hostname), NULL);
		len += ASN1_object_size(1, v6, 6);
	}

	/* 7 - PSK identity hint. */
	/* 8 - PSK identity. */

	if (in->tlsext_tick_lifetime_hint > 0) {
		a.tlsext_tick_lifetime.length = LSIZE2;
		a.tlsext_tick_lifetime.type = V_ASN1_INTEGER;
		a.tlsext_tick_lifetime.data = ibuf6;
		ASN1_INTEGER_set(&a.tlsext_tick_lifetime,
		    in->tlsext_tick_lifetime_hint);
		v9 = i2d_ASN1_INTEGER(&(a.tlsext_tick_lifetime), NULL);
		len += ASN1_object_size(1, v9, 9);
	}

	if (in->tlsext_tick) {
		a.tlsext_tick.length = in->tlsext_ticklen;
		a.tlsext_tick.type = V_ASN1_OCTET_STRING;
		a.tlsext_tick.data = (unsigned char *)in->tlsext_tick;
		v10 = i2d_ASN1_OCTET_STRING(&(a.tlsext_tick), NULL);
		len += ASN1_object_size(1, v10, 10);
	}

	/* 11 - Compression method. */
	/* 12 - SRP username. */

	/* If given a NULL pointer, return the length only. */
	ret = (ASN1_object_size(1, len, V_ASN1_SEQUENCE));
	if (pp == NULL)
		return (ret);

	/* Burp out the ASN1. */
	p = *pp;
	ASN1_put_object(&p, 1, len, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);
	i2d_ASN1_INTEGER(&(a.version), &p);
	i2d_ASN1_INTEGER(&(a.ssl_version), &p);
	i2d_ASN1_OCTET_STRING(&(a.cipher), &p);
	i2d_ASN1_OCTET_STRING(&(a.session_id), &p);
	i2d_ASN1_OCTET_STRING(&(a.master_key), &p);
	if (in->time != 0L) {
		ASN1_put_object(&p, 1, v1, 1, V_ASN1_CONTEXT_SPECIFIC);
		i2d_ASN1_INTEGER(&(a.time), &p);
	}
	if (in->timeout != 0L) {
		ASN1_put_object(&p, 1, v2, 2, V_ASN1_CONTEXT_SPECIFIC);
		i2d_ASN1_INTEGER(&(a.timeout), &p);
	}
	if (in->peer != NULL) {
		ASN1_put_object(&p, 1, v3, 3, V_ASN1_CONTEXT_SPECIFIC);
		i2d_X509(in->peer, &p);
	}
	ASN1_put_object(&p, 1, v4, 4, V_ASN1_CONTEXT_SPECIFIC);
	i2d_ASN1_OCTET_STRING(&(a.session_id_context), &p);
	if (in->verify_result != X509_V_OK) {
		ASN1_put_object(&p, 1, v5, 5, V_ASN1_CONTEXT_SPECIFIC);
		i2d_ASN1_INTEGER(&(a.verify_result), &p);
	}
	if (in->tlsext_hostname) {
		ASN1_put_object(&p, 1, v6, 6, V_ASN1_CONTEXT_SPECIFIC);
		i2d_ASN1_OCTET_STRING(&(a.tlsext_hostname), &p);
	}
	/* 7 - PSK identity hint. */
	/* 8 - PSK identity. */
	if (in->tlsext_tick_lifetime_hint > 0) {
		ASN1_put_object(&p, 1, v9, 9, V_ASN1_CONTEXT_SPECIFIC);
		i2d_ASN1_INTEGER(&(a.tlsext_tick_lifetime), &p);
	}
	if (in->tlsext_tick) {
		ASN1_put_object(&p, 1, v10, 10, V_ASN1_CONTEXT_SPECIFIC);
		i2d_ASN1_OCTET_STRING(&(a.tlsext_tick), &p);
	}
	/* 11 - Compression method. */
	/* 12 - SRP username. */

	*pp = p;
	return (ret);
}

SSL_SESSION *
d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp, long length)
{
	SSL_SESSION *ret = NULL;
	ASN1_const_CTX c;
	ASN1_INTEGER ai, *aip;
	ASN1_OCTET_STRING os, *osp;
	int ssl_version = 0, i;
	int Tinf, Ttag, Tclass;
	long Tlen;
	long id;

	c.pp = pp;
	c.p = *pp;
	c.q = *pp;
	c.max = (length == 0) ? 0 : (c.p + length);
	c.slen = length;

	if (a == NULL || *a == NULL) {
		if ((ret = SSL_SESSION_new()) == NULL) {
			SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}
	} else
		ret = *a;

	aip = &ai;
	osp = &os;

	if (!asn1_GetSequence(&c, &length)) {
		SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
		goto err;
	}

	ai.data = NULL;
	ai.length = 0;
	c.q = c.p;
	if (d2i_ASN1_INTEGER(&aip, &c.p, c.slen) == NULL) {
		SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
		goto err;
	}
	c.slen -= (c.p - c.q);

	if (ai.data != NULL) {
		free(ai.data);
		ai.data = NULL;
		ai.length = 0;
	}

	/* we don't care about the version right now :-) */
	c.q = c.p;
	if (d2i_ASN1_INTEGER(&aip, &c.p, c.slen) == NULL) {
		SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
		goto err;
	}
	c.slen -= (c.p - c.q);
	ssl_version = (int)ASN1_INTEGER_get(aip);
	ret->ssl_version = ssl_version;
	if (ai.data != NULL) {
		free(ai.data);
		ai.data = NULL;
		ai.length = 0;
	}

	os.data = NULL;
	os.length = 0;
	c.q = c.p;
	if (d2i_ASN1_OCTET_STRING(&osp, &c.p, c.slen) == NULL) {
		SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
		goto err;
	}
	c.slen -= (c.p - c.q);
	if ((ssl_version >> 8) >= SSL3_VERSION_MAJOR) {
		if (os.length != 2) {
			SSLerr(SSL_F_D2I_SSL_SESSION,
			    SSL_R_CIPHER_CODE_WRONG_LENGTH);
			goto err;
		}
		id = 0x03000000L | ((unsigned long)os.data[0]<<8L) |
		    (unsigned long)os.data[1];
	} else {
		SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNKNOWN_SSL_VERSION);
		goto err;
	}

	ret->cipher = NULL;
	ret->cipher_id = id;

	c.q = c.p;
	if (d2i_ASN1_OCTET_STRING(&osp, &c.p, c.slen) == NULL) {
		SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
		goto err;
	}
	c.slen -= (c.p - c.q);

	i = SSL3_MAX_SSL_SESSION_ID_LENGTH;
	if (os.length > i)
		os.length = i;
	if (os.length > (int)sizeof(ret->session_id)) /* can't happen */
		os.length = sizeof(ret->session_id);

	ret->session_id_length = os.length;
	OPENSSL_assert(os.length <= (int)sizeof(ret->session_id));
	memcpy(ret->session_id, os.data, os.length);

	c.q = c.p;
	if (d2i_ASN1_OCTET_STRING(&osp, &c.p, c.slen) == NULL) {
		SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
		goto err;
	}
	c.slen -= (c.p - c.q);
	if (os.length > SSL_MAX_MASTER_KEY_LENGTH)
		ret->master_key_length = SSL_MAX_MASTER_KEY_LENGTH;
	else
		ret->master_key_length = os.length;
	memcpy(ret->master_key, os.data, ret->master_key_length);

	os.length = 0;

	/* 1 - Time (INTEGER). */
	/* XXX 2038 */
	ai.length = 0;
	if (c.slen != 0L &&
	    *c.p == (V_ASN1_CONSTRUCTED | V_ASN1_CONTEXT_SPECIFIC | 1)) {
		c.q = c.p;
		Tinf = ASN1_get_object(&c.p, &Tlen, &Ttag, &Tclass, c.slen);
		if (Tinf & 0x80) {
			SSLerr(SSL_F_D2I_SSL_SESSION,
			    ERR_R_BAD_ASN1_OBJECT_HEADER);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1))
			Tlen = c.slen - (c.p - c.q) - 2;
		if (d2i_ASN1_INTEGER(&aip, &c.p, Tlen) == NULL) {
			SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1)) {
			Tlen = c.slen - (c.p - c.q);
			if(!ASN1_const_check_infinite_end(&c.p, Tlen)) {
				SSLerr(SSL_F_D2I_SSL_SESSION,
				    ERR_R_MISSING_ASN1_EOS);
				goto err;
			}
		}
		c.slen -= (c.p - c.q);
	}
	if (ai.data != NULL) {
		ret->time = ASN1_INTEGER_get(aip);
		free(ai.data);
		ai.data = NULL;
		ai.length = 0;
	} else
		ret->time = time(NULL);

	/* 2 - Timeout (INTEGER). */
	ai.length = 0;
	if (c.slen != 0L &&
	    *c.p == (V_ASN1_CONSTRUCTED | V_ASN1_CONTEXT_SPECIFIC | 2)) {
		c.q = c.p;
		Tinf = ASN1_get_object(&c.p, &Tlen, &Ttag, &Tclass, c.slen);
		if (Tinf & 0x80) {
			SSLerr(SSL_F_D2I_SSL_SESSION,
			    ERR_R_BAD_ASN1_OBJECT_HEADER);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1))
			Tlen = c.slen - (c.p - c.q) - 2;
		if (d2i_ASN1_INTEGER(&aip, &c.p, Tlen) == NULL) {
			SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1)) {
			Tlen = c.slen - (c.p - c.q);
			if(!ASN1_const_check_infinite_end(&c.p, Tlen)) {
				SSLerr(SSL_F_D2I_SSL_SESSION,
				    ERR_R_MISSING_ASN1_EOS);
				goto err;
			}
		}
		c.slen -= (c.p - c.q);
	}
	if (ai.data != NULL) {
		ret->timeout = ASN1_INTEGER_get(aip);
		free(ai.data);
		ai.data = NULL;
		ai.length = 0;
	} else
		ret->timeout = 3;

	/* 3 - Peer (X509). */
	X509_free(ret->peer);
	ret->peer = NULL;

	if (c.slen != 0L &&
	    *c.p == (V_ASN1_CONSTRUCTED | V_ASN1_CONTEXT_SPECIFIC | 3)) {
		c.q = c.p;
		Tinf = ASN1_get_object(&c.p, &Tlen, &Ttag, &Tclass, c.slen);
		if (Tinf & 0x80) {
			SSLerr(SSL_F_D2I_SSL_SESSION,
			    ERR_R_BAD_ASN1_OBJECT_HEADER);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1))
			Tlen = c.slen - (c.p - c.q) - 2;
		if (d2i_X509(&ret->peer, &c.p, Tlen) == NULL) {
			SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1)) {
			Tlen = c.slen - (c.p - c.q);
			if(!ASN1_const_check_infinite_end(&c.p, Tlen)) {
				SSLerr(SSL_F_D2I_SSL_SESSION,
				    ERR_R_MISSING_ASN1_EOS);
				goto err;
			}
		}
		c.slen -= (c.p - c.q);
	}

	/* 4 - Session ID (OCTET STRING). */
	os.length = 0;
	free(os.data);
	os.data = NULL;
	if (c.slen != 0L &&
	    *c.p == (V_ASN1_CONSTRUCTED | V_ASN1_CONTEXT_SPECIFIC | 4)) {
		c.q = c.p;
		Tinf = ASN1_get_object(&c.p, &Tlen, &Ttag, &Tclass, c.slen);
		if (Tinf & 0x80) {
			SSLerr(SSL_F_D2I_SSL_SESSION,
			    ERR_R_BAD_ASN1_OBJECT_HEADER);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1))
			Tlen = c.slen - (c.p - c.q) - 2;
		if (d2i_ASN1_OCTET_STRING(&osp, &c.p, Tlen) == NULL) {
			SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1)) {
			Tlen = c.slen - (c.p - c.q);
			if(!ASN1_const_check_infinite_end(&c.p, Tlen)) {
				SSLerr(SSL_F_D2I_SSL_SESSION,
				    ERR_R_MISSING_ASN1_EOS);
				goto err;
			}
		}
		c.slen -= (c.p - c.q);
	}
	if (os.data != NULL) {
		if (os.length > SSL_MAX_SID_CTX_LENGTH) {
			SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_BAD_LENGTH);
			goto err;
		} else {
			ret->sid_ctx_length = os.length;
			memcpy(ret->sid_ctx, os.data, os.length);
		}
		free(os.data);
		os.data = NULL;
		os.length = 0;
	} else
		ret->sid_ctx_length = 0;

	/* 5 - Verify_result. */
	ai.length = 0;
	if (c.slen != 0L &&
	    *c.p == (V_ASN1_CONSTRUCTED | V_ASN1_CONTEXT_SPECIFIC | 5)) {
		c.q = c.p;
		Tinf = ASN1_get_object(&c.p, &Tlen, &Ttag, &Tclass, c.slen);
		if (Tinf & 0x80) {
			SSLerr(SSL_F_D2I_SSL_SESSION,
			    ERR_R_BAD_ASN1_OBJECT_HEADER);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1))
			Tlen = c.slen - (c.p - c.q) - 2;
		if (d2i_ASN1_INTEGER(&aip, &c.p, Tlen) == NULL) {
			SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1)) {
			Tlen = c.slen - (c.p - c.q);
			if(!ASN1_const_check_infinite_end(&c.p, Tlen)) {
				SSLerr(SSL_F_D2I_SSL_SESSION,
				    ERR_R_MISSING_ASN1_EOS);
				goto err;
			}
		}
		c.slen -= (c.p - c.q);
	}
	if (ai.data != NULL) {
		ret->verify_result = ASN1_INTEGER_get(aip);
		free(ai.data);
		ai.data = NULL;
		ai.length = 0;
	} else
		ret->verify_result = X509_V_OK;

	/* 6 - HostName (OCTET STRING). */
	os.length = 0;
	os.data = NULL;
	if (c.slen != 0L &&
	    *c.p == (V_ASN1_CONSTRUCTED | V_ASN1_CONTEXT_SPECIFIC | 6)) {
		c.q = c.p;
		Tinf = ASN1_get_object(&c.p, &Tlen, &Ttag, &Tclass, c.slen);
		if (Tinf & 0x80) {
			SSLerr(SSL_F_D2I_SSL_SESSION,
			    ERR_R_BAD_ASN1_OBJECT_HEADER);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1))
			Tlen = c.slen - (c.p - c.q) - 2;
		if (d2i_ASN1_OCTET_STRING(&osp, &c.p, Tlen) == NULL) {
			SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1)) {
			Tlen = c.slen - (c.p - c.q);
			if(!ASN1_const_check_infinite_end(&c.p, Tlen)) {
				SSLerr(SSL_F_D2I_SSL_SESSION,
				    ERR_R_MISSING_ASN1_EOS);
				goto err;
			}
		}
		c.slen -= (c.p - c.q);
	}
	if (os.data) {
		ret->tlsext_hostname = strndup((char *)os.data, os.length);
		free(os.data);
		os.data = NULL;
		os.length = 0;
	} else
		ret->tlsext_hostname = NULL;

	/* 7 - PSK identity hint (OCTET STRING). */
	/* 8 - PSK identity (OCTET STRING). */

	/* 9 - Ticket lifetime. */
	ai.length = 0;
	if (c.slen != 0L &&
	    *c.p == (V_ASN1_CONSTRUCTED | V_ASN1_CONTEXT_SPECIFIC | 9)) {
		c.q = c.p;
		Tinf = ASN1_get_object(&c.p, &Tlen, &Ttag, &Tclass, c.slen);
		if (Tinf & 0x80) {
			SSLerr(SSL_F_D2I_SSL_SESSION,
			    ERR_R_BAD_ASN1_OBJECT_HEADER);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1))
			Tlen = c.slen - (c.p - c.q) - 2;
		if (d2i_ASN1_INTEGER(&aip, &c.p, Tlen) == NULL) {
			SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1)) {
			Tlen = c.slen - (c.p - c.q);
			if(!ASN1_const_check_infinite_end(&c.p, Tlen)) {
				SSLerr(SSL_F_D2I_SSL_SESSION,
				    ERR_R_MISSING_ASN1_EOS);
				goto err;
			}
		}
		c.slen -= (c.p - c.q);
	}
	if (ai.data != NULL) {
		ret->tlsext_tick_lifetime_hint = ASN1_INTEGER_get(aip);
		free(ai.data);
		ai.data = NULL;
		ai.length = 0;
	} else if (ret->tlsext_ticklen && ret->session_id_length)
		ret->tlsext_tick_lifetime_hint = -1;
	else
		ret->tlsext_tick_lifetime_hint = 0;
	os.length = 0;
	os.data = NULL;

	/* 10 - Ticket (OCTET STRING). */
	if (c.slen != 0L &&
	    *c.p == (V_ASN1_CONSTRUCTED | V_ASN1_CONTEXT_SPECIFIC | 10)) {
		c.q = c.p;
		Tinf = ASN1_get_object(&c.p, &Tlen, &Ttag, &Tclass, c.slen);
		if (Tinf & 0x80) {
			SSLerr(SSL_F_D2I_SSL_SESSION,
			    ERR_R_BAD_ASN1_OBJECT_HEADER);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1))
			Tlen = c.slen - (c.p - c.q) - 2;
		if (d2i_ASN1_OCTET_STRING(&osp, &c.p, Tlen) == NULL) {
			SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}
		if (Tinf == (V_ASN1_CONSTRUCTED + 1)) {
			Tlen = c.slen - (c.p - c.q);
			if(!ASN1_const_check_infinite_end(&c.p, Tlen)) {
				SSLerr(SSL_F_D2I_SSL_SESSION,
				    ERR_R_MISSING_ASN1_EOS);
				goto err;
			}
		}
		c.slen -= (c.p - c.q);
	}
	if (os.data) {
		ret->tlsext_tick = os.data;
		ret->tlsext_ticklen = os.length;
		os.data = NULL;
		os.length = 0;
	} else
		ret->tlsext_tick = NULL;

	/* 11 - Compression method (OCTET STRING). */
	/* 12 - SRP username (OCTET STRING). */

	if (!asn1_const_Finish(&c)) {
		SSLerr(SSL_F_D2I_SSL_SESSION, ERR_R_NESTED_ASN1_ERROR);
		goto err;
	}

	*pp = c.p;
	if (a != NULL)
		*a = ret;

	return (ret);

err:
	ERR_asprintf_error_data("offset=%d", (int)(c.q - *pp));
	if (ret != NULL && (a == NULL || *a != ret))
		SSL_SESSION_free(ret);

	return (NULL);
}
@


1.41
log
@X509_free(3) is NULL-safe, so remove NULL checks before its calls.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.40 2014/12/14 15:30:50 jsing Exp $ */
@


1.40
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.39 2014/10/20 12:55:21 bcook Exp $ */
d452 3
a454 4
	if (ret->peer != NULL) {
		X509_free(ret->peer);
		ret->peer = NULL;
	}
@


1.39
log
@SSL: Fix memory leak in d2i_SSL_SESSION.

Modified version of patch from Dmitry Eremin-Solenikov.

==28360== 98 bytes in 2 blocks are definitely lost in loss record 7 of 7
==28360==    at 0x402AC54: realloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so)
==28360==    by 0x40E2D2C: ASN1_STRING_set (asn1_lib.c:393)
==28360==    by 0x40EC22C: asn1_ex_c2i (tasn_dec.c:959)
==28360==    by 0x40EC632: asn1_d2i_ex_primitive (tasn_dec.c:824)
==28360==    by 0x40ED2E6: ASN1_item_ex_d2i (tasn_dec.c:230)
==28360==    by 0x40ED421: ASN1_item_d2i (tasn_dec.c:133)
==28360==    by 0x40F0335: d2i_ASN1_OCTET_STRING (tasn_typ.c:75)
==28360==    by 0x405FD6D: d2i_SSL_SESSION (ssl_asn1.c:367)
==28360==    by 0x405DD6E: ssl3_send_newsession_ticket (s3_srvr.c:2743)
==28360==    by 0x405EA48: ssl3_accept (s3_srvr.c:665)
==28360==    by 0x4067C34: SSL_accept (ssl_lib.c:922)
==28360==    by 0x404E97B: ssl23_get_client_hello (s23_srvr.c:573)

ok miod@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.38 2014/10/16 03:19:02 beck Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d144 1
a144 1
		v1 = i2d_ASN1_INTEGER(&(a.time), NULL); 
d153 1
a153 1
		v2 = i2d_ASN1_INTEGER(&(a.timeout), NULL); 
d158 1
a158 1
		v3 = i2d_X509(in->peer, NULL); 
d165 1
a165 1
	v4 = i2d_ASN1_OCTET_STRING(&(a.session_id_context), NULL); 
d173 1
a173 1
		v5 = i2d_ASN1_INTEGER(&(a.verify_result), NULL); 
d181 1
a181 1
		v6 = i2d_ASN1_OCTET_STRING(&(a.tlsext_hostname), NULL); 
d194 1
a194 1
		v9 = i2d_ASN1_INTEGER(&(a.tlsext_tick_lifetime), NULL); 
d202 1
a202 1
		v10 = i2d_ASN1_OCTET_STRING(&(a.tlsext_tick), NULL); 
@


1.38
log
@Get rid of the last remaining BUF_strdup and BUF_strlcpy and friends, use
intrinsic functions everywhere, and wrap these functions in an
#ifndef LIBRESSL_INTERNAL to make sure we don't bring their use back.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.37 2014/07/13 23:34:39 jsing Exp $ */
d484 1
@


1.37
log
@Stop leaking internal library pointers in error messages.

Requested by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.36 2014/07/13 21:38:23 jsing Exp $ */
d588 1
a588 1
		ret->tlsext_hostname = BUF_strndup((char *)os.data, os.length);
@


1.36
log
@Explicitly initialise slen - this was not previously done due to a missing
M_ASN1_D2I_begin macro.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.35 2014/07/13 21:35:27 jsing Exp $ */
d686 1
a686 1
	ERR_asprintf_error_data("address=%p offset=%d", *pp, (int)(c.q - *pp));
@


1.35
log
@Convert error handling to SSLerr and ERR_asprintf_error_data.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.34 2014/07/13 17:56:56 jsing Exp $ */
d277 1
@


1.34
log
@Convert d2i_SSL_SESSION to ASN1 primitives, instead of the horrific
asn1_mac.h macros. This still needs a lot of improvement, but immediately
becomes readable.

ok miod@@ (sight unseen!)
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.33 2014/07/13 16:43:37 jsing Exp $ */
a276 1
	c.error = ERR_R_NESTED_ASN1_ERROR;
d280 1
a280 1
			c.line = __LINE__;
d290 1
a290 1
		c.line = __LINE__;
d298 1
a298 1
		c.line = __LINE__;
d312 1
a312 1
		c.line = __LINE__;
d328 1
a328 1
		c.line = __LINE__;
d334 2
a335 2
			c.error = SSL_R_CIPHER_CODE_WRONG_LENGTH;
			c.line = __LINE__;
d341 1
a341 2
		c.error = SSL_R_UNKNOWN_SSL_VERSION;
		c.line = __LINE__;
d350 1
a350 1
		c.line = __LINE__;
d367 1
a367 1
		c.line = __LINE__;
d387 2
a388 2
			c.error = ERR_R_BAD_ASN1_OBJECT_HEADER;
			c.line = __LINE__;
d394 1
a394 1
			c.line = __LINE__;
d400 2
a401 2
				c.error = ERR_R_MISSING_ASN1_EOS;
				c.line = __LINE__;
d422 2
a423 2
			c.error = ERR_R_BAD_ASN1_OBJECT_HEADER;
			c.line = __LINE__;
d429 1
a429 1
			c.line = __LINE__;
d435 2
a436 2
				c.error = ERR_R_MISSING_ASN1_EOS;
				c.line = __LINE__;
d460 2
a461 2
			c.error = ERR_R_BAD_ASN1_OBJECT_HEADER;
			c.line = __LINE__;
d467 1
a467 1
			c.line = __LINE__;
d473 2
a474 2
				c.error = ERR_R_MISSING_ASN1_EOS;
				c.line = __LINE__;
d489 2
a490 2
			c.error = ERR_R_BAD_ASN1_OBJECT_HEADER;
			c.line = __LINE__;
d496 1
a496 1
			c.line = __LINE__;
d502 2
a503 2
				c.error = ERR_R_MISSING_ASN1_EOS;
				c.line = __LINE__;
d511 1
a511 2
			c.error = SSL_R_BAD_LENGTH;
			c.line = __LINE__;
d530 2
a531 2
			c.error = ERR_R_BAD_ASN1_OBJECT_HEADER;
			c.line = __LINE__;
d537 1
a537 1
			c.line = __LINE__;
d543 2
a544 2
				c.error = ERR_R_MISSING_ASN1_EOS;
				c.line = __LINE__;
d566 2
a567 2
			c.error = ERR_R_BAD_ASN1_OBJECT_HEADER;
			c.line = __LINE__;
d573 1
a573 1
			c.line = __LINE__;
d579 2
a580 2
				c.error = ERR_R_MISSING_ASN1_EOS;
				c.line = __LINE__;
d604 2
a605 2
			c.error = ERR_R_BAD_ASN1_OBJECT_HEADER;
			c.line = __LINE__;
d611 1
a611 1
			c.line = __LINE__;
d617 2
a618 2
				c.error = ERR_R_MISSING_ASN1_EOS;
				c.line = __LINE__;
d642 2
a643 2
			c.error = ERR_R_BAD_ASN1_OBJECT_HEADER;
			c.line = __LINE__;
d649 1
a649 1
			c.line = __LINE__;
d655 2
a656 2
				c.error = ERR_R_MISSING_ASN1_EOS;
				c.line = __LINE__;
d674 1
a674 1
		c.line = __LINE__;
d685 1
a685 3
	ERR_PUT_error(ERR_LIB_SSL, SSL_F_D2I_SSL_SESSION,
	    c.error, __FILE__, c.line);
	asn1_add_error(*pp, (int)(c.q - *pp));
@


1.33
log
@Remove license introduced with the PSK code, which has since been removed.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.32 2014/07/13 16:39:19 jsing Exp $ */
a63 1
#include <openssl/asn1_mac.h>
d67 4
d258 1
a258 1
        return (ret);
d264 4
d269 2
d272 14
a285 3
	ASN1_INTEGER ai, *aip;
	ASN1_OCTET_STRING os, *osp;
	M_ASN1_D2I_vars(a, SSL_SESSION *, SSL_SESSION_new);
d290 4
a293 2
	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
d297 7
a303 1
	M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);
d311 6
a316 1
	M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);
d327 6
a332 1
	M_ASN1_D2I_get_x(ASN1_OCTET_STRING, osp, d2i_ASN1_OCTET_STRING);
d350 7
a356 1
	M_ASN1_D2I_get_x(ASN1_OCTET_STRING, osp, d2i_ASN1_OCTET_STRING);
a357 1

d367 6
a372 1
	M_ASN1_D2I_get_x(ASN1_OCTET_STRING, osp, d2i_ASN1_OCTET_STRING);
d381 2
a382 1

d384 25
a408 1
	M_ASN1_D2I_get_EXP_opt(aip, d2i_ASN1_INTEGER, 1);	/* XXX 2038 */
d417 1
d419 25
a443 1
	M_ASN1_D2I_get_EXP_opt(aip, d2i_ASN1_INTEGER, 2);
d452 1
d457 25
a481 1
	M_ASN1_D2I_get_EXP_opt(ret->peer, d2i_X509, 3);
d483 1
d486 25
a510 2
	M_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 4);

d526 1
d528 25
a552 1
	M_ASN1_D2I_get_EXP_opt(aip, d2i_ASN1_INTEGER, 5);
d561 1
d564 25
a588 1
	M_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 6);
d597 2
d600 1
d602 25
a626 1
	M_ASN1_D2I_get_EXP_opt(aip, d2i_ASN1_INTEGER, 9);
d633 1
a633 1
	ret->tlsext_tick_lifetime_hint = -1;
d638 27
a664 1
	M_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 10);
d673 22
a694 1
	M_ASN1_D2I_Finish(a, SSL_SESSION_free, SSL_F_D2I_SSL_SESSION);
@


1.32
log
@Another compression remnant.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.31 2014/07/13 16:30:50 jsing Exp $ */
a56 26
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
@


1.31
log
@Rewrite i2d_SSL_SESSION to use the ASN1 primitives, rather than using the
horrific macros from asn1_mac.h.

This is a classic example of using macros to obfuscate code, in an attempt
to reduce the line count. The end result is so ridiculously convoluted that
it is completely unreadable and it takes hours to deconstruct the macros
and figure out what is actually going on behind the scenes.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.30 2014/07/13 00:30:07 jsing Exp $ */
a97 1
	ASN1_OCTET_STRING comp_id;
@


1.30
log
@KNF and some code cleaning.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.29 2014/07/11 12:07:30 miod Exp $ */
d119 2
a120 1
	M_ASN1_I2D_vars(in);
d137 1
d143 1
d145 1
d147 3
d151 1
a151 8

	if (in->cipher == NULL)
		l = in->cipher_id;
	else
		l = in->cipher->id;
	a.cipher.length = 2;
	buf[0] = ((unsigned char)(l >> 8L))&0xff;
	buf[1] = ((unsigned char)(l    ))&0xff;
d156 1
d161 1
a161 4

	a.session_id_context.length = in->sid_ctx_length;
	a.session_id_context.type = V_ASN1_OCTET_STRING;
	a.session_id_context.data = in->sid_ctx;
d168 2
d177 2
d181 11
d197 2
d205 2
d208 4
a211 5
	if (in->tlsext_tick) {
		a.tlsext_tick.length = in->tlsext_ticklen;
		a.tlsext_tick.type = V_ASN1_OCTET_STRING;
		a.tlsext_tick.data = (unsigned char *)in->tlsext_tick;
	}
d218 2
d222 58
a279 54
	M_ASN1_I2D_len(&(a.version), i2d_ASN1_INTEGER);
	M_ASN1_I2D_len(&(a.ssl_version), i2d_ASN1_INTEGER);
	M_ASN1_I2D_len(&(a.cipher), i2d_ASN1_OCTET_STRING);
	M_ASN1_I2D_len(&(a.session_id), i2d_ASN1_OCTET_STRING);
	M_ASN1_I2D_len(&(a.master_key), i2d_ASN1_OCTET_STRING);

	if (in->time != 0L)
		M_ASN1_I2D_len_EXP_opt(&(a.time), i2d_ASN1_INTEGER, 1, v1);
	if (in->timeout != 0L)
		M_ASN1_I2D_len_EXP_opt(&(a.timeout), i2d_ASN1_INTEGER, 2, v2);
	if (in->peer != NULL)
		M_ASN1_I2D_len_EXP_opt(in->peer, i2d_X509, 3, v3);
	M_ASN1_I2D_len_EXP_opt(&a.session_id_context,
	    i2d_ASN1_OCTET_STRING, 4, v4);
	if (in->verify_result != X509_V_OK)
		M_ASN1_I2D_len_EXP_opt(&(a.verify_result),
		    i2d_ASN1_INTEGER, 5, v5);
	if (in->tlsext_tick_lifetime_hint > 0)
		M_ASN1_I2D_len_EXP_opt(&a.tlsext_tick_lifetime,
		    i2d_ASN1_INTEGER, 9, v9);
	if (in->tlsext_tick)
		M_ASN1_I2D_len_EXP_opt(&(a.tlsext_tick),
		    i2d_ASN1_OCTET_STRING, 10, v10);
	if (in->tlsext_hostname)
		M_ASN1_I2D_len_EXP_opt(&(a.tlsext_hostname),
		    i2d_ASN1_OCTET_STRING, 6, v6);

	M_ASN1_I2D_seq_total();

	M_ASN1_I2D_put(&(a.version), i2d_ASN1_INTEGER);
	M_ASN1_I2D_put(&(a.ssl_version), i2d_ASN1_INTEGER);
	M_ASN1_I2D_put(&(a.cipher), i2d_ASN1_OCTET_STRING);
	M_ASN1_I2D_put(&(a.session_id), i2d_ASN1_OCTET_STRING);
	M_ASN1_I2D_put(&(a.master_key), i2d_ASN1_OCTET_STRING);
	if (in->time != 0L)
		M_ASN1_I2D_put_EXP_opt(&(a.time), i2d_ASN1_INTEGER, 1, v1);
	if (in->timeout != 0L)
		M_ASN1_I2D_put_EXP_opt(&(a.timeout), i2d_ASN1_INTEGER, 2, v2);
	if (in->peer != NULL)
		M_ASN1_I2D_put_EXP_opt(in->peer, i2d_X509, 3, v3);
	M_ASN1_I2D_put_EXP_opt(&a.session_id_context,
	    i2d_ASN1_OCTET_STRING, 4, v4);
	if (in->verify_result != X509_V_OK)
		M_ASN1_I2D_put_EXP_opt(&a.verify_result,
		    i2d_ASN1_INTEGER, 5, v5);
	if (in->tlsext_hostname)
		M_ASN1_I2D_put_EXP_opt(&(a.tlsext_hostname),
		    i2d_ASN1_OCTET_STRING, 6, v6);
	if (in->tlsext_tick_lifetime_hint > 0)
		M_ASN1_I2D_put_EXP_opt(&a.tlsext_tick_lifetime,
		    i2d_ASN1_INTEGER, 9, v9);
	if (in->tlsext_tick)
		M_ASN1_I2D_put_EXP_opt(&(a.tlsext_tick),
		    i2d_ASN1_OCTET_STRING, 10, v10);
d281 2
a282 1
	M_ASN1_I2D_finish();
@


1.29
log
@Missing initialization for error line in error paths; from Coverity via
OpenSSL trunk.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.28 2014/07/11 09:24:44 beck Exp $ */
d87 1
d89 1
d114 1
a114 1
	int v1 = 0, v2 = 0, v3 = 0, v4 = 0, v5 = 0;
a116 1
	int v6 = 0, v9 = 0, v10 = 0;
a117 1
	long l;
d120 1
d125 3
a127 2
	/* Note that I cheat in the following 2 assignments.  I know
	 * that if the ASN1_INTEGER passed to ASN1_INTEGER_set
d130 2
a131 1
	 * to clean up :-) */
a152 1

a164 1

d200 2
a201 1
		ASN1_INTEGER_set(&a.tlsext_tick_lifetime, in->tlsext_tick_lifetime_hint);
d204 6
a209 5
	M_ASN1_I2D_len(&(a.version),		i2d_ASN1_INTEGER);
	M_ASN1_I2D_len(&(a.ssl_version),	i2d_ASN1_INTEGER);
	M_ASN1_I2D_len(&(a.cipher),		i2d_ASN1_OCTET_STRING);
	M_ASN1_I2D_len(&(a.session_id),		i2d_ASN1_OCTET_STRING);
	M_ASN1_I2D_len(&(a.master_key),		i2d_ASN1_OCTET_STRING);
d216 2
a217 1
	M_ASN1_I2D_len_EXP_opt(&a.session_id_context, i2d_ASN1_OCTET_STRING, 4, v4);
d219 2
a220 2
		M_ASN1_I2D_len_EXP_opt(&(a.verify_result), i2d_ASN1_INTEGER, 5, v5);

d222 2
a223 1
		M_ASN1_I2D_len_EXP_opt(&a.tlsext_tick_lifetime, i2d_ASN1_INTEGER, 9, v9);
d225 2
a226 1
		M_ASN1_I2D_len_EXP_opt(&(a.tlsext_tick), i2d_ASN1_OCTET_STRING, 10, v10);
d228 2
a229 1
		M_ASN1_I2D_len_EXP_opt(&(a.tlsext_hostname), i2d_ASN1_OCTET_STRING, 6, v6);
d233 5
a237 5
	M_ASN1_I2D_put(&(a.version),		i2d_ASN1_INTEGER);
	M_ASN1_I2D_put(&(a.ssl_version),	i2d_ASN1_INTEGER);
	M_ASN1_I2D_put(&(a.cipher),		i2d_ASN1_OCTET_STRING);
	M_ASN1_I2D_put(&(a.session_id),		i2d_ASN1_OCTET_STRING);
	M_ASN1_I2D_put(&(a.master_key),		i2d_ASN1_OCTET_STRING);
d244 2
a245 2
	M_ASN1_I2D_put_EXP_opt(&a.session_id_context, i2d_ASN1_OCTET_STRING, 4,
	v4);
d247 2
a248 1
		M_ASN1_I2D_put_EXP_opt(&a.verify_result, i2d_ASN1_INTEGER, 5, v5);
d250 2
a251 1
		M_ASN1_I2D_put_EXP_opt(&(a.tlsext_hostname), i2d_ASN1_OCTET_STRING, 6, v6);
d253 2
a254 1
		M_ASN1_I2D_put_EXP_opt(&a.tlsext_tick_lifetime, i2d_ASN1_INTEGER, 9, v9);
d256 3
a258 1
		M_ASN1_I2D_put_EXP_opt(&(a.tlsext_tick), i2d_ASN1_OCTET_STRING, 10, v10);
d305 2
a306 3
		id = 0x03000000L|
		((unsigned long)os.data[0]<<8L)|
		(unsigned long)os.data[1];
a425 1

@


1.28
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.27 2014/07/10 08:51:15 tedu Exp $ */
d290 1
d298 1
d360 1
@


1.27
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_asn1.c,v 1.26 2014/06/12 15:49:31 deraadt Exp $ */
a105 4
#ifndef OPENSSL_NO_PSK
	ASN1_OCTET_STRING psk_identity_hint;
	ASN1_OCTET_STRING psk_identity;
#endif /* OPENSSL_NO_PSK */
d112 1
a112 1
	int v1 = 0, v2 = 0, v3 = 0, v4 = 0, v5 = 0, v7 = 0, v8 = 0;
a200 12
#ifndef OPENSSL_NO_PSK
	if (in->psk_identity_hint) {
		a.psk_identity_hint.length = strlen(in->psk_identity_hint);
		a.psk_identity_hint.type = V_ASN1_OCTET_STRING;
		a.psk_identity_hint.data = (unsigned char *)(in->psk_identity_hint);
	}
	if (in->psk_identity) {
		a.psk_identity.length = strlen(in->psk_identity);
		a.psk_identity.type = V_ASN1_OCTET_STRING;
		a.psk_identity.data = (unsigned char *)(in->psk_identity);
	}
#endif /* OPENSSL_NO_PSK */
a222 6
#ifndef OPENSSL_NO_PSK
	if (in->psk_identity_hint)
		M_ASN1_I2D_len_EXP_opt(&(a.psk_identity_hint), i2d_ASN1_OCTET_STRING, 7, v7);
	if (in->psk_identity)
		M_ASN1_I2D_len_EXP_opt(&(a.psk_identity), i2d_ASN1_OCTET_STRING, 8, v8);
#endif /* OPENSSL_NO_PSK */
a242 6
#ifndef OPENSSL_NO_PSK
	if (in->psk_identity_hint)
		M_ASN1_I2D_put_EXP_opt(&(a.psk_identity_hint), i2d_ASN1_OCTET_STRING, 7, v7);
	if (in->psk_identity)
		M_ASN1_I2D_put_EXP_opt(&(a.psk_identity), i2d_ASN1_OCTET_STRING, 8, v8);
#endif /* OPENSSL_NO_PSK */
a389 23
#ifndef OPENSSL_NO_PSK
	os.length = 0;
	os.data = NULL;
	M_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 7);
	if (os.data) {
		ret->psk_identity_hint = BUF_strndup((char *)os.data, os.length);
		free(os.data);
		os.data = NULL;
		os.length = 0;
	} else
		ret->psk_identity_hint = NULL;

	os.length = 0;
	os.data = NULL;
	M_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 8);
	if (os.data) {
		ret->psk_identity = BUF_strndup((char *)os.data, os.length);
		free(os.data);
		os.data = NULL;
		os.length = 0;
	} else
		ret->psk_identity = NULL;
#endif /* OPENSSL_NO_PSK */
@


1.26
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a120 4
#ifndef OPENSSL_NO_COMP
	unsigned char cbuf;
	int v11 = 0;
#endif
a153 8
#ifndef OPENSSL_NO_COMP
	if (in->compress_meth) {
		cbuf = (unsigned char)in->compress_meth;
		a.comp_id.length = 1;
		a.comp_id.type = V_ASN1_OCTET_STRING;
		a.comp_id.data = &cbuf;
	}
#endif
a238 4
#ifndef OPENSSL_NO_COMP
	if (in->compress_meth)
		M_ASN1_I2D_len_EXP_opt(&(a.comp_id), i2d_ASN1_OCTET_STRING, 11, v11);
#endif
a274 4
#ifndef OPENSSL_NO_COMP
	if (in->compress_meth)
		M_ASN1_I2D_put_EXP_opt(&(a.comp_id), i2d_ASN1_OCTET_STRING, 11, v11);
#endif
a462 10
#ifndef OPENSSL_NO_COMP
	os.length = 0;
	os.data = NULL;
	M_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 11);
	if (os.data) {
		ret->compress_meth = os.data[0];
		free(os.data);
		os.data = NULL;
	}
#endif
@


1.25
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@d1 1
a1 1
/* ssl/ssl_asn1.c */
@


1.24
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@a102 1
#ifndef OPENSSL_NO_TLSEXT
a105 1
#endif /* OPENSSL_NO_TLSEXT */
a118 1
#ifndef OPENSSL_NO_TLSEXT
a120 1
#endif
a200 1
#ifndef OPENSSL_NO_TLSEXT
a216 1
#endif /* OPENSSL_NO_TLSEXT */
a244 1
#ifndef OPENSSL_NO_TLSEXT
a254 1
#endif /* OPENSSL_NO_TLSEXT */
a278 1
#ifndef OPENSSL_NO_TLSEXT
a280 1
#endif /* OPENSSL_NO_TLSEXT */
a286 1
#ifndef OPENSSL_NO_TLSEXT
a290 1
#endif /* OPENSSL_NO_TLSEXT */
a426 1
#ifndef OPENSSL_NO_TLSEXT
a436 1
#endif /* OPENSSL_NO_TLSEXT */
a461 1
#ifndef OPENSSL_NO_TLSEXT
a482 1
#endif /* OPENSSL_NO_TLSEXT */
@


1.23
log
@Chop off more SSLv2 tentacles and start fixing and noting y2038 issues.
APIs that pass times as longs will have to change at some point...
Bump major on both libcrypto and libssl.

ok tedu@@
@
text
@a99 3
#ifndef OPENSSL_NO_KRB5
	ASN1_OCTET_STRING krb5_princ;
#endif /* OPENSSL_NO_KRB5 */
a111 3
#ifndef OPENSSL_NO_SRP
	ASN1_OCTET_STRING srp_username;
#endif /* OPENSSL_NO_SRP */
a128 3
#ifndef OPENSSL_NO_SRP
	int v12 = 0;
#endif
a182 7
#ifndef OPENSSL_NO_KRB5
	if (in->krb5_client_princ_len) {
		a.krb5_princ.length = in->krb5_client_princ_len;
		a.krb5_princ.type = V_ASN1_OCTET_STRING;
		a.krb5_princ.data = in->krb5_client_princ;
	}
#endif /* OPENSSL_NO_KRB5 */
a234 7
#ifndef OPENSSL_NO_SRP
	if (in->srp_username) {
		a.srp_username.length = strlen(in->srp_username);
		a.srp_username.type = V_ASN1_OCTET_STRING;
		a.srp_username.data = (unsigned char *)(in->srp_username);
	}
#endif /* OPENSSL_NO_SRP */
a240 4
#ifndef OPENSSL_NO_KRB5
	if (in->krb5_client_princ_len)
		M_ASN1_I2D_len(&(a.krb5_princ),	i2d_ASN1_OCTET_STRING);
#endif /* OPENSSL_NO_KRB5 */
a268 4
#ifndef OPENSSL_NO_SRP
	if (in->srp_username)
		M_ASN1_I2D_len_EXP_opt(&(a.srp_username), i2d_ASN1_OCTET_STRING, 12, v12);
#endif /* OPENSSL_NO_SRP */
a276 4
#ifndef OPENSSL_NO_KRB5
	if (in->krb5_client_princ_len)
		M_ASN1_I2D_put(&(a.krb5_princ),	i2d_ASN1_OCTET_STRING);
#endif /* OPENSSL_NO_KRB5 */
a306 4
#ifndef OPENSSL_NO_SRP
	if (in->srp_username)
		M_ASN1_I2D_put_EXP_opt(&(a.srp_username), i2d_ASN1_OCTET_STRING, 12, v12);
#endif /* OPENSSL_NO_SRP */
a383 15
#ifndef OPENSSL_NO_KRB5
	os.length = 0;
	M_ASN1_D2I_get_opt(osp, d2i_ASN1_OCTET_STRING, V_ASN1_OCTET_STRING);
	if (os.data) {
		if (os.length > SSL_MAX_KRB5_PRINCIPAL_LENGTH)
			ret->krb5_client_princ_len = 0;
		else
			ret->krb5_client_princ_len = os.length;
		memcpy(ret->krb5_client_princ, os.data, ret->krb5_client_princ_len);
		free(os.data);
		os.data = NULL;
		os.length = 0;
	} else
		ret->krb5_client_princ_len = 0;
#endif /* OPENSSL_NO_KRB5 */
a509 12
#ifndef OPENSSL_NO_SRP
	os.length = 0;
	os.data = NULL;
	M_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 12);
	if (os.data) {
		ret->srp_username = BUF_strndup((char *)os.data, os.length);
		free(os.data);
		os.data = NULL;
		os.length = 0;
	} else
		ret->srp_username = NULL;
#endif /* OPENSSL_NO_SRP */
@


1.22
log
@More KNF and style consistency tweaks
@
text
@a99 1
	ASN1_OCTET_STRING key_arg;
a191 4
	a.key_arg.length = in->key_arg_length;
	a.key_arg.type = V_ASN1_OCTET_STRING;
	a.key_arg.data = in->key_arg;

d204 1
a204 1
		ASN1_INTEGER_set(&(a.time), in->time);
a267 2
	if (in->key_arg_length > 0)
		M_ASN1_I2D_len_IMP_opt(&(a.key_arg), i2d_ASN1_OCTET_STRING);
a311 2
	if (in->key_arg_length > 0)
		M_ASN1_I2D_put_IMP_opt(&(a.key_arg), i2d_ASN1_OCTET_STRING, 0);
a438 9
	M_ASN1_D2I_get_IMP_opt(osp, d2i_ASN1_OCTET_STRING, 0, V_ASN1_OCTET_STRING);
	if (os.length > SSL_MAX_KEY_ARG_LENGTH)
		ret->key_arg_length = SSL_MAX_KEY_ARG_LENGTH;
	else
		ret->key_arg_length = os.length;
	memcpy(ret->key_arg, os.data, ret->key_arg_length);
	if (os.data != NULL)
		free(os.data);

d440 1
a440 1
	M_ASN1_D2I_get_EXP_opt(aip, d2i_ASN1_INTEGER, 1);
d447 1
a447 1
		ret->time = (unsigned long)time(NULL);
@


1.21
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d358 2
a359 3
SSL_SESSION
*d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,
long length)
@


1.20
log
@add back SRP. i was being too greedy.
@
text
@d148 1
a148 1
	 * is > sizeof(long)+1, the buffer will not be re-OPENSSL_malloc()ed.
d378 1
a378 1
		OPENSSL_free(ai.data);
d388 1
a388 1
		OPENSSL_free(ai.data);
d442 1
a442 1
		OPENSSL_free(os.data);
d456 1
a456 1
		OPENSSL_free(os.data);
d462 1
a462 1
		OPENSSL_free(ai.data);
d472 1
a472 1
		OPENSSL_free(ai.data);
d496 1
a496 1
		OPENSSL_free(os.data);
d506 1
a506 1
		OPENSSL_free(ai.data);
d518 1
a518 1
		OPENSSL_free(os.data);
d531 1
a531 1
		OPENSSL_free(os.data);
d542 1
a542 1
		OPENSSL_free(os.data);
d554 1
a554 1
		OPENSSL_free(ai.data);
d578 1
a578 1
		OPENSSL_free(os.data);
d589 1
a589 1
		OPENSSL_free(os.data);
@


1.19
log
@disentangle SRP code from TLS
@
text
@d116 3
d136 3
d256 7
d303 4
d351 4
d583 12
@


1.18
log
@Kill the bogus "send an SSLv3/TLS hello in SSLv2 format" crap from
the SSLv23_* client code.  The server continues to accept it.  It
also kills the bits for SSL2 SESSIONs; even when the server gets
an SSLv2-style compat handshake, the session that it creates has
the correct version internally.

ok tedu@@ beck@@
@
text
@a115 3
#ifndef OPENSSL_NO_SRP
	ASN1_OCTET_STRING srp_username;
#endif /* OPENSSL_NO_SRP */
a132 3
#ifndef OPENSSL_NO_SRP
	int v12 = 0;
#endif
a249 7
#ifndef OPENSSL_NO_SRP
	if (in->srp_username) {
		a.srp_username.length = strlen(in->srp_username);
		a.srp_username.type = V_ASN1_OCTET_STRING;
		a.srp_username.data = (unsigned char *)(in->srp_username);
	}
#endif /* OPENSSL_NO_SRP */
a289 4
#ifndef OPENSSL_NO_SRP
	if (in->srp_username)
		M_ASN1_I2D_len_EXP_opt(&(a.srp_username), i2d_ASN1_OCTET_STRING, 12, v12);
#endif /* OPENSSL_NO_SRP */
a333 4
#ifndef OPENSSL_NO_SRP
	if (in->srp_username)
		M_ASN1_I2D_put_EXP_opt(&(a.srp_username), i2d_ASN1_OCTET_STRING, 12, v12);
#endif /* OPENSSL_NO_SRP */
a561 12
#ifndef OPENSSL_NO_SRP
	os.length = 0;
	os.data = NULL;
	M_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 12);
	if (os.data) {
		ret->srp_username = BUF_strndup((char *)os.data, os.length);
		OPENSSL_free(os.data);
		os.data = NULL;
		os.length = 0;
	} else
		ret->srp_username = NULL;
#endif /* OPENSSL_NO_SRP */
@


1.17
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d168 3
a170 10
	if (in->ssl_version == SSL2_VERSION) {
		a.cipher.length = 3;
		buf[0] = ((unsigned char)(l >> 16L))&0xff;
		buf[1] = ((unsigned char)(l >> 8L))&0xff;
		buf[2] = ((unsigned char)(l     ))&0xff;
	} else {
		a.cipher.length = 2;
		buf[0] = ((unsigned char)(l >> 8L))&0xff;
		buf[1] = ((unsigned char)(l    ))&0xff;
	}
d396 1
a396 10
	if (ssl_version == SSL2_VERSION) {
		if (os.length != 3) {
			c.error = SSL_R_CIPHER_CODE_WRONG_LENGTH;
			goto err;
		}
		id = 0x02000000L|
		((unsigned long)os.data[0]<<16L)|
		((unsigned long)os.data[1]<< 8L)|
		(unsigned long)os.data[2];
	} else if ((ssl_version >> 8) >= SSL3_VERSION_MAJOR) {
d413 1
a413 4
	if ((ssl_version >> 8) >= SSL3_VERSION_MAJOR)
		i = SSL3_MAX_SSL_SESSION_ID_LENGTH;
	else /* if (ssl_version>>8 == SSL2_VERSION_MAJOR) */
	i = SSL2_MAX_SSL_SESSION_ID_LENGTH;
@


1.16
log
@resolve conflicts
@
text
@d92 1
a92 2
typedef struct ssl_session_asn1_st
	{
d102 1
a102 1
        ASN1_OCTET_STRING krb5_princ;
d119 1
a119 1
	} SSL_SESSION_ASN1;
d121 3
a123 2
int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp)
	{
d125 3
a127 3
	int v1=0,v2=0,v3=0,v4=0,v5=0,v7=0,v8=0;
	unsigned char buf[4],ibuf1[LSIZE2],ibuf2[LSIZE2];
	unsigned char ibuf3[LSIZE2],ibuf4[LSIZE2],ibuf5[LSIZE2];
d129 1
a129 1
	int v6=0,v9=0,v10=0;
d134 1
a134 1
	int v11=0;
d137 1
a137 1
	int v12=0;
d144 1
a144 1
		return(0);
d151 9
a159 9
	a.version.length=LSIZE2;
	a.version.type=V_ASN1_INTEGER;
	a.version.data=ibuf1;
	ASN1_INTEGER_set(&(a.version),SSL_SESSION_ASN1_VERSION);

	a.ssl_version.length=LSIZE2;
	a.ssl_version.type=V_ASN1_INTEGER;
	a.ssl_version.data=ibuf2;
	ASN1_INTEGER_set(&(a.ssl_version),in->ssl_version);
d161 2
a162 2
	a.cipher.type=V_ASN1_OCTET_STRING;
	a.cipher.data=buf;
d165 1
a165 1
		l=in->cipher_id;
d167 11
a177 14
		l=in->cipher->id;
	if (in->ssl_version == SSL2_VERSION)
		{
		a.cipher.length=3;
		buf[0]=((unsigned char)(l>>16L))&0xff;
		buf[1]=((unsigned char)(l>> 8L))&0xff;
		buf[2]=((unsigned char)(l     ))&0xff;
		}
	else
		{
		a.cipher.length=2;
		buf[0]=((unsigned char)(l>>8L))&0xff;
		buf[1]=((unsigned char)(l    ))&0xff;
		}
d180 1
a180 2
	if (in->compress_meth)
		{
d185 1
a185 1
		}
d188 15
a202 15
	a.master_key.length=in->master_key_length;
	a.master_key.type=V_ASN1_OCTET_STRING;
	a.master_key.data=in->master_key;

	a.session_id.length=in->session_id_length;
	a.session_id.type=V_ASN1_OCTET_STRING;
	a.session_id.data=in->session_id;

	a.session_id_context.length=in->sid_ctx_length;
	a.session_id_context.type=V_ASN1_OCTET_STRING;
	a.session_id_context.data=in->sid_ctx;

	a.key_arg.length=in->key_arg_length;
	a.key_arg.type=V_ASN1_OCTET_STRING;
	a.key_arg.data=in->key_arg;
d205 5
a209 6
	if (in->krb5_client_princ_len)
		{
		a.krb5_princ.length=in->krb5_client_princ_len;
		a.krb5_princ.type=V_ASN1_OCTET_STRING;
		a.krb5_princ.data=in->krb5_client_princ;
		}
d212 6
a217 7
	if (in->time != 0L)
		{
		a.time.length=LSIZE2;
		a.time.type=V_ASN1_INTEGER;
		a.time.data=ibuf3;
		ASN1_INTEGER_set(&(a.time),in->time);
		}
d219 6
a224 7
	if (in->timeout != 0L)
		{
		a.timeout.length=LSIZE2;
		a.timeout.type=V_ASN1_INTEGER;
		a.timeout.data=ibuf4;
		ASN1_INTEGER_set(&(a.timeout),in->timeout);
		}
d226 6
a231 7
	if (in->verify_result != X509_V_OK)
		{
		a.verify_result.length=LSIZE2;
		a.verify_result.type=V_ASN1_INTEGER;
		a.verify_result.data=ibuf5;
		ASN1_INTEGER_set(&a.verify_result,in->verify_result);
		}
d234 16
a249 19
	if (in->tlsext_hostname)
                {
                a.tlsext_hostname.length=strlen(in->tlsext_hostname);
                a.tlsext_hostname.type=V_ASN1_OCTET_STRING;
                a.tlsext_hostname.data=(unsigned char *)in->tlsext_hostname;
                }
	if (in->tlsext_tick)
                {
                a.tlsext_tick.length= in->tlsext_ticklen;
                a.tlsext_tick.type=V_ASN1_OCTET_STRING;
                a.tlsext_tick.data=(unsigned char *)in->tlsext_tick;
                }
	if (in->tlsext_tick_lifetime_hint > 0)
		{
		a.tlsext_tick_lifetime.length=LSIZE2;
		a.tlsext_tick_lifetime.type=V_ASN1_INTEGER;
		a.tlsext_tick_lifetime.data=ibuf6;
		ASN1_INTEGER_set(&a.tlsext_tick_lifetime,in->tlsext_tick_lifetime_hint);
		}
d252 10
a261 12
	if (in->psk_identity_hint)
		{
		a.psk_identity_hint.length=strlen(in->psk_identity_hint);
		a.psk_identity_hint.type=V_ASN1_OCTET_STRING;
		a.psk_identity_hint.data=(unsigned char *)(in->psk_identity_hint);
		}
	if (in->psk_identity)
		{
		a.psk_identity.length=strlen(in->psk_identity);
		a.psk_identity.type=V_ASN1_OCTET_STRING;
		a.psk_identity.data=(unsigned char *)(in->psk_identity);
		}
d264 5
a268 6
	if (in->srp_username)
		{
		a.srp_username.length=strlen(in->srp_username);
		a.srp_username.type=V_ASN1_OCTET_STRING;
		a.srp_username.data=(unsigned char *)(in->srp_username);
		}
d278 1
a278 1
        	M_ASN1_I2D_len(&(a.krb5_princ),	i2d_ASN1_OCTET_STRING);
d281 1
a281 1
		M_ASN1_I2D_len_IMP_opt(&(a.key_arg),i2d_ASN1_OCTET_STRING);
d283 1
a283 1
		M_ASN1_I2D_len_EXP_opt(&(a.time),i2d_ASN1_INTEGER,1,v1);
d285 1
a285 1
		M_ASN1_I2D_len_EXP_opt(&(a.timeout),i2d_ASN1_INTEGER,2,v2);
d287 2
a288 2
		M_ASN1_I2D_len_EXP_opt(in->peer,i2d_X509,3,v3);
	M_ASN1_I2D_len_EXP_opt(&a.session_id_context,i2d_ASN1_OCTET_STRING,4,v4);
d290 1
a290 1
		M_ASN1_I2D_len_EXP_opt(&(a.verify_result),i2d_ASN1_INTEGER,5,v5);
d294 1
a294 1
      	 	M_ASN1_I2D_len_EXP_opt(&a.tlsext_tick_lifetime, i2d_ASN1_INTEGER,9,v9);
d296 1
a296 1
        	M_ASN1_I2D_len_EXP_opt(&(a.tlsext_tick), i2d_ASN1_OCTET_STRING,10,v10);
d298 1
a298 1
        	M_ASN1_I2D_len_EXP_opt(&(a.tlsext_hostname), i2d_ASN1_OCTET_STRING,6,v6);
d301 1
a301 1
        	M_ASN1_I2D_len_EXP_opt(&(a.comp_id), i2d_ASN1_OCTET_STRING,11,v11);
d306 1
a306 1
        	M_ASN1_I2D_len_EXP_opt(&(a.psk_identity_hint), i2d_ASN1_OCTET_STRING,7,v7);
d308 1
a308 1
        	M_ASN1_I2D_len_EXP_opt(&(a.psk_identity), i2d_ASN1_OCTET_STRING,8,v8);
d312 1
a312 1
        	M_ASN1_I2D_len_EXP_opt(&(a.srp_username), i2d_ASN1_OCTET_STRING,12,v12);
d324 1
a324 1
        	M_ASN1_I2D_put(&(a.krb5_princ),	i2d_ASN1_OCTET_STRING);
d327 1
a327 1
		M_ASN1_I2D_put_IMP_opt(&(a.key_arg),i2d_ASN1_OCTET_STRING,0);
d329 1
a329 1
		M_ASN1_I2D_put_EXP_opt(&(a.time),i2d_ASN1_INTEGER,1,v1);
d331 1
a331 1
		M_ASN1_I2D_put_EXP_opt(&(a.timeout),i2d_ASN1_INTEGER,2,v2);
d333 3
a335 3
		M_ASN1_I2D_put_EXP_opt(in->peer,i2d_X509,3,v3);
	M_ASN1_I2D_put_EXP_opt(&a.session_id_context,i2d_ASN1_OCTET_STRING,4,
			       v4);
d337 1
a337 1
		M_ASN1_I2D_put_EXP_opt(&a.verify_result,i2d_ASN1_INTEGER,5,v5);
d340 1
a340 1
        	M_ASN1_I2D_put_EXP_opt(&(a.tlsext_hostname), i2d_ASN1_OCTET_STRING,6,v6);
d344 1
a344 1
		M_ASN1_I2D_put_EXP_opt(&(a.psk_identity_hint), i2d_ASN1_OCTET_STRING,7,v7);
d346 1
a346 1
		M_ASN1_I2D_put_EXP_opt(&(a.psk_identity), i2d_ASN1_OCTET_STRING,8,v8);
d350 1
a350 1
      	 	M_ASN1_I2D_put_EXP_opt(&a.tlsext_tick_lifetime, i2d_ASN1_INTEGER,9,v9);
d352 1
a352 1
        	M_ASN1_I2D_put_EXP_opt(&(a.tlsext_tick), i2d_ASN1_OCTET_STRING,10,v10);
d356 1
a356 1
        	M_ASN1_I2D_put_EXP_opt(&(a.comp_id), i2d_ASN1_OCTET_STRING,11,v11);
d360 1
a360 1
		M_ASN1_I2D_put_EXP_opt(&(a.srp_username), i2d_ASN1_OCTET_STRING,12,v12);
d363 1
a363 1
	}
d365 5
a369 4
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,
			     long length)
	{
	int ssl_version=0,i;
d371 3
a373 3
	ASN1_INTEGER ai,*aip;
	ASN1_OCTET_STRING os,*osp;
	M_ASN1_D2I_vars(a,SSL_SESSION *,SSL_SESSION_new);
d375 2
a376 2
	aip= &ai;
	osp= &os;
d381 8
a388 3
	ai.data=NULL; ai.length=0;
	M_ASN1_D2I_get_x(ASN1_INTEGER,aip,d2i_ASN1_INTEGER);
	if (ai.data != NULL) { OPENSSL_free(ai.data); ai.data=NULL; ai.length=0; }
d391 15
a405 12
	M_ASN1_D2I_get_x(ASN1_INTEGER,aip,d2i_ASN1_INTEGER);
	ssl_version=(int)ASN1_INTEGER_get(aip);
	ret->ssl_version=ssl_version;
	if (ai.data != NULL) { OPENSSL_free(ai.data); ai.data=NULL; ai.length=0; }

	os.data=NULL; os.length=0;
	M_ASN1_D2I_get_x(ASN1_OCTET_STRING,osp,d2i_ASN1_OCTET_STRING);
	if (ssl_version == SSL2_VERSION)
		{
		if (os.length != 3)
			{
			c.error=SSL_R_CIPHER_CODE_WRONG_LENGTH;
a406 5
			}
		id=0x02000000L|
			((unsigned long)os.data[0]<<16L)|
			((unsigned long)os.data[1]<< 8L)|
			 (unsigned long)os.data[2];
d408 7
a414 5
	else if ((ssl_version>>8) >= SSL3_VERSION_MAJOR)
		{
		if (os.length != 2)
			{
			c.error=SSL_R_CIPHER_CODE_WRONG_LENGTH;
a415 4
			}
		id=0x03000000L|
			((unsigned long)os.data[0]<<8L)|
			 (unsigned long)os.data[1];
d417 5
a421 3
	else
		{
		c.error=SSL_R_UNKNOWN_SSL_VERSION;
d423 8
a430 8
		}
	
	ret->cipher=NULL;
	ret->cipher_id=id;

	M_ASN1_D2I_get_x(ASN1_OCTET_STRING,osp,d2i_ASN1_OCTET_STRING);
	if ((ssl_version>>8) >= SSL3_VERSION_MAJOR)
		i=SSL3_MAX_SSL_SESSION_ID_LENGTH;
d432 1
a432 1
		i=SSL2_MAX_SSL_SESSION_ID_LENGTH;
d439 1
a439 1
	ret->session_id_length=os.length;
d441 1
a441 1
	memcpy(ret->session_id,os.data,os.length);
d443 1
a443 1
	M_ASN1_D2I_get_x(ASN1_OCTET_STRING,osp,d2i_ASN1_OCTET_STRING);
d445 1
a445 1
		ret->master_key_length=SSL_MAX_MASTER_KEY_LENGTH;
d447 2
a448 2
		ret->master_key_length=os.length;
	memcpy(ret->master_key,os.data,ret->master_key_length);
d450 1
a450 1
	os.length=0;
d453 5
a457 6
	os.length=0;
	M_ASN1_D2I_get_opt(osp,d2i_ASN1_OCTET_STRING,V_ASN1_OCTET_STRING);
	if (os.data)
		{
        	if (os.length > SSL_MAX_KRB5_PRINCIPAL_LENGTH)
            		ret->krb5_client_princ_len=0;
d459 2
a460 2
			ret->krb5_client_princ_len=os.length;
		memcpy(ret->krb5_client_princ,os.data,ret->krb5_client_princ_len);
d464 2
a465 3
		}
	else
		ret->krb5_client_princ_len=0;
d468 1
a468 1
	M_ASN1_D2I_get_IMP_opt(osp,d2i_ASN1_OCTET_STRING,0,V_ASN1_OCTET_STRING);
d470 1
a470 1
		ret->key_arg_length=SSL_MAX_KEY_ARG_LENGTH;
d472 4
a475 13
		ret->key_arg_length=os.length;
	memcpy(ret->key_arg,os.data,ret->key_arg_length);
	if (os.data != NULL) OPENSSL_free(os.data);

	ai.length=0;
	M_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,1);
	if (ai.data != NULL)
		{
		ret->time=ASN1_INTEGER_get(aip);
		OPENSSL_free(ai.data); ai.data=NULL; ai.length=0;
		}
	else
		ret->time=(unsigned long)time(NULL);
d477 19
a495 9
	ai.length=0;
	M_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,2);
	if (ai.data != NULL)
		{
		ret->timeout=ASN1_INTEGER_get(aip);
		OPENSSL_free(ai.data); ai.data=NULL; ai.length=0;
		}
	else
		ret->timeout=3;
d497 1
a497 2
	if (ret->peer != NULL)
		{
d499 3
a501 3
		ret->peer=NULL;
		}
	M_ASN1_D2I_get_EXP_opt(ret->peer,d2i_X509,3);
d503 11
a513 10
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,4);

	if(os.data != NULL)
	    {
	    if (os.length > SSL_MAX_SID_CTX_LENGTH)
		{
		c.error=SSL_R_BAD_LENGTH;
		goto err;
d515 5
a519 9
	    else
		{
		ret->sid_ctx_length=os.length;
		memcpy(ret->sid_ctx,os.data,os.length);
		}
	    OPENSSL_free(os.data); os.data=NULL; os.length=0;
	    }
	else
	    ret->sid_ctx_length=0;
d521 9
a529 9
	ai.length=0;
	M_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,5);
	if (ai.data != NULL)
		{
		ret->verify_result=ASN1_INTEGER_get(aip);
		OPENSSL_free(ai.data); ai.data=NULL; ai.length=0;
		}
	else
		ret->verify_result=X509_V_OK;
d532 4
a535 5
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,6);
	if (os.data)
		{
d540 2
a541 3
		}
	else
		ret->tlsext_hostname=NULL;
d545 4
a548 5
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,7);
	if (os.data)
		{
d553 2
a554 3
		}
	else
		ret->psk_identity_hint=NULL;
d556 4
a559 5
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,8);
	if (os.data)
		{
d564 2
a565 3
		}
	else
		ret->psk_identity=NULL;
d569 15
a583 16
	ai.length=0;
	M_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,9);
	if (ai.data != NULL)
		{
		ret->tlsext_tick_lifetime_hint=ASN1_INTEGER_get(aip);
		OPENSSL_free(ai.data); ai.data=NULL; ai.length=0;
		}
	else if (ret->tlsext_ticklen && ret->session_id_length)
		ret->tlsext_tick_lifetime_hint = -1;
	else
		ret->tlsext_tick_lifetime_hint=0;
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,10);
	if (os.data)
		{
d588 2
a589 3
		}
	else
		ret->tlsext_tick=NULL;
d592 4
a595 5
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,11);
	if (os.data)
		{
d599 1
a599 1
		}
d603 4
a606 5
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,12);
	if (os.data)
		{
d611 2
a612 3
		}
	else
		ret->srp_username=NULL;
d615 2
a616 2
	M_ASN1_D2I_Finish(a,SSL_SESSION_free,SSL_F_D2I_SSL_SESSION);
	}
@


1.15
log
@openssl-1.0.0e: resolve conflicts
@
text
@d117 3
d136 3
d276 8
d324 4
d372 4
d574 13
d625 15
@


1.14
log
@resolve conflicts, fix local changes
@
text
@d360 1
a360 1
	int version,ssl_version=0,i;
a373 1
	version=(int)ASN1_INTEGER_get(aip);
@


1.13
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d58 26
d97 1
d113 4
d122 1
a122 1
	int v1=0,v2=0,v3=0,v4=0,v5=0;
d129 4
d176 10
d210 1
a210 1
 
a246 6
		/* If we have a ticket set session ID to empty because
		 * it will be bogus. If liftime hint is -1 treat as a special
		 * case because the session is being used as a container
		 */
		if (in->tlsext_ticklen && (in->tlsext_tick_lifetime_hint != -1))
			a.session_id.length=0;
d256 15
d299 4
d304 7
d337 8
d350 4
d358 1
a358 1
	     long length)
d397 1
a397 1
	else if ((ssl_version>>8) == SSL3_VERSION_MAJOR)
d410 2
a411 2
		SSLerr(SSL_F_D2I_SSL_SESSION,SSL_R_UNKNOWN_SSL_VERSION);
		return(NULL);
d418 1
a418 1
	if ((ssl_version>>8) == SSL3_VERSION_MAJOR)
d502 2
a503 2
		ret->sid_ctx_length=os.length;
		SSLerr(SSL_F_D2I_SSL_SESSION,SSL_R_BAD_LENGTH);
d538 18
d566 6
a571 6
		ret->tlsext_tick_lifetime_hint = 0;
 	os.length=0;
 	os.data=NULL;
  	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,10);
 	if (os.data)
 		{
d574 3
a576 16
 		os.data = NULL;
 		os.length = 0;
#if 0
		/* There are two ways to detect a resumed ticket sesion.
		 * One is to set a random session ID and then the server
		 * must return a match in ServerHello. This allows the normal
		 * client session ID matching to work.
		 */ 
		if (ret->session_id_length == 0)
			{
			ret->session_id_length=SSL3_MAX_SSL_SESSION_ID_LENGTH;
			RAND_pseudo_bytes(ret->session_id,
						ret->session_id_length);
			}
#endif
 		}
d580 11
@


1.12
log
@resolve conflicts
@
text
@d356 1
a356 1
	if (ret->master_key_length > SSL_MAX_MASTER_KEY_LENGTH)
@


1.11
log
@resolve conflicts
@
text
@d81 5
d94 4
d190 27
a216 1

d238 8
d269 8
d280 1
a280 1
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char * const *pp,
d296 1
a296 1
	M_ASN1_D2I_get(aip,d2i_ASN1_INTEGER);
d301 1
a301 1
	M_ASN1_D2I_get(aip,d2i_ASN1_INTEGER);
d307 1
a307 1
	M_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);
d340 1
a340 1
	M_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);
d343 1
a343 1
	else /* if (ssl_version == SSL2_VERSION_MAJOR) */
d348 2
a349 2
	if (os.length > sizeof ret->session_id) /* can't happen */
		os.length = sizeof ret->session_id;
d352 1
a352 1
	OPENSSL_assert(os.length <= sizeof ret->session_id);
d355 1
a355 1
	M_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);
d447 51
@


1.10
log
@resolve conflicts
@
text
@d347 1
a347 1
		ret->time=time(NULL);
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d229 1
a229 1
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, unsigned char **pp,
d269 1
a269 1
	else if ((ssl_version>>8) == 3)
d290 1
a290 1
	if ((ssl_version>>8) == SSL3_VERSION)
d292 1
a292 1
	else /* if (ssl_version == SSL2_VERSION) */
@


1.8
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d301 1
d373 2
d376 6
a381 2
	    ret->sid_ctx_length=os.length;
	    memcpy(ret->sid_ctx,os.data,os.length);
@


1.7
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d60 1
a61 1
#include <stdlib.h>
d296 3
a298 1
		os.length=i;
a300 1
	die(os.length <= sizeof ret->session_id);
@


1.6
log
@apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@d60 1
a64 1
#include "ssl_locl.h"
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d299 1
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d75 3
d148 9
d181 1
d187 4
d210 4
d309 19
@


1.4.6.1
log
@Pull in patch from current:
Fix (markus), errata 013:
apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@a277 1
	die(os.length <= sizeof ret->session_id);
@


1.4.4.1
log
@Errata #030 (markus):
Fixes for the "OpenSSL Security Advisory [30 July 2002]"
@
text
@a277 1
	die(os.length <= sizeof ret->session_id);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d95 1
a95 1
	 * is > sizeof(long)+1, the buffer will not be re-Malloc()ed.
d226 1
a226 1
	if (ai.data != NULL) { Free(ai.data); ai.data=NULL; ai.length=0; }
d232 1
a232 1
	if (ai.data != NULL) { Free(ai.data); ai.data=NULL; ai.length=0; }
d294 1
a294 1
	if (os.data != NULL) Free(os.data);
d301 1
a301 1
		Free(ai.data); ai.data=NULL; ai.length=0;
d311 1
a311 1
		Free(ai.data); ai.data=NULL; ai.length=0;
d333 1
a333 1
	    Free(os.data); os.data=NULL; os.length=0;
d343 1
a343 1
		Free(ai.data); ai.data=NULL; ai.length=0;
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d63 1
d77 1
d83 1
a83 1
	int v1=0,v2=0,v3=0,v4=0;
d85 1
a85 1
	unsigned char ibuf3[LSIZE2],ibuf4[LSIZE2];
d94 1
a94 1
	 * that if the ASN1_INTERGER passed to ASN1_INTEGER_set
d161 8
d183 2
d203 2
a204 1

d338 10
a349 1

@


1.1
log
@Initial revision
@
text
@d61 2
a62 2
#include "asn1_mac.h"
#include "objects.h"
d72 1
d78 1
a78 8
/*
 * SSLerr(SSL_F_I2D_SSL_SESSION,SSL_R_CIPHER_CODE_WRONG_LENGTH);
 * SSLerr(SSL_F_D2I_SSL_SESSION,SSL_R_UNSUPPORTED_CIPHER);
 */

int i2d_SSL_SESSION(in,pp)
SSL_SESSION *in;
unsigned char **pp;
d81 1
a81 1
	int v1=0,v2=0,v3=0;
d135 4
d172 1
d189 2
d195 2
a196 4
SSL_SESSION *d2i_SSL_SESSION(a,pp,length)
SSL_SESSION **a;
unsigned char **pp;
long length;
d309 15
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 2
a62 3
#include <openssl/asn1_mac.h>
#include <openssl/objects.h>
#include <openssl/x509.h>
a71 1
	ASN1_OCTET_STRING session_id_context;
a72 3
#ifndef OPENSSL_NO_KRB5
        ASN1_OCTET_STRING krb5_princ;
#endif /* OPENSSL_NO_KRB5 */
a74 1
	ASN1_INTEGER verify_result;
d77 8
a84 1
int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp)
d87 1
a87 1
	int v1=0,v2=0,v3=0,v4=0,v5=0;
d89 1
a89 1
	unsigned char ibuf3[LSIZE2],ibuf4[LSIZE2],ibuf5[LSIZE2];
d98 2
a99 2
	 * that if the ASN1_INTEGER passed to ASN1_INTEGER_set
	 * is > sizeof(long)+1, the buffer will not be re-OPENSSL_malloc()ed.
a140 4
	a.session_id_context.length=in->sid_ctx_length;
	a.session_id_context.type=V_ASN1_OCTET_STRING;
	a.session_id_context.data=in->sid_ctx;

a144 9
#ifndef OPENSSL_NO_KRB5
	if (in->krb5_client_princ_len)
		{
		a.krb5_princ.length=in->krb5_client_princ_len;
		a.krb5_princ.type=V_ASN1_OCTET_STRING;
		a.krb5_princ.data=in->krb5_client_princ;
		}
#endif /* OPENSSL_NO_KRB5 */
 
a160 9
	if (in->verify_result != X509_V_OK)
		{
		a.verify_result.length=LSIZE2;
		a.verify_result.type=V_ASN1_INTEGER;
		a.verify_result.data=ibuf5;
		ASN1_INTEGER_set(&a.verify_result,in->verify_result);
		}


a165 4
#ifndef OPENSSL_NO_KRB5
	if (in->krb5_client_princ_len)
        	M_ASN1_I2D_len(&(a.krb5_princ),	i2d_ASN1_OCTET_STRING);
#endif /* OPENSSL_NO_KRB5 */
a173 3
	M_ASN1_I2D_len_EXP_opt(&a.session_id_context,i2d_ASN1_OCTET_STRING,4,v4);
	if (in->verify_result != X509_V_OK)
		M_ASN1_I2D_len_EXP_opt(&(a.verify_result),i2d_ASN1_INTEGER,5,v5);
a181 4
#ifndef OPENSSL_NO_KRB5
	if (in->krb5_client_princ_len)
        	M_ASN1_I2D_put(&(a.krb5_princ),	i2d_ASN1_OCTET_STRING);
#endif /* OPENSSL_NO_KRB5 */
d190 1
a190 4
	M_ASN1_I2D_put_EXP_opt(&a.session_id_context,i2d_ASN1_OCTET_STRING,4,
			       v4);
	if (in->verify_result != X509_V_OK)
		M_ASN1_I2D_put_EXP_opt(&a.verify_result,i2d_ASN1_INTEGER,5,v5);
d194 4
a197 2
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, unsigned char **pp,
	     long length)
d214 1
a214 1
	if (ai.data != NULL) { OPENSSL_free(ai.data); ai.data=NULL; ai.length=0; }
d220 1
a220 1
	if (ai.data != NULL) { OPENSSL_free(ai.data); ai.data=NULL; ai.length=0; }
a275 19

#ifndef OPENSSL_NO_KRB5
	os.length=0;
	M_ASN1_D2I_get_opt(osp,d2i_ASN1_OCTET_STRING,V_ASN1_OCTET_STRING);
	if (os.data)
		{
        	if (os.length > SSL_MAX_KRB5_PRINCIPAL_LENGTH)
            		ret->krb5_client_princ_len=0;
		else
			ret->krb5_client_princ_len=os.length;
		memcpy(ret->krb5_client_princ,os.data,ret->krb5_client_princ_len);
		OPENSSL_free(os.data);
		os.data = NULL;
		os.length = 0;
		}
	else
		ret->krb5_client_princ_len=0;
#endif /* OPENSSL_NO_KRB5 */

d282 1
a282 1
	if (os.data != NULL) OPENSSL_free(os.data);
d289 1
a289 1
		OPENSSL_free(ai.data); ai.data=NULL; ai.length=0;
d299 1
a299 1
		OPENSSL_free(ai.data); ai.data=NULL; ai.length=0;
a310 25
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,4);

	if(os.data != NULL)
	    {
	    if (os.length > SSL_MAX_SID_CTX_LENGTH)
		SSLerr(SSL_F_D2I_SSL_SESSION,SSL_R_BAD_LENGTH);
	    ret->sid_ctx_length=os.length;
	    memcpy(ret->sid_ctx,os.data,os.length);
	    OPENSSL_free(os.data); os.data=NULL; os.length=0;
	    }
	else
	    ret->sid_ctx_length=0;

	ai.length=0;
	M_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,5);
	if (ai.data != NULL)
		{
		ret->verify_result=ASN1_INTEGER_get(aip);
		OPENSSL_free(ai.data); ai.data=NULL; ai.length=0;
		}
	else
		ret->verify_result=X509_V_OK;

d313 1
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a60 1
#include "ssl_locl.h"
d64 1
a64 1
#include "cryptlib.h"
a298 1
	die(os.length <= sizeof ret->session_id);
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d297 1
a297 3
		os.length = i;
	if (os.length > sizeof ret->session_id) /* can't happen */
		os.length = sizeof ret->session_id;
d300 1
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@a301 1
	OPENSSL_assert(os.length <= sizeof ret->session_id);
a372 2
		{
		ret->sid_ctx_length=os.length;
d374 2
a375 6
		}
	    else
		{
		ret->sid_ctx_length=os.length;
		memcpy(ret->sid_ctx,os.data,os.length);
		}
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d65 1
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d229 1
a229 1
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char * const *pp,
d269 1
a269 1
	else if ((ssl_version>>8) == SSL3_VERSION_MAJOR)
d290 1
a290 1
	if ((ssl_version>>8) == SSL3_VERSION_MAJOR)
d292 1
a292 1
	else /* if (ssl_version == SSL2_VERSION_MAJOR) */
@


1.1.1.8
log
@import of openssl-0.9.7j
@
text
@d347 1
a347 1
		ret->time=(unsigned long)time(NULL);
@


1.1.1.9
log
@import of OpenSSL 0.9.8h
@
text
@a80 5
#ifndef OPENSSL_NO_TLSEXT
	ASN1_OCTET_STRING tlsext_hostname;
	ASN1_INTEGER tlsext_tick_lifetime;
	ASN1_OCTET_STRING tlsext_tick;
#endif /* OPENSSL_NO_TLSEXT */
a88 4
#ifndef OPENSSL_NO_TLSEXT
	int v6=0,v9=0,v10=0;
	unsigned char ibuf6[LSIZE2];
#endif
d181 1
a181 27
#ifndef OPENSSL_NO_TLSEXT
	if (in->tlsext_hostname)
                {
                a.tlsext_hostname.length=strlen(in->tlsext_hostname);
                a.tlsext_hostname.type=V_ASN1_OCTET_STRING;
                a.tlsext_hostname.data=(unsigned char *)in->tlsext_hostname;
                }
	if (in->tlsext_tick)
                {
                a.tlsext_tick.length= in->tlsext_ticklen;
                a.tlsext_tick.type=V_ASN1_OCTET_STRING;
                a.tlsext_tick.data=(unsigned char *)in->tlsext_tick;
		/* If we have a ticket set session ID to empty because
		 * it will be bogus. If liftime hint is -1 treat as a special
		 * case because the session is being used as a container
		 */
		if (in->tlsext_ticklen && (in->tlsext_tick_lifetime_hint != -1))
			a.session_id.length=0;
                }
	if (in->tlsext_tick_lifetime_hint > 0)
		{
		a.tlsext_tick_lifetime.length=LSIZE2;
		a.tlsext_tick_lifetime.type=V_ASN1_INTEGER;
		a.tlsext_tick_lifetime.data=ibuf6;
		ASN1_INTEGER_set(&a.tlsext_tick_lifetime,in->tlsext_tick_lifetime_hint);
		}
#endif /* OPENSSL_NO_TLSEXT */
a202 8
#ifndef OPENSSL_NO_TLSEXT
	if (in->tlsext_tick_lifetime_hint > 0)
      	 	M_ASN1_I2D_len_EXP_opt(&a.tlsext_tick_lifetime, i2d_ASN1_INTEGER,9,v9);
	if (in->tlsext_tick)
        	M_ASN1_I2D_len_EXP_opt(&(a.tlsext_tick), i2d_ASN1_OCTET_STRING,10,v10);
	if (in->tlsext_hostname)
        	M_ASN1_I2D_len_EXP_opt(&(a.tlsext_hostname), i2d_ASN1_OCTET_STRING,6,v6);
#endif /* OPENSSL_NO_TLSEXT */
a225 8
#ifndef OPENSSL_NO_TLSEXT
	if (in->tlsext_hostname)
        	M_ASN1_I2D_put_EXP_opt(&(a.tlsext_hostname), i2d_ASN1_OCTET_STRING,6,v6);
	if (in->tlsext_tick_lifetime_hint > 0)
      	 	M_ASN1_I2D_put_EXP_opt(&a.tlsext_tick_lifetime, i2d_ASN1_INTEGER,9,v9);
	if (in->tlsext_tick)
        	M_ASN1_I2D_put_EXP_opt(&(a.tlsext_tick), i2d_ASN1_OCTET_STRING,10,v10);
#endif /* OPENSSL_NO_TLSEXT */
d229 1
a229 1
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,
d245 1
a245 1
	M_ASN1_D2I_get_x(ASN1_INTEGER,aip,d2i_ASN1_INTEGER);
d250 1
a250 1
	M_ASN1_D2I_get_x(ASN1_INTEGER,aip,d2i_ASN1_INTEGER);
d256 1
a256 1
	M_ASN1_D2I_get_x(ASN1_OCTET_STRING,osp,d2i_ASN1_OCTET_STRING);
d289 1
a289 1
	M_ASN1_D2I_get_x(ASN1_OCTET_STRING,osp,d2i_ASN1_OCTET_STRING);
d292 1
a292 1
	else /* if (ssl_version>>8 == SSL2_VERSION_MAJOR) */
d297 2
a298 2
	if (os.length > (int)sizeof(ret->session_id)) /* can't happen */
		os.length = sizeof(ret->session_id);
d301 1
a301 1
	OPENSSL_assert(os.length <= (int)sizeof(ret->session_id));
d304 1
a304 1
	M_ASN1_D2I_get_x(ASN1_OCTET_STRING,osp,d2i_ASN1_OCTET_STRING);
a395 51

#ifndef OPENSSL_NO_TLSEXT
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,6);
	if (os.data)
		{
		ret->tlsext_hostname = BUF_strndup((char *)os.data, os.length);
		OPENSSL_free(os.data);
		os.data = NULL;
		os.length = 0;
		}
	else
		ret->tlsext_hostname=NULL;
	ai.length=0;
	M_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,9);
	if (ai.data != NULL)
		{
		ret->tlsext_tick_lifetime_hint=ASN1_INTEGER_get(aip);
		OPENSSL_free(ai.data); ai.data=NULL; ai.length=0;
		}
	else if (ret->tlsext_ticklen && ret->session_id_length)
		ret->tlsext_tick_lifetime_hint = -1;
	else
		ret->tlsext_tick_lifetime_hint = 0;
 	os.length=0;
 	os.data=NULL;
  	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,10);
 	if (os.data)
 		{
		ret->tlsext_tick = os.data;
		ret->tlsext_ticklen = os.length;
 		os.data = NULL;
 		os.length = 0;
#if 0
		/* There are two ways to detect a resumed ticket sesion.
		 * One is to set a random session ID and then the server
		 * must return a match in ServerHello. This allows the normal
		 * client session ID matching to work.
		 */ 
		if (ret->session_id_length == 0)
			{
			ret->session_id_length=SSL3_MAX_SSL_SESSION_ID_LENGTH;
			RAND_pseudo_bytes(ret->session_id,
						ret->session_id_length);
			}
#endif
 		}
	else
		ret->tlsext_tick=NULL;
#endif /* OPENSSL_NO_TLSEXT */
@


1.1.1.10
log
@import openssl-0.9.8j
@
text
@d356 1
a356 1
	if (os.length > SSL_MAX_MASTER_KEY_LENGTH)
@


1.1.1.11
log
@import OpenSSL-1.0.0a
@
text
@a57 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
a70 1
	ASN1_OCTET_STRING comp_id;
a85 4
#ifndef OPENSSL_NO_PSK
	ASN1_OCTET_STRING psk_identity_hint;
	ASN1_OCTET_STRING psk_identity;
#endif /* OPENSSL_NO_PSK */
d91 1
a91 1
	int v1=0,v2=0,v3=0,v4=0,v5=0,v7=0,v8=0;
a97 4
#ifndef OPENSSL_NO_COMP
	unsigned char cbuf;
	int v11=0;
#endif
a140 10
#ifndef OPENSSL_NO_COMP
	if (in->compress_meth)
		{
		cbuf = (unsigned char)in->compress_meth;
		a.comp_id.length = 1;
		a.comp_id.type = V_ASN1_OCTET_STRING;
		a.comp_id.data = &cbuf;
		}
#endif

d165 1
a165 1

d202 6
a216 15
#ifndef OPENSSL_NO_PSK
	if (in->psk_identity_hint)
		{
		a.psk_identity_hint.length=strlen(in->psk_identity_hint);
		a.psk_identity_hint.type=V_ASN1_OCTET_STRING;
		a.psk_identity_hint.data=(unsigned char *)(in->psk_identity_hint);
		}
	if (in->psk_identity)
		{
		a.psk_identity.length=strlen(in->psk_identity);
		a.psk_identity.type=V_ASN1_OCTET_STRING;
		a.psk_identity.data=(unsigned char *)(in->psk_identity);
		}
#endif /* OPENSSL_NO_PSK */

a244 4
#ifndef OPENSSL_NO_COMP
	if (in->compress_meth)
        	M_ASN1_I2D_len_EXP_opt(&(a.comp_id), i2d_ASN1_OCTET_STRING,11,v11);
#endif
a245 7
#ifndef OPENSSL_NO_PSK
	if (in->psk_identity_hint)
        	M_ASN1_I2D_len_EXP_opt(&(a.psk_identity_hint), i2d_ASN1_OCTET_STRING,7,v7);
	if (in->psk_identity)
        	M_ASN1_I2D_len_EXP_opt(&(a.psk_identity), i2d_ASN1_OCTET_STRING,8,v8);
#endif /* OPENSSL_NO_PSK */

a271 8
#endif /* OPENSSL_NO_TLSEXT */
#ifndef OPENSSL_NO_PSK
	if (in->psk_identity_hint)
		M_ASN1_I2D_put_EXP_opt(&(a.psk_identity_hint), i2d_ASN1_OCTET_STRING,7,v7);
	if (in->psk_identity)
		M_ASN1_I2D_put_EXP_opt(&(a.psk_identity), i2d_ASN1_OCTET_STRING,8,v8);
#endif /* OPENSSL_NO_PSK */
#ifndef OPENSSL_NO_TLSEXT
a276 4
#ifndef OPENSSL_NO_COMP
	if (in->compress_meth)
        	M_ASN1_I2D_put_EXP_opt(&(a.comp_id), i2d_ASN1_OCTET_STRING,11,v11);
#endif
d281 1
a281 1
			     long length)
d320 1
a320 1
	else if ((ssl_version>>8) >= SSL3_VERSION_MAJOR)
d333 2
a334 2
		c.error=SSL_R_UNKNOWN_SSL_VERSION;
		goto err;
d341 1
a341 1
	if ((ssl_version>>8) >= SSL3_VERSION_MAJOR)
d425 2
a426 2
		c.error=SSL_R_BAD_LENGTH;
		goto err;
a460 18
#endif /* OPENSSL_NO_TLSEXT */

#ifndef OPENSSL_NO_PSK
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,7);
	if (os.data)
		{
		ret->psk_identity_hint = BUF_strndup((char *)os.data, os.length);
		OPENSSL_free(os.data);
		os.data = NULL;
		os.length = 0;
		}
	else
		ret->psk_identity_hint=NULL;
#endif /* OPENSSL_NO_PSK */

#ifndef OPENSSL_NO_TLSEXT
d471 6
a476 6
		ret->tlsext_tick_lifetime_hint=0;
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,10);
	if (os.data)
		{
d479 16
a494 3
		os.data = NULL;
		os.length = 0;
		}
a497 11
#ifndef OPENSSL_NO_COMP
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,11);
	if (os.data)
		{
		ret->compress_meth = os.data[0];
		OPENSSL_free(os.data);
		os.data = NULL;
		}
#endif
@


1.1.1.12
log
@import OpenSSL 1.0.0e
@
text
@d360 1
a360 1
	int ssl_version=0,i;
d374 1
@


1.1.1.13
log
@import OpenSSL-1.0.1c
@
text
@a116 3
#ifndef OPENSSL_NO_SRP
	ASN1_OCTET_STRING srp_username;
#endif /* OPENSSL_NO_SRP */
a132 3
#ifndef OPENSSL_NO_SRP
	int v12=0;
#endif
a269 8
#ifndef OPENSSL_NO_SRP
	if (in->srp_username)
		{
		a.srp_username.length=strlen(in->srp_username);
		a.srp_username.type=V_ASN1_OCTET_STRING;
		a.srp_username.data=(unsigned char *)(in->srp_username);
		}
#endif /* OPENSSL_NO_SRP */
a309 4
#ifndef OPENSSL_NO_SRP
	if (in->srp_username)
        	M_ASN1_I2D_len_EXP_opt(&(a.srp_username), i2d_ASN1_OCTET_STRING,12,v12);
#endif /* OPENSSL_NO_SRP */
a353 4
#ifndef OPENSSL_NO_SRP
	if (in->srp_username)
		M_ASN1_I2D_put_EXP_opt(&(a.srp_username), i2d_ASN1_OCTET_STRING,12,v12);
#endif /* OPENSSL_NO_SRP */
a551 13

	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,8);
	if (os.data)
		{
		ret->psk_identity = BUF_strndup((char *)os.data, os.length);
		OPENSSL_free(os.data);
		os.data = NULL;
		os.length = 0;
		}
	else
		ret->psk_identity=NULL;
a589 15

#ifndef OPENSSL_NO_SRP
	os.length=0;
	os.data=NULL;
	M_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,12);
	if (os.data)
		{
		ret->srp_username = BUF_strndup((char *)os.data, os.length);
		OPENSSL_free(os.data);
		os.data = NULL;
		os.length = 0;
		}
	else
		ret->srp_username=NULL;
#endif /* OPENSSL_NO_SRP */
@


