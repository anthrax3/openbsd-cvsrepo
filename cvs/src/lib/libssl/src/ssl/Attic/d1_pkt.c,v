head	1.49;
access;
symbols
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.40.0.4
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.34.0.2
	OPENBSD_5_6_BASE:1.34
	butholakala:1.9
	openssl_1_0_1_g:1.1.1.7
	OPENSSL:1.1.1
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	openssl_1_0_1_c:1.1.1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	openssl_1_0_0_f:1.1.1.5
	openssl_1_0_0_e:1.1.1.4
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2016.09.03.11.33.41;	author beck;	state dead;
branches;
next	1.48;
commitid	HnbXxsegngek41U2;

1.48
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.47;
commitid	pa8oXRlJthT375Ws;

1.47
date	2015.09.10.17.57.50;	author jsing;	state Exp;
branches;
next	1.46;
commitid	T35skZJCouRaXVVY;

1.46
date	2015.07.19.01.07.40;	author doug;	state Exp;
branches;
next	1.45;
commitid	qMQHG44UAEhn3aIw;

1.45
date	2015.07.18.23.00.23;	author doug;	state Exp;
branches;
next	1.44;
commitid	83F4EYjF8aqo7ueq;

1.44
date	2015.07.18.22.36.55;	author doug;	state Exp;
branches;
next	1.43;
commitid	VXSpy6Hcj0SNxo5L;

1.43
date	2015.07.18.22.28.53;	author doug;	state Exp;
branches;
next	1.42;
commitid	b07eOY7bhe8qRG7a;

1.42
date	2015.06.17.07.29.33;	author doug;	state Exp;
branches;
next	1.41;
commitid	cvhmfDoLDdIR1Efl;

1.41
date	2015.06.13.08.38.10;	author doug;	state Exp;
branches;
next	1.40;
commitid	A7PrDVdy9HjfQlSR;

1.40
date	2015.02.09.10.53.28;	author jsing;	state Exp;
branches;
next	1.39;
commitid	91DZ31h3Xbk1xWbU;

1.39
date	2015.01.21.00.15.50;	author doug;	state Exp;
branches;
next	1.38;
commitid	RNgbZkkURubmGxJF;

1.38
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.37;
commitid	XNZawfRSWvnVv1VS;

1.37
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.36;
commitid	M3pvHgIFoWUHNqJn;

1.36
date	2014.10.22.15.29.31;	author jsing;	state Exp;
branches;
next	1.35;
commitid	s9AwbvMDSXlI656y;

1.35
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.34;
commitid	cGE1JG2i0h4NcVDi;

1.34
date	2014.08.07.20.02.23;	author miod;	state Exp;
branches;
next	1.33;
commitid	DMh9IXTC6aDWVuh5;

1.33
date	2014.08.07.19.46.31;	author miod;	state Exp;
branches;
next	1.32;
commitid	vayOLqnrIMw5dnz8;

1.32
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.31;
commitid	lsH7iukeZYSZBx6F;

1.31
date	2014.07.09.16.06.14;	author miod;	state Exp;
branches;
next	1.30;
commitid	WBUBPtdvi23w6jGY;

1.30
date	2014.06.19.21.29.51;	author tedu;	state Exp;
branches;
next	1.29;
commitid	CIpPjhmVWPbqgxVA;

1.29
date	2014.06.15.15.29.25;	author jsing;	state Exp;
branches;
next	1.28;
commitid	G9UpwpcoMkFCFqBD;

1.28
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	mJUVYpkFBZ0Zv2bG;

1.27
date	2014.06.11.15.17.19;	author jsing;	state Exp;
branches;
next	1.26;
commitid	yLY4i8WW5UTUfvru;

1.26
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2014.05.30.05.27.32;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.05.28.13.03.24;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2014.05.27.18.51.24;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2014.05.26.17.06.21;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2014.05.25.16.23.10;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.22.17.37.06;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.18.16.08.37;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2014.05.15.19.39.46;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.23.18.40.39;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.17.23.35.40;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.14.18.53.14;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.14.14.16.33;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2013.02.14.15.11.43;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.14.06;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.11.03.02.32.19;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.01.05.22.59.08;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: d1_pkt.c,v 1.48 2015/09/11 18:08:21 jsing Exp $ */
/*
 * DTLS implementation written by Nagendra Modadugu
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.
 */
/* ====================================================================
 * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <machine/endian.h>

#include <errno.h>
#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/buffer.h>
#include <openssl/evp.h>

#include "pqueue.h"
#include "bytestring.h"

/* mod 128 saturating subtract of two 64-bit values in big-endian order */
static int
satsub64be(const unsigned char *v1, const unsigned char *v2)
{
	int ret, sat, brw, i;

	if (sizeof(long) == 8)
		do {
			long l;

			if (BYTE_ORDER == LITTLE_ENDIAN)
				break;
			/* not reached on little-endians */
			/* following test is redundant, because input is
			 * always aligned, but I take no chances... */
			if (((size_t)v1 | (size_t)v2) & 0x7)
				break;

			l  = *((long *)v1);
			l -= *((long *)v2);
			if (l > 128)
				return 128;
			else if (l<-128)
				return -128;
			else
				return (int)l;
		} while (0);

	ret = (int)v1[7] - (int)v2[7];
	sat = 0;
	brw = ret >> 8;	/* brw is either 0 or -1 */
	if (ret & 0x80) {
		for (i = 6; i >= 0; i--) {
			brw += (int)v1[i]-(int)v2[i];
			sat |= ~brw;
			brw >>= 8;
		}
	} else {
		for (i = 6; i >= 0; i--) {
			brw += (int)v1[i]-(int)v2[i];
			sat |= brw;
			brw >>= 8;
		}
	}
	brw <<= 8;	/* brw is either 0 or -256 */

	if (sat & 0xff)
		return brw | 0x80;
	else
		return brw + (ret & 0xFF);
}

static int have_handshake_fragment(SSL *s, int type, unsigned char *buf,
    int len, int peek);
static int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap);
static void dtls1_record_bitmap_update(SSL *s, DTLS1_BITMAP *bitmap);
static DTLS1_BITMAP *dtls1_get_bitmap(SSL *s, SSL3_RECORD *rr,
    unsigned int *is_next_epoch);
static int dtls1_buffer_record(SSL *s, record_pqueue *q,
    unsigned char *priority);
static int dtls1_process_record(SSL *s);

/* copy buffered record into SSL structure */
static int
dtls1_copy_record(SSL *s, pitem *item)
{
	DTLS1_RECORD_DATA *rdata;

	rdata = (DTLS1_RECORD_DATA *)item->data;

	free(s->s3->rbuf.buf);

	s->packet = rdata->packet;
	s->packet_length = rdata->packet_length;
	memcpy(&(s->s3->rbuf), &(rdata->rbuf), sizeof(SSL3_BUFFER));
	memcpy(&(s->s3->rrec), &(rdata->rrec), sizeof(SSL3_RECORD));

	/* Set proper sequence number for mac calculation */
	memcpy(&(s->s3->read_sequence[2]), &(rdata->packet[5]), 6);

	return (1);
}


static int
dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)
{
	DTLS1_RECORD_DATA *rdata;
	pitem *item;

	/* Limit the size of the queue to prevent DOS attacks */
	if (pqueue_size(queue->q) >= 100)
		return 0;

	rdata = malloc(sizeof(DTLS1_RECORD_DATA));
	item = pitem_new(priority, rdata);
	if (rdata == NULL || item == NULL)
		goto init_err;

	rdata->packet = s->packet;
	rdata->packet_length = s->packet_length;
	memcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));
	memcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));

	item->data = rdata;


	s->packet = NULL;
	s->packet_length = 0;
	memset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));
	memset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));

	if (!ssl3_setup_buffers(s))
		goto err;

	/* insert should not fail, since duplicates are dropped */
	if (pqueue_insert(queue->q, item) == NULL)
		goto err;

	return (1);

err:
	free(rdata->rbuf.buf);

init_err:
	SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);
	free(rdata);
	pitem_free(item);
	return (-1);
}


static int
dtls1_retrieve_buffered_record(SSL *s, record_pqueue *queue)
{
	pitem *item;

	item = pqueue_pop(queue->q);
	if (item) {
		dtls1_copy_record(s, item);

		free(item->data);
		pitem_free(item);

		return (1);
	}

	return (0);
}


/* retrieve a buffered record that belongs to the new epoch, i.e., not processed
 * yet */
#define dtls1_get_unprocessed_record(s) \
                   dtls1_retrieve_buffered_record((s), \
                   &((s)->d1->unprocessed_rcds))

/* retrieve a buffered record that belongs to the current epoch, ie, processed */
#define dtls1_get_processed_record(s) \
                   dtls1_retrieve_buffered_record((s), \
                   &((s)->d1->processed_rcds))

static int
dtls1_process_buffered_records(SSL *s)
{
	pitem *item;

	item = pqueue_peek(s->d1->unprocessed_rcds.q);
	if (item) {
		/* Check if epoch is current. */
		if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
			return (1);
		/* Nothing to do. */

		/* Process all the records. */
		while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
			dtls1_get_unprocessed_record(s);
			if (! dtls1_process_record(s))
				return (0);
			if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
			    s->s3->rrec.seq_num) < 0)
				return (-1);
		}
	}

    /* sync epoch numbers once all the unprocessed records
     * have been processed */
	s->d1->processed_rcds.epoch = s->d1->r_epoch;
	s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;

	return (1);
}

static int
dtls1_process_record(SSL *s)
{
	int i, al;
	int enc_err;
	SSL_SESSION *sess;
	SSL3_RECORD *rr;
	unsigned int mac_size, orig_len;
	unsigned char md[EVP_MAX_MD_SIZE];

	rr = &(s->s3->rrec);
	sess = s->session;

	/* At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,
	 * and we have that many bytes in s->packet
	 */
	rr->input = &(s->packet[DTLS1_RT_HEADER_LENGTH]);

	/* ok, we can now read from 's->packet' data into 'rr'
	 * rr->input points at rr->length bytes, which
	 * need to be copied into rr->data by either
	 * the decryption or by the decompression
	 * When the data is 'copied' into the rr->data buffer,
	 * rr->input will be pointed at the new buffer */

	/* We now have - encrypted [ MAC [ compressed [ plain ] ] ]
	 * rr->length bytes of encrypted compressed stuff. */

	/* check is not needed I believe */
	if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {
		al = SSL_AD_RECORD_OVERFLOW;
		SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
		goto f_err;
	}

	/* decrypt in place in 'rr->input' */
	rr->data = rr->input;

	enc_err = s->method->ssl3_enc->enc(s, 0);
	/* enc_err is:
	 *    0: (in non-constant time) if the record is publically invalid.
	 *    1: if the padding is valid
	 *    -1: if the padding is invalid */
	if (enc_err == 0) {
		/* For DTLS we simply ignore bad packets. */
		rr->length = 0;
		s->packet_length = 0;
		goto err;
	}


	/* r->length is now the compressed data plus mac */
	if ((sess != NULL) && (s->enc_read_ctx != NULL) &&
	    (EVP_MD_CTX_md(s->read_hash) != NULL)) {
		/* s->read_hash != NULL => mac_size != -1 */
		unsigned char *mac = NULL;
		unsigned char mac_tmp[EVP_MAX_MD_SIZE];
		mac_size = EVP_MD_CTX_size(s->read_hash);
		OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);

		/* kludge: *_cbc_remove_padding passes padding length in rr->type */
		orig_len = rr->length + ((unsigned int)rr->type >> 8);

		/* orig_len is the length of the record before any padding was
		 * removed. This is public information, as is the MAC in use,
		 * therefore we can safely process the record in a different
		 * amount of time if it's too short to possibly contain a MAC.
		 */
		if (orig_len < mac_size ||
			/* CBC records must have a padding length byte too. */
		    (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
		    orig_len < mac_size + 1)) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
		}

		if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {
			/* We update the length so that the TLS header bytes
			 * can be constructed correctly but we need to extract
			 * the MAC in constant time from within the record,
			 * without leaking the contents of the padding bytes.
			 * */
			mac = mac_tmp;
			ssl3_cbc_copy_mac(mac_tmp, rr, mac_size, orig_len);
			rr->length -= mac_size;
		} else {
			/* In this case there's no padding, so |orig_len|
			 * equals |rec->length| and we checked that there's
			 * enough bytes for |mac_size| above. */
			rr->length -= mac_size;
			mac = &rr->data[rr->length];
		}

		i = s->method->ssl3_enc->mac(s, md, 0 /* not send */);
		if (i < 0 || mac == NULL || timingsafe_memcmp(md, mac, (size_t)mac_size) != 0)
			enc_err = -1;
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)
			enc_err = -1;
	}

	if (enc_err < 0) {
		/* decryption failed, silently discard message */
		rr->length = 0;
		s->packet_length = 0;
		goto err;
	}

	if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH) {
		al = SSL_AD_RECORD_OVERFLOW;
		SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);
		goto f_err;
	}

	rr->off = 0;
	/* So at this point the following is true
	 * ssl->s3->rrec.type 	is the type of record
	 * ssl->s3->rrec.length	== number of bytes in record
	 * ssl->s3->rrec.off	== offset to first valid byte
	 * ssl->s3->rrec.data	== where to take bytes from, increment
	 *			   after use :-).
	 */

	/* we have pulled in a full packet so zero things */
	s->packet_length = 0;
	return (1);

f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	return (0);
}


/* Call this to get a new input record.
 * It will return <= 0 if more data is needed, normally due to an error
 * or non-blocking IO.
 * When it finishes, one packet has been decoded and can be found in
 * ssl->s3->rrec.type    - is the type of record
 * ssl->s3->rrec.data, 	 - data
 * ssl->s3->rrec.length, - number of bytes
 */
/* used only by dtls1_read_bytes */
int
dtls1_get_record(SSL *s)
{
	int i, n;
	SSL3_RECORD *rr;
	unsigned char *p = NULL;
	DTLS1_BITMAP *bitmap;
	unsigned int is_next_epoch;

	rr = &(s->s3->rrec);

	/* The epoch may have changed.  If so, process all the
	 * pending records.  This is a non-blocking operation. */
	if (dtls1_process_buffered_records(s) < 0)
		return (-1);

	/* if we're renegotiating, then there may be buffered records */
	if (dtls1_get_processed_record(s))
		return 1;

	/* get something from the wire */
	if (0) {
again:
		/* dump this record on all retries */
		rr->length = 0;
		s->packet_length = 0;
	}

	/* check if we have the header */
	if ((s->rstate != SSL_ST_READ_BODY) ||
	    (s->packet_length < DTLS1_RT_HEADER_LENGTH)) {
		CBS header, seq_no;
		uint16_t epoch, len, ssl_version;
		uint8_t type;

		n = ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);
		/* read timeout is handled by dtls1_read_bytes */
		if (n <= 0)
			return(n); /* error or non-blocking */

		/* this packet contained a partial record, dump it */
		if (s->packet_length != DTLS1_RT_HEADER_LENGTH)
			goto again;

		s->rstate = SSL_ST_READ_BODY;

		CBS_init(&header, s->packet, s->packet_length);

		/* Pull apart the header into the DTLS1_RECORD */
		if (!CBS_get_u8(&header, &type))
			goto again;
		if (!CBS_get_u16(&header, &ssl_version))
			goto again;

		/* sequence number is 64 bits, with top 2 bytes = epoch */
		if (!CBS_get_u16(&header, &epoch) ||
		    !CBS_get_bytes(&header, &seq_no, 6))
			goto again;

		if (!CBS_write_bytes(&seq_no, &(s->s3->read_sequence[2]),
		    sizeof(s->s3->read_sequence) - 2, NULL))
			goto again;
		if (!CBS_get_u16(&header, &len))
			goto again;

		rr->type = type;
		rr->epoch = epoch;
		rr->length = len;

		/* unexpected version, silently discard */
		if (!s->first_packet && ssl_version != s->version)
			goto again;

		/* wrong version, silently discard record */
		if ((ssl_version & 0xff00) != (s->version & 0xff00))
			goto again;

		/* record too long, silently discard it */
		if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)
			goto again;

		/* now s->rstate == SSL_ST_READ_BODY */
		p = (unsigned char *)CBS_data(&header);
	}

	/* s->rstate == SSL_ST_READ_BODY, get and decode the data */

	if (rr->length > s->packet_length - DTLS1_RT_HEADER_LENGTH) {
		/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */
		i = rr->length;
		n = ssl3_read_n(s, i, i, 1);
		if (n <= 0)
			return(n); /* error or non-blocking io */

		/* this packet contained a partial record, dump it */
		if (n != i)
			goto again;

		/* now n == rr->length,
		 * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */
	}
	s->rstate = SSL_ST_READ_HEADER; /* set state for later operations */

	/* match epochs.  NULL means the packet is dropped on the floor */
	bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);
	if (bitmap == NULL)
		goto again;

	/*
	 * Check whether this is a repeat, or aged record.
	 * Don't check if we're listening and this message is
	 * a ClientHello. They can look as if they're replayed,
	 * since they arrive from different connections and
	 * would be dropped unnecessarily.
	 */
	if (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&
	    p != NULL && *p == SSL3_MT_CLIENT_HELLO) &&
	    !dtls1_record_replay_check(s, bitmap))
		goto again;

	/* just read a 0 length packet */
	if (rr->length == 0)
		goto again;

	/* If this record is from the next epoch (either HM or ALERT),
	 * and a handshake is currently in progress, buffer it since it
	 * cannot be processed at this time. However, do not buffer
	 * anything while listening.
	 */
	if (is_next_epoch) {
		if ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen) {
			if (dtls1_buffer_record(s, &(s->d1->unprocessed_rcds),
			    rr->seq_num) < 0)
				return (-1);
			/* Mark receipt of record. */
			dtls1_record_bitmap_update(s, bitmap);
		}
		goto again;
	}

	if (!dtls1_process_record(s))
		goto again;

	/* Mark receipt of record. */
	dtls1_record_bitmap_update(s, bitmap);

	return (1);
}

/* Return up to 'len' payload bytes received in 'type' records.
 * 'type' is one of the following:
 *
 *   -  SSL3_RT_HANDSHAKE (when ssl3_get_message calls us)
 *   -  SSL3_RT_APPLICATION_DATA (when ssl3_read calls us)
 *   -  0 (during a shutdown, no data has to be returned)
 *
 * If we don't have stored data to work from, read a SSL/TLS record first
 * (possibly multiple records if we still don't have anything to return).
 *
 * This function must handle any surprises the peer may have for us, such as
 * Alert records (e.g. close_notify), ChangeCipherSpec records (not really
 * a surprise, but handled as if it were), or renegotiation requests.
 * Also if record payloads contain fragments too small to process, we store
 * them until there is enough for the respective protocol (the record protocol
 * may use arbitrary fragmentation and even interleaving):
 *     Change cipher spec protocol
 *             just 1 byte needed, no need for keeping anything stored
 *     Alert protocol
 *             2 bytes needed (AlertLevel, AlertDescription)
 *     Handshake protocol
 *             4 bytes needed (HandshakeType, uint24 length) -- we just have
 *             to detect unexpected Client Hello and Hello Request messages
 *             here, anything else is handled by higher layers
 *     Application data protocol
 *             none of our business
 */
int
dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
{
	int al, i, j, ret;
	unsigned int n;
	SSL3_RECORD *rr;
	void (*cb)(const SSL *ssl, int type2, int val) = NULL;

	if (s->s3->rbuf.buf == NULL) /* Not initialized yet */
		if (!ssl3_setup_buffers(s))
			return (-1);

	if ((type &&
	     type != SSL3_RT_APPLICATION_DATA && type != SSL3_RT_HANDSHAKE) ||
	    (peek && (type != SSL3_RT_APPLICATION_DATA))) {
		SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
		return -1;
	}

	/* check whether there's a handshake message (client hello?) waiting */
	if ((ret = have_handshake_fragment(s, type, buf, len, peek)))
		return ret;

	/* Now s->d1->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE. */

	if (!s->in_handshake && SSL_in_init(s))
	{
		/* type == SSL3_RT_APPLICATION_DATA */
		i = s->handshake_func(s);
		if (i < 0)
			return (i);
		if (i == 0) {
			SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
			return (-1);
		}
	}

start:
	s->rwstate = SSL_NOTHING;

	/* s->s3->rrec.type	    - is the type of record
	 * s->s3->rrec.data,    - data
	 * s->s3->rrec.off,     - offset into 'data' for next read
	 * s->s3->rrec.length,  - number of bytes. */
	rr = &(s->s3->rrec);

	/* We are not handshaking and have no data yet,
	 * so process data buffered during the last handshake
	 * in advance, if any.
	 */
	if (s->state == SSL_ST_OK && rr->length == 0) {
		pitem *item;
		item = pqueue_pop(s->d1->buffered_app_data.q);
		if (item) {

			dtls1_copy_record(s, item);

			free(item->data);
			pitem_free(item);
		}
	}

	/* Check for timeout */
	if (dtls1_handle_timeout(s) > 0)
		goto start;

	/* get new packet if necessary */
	if ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY)) {
		ret = dtls1_get_record(s);
		if (ret <= 0) {
			ret = dtls1_read_failed(s, ret);
			/* anything other than a timeout is an error */
			if (ret <= 0)
				return (ret);
			else
				goto start;
		}
	}

	if (s->d1->listen && rr->type != SSL3_RT_HANDSHAKE) {
		rr->length = 0;
		goto start;
	}

	/* we now have a packet which can be read and processed */

	if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,
	                               * reset by ssl3_get_finished */
	    && (rr->type != SSL3_RT_HANDSHAKE)) {
		/* We now have application data between CCS and Finished.
		 * Most likely the packets were reordered on their way, so
		 * buffer the application data for later processing rather
		 * than dropping the connection.
		 */
		if (dtls1_buffer_record(s, &(s->d1->buffered_app_data),
		    rr->seq_num) < 0) {
			SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
			return (-1);
		}
		rr->length = 0;
		goto start;
	}

	/* If the other end has shut down, throw anything we read away
	 * (even in 'peek' mode) */
	if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {
		rr->length = 0;
		s->rwstate = SSL_NOTHING;
		return (0);
	}


	if (type == rr->type) /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */
	{
		/* make sure that we are not getting application data when we
		 * are doing a handshake for the first time */
		if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&
			(s->enc_read_ctx == NULL)) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);
			goto f_err;
		}

		if (len <= 0)
			return (len);

		if ((unsigned int)len > rr->length)
			n = rr->length;
		else
			n = (unsigned int)len;

		memcpy(buf, &(rr->data[rr->off]), n);
		if (!peek) {
			rr->length -= n;
			rr->off += n;
			if (rr->length == 0) {
				s->rstate = SSL_ST_READ_HEADER;
				rr->off = 0;
			}
		}

		return (n);
	}


	/* If we get here, then type != rr->type; if we have a handshake
	 * message, then it was unexpected (Hello Request or Client Hello). */

	/* In case of record types for which we have 'fragment' storage,
	 * fill that so that we can process the data at a fixed place.
	 */
	{
		unsigned int k, dest_maxlen = 0;
		unsigned char *dest = NULL;
		unsigned int *dest_len = NULL;

		if (rr->type == SSL3_RT_HANDSHAKE) {
			dest_maxlen = sizeof s->d1->handshake_fragment;
			dest = s->d1->handshake_fragment;
			dest_len = &s->d1->handshake_fragment_len;
		} else if (rr->type == SSL3_RT_ALERT) {
			dest_maxlen = sizeof(s->d1->alert_fragment);
			dest = s->d1->alert_fragment;
			dest_len = &s->d1->alert_fragment_len;
		}
		/* else it's a CCS message, or application data or wrong */
		else if (rr->type != SSL3_RT_CHANGE_CIPHER_SPEC) {
			/* Application data while renegotiating
			 * is allowed. Try again reading.
			 */
			if (rr->type == SSL3_RT_APPLICATION_DATA) {
				BIO *bio;
				s->s3->in_read_app_data = 2;
				bio = SSL_get_rbio(s);
				s->rwstate = SSL_READING;
				BIO_clear_retry_flags(bio);
				BIO_set_retry_read(bio);
				return (-1);
			}

			/* Not certain if this is the right error handling */
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_UNEXPECTED_RECORD);
			goto f_err;
		}

		if (dest_maxlen > 0) {
            /* XDTLS:  In a pathalogical case, the Client Hello
             *  may be fragmented--don't always expect dest_maxlen bytes */
			if (rr->length < dest_maxlen) {
#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
				/*
				 * for normal alerts rr->length is 2, while
				 * dest_maxlen is 7 if we were to handle this
				 * non-existing alert...
				 */
				FIX ME
#endif
				s->rstate = SSL_ST_READ_HEADER;
				rr->length = 0;
				goto start;
			}

			/* now move 'n' bytes: */
			for ( k = 0; k < dest_maxlen; k++) {
				dest[k] = rr->data[rr->off++];
				rr->length--;
			}
			*dest_len = dest_maxlen;
		}
	}

	/* s->d1->handshake_fragment_len == 12  iff  rr->type == SSL3_RT_HANDSHAKE;
	 * s->d1->alert_fragment_len == 7      iff  rr->type == SSL3_RT_ALERT.
	 * (Possibly rr is 'empty' now, i.e. rr->length may be 0.) */

	/* If we are a client, check for an incoming 'Hello Request': */
	if ((!s->server) &&
	    (s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) &&
	    (s->d1->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&
	    (s->session != NULL) && (s->session->cipher != NULL)) {
		s->d1->handshake_fragment_len = 0;

		if ((s->d1->handshake_fragment[1] != 0) ||
		    (s->d1->handshake_fragment[2] != 0) ||
		    (s->d1->handshake_fragment[3] != 0)) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);
			goto err;
		}

		/* no need to check sequence number on HELLO REQUEST messages */

		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
		s->d1->handshake_fragment, 4, s, s->msg_callback_arg);

		if (SSL_is_init_finished(s) &&
		    !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&
		    !s->s3->renegotiate) {
			s->d1->handshake_read_seq++;
			s->new_session = 1;
			ssl3_renegotiate(s);
			if (ssl3_renegotiate_check(s)) {
				i = s->handshake_func(s);
				if (i < 0)
					return (i);
				if (i == 0) {
					SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
					return (-1);
				}

				if (!(s->mode & SSL_MODE_AUTO_RETRY)) {
					if (s->s3->rbuf.left == 0) /* no read-ahead left? */
					{
						BIO *bio;
						/* In the case where we try to read application data,
						 * but we trigger an SSL handshake, we return -1 with
						 * the retry option set.  Otherwise renegotiation may
						 * cause nasty problems in the blocking world */
						s->rwstate = SSL_READING;
						bio = SSL_get_rbio(s);
						BIO_clear_retry_flags(bio);
						BIO_set_retry_read(bio);
						return (-1);
					}
				}
			}
		}
		/* we either finished a handshake or ignored the request,
		 * now try again to obtain the (application) data we were asked for */
		goto start;
	}

	if (s->d1->alert_fragment_len >= DTLS1_AL_HEADER_LENGTH) {
		int alert_level = s->d1->alert_fragment[0];
		int alert_descr = s->d1->alert_fragment[1];

		s->d1->alert_fragment_len = 0;

		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_ALERT,
		s->d1->alert_fragment, 2, s, s->msg_callback_arg);

		if (s->info_callback != NULL)
			cb = s->info_callback;
		else if (s->ctx->info_callback != NULL)
			cb = s->ctx->info_callback;

		if (cb != NULL) {
			j = (alert_level << 8) | alert_descr;
			cb(s, SSL_CB_READ_ALERT, j);
		}

		if (alert_level == 1) /* warning */
		{
			s->s3->warn_alert = alert_descr;
			if (alert_descr == SSL_AD_CLOSE_NOTIFY) {
				s->shutdown |= SSL_RECEIVED_SHUTDOWN;
				return (0);
			}
		} else if (alert_level == 2) /* fatal */
		{
			s->rwstate = SSL_NOTHING;
			s->s3->fatal_alert = alert_descr;
			SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);
			ERR_asprintf_error_data("SSL alert number %d",
			    alert_descr);
			s->shutdown|=SSL_RECEIVED_SHUTDOWN;
			SSL_CTX_remove_session(s->ctx, s->session);
			return (0);
		} else {
			al = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_UNKNOWN_ALERT_TYPE);
			goto f_err;
		}

		goto start;
	}

	if (s->shutdown & SSL_SENT_SHUTDOWN) /* but we have not received a shutdown */
	{
		s->rwstate = SSL_NOTHING;
		rr->length = 0;
		return (0);
	}

	if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC) {
		struct ccs_header_st ccs_hdr;
		unsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH;

		dtls1_get_ccs_header(rr->data, &ccs_hdr);

		/* 'Change Cipher Spec' is just a single byte, so we know
		 * exactly what the record payload has to look like */
		/* XDTLS: check that epoch is consistent */
		if ((rr->length != ccs_hdr_len) ||
		    (rr->off != 0) || (rr->data[0] != SSL3_MT_CCS)) {
			i = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_BAD_CHANGE_CIPHER_SPEC);
			goto err;
		}

		rr->length = 0;

		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC,
		rr->data, 1, s, s->msg_callback_arg);

		/* We can't process a CCS now, because previous handshake
		 * messages are still missing, so just drop it.
		 */
		if (!s->d1->change_cipher_spec_ok) {
			goto start;
		}

		s->d1->change_cipher_spec_ok = 0;

		s->s3->change_cipher_spec = 1;
		if (!ssl3_do_change_cipher_spec(s))
			goto err;

		/* do this whenever CCS is processed */
		dtls1_reset_seq_numbers(s, SSL3_CC_READ);

		goto start;
	}

	/* Unexpected handshake message (Client Hello, or protocol violation) */
	if ((s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) &&
	    !s->in_handshake) {
		struct hm_header_st msg_hdr;

		/* this may just be a stale retransmit */
		if (!dtls1_get_message_header(rr->data, &msg_hdr))
			return -1;
		if (rr->epoch != s->d1->r_epoch) {
			rr->length = 0;
			goto start;
		}

		/* If we are server, we may have a repeated FINISHED of the
		 * client here, then retransmit our CCS and FINISHED.
		 */
		if (msg_hdr.type == SSL3_MT_FINISHED) {
			if (dtls1_check_timeout_num(s) < 0)
				return -1;

			dtls1_retransmit_buffered_messages(s);
			rr->length = 0;
			goto start;
		}

		if (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&
		    !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {
			s->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;
			s->renegotiate = 1;
			s->new_session = 1;
		}
		i = s->handshake_func(s);
		if (i < 0)
			return (i);
		if (i == 0) {
			SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
			return (-1);
		}

		if (!(s->mode & SSL_MODE_AUTO_RETRY)) {
			if (s->s3->rbuf.left == 0) /* no read-ahead left? */
			{
				BIO *bio;
				/* In the case where we try to read application data,
				 * but we trigger an SSL handshake, we return -1 with
				 * the retry option set.  Otherwise renegotiation may
				 * cause nasty problems in the blocking world */
				s->rwstate = SSL_READING;
				bio = SSL_get_rbio(s);
				BIO_clear_retry_flags(bio);
				BIO_set_retry_read(bio);
				return (-1);
			}
		}
		goto start;
	}

	switch (rr->type) {
	default:
		/* TLS just ignores unknown message types */
		if (s->version == TLS1_VERSION) {
			rr->length = 0;
			goto start;
		}
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_UNEXPECTED_RECORD);
		goto f_err;
	case SSL3_RT_CHANGE_CIPHER_SPEC:
	case SSL3_RT_ALERT:
	case SSL3_RT_HANDSHAKE:
		/* we already handled all of these, with the possible exception
		 * of SSL3_RT_HANDSHAKE when s->in_handshake is set, but that
		 * should not happen when type != rr->type */
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
		goto f_err;
	case SSL3_RT_APPLICATION_DATA:
		/* At this point, we were expecting handshake data,
		 * but have application data.  If the library was
		 * running inside ssl3_read() (i.e. in_read_app_data
		 * is set) and it makes sense to read application data
		 * at this point (session renegotiation not yet started),
		 * we will indulge it.
		 */
		if (s->s3->in_read_app_data &&
		    (s->s3->total_renegotiations != 0) &&
		    (((s->state & SSL_ST_CONNECT) &&
		    (s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&
		    (s->state <= SSL3_ST_CR_SRVR_HELLO_A)) || (
		    (s->state & SSL_ST_ACCEPT) &&
		    (s->state <= SSL3_ST_SW_HELLO_REQ_A) &&
		    (s->state >= SSL3_ST_SR_CLNT_HELLO_A)))) {
			s->s3->in_read_app_data = 2;
			return (-1);
		} else {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_UNEXPECTED_RECORD);
			goto f_err;
		}
	}
	/* not reached */

f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	return (-1);
}

int
dtls1_write_app_data_bytes(SSL *s, int type, const void *buf_, int len)
{
	int i;

	if (SSL_in_init(s) && !s->in_handshake)
	{
		i = s->handshake_func(s);
		if (i < 0)
			return (i);
		if (i == 0) {
			SSLerr(SSL_F_DTLS1_WRITE_APP_DATA_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
			return -1;
		}
	}

	if (len > SSL3_RT_MAX_PLAIN_LENGTH) {
		SSLerr(SSL_F_DTLS1_WRITE_APP_DATA_BYTES, SSL_R_DTLS_MESSAGE_TOO_BIG);
		return -1;
	}

	i = dtls1_write_bytes(s, type, buf_, len);
	return i;
}


	/* this only happens when a client hello is received and a handshake
	 * is started. */
static int
have_handshake_fragment(SSL *s, int type, unsigned char *buf,
    int len, int peek)
{

	if ((type == SSL3_RT_HANDSHAKE) && (s->d1->handshake_fragment_len > 0))
		/* (partially) satisfy request from storage */
	{
		unsigned char *src = s->d1->handshake_fragment;
		unsigned char *dst = buf;
		unsigned int k, n;

		/* peek == 0 */
		n = 0;
		while ((len > 0) && (s->d1->handshake_fragment_len > 0)) {
			*dst++ = *src++;
			len--;
			s->d1->handshake_fragment_len--;
			n++;
		}
		/* move any remaining fragment bytes: */
		for (k = 0; k < s->d1->handshake_fragment_len; k++)
			s->d1->handshake_fragment[k] = *src++;
		return n;
	}

	return 0;
}


/* Call this to write data in records of type 'type'
 * It will return <= 0 if not all data has been sent or non-blocking IO.
 */
int
dtls1_write_bytes(SSL *s, int type, const void *buf, int len)
{
	int i;

	OPENSSL_assert(len <= SSL3_RT_MAX_PLAIN_LENGTH);
	s->rwstate = SSL_NOTHING;
	i = do_dtls1_write(s, type, buf, len);
	return i;
}

int
do_dtls1_write(SSL *s, int type, const unsigned char *buf, unsigned int len)
{
	unsigned char *p, *pseq;
	int i, mac_size, clear = 0;
	int prefix_len = 0;
	SSL3_RECORD *wr;
	SSL3_BUFFER *wb;
	SSL_SESSION *sess;
	int bs;

	/* first check if there is a SSL3_BUFFER still being written
	 * out.  This will happen with non blocking IO */
	if (s->s3->wbuf.left != 0) {
		OPENSSL_assert(0); /* XDTLS:  want to see if we ever get here */
		return (ssl3_write_pending(s, type, buf, len));
	}

	/* If we have an alert to send, lets send it */
	if (s->s3->alert_dispatch) {
		i = s->method->ssl_dispatch_alert(s);
		if (i <= 0)
			return (i);
		/* if it went, fall through and send more stuff */
	}

	if (len == 0)
		return 0;

	wr = &(s->s3->wrec);
	wb = &(s->s3->wbuf);
	sess = s->session;

	if ((sess == NULL) || (s->enc_write_ctx == NULL) ||
	    (EVP_MD_CTX_md(s->write_hash) == NULL))
		clear = 1;

	if (clear)
		mac_size = 0;
	else {
		mac_size = EVP_MD_CTX_size(s->write_hash);
		if (mac_size < 0)
			goto err;
	}

	/* DTLS implements explicit IV, so no need for empty fragments. */

	p = wb->buf + prefix_len;

	/* write the header */

	*(p++) = type&0xff;
	wr->type = type;

	*(p++) = (s->version >> 8);
	*(p++) = s->version&0xff;

	/* field where we are to write out packet epoch, seq num and len */
	pseq = p;

	p += 10;

	/* lets setup the record stuff. */

	/* Make space for the explicit IV in case of CBC.
	 * (this is a bit of a boundary violation, but what the heck).
	 */
	if (s->enc_write_ctx &&
	    (EVP_CIPHER_mode( s->enc_write_ctx->cipher ) & EVP_CIPH_CBC_MODE))
		bs = EVP_CIPHER_block_size(s->enc_write_ctx->cipher);
	else
		bs = 0;

	wr->data = p + bs;
	/* make room for IV in case of CBC */
	wr->length = (int)len;
	wr->input = (unsigned char *)buf;

	/* we now 'read' from wr->input, wr->length bytes into
	 * wr->data */

	memcpy(wr->data, wr->input, wr->length);
	wr->input = wr->data;

	/* we should still have the output to wr->data and the input
	 * from wr->input.  Length should be wr->length.
	 * wr->data still points in the wb->buf */

	if (mac_size != 0) {
		if (s->method->ssl3_enc->mac(s, &(p[wr->length + bs]), 1) < 0)
			goto err;
		wr->length += mac_size;
	}

	/* this is true regardless of mac size */
	wr->input = p;
	wr->data = p;


	/* ssl3_enc can only have an error on read */
	if (bs)	/* bs != 0 in case of CBC */
	{
		arc4random_buf(p, bs);
		/* master IV and last CBC residue stand for
		 * the rest of randomness */
		wr->length += bs;
	}

	s->method->ssl3_enc->enc(s, 1);

	/* record length after mac and block padding */
/*	if (type == SSL3_RT_APPLICATION_DATA ||
	(type == SSL3_RT_ALERT && ! SSL_in_init(s))) */

	/* there's only one epoch between handshake and app data */

	s2n(s->d1->w_epoch, pseq);

	/* XDTLS: ?? */
/*	else
	s2n(s->d1->handshake_epoch, pseq);
*/

	memcpy(pseq, &(s->s3->write_sequence[2]), 6);
	pseq += 6;
	s2n(wr->length, pseq);

	/* we should now have
	 * wr->data pointing to the encrypted data, which is
	 * wr->length long */
	wr->type=type; /* not needed but helps for debugging */
	wr->length += DTLS1_RT_HEADER_LENGTH;

	tls1_record_sequence_increment(s->s3->write_sequence);

	/* now let's set up wb */
	wb->left = prefix_len + wr->length;
	wb->offset = 0;

	/* memorize arguments so that ssl3_write_pending can detect bad write retries later */
	s->s3->wpend_tot = len;
	s->s3->wpend_buf = buf;
	s->s3->wpend_type = type;
	s->s3->wpend_ret = len;

	/* we now just need to write the buffer */
	return ssl3_write_pending(s, type, buf, len);
err:
	return -1;
}



static int
dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap)
{
	int cmp;
	unsigned int shift;
	const unsigned char *seq = s->s3->read_sequence;

	cmp = satsub64be(seq, bitmap->max_seq_num);
	if (cmp > 0) {
		memcpy (s->s3->rrec.seq_num, seq, 8);
		return 1; /* this record in new */
	}
	shift = -cmp;
	if (shift >= sizeof(bitmap->map)*8)
		return 0; /* stale, outside the window */
	else if (bitmap->map & (1UL << shift))
		return 0; /* record previously received */

	memcpy(s->s3->rrec.seq_num, seq, 8);
	return 1;
}


static void
dtls1_record_bitmap_update(SSL *s, DTLS1_BITMAP *bitmap)
{
	int cmp;
	unsigned int shift;
	const unsigned char *seq = s->s3->read_sequence;

	cmp = satsub64be(seq, bitmap->max_seq_num);
	if (cmp > 0) {
		shift = cmp;
		if (shift < sizeof(bitmap->map)*8)
			bitmap->map <<= shift, bitmap->map |= 1UL;
		else
			bitmap->map = 1UL;
		memcpy(bitmap->max_seq_num, seq, 8);
	} else {
		shift = -cmp;
		if (shift < sizeof(bitmap->map) * 8)
			bitmap->map |= 1UL << shift;
	}
}


int
dtls1_dispatch_alert(SSL *s)
{
	int i, j;
	void (*cb)(const SSL *ssl, int type, int val) = NULL;
	unsigned char buf[DTLS1_AL_HEADER_LENGTH];
	unsigned char *ptr = &buf[0];

	s->s3->alert_dispatch = 0;

	memset(buf, 0x00, sizeof(buf));
	*ptr++ = s->s3->send_alert[0];
	*ptr++ = s->s3->send_alert[1];

#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
	if (s->s3->send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE) {
		s2n(s->d1->handshake_read_seq, ptr);
		l2n3(s->d1->r_msg_hdr.frag_off, ptr);
	}
#endif

	i = do_dtls1_write(s, SSL3_RT_ALERT, &buf[0], sizeof(buf));
	if (i <= 0) {
		s->s3->alert_dispatch = 1;
		/* fprintf( stderr, "not done with alert\n" ); */
	} else {
		if (s->s3->send_alert[0] == SSL3_AL_FATAL
#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
		|| s->s3->send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
#endif
		)
			(void)BIO_flush(s->wbio);

		if (s->msg_callback)
			s->msg_callback(1, s->version, SSL3_RT_ALERT,
			    s->s3->send_alert, 2, s, s->msg_callback_arg);

		if (s->info_callback != NULL)
			cb = s->info_callback;
		else if (s->ctx->info_callback != NULL)
			cb = s->ctx->info_callback;

		if (cb != NULL) {
			j = (s->s3->send_alert[0]<<8)|s->s3->send_alert[1];
			cb(s, SSL_CB_WRITE_ALERT, j);
		}
	}
	return (i);
}


static DTLS1_BITMAP *
dtls1_get_bitmap(SSL *s, SSL3_RECORD *rr, unsigned int *is_next_epoch)
{

	*is_next_epoch = 0;

	/* In current epoch, accept HM, CCS, DATA, & ALERT */
	if (rr->epoch == s->d1->r_epoch)
		return &s->d1->bitmap;

	/* Only HM and ALERT messages can be from the next epoch */
	else if (rr->epoch == (unsigned long)(s->d1->r_epoch + 1) &&
		(rr->type == SSL3_RT_HANDSHAKE || rr->type == SSL3_RT_ALERT)) {
		*is_next_epoch = 1;
		return &s->d1->next_bitmap;
	}

	return NULL;
}

void
dtls1_reset_seq_numbers(SSL *s, int rw)
{
	unsigned char *seq;
	unsigned int seq_bytes = sizeof(s->s3->read_sequence);

	if (rw & SSL3_CC_READ) {
		seq = s->s3->read_sequence;
		s->d1->r_epoch++;
		memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP));
		memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP));
	} else {
		seq = s->s3->write_sequence;
		memcpy(s->d1->last_write_sequence, seq, sizeof(s->s3->write_sequence));
		s->d1->w_epoch++;
	}

	memset(seq, 0x00, seq_bytes);
}
@


1.48
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.47 2015/09/10 17:57:50 jsing Exp $ */
@


1.47
log
@Remove support for DTLS_BAD_VER. We do not support non-standard and
incomplete implementations just so that we can interoperate with products
from vendors who have not bothered to fix things in the last ~10 years.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.46 2015/07/19 01:07:40 doug Exp $ */
d1322 1
a1322 1
	ssl3_record_sequence_increment(s->s3->write_sequence);
@


1.46
log
@Assign p to CBS_data since it is used later.

The p initialization was hiding this bug but Coverity 126279 saw it.

ok miod@@ bcook@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.45 2015/07/18 23:00:23 doug Exp $ */
a973 3
		if (s->version == DTLS1_BAD_VER)
			ccs_hdr_len = 3;

a1004 4

		if (s->version == DTLS1_BAD_VER)
			s->d1->handshake_read_seq++;

@


1.45
log
@Convert dtls1_get_message_header to CBS and change to int.

Changed return value from void to int.  It should never return an error
given that the input length is not checked yet.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.44 2015/07/18 22:36:55 doug Exp $ */
d495 1
a495 1
		(s->packet_length < DTLS1_RT_HEADER_LENGTH)) {
d547 1
@


1.44
log
@Convert dtls1_get_record to CBS.

ok miod@@, input + ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.43 2015/07/18 22:28:53 doug Exp $ */
d1021 2
a1022 1
		dtls1_get_message_header(rr->data, &msg_hdr);
@


1.43
log
@Remove repeated code in dtls1_get_record.

The "if" is a bit ugly, but this does remove a lot of repetitive code.
This will be converted to CBS later as well.

ok miod@@
jsing@@ roughly ok with it after seeing the CBS version
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.42 2015/06/17 07:29:33 doug Exp $ */
d127 1
a467 1
	int ssl_major, ssl_minor;
a470 1
	unsigned short version;
d496 4
d511 1
a511 1
		p = s->packet;
d514 4
a517 4
		rr->type= *(p++);
		ssl_major= *(p++);
		ssl_minor= *(p++);
		version = (ssl_major << 8)|ssl_minor;
d520 3
a522 1
		n2s(p, rr->epoch);
d524 5
a528 2
		memcpy(&(s->s3->read_sequence[2]), p, 6);
		p += 6;
d530 3
a532 1
		n2s(p, rr->length);
d534 3
a536 6
		/* Lets check version */
		if (!s->first_packet) {
			if (version != s->version)
				/* unexpected version, silently discard */
				goto again;
		}
d538 2
a539 2
		if ((version & 0xff00) != (s->version & 0xff00))
			/* wrong version, silently discard record */
d542 1
a543 1
			/* record too long, silently discard it */
@


1.42
log
@KNF whitespace.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.41 2015/06/13 08:38:10 doug Exp $ */
d487 1
d489 5
d503 1
a503 2
		if (s->packet_length != DTLS1_RT_HEADER_LENGTH) {
			s->packet_length = 0;
a504 1
		}
d526 1
a526 1
			if (version != s->version) {
a527 2
				rr->length = 0;
				s->packet_length = 0;
a528 1
			}
d531 1
a531 1
		if ((version & 0xff00) != (s->version & 0xff00)) {
a532 2
			rr->length = 0;
			s->packet_length = 0;
a533 1
		}
d535 1
a535 1
		if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {
a536 2
			rr->length = 0;
			s->packet_length = 0;
a537 1
		}
d552 1
a552 3
		if (n != i) {
			rr->length = 0;
			s->packet_length = 0;
a553 1
		}
d562 1
a562 4
	if (bitmap == NULL) {
		rr->length = 0;
		s->packet_length = 0;
		/* dump this record */
a563 2
		/* get another record */
	}
d574 1
a574 3
	    !dtls1_record_replay_check(s, bitmap)) {
		rr->length = 0;
		s->packet_length=0; /* dump this record */
a575 2
		/* get another record */
	}
a593 2
		rr->length = 0;
		s->packet_length = 0;
d597 1
a597 4
	if (!dtls1_process_record(s)) {
		rr->length = 0;
		s->packet_length = 0;
		/* dump this record */
d599 1
a599 2
		/* get another record */
	}
a603 1

@


1.41
log
@Fix bad indenting in LibreSSL.

jsg@@ noticed that some of the lines in libssl and libcrypto are not
indented properly.  At a quick glance, it looks like it has a different
control flow than it really does.  I checked the history in our tree and
in OpenSSL to make sure these were simple mistakes.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.40 2015/02/09 10:53:28 jsing Exp $ */
d578 15
a592 14
		/* Check whether this is a repeat, or aged record.
		 * Don't check if we're listening and this message is
		 * a ClientHello. They can look as if they're replayed,
		 * since they arrive from different connections and
		 * would be dropped unnecessarily.
		 */
		if (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&
		    p != NULL && *p == SSL3_MT_CLIENT_HELLO) &&
		    !dtls1_record_replay_check(s, bitmap)) {
			rr->length = 0;
			s->packet_length=0; /* dump this record */
			goto again;
			/* get another record */
		}
@


1.40
log
@Jettison DTLS over SCTP.

OpenBSD does not have SCTP support and it sees little use in the wild.
OPENSSL_NO_SCTP is already specified via opensslfeatures.h, hence this
is a code removal only and symbols should remain unchanged.

ok beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.39 2015/01/21 00:15:50 doug Exp $ */
d1440 1
a1440 1
		(void)BIO_flush(s->wbio);
@


1.39
log
@Fix DTLS memory leak (CVE-2015-0206).

There were four bugs fixed by this patch:

* dtls1_buffer_record() now frees rdata->rbuf.buf on error.  Since
  s->s3->rbuf was memset, rdata->rbuf is the only pointer left which
  points to the old rbuf.  On error, rdata is freed so there will not
  be any way of freeing this memory unless we do it here.

* Changed the return code of dtls1_buffer_record() to differentiate
  between queue full (0) and error (-1).  See below as this differs
  from upstream.

* Handle errors if calls to dtls1_buffer_record() fail with -1.
  Previously, it did not check the return value.

* Changed the way receipts are recorded.  Previously, it was recorded
  when processed successfully (whether buffered or not) in
  dtls1_process_record().  Now, it records when it is handled in
  dtls1_get_record(): either when it is entered into the queue to buffer
  for the next epoch or when it is processed directly.  Processing
  buffered records does not add a receipt because it needed one in
  order to get into the queue.

The above bugs combined contributed to an eventual DoS through memory
exhaustion.  The memory leak came from dtls1_buffer_record()'s error
handling.  The error handling can be triggered by a duplicate record
or malloc failure.  It was possible to add duplicate records because
they were not being dropped.  The faulty receipts logic did not detect
replays when dealing with records for the next epoch.  Additionally,
dtls1_buffer_record()'s return value was not checked so an attacker
could send repeated replay records for the next epoch.

Reported to OpenSSL by Chris Mueller.

Patch based on OpenSSL commit 103b171d8fc282ef435f8de9afbf7782e312961f
and BoringSSL commit 44e2709cd65fbd2172b9516c79e56f1875f60300.

Our patch matches BoringSSL's commit.  OpenSSL returns 0 when the queue
is full or when malloc() or pitem_new() fails.  They return -1 on error
including !ssl3_setup_buffers() which is another failure to allocate
memory.

BoringSSL and LibreSSL changed the return code for dtls1_buffer_record()
to be 1 on success, 0 when the queue is full and -1 on error.

input + ok bcook@@, jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.38 2014/12/14 15:30:50 jsing Exp $ */
a233 7
#ifndef OPENSSL_NO_SCTP
	/* Store bio_dgram_sctp_rcvinfo struct */
	if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
		(s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {
		BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);
	}
#endif
a577 4
#ifndef OPENSSL_NO_SCTP
	/* Only do replay check if no SCTP bio */
	if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {
#endif
a591 3
#ifndef OPENSSL_NO_SCTP
	}
#endif
a680 10
#ifndef OPENSSL_NO_SCTP
	/* Continue handshake if it had to be interrupted to read
	 * app data with SCTP.
	 */
	if ((!s->in_handshake && SSL_in_init(s)) ||
	    (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
	    (s->state == DTLS1_SCTP_ST_SR_READ_SOCK ||
	    s->state == DTLS1_SCTP_ST_CR_READ_SOCK) &&
	    s->s3->in_read_app_data != 2))
#else
a681 1
#endif
a709 7
#ifndef OPENSSL_NO_SCTP
			/* Restore bio_dgram_sctp_rcvinfo struct */
			if (BIO_dgram_is_sctp(SSL_get_rbio(s))) {
				DTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *) item->data;
				BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);
			}
#endif
a796 23
#ifndef OPENSSL_NO_SCTP
		/* We were about to renegotiate but had to read
		 * belated application data first, so retry.
		 */
		if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
		    rr->type == SSL3_RT_APPLICATION_DATA &&
		    (s->state == DTLS1_SCTP_ST_SR_READ_SOCK ||
		    s->state == DTLS1_SCTP_ST_CR_READ_SOCK)) {
			s->rwstate = SSL_READING;
			BIO_clear_retry_flags(SSL_get_rbio(s));
			BIO_set_retry_read(SSL_get_rbio(s));
		}

		/* We might had to delay a close_notify alert because
		 * of reordered app data. If there was an alert and there
		 * is no message to read anymore, finally set shutdown.
		 */
		if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
			s->d1->shutdown_received && !BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {
			s->shutdown |= SSL_RECEIVED_SHUTDOWN;
			return (0);
		}
#endif
a953 14
#ifndef OPENSSL_NO_SCTP
				/* With SCTP and streams the socket may deliver app data
				 * after a close_notify alert. We have to check this
				 * first so that nothing gets discarded.
				 */
				if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
					BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {
					s->d1->shutdown_received = 1;
					s->rwstate = SSL_READING;
					BIO_clear_retry_flags(SSL_get_rbio(s));
					BIO_set_retry_read(SSL_get_rbio(s));
					return -1;
				}
#endif
a1026 8
#ifndef OPENSSL_NO_SCTP
		/* Remember that a CCS has been received,
		 * so that an old key of SCTP-Auth can be
		 * deleted when a CCS is sent. Will be ignored
		 * if no SCTP is used
		 */
		BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD, 1, NULL);
#endif
a1142 9
#ifndef OPENSSL_NO_SCTP
	/* Check if we have to continue an interrupted handshake
	 * for reading belated app data with SCTP.
	 */
	if ((SSL_in_init(s) && !s->in_handshake) ||
	    (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
	    (s->state == DTLS1_SCTP_ST_SR_READ_SOCK ||
	    s->state == DTLS1_SCTP_ST_CR_READ_SOCK)))
#else
a1143 1
#endif
@


1.38
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.37 2014/11/16 14:12:47 jsing Exp $ */
d225 1
a225 1
		goto err;
d257 3
d263 1
a263 1
	return (0);
d314 3
a316 2
			dtls1_buffer_record(s, &(s->d1->processed_rcds),
			s->s3->rrec.seq_num);
a452 1
	dtls1_record_bitmap_update(s, &(s->d1->bitmap));/* Mark receipt of record. */
d486 2
a487 1
	dtls1_process_buffered_records(s);
d618 5
a622 1
			dtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);
d636 2
d782 5
a786 1
		dtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num);
@


1.37
log
@Sort and group includes.
@
text
@d1 2
a2 2
/* $OpenBSD: d1_pkt.c,v 1.36 2014/10/22 15:29:31 jsing Exp $ */
/* 
d4 1
a4 1
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.  
d14 1
a14 1
 *    notice, this list of conditions and the following disclaimer. 
d65 1
a65 1
 * 
d72 1
a72 1
 * 
d79 1
a79 1
 * 
d94 1
a94 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d97 1
a97 1
 * 
d109 1
a109 1
 * 
d283 1
a283 1
/* retrieve a buffered record that belongs to the new epoch, i.e., not processed 
d316 1
a316 1
    /* sync epoch numbers once all the unprocessed records 
d347 1
a347 1
	 * rr->input will be pointed at the new buffer */ 
d837 1
a837 1
#endif			
d1237 1
a1237 1
	/* this only happens when a client hello is received and a handshake 
@


1.36
log
@Avoid a NULL pointer dereference that can be triggered by
SSL3_RT_HANDSHAKE replays.

Reported by Markus Stenberg <markus.stenberg at iki.fi> - thanks!

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.35 2014/10/18 16:13:16 jsing Exp $ */
d116 3
d120 1
a120 2
#include <errno.h>
#include <machine/endian.h>
d122 2
a124 1
#include <openssl/buffer.h>
@


1.35
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.34 2014/08/07 20:02:23 miod Exp $ */
d589 1
a589 1
		    *p == SSL3_MT_CLIENT_HELLO) &&
@


1.34
log
@Oops, revert changes commited by mistake. The previous commit was supposed
to only apply to s23_srvr.c.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.32 2014/07/10 08:51:14 tedu Exp $ */
a121 1
#include <openssl/rand.h>
d1382 1
a1382 1
		RAND_pseudo_bytes(p, bs);
@


1.33
log
@When you expect a function to return a particular value, don't put a comment
saying that you expect it to return that value and compare it against zero
because it is supposedly faster, for this leads to bugs (especially given the
high rate of sloppy cut'n'paste within ssl3 and dtls1 routines in this
library).

Instead, compare for the exact value it ought to return upon success.

ok deraadt@@
@
text
@d417 1
a417 2
		if (i < 0 || mac == NULL ||
		    timingsafe_memcmp(md, mac, (size_t)mac_size) != 0)
a420 1
		OPENSSL_cleanse(&md, sizeof md);
@


1.32
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.31 2014/07/09 16:06:14 miod Exp $ */
d417 2
a418 1
		if (i < 0 || mac == NULL || timingsafe_memcmp(md, mac, (size_t)mac_size) != 0)
d422 1
@


1.31
log
@Remove leading underscore from _BYTE_ORDER and _{LITTLE,BIG}_ENDIAN, to be
more friendly to systems where the underscore flavours may be defined as empty.
Found the hard way be bcook@@; joint brainstrom with bcook beck and guenther
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.30 2014/06/19 21:29:51 tedu Exp $ */
a429 14
	/* r->length is now just compressed */
	if (s->expand != NULL) {
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH) {
			al = SSL_AD_RECORD_OVERFLOW;
			SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);
			goto f_err;
		}
		if (!ssl3_do_uncompress(s)) {
			al = SSL_AD_DECOMPRESSION_FAILURE;
			SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_BAD_DECOMPRESSION);
			goto f_err;
		}
	}

d1362 2
a1363 10
	/* first we compress */
	if (s->compress != NULL) {
		if (!ssl3_do_compress(s)) {
			SSLerr(SSL_F_DO_DTLS1_WRITE, SSL_R_COMPRESSION_FAILURE);
			goto err;
		}
	} else {
		memcpy(wr->data, wr->input, wr->length);
		wr->input = wr->data;
	}
@


1.30
log
@convert CRYPTO_memcmp to timingsafe_memcmp based on current policy favoring
libc interfaces over libcrypto interfaces. for now we also prefer
timingsafe_memcmp over timingsafe_bcmp, even when the latter is acceptable.
ok beck deraadt matthew miod
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.29 2014/06/15 15:29:25 jsing Exp $ */
d136 1
a136 1
			if (_BYTE_ORDER == _LITTLE_ENDIAN)
@


1.29
log
@Rename ssl3_record_sequence_update() to ssl3_record_sequence_increment(),
so that it reflects what it is actually doing. Use this function in a
number of places that still have the hand rolled version.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_pkt.c,v 1.28 2014/06/12 15:49:31 deraadt Exp $ */
d417 1
a417 1
		if (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
@


1.28
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1436 1
a1436 1
	ssl3_record_sequence_update(&(s->s3->write_sequence[0]));
@


1.27
log
@Disable TLS support...

Just kidding!

unifdef OPENSSL_NO_TLS since we will never want to actually do that.

ok deraadt@@
@
text
@d1 1
a1 1
/* ssl/d1_pkt.c */
@


1.26
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@a1163 1
#ifndef OPENSSL_NO_TLS
a1168 1
#endif
@


1.25
log
@While working on another diff I ended up looking to see why on earth the
DTLS code had a chunk that checked to see if the SSL version was *not*
DTLS. Turns out that this is inside a big #if 0 block with a comment
explaining why DTLS will never need this code...

The DTLS code was clearly written by wholesale copying the SSLv3 code.
Any code not applicable to DTLS was seemingly #if 0'd or commented out
and left for others to find.

d1_pkt.c is copied from s3_pkt.c and it has a do_dtls1_write() function
that has the same function signature as do_ssl3_write(), except that the
create_empty_fragement (yes, that is the spelling in ssl_locl.h) argument
is unused for DTLS (although there is code that pretends to use it) since
it uses explicit IV (as the comment notes).

Instead of leaving this turd lying around, nuke the #if 0'd code (along
with the check for *not* DTLS) and remove the pointless
create_empty_fragment argument given the only two do_dtls1_write() calls
specify zero.

This kind of thing also makes you wonder how much actual peer review
occurred before the code was initially committed...

ok beck@@
@
text
@a183 4
#if 0
static int dtls1_record_needs_buffering(SSL *s, SSL3_RECORD *rr,
    unsigned short *priority, unsigned long *offset);
#endif
a321 44

#if 0

static int
dtls1_get_buffered_record(SSL *s)
{
	pitem *item;
	PQ_64BIT priority =
	    (((PQ_64BIT)s->d1->handshake_read_seq) << 32) |
	    ((PQ_64BIT)s->d1->r_msg_hdr.frag_off);

	if (!SSL_in_init(s))  /* if we're not (re)negotiating,
				   nothing buffered */
		return 0;


	item = pqueue_peek(s->d1->rcvd_records);
	if (item && item->priority == priority) {
		/* Check if we've received the record of interest.  It must be
		 * a handshake record, since data records as passed up without
		 * buffering */
		DTLS1_RECORD_DATA *rdata;
		item = pqueue_pop(s->d1->rcvd_records);
		rdata = (DTLS1_RECORD_DATA *)item->data;

		free(s->s3->rbuf.buf);

		s->packet = rdata->packet;
		s->packet_length = rdata->packet_length;
		memcpy(&(s->s3->rbuf), &(rdata->rbuf), sizeof(SSL3_BUFFER));
		memcpy(&(s->s3->rrec), &(rdata->rrec), sizeof(SSL3_RECORD));

		free(item->data);
		pitem_free(item);

		/* s->d1->next_expected_seq_num++; */
		return (1);
	}

	return 0;
}

#endif

a1023 23
#if 0
			/* XXX: this is a possible improvement in the future */
			/* now check if it's a missing record */
			if (alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE) {
				unsigned short seq;
				unsigned int frag_off;
				unsigned char *p = &(s->d1->alert_fragment[2]);

				n2s(p, seq);
				n2l3(p, frag_off);

				dtls1_retransmit_message(s,
				dtls1_get_queue_priority(frag->msg_header.seq, 0),
				frag_off, &found);
				if (!found  && SSL_in_init(s)) {
					/* fprintf( stderr,"in init = %d\n", SSL_in_init(s)); */
					/* requested a message not yet sent, 
					   send an alert ourselves */
					ssl3_send_alert(s, SSL3_AL_WARNING,
					DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
				}
			}
#endif
a1437 7
#if 0  /* this is now done at the message layer */
	/* buffer the record, making it easy to handle retransmits */
	if (type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC)
		dtls1_buffer_record(s, wr->data, wr->length,
	*((PQ_64BIT *)&(s->s3->write_sequence[0])));
#endif

a1520 10
#if 0
		if ( s->d1->r_msg_hdr.frag_off == 0)  /* waiting for a new msg */

		else
			s2n(s->d1->r_msg_hdr.seq, ptr); /* partial msg read */
#endif

#if 0
		fprintf(stderr, "s->d1->handshake_read_seq = %d, s->d1->r_msg_hdr.seq = %d\n", s->d1->handshake_read_seq, s->d1->r_msg_hdr.seq);
#endif
a1573 58

#if 0
static int
dtls1_record_needs_buffering(SSL *s, SSL3_RECORD *rr, unsigned short *priority,
    unsigned long *offset)
{

	/* alerts are passed up immediately */
	if (rr->type == SSL3_RT_APPLICATION_DATA || rr->type == SSL3_RT_ALERT)
		return 0;

	/* Only need to buffer if a handshake is underway.
	 * (this implies that Hello Request and Client Hello are passed up
	 * immediately) */
	if (SSL_in_init(s)) {
		unsigned char *data = rr->data;
		/* need to extract the HM/CCS sequence number here */
		if (rr->type == SSL3_RT_HANDSHAKE ||
		    rr->type == SSL3_RT_CHANGE_CIPHER_SPEC) {
			unsigned short seq_num;
			struct hm_header_st msg_hdr;
			struct ccs_header_st ccs_hdr;

			if (rr->type == SSL3_RT_HANDSHAKE) {
				dtls1_get_message_header(data, &msg_hdr);
				seq_num = msg_hdr.seq;
				*offset = msg_hdr.frag_off;
			} else {
				dtls1_get_ccs_header(data, &ccs_hdr);
				seq_num = ccs_hdr.seq;
				*offset = 0;
			}

			/* this is either a record we're waiting for, or a
			 * retransmit of something we happened to previously 
			 * receive (higher layers will drop the repeat silently */
			if (seq_num < s->d1->handshake_read_seq)
				return 0;
			if (rr->type == SSL3_RT_HANDSHAKE &&
			    seq_num == s->d1->handshake_read_seq &&
			    msg_hdr.frag_off < s->d1->r_msg_hdr.frag_off)
				return 0;
			else if (seq_num == s->d1->handshake_read_seq &&
			    (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC ||
			    msg_hdr.frag_off == s->d1->r_msg_hdr.frag_off))
				return 0;
			else {
				*priority = seq_num;
				return 1;
			}
		}
		else /* unknown record type */
			return 0;
	}

	return 0;
}
#endif
@


1.24
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@d1364 1
a1364 1
	i = do_dtls1_write(s, type, buf, len, 0);
d1369 1
a1369 1
do_dtls1_write(SSL *s, int type, const unsigned char *buf, unsigned int len, int create_empty_fragment)
d1394 1
a1394 1
	if (len == 0 && !create_empty_fragment)
d1413 1
a1413 25
	/* DTLS implements explicit IV, so no need for empty fragments */
#if 0
	/* 'create_empty_fragment' is true only when this function calls itself */
	if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done &&
	    SSL_version(s) != DTLS1_VERSION &&
	    SSL_version(s) != DTLS1_BAD_VER) {
		/* countermeasure against known-IV weakness in CBC ciphersuites
		 * (see http://www.openssl.org/~bodo/tls-cbc.txt) 
		 */

		if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) {
			/* recursive function call with 'create_empty_fragment' set;
			 * this prepares and buffers the data for an empty fragment
			 * (these 'prefix_len' bytes are sent out later
			 * together with the actual payload) */
			prefix_len = s->method->do_ssl_write(s, type, buf, 0, 1);
			if (prefix_len <= 0)
				goto err;

			if (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE) {
				/* insufficient space */
				SSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR);
				goto err;
			}
		}
a1414 3
		s->s3->empty_fragment_done = 1;
	}
#endif
a1517 7
	if (create_empty_fragment) {
		/* we are in a recursive call;
		 * just return the length, don't write out anything here
		 */
		return wr->length;
	}

d1613 1
a1613 1
	i = do_dtls1_write(s, SSL3_RT_ALERT, &buf[0], sizeof(buf), 0);
@


1.23
log
@Remove redundant test introduced in s3_pkt.c on 20001225, which got cargo-culted
(with an XXX comment, though) in d1_pkt.c in 2005.
@
text
@d200 1
a200 2
	if (s->s3->rbuf.buf != NULL)
		free(s->s3->rbuf.buf);
d351 1
a351 2
		if (s->s3->rbuf.buf != NULL)
			free(s->s3->rbuf.buf);
@


1.22
log
@Make sure all error paths in dtls1_buffer_record() invoke SSLErr by
factoring error handling.

ok jsing@@
@
text
@d734 2
a735 3
	/* XXX: check what the second '&& type' is about */
	if ((type && (type != SSL3_RT_APPLICATION_DATA) &&
	    (type != SSL3_RT_HANDSHAKE) && type) ||
@


1.21
log
@Remove TLS_DEBUG, SSL_DEBUG, CIPHER_DEBUG and OPENSSL_RI_DEBUG. Much of
this is sporadic, hacked up and can easily be put back in an improved form
should we ever need it.

ok miod@@
@
text
@d227 2
a228 9
	if (rdata == NULL || item == NULL) {
		if (rdata != NULL)
			free(rdata);
		if (item != NULL)
			pitem_free(item);

		SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);
		return (0);
	}
d250 2
a251 6
	if (!ssl3_setup_buffers(s)) {
		SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);
		free(rdata);
		pitem_free(item);
		return (0);
	}
d254 2
a255 5
	if (pqueue_insert(queue->q, item) == NULL) {
		free(rdata);
		pitem_free(item);
		return (0);
	}
d258 6
@


1.20
log
@Stop pulling pqueue.h into ssl_locl.h since only a small part of libssl
actually needs it. Instead, just include it in the files where it is
actually necessary.

Also remove standard includes from pqueue.h so that they are not available
as a side effect. Just add the two includes that are needed to pqueue.c.

ok miod@@
@
text
@a429 5
#ifdef TLS_DEBUG
	printf("dec %d\n", rr->length);
	{ unsigned int z; for (z = 0; z<rr->length; z++) printf("%02X%c", rr->data[z],((z+1)%16)?' ':'\n'); }
	printf("\n");
#endif
@


1.19
log
@Make sure ssl3_setup_buffers() does not return upon error with a freed
pqueue still chained, by inserting it into the list only after all possible
failure conditions have been avoided.

Reported and fix proposed by David Ramos; ok beck@@
@
text
@d124 2
@


1.18
log
@No longer make pqueue.h a public (and installed) header file. Replace its
inclusion in <ssl/dtls1.h> by the benign
`struct _pqueue; typedef struct _pqueue *pqueue;'.

Note that said dtls1.h should probably be considered a private header as well...

ok beck@@
@
text
@a249 7
	/* insert should not fail, since duplicates are dropped */
	if (pqueue_insert(queue->q, item) == NULL) {
		free(rdata);
		pitem_free(item);
		return (0);
	}

d257 7
@


1.17
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@a121 1
#include <openssl/pqueue.h>
@


1.16
log
@Figure out endianness at compile-time, using _BYTE_ORDER from
<machine/endian.h>, rather than writing 1 to a 32-bit variable and checking
whether the first byte is nonzero.

tweaks and ok matthew@@; ok beck@@ tedu@@
@
text
@a1111 2
			char tmp[16];

d1115 2
a1116 2
			(void) snprintf(tmp,sizeof tmp,"%d",alert_descr);
			ERR_add_error_data(2, "SSL alert number ", tmp);
@


1.15
log
@whack a bunch of disabled code. ok beck lteo
@
text
@d118 1
a132 4
			const union {
				long one;
				char little;
			} is_endian = {1};
d135 1
a135 1
			if (is_endian.little)
@


1.14
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a1222 6
#if 0 /* worked only because C operator preferences are not as expected (and
			* because this is not really needed for clients except for detecting
       * protocol violations): */
			s->state = SSL_ST_BEFORE |
			    (s->server) ? SSL_ST_ACCEPT : SSL_ST_CONNECT;
#else
a1223 1
#endif
@


1.13
log
@Flense all use of BIO_snprintf from ssl source - use the real one instead,
and allow for the normal posix mandated return values instead of the
nonstandard one from BIO_snprintf.
ok miod@@
@
text
@d203 1
a203 1
		OPENSSL_free(s->s3->rbuf.buf);
d227 1
a227 1
	rdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));
d231 1
a231 1
			OPENSSL_free(rdata);
d256 1
a256 1
		OPENSSL_free(rdata);
d268 1
a268 1
		OPENSSL_free(rdata);
d286 1
a286 1
		OPENSSL_free(item->data);
d363 1
a363 1
			OPENSSL_free(s->s3->rbuf.buf);
d370 1
a370 1
		OPENSSL_free(item->data);
d813 1
a813 1
			OPENSSL_free(item->data);
@


1.12
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@d1120 1
a1120 1
			BIO_snprintf(tmp, sizeof tmp, "%d", alert_descr);
@


1.11
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a939 12
#ifndef OPENSSL_NO_HEARTBEATS
		else if (rr->type == TLS1_RT_HEARTBEAT) {
			dtls1_process_heartbeat(s);

			/* Exit and notify application to read again */
			rr->length = 0;
			s->rwstate = SSL_READING;
			BIO_clear_retry_flags(SSL_get_rbio(s));
			BIO_set_retry_read(SSL_get_rbio(s));
			return (-1);
		}
#endif
@


1.10
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@d125 4
a128 2
static int satsub64be(const unsigned char *v1,const unsigned char *v2)
{	int ret,sat,brw,i;
d130 25
a154 16
	if (sizeof(long) == 8) do
	{	const union { long one; char little; } is_endian = {1};
		long l;

		if (is_endian.little)			break;
		/* not reached on little-endians */
		/* following test is redundant, because input is
		 * always aligned, but I take no chances... */
		if (((size_t)v1|(size_t)v2)&0x7)	break;

		l  = *((long *)v1);
		l -= *((long *)v2);
		if (l>128)		return 128;
		else if (l<-128)	return -128;
		else			return (int)l;
	} while (0);
d156 1
a156 1
	ret = (int)v1[7]-(int)v2[7];
d158 4
a161 4
	brw = ret>>8;	/* brw is either 0 or -1 */
	if (ret & 0x80)
	{	for (i=6;i>=0;i--)
		{	brw += (int)v1[i]-(int)v2[i];
d165 3
a167 4
	}
	else
	{	for (i=6;i>=0;i--)
		{	brw += (int)v1[i]-(int)v2[i];
d174 4
a177 2
	if (sat&0xff)	return brw | 0x80;
	else		return brw + (ret&0xFF);
d180 2
a181 2
static int have_handshake_fragment(SSL *s, int type, unsigned char *buf, 
	int len, int peek);
d184 1
a184 1
static DTLS1_BITMAP *dtls1_get_bitmap(SSL *s, SSL3_RECORD *rr, 
d188 1
a188 1
	unsigned short *priority, unsigned long *offset);
d191 1
a191 1
	unsigned char *priority);
d197 12
a208 2
    {
    DTLS1_RECORD_DATA *rdata;
a209 10
    rdata = (DTLS1_RECORD_DATA *)item->data;
    
    if (s->s3->rbuf.buf != NULL)
        OPENSSL_free(s->s3->rbuf.buf);
    
    s->packet = rdata->packet;
    s->packet_length = rdata->packet_length;
    memcpy(&(s->s3->rbuf), &(rdata->rbuf), sizeof(SSL3_BUFFER));
    memcpy(&(s->s3->rrec), &(rdata->rrec), sizeof(SSL3_RECORD));
	
d212 3
a214 3
    
    return(1);
    }
d219 1
a219 1
	{
d226 1
a226 1
		
d229 6
a234 5
	if (rdata == NULL || item == NULL)
		{
		if (rdata != NULL) OPENSSL_free(rdata);
		if (item != NULL) pitem_free(item);
		
d236 3
a238 3
		return(0);
		}
	
d249 1
a249 1
	    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {
d255 1
a255 2
	if (pqueue_insert(queue->q, item) == NULL)
		{
d258 2
a259 2
		return(0);
		}
d265 2
a266 3
	
	if (!ssl3_setup_buffers(s))
		{
d270 1
a270 4
		return(0);
		}
	
	return(1);
d273 3
d279 2
a280 2
    {
    pitem *item;
d282 3
a284 4
    item = pqueue_pop(queue->q);
    if (item)
        {
        dtls1_copy_record(s, item);
d286 1
a286 1
        OPENSSL_free(item->data);
d289 2
a290 2
        return(1);
        }
d292 2
a293 2
    return(0);
    }
d309 19
a327 20
    {
    pitem *item;
    
    item = pqueue_peek(s->d1->unprocessed_rcds.q);
    if (item)
        {
        /* Check if epoch is current. */
        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
            return(1);  /* Nothing to do. */
        
        /* Process all the records. */
        while (pqueue_peek(s->d1->unprocessed_rcds.q))
            {
            dtls1_get_unprocessed_record(s);
            if ( ! dtls1_process_record(s))
                return(0);
            dtls1_buffer_record(s, &(s->d1->processed_rcds), 
                s->s3->rrec.seq_num);
            }
        }
d331 2
a332 2
    s->d1->processed_rcds.epoch = s->d1->r_epoch;
    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;
d334 2
a335 2
    return(1);
    }
d342 1
a342 1
	{
d344 6
a349 6
	PQ_64BIT priority = 
		(((PQ_64BIT)s->d1->handshake_read_seq) << 32) | 
		((PQ_64BIT)s->d1->r_msg_hdr.frag_off);
	
	if ( ! SSL_in_init(s))  /* if we're not (re)negotiating, 
							   nothing buffered */
d354 1
a354 2
	if (item && item->priority == priority)
		{
d361 1
a361 1
		
d364 1
a364 1
		
d369 1
a369 1
		
d372 1
a372 1
		
d374 3
a376 3
		return(1);
		}
	
d378 1
a378 1
	}
d385 1
a385 1
	int i,al;
d392 1
a392 1
	rr= &(s->s3->rrec);
d398 1
a398 1
	rr->input= &(s->packet[DTLS1_RT_HEADER_LENGTH]);
d411 3
a413 4
	if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)
		{
		al=SSL_AD_RECORD_OVERFLOW;
		SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
d415 1
a415 1
		}
d418 1
a418 1
	rr->data=rr->input;
d420 1
a420 1
	enc_err = s->method->ssl3_enc->enc(s,0);
d425 1
a425 2
	if (enc_err == 0)
		{
d430 1
a430 1
		}
d433 3
a435 3
printf("dec %d\n",rr->length);
{ unsigned int z; for (z=0; z<rr->length; z++) printf("%02X%c",rr->data[z],((z+1)%16)?' ':'\n'); }
printf("\n");
d439 2
a440 4
	if ((sess != NULL) &&
	    (s->enc_read_ctx != NULL) &&
	    (EVP_MD_CTX_md(s->read_hash) != NULL))
		{
d444 1
a444 1
		mac_size=EVP_MD_CTX_size(s->read_hash);
d448 1
a448 1
		orig_len = rr->length+((unsigned int)rr->type>>8);
d456 1
a456 1
		    /* CBC records must have a padding length byte too. */
d458 3
a460 4
		     orig_len < mac_size+1))
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_LENGTH_TOO_SHORT);
d462 1
a462 1
			}
d464 1
a464 2
		if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE)
			{
d473 1
a473 3
			}
		else
			{
d479 1
a479 1
			}
d481 1
a481 1
		i=s->method->ssl3_enc->mac(s,md,0 /* not send */);
d484 1
a484 1
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+mac_size)
d486 1
a486 1
		}
d488 1
a488 2
	if (enc_err < 0)
		{
d493 1
a493 1
		}
d496 4
a499 6
	if (s->expand != NULL)
		{
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH)
			{
			al=SSL_AD_RECORD_OVERFLOW;
			SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_COMPRESSED_LENGTH_TOO_LONG);
d501 4
a504 5
			}
		if (!ssl3_do_uncompress(s))
			{
			al=SSL_AD_DECOMPRESSION_FAILURE;
			SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_BAD_DECOMPRESSION);
a505 1
			}
d507 1
d509 3
a511 4
	if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH)
		{
		al=SSL_AD_RECORD_OVERFLOW;
		SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_DATA_LENGTH_TOO_LONG);
d513 1
a513 1
		}
d515 1
a515 1
	rr->off=0;
d525 1
a525 1
	s->packet_length=0;
d527 1
a527 1
	return(1);
d530 1
a530 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d532 1
a532 1
	return(0);
d545 5
a549 4
int dtls1_get_record(SSL *s)
	{
	int ssl_major,ssl_minor;
	int i,n;
d556 1
a556 1
	rr= &(s->s3->rrec);
d569 3
a571 4
	if (	(s->rstate != SSL_ST_READ_BODY) ||
		(s->packet_length < DTLS1_RT_HEADER_LENGTH)) 
		{
		n=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);
d573 2
a574 1
		if (n <= 0) return(n); /* error or non-blocking */
d577 1
a577 2
		if (s->packet_length != DTLS1_RT_HEADER_LENGTH)
			{
d580 1
a580 1
			}
d582 1
a582 1
		s->rstate=SSL_ST_READ_BODY;
d584 1
a584 1
		p=s->packet;
d590 1
a590 1
		version=(ssl_major<<8)|ssl_minor;
d592 2
a593 2
		/* sequence number is 64 bits, with top 2 bytes = epoch */ 
		n2s(p,rr->epoch);
d596 1
a596 1
		p+=6;
d598 1
a598 1
		n2s(p,rr->length);
d601 2
a602 4
		if (!s->first_packet)
			{
			if (version != s->version)
				{
a606 1
				}
d608 1
d610 1
a610 2
		if ((version & 0xff00) != (s->version & 0xff00))
			{
d615 1
a615 1
			}
d617 1
a617 2
		if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)
			{
d622 1
a622 1
			}
d625 1
a625 1
		}
d629 1
a629 2
	if (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)
		{
d631 4
a634 3
		i=rr->length;
		n=ssl3_read_n(s,i,i,1);
		if (n <= 0) return(n); /* error or non-blocking io */
d637 1
a637 2
		if ( n != i)
			{
d641 1
a641 1
			}
d645 2
a646 2
		}
	s->rstate=SSL_ST_READ_HEADER; /* set state for later operations */
d650 1
a650 2
	if ( bitmap == NULL)
		{
d652 5
a656 3
		s->packet_length = 0;  /* dump this record */
		goto again;   /* get another record */
		}
d660 1
a660 2
	if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))
  		{
d670 1
a670 2
		    !dtls1_record_replay_check(s, bitmap))
			{
d673 3
a675 2
			goto again;     /* get another record */
			}
d677 1
a677 1
  		}
d681 2
a682 1
	if (rr->length == 0) goto again;
d689 2
a690 4
	if (is_next_epoch)
		{
		if ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)
			{
d692 1
a692 1
			}
d696 1
a696 1
		}
d698 1
a698 2
	if (!dtls1_process_record(s))
		{
d700 5
a704 3
		s->packet_length = 0;  /* dump this record */
		goto again;   /* get another record */
		}
d706 1
a706 1
	return(1);
d708 1
a708 1
	}
d737 4
a740 3
int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
	{
	int al,i,j,ret;
d743 1
a743 1
	void (*cb)(const SSL *ssl,int type2,int val)=NULL;
d747 1
a747 1
			return(-1);
d749 4
a752 5
    /* XXX: check what the second '&& type' is about */
	if ((type && (type != SSL3_RT_APPLICATION_DATA) && 
		(type != SSL3_RT_HANDSHAKE) && type) ||
	    (peek && (type != SSL3_RT_APPLICATION_DATA)))
		{
d755 1
a755 1
		}
d758 1
a758 1
	if ( (ret = have_handshake_fragment(s, type, buf, len, peek)))
d769 3
a771 2
	     (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK) &&
	     s->s3->in_read_app_data != 2))
d775 1
a775 1
		{
d777 6
a782 7
		i=s->handshake_func(s);
		if (i < 0) return(i);
		if (i == 0)
			{
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
			return(-1);
			}
d784 1
d787 1
a787 1
	s->rwstate=SSL_NOTHING;
d799 1
a799 2
	if (s->state == SSL_ST_OK && rr->length == 0)
		{
d802 1
a802 2
		if (item)
			{
d805 1
a805 2
			if (BIO_dgram_is_sctp(SSL_get_rbio(s)))
				{
d808 1
a808 1
				}
a814 1
			}
d816 1
d823 3
a825 5
	if ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))
		{
		ret=dtls1_get_record(s);
		if (ret <= 0) 
			{
d828 2
a829 2
			if (ret <= 0)  
				return(ret);
a831 1
			}
d833 1
d835 1
a835 2
	if (s->d1->listen && rr->type != SSL3_RT_HANDSHAKE)
		{
d838 1
a838 1
		}
d844 1
a844 2
		&& (rr->type != SSL3_RT_HANDSHAKE))
		{
d853 1
a853 1
		}
d857 5
a861 6
	if (s->shutdown & SSL_RECEIVED_SHUTDOWN)
		{
		rr->length=0;
		s->rwstate=SSL_NOTHING;
		return(0);
		}
d865 1
a865 1
		{
d869 3
a871 4
			(s->enc_read_ctx == NULL))
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);
d873 1
a873 1
			}
d875 2
a876 1
		if (len <= 0) return(len);
d883 7
a889 10
		memcpy(buf,&(rr->data[rr->off]),n);
		if (!peek)
			{
			rr->length-=n;
			rr->off+=n;
			if (rr->length == 0)
				{
				s->rstate=SSL_ST_READ_HEADER;
				rr->off=0;
				}
d891 1
d894 11
a904 11
			/* We were about to renegotiate but had to read
			 * belated application data first, so retry.
			 */
			if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
			    rr->type == SSL3_RT_APPLICATION_DATA &&
			    (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK))
				{
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				}
d906 9
a914 10
			/* We might had to delay a close_notify alert because
			 * of reordered app data. If there was an alert and there
			 * is no message to read anymore, finally set shutdown.
			 */
			if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
			    s->d1->shutdown_received && !BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))
				{
				s->shutdown |= SSL_RECEIVED_SHUTDOWN;
				return(0);
				}
d916 2
a917 2
		return(n);
		}
d926 1
a926 1
		{
d931 1
a931 2
		if (rr->type == SSL3_RT_HANDSHAKE)
			{
d935 1
a935 3
			}
		else if (rr->type == SSL3_RT_ALERT)
			{
d939 1
a939 1
			}
d941 1
a941 2
		else if (rr->type == TLS1_RT_HEARTBEAT)
			{
d946 1
a946 1
			s->rwstate=SSL_READING;
d949 2
a950 2
			return(-1);
			}
d953 1
a953 2
		else if (rr->type != SSL3_RT_CHANGE_CIPHER_SPEC)
			{
d957 1
a957 2
			if (rr->type == SSL3_RT_APPLICATION_DATA)
				{
d959 3
a961 3
				s->s3->in_read_app_data=2;
				bio=SSL_get_rbio(s);
				s->rwstate=SSL_READING;
d964 2
a965 2
				return(-1);
				}
d968 2
a969 2
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
d971 1
a971 1
			}
d973 1
a973 2
		if (dest_maxlen > 0)
			{
d976 1
a976 2
			if ( rr->length < dest_maxlen)
				{
d985 1
a985 1
				s->rstate=SSL_ST_READ_HEADER;
d988 1
a988 1
				}
d991 1
a991 2
			for ( k = 0; k < dest_maxlen; k++)
				{
d994 1
a994 1
				}
a995 1
			}
d997 1
d1005 3
a1007 4
		(s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) &&
		(s->d1->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&
		(s->session != NULL) && (s->session->cipher != NULL))
		{
d1011 4
a1014 5
			(s->d1->handshake_fragment[2] != 0) ||
			(s->d1->handshake_fragment[3] != 0))
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);
d1016 1
a1016 1
			}
d1021 2
a1022 2
			s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, 
				s->d1->handshake_fragment, 4, s, s->msg_callback_arg);
d1025 2
a1026 3
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&
			!s->s3->renegotiate)
			{
d1030 8
a1037 9
			if (ssl3_renegotiate_check(s))
				{
				i=s->handshake_func(s);
				if (i < 0) return(i);
				if (i == 0)
					{
					SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
					return(-1);
					}
d1039 2
a1040 1
				if (!(s->mode & SSL_MODE_AUTO_RETRY))
a1041 2
					if (s->s3->rbuf.left == 0) /* no read-ahead left? */
						{
d1047 2
a1048 2
						s->rwstate=SSL_READING;
						bio=SSL_get_rbio(s);
d1051 1
a1051 2
						return(-1);
						}
d1055 1
d1059 1
a1059 1
		}
d1061 1
a1061 2
	if (s->d1->alert_fragment_len >= DTLS1_AL_HEADER_LENGTH)
		{
d1068 2
a1069 2
			s->msg_callback(0, s->version, SSL3_RT_ALERT, 
				s->d1->alert_fragment, 2, s, s->msg_callback_arg);
d1072 1
a1072 1
			cb=s->info_callback;
d1074 1
a1074 1
			cb=s->ctx->info_callback;
d1076 1
a1076 2
		if (cb != NULL)
			{
d1079 1
a1079 1
			}
d1082 1
a1082 1
			{
d1084 1
a1084 2
			if (alert_descr == SSL_AD_CLOSE_NOTIFY)
				{
d1091 1
a1091 2
					BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))
					{
d1093 1
a1093 1
					s->rwstate=SSL_READING;
d1097 1
a1097 1
					}
d1100 2
a1101 2
				return(0);
				}
d1103 1
a1103 1
            /* XXX: this is a possible improvement in the future */
d1105 1
a1105 2
			if (alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)
				{
d1114 3
a1116 4
										 dtls1_get_queue_priority(frag->msg_header.seq, 0),
										 frag_off, &found);
				if ( ! found  && SSL_in_init(s))
					{
d1120 2
a1121 3
					ssl3_send_alert(s,SSL3_AL_WARNING,
						DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
					}
d1123 1
d1125 2
a1126 3
			}
		else if (alert_level == 2) /* fatal */
			{
d1129 1
a1129 1
			s->rwstate=SSL_NOTHING;
d1132 2
a1133 2
			BIO_snprintf(tmp,sizeof tmp,"%d",alert_descr);
			ERR_add_error_data(2,"SSL alert number ",tmp);
d1135 5
a1139 7
			SSL_CTX_remove_session(s->ctx,s->session);
			return(0);
			}
		else
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);
d1141 1
a1141 1
			}
d1144 1
a1144 1
		}
d1147 5
a1151 5
		{
		s->rwstate=SSL_NOTHING;
		rr->length=0;
		return(0);
		}
d1153 1
a1153 2
	if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)
		{
d1165 4
a1168 5
		if (	(rr->length != ccs_hdr_len) || 
			(rr->off != 0) || (rr->data[0] != SSL3_MT_CCS))
			{
			i=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);
d1170 1
a1170 1
			}
d1172 1
a1172 1
		rr->length=0;
d1175 2
a1176 2
			s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, 
				rr->data, 1, s, s->msg_callback_arg);
d1181 1
a1181 2
		if (!s->d1->change_cipher_spec_ok)
			{
d1183 1
a1183 1
			}
d1187 1
a1187 1
		s->s3->change_cipher_spec=1;
d1207 1
a1207 1
		}
d1210 2
a1211 3
	if ((s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) && 
		!s->in_handshake)
		{
d1213 1
a1213 1
		
d1216 1
a1216 2
		if( rr->epoch != s->d1->r_epoch)
			{
d1219 1
a1219 1
			}
d1224 1
a1224 2
		if (msg_hdr.type == SSL3_MT_FINISHED)
			{
d1231 1
a1231 1
			}
d1234 1
a1234 2
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))
			{
d1236 1
a1236 1
       * because this is not really needed for clients except for detecting
d1238 2
a1239 3
			s->state=SSL_ST_BEFORE|(s->server)
				?SSL_ST_ACCEPT
				:SSL_ST_CONNECT;
d1243 10
a1252 10
			s->renegotiate=1;
			s->new_session=1;
			}
		i=s->handshake_func(s);
		if (i < 0) return(i);
		if (i == 0)
			{
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
			return(-1);
			}
d1254 2
a1255 1
		if (!(s->mode & SSL_MODE_AUTO_RETRY))
a1256 2
			if (s->s3->rbuf.left == 0) /* no read-ahead left? */
				{
d1262 2
a1263 2
				s->rwstate=SSL_READING;
				bio=SSL_get_rbio(s);
d1266 1
a1266 2
				return(-1);
				}
d1268 1
d1270 1
a1270 1
		}
d1272 1
a1272 2
	switch (rr->type)
		{
d1276 1
a1276 2
		if (s->version == TLS1_VERSION)
			{
d1279 1
a1279 1
			}
d1281 2
a1282 2
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
d1290 2
a1291 2
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_DTLS1_READ_BYTES,ERR_R_INTERNAL_ERROR);
d1302 12
a1313 19
			(s->s3->total_renegotiations != 0) &&
			((
				(s->state & SSL_ST_CONNECT) &&
				(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&
				(s->state <= SSL3_ST_CR_SRVR_HELLO_A)
				) || (
					(s->state & SSL_ST_ACCEPT) &&
					(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&
					(s->state >= SSL3_ST_SR_CLNT_HELLO_A)
					)
				))
			{
			s->s3->in_read_app_data=2;
			return(-1);
			}
		else
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
a1314 1
			}
d1316 1
d1320 1
a1320 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d1322 2
a1323 2
	return(-1);
	}
d1327 1
a1327 1
	{
d1331 7
a1337 6
		/* Check if we have to continue an interrupted handshake
		 * for reading belated app data with SCTP.
		 */
		if ((SSL_in_init(s) && !s->in_handshake) ||
		    (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
		     (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK)))
d1339 1
a1339 1
		if (SSL_in_init(s) && !s->in_handshake)
d1341 6
a1346 6
		{
		i=s->handshake_func(s);
		if (i < 0) return(i);
		if (i == 0)
			{
			SSLerr(SSL_F_DTLS1_WRITE_APP_DATA_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
a1347 1
			}
d1349 1
d1351 4
a1354 5
	if (len > SSL3_RT_MAX_PLAIN_LENGTH)
		{
			SSLerr(SSL_F_DTLS1_WRITE_APP_DATA_BYTES,SSL_R_DTLS_MESSAGE_TOO_BIG);
			return -1;
		}
d1358 1
a1358 1
	}
d1364 4
a1367 4
have_handshake_fragment(SSL *s, int type, unsigned char *buf, 
	int len, int peek)
	{
	
d1370 1
a1370 1
		{
d1373 2
a1374 2
		unsigned int k,n;
		
d1377 1
a1377 2
		while ((len > 0) && (s->d1->handshake_fragment_len > 0))
			{
d1379 2
a1380 1
			len--; s->d1->handshake_fragment_len--;
d1382 1
a1382 1
			}
a1386 3
		}
	
	return 0;
d1389 2
a1390 1

d1396 3
a1398 2
int dtls1_write_bytes(SSL *s, int type, const void *buf, int len)
	{
d1402 2
a1403 2
	s->rwstate=SSL_NOTHING;
	i=do_dtls1_write(s, type, buf, len, 0);
d1405 1
a1405 1
	}
d1407 5
a1411 4
int do_dtls1_write(SSL *s, int type, const unsigned char *buf, unsigned int len, int create_empty_fragment)
	{
	unsigned char *p,*pseq;
	int i,mac_size,clear=0;
d1420 1
a1420 2
	if (s->s3->wbuf.left != 0)
		{
d1422 2
a1423 2
		return(ssl3_write_pending(s,type,buf,len));
		}
d1426 2
a1427 3
	if (s->s3->alert_dispatch)
		{
		i=s->method->ssl_dispatch_alert(s);
d1429 1
a1429 1
			return(i);
d1431 1
a1431 1
		}
d1436 7
a1442 8
	wr= &(s->s3->wrec);
	wb= &(s->s3->wbuf);
	sess=s->session;

	if (	(sess == NULL) ||
		(s->enc_write_ctx == NULL) ||
		(EVP_MD_CTX_md(s->write_hash) == NULL))
		clear=1;
d1445 3
a1447 4
		mac_size=0;
	else
		{
		mac_size=EVP_MD_CTX_size(s->write_hash);
d1450 1
a1450 1
		}
d1455 3
a1457 3
	if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done
	    && SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)
		{
d1462 1
a1462 2
		if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA)
			{
d1471 1
a1471 2
			if (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE)
				{
a1474 1
				}
d1476 2
a1477 1
		
d1479 1
a1479 1
		}
d1485 2
a1486 2
	*(p++)=type&0xff;
	wr->type=type;
d1488 2
a1489 2
	*(p++)=(s->version>>8);
	*(p++)=s->version&0xff;
d1492 3
a1494 2
	pseq=p; 
	p+=10;
d1501 2
a1502 2
	if ( s->enc_write_ctx && 
		(EVP_CIPHER_mode( s->enc_write_ctx->cipher ) & EVP_CIPH_CBC_MODE))
d1507 4
a1510 3
	wr->data=p + bs;  /* make room for IV in case of CBC */
	wr->length=(int)len;
	wr->input=(unsigned char *)buf;
d1516 3
a1518 5
	if (s->compress != NULL)
		{
		if (!ssl3_do_compress(s))
			{
			SSLerr(SSL_F_DO_DTLS1_WRITE,SSL_R_COMPRESSION_FAILURE);
a1519 6
			}
		}
	else
		{
		memcpy(wr->data,wr->input,wr->length);
		wr->input=wr->data;
d1521 4
d1530 2
a1531 3
	if (mac_size != 0)
		{
		if(s->method->ssl3_enc->mac(s,&(p[wr->length + bs]),1) < 0)
d1533 2
a1534 2
		wr->length+=mac_size;
		}
d1537 2
a1538 2
	wr->input=p;
	wr->data=p;
d1543 2
a1544 2
		{
		RAND_pseudo_bytes(p,bs);
d1548 1
a1548 1
		}
d1550 1
a1550 1
	s->method->ssl3_enc->enc(s,1);
d1555 1
a1555 1
	
d1557 1
a1557 1
	
d1562 2
a1563 1
	s2n(s->d1->handshake_epoch, pseq); */
d1566 2
a1567 2
	pseq+=6;
	s2n(wr->length,pseq);
d1573 1
a1573 1
	wr->length+=DTLS1_RT_HEADER_LENGTH;
d1577 3
a1579 3
	if ( type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC)
		dtls1_buffer_record(s, wr->data, wr->length, 
			*((PQ_64BIT *)&(s->s3->write_sequence[0])));
d1584 1
a1584 2
	if (create_empty_fragment)
		{
d1589 1
a1589 1
		}
d1596 4
a1599 4
	s->s3->wpend_tot=len;
	s->s3->wpend_buf=buf;
	s->s3->wpend_type=type;
	s->s3->wpend_ret=len;
d1602 1
a1602 1
	return ssl3_write_pending(s,type,buf,len);
d1605 1
a1605 1
	}
d1609 3
a1611 2
static int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap)
	{
d1616 3
a1618 4
	cmp = satsub64be(seq,bitmap->max_seq_num);
	if (cmp > 0)
		{
		memcpy (s->s3->rrec.seq_num,seq,8);
d1620 1
a1620 1
		}
d1624 1
a1624 1
	else if (bitmap->map & (1UL<<shift))
d1627 1
a1627 1
	memcpy (s->s3->rrec.seq_num,seq,8);
d1629 1
a1629 1
	}
d1632 3
a1634 2
static void dtls1_record_bitmap_update(SSL *s, DTLS1_BITMAP *bitmap)
	{
d1639 2
a1640 3
	cmp = satsub64be(seq,bitmap->max_seq_num);
	if (cmp > 0)
		{
d1646 2
a1647 3
		memcpy(bitmap->max_seq_num,seq,8);
		}
	else	{
d1649 2
a1650 3
		if (shift < sizeof(bitmap->map)*8)
			bitmap->map |= 1UL<<shift;
		}
d1652 1
d1655 5
a1659 4
int dtls1_dispatch_alert(SSL *s)
	{
	int i,j;
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
d1663 1
a1663 1
	s->s3->alert_dispatch=0;
d1670 1
a1670 2
	if (s->s3->send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)
		{	
d1680 1
a1680 1
		fprintf(stderr, "s->d1->handshake_read_seq = %d, s->d1->r_msg_hdr.seq = %d\n",s->d1->handshake_read_seq,s->d1->r_msg_hdr.seq);
d1683 1
a1683 1
		}
d1687 2
a1688 3
	if (i <= 0)
		{
		s->s3->alert_dispatch=1;
d1690 1
a1690 3
		}
	else
		{
d1693 1
a1693 1
		    || s->s3->send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
d1695 2
a1696 2
		    )
			(void)BIO_flush(s->wbio);
d1699 2
a1700 2
			s->msg_callback(1, s->version, SSL3_RT_ALERT, s->s3->send_alert, 
				2, s, s->msg_callback_arg);
d1703 1
a1703 1
			cb=s->info_callback;
d1705 1
a1705 1
			cb=s->ctx->info_callback;
d1707 3
a1709 5
		if (cb != NULL)
			{
			j=(s->s3->send_alert[0]<<8)|s->s3->send_alert[1];
			cb(s,SSL_CB_WRITE_ALERT,j);
			}
a1710 1
	return(i);
d1712 2
d1718 14
a1731 16
    {
    
    *is_next_epoch = 0;

    /* In current epoch, accept HM, CCS, DATA, & ALERT */
    if (rr->epoch == s->d1->r_epoch)
        return &s->d1->bitmap;

    /* Only HM and ALERT messages can be from the next epoch */
    else if (rr->epoch == (unsigned long)(s->d1->r_epoch + 1) &&
        (rr->type == SSL3_RT_HANDSHAKE ||
            rr->type == SSL3_RT_ALERT))
        {
        *is_next_epoch = 1;
        return &s->d1->next_bitmap;
        }
d1733 2
a1734 2
    return NULL;
    }
d1739 2
a1740 2
	unsigned long *offset)
	{
d1743 1
a1743 2
	if ( rr->type == SSL3_RT_APPLICATION_DATA ||
		rr->type == SSL3_RT_ALERT)
d1749 1
a1749 2
	if ( SSL_in_init(s))
		{
d1752 2
a1753 3
		if ( rr->type == SSL3_RT_HANDSHAKE ||
			rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)
			{
d1758 1
a1758 2
			if ( rr->type == SSL3_RT_HANDSHAKE)
				{
d1762 1
a1762 3
				}
			else
				{
d1766 2
a1767 2
				}
				
d1771 1
a1771 1
			if ( seq_num < s->d1->handshake_read_seq)
d1773 3
a1775 3
			if (rr->type == SSL3_RT_HANDSHAKE && 
				seq_num == s->d1->handshake_read_seq &&
				msg_hdr.frag_off < s->d1->r_msg_hdr.frag_off)
d1777 3
a1779 3
			else if ( seq_num == s->d1->handshake_read_seq &&
				(rr->type == SSL3_RT_CHANGE_CIPHER_SPEC ||
					msg_hdr.frag_off == s->d1->r_msg_hdr.frag_off))
d1781 1
a1781 2
			else
				{
a1783 1
				}
d1785 1
d1788 1
a1788 1
		}
d1791 1
a1791 1
	}
d1796 1
a1796 1
	{
d1800 1
a1800 2
	if ( rw & SSL3_CC_READ)
		{
d1805 1
a1805 3
		}
	else
		{
d1809 1
a1809 1
		}
d1812 1
a1812 1
	}
@


1.9
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a117 1
#define USE_SOCKETS
@


1.8
log
@cherry pick bugfixes for http://www.openssl.org/news/secadv_20130205.txt
from the openssl git (changes between openssl 1.0.1c and 1.0.1d).
ok djm@@
@
text
@d458 1
a458 1
			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);
d483 1
a483 1
		if (i < 0 || mac == NULL || timingsafe_bcmp(md, mac, (size_t)mac_size) != 0)
d850 6
d1060 1
@


1.7
log
@resolve conflicts
@
text
@a378 1
	int clear=0;
d382 1
a382 1
	unsigned int mac_size;
a383 3
	int decryption_failed_or_bad_record_mac = 0;
	unsigned char *mac = NULL;

d415 5
a419 1
	if (enc_err <= 0)
d421 4
a424 4
		/* To minimize information leaked via timing, we will always
		 * perform all computations before discarding the message.
		 */
		decryption_failed_or_bad_record_mac = 1;
d434 3
a436 6
	if (	(sess == NULL) ||
		(s->enc_read_ctx == NULL) ||
		(s->read_hash == NULL))
		clear=1;

	if (!clear)
d438 18
a455 7
		/* !clear => s->read_hash != NULL => mac_size != -1 */
		int t;
		t=EVP_MD_CTX_size(s->read_hash);
		OPENSSL_assert(t >= 0);
		mac_size=t;

		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+mac_size)
d457 2
a458 3
#if 0 /* OK only for stream ciphers (then rr->length is visible from ciphertext anyway) */
			al=SSL_AD_RECORD_OVERFLOW;
			SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_PRE_MAC_LENGTH_TOO_LONG);
a459 3
#else
			decryption_failed_or_bad_record_mac = 1;
#endif			
d461 2
a462 2
		/* check the MAC for rr->input (it's in mac_size bytes at the tail) */
		if (rr->length >= mac_size)
d464 7
a471 1
			mac = &rr->data[rr->length];
a473 3
			rr->length = 0;
		i=s->method->ssl3_enc->mac(s,md,0);
		if (i < 0 || mac == NULL || memcmp(md, mac, mac_size) != 0)
d475 5
a479 1
			decryption_failed_or_bad_record_mac = 1;
d481 6
d489 1
a489 1
	if (decryption_failed_or_bad_record_mac)
@


1.6
log
@OpenSSL 1.0.0f: merge
@
text
@a181 1
static void dtls1_clear_timeouts(SSL *s);
d234 8
d386 1
d458 1
a458 1
		if (rr->length < mac_size)
d460 2
a461 7
#if 0 /* OK only for stream ciphers */
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
#else
			decryption_failed_or_bad_record_mac = 1;
#endif
d463 2
a464 1
		rr->length-=mac_size;
d466 1
a466 1
		if (i < 0 || memcmp(md,&(rr->data[rr->length]),mac_size) != 0)
d651 22
a672 14
	/* Check whether this is a repeat, or aged record.
	 * Don't check if we're listening and this message is
	 * a ClientHello. They can look as if they're replayed,
	 * since they arrive from different connections and
	 * would be dropped unnecessarily.
	 */
	if (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&
		*p == SSL3_MT_CLIENT_HELLO) &&
		!dtls1_record_replay_check(s, bitmap))
		{
		rr->length = 0;
		s->packet_length=0; /* dump this record */
		goto again;     /* get another record */
		}
a699 1
	dtls1_clear_timeouts(s);  /* done waiting */
d757 9
d767 1
d798 9
d889 25
d941 13
d1037 1
d1099 15
d1220 9
d1251 3
d1271 1
d1368 10
a1377 1
	if (SSL_in_init(s) && !s->in_handshake)
a1875 7
	}


static void
dtls1_clear_timeouts(SSL *s)
	{
	memset(&(s->d1->timeout), 0x00, sizeof(struct dtls1_timeout_st));
@


1.5
log
@openssl-1.0.0e: resolve conflicts
@
text
@d378 1
d413 4
a416 7
		/* decryption failed, silently discard message */
		if (enc_err < 0)
			{
			rr->length = 0;
			s->packet_length = 0;
			}
		goto err;
d446 1
a446 1
			goto err;
d457 1
a457 1
			goto err;
d464 1
a464 1
			goto err;
d466 8
@


1.4
log
@resolve conflicts, fix local changes
@
text
@a298 3
        DTLS1_RECORD_DATA *rdata;
        rdata = (DTLS1_RECORD_DATA *)item->data;
        
d412 6
a417 5
		if (enc_err == 0)
			/* SSLerr() and ssl3_send_alert() have been called */
			goto err;

		/* otherwise enc_err == -1 */
a528 1
	SSL_SESSION *sess;
a534 1
	sess=s->session;
d661 3
a663 1
	 * cannot be processed at this time. */
d666 1
a666 1
		if (SSL_in_init(s) || s->in_handshake)
@


1.3
log
@resolve conflicts
@
text
@d125 44
d171 1
a171 2
static int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap,
	PQ_64BIT *seq_num);
d180 1
a180 1
	PQ_64BIT priority);
a181 3
#if PQ_64BIT_IS_INTEGER
static PQ_64BIT bytes_to_long_long(unsigned char *bytes, PQ_64BIT *num);
#endif
d199 3
d208 3
a210 3
dtls1_buffer_record(SSL *s, record_pqueue *queue, PQ_64BIT priority)
{
    DTLS1_RECORD_DATA *rdata;
d213 4
d257 1
a257 1
    }
d374 1
a374 1
    int i,al;
d376 1
a376 1
    int enc_err;
d378 1
a378 1
    SSL3_RECORD *rr;
d384 1
a384 1
    sess = s->session;
d420 1
a420 1
		goto decryption_failed_or_bad_record_mac;
d430 1
a430 1
if (	(sess == NULL) ||
d433 1
a433 1
    clear=1;
d437 5
a441 1
		mac_size=EVP_MD_size(s->read_hash);
d450 1
a450 1
			goto decryption_failed_or_bad_record_mac;
d461 1
a461 1
			goto decryption_failed_or_bad_record_mac;
d466 1
a466 1
		if (memcmp(md,&(rr->data[rr->length]),mac_size) != 0)
d468 1
a468 1
			goto decryption_failed_or_bad_record_mac;
d507 2
a508 2
    dtls1_record_bitmap_update(s, &(s->d1->bitmap));/* Mark receipt of record. */
    return(1);
a509 8
decryption_failed_or_bad_record_mac:
	/* Separate 'decryption_failed' alert was introduced with TLS 1.0,
	 * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption
	 * failure is directly visible from the ciphertext anyway,
	 * we should not reveal which kind of error occured -- this
	 * might become visible to an attacker (e.g. via logfile) */
	al=SSL_AD_BAD_RECORD_MAC;
	SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
d528 1
a528 1
	int ssl_major,ssl_minor,al;
d532 1
a532 1
	unsigned char *p;
d540 3
a542 4
    /* The epoch may have changed.  If so, process all the
     * pending records.  This is a non-blocking operation. */
    if ( ! dtls1_process_buffered_records(s))
        return 0;
d558 6
a563 1
		OPENSSL_assert(s->packet_length == DTLS1_RT_HEADER_LENGTH);
d586 1
a586 1
			if (version != s->version && version != DTLS1_BAD_VER)
d588 4
a591 6
				SSLerr(SSL_F_DTLS1_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);
				/* Send back error using their
				 * version number :-) */
				s->version=version;
				al=SSL_AD_PROTOCOL_VERSION;
				goto f_err;
d595 1
a595 2
		if ((version & 0xff00) != (DTLS1_VERSION & 0xff00) &&
		    (version & 0xff00) != (DTLS1_BAD_VER & 0xff00))
d597 4
a600 2
			SSLerr(SSL_F_DTLS1_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);
			goto err;
d605 4
a608 3
			al=SSL_AD_RECORD_OVERFLOW;
			SSLerr(SSL_F_DTLS1_GET_RECORD,SSL_R_PACKET_LENGTH_TOO_LONG);
			goto f_err;
a610 1
		s->client_version = version;
d626 1
d639 4
a642 3
        {
        s->packet_length = 0;  /* dump this record */
        goto again;   /* get another record */
d645 9
a653 2
	/* check whether this is a repeat, or aged record */
	if ( ! dtls1_record_replay_check(s, bitmap, &(rr->seq_num)))
d663 13
a675 11
    /* If this record is from the next epoch (either HM or ALERT), buffer it
     * since it cannot be processed at this time.
     * Records from the next epoch are marked as received even though they are 
     * not processed, so as to prevent any potential resource DoS attack */
    if (is_next_epoch)
        {
        dtls1_record_bitmap_update(s, bitmap);
        dtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);
        s->packet_length = 0;
        goto again;
        }
d677 6
a682 2
    if ( ! dtls1_process_record(s))
        return(0);
a686 4
f_err:
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
err:
	return(0);
d763 21
d805 8
a812 3
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);
		goto err;
d882 16
a897 8
                /* else it's a CCS message, or it's wrong */
                else if (rr->type != SSL3_RT_CHANGE_CIPHER_SPEC)
                        {
                          /* Not certain if this is the right error handling */
                          al=SSL_AD_UNEXPECTED_MESSAGE;
                          SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
                          goto f_err;
                        }
d899 5
d1041 3
a1043 1
				dtls1_retransmit_message(s, seq, frag_off, &found);
d1088 1
d1092 3
d1098 1
a1098 2
		if (	(s->client_version == DTLS1_BAD_VER && rr->length != 3) ||
			(s->client_version != DTLS1_BAD_VER && rr->length != DTLS1_CCS_HEADER_LENGTH) || 
d1112 10
d1129 1
a1129 1
		if (s->client_version == DTLS1_BAD_VER)
d1149 10
a1264 1
	unsigned int n,tot;
d1278 1
a1278 4
	tot = s->s3->wnum;
	n = len - tot;

	while( n)
d1280 2
a1281 17
		/* dtls1_write_bytes sends one record at a time, sized according to 
		 * the currently known MTU */
		i = dtls1_write_bytes(s, type, buf_, len);
		if (i <= 0) return i;
		
		if ((i == (int)n) ||
			(type == SSL3_RT_APPLICATION_DATA &&
				(s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE)))
			{
			/* next chunk of data should get another prepended empty fragment
			 * in ciphersuites with known-IV weakness: */
			s->s3->empty_fragment_done = 0;
			return tot+i;
			}

		tot += i;
		n-=i;
d1284 2
a1285 1
	return tot;
d1326 1
a1326 1
int dtls1_write_bytes(SSL *s, int type, const void *buf_, int len)
a1327 2
	const unsigned char *buf=buf_;
	unsigned int tot,n,nw;
a1328 1
	unsigned int mtu;
d1330 1
d1332 1
a1332 32
	tot=s->s3->wnum;

	n=(len-tot);

	/* handshake layer figures out MTU for itself, but data records
	 * are also sent through this interface, so need to figure out MTU */
#if 0
	mtu = BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_GET_MTU, 0, NULL);
	mtu += DTLS1_HM_HEADER_LENGTH;  /* HM already inserted */
#endif
	mtu = s->d1->mtu;

	if (mtu > SSL3_RT_MAX_PLAIN_LENGTH)
		mtu = SSL3_RT_MAX_PLAIN_LENGTH;

	if (n > mtu)
		nw=mtu;
	else
		nw=n;
	
	i=do_dtls1_write(s, type, &(buf[tot]), nw, 0);
	if (i <= 0)
		{
		s->s3->wnum=tot;
		return i;
		}

	if ( (int)s->s3->wnum + i == len)
		s->s3->wnum = 0;
	else 
		s->s3->wnum += i;

d1372 1
a1372 1
		(s->write_hash == NULL))
d1378 5
a1382 1
		mac_size=EVP_MD_size(s->write_hash);
d1388 1
a1388 1
		&& SSL_version(s) != DTLS1_VERSION)
a1414 1

d1422 2
a1423 6
	if (s->client_version == DTLS1_BAD_VER)
		*(p++) = DTLS1_BAD_VER>>8,
		*(p++) = DTLS1_BAD_VER&0xff;
	else
		*(p++)=(s->version>>8),
		*(p++)=s->version&0xff;
d1468 2
a1469 1
		s->method->ssl3_enc->mac(s,&(p[wr->length + bs]),1);
d1546 1
a1546 2
static int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap,
	PQ_64BIT *seq_num)
d1548 3
a1550 10
#if PQ_64BIT_IS_INTEGER
	PQ_64BIT mask = 0x0000000000000001L;
#endif
	PQ_64BIT rcd_num, tmp;

	pq_64bit_init(&rcd_num);
	pq_64bit_init(&tmp);

	/* this is the sequence number for the record just read */
	pq_64bit_bin2num(&rcd_num, s->s3->read_sequence, 8);
d1552 2
a1553 3
	
	if (pq_64bit_gt(&rcd_num, &(bitmap->max_seq_num)) ||
		pq_64bit_eq(&rcd_num, &(bitmap->max_seq_num)))
d1555 2
a1556 13
		pq_64bit_assign(seq_num, &rcd_num);
		pq_64bit_free(&rcd_num);
		pq_64bit_free(&tmp);
		return 1;  /* this record is new */
		}

	pq_64bit_sub(&tmp, &(bitmap->max_seq_num), &rcd_num);

	if ( pq_64bit_get_word(&tmp) > bitmap->length)
		{
		pq_64bit_free(&rcd_num);
		pq_64bit_free(&tmp);
		return 0;  /* stale, outside the window */
d1558 5
d1564 1
a1564 22
#if PQ_64BIT_IS_BIGNUM
	{
	int offset;
	pq_64bit_sub(&tmp, &(bitmap->max_seq_num), &rcd_num);
	pq_64bit_sub_word(&tmp, 1);
	offset = pq_64bit_get_word(&tmp);
	if ( pq_64bit_is_bit_set(&(bitmap->map), offset))
		{
		pq_64bit_free(&rcd_num);
		pq_64bit_free(&tmp);
		return 0;
		}
	}
#else
	mask <<= (bitmap->max_seq_num - rcd_num - 1);
	if (bitmap->map & mask)
		return 0; /* record previously received */
#endif
	
	pq_64bit_assign(seq_num, &rcd_num);
	pq_64bit_free(&rcd_num);
	pq_64bit_free(&tmp);
d1571 1
d1573 1
a1573 3
	PQ_64BIT rcd_num;
	PQ_64BIT tmp;
	PQ_64BIT_CTX *ctx;
d1575 2
a1576 9
	pq_64bit_init(&rcd_num);
	pq_64bit_init(&tmp);

	pq_64bit_bin2num(&rcd_num, s->s3->read_sequence, 8);

	/* unfortunate code complexity due to 64-bit manipulation support
	 * on 32-bit machines */
	if ( pq_64bit_gt(&rcd_num, &(bitmap->max_seq_num)) ||
		pq_64bit_eq(&rcd_num, &(bitmap->max_seq_num)))
d1578 6
a1583 17
		pq_64bit_sub(&tmp, &rcd_num, &(bitmap->max_seq_num));
		pq_64bit_add_word(&tmp, 1);

		shift = (unsigned int)pq_64bit_get_word(&tmp);

		pq_64bit_lshift(&(tmp), &(bitmap->map), shift);
		pq_64bit_assign(&(bitmap->map), &tmp);

		pq_64bit_set_bit(&(bitmap->map), 0);
		pq_64bit_add_word(&rcd_num, 1);
		pq_64bit_assign(&(bitmap->max_seq_num), &rcd_num);

		pq_64bit_assign_word(&tmp, 1);
		pq_64bit_lshift(&tmp, &tmp, bitmap->length);
		ctx = pq_64bit_ctx_new(&ctx);
		pq_64bit_mod(&(bitmap->map), &(bitmap->map), &tmp, ctx);
		pq_64bit_ctx_free(ctx);
d1585 4
a1588 7
	else
		{
		pq_64bit_sub(&tmp, &(bitmap->max_seq_num), &rcd_num);
		pq_64bit_sub_word(&tmp, 1);
		shift = (unsigned int)pq_64bit_get_word(&tmp);

		pq_64bit_set_bit(&(bitmap->map), shift);
a1589 3

	pq_64bit_free(&rcd_num);
	pq_64bit_free(&tmp);
d1636 1
a1636 1
		   )
d1755 1
a1755 8

		pq_64bit_assign(&(s->d1->bitmap.map), &(s->d1->next_bitmap.map));
		s->d1->bitmap.length = s->d1->next_bitmap.length;
		pq_64bit_assign(&(s->d1->bitmap.max_seq_num), 
			&(s->d1->next_bitmap.max_seq_num));

		pq_64bit_free(&(s->d1->next_bitmap.map));
		pq_64bit_free(&(s->d1->next_bitmap.max_seq_num));
a1756 2
		pq_64bit_init(&(s->d1->next_bitmap.map));
		pq_64bit_init(&(s->d1->next_bitmap.max_seq_num));
d1761 1
a1766 20

#if PQ_64BIT_IS_INTEGER
static PQ_64BIT
bytes_to_long_long(unsigned char *bytes, PQ_64BIT *num)
       {
       PQ_64BIT _num;

       _num = (((PQ_64BIT)bytes[0]) << 56) |
               (((PQ_64BIT)bytes[1]) << 48) |
               (((PQ_64BIT)bytes[2]) << 40) |
               (((PQ_64BIT)bytes[3]) << 32) |
               (((PQ_64BIT)bytes[4]) << 24) |
               (((PQ_64BIT)bytes[5]) << 16) |
               (((PQ_64BIT)bytes[6]) <<  8) |
               (((PQ_64BIT)bytes[7])      );

	   *num = _num ;
       return _num;
       }
#endif
@


1.2
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d600 1
@


1.1
log
@Initial revision
@
text
@d814 8
d1262 1
a1262 1
	return tot + i;
d1587 1
a1587 1
	unsigned char buf[2 + 2 + 3]; /* alert level + alert desc + message seq +frag_off */
d1596 1
d1612 1
d1622 5
a1626 2
		if ( s->s3->send_alert[0] == SSL3_AL_FATAL ||
			s->s3->send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@a599 1
		rr->length = 0;
a813 8
#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
				/*
				 * for normal alerts rr->length is 2, while
				 * dest_maxlen is 7 if we were to handle this
				 * non-existing alert...
				 */
				FIX ME
#endif
d1254 1
a1254 1
	return i;
d1579 1
a1579 1
	unsigned char buf[DTLS1_AL_HEADER_LENGTH];
a1587 1
#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
a1602 1
#endif
d1612 2
a1613 5
		if (s->s3->send_alert[0] == SSL3_AL_FATAL
#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
		    || s->s3->send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
#endif
		   )
@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@a124 44
/* mod 128 saturating subtract of two 64-bit values in big-endian order */
static int satsub64be(const unsigned char *v1,const unsigned char *v2)
{	int ret,sat,brw,i;

	if (sizeof(long) == 8) do
	{	const union { long one; char little; } is_endian = {1};
		long l;

		if (is_endian.little)			break;
		/* not reached on little-endians */
		/* following test is redundant, because input is
		 * always aligned, but I take no chances... */
		if (((size_t)v1|(size_t)v2)&0x7)	break;

		l  = *((long *)v1);
		l -= *((long *)v2);
		if (l>128)		return 128;
		else if (l<-128)	return -128;
		else			return (int)l;
	} while (0);

	ret = (int)v1[7]-(int)v2[7];
	sat = 0;
	brw = ret>>8;	/* brw is either 0 or -1 */
	if (ret & 0x80)
	{	for (i=6;i>=0;i--)
		{	brw += (int)v1[i]-(int)v2[i];
			sat |= ~brw;
			brw >>= 8;
		}
	}
	else
	{	for (i=6;i>=0;i--)
		{	brw += (int)v1[i]-(int)v2[i];
			sat |= brw;
			brw >>= 8;
		}
	}
	brw <<= 8;	/* brw is either 0 or -256 */

	if (sat&0xff)	return brw | 0x80;
	else		return brw + (ret&0xFF);
}

d127 2
a128 1
static int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap);
d137 1
a137 1
	unsigned char *priority);
d139 3
a158 3
	
	/* Set proper sequence number for mac calculation */
	memcpy(&(s->s3->read_sequence[2]), &(rdata->packet[5]), 6);
d165 3
a167 3
dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)
	{
	DTLS1_RECORD_DATA *rdata;
a169 4
	/* Limit the size of the queue to prevent DOS attacks */
	if (pqueue_size(queue->q) >= 100)
		return 0;
		
d210 1
a210 1
	}
d327 1
a327 1
	int i,al;
d329 1
a329 1
	int enc_err;
d331 1
a331 1
	SSL3_RECORD *rr;
d337 1
a337 1
	sess = s->session;
d373 1
a373 1
		goto err;
d383 1
a383 1
	if (	(sess == NULL) ||
d386 1
a386 1
		clear=1;
d390 1
a390 5
		/* !clear => s->read_hash != NULL => mac_size != -1 */
		int t;
		t=EVP_MD_CTX_size(s->read_hash);
		OPENSSL_assert(t >= 0);
		mac_size=t;
d399 1
a399 1
			goto err;
d410 1
a410 1
			goto err;
d415 1
a415 1
		if (i < 0 || memcmp(md,&(rr->data[rr->length]),mac_size) != 0)
d417 1
a417 1
			goto err;
d456 2
a457 2
	dtls1_record_bitmap_update(s, &(s->d1->bitmap));/* Mark receipt of record. */
	return(1);
d459 8
d485 1
a485 1
	int ssl_major,ssl_minor;
d489 1
a489 1
	unsigned char *p = NULL;
d497 4
a500 3
	/* The epoch may have changed.  If so, process all the
	 * pending records.  This is a non-blocking operation. */
	dtls1_process_buffered_records(s);
d516 1
a516 6
		/* this packet contained a partial record, dump it */
		if (s->packet_length != DTLS1_RT_HEADER_LENGTH)
			{
			s->packet_length = 0;
			goto again;
			}
d539 1
a539 1
			if (version != s->version)
d541 6
a546 4
				/* unexpected version, silently discard */
				rr->length = 0;
				s->packet_length = 0;
				goto again;
d550 2
a551 1
		if ((version & 0xff00) != (s->version & 0xff00))
d553 2
a554 4
			/* wrong version, silently discard record */
			rr->length = 0;
			s->packet_length = 0;
			goto again;
d559 3
a561 4
			/* record too long, silently discard it */
			rr->length = 0;
			s->packet_length = 0;
			goto again;
d564 1
a579 1
			rr->length = 0;
d592 3
a594 4
		{
		rr->length = 0;
		s->packet_length = 0;  /* dump this record */
		goto again;   /* get another record */
d597 2
a598 9
	/* Check whether this is a repeat, or aged record.
	 * Don't check if we're listening and this message is
	 * a ClientHello. They can look as if they're replayed,
	 * since they arrive from different connections and
	 * would be dropped unnecessarily.
	 */
	if (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&
		*p == SSL3_MT_CLIENT_HELLO) &&
		!dtls1_record_replay_check(s, bitmap))
d608 11
a618 13
	/* If this record is from the next epoch (either HM or ALERT),
	 * and a handshake is currently in progress, buffer it since it
	 * cannot be processed at this time. */
	if (is_next_epoch)
		{
		if (SSL_in_init(s) || s->in_handshake)
			{
			dtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);
			}
		rr->length = 0;
		s->packet_length = 0;
		goto again;
		}
d620 2
a621 6
	if (!dtls1_process_record(s))
		{
		rr->length = 0;
		s->packet_length = 0;  /* dump this record */
		goto again;   /* get another record */
		}
d626 4
a705 21
	/* We are not handshaking and have no data yet,
	 * so process data buffered during the last handshake
	 * in advance, if any.
	 */
	if (s->state == SSL_ST_OK && rr->length == 0)
		{
		pitem *item;
		item = pqueue_pop(s->d1->buffered_app_data.q);
		if (item)
			{
			dtls1_copy_record(s, item);

			OPENSSL_free(item->data);
			pitem_free(item);
			}
		}

	/* Check for timeout */
	if (dtls1_handle_timeout(s) > 0)
		goto start;

d727 3
a729 8
		/* We now have application data between CCS and Finished.
		 * Most likely the packets were reordered on their way, so
		 * buffer the application data for later processing rather
		 * than dropping the connection.
		 */
		dtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num);
		rr->length = 0;
		goto start;
d799 8
a806 16
		/* else it's a CCS message, or application data or wrong */
		else if (rr->type != SSL3_RT_CHANGE_CIPHER_SPEC)
			{
			/* Application data while renegotiating
			 * is allowed. Try again reading.
			 */
			if (rr->type == SSL3_RT_APPLICATION_DATA)
				{
				BIO *bio;
				s->s3->in_read_app_data=2;
				bio=SSL_get_rbio(s);
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(bio);
				BIO_set_retry_read(bio);
				return(-1);
				}
a807 5
			/* Not certain if this is the right error handling */
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
			goto f_err;
			}
d945 1
a945 3
				dtls1_retransmit_message(s,
										 dtls1_get_queue_priority(frag->msg_header.seq, 0),
										 frag_off, &found);
a989 1
		unsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH;
a992 3
		if (s->version == DTLS1_BAD_VER)
			ccs_hdr_len = 3;

d996 2
a997 1
		if (	(rr->length != ccs_hdr_len) || 
a1010 10
		/* We can't process a CCS now, because previous handshake
		 * messages are still missing, so just drop it.
		 */
		if (!s->d1->change_cipher_spec_ok)
			{
			goto start;
			}

		s->d1->change_cipher_spec_ok = 0;

d1018 1
a1018 1
		if (s->version == DTLS1_BAD_VER)
a1037 10
		/* If we are server, we may have a repeated FINISHED of the
		 * client here, then retransmit our CCS and FINISHED.
		 */
		if (msg_hdr.type == SSL3_MT_FINISHED)
			{
			dtls1_retransmit_buffered_messages(s);
			rr->length = 0;
			goto start;
			}

d1144 1
d1158 4
a1161 1
	if (len > SSL3_RT_MAX_PLAIN_LENGTH)
d1163 17
a1179 2
			SSLerr(SSL_F_DTLS1_WRITE_APP_DATA_BYTES,SSL_R_DTLS_MESSAGE_TOO_BIG);
			return -1;
d1182 1
a1182 2
	i = dtls1_write_bytes(s, type, buf_, len);
	return i;
d1223 1
a1223 1
int dtls1_write_bytes(SSL *s, int type, const void *buf, int len)
d1225 2
d1228 1
a1229 1
	OPENSSL_assert(len <= SSL3_RT_MAX_PLAIN_LENGTH);
d1231 32
a1262 1
	i=do_dtls1_write(s, type, buf, len, 0);
d1302 1
a1302 1
		(EVP_MD_CTX_md(s->write_hash) == NULL))
d1308 1
a1308 5
		{
		mac_size=EVP_MD_CTX_size(s->write_hash);
		if (mac_size < 0)
			goto err;
		}
d1314 1
a1314 1
	    && SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)
d1341 1
d1349 6
a1354 2
	*(p++)=(s->version>>8);
	*(p++)=s->version&0xff;
d1399 1
a1399 2
		if(s->method->ssl3_enc->mac(s,&(p[wr->length + bs]),1) < 0)
			goto err;
d1476 2
a1477 1
static int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap)
d1479 29
a1507 3
	int cmp;
	unsigned int shift;
	const unsigned char *seq = s->s3->read_sequence;
d1509 7
a1515 2
	cmp = satsub64be(seq,bitmap->max_seq_num);
	if (cmp > 0)
d1517 3
a1519 2
		memcpy (s->s3->rrec.seq_num,seq,8);
		return 1; /* this record in new */
d1521 4
a1524 4
	shift = -cmp;
	if (shift >= sizeof(bitmap->map)*8)
		return 0; /* stale, outside the window */
	else if (bitmap->map & (1UL<<shift))
d1526 5
a1530 2

	memcpy (s->s3->rrec.seq_num,seq,8);
a1536 1
	int cmp;
d1538 3
a1540 1
	const unsigned char *seq = s->s3->read_sequence;
d1542 9
a1550 2
	cmp = satsub64be(seq,bitmap->max_seq_num);
	if (cmp > 0)
d1552 17
a1568 6
		shift = cmp;
		if (shift < sizeof(bitmap->map)*8)
			bitmap->map <<= shift, bitmap->map |= 1UL;
		else
			bitmap->map = 1UL;
		memcpy(bitmap->max_seq_num,seq,8);
d1570 7
a1576 4
	else	{
		shift = -cmp;
		if (shift < sizeof(bitmap->map)*8)
			bitmap->map |= 1UL<<shift;
d1578 3
d1627 1
a1627 1
		    )
d1746 8
a1753 1
		memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP));
d1755 2
a1760 1
		memcpy(s->d1->last_write_sequence, seq, sizeof(s->s3->write_sequence));
d1766 20
@


1.1.1.4
log
@import OpenSSL 1.0.0e
@
text
@d299 3
d415 5
a419 6
		/* decryption failed, silently discard message */
		if (enc_err < 0)
			{
			rr->length = 0;
			s->packet_length = 0;
			}
d531 1
d538 1
d665 1
a665 3
	 * cannot be processed at this time. However, do not buffer
	 * anything while listening.
	 */
d668 1
a668 1
		if ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)
@


1.1.1.5
log
@OpenSSL 1.0.0f: import upstream source
@
text
@a377 1
	int decryption_failed_or_bad_record_mac = 0;
d412 7
a418 4
		/* To minimize information leaked via timing, we will always
		 * perform all computations before discarding the message.
		 */
		decryption_failed_or_bad_record_mac = 1;
d448 1
a448 1
			decryption_failed_or_bad_record_mac = 1;
d459 1
a459 1
			decryption_failed_or_bad_record_mac = 1;
d466 1
a466 1
			decryption_failed_or_bad_record_mac = 1;
a467 8
		}

	if (decryption_failed_or_bad_record_mac)
		{
		/* decryption failed, silently discard message */
		rr->length = 0;
		s->packet_length = 0;
		goto err;
@


1.1.1.6
log
@import OpenSSL-1.0.1c
@
text
@d182 1
a234 8
#ifndef OPENSSL_NO_SCTP
	/* Store bio_dgram_sctp_rcvinfo struct */
	if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
	    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {
		BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);
	}
#endif

a378 1
	unsigned char *mac = NULL;
d450 1
a450 1
		if (rr->length >= mac_size)
d452 7
a458 2
			rr->length -= mac_size;
			mac = &rr->data[rr->length];
d460 1
a460 2
		else
			rr->length = 0;
d462 1
a462 1
		if (i < 0 || mac == NULL || memcmp(md, mac, mac_size) != 0)
d647 14
a660 22
#ifndef OPENSSL_NO_SCTP
	/* Only do replay check if no SCTP bio */
	if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))
  		{
#endif
		/* Check whether this is a repeat, or aged record.
		 * Don't check if we're listening and this message is
		 * a ClientHello. They can look as if they're replayed,
		 * since they arrive from different connections and
		 * would be dropped unnecessarily.
		 */
		if (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&
		    *p == SSL3_MT_CLIENT_HELLO) &&
		    !dtls1_record_replay_check(s, bitmap))
			{
			rr->length = 0;
			s->packet_length=0; /* dump this record */
			goto again;     /* get another record */
			}
#ifndef OPENSSL_NO_SCTP
  		}
#endif
d688 1
a745 9
#ifndef OPENSSL_NO_SCTP
	/* Continue handshake if it had to be interrupted to read
	 * app data with SCTP.
	 */
	if ((!s->in_handshake && SSL_in_init(s)) ||
	    (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
	     (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK) &&
	     s->s3->in_read_app_data != 2))
#else
a746 1
#endif
a776 9
#ifndef OPENSSL_NO_SCTP
			/* Restore bio_dgram_sctp_rcvinfo struct */
			if (BIO_dgram_is_sctp(SSL_get_rbio(s)))
				{
				DTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *) item->data;
				BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);
				}
#endif

a858 25

#ifndef OPENSSL_NO_SCTP
			/* We were about to renegotiate but had to read
			 * belated application data first, so retry.
			 */
			if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
			    rr->type == SSL3_RT_APPLICATION_DATA &&
			    (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK))
				{
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				}

			/* We might had to delay a close_notify alert because
			 * of reordered app data. If there was an alert and there
			 * is no message to read anymore, finally set shutdown.
			 */
			if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
			    s->d1->shutdown_received && !BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))
				{
				s->shutdown |= SSL_RECEIVED_SHUTDOWN;
				return(0);
				}
#endif			
a885 13
#ifndef OPENSSL_NO_HEARTBEATS
		else if (rr->type == TLS1_RT_HEARTBEAT)
			{
			dtls1_process_heartbeat(s);

			/* Exit and notify application to read again */
			rr->length = 0;
			s->rwstate=SSL_READING;
			BIO_clear_retry_flags(SSL_get_rbio(s));
			BIO_set_retry_read(SSL_get_rbio(s));
			return(-1);
			}
#endif
a968 1
			s->new_session = 1;
a1029 15
#ifndef OPENSSL_NO_SCTP
				/* With SCTP and streams the socket may deliver app data
				 * after a close_notify alert. We have to check this
				 * first so that nothing gets discarded.
				 */
				if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
					BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))
					{
					s->d1->shutdown_received = 1;
					s->rwstate=SSL_READING;
					BIO_clear_retry_flags(SSL_get_rbio(s));
					BIO_set_retry_read(SSL_get_rbio(s));
					return -1;
					}
#endif
a1135 9
#ifndef OPENSSL_NO_SCTP
		/* Remember that a CCS has been received,
		 * so that an old key of SCTP-Auth can be
		 * deleted when a CCS is sent. Will be ignored
		 * if no SCTP is used
		 */
		BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD, 1, NULL);
#endif

a1157 3
			if (dtls1_check_timeout_num(s) < 0)
				return -1;

a1174 1
			s->renegotiate=1;
d1271 1
a1271 10
#ifndef OPENSSL_NO_SCTP
		/* Check if we have to continue an interrupted handshake
		 * for reading belated app data with SCTP.
		 */
		if ((SSL_in_init(s) && !s->in_handshake) ||
		    (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
		     (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK)))
#else
		if (SSL_in_init(s) && !s->in_handshake)
#endif
d1770 7
@


1.1.1.7
log
@Import OpenSSL 1.0.1g
@
text
@d379 1
d383 1
a383 1
	unsigned int mac_size, orig_len;
d385 3
d419 1
a419 5
	/* enc_err is:
	 *    0: (in non-constant time) if the record is publically invalid.
	 *    1: if the padding is valid
	 *    -1: if the padding is invalid */
	if (enc_err == 0)
d421 4
a424 4
		/* For DTLS we simply ignore bad packets. */
		rr->length = 0;
		s->packet_length = 0;
		goto err;
d434 14
a447 22
	if ((sess != NULL) &&
	    (s->enc_read_ctx != NULL) &&
	    (EVP_MD_CTX_md(s->read_hash) != NULL))
		{
		/* s->read_hash != NULL => mac_size != -1 */
		unsigned char *mac = NULL;
		unsigned char mac_tmp[EVP_MAX_MD_SIZE];
		mac_size=EVP_MD_CTX_size(s->read_hash);
		OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);

		/* kludge: *_cbc_remove_padding passes padding length in rr->type */
		orig_len = rr->length+((unsigned int)rr->type>>8);

		/* orig_len is the length of the record before any padding was
		 * removed. This is public information, as is the MAC in use,
		 * therefore we can safely process the record in a different
		 * amount of time if it's too short to possibly contain a MAC.
		 */
		if (orig_len < mac_size ||
		    /* CBC records must have a padding length byte too. */
		    (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
		     orig_len < mac_size+1))
d449 3
a451 2
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_LENGTH_TOO_SHORT);
d453 3
d457 2
a458 2

		if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE)
a459 7
			/* We update the length so that the TLS header bytes
			 * can be constructed correctly but we need to extract
			 * the MAC in constant time from within the record,
			 * without leaking the contents of the padding bytes.
			 * */
			mac = mac_tmp;
			ssl3_cbc_copy_mac(mac_tmp, rr, mac_size, orig_len);
d461 1
d464 3
d468 1
a468 5
			/* In this case there's no padding, so |orig_len|
			 * equals |rec->length| and we checked that there's
			 * enough bytes for |mac_size| above. */
			rr->length -= mac_size;
			mac = &rr->data[rr->length];
a469 6

		i=s->method->ssl3_enc->mac(s,md,0 /* not send */);
		if (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
			enc_err = -1;
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+mac_size)
			enc_err = -1;
d472 1
a472 1
	if (enc_err < 0)
a832 6
	if (s->d1->listen && rr->type != SSL3_RT_HANDSHAKE)
		{
		rr->length = 0;
		goto start;
		}

a1036 1
			s->d1->handshake_read_seq++;
@


