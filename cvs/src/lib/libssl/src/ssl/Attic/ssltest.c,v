head	1.38;
access;
symbols
	butholakala:1.20
	openssl_1_0_1_g:1.1.1.14
	OPENBSD_5_5:1.19.0.8
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	openssl_1_0_1_c:1.1.1.13
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	openssl_1_0_0_f:1.1.1.12
	openssl_1_0_0_e:1.1.1.12
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	openssh_1_0_0_a:1.1.1.11
	OPENBSD_4_8:1.16.0.8
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	openssl_0_9_8_k:1.1.1.10
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	openssl_0_9_8_j:1.1.1.10
	openssl_0_9_8_h:1.1.1.9
	pre_openssl_0_9_8h:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	openssl_0_9_7j:1.1.1.8
	openssl:1.1.1
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENSSL_0_9_7G:1.1.1.7
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENSSL_0_9_7D:1.1.1.6
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENSSL_0_9_7C:1.1.1.5
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2014.05.24.14.56.32;	author jsing;	state dead;
branches;
next	1.37;

1.37
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.18.17.44.24;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.17.21.41.12;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.17.13.37.50;	author beck;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.17.10.24.08;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.16.20.39.09;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.16.17.59.17;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.15.21.47.56;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.15.19.42.56;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.14.18.53.14;	author beck;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.14.17.22.37;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.13.23.05.18;	author beck;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.13.22.11.45;	author beck;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.13.20.37.12;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.06.12.17.54;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches
	1.13.8.1
	1.13.10.1;
next	1.12;

1.12
date	2005.04.29.05.39.32;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.08.08.03.15;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.22.21.39.38;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.01.23.55.02;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.14.11.18.04;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.58.41;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.50;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.35;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.31;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.14;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.14;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.44;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.12.20.53.10;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.48;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.21.35;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.42.07;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.37.29;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2011.11.03.02.32.21;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2012.10.13.21.23.50;	author djm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.13.8.1
date	2009.01.09.11.40.50;	author djm;	state Exp;
branches;
next	;

1.13.10.1
date	2009.01.09.11.40.35;	author djm;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Move ssltest.c to a regress test.
@
text
@/* ssl/ssltest.c */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#define _BSD_SOURCE 1		/* Or gethostname won't be declared properly
				   on Linux and GNU platforms. */
#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <assert.h>
#include <errno.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include <ctype.h>

#include <openssl/opensslconf.h>
#include <openssl/e_os2.h>
#include <openssl/bio.h>
#include <openssl/crypto.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/ssl.h>
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/rsa.h>
#include <openssl/dsa.h>
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
#include <openssl/bn.h>

#define _XOPEN_SOURCE_EXTENDED	1
/* Or gethostname won't be declared properly
   on Compaq platforms (at least with DEC C).
   Do not try to put it earlier, or IPv6 includes
   get screwed... */


#  define TEST_SERVER_CERT "../apps/server.pem"
#  define TEST_CLIENT_CERT "../apps/client.pem"

/* There is really no standard for this, so let's assign some tentative
   numbers.  In any case, these numbers are only for this test */
#define COMP_RLE	255
#define COMP_ZLIB	1

static int verify_callback(int ok, X509_STORE_CTX *ctx);
static RSA *tmp_rsa_cb(SSL *s, int is_export, int keylength);
static void free_tmp_rsa(void);
static int app_verify_callback(X509_STORE_CTX *ctx, void *arg);
#define APP_CALLBACK_STRING "Test Callback Argument"
struct app_verify_arg {
	char *string;
	int app_verify;
	int allow_proxy_certs;
	char *proxy_auth;
	char *proxy_cond;
};

#ifndef OPENSSL_NO_DH
static DH *get_dh512(void);
static DH *get_dh1024(void);
static DH *get_dh1024dsa(void);
#endif


static char *psk_key = NULL; /* by default PSK is not used */
#ifndef OPENSSL_NO_PSK
static unsigned int psk_client_callback(SSL *ssl, const char *hint,
    char *identity, unsigned int max_identity_len, unsigned char *psk,
    unsigned int max_psk_len);
static unsigned int psk_server_callback(SSL *ssl, const char *identity,
    unsigned char *psk, unsigned int max_psk_len);
#endif


static BIO *bio_err = NULL;
static BIO *bio_stdout = NULL;

static char *cipher = NULL;
static int verbose = 0;
static int debug = 0;
#if 0
/* Not used yet. */
#ifdef FIONBIO
static int s_nbio = 0;
#endif
#endif

int doit_biopair(SSL *s_ssl, SSL *c_ssl, long bytes, clock_t *s_time, clock_t *c_time);
int doit(SSL *s_ssl, SSL *c_ssl, long bytes);
static int do_test_cipherlist(void);

static void
sv_usage(void)
{
	fprintf(stderr, "usage: ssltest [args ...]\n");
	fprintf(stderr, "\n");
	fprintf(stderr, " -server_auth  - check server certificate\n");
	fprintf(stderr, " -client_auth  - do client authentication\n");
	fprintf(stderr, " -proxy        - allow proxy certificates\n");
	fprintf(stderr, " -proxy_auth <val> - set proxy policy rights\n");
	fprintf(stderr, " -proxy_cond <val> - experssion to test proxy policy rights\n");
	fprintf(stderr, " -v            - more output\n");
	fprintf(stderr, " -d            - debug output\n");
	fprintf(stderr, " -reuse        - use session-id reuse\n");
	fprintf(stderr, " -num <val>    - number of connections to perform\n");
	fprintf(stderr, " -bytes <val>  - number of bytes to swap between client/server\n");
#ifndef OPENSSL_NO_DH
	fprintf(stderr, " -dhe1024      - use 1024 bit key (safe prime) for DHE\n");
	fprintf(stderr, " -dhe1024dsa   - use 1024 bit key (with 160-bit subprime) for DHE\n");
	fprintf(stderr, " -no_dhe       - disable DHE\n");
#endif
#ifndef OPENSSL_NO_ECDH
	fprintf(stderr, " -no_ecdhe     - disable ECDHE\n");
#endif
#ifndef OPENSSL_NO_PSK
	fprintf(stderr, " -psk arg      - PSK in hex (without 0x)\n");
#endif
	fprintf(stderr, " -ssl3         - use SSLv3\n");
	fprintf(stderr, " -tls1         - use TLSv1\n");
	fprintf(stderr, " -CApath arg   - PEM format directory of CA's\n");
	fprintf(stderr, " -CAfile arg   - PEM format file of CA's\n");
	fprintf(stderr, " -cert arg     - Server certificate file\n");
	fprintf(stderr, " -key arg      - Server key file (default: same as -cert)\n");
	fprintf(stderr, " -c_cert arg   - Client certificate file\n");
	fprintf(stderr, " -c_key arg    - Client key file (default: same as -c_cert)\n");
	fprintf(stderr, " -cipher arg   - The cipher list\n");
	fprintf(stderr, " -bio_pair     - Use BIO pairs\n");
	fprintf(stderr, " -f            - Test even cases that can't work\n");
	fprintf(stderr, " -time         - measure processor time used by client and server\n");
	fprintf(stderr, " -zlib         - use zlib compression\n");
	fprintf(stderr, " -rle          - use rle compression\n");
#ifndef OPENSSL_NO_ECDH
	fprintf(stderr, " -named_curve arg  - Elliptic curve name to use for ephemeral ECDH keys.\n" \
	               "                 Use \"openssl ecparam -list_curves\" for all names\n"  \
	               "                 (default is sect163r2).\n");
#endif
	fprintf(stderr, " -test_cipherlist - verifies the order of the ssl cipher lists\n");
}

static void
print_details(SSL *c_ssl, const char *prefix)
{
	const SSL_CIPHER *ciph;
	X509 *cert;

	ciph = SSL_get_current_cipher(c_ssl);
	BIO_printf(bio_stdout, "%s%s, cipher %s %s",
	prefix,
	SSL_get_version(c_ssl),
	SSL_CIPHER_get_version(ciph),
	SSL_CIPHER_get_name(ciph));
	cert = SSL_get_peer_certificate(c_ssl);
	if (cert != NULL) {
		EVP_PKEY *pkey = X509_get_pubkey(cert);
		if (pkey != NULL) {
			if (pkey->type == EVP_PKEY_RSA &&
			    pkey->pkey.rsa != NULL &&
			    pkey->pkey.rsa->n != NULL) {
				BIO_printf(bio_stdout, ", %d bit RSA",
				BN_num_bits(pkey->pkey.rsa->n));
			}
			else if (pkey->type == EVP_PKEY_DSA &&
			    pkey->pkey.dsa != NULL &&
			    pkey->pkey.dsa->p != NULL) {
				BIO_printf(bio_stdout, ", %d bit DSA",
				BN_num_bits(pkey->pkey.dsa->p));
			}
			EVP_PKEY_free(pkey);
		}
		X509_free(cert);
	}
	/* The SSL API does not allow us to look at temporary RSA/DH keys,
	 * otherwise we should print their lengths too */
	BIO_printf(bio_stdout, "\n");
}

static void
lock_dbg_cb(int mode, int type, const char *file, int line)
{
	static int modes[CRYPTO_NUM_LOCKS]; /* = {0, 0, ... } */
	const char *errstr = NULL;
	int rw;

	rw = mode & (CRYPTO_READ|CRYPTO_WRITE);
	if (!((rw == CRYPTO_READ) || (rw == CRYPTO_WRITE))) {
		errstr = "invalid mode";
		goto err;
	}

	if (type < 0 || type >= CRYPTO_NUM_LOCKS) {
		errstr = "type out of bounds";
		goto err;
	}

	if (mode & CRYPTO_LOCK) {
		if (modes[type]) {
			errstr = "already locked";
			/* must not happen in a single-threaded program
			 * (would deadlock) */
			goto err;
		}

		modes[type] = rw;
	} else if (mode & CRYPTO_UNLOCK) {
		if (!modes[type]) {
			errstr = "not locked";
			goto err;
		}

		if (modes[type] != rw) {
			errstr = (rw == CRYPTO_READ) ?
			"CRYPTO_r_unlock on write lock" :
			"CRYPTO_w_unlock on read lock";
		}

		modes[type] = 0;
	} else {
		errstr = "invalid mode";
		goto err;
	}

err:
	if (errstr) {
		/* we cannot use bio_err here */
		fprintf(stderr, "openssl (lock_dbg_cb): %s (mode=%d, type=%d) at %s:%d\n",
		errstr, mode, type, file, line);
	}
}

#ifdef TLSEXT_TYPE_opaque_prf_input
	struct cb_info_st { void *input;
	size_t len;
	int ret;
};

struct cb_info_st co1 = { "C", 1, 1 }; /* try to negotiate oqaque PRF input */
struct cb_info_st co2 = { "C", 1, 2 }; /* insist on oqaque PRF input */
struct cb_info_st so1 = { "S", 1, 1 }; /* try to negotiate oqaque PRF input */
struct cb_info_st so2 = { "S", 1, 2 }; /* insist on oqaque PRF input */

int
opaque_prf_input_cb(SSL *ssl, void *peerinput, size_t len, void *arg_)
{
	struct cb_info_st *arg = arg_;

	if (arg == NULL)
		return 1;

	if (!SSL_set_tlsext_opaque_prf_input(ssl, arg->input, arg->len))
		return 0;
	return arg->ret;
}
#endif

int
main(int argc, char *argv[])
{
	char *CApath = NULL, *CAfile = NULL;
	int badop = 0;
	int bio_pair = 0;
	int force = 0;
	int tls1 = 0, ssl2 = 0, ssl3 = 0, ret = 1;
	int client_auth = 0;
	int server_auth = 0, i;
	struct app_verify_arg app_verify_arg =
	{ APP_CALLBACK_STRING, 0, 0, NULL, NULL };
	char *server_cert = TEST_SERVER_CERT;
	char *server_key = NULL;
	char *client_cert = TEST_CLIENT_CERT;
	char *client_key = NULL;
#ifndef OPENSSL_NO_ECDH
	char *named_curve = NULL;
#endif
	SSL_CTX *s_ctx = NULL;
	SSL_CTX *c_ctx = NULL;
	const SSL_METHOD *meth = NULL;
	SSL *c_ssl, *s_ssl;
	int number = 1, reuse = 0;
	long bytes = 256L;
#ifndef OPENSSL_NO_DH
	DH *dh;
	int dhe1024 = 0, dhe1024dsa = 0;
#endif
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh = NULL;
#endif
	int no_dhe = 0;
	int no_ecdhe = 0;
	int no_psk = 0;
	int print_time = 0;
	clock_t s_time = 0, c_time = 0;
	int comp = 0;
#ifndef OPENSSL_NO_COMP
	COMP_METHOD *cm = NULL;
	STACK_OF(SSL_COMP) *ssl_comp_methods = NULL;
#endif
	int test_cipherlist = 0;

	verbose = 0;
	debug = 0;
	cipher = 0;

	bio_err = BIO_new_fp(stderr, BIO_NOCLOSE|BIO_FP_TEXT);


	CRYPTO_set_locking_callback(lock_dbg_cb);

	/* enable memory leak checking unless explicitly disabled */
	if (!((getenv("OPENSSL_DEBUG_MEMORY") != NULL) && (0 == strcmp(getenv("OPENSSL_DEBUG_MEMORY"), "off")))) {
		CRYPTO_malloc_debug_init();
		CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
	} else {
		/* OPENSSL_DEBUG_MEMORY=off */
		CRYPTO_set_mem_debug_functions(0, 0, 0, 0, 0);
	}
	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);

	bio_stdout = BIO_new_fp(stdout, BIO_NOCLOSE|BIO_FP_TEXT);

	argc--;
	argv++;

	while (argc >= 1) {
		if (!strcmp(*argv, "-F")) {
			fprintf(stderr, "not compiled with FIPS support, so exitting without running.\n");
			exit(0);
		} else if (strcmp(*argv, "-server_auth") == 0)
			server_auth = 1;
		else if (strcmp(*argv, "-client_auth") == 0)
			client_auth = 1;
		else if (strcmp(*argv, "-proxy_auth") == 0) {
			if (--argc < 1)
				goto bad;
			app_verify_arg.proxy_auth= *(++argv);
		} else if (strcmp(*argv, "-proxy_cond") == 0) {
			if (--argc < 1)
				goto bad;
			app_verify_arg.proxy_cond= *(++argv);
		} else if (strcmp(*argv, "-v") == 0)
			verbose = 1;
		else if (strcmp(*argv, "-d") == 0)
			debug = 1;
		else if (strcmp(*argv, "-reuse") == 0)
			reuse = 1;
		else if (strcmp(*argv, "-dhe1024") == 0) {
#ifndef OPENSSL_NO_DH
			dhe1024 = 1;
#else
			fprintf(stderr, "ignoring -dhe1024, since I'm compiled without DH\n");
#endif
		} else if (strcmp(*argv, "-dhe1024dsa") == 0) {
#ifndef OPENSSL_NO_DH
			dhe1024dsa = 1;
#else
			fprintf(stderr, "ignoring -dhe1024, since I'm compiled without DH\n");
#endif
		} else if (strcmp(*argv, "-no_dhe") == 0)
			no_dhe = 1;
		else if (strcmp(*argv, "-no_ecdhe") == 0)
			no_ecdhe = 1;
		else if (strcmp(*argv, "-psk") == 0) {
			if (--argc < 1)
				goto bad;
			psk_key=*(++argv);
#ifndef OPENSSL_NO_PSK
			if (strspn(psk_key, "abcdefABCDEF1234567890") != strlen(psk_key)) {
				BIO_printf(bio_err, "Not a hex number '%s'\n", *argv);
				goto bad;
			}
#else
			no_psk = 1;
#endif
		}
		else if (strcmp(*argv, "-ssl2") == 0)
			ssl2 = 1;
		else if (strcmp(*argv, "-tls1") == 0)
			tls1 = 1;
		else if (strcmp(*argv, "-ssl3") == 0)
			ssl3 = 1;
		else if (strncmp(*argv, "-num", 4) == 0) {
			if (--argc < 1)
				goto bad;
			number = atoi(*(++argv));
			if (number == 0)
				number = 1;
		} else if (strcmp(*argv, "-bytes") == 0) {
			if (--argc < 1)
				goto bad;
			bytes = atol(*(++argv));
			if (bytes == 0L)
				bytes = 1L;
			i = strlen(argv[0]);
			if (argv[0][i - 1] == 'k')
				bytes*=1024L;
			if (argv[0][i - 1] == 'm')
				bytes*=1024L*1024L;
		} else if (strcmp(*argv, "-cert") == 0) {
			if (--argc < 1)
				goto bad;
			server_cert= *(++argv);
		} else if (strcmp(*argv, "-s_cert") == 0) {
			if (--argc < 1)
				goto bad;
			server_cert= *(++argv);
		} else if (strcmp(*argv, "-key") == 0) {
			if (--argc < 1)
				goto bad;
			server_key= *(++argv);
		} else if (strcmp(*argv, "-s_key") == 0) {
			if (--argc < 1)
				goto bad;
			server_key= *(++argv);
		} else if (strcmp(*argv, "-c_cert") == 0) {
			if (--argc < 1)
				goto bad;
			client_cert= *(++argv);
		} else if (strcmp(*argv, "-c_key") == 0) {
			if (--argc < 1)
				goto bad;
			client_key= *(++argv);
		} else if (strcmp(*argv, "-cipher") == 0) {
			if (--argc < 1)
				goto bad;
			cipher= *(++argv);
		} else if (strcmp(*argv, "-CApath") == 0) {
			if (--argc < 1)
				goto bad;
			CApath= *(++argv);
		} else if (strcmp(*argv, "-CAfile") == 0) {
			if (--argc < 1)
				goto bad;
			CAfile= *(++argv);
		} else if (strcmp(*argv, "-bio_pair") == 0) {
			bio_pair = 1;
		} else if (strcmp(*argv, "-f") == 0) {
			force = 1;
		} else if (strcmp(*argv, "-time") == 0) {
			print_time = 1;
		} else if (strcmp(*argv, "-zlib") == 0) {
			comp = COMP_ZLIB;
		} else if (strcmp(*argv, "-rle") == 0) {
			comp = COMP_RLE;
		} else if (strcmp(*argv, "-named_curve") == 0) {
			if (--argc < 1)
				goto bad;
#ifndef OPENSSL_NO_ECDH		
			named_curve = *(++argv);
#else
			fprintf(stderr, "ignoring -named_curve, since I'm compiled without ECDH\n");
			++argv;
#endif
		} else if (strcmp(*argv, "-app_verify") == 0) {
			app_verify_arg.app_verify = 1;
		} else if (strcmp(*argv, "-proxy") == 0) {
			app_verify_arg.allow_proxy_certs = 1;
		} else if (strcmp(*argv, "-test_cipherlist") == 0) {
			test_cipherlist = 1;
		} else {
			fprintf(stderr, "unknown option %s\n", *argv);
			badop = 1;
			break;
		}
		argc--;
		argv++;
	}
	if (badop) {
bad:
		sv_usage();
		goto end;
	}

	if (test_cipherlist == 1) {
		/* ensure that the cipher list are correctly sorted and exit */
		if (do_test_cipherlist() == 0)
			exit(1);
		ret = 0;
		goto end;
	}

	if (!ssl2 && !ssl3 && !tls1 && number > 1 && !reuse && !force) {
		fprintf(stderr,
		    "This case cannot work.  Use -f to perform "
		    "the test anyway (and\n-d to see what happens), "
		    "or add one of -ssl2, -ssl3, -tls1, -reuse\n"
		    "to avoid protocol mismatch.\n");
		exit(1);
	}

	if (print_time) {
		if (!bio_pair) {
			fprintf(stderr, "Using BIO pair (-bio_pair)\n");
			bio_pair = 1;
		}
		if (number < 50 && !force)
			fprintf(stderr, "Warning: For accurate timings, use more connections (e.g. -num 1000)\n");
	}

/*	if (cipher == NULL) cipher=getenv("SSL_CIPHER"); */

	SSL_library_init();
	SSL_load_error_strings();

#ifndef OPENSSL_NO_COMP
	if (comp == COMP_ZLIB)
		cm = COMP_zlib();
	if (comp == COMP_RLE)
		cm = COMP_rle();
	if (cm != NULL) {
		if (cm->type != NID_undef) {
			if (SSL_COMP_add_compression_method(comp, cm) != 0) {
				fprintf(stderr,
				"Failed to add compression method\n");
				ERR_print_errors_fp(stderr);
			}
		} else {
			fprintf(stderr,
			    "Warning: %s compression not supported\n",
			    (comp == COMP_RLE ? "rle" :
			    (comp == COMP_ZLIB ? "zlib" :
			    "unknown")));
			ERR_print_errors_fp(stderr);
		}
	}
	ssl_comp_methods = SSL_COMP_get_compression_methods();
	fprintf(stderr, "Available compression methods:\n");
	{
		int j, n = sk_SSL_COMP_num(ssl_comp_methods);
		if (n == 0)
			fprintf(stderr, "  NONE\n");
		else
			for (j = 0; j < n; j++) {
				SSL_COMP *c = sk_SSL_COMP_value(ssl_comp_methods, j);
				fprintf(stderr, "  %d: %s\n", c->id, c->name);
			}
	}
#endif

	if (tls1)
		meth = TLSv1_method();
	else if (ssl3)
		meth = SSLv3_method();
	else
		meth = SSLv23_method();

	c_ctx = SSL_CTX_new(meth);
	s_ctx = SSL_CTX_new(meth);
	if ((c_ctx == NULL) || (s_ctx == NULL)) {
		ERR_print_errors(bio_err);
		goto end;
	}

	if (cipher != NULL) {
		SSL_CTX_set_cipher_list(c_ctx, cipher);
		SSL_CTX_set_cipher_list(s_ctx, cipher);
	}

#ifndef OPENSSL_NO_DH
	if (!no_dhe) {
		if (dhe1024dsa) {
			/* use SSL_OP_SINGLE_DH_USE to avoid small subgroup attacks */
			SSL_CTX_set_options(s_ctx, SSL_OP_SINGLE_DH_USE);
			dh = get_dh1024dsa();
		} else if (dhe1024)
			dh = get_dh1024();
		else
			dh = get_dh512();
		SSL_CTX_set_tmp_dh(s_ctx, dh);
		DH_free(dh);
	}
#else
	(void)no_dhe;
#endif

#ifndef OPENSSL_NO_ECDH
	if (!no_ecdhe) {
		int nid;

		if (named_curve != NULL) {
			nid = OBJ_sn2nid(named_curve);
			if (nid == 0) {
				BIO_printf(bio_err, "unknown curve name (%s)\n", named_curve);
				goto end;
			}
		} else
#ifdef OPENSSL_NO_EC2M
		nid = NID_X9_62_prime256v1;
#else
		nid = NID_sect163r2;
#endif

		ecdh = EC_KEY_new_by_curve_name(nid);
		if (ecdh == NULL) {
			BIO_printf(bio_err, "unable to create curve\n");
			goto end;
		}

		SSL_CTX_set_tmp_ecdh(s_ctx, ecdh);
		SSL_CTX_set_options(s_ctx, SSL_OP_SINGLE_ECDH_USE);
		EC_KEY_free(ecdh);
	}
#else
	(void)no_ecdhe;
#endif

	SSL_CTX_set_tmp_rsa_callback(s_ctx, tmp_rsa_cb);

#ifdef TLSEXT_TYPE_opaque_prf_input
	SSL_CTX_set_tlsext_opaque_prf_input_callback(c_ctx, opaque_prf_input_cb);
	SSL_CTX_set_tlsext_opaque_prf_input_callback(s_ctx, opaque_prf_input_cb);
	SSL_CTX_set_tlsext_opaque_prf_input_callback_arg(c_ctx, &co1); /* or &co2 or NULL */
	SSL_CTX_set_tlsext_opaque_prf_input_callback_arg(s_ctx, &so1); /* or &so2 or NULL */
#endif

	if (!SSL_CTX_use_certificate_file(s_ctx, server_cert, SSL_FILETYPE_PEM)) {
		ERR_print_errors(bio_err);
	} else if (!SSL_CTX_use_PrivateKey_file(s_ctx,
	    (server_key ? server_key : server_cert), SSL_FILETYPE_PEM)) {
		ERR_print_errors(bio_err);
		goto end;
	}

	if (client_auth) {
		SSL_CTX_use_certificate_file(c_ctx, client_cert,
		SSL_FILETYPE_PEM);
		SSL_CTX_use_PrivateKey_file(c_ctx,
		(client_key ? client_key : client_cert),
		SSL_FILETYPE_PEM);
	}

	if ((!SSL_CTX_load_verify_locations(s_ctx, CAfile, CApath)) ||
	    (!SSL_CTX_set_default_verify_paths(s_ctx)) ||
	    (!SSL_CTX_load_verify_locations(c_ctx, CAfile, CApath)) ||
	    (!SSL_CTX_set_default_verify_paths(c_ctx))) {
		/* fprintf(stderr,"SSL_load_verify_locations\n"); */
		ERR_print_errors(bio_err);
		/* goto end; */
	}

	if (client_auth) {
		BIO_printf(bio_err, "client authentication\n");
		SSL_CTX_set_verify(s_ctx,
		SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
		verify_callback);
		SSL_CTX_set_cert_verify_callback(s_ctx, app_verify_callback, &app_verify_arg);
	}
	if (server_auth) {
		BIO_printf(bio_err, "server authentication\n");
		SSL_CTX_set_verify(c_ctx, SSL_VERIFY_PEER,
		verify_callback);
		SSL_CTX_set_cert_verify_callback(c_ctx, app_verify_callback, &app_verify_arg);
	}

	{
		int session_id_context = 0;
		SSL_CTX_set_session_id_context(s_ctx, (void *)&session_id_context, sizeof session_id_context);
	}

	/* Use PSK only if PSK key is given */
	if (psk_key != NULL) {
		/* no_psk is used to avoid putting psk command to openssl tool */
		if (no_psk) {
			/* if PSK is not compiled in and psk key is
			 * given, do nothing and exit successfully */
			ret = 0;
			goto end;
		}
#ifndef OPENSSL_NO_PSK
		SSL_CTX_set_psk_client_callback(c_ctx, psk_client_callback);
		SSL_CTX_set_psk_server_callback(s_ctx, psk_server_callback);
		if (debug)
			BIO_printf(bio_err, "setting PSK identity hint to s_ctx\n");
		if (!SSL_CTX_use_psk_identity_hint(s_ctx, "ctx server identity_hint")) {
			BIO_printf(bio_err, "error setting PSK identity hint to s_ctx\n");
			ERR_print_errors(bio_err);
			goto end;
		}
#endif
	}

	c_ssl = SSL_new(c_ctx);
	s_ssl = SSL_new(s_ctx);


	for (i = 0; i < number; i++) {
		if (!reuse)
			SSL_set_session(c_ssl, NULL);
		if (bio_pair)
			ret = doit_biopair(s_ssl, c_ssl, bytes, &s_time, &c_time);
		else
			ret = doit(s_ssl, c_ssl, bytes);
	}

	if (!verbose) {
		print_details(c_ssl, "");
	}
	if ((number > 1) || (bytes > 1L))
		BIO_printf(bio_stdout, "%d handshakes of %ld bytes done\n", number, bytes);
	if (print_time) {
#ifdef CLOCKS_PER_SEC
		/* "To determine the time in seconds, the value returned
		 * by the clock function should be divided by the value
		 * of the macro CLOCKS_PER_SEC."
		 *                                       -- ISO/IEC 9899 */
		BIO_printf(bio_stdout, "Approximate total server time: %6.2f s\n"
		"Approximate total client time: %6.2f s\n",
		(double)s_time/CLOCKS_PER_SEC,
		(double)c_time/CLOCKS_PER_SEC);
#else
		/* "`CLOCKS_PER_SEC' undeclared (first use this function)"
		 *                            -- cc on NeXTstep/OpenStep */
		BIO_printf(bio_stdout,
		"Approximate total server time: %6.2f units\n"
		"Approximate total client time: %6.2f units\n",
		(double)s_time,
		(double)c_time);
#endif
	}

	SSL_free(s_ssl);
	SSL_free(c_ssl);

end:
	if (s_ctx != NULL)
		SSL_CTX_free(s_ctx);
	if (c_ctx != NULL)
		SSL_CTX_free(c_ctx);

	if (bio_stdout != NULL)
		BIO_free(bio_stdout);

	free_tmp_rsa();
#ifndef OPENSSL_NO_ENGINE
	ENGINE_cleanup();
#endif
	CRYPTO_cleanup_all_ex_data();
	ERR_free_strings();
	ERR_remove_thread_state(NULL);
	EVP_cleanup();
	CRYPTO_mem_leaks(bio_err);
	if (bio_err != NULL)
		BIO_free(bio_err);
	exit(ret);
	return ret;
}

int
doit_biopair(SSL *s_ssl, SSL *c_ssl, long count, clock_t *s_time,
    clock_t *c_time)
{
	long cw_num = count, cr_num = count, sw_num = count, sr_num = count;
	BIO *s_ssl_bio = NULL, *c_ssl_bio = NULL;
	BIO *server = NULL, *server_io = NULL, *client = NULL, *client_io = NULL;
	int ret = 1;

	size_t bufsiz = 256; /* small buffer for testing */

	if (!BIO_new_bio_pair(&server, bufsiz, &server_io, bufsiz))
		goto err;
	if (!BIO_new_bio_pair(&client, bufsiz, &client_io, bufsiz))
		goto err;

	s_ssl_bio = BIO_new(BIO_f_ssl());
	if (!s_ssl_bio)
		goto err;

	c_ssl_bio = BIO_new(BIO_f_ssl());
	if (!c_ssl_bio)
		goto err;

	SSL_set_connect_state(c_ssl);
	SSL_set_bio(c_ssl, client, client);
	(void)BIO_set_ssl(c_ssl_bio, c_ssl, BIO_NOCLOSE);

	SSL_set_accept_state(s_ssl);
	SSL_set_bio(s_ssl, server, server);
	(void)BIO_set_ssl(s_ssl_bio, s_ssl, BIO_NOCLOSE);

	do {
		/* c_ssl_bio:          SSL filter BIO
		 *
		 * client:             pseudo-I/O for SSL library
		 *
		 * client_io:          client's SSL communication; usually to be
		 *                     relayed over some I/O facility, but in this
		 *                     test program, we're the server, too:
		 *
		 * server_io:          server's SSL communication
		 *
		 * server:             pseudo-I/O for SSL library
		 *
		 * s_ssl_bio:          SSL filter BIO
		 *
		 * The client and the server each employ a "BIO pair":
		 * client + client_io, server + server_io.
		 * BIO pairs are symmetric.  A BIO pair behaves similar
		 * to a non-blocking socketpair (but both endpoints must
		 * be handled by the same thread).
		 * [Here we could connect client and server to the ends
		 * of a single BIO pair, but then this code would be less
		 * suitable as an example for BIO pairs in general.]
		 *
		 * Useful functions for querying the state of BIO pair endpoints:
		 *
		 * BIO_ctrl_pending(bio)              number of bytes we can read now
		 * BIO_ctrl_get_read_request(bio)     number of bytes needed to fulfil
		 *                                      other side's read attempt
		 * BIO_ctrl_get_write_guarantee(bio)   number of bytes we can write now
		 *
		 * ..._read_request is never more than ..._write_guarantee;
		 * it depends on the application which one you should use.
		 */

		/* We have non-blocking behaviour throughout this test program, but
		 * can be sure that there is *some* progress in each iteration; so
		 * we don't have to worry about ..._SHOULD_READ or ..._SHOULD_WRITE
		 * -- we just try everything in each iteration
		 */

		{
			/* CLIENT */

			char cbuf[1024*8];
			int i, r;
			clock_t c_clock = clock();

			memset(cbuf, 0, sizeof(cbuf));

			if (debug)
				if (SSL_in_init(c_ssl))
					printf("client waiting in SSL_connect - %s\n",
			SSL_state_string_long(c_ssl));

			if (cw_num > 0) {
				/* Write to server. */

				if (cw_num > (long)sizeof cbuf)
					i = sizeof cbuf;
				else
					i = (int)cw_num;
				r = BIO_write(c_ssl_bio, cbuf, i);
				if (r < 0) {
					if (!BIO_should_retry(c_ssl_bio)) {
						fprintf(stderr, "ERROR in CLIENT\n");
						goto err;
					}
					/* BIO_should_retry(...) can just be ignored here.
					 * The library expects us to call BIO_write with
					 * the same arguments again, and that's what we will
					 * do in the next iteration. */
				} else if (r == 0) {
					fprintf(stderr, "SSL CLIENT STARTUP FAILED\n");
					goto err;
				} else {
					if (debug)
						printf("client wrote %d\n", r);
					cw_num -= r;

				}
			}

			if (cr_num > 0) {
				/* Read from server. */

				r = BIO_read(c_ssl_bio, cbuf, sizeof(cbuf));
				if (r < 0) {
					if (!BIO_should_retry(c_ssl_bio)) {
						fprintf(stderr, "ERROR in CLIENT\n");
						goto err;
					}
					/* Again, "BIO_should_retry" can be ignored. */
				} else if (r == 0) {
					fprintf(stderr, "SSL CLIENT STARTUP FAILED\n");
					goto err;
				} else {
					if (debug)
						printf("client read %d\n", r);
					cr_num -= r;
				}
			}

			/* c_time and s_time increments will typically be very small
			 * (depending on machine speed and clock tick intervals),
			 * but sampling over a large number of connections should
			 * result in fairly accurate figures.  We cannot guarantee
			 * a lot, however -- if each connection lasts for exactly
			 * one clock tick, it will be counted only for the client
			 * or only for the server or even not at all.
			 */
			*c_time += (clock() - c_clock);
		}

		{
			/* SERVER */

			char sbuf[1024*8];
			int i, r;
			clock_t s_clock = clock();

			memset(sbuf, 0, sizeof(sbuf));

			if (debug)
				if (SSL_in_init(s_ssl))
					printf("server waiting in SSL_accept - %s\n",
			SSL_state_string_long(s_ssl));

			if (sw_num > 0) {
				/* Write to client. */

				if (sw_num > (long)sizeof sbuf)
					i = sizeof sbuf;
				else
					i = (int)sw_num;
				r = BIO_write(s_ssl_bio, sbuf, i);
				if (r < 0) {
					if (!BIO_should_retry(s_ssl_bio)) {
						fprintf(stderr, "ERROR in SERVER\n");
						goto err;
					}
					/* Ignore "BIO_should_retry". */
				} else if (r == 0) {
					fprintf(stderr, "SSL SERVER STARTUP FAILED\n");
					goto err;
				} else {
					if (debug)
						printf("server wrote %d\n", r);
					sw_num -= r;

				}
			}

			if (sr_num > 0) {
				/* Read from client. */

				r = BIO_read(s_ssl_bio, sbuf, sizeof(sbuf));
				if (r < 0) {
					if (!BIO_should_retry(s_ssl_bio)) {
						fprintf(stderr, "ERROR in SERVER\n");
						goto err;
					}
					/* blah, blah */
				} else if (r == 0) {
					fprintf(stderr, "SSL SERVER STARTUP FAILED\n");
					goto err;
				} else {
					if (debug)
						printf("server read %d\n", r);
					sr_num -= r;
				}
			}

			*s_time += (clock() - s_clock);
		}

		{
			/* "I/O" BETWEEN CLIENT AND SERVER. */

			size_t r1, r2;
			BIO *io1 = server_io, *io2 = client_io;
			/* we use the non-copying interface for io1
			 * and the standard BIO_write/BIO_read interface for io2
			 */

			static int prev_progress = 1;
			int progress = 0;

			/* io1 to io2 */
			do
			{
				size_t num;
				int r;

				r1 = BIO_ctrl_pending(io1);
				r2 = BIO_ctrl_get_write_guarantee(io2);

				num = r1;
				if (r2 < num)
					num = r2;
				if (num) {
					char *dataptr;

					if (INT_MAX < num) /* yeah, right */
						num = INT_MAX;

					r = BIO_nread(io1, &dataptr, (int)num);
					assert(r > 0);
					assert(r <= (int)num);
					/* possibly r < num (non-contiguous data) */
					num = r;
					r = BIO_write(io2, dataptr, (int)num);
					if (r != (int)num) /* can't happen */
					{
						fprintf(stderr, "ERROR: BIO_write could not write "
						"BIO_ctrl_get_write_guarantee() bytes");
						goto err;
					}
					progress = 1;

					if (debug)
						printf((io1 == client_io) ?
					"C->S relaying: %d bytes\n" :
					"S->C relaying: %d bytes\n",
					(int)num);
				}
			} while (r1 && r2);

			/* io2 to io1 */
			{
				size_t num;
				int r;

				r1 = BIO_ctrl_pending(io2);
				r2 = BIO_ctrl_get_read_request(io1);
				/* here we could use ..._get_write_guarantee instead of
				 * ..._get_read_request, but by using the latter
				 * we test restartability of the SSL implementation
				 * more thoroughly */
				num = r1;
				if (r2 < num)
					num = r2;
				if (num) {
					char *dataptr;

					if (INT_MAX < num)
						num = INT_MAX;

					if (num > 1)
						--num; /* test restartability even more thoroughly */

					r = BIO_nwrite0(io1, &dataptr);
					assert(r > 0);
					if (r < (int)num)
						num = r;
					r = BIO_read(io2, dataptr, (int)num);
					if (r != (int)num) /* can't happen */
					{
						fprintf(stderr, "ERROR: BIO_read could not read "
						"BIO_ctrl_pending() bytes");
						goto err;
					}
					progress = 1;
					r = BIO_nwrite(io1, &dataptr, (int)num);
					if (r != (int)num) /* can't happen */
					{
						fprintf(stderr, "ERROR: BIO_nwrite() did not accept "
						"BIO_nwrite0() bytes");
						goto err;
					}

					if (debug)
						printf((io2 == client_io) ?
					"C->S relaying: %d bytes\n" :
					"S->C relaying: %d bytes\n",
					(int)num);
				}
			} /* no loop, BIO_ctrl_get_read_request now returns 0 anyway */

			if (!progress && !prev_progress)
				if (cw_num > 0 || cr_num > 0 || sw_num > 0 || sr_num > 0) {
				fprintf(stderr, "ERROR: got stuck\n");
				if (strcmp("SSLv2", SSL_get_version(c_ssl)) == 0) {
					fprintf(stderr, "This can happen for SSL2 because "
					    "CLIENT-FINISHED and SERVER-VERIFY are written \n"
					    "concurrently ...");
					if (strncmp("2SCF", SSL_state_string(c_ssl), 4) == 0
						&& strncmp("2SSV", SSL_state_string(s_ssl), 4) == 0) {
						fprintf(stderr, " ok.\n");
						goto end;
					}
				}
				fprintf(stderr, " ERROR.\n");
				goto err;
			}
			prev_progress = progress;
		}
	} while (cw_num > 0 || cr_num > 0 || sw_num > 0 || sr_num > 0);

	if (verbose)
		print_details(c_ssl, "DONE via BIO pair: ");
end:
	ret = 0;

	err:
	ERR_print_errors(bio_err);

	if (server)
		BIO_free(server);
	if (server_io)
		BIO_free(server_io);
	if (client)
		BIO_free(client);
	if (client_io)
		BIO_free(client_io);
	if (s_ssl_bio)
		BIO_free(s_ssl_bio);
	if (c_ssl_bio)
		BIO_free(c_ssl_bio);

	return ret;
}


#define W_READ	1
#define W_WRITE	2
#define C_DONE	1
#define S_DONE	2

int
doit(SSL *s_ssl, SSL *c_ssl, long count)
{
	char cbuf[1024*8], sbuf[1024*8];
	long cw_num = count, cr_num = count;
	long sw_num = count, sr_num = count;
	int ret = 1;
	BIO *c_to_s = NULL;
	BIO *s_to_c = NULL;
	BIO *c_bio = NULL;
	BIO *s_bio = NULL;
	int c_r, c_w, s_r, s_w;
	int i, j;
	int done = 0;
	int c_write, s_write;
	int do_server = 0, do_client = 0;

	memset(cbuf, 0, sizeof(cbuf));
	memset(sbuf, 0, sizeof(sbuf));

	c_to_s = BIO_new(BIO_s_mem());
	s_to_c = BIO_new(BIO_s_mem());
	if ((s_to_c == NULL) || (c_to_s == NULL)) {
		ERR_print_errors(bio_err);
		goto err;
	}

	c_bio = BIO_new(BIO_f_ssl());
	s_bio = BIO_new(BIO_f_ssl());
	if ((c_bio == NULL) || (s_bio == NULL)) {
		ERR_print_errors(bio_err);
		goto err;
	}

	SSL_set_connect_state(c_ssl);
	SSL_set_bio(c_ssl, s_to_c, c_to_s);
	BIO_set_ssl(c_bio, c_ssl, BIO_NOCLOSE);

	SSL_set_accept_state(s_ssl);
	SSL_set_bio(s_ssl, c_to_s, s_to_c);
	BIO_set_ssl(s_bio, s_ssl, BIO_NOCLOSE);

	c_r = 0;
	s_r = 1;
	c_w = 1;
	s_w = 0;
	c_write = 1, s_write = 0;

	/* We can always do writes */
	for (;;) {
		do_server = 0;
		do_client = 0;

		i = (int)BIO_pending(s_bio);
		if ((i && s_r) || s_w)
			do_server = 1;

		i = (int)BIO_pending(c_bio);
		if ((i && c_r) || c_w)
			do_client = 1;

		if (do_server && debug) {
			if (SSL_in_init(s_ssl))
				printf("server waiting in SSL_accept - %s\n",
				    SSL_state_string_long(s_ssl));
/*			else if (s_write)
				printf("server:SSL_write()\n");
			else
				printf("server:SSL_read()\n"); */
		}

		if (do_client && debug) {
			if (SSL_in_init(c_ssl))
				printf("client waiting in SSL_connect - %s\n",
				    SSL_state_string_long(c_ssl));
/*			else if (c_write)
				printf("client:SSL_write()\n");
			else
				printf("client:SSL_read()\n"); */
		}

		if (!do_client && !do_server) {
			fprintf(stdout, "ERROR IN STARTUP\n");
			ERR_print_errors(bio_err);
			break;
		}
		if (do_client && !(done & C_DONE)) {
			if (c_write) {
				j = (cw_num > (long)sizeof(cbuf)) ?
				    (int)sizeof(cbuf) : (int)cw_num;
				i = BIO_write(c_bio, cbuf, j);
				if (i < 0) {
					c_r = 0;
					c_w = 0;
					if (BIO_should_retry(c_bio)) {
						if (BIO_should_read(c_bio))
							c_r = 1;
						if (BIO_should_write(c_bio))
							c_w = 1;
					} else {
						fprintf(stderr, "ERROR in CLIENT\n");
						ERR_print_errors(bio_err);
						goto err;
					}
				} else if (i == 0) {
					fprintf(stderr, "SSL CLIENT STARTUP FAILED\n");
					goto err;
				} else {
					if (debug)
						printf("client wrote %d\n", i);
					/* ok */
					s_r = 1;
					c_write = 0;
					cw_num -= i;
				}
			} else {
				i = BIO_read(c_bio, cbuf, sizeof(cbuf));
				if (i < 0) {
					c_r = 0;
					c_w = 0;
					if (BIO_should_retry(c_bio)) {
						if (BIO_should_read(c_bio))
							c_r = 1;
						if (BIO_should_write(c_bio))
							c_w = 1;
					} else {
						fprintf(stderr, "ERROR in CLIENT\n");
						ERR_print_errors(bio_err);
						goto err;
					}
				} else if (i == 0) {
					fprintf(stderr, "SSL CLIENT STARTUP FAILED\n");
					goto err;
				} else {
					if (debug)
						printf("client read %d\n", i);
					cr_num -= i;
					if (sw_num > 0) {
						s_write = 1;
						s_w = 1;
					}
					if (cr_num <= 0) {
						s_write = 1;
						s_w = 1;
						done = S_DONE|C_DONE;
					}
				}
			}
		}

		if (do_server && !(done & S_DONE)) {
			if (!s_write) {
				i = BIO_read(s_bio, sbuf, sizeof(cbuf));
				if (i < 0) {
					s_r = 0;
					s_w = 0;
					if (BIO_should_retry(s_bio)) {
						if (BIO_should_read(s_bio))
							s_r = 1;
						if (BIO_should_write(s_bio))
							s_w = 1;
					} else {
						fprintf(stderr, "ERROR in SERVER\n");
						ERR_print_errors(bio_err);
						goto err;
					}
				} else if (i == 0) {
					ERR_print_errors(bio_err);
					fprintf(stderr, "SSL SERVER STARTUP FAILED in SSL_read\n");
					goto err;
				} else {
					if (debug)
						printf("server read %d\n", i);
					sr_num -= i;
					if (cw_num > 0) {
						c_write = 1;
						c_w = 1;
					}
					if (sr_num <= 0) {
						s_write = 1;
						s_w = 1;
						c_write = 0;
					}
				}
			} else {
				j = (sw_num > (long)sizeof(sbuf)) ?
				    (int)sizeof(sbuf) : (int)sw_num;
				i = BIO_write(s_bio, sbuf, j);
				if (i < 0) {
					s_r = 0;
					s_w = 0;
					if (BIO_should_retry(s_bio)) {
						if (BIO_should_read(s_bio))
							s_r = 1;
						if (BIO_should_write(s_bio))
							s_w = 1;
					} else {
						fprintf(stderr, "ERROR in SERVER\n");
						ERR_print_errors(bio_err);
						goto err;
					}
				} else if (i == 0) {
					ERR_print_errors(bio_err);
					fprintf(stderr, "SSL SERVER STARTUP FAILED in SSL_write\n");
					goto err;
				} else {
					if (debug)
						printf("server wrote %d\n", i);
					sw_num -= i;
					s_write = 0;
					c_r = 1;
					if (sw_num <= 0)
						done|=S_DONE;
				}
			}
		}

		if ((done & S_DONE)
			&& (done & C_DONE)) break;
	}

	if (verbose)
		print_details(c_ssl, "DONE: ");
	ret = 0;
err:
	/* We have to set the BIO's to NULL otherwise they will be
	 * free()ed twice.  Once when th s_ssl is SSL_free()ed and
	 * again when c_ssl is SSL_free()ed.
	 * This is a hack required because s_ssl and c_ssl are sharing the same
	 * BIO structure and SSL_set_bio() and SSL_free() automatically
	 * BIO_free non NULL entries.
	 * You should not normally do this or be required to do this */
	if (s_ssl != NULL) {
		s_ssl->rbio = NULL;
		s_ssl->wbio = NULL;
	}
	if (c_ssl != NULL) {
		c_ssl->rbio = NULL;
		c_ssl->wbio = NULL;
	}

	if (c_to_s != NULL)
		BIO_free(c_to_s);
	if (s_to_c != NULL)
		BIO_free(s_to_c);
	if (c_bio != NULL)
		BIO_free_all(c_bio);
	if (s_bio != NULL)
		BIO_free_all(s_bio);
	return (ret);
}

static int
get_proxy_auth_ex_data_idx(void)
{
	static volatile int idx = -1;
	if (idx < 0) {
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
		if (idx < 0) {
			idx = X509_STORE_CTX_get_ex_new_index(0,
			    "SSLtest for verify callback", NULL, NULL, NULL);
		}
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
	}
	return idx;
}

static int
verify_callback(int ok, X509_STORE_CTX *ctx)
{
	char *s, buf[256];

	s = X509_NAME_oneline(X509_get_subject_name(ctx->current_cert), buf,
	sizeof buf);
	if (s != NULL) {
		if (ok)
			fprintf(stderr, "depth=%d %s\n",
			    ctx->error_depth, buf);
		else {
			fprintf(stderr, "depth=%d error=%d %s\n",
			    ctx->error_depth, ctx->error, buf);
		}
	}

	if (ok == 0) {
		fprintf(stderr, "Error string: %s\n",
		    X509_verify_cert_error_string(ctx->error));
		switch (ctx->error) {
		case X509_V_ERR_CERT_NOT_YET_VALID:
		case X509_V_ERR_CERT_HAS_EXPIRED:
		case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
			fprintf(stderr, "  ... ignored.\n");
			ok = 1;
		}
	}

	if (ok == 1) {
		X509 *xs = ctx->current_cert;
#if 0
		X509 *xi = ctx->current_issuer;
#endif

		if (xs->ex_flags & EXFLAG_PROXY) {
			unsigned int *letters =
			    X509_STORE_CTX_get_ex_data(ctx,
			        get_proxy_auth_ex_data_idx());

			if (letters) {
				int found_any = 0;
				int i;
				PROXY_CERT_INFO_EXTENSION *pci =
				    X509_get_ext_d2i(xs, NID_proxyCertInfo,
				        NULL, NULL);

				switch (OBJ_obj2nid(pci->proxyPolicy->policyLanguage)) {
				case NID_Independent:
					/* Completely meaningless in this
					   program, as there's no way to
					   grant explicit rights to a
					   specific PrC.  Basically, using
					   id-ppl-Independent is the perfect
					   way to grant no rights at all. */
					fprintf(stderr, "  Independent proxy certificate");
					for (i = 0; i < 26; i++)
						letters[i] = 0;
					break;
				case NID_id_ppl_inheritAll:
					/* This is basically a NOP, we
					   simply let the current rights
					   stand as they are. */
					fprintf(stderr, "  Proxy certificate inherits all");
					break;
				default:
					s = (char *)
					pci->proxyPolicy->policy->data;
					i = pci->proxyPolicy->policy->length;

					/* The algorithm works as follows:
					   it is assumed that previous
					   iterations or the initial granted
					   rights has already set some elements
					   of `letters'.  What we need to do is
					   to clear those that weren't granted
					   by the current PrC as well.  The
					   easiest way to do this is to add 1
					   to all the elements whose letters
					   are given with the current policy.
					   That way, all elements that are set
					   by the current policy and were
					   already set by earlier policies and
					   through the original grant of rights
					   will get the value 2 or higher.
					   The last thing to do is to sweep
					   through `letters' and keep the
					   elements having the value 2 as set,
					   and clear all the others. */

					fprintf(stderr, "  Certificate proxy rights = %*.*s", i, i, s);
					while (i-- > 0) {
						int c = *s++;
						if (isascii(c) && isalpha(c)) {
							if (islower(c))
								c = toupper(c);
							letters[c - 'A']++;
						}
					}
					for (i = 0; i < 26; i++)
						if (letters[i] < 2)
							letters[i] = 0;
					else
						letters[i] = 1;
				}

				found_any = 0;
				fprintf(stderr, ", resulting proxy rights = ");
				for (i = 0; i < 26; i++)
					if (letters[i]) {
					fprintf(stderr, "%c", i + 'A');
					found_any = 1;
				}
				if (!found_any)
					fprintf(stderr, "none");
				fprintf(stderr, "\n");

				PROXY_CERT_INFO_EXTENSION_free(pci);
			}
		}
	}

	return (ok);
}

static void
process_proxy_debug(int indent, const char *format, ...)
{
	static const char indentation[] =
	">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
	">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"; /* That's 80 > */
	char my_format[256];
	va_list args;

	(void) snprintf(my_format, sizeof(my_format), "%*.*s %s",
	    indent, indent, indentation, format);

	va_start(args, format);
	vfprintf(stderr, my_format, args);
	va_end(args);
}
/* Priority levels:
   0	[!]var, ()
   1	& ^
   2	|
*/
static int process_proxy_cond_adders(unsigned int letters[26],
    const char *cond, const char **cond_end, int *pos, int indent);

static int
process_proxy_cond_val(unsigned int letters[26], const char *cond,
    const char **cond_end, int *pos, int indent)
{
	int c;
	int ok = 1;
	int negate = 0;

	while (isspace((int)*cond)) {
		cond++;
		(*pos)++;
	}
	c = *cond;

	if (debug)
		process_proxy_debug(indent,
		    "Start process_proxy_cond_val at position %d: %s\n",
		    *pos, cond);

	while (c == '!') {
		negate = !negate;
		cond++;
		(*pos)++;
		while (isspace((int)*cond)) {
			cond++;
			(*pos)++;
		}
		c = *cond;
	}

	if (c == '(') {
		cond++;
		(*pos)++;
		ok = process_proxy_cond_adders(letters, cond, cond_end, pos,
		    indent + 1);
		cond = *cond_end;
		if (ok < 0)
			goto end;
		while (isspace((int)*cond)) {
			cond++;
			(*pos)++;
		}
		c = *cond;
		if (c != ')') {
			fprintf(stderr,
			    "Weird condition character in position %d: "
			    "%c\n", *pos, c);
			ok = -1;
			goto end;
		}
		cond++;
		(*pos)++;
	} else if (isascii(c) && isalpha(c)) {
		if (islower(c))
			c = toupper(c);
		ok = letters[c - 'A'];
		cond++;
		(*pos)++;
	} else {
		fprintf(stderr,
		    "Weird condition character in position %d: "
		    "%c\n", *pos, c);
		ok = -1;
		goto end;
	}
	end:
	*cond_end = cond;
	if (ok >= 0 && negate)
		ok = !ok;

	if (debug)
		process_proxy_debug(indent,
		    "End process_proxy_cond_val at position %d: %s, returning %d\n",
		    *pos, cond, ok);

	return ok;
}

static int
process_proxy_cond_multipliers(unsigned int letters[26], const char *cond,
    const char **cond_end, int *pos, int indent)
{
	int ok;
	char c;

	if (debug)
		process_proxy_debug(indent,
		    "Start process_proxy_cond_multipliers at position %d: %s\n",
		    *pos, cond);

	ok = process_proxy_cond_val(letters, cond, cond_end, pos, indent + 1);
	cond = *cond_end;
	if (ok < 0)
		goto end;

	while (ok >= 0) {
		while (isspace((int)*cond)) {
			cond++;
			(*pos)++;
		}
		c = *cond;

		switch (c) {
		case '&':
		case '^':
			{
				int save_ok = ok;

				cond++;
				(*pos)++;
				ok = process_proxy_cond_val(letters,
				    cond, cond_end, pos, indent + 1);
				cond = *cond_end;
				if (ok < 0)
					break;

				switch (c) {
				case '&':
					ok &= save_ok;
					break;
				case '^':
					ok ^= save_ok;
					break;
				default:
					fprintf(stderr, "SOMETHING IS SERIOUSLY WRONG!"
					    " STOPPING\n");
					exit(1);
				}
			}
			break;
		default:
			goto end;
		}
	}
	end:
	if (debug)
		process_proxy_debug(indent,
		    "End process_proxy_cond_multipliers at position %d: %s, returning %d\n",
		    *pos, cond, ok);

	*cond_end = cond;
	return ok;
}

static int
process_proxy_cond_adders(unsigned int letters[26], const char *cond,
    const char **cond_end, int *pos, int indent)
{
	int ok;
	char c;

	if (debug)
		process_proxy_debug(indent,
		    "Start process_proxy_cond_adders at position %d: %s\n",
		    *pos, cond);

	ok = process_proxy_cond_multipliers(letters, cond, cond_end, pos,
	    indent + 1);
	cond = *cond_end;
	if (ok < 0)
		goto end;

	while (ok >= 0) {
		while (isspace((int)*cond)) {
			cond++;
			(*pos)++;
		}
		c = *cond;

		switch (c) {
		case '|':
			{
				int save_ok = ok;

				cond++;
				(*pos)++;
				ok = process_proxy_cond_multipliers(letters,
				    cond, cond_end, pos, indent + 1);
				cond = *cond_end;
				if (ok < 0)
					break;

				switch (c) {
				case '|':
					ok |= save_ok;
					break;
				default:
					fprintf(stderr, "SOMETHING IS SERIOUSLY WRONG!"
					    " STOPPING\n");
					exit(1);
				}
			}
			break;
		default:
			goto end;
		}
	}
	end:
	if (debug)
		process_proxy_debug(indent,
	            "End process_proxy_cond_adders at position %d: %s, returning %d\n",
		    *pos, cond, ok);

	*cond_end = cond;
	return ok;
}

static int
process_proxy_cond(unsigned int letters[26], const char *cond,
    const char **cond_end)
{
	int pos = 1;
	return process_proxy_cond_adders(letters, cond, cond_end, &pos, 1);
}

static int
app_verify_callback(X509_STORE_CTX *ctx, void *arg)
{
	int ok = 1;
	struct app_verify_arg *cb_arg = arg;
	unsigned int letters[26]; /* only used with proxy_auth */

	if (cb_arg->app_verify) {
		char *s = NULL, buf[256];

		fprintf(stderr, "In app_verify_callback, allowing cert. ");
		fprintf(stderr, "Arg is: %s\n", cb_arg->string);
		fprintf(stderr, "Finished printing do we have a context? 0x%p a cert? 0x%p\n",
		(void *)ctx, (void *)ctx->cert);
		if (ctx->cert)
			s = X509_NAME_oneline(X509_get_subject_name(ctx->cert), buf, 256);
		if (s != NULL) {
			fprintf(stderr, "cert depth=%d %s\n", ctx->error_depth, buf);
		}
		return (1);
	}
	if (cb_arg->proxy_auth) {
		int found_any = 0, i;
		char *sp;

		for (i = 0; i < 26; i++)
			letters[i] = 0;
		for (sp = cb_arg->proxy_auth; *sp; sp++) {
			int c = *sp;
			if (isascii(c) && isalpha(c)) {
				if (islower(c))
					c = toupper(c);
				letters[c - 'A'] = 1;
			}
		}

		fprintf(stderr, "  Initial proxy rights = ");
		for (i = 0; i < 26; i++)
			if (letters[i]) {
			fprintf(stderr, "%c", i + 'A');
			found_any = 1;
		}
		if (!found_any)
			fprintf(stderr, "none");
		fprintf(stderr, "\n");

		X509_STORE_CTX_set_ex_data(ctx,
		    get_proxy_auth_ex_data_idx(), letters);
	}
	if (cb_arg->allow_proxy_certs) {
		X509_STORE_CTX_set_flags(ctx, X509_V_FLAG_ALLOW_PROXY_CERTS);
	}

#ifndef OPENSSL_NO_X509_VERIFY
	ok = X509_verify_cert(ctx);
#endif

	if (cb_arg->proxy_auth) {
		if (ok > 0) {
			const char *cond_end = NULL;

			ok = process_proxy_cond(letters,
			cb_arg->proxy_cond, &cond_end);

			if (ok < 0)
				exit(3);
			if (*cond_end) {
				fprintf(stderr, "Stopped processing condition before it's end.\n");
				ok = 0;
			}
			if (!ok)
				fprintf(stderr, "Proxy rights check with condition '%s' proved invalid\n",
			cb_arg->proxy_cond);
			else
				fprintf(stderr, "Proxy rights check with condition '%s' proved valid\n",
			cb_arg->proxy_cond);
		}
	}
	return (ok);
}

static RSA *rsa_tmp = NULL;

static RSA *
tmp_rsa_cb(SSL *s, int is_export, int keylength)
{
	BIGNUM *bn = NULL;
	if (rsa_tmp == NULL) {
		bn = BN_new();
		rsa_tmp = RSA_new();
		if (!bn || !rsa_tmp || !BN_set_word(bn, RSA_F4)) {
			BIO_printf(bio_err, "Memory error...");
			goto end;
		}
		BIO_printf(bio_err, "Generating temp (%d bit) RSA key...", keylength);
		(void)BIO_flush(bio_err);
		if (!RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL)) {
			BIO_printf(bio_err, "Error generating key.");
			RSA_free(rsa_tmp);
			rsa_tmp = NULL;
		}
end:
		BIO_printf(bio_err, "\n");
		(void)BIO_flush(bio_err);
	}
	if (bn)
		BN_free(bn);
		return (rsa_tmp);
}

static void
free_tmp_rsa(void)
{
	if (rsa_tmp != NULL) {
		RSA_free(rsa_tmp);
		rsa_tmp = NULL;
	}
}

#ifndef OPENSSL_NO_DH
/* These DH parameters have been generated as follows:
 *    $ openssl dhparam -C -noout 512
 *    $ openssl dhparam -C -noout 1024
 *    $ openssl dhparam -C -noout -dsaparam 1024
 * (The third function has been renamed to avoid name conflicts.)
 */
static DH *
get_dh512()
{
	static unsigned char dh512_p[] = {
		0xCB, 0xC8, 0xE1, 0x86, 0xD0, 0x1F, 0x94, 0x17, 0xA6, 0x99, 0xF0, 0xC6,
		0x1F, 0x0D, 0xAC, 0xB6, 0x25, 0x3E, 0x06, 0x39, 0xCA, 0x72, 0x04, 0xB0,
		0x6E, 0xDA, 0xC0, 0x61, 0xE6, 0x7A, 0x77, 0x25, 0xE8, 0x3B, 0xB9, 0x5F,
		0x9A, 0xB6, 0xB5, 0xFE, 0x99, 0x0B, 0xA1, 0x93, 0x4E, 0x35, 0x33, 0xB8,
		0xE1, 0xF1, 0x13, 0x4F, 0x59, 0x1A, 0xD2, 0x57, 0xC0, 0x26, 0x21, 0x33,
		0x02, 0xC5, 0xAE, 0x23,
	};
	static unsigned char dh512_g[] = {
		0x02,
	};
	DH *dh;

	if ((dh = DH_new()) == NULL) return (NULL);
		dh->p = BN_bin2bn(dh512_p, sizeof(dh512_p), NULL);
	dh->g = BN_bin2bn(dh512_g, sizeof(dh512_g), NULL);
	if ((dh->p == NULL) || (dh->g == NULL)) {
		DH_free(dh);
		return (NULL);
	}
	return (dh);
}

static DH *
get_dh1024()
{
	static unsigned char dh1024_p[] = {
		0xF8, 0x81, 0x89, 0x7D, 0x14, 0x24, 0xC5, 0xD1, 0xE6, 0xF7, 0xBF, 0x3A,
		0xE4, 0x90, 0xF4, 0xFC, 0x73, 0xFB, 0x34, 0xB5, 0xFA, 0x4C, 0x56, 0xA2,
		0xEA, 0xA7, 0xE9, 0xC0, 0xC0, 0xCE, 0x89, 0xE1, 0xFA, 0x63, 0x3F, 0xB0,
		0x6B, 0x32, 0x66, 0xF1, 0xD1, 0x7B, 0xB0, 0x00, 0x8F, 0xCA, 0x87, 0xC2,
		0xAE, 0x98, 0x89, 0x26, 0x17, 0xC2, 0x05, 0xD2, 0xEC, 0x08, 0xD0, 0x8C,
		0xFF, 0x17, 0x52, 0x8C, 0xC5, 0x07, 0x93, 0x03, 0xB1, 0xF6, 0x2F, 0xB8,
		0x1C, 0x52, 0x47, 0x27, 0x1B, 0xDB, 0xD1, 0x8D, 0x9D, 0x69, 0x1D, 0x52,
		0x4B, 0x32, 0x81, 0xAA, 0x7F, 0x00, 0xC8, 0xDC, 0xE6, 0xD9, 0xCC, 0xC1,
		0x11, 0x2D, 0x37, 0x34, 0x6C, 0xEA, 0x02, 0x97, 0x4B, 0x0E, 0xBB, 0xB1,
		0x71, 0x33, 0x09, 0x15, 0xFD, 0xDD, 0x23, 0x87, 0x07, 0x5E, 0x89, 0xAB,
		0x6B, 0x7C, 0x5F, 0xEC, 0xA6, 0x24, 0xDC, 0x53,
	};
	static unsigned char dh1024_g[] = {
		0x02,
	};
	DH *dh;

	if ((dh = DH_new()) == NULL) return (NULL);
		dh->p = BN_bin2bn(dh1024_p, sizeof(dh1024_p), NULL);
	dh->g = BN_bin2bn(dh1024_g, sizeof(dh1024_g), NULL);
	if ((dh->p == NULL) || (dh->g == NULL)) {
		DH_free(dh);
		return (NULL);
	}
	return (dh);
}

static DH *
get_dh1024dsa()
{
	static unsigned char dh1024_p[] = {
		0xC8, 0x00, 0xF7, 0x08, 0x07, 0x89, 0x4D, 0x90, 0x53, 0xF3, 0xD5, 0x00,
		0x21, 0x1B, 0xF7, 0x31, 0xA6, 0xA2, 0xDA, 0x23, 0x9A, 0xC7, 0x87, 0x19,
		0x3B, 0x47, 0xB6, 0x8C, 0x04, 0x6F, 0xFF, 0xC6, 0x9B, 0xB8, 0x65, 0xD2,
		0xC2, 0x5F, 0x31, 0x83, 0x4A, 0xA7, 0x5F, 0x2F, 0x88, 0x38, 0xB6, 0x55,
		0xCF, 0xD9, 0x87, 0x6D, 0x6F, 0x9F, 0xDA, 0xAC, 0xA6, 0x48, 0xAF, 0xFC,
		0x33, 0x84, 0x37, 0x5B, 0x82, 0x4A, 0x31, 0x5D, 0xE7, 0xBD, 0x52, 0x97,
		0xA1, 0x77, 0xBF, 0x10, 0x9E, 0x37, 0xEA, 0x64, 0xFA, 0xCA, 0x28, 0x8D,
		0x9D, 0x3B, 0xD2, 0x6E, 0x09, 0x5C, 0x68, 0xC7, 0x45, 0x90, 0xFD, 0xBB,
		0x70, 0xC9, 0x3A, 0xBB, 0xDF, 0xD4, 0x21, 0x0F, 0xC4, 0x6A, 0x3C, 0xF6,
		0x61, 0xCF, 0x3F, 0xD6, 0x13, 0xF1, 0x5F, 0xBC, 0xCF, 0xBC, 0x26, 0x9E,
		0xBC, 0x0B, 0xBD, 0xAB, 0x5D, 0xC9, 0x54, 0x39,
	};
	static unsigned char dh1024_g[] = {
		0x3B, 0x40, 0x86, 0xE7, 0xF3, 0x6C, 0xDE, 0x67, 0x1C, 0xCC, 0x80, 0x05,
		0x5A, 0xDF, 0xFE, 0xBD, 0x20, 0x27, 0x74, 0x6C, 0x24, 0xC9, 0x03, 0xF3,
		0xE1, 0x8D, 0xC3, 0x7D, 0x98, 0x27, 0x40, 0x08, 0xB8, 0x8C, 0x6A, 0xE9,
		0xBB, 0x1A, 0x3A, 0xD6, 0x86, 0x83, 0x5E, 0x72, 0x41, 0xCE, 0x85, 0x3C,
		0xD2, 0xB3, 0xFC, 0x13, 0xCE, 0x37, 0x81, 0x9E, 0x4C, 0x1C, 0x7B, 0x65,
		0xD3, 0xE6, 0xA6, 0x00, 0xF5, 0x5A, 0x95, 0x43, 0x5E, 0x81, 0xCF, 0x60,
		0xA2, 0x23, 0xFC, 0x36, 0xA7, 0x5D, 0x7A, 0x4C, 0x06, 0x91, 0x6E, 0xF6,
		0x57, 0xEE, 0x36, 0xCB, 0x06, 0xEA, 0xF5, 0x3D, 0x95, 0x49, 0xCB, 0xA7,
		0xDD, 0x81, 0xDF, 0x80, 0x09, 0x4A, 0x97, 0x4D, 0xA8, 0x22, 0x72, 0xA1,
		0x7F, 0xC4, 0x70, 0x56, 0x70, 0xE8, 0x20, 0x10, 0x18, 0x8F, 0x2E, 0x60,
		0x07, 0xE7, 0x68, 0x1A, 0x82, 0x5D, 0x32, 0xA2,
	};
	DH *dh;

	if ((dh = DH_new()) == NULL) return (NULL);
		dh->p = BN_bin2bn(dh1024_p, sizeof(dh1024_p), NULL);
	dh->g = BN_bin2bn(dh1024_g, sizeof(dh1024_g), NULL);
	if ((dh->p == NULL) || (dh->g == NULL)) {
		DH_free(dh);
		return (NULL);
	}
	dh->length = 160;
	return (dh);
}
#endif

#ifndef OPENSSL_NO_PSK
/* convert the PSK key (psk_key) in ascii to binary (psk) */
static int
psk_key2bn(const char *pskkey, unsigned char *psk, unsigned int max_psk_len)
{
	int ret;
	BIGNUM *bn = NULL;

	ret = BN_hex2bn(&bn, pskkey);
	if (!ret) {
		BIO_printf(bio_err, "Could not convert PSK key '%s' to BIGNUM\n", pskkey);
		if (bn)
			BN_free(bn);
		return 0;
	}
	if (BN_num_bytes(bn) > (int)max_psk_len) {
		BIO_printf(bio_err, "psk buffer of callback is too small (%d) for key (%d)\n",
		max_psk_len, BN_num_bytes(bn));
		BN_free(bn);
		return 0;
	}
	ret = BN_bn2bin(bn, psk);
	BN_free(bn);
	return ret;
}

static unsigned int
psk_client_callback(SSL *ssl, const char *hint, char *identity,
    unsigned int max_identity_len, unsigned char *psk, unsigned int max_psk_len)
{
	int ret;
	unsigned int psk_len = 0;

	ret = snprintf(identity, max_identity_len, "Client_identity");
	if (ret >= max_identity_len || ret == -1)
		goto out_err;
	if (debug)
		fprintf(stderr, "client: created identity '%s' len=%d\n", identity, ret);
	ret = psk_key2bn(psk_key, psk, max_psk_len);
	if (ret < 0)
		goto out_err;
	psk_len = ret;
out_err:
	return psk_len;
}

static unsigned int
psk_server_callback(SSL *ssl, const char *identity, unsigned char *psk,
    unsigned int max_psk_len)
{
	unsigned int psk_len = 0;

	if (strcmp(identity, "Client_identity") != 0) {
		BIO_printf(bio_err, "server: PSK error: client identity not found\n");
		return 0;
	}
	psk_len = psk_key2bn(psk_key, psk, max_psk_len);
	return psk_len;
}
#endif

static int
do_test_cipherlist(void)
{
	int i = 0;
	const SSL_METHOD *meth;
	const SSL_CIPHER *ci, *tci = NULL;

	fprintf(stderr, "testing SSLv3 cipher list order: ");
	meth = SSLv3_method();
	tci = NULL;
	while ((ci = meth->get_cipher(i++)) != NULL) {
		if (tci != NULL)
			if (ci->id >= tci->id) {
				fprintf(stderr, "failed %lx vs. %lx\n", ci->id, tci->id);
			return 0;
		}
		tci = ci;
	}
	fprintf(stderr, "ok\n");
	fprintf(stderr, "testing TLSv1 cipher list order: ");
	meth = TLSv1_method();
	tci = NULL;
	while ((ci = meth->get_cipher(i++)) != NULL) {
		if (tci != NULL)
			if (ci->id >= tci->id) {
				fprintf(stderr, "failed %lx vs. %lx\n", ci->id, tci->id);
			return 0;
		}
		tci = ci;
	}
	fprintf(stderr, "ok\n");

	return 1;
}
@


1.37
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@@


1.36
log
@More KNF and style consistency tweaks
@
text
@a180 3
#ifndef OPENSSL_NO_SRP
#include <openssl/srp.h>
#endif
a226 40
#ifndef OPENSSL_NO_SRP
/* SRP client */
/* This is a context that we pass to all callbacks */
typedef struct srp_client_arg_st {
	char *srppassin;
	char *srplogin;
} SRP_CLIENT_ARG;

#define PWD_STRLEN 1024

static char *
ssl_give_srp_client_pwd_cb(SSL *s, void *arg)
{
	SRP_CLIENT_ARG *srp_client_arg = (SRP_CLIENT_ARG *)arg;
	return BUF_strdup((char *)srp_client_arg->srppassin);
}

/* SRP server */
/* This is a context that we pass to SRP server callbacks */
typedef struct srp_server_arg_st {
	char *expected_user;
	char *pass;
} SRP_SERVER_ARG;

static int
ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
	SRP_SERVER_ARG *p = (SRP_SERVER_ARG *) arg;

	if (strcmp(p->expected_user, SSL_get_srp_username(s)) != 0) {
		fprintf(stderr, "User %s doesn't exist\n", SSL_get_srp_username(s));
		return SSL3_AL_FATAL;
	}
	if (SSL_set_srp_server_param_pw(s, p->expected_user, p->pass, "1024") < 0) {
		*ad = SSL_AD_INTERNAL_ERROR;
		return SSL3_AL_FATAL;
	}
	return SSL_ERROR_NONE;
}
#endif
a270 4
#ifndef OPENSSL_NO_SRP
	fprintf(stderr, " -srpuser user  - SRP username to use\n");
	fprintf(stderr, " -srppass arg   - password for 'user'\n");
#endif
a439 6
#ifndef OPENSSL_NO_SRP
	/* client */
	SRP_CLIENT_ARG srp_client_arg = {NULL, NULL};
	/* server */
	SRP_SERVER_ARG srp_server_arg = {NULL, NULL};
#endif
a526 13
#ifndef OPENSSL_NO_SRP
		else if (strcmp(*argv, "-srpuser") == 0) {
			if (--argc < 1)
				goto bad;
			srp_server_arg.expected_user = srp_client_arg.srplogin= *(++argv);
			tls1 = 1;
		} else if (strcmp(*argv, "-srppass") == 0) {
			if (--argc < 1)
				goto bad;
			srp_server_arg.pass = srp_client_arg.srppassin= *(++argv);
			tls1 = 1;
		}
#endif
a831 17
#ifndef OPENSSL_NO_SRP
	if (srp_client_arg.srplogin) {
		if (!SSL_CTX_set_srp_username(c_ctx, srp_client_arg.srplogin)) {
			BIO_printf(bio_err, "Unable to set SRP username\n");
			goto end;
		}
		SSL_CTX_set_srp_cb_arg(c_ctx, &srp_client_arg);
		SSL_CTX_set_srp_client_pwd_callback(c_ctx, ssl_give_srp_client_pwd_cb);
		/*SSL_CTX_set_srp_strength(c_ctx, srp_client_arg.strength);*/
	}

	if (srp_server_arg.expected_user != NULL) {
		SSL_CTX_set_verify(s_ctx, SSL_VERIFY_NONE, verify_callback);
		SSL_CTX_set_srp_cb_arg(s_ctx, &srp_server_arg);
		SSL_CTX_set_srp_username_callback(s_ctx, ssl_srp_server_param_cb);
	}
#endif
a835 15
#ifndef OPENSSL_NO_KRB5
	if (c_ssl && c_ssl->kssl_ctx) {
		char	localhost[MAXHOSTNAMELEN + 2];

		if (gethostname(localhost, sizeof localhost - 1) == 0) {
			localhost[sizeof localhost - 1] = '\0';
			if (strlen(localhost) == sizeof localhost - 1) {
				BIO_printf(bio_err, "localhost name too long\n");
				goto end;
			}
			kssl_ctx_setstring(c_ssl->kssl_ctx, KSSL_SERVER,
			localhost);
		}
	}
#endif    /* OPENSSL_NO_KRB5  */
@


1.35
log
@delete "string to make the random number generator think it has entropy"
@
text
@d2072 2
a2073 2
static RSA
*tmp_rsa_cb(SSL *s, int is_export, int keylength)
d2115 2
a2116 2
static DH
*get_dh512()
d2141 2
a2142 2
static DH
*get_dh1024()
d2172 2
a2173 2
static DH
*get_dh1024dsa()
@


1.34
log
@no longer need to fool emacs indentation and other if (0) oddities.
@
text
@a283 2
static const char rnd_seed[] = "string to make the random number generator think it has entropy";

a522 2

	RAND_seed(rnd_seed, sizeof rnd_seed);
@


1.33
log
@always build in RSA and DSA. ok deraadt miod
@
text
@d358 1
a358 3
			if (0)
;
			else if (pkey->type == EVP_PKEY_RSA &&
@


1.32
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a175 1
#ifndef OPENSSL_NO_RSA
a176 2
#endif
#ifndef OPENSSL_NO_DSA
a177 1
#endif
a201 1
#ifndef OPENSSL_NO_RSA
a203 1
#endif
a359 1
#ifndef OPENSSL_NO_RSA
a365 2
#endif
#ifndef OPENSSL_NO_DSA
a371 1
#endif
a829 1
#ifndef OPENSSL_NO_RSA
a830 1
#endif
a987 1
#ifndef OPENSSL_NO_RSA
a988 1
#endif
a2075 1
#ifndef OPENSSL_NO_RSA
a2112 1
#endif
@


1.31
log
@unistd.h is always in the same place; no need to #include the result of
a maze of conditional #define's
@
text
@d1604 1
a1604 1
	 * OPENSSL_free()ed twice.  Once when th s_ssl is SSL_free()ed and
@


1.30
log
@add back SRP. i was being too greedy.
@
text
@d190 5
a194 5
#define _XOPEN_SOURCE_EXTENDED	1 /* Or gethostname won't be declared properly
on Compaq platforms (at least with DEC C).
Do not try to put it earlier, or IPv6 includes
get screwed...
				  */
a195 1
#include OPENSSL_UNISTD
@


1.29
log
@disentangle SRP code from TLS
@
text
@d185 3
d237 40
d323 4
d502 6
d597 13
d917 17
@


1.28
log
@remove ssl2 support even more completely.
in the process, always include ssl3 and tls1, we don't need config options
for them. when the time comes to expire ssl3, it will be with an ax.
checked by miod
@
text
@a184 3
#ifndef OPENSSL_NO_SRP
#include <openssl/srp.h>
#endif
a233 40
#ifndef OPENSSL_NO_SRP
/* SRP client */
/* This is a context that we pass to all callbacks */
typedef struct srp_client_arg_st {
	char *srppassin;
	char *srplogin;
} SRP_CLIENT_ARG;

#define PWD_STRLEN 1024

static char *
ssl_give_srp_client_pwd_cb(SSL *s, void *arg)
{
	SRP_CLIENT_ARG *srp_client_arg = (SRP_CLIENT_ARG *)arg;
	return BUF_strdup((char *)srp_client_arg->srppassin);
}

/* SRP server */
/* This is a context that we pass to SRP server callbacks */
typedef struct srp_server_arg_st {
	char *expected_user;
	char *pass;
} SRP_SERVER_ARG;

static int
ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
	SRP_SERVER_ARG *p = (SRP_SERVER_ARG *) arg;

	if (strcmp(p->expected_user, SSL_get_srp_username(s)) != 0) {
		fprintf(stderr, "User %s doesn't exist\n", SSL_get_srp_username(s));
		return SSL3_AL_FATAL;
	}
	if (SSL_set_srp_server_param_pw(s, p->expected_user, p->pass, "1024") < 0) {
		*ad = SSL_AD_INTERNAL_ERROR;
		return SSL3_AL_FATAL;
	}
	return SSL_ERROR_NONE;
}
#endif
a279 4
#ifndef OPENSSL_NO_SRP
	fprintf(stderr, " -srpuser user  - SRP username to use\n");
	fprintf(stderr, " -srppass arg   - password for 'user'\n");
#endif
a454 6
#ifndef OPENSSL_NO_SRP
	/* client */
	SRP_CLIENT_ARG srp_client_arg = {NULL, NULL};
	/* server */
	SRP_SERVER_ARG srp_server_arg = {NULL, NULL};
#endif
a543 13
#ifndef OPENSSL_NO_SRP
		else if (strcmp(*argv, "-srpuser") == 0) {
			if (--argc < 1)
				goto bad;
			srp_server_arg.expected_user = srp_client_arg.srplogin= *(++argv);
			tls1 = 1;
		} else if (strcmp(*argv, "-srppass") == 0) {
			if (--argc < 1)
				goto bad;
			srp_server_arg.pass = srp_client_arg.srppassin= *(++argv);
			tls1 = 1;
		}
#endif
a850 17
#ifndef OPENSSL_NO_SRP
	if (srp_client_arg.srplogin) {
		if (!SSL_CTX_set_srp_username(c_ctx, srp_client_arg.srplogin)) {
			BIO_printf(bio_err, "Unable to set SRP username\n");
			goto end;
		}
		SSL_CTX_set_srp_cb_arg(c_ctx, &srp_client_arg);
		SSL_CTX_set_srp_client_pwd_callback(c_ctx, ssl_give_srp_client_pwd_cb);
		/*SSL_CTX_set_srp_strength(c_ctx, srp_client_arg.strength);*/
	}

	if (srp_server_arg.expected_user != NULL) {
		SSL_CTX_set_verify(s_ctx, SSL_VERIFY_NONE, verify_callback);
		SSL_CTX_set_srp_cb_arg(s_ctx, &srp_server_arg);
		SSL_CTX_set_srp_username_callback(s_ctx, ssl_srp_server_param_cb);
	}
#endif
@


1.27
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok miod
@
text
@a326 4
#ifndef OPENSSL_NO_SSL2
	fprintf(stderr, " -ssl2         - use SSLv2\n");
#endif
#ifndef OPENSSL_NO_SSL3
a327 2
#endif
#ifndef OPENSSL_NO_TLS1
a328 1
#endif
a773 11
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
	if (ssl2)
		meth = SSLv2_method();
	else if (tls1)
		meth = TLSv1_method();
	else if (ssl3)
		meth = SSLv3_method();
	else
		meth = SSLv23_method();
#else
#ifdef OPENSSL_NO_SSL2
a779 4
#else
	meth = SSLv2_method();
#endif
#endif
a2305 14
#ifndef OPENSSL_NO_SSL2
	fprintf(stderr, "testing SSLv2 cipher list order: ");
	meth = SSLv2_method();
	while ((ci = meth->get_cipher(i++)) != NULL) {
		if (tci != NULL)
			if (ci->id >= tci->id) {
			fprintf(stderr, "failed %lx vs. %lx\n", ci->id, tci->id);
			return 0;
		}
		tci = ci;
	}
	fprintf(stderr, "ok\n");
#endif
#ifndef OPENSSL_NO_SSL3
a2317 2
#endif
#ifndef OPENSSL_NO_TLS1
a2329 1
#endif
@


1.26
log
@Flense all use of BIO_snprintf from ssl source - use the real one instead,
and allow for the normal posix mandated return values instead of the
nonstandard one from BIO_snprintf.
ok miod@@
@
text
@a301 3
#ifdef OPENSSL_FIPS
	fprintf(stderr, "-F             - run test in FIPS mode\n");
#endif
a525 3
#ifdef OPENSSL_FIPS
	int fips_mode = 0;
#endif
a554 3
#ifdef OPENSSL_FIPS
			fips_mode = 1;
#else
a556 1
#endif
a730 11

#ifdef OPENSSL_FIPS
	if (fips_mode) {
		if (!FIPS_mode_set(1)) {
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr, BIO_NOCLOSE));
			exit(1);
		} else
			fprintf(stderr, "*** IN FIPS MODE ***\n");
	}
#endif
@


1.25
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d1823 2
a1824 2
	BIO_snprintf(my_format, sizeof(my_format), "%*.*s %s",
	indent, indent, indentation, format);
d2314 2
a2315 2
	ret = BIO_snprintf(identity, max_identity_len, "Client_identity");
	if (ret < 0)
@


1.24
log
@Flense a variety of windows support stuff, and a strange gettimeofday function.
ok deraadt@@
@
text
@d191 3
a193 3
				     on Compaq platforms (at least with DEC C).
				     Do not try to put it earlier, or IPv6 includes
				     get screwed...
d208 1
a208 1
static RSA *tmp_rsa_cb(SSL *s, int is_export,int keylength);
d213 1
a213 2
struct app_verify_arg
	{
d219 1
a219 1
	};
d228 1
a228 1
static char *psk_key=NULL; /* by default PSK is not used */
d230 5
a234 5
static unsigned int psk_client_callback(SSL *ssl, const char *hint, char *identity,
	unsigned int max_identity_len, unsigned char *psk,
	unsigned int max_psk_len);
static unsigned int psk_server_callback(SSL *ssl, const char *identity, unsigned char *psk,
	unsigned int max_psk_len);
d240 1
a240 2
typedef struct srp_client_arg_st
	{
d243 1
a243 1
	} SRP_CLIENT_ARG;
d247 3
a249 2
static char * ssl_give_srp_client_pwd_cb(SSL *s, void *arg)
	{
d252 1
a252 1
	}
d256 1
a256 2
typedef struct srp_server_arg_st
	{
d259 1
a259 1
	} SRP_SERVER_ARG;
d261 4
a264 3
static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
	{
	SRP_SERVER_ARG * p = (SRP_SERVER_ARG *) arg;
d266 1
a266 2
	if (strcmp(p->expected_user, SSL_get_srp_username(s)) != 0)
		{
d269 2
a270 3
		}
	if (SSL_set_srp_server_param_pw(s,p->expected_user,p->pass,"1024")<0)
		{
d273 1
a273 1
		}
d275 1
a275 1
	}
d278 2
a279 2
static BIO *bio_err=NULL;
static BIO *bio_stdout=NULL;
d281 3
a283 3
static char *cipher=NULL;
static int verbose=0;
static int debug=0;
d287 1
a287 1
static int s_nbio=0;
d293 2
a294 2
int doit_biopair(SSL *s_ssl,SSL *c_ssl,long bytes,clock_t *s_time,clock_t *c_time);
int doit(SSL *s_ssl,SSL *c_ssl,long bytes);
d296 6
a301 4
static void sv_usage(void)
	{
	fprintf(stderr,"usage: ssltest [args ...]\n");
	fprintf(stderr,"\n");
d303 1
a303 1
	fprintf(stderr,"-F             - run test in FIPS mode\n");
d305 10
a314 10
	fprintf(stderr," -server_auth  - check server certificate\n");
	fprintf(stderr," -client_auth  - do client authentication\n");
	fprintf(stderr," -proxy        - allow proxy certificates\n");
	fprintf(stderr," -proxy_auth <val> - set proxy policy rights\n");
	fprintf(stderr," -proxy_cond <val> - experssion to test proxy policy rights\n");
	fprintf(stderr," -v            - more output\n");
	fprintf(stderr," -d            - debug output\n");
	fprintf(stderr," -reuse        - use session-id reuse\n");
	fprintf(stderr," -num <val>    - number of connections to perform\n");
	fprintf(stderr," -bytes <val>  - number of bytes to swap between client/server\n");
d316 3
a318 3
	fprintf(stderr," -dhe1024      - use 1024 bit key (safe prime) for DHE\n");
	fprintf(stderr," -dhe1024dsa   - use 1024 bit key (with 160-bit subprime) for DHE\n");
	fprintf(stderr," -no_dhe       - disable DHE\n");
d321 1
a321 1
	fprintf(stderr," -no_ecdhe     - disable ECDHE\n");
d324 1
a324 1
	fprintf(stderr," -psk arg      - PSK in hex (without 0x)\n");
d327 2
a328 2
	fprintf(stderr," -srpuser user  - SRP username to use\n");
	fprintf(stderr," -srppass arg   - password for 'user'\n");
d331 1
a331 1
	fprintf(stderr," -ssl2         - use SSLv2\n");
d334 1
a334 1
	fprintf(stderr," -ssl3         - use SSLv3\n");
d337 1
a337 1
	fprintf(stderr," -tls1         - use TLSv1\n");
d339 12
a350 12
	fprintf(stderr," -CApath arg   - PEM format directory of CA's\n");
	fprintf(stderr," -CAfile arg   - PEM format file of CA's\n");
	fprintf(stderr," -cert arg     - Server certificate file\n");
	fprintf(stderr," -key arg      - Server key file (default: same as -cert)\n");
	fprintf(stderr," -c_cert arg   - Client certificate file\n");
	fprintf(stderr," -c_key arg    - Client key file (default: same as -c_cert)\n");
	fprintf(stderr," -cipher arg   - The cipher list\n");
	fprintf(stderr," -bio_pair     - Use BIO pairs\n");
	fprintf(stderr," -f            - Test even cases that can't work\n");
	fprintf(stderr," -time         - measure processor time used by client and server\n");
	fprintf(stderr," -zlib         - use zlib compression\n");
	fprintf(stderr," -rle          - use rle compression\n");
d352 1
a352 1
	fprintf(stderr," -named_curve arg  - Elliptic curve name to use for ephemeral ECDH keys.\n" \
d356 2
a357 2
	fprintf(stderr," -test_cipherlist - verifies the order of the ssl cipher lists\n");
	}
d359 3
a361 2
static void print_details(SSL *c_ssl, const char *prefix)
	{
d364 9
a372 10
		
	ciph=SSL_get_current_cipher(c_ssl);
	BIO_printf(bio_stdout,"%s%s, cipher %s %s",
		prefix,
		SSL_get_version(c_ssl),
		SSL_CIPHER_get_version(ciph),
		SSL_CIPHER_get_name(ciph));
	cert=SSL_get_peer_certificate(c_ssl);
	if (cert != NULL)
		{
d374 3
a376 4
		if (pkey != NULL)
			{
			if (0) 
				;
d378 3
a380 3
			else if (pkey->type == EVP_PKEY_RSA && pkey->pkey.rsa != NULL
				&& pkey->pkey.rsa->n != NULL)
				{
d382 2
a383 2
					BN_num_bits(pkey->pkey.rsa->n));
				}
d386 3
a388 3
			else if (pkey->type == EVP_PKEY_DSA && pkey->pkey.dsa != NULL
				&& pkey->pkey.dsa->p != NULL)
				{
d390 2
a391 2
					BN_num_bits(pkey->pkey.dsa->p));
				}
d394 1
a394 1
			}
d396 1
a396 1
		}
d399 2
a400 2
	BIO_printf(bio_stdout,"\n");
	}
d402 3
a404 2
static void lock_dbg_cb(int mode, int type, const char *file, int line)
	{
d408 1
a408 1
	
d410 1
a410 2
	if (!((rw == CRYPTO_READ) || (rw == CRYPTO_WRITE)))
		{
d413 1
a413 1
		}
d415 1
a415 2
	if (type < 0 || type >= CRYPTO_NUM_LOCKS)
		{
d418 1
a418 1
		}
d420 2
a421 4
	if (mode & CRYPTO_LOCK)
		{
		if (modes[type])
			{
d426 1
a426 1
			}
d429 2
a430 5
		}
	else if (mode & CRYPTO_UNLOCK)
		{
		if (!modes[type])
			{
d433 3
a435 4
			}
		
		if (modes[type] != rw)
			{
d437 3
a439 3
				"CRYPTO_r_unlock on write lock" :
				"CRYPTO_w_unlock on read lock";
			}
d442 1
a442 3
		}
	else
		{
d445 1
a445 1
		}
d447 2
a448 3
 err:
	if (errstr)
		{
d451 1
a451 2
			errstr, mode, type, file, line);
		}
d453 1
d456 5
a460 1
struct cb_info_st { void *input; size_t len; int ret; };
d466 3
a468 2
int opaque_prf_input_cb(SSL *ssl, void *peerinput, size_t len, void *arg_)
	{
d473 1
a473 1
	
d477 1
a477 1
	}
d480 10
a489 9
int main(int argc, char *argv[])
	{
	char *CApath=NULL,*CAfile=NULL;
	int badop=0;
	int bio_pair=0;
	int force=0;
	int tls1=0,ssl2=0,ssl3=0,ret=1;
	int client_auth=0;
	int server_auth=0,i;
d491 5
a495 5
		{ APP_CALLBACK_STRING, 0, 0, NULL, NULL };
	char *server_cert=TEST_SERVER_CERT;
	char *server_key=NULL;
	char *client_cert=TEST_CLIENT_CERT;
	char *client_key=NULL;
d499 6
a504 6
	SSL_CTX *s_ctx=NULL;
	SSL_CTX *c_ctx=NULL;
	const SSL_METHOD *meth=NULL;
	SSL *c_ssl,*s_ssl;
	int number=1,reuse=0;
	long bytes=256L;
d514 1
a514 1
	SRP_CLIENT_ARG srp_client_arg = {NULL,NULL};
d516 1
a516 1
	SRP_SERVER_ARG srp_server_arg = {NULL,NULL};
d530 1
a530 1
	int fips_mode=0;
d537 2
a538 1
	bio_err=BIO_new_fp(stderr,BIO_NOCLOSE|BIO_FP_TEXT);	
d543 1
a543 2
	if (!((getenv("OPENSSL_DEBUG_MEMORY") != NULL) && (0 == strcmp(getenv("OPENSSL_DEBUG_MEMORY"), "off"))))
		{
d546 1
a546 3
		}
	else
		{
d549 1
a549 1
		}
d554 1
a554 1
	bio_stdout=BIO_new_fp(stdout,BIO_NOCLOSE|BIO_FP_TEXT);
d559 2
a560 4
	while (argc >= 1)
		{
		if(!strcmp(*argv,"-F"))
			{
d562 1
a562 1
			fips_mode=1;
d564 1
a564 1
			fprintf(stderr,"not compiled with FIPS support, so exitting without running.\n");
d567 7
a573 8
			}
		else if (strcmp(*argv,"-server_auth") == 0)
			server_auth=1;
		else if	(strcmp(*argv,"-client_auth") == 0)
			client_auth=1;
		else if (strcmp(*argv,"-proxy_auth") == 0)
			{
			if (--argc < 1) goto bad;
d575 3
a577 4
			}
		else if (strcmp(*argv,"-proxy_cond") == 0)
			{
			if (--argc < 1) goto bad;
d579 7
a585 9
			}
		else if	(strcmp(*argv,"-v") == 0)
			verbose=1;
		else if	(strcmp(*argv,"-d") == 0)
			debug=1;
		else if	(strcmp(*argv,"-reuse") == 0)
			reuse=1;
		else if	(strcmp(*argv,"-dhe1024") == 0)
			{
d587 1
a587 1
			dhe1024=1;
d589 1
a589 1
			fprintf(stderr,"ignoring -dhe1024, since I'm compiled without DH\n");
d591 1
a591 3
			}
		else if	(strcmp(*argv,"-dhe1024dsa") == 0)
			{
d593 1
a593 1
			dhe1024dsa=1;
d595 1
a595 1
			fprintf(stderr,"ignoring -dhe1024, since I'm compiled without DH\n");
d597 7
a603 8
			}
		else if	(strcmp(*argv,"-no_dhe") == 0)
			no_dhe=1;
		else if	(strcmp(*argv,"-no_ecdhe") == 0)
			no_ecdhe=1;
		else if (strcmp(*argv,"-psk") == 0)
			{
			if (--argc < 1) goto bad;
d606 2
a607 3
			if (strspn(psk_key, "abcdefABCDEF1234567890") != strlen(psk_key))
				{
				BIO_printf(bio_err,"Not a hex number '%s'\n",*argv);
d609 1
a609 1
				}
d611 1
a611 1
			no_psk=1;
d613 1
a613 1
			}
d615 3
a617 3
		else if (strcmp(*argv,"-srpuser") == 0)
			{
			if (--argc < 1) goto bad;
d619 4
a622 5
			tls1=1;
			}
		else if (strcmp(*argv,"-srppass") == 0)
			{
			if (--argc < 1) goto bad;
d624 2
a625 2
			tls1=1;
			}
d627 26
a652 24
		else if	(strcmp(*argv,"-ssl2") == 0)
			ssl2=1;
		else if	(strcmp(*argv,"-tls1") == 0)
			tls1=1;
		else if	(strcmp(*argv,"-ssl3") == 0)
			ssl3=1;
		else if	(strncmp(*argv,"-num",4) == 0)
			{
			if (--argc < 1) goto bad;
			number= atoi(*(++argv));
			if (number == 0) number=1;
			}
		else if	(strcmp(*argv,"-bytes") == 0)
			{
			if (--argc < 1) goto bad;
			bytes= atol(*(++argv));
			if (bytes == 0L) bytes=1L;
			i=strlen(argv[0]);
			if (argv[0][i-1] == 'k') bytes*=1024L;
			if (argv[0][i-1] == 'm') bytes*=1024L*1024L;
			}
		else if	(strcmp(*argv,"-cert") == 0)
			{
			if (--argc < 1) goto bad;
d654 3
a656 4
			}
		else if	(strcmp(*argv,"-s_cert") == 0)
			{
			if (--argc < 1) goto bad;
d658 3
a660 4
			}
		else if	(strcmp(*argv,"-key") == 0)
			{
			if (--argc < 1) goto bad;
d662 3
a664 4
			}
		else if	(strcmp(*argv,"-s_key") == 0)
			{
			if (--argc < 1) goto bad;
d666 3
a668 4
			}
		else if	(strcmp(*argv,"-c_cert") == 0)
			{
			if (--argc < 1) goto bad;
d670 3
a672 4
			}
		else if	(strcmp(*argv,"-c_key") == 0)
			{
			if (--argc < 1) goto bad;
d674 3
a676 4
			}
		else if	(strcmp(*argv,"-cipher") == 0)
			{
			if (--argc < 1) goto bad;
d678 3
a680 4
			}
		else if	(strcmp(*argv,"-CApath") == 0)
			{
			if (--argc < 1) goto bad;
d682 3
a684 4
			}
		else if	(strcmp(*argv,"-CAfile") == 0)
			{
			if (--argc < 1) goto bad;
d686 1
a686 3
			}
		else if	(strcmp(*argv,"-bio_pair") == 0)
			{
d688 1
a688 3
			}
		else if	(strcmp(*argv,"-f") == 0)
			{
d690 1
a690 3
			}
		else if	(strcmp(*argv,"-time") == 0)
			{
d692 1
a692 3
			}
		else if	(strcmp(*argv,"-zlib") == 0)
			{
d694 1
a694 3
			}
		else if	(strcmp(*argv,"-rle") == 0)
			{
d696 3
a698 4
			}
		else if	(strcmp(*argv,"-named_curve") == 0)
			{
			if (--argc < 1) goto bad;
d702 1
a702 1
			fprintf(stderr,"ignoring -named_curve, since I'm compiled without ECDH\n");
d705 1
a705 3
			}
		else if	(strcmp(*argv,"-app_verify") == 0)
			{
d707 1
a707 3
			}
		else if	(strcmp(*argv,"-proxy") == 0)
			{
d709 1
a709 3
			}
		else if (strcmp(*argv,"-test_cipherlist") == 0)
			{
d711 3
a713 5
			}
		else
			{
			fprintf(stderr,"unknown option %s\n",*argv);
			badop=1;
d715 1
a715 1
			}
d718 2
a719 3
		}
	if (badop)
		{
d723 1
a723 1
		}
d725 1
a725 2
	if (test_cipherlist == 1)
		{
d731 1
a731 1
		}
d733 6
a738 6
	if (!ssl2 && !ssl3 && !tls1 && number > 1 && !reuse && !force)
		{
		fprintf(stderr, "This case cannot work.  Use -f to perform "
			"the test anyway (and\n-d to see what happens), "
			"or add one of -ssl2, -ssl3, -tls1, -reuse\n"
			"to avoid protocol mismatch.\n");
d740 1
a740 1
		}
d743 2
a744 4
	if(fips_mode)
		{
		if(!FIPS_mode_set(1))
			{
d746 1
a746 1
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
d748 3
a750 4
			}
		else
			fprintf(stderr,"*** IN FIPS MODE ***\n");
		}
d753 2
a754 4
	if (print_time)
		{
		if (!bio_pair)
			{
d757 1
a757 1
			}
d760 1
a760 1
		}
d768 7
a774 8
	if (comp == COMP_ZLIB) cm = COMP_zlib();
	if (comp == COMP_RLE) cm = COMP_rle();
	if (cm != NULL)
		{
		if (cm->type != NID_undef)
			{
			if (SSL_COMP_add_compression_method(comp, cm) != 0)
				{
d776 1
a776 1
					"Failed to add compression method\n");
a777 1
				}
d779 1
a779 2
		else
			{
d781 4
a784 4
				"Warning: %s compression not supported\n",
				(comp == COMP_RLE ? "rle" :
					(comp == COMP_ZLIB ? "zlib" :
						"unknown")));
a785 1
			}
d787 1
d791 7
a797 8
	int j, n = sk_SSL_COMP_num(ssl_comp_methods);
	if (n == 0)
		fprintf(stderr, "  NONE\n");
	else
		for (j = 0; j < n; j++)
			{
			SSL_COMP *c = sk_SSL_COMP_value(ssl_comp_methods, j);
			fprintf(stderr, "  %d: %s\n", c->id, c->name);
d804 5
a808 7
		meth=SSLv2_method();
	else 
	if (tls1)
		meth=TLSv1_method();
	else
	if (ssl3)
		meth=SSLv3_method();
d810 1
a810 1
		meth=SSLv23_method();
d814 3
a816 4
		meth=TLSv1_method();
	else
	if (ssl3)
		meth=SSLv3_method();
d818 1
a818 1
		meth=SSLv23_method();
d820 1
a820 1
	meth=SSLv2_method();
d824 3
a826 4
	c_ctx=SSL_CTX_new(meth);
	s_ctx=SSL_CTX_new(meth);
	if ((c_ctx == NULL) || (s_ctx == NULL))
		{
d829 1
a829 1
		}
d831 4
a834 5
	if (cipher != NULL)
		{
		SSL_CTX_set_cipher_list(c_ctx,cipher);
		SSL_CTX_set_cipher_list(s_ctx,cipher);
		}
d837 2
a838 4
	if (!no_dhe)
		{
		if (dhe1024dsa)
			{
d841 3
a843 4
			dh=get_dh1024dsa();
			}
		else if (dhe1024)
			dh=get_dh1024();
d845 2
a846 2
			dh=get_dh512();
		SSL_CTX_set_tmp_dh(s_ctx,dh);
d848 1
a848 1
		}
d854 1
a854 2
	if (!no_ecdhe)
		{
d857 1
a857 2
		if (named_curve != NULL)
			{
d859 1
a859 2
			if (nid == 0)
			{
a861 1
				}
d863 1
a863 1
		else
d865 1
a865 1
			nid = NID_X9_62_prime256v1;
d867 1
a867 1
			nid = NID_sect163r2;
d871 1
a871 2
		if (ecdh == NULL)
			{
d874 1
a874 1
			}
d879 1
a879 1
		}
d885 1
a885 1
	SSL_CTX_set_tmp_rsa_callback(s_ctx,tmp_rsa_cb);
d895 1
a895 2
	if (!SSL_CTX_use_certificate_file(s_ctx,server_cert,SSL_FILETYPE_PEM))
		{
d897 2
a898 4
		}
	else if (!SSL_CTX_use_PrivateKey_file(s_ctx,
		(server_key?server_key:server_cert), SSL_FILETYPE_PEM))
		{
d901 1
a901 1
		}
d903 3
a905 4
	if (client_auth)
		{
		SSL_CTX_use_certificate_file(c_ctx,client_cert,
			SSL_FILETYPE_PEM);
d907 3
a909 3
			(client_key?client_key:client_cert),
			SSL_FILETYPE_PEM);
		}
d911 4
a914 5
	if (	(!SSL_CTX_load_verify_locations(s_ctx,CAfile,CApath)) ||
		(!SSL_CTX_set_default_verify_paths(s_ctx)) ||
		(!SSL_CTX_load_verify_locations(c_ctx,CAfile,CApath)) ||
		(!SSL_CTX_set_default_verify_paths(c_ctx)))
		{
d918 1
a918 1
		}
d920 2
a921 3
	if (client_auth)
		{
		BIO_printf(bio_err,"client authentication\n");
d923 2
a924 2
			SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
			verify_callback);
d926 5
a930 6
		}
	if (server_auth)
		{
		BIO_printf(bio_err,"server authentication\n");
		SSL_CTX_set_verify(c_ctx,SSL_VERIFY_PEER,
			verify_callback);
d932 2
a933 2
		}
	
d940 1
a940 2
	if (psk_key != NULL)
		{
d942 1
a942 2
		if (no_psk)
			{
d945 1
a945 1
			ret=0;
d947 1
a947 1
			}
d952 3
a954 4
			BIO_printf(bio_err,"setting PSK identity hint to s_ctx\n");
		if (!SSL_CTX_use_psk_identity_hint(s_ctx, "ctx server identity_hint"))
			{
			BIO_printf(bio_err,"error setting PSK identity hint to s_ctx\n");
d957 1
a957 1
			}
d959 1
a959 1
		}
d961 3
a963 5
        if (srp_client_arg.srplogin)
		{
		if (!SSL_CTX_set_srp_username(c_ctx, srp_client_arg.srplogin))
			{
			BIO_printf(bio_err,"Unable to set SRP username\n");
d965 2
a966 2
			}
		SSL_CTX_set_srp_cb_arg(c_ctx,&srp_client_arg);
d969 1
a969 1
		}
d971 2
a972 3
	if (srp_server_arg.expected_user != NULL)
		{
		SSL_CTX_set_verify(s_ctx,SSL_VERIFY_NONE,verify_callback);
d975 1
a975 1
		}
d978 2
a979 2
	c_ssl=SSL_new(c_ctx);
	s_ssl=SSL_new(s_ctx);
d982 7
a988 10
	if (c_ssl  &&  c_ssl->kssl_ctx)
                {
                char	localhost[MAXHOSTNAMELEN+2];

		if (gethostname(localhost, sizeof localhost-1) == 0)
                        {
			localhost[sizeof localhost-1]='\0';
			if(strlen(localhost) == sizeof localhost-1)
				{
				BIO_printf(bio_err,"localhost name too long\n");
d990 1
a990 1
				}
d992 1
a992 2
                                localhost);
			}
d994 1
d997 3
a999 3
	for (i=0; i<number; i++)
		{
		if (!reuse) SSL_set_session(c_ssl,NULL);
d1001 1
a1001 1
			ret=doit_biopair(s_ssl,c_ssl,bytes,&s_time,&c_time);
d1003 2
a1004 2
			ret=doit(s_ssl,c_ssl,bytes);
		}
d1006 1
a1006 2
	if (!verbose)
		{
d1008 1
a1008 1
		}
d1010 2
a1011 3
		BIO_printf(bio_stdout, "%d handshakes of %ld bytes done\n",number,bytes);
	if (print_time)
		{
d1018 3
a1020 3
			"Approximate total client time: %6.2f s\n",
			(double)s_time/CLOCKS_PER_SEC,
			(double)c_time/CLOCKS_PER_SEC);
d1025 4
a1028 4
			"Approximate total server time: %6.2f units\n"
			"Approximate total client time: %6.2f units\n",
			(double)s_time,
			(double)c_time);
d1030 1
a1030 1
		}
d1036 4
a1039 2
	if (s_ctx != NULL) SSL_CTX_free(s_ctx);
	if (c_ctx != NULL) SSL_CTX_free(c_ctx);
d1041 2
a1042 1
	if (bio_stdout != NULL) BIO_free(bio_stdout);
d1055 2
a1056 1
	if (bio_err != NULL) BIO_free(bio_err);
d1059 1
a1059 1
	}
d1061 4
a1064 3
int doit_biopair(SSL *s_ssl, SSL *c_ssl, long count,
	clock_t *s_time, clock_t *c_time)
	{
d1069 1
a1069 1
	
d1076 1
a1076 1
	
d1093 1
a1093 2
	do
		{
d1134 1
a1134 1
			{
d1136 1
a1136 1
		
d1146 1
a1146 1
						SSL_state_string_long(c_ssl));
d1148 1
a1148 2
			if (cw_num > 0)
				{
d1150 1
a1150 1
				
d1156 3
a1158 5
				if (r < 0)
					{
					if (!BIO_should_retry(c_ssl_bio))
						{
						fprintf(stderr,"ERROR in CLIENT\n");
d1160 1
a1160 1
						}
d1165 2
a1166 4
					}
				else if (r == 0)
					{
					fprintf(stderr,"SSL CLIENT STARTUP FAILED\n");
d1168 1
a1168 3
					}
				else
					{
d1171 2
a1172 2
					cw_num -= r;				
					}
d1174 1
d1176 1
a1176 2
			if (cr_num > 0)
				{
d1180 3
a1182 5
				if (r < 0)
					{
					if (!BIO_should_retry(c_ssl_bio))
						{
						fprintf(stderr,"ERROR in CLIENT\n");
d1184 1
a1184 1
						}
d1186 2
a1187 4
					}
				else if (r == 0)
					{
					fprintf(stderr,"SSL CLIENT STARTUP FAILED\n");
d1189 1
a1189 3
					}
				else
					{
a1192 1
					}
d1194 1
d1205 1
a1205 1
			}
d1207 1
a1207 1
			{
d1209 1
a1209 1
		
d1219 1
a1219 1
						SSL_state_string_long(s_ssl));
d1221 1
a1221 2
			if (sw_num > 0)
				{
d1223 1
a1223 1
				
d1229 3
a1231 5
				if (r < 0)
					{
					if (!BIO_should_retry(s_ssl_bio))
						{
						fprintf(stderr,"ERROR in SERVER\n");
d1233 1
a1233 1
						}
d1235 2
a1236 4
					}
				else if (r == 0)
					{
					fprintf(stderr,"SSL SERVER STARTUP FAILED\n");
d1238 1
a1238 3
					}
				else
					{
d1241 2
a1242 2
					sw_num -= r;				
					}
d1244 1
d1246 1
a1246 2
			if (sr_num > 0)
				{
d1250 3
a1252 5
				if (r < 0)
					{
					if (!BIO_should_retry(s_ssl_bio))
						{
						fprintf(stderr,"ERROR in SERVER\n");
d1254 1
a1254 1
						}
d1256 2
a1257 4
					}
				else if (r == 0)
					{
					fprintf(stderr,"SSL SERVER STARTUP FAILED\n");
d1259 1
a1259 3
					}
				else
					{
a1262 1
					}
d1264 1
d1267 3
a1269 3
			}
			
			{
d1277 1
a1277 1
			
d1280 1
a1280 1
			
d1283 1
a1283 1
				{
d1293 1
a1293 2
				if (num)
					{
d1298 1
a1298 1
					
d1306 1
a1306 1
						{
d1308 1
a1308 1
							"BIO_ctrl_get_write_guarantee() bytes");
d1310 1
a1310 1
						}
d1315 3
a1317 4
							"C->S relaying: %d bytes\n" :
							"S->C relaying: %d bytes\n",
							(int)num);
					}
d1319 1
a1319 1
			while (r1 && r2);
d1335 1
a1335 2
				if (num)
					{
d1337 1
a1337 1
					
d1343 1
a1343 1
					
d1350 1
a1350 1
						{
d1352 1
a1352 1
							"BIO_ctrl_pending() bytes");
d1354 1
a1354 1
						}
d1358 1
a1358 1
						{
d1360 1
a1360 1
							"BIO_nwrite0() bytes");
d1362 2
a1363 2
						}
					
d1366 4
a1369 4
							"C->S relaying: %d bytes\n" :
							"S->C relaying: %d bytes\n",
							(int)num);
					}
d1373 10
a1382 17
				if (cw_num > 0 || cr_num > 0 || sw_num > 0 || sr_num > 0)
					{
					fprintf(stderr, "ERROR: got stuck\n");
					if (strcmp("SSLv2", SSL_get_version(c_ssl)) == 0)
						{
						fprintf(stderr, "This can happen for SSL2 because "
							"CLIENT-FINISHED and SERVER-VERIFY are written \n"
							"concurrently ...");
						if (strncmp("2SCF", SSL_state_string(c_ssl), 4) == 0
							&& strncmp("2SSV", SSL_state_string(s_ssl), 4) == 0)
							{
							fprintf(stderr, " ok.\n");
							goto end;
							}
						}
					fprintf(stderr, " ERROR.\n");
					goto err;
d1384 4
a1388 1
			}
d1390 1
a1390 1
	while (cw_num > 0 || cr_num > 0 || sw_num > 0 || sr_num > 0);
d1397 1
a1397 1
 err:
d1399 1
a1399 1
	
d1414 1
a1414 1
	}
d1422 23
a1444 23
int doit(SSL *s_ssl, SSL *c_ssl, long count)
	{
	char cbuf[1024*8],sbuf[1024*8];
	long cw_num=count,cr_num=count;
	long sw_num=count,sr_num=count;
	int ret=1;
	BIO *c_to_s=NULL;
	BIO *s_to_c=NULL;
	BIO *c_bio=NULL;
	BIO *s_bio=NULL;
	int c_r,c_w,s_r,s_w;
	int i,j;
	int done=0;
	int c_write,s_write;
	int do_server=0,do_client=0;

	memset(cbuf,0,sizeof(cbuf));
	memset(sbuf,0,sizeof(sbuf));

	c_to_s=BIO_new(BIO_s_mem());
	s_to_c=BIO_new(BIO_s_mem());
	if ((s_to_c == NULL) || (c_to_s == NULL))
		{
d1447 1
a1447 1
		}
d1449 3
a1451 4
	c_bio=BIO_new(BIO_f_ssl());
	s_bio=BIO_new(BIO_f_ssl());
	if ((c_bio == NULL) || (s_bio == NULL))
		{
d1454 1
a1454 1
		}
d1457 2
a1458 2
	SSL_set_bio(c_ssl,s_to_c,c_to_s);
	BIO_set_ssl(c_bio,c_ssl,BIO_NOCLOSE);
d1461 2
a1462 2
	SSL_set_bio(s_ssl,c_to_s,s_to_c);
	BIO_set_ssl(s_bio,s_ssl,BIO_NOCLOSE);
d1464 5
a1468 3
	c_r=0; s_r=1;
	c_w=1; s_w=0;
	c_write=1,s_write=0;
d1471 11
a1481 10
	for (;;)
		{
		do_server=0;
		do_client=0;

		i=(int)BIO_pending(s_bio);
		if ((i && s_r) || s_w) do_server=1;

		i=(int)BIO_pending(c_bio);
		if ((i && c_r) || c_w) do_client=1;
d1483 1
a1483 2
		if (do_server && debug)
			{
d1486 1
a1486 1
					SSL_state_string_long(s_ssl));
d1491 1
a1491 1
			}
d1493 1
a1493 2
		if (do_client && debug)
			{
d1496 1
a1496 1
					SSL_state_string_long(c_ssl));
d1501 1
a1501 1
			}
d1503 2
a1504 3
		if (!do_client && !do_server)
			{
			fprintf(stdout,"ERROR IN STARTUP\n");
d1507 3
a1509 5
			}
		if (do_client && !(done & C_DONE))
			{
			if (c_write)
				{
d1511 6
a1516 8
					(int)sizeof(cbuf) : (int)cw_num;
				i=BIO_write(c_bio,cbuf,j);
				if (i < 0)
					{
					c_r=0;
					c_w=0;
					if (BIO_should_retry(c_bio))
						{
d1518 1
a1518 1
							c_r=1;
d1520 3
a1522 5
							c_w=1;
						}
					else
						{
						fprintf(stderr,"ERROR in CLIENT\n");
a1524 1
						}
d1526 2
a1527 3
				else if (i == 0)
					{
					fprintf(stderr,"SSL CLIENT STARTUP FAILED\n");
d1529 1
a1529 3
					}
				else
					{
d1531 1
a1531 1
						printf("client wrote %d\n",i);
d1533 10
a1542 14
					s_r=1;
					c_write=0;
					cw_num-=i;
					}
				}
			else
				{
				i=BIO_read(c_bio,cbuf,sizeof(cbuf));
				if (i < 0)
					{
					c_r=0;
					c_w=0;
					if (BIO_should_retry(c_bio))
						{
d1544 1
a1544 1
							c_r=1;
d1546 3
a1548 5
							c_w=1;
						}
					else
						{
						fprintf(stderr,"ERROR in CLIENT\n");
a1550 1
						}
d1552 2
a1553 3
				else if (i == 0)
					{
					fprintf(stderr,"SSL CLIENT STARTUP FAILED\n");
d1555 7
d1563 4
a1566 16
				else
					{
					if (debug)
						printf("client read %d\n",i);
					cr_num-=i;
					if (sw_num > 0)
						{
						s_write=1;
						s_w=1;
						}
					if (cr_num <= 0)
						{
						s_write=1;
						s_w=1;
						done=S_DONE|C_DONE;
						}
d1570 1
d1572 7
a1578 11
		if (do_server && !(done & S_DONE))
			{
			if (!s_write)
				{
				i=BIO_read(s_bio,sbuf,sizeof(cbuf));
				if (i < 0)
					{
					s_r=0;
					s_w=0;
					if (BIO_should_retry(s_bio))
						{
d1580 1
a1580 1
							s_r=1;
d1582 3
a1584 5
							s_w=1;
						}
					else
						{
						fprintf(stderr,"ERROR in SERVER\n");
a1586 1
						}
d1588 1
a1588 2
				else if (i == 0)
					{
d1590 1
a1590 1
					fprintf(stderr,"SSL SERVER STARTUP FAILED in SSL_read\n");
d1592 1
a1592 3
					}
				else
					{
d1594 10
a1603 13
						printf("server read %d\n",i);
					sr_num-=i;
					if (cw_num > 0)
						{
						c_write=1;
						c_w=1;
						}
					if (sr_num <= 0)
						{
						s_write=1;
						s_w=1;
						c_write=0;
						}
d1606 1
a1606 2
			else
				{
d1608 6
a1613 8
					(int)sizeof(sbuf) : (int)sw_num;
				i=BIO_write(s_bio,sbuf,j);
				if (i < 0)
					{
					s_r=0;
					s_w=0;
					if (BIO_should_retry(s_bio))
						{
d1615 1
a1615 1
							s_r=1;
d1617 3
a1619 5
							s_w=1;
						}
					else
						{
						fprintf(stderr,"ERROR in SERVER\n");
a1621 1
						}
d1623 1
a1623 2
				else if (i == 0)
					{
d1625 1
a1625 1
					fprintf(stderr,"SSL SERVER STARTUP FAILED in SSL_write\n");
d1627 1
a1627 3
					}
				else
					{
d1629 4
a1632 4
						printf("server wrote %d\n",i);
					sw_num-=i;
					s_write=0;
					c_r=1;
a1634 1
					}
d1637 1
d1639 3
a1641 2
		if ((done & S_DONE) && (done & C_DONE)) break;
		}
d1645 1
a1645 1
	ret=0;
d1654 23
a1676 20
	if (s_ssl != NULL)
		{
		s_ssl->rbio=NULL;
		s_ssl->wbio=NULL;
		}
	if (c_ssl != NULL)
		{
		c_ssl->rbio=NULL;
		c_ssl->wbio=NULL;
		}

	if (c_to_s != NULL) BIO_free(c_to_s);
	if (s_to_c != NULL) BIO_free(s_to_c);
	if (c_bio != NULL) BIO_free_all(c_bio);
	if (s_bio != NULL) BIO_free_all(s_bio);
	return(ret);
	}

static int get_proxy_auth_ex_data_idx(void)
	{
d1678 1
a1678 2
	if (idx < 0)
		{
d1680 1
a1680 2
		if (idx < 0)
			{
d1682 2
a1683 2
				"SSLtest for verify callback", NULL,NULL,NULL);
			}
d1685 1
a1685 1
		}
d1687 1
a1687 5
	}

static int verify_callback(int ok, X509_STORE_CTX *ctx)
	{
	char *s,buf[256];
d1689 8
a1696 4
	s=X509_NAME_oneline(X509_get_subject_name(ctx->current_cert),buf,
			    sizeof buf);
	if (s != NULL)
		{
d1698 5
a1702 7
			fprintf(stderr,"depth=%d %s\n",
				ctx->error_depth,buf);
		else
			{
			fprintf(stderr,"depth=%d error=%d %s\n",
				ctx->error_depth,ctx->error,buf);
			}
d1704 1
d1706 4
a1709 6
	if (ok == 0)
		{
		fprintf(stderr,"Error string: %s\n",
			X509_verify_cert_error_string(ctx->error));
		switch (ctx->error)
			{
d1713 2
a1714 3
			fprintf(stderr,"  ... ignored.\n");
			ok=1;
			}
d1716 1
d1718 1
a1718 2
	if (ok == 1)
		{
d1724 1
a1724 2
		if (xs->ex_flags & EXFLAG_PROXY)
			{
d1726 2
a1727 2
				X509_STORE_CTX_get_ex_data(ctx,
					get_proxy_auth_ex_data_idx());
d1729 1
a1729 2
			if (letters)
				{
d1733 2
a1734 2
					X509_get_ext_d2i(xs, NID_proxyCertInfo,
						NULL, NULL);
d1736 1
a1736 2
				switch (OBJ_obj2nid(pci->proxyPolicy->policyLanguage))
					{
d1756 1
a1756 1
						pci->proxyPolicy->policy->data;
d1780 1
a1780 2
					while(i-- > 0)
						{
d1782 1
a1782 2
						if (isascii(c) && isalpha(c))
							{
a1785 1
							}
d1787 1
d1791 3
a1793 3
						else
							letters[i] = 1;
					}
d1796 6
a1801 8
				fprintf(stderr,
					", resulting proxy rights = ");
				for(i = 0; i < 26; i++)
					if (letters[i])
						{
						fprintf(stderr, "%c", i + 'A');
						found_any = 1;
						}
a1806 1
				}
d1809 1
d1811 2
a1812 2
	return(ok);
	}
d1814 3
a1816 2
static void process_proxy_debug(int indent, const char *format, ...)
	{
d1818 2
a1819 2
		">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
		">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"; /* That's 80 > */
d1824 1
a1824 1
		indent, indent, indentation, format);
d1829 1
a1829 1
	}
d1836 6
a1841 4
	const char *cond, const char **cond_end, int *pos, int indent);
static int process_proxy_cond_val(unsigned int letters[26],
	const char *cond, const char **cond_end, int *pos, int indent)
	{
d1846 4
a1849 4
	while(isspace((int)*cond))
		{
		cond++; (*pos)++;
		}
d1854 2
a1855 2
			"Start process_proxy_cond_val at position %d: %s\n",
			*pos, cond);
d1857 1
a1857 2
	while(c == '!')
		{
d1859 6
a1864 5
		cond++; (*pos)++;
		while(isspace((int)*cond))
			{
			cond++; (*pos)++;
			}
d1866 1
a1866 1
		}
d1868 3
a1870 3
	if (c == '(')
		{
		cond++; (*pos)++;
d1872 1
a1872 1
			indent + 1);
d1876 4
a1879 4
		while(isspace((int)*cond))
			{
			cond++; (*pos)++;
			}
d1881 1
a1881 2
		if (c != ')')
			{
d1883 2
a1884 2
				"Weird condition character in position %d: "
				"%c\n", *pos, c);
a1886 2
			}
		cond++; (*pos)++;
d1888 3
a1890 2
	else if (isascii(c) && isalpha(c))
		{
d1894 3
a1896 4
		cond++; (*pos)++;
		}
	else
		{
d1898 2
a1899 2
			"Weird condition character in position %d: "
			"%c\n", *pos, c);
d1902 2
a1903 2
		}
 end:
d1910 2
a1911 2
			"End process_proxy_cond_val at position %d: %s, returning %d\n",
			*pos, cond, ok);
d1914 6
a1919 4
	}
static int process_proxy_cond_multipliers(unsigned int letters[26],
	const char *cond, const char **cond_end, int *pos, int indent)
	{
d1925 2
a1926 2
			"Start process_proxy_cond_multipliers at position %d: %s\n",
			*pos, cond);
d1933 5
a1937 6
	while(ok >= 0)
		{
		while(isspace((int)*cond))
			{
			cond++; (*pos)++;
			}
d1940 1
a1940 2
		switch(c)
			{
d1944 1
a1944 1
			int save_ok = ok;
d1946 7
a1952 6
			cond++; (*pos)++;
			ok = process_proxy_cond_val(letters,
				cond, cond_end, pos, indent + 1);
			cond = *cond_end;
			if (ok < 0)
				break;
d1954 11
a1964 12
			switch(c)
				{
			case '&':
				ok &= save_ok;
				break;
			case '^':
				ok ^= save_ok;
				break;
			default:
				fprintf(stderr, "SOMETHING IS SERIOUSLY WRONG!"
					" STOPPING\n");
				exit(1);
a1969 1
			}
d1971 2
a1972 1
 end:
d1975 2
a1976 2
			"End process_proxy_cond_multipliers at position %d: %s, returning %d\n",
			*pos, cond, ok);
d1980 6
a1985 4
	}
static int process_proxy_cond_adders(unsigned int letters[26],
	const char *cond, const char **cond_end, int *pos, int indent)
	{
d1991 2
a1992 2
			"Start process_proxy_cond_adders at position %d: %s\n",
			*pos, cond);
d1995 1
a1995 1
		indent + 1);
d2000 5
a2004 6
	while(ok >= 0)
		{
		while(isspace((int)*cond))
			{
			cond++; (*pos)++;
			}
d2007 1
a2007 2
		switch(c)
			{
d2010 1
a2010 1
			int save_ok = ok;
d2012 7
a2018 6
			cond++; (*pos)++;
			ok = process_proxy_cond_multipliers(letters,
				cond, cond_end, pos, indent + 1);
			cond = *cond_end;
			if (ok < 0)
				break;
d2020 8
a2027 9
			switch(c)
				{
			case '|':
				ok |= save_ok;
				break;
			default:
				fprintf(stderr, "SOMETHING IS SERIOUSLY WRONG!"
					" STOPPING\n");
				exit(1);
a2032 1
			}
d2034 2
a2035 1
 end:
d2038 2
a2039 2
			"End process_proxy_cond_adders at position %d: %s, returning %d\n",
			*pos, cond, ok);
d2043 1
a2043 1
	}
d2045 4
a2048 3
static int process_proxy_cond(unsigned int letters[26],
	const char *cond, const char **cond_end)
	{
d2051 1
a2051 1
	}
d2053 4
a2056 3
static int app_verify_callback(X509_STORE_CTX *ctx, void *arg)
	{
	int ok=1;
d2060 2
a2061 3
	if (cb_arg->app_verify)
		{
		char *s = NULL,buf[256];
d2066 1
a2066 1
			(void *)ctx, (void *)ctx->cert);
d2068 3
a2070 6
			s=X509_NAME_oneline(X509_get_subject_name(ctx->cert),buf,256);
		if (s != NULL)
			{
			fprintf(stderr,"cert depth=%d %s\n",ctx->error_depth,buf);
			}
		return(1);
d2072 3
a2074 2
	if (cb_arg->proxy_auth)
		{
d2078 1
a2078 1
		for(i = 0; i < 26; i++)
d2080 1
a2080 2
		for(sp = cb_arg->proxy_auth; *sp; sp++)
			{
d2082 1
a2082 2
			if (isascii(c) && isalpha(c))
				{
a2085 1
				}
d2087 1
d2089 6
a2094 8
		fprintf(stderr,
			"  Initial proxy rights = ");
		for(i = 0; i < 26; i++)
			if (letters[i])
				{
				fprintf(stderr, "%c", i + 'A');
				found_any = 1;
				}
d2100 3
a2102 4
			get_proxy_auth_ex_data_idx(),letters);
		}
	if (cb_arg->allow_proxy_certs)
		{
d2104 1
a2104 1
		}
d2110 2
a2111 4
	if (cb_arg->proxy_auth)
		{
		if (ok > 0)
			{
d2115 1
a2115 1
				cb_arg->proxy_cond, &cond_end);
d2119 1
a2119 2
			if (*cond_end)
				{
d2122 1
a2122 1
				}
d2125 1
a2125 1
					cb_arg->proxy_cond);
d2128 1
a2128 2
					cb_arg->proxy_cond);
			}
a2129 1
	return(ok);
d2131 2
d2135 1
a2135 1
static RSA *rsa_tmp=NULL;
d2137 3
a2139 2
static RSA *tmp_rsa_cb(SSL *s, int is_export, int keylength)
	{
d2141 1
a2141 2
	if (rsa_tmp == NULL)
		{
d2144 1
a2144 2
		if(!bn || !rsa_tmp || !BN_set_word(bn, RSA_F4))
			{
d2147 2
a2148 2
			}
		BIO_printf(bio_err,"Generating temp (%d bit) RSA key...",keylength);
d2150 1
a2150 2
		if(!RSA_generate_key_ex(rsa_tmp,keylength,bn,NULL))
			{
d2154 1
a2154 1
			}
d2156 1
a2156 1
		BIO_printf(bio_err,"\n");
a2157 3
		}
	if(bn) BN_free(bn);
	return(rsa_tmp);
d2159 4
d2164 4
a2167 4
static void free_tmp_rsa(void)
	{
	if (rsa_tmp != NULL)
		{
a2169 1
		}
d2171 1
d2181 12
a2192 11
static DH *get_dh512()
	{
	static unsigned char dh512_p[]={
		0xCB,0xC8,0xE1,0x86,0xD0,0x1F,0x94,0x17,0xA6,0x99,0xF0,0xC6,
		0x1F,0x0D,0xAC,0xB6,0x25,0x3E,0x06,0x39,0xCA,0x72,0x04,0xB0,
		0x6E,0xDA,0xC0,0x61,0xE6,0x7A,0x77,0x25,0xE8,0x3B,0xB9,0x5F,
		0x9A,0xB6,0xB5,0xFE,0x99,0x0B,0xA1,0x93,0x4E,0x35,0x33,0xB8,
		0xE1,0xF1,0x13,0x4F,0x59,0x1A,0xD2,0x57,0xC0,0x26,0x21,0x33,
		0x02,0xC5,0xAE,0x23,
		};
	static unsigned char dh512_g[]={
d2194 1
a2194 1
		};
d2197 6
a2202 6
	if ((dh=DH_new()) == NULL) return(NULL);
	dh->p=BN_bin2bn(dh512_p,sizeof(dh512_p),NULL);
	dh->g=BN_bin2bn(dh512_g,sizeof(dh512_g),NULL);
	if ((dh->p == NULL) || (dh->g == NULL))
		{ DH_free(dh); return(NULL); }
	return(dh);
d2204 2
d2207 17
a2223 16
static DH *get_dh1024()
	{
	static unsigned char dh1024_p[]={
		0xF8,0x81,0x89,0x7D,0x14,0x24,0xC5,0xD1,0xE6,0xF7,0xBF,0x3A,
		0xE4,0x90,0xF4,0xFC,0x73,0xFB,0x34,0xB5,0xFA,0x4C,0x56,0xA2,
		0xEA,0xA7,0xE9,0xC0,0xC0,0xCE,0x89,0xE1,0xFA,0x63,0x3F,0xB0,
		0x6B,0x32,0x66,0xF1,0xD1,0x7B,0xB0,0x00,0x8F,0xCA,0x87,0xC2,
		0xAE,0x98,0x89,0x26,0x17,0xC2,0x05,0xD2,0xEC,0x08,0xD0,0x8C,
		0xFF,0x17,0x52,0x8C,0xC5,0x07,0x93,0x03,0xB1,0xF6,0x2F,0xB8,
		0x1C,0x52,0x47,0x27,0x1B,0xDB,0xD1,0x8D,0x9D,0x69,0x1D,0x52,
		0x4B,0x32,0x81,0xAA,0x7F,0x00,0xC8,0xDC,0xE6,0xD9,0xCC,0xC1,
		0x11,0x2D,0x37,0x34,0x6C,0xEA,0x02,0x97,0x4B,0x0E,0xBB,0xB1,
		0x71,0x33,0x09,0x15,0xFD,0xDD,0x23,0x87,0x07,0x5E,0x89,0xAB,
		0x6B,0x7C,0x5F,0xEC,0xA6,0x24,0xDC,0x53,
		};
	static unsigned char dh1024_g[]={
d2225 1
a2225 1
		};
d2228 6
a2233 6
	if ((dh=DH_new()) == NULL) return(NULL);
	dh->p=BN_bin2bn(dh1024_p,sizeof(dh1024_p),NULL);
	dh->g=BN_bin2bn(dh1024_g,sizeof(dh1024_g),NULL);
	if ((dh->p == NULL) || (dh->g == NULL))
		{ DH_free(dh); return(NULL); }
	return(dh);
d2235 2
d2238 29
a2266 28
static DH *get_dh1024dsa()
	{
	static unsigned char dh1024_p[]={
		0xC8,0x00,0xF7,0x08,0x07,0x89,0x4D,0x90,0x53,0xF3,0xD5,0x00,
		0x21,0x1B,0xF7,0x31,0xA6,0xA2,0xDA,0x23,0x9A,0xC7,0x87,0x19,
		0x3B,0x47,0xB6,0x8C,0x04,0x6F,0xFF,0xC6,0x9B,0xB8,0x65,0xD2,
		0xC2,0x5F,0x31,0x83,0x4A,0xA7,0x5F,0x2F,0x88,0x38,0xB6,0x55,
		0xCF,0xD9,0x87,0x6D,0x6F,0x9F,0xDA,0xAC,0xA6,0x48,0xAF,0xFC,
		0x33,0x84,0x37,0x5B,0x82,0x4A,0x31,0x5D,0xE7,0xBD,0x52,0x97,
		0xA1,0x77,0xBF,0x10,0x9E,0x37,0xEA,0x64,0xFA,0xCA,0x28,0x8D,
		0x9D,0x3B,0xD2,0x6E,0x09,0x5C,0x68,0xC7,0x45,0x90,0xFD,0xBB,
		0x70,0xC9,0x3A,0xBB,0xDF,0xD4,0x21,0x0F,0xC4,0x6A,0x3C,0xF6,
		0x61,0xCF,0x3F,0xD6,0x13,0xF1,0x5F,0xBC,0xCF,0xBC,0x26,0x9E,
		0xBC,0x0B,0xBD,0xAB,0x5D,0xC9,0x54,0x39,
		};
	static unsigned char dh1024_g[]={
		0x3B,0x40,0x86,0xE7,0xF3,0x6C,0xDE,0x67,0x1C,0xCC,0x80,0x05,
		0x5A,0xDF,0xFE,0xBD,0x20,0x27,0x74,0x6C,0x24,0xC9,0x03,0xF3,
		0xE1,0x8D,0xC3,0x7D,0x98,0x27,0x40,0x08,0xB8,0x8C,0x6A,0xE9,
		0xBB,0x1A,0x3A,0xD6,0x86,0x83,0x5E,0x72,0x41,0xCE,0x85,0x3C,
		0xD2,0xB3,0xFC,0x13,0xCE,0x37,0x81,0x9E,0x4C,0x1C,0x7B,0x65,
		0xD3,0xE6,0xA6,0x00,0xF5,0x5A,0x95,0x43,0x5E,0x81,0xCF,0x60,
		0xA2,0x23,0xFC,0x36,0xA7,0x5D,0x7A,0x4C,0x06,0x91,0x6E,0xF6,
		0x57,0xEE,0x36,0xCB,0x06,0xEA,0xF5,0x3D,0x95,0x49,0xCB,0xA7,
		0xDD,0x81,0xDF,0x80,0x09,0x4A,0x97,0x4D,0xA8,0x22,0x72,0xA1,
		0x7F,0xC4,0x70,0x56,0x70,0xE8,0x20,0x10,0x18,0x8F,0x2E,0x60,
		0x07,0xE7,0x68,0x1A,0x82,0x5D,0x32,0xA2,
		};
d2269 7
a2275 5
	if ((dh=DH_new()) == NULL) return(NULL);
	dh->p=BN_bin2bn(dh1024_p,sizeof(dh1024_p),NULL);
	dh->g=BN_bin2bn(dh1024_g,sizeof(dh1024_g),NULL);
	if ((dh->p == NULL) || (dh->g == NULL))
		{ DH_free(dh); return(NULL); }
d2277 2
a2278 2
	return(dh);
	}
d2283 3
a2285 3
static int psk_key2bn(const char *pskkey, unsigned char *psk,
	unsigned int max_psk_len)
	{
d2290 2
a2291 3
	if (!ret)
		{
		BIO_printf(bio_err,"Could not convert PSK key '%s' to BIGNUM\n", pskkey); 
d2295 4
a2298 5
		}
	if (BN_num_bytes(bn) > (int)max_psk_len)
		{
		BIO_printf(bio_err,"psk buffer of callback is too small (%d) for key (%d)\n",
			max_psk_len, BN_num_bytes(bn));
d2301 1
a2301 1
		}
d2305 1
a2305 1
	}
d2307 4
a2310 4
static unsigned int psk_client_callback(SSL *ssl, const char *hint, char *identity,
	unsigned int max_identity_len, unsigned char *psk,
	unsigned int max_psk_len)
	{
d2325 1
a2325 1
	}
d2327 5
a2331 4
static unsigned int psk_server_callback(SSL *ssl, const char *identity,
	unsigned char *psk, unsigned int max_psk_len)
	{
	unsigned int psk_len=0;
d2333 1
a2333 2
	if (strcmp(identity, "Client_identity") != 0)
		{
d2336 2
a2337 2
		}
	psk_len=psk_key2bn(psk_key, psk, max_psk_len);
d2339 1
a2339 1
	}
d2342 3
a2344 2
static int do_test_cipherlist(void)
	{
d2352 1
a2352 2
	while ((ci = meth->get_cipher(i++)) != NULL)
		{
d2354 4
a2357 5
			if (ci->id >= tci->id)
				{
				fprintf(stderr, "failed %lx vs. %lx\n", ci->id, tci->id);
				return 0;
				}
d2359 1
a2359 1
		}
d2366 1
a2366 2
	while ((ci = meth->get_cipher(i++)) != NULL)
		{
d2368 1
a2368 2
			if (ci->id >= tci->id)
				{
d2370 2
a2371 2
				return 0;
				}
d2373 1
a2373 1
		}
d2380 1
a2380 2
	while ((ci = meth->get_cipher(i++)) != NULL)
		{
d2382 1
a2382 2
			if (ci->id >= tci->id)
				{
d2384 2
a2385 2
				return 0;
				}
d2387 1
a2387 1
		}
d2392 1
a2392 1
	}
@


1.23
log
@Remove vms support stuff.
ok deraadt@@
@
text
@a195 3
#ifdef OPENSSL_SYS_WINDOWS
#include <winsock.h>
#else
a196 1
#endif
@


1.22
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@a160 5
#ifdef OPENSSL_SYS_VMS
#define _XOPEN_SOURCE 500	/* Or isascii won't be declared properly on
				   VMS (at least with DECompHP C).  */
#endif

a201 10
#ifdef OPENSSL_SYS_VMS
#  define TEST_SERVER_CERT "SYS$DISK:[-.APPS]SERVER.PEM"
#  define TEST_CLIENT_CERT "SYS$DISK:[-.APPS]CLIENT.PEM"
#elif defined(OPENSSL_SYS_WINCE)
#  define TEST_SERVER_CERT "\\OpenSSL\\server.pem"
#  define TEST_CLIENT_CERT "\\OpenSSL\\client.pem"
#elif defined(OPENSSL_SYS_NETWARE)
#  define TEST_SERVER_CERT "\\openssl\\apps\\server.pem"
#  define TEST_CLIENT_CERT "\\openssl\\apps\\client.pem"
#else
a203 1
#endif
@


1.21
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@d145 5
d154 1
d159 1
a159 3

#define USE_SOCKETS
#include "e_os.h"
d168 2
d595 1
a595 1
			EXIT(0);
d794 1
a794 1
			EXIT(1);
d805 1
a805 1
		EXIT(1);
d815 1
a815 1
			EXIT(1);
d1159 1
a1159 1
	EXIT(ret);
d2153 1
a2153 1
				EXIT(1);
d2216 1
a2216 1
				EXIT(1);
d2315 1
a2315 1
				EXIT(3);
@


1.20
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d220 1
a220 1
static int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx);
d222 1
a222 1
static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export,int keylength);
d225 1
a225 1
static int MS_CALLBACK app_verify_callback(X509_STORE_CTX *ctx, void *arg);
d263 1
a263 1
static char * MS_CALLBACK ssl_give_srp_client_pwd_cb(SSL *s, void *arg)
d277 1
a277 1
static int MS_CALLBACK ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
d1233 1
a1233 1
			MS_STATIC char cbuf[1024*8];
d1319 1
a1319 1
			MS_STATIC char sbuf[1024*8];
d1553 1
a1553 1
	MS_STATIC char cbuf[1024*8],sbuf[1024*8];
d1861 1
a1861 1
static int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx)
d2235 1
a2235 1
static int MS_CALLBACK app_verify_callback(X509_STORE_CTX *ctx, void *arg)
d2329 1
a2329 1
static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength)
@


1.19
log
@resolve conflicts
@
text
@a152 2
#include <inttypes.h>
#include <ctype.h>
d546 1
a547 1
	STACK_OF(SSL_COMP) *ssl_comp_methods = NULL;
d884 7
a890 1
	meth=SSLv3_method();
@


1.18
log
@openssl-1.0.0e: resolve conflicts
@
text
@d186 3
d254 43
d319 3
d343 4
d534 6
d551 3
d585 10
a594 1
		if	(strcmp(*argv,"-server_auth") == 0)
d648 14
d804 14
d941 3
d945 1
d1048 20
a2291 4
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(1);
# endif
a2292 4
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(0);
# endif
@


1.17
log
@resolve conflicts, fix local changes
@
text
@a1434 1
	int c_want,s_want;
a1468 2
	c_want=W_WRITE;
	s_want=0;
@


1.16
log
@resolve conflicts
@
text
@d116 26
d159 1
d162 2
d241 10
a272 3
#ifdef OPENSSL_FIPS
	fprintf(stderr,"-F             - run test in FIPS mode\n");
#endif
d291 3
d325 1
a325 1
	SSL_CIPHER *ciph;
d430 19
d470 1
a470 1
	SSL_METHOD *meth=NULL;
d476 1
a476 1
	int dhe1024 = 1, dhe1024dsa = 0;
d483 1
a491 3
#ifdef OPENSSL_FIPS
	int fips_mode=0;
#endif
d497 1
a497 1
	bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);	
d516 1
a516 1
	bio_stdout=BIO_new_fp(stdout,BIO_NOCLOSE);
d523 1
a523 10
		if(!strcmp(*argv,"-F"))
			{
#ifdef OPENSSL_FIPS
			fips_mode=1;
#else
			fprintf(stderr,"not compiled with FIPS support, so exitting without running.\n");
			EXIT(0);
#endif
			}
		else if	(strcmp(*argv,"-server_auth") == 0)
d563 14
a718 14
#ifdef OPENSSL_FIPS
	if(fips_mode)
		{
		if(!FIPS_mode_set(1))
			{
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
			EXIT(1);
			}
		else
			fprintf(stderr,"*** IN FIPS MODE ***\n");
		}
#endif

d863 7
d921 25
d1022 1
a1022 1
	ERR_remove_state(0);
d2172 4
d2177 4
d2349 63
d2416 1
a2416 1
	SSL_CIPHER *ci, *tci = NULL;
@


1.15
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d2098 1
a2098 1
		if (ok)
@


1.14
log
@resolve conflicts
@
text
@d234 3
d418 1
a418 1
	int dhe1024 = 0, dhe1024dsa = 0;
d433 3
d467 10
a476 1
		if	(strcmp(*argv,"-server_auth") == 0)
d658 14
a2092 4
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(1);
# endif
a2093 4
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(0);
# endif
@


1.13
log
@resolve conflicts
@
text
@d111 5
d148 10
a157 1
#include <openssl/fips.h>
d177 3
d187 2
a188 2
#define COMP_RLE	1
#define COMP_ZLIB	2
d229 1
a233 3
#ifdef OPENSSL_FIPS
	fprintf(stderr,"-F             - run test in FIPS mode\n");
#endif
d249 3
d272 7
a278 1
	fprintf(stderr," -time         - use rle compression\n");
d388 1
d404 3
d412 1
a412 1
	long bytes=1L;
d417 3
d421 1
d425 1
a426 2
#ifdef OPENSSL_FIPS
	int fips_mode=0;
d428 2
d461 1
a461 10
		if(!strcmp(*argv,"-F"))
			{
#ifdef OPENSSL_FIPS
			fips_mode=1;
#else
			fprintf(stderr,"not compiled with FIPS support, so exitting without running.\n");
			EXIT(0);
#endif
			}
		else if	(strcmp(*argv,"-server_auth") == 0)
d499 2
d587 10
d605 4
d625 8
a642 14
#ifdef OPENSSL_FIPS
	if(fips_mode)
		{
		if(!FIPS_mode_set(1))
			{
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
			EXIT(1);
			}
		else
			fprintf(stderr,"*** IN FIPS MODE ***\n");
		}
#endif

d659 1
d683 14
d751 32
d919 1
d1410 2
a1411 2
				j=(cw_num > (long)sizeof(cbuf))
					?sizeof(cbuf):(int)cw_num;
d1541 2
a1542 2
				j=(sw_num > (long)sizeof(sbuf))?
					sizeof(sbuf):(int)sw_num;
d1729 1
a1729 1
						char c = *s++;
d1790 1
a1790 1
	char c;
d1794 1
a1794 1
	while(isspace(*cond))
d1809 1
a1809 1
		while(isspace(*cond))
d1824 1
a1824 1
		while(isspace(*cond))
d1884 1
a1884 1
		while(isspace(*cond))
d1951 1
a1951 1
		while(isspace(*cond))
d2034 1
a2034 1
			char c = *sp;
d2064 4
d2069 4
d2107 1
d2110 7
d2119 7
a2125 1
		rsa_tmp=RSA_generate_key(keylength,RSA_F4,NULL,NULL);
d2129 1
d2240 57
@


1.13.8.1
log
@Fix CVE-2008-5077: Incorrect checks for malformed signatures
@
text
@d1987 1
a1987 1
		if (ok > 0)
@


1.13.10.1
log
@Fix CVE-2008-5077: Incorrect checks for malformed signatures
@
text
@d1987 1
a1987 1
		if (ok > 0)
@


1.12
log
@resolve conflicts
@
text
@d128 4
a395 1
	const char *path=argv[0];
d598 1
a598 1
		if(!FIPS_mode_set(1,path))
d1933 2
a1934 2
		fprintf(stderr, "Finished printing do we have a context? 0x%x a cert? 0x%x\n",
			(unsigned int)ctx, (unsigned int)ctx->cert);
a1981 4
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(1);
# endif
a1982 4
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(0);
# endif
@


1.11
log
@merge 0.9.7d
@
text
@d123 1
d132 1
d139 1
d175 9
a183 2
#define APP_CALLBACK "Test Callback Argument"
static char *app_verify_arg = APP_CALLBACK;
d212 3
d217 3
d369 2
a370 1
	int app_verify=0;
d390 4
d425 10
a434 1
		if	(strcmp(*argv,"-server_auth") == 0)
d438 10
d560 5
a564 1
			app_verify = 1;
d582 1
d592 14
d739 1
a739 4
		if (app_verify) 
			{
			SSL_CTX_set_cert_verify_callback(s_ctx, app_verify_callback, app_verify_arg);
			}
d746 1
a746 4
		if (app_verify) 
			{
			SSL_CTX_set_cert_verify_callback(s_ctx, app_verify_callback, app_verify_arg);
			}
d1528 16
d1553 2
a1554 1
			fprintf(stderr,"depth=%d %s\n",ctx->error_depth,buf);
d1556 1
d1559 1
d1564 2
d1571 1
d1576 101
d1680 238
a1919 1
	char *s = NULL,buf[256];
d1921 2
d1924 1
a1924 7
	fprintf(stderr, "In app_verify_callback, allowing cert. ");
	fprintf(stderr, "Arg is: %s\n", (char *)arg);
	fprintf(stderr, "Finished printing do we have a context? 0x%lx a cert? 0x%lx\n",
			(uintptr_t)ctx, (uintptr_t)ctx->cert);
	if (ctx->cert)
		s=X509_NAME_oneline(X509_get_subject_name(ctx->cert),buf,256);
	if (s != NULL)
d1926 10
d1937 2
d1940 17
d1958 56
@


1.10
log
@Off-by-ones, from aaron@@
@
text
@d568 8
a575 1
			SSL_COMP_add_compression_method(comp, cm);
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d294 1
a294 1
	if (type < 0 || type > CRYPTO_NUM_LOCKS)
@


1.8
log
@don't cast pointer to integer, use intptr_t stuff off inttypes.h instead
ok millert
@
text
@d112 1
a112 1
#define _XOPEN_SOURCE 600	/* Or gethostname won't be declared properly
a113 3
#define _XOPEN_SOURCE_EXTENDED	1 /* Or gethostname won't be declared properly
				   on Compaq platforms (at least with DEC C).
				*/
d124 1
d132 1
d134 1
d137 7
a145 1
#include "../crypto/bio/bss_file.c"
d153 3
d377 3
a379 1
	
a396 1
	bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
d419 1
a419 1
			fprintf(stderr,"ignoring -dhe1024, since I'm compiled without DH\n";
d427 1
a427 1
			fprintf(stderr,"ignoring -dhe1024, since I'm compiled without DH\n";
d544 1
a544 1
		exit(1);
d700 1
a700 1
                char	localhost[257];
d702 1
a702 1
		if (gethostname(localhost, 256) == 0)
d704 6
d765 1
d767 1
d857 2
d943 2
d1188 3
d1472 2
a1473 1
	s=X509_NAME_oneline(X509_get_subject_name(ctx->current_cert),buf,256);
@


1.7
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d125 1
d1478 2
a1479 2
	fprintf(stderr, "Finished printing do we have a context? 0x%x a cert? 0x%x\n",
			(unsigned int)ctx, (unsigned int)ctx->cert);
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d403 2
a405 1
		else if	(strcmp(*argv,"-dhe1024") == 0)
d407 4
d412 2
d415 2
d418 1
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d58 59
d126 1
a126 1
#include "openssl/e_os.h"
d133 1
d136 2
a137 1
#ifdef WINDOWS
d139 2
d143 1
a143 1
#ifdef VMS
d151 5
d157 1
a157 1
#ifndef NO_RSA
d161 5
a165 1
#ifndef NO_DH
d199 1
a199 1
#ifndef NO_DH
d204 1
a204 1
#ifndef NO_SSL2
d207 1
a207 1
#ifndef NO_SSL3
d210 1
a210 1
#ifndef NO_TLS1
d223 2
d246 1
a246 1
#ifndef NO_RSA
d254 1
a254 1
#ifndef NO_DSA
d271 63
d343 1
d354 1
a354 1
#ifndef NO_DH
d361 2
d368 13
d403 1
a403 1
#ifndef NO_DH
d489 12
d542 18
a559 1
#if !defined(NO_SSL2) && !defined(NO_SSL3)
d571 1
a571 1
#ifdef NO_SSL2
d592 1
a592 1
#ifndef NO_DH
d612 1
a612 1
#ifndef NO_RSA
d652 4
d662 4
d676 13
d735 1
a735 1
#ifndef NO_RSA
d738 2
d1056 1
a1056 1
					r = BIO_nwrite(io1, &dataptr, (int)num);
d1058 2
a1059 2
					assert(r <= (int)num);
					num = r;
d1068 7
d1460 20
a1479 1
#ifndef NO_RSA
d1505 1
a1505 1
#ifndef NO_DH
d1512 1
a1512 1
DH *get_dh512()
d1535 1
a1535 1
DH *get_dh1024()
d1563 1
a1563 1
DH *get_dh1024dsa()
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d91 1
d532 3
d1196 1
a1196 1
	 * Free()ed twice.  Once when th s_ssl is SSL_free()ed and
d1249 2
a1252 2
	static RSA *rsa_tmp=NULL;

d1262 9
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d65 1
d71 1
d94 2
a95 3
#endif
#ifndef NO_DSA
static void MS_CALLBACK dsa_cb(int p, int n, void *arg);
d113 1
a113 1
int doit_biopair(SSL *s_ssl,SSL *c_ssl,long bytes);
d126 3
a128 4
#if !defined NO_DH && !defined NO_DSA
	fprintf(stderr," -dhe1024      - generate 1024 bit key for DHE\n");
#endif
#if !defined NO_DH
d142 4
a145 3
	fprintf(stderr," -cert arg     - Certificate file\n");
	fprintf(stderr," -s_cert arg   - Just the server certificate file\n");
	fprintf(stderr," -c_cert arg   - Just the client certificate file\n");
d149 45
d206 1
d208 1
a214 2
	SSL_CIPHER *ciph;
	int dhe1024 = 0, no_dhe = 0;
d217 1
d219 4
d249 1
d252 3
d288 10
d303 5
d331 4
d353 4
a356 6
		fprintf(stderr, "This case cannot work.  Use -f switch to perform "
			"the test anyway\n"
			"(and -d to see what happens, "
			"and -bio_pair to really make it happen :-)\n"
			"or add one of -ssl2, -ssl3, -tls1, -reuse to "
			"avoid protocol mismatch.\n");
d360 11
d412 1
a412 2
# ifndef NO_DSA
		if (dhe1024) 
d414 1
a414 14
			DSA *dsa;
			unsigned char seed[20];
			
			if (verbose)
				{
				BIO_printf(bio_err, "Creating 1024 bit DHE parameters\n");
				BIO_flush(bio_err);
				}
			
			memcpy(seed, "Random String no. 12", 20);
			dsa = DSA_generate_parameters(1024, seed, 20, NULL, NULL, dsa_cb, bio_err);
			dh = DSA_dup_DH(dsa);	
			DSA_free(dsa);
			/* important: SSL_OP_SINGLE_DH_USE to avoid small subgroup attacks */
d416 1
a416 3
			
			if (verbose)
				fprintf(stdout, " done\n");
d418 2
a420 1
# endif
d425 2
d437 2
a438 2
	else if (!SSL_CTX_use_PrivateKey_file(s_ctx,server_cert,
		SSL_FILETYPE_PEM))
d448 2
a449 1
		SSL_CTX_use_PrivateKey_file(c_ctx,client_cert,
d489 1
a489 1
			ret=doit_biopair(s_ssl,c_ssl,bytes);
d496 1
a496 5
		ciph=SSL_get_current_cipher(c_ssl);
		BIO_printf(bio_stdout,"Protocol %s, cipher %s, %s\n",
			SSL_get_version(c_ssl),
			SSL_CIPHER_get_version(ciph),
			SSL_CIPHER_get_name(ciph));
d500 21
d539 2
a540 1
int doit_biopair(SSL *s_ssl, SSL *c_ssl, long count)
a544 1
	SSL_CIPHER *ciph;
d617 1
d684 10
d701 1
d765 2
a891 1
	ciph = SSL_get_current_cipher(c_ssl);
d893 2
a894 5
		fprintf(stdout,"DONE via BIO pair, protocol %s, cipher %s, %s\n",
			SSL_get_version(c_ssl),
			SSL_CIPHER_get_version(ciph),
			SSL_CIPHER_get_name(ciph));
 end:
a937 1
	SSL_CIPHER *ciph;
a1186 1
	ciph=SSL_get_current_cipher(c_ssl);
d1188 1
a1188 4
		fprintf(stdout,"DONE, protocol %s, cipher %s, %s\n",
			SSL_get_version(c_ssl),
			SSL_CIPHER_get_version(ciph),
			SSL_CIPHER_get_name(ciph));
a1243 26
#ifndef NO_DH
static unsigned char dh512_p[]={
	0xDA,0x58,0x3C,0x16,0xD9,0x85,0x22,0x89,0xD0,0xE4,0xAF,0x75,
	0x6F,0x4C,0xCA,0x92,0xDD,0x4B,0xE5,0x33,0xB8,0x04,0xFB,0x0F,
	0xED,0x94,0xEF,0x9C,0x8A,0x44,0x03,0xED,0x57,0x46,0x50,0xD3,
	0x69,0x99,0xDB,0x29,0xD7,0x76,0x27,0x6B,0xA2,0xD3,0xD4,0x12,
	0xE2,0x18,0xF4,0xDD,0x1E,0x08,0x4C,0xF6,0xD8,0x00,0x3E,0x7C,
	0x47,0x74,0xE8,0x33,
	};
static unsigned char dh512_g[]={
	0x02,
	};

static DH *get_dh512(void)
	{
	DH *dh=NULL;

	if ((dh=DH_new()) == NULL) return(NULL);
	dh->p=BN_bin2bn(dh512_p,sizeof(dh512_p),NULL);
	dh->g=BN_bin2bn(dh512_g,sizeof(dh512_g),NULL);
	if ((dh->p == NULL) || (dh->g == NULL))
		return(NULL);
	return(dh);
	}
#endif

d1261 31
a1291 2
#ifndef NO_DSA
static void MS_CALLBACK dsa_cb(int p, int n, void *arg)
d1293 25
a1317 2
	char c='*';
	static int ok=0,num=0;
d1319 29
a1347 6
	if (p == 0) { c='.'; num++; };
	if (p == 1) c='+';
	if (p == 2) { c='*'; ok++; }
	if (p == 3) c='\n';
	BIO_write(arg,&c,1);
	(void)BIO_flush(arg);
d1349 7
a1355 5
	if (!ok && (p == 0) && (num > 1))
		{
		BIO_printf((BIO *)arg,"error in dsatest\n");
		exit(1);
		}
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d59 3
a64 2
#include <errno.h>
#include <limits.h>
d73 1
a77 4
#if defined(NO_RSA) && !defined(NO_SSL2)
#define NO_SSL2
#endif

d86 1
a86 1
int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx);
d93 6
a98 2
BIO *bio_err=NULL;
BIO *bio_stdout=NULL;
d101 2
a102 2
int verbose=0;
int debug=0;
d110 1
d128 3
d168 1
a168 1
	int dhe1024 = 0;
d172 7
a182 2
	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);

d200 2
d327 2
d330 1
a330 5
	if (dhe1024) 
		{
		DSA *dsa;

		if (verbose)
d332 18
a349 2
			fprintf(stdout, "Creating 1024 bit DHE parameters ...");
			fflush(stdout);
d351 5
a355 9

		dsa = DSA_generate_parameters(1024, NULL, 0, NULL, NULL, 0, NULL);
		dh = DSA_dup_DH(dsa);	
		DSA_free(dsa);
		/* important: SSL_OP_SINGLE_DH_USE to avoid small subgroup attacks */
		SSL_CTX_set_options(s_ctx, SSL_OP_SINGLE_DH_USE);

		if (verbose)
			fprintf(stdout, " done\n");
a356 5
	else
# endif
		dh=get_dh512();
	SSL_CTX_set_tmp_dh(s_ctx,dh);
	DH_free(dh);
d394 1
a394 1
		fprintf(stderr,"client authentication\n");
d401 1
a401 1
		fprintf(stderr,"server authentication\n");
d405 5
d426 1
a426 1
		fprintf(stdout,"Protocol %s, cipher %s, %s\n",
d432 1
a432 1
		printf("%d handshakes of %ld bytes done\n",number,bytes);
d447 1
d512 1
a512 1
		 * BIO_ctrl_get_write_gurantee(bio)   number of bytes we can write now
d544 1
a544 1
				if (r == -1)
d617 1
a617 1
				if (r == -1)
a669 9
#define RELAYBUFSIZ 200
			static char buf[RELAYBUFSIZ];

			/* RELAYBUF is arbitrary.  When writing data over some real
			 * network, use a buffer of the same size as in the BIO_pipe
			 * and make that size large (for reading from the network
			 * small buffers usually won't hurt).
			 * Here sizes differ for testing. */

d671 5
a675 2
			size_t num;
			int r;
d679 1
a679 1
			/* client to server */
d682 5
a686 2
				r1 = BIO_ctrl_pending(client_io);
				r2 = BIO_ctrl_get_write_guarantee(server_io);
d693 2
a694 2
					if (sizeof buf < num)
						num = sizeof buf;
d698 6
a703 8
					r = BIO_read(client_io, buf, (int)num);
					if (r != (int)num) /* can't happen */
						{
						fprintf(stderr, "ERROR: BIO_read could not read "
							"BIO_ctrl_pending() bytes");
						goto err;
						}
					r = BIO_write(server_io, buf, (int)num);
d713 4
a716 1
						printf("C->S relaying: %d bytes\n", (int)num);
d721 4
a724 5
			/* server to client */
			do
				{
				r1 = BIO_ctrl_pending(server_io);
				r2 = BIO_ctrl_get_write_guarantee(client_io);
d726 6
d737 2
a738 2
					if (sizeof buf < num)
						num = sizeof buf;
d741 3
d745 5
a749 1
					r = BIO_read(server_io, buf, (int)num);
a755 7
					r = BIO_write(client_io, buf, (int)num);
					if (r != (int)num) /* can't happen */
						{
						fprintf(stderr, "ERROR: BIO_write could not write "
							"BIO_ctrl_get_write_guarantee() bytes");
						goto err;
						}
d757 1
a757 1

d759 4
a762 1
						printf("S->C relaying: %d bytes\n", (int)num);
d764 1
a764 2
				}
			while (r1 && r2);
d1123 1
a1123 1
int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx)
d1191 21
@


1.1
log
@Initial revision
@
text
@d63 9
a71 6
#include "e_os.h"
#include "bio.h"
#include "crypto.h"
#include "x509.h"
#include "ssl.h"
#include "err.h"
d76 11
a86 2
#define TEST_SERVER_CERT "../apps/server.pem"
#define TEST_CLIENT_CERT "../apps/client.pem"
a87 1
#ifndef NOPROTO
d89 4
a92 2
static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int export);
#ifndef NO_DSA
a94 8
#else
int MS_CALLBACK verify_callback();
static RSA MS_CALLBACK *tmp_rsa_cb();
#ifndef NO_DSA
static DH *get_dh512();
#endif
#endif

d101 2
d106 1
d109 1
a109 1
#ifndef  NOPROTO
d111 1
a111 5
#else
int doit();
#endif

static void sv_usage()
d122 3
d140 2
d144 1
a144 3
int main(argc, argv)
int argc;
char *argv[];
d148 2
d162 1
d187 2
d240 8
d264 11
d277 1
a277 1
	SSLeay_add_ssl_algorithms();
d314 23
a336 1
	dh=get_dh512();
d394 4
a397 1
		ret=doit(s_ssl,c_ssl,bytes);
d420 1
d427 363
d795 1
a795 3
int doit(s_ssl,c_ssl,count)
SSL *s_ssl,*c_ssl;
long count;
d1094 1
a1094 3
int MS_CALLBACK verify_callback(ok, ctx)
int ok;
X509_STORE_CTX *ctx;
d1135 1
a1135 1
static DH *get_dh512()
d1148 2
a1149 3
static RSA MS_CALLBACK *tmp_rsa_cb(s,export)
SSL *s;
int export;
d1155 3
a1157 5
		BIO_printf(bio_err,"Generating temp (512 bit) RSA key...");
		BIO_flush(bio_err);
#ifndef NO_RSA
		rsa_tmp=RSA_generate_key(512,RSA_F4,NULL,NULL);
#endif
d1159 1
a1159 1
		BIO_flush(bio_err);
d1163 1
a1163 2


@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 59
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#define _XOPEN_SOURCE 600	/* Or gethostname won't be declared properly
				   on Linux and GNU platforms. */
#define _XOPEN_SOURCE_EXTENDED	1 /* Or gethostname won't be declared properly
				   on Compaq platforms (at least with DEC C).
				*/
a58 3
#include <assert.h>
#include <errno.h>
#include <limits.h>
d62 1
a62 2
#include <time.h>

d64 6
a69 11

#include <openssl/bio.h>
#include <openssl/crypto.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/ssl.h>
#include <openssl/engine.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#ifdef OPENSSL_SYS_WINDOWS
#include <winsock.h>
a70 2
#else
#include OPENSSL_UNISTD
d73 9
a81 3
#ifdef OPENSSL_SYS_VMS
#  define TEST_SERVER_CERT "SYS$DISK:[-.APPS]SERVER.PEM"
#  define TEST_CLIENT_CERT "SYS$DISK:[-.APPS]CLIENT.PEM"
d83 4
a86 13
#  define TEST_SERVER_CERT "../apps/server.pem"
#  define TEST_CLIENT_CERT "../apps/client.pem"
#endif

/* There is really no standard for this, so let's assign some tentative
   numbers.  In any case, these numbers are only for this test */
#define COMP_RLE	1
#define COMP_ZLIB	2

static int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx);
#ifndef OPENSSL_NO_RSA
static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export,int keylength);
static void free_tmp_rsa(void);
a87 8
static int MS_CALLBACK app_verify_callback(X509_STORE_CTX *ctx, void *arg);
#define APP_CALLBACK "Test Callback Argument"
static char *app_verify_arg = APP_CALLBACK;

#ifndef OPENSSL_NO_DH
static DH *get_dh512(void);
static DH *get_dh1024(void);
static DH *get_dh1024dsa(void);
d90 2
a91 2
static BIO *bio_err=NULL;
static BIO *bio_stdout=NULL;
d94 2
a95 4
static int verbose=0;
static int debug=0;
#if 0
/* Not used yet. */
a98 1
#endif
a99 1
static const char rnd_seed[] = "string to make the random number generator think it has entropy";
d101 1
a101 1
int doit_biopair(SSL *s_ssl,SSL *c_ssl,long bytes,clock_t *s_time,clock_t *c_time);
d103 5
a107 1
static void sv_usage(void)
d118 1
a118 6
#ifndef OPENSSL_NO_DH
	fprintf(stderr," -dhe1024      - use 1024 bit key (safe prime) for DHE\n");
	fprintf(stderr," -dhe1024dsa   - use 1024 bit key (with 160-bit subprime) for DHE\n");
	fprintf(stderr," -no_dhe       - disable DHE\n");
#endif
#ifndef OPENSSL_NO_SSL2
d121 1
a121 1
#ifndef OPENSSL_NO_SSL3
d124 1
a124 1
#ifndef OPENSSL_NO_TLS1
d129 3
a131 4
	fprintf(stderr," -cert arg     - Server certificate file\n");
	fprintf(stderr," -key arg      - Server key file (default: same as -cert)\n");
	fprintf(stderr," -c_cert arg   - Client certificate file\n");
	fprintf(stderr," -c_key arg    - Client key file (default: same as -c_cert)\n");
a132 5
	fprintf(stderr," -bio_pair     - Use BIO pairs\n");
	fprintf(stderr," -f            - Test even cases that can't work\n");
	fprintf(stderr," -time         - measure processor time used by client and server\n");
	fprintf(stderr," -zlib         - use zlib compression\n");
	fprintf(stderr," -time         - use rle compression\n");
d135 3
a137 108
static void print_details(SSL *c_ssl, const char *prefix)
	{
	SSL_CIPHER *ciph;
	X509 *cert;
		
	ciph=SSL_get_current_cipher(c_ssl);
	BIO_printf(bio_stdout,"%s%s, cipher %s %s",
		prefix,
		SSL_get_version(c_ssl),
		SSL_CIPHER_get_version(ciph),
		SSL_CIPHER_get_name(ciph));
	cert=SSL_get_peer_certificate(c_ssl);
	if (cert != NULL)
		{
		EVP_PKEY *pkey = X509_get_pubkey(cert);
		if (pkey != NULL)
			{
			if (0) 
				;
#ifndef OPENSSL_NO_RSA
			else if (pkey->type == EVP_PKEY_RSA && pkey->pkey.rsa != NULL
				&& pkey->pkey.rsa->n != NULL)
				{
				BIO_printf(bio_stdout, ", %d bit RSA",
					BN_num_bits(pkey->pkey.rsa->n));
				}
#endif
#ifndef OPENSSL_NO_DSA
			else if (pkey->type == EVP_PKEY_DSA && pkey->pkey.dsa != NULL
				&& pkey->pkey.dsa->p != NULL)
				{
				BIO_printf(bio_stdout, ", %d bit DSA",
					BN_num_bits(pkey->pkey.dsa->p));
				}
#endif
			EVP_PKEY_free(pkey);
			}
		X509_free(cert);
		}
	/* The SSL API does not allow us to look at temporary RSA/DH keys,
	 * otherwise we should print their lengths too */
	BIO_printf(bio_stdout,"\n");
	}

static void lock_dbg_cb(int mode, int type, const char *file, int line)
	{
	static int modes[CRYPTO_NUM_LOCKS]; /* = {0, 0, ... } */
	const char *errstr = NULL;
	int rw;
	
	rw = mode & (CRYPTO_READ|CRYPTO_WRITE);
	if (!((rw == CRYPTO_READ) || (rw == CRYPTO_WRITE)))
		{
		errstr = "invalid mode";
		goto err;
		}

	if (type < 0 || type > CRYPTO_NUM_LOCKS)
		{
		errstr = "type out of bounds";
		goto err;
		}

	if (mode & CRYPTO_LOCK)
		{
		if (modes[type])
			{
			errstr = "already locked";
			/* must not happen in a single-threaded program
			 * (would deadlock) */
			goto err;
			}

		modes[type] = rw;
		}
	else if (mode & CRYPTO_UNLOCK)
		{
		if (!modes[type])
			{
			errstr = "not locked";
			goto err;
			}
		
		if (modes[type] != rw)
			{
			errstr = (rw == CRYPTO_READ) ?
				"CRYPTO_r_unlock on write lock" :
				"CRYPTO_w_unlock on read lock";
			}

		modes[type] = 0;
		}
	else
		{
		errstr = "invalid mode";
		goto err;
		}

 err:
	if (errstr)
		{
		/* we cannot use bio_err here */
		fprintf(stderr, "openssl (lock_dbg_cb): %s (mode=%d, type=%d) at %s:%d\n",
			errstr, mode, type, file, line);
		}
	}

int main(int argc, char *argv[])
a140 2
	int bio_pair=0;
	int force=0;
a143 1
	int app_verify=0;
a144 1
	char *server_key=NULL;
a145 1
	char *client_key=NULL;
d152 2
a153 1
#ifndef OPENSSL_NO_DH
a154 1
	int dhe1024 = 0, dhe1024dsa = 0;
a155 26
	int no_dhe = 0;
	int print_time = 0;
	clock_t s_time = 0, c_time = 0;
	int comp = 0;
	COMP_METHOD *cm = NULL;

	verbose = 0;
	debug = 0;
	cipher = 0;
	
	CRYPTO_set_locking_callback(lock_dbg_cb);

	/* enable memory leak checking unless explicitly disabled */
	if (!((getenv("OPENSSL_DEBUG_MEMORY") != NULL) && (0 == strcmp(getenv("OPENSSL_DEBUG_MEMORY"), "off"))))
		{
		CRYPTO_malloc_debug_init();
		CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
		}
	else
		{
		/* OPENSSL_DEBUG_MEMORY=off */
		CRYPTO_set_mem_debug_functions(0, 0, 0, 0, 0);
		}
	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);

	RAND_seed(rnd_seed, sizeof rnd_seed);
d160 2
a176 8
#ifndef OPENSSL_NO_DH
		else if	(strcmp(*argv,"-dhe1024") == 0)
			dhe1024=1;
		else if	(strcmp(*argv,"-dhe1024dsa") == 0)
			dhe1024dsa=1;
#endif
		else if	(strcmp(*argv,"-no_dhe") == 0)
			no_dhe=1;
a207 10
		else if	(strcmp(*argv,"-key") == 0)
			{
			if (--argc < 1) goto bad;
			server_key= *(++argv);
			}
		else if	(strcmp(*argv,"-s_key") == 0)
			{
			if (--argc < 1) goto bad;
			server_key= *(++argv);
			}
a212 5
		else if	(strcmp(*argv,"-c_key") == 0)
			{
			if (--argc < 1) goto bad;
			client_key= *(++argv);
			}
a227 24
		else if	(strcmp(*argv,"-bio_pair") == 0)
			{
			bio_pair = 1;
			}
		else if	(strcmp(*argv,"-f") == 0)
			{
			force = 1;
			}
		else if	(strcmp(*argv,"-time") == 0)
			{
			print_time = 1;
			}
		else if	(strcmp(*argv,"-zlib") == 0)
			{
			comp = COMP_ZLIB;
			}
		else if	(strcmp(*argv,"-rle") == 0)
			{
			comp = COMP_RLE;
			}
		else if	(strcmp(*argv,"-app_verify") == 0)
			{
			app_verify = 1;
			}
a243 20
	if (!ssl2 && !ssl3 && !tls1 && number > 1 && !reuse && !force)
		{
		fprintf(stderr, "This case cannot work.  Use -f to perform "
			"the test anyway (and\n-d to see what happens), "
			"or add one of -ssl2, -ssl3, -tls1, -reuse\n"
			"to avoid protocol mismatch.\n");
		exit(1);
		}

	if (print_time)
		{
		if (!bio_pair)
			{
			fprintf(stderr, "Using BIO pair (-bio_pair)\n");
			bio_pair = 1;
			}
		if (number < 50 && !force)
			fprintf(stderr, "Warning: For accurate timings, use more connections (e.g. -num 1000)\n");
		}

d246 1
a246 1
	SSL_library_init();
d249 1
a249 18
	if (comp == COMP_ZLIB) cm = COMP_zlib();
	if (comp == COMP_RLE) cm = COMP_rle();
	if (cm != NULL)
		{
		if (cm->type != NID_undef)
			SSL_COMP_add_compression_method(comp, cm);
		else
			{
			fprintf(stderr,
				"Warning: %s compression not supported\n",
				(comp == COMP_RLE ? "rle" :
					(comp == COMP_ZLIB ? "zlib" :
						"unknown")));
			ERR_print_errors_fp(stderr);
			}
		}

#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
d261 1
a261 1
#ifdef OPENSSL_NO_SSL2
d282 4
a285 18
#ifndef OPENSSL_NO_DH
	if (!no_dhe)
		{
		if (dhe1024dsa)
			{
			/* use SSL_OP_SINGLE_DH_USE to avoid small subgroup attacks */
			SSL_CTX_set_options(s_ctx, SSL_OP_SINGLE_DH_USE);
			dh=get_dh1024dsa();
			}
		else if (dhe1024)
			dh=get_dh1024();
		else
			dh=get_dh512();
		SSL_CTX_set_tmp_dh(s_ctx,dh);
		DH_free(dh);
		}
#else
	(void)no_dhe;
d288 1
a288 1
#ifndef OPENSSL_NO_RSA
d296 2
a297 2
	else if (!SSL_CTX_use_PrivateKey_file(s_ctx,
		(server_key?server_key:server_cert), SSL_FILETYPE_PEM))
d307 1
a307 2
		SSL_CTX_use_PrivateKey_file(c_ctx,
			(client_key?client_key:client_cert),
d323 1
a323 1
		BIO_printf(bio_err,"client authentication\n");
a326 4
		if (app_verify) 
			{
			SSL_CTX_set_cert_verify_callback(s_ctx, app_verify_callback, app_verify_arg);
			}
d330 1
a330 1
		BIO_printf(bio_err,"server authentication\n");
a332 4
		if (app_verify) 
			{
			SSL_CTX_set_cert_verify_callback(s_ctx, app_verify_callback, app_verify_arg);
			}
a333 5
	
	{
		int session_id_context = 0;
		SSL_CTX_set_session_id_context(s_ctx, (void *)&session_id_context, sizeof session_id_context);
	}
a337 13
#ifndef OPENSSL_NO_KRB5
	if (c_ssl  &&  c_ssl->kssl_ctx)
                {
                char	localhost[257];

		if (gethostname(localhost, 256) == 0)
                        {
			kssl_ctx_setstring(c_ssl->kssl_ctx, KSSL_SERVER,
                                localhost);
			}
		}
#endif    /* OPENSSL_NO_KRB5  */

d341 1
a341 4
		if (bio_pair)
			ret=doit_biopair(s_ssl,c_ssl,bytes,&s_time,&c_time);
		else
			ret=doit(s_ssl,c_ssl,bytes);
d346 5
a350 1
		print_details(c_ssl, "");
d353 1
a353 22
		BIO_printf(bio_stdout, "%d handshakes of %ld bytes done\n",number,bytes);
	if (print_time)
		{
#ifdef CLOCKS_PER_SEC
		/* "To determine the time in seconds, the value returned
		 * by the clock function should be divided by the value
		 * of the macro CLOCKS_PER_SEC."
		 *                                       -- ISO/IEC 9899 */
		BIO_printf(bio_stdout, "Approximate total server time: %6.2f s\n"
			"Approximate total client time: %6.2f s\n",
			(double)s_time/CLOCKS_PER_SEC,
			(double)c_time/CLOCKS_PER_SEC);
#else
		/* "`CLOCKS_PER_SEC' undeclared (first use this function)"
		 *                            -- cc on NeXTstep/OpenStep */
		BIO_printf(bio_stdout,
			"Approximate total server time: %6.2f units\n"
			"Approximate total client time: %6.2f units\n",
			(double)s_time,
			(double)c_time);
#endif
		}
a363 6
#ifndef OPENSSL_NO_RSA
	free_tmp_rsa();
#endif
	ENGINE_cleanup();
	CRYPTO_cleanup_all_ex_data();
	ERR_free_strings();
a366 1
	if (bio_err != NULL) BIO_free(bio_err);
a369 385
int doit_biopair(SSL *s_ssl, SSL *c_ssl, long count,
	clock_t *s_time, clock_t *c_time)
	{
	long cw_num = count, cr_num = count, sw_num = count, sr_num = count;
	BIO *s_ssl_bio = NULL, *c_ssl_bio = NULL;
	BIO *server = NULL, *server_io = NULL, *client = NULL, *client_io = NULL;
	int ret = 1;
	
	size_t bufsiz = 256; /* small buffer for testing */

	if (!BIO_new_bio_pair(&server, bufsiz, &server_io, bufsiz))
		goto err;
	if (!BIO_new_bio_pair(&client, bufsiz, &client_io, bufsiz))
		goto err;
	
	s_ssl_bio = BIO_new(BIO_f_ssl());
	if (!s_ssl_bio)
		goto err;

	c_ssl_bio = BIO_new(BIO_f_ssl());
	if (!c_ssl_bio)
		goto err;

	SSL_set_connect_state(c_ssl);
	SSL_set_bio(c_ssl, client, client);
	(void)BIO_set_ssl(c_ssl_bio, c_ssl, BIO_NOCLOSE);

	SSL_set_accept_state(s_ssl);
	SSL_set_bio(s_ssl, server, server);
	(void)BIO_set_ssl(s_ssl_bio, s_ssl, BIO_NOCLOSE);

	do
		{
		/* c_ssl_bio:          SSL filter BIO
		 *
		 * client:             pseudo-I/O for SSL library
		 *
		 * client_io:          client's SSL communication; usually to be
		 *                     relayed over some I/O facility, but in this
		 *                     test program, we're the server, too:
		 *
		 * server_io:          server's SSL communication
		 *
		 * server:             pseudo-I/O for SSL library
		 *
		 * s_ssl_bio:          SSL filter BIO
		 *
		 * The client and the server each employ a "BIO pair":
		 * client + client_io, server + server_io.
		 * BIO pairs are symmetric.  A BIO pair behaves similar
		 * to a non-blocking socketpair (but both endpoints must
		 * be handled by the same thread).
		 * [Here we could connect client and server to the ends
		 * of a single BIO pair, but then this code would be less
		 * suitable as an example for BIO pairs in general.]
		 *
		 * Useful functions for querying the state of BIO pair endpoints:
		 *
		 * BIO_ctrl_pending(bio)              number of bytes we can read now
		 * BIO_ctrl_get_read_request(bio)     number of bytes needed to fulfil
		 *                                      other side's read attempt
		 * BIO_ctrl_get_write_guarantee(bio)   number of bytes we can write now
		 *
		 * ..._read_request is never more than ..._write_guarantee;
		 * it depends on the application which one you should use.
		 */

		/* We have non-blocking behaviour throughout this test program, but
		 * can be sure that there is *some* progress in each iteration; so
		 * we don't have to worry about ..._SHOULD_READ or ..._SHOULD_WRITE
		 * -- we just try everything in each iteration
		 */

			{
			/* CLIENT */
		
			MS_STATIC char cbuf[1024*8];
			int i, r;
			clock_t c_clock = clock();

			if (debug)
				if (SSL_in_init(c_ssl))
					printf("client waiting in SSL_connect - %s\n",
						SSL_state_string_long(c_ssl));

			if (cw_num > 0)
				{
				/* Write to server. */
				
				if (cw_num > (long)sizeof cbuf)
					i = sizeof cbuf;
				else
					i = (int)cw_num;
				r = BIO_write(c_ssl_bio, cbuf, i);
				if (r < 0)
					{
					if (!BIO_should_retry(c_ssl_bio))
						{
						fprintf(stderr,"ERROR in CLIENT\n");
						goto err;
						}
					/* BIO_should_retry(...) can just be ignored here.
					 * The library expects us to call BIO_write with
					 * the same arguments again, and that's what we will
					 * do in the next iteration. */
					}
				else if (r == 0)
					{
					fprintf(stderr,"SSL CLIENT STARTUP FAILED\n");
					goto err;
					}
				else
					{
					if (debug)
						printf("client wrote %d\n", r);
					cw_num -= r;				
					}
				}

			if (cr_num > 0)
				{
				/* Read from server. */

				r = BIO_read(c_ssl_bio, cbuf, sizeof(cbuf));
				if (r < 0)
					{
					if (!BIO_should_retry(c_ssl_bio))
						{
						fprintf(stderr,"ERROR in CLIENT\n");
						goto err;
						}
					/* Again, "BIO_should_retry" can be ignored. */
					}
				else if (r == 0)
					{
					fprintf(stderr,"SSL CLIENT STARTUP FAILED\n");
					goto err;
					}
				else
					{
					if (debug)
						printf("client read %d\n", r);
					cr_num -= r;
					}
				}

			/* c_time and s_time increments will typically be very small
			 * (depending on machine speed and clock tick intervals),
			 * but sampling over a large number of connections should
			 * result in fairly accurate figures.  We cannot guarantee
			 * a lot, however -- if each connection lasts for exactly
			 * one clock tick, it will be counted only for the client
			 * or only for the server or even not at all.
			 */
			*c_time += (clock() - c_clock);
			}

			{
			/* SERVER */
		
			MS_STATIC char sbuf[1024*8];
			int i, r;
			clock_t s_clock = clock();

			if (debug)
				if (SSL_in_init(s_ssl))
					printf("server waiting in SSL_accept - %s\n",
						SSL_state_string_long(s_ssl));

			if (sw_num > 0)
				{
				/* Write to client. */
				
				if (sw_num > (long)sizeof sbuf)
					i = sizeof sbuf;
				else
					i = (int)sw_num;
				r = BIO_write(s_ssl_bio, sbuf, i);
				if (r < 0)
					{
					if (!BIO_should_retry(s_ssl_bio))
						{
						fprintf(stderr,"ERROR in SERVER\n");
						goto err;
						}
					/* Ignore "BIO_should_retry". */
					}
				else if (r == 0)
					{
					fprintf(stderr,"SSL SERVER STARTUP FAILED\n");
					goto err;
					}
				else
					{
					if (debug)
						printf("server wrote %d\n", r);
					sw_num -= r;				
					}
				}

			if (sr_num > 0)
				{
				/* Read from client. */

				r = BIO_read(s_ssl_bio, sbuf, sizeof(sbuf));
				if (r < 0)
					{
					if (!BIO_should_retry(s_ssl_bio))
						{
						fprintf(stderr,"ERROR in SERVER\n");
						goto err;
						}
					/* blah, blah */
					}
				else if (r == 0)
					{
					fprintf(stderr,"SSL SERVER STARTUP FAILED\n");
					goto err;
					}
				else
					{
					if (debug)
						printf("server read %d\n", r);
					sr_num -= r;
					}
				}

			*s_time += (clock() - s_clock);
			}
			
			{
			/* "I/O" BETWEEN CLIENT AND SERVER. */

			size_t r1, r2;
			BIO *io1 = server_io, *io2 = client_io;
			/* we use the non-copying interface for io1
			 * and the standard BIO_write/BIO_read interface for io2
			 */
			
			static int prev_progress = 1;
			int progress = 0;
			
			/* io1 to io2 */
			do
				{
				size_t num;
				int r;

				r1 = BIO_ctrl_pending(io1);
				r2 = BIO_ctrl_get_write_guarantee(io2);

				num = r1;
				if (r2 < num)
					num = r2;
				if (num)
					{
					char *dataptr;

					if (INT_MAX < num) /* yeah, right */
						num = INT_MAX;
					
					r = BIO_nread(io1, &dataptr, (int)num);
					assert(r > 0);
					assert(r <= (int)num);
					/* possibly r < num (non-contiguous data) */
					num = r;
					r = BIO_write(io2, dataptr, (int)num);
					if (r != (int)num) /* can't happen */
						{
						fprintf(stderr, "ERROR: BIO_write could not write "
							"BIO_ctrl_get_write_guarantee() bytes");
						goto err;
						}
					progress = 1;

					if (debug)
						printf((io1 == client_io) ?
							"C->S relaying: %d bytes\n" :
							"S->C relaying: %d bytes\n",
							(int)num);
					}
				}
			while (r1 && r2);

			/* io2 to io1 */
			{
				size_t num;
				int r;

				r1 = BIO_ctrl_pending(io2);
				r2 = BIO_ctrl_get_read_request(io1);
				/* here we could use ..._get_write_guarantee instead of
				 * ..._get_read_request, but by using the latter
				 * we test restartability of the SSL implementation
				 * more thoroughly */
				num = r1;
				if (r2 < num)
					num = r2;
				if (num)
					{
					char *dataptr;
					
					if (INT_MAX < num)
						num = INT_MAX;

					if (num > 1)
						--num; /* test restartability even more thoroughly */
					
					r = BIO_nwrite0(io1, &dataptr);
					assert(r > 0);
					if (r < (int)num)
						num = r;
					r = BIO_read(io2, dataptr, (int)num);
					if (r != (int)num) /* can't happen */
						{
						fprintf(stderr, "ERROR: BIO_read could not read "
							"BIO_ctrl_pending() bytes");
						goto err;
						}
					progress = 1;
					r = BIO_nwrite(io1, &dataptr, (int)num);
					if (r != (int)num) /* can't happen */
						{
						fprintf(stderr, "ERROR: BIO_nwrite() did not accept "
							"BIO_nwrite0() bytes");
						goto err;
						}
					
					if (debug)
						printf((io2 == client_io) ?
							"C->S relaying: %d bytes\n" :
							"S->C relaying: %d bytes\n",
							(int)num);
					}
			} /* no loop, BIO_ctrl_get_read_request now returns 0 anyway */

			if (!progress && !prev_progress)
				if (cw_num > 0 || cr_num > 0 || sw_num > 0 || sr_num > 0)
					{
					fprintf(stderr, "ERROR: got stuck\n");
					if (strcmp("SSLv2", SSL_get_version(c_ssl)) == 0)
						{
						fprintf(stderr, "This can happen for SSL2 because "
							"CLIENT-FINISHED and SERVER-VERIFY are written \n"
							"concurrently ...");
						if (strncmp("2SCF", SSL_state_string(c_ssl), 4) == 0
							&& strncmp("2SSV", SSL_state_string(s_ssl), 4) == 0)
							{
							fprintf(stderr, " ok.\n");
							goto end;
							}
						}
					fprintf(stderr, " ERROR.\n");
					goto err;
					}
			prev_progress = progress;
			}
		}
	while (cw_num > 0 || cr_num > 0 || sw_num > 0 || sr_num > 0);

	if (verbose)
		print_details(c_ssl, "DONE via BIO pair: ");
end:
	ret = 0;

 err:
	ERR_print_errors(bio_err);
	
	if (server)
		BIO_free(server);
	if (server_io)
		BIO_free(server_io);
	if (client)
		BIO_free(client);
	if (client_io)
		BIO_free(client_io);
	if (s_ssl_bio)
		BIO_free(s_ssl_bio);
	if (c_ssl_bio)
		BIO_free(c_ssl_bio);

	return ret;
	}


d375 3
a377 1
int doit(SSL *s_ssl, SSL *c_ssl, long count)
d393 1
d643 1
d645 4
a648 1
		print_details(c_ssl, "DONE: ");
d652 1
a652 1
	 * OPENSSL_free()ed twice.  Once when th s_ssl is SSL_free()ed and
d676 3
a678 1
static int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx)
d706 12
a717 44
static int MS_CALLBACK app_verify_callback(X509_STORE_CTX *ctx, void *arg)
	{
	char *s = NULL,buf[256];
	int ok=1;

	fprintf(stderr, "In app_verify_callback, allowing cert. ");
	fprintf(stderr, "Arg is: %s\n", (char *)arg);
	fprintf(stderr, "Finished printing do we have a context? 0x%x a cert? 0x%x\n",
			(unsigned int)ctx, (unsigned int)ctx->cert);
	if (ctx->cert)
		s=X509_NAME_oneline(X509_get_subject_name(ctx->cert),buf,256);
	if (s != NULL)
		{
			fprintf(stderr,"cert depth=%d %s\n",ctx->error_depth,buf);
		}

	return(ok);
	}

#ifndef OPENSSL_NO_RSA
static RSA *rsa_tmp=NULL;

static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength)
	{
	if (rsa_tmp == NULL)
		{
		BIO_printf(bio_err,"Generating temp (%d bit) RSA key...",keylength);
		(void)BIO_flush(bio_err);
		rsa_tmp=RSA_generate_key(keylength,RSA_F4,NULL,NULL);
		BIO_printf(bio_err,"\n");
		(void)BIO_flush(bio_err);
		}
	return(rsa_tmp);
	}

static void free_tmp_rsa(void)
	{
	if (rsa_tmp != NULL)
		{
		RSA_free(rsa_tmp);
		rsa_tmp = NULL;
		}
	}
#endif
a718 7
#ifndef OPENSSL_NO_DH
/* These DH parameters have been generated as follows:
 *    $ openssl dhparam -C -noout 512
 *    $ openssl dhparam -C -noout 1024
 *    $ openssl dhparam -C -noout -dsaparam 1024
 * (The third function has been renamed to avoid name conflicts.)
 */
d721 1
a721 12
	static unsigned char dh512_p[]={
		0xCB,0xC8,0xE1,0x86,0xD0,0x1F,0x94,0x17,0xA6,0x99,0xF0,0xC6,
		0x1F,0x0D,0xAC,0xB6,0x25,0x3E,0x06,0x39,0xCA,0x72,0x04,0xB0,
		0x6E,0xDA,0xC0,0x61,0xE6,0x7A,0x77,0x25,0xE8,0x3B,0xB9,0x5F,
		0x9A,0xB6,0xB5,0xFE,0x99,0x0B,0xA1,0x93,0x4E,0x35,0x33,0xB8,
		0xE1,0xF1,0x13,0x4F,0x59,0x1A,0xD2,0x57,0xC0,0x26,0x21,0x33,
		0x02,0xC5,0xAE,0x23,
		};
	static unsigned char dh512_g[]={
		0x02,
		};
	DH *dh;
d727 1
a727 1
		{ DH_free(dh); return(NULL); }
d730 1
d732 3
a734 1
static DH *get_dh1024()
d736 1
a736 17
	static unsigned char dh1024_p[]={
		0xF8,0x81,0x89,0x7D,0x14,0x24,0xC5,0xD1,0xE6,0xF7,0xBF,0x3A,
		0xE4,0x90,0xF4,0xFC,0x73,0xFB,0x34,0xB5,0xFA,0x4C,0x56,0xA2,
		0xEA,0xA7,0xE9,0xC0,0xC0,0xCE,0x89,0xE1,0xFA,0x63,0x3F,0xB0,
		0x6B,0x32,0x66,0xF1,0xD1,0x7B,0xB0,0x00,0x8F,0xCA,0x87,0xC2,
		0xAE,0x98,0x89,0x26,0x17,0xC2,0x05,0xD2,0xEC,0x08,0xD0,0x8C,
		0xFF,0x17,0x52,0x8C,0xC5,0x07,0x93,0x03,0xB1,0xF6,0x2F,0xB8,
		0x1C,0x52,0x47,0x27,0x1B,0xDB,0xD1,0x8D,0x9D,0x69,0x1D,0x52,
		0x4B,0x32,0x81,0xAA,0x7F,0x00,0xC8,0xDC,0xE6,0xD9,0xCC,0xC1,
		0x11,0x2D,0x37,0x34,0x6C,0xEA,0x02,0x97,0x4B,0x0E,0xBB,0xB1,
		0x71,0x33,0x09,0x15,0xFD,0xDD,0x23,0x87,0x07,0x5E,0x89,0xAB,
		0x6B,0x7C,0x5F,0xEC,0xA6,0x24,0xDC,0x53,
		};
	static unsigned char dh1024_g[]={
		0x02,
		};
	DH *dh;
d738 11
a748 6
	if ((dh=DH_new()) == NULL) return(NULL);
	dh->p=BN_bin2bn(dh1024_p,sizeof(dh1024_p),NULL);
	dh->g=BN_bin2bn(dh1024_g,sizeof(dh1024_g),NULL);
	if ((dh->p == NULL) || (dh->g == NULL))
		{ DH_free(dh); return(NULL); }
	return(dh);
a750 29
static DH *get_dh1024dsa()
	{
	static unsigned char dh1024_p[]={
		0xC8,0x00,0xF7,0x08,0x07,0x89,0x4D,0x90,0x53,0xF3,0xD5,0x00,
		0x21,0x1B,0xF7,0x31,0xA6,0xA2,0xDA,0x23,0x9A,0xC7,0x87,0x19,
		0x3B,0x47,0xB6,0x8C,0x04,0x6F,0xFF,0xC6,0x9B,0xB8,0x65,0xD2,
		0xC2,0x5F,0x31,0x83,0x4A,0xA7,0x5F,0x2F,0x88,0x38,0xB6,0x55,
		0xCF,0xD9,0x87,0x6D,0x6F,0x9F,0xDA,0xAC,0xA6,0x48,0xAF,0xFC,
		0x33,0x84,0x37,0x5B,0x82,0x4A,0x31,0x5D,0xE7,0xBD,0x52,0x97,
		0xA1,0x77,0xBF,0x10,0x9E,0x37,0xEA,0x64,0xFA,0xCA,0x28,0x8D,
		0x9D,0x3B,0xD2,0x6E,0x09,0x5C,0x68,0xC7,0x45,0x90,0xFD,0xBB,
		0x70,0xC9,0x3A,0xBB,0xDF,0xD4,0x21,0x0F,0xC4,0x6A,0x3C,0xF6,
		0x61,0xCF,0x3F,0xD6,0x13,0xF1,0x5F,0xBC,0xCF,0xBC,0x26,0x9E,
		0xBC,0x0B,0xBD,0xAB,0x5D,0xC9,0x54,0x39,
		};
	static unsigned char dh1024_g[]={
		0x3B,0x40,0x86,0xE7,0xF3,0x6C,0xDE,0x67,0x1C,0xCC,0x80,0x05,
		0x5A,0xDF,0xFE,0xBD,0x20,0x27,0x74,0x6C,0x24,0xC9,0x03,0xF3,
		0xE1,0x8D,0xC3,0x7D,0x98,0x27,0x40,0x08,0xB8,0x8C,0x6A,0xE9,
		0xBB,0x1A,0x3A,0xD6,0x86,0x83,0x5E,0x72,0x41,0xCE,0x85,0x3C,
		0xD2,0xB3,0xFC,0x13,0xCE,0x37,0x81,0x9E,0x4C,0x1C,0x7B,0x65,
		0xD3,0xE6,0xA6,0x00,0xF5,0x5A,0x95,0x43,0x5E,0x81,0xCF,0x60,
		0xA2,0x23,0xFC,0x36,0xA7,0x5D,0x7A,0x4C,0x06,0x91,0x6E,0xF6,
		0x57,0xEE,0x36,0xCB,0x06,0xEA,0xF5,0x3D,0x95,0x49,0xCB,0xA7,
		0xDD,0x81,0xDF,0x80,0x09,0x4A,0x97,0x4D,0xA8,0x22,0x72,0xA1,
		0x7F,0xC4,0x70,0x56,0x70,0xE8,0x20,0x10,0x18,0x8F,0x2E,0x60,
		0x07,0xE7,0x68,0x1A,0x82,0x5D,0x32,0xA2,
		};
	DH *dh;
a751 9
	if ((dh=DH_new()) == NULL) return(NULL);
	dh->p=BN_bin2bn(dh1024_p,sizeof(dh1024_p),NULL);
	dh->g=BN_bin2bn(dh1024_g,sizeof(dh1024_g),NULL);
	if ((dh->p == NULL) || (dh->g == NULL))
		{ DH_free(dh); return(NULL); }
	dh->length = 160;
	return(dh);
	}
#endif
@


1.1.1.3
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d403 1
a404 2
			{
#ifndef OPENSSL_NO_DH
a405 4
#else
			fprintf(stderr,"ignoring -dhe1024, since I'm compiled without DH\n";
#endif
			}
a406 2
			{
#ifndef OPENSSL_NO_DH
a407 2
#else
			fprintf(stderr,"ignoring -dhe1024, since I'm compiled without DH\n";
a408 1
			}
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d112 1
a112 1
#define _BSD_SOURCE 1		/* Or gethostname won't be declared properly
d114 3
a125 1
#define USE_SOCKETS
a132 1
#ifndef OPENSSL_NO_ENGINE
a133 1
#endif
a135 7

#define _XOPEN_SOURCE_EXTENDED	1 /* Or gethostname won't be declared properly
				     on Compaq platforms (at least with DEC C).
				     Do not try to put it earlier, or IPv6 includes
				     get screwed...
				  */

d138 1
a145 3
#elif defined(OPENSSL_SYS_WINCE)
#  define TEST_SERVER_CERT "\\OpenSSL\\server.pem"
#  define TEST_CLIENT_CERT "\\OpenSSL\\client.pem"
d367 1
a367 3

	bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);	

d385 1
d408 1
a408 1
			fprintf(stderr,"ignoring -dhe1024, since I'm compiled without DH\n");
d416 1
a416 1
			fprintf(stderr,"ignoring -dhe1024, since I'm compiled without DH\n");
d533 1
a533 1
		EXIT(1);
d689 1
a689 1
                char	localhost[MAXHOSTNAMELEN+2];
d691 1
a691 1
		if (gethostname(localhost, sizeof localhost-1) == 0)
a692 6
			localhost[sizeof localhost-1]='\0';
			if(strlen(localhost) == sizeof localhost-1)
				{
				BIO_printf(bio_err,"localhost name too long\n");
				goto end;
				}
a747 1
#ifndef OPENSSL_NO_ENGINE
a748 1
#endif
a837 2
			memset(cbuf, 0, sizeof(cbuf));

a921 2
			memset(sbuf, 0, sizeof(sbuf));

a1164 3
	memset(cbuf,0,sizeof(cbuf));
	memset(sbuf,0,sizeof(sbuf));

d1446 1
a1446 2
	s=X509_NAME_oneline(X509_get_subject_name(ctx->current_cert),buf,
			    sizeof buf);
@


1.1.1.5
log
@import 0.9.7c
@
text
@d293 1
a293 1
	if (type < 0 || type >= CRYPTO_NUM_LOCKS)
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d567 1
a567 8
			{
			if (SSL_COMP_add_compression_method(comp, cm) != 0)
				{
				fprintf(stderr,
					"Failed to add compression method\n");
				ERR_print_errors_fp(stderr);
				}
			}
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a121 1
#include <ctype.h>
a129 1
#include <openssl/x509v3.h>
a135 1
#include <openssl/fips.h>
d171 2
a172 9
#define APP_CALLBACK_STRING "Test Callback Argument"
struct app_verify_arg
	{
	char *string;
	int app_verify;
	int allow_proxy_certs;
	char *proxy_auth;
	char *proxy_cond;
	};
a200 3
#ifdef OPENSSL_FIPS
	fprintf(stderr,"-F             - run test in FIPS mode\n");
#endif
a202 3
	fprintf(stderr," -proxy        - allow proxy certificates\n");
	fprintf(stderr," -proxy_auth <val> - set proxy policy rights\n");
	fprintf(stderr," -proxy_cond <val> - experssion to test proxy policy rights\n");
d352 1
a352 2
	struct app_verify_arg app_verify_arg =
		{ APP_CALLBACK_STRING, 0, 0, NULL, NULL };
a371 4
#ifdef OPENSSL_FIPS
	int fips_mode=0;
	const char *path=argv[0];
#endif
d403 1
a403 10
		if(!strcmp(*argv,"-F"))
			{
#ifdef OPENSSL_FIPS
			fips_mode=1;
#else
			fprintf(stderr,"not compiled with FIPS support, so exitting without running.\n");
			EXIT(0);
#endif
			}
		else if	(strcmp(*argv,"-server_auth") == 0)
a406 10
		else if (strcmp(*argv,"-proxy_auth") == 0)
			{
			if (--argc < 1) goto bad;
			app_verify_arg.proxy_auth= *(++argv);
			}
		else if (strcmp(*argv,"-proxy_cond") == 0)
			{
			if (--argc < 1) goto bad;
			app_verify_arg.proxy_cond= *(++argv);
			}
d519 1
a519 5
			app_verify_arg.app_verify = 1;
			}
		else if	(strcmp(*argv,"-proxy") == 0)
			{
			app_verify_arg.allow_proxy_certs = 1;
a536 1

a545 14
#ifdef OPENSSL_FIPS
	if(fips_mode)
		{
		if(!FIPS_mode_set(1,path))
			{
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
			EXIT(1);
			}
		else
			fprintf(stderr,"*** IN FIPS MODE ***\n");
		}
#endif

d679 4
a682 1
		SSL_CTX_set_cert_verify_callback(s_ctx, app_verify_callback, &app_verify_arg);
d689 4
a692 1
		SSL_CTX_set_cert_verify_callback(c_ctx, app_verify_callback, &app_verify_arg);
a1473 16
static int get_proxy_auth_ex_data_idx(void)
	{
	static volatile int idx = -1;
	if (idx < 0)
		{
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
		if (idx < 0)
			{
			idx = X509_STORE_CTX_get_ex_new_index(0,
				"SSLtest for verify callback", NULL,NULL,NULL);
			}
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
		}
	return idx;
	}

d1483 1
a1483 2
			fprintf(stderr,"depth=%d %s\n",
				ctx->error_depth,buf);
a1484 1
			{
a1486 1
			}
a1490 2
		fprintf(stderr,"Error string: %s\n",
			X509_verify_cert_error_string(ctx->error));
a1495 1
			fprintf(stderr,"  ... ignored.\n");
a1499 101
	if (ok == 1)
		{
		X509 *xs = ctx->current_cert;
#if 0
		X509 *xi = ctx->current_issuer;
#endif

		if (xs->ex_flags & EXFLAG_PROXY)
			{
			unsigned int *letters =
				X509_STORE_CTX_get_ex_data(ctx,
					get_proxy_auth_ex_data_idx());

			if (letters)
				{
				int found_any = 0;
				int i;
				PROXY_CERT_INFO_EXTENSION *pci =
					X509_get_ext_d2i(xs, NID_proxyCertInfo,
						NULL, NULL);

				switch (OBJ_obj2nid(pci->proxyPolicy->policyLanguage))
					{
				case NID_Independent:
					/* Completely meaningless in this
					   program, as there's no way to
					   grant explicit rights to a
					   specific PrC.  Basically, using
					   id-ppl-Independent is the perfect
					   way to grant no rights at all. */
					fprintf(stderr, "  Independent proxy certificate");
					for (i = 0; i < 26; i++)
						letters[i] = 0;
					break;
				case NID_id_ppl_inheritAll:
					/* This is basically a NOP, we
					   simply let the current rights
					   stand as they are. */
					fprintf(stderr, "  Proxy certificate inherits all");
					break;
				default:
					s = (char *)
						pci->proxyPolicy->policy->data;
					i = pci->proxyPolicy->policy->length;

					/* The algorithm works as follows:
					   it is assumed that previous
					   iterations or the initial granted
					   rights has already set some elements
					   of `letters'.  What we need to do is
					   to clear those that weren't granted
					   by the current PrC as well.  The
					   easiest way to do this is to add 1
					   to all the elements whose letters
					   are given with the current policy.
					   That way, all elements that are set
					   by the current policy and were
					   already set by earlier policies and
					   through the original grant of rights
					   will get the value 2 or higher.
					   The last thing to do is to sweep
					   through `letters' and keep the
					   elements having the value 2 as set,
					   and clear all the others. */

					fprintf(stderr, "  Certificate proxy rights = %*.*s", i, i, s);
					while(i-- > 0)
						{
						char c = *s++;
						if (isascii(c) && isalpha(c))
							{
							if (islower(c))
								c = toupper(c);
							letters[c - 'A']++;
							}
						}
					for (i = 0; i < 26; i++)
						if (letters[i] < 2)
							letters[i] = 0;
						else
							letters[i] = 1;
					}

				found_any = 0;
				fprintf(stderr,
					", resulting proxy rights = ");
				for(i = 0; i < 26; i++)
					if (letters[i])
						{
						fprintf(stderr, "%c", i + 'A');
						found_any = 1;
						}
				if (!found_any)
					fprintf(stderr, "none");
				fprintf(stderr, "\n");

				PROXY_CERT_INFO_EXTENSION_free(pci);
				}
			}
		}

a1502 238
static void process_proxy_debug(int indent, const char *format, ...)
	{
	static const char indentation[] =
		">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
		">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"; /* That's 80 > */
	char my_format[256];
	va_list args;

	BIO_snprintf(my_format, sizeof(my_format), "%*.*s %s",
		indent, indent, indentation, format);

	va_start(args, format);
	vfprintf(stderr, my_format, args);
	va_end(args);
	}
/* Priority levels:
   0	[!]var, ()
   1	& ^
   2	|
*/
static int process_proxy_cond_adders(unsigned int letters[26],
	const char *cond, const char **cond_end, int *pos, int indent);
static int process_proxy_cond_val(unsigned int letters[26],
	const char *cond, const char **cond_end, int *pos, int indent)
	{
	char c;
	int ok = 1;
	int negate = 0;

	while(isspace(*cond))
		{
		cond++; (*pos)++;
		}
	c = *cond;

	if (debug)
		process_proxy_debug(indent,
			"Start process_proxy_cond_val at position %d: %s\n",
			*pos, cond);

	while(c == '!')
		{
		negate = !negate;
		cond++; (*pos)++;
		while(isspace(*cond))
			{
			cond++; (*pos)++;
			}
		c = *cond;
		}

	if (c == '(')
		{
		cond++; (*pos)++;
		ok = process_proxy_cond_adders(letters, cond, cond_end, pos,
			indent + 1);
		cond = *cond_end;
		if (ok < 0)
			goto end;
		while(isspace(*cond))
			{
			cond++; (*pos)++;
			}
		c = *cond;
		if (c != ')')
			{
			fprintf(stderr,
				"Weird condition character in position %d: "
				"%c\n", *pos, c);
			ok = -1;
			goto end;
			}
		cond++; (*pos)++;
		}
	else if (isascii(c) && isalpha(c))
		{
		if (islower(c))
			c = toupper(c);
		ok = letters[c - 'A'];
		cond++; (*pos)++;
		}
	else
		{
		fprintf(stderr,
			"Weird condition character in position %d: "
			"%c\n", *pos, c);
		ok = -1;
		goto end;
		}
 end:
	*cond_end = cond;
	if (ok >= 0 && negate)
		ok = !ok;

	if (debug)
		process_proxy_debug(indent,
			"End process_proxy_cond_val at position %d: %s, returning %d\n",
			*pos, cond, ok);

	return ok;
	}
static int process_proxy_cond_multipliers(unsigned int letters[26],
	const char *cond, const char **cond_end, int *pos, int indent)
	{
	int ok;
	char c;

	if (debug)
		process_proxy_debug(indent,
			"Start process_proxy_cond_multipliers at position %d: %s\n",
			*pos, cond);

	ok = process_proxy_cond_val(letters, cond, cond_end, pos, indent + 1);
	cond = *cond_end;
	if (ok < 0)
		goto end;

	while(ok >= 0)
		{
		while(isspace(*cond))
			{
			cond++; (*pos)++;
			}
		c = *cond;

		switch(c)
			{
		case '&':
		case '^':
			{
			int save_ok = ok;

			cond++; (*pos)++;
			ok = process_proxy_cond_val(letters,
				cond, cond_end, pos, indent + 1);
			cond = *cond_end;
			if (ok < 0)
				break;

			switch(c)
				{
			case '&':
				ok &= save_ok;
				break;
			case '^':
				ok ^= save_ok;
				break;
			default:
				fprintf(stderr, "SOMETHING IS SERIOUSLY WRONG!"
					" STOPPING\n");
				EXIT(1);
				}
			}
			break;
		default:
			goto end;
			}
		}
 end:
	if (debug)
		process_proxy_debug(indent,
			"End process_proxy_cond_multipliers at position %d: %s, returning %d\n",
			*pos, cond, ok);

	*cond_end = cond;
	return ok;
	}
static int process_proxy_cond_adders(unsigned int letters[26],
	const char *cond, const char **cond_end, int *pos, int indent)
	{
	int ok;
	char c;

	if (debug)
		process_proxy_debug(indent,
			"Start process_proxy_cond_adders at position %d: %s\n",
			*pos, cond);

	ok = process_proxy_cond_multipliers(letters, cond, cond_end, pos,
		indent + 1);
	cond = *cond_end;
	if (ok < 0)
		goto end;

	while(ok >= 0)
		{
		while(isspace(*cond))
			{
			cond++; (*pos)++;
			}
		c = *cond;

		switch(c)
			{
		case '|':
			{
			int save_ok = ok;

			cond++; (*pos)++;
			ok = process_proxy_cond_multipliers(letters,
				cond, cond_end, pos, indent + 1);
			cond = *cond_end;
			if (ok < 0)
				break;

			switch(c)
				{
			case '|':
				ok |= save_ok;
				break;
			default:
				fprintf(stderr, "SOMETHING IS SERIOUSLY WRONG!"
					" STOPPING\n");
				EXIT(1);
				}
			}
			break;
		default:
			goto end;
			}
		}
 end:
	if (debug)
		process_proxy_debug(indent,
			"End process_proxy_cond_adders at position %d: %s, returning %d\n",
			*pos, cond, ok);

	*cond_end = cond;
	return ok;
	}

static int process_proxy_cond(unsigned int letters[26],
	const char *cond, const char **cond_end)
	{
	int pos = 1;
	return process_proxy_cond_adders(letters, cond, cond_end, &pos, 1);
	}

d1505 1
a1506 2
	struct app_verify_arg *cb_arg = arg;
	unsigned int letters[26]; /* only used with proxy_auth */
d1508 7
a1514 1
	if (cb_arg->app_verify)
a1515 10
		char *s = NULL,buf[256];

		fprintf(stderr, "In app_verify_callback, allowing cert. ");
		fprintf(stderr, "Arg is: %s\n", cb_arg->string);
		fprintf(stderr, "Finished printing do we have a context? 0x%x a cert? 0x%x\n",
			(unsigned int)ctx, (unsigned int)ctx->cert);
		if (ctx->cert)
			s=X509_NAME_oneline(X509_get_subject_name(ctx->cert),buf,256);
		if (s != NULL)
			{
a1516 2
			}
		return(1);
a1517 17
	if (cb_arg->proxy_auth)
		{
		int found_any = 0, i;
		char *sp;

		for(i = 0; i < 26; i++)
			letters[i] = 0;
		for(sp = cb_arg->proxy_auth; *sp; sp++)
			{
			char c = *sp;
			if (isascii(c) && isalpha(c))
				{
				if (islower(c))
					c = toupper(c);
				letters[c - 'A'] = 1;
				}
			}
a1518 56
		fprintf(stderr,
			"  Initial proxy rights = ");
		for(i = 0; i < 26; i++)
			if (letters[i])
				{
				fprintf(stderr, "%c", i + 'A');
				found_any = 1;
				}
		if (!found_any)
			fprintf(stderr, "none");
		fprintf(stderr, "\n");

		X509_STORE_CTX_set_ex_data(ctx,
			get_proxy_auth_ex_data_idx(),letters);
		}
	if (cb_arg->allow_proxy_certs)
		{
		X509_STORE_CTX_set_flags(ctx, X509_V_FLAG_ALLOW_PROXY_CERTS);
		}

#ifndef OPENSSL_NO_X509_VERIFY
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(1);
# endif
	ok = X509_verify_cert(ctx);
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(0);
# endif
#endif

	if (cb_arg->proxy_auth)
		{
		if (ok)
			{
			const char *cond_end = NULL;

			ok = process_proxy_cond(letters,
				cb_arg->proxy_cond, &cond_end);

			if (ok < 0)
				EXIT(3);
			if (*cond_end)
				{
				fprintf(stderr, "Stopped processing condition before it's end.\n");
				ok = 0;
				}
			if (!ok)
				fprintf(stderr, "Proxy rights check with condition '%s' proved invalid\n",
					cb_arg->proxy_cond);
			else
				fprintf(stderr, "Proxy rights check with condition '%s' proved valid\n",
					cb_arg->proxy_cond);
			}
		}
@


1.1.1.8
log
@import of openssl-0.9.7j
@
text
@d122 1
a126 4
#define _XOPEN_SOURCE 500	/* Or isascii won't be declared properly on
				   VMS (at least with DECompHP C).  */
#include <ctype.h>

d391 1
d594 1
a594 1
		if(!FIPS_mode_set(1))
d1929 2
a1930 2
		fprintf(stderr, "Finished printing do we have a context? 0x%p a cert? 0x%p\n",
			(void *)ctx, (void *)ctx->cert);
d1978 4
d1983 4
@


1.1.1.9
log
@import of OpenSSL 0.9.8h
@
text
@a110 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
d141 1
a141 10
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
#include <openssl/bn.h>
a160 3
#elif defined(OPENSSL_SYS_NETWARE)
#  define TEST_SERVER_CERT "\\openssl\\apps\\server.pem"
#  define TEST_CLIENT_CERT "\\openssl\\apps\\client.pem"
d168 2
a169 2
#define COMP_RLE	255
#define COMP_ZLIB	1
a209 1
static int do_test_cipherlist(void);
d214 3
a231 3
#ifndef OPENSSL_NO_ECDH
	fprintf(stderr," -no_ecdhe     - disable ECDHE\n");
#endif
d252 1
a252 7
	fprintf(stderr," -rle          - use rle compression\n");
#ifndef OPENSSL_NO_ECDH
	fprintf(stderr," -named_curve arg  - Elliptic curve name to use for ephemeral ECDH keys.\n" \
	               "                 Use \"openssl ecparam -list_curves\" for all names\n"  \
	               "                 (default is sect163r2).\n");
#endif
	fprintf(stderr," -test_cipherlist - verifies the order of the ssl cipher lists\n");
a361 1

a376 3
#ifndef OPENSSL_NO_ECDH
	char *named_curve = NULL;
#endif
d382 1
a382 1
	long bytes=256L;
a386 3
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh = NULL;
#endif
a387 1
	int no_ecdhe = 0;
a390 1
#ifndef OPENSSL_NO_COMP
d392 2
a394 2
	STACK_OF(SSL_COMP) *ssl_comp_methods = NULL;
	int test_cipherlist = 0;
d426 10
a435 1
		if	(strcmp(*argv,"-server_auth") == 0)
a472 2
		else if	(strcmp(*argv,"-no_ecdhe") == 0)
			no_ecdhe=1;
a558 10
		else if	(strcmp(*argv,"-named_curve") == 0)
			{
			if (--argc < 1) goto bad;
#ifndef OPENSSL_NO_ECDH		
			named_curve = *(++argv);
#else
			fprintf(stderr,"ignoring -named_curve, since I'm compiled without ECDH\n");
			++argv;
#endif
			}
a566 4
		else if (strcmp(*argv,"-test_cipherlist") == 0)
			{
			test_cipherlist = 1;
			}
a582 8
	if (test_cipherlist == 1)
		{
		/* ensure that the cipher list are correctly sorted and exit */
		if (do_test_cipherlist() == 0)
			EXIT(1);
		ret = 0;
		goto end;
		}
d593 14
a622 1
#ifndef OPENSSL_NO_COMP
a645 14
	ssl_comp_methods = SSL_COMP_get_compression_methods();
	fprintf(stderr, "Available compression methods:\n");
	{
	int j, n = sk_SSL_COMP_num(ssl_comp_methods);
	if (n == 0)
		fprintf(stderr, "  NONE\n");
	else
		for (j = 0; j < n; j++)
			{
			SSL_COMP *c = sk_SSL_COMP_value(ssl_comp_methods, j);
			fprintf(stderr, "  %d: %s\n", c->id, c->name);
			}
	}
#endif
a699 32
#ifndef OPENSSL_NO_ECDH
	if (!no_ecdhe)
		{
		int nid;

		if (named_curve != NULL)
			{
			nid = OBJ_sn2nid(named_curve);
			if (nid == 0)
			{
				BIO_printf(bio_err, "unknown curve name (%s)\n", named_curve);
				goto end;
				}
			}
		else
			nid = NID_sect163r2;

		ecdh = EC_KEY_new_by_curve_name(nid);
		if (ecdh == NULL)
			{
			BIO_printf(bio_err, "unable to create curve\n");
			goto end;
			}

		SSL_CTX_set_tmp_ecdh(s_ctx, ecdh);
		SSL_CTX_set_options(s_ctx, SSL_OP_SINGLE_ECDH_USE);
		EC_KEY_free(ecdh);
		}
#else
	(void)no_ecdhe;
#endif

a835 1
	return ret;
d1326 2
a1327 2
				j = (cw_num > (long)sizeof(cbuf)) ?
					(int)sizeof(cbuf) : (int)cw_num;
d1457 2
a1458 2
				j = (sw_num > (long)sizeof(sbuf)) ?
					(int)sizeof(sbuf) : (int)sw_num;
d1645 1
a1645 1
						int c = *s++;
d1706 1
a1706 1
	int c;
d1710 1
a1710 1
	while(isspace((int)*cond))
d1725 1
a1725 1
		while(isspace((int)*cond))
d1740 1
a1740 1
		while(isspace((int)*cond))
d1800 1
a1800 1
		while(isspace((int)*cond))
d1867 1
a1867 1
		while(isspace((int)*cond))
d1950 1
a1950 1
			int c = *sp;
a1979 4
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(1);
# endif
a1980 4
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(0);
# endif
a2014 1
	BIGNUM *bn = NULL;
a2016 7
		bn = BN_new();
		rsa_tmp = RSA_new();
		if(!bn || !rsa_tmp || !BN_set_word(bn, RSA_F4))
			{
			BIO_printf(bio_err, "Memory error...");
			goto end;
			}
d2019 1
a2019 7
		if(!RSA_generate_key_ex(rsa_tmp,keylength,bn,NULL))
			{
			BIO_printf(bio_err, "Error generating key.");
			RSA_free(rsa_tmp);
			rsa_tmp = NULL;
			}
end:
a2022 1
	if(bn) BN_free(bn);
a2132 57

static int do_test_cipherlist(void)
	{
	int i = 0;
	const SSL_METHOD *meth;
	SSL_CIPHER *ci, *tci = NULL;

#ifndef OPENSSL_NO_SSL2
	fprintf(stderr, "testing SSLv2 cipher list order: ");
	meth = SSLv2_method();
	while ((ci = meth->get_cipher(i++)) != NULL)
		{
		if (tci != NULL)
			if (ci->id >= tci->id)
				{
				fprintf(stderr, "failed %lx vs. %lx\n", ci->id, tci->id);
				return 0;
				}
		tci = ci;
		}
	fprintf(stderr, "ok\n");
#endif
#ifndef OPENSSL_NO_SSL3
	fprintf(stderr, "testing SSLv3 cipher list order: ");
	meth = SSLv3_method();
	tci = NULL;
	while ((ci = meth->get_cipher(i++)) != NULL)
		{
		if (tci != NULL)
			if (ci->id >= tci->id)
				{
				fprintf(stderr, "failed %lx vs. %lx\n", ci->id, tci->id);
				return 0;
				}
		tci = ci;
		}
	fprintf(stderr, "ok\n");
#endif
#ifndef OPENSSL_NO_TLS1
	fprintf(stderr, "testing TLSv1 cipher list order: ");
	meth = TLSv1_method();
	tci = NULL;
	while ((ci = meth->get_cipher(i++)) != NULL)
		{
		if (tci != NULL)
			if (ci->id >= tci->id)
				{
				fprintf(stderr, "failed %lx vs. %lx\n", ci->id, tci->id);
				return 0;
				}
		tci = ci;
		}
	fprintf(stderr, "ok\n");
#endif

	return 1;
	}
@


1.1.1.10
log
@import openssl-0.9.8j
@
text
@a231 3
#ifdef OPENSSL_FIPS
	fprintf(stderr,"-F             - run test in FIPS mode\n");
#endif
d413 1
a413 1
	int dhe1024 = 1, dhe1024dsa = 0;
a427 3
#ifdef OPENSSL_FIPS
	int fips_mode=0;
#endif
d459 1
a459 10
		if(!strcmp(*argv,"-F"))
			{
#ifdef OPENSSL_FIPS
			fips_mode=1;
#else
			fprintf(stderr,"not compiled with FIPS support, so exitting without running.\n");
			EXIT(0);
#endif
			}
		else if	(strcmp(*argv,"-server_auth") == 0)
a640 14
#ifdef OPENSSL_FIPS
	if(fips_mode)
		{
		if(!FIPS_mode_set(1))
			{
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
			EXIT(1);
			}
		else
			fprintf(stderr,"*** IN FIPS MODE ***\n");
		}
#endif

d2062 4
d2067 4
d2075 1
a2075 1
		if (ok > 0)
@


1.1.1.11
log
@import OpenSSL-1.0.0a
@
text
@a115 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
a130 1
#ifdef OPENSSL_SYS_VMS
a132 2
#endif

a209 10

static char *psk_key=NULL; /* by default PSK is not used */
#ifndef OPENSSL_NO_PSK
static unsigned int psk_client_callback(SSL *ssl, const char *hint, char *identity,
	unsigned int max_identity_len, unsigned char *psk,
	unsigned int max_psk_len);
static unsigned int psk_server_callback(SSL *ssl, const char *identity, unsigned char *psk,
	unsigned int max_psk_len);
#endif

d232 3
a252 3
#ifndef OPENSSL_NO_PSK
	fprintf(stderr," -psk arg      - PSK in hex (without 0x)\n");
#endif
d284 1
a284 1
	const SSL_CIPHER *ciph;
a388 19
#ifdef TLSEXT_TYPE_opaque_prf_input
struct cb_info_st { void *input; size_t len; int ret; };
struct cb_info_st co1 = { "C", 1, 1 }; /* try to negotiate oqaque PRF input */
struct cb_info_st co2 = { "C", 1, 2 }; /* insist on oqaque PRF input */
struct cb_info_st so1 = { "S", 1, 1 }; /* try to negotiate oqaque PRF input */
struct cb_info_st so2 = { "S", 1, 2 }; /* insist on oqaque PRF input */

int opaque_prf_input_cb(SSL *ssl, void *peerinput, size_t len, void *arg_)
	{
	struct cb_info_st *arg = arg_;

	if (arg == NULL)
		return 1;
	
	if (!SSL_set_tlsext_opaque_prf_input(ssl, arg->input, arg->len))
		return 0;
	return arg->ret;
	}
#endif
d410 1
a410 1
	const SSL_METHOD *meth=NULL;
d416 1
a416 1
	int dhe1024 = 0, dhe1024dsa = 0;
a422 1
	int no_psk = 0;
d431 3
d439 1
a439 1
	bio_err=BIO_new_fp(stderr,BIO_NOCLOSE|BIO_FP_TEXT);	
d458 1
a458 1
	bio_stdout=BIO_new_fp(stdout,BIO_NOCLOSE|BIO_FP_TEXT);
d465 10
a474 1
		if	(strcmp(*argv,"-server_auth") == 0)
a513 14
		else if (strcmp(*argv,"-psk") == 0)
			{
			if (--argc < 1) goto bad;
			psk_key=*(++argv);
#ifndef OPENSSL_NO_PSK
			if (strspn(psk_key, "abcdefABCDEF1234567890") != strlen(psk_key))
				{
				BIO_printf(bio_err,"Not a hex number '%s'\n",*argv);
				goto bad;
				}
#else
			no_psk=1;
#endif
			}
d656 14
a813 7
#ifdef TLSEXT_TYPE_opaque_prf_input
	SSL_CTX_set_tlsext_opaque_prf_input_callback(c_ctx, opaque_prf_input_cb);
	SSL_CTX_set_tlsext_opaque_prf_input_callback(s_ctx, opaque_prf_input_cb);
	SSL_CTX_set_tlsext_opaque_prf_input_callback_arg(c_ctx, &co1); /* or &co2 or NULL */
	SSL_CTX_set_tlsext_opaque_prf_input_callback_arg(s_ctx, &so1); /* or &so2 or NULL */
#endif

a864 25
	/* Use PSK only if PSK key is given */
	if (psk_key != NULL)
		{
		/* no_psk is used to avoid putting psk command to openssl tool */
		if (no_psk)
			{
			/* if PSK is not compiled in and psk key is
			 * given, do nothing and exit successfully */
			ret=0;
			goto end;
			}
#ifndef OPENSSL_NO_PSK
		SSL_CTX_set_psk_client_callback(c_ctx, psk_client_callback);
		SSL_CTX_set_psk_server_callback(s_ctx, psk_server_callback);
		if (debug)
			BIO_printf(bio_err,"setting PSK identity hint to s_ctx\n");
		if (!SSL_CTX_use_psk_identity_hint(s_ctx, "ctx server identity_hint"))
			{
			BIO_printf(bio_err,"error setting PSK identity hint to s_ctx\n");
			ERR_print_errors(bio_err);
			goto end;
			}
#endif
		}

d941 1
a941 1
	ERR_remove_thread_state(NULL);
a2090 4
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(1);
# endif
a2091 4
# ifdef OPENSSL_FIPS
	if(s->version == TLS1_VERSION)
		FIPS_allow_md5(0);
# endif
a2259 63
#ifndef OPENSSL_NO_PSK
/* convert the PSK key (psk_key) in ascii to binary (psk) */
static int psk_key2bn(const char *pskkey, unsigned char *psk,
	unsigned int max_psk_len)
	{
	int ret;
	BIGNUM *bn = NULL;

	ret = BN_hex2bn(&bn, pskkey);
	if (!ret)
		{
		BIO_printf(bio_err,"Could not convert PSK key '%s' to BIGNUM\n", pskkey); 
		if (bn)
			BN_free(bn);
		return 0;
		}
	if (BN_num_bytes(bn) > (int)max_psk_len)
		{
		BIO_printf(bio_err,"psk buffer of callback is too small (%d) for key (%d)\n",
			max_psk_len, BN_num_bytes(bn));
		BN_free(bn);
		return 0;
		}
	ret = BN_bn2bin(bn, psk);
	BN_free(bn);
	return ret;
	}

static unsigned int psk_client_callback(SSL *ssl, const char *hint, char *identity,
	unsigned int max_identity_len, unsigned char *psk,
	unsigned int max_psk_len)
	{
	int ret;
	unsigned int psk_len = 0;

	ret = BIO_snprintf(identity, max_identity_len, "Client_identity");
	if (ret < 0)
		goto out_err;
	if (debug)
		fprintf(stderr, "client: created identity '%s' len=%d\n", identity, ret);
	ret = psk_key2bn(psk_key, psk, max_psk_len);
	if (ret < 0)
		goto out_err;
	psk_len = ret;
out_err:
	return psk_len;
	}

static unsigned int psk_server_callback(SSL *ssl, const char *identity,
	unsigned char *psk, unsigned int max_psk_len)
	{
	unsigned int psk_len=0;

	if (strcmp(identity, "Client_identity") != 0)
		{
		BIO_printf(bio_err, "server: PSK error: client identity not found\n");
		return 0;
		}
	psk_len=psk_key2bn(psk_key, psk, max_psk_len);
	return psk_len;
	}
#endif

d2264 1
a2264 1
	const SSL_CIPHER *ci, *tci = NULL;
@


1.1.1.12
log
@import OpenSSL 1.0.0e
@
text
@d1433 1
d1468 2
@


1.1.1.13
log
@import OpenSSL-1.0.1c
@
text
@a183 3
#ifndef OPENSSL_NO_SRP
#include <openssl/srp.h>
#endif
a248 43
#ifndef OPENSSL_NO_SRP
/* SRP client */
/* This is a context that we pass to all callbacks */
typedef struct srp_client_arg_st
	{
	char *srppassin;
	char *srplogin;
	} SRP_CLIENT_ARG;

#define PWD_STRLEN 1024

static char * MS_CALLBACK ssl_give_srp_client_pwd_cb(SSL *s, void *arg)
	{
	SRP_CLIENT_ARG *srp_client_arg = (SRP_CLIENT_ARG *)arg;
	return BUF_strdup((char *)srp_client_arg->srppassin);
	}

/* SRP server */
/* This is a context that we pass to SRP server callbacks */
typedef struct srp_server_arg_st
	{
	char *expected_user;
	char *pass;
	} SRP_SERVER_ARG;

static int MS_CALLBACK ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
	{
	SRP_SERVER_ARG * p = (SRP_SERVER_ARG *) arg;

	if (strcmp(p->expected_user, SSL_get_srp_username(s)) != 0)
		{
		fprintf(stderr, "User %s doesn't exist\n", SSL_get_srp_username(s));
		return SSL3_AL_FATAL;
		}
	if (SSL_set_srp_server_param_pw(s,p->expected_user,p->pass,"1024")<0)
		{
		*ad = SSL_AD_INTERNAL_ERROR;
		return SSL3_AL_FATAL;
		}
	return SSL_ERROR_NONE;
	}
#endif

a270 3
#ifdef OPENSSL_FIPS
	fprintf(stderr,"-F             - run test in FIPS mode\n");
#endif
a291 4
#ifndef OPENSSL_NO_SRP
	fprintf(stderr," -srpuser user  - SRP username to use\n");
	fprintf(stderr," -srppass arg   - password for 'user'\n");
#endif
a478 6
#ifndef OPENSSL_NO_SRP
	/* client */
	SRP_CLIENT_ARG srp_client_arg = {NULL,NULL};
	/* server */
	SRP_SERVER_ARG srp_server_arg = {NULL,NULL};
#endif
a489 3
#ifdef OPENSSL_FIPS
	int fips_mode=0;
#endif
d521 1
a521 10
		if(!strcmp(*argv,"-F"))
			{
#ifdef OPENSSL_FIPS
			fips_mode=1;
#else
			fprintf(stderr,"not compiled with FIPS support, so exitting without running.\n");
			EXIT(0);
#endif
			}
		else if (strcmp(*argv,"-server_auth") == 0)
a574 14
#ifndef OPENSSL_NO_SRP
		else if (strcmp(*argv,"-srpuser") == 0)
			{
			if (--argc < 1) goto bad;
			srp_server_arg.expected_user = srp_client_arg.srplogin= *(++argv);
			tls1=1;
			}
		else if (strcmp(*argv,"-srppass") == 0)
			{
			if (--argc < 1) goto bad;
			srp_server_arg.pass = srp_client_arg.srppassin= *(++argv);
			tls1=1;
			}
#endif
a716 14
#ifdef OPENSSL_FIPS
	if(fips_mode)
		{
		if(!FIPS_mode_set(1))
			{
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
			EXIT(1);
			}
		else
			fprintf(stderr,"*** IN FIPS MODE ***\n");
		}
#endif

a839 3
#ifdef OPENSSL_NO_EC2M
			nid = NID_X9_62_prime256v1;
#else
a840 1
#endif
a942 20
#ifndef OPENSSL_NO_SRP
        if (srp_client_arg.srplogin)
		{
		if (!SSL_CTX_set_srp_username(c_ctx, srp_client_arg.srplogin))
			{
			BIO_printf(bio_err,"Unable to set SRP username\n");
			goto end;
			}
		SSL_CTX_set_srp_cb_arg(c_ctx,&srp_client_arg);
		SSL_CTX_set_srp_client_pwd_callback(c_ctx, ssl_give_srp_client_pwd_cb);
		/*SSL_CTX_set_srp_strength(c_ctx, srp_client_arg.strength);*/
		}

	if (srp_server_arg.expected_user != NULL)
		{
		SSL_CTX_set_verify(s_ctx,SSL_VERIFY_NONE,verify_callback);
		SSL_CTX_set_srp_cb_arg(s_ctx, &srp_server_arg);
		SSL_CTX_set_srp_username_callback(s_ctx, ssl_srp_server_param_cb);
		}
#endif
d2167 4
d2172 4
@


1.1.1.14
log
@Import OpenSSL 1.0.1g
@
text
@d546 1
a547 1
#endif
d884 1
a884 7
	if (tls1)
		meth=TLSv1_method();
	else
	if (ssl3)
		meth=SSLv3_method();
	else
		meth=SSLv23_method();
@


