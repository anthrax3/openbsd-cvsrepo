head	1.47;
access;
symbols
	OPENBSD_6_0:1.46.0.4
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.36.0.4
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	butholakala:1.14
	openssl_1_0_1_g:1.1.1.11
	OPENBSD_5_5:1.13.0.8
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.4
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	openssl_1_0_1_c:1.1.1.10
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.8
	openssl_1_0_0_f:1.1.1.9
	openssl_1_0_0_e:1.1.1.9
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	openssh_1_0_0_a:1.1.1.9
	OPENBSD_4_8:1.11.0.8
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	openssl_0_9_8_k:1.1.1.8
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	openssl_0_9_8_j:1.1.1.8
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2016.09.03.11.33.41;	author beck;	state dead;
branches;
next	1.46;
commitid	HnbXxsegngek41U2;

1.46
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.45;
commitid	pa8oXRlJthT375Ws;

1.45
date	2015.09.11.14.39.05;	author jsing;	state Exp;
branches;
next	1.44;
commitid	0zCo7JkeBYDebIHq;

1.44
date	2015.09.02.17.53.54;	author jsing;	state Exp;
branches;
next	1.43;
commitid	ZlXgyN4FHSnkiLL9;

1.43
date	2015.09.01.13.38.27;	author jsing;	state Exp;
branches;
next	1.42;
commitid	181x6cJx2ceVnn0a;

1.42
date	2015.08.29.17.15.52;	author doug;	state Exp;
branches;
next	1.41;
commitid	J5Q7EI1v6Se5pITr;

1.41
date	2015.08.27.06.21.15;	author doug;	state Exp;
branches;
next	1.40;
commitid	81GzeBdk0eOTcvRE;

1.40
date	2015.07.19.07.30.06;	author doug;	state Exp;
branches;
next	1.39;
commitid	N7VdpUQsePnBwxuL;

1.39
date	2015.07.19.06.31.32;	author doug;	state Exp;
branches;
next	1.38;
commitid	as8DOqEY9XBrHJyu;

1.38
date	2015.03.31.13.17.48;	author jsing;	state Exp;
branches;
next	1.37;
commitid	Gsu1fmdFKo5ZDsVm;

1.37
date	2015.03.27.12.29.54;	author jsing;	state Exp;
branches;
next	1.36;
commitid	GlMku1cNd3nfgnVW;

1.36
date	2015.02.06.08.30.23;	author jsing;	state Exp;
branches;
next	1.35;
commitid	K5MXFl39zEkHakNY;

1.35
date	2014.12.10.15.43.31;	author jsing;	state Exp;
branches;
next	1.34;
commitid	9GGF3DCNTm9Bs8E3;

1.34
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.33;
commitid	M3pvHgIFoWUHNqJn;

1.33
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.32;
commitid	cGE1JG2i0h4NcVDi;

1.32
date	2014.08.10.14.42.56;	author jsing;	state Exp;
branches;
next	1.31;
commitid	wihJupNvfkdpKL9O;

1.31
date	2014.07.11.08.17.36;	author miod;	state Exp;
branches;
next	1.30;
commitid	3cdQWc5wTDwlWJsQ;

1.30
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.29;
commitid	lsH7iukeZYSZBx6F;

1.29
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	mJUVYpkFBZ0Zv2bG;

1.28
date	2014.06.11.15.17.19;	author jsing;	state Exp;
branches;
next	1.27;
commitid	yLY4i8WW5UTUfvru;

1.27
date	2014.06.07.22.23.12;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	4IX3BI6FoxwuHgdS;

1.26
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2014.05.24.12.44.48;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.19.17.07.35;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.14.08.57;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.16.15.10.07;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.15.21.47.56;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.15.19.42.56;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.14.17.45.38;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.14.15.15.33;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.39;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.36;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.26;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.25;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.11;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.11;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.32;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.43.54;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.36;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.27;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.14.06;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: s23_clnt.c,v 1.46 2015/09/11 18:08:21 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/buffer.h>
#include <openssl/evp.h>
#include <openssl/objects.h>

static int ssl23_client_hello(SSL *s);
static int ssl23_get_server_hello(SSL *s);

int
ssl23_connect(SSL *s)
{
	void (*cb)(const SSL *ssl, int type, int val) = NULL;
	int ret = -1;
	int new_state, state;

	ERR_clear_error();
	errno = 0;

	if (s->info_callback != NULL)
		cb = s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb = s->ctx->info_callback;

	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s))
		SSL_clear(s);

	for (;;) {
		state = s->state;

		switch (s->state) {
		case SSL_ST_BEFORE:
		case SSL_ST_CONNECT:
		case SSL_ST_BEFORE|SSL_ST_CONNECT:
		case SSL_ST_OK|SSL_ST_CONNECT:

			if (s->session != NULL) {
				SSLerr(SSL_F_SSL23_CONNECT, SSL_R_SSL23_DOING_SESSION_ID_REUSE);
				ret = -1;
				goto end;
			}
			s->server = 0;
			if (cb != NULL)
				cb(s, SSL_CB_HANDSHAKE_START, 1);

			/* s->version=TLS1_VERSION; */
			s->type = SSL_ST_CONNECT;

			if (!ssl3_setup_init_buffer(s)) {
				ret = -1;
				goto end;
			}
			if (!ssl3_setup_buffers(s)) {
				ret = -1;
				goto end;
			}
			if (!tls1_init_finished_mac(s)) {
				ret = -1;
				goto end;
			}

			s->state = SSL23_ST_CW_CLNT_HELLO_A;
			s->ctx->stats.sess_connect++;
			s->init_num = 0;
			break;

		case SSL23_ST_CW_CLNT_HELLO_A:
		case SSL23_ST_CW_CLNT_HELLO_B:

			s->shutdown = 0;
			ret = ssl23_client_hello(s);
			if (ret <= 0)
				goto end;
			s->state = SSL23_ST_CR_SRVR_HELLO_A;
			s->init_num = 0;

			break;

		case SSL23_ST_CR_SRVR_HELLO_A:
		case SSL23_ST_CR_SRVR_HELLO_B:
			ret = ssl23_get_server_hello(s);
			if (ret >= 0)
				cb = NULL;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_SSL23_CONNECT, SSL_R_UNKNOWN_STATE);
			ret = -1;
			goto end;
			/* break; */
		}

		if (s->debug) {
			(void)BIO_flush(s->wbio);
		}

		if ((cb != NULL) && (s->state != state)) {
			new_state = s->state;
			s->state = state;
			cb(s, SSL_CB_CONNECT_LOOP, 1);
			s->state = new_state;
		}
	}

end:
	s->in_handshake--;
	if (cb != NULL)
		cb(s, SSL_CB_CONNECT_EXIT, ret);

	return (ret);
}

static int
ssl23_client_hello(SSL *s)
{
	unsigned char *buf;
	unsigned char *p, *d;
	int i;
	unsigned long l;
	int version = 0, version_major, version_minor;
	int ret;
	unsigned long mask, options = s->options;

	/*
	 * SSL_OP_NO_X disables all protocols above X *if* there are
	 * some protocols below X enabled. This is required in order
	 * to maintain "version capability" vector contiguous. So
	 * that if application wants to disable TLS1.0 in favour of
	 * TLS1>=1, it would be insufficient to pass SSL_NO_TLSv1, the
	 * answer is SSL_OP_NO_TLSv1|SSL_OP_NO_SSLv3|SSL_OP_NO_SSLv2.
	 */
	mask = SSL_OP_NO_TLSv1_1|SSL_OP_NO_TLSv1;
	version = TLS1_2_VERSION;

	if ((options & SSL_OP_NO_TLSv1_2) && (options & mask) != mask)
		version = TLS1_1_VERSION;
	mask &= ~SSL_OP_NO_TLSv1_1;
	if ((options & SSL_OP_NO_TLSv1_1) && (options & mask) != mask)
		version = TLS1_VERSION;
	mask &= ~SSL_OP_NO_TLSv1;

	buf = (unsigned char *)s->init_buf->data;
	if (s->state == SSL23_ST_CW_CLNT_HELLO_A) {
		arc4random_buf(s->s3->client_random, SSL3_RANDOM_SIZE);

		if (version == TLS1_2_VERSION) {
			version_major = TLS1_2_VERSION_MAJOR;
			version_minor = TLS1_2_VERSION_MINOR;
		} else if (version == TLS1_1_VERSION) {
			version_major = TLS1_1_VERSION_MAJOR;
			version_minor = TLS1_1_VERSION_MINOR;
		} else if (version == TLS1_VERSION) {
			version_major = TLS1_VERSION_MAJOR;
			version_minor = TLS1_VERSION_MINOR;
		} else {
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,
			    SSL_R_NO_PROTOCOLS_AVAILABLE);
			return (-1);
		}

		s->client_version = version;

		/* create Client Hello in SSL 3.0/TLS 1.0 format */

		/*
		 * Do the record header (5 bytes) and handshake
		 * message header (4 bytes) last
		 */
		d = p = &(buf[SSL3_RT_HEADER_LENGTH + SSL3_HM_HEADER_LENGTH]);

		*(p++) = version_major;
		*(p++) = version_minor;

		/* Random stuff */
		memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
		p += SSL3_RANDOM_SIZE;

		/* Session ID (zero since there is no reuse) */
		*(p++) = 0;

		/* Ciphers supported (using SSL 3.0/TLS 1.0 format) */
		i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &p[2]);
		if (i == 0) {
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,
			    SSL_R_NO_CIPHERS_AVAILABLE);
			return -1;
		}
		s2n(i, p);
		p += i;

		/* add in (no) COMPRESSION */
		*(p++) = 1;
		/* Add the NULL method */
		*(p++) = 0;

		/* TLS extensions*/
		if ((p = ssl_add_clienthello_tlsext(s, p,
		    buf + SSL3_RT_MAX_PLAIN_LENGTH)) == NULL) {
			SSLerr(SSL_F_SSL23_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
			return -1;
		}

		l = p - d;

		/* fill in 4-byte handshake header */
		d = &(buf[SSL3_RT_HEADER_LENGTH]);
		*(d++) = SSL3_MT_CLIENT_HELLO;
		l2n3(l, d);

		l += 4;

		if (l > SSL3_RT_MAX_PLAIN_LENGTH) {
			SSLerr(SSL_F_SSL23_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
			return -1;
		}

		/* fill in 5-byte record header */
		d = buf;
		*(d++) = SSL3_RT_HANDSHAKE;
		*(d++) = version_major;

		/*
		 * Some servers hang if we use long client hellos
		 * and a record number > TLS 1.0.
		 */
		if (TLS1_get_client_version(s) > TLS1_VERSION)
			*(d++) = 1;
		else
			*(d++) = version_minor;
		s2n((int)l, d);

		/* number of bytes to write */
		s->init_num = p - buf;
		s->init_off = 0;

		tls1_finish_mac(s, &(buf[SSL3_RT_HEADER_LENGTH]),
		    s->init_num - SSL3_RT_HEADER_LENGTH);

		s->state = SSL23_ST_CW_CLNT_HELLO_B;
		s->init_off = 0;
	}

	/* SSL3_ST_CW_CLNT_HELLO_B */
	ret = ssl23_write_bytes(s);

	if ((ret >= 2) && s->msg_callback) {
		/* Client Hello has been sent; tell msg_callback */

		s->msg_callback(1, version, SSL3_RT_HANDSHAKE,
		    s->init_buf->data + 5, ret - 5, s, s->msg_callback_arg);
	}

	return ret;
}

static int
ssl23_get_server_hello(SSL *s)
{
	char buf[8];
	unsigned char *p;
	int i;
	int n;

	n = ssl23_read_bytes(s, 7);

	if (n != 7)
		return (n);
	p = s->packet;

	memcpy(buf, p, n);

	/* Old unsupported sslv2 handshake */
	if ((p[0] & 0x80) && (p[2] == SSL2_MT_SERVER_HELLO) &&
	    (p[5] == 0x00) && (p[6] == 0x02)) {
		SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,
		    SSL_R_UNSUPPORTED_PROTOCOL);
		goto err;
	}

	if (p[1] == SSL3_VERSION_MAJOR &&
	    p[2] <= TLS1_2_VERSION_MINOR &&
	    ((p[0] == SSL3_RT_HANDSHAKE && p[5] == SSL3_MT_SERVER_HELLO) ||
	    (p[0] == SSL3_RT_ALERT && p[3] == 0 && p[4] == 2))) {
		/* we have sslv3 or tls1 (server hello or alert) */

		if ((p[2] == TLS1_VERSION_MINOR) &&
		    !(s->options & SSL_OP_NO_TLSv1)) {
			s->version = TLS1_VERSION;
			s->method = TLSv1_client_method();
		} else if ((p[2] == TLS1_1_VERSION_MINOR) &&
		    !(s->options & SSL_OP_NO_TLSv1_1)) {
			s->version = TLS1_1_VERSION;
			s->method = TLSv1_1_client_method();
		} else if ((p[2] == TLS1_2_VERSION_MINOR) &&
		    !(s->options & SSL_OP_NO_TLSv1_2)) {
			s->version = TLS1_2_VERSION;
			s->method = TLSv1_2_client_method();
		} else {
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,
			    SSL_R_UNSUPPORTED_PROTOCOL);
			goto err;
		}

		if (p[0] == SSL3_RT_ALERT && p[5] != SSL3_AL_WARNING) {
			/* fatal alert */
			void (*cb)(const SSL *ssl, int type, int val) = NULL;
			int j;

			if (s->info_callback != NULL)
				cb = s->info_callback;
			else if (s->ctx->info_callback != NULL)
				cb = s->ctx->info_callback;

			i = p[5];
			if (cb != NULL) {
				j = (i << 8) | p[6];
				cb(s, SSL_CB_READ_ALERT, j);
			}

			if (s->msg_callback)
				s->msg_callback(0, s->version, SSL3_RT_ALERT,
				    p + 5, 2, s, s->msg_callback_arg);

			s->rwstate = SSL_NOTHING;
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,
			    SSL_AD_REASON_OFFSET + p[6]);
			goto err;
		}

		if (!ssl_init_wbio_buffer(s, 1))
			goto err;

		/* we are in this state */
		s->state = SSL3_ST_CR_SRVR_HELLO_A;

		/* put the 7 bytes we have read into the input buffer
		 * for SSLv3 */
		s->rstate = SSL_ST_READ_HEADER;
		s->packet_length = n;
		if (s->s3->rbuf.buf == NULL)
			if (!ssl3_setup_read_buffer(s))
				goto err;
		s->packet = &(s->s3->rbuf.buf[0]);
		memcpy(s->packet, buf, n);
		s->s3->rbuf.left = n;
		s->s3->rbuf.offset = 0;

		s->handshake_func = s->method->ssl_connect;
	} else {
		SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, SSL_R_UNKNOWN_PROTOCOL);
		goto err;
	}
	s->init_num = 0;

	/*
	 * Since, if we are sending a ssl23 client hello, we are not
	 * reusing a session-id
	 */
	if (!ssl_get_new_session(s, 0))
		goto err;

	return (SSL_connect(s));
err:
	return (-1);
}
@


1.46
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.45 2015/09/11 14:39:05 jsing Exp $ */
@


1.45
log
@Put the *client_method* data structures and functions in the same place.
We can also now nuke ssl23_get_client_method() since it is the same as
tls1_get_client_method().

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.44 2015/09/02 17:53:54 jsing Exp $ */
d171 1
a171 1
			if (!ssl3_init_finished_mac(s)) {
d351 1
a351 1
		ssl3_finish_mac(s, &(buf[SSL3_RT_HEADER_LENGTH]),
@


1.44
log
@Fewer magic numbers - we already have defines for the header lengths, so
make use of them.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.43 2015/09/01 13:38:27 jsing Exp $ */
a119 1
static const SSL_METHOD *ssl23_get_client_method(int ver);
a122 50
const SSL_METHOD SSLv23_client_method_data = {
	.version = TLS1_2_VERSION,
	.ssl_new = tls1_new,
	.ssl_clear = tls1_clear,
	.ssl_free = tls1_free,
	.ssl_accept = ssl_undefined_function,
	.ssl_connect = ssl23_connect,
	.ssl_read = ssl23_read,
	.ssl_peek = ssl23_peek,
	.ssl_write = ssl23_write,
	.ssl_shutdown = ssl_undefined_function,
	.ssl_renegotiate = ssl_undefined_function,
	.ssl_renegotiate_check = ssl_ok,
	.ssl_get_message = ssl3_get_message,
	.ssl_read_bytes = ssl3_read_bytes,
	.ssl_write_bytes = ssl3_write_bytes,
	.ssl_dispatch_alert = ssl3_dispatch_alert,
	.ssl_ctrl = ssl3_ctrl,
	.ssl_ctx_ctrl = ssl3_ctx_ctrl,
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
	.ssl_pending = ssl_undefined_const_function,
	.num_ciphers = ssl3_num_ciphers,
	.get_cipher = ssl3_get_cipher,
	.get_ssl_method = ssl23_get_client_method,
	.get_timeout = ssl23_default_timeout,
	.ssl3_enc = &ssl3_undef_enc_method,
	.ssl_version = ssl_undefined_void_function,
	.ssl_callback_ctrl = ssl3_callback_ctrl,
	.ssl_ctx_callback_ctrl = ssl3_ctx_callback_ctrl,
};

const SSL_METHOD *
SSLv23_client_method(void)
{
	return &SSLv23_client_method_data;
}

static const SSL_METHOD *
ssl23_get_client_method(int ver)
{
	if (ver == TLS1_VERSION)
		return (TLSv1_client_method());
	if (ver == TLS1_1_VERSION)
		return (TLSv1_1_client_method());
	if (ver == TLS1_2_VERSION)
		return (TLSv1_2_client_method());
	return (NULL);
}

a479 6
}

const SSL_METHOD *
TLS_client_method(void)
{
	return &SSLv23_client_method_data;
@


1.43
log
@Remove the ssl_prepare_{client,server}hello_tlsext() functions, which are
now nothing more than noops.

ok bcook@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.42 2015/08/29 17:15:52 doug Exp $ */
d322 2
a323 1
			SSLerr(SSL_F_SSL23_CLIENT_HELLO, SSL_R_NO_PROTOCOLS_AVAILABLE);
d335 1
a335 1
		d = p = &(buf[9]);
d372 1
a372 1
		d = &(buf[5]);
d402 2
a403 1
		ssl3_finish_mac(s, &(buf[5]), s->init_num - 5);
@


1.42
log
@Now that SSLv3 is going away, TLS_* and SSLv23 are equivalent.

Remove the TLS method data and tls_any_* functions.  Point to SSLv23.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.41 2015/08/27 06:21:15 doug Exp $ */
a361 5
		if (ssl_prepare_clienthello_tlsext(s) <= 0) {
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,
			    SSL_R_CLIENTHELLO_TLSEXT);
			return -1;
		}
@


1.41
log
@Remove SSLv3 support from LibreSSL.

This is the first wave of SSLv3 removal which removes the main SSLv3
functions.  Future commits will remove the rest of the SSLv3 support.

Discussed the plan at c2k15.  Input from jsing@@, beck@@, miod@@, bcook@@,
sthen@@, naddy@@, and deraadt@@.

ok jsing@@, beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.40 2015/07/19 07:30:06 doug Exp $ */
a122 1
static const SSL_METHOD *tls_any_get_client_method(int ver);
a155 33
const SSL_METHOD TLS_client_method_data = {
	.version = TLS1_2_VERSION,
	.ssl_new = tls1_new,
	.ssl_clear = tls1_clear,
	.ssl_free = tls1_free,
	.ssl_accept = ssl_undefined_function,
	.ssl_connect = tls_any_connect,
	.ssl_read = ssl23_read,
	.ssl_peek = ssl23_peek,
	.ssl_write = ssl23_write,
	.ssl_shutdown = ssl_undefined_function,
	.ssl_renegotiate = ssl_undefined_function,
	.ssl_renegotiate_check = ssl_ok,
	.ssl_get_message = ssl3_get_message,
	.ssl_read_bytes = ssl3_read_bytes,
	.ssl_write_bytes = ssl3_write_bytes,
	.ssl_dispatch_alert = ssl3_dispatch_alert,
	.ssl_ctrl = ssl3_ctrl,
	.ssl_ctx_ctrl = ssl3_ctx_ctrl,
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
	.ssl_pending = ssl_undefined_const_function,
	.num_ciphers = ssl3_num_ciphers,
	.get_cipher = ssl3_get_cipher,
	.get_ssl_method = tls_any_get_client_method,
	.get_timeout = ssl23_default_timeout,
	.ssl3_enc = &ssl3_undef_enc_method,
	.ssl_version = ssl_undefined_void_function,
	.ssl_callback_ctrl = ssl3_callback_ctrl,
	.ssl_ctx_callback_ctrl = ssl3_ctx_callback_ctrl,
};


d539 1
a539 25
	return &TLS_client_method_data;
}

static const SSL_METHOD *
tls_any_get_client_method(int ver)
{
	if (ver == SSL3_VERSION)
		return (NULL);
	else
		return ssl23_get_client_method(ver);
}

int
tls_any_connect(SSL *s)
{
	int ret;
	unsigned long old_options;

	old_options = s->options;

	s->options |= SSL_OP_NO_SSLv3;
	ret = ssl23_connect(s);
	s->options = old_options;

	return ret;
@


1.40
log
@Fix symbol collision with libtls.

Pointed out by guenther.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.39 2015/07/19 06:31:32 doug Exp $ */
a198 2
	if (ver == SSL3_VERSION)
		return (SSLv3_client_method());
d332 1
a332 1
	mask = SSL_OP_NO_TLSv1_1|SSL_OP_NO_TLSv1|SSL_OP_NO_SSLv3;
a340 3
	if ((options & SSL_OP_NO_TLSv1) && (options & mask) != mask)
		version = SSL3_VERSION;
	mask &= ~SSL_OP_NO_SSLv3;
a354 3
		} else if (version == SSL3_VERSION) {
			version_major = SSL3_VERSION_MAJOR;
			version_minor = SSL3_VERSION_MINOR;
d489 1
a489 5
		if ((p[2] == SSL3_VERSION_MINOR) &&
		    !(s->options & SSL_OP_NO_SSLv3)) {
			s->version = SSL3_VERSION;
			s->method = SSLv3_client_method();
		} else if ((p[2] == TLS1_VERSION_MINOR) &&
@


1.39
log
@Add TLS_method, TLS_client_method and TLS_server_method.

Use these instead of SSLv23_*method when you want to make sure TLS is
used.

By default, we disable SSLv3 but it's still possible for the user to
re-enable it.  TLS_*method does not allow SSLv3.

Both BoringSSL and (next version of) OpenSSL have these methods.
However, they have changed the implementation significantly.  We will
as well, but not right now.

Riding the libssl major bump.

ok miod@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.38 2015/03/31 13:17:48 jsing Exp $ */
d123 1
a123 1
static const SSL_METHOD *tls_get_client_method(int ver);
d163 1
a163 1
	.ssl_connect = tls_connect,
d181 1
a181 1
	.get_ssl_method = tls_get_client_method,
d589 1
a589 1
tls_get_client_method(int ver)
d598 1
a598 1
tls_connect(SSL *s)
@


1.38
log
@Nuke the OPENSSL_MAX_TLS1_2_CIPHER_LENGTH hack - this has to be enabled at
compile time, which we do not do and are unlikely to ever do. Additionally,
there are two runtime configurable alternatives that exist.

ok bcook@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.37 2015/03/27 12:29:54 jsing Exp $ */
d123 1
d157 33
d580 30
@


1.37
log
@Factor out the init_buf initialisation code, rather than duplicating it
in four different places.

ok doug@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.36 2015/02/06 08:30:23 jsing Exp $ */
a360 10
#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
		/*
		 * Some servers hang if client hello > 256 bytes
		 * as hack workaround chop number of supported ciphers
		 * to keep it well below this if we use TLS v1.2
		 */
		if (TLS1_get_version(s) >= TLS1_2_VERSION &&
		    i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
			i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
#endif
@


1.36
log
@Bring back the horrible API that is get_cipher_by_char/put_cipher_by_char.

This API was intended to be an internal only, however like many things in
OpenSSL, it is exposed externally and parts of the software ecosystem are
now using it since there is no real alternative within the public API.

ok doug@@, tedu@@ and reluctantly miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.35 2014/12/10 15:43:31 jsing Exp $ */
a178 1
	BUF_MEM *buf = NULL;
d216 3
a218 11
			if (s->init_buf == NULL) {
				if ((buf = BUF_MEM_new()) == NULL) {
					ret = -1;
					goto end;
				}
				if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {
					ret = -1;
					goto end;
				}
				s->init_buf = buf;
				buf = NULL;
a219 1

a223 1

d272 1
a274 2
	if (buf != NULL)
		BUF_MEM_free(buf);
d277 1
@


1.35
log
@ssl3_init_finished_mac() calls BIO_new() which can fail since it in turn
calls malloc(). Instead of silently continuing on failure, check the return
value of BIO_new() and propagate failure back to the caller for appropriate
handling.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.34 2014/11/16 14:12:47 jsing Exp $ */
d143 2
@


1.34
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.33 2014/10/18 16:13:16 jsing Exp $ */
d233 4
a236 1
			ssl3_init_finished_mac(s);
@


1.33
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.32 2014/08/10 14:42:56 jsing Exp $ */
d113 1
d115 1
d117 1
a118 1
#include <openssl/evp.h>
@


1.32
log
@Since we no longer need to support SSLv2-style cipher lists, start
unravelling the maze of function pointers and callbacks by directly
calling ssl3_{get,put}_cipher_by_char() and removing the
ssl_{get,put}_cipher_by_char macros.

Prompted by similar changes in boringssl.

ok guenther.
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.31 2014/07/11 08:17:36 miod Exp $ */
a114 1
#include <openssl/rand.h>
d319 1
a319 2
		p = s->s3->client_random;
		RAND_pseudo_bytes(p, SSL3_RANDOM_SIZE);
@


1.31
log
@No need to keep ssl23_foo() flavours mapping to ssl3_foo().
ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.30 2014/07/10 08:51:14 tedu Exp $ */
a141 2
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl23_put_cipher_by_char,
d361 1
a361 2
		i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]),
		    ssl3_put_cipher_by_char);
@


1.30
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: s23_clnt.c,v 1.29 2014/06/12 15:49:31 deraadt Exp $ */
d142 1
a142 1
	.get_cipher_by_char = ssl23_get_cipher_by_char,
d145 2
a146 2
	.num_ciphers = ssl23_num_ciphers,
	.get_cipher = ssl23_get_cipher,
@


1.29
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a295 4
#ifndef OPENSSL_NO_COMP
	int j;
	SSL_COMP *comp;
#endif
d383 1
a383 2
		/* COMPRESSION */
#ifdef OPENSSL_NO_COMP
a384 12
#else
		if ((s->options & SSL_OP_NO_COMPRESSION) ||
		    !s->ctx->comp_methods)
			j = 0;
		else
			j = sk_SSL_COMP_num(s->ctx->comp_methods);
		*(p++) = 1 + j;
		for (i = 0; i < j; i++) {
			comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);
			*(p++) = comp->id;
		}
#endif
@


1.28
log
@Disable TLS support...

Just kidding!

unifdef OPENSSL_NO_TLS since we will never want to actually do that.

ok deraadt@@
@
text
@d1 1
a1 1
/* ssl/s23_clnt.c */
@


1.27
log
@http://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2016265dfbab162ec30718b5e7480add42598158
Don't know the full story, but it looks like a "can't do random
perfectly, so do it god awful" problem was found in 2013, and
replaced with "only do it badly if a flag is set".  New flags
(SSL_MODE_SEND_SERVERHELLO_TIME and SSL_MODE_SEND_SERVERHELLO_TIME)
were added [Ben Laurie?] to support the old scheme of "use time_t
for first 4 bytes of the random buffer".

Nothing uses these flags [ecosystem scan by sthen]

Fully discourage use of these flags in the future by removing
support & definition of them.  The buflen < 4 check is also interesting,
because no entropy would be returned.  No callers passed such small
buffers.
ok miod sthen
@
text
@a311 1
#if !defined(OPENSSL_NO_TLS1_2_CLIENT)
a315 3
#else
	version = TLS1_1_VERSION;
#endif
@


1.26
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@a287 24
/*
 * Fill a ClientRandom or ServerRandom field of length len. Returns <= 0
 * on failure, 1 on success.
 */
int
ssl_fill_hello_random(SSL *s, int server, unsigned char *result, int len)
{
	int send_time = 0;

	if (len < 4)
		return 0;
	if (server)
		send_time = (s->mode & SSL_MODE_SEND_SERVERHELLO_TIME) != 0;
	else
		send_time = (s->mode & SSL_MODE_SEND_CLIENTHELLO_TIME) != 0;
	if (send_time) {
		unsigned long Time = (unsigned long)time(NULL);
		unsigned char *p = result;
		l2n(Time, p);
		return RAND_pseudo_bytes(p, len - 4);
	} else
		return RAND_pseudo_bytes(result, len);
}

d331 1
a331 2
		if (ssl_fill_hello_random(s, 0, p, SSL3_RANDOM_SIZE) <= 0)
			return -1;
@


1.25
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@a433 1
#ifndef OPENSSL_NO_TLSEXT
a444 1
#endif
@


1.24
log
@DeIMPLEMENT libssl. Expand the IMPLEMENT_* macros since it is far more
readable and one less layer of abstraction. Use C99 initialisers for
clarity, grepability and to protect from future field reordering/removal.

ok miod@@ (tedu@@ also thought it was a wonderful idea, beck@@ also agreed,
but ran away squealing since it reminded him of the VOP layer...)
@
text
@a353 7
#if 0
		/* don't reuse session-id's */
		if (!ssl_get_new_session(s, 0)) {
			return (-1);
		}
#endif

@


1.23
log
@More KNF.
@
text
@d122 39
a173 3

IMPLEMENT_ssl23_meth_func(SSLv23_client_method,
    ssl_undefined_function, ssl23_connect, ssl23_get_client_method)
@


1.22
log
@More KNF and style consistency tweaks
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
@


1.21
log
@remove some code that is now unused after guenther's changes in 1.20.
@
text
@d122 2
a123 2
static const SSL_METHOD
*ssl23_get_client_method(int ver)
d127 1
a127 1
	else if (ver == TLS1_VERSION)
d129 1
a129 1
	else if (ver == TLS1_1_VERSION)
d131 1
a131 1
	else if (ver == TLS1_2_VERSION)
d133 1
a133 2
	else
		return (NULL);
@


1.20
log
@Kill the bogus "send an SSLv3/TLS hello in SSLv2 format" crap from
the SSLv23_* client code.  The server continues to accept it.  It
also kills the bits for SSL2 SESSIONs; even when the server gets
an SSLv2-style compat handshake, the session that it creates has
the correct version internally.

ok tedu@@ beck@@
@
text
@a252 15
static int
ssl23_no_ssl2_ciphers(SSL *s)
{
	SSL_CIPHER *cipher;
	STACK_OF(SSL_CIPHER) *ciphers;
	int i;
	ciphers = SSL_get_ciphers(s);
	for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {
		cipher = sk_SSL_CIPHER_value(ciphers, i);
		if (cipher->algorithm_ssl == SSL_SSLV2)
			return 0;
	}
	return 1;
}

d282 1
a282 1
	int i, ch_len;
@


1.19
log
@remove ssl2 support even more completely.
in the process, always include ssl3 and tls1, we don't need config options
for them. when the time comes to expire ssl3, it will be with an ax.
checked by miod
@
text
@d268 4
a271 2
/* Fill a ClientRandom or ServerRandom field of length len. Returns <= 0
 * on failure, 1 on success. */
a298 1
	int ssl2_compat;
a306 5
	ssl2_compat = (options & SSL_OP_NO_SSLv2) ? 0 : 1;

	if (ssl2_compat && ssl23_no_ssl2_ciphers(s))
		ssl2_compat = 0;

a331 15
#ifndef OPENSSL_NO_TLSEXT
	if (version != SSL2_VERSION) {
		/* have to disable SSL 2.0 compatibility if we need TLS extensions */

		if (s->tlsext_hostname != NULL)
			ssl2_compat = 0;
		if (s->tlsext_status_type != -1)
			ssl2_compat = 0;
#ifdef TLSEXT_TYPE_opaque_prf_input
		if (s->ctx->tlsext_opaque_prf_input_callback != 0 || s->tlsext_opaque_prf_input != NULL)
			ssl2_compat = 0;
#endif
	}
#endif

a356 3
		} else if (version == SSL2_VERSION) {
			version_major = SSL2_VERSION_MAJOR;
			version_minor = SSL2_VERSION_MINOR;
d364 1
a364 2
		if (ssl2_compat) {
			/* create SSL 2.0 compatible Client Hello */
d366 24
a389 77
			/* two byte record header will be written last */
			d = &(buf[2]);
			p = d + 9; /* leave space for message type, version, individual length fields */

			*(d++) = SSL2_MT_CLIENT_HELLO;
			*(d++) = version_major;
			*(d++) = version_minor;

			/* Ciphers supported */
			i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), p, 0);
			if (i == 0) {
				/* no ciphers */
				SSLerr(SSL_F_SSL23_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
				return -1;
			}
			s2n(i, d);
			p += i;

			/* put in the session-id length (zero since there is no reuse) */
#if 0
			s->session->session_id_length = 0;
#endif
			s2n(0, d);

			if (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)
				ch_len = SSL2_CHALLENGE_LENGTH;
			else
				ch_len = SSL2_MAX_CHALLENGE_LENGTH;

			/* write out sslv2 challenge */
			/* Note that ch_len must be <= SSL3_RANDOM_SIZE (32),
			   because it is one of SSL2_MAX_CHALLENGE_LENGTH (32)
			   or SSL2_MAX_CHALLENGE_LENGTH (16), but leave the
			   check in for futurproofing */
			if (SSL3_RANDOM_SIZE < ch_len)
				i = SSL3_RANDOM_SIZE;
			else
				i = ch_len;
			s2n(i, d);
			memset(&(s->s3->client_random[0]), 0, SSL3_RANDOM_SIZE);
			if (RAND_pseudo_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE - i]), i) <= 0)
				return -1;

			memcpy(p, &(s->s3->client_random[SSL3_RANDOM_SIZE - i]), i);
			p += i;

			i = p- &(buf[2]);
			buf[0] = ((i >> 8)&0xff)|0x80;
			buf[1] = (i&0xff);

			/* number of bytes to write */
			s->init_num = i + 2;
			s->init_off = 0;

			ssl3_finish_mac(s, &(buf[2]), i);
		} else {
			/* create Client Hello in SSL 3.0/TLS 1.0 format */

			/* do the record header (5 bytes) and handshake message header (4 bytes) last */
			d = p = &(buf[9]);

			*(p++) = version_major;
			*(p++) = version_minor;

			/* Random stuff */
			memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
			p += SSL3_RANDOM_SIZE;

			/* Session ID (zero since there is no reuse) */
			*(p++) = 0;

			/* Ciphers supported (using SSL 3.0/TLS 1.0 format) */
			i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), ssl3_put_cipher_by_char);
			if (i == 0) {
				SSLerr(SSL_F_SSL23_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
				return -1;
			}
d391 8
a398 7
			/* Some servers hang if client hello > 256 bytes
			 * as hack workaround chop number of supported ciphers
			 * to keep it well below this if we use TLS v1.2
			 */
			if (TLS1_get_version(s) >= TLS1_2_VERSION &&
			    i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
				i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
d400 2
a401 2
			s2n(i, p);
			p += i;
d403 1
a403 1
			/* COMPRESSION */
d405 1
a405 1
			*(p++) = 1;
d407 10
a416 10
			if ((s->options & SSL_OP_NO_COMPRESSION) ||
			    !s->ctx->comp_methods)
				j = 0;
			else
				j = sk_SSL_COMP_num(s->ctx->comp_methods);
			*(p++) = 1 + j;
			for (i = 0; i < j; i++) {
				comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);
				*(p++) = comp->id;
			}
d418 2
a419 1
			*(p++)=0; /* Add the NULL method */
d422 11
a432 9
			/* TLS extensions*/
			if (ssl_prepare_clienthello_tlsext(s) <= 0) {
				SSLerr(SSL_F_SSL23_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
				return -1;
			}
			if ((p = ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH)) == NULL) {
				SSLerr(SSL_F_SSL23_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
				return -1;
			}
d435 1
a435 1
			l = p - d;
d437 4
a440 11
			/* fill in 4-byte handshake header */
			d = &(buf[5]);
			*(d++) = SSL3_MT_CLIENT_HELLO;
			l2n3(l, d);

			l += 4;

			if (l > SSL3_RT_MAX_PLAIN_LENGTH) {
				SSLerr(SSL_F_SSL23_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
				return -1;
			}
d442 1
a442 16
			/* fill in 5-byte record header */
			d = buf;
			*(d++) = SSL3_RT_HANDSHAKE;
			*(d++) = version_major;
			/* Some servers hang if we use long client hellos
			 * and a record number > TLS 1.0.
			 */
			if (TLS1_get_client_version(s) > TLS1_VERSION)
				*(d++) = 1;
			else
				*(d++) = version_minor;
			s2n((int)l, d);

			/* number of bytes to write */
			s->init_num = p - buf;
			s->init_off = 0;
d444 3
a446 1
			ssl3_finish_mac(s, &(buf[5]), s->init_num - 5);
d449 21
d480 2
a481 4
		if (ssl2_compat)
			s->msg_callback(1, SSL2_VERSION, 0, s->init_buf->data + 2, ret - 2, s, s->msg_callback_arg);
		else
			s->msg_callback(1, version, SSL3_RT_HANDSHAKE, s->init_buf->data + 5, ret - 5, s, s->msg_callback_arg);
d503 1
d505 3
a507 2
		(p[5] == 0x00) && (p[6] == 0x02)) {
		SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);
d509 3
a511 1
	} else if (p[1] == SSL3_VERSION_MAJOR &&
d534 2
a535 1
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);
a540 1

d556 2
a557 1
				s->msg_callback(0, s->version, SSL3_RT_ALERT, p + 5, 2, s, s->msg_callback_arg);
d560 2
a561 1
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, SSL_AD_REASON_OFFSET + p[6]);
d590 4
a593 2
	/* Since, if we are sending a ssl23 client hello, we are not
	 * reusing a session-id */
@


1.18
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok miod
@
text
@a124 4
#ifndef OPENSSL_NO_SSL2
	if (ver == SSL2_VERSION)
		return (SSLv2_client_method());
#endif
d319 1
a319 8
	mask = SSL_OP_NO_TLSv1_1|SSL_OP_NO_TLSv1
#if !defined(OPENSSL_NO_SSL3)
	|SSL_OP_NO_SSLv3
#endif
#if !defined(OPENSSL_NO_SSL2)
	|(ssl2_compat ? SSL_OP_NO_SSLv2 : 0)
#endif
	;
a331 1
#if !defined(OPENSSL_NO_SSL3)
a334 5
#endif
#if !defined(OPENSSL_NO_SSL2)
	if ((options & SSL_OP_NO_SSLv3) && (options & mask) != mask)
		version = SSL2_VERSION;
#endif
a577 1
#ifdef OPENSSL_NO_SSL2
a579 60
#else
		/* we are talking sslv2 */
		/* we need to clean up the SSLv3 setup and put in the
		 * sslv2 stuff. */
		int ch_len;

		if (s->options & SSL_OP_NO_SSLv2) {
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);
			goto err;
		}
		if (s->s2 == NULL) {
			if (!ssl2_new(s))
				goto err;
		} else
			ssl2_clear(s);

		if (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)
			ch_len = SSL2_CHALLENGE_LENGTH;
		else
			ch_len = SSL2_MAX_CHALLENGE_LENGTH;

		/* write out sslv2 challenge */
		/* Note that ch_len must be <= SSL3_RANDOM_SIZE (32), because
		   it is one of SSL2_MAX_CHALLENGE_LENGTH (32) or
		   SSL2_MAX_CHALLENGE_LENGTH (16), but leave the check in for
		   futurproofing */
		i = (SSL3_RANDOM_SIZE < ch_len) ? SSL3_RANDOM_SIZE : ch_len;
		s->s2->challenge_length = i;
		memcpy(s->s2->challenge,
		    &(s->s3->client_random[SSL3_RANDOM_SIZE - i]), i);

		if (s->s3 != NULL)
			ssl3_free(s);

		if (!BUF_MEM_grow_clean(s->init_buf,
		    SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)) {
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, ERR_R_BUF_LIB);
			goto err;
		}

		s->state = SSL2_ST_GET_SERVER_HELLO_A;
		if (!(s->client_version == SSL2_VERSION))
			/* use special padding (SSL 3.0 draft/RFC 2246, App. E.2) */
			s->s2->ssl2_rollback = 1;

		/* setup the 7 bytes we have read so we get them from
		 * the sslv2 buffer */
		s->rstate = SSL_ST_READ_HEADER;
		s->packet_length = n;
		s->packet = &(s->s2->rbuf[0]);
		memcpy(s->packet, buf, n);
		s->s2->rbuf_left = n;
		s->s2->rbuf_offs = 0;

		/* we have already written one */
		s->s2->write_sequence = 1;

		s->method = SSLv2_client_method();
		s->handshake_func = s->method->ssl_connect;
#endif
@


1.17
log
@So the OpenSSL codebase does "get the time, add it as a random seed"
in a bunch of places inside the TLS engine, to try to keep entropy high.
I wonder if their moto is "If you can't solve a problem, at least try
to do it badly".
ok miod
@
text
@d390 1
a390 9
		}
#ifdef OPENSSL_FIPS
		else if (FIPS_mode()) {
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,
			SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
			return -1;
		}
#endif
		else if (version == SSL3_VERSION) {
a665 7
#ifdef OPENSSL_FIPS
			if (FIPS_mode()) {
				SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,
				SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
				goto err;
			}
#endif
@


1.16
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a147 1
	unsigned long Time = (unsigned long)time(NULL);
a151 1
	RAND_add(&Time, sizeof(Time), 0);
@


1.15
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@d122 3
a124 2
static const SSL_METHOD *ssl23_get_client_method(int ver)
	{
d127 1
a127 1
		return(SSLv2_client_method());
d130 1
a130 1
		return(SSLv3_client_method());
d132 1
a132 1
		return(TLSv1_client_method());
d134 1
a134 1
		return(TLSv1_1_client_method());
d136 1
a136 1
		return(TLSv1_2_client_method());
d138 2
a139 2
		return(NULL);
	}
d142 10
a151 11
			ssl_undefined_function,
			ssl23_connect,
			ssl23_get_client_method)

int ssl23_connect(SSL *s)
	{
	BUF_MEM *buf=NULL;
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state;
d153 1
a153 1
	RAND_add(&Time,sizeof(Time),0);
d158 1
a158 1
		cb=s->info_callback;
d160 2
a161 2
		cb=s->ctx->info_callback;
	
d163 2
a164 1
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 
d166 2
a167 3
	for (;;)
		{
		state=s->state;
d169 1
a169 2
		switch(s->state)
			{
d175 3
a177 4
			if (s->session != NULL)
				{
				SSLerr(SSL_F_SSL23_CONNECT,SSL_R_SSL23_DOING_SESSION_ID_REUSE);
				ret= -1;
d179 4
a182 3
				}
			s->server=0;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
d185 1
a185 1
			s->type=SSL_ST_CONNECT;
d187 3
a189 5
			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
d191 3
a193 4
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
a194 3
					}
				s->init_buf=buf;
				buf=NULL;
d196 3
d200 4
a203 1
			if (!ssl3_setup_buffers(s)) { ret= -1; goto end; }
d207 1
a207 1
			s->state=SSL23_ST_CW_CLNT_HELLO_A;
d209 1
a209 1
			s->init_num=0;
d215 6
a220 5
			s->shutdown=0;
			ret=ssl23_client_hello(s);
			if (ret <= 0) goto end;
			s->state=SSL23_ST_CR_SRVR_HELLO_A;
			s->init_num=0;
d226 3
a228 2
			ret=ssl23_get_server_hello(s);
			if (ret >= 0) cb=NULL;
d233 2
a234 2
			SSLerr(SSL_F_SSL23_CONNECT,SSL_R_UNKNOWN_STATE);
			ret= -1;
d237 1
a237 1
			}
d239 3
a241 1
		if (s->debug) { (void)BIO_flush(s->wbio); }
d243 5
a247 7
		if ((cb != NULL) && (s->state != state))
			{
			new_state=s->state;
			s->state=state;
			cb(s,SSL_CB_CONNECT_LOOP,1);
			s->state=new_state;
			}
d249 1
d255 7
a261 6
		cb(s,SSL_CB_CONNECT_EXIT,ret);
	return(ret);
	}

static int ssl23_no_ssl2_ciphers(SSL *s)
	{
d266 1
a266 2
	for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++)
		{
d270 1
a270 1
		}
d272 1
a272 1
	}
d276 3
a278 2
int ssl_fill_hello_random(SSL *s, int server, unsigned char *result, int len)
	{
d287 1
a287 2
	if (send_time)
		{
d291 2
a292 3
		return RAND_pseudo_bytes(p, len-4);
		}
	else
d294 1
a294 1
	}
d296 3
a298 2
static int ssl23_client_hello(SSL *s)
	{
d300 2
a301 2
	unsigned char *p,*d;
	int i,ch_len;
d325 1
a325 1
	mask =	SSL_OP_NO_TLSv1_1|SSL_OP_NO_TLSv1
d327 1
a327 1
		|SSL_OP_NO_SSLv3
d330 1
a330 1
		|(ssl2_compat?SSL_OP_NO_SSLv2:0)
d332 1
a332 1
		;
d356 1
a356 2
	if (version != SSL2_VERSION)
		{
d367 1
a367 1
		}
d370 2
a371 3
	buf=(unsigned char *)s->init_buf->data;
	if (s->state == SSL23_ST_CW_CLNT_HELLO_A)
		{
d374 3
a376 4
		if (!ssl_get_new_session(s,0))
			{
			return(-1);
			}
d379 1
a379 1
		p=s->s3->client_random;
d383 1
a383 2
		if (version == TLS1_2_VERSION)
			{
d386 1
a386 3
			}
		else if (version == TLS1_1_VERSION)
			{
d389 1
a389 3
			}
		else if (version == TLS1_VERSION)
			{
d392 1
a392 1
			}
d394 1
a394 2
		else if(FIPS_mode())
			{
d396 1
a396 1
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
d398 1
a398 1
			}
d400 1
a400 2
		else if (version == SSL3_VERSION)
			{
d403 1
a403 3
			}
		else if (version == SSL2_VERSION)
			{
d406 4
a409 6
			}
		else
			{
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_PROTOCOLS_AVAILABLE);
			return(-1);
			}
d413 1
a413 2
		if (ssl2_compat)
			{
d423 1
a423 1
			
d425 2
a426 3
			i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),p,0);
			if (i == 0)
				{
d428 1
a428 1
				SSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);
d430 4
a433 4
				}
			s2n(i,d);
			p+=i;
			
d436 1
a436 1
			s->session->session_id_length=0;
d438 1
a438 1
			s2n(0,d);
d441 1
a441 1
				ch_len=SSL2_CHALLENGE_LENGTH;
d443 1
a443 1
				ch_len=SSL2_MAX_CHALLENGE_LENGTH;
d451 1
a451 1
				i=SSL3_RANDOM_SIZE;
d453 4
a456 4
				i=ch_len;
			s2n(i,d);
			memset(&(s->s3->client_random[0]),0,SSL3_RANDOM_SIZE);
			if (RAND_pseudo_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i) <= 0)
d459 2
a460 2
			memcpy(p,&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);
			p+=i;
d462 3
a464 3
			i= p- &(buf[2]);
			buf[0]=((i>>8)&0xff)|0x80;
			buf[1]=(i&0xff);
d467 2
a468 2
			s->init_num=i+2;
			s->init_off=0;
d470 2
a471 4
			ssl3_finish_mac(s,&(buf[2]),i);
			}
		else
			{
d476 1
a476 1
			
d488 3
a490 4
			i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),ssl3_put_cipher_by_char);
			if (i == 0)
				{
				SSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);
d492 1
a492 1
				}
d498 2
a499 2
			if (TLS1_get_version(s) >= TLS1_2_VERSION
				&& i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
d502 2
a503 2
			s2n(i,p);
			p+=i;
d507 1
a507 1
			*(p++)=1;
d509 3
a511 3
			if ((s->options & SSL_OP_NO_COMPRESSION)
						|| !s->ctx->comp_methods)
				j=0;
d513 6
a518 7
				j=sk_SSL_COMP_num(s->ctx->comp_methods);
			*(p++)=1+j;
			for (i=0; i<j; i++)
				{
				comp=sk_SSL_COMP_value(s->ctx->comp_methods,i);
				*(p++)=comp->id;
				}
d524 2
a525 3
			if (ssl_prepare_clienthello_tlsext(s) <= 0)
				{
				SSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_CLIENTHELLO_TLSEXT);
d527 3
a529 4
				}
			if ((p = ssl_add_clienthello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
				{
				SSLerr(SSL_F_SSL23_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);
d531 1
a531 1
				}
d533 2
a534 2
			
			l = p-d;
d537 3
a539 3
			d=&(buf[5]);
			*(d++)=SSL3_MT_CLIENT_HELLO;
			l2n3(l,d);
d543 2
a544 3
			if (l > SSL3_RT_MAX_PLAIN_LENGTH)
				{
				SSLerr(SSL_F_SSL23_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);
d546 2
a547 2
				}
			
d549 1
a549 1
			d=buf;
d559 1
a559 1
			s2n((int)l,d);
d562 2
a563 2
			s->init_num=p-buf;
			s->init_off=0;
d565 2
a566 2
			ssl3_finish_mac(s,&(buf[5]), s->init_num - 5);
			}
d568 3
a570 3
		s->state=SSL23_ST_CW_CLNT_HELLO_B;
		s->init_off=0;
		}
d575 1
a575 2
	if ((ret >= 2) && s->msg_callback)
		{
d579 1
a579 1
			s->msg_callback(1, SSL2_VERSION, 0, s->init_buf->data+2, ret-2, s, s->msg_callback_arg);
d581 2
a582 2
			s->msg_callback(1, version, SSL3_RT_HANDSHAKE, s->init_buf->data+5, ret-5, s, s->msg_callback_arg);
		}
d585 1
a585 1
	}
d587 3
a589 2
static int ssl23_get_server_hello(SSL *s)
	{
d595 1
a595 1
	n=ssl23_read_bytes(s,7);
d597 3
a599 2
	if (n != 7) return(n);
	p=s->packet;
d601 1
a601 1
	memcpy(buf,p,n);
d604 1
a604 2
		(p[5] == 0x00) && (p[6] == 0x02))
		{
d606 1
a606 1
		SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
d614 2
a615 3
		if (s->options & SSL_OP_NO_SSLv2)
			{
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
d617 2
a618 3
			}
		if (s->s2 == NULL)
			{
d621 1
a621 2
			}
		else
d625 1
a625 1
			ch_len=SSL2_CHALLENGE_LENGTH;
d627 1
a627 1
			ch_len=SSL2_MAX_CHALLENGE_LENGTH;
d634 2
a635 3
		i=(SSL3_RANDOM_SIZE < ch_len)
			?SSL3_RANDOM_SIZE:ch_len;
		s->s2->challenge_length=i;
d637 1
a637 1
			&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);
d639 2
a640 1
		if (s->s3 != NULL) ssl3_free(s);
d643 2
a644 3
			SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))
			{
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,ERR_R_BUF_LIB);
d646 1
a646 1
			}
d648 1
a648 1
		s->state=SSL2_ST_GET_SERVER_HELLO_A;
d651 1
a651 1
			s->s2->ssl2_rollback=1;
d655 6
a660 6
		s->rstate=SSL_ST_READ_HEADER;
		s->packet_length=n;
		s->packet= &(s->s2->rbuf[0]);
		memcpy(s->packet,buf,n);
		s->s2->rbuf_left=n;
		s->s2->rbuf_offs=0;
d663 1
a663 1
		s->s2->write_sequence=1;
d665 2
a666 2
		s->method=SSLv2_client_method();
		s->handshake_func=s->method->ssl_connect;
d668 4
a671 6
		}
	else if (p[1] == SSL3_VERSION_MAJOR &&
	         p[2] <= TLS1_2_VERSION_MINOR &&
	         ((p[0] == SSL3_RT_HANDSHAKE && p[5] == SSL3_MT_SERVER_HELLO) ||
	          (p[0] == SSL3_RT_ALERT && p[3] == 0 && p[4] == 2)))
		{
d675 1
a675 2
			!(s->options & SSL_OP_NO_SSLv3))
			{
d677 1
a677 2
			if(FIPS_mode())
				{
d679 1
a679 1
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
d681 1
a681 1
				}
d683 16
a698 24
			s->version=SSL3_VERSION;
			s->method=SSLv3_client_method();
			}
		else if ((p[2] == TLS1_VERSION_MINOR) &&
			!(s->options & SSL_OP_NO_TLSv1))
			{
			s->version=TLS1_VERSION;
			s->method=TLSv1_client_method();
			}
		else if ((p[2] == TLS1_1_VERSION_MINOR) &&
			!(s->options & SSL_OP_NO_TLSv1_1))
			{
			s->version=TLS1_1_VERSION;
			s->method=TLSv1_1_client_method();
			}
		else if ((p[2] == TLS1_2_VERSION_MINOR) &&
			!(s->options & SSL_OP_NO_TLSv1_2))
			{
			s->version=TLS1_2_VERSION;
			s->method=TLSv1_2_client_method();
			}
		else
			{
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
d700 1
a700 1
			}
d702 1
a702 2
		if (p[0] == SSL3_RT_ALERT && p[5] != SSL3_AL_WARNING)
			{
d705 1
a705 1
			void (*cb)(const SSL *ssl,int type,int val)=NULL;
d709 1
a709 1
				cb=s->info_callback;
d711 8
a718 9
				cb=s->ctx->info_callback;
 
			i=p[5];
			if (cb != NULL)
				{
				j=(i<<8)|p[6];
				cb(s,SSL_CB_READ_ALERT,j);
				}
			
d720 1
a720 1
				s->msg_callback(0, s->version, SSL3_RT_ALERT, p+5, 2, s, s->msg_callback_arg);
d722 2
a723 2
			s->rwstate=SSL_NOTHING;
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_AD_REASON_OFFSET+p[6]);
d725 1
a725 1
			}
d727 2
a728 1
		if (!ssl_init_wbio_buffer(s,1)) goto err;
d731 1
a731 1
		s->state=SSL3_ST_CR_SRVR_HELLO_A;
d735 2
a736 2
		s->rstate=SSL_ST_READ_HEADER;
		s->packet_length=n;
d740 8
a747 10
		s->packet= &(s->s3->rbuf.buf[0]);
		memcpy(s->packet,buf,n);
		s->s3->rbuf.left=n;
		s->s3->rbuf.offset=0;

		s->handshake_func=s->method->ssl_connect;
		}
	else
		{
		SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNKNOWN_PROTOCOL);
d749 2
a750 2
		}
	s->init_num=0;
d754 1
a754 1
	if (!ssl_get_new_session(s,0))
d757 1
a757 1
	return(SSL_connect(s));
d759 2
a760 2
	return(-1);
	}
@


1.14
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d155 1
a155 1
	clear_sys_error();
@


1.13
log
@resolve conflicts
@
text
@d272 23
d300 1
a300 1
	unsigned long Time,l;
d381 1
a381 3
		Time=(unsigned long)time(NULL);		/* Time */
		l2n(Time,p);
		if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
@


1.12
log
@resolve conflicts, fix local changes
@
text
@d132 4
d285 1
d287 1
a287 1
	ssl2_compat = (s->options & SSL_OP_NO_SSLv2) ? 0 : 1;
d292 26
a317 2
	if (!(s->options & SSL_OP_NO_TLSv1))
		{
d319 3
a321 3
		}
	else if (!(s->options & SSL_OP_NO_SSLv3))
		{
d323 4
a326 3
		}
	else if (!(s->options & SSL_OP_NO_SSLv2))
		{
d328 2
a329 1
		}
d363 11
a373 1
		if (version == TLS1_VERSION)
d378 8
d489 9
d552 7
a558 2
			*(d++) = version_minor; /* arguably we should send the *lowest* suported version here
			                         * (indicating, e.g., TLS 1.0 in "SSL 3.0 format") */
d674 1
a674 1
	         (p[2] == SSL3_VERSION_MINOR || p[2] == TLS1_VERSION_MINOR) &&
d683 8
d699 12
@


1.11
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d58 53
d119 1
a119 1
static SSL_METHOD *ssl23_get_client_method(int ver);
d122 1
a122 1
static SSL_METHOD *ssl23_get_client_method(int ver)
d253 14
d272 1
a272 1
	int i,j,ch_len;
d276 2
d279 1
d284 3
d299 1
a299 1
#ifndef OPENSSL_NO_TLSEXT 
d308 4
a336 8
#ifdef OPENSSL_FIPS
		else if(FIPS_mode())
			{
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
			return -1;
			}
#endif
d390 4
d444 5
a448 1
			if (s->ctx->comp_methods == NULL)
d458 1
d460 1
d462 6
a475 1
			*p = 42;
d570 4
d594 1
a594 1
		/* setup the 5 bytes we have read so we get them from
d610 4
a613 5
	else if ((p[0] == SSL3_RT_HANDSHAKE) &&
		 (p[1] == SSL3_VERSION_MAJOR) &&
		 ((p[2] == SSL3_VERSION_MINOR) ||
		  (p[2] == TLS1_VERSION_MINOR)) &&
		 (p[5] == SSL3_MT_SERVER_HELLO))
d615 1
a615 15
		/* we have sslv3 or tls1 */

		if (!ssl_init_wbio_buffer(s,1)) goto err;

		/* we are in this state */
		s->state=SSL3_ST_CR_SRVR_HELLO_A;

		/* put the 5 bytes we have read into the input buffer
		 * for SSLv3 */
		s->rstate=SSL_ST_READ_HEADER;
		s->packet_length=n;
		s->packet= &(s->s3->rbuf.buf[0]);
		memcpy(s->packet,buf,n);
		s->s3->rbuf.left=n;
		s->s3->rbuf.offset=0;
a619 8
#ifdef OPENSSL_FIPS
			if(FIPS_mode())
				{
				SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
				goto err;
				}
#endif
d634 19
d654 6
a659 23
		s->handshake_func=s->method->ssl_connect;
		}
	else if ((p[0] == SSL3_RT_ALERT) &&
		 (p[1] == SSL3_VERSION_MAJOR) &&
		 ((p[2] == SSL3_VERSION_MINOR) ||
		  (p[2] == TLS1_VERSION_MINOR)) &&
		 (p[3] == 0) &&
		 (p[4] == 2))
		{
		void (*cb)(const SSL *ssl,int type,int val)=NULL;
		int j;

		/* An alert */
		if (s->info_callback != NULL)
			cb=s->info_callback;
		else if (s->ctx->info_callback != NULL)
			cb=s->ctx->info_callback;
 
		i=p[5];
		if (cb != NULL)
			{
			j=(i<<8)|p[6];
			cb(s,SSL_CB_READ_ALERT,j);
d662 18
a679 3
		s->rwstate=SSL_NOTHING;
		SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_AD_REASON_OFFSET+p[6]);
		goto err;
a696 1

@


1.10
log
@resolve conflicts
@
text
@d260 8
d547 8
@


1.9
log
@resolve conflicts
@
text
@d83 4
a86 22
SSL_METHOD *SSLv23_client_method(void)
	{
	static int init=1;
	static SSL_METHOD SSLv23_client_data;

	if (init)
		{
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);

		if (init)
			{
			memcpy((char *)&SSLv23_client_data,
				(char *)sslv23_base_method(),sizeof(SSL_METHOD));
			SSLv23_client_data.ssl_connect=ssl23_connect;
			SSLv23_client_data.get_ssl_method=ssl23_get_client_method;
			init=0;
			}

		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);
		}
	return(&SSLv23_client_data);
	}
d226 11
d250 1
a250 1
		Time=(unsigned long)time(NULL);			/* Time */
a259 8
#ifdef OPENSSL_FIPS
		else if(FIPS_mode())
			{
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
			return -1;
			}
#endif
d374 7
a538 8
#ifdef OPENSSL_FIPS
			if(FIPS_mode())
				{
				SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
				goto err;
				}
#endif
a594 1
	s->first_packet=1;
@


1.8
log
@resolve conflicts
@
text
@d109 1
a109 1
	unsigned long Time=time(NULL);
d223 5
a227 1
	int i,ch_len;
d230 15
d257 4
a260 2
		if(RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE) <= 0)
		    return -1;
d262 4
a265 10
		/* Do the message type and length last */
		d= &(buf[2]);
		p=d+9;

		*(d++)=SSL2_MT_CLIENT_HELLO;
		if (!(s->options & SSL_OP_NO_TLSv1))
			{
			*(d++)=TLS1_VERSION_MAJOR;
			*(d++)=TLS1_VERSION_MINOR;
			s->client_version=TLS1_VERSION;
d275 1
a275 1
		else if (!(s->options & SSL_OP_NO_SSLv3))
d277 2
a278 3
			*(d++)=SSL3_VERSION_MAJOR;
			*(d++)=SSL3_VERSION_MINOR;
			s->client_version=SSL3_VERSION;
d280 1
a280 1
		else if (!(s->options & SSL_OP_NO_SSLv2))
d282 2
a283 3
			*(d++)=SSL2_VERSION_MAJOR;
			*(d++)=SSL2_VERSION_MINOR;
			s->client_version=SSL2_VERSION;
d291 3
a293 3
		/* Ciphers supported */
		i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),p);
		if (i == 0)
d295 1
a295 6
			/* no ciphers */
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);
			return(-1);
			}
		s2n(i,d);
		p+=i;
d297 20
a316 2
		/* put in the session-id, zero since there is no
		 * reuse. */
d318 1
a318 1
		s->session->session_id_length=0;
d320 27
a346 1
		s2n(0,d);
d348 2
a349 2
		if (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)
			ch_len=SSL2_CHALLENGE_LENGTH;
d351 2
a352 1
			ch_len=SSL2_MAX_CHALLENGE_LENGTH;
d354 45
a398 9
		/* write out sslv2 challenge */
		if (SSL3_RANDOM_SIZE < ch_len)
			i=SSL3_RANDOM_SIZE;
		else
			i=ch_len;
		s2n(i,d);
		memset(&(s->s3->client_random[0]),0,SSL3_RANDOM_SIZE);
		if(RAND_pseudo_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i) <= 0)
			return -1;
d400 17
a416 2
		memcpy(p,&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);
		p+=i;
d418 2
a419 3
		i= p- &(buf[2]);
		buf[0]=((i>>8)&0xff)|0x80;
		buf[1]=(i&0xff);
a421 2
		/* number of bytes to write */
		s->init_num=i+2;
a422 2

		ssl3_finish_mac(s,&(buf[2]),i);
d427 11
a437 3
	if (ret >= 2)
		if (s->msg_callback)
			s->msg_callback(1, SSL2_VERSION, 0, s->init_buf->data+2, ret-2, s, s->msg_callback_arg); /* CLIENT-HELLO */
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d238 2
a239 1
		RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE);
d252 8
d308 3
a310 1
		RAND_pseudo_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);
d440 8
@


1.6
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d90 12
a101 5
		memcpy((char *)&SSLv23_client_data,
			(char *)sslv23_base_method(),sizeof(SSL_METHOD));
		SSLv23_client_data.ssl_connect=ssl23_connect;
		SSLv23_client_data.get_ssl_method=ssl23_get_client_method;
		init=0;
d108 1
a108 1
	BUF_MEM *buf;
d162 1
d211 2
d376 1
a376 1
		if (!BUF_MEM_grow(s->init_buf,
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d60 1
a64 1
#include "ssl_locl.h"
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d71 1
a71 1
#ifndef NO_SSL2
d103 1
a103 1
	void (*cb)()=NULL;
d116 1
a117 1
	s->in_handshake++;
d214 1
d306 5
a310 1
	return(ssl23_write_bytes(s));
d330 1
a330 1
#ifdef NO_SSL2
d443 1
a443 1
		void (*cb)()=NULL;
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d369 3
a371 1
		s->s2->ssl2_rollback=1;
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d71 1
d74 1
d107 1
a107 1
	RAND_seed(&Time,sizeof(Time));
d227 1
a227 1
		RAND_bytes(p,SSL3_RANDOM_SIZE);
d288 1
a288 1
		RAND_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);
d312 1
a312 1
	int i,ch_len;
d325 4
d332 1
d385 1
@


1.1
log
@Initial revision
@
text
@d60 4
a63 4
#include "buffer.h"
#include "rand.h"
#include "objects.h"
#include "evp.h"
d66 1
a66 3
#define BREAK break

#ifndef NOPROTO
d69 1
a69 7
#else
static int ssl23_client_hello();
static int ssl23_get_server_hello();
#endif

static SSL_METHOD *ssl23_get_client_method(ver)
int ver;
d73 1
a73 1
	else if (ver == SSL3_VERSION)
d81 1
a81 1
SSL_METHOD *SSLv23_client_method()
a87 1
		init=0;
d92 1
d97 1
a97 2
int ssl23_connect(s)
SSL *s;
d105 1
a105 1
	RAND_seed((unsigned char *)&Time,sizeof(Time));
d128 7
d160 1
a160 1
			s->ctx->sess_connect++;
d180 1
a180 1
			break;
d189 1
a189 1
		if (s->debug) BIO_flush(s->wbio);
d207 1
a207 2
static int ssl23_client_hello(s)
SSL *s;
d236 1
d242 1
d248 1
d306 1
a306 2
static int ssl23_get_server_hello(s)
SSL *s;
d445 1
a445 1
		SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,1000+p[6]);
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d60 4
a63 4
#include <openssl/buffer.h>
#include <openssl/rand.h>
#include <openssl/objects.h>
#include <openssl/evp.h>
d66 3
a68 1
static SSL_METHOD *ssl23_get_client_method(int ver);
d71 7
a77 1
static SSL_METHOD *ssl23_get_client_method(int ver)
a78 1
#ifndef OPENSSL_NO_SSL2
d81 1
a81 2
#endif
	if (ver == SSL3_VERSION)
d89 1
a89 1
SSL_METHOD *SSLv23_client_method(void)
d96 1
a100 1
		init=0;
d105 2
a106 1
int ssl23_connect(SSL *s)
d110 1
a110 1
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
d114 1
a114 1
	RAND_add(&Time,sizeof(Time),0);
d123 1
a124 1
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 
a136 7
			if (s->session != NULL)
				{
				SSLerr(SSL_F_SSL23_CONNECT,SSL_R_SSL23_DOING_SESSION_ID_REUSE);
				ret= -1;
				goto end;
				}
			s->server=0;
d162 1
a162 1
			s->ctx->stats.sess_connect++;
d182 1
a182 1
			/* break; */
d191 1
a191 1
		if (s->debug) { (void)BIO_flush(s->wbio); }
d209 2
a210 1
static int ssl23_client_hello(SSL *s)
a214 1
	int ret;
d228 1
a228 1
		RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE);
a238 1
			s->client_version=TLS1_VERSION;
a243 1
			s->client_version=SSL3_VERSION;
a248 1
			s->client_version=SSL2_VERSION;
d286 1
a286 1
		RAND_pseudo_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);
d303 1
a303 5
	ret = ssl23_write_bytes(s);
	if (ret >= 2)
		if (s->msg_callback)
			s->msg_callback(1, SSL2_VERSION, 0, s->init_buf->data+2, ret-2, s, s->msg_callback_arg); /* CLIENT-HELLO */
	return ret;
d306 2
a307 1
static int ssl23_get_server_hello(SSL *s)
d311 1
a311 1
	int i;
a323 4
#ifdef OPENSSL_NO_SSL2
		SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
		goto err;
#else
a326 1
		int ch_len;
d363 1
a363 3
		if (!(s->client_version == SSL2_VERSION))
			/* use special padding (SSL 3.0 draft/RFC 2246, App. E.2) */
			s->s2->ssl2_rollback=1;
a378 1
#endif
d429 1
a429 1
		void (*cb)(const SSL *ssl,int type,int val)=NULL;
d446 1
a446 1
		SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_AD_REASON_OFFSET+p[6]);
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a59 1
#include "ssl_locl.h"
d64 1
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d90 5
a94 12
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);

		if (init)
			{
			memcpy((char *)&SSLv23_client_data,
				(char *)sslv23_base_method(),sizeof(SSL_METHOD));
			SSLv23_client_data.ssl_connect=ssl23_connect;
			SSLv23_client_data.get_ssl_method=ssl23_get_client_method;
			init=0;
			}

		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);
d101 1
a101 1
	BUF_MEM *buf=NULL;
a154 1
				buf=NULL;
a202 2
	if (buf != NULL)
		BUF_MEM_free(buf);
d366 1
a366 1
		if (!BUF_MEM_grow_clean(s->init_buf,
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d238 1
a238 2
		if(RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE) <= 0)
		    return -1;
a250 8
#ifdef OPENSSL_FIPS
		else if(FIPS_mode())
			{
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
			return -1;
			}
#endif
d299 1
a299 3
		if(RAND_pseudo_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i) <= 0)
			return -1;

a428 8
#ifdef OPENSSL_FIPS
			if(FIPS_mode())
				{
				SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
				goto err;
				}
#endif
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@d109 1
a109 1
	unsigned long Time=(unsigned long)time(NULL);
d223 1
a223 5
	int i,j,ch_len;
	unsigned long Time,l;
	int ssl2_compat;
	int version = 0, version_major, version_minor;
	SSL_COMP *comp;
a225 15
	ssl2_compat = (s->options & SSL_OP_NO_SSLv2) ? 0 : 1;

	if (!(s->options & SSL_OP_NO_TLSv1))
		{
		version = TLS1_VERSION;
		}
	else if (!(s->options & SSL_OP_NO_SSLv3))
		{
		version = SSL3_VERSION;
		}
	else if (!(s->options & SSL_OP_NO_SSLv2))
		{
		version = SSL2_VERSION;
		}

d238 2
a239 4
		Time=(unsigned long)time(NULL);			/* Time */
		l2n(Time,p);
		if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
			return -1;
d241 10
a250 4
		if (version == TLS1_VERSION)
			{
			version_major = TLS1_VERSION_MAJOR;
			version_minor = TLS1_VERSION_MINOR;
d260 1
a260 1
		else if (version == SSL3_VERSION)
d262 3
a264 2
			version_major = SSL3_VERSION_MAJOR;
			version_minor = SSL3_VERSION_MINOR;
d266 1
a266 1
		else if (version == SSL2_VERSION)
d268 3
a270 2
			version_major = SSL2_VERSION_MAJOR;
			version_minor = SSL2_VERSION_MINOR;
d278 3
a280 3
		s->client_version = version;

		if (ssl2_compat)
d282 6
a287 1
			/* create SSL 2.0 compatible Client Hello */
d289 2
a290 20
			/* two byte record header will be written last */
			d = &(buf[2]);
			p = d + 9; /* leave space for message type, version, individual length fields */

			*(d++) = SSL2_MT_CLIENT_HELLO;
			*(d++) = version_major;
			*(d++) = version_minor;
			
			/* Ciphers supported */
			i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),p,0);
			if (i == 0)
				{
				/* no ciphers */
				SSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);
				return -1;
				}
			s2n(i,d);
			p+=i;
			
			/* put in the session-id length (zero since there is no reuse) */
d292 1
a292 1
			s->session->session_id_length=0;
d294 1
a294 1
			s2n(0,d);
d296 4
a299 25
			if (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)
				ch_len=SSL2_CHALLENGE_LENGTH;
			else
				ch_len=SSL2_MAX_CHALLENGE_LENGTH;

			/* write out sslv2 challenge */
			if (SSL3_RANDOM_SIZE < ch_len)
				i=SSL3_RANDOM_SIZE;
			else
				i=ch_len;
			s2n(i,d);
			memset(&(s->s3->client_random[0]),0,SSL3_RANDOM_SIZE);
			if (RAND_pseudo_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i) <= 0)
				return -1;

			memcpy(p,&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);
			p+=i;

			i= p- &(buf[2]);
			buf[0]=((i>>8)&0xff)|0x80;
			buf[1]=(i&0xff);

			/* number of bytes to write */
			s->init_num=i+2;
			s->init_off=0;
d301 3
a303 2
			ssl3_finish_mac(s,&(buf[2]),i);
			}
d305 5
a309 2
			{
			/* create Client Hello in SSL 3.0/TLS 1.0 format */
d311 2
a312 63
			/* do the record header (5 bytes) and handshake message header (4 bytes) last */
			d = p = &(buf[9]);
			
			*(p++) = version_major;
			*(p++) = version_minor;

			/* Random stuff */
			memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
			p += SSL3_RANDOM_SIZE;

			/* Session ID (zero since there is no reuse) */
			*(p++) = 0;

			/* Ciphers supported (using SSL 3.0/TLS 1.0 format) */
			i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),ssl3_put_cipher_by_char);
			if (i == 0)
				{
				SSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);
				return -1;
				}
			s2n(i,p);
			p+=i;

			/* COMPRESSION */
			if (s->ctx->comp_methods == NULL)
				j=0;
			else
				j=sk_SSL_COMP_num(s->ctx->comp_methods);
			*(p++)=1+j;
			for (i=0; i<j; i++)
				{
				comp=sk_SSL_COMP_value(s->ctx->comp_methods,i);
				*(p++)=comp->id;
				}
			*(p++)=0; /* Add the NULL method */
			
			l = p-d;
			*p = 42;

			/* fill in 4-byte handshake header */
			d=&(buf[5]);
			*(d++)=SSL3_MT_CLIENT_HELLO;
			l2n3(l,d);

			l += 4;

			if (l > SSL3_RT_MAX_PLAIN_LENGTH)
				{
				SSLerr(SSL_F_SSL23_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);
				return -1;
				}
			
			/* fill in 5-byte record header */
			d=buf;
			*(d++) = SSL3_RT_HANDSHAKE;
			*(d++) = version_major;
			*(d++) = version_minor; /* arguably we should send the *lowest* suported version here
			                         * (indicating, e.g., TLS 1.0 in "SSL 3.0 format") */
			s2n((int)l,d);

			/* number of bytes to write */
			s->init_num=p-buf;
			s->init_off=0;
d314 3
a316 2
			ssl3_finish_mac(s,&(buf[5]), s->init_num - 5);
			}
d319 2
d322 2
d328 3
a330 11

	if ((ret >= 2) && s->msg_callback)
		{
		/* Client Hello has been sent; tell msg_callback */

		if (ssl2_compat)
			s->msg_callback(1, SSL2_VERSION, 0, s->init_buf->data+2, ret-2, s, s->msg_callback_arg);
		else
			s->msg_callback(1, version, SSL3_RT_HANDSHAKE, s->init_buf->data+5, ret-5, s, s->msg_callback_arg);
		}

@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d83 22
a104 4
IMPLEMENT_ssl23_meth_func(SSLv23_client_method,
			ssl_undefined_function,
			ssl23_connect,
			ssl23_get_client_method)
a243 11
#ifndef OPENSSL_NO_TLSEXT 
	if (version != SSL2_VERSION)
		{
		/* have to disable SSL 2.0 compatibility if we need TLS extensions */

		if (s->tlsext_hostname != NULL)
			ssl2_compat = 0;
		if (s->tlsext_status_type != -1)
			ssl2_compat = 0;
		}
#endif
d257 1
a257 1
		Time=(unsigned long)time(NULL);		/* Time */
d267 8
a388 7
#ifndef OPENSSL_NO_TLSEXT
			if ((p = ssl_add_clienthello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
				{
				SSLerr(SSL_F_SSL23_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);
				return -1;
				}
#endif
d547 8
d611 1
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a259 8
#ifdef OPENSSL_FIPS
		else if(FIPS_mode())
			{
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
			return -1;
			}
#endif
a538 8
#ifdef OPENSSL_FIPS
			if(FIPS_mode())
				{
				SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
				goto err;
				}
#endif
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d66 1
a66 1
static const SSL_METHOD *ssl23_get_client_method(int ver);
d69 1
a69 1
static const SSL_METHOD *ssl23_get_client_method(int ver)
a199 14
static int ssl23_no_ssl2_ciphers(SSL *s)
	{
	SSL_CIPHER *cipher;
	STACK_OF(SSL_CIPHER) *ciphers;
	int i;
	ciphers = SSL_get_ciphers(s);
	for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++)
		{
		cipher = sk_SSL_CIPHER_value(ciphers, i);
		if (cipher->algorithm_ssl == SSL_SSLV2)
			return 0;
		}
	return 1;
	}
d205 1
a205 1
	int i,ch_len;
a208 2
#ifndef OPENSSL_NO_COMP
	int j;
a209 1
#endif
a213 3
	if (ssl2_compat && ssl23_no_ssl2_ciphers(s))
		ssl2_compat = 0;

d226 1
a226 1
#ifndef OPENSSL_NO_TLSEXT
a234 4
#ifdef TLSEXT_TYPE_opaque_prf_input
		if (s->ctx->tlsext_opaque_prf_input_callback != 0 || s->tlsext_opaque_prf_input != NULL)
			ssl2_compat = 0;
#endif
d260 8
a320 4
			/* Note that ch_len must be <= SSL3_RANDOM_SIZE (32),
			   because it is one of SSL2_MAX_CHALLENGE_LENGTH (32)
			   or SSL2_MAX_CHALLENGE_LENGTH (16), but leave the
			   check in for futurproofing */
d371 1
a371 5
#ifdef OPENSSL_NO_COMP
			*(p++)=1;
#else
			if ((s->options & SSL_OP_NO_COMPRESSION)
						|| !s->ctx->comp_methods)
a380 1
#endif
a381 1

a382 6
			/* TLS extensions*/
			if (ssl_prepare_clienthello_tlsext(s) <= 0)
				{
				SSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_CLIENTHELLO_TLSEXT);
				return -1;
				}
d391 1
a485 4
		/* Note that ch_len must be <= SSL3_RANDOM_SIZE (32), because
		   it is one of SSL2_MAX_CHALLENGE_LENGTH (32) or
		   SSL2_MAX_CHALLENGE_LENGTH (16), but leave the check in for
		   futurproofing */
d506 1
a506 1
		/* setup the 7 bytes we have read so we get them from
d522 5
a526 4
	else if (p[1] == SSL3_VERSION_MAJOR &&
	         (p[2] == SSL3_VERSION_MINOR || p[2] == TLS1_VERSION_MINOR) &&
	         ((p[0] == SSL3_RT_HANDSHAKE && p[5] == SSL3_MT_SERVER_HELLO) ||
	          (p[0] == SSL3_RT_ALERT && p[3] == 0 && p[4] == 2)))
d528 15
a542 1
		/* we have sslv3 or tls1 (server hello or alert) */
d547 8
d569 21
a589 2

		if (p[0] == SSL3_RT_ALERT && p[5] != SSL3_AL_WARNING)
d591 2
a592 23
			/* fatal alert */

			void (*cb)(const SSL *ssl,int type,int val)=NULL;
			int j;

			if (s->info_callback != NULL)
				cb=s->info_callback;
			else if (s->ctx->info_callback != NULL)
				cb=s->ctx->info_callback;
 
			i=p[5];
			if (cb != NULL)
				{
				j=(i<<8)|p[6];
				cb(s,SSL_CB_READ_ALERT,j);
				}
			
			if (s->msg_callback)
				s->msg_callback(0, s->version, SSL3_RT_ALERT, p+5, 2, s, s->msg_callback_arg);

			s->rwstate=SSL_NOTHING;
			SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_AD_REASON_OFFSET+p[6]);
			goto err;
d595 3
a597 18
		if (!ssl_init_wbio_buffer(s,1)) goto err;

		/* we are in this state */
		s->state=SSL3_ST_CR_SRVR_HELLO_A;

		/* put the 7 bytes we have read into the input buffer
		 * for SSLv3 */
		s->rstate=SSL_ST_READ_HEADER;
		s->packet_length=n;
		if (s->s3->rbuf.buf == NULL)
			if (!ssl3_setup_read_buffer(s))
				goto err;
		s->packet= &(s->s3->rbuf.buf[0]);
		memcpy(s->packet,buf,n);
		s->s3->rbuf.left=n;
		s->s3->rbuf.offset=0;

		s->handshake_func=s->method->ssl_connect;
d615 1
@


1.1.1.10
log
@import OpenSSL-1.0.1c
@
text
@a131 4
	else if (ver == TLS1_1_VERSION)
		return(TLSv1_1_client_method());
	else if (ver == TLS1_2_VERSION)
		return(TLSv1_2_client_method());
a280 1
	unsigned long mask, options = s->options;
d282 1
a282 1
	ssl2_compat = (options & SSL_OP_NO_SSLv2) ? 0 : 1;
d287 2
a288 26
	/*
	 * SSL_OP_NO_X disables all protocols above X *if* there are
	 * some protocols below X enabled. This is required in order
	 * to maintain "version capability" vector contiguous. So
	 * that if application wants to disable TLS1.0 in favour of
	 * TLS1>=1, it would be insufficient to pass SSL_NO_TLSv1, the
	 * answer is SSL_OP_NO_TLSv1|SSL_OP_NO_SSLv3|SSL_OP_NO_SSLv2.
	 */
	mask =	SSL_OP_NO_TLSv1_1|SSL_OP_NO_TLSv1
#if !defined(OPENSSL_NO_SSL3)
		|SSL_OP_NO_SSLv3
#endif
#if !defined(OPENSSL_NO_SSL2)
		|(ssl2_compat?SSL_OP_NO_SSLv2:0)
#endif
		;
#if !defined(OPENSSL_NO_TLS1_2_CLIENT)
	version = TLS1_2_VERSION;

	if ((options & SSL_OP_NO_TLSv1_2) && (options & mask) != mask)
		version = TLS1_1_VERSION;
#else
	version = TLS1_1_VERSION;
#endif
	mask &= ~SSL_OP_NO_TLSv1_1;
	if ((options & SSL_OP_NO_TLSv1_1) && (options & mask) != mask)
d290 3
a292 3
	mask &= ~SSL_OP_NO_TLSv1;
#if !defined(OPENSSL_NO_SSL3)
	if ((options & SSL_OP_NO_TLSv1) && (options & mask) != mask)
d294 3
a296 4
	mask &= ~SSL_OP_NO_SSLv3;
#endif
#if !defined(OPENSSL_NO_SSL2)
	if ((options & SSL_OP_NO_SSLv3) && (options & mask) != mask)
d298 1
a298 2
#endif

d332 1
a332 11
		if (version == TLS1_2_VERSION)
			{
			version_major = TLS1_2_VERSION_MAJOR;
			version_minor = TLS1_2_VERSION_MINOR;
			}
		else if (version == TLS1_1_VERSION)
			{
			version_major = TLS1_1_VERSION_MAJOR;
			version_minor = TLS1_1_VERSION_MINOR;
			}
		else if (version == TLS1_VERSION)
a336 8
#ifdef OPENSSL_FIPS
		else if(FIPS_mode())
			{
			SSLerr(SSL_F_SSL23_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
			return -1;
			}
#endif
a439 9
#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
			/* Some servers hang if client hello > 256 bytes
			 * as hack workaround chop number of supported ciphers
			 * to keep it well below this if we use TLS v1.2
			 */
			if (TLS1_get_version(s) >= TLS1_2_VERSION
				&& i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
				i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
#endif
d494 2
a495 7
			/* Some servers hang if we use long client hellos
			 * and a record number > TLS 1.0.
			 */
			if (TLS1_get_client_version(s) > TLS1_VERSION)
				*(d++) = 1;
			else
				*(d++) = version_minor;
d611 1
a611 1
	         p[2] <= TLS1_2_VERSION_MINOR &&
a619 8
#ifdef OPENSSL_FIPS
			if(FIPS_mode())
				{
				SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
				goto err;
				}
#endif
a627 12
			}
		else if ((p[2] == TLS1_1_VERSION_MINOR) &&
			!(s->options & SSL_OP_NO_TLSv1_1))
			{
			s->version=TLS1_1_VERSION;
			s->method=TLSv1_1_client_method();
			}
		else if ((p[2] == TLS1_2_VERSION_MINOR) &&
			!(s->options & SSL_OP_NO_TLSv1_2))
			{
			s->version=TLS1_2_VERSION;
			s->method=TLSv1_2_client_method();
@


1.1.1.11
log
@Import OpenSSL 1.0.1g
@
text
@a271 23
/* Fill a ClientRandom or ServerRandom field of length len. Returns <= 0
 * on failure, 1 on success. */
int ssl_fill_hello_random(SSL *s, int server, unsigned char *result, int len)
	{
	int send_time = 0;

	if (len < 4)
		return 0;
	if (server)
		send_time = (s->mode & SSL_MODE_SEND_SERVERHELLO_TIME) != 0;
	else
		send_time = (s->mode & SSL_MODE_SEND_CLIENTHELLO_TIME) != 0;
	if (send_time)
		{
		unsigned long Time = (unsigned long)time(NULL);
		unsigned char *p = result;
		l2n(Time, p);
		return RAND_pseudo_bytes(p, len-4);
		}
	else
		return RAND_pseudo_bytes(result, len);
	}

d277 1
a277 1
	unsigned long l;
d358 3
a360 1
		if (ssl_fill_hello_random(s, 0, p, SSL3_RANDOM_SIZE) <= 0)
@


