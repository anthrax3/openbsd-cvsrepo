head	1.86;
access;
symbols
	OPENBSD_6_0:1.85.0.2
	OPENBSD_6_0_BASE:1.85
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.79.0.4
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.77.0.4
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.69.0.2
	OPENBSD_5_6_BASE:1.69
	butholakala:1.19
	openssl_1_0_1_g:1.1.1.11
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	openssl_1_0_1_c:1.1.1.10
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	openssl_1_0_0_f:1.1.1.9
	openssl_1_0_0_e:1.1.1.9
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	openssh_1_0_0_a:1.1.1.8
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	openssl_0_9_8_k:1.1.1.7
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	openssl_0_9_8_j:1.1.1.7
	openssl_0_9_8_h:1.1.1.6
	pre_openssl_0_9_8h:1.10
	OPENBSD_4_4:1.10.0.14
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.12
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.10
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	openssl_0_9_7j:1.1.1.5
	openssl:1.1.1
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.86
date	2016.09.03.11.33.41;	author beck;	state dead;
branches;
next	1.85;
commitid	HnbXxsegngek41U2;

1.85
date	2016.04.28.16.39.45;	author jsing;	state Exp;
branches;
next	1.84;
commitid	MlZ5jZHGKzYpF9uz;

1.84
date	2016.03.06.14.52.15;	author beck;	state Exp;
branches;
next	1.83;
commitid	7dzq0qLU3rfFj8Ei;

1.83
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.82;
commitid	pa8oXRlJthT375Ws;

1.82
date	2015.09.11.17.54.23;	author jsing;	state Exp;
branches;
next	1.81;
commitid	xUO4TxX2aWuC1cir;

1.81
date	2015.09.10.15.56.26;	author jsing;	state Exp;
branches;
next	1.80;
commitid	vHznCDK3idwNEFz4;

1.80
date	2015.08.27.14.16.57;	author jsing;	state Exp;
branches;
next	1.79;
commitid	WJYF4fTeXHOgvyuc;

1.79
date	2015.07.17.07.04.41;	author doug;	state Exp;
branches;
next	1.78;
commitid	UNQoAwJYBULH7Shk;

1.78
date	2015.06.17.14.27.56;	author jsing;	state Exp;
branches;
next	1.77;
commitid	bj1SO1XyllNsvf5a;

1.77
date	2015.02.22.15.54.27;	author jsing;	state Exp;
branches;
next	1.76;
commitid	9t8bOP5HFWMq1Big;

1.76
date	2015.02.07.18.53.55;	author doug;	state Exp;
branches;
next	1.75;
commitid	NaIdarOUvAfU8moX;

1.75
date	2014.12.15.00.46.53;	author doug;	state Exp;
branches;
next	1.74;
commitid	I2ue40Sqz1Sg9KmB;

1.74
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.73;
commitid	XNZawfRSWvnVv1VS;

1.73
date	2014.11.18.05.33.43;	author miod;	state Exp;
branches;
next	1.72;
commitid	81uwsCsokEuKDUjo;

1.72
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.71;
commitid	M3pvHgIFoWUHNqJn;

1.71
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.70;
commitid	cGE1JG2i0h4NcVDi;

1.70
date	2014.10.18.03.04.28;	author doug;	state Exp;
branches;
next	1.69;
commitid	d3IDuvWT3qgh5zCJ;

1.69
date	2014.08.07.20.02.23;	author miod;	state Exp;
branches;
next	1.68;
commitid	DMh9IXTC6aDWVuh5;

1.68
date	2014.08.07.19.46.31;	author miod;	state Exp;
branches;
next	1.67;
commitid	vayOLqnrIMw5dnz8;

1.67
date	2014.07.10.10.09.54;	author jsing;	state Exp;
branches;
next	1.66;
commitid	ClZ3wY7kSvwpyKpe;

1.66
date	2014.07.10.08.51.15;	author tedu;	state Exp;
branches;
next	1.65;
commitid	lsH7iukeZYSZBx6F;

1.65
date	2014.07.09.11.25.42;	author jsing;	state Exp;
branches;
next	1.64;
commitid	N5P2FUkVkAd7ODs9;

1.64
date	2014.07.08.16.05.52;	author beck;	state Exp;
branches;
next	1.63;
commitid	Z6g1m27LULYnqz2h;

1.63
date	2014.06.21.17.02.25;	author jsing;	state Exp;
branches;
next	1.62;
commitid	pgD7ISJAPEuMy3ok;

1.62
date	2014.06.21.14.45.22;	author jsing;	state Exp;
branches;
next	1.61;
commitid	OvtZWZNpEJau6WOb;

1.61
date	2014.06.21.14.06.36;	author jsing;	state Exp;
branches;
next	1.60;
commitid	v7wreMJHPRr7lJCz;

1.60
date	2014.06.15.15.29.25;	author jsing;	state Exp;
branches;
next	1.59;
commitid	G9UpwpcoMkFCFqBD;

1.59
date	2014.06.13.16.09.15;	author jsing;	state Exp;
branches;
next	1.58;
commitid	XHjGN1E5JLIwHdlv;

1.58
date	2014.06.13.14.32.35;	author jsing;	state Exp;
branches;
next	1.57;
commitid	mVqDEcho3vgzJqG8;

1.57
date	2014.06.13.12.49.10;	author jsing;	state Exp;
branches;
next	1.56;
commitid	MMJlFvE2ueU0pY8p;

1.56
date	2014.06.13.11.52.03;	author jsing;	state Exp;
branches;
next	1.55;
commitid	yMCwYdOgQN7IP0A0;

1.55
date	2014.06.13.04.29.13;	author miod;	state Exp;
branches;
next	1.54;
commitid	8Qu6YceLSxhOi4yG;

1.54
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	mJUVYpkFBZ0Zv2bG;

1.53
date	2014.06.11.15.44.10;	author jsing;	state Exp;
branches;
next	1.52;
commitid	atiHl7idnrYpOeRd;

1.52
date	2014.06.10.14.46.11;	author jsing;	state Exp;
branches;
next	1.51;
commitid	2EvEg67gjrs1M5t8;

1.51
date	2014.06.08.15.10.14;	author jsing;	state Exp;
branches;
next	1.50;
commitid	mOEr8ksZemEjdEvz;

1.50
date	2014.06.08.14.33.04;	author jsing;	state Exp;
branches;
next	1.49;
commitid	ttArGFljzBk2CH47;

1.49
date	2014.06.08.14.13.44;	author jsing;	state Exp;
branches;
next	1.48;
commitid	yTVStANHMXFUNa12;

1.48
date	2014.06.08.13.32.32;	author jsing;	state Exp;
branches;
next	1.47;
commitid	RHdUF7M1zzxR9LM5;

1.47
date	2014.06.07.17.27.14;	author jsing;	state Exp;
branches;
next	1.46;
commitid	NrcEm3OumWy3OF2v;

1.46
date	2014.06.07.17.16.39;	author jsing;	state Exp;
branches;
next	1.45;
commitid	ozetdsY7niMZNdZz;

1.45
date	2014.06.07.17.10.47;	author jsing;	state Exp;
branches;
next	1.44;
commitid	G53XsIm1Jujr5ujX;

1.44
date	2014.06.07.17.05.47;	author jsing;	state Exp;
branches;
next	1.43;
commitid	q1KO0llkEqaDL0E8;

1.43
date	2014.06.07.15.57.27;	author jsing;	state Exp;
branches;
next	1.42;
commitid	AAk5bsIZTREcKQGa;

1.42
date	2014.06.07.15.23.48;	author jsing;	state Exp;
branches;
next	1.41;
commitid	wBFx3uF6WzFlm1uO;

1.41
date	2014.06.02.13.02.31;	author jsing;	state Exp;
branches;
next	1.40;
commitid	JEkOL8UJQTJyTHxg;

1.40
date	2014.06.01.16.07.20;	author jsing;	state Exp;
branches;
next	1.39;
commitid	SI9UFGvYdBWx3Uqp;

1.39
date	2014.06.01.15.54.28;	author jsing;	state Exp;
branches;
next	1.38;
commitid	Y07a8cEc6mV4tiSf;

1.38
date	2014.06.01.01.57.09;	author jsing;	state Exp;
branches;
next	1.37;
commitid	G73IixtigH0AoAJs;

1.37
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2014.05.30.14.01.11;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2014.05.29.11.28.18;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2014.05.28.14.05.35;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.28.13.29.18;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2014.05.28.13.03.25;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.25.16.23.10;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.25.13.27.38;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.24.15.17.06;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2014.05.20.16.59.05;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.28.20.10.55;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.20.12.48.19;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.19.18.02.36;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.18.21.19.20;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.17.13.37.50;	author beck;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.15.19.42.56;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.14.13.30.33;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2014.02.27.21.04.57;	author jca;	state Exp;
branches;
next	1.17;

1.17
date	2013.02.14.15.11.44;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.06.12.17.54;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.29.05.39.32;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.03.42;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.42;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.35;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.31;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.14;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.14;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.44;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.43;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.48;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.29;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2011.11.03.02.32.21;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2012.10.13.21.23.50;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;


desc
@@


1.86
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: t1_enc.c,v 1.85 2016/04/28 16:39:45 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/evp.h>
#include <openssl/hmac.h>
#include <openssl/md5.h>

void
tls1_cleanup_key_block(SSL *s)
{
	if (s->s3->tmp.key_block != NULL) {
		explicit_bzero(s->s3->tmp.key_block,
		    s->s3->tmp.key_block_length);
		free(s->s3->tmp.key_block);
		s->s3->tmp.key_block = NULL;
	}
	s->s3->tmp.key_block_length = 0;
}

int
tls1_init_finished_mac(SSL *s)
{
	BIO_free(s->s3->handshake_buffer);
	tls1_free_digest_list(s);

	s->s3->handshake_buffer = BIO_new(BIO_s_mem());
	if (s->s3->handshake_buffer == NULL)
		return (0);

	(void)BIO_set_close(s->s3->handshake_buffer, BIO_CLOSE);

	return (1);
}

void
tls1_free_digest_list(SSL *s)
{
	int i;

	if (s == NULL)
		return;

	if (s->s3->handshake_dgst == NULL)
		return;
	for (i = 0; i < SSL_MAX_DIGEST; i++) {
		if (s->s3->handshake_dgst[i])
			EVP_MD_CTX_destroy(s->s3->handshake_dgst[i]);
	}
	free(s->s3->handshake_dgst);
	s->s3->handshake_dgst = NULL;
}

void
tls1_finish_mac(SSL *s, const unsigned char *buf, int len)
{
	if (s->s3->handshake_buffer &&
	    !(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) {
		BIO_write(s->s3->handshake_buffer, (void *)buf, len);
	} else {
		int i;
		for (i = 0; i < SSL_MAX_DIGEST; i++) {
			if (s->s3->handshake_dgst[i]!= NULL)
				EVP_DigestUpdate(s->s3->handshake_dgst[i], buf, len);
		}
	}
}

int
tls1_digest_cached_records(SSL *s)
{
	int i;
	long mask;
	const EVP_MD *md;
	long hdatalen;
	void *hdata;

	tls1_free_digest_list(s);

	s->s3->handshake_dgst = calloc(SSL_MAX_DIGEST, sizeof(EVP_MD_CTX *));
	if (s->s3->handshake_dgst == NULL) {
		SSLerr(SSL_F_SSL3_DIGEST_CACHED_RECORDS, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
	if (hdatalen <= 0) {
		SSLerr(SSL_F_SSL3_DIGEST_CACHED_RECORDS,
		    SSL_R_BAD_HANDSHAKE_LENGTH);
		return 0;
	}

	/* Loop through bits of the algorithm2 field and create MD contexts. */
	for (i = 0; ssl_get_handshake_digest(i, &mask, &md); i++) {
		if ((mask & ssl_get_algorithm2(s)) && md) {
			s->s3->handshake_dgst[i] = EVP_MD_CTX_create();
			if (s->s3->handshake_dgst[i] == NULL) {
				SSLerr(SSL_F_SSL3_DIGEST_CACHED_RECORDS,
				    ERR_R_MALLOC_FAILURE);
				return 0;
			}
			if (!EVP_DigestInit_ex(s->s3->handshake_dgst[i],
			    md, NULL)) {
				EVP_MD_CTX_destroy(s->s3->handshake_dgst[i]);
				return 0;
			}
			if (!EVP_DigestUpdate(s->s3->handshake_dgst[i], hdata,
			    hdatalen))
				return 0;
		}
	}

	if (!(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) {
		BIO_free(s->s3->handshake_buffer);
		s->s3->handshake_buffer = NULL;
	}

	return 1;
}

void
tls1_record_sequence_increment(unsigned char *seq)
{
	int i;

	for (i = SSL3_SEQUENCE_SIZE - 1; i >= 0; i--) {
		if (++seq[i] != 0)
			break;
	}
}

/* seed1 through seed5 are virtually concatenated */
static int
tls1_P_hash(const EVP_MD *md, const unsigned char *sec, int sec_len,
    const void *seed1, int seed1_len, const void *seed2, int seed2_len,
    const void *seed3, int seed3_len, const void *seed4, int seed4_len,
    const void *seed5, int seed5_len, unsigned char *out, int olen)
{
	int chunk;
	size_t j;
	EVP_MD_CTX ctx, ctx_tmp;
	EVP_PKEY *mac_key;
	unsigned char A1[EVP_MAX_MD_SIZE];
	size_t A1_len;
	int ret = 0;

	chunk = EVP_MD_size(md);
	OPENSSL_assert(chunk >= 0);

	EVP_MD_CTX_init(&ctx);
	EVP_MD_CTX_init(&ctx_tmp);
	mac_key = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, sec, sec_len);
	if (!mac_key)
		goto err;
	if (!EVP_DigestSignInit(&ctx, NULL, md, NULL, mac_key))
		goto err;
	if (!EVP_DigestSignInit(&ctx_tmp, NULL, md, NULL, mac_key))
		goto err;
	if (seed1 && !EVP_DigestSignUpdate(&ctx, seed1, seed1_len))
		goto err;
	if (seed2 && !EVP_DigestSignUpdate(&ctx, seed2, seed2_len))
		goto err;
	if (seed3 && !EVP_DigestSignUpdate(&ctx, seed3, seed3_len))
		goto err;
	if (seed4 && !EVP_DigestSignUpdate(&ctx, seed4, seed4_len))
		goto err;
	if (seed5 && !EVP_DigestSignUpdate(&ctx, seed5, seed5_len))
		goto err;
	if (!EVP_DigestSignFinal(&ctx, A1, &A1_len))
		goto err;

	for (;;) {
		/* Reinit mac contexts */
		if (!EVP_DigestSignInit(&ctx, NULL, md, NULL, mac_key))
			goto err;
		if (!EVP_DigestSignInit(&ctx_tmp, NULL, md, NULL, mac_key))
			goto err;
		if (!EVP_DigestSignUpdate(&ctx, A1, A1_len))
			goto err;
		if (!EVP_DigestSignUpdate(&ctx_tmp, A1, A1_len))
			goto err;
		if (seed1 && !EVP_DigestSignUpdate(&ctx, seed1, seed1_len))
			goto err;
		if (seed2 && !EVP_DigestSignUpdate(&ctx, seed2, seed2_len))
			goto err;
		if (seed3 && !EVP_DigestSignUpdate(&ctx, seed3, seed3_len))
			goto err;
		if (seed4 && !EVP_DigestSignUpdate(&ctx, seed4, seed4_len))
			goto err;
		if (seed5 && !EVP_DigestSignUpdate(&ctx, seed5, seed5_len))
			goto err;

		if (olen > chunk) {
			if (!EVP_DigestSignFinal(&ctx, out, &j))
				goto err;
			out += j;
			olen -= j;
			/* calc the next A1 value */
			if (!EVP_DigestSignFinal(&ctx_tmp, A1, &A1_len))
				goto err;
		} else {
			/* last one */
			if (!EVP_DigestSignFinal(&ctx, A1, &A1_len))
				goto err;
			memcpy(out, A1, olen);
			break;
		}
	}
	ret = 1;

err:
	EVP_PKEY_free(mac_key);
	EVP_MD_CTX_cleanup(&ctx);
	EVP_MD_CTX_cleanup(&ctx_tmp);
	explicit_bzero(A1, sizeof(A1));
	return ret;
}

/* seed1 through seed5 are virtually concatenated */
static int
tls1_PRF(long digest_mask, const void *seed1, int seed1_len, const void *seed2,
    int seed2_len, const void *seed3, int seed3_len, const void *seed4,
    int seed4_len, const void *seed5, int seed5_len, const unsigned char *sec,
    int slen, unsigned char *out1, unsigned char *out2, int olen)
{
	int len, i, idx, count;
	const unsigned char *S1;
	long m;
	const EVP_MD *md;
	int ret = 0;

	/* Count number of digests and partition sec evenly */
	count = 0;
	for (idx = 0; ssl_get_handshake_digest(idx, &m, &md); idx++) {
		if ((m << TLS1_PRF_DGST_SHIFT) & digest_mask)
			count++;
	}
	if (count == 0) {
		SSLerr(SSL_F_TLS1_PRF,
		    SSL_R_SSL_HANDSHAKE_FAILURE);
		goto err;
	}
	len = slen / count;
	if (count == 1)
		slen = 0;
	S1 = sec;
	memset(out1, 0, olen);
	for (idx = 0; ssl_get_handshake_digest(idx, &m, &md); idx++) {
		if ((m << TLS1_PRF_DGST_SHIFT) & digest_mask) {
			if (!md) {
				SSLerr(SSL_F_TLS1_PRF,
				    SSL_R_UNSUPPORTED_DIGEST_TYPE);
				goto err;
			}
			if (!tls1_P_hash(md , S1, len + (slen&1), seed1,
			    seed1_len, seed2, seed2_len, seed3, seed3_len,
			    seed4, seed4_len, seed5, seed5_len, out2, olen))
				goto err;
			S1 += len;
			for (i = 0; i < olen; i++) {
				out1[i] ^= out2[i];
			}
		}
	}
	ret = 1;

err:
	return ret;
}

static int
tls1_generate_key_block(SSL *s, unsigned char *km, unsigned char *tmp, int num)
{
	int ret;

	ret = tls1_PRF(ssl_get_algorithm2(s),
	    TLS_MD_KEY_EXPANSION_CONST, TLS_MD_KEY_EXPANSION_CONST_SIZE,
	    s->s3->server_random, SSL3_RANDOM_SIZE,
	    s->s3->client_random, SSL3_RANDOM_SIZE,
	    NULL, 0, NULL, 0,
	    s->session->master_key, s->session->master_key_length,
	    km, tmp, num);
	return ret;
}

/*
 * tls1_aead_ctx_init allocates aead_ctx, if needed. It returns 1 on success
 * and 0 on failure.
 */
static int
tls1_aead_ctx_init(SSL_AEAD_CTX **aead_ctx)
{
	if (*aead_ctx != NULL) {
		EVP_AEAD_CTX_cleanup(&(*aead_ctx)->ctx);
		return (1);
	}

	*aead_ctx = malloc(sizeof(SSL_AEAD_CTX));
	if (*aead_ctx == NULL) {
		SSLerr(SSL_F_TLS1_AEAD_CTX_INIT, ERR_R_MALLOC_FAILURE);
		return (0);
	}

	return (1);
}

static int
tls1_change_cipher_state_aead(SSL *s, char is_read, const unsigned char *key,
    unsigned key_len, const unsigned char *iv, unsigned iv_len)
{
	const EVP_AEAD *aead = s->s3->tmp.new_aead;
	SSL_AEAD_CTX *aead_ctx;

	if (is_read) {
		if (!tls1_aead_ctx_init(&s->aead_read_ctx))
			return 0;
		aead_ctx = s->aead_read_ctx;
	} else {
		if (!tls1_aead_ctx_init(&s->aead_write_ctx))
			return 0;
		aead_ctx = s->aead_write_ctx;
	}

	if (!EVP_AEAD_CTX_init(&aead_ctx->ctx, aead, key, key_len,
	    EVP_AEAD_DEFAULT_TAG_LENGTH, NULL))
		return (0);
	if (iv_len > sizeof(aead_ctx->fixed_nonce)) {
		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE_AEAD,
		    ERR_R_INTERNAL_ERROR);
		return (0);
	}
	memcpy(aead_ctx->fixed_nonce, iv, iv_len);
	aead_ctx->fixed_nonce_len = iv_len;
	aead_ctx->variable_nonce_len = 8;  /* always the case, currently. */
	aead_ctx->variable_nonce_in_record =
	    (s->s3->tmp.new_cipher->algorithm2 &
	    SSL_CIPHER_ALGORITHM2_VARIABLE_NONCE_IN_RECORD) != 0;
	aead_ctx->xor_fixed_nonce =
	    s->s3->tmp.new_cipher->algorithm_enc == SSL_CHACHA20POLY1305;
	aead_ctx->tag_len = EVP_AEAD_max_overhead(aead);

	if (aead_ctx->xor_fixed_nonce) {
		if (aead_ctx->fixed_nonce_len != EVP_AEAD_nonce_length(aead) ||
		    aead_ctx->variable_nonce_len > EVP_AEAD_nonce_length(aead)) {
			SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE_AEAD,
			    ERR_R_INTERNAL_ERROR);
			return (0);
		}
	} else {
		if (aead_ctx->variable_nonce_len + aead_ctx->fixed_nonce_len !=
		    EVP_AEAD_nonce_length(aead)) {
			SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE_AEAD,
			    ERR_R_INTERNAL_ERROR);
			return (0);
		}
	}

	return (1);
}

/*
 * tls1_change_cipher_state_cipher performs the work needed to switch cipher
 * states when using EVP_CIPHER. The argument is_read is true iff this function
 * is being called due to reading, as opposed to writing, a ChangeCipherSpec
 * message. In order to support export ciphersuites, use_client_keys indicates
 * whether the key material provided is in the "client write" direction.
 */
static int
tls1_change_cipher_state_cipher(SSL *s, char is_read, char use_client_keys,
    const unsigned char *mac_secret, unsigned int mac_secret_size,
    const unsigned char *key, unsigned int key_len, const unsigned char *iv,
    unsigned int iv_len)
{
	EVP_CIPHER_CTX *cipher_ctx;
	const EVP_CIPHER *cipher;
	EVP_MD_CTX *mac_ctx;
	const EVP_MD *mac;
	int mac_type;

	cipher = s->s3->tmp.new_sym_enc;
	mac = s->s3->tmp.new_hash;
	mac_type = s->s3->tmp.new_mac_pkey_type;

	if (is_read) {
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
			s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;
		else
			s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;

		EVP_CIPHER_CTX_free(s->enc_read_ctx);
		s->enc_read_ctx = NULL;
		EVP_MD_CTX_destroy(s->read_hash);
		s->read_hash = NULL;

		if ((cipher_ctx = EVP_CIPHER_CTX_new()) == NULL)
			goto err;
		s->enc_read_ctx = cipher_ctx;
		if ((mac_ctx = EVP_MD_CTX_create()) == NULL)
			goto err;
		s->read_hash = mac_ctx;
	} else {
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
			s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;
		else
			s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;

		/*
		 * DTLS fragments retain a pointer to the compression, cipher
		 * and hash contexts, so that it can restore state in order
		 * to perform retransmissions. As such, we cannot free write
		 * contexts that are used for DTLS - these are instead freed
		 * by DTLS when its frees a ChangeCipherSpec fragment.
		 */
		if (!SSL_IS_DTLS(s)) {
			EVP_CIPHER_CTX_free(s->enc_write_ctx);
			s->enc_write_ctx = NULL;
			EVP_MD_CTX_destroy(s->write_hash);
			s->write_hash = NULL;
		}
		if ((cipher_ctx = EVP_CIPHER_CTX_new()) == NULL)
			goto err;
		s->enc_write_ctx = cipher_ctx;
		if ((mac_ctx = EVP_MD_CTX_create()) == NULL)
			goto err;
		s->write_hash = mac_ctx;
	}

	if (EVP_CIPHER_mode(cipher) == EVP_CIPH_GCM_MODE) {
		EVP_CipherInit_ex(cipher_ctx, cipher, NULL, key, NULL,
		    !is_read);
		EVP_CIPHER_CTX_ctrl(cipher_ctx, EVP_CTRL_GCM_SET_IV_FIXED,
		    iv_len, (unsigned char *)iv);
	} else
		EVP_CipherInit_ex(cipher_ctx, cipher, NULL, key, iv, !is_read);

	if (!(EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER)) {
		EVP_PKEY *mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
		    mac_secret, mac_secret_size);
		if (mac_key == NULL)
			goto err;
		EVP_DigestSignInit(mac_ctx, NULL, mac, NULL, mac_key);
		EVP_PKEY_free(mac_key);
	} else if (mac_secret_size > 0) {
		/* Needed for "composite" AEADs, such as RC4-HMAC-MD5 */
		EVP_CIPHER_CTX_ctrl(cipher_ctx, EVP_CTRL_AEAD_SET_MAC_KEY,
		    mac_secret_size, (unsigned char *)mac_secret);
	}

	if (s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT) {
		int nid;
		if (s->s3->tmp.new_cipher->algorithm2 & SSL_HANDSHAKE_MAC_GOST94)
			nid = NID_id_Gost28147_89_CryptoPro_A_ParamSet;
		else
			nid = NID_id_tc26_gost_28147_param_Z;

		EVP_CIPHER_CTX_ctrl(cipher_ctx, EVP_CTRL_GOST_SET_SBOX, nid, 0);
		if (s->s3->tmp.new_cipher->algorithm_mac == SSL_GOST89MAC)
			EVP_MD_CTX_ctrl(mac_ctx, EVP_MD_CTRL_GOST_SET_SBOX, nid, 0);
	}

	return (1);

err:
	SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE_CIPHER, ERR_R_MALLOC_FAILURE);
	return (0);
}

int
tls1_change_cipher_state(SSL *s, int which)
{
	const unsigned char *client_write_mac_secret, *server_write_mac_secret;
	const unsigned char *client_write_key, *server_write_key;
	const unsigned char *client_write_iv, *server_write_iv;
	const unsigned char *mac_secret, *key, *iv;
	int mac_secret_size, key_len, iv_len;
	unsigned char *key_block, *seq;
	const EVP_CIPHER *cipher;
	const EVP_AEAD *aead;
	char is_read, use_client_keys;


	cipher = s->s3->tmp.new_sym_enc;
	aead = s->s3->tmp.new_aead;

	/*
	 * is_read is true if we have just read a ChangeCipherSpec message,
	 * that is we need to update the read cipherspec. Otherwise we have
	 * just written one.
	 */
	is_read = (which & SSL3_CC_READ) != 0;

	/*
	 * use_client_keys is true if we wish to use the keys for the "client
	 * write" direction. This is the case if we're a client sending a
	 * ChangeCipherSpec, or a server reading a client's ChangeCipherSpec.
	 */
	use_client_keys = ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
	    (which == SSL3_CHANGE_CIPHER_SERVER_READ));


	/*
	 * Reset sequence number to zero - for DTLS this is handled in
	 * dtls1_reset_seq_numbers().
	 */
	if (!SSL_IS_DTLS(s)) {
		seq = is_read ? s->s3->read_sequence : s->s3->write_sequence;
		memset(seq, 0, SSL3_SEQUENCE_SIZE);
	}

	if (aead != NULL) {
		key_len = EVP_AEAD_key_length(aead);
		iv_len = SSL_CIPHER_AEAD_FIXED_NONCE_LEN(s->s3->tmp.new_cipher);
	} else {
		key_len = EVP_CIPHER_key_length(cipher);
		iv_len = EVP_CIPHER_iv_length(cipher);

		/* If GCM mode only part of IV comes from PRF. */
		if (EVP_CIPHER_mode(cipher) == EVP_CIPH_GCM_MODE)
			iv_len = EVP_GCM_TLS_FIXED_IV_LEN;
	}

	mac_secret_size = s->s3->tmp.new_mac_secret_size;

	key_block = s->s3->tmp.key_block;
	client_write_mac_secret = key_block;
	key_block += mac_secret_size;
	server_write_mac_secret = key_block;
	key_block += mac_secret_size;
	client_write_key = key_block;
	key_block += key_len;
	server_write_key = key_block;
	key_block += key_len;
	client_write_iv = key_block;
	key_block += iv_len;
	server_write_iv = key_block;
	key_block += iv_len;

	if (use_client_keys) {
		mac_secret = client_write_mac_secret;
		key = client_write_key;
		iv = client_write_iv;
	} else {
		mac_secret = server_write_mac_secret;
		key = server_write_key;
		iv = server_write_iv;
	}

	if (key_block - s->s3->tmp.key_block != s->s3->tmp.key_block_length) {
		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);
		goto err2;
	}

	if (is_read) {
		memcpy(s->s3->read_mac_secret, mac_secret, mac_secret_size);
		s->s3->read_mac_secret_size = mac_secret_size;
	} else {
		memcpy(s->s3->write_mac_secret, mac_secret, mac_secret_size);
		s->s3->write_mac_secret_size = mac_secret_size;
	}

	if (aead != NULL) {
		return tls1_change_cipher_state_aead(s, is_read, key, key_len,
		    iv, iv_len);
	}

	return tls1_change_cipher_state_cipher(s, is_read, use_client_keys,
	    mac_secret, mac_secret_size, key, key_len, iv, iv_len);

err2:
	return (0);
}

int
tls1_setup_key_block(SSL *s)
{
	unsigned char *key_block, *tmp_block = NULL;
	int mac_type = NID_undef, mac_secret_size = 0;
	int key_block_len, key_len, iv_len;
	const EVP_CIPHER *cipher = NULL;
	const EVP_AEAD *aead = NULL;
	const EVP_MD *mac = NULL;
	int ret = 0;

	if (s->s3->tmp.key_block_length != 0)
		return (1);

	if (s->session->cipher &&
	    (s->session->cipher->algorithm2 & SSL_CIPHER_ALGORITHM2_AEAD)) {
		if (!ssl_cipher_get_evp_aead(s->session, &aead)) {
			SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,
			    SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
			return (0);
		}
		key_len = EVP_AEAD_key_length(aead);
		iv_len = SSL_CIPHER_AEAD_FIXED_NONCE_LEN(s->session->cipher);
	} else {
		if (!ssl_cipher_get_evp(s->session, &cipher, &mac, &mac_type,
		    &mac_secret_size)) {
			SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,
			    SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
			return (0);
		}
		key_len = EVP_CIPHER_key_length(cipher);
		iv_len = EVP_CIPHER_iv_length(cipher);

		/* If GCM mode only part of IV comes from PRF. */
		if (EVP_CIPHER_mode(cipher) == EVP_CIPH_GCM_MODE)
			iv_len = EVP_GCM_TLS_FIXED_IV_LEN;
	}

	s->s3->tmp.new_aead = aead;
	s->s3->tmp.new_sym_enc = cipher;
	s->s3->tmp.new_hash = mac;
	s->s3->tmp.new_mac_pkey_type = mac_type;
	s->s3->tmp.new_mac_secret_size = mac_secret_size;

	tls1_cleanup_key_block(s);

	if ((key_block = reallocarray(NULL, mac_secret_size + key_len + iv_len,
	    2)) == NULL) {
		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE);
		goto err;
	}
	key_block_len = (mac_secret_size + key_len + iv_len) * 2;

	s->s3->tmp.key_block_length = key_block_len;
	s->s3->tmp.key_block = key_block;

	if ((tmp_block = malloc(key_block_len)) == NULL) {
		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE);
		goto err;
	}

	if (!tls1_generate_key_block(s, key_block, tmp_block, key_block_len))
		goto err;

	if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS) &&
	    s->method->version <= TLS1_VERSION) {
		/*
		 * Enable vulnerability countermeasure for CBC ciphers with
		 * known-IV problem (http://www.openssl.org/~bodo/tls-cbc.txt)
		 */
		s->s3->need_empty_fragments = 1;

		if (s->session->cipher != NULL) {
			if (s->session->cipher->algorithm_enc == SSL_eNULL)
				s->s3->need_empty_fragments = 0;

#ifndef OPENSSL_NO_RC4
			if (s->session->cipher->algorithm_enc == SSL_RC4)
				s->s3->need_empty_fragments = 0;
#endif
		}
	}

	ret = 1;

err:
	if (tmp_block) {
		explicit_bzero(tmp_block, key_block_len);
		free(tmp_block);
	}
	return (ret);
}

/* tls1_enc encrypts/decrypts the record in |s->wrec| / |s->rrec|, respectively.
 *
 * Returns:
 *   0: (in non-constant time) if the record is publically invalid (i.e. too
 *       short etc).
 *   1: if the record's padding is valid / the encryption was successful.
 *   -1: if the record's padding/AEAD-authenticator is invalid or, if sending,
 *       an internal error occured.
 */
int
tls1_enc(SSL *s, int send)
{
	const SSL_AEAD_CTX *aead;
	const EVP_CIPHER *enc;
	EVP_CIPHER_CTX *ds;
	SSL3_RECORD *rec;
	unsigned char *seq;
	unsigned long l;
	int bs, i, j, k, pad = 0, ret, mac_size = 0;

	if (send) {
		aead = s->aead_write_ctx;
		rec = &s->s3->wrec;
		seq = s->s3->write_sequence;
	} else {
		aead = s->aead_read_ctx;
		rec = &s->s3->rrec;
		seq = s->s3->read_sequence;
	}

	if (aead) {
		unsigned char ad[13], *in, *out, nonce[16];
		size_t out_len, pad_len = 0;
		unsigned int nonce_used;

		if (SSL_IS_DTLS(s)) {
			dtls1_build_sequence_number(ad, seq,
			    send ? s->d1->w_epoch : s->d1->r_epoch);
		} else {
			memcpy(ad, seq, SSL3_SEQUENCE_SIZE);
			tls1_record_sequence_increment(seq);
		}

		ad[8] = rec->type;
		ad[9] = (unsigned char)(s->version >> 8);
		ad[10] = (unsigned char)(s->version);

		if (aead->variable_nonce_len > 8 ||
		    aead->variable_nonce_len > sizeof(nonce))
			return -1;

		if (aead->xor_fixed_nonce) {
			if (aead->fixed_nonce_len > sizeof(nonce) ||
			    aead->variable_nonce_len > aead->fixed_nonce_len)
				return -1;  /* Should never happen. */
			pad_len = aead->fixed_nonce_len - aead->variable_nonce_len;
		} else {
			if (aead->fixed_nonce_len +
			    aead->variable_nonce_len > sizeof(nonce))
				return -1;  /* Should never happen. */
		}

		if (send) {
			size_t len = rec->length;
			size_t eivlen = 0;
			in = rec->input;
			out = rec->data;

			if (aead->xor_fixed_nonce) {
				/*
				 * The sequence number is left zero
				 * padded, then xored with the fixed
				 * nonce.
				 */
				memset(nonce, 0, pad_len);
				memcpy(nonce + pad_len, ad,
				    aead->variable_nonce_len);
				for (i = 0; i < aead->fixed_nonce_len; i++)
					nonce[i] ^= aead->fixed_nonce[i];
				nonce_used = aead->fixed_nonce_len;
			} else {
				/*
				 * When sending we use the sequence number as
				 * the variable part of the nonce.
				 */
				memcpy(nonce, aead->fixed_nonce,
				    aead->fixed_nonce_len);
				nonce_used = aead->fixed_nonce_len;
				memcpy(nonce + nonce_used, ad,
				    aead->variable_nonce_len);
				nonce_used += aead->variable_nonce_len;
			}

			/*
			 * In do_ssl3_write, rec->input is moved forward by
			 * variable_nonce_len in order to leave space for the
			 * variable nonce. Thus we can copy the sequence number
			 * bytes into place without overwriting any of the
			 * plaintext.
			 */
			if (aead->variable_nonce_in_record) {
				memcpy(out, ad, aead->variable_nonce_len);
				len -= aead->variable_nonce_len;
				eivlen = aead->variable_nonce_len;
			}

			ad[11] = len >> 8;
			ad[12] = len & 0xff;

			if (!EVP_AEAD_CTX_seal(&aead->ctx,
			    out + eivlen, &out_len, len + aead->tag_len, nonce,
			    nonce_used, in + eivlen, len, ad, sizeof(ad)))
				return -1;
			if (aead->variable_nonce_in_record)
				out_len += aead->variable_nonce_len;
		} else {
			/* receive */
			size_t len = rec->length;

			if (rec->data != rec->input)
				return -1;  /* internal error - should never happen. */
			out = in = rec->input;

			if (len < aead->variable_nonce_len)
				return 0;

			if (aead->xor_fixed_nonce) {
				/*
				 * The sequence number is left zero
				 * padded, then xored with the fixed
				 * nonce.
				 */
				memset(nonce, 0, pad_len);
				memcpy(nonce + pad_len, ad,
				    aead->variable_nonce_len);
				for (i = 0; i < aead->fixed_nonce_len; i++)
					nonce[i] ^= aead->fixed_nonce[i];
				nonce_used = aead->fixed_nonce_len;
			} else {
				memcpy(nonce, aead->fixed_nonce,
				    aead->fixed_nonce_len);
				nonce_used = aead->fixed_nonce_len;

				memcpy(nonce + nonce_used,
				    aead->variable_nonce_in_record ? in : ad,
				    aead->variable_nonce_len);
				nonce_used += aead->variable_nonce_len;
			}

			if (aead->variable_nonce_in_record) {
				in += aead->variable_nonce_len;
				len -= aead->variable_nonce_len;
				out += aead->variable_nonce_len;
			}

			if (len < aead->tag_len)
				return 0;
			len -= aead->tag_len;

			ad[11] = len >> 8;
			ad[12] = len & 0xff;

			if (!EVP_AEAD_CTX_open(&aead->ctx, out, &out_len, len,
			    nonce, nonce_used, in, len + aead->tag_len, ad,
			    sizeof(ad)))
				return -1;

			rec->data = rec->input = out;
		}

		rec->length = out_len;

		return 1;
	}

	if (send) {
		if (EVP_MD_CTX_md(s->write_hash)) {
			int n = EVP_MD_CTX_size(s->write_hash);
			OPENSSL_assert(n >= 0);
		}
		ds = s->enc_write_ctx;
		if (s->enc_write_ctx == NULL)
			enc = NULL;
		else {
			int ivlen = 0;
			enc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx);
			if (SSL_USE_EXPLICIT_IV(s) &&
			    EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)
				ivlen = EVP_CIPHER_iv_length(enc);
			if (ivlen > 1) {
				if (rec->data != rec->input) {
#ifdef DEBUG
					/* we can't write into the input stream:
					 * Can this ever happen?? (steve)
					 */
					fprintf(stderr,
					    "%s:%d: rec->data != rec->input\n",
					    __FILE__, __LINE__);
#endif
				} else
					arc4random_buf(rec->input, ivlen);
			}
		}
	} else {
		if (EVP_MD_CTX_md(s->read_hash)) {
			int n = EVP_MD_CTX_size(s->read_hash);
			OPENSSL_assert(n >= 0);
		}
		ds = s->enc_read_ctx;
		if (s->enc_read_ctx == NULL)
			enc = NULL;
		else
			enc = EVP_CIPHER_CTX_cipher(s->enc_read_ctx);
	}

	if ((s->session == NULL) || (ds == NULL) || (enc == NULL)) {
		memmove(rec->data, rec->input, rec->length);
		rec->input = rec->data;
		ret = 1;
	} else {
		l = rec->length;
		bs = EVP_CIPHER_block_size(ds->cipher);

		if (EVP_CIPHER_flags(ds->cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) {
			unsigned char buf[13];

			if (SSL_IS_DTLS(s)) {
				dtls1_build_sequence_number(buf, seq,
				    send ? s->d1->w_epoch : s->d1->r_epoch);
			} else {
				memcpy(buf, seq, SSL3_SEQUENCE_SIZE);
				tls1_record_sequence_increment(seq);
			}

			buf[8] = rec->type;
			buf[9] = (unsigned char)(s->version >> 8);
			buf[10] = (unsigned char)(s->version);
			buf[11] = rec->length >> 8;
			buf[12] = rec->length & 0xff;
			pad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD, 13, buf);
			if (send) {
				l += pad;
				rec->length += pad;
			}
		} else if ((bs != 1) && send) {
			i = bs - ((int)l % bs);

			/* Add weird padding of upto 256 bytes */

			/* we need to add 'i' padding bytes of value j */
			j = i - 1;
			for (k = (int)l; k < (int)(l + i); k++)
				rec->input[k] = j;
			l += i;
			rec->length += i;
		}

		if (!send) {
			if (l == 0 || l % bs != 0)
				return 0;
		}

		i = EVP_Cipher(ds, rec->data, rec->input, l);
		if ((EVP_CIPHER_flags(ds->cipher) &
		    EVP_CIPH_FLAG_CUSTOM_CIPHER) ? (i < 0) : (i == 0))
			return -1;	/* AEAD can fail to verify MAC */
		if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE && !send) {
			rec->data += EVP_GCM_TLS_EXPLICIT_IV_LEN;
			rec->input += EVP_GCM_TLS_EXPLICIT_IV_LEN;
			rec->length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
		}

		ret = 1;
		if (EVP_MD_CTX_md(s->read_hash) != NULL)
			mac_size = EVP_MD_CTX_size(s->read_hash);
		if ((bs != 1) && !send)
			ret = tls1_cbc_remove_padding(s, rec, bs, mac_size);
		if (pad && !send)
			rec->length -= pad;
	}
	return ret;
}

int
tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *out)
{
	EVP_MD_CTX ctx, *d = NULL;
	unsigned int ret;
	int i;

	if (s->s3->handshake_buffer)
		if (!tls1_digest_cached_records(s))
			return 0;

	for (i = 0; i < SSL_MAX_DIGEST; i++) {
		if (s->s3->handshake_dgst[i] &&
		    EVP_MD_CTX_type(s->s3->handshake_dgst[i]) == md_nid) {
			d = s->s3->handshake_dgst[i];
			break;
		}
	}
	if (d == NULL) {
		SSLerr(SSL_F_TLS1_CERT_VERIFY_MAC, SSL_R_NO_REQUIRED_DIGEST);
		return 0;
	}

	EVP_MD_CTX_init(&ctx);
	if (!EVP_MD_CTX_copy_ex(&ctx, d))
		return 0;
	EVP_DigestFinal_ex(&ctx, out, &ret);
	EVP_MD_CTX_cleanup(&ctx);

	return ((int)ret);
}

int
tls1_final_finish_mac(SSL *s, const char *str, int slen, unsigned char *out)
{
	unsigned int i;
	EVP_MD_CTX ctx;
	unsigned char buf[2*EVP_MAX_MD_SIZE];
	unsigned char *q, buf2[12];
	int idx;
	long mask;
	int err = 0;
	const EVP_MD *md;

	q = buf;

	if (s->s3->handshake_buffer)
		if (!tls1_digest_cached_records(s))
			return 0;

	EVP_MD_CTX_init(&ctx);

	for (idx = 0; ssl_get_handshake_digest(idx, &mask, &md); idx++) {
		if (ssl_get_algorithm2(s) & mask) {
			int hashsize = EVP_MD_size(md);
			EVP_MD_CTX *hdgst = s->s3->handshake_dgst[idx];
			if (!hdgst || hashsize < 0 ||
			    hashsize > (int)(sizeof buf - (size_t)(q - buf))) {
				/* internal error: 'buf' is too small for this cipersuite! */
				err = 1;
			} else {
				if (!EVP_MD_CTX_copy_ex(&ctx, hdgst) ||
				    !EVP_DigestFinal_ex(&ctx, q, &i) ||
				    (i != (unsigned int)hashsize))
					err = 1;
				q += hashsize;
			}
		}
	}

	if (!tls1_PRF(ssl_get_algorithm2(s), str, slen, buf, (int)(q - buf),
	    NULL, 0, NULL, 0, NULL, 0,
	    s->session->master_key, s->session->master_key_length,
	    out, buf2, sizeof buf2))
		err = 1;
	EVP_MD_CTX_cleanup(&ctx);

	if (err)
		return 0;
	else
		return sizeof buf2;
}

int
tls1_mac(SSL *ssl, unsigned char *md, int send)
{
	SSL3_RECORD *rec;
	unsigned char *seq;
	EVP_MD_CTX *hash;
	size_t md_size, orig_len;
	EVP_MD_CTX hmac, *mac_ctx;
	unsigned char header[13];
	int stream_mac = (send ?
	    (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM) :
	    (ssl->mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM));
	int t;

	if (send) {
		rec = &(ssl->s3->wrec);
		seq = &(ssl->s3->write_sequence[0]);
		hash = ssl->write_hash;
	} else {
		rec = &(ssl->s3->rrec);
		seq = &(ssl->s3->read_sequence[0]);
		hash = ssl->read_hash;
	}

	t = EVP_MD_CTX_size(hash);
	OPENSSL_assert(t >= 0);
	md_size = t;

	/* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */
	if (stream_mac) {
		mac_ctx = hash;
	} else {
		if (!EVP_MD_CTX_copy(&hmac, hash))
			return -1;
		mac_ctx = &hmac;
	}

	if (SSL_IS_DTLS(ssl))
		dtls1_build_sequence_number(header, seq,
		    send ? ssl->d1->w_epoch : ssl->d1->r_epoch);
	else
		memcpy(header, seq, SSL3_SEQUENCE_SIZE);

	/* kludge: tls1_cbc_remove_padding passes padding length in rec->type */
	orig_len = rec->length + md_size + ((unsigned int)rec->type >> 8);
	rec->type &= 0xff;

	header[8] = rec->type;
	header[9] = (unsigned char)(ssl->version >> 8);
	header[10] = (unsigned char)(ssl->version);
	header[11] = (rec->length) >> 8;
	header[12] = (rec->length) & 0xff;

	if (!send &&
	    EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
	    ssl3_cbc_record_digest_supported(mac_ctx)) {
		/* This is a CBC-encrypted record. We must avoid leaking any
		 * timing-side channel information about how many blocks of
		 * data we are hashing because that gives an attacker a
		 * timing-oracle. */
		if (!ssl3_cbc_digest_record(mac_ctx,
		    md, &md_size, header, rec->input,
		    rec->length + md_size, orig_len,
		    ssl->s3->read_mac_secret,
		    ssl->s3->read_mac_secret_size,
		    0 /* not SSLv3 */))
			return -1;
	} else {
		EVP_DigestSignUpdate(mac_ctx, header, sizeof(header));
		EVP_DigestSignUpdate(mac_ctx, rec->input, rec->length);
		t = EVP_DigestSignFinal(mac_ctx, md, &md_size);
		OPENSSL_assert(t > 0);
	}

	if (!stream_mac)
		EVP_MD_CTX_cleanup(&hmac);

	if (!SSL_IS_DTLS(ssl))
		tls1_record_sequence_increment(seq);

	return (md_size);
}

int
tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
    int len)
{
	unsigned char buff[SSL_MAX_MASTER_KEY_LENGTH];

	tls1_PRF(ssl_get_algorithm2(s),
	    TLS_MD_MASTER_SECRET_CONST, TLS_MD_MASTER_SECRET_CONST_SIZE,
	    s->s3->client_random, SSL3_RANDOM_SIZE, NULL, 0,
	    s->s3->server_random, SSL3_RANDOM_SIZE, NULL, 0,
	    p, len, s->session->master_key, buff, sizeof buff);

	return (SSL3_MASTER_SECRET_SIZE);
}

int
tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,
    const char *label, size_t llen, const unsigned char *context,
    size_t contextlen, int use_context)
{
	unsigned char *buff;
	unsigned char *val = NULL;
	size_t vallen, currentvalpos;
	int rv;

	buff = malloc(olen);
	if (buff == NULL)
		goto err2;

	/* construct PRF arguments
	 * we construct the PRF argument ourself rather than passing separate
	 * values into the TLS PRF to ensure that the concatenation of values
	 * does not create a prohibited label.
	 */
	vallen = llen + SSL3_RANDOM_SIZE * 2;
	if (use_context) {
		vallen += 2 + contextlen;
	}

	val = malloc(vallen);
	if (val == NULL)
		goto err2;
	currentvalpos = 0;
	memcpy(val + currentvalpos, (unsigned char *) label, llen);
	currentvalpos += llen;
	memcpy(val + currentvalpos, s->s3->client_random, SSL3_RANDOM_SIZE);
	currentvalpos += SSL3_RANDOM_SIZE;
	memcpy(val + currentvalpos, s->s3->server_random, SSL3_RANDOM_SIZE);
	currentvalpos += SSL3_RANDOM_SIZE;

	if (use_context) {
		val[currentvalpos] = (contextlen >> 8) & 0xff;
		currentvalpos++;
		val[currentvalpos] = contextlen & 0xff;
		currentvalpos++;
		if ((contextlen > 0) || (context != NULL)) {
			memcpy(val + currentvalpos, context, contextlen);
		}
	}

	/* disallow prohibited labels
	 * note that SSL3_RANDOM_SIZE > max(prohibited label len) =
	 * 15, so size of val > max(prohibited label len) = 15 and the
	 * comparisons won't have buffer overflow
	 */
	if (memcmp(val, TLS_MD_CLIENT_FINISH_CONST,
	    TLS_MD_CLIENT_FINISH_CONST_SIZE) == 0)
		goto err1;
	if (memcmp(val, TLS_MD_SERVER_FINISH_CONST,
	    TLS_MD_SERVER_FINISH_CONST_SIZE) == 0)
		goto err1;
	if (memcmp(val, TLS_MD_MASTER_SECRET_CONST,
	    TLS_MD_MASTER_SECRET_CONST_SIZE) == 0)
		goto err1;
	if (memcmp(val, TLS_MD_KEY_EXPANSION_CONST,
	    TLS_MD_KEY_EXPANSION_CONST_SIZE) == 0)
		goto err1;

	rv = tls1_PRF(ssl_get_algorithm2(s),
	    val, vallen, NULL, 0, NULL, 0, NULL, 0, NULL, 0,
	    s->session->master_key, s->session->master_key_length,
	    out, buff, olen);

	goto ret;
err1:
	SSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL,
	    SSL_R_TLS_ILLEGAL_EXPORTER_LABEL);
	rv = 0;
	goto ret;
err2:
	SSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL, ERR_R_MALLOC_FAILURE);
	rv = 0;
ret:
	free(buff);
	free(val);

	return (rv);
}

int
tls1_alert_code(int code)
{
	switch (code) {
	case SSL_AD_CLOSE_NOTIFY:
		return (SSL3_AD_CLOSE_NOTIFY);
	case SSL_AD_UNEXPECTED_MESSAGE:
		return (SSL3_AD_UNEXPECTED_MESSAGE);
	case SSL_AD_BAD_RECORD_MAC:
		return (SSL3_AD_BAD_RECORD_MAC);
	case SSL_AD_DECRYPTION_FAILED:
		return (TLS1_AD_DECRYPTION_FAILED);
	case SSL_AD_RECORD_OVERFLOW:
		return (TLS1_AD_RECORD_OVERFLOW);
	case SSL_AD_DECOMPRESSION_FAILURE:
		return (SSL3_AD_DECOMPRESSION_FAILURE);
	case SSL_AD_HANDSHAKE_FAILURE:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_NO_CERTIFICATE:
		return (-1);
	case SSL_AD_BAD_CERTIFICATE:
		return (SSL3_AD_BAD_CERTIFICATE);
	case SSL_AD_UNSUPPORTED_CERTIFICATE:
		return (SSL3_AD_UNSUPPORTED_CERTIFICATE);
	case SSL_AD_CERTIFICATE_REVOKED:
		return (SSL3_AD_CERTIFICATE_REVOKED);
	case SSL_AD_CERTIFICATE_EXPIRED:
		return (SSL3_AD_CERTIFICATE_EXPIRED);
	case SSL_AD_CERTIFICATE_UNKNOWN:
		return (SSL3_AD_CERTIFICATE_UNKNOWN);
	case SSL_AD_ILLEGAL_PARAMETER:
		return (SSL3_AD_ILLEGAL_PARAMETER);
	case SSL_AD_UNKNOWN_CA:
		return (TLS1_AD_UNKNOWN_CA);
	case SSL_AD_ACCESS_DENIED:
		return (TLS1_AD_ACCESS_DENIED);
	case SSL_AD_DECODE_ERROR:
		return (TLS1_AD_DECODE_ERROR);
	case SSL_AD_DECRYPT_ERROR:
		return (TLS1_AD_DECRYPT_ERROR);
	case SSL_AD_EXPORT_RESTRICTION:
		return (TLS1_AD_EXPORT_RESTRICTION);
	case SSL_AD_PROTOCOL_VERSION:
		return (TLS1_AD_PROTOCOL_VERSION);
	case SSL_AD_INSUFFICIENT_SECURITY:
		return (TLS1_AD_INSUFFICIENT_SECURITY);
	case SSL_AD_INTERNAL_ERROR:
		return (TLS1_AD_INTERNAL_ERROR);
	case SSL_AD_INAPPROPRIATE_FALLBACK:
		return(TLS1_AD_INAPPROPRIATE_FALLBACK);
	case SSL_AD_USER_CANCELLED:
		return (TLS1_AD_USER_CANCELLED);
	case SSL_AD_NO_RENEGOTIATION:
		return (TLS1_AD_NO_RENEGOTIATION);
	case SSL_AD_UNSUPPORTED_EXTENSION:
		return (TLS1_AD_UNSUPPORTED_EXTENSION);
	case SSL_AD_CERTIFICATE_UNOBTAINABLE:
		return (TLS1_AD_CERTIFICATE_UNOBTAINABLE);
	case SSL_AD_UNRECOGNIZED_NAME:
		return (TLS1_AD_UNRECOGNIZED_NAME);
	case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE:
		return (TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE);
	case SSL_AD_BAD_CERTIFICATE_HASH_VALUE:
		return (TLS1_AD_BAD_CERTIFICATE_HASH_VALUE);
	case SSL_AD_UNKNOWN_PSK_IDENTITY:
		return (TLS1_AD_UNKNOWN_PSK_IDENTITY);
	default:
		return (-1);
	}
}
@


1.85
log
@Implement the IETF ChaCha20-Poly1305 cipher suites.

Rename the existing ChaCha20-Poly1305 cipher suites with an "-OLD" suffix,
effectively replaces the original Google implementation. We continue to
support both the IETF and Google versions, however the existing names
now refer to the ciphers from draft-ietf-tls-chacha20-poly1305-04.

Feedback from doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.84 2016/03/06 14:52:15 beck Exp $ */
@


1.84
log
@Make sure stdio functions don't end up in the library, from miod@@
ok doug@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.83 2015/09/11 18:08:21 jsing Exp $ */
d474 18
a491 5
	if (aead_ctx->variable_nonce_len + aead_ctx->fixed_nonce_len !=
	    EVP_AEAD_nonce_length(aead)) {
		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE_AEAD,
		    ERR_R_INTERNAL_ERROR);
		return (0);
a492 1
	aead_ctx->tag_len = EVP_AEAD_max_overhead(aead);
d834 2
a835 2
		unsigned nonce_used;
		size_t out_len;
d849 14
a862 7
		if (aead->fixed_nonce_len +
		    aead->variable_nonce_len > sizeof(nonce) ||
		    aead->variable_nonce_len > 8)
			return -1;  /* internal error - should never happen. */

		memcpy(nonce, aead->fixed_nonce, aead->fixed_nonce_len);
		nonce_used = aead->fixed_nonce_len;
d870 24
a893 9
			/*
			 * When sending we use the sequence number as the
			 * variable part of the nonce.
			 */
			if (aead->variable_nonce_len > 8)
				return -1;
			memcpy(nonce + nonce_used, ad,
			    aead->variable_nonce_len);
			nonce_used += aead->variable_nonce_len;
d927 23
a949 4
			memcpy(nonce + nonce_used,
			    aead->variable_nonce_in_record ? in : ad,
			    aead->variable_nonce_len);
			nonce_used += aead->variable_nonce_len;
@


1.83
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.82 2015/09/11 17:54:23 jsing Exp $ */
d939 2
a940 1
				if (rec->data != rec->input)
d947 2
a948 1
				else
@


1.82
log
@Merge the remnants of s3_enc.c into t1_enc.c.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.81 2015/09/10 15:56:26 jsing Exp $ */
d147 1
a147 1
ssl3_cleanup_key_block(SSL *s)
d159 1
a159 1
ssl3_init_finished_mac(SSL *s)
d162 1
a162 1
	ssl3_free_digest_list(s);
d174 1
a174 1
ssl3_free_digest_list(SSL *s)
d192 1
a192 1
ssl3_finish_mac(SSL *s, const unsigned char *buf, int len)
d207 1
a207 1
ssl3_digest_cached_records(SSL *s)
d215 1
a215 1
	ssl3_free_digest_list(s);
d258 1
a258 1
ssl3_record_sequence_increment(unsigned char *seq)
d741 1
a741 1
	ssl3_cleanup_key_block(s);
d830 1
a830 1
			ssl3_record_sequence_increment(seq);
d978 1
a978 1
				ssl3_record_sequence_increment(seq);
d1038 1
a1038 1
		if (!ssl3_digest_cached_records(s))
d1077 1
a1077 1
		if (!ssl3_digest_cached_records(s))
d1191 1
a1191 1
		ssl3_record_sequence_increment(seq);
@


1.81
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.80 2015/08/27 14:16:57 jsing Exp $ */
d145 122
@


1.80
log
@Change AEAD out_len argument to size_t instead of ssize_t - while here,
rename it to out_len so that its purpose is more obvious. Also, drop two
checks that are no longer possible (and have not been for a long time).

Spotted by and ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.79 2015/07/17 07:04:41 doug Exp $ */
d229 1
a229 1
	OPENSSL_cleanse(A1, sizeof(A1));
d662 1
a662 1
		OPENSSL_cleanse(tmp_block, key_block_len);
@


1.79
log
@Remove workaround for TLS padding bug from SSLeay days.

OpenSSL doesn't remember which clients were impacted and the
functionality has been broken in their stable releases for 2 years.

Based on OpenSSL commit a8e4ac6a2fe67c19672ecf0c6aeafa15801ce3a5.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.78 2015/06/17 14:27:56 jsing Exp $ */
d701 1
a701 1
		ssize_t n;
d756 1
a756 1
			    out + eivlen, &n, len + aead->tag_len, nonce,
d759 2
a760 2
			if (n >= 0 && aead->variable_nonce_in_record)
				n += aead->variable_nonce_len;
d789 2
a790 2
			if (!EVP_AEAD_CTX_open(&aead->ctx, out, &n, len, nonce,
			    nonce_used, in, len + aead->tag_len, ad,
d797 1
a797 3
		if (n == -1)
			return -1;
		rec->length = n;
@


1.78
log
@Keep alerts sorted by alert code.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.77 2015/02/22 15:54:27 jsing Exp $ */
a877 4
			if (s->options & SSL_OP_TLS_BLOCK_PADDING_BUG) {
				if (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)
					j++;
			}
@


1.77
log
@Reluctantly add server-side support for TLS_FALLBACK_SCSV.

This allows for clients that willingly choose to perform a downgrade and
attempt to establish a second connection at a lower protocol after the
previous attempt unexpectedly failed, to be notified and have the second
connection aborted, if the server does in fact support a higher protocol.

TLS has perfectly good version negotiation and client-side fallback is
dangerous. Despite this, in order to maintain maximum compatability with
broken web servers, most mainstream browsers implement this. Furthermore,
TLS_FALLBACK_SCSV only works if both the client and server support it and
there is effectively no way to tell if this is the case, unless you control
both ends.

Unfortunately, various auditors and vulnerability scanners (including
certain online assessment websites) consider the presence of a not yet
standardised feature to be important for security, even if the clients do
not perform client-side downgrade or the server only supports current TLS
protocols.

Diff is loosely based on OpenSSL with some inspiration from BoringSSL.

Discussed with beck@@ and miod@@.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.76 2015/02/07 18:53:55 doug Exp $ */
d1227 2
a1244 2
	case SSL_AD_INAPPROPRIATE_FALLBACK:
		return(TLS1_AD_INAPPROPRIATE_FALLBACK);
@


1.76
log
@Remove useless variables and use the values directly.

From OpenSSL commit 3d47c1d331fdc7574d2275cda1a630ccdb624b08.

ok miod@@, jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.75 2014/12/15 00:46:53 doug Exp $ */
d1243 2
@


1.75
log
@Add error handling for EVP_DigestInit_ex().

A few EVP_DigestInit_ex() calls were left alone since reporting an
error would change the public API.

Changed internal ssl3_cbc_digest_record() to return a value due to the above
change.  It will also now set md_out_size=0 on failure.

This is based on part of BoringSSL's commit to fix malloc crashes:
https://boringssl.googlesource.com/boringssl/+/69a01608f33ab6fe2c3485d94aef1fe9eacf5364

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.74 2014/12/14 15:30:50 jsing Exp $ */
a1084 2
	const void *co = NULL, *so = NULL;
	int col = 0, sol = 0;
d1088 2
a1089 2
	    s->s3->client_random, SSL3_RANDOM_SIZE, co, col,
	    s->s3->server_random, SSL3_RANDOM_SIZE, so, sol,
@


1.74
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.73 2014/11/18 05:33:43 miod Exp $ */
d1057 1
a1057 1
		ssl3_cbc_digest_record(mac_ctx,
d1062 2
a1063 1
		    0 /* not SSLv3 */);
@


1.73
log
@Update the GOST code in libssl, as contributed by Dmitry Eremin-Solenikov.

This causes a libssl major version bump as this affects the layout of some
internal-but-unfortunately-made-visible structs.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.72 2014/11/16 14:12:47 jsing Exp $ */
d608 1
a608 1
		/* If GCM mode only part of IV comes from PRF. */ 
d826 1
a826 1
				else 
@


1.72
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.71 2014/10/18 16:13:16 jsing Exp $ */
d449 12
@


1.71
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.70 2014/10/18 03:04:28 doug Exp $ */
d139 1
d141 1
@


1.70
log
@Typical malloc() with size multiplication to reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.69 2014/08/07 20:02:23 miod Exp $ */
a142 1
#include <openssl/rand.h>
d812 2
a813 2
				else if (RAND_bytes(rec->input, ivlen) <= 0)
					return -1;
@


1.69
log
@Oops, revert changes commited by mistake. The previous commit was supposed
to only apply to s23_srvr.c.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.67 2014/07/10 10:09:54 jsing Exp $ */
a605 2
	key_block_len = (mac_secret_size + key_len + iv_len) * 2;

d608 2
a609 1
	if ((key_block = malloc(key_block_len)) == NULL) {
d613 1
@


1.68
log
@When you expect a function to return a particular value, don't put a comment
saying that you expect it to return that value and compare it against zero
because it is supposedly faster, for this leads to bugs (especially given the
high rate of sloppy cut'n'paste within ssl3 and dtls1 routines in this
library).

Instead, compare for the exact value it ought to return upon success.

ok deraadt@@
@
text
@d322 1
a322 1
    unsigned int key_len, const unsigned char *iv, unsigned int iv_len)
a858 1
			/* XXX divide by zero if bs == 0 (should not happen) */
d1123 1
a1123 1
		if (contextlen != 0 && context != NULL) {
@


1.67
log
@Remove more compression related code.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.66 2014/07/10 08:51:15 tedu Exp $ */
d322 1
a322 1
    unsigned key_len, const unsigned char *iv, unsigned iv_len)
d859 1
d1124 1
a1124 1
		if ((contextlen > 0) || (context != NULL)) {
@


1.66
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.65 2014/07/09 11:25:42 jsing Exp $ */
a570 1
	SSL_COMP *comp;
a574 6

	if (!ssl_cipher_get_comp(s->session, &comp)) {
		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,
		    SSL_R_CIPHER_COMPRESSION_UNAVAILABLE);
		return (0);
	}
@


1.65
log
@tedu the SSL export cipher handling - since we do not have enabled export
ciphers we no longer need the flags or code to support it.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.64 2014/07/08 16:05:52 beck Exp $ */
a139 3
#ifndef OPENSSL_NO_COMP
#include <openssl/comp.h>
#endif
a469 3
#ifndef OPENSSL_NO_COMP
	const SSL_COMP *comp;
#endif
a488 35
#ifndef OPENSSL_NO_COMP
	comp = s->s3->tmp.new_compression;
	if (is_read) {
		if (s->expand != NULL) {
			COMP_CTX_free(s->expand);
			s->expand = NULL;
		}
		if (comp != NULL) {
			s->expand = COMP_CTX_new(comp->method);
			if (s->expand == NULL) {
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,
				    SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
			}
			if (s->s3->rrec.comp == NULL)
				s->s3->rrec.comp =
				    malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
			if (s->s3->rrec.comp == NULL)
				goto err;
		}
	} else {
		if (s->compress != NULL) {
			COMP_CTX_free(s->compress);
			s->compress = NULL;
		}
		if (comp != NULL) {
			s->compress = COMP_CTX_new(comp->method);
			if (s->compress == NULL) {
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,
				    SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
			}
		}
	}
#endif
a557 2
err:
	SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);
@


1.64
log
@pedantic avoidance of division by zero, likely not actually
possible to hit for real.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.63 2014/06/21 17:02:25 jsing Exp $ */
a377 7
	static const unsigned char empty[] = "";
	unsigned char export_tmp1[EVP_MAX_KEY_LENGTH];
	unsigned char export_tmp2[EVP_MAX_KEY_LENGTH];
	unsigned char export_iv1[EVP_MAX_IV_LENGTH * 2];
	unsigned char export_iv2[EVP_MAX_IV_LENGTH * 2];
	unsigned char *exp_label;
	int exp_label_len;
a382 1
	int is_export;
a383 1
	is_export = SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
a431 35
	if (is_export) {
		/*
		 * Both the read and write key/iv are set to the same value
		 * since only the correct one will be used :-).
		 */
		if (use_client_keys) {
			exp_label = TLS_MD_CLIENT_WRITE_KEY_CONST;
			exp_label_len = TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;
		} else {
			exp_label = TLS_MD_SERVER_WRITE_KEY_CONST;
			exp_label_len = TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;
		}
		if (!tls1_PRF(ssl_get_algorithm2(s), exp_label, exp_label_len,
		    s->s3->client_random, SSL3_RANDOM_SIZE,
		    s->s3->server_random, SSL3_RANDOM_SIZE,
		    NULL, 0, NULL, 0, key, key_len, export_tmp1, export_tmp2,
		    EVP_CIPHER_key_length(cipher)))
			goto err2;
		key = export_tmp1;

		if (iv_len > 0) {
			if (!tls1_PRF(ssl_get_algorithm2(s),
			    TLS_MD_IV_BLOCK_CONST, TLS_MD_IV_BLOCK_CONST_SIZE,
			    s->s3->client_random, SSL3_RANDOM_SIZE,
			    s->s3->server_random, SSL3_RANDOM_SIZE,
			    NULL, 0, NULL, 0, empty, 0,
			    export_iv1, export_iv2, iv_len * 2))
				goto err2;
			if (use_client_keys)
				iv = export_iv1;
			else
				iv = &(export_iv1[iv_len]);
		}
	}

a452 7
	if (is_export) {
		OPENSSL_cleanse(export_tmp1, sizeof(export_tmp1));
		OPENSSL_cleanse(export_tmp2, sizeof(export_tmp2));
		OPENSSL_cleanse(export_iv1, sizeof(export_iv1));
		OPENSSL_cleanse(export_iv2, sizeof(export_iv2));
	}

a456 1
err2:
a471 1
	int is_export;
a476 1
	is_export = SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
a546 4
		if (is_export &&
		    key_len > SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher))
			key_len = SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher);

a643 4

		if (SSL_C_IS_EXPORT(s->session->cipher) &&
                    key_len > SSL_C_EXPORT_KEYLENGTH(s->session->cipher))
                        key_len = SSL_C_EXPORT_KEYLENGTH(s->session->cipher);
@


1.63
log
@Pull the code that builds a DTLS sequence number out into its own function
to avoid duplication. Also use fewer magic numbers.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.62 2014/06/21 14:45:22 jsing Exp $ */
d253 5
@


1.62
log
@Pull out the sequence number selection and handle this up front. Also, the
correct record is already known, so avoid reassignment.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.60 2014/06/15 15:29:25 jsing Exp $ */
d798 2
a799 5
			unsigned char dtlsseq[9], *p = dtlsseq;

			s2n(send ? s->d1->w_epoch : s->d1->r_epoch, p);
			memcpy(p, &seq[2], 6);
			memcpy(ad, dtlsseq, 8);
d948 2
a949 5
				unsigned char dtlsseq[9], *p = dtlsseq;

				s2n(send ? s->d1->w_epoch : s->d1->r_epoch, p);
				memcpy(p, &seq[2], 6);
				memcpy(buf, dtlsseq, 8);
d1128 5
a1132 9
	if (SSL_IS_DTLS(ssl)) {
		unsigned char dtlsseq[8], *p = dtlsseq;

		s2n(send ? ssl->d1->w_epoch : ssl->d1->r_epoch, p);
		memcpy(p, &seq[2], 6);

		memcpy(header, dtlsseq, 8);
	} else
		memcpy(header, seq, 8);
@


1.61
log
@More KNF and clean up.
@
text
@d778 1
d785 1
d789 1
d793 1
a793 1
		unsigned char ad[13], *seq, *in, *out, nonce[16];
a796 2
		seq = send ? s->s3->write_sequence : s->s3->read_sequence;

a906 1
		rec = &(s->s3->wrec);
a932 1
		rec = &(s->s3->rrec);
d948 1
a948 3
			unsigned char buf[13], *seq;

			seq = send ? s->s3->write_sequence : s->s3->read_sequence;
@


1.60
log
@Rename ssl3_record_sequence_update() to ssl3_record_sequence_increment(),
so that it reflects what it is actually doing. Use this function in a
number of places that still have the hand rolled version.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.59 2014/06/13 16:09:15 jsing Exp $ */
d251 2
a252 2
		if ((m << TLS1_PRF_DGST_SHIFT)
			& digest_mask) count++;
d254 1
a254 1
	len = slen/count;
a264 1

d448 1
a448 2
		if (!tls1_PRF(ssl_get_algorithm2(s),
		    exp_label, exp_label_len,
a990 1

a1005 1

a1060 1

d1070 1
a1070 1
		if (mask & ssl_get_algorithm2(s)) {
a1212 1

d1273 2
a1274 1
	SSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL, SSL_R_TLS_ILLEGAL_EXPORTER_LABEL);
d1283 1
@


1.59
log
@Correctly calculate the key block length when using export ciphers.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.58 2014/06/13 14:32:35 jsing Exp $ */
d806 1
a806 5
			for (i = 7; i >= 0; i--) {
				++seq[i];
				if (seq[i] != 0)
					break;
			}
d963 1
a963 5
				for (i = 7; i >= 0; i--) {	/* increment */
					++seq[i];
					if (seq[i] != 0)
						break;
				}
a1111 1
	int i;
d1185 2
a1186 7
	if (!SSL_IS_DTLS(ssl)) {
		for (i = 7; i >= 0; i--) {
			++seq[i];
			if (seq[i] != 0)
				break;
		}
	}
@


1.58
log
@Swap compress/expand around so they are in the correct order - these ended
up in the wrong order when the code was refactored.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.57 2014/06/13 12:49:10 jsing Exp $ */
d699 4
@


1.57
log
@Combine the MAC handling for both !EVP_CIPH_FLAG_AEAD_CIPHER and
EVP_CIPH_FLAG_AEAD_CIPHER into the same if/else block.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.56 2014/06/13 11:52:03 jsing Exp $ */
a548 13
		if (s->compress != NULL) {
			COMP_CTX_free(s->compress);
			s->compress = NULL;
		}
		if (comp != NULL) {
			s->compress = COMP_CTX_new(comp->method);
			if (s->compress == NULL) {
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,
				    SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
			}
		}
	} else {
d565 13
@


1.56
log
@Add support for handling SSL_CIPHER_ALGORITHM2_AEAD ciphers, which are
those that use EVP_AEAD instead ov EVP_CIPHER. This means being able to
change cipher state with an EVP_AEAD and being able to encrypt/decrypt
TLS using the EVP_AEAD. This has no change on existing
non-SSL_CIPHER_ALGORITHM2_AEAD ciphers.

Based on Adam Langley's chromium patches.

Rides the recent libssl bump.

Tested by sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.55 2014/06/13 04:29:13 miod Exp $ */
a384 1
	EVP_PKEY *mac_key;
a436 9
	if (!(EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER)) {
		mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
		    mac_secret, mac_secret_size);
		if (mac_key == NULL)
			goto err;
		EVP_DigestSignInit(mac_ctx, NULL, mac, NULL, mac_key);
		EVP_PKEY_free(mac_key);
	}

d481 9
a489 3
	/* Needed for "composite" AEADs, such as RC4-HMAC-MD5 */
	if ((EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) &&
	    mac_secret_size)
d492 1
@


1.55
log
@Remove support for the `opaque PRF input' extension, which draft has expired
7 years ago and never made it into an RFC. That code wasn't compiled in
anyway unless one would define the actual on-the-wire extension id bytes;
crank libssl major.

With help and enlightenment from Brendan MacDonell.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_enc.c,v 1.54 2014/06/12 15:49:31 deraadt Exp $ */
d299 63
d522 1
d532 1
d594 9
a602 3
	key_len = EVP_CIPHER_key_length(cipher);
	if (is_export) {
		if (key_len > SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher))
d604 4
a609 6
	/* If GCM mode only part of IV comes from PRF. */
	if (EVP_CIPHER_mode(cipher) == EVP_CIPH_GCM_MODE)
		iv_len = EVP_GCM_TLS_FIXED_IV_LEN;
	else
		iv_len = EVP_CIPHER_iv_length(cipher);

d649 5
d669 3
a671 2
	const EVP_CIPHER *cipher;
	const EVP_MD *mac;
d684 22
a705 5
	if (!ssl_cipher_get_evp(s->session, &cipher, &mac, &mac_type,
	    &mac_secret_size)) {
		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,
		    SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
		return (0);
d708 1
a708 7
	key_len = EVP_CIPHER_key_length(cipher);

	if (EVP_CIPHER_mode(cipher) == EVP_CIPH_GCM_MODE)
		iv_len = EVP_GCM_TLS_FIXED_IV_LEN;
	else
		iv_len = EVP_CIPHER_iv_length(cipher);

d713 1
d754 1
d775 3
a778 1
	EVP_CIPHER_CTX *ds;
d781 123
a903 1
	const EVP_CIPHER *enc;
a943 1

@


1.54
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a999 17

#ifdef TLSEXT_TYPE_opaque_prf_input
	if (s->s3->client_opaque_prf_input != NULL &&
	    s->s3->server_opaque_prf_input != NULL &&
	    s->s3->client_opaque_prf_input_len > 0 &&
	    s->s3->client_opaque_prf_input_len ==
	    s->s3->server_opaque_prf_input_len) {
		/*
		 * sol must be same as col - see section 3.1 of
		 * draft-rescorla-tls-opaque-prf-input-00.txt.
		 */
		co = s->s3->client_opaque_prf_input;
		col = s->s3->server_opaque_prf_input_len;
		so = s->s3->server_opaque_prf_input;
		sol = s->s3->client_opaque_prf_input_len;
	}
#endif
@


1.53
log
@Stop setting the EVP_MD_CTX_FLAG_NON_FIPS_ALLOW - it has been ignored since
OpenSSL 1.0.0.

ok miod@@ (a little while back)
@
text
@d1 1
a1 1
/* ssl/t1_enc.c */
@


1.52
log
@In tls1_cert_verify_mac(), check the return value of EVP_MD_CTX_copy_ex()
to avoid a possible NULL function call on ctx.final(). None of the callers
currently check the return value of calls to cert_verify_mac(), however
the function already returns 0 in another case and the MAC comparison will
later fail.

Issue reported by David Ramos.
@
text
@a167 2
	EVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
	EVP_MD_CTX_set_flags(&ctx_tmp, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
@


1.51
log
@Add a define for the SSLv3 sequence size and use it, rather than sprinkling
magic numbers around.

ok deraadt@@
@
text
@d822 1
a823 1
	EVP_MD_CTX ctx, *d = NULL;
d837 1
a837 1
	if (!d) {
d843 2
a844 1
	EVP_MD_CTX_copy_ex(&ctx, d);
d847 1
@


1.50
log
@Be explicit with types. No binary change.
@
text
@d528 1
a528 1
		memset(seq, 0, 8);
d756 1
a756 1
				memcpy(buf, seq, 8);
@


1.49
log
@Factor out the part of tls1_change_cipher_state() that is specific to
switching cipher states using an EVP_CIPHER. This will facilitate the
addition of cipher state changes for EVP_AEAD. No functional change.

Based on Adam Langley's chromium patches.
@
text
@d309 3
a311 3
    const unsigned char *mac_secret, unsigned mac_secret_size,
    const unsigned char *key, unsigned key_len, const unsigned char *iv,
    unsigned iv_len)
@


1.48
log
@Factor out the sequence number reset code to aid in upcoming changes.
@
text
@d300 12
a311 2
int
tls1_change_cipher_state(SSL *s, int which)
d318 58
d377 77
d459 4
a462 1
	unsigned char *key_block, *exp_label, *seq;
a463 2
	EVP_CIPHER_CTX *cipher_ctx;
	const EVP_CIPHER *cipher;
a466 6
	const EVP_MD *mac;
	int mac_type;
	EVP_MD_CTX *mac_ctx;
	EVP_PKEY *mac_key;
	int is_export, exp_label_len;
	char is_read, use_client_keys;
a469 2
	mac = s->s3->tmp.new_hash;
	mac_type = s->s3->tmp.new_mac_pkey_type;
a521 45
	if (is_read) {
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
			s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;
		else
			s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;

		EVP_CIPHER_CTX_free(s->enc_read_ctx);
		s->enc_read_ctx = NULL;
		EVP_MD_CTX_destroy(s->read_hash);
		s->read_hash = NULL;

		if ((cipher_ctx = EVP_CIPHER_CTX_new()) == NULL)
			goto err;
		s->enc_read_ctx = cipher_ctx;
		if ((mac_ctx = EVP_MD_CTX_create()) == NULL)
			goto err;
		s->read_hash = mac_ctx;
	} else {
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
			s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;
		else
			s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;

		/*
		 * DTLS fragments retain a pointer to the compression, cipher
		 * and hash contexts, so that it can restore state in order
		 * to perform retransmissions. As such, we cannot free write
		 * contexts that are used for DTLS - these are instead freed
		 * by DTLS when its frees a ChangeCipherSpec fragment.
		 */
		if (!SSL_IS_DTLS(s)) {
			EVP_CIPHER_CTX_free(s->enc_write_ctx);
			s->enc_write_ctx = NULL;
			EVP_MD_CTX_destroy(s->write_hash);
			s->write_hash = NULL;
		}
		if ((cipher_ctx = EVP_CIPHER_CTX_new()) == NULL)
			goto err;
		s->enc_write_ctx = cipher_ctx;
		if ((mac_ctx = EVP_MD_CTX_create()) == NULL)
			goto err;
		s->write_hash = mac_ctx;

	}

d582 2
a583 68
	if (!(EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER)) {
		mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
		    mac_secret, mac_secret_size);
		if (mac_key == NULL)
			goto err;
		EVP_DigestSignInit(mac_ctx, NULL, mac, NULL, mac_key);
		EVP_PKEY_free(mac_key);
	}

	if (is_export) {
		/*
		 * Both the read and write key/iv are set to the same value
		 * since only the correct one will be used :-).
		 */
		if (use_client_keys) {
			exp_label = TLS_MD_CLIENT_WRITE_KEY_CONST;
			exp_label_len = TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;
		} else {
			exp_label = TLS_MD_SERVER_WRITE_KEY_CONST;
			exp_label_len = TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;
		}

		if (!tls1_PRF(ssl_get_algorithm2(s),
		    exp_label, exp_label_len,
		    s->s3->client_random, SSL3_RANDOM_SIZE,
		    s->s3->server_random, SSL3_RANDOM_SIZE,
		    NULL, 0, NULL, 0, key, key_len, export_tmp1, export_tmp2,
		    EVP_CIPHER_key_length(cipher)))
			goto err2;
		key = export_tmp1;

		if (iv_len > 0) {
			if (!tls1_PRF(ssl_get_algorithm2(s),
			    TLS_MD_IV_BLOCK_CONST, TLS_MD_IV_BLOCK_CONST_SIZE,
			    s->s3->client_random, SSL3_RANDOM_SIZE,
			    s->s3->server_random, SSL3_RANDOM_SIZE,
			    NULL, 0, NULL, 0, empty, 0,
			    export_iv1, export_iv2, iv_len * 2))
				goto err2;
			if (use_client_keys)
				iv = export_iv1;
			else
				iv = &(export_iv1[iv_len]);
		}
	}

	if (EVP_CIPHER_mode(cipher) == EVP_CIPH_GCM_MODE) {
		EVP_CipherInit_ex(cipher_ctx, cipher, NULL, key, NULL,
		    !is_read);
		EVP_CIPHER_CTX_ctrl(cipher_ctx, EVP_CTRL_GCM_SET_IV_FIXED,
		    iv_len, (unsigned char *)iv);
	} else
		EVP_CipherInit_ex(cipher_ctx, cipher, NULL, key, iv, !is_read);

	/* Needed for "composite" AEADs, such as RC4-HMAC-MD5 */
	if ((EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) &&
	    mac_secret_size)
		EVP_CIPHER_CTX_ctrl(cipher_ctx, EVP_CTRL_AEAD_SET_MAC_KEY,
		    mac_secret_size, (unsigned char *)mac_secret);

	if (is_export) {
		OPENSSL_cleanse(export_tmp1, sizeof(export_tmp1));
		OPENSSL_cleanse(export_tmp2, sizeof(export_tmp2));
		OPENSSL_cleanse(export_iv1, sizeof(export_iv1));
		OPENSSL_cleanse(export_iv2, sizeof(export_iv2));
	}

	return (1);
@


1.47
log
@Add missing NULL check after calling EVP_PKEY_new_mac_key().

Based on Adam Langley's chromium patches.
@
text
@d314 1
a314 1
	unsigned char *key_block, *exp_label;
a400 4

		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->read_sequence[0]), 0, 8);
d427 9
a435 3
		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->write_sequence[0]), 0, 8);
@


1.46
log
@Use !is_read to imply SSL3_CC_WRITE.

While this is not strictly correct (since the presence of SSL3_CC_READ does
not guarantee the absence of SSL3_CC_WRITE), in practice only one of these
flags is set at a time and there is existing logic which already relies on
this behaviour.
@
text
@d490 2
@


1.45
log
@Move the export label initialisation into the export handling code, since
this is the only place where these variables are used.
@
text
@d533 1
a533 1
		    (which & SSL3_CC_WRITE));
d537 1
a537 2
		EVP_CipherInit_ex(cipher_ctx, cipher, NULL, key, iv,
		    (which & SSL3_CC_WRITE));
@


1.44
log
@Remove pointless casts - no binary change.
@
text
@a467 2
		exp_label = TLS_MD_CLIENT_WRITE_KEY_CONST;
		exp_label_len = TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;
a471 2
		exp_label = TLS_MD_SERVER_WRITE_KEY_CONST;
		exp_label_len = TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;
d495 3
a497 2
		/* In here I set both the read and write key/iv to the
		 * same value since only the correct one will be used :-).
d499 8
@


1.43
log
@Rename variables to make it clear that these are only used in the export
code. Additionally, these need to be cleaned in the export case.

Based on Adam Langley's chromium patches.
@
text
@d468 1
a468 1
		exp_label = (unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;
d474 1
a474 1
		exp_label = (unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;
@


1.42
log
@Further clean up of context handling in tls1_change_cipher_state().

Rather than doing a complex dance to figure out if we should reuse the
cipher context and clean it later on, just free it and allocate a new one.
This simplifies the code path, especially in the write case where special
handling is required for DTLS.

Also, calling EVP_CIPHER_CTX_init() for a newly created cipher context is
unnecessary, since EVP_CIPHER_CTX_new() already does this (not to mention
that it was already missing from the write case).
@
text
@d303 5
a307 5
	static const unsigned char empty[]="";
	unsigned char tmp1[EVP_MAX_KEY_LENGTH];
	unsigned char tmp2[EVP_MAX_KEY_LENGTH];
	unsigned char iv1[EVP_MAX_IV_LENGTH*2];
	unsigned char iv2[EVP_MAX_IV_LENGTH*2];
d506 1
a506 1
		    NULL, 0, NULL, 0, key, key_len, tmp1, tmp2,
d509 1
a509 1
		key = tmp1;
d516 2
a517 1
			    NULL, 0, NULL, 0, empty, 0, iv1, iv2, iv_len * 2))
d520 1
a520 1
				iv = iv1;
d522 1
a522 1
				iv = &(iv1[iv_len]);
a525 1

d541 7
a547 4
	OPENSSL_cleanse(tmp1, sizeof(tmp1));
	OPENSSL_cleanse(tmp2, sizeof(tmp2));
	OPENSSL_cleanse(iv1, sizeof(iv1));
	OPENSSL_cleanse(iv2, sizeof(iv2));
@


1.41
log
@Rename more variables for readability and consistency.
@
text
@a326 1
	int reuse_dd = 0;
d390 6
a395 3
		if (s->enc_read_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_read_ctx = malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d397 1
a397 7
		else {
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_read_ctx);
		}
		cipher_ctx = s->enc_read_ctx;

		ssl_clear_hash_ctx(&s->read_hash);
a409 5
		if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))
			reuse_dd = 1;
		else if ((s->enc_write_ctx = EVP_CIPHER_CTX_new()) == NULL)
			goto err;
		cipher_ctx = s->enc_write_ctx;
d418 9
a426 2
		if (!SSL_IS_DTLS(s))
			ssl_clear_hash_ctx(&s->write_hash);
a435 3
	if (reuse_dd)
		EVP_CIPHER_CTX_cleanup(cipher_ctx);

d497 1
@


1.40
log
@Overhaul the key block handling in tls1_change_cipher_state() - use
meaningful variable names with pointer arithmitic, rather than n, i, j
and p with array indexing.

Based on Adam Langley's chromium diffs.

ok miod@@
@
text
@d316 2
a317 2
	EVP_CIPHER_CTX *dd;
	const EVP_CIPHER *c;
d321 1
a321 1
	const EVP_MD *m;
d326 1
a327 1
	char is_read, use_client_keys;
d330 2
a331 2
	c = s->s3->tmp.new_sym_enc;
	m = s->s3->tmp.new_hash;
d399 1
a399 1
		dd = s->enc_read_ctx;
d418 1
a418 1
		dd = s->enc_write_ctx;
d439 1
a439 1
		EVP_CIPHER_CTX_cleanup(dd);
d441 1
a441 1
	key_len = EVP_CIPHER_key_length(c);
d448 1
a448 1
	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
d451 1
a451 1
		iv_len = EVP_CIPHER_iv_length(c);
d496 1
a496 1
	if (!(EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER)) {
d499 1
a499 1
		EVP_DigestSignInit(mac_ctx, NULL, m, NULL, mac_key);
d511 1
a511 1
		    EVP_CIPHER_key_length(c)))
d530 2
a531 2
	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) {
		EVP_CipherInit_ex(dd, c, NULL, key, NULL,
d533 2
a534 2
		EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, iv_len,
		    (unsigned char *)iv);
d536 1
a536 1
		EVP_CipherInit_ex(dd, c, NULL, key, iv,
d540 1
a540 1
	if ((EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER) &&
d542 1
a542 1
		EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_MAC_KEY,
d564 1
a564 1
	const EVP_MD *hash;
d577 1
a577 1
	if (!ssl_cipher_get_evp(s->session, &cipher, &hash, &mac_type,
d592 1
a592 1
	s->s3->tmp.new_hash = hash;
@


1.39
log
@In tls1_setup_key_block(), use the correct IV length for GCM mode, which
results in the key block length calculation also being correct. Rename a
number of variables so that their purpose becomes clear and simplify some
of the code.

Inspired by Adam Langley's chromium diffs.

ok miod@@
@
text
@a303 2
	unsigned char *p, *mac_secret;
	unsigned char *exp_label;
d308 8
a315 2
	unsigned char *ms, *key, *iv;
	int client_write;
a322 1
	int *mac_secret_size;
d325 1
a325 1
	int is_export, n, i, k, exp_label_len, key_len;
d327 1
a327 1
	char is_read;
d341 8
a408 2
		mac_secret = &(s->s3->read_mac_secret[0]);
		mac_secret_size = &(s->s3->read_mac_secret_size);
a435 2
		mac_secret = &(s->s3->write_mac_secret[0]);
		mac_secret_size = &(s->s3->write_mac_secret_size);
a440 3
	p = s->s3->tmp.key_block;
	i = *mac_secret_size = s->s3->tmp.new_mac_secret_size;

d449 1
a449 1
		k = EVP_GCM_TLS_FIXED_IV_LEN;
d451 22
a472 9
		k = EVP_CIPHER_iv_length(c);
	if ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
	    (which == SSL3_CHANGE_CIPHER_SERVER_READ)) {
		ms = &(p[0]);
		n = i + i;
		key = &(p[n]);
		n += key_len + key_len;
		iv = &(p[n]);
		n += k + k;
a474 1
		client_write = 1;
d476 3
a478 7
		n = i;
		ms = &(p[n]);
		n += i + key_len;
		key = &(p[n]);
		n += key_len + k;
		iv = &(p[n]);
		n += k;
a480 1
		client_write = 0;
d483 1
a483 1
	if (n > s->s3->tmp.key_block_length) {
d488 7
a494 1
	memcpy(mac_secret, ms, i);
d498 1
a498 1
		    mac_secret, *mac_secret_size);
d515 1
a515 1
		if (k > 0) {
d520 1
a520 1
			    NULL, 0, NULL, 0, empty, 0, iv1, iv2, k*2))
d522 1
a522 1
			if (client_write)
d525 1
a525 1
				iv = &(iv1[k]);
d531 4
a534 2
		EVP_CipherInit_ex(dd, c, NULL, key, NULL, (which & SSL3_CC_WRITE));
		EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);
d536 2
a537 1
		EVP_CipherInit_ex(dd, c, NULL, key, iv, (which & SSL3_CC_WRITE));
d540 2
a541 1
	if ((EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)
d543 1
a543 2
		    *mac_secret_size, mac_secret);

@


1.38
log
@Clean up the tls1_change_cipher_state() key length handling and use a
single variable with a descriptive name, instead of two poorly named
variables.

Largely based on Adam Langley's chromium patches.

ok miod@@
@
text
@d540 4
a543 2
	unsigned char *p1, *p2 = NULL;
	const EVP_CIPHER *c;
a544 1
	int num;
a545 1
	int mac_type = NID_undef, mac_secret_size = 0;
d557 1
a557 1
	if (!ssl_cipher_get_evp(s->session, &c, &hash, &mac_type,
d564 8
a571 1
	s->s3->tmp.new_sym_enc = c;
d575 1
a575 2
	num = EVP_CIPHER_key_length(c) + mac_secret_size + EVP_CIPHER_iv_length(c);
	num *= 2;
d579 1
a579 1
	if ((p1 = malloc(num)) == NULL) {
d584 2
a585 2
	s->s3->tmp.key_block_length = num;
	s->s3->tmp.key_block = p1;
d587 1
a587 1
	if ((p2 = malloc(num)) == NULL) {
d592 1
a592 1
	if (!tls1_generate_key_block(s, p1, p2, num))
d597 2
a598 1
		/* enable vulnerability countermeasure for CBC ciphers with
d616 3
a618 3
	if (p2) {
		OPENSSL_cleanse(p2, num);
		free(p2);
@


1.37
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@d322 1
a322 1
	int is_export, n, i, j, k, exp_label_len, cl;
d437 7
a443 5
	cl = EVP_CIPHER_key_length(c);
	j = is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
	    cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
	/* Was j=(exp)?5:EVP_CIPHER_key_length(c); */
	/* If GCM mode only part of IV comes from PRF */
d453 1
a453 1
		n += j + j;
d462 1
a462 1
		n += i + j;
d464 1
a464 1
		n += j + k;
d493 1
a493 1
		    NULL, 0, NULL, 0, key, j, tmp1, tmp2,
@


1.36
log
@Make use of SSL_IS_DTLS, SSL_USE_EXPLICIT_IV, SSL_USE_SIGALGS and
SSL_USE_TLS1_2_CIPHERS.

Largely based on OpenSSL head.
@
text
@a1110 4
#if 0 /* not appropriate for TLS, not used for DTLS */
	case DTLS1_AD_MISSING_HANDSHAKE_MESSAGE : return
		(DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif
@


1.35
log
@Fix another two cases where the return value of ssl_replace_hash() is
unchecked.

In the case of tls1_change_cipher_state(), it is fairly pointless to use
ssl_replace_hash(), since it does not initialise the hash and there is
special handling required in the DTLS write case. Instead, just inline
the part of ssl_replace_hash() that is needed and only
ssl_clear_hash_ctx() the write hash in the non-DTLS case.

Also add a detailed comment explaining why there needs to be specialised
handling for DTLS write context and where the contexts are actually freed.

ok miod@@
@
text
@d642 1
a642 1
			int ivlen;
d644 1
a644 2
			/* For TLSv1.1 and later explicit IV */
			if (s->version >= TLS1_1_VERSION &&
a646 2
			else
				ivlen = 0;
d686 1
a686 1
			if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER) {
d876 1
a876 1
	if (ssl->version == DTLS1_VERSION || ssl->version == DTLS1_BAD_VER) {
d919 1
a919 1
	if (ssl->version != DTLS1_VERSION && ssl->version != DTLS1_BAD_VER) {
@


1.34
log
@More KNF.
@
text
@d389 5
a393 1
		mac_ctx = ssl_replace_hash(&s->read_hash, NULL);
d410 13
a422 7
		if (SSL_IS_DTLS(s)) {
			mac_ctx = EVP_MD_CTX_create();
			if (!mac_ctx)
				goto err;
			s->write_hash = mac_ctx;
		} else
			mac_ctx = ssl_replace_hash(&s->write_hash, NULL);
@


1.33
log
@Refactor tls1_change_cipher_state() and split the compression handling out
from the cipher and message digest handling, allowing for upcoming changes.

Based on Adam Langley's chromium diffs.

ok miod@@
@
text
@a930 2


d932 2
a933 1
	if (s->s3->client_opaque_prf_input != NULL && s->s3->server_opaque_prf_input != NULL &&
d935 6
a940 1
	    s->s3->client_opaque_prf_input_len == s->s3->server_opaque_prf_input_len) {
d944 1
a944 1
		sol = s->s3->client_opaque_prf_input_len; /* must be same as col (see draft-rescorla-tls-opaque-prf-input-00.txt, section 3.1) */
d950 3
a952 6
	    s->s3->client_random, SSL3_RANDOM_SIZE,
	    co, col,
	    s->s3->server_random, SSL3_RANDOM_SIZE,
	    so, sol,
	    p, len,
	    s->session->master_key, buff, sizeof buff);
@


1.32
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@d324 1
d330 8
d340 32
d374 1
a374 2

	if (which & SSL3_CC_READ) {
d390 1
a390 17
#ifndef OPENSSL_NO_COMP
		if (s->expand != NULL) {
			COMP_CTX_free(s->expand);
			s->expand = NULL;
		}
		if (comp != NULL) {
			s->expand = COMP_CTX_new(comp->method);
			if (s->expand == NULL) {
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
			}
			if (s->s3->rrec.comp == NULL)
				s->s3->rrec.comp = malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
			if (s->s3->rrec.comp == NULL)
				goto err;
		}
#endif
d413 1
a413 13
#ifndef OPENSSL_NO_COMP
		if (s->compress != NULL) {
			COMP_CTX_free(s->compress);
			s->compress = NULL;
		}
		if (comp != NULL) {
			s->compress = COMP_CTX_new(comp->method);
			if (s->compress == NULL) {
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
			}
		}
#endif
@


1.31
log
@Remove TLS_DEBUG, SSL_DEBUG, CIPHER_DEBUG and OPENSSL_RI_DEBUG. Much of
this is sporadic, hacked up and can easily be put back in an improved form
should we ever need it.

ok miod@@
@
text
@d1022 2
a1023 4
	if (buff != NULL)
		free(buff);
	if (val != NULL)
		free(val);
@


1.30
log
@The ssl_ciper_get_evp() function is currently overloaded to also return the
compression associated with the SSL session. Based on one of Adam Langley's
chromium diffs, factor out the compression handling code into a separate
ssl_cipher_get_comp() function.

Rewrite the compression handling code to avoid pointless duplication and so
that failures are actually returned to and detectable by the caller.

ok miod@@
@
text
@a460 4
#ifdef TLS_DEBUG
	printf("which = %04X\nmac key=", which);
	{ int z; for (z = 0; z<i; z++) printf("%02X%c", ms[z],((z+1)%16)?' ':'\n'); }
#endif
a499 7
#ifdef TLS_DEBUG
	printf("which = %04X\nkey=", which);
	{ int z; for (z = 0; z<EVP_CIPHER_key_length(c); z++) printf("%02X%c", key[z],((z+1)%16)?' ':'\n'); }
	printf("\niv=");
	{ int z; for (z = 0; z<k; z++) printf("%02X%c", iv[z],((z+1)%16)?' ':'\n'); }
	printf("\n");
#endif
a561 8
#ifdef TLS_DEBUG
	printf("client random\n");
	{ int z; for (z = 0; z<SSL3_RANDOM_SIZE; z++) printf("%02X%c", s->s3->client_random[z],((z+1)%16)?' ':'\n'); }
	printf("server random\n");
	{ int z; for (z = 0; z<SSL3_RANDOM_SIZE; z++) printf("%02X%c", s->s3->server_random[z],((z+1)%16)?' ':'\n'); }
	printf("pre-master\n");
	{ int z; for (z = 0; z<s->session->master_key_length; z++) printf("%02X%c", s->session->master_key[z],((z+1)%16)?' ':'\n'); }
#endif
a563 4
#ifdef TLS_DEBUG
	printf("\nkey block\n");
	{ int z; for (z = 0; z<num; z++) printf("%02X%c", p1[z],((z+1)%16)?' ':'\n'); }
#endif
a898 10
#ifdef TLS_DEBUG
	printf("sec=");
	{unsigned int z; for (z = 0; z<md_size; z++) printf("%02X ", mac_sec[z]); printf("\n"); }
	printf("seq=");
	{int z; for (z = 0; z<8; z++) printf("%02X ", seq[z]); printf("\n"); }
	printf("buf=");
	{int z; for (z = 0; z<5; z++) printf("%02X ", buf[z]); printf("\n"); }
	printf("rec=");
	{unsigned int z; for (z = 0; z<rec->length; z++) printf("%02X ", buf[z]); printf("\n"); }
#endif
a907 3
#ifdef TLS_DEBUG
	{unsigned int z; for (z = 0; z<md_size; z++) printf("%02X ", md[z]); printf("\n"); }
#endif
a939 10
#ifdef SSL_DEBUG
	fprintf(stderr, "Premaster Secret:\n");
	BIO_dump_fp(stderr, (char *)p, len);
	fprintf(stderr, "Client Random:\n");
	BIO_dump_fp(stderr, (char *)s->s3->client_random, SSL3_RANDOM_SIZE);
	fprintf(stderr, "Server Random:\n");
	BIO_dump_fp(stderr, (char *)s->s3->server_random, SSL3_RANDOM_SIZE);
	fprintf(stderr, "Master Secret:\n");
	BIO_dump_fp(stderr, (char *)s->session->master_key, SSL3_MASTER_SECRET_SIZE);
#endif
@


1.29
log
@Invoke OPENSSL_cleanse() with the size of the variable you are cleaning.
ok jsing@@
@
text
@a534 1

d538 10
a547 2
	if (!ssl_cipher_get_evp(s->session, &c, &hash, &mac_type, &mac_secret_size, &comp)) {
		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
@


1.28
log
@KSSL is dead... nuke KSSL_DEBUG from orbit.

ok beck@@ miod@@
@
text
@d513 1
a513 1
	OPENSSL_cleanse(tmp2, sizeof(tmp1));
@


1.27
log
@use the correct algorithm mask. reported by satish lvr via
http://marc.info/?l=openssl-dev&m=139779977532459&w=2
ok miod
@
text
@a146 3
#ifdef KSSL_DEBUG
#include <openssl/des.h>
#endif
a296 11
#ifdef KSSL_DEBUG
	printf("tls1_generate_key_block() ==> %d byte master_key =\n\t",
	    s->session->master_key_length);
	{
		int i;
		for (i = 0; i < s->session->master_key_length; i++) {
			printf("%02X", s->session->master_key[i]);
		}
		printf("\n");
	}
#endif    /* KSSL_DEBUG */
a332 16
#ifdef KSSL_DEBUG
	printf("tls1_change_cipher_state(which= %d) w/\n", which);
	printf("\talg= %ld/%ld, comp= %p\n",
	    s->s3->tmp.new_cipher->algorithm_mkey,
	    s->s3->tmp.new_cipher->algorithm_auth,
	    comp);
	printf("\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n", c);
	printf("\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n",
	    c->nid, c->block_size, c->key_len, c->iv_len);
	printf("\tkey_block: len= %d, data= ", s->s3->tmp.key_block_length);
	{
		int i;
		for (i = 0; i < s->s3->tmp.key_block_length; i++)
			printf("%02x", s->s3->tmp.key_block[i]);  printf("\n");
	}
#endif	/* KSSL_DEBUG */
a491 10
#ifdef KSSL_DEBUG
	{
		int i;
		printf("EVP_CipherInit_ex(dd, c, key=, iv=, which)\n");
		printf("\tkey= "); for (i = 0; i<c->key_len; i++) printf("%02x", key[i]);
		printf("\n");
		printf("\t iv= "); for (i = 0; i<c->iv_len; i++) printf("%02x", iv[i]);
		printf("\n");
	}
#endif	/* KSSL_DEBUG */
a534 3
#ifdef KSSL_DEBUG
	printf ("tls1_setup_key_block()\n");
#endif	/* KSSL_DEBUG */
a668 3
#ifdef KSSL_DEBUG
	printf("tls1_enc(%d)\n", send);
#endif    /* KSSL_DEBUG */
a724 17
#ifdef KSSL_DEBUG
		{
			unsigned long ui;
			printf("EVP_Cipher(ds=%p, rec->data=%p, rec->input=%p, l=%ld) ==>\n",
			    ds, rec->data, rec->input, l);
			printf("\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%d %d], %d iv_len\n",
			    ds->buf_len, ds->cipher->key_len,
			    DES_KEY_SZ, DES_SCHEDULE_SZ,
			    ds->cipher->iv_len);
			printf("\t\tIV: ");
			for (i = 0; i<ds->cipher->iv_len; i++) printf("%02X", ds->iv[i]);
				printf("\n");
			printf("\trec->input=");
			for (ui = 0; ui<l; ui++) printf(" %02x", rec->input[ui]);
				printf("\n");
		}
#endif	/* KSSL_DEBUG */
a740 8
#ifdef KSSL_DEBUG
		{
			unsigned long i;
			printf("\trec->data=");
			for (i = 0; i < l; i++)
				printf(" %02x", rec->data[i]);  printf("\n");
		}
#endif	/* KSSL_DEBUG */
a948 3
#ifdef KSSL_DEBUG
	printf ("tls1_generate_master_secret(%p,%p, %p, %d)\n", s, out, p, len);
#endif	/* KSSL_DEBUG */
a979 3
#ifdef KSSL_DEBUG
	printf ("tls1_generate_master_secret() complete\n");
#endif	/* KSSL_DEBUG */
a992 3
#ifdef KSSL_DEBUG
	printf ("tls1_export_keying_material(%p,%p,%d,%s,%d,%p,%d)\n", s, out, olen, label, llen, p, plen);
#endif	/* KSSL_DEBUG */
a1051 3
#ifdef KSSL_DEBUG
	printf ("tls1_export_keying_material() complete\n");
#endif	/* KSSL_DEBUG */
@


1.26
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@d1127 1
a1127 1
	rv = tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
@


1.25
log
@Chop off more SSLv2 tentacles and start fixing and noting y2038 issues.
APIs that pass times as longs will have to change at some point...
Bump major on both libcrypto and libssl.

ok tedu@@
@
text
@d596 1
a596 1
	if ((p1 = (unsigned char *)malloc(num)) == NULL) {
d604 1
a604 1
	if ((p2 = (unsigned char *)malloc(num)) == NULL) {
@


1.24
log
@More KNF.
@
text
@a521 1
	s->session->key_arg_length = 0;
@


1.23
log
@now that knf carpet bombing is finished, switch to hand to hand combat.
still not sure what to make of mysteries like this:
	for (i = 7; i >= 0; i--) {      /* increment */
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d231 1
d268 1
a268 1
				SSL_R_UNSUPPORTED_DIGEST_TYPE);
d283 1
d302 1
a302 1
	s->session->master_key_length);
d350 3
a352 3
	s->s3->tmp.new_cipher->algorithm_mkey,
	s->s3->tmp.new_cipher->algorithm_auth,
	comp);
d355 1
a355 1
	c->nid, c->block_size, c->key_len, c->iv_len);
d455 1
a455 1
		(which == SSL3_CHANGE_CIPHER_SERVER_READ)) {
d487 1
a487 1
		mac_secret, *mac_secret_size);
d503 2
a504 2
		    NULL, 0, NULL, 0,
		    key, j, tmp1, tmp2, EVP_CIPHER_key_length(c)))
d513 1
a513 2
			    NULL, 0, NULL, 0,
			    empty, 0, iv1, iv2, k*2))
d535 1
a535 1
		EVP_CipherInit_ex(dd, c, NULL, key, NULL,(which & SSL3_CC_WRITE));
d538 1
a538 1
		EVP_CipherInit_ex(dd, c, NULL, key, iv,(which & SSL3_CC_WRITE));
d558 1
d776 1
a776 1
			ds, rec->data, rec->input, l);
d778 3
a780 3
			ds->buf_len, ds->cipher->key_len,
			DES_KEY_SZ, DES_SCHEDULE_SZ,
			ds->cipher->iv_len);
d796 2
a797 2
		if ((EVP_CIPHER_flags(ds->cipher) & EVP_CIPH_FLAG_CUSTOM_CIPHER) ?
		    (i < 0) : (i == 0))
d894 1
a894 1
	if (!tls1_PRF(ssl_get_algorithm2(s), str, slen, buf,(int)(q - buf),
d917 3
a919 1
	int stream_mac = (send ? (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM) : (ssl->mac_flags&SSL_MAC_FLAG_READ_MAC_STREAM));
d963 1
a963 1
	header[12] = (rec->length)&0xff;
d965 2
a966 1
	if (!send && EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
@


1.22
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d222 2
a223 3
		}
		else	/* last one */
		{
d271 4
a274 4
			if (!tls1_P_hash(md , S1, len + (slen&1),
				seed1, seed1_len, seed2, seed2_len, seed3, seed3_len, seed4, seed4_len, seed5, seed5_len,
			out2, olen))
			goto err;
d290 1
d292 6
a297 6
	TLS_MD_KEY_EXPANSION_CONST, TLS_MD_KEY_EXPANSION_CONST_SIZE,
	s->s3->server_random, SSL3_RANDOM_SIZE,
	s->s3->client_random, SSL3_RANDOM_SIZE,
	NULL, 0, NULL, 0,
	s->session->master_key, s->session->master_key_length,
	km, tmp, num);
d372 1
a372 1
		else
d374 2
a375 1
		EVP_CIPHER_CTX_init(s->enc_read_ctx);
d390 1
a390 2
				s->s3->rrec.comp = (unsigned char *)
			malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
d441 1
a441 1
	i=*mac_secret_size = s->s3->tmp.new_mac_secret_size;
d445 1
a445 1
	cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
d483 1
a483 1
	if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER)) {
d498 6
a503 6
			exp_label, exp_label_len,
		s->s3->client_random, SSL3_RANDOM_SIZE,
		s->s3->server_random, SSL3_RANDOM_SIZE,
		NULL, 0, NULL, 0,
		key, j, tmp1, tmp2, EVP_CIPHER_key_length(c)))
		goto err2;
d508 6
a513 6
				TLS_MD_IV_BLOCK_CONST, TLS_MD_IV_BLOCK_CONST_SIZE,
			s->s3->client_random, SSL3_RANDOM_SIZE,
			s->s3->server_random, SSL3_RANDOM_SIZE,
			NULL, 0, NULL, 0,
			empty, 0, iv1, iv2, k*2))
			goto err2;
d540 1
a540 1
	if ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)
d542 1
a542 1
	*mac_secret_size, mac_secret);
d591 1
a591 1
	num*=2;
d623 2
a624 2
	if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)
		&& s->method->version <= TLS1_VERSION) {
d681 2
a682 2
			if (s->version >= TLS1_1_VERSION
				&& EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)
d723 1
a723 1
		if (EVP_CIPHER_flags(ds->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER) {
d736 1
a736 4
				for (i = 7;
					i >= 0;
				i--)	/* increment */
				{
a739 1

d747 1
a747 1
			buf[12] = rec->length&0xff;
d794 3
a796 4
		if ((EVP_CIPHER_flags(ds->cipher)&EVP_CIPH_FLAG_CUSTOM_CIPHER)
			?(i < 0)
		:(i == 0))
		return -1;	/* AEAD can fail to verify MAC */
d835 2
a836 1
		if (s->s3->handshake_dgst[i]&&EVP_MD_CTX_type(s->s3->handshake_dgst[i]) == md_nid) {
d878 2
a879 1
			if (!hdgst || hashsize < 0 || hashsize > (int)(sizeof buf - (size_t)(q - buf))) {
d884 3
a886 3
					!EVP_DigestFinal_ex(&ctx, q, &i) ||
				(i != (unsigned int)hashsize))
				err = 1;
d892 5
a896 5
	if (!tls1_PRF(ssl_get_algorithm2(s),
		str, slen, buf,(int)(q - buf), NULL, 0, NULL, 0, NULL, 0,
	s->session->master_key, s->session->master_key_length,
	out, buf2, sizeof buf2))
	err = 1;
d945 1
a945 1
		memcpy (p, &seq[2], 6);
d961 2
a962 3
	if (!send &&
		EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
	ssl3_cbc_record_digest_supported(mac_ctx)) {
d967 6
a972 8
		ssl3_cbc_digest_record(
		mac_ctx,
		md, &md_size,
		header, rec->input,
		rec->length + md_size, orig_len,
		ssl->s3->read_mac_secret,
		ssl->s3->read_mac_secret_size,
		0 /* not SSLv3 */);
a997 1

d1111 2
a1112 1
		TLS_MD_CLIENT_FINISH_CONST_SIZE) == 0) goto err1;
d1114 2
a1115 1
		TLS_MD_SERVER_FINISH_CONST_SIZE) == 0) goto err1;
d1117 2
a1118 1
		TLS_MD_MASTER_SECRET_CONST_SIZE) == 0) goto err1;
d1120 2
a1121 1
		TLS_MD_KEY_EXPANSION_CONST_SIZE) == 0) goto err1;
d1124 1
a1124 5
	    val, vallen,
	    NULL, 0,
	    NULL, 0,
	    NULL, 0,
	    NULL, 0,
@


1.21
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok miod
@
text
@d370 1
a370 1
		else if ((s->enc_read_ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d390 1
a390 1
			OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
d595 1
a595 1
	if ((p1 = (unsigned char *)OPENSSL_malloc(num)) == NULL) {
d603 1
a603 1
	if ((p2 = (unsigned char *)OPENSSL_malloc(num)) == NULL) {
d645 1
a645 1
		OPENSSL_free(p2);
d1077 1
a1077 1
	buff = OPENSSL_malloc(olen);
d1091 1
a1091 1
	val = OPENSSL_malloc(vallen);
d1148 1
a1148 1
		OPENSSL_free(buff);
d1150 1
a1150 1
		OPENSSL_free(val);
@


1.20
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a983 7
#ifdef OPENSSL_FIPS
		if (!send && FIPS_mode())
			tls_fips_digest_extra(
		ssl->enc_read_ctx,
		mac_ctx, rec->input,
		rec->length, orig_len);
#endif
@


1.19
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d152 6
a157 9
static int tls1_P_hash(const EVP_MD *md, const unsigned char *sec,
			int sec_len,
			const void *seed1, int seed1_len,
			const void *seed2, int seed2_len,
			const void *seed3, int seed3_len,
			const void *seed4, int seed4_len,
			const void *seed5, int seed5_len,
			unsigned char *out, int olen)
	{
d165 2
a166 2
	
	chunk=EVP_MD_size(md);
d176 1
a176 1
	if (!EVP_DigestSignInit(&ctx,NULL,md, NULL, mac_key))
d178 1
a178 1
	if (!EVP_DigestSignInit(&ctx_tmp,NULL,md, NULL, mac_key))
d180 1
a180 1
	if (seed1 && !EVP_DigestSignUpdate(&ctx,seed1,seed1_len))
d182 1
a182 1
	if (seed2 && !EVP_DigestSignUpdate(&ctx,seed2,seed2_len))
d184 1
a184 1
	if (seed3 && !EVP_DigestSignUpdate(&ctx,seed3,seed3_len))
d186 1
a186 1
	if (seed4 && !EVP_DigestSignUpdate(&ctx,seed4,seed4_len))
d188 1
a188 1
	if (seed5 && !EVP_DigestSignUpdate(&ctx,seed5,seed5_len))
d190 1
a190 1
	if (!EVP_DigestSignFinal(&ctx,A1,&A1_len))
d193 1
a193 2
	for (;;)
		{
d195 1
a195 1
		if (!EVP_DigestSignInit(&ctx,NULL,md, NULL, mac_key))
d197 1
a197 1
		if (!EVP_DigestSignInit(&ctx_tmp,NULL,md, NULL, mac_key))
d199 1
a199 1
		if (!EVP_DigestSignUpdate(&ctx,A1,A1_len))
d201 1
a201 1
		if (!EVP_DigestSignUpdate(&ctx_tmp,A1,A1_len))
d203 1
a203 1
		if (seed1 && !EVP_DigestSignUpdate(&ctx,seed1,seed1_len))
d205 1
a205 1
		if (seed2 && !EVP_DigestSignUpdate(&ctx,seed2,seed2_len))
d207 1
a207 1
		if (seed3 && !EVP_DigestSignUpdate(&ctx,seed3,seed3_len))
d209 1
a209 1
		if (seed4 && !EVP_DigestSignUpdate(&ctx,seed4,seed4_len))
d211 1
a211 1
		if (seed5 && !EVP_DigestSignUpdate(&ctx,seed5,seed5_len))
d214 2
a215 3
		if (olen > chunk)
			{
			if (!EVP_DigestSignFinal(&ctx,out,&j))
d217 2
a218 2
			out+=j;
			olen-=j;
d220 1
a220 1
			if (!EVP_DigestSignFinal(&ctx_tmp,A1,&A1_len))
d222 1
a222 1
			}
d224 2
a225 2
			{
			if (!EVP_DigestSignFinal(&ctx,A1,&A1_len))
d227 1
a227 1
			memcpy(out,A1,olen);
a228 1
			}
d230 1
d236 1
a236 1
	OPENSSL_cleanse(A1,sizeof(A1));
d238 1
a238 1
	}
d241 7
a247 11
static int tls1_PRF(long digest_mask,
		     const void *seed1, int seed1_len,
		     const void *seed2, int seed2_len,
		     const void *seed3, int seed3_len,
		     const void *seed4, int seed4_len,
		     const void *seed5, int seed5_len,
		     const unsigned char *sec, int slen,
		     unsigned char *out1,
		     unsigned char *out2, int olen)
	{
	int len,i,idx,count;
d254 6
a259 5
	count=0;
	for (idx=0;ssl_get_handshake_digest(idx,&m,&md);idx++) {
		if ((m<<TLS1_PRF_DGST_SHIFT) & digest_mask) count++;
	}	
	len=slen/count;
d262 4
a265 4
	S1=sec;
	memset(out1,0,olen);
	for (idx=0;ssl_get_handshake_digest(idx,&m,&md);idx++) {
		if ((m<<TLS1_PRF_DGST_SHIFT) & digest_mask) {
d269 2
a270 1
				goto err;				
d272 7
a278 8
			if (!tls1_P_hash(md ,S1,len+(slen&1),
					seed1,seed1_len,seed2,seed2_len,seed3,seed3_len,seed4,seed4_len,seed5,seed5_len,
					out2,olen))
				goto err;
			S1+=len;
			for (i=0; i<olen; i++)
			{
				out1[i]^=out2[i];
d286 4
a289 3
static int tls1_generate_key_block(SSL *s, unsigned char *km,
	     unsigned char *tmp, int num)
	{
d292 6
a297 6
		 TLS_MD_KEY_EXPANSION_CONST,TLS_MD_KEY_EXPANSION_CONST_SIZE,
		 s->s3->server_random,SSL3_RANDOM_SIZE,
		 s->s3->client_random,SSL3_RANDOM_SIZE,
		 NULL,0,NULL,0,
		 s->session->master_key,s->session->master_key_length,
		 km,tmp,num);
d300 1
a300 1
                s->session->master_key_length);
d302 6
a307 6
        int i;
        for (i=0; i < s->session->master_key_length; i++)
                {
                printf("%02X", s->session->master_key[i]);
                }
        printf("\n");  }
d310 1
a310 1
	}
d312 3
a314 2
int tls1_change_cipher_state(SSL *s, int which)
	{
d316 1
a316 1
	unsigned char *p,*mac_secret;
d322 1
a322 1
	unsigned char *ms,*key,*iv;
d334 1
a334 1
	int is_export,n,i,j,k,exp_label_len,cl;
d337 3
a339 3
	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
	c=s->s3->tmp.new_sym_enc;
	m=s->s3->tmp.new_hash;
d342 1
a342 1
	comp=s->s3->tmp.new_compression;
d348 3
a350 3
	       s->s3->tmp.new_cipher->algorithm_mkey,
	       s->s3->tmp.new_cipher->algorithm_auth,
	       comp);
d353 1
a353 1
                c->nid,c->block_size,c->key_len,c->iv_len);
d356 4
a359 4
        int i;
        for (i=0; i<s->s3->tmp.key_block_length; i++)
		printf("%02x", s->s3->tmp.key_block[i]);  printf("\n");
        }
d362 1
a362 2
	if (which & SSL3_CC_READ)
		{
d370 1
a370 1
		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d374 3
a376 3
			EVP_CIPHER_CTX_init(s->enc_read_ctx);
		dd= s->enc_read_ctx;
		mac_ctx=ssl_replace_hash(&s->read_hash,NULL);
d378 1
a378 2
		if (s->expand != NULL)
			{
d380 7
a386 1
			s->expand=NULL;
a387 8
		if (comp != NULL)
			{
			s->expand=COMP_CTX_new(comp->method);
			if (s->expand == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
d389 2
a390 2
				s->s3->rrec.comp=(unsigned char *)
					OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
d393 1
a393 1
			}
d396 5
a400 7
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->read_sequence[0]),0,8);
		mac_secret= &(s->s3->read_mac_secret[0]);
		mac_secret_size=&(s->s3->read_mac_secret_size);
		}
	else
		{
d403 1
a403 1
			else
d407 1
a407 1
		else if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)
d409 2
a410 3
		dd= s->enc_write_ctx;
		if (SSL_IS_DTLS(s))
			{
d415 2
a416 3
			}
		else
			mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
d418 1
a418 2
		if (s->compress != NULL)
			{
d420 6
a425 8
			s->compress=NULL;
			}
		if (comp != NULL)
			{
			s->compress=COMP_CTX_new(comp->method);
			if (s->compress == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
a426 1
				}
d428 1
d431 3
a433 3
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->write_sequence[0]),0,8);
		mac_secret= &(s->s3->write_mac_secret[0]);
d435 1
a435 1
		}
d440 2
a441 2
	p=s->s3->tmp.key_block;
	i=*mac_secret_size=s->s3->tmp.new_mac_secret_size;
d443 3
a445 3
	cl=EVP_CIPHER_key_length(c);
	j=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
	               cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
d451 24
a474 21
		k=EVP_CIPHER_iv_length(c);
	if (	(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
		(which == SSL3_CHANGE_CIPHER_SERVER_READ))
		{
		ms=  &(p[ 0]); n=i+i;
		key= &(p[ n]); n+=j+j;
		iv=  &(p[ n]); n+=k+k;
		exp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;
		exp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;
		client_write=1;
		}
	else
		{
		n=i;
		ms=  &(p[ n]); n+=i+j;
		key= &(p[ n]); n+=j+k;
		iv=  &(p[ n]); n+=k;
		exp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;
		exp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;
		client_write=0;
		}
d476 2
a477 3
	if (n > s->s3->tmp.key_block_length)
		{
		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
d479 1
a479 1
		}
d481 1
a481 1
	memcpy(mac_secret,ms,i);
d483 1
a483 2
	if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))
		{
d485 2
a486 2
				mac_secret,*mac_secret_size);
		EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);
d488 1
a488 1
		}
d490 2
a491 2
printf("which = %04X\nmac key=",which);
{ int z; for (z=0; z<i; z++) printf("%02X%c",ms[z],((z+1)%16)?' ':'\n'); }
d493 1
a493 2
	if (is_export)
		{
d498 7
a504 7
				exp_label,exp_label_len,
				s->s3->client_random,SSL3_RANDOM_SIZE,
				s->s3->server_random,SSL3_RANDOM_SIZE,
				NULL,0,NULL,0,
				key,j,tmp1,tmp2,EVP_CIPHER_key_length(c)))
			goto err2;
		key=tmp1;
d506 1
a506 2
		if (k > 0)
			{
d508 6
a513 6
					TLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE,
					s->s3->client_random,SSL3_RANDOM_SIZE,
					s->s3->server_random,SSL3_RANDOM_SIZE,
					NULL,0,NULL,0,
					empty,0,iv1,iv2,k*2))
				goto err2;
d515 1
a515 1
				iv=iv1;
d517 1
a517 2
				iv= &(iv1[k]);
			}
d519 1
d521 1
a521 1
	s->session->key_arg_length=0;
d524 6
a529 6
        int i;
	printf("EVP_CipherInit_ex(dd,c,key=,iv=,which)\n");
	printf("\tkey= "); for (i=0; i<c->key_len; i++) printf("%02x", key[i]);
	printf("\n");
	printf("\t iv= "); for (i=0; i<c->iv_len; i++) printf("%02x", iv[i]);
	printf("\n");
d533 2
a534 3
	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		{
		EVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE));
d536 2
a537 3
		}
	else	
		EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));
d541 2
a542 2
		EVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY,
				*mac_secret_size,mac_secret);
d545 5
a549 5
printf("which = %04X\nkey=",which);
{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf("%02X%c",key[z],((z+1)%16)?' ':'\n'); }
printf("\niv=");
{ int z; for (z=0; z<k; z++) printf("%02X%c",iv[z],((z+1)%16)?' ':'\n'); }
printf("\n");
d552 5
a556 5
	OPENSSL_cleanse(tmp1,sizeof(tmp1));
	OPENSSL_cleanse(tmp2,sizeof(tmp1));
	OPENSSL_cleanse(iv1,sizeof(iv1));
	OPENSSL_cleanse(iv2,sizeof(iv2));
	return(1);
d558 1
a558 1
	SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);
d560 2
a561 2
	return(0);
	}
d563 4
a566 3
int tls1_setup_key_block(SSL *s)
	{
	unsigned char *p1,*p2=NULL;
d571 2
a572 2
	int mac_type= NID_undef,mac_secret_size=0;
	int ret=0;
d579 1
a579 1
		return(1);
d581 4
a584 5
	if (!ssl_cipher_get_evp(s->session,&c,&hash,&mac_type,&mac_secret_size,&comp))
		{
		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
		return(0);
		}
d586 2
a587 2
	s->s3->tmp.new_sym_enc=c;
	s->s3->tmp.new_hash=hash;
d590 1
a590 1
	num=EVP_CIPHER_key_length(c)+mac_secret_size+EVP_CIPHER_iv_length(c);
d595 2
a596 3
	if ((p1=(unsigned char *)OPENSSL_malloc(num)) == NULL)
		{
		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);
d598 1
a598 1
		}
d600 2
a601 2
	s->s3->tmp.key_block_length=num;
	s->s3->tmp.key_block=p1;
d603 2
a604 3
	if ((p2=(unsigned char *)OPENSSL_malloc(num)) == NULL)
		{
		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);
d606 1
a606 1
		}
d609 6
a614 6
printf("client random\n");
{ int z; for (z=0; z<SSL3_RANDOM_SIZE; z++) printf("%02X%c",s->s3->client_random[z],((z+1)%16)?' ':'\n'); }
printf("server random\n");
{ int z; for (z=0; z<SSL3_RANDOM_SIZE; z++) printf("%02X%c",s->s3->server_random[z],((z+1)%16)?' ':'\n'); }
printf("pre-master\n");
{ int z; for (z=0; z<s->session->master_key_length; z++) printf("%02X%c",s->session->master_key[z],((z+1)%16)?' ':'\n'); }
d616 1
a616 1
	if (!tls1_generate_key_block(s,p1,p2,num))
d619 2
a620 2
printf("\nkey block\n");
{ int z; for (z=0; z<num; z++) printf("%02X%c",p1[z],((z+1)%16)?' ':'\n'); }
d624 1
a624 2
		&& s->method->version <= TLS1_VERSION)
		{
d630 1
a630 2
		if (s->session->cipher != NULL)
			{
d633 1
a633 1
			
a637 1
			}
d639 2
a640 1
		
d643 2
a644 3
	if (p2)
		{
		OPENSSL_cleanse(p2,num);
a645 2
		}
	return(ret);
d647 2
d659 3
a661 2
int tls1_enc(SSL *s, int send)
	{
d665 1
a665 1
	int bs,i,j,k,pad=0,ret,mac_size=0;
d668 3
a670 5
	if (send)
		{
		if (EVP_MD_CTX_md(s->write_hash))
			{
			int n=EVP_MD_CTX_size(s->write_hash);
d672 3
a674 3
			}
		ds=s->enc_write_ctx;
		rec= &(s->s3->wrec);
d676 2
a677 3
			enc=NULL;
		else
			{
d679 1
a679 1
			enc=EVP_CIPHER_CTX_cipher(s->enc_write_ctx);
d686 2
a687 3
			if (ivlen > 1)
				{
				if ( rec->data != rec->input)
d692 2
a693 2
						"%s:%d: rec->data != rec->input\n",
						__FILE__, __LINE__);
a695 1
				}
d698 3
a700 5
	else
		{
		if (EVP_MD_CTX_md(s->read_hash))
			{
			int n=EVP_MD_CTX_size(s->read_hash);
d702 3
a704 3
			}
		ds=s->enc_read_ctx;
		rec= &(s->s3->rrec);
d706 1
a706 1
			enc=NULL;
d708 2
a709 2
			enc=EVP_CIPHER_CTX_cipher(s->enc_read_ctx);
		}
d715 3
a717 4
	if ((s->session == NULL) || (ds == NULL) || (enc == NULL))
		{
		memmove(rec->data,rec->input,rec->length);
		rec->input=rec->data;
d719 20
a738 13
		}
	else
		{
		l=rec->length;
		bs=EVP_CIPHER_block_size(ds->cipher);

		if (EVP_CIPHER_flags(ds->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)
			{
			unsigned char buf[13],*seq;

			seq = send?s->s3->write_sequence:s->s3->read_sequence;

			if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)
d740 3
a742 1
				unsigned char dtlsseq[9],*p=dtlsseq;
a743 12
				s2n(send?s->d1->w_epoch:s->d1->r_epoch,p);
				memcpy(p,&seq[2],6);
				memcpy(buf,dtlsseq,8);
				}
			else
				{
				memcpy(buf,seq,8);
				for (i=7; i>=0; i--)	/* increment */
					{
					++seq[i];
					if (seq[i] != 0) break; 
					}
d745 1
d747 9
a755 11
			buf[8]=rec->type;
			buf[9]=(unsigned char)(s->version>>8);
			buf[10]=(unsigned char)(s->version);
			buf[11]=rec->length>>8;
			buf[12]=rec->length&0xff;
			pad=EVP_CIPHER_CTX_ctrl(ds,EVP_CTRL_AEAD_TLS1_AAD,13,buf);
			if (send)
				{
				l+=pad;
				rec->length+=pad;
				}
d757 2
a758 3
		else if ((bs != 1) && send)
			{
			i=bs-((int)l%bs);
d763 2
a764 3
			j=i-1;
			if (s->options & SSL_OP_TLS_BLOCK_PADDING_BUG)
				{
a766 5
				}
			for (k=(int)l; k<(int)(l+i); k++)
				rec->input[k]=j;
			l+=i;
			rec->length+=i;
d768 5
d776 4
a779 4
		unsigned long ui;
		printf("EVP_Cipher(ds=%p,rec->data=%p,rec->input=%p,l=%ld) ==>\n",
			ds,rec->data,rec->input,l);
		printf("\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%d %d], %d iv_len\n",
d783 6
a788 6
		printf("\t\tIV: ");
		for (i=0; i<ds->cipher->iv_len; i++) printf("%02X", ds->iv[i]);
		printf("\n");
		printf("\trec->input=");
		for (ui=0; ui<l; ui++) printf(" %02x", rec->input[ui]);
		printf("\n");
d792 2
a793 3
		if (!send)
			{
			if (l == 0 || l%bs != 0)
d795 3
a797 3
			}
		
		i = EVP_Cipher(ds,rec->data,rec->input,l);
d799 4
a802 5
						?(i<0)
						:(i==0))
			return -1;	/* AEAD can fail to verify MAC */
		if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE && !send)
			{
d806 1
a806 1
			}
d810 4
a813 4
		unsigned long i;
		printf("\trec->data=");
		for (i=0; i<l; i++)
			printf(" %02x", rec->data[i]);  printf("\n");
d824 1
a824 1
		}
d826 1
a826 1
	}
d828 3
a830 2
int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *out)
	{
d832 1
a832 1
	EVP_MD_CTX ctx, *d=NULL;
d835 1
a835 1
	if (s->s3->handshake_buffer) 
d839 3
a841 5
	for (i=0;i<SSL_MAX_DIGEST;i++) 
		{
		  if (s->s3->handshake_dgst[i]&&EVP_MD_CTX_type(s->s3->handshake_dgst[i])==md_nid) 
		  	{
		  	d=s->s3->handshake_dgst[i];
a842 1
			}
d844 1
d846 1
a846 1
		SSLerr(SSL_F_TLS1_CERT_VERIFY_MAC,SSL_R_NO_REQUIRED_DIGEST);
d848 1
a848 1
	}	
d851 2
a852 2
	EVP_MD_CTX_copy_ex(&ctx,d);
	EVP_DigestFinal_ex(&ctx,out,&ret);
d854 2
a855 2
	return((int)ret);
	}
d857 3
a859 3
int tls1_final_finish_mac(SSL *s,
	     const char *str, int slen, unsigned char *out)
	{
d863 1
a863 1
	unsigned char *q,buf2[12];
d866 3
a868 2
	int err=0;
	const EVP_MD *md; 
d870 1
a870 1
	q=buf;
d872 1
a872 1
	if (s->s3->handshake_buffer) 
d878 2
a879 4
	for (idx=0;ssl_get_handshake_digest(idx,&mask,&md);idx++)
		{
		if (mask & ssl_get_algorithm2(s))
			{
d882 1
a882 2
			if (!hdgst || hashsize < 0 || hashsize > (int)(sizeof buf - (size_t)(q-buf)))
				{
d885 1
a885 3
				}
			else
				{
d887 4
a890 5
					!EVP_DigestFinal_ex(&ctx,q,&i) ||
					(i != (unsigned int)hashsize))
					err = 1;
				q+=hashsize;
				}
d893 2
a894 1
		
d896 4
a899 4
			str,slen, buf,(int)(q-buf), NULL,0, NULL,0, NULL,0,
			s->session->master_key,s->session->master_key_length,
			out,buf2,sizeof buf2))
		err = 1;
d906 1
a906 1
	}
d908 3
a910 2
int tls1_mac(SSL *ssl, unsigned char *md, int send)
	{
d918 1
a918 1
	int stream_mac = (send?(ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM):(ssl->mac_flags&SSL_MAC_FLAG_READ_MAC_STREAM));
d921 9
a929 12
	if (send)
		{
		rec= &(ssl->s3->wrec);
		seq= &(ssl->s3->write_sequence[0]);
		hash=ssl->write_hash;
		}
	else
		{
		rec= &(ssl->s3->rrec);
		seq= &(ssl->s3->read_sequence[0]);
		hash=ssl->read_hash;
		}
d931 1
a931 1
	t=EVP_MD_CTX_size(hash);
d933 1
a933 1
	md_size=t;
d936 7
a942 10
	if (stream_mac) 
		{
			mac_ctx = hash;
		}
		else
		{
			if (!EVP_MD_CTX_copy(&hmac,hash))
				return -1;
			mac_ctx = &hmac;
		}
d944 2
a945 3
	if (ssl->version == DTLS1_VERSION || ssl->version == DTLS1_BAD_VER)
		{
		unsigned char dtlsseq[8],*p=dtlsseq;
d947 2
a948 2
		s2n(send?ssl->d1->w_epoch:ssl->d1->r_epoch, p);
		memcpy (p,&seq[2],6);
d951 1
a951 2
		}
	else
d955 1
a955 1
	orig_len = rec->length+md_size+((unsigned int)rec->type>>8);
d958 5
a962 5
	header[8]=rec->type;
	header[9]=(unsigned char)(ssl->version>>8);
	header[10]=(unsigned char)(ssl->version);
	header[11]=(rec->length)>>8;
	header[12]=(rec->length)&0xff;
d965 2
a966 3
	    EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
	    ssl3_cbc_record_digest_supported(mac_ctx))
		{
d972 11
a982 13
			mac_ctx,
			md, &md_size,
			header, rec->input,
			rec->length + md_size, orig_len,
			ssl->s3->read_mac_secret,
			ssl->s3->read_mac_secret_size,
			0 /* not SSLv3 */);
		}
	else
		{
		EVP_DigestSignUpdate(mac_ctx,header,sizeof(header));
		EVP_DigestSignUpdate(mac_ctx,rec->input,rec->length);
		t=EVP_DigestSignFinal(mac_ctx,md,&md_size);
d987 3
a989 3
	    				ssl->enc_read_ctx,
					mac_ctx, rec->input,
					rec->length, orig_len);
d991 2
a992 2
		}
		
d996 8
a1003 8
printf("sec=");
{unsigned int z; for (z=0; z<md_size; z++) printf("%02X ",mac_sec[z]); printf("\n"); }
printf("seq=");
{int z; for (z=0; z<8; z++) printf("%02X ",seq[z]); printf("\n"); }
printf("buf=");
{int z; for (z=0; z<5; z++) printf("%02X ",buf[z]); printf("\n"); }
printf("rec=");
{unsigned int z; for (z=0; z<rec->length; z++) printf("%02X ",buf[z]); printf("\n"); }
d1006 2
a1007 4
	if (ssl->version != DTLS1_VERSION && ssl->version != DTLS1_BAD_VER)
		{
		for (i=7; i>=0; i--)
			{
d1009 3
a1011 2
			if (seq[i] != 0) break; 
			}
d1013 1
d1016 1
a1016 1
{unsigned int z; for (z=0; z<md_size; z++) printf("%02X ",md[z]); printf("\n"); }
d1018 2
a1019 2
	return(md_size);
	}
d1021 4
a1024 3
int tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
	     int len)
	{
d1031 1
a1031 1
	printf ("tls1_generate_master_secret(%p,%p, %p, %d)\n", s,out, p,len);
d1037 1
a1037 2
	    s->s3->client_opaque_prf_input_len == s->s3->server_opaque_prf_input_len)
		{
d1042 1
a1042 1
		}
d1046 7
a1052 7
		TLS_MD_MASTER_SECRET_CONST,TLS_MD_MASTER_SECRET_CONST_SIZE,
		s->s3->client_random,SSL3_RANDOM_SIZE,
		co, col,
		s->s3->server_random,SSL3_RANDOM_SIZE,
		so, sol,
		p,len,
		s->session->master_key,buff,sizeof buff);
d1067 2
a1068 2
	return(SSL3_MASTER_SECRET_SIZE);
	}
d1070 5
a1074 4
int tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,
	 const char *label, size_t llen, const unsigned char *context,
	 size_t contextlen, int use_context)
	{
d1085 2
a1086 1
	if (buff == NULL) goto err2;
d1094 1
a1094 2
	if (use_context)
		{
d1096 1
a1096 1
		}
d1099 2
a1100 1
	if (val == NULL) goto err2;
d1109 1
a1109 2
	if (use_context)
		{
d1114 1
a1114 2
		if ((contextlen > 0) || (context != NULL))
			{
a1115 1
			}
d1117 1
d1125 1
a1125 1
		 TLS_MD_CLIENT_FINISH_CONST_SIZE) == 0) goto err1;
d1127 1
a1127 1
		 TLS_MD_SERVER_FINISH_CONST_SIZE) == 0) goto err1;
d1129 1
a1129 1
		 TLS_MD_MASTER_SECRET_CONST_SIZE) == 0) goto err1;
d1131 1
a1131 1
		 TLS_MD_KEY_EXPANSION_CONST_SIZE) == 0) goto err1;
d1134 7
a1140 7
		      val, vallen,
		      NULL, 0,
		      NULL, 0,
		      NULL, 0,
		      NULL, 0,
		      s->session->master_key,s->session->master_key_length,
		      out,buff,olen);
d1154 6
a1159 4
	if (buff != NULL) OPENSSL_free(buff);
	if (val != NULL) OPENSSL_free(val);
	return(rv);
	}
d1161 64
a1224 34
int tls1_alert_code(int code)
	{
	switch (code)
		{
	case SSL_AD_CLOSE_NOTIFY:	return(SSL3_AD_CLOSE_NOTIFY);
	case SSL_AD_UNEXPECTED_MESSAGE:	return(SSL3_AD_UNEXPECTED_MESSAGE);
	case SSL_AD_BAD_RECORD_MAC:	return(SSL3_AD_BAD_RECORD_MAC);
	case SSL_AD_DECRYPTION_FAILED:	return(TLS1_AD_DECRYPTION_FAILED);
	case SSL_AD_RECORD_OVERFLOW:	return(TLS1_AD_RECORD_OVERFLOW);
	case SSL_AD_DECOMPRESSION_FAILURE:return(SSL3_AD_DECOMPRESSION_FAILURE);
	case SSL_AD_HANDSHAKE_FAILURE:	return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_NO_CERTIFICATE:	return(-1);
	case SSL_AD_BAD_CERTIFICATE:	return(SSL3_AD_BAD_CERTIFICATE);
	case SSL_AD_UNSUPPORTED_CERTIFICATE:return(SSL3_AD_UNSUPPORTED_CERTIFICATE);
	case SSL_AD_CERTIFICATE_REVOKED:return(SSL3_AD_CERTIFICATE_REVOKED);
	case SSL_AD_CERTIFICATE_EXPIRED:return(SSL3_AD_CERTIFICATE_EXPIRED);
	case SSL_AD_CERTIFICATE_UNKNOWN:return(SSL3_AD_CERTIFICATE_UNKNOWN);
	case SSL_AD_ILLEGAL_PARAMETER:	return(SSL3_AD_ILLEGAL_PARAMETER);
	case SSL_AD_UNKNOWN_CA:		return(TLS1_AD_UNKNOWN_CA);
	case SSL_AD_ACCESS_DENIED:	return(TLS1_AD_ACCESS_DENIED);
	case SSL_AD_DECODE_ERROR:	return(TLS1_AD_DECODE_ERROR);
	case SSL_AD_DECRYPT_ERROR:	return(TLS1_AD_DECRYPT_ERROR);
	case SSL_AD_EXPORT_RESTRICTION:	return(TLS1_AD_EXPORT_RESTRICTION);
	case SSL_AD_PROTOCOL_VERSION:	return(TLS1_AD_PROTOCOL_VERSION);
	case SSL_AD_INSUFFICIENT_SECURITY:return(TLS1_AD_INSUFFICIENT_SECURITY);
	case SSL_AD_INTERNAL_ERROR:	return(TLS1_AD_INTERNAL_ERROR);
	case SSL_AD_USER_CANCELLED:	return(TLS1_AD_USER_CANCELLED);
	case SSL_AD_NO_RENEGOTIATION:	return(TLS1_AD_NO_RENEGOTIATION);
	case SSL_AD_UNSUPPORTED_EXTENSION: return(TLS1_AD_UNSUPPORTED_EXTENSION);
	case SSL_AD_CERTIFICATE_UNOBTAINABLE: return(TLS1_AD_CERTIFICATE_UNOBTAINABLE);
	case SSL_AD_UNRECOGNIZED_NAME:	return(TLS1_AD_UNRECOGNIZED_NAME);
	case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE: return(TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE);
	case SSL_AD_BAD_CERTIFICATE_HASH_VALUE: return(TLS1_AD_BAD_CERTIFICATE_HASH_VALUE);
	case SSL_AD_UNKNOWN_PSK_IDENTITY:return(TLS1_AD_UNKNOWN_PSK_IDENTITY);
d1226 2
a1227 2
	case DTLS1_AD_MISSING_HANDSHAKE_MESSAGE: return 
					  (DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
d1229 2
a1230 2
	default:			return(-1);
		}
d1232 1
@


1.18
log
@SECURITY fixes backported from openssl-1.0.1f.  ok mikeb@@

CVE-2013-4353 NULL pointer dereference with crafted Next Protocol
 Negotiation record in TLS handshake.
Upstream: 197e0ea

CVE-2013-6449 Fix crash with crafted traffic from a TLS 1.2 client.
Upstream: ca98926, 0294b2b

CVE-2013-6450 Fix DTLS retransmission from previous session.
Upstream: 3462896
@
text
@d364 1
a364 1
		printf("%02x", key_block[i]);  printf("\n");
d430 1
a430 1
		       mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
d932 2
a933 2
				    !EVP_DigestFinal_ex(&ctx,q,&i) ||
				    (i != (unsigned int)hashsize))
d989 2
a990 1
			EVP_MD_CTX_copy(&hmac,hash);
@


1.17
log
@cherry pick bugfixes for http://www.openssl.org/news/secadv_20130205.txt
from the openssl git (changes between openssl 1.0.1c and 1.0.1d).
ok djm@@
@
text
@d417 1
a417 1
		if (s->enc_write_ctx != NULL)
d419 1
a419 1
		else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d421 8
d430 1
a430 4
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_write_ctx);
		dd= s->enc_write_ctx;
		mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
d923 2
a924 1
			if (hashsize < 0 || hashsize > (int)(sizeof buf - (size_t)(q-buf)))
d931 3
a933 3
				EVP_MD_CTX_copy_ex(&ctx,s->s3->handshake_dgst[idx]);
				EVP_DigestFinal_ex(&ctx,q,&i);
				if (i != (unsigned int)hashsize) /* can't really happen */
d935 1
a935 1
				q+=i;
@


1.16
log
@resolve conflicts
@
text
@d670 9
d684 1
a684 1
	int bs,i,ii,j,k,pad=0;
d741 1
a741 2
	if ((s->session == NULL) || (ds == NULL) ||
		(enc == NULL))
d745 1
d809 1
a809 1
                unsigned long ui;
d811 1
a811 1
                        ds,rec->data,rec->input,l);
d813 3
a815 3
                        ds->buf_len, ds->cipher->key_len,
                        DES_KEY_SZ, DES_SCHEDULE_SZ,
                        ds->cipher->iv_len);
a827 5
				{
				if (s->version >= TLS1_1_VERSION)
					return -1;
				SSLerr(SSL_F_TLS1_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);
a828 1
				}
d845 2
a846 2
                unsigned long i;
                printf("\trec->data=");
d848 2
a849 2
                        printf(" %02x", rec->data[i]);  printf("\n");
                }
d852 3
d856 1
a856 49
			{
			ii=i=rec->data[l-1]; /* padding_length */
			i++;
			/* NB: if compression is in operation the first packet
			 * may not be of even length so the padding bug check
			 * cannot be performed. This bug workaround has been
			 * around since SSLeay so hopefully it is either fixed
			 * now or no buggy implementation supports compression 
			 * [steve]
			 */
			if ( (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG)
				&& !s->expand)
				{
				/* First packet is even in size, so check */
				if ((memcmp(s->s3->read_sequence,
					"\0\0\0\0\0\0\0\0",8) == 0) && !(ii & 1))
					s->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;
				if (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)
					i--;
				}
			/* TLS 1.0 does not bound the number of padding bytes by the block size.
			 * All of them must have value 'padding_length'. */
			if (i > (int)rec->length)
				{
				/* Incorrect padding. SSLerr() and ssl3_alert are done
				 * by caller: we don't want to reveal whether this is
				 * a decryption error or a MAC verification failure
				 * (see http://www.openssl.org/~bodo/tls-cbc.txt) */
				return -1;
				}
			for (j=(int)(l-i); j<(int)l; j++)
				{
				if (rec->data[j] != ii)
					{
					/* Incorrect padding */
					return -1;
					}
				}
			rec->length -=i;
			if (s->version >= TLS1_1_VERSION
				&& EVP_CIPHER_CTX_mode(ds) == EVP_CIPH_CBC_MODE)
				{
				if (bs > (int)rec->length)
					return -1;
				rec->data += bs;    /* skip the explicit IV */
				rec->input += bs;
				rec->length -= bs;
				}
			}
d860 1
a860 1
	return(1);
d862 1
d952 1
a952 1
	size_t md_size;
d955 1
a955 1
	unsigned char buf[5]; 
a975 6
	buf[0]=rec->type;
	buf[1]=(unsigned char)(ssl->version>>8);
	buf[2]=(unsigned char)(ssl->version);
	buf[3]=rec->length>>8;
	buf[4]=rec->length&0xff;

d994 1
a994 1
		EVP_DigestSignUpdate(mac_ctx,dtlsseq,8);
d997 1
a997 1
		EVP_DigestSignUpdate(mac_ctx,seq,8);
d999 41
a1039 4
	EVP_DigestSignUpdate(mac_ctx,buf,5);
	EVP_DigestSignUpdate(mac_ctx,rec->input,rec->length);
	t=EVP_DigestSignFinal(mac_ctx,md,&md_size);
	OPENSSL_assert(t > 0);
d1041 2
a1042 1
	if (!stream_mac) EVP_MD_CTX_cleanup(&hmac);
@


1.15
log
@openssl-1.0.0e: resolve conflicts
@
text
@d146 1
d162 3
a164 3
	unsigned int j;
	HMAC_CTX ctx;
	HMAC_CTX ctx_tmp;
d166 1
a166 1
	unsigned int A1_len;
d172 6
a177 3
	HMAC_CTX_init(&ctx);
	HMAC_CTX_init(&ctx_tmp);
	if (!HMAC_Init_ex(&ctx,sec,sec_len,md, NULL))
d179 1
a179 1
	if (!HMAC_Init_ex(&ctx_tmp,sec,sec_len,md, NULL))
d181 1
a181 1
	if (seed1 != NULL && !HMAC_Update(&ctx,seed1,seed1_len))
d183 1
a183 1
	if (seed2 != NULL && !HMAC_Update(&ctx,seed2,seed2_len))
d185 1
a185 1
	if (seed3 != NULL && !HMAC_Update(&ctx,seed3,seed3_len))
d187 1
a187 1
	if (seed4 != NULL && !HMAC_Update(&ctx,seed4,seed4_len))
d189 1
a189 1
	if (seed5 != NULL && !HMAC_Update(&ctx,seed5,seed5_len))
d191 3
a193 1
	if (!HMAC_Final(&ctx,A1,&A1_len))
d198 2
a199 1
		if (!HMAC_Init_ex(&ctx,NULL,0,NULL,NULL)) /* re-init */
d201 1
a201 1
		if (!HMAC_Init_ex(&ctx_tmp,NULL,0,NULL,NULL)) /* re-init */
d203 1
a203 1
		if (!HMAC_Update(&ctx,A1,A1_len))
d205 1
a205 1
		if (!HMAC_Update(&ctx_tmp,A1,A1_len))
d207 1
a207 1
		if (seed1 != NULL && !HMAC_Update(&ctx,seed1,seed1_len))
d209 1
a209 1
		if (seed2 != NULL && !HMAC_Update(&ctx,seed2,seed2_len))
d211 1
a211 1
		if (seed3 != NULL && !HMAC_Update(&ctx,seed3,seed3_len))
d213 1
a213 1
		if (seed4 != NULL && !HMAC_Update(&ctx,seed4,seed4_len))
d215 1
a215 1
		if (seed5 != NULL && !HMAC_Update(&ctx,seed5,seed5_len))
d220 1
a220 1
			if (!HMAC_Final(&ctx,out,&j))
d224 2
a225 1
			if (!HMAC_Final(&ctx_tmp,A1,&A1_len)) /* calc the next A1 value */
d230 1
a230 1
			if (!HMAC_Final(&ctx,A1,&A1_len))
d238 3
a240 2
	HMAC_CTX_cleanup(&ctx);
	HMAC_CTX_cleanup(&ctx_tmp);
d268 2
d298 1
a298 1
	ret = tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
d372 1
a372 1
			else
d459 5
a463 1
	k=EVP_CIPHER_iv_length(c);
d492 8
a499 4
	mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
			mac_secret,*mac_secret_size);
	EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);
	EVP_PKEY_free(mac_key);
d509 1
a509 1
		if (!tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
d520 1
a520 1
			if (!tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
d546 13
a558 1
	EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));
d640 2
a641 1
	if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
d675 1
a675 1
	int bs,i,ii,j,k,n=0;
d682 1
a682 1
			n=EVP_MD_CTX_size(s->write_hash);
d690 2
d693 19
d717 1
a717 1
			n=EVP_MD_CTX_size(s->read_hash);
d743 37
a779 1
		if ((bs != 1) && send)
d820 2
d828 11
a838 1
		EVP_Cipher(ds,rec->data,rec->input,l);
d888 10
a897 1
			rec->length-=i;
d899 2
d956 1
a956 1
		if (mask & s->s3->tmp.new_cipher->algorithm2)
d975 1
a975 1
	if (!tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
d1085 1
d1102 1
a1102 1
	tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
d1110 10
d1127 89
a1256 1

@


1.14
log
@resolve conflicts, fix local changes
@
text
@d160 1
a160 1
	int chunk,n;
a189 1
	n=0;
d311 1
a311 1
	unsigned char *p,*key_block,*mac_secret;
d317 1
a317 1
	unsigned char *ms,*key,*iv,*er1,*er2;
a338 1
	key_block=s->s3->tmp.key_block;
a448 2
	er1= &(s->s3->client_random[0]);
	er2= &(s->s3->server_random[0]);
d879 1
a879 1
	unsigned char *mac_sec,*seq;
a890 1
		mac_sec= &(ssl->s3->write_mac_secret[0]);
a896 1
		mac_sec= &(ssl->s3->read_mac_secret[0]);
@


1.13
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
d111 26
d150 8
a157 2
static void tls1_P_hash(const EVP_MD *md, const unsigned char *sec,
			int sec_len, unsigned char *seed, int seed_len,
d166 1
d169 1
d173 16
a188 6
	HMAC_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
	HMAC_CTX_set_flags(&ctx_tmp, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
	HMAC_Init_ex(&ctx,sec,sec_len,md, NULL);
	HMAC_Init_ex(&ctx_tmp,sec,sec_len,md, NULL);
	HMAC_Update(&ctx,seed,seed_len);
	HMAC_Final(&ctx,A1,&A1_len);
d193 18
a210 5
		HMAC_Init_ex(&ctx,NULL,0,NULL,NULL); /* re-init */
		HMAC_Init_ex(&ctx_tmp,NULL,0,NULL,NULL); /* re-init */
		HMAC_Update(&ctx,A1,A1_len);
		HMAC_Update(&ctx_tmp,A1,A1_len);
		HMAC_Update(&ctx,seed,seed_len);
d214 2
a215 1
			HMAC_Final(&ctx,out,&j);
d218 2
a219 1
			HMAC_Final(&ctx_tmp,A1,&A1_len); /* calc the next A1 value */
d223 2
a224 1
			HMAC_Final(&ctx,A1,&A1_len);
d229 2
d234 1
d237 9
a245 3
static void tls1_PRF(const EVP_MD *md5, const EVP_MD *sha1,
		     unsigned char *label, int label_len,
		     const unsigned char *sec, int slen, unsigned char *out1,
d248 12
a259 4
	int len,i;
	const unsigned char *S1,*S2;

	len=slen/2;
d261 18
a278 9
	S2= &(sec[len]);
	len+=(slen&1); /* add for odd, make longer */

	
	tls1_P_hash(md5 ,S1,len,label,label_len,out1,olen);
	tls1_P_hash(sha1,S2,len,label,label_len,out2,olen);

	for (i=0; i<olen; i++)
		out1[i]^=out2[i];
d280 5
a284 2

static void tls1_generate_key_block(SSL *s, unsigned char *km,
d287 6
a292 14
	unsigned char *p;
	unsigned char buf[SSL3_RANDOM_SIZE*2+
		TLS_MD_MAX_CONST_SIZE];
	p=buf;

	memcpy(p,TLS_MD_KEY_EXPANSION_CONST,
		TLS_MD_KEY_EXPANSION_CONST_SIZE);
	p+=TLS_MD_KEY_EXPANSION_CONST_SIZE;
	memcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);
	p+=SSL3_RANDOM_SIZE;
	memcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);
	p+=SSL3_RANDOM_SIZE;

	tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(p-buf),
d306 1
d313 1
a313 2
	unsigned char *exp_label,buf[TLS_MD_MAX_CONST_SIZE+
		SSL3_RANDOM_SIZE*2];
d326 4
d336 1
d344 5
a348 3
	printf("\talg= %ld, comp= %p\n", s->s3->tmp.new_cipher->algorithms,
                (void *)comp);
	printf("\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n", (void *)c);
d353 3
a355 3
        int ki;
        for (ki=0; ki<s->s3->tmp.key_block_length; ki++)
		printf("%02x", key_block[ki]);  printf("\n");
d361 5
d374 1
a374 1
		s->read_hash=m;
d400 1
d404 4
d416 1
a416 1
		s->write_hash=m;
d437 1
d444 2
a445 1
	i=EVP_MD_size(m);
d481 4
d494 7
a500 9
		p=buf;
		memcpy(p,exp_label,exp_label_len);
		p+=exp_label_len;
		memcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);
		p+=SSL3_RANDOM_SIZE;
		memcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);
		p+=SSL3_RANDOM_SIZE;
		tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(p-buf),key,j,
			 tmp1,tmp2,EVP_CIPHER_key_length(c));
d505 7
a511 10
			p=buf;
			memcpy(p,TLS_MD_IV_BLOCK_CONST,
				TLS_MD_IV_BLOCK_CONST_SIZE);
			p+=TLS_MD_IV_BLOCK_CONST_SIZE;
			memcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);
			p+=SSL3_RANDOM_SIZE;
			memcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);
			p+=SSL3_RANDOM_SIZE;
			tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,p-buf,empty,0,
				 iv1,iv2,k*2);
d522 1
a522 1
        int ki;
d524 1
a524 2
	printf("\tkey= ");
	for (ki=0; ki<c->key_len; ki++) printf("%02x", key[ki]);
d526 1
a526 2
	printf("\t iv= ");
	for (ki=0; ki<c->iv_len; ki++) printf("%02x", iv[ki]);
d553 1
a553 1
	unsigned char *p1,*p2;
d558 2
d568 1
a568 1
	if (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))
d576 3
a578 2

	num=EVP_CIPHER_key_length(c)+EVP_MD_size(hash)+EVP_CIPHER_iv_length(c);
d584 2
d587 1
a587 2
	if ((p2=(unsigned char *)OPENSSL_malloc(num)) == NULL)
		goto err;
d592 5
d606 2
a607 3
	tls1_generate_key_block(s,p1,p2,num);
	OPENSSL_cleanse(p2,num);
	OPENSSL_free(p2);
d622 1
a622 1
			if ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_eNULL)
d626 1
a626 1
			if ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_RC4)
d632 1
a632 1
	return(1);
d634 6
a639 2
	SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);
	return(0);
d652 5
a656 2
		if (s->write_hash != NULL)
			n=EVP_MD_size(s->write_hash);
d666 5
a670 2
		if (s->read_hash != NULL)
			n=EVP_MD_size(s->read_hash);
d717 2
a718 2
                        (void *)ds,rec->data,rec->input,l);
		printf("\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%ld %ld], %d iv_len\n",
d720 1
a720 2
                        (unsigned long)DES_KEY_SZ,
			(unsigned long)DES_SCHEDULE_SZ,
d745 1
a745 1
                unsigned long ki;
d747 2
a748 2
		for (ki=0; ki<l; i++)
                        printf(" %02x", rec->data[ki]);  printf("\n");
d796 1
a796 2

int tls1_cert_verify_mac(SSL *s, EVP_MD_CTX *in_ctx, unsigned char *out)
d799 19
a817 1
	EVP_MD_CTX ctx;
d820 1
a820 1
	EVP_MD_CTX_copy_ex(&ctx,in_ctx);
d826 1
a826 1
int tls1_final_finish_mac(SSL *s, EVP_MD_CTX *in1_ctx, EVP_MD_CTX *in2_ctx,
d831 1
a831 1
	unsigned char buf[TLS_MD_MAX_CONST_SIZE+MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];
d833 4
d839 4
a842 2
	memcpy(q,str,slen);
	q+=slen;
d845 27
a871 10
	EVP_MD_CTX_copy_ex(&ctx,in1_ctx);
	EVP_DigestFinal_ex(&ctx,q,&i);
	q+=i;
	EVP_MD_CTX_copy_ex(&ctx,in2_ctx);
	EVP_DigestFinal_ex(&ctx,q,&i);
	q+=i;

	tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(q-buf),
		s->session->master_key,s->session->master_key_length,
		out,buf2,sizeof buf2);
d874 4
a877 1
	return sizeof buf2;
d884 2
a885 2
	const EVP_MD *hash;
	unsigned int md_size;
d887 1
a887 1
	HMAC_CTX hmac;
d889 2
d907 3
a909 1
	md_size=EVP_MD_size(hash);
d912 2
a913 10
	if (ssl->version == DTLS1_VERSION && ssl->client_version == DTLS1_BAD_VER)
		{
		buf[1]=TLS1_VERSION_MAJOR;
		buf[2]=TLS1_VERSION_MINOR;
		}
	else	{
		buf[1]=(unsigned char)(ssl->version>>8);
		buf[2]=(unsigned char)(ssl->version);
		}

d918 9
a926 2
	HMAC_CTX_init(&hmac);
	HMAC_Init_ex(&hmac,mac_sec,EVP_MD_size(hash),hash,NULL);
d928 1
a928 1
	if (ssl->version == DTLS1_VERSION && ssl->client_version != DTLS1_BAD_VER)
d935 1
a935 1
		HMAC_Update(&hmac,dtlsseq,8);
d938 1
a938 6
		HMAC_Update(&hmac,seq,8);

	HMAC_Update(&hmac,buf,5);
	HMAC_Update(&hmac,rec->input,rec->length);
	HMAC_Final(&hmac,md,&md_size);
	HMAC_CTX_cleanup(&hmac);
d940 6
d957 1
a957 1
	if ( SSL_version(ssl) != DTLS1_VERSION)
a974 1
	unsigned char buf[SSL3_RANDOM_SIZE*2+TLS_MD_MASTER_SECRET_CONST_SIZE];
d976 2
d980 1
a980 1
	printf ("tls1_generate_master_secret(%p,%p, %p, %d)\n", (void *)s,out, p,len);
d983 19
a1001 9
	/* Setup the stuff to munge */
	memcpy(buf,TLS_MD_MASTER_SECRET_CONST,
		TLS_MD_MASTER_SECRET_CONST_SIZE);
	memcpy(&(buf[TLS_MD_MASTER_SECRET_CONST_SIZE]),
		s->s3->client_random,SSL3_RANDOM_SIZE);
	memcpy(&(buf[SSL3_RANDOM_SIZE+TLS_MD_MASTER_SECRET_CONST_SIZE]),
		s->s3->server_random,SSL3_RANDOM_SIZE);
	tls1_PRF(s->ctx->md5,s->ctx->sha1,
		buf,TLS_MD_MASTER_SECRET_CONST_SIZE+SSL3_RANDOM_SIZE*2,p,len,
d1003 1
d1038 7
a1044 1
#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
@


1.12
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d114 1
d116 1
d120 3
d259 2
a260 2
                comp);
	printf("\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n", c);
d265 3
a267 3
        int i;
        for (i=0; i<s->s3->tmp.key_block_length; i++)
		printf("%02x", key_block[i]);  printf("\n");
d423 1
a423 1
        int i;
d425 2
a426 1
	printf("\tkey= "); for (i=0; i<c->key_len; i++) printf("%02x", key[i]);
d428 2
a429 1
	printf("\t iv= "); for (i=0; i<c->iv_len; i++) printf("%02x", iv[i]);
d602 2
a603 2
                        ds,rec->data,rec->input,l);
		printf("\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%d %d], %d iv_len\n",
d605 2
a606 1
                        DES_KEY_SZ, DES_SCHEDULE_SZ,
d631 1
a631 1
                unsigned long i;
d633 2
a634 2
		for (i=0; i<l; i++)
                        printf(" %02x", rec->data[i]);  printf("\n");
d818 1
a818 1
	printf ("tls1_generate_master_secret(%p,%p, %p, %d)\n", s,out, p,len);
@


1.11
log
@resolve conflicts
@
text
@d134 2
d857 1
d860 1
@


1.10
log
@resolve conflicts
@
text
@a117 1
#include <openssl/fips.h>
a133 2
	HMAC_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
	HMAC_CTX_set_flags(&ctx_tmp, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d180 1
d234 1
d236 1
d244 1
d246 1
d270 3
d275 1
d295 4
a298 1
		memset(&(s->s3->read_sequence[0]),0,8);
d307 3
a309 4
		if ((s->enc_write_ctx == NULL) &&
			((s->enc_write_ctx=(EVP_CIPHER_CTX *)
			OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL))
			goto err;
d312 1
d327 4
a330 1
		memset(&(s->s3->write_sequence[0]),0,8);
a335 1
	EVP_CIPHER_CTX_init(dd);
d517 1
a517 1

d632 9
a640 1
			if (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG)
d741 10
a750 2
	buf[1]=TLS1_VERSION_MAJOR;
	buf[2]=TLS1_VERSION_MINOR;
d757 13
a769 1
	HMAC_Update(&hmac,seq,8);
d786 1
a786 1
	for (i=7; i>=0; i--)
d788 5
a792 2
		++seq[i];
		if (seq[i] != 0) break; 
d855 2
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d118 1
d135 2
a182 1
	
@


1.8
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d127 1
a127 1
	unsigned char A1[HMAC_MAX_MD_CBLOCK];
d164 1
a164 1
	memset(A1,0,sizeof(A1));
d421 4
a424 4
	memset(tmp1,0,sizeof(tmp1));
	memset(tmp2,0,sizeof(tmp1));
	memset(iv1,0,sizeof(iv1));
	memset(iv2,0,sizeof(iv2));
d479 1
a479 1
	memset(p2,0,num);
d686 1
a686 1
		out,buf2,12);
d689 1
a689 1
	return((int)12);
d776 1
a776 1
		s->session->master_key,buff,SSL3_MASTER_SECRET_SIZE);
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d113 1
a116 1
#include "ssl_locl.h"
d486 15
a500 6
	/* enable vulnerability countermeasure for CBC ciphers with
	 * known-IV problem (http://www.openssl.org/~bodo/tls-cbc.txt) */
	s->s3->need_empty_fragments = 1;
#ifndef NO_RC4
	if ((s->session->cipher != NULL) && ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_RC4))
		s->s3->need_empty_fragments = 0;
d502 3
a504 1
		
@


1.6
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d58 53
a113 2
#include <openssl/md5.h>
#include <openssl/sha.h>
d117 1
d132 4
a135 1
	HMAC_Init(&ctx,sec,sec_len,md);
d142 2
a143 1
		HMAC_Init(&ctx,NULL,0,NULL); /* re-init */
d145 1
a145 1
		memcpy(&ctx_tmp,&ctx,sizeof(ctx)); /* Copy for A2 */ /* not needed for last one */
d162 2
a163 2
	HMAC_cleanup(&ctx);
	HMAC_cleanup(&ctx_tmp);
d207 11
d236 2
a237 1
	int _exp,n,i,j,k,exp_label_len,cl;
d239 1
a239 1
	_exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
d245 15
d262 3
a264 3
		if ((s->enc_read_ctx == NULL) &&
			((s->enc_read_ctx=(EVP_CIPHER_CTX *)
			OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL))
d292 4
d320 2
d327 2
a328 2
	j=_exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
		  cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
d356 1
a356 1
		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_INTERNAL_ERROR);
d365 1
a365 1
	if (_exp)
d401 10
d412 1
a412 1
	EVP_CipherInit(dd,c,key,iv,(which & SSL3_CC_WRITE));
d440 4
d486 8
d531 4
d565 18
d588 2
a589 2
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPT_ERROR);
				return(0);
d595 9
d621 5
a625 3
				SSLerr(SSL_F_TLS1_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);
				return(0);
d631 2
a632 3
					SSLerr(SSL_F_TLS1_ENC,SSL_R_DECRYPTION_FAILED);
					ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);
					return(0);
d646 4
a649 2
	EVP_MD_CTX_copy(&ctx,in_ctx);
	EVP_DigestFinal(&ctx,out,&ret);
d665 3
a667 2
	EVP_MD_CTX_copy(&ctx,in1_ctx);
	EVP_DigestFinal(&ctx,q,&i);
d669 2
a670 2
	EVP_MD_CTX_copy(&ctx,in2_ctx);
	EVP_DigestFinal(&ctx,q,&i);
d676 1
a676 1
	memset(&ctx,0,sizeof(EVP_MD_CTX));
d715 2
a716 1
	HMAC_Init(&hmac,mac_sec,EVP_MD_size(hash),hash);
d721 1
d752 4
d766 3
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d423 1
a423 1
		memcpy(rec->data,rec->input,rec->length);
d450 10
d464 1
a464 1
			ii=i=rec->data[l-1];
d475 2
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d575 4
a578 1
		if (++seq[i]) break; 
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d181 1
a181 1
			Malloc(sizeof(EVP_CIPHER_CTX))) == NULL))
d200 1
a200 1
					Malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
d211 1
a211 1
			Malloc(sizeof(EVP_CIPHER_CTX))) == NULL))
d358 1
a358 1
	if ((p1=(unsigned char *)Malloc(num)) == NULL)
d360 1
a360 1
	if ((p2=(unsigned char *)Malloc(num)) == NULL)
d377 1
a377 1
	Free(p2);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d497 1
a497 1
	     unsigned char *str, int slen, unsigned char *out)
d624 1
a624 1
	case SSL_AD_EXPORT_RESTRICION:	return(TLS1_AD_EXPORT_RESTRICION);
d628 1
a628 1
	case SSL_AD_USER_CANCLED:	return(TLS1_AD_USER_CANCLED);
@


1.1
log
@Initial revision
@
text
@d60 5
a64 2
#include "evp.h"
#include "hmac.h"
d67 3
a69 8
static void tls1_P_hash(md,sec,sec_len,seed,seed_len,out,olen)
EVP_MD *md;
unsigned char *sec;
int sec_len;
unsigned char *seed;
int seed_len;
unsigned char *out;
int olen;
d111 4
a114 10
static void tls1_PRF(md5,sha1,label,label_len,sec,slen,out1,out2,olen)
EVP_MD *md5;
EVP_MD *sha1;
unsigned char *label;
int label_len;
unsigned char *sec;
int slen;
unsigned char *out1;
unsigned char *out2;
int olen;
d117 1
a117 1
	unsigned char *S1,*S2;
d132 2
a133 4
static void tls1_generate_key_block(s,km,tmp,num)
SSL *s;
unsigned char *km,*tmp;
int num;
d148 3
a150 3
	tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,p-buf,
		s->session->master_key,s->session->master_key_length,
		km,tmp,num);
d153 1
a153 3
int tls1_change_cipher_state(s,which)
SSL *s;
int which;
d155 1
d166 4
a169 4
	EVP_CIPHER *c;
	SSL_COMPRESSION *comp;
	EVP_MD *m;
	int exp,n,i,j,k,exp_label_len;
d171 1
a171 1
	exp=(s->s3->tmp.new_cipher->algorithms & SSL_EXPORT)?1:0;
d185 19
a203 1
		s->read_compression=comp;
d215 14
a228 1
		s->write_compression=comp;
d237 4
a240 1
	j=(exp)?5:EVP_CIPHER_key_length(c);
d276 1
a276 1
	if (exp)
d288 2
a289 2
		tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,p-buf,key,j,
			tmp1,tmp2,EVP_CIPHER_key_length(c));
d302 2
a303 2
			tls1_PRF(s->ctx->md5,s->ctx->sha1,
				buf,p-buf,"",0,iv1,iv2,k*2);
d333 1
a333 2
int tls1_setup_key_block(s)
SSL *s;
d336 4
a339 3
	EVP_CIPHER *c;
	EVP_MD *hash;
	int num,exp;
d344 1
a344 1
	if (!ssl_cipher_get_evp(s->session->cipher,&c,&hash))
a352 2
	exp=(s->session->cipher->algorithms & SSL_EXPORT)?1:0;

d389 1
a389 3
int tls1_enc(s,send)
SSL *s;
int send;
d395 1
a395 2
	EVP_CIPHER *enc;
	SSL_COMPRESSION *comp;
d404 1
a404 1
			{ enc=NULL; comp=NULL; }
a405 1
			{
a406 2
			comp=s->write_compression;
			}
d415 1
a415 1
			{ enc=NULL; comp=NULL; }
a416 1
			{
a417 2
			comp=s->read_compression;
			}
d421 1
a421 1
		((enc == NULL) && (comp == NULL)))
d486 1
a486 4
int tls1_cert_verify_mac(s,in_ctx,out)
SSL *s;
EVP_MD_CTX *in_ctx;
unsigned char *out;
d491 1
a491 1
	memcpy(&ctx,in_ctx,sizeof(EVP_MD_CTX));
d496 2
a497 6
int tls1_final_finish_mac(s,in1_ctx,in2_ctx,str,slen,out)
SSL *s;
EVP_MD_CTX *in1_ctx,*in2_ctx;
unsigned char *str;
int slen;
unsigned char *out;
d508 1
a508 1
	memcpy(&ctx,in1_ctx,sizeof(EVP_MD_CTX));
d511 1
a511 1
	memcpy(&ctx,in2_ctx,sizeof(EVP_MD_CTX));
d515 1
a515 1
	tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,q-buf,
d523 1
a523 4
int tls1_mac(ssl,md,send)
SSL *ssl;
unsigned char *md;
int send;
d527 1
a527 1
	EVP_MD *hash;
d565 1
a565 1
{int z; for (z=0; z<md_size; z++) printf("%02X ",mac_sec[z]); printf("\n"); }
d571 1
a571 1
{int z; for (z=0; z<rec->length; z++) printf("%02X ",buf[z]); printf("\n"); }
d578 1
a578 1
{int z; for (z=0; z<md_size; z++) printf("%02X ",md[z]); printf("\n"); }
d583 2
a584 5
int tls1_generate_master_secret(s,out,p,len)
SSL *s;
unsigned char *out;
unsigned char *p;
int len;
d602 1
a602 2
int tls1_alert_code(code)
int code;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d60 2
a61 3
#include <openssl/comp.h>
#include <openssl/evp.h>
#include <openssl/hmac.h>
a62 1
#include <openssl/md5.h>
d64 8
a71 3
static void tls1_P_hash(const EVP_MD *md, const unsigned char *sec,
			int sec_len, unsigned char *seed, int seed_len,
			unsigned char *out, int olen)
d82 1
a82 4
	HMAC_CTX_init(&ctx);
	HMAC_CTX_init(&ctx_tmp);
	HMAC_Init_ex(&ctx,sec,sec_len,md, NULL);
	HMAC_Init_ex(&ctx_tmp,sec,sec_len,md, NULL);
d89 1
a89 2
		HMAC_Init_ex(&ctx,NULL,0,NULL,NULL); /* re-init */
		HMAC_Init_ex(&ctx_tmp,NULL,0,NULL,NULL); /* re-init */
d91 1
a91 1
		HMAC_Update(&ctx_tmp,A1,A1_len);
d108 2
a109 2
	HMAC_CTX_cleanup(&ctx);
	HMAC_CTX_cleanup(&ctx_tmp);
d113 10
a122 4
static void tls1_PRF(const EVP_MD *md5, const EVP_MD *sha1,
		     unsigned char *label, int label_len,
		     const unsigned char *sec, int slen, unsigned char *out1,
		     unsigned char *out2, int olen)
d125 1
a125 1
	const unsigned char *S1,*S2;
d140 4
a143 2
static void tls1_generate_key_block(SSL *s, unsigned char *km,
	     unsigned char *tmp, int num)
d158 3
a160 14
	tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(p-buf),
		 s->session->master_key,s->session->master_key_length,
		 km,tmp,num);
#ifdef KSSL_DEBUG
	printf("tls1_generate_key_block() ==> %d byte master_key =\n\t",
                s->session->master_key_length);
	{
        int i;
        for (i=0; i < s->session->master_key_length; i++)
                {
                printf("%02X", s->session->master_key[i]);
                }
        printf("\n");  }
#endif    /* KSSL_DEBUG */
d163 3
a165 1
int tls1_change_cipher_state(SSL *s, int which)
a166 1
	static const unsigned char empty[]="";
d177 4
a180 5
	const EVP_CIPHER *c;
	const SSL_COMP *comp;
	const EVP_MD *m;
	int is_export,n,i,j,k,exp_label_len,cl;
	int reuse_dd = 0;
d182 1
a182 1
	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
a187 15
#ifdef KSSL_DEBUG
	printf("tls1_change_cipher_state(which= %d) w/\n", which);
	printf("\talg= %ld, comp= %p\n", s->s3->tmp.new_cipher->algorithms,
                comp);
	printf("\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n", c);
	printf("\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n",
                c->nid,c->block_size,c->key_len,c->iv_len);
	printf("\tkey_block: len= %d, data= ", s->s3->tmp.key_block_length);
	{
        int i;
        for (i=0; i<s->s3->tmp.key_block_length; i++)
		printf("%02x", key_block[i]);  printf("\n");
        }
#endif	/* KSSL_DEBUG */

d190 3
a192 3
		if (s->enc_read_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d196 1
a196 19
		if (s->expand != NULL)
			{
			COMP_CTX_free(s->expand);
			s->expand=NULL;
			}
		if (comp != NULL)
			{
			s->expand=COMP_CTX_new(comp->method);
			if (s->expand == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			if (s->s3->rrec.comp == NULL)
				s->s3->rrec.comp=(unsigned char *)
					OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
			if (s->s3->rrec.comp == NULL)
				goto err;
			}
a201 4
		if (s->enc_write_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
			goto err;
d204 1
a204 1
			OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL))
d208 1
a208 14
		if (s->compress != NULL)
			{
			COMP_CTX_free(s->compress);
			s->compress=NULL;
			}
		if (comp != NULL)
			{
			s->compress=COMP_CTX_new(comp->method);
			if (s->compress == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			}
a212 2
	if (reuse_dd)
		EVP_CIPHER_CTX_cleanup(dd);
d217 1
a217 4
	cl=EVP_CIPHER_key_length(c);
	j=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
	               cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
	/* Was j=(exp)?5:EVP_CIPHER_key_length(c); */
d244 1
a244 1
		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
d253 1
a253 1
	if (is_export)
d265 2
a266 2
		tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(p-buf),key,j,
			 tmp1,tmp2,EVP_CIPHER_key_length(c));
d279 2
a280 2
			tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,p-buf,empty,0,
				 iv1,iv2,k*2);
a288 10
#ifdef KSSL_DEBUG
	{
        int i;
	printf("EVP_CipherInit_ex(dd,c,key=,iv=,which)\n");
	printf("\tkey= "); for (i=0; i<c->key_len; i++) printf("%02x", key[i]);
	printf("\n");
	printf("\t iv= "); for (i=0; i<c->iv_len; i++) printf("%02x", iv[i]);
	printf("\n");
	}
#endif	/* KSSL_DEBUG */
d290 1
a290 1
	EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));
d310 2
a311 1
int tls1_setup_key_block(SSL *s)
d314 3
a316 8
	const EVP_CIPHER *c;
	const EVP_MD *hash;
	int num;
	SSL_COMP *comp;

#ifdef KSSL_DEBUG
	printf ("tls1_setup_key_block()\n");
#endif	/* KSSL_DEBUG */
d321 1
a321 1
	if (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))
d330 2
d337 1
a337 1
	if ((p1=(unsigned char *)OPENSSL_malloc(num)) == NULL)
d339 1
a339 1
	if ((p2=(unsigned char *)OPENSSL_malloc(num)) == NULL)
d356 1
a356 1
	OPENSSL_free(p2);
a361 8
	/* enable vulnerability countermeasure for CBC ciphers with
	 * known-IV problem (http://www.openssl.org/~bodo/tls-cbc.txt) */
	s->s3->need_empty_fragments = 1;
#ifndef NO_RC4
	if ((s->session->cipher != NULL) && ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_RC4))
		s->s3->need_empty_fragments = 0;
#endif
		
d368 3
a370 1
int tls1_enc(SSL *s, int send)
d376 2
a377 1
	const EVP_CIPHER *enc;
d386 1
a386 1
			enc=NULL;
d388 1
d390 2
d400 1
a400 1
			enc=NULL;
d402 1
d404 2
a407 4
#ifdef KSSL_DEBUG
	printf("tls1_enc(%d)\n", send);
#endif    /* KSSL_DEBUG */

d409 1
a409 1
		(enc == NULL))
d411 1
a411 1
		memmove(rec->data,rec->input,rec->length);
a437 28
#ifdef KSSL_DEBUG
		{
                unsigned long ui;
		printf("EVP_Cipher(ds=%p,rec->data=%p,rec->input=%p,l=%ld) ==>\n",
                        ds,rec->data,rec->input,l);
		printf("\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%d %d], %d iv_len\n",
                        ds->buf_len, ds->cipher->key_len,
                        DES_KEY_SZ, DES_SCHEDULE_SZ,
                        ds->cipher->iv_len);
		printf("\t\tIV: ");
		for (i=0; i<ds->cipher->iv_len; i++) printf("%02X", ds->iv[i]);
		printf("\n");
		printf("\trec->input=");
		for (ui=0; ui<l; ui++) printf(" %02x", rec->input[ui]);
		printf("\n");
		}
#endif	/* KSSL_DEBUG */

		if (!send)
			{
			if (l == 0 || l%bs != 0)
				{
				SSLerr(SSL_F_TLS1_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);
				return 0;
				}
			}
		
a439 9
#ifdef KSSL_DEBUG
		{
                unsigned long i;
                printf("\trec->data=");
		for (i=0; i<l; i++)
                        printf(" %02x", rec->data[i]);  printf("\n");
                }
#endif	/* KSSL_DEBUG */

d442 1
a442 1
			ii=i=rec->data[l-1]; /* padding_length */
a452 2
			/* TLS 1.0 does not bound the number of padding bytes by the block size.
			 * All of them must have value 'padding_length'. */
d455 3
a457 5
				/* Incorrect padding. SSLerr() and ssl3_alert are done
				 * by caller: we don't want to reveal whether this is
				 * a decryption error or a MAC verification failure
				 * (see http://www.openssl.org/~bodo/tls-cbc.txt) */
				return -1;
d463 3
a465 2
					/* Incorrect padding */
					return -1;
d474 4
a477 1
int tls1_cert_verify_mac(SSL *s, EVP_MD_CTX *in_ctx, unsigned char *out)
d482 2
a483 4
	EVP_MD_CTX_init(&ctx);
	EVP_MD_CTX_copy_ex(&ctx,in_ctx);
	EVP_DigestFinal_ex(&ctx,out,&ret);
	EVP_MD_CTX_cleanup(&ctx);
d487 6
a492 2
int tls1_final_finish_mac(SSL *s, EVP_MD_CTX *in1_ctx, EVP_MD_CTX *in2_ctx,
	     const char *str, int slen, unsigned char *out)
d503 2
a504 3
	EVP_MD_CTX_init(&ctx);
	EVP_MD_CTX_copy_ex(&ctx,in1_ctx);
	EVP_DigestFinal_ex(&ctx,q,&i);
d506 2
a507 2
	EVP_MD_CTX_copy_ex(&ctx,in2_ctx);
	EVP_DigestFinal_ex(&ctx,q,&i);
d510 1
a510 1
	tls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(q-buf),
d513 1
a513 1
	EVP_MD_CTX_cleanup(&ctx);
d518 4
a521 1
int tls1_mac(SSL *ssl, unsigned char *md, int send)
d525 1
a525 1
	const EVP_MD *hash;
d555 1
a555 2
	HMAC_CTX_init(&hmac);
	HMAC_Init_ex(&hmac,mac_sec,EVP_MD_size(hash),hash,NULL);
a559 1
	HMAC_CTX_cleanup(&hmac);
d563 1
a563 1
{unsigned int z; for (z=0; z<md_size; z++) printf("%02X ",mac_sec[z]); printf("\n"); }
d569 1
a569 1
{unsigned int z; for (z=0; z<rec->length; z++) printf("%02X ",buf[z]); printf("\n"); }
d573 1
a573 4
		{
		++seq[i];
		if (seq[i] != 0) break; 
		}
d576 1
a576 1
{unsigned int z; for (z=0; z<md_size; z++) printf("%02X ",md[z]); printf("\n"); }
d581 5
a585 2
int tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
	     int len)
a589 4
#ifdef KSSL_DEBUG
	printf ("tls1_generate_master_secret(%p,%p, %p, %d)\n", s,out, p,len);
#endif	/* KSSL_DEBUG */

a599 3
#ifdef KSSL_DEBUG
	printf ("tls1_generate_master_secret() complete\n");
#endif	/* KSSL_DEBUG */
d603 2
a604 1
int tls1_alert_code(int code)
d626 1
a626 1
	case SSL_AD_EXPORT_RESTRICTION:	return(TLS1_AD_EXPORT_RESTRICTION);
d630 1
a630 1
	case SSL_AD_USER_CANCELLED:	return(TLS1_AD_USER_CANCELLED);
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a112 1
#include "ssl_locl.h"
d116 1
d486 6
a491 15
	if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
		{
		/* enable vulnerability countermeasure for CBC ciphers with
		 * known-IV problem (http://www.openssl.org/~bodo/tls-cbc.txt)
		 */
		s->s3->need_empty_fragments = 1;

		if (s->session->cipher != NULL)
			{
			if ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_eNULL)
				s->s3->need_empty_fragments = 0;
			
#ifndef OPENSSL_NO_RC4
			if ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_RC4)
				s->s3->need_empty_fragments = 0;
d493 1
a493 3
			}
		}

@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d127 1
a127 1
	unsigned char A1[EVP_MAX_MD_SIZE];
d164 1
a164 1
	OPENSSL_cleanse(A1,sizeof(A1));
d421 4
a424 4
	OPENSSL_cleanse(tmp1,sizeof(tmp1));
	OPENSSL_cleanse(tmp2,sizeof(tmp1));
	OPENSSL_cleanse(iv1,sizeof(iv1));
	OPENSSL_cleanse(iv2,sizeof(iv2));
d479 1
a479 1
	OPENSSL_cleanse(p2,num);
d686 1
a686 1
		out,buf2,sizeof buf2);
d689 1
a689 1
	return sizeof buf2;
d776 1
a776 1
		s->session->master_key,buff,sizeof buff);
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a117 1
#include <openssl/fips.h>
a133 2
	HMAC_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
	HMAC_CTX_set_flags(&ctx_tmp, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d180 1
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d118 1
d135 2
a182 1
	
a235 1
#ifndef OPENSSL_NO_COMP
a236 1
#endif
a243 1
#ifndef OPENSSL_NO_COMP
a244 1
#endif
a267 3
		else
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_read_ctx);
a269 1
#ifndef OPENSSL_NO_COMP
d289 1
a289 4
#endif
		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->read_sequence[0]),0,8);
d298 4
a301 3
		else
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_write_ctx);
a303 1
#ifndef OPENSSL_NO_COMP
d318 1
a318 4
#endif
		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->write_sequence[0]),0,8);
d324 1
d506 1
a506 1
		
d621 1
a621 9
			/* NB: if compression is in operation the first packet
			 * may not be of even length so the padding bug check
			 * cannot be performed. This bug workaround has been
			 * around since SSLeay so hopefully it is either fixed
			 * now or no buggy implementation supports compression 
			 * [steve]
			 */
			if ( (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG)
				&& !s->expand)
d722 2
a723 10
	if (ssl->version == DTLS1_VERSION && ssl->client_version == DTLS1_BAD_VER)
		{
		buf[1]=TLS1_VERSION_MAJOR;
		buf[2]=TLS1_VERSION_MINOR;
		}
	else	{
		buf[1]=(unsigned char)(ssl->version>>8);
		buf[2]=(unsigned char)(ssl->version);
		}

d730 1
a730 13

	if (ssl->version == DTLS1_VERSION && ssl->client_version != DTLS1_BAD_VER)
		{
		unsigned char dtlsseq[8],*p=dtlsseq;

		s2n(send?ssl->d1->w_epoch:ssl->d1->r_epoch, p);
		memcpy (p,&seq[2],6);

		HMAC_Update(&hmac,dtlsseq,8);
		}
	else
		HMAC_Update(&hmac,seq,8);

d747 1
a747 1
	if ( SSL_version(ssl) != DTLS1_VERSION)
d749 2
a750 5
		for (i=7; i>=0; i--)
			{
			++seq[i];
			if (seq[i] != 0) break; 
			}
a812 2
	case DTLS1_AD_MISSING_HANDSHAKE_MESSAGE: return 
					  (DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
@


1.1.1.7
log
@import openssl-0.9.8j
@
text
@a113 1
#ifndef OPENSSL_NO_COMP
a114 1
#endif
a117 3
#ifdef KSSL_DEBUG
#include <openssl/des.h>
#endif
a133 2
	HMAC_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
	HMAC_CTX_set_flags(&ctx_tmp, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d252 2
a253 2
                (void *)comp);
	printf("\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n", (void *)c);
d258 3
a260 3
        int ki;
        for (ki=0; ki<s->s3->tmp.key_block_length; ki++)
		printf("%02x", key_block[ki]);  printf("\n");
d416 1
a416 1
        int ki;
d418 1
a418 2
	printf("\tkey= ");
	for (ki=0; ki<c->key_len; ki++) printf("%02x", key[ki]);
d420 1
a420 2
	printf("\t iv= ");
	for (ki=0; ki<c->iv_len; ki++) printf("%02x", iv[ki]);
d593 2
a594 2
                        (void *)ds,rec->data,rec->input,l);
		printf("\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%ld %ld], %d iv_len\n",
d596 1
a596 2
                        (unsigned long)DES_KEY_SZ,
			(unsigned long)DES_SCHEDULE_SZ,
d621 1
a621 1
                unsigned long ki;
d623 2
a624 2
		for (ki=0; ki<l; i++)
                        printf(" %02x", rec->data[ki]);  printf("\n");
d808 1
a808 1
	printf ("tls1_generate_master_secret(%p,%p, %p, %d)\n", (void *)s,out, p,len);
a854 1
#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
a856 1
#endif
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
a110 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
d124 2
a125 8
/* seed1 through seed5 are virtually concatenated */
static int tls1_P_hash(const EVP_MD *md, const unsigned char *sec,
			int sec_len,
			const void *seed1, int seed1_len,
			const void *seed2, int seed2_len,
			const void *seed3, int seed3_len,
			const void *seed4, int seed4_len,
			const void *seed5, int seed5_len,
a133 1
	int ret = 0;
a135 1
	OPENSSL_assert(chunk >= 0);
d139 6
a144 16
	if (!HMAC_Init_ex(&ctx,sec,sec_len,md, NULL))
		goto err;
	if (!HMAC_Init_ex(&ctx_tmp,sec,sec_len,md, NULL))
		goto err;
	if (seed1 != NULL && !HMAC_Update(&ctx,seed1,seed1_len))
		goto err;
	if (seed2 != NULL && !HMAC_Update(&ctx,seed2,seed2_len))
		goto err;
	if (seed3 != NULL && !HMAC_Update(&ctx,seed3,seed3_len))
		goto err;
	if (seed4 != NULL && !HMAC_Update(&ctx,seed4,seed4_len))
		goto err;
	if (seed5 != NULL && !HMAC_Update(&ctx,seed5,seed5_len))
		goto err;
	if (!HMAC_Final(&ctx,A1,&A1_len))
		goto err;
d149 5
a153 18
		if (!HMAC_Init_ex(&ctx,NULL,0,NULL,NULL)) /* re-init */
			goto err;
		if (!HMAC_Init_ex(&ctx_tmp,NULL,0,NULL,NULL)) /* re-init */
			goto err;
		if (!HMAC_Update(&ctx,A1,A1_len))
			goto err;
		if (!HMAC_Update(&ctx_tmp,A1,A1_len))
			goto err;
		if (seed1 != NULL && !HMAC_Update(&ctx,seed1,seed1_len))
			goto err;
		if (seed2 != NULL && !HMAC_Update(&ctx,seed2,seed2_len))
			goto err;
		if (seed3 != NULL && !HMAC_Update(&ctx,seed3,seed3_len))
			goto err;
		if (seed4 != NULL && !HMAC_Update(&ctx,seed4,seed4_len))
			goto err;
		if (seed5 != NULL && !HMAC_Update(&ctx,seed5,seed5_len))
			goto err;
d157 1
a157 2
			if (!HMAC_Final(&ctx,out,&j))
				goto err;
d160 1
a160 2
			if (!HMAC_Final(&ctx_tmp,A1,&A1_len)) /* calc the next A1 value */
				goto err;
d164 1
a164 2
			if (!HMAC_Final(&ctx,A1,&A1_len))
				goto err;
a168 2
	ret = 1;
err:
a171 1
	return ret;
d174 3
a176 9
/* seed1 through seed5 are virtually concatenated */
static int tls1_PRF(long digest_mask,
		     const void *seed1, int seed1_len,
		     const void *seed2, int seed2_len,
		     const void *seed3, int seed3_len,
		     const void *seed4, int seed4_len,
		     const void *seed5, int seed5_len,
		     const unsigned char *sec, int slen,
		     unsigned char *out1,
d179 4
a182 12
	int len,i,idx,count;
	const unsigned char *S1;
	long m;
	const EVP_MD *md;
	int ret = 0;

	/* Count number of digests and partition sec evenly */
	count=0;
	for (idx=0;ssl_get_handshake_digest(idx,&m,&md);idx++) {
		if ((m<<TLS1_PRF_DGST_SHIFT) & digest_mask) count++;
	}	
	len=slen/count;
d184 9
a192 18
	memset(out1,0,olen);
	for (idx=0;ssl_get_handshake_digest(idx,&m,&md);idx++) {
		if ((m<<TLS1_PRF_DGST_SHIFT) & digest_mask) {
			if (!md) {
				SSLerr(SSL_F_TLS1_PRF,
				SSL_R_UNSUPPORTED_DIGEST_TYPE);
				goto err;				
			}
			if (!tls1_P_hash(md ,S1,len+(slen&1),
					seed1,seed1_len,seed2,seed2_len,seed3,seed3_len,seed4,seed4_len,seed5,seed5_len,
					out2,olen))
				goto err;
			S1+=len;
			for (i=0; i<olen; i++)
			{
				out1[i]^=out2[i];
			}
		}
d194 2
a195 5
	ret = 1;
err:
	return ret;
}
static int tls1_generate_key_block(SSL *s, unsigned char *km,
d198 14
a211 6
	int ret;
	ret = tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
		 TLS_MD_KEY_EXPANSION_CONST,TLS_MD_KEY_EXPANSION_CONST_SIZE,
		 s->s3->server_random,SSL3_RANDOM_SIZE,
		 s->s3->client_random,SSL3_RANDOM_SIZE,
		 NULL,0,NULL,0,
a224 1
	return ret;
d231 2
a232 1
	unsigned char *exp_label;
a244 4
	int mac_type;
	int *mac_secret_size;
	EVP_MD_CTX *mac_ctx;
	EVP_PKEY *mac_key;
a250 1
	mac_type = s->s3->tmp.new_mac_pkey_type;
d258 3
a260 5
	printf("\talg= %ld/%ld, comp= %p\n",
	       s->s3->tmp.new_cipher->algorithm_mkey,
	       s->s3->tmp.new_cipher->algorithm_auth,
	       comp);
	printf("\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n", c);
d265 3
a267 3
        int i;
        for (i=0; i<s->s3->tmp.key_block_length; i++)
		printf("%02x", key_block[i]);  printf("\n");
a272 5
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
			s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;
			else
			s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;

d281 1
a281 1
		mac_ctx=ssl_replace_hash(&s->read_hash,NULL);
a306 1
		mac_secret_size=&(s->s3->read_mac_secret_size);
a309 4
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
			s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;
			else
			s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;
d318 1
a318 1
		mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
a338 1
		mac_secret_size = &(s->s3->write_mac_secret_size);
d345 1
a345 2
	i=*mac_secret_size=s->s3->tmp.new_mac_secret_size;

a380 4
	mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
			mac_secret,*mac_secret_size);
	EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);
	EVP_PKEY_free(mac_key);
d390 9
a398 7
		if (!tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
				exp_label,exp_label_len,
				s->s3->client_random,SSL3_RANDOM_SIZE,
				s->s3->server_random,SSL3_RANDOM_SIZE,
				NULL,0,NULL,0,
				key,j,tmp1,tmp2,EVP_CIPHER_key_length(c)))
			goto err2;
d403 10
a412 7
			if (!tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
					TLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE,
					s->s3->client_random,SSL3_RANDOM_SIZE,
					s->s3->server_random,SSL3_RANDOM_SIZE,
					NULL,0,NULL,0,
					empty,0,iv1,iv2,k*2))
				goto err2;
d423 1
a423 1
        int i;
d425 2
a426 1
	printf("\tkey= "); for (i=0; i<c->key_len; i++) printf("%02x", key[i]);
d428 2
a429 1
	printf("\t iv= "); for (i=0; i<c->iv_len; i++) printf("%02x", iv[i]);
d456 1
a456 1
	unsigned char *p1,*p2=NULL;
a460 2
	int mac_type= NID_undef,mac_secret_size=0;
	int ret=0;
d469 1
a469 1
	if (!ssl_cipher_get_evp(s->session,&c,&hash,&mac_type,&mac_secret_size,&comp))
d477 2
a478 3
	s->s3->tmp.new_mac_pkey_type = mac_type;
	s->s3->tmp.new_mac_secret_size = mac_secret_size;
	num=EVP_CIPHER_key_length(c)+mac_secret_size+EVP_CIPHER_iv_length(c);
a483 2
		{
		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);
d485 2
a486 1
		}
a490 5
	if ((p2=(unsigned char *)OPENSSL_malloc(num)) == NULL)
		{
		SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);
		goto err;
		}
d500 3
a502 2
	if (!tls1_generate_key_block(s,p1,p2,num))
		goto err;
d517 1
a517 1
			if (s->session->cipher->algorithm_enc == SSL_eNULL)
d521 1
a521 1
			if (s->session->cipher->algorithm_enc == SSL_RC4)
d527 1
a527 1
	ret = 1;
d529 2
a530 6
	if (p2)
		{
		OPENSSL_cleanse(p2,num);
		OPENSSL_free(p2);
		}
	return(ret);
d543 2
a544 5
		if (EVP_MD_CTX_md(s->write_hash))
			{
			n=EVP_MD_CTX_size(s->write_hash);
			OPENSSL_assert(n >= 0);
			}
d554 2
a555 5
		if (EVP_MD_CTX_md(s->read_hash))
			{
			n=EVP_MD_CTX_size(s->read_hash);
			OPENSSL_assert(n >= 0);
			}
d602 2
a603 2
                        ds,rec->data,rec->input,l);
		printf("\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%d %d], %d iv_len\n",
d605 2
a606 1
                        DES_KEY_SZ, DES_SCHEDULE_SZ,
d631 1
a631 1
                unsigned long i;
d633 2
a634 2
		for (i=0; i<l; i++)
                        printf(" %02x", rec->data[i]);  printf("\n");
d682 2
a683 1
int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *out)
d686 1
a686 19
	EVP_MD_CTX ctx, *d=NULL;
	int i;

	if (s->s3->handshake_buffer) 
		if (!ssl3_digest_cached_records(s))
			return 0;

	for (i=0;i<SSL_MAX_DIGEST;i++) 
		{
		  if (s->s3->handshake_dgst[i]&&EVP_MD_CTX_type(s->s3->handshake_dgst[i])==md_nid) 
		  	{
		  	d=s->s3->handshake_dgst[i];
			break;
			}
		}
	if (!d) {
		SSLerr(SSL_F_TLS1_CERT_VERIFY_MAC,SSL_R_NO_REQUIRED_DIGEST);
		return 0;
	}	
d689 1
a689 1
	EVP_MD_CTX_copy_ex(&ctx,d);
d695 1
a695 1
int tls1_final_finish_mac(SSL *s,
d700 1
a700 1
	unsigned char buf[2*EVP_MAX_MD_SIZE];
a701 4
	int idx;
	long mask;
	int err=0;
	const EVP_MD *md; 
d704 2
a705 4

	if (s->s3->handshake_buffer) 
		if (!ssl3_digest_cached_records(s))
			return 0;
d708 10
a717 27

	for (idx=0;ssl_get_handshake_digest(idx,&mask,&md);idx++)
		{
		if (mask & s->s3->tmp.new_cipher->algorithm2)
			{
			int hashsize = EVP_MD_size(md);
			if (hashsize < 0 || hashsize > (int)(sizeof buf - (size_t)(q-buf)))
				{
				/* internal error: 'buf' is too small for this cipersuite! */
				err = 1;
				}
			else
				{
				EVP_MD_CTX_copy_ex(&ctx,s->s3->handshake_dgst[idx]);
				EVP_DigestFinal_ex(&ctx,q,&i);
				if (i != (unsigned int)hashsize) /* can't really happen */
					err = 1;
				q+=i;
				}
			}
		}
		
	if (!tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
			str,slen, buf,(int)(q-buf), NULL,0, NULL,0, NULL,0,
			s->session->master_key,s->session->master_key_length,
			out,buf2,sizeof buf2))
		err = 1;
d720 1
a720 4
	if (err)
		return 0;
	else
		return sizeof buf2;
d727 2
a728 2
	EVP_MD_CTX *hash;
	size_t md_size;
d730 1
a730 1
	EVP_MD_CTX hmac, *mac_ctx;
a731 2
	int stream_mac = (send?(ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM):(ssl->mac_flags&SSL_MAC_FLAG_READ_MAC_STREAM));
	int t;
d748 1
a748 3
	t=EVP_MD_CTX_size(hash);
	OPENSSL_assert(t >= 0);
	md_size=t;
d751 10
a760 2
	buf[1]=(unsigned char)(ssl->version>>8);
	buf[2]=(unsigned char)(ssl->version);
d765 2
a766 9
	if (stream_mac) 
		{
			mac_ctx = hash;
		}
		else
		{
			EVP_MD_CTX_copy(&hmac,hash);
			mac_ctx = &hmac;
		}
d768 1
a768 1
	if (ssl->version == DTLS1_VERSION || ssl->version == DTLS1_BAD_VER)
d775 1
a775 1
		EVP_DigestSignUpdate(mac_ctx,dtlsseq,8);
d778 6
a783 1
		EVP_DigestSignUpdate(mac_ctx,seq,8);
a784 6
	EVP_DigestSignUpdate(mac_ctx,buf,5);
	EVP_DigestSignUpdate(mac_ctx,rec->input,rec->length);
	t=EVP_DigestSignFinal(mac_ctx,md,&md_size);
	OPENSSL_assert(t > 0);
		
	if (!stream_mac) EVP_MD_CTX_cleanup(&hmac);
d796 1
a796 1
	if (ssl->version != DTLS1_VERSION && ssl->version != DTLS1_BAD_VER)
d814 1
a815 2
	const void *co = NULL, *so = NULL;
	int col = 0, sol = 0;
d818 1
a818 1
	printf ("tls1_generate_master_secret(%p,%p, %p, %d)\n", s,out, p,len);
d821 9
a829 19
#ifdef TLSEXT_TYPE_opaque_prf_input
	if (s->s3->client_opaque_prf_input != NULL && s->s3->server_opaque_prf_input != NULL &&
	    s->s3->client_opaque_prf_input_len > 0 &&
	    s->s3->client_opaque_prf_input_len == s->s3->server_opaque_prf_input_len)
		{
		co = s->s3->client_opaque_prf_input;
		col = s->s3->server_opaque_prf_input_len;
		so = s->s3->server_opaque_prf_input;
		sol = s->s3->client_opaque_prf_input_len; /* must be same as col (see draft-rescorla-tls-opaque-prf-input-00.txt, section 3.1) */
		}
#endif

	tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
		TLS_MD_MASTER_SECRET_CONST,TLS_MD_MASTER_SECRET_CONST_SIZE,
		s->s3->client_random,SSL3_RANDOM_SIZE,
		co, col,
		s->s3->server_random,SSL3_RANDOM_SIZE,
		so, sol,
		p,len,
a830 1

d865 1
a865 7
	case SSL_AD_UNSUPPORTED_EXTENSION: return(TLS1_AD_UNSUPPORTED_EXTENSION);
	case SSL_AD_CERTIFICATE_UNOBTAINABLE: return(TLS1_AD_CERTIFICATE_UNOBTAINABLE);
	case SSL_AD_UNRECOGNIZED_NAME:	return(TLS1_AD_UNRECOGNIZED_NAME);
	case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE: return(TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE);
	case SSL_AD_BAD_CERTIFICATE_HASH_VALUE: return(TLS1_AD_BAD_CERTIFICATE_HASH_VALUE);
	case SSL_AD_UNKNOWN_PSK_IDENTITY:return(TLS1_AD_UNKNOWN_PSK_IDENTITY);
#if 0 /* not appropriate for TLS, not used for DTLS */
@


1.1.1.9
log
@import OpenSSL 1.0.0e
@
text
@d160 1
a160 1
	int chunk;
d190 1
d312 1
a312 1
	unsigned char *p,*mac_secret;
d318 1
a318 1
	unsigned char *ms,*key,*iv;
d340 1
d451 2
d883 1
a883 1
	unsigned char *seq;
d895 1
d902 1
@


1.1.1.10
log
@import OpenSSL-1.0.1c
@
text
@a145 1
#include <openssl/rand.h>
d161 3
a163 3
	size_t j;
	EVP_MD_CTX ctx, ctx_tmp;
	EVP_PKEY *mac_key;
d165 1
a165 1
	size_t A1_len;
d171 3
a173 6
	EVP_MD_CTX_init(&ctx);
	EVP_MD_CTX_init(&ctx_tmp);
	EVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
	EVP_MD_CTX_set_flags(&ctx_tmp, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
	mac_key = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, sec, sec_len);
	if (!mac_key)
d175 1
a175 1
	if (!EVP_DigestSignInit(&ctx,NULL,md, NULL, mac_key))
d177 1
a177 1
	if (!EVP_DigestSignInit(&ctx_tmp,NULL,md, NULL, mac_key))
d179 1
a179 1
	if (seed1 && !EVP_DigestSignUpdate(&ctx,seed1,seed1_len))
d181 1
a181 1
	if (seed2 && !EVP_DigestSignUpdate(&ctx,seed2,seed2_len))
d183 1
a183 1
	if (seed3 && !EVP_DigestSignUpdate(&ctx,seed3,seed3_len))
d185 1
a185 1
	if (seed4 && !EVP_DigestSignUpdate(&ctx,seed4,seed4_len))
d187 1
a187 3
	if (seed5 && !EVP_DigestSignUpdate(&ctx,seed5,seed5_len))
		goto err;
	if (!EVP_DigestSignFinal(&ctx,A1,&A1_len))
d192 1
a192 2
		/* Reinit mac contexts */
		if (!EVP_DigestSignInit(&ctx,NULL,md, NULL, mac_key))
d194 1
a194 1
		if (!EVP_DigestSignInit(&ctx_tmp,NULL,md, NULL, mac_key))
d196 1
a196 1
		if (!EVP_DigestSignUpdate(&ctx,A1,A1_len))
d198 1
a198 1
		if (!EVP_DigestSignUpdate(&ctx_tmp,A1,A1_len))
d200 1
a200 1
		if (seed1 && !EVP_DigestSignUpdate(&ctx,seed1,seed1_len))
d202 1
a202 1
		if (seed2 && !EVP_DigestSignUpdate(&ctx,seed2,seed2_len))
d204 1
a204 1
		if (seed3 && !EVP_DigestSignUpdate(&ctx,seed3,seed3_len))
d206 1
a206 1
		if (seed4 && !EVP_DigestSignUpdate(&ctx,seed4,seed4_len))
d208 1
a208 1
		if (seed5 && !EVP_DigestSignUpdate(&ctx,seed5,seed5_len))
d213 1
a213 1
			if (!EVP_DigestSignFinal(&ctx,out,&j))
d217 1
a217 2
			/* calc the next A1 value */
			if (!EVP_DigestSignFinal(&ctx_tmp,A1,&A1_len))
d222 1
a222 1
			if (!EVP_DigestSignFinal(&ctx,A1,&A1_len))
d230 2
a231 3
	EVP_PKEY_free(mac_key);
	EVP_MD_CTX_cleanup(&ctx);
	EVP_MD_CTX_cleanup(&ctx_tmp);
a258 2
	if (count == 1)
		slen = 0;
d287 1
a287 1
	ret = tls1_PRF(ssl_get_algorithm2(s),
d361 1
a361 1
		else
d448 1
a448 5
	/* If GCM mode only part of IV comes from PRF */
	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		k = EVP_GCM_TLS_FIXED_IV_LEN;
	else
		k=EVP_CIPHER_iv_length(c);
d477 4
a480 8

	if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))
		{
		mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
				mac_secret,*mac_secret_size);
		EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);
		EVP_PKEY_free(mac_key);
		}
d490 1
a490 1
		if (!tls1_PRF(ssl_get_algorithm2(s),
d501 1
a501 1
			if (!tls1_PRF(ssl_get_algorithm2(s),
d527 1
a527 13
	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		{
		EVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE));
		EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);
		}
	else	
		EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));

	/* Needed for "composite" AEADs, such as RC4-HMAC-MD5 */
	if ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)
		EVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY,
				*mac_secret_size,mac_secret);

d609 1
a609 2
	if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)
		&& s->method->version <= TLS1_VERSION)
d643 1
a643 1
	int bs,i,ii,j,k,pad=0;
d650 1
a650 1
			int n=EVP_MD_CTX_size(s->write_hash);
a657 2
			{
			int ivlen;
a658 19
			/* For TLSv1.1 and later explicit IV */
			if (s->version >= TLS1_1_VERSION
				&& EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)
				ivlen = EVP_CIPHER_iv_length(enc);
			else
				ivlen = 0;
			if (ivlen > 1)
				{
				if ( rec->data != rec->input)
					/* we can't write into the input stream:
					 * Can this ever happen?? (steve)
					 */
					fprintf(stderr,
						"%s:%d: rec->data != rec->input\n",
						__FILE__, __LINE__);
				else if (RAND_bytes(rec->input, ivlen) <= 0)
					return -1;
				}
			}
d664 1
a664 1
			int n=EVP_MD_CTX_size(s->read_hash);
d690 1
a690 37
		if (EVP_CIPHER_flags(ds->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)
			{
			unsigned char buf[13],*seq;

			seq = send?s->s3->write_sequence:s->s3->read_sequence;

			if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)
				{
				unsigned char dtlsseq[9],*p=dtlsseq;

				s2n(send?s->d1->w_epoch:s->d1->r_epoch,p);
				memcpy(p,&seq[2],6);
				memcpy(buf,dtlsseq,8);
				}
			else
				{
				memcpy(buf,seq,8);
				for (i=7; i>=0; i--)	/* increment */
					{
					++seq[i];
					if (seq[i] != 0) break; 
					}
				}

			buf[8]=rec->type;
			buf[9]=(unsigned char)(s->version>>8);
			buf[10]=(unsigned char)(s->version);
			buf[11]=rec->length>>8;
			buf[12]=rec->length&0xff;
			pad=EVP_CIPHER_CTX_ctrl(ds,EVP_CTRL_AEAD_TLS1_AAD,13,buf);
			if (send)
				{
				l+=pad;
				rec->length+=pad;
				}
			}
		else if ((bs != 1) && send)
a730 2
				if (s->version >= TLS1_1_VERSION)
					return -1;
d737 1
a737 11
		i = EVP_Cipher(ds,rec->data,rec->input,l);
		if ((EVP_CIPHER_flags(ds->cipher)&EVP_CIPH_FLAG_CUSTOM_CIPHER)
						?(i<0)
						:(i==0))
			return -1;	/* AEAD can fail to verify MAC */
		if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE && !send)
			{
			rec->data += EVP_GCM_TLS_EXPLICIT_IV_LEN;
			rec->input += EVP_GCM_TLS_EXPLICIT_IV_LEN;
			rec->length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
			}
d787 1
a787 10
			rec->length -=i;
			if (s->version >= TLS1_1_VERSION
				&& EVP_CIPHER_CTX_mode(ds) == EVP_CIPH_CBC_MODE)
				{
				if (bs > (int)rec->length)
					return -1;
				rec->data += bs;    /* skip the explicit IV */
				rec->input += bs;
				rec->length -= bs;
				}
a788 2
		if (pad && !send)
			rec->length -= pad;
d844 1
a844 1
		if (mask & ssl_get_algorithm2(s))
d863 1
a863 1
	if (!tls1_PRF(ssl_get_algorithm2(s),
a972 1

d989 1
a989 1
	tls1_PRF(ssl_get_algorithm2(s),
a996 10
#ifdef SSL_DEBUG
	fprintf(stderr, "Premaster Secret:\n");
	BIO_dump_fp(stderr, (char *)p, len);
	fprintf(stderr, "Client Random:\n");
	BIO_dump_fp(stderr, (char *)s->s3->client_random, SSL3_RANDOM_SIZE);
	fprintf(stderr, "Server Random:\n");
	BIO_dump_fp(stderr, (char *)s->s3->server_random, SSL3_RANDOM_SIZE);
	fprintf(stderr, "Master Secret:\n");
	BIO_dump_fp(stderr, (char *)s->session->master_key, SSL3_MASTER_SECRET_SIZE);
#endif
a1003 89
int tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,
	 const char *label, size_t llen, const unsigned char *context,
	 size_t contextlen, int use_context)
	{
	unsigned char *buff;
	unsigned char *val = NULL;
	size_t vallen, currentvalpos;
	int rv;

#ifdef KSSL_DEBUG
	printf ("tls1_export_keying_material(%p,%p,%d,%s,%d,%p,%d)\n", s, out, olen, label, llen, p, plen);
#endif	/* KSSL_DEBUG */

	buff = OPENSSL_malloc(olen);
	if (buff == NULL) goto err2;

	/* construct PRF arguments
	 * we construct the PRF argument ourself rather than passing separate
	 * values into the TLS PRF to ensure that the concatenation of values
	 * does not create a prohibited label.
	 */
	vallen = llen + SSL3_RANDOM_SIZE * 2;
	if (use_context)
		{
		vallen += 2 + contextlen;
		}

	val = OPENSSL_malloc(vallen);
	if (val == NULL) goto err2;
	currentvalpos = 0;
	memcpy(val + currentvalpos, (unsigned char *) label, llen);
	currentvalpos += llen;
	memcpy(val + currentvalpos, s->s3->client_random, SSL3_RANDOM_SIZE);
	currentvalpos += SSL3_RANDOM_SIZE;
	memcpy(val + currentvalpos, s->s3->server_random, SSL3_RANDOM_SIZE);
	currentvalpos += SSL3_RANDOM_SIZE;

	if (use_context)
		{
		val[currentvalpos] = (contextlen >> 8) & 0xff;
		currentvalpos++;
		val[currentvalpos] = contextlen & 0xff;
		currentvalpos++;
		if ((contextlen > 0) || (context != NULL))
			{
			memcpy(val + currentvalpos, context, contextlen);
			}
		}

	/* disallow prohibited labels
	 * note that SSL3_RANDOM_SIZE > max(prohibited label len) =
	 * 15, so size of val > max(prohibited label len) = 15 and the
	 * comparisons won't have buffer overflow
	 */
	if (memcmp(val, TLS_MD_CLIENT_FINISH_CONST,
		 TLS_MD_CLIENT_FINISH_CONST_SIZE) == 0) goto err1;
	if (memcmp(val, TLS_MD_SERVER_FINISH_CONST,
		 TLS_MD_SERVER_FINISH_CONST_SIZE) == 0) goto err1;
	if (memcmp(val, TLS_MD_MASTER_SECRET_CONST,
		 TLS_MD_MASTER_SECRET_CONST_SIZE) == 0) goto err1;
	if (memcmp(val, TLS_MD_KEY_EXPANSION_CONST,
		 TLS_MD_KEY_EXPANSION_CONST_SIZE) == 0) goto err1;

	rv = tls1_PRF(s->s3->tmp.new_cipher->algorithm2,
		      val, vallen,
		      NULL, 0,
		      NULL, 0,
		      NULL, 0,
		      NULL, 0,
		      s->session->master_key,s->session->master_key_length,
		      out,buff,olen);

#ifdef KSSL_DEBUG
	printf ("tls1_export_keying_material() complete\n");
#endif	/* KSSL_DEBUG */
	goto ret;
err1:
	SSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL, SSL_R_TLS_ILLEGAL_EXPORTER_LABEL);
	rv = 0;
	goto ret;
err2:
	SSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL, ERR_R_MALLOC_FAILURE);
	rv = 0;
ret:
	if (buff != NULL) OPENSSL_free(buff);
	if (val != NULL) OPENSSL_free(val);
	return(rv);
	}

d1045 1
@


1.1.1.11
log
@Import OpenSSL 1.0.1g
@
text
@d364 1
a364 1
		printf("%02x", s->s3->tmp.key_block[i]);  printf("\n");
d417 1
a417 1
		if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))
d419 1
a419 1
		else if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)
d421 3
d425 1
a425 9
		if (SSL_IS_DTLS(s))
			{
			mac_ctx = EVP_MD_CTX_create();
			if (!mac_ctx)
				goto err;
			s->write_hash = mac_ctx;
			}
		else
			mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
a669 9
/* tls1_enc encrypts/decrypts the record in |s->wrec| / |s->rrec|, respectively.
 *
 * Returns:
 *   0: (in non-constant time) if the record is publically invalid (i.e. too
 *       short etc).
 *   1: if the record's padding is valid / the encryption was successful.
 *   -1: if the record's padding/AEAD-authenticator is invalid or, if sending,
 *       an internal error occured.
 */
d675 1
a675 1
	int bs,i,j,k,pad=0,ret,mac_size=0;
d732 2
a733 1
	if ((s->session == NULL) || (ds == NULL) || (enc == NULL))
a736 1
		ret = 1;
d800 1
a800 1
		unsigned long ui;
d802 1
a802 1
			ds,rec->data,rec->input,l);
d804 3
a806 3
			ds->buf_len, ds->cipher->key_len,
			DES_KEY_SZ, DES_SCHEDULE_SZ,
			ds->cipher->iv_len);
d819 5
d825 1
d842 2
a843 2
		unsigned long i;
		printf("\trec->data=");
d845 2
a846 2
			printf(" %02x", rec->data[i]);  printf("\n");
		}
a848 3
		ret = 1;
		if (EVP_MD_CTX_md(s->read_hash) != NULL)
			mac_size = EVP_MD_CTX_size(s->read_hash);
d850 49
a898 1
			ret = tls1_cbc_remove_padding(s, rec, bs, mac_size);
d902 1
a902 1
	return ret;
a903 1

d959 1
a959 2
			EVP_MD_CTX *hdgst = s->s3->handshake_dgst[idx];
			if (!hdgst || hashsize < 0 || hashsize > (int)(sizeof buf - (size_t)(q-buf)))
d966 3
a968 3
				if (!EVP_MD_CTX_copy_ex(&ctx, hdgst) ||
					!EVP_DigestFinal_ex(&ctx,q,&i) ||
					(i != (unsigned int)hashsize))
d970 1
a970 1
				q+=hashsize;
d993 1
a993 1
	size_t md_size, orig_len;
d996 1
a996 1
	unsigned char header[13];
d1017 6
d1030 1
a1030 2
			if (!EVP_MD_CTX_copy(&hmac,hash))
				return -1;
d1041 1
a1041 1
		memcpy(header, dtlsseq, 8);
d1044 1
a1044 1
		memcpy(header, seq, 8);
d1046 4
a1049 41
	/* kludge: tls1_cbc_remove_padding passes padding length in rec->type */
	orig_len = rec->length+md_size+((unsigned int)rec->type>>8);
	rec->type &= 0xff;

	header[8]=rec->type;
	header[9]=(unsigned char)(ssl->version>>8);
	header[10]=(unsigned char)(ssl->version);
	header[11]=(rec->length)>>8;
	header[12]=(rec->length)&0xff;

	if (!send &&
	    EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
	    ssl3_cbc_record_digest_supported(mac_ctx))
		{
		/* This is a CBC-encrypted record. We must avoid leaking any
		 * timing-side channel information about how many blocks of
		 * data we are hashing because that gives an attacker a
		 * timing-oracle. */
		ssl3_cbc_digest_record(
			mac_ctx,
			md, &md_size,
			header, rec->input,
			rec->length + md_size, orig_len,
			ssl->s3->read_mac_secret,
			ssl->s3->read_mac_secret_size,
			0 /* not SSLv3 */);
		}
	else
		{
		EVP_DigestSignUpdate(mac_ctx,header,sizeof(header));
		EVP_DigestSignUpdate(mac_ctx,rec->input,rec->length);
		t=EVP_DigestSignFinal(mac_ctx,md,&md_size);
		OPENSSL_assert(t > 0);
#ifdef OPENSSL_FIPS
		if (!send && FIPS_mode())
			tls_fips_digest_extra(
	    				ssl->enc_read_ctx,
					mac_ctx, rec->input,
					rec->length, orig_len);
#endif
		}
d1051 1
a1051 2
	if (!stream_mac)
		EVP_MD_CTX_cleanup(&hmac);
@


