head	1.71;
access;
symbols
	OPENBSD_5_8:1.61.0.4
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.59.0.4
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.54.0.2
	OPENBSD_5_6_BASE:1.54
	butholakala:1.18
	openssl_1_0_1_g:1.1.1.13
	OPENBSD_5_5:1.18.0.8
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.4
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	openssl_1_0_1_c:1.1.1.12
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	openssl_1_0_0_f:1.1.1.11
	openssl_1_0_0_e:1.1.1.10
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	openssh_1_0_0_a:1.1.1.9
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	openssl_0_9_8_k:1.1.1.8
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	openssl_0_9_8_j:1.1.1.8
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.11
	OPENBSD_4_4:1.11.0.14
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.12
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.10
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENSSL_0_9_7G:1.1.1.6
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENSSL_0_9_7D:1.1.1.5
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.71
date	2015.09.11.17.54.23;	author jsing;	state dead;
branches;
next	1.70;
commitid	xUO4TxX2aWuC1cir;

1.70
date	2015.09.11.17.11.53;	author jsing;	state Exp;
branches;
next	1.69;
commitid	rs7MJUl5HqwBT9q6;

1.69
date	2015.09.11.17.08.50;	author jsing;	state Exp;
branches;
next	1.68;
commitid	Cu2QpQbOAsdEyjFC;

1.68
date	2015.09.11.17.04.39;	author jsing;	state Exp;
branches;
next	1.67;
commitid	csGjbouXtrA2P64R;

1.67
date	2015.09.11.17.03.03;	author jsing;	state Exp;
branches;
next	1.66;
commitid	DFvv2qXJy5GNlRwX;

1.66
date	2015.09.11.17.01.19;	author jsing;	state Exp;
branches;
next	1.65;
commitid	jQZ3WzxwYTOZter3;

1.65
date	2015.09.11.16.59.17;	author jsing;	state Exp;
branches;
next	1.64;
commitid	ZY2utudxRbezwjHW;

1.64
date	2015.09.11.16.56.17;	author jsing;	state Exp;
branches;
next	1.63;
commitid	RyfjHG1AQPjhMazY;

1.63
date	2015.09.11.16.53.51;	author jsing;	state Exp;
branches;
next	1.62;
commitid	kcXUxmEdE7K553CY;

1.62
date	2015.09.10.15.56.26;	author jsing;	state Exp;
branches;
next	1.61;
commitid	vHznCDK3idwNEFz4;

1.61
date	2015.07.19.20.32.18;	author doug;	state Exp;
branches;
next	1.60;
commitid	JJGxWtixsF6e0H2B;

1.60
date	2015.06.17.14.27.56;	author jsing;	state Exp;
branches;
next	1.59;
commitid	bj1SO1XyllNsvf5a;

1.59
date	2015.02.22.15.54.27;	author jsing;	state Exp;
branches;
next	1.58;
commitid	9t8bOP5HFWMq1Big;

1.58
date	2014.12.15.00.46.53;	author doug;	state Exp;
branches;
next	1.57;
commitid	I2ue40Sqz1Sg9KmB;

1.57
date	2014.12.10.15.43.31;	author jsing;	state Exp;
branches;
next	1.56;
commitid	9GGF3DCNTm9Bs8E3;

1.56
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.55;
commitid	M3pvHgIFoWUHNqJn;

1.55
date	2014.10.18.03.04.28;	author doug;	state Exp;
branches;
next	1.54;
commitid	d3IDuvWT3qgh5zCJ;

1.54
date	2014.08.07.20.02.23;	author miod;	state Exp;
branches;
next	1.53;
commitid	DMh9IXTC6aDWVuh5;

1.53
date	2014.08.07.19.46.31;	author miod;	state Exp;
branches;
next	1.52;
commitid	vayOLqnrIMw5dnz8;

1.52
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.51;
commitid	lsH7iukeZYSZBx6F;

1.51
date	2014.07.09.11.25.42;	author jsing;	state Exp;
branches;
next	1.50;
commitid	N5P2FUkVkAd7ODs9;

1.50
date	2014.06.18.04.50.44;	author miod;	state Exp;
branches;
next	1.49;
commitid	dkMgImBMHfb2ZgDR;

1.49
date	2014.06.15.15.29.25;	author jsing;	state Exp;
branches;
next	1.48;
commitid	G9UpwpcoMkFCFqBD;

1.48
date	2014.06.13.16.08.03;	author jsing;	state Exp;
branches;
next	1.47;
commitid	dhXoeFCELfMlLPZ2;

1.47
date	2014.06.13.16.04.13;	author jsing;	state Exp;
branches;
next	1.46;
commitid	RmASjvrL5G8aiDs0;

1.46
date	2014.06.13.15.28.49;	author jsing;	state Exp;
branches;
next	1.45;
commitid	cipAbdWEjQgukKRw;

1.45
date	2014.06.13.14.58.05;	author jsing;	state Exp;
branches;
next	1.44;
commitid	OAqfBz1YPsWzikoy;

1.44
date	2014.06.13.14.38.13;	author jsing;	state Exp;
branches;
next	1.43;
commitid	HZpl3oAqkXKhhK4w;

1.43
date	2014.06.13.14.15.14;	author jsing;	state Exp;
branches;
next	1.42;
commitid	zcRrsIVGzKQJdkuH;

1.42
date	2014.06.13.14.11.35;	author jsing;	state Exp;
branches;
next	1.41;
commitid	otMnOMNFCu2Qs69k;

1.41
date	2014.06.13.12.41.01;	author jsing;	state Exp;
branches;
next	1.40;
commitid	moiy3a1Eqthw0OOH;

1.40
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	mJUVYpkFBZ0Zv2bG;

1.39
date	2014.06.11.15.44.10;	author jsing;	state Exp;
branches;
next	1.38;
commitid	atiHl7idnrYpOeRd;

1.38
date	2014.06.10.18.00.59;	author logan;	state Exp;
branches;
next	1.37;
commitid	9WXIiOBXlfEKG0dB;

1.37
date	2014.06.10.14.49.15;	author jsing;	state Exp;
branches;
next	1.36;
commitid	M3Uh5jN6erVnwqoG;

1.36
date	2014.06.10.12.56.39;	author jsing;	state Exp;
branches;
next	1.35;
commitid	onJUtY4fw6FpgQq9;

1.35
date	2014.06.10.11.40.22;	author jsing;	state Exp;
branches;
next	1.34;
commitid	gRXuvHF0WhfoxEmI;

1.34
date	2014.06.10.11.32.38;	author jsing;	state Exp;
branches;
next	1.33;
commitid	nGjnrRHQzsn3r9Fa;

1.33
date	2014.06.10.11.26.34;	author jsing;	state Exp;
branches;
next	1.32;
commitid	hPv8LXk5NLfs60xD;

1.32
date	2014.06.09.13.54.01;	author jsing;	state Exp;
branches;
next	1.31;
commitid	mW109ptzshT2okvb;

1.31
date	2014.06.08.15.10.14;	author jsing;	state Exp;
branches;
next	1.30;
commitid	mOEr8ksZemEjdEvz;

1.30
date	2014.06.07.14.37.35;	author jsing;	state Exp;
branches;
next	1.29;
commitid	JwXanfIzQdnBhF9D;

1.29
date	2014.06.07.14.35.31;	author jsing;	state Exp;
branches;
next	1.28;
commitid	moce2ayovF9fb7cV;

1.28
date	2014.05.29.08.47.56;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2014.05.28.13.07.47;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2014.05.27.13.11.56;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2014.05.25.13.27.38;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.20.12.48.19;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.15.19.42.56;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.15.17.46.17;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.14.16.07.22;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2013.02.14.15.11.43;	author markus;	state Exp;
branches
	1.18.4.1
	1.18.8.1;
next	1.17;

1.17
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.08.03.15;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.03.40;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.37;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.29;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.27;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.34;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.08;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.38;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.42.06;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.37.27;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2011.11.03.02.32.21;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.01.05.22.59.09;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.18.4.1
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.18.8.1
date	2014.08.09.16.54.58;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;


desc
@@


1.71
log
@Merge the remnants of s3_enc.c into t1_enc.c.

ok beck@@
@
text
@/* $OpenBSD: s3_enc.c,v 1.70 2015/09/11 17:11:53 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/evp.h>
#include <openssl/md5.h>

void
ssl3_cleanup_key_block(SSL *s)
{
	if (s->s3->tmp.key_block != NULL) {
		explicit_bzero(s->s3->tmp.key_block,
		    s->s3->tmp.key_block_length);
		free(s->s3->tmp.key_block);
		s->s3->tmp.key_block = NULL;
	}
	s->s3->tmp.key_block_length = 0;
}

int
ssl3_init_finished_mac(SSL *s)
{
	BIO_free(s->s3->handshake_buffer);
	ssl3_free_digest_list(s);

	s->s3->handshake_buffer = BIO_new(BIO_s_mem());
	if (s->s3->handshake_buffer == NULL)
		return (0);

	(void)BIO_set_close(s->s3->handshake_buffer, BIO_CLOSE);

	return (1);
}

void
ssl3_free_digest_list(SSL *s)
{
	int i;

	if (s == NULL)
		return;

	if (s->s3->handshake_dgst == NULL)
		return;
	for (i = 0; i < SSL_MAX_DIGEST; i++) {
		if (s->s3->handshake_dgst[i])
			EVP_MD_CTX_destroy(s->s3->handshake_dgst[i]);
	}
	free(s->s3->handshake_dgst);
	s->s3->handshake_dgst = NULL;
}

void
ssl3_finish_mac(SSL *s, const unsigned char *buf, int len)
{
	if (s->s3->handshake_buffer &&
	    !(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) {
		BIO_write(s->s3->handshake_buffer, (void *)buf, len);
	} else {
		int i;
		for (i = 0; i < SSL_MAX_DIGEST; i++) {
			if (s->s3->handshake_dgst[i]!= NULL)
				EVP_DigestUpdate(s->s3->handshake_dgst[i], buf, len);
		}
	}
}

int
ssl3_digest_cached_records(SSL *s)
{
	int i;
	long mask;
	const EVP_MD *md;
	long hdatalen;
	void *hdata;

	ssl3_free_digest_list(s);

	s->s3->handshake_dgst = calloc(SSL_MAX_DIGEST, sizeof(EVP_MD_CTX *));
	if (s->s3->handshake_dgst == NULL) {
		SSLerr(SSL_F_SSL3_DIGEST_CACHED_RECORDS, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
	if (hdatalen <= 0) {
		SSLerr(SSL_F_SSL3_DIGEST_CACHED_RECORDS,
		    SSL_R_BAD_HANDSHAKE_LENGTH);
		return 0;
	}

	/* Loop through bits of the algorithm2 field and create MD contexts. */
	for (i = 0; ssl_get_handshake_digest(i, &mask, &md); i++) {
		if ((mask & ssl_get_algorithm2(s)) && md) {
			s->s3->handshake_dgst[i] = EVP_MD_CTX_create();
			if (s->s3->handshake_dgst[i] == NULL) {
				SSLerr(SSL_F_SSL3_DIGEST_CACHED_RECORDS,
				    ERR_R_MALLOC_FAILURE);
				return 0;
			}
			if (!EVP_DigestInit_ex(s->s3->handshake_dgst[i],
			    md, NULL)) {
				EVP_MD_CTX_destroy(s->s3->handshake_dgst[i]);
				return 0;
			}
			if (!EVP_DigestUpdate(s->s3->handshake_dgst[i], hdata,
			    hdatalen))
				return 0;
		}
	}

	if (!(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) {
		BIO_free(s->s3->handshake_buffer);
		s->s3->handshake_buffer = NULL;
	}

	return 1;
}

void
ssl3_record_sequence_increment(unsigned char *seq)
{
	int i;

	for (i = SSL3_SEQUENCE_SIZE - 1; i >= 0; i--) {
		if (++seq[i] != 0)
			break;
	}
}
@


1.70
log
@Nuke ssl3_alert_code().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.69 2015/09/11 17:08:50 jsing Exp $ */
@


1.69
log
@Nuke ssl3_cert_verify_mac() and ssl3_handshake_mac().

We also no longer need the ssl3_pad_1 and ssl3_pad_2 arrays...

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.68 2015/09/11 17:04:39 jsing Exp $ */
a263 71
	}
}

int
ssl3_alert_code(int code)
{
	switch (code) {
	case SSL_AD_CLOSE_NOTIFY:
		return (SSL3_AD_CLOSE_NOTIFY);
	case SSL_AD_UNEXPECTED_MESSAGE:
		return (SSL3_AD_UNEXPECTED_MESSAGE);
	case SSL_AD_BAD_RECORD_MAC:
		return (SSL3_AD_BAD_RECORD_MAC);
	case SSL_AD_DECRYPTION_FAILED:
		return (SSL3_AD_BAD_RECORD_MAC);
	case SSL_AD_RECORD_OVERFLOW:
		return (SSL3_AD_BAD_RECORD_MAC);
	case SSL_AD_DECOMPRESSION_FAILURE:
		return (SSL3_AD_DECOMPRESSION_FAILURE);
	case SSL_AD_HANDSHAKE_FAILURE:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_NO_CERTIFICATE:
		return (SSL3_AD_NO_CERTIFICATE);
	case SSL_AD_BAD_CERTIFICATE:
		return (SSL3_AD_BAD_CERTIFICATE);
	case SSL_AD_UNSUPPORTED_CERTIFICATE:
		return (SSL3_AD_UNSUPPORTED_CERTIFICATE);
	case SSL_AD_CERTIFICATE_REVOKED:
		return (SSL3_AD_CERTIFICATE_REVOKED);
	case SSL_AD_CERTIFICATE_EXPIRED:
		return (SSL3_AD_CERTIFICATE_EXPIRED);
	case SSL_AD_CERTIFICATE_UNKNOWN:
		return (SSL3_AD_CERTIFICATE_UNKNOWN);
	case SSL_AD_ILLEGAL_PARAMETER:
		return (SSL3_AD_ILLEGAL_PARAMETER);
	case SSL_AD_UNKNOWN_CA:
		return (SSL3_AD_BAD_CERTIFICATE);
	case SSL_AD_ACCESS_DENIED:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_DECODE_ERROR:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_DECRYPT_ERROR:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_EXPORT_RESTRICTION:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_PROTOCOL_VERSION:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_INSUFFICIENT_SECURITY:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_INTERNAL_ERROR:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_INAPPROPRIATE_FALLBACK:
		return (TLS1_AD_INAPPROPRIATE_FALLBACK);
	case SSL_AD_USER_CANCELLED:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_NO_RENEGOTIATION:
		return(-1); /* Don't send it :-) */
	case SSL_AD_UNSUPPORTED_EXTENSION:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_CERTIFICATE_UNOBTAINABLE:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_UNRECOGNIZED_NAME:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_BAD_CERTIFICATE_HASH_VALUE:
		return (SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_UNKNOWN_PSK_IDENTITY:
		return (TLS1_AD_UNKNOWN_PSK_IDENTITY);
	default:
		return (-1);
@


1.68
log
@Nuke ssl3_final_finish_mac().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.67 2015/09/11 17:03:03 jsing Exp $ */
a144 21
static unsigned char ssl3_pad_1[48] = {
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
};

static unsigned char ssl3_pad_2[48] = {
	0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
	0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
	0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
	0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
	0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
	0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c
};

static int ssl3_handshake_mac(SSL *s, int md_nid, const char *sender,
    int len, unsigned char *p);

a253 60
}

int
ssl3_cert_verify_mac(SSL *s, int md_nid, unsigned char *p)
{
	return (ssl3_handshake_mac(s, md_nid, NULL, 0, p));
}

static int
ssl3_handshake_mac(SSL *s, int md_nid, const char *sender, int len,
    unsigned char *p)
{
	unsigned int ret;
	int npad, n;
	unsigned int i;
	unsigned char md_buf[EVP_MAX_MD_SIZE];
	EVP_MD_CTX ctx, *d = NULL;

	if (s->s3->handshake_buffer)
		if (!ssl3_digest_cached_records(s))
			return 0;

	/* Search for digest of specified type in the handshake_dgst array. */
	for (i = 0; i < SSL_MAX_DIGEST; i++) {
		if (s->s3->handshake_dgst[i] &&
		    EVP_MD_CTX_type(s->s3->handshake_dgst[i]) == md_nid) {
			d = s->s3->handshake_dgst[i];
			break;
		}
	}
	if (!d) {
		SSLerr(SSL_F_SSL3_HANDSHAKE_MAC, SSL_R_NO_REQUIRED_DIGEST);
		return 0;
	}
	EVP_MD_CTX_init(&ctx);
	if (!EVP_MD_CTX_copy_ex(&ctx, d))
		return 0;
	n = EVP_MD_CTX_size(&ctx);
	if (n < 0)
		return 0;

	npad = (48 / n) * n;
	if (sender != NULL)
		EVP_DigestUpdate(&ctx, sender, len);
	EVP_DigestUpdate(&ctx, s->session->master_key,
	    s->session->master_key_length);
	EVP_DigestUpdate(&ctx, ssl3_pad_1, npad);
	EVP_DigestFinal_ex(&ctx, md_buf, &i);

	if (!EVP_DigestInit_ex(&ctx, EVP_MD_CTX_md(&ctx), NULL))
		return 0;
	EVP_DigestUpdate(&ctx, s->session->master_key,
	    s->session->master_key_length);
	EVP_DigestUpdate(&ctx, ssl3_pad_2, npad);
	EVP_DigestUpdate(&ctx, md_buf, i);
	EVP_DigestFinal_ex(&ctx, p, &ret);

	EVP_MD_CTX_cleanup(&ctx);

	return ((int)ret);
@


1.67
log
@Nuke ssl3_change_cipher_state().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.66 2015/09/11 17:01:19 jsing Exp $ */
a280 15
}

int
ssl3_final_finish_mac(SSL *s, const char *sender, int len, unsigned char *p)
{
	int ret_md5, ret_sha1;

	ret_md5 = ssl3_handshake_mac(s, NID_md5, sender, len, p);
	if (ret_md5 == 0)
		return 0;
	p += ret_md5;
	ret_sha1 = ssl3_handshake_mac(s, NID_sha1, sender, len, p);
	if (ret_sha1 == 0)
		return 0;
	return (ret_md5 + ret_sha1);
@


1.66
log
@Nuke ssl3_generate_master_secret().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.65 2015/09/11 16:59:17 jsing Exp $ */
a164 108

int
ssl3_change_cipher_state(SSL *s, int which)
{
	const unsigned char *client_write_mac_secret, *server_write_mac_secret;
	const unsigned char *client_write_key, *server_write_key;
	const unsigned char *client_write_iv, *server_write_iv;
	const unsigned char *mac_secret, *key, *iv;
	unsigned char *key_block;
	int mac_len, key_len, iv_len;
	char is_read, use_client_keys;
	EVP_CIPHER_CTX *cipher_ctx;
	const EVP_CIPHER *cipher;
	const EVP_MD *mac;


	cipher = s->s3->tmp.new_sym_enc;
	mac = s->s3->tmp.new_hash;

	/* mac == NULL will lead to a crash later */
	OPENSSL_assert(mac);

	/*
	 * is_read is true if we have just read a ChangeCipherSpec message,
	 * that is we need to update the read cipherspec. Otherwise we have
	 * just written one.
	 */
	is_read = (which & SSL3_CC_READ) != 0;

	/*
	 * use_client_keys is true if we wish to use the keys for the "client
	 * write" direction. This is the case if we're a client sending a
	 * ChangeCipherSpec, or a server reading a client's ChangeCipherSpec.
	 */
	use_client_keys = ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
	    (which == SSL3_CHANGE_CIPHER_SERVER_READ));


	if (is_read) {
		EVP_CIPHER_CTX_free(s->enc_read_ctx);
		s->enc_read_ctx = NULL;
		if ((cipher_ctx = EVP_CIPHER_CTX_new()) == NULL)
			goto err;
		s->enc_read_ctx = cipher_ctx;

		if (ssl_replace_hash(&s->read_hash, mac) == NULL)
			goto err;
	} else {
		EVP_CIPHER_CTX_free(s->enc_write_ctx);
		s->enc_write_ctx = NULL;
		if ((cipher_ctx = EVP_CIPHER_CTX_new()) == NULL)
			goto err;
		s->enc_write_ctx = cipher_ctx;

		if (ssl_replace_hash(&s->write_hash, mac) == NULL)
			goto err;
	}

	memset(is_read ? s->s3->read_sequence : s->s3->write_sequence,
	    0, SSL3_SEQUENCE_SIZE);

	mac_len = EVP_MD_size(mac);
	key_len = EVP_CIPHER_key_length(cipher);
	iv_len = EVP_CIPHER_iv_length(cipher);

	if (mac_len < 0)
		goto err2;

	key_block = s->s3->tmp.key_block;
	client_write_mac_secret = key_block;
	key_block += mac_len;
	server_write_mac_secret = key_block;
	key_block += mac_len;
	client_write_key = key_block;
	key_block += key_len;
	server_write_key = key_block;
	key_block += key_len;
	client_write_iv = key_block;
	key_block += iv_len;
	server_write_iv = key_block;
	key_block += iv_len;

	if (use_client_keys) {
		mac_secret = client_write_mac_secret;
		key = client_write_key;
		iv = client_write_iv;
	} else {
		mac_secret = server_write_mac_secret;
		key = server_write_key;
		iv = server_write_iv;
	}

	if (key_block - s->s3->tmp.key_block != s->s3->tmp.key_block_length) {
		SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);
		goto err2;
	}

	memcpy(is_read ? s->s3->read_mac_secret : s->s3->write_mac_secret,
	    mac_secret, mac_len);

	EVP_CipherInit_ex(cipher_ctx, cipher, NULL, key, iv, !is_read);

	return (1);
err:
	SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);
err2:
	return (0);
}
@


1.65
log
@Nuke ssl3_setup_key_block() and ssl3_generate_key_block().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.64 2015/09/11 16:56:17 jsing Exp $ */
a468 32
}

int
ssl3_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
    int len)
{
	static const unsigned char *salt[3] = { "A", "BB", "CCC", };
	unsigned char buf[EVP_MAX_MD_SIZE];
	EVP_MD_CTX ctx;
	int i, ret = 0;
	unsigned int n;

	EVP_MD_CTX_init(&ctx);
	for (i = 0; i < 3; i++) {
		if (!EVP_DigestInit_ex(&ctx, s->ctx->sha1, NULL))
			return 0;
		EVP_DigestUpdate(&ctx, salt[i], strlen((const char *)salt[i]));
		EVP_DigestUpdate(&ctx, p, len);
		EVP_DigestUpdate(&ctx, s->s3->client_random, SSL3_RANDOM_SIZE);
		EVP_DigestUpdate(&ctx, s->s3->server_random, SSL3_RANDOM_SIZE);
		EVP_DigestFinal_ex(&ctx, buf, &n);

		if (!EVP_DigestInit_ex(&ctx, s->ctx->md5, NULL))
			return 0;
		EVP_DigestUpdate(&ctx, p, len);
		EVP_DigestUpdate(&ctx, buf, n);
		EVP_DigestFinal_ex(&ctx, out, &n);
		out += n;
		ret += n;
	}
	EVP_MD_CTX_cleanup(&ctx);
	return (ret);
@


1.64
log
@Nuke n_ssl3_mac().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.63 2015/09/11 16:53:51 jsing Exp $ */
a165 52
static int
ssl3_generate_key_block(SSL *s, unsigned char *km, int num)
{
	EVP_MD_CTX m5;
	EVP_MD_CTX s1;
	unsigned char buf[16], smd[SHA_DIGEST_LENGTH];
	unsigned char c = 'A';
	unsigned int i, j, k;

	k = 0;
	EVP_MD_CTX_init(&m5);
	EVP_MD_CTX_init(&s1);
	for (i = 0; (int)i < num; i += MD5_DIGEST_LENGTH) {
		k++;
		if (k > sizeof buf) {
			/* bug: 'buf' is too small for this ciphersuite */
			SSLerr(SSL_F_SSL3_GENERATE_KEY_BLOCK,
			    ERR_R_INTERNAL_ERROR);
			return 0;
		}

		for (j = 0; j < k; j++)
			buf[j] = c;
		c++;
		if (!EVP_DigestInit_ex(&s1, EVP_sha1(), NULL))
			return 0;
		EVP_DigestUpdate(&s1, buf, k);
		EVP_DigestUpdate(&s1, s->session->master_key,
		    s->session->master_key_length);
		EVP_DigestUpdate(&s1, s->s3->server_random, SSL3_RANDOM_SIZE);
		EVP_DigestUpdate(&s1, s->s3->client_random, SSL3_RANDOM_SIZE);
		EVP_DigestFinal_ex(&s1, smd, NULL);

		if (!EVP_DigestInit_ex(&m5, EVP_md5(), NULL))
			return 0;
		EVP_DigestUpdate(&m5, s->session->master_key,
		    s->session->master_key_length);
		EVP_DigestUpdate(&m5, smd, SHA_DIGEST_LENGTH);
		if ((int)(i + MD5_DIGEST_LENGTH) > num) {
			EVP_DigestFinal_ex(&m5, smd, NULL);
			memcpy(km, smd, (num - i));
		} else
			EVP_DigestFinal_ex(&m5, km, NULL);

		km += MD5_DIGEST_LENGTH;
	}
	explicit_bzero(smd, SHA_DIGEST_LENGTH);
	EVP_MD_CTX_cleanup(&m5);
	EVP_MD_CTX_cleanup(&s1);
	return 1;
}

a270 65
	return (0);
}

int
ssl3_setup_key_block(SSL *s)
{
	int key_block_len, mac_len, key_len, iv_len;
	unsigned char *key_block;
	const EVP_CIPHER *cipher;
	const EVP_MD *mac;
	int ret = 0;

	if (s->s3->tmp.key_block_length != 0)
		return (1);

	if (!ssl_cipher_get_evp(s->session, &cipher, &mac, NULL, NULL)) {
		SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,
		    SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
		return (0);
	}

	s->s3->tmp.new_sym_enc = cipher;
	s->s3->tmp.new_hash = mac;

	mac_len = EVP_MD_size(mac);
	key_len = EVP_CIPHER_key_length(cipher);
	iv_len = EVP_CIPHER_iv_length(cipher);

	if (mac_len < 0)
		return 0;

	ssl3_cleanup_key_block(s);

	if ((key_block = reallocarray(NULL, mac_len + key_len + iv_len, 2))
	    == NULL)
		goto err;
	key_block_len = (mac_len + key_len + iv_len) * 2;

	s->s3->tmp.key_block_length = key_block_len;
	s->s3->tmp.key_block = key_block;

	ret = ssl3_generate_key_block(s, key_block, key_block_len);

	if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)) {
		/*
		 * Enable vulnerability countermeasure for CBC ciphers with
		 * known-IV problem (http://www.openssl.org/~bodo/tls-cbc.txt)
		 */
		s->s3->need_empty_fragments = 1;

		if (s->session->cipher != NULL) {
			if (s->session->cipher->algorithm_enc == SSL_eNULL)
				s->s3->need_empty_fragments = 0;

#ifndef OPENSSL_NO_RC4
			if (s->session->cipher->algorithm_enc == SSL_RC4)
				s->s3->need_empty_fragments = 0;
#endif
		}
	}

	return ret;

err:
	SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE);
@


1.63
log
@Nuke ssl3_enc().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.62 2015/09/10 15:56:26 jsing Exp $ */
a574 98
}

int
n_ssl3_mac(SSL *ssl, unsigned char *md, int send)
{
	SSL3_RECORD *rec;
	unsigned char *mac_sec, *seq;
	EVP_MD_CTX md_ctx;
	const EVP_MD_CTX *hash;
	unsigned char *p, rec_char;
	size_t md_size, orig_len;
	int npad;
	int t;

	if (send) {
		rec = &(ssl->s3->wrec);
		mac_sec = &(ssl->s3->write_mac_secret[0]);
		seq = &(ssl->s3->write_sequence[0]);
		hash = ssl->write_hash;
	} else {
		rec = &(ssl->s3->rrec);
		mac_sec = &(ssl->s3->read_mac_secret[0]);
		seq = &(ssl->s3->read_sequence[0]);
		hash = ssl->read_hash;
	}

	t = EVP_MD_CTX_size(hash);
	if (t < 0)
		return -1;
	md_size = t;
	npad = (48 / md_size) * md_size;

	/* kludge: ssl3_cbc_remove_padding passes padding length in rec->type */
	orig_len = rec->length + md_size + ((unsigned int)rec->type >> 8);
	rec->type &= 0xff;

	if (!send &&
	    EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
	    ssl3_cbc_record_digest_supported(hash)) {
		/* This is a CBC-encrypted record. We must avoid leaking any
		 * timing-side channel information about how many blocks of
		 * data we are hashing because that gives an attacker a
		 * timing-oracle. */

		/* npad is, at most, 48 bytes and that's with MD5:
		 *   16 + 48 + 8 (sequence bytes) + 1 + 2 = 75.
		 *
		 * With SHA-1 (the largest hash speced for SSLv3) the hash size
		 * goes up 4, but npad goes down by 8, resulting in a smaller
		 * total size. */
		unsigned char header[75];
		unsigned j = 0;
		memcpy(header + j, mac_sec, md_size);
		j += md_size;
		memcpy(header + j, ssl3_pad_1, npad);
		j += npad;
		memcpy(header + j, seq, 8);
		j += 8;
		header[j++] = rec->type;
		header[j++] = rec->length >> 8;
		header[j++] = rec->length & 0xff;

		if (!ssl3_cbc_digest_record(hash, md, &md_size, header,
		    rec->input, rec->length + md_size, orig_len, mac_sec,
		    md_size, 1 /* is SSLv3 */))
			return (-1);
	} else {
		unsigned int md_size_u;
		/* Chop the digest off the end :-) */
		EVP_MD_CTX_init(&md_ctx);

		if (!EVP_MD_CTX_copy_ex(&md_ctx, hash))
			return (-1);
		EVP_DigestUpdate(&md_ctx, mac_sec, md_size);
		EVP_DigestUpdate(&md_ctx, ssl3_pad_1, npad);
		EVP_DigestUpdate(&md_ctx, seq, 8);
		rec_char = rec->type;
		EVP_DigestUpdate(&md_ctx, &rec_char, 1);
		p = md;
		s2n(rec->length, p);
		EVP_DigestUpdate(&md_ctx, md, 2);
		EVP_DigestUpdate(&md_ctx, rec->input, rec->length);
		EVP_DigestFinal_ex(&md_ctx, md, NULL);

		if (!EVP_MD_CTX_copy_ex(&md_ctx, hash))
			return (-1);
		EVP_DigestUpdate(&md_ctx, mac_sec, md_size);
		EVP_DigestUpdate(&md_ctx, ssl3_pad_2, npad);
		EVP_DigestUpdate(&md_ctx, md, md_size);
		EVP_DigestFinal_ex(&md_ctx, md, &md_size_u);
		md_size = md_size_u;

		EVP_MD_CTX_cleanup(&md_ctx);
	}

	ssl3_record_sequence_increment(seq);

	return (md_size);
@


1.62
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.61 2015/07/19 20:32:18 doug Exp $ */
a400 71
}

/* ssl3_enc encrypts/decrypts the record in |s->wrec| / |s->rrec|, respectively.
 *
 * Returns:
 *   0: (in non-constant time) if the record is publically invalid (i.e. too
 *       short etc).
 *   1: if the record's padding is valid / the encryption was successful.
 *   -1: if the record's padding is invalid or, if sending, an internal error
 *       occured.
 */
int
ssl3_enc(SSL *s, int send)
{
	SSL3_RECORD *rec;
	EVP_CIPHER_CTX *ds;
	unsigned long l;
	int bs, i, mac_size = 0;
	const EVP_CIPHER *enc;

	if (send) {
		ds = s->enc_write_ctx;
		rec = &(s->s3->wrec);
		if (s->enc_write_ctx == NULL)
			enc = NULL;
		else
			enc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx);
	} else {
		ds = s->enc_read_ctx;
		rec = &(s->s3->rrec);
		if (s->enc_read_ctx == NULL)
			enc = NULL;
		else
			enc = EVP_CIPHER_CTX_cipher(s->enc_read_ctx);
	}

	if ((s->session == NULL) || (ds == NULL) || (enc == NULL)) {
		memmove(rec->data, rec->input, rec->length);
		rec->input = rec->data;
	} else {
		l = rec->length;
		bs = EVP_CIPHER_block_size(ds->cipher);

		/* COMPRESS */

		if ((bs != 1) && send) {
			i = bs - ((int)l % bs);

			/* we need to add 'i-1' padding bytes */
			l += i;
			/* the last of these zero bytes will be overwritten
			 * with the padding length. */
			memset(&rec->input[rec->length], 0, i);
			rec->length += i;
			rec->input[l - 1] = (i - 1);
		}

		if (!send) {
			if (l == 0 || l % bs != 0)
				return 0;
			/* otherwise, rec->length >= bs */
		}

		EVP_Cipher(ds, rec->data, rec->input, l);

		if (EVP_MD_CTX_md(s->read_hash) != NULL)
			mac_size = EVP_MD_CTX_size(s->read_hash);
		if ((bs != 1) && !send)
			return ssl3_cbc_remove_padding(s, rec, bs, mac_size);
	}
	return (1);
@


1.61
log
@Allow *_free() functions in libssl to handle NULL input.

This mimics free()'s behavior which makes error handling simpler.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.60 2015/06/17 14:27:56 jsing Exp $ */
d212 1
a212 1
	OPENSSL_cleanse(smd, SHA_DIGEST_LENGTH);
d395 1
a395 1
		OPENSSL_cleanse(s->s3->tmp.key_block,
@


1.60
log
@Keep alerts sorted by alert code.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.59 2015/02/22 15:54:27 jsing Exp $ */
d493 3
@


1.59
log
@Reluctantly add server-side support for TLS_FALLBACK_SCSV.

This allows for clients that willingly choose to perform a downgrade and
attempt to establish a second connection at a lower protocol after the
previous attempt unexpectedly failed, to be notified and have the second
connection aborted, if the server does in fact support a higher protocol.

TLS has perfectly good version negotiation and client-side fallback is
dangerous. Despite this, in order to maintain maximum compatability with
broken web servers, most mainstream browsers implement this. Furthermore,
TLS_FALLBACK_SCSV only works if both the client and server support it and
there is effectively no way to tell if this is the case, unless you control
both ends.

Unfortunately, various auditors and vulnerability scanners (including
certain online assessment websites) consider the presence of a not yet
standardised feature to be important for security, even if the clients do
not perform client-side downgrade or the server only supports current TLS
protocols.

Diff is loosely based on OpenSSL with some inspiration from BoringSSL.

Discussed with beck@@ and miod@@.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.58 2014/12/15 00:46:53 doug Exp $ */
d834 2
d838 2
a839 1
	case SSL_AD_NO_RENEGOTIATION:	return(-1); /* Don't send it :-) */
a851 2
	case SSL_AD_INAPPROPRIATE_FALLBACK:
		return (TLS1_AD_INAPPROPRIATE_FALLBACK);
@


1.58
log
@Add error handling for EVP_DigestInit_ex().

A few EVP_DigestInit_ex() calls were left alone since reporting an
error would change the public API.

Changed internal ssl3_cbc_digest_record() to return a value due to the above
change.  It will also now set md_out_size=0 on failure.

This is based on part of BoringSSL's commit to fix malloc crashes:
https://boringssl.googlesource.com/boringssl/+/69a01608f33ab6fe2c3485d94aef1fe9eacf5364

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.57 2014/12/10 15:43:31 jsing Exp $ */
d849 2
@


1.57
log
@ssl3_init_finished_mac() calls BIO_new() which can fail since it in turn
calls malloc(). Instead of silently continuing on failure, check the return
value of BIO_new() and propagate failure back to the caller for appropriate
handling.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.56 2014/11/16 14:12:47 jsing Exp $ */
d190 2
a191 1
		EVP_DigestInit_ex(&s1, EVP_sha1(), NULL);
d199 2
a200 1
		EVP_DigestInit_ex(&m5, EVP_md5(), NULL);
d552 2
a553 1
			    md, NULL))
d555 1
d632 2
a633 1
	EVP_DigestInit_ex(&ctx, EVP_MD_CTX_md(&ctx), NULL);
d705 4
a708 3
		ssl3_cbc_digest_record(hash, md, &md_size, header, rec->input,
		    rec->length + md_size, orig_len, mac_sec, md_size,
		    1 /* is SSLv3 */);
d766 2
a767 1
		EVP_DigestInit_ex(&ctx, s->ctx->sha1, NULL);
d774 2
a775 1
		EVP_DigestInit_ex(&ctx, s->ctx->md5, NULL);
@


1.56
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.55 2014/10/18 03:04:28 doug Exp $ */
d472 1
a472 1
void
d477 1
d479 2
d483 2
@


1.55
log
@Typical malloc() with size multiplication to reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.54 2014/08/07 20:02:23 miod Exp $ */
d139 1
d141 1
@


1.54
log
@Oops, revert changes commited by mistake. The previous commit was supposed
to only apply to s23_srvr.c.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.52 2014/07/10 08:51:14 tedu Exp $ */
a349 2
	key_block_len = (mac_len + key_len + iv_len) * 2;

d352 2
a353 1
	if ((key_block = malloc(key_block_len)) == NULL)
d355 1
@


1.53
log
@When you expect a function to return a particular value, don't put a comment
saying that you expect it to return that value and compare it against zero
because it is supposedly faster, for this leads to bugs (especially given the
high rate of sloppy cut'n'paste within ssl3 and dtls1 routines in this
library).

Instead, compare for the exact value it ought to return upon success.

ok deraadt@@
@
text
@d610 1
a610 1
	if (n <= 0)
d658 1
a658 1
	if (t <= 0)
@


1.52
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.51 2014/07/09 11:25:42 jsing Exp $ */
d610 1
a610 1
	if (n < 0)
d658 1
a658 1
	if (t < 0)
@


1.51
log
@tedu the SSL export cipher handling - since we do not have enabled export
ciphers we no longer need the flags or code to support it.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.50 2014/06/18 04:50:44 miod Exp $ */
a227 3
#ifndef OPENSSL_NO_COMP
	const SSL_COMP *comp;
#endif
a249 35
#ifndef OPENSSL_NO_COMP
	comp = s->s3->tmp.new_compression;
	if (is_read) {
		if (s->expand != NULL) {
			COMP_CTX_free(s->expand);
			s->expand = NULL;
		}
		if (comp != NULL) {
			s->expand = COMP_CTX_new(comp->method);
			if (s->expand == NULL) {
				SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,
				    SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
			}
			if (s->s3->rrec.comp == NULL)
				s->s3->rrec.comp =
				    malloc(SSL3_RT_MAX_PLAIN_LENGTH);
			if (s->s3->rrec.comp == NULL)
				goto err;
		}
	} else {
		if (s->compress != NULL) {
			COMP_CTX_free(s->compress);
			s->compress = NULL;
		}
		if (comp != NULL) {
			s->compress = COMP_CTX_new(comp->method);
			if (s->compress == NULL) {
				SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,
				    SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
			}
		}
	}
#endif
a329 1
	SSL_COMP *comp;
a333 6
	if (!ssl_cipher_get_comp(s->session, &comp)) {
		SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,
		    SSL_R_CIPHER_COMPRESSION_UNAVAILABLE);
		return (0);
	}

a341 1
	s->s3->tmp.new_compression = comp;
@


1.50
log
@Missinc calloc() return value check; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.49 2014/06/15 15:29:25 jsing Exp $ */
d221 2
a222 4
	unsigned char *key_block, *er1, *er2;
	unsigned char export_key[EVP_MAX_KEY_LENGTH];
	unsigned char export_iv[EVP_MAX_IV_LENGTH];
	int is_export, mac_len, key_len, iv_len;
a225 1
	EVP_MD_CTX mac_ctx;
a231 1
	is_export = SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
a318 4
	if (is_export &&
	    key_len > SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher))
		key_len = SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher);

a336 2
		er1 = s->s3->client_random;
		er2 = s->s3->server_random;
a340 2
		er1 = s->s3->server_random;
		er2 = s->s3->client_random;
a349 21
		
	EVP_MD_CTX_init(&mac_ctx);
	if (is_export) {
		/* In here I set both the read and write key/iv to the
		 * same value since only the correct one will be used :-).
		 */
		EVP_DigestInit_ex(&mac_ctx, EVP_md5(), NULL);
		EVP_DigestUpdate(&mac_ctx, key, key_len);
		EVP_DigestUpdate(&mac_ctx, er1, SSL3_RANDOM_SIZE);
		EVP_DigestUpdate(&mac_ctx, er2, SSL3_RANDOM_SIZE);
		EVP_DigestFinal_ex(&mac_ctx, export_key, NULL);
		key = export_key;

		if (iv_len > 0) {
			EVP_DigestInit_ex(&mac_ctx, EVP_md5(), NULL);
			EVP_DigestUpdate(&mac_ctx, er1, SSL3_RANDOM_SIZE);
			EVP_DigestUpdate(&mac_ctx, er2, SSL3_RANDOM_SIZE);
			EVP_DigestFinal_ex(&mac_ctx, export_iv, NULL);
			iv = export_iv;
		}
	}
a352 6
	if (is_export) {
		OPENSSL_cleanse(export_key, sizeof(export_key));
		OPENSSL_cleanse(export_iv, sizeof(export_iv));
	}

	EVP_MD_CTX_cleanup(&mac_ctx);
a394 4

	if (SSL_C_IS_EXPORT(s->session->cipher) &&
	    key_len > SSL_C_EXPORT_KEYLENGTH(s->session->cipher))
		key_len = SSL_C_EXPORT_KEYLENGTH(s->session->cipher);
@


1.49
log
@Rename ssl3_record_sequence_update() to ssl3_record_sequence_increment(),
so that it reflects what it is actually doing. Use this function in a
number of places that still have the hand rolled version.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.48 2014/06/13 16:08:03 jsing Exp $ */
d611 4
@


1.48
log
@Overhaul the keyblock handling in ssl3_change_cipher_state(). Use
meaningful variable names with use with pointer arithmitic rather than
complex array indexing.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.46 2014/06/13 15:28:49 jsing Exp $ */
d810 2
a811 1
	ssl3_record_sequence_update(seq);
d816 1
a816 1
ssl3_record_sequence_update(unsigned char *seq)
@


1.47
log
@Correctly calculate the key block length when used with export ciphers.
While here, use meaningful variable names and simplify the calculation.
@
text
@d217 5
a221 1
	unsigned char *p, *mac_secret;
d224 2
a225 1
	unsigned char *ms, *key, *iv, *er1, *er2;
a229 2
	int is_export, n, mac_len, key_len, iv_len;
	char is_read;
d249 8
a301 3

		memset(s->s3->read_sequence, 0, SSL3_SEQUENCE_SIZE);
		mac_secret = &(s->s3->read_mac_secret[0]);
a310 3

		memset(s->s3->write_sequence, 0, SSL3_SEQUENCE_SIZE);
		mac_secret = &(s->s3->write_mac_secret[0]);
d313 2
a314 1
	p = s->s3->tmp.key_block;
d326 19
a344 9
	
	if ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
	    (which == SSL3_CHANGE_CIPHER_SERVER_READ)) {
		ms = &(p[0]);
		n = mac_len + mac_len;
		key = &(p[n]);
		n += key_len + key_len;
		iv = &(p[n]);
		n += iv_len + iv_len;
d348 3
a350 7
		n = mac_len;
		ms = &(p[n]);
		n += mac_len + key_len;
		key = &(p[n]);
		n += key_len + iv_len;
		iv = &(p[n]);
		n += iv_len;
d355 1
a355 1
	if (n > s->s3->tmp.key_block_length) {
d360 3
a363 1
	memcpy(mac_secret, ms, mac_len);
d384 1
a384 2
	EVP_CipherInit_ex(cipher_ctx, cipher, NULL, key, iv,
	    (which & SSL3_CC_WRITE));
@


1.46
log
@Use meaningful variable names, rather than i, j, k and cl.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.45 2014/06/13 14:58:05 jsing Exp $ */
d389 4
a392 4
	unsigned char *p;
	const EVP_CIPHER *c;
	const EVP_MD *hash;
	int num;
d405 1
a405 1
	if (!ssl_cipher_get_evp(s->session, &c, &hash, NULL, NULL)) {
d411 2
a412 2
	s->s3->tmp.new_sym_enc = c;
	s->s3->tmp.new_hash = hash;
d415 5
a419 2
	num = EVP_MD_size(hash);
	if (num < 0)
d422 5
a426 2
	num = EVP_CIPHER_key_length(c) + num + EVP_CIPHER_iv_length(c);
	num *= 2;
d430 1
a430 1
	if ((p = malloc(num)) == NULL)
d433 2
a434 2
	s->s3->tmp.key_block_length = num;
	s->s3->tmp.key_block = p;
d436 1
a436 1
	ret = ssl3_generate_key_block(s, p, num);
d439 2
a440 1
		/* enable vulnerability countermeasure for CBC ciphers with
@


1.45
log
@Do not bother trying to work out of we can reuse a cipher context - just
throw it away and create a new one. This simplifies the code and also
allows ASR to do its thing.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.44 2014/06/13 14:38:13 jsing Exp $ */
d225 1
a225 1
	int is_export, n, i, j, k, cl;
d309 6
a314 2
	i = EVP_MD_size(mac);
	if (i < 0)
d316 5
a320 5
	cl = EVP_CIPHER_key_length(cipher);
	j = is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
	    cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
	/* Was j=(is_exp)?5:EVP_CIPHER_key_length(c); */
	k = EVP_CIPHER_iv_length(cipher);
d324 1
a324 1
		n = i + i;
d326 1
a326 1
		n += j + j;
d328 3
a330 3
		n += k + k;
		er1 = &(s->s3->client_random[0]);
		er2 = &(s->s3->server_random[0]);
d332 1
a332 1
		n = i;
d334 1
a334 1
		n += i + j;
d336 1
a336 1
		n += j + k;
d338 3
a340 3
		n += k;
		er1 = &(s->s3->server_random[0]);
		er2 = &(s->s3->client_random[0]);
d349 1
a349 1
	memcpy(mac_secret, ms, i);
d355 1
a355 1
		EVP_DigestUpdate(&mac_ctx, key, j);
d361 1
a361 1
		if (k > 0) {
@


1.44
log
@Separate the comression handling from the cipher/message digest handling in
ssl3_change_cipher_state().
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.43 2014/06/13 14:15:14 jsing Exp $ */
a226 1
	int reuse_dd = 0;
d235 2
a236 1
	/* m == NULL will lead to a crash later */
d283 3
a285 3
		if (s->enc_read_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_read_ctx = malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d287 1
a287 5
		else {
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_read_ctx);
		}
		cipher_ctx = s->enc_read_ctx;
d295 3
a297 3
		if (s->enc_write_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_write_ctx = malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d299 2
a300 5
		else {
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_write_ctx);
		}
		cipher_ctx = s->enc_write_ctx;
a306 3

	if (reuse_dd)
		EVP_CIPHER_CTX_cleanup(cipher_ctx);
@


1.43
log
@The export_key/export_iv variables are only used in the is_export case.
Also use c rather than &c[0].
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.42 2014/06/13 14:11:35 jsing Exp $ */
d225 4
d230 1
a230 1
	COMP_METHOD *comp;
a231 2
	int is_export, n, i, j, k, cl;
	int reuse_dd = 0;
d239 7
d247 33
a279 4
	if (s->s3->tmp.new_compression == NULL)
		comp = NULL;
	else
		comp = s->s3->tmp.new_compression->method;
d282 1
a282 1
	if (which & SSL3_CC_READ) {
a295 18
#ifndef OPENSSL_NO_COMP
		/* COMPRESS */
		if (s->expand != NULL) {
			COMP_CTX_free(s->expand);
			s->expand = NULL;
		}
		if (comp != NULL) {
			s->expand = COMP_CTX_new(comp);
			if (s->expand == NULL) {
				SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE, SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
			}
			if (s->s3->rrec.comp == NULL)
				s->s3->rrec.comp = malloc(SSL3_RT_MAX_PLAIN_LENGTH);
			if (s->s3->rrec.comp == NULL)
				goto err;
		}
#endif
a310 14
#ifndef OPENSSL_NO_COMP
		/* COMPRESS */
		if (s->compress != NULL) {
			COMP_CTX_free(s->compress);
			s->compress = NULL;
		}
		if (comp != NULL) {
			s->compress = COMP_CTX_new(comp);
			if (s->compress == NULL) {
				SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE, SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
			}
		}
#endif
a568 2


@


1.42
log
@Rename a bunch of variables in ssl3_change_cipher_state() for readability.
This also brings it inline with tls1_change_cipher_state_cipher().
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.41 2014/06/13 12:41:01 jsing Exp $ */
d358 2
a359 2
		EVP_DigestFinal_ex(&mac_ctx, &(export_key[0]), NULL);
		key = &(export_key[0]);
d365 2
a366 2
			EVP_DigestFinal_ex(&mac_ctx, &(export_iv[0]), NULL);
			iv = &(export_iv[0]);
d373 5
a377 2
	OPENSSL_cleanse(&(export_key[0]), sizeof(export_key));
	OPENSSL_cleanse(&(export_iv[0]), sizeof(export_iv));
@


1.41
log
@Use SSL3_SEQUENCE_SIZE and if we're going to preincrement we may as well
do it properly.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_enc.c,v 1.40 2014/06/12 15:49:31 deraadt Exp $ */
d218 2
a219 2
	unsigned char exp_key[EVP_MAX_KEY_LENGTH];
	unsigned char exp_iv[EVP_MAX_IV_LENGTH];
d221 4
a224 2
	EVP_CIPHER_CTX *dd;
	const EVP_CIPHER *c;
d228 1
a228 3
	const EVP_MD *m;
	EVP_MD_CTX md;
	int is_exp, n, i, j, k, cl;
d231 3
a233 3
	is_exp = SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
	c = s->s3->tmp.new_sym_enc;
	m = s->s3->tmp.new_hash;
d235 2
a236 1
	OPENSSL_assert(m);
d253 1
a253 1
		dd = s->enc_read_ctx;
d255 1
a255 1
		if (ssl_replace_hash(&s->read_hash, m) == NULL)
d287 2
a288 2
		dd = s->enc_write_ctx;
		if (ssl_replace_hash(&s->write_hash, m) == NULL)
d310 1
a310 1
		EVP_CIPHER_CTX_cleanup(dd);
d313 1
a313 1
	i = EVP_MD_size(m);
d316 2
a317 2
	cl = EVP_CIPHER_key_length(c);
	j = is_exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
d320 1
a320 1
	k = EVP_CIPHER_iv_length(c);
d348 1
a348 1
	EVP_MD_CTX_init(&md);
d350 1
a350 1
	if (is_exp) {
d354 6
a359 6
		EVP_DigestInit_ex(&md, EVP_md5(), NULL);
		EVP_DigestUpdate(&md, key, j);
		EVP_DigestUpdate(&md, er1, SSL3_RANDOM_SIZE);
		EVP_DigestUpdate(&md, er2, SSL3_RANDOM_SIZE);
		EVP_DigestFinal_ex(&md, &(exp_key[0]), NULL);
		key = &(exp_key[0]);
d362 5
a366 5
			EVP_DigestInit_ex(&md, EVP_md5(), NULL);
			EVP_DigestUpdate(&md, er1, SSL3_RANDOM_SIZE);
			EVP_DigestUpdate(&md, er2, SSL3_RANDOM_SIZE);
			EVP_DigestFinal_ex(&md, &(exp_iv[0]), NULL);
			iv = &(exp_iv[0]);
d370 2
a371 1
	EVP_CipherInit_ex(dd, c, NULL, key, iv, (which & SSL3_CC_WRITE));
d373 3
a375 3
	OPENSSL_cleanse(&(exp_key[0]), sizeof(exp_key));
	OPENSSL_cleanse(&(exp_iv[0]), sizeof(exp_iv));
	EVP_MD_CTX_cleanup(&md);
@


1.40
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d796 2
a797 3
	for (i = 7; i >= 0; i--) {
		++seq[i];
		if (seq[i] != 0)
@


1.39
log
@Stop setting the EVP_MD_CTX_FLAG_NON_FIPS_ALLOW - it has been ignored since
OpenSSL 1.0.0.

ok miod@@ (a little while back)
@
text
@d1 1
a1 1
/* ssl/s3_enc.c */
@


1.38
log
@Check return value of EVP_MD_CTX_copy_ex() in ssl3_handshake_mac()
to avoid potential null pointer dereference.

Based on david ramos work.

OK from miod@@ and jsing@@
@
text
@a174 1
	EVP_MD_CTX_set_flags(&m5, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
a668 2
	EVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);

@


1.37
log
@Remove pointless casts and use c instead of &c[0], since it is the same
thing for an unsigned char array.

ok deraadt@@
@
text
@d671 3
a673 1
	EVP_MD_CTX_copy_ex(&ctx, d);
@


1.36
log
@More KNF.
@
text
@d808 1
a808 5
	static const unsigned char *salt[3] = {
		(const unsigned char *)"A",
		(const unsigned char *)"BB",
		(const unsigned char *)"CCC",
	};
d819 2
a820 4
		EVP_DigestUpdate(&ctx, &(s->s3->client_random[0]),
		    SSL3_RANDOM_SIZE);
		EVP_DigestUpdate(&ctx, &(s->s3->server_random[0]),
		    SSL3_RANDOM_SIZE);
@


1.35
log
@Avoid potential NULL pointer function calls in n_ssl3_mac() by checking
the return value of EVP_MD_CTX_copy_ex(). If the copy fails early then
EVP_DigestUpdate() will invoke md_ctx.update(), which will be a NULL
function pointer.

Analysis and patch from David Ramos.

ok deraadt@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d192 1
a192 1
		s->session->master_key_length);
d199 1
a199 1
		s->session->master_key_length);
d203 1
a203 1
			memcpy(km, smd,(num - i));
d370 1
a370 1
	EVP_CipherInit_ex(dd, c, NULL, key, iv,(which & SSL3_CC_WRITE));
d457 1
a457 1
		s->s3->tmp.key_block_length);
d498 1
a498 2
	if ((s->session == NULL) || (ds == NULL) ||
		(enc == NULL)) {
d567 1
a567 1
		BIO_write (s->s3->handshake_buffer,(void *)buf, len);
d680 1
a680 1
	s->session->master_key_length);
d686 1
a686 1
	s->session->master_key_length);
d824 1
a824 1
		SSL3_RANDOM_SIZE);
d826 1
a826 1
		SSL3_RANDOM_SIZE);
@


1.34
log
@Multiple fixes for ssl3_digest_cached_records() - if EVP_MD_CTX_create()
fails, the NULL check will add an error but it does not abort. This will
result in EVP_DigestInit_ex() being called with a NULL context.
Also ensure that we check the return values from EVP_DigestInit_ex() and
EVP_DigestUpdate().

ok deraadt@@ miod@@
@
text
@d765 2
a766 1
		EVP_MD_CTX_copy_ex(&md_ctx, hash);
d778 2
a779 1
		EVP_MD_CTX_copy_ex(&md_ctx, hash);
@


1.33
log
@Ensure ssl3_final_finish_mac() returns failure if either the MD5 or SHA1
handshake MAC calculation fails. Currently, the result from both
ssl3_handshake_mac() calls is added together. This means that unless both
MD5 and SHA1 fail, a positive value will be returned to the caller,
indicating success rather than failure.

ok deraadt@@ miod@@ sthen@@
@
text
@a586 1
	/* Allocate handshake_dgst array */
d588 1
d592 2
a593 1
		SSLerr(SSL_F_SSL3_DIGEST_CACHED_RECORDS, SSL_R_BAD_HANDSHAKE_LENGTH);
d597 1
a597 1
	/* Loop through bitso of algorithm2 field and create MD_CTX-es */
d604 1
d606 6
a611 4
			EVP_DigestInit_ex(s->s3->handshake_dgst[i], md, NULL);
			EVP_DigestUpdate(s->s3->handshake_dgst[i], hdata, hdatalen);
		} else {
			s->s3->handshake_dgst[i] = NULL;
d614 1
a615 1
		/* Free handshake_buffer BIO */
@


1.32
log
@More KNF.
@
text
@d628 10
a637 5
	int ret;
	ret = ssl3_handshake_mac(s, NID_md5, sender, len, p);
	p += ret;
	ret += ssl3_handshake_mac(s, NID_sha1, sender, len, p);
	return (ret);
@


1.31
log
@Add a define for the SSLv3 sequence size and use it, rather than sprinkling
magic numbers around.

ok deraadt@@
@
text
@d181 2
a182 1
			SSLerr(SSL_F_SSL3_GENERATE_KEY_BLOCK, ERR_R_INTERNAL_ERROR);
d649 1
a649 2
	/* Search for digest of specified type in the handshake_dgst
	 * array*/
d651 2
a652 1
		if (s->s3->handshake_dgst[i]&&EVP_MD_CTX_type(s->s3->handshake_dgst[i]) == md_nid) {
d668 1
a668 1
	npad = (48/n)*n;
d716 1
a716 1
	npad = (48/md_size)*md_size;
d756 1
a756 1
		EVP_MD_CTX_copy_ex( &md_ctx, hash);
d766 1
a766 1
		EVP_DigestFinal_ex( &md_ctx, md, NULL);
d768 1
a768 1
		EVP_MD_CTX_copy_ex( &md_ctx, hash);
d772 1
a772 1
		EVP_DigestFinal_ex( &md_ctx, md, &md_size_u);
a790 1

@


1.30
log
@ssl3_free_digest_list() has its own NULL check.
@
text
@d275 1
a275 1
		memset(&(s->s3->read_sequence[0]), 0, 8);
d304 1
a304 1
		memset(&(s->s3->write_sequence[0]), 0, 8);
@


1.29
log
@BIO_free has an implicit NULL check, so do not bother checking for NULL
before calling it.
@
text
@d539 1
a539 2
	if (s->s3->handshake_dgst)
		ssl3_free_digest_list(s);
d549 2
a550 1
	if (!s->s3->handshake_dgst)
@


1.28
log
@Add missing NULL checks for calls to ssl_replace_hash(). This function
calls EVP_MD_CTX_create(), which will return NULL if it fails to allocate
memory.

ok miod@@
@
text
@d538 1
a538 2
	if (s->s3->handshake_buffer)
		BIO_free(s->s3->handshake_buffer);
@


1.27
log
@EVP_MD_CTX_create() calls malloc and can return NULL. However, only one of
the calls in libssl actually checks the return value before using it. Add
NULL checks for the remaining three calls.

ok miod@@
@
text
@d254 3
a256 1
		ssl_replace_hash(&s->read_hash, m);
d287 3
a289 1
		ssl_replace_hash(&s->write_hash, m);
@


1.26
log
@More KNF.
@
text
@d596 4
@


1.25
log
@The ssl_ciper_get_evp() function is currently overloaded to also return the
compression associated with the SSL session. Based on one of Adam Langley's
chromium diffs, factor out the compression handling code into a separate
ssl_cipher_get_comp() function.

Rewrite the compression handling code to avoid pointless duplication and so
that failures are actually returned to and detectable by the caller.

ok miod@@
@
text
@d562 2
a563 1
	if (s->s3->handshake_buffer && !(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) {
@


1.24
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@d390 9
a398 2
	if (!ssl_cipher_get_evp(s->session, &c, &hash, NULL, NULL, &comp)) {
		SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
a403 3
#ifdef OPENSSL_NO_COMP
	s->s3->tmp.new_compression = NULL;
#else
a404 1
#endif
@


1.23
log
@Chop off more SSLv2 tentacles and start fixing and noting y2038 issues.
APIs that pass times as longs will have to change at some point...
Bump major on both libcrypto and libssl.

ok tedu@@
@
text
@d248 1
a248 1
		else
d250 2
a251 1
		EVP_CIPHER_CTX_init(s->enc_read_ctx);
d268 1
a268 2
				s->s3->rrec.comp = (unsigned char *)
			malloc(SSL3_RT_MAX_PLAIN_LENGTH);
d280 1
a280 1
		else
d282 2
a283 1
		EVP_CIPHER_CTX_init(s->enc_write_ctx);
d581 1
a581 2
	s->s3->handshake_dgst = malloc(SSL_MAX_DIGEST * sizeof(EVP_MD_CTX *));
	memset(s->s3->handshake_dgst, 0, SSL_MAX_DIGEST *sizeof(EVP_MD_CTX *));
@


1.22
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a363 2
	s->session->key_arg_length = 0;

@


1.21
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok miod
@
text
@d246 1
a246 1
		else if ((s->enc_read_ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d268 1
a268 1
			OPENSSL_malloc(SSL3_RT_MAX_PLAIN_LENGTH);
d278 1
a278 1
		else if ((s->enc_write_ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d413 1
a413 1
	if ((p = OPENSSL_malloc(num)) == NULL)
d451 1
a451 1
		OPENSSL_free(s->s3->tmp.key_block);
d551 1
a551 1
	OPENSSL_free(s->s3->handshake_dgst);
d582 1
a582 1
	s->s3->handshake_dgst = OPENSSL_malloc(SSL_MAX_DIGEST * sizeof(EVP_MD_CTX *));
@


1.20
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@a593 6
#ifdef OPENSSL_FIPS
			if (EVP_MD_nid(md) == NID_md5) {
				EVP_MD_CTX_set_flags(s->s3->handshake_dgst[i],
				EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
			}
#endif
@


1.19
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a172 3
#ifdef CHARSET_EBCDIC
	c = os_toascii[c]; /*'A' in ASCII */
#endif
a795 1
#ifndef CHARSET_EBCDIC
a798 5
#else
		(const unsigned char *)"\x41",
		(const unsigned char *)"\x42\x42",
		(const unsigned char *)"\x43\x43\x43",
#endif
@


1.18
log
@cherry pick bugfixes for http://www.openssl.org/news/secadv_20130205.txt
from the openssl git (changes between openssl 1.0.1c and 1.0.1d).
ok djm@@
@
text
@d143 24
a166 19
static unsigned char ssl3_pad_1[48]={
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 };

static unsigned char ssl3_pad_2[48]={
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c };
static int ssl3_handshake_mac(SSL *s, int md_nid,
	const char *sender, int len, unsigned char *p);
static int ssl3_generate_key_block(SSL *s, unsigned char *km, int num)
	{
d169 3
a171 3
	unsigned char buf[16],smd[SHA_DIGEST_LENGTH];
	unsigned char c='A';
	unsigned int i,j,k;
d176 1
a176 1
	k=0;
d180 1
a180 2
	for (i=0; (int)i<num; i+=MD5_DIGEST_LENGTH)
		{
d182 1
a182 2
		if (k > sizeof buf)
			{
d186 4
a189 4
			}
		
		for (j=0; j<k; j++)
			buf[j]=c;
d191 17
a207 19
		EVP_DigestInit_ex(&s1,EVP_sha1(), NULL);
		EVP_DigestUpdate(&s1,buf,k);
		EVP_DigestUpdate(&s1,s->session->master_key,
			s->session->master_key_length);
		EVP_DigestUpdate(&s1,s->s3->server_random,SSL3_RANDOM_SIZE);
		EVP_DigestUpdate(&s1,s->s3->client_random,SSL3_RANDOM_SIZE);
		EVP_DigestFinal_ex(&s1,smd,NULL);

		EVP_DigestInit_ex(&m5,EVP_md5(), NULL);
		EVP_DigestUpdate(&m5,s->session->master_key,
			s->session->master_key_length);
		EVP_DigestUpdate(&m5,smd,SHA_DIGEST_LENGTH);
		if ((int)(i+MD5_DIGEST_LENGTH) > num)
			{
			EVP_DigestFinal_ex(&m5,smd,NULL);
			memcpy(km,smd,(num-i));
			}
		else
			EVP_DigestFinal_ex(&m5,km,NULL);
d209 3
a211 3
		km+=MD5_DIGEST_LENGTH;
		}
	OPENSSL_cleanse(smd,SHA_DIGEST_LENGTH);
d215 1
a215 1
	}
d217 4
a220 3
int ssl3_change_cipher_state(SSL *s, int which)
	{
	unsigned char *p,*mac_secret;
d223 1
a223 1
	unsigned char *ms,*key,*iv,*er1,*er2;
d231 1
a231 1
	int is_exp,n,i,j,k,cl;
d234 3
a236 3
	is_exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
	c=s->s3->tmp.new_sym_enc;
	m=s->s3->tmp.new_hash;
d241 1
a241 1
		comp=NULL;
d243 1
a243 1
		comp=s->s3->tmp.new_compression->method;
d246 1
a246 2
	if (which & SSL3_CC_READ)
		{
d249 1
a249 1
		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d253 2
a254 2
			EVP_CIPHER_CTX_init(s->enc_read_ctx);
		dd= s->enc_read_ctx;
d256 1
a256 1
		ssl_replace_hash(&s->read_hash,m);
d259 1
a259 2
		if (s->expand != NULL)
			{
d261 7
a267 1
			s->expand=NULL;
a268 8
		if (comp != NULL)
			{
			s->expand=COMP_CTX_new(comp);
			if (s->expand == NULL)
				{
				SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
d270 2
a271 2
				s->s3->rrec.comp=(unsigned char *)
					OPENSSL_malloc(SSL3_RT_MAX_PLAIN_LENGTH);
d274 1
a274 1
			}
d276 3
a278 5
		memset(&(s->s3->read_sequence[0]),0,8);
		mac_secret= &(s->s3->read_mac_secret[0]);
		}
	else
		{
d281 1
a281 1
		else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d285 3
a287 3
			EVP_CIPHER_CTX_init(s->enc_write_ctx);
		dd= s->enc_write_ctx;
		ssl_replace_hash(&s->write_hash,m);
d290 1
a290 2
		if (s->compress != NULL)
			{
d292 6
a297 8
			s->compress=NULL;
			}
		if (comp != NULL)
			{
			s->compress=COMP_CTX_new(comp);
			if (s->compress == NULL)
				{
				SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
a298 1
				}
d300 1
d302 3
a304 3
		memset(&(s->s3->write_sequence[0]),0,8);
		mac_secret= &(s->s3->write_mac_secret[0]);
		}
d309 2
a310 2
	p=s->s3->tmp.key_block;
	i=EVP_MD_size(m);
d313 3
a315 3
	cl=EVP_CIPHER_key_length(c);
	j=is_exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
		 cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
d317 22
a338 19
	k=EVP_CIPHER_iv_length(c);
	if (	(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
		(which == SSL3_CHANGE_CIPHER_SERVER_READ))
		{
		ms=  &(p[ 0]); n=i+i;
		key= &(p[ n]); n+=j+j;
		iv=  &(p[ n]); n+=k+k;
		er1= &(s->s3->client_random[0]);
		er2= &(s->s3->server_random[0]);
		}
	else
		{
		n=i;
		ms=  &(p[ n]); n+=i+j;
		key= &(p[ n]); n+=j+k;
		iv=  &(p[ n]); n+=k;
		er1= &(s->s3->server_random[0]);
		er2= &(s->s3->client_random[0]);
		}
d340 2
a341 3
	if (n > s->s3->tmp.key_block_length)
		{
		SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
d343 1
a343 1
		}
d346 2
a347 3
	memcpy(mac_secret,ms,i);
	if (is_exp)
		{
d351 13
a363 15
		EVP_DigestInit_ex(&md,EVP_md5(), NULL);
		EVP_DigestUpdate(&md,key,j);
		EVP_DigestUpdate(&md,er1,SSL3_RANDOM_SIZE);
		EVP_DigestUpdate(&md,er2,SSL3_RANDOM_SIZE);
		EVP_DigestFinal_ex(&md,&(exp_key[0]),NULL);
		key= &(exp_key[0]);

		if (k > 0)
			{
			EVP_DigestInit_ex(&md,EVP_md5(), NULL);
			EVP_DigestUpdate(&md,er1,SSL3_RANDOM_SIZE);
			EVP_DigestUpdate(&md,er2,SSL3_RANDOM_SIZE);
			EVP_DigestFinal_ex(&md,&(exp_iv[0]),NULL);
			iv= &(exp_iv[0]);
			}
d365 1
d367 1
a367 1
	s->session->key_arg_length=0;
d369 1
a369 1
	EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));
d371 2
a372 2
	OPENSSL_cleanse(&(exp_key[0]),sizeof(exp_key));
	OPENSSL_cleanse(&(exp_iv[0]),sizeof(exp_iv));
d374 1
a374 1
	return(1);
d376 1
a376 1
	SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);
d378 2
a379 2
	return(0);
	}
d381 3
a383 2
int ssl3_setup_key_block(SSL *s)
	{
d392 1
a392 1
		return(1);
d394 4
a397 5
	if (!ssl_cipher_get_evp(s->session,&c,&hash,NULL,NULL,&comp))
		{
		SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
		return(0);
		}
d399 2
a400 2
	s->s3->tmp.new_sym_enc=c;
	s->s3->tmp.new_hash=hash;
d402 1
a402 1
	s->s3->tmp.new_compression=NULL;
d404 1
a404 1
	s->s3->tmp.new_compression=comp;
d407 1
a407 1
	num=EVP_MD_size(hash);
d411 2
a412 2
	num=EVP_CIPHER_key_length(c)+num+EVP_CIPHER_iv_length(c);
	num*=2;
d416 1
a416 1
	if ((p=OPENSSL_malloc(num)) == NULL)
d419 2
a420 2
	s->s3->tmp.key_block_length=num;
	s->s3->tmp.key_block=p;
d422 1
a422 1
	ret = ssl3_generate_key_block(s,p,num);
d424 1
a424 2
	if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
		{
d430 1
a430 2
		if (s->session->cipher != NULL)
			{
d433 1
a433 1
			
a437 1
			}
d439 1
d442 1
a442 1
		
d444 8
a451 8
	SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);
	return(0);
	}

void ssl3_cleanup_key_block(SSL *s)
	{
	if (s->s3->tmp.key_block != NULL)
		{
d453 1
a453 1
			s->s3->tmp.key_block_length);
d455 1
a455 3
		s->s3->tmp.key_block=NULL;
		}
	s->s3->tmp.key_block_length=0;
d457 2
d469 3
a471 2
int ssl3_enc(SSL *s, int send)
	{
d475 1
a475 1
	int bs,i,mac_size=0;
d478 3
a480 4
	if (send)
		{
		ds=s->enc_write_ctx;
		rec= &(s->s3->wrec);
d482 1
a482 1
			enc=NULL;
d484 4
a487 6
			enc=EVP_CIPHER_CTX_cipher(s->enc_write_ctx);
		}
	else
		{
		ds=s->enc_read_ctx;
		rec= &(s->s3->rrec);
d489 1
a489 1
			enc=NULL;
d491 2
a492 2
			enc=EVP_CIPHER_CTX_cipher(s->enc_read_ctx);
		}
d495 6
a500 9
		(enc == NULL))
		{
		memmove(rec->data,rec->input,rec->length);
		rec->input=rec->data;
		}
	else
		{
		l=rec->length;
		bs=EVP_CIPHER_block_size(ds->cipher);
d504 2
a505 3
		if ((bs != 1) && send)
			{
			i=bs-((int)l%bs);
d508 1
a508 1
			l+=i;
d512 6
a517 7
			rec->length+=i;
			rec->input[l-1]=(i-1);
			}
		
		if (!send)
			{
			if (l == 0 || l%bs != 0)
d520 3
a522 3
			}
		
		EVP_Cipher(ds,rec->data,rec->input,l);
a527 2
		}
	return(1);
d529 2
d532 15
a546 10
void ssl3_init_finished_mac(SSL *s)
	{
	if (s->s3->handshake_buffer) BIO_free(s->s3->handshake_buffer);
	if (s->s3->handshake_dgst) ssl3_free_digest_list(s);
    s->s3->handshake_buffer=BIO_new(BIO_s_mem());	
	(void)BIO_set_close(s->s3->handshake_buffer,BIO_CLOSE);
	}

void ssl3_free_digest_list(SSL *s) 
	{
d548 3
a550 3
	if (!s->s3->handshake_dgst) return;
	for (i=0;i<SSL_MAX_DIGEST;i++) 
		{
d553 1
a553 1
		}
d555 2
a556 2
	s->s3->handshake_dgst=NULL;
	}	
d560 6
a565 8
void ssl3_finish_mac(SSL *s, const unsigned char *buf, int len)
	{
	if (s->s3->handshake_buffer && !(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) 
		{
		BIO_write (s->s3->handshake_buffer,(void *)buf,len);
		} 
	else 
		{
d567 1
a567 2
		for (i=0;i< SSL_MAX_DIGEST;i++) 
			{
d569 2
a570 3
			EVP_DigestUpdate(s->s3->handshake_dgst[i],buf,len);
			}
		}	
d572 1
d574 3
a576 2
int ssl3_digest_cached_records(SSL *s)
	{
d586 3
a588 4
	memset(s->s3->handshake_dgst,0,SSL_MAX_DIGEST *sizeof(EVP_MD_CTX *));
	hdatalen = BIO_get_mem_data(s->s3->handshake_buffer,&hdata);
	if (hdatalen <= 0)
		{
d591 1
a591 1
		}
d594 3
a596 5
	for (i=0;ssl_get_handshake_digest(i,&mask,&md); i++) 
		{
		if ((mask & ssl_get_algorithm2(s)) && md) 
			{
			s->s3->handshake_dgst[i]=EVP_MD_CTX_create();
d598 1
a598 2
			if (EVP_MD_nid(md) == NID_md5)
				{
d600 2
a601 2
						EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
				}
d603 4
a606 7
			EVP_DigestInit_ex(s->s3->handshake_dgst[i],md,NULL);
			EVP_DigestUpdate(s->s3->handshake_dgst[i],hdata,hdatalen);
			} 
		else 
			{	
			s->s3->handshake_dgst[i]=NULL;
			}
d608 2
a609 2
	if (!(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE))
		{
d613 1
a613 1
		}
d616 1
a616 1
	}
d618 9
a626 7
int ssl3_cert_verify_mac(SSL *s, int md_nid, unsigned char *p)
	{
	return(ssl3_handshake_mac(s,md_nid,NULL,0,p));
	}
int ssl3_final_finish_mac(SSL *s, 
	     const char *sender, int len, unsigned char *p)
	{
d628 10
a637 8
	ret=ssl3_handshake_mac(s,NID_md5,sender,len,p);
	p+=ret;
	ret+=ssl3_handshake_mac(s,NID_sha1,sender,len,p);
	return(ret);
	}
static int ssl3_handshake_mac(SSL *s, int md_nid,
	     const char *sender, int len, unsigned char *p)
	{
d639 1
a639 1
	int npad,n;
d642 1
a642 1
	EVP_MD_CTX ctx,*d=NULL;
d644 1
a644 1
	if (s->s3->handshake_buffer) 
d650 3
a652 5
	for (i=0;i<SSL_MAX_DIGEST;i++) 
		{
		  if (s->s3->handshake_dgst[i]&&EVP_MD_CTX_type(s->s3->handshake_dgst[i])==md_nid) 
		  	{
		  	d=s->s3->handshake_dgst[i];
a653 1
			}
d655 1
d657 1
a657 1
		SSLerr(SSL_F_SSL3_HANDSHAKE_MAC,SSL_R_NO_REQUIRED_DIGEST);
d659 1
a659 1
	}	
d662 2
a663 2
	EVP_MD_CTX_copy_ex(&ctx,d);
	n=EVP_MD_CTX_size(&ctx);
d667 1
a667 1
	npad=(48/n)*n;
d669 12
a680 12
		EVP_DigestUpdate(&ctx,sender,len);
	EVP_DigestUpdate(&ctx,s->session->master_key,
		s->session->master_key_length);
	EVP_DigestUpdate(&ctx,ssl3_pad_1,npad);
	EVP_DigestFinal_ex(&ctx,md_buf,&i);

	EVP_DigestInit_ex(&ctx,EVP_MD_CTX_md(&ctx), NULL);
	EVP_DigestUpdate(&ctx,s->session->master_key,
		s->session->master_key_length);
	EVP_DigestUpdate(&ctx,ssl3_pad_2,npad);
	EVP_DigestUpdate(&ctx,md_buf,i);
	EVP_DigestFinal_ex(&ctx,p,&ret);
d684 2
a685 2
	return((int)ret);
	}
d687 3
a689 2
int n_ssl3_mac(SSL *ssl, unsigned char *md, int send)
	{
d691 1
a691 1
	unsigned char *mac_sec,*seq;
d694 1
a694 1
	unsigned char *p,rec_char;
d699 11
a709 14
	if (send)
		{
		rec= &(ssl->s3->wrec);
		mac_sec= &(ssl->s3->write_mac_secret[0]);
		seq= &(ssl->s3->write_sequence[0]);
		hash=ssl->write_hash;
		}
	else
		{
		rec= &(ssl->s3->rrec);
		mac_sec= &(ssl->s3->read_mac_secret[0]);
		seq= &(ssl->s3->read_sequence[0]);
		hash=ssl->read_hash;
		}
d711 1
a711 1
	t=EVP_MD_CTX_size(hash);
d714 2
a715 2
	md_size=t;
	npad=(48/md_size)*md_size;
d718 1
a718 1
	orig_len = rec->length+md_size+((unsigned int)rec->type>>8);
d723 1
a723 2
	    ssl3_cbc_record_digest_supported(hash))
		{
d737 1
a737 1
		memcpy(header+j, mac_sec, md_size);
d739 1
a739 1
		memcpy(header+j, ssl3_pad_1, npad);
d741 1
a741 1
		memcpy(header+j, seq, 8);
d747 4
a750 10
		ssl3_cbc_digest_record(
			hash,
			md, &md_size,
			header, rec->input,
			rec->length + md_size, orig_len,
			mac_sec, md_size,
			1 /* is SSLv3 */);
		}
	else
		{
d755 17
a771 17
		EVP_MD_CTX_copy_ex( &md_ctx,hash);
		EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
		EVP_DigestUpdate(&md_ctx,ssl3_pad_1,npad);
		EVP_DigestUpdate(&md_ctx,seq,8);
		rec_char=rec->type;
		EVP_DigestUpdate(&md_ctx,&rec_char,1);
		p=md;
		s2n(rec->length,p);
		EVP_DigestUpdate(&md_ctx,md,2);
		EVP_DigestUpdate(&md_ctx,rec->input,rec->length);
		EVP_DigestFinal_ex( &md_ctx,md,NULL);

		EVP_MD_CTX_copy_ex( &md_ctx,hash);
		EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
		EVP_DigestUpdate(&md_ctx,ssl3_pad_2,npad);
		EVP_DigestUpdate(&md_ctx,md,md_size);
		EVP_DigestFinal_ex( &md_ctx,md,&md_size_u);
d778 2
a779 2
	return(md_size);
	}
d781 3
a783 2
void ssl3_record_sequence_update(unsigned char *seq)
	{
d786 1
a786 2
	for (i=7; i>=0; i--)
		{
d788 3
a790 2
		if (seq[i] != 0) break; 
		}
d792 1
d794 5
a798 4
int ssl3_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
	     int len)
	{
	static const unsigned char *salt[3]={
d808 1
a808 1
		};
d811 1
a811 1
	int i,ret=0;
d815 17
a831 18
	for (i=0; i<3; i++)
		{
		EVP_DigestInit_ex(&ctx,s->ctx->sha1, NULL);
		EVP_DigestUpdate(&ctx,salt[i],strlen((const char *)salt[i]));
		EVP_DigestUpdate(&ctx,p,len);
		EVP_DigestUpdate(&ctx,&(s->s3->client_random[0]),
			SSL3_RANDOM_SIZE);
		EVP_DigestUpdate(&ctx,&(s->s3->server_random[0]),
			SSL3_RANDOM_SIZE);
		EVP_DigestFinal_ex(&ctx,buf,&n);

		EVP_DigestInit_ex(&ctx,s->ctx->md5, NULL);
		EVP_DigestUpdate(&ctx,p,len);
		EVP_DigestUpdate(&ctx,buf,n);
		EVP_DigestFinal_ex(&ctx,out,&n);
		out+=n;
		ret+=n;
		}
d833 2
a834 2
	return(ret);
	}
d836 50
a885 27
int ssl3_alert_code(int code)
	{
	switch (code)
		{
	case SSL_AD_CLOSE_NOTIFY:	return(SSL3_AD_CLOSE_NOTIFY);
	case SSL_AD_UNEXPECTED_MESSAGE:	return(SSL3_AD_UNEXPECTED_MESSAGE);
	case SSL_AD_BAD_RECORD_MAC:	return(SSL3_AD_BAD_RECORD_MAC);
	case SSL_AD_DECRYPTION_FAILED:	return(SSL3_AD_BAD_RECORD_MAC);
	case SSL_AD_RECORD_OVERFLOW:	return(SSL3_AD_BAD_RECORD_MAC);
	case SSL_AD_DECOMPRESSION_FAILURE:return(SSL3_AD_DECOMPRESSION_FAILURE);
	case SSL_AD_HANDSHAKE_FAILURE:	return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_NO_CERTIFICATE:	return(SSL3_AD_NO_CERTIFICATE);
	case SSL_AD_BAD_CERTIFICATE:	return(SSL3_AD_BAD_CERTIFICATE);
	case SSL_AD_UNSUPPORTED_CERTIFICATE:return(SSL3_AD_UNSUPPORTED_CERTIFICATE);
	case SSL_AD_CERTIFICATE_REVOKED:return(SSL3_AD_CERTIFICATE_REVOKED);
	case SSL_AD_CERTIFICATE_EXPIRED:return(SSL3_AD_CERTIFICATE_EXPIRED);
	case SSL_AD_CERTIFICATE_UNKNOWN:return(SSL3_AD_CERTIFICATE_UNKNOWN);
	case SSL_AD_ILLEGAL_PARAMETER:	return(SSL3_AD_ILLEGAL_PARAMETER);
	case SSL_AD_UNKNOWN_CA:		return(SSL3_AD_BAD_CERTIFICATE);
	case SSL_AD_ACCESS_DENIED:	return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_DECODE_ERROR:	return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_DECRYPT_ERROR:	return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_EXPORT_RESTRICTION:	return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_PROTOCOL_VERSION:	return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_INSUFFICIENT_SECURITY:return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_INTERNAL_ERROR:	return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_USER_CANCELLED:	return(SSL3_AD_HANDSHAKE_FAILURE);
d887 14
a900 8
	case SSL_AD_UNSUPPORTED_EXTENSION: return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_CERTIFICATE_UNOBTAINABLE: return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_UNRECOGNIZED_NAME:	return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE: return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_BAD_CERTIFICATE_HASH_VALUE: return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_UNKNOWN_PSK_IDENTITY:return(TLS1_AD_UNKNOWN_PSK_IDENTITY);
	default:			return(-1);
		}
d902 1
a902 1

@


1.18.4.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d645 1
a645 1
	int ret, sha1len;
a646 3
	if(ret == 0)
		return 0;

d648 1
a648 6

	sha1len=ssl3_handshake_mac(s,NID_sha1,sender,len,p);
	if(sha1len == 0)
		return 0;

	ret+=sha1len;
@


1.18.8.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d645 1
a645 1
	int ret, sha1len;
a646 3
	if(ret == 0)
		return 0;

d648 1
a648 6

	sha1len=ssl3_handshake_mac(s,NID_sha1,sender,len,p);
	if(sha1len == 0)
		return 0;

	ret+=sha1len;
@


1.17
log
@resolve conflicts
@
text
@d469 9
d483 1
a483 1
	int bs,i;
a533 3
				{
				SSLerr(SSL_F_SSL3_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);
a534 1
				}
d540 2
d543 1
a543 15
			{
			i=rec->data[l-1]+1;
			/* SSL 3.0 bounds the number of padding bytes by the block size;
			 * padding bytes (except the last one) are arbitrary */
			if (i > bs)
				{
				/* Incorrect padding. SSLerr() and ssl3_alert are done
				 * by caller: we don't want to reveal whether this is
				 * a decryption error or a MAC verification failure
				 * (see http://www.openssl.org/~bodo/tls-cbc.txt) */
				return -1;
				}
			/* now i <= bs <= rec->length */
			rec->length-=i;
			}
d712 1
a712 1
	unsigned int md_size;
d737 63
a799 2
	/* Chop the digest off the end :-) */
	EVP_MD_CTX_init(&md_ctx);
d801 2
a802 19
	EVP_MD_CTX_copy_ex( &md_ctx,hash);
	EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
	EVP_DigestUpdate(&md_ctx,ssl3_pad_1,npad);
	EVP_DigestUpdate(&md_ctx,seq,8);
	rec_char=rec->type;
	EVP_DigestUpdate(&md_ctx,&rec_char,1);
	p=md;
	s2n(rec->length,p);
	EVP_DigestUpdate(&md_ctx,md,2);
	EVP_DigestUpdate(&md_ctx,rec->input,rec->length);
	EVP_DigestFinal_ex( &md_ctx,md,NULL);

	EVP_MD_CTX_copy_ex( &md_ctx,hash);
	EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
	EVP_DigestUpdate(&md_ctx,ssl3_pad_2,npad);
	EVP_DigestUpdate(&md_ctx,md,md_size);
	EVP_DigestFinal_ex( &md_ctx,md,&md_size);

	EVP_MD_CTX_cleanup(&md_ctx);
@


1.16
log
@OpenSSL 1.0.0f: merge
@
text
@d173 1
d575 1
a575 1
		
d580 1
a580 1
	if (s->s3->handshake_buffer) 
d617 1
a617 1
		if ((mask & s->s3->tmp.new_cipher->algorithm2) && md) 
d620 7
d635 6
a640 3
	/* Free handshake_buffer BIO */
	BIO_free(s->s3->handshake_buffer);
	s->s3->handshake_buffer = NULL;
d686 1
@


1.15
log
@openssl-1.0.0e: resolve conflicts
@
text
@d514 3
@


1.14
log
@resolve conflicts, fix local changes
@
text
@d217 1
a217 1
	unsigned char *p,*key_block,*mac_secret;
a241 1
	key_block=s->s3->tmp.key_block;
@


1.13
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
d111 26
d158 1
a158 2

static int ssl3_handshake_mac(SSL *s, EVP_MD_CTX *in_ctx,
a159 1

a172 1
	EVP_MD_CTX_set_flags(&m5, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d234 2
d254 2
a255 1
		s->read_hash=m;
d291 1
a291 1
		s->write_hash=m;
d318 2
d400 1
a400 1
	if (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))
d414 5
a418 1
	num=EVP_CIPHER_key_length(c)+EVP_MD_size(hash)+EVP_CIPHER_iv_length(c);
d440 1
a440 1
			if ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_eNULL)
d444 1
a444 1
			if ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_RC4)
d554 4
a557 4
	EVP_MD_CTX_set_flags(&(s->s3->finish_dgst1),
		EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
	EVP_DigestInit_ex(&(s->s3->finish_dgst1),s->ctx->md5, NULL);
	EVP_DigestInit_ex(&(s->s3->finish_dgst2),s->ctx->sha1, NULL);
d560 15
d577 13
a589 2
	EVP_DigestUpdate(&(s->s3->finish_dgst1),buf,len);
	EVP_DigestUpdate(&(s->s3->finish_dgst2),buf,len);
d592 1
a592 1
int ssl3_cert_verify_mac(SSL *s, EVP_MD_CTX *ctx, unsigned char *p)
d594 36
a629 1
	return(ssl3_handshake_mac(s,ctx,NULL,0,p));
d632 5
a636 1
int ssl3_final_finish_mac(SSL *s, EVP_MD_CTX *ctx1, EVP_MD_CTX *ctx2,
d640 1
a640 2

	ret=ssl3_handshake_mac(s,ctx1,sender,len,p);
d642 1
a642 1
	ret+=ssl3_handshake_mac(s,ctx2,sender,len,p);
d645 1
a645 2

static int ssl3_handshake_mac(SSL *s, EVP_MD_CTX *in_ctx,
d652 5
a656 1
	EVP_MD_CTX ctx;
d658 14
d673 4
a676 2
	EVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
	EVP_MD_CTX_copy_ex(&ctx,in_ctx);
a677 1
	n=EVP_MD_CTX_size(&ctx);
a678 1

d698 1
a698 1
int ssl3_mac(SSL *ssl, unsigned char *md, int send)
d703 1
a703 1
	const EVP_MD *hash;
d707 1
d724 4
a727 1
	md_size=EVP_MD_size(hash);
d733 1
a733 1
	EVP_DigestInit_ex(  &md_ctx,hash, NULL);
d745 1
a745 1
	EVP_DigestInit_ex(  &md_ctx,hash, NULL);
d838 6
@


1.12
log
@resolve conflicts
@
text
@d149 1
d522 2
d560 1
@


1.11
log
@resolve conflicts
@
text
@d142 1
a142 1
	int i,j,k;
a148 1
	EVP_MD_CTX_set_flags(&m5, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d150 1
a150 1
	for (i=0; i<num; i+=MD5_DIGEST_LENGTH)
d175 1
a175 1
		if ((i+MD5_DIGEST_LENGTH) > num)
d199 1
d201 1
d210 1
d215 1
d224 3
d229 1
d250 1
d260 3
d265 1
d281 1
a287 1
	EVP_CIPHER_CTX_init(dd);
d293 1
a293 1
		    cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
d379 3
d383 1
a520 2
	EVP_MD_CTX_set_flags(&(s->s3->finish_dgst1),
		EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d589 1
a589 1
	int npad,i;
d632 8
a644 2

	return(md_size);
a666 1
	EVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
@


1.10
log
@merge 0.9.7d
@
text
@d149 1
d505 2
d647 1
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d202 1
a202 1
	int exp,n,i,j,k,cl;
d205 1
a205 1
	exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
d279 3
a281 3
	j=exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
		 cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
	/* Was j=(exp)?5:EVP_CIPHER_key_length(c); */
d310 1
a310 1
	if (exp)
@


1.8
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d185 1
a185 1
	memset(smd,0,SHA_DIGEST_LENGTH);
d195 1
a195 1
	unsigned char exp_iv[EVP_MAX_KEY_LENGTH];
d336 2
a337 2
	memset(&(exp_key[0]),0,sizeof(exp_key));
	memset(&(exp_iv[0]),0,sizeof(exp_iv));
d411 1
a411 1
		memset(s->s3->tmp.key_block,0,
d477 1
d486 1
a486 1
			 * padding bytes (except that last) are arbitrary */
d495 1
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d113 1
a114 1
#include "ssl_locl.h"
d381 12
a392 3
	/* enable vulnerability countermeasure for CBC ciphers with
	 * known-IV problem (http://www.openssl.org/~bodo/tls-cbc.txt) */
	s->s3->need_empty_fragments = 1;
d394 2
a395 2
	if ((s->session->cipher != NULL) && ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_RC4))
		s->s3->need_empty_fragments = 0;
d397 2
@


1.6
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d58 53
a112 2
#include <openssl/md5.h>
#include <openssl/sha.h>
d115 1
d136 1
a136 1
static void ssl3_generate_key_block(SSL *s, unsigned char *km, int num)
d138 3
a140 3
	MD5_CTX m5;
	SHA_CTX s1;
	unsigned char buf[8],smd[SHA_DIGEST_LENGTH];
d148 2
d153 7
d163 3
a165 3
		SHA1_Init(  &s1);
		SHA1_Update(&s1,buf,k);
		SHA1_Update(&s1,s->session->master_key,
d167 3
a169 3
		SHA1_Update(&s1,s->s3->server_random,SSL3_RANDOM_SIZE);
		SHA1_Update(&s1,s->s3->client_random,SSL3_RANDOM_SIZE);
		SHA1_Final( smd,&s1);
d171 2
a172 2
		MD5_Init(  &m5);
		MD5_Update(&m5,s->session->master_key,
d174 1
a174 1
		MD5_Update(&m5,smd,SHA_DIGEST_LENGTH);
d177 1
a177 1
			MD5_Final(smd,&m5);
d181 1
a181 1
			MD5_Final(km,&m5);
d186 3
d201 1
a201 1
	MD5_CTX md;
d203 1
d216 3
a218 3
		if ((s->enc_read_ctx == NULL) &&
			((s->enc_read_ctx=(EVP_CIPHER_CTX *)
			OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL))
d247 3
a249 3
		if ((s->enc_write_ctx == NULL) &&
			((s->enc_write_ctx=(EVP_CIPHER_CTX *)
			OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL))
d272 2
d304 1
a304 1
		SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_INTERNAL_ERROR);
d308 1
d315 5
a319 5
		MD5_Init(&md);
		MD5_Update(&md,key,j);
		MD5_Update(&md,er1,SSL3_RANDOM_SIZE);
		MD5_Update(&md,er2,SSL3_RANDOM_SIZE);
		MD5_Final(&(exp_key[0]),&md);
d324 4
a327 4
			MD5_Init(&md);
			MD5_Update(&md,er1,SSL3_RANDOM_SIZE);
			MD5_Update(&md,er2,SSL3_RANDOM_SIZE);
			MD5_Final(&(exp_iv[0]),&md);
d334 1
a334 1
	EVP_CipherInit(dd,c,key,iv,(which & SSL3_CC_WRITE));
d338 1
d352 1
d379 1
a379 1
	ssl3_generate_key_block(s,p,num);
d381 10
a390 1
	return(1);
d463 2
a464 2
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPT_ERROR);
				return(0);
d477 5
a481 3
				SSLerr(SSL_F_SSL3_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPT_ERROR);
				return(0);
d491 2
a492 2
	EVP_DigestInit(&(s->s3->finish_dgst1),s->ctx->md5);
	EVP_DigestInit(&(s->s3->finish_dgst2),s->ctx->sha1);
d526 2
a527 1
	EVP_MD_CTX_copy(&ctx,in_ctx);
d537 1
a537 1
	EVP_DigestFinal(&ctx,md_buf,&i);
d539 1
a539 1
	EVP_DigestInit(&ctx,EVP_MD_CTX_md(&ctx));
d544 1
a544 1
	EVP_DigestFinal(&ctx,p,&ret);
d546 1
a546 1
	memset(&ctx,0,sizeof(EVP_MD_CTX));
d580 1
d582 1
a582 1
	EVP_DigestInit(  &md_ctx,hash);
d592 1
a592 1
	EVP_DigestFinal( &md_ctx,md,NULL);
d594 1
a594 1
	EVP_DigestInit(  &md_ctx,hash);
d598 3
a600 1
	EVP_DigestFinal( &md_ctx,md,&md_size);
d630 1
d633 1
a633 1
		EVP_DigestInit(&ctx,s->ctx->sha1);
d640 1
a640 1
		EVP_DigestFinal(&ctx,buf,&n);
d642 1
a642 1
		EVP_DigestInit(&ctx,s->ctx->md5);
d645 1
a645 1
		EVP_DigestFinal(&ctx,out,&n);
d649 1
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d359 1
a359 1
		memcpy(rec->data,rec->input,rec->length);
a368 1
		/* This should be using (bs-1) and bs instead of 7 and 8 */
d378 11
a388 1

d394 2
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d507 4
a510 1
		if (++seq[i]) break; 
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d153 1
a153 1
			Malloc(sizeof(EVP_CIPHER_CTX))) == NULL))
d173 1
a173 1
					Malloc(SSL3_RT_MAX_PLAIN_LENGTH);
d184 1
a184 1
			Malloc(sizeof(EVP_CIPHER_CTX))) == NULL))
d303 1
a303 1
	if ((p=Malloc(num)) == NULL)
d323 1
a323 1
		Free(s->s3->tmp.key_block);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@a80 1
#ifndef NO_PROTO
d82 1
a82 4
	unsigned char *sender, int len, unsigned char *p);
#else
static int ssl3_handshake_mac();
#endif
d303 1
a303 1
	if ((p=(unsigned char *)Malloc(num)) == NULL)
d415 1
a415 1
	     unsigned char *sender, int len, unsigned char *p)
d426 1
a426 1
	     unsigned char *sender, int len, unsigned char *p)
d446 1
a446 1
	EVP_DigestInit(&ctx,EVP_MD_CTX_type(&ctx));
d574 1
a574 1
	case SSL_AD_EXPORT_RESTRICION:	return(SSL3_AD_HANDSHAKE_FAILURE);
d578 1
a578 1
	case SSL_AD_USER_CANCLED:	return(SSL3_AD_HANDSHAKE_FAILURE);
@


1.1
log
@Initial revision
@
text
@d60 3
a62 1
#include "evp.h"
d88 1
a88 4
static void ssl3_generate_key_block(s,km,num)
SSL *s;
unsigned char *km;
int num;
d96 3
d131 1
a131 3
int ssl3_change_cipher_state(s,which)
SSL *s;
int which;
d138 3
a140 3
	EVP_CIPHER *c;
	SSL_COMPRESSION *comp;
	EVP_MD *m;
d142 1
a142 1
	int exp,n,i,j,k;
d144 1
a144 1
	exp=(s->s3->tmp.new_cipher->algorithms & SSL_EXPORT)?1:0;
d147 4
a150 1
	comp=s->s3->tmp.new_compression;
d161 20
a180 1
		s->read_compression=comp;
d192 15
a206 1
		s->write_compression=comp;
d215 4
a218 1
	j=(exp)?5:EVP_CIPHER_key_length(c);
d281 1
a281 2
int ssl3_setup_key_block(s)
SSL *s;
d284 4
a287 3
	EVP_CIPHER *c;
	EVP_MD *hash;
	int num,exp;
d292 1
a292 1
	if (!ssl_cipher_get_evp(s->session->cipher,&c,&hash))
d300 1
a300 2

	exp=(s->session->cipher->algorithms & SSL_EXPORT)?1:0;
d321 1
a321 2
void ssl3_cleanup_key_block(s)
SSL *s;
d333 1
a333 3
int ssl3_enc(s,send)
SSL *s;
int send;
d339 1
a339 2
	EVP_CIPHER *enc;
	SSL_COMPRESSION *comp;
d346 1
a346 1
			{ enc=NULL; comp=NULL; }
a347 1
			{
a348 2
			comp=s->write_compression;
			}
d355 1
a355 1
			{ enc=NULL; comp=NULL; }
a356 1
			{
a357 2
			comp=s->read_compression;
			}
d361 1
a361 1
		((enc == NULL) && (comp == NULL)))
d371 2
d401 1
a401 2
void ssl3_init_finished_mac(s)
SSL *s;
d407 1
a407 4
void ssl3_finish_mac(s,buf,len)
SSL *s;
unsigned char *buf;
int len;
d413 1
a413 4
int ssl3_cert_verify_mac(s,ctx,p)
SSL *s;
EVP_MD_CTX *ctx;
unsigned char *p;
d418 2
a419 6
int ssl3_final_finish_mac(s,ctx1,ctx2,sender,len,p)
SSL *s;
EVP_MD_CTX *ctx1,*ctx2;
unsigned char *sender;
int len;
unsigned char *p;
d429 2
a430 6
static int ssl3_handshake_mac(s,in_ctx,sender,len,p)
SSL *s;
EVP_MD_CTX *in_ctx;
unsigned char *sender;
int len;
unsigned char *p;
d438 1
a438 1
	memcpy(&ctx,in_ctx,sizeof(EVP_MD_CTX));
d462 1
a462 4
int ssl3_mac(ssl,md,send)
SSL *ssl;
unsigned char *md;
int send;
d467 1
a467 1
	EVP_MD *hash;
d516 13
a528 10
int ssl3_generate_master_secret(s,out,p,len)
SSL *s;
unsigned char *out;
unsigned char *p;
int len;
	{
	static unsigned char *salt[3]={
		(unsigned char *)"A",
		(unsigned char *)"BB",
		(unsigned char *)"CCC",
d538 1
a538 1
		EVP_DigestUpdate(&ctx,salt[i],strlen((char *)salt[i]));
d556 1
a556 2
int ssl3_alert_code(code)
int code;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d60 1
a60 1
#include <openssl/evp.h>
a61 1
#include <openssl/md5.h>
d79 1
d81 4
a84 1
	const char *sender, int len, unsigned char *p);
d86 8
a93 5
static int ssl3_generate_key_block(SSL *s, unsigned char *km, int num)
	{
	EVP_MD_CTX m5;
	EVP_MD_CTX s1;
	unsigned char buf[16],smd[SHA_DIGEST_LENGTH];
a96 3
#ifdef CHARSET_EBCDIC
	c = os_toascii[c]; /*'A' in ASCII */
#endif
a97 2
	EVP_MD_CTX_init(&m5);
	EVP_MD_CTX_init(&s1);
a100 7
		if (k > sizeof buf)
			{
			/* bug: 'buf' is too small for this ciphersuite */
			SSLerr(SSL_F_SSL3_GENERATE_KEY_BLOCK, ERR_R_INTERNAL_ERROR);
			return 0;
			}
		
d104 3
a106 3
		EVP_DigestInit_ex(&s1,EVP_sha1(), NULL);
		EVP_DigestUpdate(&s1,buf,k);
		EVP_DigestUpdate(&s1,s->session->master_key,
d108 3
a110 3
		EVP_DigestUpdate(&s1,s->s3->server_random,SSL3_RANDOM_SIZE);
		EVP_DigestUpdate(&s1,s->s3->client_random,SSL3_RANDOM_SIZE);
		EVP_DigestFinal_ex(&s1,smd,NULL);
d112 2
a113 2
		EVP_DigestInit_ex(&m5,EVP_md5(), NULL);
		EVP_DigestUpdate(&m5,s->session->master_key,
d115 1
a115 1
		EVP_DigestUpdate(&m5,smd,SHA_DIGEST_LENGTH);
d118 1
a118 1
			EVP_DigestFinal_ex(&m5,smd,NULL);
d122 1
a122 1
			EVP_DigestFinal_ex(&m5,km,NULL);
a126 3
	EVP_MD_CTX_cleanup(&m5);
	EVP_MD_CTX_cleanup(&s1);
	return 1;
d129 3
a131 1
int ssl3_change_cipher_state(SSL *s, int which)
d138 5
a142 6
	const EVP_CIPHER *c;
	COMP_METHOD *comp;
	const EVP_MD *m;
	EVP_MD_CTX md;
	int exp,n,i,j,k,cl;
	int reuse_dd = 0;
d144 1
a144 1
	exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
d147 1
a147 4
	if (s->s3->tmp.new_compression == NULL)
		comp=NULL;
	else
		comp=s->s3->tmp.new_compression->method;
d152 3
a154 3
		if (s->enc_read_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d158 1
a158 20
		/* COMPRESS */
		if (s->expand != NULL)
			{
			COMP_CTX_free(s->expand);
			s->expand=NULL;
			}
		if (comp != NULL)
			{
			s->expand=COMP_CTX_new(comp);
			if (s->expand == NULL)
				{
				SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			if (s->s3->rrec.comp == NULL)
				s->s3->rrec.comp=(unsigned char *)
					OPENSSL_malloc(SSL3_RT_MAX_PLAIN_LENGTH);
			if (s->s3->rrec.comp == NULL)
				goto err;
			}
d164 3
a166 3
		if (s->enc_write_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
d170 1
a170 15
		/* COMPRESS */
		if (s->compress != NULL)
			{
			COMP_CTX_free(s->compress);
			s->compress=NULL;
			}
		if (comp != NULL)
			{
			s->compress=COMP_CTX_new(comp);
			if (s->compress == NULL)
				{
				SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			}
a174 2
	if (reuse_dd)
		EVP_CIPHER_CTX_cleanup(dd);
d179 1
a179 4
	cl=EVP_CIPHER_key_length(c);
	j=exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
		 cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
	/* Was j=(exp)?5:EVP_CIPHER_key_length(c); */
d202 1
a202 1
		SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
a205 1
	EVP_MD_CTX_init(&md);
d212 5
a216 5
		EVP_DigestInit_ex(&md,EVP_md5(), NULL);
		EVP_DigestUpdate(&md,key,j);
		EVP_DigestUpdate(&md,er1,SSL3_RANDOM_SIZE);
		EVP_DigestUpdate(&md,er2,SSL3_RANDOM_SIZE);
		EVP_DigestFinal_ex(&md,&(exp_key[0]),NULL);
d221 4
a224 4
			EVP_DigestInit_ex(&md,EVP_md5(), NULL);
			EVP_DigestUpdate(&md,er1,SSL3_RANDOM_SIZE);
			EVP_DigestUpdate(&md,er2,SSL3_RANDOM_SIZE);
			EVP_DigestFinal_ex(&md,&(exp_iv[0]),NULL);
d231 1
a231 1
	EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));
a234 1
	EVP_MD_CTX_cleanup(&md);
d242 2
a243 1
int ssl3_setup_key_block(SSL *s)
d246 3
a248 5
	const EVP_CIPHER *c;
	const EVP_MD *hash;
	int num;
	int ret = 0;
	SSL_COMP *comp;
d253 1
a253 1
	if (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))
d261 2
a262 1
	s->s3->tmp.new_compression=comp;
d269 1
a269 1
	if ((p=OPENSSL_malloc(num)) == NULL)
d275 1
a275 1
	ret = ssl3_generate_key_block(s,p,num);
d277 1
a277 10
	/* enable vulnerability countermeasure for CBC ciphers with
	 * known-IV problem (http://www.openssl.org/~bodo/tls-cbc.txt) */
	s->s3->need_empty_fragments = 1;
#ifndef OPENSSL_NO_RC4
	if ((s->session->cipher != NULL) && ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_RC4))
		s->s3->need_empty_fragments = 0;
#endif

	return ret;
		
d283 2
a284 1
void ssl3_cleanup_key_block(SSL *s)
d290 1
a290 1
		OPENSSL_free(s->s3->tmp.key_block);
d296 3
a298 1
int ssl3_enc(SSL *s, int send)
d304 2
a305 1
	const EVP_CIPHER *enc;
d312 1
a312 1
			enc=NULL;
d314 1
d316 2
d324 1
a324 1
			enc=NULL;
d326 1
d328 2
d333 1
a333 1
		(enc == NULL))
d335 1
a335 1
		memmove(rec->data,rec->input,rec->length);
d343 1
a343 2
		/* COMPRESS */

d353 1
a353 11
		
		if (!send)
			{
			if (l == 0 || l%bs != 0)
				{
				SSLerr(SSL_F_SSL3_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);
				return 0;
				}
			}
		
a358 2
			/* SSL 3.0 bounds the number of padding bytes by the block size;
			 * padding bytes (except that last) are arbitrary */
d361 3
a363 5
				/* Incorrect padding. SSLerr() and ssl3_alert are done
				 * by caller: we don't want to reveal whether this is
				 * a decryption error or a MAC verification failure
				 * (see http://www.openssl.org/~bodo/tls-cbc.txt) */
				return -1;
d371 2
a372 1
void ssl3_init_finished_mac(SSL *s)
d374 2
a375 2
	EVP_DigestInit_ex(&(s->s3->finish_dgst1),s->ctx->md5, NULL);
	EVP_DigestInit_ex(&(s->s3->finish_dgst2),s->ctx->sha1, NULL);
d378 4
a381 1
void ssl3_finish_mac(SSL *s, const unsigned char *buf, int len)
d387 4
a390 1
int ssl3_cert_verify_mac(SSL *s, EVP_MD_CTX *ctx, unsigned char *p)
d395 6
a400 2
int ssl3_final_finish_mac(SSL *s, EVP_MD_CTX *ctx1, EVP_MD_CTX *ctx2,
	     const char *sender, int len, unsigned char *p)
d410 6
a415 2
static int ssl3_handshake_mac(SSL *s, EVP_MD_CTX *in_ctx,
	     const char *sender, int len, unsigned char *p)
d423 1
a423 2
	EVP_MD_CTX_init(&ctx);
	EVP_MD_CTX_copy_ex(&ctx,in_ctx);
d433 1
a433 1
	EVP_DigestFinal_ex(&ctx,md_buf,&i);
d435 1
a435 1
	EVP_DigestInit_ex(&ctx,EVP_MD_CTX_md(&ctx), NULL);
d440 1
a440 1
	EVP_DigestFinal_ex(&ctx,p,&ret);
d442 1
a442 1
	EVP_MD_CTX_cleanup(&ctx);
d447 4
a450 1
int ssl3_mac(SSL *ssl, unsigned char *md, int send)
d455 1
a455 1
	const EVP_MD *hash;
a478 1
	EVP_MD_CTX_init(&md_ctx);
d480 1
a480 1
	EVP_DigestInit_ex(  &md_ctx,hash, NULL);
d490 1
a490 1
	EVP_DigestFinal_ex( &md_ctx,md,NULL);
d492 1
a492 1
	EVP_DigestInit_ex(  &md_ctx,hash, NULL);
d496 1
a496 3
	EVP_DigestFinal_ex( &md_ctx,md,&md_size);

	EVP_MD_CTX_cleanup(&md_ctx);
d499 1
a499 4
		{
		++seq[i];
		if (seq[i] != 0) break; 
		}
d504 10
a513 13
int ssl3_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
	     int len)
	{
	static const unsigned char *salt[3]={
#ifndef CHARSET_EBCDIC
		(const unsigned char *)"A",
		(const unsigned char *)"BB",
		(const unsigned char *)"CCC",
#else
		(const unsigned char *)"\x41",
		(const unsigned char *)"\x42\x42",
		(const unsigned char *)"\x43\x43\x43",
#endif
a519 1
	EVP_MD_CTX_init(&ctx);
d522 2
a523 2
		EVP_DigestInit_ex(&ctx,s->ctx->sha1, NULL);
		EVP_DigestUpdate(&ctx,salt[i],strlen((const char *)salt[i]));
d529 1
a529 1
		EVP_DigestFinal_ex(&ctx,buf,&n);
d531 1
a531 1
		EVP_DigestInit_ex(&ctx,s->ctx->md5, NULL);
d534 1
a534 1
		EVP_DigestFinal_ex(&ctx,out,&n);
a537 1
	EVP_MD_CTX_cleanup(&ctx);
d541 2
a542 1
int ssl3_alert_code(int code)
d564 1
a564 1
	case SSL_AD_EXPORT_RESTRICTION:	return(SSL3_AD_HANDSHAKE_FAILURE);
d568 1
a568 1
	case SSL_AD_USER_CANCELLED:	return(SSL3_AD_HANDSHAKE_FAILURE);
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d113 1
a114 1
#include <openssl/evp.h>
d381 3
a383 12
	if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
		{
		/* enable vulnerability countermeasure for CBC ciphers with
		 * known-IV problem (http://www.openssl.org/~bodo/tls-cbc.txt)
		 */
		s->s3->need_empty_fragments = 1;

		if (s->session->cipher != NULL)
			{
			if ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_eNULL)
				s->s3->need_empty_fragments = 0;
			
d385 2
a386 2
			if ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_RC4)
				s->s3->need_empty_fragments = 0;
a387 2
			}
		}
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d185 1
a185 1
	OPENSSL_cleanse(smd,SHA_DIGEST_LENGTH);
d195 1
a195 1
	unsigned char exp_iv[EVP_MAX_IV_LENGTH];
d336 2
a337 2
	OPENSSL_cleanse(&(exp_key[0]),sizeof(exp_key));
	OPENSSL_cleanse(&(exp_iv[0]),sizeof(exp_iv));
d411 1
a411 1
		OPENSSL_cleanse(s->s3->tmp.key_block,
a476 1
			/* otherwise, rec->length >= bs */
d485 1
a485 1
			 * padding bytes (except the last one) are arbitrary */
a493 1
			/* now i <= bs <= rec->length */
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@d202 1
a202 1
	int is_exp,n,i,j,k,cl;
d205 1
a205 1
	is_exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
d279 3
a281 3
	j=is_exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
		    cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
	/* Was j=(is_exp)?5:EVP_CIPHER_key_length(c); */
d310 1
a310 1
	if (is_exp)
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a148 1
	EVP_MD_CTX_set_flags(&m5, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
a503 2
	EVP_MD_CTX_set_flags(&(s->s3->finish_dgst1),
		EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
a643 1
	EVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d142 1
a142 1
	unsigned int i,j,k;
d149 1
d151 1
a151 1
	for (i=0; (int)i<num; i+=MD5_DIGEST_LENGTH)
d176 1
a176 1
		if ((int)(i+MD5_DIGEST_LENGTH) > num)
a199 1
#ifndef OPENSSL_NO_COMP
a200 1
#endif
a208 1
#ifndef OPENSSL_NO_COMP
a212 1
#endif
a220 3
		else
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_read_ctx);
a222 1
#ifndef OPENSSL_NO_COMP
a242 1
#endif
a251 3
		else
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_write_ctx);
a253 1
#ifndef OPENSSL_NO_COMP
a268 1
#endif
d275 1
d281 1
a281 1
		 cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
a366 3
#ifdef OPENSSL_NO_COMP
	s->s3->tmp.new_compression=NULL;
#else
a367 1
#endif
d505 2
d575 1
a575 1
	int npad;
a617 8
	ssl3_record_sequence_update(seq);
	return(md_size);
	}

void ssl3_record_sequence_update(unsigned char *seq)
	{
	int i;

d623 2
d647 1
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a148 1
	EVP_MD_CTX_set_flags(&m5, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
a520 2
	EVP_MD_CTX_set_flags(&(s->s3->finish_dgst1),
		EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
a556 1
	EVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
a110 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
d132 2
a133 1
static int ssl3_handshake_mac(SSL *s, int md_nid,
d135 1
d149 1
a210 2
	/* m == NULL will lead to a crash later */
	OPENSSL_assert(m);
d229 1
a229 2

		ssl_replace_hash(&s->read_hash,m);
d265 1
a265 1
		ssl_replace_hash(&s->write_hash,m);
a291 2
	if (i < 0)
		goto err2;
d372 1
a372 1
	if (!ssl_cipher_get_evp(s->session,&c,&hash,NULL,NULL,&comp))
d386 1
a386 5
	num=EVP_MD_size(hash);
	if (num < 0)
		return 0;

	num=EVP_CIPHER_key_length(c)+num+EVP_CIPHER_iv_length(c);
d408 1
a408 1
			if (s->session->cipher->algorithm_enc == SSL_eNULL)
d412 1
a412 1
			if (s->session->cipher->algorithm_enc == SSL_RC4)
d522 4
a525 4
	if (s->s3->handshake_buffer) BIO_free(s->s3->handshake_buffer);
	if (s->s3->handshake_dgst) ssl3_free_digest_list(s);
    s->s3->handshake_buffer=BIO_new(BIO_s_mem());	
	(void)BIO_set_close(s->s3->handshake_buffer,BIO_CLOSE);
a527 15
void ssl3_free_digest_list(SSL *s) 
	{
	int i;
	if (!s->s3->handshake_dgst) return;
	for (i=0;i<SSL_MAX_DIGEST;i++) 
		{
		if (s->s3->handshake_dgst[i])
			EVP_MD_CTX_destroy(s->s3->handshake_dgst[i]);
		}
	OPENSSL_free(s->s3->handshake_dgst);
	s->s3->handshake_dgst=NULL;
	}	
		


d530 2
a531 13
	if (s->s3->handshake_buffer) 
		{
		BIO_write (s->s3->handshake_buffer,(void *)buf,len);
		} 
	else 
		{
		int i;
		for (i=0;i< SSL_MAX_DIGEST;i++) 
			{
			if (s->s3->handshake_dgst[i]!= NULL)
			EVP_DigestUpdate(s->s3->handshake_dgst[i],buf,len);
			}
		}	
d534 1
a534 1
int ssl3_digest_cached_records(SSL *s)
d536 1
a536 36
	int i;
	long mask;
	const EVP_MD *md;
	long hdatalen;
	void *hdata;

	/* Allocate handshake_dgst array */
	ssl3_free_digest_list(s);
	s->s3->handshake_dgst = OPENSSL_malloc(SSL_MAX_DIGEST * sizeof(EVP_MD_CTX *));
	memset(s->s3->handshake_dgst,0,SSL_MAX_DIGEST *sizeof(EVP_MD_CTX *));
	hdatalen = BIO_get_mem_data(s->s3->handshake_buffer,&hdata);
	if (hdatalen <= 0)
		{
		SSLerr(SSL_F_SSL3_DIGEST_CACHED_RECORDS, SSL_R_BAD_HANDSHAKE_LENGTH);
		return 0;
		}

	/* Loop through bitso of algorithm2 field and create MD_CTX-es */
	for (i=0;ssl_get_handshake_digest(i,&mask,&md); i++) 
		{
		if ((mask & s->s3->tmp.new_cipher->algorithm2) && md) 
			{
			s->s3->handshake_dgst[i]=EVP_MD_CTX_create();
			EVP_DigestInit_ex(s->s3->handshake_dgst[i],md,NULL);
			EVP_DigestUpdate(s->s3->handshake_dgst[i],hdata,hdatalen);
			} 
		else 
			{	
			s->s3->handshake_dgst[i]=NULL;
			}
		}
	/* Free handshake_buffer BIO */
	BIO_free(s->s3->handshake_buffer);
	s->s3->handshake_buffer = NULL;

	return 1;
d539 1
a539 5
int ssl3_cert_verify_mac(SSL *s, int md_nid, unsigned char *p)
	{
	return(ssl3_handshake_mac(s,md_nid,NULL,0,p));
	}
int ssl3_final_finish_mac(SSL *s, 
d543 2
a544 1
	ret=ssl3_handshake_mac(s,NID_md5,sender,len,p);
d546 1
a546 1
	ret+=ssl3_handshake_mac(s,NID_sha1,sender,len,p);
d549 2
a550 1
static int ssl3_handshake_mac(SSL *s, int md_nid,
d557 1
a557 1
	EVP_MD_CTX ctx,*d=NULL;
d559 3
a561 3
	if (s->s3->handshake_buffer) 
		if (!ssl3_digest_cached_records(s))
			return 0;
a562 16
	/* Search for digest of specified type in the handshake_dgst
	 * array*/
	for (i=0;i<SSL_MAX_DIGEST;i++) 
		{
		  if (s->s3->handshake_dgst[i]&&EVP_MD_CTX_type(s->s3->handshake_dgst[i])==md_nid) 
		  	{
		  	d=s->s3->handshake_dgst[i];
			break;
			}
		}
	if (!d) {
		SSLerr(SSL_F_SSL3_HANDSHAKE_MAC,SSL_R_NO_REQUIRED_DIGEST);
		return 0;
	}	
	EVP_MD_CTX_init(&ctx);
	EVP_MD_CTX_copy_ex(&ctx,d);
d564 1
a564 2
	if (n < 0)
		return 0;
a565 1
	npad=(48/n)*n;
d585 1
a585 1
int n_ssl3_mac(SSL *ssl, unsigned char *md, int send)
d590 1
a590 1
	const EVP_MD_CTX *hash;
a593 1
	int t;
d610 1
a610 4
	t=EVP_MD_CTX_size(hash);
	if (t < 0)
		return -1;
	md_size=t;
d616 1
a616 1
	EVP_MD_CTX_copy_ex( &md_ctx,hash);
d628 1
a628 1
	EVP_MD_CTX_copy_ex( &md_ctx,hash);
a720 6
	case SSL_AD_UNSUPPORTED_EXTENSION: return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_CERTIFICATE_UNOBTAINABLE: return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_UNRECOGNIZED_NAME:	return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE: return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_BAD_CERTIFICATE_HASH_VALUE: return(SSL3_AD_HANDSHAKE_FAILURE);
	case SSL_AD_UNKNOWN_PSK_IDENTITY:return(TLS1_AD_UNKNOWN_PSK_IDENTITY);
@


1.1.1.10
log
@import OpenSSL 1.0.0e
@
text
@d217 1
a217 1
	unsigned char *p,*mac_secret;
d242 1
@


1.1.1.11
log
@OpenSSL 1.0.0f: import upstream source
@
text
@a513 3
			/* the last of these zero bytes will be overwritten
			 * with the padding length. */
			memset(&rec->input[rec->length], 0, i);
@


1.1.1.12
log
@import OpenSSL-1.0.1c
@
text
@a172 1
	EVP_MD_CTX_set_flags(&m5, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d574 1
a574 1

d579 1
a579 1
	if (s->s3->handshake_buffer && !(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) 
d616 1
a616 1
		if ((mask & ssl_get_algorithm2(s)) && md) 
a618 7
#ifdef OPENSSL_FIPS
			if (EVP_MD_nid(md) == NID_md5)
				{
				EVP_MD_CTX_set_flags(s->s3->handshake_dgst[i],
						EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
				}
#endif
d627 3
a629 6
	if (!(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE))
		{
		/* Free handshake_buffer BIO */
		BIO_free(s->s3->handshake_buffer);
		s->s3->handshake_buffer = NULL;
		}
a674 1
	EVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
@


1.1.1.13
log
@Import OpenSSL 1.0.1g
@
text
@a468 9
/* ssl3_enc encrypts/decrypts the record in |s->wrec| / |s->rrec|, respectively.
 *
 * Returns:
 *   0: (in non-constant time) if the record is publically invalid (i.e. too
 *       short etc).
 *   1: if the record's padding is valid / the encryption was successful.
 *   -1: if the record's padding is invalid or, if sending, an internal error
 *       occured.
 */
d474 1
a474 1
	int bs,i,mac_size=0;
d525 3
d529 1
a534 2
		if (EVP_MD_CTX_md(s->read_hash) != NULL)
			mac_size = EVP_MD_CTX_size(s->read_hash);
d536 15
a550 1
			return ssl3_cbc_remove_padding(s, rec, bs, mac_size);
d719 1
a719 1
	size_t md_size, orig_len;
d744 20
a763 63
	/* kludge: ssl3_cbc_remove_padding passes padding length in rec->type */
	orig_len = rec->length+md_size+((unsigned int)rec->type>>8);
	rec->type &= 0xff;

	if (!send &&
	    EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
	    ssl3_cbc_record_digest_supported(hash))
		{
		/* This is a CBC-encrypted record. We must avoid leaking any
		 * timing-side channel information about how many blocks of
		 * data we are hashing because that gives an attacker a
		 * timing-oracle. */

		/* npad is, at most, 48 bytes and that's with MD5:
		 *   16 + 48 + 8 (sequence bytes) + 1 + 2 = 75.
		 *
		 * With SHA-1 (the largest hash speced for SSLv3) the hash size
		 * goes up 4, but npad goes down by 8, resulting in a smaller
		 * total size. */
		unsigned char header[75];
		unsigned j = 0;
		memcpy(header+j, mac_sec, md_size);
		j += md_size;
		memcpy(header+j, ssl3_pad_1, npad);
		j += npad;
		memcpy(header+j, seq, 8);
		j += 8;
		header[j++] = rec->type;
		header[j++] = rec->length >> 8;
		header[j++] = rec->length & 0xff;

		ssl3_cbc_digest_record(
			hash,
			md, &md_size,
			header, rec->input,
			rec->length + md_size, orig_len,
			mac_sec, md_size,
			1 /* is SSLv3 */);
		}
	else
		{
		unsigned int md_size_u;
		/* Chop the digest off the end :-) */
		EVP_MD_CTX_init(&md_ctx);

		EVP_MD_CTX_copy_ex( &md_ctx,hash);
		EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
		EVP_DigestUpdate(&md_ctx,ssl3_pad_1,npad);
		EVP_DigestUpdate(&md_ctx,seq,8);
		rec_char=rec->type;
		EVP_DigestUpdate(&md_ctx,&rec_char,1);
		p=md;
		s2n(rec->length,p);
		EVP_DigestUpdate(&md_ctx,md,2);
		EVP_DigestUpdate(&md_ctx,rec->input,rec->length);
		EVP_DigestFinal_ex( &md_ctx,md,NULL);

		EVP_MD_CTX_copy_ex( &md_ctx,hash);
		EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
		EVP_DigestUpdate(&md_ctx,ssl3_pad_2,npad);
		EVP_DigestUpdate(&md_ctx,md,md_size);
		EVP_DigestFinal_ex( &md_ctx,md,&md_size_u);
		md_size = md_size_u;
d765 1
a765 2
		EVP_MD_CTX_cleanup(&md_ctx);
	}
@


