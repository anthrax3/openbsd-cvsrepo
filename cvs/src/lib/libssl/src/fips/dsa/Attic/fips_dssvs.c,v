head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.2.0.8
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.4
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	openssl_0_9_8_j:1.1.1.2
	openssl:1.1.1
	pre_openssl_0_9_8h:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.14
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.12
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.10
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.8
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.6
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.4
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.2
	OPENBSD_3_8_BASE:1.1.1.1
	OPENSSL_0_9_7G:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2010.10.01.22.58.58;	author djm;	state dead;
branches;
next	1.1;

1.1
date	2005.04.29.05.37.25;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.04.29.05.37.25;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.14.05;	author djm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@resolve conflicts, fix local changes
@
text
@#include <openssl/bn.h>
#include <openssl/dsa.h>
#include <openssl/fips.h>
#include <openssl/err.h>
#include <openssl/sha.h>
#include <string.h>

int hex2bin(const char *in, unsigned char *out)
    {
    int n1, n2;
    unsigned char ch;

    for (n1=0,n2=0 ; in[n1] && in[n1] != '\n' ; )
	{ /* first byte */
	if ((in[n1] >= '0') && (in[n1] <= '9'))
	    ch = in[n1++] - '0';
	else if ((in[n1] >= 'A') && (in[n1] <= 'F'))
	    ch = in[n1++] - 'A' + 10;
	else if ((in[n1] >= 'a') && (in[n1] <= 'f'))
	    ch = in[n1++] - 'a' + 10;
	else
	    return -1;
	if(!in[n1])
	    {
	    out[n2++]=ch;
	    break;
	    }
	out[n2] = ch << 4;
	/* second byte */
	if ((in[n1] >= '0') && (in[n1] <= '9'))
	    ch = in[n1++] - '0';
	else if ((in[n1] >= 'A') && (in[n1] <= 'F'))
	    ch = in[n1++] - 'A' + 10;
	else if ((in[n1] >= 'a') && (in[n1] <= 'f'))
	    ch = in[n1++] - 'a' + 10;
	else
	    return -1;
	out[n2++] |= ch;
	}
    return n2;
    }

BIGNUM *hex2bn(const char *in)
    {
    BIGNUM *p=BN_new();

    BN_hex2bn(&p,in);

    return p;
    }

int bin2hex(const unsigned char *in,int len,char *out)
    {
    int n1, n2;
    unsigned char ch;

    for (n1=0,n2=0 ; n1 < len ; ++n1)
	{
	ch=in[n1] >> 4;
	if (ch <= 0x09)
	    out[n2++]=ch+'0';
	else
	    out[n2++]=ch-10+'a';
	ch=in[n1] & 0x0f;
	if(ch <= 0x09)
	    out[n2++]=ch+'0';
	else
	    out[n2++]=ch-10+'a';
	}
    out[n2]='\0';
    return n2;
    }

void pv(const char *tag,const unsigned char *val,int len)
    {
    char obuf[2048];

    bin2hex(val,len,obuf);
    printf("%s = %s\n",tag,obuf);
    }

void pbn(const char *tag,const BIGNUM *val)
    {
    printf("%s = %s\n",tag,BN_bn2hex(val));
    }

void primes()
    {
    char buf[10240];

    while(fgets(buf,sizeof buf,stdin) != NULL)
	{
	fputs(buf,stdout);
	if(!strncmp(buf,"Prime= ",7))
	    {
	    BIGNUM *pp;

	    pp=BN_new();
	    BN_hex2bn(&pp,buf+7);
	    printf("result= %c\n",
		   BN_is_prime(pp,20,NULL,NULL,NULL) ? 'P' : 'F');
	    }	    
	}
    }

void pqg()
    {
    char buf[1024];
    int nmod=0;

    while(fgets(buf,sizeof buf,stdin) != NULL)
	{
	if(!strncmp(buf,"[mod = ",7))
	    nmod=atoi(buf+7);
	else if(!strncmp(buf,"N = ",4))
	    {
	    int n=atoi(buf+4);

	    printf("[mod = %d]\n\n",nmod);

	    while(n--)
		{
		unsigned char seed[20];
		DSA *dsa;
		int counter;
		unsigned long h;

		dsa=DSA_generate_parameters(nmod,seed,0,&counter,&h,NULL,NULL);
		printf("P = %s\n",BN_bn2hex(dsa->p));
		printf("Q = %s\n",BN_bn2hex(dsa->q));
		printf("G = %s\n",BN_bn2hex(dsa->g));
		pv("Seed",seed,20);
		printf("c = %d\n",counter);
		printf("H = %lx\n",h);
		putc('\n',stdout);
		}
	    }
	else
	    fputs(buf,stdout);
	}
    }

void keypair()
    {
    char buf[1024];
    int nmod=0;

    while(fgets(buf,sizeof buf,stdin) != NULL)
	{
	if(!strncmp(buf,"[mod = ",7))
	    nmod=atoi(buf+7);
	else if(!strncmp(buf,"N = ",4))
	    {
	    DSA *dsa;
	    int n=atoi(buf+4);

	    printf("[mod = %d]\n\n",nmod);

	    dsa=DSA_generate_parameters(nmod,NULL,0,NULL,NULL,NULL,NULL);
	    pbn("P",dsa->p);
	    pbn("Q",dsa->q);
	    pbn("G",dsa->g);
	    putc('\n',stdout);

	    while(n--)
		{
		DSA_generate_key(dsa);

		pbn("X",dsa->priv_key);
		pbn("Y",dsa->pub_key);
		putc('\n',stdout);
		}
	    }
	}
    }

void siggen()
    {
    char buf[1024];
    int nmod=0;
    DSA *dsa=NULL;

    while(fgets(buf,sizeof buf,stdin) != NULL)
	{
	if(!strncmp(buf,"[mod = ",7))
	    {
	    nmod=atoi(buf+7);
	    printf("[mod = %d]\n\n",nmod);

	    dsa=DSA_generate_parameters(nmod,NULL,0,NULL,NULL,NULL,NULL);
	    pbn("P",dsa->p);
	    pbn("Q",dsa->q);
	    pbn("G",dsa->g);
	    putc('\n',stdout);
	    }
	else if(!strncmp(buf,"Msg = ",6))
	    {
	    unsigned char msg[1024];
	    unsigned char hash[20];
	    int n;
	    DSA_SIG *sig;

	    n=hex2bin(buf+6,msg);
	    pv("Msg",msg,n);

	    DSA_generate_key(dsa);
	    pbn("Y",dsa->pub_key);

	    SHA1(msg,n,hash);
	    sig=DSA_do_sign(hash,sizeof hash,dsa);
	    pbn("R",sig->r);
	    pbn("S",sig->s);
	    putc('\n',stdout);
	    }
	}
    }

void sigver()
    {
    DSA *dsa=NULL;
    char buf[1024];
    int nmod=0;
    unsigned char hash[20];
    DSA_SIG *sig=DSA_SIG_new();

    while(fgets(buf,sizeof buf,stdin) != NULL)
	{
	if(!strncmp(buf,"[mod = ",7))
	    {
	    nmod=atoi(buf+7);
	    if(dsa)
		DSA_free(dsa);
	    dsa=DSA_new();
	    }
	else if(!strncmp(buf,"P = ",4))
	    dsa->p=hex2bn(buf+4);
	else if(!strncmp(buf,"Q = ",4))
	    dsa->q=hex2bn(buf+4);
	else if(!strncmp(buf,"G = ",4))
	    {
	    dsa->g=hex2bn(buf+4);

	    printf("[mod = %d]\n\n",nmod);
	    pbn("P",dsa->p);
	    pbn("Q",dsa->q);
	    pbn("G",dsa->g);
	    putc('\n',stdout);
	    }
	else if(!strncmp(buf,"Msg = ",6))
	    {
	    unsigned char msg[1024];
	    int n;

	    n=hex2bin(buf+6,msg);
	    pv("Msg",msg,n);
	    SHA1(msg,n,hash);
	    }
	else if(!strncmp(buf,"Y = ",4))
	    dsa->pub_key=hex2bn(buf+4);
	else if(!strncmp(buf,"R = ",4))
	    sig->r=hex2bn(buf+4);
	else if(!strncmp(buf,"S = ",4))
	    {
	    sig->s=hex2bn(buf+4);
	
	    pbn("Y",dsa->pub_key);
	    pbn("R",sig->r);
	    pbn("S",sig->s);
	    printf("Result = %c\n",DSA_do_verify(hash,sizeof hash,sig,dsa)
		   ? 'P' : 'F');
	    putc('\n',stdout);
	    }
	}
    }

int main(int argc,char **argv)
    {
    if(argc != 2)
	{
	fprintf(stderr,"%s [prime|pqg]\n",argv[0]);
	exit(1);
	}
    if(!FIPS_mode_set(1,argv[0]))
	{
	ERR_load_crypto_strings();
	ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
	exit(1);
	}
    if(!strcmp(argv[1],"prime"))
	primes();
    else if(!strcmp(argv[1],"pqg"))
	pqg();
    else if(!strcmp(argv[1],"keypair"))
	keypair();
    else if(!strcmp(argv[1],"siggen"))
	siggen();
    else if(!strcmp(argv[1],"sigver"))
	sigver();
    else
	{
	fprintf(stderr,"Don't know how to %s.\n",argv[1]);
	exit(1);
	}

    return 0;
    }
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@a0 12
#include <openssl/opensslconf.h>

#ifndef OPENSSL_FIPS
#include <stdio.h>

int main(int argc, char **argv)
{
    printf("No FIPS DSA support\n");
    return(0);
}
#else

d5 1
a5 1
#include <openssl/evp.h>
a6 1
#include <ctype.h>
d8 43
a50 1
#include "fips_utl.h"
d52 6
a57 1
static void pbn(const char *name, BIGNUM *bn)
d59 10
a68 16
	int len, i;
	unsigned char *tmp;
	len = BN_num_bytes(bn);
	tmp = OPENSSL_malloc(len);
	if (!tmp)
		{
		fprintf(stderr, "Memory allocation error\n");
		return;
		}
	BN_bn2bin(bn, tmp);
	printf("%s = ", name);
	for (i = 0; i < len; i++)
		printf("%02X", tmp[i]);
	fputs("\n", stdout);
	OPENSSL_free(tmp);
	return;
d70 16
a89 2
    char lbuf[10240];
    char *keyword, *value;
d94 1
a94 3
	if (!parse_line(&keyword, &value, lbuf, buf))
		continue;
	if(!strcmp(keyword,"Prime"))
d99 1
a99 1
	    do_hex2bn(&pp,value);
d101 1
a101 1
		   BN_is_prime_ex(pp,20,NULL,NULL) ? 'P' : 'F');
a108 2
    char lbuf[1024];
    char *keyword, *value;
d113 3
a115 8
	if (!parse_line(&keyword, &value, lbuf, buf))
		{
		fputs(buf,stdout);
		continue;
		}
	if(!strcmp(keyword,"[mod"))
	    nmod=atoi(value);
	else if(!strcmp(keyword,"N"))
d117 1
a117 1
	    int n=atoi(value);
a126 1
		dsa = FIPS_dsa_new();
d128 4
a131 8
		if (!DSA_generate_parameters_ex(dsa, nmod,seed,0,&counter,&h,NULL))
			{
			do_print_errors();
			exit(1);
			}
		pbn("P",dsa->p);
		pbn("Q",dsa->q);
		pbn("G",dsa->g);
a142 192
void pqgver()
    {
    char buf[1024];
    char lbuf[1024];
    char *keyword, *value;
    BIGNUM *p = NULL, *q = NULL, *g = NULL;
    int counter, counter2;
    unsigned long h, h2;
    DSA *dsa=NULL;
    int nmod=0;
    unsigned char seed[1024];

    while(fgets(buf,sizeof buf,stdin) != NULL)
	{
	if (!parse_line(&keyword, &value, lbuf, buf))
		{
		fputs(buf,stdout);
		continue;
		}
	if(!strcmp(keyword,"[mod"))
	    nmod=atoi(value);
	else if(!strcmp(keyword,"P"))
	    p=hex2bn(value);
	else if(!strcmp(keyword,"Q"))
	    q=hex2bn(value);
	else if(!strcmp(keyword,"G"))
	    g=hex2bn(value);
	else if(!strcmp(keyword,"Seed"))
	    {
	    int slen = hex2bin(value, seed);
	    if (slen != 20)
		{
		fprintf(stderr, "Seed parse length error\n");
		exit (1);
		}
	    }
	else if(!strcmp(keyword,"c"))
	    counter =atoi(buf+4);
	else if(!strcmp(keyword,"H"))
	    {
	    h = atoi(value);
	    if (!p || !q || !g)
		{
		fprintf(stderr, "Parse Error\n");
		exit (1);
		}
	    pbn("P",p);
	    pbn("Q",q);
	    pbn("G",g);
	    pv("Seed",seed,20);
	    printf("c = %d\n",counter);
	    printf("H = %lx\n",h);
	    dsa = FIPS_dsa_new();
	    if (!DSA_generate_parameters_ex(dsa, nmod,seed,20 ,&counter2,&h2,NULL))
			{
			do_print_errors();
			exit(1);
			}
            if (BN_cmp(dsa->p, p) || BN_cmp(dsa->q, q) || BN_cmp(dsa->g, g)
		|| (counter != counter2) || (h != h2))
	    	printf("Result = F\n");
	    else
	    	printf("Result = T\n");
	    BN_free(p);
	    BN_free(q);
	    BN_free(g);
	    p = NULL;
	    q = NULL;
	    g = NULL;
	    FIPS_dsa_free(dsa);
	    dsa = NULL;
	    }
	}
    }

/* Keypair verification routine. NB: this isn't part of the standard FIPS140-2
 * algorithm tests. It is an additional test to perform sanity checks on the
 * output of the KeyPair test.
 */

static int dss_paramcheck(int nmod, BIGNUM *p, BIGNUM *q, BIGNUM *g,
							BN_CTX *ctx)
    {
    BIGNUM *rem = NULL;
    if (BN_num_bits(p) != nmod)
	return 0;
    if (BN_num_bits(q) != 160)
	return 0;
    if (BN_is_prime_ex(p, BN_prime_checks, ctx, NULL) != 1)
	return 0;
    if (BN_is_prime_ex(q, BN_prime_checks, ctx, NULL) != 1)
	return 0;
    rem = BN_new();
    if (!BN_mod(rem, p, q, ctx) || !BN_is_one(rem)
    	|| (BN_cmp(g, BN_value_one()) <= 0)
	|| !BN_mod_exp(rem, g, q, p, ctx) || !BN_is_one(rem))
	{
	BN_free(rem);
	return 0;
	}
    /* Todo: check g */
    BN_free(rem);
    return 1;
    }

void keyver()
    {
    char buf[1024];
    char lbuf[1024];
    char *keyword, *value;
    BIGNUM *p = NULL, *q = NULL, *g = NULL, *X = NULL, *Y = NULL;
    BIGNUM *Y2;
    BN_CTX *ctx = NULL;
    int nmod=0, paramcheck = 0;

    ctx = BN_CTX_new();
    Y2 = BN_new();

    while(fgets(buf,sizeof buf,stdin) != NULL)
	{
	if (!parse_line(&keyword, &value, lbuf, buf))
		{
		fputs(buf,stdout);
		continue;
		}
	if(!strcmp(keyword,"[mod"))
	    {
	    if (p)
		BN_free(p);
	    p = NULL;
	    if (q)
		BN_free(q);
	    q = NULL;
	    if (g)
		BN_free(g);
	    g = NULL;
	    paramcheck = 0;
	    nmod=atoi(value);
	    }
	else if(!strcmp(keyword,"P"))
	    p=hex2bn(value);
	else if(!strcmp(keyword,"Q"))
	    q=hex2bn(value);
	else if(!strcmp(keyword,"G"))
	    g=hex2bn(value);
	else if(!strcmp(keyword,"X"))
	    X=hex2bn(value);
	else if(!strcmp(keyword,"Y"))
	    {
	    Y=hex2bn(value);
	    if (!p || !q || !g || !X || !Y)
		{
		fprintf(stderr, "Parse Error\n");
		exit (1);
		}
	    pbn("P",p);
	    pbn("Q",q);
	    pbn("G",g);
	    pbn("X",X);
	    pbn("Y",Y);
	    if (!paramcheck)
		{
		if (dss_paramcheck(nmod, p, q, g, ctx))
			paramcheck = 1;
		else
			paramcheck = -1;
		}
	    if (paramcheck != 1)
	   	printf("Result = F\n");
	    else
		{
		if (!BN_mod_exp(Y2, g, X, p, ctx) || BN_cmp(Y2, Y))
	    		printf("Result = F\n");
	        else
	    		printf("Result = T\n");
		}
	    BN_free(X);
	    BN_free(Y);
	    X = NULL;
	    Y = NULL;
	    }
	}
	if (p)
	    BN_free(p);
	if (q)
	    BN_free(q);
	if (g)
	    BN_free(g);
	if (Y2)
	    BN_free(Y2);
    }

a145 2
    char lbuf[1024];
    char *keyword, *value;
d150 3
a152 8
	if (!parse_line(&keyword, &value, lbuf, buf))
		{
		fputs(buf,stdout);
		continue;
		}
	if(!strcmp(keyword,"[mod"))
	    nmod=atoi(value);
	else if(!strcmp(keyword,"N"))
d155 1
a155 1
	    int n=atoi(value);
d158 2
a159 6
	    dsa = FIPS_dsa_new();
	    if (!DSA_generate_parameters_ex(dsa, nmod,NULL,0,NULL,NULL,NULL))
		{
		do_print_errors();
		exit(1);
		}
d167 1
a167 5
		if (!DSA_generate_key(dsa))
			{
			do_print_errors();
			exit(1);
			}
a179 2
    char lbuf[1024];
    char *keyword, *value;
d185 1
a185 6
	if (!parse_line(&keyword, &value, lbuf, buf))
		{
		fputs(buf,stdout);
		continue;
		}
	if(!strcmp(keyword,"[mod"))
d187 1
a187 1
	    nmod=atoi(value);
d189 2
a190 8
	    if (dsa)
		FIPS_dsa_free(dsa);
	    dsa = FIPS_dsa_new();
	    if (!DSA_generate_parameters_ex(dsa, nmod,NULL,0,NULL,NULL,NULL))
		{
		do_print_errors();
		exit(1);
		}
d196 1
a196 1
	else if(!strcmp(keyword,"Msg"))
d199 1
a199 2
	    unsigned char sbuf[60];
	    unsigned int slen;
a200 2
	    EVP_PKEY pk;
	    EVP_MD_CTX mctx;
a201 1
	    EVP_MD_CTX_init(&mctx);
d203 1
a203 1
	    n=hex2bin(value,msg);
d206 1
a206 7
	    if (!DSA_generate_key(dsa))
		{
		do_print_errors();
		exit(1);
		}
	    pk.type = EVP_PKEY_DSA;
	    pk.pkey.dsa = dsa;
d209 2
a210 7
	    EVP_SignInit_ex(&mctx, EVP_dss1(), NULL);
	    EVP_SignUpdate(&mctx, msg, n);
	    EVP_SignFinal(&mctx, sbuf, &slen, &pk);

	    sig = DSA_SIG_new();
	    FIPS_dsa_sig_decode(sig, sbuf, slen);

a213 2
	    DSA_SIG_free(sig);
	    EVP_MD_CTX_cleanup(&mctx);
a215 2
	if (dsa)
		FIPS_dsa_free(dsa);
d222 3
a224 8
    char lbuf[1024];
    unsigned char msg[1024];
    char *keyword, *value;
    int nmod=0, n=0;
    DSA_SIG sg, *sig = &sg;

    sig->r = NULL;
    sig->s = NULL;
d228 1
a228 6
	if (!parse_line(&keyword, &value, lbuf, buf))
		{
		fputs(buf,stdout);
		continue;
		}
	if(!strcmp(keyword,"[mod"))
d230 1
a230 1
	    nmod=atoi(value);
d232 2
a233 2
		FIPS_dsa_free(dsa);
	    dsa=FIPS_dsa_new();
d235 5
a239 5
	else if(!strcmp(keyword,"P"))
	    dsa->p=hex2bn(value);
	else if(!strcmp(keyword,"Q"))
	    dsa->q=hex2bn(value);
	else if(!strcmp(keyword,"G"))
d241 1
a241 1
	    dsa->g=hex2bn(value);
d249 1
a249 1
	else if(!strcmp(keyword,"Msg"))
d251 4
a254 1
	    n=hex2bin(value,msg);
d256 1
d258 5
a262 5
	else if(!strcmp(keyword,"Y"))
	    dsa->pub_key=hex2bn(value);
	else if(!strcmp(keyword,"R"))
	    sig->r=hex2bn(value);
	else if(!strcmp(keyword,"S"))
d264 1
a264 9
	    EVP_MD_CTX mctx;
	    EVP_PKEY pk;
	    unsigned char sigbuf[60];
	    unsigned int slen;
	    int r;
	    EVP_MD_CTX_init(&mctx);
	    pk.type = EVP_PKEY_DSA;
	    pk.pkey.dsa = dsa;
	    sig->s=hex2bn(value);
d269 2
a270 8

	    slen = FIPS_dsa_sig_encode(sigbuf, sig);
	    EVP_VerifyInit_ex(&mctx, EVP_dss1(), NULL);
	    EVP_VerifyUpdate(&mctx, msg, n);
	    r = EVP_VerifyFinal(&mctx, sigbuf, slen, &pk);
	    EVP_MD_CTX_cleanup(&mctx);
	
	    printf("Result = %c\n", r == 1 ? 'P' : 'F');
d280 1
a280 1
	fprintf(stderr,"%s [prime|pqg|pqgver|keypair|siggen|sigver]\n",argv[0]);
d283 1
a283 1
    if(!FIPS_mode_set(1))
d285 2
a286 1
	do_print_errors();
a292 2
    else if(!strcmp(argv[1],"pqgver"))
	pqgver();
a294 2
    else if(!strcmp(argv[1],"keyver"))
	keyver();
a306 2

#endif
@

