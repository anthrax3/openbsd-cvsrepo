head	1.4;
access;
symbols
	butholakala:1.3
	openssl_1_0_1_g:1.1.1.3
	OPENBSD_5_5:1.3.0.16
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.12
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.10
	OPENBSD_5_3_BASE:1.3
	openssl_1_0_1_c:1.1.1.3
	OPENBSD_5_2:1.3.0.6
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.3
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.2.0.8
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.1
	OPENBSD_4_4:1.1.0.26
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.24
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.22
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.20
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.18
	OPENBSD_4_0_BASE:1.1
	openssl_0_9_7j:1.1.1.1
	openssl:1.1.1
	OPENBSD_3_9:1.1.0.16
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.14
	OPENBSD_3_8_BASE:1.1
	OPENSSL_0_9_7G:1.1.1.1
	OPENBSD_3_7:1.1.0.12
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.10
	OPENBSD_3_6_BASE:1.1
	OPENSSL_0_9_7D:1.1.1.1
	OPENBSD_3_5:1.1.0.8
	OPENBSD_3_5_BASE:1.1
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.1.0.6
	OPENBSD_3_4_BASE:1.1
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.16.18.35.15;	author tedu;	state dead;
branches;
next	1.3;

1.3
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.18;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.07;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.06.12.15.48;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.12;	author djm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@quoth the readme:
NOTE: Don't expect any of these programs to work with current
OpenSSL releases, or even with later SSLeay releases.
ok miod
@
text
@#include "tunala.h"

#ifndef NO_OPENSSL

/* For callbacks generating output, here are their file-descriptors. */
static FILE *fp_cb_ssl_info = NULL;
static FILE *fp_cb_ssl_verify = NULL;
/* Output level:
 *     0 = nothing,
 *     1 = minimal, just errors,
 *     2 = minimal, all steps,
 *     3 = detail, all steps */
static unsigned int cb_ssl_verify_level = 1;

/* Other static rubbish (to mirror s_cb.c where required) */
static int int_verify_depth = 10;

/* This function is largely borrowed from the one used in OpenSSL's "s_client"
 * and "s_server" utilities. */
void cb_ssl_info(const SSL *s, int where, int ret)
{
	const char *str1, *str2;
	int w;

	if(!fp_cb_ssl_info)
		return;

	w = where & ~SSL_ST_MASK;
	str1 = (w & SSL_ST_CONNECT ? "SSL_connect" : (w & SSL_ST_ACCEPT ?
				"SSL_accept" : "undefined")),
	str2 = SSL_state_string_long(s);

	if (where & SSL_CB_LOOP)
		fprintf(fp_cb_ssl_info, "(%s) %s\n", str1, str2);
	else if (where & SSL_CB_EXIT) {
		if (ret == 0)
			fprintf(fp_cb_ssl_info, "(%s) failed in %s\n", str1, str2);
/* In a non-blocking model, we get a few of these "error"s simply because we're
 * calling "reads" and "writes" on the state-machine that are virtual NOPs
 * simply to avoid wasting the time seeing if we *should* call them. Removing
 * this case makes the "-out_state" output a lot easier on the eye. */
#if 0
		else if (ret < 0)
			fprintf(fp_cb_ssl_info, "%s:error in %s\n", str1, str2);
#endif
	}
}

void cb_ssl_info_set_output(FILE *fp)
{
	fp_cb_ssl_info = fp;
}

static const char *int_reason_no_issuer = "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT";
static const char *int_reason_not_yet = "X509_V_ERR_CERT_NOT_YET_VALID";
static const char *int_reason_before = "X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD";
static const char *int_reason_expired = "X509_V_ERR_CERT_HAS_EXPIRED";
static const char *int_reason_after = "X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD";

/* Stolen wholesale from apps/s_cb.c :-) And since then, mutilated ... */
int cb_ssl_verify(int ok, X509_STORE_CTX *ctx)
{
	char buf1[256]; /* Used for the subject name */
	char buf2[256]; /* Used for the issuer name */
	const char *reason = NULL; /* Error reason (if any) */
	X509 *err_cert;
	int err, depth;

	if(!fp_cb_ssl_verify || (cb_ssl_verify_level == 0))
		return ok;
	err_cert = X509_STORE_CTX_get_current_cert(ctx);
	err = X509_STORE_CTX_get_error(ctx);
	depth = X509_STORE_CTX_get_error_depth(ctx);

	buf1[0] = buf2[0] = '\0';
	/* Fill buf1 */
	X509_NAME_oneline(X509_get_subject_name(err_cert), buf1, 256);
	/* Fill buf2 */
	X509_NAME_oneline(X509_get_issuer_name(ctx->current_cert), buf2, 256);
	switch (ctx->error) {
	case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
		reason = int_reason_no_issuer;
		break;
	case X509_V_ERR_CERT_NOT_YET_VALID:
		reason = int_reason_not_yet;
		break;
	case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:
		reason = int_reason_before;
		break;
	case X509_V_ERR_CERT_HAS_EXPIRED:
		reason = int_reason_expired;
		break;
	case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:
		reason = int_reason_after;
		break;
	}

	if((cb_ssl_verify_level == 1) && ok)
		return ok;
	fprintf(fp_cb_ssl_verify, "chain-depth=%d, ", depth);
	if(reason)
		fprintf(fp_cb_ssl_verify, "error=%s\n", reason);
	else
		fprintf(fp_cb_ssl_verify, "error=%d\n", err);
	if(cb_ssl_verify_level < 3)
		return ok;
	fprintf(fp_cb_ssl_verify, "--> subject = %s\n", buf1);
	fprintf(fp_cb_ssl_verify, "--> issuer  = %s\n", buf2);
	if(!ok)
		fprintf(fp_cb_ssl_verify,"--> verify error:num=%d:%s\n",err,
			X509_verify_cert_error_string(err));
	fprintf(fp_cb_ssl_verify, "--> verify return:%d\n",ok);
	return ok;
}

void cb_ssl_verify_set_output(FILE *fp)
{
	fp_cb_ssl_verify = fp;
}

void cb_ssl_verify_set_depth(unsigned int verify_depth)
{
	int_verify_depth = verify_depth;
}

void cb_ssl_verify_set_level(unsigned int level)
{
	if(level < 4)
		cb_ssl_verify_level = level;
}

RSA *cb_generate_tmp_rsa(SSL *s, int is_export, int keylength)
{
	/* TODO: Perhaps make it so our global key can be generated on-the-fly
	 * after certain intervals? */
	static RSA *rsa_tmp = NULL;
	BIGNUM *bn = NULL;
	int ok = 1;
	if(!rsa_tmp) {
		ok = 0;
		if(!(bn = BN_new()))
			goto end;
		if(!BN_set_word(bn, RSA_F4))
			goto end;
		if(!(rsa_tmp = RSA_new()))
			goto end;
		if(!RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL))
			goto end;
		ok = 1;
	}
end:
	if(bn)
		BN_free(bn);
	if(!ok) {
		RSA_free(rsa_tmp);
		rsa_tmp = NULL;
	}
	return rsa_tmp;
}

#endif /* !defined(NO_OPENSSL) */

@


1.3
log
@resolve conflicts, fix local changes
@
text
@@


1.2
log
@resolve conflicts
@
text
@d137 21
a157 2
	if(!rsa_tmp)
		rsa_tmp = RSA_generate_key(keylength, RSA_F4, NULL, NULL);
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d132 10
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import of OpenSSL 0.9.8h
@
text
@a131 10
RSA *cb_generate_tmp_rsa(SSL *s, int is_export, int keylength)
{
	/* TODO: Perhaps make it so our global key can be generated on-the-fly
	 * after certain intervals? */
	static RSA *rsa_tmp = NULL;
	if(!rsa_tmp)
		rsa_tmp = RSA_generate_key(keylength, RSA_F4, NULL, NULL);
	return rsa_tmp;
}

@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@d137 2
a138 21
	BIGNUM *bn = NULL;
	int ok = 1;
	if(!rsa_tmp) {
		ok = 0;
		if(!(bn = BN_new()))
			goto end;
		if(!BN_set_word(bn, RSA_F4))
			goto end;
		if(!(rsa_tmp = RSA_new()))
			goto end;
		if(!RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL))
			goto end;
		ok = 1;
	}
end:
	if(bn)
		BN_free(bn);
	if(!ok) {
		RSA_free(rsa_tmp);
		rsa_tmp = NULL;
	}
@


