head	1.2;
access;
symbols
	butholakala:1.1.1.1
	openssl_1_0_1_g:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.66
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.62
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.60
	OPENBSD_5_3_BASE:1.1.1.1
	openssl_1_0_1_c:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.56
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.58
	openssl_1_0_0_f:1.1.1.1
	openssl_1_0_0_e:1.1.1.1
	OPENBSD_5_0:1.1.1.1.0.54
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.52
	OPENBSD_4_9_BASE:1.1.1.1
	openssh_1_0_0_a:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.50
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.46
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.48
	OPENBSD_4_6_BASE:1.1.1.1
	openssl_0_9_8_k:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.44
	OPENBSD_4_5_BASE:1.1.1.1
	openssl_0_9_8_j:1.1.1.1
	openssl_0_9_8_h:1.1.1.1
	pre_openssl_0_9_8h:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.42
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.40
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.38
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.36
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.34
	OPENBSD_4_0_BASE:1.1.1.1
	openssl_0_9_7j:1.1.1.1
	openssl:1.1.1
	OPENBSD_3_9:1.1.1.1.0.32
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.30
	OPENBSD_3_8_BASE:1.1.1.1
	OPENSSL_0_9_7G:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.28
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.26
	OPENBSD_3_6_BASE:1.1.1.1
	OPENSSL_0_9_7D:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.24
	OPENBSD_3_5_BASE:1.1.1.1
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.22
	OPENBSD_3_4_BASE:1.1.1.1
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.20
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.18
	OPENBSD_3_2_BASE:1.1.1.1
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.1.1.1.0.16
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.14
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.12
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.10
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2014.04.16.18.35.15;	author tedu;	state dead;
branches;
next	1.1;

1.1
date	98.10.05.20.13.15;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.15;	author ryker;	state Exp;
branches;
next	;


desc
@@


1.2
log
@quoth the readme:
NOTE: Don't expect any of these programs to work with current
OpenSSL releases, or even with later SSLeay releases.
ok miod
@
text
@From ssl-lists-owner@@mincom.com Mon Sep 30 22:43:15 1996
Received: from cygnus.mincom.oz.au by orb.mincom.oz.au with SMTP id AA12802
  (5.65c/IDA-1.4.4 for eay); Mon, 30 Sep 1996 12:45:43 +1000
Received: (from daemon@@localhost) by cygnus.mincom.oz.au (8.7.5/8.7.3) id MAA25922 for ssl-users-outgoing; Mon, 30 Sep 1996 12:43:43 +1000 (EST)
Received: from orb.mincom.oz.au (eay@@orb.mincom.oz.au [192.55.197.1]) by cygnus.mincom.oz.au (8.7.5/8.7.3) with SMTP id MAA25900 for <ssl-users@@listserv.mincom.oz.au>; Mon, 30 Sep 1996 12:43:39 +1000 (EST)
Received: by orb.mincom.oz.au id AA12688
  (5.65c/IDA-1.4.4 for ssl-users@@listserv.mincom.oz.au); Mon, 30 Sep 1996 12:43:16 +1000
Date: Mon, 30 Sep 1996 12:43:15 +1000 (EST)
From: Eric Young <eay@@mincom.com>
X-Sender: eay@@orb
To: Sampo Kellomaki <sampo@@neuronio.pt>
Cc: ssl-users@@mincom.com, sampo@@brutus.neuronio.pt
Subject: Re: Signing with envelope routines
In-Reply-To: <199609300037.BAA08729@@brutus.neuronio.pt>
Message-Id: <Pine.SOL.3.91.960930121504.11800Y-100000@@orb>
Mime-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII
Sender: ssl-lists-owner@@mincom.com
Precedence: bulk
Status: O
X-Status: 


On Mon, 30 Sep 1996, Sampo Kellomaki wrote:
> I have been trying to figure out how to produce signatures with EVP_
> routines. I seem to be able to read in private key and sign some
> data ok, but I can't figure out how I am supposed to read in
> public key so that I could verify my signature. I use self signed
> certificate.

hmm... a rather poorly documented are of the library at this point in time.

> I figured I should use
> 	EVP_PKEY* pkey = PEM_ASN1_read(d2i_PrivateKey, PEM_STRING_EVP_PKEY,
> 	                               fp, NULL, NULL);
> to read in private key and this seems to work Ok.
> 
> However when I try analogous
> 	EVP_PKEY* pkey = PEM_ASN1_read(d2i_PublicKey, PEM_STRING_X509,
> 	                               fp, NULL, NULL);

What you should do is 
	X509 *x509=PEM_read_X509(fp,NULL,NULL);
	/* which is the same as PEM_ASN1_read(d2i_X509,PEM_STRING_X509,fp,
	 * NULL,NULL); */
Then
	EVP_PKEY *pkey=X509_extract_key(x509);

There is also a X509_REQ_extract_key(req);
which gets the public key from a certificate request.

I re-worked quite a bit of this when I cleaned up the dependancy on
RSA as the private key.

> I figured that the second argument to PEM_ASN1_read should match the
> name in my PEM encoded object, hence PEM_STRING_X509.
> PEM_STRING_EVP_PKEY seems to be somehow magical
> because it matches whatever private key there happens to be. I could
> not find a similar constant to use with getting the certificate, however.

:-), PEM_STRING_EVP_PKEY is 'magical' :-).  In theory I should be using a
standard such as PKCS#8 to store the private key so that the type is 
encoded in the asn.1 encoding of the object.

> Is my approach of using PEM_ASN1_read correct? What should I pass in
> as name?  Can I use normal (or even self signed) X509 certificate for
> verifying the signature?

The actual public key is kept in the certificate, so basically you have 
to load the certificate and then 'unpack' the public key from the 
certificate.

> When will SSLeay documentation be written ;-)? If I would contribute
> comments to the code, would Eric take time to review them and include
> them in distribution?

:-) After SSLv3 and PKCS#7 :-).  I actually started doing a function list 
but what I really need to do is do quite a few 'this is how you do xyz' 
type documents.  I suppose the current method is to post to ssl-users and 
I'll respond :-).

I'll add a 'demo' directory for the next release, I've appended a 
modified version of your program that works, you were very close :-).

eric

/* sign-it.cpp  -  Simple test app using SSLeay envelopes to sign data
   29.9.1996, Sampo Kellomaki <sampo@@iki.fi> */

/* converted to C - eay :-) */

#include <stdio.h>
#include "rsa.h"
#include "evp.h"
#include "objects.h"
#include "x509.h"
#include "err.h"
#include "pem.h"
#include "ssl.h"

void main ()
{
  int err;
  int sig_len;
  unsigned char sig_buf [4096];
  static char certfile[] = "plain-cert.pem";
  static char keyfile[]  = "plain-key.pem";
  static char data[]     = "I owe you...";
  EVP_MD_CTX     md_ctx;
  EVP_PKEY *      pkey;
  FILE *          fp;
  X509 *	x509;

  /* Just load the crypto library error strings,
   * SSL_load_error_strings() loads the crypto AND the SSL ones */
  /* SSL_load_error_strings();*/
  ERR_load_crypto_strings();
  
  /* Read private key */
  
  fp = fopen (keyfile, "r");   if (fp == NULL) exit (1);
  pkey = (EVP_PKEY*)PEM_ASN1_read ((char *(*)())d2i_PrivateKey,
				   PEM_STRING_EVP_PKEY,
				   fp,
				   NULL, NULL);
  if (pkey == NULL) {  ERR_print_errors_fp (stderr);    exit (1);  }
  fclose (fp);
  
  /* Do the signature */
  
  EVP_SignInit   (&md_ctx, EVP_md5());
  EVP_SignUpdate (&md_ctx, data, strlen(data));
  sig_len = sizeof(sig_buf);
  err = EVP_SignFinal (&md_ctx,
		       sig_buf, 
		       &sig_len,
		       pkey);
  if (err != 1) {  ERR_print_errors_fp (stderr);    exit (1);  }
  EVP_PKEY_free (pkey);
  
  /* Read public key */
  
  fp = fopen (certfile, "r");   if (fp == NULL) exit (1);
  x509 = (X509 *)PEM_ASN1_read ((char *(*)())d2i_X509,
				   PEM_STRING_X509,
				   fp, NULL, NULL);
  if (x509 == NULL) {  ERR_print_errors_fp (stderr);    exit (1);  }
  fclose (fp);
  
  /* Get public key - eay */
  pkey=X509_extract_key(x509);
  if (pkey == NULL) {  ERR_print_errors_fp (stderr);    exit (1);  }

  /* Verify the signature */
  
  EVP_VerifyInit   (&md_ctx, EVP_md5());
  EVP_VerifyUpdate (&md_ctx, data, strlen((char*)data));
  err = EVP_VerifyFinal (&md_ctx,
			 sig_buf,
			 sig_len,
			 pkey);
  if (err != 1) {  ERR_print_errors_fp (stderr);    exit (1);  }
  EVP_PKEY_free (pkey);
  printf ("Signature Verified Ok.\n");
}





@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@
