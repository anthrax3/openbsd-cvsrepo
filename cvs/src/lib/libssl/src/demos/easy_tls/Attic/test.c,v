head	1.6;
access;
symbols
	butholakala:1.5
	openssl_1_0_1_g:1.1.1.1
	OPENBSD_5_5:1.4.0.16
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.12
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.10
	OPENBSD_5_3_BASE:1.4
	openssl_1_0_1_c:1.1.1.1
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	openssl_1_0_0_f:1.1.1.1
	openssl_1_0_0_e:1.1.1.1
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	openssh_1_0_0_a:1.1.1.1
	OPENBSD_4_8:1.3.0.34
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.30
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.32
	OPENBSD_4_6_BASE:1.3
	openssl_0_9_8_k:1.1.1.1
	OPENBSD_4_5:1.3.0.28
	OPENBSD_4_5_BASE:1.3
	openssl_0_9_8_j:1.1.1.1
	openssl_0_9_8_h:1.1.1.1
	pre_openssl_0_9_8h:1.3
	OPENBSD_4_4:1.3.0.26
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.24
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.22
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.20
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.18
	OPENBSD_4_0_BASE:1.3
	openssl_0_9_7j:1.1.1.1
	openssl:1.1.1
	OPENBSD_3_9:1.3.0.16
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.14
	OPENBSD_3_8_BASE:1.3
	OPENSSL_0_9_7G:1.1.1.1
	OPENBSD_3_7:1.3.0.12
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.10
	OPENBSD_3_6_BASE:1.3
	OPENSSL_0_9_7D:1.1.1.1
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.04.16.18.35.15;	author tedu;	state dead;
branches;
next	1.5;

1.5
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.10.16.31.56;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.05.22.12.11;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.18;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.06;	author markus;	state Exp;
branches;
next	;


desc
@@


1.6
log
@quoth the readme:
NOTE: Don't expect any of these programs to work with current
OpenSSL releases, or even with later SSLeay releases.
ok miod
@
text
@/* test.c */
/* $Id: test.c,v 1.5 2014/04/13 15:25:34 miod Exp $ */

#define L_PORT 9999
#define C_PORT 443

#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <unistd.h>

#include "test.h"
#include "easy-tls.h"

void
test_process_init(int fd, int client_p, void *apparg)
{
    fprintf(stderr, "test_process_init(fd = %d, client_p = %d, apparg = %p)\n", fd, client_p, apparg);
}

void
test_errflush(int child_p, char *errbuf, size_t num, void *apparg)
{
    fputs(errbuf, stderr);
}


int
main(int argc, char *argv[])
{
    int s, fd, r;
    FILE *conn_in;
    FILE *conn_out;
    char buf[256];
    SSL_CTX *ctx;
    int client_p = 0;
    int port;
    int tls = 0;
    char infobuf[TLS_INFO_SIZE + 1];

    if (argc > 1 && argv[1][0] == '-') {
	fputs("Usage: test [port]                   -- server\n"
	      "       test num.num.num.num [port]   -- client\n",
	      stderr);
	exit(1);
    }

    if (argc > 1) {
	if (strchr(argv[1], '.')) {
	    client_p = 1;
	}
    }
    
    fputs(client_p ? "Client\n" : "Server\n", stderr);
    
    {
	struct tls_create_ctx_args a = tls_create_ctx_defaultargs();
	a.client_p = client_p;
	a.certificate_file = "cert.pem";
	a.key_file = "cert.pem";
	a.ca_file = "cacerts.pem";
	
	ctx = tls_create_ctx(a, NULL);
	if (ctx == NULL)
	    exit(1);
    }
    
    s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (s == -1) {
	perror("socket");
	exit(1);
    }
    
    if (client_p) {
	struct sockaddr_in addr;
	size_t addr_len = sizeof addr;
	    
	addr.sin_family = AF_INET;
	assert(argc > 1);
	if (argc > 2)
	    sscanf(argv[2], "%d", &port);
	else
	    port = C_PORT;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = inet_addr(argv[1]);
	    
	r = connect(s, &addr, addr_len);
	if (r != 0) {
	    perror("connect");
	    exit(1);
	}
	fd = s;
	fprintf(stderr, "Connect (fd = %d).\n", fd);
    } else {
	/* server */
	{
	    int i = 1;

	    r = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void *) &i, sizeof i);
	    if (r == -1) {
		perror("setsockopt");
		exit(1);
	    }
	}
	
	{
	    struct sockaddr_in addr;
	    size_t addr_len = sizeof addr;
	    
	    if (argc > 1)
		sscanf(argv[1], "%d", &port);
	    else
		port = L_PORT;
	    addr.sin_family = AF_INET;
	    addr.sin_port = htons(port);
	    addr.sin_addr.s_addr = INADDR_ANY;
	    
	    r = bind(s, &addr, addr_len);
	    if (r != 0) {
		perror("bind");
		exit(1);
	    }
	}
    
	r = listen(s, 1);
	if (r == -1) {
	    perror("listen");
	    exit(1);
	}

	fprintf(stderr, "Listening at port %i.\n", port);
	
	fd = accept(s, NULL, 0);
	if (fd == -1) {
	    perror("accept");
	    exit(1);
	}
	
	fprintf(stderr, "Accept (fd = %d).\n", fd);
    }

    conn_in = fdopen(fd, "r");
    if (conn_in == NULL) {
	perror("fdopen");
	exit(1);
    }
    conn_out = fdopen(fd, "w");
    if (conn_out == NULL) {
	perror("fdopen");
	exit(1);
    }

    setvbuf(conn_in, NULL, _IOLBF, 256);
    setvbuf(conn_out, NULL, _IOLBF, 256);
	
    while (fgets(buf, sizeof buf, stdin) != NULL) {
	if (buf[0] == 'W') {
	    fprintf(conn_out, "%.*s\r\n", (int)(strlen(buf + 1) - 1), buf + 1);
	    fprintf(stderr, ">>> %.*s\n", (int)(strlen(buf + 1) - 1), buf + 1);
	} else if (buf[0] == 'C') {
	    fprintf(stderr, "Closing.\n");
	    fclose(conn_in);
	    fclose(conn_out);
	    exit(0);
	} else if (buf[0] == 'R') {
	    int lines = 0;

	    sscanf(buf + 1, "%d", &lines);
	    do {
		if (fgets(buf, sizeof buf, conn_in) == NULL) {
		    if (ferror(conn_in)) {
			fprintf(stderr, "ERROR\n");
			exit(1);
		    }
		    fprintf(stderr, "CLOSED\n");
		    return 0;
		}
		fprintf(stderr, "<<< %s", buf);
	    } while (--lines > 0);
	} else if (buf[0] == 'T') {
	    int infofd;

	    tls++;
	    {
		struct tls_start_proxy_args a = tls_start_proxy_defaultargs();
		a.fd = fd;
		a.client_p = client_p;
		a.ctx = ctx;
		a.infofd = &infofd;
		r = tls_start_proxy(a, NULL);
	    }
	    assert(r != 1);
	    if (r != 0) {
		fprintf(stderr, "tls_start_proxy failed: %d\n", r);
		switch (r) {
		case -1:
		    fputs("socketpair", stderr); break;
		case 2:
		    fputs("FD_SETSIZE exceeded", stderr); break;
		case -3:
		    fputs("pipe", stderr); break;
		case -4:
		    fputs("fork", stderr); break;
		case -5:
		    fputs("dup2", stderr); break;
		default:
		    fputs("?", stderr);
		}
		if (r < 0)
		    perror("");
		else
		    fputc('\n', stderr);
		exit(1);
	    }
	    
	    r = read(infofd, infobuf, sizeof infobuf - 1);
	    if (r > 0) {
		const char *info = infobuf;
		const char *eol;
		
		infobuf[r] = '\0';
		while ((eol = strchr(info, '\n')) != NULL) {
		    fprintf(stderr, "+++ `%.*s'\n", eol - info, info);
		    info = eol+1;
		}
		close (infofd);
	    }
	} else {
	    fprintf(stderr, "W...  write line to network\n"
		    "R[n]  read line (n lines) from network\n"
		    "C     close\n"
		    "T     start %sTLS proxy\n", tls ? "another " : "");
	}
    }
    return 0;
}
@


1.5
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d2 1
a2 1
/* $Id: test.c,v 1.1 2001/09/17 19:06:59 bodo Exp $ */
@


1.4
log
@resolve conflicts, fix local changes
@
text
@@


1.3
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d2 1
a2 1
/* $Id: test.c,v 1.1.1.1 2002/09/05 12:51:06 markus Exp $ */
@


1.2
log
@merge with 0.9.7-beta1
@
text
@@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d2 1
a2 1
/* $Id: test.c,v 1.1.1.1 2002/05/11 15:54:02 beck Exp $ */
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d2 1
a2 1
/* $Id: test.c,v 1.1 2001/09/17 19:06:59 bodo Exp $ */
@

