head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.12
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	openssl_1_0_1_c:1.1.1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	openssl_1_0_0_f:1.1.1.6
	openssl_1_0_0_e:1.1.1.5
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	openssh_1_0_0_a:1.1.1.4
	OPENBSD_4_8:1.3.0.8
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	openssl_0_9_8_k:1.1.1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	openssl_0_9_8_j:1.1.1.3
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.2
	OPENBSD_4_4:1.2.0.14
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.12
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.10
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.1.0.12
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.10
	OPENBSD_3_6_BASE:1.1
	OPENSSL_0_9_7D:1.1.1.1
	OPENBSD_3_5:1.1.0.8
	OPENBSD_3_5_BASE:1.1
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.1.0.6
	OPENBSD_3_4_BASE:1.1
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2014.04.13.15.25.26;	author miod;	state dead;
branches;
next	1.6;

1.6
date	2012.01.05.23.01.38;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.01.22.58.45;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.29.05.39.15;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.52;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.05.37.32;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.53;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.18;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2011.11.03.02.32.23;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.01.05.22.59.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@$! MKSHARED.COM -- Create shareable images.
$!
$! P1: "64" for 64-bit pointers.
$!
$! P2: Zlib object library path (optional).
$!
$! Input:	[.UTIL]LIBEAY.NUM,[.xxx.EXE.CRYPTO]SSL_LIBCRYPTO[32].OLB
$!		[.UTIL]SSLEAY.NUM,[.xxx.EXE.SSL]SSL_LIBSSL[32].OLB
$!		[.CRYPTO.xxx]OPENSSLCONF.H
$! Output:	[.xxx.EXE.CRYPTO]SSL_LIBCRYPTO_SHR[32].OPT,.MAP,.EXE
$!		[.xxx.EXE.SSL]SSL_LIBSSL_SRH[32].OPT,.MAP,.EXE
$!
$! So far, tests have only been made on VMS for Alpha.  VAX will come in time.
$! ===========================================================================
$!
$! Announce/identify.
$!
$ proc = f$environment( "procedure")
$ write sys$output "@@@@@@ "+ -
   f$parse( proc, , , "name")+ f$parse( proc, , , "type")
$!
$! Save the original default device:[directory].
$!
$ def_orig = f$environment( "default")
$ on error then goto tidy
$ on control_c then goto tidy
$!
$! SET DEFAULT to the main kit directory.
$!
$ proc = f$environment("procedure")
$ proc = f$parse( "A.;", proc)- "A.;"
$ set default 'proc'
$ set default [-]
$!
$! ----- Prepare info for processing: version number and file info
$ gosub read_version_info
$ if libver .eqs. ""
$ then
$   write sys$error "ERROR: Couldn't find any library version info..."
$   go to tidy:
$ endif
$
$ if (f$getsyi("cpu") .lt. 128)
$ then
$   arch_vax = 1
$   arch = "VAX"
$ else
$   arch_vax = 0
$   arch = f$edit( f$getsyi( "ARCH_NAME"), "UPCASE")
$   if (arch .eqs. "") then arch = "UNK"
$ endif
$!
$ archd = arch
$ lib32 = "32"
$ shr = "SHR32"
$!
$ if (p1 .nes. "")
$ then
$   if (p1 .eqs. "64")
$   then
$     archd = arch+ "_64"
$     lib32 = ""
$     shr = "SHR"
$   else
$     if (p1 .nes. "32")
$     then
$       write sys$output "Second argument invalid."
$       write sys$output "It should be "32", "64", or nothing."
$       exit
$     endif
$   endif
$ endif
$!
$! ----- Prepare info for processing: disabled algorithms info
$ gosub read_disabled_algorithms_info
$!
$ ZLIB = p2
$ zlib_lib = ""
$ if (ZLIB .nes. "")
$ then
$   file2 = f$parse( ZLIB, "libz.olb", , , "syntax_only")
$   if (f$search( file2) .eqs. "")
$   then
$     write sys$output ""
$     write sys$output "The Option ", ZLIB, " Is Invalid."
$     write sys$output "    Can't find library: ''file2'"
$     write sys$output ""
$     goto tidy
$   endif
$   zlib_lib = ", ''file2' /library"
$ endif
$!
$ if (arch_vax)
$ then
$   libtit = "CRYPTO_TRANSFER_VECTOR"
$   libid  = "Crypto"
$   libnum = "[.UTIL]LIBEAY.NUM"
$   libdir = "[.''ARCHD'.EXE.CRYPTO]"
$   libmar = "''libdir'SSL_LIBCRYPTO_''shr'.MAR"
$   libolb = "''libdir'SSL_LIBCRYPTO''lib32'.OLB"
$   libopt = "''libdir'SSL_LIBCRYPTO_''shr'.OPT"
$   libobj = "''libdir'SSL_LIBCRYPTO_''shr'.OBJ"
$   libmap = "''libdir'SSL_LIBCRYPTO_''shr'.MAP"
$   libgoal= "''libdir'SSL_LIBCRYPTO_''shr'.EXE"
$   libref = ""
$   libvec = "LIBCRYPTO"
$   if f$search( libolb) .nes. "" then gosub create_vax_shr
$   libtit = "SSL_TRANSFER_VECTOR"
$   libid  = "SSL"
$   libnum = "[.UTIL]SSLEAY.NUM"
$   libdir = "[.''ARCHD'.EXE.SSL]"
$   libmar = "''libdir'SSL_LIBSSL_''shr'.MAR"
$   libolb = "''libdir'SSL_LIBSSL''lib32'.OLB"
$   libopt = "''libdir'SSL_LIBSSL_''shr'.OPT"
$   libobj = "''libdir'SSL_LIBSSL_''shr'.OBJ"
$   libmap = "''libdir'SSL_LIBSSL_''shr'.MAP"
$   libgoal= "''libdir'SSL_LIBSSL_''shr'.EXE"
$   libref = "[.''ARCHD'.EXE.CRYPTO]SSL_LIBCRYPTO_''shr'.EXE"
$   libvec = "LIBSSL"
$   if f$search( libolb) .nes. "" then gosub create_vax_shr
$ else
$   libid  = "Crypto"
$   libnum = "[.UTIL]LIBEAY.NUM"
$   libdir = "[.''ARCHD'.EXE.CRYPTO]"
$   libolb = "''libdir'SSL_LIBCRYPTO''lib32'.OLB"
$   libopt = "''libdir'SSL_LIBCRYPTO_''shr'.OPT"
$   libmap = "''libdir'SSL_LIBCRYPTO_''shr'.MAP"
$   libgoal= "''libdir'SSL_LIBCRYPTO_''shr'.EXE"
$   libref = ""
$   if f$search( libolb) .nes. "" then gosub create_nonvax_shr
$   libid  = "SSL"
$   libnum = "[.UTIL]SSLEAY.NUM"
$   libdir = "[.''ARCHD'.EXE.SSL]"
$   libolb = "''libdir'SSL_LIBSSL''lib32'.OLB"
$   libopt = "''libdir'SSL_LIBSSL_''shr'.OPT"
$   libmap = "''libdir'SSL_LIBSSL_''shr'.MAP"
$   libgoal= "''libdir'SSL_LIBSSL_''shr'.EXE"
$   libref = "[.''ARCHD'.EXE.CRYPTO]SSL_LIBCRYPTO_''shr'.EXE"
$   if f$search( libolb) .nes. "" then gosub create_nonvax_shr
$ endif
$!
$ tidy:
$!
$! Close any open files.
$!
$ if (f$trnlnm( "libnum", "LNM$PROCESS", 0, "SUPERVISOR") .nes. "") then -
   close libnum
$!
$ if (f$trnlnm( "mar", "LNM$PROCESS", 0, "SUPERVISOR") .nes. "") then -
   close mar
$!
$ if (f$trnlnm( "opt", "LNM$PROCESS", 0, "SUPERVISOR") .nes. "") then -
   close opt
$!
$ if (f$trnlnm( "vf", "LNM$PROCESS", 0, "SUPERVISOR") .nes. "") then -
   close vf
$!
$! Restore the original default device:[directory].
$!
$ set default 'def_orig'
$ exit
$
$! ----- Subroutines to build the shareable libraries
$! For each supported architecture, there's a main shareable library
$! creator, which is called from the main code above.
$! The creator will define a number of variables to tell the next levels of
$! subroutines what routines to use to write to the option files, call the
$! main processor, read_func_num, and when that is done, it will write version
$! data at the end of the .opt file, close it, and link the library.
$!
$! read_func_num reads through a .num file and calls the writer routine for
$! each line.  It's also responsible for checking that order is properly kept
$! in the .num file, check that each line applies to VMS and the architecture,
$! and to fill in "holes" with dummy entries.
$!
$! The creator routines depend on the following variables:
$! libnum	The name of the .num file to use as input
$! libolb	The name of the object library to build from
$! libid	The identification string of the shareable library
$! libopt	The name of the .opt file to write
$! libtit	The title of the assembler transfer vector file (VAX only)
$! libmar	The name of the assembler transfer vector file (VAX only)
$! libmap	The name of the map file to write
$! libgoal	The name of the shareable library to write
$! libref	The name of a shareable library to link in
$!
$! read_func_num depends on the following variables from the creator:
$! libwriter	The name of the writer routine to call for each .num file line
$! -----
$
$! ----- Subroutines for non-VAX
$! -----
$! The creator routine
$ create_nonvax_shr:
$   open /write opt 'libopt'
$   write opt "identification=""",libid," ",libverstr,""""
$   write opt libolb, " /library"
$   if libref .nes. "" then write opt libref,"/SHARE"
$   write opt "SYMBOL_VECTOR=(-"
$   libfirstentry := true
$   libwrch   := opt
$   libwriter := write_nonvax_transfer_entry
$   textcount = 0
$   gosub read_func_num
$   write opt ")"
$   write opt "GSMATCH=",libvmatch,",",libver
$   close opt
$   link /map = 'libmap' /full /share = 'libgoal' 'libopt' /options -
     'zlib_lib'
$   return
$
$! The record writer routine
$ write_nonvax_transfer_entry:
$   if libentry .eqs. ".dummy" then return
$   if info_kind .eqs. "VARIABLE"
$   then
$     pr:=DATA
$   else
$     pr:=PROCEDURE
$   endif
$   textcount_this = f$length(pr) + f$length(libentry) + 5
$   if textcount + textcount_this .gt. 1024
$   then
$     write opt ")"
$     write opt "SYMBOL_VECTOR=(-"
$     textcount = 16
$     libfirstentry := true
$   endif
$   if libfirstentry
$   then
$     write 'libwrch' "    ",libentry,"=",pr," -"
$   else
$     write 'libwrch' "    ,",libentry,"=",pr," -"
$   endif
$   libfirstentry := false
$   textcount = textcount + textcount_this
$   return
$
$! ----- Subroutines for VAX
$! -----
$! The creator routine
$ create_vax_shr:
$   open /write mar 'libmar'
$   type sys$input:/out=mar:
;
; Transfer vector for VAX shareable image
;
$   write mar "	.TITLE ",libtit
$   write mar "	.IDENT /",libid,"/"
$   type sys$input:/out=mar:
;
; Define macro to assist in building transfer vector entries.  Each entry
; should take no more than 8 bytes.
;
	.MACRO FTRANSFER_ENTRY routine
	.ALIGN QUAD
	.TRANSFER routine
	.MASK	routine
	JMP	routine+2
	.ENDM FTRANSFER_ENTRY
;
; Place entries in own program section.
;
$   write mar "	.PSECT $$",libvec,",QUAD,PIC,USR,CON,REL,LCL,SHR,EXE,RD,NOWRT"
$   write mar libvec,"_xfer:"
$   libwrch   := mar
$   libwriter := write_vax_ftransfer_entry
$   gosub read_func_num
$   type sys$input:/out=mar:
;
; Allocate extra storage at end of vector to allow for expansion.
;
$   write mar "	.BLKB 32768-<.-",libvec,"_xfer>	; 64 pages total."
$!   libwriter := write_vax_vtransfer_entry
$!   gosub read_func_num
$   write mar "	.END"
$   close mar
$   open /write opt 'libopt'
$   write opt "identification=""",libid," ",libverstr,""""
$   write opt libobj
$   write opt libolb, " /library"
$   if libref .nes. "" then write opt libref,"/SHARE"
$   type sys$input:/out=opt:
!
! Ensure transfer vector is at beginning of image
!
CLUSTER=FIRST
$   write opt "COLLECT=FIRST,$$",libvec
$   write opt "GSMATCH=",libvmatch,",",libver
$   type sys$input:/out=opt:
!
! make psects nonshareable so image can be installed.
!
PSECT_ATTR=$CHAR_STRING_CONSTANTS,NOWRT
$   libwrch   := opt
$   libwriter := write_vax_psect_attr
$   gosub read_func_num
$   close opt
$   macro/obj='libobj' 'libmar'
$   link /map = 'libmap' /full /share = 'libgoal' 'libopt' /options -
     'zlib_lib'
$   return
$
$! The record writer routine for VAX functions
$ write_vax_ftransfer_entry:
$   if info_kind .nes. "FUNCTION" then return
$   if libentry .eqs ".dummy"
$   then
$     write 'libwrch' "	.BLKB 8" ! Dummy is zeroes...
$   else
$     write 'libwrch' "	FTRANSFER_ENTRY ",libentry
$   endif
$   return
$! The record writer routine for VAX variables (should never happen!)
$ write_vax_psect_attr:
$   if info_kind .nes. "VARIABLE" then return
$   if libentry .eqs ".dummy" then return
$   write 'libwrch' "PSECT_ATTR=",libentry,",NOSHR"
$   return
$
$! ----- Common subroutines
$! -----
$! The .num file reader.  This one has great responsibility.
$ read_func_num:
$   open /read libnum 'libnum'
$   goto read_nums
$
$ read_nums:
$   libentrynum=0
$   liblastentry:=false
$   entrycount=0
$   loop:
$     read /end=loop_end /err=loop_end libnum line
$     lin = f$edit( line, "COMPRESS,TRIM")
$!    Skip a "#" comment line.
$     if (f$extract( 0, 1, lin) .eqs. "#") then goto loop
$     entrynum = f$int(f$element( 1, " ", lin))
$     entryinfo = f$element( 2, " ", lin)
$     curentry = f$element( 0, " ", lin)
$     info_exist = f$element( 0, ":", entryinfo)
$     info_platforms = ","+ f$element(1, ":", entryinfo)+ ","
$     info_kind = f$element( 2, ":", entryinfo)
$     info_algorithms = ","+ f$element( 3, ":", entryinfo)+ ","
$     if info_exist .eqs. "NOEXIST" then goto loop
$     truesum = 0
$     falsesum = 0
$     negatives = 1
$     plat_i = 0
$     loop1:
$       plat_entry = f$element( plat_i, ",", info_platforms)
$       plat_i = plat_i + 1
$       if plat_entry .eqs. "" then goto loop1
$       if plat_entry .nes. ","
$       then
$         if f$extract(0,1,plat_entry) .nes. "!" then negatives = 0
$         if (arch_vax)
$         then
$           if plat_entry .eqs. "EXPORT_VAR_AS_FUNCTION" then -
$             truesum = truesum + 1
$           if plat_entry .eqs. "!EXPORT_VAR_AS_FUNCTION" then -
$             falsesum = falsesum + 1
$         endif
$!
$         if ((plat_entry .eqs. "VMS") .or. -
            ((plat_entry .eqs. "ZLIB") .and. (ZLIB .nes. "")) .or. -
            (arch_vax .and. (plat_entry .eqs. "VMSVAX"))) then -
            truesum = truesum + 1
$!
$         if ((plat_entry .eqs. "!VMS") .or. -
            (arch_vax .and. (plat_entry .eqs. "!VMSVAX"))) then -
            falsesum = falsesum + 1
$!
$	  goto loop1
$       endif
$     endloop1:
$!DEBUG!$     if info_platforms - "EXPORT_VAR_AS_FUNCTION" .nes. info_platforms
$!DEBUG!$     then
$!DEBUG!$       write sys$output line
$!DEBUG!$       write sys$output "        truesum = ",truesum,-
$!DEBUG!		", negatives = ",negatives,", falsesum = ",falsesum
$!DEBUG!$     endif
$     if falsesum .ne. 0 then goto loop
$     if truesum+negatives .eq. 0 then goto loop
$     alg_i = 0
$     loop2:
$       alg_entry = f$element(alg_i,",",info_algorithms)
$	alg_i = alg_i + 1
$       if alg_entry .eqs. "" then goto loop2
$       if alg_entry .nes. ","
$       then
$	  if disabled_algorithms - ("," + alg_entry + ",") .nes disabled_algorithms then goto loop
$         if f$trnlnm("OPENSSL_NO_"+alg_entry) .nes. "" then goto loop
$	  goto loop2
$       endif
$     endloop2:
$     if info_platforms - "EXPORT_VAR_AS_FUNCTION" .nes. info_platforms
$     then
$!DEBUG!$     write sys$output curentry," ; ",entrynum," ; ",entryinfo
$     endif
$   redo:
$     next:=loop
$     tolibentry=curentry
$     if libentrynum .ne. entrynum
$     then
$       entrycount=entrycount+1
$       if entrycount .lt. entrynum
$       then
$!DEBUG!$         write sys$output "Info: entrycount: ''entrycount', entrynum: ''entrynum' => 0"
$         tolibentry=".dummy"
$         next:=redo
$       endif
$       if entrycount .gt. entrynum
$       then
$         write sys$error "Decreasing library entry numbers!  Can't continue"
$         write sys$error """",line,""""
$         close libnum
$         return
$       endif
$       libentry=tolibentry
$!DEBUG!$       write sys$output entrycount," ",libentry," ",entryinfo
$       if libentry .nes. "" .and. libwriter .nes. "" then gosub 'libwriter'
$     else
$       write sys$error "Info: ""''curentry'"" is an alias for ""''libentry'"".  Overriding..."
$     endif
$     libentrynum=entrycount
$     goto 'next'
$   loop_end:
$   close libnum
$   return
$
$! The version number reader
$ read_version_info:
$   libver = ""
$   open /read vf [.CRYPTO]OPENSSLV.H
$   loop_rvi:
$     read/err=endloop_rvi/end=endloop_rvi vf rvi_line
$     if rvi_line - "SHLIB_VERSION_NUMBER """ .eqs. rvi_line then -
	goto loop_rvi
$     libverstr = f$element(1,"""",rvi_line)
$     libvmajor = f$element(0,".",libverstr)
$     libvminor = f$element(1,".",libverstr)
$     libvedit = f$element(2,".",libverstr)
$     libvpatch = f$cvui(0,8,f$extract(1,1,libvedit)+"@@")-f$cvui(0,8,"@@")
$     libvedit = f$extract(0,1,libvedit)
$     libver = f$string(f$int(libvmajor)*100)+","+-
	f$string(f$int(libvminor)*100+f$int(libvedit)*10+f$int(libvpatch))
$     if libvmajor .eqs. "0"
$     then
$       libvmatch = "EQUAL"
$     else
$       ! Starting with the 1.0 release, backward compatibility should be
$       ! kept, so switch over to the following
$       libvmatch = "LEQUAL"
$     endif
$   endloop_rvi:
$   close vf
$   return
$
$! The disabled algorithms reader
$ read_disabled_algorithms_info:
$   disabled_algorithms = ","
$   open /read cf [.CRYPTO.'ARCH']OPENSSLCONF.H
$   loop_rci:
$     read/err=endloop_rci/end=endloop_rci cf rci_line
$     rci_line = f$edit(rci_line,"TRIM,COMPRESS")
$     rci_ei = 0
$     if f$extract(0,9,rci_line) .eqs. "# define " then rci_ei = 2
$     if f$extract(0,8,rci_line) .eqs. "#define " then rci_ei = 1
$     if rci_ei .eq. 0 then goto loop_rci
$     rci_e = f$element(rci_ei," ",rci_line)
$     if f$extract(0,11,rci_e) .nes. "OPENSSL_NO_" then goto loop_rci
$     disabled_algorithms = disabled_algorithms + f$extract(11,999,rci_e) + ","
$     goto loop_rci
$   endloop_rci:
$   close cf
$   return
@


1.6
log
@OpenSSL 1.0.0f: merge
@
text
@@


1.5
log
@openssl-1.0.0e: resolve conflicts
@
text
@d9 1
d74 3
d391 1
a391 2
$         if alg_entry .eqs. "KRB5" then goto loop ! Special for now
$	  if alg_entry .eqs. "STATIC_ENGINE" then goto loop ! Special for now
d457 19
@


1.4
log
@resolve conflicts, fix local changes
@
text
@d1 1
a1 1
$! MKSHARED.COM -- script to created shareable images on VMS
d3 1
a3 2
$! No command line parameters.  This should be run at the start of the source
$! tree (the same directory where one finds INSTALL.VMS).
d5 6
a10 4
$! Input:	[.UTIL]LIBEAY.NUM,[.xxx.EXE.CRYPTO]LIBCRYPTO.OLB
$!		[.UTIL]SSLEAY.NUM,[.xxx.EXE.SSL]LIBSSL.OLB
$! Output:	[.xxx.EXE.CRYPTO]LIBCRYPTO.OPT,.MAP,.EXE
$!		[.xxx.EXE.SSL]LIBSSL.OPT,.MAP,.EXE
d14 20
a33 1
$
d39 1
a39 1
$   exit
d42 1
a42 1
$ if (f$getsyi("cpu").lt.128)
d44 2
a45 1
$     arch := VAX
d47 3
a49 2
$     arch = f$edit( f$getsyi( "ARCH_NAME"), "UPCASE")
$     if (arch .eqs. "") then arch = "UNK"
d51 39
a89 2
$
$ if arch .nes. "VAX"
d91 1
a91 1
$   arch_vax = 0
d94 7
a100 5
$   libdir = "[.''ARCH'.EXE.CRYPTO]"
$   libolb = "''libdir'LIBCRYPTO.OLB"
$   libopt = "''libdir'LIBCRYPTO.OPT"
$   libmap = "''libdir'LIBCRYPTO.MAP"
$   libgoal= "''libdir'LIBCRYPTO.EXE"
d102 3
a104 1
$   gosub create_nonvax_shr
d107 10
a116 7
$   libdir = "[.''ARCH'.EXE.SSL]"
$   libolb = "''libdir'LIBSSL.OLB"
$   libopt = "''libdir'LIBSSL.OPT"
$   libmap = "''libdir'LIBSSL.MAP"
$   libgoal= "''libdir'LIBSSL.EXE"
$   libref = "[.''ARCH'.EXE.CRYPTO]LIBCRYPTO.EXE"
$   gosub create_nonvax_shr
a117 2
$   arch_vax = 1
$   libtit = "CRYPTO_TRANSFER_VECTOR"
d120 5
a124 7
$   libdir = "[.''ARCH'.EXE.CRYPTO]"
$   libmar = "''libdir'LIBCRYPTO.MAR"
$   libolb = "''libdir'LIBCRYPTO.OLB"
$   libopt = "''libdir'LIBCRYPTO.OPT"
$   libobj = "''libdir'LIBCRYPTO.OBJ"
$   libmap = "''libdir'LIBCRYPTO.MAP"
$   libgoal= "''libdir'LIBCRYPTO.EXE"
d126 1
a126 3
$   libvec = "LIBCRYPTO"
$   gosub create_vax_shr
$   libtit = "SSL_TRANSFER_VECTOR"
d129 7
a135 10
$   libdir = "[.''ARCH'.EXE.SSL]"
$   libmar = "''libdir'LIBSSL.MAR"
$   libolb = "''libdir'LIBSSL.OLB"
$   libopt = "''libdir'LIBSSL.OPT"
$   libobj = "''libdir'LIBSSL.OBJ"
$   libmap = "''libdir'LIBSSL.MAP"
$   libgoal= "''libdir'LIBSSL.EXE"
$   libref = "[.''ARCH'.EXE.CRYPTO]LIBCRYPTO.EXE"
$   libvec = "LIBSSL"
$   gosub create_vax_shr
d137 20
d159 1
a159 1
$! ----- Soubroutines to build the shareable libraries
d191 1
a191 1
$   open/write opt 'libopt'
d193 1
a193 1
$   write opt libolb,"/lib"
d204 2
a205 1
$   link/map='libmap'/full/share='libgoal' 'libopt'/option
d239 1
a239 1
$   open/write mar 'libmar'
d274 1
a274 1
$   open/write opt 'libopt'
d277 1
a277 1
$   write opt libolb,"/lib"
d296 2
a297 1
$   link/map='libmap'/full/share='libgoal' 'libopt'/option
d319 1
a319 1
$! The .num file reader.  This one has great responsability.
d321 1
a321 1
$   open libnum 'libnum'
d329 11
a339 8
$     read/end=loop_end/err=loop_end libnum line
$     entrynum=f$int(f$element(1," ",f$edit(line,"COMPRESS,TRIM")))
$     entryinfo=f$element(2," ",f$edit(line,"COMPRESS,TRIM"))
$     curentry=f$element(0," ",f$edit(line,"COMPRESS,TRIM"))
$     info_exist=f$element(0,":",entryinfo)
$     info_platforms=","+f$element(1,":",entryinfo)+","
$     info_kind=f$element(2,":",entryinfo)
$     info_algorithms=","+f$element(3,":",entryinfo)+","
d346 1
a346 1
$       plat_entry = f$element(plat_i,",",info_platforms)
d352 1
a352 1
$         if f$getsyi("CPU") .lt. 128
d361 1
d431 1
a431 1
$   open/read vf [.CRYPTO]OPENSSLV.H
@


1.3
log
@resolve conflicts
@
text
@d6 4
a9 4
$! Input:	[.UTIL]LIBEAY.NUM,[.AXP.EXE.CRYPTO]LIBCRYPTO.OLB
$!		[.UTIL]SSLEAY.NUM,[.AXP.EXE.SSL]LIBSSL.OLB
$! Output:	[.AXP.EXE.CRYPTO]LIBCRYPTO.OPT,.MAP,.EXE
$!		[.AXP.EXE.SSL]LIBSSL.OPT,.MAP,.EXE
d22 1
a22 1
$ if f$getsyi("CPU") .ge. 128
d24 9
d35 1
a35 1
$   libdir = "[.AXP.EXE.CRYPTO]"
d41 1
a41 1
$   gosub create_axp_shr
d44 1
a44 1
$   libdir = "[.AXP.EXE.SSL]"
d49 2
a50 2
$   libref = "[.AXP.EXE.CRYPTO]LIBCRYPTO.EXE"
$   gosub create_axp_shr
d52 1
d56 1
a56 1
$   libdir = "[.VAX.EXE.CRYPTO]"
d69 1
a69 1
$   libdir = "[.VAX.EXE.SSL]"
d76 1
a76 1
$   libref = "[.VAX.EXE.CRYPTO]LIBCRYPTO.EXE"
d82 3
a84 3
$! ----- Soubroutines to actually build the shareable libraries
$! The way things work, there's a main shareable library creator for each
$! supported architecture, which is called from the main code above.
d110 1
a110 1
$! ----- Subroutines for AXP
d113 1
a113 1
$ create_axp_shr:
d121 1
a121 1
$   libwriter := write_axp_transfer_entry
d131 1
a131 1
$ write_axp_transfer_entry:
d157 1
a157 1
$! ----- Subroutines for AXP
d277 9
a285 2
$         if plat_entry .eqs. "VMS" then truesum = truesum + 1
$         if plat_entry .eqs. "!VMS" then falsesum = falsesum + 1
@


1.2
log
@resolve conflicts
@
text
@a268 8
$         if f$trnlnm("OPENSSL_FIPS") .nes. ""
$         then
$           if plat_entry .eqs. "OPENSSL_FIPS" then truesum = truesum + 1
$           if plat_entry .eqs. "!OPENSSL_FIPS" then falsesum = falsesum + 1
$         else
$           if plat_entry .eqs. "OPENSSL_FIPS" then falsesum = falsesum + 1
$           if plat_entry .eqs. "!OPENSSL_FIPS" then truesum = truesum + 1
$         endif
d288 1
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d269 8
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a268 8
$         if f$trnlnm("OPENSSL_FIPS") .nes. ""
$         then
$           if plat_entry .eqs. "OPENSSL_FIPS" then truesum = truesum + 1
$           if plat_entry .eqs. "!OPENSSL_FIPS" then falsesum = falsesum + 1
$         else
$           if plat_entry .eqs. "OPENSSL_FIPS" then falsesum = falsesum + 1
$           if plat_entry .eqs. "!OPENSSL_FIPS" then truesum = truesum + 1
$         endif
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d269 8
a295 1
$	  if alg_entry .eqs. "STATIC_ENGINE" then goto loop ! Special for now
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@d6 4
a9 4
$! Input:	[.UTIL]LIBEAY.NUM,[.xxx.EXE.CRYPTO]LIBCRYPTO.OLB
$!		[.UTIL]SSLEAY.NUM,[.xxx.EXE.SSL]LIBSSL.OLB
$! Output:	[.xxx.EXE.CRYPTO]LIBCRYPTO.OPT,.MAP,.EXE
$!		[.xxx.EXE.SSL]LIBSSL.OPT,.MAP,.EXE
d22 1
a22 1
$ if (f$getsyi("cpu").lt.128)
a23 9
$     arch := VAX
$ else
$     arch = f$edit( f$getsyi( "ARCH_NAME"), "UPCASE")
$     if (arch .eqs. "") then arch = "UNK"
$ endif
$
$ if arch .nes. "VAX"
$ then
$   arch_vax = 0
d26 1
a26 1
$   libdir = "[.''ARCH'.EXE.CRYPTO]"
d32 1
a32 1
$   gosub create_nonvax_shr
d35 1
a35 1
$   libdir = "[.''ARCH'.EXE.SSL]"
d40 2
a41 2
$   libref = "[.''ARCH'.EXE.CRYPTO]LIBCRYPTO.EXE"
$   gosub create_nonvax_shr
a42 1
$   arch_vax = 1
d46 1
a46 1
$   libdir = "[.''ARCH'.EXE.CRYPTO]"
d59 1
a59 1
$   libdir = "[.''ARCH'.EXE.SSL]"
d66 1
a66 1
$   libref = "[.''ARCH'.EXE.CRYPTO]LIBCRYPTO.EXE"
d72 3
a74 3
$! ----- Soubroutines to build the shareable libraries
$! For each supported architecture, there's a main shareable library
$! creator, which is called from the main code above.
d100 1
a100 1
$! ----- Subroutines for non-VAX
d103 1
a103 1
$ create_nonvax_shr:
d111 1
a111 1
$   libwriter := write_nonvax_transfer_entry
d121 1
a121 1
$ write_nonvax_transfer_entry:
d147 1
a147 1
$! ----- Subroutines for VAX
d267 2
a268 9
$!
$         if ((plat_entry .eqs. "VMS") .or. -
            (arch_vax .and. (plat_entry .eqs. "VMSVAX"))) then -
            truesum = truesum + 1
$!
$         if ((plat_entry .eqs. "!VMS") .or. -
            (arch_vax .and. (plat_entry .eqs. "!VMSVAX"))) then -
            falsesum = falsesum + 1
$!
@


1.1.1.5
log
@import OpenSSL 1.0.0e
@
text
@d1 1
a1 1
$! MKSHARED.COM -- Create shareable images.
d3 2
a4 1
$! P1: "64" for 64-bit pointers.
d6 4
a9 6
$! P2: Zlib object library path (optional).
$!
$! Input:	[.UTIL]LIBEAY.NUM,[.xxx.EXE.CRYPTO]SSL_LIBCRYPTO[32].OLB
$!		[.UTIL]SSLEAY.NUM,[.xxx.EXE.SSL]SSL_LIBSSL[32].OLB
$! Output:	[.xxx.EXE.CRYPTO]SSL_LIBCRYPTO_SHR[32].OPT,.MAP,.EXE
$!		[.xxx.EXE.SSL]SSL_LIBSSL_SRH[32].OPT,.MAP,.EXE
d13 1
a13 20
$!
$! Announce/identify.
$!
$ proc = f$environment( "procedure")
$ write sys$output "@@@@@@ "+ -
   f$parse( proc, , , "name")+ f$parse( proc, , , "type")
$!
$! Save the original default device:[directory].
$!
$ def_orig = f$environment( "default")
$ on error then goto tidy
$ on control_c then goto tidy
$!
$! SET DEFAULT to the main kit directory.
$!
$ proc = f$environment("procedure")
$ proc = f$parse( "A.;", proc)- "A.;"
$ set default 'proc'
$ set default [-]
$!
d19 1
a19 1
$   go to tidy:
d22 1
a22 1
$ if (f$getsyi("cpu") .lt. 128)
d24 1
a24 2
$   arch_vax = 1
$   arch = "VAX"
d26 2
a27 3
$   arch_vax = 0
$   arch = f$edit( f$getsyi( "ARCH_NAME"), "UPCASE")
$   if (arch .eqs. "") then arch = "UNK"
d29 2
a30 6
$!
$ archd = arch
$ lib32 = "32"
$ shr = "SHR32"
$!
$ if (p1 .nes. "")
d32 1
a32 34
$   if (p1 .eqs. "64")
$   then
$     archd = arch+ "_64"
$     lib32 = ""
$     shr = "SHR"
$   else
$     if (p1 .nes. "32")
$     then
$       write sys$output "Second argument invalid."
$       write sys$output "It should be "32", "64", or nothing."
$       exit
$     endif
$   endif
$ endif
$!
$ ZLIB = p2
$ zlib_lib = ""
$ if (ZLIB .nes. "")
$ then
$   file2 = f$parse( ZLIB, "libz.olb", , , "syntax_only")
$   if (f$search( file2) .eqs. "")
$   then
$     write sys$output ""
$     write sys$output "The Option ", ZLIB, " Is Invalid."
$     write sys$output "    Can't find library: ''file2'"
$     write sys$output ""
$     goto tidy
$   endif
$   zlib_lib = ", ''file2' /library"
$ endif
$!
$ if (arch_vax)
$ then
$   libtit = "CRYPTO_TRANSFER_VECTOR"
d35 5
a39 7
$   libdir = "[.''ARCHD'.EXE.CRYPTO]"
$   libmar = "''libdir'SSL_LIBCRYPTO_''shr'.MAR"
$   libolb = "''libdir'SSL_LIBCRYPTO''lib32'.OLB"
$   libopt = "''libdir'SSL_LIBCRYPTO_''shr'.OPT"
$   libobj = "''libdir'SSL_LIBCRYPTO_''shr'.OBJ"
$   libmap = "''libdir'SSL_LIBCRYPTO_''shr'.MAP"
$   libgoal= "''libdir'SSL_LIBCRYPTO_''shr'.EXE"
d41 1
a41 3
$   libvec = "LIBCRYPTO"
$   if f$search( libolb) .nes. "" then gosub create_vax_shr
$   libtit = "SSL_TRANSFER_VECTOR"
d44 7
a50 10
$   libdir = "[.''ARCHD'.EXE.SSL]"
$   libmar = "''libdir'SSL_LIBSSL_''shr'.MAR"
$   libolb = "''libdir'SSL_LIBSSL''lib32'.OLB"
$   libopt = "''libdir'SSL_LIBSSL_''shr'.OPT"
$   libobj = "''libdir'SSL_LIBSSL_''shr'.OBJ"
$   libmap = "''libdir'SSL_LIBSSL_''shr'.MAP"
$   libgoal= "''libdir'SSL_LIBSSL_''shr'.EXE"
$   libref = "[.''ARCHD'.EXE.CRYPTO]SSL_LIBCRYPTO_''shr'.EXE"
$   libvec = "LIBSSL"
$   if f$search( libolb) .nes. "" then gosub create_vax_shr
d52 2
d56 7
a62 5
$   libdir = "[.''ARCHD'.EXE.CRYPTO]"
$   libolb = "''libdir'SSL_LIBCRYPTO''lib32'.OLB"
$   libopt = "''libdir'SSL_LIBCRYPTO_''shr'.OPT"
$   libmap = "''libdir'SSL_LIBCRYPTO_''shr'.MAP"
$   libgoal= "''libdir'SSL_LIBCRYPTO_''shr'.EXE"
d64 3
a66 1
$   if f$search( libolb) .nes. "" then gosub create_nonvax_shr
d69 10
a78 7
$   libdir = "[.''ARCHD'.EXE.SSL]"
$   libolb = "''libdir'SSL_LIBSSL''lib32'.OLB"
$   libopt = "''libdir'SSL_LIBSSL_''shr'.OPT"
$   libmap = "''libdir'SSL_LIBSSL_''shr'.MAP"
$   libgoal= "''libdir'SSL_LIBSSL_''shr'.EXE"
$   libref = "[.''ARCHD'.EXE.CRYPTO]SSL_LIBCRYPTO_''shr'.EXE"
$   if f$search( libolb) .nes. "" then gosub create_nonvax_shr
a79 20
$!
$ tidy:
$!
$! Close any open files.
$!
$ if (f$trnlnm( "libnum", "LNM$PROCESS", 0, "SUPERVISOR") .nes. "") then -
   close libnum
$!
$ if (f$trnlnm( "mar", "LNM$PROCESS", 0, "SUPERVISOR") .nes. "") then -
   close mar
$!
$ if (f$trnlnm( "opt", "LNM$PROCESS", 0, "SUPERVISOR") .nes. "") then -
   close opt
$!
$ if (f$trnlnm( "vf", "LNM$PROCESS", 0, "SUPERVISOR") .nes. "") then -
   close vf
$!
$! Restore the original default device:[directory].
$!
$ set default 'def_orig'
d82 1
a82 1
$! ----- Subroutines to build the shareable libraries
d114 1
a114 1
$   open /write opt 'libopt'
d116 1
a116 1
$   write opt libolb, " /library"
d127 1
a127 2
$   link /map = 'libmap' /full /share = 'libgoal' 'libopt' /options -
     'zlib_lib'
d161 1
a161 1
$   open /write mar 'libmar'
d196 1
a196 1
$   open /write opt 'libopt'
d199 1
a199 1
$   write opt libolb, " /library"
d218 1
a218 2
$   link /map = 'libmap' /full /share = 'libgoal' 'libopt' /options -
     'zlib_lib'
d240 1
a240 1
$! The .num file reader.  This one has great responsibility.
d242 1
a242 1
$   open /read libnum 'libnum'
d250 8
a257 11
$     read /end=loop_end /err=loop_end libnum line
$     lin = f$edit( line, "COMPRESS,TRIM")
$!    Skip a "#" comment line.
$     if (f$extract( 0, 1, lin) .eqs. "#") then goto loop
$     entrynum = f$int(f$element( 1, " ", lin))
$     entryinfo = f$element( 2, " ", lin)
$     curentry = f$element( 0, " ", lin)
$     info_exist = f$element( 0, ":", entryinfo)
$     info_platforms = ","+ f$element(1, ":", entryinfo)+ ","
$     info_kind = f$element( 2, ":", entryinfo)
$     info_algorithms = ","+ f$element( 3, ":", entryinfo)+ ","
d264 1
a264 1
$       plat_entry = f$element( plat_i, ",", info_platforms)
d270 1
a270 1
$         if (arch_vax)
a278 1
            ((plat_entry .eqs. "ZLIB") .and. (ZLIB .nes. "")) .or. -
d348 1
a348 1
$   open /read vf [.CRYPTO]OPENSSLV.H
@


1.1.1.6
log
@OpenSSL 1.0.0f: import upstream source
@
text
@a8 1
$!		[.CRYPTO.xxx]OPENSSLCONF.H
a72 3
$! ----- Prepare info for processing: disabled algorithms info
$ gosub read_disabled_algorithms_info
$!
d387 2
a388 1
$	  if disabled_algorithms - ("," + alg_entry + ",") .nes disabled_algorithms then goto loop
a453 19
$   return
$
$! The disabled algorithms reader
$ read_disabled_algorithms_info:
$   disabled_algorithms = ","
$   open /read cf [.CRYPTO.'ARCH']OPENSSLCONF.H
$   loop_rci:
$     read/err=endloop_rci/end=endloop_rci cf rci_line
$     rci_line = f$edit(rci_line,"TRIM,COMPRESS")
$     rci_ei = 0
$     if f$extract(0,9,rci_line) .eqs. "# define " then rci_ei = 2
$     if f$extract(0,8,rci_line) .eqs. "#define " then rci_ei = 1
$     if rci_ei .eq. 0 then goto loop_rci
$     rci_e = f$element(rci_ei," ",rci_line)
$     if f$extract(0,11,rci_e) .nes. "OPENSSL_NO_" then goto loop_rci
$     disabled_algorithms = disabled_algorithms + f$extract(11,999,rci_e) + ","
$     goto loop_rci
$   endloop_rci:
$   close cf
@


