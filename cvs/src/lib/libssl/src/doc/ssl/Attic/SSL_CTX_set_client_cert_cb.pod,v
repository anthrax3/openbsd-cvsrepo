head	1.5;
access;
symbols
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	butholakala:1.2
	openssl_1_0_1_g:1.1.1.2
	OPENBSD_5_5:1.2.0.50
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.46
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.44
	OPENBSD_5_3_BASE:1.2
	openssl_1_0_1_c:1.1.1.2
	OPENBSD_5_2:1.2.0.40
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.42
	openssl_1_0_0_f:1.1.1.2
	openssl_1_0_0_e:1.1.1.2
	OPENBSD_5_0:1.2.0.38
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.36
	OPENBSD_4_9_BASE:1.2
	openssh_1_0_0_a:1.1.1.2
	OPENBSD_4_8:1.2.0.34
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.30
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.32
	OPENBSD_4_6_BASE:1.2
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.2.0.28
	OPENBSD_4_5_BASE:1.2
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.2
	OPENBSD_4_4:1.2.0.26
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.24
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.22
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.20
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.18
	OPENBSD_4_0_BASE:1.2
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.2.0.16
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.14
	OPENBSD_3_8_BASE:1.2
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.2.0.12
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.10
	OPENBSD_3_6_BASE:1.2
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2014.10.12.09.33.03;	author bentley;	state dead;
branches;
next	1.4;
commitid	d4OKqHtOZ8kX9T2O;

1.4
date	2014.07.11.16.18.14;	author miod;	state Exp;
branches;
next	1.3;
commitid	KFr43un1Uq8AaqNL;

1.3
date	2014.05.04.21.13.41;	author jim;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.10.16.31.56;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.19;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.21;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.43.31;	author markus;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Convert libssl manpages from pod to mdoc(7).

libcrypto has not been started yet.

ok schwarze@@ miod@@
@
text
@3=pod

=head1 NAME

SSL_CTX_set_client_cert_cb, SSL_CTX_get_client_cert_cb - handle client
certificate callback function

=head1 SYNOPSIS

 #include <openssl/ssl.h>

 void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx, int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey));
 int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL *ssl, X509 **x509, EVP_PKEY **pkey);
 int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey);

=head1 DESCRIPTION

SSL_CTX_set_client_cert_cb() sets the B<client_cert_cb()> callback, that is
called when a client certificate is requested by a server and no certificate
was yet set for the SSL object.

When B<client_cert_cb()> is NULL, no callback function is used.

SSL_CTX_get_client_cert_cb() returns a pointer to the currently set callback
function.

client_cert_cb() is the application defined callback. If it wants to
set a certificate, a certificate/private key combination must be set
using the B<x509> and B<pkey> arguments and "1" must be returned. The
certificate will be installed into B<ssl>, see the NOTES and BUGS sections.
If no certificate should be set, "0" has to be returned and no certificate
will be sent. A negative return value will suspend the handshake and the
handshake function will return immediately. L<SSL_get_error(3)|SSL_get_error(3)>
will return SSL_ERROR_WANT_X509_LOOKUP to indicate, that the handshake was
suspended. The next call to the handshake function will again lead to the call
of client_cert_cb(). It is the job of the client_cert_cb() to store information
about the state of the last call, if required to continue.

=head1 NOTES

During a handshake (or renegotiation) a server may request a certificate
from the client. A client certificate must only be sent, when the server
did send the request.

When a certificate was set using the
L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)> family of functions,
it will be sent to the server. The TLS standard requires that only a
certificate is sent, if it matches the list of acceptable CAs sent by the
server. This constraint is violated by the default behavior of the OpenSSL
library. Using the callback function it is possible to implement a proper
selection routine or to allow a user interaction to choose the certificate to
be sent.

If a callback function is defined and no certificate was yet defined for the
SSL object, the callback function will be called.
If the callback function returns a certificate, the OpenSSL library
will try to load the private key and certificate data into the SSL
object using the SSL_use_certificate() and SSL_use_private_key() functions.
Thus it will permanently install the certificate and key for this SSL
object. It will not be reset by calling L<SSL_clear(3)|SSL_clear(3)>.
If the callback returns no certificate, the OpenSSL library will not send
a certificate.

=head1 BUGS

The client_cert_cb() cannot return a complete certificate chain, it can
only return one client certificate. If the chain only has a length of 2,
the root CA certificate may be omitted according to the TLS standard and
thus a standard conforming answer can be sent to the server. For a
longer chain, the client must send the complete chain (with the option
to leave out the root CA certificate). This can only be accomplished by
either adding the intermediate CA certificates into the trusted
certificate store for the SSL_CTX object (resulting in having to add
CA certificates that otherwise maybe would not be trusted), or by adding
the chain certificates using the
L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>
function, which is only available for the SSL_CTX object as a whole and that
therefore probably can only apply for one client certificate, making
the concept of the callback function (to allow the choice from several
certificates) questionable.

Once the SSL object has been used in conjunction with the callback function,
the certificate will be set for the SSL object and will not be cleared
even when L<SSL_clear(3)|SSL_clear(3)> is being called. It is therefore
mandatory to destroy the SSL object using L<SSL_free(3)|SSL_free(3)>
and create a new one to return to the previous state.

=head1 SEE ALSO

L<ssl(3)|ssl(3)>, L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)>,
L<SSL_CTX_add_extra_chain_cert(3)|SSL_CTX_add_extra_chain_cert(3)>,
L<SSL_get_client_CA_list(3)|SSL_get_client_CA_list(3)>,
L<SSL_clear(3)|SSL_clear(3)>, L<SSL_free(3)|SSL_free(3)>

=cut
@


1.4
log
@Huge documentation update for libcrypto and libssl, mostly from Matt Caswell,
Jeff Trawick, Jean-Paul Calderone, Michal Bozon, Jeffrey Walton and Rich Salz,
via OpenSSL trunk (with some parts not applying to us, such as SSLv2 support,
at least partially removed).
@
text
@@


1.3
log
@Improve line wrapping for lines exceeding 80 chars.

ok jmc@@
@
text
@d1 1
a1 1
=pod
d33 1
a33 1
handshake function will return immediatly. L<SSL_get_error(3)|SSL_get_error(3)>
@


1.2
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d5 2
a6 1
SSL_CTX_set_client_cert_cb, SSL_CTX_get_client_cert_cb - handle client certificate callback function
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d18 4
a21 2
called when a client certificate is requested by a server.
When B<client_cert_cb()> is NULL, not callback function is used.
d30 7
a36 3
If no certificate should be set, "0" has to be returned and the default
certificate will be sent. A fatal error can be indicated by returning
a negative value, in which case the handshake will be canceled.
d44 8
a51 10
When no callback function is set, an OpenSSL client will send the certificate
that was set using the
L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)> family of functions.
The TLS standard requires that only a certificate is sent, if it matches
the list of acceptable CAs sent by the server. This constraint is
violated by the default behavior of the OpenSSL library. Using the
callback function it is possible to implement a proper selection routine
or to allow a user interaction to choose the certificate to be sent.
The callback function can obtain the list of acceptable CAs using the
L<SSL_get_client_CA_list(3)|SSL_get_client_CA_list(3)> function.
d53 2
a54 1
If a callback function is defined, the callback function will be called.
d57 5
a61 6
object using SSL_use_certificate() and SSL_use_private_key() functions.
Thus it will permanently override the certificate and key previously
installed and will not be reset by calling L<SSL_clear(3)|SSL_clear(3)>.
If the callback returns no certificate, the OpenSSL library will send
the certificate previously installed for the SSL_CTX object or the specific
certificate of the SSL object, if available.
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@d18 2
a19 4
called when a client certificate is requested by a server and no certificate
was yet set for the SSL object.

When B<client_cert_cb()> is NULL, no callback function is used.
d28 3
a30 7
If no certificate should be set, "0" has to be returned and no certificate
will be sent. A negative return value will suspend the handshake and the
handshake function will return immediatly. L<SSL_get_error(3)|SSL_get_error(3)>
will return SSL_ERROR_WANT_X509_LOOKUP to indicate, that the handshake was
suspended. The next call to the handshake function will again lead to the call
of client_cert_cb(). It is the job of the client_cert_cb() to store information
about the state of the last call, if required to continue.
d38 10
a47 8
When a certificate was set using the
L<SSL_CTX_use_certificate(3)|SSL_CTX_use_certificate(3)> family of functions,
it will be sent to the server. The TLS standard requires that only a
certificate is sent, if it matches the list of acceptable CAs sent by the
server. This constraint is violated by the default behavior of the OpenSSL
library. Using the callback function it is possible to implement a proper
selection routine or to allow a user interaction to choose the certificate to
be sent.
d49 1
a49 2
If a callback function is defined and no certificate was yet defined for the
SSL object, the callback function will be called.
d52 6
a57 5
object using the SSL_use_certificate() and SSL_use_private_key() functions.
Thus it will permanently install the certificate and key for this SSL
object. It will not be reset by calling L<SSL_clear(3)|SSL_clear(3)>.
If the callback returns no certificate, the OpenSSL library will not send
a certificate.
@


