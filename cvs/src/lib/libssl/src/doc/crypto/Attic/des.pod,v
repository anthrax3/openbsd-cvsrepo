head	1.6;
access;
symbols
	butholakala:1.5
	openssl_1_0_1_g:1.1.1.2
	OPENBSD_5_5:1.5.0.42
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.38
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.36
	OPENBSD_5_3_BASE:1.5
	openssl_1_0_1_c:1.1.1.2
	OPENBSD_5_2:1.5.0.32
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.34
	openssl_1_0_0_f:1.1.1.2
	openssl_1_0_0_e:1.1.1.2
	OPENBSD_5_0:1.5.0.30
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.28
	OPENBSD_4_9_BASE:1.5
	openssh_1_0_0_a:1.1.1.2
	OPENBSD_4_8:1.5.0.26
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.22
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.24
	OPENBSD_4_6_BASE:1.5
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2014.04.16.09.50.10;	author mpi;	state dead;
branches;
next	1.5;

1.5
date	2004.04.08.08.03.15;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.19;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.30;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.05.08.18.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.15.06.18.47;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.16;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.20.41.59;	author markus;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Sync the list of man pages for libcrypto, explicity rename conflicting
pages instead of doing it in the Makefiles and move a libssl page where
it belongs.

ok miod@@
@
text
@=pod

=head1 NAME

DES_random_key, DES_set_key, DES_key_sched, DES_set_key_checked,
DES_set_key_unchecked, DES_set_odd_parity, DES_is_weak_key,
DES_ecb_encrypt, DES_ecb2_encrypt, DES_ecb3_encrypt, DES_ncbc_encrypt,
DES_cfb_encrypt, DES_ofb_encrypt, DES_pcbc_encrypt, DES_cfb64_encrypt,
DES_ofb64_encrypt, DES_xcbc_encrypt, DES_ede2_cbc_encrypt,
DES_ede2_cfb64_encrypt, DES_ede2_ofb64_encrypt, DES_ede3_cbc_encrypt,
DES_ede3_cbcm_encrypt, DES_ede3_cfb64_encrypt, DES_ede3_ofb64_encrypt,
DES_cbc_cksum, DES_quad_cksum, DES_string_to_key, DES_string_to_2keys,
DES_fcrypt, DES_crypt, DES_enc_read, DES_enc_write - DES encryption

=head1 SYNOPSIS

 #include <openssl/des.h>

 void DES_random_key(DES_cblock *ret);

 int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule);
 int DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule);
 int DES_set_key_checked(const_DES_cblock *key,
        DES_key_schedule *schedule);
 void DES_set_key_unchecked(const_DES_cblock *key,
        DES_key_schedule *schedule);

 void DES_set_odd_parity(DES_cblock *key);
 int DES_is_weak_key(const_DES_cblock *key);

 void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output, 
        DES_key_schedule *ks, int enc);
 void DES_ecb2_encrypt(const_DES_cblock *input, DES_cblock *output, 
        DES_key_schedule *ks1, DES_key_schedule *ks2, int enc);
 void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output, 
        DES_key_schedule *ks1, DES_key_schedule *ks2, 
        DES_key_schedule *ks3, int enc);

 void DES_ncbc_encrypt(const unsigned char *input, unsigned char *output, 
        long length, DES_key_schedule *schedule, DES_cblock *ivec, 
        int enc);
 void DES_cfb_encrypt(const unsigned char *in, unsigned char *out,
        int numbits, long length, DES_key_schedule *schedule,
        DES_cblock *ivec, int enc);
 void DES_ofb_encrypt(const unsigned char *in, unsigned char *out,
        int numbits, long length, DES_key_schedule *schedule,
        DES_cblock *ivec);
 void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output, 
        long length, DES_key_schedule *schedule, DES_cblock *ivec, 
        int enc);
 void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,
        long length, DES_key_schedule *schedule, DES_cblock *ivec,
        int *num, int enc);
 void DES_ofb64_encrypt(const unsigned char *in, unsigned char *out,
        long length, DES_key_schedule *schedule, DES_cblock *ivec,
        int *num);

 void DES_xcbc_encrypt(const unsigned char *input, unsigned char *output, 
        long length, DES_key_schedule *schedule, DES_cblock *ivec, 
        const_DES_cblock *inw, const_DES_cblock *outw, int enc);

 void DES_ede2_cbc_encrypt(const unsigned char *input,
        unsigned char *output, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_cblock *ivec, int enc);
 void DES_ede2_cfb64_encrypt(const unsigned char *in,
        unsigned char *out, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_cblock *ivec, int *num, int enc);
 void DES_ede2_ofb64_encrypt(const unsigned char *in,
        unsigned char *out, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_cblock *ivec, int *num);

 void DES_ede3_cbc_encrypt(const unsigned char *input,
        unsigned char *output, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec,
        int enc);
 void DES_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out, 
        long length, DES_key_schedule *ks1, DES_key_schedule *ks2, 
        DES_key_schedule *ks3, DES_cblock *ivec1, DES_cblock *ivec2, 
        int enc);
 void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out, 
        long length, DES_key_schedule *ks1, DES_key_schedule *ks2,
        DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc);
 void DES_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out, 
        long length, DES_key_schedule *ks1, 
        DES_key_schedule *ks2, DES_key_schedule *ks3, 
        DES_cblock *ivec, int *num);

 DES_LONG DES_cbc_cksum(const unsigned char *input, DES_cblock *output, 
        long length, DES_key_schedule *schedule, 
        const_DES_cblock *ivec);
 DES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output[], 
        long length, int out_count, DES_cblock *seed);
 void DES_string_to_key(const char *str, DES_cblock *key);
 void DES_string_to_2keys(const char *str, DES_cblock *key1,
        DES_cblock *key2);

 char *DES_fcrypt(const char *buf, const char *salt, char *ret);
 char *DES_crypt(const char *buf, const char *salt);

 int DES_enc_read(int fd, void *buf, int len, DES_key_schedule *sched,
        DES_cblock *iv);
 int DES_enc_write(int fd, const void *buf, int len,
        DES_key_schedule *sched, DES_cblock *iv);

=head1 DESCRIPTION

This library contains a fast implementation of the DES encryption
algorithm.

There are two phases to the use of DES encryption.  The first is the
generation of a I<DES_key_schedule> from a key, the second is the
actual encryption.  A DES key is of type I<DES_cblock>. This type is
consists of 8 bytes with odd parity.  The least significant bit in
each byte is the parity bit.  The key schedule is an expanded form of
the key; it is used to speed the encryption process.

DES_random_key() generates a random key.  The PRNG must be seeded
prior to using this function (see L<rand(3)|rand(3)>).  If the PRNG
could not generate a secure key, 0 is returned.

Before a DES key can be used, it must be converted into the
architecture dependent I<DES_key_schedule> via the
DES_set_key_checked() or DES_set_key_unchecked() function.

DES_set_key_checked() will check that the key passed is of odd parity
and is not a week or semi-weak key.  If the parity is wrong, then -1
is returned.  If the key is a weak key, then -2 is returned.  If an
error is returned, the key schedule is not generated.

DES_set_key() works like
DES_set_key_checked() if the I<DES_check_key> flag is non-zero,
otherwise like DES_set_key_unchecked().  These functions are available
for compatibility; it is recommended to use a function that does not
depend on a global variable.

DES_set_odd_parity() sets the parity of the passed I<key> to odd.

DES_is_weak_key() returns 1 is the passed key is a weak key, 0 if it
is ok.  The probability that a randomly generated key is weak is
1/2^52, so it is not really worth checking for them.

The following routines mostly operate on an input and output stream of
I<DES_cblock>s.

DES_ecb_encrypt() is the basic DES encryption routine that encrypts or
decrypts a single 8-byte I<DES_cblock> in I<electronic code book>
(ECB) mode.  It always transforms the input data, pointed to by
I<input>, into the output data, pointed to by the I<output> argument.
If the I<encrypt> argument is non-zero (DES_ENCRYPT), the I<input>
(cleartext) is encrypted in to the I<output> (ciphertext) using the
key_schedule specified by the I<schedule> argument, previously set via
I<DES_set_key>. If I<encrypt> is zero (DES_DECRYPT), the I<input> (now
ciphertext) is decrypted into the I<output> (now cleartext).  Input
and output may overlap.  DES_ecb_encrypt() does not return a value.

DES_ecb3_encrypt() encrypts/decrypts the I<input> block by using
three-key Triple-DES encryption in ECB mode.  This involves encrypting
the input with I<ks1>, decrypting with the key schedule I<ks2>, and
then encrypting with I<ks3>.  This routine greatly reduces the chances
of brute force breaking of DES and has the advantage of if I<ks1>,
I<ks2> and I<ks3> are the same, it is equivalent to just encryption
using ECB mode and I<ks1> as the key.

The macro DES_ecb2_encrypt() is provided to perform two-key Triple-DES
encryption by using I<ks1> for the final encryption.

DES_ncbc_encrypt() encrypts/decrypts using the I<cipher-block-chaining>
(CBC) mode of DES.  If the I<encrypt> argument is non-zero, the
routine cipher-block-chain encrypts the cleartext data pointed to by
the I<input> argument into the ciphertext pointed to by the I<output>
argument, using the key schedule provided by the I<schedule> argument,
and initialization vector provided by the I<ivec> argument.  If the
I<length> argument is not an integral multiple of eight bytes, the
last block is copied to a temporary area and zero filled.  The output
is always an integral multiple of eight bytes.

DES_xcbc_encrypt() is RSA's DESX mode of DES.  It uses I<inw> and
I<outw> to 'whiten' the encryption.  I<inw> and I<outw> are secret
(unlike the iv) and are as such, part of the key.  So the key is sort
of 24 bytes.  This is much better than CBC DES.

DES_ede3_cbc_encrypt() implements outer triple CBC DES encryption with
three keys. This means that each DES operation inside the CBC mode is
really an C<C=E(ks3,D(ks2,E(ks1,M)))>.  This mode is used by SSL.

The DES_ede2_cbc_encrypt() macro implements two-key Triple-DES by
reusing I<ks1> for the final encryption.  C<C=E(ks1,D(ks2,E(ks1,M)))>.
This form of Triple-DES is used by the RSAREF library.

DES_pcbc_encrypt() encrypt/decrypts using the propagating cipher block
chaining mode used by Kerberos v4. Its parameters are the same as
DES_ncbc_encrypt().

DES_cfb_encrypt() encrypt/decrypts using cipher feedback mode.  This
method takes an array of characters as input and outputs and array of
characters.  It does not require any padding to 8 character groups.
Note: the I<ivec> variable is changed and the new changed value needs to
be passed to the next call to this function.  Since this function runs
a complete DES ECB encryption per I<numbits>, this function is only
suggested for use when sending small numbers of characters.

DES_cfb64_encrypt()
implements CFB mode of DES with 64bit feedback.  Why is this
useful you ask?  Because this routine will allow you to encrypt an
arbitrary number of bytes, no 8 byte padding.  Each call to this
routine will encrypt the input bytes to output and then update ivec
and num.  num contains 'how far' we are though ivec.  If this does
not make much sense, read more about cfb mode of DES :-).

DES_ede3_cfb64_encrypt() and DES_ede2_cfb64_encrypt() is the same as
DES_cfb64_encrypt() except that Triple-DES is used.

DES_ofb_encrypt() encrypts using output feedback mode.  This method
takes an array of characters as input and outputs and array of
characters.  It does not require any padding to 8 character groups.
Note: the I<ivec> variable is changed and the new changed value needs to
be passed to the next call to this function.  Since this function runs
a complete DES ECB encryption per numbits, this function is only
suggested for use when sending small numbers of characters.

DES_ofb64_encrypt() is the same as DES_cfb64_encrypt() using Output
Feed Back mode.

DES_ede3_ofb64_encrypt() and DES_ede2_ofb64_encrypt() is the same as
DES_ofb64_encrypt(), using Triple-DES.

The following functions are included in the DES library for
compatibility with the MIT Kerberos library.

DES_cbc_cksum() produces an 8 byte checksum based on the input stream
(via CBC encryption).  The last 4 bytes of the checksum are returned
and the complete 8 bytes are placed in I<output>. This function is
used by Kerberos v4.  Other applications should use
L<EVP_DigestInit(3)|EVP_DigestInit(3)> etc. instead.

DES_quad_cksum() is a Kerberos v4 function.  It returns a 4 byte
checksum from the input bytes.  The algorithm can be iterated over the
input, depending on I<out_count>, 1, 2, 3 or 4 times.  If I<output> is
non-NULL, the 8 bytes generated by each pass are written into
I<output>.

The following are DES-based transformations:

DES_fcrypt() is a fast version of the Unix crypt(3) function.  This
version takes only a small amount of space relative to other fast
crypt() implementations.  This is different to the normal crypt in
that the third parameter is the buffer that the return value is
written into.  It needs to be at least 14 bytes long.  This function
is thread safe, unlike the normal crypt.

DES_crypt() is a faster replacement for the normal system crypt().
This function calls DES_fcrypt() with a static array passed as the
third parameter.  This emulates the normal non-thread safe semantics
of crypt(3).

DES_enc_write() writes I<len> bytes to file descriptor I<fd> from
buffer I<buf>. The data is encrypted via I<pcbc_encrypt> (default)
using I<sched> for the key and I<iv> as a starting vector.  The actual
data send down I<fd> consists of 4 bytes (in network byte order)
containing the length of the following encrypted data.  The encrypted
data then follows, padded with random data out to a multiple of 8
bytes.

DES_enc_read() is used to read I<len> bytes from file descriptor
I<fd> into buffer I<buf>. The data being read from I<fd> is assumed to
have come from DES_enc_write() and is decrypted using I<sched> for
the key schedule and I<iv> for the initial vector.

B<Warning:> The data format used by DES_enc_write() and DES_enc_read()
has a cryptographic weakness: When asked to write more than MAXWRITE
bytes, DES_enc_write() will split the data into several chunks that
are all encrypted using the same IV.  So don't use these functions
unless you are sure you know what you do (in which case you might not
want to use them anyway).  They cannot handle non-blocking sockets.
DES_enc_read() uses an internal state and thus cannot be used on
multiple files.

I<DES_rw_mode> is used to specify the encryption mode to use with
DES_enc_read() and DES_end_write().  If set to I<DES_PCBC_MODE> (the
default), DES_pcbc_encrypt is used.  If set to I<DES_CBC_MODE>
DES_cbc_encrypt is used.

=head1 NOTES

Single-key DES is insecure due to its short key size.  ECB mode is
not suitable for most applications; see L<des_modes(7)|des_modes(7)>.

The L<evp(3)|evp(3)> library provides higher-level encryption functions.

=head1 BUGS

DES_3cbc_encrypt() is flawed and must not be used in applications.

DES_cbc_encrypt() does not modify B<ivec>; use DES_ncbc_encrypt()
instead.

DES_cfb_encrypt() and DES_ofb_encrypt() operates on input of 8 bits.
What this means is that if you set numbits to 12, and length to 2, the
first 12 bits will come from the 1st input byte and the low half of
the second input byte.  The second 12 bits will have the low 8 bits
taken from the 3rd input byte and the top 4 bits taken from the 4th
input byte.  The same holds for output.  This function has been
implemented this way because most people will be using a multiple of 8
and because once you get into pulling bytes input bytes apart things
get ugly!

DES_string_to_key() is available for backward compatibility with the
MIT library.  New applications should use a cryptographic hash function.
The same applies for DES_string_to_2key().

=head1 CONFORMING TO

ANSI X3.106

The B<des> library was written to be source code compatible with
the MIT Kerberos library.

=head1 SEE ALSO

crypt(3), L<des_modes(7)|des_modes(7)>, L<evp(3)|evp(3)>, L<rand(3)|rand(3)>

=head1 HISTORY

In OpenSSL 0.9.7, all des_ functions were renamed to DES_ to avoid
clashes with older versions of libdes.  Compatibility des_ functions
are provided for a short while, as well as crypt().
Declarations for these are in <openssl/des_old.h>. There is no DES_
variant for des_random_seed().
This will happen to other functions
as well if they are deemed redundant (des_random_seed() just calls
RAND_seed() and is present for backward compatibility only), buggy or
already scheduled for removal.

des_cbc_cksum(), des_cbc_encrypt(), des_ecb_encrypt(),
des_is_weak_key(), des_key_sched(), des_pcbc_encrypt(),
des_quad_cksum(), des_random_key() and des_string_to_key()
are available in the MIT Kerberos library;
des_check_key_parity(), des_fixup_key_parity() and des_is_weak_key()
are available in newer versions of that library.

des_set_key_checked() and des_set_key_unchecked() were added in
OpenSSL 0.9.5.

des_generate_random_block(), des_init_random_number_generator(),
des_new_random_key(), des_set_random_generator_seed() and
des_set_sequence_number() and des_rand_data() are used in newer
versions of Kerberos but are not implemented here.

des_random_key() generated cryptographically weak random data in
SSLeay and in OpenSSL prior version 0.9.5, as well as in the original
MIT library.

=head1 AUTHOR

Eric Young (eay@@cryptsoft.com). Modified for the OpenSSL project
(http://www.openssl.org).

=cut
@


1.5
log
@merge 0.9.7d
@
text
@@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d286 1
a286 1
not suitable for most applications; see L<DES_modes(7)|DES_modes(7)>.
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d5 9
a13 10
des_random_key, des_set_key, des_key_sched, des_set_key_checked,
des_set_key_unchecked, des_set_odd_parity, des_is_weak_key,
des_ecb_encrypt, des_ecb2_encrypt, des_ecb3_encrypt, des_ncbc_encrypt,
des_cfb_encrypt, des_ofb_encrypt, des_pcbc_encrypt, des_cfb64_encrypt,
des_ofb64_encrypt, des_xcbc_encrypt, des_ede2_cbc_encrypt,
des_ede2_cfb64_encrypt, des_ede2_ofb64_encrypt, des_ede3_cbc_encrypt,
des_ede3_cbcm_encrypt, des_ede3_cfb64_encrypt, des_ede3_ofb64_encrypt,
des_read_password, des_read_2passwords, des_read_pw_string,
des_cbc_cksum, des_quad_cksum, des_string_to_key, des_string_to_2keys,
des_fcrypt, des_crypt, des_enc_read, des_enc_write - DES encryption
d19 1
a19 1
 void des_random_key(des_cblock *ret);
d21 17
a37 17
 int des_set_key(const_des_cblock *key, des_key_schedule schedule);
 int des_key_sched(const_des_cblock *key, des_key_schedule schedule);
 int des_set_key_checked(const_des_cblock *key,
        des_key_schedule schedule);
 void des_set_key_unchecked(const_des_cblock *key,
        des_key_schedule schedule);

 void des_set_odd_parity(des_cblock *key);
 int des_is_weak_key(const_des_cblock *key);

 void des_ecb_encrypt(const_des_cblock *input, des_cblock *output, 
        des_key_schedule ks, int enc);
 void des_ecb2_encrypt(const_des_cblock *input, des_cblock *output, 
        des_key_schedule ks1, des_key_schedule ks2, int enc);
 void des_ecb3_encrypt(const_des_cblock *input, des_cblock *output, 
        des_key_schedule ks1, des_key_schedule ks2, 
        des_key_schedule ks3, int enc);
d39 2
a40 2
 void des_ncbc_encrypt(const unsigned char *input, unsigned char *output, 
        long length, des_key_schedule schedule, des_cblock *ivec, 
d42 8
a49 8
 void des_cfb_encrypt(const unsigned char *in, unsigned char *out,
        int numbits, long length, des_key_schedule schedule,
        des_cblock *ivec, int enc);
 void des_ofb_encrypt(const unsigned char *in, unsigned char *out,
        int numbits, long length, des_key_schedule schedule,
        des_cblock *ivec);
 void des_pcbc_encrypt(const unsigned char *input, unsigned char *output, 
        long length, des_key_schedule schedule, des_cblock *ivec, 
d51 2
a52 2
 void des_cfb64_encrypt(const unsigned char *in, unsigned char *out,
        long length, des_key_schedule schedule, des_cblock *ivec,
d54 2
a55 2
 void des_ofb64_encrypt(const unsigned char *in, unsigned char *out,
        long length, des_key_schedule schedule, des_cblock *ivec,
d58 17
a74 17
 void des_xcbc_encrypt(const unsigned char *input, unsigned char *output, 
        long length, des_key_schedule schedule, des_cblock *ivec, 
        const_des_cblock *inw, const_des_cblock *outw, int enc);

 void des_ede2_cbc_encrypt(const unsigned char *input,
        unsigned char *output, long length, des_key_schedule ks1,
        des_key_schedule ks2, des_cblock *ivec, int enc);
 void des_ede2_cfb64_encrypt(const unsigned char *in,
        unsigned char *out, long length, des_key_schedule ks1,
        des_key_schedule ks2, des_cblock *ivec, int *num, int enc);
 void des_ede2_ofb64_encrypt(const unsigned char *in,
        unsigned char *out, long length, des_key_schedule ks1,
        des_key_schedule ks2, des_cblock *ivec, int *num);

 void des_ede3_cbc_encrypt(const unsigned char *input,
        unsigned char *output, long length, des_key_schedule ks1,
        des_key_schedule ks2, des_key_schedule ks3, des_cblock *ivec,
d76 3
a78 3
 void des_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out, 
        long length, des_key_schedule ks1, des_key_schedule ks2, 
        des_key_schedule ks3, des_cblock *ivec1, des_cblock *ivec2, 
d80 24
a103 31
 void des_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out, 
        long length, des_key_schedule ks1, des_key_schedule ks2,
        des_key_schedule ks3, des_cblock *ivec, int *num, int enc);
 void des_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out, 
        long length, des_key_schedule ks1, 
        des_key_schedule ks2, des_key_schedule ks3, 
        des_cblock *ivec, int *num);

 int des_read_password(des_cblock *key, const char *prompt, int verify);
 int des_read_2passwords(des_cblock *key1, des_cblock *key2, 
        const char *prompt, int verify);
 int des_read_pw_string(char *buf, int length, const char *prompt,
        int verify);

 DES_LONG des_cbc_cksum(const unsigned char *input, des_cblock *output, 
        long length, des_key_schedule schedule, 
        const_des_cblock *ivec);
 DES_LONG des_quad_cksum(const unsigned char *input, des_cblock output[], 
        long length, int out_count, des_cblock *seed);
 void des_string_to_key(const char *str, des_cblock *key);
 void des_string_to_2keys(const char *str, des_cblock *key1,
        des_cblock *key2);

 char *des_fcrypt(const char *buf, const char *salt, char *ret);
 char *des_crypt(const char *buf, const char *salt);
 char *crypt(const char *buf, const char *salt);

 int des_enc_read(int fd, void *buf, int len, des_key_schedule sched,
        des_cblock *iv);
 int des_enc_write(int fd, const void *buf, int len,
        des_key_schedule sched, des_cblock *iv);
d111 2
a112 2
generation of a I<des_key_schedule> from a key, the second is the
actual encryption.  A DES key is of type I<des_cblock>. This type is
d117 3
a119 6
des_random_key() generates a random key.  The PRNG must be seeded
prior to using this function (see L<rand(3)|rand(3)>; for backward
compatibility the function des_random_seed() is available as well).
If the PRNG could not generate a secure key, 0 is returned.  In
earlier versions of the library, des_random_key() did not generate
secure keys.
d122 2
a123 2
architecture dependent I<des_key_schedule> via the
des_set_key_checked() or des_set_key_unchecked() function.
d125 1
a125 1
des_set_key_checked() will check that the key passed is of odd parity
d130 3
a132 3
des_set_key() (called des_key_sched() in the MIT library) works like
des_set_key_checked() if the I<des_check_key> flag is non-zero,
otherwise like des_set_key_unchecked().  These functions are available
d136 1
a136 2
des_set_odd_parity() (called des_fixup_key_parity() in the MIT
library) sets the parity of the passed I<key> to odd.
d138 1
a138 1
des_is_weak_key() returns 1 is the passed key is a weak key, 0 if it
d143 1
a143 1
I<des_cblock>s.
d145 2
a146 2
des_ecb_encrypt() is the basic DES encryption routine that encrypts or
decrypts a single 8-byte I<des_cblock> in I<electronic code book>
d152 1
a152 1
I<des_set_key>. If I<encrypt> is zero (DES_DECRYPT), the I<input> (now
d154 1
a154 1
and output may overlap.  des_ecb_encrypt() does not return a value.
d156 1
a156 1
des_ecb3_encrypt() encrypts/decrypts the I<input> block by using
d164 1
a164 1
The macro des_ecb2_encrypt() is provided to perform two-key Triple-DES
d167 1
a167 1
des_ncbc_encrypt() encrypts/decrypts using the I<cipher-block-chaining>
d177 1
a177 1
des_xcbc_encrypt() is RSA's DESX mode of DES.  It uses I<inw> and
d182 1
a182 1
des_ede3_cbc_encrypt() implements outer triple CBC DES encryption with
d186 1
a186 1
The des_ede2_cbc_encrypt() macro implements two-key Triple-DES by
d190 1
a190 1
des_pcbc_encrypt() encrypt/decrypts using the propagating cipher block
d192 1
a192 1
des_ncbc_encrypt().
d194 1
a194 1
des_cfb_encrypt() encrypt/decrypts using cipher feedback mode.  This
d202 1
a202 1
des_cfb64_encrypt()
d210 2
a211 2
des_ede3_cfb64_encrypt() and des_ede2_cfb64_encrypt() is the same as
des_cfb64_encrypt() except that Triple-DES is used.
d213 1
a213 1
des_ofb_encrypt() encrypts using output feedback mode.  This method
d221 1
a221 1
des_ofb64_encrypt() is the same as des_cfb64_encrypt() using Output
d224 2
a225 2
des_ede3_ofb64_encrypt() and des_ede2_ofb64_encrypt() is the same as
des_ofb64_encrypt(), using Triple-DES.
d228 1
a228 2
compatibility with the MIT Kerberos library. des_read_pw_string()
is also available under the name EVP_read_pw_string().
d230 1
a230 17
des_read_pw_string() writes the string specified by I<prompt> to
standard output, turns echo off and reads in input string from the
terminal.  The string is returned in I<buf>, which must have space for
at least I<length> bytes.  If I<verify> is set, the user is asked for
the password twice and unless the two copies match, an error is
returned.  A return code of -1 indicates a system error, 1 failure due
to use interaction, and 0 is success.

des_read_password() does the same and converts the password to a DES
key by calling des_string_to_key(); des_read_2password() operates in
the same way as des_read_password() except that it generates two keys
by using the des_string_to_2key() function.  des_string_to_key() is
available for backward compatibility with the MIT library.  New
applications should use a cryptographic hash function.  The same
applies for des_string_to_2key().

des_cbc_cksum() produces an 8 byte checksum based on the input stream
d236 1
a236 1
des_quad_cksum() is a Kerberos v4 function.  It returns a 4 byte
d244 1
a244 1
des_fcrypt() is a fast version of the Unix crypt(3) function.  This
d251 2
a252 2
des_crypt() is a faster replacement for the normal system crypt().
This function calls des_fcrypt() with a static array passed as the
d256 1
a256 1
des_enc_write() writes I<len> bytes to file descriptor I<fd> from
d264 1
a264 1
des_enc_read() is used to read I<len> bytes from file descriptor
d266 1
a266 1
have come from des_enc_write() and is decrypted using I<sched> for
d269 1
a269 1
B<Warning:> The data format used by des_enc_write() and des_enc_read()
d271 1
a271 1
bytes, des_enc_write() will split the data into several chunks that
d275 1
a275 1
des_enc_read() uses an internal state and thus cannot be used on
d278 4
a281 4
I<des_rw_mode> is used to specify the encryption mode to use with
des_enc_read() and des_end_write().  If set to I<DES_PCBC_MODE> (the
default), des_pcbc_encrypt is used.  If set to I<DES_CBC_MODE>
des_cbc_encrypt is used.
d286 1
a286 1
not suitable for most applications; see L<des_modes(7)|des_modes(7)>.
d292 1
a292 1
des_3cbc_encrypt() is flawed and must not be used in applications.
d294 1
a294 1
des_cbc_encrypt() does not modify B<ivec>; use des_ncbc_encrypt()
d297 1
a297 1
des_cfb_encrypt() and des_ofb_encrypt() operates on input of 8 bits.
d307 3
a309 2
des_read_pw_string() is the most machine/OS dependent function and
normally generates the most problems when porting this code.
d324 10
d336 2
a337 2
des_quad_cksum(), des_random_key(), des_read_password() and
des_string_to_key() are available in the MIT Kerberos library;
@


1.2
log
@des_modes(7) not des_modes(7); jmd@@turbogeek.org
@
text
@d133 1
a133 1
architecture dependant I<des_key_schedule> via the
d203 1
a203 1
chaing mode used by Kerberos v4. Its parameters are the same as
d244 1
a244 1
standarf output, turns echo off and reads in input string from the
d271 1
a271 1
The following are DES-based tranformations:
d273 1
a273 1
des_fcrypt() is a fast version of the unix crypt(3) function.  This
@


1.1
log
@OpenSSL 0.9.5a merge
@
text
@d348 1
a348 1
crypt(3), L<des_modes(3)|des_modes(3)>, L<evp(3)|evp(3)>, L<rand(3)|rand(3)>
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d5 10
a14 9
DES_random_key, DES_set_key, DES_key_sched, DES_set_key_checked,
DES_set_key_unchecked, DES_set_odd_parity, DES_is_weak_key,
DES_ecb_encrypt, DES_ecb2_encrypt, DES_ecb3_encrypt, DES_ncbc_encrypt,
DES_cfb_encrypt, DES_ofb_encrypt, DES_pcbc_encrypt, DES_cfb64_encrypt,
DES_ofb64_encrypt, DES_xcbc_encrypt, DES_ede2_cbc_encrypt,
DES_ede2_cfb64_encrypt, DES_ede2_ofb64_encrypt, DES_ede3_cbc_encrypt,
DES_ede3_cbcm_encrypt, DES_ede3_cfb64_encrypt, DES_ede3_ofb64_encrypt,
DES_cbc_cksum, DES_quad_cksum, DES_string_to_key, DES_string_to_2keys,
DES_fcrypt, DES_crypt, DES_enc_read, DES_enc_write - DES encryption
d20 1
a20 1
 void DES_random_key(DES_cblock *ret);
d22 17
a38 17
 int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule);
 int DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule);
 int DES_set_key_checked(const_DES_cblock *key,
        DES_key_schedule *schedule);
 void DES_set_key_unchecked(const_DES_cblock *key,
        DES_key_schedule *schedule);

 void DES_set_odd_parity(DES_cblock *key);
 int DES_is_weak_key(const_DES_cblock *key);

 void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output, 
        DES_key_schedule *ks, int enc);
 void DES_ecb2_encrypt(const_DES_cblock *input, DES_cblock *output, 
        DES_key_schedule *ks1, DES_key_schedule *ks2, int enc);
 void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output, 
        DES_key_schedule *ks1, DES_key_schedule *ks2, 
        DES_key_schedule *ks3, int enc);
d40 2
a41 2
 void DES_ncbc_encrypt(const unsigned char *input, unsigned char *output, 
        long length, DES_key_schedule *schedule, DES_cblock *ivec, 
d43 8
a50 8
 void DES_cfb_encrypt(const unsigned char *in, unsigned char *out,
        int numbits, long length, DES_key_schedule *schedule,
        DES_cblock *ivec, int enc);
 void DES_ofb_encrypt(const unsigned char *in, unsigned char *out,
        int numbits, long length, DES_key_schedule *schedule,
        DES_cblock *ivec);
 void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output, 
        long length, DES_key_schedule *schedule, DES_cblock *ivec, 
d52 2
a53 2
 void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,
        long length, DES_key_schedule *schedule, DES_cblock *ivec,
d55 2
a56 2
 void DES_ofb64_encrypt(const unsigned char *in, unsigned char *out,
        long length, DES_key_schedule *schedule, DES_cblock *ivec,
d59 17
a75 17
 void DES_xcbc_encrypt(const unsigned char *input, unsigned char *output, 
        long length, DES_key_schedule *schedule, DES_cblock *ivec, 
        const_DES_cblock *inw, const_DES_cblock *outw, int enc);

 void DES_ede2_cbc_encrypt(const unsigned char *input,
        unsigned char *output, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_cblock *ivec, int enc);
 void DES_ede2_cfb64_encrypt(const unsigned char *in,
        unsigned char *out, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_cblock *ivec, int *num, int enc);
 void DES_ede2_ofb64_encrypt(const unsigned char *in,
        unsigned char *out, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_cblock *ivec, int *num);

 void DES_ede3_cbc_encrypt(const unsigned char *input,
        unsigned char *output, long length, DES_key_schedule *ks1,
        DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec,
d77 3
a79 3
 void DES_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out, 
        long length, DES_key_schedule *ks1, DES_key_schedule *ks2, 
        DES_key_schedule *ks3, DES_cblock *ivec1, DES_cblock *ivec2, 
d81 31
a111 24
 void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out, 
        long length, DES_key_schedule *ks1, DES_key_schedule *ks2,
        DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc);
 void DES_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out, 
        long length, DES_key_schedule *ks1, 
        DES_key_schedule *ks2, DES_key_schedule *ks3, 
        DES_cblock *ivec, int *num);

 DES_LONG DES_cbc_cksum(const unsigned char *input, DES_cblock *output, 
        long length, DES_key_schedule *schedule, 
        const_DES_cblock *ivec);
 DES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output[], 
        long length, int out_count, DES_cblock *seed);
 void DES_string_to_key(const char *str, DES_cblock *key);
 void DES_string_to_2keys(const char *str, DES_cblock *key1,
        DES_cblock *key2);

 char *DES_fcrypt(const char *buf, const char *salt, char *ret);
 char *DES_crypt(const char *buf, const char *salt);

 int DES_enc_read(int fd, void *buf, int len, DES_key_schedule *sched,
        DES_cblock *iv);
 int DES_enc_write(int fd, const void *buf, int len,
        DES_key_schedule *sched, DES_cblock *iv);
d119 2
a120 2
generation of a I<DES_key_schedule> from a key, the second is the
actual encryption.  A DES key is of type I<DES_cblock>. This type is
d125 6
a130 3
DES_random_key() generates a random key.  The PRNG must be seeded
prior to using this function (see L<rand(3)|rand(3)>).  If the PRNG
could not generate a secure key, 0 is returned.
d133 2
a134 2
architecture dependent I<DES_key_schedule> via the
DES_set_key_checked() or DES_set_key_unchecked() function.
d136 1
a136 1
DES_set_key_checked() will check that the key passed is of odd parity
d141 3
a143 3
DES_set_key() works like
DES_set_key_checked() if the I<DES_check_key> flag is non-zero,
otherwise like DES_set_key_unchecked().  These functions are available
d147 2
a148 1
DES_set_odd_parity() sets the parity of the passed I<key> to odd.
d150 1
a150 1
DES_is_weak_key() returns 1 is the passed key is a weak key, 0 if it
d155 1
a155 1
I<DES_cblock>s.
d157 2
a158 2
DES_ecb_encrypt() is the basic DES encryption routine that encrypts or
decrypts a single 8-byte I<DES_cblock> in I<electronic code book>
d164 1
a164 1
I<DES_set_key>. If I<encrypt> is zero (DES_DECRYPT), the I<input> (now
d166 1
a166 1
and output may overlap.  DES_ecb_encrypt() does not return a value.
d168 1
a168 1
DES_ecb3_encrypt() encrypts/decrypts the I<input> block by using
d176 1
a176 1
The macro DES_ecb2_encrypt() is provided to perform two-key Triple-DES
d179 1
a179 1
DES_ncbc_encrypt() encrypts/decrypts using the I<cipher-block-chaining>
d189 1
a189 1
DES_xcbc_encrypt() is RSA's DESX mode of DES.  It uses I<inw> and
d194 1
a194 1
DES_ede3_cbc_encrypt() implements outer triple CBC DES encryption with
d198 1
a198 1
The DES_ede2_cbc_encrypt() macro implements two-key Triple-DES by
d202 3
a204 3
DES_pcbc_encrypt() encrypt/decrypts using the propagating cipher block
chaining mode used by Kerberos v4. Its parameters are the same as
DES_ncbc_encrypt().
d206 1
a206 1
DES_cfb_encrypt() encrypt/decrypts using cipher feedback mode.  This
d214 1
a214 1
DES_cfb64_encrypt()
d222 2
a223 2
DES_ede3_cfb64_encrypt() and DES_ede2_cfb64_encrypt() is the same as
DES_cfb64_encrypt() except that Triple-DES is used.
d225 1
a225 1
DES_ofb_encrypt() encrypts using output feedback mode.  This method
d233 1
a233 1
DES_ofb64_encrypt() is the same as DES_cfb64_encrypt() using Output
d236 2
a237 2
DES_ede3_ofb64_encrypt() and DES_ede2_ofb64_encrypt() is the same as
DES_ofb64_encrypt(), using Triple-DES.
d240 2
a241 1
compatibility with the MIT Kerberos library.
d243 17
a259 1
DES_cbc_cksum() produces an 8 byte checksum based on the input stream
d265 1
a265 1
DES_quad_cksum() is a Kerberos v4 function.  It returns a 4 byte
d271 1
a271 1
The following are DES-based transformations:
d273 1
a273 1
DES_fcrypt() is a fast version of the Unix crypt(3) function.  This
d280 2
a281 2
DES_crypt() is a faster replacement for the normal system crypt().
This function calls DES_fcrypt() with a static array passed as the
d285 1
a285 1
DES_enc_write() writes I<len> bytes to file descriptor I<fd> from
d293 1
a293 1
DES_enc_read() is used to read I<len> bytes from file descriptor
d295 1
a295 1
have come from DES_enc_write() and is decrypted using I<sched> for
d298 1
a298 1
B<Warning:> The data format used by DES_enc_write() and DES_enc_read()
d300 1
a300 1
bytes, DES_enc_write() will split the data into several chunks that
d304 1
a304 1
DES_enc_read() uses an internal state and thus cannot be used on
d307 4
a310 4
I<DES_rw_mode> is used to specify the encryption mode to use with
DES_enc_read() and DES_end_write().  If set to I<DES_PCBC_MODE> (the
default), DES_pcbc_encrypt is used.  If set to I<DES_CBC_MODE>
DES_cbc_encrypt is used.
d315 1
a315 1
not suitable for most applications; see L<DES_modes(7)|DES_modes(7)>.
d321 1
a321 1
DES_3cbc_encrypt() is flawed and must not be used in applications.
d323 1
a323 1
DES_cbc_encrypt() does not modify B<ivec>; use DES_ncbc_encrypt()
d326 1
a326 1
DES_cfb_encrypt() and DES_ofb_encrypt() operates on input of 8 bits.
d336 2
a337 3
DES_string_to_key() is available for backward compatibility with the
MIT library.  New applications should use a cryptographic hash function.
The same applies for DES_string_to_2key().
d348 1
a348 1
crypt(3), L<des_modes(7)|des_modes(7)>, L<evp(3)|evp(3)>, L<rand(3)|rand(3)>
a351 10
In OpenSSL 0.9.7, all des_ functions were renamed to DES_ to avoid
clashes with older versions of libdes.  Compatibility des_ functions
are provided for a short while, as well as crypt().
Declarations for these are in <openssl/des_old.h>. There is no DES_
variant for des_random_seed().
This will happen to other functions
as well if they are deemed redundant (des_random_seed() just calls
RAND_seed() and is present for backward compatibility only), buggy or
already scheduled for removal.

d354 2
a355 2
des_quad_cksum(), des_random_key() and des_string_to_key()
are available in the MIT Kerberos library;
@


1.1.1.2
log
@import openssl-0.9.7d
@
text
@d286 1
a286 1
not suitable for most applications; see L<des_modes(7)|des_modes(7)>.
@


