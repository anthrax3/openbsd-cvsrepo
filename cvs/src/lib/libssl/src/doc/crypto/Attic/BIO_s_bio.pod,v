head	1.6;
access;
symbols
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	butholakala:1.2
	openssl_1_0_1_g:1.1.1.2
	OPENBSD_5_5:1.2.0.46
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.42
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.40
	OPENBSD_5_3_BASE:1.2
	openssl_1_0_1_c:1.1.1.2
	OPENBSD_5_2:1.2.0.36
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.38
	openssl_1_0_0_f:1.1.1.2
	openssl_1_0_0_e:1.1.1.2
	OPENBSD_5_0:1.2.0.34
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.32
	OPENBSD_4_9_BASE:1.2
	openssh_1_0_0_a:1.1.1.2
	OPENBSD_4_8:1.2.0.30
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.26
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.28
	OPENBSD_4_6_BASE:1.2
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.2.0.24
	OPENBSD_4_5_BASE:1.2
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.2
	OPENBSD_4_4:1.2.0.22
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.20
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.18
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.16
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.14
	OPENBSD_4_0_BASE:1.2
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.2.0.12
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.10
	OPENBSD_3_8_BASE:1.2
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.2.0.8
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.1.0.10
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.8
	OPENBSD_3_2_BASE:1.1
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.1.0.6
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.2
	OPENBSD_2_9_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2015.02.16.16.42.14;	author schwarze;	state dead;
branches;
next	1.5;
commitid	Mk7fO1Pmls5x0M61;

1.5
date	2014.05.04.22.26.32;	author jim;	state Exp;
branches;
next	1.4;

1.4
date	2014.05.04.21.46.35;	author jim;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.18.21.57.17;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.12.02.18.39;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.15.02.58.25;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.15;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.36.10;	author markus;	state Exp;
branches;
next	;


desc
@@


1.6
log
@third batch of perlpod(1) to mdoc(7) conversion
@
text
@=pod

=head1 NAME

BIO_s_bio, BIO_make_bio_pair, BIO_destroy_bio_pair, BIO_shutdown_wr,
BIO_set_write_buf_size, BIO_get_write_buf_size, BIO_new_bio_pair,
BIO_get_write_guarantee, BIO_ctrl_get_write_guarantee, BIO_get_read_request,
BIO_ctrl_get_read_request, BIO_ctrl_reset_read_request - BIO pair BIO

=head1 SYNOPSIS

 #include <openssl/bio.h>

 BIO_METHOD *BIO_s_bio(void);

 #define BIO_make_bio_pair(b1,b2)   (int)BIO_ctrl(b1,BIO_C_MAKE_BIO_PAIR,0,b2)
 #define BIO_destroy_bio_pair(b)    (int)BIO_ctrl(b,BIO_C_DESTROY_BIO_PAIR,0,NULL)

 #define BIO_shutdown_wr(b) (int)BIO_ctrl(b, BIO_C_SHUTDOWN_WR, 0, NULL)

 #define BIO_set_write_buf_size(b,size) (int)BIO_ctrl(b,BIO_C_SET_WRITE_BUF_SIZE,size,NULL)
 #define BIO_get_write_buf_size(b,size) (size_t)BIO_ctrl(b,BIO_C_GET_WRITE_BUF_SIZE,size,NULL)

 int BIO_new_bio_pair(BIO **bio1, size_t writebuf1, BIO **bio2, size_t writebuf2);

 #define BIO_get_write_guarantee(b) (int)BIO_ctrl(b,BIO_C_GET_WRITE_GUARANTEE,0,NULL)
 size_t BIO_ctrl_get_write_guarantee(BIO *b);

 #define BIO_get_read_request(b)    (int)BIO_ctrl(b,BIO_C_GET_READ_REQUEST,0,NULL)
 size_t BIO_ctrl_get_read_request(BIO *b);

 int BIO_ctrl_reset_read_request(BIO *b);

=head1 DESCRIPTION

BIO_s_bio() returns the method for a BIO pair. A BIO pair is a pair of
source/sink BIOs where data written to either half of the pair is buffered and
can be read from the other half. Both halves must usually by handled by the
same application thread since no locking is done on the internal data
structures.

Since BIO chains typically end in a source/sink BIO it is possible to make this
one half of a BIO pair and have all the data processed by the chain under
application control.

One typical use of BIO pairs is to place TLS/SSL I/O under application control,
this can be used when the application wishes to use a non standard transport
for TLS/SSL or the normal socket routines are inappropriate.

Calls to BIO_read() will read data from the buffer or request a retry if no
data is available.

Calls to BIO_write() will place data in the buffer or request a retry if the
buffer is full.

The standard calls BIO_ctrl_pending() and BIO_ctrl_wpending() can be used to
determine the amount of pending data in the read or write buffer.

BIO_reset() clears any data in the write buffer.

BIO_make_bio_pair() joins two separate BIOs into a connected pair.

BIO_destroy_pair() destroys the association between two connected BIOs. Freeing
up any half of the pair will automatically destroy the association.

BIO_shutdown_wr() is used to close down a BIO B<b>. After this call no further
writes on BIO B<b> are allowed (they will return an error). Reads on the other
half of the pair will return any pending data or EOF when all pending data has
been read.

BIO_set_write_buf_size() sets the write buffer size of BIO B<b> to B<size>.
If the size is not initialized a default value is used. This is currently
17K, sufficient for a maximum size TLS record.

BIO_get_write_buf_size() returns the size of the write buffer.

BIO_new_bio_pair() combines the calls to BIO_new(), BIO_make_bio_pair() and
BIO_set_write_buf_size() to create a connected pair of BIOs B<bio1>, B<bio2>
with write buffer sizes B<writebuf1> and B<writebuf2>. If either size is
zero then the default size is used.  BIO_new_bio_pair() does not check whether
B<bio1> or B<bio2> do point to some other BIO, the values are overwritten,
BIO_free() is not called.

BIO_get_write_guarantee() and BIO_ctrl_get_write_guarantee() return the maximum
length of data that can be currently written to the BIO. Writes larger than
this value will return a value from BIO_write() less than the amount requested
or if the buffer is full request a retry. BIO_ctrl_get_write_guarantee() is a
function whereas BIO_get_write_guarantee() is a macro.

BIO_get_read_request() and BIO_ctrl_get_read_request() return the
amount of data requested, or the buffer size if it is less, if the
last read attempt at the other half of the BIO pair failed due to an
empty buffer.  This can be used to determine how much data should be
written to the BIO so the next read will succeed: this is most useful
in TLS/SSL applications where the amount of data read is usually
meaningful rather than just a buffer size. After a successful read
this call will return zero.  It also will return zero once new data
has been written satisfying the read request or part of it.
Note that BIO_get_read_request() never returns an amount larger
than that returned by BIO_get_write_guarantee().

BIO_ctrl_reset_read_request() can also be used to reset the value returned by
BIO_get_read_request() to zero.

=head1 NOTES

Both halves of a BIO pair should be freed. That is even if one half is implicit
freed due to a BIO_free_all() or SSL_free() call the other half needs to be
freed.

When used in bidirectional applications (such as TLS/SSL) care should be taken
to flush any data in the write buffer. This can be done by calling
BIO_pending() on the other half of the pair and, if any data is pending,
reading it and sending it to the underlying transport. This must be done before
any normal processing (such as calling select() ) due to a request and
BIO_should_read() being true.

To see why this is important consider a case where a request is sent using
BIO_write() and a response read with BIO_read(), this can occur during an
TLS/SSL handshake for example. BIO_write() will succeed and place data in the
write buffer. BIO_read() will initially fail and BIO_should_read() will be
true. If the application then waits for data to be available on the underlying
transport before flushing the write buffer it will never succeed because the
request was never sent!

=head1 RETURN VALUES

BIO_new_bio_pair() returns 1 on success, with the new BIOs available in
B<bio1> and B<bio2>, or 0 on failure, with NULL pointers stored into the
locations for B<bio1> and B<bio2>. Check the error stack for more information.

[TODO: More return values need to be added here]

=head1 EXAMPLE

The BIO pair can be used to have full control over the network access of an
application. The application can call select() on the socket as required
without having to go through the SSL-interface.

 BIO *internal_bio, *network_bio;
 ...
 BIO_new_bio_pair(internal_bio, 0, network_bio, 0);
 SSL_set_bio(ssl, internal_bio, internal_bio);
 SSL_operations();
 ...

 application |   TLS-engine
    |        |
    +----------> SSL_operations()
             |     /\    ||
             |     ||    \/
             |   BIO-pair (internal_bio)
    +----------< BIO-pair (network_bio)
    |        |
  socket     |

  ...
  SSL_free(ssl);		/* implicitly frees internal_bio */
  BIO_free(network_bio);
  ...

As the BIO pair will only buffer the data and never directly access the
connection, it behaves non-blocking and will return as soon as the write
buffer is full or the read buffer is drained. Then the application has to
flush the write buffer and/or fill the read buffer.

Use the BIO_ctrl_pending(), to find out whether data is buffered in the BIO
and must be transfered to the network. Use BIO_ctrl_get_read_request() to
find out, how many bytes must be written into the buffer before the
SSL_operation() can successfully be continued.

=head1 WARNING

As the data is buffered, SSL_operation() may return with a ERROR_SSL_WANT_READ
condition, but there is still data in the write buffer. An application must
not rely on the error value of SSL_operation() but must assure that the
write buffer is always flushed first. Otherwise a deadlock may occur as
the peer might be waiting for the data before being able to continue.

=head1 SEE ALSO

L<SSL_set_bio(3)|SSL_set_bio(3)>, L<ssl(3)|ssl(3)>, L<bio(3)|bio(3)>,
L<BIO_should_retry(3)|BIO_should_retry(3)>, L<BIO_read(3)|BIO_read(3)>

=cut
@


1.5
log
@Improve line wrapping for lines exceeding 80 chars.

ok jmc@@
@
text
@@


1.4
log
@Remove trailing whitespace.

fine jmc@@
@
text
@d36 5
a40 4
BIO_s_bio() returns the method for a BIO pair. A BIO pair is a pair of source/sink
BIOs where data written to either half of the pair is buffered and can be read from
the other half. Both halves must usually by handled by the same application thread
since no locking is done on the internal data structures.
d43 2
a44 2
one half of a BIO pair and have all the data processed by the chain under application
control.
d46 3
a48 3
One typical use of BIO pairs is to place TLS/SSL I/O under application control, this
can be used when the application wishes to use a non standard transport for
TLS/SSL or the normal socket routines are inappropriate.
d85 4
a88 4
length of data that can be currently written to the BIO. Writes larger than this
value will return a value from BIO_write() less than the amount requested or if the
buffer is full request a retry. BIO_ctrl_get_write_guarantee() is a function
whereas BIO_get_write_guarantee() is a macro.
d108 2
a109 1
freed due to a BIO_free_all() or SSL_free() call the other half needs to be freed.
d111 6
a116 5
When used in bidirectional applications (such as TLS/SSL) care should be taken to
flush any data in the write buffer. This can be done by calling BIO_pending()
on the other half of the pair and, if any data is pending, reading it and sending
it to the underlying transport. This must be done before any normal processing
(such as calling select() ) due to a request and BIO_should_read() being true.
d120 5
a124 5
TLS/SSL handshake for example. BIO_write() will succeed and place data in the write
buffer. BIO_read() will initially fail and BIO_should_read() will be true. If
the application then waits for data to be available on the underlying transport
before flushing the write buffer it will never succeed because the request was
never sent!
@


1.3
log
@tone down some XXXXX to not appear in grep
@
text
@d5 1
a5 1
BIO_s_bio, BIO_make_bio_pair, BIO_destroy_bio_pair, BIO_shutdown_wr, 
d68 1
a68 1
been read. 
@


1.2
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d129 1
a129 1
[XXXXX: More return values need to be added here]
@


1.1
log
@openssl-engine-0.9.6 merge
@
text
@d79 3
a81 1
zero then the default size is used.
d123 8
d133 43
a175 1
TBA
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d79 1
a79 3
zero then the default size is used.  BIO_new_bio_pair() does not check whether
B<bio1> or B<bio2> do point to some other BIO, the values are overwritten,
BIO_free() is not called.
a120 8
=head1 RETURN VALUES

BIO_new_bio_pair() returns 1 on success, with the new BIOs available in
B<bio1> and B<bio2>, or 0 on failure, with NULL pointers stored into the
locations for B<bio1> and B<bio2>. Check the error stack for more information.

[XXXXX: More return values need to be added here]

d123 1
a123 43
The BIO pair can be used to have full control over the network access of an
application. The application can call select() on the socket as required
without having to go through the SSL-interface.

 BIO *internal_bio, *network_bio;
 ...
 BIO_new_bio_pair(internal_bio, 0, network_bio, 0);
 SSL_set_bio(ssl, internal_bio, internal_bio);
 SSL_operations();
 ...

 application |   TLS-engine
    |        |
    +----------> SSL_operations()
             |     /\    ||
             |     ||    \/
             |   BIO-pair (internal_bio)
    +----------< BIO-pair (network_bio)
    |        |
  socket     |

  ...
  SSL_free(ssl);		/* implicitly frees internal_bio */
  BIO_free(network_bio);
  ...

As the BIO pair will only buffer the data and never directly access the
connection, it behaves non-blocking and will return as soon as the write
buffer is full or the read buffer is drained. Then the application has to
flush the write buffer and/or fill the read buffer.

Use the BIO_ctrl_pending(), to find out whether data is buffered in the BIO
and must be transfered to the network. Use BIO_ctrl_get_read_request() to
find out, how many bytes must be written into the buffer before the
SSL_operation() can successfully be continued.

=head1 WARNING

As the data is buffered, SSL_operation() may return with a ERROR_SSL_WANT_READ
condition, but there is still data in the write buffer. An application must
not rely on the error value of SSL_operation() but must assure that the
write buffer is always flushed first. Otherwise a deadlock may occur as
the peer might be waiting for the data before being able to continue.
@


