head	1.5;
access;
symbols
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	butholakala:1.3
	openssl_1_0_1_g:1.1.1.2
	OPENBSD_5_5:1.3.0.50
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.46
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.44
	OPENBSD_5_3_BASE:1.3
	openssl_1_0_1_c:1.1.1.2
	OPENBSD_5_2:1.3.0.40
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.42
	openssl_1_0_0_f:1.1.1.2
	openssl_1_0_0_e:1.1.1.2
	OPENBSD_5_0:1.3.0.38
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.36
	OPENBSD_4_9_BASE:1.3
	openssh_1_0_0_a:1.1.1.2
	OPENBSD_4_8:1.3.0.34
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.30
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.32
	OPENBSD_4_6_BASE:1.3
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.3.0.28
	OPENBSD_4_5_BASE:1.3
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.3
	OPENBSD_4_4:1.3.0.26
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.24
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.22
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.20
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.18
	OPENBSD_4_0_BASE:1.3
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.3.0.16
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.14
	OPENBSD_3_8_BASE:1.3
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.3.0.12
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.10
	OPENBSD_3_6_BASE:1.3
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@# @;


1.5
date	2015.02.23.17.43.24;	author schwarze;	state dead;
branches;
next	1.4;
commitid	YTrWDOlpO82FZm6K;

1.4
date	2014.05.04.22.26.32;	author jim;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.15.02.29.19;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.03.19.27.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.12.54;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.16;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.36.10;	author markus;	state Exp;
branches;
next	;


desc
@@


1.5
log
@fourth batch of perlpod(1) to mdoc(7) conversion
@
text
@=pod

=head1 NAME

BN_add, BN_sub, BN_mul, BN_sqr, BN_div, BN_mod, BN_nnmod, BN_mod_add,
BN_mod_sub, BN_mod_mul, BN_mod_sqr, BN_exp, BN_mod_exp, BN_gcd -
arithmetic operations on BIGNUMs

=head1 SYNOPSIS

 #include <openssl/bn.h>

 int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);

 int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);

 int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);

 int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);

 int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,
         BN_CTX *ctx);

 int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);

 int BN_nnmod(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);

 int BN_mod_add(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
         BN_CTX *ctx);

 int BN_mod_sub(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
         BN_CTX *ctx);

 int BN_mod_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
         BN_CTX *ctx);

 int BN_mod_sqr(BIGNUM *r, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);

 int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);

 int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
         const BIGNUM *m, BN_CTX *ctx);

 int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);

=head1 DESCRIPTION

BN_add() adds I<a> and I<b> and places the result in I<r> (C<r=a+b>).
I<r> may be the same B<BIGNUM> as I<a> or I<b>.

BN_sub() subtracts I<b> from I<a> and places the result in I<r> (C<r=a-b>).

BN_mul() multiplies I<a> and I<b> and places the result in I<r> (C<r=a*b>).
I<r> may be the same B<BIGNUM> as I<a> or I<b>.
For multiplication by powers of 2, use L<BN_lshift(3)|BN_lshift(3)>.

BN_sqr() takes the square of I<a> and places the result in I<r>
(C<r=a^2>). I<r> and I<a> may be the same B<BIGNUM>.
This function is faster than BN_mul(r,a,a).

BN_div() divides I<a> by I<d> and places the result in I<dv> and the
remainder in I<rem> (C<dv=a/d, rem=a%d>). Either of I<dv> and I<rem> may
be B<NULL>, in which case the respective value is not returned.
The result is rounded towards zero; thus if I<a> is negative, the
remainder will be zero or negative.
For division by powers of 2, use BN_rshift(3).

BN_mod() corresponds to BN_div() with I<dv> set to B<NULL>.

BN_nnmod() reduces I<a> modulo I<m> and places the non-negative
remainder in I<r>.

BN_mod_add() adds I<a> to I<b> modulo I<m> and places the non-negative
result in I<r>.

BN_mod_sub() subtracts I<b> from I<a> modulo I<m> and places the
non-negative result in I<r>.

BN_mod_mul() multiplies I<a> by I<b> and finds the non-negative
remainder respective to modulus I<m> (C<r=(a*b) mod m>). I<r> may be
the same B<BIGNUM> as I<a> or I<b>. For more efficient algorithms for
repeated computations using the same modulus, see
L<BN_mod_mul_montgomery(3)|BN_mod_mul_montgomery(3)> and
L<BN_mod_mul_reciprocal(3)|BN_mod_mul_reciprocal(3)>.

BN_mod_sqr() takes the square of I<a> modulo B<m> and places the
result in I<r>.

BN_exp() raises I<a> to the I<p>-th power and places the result in I<r>
(C<r=a^p>). This function is faster than repeated applications of
BN_mul().

BN_mod_exp() computes I<a> to the I<p>-th power modulo I<m> (C<r=a^p %
m>). This function uses less time and space than BN_exp().

BN_gcd() computes the greatest common divisor of I<a> and I<b> and
places the result in I<r>. I<r> may be the same B<BIGNUM> as I<a> or
I<b>.

For all functions, I<ctx> is a previously allocated B<BN_CTX> used for
temporary variables; see L<BN_CTX_new(3)|BN_CTX_new(3)>.

Unless noted otherwise, the result B<BIGNUM> must be different from
the arguments.

=head1 RETURN VALUES

For all functions, 1 is returned for success, 0 on error. The return
value should always be checked (e.g., C<if (!BN_add(r,a,b)) goto err;>).
The error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>.

=head1 SEE ALSO

L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>,
L<BN_CTX_new(3)|BN_CTX_new(3)>, L<BN_add_word(3)|BN_add_word(3)>,
L<BN_set_bit(3)|BN_set_bit(3)>

=head1 HISTORY

BN_add(), BN_sub(), BN_sqr(), BN_div(), BN_mod(), BN_mod_mul(),
BN_mod_exp() and BN_gcd() are available in all versions of SSLeay and
OpenSSL. The I<ctx> argument to BN_mul() was added in SSLeay
0.9.1b. BN_exp() appeared in SSLeay 0.9.0.
BN_nnmod(), BN_mod_add(), BN_mod_sub(), and BN_mod_sqr() were added in
OpenSSL 0.9.7.

=cut
@


1.4
log
@Improve line wrapping for lines exceeding 80 chars.

ok jmc@@
@
text
@@


1.3
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d114 3
a116 2
L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_CTX_new(3)|BN_CTX_new(3)>,
L<BN_add_word(3)|BN_add_word(3)>, L<BN_set_bit(3)|BN_set_bit(3)>
@


1.2
log
@correct Xr to where we actually install the man pages
@
text
@d5 3
a7 2
BN_add, BN_sub, BN_mul, BN_div, BN_sqr, BN_mod, BN_mod_mul, BN_exp,
BN_mod_exp, BN_gcd - arithmetic operations on BIGNUMs
d19 2
d24 6
a29 1
 int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);
d31 2
a32 1
 int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
d34 1
a34 1
 int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
d37 2
d48 2
a49 2
BN_add() adds B<a> and B<b> and places the result in B<r> (C<r=a+b>).
B<r> may be the same B<BIGNUM> as B<a> or B<b>.
d51 1
a51 1
BN_sub() subtracts B<b> from B<a> and places the result in B<r> (C<r=a-b>).
d53 2
a54 2
BN_mul() multiplies B<a> and B<b> and places the result in B<r> (C<r=a*b>).
B<r> may be the same B<BIGNUM> as B<a> or B<b>.
d57 9
a65 3
BN_div() divides B<a> by B<d> and places the result in B<dv> and the
remainder in B<rem> (C<dv=a/d, rem=a%d>). Either of B<dv> and B<rem> may
be NULL, in which case the respective value is not returned.
d68 10
a77 3
BN_sqr() takes the square of B<a> and places the result in B<r>
(C<r=a^2>). B<r> and B<a> may be the same B<BIGNUM>.
This function is faster than BN_mul(r,a,a).
d79 6
a84 2
BN_mod() find the remainder of B<a> divided by B<m> and places it in
B<rem> (C<rem=a%m>).
d86 2
a87 5
BN_mod_mul() multiplies B<a> by B<b> and finds the remainder when
divided by B<m> (C<r=(a*b)%m>). B<r> may be the same B<BIGNUM> as B<a>
or B<b>. For a more efficient algorithm, see
L<BN_mod_mul_montgomery(3)|BN_mod_mul_montgomery(3)>; for repeated
computations using the same modulus, see L<BN_mod_mul_reciprocal(3)|BN_mod_mul_reciprocal(3)>.
d89 1
a89 1
BN_exp() raises B<a> to the B<p>-th power and places the result in B<r>
d93 1
a93 1
BN_mod_exp() computes B<a> to the B<p>-th power modulo B<m> (C<r=a^p %
d96 3
a98 3
BN_gcd() computes the greatest common divisor of B<a> and B<b> and
places the result in B<r>. B<r> may be the same B<BIGNUM> as B<a> or
B<b>.
d100 1
a100 1
For all functions, B<ctx> is a previously allocated B<BN_CTX> used for
d119 1
a119 1
BN_add(), BN_sub(), BN_div(), BN_sqr(), BN_mod(), BN_mod_mul(),
d121 1
a121 1
OpenSSL. The B<ctx> argument to BN_mul() was added in SSLeay
d123 2
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d89 1
a89 1
L<bn(3)|bn(3)>, L<err(3)|err(3)>, L<BN_CTX_new(3)|BN_CTX_new(3)>,
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d5 2
a6 3
BN_add, BN_sub, BN_mul, BN_sqr, BN_div, BN_mod, BN_nnmod, BN_mod_add,
BN_mod_sub, BN_mod_mul, BN_mod_sqr, BN_exp, BN_mod_exp, BN_gcd -
arithmetic operations on BIGNUMs
a17 2
 int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);

d21 2
d25 1
a25 9
 int BN_nnmod(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);

 int BN_mod_add(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
         BN_CTX *ctx);

 int BN_mod_sub(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
         BN_CTX *ctx);

 int BN_mod_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
a27 2
 int BN_mod_sqr(BIGNUM *r, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);

d37 2
a38 2
BN_add() adds I<a> and I<b> and places the result in I<r> (C<r=a+b>).
I<r> may be the same B<BIGNUM> as I<a> or I<b>.
d40 1
a40 1
BN_sub() subtracts I<b> from I<a> and places the result in I<r> (C<r=a-b>).
d42 2
a43 2
BN_mul() multiplies I<a> and I<b> and places the result in I<r> (C<r=a*b>).
I<r> may be the same B<BIGNUM> as I<a> or I<b>.
d46 3
a48 9
BN_sqr() takes the square of I<a> and places the result in I<r>
(C<r=a^2>). I<r> and I<a> may be the same B<BIGNUM>.
This function is faster than BN_mul(r,a,a).

BN_div() divides I<a> by I<d> and places the result in I<dv> and the
remainder in I<rem> (C<dv=a/d, rem=a%d>). Either of I<dv> and I<rem> may
be B<NULL>, in which case the respective value is not returned.
The result is rounded towards zero; thus if I<a> is negative, the
remainder will be zero or negative.
d51 3
a53 10
BN_mod() corresponds to BN_div() with I<dv> set to B<NULL>.

BN_nnmod() reduces I<a> modulo I<m> and places the non-negative
remainder in I<r>.

BN_mod_add() adds I<a> to I<b> modulo I<m> and places the non-negative
result in I<r>.

BN_mod_sub() subtracts I<b> from I<a> modulo I<m> and places the
non-negative result in I<r>.
d55 2
a56 6
BN_mod_mul() multiplies I<a> by I<b> and finds the non-negative
remainder respective to modulus I<m> (C<r=(a*b) mod m>). I<r> may be
the same B<BIGNUM> as I<a> or I<b>. For more efficient algorithms for
repeated computations using the same modulus, see
L<BN_mod_mul_montgomery(3)|BN_mod_mul_montgomery(3)> and
L<BN_mod_mul_reciprocal(3)|BN_mod_mul_reciprocal(3)>.
d58 5
a62 2
BN_mod_sqr() takes the square of I<a> modulo B<m> and places the
result in I<r>.
d64 1
a64 1
BN_exp() raises I<a> to the I<p>-th power and places the result in I<r>
d68 1
a68 1
BN_mod_exp() computes I<a> to the I<p>-th power modulo I<m> (C<r=a^p %
d71 3
a73 3
BN_gcd() computes the greatest common divisor of I<a> and I<b> and
places the result in I<r>. I<r> may be the same B<BIGNUM> as I<a> or
I<b>.
d75 1
a75 1
For all functions, I<ctx> is a previously allocated B<BN_CTX> used for
d94 1
a94 1
BN_add(), BN_sub(), BN_sqr(), BN_div(), BN_mod(), BN_mod_mul(),
d96 1
a96 1
OpenSSL. The I<ctx> argument to BN_mul() was added in SSLeay
a97 2
BN_nnmod(), BN_mod_add(), BN_mod_sub(), and BN_mod_sqr() were added in
OpenSSL 0.9.7.
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d114 1
a114 1
L<bn(3)|bn(3)>, L<ERR_get_error(3)|ERR_get_error(3)>, L<BN_CTX_new(3)|BN_CTX_new(3)>,
@


