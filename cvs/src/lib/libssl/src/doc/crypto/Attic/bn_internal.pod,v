head	1.9;
access;
symbols
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	butholakala:1.6
	openssl_1_0_1_g:1.1.1.3
	OPENBSD_5_5:1.6.0.16
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.12
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.10
	OPENBSD_5_3_BASE:1.6
	openssl_1_0_1_c:1.1.1.3
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.3
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.5.0.8
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.4
	OPENBSD_4_4:1.4.0.26
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.24
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.22
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.20
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.18
	OPENBSD_4_0_BASE:1.4
	openssl_0_9_7j:1.1.1.1
	openssl:1.1.1
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENSSL_0_9_7G:1.1.1.1
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENSSL_0_9_7D:1.1.1.1
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.2.0.6
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@# @;


1.9
date	2015.11.12.00.55.49;	author schwarze;	state dead;
branches;
next	1.8;
commitid	RO3YWQP7BDJs4F8k;

1.8
date	2015.11.11.22.14.40;	author jmc;	state Exp;
branches;
next	1.7;
commitid	eNNq8UNxWW0rsWWg;

1.7
date	2014.05.04.21.46.36;	author jim;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.01.22.58.58;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.03.15.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.15.02.29.19;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.58.30;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.13.00;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.16;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.06.12.15.49;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.13;	author djm;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Convert the handful of manuals that had imaginary names,
give them names that really exist.
This also helps jmc@@'s ongoing work on improving NAME sections.
@
text
@=pod

=head1 NAME

bn_mul_words, bn_mul_add_words, bn_sqr_words, bn_div_words,
bn_add_words, bn_sub_words, bn_mul_comba4, bn_mul_comba8,
bn_sqr_comba4, bn_sqr_comba8, bn_cmp_words, bn_mul_normal,
bn_mul_low_normal, bn_mul_recursive, bn_mul_part_recursive,
bn_mul_low_recursive, bn_mul_high, bn_sqr_normal, bn_sqr_recursive,
bn_expand, bn_wexpand, bn_expand2, bn_fix_top, bn_check_top,
bn_print, bn_dump, bn_set_max, bn_set_high, bn_set_low, sqr
- BIGNUM library internal functions

=head1 SYNOPSIS

 #include <openssl/bn.h>

 BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w);
 BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num,
   BN_ULONG w);
 void     bn_sqr_words(BN_ULONG *rp, BN_ULONG *ap, int num);
 BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);
 BN_ULONG bn_add_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
   int num);
 BN_ULONG bn_sub_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
   int num);

 void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
 void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
 void bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a);
 void bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a);

 int bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n);

 void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b,
   int nb);
 void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n);
 void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
   int dna,int dnb,BN_ULONG *tmp);
 void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
   int n, int tna,int tnb, BN_ULONG *tmp);
 void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
   int n2, BN_ULONG *tmp);
 void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l,
   int n2, BN_ULONG *tmp);

 void bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp);
 void bn_sqr_recursive(BN_ULONG *r, BN_ULONG *a, int n2, BN_ULONG *tmp);

 void mul(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
 void mul_add(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
 void sqr(BN_ULONG r0, BN_ULONG r1, BN_ULONG a);

 BIGNUM *bn_expand(BIGNUM *a, int bits);
 BIGNUM *bn_wexpand(BIGNUM *a, int n);
 BIGNUM *bn_expand2(BIGNUM *a, int n);
 void bn_fix_top(BIGNUM *a);

 void bn_check_top(BIGNUM *a);
 void bn_print(BIGNUM *a);
 void bn_dump(BN_ULONG *d, int n);
 void bn_set_max(BIGNUM *a);
 void bn_set_high(BIGNUM *r, BIGNUM *a, int n);
 void bn_set_low(BIGNUM *r, BIGNUM *a, int n);

=head1 DESCRIPTION

This page documents the internal functions used by the OpenSSL
B<BIGNUM> implementation. They are described here to facilitate
debugging and extending the library. They are I<not> to be used by
applications.

=head2 The BIGNUM structure

 typedef struct bignum_st BIGNUM;

 struct bignum_st
        {
        BN_ULONG *d;    /* Pointer to an array of 'BN_BITS2' bit chunks. */
        int top;        /* Index of last used d +1. */
        /* The next are internal book keeping for bn_expand. */
        int dmax;       /* Size of the d array. */
        int neg;        /* one if the number is negative */
        int flags;
        };


The integer value is stored in B<d>, a malloc()ed array of words (B<BN_ULONG>),
least significant word first. A B<BN_ULONG> can be either 16, 32 or 64 bits
in size, depending on the 'number of bits' (B<BITS2>) specified in
C<openssl/bn.h>.

B<dmax> is the size of the B<d> array that has been allocated.  B<top>
is the number of words being used, so for a value of 4, bn.d[0]=4 and
bn.top=1.  B<neg> is 1 if the number is negative.  When a B<BIGNUM> is
B<0>, the B<d> field can be B<NULL> and B<top> == B<0>.

B<flags> is a bit field of flags which are defined in C<openssl/bn.h>. The
flags begin with B<BN_FLG_>. The macros BN_set_flags(b,n) and
BN_get_flags(b,n) exist to enable or fetch flag(s) B<n> from B<BIGNUM>
structure B<b>.

Various routines in this library require the use of temporary
B<BIGNUM> variables during their execution.  Since dynamic memory
allocation to create B<BIGNUM>s is rather expensive when used in
conjunction with repeated subroutine calls, the B<BN_CTX> structure is
used.  This structure contains B<BN_CTX_NUM> B<BIGNUM>s, see
L<BN_CTX_start(3)|BN_CTX_start(3)>.

=head2 Low-level arithmetic operations

These functions are implemented in C and for several platforms in
assembly language:

bn_mul_words(B<rp>, B<ap>, B<num>, B<w>) operates on the B<num> word
arrays B<rp> and B<ap>.  It computes B<ap> * B<w>, places the result
in B<rp>, and returns the high word (carry).

bn_mul_add_words(B<rp>, B<ap>, B<num>, B<w>) operates on the B<num>
word arrays B<rp> and B<ap>.  It computes B<ap> * B<w> + B<rp>, places
the result in B<rp>, and returns the high word (carry).

bn_sqr_words(B<rp>, B<ap>, B<n>) operates on the B<num> word array
B<ap> and the 2*B<num> word array B<ap>.  It computes B<ap> * B<ap>
word-wise, and places the low and high bytes of the result in B<rp>.

bn_div_words(B<h>, B<l>, B<d>) divides the two word number (B<h>,B<l>)
by B<d> and returns the result.

bn_add_words(B<rp>, B<ap>, B<bp>, B<num>) operates on the B<num> word
arrays B<ap>, B<bp> and B<rp>.  It computes B<ap> + B<bp>, places the
result in B<rp>, and returns the high word (carry).

bn_sub_words(B<rp>, B<ap>, B<bp>, B<num>) operates on the B<num> word
arrays B<ap>, B<bp> and B<rp>.  It computes B<ap> - B<bp>, places the
result in B<rp>, and returns the carry (1 if B<bp> E<gt> B<ap>, 0
otherwise).

bn_mul_comba4(B<r>, B<a>, B<b>) operates on the 4 word arrays B<a> and
B<b> and the 8 word array B<r>.  It computes B<a>*B<b> and places the
result in B<r>.

bn_mul_comba8(B<r>, B<a>, B<b>) operates on the 8 word arrays B<a> and
B<b> and the 16 word array B<r>.  It computes B<a>*B<b> and places the
result in B<r>.

bn_sqr_comba4(B<r>, B<a>, B<b>) operates on the 4 word arrays B<a> and
B<b> and the 8 word array B<r>.

bn_sqr_comba8(B<r>, B<a>, B<b>) operates on the 8 word arrays B<a> and
B<b> and the 16 word array B<r>.

The following functions are implemented in C:

bn_cmp_words(B<a>, B<b>, B<n>) operates on the B<n> word arrays B<a>
and B<b>.  It returns 1, 0 and -1 if B<a> is greater than, equal and
less than B<b>.

bn_mul_normal(B<r>, B<a>, B<na>, B<b>, B<nb>) operates on the B<na>
word array B<a>, the B<nb> word array B<b> and the B<na>+B<nb> word
array B<r>.  It computes B<a>*B<b> and places the result in B<r>.

bn_mul_low_normal(B<r>, B<a>, B<b>, B<n>) operates on the B<n> word
arrays B<r>, B<a> and B<b>.  It computes the B<n> low words of
B<a>*B<b> and places the result in B<r>.

bn_mul_recursive(B<r>, B<a>, B<b>, B<n2>, B<dna>, B<dnb>, B<t>) operates
on the word arrays B<a> and B<b> of length B<n2>+B<dna> and B<n2>+B<dnb>
(B<dna> and B<dnb> are currently allowed to be 0 or negative) and the 2*B<n2>
word arrays B<r> and B<t>.  B<n2> must be a power of 2.  It computes
B<a>*B<b> and places the result in B<r>.

bn_mul_part_recursive(B<r>, B<a>, B<b>, B<n>, B<tna>, B<tnb>, B<tmp>)
operates on the word arrays B<a> and B<b> of length B<n>+B<tna> and
B<n>+B<tnb> and the 4*B<n> word arrays B<r> and B<tmp>.

bn_mul_low_recursive(B<r>, B<a>, B<b>, B<n2>, B<tmp>) operates on the
B<n2> word arrays B<r> and B<tmp> and the B<n2>/2 word arrays B<a>
and B<b>.

bn_mul_high(B<r>, B<a>, B<b>, B<l>, B<n2>, B<tmp>) operates on the
B<n2> word arrays B<r>, B<a>, B<b> and B<l> (?) and the 3*B<n2> word
array B<tmp>.

BN_mul() calls bn_mul_normal(), or an optimized implementation if the
factors have the same size: bn_mul_comba8() is used if they are 8
words long, bn_mul_recursive() if they are larger than
B<BN_MULL_SIZE_NORMAL> and the size is an exact multiple of the word
size, and bn_mul_part_recursive() for others that are larger than
B<BN_MULL_SIZE_NORMAL>.

bn_sqr_normal(B<r>, B<a>, B<n>, B<tmp>) operates on the B<n> word array
B<a> and the 2*B<n> word arrays B<tmp> and B<r>.

The implementations use the following macros which, depending on the
architecture, may use "long long" C operations or inline assembler.
They are defined in C<bn_lcl.h>.

mul(B<r>, B<a>, B<w>, B<c>) computes B<w>*B<a>+B<c> and places the
low word of the result in B<r> and the high word in B<c>.

mul_add(B<r>, B<a>, B<w>, B<c>) computes B<w>*B<a>+B<r>+B<c> and
places the low word of the result in B<r> and the high word in B<c>.

sqr(B<r0>, B<r1>, B<a>) computes B<a>*B<a> and places the low word
of the result in B<r0> and the high word in B<r1>.

=head2 Size changes

bn_expand() ensures that B<b> has enough space for a B<bits> bit
number.  bn_wexpand() ensures that B<b> has enough space for an
B<n> word number.  If the number has to be expanded, both macros
call bn_expand2(), which allocates a new B<d> array and copies the
data.  They return B<NULL> on error, B<b> otherwise.

The bn_fix_top() macro reduces B<a-E<gt>top> to point to the most
significant non-zero word plus one when B<a> has shrunk.

=head2 Debugging

bn_check_top() verifies that C<((a)-E<gt>top E<gt>= 0 && (a)-E<gt>top
E<lt>= (a)-E<gt>dmax)>.  A violation will cause the program to abort.

bn_print() prints B<a> to stderr. bn_dump() prints B<n> words at B<d>
(in reverse order, i.e. most significant word first) to stderr.

bn_set_max() makes B<a> a static number with a B<dmax> of its current size.
This is used by bn_set_low() and bn_set_high() to make B<r> a read-only
B<BIGNUM> that contains the B<n> low or high words of B<a>.

If B<BN_DEBUG> is not defined, bn_check_top(), bn_print(), bn_dump()
and bn_set_max() are defined as empty macros.

=head1 SEE ALSO

L<bn(3)|bn(3)>

=cut
@


1.8
log
@add missing functions to NAME, or otherwise correct the mlink
entry for them;

feedback/ok schwarze
@
text
@@


1.7
log
@Remove trailing whitespace.

fine jmc@@
@
text
@d11 2
a12 2
bn_print, bn_dump, bn_set_max, bn_set_high, bn_set_low - BIGNUM
library internal functions
@


1.6
log
@resolve conflicts, fix local changes
@
text
@d98 2
a99 2
B<flags> is a bit field of flags which are defined in C<openssl/bn.h>. The 
flags begin with B<BN_FLG_>. The macros BN_set_flags(b,n) and 
@


1.5
log
@resolve conflicts
@
text
@d16 2
d75 3
a77 1
 typedef struct bignum_st
d79 8
a86 5
        int top;      /* number of words used in d */
        BN_ULONG *d;  /* pointer to an array containing the integer value */
        int max;      /* size of the d array */
        int neg;      /* sign */
        } BIGNUM;
d93 1
a93 1
B<max> is the size of the B<d> array that has been allocated.  B<top>
d98 5
d222 1
a222 1
E<lt>= (a)-E<gt>max)>.  A violation will cause the program to abort.
d227 1
a227 1
bn_set_max() makes B<a> a static number with a B<max> of its current size.
@


1.4
log
@god these guys have low quality control
@
text
@d75 2
a76 2
        int top;      /* index of last used d (most significant word) */
        BN_ULONG *d;  /* pointer to an array of 'BITS2' bit chunks */
d81 3
a83 3
The big number is stored in B<d>, a malloc()ed array of B<BN_ULONG>s,
least significant first. A B<BN_ULONG> can be either 16, 32 or 64 bits
in size (B<BITS2>), depending on the 'number of bits' specified in
d87 1
a87 1
is the 'last' entry being used, so for a value of 4, bn.d[0]=4 and
d205 1
a205 1
significant non-zero word when B<a> has shrunk.
@


1.3
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d161 1
a161 1
bn_mul_part_recursive(B<r>, B<a>, B<b>, B<n>, B<tna>, B<tnb, B<tmp>)
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d37 1
a37 1
   BN_ULONG *tmp);
d39 1
a39 1
   int tn, int n, BN_ULONG *tmp);
d155 5
a159 4
bn_mul_recursive(B<r>, B<a>, B<b>, B<n2>, B<t>) operates on the B<n2>
word arrays B<a> and B<b> and the 2*B<n2> word arrays B<r> and B<t>.
B<n2> must be a power of 2.  It computes B<a>*B<b> and places the
result in B<r>.
d161 3
a163 3
bn_mul_part_recursive(B<r>, B<a>, B<b>, B<tn>, B<n>, B<tmp>) operates
on the B<n>+B<tn> word arrays B<a> and B<b> and the 4*B<n> word arrays
B<r> and B<tmp>.
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d152 1
a152 1
arrays B<r>, B<a> und B<b>.  It computes the B<n> low words of
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d37 1
a37 1
   int dna,int dnb,BN_ULONG *tmp);
d39 1
a39 1
   int n, int tna,int tnb, BN_ULONG *tmp);
d152 1
a152 1
arrays B<r>, B<a> and B<b>.  It computes the B<n> low words of
d155 4
a158 5
bn_mul_recursive(B<r>, B<a>, B<b>, B<n2>, B<dna>, B<dnb>, B<t>) operates
on the word arrays B<a> and B<b> of length B<n2>+B<dna> and B<n2>+B<dnb>
(B<dna> and B<dnb> are currently allowed to be 0 or negative) and the 2*B<n2>
word arrays B<r> and B<t>.  B<n2> must be a power of 2.  It computes
B<a>*B<b> and places the result in B<r>.
d160 3
a162 3
bn_mul_part_recursive(B<r>, B<a>, B<b>, B<n>, B<tna>, B<tnb>, B<tmp>)
operates on the word arrays B<a> and B<b> of length B<n>+B<tna> and
B<n>+B<tnb> and the 4*B<n> word arrays B<r> and B<tmp>.
@


1.1.1.2
log
@import of OpenSSL 0.9.8h
@
text
@d75 2
a76 2
        int top;      /* number of words used in d */
        BN_ULONG *d;  /* pointer to an array containing the integer value */
d81 3
a83 3
The integer value is stored in B<d>, a malloc()ed array of words (B<BN_ULONG>),
least significant word first. A B<BN_ULONG> can be either 16, 32 or 64 bits
in size, depending on the 'number of bits' (B<BITS2>) specified in
d87 1
a87 1
is the number of words being used, so for a value of 4, bn.d[0]=4 and
d205 1
a205 1
significant non-zero word plus one when B<a> has shrunk.
@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@a15 2
 #include <openssl/bn.h>

d73 1
a73 3
 typedef struct bignum_st BIGNUM;

 struct bignum_st
d75 5
a79 8
        BN_ULONG *d;    /* Pointer to an array of 'BN_BITS2' bit chunks. */
        int top;        /* Index of last used d +1. */
        /* The next are internal book keeping for bn_expand. */
        int dmax;       /* Size of the d array. */
        int neg;        /* one if the number is negative */
        int flags;
        };

d86 1
a86 1
B<dmax> is the size of the B<d> array that has been allocated.  B<top>
a90 5
B<flags> is a bit field of flags which are defined in C<openssl/bn.h>. The 
flags begin with B<BN_FLG_>. The macros BN_set_flags(b,n) and 
BN_get_flags(b,n) exist to enable or fetch flag(s) B<n> from B<BIGNUM>
structure B<b>.

d210 1
a210 1
E<lt>= (a)-E<gt>dmax)>.  A violation will cause the program to abort.
d215 1
a215 1
bn_set_max() makes B<a> a static number with a B<dmax> of its current size.
@


