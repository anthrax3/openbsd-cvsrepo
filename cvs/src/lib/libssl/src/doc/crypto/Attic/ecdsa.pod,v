head	1.7;
access;
symbols
	OPENBSD_5_8:1.5.0.8
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	butholakala:1.1.1.3
	openssl_1_0_1_g:1.1.1.3
	OPENSSL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.8
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.4
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.2
	OPENBSD_5_3_BASE:1.1.1.2
	openssl_1_0_1_c:1.1.1.2
	OPENBSD_5_2:1.1.1.1.0.14
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.16
	openssl_1_0_0_f:1.1.1.1
	openssl_1_0_0_e:1.1.1.1
	OPENBSD_5_0:1.1.1.1.0.12
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.10
	OPENBSD_4_9_BASE:1.1.1.1
	openssh_1_0_0_a:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	openssl_0_9_8_k:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	openssl_0_9_8_j:1.1.1.1
	openssl_0_9_8_h:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2015.11.12.00.55.49;	author schwarze;	state dead;
branches;
next	1.6;
commitid	RO3YWQP7BDJs4F8k;

1.6
date	2015.11.11.22.14.40;	author jmc;	state Exp;
branches;
next	1.5;
commitid	eNNq8UNxWW0rsWWg;

1.5
date	2014.07.13.15.42.42;	author miod;	state Exp;
branches;
next	1.4;
commitid	cdCNtFiqR1YHopHz;

1.4
date	2014.07.11.16.18.14;	author miod;	state Exp;
branches;
next	1.3;
commitid	KFr43un1Uq8AaqNL;

1.3
date	2014.07.10.14.14.04;	author miod;	state Exp;
branches;
next	1.2;
commitid	VVoKhghxvV7qSanI;

1.2
date	2014.05.04.21.46.36;	author jim;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.49;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.49;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.10.13.21.23.47;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.04.13.15.16.35;	author miod;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Convert the handful of manuals that had imaginary names,
give them names that really exist.
This also helps jmc@@'s ongoing work on improving NAME sections.
@
text
@=pod

=head1 NAME

ECDSA_SIG_new, ECDSA_SIG_free, i2d_ECDSA_SIG, d2i_ECDSA_SIG,
ECDSA_size, ECDSA_sign_setup, ECDSA_sign, ECDSA_sign_ex,
ECDSA_verify, ECDSA_do_sign, ECDSA_do_sign_ex, ECDSA_do_verify,
ECDSA_OpenSSL, ECDSA_get_default_method, ECDSA_get_ex_data,
ECDSA_get_ex_new_index, ECDSA_set_default_method, ECDSA_set_ex_data,
ECDSA_set_method - Elliptic Curve Digital Signature Algorithm

=head1 SYNOPSIS

 #include <openssl/ecdsa.h>

 ECDSA_SIG*	ECDSA_SIG_new(void);
 void		ECDSA_SIG_free(ECDSA_SIG *sig);
 int		i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);
 ECDSA_SIG*	d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp,
		long len);

 ECDSA_SIG*	ECDSA_do_sign(const unsigned char *dgst, int dgst_len,
			EC_KEY *eckey);
 ECDSA_SIG*	ECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen,
			const BIGNUM *kinv, const BIGNUM *rp,
			EC_KEY *eckey);
 int		ECDSA_do_verify(const unsigned char *dgst, int dgst_len,
			const ECDSA_SIG *sig, EC_KEY* eckey);
 int		ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx,
			BIGNUM **kinv, BIGNUM **rp);
 int		ECDSA_sign(int type, const unsigned char *dgst,
			int dgstlen, unsigned char *sig,
			unsigned int *siglen, EC_KEY *eckey);
 int		ECDSA_sign_ex(int type, const unsigned char *dgst,
			int dgstlen, unsigned char *sig,
			unsigned int *siglen, const BIGNUM *kinv,
			const BIGNUM *rp, EC_KEY *eckey);
 int		ECDSA_verify(int type, const unsigned char *dgst,
			int dgstlen, const unsigned char *sig,
			int siglen, EC_KEY *eckey);
 int		ECDSA_size(const EC_KEY *eckey);

 const ECDSA_METHOD*	ECDSA_OpenSSL(void);
 void		ECDSA_set_default_method(const ECDSA_METHOD *meth);
 const ECDSA_METHOD*	ECDSA_get_default_method(void);
 int		ECDSA_set_method(EC_KEY *eckey,const ECDSA_METHOD *meth);

 int		ECDSA_get_ex_new_index(long argl, void *argp,
			CRYPTO_EX_new *new_func,
			CRYPTO_EX_dup *dup_func,
			CRYPTO_EX_free *free_func);
 int		ECDSA_set_ex_data(EC_KEY *d, int idx, void *arg);
 void*		ECDSA_get_ex_data(EC_KEY *d, int idx);

=head1 DESCRIPTION

The B<ECDSA_SIG> structure consists of two BIGNUMs for the
r and s value of a ECDSA signature (see X9.62 or FIPS 186-2).

 struct
	{
	BIGNUM *r;
	BIGNUM *s;
 } ECDSA_SIG;

ECDSA_SIG_new() allocates a new B<ECDSA_SIG> structure (note: this
function also allocates the BIGNUMs) and initialize it.

ECDSA_SIG_free() frees the B<ECDSA_SIG> structure B<sig>.

i2d_ECDSA_SIG() creates the DER encoding of the ECDSA signature
B<sig> and writes the encoded signature to B<*pp> (note: if B<pp>
is NULL B<i2d_ECDSA_SIG> returns the expected length in bytes of
the DER encoded signature). B<i2d_ECDSA_SIG> returns the length
of the DER encoded signature (or 0 on error).

d2i_ECDSA_SIG() decodes a DER encoded ECDSA signature and returns
the decoded signature in a newly allocated B<ECDSA_SIG> structure.
B<*sig> points to the buffer containing the DER encoded signature
of size B<len>.

ECDSA_size() returns the maximum length of a DER encoded
ECDSA signature created with the private EC key B<eckey>.

ECDSA_sign_setup() may be used to precompute parts of the
signing operation. B<eckey> is the private EC key and B<ctx>
is a pointer to B<BN_CTX> structure (or NULL). The precomputed
values or returned in B<kinv> and B<rp> and can be used in a
later call to B<ECDSA_sign_ex> or B<ECDSA_do_sign_ex>.

ECDSA_sign() is wrapper function for ECDSA_sign_ex with B<kinv>
and B<rp> set to NULL.

ECDSA_sign_ex() computes a digital signature of the B<dgstlen> bytes
hash value B<dgst> using the private EC key B<eckey> and the optional
pre-computed values B<kinv> and B<rp>. The DER encoded signatures is
stored in B<sig> and it's length is returned in B<sig_len>. Note: B<sig>
must point to B<ECDSA_size> bytes of memory. The parameter B<type>
is ignored.

ECDSA_verify() verifies that the signature in B<sig> of size
B<siglen> is a valid ECDSA signature of the hash value
B<dgst> of size B<dgstlen> using the public key B<eckey>.
The parameter B<type> is ignored.

ECDSA_do_sign() is wrapper function for ECDSA_do_sign_ex with B<kinv>
and B<rp> set to NULL.

ECDSA_do_sign_ex() computes a digital signature of the B<dgst_len>
bytes hash value B<dgst> using the private key B<eckey> and the
optional pre-computed values B<kinv> and B<rp>. The signature is
returned in a newly allocated B<ECDSA_SIG> structure (or NULL on error).

ECDSA_do_verify() verifies that the signature B<sig> is a valid
ECDSA signature of the hash value B<dgst> of size B<dgst_len>
using the public key B<eckey>.

=head1 RETURN VALUES

ECDSA_size() returns the maximum length signature or 0 on error.

ECDSA_sign_setup() and ECDSA_sign() return 1 if successful or 0
on error.

ECDSA_verify() and ECDSA_do_verify() return 1 for a valid
signature, 0 for an invalid signature and -1 on error.
The error codes can be obtained by L<ERR_get_error(3)|ERR_get_error(3)>.

=head1 EXAMPLES

Creating a ECDSA signature of given SHA-1 hash value using the
named curve secp192k1.

First step: create a EC_KEY object (note: this part is B<not> ECDSA
specific)

 int ret;
 ECDSA_SIG *sig;
 EC_KEY *eckey;

 eckey = EC_KEY_new_by_curve_name(NID_secp192k1);
 if (eckey == NULL) {
	/* error */
 }
 if (!EC_KEY_generate_key(eckey)) {
	/* error */
 }

Second step: compute the ECDSA signature of a SHA-1 hash value
using B<ECDSA_do_sign>

 sig = ECDSA_do_sign(digest, 20, eckey);
 if (sig == NULL) {
	/* error */
 }

or using B<ECDSA_sign>

 unsigned char *buffer, *pp;
 int buf_len;

 buf_len = ECDSA_size(eckey);
 buffer  = malloc(buf_len);
 pp = buffer;
 if (!ECDSA_sign(0, dgst, dgstlen, pp, &buf_len, eckey) {
	/* error */
 }

Third step: verify the created ECDSA signature using B<ECDSA_do_verify>

 ret = ECDSA_do_verify(digest, 20, sig, eckey);

or using B<ECDSA_verify>

 ret = ECDSA_verify(0, digest, 20, buffer, buf_len, eckey);

and finally evaluate the return value:

 if (ret == -1) {
	/* error */
 } else if (ret == 0) {
	/* incorrect signature */
 } else	{
	/* ret == 1 */
	/* signature ok */
 }

=head1 CONFORMING TO

ANSI X9.62, US Federal Information Processing Standard FIPS 186-2
(Digital Signature Standard, DSS)

=head1 SEE ALSO

L<dsa(3)|dsa(3)>, L<rsa(3)|rsa(3)>

=head1 HISTORY

The ecdsa implementation was first introduced in OpenSSL 0.9.8

=head1 AUTHOR

Nils Larsch for the OpenSSL project (http://www.openssl.org).

=cut
@


1.6
log
@add missing functions to NAME, or otherwise correct the mlink
entry for them;

feedback/ok schwarze
@
text
@@


1.5
log
@OPENSSL_{malloc,free} -> {malloc,free}
@
text
@d5 6
a10 1
ECDSA_SIG_new, ECDSA_SIG_free, i2d_ECDSA_SIG, d2i_ECDSA_SIG, ECDSA_size, ECDSA_sign_setup, ECDSA_sign, ECDSA_sign_ex, ECDSA_verify, ECDSA_do_sign, ECDSA_do_sign_ex, ECDSA_do_verify - Elliptic Curve Digital Signature Algorithm
@


1.4
log
@Huge documentation update for libcrypto and libssl, mostly from Matt Caswell,
Jeff Trawick, Jean-Paul Calderone, Michal Bozon, Jeffrey Walton and Rich Salz,
via OpenSSL trunk (with some parts not applying to us, such as SSLv2 support,
at least partially removed).
@
text
@d158 1
a158 1
 buffer  = OPENSSL_malloc(buf_len);
@


1.3
log
@Try and fix the horrible coding style of the example code snippets.
@
text
@d5 1
a5 1
ecdsa - Elliptic Curve Digital Signature Algorithm
@


1.2
log
@Remove trailing whitespace.

fine jmc@@
@
text
@d132 1
a132 1
 int        ret;
d134 2
a135 1
 EC_KEY    *eckey;
d137 1
a137 2
 if (eckey == NULL)
	{
d139 2
a140 3
	}
 if (!EC_KEY_generate_key(eckey))
	{
d142 1
a142 1
	}
d148 1
a148 2
 if (sig == NULL)
	{
d150 1
a150 1
	}
d155 2
a156 1
 int            buf_len;
d160 1
a160 2
 if (!ECDSA_sign(0, dgst, dgstlen, pp, &buf_len, eckey);
	{
d162 1
a162 1
	}
d174 1
a174 2
 if (ret == -1)
	{
d176 1
a176 3
	}
 else if (ret == 0)
	{
d178 2
a179 3
	}
 else	/* ret == 1 */
	{
d181 1
a181 1
	}
@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
 ECDSA_SIG*	d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, 
d19 1
a19 1
 ECDSA_SIG*	ECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen, 
d31 1
a31 1
			unsigned int *siglen, const BIGNUM *kinv, 
d68 1
a68 1
is NULL B<i2d_ECDSA_SIG> returns the expected length in bytes of 
d98 1
a98 1
value B<dgst> of size B<dgstlen> using the public key B<eckey>.
d117 1
a117 1
ECDSA_sign_setup() and ECDSA_sign() return 1 if successful or -1
d134 2
a135 1
 EC_KEY    *eckey = EC_KEY_new();
a139 5
 key->group = EC_GROUP_new_by_nid(NID_secp192k1);
 if (key->group == NULL)
	{
	/* error */
	}
d145 2
a146 2
Second step: compute the ECDSA signature of a SHA-1 hash value 
using B<ECDSA_do_sign> 
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.1c
@
text
@d117 1
a117 1
ECDSA_sign_setup() and ECDSA_sign() return 1 if successful or 0
@


1.1.1.3
log
@Import OpenSSL 1.0.1g
@
text
@d98 1
a98 1
B<dgst> of size B<dgstlen> using the public key B<eckey>.
d134 1
a134 2
 EC_KEY    *eckey;
 eckey = EC_KEY_new_by_curve_name(NID_secp192k1);
d136 5
@


