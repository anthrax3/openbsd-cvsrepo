head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	butholakala:1.5
	openssl_1_0_1_g:1.1.1.3
	OPENBSD_5_5:1.5.0.16
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.12
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.10
	OPENBSD_5_3_BASE:1.5
	openssl_1_0_1_c:1.1.1.3
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.8
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.3
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.4.0.34
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.30
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.32
	OPENBSD_4_6_BASE:1.4
	openssl_0_9_8_k:1.1.1.2
	OPENBSD_4_5:1.4.0.28
	OPENBSD_4_5_BASE:1.4
	openssl_0_9_8_j:1.1.1.2
	openssl_0_9_8_h:1.1.1.2
	pre_openssl_0_9_8h:1.4
	OPENBSD_4_4:1.4.0.26
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.24
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.22
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.20
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.18
	OPENBSD_4_0_BASE:1.4
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.2.0.6
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@# @;


1.8
date	2015.11.12.00.55.49;	author schwarze;	state dead;
branches;
next	1.7;
commitid	RO3YWQP7BDJs4F8k;

1.7
date	2014.05.04.22.26.33;	author jim;	state Exp;
branches;
next	1.6;

1.6
date	2014.05.04.21.46.36;	author jim;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.01.22.58.58;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.10.16.31.56;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.15.02.29.19;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.58.31;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.13.01;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.18;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.43.25;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.14;	author djm;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Convert the handful of manuals that had imaginary names,
give them names that really exist.
This also helps jmc@@'s ongoing work on improving NAME sections.
@
text
@=pod

=head1 NAME

lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg,
lh_error - dynamic hash table

=head1 SYNOPSIS

 #include <openssl/lhash.h>

 DECLARE_LHASH_OF(<type>);

 LHASH *lh_<type>_new();
 void lh_<type>_free(LHASH_OF(<type> *table);

 <type> *lh_<type>_insert(LHASH_OF(<type> *table, <type> *data);
 <type> *lh_<type>_delete(LHASH_OF(<type> *table, <type> *data);
 <type> *lh_retrieve(LHASH_OF<type> *table, <type> *data);

 void lh_<type>_doall(LHASH_OF(<type> *table, LHASH_DOALL_FN_TYPE func);
 void lh_<type>_doall_arg(LHASH_OF(<type> *table, LHASH_DOALL_ARG_FN_TYPE func,
          <type2>, <type2> *arg);

 int lh_<type>_error(LHASH_OF(<type> *table);

 typedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);
 typedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);
 typedef void (*LHASH_DOALL_FN_TYPE)(const void *);
 typedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const void *);

=head1 DESCRIPTION

This library implements type-checked dynamic hash tables. The hash
table entries can be arbitrary structures. Usually they consist of key
and value fields.

lh_<type>_new() creates a new B<LHASH_OF(<type>> structure to store
arbitrary data entries, and provides the 'hash' and 'compare'
callbacks to be used in organising the table's entries.  The B<hash>
callback takes a pointer to a table entry as its argument and returns
an unsigned long hash value for its key field.  The hash value is
normally truncated to a power of 2, so make sure that your hash
function returns well mixed low order bits.  The B<compare> callback
takes two arguments (pointers to two hash table entries), and returns
0 if their keys are equal, non-zero otherwise.  If your hash table
will contain items of some particular type and the B<hash> and
B<compare> callbacks hash/compare these types, then the
B<DECLARE_LHASH_HASH_FN> and B<IMPLEMENT_LHASH_COMP_FN> macros can be
used to create callback wrappers of the prototypes required by
lh_<type>_new().  These provide per-variable casts before calling the
type-specific callbacks written by the application author.  These
macros, as well as those used for the "doall" callbacks, are defined
as;

 #define DECLARE_LHASH_HASH_FN(name, o_type) \
	 unsigned long name##_LHASH_HASH(const void *);
 #define IMPLEMENT_LHASH_HASH_FN(name, o_type) \
	 unsigned long name##_LHASH_HASH(const void *arg) { \
		 const o_type *a = arg; \
		 return name##_hash(a); }
 #define LHASH_HASH_FN(name) name##_LHASH_HASH

 #define DECLARE_LHASH_COMP_FN(name, o_type) \
	 int name##_LHASH_COMP(const void *, const void *);
 #define IMPLEMENT_LHASH_COMP_FN(name, o_type) \
	 int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
		 const o_type *a = arg1;		    \
		 const o_type *b = arg2; \
		 return name##_cmp(a,b); }
 #define LHASH_COMP_FN(name) name##_LHASH_COMP

 #define DECLARE_LHASH_DOALL_FN(name, o_type) \
	 void name##_LHASH_DOALL(void *);
 #define IMPLEMENT_LHASH_DOALL_FN(name, o_type) \
	 void name##_LHASH_DOALL(void *arg) { \
		 o_type *a = arg; \
		 name##_doall(a); }
 #define LHASH_DOALL_FN(name) name##_LHASH_DOALL

 #define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \
	 void name##_LHASH_DOALL_ARG(void *, void *);
 #define IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \
	 void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \
		 o_type *a = arg1; \
		 a_type *b = arg2; \
		 name##_doall_arg(a, b); }
 #define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG

 An example of a hash table storing (pointers to) structures of type 'STUFF'
 could be defined as follows;

 /* Calculates the hash value of 'tohash' (implemented elsewhere) */
 unsigned long STUFF_hash(const STUFF *tohash);
 /* Orders 'arg1' and 'arg2' (implemented elsewhere) */
 int stuff_cmp(const STUFF *arg1, const STUFF *arg2);
 /* Create the type-safe wrapper functions for use in the LHASH internals */
 static IMPLEMENT_LHASH_HASH_FN(stuff, STUFF);
 static IMPLEMENT_LHASH_COMP_FN(stuff, STUFF);
 /* ... */
 int main(int argc, char *argv[]) {
         /* Create the new hash table using the hash/compare wrappers */
         LHASH_OF(STUFF) *hashtable = lh_STUFF_new(LHASH_HASH_FN(STUFF_hash),
                                   LHASH_COMP_FN(STUFF_cmp));
	 /* ... */
 }

lh_<type>_free() frees the B<LHASH_OF(<type>> structure
B<table>. Allocated hash table entries will not be freed; consider
using lh_<type>_doall() to deallocate any remaining entries in the
hash table (see below).

lh_<type>_insert() inserts the structure pointed to by B<data> into
B<table>.  If there already is an entry with the same key, the old
value is replaced. Note that lh_<type>_insert() stores pointers, the
data are not copied.

lh_<type>_delete() deletes an entry from B<table>.

lh_<type>_retrieve() looks up an entry in B<table>. Normally, B<data>
is a structure with the key field(s) set; the function will return a
pointer to a fully populated structure.

lh_<type>_doall() will, for every entry in the hash table, call
B<func> with the data item as its parameter.  For lh_<type>_doall()
and lh_<type>_doall_arg(), function pointer casting should be avoided
in the callbacks (see B<NOTE>) - instead use the declare/implement
macros to create type-checked wrappers that cast variables prior to
calling your type-specific callbacks.  An example of this is
illustrated here where the callback is used to cleanup resources for
items in the hash table prior to the hashtable itself being
deallocated:

 /* Cleans up resources belonging to 'a' (this is implemented elsewhere) */
 void STUFF_cleanup_doall(STUFF *a);
 /* Implement a prototype-compatible wrapper for "STUFF_cleanup" */
 IMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF)
         /* ... then later in the code ... */
 /* So to run "STUFF_cleanup" against all items in a hash table ... */
 lh_STUFF_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup));
 /* Then the hash table itself can be deallocated */
 lh_STUFF_free(hashtable);

When doing this, be careful if you delete entries from the hash table
in your callbacks: the table may decrease in size, moving the item
that you are currently on down lower in the hash table - this could
cause some entries to be skipped during the iteration.  The second
best solution to this problem is to set hash-E<gt>down_load=0 before
you start (which will stop the hash table ever decreasing in size).
The best solution is probably to avoid deleting items from the hash
table inside a "doall" callback!

lh_<type>_doall_arg() is the same as lh_<type>_doall() except that
B<func> will be called with B<arg> as the second argument and B<func>
should be of type B<LHASH_DOALL_ARG_FN_TYPE> (a callback prototype
that is passed both the table entry and an extra argument).  As with
lh_doall(), you can instead choose to declare your callback with a
prototype matching the types you are dealing with and use the
declare/implement macros to create compatible wrappers that cast
variables before calling your type-specific callbacks.  An example of
this is demonstrated here (printing all hash table entries to a BIO
that is provided by the caller):

 /* Prints item 'a' to 'output_bio' (this is implemented elsewhere) */
 void STUFF_print_doall_arg(const STUFF *a, BIO *output_bio);
 /* Implement a prototype-compatible wrapper for "STUFF_print" */
 static IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF, const STUFF, BIO)
         /* ... then later in the code ... */
 /* Print out the entire hashtable to a particular BIO */
 lh_STUFF_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), BIO,
                    logging_bio);

lh_<type>_error() can be used to determine if an error occurred in the last
operation. lh_<type>_error() is a macro.

=head1 RETURN VALUES

lh_<type>_new() returns B<NULL> on error, otherwise a pointer to the new
B<LHASH> structure.

When a hash table entry is replaced, lh_<type>_insert() returns the value
being replaced. B<NULL> is returned on normal operation and on error.

lh_<type>_delete() returns the entry being deleted.  B<NULL> is returned if
there is no such value in the hash table.

lh_<type>_retrieve() returns the hash table entry if it has been found,
B<NULL> otherwise.

lh_<type>_error() returns 1 if an error occurred in the last operation, 0
otherwise.

lh_<type>_free(), lh_<type>_doall() and lh_<type>_doall_arg() return no values.

=head1 NOTE

The various LHASH macros and callback types exist to make it possible
to write type-checked code without resorting to function-prototype
casting - an evil that makes application code much harder to
audit/verify and also opens the window of opportunity for stack
corruption and other hard-to-find bugs.  It also, apparently, violates
ANSI-C.

The LHASH code regards table entries as constant data.  As such, it
internally represents lh_insert()'d items with a "const void *"
pointer type.  This is why callbacks such as those used by lh_doall()
and lh_doall_arg() declare their prototypes with "const", even for the
parameters that pass back the table items' data pointers - for
consistency, user-provided data is "const" at all times as far as the
LHASH code is concerned.  However, as callers are themselves providing
these pointers, they can choose whether they too should be treating
all such parameters as constant.

As an example, a hash table may be maintained by code that, for
reasons of encapsulation, has only "const" access to the data being
indexed in the hash table (ie. it is returned as "const" from
elsewhere in their code) - in this case the LHASH prototypes are
appropriate as-is.  Conversely, if the caller is responsible for the
life-time of the data in question, then they may well wish to make
modifications to table item passed back in the lh_doall() or
lh_doall_arg() callbacks (see the "STUFF_cleanup" example above).  If
so, the caller can either cast the "const" away (if they're providing
the raw callbacks themselves) or use the macros to declare/implement
the wrapper functions without "const" types.

Callers that only have "const" access to data they're indexing in a
table, yet declare callbacks without constant types (or cast the
"const" away themselves), are therefore creating their own risks/bugs
without being encouraged to do so by the API.  On a related note,
those auditing code should pay special attention to any instances of
DECLARE/IMPLEMENT_LHASH_DOALL_[ARG_]_FN macros that provide types
without any "const" qualifiers.

=head1 BUGS

lh_<type>_insert() returns B<NULL> both for success and error.

=head1 INTERNALS

The following description is based on the SSLeay documentation:

The B<lhash> library implements a hash table described in the
I<Communications of the ACM> in 1991.  What makes this hash table
different is that as the table fills, the hash table is increased (or
decreased) in size via OPENSSL_realloc().  When a 'resize' is done, instead of
all hashes being redistributed over twice as many 'buckets', one
bucket is split.  So when an 'expand' is done, there is only a minimal
cost to redistribute some values.  Subsequent inserts will cause more
single 'bucket' redistributions but there will never be a sudden large
cost due to redistributing all the 'buckets'.

The state for a particular hash table is kept in the B<LHASH> structure.
The decision to increase or decrease the hash table size is made
depending on the 'load' of the hash table.  The load is the number of
items in the hash table divided by the size of the hash table.  The
default values are as follows.  If (hash->up_load E<lt> load) =E<gt>
expand.  if (hash-E<gt>down_load E<gt> load) =E<gt> contract.  The
B<up_load> has a default value of 1 and B<down_load> has a default value
of 2.  These numbers can be modified by the application by just
playing with the B<up_load> and B<down_load> variables.  The 'load' is
kept in a form which is multiplied by 256.  So
hash-E<gt>up_load=8*256; will cause a load of 8 to be set.

If you are interested in performance the field to watch is
num_comp_calls.  The hash library keeps track of the 'hash' value for
each item so when a lookup is done, the 'hashes' are compared, if
there is a match, then a full compare is done, and
hash-E<gt>num_comp_calls is incremented.  If num_comp_calls is not equal
to num_delete plus num_retrieve it means that your hash function is
generating hashes that are the same for different values.  It is
probably worth changing your hash function if this is the case because
even if your hash table has 10 items in a 'bucket', it can be searched
with 10 B<unsigned long> compares and 10 linked list traverses.  This
will be much less expensive that 10 calls to your compare function.

lh_strhash() is a demo string hashing function:

 unsigned long lh_strhash(const char *c);

Since the B<LHASH> routines would normally be passed structures, this
routine would not normally be passed to lh_<type>_new(), rather it would be
used in the function passed to lh_<type>_new().

=head1 SEE ALSO

L<lh_stats(3)|lh_stats(3)>

=head1 HISTORY

The B<lhash> library is available in all versions of SSLeay and OpenSSL.
lh_error() was added in SSLeay 0.9.1b.

This manpage is derived from the SSLeay documentation.

In OpenSSL 0.9.7, all lhash functions that were passed function pointers
were changed for better type safety, and the function types LHASH_COMP_FN_TYPE,
LHASH_HASH_FN_TYPE, LHASH_DOALL_FN_TYPE and LHASH_DOALL_ARG_FN_TYPE
became available.

In OpenSSL 1.0.0, the lhash interface was revamped for even better
type checking.

=cut
@


1.7
log
@Improve line wrapping for lines exceeding 80 chars.

ok jmc@@
@
text
@@


1.6
log
@Remove trailing whitespace.

fine jmc@@
@
text
@d5 2
a6 1
lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg, lh_error - dynamic hash table
@


1.5
log
@resolve conflicts, fix local changes
@
text
@d171 1
a171 1
 
d296 1
a296 1
LHASH_HASH_FN_TYPE, LHASH_DOALL_FN_TYPE and LHASH_DOALL_ARG_FN_TYPE 
@


1.4
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d11 1
a11 2
 LHASH *lh_new(LHASH_HASH_FN_TYPE hash, LHASH_COMP_FN_TYPE compare);
 void lh_free(LHASH *table);
d13 2
a14 7
 void *lh_insert(LHASH *table, void *data);
 void *lh_delete(LHASH *table, void *data);
 void *lh_retrieve(LHASH *table, void *data);

 void lh_doall(LHASH *table, LHASH_DOALL_FN_TYPE func);
 void lh_doall_arg(LHASH *table, LHASH_DOALL_ARG_FN_TYPE func,
          void *arg);
d16 9
a24 1
 int lh_error(LHASH *table);
d33 55
a87 54
This library implements dynamic hash tables. The hash table entries
can be arbitrary structures. Usually they consist of key and value
fields.

lh_new() creates a new B<LHASH> structure to store arbitrary data
entries, and provides the 'hash' and 'compare' callbacks to be used in
organising the table's entries.  The B<hash> callback takes a pointer
to a table entry as its argument and returns an unsigned long hash
value for its key field.  The hash value is normally truncated to a
power of 2, so make sure that your hash function returns well mixed
low order bits.  The B<compare> callback takes two arguments (pointers
to two hash table entries), and returns 0 if their keys are equal,
non-zero otherwise.  If your hash table will contain items of some
particular type and the B<hash> and B<compare> callbacks hash/compare
these types, then the B<DECLARE_LHASH_HASH_FN> and
B<IMPLEMENT_LHASH_COMP_FN> macros can be used to create callback
wrappers of the prototypes required by lh_new().  These provide
per-variable casts before calling the type-specific callbacks written
by the application author.  These macros, as well as those used for
the "doall" callbacks, are defined as;

 #define DECLARE_LHASH_HASH_FN(f_name,o_type) \
         unsigned long f_name##_LHASH_HASH(const void *);
 #define IMPLEMENT_LHASH_HASH_FN(f_name,o_type) \
         unsigned long f_name##_LHASH_HASH(const void *arg) { \
                 o_type a = (o_type)arg; \
                 return f_name(a); }
 #define LHASH_HASH_FN(f_name) f_name##_LHASH_HASH

 #define DECLARE_LHASH_COMP_FN(f_name,o_type) \
         int f_name##_LHASH_COMP(const void *, const void *);
 #define IMPLEMENT_LHASH_COMP_FN(f_name,o_type) \
         int f_name##_LHASH_COMP(const void *arg1, const void *arg2) { \
                 o_type a = (o_type)arg1; \
                 o_type b = (o_type)arg2; \
                 return f_name(a,b); }
 #define LHASH_COMP_FN(f_name) f_name##_LHASH_COMP

 #define DECLARE_LHASH_DOALL_FN(f_name,o_type) \
         void f_name##_LHASH_DOALL(const void *);
 #define IMPLEMENT_LHASH_DOALL_FN(f_name,o_type) \
         void f_name##_LHASH_DOALL(const void *arg) { \
                 o_type a = (o_type)arg; \
                 f_name(a); }
 #define LHASH_DOALL_FN(f_name) f_name##_LHASH_DOALL

 #define DECLARE_LHASH_DOALL_ARG_FN(f_name,o_type,a_type) \
         void f_name##_LHASH_DOALL_ARG(const void *, const void *);
 #define IMPLEMENT_LHASH_DOALL_ARG_FN(f_name,o_type,a_type) \
         void f_name##_LHASH_DOALL_ARG(const void *arg1, const void *arg2) { \
                 o_type a = (o_type)arg1; \
                 a_type b = (a_type)arg2; \
                 f_name(a,b); }
 #define LHASH_DOALL_ARG_FN(f_name) f_name##_LHASH_DOALL_ARG
d89 2
a90 2
An example of a hash table storing (pointers to) structures of type 'STUFF'
could be defined as follows;
d95 1
a95 1
 int STUFF_cmp(const STUFF *arg1, const STUFF *arg2);
d97 2
a98 2
 static IMPLEMENT_LHASH_HASH_FN(STUFF_hash, const STUFF *)
 static IMPLEMENT_LHASH_COMP_FN(STUFF_cmp, const STUFF *);
d102 1
a102 1
         LHASH *hashtable = lh_new(LHASH_HASH_FN(STUFF_hash),
d107 9
a115 8
lh_free() frees the B<LHASH> structure B<table>. Allocated hash table
entries will not be freed; consider using lh_doall() to deallocate any
remaining entries in the hash table (see below).

lh_insert() inserts the structure pointed to by B<data> into B<table>.
If there already is an entry with the same key, the old value is
replaced. Note that lh_insert() stores pointers, the data are not
copied.
d117 1
a117 1
lh_delete() deletes an entry from B<table>.
d119 2
a120 2
lh_retrieve() looks up an entry in B<table>. Normally, B<data> is
a structure with the key field(s) set; the function will return a
d123 9
a131 9
lh_doall() will, for every entry in the hash table, call B<func> with
the data item as its parameter.  For lh_doall() and lh_doall_arg(),
function pointer casting should be avoided in the callbacks (see
B<NOTE>) - instead, either declare the callbacks to match the
prototype required in lh_new() or use the declare/implement macros to
create type-safe wrappers that cast variables prior to calling your
type-specific callbacks.  An example of this is illustrated here where
the callback is used to cleanup resources for items in the hash table
prior to the hashtable itself being deallocated:
d134 1
a134 1
 void STUFF_cleanup(STUFF *a);
d136 1
a136 1
 IMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF *)
d139 1
a139 1
 lh_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup));
d141 1
a141 1
 lh_free(hashtable);
d152 10
a161 10
lh_doall_arg() is the same as lh_doall() except that B<func> will be
called with B<arg> as the second argument and B<func> should be of
type B<LHASH_DOALL_ARG_FN_TYPE> (a callback prototype that is passed
both the table entry and an extra argument).  As with lh_doall(), you
can instead choose to declare your callback with a prototype matching
the types you are dealing with and use the declare/implement macros to
create compatible wrappers that cast variables before calling your
type-specific callbacks.  An example of this is demonstrated here
(printing all hash table entries to a BIO that is provided by the
caller):
d164 1
a164 1
 void STUFF_print(const STUFF *a, BIO *output_bio);
d166 1
a166 1
 static IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF_print, const STUFF *, BIO *)
d169 2
a170 1
 lh_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), logging_bio);
d172 2
a173 2
lh_error() can be used to determine if an error occurred in the last
operation. lh_error() is a macro.
d177 1
a177 1
lh_new() returns B<NULL> on error, otherwise a pointer to the new
d180 1
a180 1
When a hash table entry is replaced, lh_insert() returns the value
d183 1
a183 1
lh_delete() returns the entry being deleted.  B<NULL> is returned if
d186 1
a186 1
lh_retrieve() returns the hash table entry if it has been found,
d189 1
a189 1
lh_error() returns 1 if an error occurred in the last operation, 0
d192 1
a192 1
lh_free(), lh_doall() and lh_doall_arg() return no values.
d197 1
a197 1
to write type-safe code without resorting to function-prototype
d235 1
a235 1
lh_insert() returns B<NULL> both for success and error.
d280 2
a281 2
routine would not normally be passed to lh_new(), rather it would be
used in the function passed to lh_new().
d298 3
@


1.3
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d289 5
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d5 1
a5 2
lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall,
lh_doall_arg, lh_error - dynamic hash table
d11 1
a11 2
 LHASH *lh_new(unsigned long (*hash)(/*void *a*/),
          int (*compare)(/*void *a,void *b*/));
d18 2
a19 2
 void lh_doall(LHASH *table, void (*func)(/*void *b*/));
 void lh_doall_arg(LHASH *table, void (*func)(/*void *a,void *b*/),
d24 5
d35 68
a102 6
lh_new() creates a new B<LHASH> structure. B<hash> takes a pointer to
the structure and returns an unsigned long hash value of its key
field. The hash value is normally truncated to a power of 2, so make
sure that your hash function returns well mixed low order
bits. B<compare> takes two arguments, and returns 0 if their keys are
equal, non-zero otherwise.
d106 1
a106 1
remaining entries in the hash table.
d120 47
a166 17
the data item as parameters.
This function can be quite useful when used as follows:
 void cleanup(STUFF *a)
  { STUFF_free(a); }
 lh_doall(hash,cleanup);
 lh_free(hash);
This can be used to free all the entries. lh_free() then cleans up the
'buckets' that point to nothing. When doing this, be careful if you
delete entries from the hash table in B<func>: the table may decrease
in size, moving item that you are currently on down lower in the hash
table.  This could cause some entries to be skipped.  The best
solution to this problem is to set hash-E<gt>down_load=0 before you
start.  This will stop the hash table ever being decreased in size.

lh_doall_arg() is the same as lh_doall() except that B<func> will
be called with B<arg> as the second argument.

d189 39
d268 1
a268 1
will be much less expensive that 10 calls to you compare function.
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d105 1
a105 1
decreased) in size via Realloc().  When a 'resize' is done, instead of
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d5 2
a6 1
lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg, lh_error - dynamic hash table
d12 2
a13 1
 LHASH *lh_new(LHASH_HASH_FN_TYPE hash, LHASH_COMP_FN_TYPE compare);
d20 2
a21 2
 void lh_doall(LHASH *table, LHASH_DOALL_FN_TYPE func);
 void lh_doall_arg(LHASH *table, LHASH_DOALL_ARG_FN_TYPE func,
a25 5
 typedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);
 typedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);
 typedef void (*LHASH_DOALL_FN_TYPE)(const void *);
 typedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const void *);

d32 6
a37 68
lh_new() creates a new B<LHASH> structure to store arbitrary data
entries, and provides the 'hash' and 'compare' callbacks to be used in
organising the table's entries.  The B<hash> callback takes a pointer
to a table entry as its argument and returns an unsigned long hash
value for its key field.  The hash value is normally truncated to a
power of 2, so make sure that your hash function returns well mixed
low order bits.  The B<compare> callback takes two arguments (pointers
to two hash table entries), and returns 0 if their keys are equal,
non-zero otherwise.  If your hash table will contain items of some
particular type and the B<hash> and B<compare> callbacks hash/compare
these types, then the B<DECLARE_LHASH_HASH_FN> and
B<IMPLEMENT_LHASH_COMP_FN> macros can be used to create callback
wrappers of the prototypes required by lh_new().  These provide
per-variable casts before calling the type-specific callbacks written
by the application author.  These macros, as well as those used for
the "doall" callbacks, are defined as;

 #define DECLARE_LHASH_HASH_FN(f_name,o_type) \
         unsigned long f_name##_LHASH_HASH(const void *);
 #define IMPLEMENT_LHASH_HASH_FN(f_name,o_type) \
         unsigned long f_name##_LHASH_HASH(const void *arg) { \
                 o_type a = (o_type)arg; \
                 return f_name(a); }
 #define LHASH_HASH_FN(f_name) f_name##_LHASH_HASH

 #define DECLARE_LHASH_COMP_FN(f_name,o_type) \
         int f_name##_LHASH_COMP(const void *, const void *);
 #define IMPLEMENT_LHASH_COMP_FN(f_name,o_type) \
         int f_name##_LHASH_COMP(const void *arg1, const void *arg2) { \
                 o_type a = (o_type)arg1; \
                 o_type b = (o_type)arg2; \
                 return f_name(a,b); }
 #define LHASH_COMP_FN(f_name) f_name##_LHASH_COMP

 #define DECLARE_LHASH_DOALL_FN(f_name,o_type) \
         void f_name##_LHASH_DOALL(const void *);
 #define IMPLEMENT_LHASH_DOALL_FN(f_name,o_type) \
         void f_name##_LHASH_DOALL(const void *arg) { \
                 o_type a = (o_type)arg; \
                 f_name(a); }
 #define LHASH_DOALL_FN(f_name) f_name##_LHASH_DOALL

 #define DECLARE_LHASH_DOALL_ARG_FN(f_name,o_type,a_type) \
         void f_name##_LHASH_DOALL_ARG(const void *, const void *);
 #define IMPLEMENT_LHASH_DOALL_ARG_FN(f_name,o_type,a_type) \
         void f_name##_LHASH_DOALL_ARG(const void *arg1, const void *arg2) { \
                 o_type a = (o_type)arg1; \
                 a_type b = (a_type)arg2; \
                 f_name(a,b); }
 #define LHASH_DOALL_ARG_FN(f_name) f_name##_LHASH_DOALL_ARG

An example of a hash table storing (pointers to) structures of type 'STUFF'
could be defined as follows;

 /* Calculates the hash value of 'tohash' (implemented elsewhere) */
 unsigned long STUFF_hash(const STUFF *tohash);
 /* Orders 'arg1' and 'arg2' (implemented elsewhere) */
 int STUFF_cmp(const STUFF *arg1, const STUFF *arg2);
 /* Create the type-safe wrapper functions for use in the LHASH internals */
 static IMPLEMENT_LHASH_HASH_FN(STUFF_hash, const STUFF *)
 static IMPLEMENT_LHASH_COMP_FN(STUFF_cmp, const STUFF *);
 /* ... */
 int main(int argc, char *argv[]) {
         /* Create the new hash table using the hash/compare wrappers */
         LHASH *hashtable = lh_new(LHASH_HASH_FN(STUFF_hash),
                                   LHASH_COMP_FN(STUFF_cmp));
	 /* ... */
 }
d41 1
a41 1
remaining entries in the hash table (see below).
d55 17
a71 47
the data item as its parameter.  For lh_doall() and lh_doall_arg(),
function pointer casting should be avoided in the callbacks (see
B<NOTE>) - instead, either declare the callbacks to match the
prototype required in lh_new() or use the declare/implement macros to
create type-safe wrappers that cast variables prior to calling your
type-specific callbacks.  An example of this is illustrated here where
the callback is used to cleanup resources for items in the hash table
prior to the hashtable itself being deallocated:

 /* Cleans up resources belonging to 'a' (this is implemented elsewhere) */
 void STUFF_cleanup(STUFF *a);
 /* Implement a prototype-compatible wrapper for "STUFF_cleanup" */
 IMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF *)
         /* ... then later in the code ... */
 /* So to run "STUFF_cleanup" against all items in a hash table ... */
 lh_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup));
 /* Then the hash table itself can be deallocated */
 lh_free(hashtable);

When doing this, be careful if you delete entries from the hash table
in your callbacks: the table may decrease in size, moving the item
that you are currently on down lower in the hash table - this could
cause some entries to be skipped during the iteration.  The second
best solution to this problem is to set hash-E<gt>down_load=0 before
you start (which will stop the hash table ever decreasing in size).
The best solution is probably to avoid deleting items from the hash
table inside a "doall" callback!

lh_doall_arg() is the same as lh_doall() except that B<func> will be
called with B<arg> as the second argument and B<func> should be of
type B<LHASH_DOALL_ARG_FN_TYPE> (a callback prototype that is passed
both the table entry and an extra argument).  As with lh_doall(), you
can instead choose to declare your callback with a prototype matching
the types you are dealing with and use the declare/implement macros to
create compatible wrappers that cast variables before calling your
type-specific callbacks.  An example of this is demonstrated here
(printing all hash table entries to a BIO that is provided by the
caller):

 /* Prints item 'a' to 'output_bio' (this is implemented elsewhere) */
 void STUFF_print(const STUFF *a, BIO *output_bio);
 /* Implement a prototype-compatible wrapper for "STUFF_print" */
 static IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF_print, const STUFF *, BIO *)
         /* ... then later in the code ... */
 /* Print out the entire hashtable to a particular BIO */
 lh_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), logging_bio);
 
a93 39
=head1 NOTE

The various LHASH macros and callback types exist to make it possible
to write type-safe code without resorting to function-prototype
casting - an evil that makes application code much harder to
audit/verify and also opens the window of opportunity for stack
corruption and other hard-to-find bugs.  It also, apparently, violates
ANSI-C.

The LHASH code regards table entries as constant data.  As such, it
internally represents lh_insert()'d items with a "const void *"
pointer type.  This is why callbacks such as those used by lh_doall()
and lh_doall_arg() declare their prototypes with "const", even for the
parameters that pass back the table items' data pointers - for
consistency, user-provided data is "const" at all times as far as the
LHASH code is concerned.  However, as callers are themselves providing
these pointers, they can choose whether they too should be treating
all such parameters as constant.

As an example, a hash table may be maintained by code that, for
reasons of encapsulation, has only "const" access to the data being
indexed in the hash table (ie. it is returned as "const" from
elsewhere in their code) - in this case the LHASH prototypes are
appropriate as-is.  Conversely, if the caller is responsible for the
life-time of the data in question, then they may well wish to make
modifications to table item passed back in the lh_doall() or
lh_doall_arg() callbacks (see the "STUFF_cleanup" example above).  If
so, the caller can either cast the "const" away (if they're providing
the raw callbacks themselves) or use the macros to declare/implement
the wrapper functions without "const" types.

Callers that only have "const" access to data they're indexing in a
table, yet declare callbacks without constant types (or cast the
"const" away themselves), are therefore creating their own risks/bugs
without being encouraged to do so by the API.  On a related note,
those auditing code should pay special attention to any instances of
DECLARE/IMPLEMENT_LHASH_DOALL_[ARG_]_FN macros that provide types
without any "const" qualifiers.

d105 1
a105 1
decreased) in size via OPENSSL_realloc().  When a 'resize' is done, instead of
d134 1
a134 1
will be much less expensive that 10 calls to your compare function.
@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@a288 5
In OpenSSL 0.9.7, all lhash functions that were passed function pointers
were changed for better type safety, and the function types LHASH_COMP_FN_TYPE,
LHASH_HASH_FN_TYPE, LHASH_DOALL_FN_TYPE and LHASH_DOALL_ARG_FN_TYPE 
became available.

@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@d11 2
a12 1
 DECLARE_LHASH_OF(<type>);
d14 7
a20 2
 LHASH *lh_<type>_new();
 void lh_<type>_free(LHASH_OF(<type> *table);
d22 1
a22 9
 <type> *lh_<type>_insert(LHASH_OF(<type> *table, <type> *data);
 <type> *lh_<type>_delete(LHASH_OF(<type> *table, <type> *data);
 <type> *lh_retrieve(LHASH_OF<type> *table, <type> *data);

 void lh_<type>_doall(LHASH_OF(<type> *table, LHASH_DOALL_FN_TYPE func);
 void lh_<type>_doall_arg(LHASH_OF(<type> *table, LHASH_DOALL_ARG_FN_TYPE func,
          <type2>, <type2> *arg);

 int lh_<type>_error(LHASH_OF(<type> *table);
d31 54
a84 55
This library implements type-checked dynamic hash tables. The hash
table entries can be arbitrary structures. Usually they consist of key
and value fields.

lh_<type>_new() creates a new B<LHASH_OF(<type>> structure to store
arbitrary data entries, and provides the 'hash' and 'compare'
callbacks to be used in organising the table's entries.  The B<hash>
callback takes a pointer to a table entry as its argument and returns
an unsigned long hash value for its key field.  The hash value is
normally truncated to a power of 2, so make sure that your hash
function returns well mixed low order bits.  The B<compare> callback
takes two arguments (pointers to two hash table entries), and returns
0 if their keys are equal, non-zero otherwise.  If your hash table
will contain items of some particular type and the B<hash> and
B<compare> callbacks hash/compare these types, then the
B<DECLARE_LHASH_HASH_FN> and B<IMPLEMENT_LHASH_COMP_FN> macros can be
used to create callback wrappers of the prototypes required by
lh_<type>_new().  These provide per-variable casts before calling the
type-specific callbacks written by the application author.  These
macros, as well as those used for the "doall" callbacks, are defined
as;

 #define DECLARE_LHASH_HASH_FN(name, o_type) \
	 unsigned long name##_LHASH_HASH(const void *);
 #define IMPLEMENT_LHASH_HASH_FN(name, o_type) \
	 unsigned long name##_LHASH_HASH(const void *arg) { \
		 const o_type *a = arg; \
		 return name##_hash(a); }
 #define LHASH_HASH_FN(name) name##_LHASH_HASH

 #define DECLARE_LHASH_COMP_FN(name, o_type) \
	 int name##_LHASH_COMP(const void *, const void *);
 #define IMPLEMENT_LHASH_COMP_FN(name, o_type) \
	 int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
		 const o_type *a = arg1;		    \
		 const o_type *b = arg2; \
		 return name##_cmp(a,b); }
 #define LHASH_COMP_FN(name) name##_LHASH_COMP

 #define DECLARE_LHASH_DOALL_FN(name, o_type) \
	 void name##_LHASH_DOALL(void *);
 #define IMPLEMENT_LHASH_DOALL_FN(name, o_type) \
	 void name##_LHASH_DOALL(void *arg) { \
		 o_type *a = arg; \
		 name##_doall(a); }
 #define LHASH_DOALL_FN(name) name##_LHASH_DOALL

 #define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \
	 void name##_LHASH_DOALL_ARG(void *, void *);
 #define IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \
	 void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \
		 o_type *a = arg1; \
		 a_type *b = arg2; \
		 name##_doall_arg(a, b); }
 #define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG
d86 2
a87 2
 An example of a hash table storing (pointers to) structures of type 'STUFF'
 could be defined as follows;
d92 1
a92 1
 int stuff_cmp(const STUFF *arg1, const STUFF *arg2);
d94 2
a95 2
 static IMPLEMENT_LHASH_HASH_FN(stuff, STUFF);
 static IMPLEMENT_LHASH_COMP_FN(stuff, STUFF);
d99 1
a99 1
         LHASH_OF(STUFF) *hashtable = lh_STUFF_new(LHASH_HASH_FN(STUFF_hash),
d104 8
a111 9
lh_<type>_free() frees the B<LHASH_OF(<type>> structure
B<table>. Allocated hash table entries will not be freed; consider
using lh_<type>_doall() to deallocate any remaining entries in the
hash table (see below).

lh_<type>_insert() inserts the structure pointed to by B<data> into
B<table>.  If there already is an entry with the same key, the old
value is replaced. Note that lh_<type>_insert() stores pointers, the
data are not copied.
d113 1
a113 1
lh_<type>_delete() deletes an entry from B<table>.
d115 2
a116 2
lh_<type>_retrieve() looks up an entry in B<table>. Normally, B<data>
is a structure with the key field(s) set; the function will return a
d119 9
a127 9
lh_<type>_doall() will, for every entry in the hash table, call
B<func> with the data item as its parameter.  For lh_<type>_doall()
and lh_<type>_doall_arg(), function pointer casting should be avoided
in the callbacks (see B<NOTE>) - instead use the declare/implement
macros to create type-checked wrappers that cast variables prior to
calling your type-specific callbacks.  An example of this is
illustrated here where the callback is used to cleanup resources for
items in the hash table prior to the hashtable itself being
deallocated:
d130 1
a130 1
 void STUFF_cleanup_doall(STUFF *a);
d132 1
a132 1
 IMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF)
d135 1
a135 1
 lh_STUFF_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup));
d137 1
a137 1
 lh_STUFF_free(hashtable);
d148 10
a157 10
lh_<type>_doall_arg() is the same as lh_<type>_doall() except that
B<func> will be called with B<arg> as the second argument and B<func>
should be of type B<LHASH_DOALL_ARG_FN_TYPE> (a callback prototype
that is passed both the table entry and an extra argument).  As with
lh_doall(), you can instead choose to declare your callback with a
prototype matching the types you are dealing with and use the
declare/implement macros to create compatible wrappers that cast
variables before calling your type-specific callbacks.  An example of
this is demonstrated here (printing all hash table entries to a BIO
that is provided by the caller):
d160 1
a160 1
 void STUFF_print_doall_arg(const STUFF *a, BIO *output_bio);
d162 1
a162 1
 static IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF, const STUFF, BIO)
d165 1
a165 2
 lh_STUFF_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), BIO,
                    logging_bio);
d167 2
a168 2
lh_<type>_error() can be used to determine if an error occurred in the last
operation. lh_<type>_error() is a macro.
d172 1
a172 1
lh_<type>_new() returns B<NULL> on error, otherwise a pointer to the new
d175 1
a175 1
When a hash table entry is replaced, lh_<type>_insert() returns the value
d178 1
a178 1
lh_<type>_delete() returns the entry being deleted.  B<NULL> is returned if
d181 1
a181 1
lh_<type>_retrieve() returns the hash table entry if it has been found,
d184 1
a184 1
lh_<type>_error() returns 1 if an error occurred in the last operation, 0
d187 1
a187 1
lh_<type>_free(), lh_<type>_doall() and lh_<type>_doall_arg() return no values.
d192 1
a192 1
to write type-checked code without resorting to function-prototype
d230 1
a230 1
lh_<type>_insert() returns B<NULL> both for success and error.
d275 2
a276 2
routine would not normally be passed to lh_<type>_new(), rather it would be
used in the function passed to lh_<type>_new().
a292 3

In OpenSSL 1.0.0, the lhash interface was revamped for even better
type checking.
@


