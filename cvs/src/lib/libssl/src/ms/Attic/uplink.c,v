head	1.2;
access;
symbols
	OPENBSD_5_5:1.1.1.2.0.12
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.8
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.6
	OPENBSD_5_3_BASE:1.1.1.2
	openssl_1_0_1_c:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.2
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.4
	openssl_1_0_0_f:1.1.1.2
	openssl_1_0_0_e:1.1.1.2
	OPENBSD_5_0:1.1.1.1.0.12
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.10
	OPENBSD_4_9_BASE:1.1.1.1
	openssh_1_0_0_a:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	openssl_0_9_8_k:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	openssl_0_9_8_j:1.1.1.1
	openssl_0_9_8_h:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2014.04.13.15.25.34;	author miod;	state dead;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.11.03.02.32.19;	author djm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@#if (defined(_WIN64) || defined(_WIN32_WCE)) && !defined(UNICODE)
#define UNICODE
#endif
#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif
#if defined(_UNICODE) && !defined(UNICODE)
#define UNICODE
#endif

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "uplink.h"
void OPENSSL_showfatal(const char *,...);

static TCHAR msg[128];

static void unimplemented (void)
{   OPENSSL_showfatal (sizeof(TCHAR)==sizeof(char)?"%s\n":"%S\n",msg);
    ExitProcess (1);
}

void OPENSSL_Uplink (volatile void **table, int index)
{ static HMODULE volatile apphandle=NULL;
  static void ** volatile applinktable=NULL;
  int len;
  void (*func)(void)=unimplemented;
  HANDLE h;
  void **p;

    /* Note that the below code is not MT-safe in respect to msg
     * buffer, but what's the worst thing that can happen? Error
     * message might be misleading or corrupted. As error condition
     * is fatal and should never be risen, I accept the risk... */
    /* One can argue that I should have used InterlockedExchangePointer
     * or something to update static variables and table[]. Well,
     * store instructions are as atomic as they can get and assigned
     * values are effectively constant... So that volatile qualifier
     * should be sufficient [it prohibits compiler to reorder memory
     * access instructions]. */
    do {
	len = _stprintf (msg,_T("OPENSSL_Uplink(%p,%02X): "),table,index);
	_tcscpy (msg+len,_T("unimplemented function"));

	if ((h=apphandle)==NULL)
	{   if  ((h=GetModuleHandle(NULL))==NULL)
	    {	apphandle=(HMODULE)-1;
		_tcscpy (msg+len,_T("no host application"));
		break;
	    }
	    apphandle = h;
	}
	if ((h=apphandle)==(HMODULE)-1) /* revalidate */
	    break;

	if (applinktable==NULL)
	{ void**(*applink)();

	    applink=(void**(*)())GetProcAddress(h,"OPENSSL_Applink");
	    if (applink==NULL)
	    {	apphandle=(HMODULE)-1;
		_tcscpy (msg+len,_T("no OPENSSL_Applink"));
		break;
	    }
	    p = (*applink)();
	    if (p==NULL)
	    {	apphandle=(HMODULE)-1;
		_tcscpy (msg+len,_T("no ApplinkTable"));
		break;
	    }
	    applinktable = p;
	}
	else
	    p = applinktable;

	if (index > (int)p[0])
	    break;

	if (p[index]) func = p[index];
    } while (0);

    table[index] = func;
}    

#if defined(_MSC_VER) && defined(_M_IX86) && !defined(OPENSSL_NO_INLINE_ASM)
#define LAZY(i)		\
__declspec(naked) static void lazy##i (void) { 	\
	_asm	push i				\
	_asm	push OFFSET OPENSSL_UplinkTable	\
	_asm	call OPENSSL_Uplink		\
	_asm	add  esp,8			\
	_asm	jmp  OPENSSL_UplinkTable+4*i	}

#if APPLINK_MAX>25
#error "Add more stubs..."
#endif
/* make some in advance... */
LAZY(1)  LAZY(2)  LAZY(3)  LAZY(4)  LAZY(5)
LAZY(6)  LAZY(7)  LAZY(8)  LAZY(9)  LAZY(10)
LAZY(11) LAZY(12) LAZY(13) LAZY(14) LAZY(15)
LAZY(16) LAZY(17) LAZY(18) LAZY(19) LAZY(20)
LAZY(21) LAZY(22) LAZY(23) LAZY(24) LAZY(25)
void *OPENSSL_UplinkTable[] = {
	(void *)APPLINK_MAX,
	lazy1, lazy2, lazy3, lazy4, lazy5,
	lazy6, lazy7, lazy8, lazy9, lazy10,
	lazy11,lazy12,lazy13,lazy14,lazy15,
	lazy16,lazy17,lazy18,lazy19,lazy20,
	lazy21,lazy22,lazy23,lazy24,lazy25,
};
#endif

#ifdef SELFTEST
main() {  UP_fprintf(UP_stdout,"hello, world!\n"); }
#endif
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import OpenSSL 1.0.0e
@
text
@d43 1
a43 2
	len = _sntprintf (msg,sizeof(msg)/sizeof(TCHAR),
			  _T("OPENSSL_Uplink(%p,%02X): "),table,index);
@

