head	1.2;
access;
symbols
	OPENBSD_5_5:1.1.1.1.0.16
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.12
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	openssl_1_0_1_c:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.6
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.8
	openssl_1_0_0_f:1.1.1.1
	openssl_1_0_0_e:1.1.1.1
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	openssh_1_0_0_a:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2014.04.13.15.25.34;	author miod;	state dead;
branches;
next	1.1;

1.1
date	2010.10.01.22.54.15;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.10.01.22.54.15;	author djm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@#!/usr/bin/env perl

$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
push(@@INC,"${dir}.");

require "uplink-common.pl";

local $V=8;	# max number of args uplink functions may accept...
my $loc0 = "r".(32+$V);
print <<___;
.text
.global	OPENSSL_Uplink#
.type	OPENSSL_Uplink#,\@@function

___
for ($i=1;$i<=$N;$i++) {
print <<___;
.proc	lazy$i#
lazy$i:
	.prologue
{ .mii;	.save	ar.pfs,$loc0
	alloc	loc0=ar.pfs,$V,3,2,0
	.save	b0,loc1
	mov	loc1=b0
	addl	loc2=\@@ltoff(OPENSSL_UplinkTable#),gp	};;
	.body
{ .mmi;	ld8	out0=[loc2]
	mov	out1=$i					};;
{ .mib;	add	loc2=8*$i,out0
	br.call.sptk.many	b0=OPENSSL_Uplink#	};;
{ .mmi;	ld8	r31=[loc2];;
	ld8	r30=[r31],8				};;
{ .mii;	ld8	gp=[r31]
	mov	b6=r30
	mov	b0=loc1					};;
{ .mib;	mov	ar.pfs=loc0
	br.many	b6					};;
.endp	lazy$i#

___
}
print <<___;
.data
.global OPENSSL_UplinkTable#
OPENSSL_UplinkTable:    data8   $N      // amount of following entries
___
for ($i=1;$i<=$N;$i++) {   print "      data8   \@@fptr(lazy$i#)\n";   }
print <<___;
.size   OPENSSL_UplinkTable,.-OPENSSL_UplinkTable#
___
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import OpenSSL-1.0.0a
@
text
@@
