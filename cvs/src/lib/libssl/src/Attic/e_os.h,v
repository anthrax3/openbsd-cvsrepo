head	1.28;
access;
symbols
	butholakala:1.20
	openssl_1_0_1_g:1.1.1.12
	OPENBSD_5_5:1.19.0.8
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	openssl_1_0_1_c:1.1.1.11
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	openssl_1_0_0_f:1.1.1.10
	openssl_1_0_0_e:1.1.1.10
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	openssh_1_0_0_a:1.1.1.10
	OPENBSD_4_8:1.17.0.8
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.4
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	openssl_0_9_8_k:1.1.1.9
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	openssl_0_9_8_j:1.1.1.9
	openssl_0_9_8_h:1.1.1.8
	pre_openssl_0_9_8h:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	openssl_0_9_7j:1.1.1.7
	openssl:1.1.1
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENSSL_0_9_7G:1.1.1.6
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	OPENSSL_0_9_7D:1.1.1.5
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENSSL_0_9_7C:1.1.1.5
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2014.04.18.14.37.41;	author deraadt;	state dead;
branches;
next	1.27;

1.27
date	2014.04.18.11.31.16;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.17.21.32.37;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.17.20.58.07;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.15.17.11.21;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.13.23.31.36;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.13.20.17.41;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.13.19.50.56;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.13.15.25.20;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.13.21.25.05;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2010.10.01.22.58.41;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.09.12.15.16;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.27.05.06.51;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.29.05.39.10;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.11.22.15.18;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.12.02.18.34;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.10.16.31.53;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.05.22.12.11;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.15.02.29.08;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.01.19.51.16;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.02.48;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.56.51;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.19.11.07.46;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.10.06.15.17.02;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.12;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.29;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.29;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.24;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.33.28;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.10;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.10.01;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.36.56;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.06.27.05.05.28;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.37;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.01.09.12.13.48;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.10.01.22.54.00;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.10.13.21.23.31;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.04.13.15.16.29;	author miod;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Put the final pieces from e_os.h in the required places, and remove it.
"dance on it's grave" says beck
ok guenther beck
@
text
@/* e_os.h */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#ifndef HEADER_E_OS_H
#define HEADER_E_OS_H

#include <openssl/opensslconf.h>

/*
 * <openssl/e_os2.h> contains what we can justify to make visible
 * to the outside
 * <openssl/e_os2.h> is not exported interface (except to the openssl
 * command)
 */

#include <openssl/e_os2.h>

#define OPENSSL_CONF	"openssl.cnf"

#define OPENSSL_USE_IPV6 1

#endif

@


1.27
log
@define RFILE only in the file that needs it
@
text
@@


1.26
log
@kill REF_PRINT/REF_CHECK debugging framework noone would use
ok miod
@
text
@a72 4
#ifdef  __cplusplus
extern "C" {
#endif

a73 1
#define RFILE		".rnd"
a75 4

#ifdef  __cplusplus
}
#endif
@


1.25
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@a76 6
/* Used to checking reference counts, most while doing perl5 stuff :-) */
#ifdef REF_PRINT
#undef REF_PRINT
#define REF_PRINT(a,b)	fprintf(stderr,"%08X:%4d:%s\n",(int)b,b->references,a)
#endif

@


1.24
log
@No need to define DEVRANDOM and DEVRANDOM_EGD any longer.
@
text
@d64 7
a71 3
/* <openssl/e_os2.h> contains what we can justify to make visible
 * to the outside; this file e_os.h is not part of the exported
 * interface. */
d83 2
a84 36
#      include <unistd.h>
#      include <sys/types.h>
#    define OPENSSL_CONF	"openssl.cnf"
#    define SSLEAY_CONF		OPENSSL_CONF
#    define RFILE		".rnd"
#    define LIST_SEPARATOR_CHAR ':'
#    define EXIT(n)		exit(n)


#ifdef USE_SOCKETS
#    include <sys/param.h>
#    include <sys/time.h> /* Needed under linux for FD_XXX */
#    include <netdb.h>
#    include <sys/socket.h>
#    include <netinet/in.h>
#    include <sys/ioctl.h>
#endif

/* Some IPv6 implementations are broken, disable them in known bad
 * versions.
 */
#  if !defined(OPENSSL_USE_IPV6)
#    if defined(AF_INET6)
#      define OPENSSL_USE_IPV6 1
#    else
#      define OPENSSL_USE_IPV6 0
#    endif
#  endif

#ifndef OPENSSL_EXIT
# if defined(MONOLITH) && !defined(OPENSSL_C)
#  define OPENSSL_EXIT(n) return(n)
# else
#  define OPENSSL_EXIT(n) do { EXIT(n); return(n); } while(0)
# endif
#endif
d86 1
a86 1
/***********************************************/
@


1.23
log
@Remove various horrible socket syscall wrappers, especially SHUTDOWN*
which did shutdown + close, all nasty and surprising.  Use the raw
syscalls that everyone knows the behaviour of.
ok beck matthew
@
text
@a78 12
#ifndef DEVRANDOM
/* set this to a comma-separated list of 'random' device files to try out.
 * My default, we will try to read at least one of these files */
#define DEVRANDOM "/dev/urandom","/dev/random","/dev/srandom"
#endif
#ifndef DEVRANDOM_EGD
/* set this to a comma-seperated list of 'egd' sockets to try out. These
 * sockets will be tried in the order listed in case accessing the device files
 * listed in DEVRANDOM did not return enough entropy. */
#define DEVRANDOM_EGD "/var/run/egd-pool","/dev/egd-pool","/etc/egd-pool","/etc/entropy"
#endif

@


1.22
log
@/dev/null does not move around
@
text
@a90 9
#define get_last_sys_error()	errno
#define clear_sys_error()	errno=0
#define get_last_socket_error()	errno
#define clear_socket_error()	errno=0
#define ioctlsocket(a,b,c)	ioctl(a,b,c)
#define closesocket(s)		close(s)
#define readsocket(s,b,n)	read((s),(b),(n))
#define writesocket(s,b,n)	write((s),(b),(n))

a97 1
#  define SSLeay_getpid()	getpid()
d101 2
a102 2
#      include <sys/param.h>
#      include <sys/time.h> /* Needed under linux for FD_XXX */
d104 3
a106 13
#      include <sys/socket.h>
#      ifdef FILIO_H
#        include <sys/filio.h> /* Added for FIONBIO under unixware */
#      endif
#      include <netinet/in.h>
#        include <sys/ioctl.h>
#    define SSLeay_Read(a,b,c)     read((a),(b),(c))
#    define SSLeay_Write(a,b,c)    write((a),(b),(c))
#    define SHUTDOWN(fd)    { shutdown((fd),0); closesocket((fd)); }
#    define SHUTDOWN2(fd)   { shutdown((fd),2); closesocket((fd)); }
#    ifndef INVALID_SOCKET
#    define INVALID_SOCKET	(-1)
#    endif /* INVALID_SOCKET */
@


1.21
log
@Remove some stuff that isn't needed.
ok miod@@ deraadt@@
@
text
@a105 1
#    define NUL_DEV		"/dev/null"
@


1.20
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a90 52
#if defined(OPENSSL_SYS_VXWORKS)
#  define NO_SYS_PARAM_H
#  define NO_CHMOD
#  define NO_SYSLOG
#endif
  
#if defined(OPENSSL_SYS_MACINTOSH_CLASSIC)
# if macintosh==1
#  ifndef MAC_OS_GUSI_SOURCE
#    define MAC_OS_pre_X
#    define NO_SYS_TYPES_H
#  endif
#  define NO_SYS_PARAM_H
#  define NO_CHMOD
#  define NO_SYSLOG
#  undef  DEVRANDOM
#  define GETPID_IS_MEANINGLESS
# endif
#endif

/********************************************************************
 The Microsoft section
 ********************************************************************/
/* The following is used because of the small stack in some
 * Microsoft operating systems */
#if defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYSNAME_WIN32)
#  define MS_STATIC	static
#else
#  define MS_STATIC
#endif

#if defined(OPENSSL_SYS_WIN32) && !defined(WIN32)
#  define WIN32
#endif
#if defined(OPENSSL_SYS_WINDOWS) && !defined(WINDOWS)
#  define WINDOWS
#endif
#if defined(OPENSSL_SYS_MSDOS) && !defined(MSDOS)
#  define MSDOS
#endif

#if defined(MSDOS) && !defined(GETPID_IS_MEANINGLESS)
#  define GETPID_IS_MEANINGLESS
#endif

#ifdef WIN32
#define get_last_sys_error()	GetLastError()
#define clear_sys_error()	SetLastError(0)
#if !defined(WINNT)
#define WIN_CONSOLE_BUG
#endif
#else
a92 61
#endif

#if defined(WINDOWS)
#define get_last_socket_error()	WSAGetLastError()
#define clear_socket_error()	WSASetLastError(0)
#define readsocket(s,b,n)	recv((s),(b),(n),0)
#define writesocket(s,b,n)	send((s),(b),(n),0)
#elif defined(__DJGPP__)
#define WATT32
#define get_last_socket_error()	errno
#define clear_socket_error()	errno=0
#define closesocket(s)		close_s(s)
#define readsocket(s,b,n)	read_s(s,b,n)
#define writesocket(s,b,n)	send(s,b,n,0)
#elif defined(MAC_OS_pre_X)
#define get_last_socket_error()	errno
#define clear_socket_error()	errno=0
#define closesocket(s)		MacSocket_close(s)
#define readsocket(s,b,n)	MacSocket_recv((s),(b),(n),true)
#define writesocket(s,b,n)	MacSocket_send((s),(b),(n))
#elif defined(OPENSSL_SYS_VMS)
#define get_last_socket_error() errno
#define clear_socket_error()    errno=0
#define ioctlsocket(a,b,c)      ioctl(a,b,c)
#define closesocket(s)          close(s)
#define readsocket(s,b,n)       recv((s),(b),(n),0)
#define writesocket(s,b,n)      send((s),(b),(n),0)
#elif defined(OPENSSL_SYS_VXWORKS)
#define get_last_socket_error()	errno
#define clear_socket_error()	errno=0
#define ioctlsocket(a,b,c)	    ioctl((a),(b),(int)(c))
#define closesocket(s)		    close(s)
#define readsocket(s,b,n)	    read((s),(b),(n))
#define writesocket(s,b,n)	    write((s),(char *)(b),(n))
#elif defined(OPENSSL_SYS_BEOS_R5)
#define get_last_socket_error() errno
#define clear_socket_error()    errno=0
#define FIONBIO SO_NONBLOCK
#define ioctlsocket(a,b,c)		  setsockopt((a),SOL_SOCKET,(b),(c),sizeof(*(c)))
#define readsocket(s,b,n)       recv((s),(b),(n),0)
#define writesocket(s,b,n)      send((s),(b),(n),0)
#elif defined(OPENSSL_SYS_NETWARE)
#if defined(NETWARE_BSDSOCK)
#define get_last_socket_error() errno
#define clear_socket_error()    errno=0
#define closesocket(s)          close(s)
#define ioctlsocket(a,b,c)      ioctl(a,b,c)
#if defined(NETWARE_LIBC)
#define readsocket(s,b,n)       recv((s),(b),(n),0)
#define writesocket(s,b,n)      send((s),(b),(n),0)
#else
#define readsocket(s,b,n)       recv((s),(char*)(b),(n),0)
#define writesocket(s,b,n)      send((s),(char*)(b),(n),0)
#endif
#else
#define get_last_socket_error()	WSAGetLastError()
#define clear_socket_error()	WSASetLastError(0)
#define readsocket(s,b,n)		recv((s),(b),(n),0)
#define writesocket(s,b,n)		send((s),(b),(n),0)
#endif
#else
a98 37
#endif

#ifdef WIN16 /* never the case */
#  define MS_CALLBACK	_far _loadds
#  define MS_FAR	_far
#else
#  define MS_CALLBACK
#  define MS_FAR
#endif

#ifdef OPENSSL_NO_STDIO
#  undef OPENSSL_NO_FP_API
#  define OPENSSL_NO_FP_API
#endif

#if (defined(WINDOWS) || defined(MSDOS))

#  ifdef __DJGPP__
#    include <unistd.h>
#    include <sys/stat.h>
#    include <sys/socket.h>
#    include <tcp.h>
#    include <netdb.h>
#    define _setmode setmode
#    define _O_TEXT O_TEXT
#    define _O_BINARY O_BINARY
#    undef DEVRANDOM
#    define DEVRANDOM "/dev/urandom\x24"
#  endif /* __DJGPP__ */

#  ifndef S_IFDIR
#    define S_IFDIR	_S_IFDIR
#  endif

#  ifndef S_IFMT
#    define S_IFMT	_S_IFMT
#  endif
a99 203
#  if !defined(WINNT) && !defined(__DJGPP__)
#    define NO_SYSLOG
#  endif
#  define NO_DIRENT

#  ifdef WINDOWS
#    if !defined(_WIN32_WCE) && !defined(_WIN32_WINNT)
       /*
	* Defining _WIN32_WINNT here in e_os.h implies certain "discipline."
	* Most notably we ought to check for availability of each specific
	* routine with GetProcAddress() and/or guard NT-specific calls with
	* GetVersion() < 0x80000000. One can argue that in latter "or" case
	* we ought to /DELAYLOAD some .DLLs in order to protect ourselves
	* against run-time link errors. This doesn't seem to be necessary,
	* because it turned out that already Windows 95, first non-NT Win32
	* implementation, is equipped with at least NT 3.51 stubs, dummy
	* routines with same name, but which do nothing. Meaning that it's
	* apparently sufficient to guard "vanilla" NT calls with GetVersion
	* alone, while NT 4.0 and above interfaces ought to be linked with
	* GetProcAddress at run-time.
	*/
#      define _WIN32_WINNT 0x0400
#    endif
#    if !defined(OPENSSL_NO_SOCK) && defined(_WIN32_WINNT)
       /*
        * Just like defining _WIN32_WINNT including winsock2.h implies
        * certain "discipline" for maintaining [broad] binary compatibility.
        * As long as structures are invariant among Winsock versions,
        * it's sufficient to check for specific Winsock2 API availability
        * at run-time [DSO_global_lookup is recommended]...
        */
#      include <winsock2.h>
#      include <ws2tcpip.h>
       /* yes, they have to be #included prior to <windows.h> */
#    endif
#    include <windows.h>
#    include <stdio.h>
#    include <stddef.h>
#    include <errno.h>
#    include <string.h>
#    ifdef _WIN64
#      define strlen(s) _strlen31(s)
/* cut strings to 2GB */
static unsigned int _strlen31(const char *str)
	{
	unsigned int len=0;
	while (*str && len<0x80000000U) str++, len++;
	return len&0x7FFFFFFF;
	}
#    endif
#    include <malloc.h>
#    if defined(_MSC_VER) && _MSC_VER<=1200 && defined(_MT) && defined(isspace)
       /* compensate for bug in VC6 ctype.h */
#      undef isspace
#      undef isdigit
#      undef isalnum
#      undef isupper
#      undef isxdigit
#    endif
#    if defined(_MSC_VER) && !defined(_DLL) && defined(stdin)
#      if _MSC_VER>=1300
#        undef stdin
#        undef stdout
#        undef stderr
         FILE *__iob_func();
#        define stdin  (&__iob_func()[0])
#        define stdout (&__iob_func()[1])
#        define stderr (&__iob_func()[2])
#      elif defined(I_CAN_LIVE_WITH_LNK4049)
#        undef stdin
#        undef stdout
#        undef stderr
         /* pre-1300 has __p__iob(), but it's available only in msvcrt.lib,
          * or in other words with /MD. Declaring implicit import, i.e.
          * with _imp_ prefix, works correctly with all compiler options,
	  * but without /MD results in LINK warning LNK4049:
	  * 'locally defined symbol "__iob" imported'.
          */
         extern FILE *_imp___iob;
#        define stdin  (&_imp___iob[0])
#        define stdout (&_imp___iob[1])
#        define stderr (&_imp___iob[2])
#      endif
#    endif
#  endif
#  include <io.h>
#  include <fcntl.h>

#  ifdef OPENSSL_SYS_WINCE
#    define OPENSSL_NO_POSIX_IO
#  endif

#  if defined (__BORLANDC__)
#    define _setmode setmode
#    define _O_TEXT O_TEXT
#    define _O_BINARY O_BINARY
#    define _int64 __int64
#    define _kbhit kbhit
#  endif

#  define EXIT(n) exit(n)
#  define LIST_SEPARATOR_CHAR ';'
#  ifndef X_OK
#    define X_OK	0
#  endif
#  ifndef W_OK
#    define W_OK	2
#  endif
#  ifndef R_OK
#    define R_OK	4
#  endif
#  define OPENSSL_CONF	"openssl.cnf"
#  define SSLEAY_CONF	OPENSSL_CONF
#  define NUL_DEV	"nul"
#  define RFILE		".rnd"
#  ifdef OPENSSL_SYS_WINCE
#    define DEFAULT_HOME  ""
#  else
#    define DEFAULT_HOME  "C:"
#  endif

/* Avoid Windows 8 SDK GetVersion deprecated problems */
#if defined(_MSC_VER) && _MSC_VER>=1800
#  define check_winnt() (1)
#else
#  define check_winnt() (GetVersion() < 0x80000000)
#endif 

#else /* The non-microsoft world */

#  ifdef OPENSSL_SYS_VMS
#    define VMS 1
  /* some programs don't include stdlib, so exit() and others give implicit 
     function warnings */
#    include <stdlib.h>
#    if defined(__DECC)
#      include <unistd.h>
#    else
#      include <unixlib.h>
#    endif
#    define OPENSSL_CONF	"openssl.cnf"
#    define SSLEAY_CONF		OPENSSL_CONF
#    define RFILE		".rnd"
#    define LIST_SEPARATOR_CHAR ','
#    define NUL_DEV		"NLA0:"
  /* We don't have any well-defined random devices on VMS, yet... */
#    undef DEVRANDOM
  /* We need to do this since VMS has the following coding on status codes:

     Bits 0-2: status type: 0 = warning, 1 = success, 2 = error, 3 = info ...
               The important thing to know is that odd numbers are considered
	       good, while even ones are considered errors.
     Bits 3-15: actual status number
     Bits 16-27: facility number.  0 is considered "unknown"
     Bits 28-31: control bits.  If bit 28 is set, the shell won't try to
                 output the message (which, for random codes, just looks ugly)

     So, what we do here is to change 0 to 1 to get the default success status,
     and everything else is shifted up to fit into the status number field, and
     the status is tagged as an error, which I believe is what is wanted here.
     -- Richard Levitte
  */
#    define EXIT(n)		do { int __VMS_EXIT = n; \
                                     if (__VMS_EXIT == 0) \
				       __VMS_EXIT = 1; \
				     else \
				       __VMS_EXIT = (n << 3) | 2; \
                                     __VMS_EXIT |= 0x10000000; \
				     exit(__VMS_EXIT); } while(0)
#    define NO_SYS_PARAM_H

#  elif defined(OPENSSL_SYS_NETWARE)
#    include <fcntl.h>
#    include <unistd.h>
#    define NO_SYS_TYPES_H
#    undef  DEVRANDOM
#    ifdef NETWARE_CLIB
#      define getpid GetThreadID
       extern int GetThreadID(void);
/* #      include <conio.h> */
       extern int kbhit(void);
#    else
#      include <screen.h>
#    endif
#    define NO_SYSLOG
#    define _setmode setmode
#    define _kbhit kbhit
#    define _O_TEXT O_TEXT
#    define _O_BINARY O_BINARY
#    define OPENSSL_CONF   "openssl.cnf"
#    define SSLEAY_CONF    OPENSSL_CONF
#    define RFILE    ".rnd"
#    define LIST_SEPARATOR_CHAR ';'
#    define EXIT(n)  { if (n) printf("ERROR: %d\n", (int)n); exit(n); }

#  else
     /* !defined VMS */
#    ifdef OPENSSL_SYS_MPE
#      define NO_SYS_PARAM_H
#    endif
#    ifdef OPENSSL_UNISTD
#      include OPENSSL_UNISTD
#    else
a100 2
#    endif
#    ifndef NO_SYS_TYPES_H
a101 15
#    endif
#    if defined(NeXT) || defined(OPENSSL_SYS_NEWS4)
#      define pid_t int /* pid_t is missing on NEXTSTEP/OPENSTEP
                         * (unless when compiling with -D_POSIX_SOURCE,
                         * which doesn't work for us) */
#    endif
#    ifdef OPENSSL_SYS_NEWS4 /* setvbuf is missing on mips-sony-bsd */
#      define setvbuf(a, b, c, d) setbuffer((a), (b), (d))
       typedef unsigned long clock_t;
#    endif
#    ifdef OPENSSL_SYS_WIN32_CYGWIN
#      include <io.h>
#      include <fcntl.h>
#    endif

a107 2
#  endif

a109 4
#endif


/*************/
a111 74
#  if defined(WINDOWS) || defined(MSDOS)
      /* windows world */

#    ifdef OPENSSL_NO_SOCK
#      define SSLeay_Write(a,b,c)	(-1)
#      define SSLeay_Read(a,b,c)	(-1)
#      define SHUTDOWN(fd)		close(fd)
#      define SHUTDOWN2(fd)		close(fd)
#    elif !defined(__DJGPP__)
#      if defined(_WIN32_WCE) && _WIN32_WCE<410
#        define getservbyname _masked_declaration_getservbyname
#      endif
#      if !defined(IPPROTO_IP)
         /* winsock[2].h was included already? */
#        include <winsock.h>
#      endif
#      ifdef getservbyname
#        undef getservbyname
         /* this is used to be wcecompat/include/winsock_extras.h */
         struct servent* PASCAL getservbyname(const char*,const char*);
#      endif

#      ifdef _WIN64
/*
 * Even though sizeof(SOCKET) is 8, it's safe to cast it to int, because
 * the value constitutes an index in per-process table of limited size
 * and not a real pointer.
 */
#        define socket(d,t,p)	((int)socket(d,t,p))
#        define accept(s,f,l)	((int)accept(s,f,l))
#      endif
#      define SSLeay_Write(a,b,c)	send((a),(b),(c),0)
#      define SSLeay_Read(a,b,c)	recv((a),(b),(c),0)
#      define SHUTDOWN(fd)		{ shutdown((fd),0); closesocket(fd); }
#      define SHUTDOWN2(fd)		{ shutdown((fd),2); closesocket(fd); }
#    else
#      define SSLeay_Write(a,b,c)	write_s(a,b,c,0)
#      define SSLeay_Read(a,b,c)	read_s(a,b,c)
#      define SHUTDOWN(fd)		close_s(fd)
#      define SHUTDOWN2(fd)		close_s(fd)
#    endif

#  elif defined(MAC_OS_pre_X)

#    include "MacSocket.h"
#    define SSLeay_Write(a,b,c)		MacSocket_send((a),(b),(c))
#    define SSLeay_Read(a,b,c)		MacSocket_recv((a),(b),(c),true)
#    define SHUTDOWN(fd)		MacSocket_close(fd)
#    define SHUTDOWN2(fd)		MacSocket_close(fd)

#  elif defined(OPENSSL_SYS_NETWARE)
         /* NetWare uses the WinSock2 interfaces by default, but can be configured for BSD
         */
#      if defined(NETWARE_BSDSOCK)
#        include <sys/socket.h>
#        include <netinet/in.h>
#        include <sys/time.h>
#        if defined(NETWARE_CLIB)
#          include <sys/bsdskt.h>
#        else
#          include <sys/select.h>
#        endif
#        define INVALID_SOCKET (int)(~0)
#      else
#        include <novsock2.h>
#      endif
#      define SSLeay_Write(a,b,c)   send((a),(b),(c),0)
#      define SSLeay_Read(a,b,c) recv((a),(b),(c),0)
#      define SHUTDOWN(fd)    { shutdown((fd),0); closesocket(fd); }
#      define SHUTDOWN2(fd)      { shutdown((fd),2); closesocket(fd); }

#  else

#    ifndef NO_SYS_PARAM_H
a112 4
#    endif
#    ifdef OPENSSL_SYS_VXWORKS
#      include <time.h> 
#    elif !defined(OPENSSL_SYS_MPE)
a113 2
#    endif

a114 5
#    if defined(OPENSSL_SYS_VMS_NODECC)
#      include <socket.h>
#      include <in.h>
#      include <inet.h>
#    else
a119 22
#      if !defined(OPENSSL_SYS_BEOS_R5)
#      include <arpa/inet.h>
#    endif
#    endif

#    if defined(NeXT) || defined(_NEXT_SOURCE)
#      include <sys/fcntl.h>
#      include <sys/types.h>
#    endif

#    ifdef OPENSSL_SYS_AIX
#      include <sys/select.h>
#    endif

#    ifdef __QNX__
#      include <sys/select.h>
#    endif

#    if defined(sun)
#      include <sys/filio.h>
#    else
#      ifndef VMS
a120 15
#      else
	 /* ioctl is only in VMS > 7.0 and when socketshr is not used */
#        if !defined(TCPIP_TYPE_SOCKETSHR) && defined(__VMS_VER) && (__VMS_VER > 70000000)
#          include <sys/ioctl.h>
#        endif
#      endif
#    endif

#    ifdef VMS
#      include <unixio.h>
#      if defined(TCPIP_TYPE_SOCKETSHR)
#        include <socketshr.h>
#      endif
#    endif

d128 1
a128 1
#  endif
d134 1
a134 1
#    if defined(AF_INET6) && !defined(OPENSSL_SYS_BEOS_BONE) && !defined(NETWARE_CLIB)
a140 17
#endif

#if defined(sun) && !defined(__svr4__) && !defined(__SVR4)
  /* include headers first, so our defines don't break it */
#include <stdlib.h>
#include <string.h>
  /* bcopy can handle overlapping moves according to SunOS 4.1.4 manpage */
# define memmove(s1,s2,n) bcopy((s2),(s1),(n))
# define strtoul(s,e,b) ((unsigned long int)strtol((s),(e),(b)))
extern char *sys_errlist[]; extern int sys_nerr;
# define strerror(errnum) \
	(((errnum)<0 || (errnum)>=sys_nerr) ? NULL : sys_errlist[errnum])
  /* Being signed SunOS 4.x memcpy breaks ASN1_OBJECT table lookup */
#include "crypto/o_str.h"
# define memcmp OPENSSL_memcmp
#endif

a149 70

#define DG_GCC_BUG	/* gcc < 2.6.3 on DGUX */

#ifdef sgi
#define IRIX_CC_BUG	/* all version of IRIX I've tested (4.* 5.*) */
#endif
#ifdef OPENSSL_SYS_SNI
#define IRIX_CC_BUG	/* CDS++ up to V2.0Bsomething suffered from the same bug.*/
#endif

#if defined(OPENSSL_SYS_WINDOWS)
#  define strcasecmp _stricmp
#  define strncasecmp _strnicmp
#elif defined(OPENSSL_SYS_VMS)
/* VMS below version 7.0 doesn't have strcasecmp() */
#  include "o_str.h"
#  define strcasecmp OPENSSL_strcasecmp
#  define strncasecmp OPENSSL_strncasecmp
#  define OPENSSL_IMPLEMENTS_strncasecmp
#elif defined(OPENSSL_SYS_OS2) && defined(__EMX__)
#  define strcasecmp stricmp
#  define strncasecmp strnicmp
#elif defined(OPENSSL_SYS_NETWARE)
#  include <string.h>
#  if defined(NETWARE_CLIB)
#    define strcasecmp stricmp
#    define strncasecmp strnicmp
#  endif /* NETWARE_CLIB */
#endif

#if defined(OPENSSL_SYS_OS2) && defined(__EMX__)
# include <io.h>
# include <fcntl.h>
# define NO_SYSLOG
#endif

/* vxworks */
#if defined(OPENSSL_SYS_VXWORKS)
#include <ioLib.h>
#include <tickLib.h>
#include <sysLib.h>

#define TTY_STRUCT int

#define sleep(a) taskDelay((a) * sysClkRateGet())

#include <vxWorks.h>
#include <sockLib.h>
#include <taskLib.h>

#define getpid taskIdSelf

/* NOTE: these are implemented by helpers in database app!
 * if the database is not linked, we need to implement them
 * elswhere */
struct hostent *gethostbyname(const char *name);
struct hostent *gethostbyaddr(const char *addr, int length, int type);
struct servent *getservbyname(const char *name, const char *proto);

#endif
/* end vxworks */

/* beos */
#if defined(OPENSSL_SYS_BEOS_R5)
#define SO_ERROR 0
#define NO_SYS_UN
#define IPPROTO_IP 0
#include <OS.h>
#endif

@


1.19
log
@resolve conflicts
@
text
@d371 7
@


1.18
log
@resolve conflicts, fix local changes
@
text
@a101 1
     typedef long ssize_t;
a341 2
#  define ssize_t long

a455 3
#    if defined(NeXT) || defined(OPENSSL_SYS_NEWS4) || defined(OPENSSL_SYS_SUNOS)
#      define ssize_t int /* ditto */
#    endif
a631 6
#endif

#if defined(__ultrix)
#  ifndef ssize_t
#    define ssize_t int 
#  endif
@


1.17
log
@resolve conflicts
@
text
@d115 1
a115 1
/* The following is used becaue of the small stack in some
a125 3
#if defined(OPENSSL_SYS_WIN16) && !defined(WIN16)
#  define WIN16
#endif
a152 1
#define EADDRINUSE		WSAEADDRINUSE
d180 7
d215 1
a215 1
#ifdef WIN16
d261 1
a261 1
	* routine with GetProcAddress() and/or quard NT-specific calls with
d268 3
a270 3
	* apparently appropriate to guard generic NT calls with GetVersion
	* alone, while NT 4.0 and above calls ought to be additionally
	* checked upon with GetProcAddress.
d274 12
d326 2
a327 2
          * but without /MD results in LINK warning LNK4049:
          * 'locally defined symbol "__iob" imported'.
d340 1
a340 1
#    include <winsock_extras.h>
d353 1
a353 6
#  if defined(WIN16) && defined(SSLEAY) && defined(_WINEXITNOPERSIST)
#    define EXIT(n) _wsetexit(_WINEXITNOPERSIST)
#    define OPENSSL_EXIT(n) do { if (n == 0) EXIT(n); return(n); } while(0)
#  else
#    define EXIT(n) exit(n)
#  endif
d374 1
a374 1
#else /* The non-microsoft world world */
a426 1
       extern void delay(unsigned milliseconds);
d466 4
d496 13
a508 2
#      include <winsock.h>
extern HINSTANCE _hInstance;
d580 1
d583 1
d626 12
a670 12
/* do we need to do this for getenv.
 * Just define getenv for use under windows */

#ifdef WIN16
/* How to do this needs to be thought out a bit more.... */
/*char *GETENV(char *);
#define Getenv	GETENV*/
#define Getenv	getenv
#else
#define Getenv getenv
#endif

d731 9
@


1.16
log
@resolve conflicts
@
text
@d272 1
d288 1
a288 1
       /* compensate for bug is VC6 ctype.h */
d294 25
@


1.15
log
@resolve conflicts
@
text
@d184 19
a212 1
#  define OPENSSL_NO_FP_API
d221 1
d254 17
d275 10
d286 8
d380 26
d459 9
d487 21
d592 3
d640 6
a645 7
#else
#  ifdef NO_STRINGS_H
    int	strcasecmp();
    int	strncasecmp();
#  else
#    include <strings.h>
#  endif /* NO_STRINGS_H */
@


1.14
log
@resolve conflicts
@
text
@d217 2
@


1.13
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d513 21
a537 1
# define strcasecmp stricmp
@


1.12
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d177 7
d260 1
a260 1
#    define EXIT(n) return(n)
d341 2
a528 4
#if defined(ioctlsocket)
#undef ioctlsocket
#endif
#define ioctlsocket(a,b,c) ioctl((a),(b),*(c))
@


1.11
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d157 7
d204 3
d220 1
a220 1
#  if !defined(WINNT)
d235 4
d249 3
a251 2
#  if defined(WIN16) && !defined(MONOLITH) && defined(SSLEAY) && defined(_WINEXITNOPERSIST)
#    define EXIT(n) { if (n == 0) _wsetexit(_WINEXITNOPERSIST); return(n); }
d253 1
a253 1
#    define EXIT(n)		return(n);
d269 5
a273 1
#  define DEFAULT_HOME  "C:"
d309 1
a309 2
#    if !defined(MONOLITH) || defined(OPENSSL_C)
#      define EXIT(n)		do { int __VMS_EXIT = n; \
d315 1
a315 5
				     exit(__VMS_EXIT); \
				     return(__VMS_EXIT); } while(0)
#    else
#      define EXIT(n)		return(n)
#    endif
d346 1
a346 5
#    ifndef MONOLITH
#      define EXIT(n)		exit(n); return(n)
#    else
#      define EXIT(n)		return(n)
#    endif
d357 1
a357 1
#  if (defined(WINDOWS) || defined(MSDOS)) && !defined(__DJGPP__)
d365 1
a365 1
#    else
d372 5
d473 8
d510 30
@


1.10
log
@merge with 0.9.7-beta1
@
text
@d194 8
d347 1
a347 1
#  if defined(WINDOWS) || defined(MSDOS)
d434 1
d436 1
@


1.9
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d82 1
a82 1
#define DEVRANDOM  "/dev/arandom","/dev/urandom","/dev/random","/dev/srandom"
@


1.8
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d117 1
a117 1
#if defined(OPENSSL_SYS_MSDOS)
@


1.7
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d80 9
a88 3
/* set this to your 'random' device if you have one.
 * By default, we will try to read this file */
#define DEVRANDOM "/dev/arandom"
d91 7
a97 1
#if defined(__MWERKS__) && defined(macintosh)
d117 1
a117 1
#if defined(WIN16) || defined(MSDOS)
d123 1
a123 1
#if defined(_WIN32) && !defined(WIN32) && !defined(__CYGWIN32__)
d126 8
a133 8

#if (defined(WIN32) || defined(WIN16)) && !defined(__CYGWIN32__)
#  ifndef WINDOWS
#    define WINDOWS
#  endif
#  ifndef MSDOS
#    define MSDOS
#  endif
d151 1
a151 1
#if defined(WINDOWS) && !defined(__CYGWIN32__)
d163 7
d180 1
a180 1
#  define NO_FP_API
d188 2
a189 2
#ifdef NO_STDIO
#  define NO_FP_API
d192 1
a192 1
#if (defined(WINDOWS) || defined(MSDOS)) && !defined(__CYGWIN32__)
d194 3
a196 3
#ifndef S_IFDIR
#define S_IFDIR	_S_IFDIR
#endif
d198 3
a200 2
#ifndef S_IFMT
#define S_IFMT	_S_IFMT
d202 4
a205 6
#if !defined(WINNT)
#define NO_SYSLOG
#endif
#define NO_DIRENT

#endif
d217 9
a225 7
#if defined (__BORLANDC__)
#define _setmode setmode
#define _O_TEXT O_TEXT
#define _O_BINARY O_BINARY
#define _int64 __int64
#define _kbhit kbhit
#endif
d227 5
a231 5
#if defined(WIN16) && !defined(MONOLITH) && defined(SSLEAY) && defined(_WINEXITNOPERSIST)
#  define EXIT(n) { if (n == 0) _wsetexit(_WINEXITNOPERSIST); return(n); }
#else
#  define EXIT(n)		return(n);
#endif
d233 9
a241 9
#ifndef X_OK
#  define X_OK	0
#endif
#ifndef W_OK
#  define W_OK	2
#endif
#ifndef R_OK
#  define R_OK	4
#endif
d250 2
a251 5
#  if defined(__VMS) && !defined(VMS)
#  define VMS 1
#  endif

#  ifdef VMS
d265 18
a282 3
  /* We need to do this, because DEC C converts exit code 0 to 1, but not 1
     to 0.  We will convert 1 to 3!  Also, add the inhibit message bit... */
#    ifndef MONOLITH
d284 4
a287 1
                                     if (__VMS_EXIT == 1) __VMS_EXIT = 3; \
d289 2
a290 1
				     exit(n); return(n); } while(0)
d292 1
a292 4
#      define EXIT(n)		do { int __VMS_EXIT = n; \
                                     if (__VMS_EXIT == 1) __VMS_EXIT = 3; \
                                     __VMS_EXIT |= 0x10000000; \
				     return(n); } while(0)
d297 1
a297 1
#    ifdef MPE
d308 1
a308 1
#    if defined(NeXT) || defined(NEWS4)
d314 1
a314 1
#    ifdef NEWS4 /* setvbuf is missing on mips-sony-bsd */
d342 1
a342 1
#    ifdef NO_SOCK
d369 3
a371 1
#    ifndef MPE
d376 1
a376 1
#    if defined(VMS) && !defined(__DECC)
d394 1
a394 1
#    ifdef AIX
d430 4
a433 4
#if defined(THREADS) || defined(sun)
#ifndef _REENTRANT
#define _REENTRANT
#endif
d437 3
d467 1
a467 1
#ifdef SNI
d471 5
a475 11
#ifdef NO_MD2
#define MD2_Init MD2Init
#define MD2_Update MD2Update
#define MD2_Final MD2Final
#define MD2_DIGEST_LENGTH 16
#endif
#ifdef NO_MD5
#define MD5_Init MD5Init 
#define MD5_Update MD5Update
#define MD5_Final MD5Final
#define MD5_DIGEST_LENGTH 16
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d226 1
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d343 1
d350 1
@


1.4
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d90 1
d111 1
a111 1
#if defined(_WIN32) && !defined(WIN32)
d115 1
a115 1
#if defined(WIN32) || defined(WIN16)
d139 1
a139 1
#ifdef WINDOWS
d173 1
a173 1
#if defined(WINDOWS) || defined(MSDOS)
d263 3
d274 10
d335 3
a337 1
#    include <sys/time.h> /* Needed under linux for FD_XXX */
d360 4
d396 9
@


1.3
log
@use /dev/arandom by default
@
text
@d85 14
d110 4
d123 4
d144 6
d203 1
d259 1
d262 8
a269 1
#    include OPENSSL_UNISTD
d308 7
d318 1
a318 2
#    include <sys/types.h>
#    ifndef VMS
d366 2
a367 2
#    define SHUTDOWN(fd)    { shutdown((fd),0); close((fd)); }
#    define SHUTDOWN2(fd)   { shutdown((fd),2); close((fd)); }
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d81 2
a82 2
 * My default, we will try to read this file */
#define DEVRANDOM "/dev/urandom"
@


1.1
log
@Initial revision
@
text
@d62 7
a84 4
#if defined(NOCONST)
#define const
#endif

d108 3
d119 3
d126 3
d152 3
d156 1
d158 1
a158 1
#define strncasecmp(a,b,c)	strnicmp((a),(b),(c))
d170 7
d192 2
a193 1
#  define SSLEAY_CONF	"ssleay.cnf"
d199 4
d204 26
a229 1
#    include <unixlib.h>
d231 2
a232 2
#    include <unistd.h>
#  endif
d234 10
a243 7
#  define SSLEAY_CONF	"ssleay.cnf"
#  define RFILE		".rnd"
#  define LIST_SEPARATOR_CHAR ':'
#  ifndef MONOLITH
#    define EXIT(n)		exit(n); return(n)
#  else
#    define EXIT(n)		return(n)
a244 1
#  define NUL_DEV		"/dev/null"
d250 1
d274 1
d276 9
a284 3
      /* unix world */
#      include <netdb.h>
#      include <sys/types.h>
a288 2
#      include <sys/param.h>
#      include <sys/time.h> /* Needed under linux for FD_XXX */
d304 8
a311 1
#      include <sys/ioctl.h>
d316 3
d325 1
a325 1
#    define INVALID_SOCKET	-1
a336 20
#ifndef NOPROTO
#define P_CC_CC	const void *,const void *
#define P_I_I		int,int 
#define P_I_I_P		int,int,char *
#define P_I_I_P_I	int,int,char *,int
#define P_IP_I_I_P_I	int *,int,int,char *,int
#define P_V		void 
#else
#define P_CC_CC
#define P_I_I
#define P_I_I_P
#define P_IP_I_I_P_I
#define P_I_I_P_I
#define P_V
#endif

/* not used yet */
#define	CS_BEGIN
#define CS_END

d353 3
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a61 7
#include <openssl/opensslconf.h>

#include <openssl/e_os2.h>
/* <openssl/e_os2.h> contains what we can justify to make visible
 * to the outside; this file e_os.h is not part of the exported
 * interface. */

d73 7
a79 30
/* set this to a comma-separated list of 'random' device files to try out.
 * My default, we will try to read at least one of these files */
#define DEVRANDOM "/dev/urandom","/dev/random","/dev/srandom"
#endif
#ifndef DEVRANDOM_EGD
/* set this to a comma-seperated list of 'egd' sockets to try out. These
 * sockets will be tried in the order listed in case accessing the device files
 * listed in DEVRANDOM did not return enough entropy. */
#define DEVRANDOM_EGD "/var/run/egd-pool","/dev/egd-pool","/etc/egd-pool","/etc/entropy"
#endif

#if defined(OPENSSL_SYS_VXWORKS)
#  define NO_SYS_PARAM_H
#  define NO_CHMOD
#  define NO_SYSLOG
#endif
  
#if defined(OPENSSL_SYS_MACINTOSH_CLASSIC)
# if macintosh==1
#  ifndef MAC_OS_GUSI_SOURCE
#    define MAC_OS_pre_X
#    define NO_SYS_TYPES_H
     typedef long ssize_t;
#  endif
#  define NO_SYS_PARAM_H
#  define NO_CHMOD
#  define NO_SYSLOG
#  undef  DEVRANDOM
#  define GETPID_IS_MEANINGLESS
# endif
d87 1
a87 1
#if defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYSNAME_WIN32)
d93 7
a99 15
#if defined(OPENSSL_SYS_WIN32) && !defined(WIN32)
#  define WIN32
#endif
#if defined(OPENSSL_SYS_WIN16) && !defined(WIN16)
#  define WIN16
#endif
#if defined(OPENSSL_SYS_WINDOWS) && !defined(WINDOWS)
#  define WINDOWS
#endif
#if defined(OPENSSL_SYS_MSDOS) && !defined(MSDOS)
#  define MSDOS
#endif

#if defined(MSDOS) && !defined(GETPID_IS_MEANINGLESS)
#  define GETPID_IS_MEANINGLESS
a104 3
#if !defined(WINNT)
#define WIN_CONSOLE_BUG
#endif
d110 1
a110 1
#if defined(WINDOWS)
a112 16
#define readsocket(s,b,n)	recv((s),(b),(n),0)
#define writesocket(s,b,n)	send((s),(b),(n),0)
#define EADDRINUSE		WSAEADDRINUSE
#elif defined(MAC_OS_pre_X)
#define get_last_socket_error()	errno
#define clear_socket_error()	errno=0
#define closesocket(s)		MacSocket_close(s)
#define readsocket(s,b,n)	MacSocket_recv((s),(b),(n),true)
#define writesocket(s,b,n)	MacSocket_send((s),(b),(n))
#elif defined(OPENSSL_SYS_VMS)
#define get_last_socket_error() errno
#define clear_socket_error()    errno=0
#define ioctlsocket(a,b,c)      ioctl(a,b,c)
#define closesocket(s)          close(s)
#define readsocket(s,b,n)       recv((s),(b),(n),0)
#define writesocket(s,b,n)      send((s),(b),(n),0)
a116 3
#define closesocket(s)		close(s)
#define readsocket(s,b,n)	read((s),(b),(n))
#define writesocket(s,b,n)	write((s),(b),(n))
d120 1
a120 1
#  define OPENSSL_NO_FP_API
d128 2
a129 2
#ifdef OPENSSL_NO_STDIO
#  define OPENSSL_NO_FP_API
d132 1
a132 1
#if (defined(WINDOWS) || defined(MSDOS))
d134 3
a136 3
#  ifndef S_IFDIR
#    define S_IFDIR	_S_IFDIR
#  endif
d138 3
a140 3
#  ifndef S_IFMT
#    define S_IFMT	_S_IFMT
#  endif
d142 1
a142 4
#  if !defined(WINNT)
#    define NO_SYSLOG
#  endif
#  define NO_DIRENT
d154 5
a158 15
#  define ssize_t long

#  if defined (__BORLANDC__)
#    define _setmode setmode
#    define _O_TEXT O_TEXT
#    define _O_BINARY O_BINARY
#    define _int64 __int64
#    define _kbhit kbhit
#  endif

#  if defined(WIN16) && !defined(MONOLITH) && defined(SSLEAY) && defined(_WINEXITNOPERSIST)
#    define EXIT(n) { if (n == 0) _wsetexit(_WINEXITNOPERSIST); return(n); }
#  else
#    define EXIT(n)		return(n);
#  endif
d160 10
a169 11
#  ifndef X_OK
#    define X_OK	0
#  endif
#  ifndef W_OK
#    define W_OK	2
#  endif
#  ifndef R_OK
#    define R_OK	4
#  endif
#  define OPENSSL_CONF	"openssl.cnf"
#  define SSLEAY_CONF	OPENSSL_CONF
a171 1
#  define DEFAULT_HOME  "C:"
d175 2
a176 45
#  ifdef OPENSSL_SYS_VMS
#    define VMS 1
  /* some programs don't include stdlib, so exit() and others give implicit 
     function warnings */
#    include <stdlib.h>
#    if defined(__DECC)
#      include <unistd.h>
#    else
#      include <unixlib.h>
#    endif
#    define OPENSSL_CONF	"openssl.cnf"
#    define SSLEAY_CONF		OPENSSL_CONF
#    define RFILE		".rnd"
#    define LIST_SEPARATOR_CHAR ','
#    define NUL_DEV		"NLA0:"
  /* We don't have any well-defined random devices on VMS, yet... */
#    undef DEVRANDOM
  /* We need to do this since VMS has the following coding on status codes:

     Bits 0-2: status type: 0 = warning, 1 = success, 2 = error, 3 = info ...
               The important thing to know is that odd numbers are considered
	       good, while even ones are considered errors.
     Bits 3-15: actual status number
     Bits 16-27: facility number.  0 is considered "unknown"
     Bits 28-31: control bits.  If bit 28 is set, the shell won't try to
                 output the message (which, for random codes, just looks ugly)

     So, what we do here is to change 0 to 1 to get the default success status,
     and everything else is shifted up to fit into the status number field, and
     the status is tagged as an error, which I believe is what is wanted here.
     -- Richard Levitte
  */
#    if !defined(MONOLITH) || defined(OPENSSL_C)
#      define EXIT(n)		do { int __VMS_EXIT = n; \
                                     if (__VMS_EXIT == 0) \
				       __VMS_EXIT = 1; \
				     else \
				       __VMS_EXIT = (n << 3) | 2; \
                                     __VMS_EXIT |= 0x10000000; \
				     exit(__VMS_EXIT); \
				     return(__VMS_EXIT); } while(0)
#    else
#      define EXIT(n)		return(n)
#    endif
#    define NO_SYS_PARAM_H
d178 2
a179 22
     /* !defined VMS */
#    ifdef OPENSSL_SYS_MPE
#      define NO_SYS_PARAM_H
#    endif
#    ifdef OPENSSL_UNISTD
#      include OPENSSL_UNISTD
#    else
#      include <unistd.h>
#    endif
#    ifndef NO_SYS_TYPES_H
#      include <sys/types.h>
#    endif
#    if defined(NeXT) || defined(OPENSSL_SYS_NEWS4)
#      define pid_t int /* pid_t is missing on NEXTSTEP/OPENSTEP
                         * (unless when compiling with -D_POSIX_SOURCE,
                         * which doesn't work for us) */
#      define ssize_t int /* ditto */
#    endif
#    ifdef OPENSSL_SYS_NEWS4 /* setvbuf is missing on mips-sony-bsd */
#      define setvbuf(a, b, c, d) setbuffer((a), (b), (d))
       typedef unsigned long clock_t;
#    endif
d181 7
a187 10
#    define OPENSSL_CONF	"openssl.cnf"
#    define SSLEAY_CONF		OPENSSL_CONF
#    define RFILE		".rnd"
#    define LIST_SEPARATOR_CHAR ':'
#    define NUL_DEV		"/dev/null"
#    ifndef MONOLITH
#      define EXIT(n)		exit(n); return(n)
#    else
#      define EXIT(n)		return(n)
#    endif
d189 1
a194 1

d201 1
a201 1
#    ifdef OPENSSL_NO_SOCK
a214 7
#  elif defined(MAC_OS_pre_X)

#    include "MacSocket.h"
#    define SSLeay_Write(a,b,c)		MacSocket_send((a),(b),(c))
#    define SSLeay_Read(a,b,c)		MacSocket_recv((a),(b),(c),true)
#    define SHUTDOWN(fd)		MacSocket_close(fd)
#    define SHUTDOWN2(fd)		MacSocket_close(fd)
d218 4
a221 15
#    ifndef NO_SYS_PARAM_H
#      include <sys/param.h>
#    endif
#    ifdef OPENSSL_SYS_VXWORKS
#      include <time.h> 
#    elif !defined(OPENSSL_SYS_MPE)
#      include <sys/time.h> /* Needed under linux for FD_XXX */
#    endif

#    include <netdb.h>
#    if defined(OPENSSL_SYS_VMS_NODECC)
#      include <socket.h>
#      include <in.h>
#      include <inet.h>
#    else
d226 2
a228 1
#      include <arpa/inet.h>
d236 1
a236 5
#    ifdef OPENSSL_SYS_AIX
#      include <sys/select.h>
#    endif

#    ifdef __QNX__
d243 1
a243 8
#      ifndef VMS
#        include <sys/ioctl.h>
#      else
	 /* ioctl is only in VMS > 7.0 and when socketshr is not used */
#        if !defined(TCPIP_TYPE_SOCKETSHR) && defined(__VMS_VER) && (__VMS_VER > 70000000)
#          include <sys/ioctl.h>
#        endif
#      endif
a247 3
#      if defined(TCPIP_TYPE_SOCKETSHR)
#        include <socketshr.h>
#      endif
d252 3
a254 3
#    define SHUTDOWN(fd)    { shutdown((fd),0); closesocket((fd)); }
#    define SHUTDOWN2(fd)   { shutdown((fd),2); closesocket((fd)); }
#    define INVALID_SOCKET	(-1)
d258 4
a261 4
#if defined(__ultrix)
#  ifndef ssize_t
#    define ssize_t int 
#  endif
d264 16
a279 10
#if defined(sun) && !defined(__svr4__) && !defined(__SVR4)
  /* include headers first, so our defines don't break it */
#include <stdlib.h>
#include <string.h>
  /* bcopy can handle overlapping moves according to SunOS 4.1.4 manpage */
# define memmove(s1,s2,n) bcopy((s2),(s1),(n))
# define strtoul(s,e,b) ((unsigned long int)strtol((s),(e),(b)))
extern char *sys_errlist[]; extern int sys_nerr;
# define strerror(errnum) \
	(((errnum)<0 || (errnum)>=sys_nerr) ? NULL : sys_errlist[errnum])
d282 3
a284 1
/***********************************************/
a302 3
#ifdef OPENSSL_SYS_SNI
#define IRIX_CC_BUG	/* CDS++ up to V2.0Bsomething suffered from the same bug.*/
#endif
d304 11
a314 5
#if defined(OPENSSL_SYS_OS2) && defined(__EMX__)
# include <io.h>
# include <fcntl.h>
# define NO_SYSLOG
# define strcasecmp stricmp
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a193 8
#  ifdef __DJGPP__
#    include <unistd.h>
#    include <sys/stat.h>
#    define _setmode setmode
#    define _O_TEXT O_TEXT
#    define _O_BINARY O_BINARY
#  endif /* __DJGPP__ */

d339 1
a339 1
#  if (defined(WINDOWS) || defined(MSDOS)) && !defined(__DJGPP__)
a425 1
#    ifndef INVALID_SOCKET
a426 1
#    endif /* INVALID_SOCKET */
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a156 7
#elif defined(__DJGPP__)
#define WATT32
#define get_last_socket_error()	errno
#define clear_socket_error()	errno=0
#define closesocket(s)		close_s(s)
#define readsocket(s,b,n)	read_s(s,b,n)
#define writesocket(s,b,n)	send(s,b,n,0)
a196 3
#    include <sys/socket.h>
#    include <tcp.h>
#    include <netdb.h>
d210 1
a210 1
#  if !defined(WINNT) && !defined(__DJGPP__)
a224 4
#  ifdef OPENSSL_SYS_WINCE
#    include <winsock_extras.h>
#  endif

d235 2
a236 3
#  if defined(WIN16) && defined(SSLEAY) && defined(_WINEXITNOPERSIST)
#    define EXIT(n) _wsetexit(_WINEXITNOPERSIST)
#    define OPENSSL_EXIT(n) do { if (n == 0) EXIT(n); return(n); } while(0)
d238 1
a238 1
#    define EXIT(n) return(n)
d254 1
a254 5
#  ifdef OPENSSL_SYS_WINCE
#    define DEFAULT_HOME  ""
#  else
#    define DEFAULT_HOME  "C:"
#  endif
d290 2
a291 1
#    define EXIT(n)		do { int __VMS_EXIT = n; \
d297 5
a301 1
				     exit(__VMS_EXIT); } while(0)
d332 5
a336 1
#    define EXIT(n)		exit(n)
d347 1
a347 1
#  if defined(WINDOWS) || defined(MSDOS)
d355 1
a355 1
#    elif !defined(__DJGPP__)
a361 5
#    else
#      define SSLeay_Write(a,b,c)	write_s(a,b,c,0)
#      define SSLeay_Read(a,b,c)	read_s(a,b,c)
#      define SHUTDOWN(fd)		close_s(fd)
#      define SHUTDOWN2(fd)		close_s(fd)
a457 8
#ifndef OPENSSL_EXIT
# if defined(MONOLITH) && !defined(OPENSSL_C)
#  define OPENSSL_EXIT(n) return(n)
# else
#  define OPENSSL_EXIT(n) do { EXIT(n); return(n); } while(0)
# endif
#endif

a486 30

/* vxworks */
#if defined(OPENSSL_SYS_VXWORKS)
#include <ioLib.h>
#include <tickLib.h>
#include <sysLib.h>

#define TTY_STRUCT int

#define sleep(a) taskDelay((a) * sysClkRateGet())
#if defined(ioctlsocket)
#undef ioctlsocket
#endif
#define ioctlsocket(a,b,c) ioctl((a),(b),*(c))

#include <vxWorks.h>
#include <sockLib.h>
#include <taskLib.h>

#define getpid taskIdSelf

/* NOTE: these are implemented by helpers in database app!
 * if the database is not linked, we need to implement them
 * elswhere */
struct hostent *gethostbyname(const char *name);
struct hostent *gethostbyaddr(const char *addr, int length, int type);
struct servent *getservbyname(const char *name, const char *proto);

#endif
/* end vxworks */
@


1.1.1.5
log
@import 0.9.7c
@
text
@a176 7
#elif defined(OPENSSL_SYS_VXWORKS)
#define get_last_socket_error()	errno
#define clear_socket_error()	errno=0
#define ioctlsocket(a,b,c)	    ioctl((a),(b),(int)(c))
#define closesocket(s)		    close(s)
#define readsocket(s,b,n)	    read((s),(b),(n))
#define writesocket(s,b,n)	    write((s),(char *)(b),(n))
d253 1
a253 1
#    define EXIT(n) exit(n)
a333 2
#    endif
#    if defined(NeXT) || defined(OPENSSL_SYS_NEWS4) || defined(OPENSSL_SYS_SUNOS)
d520 4
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a512 21
#if defined(OPENSSL_SYS_WINDOWS)
#  define strcasecmp _stricmp
#  define strncasecmp _strnicmp
#elif defined(OPENSSL_SYS_VMS)
/* VMS below version 7.0 doesn't have strcasecmp() */
#  include "o_str.h"
#  define strcasecmp OPENSSL_strcasecmp
#  define strncasecmp OPENSSL_strncasecmp
#  define OPENSSL_IMPLEMENTS_strncasecmp
#elif defined(OPENSSL_SYS_OS2) && defined(__EMX__)
#  define strcasecmp stricmp
#  define strncasecmp strnicmp
#else
#  ifdef NO_STRINGS_H
    int	strcasecmp();
    int	strncasecmp();
#  else
#    include <strings.h>
#  endif /* NO_STRINGS_H */
#endif

d517 1
@


1.1.1.7
log
@import of openssl-0.9.7j
@
text
@a216 2
#    undef DEVRANDOM
#    define DEVRANDOM "/dev/urandom\x24"
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@a183 19
#elif defined(OPENSSL_SYS_NETWARE)
#if defined(NETWARE_BSDSOCK)
#define get_last_socket_error() errno
#define clear_socket_error()    errno=0
#define closesocket(s)          close(s)
#define ioctlsocket(a,b,c)      ioctl(a,b,c)
#if defined(NETWARE_LIBC)
#define readsocket(s,b,n)       recv((s),(b),(n),0)
#define writesocket(s,b,n)      send((s),(b),(n),0)
#else
#define readsocket(s,b,n)       recv((s),(char*)(b),(n),0)
#define writesocket(s,b,n)      send((s),(char*)(b),(n),0)
#endif
#else
#define get_last_socket_error()	WSAGetLastError()
#define clear_socket_error()	WSASetLastError(0)
#define readsocket(s,b,n)		recv((s),(b),(n),0)
#define writesocket(s,b,n)		send((s),(b),(n),0)
#endif
d194 1
a202 1
#  undef OPENSSL_NO_FP_API
a234 17
#    if !defined(_WIN32_WCE) && !defined(_WIN32_WINNT)
       /*
	* Defining _WIN32_WINNT here in e_os.h implies certain "discipline."
	* Most notably we ought to check for availability of each specific
	* routine with GetProcAddress() and/or quard NT-specific calls with
	* GetVersion() < 0x80000000. One can argue that in latter "or" case
	* we ought to /DELAYLOAD some .DLLs in order to protect ourselves
	* against run-time link errors. This doesn't seem to be necessary,
	* because it turned out that already Windows 95, first non-NT Win32
	* implementation, is equipped with at least NT 3.51 stubs, dummy
	* routines with same name, but which do nothing. Meaning that it's
	* apparently appropriate to guard generic NT calls with GetVersion
	* alone, while NT 4.0 and above calls ought to be additionally
	* checked upon with GetProcAddress.
	*/
#      define _WIN32_WINNT 0x0400
#    endif
a238 10
#    ifdef _WIN64
#      define strlen(s) _strlen31(s)
/* cut strings to 2GB */
static unsigned int _strlen31(const char *str)
	{
	unsigned int len=0;
	while (*str && len<0x80000000U) str++, len++;
	return len&0x7FFFFFFF;
	}
#    endif
a239 8
#    if defined(_MSC_VER) && _MSC_VER<=1200 && defined(_MT) && defined(isspace)
       /* compensate for bug is VC6 ctype.h */
#      undef isspace
#      undef isdigit
#      undef isalnum
#      undef isupper
#      undef isxdigit
#    endif
a325 26

#  elif defined(OPENSSL_SYS_NETWARE)
#    include <fcntl.h>
#    include <unistd.h>
#    define NO_SYS_TYPES_H
#    undef  DEVRANDOM
#    ifdef NETWARE_CLIB
#      define getpid GetThreadID
       extern int GetThreadID(void);
/* #      include <conio.h> */
       extern int kbhit(void);
       extern void delay(unsigned milliseconds);
#    else
#      include <screen.h>
#    endif
#    define NO_SYSLOG
#    define _setmode setmode
#    define _kbhit kbhit
#    define _O_TEXT O_TEXT
#    define _O_BINARY O_BINARY
#    define OPENSSL_CONF   "openssl.cnf"
#    define SSLEAY_CONF    OPENSSL_CONF
#    define RFILE    ".rnd"
#    define LIST_SEPARATOR_CHAR ';'
#    define EXIT(n)  { if (n) printf("ERROR: %d\n", (int)n); exit(n); }

a378 9
#      ifdef _WIN64
/*
 * Even though sizeof(SOCKET) is 8, it's safe to cast it to int, because
 * the value constitutes an index in per-process table of limited size
 * and not a real pointer.
 */
#        define socket(d,t,p)	((int)socket(d,t,p))
#        define accept(s,f,l)	((int)accept(s,f,l))
#      endif
a397 21
#  elif defined(OPENSSL_SYS_NETWARE)
         /* NetWare uses the WinSock2 interfaces by default, but can be configured for BSD
         */
#      if defined(NETWARE_BSDSOCK)
#        include <sys/socket.h>
#        include <netinet/in.h>
#        include <sys/time.h>
#        if defined(NETWARE_CLIB)
#          include <sys/bsdskt.h>
#        else
#          include <sys/select.h>
#        endif
#        define INVALID_SOCKET (int)(~0)
#      else
#        include <novsock2.h>
#      endif
#      define SSLeay_Write(a,b,c)   send((a),(b),(c),0)
#      define SSLeay_Read(a,b,c) recv((a),(b),(c),0)
#      define SHUTDOWN(fd)    { shutdown((fd),0); closesocket(fd); }
#      define SHUTDOWN2(fd)      { shutdown((fd),2); closesocket(fd); }

a481 3
  /* Being signed SunOS 4.x memcpy breaks ASN1_OBJECT table lookup */
#include "crypto/o_str.h"
# define memcmp OPENSSL_memcmp
d527 7
a533 6
#elif defined(OPENSSL_SYS_NETWARE)
#  include <string.h>
#  if defined(NETWARE_CLIB)
#    define strcasecmp stricmp
#    define strncasecmp strnicmp
#  endif /* NETWARE_CLIB */
@


1.1.1.9
log
@import openssl-0.9.8j
@
text
@a271 1
#    include <stdio.h>
d287 1
a287 1
       /* compensate for bug in VC6 ctype.h */
a292 25
#    endif
#    if defined(_MSC_VER) && !defined(_DLL) && defined(stdin)
#      if _MSC_VER>=1300
#        undef stdin
#        undef stdout
#        undef stderr
         FILE *__iob_func();
#        define stdin  (&__iob_func()[0])
#        define stdout (&__iob_func()[1])
#        define stderr (&__iob_func()[2])
#      elif defined(I_CAN_LIVE_WITH_LNK4049)
#        undef stdin
#        undef stdout
#        undef stderr
         /* pre-1300 has __p__iob(), but it's available only in msvcrt.lib,
          * or in other words with /MD. Declaring implicit import, i.e.
          * with _imp_ prefix, works correctly with all compiler options,
          * but without /MD results in LINK warning LNK4049:
          * 'locally defined symbol "__iob" imported'.
          */
         extern FILE *_imp___iob;
#        define stdin  (&_imp___iob[0])
#        define stdout (&_imp___iob[1])
#        define stderr (&_imp___iob[2])
#      endif
@


1.1.1.10
log
@import OpenSSL-1.0.0a
@
text
@d115 1
a115 1
/* The following is used because of the small stack in some
d126 3
d156 1
a183 7
#elif defined(OPENSSL_SYS_BEOS_R5)
#define get_last_socket_error() errno
#define clear_socket_error()    errno=0
#define FIONBIO SO_NONBLOCK
#define ioctlsocket(a,b,c)		  setsockopt((a),SOL_SOCKET,(b),(c),sizeof(*(c)))
#define readsocket(s,b,n)       recv((s),(b),(n),0)
#define writesocket(s,b,n)      send((s),(b),(n),0)
d212 1
a212 1
#ifdef WIN16 /* never the case */
d258 1
a258 1
	* routine with GetProcAddress() and/or guard NT-specific calls with
d265 3
a267 3
	* apparently sufficient to guard "vanilla" NT calls with GetVersion
	* alone, while NT 4.0 and above interfaces ought to be linked with
	* GetProcAddress at run-time.
a270 12
#    if !defined(OPENSSL_NO_SOCK) && defined(_WIN32_WINNT)
       /*
        * Just like defining _WIN32_WINNT including winsock2.h implies
        * certain "discipline" for maintaining [broad] binary compatibility.
        * As long as structures are invariant among Winsock versions,
        * it's sufficient to check for specific Winsock2 API availability
        * at run-time [DSO_global_lookup is recommended]...
        */
#      include <winsock2.h>
#      include <ws2tcpip.h>
       /* yes, they have to be #included prior to <windows.h> */
#    endif
d311 2
a312 2
	  * but without /MD results in LINK warning LNK4049:
	  * 'locally defined symbol "__iob" imported'.
d325 1
a325 1
#    define OPENSSL_NO_POSIX_IO
d338 6
a343 1
#  define EXIT(n) exit(n)
d364 1
a364 1
#else /* The non-microsoft world */
d417 1
a456 4
#    ifdef OPENSSL_SYS_WIN32_CYGWIN
#      include <io.h>
#      include <fcntl.h>
#    endif
d483 2
a484 13
#      if defined(_WIN32_WCE) && _WIN32_WCE<410
#        define getservbyname _masked_declaration_getservbyname
#      endif
#      if !defined(IPPROTO_IP)
         /* winsock[2].h was included already? */
#        include <winsock.h>
#      endif
#      ifdef getservbyname
#        undef getservbyname
         /* this is used to be wcecompat/include/winsock_extras.h */
         struct servent* PASCAL getservbyname(const char*,const char*);
#      endif

a555 1
#      if !defined(OPENSSL_SYS_BEOS_R5)
a557 1
#    endif
a599 12

/* Some IPv6 implementations are broken, disable them in known bad
 * versions.
 */
#  if !defined(OPENSSL_USE_IPV6)
#    if defined(AF_INET6) && !defined(OPENSSL_SYS_BEOS_BONE) && !defined(NETWARE_CLIB)
#      define OPENSSL_USE_IPV6 1
#    else
#      define OPENSSL_USE_IPV6 0
#    endif
#  endif

d633 12
a704 9

/* beos */
#if defined(OPENSSL_SYS_BEOS_R5)
#define SO_ERROR 0
#define NO_SYS_UN
#define IPPROTO_IP 0
#include <OS.h>
#endif

@


1.1.1.11
log
@import OpenSSL-1.0.1c
@
text
@d102 1
d343 2
d459 3
d638 6
@


1.1.1.12
log
@Import OpenSSL 1.0.1g
@
text
@a370 7
/* Avoid Windows 8 SDK GetVersion deprecated problems */
#if defined(_MSC_VER) && _MSC_VER>=1800
#  define check_winnt() (1)
#else
#  define check_winnt() (GetVersion() < 0x80000000)
#endif 

@


