head	1.64;
access;
symbols
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	butholakala:1.16
	openssl_1_0_1_g:1.1.1.12
	OPENBSD_5_5:1.15.0.8
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	openssl_1_0_1_c:1.1.1.11
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	openssl_1_0_0_f:1.1.1.10
	openssl_1_0_0_e:1.1.1.10
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	openssh_1_0_0_a:1.1.1.9
	OPENBSD_4_8:1.12.0.8
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.4
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	openssl_0_9_8_k:1.1.1.8
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	openssl_0_9_8_j:1.1.1.8
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.10
	OPENBSD_4_4:1.10.0.20
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.18
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.16
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.14
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENSSL_0_9_7G:1.1.1.6
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENSSL_0_9_7D:1.1.1.6
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENSSL_0_9_7C:1.1.1.6
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENSSL_0_9_7B:1.1.1.5
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.4
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.64
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.63;
commitid	7A7DObXgY4Fni8xJ;

1.63
date	2014.08.24.16.07.29;	author bcook;	state Exp;
branches;
next	1.62;
commitid	DkRmQqUr5tFLfwxx;

1.62
date	2014.07.25.06.05.32;	author doug;	state Exp;
branches;
next	1.61;
commitid	DnBLYuKKjvrWeH3R;

1.61
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	EB0l28piqIRSpBUh;

1.60
date	2014.07.12.19.31.21;	author jsing;	state Exp;
branches;
next	1.59;
commitid	X84oGf60c5Z5Yd6T;

1.59
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.58;
commitid	0NuggCO2WJOZj8Kh;

1.58
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.57;
commitid	cCGiAdDteN08GytD;

1.57
date	2014.07.10.08.59.15;	author bcook;	state Exp;
branches;
next	1.56;
commitid	N0T1dqn5PaVY11W8;

1.56
date	2014.07.09.21.02.35;	author tedu;	state Exp;
branches;
next	1.55;
commitid	ivoCf1icUxmbGXSc;

1.55
date	2014.07.09.20.59.41;	author tedu;	state Exp;
branches;
next	1.54;
commitid	2mQaONecDqKK2dqY;

1.54
date	2014.06.28.04.39.41;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	gGtvlhTlvaxlmOBo;

1.53
date	2014.06.13.04.29.13;	author miod;	state Exp;
branches;
next	1.52;
commitid	8Qu6YceLSxhOi4yG;

1.52
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	mJUVYpkFBZ0Zv2bG;

1.51
date	2014.06.02.16.23.18;	author jsing;	state Exp;
branches;
next	1.50;
commitid	IqYoI5gjfSomu7k2;

1.50
date	2014.06.01.20.31.02;	author guenther;	state Exp;
branches;
next	1.49;
commitid	DF8buG0TsPKjTdV4;

1.49
date	2014.05.30.02.52.11;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.26.13.55.24;	author jsing;	state Exp;
branches;
next	1.47;

1.47
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.46;

1.46
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.07.21.32.19;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.06.01.54.42;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.06.01.52.07;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.05.16.14.45;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.02.17.06.46;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.22.14.54.13;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.19.16.46.08;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.19.16.31.51;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.18.15.39.53;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.18.09.38.42;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.18.04.17.17;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.18.01.07.13;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.17.22.44.34;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.17.21.45.45;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.16.18.23.52;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.16.02.50.09;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.15.21.47.56;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.15.17.46.16;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.13.23.31.37;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.13.20.37.11;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.01.22.58.51;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.09.12.15.19;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.11.22.15.18;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.02.50;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.56.58;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.13;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.19;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.09;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.09;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.38;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.34.45;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.43.07;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.34.25;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.11.11.21.11.06;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.13.49;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2011.11.03.02.32.07;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: s_server.c,v 1.63 2014/08/24 16:07:29 bcook Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

/* Until the key-gen callbacks are modified to use newer prototypes, we allow
 * deprecated functions for openssl-internal code */
#ifdef OPENSSL_NO_DEPRECATED
#undef OPENSSL_NO_DEPRECATED
#endif

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/socket.h>

#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>

#include "apps.h"

#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/lhash.h>
#include <openssl/ocsp.h>
#include <openssl/pem.h>
#include <openssl/rand.h>
#include <openssl/ssl.h>
#include <openssl/x509.h>

#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif

#include <openssl/rsa.h>

#include "s_apps.h"
#include "timeouts.h"

static RSA *tmp_rsa_cb(SSL * s, int is_export, int keylength);
static int sv_body(char *hostname, int s, unsigned char *context);
static int www_body(char *hostname, int s, unsigned char *context);
static void close_accept_socket(void);
static void sv_usage(void);
static int init_ssl_connection(SSL * s);
static void print_stats(BIO * bp, SSL_CTX * ctx);
static int
generate_session_id(const SSL * ssl, unsigned char *id,
    unsigned int *id_len);
#ifndef OPENSSL_NO_DH
static DH *load_dh_param(const char *dhfile);
static DH *get_dh512(void);
#endif

static void s_server_init(void);

#ifndef OPENSSL_NO_DH
static unsigned char dh512_p[] = {
	0xDA, 0x58, 0x3C, 0x16, 0xD9, 0x85, 0x22, 0x89, 0xD0, 0xE4, 0xAF, 0x75,
	0x6F, 0x4C, 0xCA, 0x92, 0xDD, 0x4B, 0xE5, 0x33, 0xB8, 0x04, 0xFB, 0x0F,
	0xED, 0x94, 0xEF, 0x9C, 0x8A, 0x44, 0x03, 0xED, 0x57, 0x46, 0x50, 0xD3,
	0x69, 0x99, 0xDB, 0x29, 0xD7, 0x76, 0x27, 0x6B, 0xA2, 0xD3, 0xD4, 0x12,
	0xE2, 0x18, 0xF4, 0xDD, 0x1E, 0x08, 0x4C, 0xF6, 0xD8, 0x00, 0x3E, 0x7C,
	0x47, 0x74, 0xE8, 0x33,
};
static unsigned char dh512_g[] = {
	0x02,
};

static DH *
get_dh512(void)
{
	DH *dh = NULL;

	if ((dh = DH_new()) == NULL)
		return (NULL);
	dh->p = BN_bin2bn(dh512_p, sizeof(dh512_p), NULL);
	dh->g = BN_bin2bn(dh512_g, sizeof(dh512_g), NULL);
	if ((dh->p == NULL) || (dh->g == NULL))
		return (NULL);
	return (dh);
}
#endif


/* static int load_CA(SSL_CTX *ctx, char *file);*/

#define BUFSIZZ	16*1024
static int bufsize = BUFSIZZ;
static int accept_socket = -1;

#define TEST_CERT	"server.pem"
#ifndef OPENSSL_NO_TLSEXT
#define TEST_CERT2	"server2.pem"
#endif

extern int verify_depth, verify_return_error;

static char *cipher = NULL;
static int s_server_verify = SSL_VERIFY_NONE;
static int s_server_session_id_context = 1;	/* anything will do */
static const char *s_cert_file = TEST_CERT, *s_key_file = NULL;
#ifndef OPENSSL_NO_TLSEXT
static const char *s_cert_file2 = TEST_CERT2, *s_key_file2 = NULL;
#endif
static char *s_dcert_file = NULL, *s_dkey_file = NULL;
static int s_nbio = 0;
static int s_nbio_test = 0;
int s_crlf = 0;
static SSL_CTX *ctx = NULL;
#ifndef OPENSSL_NO_TLSEXT
static SSL_CTX *ctx2 = NULL;
#endif
static int www = 0;

static BIO *bio_s_out = NULL;
static int s_debug = 0;
#ifndef OPENSSL_NO_TLSEXT
static int s_tlsextdebug = 0;
static int s_tlsextstatus = 0;
static int cert_status_cb(SSL * s, void *arg);
#endif
static int s_msg = 0;
static int s_quiet = 0;

static char *keymatexportlabel = NULL;
static int keymatexportlen = 20;

static int hack = 0;
#ifndef OPENSSL_NO_ENGINE
static char *engine_id = NULL;
#endif
static const char *session_id_prefix = NULL;

static int enable_timeouts = 0;
static long socket_mtu;
#ifndef OPENSSL_NO_DTLS1
static int cert_chain = 0;
#endif




static void
s_server_init(void)
{
	accept_socket = -1;
	cipher = NULL;
	s_server_verify = SSL_VERIFY_NONE;
	s_dcert_file = NULL;
	s_dkey_file = NULL;
	s_cert_file = TEST_CERT;
	s_key_file = NULL;
#ifndef OPENSSL_NO_TLSEXT
	s_cert_file2 = TEST_CERT2;
	s_key_file2 = NULL;
	ctx2 = NULL;
#endif
	s_nbio = 0;
	s_nbio_test = 0;
	ctx = NULL;
	www = 0;

	bio_s_out = NULL;
	s_debug = 0;
	s_msg = 0;
	s_quiet = 0;
	hack = 0;
#ifndef OPENSSL_NO_ENGINE
	engine_id = NULL;
#endif
}

static void
sv_usage(void)
{
	BIO_printf(bio_err, "usage: s_server [args ...]\n");
	BIO_printf(bio_err, "\n");
	BIO_printf(bio_err, " -accept arg   - port to accept on (default is %d)\n", PORT);
	BIO_printf(bio_err, " -context arg  - set session ID context\n");
	BIO_printf(bio_err, " -verify arg   - turn on peer certificate verification\n");
	BIO_printf(bio_err, " -Verify arg   - turn on peer certificate verification, must have a cert.\n");
	BIO_printf(bio_err, " -cert arg     - certificate file to use\n");
	BIO_printf(bio_err, "                 (default is %s)\n", TEST_CERT);
	BIO_printf(bio_err, " -crl_check    - check the peer certificate has not been revoked by its CA.\n" \
	    "                 The CRL(s) are appended to the certificate file\n");
	BIO_printf(bio_err, " -crl_check_all - check the peer certificate has not been revoked by its CA\n" \
	    "                 or any other CRL in the CA chain. CRL(s) are appended to the\n" \
	    "                 the certificate file.\n");
	BIO_printf(bio_err, " -certform arg - certificate format (PEM or DER) PEM default\n");
	BIO_printf(bio_err, " -key arg      - Private Key file to use, in cert file if\n");
	BIO_printf(bio_err, "                 not specified (default is %s)\n", TEST_CERT);
	BIO_printf(bio_err, " -keyform arg  - key format (PEM, DER or ENGINE) PEM default\n");
	BIO_printf(bio_err, " -pass arg     - private key file pass phrase source\n");
	BIO_printf(bio_err, " -dcert arg    - second certificate file to use (usually for DSA)\n");
	BIO_printf(bio_err, " -dcertform x  - second certificate format (PEM or DER) PEM default\n");
	BIO_printf(bio_err, " -dkey arg     - second private key file to use (usually for DSA)\n");
	BIO_printf(bio_err, " -dkeyform arg - second key format (PEM, DER or ENGINE) PEM default\n");
	BIO_printf(bio_err, " -dpass arg    - second private key file pass phrase source\n");
	BIO_printf(bio_err, " -dhparam arg  - DH parameter file to use, in cert file if not specified\n");
	BIO_printf(bio_err, "                 or a default set of parameters is used\n");
	BIO_printf(bio_err, " -named_curve arg  - Elliptic curve name to use for ephemeral ECDH keys.\n" \
	    "                 Use \"openssl ecparam -list_curves\" for all names\n" \
	    "                 (default is nistp256).\n");
	BIO_printf(bio_err, " -nbio         - Run with non-blocking IO\n");
	BIO_printf(bio_err, " -nbio_test    - test with the non-blocking test bio\n");
	BIO_printf(bio_err, " -crlf         - convert LF from terminal into CRLF\n");
	BIO_printf(bio_err, " -debug        - Print more output\n");
	BIO_printf(bio_err, " -msg          - Show protocol messages\n");
	BIO_printf(bio_err, " -state        - Print the SSL states\n");
	BIO_printf(bio_err, " -CApath arg   - PEM format directory of CA's\n");
	BIO_printf(bio_err, " -CAfile arg   - PEM format file of CA's\n");
	BIO_printf(bio_err, " -nocert       - Don't use any certificates (Anon-DH)\n");
	BIO_printf(bio_err, " -cipher arg   - play with 'openssl ciphers' to see what goes here\n");
	BIO_printf(bio_err, " -serverpref   - Use server's cipher preferences\n");
	BIO_printf(bio_err, " -quiet        - Inhibit printing of session and certificate information\n");
	BIO_printf(bio_err, " -no_tmp_rsa   - Do not generate a tmp RSA key\n");
	BIO_printf(bio_err, " -ssl3         - Just talk SSLv3\n");
	BIO_printf(bio_err, " -tls1_2       - Just talk TLSv1.2\n");
	BIO_printf(bio_err, " -tls1_1       - Just talk TLSv1.1\n");
	BIO_printf(bio_err, " -tls1         - Just talk TLSv1\n");
	BIO_printf(bio_err, " -dtls1        - Just talk DTLSv1\n");
	BIO_printf(bio_err, " -timeout      - Enable timeouts\n");
	BIO_printf(bio_err, " -mtu          - Set link layer MTU\n");
	BIO_printf(bio_err, " -chain        - Read a certificate chain\n");
	BIO_printf(bio_err, " -no_ssl2      - Just disable SSLv2\n");
	BIO_printf(bio_err, " -no_ssl3      - Just disable SSLv3\n");
	BIO_printf(bio_err, " -no_tls1      - Just disable TLSv1\n");
	BIO_printf(bio_err, " -no_tls1_1    - Just disable TLSv1.1\n");
	BIO_printf(bio_err, " -no_tls1_2    - Just disable TLSv1.2\n");
#ifndef OPENSSL_NO_DH
	BIO_printf(bio_err, " -no_dhe       - Disable ephemeral DH\n");
#endif
	BIO_printf(bio_err, " -no_ecdhe     - Disable ephemeral ECDH\n");
	BIO_printf(bio_err, " -bugs         - Turn on SSL bug compatibility\n");
	BIO_printf(bio_err, " -www          - Respond to a 'GET /' with a status page\n");
	BIO_printf(bio_err, " -WWW          - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\n");
	BIO_printf(bio_err, " -HTTP         - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\n");
	BIO_printf(bio_err, "                 with the assumption it contains a complete HTTP response.\n");
#ifndef OPENSSL_NO_ENGINE
	BIO_printf(bio_err, " -engine id    - Initialise and use the specified engine\n");
#endif
	BIO_printf(bio_err, " -id_prefix arg - Generate SSL/TLS session IDs prefixed by 'arg'\n");
#ifndef OPENSSL_NO_TLSEXT
	BIO_printf(bio_err, " -servername host - servername for HostName TLS extension\n");
	BIO_printf(bio_err, " -servername_fatal - on mismatch send fatal alert (default warning alert)\n");
	BIO_printf(bio_err, " -cert2 arg    - certificate file to use for servername\n");
	BIO_printf(bio_err, "                 (default is %s)\n", TEST_CERT2);
	BIO_printf(bio_err, " -key2 arg     - Private Key file to use for servername, in cert file if\n");
	BIO_printf(bio_err, "                 not specified (default is %s)\n", TEST_CERT2);
	BIO_printf(bio_err, " -tlsextdebug  - hex dump of all TLS extensions received\n");
	BIO_printf(bio_err, " -no_ticket    - disable use of RFC4507bis session tickets\n");
#ifndef OPENSSL_NO_NEXTPROTONEG
	BIO_printf(bio_err, " -nextprotoneg arg - set the advertised protocols for the NPN extension (comma-separated list)\n");
#endif
#ifndef OPENSSL_NO_SRTP
	BIO_printf(bio_err, " -use_srtp profiles - Offer SRTP key management with a colon-separated profile list\n");
#endif
#endif
	BIO_printf(bio_err, " -keymatexport label   - Export keying material using label\n");
	BIO_printf(bio_err, " -keymatexportlen len  - Export len bytes of keying material (default 20)\n");
}

static int local_argc = 0;
static char **local_argv;

#ifndef OPENSSL_NO_TLSEXT

/* This is a context that we pass to callbacks */
typedef struct tlsextctx_st {
	char *servername;
	BIO *biodebug;
	int extension_error;
} tlsextctx;


static int
ssl_servername_cb(SSL * s, int *ad, void *arg)
{
	tlsextctx *p = (tlsextctx *) arg;
	const char *servername = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);
	if (servername && p->biodebug)
		BIO_printf(p->biodebug, "Hostname in TLS extension: \"%s\"\n", servername);

	if (!p->servername)
		return SSL_TLSEXT_ERR_NOACK;

	if (servername) {
		if (strcmp(servername, p->servername))
			return p->extension_error;
		if (ctx2) {
			BIO_printf(p->biodebug, "Switching server context.\n");
			SSL_set_SSL_CTX(s, ctx2);
		}
	}
	return SSL_TLSEXT_ERR_OK;
}

/* Structure passed to cert status callback */

typedef struct tlsextstatusctx_st {
	/* Default responder to use */
	char *host, *path, *port;
	int use_ssl;
	int timeout;
	BIO *err;
	int verbose;
} tlsextstatusctx;

static tlsextstatusctx tlscstatp = {NULL, NULL, NULL, 0, -1, NULL, 0};

/* Certificate Status callback. This is called when a client includes a
 * certificate status request extension.
 *
 * This is a simplified version. It examines certificates each time and
 * makes one OCSP responder query for each request.
 *
 * A full version would store details such as the OCSP certificate IDs and
 * minimise the number of OCSP responses by caching them until they were
 * considered "expired".
 */

static int
cert_status_cb(SSL * s, void *arg)
{
	tlsextstatusctx *srctx = arg;
	BIO *err = srctx->err;
	char *host, *port, *path;
	int use_ssl;
	unsigned char *rspder = NULL;
	int rspderlen;
	STACK_OF(OPENSSL_STRING) * aia = NULL;
	X509 *x = NULL;
	X509_STORE_CTX inctx;
	X509_OBJECT obj;
	OCSP_REQUEST *req = NULL;
	OCSP_RESPONSE *resp = NULL;
	OCSP_CERTID *id = NULL;
	STACK_OF(X509_EXTENSION) * exts;
	int ret = SSL_TLSEXT_ERR_NOACK;
	int i;

	if (srctx->verbose)
		BIO_puts(err, "cert_status: callback called\n");
	/* Build up OCSP query from server certificate */
	x = SSL_get_certificate(s);
	aia = X509_get1_ocsp(x);
	if (aia) {
		if (!OCSP_parse_url(sk_OPENSSL_STRING_value(aia, 0),
			&host, &port, &path, &use_ssl)) {
			BIO_puts(err, "cert_status: can't parse AIA URL\n");
			goto err;
		}
		if (srctx->verbose)
			BIO_printf(err, "cert_status: AIA URL: %s\n",
			    sk_OPENSSL_STRING_value(aia, 0));
	} else {
		if (!srctx->host) {
			BIO_puts(srctx->err, "cert_status: no AIA and no default responder URL\n");
			goto done;
		}
		host = srctx->host;
		path = srctx->path;
		port = srctx->port;
		use_ssl = srctx->use_ssl;
	}

	if (!X509_STORE_CTX_init(&inctx,
		SSL_CTX_get_cert_store(SSL_get_SSL_CTX(s)),
		NULL, NULL))
		goto err;
	if (X509_STORE_get_by_subject(&inctx, X509_LU_X509,
		X509_get_issuer_name(x), &obj) <= 0) {
		BIO_puts(err, "cert_status: Can't retrieve issuer certificate.\n");
		X509_STORE_CTX_cleanup(&inctx);
		goto done;
	}
	req = OCSP_REQUEST_new();
	if (!req)
		goto err;
	id = OCSP_cert_to_id(NULL, x, obj.data.x509);
	X509_free(obj.data.x509);
	X509_STORE_CTX_cleanup(&inctx);
	if (!id)
		goto err;
	if (!OCSP_request_add0_id(req, id))
		goto err;
	id = NULL;
	/* Add any extensions to the request */
	SSL_get_tlsext_status_exts(s, &exts);
	for (i = 0; i < sk_X509_EXTENSION_num(exts); i++) {
		X509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);
		if (!OCSP_REQUEST_add_ext(req, ext, -1))
			goto err;
	}
	resp = process_responder(err, req, host, path, port, use_ssl, NULL,
	    srctx->timeout);
	if (!resp) {
		BIO_puts(err, "cert_status: error querying responder\n");
		goto done;
	}
	rspderlen = i2d_OCSP_RESPONSE(resp, &rspder);
	if (rspderlen <= 0)
		goto err;
	SSL_set_tlsext_status_ocsp_resp(s, rspder, rspderlen);
	if (srctx->verbose) {
		BIO_puts(err, "cert_status: ocsp response sent:\n");
		OCSP_RESPONSE_print(err, resp, 2);
	}
	ret = SSL_TLSEXT_ERR_OK;
done:
	if (ret != SSL_TLSEXT_ERR_OK)
		ERR_print_errors(err);
	if (aia) {
		free(host);
		free(path);
		free(port);
		X509_email_free(aia);
	}
	if (id)
		OCSP_CERTID_free(id);
	if (req)
		OCSP_REQUEST_free(req);
	if (resp)
		OCSP_RESPONSE_free(resp);
	return ret;
err:
	ret = SSL_TLSEXT_ERR_ALERT_FATAL;
	goto done;
}

#ifndef OPENSSL_NO_NEXTPROTONEG
/* This is the context that we pass to next_proto_cb */
typedef struct tlsextnextprotoctx_st {
	unsigned char *data;
	unsigned int len;
} tlsextnextprotoctx;

static int
next_proto_cb(SSL * s, const unsigned char **data, unsigned int *len, void *arg)
{
	tlsextnextprotoctx *next_proto = arg;

	*data = next_proto->data;
	*len = next_proto->len;

	return SSL_TLSEXT_ERR_OK;
}
#endif				/* ndef OPENSSL_NO_NEXTPROTONEG */


#endif

int s_server_main(int, char **);

#ifndef OPENSSL_NO_SRTP
static char *srtp_profiles = NULL;
#endif

int
s_server_main(int argc, char *argv[])
{
	X509_VERIFY_PARAM *vpm = NULL;
	int badarg = 0;
	short port = PORT;
	char *CApath = NULL, *CAfile = NULL;
	unsigned char *context = NULL;
	char *dhfile = NULL;
	char *named_curve = NULL;
	int badop = 0, bugs = 0;
	int ret = 1;
	int off = 0;
	int no_tmp_rsa = 0, no_dhe = 0, no_ecdhe = 0, nocert = 0;
	int state = 0;
	const SSL_METHOD *meth = NULL;
	int socket_type = SOCK_STREAM;
	ENGINE *e = NULL;
	int s_cert_format = FORMAT_PEM, s_key_format = FORMAT_PEM;
	char *passarg = NULL, *pass = NULL;
	char *dpassarg = NULL, *dpass = NULL;
	int s_dcert_format = FORMAT_PEM, s_dkey_format = FORMAT_PEM;
	X509 *s_cert = NULL, *s_dcert = NULL;
	EVP_PKEY *s_key = NULL, *s_dkey = NULL;
	int no_cache = 0;
	const char *errstr = NULL;
#ifndef OPENSSL_NO_TLSEXT
	EVP_PKEY *s_key2 = NULL;
	X509 *s_cert2 = NULL;
	tlsextctx tlsextcbp = {NULL, NULL, SSL_TLSEXT_ERR_ALERT_WARNING};
#ifndef OPENSSL_NO_NEXTPROTONEG
	const char *next_proto_neg_in = NULL;
	tlsextnextprotoctx next_proto;
#endif
#endif
	meth = SSLv23_server_method();

	local_argc = argc;
	local_argv = argv;

	s_server_init();

	verify_depth = 0;
	s_nbio = 0;
	s_nbio_test = 0;

	argc--;
	argv++;

	while (argc >= 1) {
		if ((strcmp(*argv, "-port") == 0) ||
		    (strcmp(*argv, "-accept") == 0)) {
			if (--argc < 1)
				goto bad;
			if (!extract_port(*(++argv), &port))
				goto bad;
		} else if (strcmp(*argv, "-verify") == 0) {
			s_server_verify = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;
			if (--argc < 1)
				goto bad;
			verify_depth = strtonum(*(++argv), 0, INT_MAX, &errstr);
			if (errstr)
				goto bad;
			BIO_printf(bio_err, "verify depth is %d\n", verify_depth);
		} else if (strcmp(*argv, "-Verify") == 0) {
			s_server_verify = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT |
			    SSL_VERIFY_CLIENT_ONCE;
			if (--argc < 1)
				goto bad;
			verify_depth = strtonum(*(++argv), 0, INT_MAX, &errstr);
			if (errstr)
				goto bad;
			BIO_printf(bio_err, "verify depth is %d, must return a certificate\n", verify_depth);
		} else if (strcmp(*argv, "-context") == 0) {
			if (--argc < 1)
				goto bad;
			context = (unsigned char *) *(++argv);
		} else if (strcmp(*argv, "-cert") == 0) {
			if (--argc < 1)
				goto bad;
			s_cert_file = *(++argv);
		} else if (strcmp(*argv, "-certform") == 0) {
			if (--argc < 1)
				goto bad;
			s_cert_format = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-key") == 0) {
			if (--argc < 1)
				goto bad;
			s_key_file = *(++argv);
		} else if (strcmp(*argv, "-keyform") == 0) {
			if (--argc < 1)
				goto bad;
			s_key_format = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-pass") == 0) {
			if (--argc < 1)
				goto bad;
			passarg = *(++argv);
		} else if (strcmp(*argv, "-dhparam") == 0) {
			if (--argc < 1)
				goto bad;
			dhfile = *(++argv);
		}
		else if (strcmp(*argv, "-named_curve") == 0) {
			if (--argc < 1)
				goto bad;
			named_curve = *(++argv);
		}
		else if (strcmp(*argv, "-dcertform") == 0) {
			if (--argc < 1)
				goto bad;
			s_dcert_format = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-dcert") == 0) {
			if (--argc < 1)
				goto bad;
			s_dcert_file = *(++argv);
		} else if (strcmp(*argv, "-dkeyform") == 0) {
			if (--argc < 1)
				goto bad;
			s_dkey_format = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-dpass") == 0) {
			if (--argc < 1)
				goto bad;
			dpassarg = *(++argv);
		} else if (strcmp(*argv, "-dkey") == 0) {
			if (--argc < 1)
				goto bad;
			s_dkey_file = *(++argv);
		} else if (strcmp(*argv, "-nocert") == 0) {
			nocert = 1;
		} else if (strcmp(*argv, "-CApath") == 0) {
			if (--argc < 1)
				goto bad;
			CApath = *(++argv);
		} else if (strcmp(*argv, "-no_cache") == 0)
			no_cache = 1;
		else if (args_verify(&argv, &argc, &badarg, bio_err, &vpm)) {
			if (badarg)
				goto bad;
			continue;
		} else if (strcmp(*argv, "-verify_return_error") == 0)
			verify_return_error = 1;
		else if (strcmp(*argv, "-serverpref") == 0) {
			off |= SSL_OP_CIPHER_SERVER_PREFERENCE;
		} else if (strcmp(*argv, "-legacy_renegotiation") == 0)
			; /* no-op */
		else if (strcmp(*argv, "-cipher") == 0) {
			if (--argc < 1)
				goto bad;
			cipher = *(++argv);
		} else if (strcmp(*argv, "-CAfile") == 0) {
			if (--argc < 1)
				goto bad;
			CAfile = *(++argv);
		}
		else if (strcmp(*argv, "-nbio") == 0) {
			s_nbio = 1;
		}
		else if (strcmp(*argv, "-nbio_test") == 0) {
			s_nbio = 1;
			s_nbio_test = 1;
		} else if (strcmp(*argv, "-debug") == 0) {
			s_debug = 1;
		}
#ifndef OPENSSL_NO_TLSEXT
		else if (strcmp(*argv, "-tlsextdebug") == 0)
			s_tlsextdebug = 1;
		else if (strcmp(*argv, "-status") == 0)
			s_tlsextstatus = 1;
		else if (strcmp(*argv, "-status_verbose") == 0) {
			s_tlsextstatus = 1;
			tlscstatp.verbose = 1;
		} else if (!strcmp(*argv, "-status_timeout")) {
			s_tlsextstatus = 1;
			if (--argc < 1)
				goto bad;
			tlscstatp.timeout = strtonum(*(++argv), 0, INT_MAX, &errstr);
			if (errstr)
				goto bad;
		} else if (!strcmp(*argv, "-status_url")) {
			s_tlsextstatus = 1;
			if (--argc < 1)
				goto bad;
			if (!OCSP_parse_url(*(++argv),
				&tlscstatp.host,
				&tlscstatp.port,
				&tlscstatp.path,
				&tlscstatp.use_ssl)) {
				BIO_printf(bio_err, "Error parsing URL\n");
				goto bad;
			}
		}
#endif
		else if (strcmp(*argv, "-msg") == 0) {
			s_msg = 1;
		} else if (strcmp(*argv, "-hack") == 0) {
			hack = 1;
		} else if (strcmp(*argv, "-state") == 0) {
			state = 1;
		} else if (strcmp(*argv, "-crlf") == 0) {
			s_crlf = 1;
		} else if (strcmp(*argv, "-quiet") == 0) {
			s_quiet = 1;
		} else if (strcmp(*argv, "-bugs") == 0) {
			bugs = 1;
		} else if (strcmp(*argv, "-no_tmp_rsa") == 0) {
			no_tmp_rsa = 1;
		} else if (strcmp(*argv, "-no_dhe") == 0) {
			no_dhe = 1;
		} else if (strcmp(*argv, "-no_ecdhe") == 0) {
			no_ecdhe = 1;
		}
		else if (strcmp(*argv, "-www") == 0) {
			www = 1;
		} else if (strcmp(*argv, "-WWW") == 0) {
			www = 2;
		} else if (strcmp(*argv, "-HTTP") == 0) {
			www = 3;
		} else if (strcmp(*argv, "-no_ssl2") == 0) {
			off |= SSL_OP_NO_SSLv2;
		} else if (strcmp(*argv, "-no_ssl3") == 0) {
			off |= SSL_OP_NO_SSLv3;
		} else if (strcmp(*argv, "-no_tls1") == 0) {
			off |= SSL_OP_NO_TLSv1;
		} else if (strcmp(*argv, "-no_tls1_1") == 0) {
			off |= SSL_OP_NO_TLSv1_1;
		} else if (strcmp(*argv, "-no_tls1_2") == 0) {
			off |= SSL_OP_NO_TLSv1_2;
		} else if (strcmp(*argv, "-no_comp") == 0) {
			off |= SSL_OP_NO_COMPRESSION;
		}
#ifndef OPENSSL_NO_TLSEXT
		else if (strcmp(*argv, "-no_ticket") == 0) {
			off |= SSL_OP_NO_TICKET;
		}
#endif
		else if (strcmp(*argv, "-ssl3") == 0) {
			meth = SSLv3_server_method();
		} else if (strcmp(*argv, "-tls1") == 0) {
			meth = TLSv1_server_method();
		} else if (strcmp(*argv, "-tls1_1") == 0) {
			meth = TLSv1_1_server_method();
		} else if (strcmp(*argv, "-tls1_2") == 0) {
			meth = TLSv1_2_server_method();
		}
#ifndef OPENSSL_NO_DTLS1
		else if (strcmp(*argv, "-dtls1") == 0) {
			meth = DTLSv1_server_method();
			socket_type = SOCK_DGRAM;
		} else if (strcmp(*argv, "-timeout") == 0)
			enable_timeouts = 1;
		else if (strcmp(*argv, "-mtu") == 0) {
			if (--argc < 1)
				goto bad;
			socket_mtu = strtonum(*(++argv), 0, LONG_MAX, &errstr);
			if (errstr)
				goto bad;
		} else if (strcmp(*argv, "-chain") == 0)
			cert_chain = 1;
#endif
		else if (strcmp(*argv, "-id_prefix") == 0) {
			if (--argc < 1)
				goto bad;
			session_id_prefix = *(++argv);
		}
#ifndef OPENSSL_NO_ENGINE
		else if (strcmp(*argv, "-engine") == 0) {
			if (--argc < 1)
				goto bad;
			engine_id = *(++argv);
		}
#endif
#ifndef OPENSSL_NO_TLSEXT
		else if (strcmp(*argv, "-servername") == 0) {
			if (--argc < 1)
				goto bad;
			tlsextcbp.servername = *(++argv);
		} else if (strcmp(*argv, "-servername_fatal") == 0) {
			tlsextcbp.extension_error = SSL_TLSEXT_ERR_ALERT_FATAL;
		} else if (strcmp(*argv, "-cert2") == 0) {
			if (--argc < 1)
				goto bad;
			s_cert_file2 = *(++argv);
		} else if (strcmp(*argv, "-key2") == 0) {
			if (--argc < 1)
				goto bad;
			s_key_file2 = *(++argv);
		}
#ifndef OPENSSL_NO_NEXTPROTONEG
		else if (strcmp(*argv, "-nextprotoneg") == 0) {
			if (--argc < 1)
				goto bad;
			next_proto_neg_in = *(++argv);
		}
#endif
#endif
#ifndef OPENSSL_NO_SRTP
		else if (strcmp(*argv, "-use_srtp") == 0) {
			if (--argc < 1)
				goto bad;
			srtp_profiles = *(++argv);
		}
#endif
		else if (strcmp(*argv, "-keymatexport") == 0) {
			if (--argc < 1)
				goto bad;
			keymatexportlabel = *(++argv);
		} else if (strcmp(*argv, "-keymatexportlen") == 0) {
			if (--argc < 1)
				goto bad;
			keymatexportlen = strtonum(*(++argv), 1, INT_MAX, &errstr);
			if (errstr)
				goto bad;
		} else {
			BIO_printf(bio_err, "unknown option %s\n", *argv);
			badop = 1;
			break;
		}
		argc--;
		argv++;
	}
	if (badop) {
bad:
		if (errstr)
			BIO_printf(bio_err, "invalid argument %s: %s\n",
			    *argv, errstr);
		else
			sv_usage();
		goto end;
	}

#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine_id, 1);
#endif

	if (!app_passwd(bio_err, passarg, dpassarg, &pass, &dpass)) {
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
	}
	if (s_key_file == NULL)
		s_key_file = s_cert_file;
#ifndef OPENSSL_NO_TLSEXT
	if (s_key_file2 == NULL)
		s_key_file2 = s_cert_file2;
#endif

	if (nocert == 0) {
		s_key = load_key(bio_err, s_key_file, s_key_format, 0, pass, e,
		    "server certificate private key file");
		if (!s_key) {
			ERR_print_errors(bio_err);
			goto end;
		}
		s_cert = load_cert(bio_err, s_cert_file, s_cert_format,
		    NULL, e, "server certificate file");

		if (!s_cert) {
			ERR_print_errors(bio_err);
			goto end;
		}
#ifndef OPENSSL_NO_TLSEXT
		if (tlsextcbp.servername) {
			s_key2 = load_key(bio_err, s_key_file2, s_key_format, 0, pass, e,
			    "second server certificate private key file");
			if (!s_key2) {
				ERR_print_errors(bio_err);
				goto end;
			}
			s_cert2 = load_cert(bio_err, s_cert_file2, s_cert_format,
			    NULL, e, "second server certificate file");

			if (!s_cert2) {
				ERR_print_errors(bio_err);
				goto end;
			}
		}
#endif
	}
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	if (next_proto_neg_in) {
		unsigned short len;
		next_proto.data = next_protos_parse(&len, next_proto_neg_in);
		if (next_proto.data == NULL)
			goto end;
		next_proto.len = len;
	} else {
		next_proto.data = NULL;
	}
#endif


	if (s_dcert_file) {

		if (s_dkey_file == NULL)
			s_dkey_file = s_dcert_file;

		s_dkey = load_key(bio_err, s_dkey_file, s_dkey_format,
		    0, dpass, e,
		    "second certificate private key file");
		if (!s_dkey) {
			ERR_print_errors(bio_err);
			goto end;
		}
		s_dcert = load_cert(bio_err, s_dcert_file, s_dcert_format,
		    NULL, e, "second server certificate file");

		if (!s_dcert) {
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (bio_s_out == NULL) {
		if (s_quiet && !s_debug && !s_msg) {
			bio_s_out = BIO_new(BIO_s_null());
		} else {
			if (bio_s_out == NULL)
				bio_s_out = BIO_new_fp(stdout, BIO_NOCLOSE);
		}
	}
	if (nocert)
	{
		s_cert_file = NULL;
		s_key_file = NULL;
		s_dcert_file = NULL;
		s_dkey_file = NULL;
#ifndef OPENSSL_NO_TLSEXT
		s_cert_file2 = NULL;
		s_key_file2 = NULL;
#endif
	}
	ctx = SSL_CTX_new(meth);
	if (ctx == NULL) {
		ERR_print_errors(bio_err);
		goto end;
	}
	if (session_id_prefix) {
		if (strlen(session_id_prefix) >= 32)
			BIO_printf(bio_err,
			    "warning: id_prefix is too long, only one new session will be possible\n");
		else if (strlen(session_id_prefix) >= 16)
			BIO_printf(bio_err,
			    "warning: id_prefix is too long if you use SSLv2\n");
		if (!SSL_CTX_set_generate_session_id(ctx, generate_session_id)) {
			BIO_printf(bio_err, "error setting 'id_prefix'\n");
			ERR_print_errors(bio_err);
			goto end;
		}
		BIO_printf(bio_err, "id_prefix '%s' set.\n", session_id_prefix);
	}
	SSL_CTX_set_quiet_shutdown(ctx, 1);
	if (bugs)
		SSL_CTX_set_options(ctx, SSL_OP_ALL);
	if (hack)
		SSL_CTX_set_options(ctx, SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);
	SSL_CTX_set_options(ctx, off);
	/*
	 * DTLS: partial reads end up discarding unread UDP bytes :-( Setting
	 * read ahead solves this problem.
	 */
	if (socket_type == SOCK_DGRAM)
		SSL_CTX_set_read_ahead(ctx, 1);

	if (state)
		SSL_CTX_set_info_callback(ctx, apps_ssl_info_callback);
	if (no_cache)
		SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);
	else
		SSL_CTX_sess_set_cache_size(ctx, 128);

#ifndef OPENSSL_NO_SRTP
	if (srtp_profiles != NULL)
		SSL_CTX_set_tlsext_use_srtp(ctx, srtp_profiles);
#endif


	if ((!SSL_CTX_load_verify_locations(ctx, CAfile, CApath)) ||
	    (!SSL_CTX_set_default_verify_paths(ctx))) {
		/* BIO_printf(bio_err,"X509_load_verify_locations\n"); */
		ERR_print_errors(bio_err);
		/* goto end; */
	}
	if (vpm)
		SSL_CTX_set1_param(ctx, vpm);

#ifndef OPENSSL_NO_TLSEXT
	if (s_cert2) {
		ctx2 = SSL_CTX_new(meth);
		if (ctx2 == NULL) {
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (ctx2) {
		BIO_printf(bio_s_out, "Setting secondary ctx parameters\n");

		if (session_id_prefix) {
			if (strlen(session_id_prefix) >= 32)
				BIO_printf(bio_err,
				    "warning: id_prefix is too long, only one new session will be possible\n");
			else if (strlen(session_id_prefix) >= 16)
				BIO_printf(bio_err,
				    "warning: id_prefix is too long if you use SSLv2\n");
			if (!SSL_CTX_set_generate_session_id(ctx2, generate_session_id)) {
				BIO_printf(bio_err, "error setting 'id_prefix'\n");
				ERR_print_errors(bio_err);
				goto end;
			}
			BIO_printf(bio_err, "id_prefix '%s' set.\n", session_id_prefix);
		}
		SSL_CTX_set_quiet_shutdown(ctx2, 1);
		if (bugs)
			SSL_CTX_set_options(ctx2, SSL_OP_ALL);
		if (hack)
			SSL_CTX_set_options(ctx2, SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);
		SSL_CTX_set_options(ctx2, off);
		/*
		 * DTLS: partial reads end up discarding unread UDP bytes :-(
		 * Setting read ahead solves this problem.
		 */
		if (socket_type == SOCK_DGRAM)
			SSL_CTX_set_read_ahead(ctx2, 1);

		if (state)
			SSL_CTX_set_info_callback(ctx2, apps_ssl_info_callback);

		if (no_cache)
			SSL_CTX_set_session_cache_mode(ctx2, SSL_SESS_CACHE_OFF);
		else
			SSL_CTX_sess_set_cache_size(ctx2, 128);

		if ((!SSL_CTX_load_verify_locations(ctx2, CAfile, CApath)) ||
		    (!SSL_CTX_set_default_verify_paths(ctx2))) {
			ERR_print_errors(bio_err);
		}
		if (vpm)
			SSL_CTX_set1_param(ctx2, vpm);
	}
#ifndef OPENSSL_NO_NEXTPROTONEG
	if (next_proto.data)
		SSL_CTX_set_next_protos_advertised_cb(ctx, next_proto_cb, &next_proto);
#endif
#endif

#ifndef OPENSSL_NO_DH
	if (!no_dhe) {
		DH *dh = NULL;

		if (dhfile)
			dh = load_dh_param(dhfile);
		else if (s_cert_file)
			dh = load_dh_param(s_cert_file);

		if (dh != NULL) {
			BIO_printf(bio_s_out, "Setting temp DH parameters\n");
		} else {
			BIO_printf(bio_s_out, "Using default temp DH parameters\n");
			dh = get_dh512();
		}
		(void) BIO_flush(bio_s_out);

		SSL_CTX_set_tmp_dh(ctx, dh);
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2) {
			if (!dhfile) {
				DH *dh2 = load_dh_param(s_cert_file2);
				if (dh2 != NULL) {
					BIO_printf(bio_s_out, "Setting temp DH parameters\n");
					(void) BIO_flush(bio_s_out);

					DH_free(dh);
					dh = dh2;
				}
			}
			SSL_CTX_set_tmp_dh(ctx2, dh);
		}
#endif
		DH_free(dh);
	}
#endif

	if (!no_ecdhe) {
		EC_KEY *ecdh = NULL;

		if (named_curve) {
			int nid = OBJ_sn2nid(named_curve);

			if (nid == 0) {
				BIO_printf(bio_err, "unknown curve name (%s)\n",
				    named_curve);
				goto end;
			}
			ecdh = EC_KEY_new_by_curve_name(nid);
			if (ecdh == NULL) {
				BIO_printf(bio_err, "unable to create curve (%s)\n",
				    named_curve);
				goto end;
			}
		}
		if (ecdh != NULL) {
			BIO_printf(bio_s_out, "Setting temp ECDH parameters\n");
		} else {
			BIO_printf(bio_s_out, "Using default temp ECDH parameters\n");
			ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
			if (ecdh == NULL) {
				BIO_printf(bio_err, "unable to create curve (nistp256)\n");
				goto end;
			}
		}
		(void) BIO_flush(bio_s_out);

		SSL_CTX_set_tmp_ecdh(ctx, ecdh);
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2)
			SSL_CTX_set_tmp_ecdh(ctx2, ecdh);
#endif
		EC_KEY_free(ecdh);
	}

	if (!set_cert_key_stuff(ctx, s_cert, s_key))
		goto end;
#ifndef OPENSSL_NO_TLSEXT
	if (ctx2 && !set_cert_key_stuff(ctx2, s_cert2, s_key2))
		goto end;
#endif
	if (s_dcert != NULL) {
		if (!set_cert_key_stuff(ctx, s_dcert, s_dkey))
			goto end;
	}
	if (!no_tmp_rsa) {
		SSL_CTX_set_tmp_rsa_callback(ctx, tmp_rsa_cb);
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2)
			SSL_CTX_set_tmp_rsa_callback(ctx2, tmp_rsa_cb);
#endif
	}


	if (cipher != NULL) {
		if (!SSL_CTX_set_cipher_list(ctx, cipher)) {
			BIO_printf(bio_err, "error setting cipher list\n");
			ERR_print_errors(bio_err);
			goto end;
		}
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2 && !SSL_CTX_set_cipher_list(ctx2, cipher)) {
			BIO_printf(bio_err, "error setting cipher list\n");
			ERR_print_errors(bio_err);
			goto end;
		}
#endif
	}
	SSL_CTX_set_verify(ctx, s_server_verify, verify_callback);
	SSL_CTX_set_session_id_context(ctx, (void *) &s_server_session_id_context,
	    sizeof s_server_session_id_context);

	/* Set DTLS cookie generation and verification callbacks */
	SSL_CTX_set_cookie_generate_cb(ctx, generate_cookie_callback);
	SSL_CTX_set_cookie_verify_cb(ctx, verify_cookie_callback);

#ifndef OPENSSL_NO_TLSEXT
	if (ctx2) {
		SSL_CTX_set_verify(ctx2, s_server_verify, verify_callback);
		SSL_CTX_set_session_id_context(ctx2, (void *) &s_server_session_id_context,
		    sizeof s_server_session_id_context);

		tlsextcbp.biodebug = bio_s_out;
		SSL_CTX_set_tlsext_servername_callback(ctx2, ssl_servername_cb);
		SSL_CTX_set_tlsext_servername_arg(ctx2, &tlsextcbp);
		SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);
		SSL_CTX_set_tlsext_servername_arg(ctx, &tlsextcbp);
	}
#endif

	if (CAfile != NULL) {
		SSL_CTX_set_client_CA_list(ctx, SSL_load_client_CA_file(CAfile));
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2)
			SSL_CTX_set_client_CA_list(ctx2, SSL_load_client_CA_file(CAfile));
#endif
	}
	BIO_printf(bio_s_out, "ACCEPT\n");
	(void) BIO_flush(bio_s_out);
	if (www)
		do_server(port, socket_type, &accept_socket, www_body, context);
	else
		do_server(port, socket_type, &accept_socket, sv_body, context);
	print_stats(bio_s_out, ctx);
	ret = 0;
end:
	if (ctx != NULL)
		SSL_CTX_free(ctx);
	if (s_cert)
		X509_free(s_cert);
	if (s_dcert)
		X509_free(s_dcert);
	if (s_key)
		EVP_PKEY_free(s_key);
	if (s_dkey)
		EVP_PKEY_free(s_dkey);
	free(pass);
	free(dpass);
	if (vpm)
		X509_VERIFY_PARAM_free(vpm);
#ifndef OPENSSL_NO_TLSEXT
	free(tlscstatp.host);
	free(tlscstatp.port);
	free(tlscstatp.path);
	if (ctx2 != NULL)
		SSL_CTX_free(ctx2);
	if (s_cert2)
		X509_free(s_cert2);
	if (s_key2)
		EVP_PKEY_free(s_key2);
#endif
	if (bio_s_out != NULL) {
		BIO_free(bio_s_out);
		bio_s_out = NULL;
	}

	return (ret);
}

static void
print_stats(BIO * bio, SSL_CTX * ssl_ctx)
{
	BIO_printf(bio, "%4ld items in the session cache\n",
	    SSL_CTX_sess_number(ssl_ctx));
	BIO_printf(bio, "%4ld client connects (SSL_connect())\n",
	    SSL_CTX_sess_connect(ssl_ctx));
	BIO_printf(bio, "%4ld client renegotiates (SSL_connect())\n",
	    SSL_CTX_sess_connect_renegotiate(ssl_ctx));
	BIO_printf(bio, "%4ld client connects that finished\n",
	    SSL_CTX_sess_connect_good(ssl_ctx));
	BIO_printf(bio, "%4ld server accepts (SSL_accept())\n",
	    SSL_CTX_sess_accept(ssl_ctx));
	BIO_printf(bio, "%4ld server renegotiates (SSL_accept())\n",
	    SSL_CTX_sess_accept_renegotiate(ssl_ctx));
	BIO_printf(bio, "%4ld server accepts that finished\n",
	    SSL_CTX_sess_accept_good(ssl_ctx));
	BIO_printf(bio, "%4ld session cache hits\n", SSL_CTX_sess_hits(ssl_ctx));
	BIO_printf(bio, "%4ld session cache misses\n", SSL_CTX_sess_misses(ssl_ctx));
	BIO_printf(bio, "%4ld session cache timeouts\n", SSL_CTX_sess_timeouts(ssl_ctx));
	BIO_printf(bio, "%4ld callback cache hits\n", SSL_CTX_sess_cb_hits(ssl_ctx));
	BIO_printf(bio, "%4ld cache full overflows (%ld allowed)\n",
	    SSL_CTX_sess_cache_full(ssl_ctx),
	    SSL_CTX_sess_get_cache_size(ssl_ctx));
}

static int
sv_body(char *hostname, int s, unsigned char *context)
{
	char *buf = NULL;
	fd_set readfds;
	int ret = 1, width;
	int k, i;
	unsigned long l;
	SSL *con = NULL;
	BIO *sbio;
	struct timeval timeout;
	struct timeval *timeoutp;

	if ((buf = malloc(bufsize)) == NULL) {
		BIO_printf(bio_err, "out of memory\n");
		goto err;
	}
	if (s_nbio) {
		unsigned long sl = 1;

		if (!s_quiet)
			BIO_printf(bio_err, "turning on non blocking io\n");
		if (BIO_socket_ioctl(s, FIONBIO, &sl) < 0)
			ERR_print_errors(bio_err);
	}

	if (con == NULL) {
		con = SSL_new(ctx);
#ifndef OPENSSL_NO_TLSEXT
		if (s_tlsextdebug) {
			SSL_set_tlsext_debug_callback(con, tlsext_cb);
			SSL_set_tlsext_debug_arg(con, bio_s_out);
		}
		if (s_tlsextstatus) {
			SSL_CTX_set_tlsext_status_cb(ctx, cert_status_cb);
			tlscstatp.err = bio_err;
			SSL_CTX_set_tlsext_status_arg(ctx, &tlscstatp);
		}
#endif
		if (context)
			SSL_set_session_id_context(con, context,
			    strlen((char *) context));
	}
	SSL_clear(con);

	if (SSL_version(con) == DTLS1_VERSION) {

		sbio = BIO_new_dgram(s, BIO_NOCLOSE);

		if (enable_timeouts) {
			timeout.tv_sec = 0;
			timeout.tv_usec = DGRAM_RCV_TIMEOUT;
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);

			timeout.tv_sec = 0;
			timeout.tv_usec = DGRAM_SND_TIMEOUT;
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);
		}
		if (socket_mtu > 28) {
			SSL_set_options(con, SSL_OP_NO_QUERY_MTU);
			SSL_set_mtu(con, socket_mtu - 28);
		} else
			/* want to do MTU discovery */
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);

		/* turn on cookie exchange */
		SSL_set_options(con, SSL_OP_COOKIE_EXCHANGE);
	} else
		sbio = BIO_new_socket(s, BIO_NOCLOSE);

	if (s_nbio_test) {
		BIO *test;

		test = BIO_new(BIO_f_nbio_test());
		sbio = BIO_push(test, sbio);
	}

	SSL_set_bio(con, sbio, sbio);
	SSL_set_accept_state(con);
	/* SSL_set_fd(con,s); */

	if (s_debug) {
		SSL_set_debug(con, 1);
		BIO_set_callback(SSL_get_rbio(con), bio_dump_callback);
		BIO_set_callback_arg(SSL_get_rbio(con), (char *) bio_s_out);
	}
	if (s_msg) {
		SSL_set_msg_callback(con, msg_cb);
		SSL_set_msg_callback_arg(con, bio_s_out);
	}
#ifndef OPENSSL_NO_TLSEXT
	if (s_tlsextdebug) {
		SSL_set_tlsext_debug_callback(con, tlsext_cb);
		SSL_set_tlsext_debug_arg(con, bio_s_out);
	}
#endif

	width = s + 1;
	for (;;) {
		int read_from_terminal;
		int read_from_sslcon;

		read_from_terminal = 0;
		read_from_sslcon = SSL_pending(con);

		if (!read_from_sslcon) {
			FD_ZERO(&readfds);
			FD_SET(fileno(stdin), &readfds);
			FD_SET(s, &readfds);
			if ((SSL_version(con) == DTLS1_VERSION) &&
			    DTLSv1_get_timeout(con, &timeout))
				timeoutp = &timeout;
			else
				timeoutp = NULL;

			i = select(width, &readfds, NULL, NULL, timeoutp);

			if ((SSL_version(con) == DTLS1_VERSION) && DTLSv1_handle_timeout(con) > 0) {
				BIO_printf(bio_err, "TIMEOUT occured\n");
			}
			if (i <= 0)
				continue;
			if (FD_ISSET(fileno(stdin), &readfds))
				read_from_terminal = 1;
			if (FD_ISSET(s, &readfds))
				read_from_sslcon = 1;
		}
		if (read_from_terminal) {
			if (s_crlf) {
				int j, lf_num;

				i = read(fileno(stdin), buf, bufsize / 2);
				lf_num = 0;
				/* both loops are skipped when i <= 0 */
				for (j = 0; j < i; j++)
					if (buf[j] == '\n')
						lf_num++;
				for (j = i - 1; j >= 0; j--) {
					buf[j + lf_num] = buf[j];
					if (buf[j] == '\n') {
						lf_num--;
						i++;
						buf[j + lf_num] = '\r';
					}
				}
				assert(lf_num == 0);
			} else
				i = read(fileno(stdin), buf, bufsize);
			if (!s_quiet) {
				if ((i <= 0) || (buf[0] == 'Q')) {
					BIO_printf(bio_s_out, "DONE\n");
					shutdown(s, SHUT_RD);
					close(s);
					close_accept_socket();
					ret = -11;
					goto err;
				}
				if ((i <= 0) || (buf[0] == 'q')) {
					BIO_printf(bio_s_out, "DONE\n");
					if (SSL_version(con) != DTLS1_VERSION) {
						shutdown(s, SHUT_RD);
						close(s);
					}
					/*
					 * close_accept_socket(); ret= -11;
					 */
					goto err;
				}
				if ((buf[0] == 'r') &&
				    ((buf[1] == '\n') || (buf[1] == '\r'))) {
					SSL_renegotiate(con);
					i = SSL_do_handshake(con);
					printf("SSL_do_handshake -> %d\n", i);
					i = 0;	/* 13; */
					continue;
					/*
					 * strcpy(buf,"server side
					 * RE-NEGOTIATE\n");
					 */
				}
				if ((buf[0] == 'R') &&
				    ((buf[1] == '\n') || (buf[1] == '\r'))) {
					SSL_set_verify(con,
					    SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE, NULL);
					SSL_renegotiate(con);
					i = SSL_do_handshake(con);
					printf("SSL_do_handshake -> %d\n", i);
					i = 0;	/* 13; */
					continue;
					/*
					 * strcpy(buf,"server side
					 * RE-NEGOTIATE asking for client
					 * cert\n");
					 */
				}
				if (buf[0] == 'P') {
					static const char *str = "Lets print some clear text\n";
					BIO_write(SSL_get_wbio(con), str, strlen(str));
				}
				if (buf[0] == 'S') {
					print_stats(bio_s_out, SSL_get_SSL_CTX(con));
				}
			}
			l = k = 0;
			for (;;) {
				/* should do a select for the write */
#ifdef RENEG
				{
					static count = 0;
					if (++count == 100) {
						count = 0;
						SSL_renegotiate(con);
					}
				}
#endif
				k = SSL_write(con, &(buf[l]), (unsigned int) i);
				switch (SSL_get_error(con, k)) {
				case SSL_ERROR_NONE:
					break;
				case SSL_ERROR_WANT_WRITE:
				case SSL_ERROR_WANT_READ:
				case SSL_ERROR_WANT_X509_LOOKUP:
					BIO_printf(bio_s_out, "Write BLOCK\n");
					break;
				case SSL_ERROR_SYSCALL:
				case SSL_ERROR_SSL:
					BIO_printf(bio_s_out, "ERROR\n");
					ERR_print_errors(bio_err);
					ret = 1;
					goto err;
					/* break; */
				case SSL_ERROR_ZERO_RETURN:
					BIO_printf(bio_s_out, "DONE\n");
					ret = 1;
					goto err;
				}
				l += k;
				i -= k;
				if (i <= 0)
					break;
			}
		}
		if (read_from_sslcon) {
			if (!SSL_is_init_finished(con)) {
				i = init_ssl_connection(con);

				if (i < 0) {
					ret = 0;
					goto err;
				} else if (i == 0) {
					ret = 1;
					goto err;
				}
			} else {
		again:
				i = SSL_read(con, (char *) buf, bufsize);
				switch (SSL_get_error(con, i)) {
				case SSL_ERROR_NONE: {
						int len, n;
						for (len = 0; len < i;) {
							do {
								n = write(fileno(stdout), buf + len, i - len);
							} while (n == -1 && errno == EINTR);

							if (n < 0) {
								BIO_printf(bio_s_out, "ERROR\n");
								goto err;
							}
							len += n;
						}
					}
					if (SSL_pending(con))
						goto again;
					break;
				case SSL_ERROR_WANT_WRITE:
				case SSL_ERROR_WANT_READ:
					BIO_printf(bio_s_out, "Read BLOCK\n");
					break;
				case SSL_ERROR_SYSCALL:
				case SSL_ERROR_SSL:
					BIO_printf(bio_s_out, "ERROR\n");
					ERR_print_errors(bio_err);
					ret = 1;
					goto err;
				case SSL_ERROR_ZERO_RETURN:
					BIO_printf(bio_s_out, "DONE\n");
					ret = 1;
					goto err;
				}
			}
		}
	}
err:
	if (con != NULL) {
		BIO_printf(bio_s_out, "shutting down SSL\n");
		SSL_set_shutdown(con, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
		SSL_free(con);
	}
	BIO_printf(bio_s_out, "CONNECTION CLOSED\n");
	if (buf != NULL) {
		OPENSSL_cleanse(buf, bufsize);
		free(buf);
	}
	if (ret >= 0)
		BIO_printf(bio_s_out, "ACCEPT\n");
	return (ret);
}

static void
close_accept_socket(void)
{
	BIO_printf(bio_err, "shutdown accept socket\n");
	if (accept_socket >= 0) {
		shutdown(accept_socket, SHUT_RDWR);
		close(accept_socket);
	}
}

static int
init_ssl_connection(SSL * con)
{
	int i;
	const char *str;
	X509 *peer;
	long verify_error;
	char buf[BUFSIZ];
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	const unsigned char *next_proto_neg;
	unsigned next_proto_neg_len;
#endif
	unsigned char *exportedkeymat;


	i = SSL_accept(con);
	if (i <= 0) {
		if (BIO_sock_should_retry(i)) {
			BIO_printf(bio_s_out, "DELAY\n");
			return (1);
		}
		BIO_printf(bio_err, "ERROR\n");
		verify_error = SSL_get_verify_result(con);
		if (verify_error != X509_V_OK) {
			BIO_printf(bio_err, "verify error:%s\n",
			    X509_verify_cert_error_string(verify_error));
		} else
			ERR_print_errors(bio_err);
		return (0);
	}
	PEM_write_bio_SSL_SESSION(bio_s_out, SSL_get_session(con));

	peer = SSL_get_peer_certificate(con);
	if (peer != NULL) {
		BIO_printf(bio_s_out, "Client certificate\n");
		PEM_write_bio_X509(bio_s_out, peer);
		X509_NAME_oneline(X509_get_subject_name(peer), buf, sizeof buf);
		BIO_printf(bio_s_out, "subject=%s\n", buf);
		X509_NAME_oneline(X509_get_issuer_name(peer), buf, sizeof buf);
		BIO_printf(bio_s_out, "issuer=%s\n", buf);
		X509_free(peer);
	}
	if (SSL_get_shared_ciphers(con, buf, sizeof buf) != NULL)
		BIO_printf(bio_s_out, "Shared ciphers:%s\n", buf);
	str = SSL_CIPHER_get_name(SSL_get_current_cipher(con));
	BIO_printf(bio_s_out, "CIPHER is %s\n", (str != NULL) ? str : "(NONE)");

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	SSL_get0_next_proto_negotiated(con, &next_proto_neg, &next_proto_neg_len);
	if (next_proto_neg) {
		BIO_printf(bio_s_out, "NEXTPROTO is ");
		BIO_write(bio_s_out, next_proto_neg, next_proto_neg_len);
		BIO_printf(bio_s_out, "\n");
	}
#endif
#ifndef OPENSSL_NO_SRTP
	{
		SRTP_PROTECTION_PROFILE *srtp_profile
		= SSL_get_selected_srtp_profile(con);

		if (srtp_profile)
			BIO_printf(bio_s_out, "SRTP Extension negotiated, profile=%s\n",
			    srtp_profile->name);
	}
#endif
	if (SSL_cache_hit(con))
		BIO_printf(bio_s_out, "Reused session-id\n");
	if (SSL_ctrl(con, SSL_CTRL_GET_FLAGS, 0, NULL) &
	    TLS1_FLAGS_TLS_PADDING_BUG)
		BIO_printf(bio_s_out,
		    "Peer has incorrect TLSv1 block padding\n");
	BIO_printf(bio_s_out, "Secure Renegotiation IS%s supported\n",
	    SSL_get_secure_renegotiation_support(con) ? "" : " NOT");
	if (keymatexportlabel != NULL) {
		BIO_printf(bio_s_out, "Keying material exporter:\n");
		BIO_printf(bio_s_out, "    Label: '%s'\n", keymatexportlabel);
		BIO_printf(bio_s_out, "    Length: %i bytes\n",
		    keymatexportlen);
		exportedkeymat = malloc(keymatexportlen);
		if (exportedkeymat != NULL) {
			if (!SSL_export_keying_material(con, exportedkeymat,
				keymatexportlen,
				keymatexportlabel,
				strlen(keymatexportlabel),
				NULL, 0, 0)) {
				BIO_printf(bio_s_out, "    Error\n");
			} else {
				BIO_printf(bio_s_out, "    Keying material: ");
				for (i = 0; i < keymatexportlen; i++)
					BIO_printf(bio_s_out, "%02X",
					    exportedkeymat[i]);
				BIO_printf(bio_s_out, "\n");
			}
			free(exportedkeymat);
		}
	}
	return (1);
}

#ifndef OPENSSL_NO_DH
static DH *
load_dh_param(const char *dhfile)
{
	DH *ret = NULL;
	BIO *bio;

	if ((bio = BIO_new_file(dhfile, "r")) == NULL)
		goto err;
	ret = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
err:
	BIO_free(bio);
	return (ret);
}
#endif

static int
www_body(char *hostname, int s, unsigned char *context)
{
	char *buf = NULL;
	int ret = 1;
	int i, j, k, dot;
	SSL *con;
	const SSL_CIPHER *c;
	BIO *io, *ssl_bio, *sbio;

	buf = malloc(bufsize);
	if (buf == NULL)
		return (0);
	io = BIO_new(BIO_f_buffer());
	ssl_bio = BIO_new(BIO_f_ssl());
	if ((io == NULL) || (ssl_bio == NULL))
		goto err;

	if (s_nbio) {
		unsigned long sl = 1;

		if (!s_quiet)
			BIO_printf(bio_err, "turning on non blocking io\n");
		if (BIO_socket_ioctl(s, FIONBIO, &sl) < 0)
			ERR_print_errors(bio_err);
	}

	/* lets make the output buffer a reasonable size */
	if (!BIO_set_write_buffer_size(io, bufsize))
		goto err;

	if ((con = SSL_new(ctx)) == NULL)
		goto err;
#ifndef OPENSSL_NO_TLSEXT
	if (s_tlsextdebug) {
		SSL_set_tlsext_debug_callback(con, tlsext_cb);
		SSL_set_tlsext_debug_arg(con, bio_s_out);
	}
#endif
	if (context)
		SSL_set_session_id_context(con, context,
		    strlen((char *) context));

	sbio = BIO_new_socket(s, BIO_NOCLOSE);
	if (s_nbio_test) {
		BIO *test;

		test = BIO_new(BIO_f_nbio_test());
		sbio = BIO_push(test, sbio);
	}
	SSL_set_bio(con, sbio, sbio);
	SSL_set_accept_state(con);

	/* SSL_set_fd(con,s); */
	BIO_set_ssl(ssl_bio, con, BIO_CLOSE);
	BIO_push(io, ssl_bio);

	if (s_debug) {
		SSL_set_debug(con, 1);
		BIO_set_callback(SSL_get_rbio(con), bio_dump_callback);
		BIO_set_callback_arg(SSL_get_rbio(con), (char *) bio_s_out);
	}
	if (s_msg) {
		SSL_set_msg_callback(con, msg_cb);
		SSL_set_msg_callback_arg(con, bio_s_out);
	}
	for (;;) {
		if (hack) {
			i = SSL_accept(con);
			switch (SSL_get_error(con, i)) {
			case SSL_ERROR_NONE:
				break;
			case SSL_ERROR_WANT_WRITE:
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_X509_LOOKUP:
				continue;
			case SSL_ERROR_SYSCALL:
			case SSL_ERROR_SSL:
			case SSL_ERROR_ZERO_RETURN:
				ret = 1;
				goto err;
				/* break; */
			}

			SSL_renegotiate(con);
			SSL_write(con, NULL, 0);
		}
		i = BIO_gets(io, buf, bufsize - 1);
		if (i < 0) {	/* error */
			if (!BIO_should_retry(io)) {
				if (!s_quiet)
					ERR_print_errors(bio_err);
				goto err;
			} else {
				BIO_printf(bio_s_out, "read R BLOCK\n");
				sleep(1);
				continue;
			}
		} else if (i == 0) {	/* end of input */
			ret = 1;
			goto end;
		}
		/* else we have data */
		if (((www == 1) && (strncmp("GET ", buf, 4) == 0)) ||
		    ((www == 2) && (strncmp("GET /stats ", buf, 11) == 0))) {
			char *p;
			X509 *peer;
			STACK_OF(SSL_CIPHER) * sk;
			static const char *space = "                          ";

			BIO_puts(io, "HTTP/1.0 200 ok\r\nContent-type: text/html\r\n\r\n");
			BIO_puts(io, "<HTML><BODY BGCOLOR=\"#ffffff\">\n");
			BIO_puts(io, "<pre>\n");
/*			BIO_puts(io,SSLeay_version(SSLEAY_VERSION));*/
			BIO_puts(io, "\n");
			for (i = 0; i < local_argc; i++) {
				BIO_puts(io, local_argv[i]);
				BIO_write(io, " ", 1);
			}
			BIO_puts(io, "\n");

			BIO_printf(io,
			    "Secure Renegotiation IS%s supported\n",
			    SSL_get_secure_renegotiation_support(con) ?
			    "" : " NOT");

			/*
			 * The following is evil and should not really be
			 * done
			 */
			BIO_printf(io, "Ciphers supported in s_server binary\n");
			sk = SSL_get_ciphers(con);
			j = sk_SSL_CIPHER_num(sk);
			for (i = 0; i < j; i++) {
				c = sk_SSL_CIPHER_value(sk, i);
				BIO_printf(io, "%-11s:%-25s",
				    SSL_CIPHER_get_version(c),
				    SSL_CIPHER_get_name(c));
				if ((((i + 1) % 2) == 0) && (i + 1 != j))
					BIO_puts(io, "\n");
			}
			BIO_puts(io, "\n");
			p = SSL_get_shared_ciphers(con, buf, bufsize);
			if (p != NULL) {
				BIO_printf(io, "---\nCiphers common between both SSL end points:\n");
				j = i = 0;
				while (*p) {
					if (*p == ':') {
						BIO_write(io, space, 26 - j);
						i++;
						j = 0;
						BIO_write(io, ((i % 3) ? " " : "\n"), 1);
					} else {
						BIO_write(io, p, 1);
						j++;
					}
					p++;
				}
				BIO_puts(io, "\n");
			}
			BIO_printf(io, (SSL_cache_hit(con)
				? "---\nReused, "
				: "---\nNew, "));
			c = SSL_get_current_cipher(con);
			BIO_printf(io, "%s, Cipher is %s\n",
			    SSL_CIPHER_get_version(c),
			    SSL_CIPHER_get_name(c));
			SSL_SESSION_print(io, SSL_get_session(con));
			BIO_printf(io, "---\n");
			print_stats(io, SSL_get_SSL_CTX(con));
			BIO_printf(io, "---\n");
			peer = SSL_get_peer_certificate(con);
			if (peer != NULL) {
				BIO_printf(io, "Client certificate\n");
				X509_print(io, peer);
				PEM_write_bio_X509(io, peer);
			} else
				BIO_puts(io, "no client certificate available\n");
			BIO_puts(io, "</BODY></HTML>\r\n\r\n");
			break;
		} else if ((www == 2 || www == 3)
		    && (strncmp("GET /", buf, 5) == 0)) {
			BIO *file;
			char *p, *e;
			static const char *text = "HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n";

			/* skip the '/' */
			p = &(buf[5]);

			dot = 1;
			for (e = p; *e != '\0'; e++) {
				if (e[0] == ' ')
					break;

				switch (dot) {
				case 1:
					dot = (e[0] == '.') ? 2 : 0;
					break;
				case 2:
					dot = (e[0] == '.') ? 3 : 0;
					break;
				case 3:
					dot = (e[0] == '/') ? -1 : 0;
					break;
				}
				if (dot == 0)
					dot = (e[0] == '/') ? 1 : 0;
			}
			dot = (dot == 3) || (dot == -1);	/* filename contains
								 * ".." component */

			if (*e == '\0') {
				BIO_puts(io, text);
				BIO_printf(io, "'%s' is an invalid file name\r\n", p);
				break;
			}
			*e = '\0';

			if (dot) {
				BIO_puts(io, text);
				BIO_printf(io, "'%s' contains '..' reference\r\n", p);
				break;
			}
			if (*p == '/') {
				BIO_puts(io, text);
				BIO_printf(io, "'%s' is an invalid path\r\n", p);
				break;
			}
			/* if a directory, do the index thang */
			if (app_isdir(p) > 0) {
				BIO_puts(io, text);
				BIO_printf(io, "'%s' is a directory\r\n", p);
				break;
			}
			if ((file = BIO_new_file(p, "r")) == NULL) {
				BIO_puts(io, text);
				BIO_printf(io, "Error opening '%s'\r\n", p);
				ERR_print_errors(io);
				break;
			}
			if (!s_quiet)
				BIO_printf(bio_err, "FILE:%s\n", p);

			if (www == 2) {
				i = strlen(p);
				if (((i > 5) && (strcmp(&(p[i - 5]), ".html") == 0)) ||
				    ((i > 4) && (strcmp(&(p[i - 4]), ".php") == 0)) ||
				    ((i > 4) && (strcmp(&(p[i - 4]), ".htm") == 0)))
					BIO_puts(io, "HTTP/1.0 200 ok\r\nContent-type: text/html\r\n\r\n");
				else
					BIO_puts(io, "HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n");
			}
			/* send the file */
			for (;;) {
				i = BIO_read(file, buf, bufsize);
				if (i <= 0)
					break;

#ifdef RENEG
				total_bytes += i;
				fprintf(stderr, "%d\n", i);
				if (total_bytes > 3 * 1024) {
					total_bytes = 0;
					fprintf(stderr, "RENEGOTIATE\n");
					SSL_renegotiate(con);
				}
#endif

				for (j = 0; j < i;) {
#ifdef RENEG
					{
						static count = 0;
						if (++count == 13) {
							SSL_renegotiate(con);
						}
					}
#endif
					k = BIO_write(io, &(buf[j]), i - j);
					if (k <= 0) {
						if (!BIO_should_retry(io))
							goto write_error;
						else {
							BIO_printf(bio_s_out, "rwrite W BLOCK\n");
						}
					} else {
						j += k;
					}
				}
			}
	write_error:
			BIO_free(file);
			break;
		}
	}

	for (;;) {
		i = (int) BIO_flush(io);
		if (i <= 0) {
			if (!BIO_should_retry(io))
				break;
		} else
			break;
	}
end:
	/* make sure we re-use sessions */
	SSL_set_shutdown(con, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);

err:

	if (ret >= 0)
		BIO_printf(bio_s_out, "ACCEPT\n");

	if (buf != NULL)
		free(buf);
	if (io != NULL)
		BIO_free_all(io);
/*	if (ssl_bio != NULL) BIO_free(ssl_bio);*/
	return (ret);
}

static RSA *
tmp_rsa_cb(SSL * s, int is_export, int keylength)
{
	BIGNUM *bn = NULL;
	static RSA *rsa_tmp = NULL;

	if (!rsa_tmp && ((bn = BN_new()) == NULL))
		BIO_printf(bio_err, "Allocation error in generating RSA key\n");
	if (!rsa_tmp && bn) {
		if (!s_quiet) {
			BIO_printf(bio_err, "Generating temp (%d bit) RSA key...", keylength);
			(void) BIO_flush(bio_err);
		}
		if (!BN_set_word(bn, RSA_F4) || ((rsa_tmp = RSA_new()) == NULL) ||
		    !RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL)) {
			if (rsa_tmp)
				RSA_free(rsa_tmp);
			rsa_tmp = NULL;
		}
		if (!s_quiet) {
			BIO_printf(bio_err, "\n");
			(void) BIO_flush(bio_err);
		}
		BN_free(bn);
	}
	return (rsa_tmp);
}

#define MAX_SESSION_ID_ATTEMPTS 10
static int
generate_session_id(const SSL * ssl, unsigned char *id,
    unsigned int *id_len)
{
	unsigned int count = 0;
	do {
		RAND_pseudo_bytes(id, *id_len);
		/*
		 * Prefix the session_id with the required prefix. NB: If our
		 * prefix is too long, clip it - but there will be worse
		 * effects anyway, eg. the server could only possibly create
		 * 1 session ID (ie. the prefix!) so all future session
		 * negotiations will fail due to conflicts.
		 */
		memcpy(id, session_id_prefix,
		    (strlen(session_id_prefix) < *id_len) ?
		    strlen(session_id_prefix) : *id_len);
	}
	while (SSL_has_matching_session_id(ssl, id, *id_len) &&
	    (++count < MAX_SESSION_ID_ATTEMPTS));
	if (count >= MAX_SESSION_ID_ATTEMPTS)
		return 0;
	return 1;
}
@


1.63
log
@Include <sys/select.h> to get select

These files currently depends on the wrapper <stdlib.h> file indirectly
including a header that provides select().

from Jonas 'Sortie' Termansen

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.62 2014/07/25 06:05:32 doug Exp $ */
@


1.62
log
@BIO_free() returns immediately when the sole input is NULL.
Remove unnecessary NULL check.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.61 2014/07/14 00:35:10 deraadt Exp $ */
d151 1
@


1.61
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.60 2014/07/12 19:31:21 jsing Exp $ */
d1776 1
a1776 2
	if (bio != NULL)
		BIO_free(bio);
@


1.60
log
@In openssl_startup(), call SSL_library_init() and SSL_load_error_strings().
This allows us to remove the ERR_load_crypto_strings() call, along with
the various SSL_load_error_strings() and OpenSSL_add_ssl_algorithms()
calls scattered around the place.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.59 2014/07/12 17:54:31 jsing Exp $ */
d188 1
a188 1
static int 
d285 1
a285 1
static void 
d315 1
a315 1
static void 
d418 1
a418 1
static int 
d464 1
a464 1
static int 
d580 1
a580 1
static int 
d601 1
a601 1
int 
d1318 1
a1318 1
	
d1322 1
a1322 1
static void 
d1348 1
a1348 1
static int 
d1656 1
a1656 1
static void 
d1666 1
a1666 1
static int 
d1782 1
a1782 1
static int 
d2131 1
a2131 1
static int 
@


1.59
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.58 2014/07/11 09:24:44 beck Exp $ */
a929 3

	SSL_load_error_strings();
	OpenSSL_add_ssl_algorithms();
@


1.58
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.57 2014/07/10 08:59:15 bcook Exp $ */
a641 3

	if (!load_config(bio_err, NULL))
		goto end;
@


1.57
log
@check return value of write.

ok beck@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.56 2014/07/09 21:02:35 tedu Exp $ */
a282 62
#ifndef OPENSSL_NO_PSK
static char *psk_identity = "Client_identity";
char *psk_key = NULL;		/* by default PSK is not used */

static unsigned int 
psk_server_cb(SSL * ssl, const char *identity,
    unsigned char *psk, unsigned int max_psk_len)
{
	unsigned int psk_len = 0;
	int ret;
	BIGNUM *bn = NULL;

	if (s_debug)
		BIO_printf(bio_s_out, "psk_server_cb\n");
	if (!identity) {
		BIO_printf(bio_err, "Error: client did not send PSK identity\n");
		goto out_err;
	}
	if (s_debug)
		BIO_printf(bio_s_out, "identity_len=%d identity=%s\n",
		    identity ? (int) strlen(identity) : 0, identity);

	/* here we could lookup the given identity e.g. from a database */
	if (strcmp(identity, psk_identity) != 0) {
		BIO_printf(bio_s_out, "PSK error: client identity not found"
		    " (got '%s' expected '%s')\n", identity,
		    psk_identity);
		goto out_err;
	}
	if (s_debug)
		BIO_printf(bio_s_out, "PSK client identity found\n");

	/* convert the PSK key to binary */
	ret = BN_hex2bn(&bn, psk_key);
	if (!ret) {
		BIO_printf(bio_err, "Could not convert PSK key '%s' to BIGNUM\n", psk_key);
		if (bn)
			BN_free(bn);
		return 0;
	}
	if (BN_num_bytes(bn) > (int) max_psk_len) {
		BIO_printf(bio_err, "psk buffer of callback is too small (%d) for key (%d)\n",
		    max_psk_len, BN_num_bytes(bn));
		BN_free(bn);
		return 0;
	}
	ret = BN_bn2bin(bn, psk);
	BN_free(bn);

	if (ret < 0)
		goto out_err;
	psk_len = (unsigned int) ret;

	if (s_debug)
		BIO_printf(bio_s_out, "fetched PSK len=%d\n", psk_len);
	return psk_len;
out_err:
	if (s_debug)
		BIO_printf(bio_err, "Error in PSK server callback\n");
	return 0;
}
#endif
a358 4
#ifndef OPENSSL_NO_PSK
	BIO_printf(bio_err, " -psk_hint arg - PSK identity hint to use\n");
	BIO_printf(bio_err, " -psk arg      - PSK in hex (without 0x)\n");
#endif
a635 4
#ifndef OPENSSL_NO_PSK
	/* by default do not send a PSK identity hint */
	static char *psk_identity_hint = NULL;
#endif
a814 19
#ifndef OPENSSL_NO_PSK
		else if (strcmp(*argv, "-psk_hint") == 0) {
			if (--argc < 1)
				goto bad;
			psk_identity_hint = *(++argv);
		} else if (strcmp(*argv, "-psk") == 0) {
			size_t i;

			if (--argc < 1)
				goto bad;
			psk_key = *(++argv);
			for (i = 0; i < strlen(psk_key); i++) {
				if (isxdigit((unsigned char) psk_key[i]))
					continue;
				BIO_printf(bio_err, "Not a hex number '%s'\n", *argv);
				goto bad;
			}
		}
#endif
a1241 12
#ifndef OPENSSL_NO_PSK
	if (psk_key != NULL) {
		if (s_debug)
			BIO_printf(bio_s_out, "PSK key given, setting server callback\n");
		SSL_CTX_set_psk_server_callback(ctx, psk_server_cb);
	}
	if (!SSL_CTX_use_psk_identity_hint(ctx, psk_identity_hint)) {
		BIO_printf(bio_err, "error setting PSK identity hint to context\n");
		ERR_print_errors(bio_err);
		goto end;
	}
#endif
@


1.56
log
@unifdef a whole bunch of NO RSA/DSA/ECDH defines i deleted from libssl
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.55 2014/07/09 20:59:41 tedu Exp $ */
d1712 14
a1725 3
				case SSL_ERROR_NONE:
					write(fileno(stdout), buf,
					    (unsigned int) i);
@


1.55
log
@clean up if 0/if 1 code. we don't care anymore.
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.54 2014/06/28 04:39:41 deraadt Exp $ */
a175 1
#ifndef OPENSSL_NO_RSA
a176 1
#endif
a180 1
#ifndef OPENSSL_NO_RSA
a181 1
#endif
a404 1
#ifndef OPENSSL_NO_ECDH
a407 1
#endif
a440 1
#ifndef OPENSSL_NO_ECDH
a441 1
#endif
a675 1
#ifndef OPENSSL_NO_ECDH
a676 1
#endif
a775 1
#ifndef OPENSSL_NO_ECDH
a780 1
#endif
a1113 1
#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_ECDSA)
a1114 1
#endif
a1274 1
#ifndef OPENSSL_NO_ECDH
a1311 1
#endif
a1322 1
#ifndef OPENSSL_NO_RSA
a1329 1
#endif
a2197 1
#ifndef OPENSSL_NO_RSA
a2224 1
#endif
@


1.54
log
@Use strtonum() instead of atoi(), and then impose what are we think
are the current range checks.  Help from millert and lteo.  Please test
now that it is deployed and let us know if any numbers are off..
ok lteo
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.53 2014/06/13 04:29:13 miod Exp $ */
d557 1
a557 5
#if 0
	STACK_OF(OCSP_RESPID) * ids;
	SSL_get_tlsext_status_ids(s, &ids);
	BIO_printf(err, "cert_status: received %d ids\n", sk_OCSP_RESPID_num(ids));
#endif
a1182 11
#if 0
	if (cipher == NULL)
		cipher = getenv("SSL_CIPHER");
#endif

#if 0
	if (s_cert_file == NULL) {
		BIO_printf(bio_err, "You must specify a certificate file for the server to use\n");
		goto end;
	}
#endif
a1339 1
#if 1
a1346 25
#else
	if (!no_tmp_rsa && SSL_CTX_need_tmp_RSA(ctx)) {
		RSA *rsa;

		BIO_printf(bio_s_out, "Generating temp (512 bit) RSA key...");
		BIO_flush(bio_s_out);

		rsa = RSA_generate_key(512, RSA_F4, NULL);

		if (!SSL_CTX_set_tmp_rsa(ctx, rsa)) {
			ERR_print_errors(bio_err);
			goto end;
		}
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2) {
			if (!SSL_CTX_set_tmp_rsa(ctx2, rsa)) {
				ERR_print_errors(bio_err);
				goto end;
			}
		}
#endif
		RSA_free(rsa);
		BIO_printf(bio_s_out, "\n");
	}
#endif
a1756 1
#if 1
a1757 3
#else
		SSL_shutdown(con);
#endif
a1895 22
#if 0
static int 
load_CA(SSL_CTX * ctx, char *file)
{
	FILE *in;
	X509 *x = NULL;

	if ((in = fopen(file, "r")) == NULL)
		return (0);

	for (;;) {
		if (PEM_read_X509(in, &x, NULL) == NULL)
			break;
		SSL_CTX_add_client_CA(ctx, x);
	}
	if (x != NULL)
		X509_free(x);
	fclose(in);
	return (1);
}
#endif

a2123 6
#if 0
			/* append if a directory lookup */
			if (e[-1] == '/')
				strcat(p, "index.html");
#endif

a2125 3
#if 0				/* must check buffer size */
				strcat(p, "/index.html");
#else
a2128 1
#endif
a2199 1
#if 1
a2201 5
#else
	/* This kills performance */
/*	SSL_shutdown(con); A shutdown gets sent in the
 *	BIO_free_all(io) procession */
#endif
@


1.53
log
@Remove support for the `opaque PRF input' extension, which draft has expired
7 years ago and never made it into an RFC. That code wasn't compiled in
anyway unless one would define the actual on-the-wire extension id bytes;
crank libssl major.

With help and enlightenment from Brendan MacDonell.
@
text
@d1 1
a1 1
/* $OpenBSD: s_server.c,v 1.52 2014/06/12 15:49:27 deraadt Exp $ */
d157 1
d706 1
d748 3
a750 1
			verify_depth = atoi(*(++argv));
d757 3
a759 1
			verify_depth = atoi(*(++argv));
d865 3
a867 1
			tlscstatp.timeout = atoi(*(++argv));
d962 3
a964 1
			socket_mtu = atol(*(++argv));
d1018 2
a1019 2
			keymatexportlen = atoi(*(++argv));
			if (keymatexportlen == 0)
d1031 5
a1035 1
		sv_usage();
@


1.52
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a1543 5
#if 0
#ifdef TLSEXT_TYPE_opaque_prf_input
	SSL_set_tlsext_opaque_prf_input(con, "Test server", 11);
#endif
#endif
@


1.51
log
@Stop pretending that openssl(1) applications support the -rand option.
The underlying code has long been removed, making this a no-op.

If your random subsystem actually requires that you seed it from a file,
then you really should go and buy a new random subsystem that was built
after 1990.

Diff from Brent Cook.

ok deraadt@@
@
text
@d1 1
a1 1
/* apps/s_server.c */
@


1.50
log
@Make usage for -quiet match the manpage and fix a misspelling
@
text
@a457 1
	BIO_printf(bio_err, " -rand file:file:...\n");
a697 1
	char *inrand = NULL;
a969 5
		else if (strcmp(*argv, "-rand") == 0) {
			if (--argc < 1)
				goto bad;
			inrand = *(++argv);
		}
@


1.49
log
@no need for null check before free. from Brendan MacDonell
@
text
@d394 1
a394 1
	    "                 or any other CRL in the CA chain. CRL(s) are appened to the\n" \
d424 1
a424 1
	BIO_printf(bio_err, " -quiet        - No server output\n");
@


1.48
log
@There is no need to include <openssl/e_os2.h> here, except for the fact
that it brings in <openssl/opensslconf.h>, so just do that instead
(currently via apps.h).
@
text
@d1463 3
a1465 6
	if (tlscstatp.host)
		free(tlscstatp.host);
	if (tlscstatp.port)
		free(tlscstatp.port);
	if (tlscstatp.path)
		free(tlscstatp.path);
@


1.47
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@a162 1
#include <openssl/e_os2.h>
@


1.46
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a725 1
	signal(SIGPIPE, SIG_IGN);
@


1.45
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d1460 2
a1461 4
	if (pass)
		free(pass);
	if (dpass)
		free(dpass);
@


1.44
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d149 1
d151 1
a158 1
#include <sys/socket.h>
d160 1
a160 1
#include <openssl/e_os2.h>
a161 3
#include <sys/types.h>

#include <openssl/lhash.h>
d163 1
a163 1
#include "apps.h"
d165 2
d168 2
d171 1
a171 3
#include <openssl/ssl.h>
#include <openssl/rand.h>
#include <openssl/ocsp.h>
d175 1
d179 1
a181 1

@


1.43
log
@less than jpake
@
text
@a727 3
	if (bio_err == NULL)
		bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);

@


1.42
log
@remove Kerberos
@
text
@a428 2
#ifndef OPENSSL_NO_JPAKE
	BIO_printf(bio_err, " -jpake arg    - JPAKE secret to use\n");
a429 2
#endif
	BIO_printf(bio_err, " -ssl2         - Just talk SSLv2\n");
a674 3
#ifndef OPENSSL_NO_JPAKE
static char *jpake_secret = NULL;
#endif
a1004 7
#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)
		else if (strcmp(*argv, "-jpake") == 0) {
			if (--argc < 1)
				goto bad;
			jpake_secret = *(++argv);
		}
#endif
a1034 15
#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)
	if (jpake_secret) {
		if (psk_key) {
			BIO_printf(bio_err,
			    "Can't use JPAKE and PSK together\n");
			goto end;
		}
		psk_identity = "JPAKE";
		if (cipher) {
			BIO_printf(bio_err, "JPAKE sets cipher to PSK\n");
			goto end;
		}
		cipher = "PSK";
	}
#endif
d1388 1
a1388 6
#ifdef OPENSSL_NO_JPAKE
	if (psk_key != NULL)
#else
	if (psk_key != NULL || jpake_secret)
#endif
	{
d1390 1
a1390 1
			BIO_printf(bio_s_out, "PSK key given or JPAKE in use, setting server callback\n");
a1596 4
#ifndef OPENSSL_NO_JPAKE
	if (jpake_secret)
		jpake_server_auth(bio_s_out, sbio, jpake_secret);
#endif
@


1.41
log
@bye bye SRP
@
text
@a1559 3
#ifndef OPENSSL_NO_KRB5
	KSSL_CTX *kctx;
#endif
a1588 7
#ifndef OPENSSL_NO_KRB5
		if ((kctx = kssl_ctx_new()) != NULL) {
			SSL_set0_kssl_ctx(con, kctx);
			kssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);
			kssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);
		}
#endif				/* OPENSSL_NO_KRB5 */
a1877 3
#ifndef OPENSSL_NO_KRB5
	char *client_princ;
#endif
a1940 7
#ifndef OPENSSL_NO_KRB5
	client_princ = kssl_ctx_get0_client_princ(SSL_get0_kssl_ctx(con));
	if (client_princ != NULL) {
		BIO_printf(bio_s_out, "Kerberos peer principal is %s\n",
		    client_princ);
	}
#endif				/* OPENSSL_NO_KRB5 */
a1984 3
#ifndef OPENSSL_NO_KRB5
char *client_princ;
#endif
a2016 3
#ifndef OPENSSL_NO_KRB5
	KSSL_CTX *kctx;
#endif
a2046 6
#ifndef OPENSSL_NO_KRB5
	if ((kctx = kssl_ctx_new()) != NULL) {
		kssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);
		kssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);
	}
#endif				/* OPENSSL_NO_KRB5 */
@


1.40
log
@During the great e_os.h nukathon we stopped pulling in <sys/filio.h> via
the ifdef maze, meaning that FIONBIO was no longer defined. This removes
non-blocking I/O support from s_{client,server,time}.

Remove all FIONBIO ifdefs and import <sys/ioctl.h>, renabling -nbio.

ok miod@@
@
text
@a177 3
#ifndef OPENSSL_NO_SRP
#include <openssl/srp.h>
#endif
a348 41
#ifndef OPENSSL_NO_SRP
/* This is a context that we pass to callbacks */
typedef struct srpsrvparm_st {
	char *login;
	SRP_VBASE *vb;
	SRP_user_pwd *user;
} srpsrvparm;

/* This callback pretends to require some asynchronous logic in order to obtain
   a verifier. When the callback is called for a new connection we return
   with a negative value. This will provoke the accept etc to return with
   an LOOKUP_X509. The main logic of the reinvokes the suspended call
   (which would normally occur after a worker has finished) and we
   set the user parameters.
*/
static int 
ssl_srp_server_param_cb(SSL * s, int *ad, void *arg)
{
	srpsrvparm *p = (srpsrvparm *) arg;
	if (p->login == NULL && p->user == NULL) {
		p->login = SSL_get_srp_username(s);
		BIO_printf(bio_err, "SRP username = \"%s\"\n", p->login);
		return (-1);
	}
	if (p->user == NULL) {
		BIO_printf(bio_err, "User %s doesn't exist\n", p->login);
		return SSL3_AL_FATAL;
	}
	if (SSL_set_srp_server_param(s, p->user->N, p->user->g, p->user->s, p->user->v,
		p->user->info) < 0) {
		*ad = SSL_AD_INTERNAL_ERROR;
		return SSL3_AL_FATAL;
	}
	BIO_printf(bio_err, "SRP parameters set: username = \"%s\" info=\"%s\" \n", p->login, p->user->info);
	/* need to check whether there are memory leaks */
	p->user = NULL;
	p->login = NULL;
	return SSL_ERROR_NONE;
}

#endif
a432 4
#ifndef OPENSSL_NO_SRP
	BIO_printf(bio_err, " -srpvfile file      - The verifier file for SRP\n");
	BIO_printf(bio_err, " -srpuserseed string - A seed string for a default user salt.\n");
#endif
a681 3
#ifndef OPENSSL_NO_SRP
static srpsrvparm srp_callback_parm;
#endif
a726 4
#ifndef OPENSSL_NO_SRP
	char *srpuserseed = NULL;
	char *srp_verifier_file = NULL;
#endif
a924 13
#ifndef OPENSSL_NO_SRP
		else if (strcmp(*argv, "-srpvfile") == 0) {
			if (--argc < 1)
				goto bad;
			srp_verifier_file = *(++argv);
			meth = TLSv1_server_method();
		} else if (strcmp(*argv, "-srpuserseed") == 0) {
			if (--argc < 1)
				goto bad;
			srpuserseed = *(++argv);
			meth = TLSv1_server_method();
		}
#endif
a1469 16
#ifndef OPENSSL_NO_SRP
	if (srp_verifier_file != NULL) {
		srp_callback_parm.vb = SRP_VBASE_new(srpuserseed);
		srp_callback_parm.user = NULL;
		srp_callback_parm.login = NULL;
		if ((ret = SRP_VBASE_init(srp_callback_parm.vb, srp_verifier_file)) != SRP_NO_ERROR) {
			BIO_printf(bio_err,
			    "Cannot initialize SRP verifier file \"%s\":ret=%d\n",
			    srp_verifier_file, ret);
			goto end;
		}
		SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, verify_callback);
		SSL_CTX_set_srp_cb_arg(ctx, &srp_callback_parm);
		SSL_CTX_set_srp_username_callback(ctx, ssl_srp_server_param_cb);
	} else
#endif
a1784 11
#ifndef OPENSSL_NO_SRP
				while (SSL_get_error(con, k) == SSL_ERROR_WANT_X509_LOOKUP) {
					BIO_printf(bio_s_out, "LOOKUP renego during write\n");
					srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login);
					if (srp_callback_parm.user)
						BIO_printf(bio_s_out, "LOOKUP done %s\n", srp_callback_parm.user->info);
					else
						BIO_printf(bio_s_out, "LOOKUP not successful\n");
					k = SSL_write(con, &(buf[l]), (unsigned int) i);
				}
#endif
a1824 11
#ifndef OPENSSL_NO_SRP
				while (SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {
					BIO_printf(bio_s_out, "LOOKUP renego during read\n");
					srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login);
					if (srp_callback_parm.user)
						BIO_printf(bio_s_out, "LOOKUP done %s\n", srp_callback_parm.user->info);
					else
						BIO_printf(bio_s_out, "LOOKUP not successful\n");
					i = SSL_read(con, (char *) buf, bufsize);
				}
#endif
a1898 11
#ifndef OPENSSL_NO_SRP
	while (i <= 0 && SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {
		BIO_printf(bio_s_out, "LOOKUP during accept %s\n", srp_callback_parm.login);
		srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login);
		if (srp_callback_parm.user)
			BIO_printf(bio_s_out, "LOOKUP done %s\n", srp_callback_parm.user->info);
		else
			BIO_printf(bio_s_out, "LOOKUP not successful\n");
		i = SSL_accept(con);
	}
#endif
a2108 11
#ifndef OPENSSL_NO_SRP
			while (i <= 0 && SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {
				BIO_printf(bio_s_out, "LOOKUP during accept %s\n", srp_callback_parm.login);
				srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login);
				if (srp_callback_parm.user)
					BIO_printf(bio_s_out, "LOOKUP done %s\n", srp_callback_parm.user->info);
				else
					BIO_printf(bio_s_out, "LOOKUP not successful\n");
				i = SSL_accept(con);
			}
#endif
@


1.39
log
@remove crazy #undefs; ok jsing
@
text
@d149 2
a253 1
#ifdef FIONBIO
a254 1
#endif
a408 1
#ifdef FIONBIO
a409 1
#endif
a456 1
#ifdef FIONBIO
a457 1
#endif
a796 1
#ifdef FIONBIO
a797 1
#endif
a905 1
#ifdef FIONBIO
a908 1
#endif
a909 1
#ifdef FIONBIO
a910 1
#endif
a1653 1
#ifdef FIONBIO
a1661 1
#endif
a2168 1
#ifdef FIONBIO
a2176 1
#endif
@


1.38
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a232 1
#undef BUFSIZZ
@


1.37
log
@Nuke the last of the windows related defines from the openssl apps.

ok deraadt@@
@
text
@d792 1
a792 1
	apps_startup();
d1615 1
a1615 1
	apps_shutdown();
@


1.36
log
@remove the openssl_fdset wrapper, and a variety of VMS'ism's like
crazy (void *) casts all over the place
ok beck jsing
@
text
@a157 3
#ifdef OPENSSL_NO_STDIO
#define APPS_WIN16
#endif
@


1.35
log
@ReadFile() and GetStdHandle() are not very POSIX.
ok beck jsing
@
text
@d1776 2
a1777 10
			openssl_fdset(fileno(stdin), &readfds);
			openssl_fdset(s, &readfds);
			/*
			 * Note: under VMS with SOCKETSHR the second
			 * parameter is currently of type (int *) whereas
			 * under other systems it is (void *) if you don't
			 * have a cast it will choke the compiler: if you do
			 * have a cast then you can either go for (int *) or
			 * (void *).
			 */
d1784 1
a1784 1
			i = select(width, (void *) &readfds, NULL, NULL, timeoutp);
@


1.34
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d1808 1
a1808 1
				i = raw_read_stdin(buf, bufsize / 2);
d1824 1
a1824 1
				i = raw_read_stdin(buf, bufsize);
d1957 1
a1957 1
					raw_write_stdout(buf,
@


1.33
log
@Finish zapping SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION usage; only keep
the #define for compat, but document that it's a no-op now.  Also, neuter
the -legacy_renegotiation option to "openssl s_{client,server}"

ok beck@@
@
text
@a1229 8
	if (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL
	    && !RAND_status()) {
		BIO_printf(bio_err, "warning, not much extra random data, consider using the -rand option\n");
	}
	if (inrand != NULL)
		BIO_printf(bio_err, "%ld semi-random bytes loaded\n",
		    app_RAND_load_files(inrand));

@


1.32
log
@simplify file:file:... stuff
@
text
@a527 1
	BIO_printf(bio_err, " -legacy_renegotiation - enable use of legacy renegotiation (dangerous)\n");
d906 1
a906 1
			off |= SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
@


1.31
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d518 1
a518 1
	BIO_printf(bio_err, " -rand file%cfile%c...\n", ':', ':');
@


1.30
log
@KaboomNF
@
text
@a244 2
#undef PROG
#define PROG		s_server_main
d734 1
a734 1
int MAIN(int, char **);
d747 1
a747 1
MAIN(int argc, char *argv[])
@


1.29
log
@Remove support for unwanted operating systems.

ok miod@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d113 1
a113 1
 * ECC cipher suite support in OpenSSL originally developed by 
d187 1
a187 1
static RSA *tmp_rsa_cb(SSL *s, int is_export, int keylength);
d191 1
a191 1
static void close_accept_socket(void );
d193 5
a197 4
static int init_ssl_connection(SSL *s);
static void print_stats(BIO *bp,SSL_CTX *ctx);
static int generate_session_id(const SSL *ssl, unsigned char *id,
				unsigned int *id_len);
d206 9
a214 9
static unsigned char dh512_p[]={
	0xDA,0x58,0x3C,0x16,0xD9,0x85,0x22,0x89,0xD0,0xE4,0xAF,0x75,
	0x6F,0x4C,0xCA,0x92,0xDD,0x4B,0xE5,0x33,0xB8,0x04,0xFB,0x0F,
	0xED,0x94,0xEF,0x9C,0x8A,0x44,0x03,0xED,0x57,0x46,0x50,0xD3,
	0x69,0x99,0xDB,0x29,0xD7,0x76,0x27,0x6B,0xA2,0xD3,0xD4,0x12,
	0xE2,0x18,0xF4,0xDD,0x1E,0x08,0x4C,0xF6,0xD8,0x00,0x3E,0x7C,
	0x47,0x74,0xE8,0x33,
	};
static unsigned char dh512_g[]={
d216 1
a216 5
	};

static DH *get_dh512(void)
	{
	DH *dh=NULL;
d218 9
a226 3
	if ((dh=DH_new()) == NULL) return(NULL);
	dh->p=BN_bin2bn(dh512_p,sizeof(dh512_p),NULL);
	dh->g=BN_bin2bn(dh512_g,sizeof(dh512_g),NULL);
d228 3
a230 3
		return(NULL);
	return(dh);
	}
d238 2
a239 2
static int bufsize=BUFSIZZ;
static int accept_socket= -1;
d250 4
a253 4
static char *cipher=NULL;
static int s_server_verify=SSL_VERIFY_NONE;
static int s_server_session_id_context = 1; /* anything will do */
static const char *s_cert_file=TEST_CERT,*s_key_file=NULL;
d255 1
a255 1
static const char *s_cert_file2=TEST_CERT2,*s_key_file2=NULL;
d257 1
a257 1
static char *s_dcert_file=NULL,*s_dkey_file=NULL;
d259 1
a259 1
static int s_nbio=0;
d261 3
a263 3
static int s_nbio_test=0;
int s_crlf=0;
static SSL_CTX *ctx=NULL;
d265 1
a265 1
static SSL_CTX *ctx2=NULL;
d267 1
a267 1
static int www=0;
d269 2
a270 2
static BIO *bio_s_out=NULL;
static int s_debug=0;
d272 3
a274 3
static int s_tlsextdebug=0;
static int s_tlsextstatus=0;
static int cert_status_cb(SSL *s, void *arg);
d276 2
a277 2
static int s_msg=0;
static int s_quiet=0;
d279 2
a280 2
static char *keymatexportlabel=NULL;
static int keymatexportlen=20;
d282 1
a282 1
static int hack=0;
d284 1
a284 1
static char *engine_id=NULL;
d286 1
a286 1
static const char *session_id_prefix=NULL;
d296 2
a297 2
static char *psk_identity="Client_identity";
char *psk_key=NULL; /* by default PSK is not used */
d299 4
a302 3
static unsigned int psk_server_cb(SSL *ssl, const char *identity,
	unsigned char *psk, unsigned int max_psk_len)
	{
d308 3
a310 4
		BIO_printf(bio_s_out,"psk_server_cb\n");
	if (!identity)
		{
		BIO_printf(bio_err,"Error: client did not send PSK identity\n");
d312 1
a312 1
		}
d314 2
a315 2
		BIO_printf(bio_s_out,"identity_len=%d identity=%s\n",
			identity ? (int)strlen(identity) : 0, identity);
d318 4
a321 5
  	if (strcmp(identity, psk_identity) != 0)
		{
                BIO_printf(bio_s_out, "PSK error: client identity not found"
			   " (got '%s' expected '%s')\n", identity,
			   psk_identity);
d323 1
a323 1
                }
d329 2
a330 3
	if (!ret)
		{
		BIO_printf(bio_err,"Could not convert PSK key '%s' to BIGNUM\n", psk_key);
d334 4
a337 5
		}
	if (BN_num_bytes(bn) > (int)max_psk_len)
		{
		BIO_printf(bio_err,"psk buffer of callback is too small (%d) for key (%d)\n",
			max_psk_len, BN_num_bytes(bn));
d340 1
a340 2
		}

d346 1
a346 1
	psk_len = (unsigned int)ret;
d350 2
a351 2
        return psk_len;
 out_err:
d355 1
a355 1
        }
d360 1
a360 2
typedef struct srpsrvparm_st
	{
d364 1
a364 1
	} srpsrvparm;
d369 1
a369 1
   an LOOKUP_X509. The main logic of the reinvokes the suspended call 
d371 1
a371 1
   set the user parameters. 
d373 5
a377 5
static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
	{
	srpsrvparm *p = (srpsrvparm *)arg;
	if (p->login == NULL && p->user == NULL )
		{
d380 3
a382 5
		return (-1) ;
		}

	if (p->user == NULL)
		{
d385 1
a385 1
		}
d387 1
a387 2
				     p->user->info) < 0)
		{
d390 2
a391 2
		}
	BIO_printf(bio_err, "SRP parameters set: username = \"%s\" info=\"%s\" \n", p->login,p->user->info);
d396 1
a396 1
	}
d400 14
a413 13
static void s_server_init(void)
	{
	accept_socket=-1;
	cipher=NULL;
	s_server_verify=SSL_VERIFY_NONE;
	s_dcert_file=NULL;
	s_dkey_file=NULL;
	s_cert_file=TEST_CERT;
	s_key_file=NULL;
#ifndef OPENSSL_NO_TLSEXT
	s_cert_file2=TEST_CERT2;
	s_key_file2=NULL;
	ctx2=NULL;
d416 1
a416 1
	s_nbio=0;
d418 9
a426 9
	s_nbio_test=0;
	ctx=NULL;
	www=0;

	bio_s_out=NULL;
	s_debug=0;
	s_msg=0;
	s_quiet=0;
	hack=0;
d428 1
a428 1
	engine_id=NULL;
d430 1
a430 1
	}
d432 28
a459 27
static void sv_usage(void)
	{
	BIO_printf(bio_err,"usage: s_server [args ...]\n");
	BIO_printf(bio_err,"\n");
	BIO_printf(bio_err," -accept arg   - port to accept on (default is %d)\n",PORT);
	BIO_printf(bio_err," -context arg  - set session ID context\n");
	BIO_printf(bio_err," -verify arg   - turn on peer certificate verification\n");
	BIO_printf(bio_err," -Verify arg   - turn on peer certificate verification, must have a cert.\n");
	BIO_printf(bio_err," -cert arg     - certificate file to use\n");
	BIO_printf(bio_err,"                 (default is %s)\n",TEST_CERT);
	BIO_printf(bio_err," -crl_check    - check the peer certificate has not been revoked by its CA.\n" \
	                   "                 The CRL(s) are appended to the certificate file\n");
	BIO_printf(bio_err," -crl_check_all - check the peer certificate has not been revoked by its CA\n" \
	                   "                 or any other CRL in the CA chain. CRL(s) are appened to the\n" \
	                   "                 the certificate file.\n");
	BIO_printf(bio_err," -certform arg - certificate format (PEM or DER) PEM default\n");
	BIO_printf(bio_err," -key arg      - Private Key file to use, in cert file if\n");
	BIO_printf(bio_err,"                 not specified (default is %s)\n",TEST_CERT);
	BIO_printf(bio_err," -keyform arg  - key format (PEM, DER or ENGINE) PEM default\n");
	BIO_printf(bio_err," -pass arg     - private key file pass phrase source\n");
	BIO_printf(bio_err," -dcert arg    - second certificate file to use (usually for DSA)\n");
	BIO_printf(bio_err," -dcertform x  - second certificate format (PEM or DER) PEM default\n");
	BIO_printf(bio_err," -dkey arg     - second private key file to use (usually for DSA)\n");
	BIO_printf(bio_err," -dkeyform arg - second key format (PEM, DER or ENGINE) PEM default\n");
	BIO_printf(bio_err," -dpass arg    - second private key file pass phrase source\n");
	BIO_printf(bio_err," -dhparam arg  - DH parameter file to use, in cert file if not specified\n");
	BIO_printf(bio_err,"                 or a default set of parameters is used\n");
d461 3
a463 3
	BIO_printf(bio_err," -named_curve arg  - Elliptic curve name to use for ephemeral ECDH keys.\n" \
	                   "                 Use \"openssl ecparam -list_curves\" for all names\n" \
	                   "                 (default is nistp256).\n");
d466 1
a466 1
	BIO_printf(bio_err," -nbio         - Run with non-blocking IO\n");
d468 12
a479 12
	BIO_printf(bio_err," -nbio_test    - test with the non-blocking test bio\n");
	BIO_printf(bio_err," -crlf         - convert LF from terminal into CRLF\n");
	BIO_printf(bio_err," -debug        - Print more output\n");
	BIO_printf(bio_err," -msg          - Show protocol messages\n");
	BIO_printf(bio_err," -state        - Print the SSL states\n");
	BIO_printf(bio_err," -CApath arg   - PEM format directory of CA's\n");
	BIO_printf(bio_err," -CAfile arg   - PEM format file of CA's\n");
	BIO_printf(bio_err," -nocert       - Don't use any certificates (Anon-DH)\n");
	BIO_printf(bio_err," -cipher arg   - play with 'openssl ciphers' to see what goes here\n");
	BIO_printf(bio_err," -serverpref   - Use server's cipher preferences\n");
	BIO_printf(bio_err," -quiet        - No server output\n");
	BIO_printf(bio_err," -no_tmp_rsa   - Do not generate a tmp RSA key\n");
d481 5
a485 5
	BIO_printf(bio_err," -psk_hint arg - PSK identity hint to use\n");
	BIO_printf(bio_err," -psk arg      - PSK in hex (without 0x)\n");
# ifndef OPENSSL_NO_JPAKE
	BIO_printf(bio_err," -jpake arg    - JPAKE secret to use\n");
# endif
d488 2
a489 2
	BIO_printf(bio_err," -srpvfile file      - The verifier file for SRP\n");
	BIO_printf(bio_err," -srpuserseed string - A seed string for a default user salt.\n");
d491 14
a504 14
	BIO_printf(bio_err," -ssl2         - Just talk SSLv2\n");
	BIO_printf(bio_err," -ssl3         - Just talk SSLv3\n");
	BIO_printf(bio_err," -tls1_2       - Just talk TLSv1.2\n");
	BIO_printf(bio_err," -tls1_1       - Just talk TLSv1.1\n");
	BIO_printf(bio_err," -tls1         - Just talk TLSv1\n");
	BIO_printf(bio_err," -dtls1        - Just talk DTLSv1\n");
	BIO_printf(bio_err," -timeout      - Enable timeouts\n");
	BIO_printf(bio_err," -mtu          - Set link layer MTU\n");
	BIO_printf(bio_err," -chain        - Read a certificate chain\n");
	BIO_printf(bio_err," -no_ssl2      - Just disable SSLv2\n");
	BIO_printf(bio_err," -no_ssl3      - Just disable SSLv3\n");
	BIO_printf(bio_err," -no_tls1      - Just disable TLSv1\n");
	BIO_printf(bio_err," -no_tls1_1    - Just disable TLSv1.1\n");
	BIO_printf(bio_err," -no_tls1_2    - Just disable TLSv1.2\n");
d506 1
a506 1
	BIO_printf(bio_err," -no_dhe       - Disable ephemeral DH\n");
d509 1
a509 1
	BIO_printf(bio_err," -no_ecdhe     - Disable ephemeral ECDH\n");
d511 5
a515 5
	BIO_printf(bio_err," -bugs         - Turn on SSL bug compatibility\n");
	BIO_printf(bio_err," -www          - Respond to a 'GET /' with a status page\n");
	BIO_printf(bio_err," -WWW          - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\n");
	BIO_printf(bio_err," -HTTP         - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\n");
        BIO_printf(bio_err,"                 with the assumption it contains a complete HTTP response.\n");
d517 1
a517 1
	BIO_printf(bio_err," -engine id    - Initialise and use the specified engine\n");
d519 2
a520 2
	BIO_printf(bio_err," -id_prefix arg - Generate SSL/TLS session IDs prefixed by 'arg'\n");
	BIO_printf(bio_err," -rand file%cfile%c...\n", ':', ':');
d522 15
a536 15
	BIO_printf(bio_err," -servername host - servername for HostName TLS extension\n");
	BIO_printf(bio_err," -servername_fatal - on mismatch send fatal alert (default warning alert)\n");
	BIO_printf(bio_err," -cert2 arg    - certificate file to use for servername\n");
	BIO_printf(bio_err,"                 (default is %s)\n",TEST_CERT2);
	BIO_printf(bio_err," -key2 arg     - Private Key file to use for servername, in cert file if\n");
	BIO_printf(bio_err,"                 not specified (default is %s)\n",TEST_CERT2);
	BIO_printf(bio_err," -tlsextdebug  - hex dump of all TLS extensions received\n");
	BIO_printf(bio_err," -no_ticket    - disable use of RFC4507bis session tickets\n");
	BIO_printf(bio_err," -legacy_renegotiation - enable use of legacy renegotiation (dangerous)\n");
# ifndef OPENSSL_NO_NEXTPROTONEG
	BIO_printf(bio_err," -nextprotoneg arg - set the advertised protocols for the NPN extension (comma-separated list)\n");
# endif
# ifndef OPENSSL_NO_SRTP
        BIO_printf(bio_err," -use_srtp profiles - Offer SRTP key management with a colon-separated profile list\n");
# endif
d538 3
a540 3
	BIO_printf(bio_err," -keymatexport label   - Export keying material using label\n");
	BIO_printf(bio_err," -keymatexportlen len  - Export len bytes of keying material (default 20)\n");
	}
d542 1
a542 1
static int local_argc=0;
d549 3
a551 3
   char * servername;
   BIO * biodebug;
   int extension_error;
d555 8
a562 7
static int ssl_servername_cb(SSL *s, int *ad, void *arg)
	{
	tlsextctx * p = (tlsextctx *) arg;
	const char * servername = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);
        if (servername && p->biodebug) 
		BIO_printf(p->biodebug,"Hostname in TLS extension: \"%s\"\n",servername);
        
d565 3
a567 4
	
	if (servername)
		{
    		if (strcmp(servername,p->servername)) 
d569 3
a571 5
		if (ctx2)
			{
			BIO_printf(p->biodebug,"Switching server context.\n");
			SSL_set_SSL_CTX(s,ctx2);
			}     
d573 1
d580 6
a585 6
   /* Default responder to use */
   char *host, *path, *port;
   int use_ssl;
   int timeout;
   BIO *err;
   int verbose;
d601 3
a603 2
static int cert_status_cb(SSL *s, void *arg)
	{
d610 1
a610 1
	STACK_OF(OPENSSL_STRING) *aia = NULL;
d617 1
a617 1
	STACK_OF(X509_EXTENSION) *exts;
d621 3
a623 3
STACK_OF(OCSP_RESPID) *ids;
SSL_get_tlsext_status_ids(s, &ids);
BIO_printf(err, "cert_status: received %d ids\n", sk_OCSP_RESPID_num(ids));
d630 1
a630 2
	if (aia)
		{
d632 1
a632 2
			&host, &port, &path, &use_ssl))
			{
d635 1
a635 1
			}
d638 3
a640 6
					sk_OPENSSL_STRING_value(aia, 0));
		}
	else
		{
		if (!srctx->host)
			{
d643 1
a643 1
			}
d648 2
a649 2
		}
		
d651 2
a652 2
				SSL_CTX_get_cert_store(SSL_get_SSL_CTX(s)),
				NULL, NULL))
d654 2
a655 3
	if (X509_STORE_get_by_subject(&inctx,X509_LU_X509,
				X509_get_issuer_name(x),&obj) <= 0)
		{
d659 1
a659 1
		}
d673 1
a673 2
	for (i = 0; i < sk_X509_EXTENSION_num(exts); i++)
		{
d677 1
a677 1
		}
d679 2
a680 3
					srctx->timeout);
	if (!resp)
		{
d683 1
a683 1
		}
d688 1
a688 2
	if (srctx->verbose)
		{
d691 1
a691 1
		}
d693 1
a693 1
	done:
d696 1
a696 2
	if (aia)
		{
d701 1
a701 1
		}
d709 1
a709 1
	err:
d712 1
a712 1
	}
d714 1
a714 1
# ifndef OPENSSL_NO_NEXTPROTONEG
d721 3
a723 2
static int next_proto_cb(SSL *s, const unsigned char **data, unsigned int *len, void *arg)
	{
d730 2
a731 2
	}
# endif  /* ndef OPENSSL_NO_NEXTPROTONEG */
d742 1
a742 1
	static srpsrvparm srp_callback_parm;
d748 3
a750 2
int MAIN(int argc, char *argv[])
	{
d753 2
a754 2
	short port=PORT;
	char *CApath=NULL,*CAfile=NULL;
d760 9
a768 9
	int badop=0,bugs=0;
	int ret=1;
	int off=0;
	int no_tmp_rsa=0,no_dhe=0,no_ecdhe=0,nocert=0;
	int state=0;
	const SSL_METHOD *meth=NULL;
	int socket_type=SOCK_STREAM;
	ENGINE *e=NULL;
	char *inrand=NULL;
d779 2
a780 2
        tlsextctx tlsextcbp = {NULL, NULL, SSL_TLSEXT_ERR_ALERT_WARNING};
# ifndef OPENSSL_NO_NEXTPROTONEG
d783 1
a783 1
# endif
d787 1
a787 1
	static char *psk_identity_hint=NULL;
d793 1
a793 1
	meth=SSLv23_server_method();
d795 2
a796 2
	local_argc=argc;
	local_argv=argv;
d802 1
a802 1
		bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
d807 1
a807 1
	verify_depth=0;
d809 1
a809 1
	s_nbio=0;
d811 1
a811 1
	s_nbio_test=0;
d816 31
a846 37
	while (argc >= 1)
		{
		if	((strcmp(*argv,"-port") == 0) ||
			 (strcmp(*argv,"-accept") == 0))
			{
			if (--argc < 1) goto bad;
			if (!extract_port(*(++argv),&port))
				goto bad;
			}
		else if	(strcmp(*argv,"-verify") == 0)
			{
			s_server_verify=SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE;
			if (--argc < 1) goto bad;
			verify_depth=atoi(*(++argv));
			BIO_printf(bio_err,"verify depth is %d\n",verify_depth);
			}
		else if	(strcmp(*argv,"-Verify") == 0)
			{
			s_server_verify=SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT|
				SSL_VERIFY_CLIENT_ONCE;
			if (--argc < 1) goto bad;
			verify_depth=atoi(*(++argv));
			BIO_printf(bio_err,"verify depth is %d, must return a certificate\n",verify_depth);
			}
		else if	(strcmp(*argv,"-context") == 0)
			{
			if (--argc < 1) goto bad;
			context= (unsigned char *)*(++argv);
			}
		else if	(strcmp(*argv,"-cert") == 0)
			{
			if (--argc < 1) goto bad;
			s_cert_file= *(++argv);
			}
		else if	(strcmp(*argv,"-certform") == 0)
			{
			if (--argc < 1) goto bad;
d848 7
a854 9
			}
		else if	(strcmp(*argv,"-key") == 0)
			{
			if (--argc < 1) goto bad;
			s_key_file= *(++argv);
			}
		else if	(strcmp(*argv,"-keyform") == 0)
			{
			if (--argc < 1) goto bad;
d856 3
a858 4
			}
		else if	(strcmp(*argv,"-pass") == 0)
			{
			if (--argc < 1) goto bad;
d860 3
a862 4
			}
		else if	(strcmp(*argv,"-dhparam") == 0)
			{
			if (--argc < 1) goto bad;
d864 5
a868 5
			}
#ifndef OPENSSL_NO_ECDH		
		else if	(strcmp(*argv,"-named_curve") == 0)
			{
			if (--argc < 1) goto bad;
d870 1
a870 1
			}
d872 3
a874 3
		else if	(strcmp(*argv,"-dcertform") == 0)
			{
			if (--argc < 1) goto bad;
d876 7
a882 9
			}
		else if	(strcmp(*argv,"-dcert") == 0)
			{
			if (--argc < 1) goto bad;
			s_dcert_file= *(++argv);
			}
		else if	(strcmp(*argv,"-dkeyform") == 0)
			{
			if (--argc < 1) goto bad;
d884 3
a886 4
			}
		else if	(strcmp(*argv,"-dpass") == 0)
			{
			if (--argc < 1) goto bad;
d888 11
a898 16
			}
		else if	(strcmp(*argv,"-dkey") == 0)
			{
			if (--argc < 1) goto bad;
			s_dkey_file= *(++argv);
			}
		else if (strcmp(*argv,"-nocert") == 0)
			{
			nocert=1;
			}
		else if	(strcmp(*argv,"-CApath") == 0)
			{
			if (--argc < 1) goto bad;
			CApath= *(++argv);
			}
		else if (strcmp(*argv,"-no_cache") == 0)
d900 1
a900 2
		else if (args_verify(&argv, &argc, &badarg, bio_err, &vpm))
			{
d904 1
a904 2
			}
		else if (strcmp(*argv,"-verify_return_error") == 0)
d906 33
a938 35
		else if	(strcmp(*argv,"-serverpref") == 0)
			{ off|=SSL_OP_CIPHER_SERVER_PREFERENCE; }
		else if (strcmp(*argv,"-legacy_renegotiation") == 0)
			off|=SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
		else if	(strcmp(*argv,"-cipher") == 0)
			{
			if (--argc < 1) goto bad;
			cipher= *(++argv);
			}
		else if	(strcmp(*argv,"-CAfile") == 0)
			{
			if (--argc < 1) goto bad;
			CAfile= *(++argv);
			}
#ifdef FIONBIO	
		else if	(strcmp(*argv,"-nbio") == 0)
			{ s_nbio=1; }
#endif
		else if	(strcmp(*argv,"-nbio_test") == 0)
			{
#ifdef FIONBIO	
			s_nbio=1;
#endif
			s_nbio_test=1;
			}
		else if	(strcmp(*argv,"-debug") == 0)
			{ s_debug=1; }
#ifndef OPENSSL_NO_TLSEXT
		else if	(strcmp(*argv,"-tlsextdebug") == 0)
			s_tlsextdebug=1;
		else if	(strcmp(*argv,"-status") == 0)
			s_tlsextstatus=1;
		else if	(strcmp(*argv,"-status_verbose") == 0)
			{
			s_tlsextstatus=1;
d940 4
a943 5
			}
		else if (!strcmp(*argv, "-status_timeout"))
			{
			s_tlsextstatus=1;
                        if (--argc < 1) goto bad;
d945 4
a948 5
			}
		else if (!strcmp(*argv, "-status_url"))
			{
			s_tlsextstatus=1;
                        if (--argc < 1) goto bad;
d950 4
a953 5
					&tlscstatp.host,
					&tlscstatp.port,
					&tlscstatp.path,
					&tlscstatp.use_ssl))
				{
a955 1
				}
d957 1
d959 19
a977 18
		else if	(strcmp(*argv,"-msg") == 0)
			{ s_msg=1; }
		else if	(strcmp(*argv,"-hack") == 0)
			{ hack=1; }
		else if	(strcmp(*argv,"-state") == 0)
			{ state=1; }
		else if	(strcmp(*argv,"-crlf") == 0)
			{ s_crlf=1; }
		else if	(strcmp(*argv,"-quiet") == 0)
			{ s_quiet=1; }
		else if	(strcmp(*argv,"-bugs") == 0)
			{ bugs=1; }
		else if	(strcmp(*argv,"-no_tmp_rsa") == 0)
			{ no_tmp_rsa=1; }
		else if	(strcmp(*argv,"-no_dhe") == 0)
			{ no_dhe=1; }
		else if	(strcmp(*argv,"-no_ecdhe") == 0)
			{ no_ecdhe=1; }
d979 5
a983 7
                else if (strcmp(*argv,"-psk_hint") == 0)
			{
                        if (--argc < 1) goto bad;
                        psk_identity_hint= *(++argv);
                        }
                else if (strcmp(*argv,"-psk") == 0)
			{
d986 5
a990 5
			if (--argc < 1) goto bad;
			psk_key=*(++argv);
			for (i=0; i<strlen(psk_key); i++)
				{
				if (isxdigit((unsigned char)psk_key[i]))
d992 1
a992 1
				BIO_printf(bio_err,"Not a hex number '%s'\n",*argv);
a993 1
				}
d995 1
d998 3
a1000 3
		else if (strcmp(*argv, "-srpvfile") == 0)
			{
			if (--argc < 1) goto bad;
d1003 3
a1005 4
			}
		else if (strcmp(*argv, "-srpuserseed") == 0)
			{
			if (--argc < 1) goto bad;
d1008 1
a1008 1
			}
d1010 33
a1042 30
		else if	(strcmp(*argv,"-www") == 0)
			{ www=1; }
		else if	(strcmp(*argv,"-WWW") == 0)
			{ www=2; }
		else if	(strcmp(*argv,"-HTTP") == 0)
			{ www=3; }
		else if	(strcmp(*argv,"-no_ssl2") == 0)
			{ off|=SSL_OP_NO_SSLv2; }
		else if	(strcmp(*argv,"-no_ssl3") == 0)
			{ off|=SSL_OP_NO_SSLv3; }
		else if	(strcmp(*argv,"-no_tls1") == 0)
			{ off|=SSL_OP_NO_TLSv1; }
		else if	(strcmp(*argv,"-no_tls1_1") == 0)
			{ off|=SSL_OP_NO_TLSv1_1; }
		else if	(strcmp(*argv,"-no_tls1_2") == 0)
			{ off|=SSL_OP_NO_TLSv1_2; }
		else if	(strcmp(*argv,"-no_comp") == 0)
			{ off|=SSL_OP_NO_COMPRESSION; }
#ifndef OPENSSL_NO_TLSEXT
		else if	(strcmp(*argv,"-no_ticket") == 0)
			{ off|=SSL_OP_NO_TICKET; }
#endif
		else if	(strcmp(*argv,"-ssl3") == 0)
			{ meth=SSLv3_server_method(); }
		else if	(strcmp(*argv,"-tls1") == 0)
			{ meth=TLSv1_server_method(); }
		else if	(strcmp(*argv,"-tls1_1") == 0)
			{ meth=TLSv1_1_server_method(); }
		else if	(strcmp(*argv,"-tls1_2") == 0)
			{ meth=TLSv1_2_server_method(); }
d1044 2
a1045 3
		else if	(strcmp(*argv,"-dtls1") == 0)
			{ 
			meth=DTLSv1_server_method();
d1047 1
a1047 2
			}
		else if (strcmp(*argv,"-timeout") == 0)
d1049 3
a1051 3
		else if (strcmp(*argv,"-mtu") == 0)
			{
			if (--argc < 1) goto bad;
d1053 1
a1053 2
			}
		else if (strcmp(*argv, "-chain") == 0)
d1056 3
a1058 3
		else if (strcmp(*argv, "-id_prefix") == 0)
			{
			if (--argc < 1) goto bad;
d1060 1
a1060 1
			}
d1062 31
a1092 33
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
			engine_id= *(++argv);
			}
#endif
		else if (strcmp(*argv,"-rand") == 0)
			{
			if (--argc < 1) goto bad;
			inrand= *(++argv);
			}
#ifndef OPENSSL_NO_TLSEXT
		else if (strcmp(*argv,"-servername") == 0)
			{
			if (--argc < 1) goto bad;
			tlsextcbp.servername= *(++argv);
			}
		else if (strcmp(*argv,"-servername_fatal") == 0)
			{ tlsextcbp.extension_error = SSL_TLSEXT_ERR_ALERT_FATAL; }
		else if	(strcmp(*argv,"-cert2") == 0)
			{
			if (--argc < 1) goto bad;
			s_cert_file2= *(++argv);
			}
		else if	(strcmp(*argv,"-key2") == 0)
			{
			if (--argc < 1) goto bad;
			s_key_file2= *(++argv);
			}
# ifndef OPENSSL_NO_NEXTPROTONEG
		else if	(strcmp(*argv,"-nextprotoneg") == 0)
			{
			if (--argc < 1) goto bad;
d1094 2
a1095 2
			}
# endif
d1098 3
a1100 3
		else if (strcmp(*argv,"-jpake") == 0)
			{
			if (--argc < 1) goto bad;
d1102 1
a1102 1
			}
d1105 3
a1107 3
		else if (strcmp(*argv,"-use_srtp") == 0)
			{
			if (--argc < 1) goto bad;
d1109 1
a1109 1
			}
d1111 13
a1123 15
		else if (strcmp(*argv,"-keymatexport") == 0)
			{
			if (--argc < 1) goto bad;
			keymatexportlabel= *(++argv);
			}
		else if (strcmp(*argv,"-keymatexportlen") == 0)
			{
			if (--argc < 1) goto bad;
			keymatexportlen=atoi(*(++argv));
			if (keymatexportlen == 0) goto bad;
			}
		else
			{
			BIO_printf(bio_err,"unknown option %s\n",*argv);
			badop=1;
d1125 1
a1125 1
			}
d1128 2
a1129 3
		}
	if (badop)
		{
d1133 1
a1133 2
		}

d1135 2
a1136 4
	if (jpake_secret)
		{
		if (psk_key)
			{
d1138 1
a1138 1
				   "Can't use JPAKE and PSK together\n");
d1140 1
a1140 1
			}
d1142 1
a1142 2
		if (cipher)
			{
d1145 1
a1145 1
			}
d1147 1
a1147 2
		}

d1154 1
a1154 1
        e = setup_engine(bio_err, engine_id, 1);
d1157 1
a1157 2
	if (!app_passwd(bio_err, passarg, dpassarg, &pass, &dpass))
		{
d1160 1
a1160 3
		}


d1168 1
a1168 2
	if (nocert == 0)
		{
d1170 2
a1171 3
		       "server certificate private key file");
		if (!s_key)
			{
d1174 3
a1176 1
			}
d1178 1
a1178 5
		s_cert = load_cert(bio_err,s_cert_file,s_cert_format,
			NULL, e, "server certificate file");

		if (!s_cert)
			{
d1181 1
a1181 2
			}

d1183 1
a1183 2
		if (tlsextcbp.servername) 
			{
d1185 2
a1186 3
				"second server certificate private key file");
			if (!s_key2)
				{
d1189 5
a1193 7
				}
			
			s_cert2 = load_cert(bio_err,s_cert_file2,s_cert_format,
				NULL, e, "second server certificate file");
			
			if (!s_cert2)
				{
a1195 1
				}
d1197 1
d1199 3
a1201 5
		}

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG) 
	if (next_proto_neg_in)
		{
d1207 1
a1207 3
		}
	else
		{
d1209 1
a1209 1
		}
d1213 1
a1213 2
	if (s_dcert_file)
		{
d1219 3
a1221 4
				0, dpass, e,
			       "second certificate private key file");
		if (!s_dkey)
			{
d1224 3
a1226 4
			}

		s_dcert = load_cert(bio_err,s_dcert_file,s_dcert_format,
				NULL, e, "second server certificate file");
d1228 1
a1228 2
		if (!s_dcert)
			{
a1230 2
			}

d1232 1
a1232 1

d1234 3
a1236 4
		&& !RAND_status())
		{
		BIO_printf(bio_err,"warning, not much extra random data, consider using the -rand option\n");
		}
d1238 2
a1239 2
		BIO_printf(bio_err,"%ld semi-random bytes loaded\n",
			app_RAND_load_files(inrand));
d1241 4
a1244 8
	if (bio_s_out == NULL)
		{
		if (s_quiet && !s_debug && !s_msg)
			{
			bio_s_out=BIO_new(BIO_s_null());
			}
		else
			{
d1246 1
a1246 2
				bio_s_out=BIO_new_fp(stdout,BIO_NOCLOSE);
			}
d1248 1
a1248 1

d1252 5
a1256 5
		{
		s_cert_file=NULL;
		s_key_file=NULL;
		s_dcert_file=NULL;
		s_dkey_file=NULL;
d1258 2
a1259 2
		s_cert_file2=NULL;
		s_key_file2=NULL;
d1261 3
a1263 5
		}

	ctx=SSL_CTX_new(meth);
	if (ctx == NULL)
		{
d1266 3
a1268 4
		}
	if (session_id_prefix)
		{
		if(strlen(session_id_prefix) >= 32)
d1270 2
a1271 2
"warning: id_prefix is too long, only one new session will be possible\n");
		else if(strlen(session_id_prefix) >= 16)
d1273 3
a1275 4
"warning: id_prefix is too long if you use SSLv2\n");
		if(!SSL_CTX_set_generate_session_id(ctx, generate_session_id))
			{
			BIO_printf(bio_err,"error setting 'id_prefix'\n");
a1277 2
			}
		BIO_printf(bio_err,"id_prefix '%s' set.\n", session_id_prefix);
d1279 11
a1289 6
	SSL_CTX_set_quiet_shutdown(ctx,1);
	if (bugs) SSL_CTX_set_options(ctx,SSL_OP_ALL);
	if (hack) SSL_CTX_set_options(ctx,SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);
	SSL_CTX_set_options(ctx,off);
	/* DTLS: partial reads end up discarding unread UDP bytes :-( 
	 * Setting read ahead solves this problem.
d1291 2
a1292 1
	if (socket_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx, 1);
d1294 2
a1295 1
	if (state) SSL_CTX_set_info_callback(ctx,apps_ssl_info_callback);
d1299 1
a1299 1
		SSL_CTX_sess_set_cache_size(ctx,128);
d1307 2
a1308 1
	if (cipher == NULL) cipher=getenv("SSL_CIPHER");
d1312 2
a1313 3
	if (s_cert_file == NULL)
		{
		BIO_printf(bio_err,"You must specify a certificate file for the server to use\n");
d1315 1
a1315 1
		}
d1318 2
a1319 3
	if ((!SSL_CTX_load_verify_locations(ctx,CAfile,CApath)) ||
		(!SSL_CTX_set_default_verify_paths(ctx)))
		{
d1323 1
a1323 1
		}
d1328 3
a1330 5
	if (s_cert2)
		{
		ctx2=SSL_CTX_new(meth);
		if (ctx2 == NULL)
			{
a1332 1
			}
d1334 6
a1339 8
	
	if (ctx2)
		{
		BIO_printf(bio_s_out,"Setting secondary ctx parameters\n");

		if (session_id_prefix)
			{
			if(strlen(session_id_prefix) >= 32)
d1341 2
a1342 2
					"warning: id_prefix is too long, only one new session will be possible\n");
			else if(strlen(session_id_prefix) >= 16)
d1344 3
a1346 4
					"warning: id_prefix is too long if you use SSLv2\n");
			if(!SSL_CTX_set_generate_session_id(ctx2, generate_session_id))
				{
				BIO_printf(bio_err,"error setting 'id_prefix'\n");
a1348 2
				}
			BIO_printf(bio_err,"id_prefix '%s' set.\n", session_id_prefix);
d1350 10
a1359 5
		SSL_CTX_set_quiet_shutdown(ctx2,1);
		if (bugs) SSL_CTX_set_options(ctx2,SSL_OP_ALL);
		if (hack) SSL_CTX_set_options(ctx2,SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);
		SSL_CTX_set_options(ctx2,off);
		/* DTLS: partial reads end up discarding unread UDP bytes :-( 
d1362 2
a1363 1
		if (socket_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx2, 1);
d1365 2
a1366 1
		if (state) SSL_CTX_set_info_callback(ctx2,apps_ssl_info_callback);
d1369 1
a1369 1
			SSL_CTX_set_session_cache_mode(ctx2,SSL_SESS_CACHE_OFF);
d1371 1
a1371 1
			SSL_CTX_sess_set_cache_size(ctx2,128);
d1373 2
a1374 3
		if ((!SSL_CTX_load_verify_locations(ctx2,CAfile,CApath)) ||
			(!SSL_CTX_set_default_verify_paths(ctx2)))
			{
d1376 1
a1376 1
			}
d1379 2
a1380 3
		}

# ifndef OPENSSL_NO_NEXTPROTONEG
d1383 2
a1384 2
# endif
#endif 
d1387 2
a1388 3
	if (!no_dhe)
		{
		DH *dh=NULL;
d1395 20
a1414 3
		if (dh != NULL)
			{
			BIO_printf(bio_s_out,"Setting temp DH parameters\n");
d1416 3
a1418 26
		else
			{
			BIO_printf(bio_s_out,"Using default temp DH parameters\n");
			dh=get_dh512();
			}
		(void)BIO_flush(bio_s_out);

		SSL_CTX_set_tmp_dh(ctx,dh);
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2)
			{
			if (!dhfile)
				{ 
				DH *dh2=load_dh_param(s_cert_file2);
				if (dh2 != NULL)
					{
					BIO_printf(bio_s_out,"Setting temp DH parameters\n");
					(void)BIO_flush(bio_s_out);

					DH_free(dh);
					dh = dh2;
					}
				}
			SSL_CTX_set_tmp_dh(ctx2,dh);
			}
#endif
d1420 1
a1420 1
		}
d1424 2
a1425 3
	if (!no_ecdhe)
		{
		EC_KEY *ecdh=NULL;
d1427 1
a1427 2
		if (named_curve)
			{
d1430 3
a1432 4
			if (nid == 0)
				{
				BIO_printf(bio_err, "unknown curve name (%s)\n", 
					named_curve);
d1434 1
a1434 1
				}
d1436 3
a1438 4
			if (ecdh == NULL)
				{
				BIO_printf(bio_err, "unable to create curve (%s)\n", 
					named_curve);
a1439 1
				}
d1441 5
a1445 8

		if (ecdh != NULL)
			{
			BIO_printf(bio_s_out,"Setting temp ECDH parameters\n");
			}
		else
			{
			BIO_printf(bio_s_out,"Using default temp ECDH parameters\n");
d1447 1
a1447 2
			if (ecdh == NULL) 
				{
a1449 1
				}
d1451 2
a1452 1
		(void)BIO_flush(bio_s_out);
d1454 1
a1454 1
		SSL_CTX_set_tmp_ecdh(ctx,ecdh);
d1456 2
a1457 2
		if (ctx2) 
			SSL_CTX_set_tmp_ecdh(ctx2,ecdh);
d1460 1
a1460 1
		}
d1462 1
a1462 1
	
d1466 2
a1467 2
	if (ctx2 && !set_cert_key_stuff(ctx2,s_cert2,s_key2))
		goto end; 
d1469 1
a1469 2
	if (s_dcert != NULL)
		{
d1472 1
a1472 2
		}

d1475 7
a1481 8
	if (!no_tmp_rsa)
		{
		SSL_CTX_set_tmp_rsa_callback(ctx,tmp_rsa_cb);
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2) 
			SSL_CTX_set_tmp_rsa_callback(ctx2,tmp_rsa_cb);
#endif		
		}
d1483 1
a1483 2
	if (!no_tmp_rsa && SSL_CTX_need_tmp_RSA(ctx))
		{
d1486 1
a1486 1
		BIO_printf(bio_s_out,"Generating temp (512 bit) RSA key...");
d1489 1
a1489 1
		rsa=RSA_generate_key(512,RSA_F4,NULL);
d1491 1
a1491 2
		if (!SSL_CTX_set_tmp_rsa(ctx,rsa))
			{
d1494 6
d1501 1
a1501 9
#ifndef OPENSSL_NO_TLSEXT
			if (ctx2)
				{
				if (!SSL_CTX_set_tmp_rsa(ctx2,rsa))
					{
					ERR_print_errors(bio_err);
					goto end;
					}
				}
d1504 2
a1505 2
		BIO_printf(bio_s_out,"\n");
		}
d1515 1
a1515 1
		{
d1519 3
a1521 5
		}

	if (!SSL_CTX_use_psk_identity_hint(ctx, psk_identity_hint))
		{
		BIO_printf(bio_err,"error setting PSK identity hint to context\n");
d1524 1
a1524 1
		}
d1527 3
a1529 5
	if (cipher != NULL)
		{
		if(!SSL_CTX_set_cipher_list(ctx,cipher))
			{
			BIO_printf(bio_err,"error setting cipher list\n");
d1532 1
a1532 1
			}
d1534 2
a1535 3
		if (ctx2 && !SSL_CTX_set_cipher_list(ctx2,cipher))
			{
			BIO_printf(bio_err,"error setting cipher list\n");
d1538 1
a1538 1
			}
d1540 4
a1543 4
		}
	SSL_CTX_set_verify(ctx,s_server_verify,verify_callback);
	SSL_CTX_set_session_id_context(ctx,(void*)&s_server_session_id_context,
		sizeof s_server_session_id_context);
d1550 4
a1553 5
	if (ctx2)
		{
		SSL_CTX_set_verify(ctx2,s_server_verify,verify_callback);
		SSL_CTX_set_session_id_context(ctx2,(void*)&s_server_session_id_context,
			sizeof s_server_session_id_context);
d1560 1
a1560 1
		}
d1564 1
a1564 2
	if (srp_verifier_file != NULL)
		{
d1568 1
a1568 2
		if ((ret = SRP_VBASE_init(srp_callback_parm.vb, srp_verifier_file)) != SRP_NO_ERROR)
			{
d1570 6
a1575 6
				   "Cannot initialize SRP verifier file \"%s\":ret=%d\n",
				   srp_verifier_file, ret);
				goto end;
			}
		SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE,verify_callback);
		SSL_CTX_set_srp_cb_arg(ctx, &srp_callback_parm);  			
d1577 1
a1577 2
		}
	else
d1579 2
a1580 3
	if (CAfile != NULL)
		{
		SSL_CTX_set_client_CA_list(ctx,SSL_load_client_CA_file(CAfile));
d1582 2
a1583 2
		if (ctx2) 
			SSL_CTX_set_client_CA_list(ctx2,SSL_load_client_CA_file(CAfile));
d1585 3
a1587 4
		}

	BIO_printf(bio_s_out,"ACCEPT\n");
	(void)BIO_flush(bio_s_out);
d1589 1
a1589 1
		do_server(port,socket_type,&accept_socket,www_body, context);
d1591 3
a1593 3
		do_server(port,socket_type,&accept_socket,sv_body, context);
	print_stats(bio_s_out,ctx);
	ret=0;
d1595 2
a1596 1
	if (ctx != NULL) SSL_CTX_free(ctx);
d1618 2
a1619 1
	if (ctx2 != NULL) SSL_CTX_free(ctx2);
d1625 4
a1628 5
	if (bio_s_out != NULL)
		{
        BIO_free(bio_s_out);
		bio_s_out=NULL;
		}
d1630 2
a1631 2
	return(ret);
	}
d1633 25
a1657 24
static void print_stats(BIO *bio, SSL_CTX *ssl_ctx)
	{
	BIO_printf(bio,"%4ld items in the session cache\n",
		SSL_CTX_sess_number(ssl_ctx));
	BIO_printf(bio,"%4ld client connects (SSL_connect())\n",
		SSL_CTX_sess_connect(ssl_ctx));
	BIO_printf(bio,"%4ld client renegotiates (SSL_connect())\n",
		SSL_CTX_sess_connect_renegotiate(ssl_ctx));
	BIO_printf(bio,"%4ld client connects that finished\n",
		SSL_CTX_sess_connect_good(ssl_ctx));
	BIO_printf(bio,"%4ld server accepts (SSL_accept())\n",
		SSL_CTX_sess_accept(ssl_ctx));
	BIO_printf(bio,"%4ld server renegotiates (SSL_accept())\n",
		SSL_CTX_sess_accept_renegotiate(ssl_ctx));
	BIO_printf(bio,"%4ld server accepts that finished\n",
		SSL_CTX_sess_accept_good(ssl_ctx));
	BIO_printf(bio,"%4ld session cache hits\n",SSL_CTX_sess_hits(ssl_ctx));
	BIO_printf(bio,"%4ld session cache misses\n",SSL_CTX_sess_misses(ssl_ctx));
	BIO_printf(bio,"%4ld session cache timeouts\n",SSL_CTX_sess_timeouts(ssl_ctx));
	BIO_printf(bio,"%4ld callback cache hits\n",SSL_CTX_sess_cb_hits(ssl_ctx));
	BIO_printf(bio,"%4ld cache full overflows (%ld allowed)\n",
		SSL_CTX_sess_cache_full(ssl_ctx),
		SSL_CTX_sess_get_cache_size(ssl_ctx));
	}
d1659 4
a1662 3
static int sv_body(char *hostname, int s, unsigned char *context)
	{
	char *buf=NULL;
d1664 2
a1665 2
	int ret=1,width;
	int k,i;
d1667 1
a1667 1
	SSL *con=NULL;
d1675 2
a1676 3
	if ((buf=malloc(bufsize)) == NULL)
		{
		BIO_printf(bio_err,"out of memory\n");
d1678 4
a1681 5
		}
#ifdef FIONBIO	
	if (s_nbio)
		{
		unsigned long sl=1;
d1684 2
a1685 2
			BIO_printf(bio_err,"turning on non blocking io\n");
		if (BIO_socket_ioctl(s,FIONBIO,&sl) < 0)
d1687 1
a1687 1
		}
d1691 1
a1691 1
		con=SSL_new(ctx);
d1693 3
a1695 4
	if (s_tlsextdebug)
		{
		SSL_set_tlsext_debug_callback(con, tlsext_cb);
		SSL_set_tlsext_debug_arg(con, bio_s_out);
d1697 4
a1700 5
	if (s_tlsextstatus)
		{
		SSL_CTX_set_tlsext_status_cb(ctx, cert_status_cb);
		tlscstatp.err = bio_err;
		SSL_CTX_set_tlsext_status_arg(ctx, &tlscstatp);
d1704 1
a1704 2
		if ((kctx = kssl_ctx_new()) != NULL)
                        {
d1706 7
a1712 7
                        kssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);
                        kssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);
                        }
#endif	/* OPENSSL_NO_KRB5 */
		if(context)
		      SSL_set_session_id_context(con, context,
						 strlen((char *)context));
d1721 1
a1721 2
	if (SSL_version(con) == DTLS1_VERSION)
		{
d1723 1
a1723 1
		sbio=BIO_new_dgram(s,BIO_NOCLOSE);
d1725 1
a1725 2
		if (enable_timeouts)
			{
d1729 1
a1729 1
			
d1733 2
a1734 4
			}

		if (socket_mtu > 28)
			{
d1737 1
a1737 2
			}
		else
d1741 4
a1744 5
        /* turn on cookie exchange */
        SSL_set_options(con, SSL_OP_COOKIE_EXCHANGE);
		}
	else
		sbio=BIO_new_socket(s,BIO_NOCLOSE);
d1746 1
a1746 2
	if (s_nbio_test)
		{
d1749 3
a1751 3
		test=BIO_new(BIO_f_nbio_test());
		sbio=BIO_push(test,sbio);
		}
d1753 1
a1753 1
	if(jpake_secret)
d1757 1
a1757 1
	SSL_set_bio(con,sbio,sbio);
d1761 1
a1761 2
	if (s_debug)
		{
d1763 4
a1766 5
		BIO_set_callback(SSL_get_rbio(con),bio_dump_callback);
		BIO_set_callback_arg(SSL_get_rbio(con),(char *)bio_s_out);
		}
	if (s_msg)
		{
d1769 1
a1769 1
		}
d1771 1
a1771 2
	if (s_tlsextdebug)
		{
d1774 1
a1774 1
		}
d1777 2
a1778 3
	width=s+1;
	for (;;)
		{
d1785 1
a1785 2
		if (!read_from_sslcon)
			{
d1787 9
a1795 7
			openssl_fdset(fileno(stdin),&readfds);
			openssl_fdset(s,&readfds);
			/* Note: under VMS with SOCKETSHR the second parameter is
			 * currently of type (int *) whereas under other systems
			 * it is (void *) if you don't have a cast it will choke
			 * the compiler: if you do have a cast then you can either
			 * go for (int *) or (void *).
d1798 1
a1798 1
				DTLSv1_get_timeout(con, &timeout))
d1803 1
a1803 1
			i=select(width,(void *)&readfds,NULL,NULL,timeoutp);
d1805 6
a1810 7
			if ((SSL_version(con) == DTLS1_VERSION) && DTLSv1_handle_timeout(con) > 0)
				{
				BIO_printf(bio_err,"TIMEOUT occured\n");
				}

			if (i <= 0) continue;
			if (FD_ISSET(fileno(stdin),&readfds))
d1812 1
a1812 1
			if (FD_ISSET(s,&readfds))
d1814 3
a1816 5
			}
		if (read_from_terminal)
			{
			if (s_crlf)
				{
d1819 1
a1819 1
				i=raw_read_stdin(buf, bufsize/2);
d1825 3
a1827 5
				for (j = i-1; j >= 0; j--)
					{
					buf[j+lf_num] = buf[j];
					if (buf[j] == '\n')
						{
d1830 1
a1830 2
						buf[j+lf_num] = '\r';
						}
d1832 1
d1834 5
a1838 8
				}
			else
				i=raw_read_stdin(buf,bufsize);
			if (!s_quiet)
				{
				if ((i <= 0) || (buf[0] == 'Q'))
					{
					BIO_printf(bio_s_out,"DONE\n");
d1842 1
a1842 1
					ret= -11;
d1844 3
a1846 4
					}
				if ((i <= 0) || (buf[0] == 'q'))
					{
					BIO_printf(bio_s_out,"DONE\n");
d1848 1
a1848 1
			                        shutdown(s, SHUT_RD);
d1851 3
a1853 2
	/*				close_accept_socket();
					ret= -11;*/
d1855 3
a1857 4
					}
				if ((buf[0] == 'r') && 
					((buf[1] == '\n') || (buf[1] == '\r')))
					{
d1859 3
a1861 3
					i=SSL_do_handshake(con);
					printf("SSL_do_handshake -> %d\n",i);
					i=0; /*13; */
d1863 5
a1867 2
					/* strcpy(buf,"server side RE-NEGOTIATE\n"); */
					}
d1869 1
a1869 2
					((buf[1] == '\n') || (buf[1] == '\r')))
					{
d1871 1
a1871 1
						SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE,NULL);
d1873 3
a1875 3
					i=SSL_do_handshake(con);
					printf("SSL_do_handshake -> %d\n",i);
					i=0; /* 13; */
d1877 12
a1888 11
					/* strcpy(buf,"server side RE-NEGOTIATE asking for client cert\n"); */
					}
				if (buf[0] == 'P')
					{
					static const char *str="Lets print some clear text\n";
					BIO_write(SSL_get_wbio(con),str,strlen(str));
					}
				if (buf[0] == 'S')
					{
					print_stats(bio_s_out,SSL_get_SSL_CTX(con));
					}
d1890 3
a1892 3
			l=k=0;
			for (;;)
				{
d1895 7
a1901 1
{ static count=0; if (++count == 100) { count=0; SSL_renegotiate(con); } }
d1903 1
a1903 1
				k=SSL_write(con,&(buf[l]),(unsigned int)i);
d1905 9
a1913 10
				while (SSL_get_error(con,k) == SSL_ERROR_WANT_X509_LOOKUP)
					{
					BIO_printf(bio_s_out,"LOOKUP renego during write\n");
					srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
					if (srp_callback_parm.user) 
						BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
					else 
						BIO_printf(bio_s_out,"LOOKUP not successful\n");
						k=SSL_write(con,&(buf[l]),(unsigned int)i);
					}
d1915 1
a1915 2
				switch (SSL_get_error(con,k))
					{
d1921 1
a1921 1
					BIO_printf(bio_s_out,"Write BLOCK\n");
d1925 1
a1925 1
					BIO_printf(bio_s_out,"ERROR\n");
d1927 1
a1927 1
					ret=1;
d1931 2
a1932 2
					BIO_printf(bio_s_out,"DONE\n");
					ret=1;
a1933 4
					}
				l+=k;
				i-=k;
				if (i <= 0) break;
d1935 4
d1940 7
a1946 9
		if (read_from_sslcon)
			{
			if (!SSL_is_init_finished(con))
				{
				i=init_ssl_connection(con);
				
				if (i < 0)
					{
					ret=0;
d1948 2
a1949 4
					}
				else if (i == 0)
					{
					ret=1;
a1950 1
					}
d1952 3
a1954 4
			else
				{
again:	
				i=SSL_read(con,(char *)buf,bufsize);
d1956 9
a1964 10
				while (SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP)
					{
					BIO_printf(bio_s_out,"LOOKUP renego during read\n");
					srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
					if (srp_callback_parm.user) 
						BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
					else 
						BIO_printf(bio_s_out,"LOOKUP not successful\n");
					i=SSL_read(con,(char *)buf,bufsize);
					}
d1966 1
a1966 2
				switch (SSL_get_error(con,i))
					{
d1969 3
a1971 2
						(unsigned int)i);
					if (SSL_pending(con)) goto again;
d1975 1
a1975 1
					BIO_printf(bio_s_out,"Read BLOCK\n");
d1979 1
a1979 1
					BIO_printf(bio_s_out,"ERROR\n");
d1981 1
a1981 1
					ret=1;
d1984 2
a1985 2
					BIO_printf(bio_s_out,"DONE\n");
					ret=1;
a1986 1
					}
d1990 1
d1992 2
a1993 3
	if (con != NULL)
		{
		BIO_printf(bio_s_out,"shutting down SSL\n");
d1995 1
a1995 1
		SSL_set_shutdown(con,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
d2000 4
a2003 5
		}
	BIO_printf(bio_s_out,"CONNECTION CLOSED\n");
	if (buf != NULL)
		{
		OPENSSL_cleanse(buf,bufsize);
d2005 1
a2005 1
		}
d2007 3
a2009 3
		BIO_printf(bio_s_out,"ACCEPT\n");
	return(ret);
	}
d2011 5
a2015 5
static void close_accept_socket(void)
	{
	BIO_printf(bio_err,"shutdown accept socket\n");
	if (accept_socket >= 0)
		{
a2017 1
		}
d2019 1
d2021 3
a2023 2
static int init_ssl_connection(SSL *con)
	{
d2039 1
a2039 1
	i=SSL_accept(con);
d2041 5
a2045 26
	while (i <= 0 &&  SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP) 
		{
			BIO_printf(bio_s_out,"LOOKUP during accept %s\n",srp_callback_parm.login);
			srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
			if (srp_callback_parm.user) 
				BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
			else 
				BIO_printf(bio_s_out,"LOOKUP not successful\n");
			i=SSL_accept(con);
		}
#endif
	if (i <= 0)
		{
		if (BIO_sock_should_retry(i))
			{
			BIO_printf(bio_s_out,"DELAY\n");
			return(1);
			}

		BIO_printf(bio_err,"ERROR\n");
		verify_error=SSL_get_verify_result(con);
		if (verify_error != X509_V_OK)
			{
			BIO_printf(bio_err,"verify error:%s\n",
				X509_verify_cert_error_string(verify_error));
			}
d2047 15
d2063 3
a2065 4
		return(0);
		}

	PEM_write_bio_SSL_SESSION(bio_s_out,SSL_get_session(con));
d2067 8
a2074 9
	peer=SSL_get_peer_certificate(con);
	if (peer != NULL)
		{
		BIO_printf(bio_s_out,"Client certificate\n");
		PEM_write_bio_X509(bio_s_out,peer);
		X509_NAME_oneline(X509_get_subject_name(peer),buf,sizeof buf);
		BIO_printf(bio_s_out,"subject=%s\n",buf);
		X509_NAME_oneline(X509_get_issuer_name(peer),buf,sizeof buf);
		BIO_printf(bio_s_out,"issuer=%s\n",buf);
d2076 5
a2080 6
		}

	if (SSL_get_shared_ciphers(con,buf,sizeof buf) != NULL)
		BIO_printf(bio_s_out,"Shared ciphers:%s\n",buf);
	str=SSL_CIPHER_get_name(SSL_get_current_cipher(con));
	BIO_printf(bio_s_out,"CIPHER is %s\n",(str != NULL)?str:"(NONE)");
d2084 2
a2085 3
	if (next_proto_neg)
		{
		BIO_printf(bio_s_out,"NEXTPROTO is ");
d2088 1
a2088 1
		}
d2092 2
a2093 2
	SRTP_PROTECTION_PROFILE *srtp_profile
	  = SSL_get_selected_srtp_profile(con);
d2095 3
a2097 3
	if(srtp_profile)
		BIO_printf(bio_s_out,"SRTP Extension negotiated, profile=%s\n",
			   srtp_profile->name);
d2100 4
a2103 3
	if (SSL_cache_hit(con)) BIO_printf(bio_s_out,"Reused session-id\n");
	if (SSL_ctrl(con,SSL_CTRL_GET_FLAGS,0,NULL) &
		TLS1_FLAGS_TLS_PADDING_BUG)
d2105 1
a2105 1
			   "Peer has incorrect TLSv1 block padding\n");
d2108 5
a2112 6
	if (client_princ != NULL)
		{
		BIO_printf(bio_s_out,"Kerberos peer principal is %s\n",
								client_princ);
		}
#endif /* OPENSSL_NO_KRB5 */
d2114 2
a2115 3
		      SSL_get_secure_renegotiation_support(con) ? "" : " NOT");
	if (keymatexportlabel != NULL)
		{
d2119 1
a2119 1
			   keymatexportlen);
d2121 1
a2121 2
		if (exportedkeymat != NULL)
			{
d2123 4
a2126 5
						        keymatexportlen,
						        keymatexportlabel,
						        strlen(keymatexportlabel),
						        NULL, 0, 0))
				{
d2128 1
a2128 3
				}
			else
				{
d2130 1
a2130 1
				for (i=0; i<keymatexportlen; i++)
d2132 1
a2132 1
						   exportedkeymat[i]);
d2134 1
a2134 1
				}
a2135 1
			}
a2136 2

	return(1);
d2138 2
d2142 4
a2145 3
static DH *load_dh_param(const char *dhfile)
	{
	DH *ret=NULL;
d2148 1
a2148 1
	if ((bio=BIO_new_file(dhfile,"r")) == NULL)
d2150 1
a2150 1
	ret=PEM_read_bio_DHparams(bio,NULL,NULL,NULL);
d2152 4
a2155 3
	if (bio != NULL) BIO_free(bio);
	return(ret);
	}
d2158 1
a2158 1
	char *client_princ;
d2162 3
a2164 2
static int load_CA(SSL_CTX *ctx, char *file)
	{
d2166 1
a2166 1
	X509 *x=NULL;
d2168 2
a2169 2
	if ((in=fopen(file,"r")) == NULL)
		return(0);
d2171 2
a2172 3
	for (;;)
		{
		if (PEM_read_X509(in,&x,NULL) == NULL)
d2174 4
a2177 3
		SSL_CTX_add_client_CA(ctx,x);
		}
	if (x != NULL) X509_free(x);
d2179 2
a2180 2
	return(1);
	}
d2183 6
a2188 5
static int www_body(char *hostname, int s, unsigned char *context)
	{
	char *buf=NULL;
	int ret=1;
	int i,j,k,dot;
d2191 1
a2191 1
	BIO *io,*ssl_bio,*sbio;
d2196 11
a2206 10
	buf=malloc(bufsize);
	if (buf == NULL) return(0);
	io=BIO_new(BIO_f_buffer());
	ssl_bio=BIO_new(BIO_f_ssl());
	if ((io == NULL) || (ssl_bio == NULL)) goto err;

#ifdef FIONBIO	
	if (s_nbio)
		{
		unsigned long sl=1;
d2209 2
a2210 2
			BIO_printf(bio_err,"turning on non blocking io\n");
		if (BIO_socket_ioctl(s,FIONBIO,&sl) < 0)
d2212 1
a2212 1
		}
d2216 2
a2217 1
	if (!BIO_set_write_buffer_size(io,bufsize)) goto err;
d2219 2
a2220 1
	if ((con=SSL_new(ctx)) == NULL) goto err;
d2222 4
a2225 5
		if (s_tlsextdebug)
			{
			SSL_set_tlsext_debug_callback(con, tlsext_cb);
			SSL_set_tlsext_debug_arg(con, bio_s_out);
			}
d2228 1
a2228 2
	if ((kctx = kssl_ctx_new()) != NULL)
		{
d2231 8
a2238 8
		}
#endif	/* OPENSSL_NO_KRB5 */
	if(context) SSL_set_session_id_context(con, context,
					       strlen((char *)context));

	sbio=BIO_new_socket(s,BIO_NOCLOSE);
	if (s_nbio_test)
		{
d2241 4
a2244 4
		test=BIO_new(BIO_f_nbio_test());
		sbio=BIO_push(test,sbio);
		}
	SSL_set_bio(con,sbio,sbio);
d2248 2
a2249 2
	BIO_set_ssl(ssl_bio,con,BIO_CLOSE);
	BIO_push(io,ssl_bio);
d2251 1
a2251 2
	if (s_debug)
		{
d2253 4
a2256 5
		BIO_set_callback(SSL_get_rbio(con),bio_dump_callback);
		BIO_set_callback_arg(SSL_get_rbio(con),(char *)bio_s_out);
		}
	if (s_msg)
		{
d2259 4
a2262 7
		}

	for (;;)
		{
		if (hack)
			{
			i=SSL_accept(con);
d2264 9
a2272 10
			while (i <= 0 &&  SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP) 
		{
			BIO_printf(bio_s_out,"LOOKUP during accept %s\n",srp_callback_parm.login);
			srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
			if (srp_callback_parm.user) 
				BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
			else 
				BIO_printf(bio_s_out,"LOOKUP not successful\n");
			i=SSL_accept(con);
		}
d2274 1
a2274 2
			switch (SSL_get_error(con,i))
				{
d2284 1
a2284 1
				ret=1;
d2287 1
a2287 1
				}
d2290 5
a2294 8
			SSL_write(con,NULL,0);
			}

		i=BIO_gets(io,buf,bufsize-1);
		if (i < 0) /* error */
			{
			if (!BIO_should_retry(io))
				{
d2298 2
a2299 4
				}
			else
				{
				BIO_printf(bio_s_out,"read R BLOCK\n");
a2301 1
				}
d2303 2
a2304 3
		else if (i == 0) /* end of input */
			{
			ret=1;
d2306 1
a2306 2
			}

d2308 2
a2309 3
		if (	((www == 1) && (strncmp("GET ",buf,4) == 0)) ||
			((www == 2) && (strncmp("GET /stats ",buf,11) == 0)))
			{
d2312 2
a2313 2
			STACK_OF(SSL_CIPHER) *sk;
			static const char *space="                          ";
d2315 3
a2317 3
			BIO_puts(io,"HTTP/1.0 200 ok\r\nContent-type: text/html\r\n\r\n");
			BIO_puts(io,"<HTML><BODY BGCOLOR=\"#ffffff\">\n");
			BIO_puts(io,"<pre>\n");
d2319 6
a2324 7
			BIO_puts(io,"\n");
			for (i=0; i<local_argc; i++)
				{
				BIO_puts(io,local_argv[i]);
				BIO_write(io," ",1);
				}
			BIO_puts(io,"\n");
d2327 27
a2353 29
				"Secure Renegotiation IS%s supported\n",
		      		SSL_get_secure_renegotiation_support(con) ?
							"" : " NOT");

			/* The following is evil and should not really
			 * be done */
			BIO_printf(io,"Ciphers supported in s_server binary\n");
			sk=SSL_get_ciphers(con);
			j=sk_SSL_CIPHER_num(sk);
			for (i=0; i<j; i++)
				{
				c=sk_SSL_CIPHER_value(sk,i);
				BIO_printf(io,"%-11s:%-25s",
					SSL_CIPHER_get_version(c),
					SSL_CIPHER_get_name(c));
				if ((((i+1)%2) == 0) && (i+1 != j))
					BIO_puts(io,"\n");
				}
			BIO_puts(io,"\n");
			p=SSL_get_shared_ciphers(con,buf,bufsize);
			if (p != NULL)
				{
				BIO_printf(io,"---\nCiphers common between both SSL end points:\n");
				j=i=0;
				while (*p)
					{
					if (*p == ':')
						{
						BIO_write(io,space,26-j);
d2355 4
a2358 6
						j=0;
						BIO_write(io,((i%3)?" ":"\n"),1);
						}
					else
						{
						BIO_write(io,p,1);
d2360 1
a2360 1
						}
a2361 2
					}
				BIO_puts(io,"\n");
d2363 21
a2383 21
			BIO_printf(io,(SSL_cache_hit(con)
				?"---\nReused, "
				:"---\nNew, "));
			c=SSL_get_current_cipher(con);
			BIO_printf(io,"%s, Cipher is %s\n",
				SSL_CIPHER_get_version(c),
				SSL_CIPHER_get_name(c));
			SSL_SESSION_print(io,SSL_get_session(con));
			BIO_printf(io,"---\n");
			print_stats(io,SSL_get_SSL_CTX(con));
			BIO_printf(io,"---\n");
			peer=SSL_get_peer_certificate(con);
			if (peer != NULL)
				{
				BIO_printf(io,"Client certificate\n");
				X509_print(io,peer);
				PEM_write_bio_X509(io,peer);
				}
			else
				BIO_puts(io,"no client certificate available\n");
			BIO_puts(io,"</BODY></HTML>\r\n\r\n");
d2385 2
a2386 4
			}
		else if ((www == 2 || www == 3)
                         && (strncmp("GET /",buf,5) == 0))
			{
d2388 2
a2389 2
			char *p,*e;
			static const char *text="HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n";
d2392 1
a2392 1
			p= &(buf[5]);
d2395 1
a2395 2
			for (e=p; *e != '\0'; e++)
				{
d2399 1
a2399 2
				switch (dot)
					{
d2409 1
a2409 1
					}
d2412 3
a2414 2
				}
			dot = (dot == 3) || (dot == -1); /* filename contains ".." component */
d2416 3
a2418 4
			if (*e == '\0')
				{
				BIO_puts(io,text);
				BIO_printf(io,"'%s' is an invalid file name\r\n",p);
d2420 2
a2421 2
				}
			*e='\0';
d2423 3
a2425 4
			if (dot)
				{
				BIO_puts(io,text);
				BIO_printf(io,"'%s' contains '..' reference\r\n",p);
d2427 4
a2430 6
				}

			if (*p == '/')
				{
				BIO_puts(io,text);
				BIO_printf(io,"'%s' is an invalid path\r\n",p);
d2432 1
a2432 2
				}

d2436 1
a2436 1
				strcat(p,"index.html");
d2440 3
a2442 4
			if (app_isdir(p)>0)
				{
#if 0 /* must check buffer size */
				strcat(p,"/index.html");
d2444 2
a2445 2
				BIO_puts(io,text);
				BIO_printf(io,"'%s' is a directory\r\n",p);
d2448 4
a2451 6
				}

			if ((file=BIO_new_file(p,"r")) == NULL)
				{
				BIO_puts(io,text);
				BIO_printf(io,"Error opening '%s'\r\n",p);
d2454 1
a2454 2
				}

d2456 1
a2456 1
				BIO_printf(bio_err,"FILE:%s\n",p);
d2458 9
a2466 10
                        if (www == 2)
                                {
                                i=strlen(p);
                                if (	((i > 5) && (strcmp(&(p[i-5]),".html") == 0)) ||
                                        ((i > 4) && (strcmp(&(p[i-4]),".php") == 0)) ||
                                        ((i > 4) && (strcmp(&(p[i-4]),".htm") == 0)))
                                        BIO_puts(io,"HTTP/1.0 200 ok\r\nContent-type: text/html\r\n\r\n");
                                else
                                        BIO_puts(io,"HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n");
                                }
d2468 4
a2471 4
			for (;;)
				{
				i=BIO_read(file,buf,bufsize);
				if (i <= 0) break;
d2474 5
a2478 6
				total_bytes+=i;
				fprintf(stderr,"%d\n",i);
				if (total_bytes > 3*1024)
					{
					total_bytes=0;
					fprintf(stderr,"RENEGOTIATE\n");
d2480 1
a2480 1
					}
d2483 2
a2484 1
				for (j=0; j<i; )
d2486 5
a2490 2
#ifdef RENEG
{ static count=0; if (++count == 13) { SSL_renegotiate(con); } }
d2492 2
a2493 3
					k=BIO_write(io,&(buf[j]),i-j);
					if (k <= 0)
						{
d2496 2
a2497 8
						else
							{
							BIO_printf(bio_s_out,"rwrite W BLOCK\n");
							}
						}
					else
						{
						j+=k;
d2499 2
d2503 2
a2504 1
write_error:
a2506 1
			}
d2508 1
d2510 3
a2512 5
	for (;;)
		{
		i=(int)BIO_flush(io);
		if (i <= 0)
			{
d2515 1
a2515 2
			}
		else
d2517 1
a2517 1
		}
d2521 1
a2521 1
	SSL_set_shutdown(con,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
d2531 1
a2531 1
		BIO_printf(bio_s_out,"ACCEPT\n");
d2533 4
a2536 2
	if (buf != NULL) free(buf);
	if (io != NULL) BIO_free_all(io);
d2538 2
a2539 2
	return(ret);
	}
d2542 3
a2544 2
static RSA *tmp_rsa_cb(SSL *s, int is_export, int keylength)
	{
d2546 1
a2546 1
	static RSA *rsa_tmp=NULL;
d2549 10
a2558 12
		BIO_printf(bio_err,"Allocation error in generating RSA key\n");
	if (!rsa_tmp && bn)
		{
		if (!s_quiet)
			{
			BIO_printf(bio_err,"Generating temp (%d bit) RSA key...",keylength);
			(void)BIO_flush(bio_err);
			}
		if(!BN_set_word(bn, RSA_F4) || ((rsa_tmp = RSA_new()) == NULL) ||
				!RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL))
			{
			if(rsa_tmp) RSA_free(rsa_tmp);
d2560 5
a2564 6
			}
		if (!s_quiet)
			{
			BIO_printf(bio_err,"\n");
			(void)BIO_flush(bio_err);
			}
a2565 2
		}
	return(rsa_tmp);
d2567 2
d2572 4
a2575 3
static int generate_session_id(const SSL *ssl, unsigned char *id,
				unsigned int *id_len)
	{
d2577 1
a2577 1
	do	{
d2579 7
a2585 5
		/* Prefix the session_id with the required prefix. NB: If our
		 * prefix is too long, clip it - but there will be worse effects
		 * anyway, eg. the server could only possibly create 1 session
		 * ID (ie. the prefix!) so all future session negotiations will
		 * fail due to conflicts. */
d2587 6
a2592 6
			(strlen(session_id_prefix) < *id_len) ?
			strlen(session_id_prefix) : *id_len);
		}
	while(SSL_has_matching_session_id(ssl, id, *id_len) &&
		(++count < MAX_SESSION_ID_ATTEMPTS));
	if(count >= MAX_SESSION_ID_ATTEMPTS)
d2595 1
a2595 1
	}
@


1.28
log
@Make MONOLITH the default and only option

ok deraadt
@
text
@a1782 3
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)
	struct timeval tv;
#else
a1783 1
#endif
a1913 1
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE) && !defined(OPENSSL_SYS_BEOS_R5)
a1914 1
#endif
a1921 13
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)
                        /* Under DOS (non-djgpp) and Windows we can't select on stdin: only
			 * on sockets. As a workaround we timeout the select every
			 * second and check for any keypress. In a proper Windows
			 * application we wouldn't do this because it is inefficient.
			 */
			tv.tv_sec = 1;
			tv.tv_usec = 0;
			i=select(width,(void *)&readfds,NULL,NULL,&tv);
			if((i < 0) || (!i && !_kbhit() ) )continue;
			if(_kbhit())
				read_from_terminal = 1;
#else
a1937 1
#endif
a2457 1
#if   !defined(OPENSSL_SYS_MSDOS) && !defined(__DJGPP__)
a2458 1
#endif
@


1.27
log
@unistd.h exposed after -Wall after e_os.h stops doing so; spotted by matthew
@
text
@a201 1
#ifdef MONOLITH
a202 1
#endif
a404 1
#ifdef MONOLITH
a434 1
#endif
a809 1
#ifdef MONOLITH
a810 1
#endif
@


1.26
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d154 1
@


1.25
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d154 1
a164 1
#define USE_SOCKETS
d526 1
a526 1
	BIO_printf(bio_err," -rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
d1747 1
a1747 1
	OPENSSL_EXIT(ret);
@


1.24
log
@fix a few bugs observed on http://www.viva64.com/en/b/0250/
ok krw miod
@
text
@d713 3
a715 3
		OPENSSL_free(host);
		OPENSSL_free(path);
		OPENSSL_free(port);
d1723 1
a1723 1
		OPENSSL_free(pass);
d1725 1
a1725 1
		OPENSSL_free(dpass);
d1730 1
a1730 1
		OPENSSL_free(tlscstatp.host);
d1732 1
a1732 1
		OPENSSL_free(tlscstatp.port);
d1734 1
a1734 1
		OPENSSL_free(tlscstatp.path);
d1794 1
a1794 1
	if ((buf=OPENSSL_malloc(bufsize)) == NULL)
d2165 1
a2165 1
		OPENSSL_free(buf);
d2291 1
a2291 1
		exportedkeymat = OPENSSL_malloc(keymatexportlen);
d2310 1
a2310 1
			OPENSSL_free(exportedkeymat);
d2368 1
a2368 1
	buf=OPENSSL_malloc(bufsize);
d2746 1
a2746 1
	if (buf != NULL) OPENSSL_free(buf);
@


1.23
log
@first round of unifdef hammering
@
text
@d2497 1
a2497 1
			((www == 2) && (strncmp("GET /stats ",buf,10) == 0)))
@


1.22
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@a159 1
#if !defined(OPENSSL_SYS_NETWARE)  /* conflicts with winsock2 stuff on netware */
a160 1
#endif
a183 3
#if defined(OPENSSL_SYS_BEOS_R5)
#include <fcntl.h>
#endif
a1944 11
#elif defined(OPENSSL_SYS_BEOS_R5)
			/* Under BeOS-R5 the situation is similar to DOS */
			tv.tv_sec = 1;
			tv.tv_usec = 0;
			(void)fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);
			i=select(width,(void *)&readfds,NULL,NULL,&tv);
			if ((i < 0) || (!i && read(fileno(stdin), buf, 0) < 0))
				continue;
			if (read(fileno(stdin), buf, 0) >= 0)
				read_from_terminal = 1;
			(void)fcntl(fileno(stdin), F_SETFL, 0);
d2483 1
a2483 3
#if defined(OPENSSL_SYS_NETWARE)
            delay(1000);
#elif !defined(OPENSSL_SYS_MSDOS) && !defined(__DJGPP__)
@


1.21
log
@remove ssl2 support even more completely.
in the process, always include ssl3 and tls1, we don't need config options
for them. when the time comes to expire ssl3, it will be with an ax.
checked by miod
@
text
@a163 9
/* With IPv6, it looks like Digital has mixed up the proper order of
   recursive header file inclusion, resulting in the compiler complaining
   that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which
   is needed to have fileno() declared correctly...  So let's define u_int */
#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__U_INT)
#define __U_INT
typedef unsigned int u_int;
#endif

a184 5

#if (defined(OPENSSL_SYS_VMS) && __VMS_VER < 70000000)
/* FIONBIO used as a switch to enable ioctl, and that isn't in VMS < 7.0 */
#undef FIONBIO
#endif
@


1.20
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@a1093 5
#ifndef OPENSSL_NO_SSL2
		else if	(strcmp(*argv,"-ssl2") == 0)
			{ meth=SSLv2_server_method(); }
#endif
#ifndef OPENSSL_NO_SSL3
a1095 2
#endif
#ifndef OPENSSL_NO_TLS1
a1101 1
#endif
@


1.19
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@a569 150
#ifdef CHARSET_EBCDIC
static int ebcdic_new(BIO *bi);
static int ebcdic_free(BIO *a);
static int ebcdic_read(BIO *b, char *out, int outl);
static int ebcdic_write(BIO *b, const char *in, int inl);
static long ebcdic_ctrl(BIO *b, int cmd, long num, void *ptr);
static int ebcdic_gets(BIO *bp, char *buf, int size);
static int ebcdic_puts(BIO *bp, const char *str);

#define BIO_TYPE_EBCDIC_FILTER	(18|0x0200)
static BIO_METHOD methods_ebcdic=
	{
	BIO_TYPE_EBCDIC_FILTER,
	"EBCDIC/ASCII filter",
	ebcdic_write,
	ebcdic_read,
	ebcdic_puts,
	ebcdic_gets,
	ebcdic_ctrl,
	ebcdic_new,
	ebcdic_free,
	};

typedef struct
{
	size_t	alloced;
	char	buff[1];
} EBCDIC_OUTBUFF;

BIO_METHOD *BIO_f_ebcdic_filter()
{
	return(&methods_ebcdic);
}

static int ebcdic_new(BIO *bi)
{
	EBCDIC_OUTBUFF *wbuf;

	wbuf = (EBCDIC_OUTBUFF *)OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + 1024);
	wbuf->alloced = 1024;
	wbuf->buff[0] = '\0';

	bi->ptr=(char *)wbuf;
	bi->init=1;
	bi->flags=0;
	return(1);
}

static int ebcdic_free(BIO *a)
{
	if (a == NULL) return(0);
	if (a->ptr != NULL)
		OPENSSL_free(a->ptr);
	a->ptr=NULL;
	a->init=0;
	a->flags=0;
	return(1);
}
	
static int ebcdic_read(BIO *b, char *out, int outl)
{
	int ret=0;

	if (out == NULL || outl == 0) return(0);
	if (b->next_bio == NULL) return(0);

	ret=BIO_read(b->next_bio,out,outl);
	if (ret > 0)
		ascii2ebcdic(out,out,ret);
	return(ret);
}

static int ebcdic_write(BIO *b, const char *in, int inl)
{
	EBCDIC_OUTBUFF *wbuf;
	int ret=0;
	int num;
	unsigned char n;

	if ((in == NULL) || (inl <= 0)) return(0);
	if (b->next_bio == NULL) return(0);

	wbuf=(EBCDIC_OUTBUFF *)b->ptr;

	if (inl > (num = wbuf->alloced))
	{
		num = num + num;  /* double the size */
		if (num < inl)
			num = inl;
		OPENSSL_free(wbuf);
		wbuf=(EBCDIC_OUTBUFF *)OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + num);

		wbuf->alloced = num;
		wbuf->buff[0] = '\0';

		b->ptr=(char *)wbuf;
	}

	ebcdic2ascii(wbuf->buff, in, inl);

	ret=BIO_write(b->next_bio, wbuf->buff, inl);

	return(ret);
}

static long ebcdic_ctrl(BIO *b, int cmd, long num, void *ptr)
{
	long ret;

	if (b->next_bio == NULL) return(0);
	switch (cmd)
	{
	case BIO_CTRL_DUP:
		ret=0L;
		break;
	default:
		ret=BIO_ctrl(b->next_bio,cmd,num,ptr);
		break;
	}
	return(ret);
}

static int ebcdic_gets(BIO *bp, char *buf, int size)
{
	int i, ret=0;
	if (bp->next_bio == NULL) return(0);
/*	return(BIO_gets(bp->next_bio,buf,size));*/
	for (i=0; i<size-1; ++i)
	{
		ret = ebcdic_read(bp,&buf[i],1);
		if (ret <= 0)
			break;
		else if (buf[i] == '\n')
		{
			++i;
			break;
		}
	}
	if (i < size)
		buf[i] = '\0';
	return (ret < 0 && i == 0) ? ret : i;
}

static int ebcdic_puts(BIO *bp, const char *str)
{
	if (bp->next_bio == NULL) return(0);
	return ebcdic_write(bp, str, strlen(str));
}
#endif

a2083 3
#ifdef CHARSET_EBCDIC
			ebcdic2ascii(buf,buf,i);
#endif
a2165 3
#ifdef CHARSET_EBCDIC
					ascii2ebcdic(buf,buf,i);
#endif
a2458 3
#ifdef CHARSET_EBCDIC
	io = BIO_push(BIO_new(BIO_f_ebcdic_filter()),io);
#endif
@


1.18
log
@Remove various horrible socket syscall wrappers, especially SHUTDOWN*
which did shutdown + close, all nasty and surprising.  Use the raw
syscalls that everyone knows the behaviour of.
ok beck matthew
@
text
@a2201 11

#ifndef OPENSSL_NO_HEARTBEATS
				if ((buf[0] == 'B') &&
					((buf[1] == '\n') || (buf[1] == '\r')))
					{
					BIO_printf(bio_err,"HEARTBEATING\n");
					SSL_heartbeat(con);
					i=0;
					continue;
					}
#endif
@


1.17
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@d2185 2
a2186 1
					SHUTDOWN(s);
d2194 4
a2197 2
					if (SSL_version(con) != DTLS1_VERSION)
                        SHUTDOWN(s);
d2382 2
a2383 1
		SHUTDOWN2(accept_socket);
@


1.16
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d205 1
a205 1
static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength);
d395 1
a395 1
static int MS_CALLBACK ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
d730 1
a730 1
static int MS_CALLBACK ssl_servername_cb(SSL *s, int *ad, void *arg)
d2389 1
a2389 1
	MS_STATIC char buf[BUFSIZ];
d2959 1
a2959 1
static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength)
@


1.15
log
@resolve conflicts
@
text
@d559 1
d561 1
d928 1
d930 1
d1213 1
a1213 1
			meth=TLSv1_server_method();
d1219 1
a1219 1
			meth=TLSv1_server_method();
d1326 1
d1332 1
d1440 2
d1443 13
a1455 15
# ifndef OPENSSL_NO_NEXTPROTONEG
		if (next_proto_neg_in)
			{
			unsigned short len;
			next_proto.data = next_protos_parse(&len,
				next_proto_neg_in);
			if (next_proto.data == NULL)
				goto end;
			next_proto.len = len;
			}
		else
			{
			next_proto.data = NULL;
			}
# endif
a1456 1
		}
d1558 1
d1561 1
d1740 1
a1740 1
	if (!set_cert_key_stuff(ctx,s_cert,s_key))
d1748 1
a1748 1
		if (!set_cert_key_stuff(ctx,s_dcert,s_dkey))
d1903 2
d1906 6
d2451 1
d2461 1
d2470 1
d2721 5
@


1.14
log
@openssl-1.0.0e: resolve conflicts
@
text
@d189 3
d296 3
d311 1
d379 46
d512 4
d518 2
d528 2
d556 4
d561 2
d896 20
d923 4
a957 2
#endif
#ifndef OPENSSL_NO_TLSEXT
d959 4
d968 4
a971 1
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
a972 5
#elif !defined(OPENSSL_NO_SSL3)
	meth=SSLv3_server_method();
#elif !defined(OPENSSL_NO_SSL2)
	meth=SSLv2_server_method();
#endif
d1197 1
a1197 1
				if (isxdigit((int)psk_key[i]))
d1204 14
d1230 4
d1251 4
d1307 7
a1313 1
			
d1322 16
d1434 16
d1553 3
d1633 5
d1846 19
d1946 3
d1989 1
a1989 1
		if ((con->kssl_ctx = kssl_ctx_new()) != NULL)
d1991 3
a1993 4
                        kssl_ctx_setstring(con->kssl_ctx, KSSL_SERVICE,
								KRB5SVC);
                        kssl_ctx_setstring(con->kssl_ctx, KSSL_KEYTAB,
								KRB5KEYTAB);
d2056 1
a2056 1
		con->debug=1;
d2185 10
d2238 12
d2297 12
a2320 1
				case SSL_ERROR_WANT_X509_LOOKUP:
d2375 9
d2385 14
a2398 1
	if ((i=SSL_accept(con)) <= 0)
d2436 18
a2453 1
	if (con->hit) BIO_printf(bio_s_out,"Reused session-id\n");
d2456 2
a2457 1
		BIO_printf(bio_s_out,"Peer has incorrect TLSv1 block padding\n");
d2459 2
a2460 1
	if (con->kssl_ctx->client_princ != NULL)
d2463 1
a2463 1
			con->kssl_ctx->client_princ);
d2468 29
d2514 3
d2547 3
d2581 1
a2581 1
	if ((con->kssl_ctx = kssl_ctx_new()) != NULL)
d2583 2
a2584 2
		kssl_ctx_setstring(con->kssl_ctx, KSSL_SERVICE, KRB5SVC);
		kssl_ctx_setstring(con->kssl_ctx, KSSL_KEYTAB, KRB5KEYTAB);
d2610 1
a2610 1
		con->debug=1;
d2625 12
a2636 1

d2742 1
a2742 1
			BIO_printf(io,((con->hit)
@


1.13
log
@resolve conflicts, fix local changes
@
text
@d2257 1
a2257 1
	int i,j,k,blank,dot;
a2260 1
	long total_bytes;
a2330 1
	blank=0;
a2559 1
			total_bytes=0;
@


1.12
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d116 26
d150 1
a154 1
#include <sys/stat.h>
a191 8
#ifdef OPENSSL_SYS_WINCE
/* Windows CE incorrectly defines fileno as returning void*, so to avoid problems below... */
#ifdef fileno
#undef fileno
#endif
#define fileno(a) (int)_fileno(a)
#endif

d197 4
a220 8
#ifndef S_ISDIR
# if defined(_S_IFMT) && defined(_S_IFDIR)
#  define S_ISDIR(a)	(((a) & _S_IFMT) == _S_IFDIR)
# else
#  define S_ISDIR(a)	(((a) & S_IFMT) == S_IFDIR)
# endif
#endif

d262 1
a262 1
extern int verify_depth;
d300 3
a302 2
#ifdef mtu
#undef mtu
a303 2
static long mtu;
static int cert_chain = 0;
d305 66
d435 1
a435 1
	                   "                 (default is sect163r2).\n");
d452 7
d464 1
a464 1
	BIO_printf(bio_err," -mtu          - Set MTU\n");
d494 1
d677 1
a677 1
			BIO_printf(p->biodebug,"Swiching server context.\n");
d716 1
a716 1
	STACK *aia = NULL;
d738 1
a738 1
		if (!OCSP_parse_url(sk_value(aia, 0),
d746 1
a746 1
					sk_value(aia, 0));
d791 1
a791 1
	resp = process_responder(err, req, host, path, port, use_ssl,
d830 1
d839 2
a840 2
	X509_STORE *store = NULL;
	int vflags = 0;
d853 2
a854 2
	SSL_METHOD *meth=NULL;
        int socket_type=SOCK_STREAM;
d863 1
d871 4
a874 1

d1006 3
a1008 1
		else if (strcmp(*argv,"-crl_check") == 0)
d1010 3
a1012 5
			vflags |= X509_V_FLAG_CRL_CHECK;
			}
		else if (strcmp(*argv,"-crl_check_all") == 0)
			{
			vflags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;
d1014 2
d1018 2
d1092 21
d1125 2
d1154 1
a1154 1
			mtu = atol(*(++argv));
d1196 1
a1196 1
#ifndef OPENSSL_NO_JPAKE
d1219 20
d1301 2
d1397 4
a1400 2

	SSL_CTX_sess_set_cache_size(ctx,128);
d1421 3
a1423 2
	store = SSL_CTX_get_cert_store(ctx);
	X509_STORE_set_flags(store, vflags);
a1458 1

a1463 1

d1466 4
a1469 1
		SSL_CTX_sess_set_cache_size(ctx2,128);
d1476 2
a1477 2
		store = SSL_CTX_get_cert_store(ctx2);
		X509_STORE_set_flags(store, vflags);
a1480 1

d1556 1
a1556 1
			ecdh = EC_KEY_new_by_curve_name(NID_sect163r2);
d1559 1
a1559 1
				BIO_printf(bio_err, "unable to create curve (sect163r2)\n");
d1594 1
a1594 1
#endif	
d1627 15
a1641 3
	if (cipher != NULL)
		if(!SSL_CTX_set_cipher_list(ctx,cipher)) {
		BIO_printf(bio_err,"error setting cipher list\n");
d1644 11
d1663 1
a1663 1
	}
d1668 4
d1686 1
d1695 1
d1697 1
d1768 2
a1769 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)
d1771 2
d1821 5
a1828 1
		struct timeval timeout;
d1832 1
a1832 1
		if ( enable_timeouts)
d1843 1
a1843 2
		
		if ( mtu > 0)
d1846 1
a1846 1
			SSL_set_mtu(con, mtu);
d1905 2
a1906 2
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE)
			FD_SET(fileno(stdin),&readfds);
d1908 1
a1908 1
			FD_SET(s,&readfds);
d1927 11
d1939 13
a1951 1
			i=select(width,(void *)&readfds,NULL,NULL,NULL);
d1965 1
a1965 1
				i=read(fileno(stdin), buf, bufsize/2);
d1984 1
a1984 1
				i=read(fileno(stdin),buf,bufsize);
d2004 1
d2101 1
a2101 1
					write(fileno(stdout),buf,
d2125 3
a2127 1
	BIO_printf(bio_s_out,"shutting down SSL\n");
d2129 1
a2129 1
	SSL_set_shutdown(con,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
d2131 1
a2131 1
	SSL_shutdown(con);
d2133 2
a2134 1
	if (con != NULL) SSL_free(con);
d2212 2
a2257 1
	struct stat st_buf;
d2259 1
a2259 1
	SSL_CIPHER *c;
d2529 1
a2529 8
			if (stat(p,&st_buf) < 0)
				{
				BIO_puts(io,text);
				BIO_printf(io,"Error accessing '%s'\r\n",p);
				ERR_print_errors(io);
				break;
				}
			if (S_ISDIR(st_buf.st_mode))
@


1.11
log
@resolve conflicts
@
text
@d745 4
a766 1
#ifndef OPENSSL_NO_ENGINE
a767 1
#endif
a778 1

d1075 8
d1685 5
@


1.10
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d111 11
d127 1
a127 1
#include <sys/types.h>
d134 4
d156 7
d164 1
d191 1
a191 1
static DH *load_dh_param(char *dhfile);
d194 1
d233 1
d242 3
d253 4
a256 1
static char *s_cert_file=TEST_CERT,*s_key_file=NULL;
d264 3
d271 5
d285 8
d303 5
d334 1
a334 1
	BIO_printf(bio_err," -cert arg     - certificate file to use, PEM format assumed\n");
d336 7
a342 1
	BIO_printf(bio_err," -key arg      - Private Key file to use, PEM format assumed, in cert file if\n");
d344 2
d347 1
d349 2
d353 5
d376 4
d386 3
d399 10
d564 179
d751 1
a751 1
	char *context = NULL;
d753 3
d759 1
a759 1
	int no_tmp_rsa=0,no_dhe=0,nocert=0;
d762 1
d767 14
d840 1
a840 1
			context= *(++argv);
d847 5
d857 10
d872 12
d889 10
d917 1
a917 1
		else if (strcmp(*argv,"-crl_check") == 0)
d946 31
d993 2
d1007 4
d1023 16
d1056 19
d1098 81
d1201 1
a1201 1
#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA)
d1209 4
d1241 4
d1271 56
d1350 18
d1371 49
d1421 1
a1421 1
	if (!set_cert_stuff(ctx,s_cert_file,s_key_file))
d1423 5
a1427 1
	if (s_dcert_file != NULL)
d1429 1
a1429 1
		if (!set_cert_stuff(ctx,s_dcert_file,s_dkey_file))
d1436 1
d1438 5
d1458 10
d1479 8
d1492 14
d1507 7
a1513 2
	    SSL_CTX_set_client_CA_list(ctx,SSL_load_client_CA_file(CAfile));

d1516 1
a1516 1
		do_server(port,&accept_socket,www_body, context);
d1518 1
a1518 1
		do_server(port,&accept_socket,sv_body, context);
d1523 19
d1544 1
a1544 1
		BIO_free(bio_s_out);
d1555 1
a1555 1
	BIO_printf(bio,"%4d client connects (SSL_connect())\n",
d1557 1
a1557 1
	BIO_printf(bio,"%4d client renegotiates (SSL_connect())\n",
d1559 1
a1559 1
	BIO_printf(bio,"%4d client connects that finished\n",
d1561 1
a1561 1
	BIO_printf(bio,"%4d server accepts (SSL_accept())\n",
d1563 1
a1563 1
	BIO_printf(bio,"%4d server renegotiates (SSL_accept())\n",
d1565 1
a1565 1
	BIO_printf(bio,"%4d server accepts that finished\n",
d1567 5
a1571 5
	BIO_printf(bio,"%4d session cache hits\n",SSL_CTX_sess_hits(ssl_ctx));
	BIO_printf(bio,"%4d session cache misses\n",SSL_CTX_sess_misses(ssl_ctx));
	BIO_printf(bio,"%4d session cache timeouts\n",SSL_CTX_sess_timeouts(ssl_ctx));
	BIO_printf(bio,"%4d callback cache hits\n",SSL_CTX_sess_cb_hits(ssl_ctx));
	BIO_printf(bio,"%4d cache full overflows (%d allowed)\n",
d1585 1
a1585 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
d1608 13
d1636 33
a1668 1
	sbio=BIO_new_socket(s,BIO_NOCLOSE);
d1683 2
a1684 2
		BIO_set_callback(SSL_get_rbio(con),bio_dump_cb);
		BIO_set_callback_arg(SSL_get_rbio(con),bio_s_out);
d1691 7
d1711 1
a1711 1
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS)
d1721 1
a1721 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
d1781 2
a1782 1
					SHUTDOWN(s);
d1811 1
a1811 1
					static char *str="Lets print some clear text\n";
d1995 1
a1995 1
static DH *load_dh_param(char *dhfile)
d2063 7
d2101 2
a2102 2
		BIO_set_callback(SSL_get_rbio(con),bio_dump_cb);
		BIO_set_callback_arg(SSL_get_rbio(con),bio_s_out);
d2149 3
a2151 1
#if !defined(OPENSSL_SYS_MSDOS) && !defined(__DJGPP__)
d2170 1
a2170 1
			static char *space="                          ";
d2250 1
a2250 1
			static char *text="HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n";
d2426 1
d2429 3
a2431 1
	if (rsa_tmp == NULL)
d2438 6
a2443 1
		rsa_tmp=RSA_generate_key(keylength,RSA_F4,NULL,NULL);
d2449 1
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@a142 4
#ifdef OPENSSL_SYS_WINDOWS
#include <conio.h>
#endif

d916 1
a916 1
#ifdef OPENSSL_SYS_WINDOWS
d990 1
a990 1
#ifndef OPENSSL_SYS_WINDOWS
d1000 2
a1001 2
#ifdef OPENSSL_SYS_WINDOWS
			/* Under Windows we can't select on stdin: only
d1262 7
a1268 1

@


1.8
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d147 8
d245 1
d247 1
d272 1
d274 1
d323 1
d325 1
d499 1
d501 1
d676 1
d682 1
d707 1
d709 1
d883 1
a883 1
	EXIT(ret);
d1199 1
a1199 1
		memset(buf,0,bufsize);
d1251 1
a1251 1
		X509_NAME_oneline(X509_get_subject_name(peer),buf,BUFSIZ);
d1253 1
a1253 1
		X509_NAME_oneline(X509_get_issuer_name(peer),buf,BUFSIZ);
d1258 1
a1258 1
	if (SSL_get_shared_ciphers(con,buf,BUFSIZ) != NULL)
d1418 1
a1418 1
#ifndef OPENSSL_SYS_MSDOS
@


1.7
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d323 2
a324 2
static int ebcdic_write(BIO *b, char *in, int inl);
static long ebcdic_ctrl(BIO *b, int cmd, long num, char *ptr);
d326 1
a326 1
static int ebcdic_puts(BIO *bp, char *str);
d391 1
a391 1
static int ebcdic_write(BIO *b, char *in, int inl)
d424 1
a424 1
static long ebcdic_ctrl(BIO *b, int cmd, long num, char *ptr)
d443 1
a443 1
	int i, ret;
d462 1
a462 1
static int ebcdic_puts(BIO *bp, char *str)
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d686 5
a721 5

	SSL_load_error_strings();
	OpenSSL_add_ssl_algorithms();

        e = setup_engine(bio_err, engine_id, 1);
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d58 53
d118 2
a119 1
#ifdef NO_STDIO
d127 1
a127 1
#if defined(VMS) && defined(__DECC) && !defined(__U_INT)
a140 1
#include <openssl/engine.h>
d143 1
a143 1
#ifdef WINDOWS
d147 1
a147 1
#if (defined(VMS) && __VMS_VER < 70000000)
d152 1
a152 1
#ifndef NO_RSA
d161 3
a163 1
#ifndef NO_DH
d179 1
a179 1
#ifndef NO_DH
d233 1
d238 1
d259 1
d288 1
d294 1
d303 1
a303 1
#ifndef NO_DH
d309 4
a313 1
	BIO_printf(bio_err," -engine id    - Initialise and use the specified engine\n");
d473 2
d485 1
a486 5
	char *engine_id=NULL;
	ENGINE *e=NULL;
#ifndef NO_DH
	DH *dh=NULL;
#endif
d488 1
a488 1
#if !defined(NO_SSL2) && !defined(NO_SSL3)
d490 1
a490 1
#elif !defined(NO_SSL3)
d492 1
a492 1
#elif !defined(NO_SSL2)
d507 3
d582 10
d615 2
d635 2
d643 1
a643 1
#ifndef NO_SSL2
d647 1
a647 1
#ifndef NO_SSL3
d651 1
a651 1
#ifndef NO_TLS1
d655 1
a655 1
		else if (strcmp(*argv,"-rand") == 0)
d658 1
a658 1
			inrand= *(++argv);
d665 5
d697 1
a697 1
		if (s_quiet && !s_debug)
d708 1
a708 1
#if !defined(NO_RSA) || !defined(NO_DSA)
d721 1
a721 22
	if (engine_id != NULL)
		{
		if((e = ENGINE_by_id(engine_id)) == NULL)
			{
			BIO_printf(bio_err,"invalid engine\n");
			ERR_print_errors(bio_err);
			goto end;
			}
		if (s_debug)
			{
			ENGINE_ctrl(e, ENGINE_CTRL_SET_LOGSTREAM,
				0, bio_err, 0);
			}
		if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
			{
			BIO_printf(bio_err,"can't use that engine\n");
			ERR_print_errors(bio_err);
			goto end;
			}
		BIO_printf(bio_err,"engine \"%s\" set.\n", engine_id);
		ENGINE_free(e);
		}
d729 16
a744 1

a748 1
	if (hack) SSL_CTX_set_options(ctx,SSL_OP_NON_EXPORT_FIRST);
d773 2
d776 1
a776 1
#ifndef NO_DH
d779 7
a785 1
		dh=load_dh_param(dhfile ? dhfile : s_cert_file);
d810 1
a810 1
#ifndef NO_RSA
d862 1
d900 1
a900 1
#ifdef WINDOWS
d923 9
d956 5
d974 1
a974 1
#ifndef WINDOWS
d984 1
a984 1
#ifdef WINDOWS
d1250 1
a1250 1
#ifndef NO_DH
d1319 7
d1353 5
d1398 1
a1398 1
#ifndef MSDOS
d1492 2
a1493 1
		else if ((www == 2) && (strncmp("GET /",buf,5) == 0))
d1583 10
a1592 7
			i=strlen(p);
			if (	((i > 5) && (strcmp(&(p[i-5]),".html") == 0)) ||
				((i > 4) && (strcmp(&(p[i-4]),".php") == 0)) ||
				((i > 4) && (strcmp(&(p[i-4]),".htm") == 0)))
				BIO_puts(io,"HTTP/1.0 200 ok\r\nContent-type: text/html\r\n\r\n");
			else
				BIO_puts(io,"HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n");
d1670 1
a1670 1
#ifndef NO_RSA
d1692 23
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d86 1
d249 1
d420 2
d577 5
d603 8
a610 1
	app_RAND_load_file(NULL, bio_err, 0);
d728 2
a729 1
	SSL_CTX_set_tmp_rsa_callback(ctx,tmp_rsa_cb);
d1389 2
a1390 1
			dot=0;
d1393 17
a1409 4
				if (e[0] == ' ') break;
				if (	(e[0] == '.') &&
					(strncmp(&(e[-1]),"/../",4) == 0))
					dot=1;
d1411 1
a1411 1
			
d1435 1
d1439 1
d1451 1
d1453 5
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d86 1
d180 1
d203 1
d248 1
d292 1
a292 1
	wbuf = (EBCDIC_OUTBUFF *)Malloc(sizeof(EBCDIC_OUTBUFF) + 1024);
d306 1
a306 1
		Free(a->ptr);
d343 2
a344 2
		Free(wbuf);
		wbuf=(EBCDIC_OUTBUFF *)Malloc(sizeof(EBCDIC_OUTBUFF) + num);
d418 1
d573 5
d622 23
d802 1
a802 1
	if ((buf=Malloc(bufsize)) == NULL)
d1064 1
a1064 1
		Free(buf);
d1181 1
a1181 1
	buf=Malloc(bufsize);
d1510 1
a1510 1
	if (buf != NULL) Free(buf);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d59 1
a59 3
#ifdef APPS_CRLF
# include <assert.h>
#endif
d88 4
a96 4
#if defined(NO_RSA) && !defined(NO_SSL2)
#define NO_SSL2
#endif

d107 1
a107 1
static DH *load_dh_param(void );
d110 3
a112 1
/* static void s_server_init(void);*/
d152 1
a152 1
static int bufsize=32;
a158 2
#define DH_PARAM	"server.pem"

a169 1
#ifdef APPS_CRLF /* won't be #ifdef'd in next release */
a170 1
#endif
d178 3
a180 1
#if 0
d183 1
d200 1
d214 1
a214 1
	BIO_printf(bio_err," -key arg      - RSA file to use, PEM format assumed, in cert file if\n");
d218 2
a223 1
#ifdef APPS_CRLF
a224 1
#endif
d242 1
a242 1
	BIO_printf(bio_err," -bugs         - Turn on SSL bug compatability\n");
a248 1
static int hack=0;
d339 1
a339 1
		Free((char*)wbuf);
d400 2
d407 1
d430 3
a432 2
	s_quiet=0;
	s_debug=0;
d485 5
a535 1
#ifdef APPS_CRLF
a537 1
#endif
d584 2
d610 1
a610 1
	SSLeay_add_ssl_algorithms();
d652 1
a652 2
		/* EAY EAY EAY evil hack */
		dh=load_dh_param();
d702 5
a706 1
		SSL_CTX_set_cipher_list(ctx,cipher);
d711 2
a712 1
	SSL_CTX_set_client_CA_list(ctx,SSL_load_client_CA_file(CAfile));
d765 3
d787 1
a787 1
		con=(SSL *)SSL_new(ctx);
d816 9
a824 1
		FD_ZERO(&readfds);
d826 1
a826 1
		FD_SET(fileno(stdin),&readfds);
d828 29
a856 10
		FD_SET(s,&readfds);
		/* Note: under VMS with SOCKETSHR the second parameter is
		 * currently of type (int *) whereas under other systems
		 * it is (void *) if you don't have a cast it will choke
		 * the compiler: if you do have a cast then you can either
		 * go for (int *) or (void *).
		 */
		i=select(width,(void *)&readfds,NULL,NULL,NULL);
		if (i <= 0) continue;
		if (FD_ISSET(fileno(stdin),&readfds))
a857 1
#ifdef APPS_CRLF
a880 1
#endif
d969 1
a969 1
		if (FD_ISSET(s,&readfds))
d1102 1
a1102 1
static DH *load_dh_param(void)
d1107 1
a1107 1
	if ((bio=BIO_new_file(DH_PARAM,"r")) == NULL)
d1169 1
a1169 1
	if ((con=(SSL *)SSL_new(ctx)) == NULL) goto err;
d1467 1
a1467 1
	/* This kills performace */
@


1.1
log
@Initial revision
@
text
@d59 3
d70 12
a81 2
#include "lhash.h"
#include "bn.h"
d84 4
a87 4
#include "err.h"
#include "pem.h"
#include "x509.h"
#include "ssl.h"
d90 14
a103 4
#ifndef NOPROTO
static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int export);
static int sv_body(char *hostname, int s);
static int www_body(char *hostname, int s);
a112 15
#else
static RSA MS_CALLBACK *tmp_rsa_cb();
static int sv_body();
static int www_body();
static void close_accept_socket();
static void sv_usage();
static int init_ssl_connection();
static void print_stats();
#ifndef NO_DH
static DH *load_dh_param();
static DH *get_dh512();
#endif
/* static void s_server_init(); */
#endif

d115 5
a119 1
#define S_ISDIR(a)	(((a) & _S_IFMT) == _S_IFDIR)
d135 1
a135 1
static DH *get_dh512()
d151 2
a152 1
#define BUFSIZZ	8*1024
d165 1
d172 3
d183 1
a183 1
static void s_server_init()
d204 1
a204 1
static void sv_usage()
d208 2
a209 1
	BIO_printf(bio_err," -accept arg   - port to accept on (default is %d\n",PORT);
d216 2
d222 3
d230 1
a230 1
	BIO_printf(bio_err," -cipher arg   - play with 'ssleay ciphers' to see what goes here\n");
d239 3
d244 1
a244 1
	BIO_printf(bio_err," -WWW          - Returns requested page from to a 'GET <path> HTTP/1.0'\n");
d251 151
a401 3
int MAIN(argc, argv)
int argc;
char *argv[];
d405 1
d409 1
a409 1
	int no_tmp_rsa=0,nocert=0;
d467 5
d528 4
d538 2
d642 1
a642 3
	/* EAY EAY EAY evil hack */
	dh=load_dh_param();
	if (dh != NULL)
d644 15
a658 6
		BIO_printf(bio_s_out,"Setting temp DH parameters\n");
		}
	else
		{
		BIO_printf(bio_s_out,"Using default temp DH parameters\n");
		dh=get_dh512();
a659 4
	BIO_flush(bio_s_out);

	SSL_CTX_set_tmp_dh(ctx,dh);
	DH_free(dh);
d670 1
d692 1
d697 2
d700 1
a700 1
	SSL_CTX_set_client_CA_list(ctx,SSL_load_client_CA_file(s_cert_file));
d704 1
a704 1
		do_server(port,&accept_socket,www_body);
d706 1
a706 1
		do_server(port,&accept_socket,sv_body);
d719 1
a719 3
static void print_stats(bio,ssl_ctx)
BIO *bio;
SSL_CTX *ssl_ctx;
d744 1
a744 3
static int sv_body(hostname, s)
char *hostname;
int s;
d754 1
a754 1
	if ((buf=Malloc(BUFSIZZ)) == NULL)
d771 1
a771 1
	if (con == NULL)
d773 4
d806 7
a812 1
		i=select(width,&readfds,NULL,NULL,NULL);
d816 26
a841 1
			i=read(fileno(stdin),buf,128/*BUFSIZZ*/);
d868 1
a868 1
					strcpy(buf,"server side RE-NEGOTIATE\n");
d871 1
a871 1
					((buf[1] == '\0') || (buf[1] == '\r')))
d880 1
a880 1
					strcpy(buf,"server side RE-NEGOTIATE asking for client cert\n");
d892 3
d918 1
a918 1
					break;
d948 2
a949 1
				i=SSL_read(con,(char *)buf,128 /*BUFSIZZ */);
d953 3
d958 1
d990 1
a990 1
		memset(buf,0,BUFSIZZ);
d998 1
a998 1
static void close_accept_socket()
d1007 1
a1007 2
static int init_ssl_connection(con)
SSL *con;
d1010 1
a1010 1
	char *str;
d1054 4
d1062 1
a1062 1
static DH *load_dh_param()
d1069 1
a1069 1
	ret=PEM_read_bio_DHparams(bio,NULL,NULL);
d1077 1
a1077 3
static int load_CA(ctx,file)
SSL_CTX *ctx;
char *file;
d1097 1
a1097 3
static int www_body(hostname, s)
char *hostname;
int s;
d1099 1
a1099 1
	char buf[1024];
d1108 2
d1127 1
a1127 1
	if (!BIO_set_write_buffer_size(io,253 /*16*1024*/)) goto err;
d1130 2
d1147 3
d1178 1
a1178 1
				break;
d1185 1
a1185 1
		i=BIO_gets(io,buf,sizeof(buf)-1);
d1215 1
a1215 1
			STACK *sk;
d1219 1
a1219 1
			BIO_puts(io,"<HTML><BODY BGCOLOR=ffffff>\n");
d1234 1
a1234 1
			j=sk_num(sk);
d1237 1
a1237 1
				c=(SSL_CIPHER *)sk_value(sk,i);
d1245 1
a1245 1
			p=SSL_get_shared_ciphers(con,buf,sizeof(buf));
d1291 1
a1291 1
		else if ((www == 2) && (strncmp("GET ",buf,4) == 0))
d1370 1
a1370 1
				i=BIO_read(file,buf,1024);
d1373 1
d1382 1
d1437 1
d1443 2
a1444 3
static RSA MS_CALLBACK *tmp_rsa_cb(s,export)
SSL *s;
int export;
d1452 2
a1453 2
			BIO_printf(bio_err,"Generating temp (512 bit) RSA key...");
			BIO_flush(bio_err);
d1455 1
a1455 3
#ifndef NO_RSA
		rsa_tmp=RSA_generate_key(512,RSA_F4,NULL,NULL);
#endif
d1459 1
a1459 1
			BIO_flush(bio_err);
d1464 1
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
a58 1
#include <assert.h>
d64 1
a64 2
#include <openssl/e_os2.h>
#ifdef OPENSSL_NO_STDIO
d67 2
a68 12

/* With IPv6, it looks like Digital has mixed up the proper order of
   recursive header file inclusion, resulting in the compiler complaining
   that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which
   is needed to have fileno() declared correctly...  So let's define u_int */
#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__U_INT)
#define __U_INT
typedef unsigned int u_int;
#endif

#include <openssl/lhash.h>
#include <openssl/bn.h>
d71 4
a74 5
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/x509.h>
#include <openssl/ssl.h>
#include <openssl/rand.h>
d77 4
a80 14
#ifdef OPENSSL_SYS_WINDOWS
#include <conio.h>
#endif

#if (defined(OPENSSL_SYS_VMS) && __VMS_VER < 70000000)
/* FIONBIO used as a switch to enable ioctl, and that isn't in VMS < 7.0 */
#undef FIONBIO
#endif

#ifndef OPENSSL_NO_RSA
static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength);
#endif
static int sv_body(char *hostname, int s, unsigned char *context);
static int www_body(char *hostname, int s, unsigned char *context);
d85 2
a86 4
static int generate_session_id(const SSL *ssl, unsigned char *id,
				unsigned int *id_len);
#ifndef OPENSSL_NO_DH
static DH *load_dh_param(char *dhfile);
d89 14
a102 2
#ifdef MONOLITH
static void s_server_init(void);
d105 1
d107 1
a107 5
# if defined(_S_IFMT) && defined(_S_IFDIR)
#  define S_ISDIR(a)	(((a) & _S_IFMT) == _S_IFDIR)
# else
#  define S_ISDIR(a)	(((a) & S_IFMT) == S_IFDIR)
# endif
d110 1
a110 1
#ifndef OPENSSL_NO_DH
d123 1
a123 1
static DH *get_dh512(void)
d139 1
a139 2
#define BUFSIZZ	16*1024
static int bufsize=BUFSIZZ;
d146 2
a151 1
static int s_server_session_id_context = 1; /* anything will do */
a157 1
int s_crlf=0;
a162 1
static int s_msg=0;
d165 2
a166 6
static int hack=0;
static char *engine_id=NULL;
static const char *session_id_prefix=NULL;

#ifdef MONOLITH
static void s_server_init(void)
a167 1
	accept_socket=-1;
a182 1
	s_msg=0;
a183 2
	hack=0;
	engine_id=NULL;
d187 1
a187 1
static void sv_usage(void)
d191 1
a191 2
	BIO_printf(bio_err," -accept arg   - port to accept on (default is %d)\n",PORT);
	BIO_printf(bio_err," -context arg  - set session ID context\n");
d196 1
a196 1
	BIO_printf(bio_err," -key arg      - Private Key file to use, PEM format assumed, in cert file if\n");
a197 4
	BIO_printf(bio_err," -dcert arg    - second certificate file to use (usually for DSA)\n");
	BIO_printf(bio_err," -dkey arg     - second private key file to use (usually for DSA)\n");
	BIO_printf(bio_err," -dhparam arg  - DH parameter file to use, in cert file if not specified\n");
	BIO_printf(bio_err,"                 or a default set of parameters is used\n");
a201 1
	BIO_printf(bio_err," -crlf         - convert LF from terminal into CRLF\n");
a202 1
	BIO_printf(bio_err," -msg          - Show protocol messages\n");
d207 1
a207 2
	BIO_printf(bio_err," -cipher arg   - play with 'openssl ciphers' to see what goes here\n");
	BIO_printf(bio_err," -serverpref   - Use server's cipher preferences\n");
d216 1
a216 4
#ifndef OPENSSL_NO_DH
	BIO_printf(bio_err," -no_dhe       - Disable ephemeral DH\n");
#endif
	BIO_printf(bio_err," -bugs         - Turn on SSL bug compatibility\n");
d218 1
a218 6
	BIO_printf(bio_err," -WWW          - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\n");
	BIO_printf(bio_err," -HTTP         - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\n");
        BIO_printf(bio_err,"                 with the assumption it contains a complete HTTP response.\n");
	BIO_printf(bio_err," -engine id    - Initialise and use the specified engine\n");
	BIO_printf(bio_err," -id_prefix arg - Generate SSL/TLS session IDs prefixed by 'arg'\n");
	BIO_printf(bio_err," -rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
d223 1
d225 3
a227 111
#ifdef CHARSET_EBCDIC
static int ebcdic_new(BIO *bi);
static int ebcdic_free(BIO *a);
static int ebcdic_read(BIO *b, char *out, int outl);
static int ebcdic_write(BIO *b, char *in, int inl);
static long ebcdic_ctrl(BIO *b, int cmd, long num, char *ptr);
static int ebcdic_gets(BIO *bp, char *buf, int size);
static int ebcdic_puts(BIO *bp, char *str);

#define BIO_TYPE_EBCDIC_FILTER	(18|0x0200)
static BIO_METHOD methods_ebcdic=
	{
	BIO_TYPE_EBCDIC_FILTER,
	"EBCDIC/ASCII filter",
	ebcdic_write,
	ebcdic_read,
	ebcdic_puts,
	ebcdic_gets,
	ebcdic_ctrl,
	ebcdic_new,
	ebcdic_free,
	};

typedef struct
{
	size_t	alloced;
	char	buff[1];
} EBCDIC_OUTBUFF;

BIO_METHOD *BIO_f_ebcdic_filter()
{
	return(&methods_ebcdic);
}

static int ebcdic_new(BIO *bi)
{
	EBCDIC_OUTBUFF *wbuf;

	wbuf = (EBCDIC_OUTBUFF *)OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + 1024);
	wbuf->alloced = 1024;
	wbuf->buff[0] = '\0';

	bi->ptr=(char *)wbuf;
	bi->init=1;
	bi->flags=0;
	return(1);
}

static int ebcdic_free(BIO *a)
{
	if (a == NULL) return(0);
	if (a->ptr != NULL)
		OPENSSL_free(a->ptr);
	a->ptr=NULL;
	a->init=0;
	a->flags=0;
	return(1);
}
	
static int ebcdic_read(BIO *b, char *out, int outl)
{
	int ret=0;

	if (out == NULL || outl == 0) return(0);
	if (b->next_bio == NULL) return(0);

	ret=BIO_read(b->next_bio,out,outl);
	if (ret > 0)
		ascii2ebcdic(out,out,ret);
	return(ret);
}

static int ebcdic_write(BIO *b, char *in, int inl)
{
	EBCDIC_OUTBUFF *wbuf;
	int ret=0;
	int num;
	unsigned char n;

	if ((in == NULL) || (inl <= 0)) return(0);
	if (b->next_bio == NULL) return(0);

	wbuf=(EBCDIC_OUTBUFF *)b->ptr;

	if (inl > (num = wbuf->alloced))
	{
		num = num + num;  /* double the size */
		if (num < inl)
			num = inl;
		OPENSSL_free(wbuf);
		wbuf=(EBCDIC_OUTBUFF *)OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + num);

		wbuf->alloced = num;
		wbuf->buff[0] = '\0';

		b->ptr=(char *)wbuf;
	}

	ebcdic2ascii(wbuf->buff, in, inl);

	ret=BIO_write(b->next_bio, wbuf->buff, inl);

	return(ret);
}

static long ebcdic_ctrl(BIO *b, int cmd, long num, char *ptr)
{
	long ret;

	if (b->next_bio == NULL) return(0);
	switch (cmd)
a228 44
	case BIO_CTRL_DUP:
		ret=0L;
		break;
	default:
		ret=BIO_ctrl(b->next_bio,cmd,num,ptr);
		break;
	}
	return(ret);
}

static int ebcdic_gets(BIO *bp, char *buf, int size)
{
	int i, ret;
	if (bp->next_bio == NULL) return(0);
/*	return(BIO_gets(bp->next_bio,buf,size));*/
	for (i=0; i<size-1; ++i)
	{
		ret = ebcdic_read(bp,&buf[i],1);
		if (ret <= 0)
			break;
		else if (buf[i] == '\n')
		{
			++i;
			break;
		}
	}
	if (i < size)
		buf[i] = '\0';
	return (ret < 0 && i == 0) ? ret : i;
}

static int ebcdic_puts(BIO *bp, char *str)
{
	if (bp->next_bio == NULL) return(0);
	return ebcdic_write(bp, str, strlen(str));
}
#endif

int MAIN(int, char **);

int MAIN(int argc, char *argv[])
	{
	X509_STORE *store = NULL;
	int vflags = 0;
a230 2
	char *context = NULL;
	char *dhfile = NULL;
d234 1
a234 1
	int no_tmp_rsa=0,no_dhe=0,nocert=0;
d237 3
a239 2
	ENGINE *e=NULL;
	char *inrand=NULL;
d241 1
a241 1
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
d243 1
a243 1
#elif !defined(OPENSSL_NO_SSL3)
d245 1
a245 1
#elif !defined(OPENSSL_NO_SSL2)
d253 2
a254 3
#ifdef MONOLITH
	s_server_init();
#endif
a258 3
	if (!load_config(bio_err, NULL))
		goto end;

a291 5
		else if	(strcmp(*argv,"-context") == 0)
			{
			if (--argc < 1) goto bad;
			context= *(++argv);
			}
a301 5
		else if	(strcmp(*argv,"-dhparam") == 0)
			{
			if (--argc < 1) goto bad;
			dhfile = *(++argv);
			}
a320 10
		else if (strcmp(*argv,"-crl_check") == 0)
			{
			vflags |= X509_V_FLAG_CRL_CHECK;
			}
		else if (strcmp(*argv,"-crl_check") == 0)
			{
			vflags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;
			}
		else if	(strcmp(*argv,"-serverpref") == 0)
			{ off|=SSL_OP_CIPHER_SERVER_PREFERENCE; }
a343 2
		else if	(strcmp(*argv,"-msg") == 0)
			{ s_msg=1; }
a347 2
		else if	(strcmp(*argv,"-crlf") == 0)
			{ s_crlf=1; }
a353 2
		else if	(strcmp(*argv,"-no_dhe") == 0)
			{ no_dhe=1; }
a357 2
		else if	(strcmp(*argv,"-HTTP") == 0)
			{ www=3; }
d364 1
a364 1
#ifndef OPENSSL_NO_SSL2
d368 1
a368 1
#ifndef OPENSSL_NO_SSL3
d372 1
a372 1
#ifndef OPENSSL_NO_TLS1
a375 15
		else if (strcmp(*argv, "-id_prefix") == 0)
			{
			if (--argc < 1) goto bad;
			session_id_prefix = *(++argv);
			}
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
			engine_id= *(++argv);
			}
		else if (strcmp(*argv,"-rand") == 0)
			{
			if (--argc < 1) goto bad;
			inrand= *(++argv);
			}
a391 9
	if (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL
		&& !RAND_status())
		{
		BIO_printf(bio_err,"warning, not much extra random data, consider using the -rand option\n");
		}
	if (inrand != NULL)
		BIO_printf(bio_err,"%ld semi-random bytes loaded\n",
			app_RAND_load_files(inrand));

d394 1
a394 1
		if (s_quiet && !s_debug && !s_msg)
d405 1
a405 1
#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA)
d416 1
a416 3
	OpenSSL_add_ssl_algorithms();

        e = setup_engine(bio_err, engine_id, 1);
d424 1
a424 16
	if (session_id_prefix)
		{
		if(strlen(session_id_prefix) >= 32)
			BIO_printf(bio_err,
"warning: id_prefix is too long, only one new session will be possible\n");
		else if(strlen(session_id_prefix) >= 16)
			BIO_printf(bio_err,
"warning: id_prefix is too long if you use SSLv2\n");
		if(!SSL_CTX_set_generate_session_id(ctx, generate_session_id))
			{
			BIO_printf(bio_err,"error setting 'id_prefix'\n");
			ERR_print_errors(bio_err);
			goto end;
			}
		BIO_printf(bio_err,"id_prefix '%s' set.\n", session_id_prefix);
		}
d429 1
a453 2
	store = SSL_CTX_get_cert_store(ctx);
	X509_STORE_set_flags(store, vflags);
d455 8
a462 2
#ifndef OPENSSL_NO_DH
	if (!no_dhe)
d464 4
a467 17
		DH *dh=NULL;

		if (dhfile)
			dh = load_dh_param(dhfile);
		else if (s_cert_file)
			dh = load_dh_param(s_cert_file);

		if (dh != NULL)
			{
			BIO_printf(bio_s_out,"Setting temp DH parameters\n");
			}
		else
			{
			BIO_printf(bio_s_out,"Using default temp DH parameters\n");
			dh=get_dh512();
			}
		(void)BIO_flush(bio_s_out);
d469 2
a470 3
		SSL_CTX_set_tmp_dh(ctx,dh);
		DH_free(dh);
		}
a480 1
#ifndef OPENSSL_NO_RSA
d482 1
a482 2
	if (!no_tmp_rsa)
		SSL_CTX_set_tmp_rsa_callback(ctx,tmp_rsa_cb);
a501 1
#endif
d504 1
a504 5
		if(!SSL_CTX_set_cipher_list(ctx,cipher)) {
		BIO_printf(bio_err,"error setting cipher list\n");
		ERR_print_errors(bio_err);
		goto end;
	}
a505 2
	SSL_CTX_set_session_id_context(ctx,(void*)&s_server_session_id_context,
		sizeof s_server_session_id_context);
d507 1
a507 2
	if (CAfile != NULL)
	    SSL_CTX_set_client_CA_list(ctx,SSL_load_client_CA_file(CAfile));
d511 1
a511 1
		do_server(port,&accept_socket,www_body, context);
d513 1
a513 1
		do_server(port,&accept_socket,sv_body, context);
a522 1
	apps_shutdown();
d526 3
a528 1
static void print_stats(BIO *bio, SSL_CTX *ssl_ctx)
d553 3
a555 1
static int sv_body(char *hostname, int s, unsigned char *context)
a563 3
#ifdef OPENSSL_SYS_WINDOWS
	struct timeval tv;
#endif
d565 1
a565 1
	if ((buf=OPENSSL_malloc(bufsize)) == NULL)
d582 2
a583 15
	if (con == NULL) {
		con=SSL_new(ctx);
#ifndef OPENSSL_NO_KRB5
		if ((con->kssl_ctx = kssl_ctx_new()) != NULL)
                        {
                        kssl_ctx_setstring(con->kssl_ctx, KSSL_SERVICE,
								KRB5SVC);
                        kssl_ctx_setstring(con->kssl_ctx, KSSL_KEYTAB,
								KRB5KEYTAB);
                        }
#endif	/* OPENSSL_NO_KRB5 */
		if(context)
		      SSL_set_session_id_context(con, context,
						 strlen((char *)context));
	}
a603 5
	if (s_msg)
		{
		SSL_set_msg_callback(con, msg_cb);
		SSL_set_msg_callback_arg(con, bio_s_out);
		}
d608 8
a615 41
		int read_from_terminal;
		int read_from_sslcon;

		read_from_terminal = 0;
		read_from_sslcon = SSL_pending(con);

		if (!read_from_sslcon)
			{
			FD_ZERO(&readfds);
#ifndef OPENSSL_SYS_WINDOWS
			FD_SET(fileno(stdin),&readfds);
#endif
			FD_SET(s,&readfds);
			/* Note: under VMS with SOCKETSHR the second parameter is
			 * currently of type (int *) whereas under other systems
			 * it is (void *) if you don't have a cast it will choke
			 * the compiler: if you do have a cast then you can either
			 * go for (int *) or (void *).
			 */
#ifdef OPENSSL_SYS_WINDOWS
			/* Under Windows we can't select on stdin: only
			 * on sockets. As a workaround we timeout the select every
			 * second and check for any keypress. In a proper Windows
			 * application we wouldn't do this because it is inefficient.
			 */
			tv.tv_sec = 1;
			tv.tv_usec = 0;
			i=select(width,(void *)&readfds,NULL,NULL,&tv);
			if((i < 0) || (!i && !_kbhit() ) )continue;
			if(_kbhit())
				read_from_terminal = 1;
#else
			i=select(width,(void *)&readfds,NULL,NULL,NULL);
			if (i <= 0) continue;
			if (FD_ISSET(fileno(stdin),&readfds))
				read_from_terminal = 1;
#endif
			if (FD_ISSET(s,&readfds))
				read_from_sslcon = 1;
			}
		if (read_from_terminal)
d617 1
a617 24
			if (s_crlf)
				{
				int j, lf_num;

				i=read(fileno(stdin), buf, bufsize/2);
				lf_num = 0;
				/* both loops are skipped when i <= 0 */
				for (j = 0; j < i; j++)
					if (buf[j] == '\n')
						lf_num++;
				for (j = i-1; j >= 0; j--)
					{
					buf[j+lf_num] = buf[j];
					if (buf[j] == '\n')
						{
						lf_num--;
						i++;
						buf[j+lf_num] = '\r';
						}
					}
				assert(lf_num == 0);
				}
			else
				i=read(fileno(stdin),buf,bufsize);
d644 1
a644 1
					/* strcpy(buf,"server side RE-NEGOTIATE\n"); */
d647 1
a647 1
					((buf[1] == '\n') || (buf[1] == '\r')))
d656 1
a656 1
					/* strcpy(buf,"server side RE-NEGOTIATE asking for client cert\n"); */
a667 3
#ifdef CHARSET_EBCDIC
			ebcdic2ascii(buf,buf,i);
#endif
d691 1
a691 1
					/* break; */
d702 1
a702 1
		if (read_from_sslcon)
d721 1
a721 2
again:	
				i=SSL_read(con,(char *)buf,bufsize);
a724 3
#ifdef CHARSET_EBCDIC
					ascii2ebcdic(buf,buf,i);
#endif
a726 1
					if (SSL_pending(con)) goto again;
d758 2
a759 2
		memset(buf,0,bufsize);
		OPENSSL_free(buf);
d766 1
a766 1
static void close_accept_socket(void)
d775 2
a776 1
static int init_ssl_connection(SSL *con)
d779 1
a779 1
	const char *str;
a822 4
	if (SSL_ctrl(con,SSL_CTRL_GET_FLAGS,0,NULL) &
		TLS1_FLAGS_TLS_PADDING_BUG)
		BIO_printf(bio_s_out,"Peer has incorrect TLSv1 block padding\n");

d826 2
a827 2
#ifndef OPENSSL_NO_DH
static DH *load_dh_param(char *dhfile)
d832 1
a832 1
	if ((bio=BIO_new_file(dhfile,"r")) == NULL)
d834 1
a834 1
	ret=PEM_read_bio_DHparams(bio,NULL,NULL,NULL);
d842 3
a844 1
static int load_CA(SSL_CTX *ctx, char *file)
d864 3
a866 1
static int www_body(char *hostname, int s, unsigned char *context)
d868 1
a868 1
	char *buf=NULL;
a876 2
	buf=OPENSSL_malloc(bufsize);
	if (buf == NULL) return(0);
d894 1
a894 1
	if (!BIO_set_write_buffer_size(io,bufsize)) goto err;
d896 1
a896 10
	if ((con=SSL_new(ctx)) == NULL) goto err;
#ifndef OPENSSL_NO_KRB5
	if ((con->kssl_ctx = kssl_ctx_new()) != NULL)
		{
		kssl_ctx_setstring(con->kssl_ctx, KSSL_SERVICE, KRB5SVC);
		kssl_ctx_setstring(con->kssl_ctx, KSSL_KEYTAB, KRB5KEYTAB);
		}
#endif	/* OPENSSL_NO_KRB5 */
	if(context) SSL_set_session_id_context(con, context,
					       strlen((char *)context));
a911 3
#ifdef CHARSET_EBCDIC
	io = BIO_push(BIO_new(BIO_f_ebcdic_filter()),io);
#endif
a918 5
	if (s_msg)
		{
		SSL_set_msg_callback(con, msg_cb);
		SSL_set_msg_callback_arg(con, bio_s_out);
		}
d940 1
a940 1
				/* break; */
d947 1
a947 1
		i=BIO_gets(io,buf,bufsize-1);
d959 1
a959 1
#ifndef OPENSSL_SYS_MSDOS
d977 1
a977 1
			STACK_OF(SSL_CIPHER) *sk;
d981 1
a981 1
			BIO_puts(io,"<HTML><BODY BGCOLOR=\"#ffffff\">\n");
d996 1
a996 1
			j=sk_SSL_CIPHER_num(sk);
d999 1
a999 1
				c=sk_SSL_CIPHER_value(sk,i);
d1007 1
a1007 1
			p=SSL_get_shared_ciphers(con,buf,bufsize);
d1053 1
a1053 2
		else if ((www == 2 || www == 3)
                         && (strncmp("GET /",buf,5) == 0))
d1061 1
a1061 2

			dot = 1;
d1064 4
a1067 17
				if (e[0] == ' ')
					break;

				switch (dot)
					{
				case 1:
					dot = (e[0] == '.') ? 2 : 0;
					break;
				case 2:
					dot = (e[0] == '.') ? 3 : 0;
					break;
				case 3:
					dot = (e[0] == '/') ? -1 : 0;
					break;
					}
				if (dot == 0)
					dot = (e[0] == '/') ? 1 : 0;
d1069 1
a1069 1
			dot = (dot == 3) || (dot == -1); /* filename contains ".." component */
a1092 1
#if 0
a1095 1
#endif
a1106 1
#if 0 /* must check buffer size */
a1107 5
#else
				BIO_puts(io,text);
				BIO_printf(io,"'%s' is a directory\r\n",p);
				break;
#endif
d1121 7
a1127 10
                        if (www == 2)
                                {
                                i=strlen(p);
                                if (	((i > 5) && (strcmp(&(p[i-5]),".html") == 0)) ||
                                        ((i > 4) && (strcmp(&(p[i-4]),".php") == 0)) ||
                                        ((i > 4) && (strcmp(&(p[i-4]),".htm") == 0)))
                                        BIO_puts(io,"HTTP/1.0 200 ok\r\nContent-type: text/html\r\n\r\n");
                                else
                                        BIO_puts(io,"HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n");
                                }
d1132 1
a1132 1
				i=BIO_read(file,buf,bufsize);
a1134 1
#ifdef RENEG
a1142 1
#endif
d1187 1
a1187 1
	/* This kills performance */
a1196 1
	if (buf != NULL) OPENSSL_free(buf);
d1202 3
a1204 2
#ifndef OPENSSL_NO_RSA
static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength)
d1212 2
a1213 2
			BIO_printf(bio_err,"Generating temp (%d bit) RSA key...",keylength);
			(void)BIO_flush(bio_err);
d1215 3
a1217 1
		rsa_tmp=RSA_generate_key(keylength,RSA_F4,NULL,NULL);
d1221 1
a1221 1
			(void)BIO_flush(bio_err);
a1224 24
	}
#endif

#define MAX_SESSION_ID_ATTEMPTS 10
static int generate_session_id(const SSL *ssl, unsigned char *id,
				unsigned int *id_len)
	{
	unsigned int count = 0;
	do	{
		RAND_pseudo_bytes(id, *id_len);
		/* Prefix the session_id with the required prefix. NB: If our
		 * prefix is too long, clip it - but there will be worse effects
		 * anyway, eg. the server could only possibly create 1 session
		 * ID (ie. the prefix!) so all future session negotiations will
		 * fail due to conflicts. */
		memcpy(id, session_id_prefix,
			(strlen(session_id_prefix) < *id_len) ?
			strlen(session_id_prefix) : *id_len);
		}
	while(SSL_has_matching_session_id(ssl, id, *id_len) &&
		(++count < MAX_SESSION_ID_ATTEMPTS));
	if(count >= MAX_SESSION_ID_ATTEMPTS)
		return 0;
	return 1;
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a685 5
	SSL_load_error_strings();
	OpenSSL_add_ssl_algorithms();

        e = setup_engine(bio_err, engine_id, 1);

d717 5
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d323 2
a324 2
static int ebcdic_write(BIO *b, const char *in, int inl);
static long ebcdic_ctrl(BIO *b, int cmd, long num, void *ptr);
d326 1
a326 1
static int ebcdic_puts(BIO *bp, const char *str);
d391 1
a391 1
static int ebcdic_write(BIO *b, const char *in, int inl)
d424 1
a424 1
static long ebcdic_ctrl(BIO *b, int cmd, long num, void *ptr)
d443 1
a443 1
	int i, ret=0;
d462 1
a462 1
static int ebcdic_puts(BIO *bp, const char *str)
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@a146 8
#ifdef OPENSSL_SYS_WINCE
/* Windows CE incorrectly defines fileno as returning void*, so to avoid problems below... */
#ifdef fileno
#undef fileno
#endif
#define fileno(a) (int)_fileno(a)
#endif

a236 1
#ifndef OPENSSL_NO_ENGINE
a237 1
#endif
a261 1
#ifndef OPENSSL_NO_ENGINE
a262 1
#endif
a310 1
#ifndef OPENSSL_NO_ENGINE
a311 1
#endif
a484 1
#ifndef OPENSSL_NO_ENGINE
a485 1
#endif
a659 1
#ifndef OPENSSL_NO_ENGINE
a664 1
#endif
a688 1
#ifndef OPENSSL_NO_ENGINE
a689 1
#endif
d863 1
a863 1
	OPENSSL_EXIT(ret);
d1179 1
a1179 1
		OPENSSL_cleanse(buf,bufsize);
d1231 1
a1231 1
		X509_NAME_oneline(X509_get_subject_name(peer),buf,sizeof buf);
d1233 1
a1233 1
		X509_NAME_oneline(X509_get_issuer_name(peer),buf,sizeof buf);
d1238 1
a1238 1
	if (SSL_get_shared_ciphers(con,buf,sizeof buf) != NULL)
d1398 1
a1398 1
#if !defined(OPENSSL_SYS_MSDOS) && !defined(__DJGPP__)
@


1.1.1.6
log
@import 0.9.7c
@
text
@d143 4
d920 1
a920 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
d994 1
a994 1
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS)
d1004 2
a1005 2
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
                        /* Under DOS (non-djgpp) and Windows we can't select on stdin: only
d1266 1
a1266 7
#ifndef OPENSSL_NO_KRB5
	if (con->kssl_ctx->client_princ != NULL)
		{
		BIO_printf(bio_s_out,"Kerberos peer principal is %s\n",
			con->kssl_ctx->client_princ);
		}
#endif /* OPENSSL_NO_KRB5 */
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@a110 11
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */

/* Until the key-gen callbacks are modified to use newer prototypes, we allow
 * deprecated functions for openssl-internal code */
#ifdef OPENSSL_NO_DEPRECATED
#undef OPENSSL_NO_DEPRECATED
#endif
d116 1
a116 1

a122 4
#if !defined(OPENSSL_SYS_NETWARE)  /* conflicts with winsock2 stuff on netware */
#include <sys/types.h>
#endif

a140 7
#include <openssl/ocsp.h>
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
a141 1
#include "timeouts.h"
d168 1
a168 1
static DH *load_dh_param(const char *dhfile);
a170 1

a208 1

a216 3
#ifndef OPENSSL_NO_TLSEXT
#define TEST_CERT2	"server2.pem"
#endif
d225 1
a225 4
static const char *s_cert_file=TEST_CERT,*s_key_file=NULL;
#ifndef OPENSSL_NO_TLSEXT
static const char *s_cert_file2=TEST_CERT2,*s_key_file2=NULL;
#endif
a232 3
#ifndef OPENSSL_NO_TLSEXT
static SSL_CTX *ctx2=NULL;
#endif
a236 5
#ifndef OPENSSL_NO_TLSEXT
static int s_tlsextdebug=0;
static int s_tlsextstatus=0;
static int cert_status_cb(SSL *s, void *arg);
#endif
a245 8
static int enable_timeouts = 0;
#ifdef mtu
#undef mtu
#endif
static long mtu;
static int cert_chain = 0;


a255 5
#ifndef OPENSSL_NO_TLSEXT
	s_cert_file2=TEST_CERT2;
	s_key_file2=NULL;
	ctx2=NULL;
#endif
d282 1
a282 1
	BIO_printf(bio_err," -cert arg     - certificate file to use\n");
d284 1
a284 7
	BIO_printf(bio_err," -crl_check    - check the peer certificate has not been revoked by its CA.\n" \
	                   "                 The CRL(s) are appended to the certificate file\n");
	BIO_printf(bio_err," -crl_check_all - check the peer certificate has not been revoked by its CA\n" \
	                   "                 or any other CRL in the CA chain. CRL(s) are appened to the\n" \
	                   "                 the certificate file.\n");
	BIO_printf(bio_err," -certform arg - certificate format (PEM or DER) PEM default\n");
	BIO_printf(bio_err," -key arg      - Private Key file to use, in cert file if\n");
a285 2
	BIO_printf(bio_err," -keyform arg  - key format (PEM, DER or ENGINE) PEM default\n");
	BIO_printf(bio_err," -pass arg     - private key file pass phrase source\n");
a286 1
	BIO_printf(bio_err," -dcertform x  - second certificate format (PEM or DER) PEM default\n");
a287 2
	BIO_printf(bio_err," -dkeyform arg - second key format (PEM, DER or ENGINE) PEM default\n");
	BIO_printf(bio_err," -dpass arg    - second private key file pass phrase source\n");
a289 5
#ifndef OPENSSL_NO_ECDH
	BIO_printf(bio_err," -named_curve arg  - Elliptic curve name to use for ephemeral ECDH keys.\n" \
	                   "                 Use \"openssl ecparam -list_curves\" for all names\n" \
	                   "                 (default is sect163r2).\n");
#endif
a307 4
	BIO_printf(bio_err," -dtls1        - Just talk DTLSv1\n");
	BIO_printf(bio_err," -timeout      - Enable timeouts\n");
	BIO_printf(bio_err," -mtu          - Set MTU\n");
	BIO_printf(bio_err," -chain        - Read a certificate chain\n");
a313 3
#ifndef OPENSSL_NO_ECDH
	BIO_printf(bio_err," -no_ecdhe     - Disable ephemeral ECDH\n");
#endif
a323 10
#ifndef OPENSSL_NO_TLSEXT
	BIO_printf(bio_err," -servername host - servername for HostName TLS extension\n");
	BIO_printf(bio_err," -servername_fatal - on mismatch send fatal alert (default warning alert)\n");
	BIO_printf(bio_err," -cert2 arg    - certificate file to use for servername\n");
	BIO_printf(bio_err,"                 (default is %s)\n",TEST_CERT2);
	BIO_printf(bio_err," -key2 arg     - Private Key file to use for servername, in cert file if\n");
	BIO_printf(bio_err,"                 not specified (default is %s)\n",TEST_CERT2);
	BIO_printf(bio_err," -tlsextdebug  - hex dump of all TLS extensions received\n");
	BIO_printf(bio_err," -no_ticket    - disable use of RFC4507bis session tickets\n");
#endif
a478 179
#ifndef OPENSSL_NO_TLSEXT

/* This is a context that we pass to callbacks */
typedef struct tlsextctx_st {
   char * servername;
   BIO * biodebug;
   int extension_error;
} tlsextctx;


static int MS_CALLBACK ssl_servername_cb(SSL *s, int *ad, void *arg)
	{
	tlsextctx * p = (tlsextctx *) arg;
	const char * servername = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);
        if (servername && p->biodebug) 
		BIO_printf(p->biodebug,"Hostname in TLS extension: \"%s\"\n",servername);
        
	if (!p->servername)
		return SSL_TLSEXT_ERR_NOACK;
	
	if (servername)
		{
    		if (strcmp(servername,p->servername)) 
			return p->extension_error;
		if (ctx2)
			{
			BIO_printf(p->biodebug,"Swiching server context.\n");
			SSL_set_SSL_CTX(s,ctx2);
			}     
		}
	return SSL_TLSEXT_ERR_OK;
}

/* Structure passed to cert status callback */

typedef struct tlsextstatusctx_st {
   /* Default responder to use */
   char *host, *path, *port;
   int use_ssl;
   int timeout;
   BIO *err;
   int verbose;
} tlsextstatusctx;

static tlsextstatusctx tlscstatp = {NULL, NULL, NULL, 0, -1, NULL, 0};

/* Certificate Status callback. This is called when a client includes a
 * certificate status request extension.
 *
 * This is a simplified version. It examines certificates each time and
 * makes one OCSP responder query for each request.
 *
 * A full version would store details such as the OCSP certificate IDs and
 * minimise the number of OCSP responses by caching them until they were
 * considered "expired".
 */

static int cert_status_cb(SSL *s, void *arg)
	{
	tlsextstatusctx *srctx = arg;
	BIO *err = srctx->err;
	char *host, *port, *path;
	int use_ssl;
	unsigned char *rspder = NULL;
	int rspderlen;
	STACK *aia = NULL;
	X509 *x = NULL;
	X509_STORE_CTX inctx;
	X509_OBJECT obj;
	OCSP_REQUEST *req = NULL;
	OCSP_RESPONSE *resp = NULL;
	OCSP_CERTID *id = NULL;
	STACK_OF(X509_EXTENSION) *exts;
	int ret = SSL_TLSEXT_ERR_NOACK;
	int i;
#if 0
STACK_OF(OCSP_RESPID) *ids;
SSL_get_tlsext_status_ids(s, &ids);
BIO_printf(err, "cert_status: received %d ids\n", sk_OCSP_RESPID_num(ids));
#endif
	if (srctx->verbose)
		BIO_puts(err, "cert_status: callback called\n");
	/* Build up OCSP query from server certificate */
	x = SSL_get_certificate(s);
	aia = X509_get1_ocsp(x);
	if (aia)
		{
		if (!OCSP_parse_url(sk_value(aia, 0),
			&host, &port, &path, &use_ssl))
			{
			BIO_puts(err, "cert_status: can't parse AIA URL\n");
			goto err;
			}
		if (srctx->verbose)
			BIO_printf(err, "cert_status: AIA URL: %s\n",
					sk_value(aia, 0));
		}
	else
		{
		if (!srctx->host)
			{
			BIO_puts(srctx->err, "cert_status: no AIA and no default responder URL\n");
			goto done;
			}
		host = srctx->host;
		path = srctx->path;
		port = srctx->port;
		use_ssl = srctx->use_ssl;
		}
		
	if (!X509_STORE_CTX_init(&inctx,
				SSL_CTX_get_cert_store(SSL_get_SSL_CTX(s)),
				NULL, NULL))
		goto err;
	if (X509_STORE_get_by_subject(&inctx,X509_LU_X509,
				X509_get_issuer_name(x),&obj) <= 0)
		{
		BIO_puts(err, "cert_status: Can't retrieve issuer certificate.\n");
		X509_STORE_CTX_cleanup(&inctx);
		goto done;
		}
	req = OCSP_REQUEST_new();
	if (!req)
		goto err;
	id = OCSP_cert_to_id(NULL, x, obj.data.x509);
	X509_free(obj.data.x509);
	X509_STORE_CTX_cleanup(&inctx);
	if (!id)
		goto err;
	if (!OCSP_request_add0_id(req, id))
		goto err;
	id = NULL;
	/* Add any extensions to the request */
	SSL_get_tlsext_status_exts(s, &exts);
	for (i = 0; i < sk_X509_EXTENSION_num(exts); i++)
		{
		X509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);
		if (!OCSP_REQUEST_add_ext(req, ext, -1))
			goto err;
		}
	resp = process_responder(err, req, host, path, port, use_ssl,
					srctx->timeout);
	if (!resp)
		{
		BIO_puts(err, "cert_status: error querying responder\n");
		goto done;
		}
	rspderlen = i2d_OCSP_RESPONSE(resp, &rspder);
	if (rspderlen <= 0)
		goto err;
	SSL_set_tlsext_status_ocsp_resp(s, rspder, rspderlen);
	if (srctx->verbose)
		{
		BIO_puts(err, "cert_status: ocsp response sent:\n");
		OCSP_RESPONSE_print(err, resp, 2);
		}
	ret = SSL_TLSEXT_ERR_OK;
	done:
	if (ret != SSL_TLSEXT_ERR_OK)
		ERR_print_errors(err);
	if (aia)
		{
		OPENSSL_free(host);
		OPENSSL_free(path);
		OPENSSL_free(port);
		X509_email_free(aia);
		}
	if (id)
		OCSP_CERTID_free(id);
	if (req)
		OCSP_REQUEST_free(req);
	if (resp)
		OCSP_RESPONSE_free(resp);
	return ret;
	err:
	ret = SSL_TLSEXT_ERR_ALERT_FATAL;
	goto done;
	}
#endif
d487 1
a487 1
	unsigned char *context = NULL;
a488 3
#ifndef OPENSSL_NO_ECDH
	char *named_curve = NULL;
#endif
d492 1
a492 1
	int no_tmp_rsa=0,no_dhe=0,no_ecdhe=0,nocert=0;
a494 1
        int socket_type=SOCK_STREAM;
a498 14
	int s_cert_format = FORMAT_PEM, s_key_format = FORMAT_PEM;
	char *passarg = NULL, *pass = NULL;
	char *dpassarg = NULL, *dpass = NULL;
	int s_dcert_format = FORMAT_PEM, s_dkey_format = FORMAT_PEM;
	X509 *s_cert = NULL, *s_dcert = NULL;
	EVP_PKEY *s_key = NULL, *s_dkey = NULL;
#ifndef OPENSSL_NO_TLSEXT
	EVP_PKEY *s_key2 = NULL;
	X509 *s_cert2 = NULL;
#endif

#ifndef OPENSSL_NO_TLSEXT
        tlsextctx tlsextcbp = {NULL, NULL, SSL_TLSEXT_ERR_ALERT_WARNING};
#endif
d558 1
a558 1
			context= (unsigned char *)*(++argv);
a564 5
		else if	(strcmp(*argv,"-certform") == 0)
			{
			if (--argc < 1) goto bad;
			s_cert_format = str2fmt(*(++argv));
			}
a569 10
		else if	(strcmp(*argv,"-keyform") == 0)
			{
			if (--argc < 1) goto bad;
			s_key_format = str2fmt(*(++argv));
			}
		else if	(strcmp(*argv,"-pass") == 0)
			{
			if (--argc < 1) goto bad;
			passarg = *(++argv);
			}
a574 12
#ifndef OPENSSL_NO_ECDH		
		else if	(strcmp(*argv,"-named_curve") == 0)
			{
			if (--argc < 1) goto bad;
			named_curve = *(++argv);
			}
#endif
		else if	(strcmp(*argv,"-dcertform") == 0)
			{
			if (--argc < 1) goto bad;
			s_dcert_format = str2fmt(*(++argv));
			}
a579 10
		else if	(strcmp(*argv,"-dkeyform") == 0)
			{
			if (--argc < 1) goto bad;
			s_dkey_format = str2fmt(*(++argv));
			}
		else if	(strcmp(*argv,"-dpass") == 0)
			{
			if (--argc < 1) goto bad;
			dpassarg = *(++argv);
			}
d598 1
a598 1
		else if (strcmp(*argv,"-crl_check_all") == 0)
a626 31
#ifndef OPENSSL_NO_TLSEXT
		else if	(strcmp(*argv,"-tlsextdebug") == 0)
			s_tlsextdebug=1;
		else if	(strcmp(*argv,"-status") == 0)
			s_tlsextstatus=1;
		else if	(strcmp(*argv,"-status_verbose") == 0)
			{
			s_tlsextstatus=1;
			tlscstatp.verbose = 1;
			}
		else if (!strcmp(*argv, "-status_timeout"))
			{
			s_tlsextstatus=1;
                        if (--argc < 1) goto bad;
			tlscstatp.timeout = atoi(*(++argv));
			}
		else if (!strcmp(*argv, "-status_url"))
			{
			s_tlsextstatus=1;
                        if (--argc < 1) goto bad;
			if (!OCSP_parse_url(*(++argv),
					&tlscstatp.host,
					&tlscstatp.port,
					&tlscstatp.path,
					&tlscstatp.use_ssl))
				{
				BIO_printf(bio_err, "Error parsing URL\n");
				goto bad;
				}
			}
#endif
a642 2
		else if	(strcmp(*argv,"-no_ecdhe") == 0)
			{ no_ecdhe=1; }
a654 4
#ifndef OPENSSL_NO_TLSEXT
		else if	(strcmp(*argv,"-no_ticket") == 0)
			{ off|=SSL_OP_NO_TICKET; }
#endif
a666 16
#ifndef OPENSSL_NO_DTLS1
		else if	(strcmp(*argv,"-dtls1") == 0)
			{ 
			meth=DTLSv1_server_method();
			socket_type = SOCK_DGRAM;
			}
		else if (strcmp(*argv,"-timeout") == 0)
			enable_timeouts = 1;
		else if (strcmp(*argv,"-mtu") == 0)
			{
			if (--argc < 1) goto bad;
			mtu = atol(*(++argv));
			}
		else if (strcmp(*argv, "-chain") == 0)
			cert_chain = 1;
#endif
a683 19
#ifndef OPENSSL_NO_TLSEXT
		else if (strcmp(*argv,"-servername") == 0)
			{
			if (--argc < 1) goto bad;
			tlsextcbp.servername= *(++argv);
			}
		else if (strcmp(*argv,"-servername_fatal") == 0)
			{ tlsextcbp.extension_error = SSL_TLSEXT_ERR_ALERT_FATAL; }
		else if	(strcmp(*argv,"-cert2") == 0)
			{
			if (--argc < 1) goto bad;
			s_cert_file2= *(++argv);
			}
		else if	(strcmp(*argv,"-key2") == 0)
			{
			if (--argc < 1) goto bad;
			s_key_file2= *(++argv);
			}
#endif
a706 81
	if (!app_passwd(bio_err, passarg, dpassarg, &pass, &dpass))
		{
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
		}


	if (s_key_file == NULL)
		s_key_file = s_cert_file;
#ifndef OPENSSL_NO_TLSEXT
	if (s_key_file2 == NULL)
		s_key_file2 = s_cert_file2;
#endif

	if (nocert == 0)
		{
		s_key = load_key(bio_err, s_key_file, s_key_format, 0, pass, e,
		       "server certificate private key file");
		if (!s_key)
			{
			ERR_print_errors(bio_err);
			goto end;
			}

		s_cert = load_cert(bio_err,s_cert_file,s_cert_format,
			NULL, e, "server certificate file");

		if (!s_cert)
			{
			ERR_print_errors(bio_err);
			goto end;
			}

#ifndef OPENSSL_NO_TLSEXT
		if (tlsextcbp.servername) 
			{
			s_key2 = load_key(bio_err, s_key_file2, s_key_format, 0, pass, e,
				"second server certificate private key file");
			if (!s_key2)
				{
				ERR_print_errors(bio_err);
				goto end;
				}
			
			s_cert2 = load_cert(bio_err,s_cert_file2,s_cert_format,
				NULL, e, "second server certificate file");
			
			if (!s_cert2)
				{
				ERR_print_errors(bio_err);
				goto end;
				}
			}
#endif
		}
	if (s_dcert_file)
		{

		if (s_dkey_file == NULL)
			s_dkey_file = s_dcert_file;

		s_dkey = load_key(bio_err, s_dkey_file, s_dkey_format,
				0, dpass, e,
			       "second certificate private key file");
		if (!s_dkey)
			{
			ERR_print_errors(bio_err);
			goto end;
			}

		s_dcert = load_cert(bio_err,s_dcert_file,s_dcert_format,
				NULL, e, "second server certificate file");

		if (!s_dcert)
			{
			ERR_print_errors(bio_err);
			goto end;
			}

		}

d729 1
a729 1
#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_ECDSA)
a736 4
#ifndef OPENSSL_NO_TLSEXT
		s_cert_file2=NULL;
		s_key_file2=NULL;
#endif
a764 4
	/* DTLS: partial reads end up discarding unread UDP bytes :-( 
	 * Setting read ahead solves this problem.
	 */
	if (socket_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx, 1);
a790 56
#ifndef OPENSSL_NO_TLSEXT
	if (s_cert2)
		{
		ctx2=SSL_CTX_new(meth);
		if (ctx2 == NULL)
			{
			ERR_print_errors(bio_err);
			goto end;
			}
		}
	
	if (ctx2)
		{
		BIO_printf(bio_s_out,"Setting secondary ctx parameters\n");

		if (session_id_prefix)
			{
			if(strlen(session_id_prefix) >= 32)
				BIO_printf(bio_err,
					"warning: id_prefix is too long, only one new session will be possible\n");
			else if(strlen(session_id_prefix) >= 16)
				BIO_printf(bio_err,
					"warning: id_prefix is too long if you use SSLv2\n");
			if(!SSL_CTX_set_generate_session_id(ctx2, generate_session_id))
				{
				BIO_printf(bio_err,"error setting 'id_prefix'\n");
				ERR_print_errors(bio_err);
				goto end;
				}
			BIO_printf(bio_err,"id_prefix '%s' set.\n", session_id_prefix);
			}
		SSL_CTX_set_quiet_shutdown(ctx2,1);
		if (bugs) SSL_CTX_set_options(ctx2,SSL_OP_ALL);
		if (hack) SSL_CTX_set_options(ctx2,SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);
		SSL_CTX_set_options(ctx2,off);

		/* DTLS: partial reads end up discarding unread UDP bytes :-( 
		 * Setting read ahead solves this problem.
		 */
		if (socket_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx2, 1);


		if (state) SSL_CTX_set_info_callback(ctx2,apps_ssl_info_callback);

		SSL_CTX_sess_set_cache_size(ctx2,128);

		if ((!SSL_CTX_load_verify_locations(ctx2,CAfile,CApath)) ||
			(!SSL_CTX_set_default_verify_paths(ctx2)))
			{
			ERR_print_errors(bio_err);
			}
		store = SSL_CTX_get_cert_store(ctx2);
		X509_STORE_set_flags(store, vflags);
		}
#endif 

a813 18
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2)
			{
			if (!dhfile)
				{ 
				DH *dh2=load_dh_param(s_cert_file2);
				if (dh2 != NULL)
					{
					BIO_printf(bio_s_out,"Setting temp DH parameters\n");
					(void)BIO_flush(bio_s_out);

					DH_free(dh);
					dh = dh2;
					}
				}
			SSL_CTX_set_tmp_dh(ctx2,dh);
			}
#endif
a816 49

#ifndef OPENSSL_NO_ECDH
	if (!no_ecdhe)
		{
		EC_KEY *ecdh=NULL;

		if (named_curve)
			{
			int nid = OBJ_sn2nid(named_curve);

			if (nid == 0)
				{
				BIO_printf(bio_err, "unknown curve name (%s)\n", 
					named_curve);
				goto end;
				}
			ecdh = EC_KEY_new_by_curve_name(nid);
			if (ecdh == NULL)
				{
				BIO_printf(bio_err, "unable to create curve (%s)\n", 
					named_curve);
				goto end;
				}
			}

		if (ecdh != NULL)
			{
			BIO_printf(bio_s_out,"Setting temp ECDH parameters\n");
			}
		else
			{
			BIO_printf(bio_s_out,"Using default temp ECDH parameters\n");
			ecdh = EC_KEY_new_by_curve_name(NID_sect163r2);
			if (ecdh == NULL) 
				{
				BIO_printf(bio_err, "unable to create curve (sect163r2)\n");
				goto end;
				}
			}
		(void)BIO_flush(bio_s_out);

		SSL_CTX_set_tmp_ecdh(ctx,ecdh);
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2) 
			SSL_CTX_set_tmp_ecdh(ctx2,ecdh);
#endif
		EC_KEY_free(ecdh);
		}
#endif
d818 1
a818 1
	if (!set_cert_key_stuff(ctx,s_cert,s_key))
d820 1
a820 5
#ifndef OPENSSL_NO_TLSEXT
	if (ctx2 && !set_cert_key_stuff(ctx2,s_cert2,s_key2))
		goto end; 
#endif
	if (s_dcert != NULL)
d822 1
a822 1
		if (!set_cert_key_stuff(ctx,s_dcert,s_dkey))
a828 1
		{
a829 5
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2) 
			SSL_CTX_set_tmp_rsa_callback(ctx2,tmp_rsa_cb);
#endif	
		}
a844 10
#ifndef OPENSSL_NO_TLSEXT
			if (ctx2)
				{
				if (!SSL_CTX_set_tmp_rsa(ctx2,rsa))
					{
					ERR_print_errors(bio_err);
					goto end;
					}
				}
#endif
a855 8
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2 && !SSL_CTX_set_cipher_list(ctx2,cipher))
			{
			BIO_printf(bio_err,"error setting cipher list\n");
			ERR_print_errors(bio_err);
			goto end;
			}
#endif
a860 14
#ifndef OPENSSL_NO_TLSEXT
	if (ctx2)
		{
		SSL_CTX_set_verify(ctx2,s_server_verify,verify_callback);
		SSL_CTX_set_session_id_context(ctx2,(void*)&s_server_session_id_context,
			sizeof s_server_session_id_context);

		tlsextcbp.biodebug = bio_s_out;
		SSL_CTX_set_tlsext_servername_callback(ctx2, ssl_servername_cb);
		SSL_CTX_set_tlsext_servername_arg(ctx2, &tlsextcbp);
		SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);
		SSL_CTX_set_tlsext_servername_arg(ctx, &tlsextcbp);
		}
#endif
d862 2
a863 7
		{
		SSL_CTX_set_client_CA_list(ctx,SSL_load_client_CA_file(CAfile));
#ifndef OPENSSL_NO_TLSEXT
		if (ctx2) 
			SSL_CTX_set_client_CA_list(ctx2,SSL_load_client_CA_file(CAfile));
#endif
		}
d866 1
a866 1
		do_server(port,socket_type,&accept_socket,www_body, context);
d868 1
a868 1
		do_server(port,socket_type,&accept_socket,sv_body, context);
a872 19
	if (s_cert)
		X509_free(s_cert);
	if (s_dcert)
		X509_free(s_dcert);
	if (s_key)
		EVP_PKEY_free(s_key);
	if (s_dkey)
		EVP_PKEY_free(s_dkey);
	if (pass)
		OPENSSL_free(pass);
	if (dpass)
		OPENSSL_free(dpass);
#ifndef OPENSSL_NO_TLSEXT
	if (ctx2 != NULL) SSL_CTX_free(ctx2);
	if (s_cert2)
		X509_free(s_cert2);
	if (s_key2)
		EVP_PKEY_free(s_key2);
#endif
d875 1
a875 1
        BIO_free(bio_s_out);
d886 1
a886 1
	BIO_printf(bio,"%4ld client connects (SSL_connect())\n",
d888 1
a888 1
	BIO_printf(bio,"%4ld client renegotiates (SSL_connect())\n",
d890 1
a890 1
	BIO_printf(bio,"%4ld client connects that finished\n",
d892 1
a892 1
	BIO_printf(bio,"%4ld server accepts (SSL_accept())\n",
d894 1
a894 1
	BIO_printf(bio,"%4ld server renegotiates (SSL_accept())\n",
d896 1
a896 1
	BIO_printf(bio,"%4ld server accepts that finished\n",
d898 5
a902 5
	BIO_printf(bio,"%4ld session cache hits\n",SSL_CTX_sess_hits(ssl_ctx));
	BIO_printf(bio,"%4ld session cache misses\n",SSL_CTX_sess_misses(ssl_ctx));
	BIO_printf(bio,"%4ld session cache timeouts\n",SSL_CTX_sess_timeouts(ssl_ctx));
	BIO_printf(bio,"%4ld callback cache hits\n",SSL_CTX_sess_cb_hits(ssl_ctx));
	BIO_printf(bio,"%4ld cache full overflows (%ld allowed)\n",
d916 1
a916 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)
a938 13
#ifndef OPENSSL_NO_TLSEXT
	if (s_tlsextdebug)
		{
		SSL_set_tlsext_debug_callback(con, tlsext_cb);
		SSL_set_tlsext_debug_arg(con, bio_s_out);
		}
	if (s_tlsextstatus)
		{
		SSL_CTX_set_tlsext_status_cb(ctx, cert_status_cb);
		tlscstatp.err = bio_err;
		SSL_CTX_set_tlsext_status_arg(ctx, &tlscstatp);
		}
#endif
d954 1
a954 33
	if (SSL_version(con) == DTLS1_VERSION)
		{
		struct timeval timeout;

		sbio=BIO_new_dgram(s,BIO_NOCLOSE);

		if ( enable_timeouts)
			{
			timeout.tv_sec = 0;
			timeout.tv_usec = DGRAM_RCV_TIMEOUT;
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);
			
			timeout.tv_sec = 0;
			timeout.tv_usec = DGRAM_SND_TIMEOUT;
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);
			}

		
		if ( mtu > 0)
			{
			SSL_set_options(con, SSL_OP_NO_QUERY_MTU);
			SSL_set_mtu(con, mtu);
			}
		else
			/* want to do MTU discovery */
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);

        /* turn on cookie exchange */
        SSL_set_options(con, SSL_OP_COOKIE_EXCHANGE);
		}
	else
		sbio=BIO_new_socket(s,BIO_NOCLOSE);

d969 2
a970 2
		BIO_set_callback(SSL_get_rbio(con),bio_dump_callback);
		BIO_set_callback_arg(SSL_get_rbio(con),(char *)bio_s_out);
a976 7
#ifndef OPENSSL_NO_TLSEXT
	if (s_tlsextdebug)
		{
		SSL_set_tlsext_debug_callback(con, tlsext_cb);
		SSL_set_tlsext_debug_arg(con, bio_s_out);
		}
#endif
d990 1
a990 1
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE)
d1000 1
a1000 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)
d1060 1
a1060 2
					if (SSL_version(con) != DTLS1_VERSION)
                        SHUTDOWN(s);
d1089 1
a1089 1
					static const char *str="Lets print some clear text\n";
d1273 1
a1273 1
static DH *load_dh_param(const char *dhfile)
a1340 7
#ifndef OPENSSL_NO_TLSEXT
		if (s_tlsextdebug)
			{
			SSL_set_tlsext_debug_callback(con, tlsext_cb);
			SSL_set_tlsext_debug_arg(con, bio_s_out);
			}
#endif
d1372 2
a1373 2
		BIO_set_callback(SSL_get_rbio(con),bio_dump_callback);
		BIO_set_callback_arg(SSL_get_rbio(con),(char *)bio_s_out);
d1420 1
a1420 3
#if defined(OPENSSL_SYS_NETWARE)
            delay(1000);
#elif !defined(OPENSSL_SYS_MSDOS) && !defined(__DJGPP__)
d1439 1
a1439 1
			static const char *space="                          ";
d1519 1
a1519 1
			static const char *text="HTTP/1.0 200 ok\r\nContent-type: text/plain\r\n\r\n";
a1694 1
	BIGNUM *bn = NULL;
d1697 1
a1697 3
	if (!rsa_tmp && ((bn = BN_new()) == NULL))
		BIO_printf(bio_err,"Allocation error in generating RSA key\n");
	if (!rsa_tmp && bn)
d1704 1
a1704 6
		if(!BN_set_word(bn, RSA_F4) || ((rsa_tmp = RSA_new()) == NULL) ||
				!RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL))
			{
			if(rsa_tmp) RSA_free(rsa_tmp);
			rsa_tmp = NULL;
			}
a1709 1
		BN_free(bn);
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a744 4
#ifndef OPENSSL_NO_JPAKE
static char *jpake_secret = NULL;
#endif

d763 1
d765 1
d777 1
a1073 8
			
#endif
#ifndef OPENSSL_NO_JPAKE
		else if (strcmp(*argv,"-jpake") == 0)
			{
			if (--argc < 1) goto bad;
			jpake_secret = *(++argv);
			}
a1675 5
#ifndef OPENSSL_NO_JPAKE
	if(jpake_secret)
		jpake_server_auth(bio_s_out, sbio, jpake_secret);
#endif

@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
a115 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
a123 1
#include <ctype.h>
d128 1
d166 8
a178 4
#if defined(OPENSSL_SYS_BEOS_R5)
#include <fcntl.h>
#endif

d199 8
d248 1
a248 1
extern int verify_depth, verify_return_error;
d286 4
a289 2
static long socket_mtu;
#ifndef OPENSSL_NO_DTLS1
a290 58
#endif

#ifndef OPENSSL_NO_PSK
static char *psk_identity="Client_identity";
char *psk_key=NULL; /* by default PSK is not used */

static unsigned int psk_server_cb(SSL *ssl, const char *identity,
	unsigned char *psk, unsigned int max_psk_len)
	{
	unsigned int psk_len = 0;
	int ret;
	BIGNUM *bn = NULL;

	if (s_debug)
		BIO_printf(bio_s_out,"psk_server_cb\n");
	if (!identity)
		{
		BIO_printf(bio_err,"Error: client did not send PSK identity\n");
		goto out_err;
		}
	if (s_debug)
		BIO_printf(bio_s_out,"identity_len=%d identity=%s\n",
			identity ? (int)strlen(identity) : 0, identity);

	/* here we could lookup the given identity e.g. from a database */
  	if (strcmp(identity, psk_identity) != 0)
		{
                BIO_printf(bio_s_out, "PSK error: client identity not found"
			   " (got '%s' expected '%s')\n", identity,
			   psk_identity);
		goto out_err;
                }
	if (s_debug)
		BIO_printf(bio_s_out, "PSK client identity found\n");

	/* convert the PSK key to binary */
	ret = BN_hex2bn(&bn, psk_key);
	if (!ret)
		{
		BIO_printf(bio_err,"Could not convert PSK key '%s' to BIGNUM\n", psk_key);
		if (bn)
			BN_free(bn);
		return 0;
		}
	if (BN_num_bytes(bn) > (int)max_psk_len)
		{
		BIO_printf(bio_err,"psk buffer of callback is too small (%d) for key (%d)\n",
			max_psk_len, BN_num_bytes(bn));
		BN_free(bn);
		return 0;
		}

	ret = BN_bn2bin(bn, psk);
	BN_free(bn);

	if (ret < 0)
		goto out_err;
	psk_len = (unsigned int)ret;
a291 9
	if (s_debug)
		BIO_printf(bio_s_out, "fetched PSK len=%d\n", psk_len);
        return psk_len;
 out_err:
	if (s_debug)
		BIO_printf(bio_err, "Error in PSK server callback\n");
	return 0;
        }
#endif
d356 1
a356 1
	                   "                 (default is nistp256).\n");
a372 7
#ifndef OPENSSL_NO_PSK
	BIO_printf(bio_err," -psk_hint arg - PSK identity hint to use\n");
	BIO_printf(bio_err," -psk arg      - PSK in hex (without 0x)\n");
# ifndef OPENSSL_NO_JPAKE
	BIO_printf(bio_err," -jpake arg    - JPAKE secret to use\n");
# endif
#endif
d378 1
a378 1
	BIO_printf(bio_err," -mtu          - Set link layer MTU\n");
a407 1
	BIO_printf(bio_err," -legacy_renegotiation - enable use of legacy renegotiation (dangerous)\n");
d590 1
a590 1
			BIO_printf(p->biodebug,"Switching server context.\n");
d629 1
a629 1
	STACK_OF(OPENSSL_STRING) *aia = NULL;
d651 1
a651 1
		if (!OCSP_parse_url(sk_OPENSSL_STRING_value(aia, 0),
d659 1
a659 1
					sk_OPENSSL_STRING_value(aia, 0));
d704 1
a704 1
	resp = process_responder(err, req, host, path, port, use_ssl, NULL,
a742 1

d751 2
a752 2
	X509_VERIFY_PARAM *vpm = NULL;
	int badarg = 0;
d765 2
a766 2
	const SSL_METHOD *meth=NULL;
	int socket_type=SOCK_STREAM;
a774 1
	int no_cache = 0;
d782 1
a782 4
#ifndef OPENSSL_NO_PSK
	/* by default do not send a PSK identity hint */
	static char *psk_identity_hint=NULL;
#endif
d914 1
a914 3
		else if (strcmp(*argv,"-no_cache") == 0)
			no_cache = 1;
		else if (args_verify(&argv, &argc, &badarg, bio_err, &vpm))
d916 5
a920 3
			if (badarg)
				goto bad;
			continue;
a921 2
		else if (strcmp(*argv,"-verify_return_error") == 0)
			verify_return_error = 1;
a923 2
		else if (strcmp(*argv,"-legacy_renegotiation") == 0)
			off|=SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
a995 21
#ifndef OPENSSL_NO_PSK
                else if (strcmp(*argv,"-psk_hint") == 0)
			{
                        if (--argc < 1) goto bad;
                        psk_identity_hint= *(++argv);
                        }
                else if (strcmp(*argv,"-psk") == 0)
			{
			size_t i;

			if (--argc < 1) goto bad;
			psk_key=*(++argv);
			for (i=0; i<strlen(psk_key); i++)
				{
				if (isxdigit((int)psk_key[i]))
					continue;
				BIO_printf(bio_err,"Not a hex number '%s'\n",*argv);
				goto bad;
				}
			}
#endif
a1007 2
		else if	(strcmp(*argv,"-no_comp") == 0)
			{ off|=SSL_OP_NO_COMPRESSION; }
d1035 1
a1035 1
			socket_mtu = atol(*(++argv));
d1077 1
a1077 1
#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)
a1099 20
#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)
	if (jpake_secret)
		{
		if (psk_key)
			{
			BIO_printf(bio_err,
				   "Can't use JPAKE and PSK together\n");
			goto end;
			}
		psk_identity = "JPAKE";
		if (cipher)
			{
			BIO_printf(bio_err, "JPAKE sets cipher to PSK\n");
			goto end;
			}
		cipher = "PSK";
		}

#endif

a1161 2


d1256 2
a1257 4
	if (no_cache)
		SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);
	else
		SSL_CTX_sess_set_cache_size(ctx,128);
d1278 2
a1279 3
	if (vpm)
		SSL_CTX_set1_param(ctx, vpm);

d1315 1
d1321 1
d1324 1
a1324 4
		if (no_cache)
			SSL_CTX_set_session_cache_mode(ctx2,SSL_SESS_CACHE_OFF);
		else
			SSL_CTX_sess_set_cache_size(ctx2,128);
d1331 2
a1332 2
		if (vpm)
			SSL_CTX_set1_param(ctx2, vpm);
d1336 1
d1412 1
a1412 1
			ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
d1415 1
a1415 1
				BIO_printf(bio_err, "unable to create curve (nistp256)\n");
d1450 1
a1450 1
#endif		
d1483 3
a1485 15
#ifndef OPENSSL_NO_PSK
#ifdef OPENSSL_NO_JPAKE
	if (psk_key != NULL)
#else
	if (psk_key != NULL || jpake_secret)
#endif
		{
		if (s_debug)
			BIO_printf(bio_s_out, "PSK key given or JPAKE in use, setting server callback\n");
		SSL_CTX_set_psk_server_callback(ctx, psk_server_cb);
		}

	if (!SSL_CTX_use_psk_identity_hint(ctx, psk_identity_hint))
		{
		BIO_printf(bio_err,"error setting PSK identity hint to context\n");
a1487 11
		}
#endif

	if (cipher != NULL)
		{
		if(!SSL_CTX_set_cipher_list(ctx,cipher))
			{
			BIO_printf(bio_err,"error setting cipher list\n");
			ERR_print_errors(bio_err);
			goto end;
			}
d1496 1
a1496 1
		}
a1500 4
	/* Set DTLS cookie generation and verification callbacks */
	SSL_CTX_set_cookie_generate_cb(ctx, generate_cookie_callback);
	SSL_CTX_set_cookie_verify_cb(ctx, verify_cookie_callback);

a1514 1

a1522 1

a1523 1
	(void)BIO_flush(bio_s_out);
d1594 1
a1594 2
	struct timeval timeout;
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)
a1595 2
#else
	struct timeval *timeoutp;
a1643 5
#if 0
#ifdef TLSEXT_TYPE_opaque_prf_input
	SSL_set_tlsext_opaque_prf_input(con, "Test server", 11);
#endif
#endif
d1647 1
d1651 1
a1651 1
		if (enable_timeouts)
d1662 2
a1663 1
		if (socket_mtu > 28)
d1666 1
a1666 1
			SSL_set_mtu(con, socket_mtu - 28);
d1725 2
a1726 2
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE) && !defined(OPENSSL_SYS_BEOS_R5)
			openssl_fdset(fileno(stdin),&readfds);
d1728 1
a1728 1
			openssl_fdset(s,&readfds);
a1746 11
#elif defined(OPENSSL_SYS_BEOS_R5)
			/* Under BeOS-R5 the situation is similar to DOS */
			tv.tv_sec = 1;
			tv.tv_usec = 0;
			(void)fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);
			i=select(width,(void *)&readfds,NULL,NULL,&tv);
			if ((i < 0) || (!i && read(fileno(stdin), buf, 0) < 0))
				continue;
			if (read(fileno(stdin), buf, 0) >= 0)
				read_from_terminal = 1;
			(void)fcntl(fileno(stdin), F_SETFL, 0);
d1748 1
a1748 13
			if ((SSL_version(con) == DTLS1_VERSION) &&
				DTLSv1_get_timeout(con, &timeout))
				timeoutp = &timeout;
			else
				timeoutp = NULL;

			i=select(width,(void *)&readfds,NULL,NULL,timeoutp);

			if ((SSL_version(con) == DTLS1_VERSION) && DTLSv1_handle_timeout(con) > 0)
				{
				BIO_printf(bio_err,"TIMEOUT occured\n");
				}

d1762 1
a1762 1
				i=raw_read_stdin(buf, bufsize/2);
d1781 1
a1781 1
				i=raw_read_stdin(buf,bufsize);
a1800 1

d1897 1
a1897 1
					raw_write_stdout(buf,
d1921 1
a1921 3
	if (con != NULL)
		{
		BIO_printf(bio_s_out,"shutting down SSL\n");
d1923 1
a1923 1
		SSL_set_shutdown(con,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
d1925 1
a1925 1
		SSL_shutdown(con);
d1927 1
a1927 2
		SSL_free(con);
		}
a2004 2
	BIO_printf(bio_s_out, "Secure Renegotiation IS%s supported\n",
		      SSL_get_secure_renegotiation_support(con) ? "" : " NOT");
d2049 1
d2051 1
a2051 1
	const SSL_CIPHER *c;
d2321 8
a2328 1
			if (app_isdir(p)>0)
@


1.1.1.10
log
@import OpenSSL 1.0.0e
@
text
@d2257 1
a2257 1
	int i,j,k,dot;
d2261 1
d2332 1
d2562 1
@


1.1.1.11
log
@import OpenSSL-1.0.1c
@
text
@a188 3
#ifndef OPENSSL_NO_SRP
#include <openssl/srp.h>
#endif
a292 3
static char *keymatexportlabel=NULL;
static int keymatexportlen=20;

a304 1

a371 46
#ifndef OPENSSL_NO_SRP
/* This is a context that we pass to callbacks */
typedef struct srpsrvparm_st
	{
	char *login;
	SRP_VBASE *vb;
	SRP_user_pwd *user;
	} srpsrvparm;

/* This callback pretends to require some asynchronous logic in order to obtain
   a verifier. When the callback is called for a new connection we return
   with a negative value. This will provoke the accept etc to return with
   an LOOKUP_X509. The main logic of the reinvokes the suspended call 
   (which would normally occur after a worker has finished) and we
   set the user parameters. 
*/
static int MS_CALLBACK ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
	{
	srpsrvparm *p = (srpsrvparm *)arg;
	if (p->login == NULL && p->user == NULL )
		{
		p->login = SSL_get_srp_username(s);
		BIO_printf(bio_err, "SRP username = \"%s\"\n", p->login);
		return (-1) ;
		}

	if (p->user == NULL)
		{
		BIO_printf(bio_err, "User %s doesn't exist\n", p->login);
		return SSL3_AL_FATAL;
		}
	if (SSL_set_srp_server_param(s, p->user->N, p->user->g, p->user->s, p->user->v,
				     p->user->info) < 0)
		{
		*ad = SSL_AD_INTERNAL_ERROR;
		return SSL3_AL_FATAL;
		}
	BIO_printf(bio_err, "SRP parameters set: username = \"%s\" info=\"%s\" \n", p->login,p->user->info);
	/* need to check whether there are memory leaks */
	p->user = NULL;
	p->login = NULL;
	return SSL_ERROR_NONE;
	}

#endif

a458 4
#ifndef OPENSSL_NO_SRP
	BIO_printf(bio_err," -srpvfile file      - The verifier file for SRP\n");
	BIO_printf(bio_err," -srpuserseed string - A seed string for a default user salt.\n");
#endif
a460 2
	BIO_printf(bio_err," -tls1_2       - Just talk TLSv1.2\n");
	BIO_printf(bio_err," -tls1_1       - Just talk TLSv1.1\n");
a468 2
	BIO_printf(bio_err," -no_tls1_1    - Just disable TLSv1.1\n");
	BIO_printf(bio_err," -no_tls1_2    - Just disable TLSv1.2\n");
a494 4
# ifndef OPENSSL_NO_NEXTPROTONEG
	BIO_printf(bio_err," -nextprotoneg arg - set the advertised protocols for the NPN extension (comma-separated list)\n");
# endif
        BIO_printf(bio_err," -use_srtp profiles - Offer SRTP key management with a colon-separated profile list\n");
a495 2
	BIO_printf(bio_err," -keymatexport label   - Export keying material using label\n");
	BIO_printf(bio_err," -keymatexportlen len  - Export len bytes of keying material (default 20)\n");
a828 20

# ifndef OPENSSL_NO_NEXTPROTONEG
/* This is the context that we pass to next_proto_cb */
typedef struct tlsextnextprotoctx_st {
	unsigned char *data;
	unsigned int len;
} tlsextnextprotoctx;

static int next_proto_cb(SSL *s, const unsigned char **data, unsigned int *len, void *arg)
	{
	tlsextnextprotoctx *next_proto = arg;

	*data = next_proto->data;
	*len = next_proto->len;

	return SSL_TLSEXT_ERR_OK;
	}
# endif  /* ndef OPENSSL_NO_NEXTPROTONEG */


a835 4
#ifndef OPENSSL_NO_SRP
	static srpsrvparm srp_callback_parm;
#endif
static char *srtp_profiles = NULL;
d867 2
a869 4
# ifndef OPENSSL_NO_NEXTPROTONEG
	const char *next_proto_neg_in = NULL;
	tlsextnextprotoctx next_proto;
# endif
d875 6
a880 3
#ifndef OPENSSL_NO_SRP
	char *srpuserseed = NULL;
	char *srp_verifier_file = NULL;
a881 1
	meth=SSLv23_server_method();
d1106 1
a1106 1
				if (isxdigit((unsigned char)psk_key[i]))
a1112 14
#ifndef OPENSSL_NO_SRP
		else if (strcmp(*argv, "-srpvfile") == 0)
			{
			if (--argc < 1) goto bad;
			srp_verifier_file = *(++argv);
			meth=TLSv1_server_method();
			}
		else if (strcmp(*argv, "-srpuserseed") == 0)
			{
			if (--argc < 1) goto bad;
			srpuserseed = *(++argv);
			meth=TLSv1_server_method();
			}
#endif
a1124 4
		else if	(strcmp(*argv,"-no_tls1_1") == 0)
			{ off|=SSL_OP_NO_TLSv1_1; }
		else if	(strcmp(*argv,"-no_tls1_2") == 0)
			{ off|=SSL_OP_NO_TLSv1_2; }
a1141 4
		else if	(strcmp(*argv,"-tls1_1") == 0)
			{ meth=TLSv1_1_server_method(); }
		else if	(strcmp(*argv,"-tls1_2") == 0)
			{ meth=TLSv1_2_server_method(); }
d1194 1
a1194 7
# ifndef OPENSSL_NO_NEXTPROTONEG
		else if	(strcmp(*argv,"-nextprotoneg") == 0)
			{
			if (--argc < 1) goto bad;
			next_proto_neg_in = *(++argv);
			}
# endif
a1202 16
		else if (strcmp(*argv,"-use_srtp") == 0)
			{
			if (--argc < 1) goto bad;
			srtp_profiles = *(++argv);
			}
		else if (strcmp(*argv,"-keymatexport") == 0)
			{
			if (--argc < 1) goto bad;
			keymatexportlabel= *(++argv);
			}
		else if (strcmp(*argv,"-keymatexportlen") == 0)
			{
			if (--argc < 1) goto bad;
			keymatexportlen=atoi(*(++argv));
			if (keymatexportlen == 0) goto bad;
			}
a1298 16

# ifndef OPENSSL_NO_NEXTPROTONEG
		if (next_proto_neg_in)
			{
			unsigned short len;
			next_proto.data = next_protos_parse(&len,
				next_proto_neg_in);
			if (next_proto.data == NULL)
				goto end;
			next_proto.len = len;
			}
		else
			{
			next_proto.data = NULL;
			}
# endif
a1401 3
	if (srtp_profiles != NULL)
		SSL_CTX_set_tlsext_use_srtp(ctx, srtp_profiles);

a1478 5

# ifndef OPENSSL_NO_NEXTPROTONEG
	if (next_proto.data)
		SSL_CTX_set_next_protos_advertised_cb(ctx, next_proto_cb, &next_proto);
# endif
a1686 19
#ifndef OPENSSL_NO_SRP
	if (srp_verifier_file != NULL)
		{
		srp_callback_parm.vb = SRP_VBASE_new(srpuserseed);
		srp_callback_parm.user = NULL;
		srp_callback_parm.login = NULL;
		if ((ret = SRP_VBASE_init(srp_callback_parm.vb, srp_verifier_file)) != SRP_NO_ERROR)
			{
			BIO_printf(bio_err,
				   "Cannot initialize SRP verifier file \"%s\":ret=%d\n",
				   srp_verifier_file, ret);
				goto end;
			}
		SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE,verify_callback);
		SSL_CTX_set_srp_cb_arg(ctx, &srp_callback_parm);  			
		SSL_CTX_set_srp_username_callback(ctx, ssl_srp_server_param_cb);
		}
	else
#endif
a1767 3
#ifndef OPENSSL_NO_KRB5
	KSSL_CTX *kctx;
#endif
d1808 1
a1808 1
		if ((kctx = kssl_ctx_new()) != NULL)
d1810 4
a1813 3
			SSL_set0_kssl_ctx(con, kctx);
                        kssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);
                        kssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);
d1876 1
a1876 1
		SSL_set_debug(con, 1);
a2004 10
#ifndef OPENSSL_NO_HEARTBEATS
				if ((buf[0] == 'B') &&
					((buf[1] == '\n') || (buf[1] == '\r')))
					{
					BIO_printf(bio_err,"HEARTBEATING\n");
					SSL_heartbeat(con);
					i=0;
					continue;
					}
#endif
a2047 12
#ifndef OPENSSL_NO_SRP
				while (SSL_get_error(con,k) == SSL_ERROR_WANT_X509_LOOKUP)
					{
					BIO_printf(bio_s_out,"LOOKUP renego during write\n");
					srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
					if (srp_callback_parm.user) 
						BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
					else 
						BIO_printf(bio_s_out,"LOOKUP not successful\n");
						k=SSL_write(con,&(buf[l]),(unsigned int)i);
					}
#endif
a2094 12
#ifndef OPENSSL_NO_SRP
				while (SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP)
					{
					BIO_printf(bio_s_out,"LOOKUP renego during read\n");
					srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
					if (srp_callback_parm.user) 
						BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
					else 
						BIO_printf(bio_s_out,"LOOKUP not successful\n");
					i=SSL_read(con,(char *)buf,bufsize);
					}
#endif
d2107 1
a2161 9
#ifndef OPENSSL_NO_KRB5
	char *client_princ;
#endif
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	const unsigned char *next_proto_neg;
	unsigned next_proto_neg_len;
#endif
	unsigned char *exportedkeymat;

d2163 1
a2163 14
	i=SSL_accept(con);
#ifndef OPENSSL_NO_SRP
	while (i <= 0 &&  SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP) 
		{
			BIO_printf(bio_s_out,"LOOKUP during accept %s\n",srp_callback_parm.login);
			srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
			if (srp_callback_parm.user) 
				BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
			else 
				BIO_printf(bio_s_out,"LOOKUP not successful\n");
			i=SSL_accept(con);
		}
#endif
	if (i <= 0)
d2201 1
a2201 18
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	SSL_get0_next_proto_negotiated(con, &next_proto_neg, &next_proto_neg_len);
	if (next_proto_neg)
		{
		BIO_printf(bio_s_out,"NEXTPROTO is ");
		BIO_write(bio_s_out, next_proto_neg, next_proto_neg_len);
		BIO_printf(bio_s_out, "\n");
		}
#endif
	{
	SRTP_PROTECTION_PROFILE *srtp_profile
	  = SSL_get_selected_srtp_profile(con);

	if(srtp_profile)
		BIO_printf(bio_s_out,"SRTP Extension negotiated, profile=%s\n",
			   srtp_profile->name);
	}
	if (SSL_cache_hit(con)) BIO_printf(bio_s_out,"Reused session-id\n");
d2204 1
a2204 2
		BIO_printf(bio_s_out,
			   "Peer has incorrect TLSv1 block padding\n");
d2206 1
a2206 2
	client_princ = kssl_ctx_get0_client_princ(SSL_get0_kssl_ctx(con));
	if (client_princ != NULL)
d2209 1
a2209 1
								client_princ);
a2213 29
	if (keymatexportlabel != NULL)
		{
		BIO_printf(bio_s_out, "Keying material exporter:\n");
		BIO_printf(bio_s_out, "    Label: '%s'\n", keymatexportlabel);
		BIO_printf(bio_s_out, "    Length: %i bytes\n",
			   keymatexportlen);
		exportedkeymat = OPENSSL_malloc(keymatexportlen);
		if (exportedkeymat != NULL)
			{
			if (!SSL_export_keying_material(con, exportedkeymat,
						        keymatexportlen,
						        keymatexportlabel,
						        strlen(keymatexportlabel),
						        NULL, 0, 0))
				{
				BIO_printf(bio_s_out, "    Error\n");
				}
			else
				{
				BIO_printf(bio_s_out, "    Keying material: ");
				for (i=0; i<keymatexportlen; i++)
					BIO_printf(bio_s_out, "%02X",
						   exportedkeymat[i]);
				BIO_printf(bio_s_out, "\n");
				}
			OPENSSL_free(exportedkeymat);
			}
		}

a2230 3
#ifndef OPENSSL_NO_KRB5
	char *client_princ;
#endif
a2260 3
#ifndef OPENSSL_NO_KRB5
	KSSL_CTX *kctx;
#endif
d2292 1
a2292 1
	if ((kctx = kssl_ctx_new()) != NULL)
d2294 2
a2295 2
		kssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);
		kssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);
d2321 1
a2321 1
		SSL_set_debug(con, 1);
d2336 1
a2336 12
#ifndef OPENSSL_NO_SRP
			while (i <= 0 &&  SSL_get_error(con,i) == SSL_ERROR_WANT_X509_LOOKUP) 
		{
			BIO_printf(bio_s_out,"LOOKUP during accept %s\n",srp_callback_parm.login);
			srp_callback_parm.user = SRP_VBASE_get_by_user(srp_callback_parm.vb, srp_callback_parm.login); 
			if (srp_callback_parm.user) 
				BIO_printf(bio_s_out,"LOOKUP done %s\n",srp_callback_parm.user->info);
			else 
				BIO_printf(bio_s_out,"LOOKUP not successful\n");
			i=SSL_accept(con);
		}
#endif
d2442 1
a2442 1
			BIO_printf(io,(SSL_cache_hit(con)
@


1.1.1.12
log
@Import OpenSSL 1.0.1g
@
text
@a558 1
# ifndef OPENSSL_NO_SRTP
a559 1
# endif
a925 1
#ifndef OPENSSL_NO_SRTP
a926 1
#endif
d1209 1
a1209 1
			meth = TLSv1_server_method();
d1215 1
a1215 1
			meth = TLSv1_server_method();
a1321 1
#ifndef OPENSSL_NO_SRTP
a1326 1
#endif
d1434 16
a1452 15
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG) 
	if (next_proto_neg_in)
		{
		unsigned short len;
		next_proto.data = next_protos_parse(&len, next_proto_neg_in);
		if (next_proto.data == NULL)
			goto end;
		next_proto.len = len;
		}
	else
		{
		next_proto.data = NULL;
		}
#endif

a1552 1
#ifndef OPENSSL_NO_SRTP
a1554 1
#endif
d1733 1
a1733 1
	if (!set_cert_key_stuff(ctx, s_cert, s_key))
d1741 1
a1741 1
		if (!set_cert_key_stuff(ctx, s_dcert, s_dkey))
a1895 2
	if (vpm)
		X509_VERIFY_PARAM_free(vpm);
a1896 6
	if (tlscstatp.host)
		OPENSSL_free(tlscstatp.host);
	if (tlscstatp.port)
		OPENSSL_free(tlscstatp.port);
	if (tlscstatp.path)
		OPENSSL_free(tlscstatp.path);
a2435 1

a2444 1
#ifndef OPENSSL_NO_SRTP
a2452 1
#endif
a2702 5

			BIO_printf(io,
				"Secure Renegotiation IS%s supported\n",
		      		SSL_get_secure_renegotiation_support(con) ?
							"" : " NOT");
@


