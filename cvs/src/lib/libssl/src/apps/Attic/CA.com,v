head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.12
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	openssl_1_0_1_c:1.1.1.3
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.3
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	openssh_1_0_0_a:1.1.1.2
	OPENBSD_4_8:1.2.0.44
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.40
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.42
	OPENBSD_4_6_BASE:1.2
	openssl_0_9_8_k:1.1.1.1
	OPENBSD_4_5:1.2.0.38
	OPENBSD_4_5_BASE:1.2
	openssl_0_9_8_j:1.1.1.1
	openssl_0_9_8_h:1.1.1.1
	pre_openssl_0_9_8h:1.2
	OPENBSD_4_4:1.2.0.36
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.34
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.32
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.30
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.28
	OPENBSD_4_0_BASE:1.2
	openssl_0_9_7j:1.1.1.1
	openssl:1.1.1
	OPENBSD_3_9:1.2.0.26
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.24
	OPENBSD_3_8_BASE:1.2
	OPENSSL_0_9_7G:1.1.1.1
	OPENBSD_3_7:1.2.0.22
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.20
	OPENBSD_3_6_BASE:1.2
	OPENSSL_0_9_7D:1.1.1.1
	OPENBSD_3_5:1.2.0.18
	OPENBSD_3_5_BASE:1.2
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.2.0.16
	OPENBSD_3_4_BASE:1.2
	OPENSSL_0_9_7B:1.1.1.1
	OPENBSD_3_3:1.2.0.14
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@# @;


1.5
date	2014.04.13.15.25.27;	author miod;	state dead;
branches;
next	1.4;

1.4
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.01.22.58.50;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.08.03;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.35.13;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.29;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.10.01.22.54.00;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.11.03.02.32.06;	author djm;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@$! CA - wrapper around ca to make it easier to use ... basically ca requires
$!      some setup stuff to be done before you can use it and this makes
$!      things easier between now and when Eric is convinced to fix it :-)
$!
$! CA -newca ... will setup the right stuff
$! CA -newreq ... will generate a certificate request 
$! CA -sign ... will sign the generated request and output 
$!
$! At the end of that grab newreq.pem and newcert.pem (one has the key 
$! and the other the certificate) and cat them together and that is what
$! you want/need ... I'll make even this a little cleaner later.
$!
$!
$! 12-Jan-96 tjh    Added more things ... including CA -signcert which
$!                  converts a certificate to a request and then signs it.
$! 10-Jan-96 eay    Fixed a few more bugs and added the SSLEAY_CONFIG
$!                 environment variable so this can be driven from
$!                 a script.
$! 25-Jul-96 eay    Cleaned up filenames some more.
$! 11-Jun-96 eay    Fixed a few filename missmatches.
$! 03-May-96 eay    Modified to use 'openssl cmd' instead of 'cmd'.
$! 18-Apr-96 tjh    Original hacking
$!
$! Tim Hudson
$! tjh@@cryptsoft.com
$!
$!
$! default ssleay.cnf file has setup as per the following
$! demoCA ... where everything is stored
$
$ IF F$TYPE(SSLEAY_CONFIG) .EQS. "" THEN SSLEAY_CONFIG := SSLLIB:SSLEAY.CNF
$
$ DAYS   = "-days 365"
$ REQ    = openssl + " req " + SSLEAY_CONFIG
$ CA     = openssl + " ca " + SSLEAY_CONFIG
$ VERIFY = openssl + " verify"
$ X509   = openssl + " x509"
$ PKCS12 = openssl + " pkcs12"
$ echo   = "write sys$Output"
$ RET = 1
$!
$! 2010-12-20 SMS.
$! Use a concealed logical name to reduce command line lengths, to
$! avoid DCL errors on VAX:
$!     %DCL-W-TKNOVF, command element is too long - shorten
$! (Path segments like "openssl-1_0_1-stable-SNAP-20101217" accumulate
$! quickly.)
$!
$ CATOP = F$PARSE( F$ENVIRONMENT( "DEFAULT"), "[]")- "].;"+ ".demoCA.]"
$ define /translation_attributes = concealed CATOP 'CATOP'
$!
$ on error then goto clean_up
$ on control_y then goto clean_up
$!
$ CAKEY  = "CATOP:[private]cakey.pem"
$ CACERT = "CATOP:[000000]cacert.pem"
$
$ __INPUT := SYS$COMMAND
$!
$ i = 1
$opt_loop:
$ if i .gt. 8 then goto opt_loop_end
$
$ prog_opt = F$EDIT(P'i',"lowercase")
$
$ IF (prog_opt .EQS. "?" .OR. prog_opt .EQS. "-h" .OR. prog_opt .EQS. "-help") 
$ THEN
$   echo "usage: CA -newcert|-newreq|-newca|-sign|-verify" 
$   goto clean_up
$ ENDIF
$!
$ IF (prog_opt .EQS. "-input")
$ THEN
$   ! Get input from somewhere other than SYS$COMMAND
$   i = i + 1
$   __INPUT = P'i'
$   GOTO opt_loop_continue
$ ENDIF
$!
$ IF (prog_opt .EQS. "-newcert")
$ THEN
$   ! Create a certificate.
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
$   REQ -new -x509 -keyout newreq.pem -out newreq.pem 'DAYS'
$   RET=$STATUS
$   echo "Certificate (and private key) is in newreq.pem"
$   GOTO opt_loop_continue
$ ENDIF
$!
$ IF (prog_opt .EQS. "-newreq")
$ THEN
$   ! Create a certificate request
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
$   REQ -new -keyout newreq.pem -out newreq.pem 'DAYS'
$   RET=$STATUS
$   echo "Request (and private key) is in newreq.pem"
$   GOTO opt_loop_continue
$ ENDIF
$!
$ IF (prog_opt .EQS. "-newca")
$ THEN
$   ! If explicitly asked for or it doesn't exist then setup the directory
$   ! structure that Eric likes to manage things.
$   IF F$SEARCH( "CATOP:[000000]serial.") .EQS. ""
$   THEN
$     CREATE /DIRECTORY /PROTECTION=OWNER:RWED CATOP:[000000]
$     CREATE /DIRECTORY /PROTECTION=OWNER:RWED CATOP:[certs]
$     CREATE /DIRECTORY /PROTECTION=OWNER:RWED CATOP:[crl]
$     CREATE /DIRECTORY /PROTECTION=OWNER:RWED CATOP:[newcerts]
$     CREATE /DIRECTORY /PROTECTION=OWNER:RWED CATOP:[private]
$
$     OPEN /WRITE ser_file CATOP:[000000]serial. 
$     WRITE ser_file "01"
$     CLOSE ser_file
$     APPEND /NEW_VERSION NL: CATOP:[000000]index.txt
$
$     ! The following is to make sure access() doesn't get confused.  It
$     ! really needs one file in the directory to give correct answers...
$     COPY NLA0: CATOP:[certs].;
$     COPY NLA0: CATOP:[crl].;
$     COPY NLA0: CATOP:[newcerts].;
$     COPY NLA0: CATOP:[private].;
$   ENDIF
$!
$   IF F$SEARCH( CAKEY) .EQS. ""
$   THEN
$     READ '__INPUT' FILE -
       /PROMPT="CA certificate filename (or enter to create): "
$     IF (FILE .NES. "") .AND. (F$SEARCH(FILE) .NES. "")
$     THEN
$       COPY 'FILE' 'CAKEY'
$       RET=$STATUS
$     ELSE
$       echo "Making CA certificate ..."
$       DEFINE /USER_MODE SYS$INPUT '__INPUT'
$       REQ -new -x509 -keyout 'CAKEY' -out 'CACERT' 'DAYS'
$       RET=$STATUS
$     ENDIF
$   ENDIF
$   GOTO opt_loop_continue
$ ENDIF
$!
$ IF (prog_opt .EQS. "-pkcs12")
$ THEN
$   i = i + 1
$   cname = P'i'
$   IF cname .EQS. "" THEN cname = "My certificate"
$   PKCS12 -in newcert.pem -inkey newreq.pem -certfile 'CACERT' -
     -out newcert.p12 -export -name "''cname'"
$   RET=$STATUS
$   goto clean_up
$ ENDIF
$!
$ IF (prog_opt .EQS. "-xsign")
$ THEN
$!
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
$   CA -policy policy_anything -infiles newreq.pem
$   RET=$STATUS
$   GOTO opt_loop_continue
$ ENDIF
$!
$ IF ((prog_opt .EQS. "-sign") .OR. (prog_opt .EQS. "-signreq"))
$ THEN
$!   
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
$   CA -policy policy_anything -out newcert.pem -infiles newreq.pem
$   RET=$STATUS
$   type newcert.pem
$   echo "Signed certificate is in newcert.pem"
$   GOTO opt_loop_continue
$ ENDIF
$!
$ IF (prog_opt .EQS. "-signcert")
$  THEN
$!   
$   echo "Cert passphrase will be requested twice - bug?"
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
$   X509 -x509toreq -in newreq.pem -signkey newreq.pem -out tmp.pem
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
$   CA -policy policy_anything -out newcert.pem -infiles tmp.pem
y
y
$   type newcert.pem
$   echo "Signed certificate is in newcert.pem"
$   GOTO opt_loop_continue
$ ENDIF
$!
$ IF (prog_opt .EQS. "-verify")
$ THEN
$!   
$   i = i + 1
$   IF (p'i' .EQS. "")
$   THEN
$     DEFINE /USER_MODE SYS$INPUT '__INPUT'
$     VERIFY "-CAfile" 'CACERT' newcert.pem
$   ELSE
$     j = i
$    verify_opt_loop:
$     IF j .GT. 8 THEN GOTO verify_opt_loop_end
$     IF p'j' .NES. ""
$     THEN 
$       DEFINE /USER_MODE SYS$INPUT '__INPUT'
$       __tmp = p'j'
$       VERIFY "-CAfile" 'CACERT' '__tmp'
$       tmp=$STATUS
$       IF tmp .NE. 0 THEN RET=tmp
$     ENDIF
$     j = j + 1
$     GOTO verify_opt_loop
$    verify_opt_loop_end:
$   ENDIF
$   
$   GOTO opt_loop_end
$ ENDIF
$!
$ IF (prog_opt .NES. "")
$ THEN
$!   
$   echo "Unknown argument ''prog_opt'"
$   RET = 3
$   goto clean_up
$ ENDIF
$
$opt_loop_continue:
$ i = i + 1
$ GOTO opt_loop
$
$opt_loop_end:
$!
$clean_up:
$!
$ if f$trnlnm( "CATOP", "LNM$PROCESS") .nes. "" then -
   deassign /process CATOP
$!
$ EXIT 'RET'
@


1.4
log
@openssl-1.0.0e: resolve conflicts
@
text
@@


1.3
log
@resolve conflicts, fix local changes
@
text
@d40 11
d52 5
a56 4
$ s = F$PARSE(F$ENVIRONMENT("DEFAULT"),"[]") - "].;"
$ CATOP  := 's'.demoCA
$ CAKEY  := ]cakey.pem
$ CACERT := ]cacert.pem
a58 1
$ RET = 1
d69 1
a69 1
$   exit
d83 1
a83 1
$   DEFINE/USER SYS$INPUT '__INPUT'
d93 1
a93 1
$   DEFINE/USER SYS$INPUT '__INPUT'
d104 1
a104 1
$   IF F$SEARCH(CATOP+"]serial.") .EQS. ""
d106 5
a110 5
$     CREATE /DIR /PROTECTION=OWNER:RWED 'CATOP']
$     CREATE /DIR /PROTECTION=OWNER:RWED 'CATOP'.certs]
$     CREATE /DIR /PROTECTION=OWNER:RWED 'CATOP'.crl]
$     CREATE /DIR /PROTECTION=OWNER:RWED 'CATOP'.newcerts]
$     CREATE /DIR /PROTECTION=OWNER:RWED 'CATOP'.private]
d112 1
a112 1
$     OPEN   /WRITE ser_file 'CATOP']serial. 
d115 1
a115 1
$     APPEND/NEW NL: 'CATOP']index.txt
d119 4
a122 4
$     COPY NLA0: 'CATOP'.certs].;
$     COPY NLA0: 'CATOP'.crl].;
$     COPY NLA0: 'CATOP'.newcerts].;
$     COPY NLA0: 'CATOP'.private].;
d125 1
a125 1
$   IF F$SEARCH(CATOP+".private"+CAKEY) .EQS. ""
d128 1
a128 1
	   /PROMPT="CA certificate filename (or enter to create)"
d131 2
a132 2
$       COPY 'FILE' 'CATOP'.private'CAKEY'
$	RET=$STATUS
d135 3
a137 4
$       DEFINE/USER SYS$INPUT '__INPUT'
$       REQ -new -x509 -keyout 'CATOP'.private'CAKEY' -
		       -out 'CATOP''CACERT' 'DAYS'
$	RET=$STATUS
d148 2
a149 2
$   PKCS12 -in newcert.pem -inkey newreq.pem -certfile 'CATOP''CACERT -
	   -out newcert.p12 -export -name "''cname'"
d151 1
a151 1
$   exit RET
d157 1
a157 1
$   DEFINE/USER SYS$INPUT '__INPUT'
d166 1
a166 1
$   DEFINE/USER SYS$INPUT '__INPUT'
d178 1
a178 1
$   DEFINE/USER SYS$INPUT '__INPUT'
d180 1
a180 1
$   DEFINE/USER SYS$INPUT '__INPUT'
d195 2
a196 2
$     DEFINE/USER SYS$INPUT '__INPUT'
$     VERIFY "-CAfile" 'CATOP''CACERT' newcert.pem
d203 1
a203 1
$       DEFINE/USER SYS$INPUT '__INPUT'
d205 1
a205 1
$       VERIFY "-CAfile" 'CATOP''CACERT' '__tmp'
d221 2
a222 2
$   
$   EXIT 3
d230 6
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d117 2
a118 2
	   /PROMT="CA certificate filename (or enter to create)"
$     IF F$SEARCH(FILE) .NES. ""
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d38 1
d100 1
d105 7
d131 11
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a37 1
$ PKCS12 = openssl + " pkcs12"
a98 1
$
a102 7
$
$     ! The following is to make sure access() doesn't get confused.  It
$     ! really needs one file in the directory to give correct answers...
$     COPY NLA0: 'CATOP'.certs].;
$     COPY NLA0: 'CATOP'.crl].;
$     COPY NLA0: 'CATOP'.newcerts].;
$     COPY NLA0: 'CATOP'.private].;
a121 11
$ ENDIF
$!
$ IF (prog_opt .EQS. "-pkcs12")
$ THEN
$   i = i + 1
$   cname = P'i'
$   IF cname .EQS. "" THEN cname = "My certificate"
$   PKCS12 -in newcert.pem -inkey newreq.pem -certfile 'CATOP''CACERT -
	   -out newcert.p12 -export -name "''cname'"
$   RET=$STATUS
$   exit RET
@


1.1.1.2
log
@import OpenSSL-1.0.0a
@
text
@d117 2
a118 2
	   /PROMPT="CA certificate filename (or enter to create)"
$     IF (FILE .NES. "") .AND. (F$SEARCH(FILE) .NES. "")
@


1.1.1.3
log
@import OpenSSL 1.0.0e
@
text
@a39 11
$ RET = 1
$!
$! 2010-12-20 SMS.
$! Use a concealed logical name to reduce command line lengths, to
$! avoid DCL errors on VAX:
$!     %DCL-W-TKNOVF, command element is too long - shorten
$! (Path segments like "openssl-1_0_1-stable-SNAP-20101217" accumulate
$! quickly.)
$!
$ CATOP = F$PARSE( F$ENVIRONMENT( "DEFAULT"), "[]")- "].;"+ ".demoCA.]"
$ define /translation_attributes = concealed CATOP 'CATOP'
d41 4
a44 5
$ on error then goto clean_up
$ on control_y then goto clean_up
$!
$ CAKEY  = "CATOP:[private]cakey.pem"
$ CACERT = "CATOP:[000000]cacert.pem"
d47 1
d58 1
a58 1
$   goto clean_up
d72 1
a72 1
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
d82 1
a82 1
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
d93 1
a93 1
$   IF F$SEARCH( "CATOP:[000000]serial.") .EQS. ""
d95 5
a99 5
$     CREATE /DIRECTORY /PROTECTION=OWNER:RWED CATOP:[000000]
$     CREATE /DIRECTORY /PROTECTION=OWNER:RWED CATOP:[certs]
$     CREATE /DIRECTORY /PROTECTION=OWNER:RWED CATOP:[crl]
$     CREATE /DIRECTORY /PROTECTION=OWNER:RWED CATOP:[newcerts]
$     CREATE /DIRECTORY /PROTECTION=OWNER:RWED CATOP:[private]
d101 1
a101 1
$     OPEN /WRITE ser_file CATOP:[000000]serial. 
d104 1
a104 1
$     APPEND /NEW_VERSION NL: CATOP:[000000]index.txt
d108 4
a111 4
$     COPY NLA0: CATOP:[certs].;
$     COPY NLA0: CATOP:[crl].;
$     COPY NLA0: CATOP:[newcerts].;
$     COPY NLA0: CATOP:[private].;
d114 1
a114 1
$   IF F$SEARCH( CAKEY) .EQS. ""
d117 1
a117 1
       /PROMPT="CA certificate filename (or enter to create): "
d120 2
a121 2
$       COPY 'FILE' 'CAKEY'
$       RET=$STATUS
d124 4
a127 3
$       DEFINE /USER_MODE SYS$INPUT '__INPUT'
$       REQ -new -x509 -keyout 'CAKEY' -out 'CACERT' 'DAYS'
$       RET=$STATUS
d138 2
a139 2
$   PKCS12 -in newcert.pem -inkey newreq.pem -certfile 'CACERT' -
     -out newcert.p12 -export -name "''cname'"
d141 1
a141 1
$   goto clean_up
d147 1
a147 1
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
d156 1
a156 1
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
d168 1
a168 1
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
d170 1
a170 1
$   DEFINE /USER_MODE SYS$INPUT '__INPUT'
d185 2
a186 2
$     DEFINE /USER_MODE SYS$INPUT '__INPUT'
$     VERIFY "-CAfile" 'CACERT' newcert.pem
d193 1
a193 1
$       DEFINE /USER_MODE SYS$INPUT '__INPUT'
d195 1
a195 1
$       VERIFY "-CAfile" 'CACERT' '__tmp'
d211 2
a212 2
$   RET = 3
$   goto clean_up
a219 6
$!
$clean_up:
$!
$ if f$trnlnm( "CATOP", "LNM$PROCESS") .nes. "" then -
   deassign /process CATOP
$!
@


