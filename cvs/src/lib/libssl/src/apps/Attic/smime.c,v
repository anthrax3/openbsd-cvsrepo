head	1.29;
access;
symbols
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	butholakala:1.11
	openssl_1_0_1_g:1.1.1.7
	OPENBSD_5_5:1.11.0.16
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.12
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	openssl_1_0_1_c:1.1.1.7
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	openssl_1_0_0_f:1.1.1.7
	openssl_1_0_0_e:1.1.1.7
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	openssh_1_0_0_a:1.1.1.7
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	openssl_0_9_8_k:1.1.1.6
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	openssl_0_9_8_j:1.1.1.6
	openssl_0_9_8_h:1.1.1.5
	pre_openssl_0_9_8h:1.8
	OPENBSD_4_4:1.8.0.20
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.18
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.16
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.14
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	openssl_0_9_7j:1.1.1.4
	openssl:1.1.1
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENSSL_0_9_7G:1.1.1.4
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.29
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.28;
commitid	7A7DObXgY4Fni8xJ;

1.28
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	EB0l28piqIRSpBUh;

1.27
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.26;
commitid	0NuggCO2WJOZj8Kh;

1.26
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	mJUVYpkFBZ0Zv2bG;

1.25
date	2014.06.02.16.23.18;	author jsing;	state Exp;
branches;
next	1.24;
commitid	IqYoI5gjfSomu7k2;

1.24
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.17.15.45.50;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.18.09.38.42;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.18.04.17.17;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.18.02.45.27;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.01.22.58.51;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.09.12.15.19;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.11.22.15.18;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.01.19.51.16;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.56.59;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.15.06.18.30;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.08.14;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.36;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.12.20.43.13;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.24;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.11.21.11.00;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.01.09.12.13.49;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: smime.c,v 1.28 2014/07/14 00:35:10 deraadt Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project.
 */
/* ====================================================================
 * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

/* S/MIME utility function */

#include <stdio.h>
#include <string.h>

#include "apps.h"

#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/x509_vfy.h>
#include <openssl/x509v3.h>

static int save_certs(char *signerfile, STACK_OF(X509) * signers);
static int smime_cb(int ok, X509_STORE_CTX * ctx);

#define SMIME_OP	0x10
#define SMIME_IP	0x20
#define SMIME_SIGNERS	0x40
#define SMIME_ENCRYPT	(1 | SMIME_OP)
#define SMIME_DECRYPT	(2 | SMIME_IP)
#define SMIME_SIGN	(3 | SMIME_OP | SMIME_SIGNERS)
#define SMIME_VERIFY	(4 | SMIME_IP)
#define SMIME_PK7OUT	(5 | SMIME_IP | SMIME_OP)
#define SMIME_RESIGN	(6 | SMIME_IP | SMIME_OP | SMIME_SIGNERS)

int smime_main(int, char **);

int
smime_main(int argc, char **argv)
{
	ENGINE *e = NULL;
	int operation = 0;
	int ret = 0;
	char **args;
	const char *inmode = "r", *outmode = "w";
	char *infile = NULL, *outfile = NULL;
	char *signerfile = NULL, *recipfile = NULL;
	STACK_OF(OPENSSL_STRING) * sksigners = NULL, *skkeys = NULL;
	char *certfile = NULL, *keyfile = NULL, *contfile = NULL;
	const EVP_CIPHER *cipher = NULL;
	PKCS7 *p7 = NULL;
	X509_STORE *store = NULL;
	X509 *cert = NULL, *recip = NULL, *signer = NULL;
	EVP_PKEY *key = NULL;
	STACK_OF(X509) * encerts = NULL, *other = NULL;
	BIO *in = NULL, *out = NULL, *indata = NULL;
	int badarg = 0;
	int flags = PKCS7_DETACHED;
	char *to = NULL, *from = NULL, *subject = NULL;
	char *CAfile = NULL, *CApath = NULL;
	char *passargin = NULL, *passin = NULL;
	int indef = 0;
	const EVP_MD *sign_md = NULL;
	int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;
	int keyform = FORMAT_PEM;
#ifndef OPENSSL_NO_ENGINE
	char *engine = NULL;
#endif

	X509_VERIFY_PARAM *vpm = NULL;

	args = argv + 1;
	ret = 1;

	while (!badarg && *args && *args[0] == '-') {
		if (!strcmp(*args, "-encrypt"))
			operation = SMIME_ENCRYPT;
		else if (!strcmp(*args, "-decrypt"))
			operation = SMIME_DECRYPT;
		else if (!strcmp(*args, "-sign"))
			operation = SMIME_SIGN;
		else if (!strcmp(*args, "-resign"))
			operation = SMIME_RESIGN;
		else if (!strcmp(*args, "-verify"))
			operation = SMIME_VERIFY;
		else if (!strcmp(*args, "-pk7out"))
			operation = SMIME_PK7OUT;
#ifndef OPENSSL_NO_DES
		else if (!strcmp(*args, "-des3"))
			cipher = EVP_des_ede3_cbc();
		else if (!strcmp(*args, "-des"))
			cipher = EVP_des_cbc();
#endif
#ifndef OPENSSL_NO_RC2
		else if (!strcmp(*args, "-rc2-40"))
			cipher = EVP_rc2_40_cbc();
		else if (!strcmp(*args, "-rc2-128"))
			cipher = EVP_rc2_cbc();
		else if (!strcmp(*args, "-rc2-64"))
			cipher = EVP_rc2_64_cbc();
#endif
#ifndef OPENSSL_NO_AES
		else if (!strcmp(*args, "-aes128"))
			cipher = EVP_aes_128_cbc();
		else if (!strcmp(*args, "-aes192"))
			cipher = EVP_aes_192_cbc();
		else if (!strcmp(*args, "-aes256"))
			cipher = EVP_aes_256_cbc();
#endif
#ifndef OPENSSL_NO_CAMELLIA
		else if (!strcmp(*args, "-camellia128"))
			cipher = EVP_camellia_128_cbc();
		else if (!strcmp(*args, "-camellia192"))
			cipher = EVP_camellia_192_cbc();
		else if (!strcmp(*args, "-camellia256"))
			cipher = EVP_camellia_256_cbc();
#endif
		else if (!strcmp(*args, "-text"))
			flags |= PKCS7_TEXT;
		else if (!strcmp(*args, "-nointern"))
			flags |= PKCS7_NOINTERN;
		else if (!strcmp(*args, "-noverify"))
			flags |= PKCS7_NOVERIFY;
		else if (!strcmp(*args, "-nochain"))
			flags |= PKCS7_NOCHAIN;
		else if (!strcmp(*args, "-nocerts"))
			flags |= PKCS7_NOCERTS;
		else if (!strcmp(*args, "-noattr"))
			flags |= PKCS7_NOATTR;
		else if (!strcmp(*args, "-nodetach"))
			flags &= ~PKCS7_DETACHED;
		else if (!strcmp(*args, "-nosmimecap"))
			flags |= PKCS7_NOSMIMECAP;
		else if (!strcmp(*args, "-binary"))
			flags |= PKCS7_BINARY;
		else if (!strcmp(*args, "-nosigs"))
			flags |= PKCS7_NOSIGS;
		else if (!strcmp(*args, "-stream"))
			indef = 1;
		else if (!strcmp(*args, "-indef"))
			indef = 1;
		else if (!strcmp(*args, "-noindef"))
			indef = 0;
		else if (!strcmp(*args, "-nooldmime"))
			flags |= PKCS7_NOOLDMIMETYPE;
		else if (!strcmp(*args, "-crlfeol"))
			flags |= PKCS7_CRLFEOL;
#ifndef OPENSSL_NO_ENGINE
		else if (!strcmp(*args, "-engine")) {
			if (!args[1])
				goto argerr;
			engine = *++args;
		}
#endif
		else if (!strcmp(*args, "-passin")) {
			if (!args[1])
				goto argerr;
			passargin = *++args;
		} else if (!strcmp(*args, "-to")) {
			if (!args[1])
				goto argerr;
			to = *++args;
		} else if (!strcmp(*args, "-from")) {
			if (!args[1])
				goto argerr;
			from = *++args;
		} else if (!strcmp(*args, "-subject")) {
			if (!args[1])
				goto argerr;
			subject = *++args;
		} else if (!strcmp(*args, "-signer")) {
			if (!args[1])
				goto argerr;
			/* If previous -signer argument add signer to list */

			if (signerfile) {
				if (!sksigners)
					sksigners = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(sksigners, signerfile);
				if (!keyfile)
					keyfile = signerfile;
				if (!skkeys)
					skkeys = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(skkeys, keyfile);
				keyfile = NULL;
			}
			signerfile = *++args;
		} else if (!strcmp(*args, "-recip")) {
			if (!args[1])
				goto argerr;
			recipfile = *++args;
		} else if (!strcmp(*args, "-md")) {
			if (!args[1])
				goto argerr;
			sign_md = EVP_get_digestbyname(*++args);
			if (sign_md == NULL) {
				BIO_printf(bio_err, "Unknown digest %s\n",
				    *args);
				goto argerr;
			}
		} else if (!strcmp(*args, "-inkey")) {
			if (!args[1])
				goto argerr;
			/* If previous -inkey arument add signer to list */
			if (keyfile) {
				if (!signerfile) {
					BIO_puts(bio_err, "Illegal -inkey without -signer\n");
					goto argerr;
				}
				if (!sksigners)
					sksigners = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(sksigners, signerfile);
				signerfile = NULL;
				if (!skkeys)
					skkeys = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(skkeys, keyfile);
			}
			keyfile = *++args;
		} else if (!strcmp(*args, "-keyform")) {
			if (!args[1])
				goto argerr;
			keyform = str2fmt(*++args);
		} else if (!strcmp(*args, "-certfile")) {
			if (!args[1])
				goto argerr;
			certfile = *++args;
		} else if (!strcmp(*args, "-CAfile")) {
			if (!args[1])
				goto argerr;
			CAfile = *++args;
		} else if (!strcmp(*args, "-CApath")) {
			if (!args[1])
				goto argerr;
			CApath = *++args;
		} else if (!strcmp(*args, "-in")) {
			if (!args[1])
				goto argerr;
			infile = *++args;
		} else if (!strcmp(*args, "-inform")) {
			if (!args[1])
				goto argerr;
			informat = str2fmt(*++args);
		} else if (!strcmp(*args, "-outform")) {
			if (!args[1])
				goto argerr;
			outformat = str2fmt(*++args);
		} else if (!strcmp(*args, "-out")) {
			if (!args[1])
				goto argerr;
			outfile = *++args;
		} else if (!strcmp(*args, "-content")) {
			if (!args[1])
				goto argerr;
			contfile = *++args;
		} else if (args_verify(&args, NULL, &badarg, bio_err, &vpm))
			continue;
		else if ((cipher = EVP_get_cipherbyname(*args + 1)) == NULL)
			badarg = 1;
		args++;
	}

	if (!(operation & SMIME_SIGNERS) && (skkeys || sksigners)) {
		BIO_puts(bio_err, "Multiple signers or keys not allowed\n");
		goto argerr;
	}
	if (operation & SMIME_SIGNERS) {
		/* Check to see if any final signer needs to be appended */
		if (keyfile && !signerfile) {
			BIO_puts(bio_err, "Illegal -inkey without -signer\n");
			goto argerr;
		}
		if (signerfile) {
			if (!sksigners)
				sksigners = sk_OPENSSL_STRING_new_null();
			sk_OPENSSL_STRING_push(sksigners, signerfile);
			if (!skkeys)
				skkeys = sk_OPENSSL_STRING_new_null();
			if (!keyfile)
				keyfile = signerfile;
			sk_OPENSSL_STRING_push(skkeys, keyfile);
		}
		if (!sksigners) {
			BIO_printf(bio_err, "No signer certificate specified\n");
			badarg = 1;
		}
		signerfile = NULL;
		keyfile = NULL;
	} else if (operation == SMIME_DECRYPT) {
		if (!recipfile && !keyfile) {
			BIO_printf(bio_err, "No recipient certificate or key specified\n");
			badarg = 1;
		}
	} else if (operation == SMIME_ENCRYPT) {
		if (!*args) {
			BIO_printf(bio_err, "No recipient(s) certificate(s) specified\n");
			badarg = 1;
		}
	} else if (!operation)
		badarg = 1;

	if (badarg) {
argerr:
		BIO_printf(bio_err, "Usage smime [options] cert.pem ...\n");
		BIO_printf(bio_err, "where options are\n");
		BIO_printf(bio_err, "-encrypt       encrypt message\n");
		BIO_printf(bio_err, "-decrypt       decrypt encrypted message\n");
		BIO_printf(bio_err, "-sign          sign message\n");
		BIO_printf(bio_err, "-verify        verify signed message\n");
		BIO_printf(bio_err, "-pk7out        output PKCS#7 structure\n");
#ifndef OPENSSL_NO_DES
		BIO_printf(bio_err, "-des3          encrypt with triple DES\n");
		BIO_printf(bio_err, "-des           encrypt with DES\n");
#endif
#ifndef OPENSSL_NO_RC2
		BIO_printf(bio_err, "-rc2-40        encrypt with RC2-40 (default)\n");
		BIO_printf(bio_err, "-rc2-64        encrypt with RC2-64\n");
		BIO_printf(bio_err, "-rc2-128       encrypt with RC2-128\n");
#endif
#ifndef OPENSSL_NO_AES
		BIO_printf(bio_err, "-aes128, -aes192, -aes256\n");
		BIO_printf(bio_err, "               encrypt PEM output with cbc aes\n");
#endif
#ifndef OPENSSL_NO_CAMELLIA
		BIO_printf(bio_err, "-camellia128, -camellia192, -camellia256\n");
		BIO_printf(bio_err, "               encrypt PEM output with cbc camellia\n");
#endif
		BIO_printf(bio_err, "-nointern      don't search certificates in message for signer\n");
		BIO_printf(bio_err, "-nosigs        don't verify message signature\n");
		BIO_printf(bio_err, "-noverify      don't verify signers certificate\n");
		BIO_printf(bio_err, "-nocerts       don't include signers certificate when signing\n");
		BIO_printf(bio_err, "-nodetach      use opaque signing\n");
		BIO_printf(bio_err, "-noattr        don't include any signed attributes\n");
		BIO_printf(bio_err, "-binary        don't translate message to text\n");
		BIO_printf(bio_err, "-certfile file other certificates file\n");
		BIO_printf(bio_err, "-signer file   signer certificate file\n");
		BIO_printf(bio_err, "-recip  file   recipient certificate file for decryption\n");
		BIO_printf(bio_err, "-in file       input file\n");
		BIO_printf(bio_err, "-inform arg    input format SMIME (default), PEM or DER\n");
		BIO_printf(bio_err, "-inkey file    input private key (if not signer or recipient)\n");
		BIO_printf(bio_err, "-keyform arg   input private key format (PEM or ENGINE)\n");
		BIO_printf(bio_err, "-out file      output file\n");
		BIO_printf(bio_err, "-outform arg   output format SMIME (default), PEM or DER\n");
		BIO_printf(bio_err, "-content file  supply or override content for detached signature\n");
		BIO_printf(bio_err, "-to addr       to address\n");
		BIO_printf(bio_err, "-from ad       from address\n");
		BIO_printf(bio_err, "-subject s     subject\n");
		BIO_printf(bio_err, "-text          include or delete text MIME headers\n");
		BIO_printf(bio_err, "-CApath dir    trusted certificates directory\n");
		BIO_printf(bio_err, "-CAfile file   trusted certificates file\n");
		BIO_printf(bio_err, "-crl_check     check revocation status of signer's certificate using CRLs\n");
		BIO_printf(bio_err, "-crl_check_all check revocation status of signer's certificate chain using CRLs\n");
#ifndef OPENSSL_NO_ENGINE
		BIO_printf(bio_err, "-engine e      use engine e, possibly a hardware device.\n");
#endif
		BIO_printf(bio_err, "-passin arg    input file pass phrase source\n");
		BIO_printf(bio_err, "cert.pem       recipient certificate(s) for encryption\n");
		goto end;
	}
#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine, 0);
#endif

	if (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
	}
	ret = 2;

	if (!(operation & SMIME_SIGNERS))
		flags &= ~PKCS7_DETACHED;

	if (operation & SMIME_OP) {
		if (outformat == FORMAT_ASN1)
			outmode = "wb";
	} else {
		if (flags & PKCS7_BINARY)
			outmode = "wb";
	}

	if (operation & SMIME_IP) {
		if (informat == FORMAT_ASN1)
			inmode = "rb";
	} else {
		if (flags & PKCS7_BINARY)
			inmode = "rb";
	}

	if (operation == SMIME_ENCRYPT) {
		if (!cipher) {
#ifndef OPENSSL_NO_RC2
			cipher = EVP_rc2_40_cbc();
#else
			BIO_printf(bio_err, "No cipher selected\n");
			goto end;
#endif
		}
		encerts = sk_X509_new_null();
		while (*args) {
			if (!(cert = load_cert(bio_err, *args, FORMAT_PEM,
				    NULL, e, "recipient certificate file"))) {
#if 0				/* An appropriate message is already printed */
				BIO_printf(bio_err, "Can't read recipient certificate file %s\n", *args);
#endif
				goto end;
			}
			sk_X509_push(encerts, cert);
			cert = NULL;
			args++;
		}
	}
	if (certfile) {
		if (!(other = load_certs(bio_err, certfile, FORMAT_PEM, NULL,
			    e, "certificate file"))) {
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (recipfile && (operation == SMIME_DECRYPT)) {
		if (!(recip = load_cert(bio_err, recipfile, FORMAT_PEM, NULL,
			    e, "recipient certificate file"))) {
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (operation == SMIME_DECRYPT) {
		if (!keyfile)
			keyfile = recipfile;
	} else if (operation == SMIME_SIGN) {
		if (!keyfile)
			keyfile = signerfile;
	} else
		keyfile = NULL;

	if (keyfile) {
		key = load_key(bio_err, keyfile, keyform, 0, passin, e,
		    "signing key file");
		if (!key)
			goto end;
	}
	if (infile) {
		if (!(in = BIO_new_file(infile, inmode))) {
			BIO_printf(bio_err,
			    "Can't open input file %s\n", infile);
			goto end;
		}
	} else
		in = BIO_new_fp(stdin, BIO_NOCLOSE);

	if (operation & SMIME_IP) {
		if (informat == FORMAT_SMIME)
			p7 = SMIME_read_PKCS7(in, &indata);
		else if (informat == FORMAT_PEM)
			p7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);
		else if (informat == FORMAT_ASN1)
			p7 = d2i_PKCS7_bio(in, NULL);
		else {
			BIO_printf(bio_err, "Bad input format for PKCS#7 file\n");
			goto end;
		}

		if (!p7) {
			BIO_printf(bio_err, "Error reading S/MIME message\n");
			goto end;
		}
		if (contfile) {
			BIO_free(indata);
			if (!(indata = BIO_new_file(contfile, "rb"))) {
				BIO_printf(bio_err, "Can't read content file %s\n", contfile);
				goto end;
			}
		}
	}
	if (outfile) {
		if (!(out = BIO_new_file(outfile, outmode))) {
			BIO_printf(bio_err,
			    "Can't open output file %s\n", outfile);
			goto end;
		}
	} else {
		out = BIO_new_fp(stdout, BIO_NOCLOSE);
	}

	if (operation == SMIME_VERIFY) {
		if (!(store = setup_verify(bio_err, CAfile, CApath)))
			goto end;
		X509_STORE_set_verify_cb(store, smime_cb);
		if (vpm)
			X509_STORE_set1_param(store, vpm);
	}
	ret = 3;

	if (operation == SMIME_ENCRYPT) {
		if (indef)
			flags |= PKCS7_STREAM;
		p7 = PKCS7_encrypt(encerts, in, cipher, flags);
	} else if (operation & SMIME_SIGNERS) {
		int i;
		/*
		 * If detached data content we only enable streaming if
		 * S/MIME output format.
		 */
		if (operation == SMIME_SIGN) {
			if (flags & PKCS7_DETACHED) {
				if (outformat == FORMAT_SMIME)
					flags |= PKCS7_STREAM;
			} else if (indef)
				flags |= PKCS7_STREAM;
			flags |= PKCS7_PARTIAL;
			p7 = PKCS7_sign(NULL, NULL, other, in, flags);
			if (!p7)
				goto end;
		} else
			flags |= PKCS7_REUSE_DIGEST;
		for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {
			signerfile = sk_OPENSSL_STRING_value(sksigners, i);
			keyfile = sk_OPENSSL_STRING_value(skkeys, i);
			signer = load_cert(bio_err, signerfile, FORMAT_PEM, NULL,
			    e, "signer certificate");
			if (!signer)
				goto end;
			key = load_key(bio_err, keyfile, keyform, 0, passin, e,
			    "signing key file");
			if (!key)
				goto end;
			if (!PKCS7_sign_add_signer(p7, signer, key,
				sign_md, flags))
				goto end;
			X509_free(signer);
			signer = NULL;
			EVP_PKEY_free(key);
			key = NULL;
		}
		/* If not streaming or resigning finalize structure */
		if ((operation == SMIME_SIGN) && !(flags & PKCS7_STREAM)) {
			if (!PKCS7_final(p7, in, flags))
				goto end;
		}
	}
	if (!p7) {
		BIO_printf(bio_err, "Error creating PKCS#7 structure\n");
		goto end;
	}
	ret = 4;
	if (operation == SMIME_DECRYPT) {
		if (!PKCS7_decrypt(p7, key, recip, out, flags)) {
			BIO_printf(bio_err, "Error decrypting PKCS#7 structure\n");
			goto end;
		}
	} else if (operation == SMIME_VERIFY) {
		STACK_OF(X509) * signers;
		if (PKCS7_verify(p7, other, store, indata, out, flags))
			BIO_printf(bio_err, "Verification successful\n");
		else {
			BIO_printf(bio_err, "Verification failure\n");
			goto end;
		}
		signers = PKCS7_get0_signers(p7, other, flags);
		if (!save_certs(signerfile, signers)) {
			BIO_printf(bio_err, "Error writing signers to %s\n",
			    signerfile);
			ret = 5;
			goto end;
		}
		sk_X509_free(signers);
	} else if (operation == SMIME_PK7OUT)
		PEM_write_bio_PKCS7(out, p7);
	else {
		if (to)
			BIO_printf(out, "To: %s\n", to);
		if (from)
			BIO_printf(out, "From: %s\n", from);
		if (subject)
			BIO_printf(out, "Subject: %s\n", subject);
		if (outformat == FORMAT_SMIME) {
			if (operation == SMIME_RESIGN)
				SMIME_write_PKCS7(out, p7, indata, flags);
			else
				SMIME_write_PKCS7(out, p7, in, flags);
		} else if (outformat == FORMAT_PEM)
			PEM_write_bio_PKCS7_stream(out, p7, in, flags);
		else if (outformat == FORMAT_ASN1)
			i2d_PKCS7_bio_stream(out, p7, in, flags);
		else {
			BIO_printf(bio_err, "Bad output format for PKCS#7 file\n");
			goto end;
		}
	}
	ret = 0;
end:
	if (ret)
		ERR_print_errors(bio_err);
	sk_X509_pop_free(encerts, X509_free);
	sk_X509_pop_free(other, X509_free);
	if (vpm)
		X509_VERIFY_PARAM_free(vpm);
	if (sksigners)
		sk_OPENSSL_STRING_free(sksigners);
	if (skkeys)
		sk_OPENSSL_STRING_free(skkeys);
	X509_STORE_free(store);
	X509_free(cert);
	X509_free(recip);
	X509_free(signer);
	EVP_PKEY_free(key);
	PKCS7_free(p7);
	BIO_free(in);
	BIO_free(indata);
	BIO_free_all(out);
	free(passin);

	return (ret);
}

static int
save_certs(char *signerfile, STACK_OF(X509) * signers)
{
	int i;
	BIO *tmp;
	if (!signerfile)
		return 1;
	tmp = BIO_new_file(signerfile, "w");
	if (!tmp)
		return 0;
	for (i = 0; i < sk_X509_num(signers); i++)
		PEM_write_bio_X509(tmp, sk_X509_value(signers, i));
	BIO_free(tmp);
	return 1;
}


/* Minimal callback just to output policy info (if any) */

static int
smime_cb(int ok, X509_STORE_CTX * ctx)
{
	int error;

	error = X509_STORE_CTX_get_error(ctx);

	if ((error != X509_V_ERR_NO_EXPLICIT_POLICY)
	    && ((error != X509_V_OK) || (ok != 2)))
		return ok;

	policies_print(NULL, ctx);

	return ok;

}
@


1.28
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: smime.c,v 1.27 2014/07/12 17:54:31 jsing Exp $ */
@


1.27
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: smime.c,v 1.26 2014/06/12 15:49:27 deraadt Exp $ */
d87 1
a87 1
int 
d663 1
a663 1
static int 
d682 1
a682 1
static int 
@


1.26
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a122 3

	if (!load_config(bio_err, NULL))
		goto end;
@


1.25
log
@Stop pretending that openssl(1) applications support the -rand option.
The underlying code has long been removed, making this a no-op.

If your random subsystem actually requires that you seed it from a file,
then you really should go and buy a new random subsystem that was built
after 1990.

Diff from Brent Cook.

ok deraadt@@
@
text
@d1 1
a1 1
/* smime.c */
@


1.24
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@a110 1
	char *inrand = NULL;
a199 6
		else if (!strcmp(*args, "-rand")) {
			if (!args[1])
				goto argerr;
			args++;
			inrand = *args;
		}
a407 3
		BIO_printf(bio_err, "-rand file:file:...\n");
		BIO_printf(bio_err, "               load the file (or the files in the directory) into\n");
		BIO_printf(bio_err, "               the random number generator\n");
@


1.23
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a124 2
	signal(SIGPIPE, SIG_IGN);

@


1.22
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d673 2
a674 2
	if (passin)
		free(passin);
@


1.21
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d63 1
d65 1
d67 1
a68 1
#include <openssl/err.h>
@


1.20
log
@deleted seed some time ago
@
text
@a124 4
	if (bio_err == NULL) {
		if ((bio_err = BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);
	}
@


1.19
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a150 4
#ifndef OPENSSL_NO_SEED
		else if (!strcmp(*args, "-seed"))
			cipher = EVP_seed_cbc();
#endif
a375 3
#endif
#ifndef OPENSSL_NO_SEED
		BIO_printf(bio_err, "-seed          encrypt with SEED\n");
@


1.18
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d123 1
a123 1
	apps_startup();
@


1.17
log
@simplify file:file:... stuff
@
text
@a109 1
	int need_rand = 0;
a213 1
			need_rand = 1;
a354 1
		need_rand = 1;
a364 1
		need_rand = 1;
a439 6
	if (need_rand) {
		app_RAND_load_file(NULL, bio_err, (inrand != NULL));
		if (inrand != NULL)
			BIO_printf(bio_err, "%ld semi-random bytes loaded\n",
			    app_RAND_load_files(inrand));
	}
a662 2
	if (need_rand)
		app_RAND_write_file(NULL, bio_err);
@


1.16
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d430 1
a430 1
		BIO_printf(bio_err, "-rand file%cfile%c...\n", ':', ':');
@


1.15
log
@KaboomNF
@
text
@a69 2
#undef PROG
#define PROG smime_main
d83 1
a83 1
int MAIN(int, char **);
d86 1
a86 1
MAIN(int argc, char **argv)
@


1.14
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d72 2
a73 2
static int save_certs(char *signerfile, STACK_OF(X509) *signers);
static int smime_cb(int ok, X509_STORE_CTX *ctx);
d87 3
a89 2
int MAIN(int argc, char **argv)
	{
d97 2
a98 2
	STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;
	char *certfile = NULL, *keyfile = NULL, *contfile=NULL;
d104 1
a104 1
	STACK_OF(X509) *encerts = NULL, *other = NULL;
d116 1
a116 1
        int keyform = FORMAT_PEM;
d118 1
a118 1
	char *engine=NULL;
d128 1
a128 2
	if (bio_err == NULL)
		{
d130 2
a131 3
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE|BIO_FP_TEXT);
		}

d135 2
a136 3
	while (!badarg && *args && *args[0] == '-')
		{
		if (!strcmp (*args, "-encrypt"))
d138 1
a138 1
		else if (!strcmp (*args, "-decrypt"))
d140 1
a140 1
		else if (!strcmp (*args, "-sign"))
d142 1
a142 1
		else if (!strcmp (*args, "-resign"))
d144 1
a144 1
		else if (!strcmp (*args, "-verify"))
d146 1
a146 1
		else if (!strcmp (*args, "-pk7out"))
d149 4
a152 4
		else if (!strcmp (*args, "-des3")) 
				cipher = EVP_des_ede3_cbc();
		else if (!strcmp (*args, "-des")) 
				cipher = EVP_des_cbc();
d155 2
a156 2
		else if (!strcmp (*args, "-seed")) 
				cipher = EVP_seed_cbc();
d159 6
a164 6
		else if (!strcmp (*args, "-rc2-40")) 
				cipher = EVP_rc2_40_cbc();
		else if (!strcmp (*args, "-rc2-128")) 
				cipher = EVP_rc2_cbc();
		else if (!strcmp (*args, "-rc2-64")) 
				cipher = EVP_rc2_64_cbc();
d167 6
a172 6
		else if (!strcmp(*args,"-aes128"))
				cipher = EVP_aes_128_cbc();
		else if (!strcmp(*args,"-aes192"))
				cipher = EVP_aes_192_cbc();
		else if (!strcmp(*args,"-aes256"))
				cipher = EVP_aes_256_cbc();
d175 38
a212 39
		else if (!strcmp(*args,"-camellia128"))
				cipher = EVP_camellia_128_cbc();
		else if (!strcmp(*args,"-camellia192"))
				cipher = EVP_camellia_192_cbc();
		else if (!strcmp(*args,"-camellia256"))
				cipher = EVP_camellia_256_cbc();
#endif
		else if (!strcmp (*args, "-text")) 
				flags |= PKCS7_TEXT;
		else if (!strcmp (*args, "-nointern")) 
				flags |= PKCS7_NOINTERN;
		else if (!strcmp (*args, "-noverify")) 
				flags |= PKCS7_NOVERIFY;
		else if (!strcmp (*args, "-nochain")) 
				flags |= PKCS7_NOCHAIN;
		else if (!strcmp (*args, "-nocerts")) 
				flags |= PKCS7_NOCERTS;
		else if (!strcmp (*args, "-noattr")) 
				flags |= PKCS7_NOATTR;
		else if (!strcmp (*args, "-nodetach")) 
				flags &= ~PKCS7_DETACHED;
		else if (!strcmp (*args, "-nosmimecap"))
				flags |= PKCS7_NOSMIMECAP;
		else if (!strcmp (*args, "-binary"))
				flags |= PKCS7_BINARY;
		else if (!strcmp (*args, "-nosigs"))
				flags |= PKCS7_NOSIGS;
		else if (!strcmp (*args, "-stream"))
				indef = 1;
		else if (!strcmp (*args, "-indef"))
				indef = 1;
		else if (!strcmp (*args, "-noindef"))
				indef = 0;
		else if (!strcmp (*args, "-nooldmime"))
				flags |= PKCS7_NOOLDMIMETYPE;
		else if (!strcmp (*args, "-crlfeol"))
				flags |= PKCS7_CRLFEOL;
		else if (!strcmp(*args,"-rand"))
			{
d218 1
a218 1
			}
d220 1
a220 2
		else if (!strcmp(*args,"-engine"))
			{
d224 1
a224 1
			}
d226 1
a226 2
		else if (!strcmp(*args,"-passin"))
			{
d230 1
a230 3
			}
		else if (!strcmp (*args, "-to"))
			{
d234 1
a234 3
			}
		else if (!strcmp (*args, "-from"))
			{
d238 1
a238 3
			}
		else if (!strcmp (*args, "-subject"))
			{
d242 1
a242 3
			}
		else if (!strcmp (*args, "-signer"))
			{
d247 1
a247 2
			if (signerfile)
				{
d257 1
a257 1
				}
d259 1
a259 3
			}
		else if (!strcmp (*args, "-recip"))
			{
d263 1
a263 3
			}
		else if (!strcmp (*args, "-md"))
			{
d267 1
a267 2
			if (sign_md == NULL)
				{
d269 1
a269 1
							*args);
a270 1
				}
d272 2
a273 3
		else if (!strcmp (*args, "-inkey"))
			{
			if (!args[1])	
d276 2
a277 4
			if (keyfile)
				{
				if (!signerfile)
					{
d280 1
a280 1
					}
d288 1
a288 1
				}
d290 1
a290 3
			}
		else if (!strcmp (*args, "-keyform"))
			{
d294 1
a294 3
			}
		else if (!strcmp (*args, "-certfile"))
			{
d298 1
a298 3
			}
		else if (!strcmp (*args, "-CAfile"))
			{
d302 1
a302 3
			}
		else if (!strcmp (*args, "-CApath"))
			{
d306 1
a306 3
			}
		else if (!strcmp (*args, "-in"))
			{
d310 1
a310 3
			}
		else if (!strcmp (*args, "-inform"))
			{
d314 1
a314 3
			}
		else if (!strcmp (*args, "-outform"))
			{
d318 1
a318 3
			}
		else if (!strcmp (*args, "-out"))
			{
d322 1
a322 3
			}
		else if (!strcmp (*args, "-content"))
			{
d326 1
a326 2
			}
		else if (args_verify(&args, NULL, &badarg, bio_err, &vpm))
d331 1
a331 1
		}
d333 1
a333 2
	if (!(operation & SMIME_SIGNERS) && (skkeys || sksigners))
		{
d336 2
a337 4
		}

	if (operation & SMIME_SIGNERS)
		{
d339 1
a339 2
		if (keyfile && !signerfile)
			{
d342 2
a343 3
			}
		if (signerfile)
			{
d352 2
a353 3
			}
		if (!sksigners)
			{
d356 1
a356 1
			}
d360 2
a361 5
		}
	else if (operation == SMIME_DECRYPT)
		{
		if (!recipfile && !keyfile)
			{
a363 1
			}
d365 2
a366 4
	else if (operation == SMIME_ENCRYPT)
		{
		if (!*args)
			{
d369 1
a369 1
			}
d371 1
a371 2
		}
	else if (!operation)
d374 9
a382 10
	if (badarg)
		{
		argerr:
		BIO_printf (bio_err, "Usage smime [options] cert.pem ...\n");
		BIO_printf (bio_err, "where options are\n");
		BIO_printf (bio_err, "-encrypt       encrypt message\n");
		BIO_printf (bio_err, "-decrypt       decrypt encrypted message\n");
		BIO_printf (bio_err, "-sign          sign message\n");
		BIO_printf (bio_err, "-verify        verify signed message\n");
		BIO_printf (bio_err, "-pk7out        output PKCS#7 structure\n");
d384 2
a385 2
		BIO_printf (bio_err, "-des3          encrypt with triple DES\n");
		BIO_printf (bio_err, "-des           encrypt with DES\n");
d388 1
a388 1
		BIO_printf (bio_err, "-seed          encrypt with SEED\n");
d391 3
a393 3
		BIO_printf (bio_err, "-rc2-40        encrypt with RC2-40 (default)\n");
		BIO_printf (bio_err, "-rc2-64        encrypt with RC2-64\n");
		BIO_printf (bio_err, "-rc2-128       encrypt with RC2-128\n");
d396 2
a397 2
		BIO_printf (bio_err, "-aes128, -aes192, -aes256\n");
		BIO_printf (bio_err, "               encrypt PEM output with cbc aes\n");
d400 2
a401 2
		BIO_printf (bio_err, "-camellia128, -camellia192, -camellia256\n");
		BIO_printf (bio_err, "               encrypt PEM output with cbc camellia\n");
d403 25
a427 25
		BIO_printf (bio_err, "-nointern      don't search certificates in message for signer\n");
		BIO_printf (bio_err, "-nosigs        don't verify message signature\n");
		BIO_printf (bio_err, "-noverify      don't verify signers certificate\n");
		BIO_printf (bio_err, "-nocerts       don't include signers certificate when signing\n");
		BIO_printf (bio_err, "-nodetach      use opaque signing\n");
		BIO_printf (bio_err, "-noattr        don't include any signed attributes\n");
		BIO_printf (bio_err, "-binary        don't translate message to text\n");
		BIO_printf (bio_err, "-certfile file other certificates file\n");
		BIO_printf (bio_err, "-signer file   signer certificate file\n");
		BIO_printf (bio_err, "-recip  file   recipient certificate file for decryption\n");
		BIO_printf (bio_err, "-in file       input file\n");
		BIO_printf (bio_err, "-inform arg    input format SMIME (default), PEM or DER\n");
		BIO_printf (bio_err, "-inkey file    input private key (if not signer or recipient)\n");
		BIO_printf (bio_err, "-keyform arg   input private key format (PEM or ENGINE)\n");
		BIO_printf (bio_err, "-out file      output file\n");
		BIO_printf (bio_err, "-outform arg   output format SMIME (default), PEM or DER\n");
		BIO_printf (bio_err, "-content file  supply or override content for detached signature\n");
		BIO_printf (bio_err, "-to addr       to address\n");
		BIO_printf (bio_err, "-from ad       from address\n");
		BIO_printf (bio_err, "-subject s     subject\n");
		BIO_printf (bio_err, "-text          include or delete text MIME headers\n");
		BIO_printf (bio_err, "-CApath dir    trusted certificates directory\n");
		BIO_printf (bio_err, "-CAfile file   trusted certificates file\n");
		BIO_printf (bio_err, "-crl_check     check revocation status of signer's certificate using CRLs\n");
		BIO_printf (bio_err, "-crl_check_all check revocation status of signer's certificate chain using CRLs\n");
d429 1
a429 1
		BIO_printf (bio_err, "-engine e      use engine e, possibly a hardware device.\n");
d431 5
a435 5
		BIO_printf (bio_err, "-passin arg    input file pass phrase source\n");
		BIO_printf(bio_err,  "-rand file%cfile%c...\n", ':', ':');
		BIO_printf(bio_err,  "               load the file (or the files in the directory) into\n");
		BIO_printf(bio_err,  "               the random number generator\n");
		BIO_printf (bio_err, "cert.pem       recipient certificate(s) for encryption\n");
d437 1
a437 2
		}

d439 1
a439 1
        e = setup_engine(bio_err, engine, 0);
d442 1
a442 2
	if (!app_passwd(bio_err, passargin, NULL, &passin, NULL))
		{
d445 2
a446 4
		}

	if (need_rand)
		{
d449 3
a451 4
			BIO_printf(bio_err,"%ld semi-random bytes loaded\n",
				app_RAND_load_files(inrand));
		}

d457 1
a457 2
	if (operation & SMIME_OP)
		{
d460 1
a460 3
		}
	else
		{
d463 1
a463 1
		}
d465 1
a465 2
	if (operation & SMIME_IP)
		{
d468 1
a468 3
		}
	else
		{
d471 1
a471 1
		}
d473 3
a475 5
	if (operation == SMIME_ENCRYPT)
		{
		if (!cipher)
			{
#ifndef OPENSSL_NO_RC2			
d481 1
a481 1
			}
d483 3
a485 5
		while (*args)
			{
			if (!(cert = load_cert(bio_err,*args,FORMAT_PEM,
				NULL, e, "recipient certificate file")))
				{
d490 1
a490 1
				}
a493 1
			}
d495 4
a498 6

	if (certfile)
		{
		if (!(other = load_certs(bio_err,certfile,FORMAT_PEM, NULL,
			e, "certificate file")))
			{
a500 1
			}
d502 4
a505 6

	if (recipfile && (operation == SMIME_DECRYPT))
		{
		if (!(recip = load_cert(bio_err,recipfile,FORMAT_PEM,NULL,
			e, "recipient certificate file")))
			{
a507 1
			}
d509 2
a510 3

	if (operation == SMIME_DECRYPT)
		{
d513 1
a513 3
		}
	else if (operation == SMIME_SIGN)
		{
d516 2
a517 2
		}
	else keyfile = NULL;
d519 1
a519 2
	if (keyfile)
		{
d521 1
a521 1
			       "signing key file");
d524 5
a528 8
		}

	if (infile)
		{
		if (!(in = BIO_new_file(infile, inmode)))
			{
			BIO_printf (bio_err,
				 "Can't open input file %s\n", infile);
a529 1
			}
d531 1
a531 1
	else
d534 2
a535 3
	if (operation & SMIME_IP)
		{
		if (informat == FORMAT_SMIME) 
d537 1
a537 1
		else if (informat == FORMAT_PEM) 
d539 1
a539 1
		else if (informat == FORMAT_ASN1) 
d541 1
a541 2
		else
			{
d544 1
a544 1
			}
d546 1
a546 2
		if (!p7)
			{
d549 2
a550 3
			}
		if (contfile)
			{
d552 1
a552 2
			if (!(indata = BIO_new_file(contfile, "rb")))
				{
a554 1
				}
d557 5
a561 7

	if (outfile)
		{
		if (!(out = BIO_new_file(outfile, outmode)))
			{
			BIO_printf (bio_err,
				 "Can't open output file %s\n", outfile);
a562 1
			}
d564 1
a564 2
	else
		{
d566 1
a566 1
		}
d568 1
a568 2
	if (operation == SMIME_VERIFY)
		{
d574 1
a574 3
		}


d577 1
a577 2
	if (operation == SMIME_ENCRYPT)
		{
d581 1
a581 3
		}
	else if (operation & SMIME_SIGNERS)
		{
d583 2
a584 1
		/* If detached data content we only enable streaming if
d587 2
a588 4
		if (operation == SMIME_SIGN)
			{
			if (flags & PKCS7_DETACHED)
				{
d591 1
a591 2
				}
			else if (indef)
d597 1
a597 2
			}
		else
d599 1
a599 2
		for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++)
			{
d602 2
a603 2
			signer = load_cert(bio_err, signerfile,FORMAT_PEM, NULL,
					e, "signer certificate");
d607 1
a607 1
			       "signing key file");
d611 1
a611 1
						sign_md, flags))
d617 1
a617 1
			}
d619 1
a619 2
		if ((operation == SMIME_SIGN) && !(flags & PKCS7_STREAM))
			{
a621 1
			}
d623 2
a624 3

	if (!p7)
		{
d627 1
a627 2
		}

d629 2
a630 4
	if (operation == SMIME_DECRYPT)
		{
		if (!PKCS7_decrypt(p7, key, recip, out, flags))
			{
a632 1
			}
d634 2
a635 3
	else if (operation == SMIME_VERIFY)
		{
		STACK_OF(X509) *signers;
d638 1
a638 2
		else
			{
d641 1
a641 1
			}
d643 1
a643 2
		if (!save_certs(signerfile, signers))
			{
d645 1
a645 1
								signerfile);
d648 1
a648 1
			}
d650 1
a650 2
		}
	else if (operation == SMIME_PK7OUT)
d652 1
a652 2
	else
		{
d659 1
a659 2
		if (outformat == FORMAT_SMIME) 
			{
d664 1
a664 2
			}
		else if (outformat == FORMAT_PEM) 
d666 3
a668 4
		else if (outformat == FORMAT_ASN1) 
			i2d_PKCS7_bio_stream(out,p7, in, flags);
		else
			{
a670 1
			}
d672 1
d677 2
a678 1
	if (ret) ERR_print_errors(bio_err);
d696 2
a697 1
	if (passin) free(passin);
d701 3
a703 2
static int save_certs(char *signerfile, STACK_OF(X509) *signers)
	{
d709 3
a711 2
	if (!tmp) return 0;
	for(i = 0; i < sk_X509_num(signers); i++)
d715 2
a716 2
	}
	
d720 3
a722 2
static int smime_cb(int ok, X509_STORE_CTX *ctx)
	{
d728 1
a728 1
		&& ((error != X509_V_OK) || (ok != 2)))
d735 1
a735 1
	}
@


1.13
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d488 1
a488 1
		BIO_printf(bio_err,  "-rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
@


1.12
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d816 1
a816 1
	if (passin) OPENSSL_free(passin);
@


1.11
log
@resolve conflicts, fix local changes
@
text
@a661 6
#ifdef OPENSSL_SYS_VMS
		{
		    BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		    out = BIO_push(tmpbio, out);
		}
#endif
@


1.10
log
@resolve conflicts
@
text
@d76 2
d79 5
a83 4
#define SMIME_DECRYPT	2
#define SMIME_SIGN	(3 | SMIME_OP)
#define SMIME_VERIFY	4
#define SMIME_PK7OUT	5
d96 1
d112 2
d144 2
d204 6
d216 4
a219 7
			if (args[1])
				{
				args++;
				inrand = *args;
				}
			else
				badarg = 1;
d225 3
a227 6
			if (args[1])
				{
				args++;
				engine = *args;
				}
			else badarg = 1;
d232 3
a234 7
			if (args[1])
				{
				args++;
				passargin = *args;
				}
			else
				badarg = 1;
d238 3
a240 7
			if (args[1])
				{
				args++;
				to = *args;
				}
			else
				badarg = 1;
d244 3
a246 6
			if (args[1])
				{
				args++;
				from = *args;
				}
			else badarg = 1;
d250 3
a252 7
			if (args[1])
				{
				args++;
				subject = *args;
				}
			else
				badarg = 1;
d256 15
a270 4
			if (args[1])
				{
				args++;
				signerfile = *args;
d272 1
a272 2
			else
				badarg = 1;
d276 14
a289 4
			if (args[1])
				{
				args++;
				recipfile = *args;
a290 1
			else badarg = 1;
d294 17
a310 4
			if (args[1])
				{
				args++;
				keyfile = *args;
d312 2
a313 3
			else
				badarg = 1;
		}
d316 3
a318 7
			if (args[1])
				{
				args++;
				keyform = str2fmt(*args);
				}
			else
				badarg = 1;
d322 3
a324 7
			if (args[1])
				{
				args++;
				certfile = *args;
				}
			else
				badarg = 1;
d328 3
a330 7
			if (args[1])
				{
				args++;
				CAfile = *args;
				}
			else
				badarg = 1;
d334 3
a336 7
			if (args[1])
				{
				args++;
				CApath = *args;
				}
			else
				badarg = 1;
d340 3
a342 7
			if (args[1])
				{
				args++;
				infile = *args;
				}
			else
				badarg = 1;
d346 3
a348 7
			if (args[1])
				{
				args++;
				informat = str2fmt(*args);
				}
			else
				badarg = 1;
d352 3
a354 7
			if (args[1])
				{
				args++;
				outformat = str2fmt(*args);
				}
			else
				badarg = 1;
d358 3
a360 7
			if (args[1])
				{
				args++;
				outfile = *args;
				}
			else
				badarg = 1;
d364 3
a366 7
			if (args[1])
				{
				args++;
				contfile = *args;
				}
			else
				badarg = 1;
d370 1
a370 1
		else
d375 5
d381 1
a381 1
	if (operation == SMIME_SIGN)
d383 18
a400 1
		if (!signerfile)
d405 2
d431 1
d515 1
a515 1
	if (operation != SMIME_SIGN)
a519 2
		if (flags & PKCS7_BINARY)
			inmode = "rb";
d527 4
d534 5
a567 12
	if (signerfile && (operation == SMIME_SIGN))
		{
		if (!(signer = load_cert(bio_err,signerfile,FORMAT_PEM, NULL,
			e, "signer certificate")))
			{
#if 0			/* An appropri message has already been printed */
			BIO_printf(bio_err, "Can't read signer certificate file %s\n", signerfile);
#endif
			goto end;
			}
		}

a572 3
#if 0			/* An appropriate message has already been printed */
			BIO_printf(bio_err, "Can't read certificate file %s\n", certfile);
#endif
a582 3
#if 0			/* An appropriate message has alrady been printed */
			BIO_printf(bio_err, "Can't read recipient certificate file %s\n", recipfile);
#endif
d620 30
d674 1
a674 1
		X509_STORE_set_verify_cb_func(store, smime_cb);
a682 2
		p7 = PKCS7_encrypt(encerts, in, cipher, flags);
	else if (operation == SMIME_SIGN)
d684 1
a684 4
		/* If detached data and SMIME output enable partial
		 * signing.
		 */
		if ((flags & PKCS7_DETACHED) && (outformat == FORMAT_SMIME))
d686 1
a686 1
		p7 = PKCS7_sign(signer, key, other, in, flags);
d688 1
a688 1
	else
d690 5
a694 7
		if (informat == FORMAT_SMIME) 
			p7 = SMIME_read_PKCS7(in, &indata);
		else if (informat == FORMAT_PEM) 
			p7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);
		else if (informat == FORMAT_ASN1) 
			p7 = d2i_PKCS7_bio(in, NULL);
		else
d696 11
a706 2
			BIO_printf(bio_err, "Bad input format for PKCS#7 file\n");
			goto end;
d708 3
a710 2

		if (!p7)
d712 17
a728 2
			BIO_printf(bio_err, "Error reading S/MIME message\n");
			goto end;
d730 2
a731 1
		if (contfile)
d733 1
a733 4
			BIO_free(indata);
			if (!(indata = BIO_new_file(contfile, "rb")))
				{
				BIO_printf(bio_err, "Can't read content file %s\n", contfile);
a734 1
				}
d784 6
a789 1
			SMIME_write_PKCS7(out, p7, in, flags);
d791 1
a791 1
			PEM_write_bio_PKCS7(out,p7);
d793 1
a793 1
			i2d_PKCS7_bio(out,p7);
d809 4
@


1.9
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.8
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d3 1
a3 1
 * project 1999.
d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d67 2
d73 1
d85 1
a85 1
{
d90 1
a90 1
	char *inmode = "r", *outmode = "w";
d102 1
a102 1
	int flags = PKCS7_DETACHED, store_flags = 0;
d114 2
d122 1
d125 1
d130 12
a141 6
	while (!badarg && *args && *args[0] == '-') {
		if (!strcmp (*args, "-encrypt")) operation = SMIME_ENCRYPT;
		else if (!strcmp (*args, "-decrypt")) operation = SMIME_DECRYPT;
		else if (!strcmp (*args, "-sign")) operation = SMIME_SIGN;
		else if (!strcmp (*args, "-verify")) operation = SMIME_VERIFY;
		else if (!strcmp (*args, "-pk7out")) operation = SMIME_PK7OUT;
d148 4
d168 8
d200 4
a203 6
		else if (!strcmp (*args, "-crl_check"))
				store_flags |= X509_V_FLAG_CRL_CHECK;
		else if (!strcmp (*args, "-crl_check_all"))
				store_flags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;
		else if (!strcmp(*args,"-rand")) {
			if (args[1]) {
d206 3
a208 1
			} else badarg = 1;
d210 1
d212 4
a215 2
		} else if (!strcmp(*args,"-engine")) {
			if (args[1]) {
d218 3
a220 1
			} else badarg = 1;
d222 4
a225 2
		} else if (!strcmp(*args,"-passin")) {
			if (args[1]) {
d228 8
a235 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-to")) {
			if (args[1]) {
d238 8
a245 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-from")) {
			if (args[1]) {
d248 7
a254 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-subject")) {
			if (args[1]) {
d257 8
a264 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-signer")) {
			if (args[1]) {
d267 8
a274 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-recip")) {
			if (args[1]) {
d277 7
a283 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-inkey")) {
			if (args[1]) {
d286 8
a293 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-keyform")) {
			if (args[1]) {
d296 8
a303 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-certfile")) {
			if (args[1]) {
d306 8
a313 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-CAfile")) {
			if (args[1]) {
d316 8
a323 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-CApath")) {
			if (args[1]) {
d326 8
a333 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-in")) {
			if (args[1]) {
d336 8
a343 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-inform")) {
			if (args[1]) {
d346 8
a353 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-outform")) {
			if (args[1]) {
d356 8
a363 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-out")) {
			if (args[1]) {
d366 8
a373 3
			} else badarg = 1;
		} else if (!strcmp (*args, "-content")) {
			if (args[1]) {
d376 8
a383 2
			} else badarg = 1;
		} else badarg = 1;
d385 2
a386 1
	}
d388 4
a391 2
	if(operation == SMIME_SIGN) {
		if(!signerfile) {
d394 2
d397 5
a401 4
		need_rand = 1;
	} else if(operation == SMIME_DECRYPT) {
		if(!recipfile) {
			BIO_printf(bio_err, "No recipient certificate and key specified\n");
d403 1
d405 4
a408 2
	} else if(operation == SMIME_ENCRYPT) {
		if(!*args) {
d411 2
d414 2
a415 2
		need_rand = 1;
	} else if(!operation) badarg = 1;
d417 2
a418 1
	if (badarg) {
d430 3
d442 4
d480 1
a480 1
	}
d486 2
a487 1
	if(!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
d490 1
a490 1
	}
d492 2
a493 1
	if (need_rand) {
d498 1
a498 1
	}
d502 2
a503 1
	if(operation != SMIME_SIGN) flags &= ~PKCS7_DETACHED;
d505 14
a518 7
	if(operation & SMIME_OP) {
		if(flags & PKCS7_BINARY) inmode = "rb";
		if(outformat == FORMAT_ASN1) outmode = "wb";
	} else {
		if(flags & PKCS7_BINARY) outmode = "wb";
		if(informat == FORMAT_ASN1) inmode = "rb";
	}
d520 4
a523 2
	if(operation == SMIME_ENCRYPT) {
		if (!cipher) {
d530 1
a530 1
		}
d532 5
a536 3
		while (*args) {
			if(!(cert = load_cert(bio_err,*args,FORMAT_PEM,
				NULL, e, "recipient certificate file"))) {
d541 1
a541 1
			}
d545 1
a546 1
	}
d548 5
a552 3
	if(signerfile && (operation == SMIME_SIGN)) {
		if(!(signer = load_cert(bio_err,signerfile,FORMAT_PEM, NULL,
			e, "signer certificate"))) {
d557 1
a558 1
	}
d560 5
a564 3
	if(certfile) {
		if(!(other = load_certs(bio_err,certfile,FORMAT_PEM, NULL,
			e, "certificate file"))) {
d570 1
a571 1
	}
d573 5
a577 3
	if(recipfile && (operation == SMIME_DECRYPT)) {
		if(!(recip = load_cert(bio_err,recipfile,FORMAT_PEM,NULL,
			e, "recipient certificate file"))) {
d583 1
a584 1
	}
d586 11
a596 5
	if(operation == SMIME_DECRYPT) {
		if(!keyfile) keyfile = recipfile;
	} else if(operation == SMIME_SIGN) {
		if(!keyfile) keyfile = signerfile;
	} else keyfile = NULL;
d598 2
a599 1
	if(keyfile) {
d602 1
a602 1
		if (!key) {
d604 1
a604 2
                }
	}
d606 4
a609 2
	if (infile) {
		if (!(in = BIO_new_file(infile, inmode))) {
d613 1
d615 2
a616 1
	} else in = BIO_new_fp(stdin, BIO_NOCLOSE);
d618 4
a621 2
	if (outfile) {
		if (!(out = BIO_new_file(outfile, outmode))) {
d625 1
d627 2
a628 1
	} else {
d636 1
a636 1
	}
d638 8
a645 4
	if(operation == SMIME_VERIFY) {
		if(!(store = setup_verify(bio_err, CAfile, CApath))) goto end;
		X509_STORE_set_flags(store, store_flags);
	}
d650 1
a650 1
	if(operation == SMIME_ENCRYPT) {
d652 7
a658 1
	} else if(operation == SMIME_SIGN) {
a659 3
		if (BIO_reset(in) != 0 && (flags & PKCS7_DETACHED)) {
		  BIO_printf(bio_err, "Can't rewind input file\n");
		  goto end;
d661 3
a663 2
	} else {
		if(informat == FORMAT_SMIME) 
d665 1
a665 1
		else if(informat == FORMAT_PEM) 
d667 1
a667 1
		else if(informat == FORMAT_ASN1) 
d669 2
a670 1
		else {
d673 1
a673 1
		}
d675 2
a676 1
		if(!p7) {
d679 3
a681 2
		}
		if(contfile) {
d683 2
a684 1
			if(!(indata = BIO_new_file(contfile, "rb"))) {
d687 1
a689 1
	}
d691 2
a692 1
	if(!p7) {
d695 1
a695 1
	}
d698 4
a701 2
	if(operation == SMIME_DECRYPT) {
		if(!PKCS7_decrypt(p7, key, recip, out, flags)) {
d704 1
d706 2
a707 1
	} else if(operation == SMIME_VERIFY) {
d709 1
a709 1
		if(PKCS7_verify(p7, other, store, indata, out, flags)) {
d711 2
a712 1
		} else {
d715 1
a715 1
		}
d717 2
a718 1
		if(!save_certs(signerfile, signers)) {
d723 2
d726 1
a726 2
		sk_X509_free(signers);
	} else if(operation == SMIME_PK7OUT) {
d728 9
a736 5
	} else {
		if(to) BIO_printf(out, "To: %s\n", to);
		if(from) BIO_printf(out, "From: %s\n", from);
		if(subject) BIO_printf(out, "Subject: %s\n", subject);
		if(outformat == FORMAT_SMIME) 
d738 1
a738 1
		else if(outformat == FORMAT_PEM) 
d740 1
a740 1
		else if(outformat == FORMAT_ASN1) 
d742 2
a743 1
		else {
d746 1
a747 1
	}
d752 1
a752 1
	if(ret) ERR_print_errors(bio_err);
d755 2
d766 1
a766 1
	if(passin) OPENSSL_free(passin);
d771 1
a771 1
{
d774 2
a775 1
	if(!signerfile) return 1;
d777 1
a777 1
	if(!tmp) return 0;
d782 1
a782 1
}
d784 18
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d171 4
@


1.6
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d107 1
d109 1
d181 1
d187 1
d337 1
d339 1
d348 1
d350 1
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d431 1
a431 1
		key = load_key(bio_err, keyfile, keyform, passin, e,
@


1.4
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@a66 1
#include <openssl/engine.h>
a69 1
static X509_STORE *setup_verify(char *CAfile, char *CApath);
d91 1
a91 1
	EVP_CIPHER *cipher = NULL;
d99 1
a99 1
	int flags = PKCS7_DETACHED;
d106 1
d112 9
d127 1
a127 1
#ifndef NO_DES
d133 1
a133 1
#ifndef NO_RC2
d141 8
d169 4
d219 5
d295 1
a295 1
#ifndef NO_DES
d299 1
a299 1
#ifndef NO_RC2
d304 4
d321 1
d331 2
d342 1
a342 17
	if (engine != NULL)
		{
		if((e = ENGINE_by_id(engine)) == NULL)
			{
			BIO_printf(bio_err,"invalid engine \"%s\"\n",
				engine);
			goto end;
			}
		if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
			{
			BIO_printf(bio_err,"can't use that engine\n");
			goto end;
			}
		BIO_printf(bio_err,"engine \"%s\" set.\n", engine);
		/* Free our "structural" reference. */
		ENGINE_free(e);
		}
d370 1
a370 1
#ifndef NO_RC2			
d379 3
a381 1
			if(!(cert = load_cert(bio_err,*args,FORMAT_PEM))) {
d383 1
d393 3
a395 1
		if(!(signer = load_cert(bio_err,signerfile,FORMAT_PEM))) {
d397 1
d403 3
a405 1
		if(!(other = load_certs(bio_err,certfile,FORMAT_PEM))) {
d407 1
d414 3
a416 1
		if(!(recip = load_cert(bio_err,recipfile,FORMAT_PEM))) {
d418 1
d431 3
a433 3
		if(!(key = load_key(bio_err,keyfile, FORMAT_PEM, passin))) {
			BIO_printf(bio_err, "Can't read recipient certificate file %s\n", keyfile);
			ERR_print_errors(bio_err);
d435 1
a435 1
		}
d454 1
a454 1
#ifdef VMS
d463 2
a464 1
		if(!(store = setup_verify(CAfile, CApath))) goto end;
d467 1
d474 4
a477 1
		BIO_reset(in);
d517 1
a517 1
			BIO_printf(bio_err, "Verification Successful\n");
d519 1
a519 1
			BIO_printf(bio_err, "Verification Failure\n");
a564 30
}

static X509_STORE *setup_verify(char *CAfile, char *CApath)
{
	X509_STORE *store;
	X509_LOOKUP *lookup;
	if(!(store = X509_STORE_new())) goto end;
	lookup=X509_STORE_add_lookup(store,X509_LOOKUP_file());
	if (lookup == NULL) goto end;
	if (CAfile) {
		if(!X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM)) {
			BIO_printf(bio_err, "Error loading file %s\n", CAfile);
			goto end;
		}
	} else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);
		
	lookup=X509_STORE_add_lookup(store,X509_LOOKUP_hash_dir());
	if (lookup == NULL) goto end;
	if (CApath) {
		if(!X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM)) {
			BIO_printf(bio_err, "Error loading directory %s\n", CApath);
			goto end;
		}
	} else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);

	ERR_clear_error();
	return store;
	end:
	X509_STORE_free(store);
	return NULL;
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d302 1
@


1.2
log
@OpenSSL 0.9.5a merge
@
text
@d67 1
a70 3
static X509 *load_cert(char *file);
static EVP_PKEY *load_key(char *file, char *pass);
static STACK_OF(X509) *load_certs(char *file);
d85 1
d92 1
a92 1
	char *certfile = NULL, *keyfile = NULL;
d107 3
a110 1

d147 2
d159 5
d219 10
d234 5
d290 1
d293 2
d301 1
d309 18
d343 6
a348 3
	if(flags & PKCS7_BINARY) {
		if(operation & SMIME_OP) inmode = "rb";
		else outmode = "rb";
d362 1
a362 1
			if(!(cert = load_cert(*args))) {
d373 1
a373 1
		if(!(signer = load_cert(signerfile))) {
d380 1
a380 1
		if(!(other = load_certs(certfile))) {
d388 1
a388 1
		if(!(recip = load_cert(recipfile))) {
d402 1
a402 1
		if(!(key = load_key(keyfile, passin))) {
d423 9
a431 1
	} else out = BIO_new_fp(stdout, BIO_NOCLOSE);
d445 12
a456 1
		if(!(p7 = SMIME_read_PKCS7(in, &indata))) {
d460 7
d502 10
a511 1
		SMIME_write_PKCS7(out, p7, in, flags);
d528 2
a529 2
	BIO_free(out);
	if(passin) Free(passin);
a530 43
}

static X509 *load_cert(char *file)
{
	BIO *in;
	X509 *cert;
	if(!(in = BIO_new_file(file, "r"))) return NULL;
	cert = PEM_read_bio_X509(in, NULL, NULL,NULL);
	BIO_free(in);
	return cert;
}

static EVP_PKEY *load_key(char *file, char *pass)
{
	BIO *in;
	EVP_PKEY *key;
	if(!(in = BIO_new_file(file, "r"))) return NULL;
	key = PEM_read_bio_PrivateKey(in, NULL,NULL,pass);
	BIO_free(in);
	return key;
}

static STACK_OF(X509) *load_certs(char *file)
{
	BIO *in;
	int i;
	STACK_OF(X509) *othercerts;
	STACK_OF(X509_INFO) *allcerts;
	X509_INFO *xi;
	if(!(in = BIO_new_file(file, "r"))) return NULL;
	othercerts = sk_X509_new(NULL);
	if(!othercerts) return NULL;
	allcerts = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL);
	for(i = 0; i < sk_X509_INFO_num(allcerts); i++) {
		xi = sk_X509_INFO_value (allcerts, i);
		if (xi->x509) {
			sk_X509_push(othercerts, xi->x509);
			xi->x509 = NULL;
		}
	}
	sk_X509_INFO_pop_free(allcerts, X509_INFO_free);
	BIO_free(in);
	return othercerts;
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d275 1
a275 1
		BIO_printf(bio_err,  "-rand file:file:...\n");
a311 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("load encryption certificates");
#endif		
a321 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a324 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("load signer certificate");
#endif		
a328 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a331 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("load other certfiles");
#endif		
a336 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a339 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("load recipient certificate");
#endif		
a344 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a353 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("load keyfile");
#endif		
a358 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a360 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_push_info("open input files");
#endif		
d368 1
a368 7
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
#endif		

#ifdef CRYPTO_MDEBUG
	CRYPTO_push_info("open output files");
#endif		
a375 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
#endif		
a377 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("setup_verify");
#endif		
a378 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a383 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("PKCS7_encrypt");
#endif		
a384 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a385 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("PKCS7_sign");
#endif		
a387 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a388 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("SMIME_read_PKCS7");
#endif		
a392 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a401 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("PKCS7_decrypt");
#endif		
a405 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a407 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("PKCS7_verify");
#endif		
a413 4
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
		CRYPTO_push_info("PKCS7_get0_signers");
#endif		
a414 4
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
		CRYPTO_push_info("save_certs");
#endif		
a420 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif		
a431 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_remove_all_info();
#endif
a496 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_push_info("X509_STORE_new");
#endif	
a497 4
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("X509_STORE_add_lookup(...file)");
#endif	
a499 4
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("X509_LOOKUP_load_file");
#endif	
a506 4
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("X509_STORE_add_lookup(...hash_dir)");
#endif	
a508 4
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("X509_LOOKUP_add_dir");
#endif	
a514 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
#endif	
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d70 4
a86 1
	ENGINE *e = NULL;
d93 2
a94 2
	char *certfile = NULL, *keyfile = NULL, *contfile=NULL;
	const EVP_CIPHER *cipher = NULL;
d102 1
a102 1
	int flags = PKCS7_DETACHED, store_flags = 0;
d108 1
a108 3
	int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;
        int keyform = FORMAT_PEM;
	char *engine=NULL;
a109 1
	args = argv + 1;
a111 9
	apps_startup();

	if (bio_err == NULL)
		if ((bio_err = BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE|BIO_FP_TEXT);

	if (!load_config(bio_err, NULL))
		goto end;

d118 1
a118 1
#ifndef OPENSSL_NO_DES
d124 1
a124 1
#ifndef OPENSSL_NO_RC2
a131 8
#ifndef OPENSSL_NO_AES
		else if (!strcmp(*args,"-aes128"))
				cipher = EVP_aes_128_cbc();
		else if (!strcmp(*args,"-aes192"))
				cipher = EVP_aes_192_cbc();
		else if (!strcmp(*args,"-aes256"))
				cipher = EVP_aes_256_cbc();
#endif
a145 2
		else if (!strcmp (*args, "-nosmimecap"))
				flags |= PKCS7_NOSMIMECAP;
a149 4
		else if (!strcmp (*args, "-crl_check"))
				store_flags |= X509_V_FLAG_CRL_CHECK;
		else if (!strcmp (*args, "-crl_check_all"))
				store_flags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;
a155 5
		} else if (!strcmp(*args,"-engine")) {
			if (args[1]) {
				args++;
				engine = *args;
			} else badarg = 1;
a190 5
		} else if (!strcmp (*args, "-keyform")) {
			if (args[1]) {
				args++;
				keyform = str2fmt(*args);
			} else badarg = 1;
a210 10
		} else if (!strcmp (*args, "-inform")) {
			if (args[1]) {
				args++;
				informat = str2fmt(*args);
			} else badarg = 1;
		} else if (!strcmp (*args, "-outform")) {
			if (args[1]) {
				args++;
				outformat = str2fmt(*args);
			} else badarg = 1;
a215 5
		} else if (!strcmp (*args, "-content")) {
			if (args[1]) {
				args++;
				contfile = *args;
			} else badarg = 1;
d247 1
a247 1
#ifndef OPENSSL_NO_DES
d251 1
a251 1
#ifndef OPENSSL_NO_RC2
a255 4
#ifndef OPENSSL_NO_AES
		BIO_printf (bio_err, "-aes128, -aes192, -aes256\n");
		BIO_printf (bio_err, "               encrypt PEM output with cbc aes\n");
#endif
a266 1
		BIO_printf (bio_err, "-inform arg    input format SMIME (default), PEM or DER\n");
a267 1
		BIO_printf (bio_err, "-keyform arg   input private key format (PEM or ENGINE)\n");
a268 2
		BIO_printf (bio_err, "-outform arg   output format SMIME (default), PEM or DER\n");
		BIO_printf (bio_err, "-content file  supply or override content for detached signature\n");
d275 1
a275 5
		BIO_printf (bio_err, "-crl_check     check revocation status of signer's certificate using CRLs\n");
		BIO_printf (bio_err, "-crl_check_all check revocation status of signer's certificate chain using CRLs\n");
		BIO_printf (bio_err, "-engine e      use engine e, possibly a hardware device.\n");
		BIO_printf (bio_err, "-passin arg    input file pass phrase source\n");
		BIO_printf(bio_err,  "-rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
a281 2
        e = setup_engine(bio_err, engine, 0);

d298 3
a300 6
	if(operation & SMIME_OP) {
		if(flags & PKCS7_BINARY) inmode = "rb";
		if(outformat == FORMAT_ASN1) outmode = "wb";
	} else {
		if(flags & PKCS7_BINARY) outmode = "wb";
		if(informat == FORMAT_ASN1) inmode = "rb";
d305 1
a305 1
#ifndef OPENSSL_NO_RC2			
d312 3
d317 1
a317 3
			if(!(cert = load_cert(bio_err,*args,FORMAT_PEM,
				NULL, e, "recipient certificate file"))) {
#if 0				/* An appropriate message is already printed */
a318 1
#endif
d325 3
d331 4
a334 3
		if(!(signer = load_cert(bio_err,signerfile,FORMAT_PEM, NULL,
			e, "signer certificate"))) {
#if 0			/* An appropri message has already been printed */
a335 1
#endif
d338 3
d344 4
a347 3
		if(!(other = load_certs(bio_err,certfile,FORMAT_PEM, NULL,
			e, "certificate file"))) {
#if 0			/* An appropriate message has already been printed */
a348 1
#endif
d352 3
d358 4
a361 3
		if(!(recip = load_cert(bio_err,recipfile,FORMAT_PEM,NULL,
			e, "recipient certificate file"))) {
#if 0			/* An appropriate message has alrady been printed */
a362 1
#endif
d366 3
d378 6
a383 3
		key = load_key(bio_err, keyfile, keyform, passin, e,
			       "signing key file");
		if (!key) {
d385 4
a388 1
                }
d391 3
d401 7
a407 1

d414 4
a417 9
	} else {
		out = BIO_new_fp(stdout, BIO_NOCLOSE);
#ifdef OPENSSL_SYS_VMS
		{
		    BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		    out = BIO_push(tmpbio, out);
		}
#endif
	}
d420 7
a426 2
		if(!(store = setup_verify(bio_err, CAfile, CApath))) goto end;
		X509_STORE_set_flags(store, store_flags);
a428 1

d432 3
d436 3
d440 3
d444 4
a447 4
		if (BIO_reset(in) != 0 && (flags & PKCS7_DETACHED)) {
		  BIO_printf(bio_err, "Can't rewind input file\n");
		  goto end;
		}
d449 4
a452 12
		if(informat == FORMAT_SMIME) 
			p7 = SMIME_read_PKCS7(in, &indata);
		else if(informat == FORMAT_PEM) 
			p7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);
		else if(informat == FORMAT_ASN1) 
			p7 = d2i_PKCS7_bio(in, NULL);
		else {
			BIO_printf(bio_err, "Bad input format for PKCS#7 file\n");
			goto end;
		}

		if(!p7) {
d456 3
a458 7
		if(contfile) {
			BIO_free(indata);
			if(!(indata = BIO_new_file(contfile, "rb"))) {
				BIO_printf(bio_err, "Can't read content file %s\n", contfile);
				goto end;
			}
		}
d468 3
d475 3
d480 3
d484 1
a484 1
			BIO_printf(bio_err, "Verification successful\n");
d486 1
a486 1
			BIO_printf(bio_err, "Verification failure\n");
d489 4
d494 4
d504 3
d514 1
a514 10
		if(outformat == FORMAT_SMIME) 
			SMIME_write_PKCS7(out, p7, in, flags);
		else if(outformat == FORMAT_PEM) 
			PEM_write_bio_PKCS7(out,p7);
		else if(outformat == FORMAT_ASN1) 
			i2d_PKCS7_bio(out,p7);
		else {
			BIO_printf(bio_err, "Bad output format for PKCS#7 file\n");
			goto end;
		}
d518 3
d534 2
a535 2
	BIO_free_all(out);
	if(passin) OPENSSL_free(passin);
d537 95
@


1.1.1.2
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d431 1
a431 1
		key = load_key(bio_err, keyfile, keyform, 0, passin, e,
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@a106 1
#ifndef OPENSSL_NO_ENGINE
a107 1
#endif
a178 1
#ifndef OPENSSL_NO_ENGINE
a183 1
#endif
a332 1
#ifndef OPENSSL_NO_ENGINE
a333 1
#endif
a341 1
#ifndef OPENSSL_NO_ENGINE
a342 1
#endif
@


1.1.1.4
log
@import 0.9.7c
@
text
@a170 4
		else if (!strcmp (*args, "-nooldmime"))
				flags |= PKCS7_NOOLDMIMETYPE;
		else if (!strcmp (*args, "-crlfeol"))
				flags |= PKCS7_CRLFEOL;
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@d3 1
a3 1
 * project.
d6 1
a6 1
 * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.
a66 2
#include <openssl/x509_vfy.h>
#include <openssl/x509v3.h>
a70 1
static int smime_cb(int ok, X509_STORE_CTX *ctx);
d82 1
a82 1
	{
d87 1
a87 1
	const char *inmode = "r", *outmode = "w";
d99 1
a99 1
	int flags = PKCS7_DETACHED;
a110 2
	X509_VERIFY_PARAM *vpm = NULL;

a116 1
		{
a118 1
		}
d123 6
a128 12
	while (!badarg && *args && *args[0] == '-')
		{
		if (!strcmp (*args, "-encrypt"))
			operation = SMIME_ENCRYPT;
		else if (!strcmp (*args, "-decrypt"))
			operation = SMIME_DECRYPT;
		else if (!strcmp (*args, "-sign"))
			operation = SMIME_SIGN;
		else if (!strcmp (*args, "-verify"))
			operation = SMIME_VERIFY;
		else if (!strcmp (*args, "-pk7out"))
			operation = SMIME_PK7OUT;
a134 4
#ifndef OPENSSL_NO_SEED
		else if (!strcmp (*args, "-seed")) 
				cipher = EVP_seed_cbc();
#endif
a150 8
#ifndef OPENSSL_NO_CAMELLIA
		else if (!strcmp(*args,"-camellia128"))
				cipher = EVP_camellia_128_cbc();
		else if (!strcmp(*args,"-camellia192"))
				cipher = EVP_camellia_192_cbc();
		else if (!strcmp(*args,"-camellia256"))
				cipher = EVP_camellia_256_cbc();
#endif
d175 6
a180 4
		else if (!strcmp(*args,"-rand"))
			{
			if (args[1])
				{
d183 1
a183 3
				}
			else
				badarg = 1;
a184 1
			}
d186 2
a187 4
		else if (!strcmp(*args,"-engine"))
			{
			if (args[1])
				{
d190 1
a190 3
				}
			else badarg = 1;
			}
d192 2
a193 4
		else if (!strcmp(*args,"-passin"))
			{
			if (args[1])
				{
d196 3
a198 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-to"))
			{
			if (args[1])
				{
d201 3
a203 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-from"))
			{
			if (args[1])
				{
d206 3
a208 7
				}
			else badarg = 1;
			}
		else if (!strcmp (*args, "-subject"))
			{
			if (args[1])
				{
d211 3
a213 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-signer"))
			{
			if (args[1])
				{
d216 3
a218 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-recip"))
			{
			if (args[1])
				{
d221 3
a223 7
				}
			else badarg = 1;
			}
		else if (!strcmp (*args, "-inkey"))
			{
			if (args[1])
				{
d226 3
a228 8
				}
			else
				badarg = 1;
		}
		else if (!strcmp (*args, "-keyform"))
			{
			if (args[1])
				{
d231 3
a233 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-certfile"))
			{
			if (args[1])
				{
d236 3
a238 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-CAfile"))
			{
			if (args[1])
				{
d241 3
a243 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-CApath"))
			{
			if (args[1])
				{
d246 3
a248 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-in"))
			{
			if (args[1])
				{
d251 3
a253 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-inform"))
			{
			if (args[1])
				{
d256 3
a258 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-outform"))
			{
			if (args[1])
				{
d261 3
a263 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-out"))
			{
			if (args[1])
				{
d266 3
a268 8
				}
			else
				badarg = 1;
			}
		else if (!strcmp (*args, "-content"))
			{
			if (args[1])
				{
d271 2
a272 8
				}
			else
				badarg = 1;
			}
		else if (args_verify(&args, NULL, &badarg, bio_err, &vpm))
			continue;
		else
			badarg = 1;
d274 1
a274 2
		}

d276 2
a277 4
	if (operation == SMIME_SIGN)
		{
		if (!signerfile)
			{
d280 1
a280 1
			}
d282 3
a284 6
		}
	else if (operation == SMIME_DECRYPT)
		{
		if (!recipfile && !keyfile)
			{
			BIO_printf(bio_err, "No recipient certificate or key specified\n");
a285 1
			}
d287 2
a288 4
	else if (operation == SMIME_ENCRYPT)
		{
		if (!*args)
			{
d291 1
a291 1
			}
d293 1
a293 3
		}
	else if (!operation)
		badarg = 1;
d295 1
a295 2
	if (badarg)
		{
a306 3
#ifndef OPENSSL_NO_SEED
		BIO_printf (bio_err, "-seed          encrypt with SEED\n");
#endif
a315 4
#ifndef OPENSSL_NO_CAMELLIA
		BIO_printf (bio_err, "-camellia128, -camellia192, -camellia256\n");
		BIO_printf (bio_err, "               encrypt PEM output with cbc camellia\n");
#endif
d350 1
a350 1
		}
d356 1
a356 2
	if (!app_passwd(bio_err, passargin, NULL, &passin, NULL))
		{
d359 1
a359 1
		}
d361 1
a361 2
	if (need_rand)
		{
d366 1
a366 1
		}
d370 1
a370 2
	if (operation != SMIME_SIGN)
		flags &= ~PKCS7_DETACHED;
d372 7
a378 14
	if (operation & SMIME_OP)
		{
		if (flags & PKCS7_BINARY)
			inmode = "rb";
		if (outformat == FORMAT_ASN1)
			outmode = "wb";
		}
	else
		{
		if (flags & PKCS7_BINARY)
			outmode = "wb";
		if (informat == FORMAT_ASN1)
			inmode = "rb";
		}
d380 2
a381 4
	if (operation == SMIME_ENCRYPT)
		{
		if (!cipher)
			{
d388 1
a388 1
			}
d390 3
a392 5
		while (*args)
			{
			if (!(cert = load_cert(bio_err,*args,FORMAT_PEM,
				NULL, e, "recipient certificate file")))
				{
d397 1
a397 1
				}
a400 1
			}
d402 1
d404 3
a406 5
	if (signerfile && (operation == SMIME_SIGN))
		{
		if (!(signer = load_cert(bio_err,signerfile,FORMAT_PEM, NULL,
			e, "signer certificate")))
			{
a410 1
			}
d412 1
d414 3
a416 5
	if (certfile)
		{
		if (!(other = load_certs(bio_err,certfile,FORMAT_PEM, NULL,
			e, "certificate file")))
			{
a421 1
			}
d423 1
d425 3
a427 5
	if (recipfile && (operation == SMIME_DECRYPT))
		{
		if (!(recip = load_cert(bio_err,recipfile,FORMAT_PEM,NULL,
			e, "recipient certificate file")))
			{
a432 1
			}
d434 1
d436 5
a440 11
	if (operation == SMIME_DECRYPT)
		{
		if (!keyfile)
			keyfile = recipfile;
		}
	else if (operation == SMIME_SIGN)
		{
		if (!keyfile)
			keyfile = signerfile;
		}
	else keyfile = NULL;
d442 1
a442 2
	if (keyfile)
		{
d445 1
a445 1
		if (!key)
d447 2
a448 1
		}
d450 2
a451 4
	if (infile)
		{
		if (!(in = BIO_new_file(infile, inmode)))
			{
a454 1
			}
d456 1
a456 2
	else
		in = BIO_new_fp(stdin, BIO_NOCLOSE);
d458 2
a459 4
	if (outfile)
		{
		if (!(out = BIO_new_file(outfile, outmode)))
			{
a462 1
			}
d464 1
a464 2
	else
		{
d472 1
a472 1
		}
d474 4
a477 8
	if (operation == SMIME_VERIFY)
		{
		if (!(store = setup_verify(bio_err, CAfile, CApath)))
			goto end;
		X509_STORE_set_verify_cb_func(store, smime_cb);
		if (vpm)
			X509_STORE_set1_param(store, vpm);
		}
d482 1
a482 1
	if (operation == SMIME_ENCRYPT)
d484 1
a484 7
	else if (operation == SMIME_SIGN)
		{
		/* If detached data and SMIME output enable partial
		 * signing.
		 */
		if ((flags & PKCS7_DETACHED) && (outformat == FORMAT_SMIME))
			flags |= PKCS7_STREAM;
d486 3
d490 2
a491 3
	else
		{
		if (informat == FORMAT_SMIME) 
d493 1
a493 1
		else if (informat == FORMAT_PEM) 
d495 1
a495 1
		else if (informat == FORMAT_ASN1) 
d497 1
a497 2
		else
			{
d500 1
a500 1
			}
d502 1
a502 2
		if (!p7)
			{
d505 2
a506 3
			}
		if (contfile)
			{
d508 1
a508 2
			if (!(indata = BIO_new_file(contfile, "rb")))
				{
a510 1
				}
d513 1
d515 1
a515 2
	if (!p7)
		{
d518 1
a518 1
		}
d521 2
a522 4
	if (operation == SMIME_DECRYPT)
		{
		if (!PKCS7_decrypt(p7, key, recip, out, flags))
			{
a524 1
			}
d526 1
a526 2
	else if (operation == SMIME_VERIFY)
		{
d528 1
a528 1
		if (PKCS7_verify(p7, other, store, indata, out, flags))
d530 1
a530 2
		else
			{
d533 1
a533 1
			}
d535 1
a535 2
		if (!save_certs(signerfile, signers))
			{
d540 1
a540 1
			}
d542 1
a542 2
		}
	else if (operation == SMIME_PK7OUT)
d544 5
a548 9
	else
		{
		if (to)
			BIO_printf(out, "To: %s\n", to);
		if (from)
			BIO_printf(out, "From: %s\n", from);
		if (subject)
			BIO_printf(out, "Subject: %s\n", subject);
		if (outformat == FORMAT_SMIME) 
d550 1
a550 1
		else if (outformat == FORMAT_PEM) 
d552 1
a552 1
		else if (outformat == FORMAT_ASN1) 
d554 1
a554 2
		else
			{
a556 1
			}
d558 1
d563 1
a563 1
	if (ret) ERR_print_errors(bio_err);
a565 2
	if (vpm)
		X509_VERIFY_PARAM_free(vpm);
d575 1
a575 1
	if (passin) OPENSSL_free(passin);
d580 1
a580 1
	{
d583 1
a583 2
	if (!signerfile)
		return 1;
d585 1
a585 1
	if (!tmp) return 0;
d590 1
a590 1
	}
a591 18

/* Minimal callback just to output policy info (if any) */

static int smime_cb(int ok, X509_STORE_CTX *ctx)
	{
	int error;

	error = X509_STORE_CTX_get_error(ctx);

	if ((error != X509_V_ERR_NO_EXPLICIT_POLICY)
		&& ((error != X509_V_OK) || (ok != 2)))
		return ok;

	policies_print(NULL, ctx);

	return ok;

	}
@


1.1.1.6
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@a75 2
#define SMIME_IP	0x20
#define SMIME_SIGNERS	0x40
d77 4
a80 5
#define SMIME_DECRYPT	(2 | SMIME_IP)
#define SMIME_SIGN	(3 | SMIME_OP | SMIME_SIGNERS)
#define SMIME_VERIFY	(4 | SMIME_IP)
#define SMIME_PK7OUT	(5 | SMIME_IP | SMIME_OP)
#define SMIME_RESIGN	(6 | SMIME_IP | SMIME_OP | SMIME_SIGNERS)
a92 1
	STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;
a107 2
	int indef = 0;
	const EVP_MD *sign_md = NULL;
a137 2
		else if (!strcmp (*args, "-resign"))
			operation = SMIME_RESIGN;
a195 6
		else if (!strcmp (*args, "-stream"))
				indef = 1;
		else if (!strcmp (*args, "-indef"))
				indef = 1;
		else if (!strcmp (*args, "-noindef"))
				indef = 0;
d202 7
a208 4
			if (!args[1])
				goto argerr;
			args++;
			inrand = *args;
d214 6
a219 3
			if (!args[1])
				goto argerr;
			engine = *++args;
d224 7
a230 3
			if (!args[1])
				goto argerr;
			passargin = *++args;
d234 7
a240 3
			if (!args[1])
				goto argerr;
			to = *++args;
d244 6
a249 3
			if (!args[1])
				goto argerr;
			from = *++args;
d253 7
a259 3
			if (!args[1])
				goto argerr;
			subject = *++args;
d263 4
a266 15
			if (!args[1])
				goto argerr;
			/* If previous -signer argument add signer to list */

			if (signerfile)
				{
				if (!sksigners)
					sksigners = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(sksigners, signerfile);
				if (!keyfile)
					keyfile = signerfile;
				if (!skkeys)
					skkeys = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(skkeys, keyfile);
				keyfile = NULL;
d268 2
a269 1
			signerfile = *++args;
d273 4
a276 14
			if (!args[1])
				goto argerr;
			recipfile = *++args;
			}
		else if (!strcmp (*args, "-md"))
			{
			if (!args[1])
				goto argerr;
			sign_md = EVP_get_digestbyname(*++args);
			if (sign_md == NULL)
				{
				BIO_printf(bio_err, "Unknown digest %s\n",
							*args);
				goto argerr;
d278 1
d282 4
a285 17
			if (!args[1])	
				goto argerr;
			/* If previous -inkey arument add signer to list */
			if (keyfile)
				{
				if (!signerfile)
					{
					BIO_puts(bio_err, "Illegal -inkey without -signer\n");
					goto argerr;
					}
				if (!sksigners)
					sksigners = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(sksigners, signerfile);
				signerfile = NULL;
				if (!skkeys)
					skkeys = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(skkeys, keyfile);
d287 3
a289 2
			keyfile = *++args;
			}
d292 7
a298 3
			if (!args[1])
				goto argerr;
			keyform = str2fmt(*++args);
d302 7
a308 3
			if (!args[1])
				goto argerr;
			certfile = *++args;
d312 7
a318 3
			if (!args[1])
				goto argerr;
			CAfile = *++args;
d322 7
a328 3
			if (!args[1])
				goto argerr;
			CApath = *++args;
d332 7
a338 3
			if (!args[1])
				goto argerr;
			infile = *++args;
d342 7
a348 3
			if (!args[1])
				goto argerr;
			informat = str2fmt(*++args);
d352 7
a358 3
			if (!args[1])
				goto argerr;
			outformat = str2fmt(*++args);
d362 7
a368 3
			if (!args[1])
				goto argerr;
			outfile = *++args;
d372 7
a378 3
			if (!args[1])
				goto argerr;
			contfile = *++args;
d382 1
a382 1
		else if ((cipher = EVP_get_cipherbyname(*args + 1)) == NULL)
a386 5
	if (!(operation & SMIME_SIGNERS) && (skkeys || sksigners))
		{
		BIO_puts(bio_err, "Multiple signers or keys not allowed\n");
		goto argerr;
		}
d388 1
a388 1
	if (operation & SMIME_SIGNERS)
d390 1
a390 18
		/* Check to see if any final signer needs to be appended */
		if (keyfile && !signerfile)
			{
			BIO_puts(bio_err, "Illegal -inkey without -signer\n");
			goto argerr;
			}
		if (signerfile)
			{
			if (!sksigners)
				sksigners = sk_OPENSSL_STRING_new_null();
			sk_OPENSSL_STRING_push(sksigners, signerfile);
			if (!skkeys)
				skkeys = sk_OPENSSL_STRING_new_null();
			if (!keyfile)
				keyfile = signerfile;
			sk_OPENSSL_STRING_push(skkeys, keyfile);
			}
		if (!sksigners)
a394 2
		signerfile = NULL;
		keyfile = NULL;
a418 1
		argerr:
d502 1
a502 1
	if (!(operation & SMIME_SIGNERS))
d507 2
a515 4
		}

	if (operation & SMIME_IP)
		{
a518 5
	else
		{
		if (flags & PKCS7_BINARY)
			inmode = "rb";
		}
d548 12
d565 3
d578 3
a617 30
	if (operation & SMIME_IP)
		{
		if (informat == FORMAT_SMIME) 
			p7 = SMIME_read_PKCS7(in, &indata);
		else if (informat == FORMAT_PEM) 
			p7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);
		else if (informat == FORMAT_ASN1) 
			p7 = d2i_PKCS7_bio(in, NULL);
		else
			{
			BIO_printf(bio_err, "Bad input format for PKCS#7 file\n");
			goto end;
			}

		if (!p7)
			{
			BIO_printf(bio_err, "Error reading S/MIME message\n");
			goto end;
			}
		if (contfile)
			{
			BIO_free(indata);
			if (!(indata = BIO_new_file(contfile, "rb")))
				{
				BIO_printf(bio_err, "Can't read content file %s\n", contfile);
				goto end;
				}
			}
		}

d642 1
a642 1
		X509_STORE_set_verify_cb(store, smime_cb);
d651 2
d654 4
a657 1
		if (indef)
d659 1
a659 1
		p7 = PKCS7_encrypt(encerts, in, cipher, flags);
d661 1
a661 1
	else if (operation & SMIME_SIGNERS)
d663 7
a669 5
		int i;
		/* If detached data content we only enable streaming if
		 * S/MIME output format.
		 */
		if (operation == SMIME_SIGN)
d671 2
a672 11
			if (flags & PKCS7_DETACHED)
				{
				if (outformat == FORMAT_SMIME)
					flags |= PKCS7_STREAM;
				}
			else if (indef)
				flags |= PKCS7_STREAM;
			flags |= PKCS7_PARTIAL;
			p7 = PKCS7_sign(NULL, NULL, other, in, flags);
			if (!p7)
				goto end;
d674 2
a675 3
		else
			flags |= PKCS7_REUSE_DIGEST;
		for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++)
d677 2
a678 17
			signerfile = sk_OPENSSL_STRING_value(sksigners, i);
			keyfile = sk_OPENSSL_STRING_value(skkeys, i);
			signer = load_cert(bio_err, signerfile,FORMAT_PEM, NULL,
					e, "signer certificate");
			if (!signer)
				goto end;
			key = load_key(bio_err, keyfile, keyform, 0, passin, e,
			       "signing key file");
			if (!key)
				goto end;
			if (!PKCS7_sign_add_signer(p7, signer, key,
						sign_md, flags))
				goto end;
			X509_free(signer);
			signer = NULL;
			EVP_PKEY_free(key);
			key = NULL;
d680 1
a680 2
		/* If not streaming or resigning finalize structure */
		if ((operation == SMIME_SIGN) && !(flags & PKCS7_STREAM))
d682 4
a685 1
			if (!PKCS7_final(p7, in, flags))
d687 1
d737 1
a737 6
			{
			if (operation == SMIME_RESIGN)
				SMIME_write_PKCS7(out, p7, indata, flags);
			else
				SMIME_write_PKCS7(out, p7, in, flags);
			}
d739 1
a739 1
			PEM_write_bio_PKCS7_stream(out, p7, in, flags);
d741 1
a741 1
			i2d_PKCS7_bio_stream(out,p7, in, flags);
a756 4
	if (sksigners)
		sk_OPENSSL_STRING_free(sksigners);
	if (skkeys)
		sk_OPENSSL_STRING_free(skkeys);
@


