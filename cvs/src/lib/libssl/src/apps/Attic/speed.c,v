head	1.53;
access;
symbols
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	butholakala:1.22
	openssl_1_0_1_g:1.1.1.12
	OPENBSD_5_5:1.21.0.8
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.4
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	openssl_1_0_1_c:1.1.1.11
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	openssl_1_0_0_f:1.1.1.10
	openssl_1_0_0_e:1.1.1.10
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	openssh_1_0_0_a:1.1.1.9
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	openssl_0_9_8_k:1.1.1.8
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	openssl_0_9_8_j:1.1.1.8
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.52;
commitid	7A7DObXgY4Fni8xJ;

1.52
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	EB0l28piqIRSpBUh;

1.51
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.50;
commitid	0NuggCO2WJOZj8Kh;

1.50
date	2014.07.09.21.02.35;	author tedu;	state Exp;
branches;
next	1.49;
commitid	ivoCf1icUxmbGXSc;

1.49
date	2014.06.28.04.39.41;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	gGtvlhTlvaxlmOBo;

1.48
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	mJUVYpkFBZ0Zv2bG;

1.47
date	2014.06.11.01.53.02;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	4evB2EbwDYaBfe0g;

1.46
date	2014.06.07.14.41.56;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	2nvnQBrv22dLtvTt;

1.45
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.17.15.57.52;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.17.15.45.50;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.02.17.06.46;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2014.05.02.16.58.12;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.24.12.04.31;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.22.14.54.13;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.18.18.01.06;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.18.04.17.17;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.18.02.45.27;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.18.01.04.53;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.17.21.55.07;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.17.10.24.08;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.16.19.36.19;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.16.02.50.09;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2010.10.01.22.58.51;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.11.16.56.39;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.09.12.15.19;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.27.05.06.54;	author djm;	state Exp;
branches
	1.15.8.1
	1.15.10.1;
next	1.14;

1.14
date	2005.04.29.05.39.16;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.16.21.42.50;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.05.22.12.11;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.01.19.51.16;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.02.51;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.56.59;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.30;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.14;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.20;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.08;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.08;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.37;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.24;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.30;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.36.59;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.29;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.13.49;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2011.11.03.02.32.06;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;

1.15.8.1
date	2009.01.09.11.40.48;	author djm;	state Exp;
branches;
next	;

1.15.10.1
date	2009.01.09.11.40.32;	author djm;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: speed.c,v 1.52 2014/07/14 00:35:10 deraadt Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the OpenSSL open source
 * license provided above.
 *
 * The ECDH and ECDSA speed test software is originally written by
 * Sumit Gupta of Sun Microsystems Laboratories.
 *
 */

/* most of this code has been pilfered from my libdes speed.c program */

#ifndef OPENSSL_NO_SPEED

#define SECONDS		3
#define RSA_SECONDS	10
#define DSA_SECONDS	10
#define ECDSA_SECONDS   10
#define ECDH_SECONDS    10

/* 11-Sep-92 Andrew Daviel   Support for Silicon Graphics IRIX added */
/* 06-Apr-92 Luke Brennan    Support for VMS and add extra signal calls */

#include <math.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>

#include "apps.h"

#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/modes.h>
#include <openssl/objects.h>
#include <openssl/rand.h>
#include <openssl/x509.h>

#ifndef OPENSSL_NO_AES
#include <openssl/aes.h>
#endif
#ifndef OPENSSL_NO_BF
#include <openssl/blowfish.h>
#endif
#ifndef OPENSSL_NO_CAST
#include <openssl/cast.h>
#endif
#ifndef OPENSSL_NO_CAMELLIA
#include <openssl/camellia.h>
#endif
#ifndef OPENSSL_NO_DES
#include <openssl/des.h>
#endif
#include <openssl/dsa.h>
#include <openssl/ecdh.h>
#include <openssl/ecdsa.h>
#ifndef OPENSSL_NO_HMAC
#include <openssl/hmac.h>
#endif
#ifndef OPENSSL_NO_IDEA
#include <openssl/idea.h>
#endif
#ifndef OPENSSL_NO_MDC2
#include <openssl/mdc2.h>
#endif
#ifndef OPENSSL_NO_MD4
#include <openssl/md4.h>
#endif
#ifndef OPENSSL_NO_MD5
#include <openssl/md5.h>
#endif
#ifndef OPENSSL_NO_RC2
#include <openssl/rc2.h>
#endif
#ifndef OPENSSL_NO_RC4
#include <openssl/rc4.h>
#endif
#ifndef OPENSSL_NO_RC5
#include <openssl/rc5.h>
#endif
#include <openssl/rsa.h>
#ifndef OPENSSL_NO_RIPEMD
#include <openssl/ripemd.h>
#endif
#ifndef OPENSSL_NO_SHA
#include <openssl/sha.h>
#endif
#ifndef OPENSSL_NO_WHIRLPOOL
#include <openssl/whrlpool.h>
#endif

#include "./testdsa.h"
#include "./testrsa.h"

#define BUFSIZE	((long)1024*8+1)
int run = 0;

static int mr = 0;
static int usertime = 1;

static double Time_F(int s);
static void print_message(const char *s, long num, int length);
static void
pkey_print_message(const char *str, const char *str2,
    long num, int bits, int sec);
static void print_result(int alg, int run_no, int count, double time_used);
static int do_multi(int multi);

#define ALGOR_NUM	30
#define SIZE_NUM	5
#define RSA_NUM		4
#define DSA_NUM		3

#define EC_NUM       16
#define MAX_ECDH_SIZE 256

static const char *names[ALGOR_NUM] = {
	"md2", "mdc2", "md4", "md5", "hmac(md5)", "sha1", "rmd160", "rc4",
	"des cbc", "des ede3", "idea cbc", "seed cbc",
	"rc2 cbc", "rc5-32/12 cbc", "blowfish cbc", "cast cbc",
	"aes-128 cbc", "aes-192 cbc", "aes-256 cbc",
	"camellia-128 cbc", "camellia-192 cbc", "camellia-256 cbc",
	"evp", "sha256", "sha512", "whirlpool",
"aes-128 ige", "aes-192 ige", "aes-256 ige", "ghash"};
static double results[ALGOR_NUM][SIZE_NUM];
static int lengths[SIZE_NUM] = {16, 64, 256, 1024, 8 * 1024};
static double rsa_results[RSA_NUM][2];
static double dsa_results[DSA_NUM][2];
static double ecdsa_results[EC_NUM][2];
static double ecdh_results[EC_NUM][1];

static void sig_done(int sig);

static void
sig_done(int sig)
{
	signal(SIGALRM, sig_done);
	run = 0;
}

#define START	0
#define STOP	1


static double
Time_F(int s)
{
	return app_tminterval(s, usertime);
}


static const int KDF1_SHA1_len = 20;
static void *
KDF1_SHA1(const void *in, size_t inlen, void *out, size_t * outlen)
{
#ifndef OPENSSL_NO_SHA
	if (*outlen < SHA_DIGEST_LENGTH)
		return NULL;
	else
		*outlen = SHA_DIGEST_LENGTH;
	return SHA1(in, inlen, out);
#else
	return NULL;
#endif				/* OPENSSL_NO_SHA */
}


int speed_main(int, char **);

int
speed_main(int argc, char **argv)
{
	unsigned char *buf = NULL, *buf2 = NULL;
	int mret = 1;
	long count = 0, save_count = 0;
	int i, j, k;
	long rsa_count;
	unsigned rsa_num;
	unsigned char md[EVP_MAX_MD_SIZE];
#ifndef OPENSSL_NO_MDC2
	unsigned char mdc2[MDC2_DIGEST_LENGTH];
#endif
#ifndef OPENSSL_NO_MD4
	unsigned char md4[MD4_DIGEST_LENGTH];
#endif
#ifndef OPENSSL_NO_MD5
	unsigned char md5[MD5_DIGEST_LENGTH];
	unsigned char hmac[MD5_DIGEST_LENGTH];
#endif
#ifndef OPENSSL_NO_SHA
	unsigned char sha[SHA_DIGEST_LENGTH];
#ifndef OPENSSL_NO_SHA256
	unsigned char sha256[SHA256_DIGEST_LENGTH];
#endif
#ifndef OPENSSL_NO_SHA512
	unsigned char sha512[SHA512_DIGEST_LENGTH];
#endif
#endif
#ifndef OPENSSL_NO_WHIRLPOOL
	unsigned char whirlpool[WHIRLPOOL_DIGEST_LENGTH];
#endif
#ifndef OPENSSL_NO_RIPEMD
	unsigned char rmd160[RIPEMD160_DIGEST_LENGTH];
#endif
#ifndef OPENSSL_NO_RC4
	RC4_KEY rc4_ks;
#endif
#ifndef OPENSSL_NO_RC5
	RC5_32_KEY rc5_ks;
#endif
#ifndef OPENSSL_NO_RC2
	RC2_KEY rc2_ks;
#endif
#ifndef OPENSSL_NO_IDEA
	IDEA_KEY_SCHEDULE idea_ks;
#endif
#ifndef OPENSSL_NO_BF
	BF_KEY bf_ks;
#endif
#ifndef OPENSSL_NO_CAST
	CAST_KEY cast_ks;
#endif
	static const unsigned char key16[16] =
	{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
	0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12};
#ifndef OPENSSL_NO_AES
	static const unsigned char key24[24] =
	{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34};
	static const unsigned char key32[32] =
	{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
		0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56};
#endif
#ifndef OPENSSL_NO_CAMELLIA
	static const unsigned char ckey24[24] =
	{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
	0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34};
	static const unsigned char ckey32[32] =
	{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
		0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
	0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56};
#endif
#ifndef OPENSSL_NO_AES
#define MAX_BLOCK_SIZE 128
#else
#define MAX_BLOCK_SIZE 64
#endif
	unsigned char DES_iv[8];
	unsigned char iv[2 * MAX_BLOCK_SIZE / 8];
#ifndef OPENSSL_NO_DES
	static DES_cblock key = {0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0};
	static DES_cblock key2 = {0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12};
	static DES_cblock key3 = {0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34};
	DES_key_schedule sch;
	DES_key_schedule sch2;
	DES_key_schedule sch3;
#endif
#ifndef OPENSSL_NO_AES
	AES_KEY aes_ks1, aes_ks2, aes_ks3;
#endif
#ifndef OPENSSL_NO_CAMELLIA
	CAMELLIA_KEY camellia_ks1, camellia_ks2, camellia_ks3;
#endif
#define	D_MD2		0
#define	D_MDC2		1
#define	D_MD4		2
#define	D_MD5		3
#define	D_HMAC		4
#define	D_SHA1		5
#define D_RMD160	6
#define	D_RC4		7
#define	D_CBC_DES	8
#define	D_EDE3_DES	9
#define	D_CBC_IDEA	10
#define	D_CBC_SEED	11
#define	D_CBC_RC2	12
#define	D_CBC_RC5	13
#define	D_CBC_BF	14
#define	D_CBC_CAST	15
#define D_CBC_128_AES	16
#define D_CBC_192_AES	17
#define D_CBC_256_AES	18
#define D_CBC_128_CML   19
#define D_CBC_192_CML   20
#define D_CBC_256_CML   21
#define D_EVP		22
#define D_SHA256	23
#define D_SHA512	24
#define D_WHIRLPOOL	25
#define D_IGE_128_AES   26
#define D_IGE_192_AES   27
#define D_IGE_256_AES   28
#define D_GHASH		29
	double d = 0.0;
	long c[ALGOR_NUM][SIZE_NUM];
#define	R_DSA_512	0
#define	R_DSA_1024	1
#define	R_DSA_2048	2
#define	R_RSA_512	0
#define	R_RSA_1024	1
#define	R_RSA_2048	2
#define	R_RSA_4096	3

#define R_EC_P160    0
#define R_EC_P192    1
#define R_EC_P224    2
#define R_EC_P256    3
#define R_EC_P384    4
#define R_EC_P521    5
#define R_EC_K163    6
#define R_EC_K233    7
#define R_EC_K283    8
#define R_EC_K409    9
#define R_EC_K571    10
#define R_EC_B163    11
#define R_EC_B233    12
#define R_EC_B283    13
#define R_EC_B409    14
#define R_EC_B571    15

	RSA *rsa_key[RSA_NUM];
	long rsa_c[RSA_NUM][2];
	static unsigned int rsa_bits[RSA_NUM] = {512, 1024, 2048, 4096};
	static unsigned char *rsa_data[RSA_NUM] =
	{test512, test1024, test2048, test4096};
	static int rsa_data_length[RSA_NUM] = {
		sizeof(test512), sizeof(test1024),
	sizeof(test2048), sizeof(test4096)};
	DSA *dsa_key[DSA_NUM];
	long dsa_c[DSA_NUM][2];
	static unsigned int dsa_bits[DSA_NUM] = {512, 1024, 2048};
#ifndef OPENSSL_NO_EC
	/*
	 * We only test over the following curves as they are representative,
	 * To add tests over more curves, simply add the curve NID and curve
	 * name to the following arrays and increase the EC_NUM value
	 * accordingly.
	 */
	static unsigned int test_curves[EC_NUM] =
	{
		/* Prime Curves */
		NID_secp160r1,
		NID_X9_62_prime192v1,
		NID_secp224r1,
		NID_X9_62_prime256v1,
		NID_secp384r1,
		NID_secp521r1,
		/* Binary Curves */
		NID_sect163k1,
		NID_sect233k1,
		NID_sect283k1,
		NID_sect409k1,
		NID_sect571k1,
		NID_sect163r2,
		NID_sect233r1,
		NID_sect283r1,
		NID_sect409r1,
		NID_sect571r1
	};
	static const char *test_curves_names[EC_NUM] =
	{
		/* Prime Curves */
		"secp160r1",
		"nistp192",
		"nistp224",
		"nistp256",
		"nistp384",
		"nistp521",
		/* Binary Curves */
		"nistk163",
		"nistk233",
		"nistk283",
		"nistk409",
		"nistk571",
		"nistb163",
		"nistb233",
		"nistb283",
		"nistb409",
		"nistb571"
	};
	static int test_curves_bits[EC_NUM] =
	{
		160, 192, 224, 256, 384, 521,
		163, 233, 283, 409, 571,
		163, 233, 283, 409, 571
	};

#endif

	unsigned char ecdsasig[256];
	unsigned int ecdsasiglen;
	EC_KEY *ecdsa[EC_NUM];
	long ecdsa_c[EC_NUM][2];

	EC_KEY *ecdh_a[EC_NUM], *ecdh_b[EC_NUM];
	unsigned char secret_a[MAX_ECDH_SIZE], secret_b[MAX_ECDH_SIZE];
	int secret_size_a, secret_size_b;
	int ecdh_checks = 0;
	int secret_idx = 0;
	long ecdh_c[EC_NUM][2];

	int rsa_doit[RSA_NUM];
	int dsa_doit[DSA_NUM];
	int ecdsa_doit[EC_NUM];
	int ecdh_doit[EC_NUM];
	int doit[ALGOR_NUM];
	int pr_header = 0;
	const EVP_CIPHER *evp_cipher = NULL;
	const EVP_MD *evp_md = NULL;
	int decrypt = 0;
	int multi = 0;
	const char *errstr = NULL;

#ifndef TIMES
	usertime = -1;
#endif

	memset(results, 0, sizeof(results));
	memset(dsa_key, 0, sizeof(dsa_key));
	for (i = 0; i < EC_NUM; i++)
		ecdsa[i] = NULL;
	for (i = 0; i < EC_NUM; i++) {
		ecdh_a[i] = NULL;
		ecdh_b[i] = NULL;
	}

	memset(rsa_key, 0, sizeof(rsa_key));
	for (i = 0; i < RSA_NUM; i++)
		rsa_key[i] = NULL;

	if ((buf = malloc((int) BUFSIZE)) == NULL) {
		BIO_printf(bio_err, "out of memory\n");
		goto end;
	}
	if ((buf2 = malloc((int) BUFSIZE)) == NULL) {
		BIO_printf(bio_err, "out of memory\n");
		goto end;
	}
	memset(c, 0, sizeof(c));
	memset(DES_iv, 0, sizeof(DES_iv));
	memset(iv, 0, sizeof(iv));

	for (i = 0; i < ALGOR_NUM; i++)
		doit[i] = 0;
	for (i = 0; i < RSA_NUM; i++)
		rsa_doit[i] = 0;
	for (i = 0; i < DSA_NUM; i++)
		dsa_doit[i] = 0;
	for (i = 0; i < EC_NUM; i++)
		ecdsa_doit[i] = 0;
	for (i = 0; i < EC_NUM; i++)
		ecdh_doit[i] = 0;


	j = 0;
	argc--;
	argv++;
	while (argc) {
		if ((argc > 0) && (strcmp(*argv, "-elapsed") == 0)) {
			usertime = 0;
			j--;	/* Otherwise, -elapsed gets confused with an
				 * algorithm. */
		} else if ((argc > 0) && (strcmp(*argv, "-evp") == 0)) {
			argc--;
			argv++;
			if (argc == 0) {
				BIO_printf(bio_err, "no EVP given\n");
				goto end;
			}
			evp_cipher = EVP_get_cipherbyname(*argv);
			if (!evp_cipher) {
				evp_md = EVP_get_digestbyname(*argv);
			}
			if (!evp_cipher && !evp_md) {
				BIO_printf(bio_err, "%s is an unknown cipher or digest\n", *argv);
				goto end;
			}
			doit[D_EVP] = 1;
		} else if (argc > 0 && !strcmp(*argv, "-decrypt")) {
			decrypt = 1;
			j--;	/* Otherwise, -elapsed gets confused with an
				 * algorithm. */
		}
#ifndef OPENSSL_NO_ENGINE
		else if ((argc > 0) && (strcmp(*argv, "-engine") == 0)) {
			argc--;
			argv++;
			if (argc == 0) {
				BIO_printf(bio_err, "no engine given\n");
				goto end;
			}
			setup_engine(bio_err, *argv, 0);
			/*
			 * j will be increased again further down.  We just
			 * don't want speed to confuse an engine with an
			 * algorithm, especially when none is given (which
			 * means all of them should be run)
			 */
			j--;
		}
#endif
		else if ((argc > 0) && (strcmp(*argv, "-multi") == 0)) {
			argc--;
			argv++;
			if (argc == 0) {
				BIO_printf(bio_err, "no multi count given\n");
				goto end;
			}
			multi = strtonum(argv[0], 1, INT_MAX, &errstr);
			if (errstr) {
				BIO_printf(bio_err, "bad multi count: %s", errstr);
				goto end;
			}
			j--;	/* Otherwise, -mr gets confused with an
				 * algorithm. */
		}
		else if (argc > 0 && !strcmp(*argv, "-mr")) {
			mr = 1;
			j--;	/* Otherwise, -mr gets confused with an
				 * algorithm. */
		} else
#ifndef OPENSSL_NO_MDC2
		if (strcmp(*argv, "mdc2") == 0)
			doit[D_MDC2] = 1;
		else
#endif
#ifndef OPENSSL_NO_MD4
		if (strcmp(*argv, "md4") == 0)
			doit[D_MD4] = 1;
		else
#endif
#ifndef OPENSSL_NO_MD5
		if (strcmp(*argv, "md5") == 0)
			doit[D_MD5] = 1;
		else
#endif
#ifndef OPENSSL_NO_MD5
		if (strcmp(*argv, "hmac") == 0)
			doit[D_HMAC] = 1;
		else
#endif
#ifndef OPENSSL_NO_SHA
		if (strcmp(*argv, "sha1") == 0)
			doit[D_SHA1] = 1;
		else if (strcmp(*argv, "sha") == 0)
			doit[D_SHA1] = 1,
			    doit[D_SHA256] = 1,
			    doit[D_SHA512] = 1;
		else
#ifndef OPENSSL_NO_SHA256
		if (strcmp(*argv, "sha256") == 0)
			doit[D_SHA256] = 1;
		else
#endif
#ifndef OPENSSL_NO_SHA512
		if (strcmp(*argv, "sha512") == 0)
			doit[D_SHA512] = 1;
		else
#endif
#endif
#ifndef OPENSSL_NO_WHIRLPOOL
		if (strcmp(*argv, "whirlpool") == 0)
			doit[D_WHIRLPOOL] = 1;
		else
#endif
#ifndef OPENSSL_NO_RIPEMD
		if (strcmp(*argv, "ripemd") == 0)
			doit[D_RMD160] = 1;
		else if (strcmp(*argv, "rmd160") == 0)
			doit[D_RMD160] = 1;
		else if (strcmp(*argv, "ripemd160") == 0)
			doit[D_RMD160] = 1;
		else
#endif
#ifndef OPENSSL_NO_RC4
		if (strcmp(*argv, "rc4") == 0)
			doit[D_RC4] = 1;
		else
#endif
#ifndef OPENSSL_NO_DES
		if (strcmp(*argv, "des-cbc") == 0)
			doit[D_CBC_DES] = 1;
		else if (strcmp(*argv, "des-ede3") == 0)
			doit[D_EDE3_DES] = 1;
		else
#endif
#ifndef OPENSSL_NO_AES
		if (strcmp(*argv, "aes-128-cbc") == 0)
			doit[D_CBC_128_AES] = 1;
		else if (strcmp(*argv, "aes-192-cbc") == 0)
			doit[D_CBC_192_AES] = 1;
		else if (strcmp(*argv, "aes-256-cbc") == 0)
			doit[D_CBC_256_AES] = 1;
		else if (strcmp(*argv, "aes-128-ige") == 0)
			doit[D_IGE_128_AES] = 1;
		else if (strcmp(*argv, "aes-192-ige") == 0)
			doit[D_IGE_192_AES] = 1;
		else if (strcmp(*argv, "aes-256-ige") == 0)
			doit[D_IGE_256_AES] = 1;
		else
#endif
#ifndef OPENSSL_NO_CAMELLIA
		if (strcmp(*argv, "camellia-128-cbc") == 0)
			doit[D_CBC_128_CML] = 1;
		else if (strcmp(*argv, "camellia-192-cbc") == 0)
			doit[D_CBC_192_CML] = 1;
		else if (strcmp(*argv, "camellia-256-cbc") == 0)
			doit[D_CBC_256_CML] = 1;
		else
#endif
#if 0				/* was: #ifdef RSAref */
		if (strcmp(*argv, "rsaref") == 0) {
			RSA_set_default_openssl_method(RSA_PKCS1_RSAref());
			j--;
		} else
#endif
#ifndef RSA_NULL
		if (strcmp(*argv, "openssl") == 0) {
			RSA_set_default_method(RSA_PKCS1_SSLeay());
			j--;
		} else
#endif
		if (strcmp(*argv, "dsa512") == 0)
			dsa_doit[R_DSA_512] = 2;
		else if (strcmp(*argv, "dsa1024") == 0)
			dsa_doit[R_DSA_1024] = 2;
		else if (strcmp(*argv, "dsa2048") == 0)
			dsa_doit[R_DSA_2048] = 2;
		else if (strcmp(*argv, "rsa512") == 0)
			rsa_doit[R_RSA_512] = 2;
		else if (strcmp(*argv, "rsa1024") == 0)
			rsa_doit[R_RSA_1024] = 2;
		else if (strcmp(*argv, "rsa2048") == 0)
			rsa_doit[R_RSA_2048] = 2;
		else if (strcmp(*argv, "rsa4096") == 0)
			rsa_doit[R_RSA_4096] = 2;
		else
#ifndef OPENSSL_NO_RC2
		if (strcmp(*argv, "rc2-cbc") == 0)
			doit[D_CBC_RC2] = 1;
		else if (strcmp(*argv, "rc2") == 0)
			doit[D_CBC_RC2] = 1;
		else
#endif
#ifndef OPENSSL_NO_RC5
		if (strcmp(*argv, "rc5-cbc") == 0)
			doit[D_CBC_RC5] = 1;
		else if (strcmp(*argv, "rc5") == 0)
			doit[D_CBC_RC5] = 1;
		else
#endif
#ifndef OPENSSL_NO_IDEA
		if (strcmp(*argv, "idea-cbc") == 0)
			doit[D_CBC_IDEA] = 1;
		else if (strcmp(*argv, "idea") == 0)
			doit[D_CBC_IDEA] = 1;
		else
#endif
#ifndef OPENSSL_NO_BF
		if (strcmp(*argv, "bf-cbc") == 0)
			doit[D_CBC_BF] = 1;
		else if (strcmp(*argv, "blowfish") == 0)
			doit[D_CBC_BF] = 1;
		else if (strcmp(*argv, "bf") == 0)
			doit[D_CBC_BF] = 1;
		else
#endif
#ifndef OPENSSL_NO_CAST
		if (strcmp(*argv, "cast-cbc") == 0)
			doit[D_CBC_CAST] = 1;
		else if (strcmp(*argv, "cast") == 0)
			doit[D_CBC_CAST] = 1;
		else if (strcmp(*argv, "cast5") == 0)
			doit[D_CBC_CAST] = 1;
		else
#endif
#ifndef OPENSSL_NO_DES
		if (strcmp(*argv, "des") == 0) {
			doit[D_CBC_DES] = 1;
			doit[D_EDE3_DES] = 1;
		} else
#endif
#ifndef OPENSSL_NO_AES
		if (strcmp(*argv, "aes") == 0) {
			doit[D_CBC_128_AES] = 1;
			doit[D_CBC_192_AES] = 1;
			doit[D_CBC_256_AES] = 1;
		} else if (strcmp(*argv, "ghash") == 0) {
			doit[D_GHASH] = 1;
		} else
#endif
#ifndef OPENSSL_NO_CAMELLIA
		if (strcmp(*argv, "camellia") == 0) {
			doit[D_CBC_128_CML] = 1;
			doit[D_CBC_192_CML] = 1;
			doit[D_CBC_256_CML] = 1;
		} else
#endif
		if (strcmp(*argv, "rsa") == 0) {
			rsa_doit[R_RSA_512] = 1;
			rsa_doit[R_RSA_1024] = 1;
			rsa_doit[R_RSA_2048] = 1;
			rsa_doit[R_RSA_4096] = 1;
		} else
		if (strcmp(*argv, "dsa") == 0) {
			dsa_doit[R_DSA_512] = 1;
			dsa_doit[R_DSA_1024] = 1;
			dsa_doit[R_DSA_2048] = 1;
		} else
		if (strcmp(*argv, "ecdsap160") == 0)
			ecdsa_doit[R_EC_P160] = 2;
		else if (strcmp(*argv, "ecdsap192") == 0)
			ecdsa_doit[R_EC_P192] = 2;
		else if (strcmp(*argv, "ecdsap224") == 0)
			ecdsa_doit[R_EC_P224] = 2;
		else if (strcmp(*argv, "ecdsap256") == 0)
			ecdsa_doit[R_EC_P256] = 2;
		else if (strcmp(*argv, "ecdsap384") == 0)
			ecdsa_doit[R_EC_P384] = 2;
		else if (strcmp(*argv, "ecdsap521") == 0)
			ecdsa_doit[R_EC_P521] = 2;
		else if (strcmp(*argv, "ecdsak163") == 0)
			ecdsa_doit[R_EC_K163] = 2;
		else if (strcmp(*argv, "ecdsak233") == 0)
			ecdsa_doit[R_EC_K233] = 2;
		else if (strcmp(*argv, "ecdsak283") == 0)
			ecdsa_doit[R_EC_K283] = 2;
		else if (strcmp(*argv, "ecdsak409") == 0)
			ecdsa_doit[R_EC_K409] = 2;
		else if (strcmp(*argv, "ecdsak571") == 0)
			ecdsa_doit[R_EC_K571] = 2;
		else if (strcmp(*argv, "ecdsab163") == 0)
			ecdsa_doit[R_EC_B163] = 2;
		else if (strcmp(*argv, "ecdsab233") == 0)
			ecdsa_doit[R_EC_B233] = 2;
		else if (strcmp(*argv, "ecdsab283") == 0)
			ecdsa_doit[R_EC_B283] = 2;
		else if (strcmp(*argv, "ecdsab409") == 0)
			ecdsa_doit[R_EC_B409] = 2;
		else if (strcmp(*argv, "ecdsab571") == 0)
			ecdsa_doit[R_EC_B571] = 2;
		else if (strcmp(*argv, "ecdsa") == 0) {
			for (i = 0; i < EC_NUM; i++)
				ecdsa_doit[i] = 1;
		} else
		if (strcmp(*argv, "ecdhp160") == 0)
			ecdh_doit[R_EC_P160] = 2;
		else if (strcmp(*argv, "ecdhp192") == 0)
			ecdh_doit[R_EC_P192] = 2;
		else if (strcmp(*argv, "ecdhp224") == 0)
			ecdh_doit[R_EC_P224] = 2;
		else if (strcmp(*argv, "ecdhp256") == 0)
			ecdh_doit[R_EC_P256] = 2;
		else if (strcmp(*argv, "ecdhp384") == 0)
			ecdh_doit[R_EC_P384] = 2;
		else if (strcmp(*argv, "ecdhp521") == 0)
			ecdh_doit[R_EC_P521] = 2;
		else if (strcmp(*argv, "ecdhk163") == 0)
			ecdh_doit[R_EC_K163] = 2;
		else if (strcmp(*argv, "ecdhk233") == 0)
			ecdh_doit[R_EC_K233] = 2;
		else if (strcmp(*argv, "ecdhk283") == 0)
			ecdh_doit[R_EC_K283] = 2;
		else if (strcmp(*argv, "ecdhk409") == 0)
			ecdh_doit[R_EC_K409] = 2;
		else if (strcmp(*argv, "ecdhk571") == 0)
			ecdh_doit[R_EC_K571] = 2;
		else if (strcmp(*argv, "ecdhb163") == 0)
			ecdh_doit[R_EC_B163] = 2;
		else if (strcmp(*argv, "ecdhb233") == 0)
			ecdh_doit[R_EC_B233] = 2;
		else if (strcmp(*argv, "ecdhb283") == 0)
			ecdh_doit[R_EC_B283] = 2;
		else if (strcmp(*argv, "ecdhb409") == 0)
			ecdh_doit[R_EC_B409] = 2;
		else if (strcmp(*argv, "ecdhb571") == 0)
			ecdh_doit[R_EC_B571] = 2;
		else if (strcmp(*argv, "ecdh") == 0) {
			for (i = 0; i < EC_NUM; i++)
				ecdh_doit[i] = 1;
		} else
		{
			BIO_printf(bio_err, "Error: bad option or value\n");
			BIO_printf(bio_err, "\n");
			BIO_printf(bio_err, "Available values:\n");
#ifndef OPENSSL_NO_MDC2
			BIO_printf(bio_err, "mdc2     ");
#endif
#ifndef OPENSSL_NO_MD4
			BIO_printf(bio_err, "md4      ");
#endif
#ifndef OPENSSL_NO_MD5
			BIO_printf(bio_err, "md5      ");
#ifndef OPENSSL_NO_HMAC
			BIO_printf(bio_err, "hmac     ");
#endif
#endif
#ifndef OPENSSL_NO_SHA1
			BIO_printf(bio_err, "sha1     ");
#endif
#ifndef OPENSSL_NO_SHA256
			BIO_printf(bio_err, "sha256   ");
#endif
#ifndef OPENSSL_NO_SHA512
			BIO_printf(bio_err, "sha512   ");
#endif
#ifndef OPENSSL_NO_WHIRLPOOL
			BIO_printf(bio_err, "whirlpool");
#endif
#ifndef OPENSSL_NO_RIPEMD160
			BIO_printf(bio_err, "rmd160");
#endif
#if !defined(OPENSSL_NO_MD2) || !defined(OPENSSL_NO_MDC2) || \
    !defined(OPENSSL_NO_MD4) || !defined(OPENSSL_NO_MD5) || \
    !defined(OPENSSL_NO_SHA1) || !defined(OPENSSL_NO_RIPEMD160) || \
    !defined(OPENSSL_NO_WHIRLPOOL)
			BIO_printf(bio_err, "\n");
#endif

#ifndef OPENSSL_NO_IDEA
			BIO_printf(bio_err, "idea-cbc ");
#endif
#ifndef OPENSSL_NO_RC2
			BIO_printf(bio_err, "rc2-cbc  ");
#endif
#ifndef OPENSSL_NO_RC5
			BIO_printf(bio_err, "rc5-cbc  ");
#endif
#ifndef OPENSSL_NO_BF
			BIO_printf(bio_err, "bf-cbc");
#endif
#if !defined(OPENSSL_NO_IDEA) || !defined(OPENSSL_NO_SEED) || !defined(OPENSSL_NO_RC2) || \
    !defined(OPENSSL_NO_BF) || !defined(OPENSSL_NO_RC5)
			BIO_printf(bio_err, "\n");
#endif
#ifndef OPENSSL_NO_DES
			BIO_printf(bio_err, "des-cbc  des-ede3 ");
#endif
#ifndef OPENSSL_NO_AES
			BIO_printf(bio_err, "aes-128-cbc aes-192-cbc aes-256-cbc ");
			BIO_printf(bio_err, "aes-128-ige aes-192-ige aes-256-ige ");
#endif
#ifndef OPENSSL_NO_CAMELLIA
			BIO_printf(bio_err, "\n");
			BIO_printf(bio_err, "camellia-128-cbc camellia-192-cbc camellia-256-cbc ");
#endif
#ifndef OPENSSL_NO_RC4
			BIO_printf(bio_err, "rc4");
#endif
			BIO_printf(bio_err, "\n");

			BIO_printf(bio_err, "rsa512   rsa1024  rsa2048  rsa4096\n");

			BIO_printf(bio_err, "dsa512   dsa1024  dsa2048\n");
			BIO_printf(bio_err, "ecdsap160 ecdsap192 ecdsap224 ecdsap256 ecdsap384 ecdsap521\n");
			BIO_printf(bio_err, "ecdsak163 ecdsak233 ecdsak283 ecdsak409 ecdsak571\n");
			BIO_printf(bio_err, "ecdsab163 ecdsab233 ecdsab283 ecdsab409 ecdsab571\n");
			BIO_printf(bio_err, "ecdsa\n");
			BIO_printf(bio_err, "ecdhp160  ecdhp192  ecdhp224  ecdhp256  ecdhp384  ecdhp521\n");
			BIO_printf(bio_err, "ecdhk163  ecdhk233  ecdhk283  ecdhk409  ecdhk571\n");
			BIO_printf(bio_err, "ecdhb163  ecdhb233  ecdhb283  ecdhb409  ecdhb571\n");
			BIO_printf(bio_err, "ecdh\n");

#ifndef OPENSSL_NO_IDEA
			BIO_printf(bio_err, "idea     ");
#endif
#ifndef OPENSSL_NO_RC2
			BIO_printf(bio_err, "rc2      ");
#endif
#ifndef OPENSSL_NO_DES
			BIO_printf(bio_err, "des      ");
#endif
#ifndef OPENSSL_NO_AES
			BIO_printf(bio_err, "aes      ");
#endif
#ifndef OPENSSL_NO_CAMELLIA
			BIO_printf(bio_err, "camellia ");
#endif
			BIO_printf(bio_err, "rsa      ");
#ifndef OPENSSL_NO_BF
			BIO_printf(bio_err, "blowfish");
#endif
#if !defined(OPENSSL_NO_IDEA) || !defined(OPENSSL_NO_SEED) || \
    !defined(OPENSSL_NO_RC2) || !defined(OPENSSL_NO_DES) || \
    !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_BF) || \
    !defined(OPENSSL_NO_AES) || !defined(OPENSSL_NO_CAMELLIA)
			BIO_printf(bio_err, "\n");
#endif

			BIO_printf(bio_err, "\n");
			BIO_printf(bio_err, "Available options:\n");
#if defined(TIMES) || defined(USE_TOD)
			BIO_printf(bio_err, "-elapsed        measure time in real time instead of CPU user time.\n");
#endif
#ifndef OPENSSL_NO_ENGINE
			BIO_printf(bio_err, "-engine e       use engine e, possibly a hardware device.\n");
#endif
			BIO_printf(bio_err, "-evp e          use EVP e.\n");
			BIO_printf(bio_err, "-decrypt        time decryption instead of encryption (only EVP).\n");
			BIO_printf(bio_err, "-mr             produce machine readable output.\n");
			BIO_printf(bio_err, "-multi n        run n benchmarks in parallel.\n");
			goto end;
		}
		argc--;
		argv++;
		j++;
	}

	if (multi && do_multi(multi))
		goto show_res;

	if (j == 0) {
		for (i = 0; i < ALGOR_NUM; i++) {
			if (i != D_EVP)
				doit[i] = 1;
		}
		for (i = 0; i < RSA_NUM; i++)
			rsa_doit[i] = 1;
		for (i = 0; i < DSA_NUM; i++)
			dsa_doit[i] = 1;
		for (i = 0; i < EC_NUM; i++)
			ecdsa_doit[i] = 1;
		for (i = 0; i < EC_NUM; i++)
			ecdh_doit[i] = 1;
	}
	for (i = 0; i < ALGOR_NUM; i++)
		if (doit[i])
			pr_header++;

	if (usertime == 0 && !mr)
		BIO_printf(bio_err, "You have chosen to measure elapsed time instead of user CPU time.\n");

	for (i = 0; i < RSA_NUM; i++) {
		const unsigned char *p;

		p = rsa_data[i];
		rsa_key[i] = d2i_RSAPrivateKey(NULL, &p, rsa_data_length[i]);
		if (rsa_key[i] == NULL) {
			BIO_printf(bio_err, "internal error loading RSA key number %d\n", i);
			goto end;
		}
#if 0
		else {
			BIO_printf(bio_err, mr ? "+RK:%d:"
			    : "Loaded RSA key, %d bit modulus and e= 0x",
			    BN_num_bits(rsa_key[i]->n));
			BN_print(bio_err, rsa_key[i]->e);
			BIO_printf(bio_err, "\n");
		}
#endif
	}

	dsa_key[0] = get_dsa512();
	dsa_key[1] = get_dsa1024();
	dsa_key[2] = get_dsa2048();

#ifndef OPENSSL_NO_DES
	DES_set_key_unchecked(&key, &sch);
	DES_set_key_unchecked(&key2, &sch2);
	DES_set_key_unchecked(&key3, &sch3);
#endif
#ifndef OPENSSL_NO_AES
	AES_set_encrypt_key(key16, 128, &aes_ks1);
	AES_set_encrypt_key(key24, 192, &aes_ks2);
	AES_set_encrypt_key(key32, 256, &aes_ks3);
#endif
#ifndef OPENSSL_NO_CAMELLIA
	Camellia_set_key(key16, 128, &camellia_ks1);
	Camellia_set_key(ckey24, 192, &camellia_ks2);
	Camellia_set_key(ckey32, 256, &camellia_ks3);
#endif
#ifndef OPENSSL_NO_IDEA
	idea_set_encrypt_key(key16, &idea_ks);
#endif
#ifndef OPENSSL_NO_RC4
	RC4_set_key(&rc4_ks, 16, key16);
#endif
#ifndef OPENSSL_NO_RC2
	RC2_set_key(&rc2_ks, 16, key16, 128);
#endif
#ifndef OPENSSL_NO_RC5
	RC5_32_set_key(&rc5_ks, 16, key16, 12);
#endif
#ifndef OPENSSL_NO_BF
	BF_set_key(&bf_ks, 16, key16);
#endif
#ifndef OPENSSL_NO_CAST
	CAST_set_key(&cast_ks, 16, key16);
#endif
	memset(rsa_c, 0, sizeof(rsa_c));
#define COND(c)	(run && count<0x7fffffff)
#define COUNT(d) (count)
	signal(SIGALRM, sig_done);

#ifndef OPENSSL_NO_MDC2
	if (doit[D_MDC2]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_MDC2], c[D_MDC2][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_MDC2][j]); count++)
				EVP_Digest(buf, (unsigned long) lengths[j], &(mdc2[0]), NULL, EVP_mdc2(), NULL);
			d = Time_F(STOP);
			print_result(D_MDC2, j, count, d);
		}
	}
#endif

#ifndef OPENSSL_NO_MD4
	if (doit[D_MD4]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_MD4], c[D_MD4][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_MD4][j]); count++)
				EVP_Digest(&(buf[0]), (unsigned long) lengths[j], &(md4[0]), NULL, EVP_md4(), NULL);
			d = Time_F(STOP);
			print_result(D_MD4, j, count, d);
		}
	}
#endif

#ifndef OPENSSL_NO_MD5
	if (doit[D_MD5]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_MD5], c[D_MD5][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_MD5][j]); count++)
				EVP_Digest(&(buf[0]), (unsigned long) lengths[j], &(md5[0]), NULL, EVP_get_digestbyname("md5"), NULL);
			d = Time_F(STOP);
			print_result(D_MD5, j, count, d);
		}
	}
#endif

#if !defined(OPENSSL_NO_MD5) && !defined(OPENSSL_NO_HMAC)
	if (doit[D_HMAC]) {
		HMAC_CTX hctx;

		HMAC_CTX_init(&hctx);
		HMAC_Init_ex(&hctx, (unsigned char *) "This is a key...",
		    16, EVP_md5(), NULL);

		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_HMAC], c[D_HMAC][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_HMAC][j]); count++) {
				HMAC_Init_ex(&hctx, NULL, 0, NULL, NULL);
				HMAC_Update(&hctx, buf, lengths[j]);
				HMAC_Final(&hctx, &(hmac[0]), NULL);
			}
			d = Time_F(STOP);
			print_result(D_HMAC, j, count, d);
		}
		HMAC_CTX_cleanup(&hctx);
	}
#endif
#ifndef OPENSSL_NO_SHA
	if (doit[D_SHA1]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_SHA1], c[D_SHA1][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_SHA1][j]); count++)
				EVP_Digest(buf, (unsigned long) lengths[j], &(sha[0]), NULL, EVP_sha1(), NULL);
			d = Time_F(STOP);
			print_result(D_SHA1, j, count, d);
		}
	}
#ifndef OPENSSL_NO_SHA256
	if (doit[D_SHA256]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_SHA256], c[D_SHA256][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_SHA256][j]); count++)
				SHA256(buf, lengths[j], sha256);
			d = Time_F(STOP);
			print_result(D_SHA256, j, count, d);
		}
	}
#endif

#ifndef OPENSSL_NO_SHA512
	if (doit[D_SHA512]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_SHA512], c[D_SHA512][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_SHA512][j]); count++)
				SHA512(buf, lengths[j], sha512);
			d = Time_F(STOP);
			print_result(D_SHA512, j, count, d);
		}
	}
#endif
#endif

#ifndef OPENSSL_NO_WHIRLPOOL
	if (doit[D_WHIRLPOOL]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_WHIRLPOOL], c[D_WHIRLPOOL][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_WHIRLPOOL][j]); count++)
				WHIRLPOOL(buf, lengths[j], whirlpool);
			d = Time_F(STOP);
			print_result(D_WHIRLPOOL, j, count, d);
		}
	}
#endif

#ifndef OPENSSL_NO_RIPEMD
	if (doit[D_RMD160]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_RMD160], c[D_RMD160][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_RMD160][j]); count++)
				EVP_Digest(buf, (unsigned long) lengths[j], &(rmd160[0]), NULL, EVP_ripemd160(), NULL);
			d = Time_F(STOP);
			print_result(D_RMD160, j, count, d);
		}
	}
#endif
#ifndef OPENSSL_NO_RC4
	if (doit[D_RC4]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_RC4], c[D_RC4][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_RC4][j]); count++)
				RC4(&rc4_ks, (unsigned int) lengths[j],
				    buf, buf);
			d = Time_F(STOP);
			print_result(D_RC4, j, count, d);
		}
	}
#endif
#ifndef OPENSSL_NO_DES
	if (doit[D_CBC_DES]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_DES], c[D_CBC_DES][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_DES][j]); count++)
				DES_ncbc_encrypt(buf, buf, lengths[j], &sch,
				    &DES_iv, DES_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_DES, j, count, d);
		}
	}
	if (doit[D_EDE3_DES]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_EDE3_DES], c[D_EDE3_DES][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_EDE3_DES][j]); count++)
				DES_ede3_cbc_encrypt(buf, buf, lengths[j],
				    &sch, &sch2, &sch3,
				    &DES_iv, DES_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_EDE3_DES, j, count, d);
		}
	}
#endif
#ifndef OPENSSL_NO_AES
	if (doit[D_CBC_128_AES]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_128_AES], c[D_CBC_128_AES][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_128_AES][j]); count++)
				AES_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &aes_ks1,
				    iv, AES_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_128_AES, j, count, d);
		}
	}
	if (doit[D_CBC_192_AES]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_192_AES], c[D_CBC_192_AES][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_192_AES][j]); count++)
				AES_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &aes_ks2,
				    iv, AES_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_192_AES, j, count, d);
		}
	}
	if (doit[D_CBC_256_AES]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_256_AES], c[D_CBC_256_AES][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_256_AES][j]); count++)
				AES_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &aes_ks3,
				    iv, AES_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_256_AES, j, count, d);
		}
	}
	if (doit[D_IGE_128_AES]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_IGE_128_AES], c[D_IGE_128_AES][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_IGE_128_AES][j]); count++)
				AES_ige_encrypt(buf, buf2,
				    (unsigned long) lengths[j], &aes_ks1,
				    iv, AES_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_IGE_128_AES, j, count, d);
		}
	}
	if (doit[D_IGE_192_AES]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_IGE_192_AES], c[D_IGE_192_AES][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_IGE_192_AES][j]); count++)
				AES_ige_encrypt(buf, buf2,
				    (unsigned long) lengths[j], &aes_ks2,
				    iv, AES_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_IGE_192_AES, j, count, d);
		}
	}
	if (doit[D_IGE_256_AES]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_IGE_256_AES], c[D_IGE_256_AES][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_IGE_256_AES][j]); count++)
				AES_ige_encrypt(buf, buf2,
				    (unsigned long) lengths[j], &aes_ks3,
				    iv, AES_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_IGE_256_AES, j, count, d);
		}
	}
	if (doit[D_GHASH]) {
		GCM128_CONTEXT *ctx = CRYPTO_gcm128_new(&aes_ks1, (block128_f) AES_encrypt);
		CRYPTO_gcm128_setiv(ctx, (unsigned char *) "0123456789ab", 12);

		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_GHASH], c[D_GHASH][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_GHASH][j]); count++)
				CRYPTO_gcm128_aad(ctx, buf, lengths[j]);
			d = Time_F(STOP);
			print_result(D_GHASH, j, count, d);
		}
		CRYPTO_gcm128_release(ctx);
	}
#endif
#ifndef OPENSSL_NO_CAMELLIA
	if (doit[D_CBC_128_CML]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_128_CML], c[D_CBC_128_CML][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_128_CML][j]); count++)
				Camellia_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &camellia_ks1,
				    iv, CAMELLIA_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_128_CML, j, count, d);
		}
	}
	if (doit[D_CBC_192_CML]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_192_CML], c[D_CBC_192_CML][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_192_CML][j]); count++)
				Camellia_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &camellia_ks2,
				    iv, CAMELLIA_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_192_CML, j, count, d);
		}
	}
	if (doit[D_CBC_256_CML]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_256_CML], c[D_CBC_256_CML][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_256_CML][j]); count++)
				Camellia_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &camellia_ks3,
				    iv, CAMELLIA_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_256_CML, j, count, d);
		}
	}
#endif
#ifndef OPENSSL_NO_IDEA
	if (doit[D_CBC_IDEA]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_IDEA], c[D_CBC_IDEA][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_IDEA][j]); count++)
				idea_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &idea_ks,
				    iv, IDEA_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_IDEA, j, count, d);
		}
	}
#endif
#ifndef OPENSSL_NO_RC2
	if (doit[D_CBC_RC2]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_RC2], c[D_CBC_RC2][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_RC2][j]); count++)
				RC2_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &rc2_ks,
				    iv, RC2_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_RC2, j, count, d);
		}
	}
#endif
#ifndef OPENSSL_NO_RC5
	if (doit[D_CBC_RC5]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_RC5], c[D_CBC_RC5][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_RC5][j]); count++)
				RC5_32_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &rc5_ks,
				    iv, RC5_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_RC5, j, count, d);
		}
	}
#endif
#ifndef OPENSSL_NO_BF
	if (doit[D_CBC_BF]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_BF], c[D_CBC_BF][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_BF][j]); count++)
				BF_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &bf_ks,
				    iv, BF_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_BF, j, count, d);
		}
	}
#endif
#ifndef OPENSSL_NO_CAST
	if (doit[D_CBC_CAST]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_CAST], c[D_CBC_CAST][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_CAST][j]); count++)
				CAST_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &cast_ks,
				    iv, CAST_ENCRYPT);
			d = Time_F(STOP);
			print_result(D_CBC_CAST, j, count, d);
		}
	}
#endif

	if (doit[D_EVP]) {
		for (j = 0; j < SIZE_NUM; j++) {
			if (evp_cipher) {
				EVP_CIPHER_CTX ctx;
				int outl;

				names[D_EVP] = OBJ_nid2ln(evp_cipher->nid);
				/*
				 * -O3 -fschedule-insns messes up an
				 * optimization here!  names[D_EVP] somehow
				 * becomes NULL
				 */
				print_message(names[D_EVP], save_count,
				    lengths[j]);

				EVP_CIPHER_CTX_init(&ctx);
				if (decrypt)
					EVP_DecryptInit_ex(&ctx, evp_cipher, NULL, key16, iv);
				else
					EVP_EncryptInit_ex(&ctx, evp_cipher, NULL, key16, iv);
				EVP_CIPHER_CTX_set_padding(&ctx, 0);

				Time_F(START);
				if (decrypt)
					for (count = 0, run = 1; COND(save_count * 4 * lengths[0] / lengths[j]); count++)
						EVP_DecryptUpdate(&ctx, buf, &outl, buf, lengths[j]);
				else
					for (count = 0, run = 1; COND(save_count * 4 * lengths[0] / lengths[j]); count++)
						EVP_EncryptUpdate(&ctx, buf, &outl, buf, lengths[j]);
				if (decrypt)
					EVP_DecryptFinal_ex(&ctx, buf, &outl);
				else
					EVP_EncryptFinal_ex(&ctx, buf, &outl);
				d = Time_F(STOP);
				EVP_CIPHER_CTX_cleanup(&ctx);
			}
			if (evp_md) {
				names[D_EVP] = OBJ_nid2ln(evp_md->type);
				print_message(names[D_EVP], save_count,
				    lengths[j]);

				Time_F(START);
				for (count = 0, run = 1; COND(save_count * 4 * lengths[0] / lengths[j]); count++)
					EVP_Digest(buf, lengths[j], &(md[0]), NULL, evp_md, NULL);

				d = Time_F(STOP);
			}
			print_result(D_EVP, j, count, d);
		}
	}
	RAND_pseudo_bytes(buf, 36);
	for (j = 0; j < RSA_NUM; j++) {
		int ret;
		if (!rsa_doit[j])
			continue;
		ret = RSA_sign(NID_md5_sha1, buf, 36, buf2, &rsa_num, rsa_key[j]);
		if (ret == 0) {
			BIO_printf(bio_err, "RSA sign failure.  No RSA sign will be done.\n");
			ERR_print_errors(bio_err);
			rsa_count = 1;
		} else {
			pkey_print_message("private", "rsa",
			    rsa_c[j][0], rsa_bits[j],
			    RSA_SECONDS);
/*			RSA_blinding_on(rsa_key[j],NULL); */
			Time_F(START);
			for (count = 0, run = 1; COND(rsa_c[j][0]); count++) {
				ret = RSA_sign(NID_md5_sha1, buf, 36, buf2,
				    &rsa_num, rsa_key[j]);
				if (ret == 0) {
					BIO_printf(bio_err,
					    "RSA sign failure\n");
					ERR_print_errors(bio_err);
					count = 1;
					break;
				}
			}
			d = Time_F(STOP);
			BIO_printf(bio_err, mr ? "+R1:%ld:%d:%.2f\n"
			    : "%ld %d bit private RSA's in %.2fs\n",
			    count, rsa_bits[j], d);
			rsa_results[j][0] = d / (double) count;
			rsa_count = count;
		}

#if 1
		ret = RSA_verify(NID_md5_sha1, buf, 36, buf2, rsa_num, rsa_key[j]);
		if (ret <= 0) {
			BIO_printf(bio_err, "RSA verify failure.  No RSA verify will be done.\n");
			ERR_print_errors(bio_err);
			rsa_doit[j] = 0;
		} else {
			pkey_print_message("public", "rsa",
			    rsa_c[j][1], rsa_bits[j],
			    RSA_SECONDS);
			Time_F(START);
			for (count = 0, run = 1; COND(rsa_c[j][1]); count++) {
				ret = RSA_verify(NID_md5_sha1, buf, 36, buf2,
				    rsa_num, rsa_key[j]);
				if (ret <= 0) {
					BIO_printf(bio_err,
					    "RSA verify failure\n");
					ERR_print_errors(bio_err);
					count = 1;
					break;
				}
			}
			d = Time_F(STOP);
			BIO_printf(bio_err, mr ? "+R2:%ld:%d:%.2f\n"
			    : "%ld %d bit public RSA's in %.2fs\n",
			    count, rsa_bits[j], d);
			rsa_results[j][1] = d / (double) count;
		}
#endif

		if (rsa_count <= 1) {
			/* if longer than 10s, don't do any more */
			for (j++; j < RSA_NUM; j++)
				rsa_doit[j] = 0;
		}
	}

	RAND_pseudo_bytes(buf, 20);
	for (j = 0; j < DSA_NUM; j++) {
		unsigned int kk;
		int ret;

		if (!dsa_doit[j])
			continue;
/*		DSA_generate_key(dsa_key[j]); */
/*		DSA_sign_setup(dsa_key[j],NULL); */
		ret = DSA_sign(EVP_PKEY_DSA, buf, 20, buf2,
		    &kk, dsa_key[j]);
		if (ret == 0) {
			BIO_printf(bio_err, "DSA sign failure.  No DSA sign will be done.\n");
			ERR_print_errors(bio_err);
			rsa_count = 1;
		} else {
			pkey_print_message("sign", "dsa",
			    dsa_c[j][0], dsa_bits[j],
			    DSA_SECONDS);
			Time_F(START);
			for (count = 0, run = 1; COND(dsa_c[j][0]); count++) {
				ret = DSA_sign(EVP_PKEY_DSA, buf, 20, buf2,
				    &kk, dsa_key[j]);
				if (ret == 0) {
					BIO_printf(bio_err,
					    "DSA sign failure\n");
					ERR_print_errors(bio_err);
					count = 1;
					break;
				}
			}
			d = Time_F(STOP);
			BIO_printf(bio_err, mr ? "+R3:%ld:%d:%.2f\n"
			    : "%ld %d bit DSA signs in %.2fs\n",
			    count, dsa_bits[j], d);
			dsa_results[j][0] = d / (double) count;
			rsa_count = count;
		}

		ret = DSA_verify(EVP_PKEY_DSA, buf, 20, buf2,
		    kk, dsa_key[j]);
		if (ret <= 0) {
			BIO_printf(bio_err, "DSA verify failure.  No DSA verify will be done.\n");
			ERR_print_errors(bio_err);
			dsa_doit[j] = 0;
		} else {
			pkey_print_message("verify", "dsa",
			    dsa_c[j][1], dsa_bits[j],
			    DSA_SECONDS);
			Time_F(START);
			for (count = 0, run = 1; COND(dsa_c[j][1]); count++) {
				ret = DSA_verify(EVP_PKEY_DSA, buf, 20, buf2,
				    kk, dsa_key[j]);
				if (ret <= 0) {
					BIO_printf(bio_err,
					    "DSA verify failure\n");
					ERR_print_errors(bio_err);
					count = 1;
					break;
				}
			}
			d = Time_F(STOP);
			BIO_printf(bio_err, mr ? "+R4:%ld:%d:%.2f\n"
			    : "%ld %d bit DSA verify in %.2fs\n",
			    count, dsa_bits[j], d);
			dsa_results[j][1] = d / (double) count;
		}

		if (rsa_count <= 1) {
			/* if longer than 10s, don't do any more */
			for (j++; j < DSA_NUM; j++)
				dsa_doit[j] = 0;
		}
	}

	for (j = 0; j < EC_NUM; j++) {
		int ret;

		if (!ecdsa_doit[j])
			continue;	/* Ignore Curve */
		ecdsa[j] = EC_KEY_new_by_curve_name(test_curves[j]);
		if (ecdsa[j] == NULL) {
			BIO_printf(bio_err, "ECDSA failure.\n");
			ERR_print_errors(bio_err);
			rsa_count = 1;
		} else {
#if 1
			EC_KEY_precompute_mult(ecdsa[j], NULL);
#endif
			/* Perform ECDSA signature test */
			EC_KEY_generate_key(ecdsa[j]);
			ret = ECDSA_sign(0, buf, 20, ecdsasig,
			    &ecdsasiglen, ecdsa[j]);
			if (ret == 0) {
				BIO_printf(bio_err, "ECDSA sign failure.  No ECDSA sign will be done.\n");
				ERR_print_errors(bio_err);
				rsa_count = 1;
			} else {
				pkey_print_message("sign", "ecdsa",
				    ecdsa_c[j][0],
				    test_curves_bits[j],
				    ECDSA_SECONDS);

				Time_F(START);
				for (count = 0, run = 1; COND(ecdsa_c[j][0]);
				    count++) {
					ret = ECDSA_sign(0, buf, 20,
					    ecdsasig, &ecdsasiglen,
					    ecdsa[j]);
					if (ret == 0) {
						BIO_printf(bio_err, "ECDSA sign failure\n");
						ERR_print_errors(bio_err);
						count = 1;
						break;
					}
				}
				d = Time_F(STOP);

				BIO_printf(bio_err, mr ? "+R5:%ld:%d:%.2f\n" :
				    "%ld %d bit ECDSA signs in %.2fs \n",
				    count, test_curves_bits[j], d);
				ecdsa_results[j][0] = d / (double) count;
				rsa_count = count;
			}

			/* Perform ECDSA verification test */
			ret = ECDSA_verify(0, buf, 20, ecdsasig,
			    ecdsasiglen, ecdsa[j]);
			if (ret != 1) {
				BIO_printf(bio_err, "ECDSA verify failure.  No ECDSA verify will be done.\n");
				ERR_print_errors(bio_err);
				ecdsa_doit[j] = 0;
			} else {
				pkey_print_message("verify", "ecdsa",
				    ecdsa_c[j][1],
				    test_curves_bits[j],
				    ECDSA_SECONDS);
				Time_F(START);
				for (count = 0, run = 1; COND(ecdsa_c[j][1]); count++) {
					ret = ECDSA_verify(0, buf, 20, ecdsasig, ecdsasiglen, ecdsa[j]);
					if (ret != 1) {
						BIO_printf(bio_err, "ECDSA verify failure\n");
						ERR_print_errors(bio_err);
						count = 1;
						break;
					}
				}
				d = Time_F(STOP);
				BIO_printf(bio_err, mr ? "+R6:%ld:%d:%.2f\n"
				    : "%ld %d bit ECDSA verify in %.2fs\n",
				    count, test_curves_bits[j], d);
				ecdsa_results[j][1] = d / (double) count;
			}

			if (rsa_count <= 1) {
				/* if longer than 10s, don't do any more */
				for (j++; j < EC_NUM; j++)
					ecdsa_doit[j] = 0;
			}
		}
	}

	for (j = 0; j < EC_NUM; j++) {
		if (!ecdh_doit[j])
			continue;
		ecdh_a[j] = EC_KEY_new_by_curve_name(test_curves[j]);
		ecdh_b[j] = EC_KEY_new_by_curve_name(test_curves[j]);
		if ((ecdh_a[j] == NULL) || (ecdh_b[j] == NULL)) {
			BIO_printf(bio_err, "ECDH failure.\n");
			ERR_print_errors(bio_err);
			rsa_count = 1;
		} else {
			/* generate two ECDH key pairs */
			if (!EC_KEY_generate_key(ecdh_a[j]) ||
			    !EC_KEY_generate_key(ecdh_b[j])) {
				BIO_printf(bio_err, "ECDH key generation failure.\n");
				ERR_print_errors(bio_err);
				rsa_count = 1;
			} else {
				/*
				 * If field size is not more than 24 octets,
				 * then use SHA-1 hash of result; otherwise,
				 * use result (see section 4.8 of
				 * draft-ietf-tls-ecc-03.txt).
				 */
				int field_size, outlen;
				void *(*kdf) (const void *in, size_t inlen, void *out, size_t * xoutlen);
				field_size = EC_GROUP_get_degree(EC_KEY_get0_group(ecdh_a[j]));
				if (field_size <= 24 * 8) {
					outlen = KDF1_SHA1_len;
					kdf = KDF1_SHA1;
				} else {
					outlen = (field_size + 7) / 8;
					kdf = NULL;
				}
				secret_size_a = ECDH_compute_key(secret_a, outlen,
				    EC_KEY_get0_public_key(ecdh_b[j]),
				    ecdh_a[j], kdf);
				secret_size_b = ECDH_compute_key(secret_b, outlen,
				    EC_KEY_get0_public_key(ecdh_a[j]),
				    ecdh_b[j], kdf);
				if (secret_size_a != secret_size_b)
					ecdh_checks = 0;
				else
					ecdh_checks = 1;

				for (secret_idx = 0;
				    (secret_idx < secret_size_a)
				    && (ecdh_checks == 1);
				    secret_idx++) {
					if (secret_a[secret_idx] != secret_b[secret_idx])
						ecdh_checks = 0;
				}

				if (ecdh_checks == 0) {
					BIO_printf(bio_err, "ECDH computations don't match.\n");
					ERR_print_errors(bio_err);
					rsa_count = 1;
				}
				pkey_print_message("", "ecdh",
				    ecdh_c[j][0],
				    test_curves_bits[j],
				    ECDH_SECONDS);
				Time_F(START);
				for (count = 0, run = 1; COND(ecdh_c[j][0]); count++) {
					ECDH_compute_key(secret_a, outlen,
					    EC_KEY_get0_public_key(ecdh_b[j]),
					    ecdh_a[j], kdf);
				}
				d = Time_F(STOP);
				BIO_printf(bio_err, mr ? "+R7:%ld:%d:%.2f\n" : "%ld %d-bit ECDH ops in %.2fs\n",
				    count, test_curves_bits[j], d);
				ecdh_results[j][0] = d / (double) count;
				rsa_count = count;
			}
		}


		if (rsa_count <= 1) {
			/* if longer than 10s, don't do any more */
			for (j++; j < EC_NUM; j++)
				ecdh_doit[j] = 0;
		}
	}
show_res:
	if (!mr) {
		fprintf(stdout, "%s\n", SSLeay_version(SSLEAY_VERSION));
		fprintf(stdout, "%s\n", SSLeay_version(SSLEAY_BUILT_ON));
		printf("options:");
		printf("%s ", BN_options());
#ifndef OPENSSL_NO_RC4
		printf("%s ", RC4_options());
#endif
#ifndef OPENSSL_NO_DES
		printf("%s ", DES_options());
#endif
#ifndef OPENSSL_NO_AES
		printf("%s ", AES_options());
#endif
#ifndef OPENSSL_NO_IDEA
		printf("%s ", idea_options());
#endif
#ifndef OPENSSL_NO_BF
		printf("%s ", BF_options());
#endif
		fprintf(stdout, "\n%s\n", SSLeay_version(SSLEAY_CFLAGS));
	}
	if (pr_header) {
		if (mr)
			fprintf(stdout, "+H");
		else {
			fprintf(stdout, "The 'numbers' are in 1000s of bytes per second processed.\n");
			fprintf(stdout, "type        ");
		}
		for (j = 0; j < SIZE_NUM; j++)
			fprintf(stdout, mr ? ":%d" : "%7d bytes", lengths[j]);
		fprintf(stdout, "\n");
	}
	for (k = 0; k < ALGOR_NUM; k++) {
		if (!doit[k])
			continue;
		if (mr)
			fprintf(stdout, "+F:%d:%s", k, names[k]);
		else
			fprintf(stdout, "%-13s", names[k]);
		for (j = 0; j < SIZE_NUM; j++) {
			if (results[k][j] > 10000 && !mr)
				fprintf(stdout, " %11.2fk", results[k][j] / 1e3);
			else
				fprintf(stdout, mr ? ":%.2f" : " %11.2f ", results[k][j]);
		}
		fprintf(stdout, "\n");
	}
	j = 1;
	for (k = 0; k < RSA_NUM; k++) {
		if (!rsa_doit[k])
			continue;
		if (j && !mr) {
			printf("%18ssign    verify    sign/s verify/s\n", " ");
			j = 0;
		}
		if (mr)
			fprintf(stdout, "+F2:%u:%u:%f:%f\n",
			    k, rsa_bits[k], rsa_results[k][0],
			    rsa_results[k][1]);
		else
			fprintf(stdout, "rsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\n",
			    rsa_bits[k], rsa_results[k][0], rsa_results[k][1],
			    1.0 / rsa_results[k][0], 1.0 / rsa_results[k][1]);
	}
	j = 1;
	for (k = 0; k < DSA_NUM; k++) {
		if (!dsa_doit[k])
			continue;
		if (j && !mr) {
			printf("%18ssign    verify    sign/s verify/s\n", " ");
			j = 0;
		}
		if (mr)
			fprintf(stdout, "+F3:%u:%u:%f:%f\n",
			    k, dsa_bits[k], dsa_results[k][0], dsa_results[k][1]);
		else
			fprintf(stdout, "dsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\n",
			    dsa_bits[k], dsa_results[k][0], dsa_results[k][1],
			    1.0 / dsa_results[k][0], 1.0 / dsa_results[k][1]);
	}
	j = 1;
	for (k = 0; k < EC_NUM; k++) {
		if (!ecdsa_doit[k])
			continue;
		if (j && !mr) {
			printf("%30ssign    verify    sign/s verify/s\n", " ");
			j = 0;
		}
		if (mr)
			fprintf(stdout, "+F4:%u:%u:%f:%f\n",
			    k, test_curves_bits[k],
			    ecdsa_results[k][0], ecdsa_results[k][1]);
		else
			fprintf(stdout,
			    "%4u bit ecdsa (%s) %8.4fs %8.4fs %8.1f %8.1f\n",
			    test_curves_bits[k],
			    test_curves_names[k],
			    ecdsa_results[k][0], ecdsa_results[k][1],
			    1.0 / ecdsa_results[k][0], 1.0 / ecdsa_results[k][1]);
	}


	j = 1;
	for (k = 0; k < EC_NUM; k++) {
		if (!ecdh_doit[k])
			continue;
		if (j && !mr) {
			printf("%30sop      op/s\n", " ");
			j = 0;
		}
		if (mr)
			fprintf(stdout, "+F5:%u:%u:%f:%f\n",
			    k, test_curves_bits[k],
			    ecdh_results[k][0], 1.0 / ecdh_results[k][0]);

		else
			fprintf(stdout, "%4u bit ecdh (%s) %8.4fs %8.1f\n",
			    test_curves_bits[k],
			    test_curves_names[k],
			    ecdh_results[k][0], 1.0 / ecdh_results[k][0]);
	}

	mret = 0;

end:
	ERR_print_errors(bio_err);
	free(buf);
	free(buf2);
	for (i = 0; i < RSA_NUM; i++)
		if (rsa_key[i] != NULL)
			RSA_free(rsa_key[i]);
	for (i = 0; i < DSA_NUM; i++)
		if (dsa_key[i] != NULL)
			DSA_free(dsa_key[i]);

	for (i = 0; i < EC_NUM; i++)
		if (ecdsa[i] != NULL)
			EC_KEY_free(ecdsa[i]);
	for (i = 0; i < EC_NUM; i++) {
		if (ecdh_a[i] != NULL)
			EC_KEY_free(ecdh_a[i]);
		if (ecdh_b[i] != NULL)
			EC_KEY_free(ecdh_b[i]);
	}


	return (mret);
}

static void
print_message(const char *s, long num, int length)
{
	BIO_printf(bio_err, mr ? "+DT:%s:%d:%d\n"
	    : "Doing %s for %ds on %d size blocks: ", s, SECONDS, length);
	(void) BIO_flush(bio_err);
	alarm(SECONDS);
}

static void
pkey_print_message(const char *str, const char *str2, long num,
    int bits, int tm)
{
	BIO_printf(bio_err, mr ? "+DTP:%d:%s:%s:%d\n"
	    : "Doing %d bit %s %s's for %ds: ", bits, str, str2, tm);
	(void) BIO_flush(bio_err);
	alarm(tm);
}

static void
print_result(int alg, int run_no, int count, double time_used)
{
	BIO_printf(bio_err, mr ? "+R:%d:%s:%f\n"
	    : "%d %s's in %.2fs\n", count, names[alg], time_used);
	results[alg][run_no] = ((double) count) / time_used * lengths[run_no];
}

static char *
sstrsep(char **string, const char *delim)
{
	char isdelim[256];
	char *token = *string;

	if (**string == 0)
		return NULL;

	memset(isdelim, 0, sizeof isdelim);
	isdelim[0] = 1;

	while (*delim) {
		isdelim[(unsigned char) (*delim)] = 1;
		delim++;
	}

	while (!isdelim[(unsigned char) (**string)]) {
		(*string)++;
	}

	if (**string) {
		**string = 0;
		(*string)++;
	}
	return token;
}

static int
do_multi(int multi)
{
	int n;
	int fd[2];
	int *fds;
	static char sep[] = ":";
	const char *errstr = NULL;

	fds = reallocarray(NULL, multi, sizeof *fds);
	for (n = 0; n < multi; ++n) {
		if (pipe(fd) == -1) {
			fprintf(stderr, "pipe failure\n");
			exit(1);
		}
		fflush(stdout);
		fflush(stderr);
		if (fork()) {
			close(fd[1]);
			fds[n] = fd[0];
		} else {
			close(fd[0]);
			close(1);
			if (dup(fd[1]) == -1) {
				fprintf(stderr, "dup failed\n");
				exit(1);
			}
			close(fd[1]);
			mr = 1;
			usertime = 0;
			free(fds);
			return 0;
		}
		printf("Forked child %d\n", n);
	}

	/* for now, assume the pipe is long enough to take all the output */
	for (n = 0; n < multi; ++n) {
		FILE *f;
		char buf[1024];
		char *p;

		f = fdopen(fds[n], "r");
		while (fgets(buf, sizeof buf, f)) {
			p = strchr(buf, '\n');
			if (p)
				*p = '\0';
			if (buf[0] != '+') {
				fprintf(stderr, "Don't understand line '%s' from child %d\n",
				    buf, n);
				continue;
			}
			printf("Got: %s from %d\n", buf, n);
			if (!strncmp(buf, "+F:", 3)) {
				int alg;
				int j;

				p = buf + 3;
				alg = strtonum(sstrsep(&p, sep),
				    0, ALGOR_NUM - 1, &errstr);
				sstrsep(&p, sep);
				for (j = 0; j < SIZE_NUM; ++j)
					results[alg][j] += atof(sstrsep(&p, sep));
			} else if (!strncmp(buf, "+F2:", 4)) {
				int k;
				double d;

				p = buf + 4;
				k = strtonum(sstrsep(&p, sep),
				    0, ALGOR_NUM - 1, &errstr);
				sstrsep(&p, sep);

				d = atof(sstrsep(&p, sep));
				if (n)
					rsa_results[k][0] = 1 / (1 / rsa_results[k][0] + 1 / d);
				else
					rsa_results[k][0] = d;

				d = atof(sstrsep(&p, sep));
				if (n)
					rsa_results[k][1] = 1 / (1 / rsa_results[k][1] + 1 / d);
				else
					rsa_results[k][1] = d;
			} else if (!strncmp(buf, "+F2:", 4)) {
				int k;
				double d;

				p = buf + 4;
				k = strtonum(sstrsep(&p, sep),
				    0, ALGOR_NUM - 1, &errstr);
				sstrsep(&p, sep);

				d = atof(sstrsep(&p, sep));
				if (n)
					rsa_results[k][0] = 1 / (1 / rsa_results[k][0] + 1 / d);
				else
					rsa_results[k][0] = d;

				d = atof(sstrsep(&p, sep));
				if (n)
					rsa_results[k][1] = 1 / (1 / rsa_results[k][1] + 1 / d);
				else
					rsa_results[k][1] = d;
			}
			else if (!strncmp(buf, "+F3:", 4)) {
				int k;
				double d;

				p = buf + 4;
				k = strtonum(sstrsep(&p, sep),
				    0, ALGOR_NUM - 1, &errstr);
				sstrsep(&p, sep);

				d = atof(sstrsep(&p, sep));
				if (n)
					dsa_results[k][0] = 1 / (1 / dsa_results[k][0] + 1 / d);
				else
					dsa_results[k][0] = d;

				d = atof(sstrsep(&p, sep));
				if (n)
					dsa_results[k][1] = 1 / (1 / dsa_results[k][1] + 1 / d);
				else
					dsa_results[k][1] = d;
			}
			else if (!strncmp(buf, "+F4:", 4)) {
				int k;
				double d;

				p = buf + 4;
				k = strtonum(sstrsep(&p, sep),
				    0, ALGOR_NUM - 1, &errstr);
				sstrsep(&p, sep);

				d = atof(sstrsep(&p, sep));
				if (n)
					ecdsa_results[k][0] = 1 / (1 / ecdsa_results[k][0] + 1 / d);
				else
					ecdsa_results[k][0] = d;

				d = atof(sstrsep(&p, sep));
				if (n)
					ecdsa_results[k][1] = 1 / (1 / ecdsa_results[k][1] + 1 / d);
				else
					ecdsa_results[k][1] = d;
			}

			else if (!strncmp(buf, "+F5:", 4)) {
				int k;
				double d;

				p = buf + 4;
				k = strtonum(sstrsep(&p, sep),
				    0, ALGOR_NUM - 1, &errstr);
				sstrsep(&p, sep);

				d = atof(sstrsep(&p, sep));
				if (n)
					ecdh_results[k][0] = 1 / (1 / ecdh_results[k][0] + 1 / d);
				else
					ecdh_results[k][0] = d;

			}

			else if (!strncmp(buf, "+H:", 3)) {
			} else
				fprintf(stderr, "Unknown type '%s' from child %d\n", buf, n);
		}

		fclose(f);
	}
	free(fds);
	return 1;
}
#endif
@


1.52
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: speed.c,v 1.51 2014/07/12 17:54:31 jsing Exp $ */
@


1.51
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: speed.c,v 1.50 2014/07/09 21:02:35 tedu Exp $ */
d168 1
a168 1
static void 
d210 1
a210 1
static double 
d235 1
a235 1
int 
d1937 1
a1937 1
	
d1941 1
a1941 1
static void 
d1950 1
a1950 1
static void 
d1960 1
a1960 1
static void 
d1996 1
a1996 1
static int 
@


1.50
log
@unifdef a whole bunch of NO RSA/DSA/ECDH defines i deleted from libssl
@
text
@d1 1
a1 1
/* $OpenBSD: speed.c,v 1.49 2014/06/28 04:39:41 deraadt Exp $ */
a495 3

	if (!load_config(bio_err, NULL))
		goto end;
@


1.49
log
@Use strtonum() instead of atoi(), and then impose what are we think
are the current range checks.  Help from millert and lteo.  Please test
now that it is deployed and let us know if any numbers are off..
ok lteo
@
text
@d1 1
a1 1
/* $OpenBSD: speed.c,v 1.48 2014/06/12 15:49:27 deraadt Exp $ */
a118 1
#ifndef OPENSSL_NO_DSA
a119 2
#endif
#ifndef OPENSSL_NO_ECDH
a120 2
#endif
#ifndef OPENSSL_NO_ECDSA
a121 1
#endif
a145 1
#ifndef OPENSSL_NO_RSA
a146 1
#endif
a156 1
#ifndef OPENSSL_NO_DSA
a157 2
#endif
#ifndef OPENSSL_NO_RSA
a158 1
#endif
a191 1
#ifndef OPENSSL_NO_RSA
a192 2
#endif
#ifndef OPENSSL_NO_DSA
a193 2
#endif
#ifndef OPENSSL_NO_ECDSA
a194 2
#endif
#ifndef OPENSSL_NO_ECDH
a195 1
#endif
a216 1
#ifndef OPENSSL_NO_ECDH
a230 1
#endif				/* OPENSSL_NO_ECDH */
a241 1
#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA)
a242 2
#endif
#ifndef OPENSSL_NO_RSA
a243 1
#endif
a390 1
#ifndef OPENSSL_NO_RSA
a398 2
#endif
#ifndef OPENSSL_NO_DSA
a401 1
#endif
a459 1
#ifndef OPENSSL_NO_ECDSA
a463 1
#endif
a464 1
#ifndef OPENSSL_NO_ECDH
a470 1
#endif
a473 1
#ifndef OPENSSL_NO_ECDSA
a474 2
#endif
#ifndef OPENSSL_NO_ECDH
a475 1
#endif
a488 1
#ifndef OPENSSL_NO_DSA
a489 2
#endif
#ifndef OPENSSL_NO_ECDSA
a491 2
#endif
#ifndef OPENSSL_NO_ECDH
a495 1
#endif
a499 1
#ifndef OPENSSL_NO_RSA
a502 1
#endif
a521 1
#ifndef OPENSSL_NO_ECDSA
a523 2
#endif
#ifndef OPENSSL_NO_ECDH
a525 1
#endif
a683 1
#ifndef OPENSSL_NO_RSA
a695 1
#endif				/* !OPENSSL_NO_RSA */
a771 1
#ifndef OPENSSL_NO_RSA
a777 2
#endif
#ifndef OPENSSL_NO_DSA
a782 2
#endif
#ifndef OPENSSL_NO_ECDSA
a818 2
#endif
#ifndef OPENSSL_NO_ECDH
a854 1
#endif
a924 1
#ifndef OPENSSL_NO_RSA
a925 1
#endif
a926 1
#ifndef OPENSSL_NO_DSA
a927 2
#endif
#ifndef OPENSSL_NO_ECDSA
a931 2
#endif
#ifndef OPENSSL_NO_ECDH
a935 1
#endif
a951 1
#ifndef OPENSSL_NO_RSA
a952 1
#endif
a993 1
#ifndef OPENSSL_NO_ECDSA
a995 2
#endif
#ifndef OPENSSL_NO_ECDH
a997 1
#endif
a1005 1
#ifndef OPENSSL_NO_RSA
a1024 1
#endif
a1025 1
#ifndef OPENSSL_NO_DSA
a1028 1
#endif
a1062 1
#ifndef OPENSSL_NO_RSA
a1063 1
#endif
a1477 1
#ifndef OPENSSL_NO_RSA
a1547 1
#endif
a1549 1
#ifndef OPENSSL_NO_DSA
a1622 1
#endif
a1623 1
#ifndef OPENSSL_NO_ECDSA
a1709 1
#endif
a1710 1
#ifndef OPENSSL_NO_ECDH
a1792 1
#endif
a1841 1
#ifndef OPENSSL_NO_RSA
a1858 2
#endif
#ifndef OPENSSL_NO_DSA
a1874 2
#endif
#ifndef OPENSSL_NO_ECDSA
a1894 1
#endif
a1896 1
#ifndef OPENSSL_NO_ECDH
a1915 1
#endif
a1922 1
#ifndef OPENSSL_NO_RSA
a1925 2
#endif
#ifndef OPENSSL_NO_DSA
a1928 1
#endif
a1929 1
#ifndef OPENSSL_NO_ECDSA
a1932 2
#endif
#ifndef OPENSSL_NO_ECDH
a1938 1
#endif
a2102 1
#ifndef OPENSSL_NO_DSA
a2123 2
#endif
#ifndef OPENSSL_NO_ECDSA
a2144 1
#endif
a2145 1
#ifndef OPENSSL_NO_ECDH
a2161 1
#endif
@


1.48
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d89 1
d520 1
d632 3
a634 3
			multi = atoi(argv[0]);
			if (multi <= 0) {
				BIO_printf(bio_err, "bad multi count\n");
d2110 1
d2161 2
a2162 1
				alg = atoi(sstrsep(&p, sep));
d2171 2
a2172 1
				k = atoi(sstrsep(&p, sep));
d2191 2
a2192 1
				k = atoi(sstrsep(&p, sep));
d2213 2
a2214 1
				k = atoi(sstrsep(&p, sep));
d2236 2
a2237 1
				k = atoi(sstrsep(&p, sep));
d2260 2
a2261 1
				k = atoi(sstrsep(&p, sep));
@


1.47
log
@c-file-style hints, begone; ok beck
@
text
@d1 1
a1 1
/* apps/speed.c */
@


1.46
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* apps/speed.c -*- mode:C; c-file-style: "eay" -*- */
@


1.45
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d548 1
a548 1
	if ((buf = (unsigned char *) malloc((int) BUFSIZE)) == NULL) {
d552 1
a552 1
	if ((buf2 = (unsigned char *) malloc((int) BUFSIZE)) == NULL) {
@


1.44
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@d2109 1
a2109 1
	fds = malloc(multi * sizeof *fds);
@


1.43
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a523 1
	signal(SIGPIPE, SIG_IGN);
@


1.42
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d2016 2
a2017 4
	if (buf != NULL)
		free(buf);
	if (buf2 != NULL)
		free(buf2);
@


1.41
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d92 2
d98 1
a99 1
#include <openssl/modes.h>
a162 2

#include "apps.h"
@


1.40
log
@no no md2
@
text
@a539 5

	if (bio_err == NULL)
		if ((bio_err = BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);

@


1.39
log
@deleted seed some time ago
@
text
@a130 3
#ifndef OPENSSL_NO_MD2
#include <openssl/md2.h>
#endif
a269 3
#ifndef OPENSSL_NO_MD2
	unsigned char md2[MD2_DIGEST_LENGTH];
#endif
a648 5
#ifndef OPENSSL_NO_MD2
		if (strcmp(*argv, "md2") == 0)
			doit[D_MD2] = 1;
		else
#endif
a922 3
#ifndef OPENSSL_NO_MD2
			BIO_printf(bio_err, "md2      ");
#endif
a1151 12
#ifndef OPENSSL_NO_MD2
	if (doit[D_MD2]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_MD2], c[D_MD2][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_MD2][j]); count++)
				EVP_Digest(buf, (unsigned long) lengths[j], &(md2[0]), NULL, EVP_md2(), NULL);
			d = Time_F(STOP);
			print_result(D_MD2, j, count, d);
		}
	}
#endif
a1890 3
#ifndef OPENSSL_NO_MD2
		printf("%s ", MD2_options());
#endif
@


1.38
log
@remove crazy #undefs; ok jsing
@
text
@a157 3
#ifndef OPENSSL_NO_SEED
#include <openssl/seed.h>
#endif
a312 3
#ifndef OPENSSL_NO_SEED
	SEED_KEY_SCHEDULE seed_ks;
#endif
a798 7
#ifndef OPENSSL_NO_SEED
		if (strcmp(*argv, "seed-cbc") == 0)
			doit[D_CBC_SEED] = 1;
		else if (strcmp(*argv, "seed") == 0)
			doit[D_CBC_SEED] = 1;
		else
#endif
a973 3
#ifndef OPENSSL_NO_SEED
			BIO_printf(bio_err, "seed-cbc ");
#endif
a1025 3
#ifndef OPENSSL_NO_SEED
			BIO_printf(bio_err, "seed     ");
#endif
a1143 3
#ifndef OPENSSL_NO_SEED
	SEED_set_key(key16, &seed_ks);
#endif
a1476 13
		}
	}
#endif
#ifndef OPENSSL_NO_SEED
	if (doit[D_CBC_SEED]) {
		for (j = 0; j < SIZE_NUM; j++) {
			print_message(names[D_CBC_SEED], c[D_CBC_SEED][j], lengths[j]);
			Time_F(START);
			for (count = 0, run = 1; COND(c[D_CBC_SEED][j]); count++)
				SEED_cbc_encrypt(buf, buf,
				    (unsigned long) lengths[j], &seed_ks, iv, 1);
			d = Time_F(STOP);
			print_result(D_CBC_SEED, j, count, d);
@


1.37
log
@Sort and group includes. We also do not need to include openssl/evp.h more
than once.

ok beck@@
@
text
@a75 1
#undef SECONDS
a176 1
#undef BUFSIZE
@


1.36
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@d86 2
a87 1

d90 2
d93 1
a93 3
#include <string.h>
#include <math.h>
#include "apps.h"
a94 1
#include <openssl/rand.h>
d98 3
a100 3
#include <unistd.h>

#include <signal.h>
a101 4
#include <openssl/bn.h>
#ifndef OPENSSL_NO_DES
#include <openssl/des.h>
#endif
d105 6
d114 18
d144 2
a145 12
#ifndef OPENSSL_NO_HMAC
#include <openssl/hmac.h>
#endif
#include <openssl/evp.h>
#ifndef OPENSSL_NO_SHA
#include <openssl/sha.h>
#endif
#ifndef OPENSSL_NO_RIPEMD
#include <openssl/ripemd.h>
#endif
#ifndef OPENSSL_NO_WHIRLPOOL
#include <openssl/whrlpool.h>
d153 2
a154 2
#ifndef OPENSSL_NO_RC2
#include <openssl/rc2.h>
d156 2
a157 2
#ifndef OPENSSL_NO_IDEA
#include <openssl/idea.h>
d162 2
a163 2
#ifndef OPENSSL_NO_BF
#include <openssl/blowfish.h>
d165 2
a166 2
#ifndef OPENSSL_NO_CAST
#include <openssl/cast.h>
d168 3
a170 5
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#include "./testrsa.h"
#endif
#include <openssl/x509.h>
a171 1
#include <openssl/dsa.h>
d174 2
a175 2
#ifndef OPENSSL_NO_ECDSA
#include <openssl/ecdsa.h>
a176 5
#ifndef OPENSSL_NO_ECDH
#include <openssl/ecdh.h>
#endif
#include <openssl/modes.h>

@


1.35
log
@Rip a bunch of ifdefs from speed. We know we can fork, have SIGALRM and
do not use lint.

ok miod@@
@
text
@d536 1
a536 1
	apps_startup();
d2114 1
a2114 1
	apps_shutdown();
@


1.34
log
@Nuke the last of the windows related defines from the openssl apps.

ok deraadt@@
@
text
@a175 10
#ifndef HAVE_FORK
#define HAVE_FORK 1
#endif

#if HAVE_FORK
#undef NO_FORK
#else
#define NO_FORK
#endif

a188 1
#ifndef NO_FORK
a189 1
#endif
d222 1
a222 6
#ifdef SIGALRM
#if defined(__STDC__) || defined(sgi) || defined(_AIX)
#define SIGRETTYPE void
#else
#define SIGRETTYPE int
#endif
d224 1
a224 2
static SIGRETTYPE sig_done(int sig);
static SIGRETTYPE 
a228 3
#ifdef LINT
	sig = sig;
#endif
a229 1
#endif
a529 1
#ifndef NO_FORK
a530 1
#endif
a640 1
#ifndef NO_FORK
a655 1
#endif
a1080 1
#ifndef NO_FORK
a1081 1
#endif
a1088 1
#ifndef NO_FORK
a1090 1
#endif
a1183 212
#ifndef SIGALRM
#ifndef OPENSSL_NO_DES
	BIO_printf(bio_err, "First we calculate the approximate speed ...\n");
	count = 10;
	do {
		long it;
		count *= 2;
		Time_F(START);
		for (it = count; it; it--)
			DES_ecb_encrypt((DES_cblock *) buf,
			    (DES_cblock *) buf,
			    &sch, DES_ENCRYPT);
		d = Time_F(STOP);
	} while (d < 3);
	save_count = count;
	c[D_MD2][0] = count / 10;
	c[D_MDC2][0] = count / 10;
	c[D_MD4][0] = count;
	c[D_MD5][0] = count;
	c[D_HMAC][0] = count;
	c[D_SHA1][0] = count;
	c[D_RMD160][0] = count;
	c[D_RC4][0] = count * 5;
	c[D_CBC_DES][0] = count;
	c[D_EDE3_DES][0] = count / 3;
	c[D_CBC_IDEA][0] = count;
	c[D_CBC_SEED][0] = count;
	c[D_CBC_RC2][0] = count;
	c[D_CBC_RC5][0] = count;
	c[D_CBC_BF][0] = count;
	c[D_CBC_CAST][0] = count;
	c[D_CBC_128_AES][0] = count;
	c[D_CBC_192_AES][0] = count;
	c[D_CBC_256_AES][0] = count;
	c[D_CBC_128_CML][0] = count;
	c[D_CBC_192_CML][0] = count;
	c[D_CBC_256_CML][0] = count;
	c[D_SHA256][0] = count;
	c[D_SHA512][0] = count;
	c[D_WHIRLPOOL][0] = count;
	c[D_IGE_128_AES][0] = count;
	c[D_IGE_192_AES][0] = count;
	c[D_IGE_256_AES][0] = count;
	c[D_GHASH][0] = count;

	for (i = 1; i < SIZE_NUM; i++) {
		c[D_MD2][i] = c[D_MD2][0] * 4 * lengths[0] / lengths[i];
		c[D_MDC2][i] = c[D_MDC2][0] * 4 * lengths[0] / lengths[i];
		c[D_MD4][i] = c[D_MD4][0] * 4 * lengths[0] / lengths[i];
		c[D_MD5][i] = c[D_MD5][0] * 4 * lengths[0] / lengths[i];
		c[D_HMAC][i] = c[D_HMAC][0] * 4 * lengths[0] / lengths[i];
		c[D_SHA1][i] = c[D_SHA1][0] * 4 * lengths[0] / lengths[i];
		c[D_RMD160][i] = c[D_RMD160][0] * 4 * lengths[0] / lengths[i];
		c[D_SHA256][i] = c[D_SHA256][0] * 4 * lengths[0] / lengths[i];
		c[D_SHA512][i] = c[D_SHA512][0] * 4 * lengths[0] / lengths[i];
		c[D_WHIRLPOOL][i] = c[D_WHIRLPOOL][0] * 4 * lengths[0] / lengths[i];
	}
	for (i = 1; i < SIZE_NUM; i++) {
		long l0, l1;

		l0 = (long) lengths[i - 1];
		l1 = (long) lengths[i];
		c[D_RC4][i] = c[D_RC4][i - 1] * l0 / l1;
		c[D_CBC_DES][i] = c[D_CBC_DES][i - 1] * l0 / l1;
		c[D_EDE3_DES][i] = c[D_EDE3_DES][i - 1] * l0 / l1;
		c[D_CBC_IDEA][i] = c[D_CBC_IDEA][i - 1] * l0 / l1;
		c[D_CBC_SEED][i] = c[D_CBC_SEED][i - 1] * l0 / l1;
		c[D_CBC_RC2][i] = c[D_CBC_RC2][i - 1] * l0 / l1;
		c[D_CBC_RC5][i] = c[D_CBC_RC5][i - 1] * l0 / l1;
		c[D_CBC_BF][i] = c[D_CBC_BF][i - 1] * l0 / l1;
		c[D_CBC_CAST][i] = c[D_CBC_CAST][i - 1] * l0 / l1;
		c[D_CBC_128_AES][i] = c[D_CBC_128_AES][i - 1] * l0 / l1;
		c[D_CBC_192_AES][i] = c[D_CBC_192_AES][i - 1] * l0 / l1;
		c[D_CBC_256_AES][i] = c[D_CBC_256_AES][i - 1] * l0 / l1;
		c[D_CBC_128_CML][i] = c[D_CBC_128_CML][i - 1] * l0 / l1;
		c[D_CBC_192_CML][i] = c[D_CBC_192_CML][i - 1] * l0 / l1;
		c[D_CBC_256_CML][i] = c[D_CBC_256_CML][i - 1] * l0 / l1;
		c[D_IGE_128_AES][i] = c[D_IGE_128_AES][i - 1] * l0 / l1;
		c[D_IGE_192_AES][i] = c[D_IGE_192_AES][i - 1] * l0 / l1;
		c[D_IGE_256_AES][i] = c[D_IGE_256_AES][i - 1] * l0 / l1;
	}
#ifndef OPENSSL_NO_RSA
	rsa_c[R_RSA_512][0] = count / 2000;
	rsa_c[R_RSA_512][1] = count / 400;
	for (i = 1; i < RSA_NUM; i++) {
		rsa_c[i][0] = rsa_c[i - 1][0] / 8;
		rsa_c[i][1] = rsa_c[i - 1][1] / 4;
		if ((rsa_doit[i] <= 1) && (rsa_c[i][0] == 0))
			rsa_doit[i] = 0;
		else {
			if (rsa_c[i][0] == 0) {
				rsa_c[i][0] = 1;
				rsa_c[i][1] = 20;
			}
		}
	}
#endif

#ifndef OPENSSL_NO_DSA
	dsa_c[R_DSA_512][0] = count / 1000;
	dsa_c[R_DSA_512][1] = count / 1000 / 2;
	for (i = 1; i < DSA_NUM; i++) {
		dsa_c[i][0] = dsa_c[i - 1][0] / 4;
		dsa_c[i][1] = dsa_c[i - 1][1] / 4;
		if ((dsa_doit[i] <= 1) && (dsa_c[i][0] == 0))
			dsa_doit[i] = 0;
		else {
			if (dsa_c[i] == 0) {
				dsa_c[i][0] = 1;
				dsa_c[i][1] = 1;
			}
		}
	}
#endif

#ifndef OPENSSL_NO_ECDSA
	ecdsa_c[R_EC_P160][0] = count / 1000;
	ecdsa_c[R_EC_P160][1] = count / 1000 / 2;
	for (i = R_EC_P192; i <= R_EC_P521; i++) {
		ecdsa_c[i][0] = ecdsa_c[i - 1][0] / 2;
		ecdsa_c[i][1] = ecdsa_c[i - 1][1] / 2;
		if ((ecdsa_doit[i] <= 1) && (ecdsa_c[i][0] == 0))
			ecdsa_doit[i] = 0;
		else {
			if (ecdsa_c[i] == 0) {
				ecdsa_c[i][0] = 1;
				ecdsa_c[i][1] = 1;
			}
		}
	}
	ecdsa_c[R_EC_K163][0] = count / 1000;
	ecdsa_c[R_EC_K163][1] = count / 1000 / 2;
	for (i = R_EC_K233; i <= R_EC_K571; i++) {
		ecdsa_c[i][0] = ecdsa_c[i - 1][0] / 2;
		ecdsa_c[i][1] = ecdsa_c[i - 1][1] / 2;
		if ((ecdsa_doit[i] <= 1) && (ecdsa_c[i][0] == 0))
			ecdsa_doit[i] = 0;
		else {
			if (ecdsa_c[i] == 0) {
				ecdsa_c[i][0] = 1;
				ecdsa_c[i][1] = 1;
			}
		}
	}
	ecdsa_c[R_EC_B163][0] = count / 1000;
	ecdsa_c[R_EC_B163][1] = count / 1000 / 2;
	for (i = R_EC_B233; i <= R_EC_B571; i++) {
		ecdsa_c[i][0] = ecdsa_c[i - 1][0] / 2;
		ecdsa_c[i][1] = ecdsa_c[i - 1][1] / 2;
		if ((ecdsa_doit[i] <= 1) && (ecdsa_c[i][0] == 0))
			ecdsa_doit[i] = 0;
		else {
			if (ecdsa_c[i] == 0) {
				ecdsa_c[i][0] = 1;
				ecdsa_c[i][1] = 1;
			}
		}
	}
#endif

#ifndef OPENSSL_NO_ECDH
	ecdh_c[R_EC_P160][0] = count / 1000;
	ecdh_c[R_EC_P160][1] = count / 1000;
	for (i = R_EC_P192; i <= R_EC_P521; i++) {
		ecdh_c[i][0] = ecdh_c[i - 1][0] / 2;
		ecdh_c[i][1] = ecdh_c[i - 1][1] / 2;
		if ((ecdh_doit[i] <= 1) && (ecdh_c[i][0] == 0))
			ecdh_doit[i] = 0;
		else {
			if (ecdh_c[i] == 0) {
				ecdh_c[i][0] = 1;
				ecdh_c[i][1] = 1;
			}
		}
	}
	ecdh_c[R_EC_K163][0] = count / 1000;
	ecdh_c[R_EC_K163][1] = count / 1000;
	for (i = R_EC_K233; i <= R_EC_K571; i++) {
		ecdh_c[i][0] = ecdh_c[i - 1][0] / 2;
		ecdh_c[i][1] = ecdh_c[i - 1][1] / 2;
		if ((ecdh_doit[i] <= 1) && (ecdh_c[i][0] == 0))
			ecdh_doit[i] = 0;
		else {
			if (ecdh_c[i] == 0) {
				ecdh_c[i][0] = 1;
				ecdh_c[i][1] = 1;
			}
		}
	}
	ecdh_c[R_EC_B163][0] = count / 1000;
	ecdh_c[R_EC_B163][1] = count / 1000;
	for (i = R_EC_B233; i <= R_EC_B571; i++) {
		ecdh_c[i][0] = ecdh_c[i - 1][0] / 2;
		ecdh_c[i][1] = ecdh_c[i - 1][1] / 2;
		if ((ecdh_doit[i] <= 1) && (ecdh_c[i][0] == 0))
			ecdh_doit[i] = 0;
		else {
			if (ecdh_c[i] == 0) {
				ecdh_c[i][0] = 1;
				ecdh_c[i][1] = 1;
			}
		}
	}
#endif

#define COND(d)	(count < (d))
#define COUNT(d) (d)
#else
/* not worth fixing */
#error "You cannot disable DES on systems without SIGALRM."
#endif				/* OPENSSL_NO_DES */
#else
a1186 1
#endif				/* SIGALRM */
a1945 1
#ifndef NO_FORK
a1946 1
#endif
a2120 1
#ifdef SIGALRM
a2124 8
#else
	BIO_printf(bio_err, mr ? "+DN:%s:%ld:%d\n"
	    : "Doing %s %ld times on %d size blocks: ", s, num, length);
	(void) BIO_flush(bio_err);
#endif
#ifdef LINT
	num = num;
#endif
a2130 1
#ifdef SIGALRM
a2134 8
#else
	BIO_printf(bio_err, mr ? "+DNP:%ld:%d:%s:%s\n"
	    : "Doing %ld %d bit %s %s's: ", num, bits, str, str2);
	(void) BIO_flush(bio_err);
#endif
#ifdef LINT
	num = num;
#endif
a2144 1
#ifndef NO_FORK
a2345 1
#endif
@


1.33
log
@another "string to make the random number generator think it has entropy"
@
text
@a92 3
#ifdef OPENSSL_NO_STDIO
#define APPS_WIN16
#endif
a100 12

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#if defined(__CYGWIN__) && !defined(_WIN32)
 /*
  * <windows.h> should define _WIN32, which normally is mutually exclusive
  * with __CYGWIN__, but if it didn't...
  */
#define _WIN32
 /* this is done because Cygwin alarm() fails sometimes. */
#endif
#endif
@


1.32
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@a248 5
#if defined(OPENSSL_NO_DSA) && !(defined(OPENSSL_NO_ECDSA) && defined(OPENSSL_NO_ECDH))
static const char rnd_seed[] = "string to make the random number generator think it has entropy";
static int rnd_fake = 0;
#endif

a1955 4
	if (RAND_status() != 1) {
		RAND_seed(rnd_seed, sizeof rnd_seed);
		rnd_fake = 1;
	}
a2028 2
	if (rnd_fake)
		RAND_cleanup();
a2031 4
	if (RAND_status() != 1) {
		RAND_seed(rnd_seed, sizeof rnd_seed);
		rnd_fake = 1;
	}
a2117 2
	if (rnd_fake)
		RAND_cleanup();
a2120 4
	if (RAND_status() != 1) {
		RAND_seed(rnd_seed, sizeof rnd_seed);
		rnd_fake = 1;
	}
a2202 2
	if (rnd_fake)
		RAND_cleanup();
@


1.31
log
@KaboomNF
@
text
@a85 2
#undef PROG
#define PROG speed_main
d302 1
a302 1
int MAIN(int, char **);
d305 1
a305 1
MAIN(int argc, char **argv)
@


1.30
log
@Unifdef OPENSSL_FIPS.

ok miod@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d61 1
a61 1
 * Portions of the attached software ("Contribution") are developed by 
d67 1
a67 1
 * The ECDH and ECDSA speed test software is originally written by 
d77 1
a77 1
#define SECONDS		3	
d109 8
a116 6
# if defined(__CYGWIN__) && !defined(_WIN32)
  /* <windows.h> should define _WIN32, which normally is mutually
   * exclusive with __CYGWIN__, but if it didn't... */
#  define _WIN32
  /* this is done because Cygwin alarm() fails sometimes. */
# endif
d194 1
a194 1
#  define HAVE_FORK 1
d205 1
a205 1
int run=0;
d207 2
a208 2
static int mr=0;
static int usertime=1;
d211 5
a215 4
static void print_message(const char *s,long num,int length);
static void pkey_print_message(const char *str, const char *str2,
	long num, int bits, int sec);
static void print_result(int alg,int run_no,int count,double time_used);
d228 8
a235 8
static const char *names[ALGOR_NUM]={
  "md2","mdc2","md4","md5","hmac(md5)","sha1","rmd160","rc4",
  "des cbc","des ede3","idea cbc","seed cbc",
  "rc2 cbc","rc5-32/12 cbc","blowfish cbc","cast cbc",
  "aes-128 cbc","aes-192 cbc","aes-256 cbc",
  "camellia-128 cbc","camellia-192 cbc","camellia-256 cbc",
  "evp","sha256","sha512","whirlpool",
  "aes-128 ige","aes-192 ige","aes-256 ige","ghash" };
d237 1
a237 1
static int lengths[SIZE_NUM]={16,64,256,1024,8*1024};
d261 1
a261 1
#endif 
d264 5
a268 4
static SIGRETTYPE sig_done(int sig)
	{
	signal(SIGALRM,sig_done);
	run=0;
d270 1
a270 1
	sig=sig;
d272 1
a272 1
	}
d279 5
a283 4
static double Time_F(int s)
	{
	return app_tminterval(s,usertime);
	}
d288 3
a290 2
static void *KDF1_SHA1(const void *in, size_t inlen, void *out, size_t *outlen)
	{
d299 3
a301 3
#endif	/* OPENSSL_NO_SHA */
	}
#endif	/* OPENSSL_NO_ECDH */
d306 7
a312 6
int MAIN(int argc, char **argv)
	{
	unsigned char *buf=NULL,*buf2=NULL;
	int mret=1;
	long count=0,save_count=0;
	int i,j,k;
d369 3
a371 3
	static const unsigned char key16[16]=
		{0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,
		 0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12};
d373 9
a381 9
	static const unsigned char key24[24]=
		{0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,
		 0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,
		 0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};
	static const unsigned char key32[32]=
		{0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,
		 0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,
		 0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34,
		 0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34,0x56};
d384 9
a392 9
	static const unsigned char ckey24[24]=
		{0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,
		 0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,
		 0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};
	static const unsigned char ckey32[32]=
		{0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,
		 0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,
		 0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34,
		 0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34,0x56};
d400 1
a400 1
	unsigned char iv[2*MAX_BLOCK_SIZE/8];
d402 3
a404 3
	static DES_cblock key ={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};
	static DES_cblock key2={0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12};
	static DES_cblock key3={0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};
d434 1
a434 1
#define D_CBC_128_CML   19 
d436 1
a436 1
#define D_CBC_256_CML   21 
d438 1
a438 1
#define D_SHA256	23	
d445 1
a445 1
	double d=0.0;
d456 1
a456 1
#define R_EC_P192    1	
d475 6
a480 6
	static unsigned int rsa_bits[RSA_NUM]={512,1024,2048,4096};
	static unsigned char *rsa_data[RSA_NUM]=
		{test512,test1024,test2048,test4096};
	static int rsa_data_length[RSA_NUM]={
		sizeof(test512),sizeof(test1024),
		sizeof(test2048),sizeof(test4096)};
d485 1
a485 1
	static unsigned int dsa_bits[DSA_NUM]={512,1024,2048};
d488 5
a492 4
	/* We only test over the following curves as they are representative, 
	 * To add tests over more curves, simply add the curve NID
	 * and curve name to the following arrays and increase the 
	 * EC_NUM value accordingly. 
d494 22
a515 22
	static unsigned int test_curves[EC_NUM] = 
	{	
	/* Prime Curves */
	NID_secp160r1,
	NID_X9_62_prime192v1,
	NID_secp224r1,
	NID_X9_62_prime256v1,
	NID_secp384r1,
	NID_secp521r1,
	/* Binary Curves */
	NID_sect163k1,
	NID_sect233k1,
	NID_sect283k1,
	NID_sect409k1,
	NID_sect571k1,
	NID_sect163r2,
	NID_sect233r1,
	NID_sect283r1,
	NID_sect409r1,
	NID_sect571r1
	}; 
	static const char * test_curves_names[EC_NUM] = 
d517 18
a534 18
	/* Prime Curves */
	"secp160r1",
	"nistp192",
	"nistp224",
	"nistp256",
	"nistp384",
	"nistp521",
	/* Binary Curves */
	"nistk163",
	"nistk233",
	"nistk283",
	"nistk409",
	"nistk571",
	"nistb163",
	"nistb233",
	"nistb283",
	"nistb409",
	"nistb571"
d537 5
a541 5
        {
        160, 192, 224, 256, 384, 521,
        163, 233, 283, 409, 571,
        163, 233, 283, 409, 571
        };
d567 1
a567 1
        int ecdh_doit[EC_NUM];
d570 4
a573 4
	int pr_header=0;
	const EVP_CIPHER *evp_cipher=NULL;
	const EVP_MD *evp_md=NULL;
	int decrypt=0;
d575 1
a575 1
	int multi=0;
d579 1
a579 1
	usertime=-1;
d585 1
a585 1
	memset(dsa_key,0,sizeof(dsa_key));
d588 2
a589 1
	for (i=0; i<EC_NUM; i++) ecdsa[i] = NULL;
d592 1
a592 2
	for (i=0; i<EC_NUM; i++)
		{
d595 1
a595 1
		}
d600 2
a601 2
		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);
d607 3
a609 3
	memset(rsa_key,0,sizeof(rsa_key));
	for (i=0; i<RSA_NUM; i++)
		rsa_key[i]=NULL;
d612 2
a613 3
	if ((buf=(unsigned char *)malloc((int)BUFSIZE)) == NULL)
		{
		BIO_printf(bio_err,"out of memory\n");
d615 3
a617 4
		}
	if ((buf2=(unsigned char *)malloc((int)BUFSIZE)) == NULL)
		{
		BIO_printf(bio_err,"out of memory\n");
d619 11
a629 12
		}

	memset(c,0,sizeof(c));
	memset(DES_iv,0,sizeof(DES_iv));
	memset(iv,0,sizeof(iv));

	for (i=0; i<ALGOR_NUM; i++)
		doit[i]=0;
	for (i=0; i<RSA_NUM; i++)
		rsa_doit[i]=0;
	for (i=0; i<DSA_NUM; i++)
		dsa_doit[i]=0;
d631 2
a632 2
	for (i=0; i<EC_NUM; i++)
		ecdsa_doit[i]=0;
d635 2
a636 2
	for (i=0; i<EC_NUM; i++)
		ecdh_doit[i]=0;
d639 2
a640 2
	
	j=0;
d643 2
a644 4
	while (argc)
		{
		if	((argc > 0) && (strcmp(*argv,"-elapsed") == 0))
			{
d646 3
a648 5
			j--;	/* Otherwise, -elapsed gets confused with
				   an algorithm. */
			}
		else if	((argc > 0) && (strcmp(*argv,"-evp") == 0))
			{
d651 2
a652 3
			if(argc == 0)
				{
				BIO_printf(bio_err,"no EVP given\n");
d654 7
a660 9
				}
			evp_cipher=EVP_get_cipherbyname(*argv);
			if(!evp_cipher)
				{
				evp_md=EVP_get_digestbyname(*argv);
				}
			if(!evp_cipher && !evp_md)
				{
				BIO_printf(bio_err,"%s is an unknown cipher or digest\n",*argv);
a661 8
				}
			doit[D_EVP]=1;
			}
		else if (argc > 0 && !strcmp(*argv,"-decrypt"))
			{
			decrypt=1;
			j--;	/* Otherwise, -elapsed gets confused with
				   an algorithm. */
d663 6
d670 1
a670 2
		else if	((argc > 0) && (strcmp(*argv,"-engine") == 0))
			{
d673 2
a674 3
			if(argc == 0)
				{
				BIO_printf(bio_err,"no engine given\n");
d676 8
a683 6
				}
                        setup_engine(bio_err, *argv, 0);
			/* j will be increased again further down.  We just
			   don't want speed to confuse an engine with an
			   algorithm, especially when none is given (which
			   means all of them should be run) */
d685 1
a685 1
			}
d688 1
a688 2
		else if	((argc > 0) && (strcmp(*argv,"-multi") == 0))
			{
d691 2
a692 3
			if(argc == 0)
				{
				BIO_printf(bio_err,"no multi count given\n");
d694 4
a697 5
				}
			multi=atoi(argv[0]);
			if(multi <= 0)
			    {
				BIO_printf(bio_err,"bad multi count\n");
a698 3
				}				
			j--;	/* Otherwise, -mr gets confused with
				   an algorithm. */
d700 3
d704 5
a708 7
		else if (argc > 0 && !strcmp(*argv,"-mr"))
			{
			mr=1;
			j--;	/* Otherwise, -mr gets confused with
				   an algorithm. */
			}
		else
d710 2
a711 1
		if	(strcmp(*argv,"md2") == 0) doit[D_MD2]=1;
d715 2
a716 1
			if (strcmp(*argv,"mdc2") == 0) doit[D_MDC2]=1;
d720 2
a721 1
			if (strcmp(*argv,"md4") == 0) doit[D_MD4]=1;
d725 2
a726 1
			if (strcmp(*argv,"md5") == 0) doit[D_MD5]=1;
d730 2
a731 1
			if (strcmp(*argv,"hmac") == 0) doit[D_HMAC]=1;
d735 6
a740 5
			if (strcmp(*argv,"sha1") == 0) doit[D_SHA1]=1;
		else
			if (strcmp(*argv,"sha") == 0)	doit[D_SHA1]=1,
							doit[D_SHA256]=1,
							doit[D_SHA512]=1;
d743 2
a744 1
			if (strcmp(*argv,"sha256") == 0) doit[D_SHA256]=1;
d748 2
a749 1
			if (strcmp(*argv,"sha512") == 0) doit[D_SHA512]=1;
d754 2
a755 1
			if (strcmp(*argv,"whirlpool") == 0) doit[D_WHIRLPOOL]=1;
d759 6
a764 5
			if (strcmp(*argv,"ripemd") == 0) doit[D_RMD160]=1;
		else
			if (strcmp(*argv,"rmd160") == 0) doit[D_RMD160]=1;
		else
			if (strcmp(*argv,"ripemd160") == 0) doit[D_RMD160]=1;
d768 3
a770 2
			if (strcmp(*argv,"rc4") == 0) doit[D_RC4]=1;
		else 
d773 4
a776 2
			if (strcmp(*argv,"des-cbc") == 0) doit[D_CBC_DES]=1;
		else	if (strcmp(*argv,"des-ede3") == 0) doit[D_EDE3_DES]=1;
d780 13
a792 7
			if (strcmp(*argv,"aes-128-cbc") == 0) doit[D_CBC_128_AES]=1;
		else	if (strcmp(*argv,"aes-192-cbc") == 0) doit[D_CBC_192_AES]=1;
		else	if (strcmp(*argv,"aes-256-cbc") == 0) doit[D_CBC_256_AES]=1;
		else    if (strcmp(*argv,"aes-128-ige") == 0) doit[D_IGE_128_AES]=1;
		else	if (strcmp(*argv,"aes-192-ige") == 0) doit[D_IGE_192_AES]=1;
		else	if (strcmp(*argv,"aes-256-ige") == 0) doit[D_IGE_256_AES]=1;
                else
d795 6
a800 3
			if (strcmp(*argv,"camellia-128-cbc") == 0) doit[D_CBC_128_CML]=1;
		else    if (strcmp(*argv,"camellia-192-cbc") == 0) doit[D_CBC_192_CML]=1;
		else    if (strcmp(*argv,"camellia-256-cbc") == 0) doit[D_CBC_256_CML]=1;
d804 2
a805 3
#if 0 /* was: #ifdef RSAref */
			if (strcmp(*argv,"rsaref") == 0) 
			{
d808 1
a808 2
			}
		else
d811 1
a811 2
			if (strcmp(*argv,"openssl") == 0) 
			{
d814 1
a814 2
			}
		else
d816 15
a830 8
#endif /* !OPENSSL_NO_RSA */
		     if (strcmp(*argv,"dsa512") == 0) dsa_doit[R_DSA_512]=2;
		else if (strcmp(*argv,"dsa1024") == 0) dsa_doit[R_DSA_1024]=2;
		else if (strcmp(*argv,"dsa2048") == 0) dsa_doit[R_DSA_2048]=2;
		else if (strcmp(*argv,"rsa512") == 0) rsa_doit[R_RSA_512]=2;
		else if (strcmp(*argv,"rsa1024") == 0) rsa_doit[R_RSA_1024]=2;
		else if (strcmp(*argv,"rsa2048") == 0) rsa_doit[R_RSA_2048]=2;
		else if (strcmp(*argv,"rsa4096") == 0) rsa_doit[R_RSA_4096]=2;
d833 4
a836 2
		     if (strcmp(*argv,"rc2-cbc") == 0) doit[D_CBC_RC2]=1;
		else if (strcmp(*argv,"rc2") == 0) doit[D_CBC_RC2]=1;
d840 4
a843 2
		     if (strcmp(*argv,"rc5-cbc") == 0) doit[D_CBC_RC5]=1;
		else if (strcmp(*argv,"rc5") == 0) doit[D_CBC_RC5]=1;
d847 4
a850 2
		     if (strcmp(*argv,"idea-cbc") == 0) doit[D_CBC_IDEA]=1;
		else if (strcmp(*argv,"idea") == 0) doit[D_CBC_IDEA]=1;
d854 4
a857 2
		     if (strcmp(*argv,"seed-cbc") == 0) doit[D_CBC_SEED]=1;
		else if (strcmp(*argv,"seed") == 0) doit[D_CBC_SEED]=1;
d861 6
a866 3
		     if (strcmp(*argv,"bf-cbc") == 0) doit[D_CBC_BF]=1;
		else if (strcmp(*argv,"blowfish") == 0) doit[D_CBC_BF]=1;
		else if (strcmp(*argv,"bf") == 0) doit[D_CBC_BF]=1;
d870 6
a875 3
		     if (strcmp(*argv,"cast-cbc") == 0) doit[D_CBC_CAST]=1;
		else if (strcmp(*argv,"cast") == 0) doit[D_CBC_CAST]=1;
		else if (strcmp(*argv,"cast5") == 0) doit[D_CBC_CAST]=1;
d879 4
a882 6
			if (strcmp(*argv,"des") == 0)
			{
			doit[D_CBC_DES]=1;
			doit[D_EDE3_DES]=1;
			}
		else
d885 7
a891 11
			if (strcmp(*argv,"aes") == 0)
			{
			doit[D_CBC_128_AES]=1;
			doit[D_CBC_192_AES]=1;
			doit[D_CBC_256_AES]=1;
			}
		else if (strcmp(*argv,"ghash") == 0)
			{
			doit[D_GHASH]=1;
			}
		else
d894 5
a898 7
			if (strcmp(*argv,"camellia") == 0)
			{
			doit[D_CBC_128_CML]=1;
			doit[D_CBC_192_CML]=1;
			doit[D_CBC_256_CML]=1;
			}
		else
d901 6
a906 8
			if (strcmp(*argv,"rsa") == 0)
			{
			rsa_doit[R_RSA_512]=1;
			rsa_doit[R_RSA_1024]=1;
			rsa_doit[R_RSA_2048]=1;
			rsa_doit[R_RSA_4096]=1;
			}
		else
d909 5
a913 7
			if (strcmp(*argv,"dsa") == 0)
			{
			dsa_doit[R_DSA_512]=1;
			dsa_doit[R_DSA_1024]=1;
			dsa_doit[R_DSA_2048]=1;
			}
		else
d916 36
a951 22
		     if (strcmp(*argv,"ecdsap160") == 0) ecdsa_doit[R_EC_P160]=2;
		else if (strcmp(*argv,"ecdsap192") == 0) ecdsa_doit[R_EC_P192]=2;
		else if (strcmp(*argv,"ecdsap224") == 0) ecdsa_doit[R_EC_P224]=2;
		else if (strcmp(*argv,"ecdsap256") == 0) ecdsa_doit[R_EC_P256]=2;
		else if (strcmp(*argv,"ecdsap384") == 0) ecdsa_doit[R_EC_P384]=2;
		else if (strcmp(*argv,"ecdsap521") == 0) ecdsa_doit[R_EC_P521]=2;
		else if (strcmp(*argv,"ecdsak163") == 0) ecdsa_doit[R_EC_K163]=2;
		else if (strcmp(*argv,"ecdsak233") == 0) ecdsa_doit[R_EC_K233]=2;
		else if (strcmp(*argv,"ecdsak283") == 0) ecdsa_doit[R_EC_K283]=2;
		else if (strcmp(*argv,"ecdsak409") == 0) ecdsa_doit[R_EC_K409]=2;
		else if (strcmp(*argv,"ecdsak571") == 0) ecdsa_doit[R_EC_K571]=2;
		else if (strcmp(*argv,"ecdsab163") == 0) ecdsa_doit[R_EC_B163]=2;
		else if (strcmp(*argv,"ecdsab233") == 0) ecdsa_doit[R_EC_B233]=2;
		else if (strcmp(*argv,"ecdsab283") == 0) ecdsa_doit[R_EC_B283]=2;
		else if (strcmp(*argv,"ecdsab409") == 0) ecdsa_doit[R_EC_B409]=2;
		else if (strcmp(*argv,"ecdsab571") == 0) ecdsa_doit[R_EC_B571]=2;
		else if (strcmp(*argv,"ecdsa") == 0)
			{
			for (i=0; i < EC_NUM; i++)
				ecdsa_doit[i]=1;
			}
		else
d954 41
a994 27
		     if (strcmp(*argv,"ecdhp160") == 0) ecdh_doit[R_EC_P160]=2;
		else if (strcmp(*argv,"ecdhp192") == 0) ecdh_doit[R_EC_P192]=2;
		else if (strcmp(*argv,"ecdhp224") == 0) ecdh_doit[R_EC_P224]=2;
		else if (strcmp(*argv,"ecdhp256") == 0) ecdh_doit[R_EC_P256]=2;
		else if (strcmp(*argv,"ecdhp384") == 0) ecdh_doit[R_EC_P384]=2;
		else if (strcmp(*argv,"ecdhp521") == 0) ecdh_doit[R_EC_P521]=2;
		else if (strcmp(*argv,"ecdhk163") == 0) ecdh_doit[R_EC_K163]=2;
		else if (strcmp(*argv,"ecdhk233") == 0) ecdh_doit[R_EC_K233]=2;
		else if (strcmp(*argv,"ecdhk283") == 0) ecdh_doit[R_EC_K283]=2;
		else if (strcmp(*argv,"ecdhk409") == 0) ecdh_doit[R_EC_K409]=2;
		else if (strcmp(*argv,"ecdhk571") == 0) ecdh_doit[R_EC_K571]=2;
		else if (strcmp(*argv,"ecdhb163") == 0) ecdh_doit[R_EC_B163]=2;
		else if (strcmp(*argv,"ecdhb233") == 0) ecdh_doit[R_EC_B233]=2;
		else if (strcmp(*argv,"ecdhb283") == 0) ecdh_doit[R_EC_B283]=2;
		else if (strcmp(*argv,"ecdhb409") == 0) ecdh_doit[R_EC_B409]=2;
		else if (strcmp(*argv,"ecdhb571") == 0) ecdh_doit[R_EC_B571]=2;
		else if (strcmp(*argv,"ecdh") == 0)
			{
			for (i=0; i < EC_NUM; i++)
				ecdh_doit[i]=1;
			}
		else
#endif
			{
			BIO_printf(bio_err,"Error: bad option or value\n");
			BIO_printf(bio_err,"\n");
			BIO_printf(bio_err,"Available values:\n");
d996 1
a996 1
			BIO_printf(bio_err,"md2      ");
d999 1
a999 1
			BIO_printf(bio_err,"mdc2     ");
d1002 1
a1002 1
			BIO_printf(bio_err,"md4      ");
d1005 1
a1005 1
			BIO_printf(bio_err,"md5      ");
d1007 1
a1007 1
			BIO_printf(bio_err,"hmac     ");
d1011 1
a1011 1
			BIO_printf(bio_err,"sha1     ");
d1014 1
a1014 1
			BIO_printf(bio_err,"sha256   ");
d1017 1
a1017 1
			BIO_printf(bio_err,"sha512   ");
d1020 1
a1020 1
			BIO_printf(bio_err,"whirlpool");
d1023 1
a1023 1
			BIO_printf(bio_err,"rmd160");
d1029 1
a1029 1
			BIO_printf(bio_err,"\n");
d1033 1
a1033 1
			BIO_printf(bio_err,"idea-cbc ");
d1036 1
a1036 1
			BIO_printf(bio_err,"seed-cbc ");
d1039 1
a1039 1
			BIO_printf(bio_err,"rc2-cbc  ");
d1042 1
a1042 1
			BIO_printf(bio_err,"rc5-cbc  ");
d1045 1
a1045 1
			BIO_printf(bio_err,"bf-cbc");
d1049 1
a1049 1
			BIO_printf(bio_err,"\n");
d1052 1
a1052 1
			BIO_printf(bio_err,"des-cbc  des-ede3 ");
d1055 2
a1056 2
			BIO_printf(bio_err,"aes-128-cbc aes-192-cbc aes-256-cbc ");
			BIO_printf(bio_err,"aes-128-ige aes-192-ige aes-256-ige ");
d1059 2
a1060 2
			BIO_printf(bio_err,"\n");
			BIO_printf(bio_err,"camellia-128-cbc camellia-192-cbc camellia-256-cbc ");
d1063 1
a1063 1
			BIO_printf(bio_err,"rc4");
d1065 1
a1065 1
			BIO_printf(bio_err,"\n");
d1068 1
a1068 1
			BIO_printf(bio_err,"rsa512   rsa1024  rsa2048  rsa4096\n");
d1072 1
a1072 1
			BIO_printf(bio_err,"dsa512   dsa1024  dsa2048\n");
d1075 4
a1078 4
			BIO_printf(bio_err,"ecdsap160 ecdsap192 ecdsap224 ecdsap256 ecdsap384 ecdsap521\n");
			BIO_printf(bio_err,"ecdsak163 ecdsak233 ecdsak283 ecdsak409 ecdsak571\n");
			BIO_printf(bio_err,"ecdsab163 ecdsab233 ecdsab283 ecdsab409 ecdsab571\n");
			BIO_printf(bio_err,"ecdsa\n");
d1081 4
a1084 4
			BIO_printf(bio_err,"ecdhp160  ecdhp192  ecdhp224  ecdhp256  ecdhp384  ecdhp521\n");
			BIO_printf(bio_err,"ecdhk163  ecdhk233  ecdhk283  ecdhk409  ecdhk571\n");
			BIO_printf(bio_err,"ecdhb163  ecdhb233  ecdhb283  ecdhb409  ecdhb571\n");
			BIO_printf(bio_err,"ecdh\n");
d1088 1
a1088 1
			BIO_printf(bio_err,"idea     ");
d1091 1
a1091 1
			BIO_printf(bio_err,"seed     ");
d1094 1
a1094 1
			BIO_printf(bio_err,"rc2      ");
d1097 1
a1097 1
			BIO_printf(bio_err,"des      ");
d1100 1
a1100 1
			BIO_printf(bio_err,"aes      ");
d1103 1
a1103 1
			BIO_printf(bio_err,"camellia ");
d1106 1
a1106 1
			BIO_printf(bio_err,"rsa      ");
d1109 1
a1109 1
			BIO_printf(bio_err,"blowfish");
d1115 1
a1115 1
			BIO_printf(bio_err,"\n");
d1118 2
a1119 2
			BIO_printf(bio_err,"\n");
			BIO_printf(bio_err,"Available options:\n");
d1121 1
a1121 1
			BIO_printf(bio_err,"-elapsed        measure time in real time instead of CPU user time.\n");
d1124 1
a1124 1
			BIO_printf(bio_err,"-engine e       use engine e, possibly a hardware device.\n");
d1126 3
a1128 3
			BIO_printf(bio_err,"-evp e          use EVP e.\n");
			BIO_printf(bio_err,"-decrypt        time decryption instead of encryption (only EVP).\n");
			BIO_printf(bio_err,"-mr             produce machine readable output.\n");
d1130 1
a1130 1
			BIO_printf(bio_err,"-multi n        run n benchmarks in parallel.\n");
d1133 1
a1133 1
			}
d1137 1
a1137 1
		}
d1140 1
a1140 1
	if(multi && do_multi(multi))
d1144 2
a1145 4
	if (j == 0)
		{
		for (i=0; i<ALGOR_NUM; i++)
			{
d1147 6
a1152 6
				doit[i]=1;
			}
		for (i=0; i<RSA_NUM; i++)
			rsa_doit[i]=1;
		for (i=0; i<DSA_NUM; i++)
			dsa_doit[i]=1;
d1154 2
a1155 2
		for (i=0; i<EC_NUM; i++)
			ecdsa_doit[i]=1;
d1158 2
a1159 2
		for (i=0; i<EC_NUM; i++)
			ecdh_doit[i]=1;
d1161 4
a1164 3
		}
	for (i=0; i<ALGOR_NUM; i++)
		if (doit[i]) pr_header++;
d1167 1
a1167 1
		BIO_printf(bio_err,"You have chosen to measure elapsed time instead of user CPU time.\n");
d1170 1
a1170 2
	for (i=0; i<RSA_NUM; i++)
		{
d1173 4
a1176 5
		p=rsa_data[i];
		rsa_key[i]=d2i_RSAPrivateKey(NULL,&p,rsa_data_length[i]);
		if (rsa_key[i] == NULL)
			{
			BIO_printf(bio_err,"internal error loading RSA key number %d\n",i);
d1178 1
a1178 1
			}
d1180 7
a1186 8
		else
			{
			BIO_printf(bio_err,mr ? "+RK:%d:"
				   : "Loaded RSA key, %d bit modulus and e= 0x",
				   BN_num_bits(rsa_key[i]->n));
			BN_print(bio_err,rsa_key[i]->e);
			BIO_printf(bio_err,"\n");
			}
d1188 1
a1188 1
		}
d1192 3
a1194 3
	dsa_key[0]=get_dsa512();
	dsa_key[1]=get_dsa1024();
	dsa_key[2]=get_dsa2048();
d1198 3
a1200 3
	DES_set_key_unchecked(&key,&sch);
	DES_set_key_unchecked(&key2,&sch2);
	DES_set_key_unchecked(&key3,&sch3);
d1203 3
a1205 3
	AES_set_encrypt_key(key16,128,&aes_ks1);
	AES_set_encrypt_key(key24,192,&aes_ks2);
	AES_set_encrypt_key(key32,256,&aes_ks3);
d1208 3
a1210 3
	Camellia_set_key(key16,128,&camellia_ks1);
	Camellia_set_key(ckey24,192,&camellia_ks2);
	Camellia_set_key(ckey32,256,&camellia_ks3);
d1213 1
a1213 1
	idea_set_encrypt_key(key16,&idea_ks);
d1216 1
a1216 1
	SEED_set_key(key16,&seed_ks);
d1219 1
a1219 1
	RC4_set_key(&rc4_ks,16,key16);
d1222 1
a1222 1
	RC2_set_key(&rc2_ks,16,key16,128);
d1225 1
a1225 1
	RC5_32_set_key(&rc5_ks,16,key16,12);
d1228 1
a1228 1
	BF_set_key(&bf_ks,16,key16);
d1231 1
a1231 1
	CAST_set_key(&cast_ks,16,key16);
d1234 1
a1234 1
	memset(rsa_c,0,sizeof(rsa_c));
d1238 3
a1240 3
	BIO_printf(bio_err,"First we calculate the approximate speed ...\n");
	count=10;
	do	{
d1242 1
a1242 1
		count*=2;
d1244 51
a1294 36
		for (it=count; it; it--)
			DES_ecb_encrypt((DES_cblock *)buf,
				(DES_cblock *)buf,
				&sch,DES_ENCRYPT);
		d=Time_F(STOP);
		} while (d <3);
	save_count=count;
	c[D_MD2][0]=count/10;
	c[D_MDC2][0]=count/10;
	c[D_MD4][0]=count;
	c[D_MD5][0]=count;
	c[D_HMAC][0]=count;
	c[D_SHA1][0]=count;
	c[D_RMD160][0]=count;
	c[D_RC4][0]=count*5;
	c[D_CBC_DES][0]=count;
	c[D_EDE3_DES][0]=count/3;
	c[D_CBC_IDEA][0]=count;
	c[D_CBC_SEED][0]=count;
	c[D_CBC_RC2][0]=count;
	c[D_CBC_RC5][0]=count;
	c[D_CBC_BF][0]=count;
	c[D_CBC_CAST][0]=count;
	c[D_CBC_128_AES][0]=count;
	c[D_CBC_192_AES][0]=count;
	c[D_CBC_256_AES][0]=count;
	c[D_CBC_128_CML][0]=count;
	c[D_CBC_192_CML][0]=count;
	c[D_CBC_256_CML][0]=count;
	c[D_SHA256][0]=count;
	c[D_SHA512][0]=count;
	c[D_WHIRLPOOL][0]=count;
	c[D_IGE_128_AES][0]=count;
	c[D_IGE_192_AES][0]=count;
	c[D_IGE_256_AES][0]=count;
	c[D_GHASH][0]=count;
d1296 21
a1316 38
	for (i=1; i<SIZE_NUM; i++)
		{
		c[D_MD2][i]=c[D_MD2][0]*4*lengths[0]/lengths[i];
		c[D_MDC2][i]=c[D_MDC2][0]*4*lengths[0]/lengths[i];
		c[D_MD4][i]=c[D_MD4][0]*4*lengths[0]/lengths[i];
		c[D_MD5][i]=c[D_MD5][0]*4*lengths[0]/lengths[i];
		c[D_HMAC][i]=c[D_HMAC][0]*4*lengths[0]/lengths[i];
		c[D_SHA1][i]=c[D_SHA1][0]*4*lengths[0]/lengths[i];
		c[D_RMD160][i]=c[D_RMD160][0]*4*lengths[0]/lengths[i];
		c[D_SHA256][i]=c[D_SHA256][0]*4*lengths[0]/lengths[i];
		c[D_SHA512][i]=c[D_SHA512][0]*4*lengths[0]/lengths[i];
		c[D_WHIRLPOOL][i]=c[D_WHIRLPOOL][0]*4*lengths[0]/lengths[i];
		}
	for (i=1; i<SIZE_NUM; i++)
		{
		long l0,l1;

		l0=(long)lengths[i-1];
		l1=(long)lengths[i];
		c[D_RC4][i]=c[D_RC4][i-1]*l0/l1;
		c[D_CBC_DES][i]=c[D_CBC_DES][i-1]*l0/l1;
		c[D_EDE3_DES][i]=c[D_EDE3_DES][i-1]*l0/l1;
		c[D_CBC_IDEA][i]=c[D_CBC_IDEA][i-1]*l0/l1;
		c[D_CBC_SEED][i]=c[D_CBC_SEED][i-1]*l0/l1;
		c[D_CBC_RC2][i]=c[D_CBC_RC2][i-1]*l0/l1;
		c[D_CBC_RC5][i]=c[D_CBC_RC5][i-1]*l0/l1;
		c[D_CBC_BF][i]=c[D_CBC_BF][i-1]*l0/l1;
		c[D_CBC_CAST][i]=c[D_CBC_CAST][i-1]*l0/l1;
		c[D_CBC_128_AES][i]=c[D_CBC_128_AES][i-1]*l0/l1;
		c[D_CBC_192_AES][i]=c[D_CBC_192_AES][i-1]*l0/l1;
		c[D_CBC_256_AES][i]=c[D_CBC_256_AES][i-1]*l0/l1;
 		c[D_CBC_128_CML][i]=c[D_CBC_128_CML][i-1]*l0/l1;
		c[D_CBC_192_CML][i]=c[D_CBC_192_CML][i-1]*l0/l1;
		c[D_CBC_256_CML][i]=c[D_CBC_256_CML][i-1]*l0/l1;
		c[D_IGE_128_AES][i]=c[D_IGE_128_AES][i-1]*l0/l1;
		c[D_IGE_192_AES][i]=c[D_IGE_192_AES][i-1]*l0/l1;
		c[D_IGE_256_AES][i]=c[D_IGE_256_AES][i-1]*l0/l1;
		}
d1318 5
a1322 6
	rsa_c[R_RSA_512][0]=count/2000;
	rsa_c[R_RSA_512][1]=count/400;
	for (i=1; i<RSA_NUM; i++)
		{
		rsa_c[i][0]=rsa_c[i-1][0]/8;
		rsa_c[i][1]=rsa_c[i-1][1]/4;
d1324 6
a1329 9
			rsa_doit[i]=0;
		else
			{
			if (rsa_c[i][0] == 0)
				{
				rsa_c[i][0]=1;
				rsa_c[i][1]=20;
				}
			}				
d1331 1
d1335 5
a1339 6
	dsa_c[R_DSA_512][0]=count/1000;
	dsa_c[R_DSA_512][1]=count/1000/2;
	for (i=1; i<DSA_NUM; i++)
		{
		dsa_c[i][0]=dsa_c[i-1][0]/4;
		dsa_c[i][1]=dsa_c[i-1][1]/4;
d1341 6
a1346 9
			dsa_doit[i]=0;
		else
			{
			if (dsa_c[i] == 0)
				{
				dsa_c[i][0]=1;
				dsa_c[i][1]=1;
				}
			}				
d1348 1
d1352 5
a1356 6
	ecdsa_c[R_EC_P160][0]=count/1000;
	ecdsa_c[R_EC_P160][1]=count/1000/2;
	for (i=R_EC_P192; i<=R_EC_P521; i++)
		{
		ecdsa_c[i][0]=ecdsa_c[i-1][0]/2;
		ecdsa_c[i][1]=ecdsa_c[i-1][1]/2;
d1358 5
a1362 8
			ecdsa_doit[i]=0;
		else
			{
			if (ecdsa_c[i] == 0)
				{
				ecdsa_c[i][0]=1;
				ecdsa_c[i][1]=1;
				}
d1365 6
a1370 6
	ecdsa_c[R_EC_K163][0]=count/1000;
	ecdsa_c[R_EC_K163][1]=count/1000/2;
	for (i=R_EC_K233; i<=R_EC_K571; i++)
		{
		ecdsa_c[i][0]=ecdsa_c[i-1][0]/2;
		ecdsa_c[i][1]=ecdsa_c[i-1][1]/2;
d1372 5
a1376 8
			ecdsa_doit[i]=0;
		else
			{
			if (ecdsa_c[i] == 0)
				{
				ecdsa_c[i][0]=1;
				ecdsa_c[i][1]=1;
				}
d1379 6
a1384 6
	ecdsa_c[R_EC_B163][0]=count/1000;
	ecdsa_c[R_EC_B163][1]=count/1000/2;
	for (i=R_EC_B233; i<=R_EC_B571; i++)
		{
		ecdsa_c[i][0]=ecdsa_c[i-1][0]/2;
		ecdsa_c[i][1]=ecdsa_c[i-1][1]/2;
d1386 5
a1390 8
			ecdsa_doit[i]=0;
		else
			{
			if (ecdsa_c[i] == 0)
				{
				ecdsa_c[i][0]=1;
				ecdsa_c[i][1]=1;
				}
d1393 1
d1397 5
a1401 6
	ecdh_c[R_EC_P160][0]=count/1000;
	ecdh_c[R_EC_P160][1]=count/1000;
	for (i=R_EC_P192; i<=R_EC_P521; i++)
		{
		ecdh_c[i][0]=ecdh_c[i-1][0]/2;
		ecdh_c[i][1]=ecdh_c[i-1][1]/2;
d1403 5
a1407 8
			ecdh_doit[i]=0;
		else
			{
			if (ecdh_c[i] == 0)
				{
				ecdh_c[i][0]=1;
				ecdh_c[i][1]=1;
				}
d1410 6
a1415 6
	ecdh_c[R_EC_K163][0]=count/1000;
	ecdh_c[R_EC_K163][1]=count/1000;
	for (i=R_EC_K233; i<=R_EC_K571; i++)
		{
		ecdh_c[i][0]=ecdh_c[i-1][0]/2;
		ecdh_c[i][1]=ecdh_c[i-1][1]/2;
d1417 5
a1421 8
			ecdh_doit[i]=0;
		else
			{
			if (ecdh_c[i] == 0)
				{
				ecdh_c[i][0]=1;
				ecdh_c[i][1]=1;
				}
d1424 6
a1429 6
	ecdh_c[R_EC_B163][0]=count/1000;
	ecdh_c[R_EC_B163][1]=count/1000;
	for (i=R_EC_B233; i<=R_EC_B571; i++)
		{
		ecdh_c[i][0]=ecdh_c[i-1][0]/2;
		ecdh_c[i][1]=ecdh_c[i-1][1]/2;
d1431 5
a1435 8
			ecdh_doit[i]=0;
		else
			{
			if (ecdh_c[i] == 0)
				{
				ecdh_c[i][0]=1;
				ecdh_c[i][1]=1;
				}
d1438 1
d1445 2
a1446 2
# error "You cannot disable DES on systems without SIGALRM."
#endif /* OPENSSL_NO_DES */
d1450 2
a1451 2
	signal(SIGALRM,sig_done);
#endif /* SIGALRM */
d1454 8
a1461 11
	if (doit[D_MD2])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_MD2],c[D_MD2][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_MD2][j]); count++)
				EVP_Digest(buf,(unsigned long)lengths[j],&(md2[0]),NULL,EVP_md2(),NULL);
			d=Time_F(STOP);
			print_result(D_MD2,j,count,d);
			}
d1463 1
d1466 8
a1473 11
	if (doit[D_MDC2])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_MDC2],c[D_MDC2][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_MDC2][j]); count++)
				EVP_Digest(buf,(unsigned long)lengths[j],&(mdc2[0]),NULL,EVP_mdc2(),NULL);
			d=Time_F(STOP);
			print_result(D_MDC2,j,count,d);
			}
d1475 1
d1479 8
a1486 11
	if (doit[D_MD4])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_MD4],c[D_MD4][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_MD4][j]); count++)
				EVP_Digest(&(buf[0]),(unsigned long)lengths[j],&(md4[0]),NULL,EVP_md4(),NULL);
			d=Time_F(STOP);
			print_result(D_MD4,j,count,d);
			}
d1488 1
d1492 8
a1499 11
	if (doit[D_MD5])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_MD5],c[D_MD5][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_MD5][j]); count++)
				EVP_Digest(&(buf[0]),(unsigned long)lengths[j],&(md5[0]),NULL,EVP_get_digestbyname("md5"),NULL);
			d=Time_F(STOP);
			print_result(D_MD5,j,count,d);
			}
d1501 1
d1505 1
a1505 2
	if (doit[D_HMAC])
		{
d1509 2
a1510 2
		HMAC_Init_ex(&hctx,(unsigned char *)"This is a key...",
			16,EVP_md5(), NULL);
d1512 7
a1518 12
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_HMAC],c[D_HMAC][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_HMAC][j]); count++)
				{
				HMAC_Init_ex(&hctx,NULL,0,NULL,NULL);
				HMAC_Update(&hctx,buf,lengths[j]);
				HMAC_Final(&hctx,&(hmac[0]),NULL);
				}
			d=Time_F(STOP);
			print_result(D_HMAC,j,count,d);
d1520 3
d1524 1
a1524 1
		}
d1527 8
a1534 11
	if (doit[D_SHA1])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_SHA1],c[D_SHA1][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_SHA1][j]); count++)
				EVP_Digest(buf,(unsigned long)lengths[j],&(sha[0]),NULL,EVP_sha1(),NULL);
			d=Time_F(STOP);
			print_result(D_SHA1,j,count,d);
			}
d1536 1
a1536 1

d1538 8
a1545 11
	if (doit[D_SHA256])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_SHA256],c[D_SHA256][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_SHA256][j]); count++)
				SHA256(buf,lengths[j],sha256);
			d=Time_F(STOP);
			print_result(D_SHA256,j,count,d);
			}
d1547 1
d1551 8
a1558 11
	if (doit[D_SHA512])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_SHA512],c[D_SHA512][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_SHA512][j]); count++)
				SHA512(buf,lengths[j],sha512);
			d=Time_F(STOP);
			print_result(D_SHA512,j,count,d);
			}
d1560 1
d1565 8
a1572 11
	if (doit[D_WHIRLPOOL])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_WHIRLPOOL],c[D_WHIRLPOOL][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_WHIRLPOOL][j]); count++)
				WHIRLPOOL(buf,lengths[j],whirlpool);
			d=Time_F(STOP);
			print_result(D_WHIRLPOOL,j,count,d);
			}
d1574 1
d1578 8
a1585 11
	if (doit[D_RMD160])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_RMD160],c[D_RMD160][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_RMD160][j]); count++)
				EVP_Digest(buf,(unsigned long)lengths[j],&(rmd160[0]),NULL,EVP_ripemd160(),NULL);
			d=Time_F(STOP);
			print_result(D_RMD160,j,count,d);
			}
d1587 1
d1590 9
a1598 12
	if (doit[D_RC4])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_RC4],c[D_RC4][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_RC4][j]); count++)
				RC4(&rc4_ks,(unsigned int)lengths[j],
					buf,buf);
			d=Time_F(STOP);
			print_result(D_RC4,j,count,d);
			}
d1600 1
d1603 9
a1611 12
	if (doit[D_CBC_DES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_DES],c[D_CBC_DES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_DES][j]); count++)
				DES_ncbc_encrypt(buf,buf,lengths[j],&sch,
						 &DES_iv,DES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_DES,j,count,d);
			}
d1613 11
a1623 14

	if (doit[D_EDE3_DES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_EDE3_DES],c[D_EDE3_DES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_EDE3_DES][j]); count++)
				DES_ede3_cbc_encrypt(buf,buf,lengths[j],
						     &sch,&sch2,&sch3,
						     &DES_iv,DES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_EDE3_DES,j,count,d);
			}
d1625 1
d1628 22
a1649 13
	if (doit[D_CBC_128_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_128_AES],c[D_CBC_128_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_128_AES][j]); count++)
				AES_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&aes_ks1,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_128_AES,j,count,d);
			}
d1651 11
a1661 13
	if (doit[D_CBC_192_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_192_AES],c[D_CBC_192_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_192_AES][j]); count++)
				AES_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&aes_ks2,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_192_AES,j,count,d);
			}
d1663 11
a1673 13
	if (doit[D_CBC_256_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_256_AES],c[D_CBC_256_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_256_AES][j]); count++)
				AES_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&aes_ks3,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_256_AES,j,count,d);
			}
d1675 11
a1685 14

	if (doit[D_IGE_128_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_IGE_128_AES],c[D_IGE_128_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_IGE_128_AES][j]); count++)
				AES_ige_encrypt(buf,buf2,
					(unsigned long)lengths[j],&aes_ks1,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_IGE_128_AES,j,count,d);
			}
d1687 11
a1697 13
	if (doit[D_IGE_192_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_IGE_192_AES],c[D_IGE_192_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_IGE_192_AES][j]); count++)
				AES_ige_encrypt(buf,buf2,
					(unsigned long)lengths[j],&aes_ks2,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_IGE_192_AES,j,count,d);
			}
d1699 12
a1710 13
	if (doit[D_IGE_256_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_IGE_256_AES],c[D_IGE_256_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_IGE_256_AES][j]); count++)
				AES_ige_encrypt(buf,buf2,
					(unsigned long)lengths[j],&aes_ks3,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_IGE_256_AES,j,count,d);
			}
a1711 14
	if (doit[D_GHASH])
		{
		GCM128_CONTEXT *ctx = CRYPTO_gcm128_new(&aes_ks1,(block128_f)AES_encrypt);
		CRYPTO_gcm128_setiv (ctx,(unsigned char *)"0123456789ab",12);

		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_GHASH],c[D_GHASH][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_GHASH][j]); count++)
				CRYPTO_gcm128_aad(ctx,buf,lengths[j]);
			d=Time_F(STOP);
			print_result(D_GHASH,j,count,d);
			}
d1713 1
a1713 2
		}

d1716 10
a1725 13
	if (doit[D_CBC_128_CML])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_128_CML],c[D_CBC_128_CML][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_128_CML][j]); count++)
				Camellia_cbc_encrypt(buf,buf,
				        (unsigned long)lengths[j],&camellia_ks1,
				        iv,CAMELLIA_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_128_CML,j,count,d);
			}
d1727 11
a1737 13
	if (doit[D_CBC_192_CML])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_192_CML],c[D_CBC_192_CML][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_192_CML][j]); count++)
				Camellia_cbc_encrypt(buf,buf,
				        (unsigned long)lengths[j],&camellia_ks2,
				        iv,CAMELLIA_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_192_CML,j,count,d);
			}
d1739 11
a1749 13
	if (doit[D_CBC_256_CML])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_256_CML],c[D_CBC_256_CML][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_256_CML][j]); count++)
				Camellia_cbc_encrypt(buf,buf,
				        (unsigned long)lengths[j],&camellia_ks3,
				        iv,CAMELLIA_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_256_CML,j,count,d);
			}
d1751 1
a1751 1

d1754 10
a1763 13
	if (doit[D_CBC_IDEA])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_IDEA],c[D_CBC_IDEA][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_IDEA][j]); count++)
				idea_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&idea_ks,
					iv,IDEA_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_IDEA,j,count,d);
			}
d1765 1
d1768 9
a1776 12
	if (doit[D_CBC_SEED])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_SEED],c[D_CBC_SEED][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_SEED][j]); count++)
				SEED_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&seed_ks,iv,1);
			d=Time_F(STOP);
			print_result(D_CBC_SEED,j,count,d);
			}
d1778 1
d1781 10
a1790 13
	if (doit[D_CBC_RC2])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_RC2],c[D_CBC_RC2][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_RC2][j]); count++)
				RC2_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&rc2_ks,
					iv,RC2_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_RC2,j,count,d);
			}
d1792 1
d1795 10
a1804 13
	if (doit[D_CBC_RC5])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_RC5],c[D_CBC_RC5][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_RC5][j]); count++)
				RC5_32_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&rc5_ks,
					iv,RC5_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_RC5,j,count,d);
			}
d1806 1
d1809 10
a1818 13
	if (doit[D_CBC_BF])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_BF],c[D_CBC_BF][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_BF][j]); count++)
				BF_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&bf_ks,
					iv,BF_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_BF,j,count,d);
			}
d1820 1
d1823 10
a1832 13
	if (doit[D_CBC_CAST])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_CAST],c[D_CBC_CAST][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_CAST][j]); count++)
				CAST_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&cast_ks,
					iv,CAST_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_CAST,j,count,d);
			}
d1834 1
d1837 3
a1839 6
	if (doit[D_EVP])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			if (evp_cipher)
				{
d1843 8
a1850 6
				names[D_EVP]=OBJ_nid2ln(evp_cipher->nid);
				/* -O3 -fschedule-insns messes up an
				 * optimization here!  names[D_EVP]
				 * somehow becomes NULL */
				print_message(names[D_EVP],save_count,
					lengths[j]);
d1853 2
a1854 2
				if(decrypt)
					EVP_DecryptInit_ex(&ctx,evp_cipher,NULL,key16,iv);
d1856 1
a1856 1
					EVP_EncryptInit_ex(&ctx,evp_cipher,NULL,key16,iv);
d1860 3
a1862 3
				if(decrypt)
					for (count=0,run=1; COND(save_count*4*lengths[0]/lengths[j]); count++)
						EVP_DecryptUpdate(&ctx,buf,&outl,buf,lengths[j]);
d1864 4
a1867 4
					for (count=0,run=1; COND(save_count*4*lengths[0]/lengths[j]); count++)
						EVP_EncryptUpdate(&ctx,buf,&outl,buf,lengths[j]);
				if(decrypt)
					EVP_DecryptFinal_ex(&ctx,buf,&outl);
d1869 2
a1870 2
					EVP_EncryptFinal_ex(&ctx,buf,&outl);
				d=Time_F(STOP);
d1872 5
a1876 6
				}
			if (evp_md)
				{
				names[D_EVP]=OBJ_nid2ln(evp_md->type);
				print_message(names[D_EVP],save_count,
					lengths[j]);
d1879 2
a1880 2
				for (count=0,run=1; COND(save_count*4*lengths[0]/lengths[j]); count++)
					EVP_Digest(buf,lengths[j],&(md[0]),NULL,evp_md,NULL);
d1882 1
a1882 3
				d=Time_F(STOP);
				}
			print_result(D_EVP,j,count,d);
d1884 1
d1886 2
a1887 2

	RAND_pseudo_bytes(buf,36);
d1889 1
a1889 2
	for (j=0; j<RSA_NUM; j++)
		{
d1891 5
a1895 5
		if (!rsa_doit[j]) continue;
		ret=RSA_sign(NID_md5_sha1, buf,36, buf2, &rsa_num, rsa_key[j]);
		if (ret == 0)
			{
			BIO_printf(bio_err,"RSA sign failure.  No RSA sign will be done.\n");
d1897 5
a1901 7
			rsa_count=1;
			}
		else
			{
			pkey_print_message("private","rsa",
				rsa_c[j][0],rsa_bits[j],
				RSA_SECONDS);
d1904 4
a1907 6
			for (count=0,run=1; COND(rsa_c[j][0]); count++)
				{
				ret=RSA_sign(NID_md5_sha1, buf,36, buf2,
					&rsa_num, rsa_key[j]);
				if (ret == 0)
					{
d1909 1
a1909 1
						"RSA sign failure\n");
d1911 1
a1911 1
					count=1;
a1912 1
					}
a1913 6
			d=Time_F(STOP);
			BIO_printf(bio_err,mr ? "+R1:%ld:%d:%.2f\n"
				   : "%ld %d bit private RSA's in %.2fs\n",
				   count,rsa_bits[j],d);
			rsa_results[j][0]=d/(double)count;
			rsa_count=count;
d1915 7
d1924 3
a1926 4
		ret=RSA_verify(NID_md5_sha1, buf,36, buf2, rsa_num, rsa_key[j]);
		if (ret <= 0)
			{
			BIO_printf(bio_err,"RSA verify failure.  No RSA verify will be done.\n");
d1929 9
a1937 13
			}
		else
			{
			pkey_print_message("public","rsa",
				rsa_c[j][1],rsa_bits[j],
				RSA_SECONDS);
			Time_F(START);
			for (count=0,run=1; COND(rsa_c[j][1]); count++)
				{
				ret=RSA_verify(NID_md5_sha1, buf,36, buf2,
					rsa_num, rsa_key[j]);
				if (ret <= 0)
					{
d1939 1
a1939 1
						"RSA verify failure\n");
d1941 1
a1941 1
					count=1;
a1942 1
					}
a1943 5
			d=Time_F(STOP);
			BIO_printf(bio_err,mr ? "+R2:%ld:%d:%.2f\n"
				   : "%ld %d bit public RSA's in %.2fs\n",
				   count,rsa_bits[j],d);
			rsa_results[j][1]=d/(double)count;
d1945 6
d1953 1
a1953 2
		if (rsa_count <= 1)
			{
d1955 2
a1956 3
			for (j++; j<RSA_NUM; j++)
				rsa_doit[j]=0;
			}
d1958 1
d1961 1
a1961 1
	RAND_pseudo_bytes(buf,20);
d1963 1
a1963 2
	if (RAND_status() != 1)
		{
d1966 2
a1967 3
		}
	for (j=0; j<DSA_NUM; j++)
		{
d1971 2
a1972 1
		if (!dsa_doit[j]) continue;
d1975 4
a1978 5
		ret=DSA_sign(EVP_PKEY_DSA,buf,20,buf2,
			&kk,dsa_key[j]);
		if (ret == 0)
			{
			BIO_printf(bio_err,"DSA sign failure.  No DSA sign will be done.\n");
d1980 10
a1989 14
			rsa_count=1;
			}
		else
			{
			pkey_print_message("sign","dsa",
				dsa_c[j][0],dsa_bits[j],
				DSA_SECONDS);
			Time_F(START);
			for (count=0,run=1; COND(dsa_c[j][0]); count++)
				{
				ret=DSA_sign(EVP_PKEY_DSA,buf,20,buf2,
					&kk,dsa_key[j]);
				if (ret == 0)
					{
d1991 1
a1991 1
						"DSA sign failure\n");
d1993 1
a1993 1
					count=1;
a1994 1
					}
a1995 6
			d=Time_F(STOP);
			BIO_printf(bio_err,mr ? "+R3:%ld:%d:%.2f\n"
				   : "%ld %d bit DSA signs in %.2fs\n",
				   count,dsa_bits[j],d);
			dsa_results[j][0]=d/(double)count;
			rsa_count=count;
d1997 7
d2005 4
a2008 5
		ret=DSA_verify(EVP_PKEY_DSA,buf,20,buf2,
			kk,dsa_key[j]);
		if (ret <= 0)
			{
			BIO_printf(bio_err,"DSA verify failure.  No DSA verify will be done.\n");
d2011 9
a2019 13
			}
		else
			{
			pkey_print_message("verify","dsa",
				dsa_c[j][1],dsa_bits[j],
				DSA_SECONDS);
			Time_F(START);
			for (count=0,run=1; COND(dsa_c[j][1]); count++)
				{
				ret=DSA_verify(EVP_PKEY_DSA,buf,20,buf2,
					kk,dsa_key[j]);
				if (ret <= 0)
					{
d2021 1
a2021 1
						"DSA verify failure\n");
d2023 1
a2023 1
					count=1;
a2024 1
					}
a2025 5
			d=Time_F(STOP);
			BIO_printf(bio_err,mr ? "+R4:%ld:%d:%.2f\n"
				   : "%ld %d bit DSA verify in %.2fs\n",
				   count,dsa_bits[j],d);
			dsa_results[j][1]=d/(double)count;
d2027 6
d2034 1
a2034 2
		if (rsa_count <= 1)
			{
d2036 2
a2037 3
			for (j++; j<DSA_NUM; j++)
				dsa_doit[j]=0;
			}
d2039 3
a2041 1
	if (rnd_fake) RAND_cleanup();
d2045 1
a2045 2
	if (RAND_status() != 1) 
		{
d2048 2
a2049 3
		}
	for (j=0; j<EC_NUM; j++) 
		{
d2052 2
a2053 1
		if (!ecdsa_doit[j]) continue; /* Ignore Curve */ 
d2055 2
a2056 3
		if (ecdsa[j] == NULL) 
			{
			BIO_printf(bio_err,"ECDSA failure.\n");
d2058 2
a2059 4
			rsa_count=1;
			} 
		else 
			{
d2065 4
a2068 5
			ret = ECDSA_sign(0, buf, 20, ecdsasig, 
				&ecdsasiglen, ecdsa[j]);
			if (ret == 0) 
				{
				BIO_printf(bio_err,"ECDSA sign failure.  No ECDSA sign will be done.\n");
d2070 6
a2075 8
				rsa_count=1;
				} 
			else 
				{
				pkey_print_message("sign","ecdsa",
					ecdsa_c[j][0], 
					test_curves_bits[j],
					ECDSA_SECONDS);
d2078 6
a2083 8
				for (count=0,run=1; COND(ecdsa_c[j][0]);
					count++) 
					{
					ret=ECDSA_sign(0, buf, 20, 
						ecdsasig, &ecdsasiglen,
						ecdsa[j]);
					if (ret == 0) 
						{
d2086 1
a2086 1
						count=1;
a2087 1
						}
d2089 2
a2090 1
				d=Time_F(STOP);
d2093 5
a2097 5
					"%ld %d bit ECDSA signs in %.2fs \n", 
					count, test_curves_bits[j], d);
				ecdsa_results[j][0]=d/(double)count;
				rsa_count=count;
				}
d2100 4
a2103 5
			ret=ECDSA_verify(0, buf, 20, ecdsasig, 
				ecdsasiglen, ecdsa[j]);
			if (ret != 1) 
				{
				BIO_printf(bio_err,"ECDSA verify failure.  No ECDSA verify will be done.\n");
d2106 5
a2110 7
				} 
			else 
				{
				pkey_print_message("verify","ecdsa",
				ecdsa_c[j][1],
				test_curves_bits[j],
				ECDSA_SECONDS);
d2112 3
a2114 5
				for (count=0,run=1; COND(ecdsa_c[j][1]); count++) 
					{
					ret=ECDSA_verify(0, buf, 20, ecdsasig, ecdsasiglen, ecdsa[j]);
					if (ret != 1) 
						{
d2117 1
a2117 1
						count=1;
a2118 1
						}
a2119 5
				d=Time_F(STOP);
				BIO_printf(bio_err, mr? "+R6:%ld:%d:%.2f\n"
						: "%ld %d bit ECDSA verify in %.2fs\n",
				count, test_curves_bits[j], d);
				ecdsa_results[j][1]=d/(double)count;
d2121 6
d2128 1
a2128 2
			if (rsa_count <= 1) 
				{
d2130 2
a2131 3
				for (j++; j<EC_NUM; j++)
				ecdsa_doit[j]=0;
				}
d2134 3
a2136 1
	if (rnd_fake) RAND_cleanup();
d2140 1
a2140 2
	if (RAND_status() != 1)
		{
d2143 4
a2146 4
		}
	for (j=0; j<EC_NUM; j++)
		{
		if (!ecdh_doit[j]) continue;
d2149 2
a2150 3
		if ((ecdh_a[j] == NULL) || (ecdh_b[j] == NULL))
			{
			BIO_printf(bio_err,"ECDH failure.\n");
d2152 2
a2153 4
			rsa_count=1;
			}
		else
			{
d2156 2
a2157 3
				!EC_KEY_generate_key(ecdh_b[j]))
				{
				BIO_printf(bio_err,"ECDH key generation failure.\n");
d2159 7
a2165 6
				rsa_count=1;		
				}
			else
				{
				/* If field size is not more than 24 octets, then use SHA-1 hash of result;
				 * otherwise, use result (see section 4.8 of draft-ietf-tls-ecc-03.txt).
d2168 1
a2168 1
				void *(*kdf)(const void *in, size_t inlen, void *out, size_t *xoutlen);
d2170 1
a2170 2
				if (field_size <= 24 * 8)
					{
d2173 2
a2174 4
					}
				else
					{
					outlen = (field_size+7)/8;
d2176 1
a2176 1
					}
d2178 2
a2179 2
					EC_KEY_get0_public_key(ecdh_b[j]),
					ecdh_a[j], kdf);
d2181 3
a2183 3
					EC_KEY_get0_public_key(ecdh_a[j]),
					ecdh_b[j], kdf);
				if (secret_size_a != secret_size_b) 
d2188 1
a2188 1
				for (secret_idx = 0; 
d2190 2
a2191 3
					&& (ecdh_checks == 1);
				    secret_idx++)
					{
d2193 2
a2194 2
					ecdh_checks = 0;
					}
d2196 2
a2197 3
				if (ecdh_checks == 0)
					{
					BIO_printf(bio_err,"ECDH computations don't match.\n");
d2199 6
a2204 7
					rsa_count=1;		
					}

				pkey_print_message("","ecdh",
				ecdh_c[j][0], 
				test_curves_bits[j],
				ECDH_SECONDS);
d2206 1
a2206 2
				for (count=0,run=1; COND(ecdh_c[j][0]); count++)
					{
d2208 2
a2209 8
					EC_KEY_get0_public_key(ecdh_b[j]),
					ecdh_a[j], kdf);
					}
				d=Time_F(STOP);
				BIO_printf(bio_err, mr ? "+R7:%ld:%d:%.2f\n" :"%ld %d-bit ECDH ops in %.2fs\n",
				count, test_curves_bits[j], d);
				ecdh_results[j][0]=d/(double)count;
				rsa_count=count;
d2211 5
d2217 1
d2220 1
a2220 2
		if (rsa_count <= 1)
			{
d2222 2
a2223 3
			for (j++; j<EC_NUM; j++)
			ecdh_doit[j]=0;
			}
d2225 3
a2227 1
	if (rnd_fake) RAND_cleanup();
d2232 3
a2234 4
	if(!mr)
		{
		fprintf(stdout,"%s\n",SSLeay_version(SSLEAY_VERSION));
        fprintf(stdout,"%s\n",SSLeay_version(SSLEAY_BUILT_ON));
d2236 1
a2236 1
		printf("%s ",BN_options());
d2238 1
a2238 1
		printf("%s ",MD2_options());
d2241 1
a2241 1
		printf("%s ",RC4_options());
d2244 1
a2244 1
		printf("%s ",DES_options());
d2247 1
a2247 1
		printf("%s ",AES_options());
d2250 1
a2250 1
		printf("%s ",idea_options());
d2253 1
a2253 1
		printf("%s ",BF_options());
d2255 18
a2272 7
		fprintf(stdout,"\n%s\n",SSLeay_version(SSLEAY_CFLAGS));
		}

	if (pr_header)
		{
		if(mr)
			fprintf(stdout,"+H");
d2274 2
a2275 18
			{
			fprintf(stdout,"The 'numbers' are in 1000s of bytes per second processed.\n"); 
			fprintf(stdout,"type        ");
			}
		for (j=0;  j<SIZE_NUM; j++)
			fprintf(stdout,mr ? ":%d" : "%7d bytes",lengths[j]);
		fprintf(stdout,"\n");
		}

	for (k=0; k<ALGOR_NUM; k++)
		{
		if (!doit[k]) continue;
		if(mr)
			fprintf(stdout,"+F:%d:%s",k,names[k]);
		else
			fprintf(stdout,"%-13s",names[k]);
		for (j=0; j<SIZE_NUM; j++)
			{
d2277 1
a2277 1
				fprintf(stdout," %11.2fk",results[k][j]/1e3);
d2279 1
a2279 3
				fprintf(stdout,mr ? ":%.2f" : " %11.2f ",results[k][j]);
			}
		fprintf(stdout,"\n");
d2281 2
d2284 7
a2290 17
	j=1;
	for (k=0; k<RSA_NUM; k++)
		{
		if (!rsa_doit[k]) continue;
		if (j && !mr)
			{
			printf("%18ssign    verify    sign/s verify/s\n"," ");
			j=0;
			}
		if(mr)
			fprintf(stdout,"+F2:%u:%u:%f:%f\n",
				k,rsa_bits[k],rsa_results[k][0],
				rsa_results[k][1]);
		else
			fprintf(stdout,"rsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\n",
				rsa_bits[k],rsa_results[k][0],rsa_results[k][1],
				1.0/rsa_results[k][0],1.0/rsa_results[k][1]);
d2292 9
d2303 7
a2309 16
	j=1;
	for (k=0; k<DSA_NUM; k++)
		{
		if (!dsa_doit[k]) continue;
		if (j && !mr)
			{
			printf("%18ssign    verify    sign/s verify/s\n"," ");
			j=0;
			}
		if(mr)
			fprintf(stdout,"+F3:%u:%u:%f:%f\n",
				k,dsa_bits[k],dsa_results[k][0],dsa_results[k][1]);
		else
			fprintf(stdout,"dsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\n",
				dsa_bits[k],dsa_results[k][0],dsa_results[k][1],
				1.0/dsa_results[k][0],1.0/dsa_results[k][1]);
d2311 8
d2321 8
a2328 10
	j=1;
	for (k=0; k<EC_NUM; k++)
		{
		if (!ecdsa_doit[k]) continue;
		if (j && !mr)
			{
			printf("%30ssign    verify    sign/s verify/s\n"," ");
			j=0;
			}

d2330 3
a2332 3
			fprintf(stdout,"+F4:%u:%u:%f:%f\n", 
				k, test_curves_bits[k],
				ecdsa_results[k][0],ecdsa_results[k][1]);
d2335 6
a2340 6
				"%4u bit ecdsa (%s) %8.4fs %8.4fs %8.1f %8.1f\n", 
				test_curves_bits[k],
				test_curves_names[k],
				ecdsa_results[k][0],ecdsa_results[k][1], 
				1.0/ecdsa_results[k][0],1.0/ecdsa_results[k][1]);
		}
d2345 8
a2352 9
	j=1;
	for (k=0; k<EC_NUM; k++)
		{
		if (!ecdh_doit[k]) continue;
		if (j && !mr)
			{
			printf("%30sop      op/s\n"," ");
			j=0;
			}
d2354 3
a2356 3
			fprintf(stdout,"+F5:%u:%u:%f:%f\n",
				k, test_curves_bits[k],
				ecdh_results[k][0], 1.0/ecdh_results[k][0]);
d2359 5
a2363 5
			fprintf(stdout,"%4u bit ecdh (%s) %8.4fs %8.1f\n",
				test_curves_bits[k],
				test_curves_names[k],
				ecdh_results[k][0], 1.0/ecdh_results[k][0]);
		}
d2366 1
a2366 1
	mret=0;
d2370 4
a2373 2
	if (buf != NULL) free(buf);
	if (buf2 != NULL) free(buf2);
d2375 1
a2375 1
	for (i=0; i<RSA_NUM; i++)
d2380 1
a2380 1
	for (i=0; i<DSA_NUM; i++)
d2386 1
a2386 1
	for (i=0; i<EC_NUM; i++)
d2391 1
a2391 2
	for (i=0; i<EC_NUM; i++)
	{
d2400 2
a2401 2
	return(mret);
	}
d2403 3
a2405 2
static void print_message(const char *s, long num, int length)
	{
d2407 3
a2409 3
	BIO_printf(bio_err,mr ? "+DT:%s:%d:%d\n"
		   : "Doing %s for %ds on %d size blocks: ",s,SECONDS,length);
	(void)BIO_flush(bio_err);
d2412 3
a2414 3
	BIO_printf(bio_err,mr ? "+DN:%s:%ld:%d\n"
		   : "Doing %s %ld times on %d size blocks: ",s,num,length);
	(void)BIO_flush(bio_err);
d2417 1
a2417 1
	num=num;
d2419 1
a2419 1
	}
d2421 4
a2424 3
static void pkey_print_message(const char *str, const char *str2, long num,
	int bits, int tm)
	{
d2426 3
a2428 3
	BIO_printf(bio_err,mr ? "+DTP:%d:%s:%s:%d\n"
			   : "Doing %d bit %s %s's for %ds: ",bits,str,str2,tm);
	(void)BIO_flush(bio_err);
d2431 3
a2433 3
	BIO_printf(bio_err,mr ? "+DNP:%ld:%d:%s:%s\n"
			   : "Doing %ld %d bit %s %s's: ",num,bits,str,str2);
	(void)BIO_flush(bio_err);
d2436 1
a2436 1
	num=num;
d2438 26
d2466 2
a2467 5
static void print_result(int alg,int run_no,int count,double time_used)
	{
	BIO_printf(bio_err,mr ? "+R:%d:%s:%f\n"
		   : "%d %s's in %.2fs\n",count,names[alg],time_used);
	results[alg][run_no]=((double)count)/time_used*lengths[run_no];
d2470 6
a2475 28
#ifndef NO_FORK
static char *sstrsep(char **string, const char *delim)
    {
    char isdelim[256];
    char *token = *string;

    if (**string == 0)
        return NULL;

    memset(isdelim, 0, sizeof isdelim);
    isdelim[0] = 1;

    while (*delim)
        {
        isdelim[(unsigned char)(*delim)] = 1;
        delim++;
        }

    while (!isdelim[(unsigned char)(**string)])
        {
        (*string)++;
        }

    if (**string)
        {
        **string = 0;
        (*string)++;
        }
d2477 3
a2479 5
    return token;
    }

static int do_multi(int multi)
	{
d2483 1
a2483 1
	static char sep[]=":";
d2485 3
a2487 5
	fds=malloc(multi*sizeof *fds);
	for(n=0 ; n < multi ; ++n)
		{
		if (pipe(fd) == -1)
			{
d2490 1
a2490 1
			}
d2493 1
a2493 2
		if(fork())
			{
d2495 2
a2496 4
			fds[n]=fd[0];
			}
		else
			{
d2499 1
a2499 2
			if (dup(fd[1]) == -1)
				{
d2502 1
a2502 1
				}
d2504 2
a2505 2
			mr=1;
			usertime=0;
a2507 2
			}
		printf("Forked child %d\n",n);
d2509 2
d2513 1
a2513 2
	for(n=0 ; n < multi ; ++n)
		{
d2518 8
a2525 10
		f=fdopen(fds[n],"r");
		while(fgets(buf,sizeof buf,f))
			{
			p=strchr(buf,'\n');
			if(p)
				*p='\0';
			if(buf[0] != '+')
				{
				fprintf(stderr,"Don't understand line '%s' from child %d\n",
						buf,n);
d2527 3
a2529 4
				}
			printf("Got: %s from %d\n",buf,n);
			if(!strncmp(buf,"+F:",3))
				{
d2533 6
a2538 8
				p=buf+3;
				alg=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);
				for(j=0 ; j < SIZE_NUM ; ++j)
					results[alg][j]+=atof(sstrsep(&p,sep));
				}
			else if(!strncmp(buf,"+F2:",4))
				{
d2541 8
a2548 8
				
				p=buf+4;
				k=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);

				d=atof(sstrsep(&p,sep));
				if(n)
					rsa_results[k][0]=1/(1/rsa_results[k][0]+1/d);
d2550 1
a2550 1
					rsa_results[k][0]=d;
d2552 3
a2554 3
				d=atof(sstrsep(&p,sep));
				if(n)
					rsa_results[k][1]=1/(1/rsa_results[k][1]+1/d);
d2556 2
a2557 4
					rsa_results[k][1]=d;
				}
			else if(!strncmp(buf,"+F2:",4))
				{
d2560 8
a2567 8
				
				p=buf+4;
				k=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);

				d=atof(sstrsep(&p,sep));
				if(n)
					rsa_results[k][0]=1/(1/rsa_results[k][0]+1/d);
d2569 1
a2569 1
					rsa_results[k][0]=d;
d2571 3
a2573 3
				d=atof(sstrsep(&p,sep));
				if(n)
					rsa_results[k][1]=1/(1/rsa_results[k][1]+1/d);
d2575 2
a2576 2
					rsa_results[k][1]=d;
				}
d2578 1
a2578 2
			else if(!strncmp(buf,"+F3:",4))
				{
d2581 8
a2588 8
				
				p=buf+4;
				k=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);

				d=atof(sstrsep(&p,sep));
				if(n)
					dsa_results[k][0]=1/(1/dsa_results[k][0]+1/d);
d2590 1
a2590 1
					dsa_results[k][0]=d;
d2592 3
a2594 3
				d=atof(sstrsep(&p,sep));
				if(n)
					dsa_results[k][1]=1/(1/dsa_results[k][1]+1/d);
d2596 2
a2597 2
					dsa_results[k][1]=d;
				}
d2600 1
a2600 2
			else if(!strncmp(buf,"+F4:",4))
				{
d2603 8
a2610 8
				
				p=buf+4;
				k=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);

				d=atof(sstrsep(&p,sep));
				if(n)
					ecdsa_results[k][0]=1/(1/ecdsa_results[k][0]+1/d);
d2612 1
a2612 1
					ecdsa_results[k][0]=d;
d2614 3
a2616 3
				d=atof(sstrsep(&p,sep));
				if(n)
					ecdsa_results[k][1]=1/(1/ecdsa_results[k][1]+1/d);
d2618 3
a2620 3
					ecdsa_results[k][1]=d;
				}
#endif 
d2623 1
a2623 2
			else if(!strncmp(buf,"+F5:",4))
				{
d2626 8
a2633 8
				
				p=buf+4;
				k=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);

				d=atof(sstrsep(&p,sep));
				if(n)
					ecdh_results[k][0]=1/(1/ecdh_results[k][0]+1/d);
d2635 1
a2635 1
					ecdh_results[k][0]=d;
d2637 1
a2637 1
				}
d2640 4
a2643 6
			else if(!strncmp(buf,"+H:",3))
				{
				}
			else
				fprintf(stderr,"Unknown type '%s' from child %d\n",buf,n);
			}
d2646 1
a2646 1
		}
d2649 1
a2649 1
	}
@


1.29
log
@oops, exit vs return; spotted by matthew
@
text
@a189 17
#ifdef OPENSSL_FIPS
#ifdef OPENSSL_DOING_MAKEDEPEND
#undef AES_set_encrypt_key
#undef AES_set_decrypt_key
#undef DES_set_key_unchecked
#endif
#define BF_set_key	private_BF_set_key
#define CAST_set_key	private_CAST_set_key
#define idea_set_encrypt_key	private_idea_set_encrypt_key
#define SEED_set_key	private_SEED_set_key
#define RC2_set_key	private_RC2_set_key
#define RC4_set_key	private_RC4_set_key
#define DES_set_key_unchecked	private_DES_set_key_unchecked
#define AES_set_encrypt_key	private_AES_set_encrypt_key
#define AES_set_decrypt_key	private_AES_set_decrypt_key
#define Camellia_set_key	private_Camellia_set_key
#endif
@


1.28
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d2525 1
a2525 1
	exit(mret);
@


1.27
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d2525 1
a2525 1
	OPENSSL_EXIT(mret);
@


1.26
log
@unistd.h is always in the same place; no need to #include the result of
a maze of conditional #define's
@
text
@d621 1
a621 1
	if ((buf=(unsigned char *)OPENSSL_malloc((int)BUFSIZE)) == NULL)
d626 1
a626 1
	if ((buf2=(unsigned char *)OPENSSL_malloc((int)BUFSIZE)) == NULL)
d2496 2
a2497 2
	if (buf != NULL) OPENSSL_free(buf);
	if (buf2 != NULL) OPENSSL_free(buf2);
@


1.25
log
@lots of ifdef cleanup
@
text
@d103 1
a103 1
#include OPENSSL_UNISTD
@


1.24
log
@first round of unifdef hammering
@
text
@a290 16
#if defined(_WIN32)

#if !defined(SIGALRM)
# define SIGALRM
#endif
static unsigned int lapse,schlock;
static void alarm_win32(unsigned int secs) { lapse = secs*1000; }
#define alarm alarm_win32

static DWORD WINAPI sleepy(VOID *arg)
	{
	schlock = 1;
	Sleep(lapse);
	run = 0;
	return 0;
	}
a293 15
	if (s == START)
		{
		HANDLE	thr;
		schlock = 0;
		thr = CreateThread(NULL,4096,sleepy,NULL,0,NULL);
		if (thr==NULL)
			{
			DWORD ret=GetLastError();
			BIO_printf(bio_err,"unable to CreateThread (%d)",ret);
			ExitProcess(ret);
			}
		CloseHandle(thr);		/* detach the thread	*/
		while (!schlock) Sleep(0);	/* scheduler spinlock	*/
		}

a295 7
#else

static double Time_F(int s)
	{
	return app_tminterval(s,usertime);
	}
#endif
a1450 1
#ifndef _WIN32
a1451 1
#endif
@


1.23
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@a102 1
#if !defined(OPENSSL_SYS_MSDOS)
a103 1
#endif
a104 1
#ifndef OPENSSL_SYS_NETWARE
a105 1
#endif
@


1.22
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a212 3
# if defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MACINTOSH_CLASSIC) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_NETWARE)
#  define HAVE_FORK 0
# else
a213 1
# endif
@


1.21
log
@resolve conflicts
@
text
@d257 1
a257 1
  "aes-128 ige","aes-192 ige","aes-256 ige","ghash"};
d302 1
a302 1
#define SIGALRM
@


1.20
log
@openssl-1.0.0e: resolve conflicts
@
text
@d111 1
a111 1
#ifdef _WIN32
d113 6
d192 19
d242 1
a242 1
#define ALGOR_NUM	29
d257 1
a257 1
  "aes-128 ige","aes-192 ige","aes-256 ige"};
d301 1
d303 1
d305 2
a306 1
static void alarm(unsigned int secs) { lapse = secs*1000; }
d500 1
d926 4
d1300 1
d1495 1
a1495 1
#define COND(c)	(run)
d1791 4
d1796 11
d2600 1
a2600 1
	alarm(RSA_SECONDS);
d2660 5
a2664 1
		pipe(fd);
d2676 5
a2680 1
			dup(fd[1]);
@


1.19
log
@resolve conflicts, fix local changes
@
text
@a336 3
#ifndef OPENSSL_NO_ENGINE
	ENGINE *e = NULL;
#endif
a429 1
	DES_cblock *buf_as_des_cblock = NULL;
a642 3
#ifndef OPENSSL_NO_DES
	buf_as_des_cblock = (DES_cblock *)buf;
#endif
d717 1
a717 1
                        e = setup_engine(bio_err, *argv, 0);
d1233 2
a1234 1
			DES_ecb_encrypt(buf_as_des_cblock,buf_as_des_cblock,
d2706 1
d2728 1
@


1.18
log
@plug a memory leak; found by parfait, ok djm
@
text
@d111 2
a112 47
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(OPENSSL_SYS_MACOSX)
# define USE_TOD
#elif !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VXWORKS) && (!defined(OPENSSL_SYS_VMS) || defined(__DECC))
# define TIMES
#endif
#if !defined(_UNICOS) && !defined(__OpenBSD__) && !defined(sgi) && !defined(__FreeBSD__) && !(defined(__bsdi) || defined(__bsdi__)) && !defined(_AIX) && !defined(OPENSSL_SYS_MPE) && !defined(__NetBSD__) && !defined(OPENSSL_SYS_VXWORKS) /* FIXME */
# define TIMEB
#endif

#if defined(OPENSSL_SYS_NETWARE)
#undef TIMES
#undef TIMEB
#include <time.h>
#endif

#ifndef _IRIX
# include <time.h>
#endif
#ifdef TIMES
# include <sys/types.h>
# include <sys/times.h>
#endif
#ifdef USE_TOD
# include <sys/time.h>
# include <sys/resource.h>
#endif

/* Depending on the VMS version, the tms structure is perhaps defined.
   The __TMS macro will show if it was.  If it wasn't defined, we should
   undefine TIMES, since that tells the rest of the program how things
   should be handled.				-- Richard Levitte */
#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__TMS)
#undef TIMES
#endif

#ifdef TIMEB
#include <sys/timeb.h>
#endif

#if !defined(TIMES) && !defined(TIMEB) && !defined(USE_TOD) && !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_NETWARE)
#error "It seems neither struct tms nor struct timeb is supported in this platform!"
#endif

#if defined(sun) || defined(__ultrix)
#define _POSIX_SOURCE
#include <limits.h>
#include <sys/param.h>
d147 3
d187 3
a189 15
/*
 * The following "HZ" timing stuff should be sync'd up with the code in
 * crypto/tmdiff.[ch]. That appears to try to do the same job, though I think
 * this code is more up to date than libcrypto's so there may be features to
 * migrate over first. This is used in two places further down AFAICS. 
 * The point is that nothing in openssl actually *uses* that tmdiff stuff, so
 * either speed.c should be using it or it should go because it's obviously not
 * useful enough. Anyone want to do a janitorial job on this?
 */

/* The following if from times(3) man page.  It may need to be changed */
#ifndef HZ
# if defined(_SC_CLK_TCK) \
     && (!defined(OPENSSL_SYS_VMS) || __CTRL_VER >= 70000000)
#  define HZ sysconf(_SC_CLK_TCK)
d191 1
a191 9
#  ifndef CLK_TCK
#   ifndef _BSD_CLK_TCK_ /* FreeBSD hack */
#    define HZ	100.0
#   else /* _BSD_CLK_TCK_ */
#    define HZ ((double)_BSD_CLK_TCK_)
#   endif
#  else /* CLK_TCK */
#   define HZ ((double)CLK_TCK)
#  endif
d195 4
a198 2
#if !defined(OPENSSL_SYS_VMS) && !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MACINTOSH_CLASSIC) && !defined(OPENSSL_SYS_OS2) && !defined(OPENSSL_SYS_NETWARE)
# define HAVE_FORK 1
a204 1
static char ftime_used = 0, times_used = 0, gettimeofday_used = 0, getrusage_used = 0;
d213 1
a213 1
#ifdef HAVE_FORK
d217 1
a217 1
#define ALGOR_NUM	28
d231 1
a231 1
  "evp","sha256","sha512",
d235 1
d237 2
d240 1
d274 5
a278 1
#if defined(OPENSSL_SYS_NETWARE)
d280 1
a280 4
   /* for NetWare the best we can do is use clock() which returns the
    * time, in hundredths of a second, since the NLM began executing
   */
static double Time_F(int s)
d282 5
a286 18
	double ret;

   static clock_t tstart,tend;

   if (s == START)
   {
      tstart=clock();
      return(0);
   }
   else
   {
      tend=clock();
      ret=(double)((double)(tend)-(double)(tstart));
      return((ret < 0.001)?0.001:ret);
   }
   }

#else
d290 1
a290 4
	double ret;

#ifdef USE_TOD
	if(usertime)
d292 4
a295 4
		static struct rusage tstart,tend;

		getrusage_used = 1;
		if (s == START)
d297 3
a299 12
			getrusage(RUSAGE_SELF,&tstart);
			return(0);
			}
		else
			{
			long i;

			getrusage(RUSAGE_SELF,&tend);
			i=(long)tend.ru_utime.tv_usec-(long)tstart.ru_utime.tv_usec;
			ret=((double)(tend.ru_utime.tv_sec-tstart.ru_utime.tv_sec))
			  +((double)i)/1000000.0;
			return((ret < 0.001)?0.001:ret);
d301 2
a303 4
	else
		{
		static struct timeval tstart,tend;
		long i;
d305 3
a307 20
		gettimeofday_used = 1;
		if (s == START)
			{
			gettimeofday(&tstart,NULL);
			return(0);
			}
		else
			{
			gettimeofday(&tend,NULL);
			i=(long)tend.tv_usec-(long)tstart.tv_usec;
			ret=((double)(tend.tv_sec-tstart.tv_sec))+((double)i)/1000000.0;
			return((ret < 0.001)?0.001:ret);
			}
		}
#else  /* ndef USE_TOD */
		
# ifdef TIMES
	if (usertime)
		{
		static struct tms tstart,tend;
d309 4
a312 54
		times_used = 1;
		if (s == START)
			{
			times(&tstart);
			return(0);
			}
		else
			{
			times(&tend);
			ret = HZ;
			ret=(double)(tend.tms_utime-tstart.tms_utime) / ret;
			return((ret < 1e-3)?1e-3:ret);
			}
		}
# endif /* times() */
# if defined(TIMES) && defined(TIMEB)
	else
# endif
# ifdef OPENSSL_SYS_VXWORKS
                {
		static unsigned long tick_start, tick_end;

		if( s == START )
			{
			tick_start = tickGet();
			return 0;
			}
		else
			{
			tick_end = tickGet();
			ret = (double)(tick_end - tick_start) / (double)sysClkRateGet();
			return((ret < 0.001)?0.001:ret);
			}
                }
# elif defined(TIMEB)
		{
		static struct timeb tstart,tend;
		long i;

		ftime_used = 1;
		if (s == START)
			{
			ftime(&tstart);
			return(0);
			}
		else
			{
			ftime(&tend);
			i=(long)tend.millitm-(long)tstart.millitm;
			ret=((double)(tend.time-tstart.time))+((double)i)/1000.0;
			return((ret < 0.001)?0.001:ret);
			}
		}
# endif
a313 2
	}
#endif /* if defined(OPENSSL_SYS_NETWARE) */
d373 3
d472 4
a475 3
#define D_IGE_128_AES   25
#define D_IGE_192_AES   26
#define D_IGE_256_AES   27
d604 1
a604 1
#ifdef HAVE_FORK
d732 1
a732 1
#ifdef HAVE_FORK
d795 4
d1010 3
d1018 2
a1019 1
    !defined(OPENSSL_NO_SHA1) || !defined(OPENSSL_NO_RIPEMD160)
d1120 1
a1120 1
#ifdef HAVE_FORK
d1130 1
a1130 1
#ifdef HAVE_FORK
d1146 8
a1159 5
	if (usertime <= 0 && !mr)
		{
		BIO_printf(bio_err,"To get the most accurate results, try to run this\n");
		BIO_printf(bio_err,"program when this computer is idle.\n");
		}
d1269 1
d1285 1
d1469 1
d1471 1
d1601 1
d1603 13
d1617 1
d1763 2
d2349 1
a2349 1
#ifdef HAVE_FORK
a2376 29
		printf("available timing options: ");
#ifdef TIMES
		printf("TIMES ");
#endif
#ifdef TIMEB
		printf("TIMEB ");
#endif
#ifdef USE_TOD
		printf("USE_TOD ");
#endif
#ifdef HZ
#define as_string(s) (#s)
		{
		double dbl = HZ;
		printf("HZ=%g", dbl);
		}
# ifdef _SC_CLK_TCK
		printf(" [sysconf value]");
# endif
#endif
		printf("\n");
		printf("timing function used: %s%s%s%s%s%s%s\n",
		       (ftime_used ? "ftime" : ""),
		       (ftime_used + times_used > 1 ? "," : ""),
		       (times_used ? "times" : ""),
		       (ftime_used + times_used + gettimeofday_used > 1 ? "," : ""),
		       (gettimeofday_used ? "gettimeofday" : ""),
		       (ftime_used + times_used + gettimeofday_used + getrusage_used > 1 ? "," : ""),
		       (getrusage_used ? "getrusage" : ""));
d2575 1
a2575 1
#ifdef HAVE_FORK
d2782 2
@


1.17
log
@resolve conflicts
@
text
@d2778 1
d2928 1
@


1.16
log
@resolve conflicts
@
text
@d2135 1
a2135 1
				if (ret == 0)
d2763 2
@


1.15
log
@resolve conflicts
@
text
@d58 13
d80 2
d91 1
a91 1
#include <signal.h>
d107 4
d120 6
d150 1
a150 1
#if !defined(TIMES) && !defined(TIMEB) && !defined(USE_TOD) && !defined(OPENSSL_SYS_VXWORKS)
d160 1
d167 3
d204 3
d219 1
d222 16
d243 1
a243 1
#  define HZ ((double)sysconf(_SC_CLK_TCK))
d257 1
a257 1
#if !defined(OPENSSL_SYS_VMS) && !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MACINTOSH_CLASSIC) && !defined(OPENSSL_SYS_OS2)
d271 2
a272 1
static void pkey_print_message(char *str,char *str2,long num,int bits,int sec);
d278 1
a278 1
#define ALGOR_NUM	19
d282 4
d288 1
a288 1
  "des cbc","des ede3","idea cbc",
d290 4
a293 1
  "aes-128 cbc","aes-192 cbc","aes-256 cbc"};
d298 11
d331 26
d363 1
a363 1
	    {
d418 2
a419 1
			ret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;
d465 19
d518 6
d540 3
d552 1
d562 12
d580 1
a580 1
	unsigned char iv[MAX_BLOCK_SIZE/8];
d593 3
d607 17
a623 8
#define	D_CBC_RC2	11
#define	D_CBC_RC5	12
#define	D_CBC_BF	13
#define	D_CBC_CAST	14
#define D_CBC_128_AES	15
#define D_CBC_192_AES	16
#define D_CBC_256_AES	17
#define D_EVP		18
d633 18
d666 73
d741 6
d765 11
d814 9
d930 6
a935 1
			if (strcmp(*argv,"sha") == 0) doit[D_SHA1]=1;
d938 5
d964 9
d1016 5
d1050 9
d1078 48
d1148 6
d1166 3
d1178 1
a1178 1
#if !defined(OPENSSL_NO_IDEA) || !defined(OPENSSL_NO_RC2) || \
d1187 5
d1205 12
d1221 3
d1233 3
d1242 4
a1245 3
#if !defined(OPENSSL_NO_IDEA) || !defined(OPENSSL_NO_RC2) || \
    !defined(OPENSSL_NO_DES) || !defined(OPENSSL_NO_RSA) || \
    !defined(OPENSSL_NO_BF) || !defined(OPENSSL_NO_AES)
d1339 5
d1347 3
d1373 1
a1373 1
		long i;
d1376 1
a1376 1
		for (i=count; i; i--)
d1393 1
d1401 8
d1419 2
d1432 1
d1440 6
d1487 108
d1704 31
d1839 87
d1943 15
d2254 211
d2505 4
a2508 1
		printf("HZ=%g", (double)HZ);
d2593 49
d2643 1
d2658 16
d2695 2
a2696 2
static void pkey_print_message(char *str, char *str2, long num, int bits,
	     int tm)
d2715 2
a2716 2
	BIO_printf(bio_err,mr ? "+R:%ld:%s:%f\n"
		   : "%ld %s's in %.2fs\n",count,names[alg],time_used);
d2720 1
a2751 1
#ifdef HAVE_FORK
d2875 43
@


1.15.8.1
log
@Fix CVE-2008-5077: Incorrect checks for malformed signatures
@
text
@d1489 1
a1489 1
				if (ret <= 0)
@


1.15.10.1
log
@Fix CVE-2008-5077: Incorrect checks for malformed signatures
@
text
@d1489 1
a1489 1
				if (ret <= 0)
@


1.14
log
@resolve conflicts
@
text
@d1709 1
a1709 1
			fprintf(stdout,"rsa %4u bits %8.4fs %8.4fs %8.1f %8.1f\n",
d1728 1
a1728 1
			fprintf(stdout,"dsa %4u bits %8.4fs %8.4fs %8.1f %8.1f\n",
@


1.13
log
@merge 0.9.7d
@
text
@d1398 1
@


1.12
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d776 1
d1010 3
d1038 3
@


1.11
log
@add -elapsed to usage() for USE_TOD, too
@
text
@d61 2
d192 2
a193 1
# ifdef _SC_CLK_TCK
d375 1
d377 1
d597 1
d614 1
d874 1
d876 1
d1404 1
d1741 1
a1741 1
	EXIT(mret);
d1794 1
a1794 1
    memset(isdelim, 0, 256);
d1950 1
@


1.10
log
@merge with 0.9.7-beta1
@
text
@d864 1
a864 1
#ifdef TIMES
@


1.9
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d1630 1
a1630 1
		printf("HZ=%g", HZ);
@


1.8
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d375 1
a375 1
	long count=0,save_count=0, rsa_count;
d377 3
@


1.7
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d1 1
a1 1
/* apps/speed.c */
d78 1
a78 1
#ifdef NO_STDIO
d84 5
a88 1
#include <openssl/engine.h>
d90 1
a90 1
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
d92 1
a92 1
#elif !defined(MSDOS) && (!defined(VMS) || defined(__DECC))
d95 1
a95 1
#if !defined(_UNICOS) && !defined(__OpenBSD__) && !defined(sgi) && !defined(__FreeBSD__) && !(defined(__bsdi) || defined(__bsdi__)) && !defined(_AIX) && !defined(MPE) && !defined(__NetBSD__)
d115 1
a115 1
#if defined(VMS) && defined(__DECC) && !defined(__TMS)
d123 1
a123 1
#if !defined(TIMES) && !defined(TIMEB) && !defined(USE_TOD)
d133 1
a133 1
#ifndef NO_DES
d136 4
a139 1
#ifndef NO_MD2
d142 1
a142 1
#ifndef NO_MDC2
d145 1
a145 1
#ifndef NO_MD4
d148 1
a148 1
#ifndef NO_MD5
d151 1
a151 1
#ifndef NO_HMAC
d155 1
a155 1
#ifndef NO_SHA
d158 1
a158 1
#ifndef NO_RIPEMD
d161 1
a161 1
#ifndef NO_RC4
d164 1
a164 1
#ifndef NO_RC5
d167 1
a167 1
#ifndef NO_RC2
d170 1
a170 1
#ifndef NO_IDEA
d173 1
a173 1
#ifndef NO_BF
d176 1
a176 1
#ifndef NO_CAST
d179 1
a179 1
#ifndef NO_RSA
d184 1
a184 1
#ifndef NO_DSA
d190 11
a200 5
# ifndef CLK_TCK
#  ifndef _BSD_CLK_TCK_ /* FreeBSD hack */
#   define HZ	100.0
#  else /* _BSD_CLK_TCK_ */
#   define HZ ((double)_BSD_CLK_TCK_)
a201 2
# else /* CLK_TCK */
#  define HZ ((double)CLK_TCK)
d205 4
d213 6
a218 2
static double Time_F(int s, int usertime);
static void print_message(char *s,long num,int length);
d220 19
d260 1
a260 1
static double Time_F(int s, int usertime)
d269 1
d291 1
d312 1
d329 17
a345 1
# ifdef TIMEB
d350 1
d372 1
a372 1
	ENGINE *e;
d375 1
a375 5
#define ALGOR_NUM	15
#define SIZE_NUM	5
#define RSA_NUM		4
#define DSA_NUM		3
	long count,rsa_count;
d377 1
d379 3
a381 1
#ifndef NO_MD2
d384 1
a384 1
#ifndef NO_MDC2
d387 1
a387 1
#ifndef NO_MD4
d390 1
a390 1
#ifndef NO_MD5
d394 1
a394 1
#ifndef NO_SHA
d397 1
a397 1
#ifndef NO_RIPEMD
d400 1
a400 1
#ifndef NO_RC4
d403 1
a403 1
#ifndef NO_RC5
d406 1
a406 1
#ifndef NO_RC2
d409 1
a409 1
#ifndef NO_IDEA
d412 1
a412 1
#ifndef NO_BF
d415 1
a415 1
#ifndef NO_CAST
d418 1
a418 1
	static unsigned char key16[16]=
d421 27
a447 7
	unsigned char iv[8];
#ifndef NO_DES
	des_cblock *buf_as_des_cblock = NULL;
	static des_cblock key ={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};
	static des_cblock key2={0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12};
	static des_cblock key3={0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};
	des_key_schedule sch,sch2,sch3;
d464 5
a468 2
	double d,results[ALGOR_NUM][SIZE_NUM];
	static int lengths[SIZE_NUM]={8,64,256,1024,8*1024};
a469 4
	static char *names[ALGOR_NUM]={
		"md2","mdc2","md4","md5","hmac(md5)","sha1","rmd160","rc4",
		"des cbc","des ede3","idea cbc",
		"rc2 cbc","rc5-32/12 cbc","blowfish cbc","cast cbc"};
d477 1
a477 1
#ifndef NO_RSA
a479 1
	double rsa_results[RSA_NUM][2];
d487 1
a487 1
#ifndef NO_DSA
a489 1
	double dsa_results[DSA_NUM][2];
d496 6
a501 1
	int usertime=1;
d509 1
a509 1
#ifndef NO_DSA
d517 4
a520 1
#ifndef NO_RSA
d531 2
a532 2
#ifndef NO_DES
	buf_as_des_cblock = (des_cblock *)buf;
d541 1
d557 1
d559 4
a562 2
		else
		if	((argc > 0) && (strcmp(*argv,"-engine") == 0))
d568 1
a568 1
				BIO_printf(bio_err,"no engine given\n");
d571 2
a572 1
			if((e = ENGINE_by_id(*argv)) == NULL)
d574 5
a578 2
				BIO_printf(bio_err,"invalid engine \"%s\"\n",
					*argv);
d581 13
a593 1
			if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
d595 1
a595 1
				BIO_printf(bio_err,"can't use that engine\n");
d598 2
a599 4
			BIO_printf(bio_err,"engine \"%s\" set.\n", *argv);
			/* Free our "structural" reference. */
			ENGINE_free(e);
			/* It will be increased again further down.  We just
d605 26
d632 1
a632 1
#ifndef NO_MD2
d636 1
a636 1
#ifndef NO_MDC2
d640 1
a640 1
#ifndef NO_MD4
d644 1
a644 1
#ifndef NO_MD5
d648 1
a648 1
#ifndef NO_MD5
d652 1
a652 1
#ifndef NO_SHA
d658 1
a658 1
#ifndef NO_RIPEMD
d666 1
a666 1
#ifndef NO_RC4
d670 1
a670 1
#ifndef NO_DES
d675 8
a682 2
#ifndef NO_RSA
#ifdef RSAref
d693 1
a693 1
			RSA_set_default_openssl_method(RSA_PKCS1_SSLeay());
d698 1
a698 1
#endif /* !NO_RSA */
d707 1
a707 1
#ifndef NO_RC2
d712 1
a712 1
#ifndef NO_RC5
d717 1
a717 1
#ifndef NO_IDEA
d722 1
a722 1
#ifndef NO_BF
d728 1
a728 1
#ifndef NO_CAST
d734 1
a734 1
#ifndef NO_DES
d742 10
a751 1
#ifndef NO_RSA
d761 1
a761 1
#ifndef NO_DSA
d773 1
a773 1
#ifndef NO_MD2
d776 1
a776 1
#ifndef NO_MDC2
d779 1
a779 1
#ifndef NO_MD4
d782 1
a782 1
#ifndef NO_MD5
d784 1
a784 1
#ifndef NO_HMAC
d788 1
a788 1
#ifndef NO_SHA1
d791 1
a791 1
#ifndef NO_RIPEMD160
d794 3
a796 1
#if !defined(NO_MD2) || !defined(NO_MDC2) || !defined(NO_MD4) || !defined(NO_MD5) || !defined(NO_SHA1) || !defined(NO_RIPEMD160)
d800 1
a800 1
#ifndef NO_IDEA
d803 1
a803 1
#ifndef NO_RC2
d806 1
a806 1
#ifndef NO_RC5
d809 1
a809 1
#ifndef NO_BF
d812 2
a813 1
#if !defined(NO_IDEA) || !defined(NO_RC2) || !defined(NO_BF) || !defined(NO_RC5)
d816 1
a816 1

d818 5
a822 1
#ifndef NO_RC4
d827 1
a827 1
#ifndef NO_RSA
d831 1
a831 1
#ifndef NO_DSA
d835 1
a835 1
#ifndef NO_IDEA
d838 1
a838 1
#ifndef NO_RC2
d841 1
a841 1
#ifndef NO_DES
d844 4
a847 1
#ifndef NO_RSA
d850 1
a850 1
#ifndef NO_BF
d853 3
a855 1
#if !defined(NO_IDEA) || !defined(NO_RC2) || !defined(NO_DES) || !defined(NO_RSA) || !defined(NO_BF)
d865 6
d878 5
d886 4
a889 1
			doit[i]=1;
d898 1
a898 1
	if (usertime == 0)
d900 1
a900 1
	if (usertime <= 0)
d906 1
a906 1
#ifndef NO_RSA
d909 1
a909 1
		unsigned char *p;
d921 3
a923 1
			BIO_printf(bio_err,"Loaded RSA key, %d bit modulus and e= 0x",BN_num_bits(rsa_key[i]->n));
d931 1
a931 1
#ifndef NO_DSA
d937 9
a945 4
#ifndef NO_DES
	des_set_key_unchecked(&key,sch);
	des_set_key_unchecked(&key2,sch2);
	des_set_key_unchecked(&key3,sch3);
d947 1
a947 1
#ifndef NO_IDEA
d950 1
a950 1
#ifndef NO_RC4
d953 1
a953 1
#ifndef NO_RC2
d956 1
a956 1
#ifndef NO_RC5
d959 1
a959 1
#ifndef NO_BF
d962 1
a962 1
#ifndef NO_CAST
d965 1
a965 1
#ifndef NO_RSA
d969 1
a969 1
#ifndef NO_DES
d975 1
a975 1
		Time_F(START,usertime);
d977 3
a979 3
			des_ecb_encrypt(buf_as_des_cblock,buf_as_des_cblock,
				&(sch[0]),DES_ENCRYPT);
		d=Time_F(STOP,usertime);
d981 1
d1023 1
a1023 1
#ifndef NO_RSA
d1043 1
a1043 1
#ifndef NO_DSA
d1068 1
a1068 1
#endif /* NO_DES */
d1075 1
a1075 1
#ifndef NO_MD2
d1081 1
a1081 1
			Time_F(START,usertime);
d1083 3
a1085 5
				MD2(buf,(unsigned long)lengths[j],&(md2[0]));
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_MD2],d);
			results[D_MD2][j]=((double)count)/d*lengths[j];
d1089 1
a1089 1
#ifndef NO_MDC2
d1095 1
a1095 1
			Time_F(START,usertime);
d1097 3
a1099 5
				MDC2(buf,(unsigned long)lengths[j],&(mdc2[0]));
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_MDC2],d);
			results[D_MDC2][j]=((double)count)/d*lengths[j];
d1104 1
a1104 1
#ifndef NO_MD4
d1110 1
a1110 1
			Time_F(START,usertime);
d1112 3
a1114 5
				MD4(&(buf[0]),(unsigned long)lengths[j],&(md4[0]));
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_MD4],d);
			results[D_MD4][j]=((double)count)/d*lengths[j];
d1119 1
a1119 1
#ifndef NO_MD5
d1125 1
a1125 1
			Time_F(START,usertime);
d1127 3
a1129 5
				MD5(&(buf[0]),(unsigned long)lengths[j],&(md5[0]));
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_MD5],d);
			results[D_MD5][j]=((double)count)/d*lengths[j];
d1134 1
a1134 1
#if !defined(NO_MD5) && !defined(NO_HMAC)
d1138 4
a1141 2
		HMAC_Init(&hctx,(unsigned char *)"This is a key...",
			16,EVP_md5());
d1146 1
a1146 1
			Time_F(START,usertime);
d1149 3
a1151 3
				HMAC_Init(&hctx,NULL,0,NULL);
                                HMAC_Update(&hctx,buf,lengths[j]);
                                HMAC_Final(&hctx,&(hmac[0]),NULL);
d1153 2
a1154 4
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_HMAC],d);
			results[D_HMAC][j]=((double)count)/d*lengths[j];
d1156 1
d1159 1
a1159 1
#ifndef NO_SHA
d1165 1
a1165 1
			Time_F(START,usertime);
d1167 3
a1169 5
				SHA1(buf,(unsigned long)lengths[j],&(sha[0]));
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_SHA1],d);
			results[D_SHA1][j]=((double)count)/d*lengths[j];
d1173 1
a1173 1
#ifndef NO_RIPEMD
d1179 1
a1179 1
			Time_F(START,usertime);
d1181 3
a1183 5
				RIPEMD160(buf,(unsigned long)lengths[j],&(rmd160[0]));
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_RMD160],d);
			results[D_RMD160][j]=((double)count)/d*lengths[j];
d1187 1
a1187 1
#ifndef NO_RC4
d1193 1
a1193 1
			Time_F(START,usertime);
d1197 2
a1198 4
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_RC4],d);
			results[D_RC4][j]=((double)count)/d*lengths[j];
d1202 1
a1202 1
#ifndef NO_DES
d1208 1
a1208 1
			Time_F(START,usertime);
d1210 4
a1213 6
				des_ncbc_encrypt(buf,buf,lengths[j],sch,
						 &iv,DES_ENCRYPT);
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_CBC_DES],d);
			results[D_CBC_DES][j]=((double)count)/d*lengths[j];
d1222 1
a1222 1
			Time_F(START,usertime);
d1224 5
a1228 7
				des_ede3_cbc_encrypt(buf,buf,lengths[j],
						     sch,sch2,sch3,
						     &iv,DES_ENCRYPT);
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_EDE3_DES],d);
			results[D_EDE3_DES][j]=((double)count)/d*lengths[j];
d1232 46
a1277 1
#ifndef NO_IDEA
d1283 1
a1283 1
			Time_F(START,usertime);
d1288 2
a1289 4
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_CBC_IDEA],d);
			results[D_CBC_IDEA][j]=((double)count)/d*lengths[j];
d1293 1
a1293 1
#ifndef NO_RC2
d1299 1
a1299 1
			Time_F(START,usertime);
d1304 2
a1305 4
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_CBC_RC2],d);
			results[D_CBC_RC2][j]=((double)count)/d*lengths[j];
d1309 1
a1309 1
#ifndef NO_RC5
d1315 1
a1315 1
			Time_F(START,usertime);
d1320 2
a1321 4
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_CBC_RC5],d);
			results[D_CBC_RC5][j]=((double)count)/d*lengths[j];
d1325 1
a1325 1
#ifndef NO_BF
d1331 1
a1331 1
			Time_F(START,usertime);
d1336 2
a1337 4
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_CBC_BF],d);
			results[D_CBC_BF][j]=((double)count)/d*lengths[j];
d1341 1
a1341 1
#ifndef NO_CAST
d1347 1
a1347 1
			Time_F(START,usertime);
d1352 2
a1353 4
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %s's in %.2fs\n",
				count,names[D_CBC_CAST],d);
			results[D_CBC_CAST][j]=((double)count)/d*lengths[j];
d1358 51
d1410 1
a1410 1
#ifndef NO_RSA
d1428 1
a1428 1
			Time_F(START,usertime);
d1442 4
a1445 4
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,
				"%ld %d bit private RSA's in %.2fs\n",
				count,rsa_bits[j],d);
d1463 1
a1463 1
			Time_F(START,usertime);
d1477 4
a1480 4
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,
				"%ld %d bit public RSA's in %.2fs\n",
				count,rsa_bits[j],d);
d1495 1
a1495 1
#ifndef NO_DSA
d1507 1
a1507 1
		DSA_generate_key(dsa_key[j]);
d1522 1
a1522 1
			Time_F(START,usertime);
d1536 4
a1539 3
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %d bit DSA signs in %.2fs\n",
				count,dsa_bits[j],d);
d1557 1
a1557 1
			Time_F(START,usertime);
d1571 4
a1574 3
			d=Time_F(STOP,usertime);
			BIO_printf(bio_err,"%ld %d bit DSA verify in %.2fs\n",
				count,dsa_bits[j],d);
d1587 6
a1592 2

	fprintf(stdout,"%s\n",SSLeay_version(SSLEAY_VERSION));
d1594 19
a1612 4
	printf("options:");
	printf("%s ",BN_options());
#ifndef NO_MD2
	printf("%s ",MD2_options());
d1614 4
a1617 2
#ifndef NO_RC4
	printf("%s ",RC4_options());
d1619 2
a1620 2
#ifndef NO_DES
	printf("%s ",des_options());
d1622 2
a1623 2
#ifndef NO_IDEA
	printf("%s ",idea_options());
d1625 6
a1630 2
#ifndef NO_BF
	printf("%s ",BF_options());
d1632 10
a1641 1
	fprintf(stdout,"\n%s\n",SSLeay_version(SSLEAY_CFLAGS));
d1645 7
a1651 2
		fprintf(stdout,"The 'numbers' are in 1000s of bytes per second processed.\n"); 
		fprintf(stdout,"type        ");
d1653 1
a1653 1
			fprintf(stdout,"%7d bytes",lengths[j]);
d1660 4
a1663 1
		fprintf(stdout,"%-13s",names[k]);
d1666 1
a1666 1
			if (results[k][j] > 10000)
d1669 1
a1669 1
				fprintf(stdout," %11.2f ",results[k][j]);
d1673 1
a1673 1
#ifndef NO_RSA
d1678 1
a1678 1
		if (j)
d1683 8
a1690 4
		fprintf(stdout,"rsa %4u bits %8.4fs %8.4fs %8.1f %8.1f",
			rsa_bits[k],rsa_results[k][0],rsa_results[k][1],
			1.0/rsa_results[k][0],1.0/rsa_results[k][1]);
		fprintf(stdout,"\n");
d1693 1
a1693 1
#ifndef NO_DSA
d1698 2
a1699 1
		if (j)	{
d1703 7
a1709 4
		fprintf(stdout,"dsa %4u bits %8.4fs %8.4fs %8.1f %8.1f",
			dsa_bits[k],dsa_results[k][0],dsa_results[k][1],
			1.0/dsa_results[k][0],1.0/dsa_results[k][1]);
		fprintf(stdout,"\n");
d1717 1
a1717 1
#ifndef NO_RSA
d1722 1
a1722 1
#ifndef NO_DSA
d1727 1
d1731 1
a1731 1
static void print_message(char *s, long num, int length)
d1734 2
a1735 1
	BIO_printf(bio_err,"Doing %s for %ds on %d size blocks: ",s,SECONDS,length);
d1739 2
a1740 1
	BIO_printf(bio_err,"Doing %s %ld times on %d size blocks: ",s,num,length);
d1752 2
a1753 1
	BIO_printf(bio_err,"Doing %d bit %s %s's for %ds: ",bits,str,str2,tm);
d1757 2
a1758 1
	BIO_printf(bio_err,"Doing %ld %d bit %s %s's: ",num,bits,str,str2);
d1766 172
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d86 1
a86 1
#if defined(__FreeBSD__)
d91 1
a91 1
#if !defined(_UNICOS) && !defined(__OpenBSD__) && !defined(sgi) && !defined(__FreeBSD__) && !(defined(__bsdi) || defined(__bsdi__)) && !defined(_AIX) && !defined(MPE)
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d868 1
d886 1
d1212 1
a1212 1
			dsa_doit[j] = 0;
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d84 1
d86 7
a92 2
#if !defined(MSDOS) && (!defined(VMS) || defined(__DECC))
#define TIMES
d96 1
a96 1
#include <time.h>
d99 6
a104 2
#include <sys/types.h>
#include <sys/times.h>
d115 1
a115 1
#ifndef TIMES
d119 4
d138 3
d198 1
a198 1
static double Time_F(int s);
d222 1
a222 1
static double Time_F(int s)
a224 2
#ifdef TIMES
	static struct tms tstart,tend;
d226 20
a245 4
	if (s == START)
		{
		times(&tstart);
		return(0);
d249 2
a250 7
		times(&tend);
		ret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;
		return((ret < 1e-3)?1e-3:ret);
		}
#else /* !times() */
	static struct timeb tstart,tend;
	long i;
d252 17
a268 1
	if (s == START)
d270 13
a282 2
		ftime(&tstart);
		return(0);
d284 2
d287 2
d290 15
a304 4
		ftime(&tend);
		i=(long)tend.millitm-(long)tstart.millitm;
		ret=((double)(tend.time-tstart.time))+((double)i)/1000.0;
		return((ret < 0.001)?0.001:ret);
d306 1
d314 1
d317 1
a317 1
#define ALGOR_NUM	14
d323 1
a323 1
	unsigned rsa_num,rsa_num2;
d330 3
d374 13
a386 12
#define	D_MD5		2
#define	D_HMAC		3
#define	D_SHA1		4
#define D_RMD160	5
#define	D_RC4		6
#define	D_CBC_DES	7
#define	D_EDE3_DES	8
#define	D_CBC_IDEA	9
#define	D_CBC_RC2	10
#define	D_CBC_RC5	11
#define	D_CBC_BF	12
#define	D_CBC_CAST	13
d391 1
a391 1
		"md2","mdc2","md5","hmac(md5)","sha1","rmd160","rc4",
d422 5
d444 1
a444 1
	if ((buf=(unsigned char *)Malloc((int)BUFSIZE)) == NULL)
d452 1
a452 1
	if ((buf2=(unsigned char *)Malloc((int)BUFSIZE)) == NULL)
d473 33
d514 4
d553 1
a553 1
			RSA_set_default_method(RSA_PKCS1_RSAref());
d561 1
a561 1
			RSA_set_default_method(RSA_PKCS1_SSLeay());
d629 28
a656 2
			BIO_printf(bio_err,"bad value, pick one of\n");
			BIO_printf(bio_err,"md2      mdc2	md5      hmac      sha1    rmd160\n");
d669 1
a669 1
#if !defined(NO_IDEA) && !defined(NO_RC2) && !defined(NO_BF) && !defined(NO_RC5)
d672 1
d677 2
d680 1
a680 1
			BIO_printf(bio_err,"\nrsa512   rsa1024  rsa2048  rsa4096\n");
d682 1
d684 26
a709 1
			BIO_printf(bio_err,"\ndsa512   dsa1024  dsa2048\n");
d711 1
a711 1
			BIO_printf(bio_err,"idea     rc2      des      rsa    blowfish\n");
d731 7
a737 4
#ifndef TIMES
	BIO_printf(bio_err,"To get the most accurate results, try to run this\n");
	BIO_printf(bio_err,"program when this computer is idle.\n");
#endif
d801 1
a801 1
		Time_F(START);
d805 1
a805 1
		d=Time_F(STOP);
d809 1
d827 1
d904 1
a904 1
			Time_F(START);
d907 1
a907 1
			d=Time_F(STOP);
d920 1
a920 1
			Time_F(START);
d923 1
a923 1
			d=Time_F(STOP);
d931 17
d954 1
a954 1
			Time_F(START);
d957 1
a957 1
			d=Time_F(STOP);
d975 1
a975 1
			Time_F(START);
d982 1
a982 1
			d=Time_F(STOP);
d995 1
a995 1
			Time_F(START);
d998 1
a998 1
			d=Time_F(STOP);
d1011 1
a1011 1
			Time_F(START);
d1014 1
a1014 1
			d=Time_F(STOP);
d1027 1
a1027 1
			Time_F(START);
d1031 1
a1031 1
			d=Time_F(STOP);
d1044 1
a1044 1
			Time_F(START);
d1048 1
a1048 1
			d=Time_F(STOP);
d1060 1
a1060 1
			Time_F(START);
d1065 1
a1065 1
			d=Time_F(STOP);
d1078 1
a1078 1
			Time_F(START);
d1083 1
a1083 1
			d=Time_F(STOP);
d1096 1
a1096 1
			Time_F(START);
d1101 1
a1101 1
			d=Time_F(STOP);
d1114 1
a1114 1
			Time_F(START);
d1119 1
a1119 1
			d=Time_F(STOP);
d1132 1
a1132 1
			Time_F(START);
d1137 1
a1137 1
			d=Time_F(STOP);
d1150 1
a1150 1
			Time_F(START);
d1155 1
a1155 1
			d=Time_F(STOP);
d1170 14
a1183 9
		pkey_print_message("private","rsa",rsa_c[j][0],rsa_bits[j],
			RSA_SECONDS);
/*		RSA_blinding_on(rsa_key[j],NULL); */
		Time_F(START);
		for (count=0,run=1; COND(rsa_c[j][0]); count++)
			{
			ret=RSA_sign(NID_md5_sha1, buf,36, buf2, &rsa_num,
								 rsa_key[j]);
			if (ret <= 0)
d1185 10
a1194 4
				BIO_printf(bio_err,"RSA private encrypt failure\n");
				ERR_print_errors(bio_err);
				count=1;
				break;
d1196 6
a1202 5
		d=Time_F(STOP);
		BIO_printf(bio_err,"%ld %d bit private RSA's in %.2fs\n",
			count,rsa_bits[j],d);
		rsa_results[j][0]=d/(double)count;
		rsa_count=count;
d1206 13
a1218 8
		pkey_print_message("public","rsa",rsa_c[j][1],rsa_bits[j],
			RSA_SECONDS);
		Time_F(START);
		for (count=0,run=1; COND(rsa_c[j][1]); count++)
			{
			ret=RSA_verify(NID_md5_sha1, buf,36, buf2, rsa_num,
								rsa_key[j]);
			if (ret <= 0)
d1220 10
a1229 4
				BIO_printf(bio_err,"RSA verify failure\n");
				ERR_print_errors(bio_err);
				count=1;
				break;
d1231 5
a1236 4
		d=Time_F(STOP);
		BIO_printf(bio_err,"%ld %d bit public RSA's in %.2fs\n",
			count,rsa_bits[j],d);
		rsa_results[j][1]=d/(double)count;
d1258 1
d1263 1
a1263 1
		rsa_num=DSA_sign(EVP_PKEY_DSA,buf,20,buf2,
d1265 13
a1277 8
		pkey_print_message("sign","dsa",dsa_c[j][0],dsa_bits[j],
			DSA_SECONDS);
		Time_F(START);
		for (count=0,run=1; COND(dsa_c[j][0]); count++)
			{
			rsa_num=DSA_sign(EVP_PKEY_DSA,buf,20,buf2,
				&kk,dsa_key[j]);
			if (rsa_num == 0)
d1279 10
a1288 4
				BIO_printf(bio_err,"DSA sign failure\n");
				ERR_print_errors(bio_err);
				count=1;
				break;
d1290 5
a1295 5
		d=Time_F(STOP);
		BIO_printf(bio_err,"%ld %d bit DSA signs in %.2fs\n",
			count,dsa_bits[j],d);
		dsa_results[j][0]=d/(double)count;
		rsa_count=count;
d1297 1
a1297 1
		rsa_num2=DSA_verify(EVP_PKEY_DSA,buf,20,buf2,
d1299 13
a1311 8
		pkey_print_message("verify","dsa",dsa_c[j][1],dsa_bits[j],
			DSA_SECONDS);
		Time_F(START);
		for (count=0,run=1; COND(dsa_c[j][1]); count++)
			{
			rsa_num2=DSA_verify(EVP_PKEY_DSA,buf,20,buf2,
				kk,dsa_key[j]);
			if (rsa_num2 == 0)
d1313 10
a1322 4
				BIO_printf(bio_err,"DSA verify failure\n");
				ERR_print_errors(bio_err);
				count=1;
				break;
d1324 4
a1328 4
		d=Time_F(STOP);
		BIO_printf(bio_err,"%ld %d bit DSA verify in %.2fs\n",
			count,dsa_bits[j],d);
		dsa_results[j][1]=d/(double)count;
d1416 3
a1418 2
	if (buf != NULL) Free(buf);
	if (buf2 != NULL) Free(buf2);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d1033 5
d1097 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d241 2
d246 1
a246 1
	int ret=1;
d252 2
a253 1
	int i,j,k,rsa_num,rsa_num2;
d350 1
d428 1
a428 1
#ifndef NO_DEF
d442 1
d449 1
d595 3
a597 3
	des_set_key(&key,sch);
	des_set_key(&key2,sch2);
	des_set_key(&key3,sch3);
d621 1
d713 4
d720 1
a720 1
#endif
d970 1
a970 1
	RAND_bytes(buf,30);
d974 1
d976 1
a976 2
		rsa_num=RSA_private_encrypt(30,buf,buf2,rsa_key[j],
			RSA_PKCS1_PADDING);
d983 3
a985 3
			rsa_num=RSA_private_encrypt(30,buf,buf2,rsa_key[j],
				RSA_PKCS1_PADDING);
			if (rsa_num <= 0)
d1000 1
a1000 2
		rsa_num2=RSA_public_decrypt(rsa_num,buf2,buf,rsa_key[j],
			RSA_PKCS1_PADDING);
d1006 3
a1008 3
			rsa_num2=RSA_public_decrypt(rsa_num,buf2,buf,rsa_key[j],
				RSA_PKCS1_PADDING);
			if (rsa_num2 <= 0)
d1010 1
a1010 1
				BIO_printf(bio_err,"RSA public encrypt failure\n");
d1031 1
a1031 1
	RAND_bytes(buf,20);
d1049 1
a1049 1
			if (rsa_num <= 0)
d1072 1
a1072 1
			if (rsa_num2 <= 0)
d1168 1
a1168 1
	ret=0;
d1182 1
a1182 1
	EXIT(ret);
@


1.1
log
@Initial revision
@
text
@d63 2
a64 2
#define RSA_SECONDS	10	
#define DSA_SECONDS	10	
d81 3
a83 3
#include "crypto.h"
#include "rand.h"
#include "err.h"
d85 1
a85 1
#ifndef MSDOS
a88 1
#ifndef VMS
d96 7
a102 8
#else /* VMS */
#include <types.h>
struct tms {
	time_t tms_utime;
	time_t tms_stime;
	time_t tms_uchild;	/* I dunno...  */
	time_t tms_uchildsys;	/* so these names are a guess :-) */
	}
d104 1
d109 2
a110 1
#ifdef sun
d116 1
a116 1
#include "des.h"
d119 1
a119 1
#include "md2.h"
d122 1
a122 1
#include "mdc2.h"
d125 4
a128 3
#include "md5.h"
#include "hmac.h"
#include "evp.h"
d130 3
a132 2
#ifndef NO_SHA1
#include "sha.h"
d134 2
a135 2
#ifndef NO_RMD160
#include "ripemd.h"
d138 1
a138 1
#include "rc4.h"
d141 1
a141 1
#include "rc5.h"
d144 1
a144 1
#include "rc2.h"
d147 1
a147 1
#include "idea.h"
d149 2
a150 2
#ifndef NO_BLOWFISH
#include "blowfish.h"
d153 1
a153 1
#include "cast.h"
d156 2
a157 1
#include "rsa.h"
d159 1
a159 2
#include "x509.h"
#include "./testrsa.h"
d168 1
a168 5
#   ifndef VMS
#    define HZ	100.0
#   else /* VMS */
#    define HZ	100.0
#   endif
a180 1
#ifndef NOPROTO
a183 6
#else
static double Time_F();
static void print_message();
static void pkey_print_message();
#endif

a190 1
#ifndef NOPROTO
d192 1
a192 6
#else
static SIGRETTYPE sig_done();
#endif

static SIGRETTYPE sig_done(sig)
int sig;
d205 1
a205 2
static double Time_F(s)
int s;
d241 1
a241 3
int MAIN(argc,argv)
int argc;
char **argv;
d261 1
a261 1
#ifndef NO_SHA1
d264 1
a264 1
#ifndef NO_RMD160
d279 1
a279 1
#ifndef NO_BLOWFISH
d290 1
d324 1
a326 1
#ifndef NO_RSA
d347 3
d355 2
d359 1
d366 3
d406 1
a406 1
#ifndef NO_SHA1
d412 1
a412 1
#ifndef NO_RMD160
d438 1
a438 1
			if (strcmp(*argv,"ssleay") == 0) 
d468 1
a468 1
#ifndef NO_BLOWFISH
d518 1
a518 1
#ifndef NO_BLOWFISH
d521 1
a521 1
#if !defined(NO_IDEA) && !defined(NO_RC2) && !defined(NO_BLOWFISH) && !defined(NO_RC5)
d589 3
a591 3
	des_set_key((C_Block *)key,sch);
	des_set_key((C_Block *)key2,sch2);
	des_set_key((C_Block *)key3,sch3);
d605 1
a605 1
#ifndef NO_BLOWFISH
d611 1
a611 1

d613 1
d622 1
a622 1
			des_ecb_encrypt((C_Block *)buf,(C_Block *)buf,
d665 1
d676 1
a676 1
			if (rsa_c[i] == 0)
d683 1
d761 1
a761 1
#ifndef NO_MD5
d785 1
a785 1
#ifndef NO_SHA1
d801 1
a801 1
#ifndef NO_RMD160
d842 2
a843 4
				des_ncbc_encrypt((C_Block *)buf,
					(C_Block *)buf,
					(long)lengths[j],sch,
					(C_Block *)&(iv[0]),DES_ENCRYPT);
d858 3
a860 4
				des_ede3_cbc_encrypt((C_Block *)buf,
					(C_Block *)buf,
					(long)lengths[j],sch,sch2,sch3,
					(C_Block *)&(iv[0]),DES_ENCRYPT);
d878 1
a878 1
					(unsigned char *)&(iv[0]),IDEA_ENCRYPT);
d896 1
a896 1
					(unsigned char *)&(iv[0]),RC2_ENCRYPT);
d914 1
a914 1
					(unsigned char *)&(iv[0]),RC5_ENCRYPT);
d922 1
a922 1
#ifndef NO_BLOWFISH
d932 1
a932 1
					(unsigned char *)&(iv[0]),BF_ENCRYPT);
d950 1
a950 1
					(unsigned char *)&(iv[0]),CAST_ENCRYPT);
d964 2
d989 2
d1030 2
d1053 2
d1100 1
a1100 1
#ifndef NO_BLOWFISH
d1137 1
a1137 1
		fprintf(stdout,"rsa %4d bits %8.4fs %8.4fs %8.1f %8.1f",
d1152 1
a1152 1
		fprintf(stdout,"dsa %4d bits %8.4fs %8.4fs %8.1f %8.1f",
d1175 1
a1175 4
static void print_message(s,num,length)
char *s;
long num;
int length;
d1179 1
a1179 1
	BIO_flush(bio_err);
d1183 1
a1183 1
	BIO_flush(bio_err);
d1190 2
a1191 6
static void pkey_print_message(str,str2,num,bits,tm)
char *str;
char *str2;
long num;
int bits;
int tm;
d1195 1
a1195 1
	BIO_flush(bio_err);
d1199 1
a1199 1
	BIO_flush(bio_err);
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 1
/* apps/speed.c -*- mode:C; c-file-style: "eay" -*- */
d63 2
a64 2
#define RSA_SECONDS	10
#define DSA_SECONDS	10
d78 1
a78 1
#ifdef OPENSSL_NO_STDIO
d81 6
a86 16
#include <openssl/crypto.h>
#include <openssl/rand.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#if !defined(OPENSSL_SYS_MSDOS)
#include OPENSSL_UNISTD
#endif

#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(OPENSSL_SYS_MACOSX)
# define USE_TOD
#elif !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VXWORKS) && (!defined(OPENSSL_SYS_VMS) || defined(__DECC))
# define TIMES
#endif
#if !defined(_UNICOS) && !defined(__OpenBSD__) && !defined(sgi) && !defined(__FreeBSD__) && !(defined(__bsdi) || defined(__bsdi__)) && !defined(_AIX) && !defined(OPENSSL_SYS_MPE) && !defined(__NetBSD__) && !defined(OPENSSL_SYS_VXWORKS) /* FIXME */
# define TIMEB
d89 1
d91 1
a91 1
# include <time.h>
d94 2
a95 2
# include <sys/types.h>
# include <sys/times.h>
d97 8
a104 3
#ifdef USE_TOD
# include <sys/time.h>
# include <sys/resource.h>
d106 1
a106 10

/* Depending on the VMS version, the tms structure is perhaps defined.
   The __TMS macro will show if it was.  If it wasn't defined, we should
   undefine TIMES, since that tells the rest of the program how things
   should be handled.				-- Richard Levitte */
#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__TMS)
#undef TIMES
#endif

#ifdef TIMEB
d110 1
a110 6
#if !defined(TIMES) && !defined(TIMEB) && !defined(USE_TOD) && !defined(OPENSSL_SYS_VXWORKS)
#error "It seems neither struct tms nor struct timeb is supported in this platform!"
#endif

#if defined(sun) || defined(__ultrix)
#define _POSIX_SOURCE
d115 2
a116 5
#ifndef OPENSSL_NO_DES
#include <openssl/des.h>
#endif
#ifndef OPENSSL_NO_AES
#include <openssl/aes.h>
d118 2
a119 2
#ifndef OPENSSL_NO_MD2
#include <openssl/md2.h>
d121 2
a122 2
#ifndef OPENSSL_NO_MDC2
#include <openssl/mdc2.h>
d124 4
a127 2
#ifndef OPENSSL_NO_MD4
#include <openssl/md4.h>
d129 2
a130 2
#ifndef OPENSSL_NO_MD5
#include <openssl/md5.h>
d132 2
a133 2
#ifndef OPENSSL_NO_HMAC
#include <openssl/hmac.h>
d135 2
a136 3
#include <openssl/evp.h>
#ifndef OPENSSL_NO_SHA
#include <openssl/sha.h>
d138 2
a139 2
#ifndef OPENSSL_NO_RIPEMD
#include <openssl/ripemd.h>
d141 2
a142 2
#ifndef OPENSSL_NO_RC4
#include <openssl/rc4.h>
d144 2
a145 2
#ifndef OPENSSL_NO_RC5
#include <openssl/rc5.h>
d147 2
a148 2
#ifndef OPENSSL_NO_RC2
#include <openssl/rc2.h>
d150 2
a151 2
#ifndef OPENSSL_NO_IDEA
#include <openssl/idea.h>
d153 2
a154 2
#ifndef OPENSSL_NO_BF
#include <openssl/blowfish.h>
d156 1
a156 5
#ifndef OPENSSL_NO_CAST
#include <openssl/cast.h>
#endif
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
d158 1
a158 3
#endif
#include <openssl/x509.h>
#ifndef OPENSSL_NO_DSA
d164 5
a168 5
# ifdef _SC_CLK_TCK
#  define HZ ((double)sysconf(_SC_CLK_TCK))
# else
#  ifndef CLK_TCK
#   ifndef _BSD_CLK_TCK_ /* FreeBSD hack */
a169 2
#   else /* _BSD_CLK_TCK_ */
#    define HZ ((double)_BSD_CLK_TCK_)
d171 2
a172 2
#  else /* CLK_TCK */
#   define HZ ((double)CLK_TCK)
d174 2
a178 4
#if !defined(OPENSSL_SYS_VMS) && !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MACINTOSH_CLASSIC) && !defined(OPENSSL_SYS_OS2)
# define HAVE_FORK 1
#endif

d183 1
a183 4
static char ftime_used = 0, times_used = 0, gettimeofday_used = 0, getrusage_used = 0;
static int mr=0;
static int usertime=1;

d185 1
a185 1
static void print_message(const char *s,long num,int length);
d187 4
a190 3
static void print_result(int alg,int run_no,int count,double time_used);
#ifdef HAVE_FORK
static int do_multi(int multi);
a192 14
#define ALGOR_NUM	19
#define SIZE_NUM	5
#define RSA_NUM		4
#define DSA_NUM		3
static const char *names[ALGOR_NUM]={
  "md2","mdc2","md4","md5","hmac(md5)","sha1","rmd160","rc4",
  "des cbc","des ede3","idea cbc",
  "rc2 cbc","rc5-32/12 cbc","blowfish cbc","cast cbc",
  "aes-128 cbc","aes-192 cbc","aes-256 cbc"};
static double results[ALGOR_NUM][SIZE_NUM];
static int lengths[SIZE_NUM]={16,64,256,1024,8*1024};
static double rsa_results[RSA_NUM][2];
static double dsa_results[DSA_NUM][2];

d200 1
d202 6
a207 1
static SIGRETTYPE sig_done(int sig)
d220 2
a221 1
static double Time_F(int s)
d224 2
d227 4
a230 21
#ifdef USE_TOD
	if(usertime)
	    {
		static struct rusage tstart,tend;

		getrusage_used = 1;
		if (s == START)
			{
			getrusage(RUSAGE_SELF,&tstart);
			return(0);
			}
		else
			{
			long i;

			getrusage(RUSAGE_SELF,&tend);
			i=(long)tend.ru_utime.tv_usec-(long)tstart.ru_utime.tv_usec;
			ret=((double)(tend.ru_utime.tv_sec-tstart.ru_utime.tv_sec))
			  +((double)i)/1000000.0;
			return((ret < 0.001)?0.001:ret);
			}
d234 7
a240 2
		static struct timeval tstart,tend;
		long i;
d242 1
a242 18
		gettimeofday_used = 1;
		if (s == START)
			{
			gettimeofday(&tstart,NULL);
			return(0);
			}
		else
			{
			gettimeofday(&tend,NULL);
			i=(long)tend.tv_usec-(long)tstart.tv_usec;
			ret=((double)(tend.tv_sec-tstart.tv_sec))+((double)i)/1000000.0;
			return((ret < 0.001)?0.001:ret);
			}
		}
#else  /* ndef USE_TOD */
		
# ifdef TIMES
	if (usertime)
d244 2
a245 14
		static struct tms tstart,tend;

		times_used = 1;
		if (s == START)
			{
			times(&tstart);
			return(0);
			}
		else
			{
			times(&tend);
			ret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;
			return((ret < 1e-3)?1e-3:ret);
			}
a246 2
# endif /* times() */
# if defined(TIMES) && defined(TIMEB)
a247 18
# endif
# ifdef OPENSSL_SYS_VXWORKS
                {
		static unsigned long tick_start, tick_end;

		if( s == START )
			{
			tick_start = tickGet();
			return 0;
			}
		else
			{
			tick_end = tickGet();
			ret = (double)(tick_end - tick_start) / (double)sysClkRateGet();
			return((ret < 0.001)?0.001:ret);
			}
                }
# elif defined(TIMEB)
d249 4
a252 16
		static struct timeb tstart,tend;
		long i;

		ftime_used = 1;
		if (s == START)
			{
			ftime(&tstart);
			return(0);
			}
		else
			{
			ftime(&tend);
			i=(long)tend.millitm-(long)tstart.millitm;
			ret=((double)(tend.time-tstart.time))+((double)i)/1000.0;
			return((ret < 0.001)?0.001:ret);
			}
a253 1
# endif
d257 3
a259 3
int MAIN(int, char **);

int MAIN(int argc, char **argv)
a260 1
	ENGINE *e = NULL;
d262 8
a269 11
	int mret=1;
	long count=0,save_count=0;
	int i,j,k;
#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA)
	long rsa_count;
#endif
#ifndef OPENSSL_NO_RSA
	unsigned rsa_num;
#endif
	unsigned char md[EVP_MAX_MD_SIZE];
#ifndef OPENSSL_NO_MD2
d272 1
a272 1
#ifndef OPENSSL_NO_MDC2
d275 1
a275 4
#ifndef OPENSSL_NO_MD4
	unsigned char md4[MD4_DIGEST_LENGTH];
#endif
#ifndef OPENSSL_NO_MD5
d279 1
a279 1
#ifndef OPENSSL_NO_SHA
d282 1
a282 1
#ifndef OPENSSL_NO_RIPEMD
d285 1
a285 1
#ifndef OPENSSL_NO_RC4
d288 1
a288 1
#ifndef OPENSSL_NO_RC5
d291 1
a291 1
#ifndef OPENSSL_NO_RC2
d294 1
a294 1
#ifndef OPENSSL_NO_IDEA
d297 1
a297 1
#ifndef OPENSSL_NO_BF
d300 1
a300 1
#ifndef OPENSSL_NO_CAST
d303 1
a303 1
	static const unsigned char key16[16]=
d306 6
a311 27
	static const unsigned char key24[24]=
		{0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,
		 0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,
		 0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};
	static const unsigned char key32[32]=
		{0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,
		 0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,
		 0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34,
		 0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34,0x56};
#ifndef OPENSSL_NO_AES
#define MAX_BLOCK_SIZE 128
#else
#define MAX_BLOCK_SIZE 64
#endif
	unsigned char DES_iv[8];
	unsigned char iv[MAX_BLOCK_SIZE/8];
#ifndef OPENSSL_NO_DES
	DES_cblock *buf_as_des_cblock = NULL;
	static DES_cblock key ={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};
	static DES_cblock key2={0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12};
	static DES_cblock key3={0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};
	DES_key_schedule sch;
	DES_key_schedule sch2;
	DES_key_schedule sch3;
#endif
#ifndef OPENSSL_NO_AES
	AES_KEY aes_ks1, aes_ks2, aes_ks3;
d315 14
a328 18
#define	D_MD4		2
#define	D_MD5		3
#define	D_HMAC		4
#define	D_SHA1		5
#define D_RMD160	6
#define	D_RC4		7
#define	D_CBC_DES	8
#define	D_EDE3_DES	9
#define	D_CBC_IDEA	10
#define	D_CBC_RC2	11
#define	D_CBC_RC5	12
#define	D_CBC_BF	13
#define	D_CBC_CAST	14
#define D_CBC_128_AES	15
#define D_CBC_192_AES	16
#define D_CBC_256_AES	17
#define D_EVP		18
	double d=0.0;
d330 4
a340 1
#ifndef OPENSSL_NO_RSA
d343 2
d352 1
a352 1
#ifndef OPENSSL_NO_DSA
d355 1
a361 10
	const EVP_CIPHER *evp_cipher=NULL;
	const EVP_MD *evp_md=NULL;
	int decrypt=0;
#ifdef HAVE_FORK
	int multi=0;
#endif

#ifndef TIMES
	usertime=-1;
#endif
a363 4
	memset(results, 0, sizeof(results));
#ifndef OPENSSL_NO_DSA
	memset(dsa_key,0,sizeof(dsa_key));
#endif
a368 5
	if (!load_config(bio_err, NULL))
		goto end;

#ifndef OPENSSL_NO_RSA
	memset(rsa_key,0,sizeof(rsa_key));
a370 1
#endif
d372 1
a372 1
	if ((buf=(unsigned char *)OPENSSL_malloc((int)BUFSIZE)) == NULL)
d377 1
a377 4
#ifndef OPENSSL_NO_DES
	buf_as_des_cblock = (DES_cblock *)buf;
#endif
	if ((buf2=(unsigned char *)OPENSSL_malloc((int)BUFSIZE)) == NULL)
a383 1
	memset(DES_iv,0,sizeof(DES_iv));
d398 1
a398 77
		if	((argc > 0) && (strcmp(*argv,"-elapsed") == 0))
			{
			usertime = 0;
			j--;	/* Otherwise, -elapsed gets confused with
				   an algorithm. */
			}
		else if	((argc > 0) && (strcmp(*argv,"-evp") == 0))
			{
			argc--;
			argv++;
			if(argc == 0)
				{
				BIO_printf(bio_err,"no EVP given\n");
				goto end;
				}
			evp_cipher=EVP_get_cipherbyname(*argv);
			if(!evp_cipher)
				{
				evp_md=EVP_get_digestbyname(*argv);
				}
			if(!evp_cipher && !evp_md)
				{
				BIO_printf(bio_err,"%s is an unknown cipher or digest\n",*argv);
				goto end;
				}
			doit[D_EVP]=1;
			}
		else if (argc > 0 && !strcmp(*argv,"-decrypt"))
			{
			decrypt=1;
			j--;	/* Otherwise, -elapsed gets confused with
				   an algorithm. */
			}
		else if	((argc > 0) && (strcmp(*argv,"-engine") == 0))
			{
			argc--;
			argv++;
			if(argc == 0)
				{
				BIO_printf(bio_err,"no engine given\n");
				goto end;
				}
                        e = setup_engine(bio_err, *argv, 0);
			/* j will be increased again further down.  We just
			   don't want speed to confuse an engine with an
			   algorithm, especially when none is given (which
			   means all of them should be run) */
			j--;
			}
#ifdef HAVE_FORK
		else if	((argc > 0) && (strcmp(*argv,"-multi") == 0))
			{
			argc--;
			argv++;
			if(argc == 0)
				{
				BIO_printf(bio_err,"no multi count given\n");
				goto end;
				}
			multi=atoi(argv[0]);
			if(multi <= 0)
			    {
				BIO_printf(bio_err,"bad multi count\n");
				goto end;
				}				
			j--;	/* Otherwise, -mr gets confused with
				   an algorithm. */
			}
#endif
		else if (argc > 0 && !strcmp(*argv,"-mr"))
			{
			mr=1;
			j--;	/* Otherwise, -mr gets confused with
				   an algorithm. */
			}
		else
#ifndef OPENSSL_NO_MD2
d402 1
a402 1
#ifndef OPENSSL_NO_MDC2
d406 1
a406 5
#ifndef OPENSSL_NO_MD4
			if (strcmp(*argv,"md4") == 0) doit[D_MD4]=1;
		else
#endif
#ifndef OPENSSL_NO_MD5
d410 1
a410 1
#ifndef OPENSSL_NO_MD5
d414 1
a414 1
#ifndef OPENSSL_NO_SHA
d420 1
a420 1
#ifndef OPENSSL_NO_RIPEMD
d428 1
a428 1
#ifndef OPENSSL_NO_RC4
d432 1
a432 1
#ifndef OPENSSL_NO_DES
d437 2
a438 8
#ifndef OPENSSL_NO_AES
			if (strcmp(*argv,"aes-128-cbc") == 0) doit[D_CBC_128_AES]=1;
		else	if (strcmp(*argv,"aes-192-cbc") == 0) doit[D_CBC_192_AES]=1;
		else	if (strcmp(*argv,"aes-256-cbc") == 0) doit[D_CBC_256_AES]=1;
		else
#endif
#ifndef OPENSSL_NO_RSA
#if 0 /* was: #ifdef RSAref */
d441 1
a441 1
			RSA_set_default_openssl_method(RSA_PKCS1_RSAref());
d446 1
a446 2
#ifndef RSA_NULL
			if (strcmp(*argv,"openssl") == 0) 
d452 1
a452 2
#endif
#endif /* !OPENSSL_NO_RSA */
d461 1
a461 1
#ifndef OPENSSL_NO_RC2
d466 1
a466 1
#ifndef OPENSSL_NO_RC5
d471 1
a471 1
#ifndef OPENSSL_NO_IDEA
d476 1
a476 1
#ifndef OPENSSL_NO_BF
d482 1
a482 1
#ifndef OPENSSL_NO_CAST
d488 1
a488 1
#ifndef OPENSSL_NO_DES
d496 1
a496 10
#ifndef OPENSSL_NO_AES
			if (strcmp(*argv,"aes") == 0)
			{
			doit[D_CBC_128_AES]=1;
			doit[D_CBC_192_AES]=1;
			doit[D_CBC_256_AES]=1;
			}
		else
#endif
#ifndef OPENSSL_NO_RSA
d506 1
a506 1
#ifndef OPENSSL_NO_DSA
d515 3
a517 31
			BIO_printf(bio_err,"Error: bad option or value\n");
			BIO_printf(bio_err,"\n");
			BIO_printf(bio_err,"Available values:\n");
#ifndef OPENSSL_NO_MD2
			BIO_printf(bio_err,"md2      ");
#endif
#ifndef OPENSSL_NO_MDC2
			BIO_printf(bio_err,"mdc2     ");
#endif
#ifndef OPENSSL_NO_MD4
			BIO_printf(bio_err,"md4      ");
#endif
#ifndef OPENSSL_NO_MD5
			BIO_printf(bio_err,"md5      ");
#ifndef OPENSSL_NO_HMAC
			BIO_printf(bio_err,"hmac     ");
#endif
#endif
#ifndef OPENSSL_NO_SHA1
			BIO_printf(bio_err,"sha1     ");
#endif
#ifndef OPENSSL_NO_RIPEMD160
			BIO_printf(bio_err,"rmd160");
#endif
#if !defined(OPENSSL_NO_MD2) || !defined(OPENSSL_NO_MDC2) || \
    !defined(OPENSSL_NO_MD4) || !defined(OPENSSL_NO_MD5) || \
    !defined(OPENSSL_NO_SHA1) || !defined(OPENSSL_NO_RIPEMD160)
			BIO_printf(bio_err,"\n");
#endif

#ifndef OPENSSL_NO_IDEA
d520 1
a520 1
#ifndef OPENSSL_NO_RC2
d523 1
a523 1
#ifndef OPENSSL_NO_RC5
d526 1
a526 1
#ifndef OPENSSL_NO_BF
d529 1
a529 2
#if !defined(OPENSSL_NO_IDEA) || !defined(OPENSSL_NO_RC2) || \
    !defined(OPENSSL_NO_BF) || !defined(OPENSSL_NO_RC5)
a531 1
#ifndef OPENSSL_NO_DES
d533 1
a533 5
#endif
#ifndef OPENSSL_NO_AES
			BIO_printf(bio_err,"aes-128-cbc aes-192-cbc aes-256-cbc ");
#endif
#ifndef OPENSSL_NO_RC4
d536 2
a537 38
			BIO_printf(bio_err,"\n");

#ifndef OPENSSL_NO_RSA
			BIO_printf(bio_err,"rsa512   rsa1024  rsa2048  rsa4096\n");
#endif

#ifndef OPENSSL_NO_DSA
			BIO_printf(bio_err,"dsa512   dsa1024  dsa2048\n");
#endif

#ifndef OPENSSL_NO_IDEA
			BIO_printf(bio_err,"idea     ");
#endif
#ifndef OPENSSL_NO_RC2
			BIO_printf(bio_err,"rc2      ");
#endif
#ifndef OPENSSL_NO_DES
			BIO_printf(bio_err,"des      ");
#endif
#ifndef OPENSSL_NO_AES
			BIO_printf(bio_err,"aes      ");
#endif
#ifndef OPENSSL_NO_RSA
			BIO_printf(bio_err,"rsa      ");
#endif
#ifndef OPENSSL_NO_BF
			BIO_printf(bio_err,"blowfish");
#endif
#if !defined(OPENSSL_NO_IDEA) || !defined(OPENSSL_NO_RC2) || \
    !defined(OPENSSL_NO_DES) || !defined(OPENSSL_NO_RSA) || \
    !defined(OPENSSL_NO_BF) || !defined(OPENSSL_NO_AES)
			BIO_printf(bio_err,"\n");
#endif

			BIO_printf(bio_err,"\n");
			BIO_printf(bio_err,"Available options:\n");
#ifdef TIMES
			BIO_printf(bio_err,"-elapsed        measure time in real time instead of CPU user time.\n");
d539 2
a540 6
			BIO_printf(bio_err,"-engine e       use engine e, possibly a hardware device.\n");
			BIO_printf(bio_err,"-evp e          use EVP e.\n");
			BIO_printf(bio_err,"-decrypt        time decryption instead of encryption (only EVP).\n");
			BIO_printf(bio_err,"-mr             produce machine readable output.\n");
#ifdef HAVE_FORK
			BIO_printf(bio_err,"-multi n        run n benchmarks in parallel.\n");
d542 1
a549 5
#ifdef HAVE_FORK
	if(multi && do_multi(multi))
		goto show_res;
#endif

d553 1
a553 4
			{
			if (i != D_EVP)
				doit[i]=1;
			}
d562 4
a565 7
	if (usertime == 0 && !mr)
		BIO_printf(bio_err,"You have chosen to measure elapsed time instead of user CPU time.\n");
	if (usertime <= 0 && !mr)
		{
		BIO_printf(bio_err,"To get the most accurate results, try to run this\n");
		BIO_printf(bio_err,"program when this computer is idle.\n");
		}
d567 1
a567 1
#ifndef OPENSSL_NO_RSA
d570 1
a570 1
		const unsigned char *p;
d582 1
a582 3
			BIO_printf(bio_err,mr ? "+RK:%d:"
				   : "Loaded RSA key, %d bit modulus and e= 0x",
				   BN_num_bits(rsa_key[i]->n));
d590 1
a590 1
#ifndef OPENSSL_NO_DSA
d596 4
a599 9
#ifndef OPENSSL_NO_DES
	DES_set_key_unchecked(&key,&sch);
	DES_set_key_unchecked(&key2,&sch2);
	DES_set_key_unchecked(&key3,&sch3);
#endif
#ifndef OPENSSL_NO_AES
	AES_set_encrypt_key(key16,128,&aes_ks1);
	AES_set_encrypt_key(key24,192,&aes_ks2);
	AES_set_encrypt_key(key32,256,&aes_ks3);
d601 1
a601 1
#ifndef OPENSSL_NO_IDEA
d604 1
a604 1
#ifndef OPENSSL_NO_RC4
d607 1
a607 1
#ifndef OPENSSL_NO_RC2
d610 1
a610 1
#ifndef OPENSSL_NO_RC5
d613 1
a613 1
#ifndef OPENSSL_NO_BF
d616 1
a616 1
#ifndef OPENSSL_NO_CAST
d619 1
a619 1
#ifndef OPENSSL_NO_RSA
a620 1
#endif
a621 1
#ifndef OPENSSL_NO_DES
d629 2
a630 2
			DES_ecb_encrypt(buf_as_des_cblock,buf_as_des_cblock,
				&sch,DES_ENCRYPT);
a632 1
	save_count=count;
a634 1
	c[D_MD4][0]=count;
a651 1
		c[D_MD4][i]=c[D_MD4][0]*4*lengths[0]/lengths[i];
a671 1
#ifndef OPENSSL_NO_RSA
d682 1
a682 1
			if (rsa_c[i][0] == 0)
a688 1
#endif
a689 1
#ifndef OPENSSL_NO_DSA
a706 1
#endif
a710 4
/* not worth fixing */
# error "You cannot disable DES on systems without SIGALRM."
#endif /* OPENSSL_NO_DES */
#else
d714 1
a714 1
#endif /* SIGALRM */
d716 1
a716 1
#ifndef OPENSSL_NO_MD2
d724 1
a724 1
				EVP_Digest(buf,(unsigned long)lengths[j],&(md2[0]),NULL,EVP_md2(),NULL);
d726 3
a728 1
			print_result(D_MD2,j,count,d);
d732 1
a732 1
#ifndef OPENSSL_NO_MDC2
d740 1
a740 1
				EVP_Digest(buf,(unsigned long)lengths[j],&(mdc2[0]),NULL,EVP_mdc2(),NULL);
d742 3
a744 1
			print_result(D_MDC2,j,count,d);
d749 1
a749 16
#ifndef OPENSSL_NO_MD4
	if (doit[D_MD4])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_MD4],c[D_MD4][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_MD4][j]); count++)
				EVP_Digest(&(buf[0]),(unsigned long)lengths[j],&(md4[0]),NULL,EVP_md4(),NULL);
			d=Time_F(STOP);
			print_result(D_MD4,j,count,d);
			}
		}
#endif

#ifndef OPENSSL_NO_MD5
d757 1
a757 1
				EVP_Digest(&(buf[0]),(unsigned long)lengths[j],&(md5[0]),NULL,EVP_get_digestbyname("md5"),NULL);
d759 3
a761 1
			print_result(D_MD5,j,count,d);
d766 1
a766 1
#if !defined(OPENSSL_NO_MD5) && !defined(OPENSSL_NO_HMAC)
d770 2
a771 4

		HMAC_CTX_init(&hctx);
		HMAC_Init_ex(&hctx,(unsigned char *)"This is a key...",
			16,EVP_md5(), NULL);
d779 3
a781 3
				HMAC_Init_ex(&hctx,NULL,0,NULL,NULL);
				HMAC_Update(&hctx,buf,lengths[j]);
				HMAC_Final(&hctx,&(hmac[0]),NULL);
d784 3
a786 1
			print_result(D_HMAC,j,count,d);
a787 1
		HMAC_CTX_cleanup(&hctx);
d790 1
a790 1
#ifndef OPENSSL_NO_SHA
d798 1
a798 1
				EVP_Digest(buf,(unsigned long)lengths[j],&(sha[0]),NULL,EVP_sha1(),NULL);
d800 3
a802 1
			print_result(D_SHA1,j,count,d);
d806 1
a806 1
#ifndef OPENSSL_NO_RIPEMD
d814 1
a814 1
				EVP_Digest(buf,(unsigned long)lengths[j],&(rmd160[0]),NULL,EVP_ripemd160(),NULL);
d816 3
a818 1
			print_result(D_RMD160,j,count,d);
d822 1
a822 1
#ifndef OPENSSL_NO_RC4
d833 3
a835 1
			print_result(D_RC4,j,count,d);
d839 1
a839 1
#ifndef OPENSSL_NO_DES
d847 8
a854 4
				DES_ncbc_encrypt(buf,buf,lengths[j],&sch,
						 &DES_iv,DES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_DES,j,count,d);
d865 4
a868 3
				DES_ede3_cbc_encrypt(buf,buf,lengths[j],
						     &sch,&sch2,&sch3,
						     &DES_iv,DES_ENCRYPT);
d870 3
a872 1
			print_result(D_EDE3_DES,j,count,d);
d876 1
a876 46
#ifndef OPENSSL_NO_AES
	if (doit[D_CBC_128_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_128_AES],c[D_CBC_128_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_128_AES][j]); count++)
				AES_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&aes_ks1,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_128_AES,j,count,d);
			}
		}
	if (doit[D_CBC_192_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_192_AES],c[D_CBC_192_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_192_AES][j]); count++)
				AES_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&aes_ks2,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_192_AES,j,count,d);
			}
		}
	if (doit[D_CBC_256_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_256_AES],c[D_CBC_256_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_256_AES][j]); count++)
				AES_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&aes_ks3,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_256_AES,j,count,d);
			}
		}

#endif
#ifndef OPENSSL_NO_IDEA
d886 1
a886 1
					iv,IDEA_ENCRYPT);
d888 3
a890 1
			print_result(D_CBC_IDEA,j,count,d);
d894 1
a894 1
#ifndef OPENSSL_NO_RC2
d904 1
a904 1
					iv,RC2_ENCRYPT);
d906 3
a908 1
			print_result(D_CBC_RC2,j,count,d);
d912 1
a912 1
#ifndef OPENSSL_NO_RC5
d922 1
a922 1
					iv,RC5_ENCRYPT);
d924 3
a926 1
			print_result(D_CBC_RC5,j,count,d);
d930 1
a930 1
#ifndef OPENSSL_NO_BF
d940 1
a940 1
					iv,BF_ENCRYPT);
d942 3
a944 1
			print_result(D_CBC_BF,j,count,d);
d948 1
a948 1
#ifndef OPENSSL_NO_CAST
d958 1
a958 1
					iv,CAST_ENCRYPT);
d960 3
a962 1
			print_result(D_CBC_CAST,j,count,d);
d967 2
a968 53
	if (doit[D_EVP])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			if (evp_cipher)
				{
				EVP_CIPHER_CTX ctx;
				int outl;

				names[D_EVP]=OBJ_nid2ln(evp_cipher->nid);
				/* -O3 -fschedule-insns messes up an
				 * optimization here!  names[D_EVP]
				 * somehow becomes NULL */
				print_message(names[D_EVP],save_count,
					lengths[j]);

				EVP_CIPHER_CTX_init(&ctx);
				if(decrypt)
					EVP_DecryptInit_ex(&ctx,evp_cipher,NULL,key16,iv);
				else
					EVP_EncryptInit_ex(&ctx,evp_cipher,NULL,key16,iv);

				Time_F(START);
				if(decrypt)
					for (count=0,run=1; COND(save_count*4*lengths[0]/lengths[j]); count++)
						EVP_DecryptUpdate(&ctx,buf,&outl,buf,lengths[j]);
				else
					for (count=0,run=1; COND(save_count*4*lengths[0]/lengths[j]); count++)
						EVP_EncryptUpdate(&ctx,buf,&outl,buf,lengths[j]);
				if(decrypt)
					EVP_DecryptFinal_ex(&ctx,buf,&outl);
				else
					EVP_EncryptFinal_ex(&ctx,buf,&outl);
				d=Time_F(STOP);
				}
			if (evp_md)
				{
				names[D_EVP]=OBJ_nid2ln(evp_md->type);
				print_message(names[D_EVP],save_count,
					lengths[j]);

				Time_F(START);
				for (count=0,run=1; COND(save_count*4*lengths[0]/lengths[j]); count++)
					EVP_Digest(buf,lengths[j],&(md[0]),NULL,evp_md,NULL);

				d=Time_F(STOP);
				}
			print_result(D_EVP,j,count,d);
			}
		}

	RAND_pseudo_bytes(buf,36);
#ifndef OPENSSL_NO_RSA
a970 1
		int ret;
d972 5
a976 8
		ret=RSA_sign(NID_md5_sha1, buf,36, buf2, &rsa_num, rsa_key[j]);
		if (ret == 0)
			{
			BIO_printf(bio_err,"RSA sign failure.  No RSA sign will be done.\n");
			ERR_print_errors(bio_err);
			rsa_count=1;
			}
		else
d978 3
a980 6
			pkey_print_message("private","rsa",
				rsa_c[j][0],rsa_bits[j],
				RSA_SECONDS);
/*			RSA_blinding_on(rsa_key[j],NULL); */
			Time_F(START);
			for (count=0,run=1; COND(rsa_c[j][0]); count++)
d982 4
a985 10
				ret=RSA_sign(NID_md5_sha1, buf,36, buf2,
					&rsa_num, rsa_key[j]);
				if (ret == 0)
					{
					BIO_printf(bio_err,
						"RSA sign failure\n");
					ERR_print_errors(bio_err);
					count=1;
					break;
					}
a986 6
			d=Time_F(STOP);
			BIO_printf(bio_err,mr ? "+R1:%ld:%d:%.2f\n"
				   : "%ld %d bit private RSA's in %.2fs\n",
				   count,rsa_bits[j],d);
			rsa_results[j][0]=d/(double)count;
			rsa_count=count;
d988 5
d995 4
a998 2
		ret=RSA_verify(NID_md5_sha1, buf,36, buf2, rsa_num, rsa_key[j]);
		if (ret <= 0)
d1000 3
a1002 11
			BIO_printf(bio_err,"RSA verify failure.  No RSA verify will be done.\n");
			ERR_print_errors(bio_err);
			rsa_doit[j] = 0;
			}
		else
			{
			pkey_print_message("public","rsa",
				rsa_c[j][1],rsa_bits[j],
				RSA_SECONDS);
			Time_F(START);
			for (count=0,run=1; COND(rsa_c[j][1]); count++)
d1004 4
a1007 10
				ret=RSA_verify(NID_md5_sha1, buf,36, buf2,
					rsa_num, rsa_key[j]);
				if (ret == 0)
					{
					BIO_printf(bio_err,
						"RSA verify failure\n");
					ERR_print_errors(bio_err);
					count=1;
					break;
					}
a1008 5
			d=Time_F(STOP);
			BIO_printf(bio_err,mr ? "+R2:%ld:%d:%.2f\n"
				   : "%ld %d bit public RSA's in %.2fs\n",
				   count,rsa_bits[j],d);
			rsa_results[j][1]=d/(double)count;
d1010 4
d1025 2
a1026 7
	RAND_pseudo_bytes(buf,20);
#ifndef OPENSSL_NO_DSA
	if (RAND_status() != 1)
		{
		RAND_seed(rnd_seed, sizeof rnd_seed);
		rnd_fake = 1;
		}
a1029 1
		int ret;
d1032 1
a1032 1
/*		DSA_generate_key(dsa_key[j]); */
d1034 4
a1037 9
		ret=DSA_sign(EVP_PKEY_DSA,buf,20,buf2,
			&kk,dsa_key[j]);
		if (ret == 0)
			{
			BIO_printf(bio_err,"DSA sign failure.  No DSA sign will be done.\n");
			ERR_print_errors(bio_err);
			rsa_count=1;
			}
		else
d1039 3
a1041 5
			pkey_print_message("sign","dsa",
				dsa_c[j][0],dsa_bits[j],
				DSA_SECONDS);
			Time_F(START);
			for (count=0,run=1; COND(dsa_c[j][0]); count++)
d1043 4
a1046 10
				ret=DSA_sign(EVP_PKEY_DSA,buf,20,buf2,
					&kk,dsa_key[j]);
				if (ret == 0)
					{
					BIO_printf(bio_err,
						"DSA sign failure\n");
					ERR_print_errors(bio_err);
					count=1;
					break;
					}
a1047 6
			d=Time_F(STOP);
			BIO_printf(bio_err,mr ? "+R3:%ld:%d:%.2f\n"
				   : "%ld %d bit DSA signs in %.2fs\n",
				   count,dsa_bits[j],d);
			dsa_results[j][0]=d/(double)count;
			rsa_count=count;
d1049 5
d1055 4
a1058 3
		ret=DSA_verify(EVP_PKEY_DSA,buf,20,buf2,
			kk,dsa_key[j]);
		if (ret <= 0)
d1060 3
a1062 11
			BIO_printf(bio_err,"DSA verify failure.  No DSA verify will be done.\n");
			ERR_print_errors(bio_err);
			dsa_doit[j] = 0;
			}
		else
			{
			pkey_print_message("verify","dsa",
				dsa_c[j][1],dsa_bits[j],
				DSA_SECONDS);
			Time_F(START);
			for (count=0,run=1; COND(dsa_c[j][1]); count++)
d1064 4
a1067 10
				ret=DSA_verify(EVP_PKEY_DSA,buf,20,buf2,
					kk,dsa_key[j]);
				if (ret <= 0)
					{
					BIO_printf(bio_err,
						"DSA verify failure\n");
					ERR_print_errors(bio_err);
					count=1;
					break;
					}
a1068 5
			d=Time_F(STOP);
			BIO_printf(bio_err,mr ? "+R4:%ld:%d:%.2f\n"
				   : "%ld %d bit DSA verify in %.2fs\n",
				   count,dsa_bits[j],d);
			dsa_results[j][1]=d/(double)count;
d1070 4
a1081 1
	if (rnd_fake) RAND_cleanup();
d1083 2
a1084 6
#ifdef HAVE_FORK
show_res:
#endif
	if(!mr)
		{
		fprintf(stdout,"%s\n",SSLeay_version(SSLEAY_VERSION));
d1086 4
a1089 10
		printf("options:");
		printf("%s ",BN_options());
#ifndef OPENSSL_NO_MD2
		printf("%s ",MD2_options());
#endif
#ifndef OPENSSL_NO_RC4
		printf("%s ",RC4_options());
#endif
#ifndef OPENSSL_NO_DES
		printf("%s ",DES_options());
d1091 2
a1092 2
#ifndef OPENSSL_NO_AES
		printf("%s ",AES_options());
d1094 2
a1095 2
#ifndef OPENSSL_NO_IDEA
		printf("%s ",idea_options());
d1097 2
a1098 7
#ifndef OPENSSL_NO_BF
		printf("%s ",BF_options());
#endif
		fprintf(stdout,"\n%s\n",SSLeay_version(SSLEAY_CFLAGS));
		printf("available timing options: ");
#ifdef TIMES
		printf("TIMES ");
d1100 2
a1101 2
#ifdef TIMEB
		printf("TIMEB ");
d1103 1
a1103 20
#ifdef USE_TOD
		printf("USE_TOD ");
#endif
#ifdef HZ
#define as_string(s) (#s)
		printf("HZ=%g", (double)HZ);
# ifdef _SC_CLK_TCK
		printf(" [sysconf value]");
# endif
#endif
		printf("\n");
		printf("timing function used: %s%s%s%s%s%s%s\n",
		       (ftime_used ? "ftime" : ""),
		       (ftime_used + times_used > 1 ? "," : ""),
		       (times_used ? "times" : ""),
		       (ftime_used + times_used + gettimeofday_used > 1 ? "," : ""),
		       (gettimeofday_used ? "gettimeofday" : ""),
		       (ftime_used + times_used + gettimeofday_used + getrusage_used > 1 ? "," : ""),
		       (getrusage_used ? "getrusage" : ""));
		}
d1107 2
a1108 7
		if(mr)
			fprintf(stdout,"+H");
		else
			{
			fprintf(stdout,"The 'numbers' are in 1000s of bytes per second processed.\n"); 
			fprintf(stdout,"type        ");
			}
d1110 1
a1110 1
			fprintf(stdout,mr ? ":%d" : "%7d bytes",lengths[j]);
d1117 1
a1117 4
		if(mr)
			fprintf(stdout,"+F:%d:%s",k,names[k]);
		else
			fprintf(stdout,"%-13s",names[k]);
d1120 1
a1120 1
			if (results[k][j] > 10000 && !mr)
d1123 1
a1123 1
				fprintf(stdout,mr ? ":%.2f" : " %11.2f ",results[k][j]);
d1127 1
a1127 1
#ifndef OPENSSL_NO_RSA
d1132 1
a1132 1
		if (j && !mr)
d1137 4
a1140 8
		if(mr)
			fprintf(stdout,"+F2:%u:%u:%f:%f\n",
				k,rsa_bits[k],rsa_results[k][0],
				rsa_results[k][1]);
		else
			fprintf(stdout,"rsa %4u bits %8.4fs %8.4fs %8.1f %8.1f\n",
				rsa_bits[k],rsa_results[k][0],rsa_results[k][1],
				1.0/rsa_results[k][0],1.0/rsa_results[k][1]);
d1143 1
a1143 1
#ifndef OPENSSL_NO_DSA
d1148 1
a1148 2
		if (j && !mr)
			{
d1152 4
a1155 7
		if(mr)
			fprintf(stdout,"+F3:%u:%u:%f:%f\n",
				k,dsa_bits[k],dsa_results[k][0],dsa_results[k][1]);
		else
			fprintf(stdout,"dsa %4u bits %8.4fs %8.4fs %8.1f %8.1f\n",
				dsa_bits[k],dsa_results[k][0],dsa_results[k][1],
				1.0/dsa_results[k][0],1.0/dsa_results[k][1]);
d1158 1
a1158 1
	mret=0;
d1160 3
a1162 4
	ERR_print_errors(bio_err);
	if (buf != NULL) OPENSSL_free(buf);
	if (buf2 != NULL) OPENSSL_free(buf2);
#ifndef OPENSSL_NO_RSA
d1167 1
a1167 1
#ifndef OPENSSL_NO_DSA
d1172 1
a1172 2
	apps_shutdown();
	EXIT(mret);
d1175 4
a1178 1
static void print_message(const char *s, long num, int length)
d1181 2
a1182 3
	BIO_printf(bio_err,mr ? "+DT:%s:%d:%d\n"
		   : "Doing %s for %ds on %d size blocks: ",s,SECONDS,length);
	(void)BIO_flush(bio_err);
d1185 2
a1186 3
	BIO_printf(bio_err,mr ? "+DN:%s:%ld:%d\n"
		   : "Doing %s %ld times on %d size blocks: ",s,num,length);
	(void)BIO_flush(bio_err);
d1193 6
a1198 2
static void pkey_print_message(char *str, char *str2, long num, int bits,
	     int tm)
d1201 2
a1202 3
	BIO_printf(bio_err,mr ? "+DTP:%d:%s:%s:%d\n"
			   : "Doing %d bit %s %s's for %ds: ",bits,str,str2,tm);
	(void)BIO_flush(bio_err);
d1205 2
a1206 3
	BIO_printf(bio_err,mr ? "+DNP:%ld:%d:%s:%s\n"
			   : "Doing %ld %d bit %s %s's: ",num,bits,str,str2);
	(void)BIO_flush(bio_err);
a1212 172
static void print_result(int alg,int run_no,int count,double time_used)
	{
	BIO_printf(bio_err,mr ? "+R:%ld:%s:%f\n"
		   : "%ld %s's in %.2fs\n",count,names[alg],time_used);
	results[alg][run_no]=((double)count)/time_used*lengths[run_no];
	}

static char *sstrsep(char **string, const char *delim)
    {
    char isdelim[256];
    char *token = *string;

    if (**string == 0)
        return NULL;

    memset(isdelim, 0, 256);
    isdelim[0] = 1;

    while (*delim)
        {
        isdelim[(unsigned char)(*delim)] = 1;
        delim++;
        }

    while (!isdelim[(unsigned char)(**string)])
        {
        (*string)++;
        }

    if (**string)
        {
        **string = 0;
        (*string)++;
        }

    return token;
    }

#ifdef HAVE_FORK
static int do_multi(int multi)
	{
	int n;
	int fd[2];
	int *fds;
	static char sep[]=":";

	fds=malloc(multi*sizeof *fds);
	for(n=0 ; n < multi ; ++n)
		{
		pipe(fd);
		if(fork())
			{
			close(fd[1]);
			fds[n]=fd[0];
			}
		else
			{
			close(fd[0]);
			close(1);
			dup(fd[1]);
			close(fd[1]);
			mr=1;
			usertime=0;
			return 0;
			}
		printf("Forked child %d\n",n);
		}

	/* for now, assume the pipe is long enough to take all the output */
	for(n=0 ; n < multi ; ++n)
		{
		FILE *f;
		char buf[1024];
		char *p;

		f=fdopen(fds[n],"r");
		while(fgets(buf,sizeof buf,f))
			{
			p=strchr(buf,'\n');
			if(p)
				*p='\0';
			if(buf[0] != '+')
				{
				fprintf(stderr,"Don't understand line '%s' from child %d\n",
						buf,n);
				continue;
				}
			printf("Got: %s from %d\n",buf,n);
			if(!strncmp(buf,"+F:",3))
				{
				int alg;
				int j;

				p=buf+3;
				alg=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);
				for(j=0 ; j < SIZE_NUM ; ++j)
					results[alg][j]+=atof(sstrsep(&p,sep));
				}
			else if(!strncmp(buf,"+F2:",4))
				{
				int k;
				double d;
				
				p=buf+4;
				k=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);

				d=atof(sstrsep(&p,sep));
				if(n)
					rsa_results[k][0]=1/(1/rsa_results[k][0]+1/d);
				else
					rsa_results[k][0]=d;

				d=atof(sstrsep(&p,sep));
				if(n)
					rsa_results[k][1]=1/(1/rsa_results[k][1]+1/d);
				else
					rsa_results[k][1]=d;
				}
			else if(!strncmp(buf,"+F2:",4))
				{
				int k;
				double d;
				
				p=buf+4;
				k=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);

				d=atof(sstrsep(&p,sep));
				if(n)
					rsa_results[k][0]=1/(1/rsa_results[k][0]+1/d);
				else
					rsa_results[k][0]=d;

				d=atof(sstrsep(&p,sep));
				if(n)
					rsa_results[k][1]=1/(1/rsa_results[k][1]+1/d);
				else
					rsa_results[k][1]=d;
				}
			else if(!strncmp(buf,"+F3:",4))
				{
				int k;
				double d;
				
				p=buf+4;
				k=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);

				d=atof(sstrsep(&p,sep));
				if(n)
					dsa_results[k][0]=1/(1/dsa_results[k][0]+1/d);
				else
					dsa_results[k][0]=d;

				d=atof(sstrsep(&p,sep));
				if(n)
					dsa_results[k][1]=1/(1/dsa_results[k][1]+1/d);
				else
					dsa_results[k][1]=d;
				}
			else if(!strncmp(buf,"+H:",3))
				{
				}
			else
				fprintf(stderr,"Unknown type '%s' from child %d\n",buf,n);
			}
		}
	return 1;
	}
#endif
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@a60 2
#ifndef OPENSSL_NO_SPEED

d190 1
a190 2
# if defined(_SC_CLK_TCK) \
     && (!defined(OPENSSL_SYS_VMS) || __CTRL_VER >= 70000000)
a371 1
#ifndef OPENSSL_NO_ENGINE
a372 1
#endif
a591 1
#ifndef OPENSSL_NO_ENGINE
a607 1
#endif
d864 1
a864 1
#if defined(TIMES) || defined(USE_TOD)
a866 1
#ifndef OPENSSL_NO_ENGINE
a867 1
#endif
a1394 1
				EVP_CIPHER_CTX_cleanup(&ctx);
d1731 1
a1731 1
	OPENSSL_EXIT(mret);
d1784 1
a1784 1
    memset(isdelim, 0, sizeof isdelim);
a1939 1
#endif
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@a775 1
			dsa_doit[R_DSA_2048]=1;
a1008 3
	c[D_CBC_128_AES][0]=count;
	c[D_CBC_192_AES][0]=count;
	c[D_CBC_256_AES][0]=count;
a1033 3
		c[D_CBC_128_AES][i]=c[D_CBC_128_AES][i-1]*l0/l1;
		c[D_CBC_192_AES][i]=c[D_CBC_192_AES][i-1]*l0/l1;
		c[D_CBC_256_AES][i]=c[D_CBC_256_AES][i-1]*l0/l1;
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a1397 1
				EVP_CIPHER_CTX_set_padding(&ctx, 0);
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@d1709 1
a1709 1
			fprintf(stdout,"rsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\n",
d1728 1
a1728 1
			fprintf(stdout,"dsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\n",
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@a57 13
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * Portions of the attached software ("Contribution") are developed by 
 * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
 *
 * The Contribution is licensed pursuant to the OpenSSL open source
 * license provided above.
 *
 * The ECDH and ECDSA speed test software is originally written by 
 * Sumit Gupta of Sun Microsystems Laboratories.
 *
 */
a66 2
#define ECDSA_SECONDS   10
#define ECDH_SECONDS    10
d76 1
a76 1

a91 4
#ifndef OPENSSL_SYS_NETWARE
#include <signal.h>
#endif

a100 6
#if defined(OPENSSL_SYS_NETWARE)
#undef TIMES
#undef TIMEB
#include <time.h>
#endif

d125 1
a125 1
#if !defined(TIMES) && !defined(TIMEB) && !defined(USE_TOD) && !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_NETWARE)
a134 1
#include <openssl/bn.h>
a140 3
#ifndef OPENSSL_NO_CAMELLIA
#include <openssl/camellia.h>
#endif
a174 3
#ifndef OPENSSL_NO_SEED
#include <openssl/seed.h>
#endif
a186 1
#include <openssl/dsa.h>
a188 16
#ifndef OPENSSL_NO_ECDSA
#include <openssl/ecdsa.h>
#endif
#ifndef OPENSSL_NO_ECDH
#include <openssl/ecdh.h>
#endif

/*
 * The following "HZ" timing stuff should be sync'd up with the code in
 * crypto/tmdiff.[ch]. That appears to try to do the same job, though I think
 * this code is more up to date than libcrypto's so there may be features to
 * migrate over first. This is used in two places further down AFAICS. 
 * The point is that nothing in openssl actually *uses* that tmdiff stuff, so
 * either speed.c should be using it or it should go because it's obviously not
 * useful enough. Anyone want to do a janitorial job on this?
 */
d194 1
a194 1
#  define HZ sysconf(_SC_CLK_TCK)
d208 1
a208 1
#if !defined(OPENSSL_SYS_VMS) && !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MACINTOSH_CLASSIC) && !defined(OPENSSL_SYS_OS2) && !defined(OPENSSL_SYS_NETWARE)
d222 1
a222 2
static void pkey_print_message(const char *str, const char *str2,
	long num, int bits, int sec);
d228 1
a228 1
#define ALGOR_NUM	28
a231 4

#define EC_NUM       16
#define MAX_ECDH_SIZE 256

d234 1
a234 1
  "des cbc","des ede3","idea cbc","seed cbc",
d236 1
a236 4
  "aes-128 cbc","aes-192 cbc","aes-256 cbc",
  "camellia-128 cbc","camellia-192 cbc","camellia-256 cbc",
  "evp","sha256","sha512",
  "aes-128 ige","aes-192 ige","aes-256 ige"};
a240 11
#ifndef OPENSSL_NO_ECDSA
static double ecdsa_results[EC_NUM][2];
#endif
#ifndef OPENSSL_NO_ECDH
static double ecdh_results[EC_NUM][1];
#endif

#if defined(OPENSSL_NO_DSA) && !(defined(OPENSSL_NO_ECDSA) && defined(OPENSSL_NO_ECDH))
static const char rnd_seed[] = "string to make the random number generator think it has entropy";
static int rnd_fake = 0;
#endif
a262 26
#if defined(OPENSSL_SYS_NETWARE)

   /* for NetWare the best we can do is use clock() which returns the
    * time, in hundredths of a second, since the NLM began executing
   */
static double Time_F(int s)
	{
	double ret;

   static clock_t tstart,tend;

   if (s == START)
   {
      tstart=clock();
      return(0);
   }
   else
   {
      tend=clock();
      ret=(double)((double)(tend)-(double)(tstart));
      return((ret < 0.001)?0.001:ret);
   }
   }

#else

d269 1
a269 1
		{
d324 1
a324 2
			ret = HZ;
			ret=(double)(tend.tms_utime-tstart.tms_utime) / ret;
a369 19
#endif /* if defined(OPENSSL_SYS_NETWARE) */


#ifndef OPENSSL_NO_ECDH
static const int KDF1_SHA1_len = 20;
static void *KDF1_SHA1(const void *in, size_t inlen, void *out, size_t *outlen)
	{
#ifndef OPENSSL_NO_SHA
	if (*outlen < SHA_DIGEST_LENGTH)
		return NULL;
	else
		*outlen = SHA_DIGEST_LENGTH;
	return SHA1(in, inlen, out);
#else
	return NULL;
#endif	/* OPENSSL_NO_SHA */
	}
#endif	/* OPENSSL_NO_ECDH */

a403 6
#ifndef OPENSSL_NO_SHA256
	unsigned char sha256[SHA256_DIGEST_LENGTH];
#endif
#ifndef OPENSSL_NO_SHA512
	unsigned char sha512[SHA512_DIGEST_LENGTH];
#endif
a419 3
#ifndef OPENSSL_NO_SEED
	SEED_KEY_SCHEDULE seed_ks;
#endif
a428 1
#ifndef OPENSSL_NO_AES
a437 12
#endif
#ifndef OPENSSL_NO_CAMELLIA
	static const unsigned char ckey24[24]=
		{0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,
		 0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,
		 0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};
	static const unsigned char ckey32[32]=
		{0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,
		 0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,
		 0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34,
		 0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34,0x56};
#endif
d444 1
a444 1
	unsigned char iv[2*MAX_BLOCK_SIZE/8];
a456 3
#ifndef OPENSSL_NO_CAMELLIA
	CAMELLIA_KEY camellia_ks1, camellia_ks2, camellia_ks3;
#endif
d468 8
a475 17
#define	D_CBC_SEED	11
#define	D_CBC_RC2	12
#define	D_CBC_RC5	13
#define	D_CBC_BF	14
#define	D_CBC_CAST	15
#define D_CBC_128_AES	16
#define D_CBC_192_AES	17
#define D_CBC_256_AES	18
#define D_CBC_128_CML   19 
#define D_CBC_192_CML   20
#define D_CBC_256_CML   21 
#define D_EVP		22
#define D_SHA256	23	
#define D_SHA512	24
#define D_IGE_128_AES   25
#define D_IGE_192_AES   26
#define D_IGE_256_AES   27
a484 18

#define R_EC_P160    0
#define R_EC_P192    1	
#define R_EC_P224    2
#define R_EC_P256    3
#define R_EC_P384    4
#define R_EC_P521    5
#define R_EC_K163    6
#define R_EC_K233    7
#define R_EC_K283    8
#define R_EC_K409    9
#define R_EC_K571    10
#define R_EC_B163    11
#define R_EC_B233    12
#define R_EC_B283    13
#define R_EC_B409    14
#define R_EC_B571    15

a499 73
#ifndef OPENSSL_NO_EC
	/* We only test over the following curves as they are representative, 
	 * To add tests over more curves, simply add the curve NID
	 * and curve name to the following arrays and increase the 
	 * EC_NUM value accordingly. 
	 */
	static unsigned int test_curves[EC_NUM] = 
	{	
	/* Prime Curves */
	NID_secp160r1,
	NID_X9_62_prime192v1,
	NID_secp224r1,
	NID_X9_62_prime256v1,
	NID_secp384r1,
	NID_secp521r1,
	/* Binary Curves */
	NID_sect163k1,
	NID_sect233k1,
	NID_sect283k1,
	NID_sect409k1,
	NID_sect571k1,
	NID_sect163r2,
	NID_sect233r1,
	NID_sect283r1,
	NID_sect409r1,
	NID_sect571r1
	}; 
	static const char * test_curves_names[EC_NUM] = 
	{
	/* Prime Curves */
	"secp160r1",
	"nistp192",
	"nistp224",
	"nistp256",
	"nistp384",
	"nistp521",
	/* Binary Curves */
	"nistk163",
	"nistk233",
	"nistk283",
	"nistk409",
	"nistk571",
	"nistb163",
	"nistb233",
	"nistb283",
	"nistb409",
	"nistb571"
	};
	static int test_curves_bits[EC_NUM] =
        {
        160, 192, 224, 256, 384, 521,
        163, 233, 283, 409, 571,
        163, 233, 283, 409, 571
        };

#endif

#ifndef OPENSSL_NO_ECDSA
	unsigned char ecdsasig[256];
	unsigned int ecdsasiglen;
	EC_KEY *ecdsa[EC_NUM];
	long ecdsa_c[EC_NUM][2];
#endif

#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh_a[EC_NUM], *ecdh_b[EC_NUM];
	unsigned char secret_a[MAX_ECDH_SIZE], secret_b[MAX_ECDH_SIZE];
	int secret_size_a, secret_size_b;
	int ecdh_checks = 0;
	int secret_idx = 0;
	long ecdh_c[EC_NUM][2];
#endif

a501 6
#ifndef OPENSSL_NO_ECDSA
	int ecdsa_doit[EC_NUM];
#endif
#ifndef OPENSSL_NO_ECDH
        int ecdh_doit[EC_NUM];
#endif
a519 11
#ifndef OPENSSL_NO_ECDSA
	for (i=0; i<EC_NUM; i++) ecdsa[i] = NULL;
#endif
#ifndef OPENSSL_NO_ECDH
	for (i=0; i<EC_NUM; i++)
		{
		ecdh_a[i] = NULL;
		ecdh_b[i] = NULL;
		}
#endif

a557 9
#ifndef OPENSSL_NO_ECDSA
	for (i=0; i<EC_NUM; i++)
		ecdsa_doit[i]=0;
#endif
#ifndef OPENSSL_NO_ECDH
	for (i=0; i<EC_NUM; i++)
		ecdh_doit[i]=0;
#endif

d665 1
a665 6
			if (strcmp(*argv,"sha") == 0)	doit[D_SHA1]=1,
							doit[D_SHA256]=1,
							doit[D_SHA512]=1;
		else
#ifndef OPENSSL_NO_SHA256
			if (strcmp(*argv,"sha256") == 0) doit[D_SHA256]=1;
a667 5
#ifndef OPENSSL_NO_SHA512
			if (strcmp(*argv,"sha512") == 0) doit[D_SHA512]=1;
		else
#endif
#endif
a688 9
		else    if (strcmp(*argv,"aes-128-ige") == 0) doit[D_IGE_128_AES]=1;
		else	if (strcmp(*argv,"aes-192-ige") == 0) doit[D_IGE_192_AES]=1;
		else	if (strcmp(*argv,"aes-256-ige") == 0) doit[D_IGE_256_AES]=1;
                else
#endif
#ifndef OPENSSL_NO_CAMELLIA
			if (strcmp(*argv,"camellia-128-cbc") == 0) doit[D_CBC_128_CML]=1;
		else    if (strcmp(*argv,"camellia-192-cbc") == 0) doit[D_CBC_192_CML]=1;
		else    if (strcmp(*argv,"camellia-256-cbc") == 0) doit[D_CBC_256_CML]=1;
a731 5
#ifndef OPENSSL_NO_SEED
		     if (strcmp(*argv,"seed-cbc") == 0) doit[D_CBC_SEED]=1;
		else if (strcmp(*argv,"seed") == 0) doit[D_CBC_SEED]=1;
		else
#endif
a760 9
#ifndef OPENSSL_NO_CAMELLIA
			if (strcmp(*argv,"camellia") == 0)
			{
			doit[D_CBC_128_CML]=1;
			doit[D_CBC_192_CML]=1;
			doit[D_CBC_256_CML]=1;
			}
		else
#endif
a779 48
#ifndef OPENSSL_NO_ECDSA
		     if (strcmp(*argv,"ecdsap160") == 0) ecdsa_doit[R_EC_P160]=2;
		else if (strcmp(*argv,"ecdsap192") == 0) ecdsa_doit[R_EC_P192]=2;
		else if (strcmp(*argv,"ecdsap224") == 0) ecdsa_doit[R_EC_P224]=2;
		else if (strcmp(*argv,"ecdsap256") == 0) ecdsa_doit[R_EC_P256]=2;
		else if (strcmp(*argv,"ecdsap384") == 0) ecdsa_doit[R_EC_P384]=2;
		else if (strcmp(*argv,"ecdsap521") == 0) ecdsa_doit[R_EC_P521]=2;
		else if (strcmp(*argv,"ecdsak163") == 0) ecdsa_doit[R_EC_K163]=2;
		else if (strcmp(*argv,"ecdsak233") == 0) ecdsa_doit[R_EC_K233]=2;
		else if (strcmp(*argv,"ecdsak283") == 0) ecdsa_doit[R_EC_K283]=2;
		else if (strcmp(*argv,"ecdsak409") == 0) ecdsa_doit[R_EC_K409]=2;
		else if (strcmp(*argv,"ecdsak571") == 0) ecdsa_doit[R_EC_K571]=2;
		else if (strcmp(*argv,"ecdsab163") == 0) ecdsa_doit[R_EC_B163]=2;
		else if (strcmp(*argv,"ecdsab233") == 0) ecdsa_doit[R_EC_B233]=2;
		else if (strcmp(*argv,"ecdsab283") == 0) ecdsa_doit[R_EC_B283]=2;
		else if (strcmp(*argv,"ecdsab409") == 0) ecdsa_doit[R_EC_B409]=2;
		else if (strcmp(*argv,"ecdsab571") == 0) ecdsa_doit[R_EC_B571]=2;
		else if (strcmp(*argv,"ecdsa") == 0)
			{
			for (i=0; i < EC_NUM; i++)
				ecdsa_doit[i]=1;
			}
		else
#endif
#ifndef OPENSSL_NO_ECDH
		     if (strcmp(*argv,"ecdhp160") == 0) ecdh_doit[R_EC_P160]=2;
		else if (strcmp(*argv,"ecdhp192") == 0) ecdh_doit[R_EC_P192]=2;
		else if (strcmp(*argv,"ecdhp224") == 0) ecdh_doit[R_EC_P224]=2;
		else if (strcmp(*argv,"ecdhp256") == 0) ecdh_doit[R_EC_P256]=2;
		else if (strcmp(*argv,"ecdhp384") == 0) ecdh_doit[R_EC_P384]=2;
		else if (strcmp(*argv,"ecdhp521") == 0) ecdh_doit[R_EC_P521]=2;
		else if (strcmp(*argv,"ecdhk163") == 0) ecdh_doit[R_EC_K163]=2;
		else if (strcmp(*argv,"ecdhk233") == 0) ecdh_doit[R_EC_K233]=2;
		else if (strcmp(*argv,"ecdhk283") == 0) ecdh_doit[R_EC_K283]=2;
		else if (strcmp(*argv,"ecdhk409") == 0) ecdh_doit[R_EC_K409]=2;
		else if (strcmp(*argv,"ecdhk571") == 0) ecdh_doit[R_EC_K571]=2;
		else if (strcmp(*argv,"ecdhb163") == 0) ecdh_doit[R_EC_B163]=2;
		else if (strcmp(*argv,"ecdhb233") == 0) ecdh_doit[R_EC_B233]=2;
		else if (strcmp(*argv,"ecdhb283") == 0) ecdh_doit[R_EC_B283]=2;
		else if (strcmp(*argv,"ecdhb409") == 0) ecdh_doit[R_EC_B409]=2;
		else if (strcmp(*argv,"ecdhb571") == 0) ecdh_doit[R_EC_B571]=2;
		else if (strcmp(*argv,"ecdh") == 0)
			{
			for (i=0; i < EC_NUM; i++)
				ecdh_doit[i]=1;
			}
		else
#endif
a801 6
#ifndef OPENSSL_NO_SHA256
			BIO_printf(bio_err,"sha256   ");
#endif
#ifndef OPENSSL_NO_SHA512
			BIO_printf(bio_err,"sha512   ");
#endif
a813 3
#ifndef OPENSSL_NO_SEED
			BIO_printf(bio_err,"seed-cbc ");
#endif
d823 1
a823 1
#if !defined(OPENSSL_NO_IDEA) || !defined(OPENSSL_NO_SEED) || !defined(OPENSSL_NO_RC2) || \
a831 5
			BIO_printf(bio_err,"aes-128-ige aes-192-ige aes-256-ige ");
#endif
#ifndef OPENSSL_NO_CAMELLIA
			BIO_printf(bio_err,"\n");
			BIO_printf(bio_err,"camellia-128-cbc camellia-192-cbc camellia-256-cbc ");
a844 12
#ifndef OPENSSL_NO_ECDSA
			BIO_printf(bio_err,"ecdsap160 ecdsap192 ecdsap224 ecdsap256 ecdsap384 ecdsap521\n");
			BIO_printf(bio_err,"ecdsak163 ecdsak233 ecdsak283 ecdsak409 ecdsak571\n");
			BIO_printf(bio_err,"ecdsab163 ecdsab233 ecdsab283 ecdsab409 ecdsab571\n");
			BIO_printf(bio_err,"ecdsa\n");
#endif
#ifndef OPENSSL_NO_ECDH
			BIO_printf(bio_err,"ecdhp160  ecdhp192  ecdhp224  ecdhp256  ecdhp384  ecdhp521\n");
			BIO_printf(bio_err,"ecdhk163  ecdhk233  ecdhk283  ecdhk409  ecdhk571\n");
			BIO_printf(bio_err,"ecdhb163  ecdhb233  ecdhb283  ecdhb409  ecdhb571\n");
			BIO_printf(bio_err,"ecdh\n");
#endif
a848 3
#ifndef OPENSSL_NO_SEED
			BIO_printf(bio_err,"seed     ");
#endif
a857 3
#ifndef OPENSSL_NO_CAMELLIA
			BIO_printf(bio_err,"camellia ");
#endif
d864 3
a866 4
#if !defined(OPENSSL_NO_IDEA) || !defined(OPENSSL_NO_SEED) || \
    !defined(OPENSSL_NO_RC2) || !defined(OPENSSL_NO_DES) || \
    !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_BF) || \
    !defined(OPENSSL_NO_AES) || !defined(OPENSSL_NO_CAMELLIA)
a959 5
#ifndef OPENSSL_NO_CAMELLIA
	Camellia_set_key(key16,128,&camellia_ks1);
	Camellia_set_key(ckey24,192,&camellia_ks2);
	Camellia_set_key(ckey32,256,&camellia_ks3);
#endif
a962 3
#ifndef OPENSSL_NO_SEED
	SEED_set_key(key16,&seed_ks);
#endif
d986 1
a986 1
		long it;
d989 1
a989 1
		for (it=count; it; it--)
a1005 1
	c[D_CBC_SEED][0]=count;
a1012 8
	c[D_CBC_128_CML][0]=count;
	c[D_CBC_192_CML][0]=count;
	c[D_CBC_256_CML][0]=count;
	c[D_SHA256][0]=count;
	c[D_SHA512][0]=count;
	c[D_IGE_128_AES][0]=count;
	c[D_IGE_192_AES][0]=count;
	c[D_IGE_256_AES][0]=count;
a1022 2
		c[D_SHA256][i]=c[D_SHA256][0]*4*lengths[0]/lengths[i];
		c[D_SHA512][i]=c[D_SHA512][0]*4*lengths[0]/lengths[i];
a1033 1
		c[D_CBC_SEED][i]=c[D_CBC_SEED][i-1]*l0/l1;
a1040 6
 		c[D_CBC_128_CML][i]=c[D_CBC_128_CML][i-1]*l0/l1;
		c[D_CBC_192_CML][i]=c[D_CBC_192_CML][i-1]*l0/l1;
		c[D_CBC_256_CML][i]=c[D_CBC_256_CML][i-1]*l0/l1;
		c[D_IGE_128_AES][i]=c[D_IGE_128_AES][i-1]*l0/l1;
		c[D_IGE_192_AES][i]=c[D_IGE_192_AES][i-1]*l0/l1;
		c[D_IGE_256_AES][i]=c[D_IGE_256_AES][i-1]*l0/l1;
a1081 108
#ifndef OPENSSL_NO_ECDSA
	ecdsa_c[R_EC_P160][0]=count/1000;
	ecdsa_c[R_EC_P160][1]=count/1000/2;
	for (i=R_EC_P192; i<=R_EC_P521; i++)
		{
		ecdsa_c[i][0]=ecdsa_c[i-1][0]/2;
		ecdsa_c[i][1]=ecdsa_c[i-1][1]/2;
		if ((ecdsa_doit[i] <= 1) && (ecdsa_c[i][0] == 0))
			ecdsa_doit[i]=0;
		else
			{
			if (ecdsa_c[i] == 0)
				{
				ecdsa_c[i][0]=1;
				ecdsa_c[i][1]=1;
				}
			}
		}
	ecdsa_c[R_EC_K163][0]=count/1000;
	ecdsa_c[R_EC_K163][1]=count/1000/2;
	for (i=R_EC_K233; i<=R_EC_K571; i++)
		{
		ecdsa_c[i][0]=ecdsa_c[i-1][0]/2;
		ecdsa_c[i][1]=ecdsa_c[i-1][1]/2;
		if ((ecdsa_doit[i] <= 1) && (ecdsa_c[i][0] == 0))
			ecdsa_doit[i]=0;
		else
			{
			if (ecdsa_c[i] == 0)
				{
				ecdsa_c[i][0]=1;
				ecdsa_c[i][1]=1;
				}
			}
		}
	ecdsa_c[R_EC_B163][0]=count/1000;
	ecdsa_c[R_EC_B163][1]=count/1000/2;
	for (i=R_EC_B233; i<=R_EC_B571; i++)
		{
		ecdsa_c[i][0]=ecdsa_c[i-1][0]/2;
		ecdsa_c[i][1]=ecdsa_c[i-1][1]/2;
		if ((ecdsa_doit[i] <= 1) && (ecdsa_c[i][0] == 0))
			ecdsa_doit[i]=0;
		else
			{
			if (ecdsa_c[i] == 0)
				{
				ecdsa_c[i][0]=1;
				ecdsa_c[i][1]=1;
				}
			}
		}
#endif

#ifndef OPENSSL_NO_ECDH
	ecdh_c[R_EC_P160][0]=count/1000;
	ecdh_c[R_EC_P160][1]=count/1000;
	for (i=R_EC_P192; i<=R_EC_P521; i++)
		{
		ecdh_c[i][0]=ecdh_c[i-1][0]/2;
		ecdh_c[i][1]=ecdh_c[i-1][1]/2;
		if ((ecdh_doit[i] <= 1) && (ecdh_c[i][0] == 0))
			ecdh_doit[i]=0;
		else
			{
			if (ecdh_c[i] == 0)
				{
				ecdh_c[i][0]=1;
				ecdh_c[i][1]=1;
				}
			}
		}
	ecdh_c[R_EC_K163][0]=count/1000;
	ecdh_c[R_EC_K163][1]=count/1000;
	for (i=R_EC_K233; i<=R_EC_K571; i++)
		{
		ecdh_c[i][0]=ecdh_c[i-1][0]/2;
		ecdh_c[i][1]=ecdh_c[i-1][1]/2;
		if ((ecdh_doit[i] <= 1) && (ecdh_c[i][0] == 0))
			ecdh_doit[i]=0;
		else
			{
			if (ecdh_c[i] == 0)
				{
				ecdh_c[i][0]=1;
				ecdh_c[i][1]=1;
				}
			}
		}
	ecdh_c[R_EC_B163][0]=count/1000;
	ecdh_c[R_EC_B163][1]=count/1000;
	for (i=R_EC_B233; i<=R_EC_B571; i++)
		{
		ecdh_c[i][0]=ecdh_c[i-1][0]/2;
		ecdh_c[i][1]=ecdh_c[i-1][1]/2;
		if ((ecdh_doit[i] <= 1) && (ecdh_c[i][0] == 0))
			ecdh_doit[i]=0;
		else
			{
			if (ecdh_c[i] == 0)
				{
				ecdh_c[i][0]=1;
				ecdh_c[i][1]=1;
				}
			}
		}
#endif

a1190 31

#ifndef OPENSSL_NO_SHA256
	if (doit[D_SHA256])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_SHA256],c[D_SHA256][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_SHA256][j]); count++)
				SHA256(buf,lengths[j],sha256);
			d=Time_F(STOP);
			print_result(D_SHA256,j,count,d);
			}
		}
#endif

#ifndef OPENSSL_NO_SHA512
	if (doit[D_SHA512])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_SHA512],c[D_SHA512][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_SHA512][j]); count++)
				SHA512(buf,lengths[j],sha512);
			d=Time_F(STOP);
			print_result(D_SHA512,j,count,d);
			}
		}
#endif

a1294 87
	if (doit[D_IGE_128_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_IGE_128_AES],c[D_IGE_128_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_IGE_128_AES][j]); count++)
				AES_ige_encrypt(buf,buf2,
					(unsigned long)lengths[j],&aes_ks1,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_IGE_128_AES,j,count,d);
			}
		}
	if (doit[D_IGE_192_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_IGE_192_AES],c[D_IGE_192_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_IGE_192_AES][j]); count++)
				AES_ige_encrypt(buf,buf2,
					(unsigned long)lengths[j],&aes_ks2,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_IGE_192_AES,j,count,d);
			}
		}
	if (doit[D_IGE_256_AES])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_IGE_256_AES],c[D_IGE_256_AES][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_IGE_256_AES][j]); count++)
				AES_ige_encrypt(buf,buf2,
					(unsigned long)lengths[j],&aes_ks3,
					iv,AES_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_IGE_256_AES,j,count,d);
			}
		}
#endif
#ifndef OPENSSL_NO_CAMELLIA
	if (doit[D_CBC_128_CML])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_128_CML],c[D_CBC_128_CML][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_128_CML][j]); count++)
				Camellia_cbc_encrypt(buf,buf,
				        (unsigned long)lengths[j],&camellia_ks1,
				        iv,CAMELLIA_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_128_CML,j,count,d);
			}
		}
	if (doit[D_CBC_192_CML])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_192_CML],c[D_CBC_192_CML][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_192_CML][j]); count++)
				Camellia_cbc_encrypt(buf,buf,
				        (unsigned long)lengths[j],&camellia_ks2,
				        iv,CAMELLIA_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_192_CML,j,count,d);
			}
		}
	if (doit[D_CBC_256_CML])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_256_CML],c[D_CBC_256_CML][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_256_CML][j]); count++)
				Camellia_cbc_encrypt(buf,buf,
				        (unsigned long)lengths[j],&camellia_ks3,
				        iv,CAMELLIA_ENCRYPT);
			d=Time_F(STOP);
			print_result(D_CBC_256_CML,j,count,d);
			}
		}

a1311 15
#ifndef OPENSSL_NO_SEED
	if (doit[D_CBC_SEED])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_CBC_SEED],c[D_CBC_SEED][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_CBC_SEED][j]); count++)
				SEED_cbc_encrypt(buf,buf,
					(unsigned long)lengths[j],&seed_ks,iv,1);
			d=Time_F(STOP);
			print_result(D_CBC_SEED,j,count,d);
			}
		}
#endif
a1607 211

#ifndef OPENSSL_NO_ECDSA
	if (RAND_status() != 1) 
		{
		RAND_seed(rnd_seed, sizeof rnd_seed);
		rnd_fake = 1;
		}
	for (j=0; j<EC_NUM; j++) 
		{
		int ret;

		if (!ecdsa_doit[j]) continue; /* Ignore Curve */ 
		ecdsa[j] = EC_KEY_new_by_curve_name(test_curves[j]);
		if (ecdsa[j] == NULL) 
			{
			BIO_printf(bio_err,"ECDSA failure.\n");
			ERR_print_errors(bio_err);
			rsa_count=1;
			} 
		else 
			{
#if 1
			EC_KEY_precompute_mult(ecdsa[j], NULL);
#endif
			/* Perform ECDSA signature test */
			EC_KEY_generate_key(ecdsa[j]);
			ret = ECDSA_sign(0, buf, 20, ecdsasig, 
				&ecdsasiglen, ecdsa[j]);
			if (ret == 0) 
				{
				BIO_printf(bio_err,"ECDSA sign failure.  No ECDSA sign will be done.\n");
				ERR_print_errors(bio_err);
				rsa_count=1;
				} 
			else 
				{
				pkey_print_message("sign","ecdsa",
					ecdsa_c[j][0], 
					test_curves_bits[j],
					ECDSA_SECONDS);

				Time_F(START);
				for (count=0,run=1; COND(ecdsa_c[j][0]);
					count++) 
					{
					ret=ECDSA_sign(0, buf, 20, 
						ecdsasig, &ecdsasiglen,
						ecdsa[j]);
					if (ret == 0) 
						{
						BIO_printf(bio_err, "ECDSA sign failure\n");
						ERR_print_errors(bio_err);
						count=1;
						break;
						}
					}
				d=Time_F(STOP);

				BIO_printf(bio_err, mr ? "+R5:%ld:%d:%.2f\n" :
					"%ld %d bit ECDSA signs in %.2fs \n", 
					count, test_curves_bits[j], d);
				ecdsa_results[j][0]=d/(double)count;
				rsa_count=count;
				}

			/* Perform ECDSA verification test */
			ret=ECDSA_verify(0, buf, 20, ecdsasig, 
				ecdsasiglen, ecdsa[j]);
			if (ret != 1) 
				{
				BIO_printf(bio_err,"ECDSA verify failure.  No ECDSA verify will be done.\n");
				ERR_print_errors(bio_err);
				ecdsa_doit[j] = 0;
				} 
			else 
				{
				pkey_print_message("verify","ecdsa",
				ecdsa_c[j][1],
				test_curves_bits[j],
				ECDSA_SECONDS);
				Time_F(START);
				for (count=0,run=1; COND(ecdsa_c[j][1]); count++) 
					{
					ret=ECDSA_verify(0, buf, 20, ecdsasig, ecdsasiglen, ecdsa[j]);
					if (ret != 1) 
						{
						BIO_printf(bio_err, "ECDSA verify failure\n");
						ERR_print_errors(bio_err);
						count=1;
						break;
						}
					}
				d=Time_F(STOP);
				BIO_printf(bio_err, mr? "+R6:%ld:%d:%.2f\n"
						: "%ld %d bit ECDSA verify in %.2fs\n",
				count, test_curves_bits[j], d);
				ecdsa_results[j][1]=d/(double)count;
				}

			if (rsa_count <= 1) 
				{
				/* if longer than 10s, don't do any more */
				for (j++; j<EC_NUM; j++)
				ecdsa_doit[j]=0;
				}
			}
		}
	if (rnd_fake) RAND_cleanup();
#endif

#ifndef OPENSSL_NO_ECDH
	if (RAND_status() != 1)
		{
		RAND_seed(rnd_seed, sizeof rnd_seed);
		rnd_fake = 1;
		}
	for (j=0; j<EC_NUM; j++)
		{
		if (!ecdh_doit[j]) continue;
		ecdh_a[j] = EC_KEY_new_by_curve_name(test_curves[j]);
		ecdh_b[j] = EC_KEY_new_by_curve_name(test_curves[j]);
		if ((ecdh_a[j] == NULL) || (ecdh_b[j] == NULL))
			{
			BIO_printf(bio_err,"ECDH failure.\n");
			ERR_print_errors(bio_err);
			rsa_count=1;
			}
		else
			{
			/* generate two ECDH key pairs */
			if (!EC_KEY_generate_key(ecdh_a[j]) ||
				!EC_KEY_generate_key(ecdh_b[j]))
				{
				BIO_printf(bio_err,"ECDH key generation failure.\n");
				ERR_print_errors(bio_err);
				rsa_count=1;		
				}
			else
				{
				/* If field size is not more than 24 octets, then use SHA-1 hash of result;
				 * otherwise, use result (see section 4.8 of draft-ietf-tls-ecc-03.txt).
				 */
				int field_size, outlen;
				void *(*kdf)(const void *in, size_t inlen, void *out, size_t *xoutlen);
				field_size = EC_GROUP_get_degree(EC_KEY_get0_group(ecdh_a[j]));
				if (field_size <= 24 * 8)
					{
					outlen = KDF1_SHA1_len;
					kdf = KDF1_SHA1;
					}
				else
					{
					outlen = (field_size+7)/8;
					kdf = NULL;
					}
				secret_size_a = ECDH_compute_key(secret_a, outlen,
					EC_KEY_get0_public_key(ecdh_b[j]),
					ecdh_a[j], kdf);
				secret_size_b = ECDH_compute_key(secret_b, outlen,
					EC_KEY_get0_public_key(ecdh_a[j]),
					ecdh_b[j], kdf);
				if (secret_size_a != secret_size_b) 
					ecdh_checks = 0;
				else
					ecdh_checks = 1;

				for (secret_idx = 0; 
				    (secret_idx < secret_size_a)
					&& (ecdh_checks == 1);
				    secret_idx++)
					{
					if (secret_a[secret_idx] != secret_b[secret_idx])
					ecdh_checks = 0;
					}

				if (ecdh_checks == 0)
					{
					BIO_printf(bio_err,"ECDH computations don't match.\n");
					ERR_print_errors(bio_err);
					rsa_count=1;		
					}

				pkey_print_message("","ecdh",
				ecdh_c[j][0], 
				test_curves_bits[j],
				ECDH_SECONDS);
				Time_F(START);
				for (count=0,run=1; COND(ecdh_c[j][0]); count++)
					{
					ECDH_compute_key(secret_a, outlen,
					EC_KEY_get0_public_key(ecdh_b[j]),
					ecdh_a[j], kdf);
					}
				d=Time_F(STOP);
				BIO_printf(bio_err, mr ? "+R7:%ld:%d:%.2f\n" :"%ld %d-bit ECDH ops in %.2fs\n",
				count, test_curves_bits[j], d);
				ecdh_results[j][0]=d/(double)count;
				rsa_count=count;
				}
			}


		if (rsa_count <= 1)
			{
			/* if longer than 10s, don't do any more */
			for (j++; j<EC_NUM; j++)
			ecdh_doit[j]=0;
			}
		}
	if (rnd_fake) RAND_cleanup();
#endif
d1648 1
a1648 4
		{
		double dbl = HZ;
		printf("HZ=%g", dbl);
		}
a1732 49
#ifndef OPENSSL_NO_ECDSA
	j=1;
	for (k=0; k<EC_NUM; k++)
		{
		if (!ecdsa_doit[k]) continue;
		if (j && !mr)
			{
			printf("%30ssign    verify    sign/s verify/s\n"," ");
			j=0;
			}

		if (mr)
			fprintf(stdout,"+F4:%u:%u:%f:%f\n", 
				k, test_curves_bits[k],
				ecdsa_results[k][0],ecdsa_results[k][1]);
		else
			fprintf(stdout,
				"%4u bit ecdsa (%s) %8.4fs %8.4fs %8.1f %8.1f\n", 
				test_curves_bits[k],
				test_curves_names[k],
				ecdsa_results[k][0],ecdsa_results[k][1], 
				1.0/ecdsa_results[k][0],1.0/ecdsa_results[k][1]);
		}
#endif


#ifndef OPENSSL_NO_ECDH
	j=1;
	for (k=0; k<EC_NUM; k++)
		{
		if (!ecdh_doit[k]) continue;
		if (j && !mr)
			{
			printf("%30sop      op/s\n"," ");
			j=0;
			}
		if (mr)
			fprintf(stdout,"+F5:%u:%u:%f:%f\n",
				k, test_curves_bits[k],
				ecdh_results[k][0], 1.0/ecdh_results[k][0]);

		else
			fprintf(stdout,"%4u bit ecdh (%s) %8.4fs %8.1f\n",
				test_curves_bits[k],
				test_curves_names[k],
				ecdh_results[k][0], 1.0/ecdh_results[k][0]);
		}
#endif

a1733 1

a1747 16

#ifndef OPENSSL_NO_ECDSA
	for (i=0; i<EC_NUM; i++)
		if (ecdsa[i] != NULL)
			EC_KEY_free(ecdsa[i]);
#endif
#ifndef OPENSSL_NO_ECDH
	for (i=0; i<EC_NUM; i++)
	{
		if (ecdh_a[i] != NULL)
			EC_KEY_free(ecdh_a[i]);
		if (ecdh_b[i] != NULL)
			EC_KEY_free(ecdh_b[i]);
	}
#endif

d1769 2
a1770 2
static void pkey_print_message(const char *str, const char *str2, long num,
	int bits, int tm)
d1789 2
a1790 2
	BIO_printf(bio_err,mr ? "+R:%d:%s:%f\n"
		   : "%d %s's in %.2fs\n",count,names[alg],time_used);
a1793 1
#ifdef HAVE_FORK
d1825 1
a1948 43
#ifndef OPENSSL_NO_ECDSA
			else if(!strncmp(buf,"+F4:",4))
				{
				int k;
				double d;
				
				p=buf+4;
				k=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);

				d=atof(sstrsep(&p,sep));
				if(n)
					ecdsa_results[k][0]=1/(1/ecdsa_results[k][0]+1/d);
				else
					ecdsa_results[k][0]=d;

				d=atof(sstrsep(&p,sep));
				if(n)
					ecdsa_results[k][1]=1/(1/ecdsa_results[k][1]+1/d);
				else
					ecdsa_results[k][1]=d;
				}
#endif 

#ifndef OPENSSL_NO_ECDH
			else if(!strncmp(buf,"+F5:",4))
				{
				int k;
				double d;
				
				p=buf+4;
				k=atoi(sstrsep(&p,sep));
				sstrsep(&p,sep);

				d=atof(sstrsep(&p,sep));
				if(n)
					ecdh_results[k][0]=1/(1/ecdh_results[k][0]+1/d);
				else
					ecdh_results[k][0]=d;

				}
#endif

@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@d2135 1
a2135 1
				if (ret <= 0)
a2762 2
		fflush(stdout);
		fflush(stderr);
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d111 47
a157 2
#ifdef _WIN32
#include <windows.h>
a191 3
#ifndef OPENSSL_NO_WHIRLPOOL
#include <openssl/whrlpool.h>
#endif
d229 15
a243 3
#ifndef HAVE_FORK
# if defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MACINTOSH_CLASSIC) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_NETWARE)
#  define HAVE_FORK 0
d245 9
a253 1
#  define HAVE_FORK 1
d257 2
a258 4
#if HAVE_FORK
#undef NO_FORK
#else
#define NO_FORK
d265 1
d274 1
a274 1
#ifndef NO_FORK
d278 1
a278 1
#define ALGOR_NUM	29
d292 1
a292 1
  "evp","sha256","sha512","whirlpool",
a295 1
#ifndef OPENSSL_NO_RSA
a296 2
#endif
#ifndef OPENSSL_NO_DSA
a297 1
#endif
d331 10
a340 1
#if defined(_WIN32)
d342 12
a353 3
#define SIGALRM
static unsigned int lapse,schlock;
static void alarm(unsigned int secs) { lapse = secs*1000; }
d355 1
a355 7
static DWORD WINAPI sleepy(VOID *arg)
	{
	schlock = 1;
	Sleep(lapse);
	run = 0;
	return 0;
	}
d359 25
a383 1
	if (s == START)
d385 10
a394 4
		HANDLE	thr;
		schlock = 0;
		thr = CreateThread(NULL,4096,sleepy,NULL,0,NULL);
		if (thr==NULL)
d396 4
a399 3
			DWORD ret=GetLastError();
			BIO_printf(bio_err,"unable to CreateThread (%d)",ret);
			ExitProcess(ret);
a400 2
		CloseHandle(thr);		/* detach the thread	*/
		while (!schlock) Sleep(0);	/* scheduler spinlock	*/
d402 6
d409 38
a446 3
	return app_tminterval(s,usertime);
	}
#else
d448 16
a463 3
static double Time_F(int s)
	{
	return app_tminterval(s,usertime);
d465 1
a465 1
#endif
a524 3
#ifndef OPENSSL_NO_WHIRLPOOL
	unsigned char whirlpool[WHIRLPOOL_DIGEST_LENGTH];
#endif
d621 3
a623 4
#define D_WHIRLPOOL	25
#define D_IGE_128_AES   26
#define D_IGE_192_AES   27
#define D_IGE_256_AES   28
d752 1
a752 1
#ifndef NO_FORK
d880 1
a880 1
#ifndef NO_FORK
a942 4
#ifndef OPENSSL_NO_WHIRLPOOL
			if (strcmp(*argv,"whirlpool") == 0) doit[D_WHIRLPOOL]=1;
		else
#endif
a1153 3
#ifndef OPENSSL_NO_WHIRLPOOL
			BIO_printf(bio_err,"whirlpool");
#endif
d1159 1
a1159 2
    !defined(OPENSSL_NO_SHA1) || !defined(OPENSSL_NO_RIPEMD160) || \
    !defined(OPENSSL_NO_WHIRLPOOL)
d1260 1
a1260 1
#ifndef NO_FORK
d1270 1
a1270 1
#ifndef NO_FORK
a1285 8
#ifndef OPENSSL_NO_ECDSA
		for (i=0; i<EC_NUM; i++)
			ecdsa_doit[i]=1;
#endif
#ifndef OPENSSL_NO_ECDH
		for (i=0; i<EC_NUM; i++)
			ecdh_doit[i]=1;
#endif
d1292 5
a1405 1
	c[D_WHIRLPOOL][0]=count;
a1420 1
		c[D_WHIRLPOOL][i]=c[D_WHIRLPOOL][0]*4*lengths[0]/lengths[i];
a1603 1
#ifndef _WIN32
a1604 1
#endif
a1733 1
#endif
a1734 13
#ifndef OPENSSL_NO_WHIRLPOOL
	if (doit[D_WHIRLPOOL])
		{
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_WHIRLPOOL],c[D_WHIRLPOOL][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_WHIRLPOOL][j]); count++)
				WHIRLPOOL(buf,lengths[j],whirlpool);
			d=Time_F(STOP);
			print_result(D_WHIRLPOOL,j,count,d);
			}
		}
a1735 1

a1880 2


d2465 1
a2465 1
#ifndef NO_FORK
d2493 29
d2720 1
a2720 1
#ifndef NO_FORK
a2777 1
			free(fds);
a2925 2

		fclose(f);
a2926 1
	free(fds);
@


1.1.1.10
log
@import OpenSSL 1.0.0e
@
text
@d337 3
d433 1
d647 3
d724 1
a724 1
                        setup_engine(bio_err, *argv, 0);
d1240 1
a1240 2
			DES_ecb_encrypt((DES_cblock *)buf,
				(DES_cblock *)buf,
a2711 1
#ifndef OPENSSL_NO_DSA
a2732 1
#endif
@


1.1.1.11
log
@import OpenSSL-1.0.1c
@
text
@d111 1
a111 1
#if defined(_WIN32) || defined(__CYGWIN__)
a112 6
# if defined(__CYGWIN__) && !defined(_WIN32)
  /* <windows.h> should define _WIN32, which normally is mutually
   * exclusive with __CYGWIN__, but if it didn't... */
#  define _WIN32
  /* this is done because Cygwin alarm() fails sometimes. */
# endif
a185 19
#include <openssl/modes.h>

#ifdef OPENSSL_FIPS
#ifdef OPENSSL_DOING_MAKEDEPEND
#undef AES_set_encrypt_key
#undef AES_set_decrypt_key
#undef DES_set_key_unchecked
#endif
#define BF_set_key	private_BF_set_key
#define CAST_set_key	private_CAST_set_key
#define idea_set_encrypt_key	private_idea_set_encrypt_key
#define SEED_set_key	private_SEED_set_key
#define RC2_set_key	private_RC2_set_key
#define RC4_set_key	private_RC4_set_key
#define DES_set_key_unchecked	private_DES_set_key_unchecked
#define AES_set_encrypt_key	private_AES_set_encrypt_key
#define AES_set_decrypt_key	private_AES_set_decrypt_key
#define Camellia_set_key	private_Camellia_set_key
#endif
d217 1
a217 1
#define ALGOR_NUM	30
d232 1
a232 1
  "aes-128 ige","aes-192 ige","aes-256 ige","ghash"};
a275 1
#if !defined(SIGALRM)
a276 1
#endif
d278 1
a278 2
static void alarm_win32(unsigned int secs) { lapse = secs*1000; }
#define alarm alarm_win32
a471 1
#define D_GHASH		29
a896 4
		else if (strcmp(*argv,"ghash") == 0)
			{
			doit[D_GHASH]=1;
			}
a1266 1
	c[D_GHASH][0]=count;
d1461 1
a1461 1
#define COND(c)	(run && count<0x7fffffff)
a1756 4
	if (doit[D_GHASH])
		{
		GCM128_CONTEXT *ctx = CRYPTO_gcm128_new(&aes_ks1,(block128_f)AES_encrypt);
		CRYPTO_gcm128_setiv (ctx,(unsigned char *)"0123456789ab",12);
a1757 11
		for (j=0; j<SIZE_NUM; j++)
			{
			print_message(names[D_GHASH],c[D_GHASH][j],lengths[j]);
			Time_F(START);
			for (count=0,run=1; COND(c[D_GHASH][j]); count++)
				CRYPTO_gcm128_aad(ctx,buf,lengths[j]);
			d=Time_F(STOP);
			print_result(D_GHASH,j,count,d);
			}
		CRYPTO_gcm128_release(ctx);
		}
d2551 1
a2551 1
	alarm(tm);
d2611 1
a2611 5
		if (pipe(fd) == -1)
			{
			fprintf(stderr, "pipe failure\n");
			exit(1);
			}
d2623 1
a2623 5
			if (dup(fd[1]) == -1)
				{
				fprintf(stderr, "dup failed\n");
				exit(1);
				}
@


1.1.1.12
log
@Import OpenSSL 1.0.1g
@
text
@d257 1
a257 1
  "aes-128 ige","aes-192 ige","aes-256 ige","ghash" };
d302 1
a302 1
# define SIGALRM
@


