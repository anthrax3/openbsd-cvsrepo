head	1.66;
access;
symbols
	OPENBSD_5_6:1.65.0.4
	OPENBSD_5_6_BASE:1.65
	butholakala:1.25
	openssl_1_0_1_g:1.1.1.13
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	openssl_1_0_1_c:1.1.1.12
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	openssl_1_0_0_f:1.1.1.11
	openssl_1_0_0_e:1.1.1.11
	OPENBSD_5_0:1.23.0.4
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	openssh_1_0_0_a:1.1.1.11
	OPENBSD_4_8:1.22.0.6
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	openssl_0_9_8_k:1.1.1.10
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	openssl_0_9_8_j:1.1.1.9
	openssl_0_9_8_h:1.1.1.9
	pre_openssl_0_9_8h:1.20
	OPENBSD_4_4:1.20.0.8
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	openssl_0_9_7j:1.1.1.8
	openssl:1.1.1
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENSSL_0_9_7G:1.1.1.7
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENSSL_0_9_7D:1.1.1.6
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENSSL_0_9_7C:1.1.1.5
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENSSL_0_9_7B:1.1.1.5
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.4
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.66
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.65;
commitid	7A7DObXgY4Fni8xJ;

1.65
date	2014.07.29.08.51.49;	author blambert;	state Exp;
branches;
next	1.64;
commitid	AtDBKIDSKWrtcIjo;

1.64
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	EB0l28piqIRSpBUh;

1.63
date	2014.07.13.16.03.09;	author beck;	state Exp;
branches;
next	1.62;
commitid	6xdvCwSqBadTW6X3;

1.62
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.61;
commitid	0NuggCO2WJOZj8Kh;

1.61
date	2014.07.09.21.13.34;	author tedu;	state Exp;
branches;
next	1.60;
commitid	QXQcqvx7I5AtKqYK;

1.60
date	2014.06.28.04.39.41;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	gGtvlhTlvaxlmOBo;

1.59
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	mJUVYpkFBZ0Zv2bG;

1.58
date	2014.06.07.14.41.56;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	2nvnQBrv22dLtvTt;

1.57
date	2014.06.02.17.03.46;	author jsing;	state Exp;
branches;
next	1.56;
commitid	d5GcIg6nLZT1al0t;

1.56
date	2014.05.29.21.19.30;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.53;

1.53
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.52;

1.52
date	2014.05.18.16.43.18;	author jsing;	state Exp;
branches;
next	1.51;

1.51
date	2014.05.18.16.34.04;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.02.17.06.46;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.46;

1.46
date	2014.04.22.13.32.17;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2014.04.22.13.13.58;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2014.04.19.15.37.35;	author beck;	state Exp;
branches;
next	1.43;

1.43
date	2014.04.19.11.46.39;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2014.04.19.00.41.37;	author beck;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.18.18.08.36;	author lteo;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.18.04.23.53;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.18.04.17.16;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.17.21.45.45;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.17.20.58.07;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.17.13.30.32;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.17.10.50.36;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.17.10.17.56;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.16.19.36.19;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.16.16.47.20;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.13.20.37.11;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2010.10.01.22.58.50;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.25.18.32.07;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.27.05.06.54;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.10.10.23.11;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.29.05.39.15;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.06.21.08.05;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.26.18.06.46;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.04.06.55.14;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.16.09.22.51;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.10.16.31.53;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.21.01.49.11;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.01.19.51.16;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.56.53;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.29;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.06;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.14;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.06;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.06;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.29;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.34.14;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.42.37;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.34.17;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.41.28;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.36.58;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.06.27.05.05.29;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.04.06.06.30.00;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.10.01.22.54.00;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.66
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: ca.c,v 1.65 2014/07/29 08:51:49 blambert Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/* The PPKI stuff has been donated by Jeff Barber <jeffb@@issl.atl.hp.com> */

#include <sys/types.h>

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>

#include "apps.h"

#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#include <openssl/ocsp.h>
#include <openssl/pem.h>
#include <openssl/txt_db.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>

#define BASE_SECTION		"ca"

#define ENV_DEFAULT_CA		"default_ca"

#define STRING_MASK		"string_mask"
#define UTF8_IN			"utf8"

#define ENV_DIR			"dir"
#define ENV_CERTS		"certs"
#define ENV_CRL_DIR		"crl_dir"
#define ENV_CA_DB		"CA_DB"
#define ENV_NEW_CERTS_DIR	"new_certs_dir"
#define ENV_CERTIFICATE 	"certificate"
#define ENV_SERIAL		"serial"
#define ENV_CRLNUMBER		"crlnumber"
#define ENV_CRL			"crl"
#define ENV_PRIVATE_KEY		"private_key"
#define ENV_DEFAULT_DAYS 	"default_days"
#define ENV_DEFAULT_STARTDATE 	"default_startdate"
#define ENV_DEFAULT_ENDDATE 	"default_enddate"
#define ENV_DEFAULT_CRL_DAYS 	"default_crl_days"
#define ENV_DEFAULT_CRL_HOURS 	"default_crl_hours"
#define ENV_DEFAULT_MD		"default_md"
#define ENV_DEFAULT_EMAIL_DN	"email_in_dn"
#define ENV_PRESERVE		"preserve"
#define ENV_POLICY      	"policy"
#define ENV_EXTENSIONS      	"x509_extensions"
#define ENV_CRLEXT      	"crl_extensions"
#define ENV_MSIE_HACK		"msie_hack"
#define ENV_NAMEOPT		"name_opt"
#define ENV_CERTOPT		"cert_opt"
#define ENV_EXTCOPY		"copy_extensions"
#define ENV_UNIQUE_SUBJECT	"unique_subject"

#define ENV_DATABASE		"database"

/* Additional revocation information types */

#define REV_NONE		0	/* No addditional information */
#define REV_CRL_REASON		1	/* Value is CRL reason code */
#define REV_HOLD		2	/* Value is hold instruction */
#define REV_KEY_COMPROMISE	3	/* Value is cert key compromise time */
#define REV_CA_COMPROMISE	4	/* Value is CA key compromise time */

static const char *ca_usage[] = {
	"usage: ca args\n",
	"\n",
	" -verbose        - Talk a lot while doing things\n",
	" -config file    - A config file\n",
	" -name arg       - The particular CA definition to use\n",
	" -gencrl         - Generate a new CRL\n",
	" -crldays days   - Days is when the next CRL is due\n",
	" -crlhours hours - Hours is when the next CRL is due\n",
	" -startdate YYMMDDHHMMSSZ  - certificate validity notBefore\n",
	" -enddate YYMMDDHHMMSSZ    - certificate validity notAfter (overrides -days)\n",
	" -days arg       - number of days to certify the certificate for\n",
	" -md arg         - md to use, one of md2, md5, sha or sha1\n",
	" -policy arg     - The CA 'policy' to support\n",
	" -keyfile arg    - private key file\n",
	" -keyform arg    - private key file format (PEM or ENGINE)\n",
	" -key arg        - key to decode the private key if it is encrypted\n",
	" -cert file      - The CA certificate\n",
	" -selfsign       - sign a certificate with the key associated with it\n",
	" -in file        - The input PEM encoded certificate request(s)\n",
	" -out file       - Where to put the output file(s)\n",
	" -outdir dir     - Where to put output certificates\n",
	" -infiles ....   - The last argument, requests to process\n",
	" -spkac file     - File contains DN and signed public key and challenge\n",
	" -ss_cert file   - File contains a self signed cert to sign\n",
	" -preserveDN     - Don't re-order the DN\n",
	" -noemailDN      - Don't add the EMAIL field into certificate' subject\n",
	" -batch          - Don't ask questions\n",
	" -msie_hack      - msie modifications to handle all those universal strings\n",
	" -revoke file    - Revoke a certificate (given in file)\n",
	" -subj arg       - Use arg instead of request's subject\n",
	" -utf8           - input characters are UTF8 (default ASCII)\n",
	" -multivalue-rdn - enable support for multivalued RDNs\n",
	" -extensions ..  - Extension section (override value in config file)\n",
	" -extfile file   - Configuration file with X509v3 extentions to add\n",
	" -crlexts ..     - CRL extension section (override value in config file)\n",
#ifndef OPENSSL_NO_ENGINE
	" -engine e       - use engine e, possibly a hardware device.\n",
#endif
	" -status serial  - Shows certificate status given the serial number\n",
	" -updatedb       - Updates db for expired certificates\n",
	NULL
};

static void lookup_fail(const char *name, const char *tag);
static int certify(X509 ** xret, char *infile, EVP_PKEY * pkey, X509 * x509,
    const EVP_MD * dgst, STACK_OF(OPENSSL_STRING) * sigopts,
    STACK_OF(CONF_VALUE) * policy, CA_DB * db, BIGNUM * serial, char *subj,
    unsigned long chtype, int multirdn, int email_dn, char *startdate,
    char *enddate, long days, int batch, char *ext_sect, CONF * conf,
    int verbose, unsigned long certopt, unsigned long nameopt,
    int default_op, int ext_copy, int selfsign);
static int certify_cert(X509 ** xret, char *infile, EVP_PKEY * pkey,
    X509 * x509, const EVP_MD * dgst, STACK_OF(OPENSSL_STRING) * sigopts,
    STACK_OF(CONF_VALUE) * policy, CA_DB * db, BIGNUM * serial, char *subj,
    unsigned long chtype, int multirdn, int email_dn, char *startdate,
    char *enddate, long days, int batch, char *ext_sect, CONF * conf,
    int verbose, unsigned long certopt, unsigned long nameopt, int default_op,
    int ext_copy, ENGINE * e);
static int certify_spkac(X509 ** xret, char *infile, EVP_PKEY * pkey,
    X509 * x509, const EVP_MD * dgst, STACK_OF(OPENSSL_STRING) * sigopts,
    STACK_OF(CONF_VALUE) * policy, CA_DB * db, BIGNUM * serial, char *subj,
    unsigned long chtype, int multirdn, int email_dn, char *startdate,
    char *enddate, long days, char *ext_sect, CONF * conf, int verbose,
    unsigned long certopt, unsigned long nameopt, int default_op, int ext_copy);
static void write_new_certificate(BIO * bp, X509 * x, int output_der,
    int notext);
static int do_body(X509 ** xret, EVP_PKEY * pkey, X509 * x509,
    const EVP_MD * dgst, STACK_OF(OPENSSL_STRING) * sigopts,
    STACK_OF(CONF_VALUE) * policy, CA_DB * db, BIGNUM * serial, char *subj,
    unsigned long chtype, int multirdn, int email_dn, char *startdate,
    char *enddate, long days, int batch, int verbose, X509_REQ * req,
    char *ext_sect, CONF * conf, unsigned long certopt, unsigned long nameopt,
    int default_op, int ext_copy, int selfsign);
static int do_revoke(X509 * x509, CA_DB * db, int ext, char *extval);
static int get_certificate_status(const char *ser_status, CA_DB * db);
static int do_updatedb(CA_DB * db);
static int check_time_format(const char *str);
static char * bin2hex(unsigned char *, size_t);
char *make_revocation_str(int rev_type, char *rev_arg);
int make_revoked(X509_REVOKED * rev, const char *str);
int old_entry_print(BIO * bp, ASN1_OBJECT * obj, ASN1_STRING * str);
static CONF *conf = NULL;
static CONF *extconf = NULL;
static char *section = NULL;

static int preserve = 0;
static int msie_hack = 0;


int ca_main(int, char **);

int
ca_main(int argc, char **argv)
{
	ENGINE *e = NULL;
	char *key = NULL, *passargin = NULL;
	int create_ser = 0;
	int free_key = 0;
	int total = 0;
	int total_done = 0;
	int badops = 0;
	int ret = 1;
	int email_dn = 1;
	int req = 0;
	int verbose = 0;
	int gencrl = 0;
	int dorevoke = 0;
	int doupdatedb = 0;
	long crldays = 0;
	long crlhours = 0;
	long crlsec = 0;
	long errorline = -1;
	char *configfile = NULL;
	char *md = NULL;
	char *policy = NULL;
	char *keyfile = NULL;
	char *certfile = NULL;
	int keyform = FORMAT_PEM;
	char *infile = NULL;
	char *spkac_file = NULL;
	char *ss_cert_file = NULL;
	char *ser_status = NULL;
	EVP_PKEY *pkey = NULL;
	int output_der = 0;
	char *outfile = NULL;
	char *outdir = NULL;
	char *serialfile = NULL;
	char *crlnumberfile = NULL;
	char *extensions = NULL;
	char *extfile = NULL;
	char *subj = NULL;
	unsigned long chtype = MBSTRING_ASC;
	int multirdn = 0;
	char *tmp_email_dn = NULL;
	char *crl_ext = NULL;
	int rev_type = REV_NONE;
	char *rev_arg = NULL;
	BIGNUM *serial = NULL;
	BIGNUM *crlnumber = NULL;
	char *startdate = NULL;
	char *enddate = NULL;
	long days = 0;
	int batch = 0;
	int notext = 0;
	unsigned long nameopt = 0, certopt = 0;
	int default_op = 1;
	int ext_copy = EXT_COPY_NONE;
	int selfsign = 0;
	X509 *x509 = NULL, *x509p = NULL;
	X509 *x = NULL;
	BIO *in = NULL, *out = NULL, *Sout = NULL, *Cout = NULL;
	char *dbfile = NULL;
	CA_DB *db = NULL;
	X509_CRL *crl = NULL;
	X509_REVOKED *r = NULL;
	ASN1_TIME *tmptm;
	ASN1_INTEGER *tmpser;
	char *f;
	const char *p;
	char *const * pp;
	int i, j;
	const EVP_MD *dgst = NULL;
	STACK_OF(CONF_VALUE) * attribs = NULL;
	STACK_OF(X509) * cert_sk = NULL;
	STACK_OF(OPENSSL_STRING) * sigopts = NULL;
#define BSIZE 256
	char buf[3][BSIZE];
#ifndef OPENSSL_NO_ENGINE
	char *engine = NULL;
#endif
	char *tofree = NULL;
	const char *errstr = NULL;
	DB_ATTR db_attr;

	conf = NULL;
	key = NULL;
	section = NULL;

	preserve = 0;
	msie_hack = 0;

	argc--;
	argv++;
	while (argc >= 1) {
		if (strcmp(*argv, "-verbose") == 0)
			verbose = 1;
		else if (strcmp(*argv, "-config") == 0) {
			if (--argc < 1)
				goto bad;
			configfile = *(++argv);
		} else if (strcmp(*argv, "-name") == 0) {
			if (--argc < 1)
				goto bad;
			section = *(++argv);
		} else if (strcmp(*argv, "-subj") == 0) {
			if (--argc < 1)
				goto bad;
			subj = *(++argv);
			/* preserve=1; */
		} else if (strcmp(*argv, "-utf8") == 0)
			chtype = MBSTRING_UTF8;
		else if (strcmp(*argv, "-create_serial") == 0)
			create_ser = 1;
		else if (strcmp(*argv, "-multivalue-rdn") == 0)
			multirdn = 1;
		else if (strcmp(*argv, "-startdate") == 0) {
			if (--argc < 1)
				goto bad;
			startdate = *(++argv);
		} else if (strcmp(*argv, "-enddate") == 0) {
			if (--argc < 1)
				goto bad;
			enddate = *(++argv);
		} else if (strcmp(*argv, "-days") == 0) {
			if (--argc < 1)
				goto bad;
			days = strtonum(*(++argv), 0, LONG_MAX, &errstr);
			if (errstr)
				goto bad;
		} else if (strcmp(*argv, "-md") == 0) {
			if (--argc < 1)
				goto bad;
			md = *(++argv);
		} else if (strcmp(*argv, "-policy") == 0) {
			if (--argc < 1)
				goto bad;
			policy = *(++argv);
		} else if (strcmp(*argv, "-keyfile") == 0) {
			if (--argc < 1)
				goto bad;
			keyfile = *(++argv);
		} else if (strcmp(*argv, "-keyform") == 0) {
			if (--argc < 1)
				goto bad;
			keyform = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-passin") == 0) {
			if (--argc < 1)
				goto bad;
			passargin = *(++argv);
		} else if (strcmp(*argv, "-key") == 0) {
			if (--argc < 1)
				goto bad;
			key = *(++argv);
		} else if (strcmp(*argv, "-cert") == 0) {
			if (--argc < 1)
				goto bad;
			certfile = *(++argv);
		} else if (strcmp(*argv, "-selfsign") == 0)
			selfsign = 1;
		else if (strcmp(*argv, "-in") == 0) {
			if (--argc < 1)
				goto bad;
			infile = *(++argv);
			req = 1;
		} else if (strcmp(*argv, "-out") == 0) {
			if (--argc < 1)
				goto bad;
			outfile = *(++argv);
		} else if (strcmp(*argv, "-outdir") == 0) {
			if (--argc < 1)
				goto bad;
			outdir = *(++argv);
		} else if (strcmp(*argv, "-sigopt") == 0) {
			if (--argc < 1)
				goto bad;
			if (!sigopts)
				sigopts = sk_OPENSSL_STRING_new_null();
			if (!sigopts ||
			    !sk_OPENSSL_STRING_push(sigopts, *(++argv)))
				goto bad;
		} else if (strcmp(*argv, "-notext") == 0)
			notext = 1;
		else if (strcmp(*argv, "-batch") == 0)
			batch = 1;
		else if (strcmp(*argv, "-preserveDN") == 0)
			preserve = 1;
		else if (strcmp(*argv, "-noemailDN") == 0)
			email_dn = 0;
		else if (strcmp(*argv, "-gencrl") == 0)
			gencrl = 1;
		else if (strcmp(*argv, "-msie_hack") == 0)
			msie_hack = 1;
		else if (strcmp(*argv, "-crldays") == 0) {
			if (--argc < 1)
				goto bad;
			crldays = strtonum(*(++argv), 0, LONG_MAX, &errstr);
			if (errstr)
				goto bad;
		} else if (strcmp(*argv, "-crlhours") == 0) {
			if (--argc < 1)
				goto bad;
			crlhours = strtonum(*(++argv), 0, LONG_MAX, &errstr);
			if (errstr)
				goto bad;
		} else if (strcmp(*argv, "-crlsec") == 0) {
			if (--argc < 1)
				goto bad;
			crlsec = strtonum(*(++argv), 0, LONG_MAX, &errstr);
			if (errstr)
				goto bad;
		} else if (strcmp(*argv, "-infiles") == 0) {
			argc--;
			argv++;
			req = 1;
			break;
		} else if (strcmp(*argv, "-ss_cert") == 0) {
			if (--argc < 1)
				goto bad;
			ss_cert_file = *(++argv);
			req = 1;
		} else if (strcmp(*argv, "-spkac") == 0) {
			if (--argc < 1)
				goto bad;
			spkac_file = *(++argv);
			req = 1;
		} else if (strcmp(*argv, "-revoke") == 0) {
			if (--argc < 1)
				goto bad;
			infile = *(++argv);
			dorevoke = 1;
		} else if (strcmp(*argv, "-extensions") == 0) {
			if (--argc < 1)
				goto bad;
			extensions = *(++argv);
		} else if (strcmp(*argv, "-extfile") == 0) {
			if (--argc < 1)
				goto bad;
			extfile = *(++argv);
		} else if (strcmp(*argv, "-status") == 0) {
			if (--argc < 1)
				goto bad;
			ser_status = *(++argv);
		} else if (strcmp(*argv, "-updatedb") == 0) {
			doupdatedb = 1;
		} else if (strcmp(*argv, "-crlexts") == 0) {
			if (--argc < 1)
				goto bad;
			crl_ext = *(++argv);
		} else if (strcmp(*argv, "-crl_reason") == 0) {
			if (--argc < 1)
				goto bad;
			rev_arg = *(++argv);
			rev_type = REV_CRL_REASON;
		} else if (strcmp(*argv, "-crl_hold") == 0) {
			if (--argc < 1)
				goto bad;
			rev_arg = *(++argv);
			rev_type = REV_HOLD;
		} else if (strcmp(*argv, "-crl_compromise") == 0) {
			if (--argc < 1)
				goto bad;
			rev_arg = *(++argv);
			rev_type = REV_KEY_COMPROMISE;
		} else if (strcmp(*argv, "-crl_CA_compromise") == 0) {
			if (--argc < 1)
				goto bad;
			rev_arg = *(++argv);
			rev_type = REV_CA_COMPROMISE;
		}
#ifndef OPENSSL_NO_ENGINE
		else if (strcmp(*argv, "-engine") == 0) {
			if (--argc < 1)
				goto bad;
			engine = *(++argv);
		}
#endif
		else {
bad:
			if (errstr)
				BIO_printf(bio_err, "invalid argument %s: %s\n",
				    *argv, errstr);
			else
				BIO_printf(bio_err, "unknown option %s\n", *argv);
			badops = 1;
			break;
		}
		argc--;
		argv++;
	}

	if (badops) {
		const char **pp2;

		for (pp2 = ca_usage; (*pp2 != NULL); pp2++)
			BIO_printf(bio_err, "%s", *pp2);
		goto err;
	}
	ERR_load_crypto_strings();

	/*****************************************************************/
	tofree = NULL;
	if (configfile == NULL)
		configfile = getenv("OPENSSL_CONF");
	if (configfile == NULL)
		configfile = getenv("SSLEAY_CONF");
	if (configfile == NULL) {
		if ((tofree = make_config_name()) == NULL) {
			BIO_printf(bio_err, "error making config file name\n");
			goto err;
		}
		configfile = tofree;
	}
	BIO_printf(bio_err, "Using configuration from %s\n", configfile);
	conf = NCONF_new(NULL);
	if (NCONF_load(conf, configfile, &errorline) <= 0) {
		if (errorline <= 0)
			BIO_printf(bio_err,
			    "error loading the config file '%s'\n",
			    configfile);
		else
			BIO_printf(bio_err,
			    "error on line %ld of config file '%s'\n",
			    errorline, configfile);
		goto err;
	}
	free(tofree);
	tofree = NULL;

#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine, 0);
#endif

	/* Lets get the config section we are using */
	if (section == NULL) {
		section = NCONF_get_string(conf, BASE_SECTION, ENV_DEFAULT_CA);
		if (section == NULL) {
			lookup_fail(BASE_SECTION, ENV_DEFAULT_CA);
			goto err;
		}
	}
	if (conf != NULL) {
		p = NCONF_get_string(conf, NULL, "oid_file");
		if (p == NULL)
			ERR_clear_error();
		if (p != NULL) {
			BIO *oid_bio;

			oid_bio = BIO_new_file(p, "r");
			if (oid_bio == NULL) {
				/*
				BIO_printf(bio_err,
				    "problems opening %s for extra oid's\n", p);
				ERR_print_errors(bio_err);
				*/
				ERR_clear_error();
			} else {
				OBJ_create_objects(oid_bio);
				BIO_free(oid_bio);
			}
		}
		if (!add_oid_section(bio_err, conf)) {
			ERR_print_errors(bio_err);
			goto err;
		}
	}
	f = NCONF_get_string(conf, section, STRING_MASK);
	if (!f)
		ERR_clear_error();

	if (f && !ASN1_STRING_set_default_mask_asc(f)) {
		BIO_printf(bio_err,
		    "Invalid global string mask setting %s\n", f);
		goto err;
	}
	if (chtype != MBSTRING_UTF8) {
		f = NCONF_get_string(conf, section, UTF8_IN);
		if (!f)
			ERR_clear_error();
		else if (!strcmp(f, "yes"))
			chtype = MBSTRING_UTF8;
	}
	db_attr.unique_subject = 1;
	p = NCONF_get_string(conf, section, ENV_UNIQUE_SUBJECT);
	if (p) {
		db_attr.unique_subject = parse_yesno(p, 1);
	} else
		ERR_clear_error();

	in = BIO_new(BIO_s_file());
	out = BIO_new(BIO_s_file());
	Sout = BIO_new(BIO_s_file());
	Cout = BIO_new(BIO_s_file());
	if ((in == NULL) || (out == NULL) || (Sout == NULL) || (Cout == NULL)) {
		ERR_print_errors(bio_err);
		goto err;
	}
	/*****************************************************************/
	/* report status of cert with serial number given on command line */
	if (ser_status) {
		if ((dbfile = NCONF_get_string(conf, section,
		    ENV_DATABASE)) == NULL) {
			lookup_fail(section, ENV_DATABASE);
			goto err;
		}
		db = load_index(dbfile, &db_attr);
		if (db == NULL)
			goto err;

		if (!index_index(db))
			goto err;

		if (get_certificate_status(ser_status, db) != 1)
			BIO_printf(bio_err, "Error verifying serial %s!\n",
			    ser_status);
		goto err;
	}
	/*****************************************************************/
	/* we definitely need a private key, so let's get it */

	if ((keyfile == NULL) && ((keyfile = NCONF_get_string(conf,
	    section, ENV_PRIVATE_KEY)) == NULL)) {
		lookup_fail(section, ENV_PRIVATE_KEY);
		goto err;
	}
	if (!key) {
		free_key = 1;
		if (!app_passwd(bio_err, passargin, NULL, &key, NULL)) {
			BIO_printf(bio_err, "Error getting password\n");
			goto err;
		}
	}
	pkey = load_key(bio_err, keyfile, keyform, 0, key, e, "CA private key");
	if (key)
		OPENSSL_cleanse(key, strlen(key));
	if (pkey == NULL) {
		/* load_key() has already printed an appropriate message */
		goto err;
	}
	/*****************************************************************/
	/* we need a certificate */
	if (!selfsign || spkac_file || ss_cert_file || gencrl) {
		if ((certfile == NULL) &&
		    ((certfile = NCONF_get_string(conf,
		    section, ENV_CERTIFICATE)) == NULL)) {
			lookup_fail(section, ENV_CERTIFICATE);
			goto err;
		}
		x509 = load_cert(bio_err, certfile, FORMAT_PEM, NULL, e,
		    "CA certificate");
		if (x509 == NULL)
			goto err;

		if (!X509_check_private_key(x509, pkey)) {
			BIO_printf(bio_err,
			    "CA certificate and CA private key do not match\n");
			goto err;
		}
	}
	if (!selfsign)
		x509p = x509;

	f = NCONF_get_string(conf, BASE_SECTION, ENV_PRESERVE);
	if (f == NULL)
		ERR_clear_error();
	if ((f != NULL) && ((*f == 'y') || (*f == 'Y')))
		preserve = 1;
	f = NCONF_get_string(conf, BASE_SECTION, ENV_MSIE_HACK);
	if (f == NULL)
		ERR_clear_error();
	if ((f != NULL) && ((*f == 'y') || (*f == 'Y')))
		msie_hack = 1;

	f = NCONF_get_string(conf, section, ENV_NAMEOPT);

	if (f) {
		if (!set_name_ex(&nameopt, f)) {
			BIO_printf(bio_err,
			    "Invalid name options: \"%s\"\n", f);
			goto err;
		}
		default_op = 0;
	} else
		ERR_clear_error();

	f = NCONF_get_string(conf, section, ENV_CERTOPT);

	if (f) {
		if (!set_cert_ex(&certopt, f)) {
			BIO_printf(bio_err,
			    "Invalid certificate options: \"%s\"\n", f);
			goto err;
		}
		default_op = 0;
	} else
		ERR_clear_error();

	f = NCONF_get_string(conf, section, ENV_EXTCOPY);

	if (f) {
		if (!set_ext_copy(&ext_copy, f)) {
			BIO_printf(bio_err,
			    "Invalid extension copy option: \"%s\"\n", f);
			goto err;
		}
	} else
		ERR_clear_error();

	/*****************************************************************/
	/* lookup where to write new certificates */
	if ((outdir == NULL) && (req)) {

		if ((outdir = NCONF_get_string(conf, section,
		    ENV_NEW_CERTS_DIR)) == NULL) {
			BIO_printf(bio_err, "there needs to be defined a directory for new certificate to be placed in\n");
			goto err;
		}
		/*
		 * outdir is a directory spec, but access() for VMS demands a
		 * filename.  In any case, stat(), below, will catch the
		 * problem if outdir is not a directory spec, and the fopen()
		 * or open() will catch an error if there is no write access.
		 *
		 * Presumably, this problem could also be solved by using the
		 * DEC C routines to convert the directory syntax to Unixly,
		 * and give that to access().  However, time's too short to
		 * do that just now.
		 */
		if (access(outdir, R_OK | W_OK | X_OK) != 0) {
			BIO_printf(bio_err,
			    "I am unable to access the %s directory\n", outdir);
			perror(outdir);
			goto err;
		}
		if (app_isdir(outdir) <= 0) {
			BIO_printf(bio_err,
			    "%s need to be a directory\n", outdir);
			perror(outdir);
			goto err;
		}
	}
	/*****************************************************************/
	/* we need to load the database file */
	if ((dbfile = NCONF_get_string(conf, section, ENV_DATABASE)) == NULL) {
		lookup_fail(section, ENV_DATABASE);
		goto err;
	}
	db = load_index(dbfile, &db_attr);
	if (db == NULL)
		goto err;

	/* Lets check some fields */
	for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {
		pp = sk_OPENSSL_PSTRING_value(db->db->data, i);
		if ((pp[DB_type][0] != DB_TYPE_REV) &&
		    (pp[DB_rev_date][0] != '\0')) {
			BIO_printf(bio_err, "entry %d: not revoked yet, but has a revocation date\n", i + 1);
			goto err;
		}
		if ((pp[DB_type][0] == DB_TYPE_REV) &&
		    !make_revoked(NULL, pp[DB_rev_date])) {
			BIO_printf(bio_err, " in entry %d\n", i + 1);
			goto err;
		}
		if (!check_time_format((char *) pp[DB_exp_date])) {
			BIO_printf(bio_err, "entry %d: invalid expiry date\n",
			    i + 1);
			goto err;
		}
		p = pp[DB_serial];
		j = strlen(p);
		if (*p == '-') {
			p++;
			j--;
		}
		if ((j & 1) || (j < 2)) {
			BIO_printf(bio_err,
			    "entry %d: bad serial number length (%d)\n",
			    i + 1, j);
			goto err;
		}
		while (*p) {
			if (!(((*p >= '0') && (*p <= '9')) ||
			    ((*p >= 'A') && (*p <= 'F')) ||
			    ((*p >= 'a') && (*p <= 'f')))) {
				BIO_printf(bio_err, "entry %d: bad serial number characters, char pos %ld, char is '%c'\n", i + 1, (long) (p - pp[DB_serial]), *p);
				goto err;
			}
			p++;
		}
	}
	if (verbose) {
		BIO_set_fp(out, stdout, BIO_NOCLOSE | BIO_FP_TEXT);	/* cannot fail */
		TXT_DB_write(out, db->db);
		BIO_printf(bio_err, "%d entries loaded from the database\n",
		    sk_OPENSSL_PSTRING_num(db->db->data));
		BIO_printf(bio_err, "generating index\n");
	}
	if (!index_index(db))
		goto err;

	/*****************************************************************/
	/* Update the db file for expired certificates */
	if (doupdatedb) {
		if (verbose)
			BIO_printf(bio_err, "Updating %s ...\n", dbfile);

		i = do_updatedb(db);
		if (i == -1) {
			BIO_printf(bio_err, "Malloc failure\n");
			goto err;
		} else if (i == 0) {
			if (verbose)
				BIO_printf(bio_err,
				    "No entries found to mark expired\n");
		} else {
			if (!save_index(dbfile, "new", db))
				goto err;

			if (!rotate_index(dbfile, "new", "old"))
				goto err;

			if (verbose)
				BIO_printf(bio_err,
				    "Done. %d entries marked as expired\n", i);
		}
	}
	/*****************************************************************/
	/* Read extentions config file                                   */
	if (extfile) {
		extconf = NCONF_new(NULL);
		if (NCONF_load(extconf, extfile, &errorline) <= 0) {
			if (errorline <= 0)
				BIO_printf(bio_err,
				    "ERROR: loading the config file '%s'\n",
				    extfile);
			else
				BIO_printf(bio_err,
				    "ERROR: on line %ld of config file '%s'\n",
				    errorline, extfile);
			ret = 1;
			goto err;
		}
		if (verbose)
			BIO_printf(bio_err,
			    "Successfully loaded extensions file %s\n",
			    extfile);

		/* We can have sections in the ext file */
		if (!extensions && !(extensions = NCONF_get_string(extconf,
		    "default", "extensions")))
			extensions = "default";
	}
	/*****************************************************************/
	if (req || gencrl) {
		if (outfile != NULL) {
			if (BIO_write_filename(Sout, outfile) <= 0) {
				perror(outfile);
				goto err;
			}
		} else {
			BIO_set_fp(Sout, stdout, BIO_NOCLOSE | BIO_FP_TEXT);
		}
	}
	if ((md == NULL) && ((md = NCONF_get_string(conf, section,
	    ENV_DEFAULT_MD)) == NULL)) {
		lookup_fail(section, ENV_DEFAULT_MD);
		goto err;
	}
	if (!strcmp(md, "default")) {
		int def_nid;
		if (EVP_PKEY_get_default_digest_nid(pkey, &def_nid) <= 0) {
			BIO_puts(bio_err, "no default digest\n");
			goto err;
		}
		md = (char *) OBJ_nid2sn(def_nid);
	}
	if ((dgst = EVP_get_digestbyname(md)) == NULL) {
		BIO_printf(bio_err,
		    "%s is an unsupported message digest type\n", md);
		goto err;
	}
	if (req) {
		if ((email_dn == 1) && ((tmp_email_dn = NCONF_get_string(conf,
		    section, ENV_DEFAULT_EMAIL_DN)) != NULL)) {
			if (strcmp(tmp_email_dn, "no") == 0)
				email_dn = 0;
		}
		if (verbose)
			BIO_printf(bio_err, "message digest is %s\n",
			    OBJ_nid2ln(dgst->type));
		if ((policy == NULL) && ((policy = NCONF_get_string(conf,
		    section, ENV_POLICY)) == NULL)) {
			lookup_fail(section, ENV_POLICY);
			goto err;
		}
		if (verbose)
			BIO_printf(bio_err, "policy is %s\n", policy);

		if ((serialfile = NCONF_get_string(conf, section,
		    ENV_SERIAL)) == NULL) {
			lookup_fail(section, ENV_SERIAL);
			goto err;
		}
		if (!extconf) {
			/*
			 * no '-extfile' option, so we look for extensions in
			 * the main configuration file
			 */
			if (!extensions) {
				extensions = NCONF_get_string(conf, section,
				    ENV_EXTENSIONS);
				if (!extensions)
					ERR_clear_error();
			}
			if (extensions) {
				/* Check syntax of file */
				X509V3_CTX ctx;
				X509V3_set_ctx_test(&ctx);
				X509V3_set_nconf(&ctx, conf);
				if (!X509V3_EXT_add_nconf(conf, &ctx,
				    extensions, NULL)) {
					BIO_printf(bio_err,
					    "Error Loading extension section %s\n",
					    extensions);
					ret = 1;
					goto err;
				}
			}
		}
		if (startdate == NULL) {
			startdate = NCONF_get_string(conf, section,
			    ENV_DEFAULT_STARTDATE);
			if (startdate == NULL)
				ERR_clear_error();
		}
		if (startdate && !ASN1_TIME_set_string(NULL, startdate)) {
			BIO_printf(bio_err, "start date is invalid, it should be YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ\n");
			goto err;
		}
		if (startdate == NULL)
			startdate = "today";

		if (enddate == NULL) {
			enddate = NCONF_get_string(conf, section,
			    ENV_DEFAULT_ENDDATE);
			if (enddate == NULL)
				ERR_clear_error();
		}
		if (enddate && !ASN1_TIME_set_string(NULL, enddate)) {
			BIO_printf(bio_err, "end date is invalid, it should be YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ\n");
			goto err;
		}
		if (days == 0) {
			if (!NCONF_get_number(conf, section,
			    ENV_DEFAULT_DAYS, &days))
				days = 0;
		}
		if (!enddate && (days == 0)) {
			BIO_printf(bio_err,
			    "cannot lookup how many days to certify for\n");
			goto err;
		}
		if ((serial = load_serial(serialfile, create_ser, NULL)) ==
		    NULL) {
			BIO_printf(bio_err,
			    "error while loading serial number\n");
			goto err;
		}
		if (verbose) {
			if (BN_is_zero(serial))
				BIO_printf(bio_err,
				    "next serial number is 00\n");
			else {
				if ((f = BN_bn2hex(serial)) == NULL)
					goto err;
				BIO_printf(bio_err,
				    "next serial number is %s\n", f);
				free(f);
			}
		}
		if ((attribs = NCONF_get_section(conf, policy)) == NULL) {
			BIO_printf(bio_err,
			    "unable to find 'section' for %s\n", policy);
			goto err;
		}
		if ((cert_sk = sk_X509_new_null()) == NULL) {
			BIO_printf(bio_err, "Memory allocation failure\n");
			goto err;
		}
		if (spkac_file != NULL) {
			total++;
			j = certify_spkac(&x, spkac_file, pkey, x509, dgst,
			    sigopts, attribs, db, serial, subj, chtype,
			    multirdn, email_dn, startdate, enddate, days,
			    extensions, conf, verbose, certopt, nameopt,
			    default_op, ext_copy);
			if (j < 0)
				goto err;
			if (j > 0) {
				total_done++;
				BIO_printf(bio_err, "\n");
				if (!BN_add_word(serial, 1))
					goto err;
				if (!sk_X509_push(cert_sk, x)) {
					BIO_printf(bio_err,
					    "Memory allocation failure\n");
					goto err;
				}
				if (outfile) {
					output_der = 1;
					batch = 1;
				}
			}
		}
		if (ss_cert_file != NULL) {
			total++;
			j = certify_cert(&x, ss_cert_file, pkey, x509, dgst,
			    sigopts, attribs, db, serial, subj, chtype,
			    multirdn, email_dn, startdate, enddate, days, batch,
			    extensions, conf, verbose, certopt, nameopt,
			    default_op, ext_copy, e);
			if (j < 0)
				goto err;
			if (j > 0) {
				total_done++;
				BIO_printf(bio_err, "\n");
				if (!BN_add_word(serial, 1))
					goto err;
				if (!sk_X509_push(cert_sk, x)) {
					BIO_printf(bio_err,
					    "Memory allocation failure\n");
					goto err;
				}
			}
		}
		if (infile != NULL) {
			total++;
			j = certify(&x, infile, pkey, x509p, dgst, sigopts,
			    attribs, db, serial, subj, chtype, multirdn,
			    email_dn, startdate, enddate, days, batch,
			    extensions, conf, verbose, certopt, nameopt,
			    default_op, ext_copy, selfsign);
			if (j < 0)
				goto err;
			if (j > 0) {
				total_done++;
				BIO_printf(bio_err, "\n");
				if (!BN_add_word(serial, 1))
					goto err;
				if (!sk_X509_push(cert_sk, x)) {
					BIO_printf(bio_err,
					    "Memory allocation failure\n");
					goto err;
				}
			}
		}
		for (i = 0; i < argc; i++) {
			total++;
			j = certify(&x, argv[i], pkey, x509p, dgst, sigopts,
			    attribs, db, serial, subj, chtype, multirdn,
			    email_dn, startdate, enddate, days, batch,
			    extensions, conf, verbose, certopt, nameopt,
			    default_op, ext_copy, selfsign);
			if (j < 0)
				goto err;
			if (j > 0) {
				total_done++;
				BIO_printf(bio_err, "\n");
				if (!BN_add_word(serial, 1))
					goto err;
				if (!sk_X509_push(cert_sk, x)) {
					BIO_printf(bio_err,
					    "Memory allocation failure\n");
					goto err;
				}
			}
		}
		/*
		 * we have a stack of newly certified certificates and a data
		 * base and serial number that need updating
		 */

		if (sk_X509_num(cert_sk) > 0) {
			if (!batch) {
				BIO_printf(bio_err, "\n%d out of %d certificate requests certified, commit? [y/n]", total_done, total);
				(void) BIO_flush(bio_err);
				buf[0][0] = '\0';
				if (!fgets(buf[0], 10, stdin)) {
					BIO_printf(bio_err, "CERTIFICATION CANCELED: I/O error\n");
					ret = 0;
					goto err;
				}
				if ((buf[0][0] != 'y') && (buf[0][0] != 'Y')) {
					BIO_printf(bio_err, "CERTIFICATION CANCELED\n");
					ret = 0;
					goto err;
				}
			}
			BIO_printf(bio_err, "Write out database with %d new entries\n", sk_X509_num(cert_sk));

			if (!save_serial(serialfile, "new", serial, NULL))
				goto err;

			if (!save_index(dbfile, "new", db))
				goto err;
		}
		if (verbose)
			BIO_printf(bio_err, "writing new certificates\n");
		for (i = 0; i < sk_X509_num(cert_sk); i++) {
			int k;
			char *serial;
			unsigned char *data;

			x = sk_X509_value(cert_sk, i);

			j = x->cert_info->serialNumber->length;
			data = (unsigned char *)x->cert_info->serialNumber->data;
			if (j > 0)
				serial = bin2hex(data, j);
			else
				serial = strdup("00");
			if (serial) {
				k = snprintf(buf[2], sizeof(buf[2]),
				    "%s/%s.pem", outdir, serial);
				free(serial);
				if (k == -1 || k >= sizeof(buf[2])) {
					BIO_printf(bio_err,
					    "certificate file name too long\n");
					goto err;
				}
			} else {
				BIO_printf(bio_err,
				    "memory allocation failed\n");
				goto err;
			}
			if (verbose)
				BIO_printf(bio_err, "writing %s\n", buf[2]);

			if (BIO_write_filename(Cout, buf[2]) <= 0) {
				perror(buf[2]);
				goto err;
			}
			write_new_certificate(Cout, x, 0, notext);
			write_new_certificate(Sout, x, output_der, notext);
		}

		if (sk_X509_num(cert_sk)) {
			/* Rename the database and the serial file */
			if (!rotate_serial(serialfile, "new", "old"))
				goto err;

			if (!rotate_index(dbfile, "new", "old"))
				goto err;

			BIO_printf(bio_err, "Data Base Updated\n");
		}
	}
	/*****************************************************************/
	if (gencrl) {
		int crl_v2 = 0;
		if (!crl_ext) {
			crl_ext = NCONF_get_string(conf, section, ENV_CRLEXT);
			if (!crl_ext)
				ERR_clear_error();
		}
		if (crl_ext) {
			/* Check syntax of file */
			X509V3_CTX ctx;
			X509V3_set_ctx_test(&ctx);
			X509V3_set_nconf(&ctx, conf);
			if (!X509V3_EXT_add_nconf(conf, &ctx, crl_ext, NULL)) {
				BIO_printf(bio_err,
				    "Error Loading CRL extension section %s\n",
				    crl_ext);
				ret = 1;
				goto err;
			}
		}
		if ((crlnumberfile = NCONF_get_string(conf, section,
		    ENV_CRLNUMBER)) != NULL)
			if ((crlnumber = load_serial(crlnumberfile, 0,
			    NULL)) == NULL) {
				BIO_printf(bio_err,
				    "error while loading CRL number\n");
				goto err;
			}
		if (!crldays && !crlhours && !crlsec) {
			if (!NCONF_get_number(conf, section,
			    ENV_DEFAULT_CRL_DAYS, &crldays))
				crldays = 0;
			if (!NCONF_get_number(conf, section,
			    ENV_DEFAULT_CRL_HOURS, &crlhours))
				crlhours = 0;
			ERR_clear_error();
		}
		if ((crldays == 0) && (crlhours == 0) && (crlsec == 0)) {
			BIO_printf(bio_err, "cannot lookup how long until the next CRL is issued\n");
			goto err;
		}
		if (verbose)
			BIO_printf(bio_err, "making CRL\n");
		if ((crl = X509_CRL_new()) == NULL)
			goto err;
		if (!X509_CRL_set_issuer_name(crl, X509_get_subject_name(x509)))
			goto err;

		tmptm = ASN1_TIME_new();
		if (!tmptm)
			goto err;
		X509_gmtime_adj(tmptm, 0);
		X509_CRL_set_lastUpdate(crl, tmptm);
		if (!X509_time_adj_ex(tmptm, crldays,
		    crlhours * 60 * 60 + crlsec, NULL)) {
			BIO_puts(bio_err, "error setting CRL nextUpdate\n");
			goto err;
		}
		X509_CRL_set_nextUpdate(crl, tmptm);

		ASN1_TIME_free(tmptm);

		for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {
			pp = sk_OPENSSL_PSTRING_value(db->db->data, i);
			if (pp[DB_type][0] == DB_TYPE_REV) {
				if ((r = X509_REVOKED_new()) == NULL)
					goto err;
				j = make_revoked(r, pp[DB_rev_date]);
				if (!j)
					goto err;
				if (j == 2)
					crl_v2 = 1;
				if (!BN_hex2bn(&serial, pp[DB_serial]))
					goto err;
				tmpser = BN_to_ASN1_INTEGER(serial, NULL);
				BN_free(serial);
				serial = NULL;
				if (!tmpser)
					goto err;
				X509_REVOKED_set_serialNumber(r, tmpser);
				ASN1_INTEGER_free(tmpser);
				X509_CRL_add0_revoked(crl, r);
			}
		}

		/*
		 * sort the data so it will be written in serial number order
		 */
		X509_CRL_sort(crl);

		/* we now have a CRL */
		if (verbose)
			BIO_printf(bio_err, "signing CRL\n");

		/* Add any extensions asked for */

		if (crl_ext || crlnumberfile != NULL) {
			X509V3_CTX crlctx;
			X509V3_set_ctx(&crlctx, x509, NULL, NULL, crl, 0);
			X509V3_set_nconf(&crlctx, conf);

			if (crl_ext)
				if (!X509V3_EXT_CRL_add_nconf(conf, &crlctx,
				    crl_ext, crl))
					goto err;
			if (crlnumberfile != NULL) {
				tmpser = BN_to_ASN1_INTEGER(crlnumber, NULL);
				if (!tmpser)
					goto err;
				X509_CRL_add1_ext_i2d(crl, NID_crl_number,
				    tmpser, 0, 0);
				ASN1_INTEGER_free(tmpser);
				crl_v2 = 1;
				if (!BN_add_word(crlnumber, 1))
					goto err;
			}
		}
		if (crl_ext || crl_v2) {
			if (!X509_CRL_set_version(crl, 1))
				goto err;	/* version 2 CRL */
		}
		if (crlnumberfile != NULL)	/* we have a CRL number that
						 * need updating */
			if (!save_serial(crlnumberfile, "new", crlnumber, NULL))
				goto err;

		if (crlnumber) {
			BN_free(crlnumber);
			crlnumber = NULL;
		}
		if (!do_X509_CRL_sign(bio_err, crl, pkey, dgst, sigopts))
			goto err;

		PEM_write_bio_X509_CRL(Sout, crl);

		if (crlnumberfile != NULL)	/* Rename the crlnumber file */
			if (!rotate_serial(crlnumberfile, "new", "old"))
				goto err;

	}
	/*****************************************************************/
	if (dorevoke) {
		if (infile == NULL) {
			BIO_printf(bio_err, "no input files\n");
			goto err;
		} else {
			X509 *revcert;
			revcert = load_cert(bio_err, infile, FORMAT_PEM,
			    NULL, e, infile);
			if (revcert == NULL)
				goto err;
			j = do_revoke(revcert, db, rev_type, rev_arg);
			if (j <= 0)
				goto err;
			X509_free(revcert);

			if (!save_index(dbfile, "new", db))
				goto err;

			if (!rotate_index(dbfile, "new", "old"))
				goto err;

			BIO_printf(bio_err, "Data Base Updated\n");
		}
	}
	/*****************************************************************/
	ret = 0;

err:
	free(tofree);

	BIO_free_all(Cout);
	BIO_free_all(Sout);
	BIO_free_all(out);
	BIO_free_all(in);

	if (cert_sk)
		sk_X509_pop_free(cert_sk, X509_free);

	if (ret)
		ERR_print_errors(bio_err);
	if (free_key && key)
		free(key);
	BN_free(serial);
	BN_free(crlnumber);
	free_index(db);
	if (sigopts)
		sk_OPENSSL_STRING_free(sigopts);
	EVP_PKEY_free(pkey);
	if (x509)
		X509_free(x509);
	X509_CRL_free(crl);
	NCONF_free(conf);
	NCONF_free(extconf);
	OBJ_cleanup();

	return (ret);
}

static void
lookup_fail(const char *name, const char *tag)
{
	BIO_printf(bio_err, "variable lookup failed for %s::%s\n", name, tag);
}

static int
certify(X509 ** xret, char *infile, EVP_PKEY * pkey, X509 * x509,
    const EVP_MD * dgst, STACK_OF(OPENSSL_STRING) * sigopts,
    STACK_OF(CONF_VALUE) * policy, CA_DB * db, BIGNUM * serial, char *subj,
    unsigned long chtype, int multirdn, int email_dn, char *startdate,
    char *enddate, long days, int batch, char *ext_sect, CONF * lconf,
    int verbose, unsigned long certopt, unsigned long nameopt, int default_op,
    int ext_copy, int selfsign)
{
	X509_REQ *req = NULL;
	BIO *in = NULL;
	EVP_PKEY *pktmp = NULL;
	int ok = -1, i;

	in = BIO_new(BIO_s_file());

	if (BIO_read_filename(in, infile) <= 0) {
		perror(infile);
		goto err;
	}
	if ((req = PEM_read_bio_X509_REQ(in, NULL, NULL, NULL)) == NULL) {
		BIO_printf(bio_err, "Error reading certificate request in %s\n",
		    infile);
		goto err;
	}
	if (verbose)
		X509_REQ_print(bio_err, req);

	BIO_printf(bio_err, "Check that the request matches the signature\n");

	if (selfsign && !X509_REQ_check_private_key(req, pkey)) {
		BIO_printf(bio_err,
		    "Certificate request and CA private key do not match\n");
		ok = 0;
		goto err;
	}
	if ((pktmp = X509_REQ_get_pubkey(req)) == NULL) {
		BIO_printf(bio_err, "error unpacking public key\n");
		goto err;
	}
	i = X509_REQ_verify(req, pktmp);
	EVP_PKEY_free(pktmp);
	if (i < 0) {
		ok = 0;
		BIO_printf(bio_err, "Signature verification problems....\n");
		goto err;
	}
	if (i == 0) {
		ok = 0;
		BIO_printf(bio_err,
		    "Signature did not match the certificate request\n");
		goto err;
	} else
		BIO_printf(bio_err, "Signature ok\n");

	ok = do_body(xret, pkey, x509, dgst, sigopts, policy, db, serial,
	    subj, chtype, multirdn, email_dn, startdate, enddate, days, batch,
	    verbose, req, ext_sect, lconf, certopt, nameopt, default_op,
	    ext_copy, selfsign);

err:
	if (req != NULL)
		X509_REQ_free(req);
	if (in != NULL)
		BIO_free(in);
	return (ok);
}

static int
certify_cert(X509 ** xret, char *infile, EVP_PKEY * pkey, X509 * x509,
    const EVP_MD * dgst, STACK_OF(OPENSSL_STRING) * sigopts,
    STACK_OF(CONF_VALUE) * policy, CA_DB * db, BIGNUM * serial, char *subj,
    unsigned long chtype, int multirdn, int email_dn, char *startdate,
    char *enddate, long days, int batch, char *ext_sect, CONF * lconf,
    int verbose, unsigned long certopt, unsigned long nameopt, int default_op,
    int ext_copy, ENGINE * e)
{
	X509 *req = NULL;
	X509_REQ *rreq = NULL;
	EVP_PKEY *pktmp = NULL;
	int ok = -1, i;

	if ((req = load_cert(bio_err, infile, FORMAT_PEM, NULL, e,
	    infile)) == NULL)
		goto err;
	if (verbose)
		X509_print(bio_err, req);

	BIO_printf(bio_err, "Check that the request matches the signature\n");

	if ((pktmp = X509_get_pubkey(req)) == NULL) {
		BIO_printf(bio_err, "error unpacking public key\n");
		goto err;
	}
	i = X509_verify(req, pktmp);
	EVP_PKEY_free(pktmp);
	if (i < 0) {
		ok = 0;
		BIO_printf(bio_err, "Signature verification problems....\n");
		goto err;
	}
	if (i == 0) {
		ok = 0;
		BIO_printf(bio_err,
		    "Signature did not match the certificate\n");
		goto err;
	} else
		BIO_printf(bio_err, "Signature ok\n");

	if ((rreq = X509_to_X509_REQ(req, NULL, EVP_md5())) == NULL)
		goto err;

	ok = do_body(xret, pkey, x509, dgst, sigopts, policy, db, serial,
	    subj, chtype, multirdn, email_dn, startdate, enddate, days, batch,
	    verbose, rreq, ext_sect, lconf, certopt, nameopt, default_op,
	    ext_copy, 0);

err:
	if (rreq != NULL)
		X509_REQ_free(rreq);
	if (req != NULL)
		X509_free(req);
	return (ok);
}

static int
do_body(X509 ** xret, EVP_PKEY * pkey, X509 * x509, const EVP_MD * dgst,
    STACK_OF(OPENSSL_STRING) * sigopts, STACK_OF(CONF_VALUE) * policy,
    CA_DB * db, BIGNUM * serial, char *subj, unsigned long chtype, int multirdn,
    int email_dn, char *startdate, char *enddate, long days, int batch,
    int verbose, X509_REQ * req, char *ext_sect, CONF * lconf,
    unsigned long certopt, unsigned long nameopt, int default_op,
    int ext_copy, int selfsign)
{
	X509_NAME *name = NULL, *CAname = NULL, *subject = NULL, *dn_subject = NULL;
	ASN1_UTCTIME *tm, *tmptm;
	ASN1_STRING *str, *str2;
	ASN1_OBJECT *obj;
	X509 *ret = NULL;
	X509_CINF *ci;
	X509_NAME_ENTRY *ne;
	X509_NAME_ENTRY *tne, *push;
	EVP_PKEY *pktmp;
	int ok = -1, i, j, last, nid;
	const char *p;
	CONF_VALUE *cv;
	OPENSSL_STRING row[DB_NUMBER];
	OPENSSL_STRING *irow = NULL;
	OPENSSL_STRING *rrow = NULL;
	char buf[25];

	tmptm = ASN1_UTCTIME_new();
	if (tmptm == NULL) {
		BIO_printf(bio_err, "malloc error\n");
		return (0);
	}
	for (i = 0; i < DB_NUMBER; i++)
		row[i] = NULL;

	if (subj) {
		X509_NAME *n = parse_name(subj, chtype, multirdn);

		if (!n) {
			ERR_print_errors(bio_err);
			goto err;
		}
		X509_REQ_set_subject_name(req, n);
		req->req_info->enc.modified = 1;
		X509_NAME_free(n);
	}
	if (default_op)
		BIO_printf(bio_err,
		    "The Subject's Distinguished Name is as follows\n");

	name = X509_REQ_get_subject_name(req);
	for (i = 0; i < X509_NAME_entry_count(name); i++) {
		ne = X509_NAME_get_entry(name, i);
		str = X509_NAME_ENTRY_get_data(ne);
		obj = X509_NAME_ENTRY_get_object(ne);

		if (msie_hack) {
			/* assume all type should be strings */
			nid = OBJ_obj2nid(ne->object);

			if (str->type == V_ASN1_UNIVERSALSTRING)
				ASN1_UNIVERSALSTRING_to_string(str);

			if ((str->type == V_ASN1_IA5STRING) &&
			    (nid != NID_pkcs9_emailAddress))
				str->type = V_ASN1_T61STRING;

			if ((nid == NID_pkcs9_emailAddress) &&
			    (str->type == V_ASN1_PRINTABLESTRING))
				str->type = V_ASN1_IA5STRING;
		}
		/* If no EMAIL is wanted in the subject */
		if ((OBJ_obj2nid(obj) == NID_pkcs9_emailAddress) && (!email_dn))
			continue;

		/* check some things */
		if ((OBJ_obj2nid(obj) == NID_pkcs9_emailAddress) &&
		    (str->type != V_ASN1_IA5STRING)) {
			BIO_printf(bio_err, "\nemailAddress type needs to be of type IA5STRING\n");
			goto err;
		}
		if ((str->type != V_ASN1_BMPSTRING) &&
		    (str->type != V_ASN1_UTF8STRING)) {
			j = ASN1_PRINTABLE_type(str->data, str->length);
			if (((j == V_ASN1_T61STRING) &&
			    (str->type != V_ASN1_T61STRING)) ||
			    ((j == V_ASN1_IA5STRING) &&
			    (str->type == V_ASN1_PRINTABLESTRING))) {
				BIO_printf(bio_err, "\nThe string contains characters that are illegal for the ASN.1 type\n");
				goto err;
			}
		}
		if (default_op)
			old_entry_print(bio_err, obj, str);
	}

	/* Ok, now we check the 'policy' stuff. */
	if ((subject = X509_NAME_new()) == NULL) {
		BIO_printf(bio_err, "Memory allocation failure\n");
		goto err;
	}
	/* take a copy of the issuer name before we mess with it. */
	if (selfsign)
		CAname = X509_NAME_dup(name);
	else
		CAname = X509_NAME_dup(x509->cert_info->subject);
	if (CAname == NULL)
		goto err;
	str = str2 = NULL;

	for (i = 0; i < sk_CONF_VALUE_num(policy); i++) {
		cv = sk_CONF_VALUE_value(policy, i);	/* get the object id */
		if ((j = OBJ_txt2nid(cv->name)) == NID_undef) {
			BIO_printf(bio_err, "%s:unknown object type in 'policy' configuration\n", cv->name);
			goto err;
		}
		obj = OBJ_nid2obj(j);

		last = -1;
		for (;;) {
			/* lookup the object in the supplied name list */
			j = X509_NAME_get_index_by_OBJ(name, obj, last);
			if (j < 0) {
				if (last != -1)
					break;
				tne = NULL;
			} else {
				tne = X509_NAME_get_entry(name, j);
			}
			last = j;

			/* depending on the 'policy', decide what to do. */
			push = NULL;
			if (strcmp(cv->value, "optional") == 0) {
				if (tne != NULL)
					push = tne;
			} else if (strcmp(cv->value, "supplied") == 0) {
				if (tne == NULL) {
					BIO_printf(bio_err, "The %s field needed to be supplied and was missing\n", cv->name);
					goto err;
				} else
					push = tne;
			} else if (strcmp(cv->value, "match") == 0) {
				int last2;

				if (tne == NULL) {
					BIO_printf(bio_err, "The mandatory %s field was missing\n", cv->name);
					goto err;
				}
				last2 = -1;

again2:
				j = X509_NAME_get_index_by_OBJ(CAname, obj, last2);
				if ((j < 0) && (last2 == -1)) {
					BIO_printf(bio_err, "The %s field does not exist in the CA certificate,\nthe 'policy' is misconfigured\n", cv->name);
					goto err;
				}
				if (j >= 0) {
					push = X509_NAME_get_entry(CAname, j);
					str = X509_NAME_ENTRY_get_data(tne);
					str2 = X509_NAME_ENTRY_get_data(push);
					last2 = j;
					if (ASN1_STRING_cmp(str, str2) != 0)
						goto again2;
				}
				if (j < 0) {
					BIO_printf(bio_err, "The %s field needed to be the same in the\nCA certificate (%s) and the request (%s)\n", cv->name, ((str2 == NULL) ? "NULL" : (char *) str2->data), ((str == NULL) ? "NULL" : (char *) str->data));
					goto err;
				}
			} else {
				BIO_printf(bio_err, "%s:invalid type in 'policy' configuration\n", cv->value);
				goto err;
			}

			if (push != NULL) {
				if (!X509_NAME_add_entry(subject, push,
				    -1, 0)) {
					if (push != NULL)
						X509_NAME_ENTRY_free(push);
					BIO_printf(bio_err,
					    "Memory allocation failure\n");
					goto err;
				}
			}
			if (j < 0)
				break;
		}
	}

	if (preserve) {
		X509_NAME_free(subject);
		/* subject=X509_NAME_dup(X509_REQ_get_subject_name(req)); */
		subject = X509_NAME_dup(name);
		if (subject == NULL)
			goto err;
	}
	if (verbose)
		BIO_printf(bio_err, "The subject name appears to be ok, checking data base for clashes\n");

	/* Build the correct Subject if no e-mail is wanted in the subject */
	/*
	 * and add it later on because of the method extensions are added
	 * (altName)
	 */

	if (email_dn)
		dn_subject = subject;
	else {
		X509_NAME_ENTRY *tmpne;
		/*
		 * Its best to dup the subject DN and then delete any email
		 * addresses because this retains its structure.
		 */
		if (!(dn_subject = X509_NAME_dup(subject))) {
			BIO_printf(bio_err, "Memory allocation failure\n");
			goto err;
		}
		while ((i = X509_NAME_get_index_by_NID(dn_subject,
		    NID_pkcs9_emailAddress, -1)) >= 0) {
			tmpne = X509_NAME_get_entry(dn_subject, i);
			X509_NAME_delete_entry(dn_subject, i);
			X509_NAME_ENTRY_free(tmpne);
		}
	}

	if (BN_is_zero(serial))
		row[DB_serial] = strdup("00");
	else
		row[DB_serial] = BN_bn2hex(serial);
	if (row[DB_serial] == NULL) {
		BIO_printf(bio_err, "Memory allocation failure\n");
		goto err;
	}
	if (db->attributes.unique_subject) {
		OPENSSL_STRING *crow = row;

		rrow = TXT_DB_get_by_index(db->db, DB_name, crow);
		if (rrow != NULL) {
			BIO_printf(bio_err,
			    "ERROR:There is already a certificate for %s\n",
			    row[DB_name]);
		}
	}
	if (rrow == NULL) {
		rrow = TXT_DB_get_by_index(db->db, DB_serial, row);
		if (rrow != NULL) {
			BIO_printf(bio_err,
			    "ERROR:Serial number %s has already been issued,\n",
			    row[DB_serial]);
			BIO_printf(bio_err, "      check the database/serial_file for corruption\n");
		}
	}
	if (rrow != NULL) {
		BIO_printf(bio_err,
		    "The matching entry has the following details\n");
		if (rrow[DB_type][0] == 'E')
			p = "Expired";
		else if (rrow[DB_type][0] == 'R')
			p = "Revoked";
		else if (rrow[DB_type][0] == 'V')
			p = "Valid";
		else
			p = "\ninvalid type, Data base error\n";
		BIO_printf(bio_err, "Type	  :%s\n", p);
		if (rrow[DB_type][0] == 'R') {
			p = rrow[DB_exp_date];
			if (p == NULL)
				p = "undef";
			BIO_printf(bio_err, "Was revoked on:%s\n", p);
		}
		p = rrow[DB_exp_date];
		if (p == NULL)
			p = "undef";
		BIO_printf(bio_err, "Expires on    :%s\n", p);
		p = rrow[DB_serial];
		if (p == NULL)
			p = "undef";
		BIO_printf(bio_err, "Serial Number :%s\n", p);
		p = rrow[DB_file];
		if (p == NULL)
			p = "undef";
		BIO_printf(bio_err, "File name     :%s\n", p);
		p = rrow[DB_name];
		if (p == NULL)
			p = "undef";
		BIO_printf(bio_err, "Subject Name  :%s\n", p);
		ok = -1;	/* This is now a 'bad' error. */
		goto err;
	}
	/* We are now totally happy, lets make and sign the certificate */
	if (verbose)
		BIO_printf(bio_err, "Everything appears to be ok, creating and signing the certificate\n");

	if ((ret = X509_new()) == NULL)
		goto err;
	ci = ret->cert_info;

#ifdef X509_V3
	/* Make it an X509 v3 certificate. */
	if (!X509_set_version(ret, 2))
		goto err;
#endif

	if (BN_to_ASN1_INTEGER(serial, ci->serialNumber) == NULL)
		goto err;
	if (selfsign) {
		if (!X509_set_issuer_name(ret, subject))
			goto err;
	} else {
		if (!X509_set_issuer_name(ret, X509_get_subject_name(x509)))
			goto err;
	}

	if (strcmp(startdate, "today") == 0)
		X509_gmtime_adj(X509_get_notBefore(ret), 0);
	else
		ASN1_TIME_set_string(X509_get_notBefore(ret), startdate);

	if (enddate == NULL)
		X509_time_adj_ex(X509_get_notAfter(ret), days, 0, NULL);
	else
		ASN1_TIME_set_string(X509_get_notAfter(ret), enddate);

	if (!X509_set_subject_name(ret, subject))
		goto err;

	pktmp = X509_REQ_get_pubkey(req);
	i = X509_set_pubkey(ret, pktmp);
	EVP_PKEY_free(pktmp);
	if (!i)
		goto err;

	/* Lets add the extensions, if there are any */
	if (ext_sect) {
		X509V3_CTX ctx;
		if (ci->version == NULL)
			if ((ci->version = ASN1_INTEGER_new()) == NULL)
				goto err;
		ASN1_INTEGER_set(ci->version, 2);	/* version 3 certificate */

		/*
		 * Free the current entries if any, there should not be any I
		 * believe
		 */
		if (ci->extensions != NULL)
			sk_X509_EXTENSION_pop_free(ci->extensions,
			    X509_EXTENSION_free);

		ci->extensions = NULL;

		/* Initialize the context structure */
		if (selfsign)
			X509V3_set_ctx(&ctx, ret, ret, req, NULL, 0);
		else
			X509V3_set_ctx(&ctx, x509, ret, req, NULL, 0);

		if (extconf) {
			if (verbose)
				BIO_printf(bio_err,
				    "Extra configuration file found\n");

			/* Use the extconf configuration db LHASH */
			X509V3_set_nconf(&ctx, extconf);

			/* Test the structure (needed?) */
			/* X509V3_set_ctx_test(&ctx); */

			/* Adds exts contained in the configuration file */
			if (!X509V3_EXT_add_nconf(extconf, &ctx,
			    ext_sect, ret)) {
				BIO_printf(bio_err,
				    "ERROR: adding extensions in section %s\n",
				    ext_sect);
				ERR_print_errors(bio_err);
				goto err;
			}
			if (verbose)
				BIO_printf(bio_err, "Successfully added extensions from file.\n");
		} else if (ext_sect) {
			/* We found extensions to be set from config file */
			X509V3_set_nconf(&ctx, lconf);

			if (!X509V3_EXT_add_nconf(lconf, &ctx, ext_sect, ret)) {
				BIO_printf(bio_err,
				    "ERROR: adding extensions in section %s\n",
				    ext_sect);
				ERR_print_errors(bio_err);
				goto err;
			}
			if (verbose)
				BIO_printf(bio_err, "Successfully added extensions from config\n");
		}
	}
	/* Copy extensions from request (if any) */

	if (!copy_extensions(ret, req, ext_copy)) {
		BIO_printf(bio_err, "ERROR: adding extensions from request\n");
		ERR_print_errors(bio_err);
		goto err;
	}
	/* Set the right value for the noemailDN option */
	if (email_dn == 0) {
		if (!X509_set_subject_name(ret, dn_subject))
			goto err;
	}
	if (!default_op) {
		BIO_printf(bio_err, "Certificate Details:\n");
		/*
		 * Never print signature details because signature not
		 * present
		 */
		certopt |= X509_FLAG_NO_SIGDUMP | X509_FLAG_NO_SIGNAME;
		X509_print_ex(bio_err, ret, nameopt, certopt);
	}
	BIO_printf(bio_err, "Certificate is to be certified until ");
	ASN1_TIME_print(bio_err, X509_get_notAfter(ret));
	if (days)
		BIO_printf(bio_err, " (%ld days)", days);
	BIO_printf(bio_err, "\n");

	if (!batch) {

		BIO_printf(bio_err, "Sign the certificate? [y/n]:");
		(void) BIO_flush(bio_err);
		buf[0] = '\0';
		if (!fgets(buf, sizeof(buf) - 1, stdin)) {
			BIO_printf(bio_err,
			    "CERTIFICATE WILL NOT BE CERTIFIED: I/O error\n");
			ok = 0;
			goto err;
		}
		if (!((buf[0] == 'y') || (buf[0] == 'Y'))) {
			BIO_printf(bio_err,
			    "CERTIFICATE WILL NOT BE CERTIFIED\n");
			ok = 0;
			goto err;
		}
	}
	pktmp = X509_get_pubkey(ret);
	if (EVP_PKEY_missing_parameters(pktmp) &&
	    !EVP_PKEY_missing_parameters(pkey))
		EVP_PKEY_copy_parameters(pktmp, pkey);
	EVP_PKEY_free(pktmp);

	if (!do_X509_sign(bio_err, ret, pkey, dgst, sigopts))
		goto err;

	/* We now just add it to the database */
	row[DB_type] = malloc(2);

	tm = X509_get_notAfter(ret);
	row[DB_exp_date] = malloc(tm->length + 1);
	memcpy(row[DB_exp_date], tm->data, tm->length);
	row[DB_exp_date][tm->length] = '\0';

	row[DB_rev_date] = NULL;

	/* row[DB_serial] done already */
	row[DB_file] = malloc(8);
	row[DB_name] = X509_NAME_oneline(X509_get_subject_name(ret), NULL, 0);

	if ((row[DB_type] == NULL) || (row[DB_exp_date] == NULL) ||
	    (row[DB_file] == NULL) || (row[DB_name] == NULL)) {
		BIO_printf(bio_err, "Memory allocation failure\n");
		goto err;
	}
	(void) strlcpy(row[DB_file], "unknown", 8);
	row[DB_type][0] = 'V';
	row[DB_type][1] = '\0';

	if ((irow = reallocarray(NULL, DB_NUMBER + 1, sizeof(char *))) ==
	    NULL) {
		BIO_printf(bio_err, "Memory allocation failure\n");
		goto err;
	}
	for (i = 0; i < DB_NUMBER; i++) {
		irow[i] = row[i];
		row[i] = NULL;
	}
	irow[DB_NUMBER] = NULL;

	if (!TXT_DB_insert(db->db, irow)) {
		BIO_printf(bio_err, "failed to update database\n");
		BIO_printf(bio_err, "TXT_DB error number %ld\n", db->db->error);
		goto err;
	}
	ok = 1;
err:
	for (i = 0; i < DB_NUMBER; i++)
		free(row[i]);

	if (CAname != NULL)
		X509_NAME_free(CAname);
	if (subject != NULL)
		X509_NAME_free(subject);
	if ((dn_subject != NULL) && !email_dn)
		X509_NAME_free(dn_subject);
	if (tmptm != NULL)
		ASN1_UTCTIME_free(tmptm);
	if (ok <= 0) {
		if (ret != NULL)
			X509_free(ret);
		ret = NULL;
	} else
		*xret = ret;
	return (ok);
}

static void
write_new_certificate(BIO * bp, X509 * x, int output_der, int notext)
{
	if (output_der) {
		(void) i2d_X509_bio(bp, x);
		return;
	}
#if 0
	/* ??? Not needed since X509_print prints all this stuff anyway */
	f = X509_NAME_oneline(X509_get_issuer_name(x), buf, 256);
	BIO_printf(bp, "issuer :%s\n", f);

	f = X509_NAME_oneline(X509_get_subject_name(x), buf, 256);
	BIO_printf(bp, "subject:%s\n", f);

	BIO_puts(bp, "serial :");
	i2a_ASN1_INTEGER(bp, x->cert_info->serialNumber);
	BIO_puts(bp, "\n\n");
#endif
	if (!notext)
		X509_print(bp, x);
	PEM_write_bio_X509(bp, x);
}

static int
certify_spkac(X509 ** xret, char *infile, EVP_PKEY * pkey, X509 * x509,
    const EVP_MD * dgst, STACK_OF(OPENSSL_STRING) * sigopts,
    STACK_OF(CONF_VALUE) * policy, CA_DB * db, BIGNUM * serial, char *subj,
    unsigned long chtype, int multirdn, int email_dn, char *startdate,
    char *enddate, long days, char *ext_sect, CONF * lconf, int verbose,
    unsigned long certopt, unsigned long nameopt, int default_op, int ext_copy)
{
	STACK_OF(CONF_VALUE) * sk = NULL;
	LHASH_OF(CONF_VALUE) * parms = NULL;
	X509_REQ *req = NULL;
	CONF_VALUE *cv = NULL;
	NETSCAPE_SPKI *spki = NULL;
	X509_REQ_INFO *ri;
	char *type, *buf;
	EVP_PKEY *pktmp = NULL;
	X509_NAME *n = NULL;
	X509_NAME_ENTRY *ne = NULL;
	int ok = -1, i, j;
	long errline;
	int nid;

	/*
	 * Load input file into a hash table.  (This is just an easy
	 * way to read and parse the file, then put it into a convenient
	 * STACK format).
	 */
	parms = CONF_load(NULL, infile, &errline);
	if (parms == NULL) {
		BIO_printf(bio_err, "error on line %ld of %s\n",
		    errline, infile);
		ERR_print_errors(bio_err);
		goto err;
	}
	sk = CONF_get_section(parms, "default");
	if (sk_CONF_VALUE_num(sk) == 0) {
		BIO_printf(bio_err, "no name/value pairs found in %s\n",
		    infile);
		CONF_free(parms);
		goto err;
	}
	/*
	 * Now create a dummy X509 request structure.  We don't actually
	 * have an X509 request, but we have many of the components
	 * (a public key, various DN components).  The idea is that we
	 * put these components into the right X509 request structure
	 * and we can use the same code as if you had a real X509 request.
	 */
	req = X509_REQ_new();
	if (req == NULL) {
		ERR_print_errors(bio_err);
		goto err;
	}
	/*
	 * Build up the subject name set.
	 */
	ri = req->req_info;
	n = ri->subject;

	for (i = 0;; i++) {
		if (sk_CONF_VALUE_num(sk) <= i)
			break;

		cv = sk_CONF_VALUE_value(sk, i);
		type = cv->name;
		/*
		 * Skip past any leading X. X: X, etc to allow for multiple
		 * instances
		 */
		for (buf = cv->name; *buf; buf++) {
			if ((*buf == ':') || (*buf == ',') || (*buf == '.')) {
				buf++;
				if (*buf)
					type = buf;
				break;
			}
		}

		buf = cv->value;
		if ((nid = OBJ_txt2nid(type)) == NID_undef) {
			if (strcmp(type, "SPKAC") == 0) {
				spki = NETSCAPE_SPKI_b64_decode(cv->value, -1);
				if (spki == NULL) {
					BIO_printf(bio_err, "unable to load Netscape SPKAC structure\n");
					ERR_print_errors(bio_err);
					goto err;
				}
			}
			continue;
		}
		if (!X509_NAME_add_entry_by_NID(n, nid, chtype,
		    (unsigned char *)buf, -1, -1, 0))
			goto err;
	}
	if (spki == NULL) {
		BIO_printf(bio_err,
		    "Netscape SPKAC structure not found in %s\n", infile);
		goto err;
	}
	/*
	 * Now extract the key from the SPKI structure.
	 */

	BIO_printf(bio_err,
	    "Check that the SPKAC request matches the signature\n");

	if ((pktmp = NETSCAPE_SPKI_get_pubkey(spki)) == NULL) {
		BIO_printf(bio_err, "error unpacking SPKAC public key\n");
		goto err;
	}
	j = NETSCAPE_SPKI_verify(spki, pktmp);
	if (j <= 0) {
		BIO_printf(bio_err,
		    "signature verification failed on SPKAC public key\n");
		goto err;
	}
	BIO_printf(bio_err, "Signature ok\n");

	X509_REQ_set_pubkey(req, pktmp);
	EVP_PKEY_free(pktmp);
	ok = do_body(xret, pkey, x509, dgst, sigopts, policy, db, serial,
	    subj, chtype, multirdn, email_dn, startdate, enddate, days, 1,
	    verbose, req, ext_sect, lconf, certopt, nameopt, default_op,
	    ext_copy, 0);

err:
	if (req != NULL)
		X509_REQ_free(req);
	if (parms != NULL)
		CONF_free(parms);
	if (spki != NULL)
		NETSCAPE_SPKI_free(spki);
	if (ne != NULL)
		X509_NAME_ENTRY_free(ne);

	return (ok);
}

static int
check_time_format(const char *str)
{
	return ASN1_TIME_set_string(NULL, str);
}

static int
do_revoke(X509 * x509, CA_DB * db, int type, char *value)
{
	ASN1_UTCTIME *tm = NULL;
	char *row[DB_NUMBER], **rrow, **irow;
	char *rev_str = NULL;
	BIGNUM *bn = NULL;
	int ok = -1, i;

	for (i = 0; i < DB_NUMBER; i++)
		row[i] = NULL;
	row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);
	bn = ASN1_INTEGER_to_BN(X509_get_serialNumber(x509), NULL);
	if (!bn)
		goto err;
	if (BN_is_zero(bn))
		row[DB_serial] = strdup("00");
	else
		row[DB_serial] = BN_bn2hex(bn);
	BN_free(bn);
	if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {
		BIO_printf(bio_err, "Memory allocation failure\n");
		goto err;
	}
	/*
	 * We have to lookup by serial number because name lookup skips
	 * revoked certs
	 */
	rrow = TXT_DB_get_by_index(db->db, DB_serial, row);
	if (rrow == NULL) {
		BIO_printf(bio_err,
		    "Adding Entry with serial number %s to DB for %s\n",
		    row[DB_serial], row[DB_name]);

		/* We now just add it to the database */
		row[DB_type] = malloc(2);

		tm = X509_get_notAfter(x509);
		row[DB_exp_date] = malloc(tm->length + 1);
		memcpy(row[DB_exp_date], tm->data, tm->length);
		row[DB_exp_date][tm->length] = '\0';

		row[DB_rev_date] = NULL;

		/* row[DB_serial] done already */
		row[DB_file] = malloc(8);

		/* row[DB_name] done already */

		if ((row[DB_type] == NULL) || (row[DB_exp_date] == NULL) ||
		    (row[DB_file] == NULL)) {
			BIO_printf(bio_err, "Memory allocation failure\n");
			goto err;
		}
		(void) strlcpy(row[DB_file], "unknown", 8);
		row[DB_type][0] = 'V';
		row[DB_type][1] = '\0';

		if ((irow = reallocarray(NULL, sizeof(char *),
		    (DB_NUMBER + 1))) == NULL) {
			BIO_printf(bio_err, "Memory allocation failure\n");
			goto err;
		}
		for (i = 0; i < DB_NUMBER; i++) {
			irow[i] = row[i];
			row[i] = NULL;
		}
		irow[DB_NUMBER] = NULL;

		if (!TXT_DB_insert(db->db, irow)) {
			BIO_printf(bio_err, "failed to update database\n");
			BIO_printf(bio_err, "TXT_DB error number %ld\n",
			    db->db->error);
			goto err;
		}
		/* Revoke Certificate */
		ok = do_revoke(x509, db, type, value);

		goto err;

	} else if (index_name_cmp_noconst(row, rrow)) {
		BIO_printf(bio_err, "ERROR:name does not match %s\n",
		    row[DB_name]);
		goto err;
	} else if (rrow[DB_type][0] == 'R') {
		BIO_printf(bio_err, "ERROR:Already revoked, serial number %s\n",
		    row[DB_serial]);
		goto err;
	} else {
		BIO_printf(bio_err, "Revoking Certificate %s.\n",
		    rrow[DB_serial]);
		rev_str = make_revocation_str(type, value);
		if (!rev_str) {
			BIO_printf(bio_err, "Error in revocation arguments\n");
			goto err;
		}
		rrow[DB_type][0] = 'R';
		rrow[DB_type][1] = '\0';
		rrow[DB_rev_date] = rev_str;
	}
	ok = 1;

err:
	for (i = 0; i < DB_NUMBER; i++)
		free(row[i]);

	return (ok);
}

static int
get_certificate_status(const char *serial, CA_DB * db)
{
	char *row[DB_NUMBER], **rrow;
	int ok = -1, i;

	/* Free Resources */
	for (i = 0; i < DB_NUMBER; i++)
		row[i] = NULL;

	/* Malloc needed char spaces */
	row[DB_serial] = malloc(strlen(serial) + 2);
	if (row[DB_serial] == NULL) {
		BIO_printf(bio_err, "Malloc failure\n");
		goto err;
	}
	if (strlen(serial) % 2) {
		/* Set the first char to 0 */ ;
		row[DB_serial][0] = '0';

		/* Copy String from serial to row[DB_serial] */
		memcpy(row[DB_serial] + 1, serial, strlen(serial));
		row[DB_serial][strlen(serial) + 1] = '\0';
	} else {
		/* Copy String from serial to row[DB_serial] */
		memcpy(row[DB_serial], serial, strlen(serial));
		row[DB_serial][strlen(serial)] = '\0';
	}

	/* Make it Upper Case */
	for (i = 0; row[DB_serial][i] != '\0'; i++)
		row[DB_serial][i] = toupper((unsigned char) row[DB_serial][i]);


	ok = 1;

	/* Search for the certificate */
	rrow = TXT_DB_get_by_index(db->db, DB_serial, row);
	if (rrow == NULL) {
		BIO_printf(bio_err, "Serial %s not present in db.\n",
		    row[DB_serial]);
		ok = -1;
		goto err;
	} else if (rrow[DB_type][0] == 'V') {
		BIO_printf(bio_err, "%s=Valid (%c)\n",
		    row[DB_serial], rrow[DB_type][0]);
		goto err;
	} else if (rrow[DB_type][0] == 'R') {
		BIO_printf(bio_err, "%s=Revoked (%c)\n",
		    row[DB_serial], rrow[DB_type][0]);
		goto err;
	} else if (rrow[DB_type][0] == 'E') {
		BIO_printf(bio_err, "%s=Expired (%c)\n",
		    row[DB_serial], rrow[DB_type][0]);
		goto err;
	} else if (rrow[DB_type][0] == 'S') {
		BIO_printf(bio_err, "%s=Suspended (%c)\n",
		    row[DB_serial], rrow[DB_type][0]);
		goto err;
	} else {
		BIO_printf(bio_err, "%s=Unknown (%c).\n",
		    row[DB_serial], rrow[DB_type][0]);
		ok = -1;
	}

err:
	for (i = 0; i < DB_NUMBER; i++)
		free(row[i]);

	return (ok);
}

static int
do_updatedb(CA_DB * db)
{
	ASN1_UTCTIME *a_tm = NULL;
	int i, cnt = 0;
	int db_y2k, a_y2k;	/* flags = 1 if y >= 2000 */
	char **rrow, *a_tm_s;

	a_tm = ASN1_UTCTIME_new();

	/* get actual time and make a string */
	a_tm = X509_gmtime_adj(a_tm, 0);
	a_tm_s = malloc(a_tm->length + 1);
	if (a_tm_s == NULL) {
		cnt = -1;
		goto err;
	}
	memcpy(a_tm_s, a_tm->data, a_tm->length);
	a_tm_s[a_tm->length] = '\0';

	if (strncmp(a_tm_s, "49", 2) <= 0)
		a_y2k = 1;
	else
		a_y2k = 0;

	for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {
		rrow = sk_OPENSSL_PSTRING_value(db->db->data, i);

		if (rrow[DB_type][0] == 'V') {
			/* ignore entries that are not valid */
			if (strncmp(rrow[DB_exp_date], "49", 2) <= 0)
				db_y2k = 1;
			else
				db_y2k = 0;

			if (db_y2k == a_y2k) {
				/* all on the same y2k side */
				if (strcmp(rrow[DB_exp_date], a_tm_s) <= 0) {
					rrow[DB_type][0] = 'E';
					rrow[DB_type][1] = '\0';
					cnt++;

					BIO_printf(bio_err, "%s=Expired\n",
					    rrow[DB_serial]);
				}
			} else if (db_y2k < a_y2k) {
				rrow[DB_type][0] = 'E';
				rrow[DB_type][1] = '\0';
				cnt++;

				BIO_printf(bio_err, "%s=Expired\n",
				    rrow[DB_serial]);
			}
		}
	}

err:
	ASN1_UTCTIME_free(a_tm);
	free(a_tm_s);

	return (cnt);
}

static const char *crl_reasons[] = {
	/* CRL reason strings */
	"unspecified",
	"keyCompromise",
	"CACompromise",
	"affiliationChanged",
	"superseded",
	"cessationOfOperation",
	"certificateHold",
	"removeFromCRL",
	/* Additional pseudo reasons */
	"holdInstruction",
	"keyTime",
	"CAkeyTime"
};

#define NUM_REASONS (sizeof(crl_reasons) / sizeof(char *))

/* Given revocation information convert to a DB string.
 * The format of the string is:
 * revtime[,reason,extra]. Where 'revtime' is the
 * revocation time (the current time). 'reason' is the
 * optional CRL reason and 'extra' is any additional
 * argument
 */

char *
make_revocation_str(int rev_type, char *rev_arg)
{
	char *other = NULL, *str;
	const char *reason = NULL;
	ASN1_OBJECT *otmp;
	ASN1_UTCTIME *revtm = NULL;
	int i;
	switch (rev_type) {
	case REV_NONE:
		break;

	case REV_CRL_REASON:
		for (i = 0; i < 8; i++) {
			if (!strcasecmp(rev_arg, crl_reasons[i])) {
				reason = crl_reasons[i];
				break;
			}
		}
		if (reason == NULL) {
			BIO_printf(bio_err, "Unknown CRL reason %s\n", rev_arg);
			return NULL;
		}
		break;

	case REV_HOLD:
		/* Argument is an OID */

		otmp = OBJ_txt2obj(rev_arg, 0);
		ASN1_OBJECT_free(otmp);

		if (otmp == NULL) {
			BIO_printf(bio_err,
			    "Invalid object identifier %s\n", rev_arg);
			return NULL;
		}
		reason = "holdInstruction";
		other = rev_arg;
		break;

	case REV_KEY_COMPROMISE:
	case REV_CA_COMPROMISE:

		/* Argument is the key compromise time  */
		if (!ASN1_GENERALIZEDTIME_set_string(NULL, rev_arg)) {
			BIO_printf(bio_err,
			    "Invalid time format %s. Need YYYYMMDDHHMMSSZ\n",
			    rev_arg);
			return NULL;
		}
		other = rev_arg;
		if (rev_type == REV_KEY_COMPROMISE)
			reason = "keyTime";
		else
			reason = "CAkeyTime";

		break;

	}

	revtm = X509_gmtime_adj(NULL, 0);
	if (asprintf(&str, "%s%s%s%s%s", revtm->data,
	    reason ? "," : "", reason ? reason : "",
	    other ? "," : "", other ? other : "") == -1)
		str = NULL;
	ASN1_UTCTIME_free(revtm);
	return str;
}

/* Convert revocation field to X509_REVOKED entry
 * return code:
 * 0 error
 * 1 OK
 * 2 OK and some extensions added (i.e. V2 CRL)
 */

int
make_revoked(X509_REVOKED * rev, const char *str)
{
	char *tmp = NULL;
	int reason_code = -1;
	int i, ret = 0;
	ASN1_OBJECT *hold = NULL;
	ASN1_GENERALIZEDTIME *comp_time = NULL;
	ASN1_ENUMERATED *rtmp = NULL;

	ASN1_TIME *revDate = NULL;

	i = unpack_revinfo(&revDate, &reason_code, &hold, &comp_time, str);

	if (i == 0)
		goto err;

	if (rev && !X509_REVOKED_set_revocationDate(rev, revDate))
		goto err;

	if (rev && (reason_code != OCSP_REVOKED_STATUS_NOSTATUS)) {
		rtmp = ASN1_ENUMERATED_new();
		if (!rtmp || !ASN1_ENUMERATED_set(rtmp, reason_code))
			goto err;
		if (!X509_REVOKED_add1_ext_i2d(rev, NID_crl_reason, rtmp, 0, 0))
			goto err;
	}
	if (rev && comp_time) {
		if (!X509_REVOKED_add1_ext_i2d(rev, NID_invalidity_date,
		    comp_time, 0, 0))
			goto err;
	}
	if (rev && hold) {
		if (!X509_REVOKED_add1_ext_i2d(rev, NID_hold_instruction_code,
		    hold, 0, 0))
			goto err;
	}
	if (reason_code != OCSP_REVOKED_STATUS_NOSTATUS)
		ret = 2;
	else
		ret = 1;

err:
	free(tmp);

	ASN1_OBJECT_free(hold);
	ASN1_GENERALIZEDTIME_free(comp_time);
	ASN1_ENUMERATED_free(rtmp);
	ASN1_TIME_free(revDate);

	return ret;
}

int
old_entry_print(BIO * bp, ASN1_OBJECT * obj, ASN1_STRING * str)
{
	char buf[25], *pbuf, *p;
	int j;

	j = i2a_ASN1_OBJECT(bp, obj);
	pbuf = buf;
	for (j = 22 - j; j > 0; j--)
		*(pbuf++) = ' ';
	*(pbuf++) = ':';
	*(pbuf++) = '\0';
	BIO_puts(bp, buf);

	if (str->type == V_ASN1_PRINTABLESTRING)
		BIO_printf(bp, "PRINTABLE:'");
	else if (str->type == V_ASN1_T61STRING)
		BIO_printf(bp, "T61STRING:'");
	else if (str->type == V_ASN1_IA5STRING)
		BIO_printf(bp, "IA5STRING:'");
	else if (str->type == V_ASN1_UNIVERSALSTRING)
		BIO_printf(bp, "UNIVERSALSTRING:'");
	else
		BIO_printf(bp, "ASN.1 %2d:'", str->type);

	p = (char *) str->data;
	for (j = str->length; j > 0; j--) {
		if ((*p >= ' ') && (*p <= '~'))
			BIO_printf(bp, "%c", *p);
		else if (*p & 0x80)
			BIO_printf(bp, "\\0x%02X", *p);
		else if ((unsigned char) *p == 0xf7)
			BIO_printf(bp, "^?");
		else
			BIO_printf(bp, "^%c", *p + '@@');
		p++;
	}
	BIO_printf(bp, "'\n");
	return 1;
}

int
unpack_revinfo(ASN1_TIME ** prevtm, int *preason, ASN1_OBJECT ** phold,
    ASN1_GENERALIZEDTIME ** pinvtm, const char *str)
{
	char *tmp = NULL;
	char *rtime_str, *reason_str = NULL, *arg_str = NULL, *p;
	int reason_code = -1;
	int ret = 0;
	unsigned int i;
	ASN1_OBJECT *hold = NULL;
	ASN1_GENERALIZEDTIME *comp_time = NULL;

	if ((tmp = strdup(str)) == NULL) {
		BIO_printf(bio_err, "malloc failed\n");
		goto err;
	}
	p = strchr(tmp, ',');
	rtime_str = tmp;

	if (p) {
		*p = '\0';
		p++;
		reason_str = p;
		p = strchr(p, ',');
		if (p) {
			*p = '\0';
			arg_str = p + 1;
		}
	}
	if (prevtm) {
		*prevtm = ASN1_UTCTIME_new();
		if (!ASN1_UTCTIME_set_string(*prevtm, rtime_str)) {
			BIO_printf(bio_err, "invalid revocation date %s\n",
			    rtime_str);
			goto err;
		}
	}
	if (reason_str) {
		for (i = 0; i < NUM_REASONS; i++) {
			if (!strcasecmp(reason_str, crl_reasons[i])) {
				reason_code = i;
				break;
			}
		}
		if (reason_code == OCSP_REVOKED_STATUS_NOSTATUS) {
			BIO_printf(bio_err, "invalid reason code %s\n",
			    reason_str);
			goto err;
		}
		if (reason_code == 7)
			reason_code = OCSP_REVOKED_STATUS_REMOVEFROMCRL;
		else if (reason_code == 8) {	/* Hold instruction */
			if (!arg_str) {
				BIO_printf(bio_err,
				    "missing hold instruction\n");
				goto err;
			}
			reason_code = OCSP_REVOKED_STATUS_CERTIFICATEHOLD;
			hold = OBJ_txt2obj(arg_str, 0);

			if (!hold) {
				BIO_printf(bio_err,
				    "invalid object identifier %s\n", arg_str);
				goto err;
			}
			if (phold)
				*phold = hold;
		} else if ((reason_code == 9) || (reason_code == 10)) {
			if (!arg_str) {
				BIO_printf(bio_err,
				    "missing compromised time\n");
				goto err;
			}
			comp_time = ASN1_GENERALIZEDTIME_new();
			if (!ASN1_GENERALIZEDTIME_set_string(comp_time,
			    arg_str)) {
				BIO_printf(bio_err,
				    "invalid compromised time %s\n", arg_str);
				goto err;
			}
			if (reason_code == 9)
				reason_code = OCSP_REVOKED_STATUS_KEYCOMPROMISE;
			else
				reason_code = OCSP_REVOKED_STATUS_CACOMPROMISE;
		}
	}
	if (preason)
		*preason = reason_code;
	if (pinvtm)
		*pinvtm = comp_time;
	else
		ASN1_GENERALIZEDTIME_free(comp_time);

	ret = 1;

err:
	free(tmp);

	if (!phold)
		ASN1_OBJECT_free(hold);
	if (!pinvtm)
		ASN1_GENERALIZEDTIME_free(comp_time);

	return ret;
}

static char *
bin2hex(unsigned char * data, size_t len)
{
	char *ret = NULL;
	char hex[] = "0123456789ABCDEF";
	int i;

	if ((ret = malloc(len * 2 + 1))) {
		for (i = 0; i < len; i++) {
			ret[i * 2 + 0] = hex[data[i] >> 4];
			ret[i * 2 + 1] = hex[data[i] & 0x0F];
		}
		ret[len * 2] = '\0';
	}
	return ret;
}
@


1.65
log
@Fix a usage string; the proper spelling of 'alot' is 'a lot'.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ca.c,v 1.64 2014/07/14 00:35:10 deraadt Exp $ */
@


1.64
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: ca.c,v 1.63 2014/07/13 16:03:09 beck Exp $ */
d131 1
a131 1
	" -verbose        - Talk alot while doing things\n",
@


1.63
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ca.c,v 1.62 2014/07/12 17:54:31 jsing Exp $ */
d1372 1
a1372 1
	
@


1.62
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ca.c,v 1.61 2014/07/09 21:13:34 tedu Exp $ */
d1732 1
a1732 1
		row[DB_serial] = BUF_strdup("00");
d2198 1
a2198 1
		row[DB_serial] = BUF_strdup("00");
d2634 4
a2637 1
	tmp = BUF_strdup(str);
@


1.61
log
@unfidef RL_DEBUG. hopefully it's been debugged by now
@
text
@d1 1
a1 1
/* $OpenBSD: ca.c,v 1.60 2014/06/28 04:39:41 deraadt Exp $ */
a545 3

	if (!load_config(bio_err, conf))
		goto err;
@


1.60
log
@Use strtonum() instead of atoi(), and then impose what are we think
are the current range checks.  Help from millert and lteo.  Please test
now that it is deployed and let us know if any numbers are off..
ok lteo
@
text
@d1 1
a1 1
/* $OpenBSD: ca.c,v 1.59 2014/06/12 15:49:27 deraadt Exp $ */
a605 3
#ifdef RL_DEBUG
		BIO_printf(bio_err, "DEBUG: unique_subject = \"%s\"\n", p);
#endif
a608 8
#ifdef RL_DEBUG
	if (!p)
		BIO_printf(bio_err, "DEBUG: unique_subject undefined\n", p);
#endif
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: configured unique_subject is %d\n",
	    db_attr.unique_subject);
#endif
@


1.59
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d66 1
d300 1
d345 3
a347 1
			days = atoi(*(++argv));
d414 3
a416 1
			crldays = atol(*(++argv));
d420 3
a422 1
			crlhours = atol(*(++argv));
d426 3
a428 1
			crlsec = atol(*(++argv));
d497 5
a501 1
			BIO_printf(bio_err, "unknown option %s\n", *argv);
@


1.58
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* apps/ca.c */
@


1.57
log
@Remove RANDFILE remnants.
@
text
@d1954 1
a1954 1
	row[DB_type] = (char *) malloc(2);
d1957 1
a1957 1
	row[DB_exp_date] = (char *) malloc(tm->length + 1);
d1964 1
a1964 1
	row[DB_file] = (char *) malloc(8);
d2217 1
a2217 1
		row[DB_type] = (char *) malloc(2);
d2220 1
a2220 1
		row[DB_exp_date] = (char *) malloc(tm->length + 1);
d2227 1
a2227 1
		row[DB_file] = (char *) malloc(8);
d2375 1
a2375 1
	a_tm_s = (char *) malloc(a_tm->length + 1);
@


1.56
log
@ok, next pass after review:  when possible, put the reallocarray arguments
in the "size_t nmemb, size_t size"
@
text
@a99 1
#define ENV_RANDFILE		"RANDFILE"
@


1.55
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d1977 1
a1977 1
	if ((irow = reallocarray(NULL, sizeof(char *), (DB_NUMBER + 1))) ==
@


1.54
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@d1977 1
a1977 1
	if ((irow = (char **)malloc(sizeof(char *) * (DB_NUMBER + 1))) ==
d2241 1
a2241 1
		if ((irow = (char **)malloc(sizeof(char *) *
@


1.53
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a301 2
	signal(SIGPIPE, SIG_IGN);

@


1.52
log
@Out of all the openssl apps, just one of them has code to mess around with
electric fence externs. Nuke from orbit.

ok miod@@
@
text
@d533 3
a535 4
	if (tofree) {
		free(tofree);
		tofree = NULL;
	}
d1349 2
a1350 2
	if (tofree)
		free(tofree);
d1998 1
a1998 2
		if (row[i] != NULL)
			free(row[i]);
d2288 3
a2290 4
	for (i = 0; i < DB_NUMBER; i++) {
		if (row[i] != NULL)
			free(row[i]);
	}
d2360 3
a2362 4
	for (i = 0; i < DB_NUMBER; i++) {
		if (row[i] != NULL)
			free(row[i]);
	}
d2574 2
a2575 2
	if (tmp)
		free(tmp);
d2718 2
a2719 2
	if (tmp)
		free(tmp);
@


1.51
log
@W_OK comes via unistd.h - nuke several #ifndef W_OK that attempt to handle
missing defines.
@
text
@a171 6
#ifdef EFENCE
extern int EF_PROTECT_FREE;
extern int EF_PROTECT_BELOW;
extern int EF_ALIGNMENT;
#endif

a300 6

#ifdef EFENCE
	EF_PROTECT_FREE = 1;
	EF_PROTECT_BELOW = 1;
	EF_ALIGNMENT = 0;
#endif
@


1.50
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@a62 4
#ifndef W_OK
#include <sys/file.h>
#endif

d83 1
a83 8
#ifndef W_OK
#define F_OK 0
#define X_OK 1
#define W_OK 2
#define R_OK 4
#endif

#define BASE_SECTION	"ca"
d87 1
a87 1
#define STRING_MASK	"string_mask"
@


1.49
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d61 7
a70 1
#include <ctype.h>
d72 5
a76 1
#include <sys/types.h>
a77 1
#include <openssl/bio.h>
a78 2
#include <openssl/bn.h>
#include <openssl/txt_db.h>
a79 2
#include <openssl/x509.h>
#include <openssl/x509v3.h>
d83 3
a85 6

#ifndef W_OK
#include <sys/file.h>
#endif

#include "apps.h"
a92 1

@


1.48
log
@remove crazy #undefs; ok jsing
@
text
@a331 3
	if (bio_err == NULL)
		if ((bio_err = BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);
@


1.47
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a309 1
#undef BSIZE
@


1.46
log
@More KNF.
@
text
@d325 1
a325 1
	apps_startup();
d1402 1
a1402 1
	apps_shutdown();
@


1.45
log
@More KNF.
@
text
@d2128 1
a2128 1
	for (i = 0; ; i++) {
@


1.44
log
@Fix some serious pointer-arithmatic-magic-number-unchecked-return eyebleed
that I stumbled into here and got stuck with.  If modern society can get past
selling daughters for cows, surely we can decide to write modern C code in
an "application" that is probably 3 lines of shell/python/cgi away from
talking to the internet in a lot of places.. (This file still needs a lot
more love though)
"oh god yuck" deraadt@@
ok tedu@@
@
text
@d189 1
a189 2
static int 
certify(X509 ** xret, char *infile, EVP_PKEY * pkey, X509 * x509,
d196 2
a197 3
static int certify_cert(X509 ** xret, char *infile, EVP_PKEY * pkey, X509 * x509,
    const EVP_MD * dgst, 
    STACK_OF(OPENSSL_STRING) * sigopts,
d203 2
a204 3
static int certify_spkac(X509 ** xret, char *infile, EVP_PKEY * pkey, X509 * x509,
     const EVP_MD * dgst, 
    STACK_OF(OPENSSL_STRING) * sigopts,
d209 9
a217 8
static void write_new_certificate(BIO * bp, X509 * x, int output_der, int notext);
static int do_body(X509 ** xret, EVP_PKEY * pkey, X509 * x509, const EVP_MD * dgst,
    STACK_OF(OPENSSL_STRING) * sigopts, STACK_OF(CONF_VALUE) * policy, CA_DB * db,
    BIGNUM * serial, char *subj, unsigned long chtype, int multirdn,
    int email_dn, char *startdate, char *enddate, long days, int batch,
    int verbose, X509_REQ * req, char *ext_sect, CONF * conf,
    unsigned long certopt, unsigned long nameopt, int default_op,
    int ext_copy, int selfsign);
d421 2
a422 1
			if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))
d515 1
a515 1
	bad:
d550 2
a551 1
			BIO_printf(bio_err, "error loading the config file '%s'\n",
d554 3
a556 2
			BIO_printf(bio_err, "error on line %ld of config file '%s'\n"
			    ,errorline, configfile);
d588 2
a589 1
				BIO_printf(bio_err,"problems opening %s for extra oid's\n",p);
d608 2
a609 1
		BIO_printf(bio_err, "Invalid global string mask setting %s\n", f);
d648 2
a649 1
		if ((dbfile = NCONF_get_string(conf, section, ENV_DATABASE)) == NULL) {
d669 1
a669 1
			section, ENV_PRIVATE_KEY)) == NULL)) {
d692 1
a692 1
				section, ENV_CERTIFICATE)) == NULL)) {
d702 2
a703 1
			BIO_printf(bio_err, "CA certificate and CA private key do not match\n");
d725 2
a726 1
			BIO_printf(bio_err, "Invalid name options: \"%s\"\n", f);
d737 2
a738 1
			BIO_printf(bio_err, "Invalid certificate options: \"%s\"\n", f);
d749 2
a750 1
			BIO_printf(bio_err, "Invalid extension copy option: \"%s\"\n", f);
d761 1
a761 1
			    ENV_NEW_CERTS_DIR)) == NULL) {
d770 1
a770 1
		 * 
d777 2
a778 1
			BIO_printf(bio_err, "I am unable to access the %s directory\n", outdir);
d783 2
a784 1
			BIO_printf(bio_err, "%s need to be a directory\n", outdir);
d813 2
a814 1
			BIO_printf(bio_err, "entry %d: invalid expiry date\n", i + 1);
d824 3
a826 1
			BIO_printf(bio_err, "entry %d: bad serial number length (%d)\n", i + 1, j);
d831 2
a832 2
				((*p >= 'A') && (*p <= 'F')) ||
				((*p >= 'a') && (*p <= 'f')))) {
d853 1
a853 2
			BIO_printf(bio_err, "Updating %s ...\n",
			    dbfile);
d881 2
a882 1
				BIO_printf(bio_err, "ERROR: loading the config file '%s'\n",
d885 2
a886 1
				BIO_printf(bio_err, "ERROR: on line %ld of config file '%s'\n",
d892 3
a894 1
			BIO_printf(bio_err, "Successfully loaded extensions file %s\n", extfile);
d897 2
a898 1
		if (!extensions && !(extensions = NCONF_get_string(extconf, "default", "extensions")))
d912 2
a913 2
	if ((md == NULL) && ((md = NCONF_get_string(conf,
			section, ENV_DEFAULT_MD)) == NULL)) {
d926 2
a927 1
		BIO_printf(bio_err, "%s is an unsupported message digest type\n", md);
d932 1
a932 1
				section, ENV_DEFAULT_EMAIL_DN)) != NULL)) {
d940 1
a940 1
				section, ENV_POLICY)) == NULL)) {
d947 2
a948 2
		if ((serialfile = NCONF_get_string(conf, section, ENV_SERIAL))
		    == NULL) {
d968 2
a969 2
				if (!X509V3_EXT_add_nconf(conf, &ctx, extensions,
					NULL)) {
d1002 2
a1003 1
			if (!NCONF_get_number(conf, section, ENV_DEFAULT_DAYS, &days))
d1007 2
a1008 1
			BIO_printf(bio_err, "cannot lookup how many days to certify for\n");
d1011 4
a1014 2
		if ((serial = load_serial(serialfile, create_ser, NULL)) == NULL) {
			BIO_printf(bio_err, "error while loading serial number\n");
d1019 2
a1020 1
				BIO_printf(bio_err, "next serial number is 00\n");
d1024 2
a1025 1
				BIO_printf(bio_err, "next serial number is %s\n", f);
d1030 2
a1031 1
			BIO_printf(bio_err, "unable to find 'section' for %s\n", policy);
d1040 5
a1044 4
			j = certify_spkac(&x, spkac_file, pkey, x509, dgst, sigopts,
			    attribs, db, serial, subj, chtype, multirdn,
			    email_dn, startdate, enddate, days, extensions,
			    conf, verbose, certopt, nameopt, default_op, ext_copy);
d1053 2
a1054 1
					BIO_printf(bio_err, "Memory allocation failure\n");
d1065 3
a1067 3
			j = certify_cert(&x, ss_cert_file, pkey, x509, dgst, sigopts,
			    attribs,
			    db, serial, subj, chtype, multirdn, email_dn, startdate, enddate, days, batch,
d1078 2
a1079 1
					BIO_printf(bio_err, "Memory allocation failure\n");
d1086 3
a1088 2
			j = certify(&x, infile, pkey, x509p, dgst, sigopts, attribs, db,
			    serial, subj, chtype, multirdn, email_dn, startdate, enddate, days, batch,
d1099 2
a1100 1
					BIO_printf(bio_err, "Memory allocation failure\n");
d1107 3
a1109 2
			j = certify(&x, argv[i], pkey, x509p, dgst, sigopts, attribs, db,
			    serial, subj, chtype, multirdn, email_dn, startdate, enddate, days, batch,
d1120 2
a1121 1
					BIO_printf(bio_err, "Memory allocation failure\n");
d1165 1
a1165 1
			data = (unsigned char *) x->cert_info->serialNumber->data;
d1227 6
a1232 4
		if ((crlnumberfile = NCONF_get_string(conf, section, ENV_CRLNUMBER))
		    != NULL)
			if ((crlnumber = load_serial(crlnumberfile, 0, NULL)) == NULL) {
				BIO_printf(bio_err, "error while loading CRL number\n");
d1237 1
a1237 1
				ENV_DEFAULT_CRL_DAYS, &crldays))
d1240 1
a1240 1
				ENV_DEFAULT_CRL_HOURS, &crlhours))
d1260 2
a1261 2
		if (!X509_time_adj_ex(tmptm, crldays, crlhours * 60 * 60 + crlsec,
			NULL)) {
d1310 1
a1310 1
					crl_ext, crl))
d1316 2
a1317 1
				X509_CRL_add1_ext_i2d(crl, NID_crl_number, tmpser, 0, 0);
d1374 1
d1443 2
a1444 1
		BIO_printf(bio_err, "Certificate request and CA private key do not match\n");
d1461 2
a1462 1
		BIO_printf(bio_err, "Signature did not match the certificate request\n");
d1467 4
a1470 4
	ok = do_body(xret, pkey, x509, dgst, sigopts, policy, db, serial, subj, chtype,
	    multirdn, email_dn,
	    startdate, enddate, days, batch, verbose, req, ext_sect, lconf,
	    certopt, nameopt, default_op, ext_copy, selfsign);
d1494 2
a1495 1
	if ((req = load_cert(bio_err, infile, FORMAT_PEM, NULL, e, infile)) == NULL)
d1515 2
a1516 1
		BIO_printf(bio_err, "Signature did not match the certificate\n");
d1524 3
a1526 2
	ok = do_body(xret, pkey, x509, dgst, sigopts, policy, db, serial, subj, chtype, multirdn, email_dn, startdate, enddate,
	    days, batch, verbose, rreq, ext_sect, lconf, certopt, nameopt, default_op,
d1583 2
a1584 1
		BIO_printf(bio_err, "The Subject's Distinguished Name is as follows\n");
d1617 2
a1618 1
		if ((str->type != V_ASN1_BMPSTRING) && (str->type != V_ASN1_UTF8STRING)) {
d1621 1
a1621 1
				(str->type != V_ASN1_T61STRING)) ||
d1623 1
a1623 1
				(str->type == V_ASN1_PRINTABLESTRING))) {
d1687 1
a1687 1
		again2:
d1711 2
a1712 1
				if (!X509_NAME_add_entry(subject, push, -1, 0)) {
d1715 2
a1716 1
					BIO_printf(bio_err, "Memory allocation failure\n");
d1754 1
a1754 1
			    NID_pkcs9_emailAddress, -1)) >= 0) {
d1782 2
a1783 1
			BIO_printf(bio_err, "ERROR:Serial number %s has already been issued,\n",
d1894 2
a1895 1
				BIO_printf(bio_err, "Extra configuration file found\n");
d1904 2
a1905 1
			if (!X509V3_EXT_add_nconf(extconf, &ctx, ext_sect, ret)) {
d1919 3
a1921 1
				BIO_printf(bio_err, "ERROR: adding extensions in section %s\n", ext_sect);
d1962 2
a1963 1
			BIO_printf(bio_err, "CERTIFICATE WILL NOT BE CERTIFIED: I/O error\n");
d1968 2
a1969 1
			BIO_printf(bio_err, "CERTIFICATE WILL NOT BE CERTIFIED\n");
d2006 2
a2007 1
	if ((irow = (char **) malloc(sizeof(char *) * (DB_NUMBER + 1))) == NULL) {
d2098 2
a2099 1
		BIO_printf(bio_err, "error on line %ld of %s\n", errline, infile);
d2105 2
a2106 1
		BIO_printf(bio_err, "no name/value pairs found in %s\n", infile);
d2128 1
a2128 1
	for (i = 0;; i++) {
d2160 1
a2160 1
			(unsigned char *) buf, -1, -1, 0))
d2164 2
a2165 2
		BIO_printf(bio_err, "Netscape SPKAC structure not found in %s\n",
		    infile);
d2172 2
a2173 1
	BIO_printf(bio_err, "Check that the SPKAC request matches the signature\n");
d2181 2
a2182 1
		BIO_printf(bio_err, "signature verification failed on SPKAC public key\n");
d2189 5
a2193 3
	ok = do_body(xret, pkey, x509, dgst, sigopts, policy, db, serial, subj, chtype,
	    multirdn, email_dn, startdate, enddate, days, 1, verbose, req,
	    ext_sect, lconf, certopt, nameopt, default_op, ext_copy, 0);
d2243 3
a2245 1
		BIO_printf(bio_err, "Adding Entry with serial number %s to DB for %s\n", row[DB_serial], row[DB_name]);
d2271 2
a2272 1
		if ((irow = (char **) malloc(sizeof(char *) * (DB_NUMBER + 1))) == NULL) {
d2284 2
a2285 1
			BIO_printf(bio_err, "TXT_DB error number %ld\n", db->db->error);
d2302 2
a2303 1
		BIO_printf(bio_err, "Revoking Certificate %s.\n", rrow[DB_serial]);
d2314 1
d2340 1
a2340 1
		 /* Set the first char to 0 */ ;
d2387 1
d2396 1
a2396 1
static int 
d2517 2
a2518 1
			BIO_printf(bio_err, "Invalid object identifier %s\n", rev_arg);
d2530 3
a2532 1
			BIO_printf(bio_err, "Invalid time format %s. Need YYYYMMDDHHMMSSZ\n", rev_arg);
d2547 3
a2549 3
		reason ? "," : "", reason ? reason : "",
		other ? "," : "", other ? other : "") == -1)
	    str = NULL;
d2589 2
a2590 1
		if (!X509_REVOKED_add1_ext_i2d(rev, NID_invalidity_date, comp_time, 0, 0))
d2594 2
a2595 1
		if (!X509_REVOKED_add1_ext_i2d(rev, NID_hold_instruction_code, hold, 0, 0))
a2603 1

d2619 1
d2666 1
a2667 1

a2668 1

d2684 2
a2685 1
			BIO_printf(bio_err, "invalid revocation date %s\n", rtime_str);
d2697 2
a2698 1
			BIO_printf(bio_err, "invalid reason code %s\n", reason_str);
d2705 2
a2706 1
				BIO_printf(bio_err, "missing hold instruction\n");
d2713 2
a2714 1
				BIO_printf(bio_err, "invalid object identifier %s\n", arg_str);
d2721 2
a2722 1
				BIO_printf(bio_err, "missing compromised time\n");
d2726 4
a2729 2
			if (!ASN1_GENERALIZEDTIME_set_string(comp_time, arg_str)) {
				BIO_printf(bio_err, "invalid compromised time %s\n", arg_str);
a2757 1

d2762 1
a2762 1
	char hex[]= "0123456789ABCDEF";
d2766 2
a2767 3
		for (i = 0; i < len; i++)
		{
			ret[i * 2 + 0] = hex[data[i] >> 4  ];
@


1.43
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d224 1
d1127 2
a1128 1
			char *n;
d1133 13
a1145 19
			p = (const char *) x->cert_info->serialNumber->data;

			if (strlen(outdir) >= (size_t) (j ? BSIZE - j * 2 - 6 : BSIZE - 8)) {
				BIO_printf(bio_err, "certificate file name too long\n");
				goto err;
			}
			strlcpy(buf[2], outdir, sizeof(buf[2]));

			strlcat(buf[2], "/", sizeof(buf[2]));

			n = (char *) &(buf[2][strlen(buf[2])]);
			if (j > 0) {
				for (k = 0; k < j; k++) {
					if (n >= &(buf[2][sizeof(buf[2])]))
						break;
					snprintf(n,
					    &buf[2][0] + sizeof(buf[2]) - n,
					    "%02X", (unsigned char) *(p++));
					n += 2;
d1148 3
a1150 2
				*(n++) = '0';
				*(n++) = '0';
a1151 5
			*(n++) = '.';
			*(n++) = 'p';
			*(n++) = 'e';
			*(n++) = 'm';
			*n = '\0';
d1950 1
a1950 1
	strlcpy(row[DB_file], "unknown", 8);
d2206 1
a2206 1
		strlcpy(row[DB_file], "unknown", 8);
d2477 4
a2480 24

	i = revtm->length + 1;

	if (reason)
		i += strlen(reason)
		    + 1;
	if (other)
		i += strlen(other)
		    + 1;

	str = malloc(i);

	if (!str)
		return NULL;

	strlcpy(str, (char *) revtm->data, i);
	if (reason) {
		strlcat(str, ",", i);
		strlcat(str, reason, i);
	}
	if (other) {
		strlcat(str, ",", i);
		strlcat(str, other, i);
	}
d2678 19
@


1.42
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d1146 1
a1146 1
					(void) snprintf(n,
@


1.41
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d1139 1
a1139 1
			BUF_strlcat(buf[2], "/", sizeof(buf[2]));
d1958 1
a1958 1
	BUF_strlcpy(row[DB_file], "unknown", 8);
d2214 1
a2214 1
		BUF_strlcpy(row[DB_file], "unknown", 8);
d2500 1
a2500 1
	BUF_strlcpy(str, (char *) revtm->data, i);
d2502 2
a2503 2
		BUF_strlcat(str, ",", i);
		BUF_strlcat(str, reason, i);
d2506 2
a2507 2
		BUF_strlcat(str, ",", i);
		BUF_strlcat(str, other, i);
@


1.40
log
@Use the cleaned up asprintf-based make_config_name() to make the name of
the config file instead of the malloc/BUF_strlcpy/BUF_strlcat calls with
no return value checks (that make_config_name() also used to do prior to
being cleaned up).

ok beck@@
@
text
@a313 1
	char *randfile = NULL;
a599 5
	randfile = NCONF_get_string(conf, BASE_SECTION, "RANDFILE");
	if (randfile == NULL)
		ERR_clear_error();
	app_RAND_load_file(randfile, bio_err, 0);

a1359 1
	app_RAND_write_file(randfile, bio_err);
@


1.39
log
@repair whitespace. this is what happens when functions take 20 params.
@
text
@a93 1
#define CONFIG_FILE "openssl.cnf"
d541 4
a544 8
		const char *s = X509_get_default_cert_area();
		size_t len;

		len = strlen(s) + sizeof(CONFIG_FILE) + 1;
		tofree = malloc(len);
		BUF_strlcpy(tofree, s, len);
		BUF_strlcat(tofree, "/", len);
		BUF_strlcat(tofree, CONFIG_FILE, len);
@


1.38
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d198 2
a199 2
	static int certify_cert(X509 ** xret, char *infile, EVP_PKEY * pkey, X509 * x509,
     const EVP_MD * dgst, 
d206 1
a206 1
	static int certify_spkac(X509 ** xret, char *infile, EVP_PKEY * pkey, X509 * x509,
d213 2
a214 2
	static void write_new_certificate(BIO * bp, X509 * x, int output_der, int notext);
	static int do_body(X509 ** xret, EVP_PKEY * pkey, X509 * x509, const EVP_MD * dgst,
d221 10
a230 10
	static int do_revoke(X509 * x509, CA_DB * db, int ext, char *extval);
	static int get_certificate_status(const char *ser_status, CA_DB * db);
	static int do_updatedb(CA_DB * db);
	static int check_time_format(const char *str);
	char *make_revocation_str(int rev_type, char *rev_arg);
	int make_revoked(X509_REVOKED * rev, const char *str);
	int old_entry_print(BIO * bp, ASN1_OBJECT * obj, ASN1_STRING * str);
	static CONF *conf = NULL;
	static CONF *extconf = NULL;
	static char *section = NULL;
d232 2
a233 2
	static int preserve = 0;
	static int msie_hack = 0;
d236 1
a236 1
	int ca_main(int, char **);
d238 2
a239 2
	int
	 ca_main(int argc, char **argv)
@


1.37
log
@KaboomNF
@
text
@a91 2
#undef PROG
#define PROG ca_main
d236 1
a236 1
	int MAIN(int, char **);
d239 1
a239 1
	 MAIN(int argc, char **argv)
@


1.36
log
@unistd.h exposed after -Wall after e_os.h stops doing so; spotted by matthew
@
text
@d80 1
a80 1
#    include <sys/file.h>
d86 4
a89 4
#  define F_OK 0
#  define X_OK 1
#  define W_OK 2
#  define R_OK 4
d192 4
a195 3
static int certify(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
    const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
    STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial, char *subj,
d197 1
a197 1
    char *enddate, long days, int batch, char *ext_sect, CONF *conf,
d200 4
a203 3
static int certify_cert(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
    const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
    STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial, char *subj,
d205 1
a205 1
    char *enddate, long days, int batch, char *ext_sect, CONF *conf,
d207 5
a211 4
    int ext_copy, ENGINE *e);
static int certify_spkac(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
    const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
    STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial, char *subj,
d213 1
a213 1
    char *enddate, long days, char *ext_sect, CONF *conf, int verbose,
d215 4
a218 4
static void write_new_certificate(BIO *bp, X509 *x, int output_der, int notext);
static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509, const EVP_MD *dgst,
    STACK_OF(OPENSSL_STRING) *sigopts, STACK_OF(CONF_VALUE) *policy, CA_DB *db,
    BIGNUM *serial, char *subj, unsigned long chtype, int multirdn,
d220 1
a220 1
    int verbose, X509_REQ *req, char *ext_sect, CONF *conf,
d223 10
a232 10
static int do_revoke(X509 *x509, CA_DB *db, int ext, char *extval);
static int get_certificate_status(const char *ser_status, CA_DB *db);
static int do_updatedb(CA_DB *db);
static int check_time_format(const char *str);
char *make_revocation_str(int rev_type, char *rev_arg);
int make_revoked(X509_REVOKED *rev, const char *str);
int old_entry_print(BIO *bp, ASN1_OBJECT *obj, ASN1_STRING *str);
static CONF *conf = NULL;
static CONF *extconf = NULL;
static char *section = NULL;
d234 2
a235 2
static int preserve = 0;
static int msie_hack = 0;
d238 1
a238 1
int MAIN(int, char **);
d240 2
a241 2
int
MAIN(int argc, char **argv)
d308 1
a308 1
	char * const *pp;
d311 3
a313 3
	STACK_OF(CONF_VALUE) *attribs = NULL;
	STACK_OF(X509) *cert_sk = NULL;
	STACK_OF(OPENSSL_STRING) *sigopts = NULL;
d340 1
a340 1
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE|BIO_FP_TEXT);
d350 1
a350 1
			configfile= *(++argv);
d354 1
a354 1
			section= *(++argv);
d358 1
a358 1
			subj= *(++argv);
d369 1
a369 1
			startdate= *(++argv);
d373 1
a373 1
			enddate= *(++argv);
d381 1
a381 1
			md= *(++argv);
d385 1
a385 1
			policy= *(++argv);
d389 2
a390 3
			keyfile= *(++argv);
		}
		else if (strcmp(*argv, "-keyform") == 0) {
d397 1
a397 1
			passargin= *(++argv);
d401 1
a401 1
			key= *(++argv);
d405 1
a405 1
			certfile= *(++argv);
d411 1
a411 1
			infile= *(++argv);
d416 1
a416 1
			outfile= *(++argv);
d420 1
a420 1
			outdir= *(++argv);
d470 1
a470 1
			infile= *(++argv);
d475 1
a475 1
			extensions= *(++argv);
d479 1
a479 1
			extfile= *(++argv);
d483 1
a483 1
			ser_status= *(++argv);
d489 1
a489 1
			crl_ext= *(++argv);
d515 1
a515 1
			engine= *(++argv);
d519 1
a519 1
bad:
a534 1

a553 1

d562 1
a562 1
		, errorline, configfile);
a568 1

a583 1

a607 1

d621 1
a621 2

	if (chtype != MBSTRING_UTF8){
a627 1

a653 1

a672 1

d677 1
a677 1
		    section, ENV_PRIVATE_KEY)) == NULL)) {
a694 1

d700 1
a700 1
		    section, ENV_CERTIFICATE)) == NULL)) {
d765 1
a765 1
		    ENV_NEW_CERTS_DIR)) == NULL) {
d769 12
a780 12
	    /* outdir is a directory spec, but access() for VMS demands a
	       filename.  In any case, stat(), below, will catch the problem
	       if outdir is not a directory spec, and the fopen() or open()
	       will catch an error if there is no write access.

	       Presumably, this problem could also be solved by using the DEC
	       C routines to convert the directory syntax to Unixly, and give
	       that to access().  However, time's too short to do that just
	       now.
	    */
		if (access(outdir, R_OK|W_OK|X_OK) != 0)
		{
a784 1

a790 1

d806 1
a806 1
			BIO_printf(bio_err, "entry %d: not revoked yet, but has a revocation date\n", i+1);
d811 1
a811 1
			BIO_printf(bio_err, " in entry %d\n", i+1);
d814 2
a815 2
		if (!check_time_format((char *)pp[DB_exp_date])) {
			BIO_printf(bio_err, "entry %d: invalid expiry date\n", i+1);
d824 2
a825 2
		if ((j&1) || (j < 2)) {
			BIO_printf(bio_err, "entry %d: bad serial number length (%d)\n", i+1, j);
d829 4
a832 4
			if (!(	((*p >= '0') && (*p <= '9')) ||
			    ((*p >= 'A') && (*p <= 'F')) ||
			    ((*p >= 'a') && (*p <= 'f')))  ) {
				BIO_printf(bio_err, "entry %d: bad serial number characters, char pos %ld, char is '%c'\n", i+1, (long)(p-pp[DB_serial]), *p);
d839 1
a839 1
		BIO_set_fp(out,stdout,BIO_NOCLOSE|BIO_FP_TEXT); /* cannot fail */
a844 1

d860 2
a861 1
			if (verbose) BIO_printf(bio_err,
d870 2
a871 1
			if (verbose) BIO_printf(bio_err,
a874 1

d885 1
a885 1
			    errorline, extfile);
a888 1

a895 1

d904 1
a904 1
			BIO_set_fp(Sout, stdout, BIO_NOCLOSE|BIO_FP_TEXT);
a906 1

d908 1
a908 1
		    section, ENV_DEFAULT_MD)) == NULL)) {
a911 1

d918 1
a918 1
		md = (char *)OBJ_nid2sn(def_nid);
a919 1

a923 1

d926 1
a926 1
			    section, ENV_DEFAULT_EMAIL_DN)) != NULL )) {
d934 1
a934 1
			    section, ENV_POLICY)) == NULL)) {
d942 1
a942 1
			== NULL) {
a945 1

d947 4
a950 2
			/* no '-extfile' option, so we look for extensions
			 * in the main configuration file */
d963 1
a963 1
					    NULL)) {
a971 1

d983 1
a983 1
			startdate="today";
a994 1

a1002 1

a1016 1

a1020 1

d1106 4
a1109 3
		/* we have a stack of newly certified certificates
		 * and a data base and serial number that need
		 * updating */
d1114 1
a1114 1
				(void)BIO_flush(bio_err);
a1126 1

a1134 1

d1144 1
a1144 1
			p = (const char *)x->cert_info->serialNumber->data;
d1146 1
a1146 1
			if (strlen(outdir) >= (size_t)(j ? BSIZE - j*2 - 6 : BSIZE - 8)) {
a1149 1

d1154 1
a1154 1
			n = (char *)&(buf[2][strlen(buf[2])]);
d1161 1
a1161 1
					    "%02X", (unsigned char)*(p++));
a1194 1

a1215 1

d1217 1
a1217 1
			!= NULL)
d1219 3
a1221 4
			BIO_printf(bio_err, "error while loading CRL number\n");
			goto err;
		}

d1224 1
a1224 1
				    ENV_DEFAULT_CRL_DAYS, &crldays))
d1227 1
a1227 1
				    ENV_DEFAULT_CRL_HOURS, &crlhours))
a1234 1

d1247 2
a1248 2
		if (!X509_time_adj_ex(tmptm, crldays, crlhours*60*60 + crlsec,
			    NULL)) {
d1279 3
a1281 2
		/* sort the data so it will be written in serial
		 * number order */
d1297 2
a1298 1
					    crl_ext, crl)) goto err;
d1312 1
a1312 1
				goto err; /* version 2 CRL */
d1314 2
a1315 3


		if (crlnumberfile != NULL)	/* we have a CRL number that need updating */
a1322 1

d1389 1
a1389 1
	return(ret);
d1399 3
a1401 3
certify(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
    const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
    STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial, char *subj,
d1403 1
a1403 1
    char *enddate, long days, int batch, char *ext_sect, CONF *lconf,
d1465 3
a1467 3
certify_cert(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
    const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
    STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial, char *subj,
d1469 1
a1469 1
    char *enddate, long days, int batch, char *ext_sect, CONF *lconf,
d1471 1
a1471 1
    int ext_copy, ENGINE *e)
d1519 3
a1521 3
do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509, const EVP_MD *dgst,
    STACK_OF(OPENSSL_STRING) *sigopts, STACK_OF(CONF_VALUE) *policy,
    CA_DB *db, BIGNUM *serial, char *subj, unsigned long chtype, int multirdn,
d1523 1
a1523 1
    int verbose, X509_REQ *req, char *ext_sect, CONF *lconf,
a1548 1

a1562 1

a1586 1

d1600 1
a1600 1
			    (str->type != V_ASN1_T61STRING)) ||
d1602 1
a1602 1
			    (str->type == V_ASN1_PRINTABLESTRING))) {
a1606 1

a1615 1

d1626 1
a1626 1
		cv=sk_CONF_VALUE_value(policy,i); /* get the object id */
a1663 1

d1666 1
a1666 1
again2:
d1681 1
a1681 1
					BIO_printf(bio_err, "The %s field needed to be the same in the\nCA certificate (%s) and the request (%s)\n", cv->name, ((str2 == NULL)?"NULL":(char *)str2->data), ((str == NULL)?"NULL":(char *)str->data));
a1708 1

d1713 4
a1716 1
	/* and add it later on because of the method extensions are added (altName) */
d1722 2
a1723 1
		/* Its best to dup the subject DN and then delete any email
a1745 1

a1763 1

d1768 1
a1768 1
			p="Expired";
d1770 1
a1770 1
			p="Revoked";
d1772 1
a1772 1
			p="Valid";
d1774 1
a1774 1
			p="\ninvalid type, Data base error\n";
d1777 3
a1779 1
			p = rrow[DB_exp_date]; if (p == NULL) p="undef";
d1782 3
a1784 1
		p = rrow[DB_exp_date]; if (p == NULL) p="undef";
d1786 3
a1788 1
		p = rrow[DB_serial]; if (p == NULL) p="undef";
d1790 3
a1792 1
		p = rrow[DB_file]; if (p == NULL) p="undef";
d1794 3
a1796 1
		p = rrow[DB_name]; if (p == NULL) p="undef";
d1798 1
a1798 1
		ok= -1; /* This is now a 'bad' error. */
a1800 1

d1850 1
a1850 1
		ASN1_INTEGER_set(ci->version,2); /* version 3 certificate */
d1852 4
a1855 2
		/* Free the current entries if any, there should not
		 * be any I believe */
a1896 1

a1900 1

a1907 1

d1909 1
a1909 1
	if (email_dn == 0 ) {
a1912 1

d1915 4
a1918 1
		/* Never print signature details because signature not present */
a1921 1

d1931 1
a1931 1
		(void)BIO_flush(bio_err);
a1943 1

d1954 1
a1954 1
	row[DB_type] = (char *)malloc(2);
d1957 1
a1957 1
	row[DB_exp_date] = (char *)malloc(tm->length + 1);
d1964 1
a1964 1
	row[DB_file] = (char *)malloc(8);
d1976 1
a1976 1
	if ((irow = (char **)malloc(sizeof(char *)*(DB_NUMBER + 1))) == NULL) {
a1979 1

d2015 1
a2015 1
write_new_certificate(BIO *bp, X509 *x, int output_der, int notext)
d2018 1
a2018 1
		(void)i2d_X509_bio(bp, x);
d2039 3
a2041 3
certify_spkac(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
    const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
    STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial, char *subj,
d2043 1
a2043 1
    char *enddate, long days, char *ext_sect, CONF *lconf, int verbose,
d2046 2
a2047 2
	STACK_OF(CONF_VALUE) *sk = NULL;
	LHASH_OF(CONF_VALUE) *parms = NULL;
a2070 1

a2076 1

a2088 1

d2095 1
a2095 1
	for (i = 0; ; i++) {
d2101 3
a2103 2
		/* Skip past any leading X. X: X, etc to allow for
		 * multiple instances
a2125 1

d2127 1
a2127 1
			    (unsigned char *)buf, -1, -1, 0))
a2134 1

a2144 1

d2177 1
a2177 1
do_revoke(X509 *x509, CA_DB *db, int type, char *value)
d2200 4
a2203 3
	/* We have to lookup by serial number because name lookup
	 * skips revoked certs
 	 */
d2209 1
a2209 1
		row[DB_type] = (char *)malloc(2);
d2212 1
a2212 1
		row[DB_exp_date] = (char *)malloc(tm->length + 1);
d2219 1
a2219 1
		row[DB_file] = (char *)malloc(8);
d2232 1
a2232 1
		if ((irow = (char **)malloc(sizeof(char *)*(DB_NUMBER + 1))) == NULL) {
a2235 1

a2246 1

d2256 1
a2256 1
	} else if (rrow[DB_type][0]=='R') {
d2281 1
a2281 1
get_certificate_status(const char *serial, CA_DB *db)
a2295 1

d2297 2
a2298 2
		/* Set the first char to 0 */;
		row[DB_serial][0]='0';
d2301 1
a2301 1
		memcpy(row[DB_serial]+1, serial, strlen(serial));
d2311 1
a2311 1
		row[DB_serial][i] = toupper((unsigned char)row[DB_serial][i]);
d2323 1
a2323 1
	} else if (rrow[DB_type][0]=='V') {
d2327 1
a2327 1
	} else if (rrow[DB_type][0]=='R') {
d2331 1
a2331 1
	} else if (rrow[DB_type][0]=='E') {
d2335 1
a2335 1
	} else if (rrow[DB_type][0]=='S') {
d2352 2
a2353 1
static int do_updatedb (CA_DB *db)
d2355 1
a2355 1
	ASN1_UTCTIME	*a_tm = NULL;
d2357 1
a2357 1
	int db_y2k, a_y2k;  /* flags = 1 if y >= 2000 */
a2368 1

a2404 1

a2475 1

d2502 6
a2507 4
	if (reason) i += strlen(reason)
		+ 1;
	if (other) i += strlen(other)
		+ 1;
d2514 1
a2514 1
	BUF_strlcpy(str, (char *)revtm->data, i);
d2535 1
a2535 1
make_revoked(X509_REVOKED *rev, const char *str)
a2560 1

a2568 1

d2587 1
a2587 1
old_entry_print(BIO *bp, ASN1_OBJECT *obj, ASN1_STRING *str)
d2610 1
a2610 1
	p = (char *)str->data;
d2616 1
a2616 1
		else if ((unsigned char)*p == 0xf7)
d2619 1
a2619 1
			BIO_printf(bp, "^%c", *p+'@@');
d2627 2
a2628 2
unpack_revinfo(ASN1_TIME **prevtm, int *preason, ASN1_OBJECT **phold,
    ASN1_GENERALIZEDTIME **pinvtm, const char *str)
a2652 1

a2670 1

d2673 1
a2673 2
		else if (reason_code == 8)		/* Hold instruction */
		{
a2702 1

@


1.35
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d65 1
@


1.34
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d1414 1
a1414 1
	OPENSSL_EXIT(ret);
@


1.33
log
@Revert unintended whitespace changes.
@
text
@d546 1
a546 1
		tofree = OPENSSL_malloc(len);
d565 1
a565 1
		OPENSSL_free(tofree);
d1031 1
a1031 1
				OPENSSL_free(f);
d1387 1
a1387 1
		OPENSSL_free(tofree);
d1400 1
a1400 1
		OPENSSL_free(key);
d1976 1
a1976 1
	row[DB_type] = (char *)OPENSSL_malloc(2);
d1979 1
a1979 1
	row[DB_exp_date] = (char *)OPENSSL_malloc(tm->length + 1);
d1986 1
a1986 1
	row[DB_file] = (char *)OPENSSL_malloc(8);
d1998 1
a1998 1
	if ((irow = (char **)OPENSSL_malloc(sizeof(char *)*(DB_NUMBER + 1))) == NULL) {
d2018 1
a2018 1
			OPENSSL_free(row[i]);
d2236 1
a2236 1
		row[DB_type] = (char *)OPENSSL_malloc(2);
d2239 1
a2239 1
		row[DB_exp_date] = (char *)OPENSSL_malloc(tm->length + 1);
d2246 1
a2246 1
		row[DB_file] = (char *)OPENSSL_malloc(8);
d2259 1
a2259 1
		if ((irow = (char **)OPENSSL_malloc(sizeof(char *)*(DB_NUMBER + 1))) == NULL) {
d2304 1
a2304 1
			OPENSSL_free(row[i]);
d2320 1
a2320 1
	row[DB_serial] = OPENSSL_malloc(strlen(serial) + 2);
d2377 1
a2377 1
			OPENSSL_free(row[i]);
d2393 1
a2393 1
	a_tm_s = (char *) OPENSSL_malloc(a_tm->length + 1);
d2441 1
a2441 1
	OPENSSL_free(a_tm_s);
d2539 1
a2539 1
	str = OPENSSL_malloc(i);
d2609 1
a2609 1
		OPENSSL_free(tmp);
d2750 1
a2750 1
		OPENSSL_free(tmp);
@


1.32
log
@Fix for ", " issue in jsing's knf script
@
text
@d2354 1
a2354 1
		BIO_printf(bio_err, "%s = Valid (%c)\n",
d2358 1
a2358 1
		BIO_printf(bio_err, "%s = Revoked (%c)\n",
d2362 1
a2362 1
		BIO_printf(bio_err, "%s = Expired (%c)\n",
d2366 1
a2366 1
		BIO_printf(bio_err, "%s = Suspended (%c)\n",
d2370 1
a2370 1
		BIO_printf(bio_err, "%s = Unknown (%c).\n",
d2424 1
a2424 1
					BIO_printf(bio_err, "%s = Expired\n",
d2432 1
a2432 1
				BIO_printf(bio_err, "%s = Expired\n",
@


1.31
log
@minimal fix for ', ' issue in jsing's indent script
@
text
@d2546 1
a2546 1
		BUF_strlcat(str, ", ", i);
d2550 1
a2550 1
		BUF_strlcat(str, ", ", i);
@


1.30
log
@lots of ifdef cleanup
@
text
@d2130 7
a2136 6
		for (buf = cv->name; *buf; buf++)
			if ((*buf == ':') || (*buf == ', ') || (*buf == '.')) {
			buf++;
			if (*buf)
				type = buf;
			break;
d2671 1
a2671 1
	p = strchr(tmp, ', ');
d2679 1
a2679 1
		p = strchr(p, ', ');
@


1.29
log
@Initial KNF.
@
text
@a785 1
#ifndef _WIN32
a786 3
#else
		if (_access(outdir, R_OK|W_OK|X_OK) != 0)
#endif
@


1.28
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d140 36
a175 36
static const char *ca_usage[]={
"usage: ca args\n",
"\n",
" -verbose        - Talk alot while doing things\n",
" -config file    - A config file\n",
" -name arg       - The particular CA definition to use\n",
" -gencrl         - Generate a new CRL\n",
" -crldays days   - Days is when the next CRL is due\n",
" -crlhours hours - Hours is when the next CRL is due\n",
" -startdate YYMMDDHHMMSSZ  - certificate validity notBefore\n",
" -enddate YYMMDDHHMMSSZ    - certificate validity notAfter (overrides -days)\n",
" -days arg       - number of days to certify the certificate for\n",
" -md arg         - md to use, one of md2, md5, sha or sha1\n",
" -policy arg     - The CA 'policy' to support\n",
" -keyfile arg    - private key file\n",
" -keyform arg    - private key file format (PEM or ENGINE)\n",
" -key arg        - key to decode the private key if it is encrypted\n",
" -cert file      - The CA certificate\n",
" -selfsign       - sign a certificate with the key associated with it\n",
" -in file        - The input PEM encoded certificate request(s)\n",
" -out file       - Where to put the output file(s)\n",
" -outdir dir     - Where to put output certificates\n",
" -infiles ....   - The last argument, requests to process\n",
" -spkac file     - File contains DN and signed public key and challenge\n",
" -ss_cert file   - File contains a self signed cert to sign\n",
" -preserveDN     - Don't re-order the DN\n",
" -noemailDN      - Don't add the EMAIL field into certificate' subject\n",
" -batch          - Don't ask questions\n",
" -msie_hack      - msie modifications to handle all those universal strings\n",
" -revoke file    - Revoke a certificate (given in file)\n",
" -subj arg       - Use arg instead of request's subject\n",
" -utf8           - input characters are UTF8 (default ASCII)\n",
" -multivalue-rdn - enable support for multivalued RDNs\n",
" -extensions ..  - Extension section (override value in config file)\n",
" -extfile file   - Configuration file with X509v3 extentions to add\n",
" -crlexts ..     - CRL extension section (override value in config file)\n",
d177 1
a177 1
" -engine e       - use engine e, possibly a hardware device.\n",
d179 3
a181 3
" -status serial  - Shows certificate status given the serial number\n",
" -updatedb       - Updates db for expired certificates\n",
NULL
d191 20
a210 22
static int certify(X509 **xret, char *infile,EVP_PKEY *pkey,X509 *x509,
		   const EVP_MD *dgst,STACK_OF(OPENSSL_STRING) *sigopts,
		   STACK_OF(CONF_VALUE) *policy,CA_DB *db,
		   BIGNUM *serial, char *subj,unsigned long chtype, int multirdn, int email_dn, char *startdate,
		   char *enddate, long days, int batch, char *ext_sect, CONF *conf,
		   int verbose, unsigned long certopt, unsigned long nameopt,
		   int default_op, int ext_copy, int selfsign);
static int certify_cert(X509 **xret, char *infile,EVP_PKEY *pkey,X509 *x509,
			const EVP_MD *dgst,STACK_OF(OPENSSL_STRING) *sigopts,
			STACK_OF(CONF_VALUE) *policy,
			CA_DB *db, BIGNUM *serial, char *subj,unsigned long chtype, int multirdn, int email_dn,
			char *startdate, char *enddate, long days, int batch,
			char *ext_sect, CONF *conf,int verbose, unsigned long certopt,
			unsigned long nameopt, int default_op, int ext_copy,
			ENGINE *e);
static int certify_spkac(X509 **xret, char *infile,EVP_PKEY *pkey,X509 *x509,
			 const EVP_MD *dgst,STACK_OF(OPENSSL_STRING) *sigopts,
			 STACK_OF(CONF_VALUE) *policy,
			 CA_DB *db, BIGNUM *serial,char *subj,unsigned long chtype, int multirdn, int email_dn,
			 char *startdate, char *enddate, long days, char *ext_sect,
			 CONF *conf, int verbose, unsigned long certopt, 
			 unsigned long nameopt, int default_op, int ext_copy);
d213 6
a218 6
	STACK_OF(OPENSSL_STRING) *sigopts,
	STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial,char *subj,unsigned long chtype, int multirdn,
	int email_dn, char *startdate, char *enddate, long days, int batch,
       	int verbose, X509_REQ *req, char *ext_sect, CONF *conf,
	unsigned long certopt, unsigned long nameopt, int default_op,
	int ext_copy, int selfsign);
d226 3
a228 3
static CONF *conf=NULL;
static CONF *extconf=NULL;
static char *section=NULL;
d230 2
a231 2
static int preserve=0;
static int msie_hack=0;
d236 3
a238 2
int MAIN(int argc, char **argv)
	{
d240 1
a240 1
	char *key=NULL,*passargin=NULL;
d243 25
a267 25
	int total=0;
	int total_done=0;
	int badops=0;
	int ret=1;
	int email_dn=1;
	int req=0;
	int verbose=0;
	int gencrl=0;
	int dorevoke=0;
	int doupdatedb=0;
	long crldays=0;
	long crlhours=0;
	long crlsec=0;
	long errorline= -1;
	char *configfile=NULL;
	char *md=NULL;
	char *policy=NULL;
	char *keyfile=NULL;
	char *certfile=NULL;
	int keyform=FORMAT_PEM;
	char *infile=NULL;
	char *spkac_file=NULL;
	char *ss_cert_file=NULL;
	char *ser_status=NULL;
	EVP_PKEY *pkey=NULL;
d269 7
a275 7
	char *outfile=NULL;
	char *outdir=NULL;
	char *serialfile=NULL;
	char *crlnumberfile=NULL;
	char *extensions=NULL;
	char *extfile=NULL;
	char *subj=NULL;
d278 2
a279 2
	char *tmp_email_dn=NULL;
	char *crl_ext=NULL;
d282 7
a288 7
	BIGNUM *serial=NULL;
	BIGNUM *crlnumber=NULL;
	char *startdate=NULL;
	char *enddate=NULL;
	long days=0;
	int batch=0;
	int notext=0;
d293 7
a299 7
	X509 *x509=NULL, *x509p = NULL;
	X509 *x=NULL;
	BIO *in=NULL,*out=NULL,*Sout=NULL,*Cout=NULL;
	char *dbfile=NULL;
	CA_DB *db=NULL;
	X509_CRL *crl=NULL;
	X509_REVOKED *r=NULL;
d305 4
a308 4
	int i,j;
	const EVP_MD *dgst=NULL;
	STACK_OF(CONF_VALUE) *attribs=NULL;
	STACK_OF(X509) *cert_sk=NULL;
d313 1
a313 1
	char *randfile=NULL;
d317 1
a317 1
	char *tofree=NULL;
d321 3
a323 3
EF_PROTECT_FREE=1;
EF_PROTECT_BELOW=1;
EF_ALIGNMENT=0;
d332 2
a333 2
	preserve=0;
	msie_hack=0;
d335 2
a336 2
		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);
d340 6
a345 7
	while (argc >= 1)
		{
		if	(strcmp(*argv,"-verbose") == 0)
			verbose=1;
		else if	(strcmp(*argv,"-config") == 0)
			{
			if (--argc < 1) goto bad;
d347 3
a349 4
			}
		else if (strcmp(*argv,"-name") == 0)
			{
			if (--argc < 1) goto bad;
d351 3
a353 4
			}
		else if (strcmp(*argv,"-subj") == 0)
			{
			if (--argc < 1) goto bad;
d356 1
a356 2
			}
		else if (strcmp(*argv,"-utf8") == 0)
d358 1
a358 1
		else if (strcmp(*argv,"-create_serial") == 0)
d360 5
a364 5
		else if (strcmp(*argv,"-multivalue-rdn") == 0)
			multirdn=1;
		else if (strcmp(*argv,"-startdate") == 0)
			{
			if (--argc < 1) goto bad;
d366 3
a368 4
			}
		else if (strcmp(*argv,"-enddate") == 0)
			{
			if (--argc < 1) goto bad;
d370 7
a376 9
			}
		else if (strcmp(*argv,"-days") == 0)
			{
			if (--argc < 1) goto bad;
			days=atoi(*(++argv));
			}
		else if (strcmp(*argv,"-md") == 0)
			{
			if (--argc < 1) goto bad;
d378 3
a380 4
			}
		else if (strcmp(*argv,"-policy") == 0)
			{
			if (--argc < 1) goto bad;
d382 3
a384 4
			}
		else if (strcmp(*argv,"-keyfile") == 0)
			{
			if (--argc < 1) goto bad;
d386 8
a393 9
			}
		else if (strcmp(*argv,"-keyform") == 0)
			{
			if (--argc < 1) goto bad;
			keyform=str2fmt(*(++argv));
			}
		else if (strcmp(*argv,"-passin") == 0)
			{
			if (--argc < 1) goto bad;
d395 3
a397 4
			}
		else if (strcmp(*argv,"-key") == 0)
			{
			if (--argc < 1) goto bad;
d399 3
a401 4
			}
		else if (strcmp(*argv,"-cert") == 0)
			{
			if (--argc < 1) goto bad;
d403 5
a407 6
			}
		else if (strcmp(*argv,"-selfsign") == 0)
			selfsign=1;
		else if (strcmp(*argv,"-in") == 0)
			{
			if (--argc < 1) goto bad;
d409 4
a412 5
			req=1;
			}
		else if (strcmp(*argv,"-out") == 0)
			{
			if (--argc < 1) goto bad;
d414 3
a416 4
			}
		else if (strcmp(*argv,"-outdir") == 0)
			{
			if (--argc < 1) goto bad;
d418 1
a418 3
			}
		else if (strcmp(*argv,"-sigopt") == 0)
			{
d425 23
a447 26
			}
		else if (strcmp(*argv,"-notext") == 0)
			notext=1;
		else if (strcmp(*argv,"-batch") == 0)
			batch=1;
		else if (strcmp(*argv,"-preserveDN") == 0)
			preserve=1;
		else if (strcmp(*argv,"-noemailDN") == 0)
			email_dn=0;
		else if (strcmp(*argv,"-gencrl") == 0)
			gencrl=1;
		else if (strcmp(*argv,"-msie_hack") == 0)
			msie_hack=1;
		else if (strcmp(*argv,"-crldays") == 0)
			{
			if (--argc < 1) goto bad;
			crldays= atol(*(++argv));
			}
		else if (strcmp(*argv,"-crlhours") == 0)
			{
			if (--argc < 1) goto bad;
			crlhours= atol(*(++argv));
			}
		else if (strcmp(*argv,"-crlsec") == 0)
			{
			if (--argc < 1) goto bad;
d449 1
a449 3
			}
		else if (strcmp(*argv,"-infiles") == 0)
			{
d452 1
a452 1
			req=1;
d454 3
a456 4
			}
		else if (strcmp(*argv, "-ss_cert") == 0)
			{
			if (--argc < 1) goto bad;
d458 4
a461 5
			req=1;
			}
		else if (strcmp(*argv, "-spkac") == 0)
			{
			if (--argc < 1) goto bad;
d463 4
a466 5
			req=1;
			}
		else if (strcmp(*argv,"-revoke") == 0)
			{
			if (--argc < 1) goto bad;
d468 4
a471 5
			dorevoke=1;
			}
		else if (strcmp(*argv,"-extensions") == 0)
			{
			if (--argc < 1) goto bad;
d473 3
a475 4
			}
		else if (strcmp(*argv,"-extfile") == 0)
			{
			if (--argc < 1) goto bad;
d477 3
a479 4
			}
		else if (strcmp(*argv,"-status") == 0)
			{
			if (--argc < 1) goto bad;
d481 5
a485 8
			}
		else if (strcmp(*argv,"-updatedb") == 0)
			{
			doupdatedb=1;
			}
		else if (strcmp(*argv,"-crlexts") == 0)
			{
			if (--argc < 1) goto bad;
d487 3
a489 4
			}
		else if (strcmp(*argv,"-crl_reason") == 0)
			{
			if (--argc < 1) goto bad;
d492 3
a494 4
			}
		else if (strcmp(*argv,"-crl_hold") == 0)
			{
			if (--argc < 1) goto bad;
d497 3
a499 4
			}
		else if (strcmp(*argv,"-crl_compromise") == 0)
			{
			if (--argc < 1) goto bad;
d502 3
a504 4
			}
		else if (strcmp(*argv,"-crl_CA_compromise") == 0)
			{
			if (--argc < 1) goto bad;
d507 1
a507 1
			}
d509 3
a511 3
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
d513 1
a513 1
			}
d515 1
a515 2
		else
			{
d517 2
a518 2
			BIO_printf(bio_err,"unknown option %s\n",*argv);
			badops=1;
d520 1
a520 1
			}
d523 1
a523 1
		}
d525 1
a525 2
	if (badops)
		{
d528 2
a529 2
		for (pp2=ca_usage; (*pp2 != NULL); pp2++)
			BIO_printf(bio_err,"%s",*pp2);
d531 1
a531 1
		}
d536 1
a536 3
	tofree=NULL;
	if (configfile == NULL) configfile = getenv("OPENSSL_CONF");
	if (configfile == NULL) configfile = getenv("SSLEAY_CONF");
d538 5
a542 2
		{
		const char *s=X509_get_default_cert_area();
d545 7
a551 7
		len = strlen(s)+sizeof(CONFIG_FILE)+1;
		tofree=OPENSSL_malloc(len);
		BUF_strlcpy(tofree,s,len);
		BUF_strlcat(tofree,"/",len);
		BUF_strlcat(tofree,CONFIG_FILE,len);
		configfile=tofree;
		}
d553 1
a553 1
	BIO_printf(bio_err,"Using configuration from %s\n",configfile);
d555 1
a555 2
	if (NCONF_load(conf,configfile,&errorline) <= 0)
		{
d557 2
a558 2
			BIO_printf(bio_err,"error loading the config file '%s'\n",
				configfile);
d560 2
a561 2
			BIO_printf(bio_err,"error on line %ld of config file '%s'\n"
				,errorline,configfile);
d563 2
a564 3
		}
	if(tofree)
		{
d567 1
a567 1
		}
d577 4
a580 6
	if (section == NULL)
		{
		section=NCONF_get_string(conf,BASE_SECTION,ENV_DEFAULT_CA);
		if (section == NULL)
			{
			lookup_fail(BASE_SECTION,ENV_DEFAULT_CA);
a581 1
			}
d583 1
d585 2
a586 3
	if (conf != NULL)
		{
		p=NCONF_get_string(conf,NULL,"oid_file");
d589 1
a589 2
		if (p != NULL)
			{
d592 2
a593 3
			oid_bio=BIO_new_file(p,"r");
			if (oid_bio == NULL) 
				{
d599 1
a599 3
				}
			else
				{
a601 1
				}
d603 2
a604 2
		if (!add_oid_section(bio_err,conf)) 
			{
a606 1
			}
d608 1
d619 1
a619 1
	if(f && !ASN1_STRING_set_default_mask_asc(f)) {
d634 1
a634 2
	if (p)
		{
d638 2
a639 3
		db_attr.unique_subject = parse_yesno(p,1);
		}
	else
d647 1
a647 1
		db_attr.unique_subject);
d649 6
a654 7
	
	in=BIO_new(BIO_s_file());
	out=BIO_new(BIO_s_file());
	Sout=BIO_new(BIO_s_file());
	Cout=BIO_new(BIO_s_file());
	if ((in == NULL) || (out == NULL) || (Sout == NULL) || (Cout == NULL))
		{
d657 1
a657 1
		}
d661 7
a667 5
	if (ser_status)
	{
		if ((dbfile=NCONF_get_string(conf,section,ENV_DATABASE)) == NULL)
			{
			lookup_fail(section,ENV_DATABASE);
a668 3
			}
		db = load_index(dbfile,&db_attr);
		if (db == NULL) goto err;
d670 2
a671 1
		if (!index_index(db)) goto err;
d673 3
a675 3
		if (get_certificate_status(ser_status,db) != 1)
			BIO_printf(bio_err,"Error verifying serial %s!\n",
				 ser_status);
d682 3
a684 4
	if ((keyfile == NULL) && ((keyfile=NCONF_get_string(conf,
		section,ENV_PRIVATE_KEY)) == NULL))
		{
		lookup_fail(section,ENV_PRIVATE_KEY);
d686 2
a687 3
		}
	if (!key)
		{
d689 2
a690 3
		if (!app_passwd(bio_err, passargin, NULL, &key, NULL))
			{
			BIO_printf(bio_err,"Error getting password\n");
a691 1
			}
d693 5
a697 5
	pkey = load_key(bio_err, keyfile, keyform, 0, key, e, 
		"CA private key");
	if (key) OPENSSL_cleanse(key,strlen(key));
	if (pkey == NULL)
		{
d700 1
a700 1
		}
d704 5
a708 7
	if (!selfsign || spkac_file || ss_cert_file || gencrl)
		{
		if ((certfile == NULL)
			&& ((certfile=NCONF_get_string(conf,
				     section,ENV_CERTIFICATE)) == NULL))
			{
			lookup_fail(section,ENV_CERTIFICATE);
d710 3
a712 3
			}
		x509=load_cert(bio_err, certfile, FORMAT_PEM, NULL, e,
			"CA certificate");
d716 2
a717 3
		if (!X509_check_private_key(x509,pkey))
			{
			BIO_printf(bio_err,"CA certificate and CA private key do not match\n");
a718 1
			}
d720 3
a722 1
	if (!selfsign) x509p = x509;
d724 1
a724 1
	f=NCONF_get_string(conf,BASE_SECTION,ENV_PRESERVE);
d728 2
a729 2
		preserve=1;
	f=NCONF_get_string(conf,BASE_SECTION,ENV_MSIE_HACK);
d733 1
a733 1
		msie_hack=1;
d735 1
a735 1
	f=NCONF_get_string(conf,section,ENV_NAMEOPT);
d737 2
a738 4
	if (f)
		{
		if (!set_name_ex(&nameopt, f))
			{
d741 1
a741 1
			}
d743 1
a743 2
		}
	else
d746 1
a746 1
	f=NCONF_get_string(conf,section,ENV_CERTOPT);
d748 2
a749 4
	if (f)
		{
		if (!set_cert_ex(&certopt, f))
			{
d752 1
a752 1
			}
d754 1
a754 2
		}
	else
d757 1
a757 1
	f=NCONF_get_string(conf,section,ENV_EXTCOPY);
d759 2
a760 4
	if (f)
		{
		if (!set_ext_copy(&ext_copy, f))
			{
a762 1
			}
d764 1
a764 1
	else
d769 1
a769 2
	if ((outdir == NULL) && (req))
		{
d771 3
a773 4
		if ((outdir=NCONF_get_string(conf,section,ENV_NEW_CERTS_DIR))
			== NULL)
			{
			BIO_printf(bio_err,"there needs to be defined a directory for new certificate to be placed in\n");
d775 1
a775 1
			}
d787 1
a787 1
		if (access(outdir,R_OK|W_OK|X_OK) != 0)
d789 1
a789 1
		if (_access(outdir,R_OK|W_OK|X_OK) != 0)
d791 2
a792 2
			{
			BIO_printf(bio_err,"I am unable to access the %s directory\n",outdir);
d795 1
a795 1
			}
d797 2
a798 3
		if (app_isdir(outdir)<=0)
			{
			BIO_printf(bio_err,"%s need to be a directory\n",outdir);
a800 1
			}
d802 1
d806 2
a807 3
	if ((dbfile=NCONF_get_string(conf,section,ENV_DATABASE)) == NULL)
		{
		lookup_fail(section,ENV_DATABASE);
d809 1
a809 1
		}
d811 2
a812 1
	if (db == NULL) goto err;
d815 2
a816 3
	for (i=0; i<sk_OPENSSL_PSTRING_num(db->db->data); i++)
		{
		pp=sk_OPENSSL_PSTRING_value(db->db->data,i);
d818 2
a819 3
			(pp[DB_rev_date][0] != '\0'))
			{
			BIO_printf(bio_err,"entry %d: not revoked yet, but has a revocation date\n",i+1);
d821 1
a821 1
			}
d823 2
a824 3
			!make_revoked(NULL, pp[DB_rev_date]))
			{
			BIO_printf(bio_err," in entry %d\n", i+1);
d826 3
a828 4
			}
		if (!check_time_format((char *)pp[DB_exp_date]))
			{
			BIO_printf(bio_err,"entry %d: invalid expiry date\n",i+1);
d830 4
a833 5
			}
		p=pp[DB_serial];
		j=strlen(p);
		if (*p == '-')
			{
d836 3
a838 4
			}
		if ((j&1) || (j < 2))
			{
			BIO_printf(bio_err,"entry %d: bad serial number length (%d)\n",i+1,j);
d840 2
a841 3
			}
		while (*p)
			{
d843 3
a845 4
				((*p >= 'A') && (*p <= 'F')) ||
				((*p >= 'a') && (*p <= 'f')))  )
				{
				BIO_printf(bio_err,"entry %d: bad serial number characters, char pos %ld, char is '%c'\n",i+1,(long)(p-pp[DB_serial]),*p);
d847 1
a847 1
				}
a848 1
			}
d850 2
a851 2
	if (verbose)
		{
d853 8
a860 7
		TXT_DB_write(out,db->db);
		BIO_printf(bio_err,"%d entries loaded from the database\n",
			   sk_OPENSSL_PSTRING_num(db->db->data));
		BIO_printf(bio_err,"generating index\n");
		}
	
	if (!index_index(db)) goto err;
d864 1
a864 2
	if (doupdatedb)
		{
d867 1
a867 1
							dbfile);
d870 2
a871 3
		if (i == -1)
			{
			BIO_printf(bio_err,"Malloc failure\n");
d873 1
a873 3
			}
		else if (i == 0)
			{
d875 8
a882 8
					"No entries found to mark expired\n"); 
			}
	    	else
			{
			if (!save_index(dbfile,"new",db)) goto err;
				
			if (!rotate_index(dbfile,"new","old")) goto err;
				
d884 3
a886 3
				"Done. %d entries marked as expired\n",i); 
	      		}
	  	}
d888 1
a888 1
 	/*****************************************************************/
d890 1
a890 2
	if (extfile)
		{
d892 1
a892 2
		if (NCONF_load(extconf,extfile,&errorline) <= 0)
			{
d895 1
a895 1
					extfile);
d898 1
a898 1
					errorline,extfile);
d901 1
a901 1
			}
d909 1
a909 1
		}
d912 3
a914 6
	if (req || gencrl)
		{
		if (outfile != NULL)
			{
			if (BIO_write_filename(Sout,outfile) <= 0)
				{
a916 5
				}
			}
		else
			{
			BIO_set_fp(Sout,stdout,BIO_NOCLOSE|BIO_FP_TEXT);
d918 2
d921 1
d923 3
a925 4
	if ((md == NULL) && ((md=NCONF_get_string(conf,
		section,ENV_DEFAULT_MD)) == NULL))
		{
		lookup_fail(section,ENV_DEFAULT_MD);
d927 1
a927 1
		}
d929 1
a929 2
	if (!strcmp(md, "default"))
		{
d931 2
a932 3
		if (EVP_PKEY_get_default_digest_nid(pkey, &def_nid) <= 0)
			{
			BIO_puts(bio_err,"no default digest\n");
d934 1
a934 1
			}
d936 1
a936 1
		}
d938 2
a939 3
	if ((dgst=EVP_get_digestbyname(md)) == NULL)
		{
		BIO_printf(bio_err,"%s is an unsupported message digest type\n",md);
d941 7
a948 9

	if (req)
		{
		if ((email_dn == 1) && ((tmp_email_dn=NCONF_get_string(conf,
			section,ENV_DEFAULT_EMAIL_DN)) != NULL ))
			{
			if(strcmp(tmp_email_dn,"no") == 0)
				email_dn=0;
			}
d950 5
a954 6
			BIO_printf(bio_err,"message digest is %s\n",
				OBJ_nid2ln(dgst->type));
		if ((policy == NULL) && ((policy=NCONF_get_string(conf,
			section,ENV_POLICY)) == NULL))
			{
			lookup_fail(section,ENV_POLICY);
d956 1
a956 1
			}
d958 1
a958 1
			BIO_printf(bio_err,"policy is %s\n",policy);
d960 3
a962 4
		if ((serialfile=NCONF_get_string(conf,section,ENV_SERIAL))
			== NULL)
			{
			lookup_fail(section,ENV_SERIAL);
d964 1
a964 1
			}
d966 1
a966 2
		if (!extconf)
			{
d969 3
a971 4
			if (!extensions)
				{
				extensions=NCONF_get_string(conf,section,
								ENV_EXTENSIONS);
d974 2
a975 3
				}
			if (extensions)
				{
d981 1
a981 2
								NULL))
					{
d983 2
a984 2
				 	"Error Loading extension section %s\n",
								 extensions);
a986 1
					}
d989 1
d991 3
a993 4
		if (startdate == NULL)
			{
			startdate=NCONF_get_string(conf,section,
				ENV_DEFAULT_STARTDATE);
d996 3
a998 4
			}
		if (startdate && !ASN1_TIME_set_string(NULL, startdate))
			{
			BIO_printf(bio_err,"start date is invalid, it should be YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ\n");
d1000 3
a1002 2
			}
		if (startdate == NULL) startdate="today";
d1004 3
a1006 4
		if (enddate == NULL)
			{
			enddate=NCONF_get_string(conf,section,
				ENV_DEFAULT_ENDDATE);
d1009 3
a1011 4
			}
		if (enddate && !ASN1_TIME_set_string(NULL, enddate))
			{
			BIO_printf(bio_err,"end date is invalid, it should be YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ\n");
d1013 1
a1013 1
			}
d1015 2
a1016 3
		if (days == 0)
			{
			if(!NCONF_get_number(conf,section, ENV_DEFAULT_DAYS, &days))
d1018 3
a1020 4
			}
		if (!enddate && (days == 0))
			{
			BIO_printf(bio_err,"cannot lookup how many days to certify for\n");
d1022 1
a1022 1
			}
d1024 2
a1025 3
		if ((serial=load_serial(serialfile, create_ser, NULL)) == NULL)
			{
			BIO_printf(bio_err,"error while loading serial number\n");
d1027 2
a1028 3
			}
		if (verbose)
			{
d1030 5
a1034 5
				BIO_printf(bio_err,"next serial number is 00\n");
			else
				{
				if ((f=BN_bn2hex(serial)) == NULL) goto err;
				BIO_printf(bio_err,"next serial number is %s\n",f);
a1035 1
				}
d1037 1
d1039 2
a1040 3
		if ((attribs=NCONF_get_section(conf,policy)) == NULL)
			{
			BIO_printf(bio_err,"unable to find 'section' for %s\n",policy);
d1042 1
a1042 1
			}
d1044 2
a1045 3
		if ((cert_sk=sk_X509_new_null()) == NULL)
			{
			BIO_printf(bio_err,"Memory allocation failure\n");
d1047 2
a1048 3
			}
		if (spkac_file != NULL)
			{
d1050 7
a1056 7
			j=certify_spkac(&x,spkac_file,pkey,x509,dgst,sigopts,
				attribs,db, serial,subj,chtype,multirdn,
				email_dn,startdate,enddate,days,extensions,
				conf,verbose,certopt,nameopt,default_op,ext_copy);
			if (j < 0) goto err;
			if (j > 0)
				{
d1058 8
a1065 9
				BIO_printf(bio_err,"\n");
				if (!BN_add_word(serial,1)) goto err;
				if (!sk_X509_push(cert_sk,x))
					{
					BIO_printf(bio_err,"Memory allocation failure\n");
					goto err;
					}
				if (outfile)
					{
a1067 1
					}
d1070 2
a1071 2
		if (ss_cert_file != NULL)
			{
d1073 8
a1080 8
			j=certify_cert(&x,ss_cert_file,pkey,x509,dgst,sigopts,
				attribs,
				db,serial,subj,chtype,multirdn,email_dn,startdate,enddate,days,batch,
				extensions,conf,verbose, certopt, nameopt,
				default_op, ext_copy, e);
			if (j < 0) goto err;
			if (j > 0)
				{
d1082 5
a1086 5
				BIO_printf(bio_err,"\n");
				if (!BN_add_word(serial,1)) goto err;
				if (!sk_X509_push(cert_sk,x))
					{
					BIO_printf(bio_err,"Memory allocation failure\n");
a1087 1
					}
d1090 2
a1091 2
		if (infile != NULL)
			{
d1093 7
a1099 7
			j=certify(&x,infile,pkey,x509p,dgst,sigopts, attribs,db,
				serial,subj,chtype,multirdn,email_dn,startdate,enddate,days,batch,
				extensions,conf,verbose, certopt, nameopt,
				default_op, ext_copy, selfsign);
			if (j < 0) goto err;
			if (j > 0)
				{
d1101 5
a1105 5
				BIO_printf(bio_err,"\n");
				if (!BN_add_word(serial,1)) goto err;
				if (!sk_X509_push(cert_sk,x))
					{
					BIO_printf(bio_err,"Memory allocation failure\n");
a1106 1
					}
d1109 2
a1110 2
		for (i=0; i<argc; i++)
			{
d1112 7
a1118 7
			j=certify(&x,argv[i],pkey,x509p,dgst,sigopts,attribs,db,
				serial,subj,chtype,multirdn,email_dn,startdate,enddate,days,batch,
				extensions,conf,verbose, certopt, nameopt,
				default_op, ext_copy, selfsign);
			if (j < 0) goto err;
			if (j > 0)
				{
d1120 5
a1124 5
				BIO_printf(bio_err,"\n");
				if (!BN_add_word(serial,1)) goto err;
				if (!sk_X509_push(cert_sk,x))
					{
					BIO_printf(bio_err,"Memory allocation failure\n");
a1125 1
					}
d1127 2
a1128 1
			}	
d1133 3
a1135 5
		if (sk_X509_num(cert_sk) > 0)
			{
			if (!batch)
				{
				BIO_printf(bio_err,"\n%d out of %d certificate requests certified, commit? [y/n]",total_done,total);
d1137 4
a1140 11
				buf[0][0]='\0';
				if (!fgets(buf[0],10,stdin))
					{
					BIO_printf(bio_err,"CERTIFICATION CANCELED: I/O error\n"); 
					ret=0;
					goto err;
					}
				if ((buf[0][0] != 'y') && (buf[0][0] != 'Y'))
					{
					BIO_printf(bio_err,"CERTIFICATION CANCELED\n"); 
					ret=0;
a1141 1
					}
d1143 6
d1150 1
a1150 1
			BIO_printf(bio_err,"Write out database with %d new entries\n",sk_X509_num(cert_sk));
d1152 6
a1157 1
			if (!save_serial(serialfile,"new",serial,NULL)) goto err;
a1158 3
			if (!save_index(dbfile, "new", db)) goto err;
			}
	
d1160 2
a1161 3
			BIO_printf(bio_err,"writing new certificates\n");
		for (i=0; i<sk_X509_num(cert_sk); i++)
			{
d1165 1
a1165 1
			x=sk_X509_value(cert_sk,i);
d1167 5
a1171 6
			j=x->cert_info->serialNumber->length;
			p=(const char *)x->cert_info->serialNumber->data;
			
			if(strlen(outdir) >= (size_t)(j ? BSIZE-j*2-6 : BSIZE-8))
				{
				BIO_printf(bio_err,"certificate file name too long\n");
d1173 1
a1173 1
				}
d1175 1
a1175 1
			strlcpy(buf[2],outdir,sizeof(buf[2]));
d1177 1
a1177 1
			BUF_strlcat(buf[2],"/",sizeof(buf[2]));
d1179 3
a1181 5
			n=(char *)&(buf[2][strlen(buf[2])]);
			if (j > 0)
				{
				for (k=0; k<j; k++)
					{
d1185 13
a1197 12
						     &buf[2][0] + sizeof(buf[2]) - n,
						     "%02X",(unsigned char)*(p++));
					n+=2;
					}
				}
			else
				{
				*(n++)='0';
				*(n++)='0';
				}
			*(n++)='.'; *(n++)='p'; *(n++)='e'; *(n++)='m';
			*n='\0';
d1199 1
a1199 1
				BIO_printf(bio_err,"writing %s\n",buf[2]);
d1201 1
a1201 2
			if (BIO_write_filename(Cout,buf[2]) <= 0)
				{
a1203 3
				}
			write_new_certificate(Cout,x, 0, notext);
			write_new_certificate(Sout,x, output_der, notext);
d1205 3
d1209 1
a1209 2
		if (sk_X509_num(cert_sk))
			{
d1211 2
a1212 1
			if (!rotate_serial(serialfile,"new","old")) goto err;
d1214 2
a1215 1
			if (!rotate_index(dbfile,"new","old")) goto err;
d1217 1
a1217 2
			BIO_printf(bio_err,"Data Base Updated\n");
			}
d1219 2
a1220 1
	
d1222 1
a1222 2
	if (gencrl)
		{
d1224 2
a1225 3
		if (!crl_ext)
			{
			crl_ext=NCONF_get_string(conf,section,ENV_CRLEXT);
d1228 2
a1229 3
			}
		if (crl_ext)
			{
d1234 1
a1234 2
			if (!X509V3_EXT_add_nconf(conf, &ctx, crl_ext, NULL))
				{
d1236 2
a1237 2
				 "Error Loading CRL extension section %s\n",
								 crl_ext);
a1239 1
				}
d1241 1
d1243 1
a1243 1
		if ((crlnumberfile=NCONF_get_string(conf,section,ENV_CRLNUMBER))
d1245 4
a1248 5
			if ((crlnumber=load_serial(crlnumberfile,0,NULL)) == NULL)
				{
				BIO_printf(bio_err,"error while loading CRL number\n");
				goto err;
				}
d1250 3
a1252 4
		if (!crldays && !crlhours && !crlsec)
			{
			if (!NCONF_get_number(conf,section,
				ENV_DEFAULT_CRL_DAYS, &crldays))
d1254 2
a1255 2
			if (!NCONF_get_number(conf,section,
				ENV_DEFAULT_CRL_HOURS, &crlhours))
d1258 3
a1260 4
			}
		if ((crldays == 0) && (crlhours == 0) && (crlsec == 0))
			{
			BIO_printf(bio_err,"cannot lookup how long until the next CRL is issued\n");
d1262 1
a1262 1
			}
d1264 6
a1269 3
		if (verbose) BIO_printf(bio_err,"making CRL\n");
		if ((crl=X509_CRL_new()) == NULL) goto err;
		if (!X509_CRL_set_issuer_name(crl, X509_get_subject_name(x509))) goto err;
d1272 4
a1275 3
		if (!tmptm) goto err;
		X509_gmtime_adj(tmptm,0);
		X509_CRL_set_lastUpdate(crl, tmptm);	
d1277 1
a1277 2
			NULL))
			{
d1280 2
a1281 2
			}
		X509_CRL_set_nextUpdate(crl, tmptm);	
d1285 5
a1289 6
		for (i=0; i<sk_OPENSSL_PSTRING_num(db->db->data); i++)
			{
			pp=sk_OPENSSL_PSTRING_value(db->db->data,i);
			if (pp[DB_type][0] == DB_TYPE_REV)
				{
				if ((r=X509_REVOKED_new()) == NULL) goto err;
d1291 4
a1294 2
				if (!j) goto err;
				if (j == 2) crl_v2 = 1;
d1304 1
a1304 2
				X509_CRL_add0_revoked(crl,r);
				}
d1306 1
d1313 2
a1314 1
		if (verbose) BIO_printf(bio_err,"signing CRL\n");
d1318 1
a1318 2
		if (crl_ext || crlnumberfile != NULL)
			{
d1325 2
a1326 3
					crl_ext, crl)) goto err;
			if (crlnumberfile != NULL)
				{
d1328 3
a1330 2
				if (!tmpser) goto err;
				X509_CRL_add1_ext_i2d(crl,NID_crl_number,tmpser,0,0);
d1333 2
a1334 2
				if (!BN_add_word(crlnumber,1)) goto err;
				}
d1336 2
a1337 2
		if (crl_ext || crl_v2)
			{
d1340 2
a1341 1
			}
a1342 1
		
d1344 2
a1345 1
			if (!save_serial(crlnumberfile,"new",crlnumber,NULL)) goto err;
d1347 1
a1347 2
		if (crlnumber)
			{
d1350 1
a1350 1
			}
d1352 2
a1353 1
		if (!do_X509_CRL_sign(bio_err,crl,pkey,dgst,sigopts)) goto err;
d1355 1
a1355 1
		PEM_write_bio_X509_CRL(Sout,crl);
d1358 2
a1359 1
			if (!rotate_serial(crlnumberfile,"new","old")) goto err;
d1361 1
a1361 1
		}
d1363 3
a1365 5
	if (dorevoke)
		{
		if (infile == NULL) 
			{
			BIO_printf(bio_err,"no input files\n");
d1367 1
a1367 3
			}
		else
			{
d1369 2
a1370 2
			revcert=load_cert(bio_err, infile, FORMAT_PEM,
				NULL, e, infile);
d1373 3
a1375 2
			j=do_revoke(revcert,db, rev_type, rev_arg);
			if (j <= 0) goto err;
d1378 2
a1379 1
			if (!save_index(dbfile, "new", db)) goto err;
d1381 2
a1382 1
			if (!rotate_index(dbfile, "new", "old")) goto err;
d1384 1
a1384 2
			BIO_printf(bio_err,"Data Base Updated\n"); 
			}
d1386 1
d1388 1
a1388 1
	ret=0;
d1390 1
a1390 1
	if(tofree)
d1398 1
a1398 1
		sk_X509_pop_free(cert_sk,X509_free);
d1400 2
a1401 1
	if (ret) ERR_print_errors(bio_err);
d1411 2
a1412 1
	if (x509) X509_free(x509);
d1419 1
a1419 6
	}

static void lookup_fail(const char *name, const char *tag)
	{
	BIO_printf(bio_err,"variable lookup failed for %s::%s\n",name,tag);
	}
d1421 19
a1439 13
static int certify(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
	     const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
	     STACK_OF(CONF_VALUE) *policy, CA_DB *db,
	     BIGNUM *serial, char *subj,unsigned long chtype, int multirdn,
	     int email_dn, char *startdate, char *enddate,
	     long days, int batch, char *ext_sect, CONF *lconf, int verbose,
	     unsigned long certopt, unsigned long nameopt, int default_op,
	     int ext_copy, int selfsign)
	{
	X509_REQ *req=NULL;
	BIO *in=NULL;
	EVP_PKEY *pktmp=NULL;
	int ok= -1,i;
d1441 1
a1441 1
	in=BIO_new(BIO_s_file());
d1443 1
a1443 2
	if (BIO_read_filename(in,infile) <= 0)
		{
d1446 4
a1449 5
		}
	if ((req=PEM_read_bio_X509_REQ(in,NULL,NULL,NULL)) == NULL)
		{
		BIO_printf(bio_err,"Error reading certificate request in %s\n",
			infile);
d1451 1
a1451 1
		}
d1453 1
a1453 1
		X509_REQ_print(bio_err,req);
d1455 1
a1455 1
	BIO_printf(bio_err,"Check that the request matches the signature\n");
d1457 3
a1459 4
	if (selfsign && !X509_REQ_check_private_key(req,pkey))
		{
		BIO_printf(bio_err,"Certificate request and CA private key do not match\n");
		ok=0;
d1461 3
a1463 4
		}
	if ((pktmp=X509_REQ_get_pubkey(req)) == NULL)
		{
		BIO_printf(bio_err,"error unpacking public key\n");
d1465 2
a1466 2
		}
	i=X509_REQ_verify(req,pktmp);
d1468 3
a1470 4
	if (i < 0)
		{
		ok=0;
		BIO_printf(bio_err,"Signature verification problems....\n");
d1472 12
a1483 14
		}
	if (i == 0)
		{
		ok=0;
		BIO_printf(bio_err,"Signature did not match the certificate request\n");
		goto err;
		}
	else
		BIO_printf(bio_err,"Signature ok\n");

	ok=do_body(xret,pkey,x509,dgst,sigopts, policy,db,serial,subj,chtype,
		multirdn, email_dn,
		startdate,enddate,days,batch,verbose,req,ext_sect,lconf,
		certopt, nameopt, default_op, ext_copy, selfsign);
d1486 20
a1505 4
	if (req != NULL) X509_REQ_free(req);
	if (in != NULL) BIO_free(in);
	return(ok);
	}
d1507 1
a1507 14
static int certify_cert(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
	     const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
	     STACK_OF(CONF_VALUE) *policy, CA_DB *db,
	     BIGNUM *serial, char *subj, unsigned long chtype, int multirdn, int email_dn, char *startdate, char *enddate,
	     long days, int batch, char *ext_sect, CONF *lconf, int verbose,
	     unsigned long certopt, unsigned long nameopt, int default_op,
	     int ext_copy, ENGINE *e)
	{
	X509 *req=NULL;
	X509_REQ *rreq=NULL;
	EVP_PKEY *pktmp=NULL;
	int ok= -1,i;

	if ((req=load_cert(bio_err, infile, FORMAT_PEM, NULL, e, infile)) == NULL)
d1510 1
a1510 1
		X509_print(bio_err,req);
d1512 1
a1512 1
	BIO_printf(bio_err,"Check that the request matches the signature\n");
d1514 2
a1515 3
	if ((pktmp=X509_get_pubkey(req)) == NULL)
		{
		BIO_printf(bio_err,"error unpacking public key\n");
d1517 2
a1518 2
		}
	i=X509_verify(req,pktmp);
d1520 3
a1522 4
	if (i < 0)
		{
		ok=0;
		BIO_printf(bio_err,"Signature verification problems....\n");
d1524 4
a1527 5
		}
	if (i == 0)
		{
		ok=0;
		BIO_printf(bio_err,"Signature did not match the certificate\n");
d1529 2
a1530 3
		}
	else
		BIO_printf(bio_err,"Signature ok\n");
d1532 1
a1532 1
	if ((rreq=X509_to_X509_REQ(req,NULL,EVP_md5())) == NULL)
d1535 3
a1537 3
	ok=do_body(xret,pkey,x509,dgst,sigopts,policy,db,serial,subj,chtype,multirdn,email_dn,startdate,enddate,
		days,batch,verbose,rreq,ext_sect,lconf, certopt, nameopt, default_op,
		ext_copy, 0);
d1540 19
a1558 17
	if (rreq != NULL) X509_REQ_free(rreq);
	if (req != NULL) X509_free(req);
	return(ok);
	}

static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509, const EVP_MD *dgst,
	     STACK_OF(OPENSSL_STRING) *sigopts, STACK_OF(CONF_VALUE) *policy,
             CA_DB *db, BIGNUM *serial, char *subj,
	     unsigned long chtype, int multirdn,
	     int email_dn, char *startdate, char *enddate, long days, int batch,
	     int verbose, X509_REQ *req, char *ext_sect, CONF *lconf,
	     unsigned long certopt, unsigned long nameopt, int default_op,
	     int ext_copy, int selfsign)
	{
	X509_NAME *name=NULL,*CAname=NULL,*subject=NULL, *dn_subject=NULL;
	ASN1_UTCTIME *tm,*tmptm;
	ASN1_STRING *str,*str2;
d1560 1
a1560 1
	X509 *ret=NULL;
d1563 1
a1563 1
	X509_NAME_ENTRY *tne,*push;
d1565 1
a1565 1
	int ok= -1,i,j,last,nid;
d1569 2
a1570 2
	OPENSSL_STRING *irow=NULL;
	OPENSSL_STRING *rrow=NULL;
d1573 5
a1577 6
	tmptm=ASN1_UTCTIME_new();
	if (tmptm == NULL)
		{
		BIO_printf(bio_err,"malloc error\n");
		return(0);
		}
d1579 2
a1580 2
	for (i=0; i<DB_NUMBER; i++)
		row[i]=NULL;
d1582 1
a1582 2
	if (subj)
		{
d1585 1
a1585 2
		if (!n)
			{
d1588 2
a1589 2
			}
		X509_REQ_set_subject_name(req,n);
d1592 1
a1592 1
		}
d1595 1
a1595 1
		BIO_printf(bio_err,"The Subject's Distinguished Name is as follows\n");
d1597 5
a1601 6
	name=X509_REQ_get_subject_name(req);
	for (i=0; i<X509_NAME_entry_count(name); i++)
		{
		ne= X509_NAME_get_entry(name,i);
		str=X509_NAME_ENTRY_get_data(ne);
		obj=X509_NAME_ENTRY_get_object(ne);
d1603 1
a1603 2
		if (msie_hack)
			{
d1605 1
a1605 1
			nid=OBJ_obj2nid(ne->object);
d1611 2
a1612 2
				(nid != NID_pkcs9_emailAddress))
				str->type=V_ASN1_T61STRING;
d1615 3
a1617 3
				(str->type == V_ASN1_PRINTABLESTRING))
				str->type=V_ASN1_IA5STRING;
			}
d1625 2
a1626 3
			(str->type != V_ASN1_IA5STRING))
			{
			BIO_printf(bio_err,"\nemailAddress type needs to be of type IA5STRING\n");
d1628 8
a1635 10
			}
		if ((str->type != V_ASN1_BMPSTRING) && (str->type != V_ASN1_UTF8STRING))
			{
			j=ASN1_PRINTABLE_type(str->data,str->length);
			if (	((j == V_ASN1_T61STRING) &&
				 (str->type != V_ASN1_T61STRING)) ||
				((j == V_ASN1_IA5STRING) &&
				 (str->type == V_ASN1_PRINTABLESTRING)))
				{
				BIO_printf(bio_err,"\nThe string contains characters that are illegal for the ASN.1 type\n");
a1636 1
				}
d1638 1
d1642 1
a1642 1
		}
d1645 2
a1646 3
	if ((subject=X509_NAME_new()) == NULL)
		{
		BIO_printf(bio_err,"Memory allocation failure\n");
d1648 1
a1648 1
		}
d1652 1
a1652 1
		CAname=X509_NAME_dup(name);
d1654 4
a1657 3
		CAname=X509_NAME_dup(x509->cert_info->subject);
	if (CAname == NULL) goto err;
	str=str2=NULL;
d1659 1
a1659 2
	for (i=0; i<sk_CONF_VALUE_num(policy); i++)
		{
d1661 2
a1662 3
		if ((j=OBJ_txt2nid(cv->name)) == NID_undef)
			{
			BIO_printf(bio_err,"%s:unknown object type in 'policy' configuration\n",cv->name);
d1664 2
a1665 2
			}
		obj=OBJ_nid2obj(j);
d1667 2
a1668 3
		last= -1;
		for (;;)
			{
d1670 9
a1678 11
			j=X509_NAME_get_index_by_OBJ(name,obj,last);
			if (j < 0)
				{
				if (last != -1) break;
				tne=NULL;
				}
			else
				{
				tne=X509_NAME_get_entry(name,j);
				}
			last=j;
d1681 2
a1682 3
			push=NULL;
			if (strcmp(cv->value,"optional") == 0)
				{
d1684 8
a1691 14
					push=tne;
				}
			else if (strcmp(cv->value,"supplied") == 0)
				{
				if (tne == NULL)
					{
					BIO_printf(bio_err,"The %s field needed to be supplied and was missing\n",cv->name);
					goto err;
					}
				else
					push=tne;
				}
			else if (strcmp(cv->value,"match") == 0)
				{
d1694 2
a1695 3
				if (tne == NULL)
					{
					BIO_printf(bio_err,"The mandatory %s field was missing\n",cv->name);
d1697 1
a1697 1
					}
d1699 1
a1699 1
				last2= -1;
d1702 11
a1712 13
				j=X509_NAME_get_index_by_OBJ(CAname,obj,last2);
				if ((j < 0) && (last2 == -1))
					{
					BIO_printf(bio_err,"The %s field does not exist in the CA certificate,\nthe 'policy' is misconfigured\n",cv->name);
					goto err;
					}
				if (j >= 0)
					{
					push=X509_NAME_get_entry(CAname,j);
					str=X509_NAME_ENTRY_get_data(tne);
					str2=X509_NAME_ENTRY_get_data(push);
					last2=j;
					if (ASN1_STRING_cmp(str,str2) != 0)
d1714 3
a1716 4
					}
				if (j < 0)
					{
					BIO_printf(bio_err,"The %s field needed to be the same in the\nCA certificate (%s) and the request (%s)\n",cv->name,((str2 == NULL)?"NULL":(char *)str2->data),((str == NULL)?"NULL":(char *)str->data));
a1717 1
					}
d1719 2
a1720 3
			else
				{
				BIO_printf(bio_err,"%s:invalid type in 'policy' configuration\n",cv->value);
d1722 1
a1722 1
				}
d1724 2
a1725 4
			if (push != NULL)
				{
				if (!X509_NAME_add_entry(subject,push, -1, 0))
					{
d1728 1
a1728 1
					BIO_printf(bio_err,"Memory allocation failure\n");
a1729 1
					}
a1730 1
			if (j < 0) break;
d1732 2
d1735 1
d1737 1
a1737 2
	if (preserve)
		{
d1740 4
a1743 3
		subject=X509_NAME_dup(name);
		if (subject == NULL) goto err;
		}
d1746 1
a1746 1
		BIO_printf(bio_err,"The subject name appears to be ok, checking data base for clashes\n");
d1750 1
a1750 1
	 
d1753 1
a1753 2
	else
		{
d1758 2
a1759 3
		if (!(dn_subject = X509_NAME_dup(subject)))
			{
			BIO_printf(bio_err,"Memory allocation failure\n");
d1761 3
a1763 4
			}
		while((i = X509_NAME_get_index_by_NID(dn_subject,
					NID_pkcs9_emailAddress, -1)) >= 0)
			{
a1766 1
			}
d1768 1
d1771 1
a1771 1
		row[DB_serial]=BUF_strdup("00");
d1773 3
a1775 4
		row[DB_serial]=BN_bn2hex(serial);
	if (row[DB_serial] == NULL)
		{
		BIO_printf(bio_err,"Memory allocation failure\n");
d1777 1
a1777 1
		}
d1779 2
a1780 3
	if (db->attributes.unique_subject)
		{
		OPENSSL_STRING *crow=row;
d1782 2
a1783 3
		rrow=TXT_DB_get_by_index(db->db,DB_name,crow);
		if (rrow != NULL)
			{
d1785 2
a1786 3
				"ERROR:There is already a certificate for %s\n",
				row[DB_name]);
			}
d1788 7
a1794 9
	if (rrow == NULL)
		{
		rrow=TXT_DB_get_by_index(db->db,DB_serial,row);
		if (rrow != NULL)
			{
			BIO_printf(bio_err,"ERROR:Serial number %s has already been issued,\n",
				row[DB_serial]);
			BIO_printf(bio_err,"      check the database/serial_file for corruption\n");
			}
d1796 1
d1798 1
a1798 2
	if (rrow != NULL)
		{
d1800 1
a1800 1
			"The matching entry has the following details\n");
d1809 13
a1821 14
		BIO_printf(bio_err,"Type	  :%s\n",p);
		if (rrow[DB_type][0] == 'R')
			{
			p=rrow[DB_exp_date]; if (p == NULL) p="undef";
			BIO_printf(bio_err,"Was revoked on:%s\n",p);
			}
		p=rrow[DB_exp_date]; if (p == NULL) p="undef";
		BIO_printf(bio_err,"Expires on    :%s\n",p);
		p=rrow[DB_serial]; if (p == NULL) p="undef";
		BIO_printf(bio_err,"Serial Number :%s\n",p);
		p=rrow[DB_file]; if (p == NULL) p="undef";
		BIO_printf(bio_err,"File name     :%s\n",p);
		p=rrow[DB_name]; if (p == NULL) p="undef";
		BIO_printf(bio_err,"Subject Name  :%s\n",p);
d1824 1
a1824 1
		}
d1828 1
a1828 1
		BIO_printf(bio_err,"Everything appears to be ok, creating and signing the certificate\n");
d1830 3
a1832 2
	if ((ret=X509_new()) == NULL) goto err;
	ci=ret->cert_info;
d1836 2
a1837 1
	if (!X509_set_version(ret,2)) goto err;
d1840 1
a1840 1
	if (BN_to_ASN1_INTEGER(serial,ci->serialNumber) == NULL)
d1842 2
a1843 3
	if (selfsign)
		{
		if (!X509_set_issuer_name(ret,subject))
d1845 2
a1846 4
		}
	else
		{
		if (!X509_set_issuer_name(ret,X509_get_subject_name(x509)))
d1848 1
a1848 1
		}
d1850 4
a1853 3
	if (strcmp(startdate,"today") == 0)
		X509_gmtime_adj(X509_get_notBefore(ret),0);
	else ASN1_TIME_set_string(X509_get_notBefore(ret),startdate);
d1856 3
a1858 2
		X509_time_adj_ex(X509_get_notAfter(ret),days, 0, NULL);
	else ASN1_TIME_set_string(X509_get_notAfter(ret),enddate);
d1860 2
a1861 1
	if (!X509_set_subject_name(ret,subject)) goto err;
d1863 2
a1864 2
	pktmp=X509_REQ_get_pubkey(req);
	i = X509_set_pubkey(ret,pktmp);
d1866 2
a1867 1
	if (!i) goto err;
d1870 1
a1870 2
	if (ext_sect)
		{
d1873 1
a1873 1
			if ((ci->version=ASN1_INTEGER_new()) == NULL)
d1881 1
a1881 1
						   X509_EXTENSION_free);
d1891 1
a1891 2
		if (extconf)
			{
d1894 1
a1894 1
 
d1897 1
a1897 1
 
d1902 1
a1902 2
			if (!X509V3_EXT_add_nconf(extconf, &ctx, ext_sect,ret))
				{
d1905 1
a1905 1
								ext_sect);
d1908 1
a1908 1
				}
d1911 1
a1911 3
			}
		else if (ext_sect)
			{
d1915 1
a1915 2
			if(!X509V3_EXT_add_nconf(lconf, &ctx, ext_sect, ret))
				{
d1919 1
a1919 1
				}
d1921 1
a1921 1
			if (verbose) 
a1922 1
			}
d1924 1
d1928 1
a1928 2
	if (!copy_extensions(ret, req, ext_copy))
		{
d1932 1
a1932 1
		}
d1935 4
a1938 4
	if( email_dn == 0 )
		{
		if (!X509_set_subject_name(ret,dn_subject)) goto err;
		}
d1940 1
a1940 2
	if (!default_op)
		{
d1944 2
a1945 2
		X509_print_ex(bio_err, ret, nameopt, certopt); 
		}
d1947 4
a1950 3
	BIO_printf(bio_err,"Certificate is to be certified until ");
	ASN1_TIME_print(bio_err,X509_get_notAfter(ret));
	if (days) BIO_printf(bio_err," (%ld days)",days);
d1953 1
a1953 2
	if (!batch)
		{
d1955 1
a1955 1
		BIO_printf(bio_err,"Sign the certificate? [y/n]:");
d1957 4
a1960 5
		buf[0]='\0';
		if (!fgets(buf,sizeof(buf)-1,stdin))
			{
			BIO_printf(bio_err,"CERTIFICATE WILL NOT BE CERTIFIED: I/O error\n");
			ok=0;
d1962 4
a1965 5
			}
		if (!((buf[0] == 'y') || (buf[0] == 'Y')))
			{
			BIO_printf(bio_err,"CERTIFICATE WILL NOT BE CERTIFIED\n");
			ok=0;
a1966 1
			}
d1968 1
d1970 1
a1970 1
	pktmp=X509_get_pubkey(ret);
d1972 2
a1973 2
		!EVP_PKEY_missing_parameters(pkey))
		EVP_PKEY_copy_parameters(pktmp,pkey);
d1976 1
a1976 1
	if (!do_X509_sign(bio_err, ret,pkey,dgst, sigopts))
d1980 1
a1980 1
	row[DB_type]=(char *)OPENSSL_malloc(2);
d1982 4
a1985 4
	tm=X509_get_notAfter(ret);
	row[DB_exp_date]=(char *)OPENSSL_malloc(tm->length+1);
	memcpy(row[DB_exp_date],tm->data,tm->length);
	row[DB_exp_date][tm->length]='\0';
d1987 1
a1987 1
	row[DB_rev_date]=NULL;
d1990 2
a1991 2
	row[DB_file]=(char *)OPENSSL_malloc(8);
	row[DB_name]=X509_NAME_oneline(X509_get_subject_name(ret),NULL,0);
d1994 2
a1995 3
		(row[DB_file] == NULL) || (row[DB_name] == NULL))
		{
		BIO_printf(bio_err,"Memory allocation failure\n");
d1997 4
a2000 4
		}
	BUF_strlcpy(row[DB_file],"unknown",8);
	row[DB_type][0]='V';
	row[DB_type][1]='\0';
d2002 2
a2003 3
	if ((irow=(char **)OPENSSL_malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)
		{
		BIO_printf(bio_err,"Memory allocation failure\n");
d2005 1
a2005 1
		}
d2007 5
a2011 6
	for (i=0; i<DB_NUMBER; i++)
		{
		irow[i]=row[i];
		row[i]=NULL;
		}
	irow[DB_NUMBER]=NULL;
d2013 3
a2015 4
	if (!TXT_DB_insert(db->db,irow))
		{
		BIO_printf(bio_err,"failed to update database\n");
		BIO_printf(bio_err,"TXT_DB error number %ld\n",db->db->error);
d2017 2
a2018 2
		}
	ok=1;
d2020 3
a2022 2
	for (i=0; i<DB_NUMBER; i++)
		if (row[i] != NULL) OPENSSL_free(row[i]);
d2032 15
a2046 8
	if (ok <= 0)
		{
		if (ret != NULL) X509_free(ret);
		ret=NULL;
		}
	else
		*xret=ret;
	return(ok);
a2047 9

static void write_new_certificate(BIO *bp, X509 *x, int output_der, int notext)
	{

	if (output_der)
		{
		(void)i2d_X509_bio(bp,x);
		return;
		}
d2050 2
a2051 2
	f=X509_NAME_oneline(X509_get_issuer_name(x),buf,256);
	BIO_printf(bp,"issuer :%s\n",f);
d2053 2
a2054 2
	f=X509_NAME_oneline(X509_get_subject_name(x),buf,256);
	BIO_printf(bp,"subject:%s\n",f);
d2056 3
a2058 3
	BIO_puts(bp,"serial :");
	i2a_ASN1_INTEGER(bp,x->cert_info->serialNumber);
	BIO_puts(bp,"\n\n");
d2060 17
a2076 15
	if (!notext)X509_print(bp,x);
	PEM_write_bio_X509(bp,x);
	}

static int certify_spkac(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
	     const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
	     STACK_OF(CONF_VALUE) *policy, CA_DB *db,
	     BIGNUM *serial, char *subj,unsigned long chtype, int multirdn, int email_dn, char *startdate, char *enddate,
	     long days, char *ext_sect, CONF *lconf, int verbose, unsigned long certopt,
	     unsigned long nameopt, int default_op, int ext_copy)
	{
	STACK_OF(CONF_VALUE) *sk=NULL;
	LHASH_OF(CONF_VALUE) *parms=NULL;
	X509_REQ *req=NULL;
	CONF_VALUE *cv=NULL;
d2079 5
a2083 5
	char *type,*buf;
	EVP_PKEY *pktmp=NULL;
	X509_NAME *n=NULL;
	X509_NAME_ENTRY *ne=NULL;
	int ok= -1,i,j;
d2092 3
a2094 4
	parms=CONF_load(NULL,infile,&errline);
	if (parms == NULL)
		{
		BIO_printf(bio_err,"error on line %ld of %s\n",errline,infile);
d2097 1
a2097 1
		}
d2099 2
a2100 3
	sk=CONF_get_section(parms, "default");
	if (sk_CONF_VALUE_num(sk) == 0)
		{
d2104 1
a2104 1
		}
d2113 2
a2114 3
	req=X509_REQ_new();
	if (req == NULL)
		{
d2117 1
a2117 1
		}
d2122 1
a2122 1
	ri=req->req_info;
d2125 3
a2127 3
	for (i = 0; ; i++)
		{
		if (sk_CONF_VALUE_num(sk) <= i) break;
d2129 2
a2130 2
		cv=sk_CONF_VALUE_value(sk,i);
		type=cv->name;
d2134 7
a2140 7
		for (buf = cv->name; *buf ; buf++)
			if ((*buf == ':') || (*buf == ',') || (*buf == '.'))
				{
				buf++;
				if (*buf) type = buf;
				break;
				}
d2142 3
a2144 5
		buf=cv->value;
		if ((nid=OBJ_txt2nid(type)) == NID_undef)
			{
			if (strcmp(type, "SPKAC") == 0)
				{
d2146 2
a2147 3
				if (spki == NULL)
					{
					BIO_printf(bio_err,"unable to load Netscape SPKAC structure\n");
a2149 1
					}
d2151 1
d2153 1
a2153 1
			}
d2156 1
a2156 1
				(unsigned char *)buf, -1, -1, 0))
d2158 4
a2161 5
		}
	if (spki == NULL)
		{
		BIO_printf(bio_err,"Netscape SPKAC structure not found in %s\n",
			infile);
d2163 1
a2163 1
		}
d2169 1
a2169 1
	BIO_printf(bio_err,"Check that the SPKAC request matches the signature\n");
d2171 2
a2172 3
	if ((pktmp=NETSCAPE_SPKI_get_pubkey(spki)) == NULL)
		{
		BIO_printf(bio_err,"error unpacking SPKAC public key\n");
d2174 1
a2174 1
		}
d2177 2
a2178 3
	if (j <= 0)
		{
		BIO_printf(bio_err,"signature verification failed on SPKAC public key\n");
d2180 2
a2181 2
		}
	BIO_printf(bio_err,"Signature ok\n");
d2183 1
a2183 1
	X509_REQ_set_pubkey(req,pktmp);
d2185 3
a2187 3
	ok=do_body(xret,pkey,x509,dgst,sigopts,policy,db,serial,subj,chtype,
		   multirdn,email_dn,startdate,enddate, days,1,verbose,req,
		   ext_sect,lconf, certopt, nameopt, default_op, ext_copy, 0);
d2189 15
a2203 10
	if (req != NULL) X509_REQ_free(req);
	if (parms != NULL) CONF_free(parms);
	if (spki != NULL) NETSCAPE_SPKI_free(spki);
	if (ne != NULL) X509_NAME_ENTRY_free(ne);

	return(ok);
	}

static int check_time_format(const char *str)
	{
d2205 1
a2205 1
	}
d2207 5
a2211 4
static int do_revoke(X509 *x509, CA_DB *db, int type, char *value)
	{
	ASN1_UTCTIME *tm=NULL;
	char *row[DB_NUMBER],**rrow,**irow;
d2214 1
a2214 1
	int ok=-1,i;
d2216 4
a2219 4
	for (i=0; i<DB_NUMBER; i++)
		row[i]=NULL;
	row[DB_name]=X509_NAME_oneline(X509_get_subject_name(x509),NULL,0);
	bn = ASN1_INTEGER_to_BN(X509_get_serialNumber(x509),NULL);
d2223 1
a2223 1
		row[DB_serial]=BUF_strdup("00");
d2225 1
a2225 1
		row[DB_serial]=BN_bn2hex(bn);
d2227 2
a2228 3
	if ((row[DB_name] == NULL) || (row[DB_serial] == NULL))
		{
		BIO_printf(bio_err,"Memory allocation failure\n");
d2230 1
a2230 1
		}
d2234 3
a2236 4
	rrow=TXT_DB_get_by_index(db->db,DB_serial,row);
	if (rrow == NULL)
		{
		BIO_printf(bio_err,"Adding Entry with serial number %s to DB for %s\n", row[DB_serial], row[DB_name]);
d2239 1
a2239 1
		row[DB_type]=(char *)OPENSSL_malloc(2);
d2241 4
a2244 4
		tm=X509_get_notAfter(x509);
		row[DB_exp_date]=(char *)OPENSSL_malloc(tm->length+1);
		memcpy(row[DB_exp_date],tm->data,tm->length);
		row[DB_exp_date][tm->length]='\0';
d2246 1
a2246 1
		row[DB_rev_date]=NULL;
d2249 1
a2249 1
		row[DB_file]=(char *)OPENSSL_malloc(8);
d2254 2
a2255 3
			(row[DB_file] == NULL))
			{
			BIO_printf(bio_err,"Memory allocation failure\n");
d2257 4
a2260 4
			}
		BUF_strlcpy(row[DB_file],"unknown",8);
		row[DB_type][0]='V';
		row[DB_type][1]='\0';
d2262 2
a2263 3
		if ((irow=(char **)OPENSSL_malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)
			{
			BIO_printf(bio_err,"Memory allocation failure\n");
d2265 1
a2265 1
			}
d2267 5
a2271 6
		for (i=0; i<DB_NUMBER; i++)
			{
			irow[i]=row[i];
			row[i]=NULL;
			}
		irow[DB_NUMBER]=NULL;
d2273 3
a2275 4
		if (!TXT_DB_insert(db->db,irow))
			{
			BIO_printf(bio_err,"failed to update database\n");
			BIO_printf(bio_err,"TXT_DB error number %ld\n",db->db->error);
d2277 1
a2277 1
			}
d2280 1
a2280 1
		ok = do_revoke(x509,db, type, value);
d2284 3
a2286 5
		}
	else if (index_name_cmp_noconst(row, rrow))
		{
		BIO_printf(bio_err,"ERROR:name does not match %s\n",
			   row[DB_name]);
d2288 3
a2290 5
		}
	else if (rrow[DB_type][0]=='R')
		{
		BIO_printf(bio_err,"ERROR:Already revoked, serial number %s\n",
			   row[DB_serial]);
d2292 2
a2293 4
		}
	else
		{
		BIO_printf(bio_err,"Revoking Certificate %s.\n", rrow[DB_serial]);
d2295 1
a2295 2
		if (!rev_str)
			{
d2298 3
a2300 3
			}
		rrow[DB_type][0]='R';
		rrow[DB_type][1]='\0';
d2302 2
a2303 2
		}
	ok=1;
d2305 2
a2306 3
	for (i=0; i<DB_NUMBER; i++)
		{
		if (row[i] != NULL) 
a2307 2
		}
	return(ok);
d2309 2
d2312 5
a2316 4
static int get_certificate_status(const char *serial, CA_DB *db)
	{
	char *row[DB_NUMBER],**rrow;
	int ok=-1,i;
d2319 2
a2320 2
	for (i=0; i<DB_NUMBER; i++)
		row[i]=NULL;
d2324 2
a2325 3
	if (row[DB_serial] == NULL)
		{
		BIO_printf(bio_err,"Malloc failure\n");
d2327 1
a2327 1
		}
d2329 1
a2329 2
	if (strlen(serial) % 2)
		{
d2335 2
a2336 4
		row[DB_serial][strlen(serial)+1]='\0';
		}
	else
		{
d2339 3
a2341 3
		row[DB_serial][strlen(serial)]='\0';
		}
			
d2343 1
a2343 1
	for (i=0; row[DB_serial][i] != '\0'; i++)
a2344 1
	
d2346 2
a2347 1
	ok=1;
d2350 27
a2376 38
	rrow=TXT_DB_get_by_index(db->db,DB_serial,row);
	if (rrow == NULL)
		{
		BIO_printf(bio_err,"Serial %s not present in db.\n",
				 row[DB_serial]);
		ok=-1;
		goto err;
		}
	else if (rrow[DB_type][0]=='V')
		{
		BIO_printf(bio_err,"%s=Valid (%c)\n",
			row[DB_serial], rrow[DB_type][0]);
		goto err;
		}
	else if (rrow[DB_type][0]=='R')
		{
		BIO_printf(bio_err,"%s=Revoked (%c)\n",
			row[DB_serial], rrow[DB_type][0]);
		goto err;
		}
	else if (rrow[DB_type][0]=='E')
		{
		BIO_printf(bio_err,"%s=Expired (%c)\n",
			row[DB_serial], rrow[DB_type][0]);
		goto err;
		}
	else if (rrow[DB_type][0]=='S')
		{
		BIO_printf(bio_err,"%s=Suspended (%c)\n",
			row[DB_serial], rrow[DB_type][0]);
		goto err;
		}
	else
		{
		BIO_printf(bio_err,"%s=Unknown (%c).\n",
			row[DB_serial], rrow[DB_type][0]);
		ok=-1;
		}
d2378 1
a2378 2
	for (i=0; i<DB_NUMBER; i++)
		{
a2380 2
		}
	return(ok);
d2382 2
d2386 1
a2386 1
	{
d2389 1
a2389 1
	int db_y2k, a_y2k;  /* flags = 1 if y >= 2000 */ 
d2396 2
a2397 3
	a_tm_s = (char *) OPENSSL_malloc(a_tm->length+1);
	if (a_tm_s == NULL)
		{
d2400 1
a2400 1
		}
d2410 1
a2410 2
	for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++)
		{
d2413 1
a2413 2
		if (rrow[DB_type][0] == 'V')
		 	{
d2420 1
a2420 2
			if (db_y2k == a_y2k)
				{
d2422 12
a2433 15
				if (strcmp(rrow[DB_exp_date], a_tm_s) <= 0)
				       	{
				       	rrow[DB_type][0]  = 'E';
				       	rrow[DB_type][1]  = '\0';
	  				cnt++;

					BIO_printf(bio_err, "%s=Expired\n",
							rrow[DB_serial]);
					}
				}
			else if (db_y2k < a_y2k)
				{
		  		rrow[DB_type][0]  = 'E';
		  		rrow[DB_type][1]  = '\0';
	  			cnt++;
d2435 3
a2437 3
				BIO_printf(bio_err, "%s=Expired\n",
							rrow[DB_serial]);
				}
d2439 2
a2440 2
			}
    		}
a2442 1

d2447 1
a2447 1
	}
d2455 1
a2455 1
	"superseded", 
d2475 3
a2477 2
char *make_revocation_str(int rev_type, char *rev_arg)
	{
d2483 1
a2483 2
	switch (rev_type)
		{
d2488 2
a2489 4
		for (i = 0; i < 8; i++)
			{
			if (!strcasecmp(rev_arg, crl_reasons[i]))
				{
a2491 1
				}
d2493 2
a2494 2
		if (reason == NULL)
			{
d2497 1
a2497 1
			}
d2506 1
a2506 2
		if (otmp == NULL)
			{
d2509 1
a2509 1
			}
d2514 1
a2514 1
		
d2519 1
a2519 2
		if (!ASN1_GENERALIZEDTIME_set_string(NULL, rev_arg))
			{	
d2522 1
a2522 1
			}
d2526 1
a2526 1
		else 
d2531 1
a2531 1
		}
d2537 4
a2540 2
	if (reason) i += strlen(reason) + 1;
	if (other) i += strlen(other) + 1;
d2544 2
a2545 1
	if (!str) return NULL;
d2548 2
a2549 3
	if (reason)
		{
		BUF_strlcat(str, ",", i);
d2551 3
a2553 4
		}
	if (other)
		{
		BUF_strlcat(str, ",", i);
d2555 1
a2555 1
		}
d2558 1
a2558 1
	}
d2560 1
a2560 1
/* Convert revocation field to X509_REVOKED entry 
d2567 3
a2569 3

int make_revoked(X509_REVOKED *rev, const char *str)
	{
d2587 1
a2587 2
	if (rev && (reason_code != OCSP_REVOKED_STATUS_NOSTATUS))
		{
d2593 1
a2593 1
		}
d2595 1
a2595 2
	if (rev && comp_time)
		{
d2598 2
a2599 3
		}
	if (rev && hold)
		{
d2602 1
a2602 1
		}
d2606 2
a2607 1
	else ret = 1;
d2609 1
a2609 1
	err:
d2611 2
a2612 1
	if (tmp) OPENSSL_free(tmp);
d2619 1
a2619 1
	}
d2621 4
a2624 3
int old_entry_print(BIO *bp, ASN1_OBJECT *obj, ASN1_STRING *str)
	{
	char buf[25],*pbuf, *p;
d2626 7
a2632 7
	j=i2a_ASN1_OBJECT(bp,obj);
	pbuf=buf;
	for (j=22-j; j>0; j--)
		*(pbuf++)=' ';
	*(pbuf++)=':';
	*(pbuf++)='\0';
	BIO_puts(bp,buf);
d2635 1
a2635 1
		BIO_printf(bp,"PRINTABLE:'");
d2637 1
a2637 1
		BIO_printf(bp,"T61STRING:'");
d2639 1
a2639 1
		BIO_printf(bp,"IA5STRING:'");
d2641 1
a2641 1
		BIO_printf(bp,"UNIVERSALSTRING:'");
d2643 4
a2646 5
		BIO_printf(bp,"ASN.1 %2d:'",str->type);
			
	p=(char *)str->data;
	for (j=str->length; j>0; j--)
		{
d2648 1
a2648 1
			BIO_printf(bp,"%c",*p);
d2650 1
a2650 1
			BIO_printf(bp,"\\0x%02X",*p);
d2652 3
a2654 2
			BIO_printf(bp,"^?");
		else	BIO_printf(bp,"^%c",*p+'@@');
d2656 2
a2657 2
		}
	BIO_printf(bp,"'\n");
d2659 1
a2659 1
	}
d2661 4
a2664 2
int unpack_revinfo(ASN1_TIME **prevtm, int *preason, ASN1_OBJECT **phold, ASN1_GENERALIZEDTIME **pinvtm, const char *str)
	{
d2674 1
a2674 1
	p = strchr(tmp, ',');
d2678 1
a2678 2
	if (p)
		{
d2682 2
a2683 3
		p = strchr(p, ',');
		if (p)
			{
a2685 1
			}
d2687 1
d2689 1
a2689 2
	if (prevtm)
		{
d2691 1
a2691 2
		if (!ASN1_UTCTIME_set_string(*prevtm, rtime_str))
			{
a2693 1
			}
d2695 4
a2698 6
	if (reason_str)
		{
		for (i = 0; i < NUM_REASONS; i++)
			{
			if(!strcasecmp(reason_str, crl_reasons[i]))
				{
a2700 1
				}
d2702 2
a2703 2
		if (reason_code == OCSP_REVOKED_STATUS_NOSTATUS)
			{
d2706 1
a2706 1
			}
d2711 2
a2712 3
			{
			if (!arg_str)
				{	
d2715 1
a2715 1
				}
d2719 1
a2719 2
			if (!hold)
				{
a2721 2
				}
			if (phold) *phold = hold;
d2723 4
a2726 4
		else if ((reason_code == 9) || (reason_code == 10))
			{
			if (!arg_str)
				{	
d2729 1
a2729 1
				}
d2731 1
a2731 2
			if (!ASN1_GENERALIZEDTIME_set_string(comp_time, arg_str))
				{	
d2734 1
a2734 1
				}
a2738 1
			}
d2740 1
d2742 6
a2747 3
	if (preason) *preason = reason_code;
	if (pinvtm) *pinvtm = comp_time;
	else ASN1_GENERALIZEDTIME_free(comp_time);
d2751 7
a2757 5
	err:

	if (tmp) OPENSSL_free(tmp);
	if (!phold) ASN1_OBJECT_free(hold);
	if (!pinvtm) ASN1_GENERALIZEDTIME_free(comp_time);
d2760 1
a2760 1
	}
@


1.27
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@a78 7
#  ifdef OPENSSL_SYS_VMS
#    if defined(__DECC)
#      include <unistd.h>
#    else
#      include <unixlib.h>
#    endif
#  elif !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_NETWARE)
a79 1
#  endif
a581 5
#ifdef OPENSSL_SYS_VMS
		len = strlen(s)+sizeof(CONFIG_FILE);
		tofree=OPENSSL_malloc(len);
		strcpy(tofree,s);
#else
a585 1
#endif
a842 1
#ifndef OPENSSL_SYS_VMS
a869 1
#endif
a929 6
#ifdef OPENSSL_SYS_VMS
		{
		BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		out = BIO_push(tmpbio, out);
		}
#endif
a1006 6
#ifdef OPENSSL_SYS_VMS
			{
			BIO *tmpbio = BIO_new(BIO_f_linebuffer());
			Sout = BIO_push(tmpbio, Sout);
			}
#endif
a1293 1
#ifndef OPENSSL_SYS_VMS
a1294 1
#endif
@


1.26
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@d1333 1
a1333 1
					BIO_snprintf(n,
@


1.25
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d321 1
a321 1
	MS_STATIC char buf[3][BSIZE];
@


1.24
log
@resolve conflicts
@
text
@d1411 1
@


1.23
log
@resolve conflicts, fix local changes
@
text
@d200 2
a201 1
		   const EVP_MD *dgst,STACK_OF(CONF_VALUE) *policy,CA_DB *db,
d207 2
a208 1
			const EVP_MD *dgst,STACK_OF(CONF_VALUE) *policy,
d215 2
a216 1
			 const EVP_MD *dgst,STACK_OF(CONF_VALUE) *policy,
d223 1
d318 1
d443 9
d1187 3
a1189 2
			j=certify_spkac(&x,spkac_file,pkey,x509,dgst,attribs,db,
				serial,subj,chtype,multirdn,email_dn,startdate,enddate,days,extensions,
d1212 2
a1213 1
			j=certify_cert(&x,ss_cert_file,pkey,x509,dgst,attribs,
d1233 1
a1233 1
			j=certify(&x,infile,pkey,x509p,dgst,attribs,db,
d1253 1
a1253 1
			j=certify(&x,argv[i],pkey,x509p,dgst,attribs,db,
d1502 1
a1502 1
		if (!X509_CRL_sign(crl,pkey,dgst)) goto err;
d1556 2
d1574 4
a1577 2
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, CA_DB *db,
	     BIGNUM *serial, char *subj,unsigned long chtype, int multirdn, int email_dn, char *startdate, char *enddate,
d1633 2
a1634 1
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj,chtype,multirdn, email_dn,
d1645 2
a1646 1
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, CA_DB *db,
d1689 1
a1689 1
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj,chtype,multirdn,email_dn,startdate,enddate,
d1700 2
a1701 1
	     STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial, char *subj,
d2172 1
a2172 1
	if (!X509_sign(ret,pkey,dgst))
d2266 2
a2267 1
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, CA_DB *db,
d2393 3
a2395 3
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj,chtype,multirdn,email_dn,startdate,enddate,
		   days,1,verbose,req,ext_sect,lconf, certopt, nameopt, default_op,
			ext_copy, 0);
d2563 1
a2563 1
		row[DB_serial][i] = toupper(row[DB_serial][i]);
@


1.22
log
@resolve conflicts
@
text
@a65 1
#include <sys/stat.h>
d85 1
a85 1
#  elif !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_NETWARE) && !defined(__TANDEM)
a217 1
static int fix_data(int nid, int *type);
d228 1
a228 1
static int check_time_format(char *str);
d260 1
d308 2
a309 1
	const char *p, **pp;
d460 5
d558 4
a561 2
		for (pp=ca_usage; (*pp != NULL); pp++)
			BIO_printf(bio_err,"%s",*pp);
a835 1
		struct stat sb;
d854 1
d856 3
d865 1
a865 8
		if (stat(outdir,&sb) != 0)
			{
			BIO_printf(bio_err,"unable to stat(%s)\n",outdir);
			perror(outdir);
			goto err;
			}
#ifdef S_ISDIR
		if (!S_ISDIR(sb.st_mode))
a871 1
#endif
d885 1
a885 1
	for (i=0; i<sk_num(db->db->data); i++)
d887 1
a887 1
		pp=(const char **)sk_value(db->db->data,i);
d940 1
a940 1
			db->db->data->num);
d1031 11
d1111 1
a1111 1
		if (startdate && !ASN1_UTCTIME_set_string(NULL,startdate))
d1113 1
a1113 1
			BIO_printf(bio_err,"start date is invalid, it should be YYMMDDHHMMSSZ\n");
d1125 1
a1125 1
		if (enddate && !ASN1_UTCTIME_set_string(NULL,enddate))
d1127 1
a1127 1
			BIO_printf(bio_err,"end date is invalid, it should be YYMMDDHHMMSSZ\n");
d1265 6
a1270 1
				fgets(buf[0],10,stdin);
d1387 1
a1387 1
		if (!crldays && !crlhours)
d1396 1
a1396 1
		if ((crldays == 0) && (crlhours == 0))
d1410 6
a1415 1
		X509_gmtime_adj(tmptm,(crldays*24+crlhours)*60*60);
d1420 1
a1420 1
		for (i=0; i<sk_num(db->db->data); i++)
d1422 1
a1422 1
			pp=(const char **)sk_value(db->db->data,i);
a1447 9
#ifndef OPENSSL_NO_DSA
		if (pkey->type == EVP_PKEY_DSA) 
			dgst=EVP_dss1();
		else
#endif
#ifndef OPENSSL_NO_ECDSA
		if (pkey->type == EVP_PKEY_EC)
			dgst=EVP_ecdsa();
#endif
d1480 6
d1538 1
d1697 3
a1699 1
	char *row[DB_NUMBER],**rrow=NULL,**irow=NULL;
d1941 3
a1943 1
		rrow=TXT_DB_get_by_index(db->db,DB_name,row);
d2019 1
a2019 1
	else ASN1_UTCTIME_set_string(X509_get_notBefore(ret),startdate);
d2022 2
a2023 2
		X509_gmtime_adj(X509_get_notAfter(ret),(long)60*60*24*days);
	else ASN1_UTCTIME_set_string(X509_get_notAfter(ret),enddate);
d2119 1
a2119 1
	ASN1_UTCTIME_print(bio_err,X509_get_notAfter(ret));
d2129 6
a2134 1
		fgets(buf,sizeof(buf)-1,stdin);
a2142 3

#ifndef OPENSSL_NO_DSA
	if (pkey->type == EVP_PKEY_DSA) dgst=EVP_dss1();
a2147 11
#endif
#ifndef OPENSSL_NO_ECDSA
	if (pkey->type == EVP_PKEY_EC)
		dgst = EVP_ecdsa();
	pktmp = X509_get_pubkey(ret);
	if (EVP_PKEY_missing_parameters(pktmp) &&
		!EVP_PKEY_missing_parameters(pkey))
		EVP_PKEY_copy_parameters(pktmp, pkey);
	EVP_PKEY_free(pktmp);
#endif

d2249 1
a2249 1
	LHASH *parms=NULL;
d2336 2
a2337 16
		/*
		if ((nid == NID_pkcs9_emailAddress) && (email_dn == 0))
			continue;
		*/
		
		j=ASN1_PRINTABLE_type((unsigned char *)buf,-1);
		if (fix_data(nid, &j) == 0)
			{
			BIO_printf(bio_err,
				"invalid characters in string %s\n",buf);
			goto err;
			}

		if ((ne=X509_NAME_ENTRY_create_by_NID(&ne,nid,j,
			(unsigned char *)buf,
			strlen(buf))) == NULL)
a2338 2

		if (!X509_NAME_add_entry(n,ne,-1, 0)) goto err;
d2381 1
a2381 1
static int fix_data(int nid, int *type)
d2383 1
a2383 21
	if (nid == NID_pkcs9_emailAddress)
		*type=V_ASN1_IA5STRING;
	if ((nid == NID_commonName) && (*type == V_ASN1_IA5STRING))
		*type=V_ASN1_T61STRING;
	if ((nid == NID_pkcs9_challengePassword) && (*type == V_ASN1_IA5STRING))
		*type=V_ASN1_T61STRING;
	if ((nid == NID_pkcs9_unstructuredName) && (*type == V_ASN1_T61STRING))
		return(0);
	if (nid == NID_pkcs9_unstructuredName)
		*type=V_ASN1_IA5STRING;
	return(1);
	}

static int check_time_format(char *str)
	{
	ASN1_UTCTIME tm;

	tm.data=(unsigned char *)str;
	tm.length=strlen(str);
	tm.type=V_ASN1_UTCTIME;
	return(ASN1_UTCTIME_check(&tm));
d2398 2
d2469 1
a2469 1
	else if (index_name_cmp((const char **)row,(const char **)rrow))
d2618 1
a2618 1
	for (i = 0; i < sk_num(db->db->data); i++)
d2620 1
a2620 1
		rrow = (char **) sk_value(db->db->data, i);
a2866 4
#ifdef CHARSET_EBCDIC
		if ((*p >= 0x20) && (*p <= 0x7e))
			BIO_printf(bp,"%c",os_toebcdic[*p]);
#else
a2868 1
#endif
a2872 3
#ifdef CHARSET_EBCDIC
		else	BIO_printf(bp,"^%c",os_toebcdic[*p+0x40]);
#else
a2873 1
#endif
@


1.21
log
@resolve conflicts
@
text
@d86 1
a86 1
#  elif !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_NETWARE)
@


1.20
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which lead to surprising results. Spotted by
Paul Stoeber. ok djm@@
@
text
@d86 1
a86 1
#  elif !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_WINDOWS)
d108 3
d137 1
d149 1
a149 1
static char *ca_usage[]={
d167 1
d180 2
d199 1
a199 1
static void lookup_fail(char *name,char *tag);
d202 1
a202 1
		   BIGNUM *serial, char *subj, int email_dn, char *startdate,
d205 1
a205 1
		   int default_op, int ext_copy);
d208 1
a208 1
			CA_DB *db, BIGNUM *serial, char *subj, int email_dn,
d215 1
a215 1
			 CA_DB *db, BIGNUM *serial,char *subj, int email_dn,
d222 1
a222 1
	STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial,char *subj,
d226 1
a226 1
	int ext_copy);
d232 1
a232 1
int make_revoked(X509_REVOKED *rev, char *str);
d282 2
d298 2
a299 1
	X509 *x509=NULL;
d308 2
a309 1
	char **pp,*p,*f;
d364 6
d420 2
d655 17
d673 1
a673 1
	p = NCONF_get_string(conf, section, "unique_subject");
d679 1
a679 16
		switch(*p)
			{
		case 'f': /* false */
		case 'F': /* FALSE */
		case 'n': /* no */
		case 'N': /* NO */
			db_attr.unique_subject = 0;
			break;
		case 't': /* true */
		case 'T': /* TRUE */
		case 'y': /* yes */
		case 'Y': /* YES */
		default:
			db_attr.unique_subject = 1;
			break;
			}
d723 1
a723 1
	/* we definitely need a public key, so let's get it */
d751 1
a751 2
	if ((certfile == NULL) && ((certfile=NCONF_get_string(conf,
		section,ENV_CERTIFICATE)) == NULL))
d753 11
a763 7
		lookup_fail(section,ENV_CERTIFICATE);
		goto err;
		}
	x509=load_cert(bio_err, certfile, FORMAT_PEM, NULL, e,
		"CA certificate");
	if (x509 == NULL)
		goto err;
d765 5
a769 4
	if (!X509_check_private_key(x509,pkey))
		{
		BIO_printf(bio_err,"CA certificate and CA private key do not match\n");
		goto err;
d771 1
d885 1
a885 1
		pp=(char **)sk_value(db->db->data,i);
d898 1
a898 1
		if (!check_time_format(pp[DB_exp_date]))
d1161 1
a1161 1
				serial,subj,email_dn,startdate,enddate,days,extensions,
d1185 1
a1185 1
				db,serial,subj,email_dn,startdate,enddate,days,batch,
d1204 2
a1205 2
			j=certify(&x,infile,pkey,x509,dgst,attribs,db,
				serial,subj,email_dn,startdate,enddate,days,batch,
d1207 1
a1207 1
				default_op, ext_copy);
d1224 2
a1225 2
			j=certify(&x,argv[i],pkey,x509,dgst,attribs,db,
				serial,subj,email_dn,startdate,enddate,days,batch,
d1227 1
a1227 1
				default_op, ext_copy);
d1278 1
a1278 1
			p=(char *)x->cert_info->serialNumber->data;
d1399 1
a1399 1
			pp=(char **)sk_value(db->db->data,i);
d1428 5
d1520 1
a1520 1
	X509_free(x509);
d1523 1
d1529 1
a1529 1
static void lookup_fail(char *name, char *tag)
d1536 1
a1536 1
	     BIGNUM *serial, char *subj, int email_dn, char *startdate, char *enddate,
d1539 1
a1539 1
	     int ext_copy)
d1564 6
d1592 1
a1592 1
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj, email_dn,
d1594 1
a1594 1
		certopt, nameopt, default_op, ext_copy);
d1604 1
a1604 1
	     BIGNUM *serial, char *subj, int email_dn, char *startdate, char *enddate,
d1646 1
a1646 1
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj,email_dn,startdate,enddate,
d1648 1
a1648 1
		ext_copy);
d1658 1
d1662 1
a1662 1
	     int ext_copy)
d1674 1
a1674 1
	char *p;
d1691 1
a1691 1
		X509_NAME *n = do_subject(subj, MBSTRING_ASC);
d1766 4
a1769 1
	CAname=X509_NAME_dup(x509->cert_info->subject);
d1981 10
a1990 2
	if (!X509_set_issuer_name(ret,X509_get_subject_name(x509)))
		goto err;
d2025 4
a2028 1
		X509V3_set_ctx(&ctx, x509, ret, req, NULL, 0);
d2095 1
a2095 1
	if (days) BIO_printf(bio_err," (%d days)",days);
d2122 10
d2228 1
a2228 1
	     BIGNUM *serial, char *subj, int email_dn, char *startdate, char *enddate,
d2369 1
a2369 1
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj,email_dn,startdate,enddate,
d2371 1
a2371 1
			ext_copy);
d2682 1
a2682 1
static char *crl_reasons[] = {
d2710 2
a2711 1
	char *reason = NULL, *other = NULL, *str;
d2805 1
a2805 1
int make_revoked(X509_REVOKED *rev, char *str)
a2858 123
/*
 * subject is expected to be in the format /type0=value0/type1=value1/type2=...
 * where characters may be escaped by \
 */
X509_NAME *do_subject(char *subject, long chtype)
	{
	size_t buflen = strlen(subject)+1; /* to copy the types and values into. due to escaping, the copy can only become shorter */
	char *buf = OPENSSL_malloc(buflen);
	size_t max_ne = buflen / 2 + 1; /* maximum number of name elements */
	char **ne_types = OPENSSL_malloc(max_ne * sizeof (char *));
	char **ne_values = OPENSSL_malloc(max_ne * sizeof (char *));

	char *sp = subject, *bp = buf;
	int i, ne_num = 0;

	X509_NAME *n = NULL;
	int nid;

	if (!buf || !ne_types || !ne_values)
	{
		BIO_printf(bio_err, "malloc error\n");
		goto error;
	}

	if (*subject != '/')
	{
		BIO_printf(bio_err, "Subject does not start with '/'.\n");
		goto error;
	}
	sp++; /* skip leading / */

	while (*sp)
		{
		/* collect type */
		ne_types[ne_num] = bp;
		while (*sp)
			{
			if (*sp == '\\') /* is there anything to escape in the type...? */
				{
				if (*++sp)
					*bp++ = *sp++;
				else
					{
					BIO_printf(bio_err, "escape character at end of string\n");
					goto error;
					}
				}
			else if (*sp == '=')
				{
				sp++;
				*bp++ = '\0';
				break;
				}
			else
				*bp++ = *sp++;
			}
		if (!*sp)
			{
			BIO_printf(bio_err, "end of string encountered while processing type of subject name element #%d\n", ne_num);
			goto error;
			}
		ne_values[ne_num] = bp;
		while (*sp)
			{
			if (*sp == '\\')
				{
				if (*++sp)
					*bp++ = *sp++;
				else
					{
					BIO_printf(bio_err, "escape character at end of string\n");
					goto error;
					}
				}
			else if (*sp == '/')
				{
				sp++;
				break;
				}
			else
				*bp++ = *sp++;
			}
		*bp++ = '\0';
		ne_num++;
		}

	if (!(n = X509_NAME_new()))
		goto error;

	for (i = 0; i < ne_num; i++)
		{
		if ((nid=OBJ_txt2nid(ne_types[i])) == NID_undef)
			{
			BIO_printf(bio_err, "Subject Attribute %s has no known NID, skipped\n", ne_types[i]);
			continue;
			}

		if (!*ne_values[i])
			{
			BIO_printf(bio_err, "No value provided for Subject Attribute %s, skipped\n", ne_types[i]);
			continue;
			}

		if (!X509_NAME_add_entry_by_NID(n, nid, chtype, (unsigned char*)ne_values[i], -1,-1,0))
			goto error;
		}

	OPENSSL_free(ne_values);
	OPENSSL_free(ne_types);
	OPENSSL_free(buf);
	return n;

error:
	X509_NAME_free(n);
	if (ne_values)
		OPENSSL_free(ne_values);
	if (ne_types)
		OPENSSL_free(ne_types);
	if (buf)
		OPENSSL_free(buf);
	return NULL;
}

d2885 4
d2891 1
d2896 3
d2900 1
d2907 1
a2907 1
int unpack_revinfo(ASN1_TIME **prevtm, int *preason, ASN1_OBJECT **phold, ASN1_GENERALIZEDTIME **pinvtm, char *str)
d2912 2
a2913 1
	int i, ret = 0;
@


1.19
log
@resolve conflicts
@
text
@d835 2
a836 2
#ifdef S_IFDIR
		if (!(sb.st_mode & S_IFDIR))
@


1.18
log
@kill strcpy; ok hshoexer@@, prodded by david@@
@
text
@a945 1
			goto err;
@


1.17
log
@resolve conflicts
@
text
@d1261 1
a1261 1
			strcpy(buf[2],outdir);
@


1.16
log
@merge 0.9.7d
@
text
@a78 10
#ifdef OPENSSL_SYS_WINDOWS
#define strcasecmp _stricmp
#else
#  ifdef NO_STRINGS_H
    int	strcasecmp();
#  else
#    include <strings.h>
#  endif /* NO_STRINGS_H */
#endif

d241 1
a540 4
#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine, 0);
#endif

d585 4
d660 2
d663 1
a663 1
	else
d997 13
a1011 6
		if ((md == NULL) && ((md=NCONF_get_string(conf,
			section,ENV_DEFAULT_MD)) == NULL))
			{
			lookup_fail(section,ENV_DEFAULT_MD);
			goto err;
			}
a1017 5
		if ((dgst=EVP_get_digestbyname(md)) == NULL)
			{
			BIO_printf(bio_err,"%s is an unsupported message digest type\n",md);
			goto err;
			}
d1104 1
a1104 1
		if ((serial=load_serial(serialfile, 0, NULL)) == NULL)
a1399 10
		if (md != NULL)
			{
			if ((dgst=EVP_get_digestbyname(md)) == NULL)
				{
				BIO_printf(bio_err,"%s is an unsupported message digest type\n",md);
				goto err;
				}
			}
		else
			{
d1401 2
a1402 3
			if (pkey->type == EVP_PKEY_DSA) 
				dgst=EVP_dss1();
			else
a1403 2
				dgst=EVP_md5();
			}
@


1.15
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d125 1
a146 12
#define DB_type         0
#define DB_exp_date     1
#define DB_rev_date     2
#define DB_serial       3       /* index - unique */
#define DB_file         4       
#define DB_name         5       /* index - unique for active */
#define DB_NUMBER       6

#define DB_TYPE_REV	'R'
#define DB_TYPE_EXP	'E'
#define DB_TYPE_VAL	'V'

a202 7
static unsigned long index_serial_hash(const char **a);
static int index_serial_cmp(const char **a, const char **b);
static unsigned long index_name_hash(const char **a);
static int index_name_qual(char **a);
static int index_name_cmp(const char **a,const char **b);
static BIGNUM *load_serial(char *serialfile);
static int save_serial(char *serialfile, BIGNUM *serial);
d204 1
a204 1
		   const EVP_MD *dgst,STACK_OF(CONF_VALUE) *policy,TXT_DB *db,
d211 1
a211 1
			TXT_DB *db, BIGNUM *serial, char *subj, int email_dn,
d218 1
a218 1
			 TXT_DB *db, BIGNUM *serial,char *subj, int email_dn,
d225 1
a225 1
	STACK_OF(CONF_VALUE) *policy, TXT_DB *db, BIGNUM *serial,char *subj,
d230 3
a232 3
static int do_revoke(X509 *x509, TXT_DB *db, int ext, char *extval);
static int get_certificate_status(const char *ser_status, TXT_DB *db);
static int do_updatedb(TXT_DB *db);
a243 5
static IMPLEMENT_LHASH_HASH_FN(index_serial_hash,const char **)
static IMPLEMENT_LHASH_COMP_FN(index_serial_cmp,const char **)
static IMPLEMENT_LHASH_HASH_FN(index_name_hash,const char **)
static IMPLEMENT_LHASH_COMP_FN(index_name_cmp,const char **)

d280 1
d289 1
d302 1
a302 1
	TXT_DB *db=NULL;
a308 1
	long l;
d320 1
d570 2
a571 2
		strlcpy(tofree,s,len);
		strlcat(tofree,"/",len);
d573 1
a573 1
		strlcat(tofree,CONFIG_FILE,len);
d644 33
d697 1
a697 7
		if (BIO_read_filename(in,dbfile) <= 0)
			{
			perror(dbfile);
			BIO_printf(bio_err,"unable to open '%s'\n",dbfile);
			goto err;
			}
		db=TXT_DB_read(in,DB_NUMBER);
d700 1
a700 2
		if (!make_serial_index(db))
			goto err;
d860 1
a860 7
	if (BIO_read_filename(in,dbfile) <= 0)
		{
		perror(dbfile);
		BIO_printf(bio_err,"unable to open '%s'\n",dbfile);
		goto err;
		}
	db=TXT_DB_read(in,DB_NUMBER);
d864 1
a864 1
	for (i=0; i<sk_num(db->data); i++)
d866 1
a866 1
		pp=(char **)sk_value(db->data,i);
d917 1
a917 1
		TXT_DB_write(out,db);
d919 1
a919 1
			db->data->num);
d923 1
a923 11
	if (!make_serial_index(db))
		goto err;

	if (!TXT_DB_create_index(db, DB_name, index_name_qual,
			LHASH_HASH_FN(index_name_hash),
			LHASH_COMP_FN(index_name_cmp)))
		{
		BIO_printf(bio_err,"error creating name index:(%ld,%ld,%ld)\n",
			db->error,db->arg1,db->arg2);
		goto err;
		}
d946 3
a948 56
			out = BIO_new(BIO_s_file());
			if (out == NULL)
				{
				ERR_print_errors(bio_err);
				goto err;
				}

#ifndef OPENSSL_SYS_VMS
			j = BIO_snprintf(buf[0], sizeof buf[0], "%s.new", dbfile);
#else
			j = BIO_snprintf(buf[0], sizeof buf[0], "%s-new", dbfile);
#endif
			if (j < 0 || j >= sizeof buf[0])
				{
				BIO_printf(bio_err, "file name too long\n");
				goto err;
				}
			if (BIO_write_filename(out,buf[0]) <= 0)
		  		{
		    		perror(dbfile);
		    		BIO_printf(bio_err,"unable to open '%s'\n",
									dbfile);
		    		goto err;
		  		}
			j=TXT_DB_write(out,db);
			if (j <= 0) goto err;
			
			BIO_free(out);
			out = NULL;
#ifndef OPENSSL_SYS_VMS
			j = BIO_snprintf(buf[1], sizeof buf[1], "%s.old", dbfile);
#else
			j = BIO_snprintf(buf[1], sizeof buf[1], "%s-old", dbfile);
#endif
			if (j < 0 || j >= sizeof buf[1])
				{
				BIO_printf(bio_err, "file name too long\n");
				goto err;
				}
			if (rename(dbfile,buf[1]) < 0)
		  		{
		    		BIO_printf(bio_err,
						"unable to rename %s to %s\n",
						dbfile, buf[1]);
		    		perror("reason");
		    		goto err;
		  		}
			if (rename(buf[0],dbfile) < 0)
				{
		    		BIO_printf(bio_err,
						"unable to rename %s to %s\n",
						buf[0],dbfile);
		    		perror("reason");
		    		rename(buf[1],dbfile);
		    		goto err;
		  		}
d1109 1
a1109 1
		if ((serial=load_serial(serialfile)) == NULL)
d1243 1
a1243 17
			if(strlen(serialfile) > BSIZE-5 || strlen(dbfile) > BSIZE-5)
				{
				BIO_printf(bio_err,"file name too long\n");
				goto err;
				}

			strcpy(buf[0],serialfile);

#ifdef OPENSSL_SYS_VMS
			strcat(buf[0],"-new");
#else
			strlcat(buf[0],".new",sizeof(buf[0]));
#endif

			if (!save_serial(buf[0],serial)) goto err;

			strcpy(buf[1],dbfile);
d1245 1
a1245 14
#ifdef OPENSSL_SYS_VMS
			strcat(buf[1],"-new");
#else
			strlcat(buf[1],".new",sizeof(buf[1]));
#endif

			if (BIO_write_filename(out,buf[1]) <= 0)
				{
				perror(dbfile);
				BIO_printf(bio_err,"unable to open '%s'\n",dbfile);
				goto err;
				}
			l=TXT_DB_write(out,db);
			if (l <= 0) goto err;
d1269 1
a1269 1
			strlcat(buf[2],"/",sizeof(buf[2]));
d1279 3
a1281 3
					snprintf(n,
						&buf[2][0] + sizeof(buf[2]) - n,
						"%02X",(unsigned char)*(p++));
d1307 1
a1307 8
			strncpy(buf[2],serialfile,BSIZE-4);
			buf[2][BSIZE-4]='\0';

#ifdef OPENSSL_SYS_VMS
			strcat(buf[2],"-old");
#else
			strlcat(buf[2],".old",sizeof(buf[2]));
#endif
d1309 1
a1309 22
			BIO_free(in);
			BIO_free_all(out);
			in=NULL;
			out=NULL;
			if (rename(serialfile,buf[2]) < 0)
				{
				BIO_printf(bio_err,"unable to rename %s to %s\n",
					serialfile,buf[2]);
				perror("reason");
				goto err;
				}
			if (rename(buf[0],serialfile) < 0)
				{
				BIO_printf(bio_err,"unable to rename %s to %s\n",
					buf[0],serialfile);
				perror("reason");
				rename(buf[2],serialfile);
				goto err;
				}

			strncpy(buf[2],dbfile,BSIZE-4);
			buf[2][BSIZE-4]='\0';
a1310 21
#ifdef OPENSSL_SYS_VMS
			strcat(buf[2],"-old");
#else
			strlcat(buf[2],".old",sizeof(buf[2]));
#endif

			if (rename(dbfile,buf[2]) < 0)
				{
				BIO_printf(bio_err,"unable to rename %s to %s\n",
					dbfile,buf[2]);
				perror("reason");
				goto err;
				}
			if (rename(buf[1],dbfile) < 0)
				{
				BIO_printf(bio_err,"unable to rename %s to %s\n",
					buf[1],dbfile);
				perror("reason");
				rename(buf[2],dbfile);
				goto err;
				}
d1341 8
d1377 1
a1377 1
		for (i=0; i<sk_num(db->data); i++)
d1379 1
a1379 1
			pp=(char **)sk_value(db->data,i);
d1425 1
a1425 1
		if (crl_ext)
d1431 12
a1442 2
			if (!X509V3_EXT_CRL_add_nconf(conf, &crlctx,
				crl_ext, crl)) goto err;
d1450 4
d1457 4
d1481 3
a1483 5
			if(strlen(dbfile) > BSIZE-5)
				{
				BIO_printf(bio_err,"filename too long\n");
				goto err;
				}
a1484 38
			strcpy(buf[0],dbfile);
#ifndef OPENSSL_SYS_VMS
			strlcat(buf[0],".new",sizeof(buf[0]));
#else
			strcat(buf[0],"-new");
#endif
			if (BIO_write_filename(out,buf[0]) <= 0)
				{
				perror(dbfile);
				BIO_printf(bio_err,"unable to open '%s'\n",dbfile);
				goto err;
				}
			j=TXT_DB_write(out,db);
			if (j <= 0) goto err;
			BIO_free_all(out);
			out = NULL;
			BIO_free_all(in);
			in = NULL;
			strncpy(buf[1],dbfile,BSIZE-4);
			buf[1][BSIZE-4]='\0';
#ifndef OPENSSL_SYS_VMS
			strlcat(buf[1],".old",sizeof(buf[1]));
#else
			strcat(buf[1],"-old");
#endif
			if (rename(dbfile,buf[1]) < 0)
				{
				BIO_printf(bio_err,"unable to rename %s to %s\n", dbfile, buf[1]);
				perror("reason");
				goto err;
				}
			if (rename(buf[0],dbfile) < 0)
				{
				BIO_printf(bio_err,"unable to rename %s to %s\n", buf[0],dbfile);
				perror("reason");
				rename(buf[1],dbfile);
				goto err;
				}
d1506 1
a1506 1
	TXT_DB_free(db);
a1520 98
static unsigned long index_serial_hash(const char **a)
	{
	const char *n;

	n=a[DB_serial];
	while (*n == '0') n++;
	return(lh_strhash(n));
	}

static int index_serial_cmp(const char **a, const char **b)
	{
	const char *aa,*bb;

	for (aa=a[DB_serial]; *aa == '0'; aa++);
	for (bb=b[DB_serial]; *bb == '0'; bb++);
	return(strcmp(aa,bb));
	}

static unsigned long index_name_hash(const char **a)
	{ return(lh_strhash(a[DB_name])); }

static int index_name_qual(char **a)
	{ return(a[0][0] == 'V'); }

static int index_name_cmp(const char **a, const char **b)
	{ return(strcmp(a[DB_name],
	     b[DB_name])); }

static BIGNUM *load_serial(char *serialfile)
	{
	BIO *in=NULL;
	BIGNUM *ret=NULL;
	MS_STATIC char buf[1024];
	ASN1_INTEGER *ai=NULL;

	if ((in=BIO_new(BIO_s_file())) == NULL)
		{
		ERR_print_errors(bio_err);
		goto err;
		}

	if (BIO_read_filename(in,serialfile) <= 0)
		{
		perror(serialfile);
		goto err;
		}
	ai=ASN1_INTEGER_new();
	if (ai == NULL) goto err;
	if (!a2i_ASN1_INTEGER(in,ai,buf,1024))
		{
		BIO_printf(bio_err,"unable to load number from %s\n",
			serialfile);
		goto err;
		}
	ret=ASN1_INTEGER_to_BN(ai,NULL);
	if (ret == NULL)
		{
		BIO_printf(bio_err,"error converting number from bin to BIGNUM\n");
		goto err;
		}
err:
	if (in != NULL) BIO_free(in);
	if (ai != NULL) ASN1_INTEGER_free(ai);
	return(ret);
	}

static int save_serial(char *serialfile, BIGNUM *serial)
	{
	BIO *out;
	int ret=0;
	ASN1_INTEGER *ai=NULL;

	out=BIO_new(BIO_s_file());
	if (out == NULL)
		{
		ERR_print_errors(bio_err);
		goto err;
		}
	if (BIO_write_filename(out,serialfile) <= 0)
		{
		perror(serialfile);
		goto err;
		}

	if ((ai=BN_to_ASN1_INTEGER(serial,NULL)) == NULL)
		{
		BIO_printf(bio_err,"error converting serial to ASN.1 format\n");
		goto err;
		}
	i2a_ASN1_INTEGER(out,ai);
	BIO_puts(out,"\n");
	ret=1;
err:
	if (out != NULL) BIO_free_all(out);
	if (ai != NULL) ASN1_INTEGER_free(ai);
	return(ret);
	}

d1522 1
a1522 1
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, TXT_DB *db,
d1584 1
a1584 1
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, TXT_DB *db,
d1638 1
a1638 1
	     STACK_OF(CONF_VALUE) *policy, TXT_DB *db, BIGNUM *serial, char *subj,
d1656 1
a1656 1
	char *row[DB_NUMBER],**rrow,**irow=NULL;
d1893 1
a1893 2
	rrow=TXT_DB_get_by_index(db,DB_name,row);
	if (rrow != NULL)
d1895 7
a1901 2
		BIO_printf(bio_err,"ERROR:There is already a certificate for %s\n",
			row[DB_name]);
d1903 1
a1903 1
	else
d1905 1
a1905 1
		rrow=TXT_DB_get_by_index(db,DB_serial,row);
d2112 1
a2112 1
	strlcpy(row[DB_file],"unknown",8);
d2129 1
a2129 1
	if (!TXT_DB_insert(db,irow))
d2132 1
a2132 1
		BIO_printf(bio_err,"TXT_DB error number %ld\n",db->error);
d2183 1
a2183 1
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, TXT_DB *db,
d2362 1
a2362 1
static int do_revoke(X509 *x509, TXT_DB *db, int type, char *value)
d2387 1
a2387 1
	rrow=TXT_DB_get_by_index(db,DB_serial,row);
d2390 1
a2390 1
		BIO_printf(bio_err,"Adding Entry to DB for %s\n", row[DB_name]);
d2413 1
a2413 1
		strlcpy(row[DB_file],"unknown",8);
d2430 1
a2430 1
		if (!TXT_DB_insert(db,irow))
d2433 1
a2433 1
			BIO_printf(bio_err,"TXT_DB error number %ld\n",db->error);
d2478 1
a2478 1
static int get_certificate_status(const char *serial, TXT_DB *db)
d2519 1
a2519 1
	rrow=TXT_DB_get_by_index(db,DB_serial,row);
d2566 1
a2566 1
static int do_updatedb (TXT_DB *db)
d2592 1
a2592 1
	for (i = 0; i < sk_num(db->data); i++)
d2594 1
a2594 1
		rrow = (char **) sk_value(db->data, i);
d2737 1
a2737 1
	strlcpy(str, (char *)revtm->data, i);
d2740 2
a2741 2
		strlcat(str, ",", i);
		strlcat(str, reason, i);
d2745 2
a2746 2
		strlcat(str, ",", i);
		strlcat(str, other, i);
a3079 14
	}

int make_serial_index(TXT_DB *db)
	{
	if (!TXT_DB_create_index(db, DB_serial, NULL,
				LHASH_HASH_FN(index_serial_hash),
				LHASH_COMP_FN(index_serial_cmp)))
		{
		BIO_printf(bio_err,
		  "error creating serial number index:(%ld,%ld,%ld)\n",
		  			db->error,db->arg1,db->arg2);
			return 0;
		}
	return 1;
@


1.14
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d2176 1
a2176 1
		BIO_printf(bio_err,"Type	  :%s\n",p);;
@


1.13
log
@string cleaning; ok tedu
@
text
@a66 1
#include "apps.h"
d96 1
a96 1
#  elif !defined(OPENSSL_SYS_VXWORKS)
d101 2
d199 1
d201 1
d338 1
d340 2
d544 1
d550 1
d571 3
a573 1
        e = setup_engine(bio_err, engine, 0);
d576 1
d581 3
a583 1
		/* We will just use 'buf[0]' as a temporary buffer.  */
d585 3
a587 2
		strncpy(buf[0],X509_get_default_cert_area(),
			sizeof(buf[0])-1-sizeof(CONFIG_FILE));
d589 4
a592 4
		strncpy(buf[0],X509_get_default_cert_area(),
			sizeof(buf[0])-2-sizeof(CONFIG_FILE));
		buf[0][sizeof(buf[0])-2-sizeof(CONFIG_FILE)]='\0';
		strlcat(buf[0],"/",sizeof(buf[0]));
d594 2
a595 2
		strlcat(buf[0],CONFIG_FILE,sizeof(buf[0]));
		configfile=buf[0];
d610 5
d723 1
a723 1
	if (key) memset(key,0,strlen(key));
d1180 8
a1187 3
			if ((f=BN_bn2hex(serial)) == NULL) goto err;
			BIO_printf(bio_err,"next serial number is %s\n",f);
			OPENSSL_free(f);
d1307 7
a1313 2
			strncpy(buf[0],serialfile,BSIZE-4);
			buf[0][BSIZE-4]='\0';
d1323 1
a1323 2
			strncpy(buf[1],dbfile,BSIZE-4);
			buf[1][BSIZE-4]='\0';
d1353 7
a1359 2
			strncpy(buf[2],outdir,BSIZE-(j*2)-6);
			buf[2][BSIZE-(j*2)-6]='\0';
d1597 7
a1603 2
			strncpy(buf[0],dbfile,BSIZE-4);
			buf[0][BSIZE-4]='\0';
d1647 2
d1654 2
a1655 1
	sk_X509_pop_free(cert_sk,X509_free);
d1659 1
a1659 1
	if (free_key)
d1669 1
a1669 1
	EXIT(ret);
d1734 1
a1734 1
		BIO_printf(bio_err,"error converting number from bin to BIGNUM");
d2137 4
a2140 1
	row[DB_serial]=BN_bn2hex(serial);
d2203 1
a2203 1
	if (!X509_set_version(x509,2)) goto err;
d2624 4
a2627 1
	row[DB_serial]=BN_bn2hex(bn);
d3096 1
a3096 1
	{
d3100 1
a3100 1
		{
d3102 1
d3106 1
a3106 1
				{
d3109 1
d3112 1
a3112 1
			{
d3116 1
a3116 1
			}
d3119 1
a3119 1
		}
d3121 1
a3121 1
		{
d3124 1
a3124 1
		}
d3127 1
a3127 1
		{
d3129 1
d3133 1
a3133 1
				{
d3136 1
d3139 1
a3139 1
			{
d3142 1
a3142 1
			}
d3145 1
a3145 1
		}
d3148 1
a3148 1
	}
@


1.12
log
@more strcpy & sprintf murder; ho ok
@
text
@d578 1
a578 1
		strcat(buf[0],"/");
d580 1
a580 1
		strcat(buf[0],CONFIG_FILE);
d1289 1
a1289 1
			strcat(buf[0],".new");
d1300 1
a1300 1
			strcat(buf[1],".new");
d1318 1
a1318 1
			unsigned char *n;
d1329 1
a1329 1
			strcat(buf[2],"/");
d1332 1
a1332 1
			n=(unsigned char *)&(buf[2][strlen(buf[2])]);
d1337 5
a1341 1
					sprintf((char *)n,"%02X",(unsigned char)*(p++));
d1373 1
a1373 1
			strcat(buf[2],".old");
d1402 1
a1402 1
			strcat(buf[2],".old");
d1567 1
a1567 1
			strcat(buf[0],".new");
d1586 1
a1586 1
			strcat(buf[1],".old");
d2318 1
a2318 1
	strcpy(row[DB_file],"unknown");
d2616 1
a2616 1
		strcpy(row[DB_file],"unknown");
@


1.11
log
@typo; torh@@bogus.net
@
text
@d2936 1
a2936 1
	strcpy(str, (char *)revtm->data);
d2939 2
a2940 2
		strcat(str, ",");
		strcat(str, reason);
d2944 2
a2945 2
		strcat(str, ",");
		strcat(str, other);
@


1.10
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d1019 1
a1019 1
			BIO_printf(bio_err, "Succesfully loaded extensions file %s\n", extfile);
@


1.9
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d702 1
a702 1
	pkey = load_key(bio_err, keyfile, keyform, key, e, 
a2091 1
	row[DB_name]=X509_NAME_oneline(dn_subject,NULL,0);
d2093 1
a2093 1
	if ((row[DB_name] == NULL) || (row[DB_serial] == NULL))
d2306 1
a2306 1
	/* row[DB_name] done already */
d2309 1
a2309 1
		(row[DB_file] == NULL))
@


1.8
log
@Merge openssl-0.9.7-stable-SNAP-20020519
@
text
@d83 5
a87 1
#include <strings.h>
d1457 1
a1457 1
			BIO_printf(bio_err,"cannot lookup how long until the next CRL is issuer\n");
d1463 1
a1463 1
		if (!X509_CRL_set_issuer_name(crl, X509_get_issuer_name(x509))) goto err;
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@a240 1
static X509_NAME *do_subject(char *subject);
d1876 1
a1876 1
		X509_NAME *n = do_subject(subj);
d3014 1
a3014 1
static X509_NAME *do_subject(char *subject)
d3016 2
a3017 2
	size_t buflen = strlen (subject)+1; /* to copy the types and values into. due to escaping, the copy can only become shorter */
	char *buf = malloc (buflen);
d3019 2
a3020 2
	char **ne_types = malloc (max_ne * sizeof (char *));
	char **ne_values = malloc (max_ne * sizeof (char *));
d3031 1
a3031 1
		goto error0;
d3037 1
a3037 1
		goto error0;
d3053 1
a3053 1
					goto error0;
d3067 1
a3067 1
			goto error0;
d3078 1
a3078 1
					goto error0;
a3082 1
				*bp++ = '\0';
d3093 1
a3093 1
		goto error0;
d3109 2
a3110 2
		if (!X509_NAME_add_entry_by_NID(n, nid, MBSTRING_ASC, (unsigned char*)ne_values[i], -1,-1,0))
			goto error1;
d3113 3
a3115 3
	free (ne_values);
	free (ne_types);
	free (buf);
d3118 1
a3118 1
error1:
d3120 6
a3125 4
error0:
	free (ne_values);
	free (ne_types);
	free (buf);
a3127 1

@


1.6
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d64 1
d77 1
d79 6
a84 1
#include <openssl/engine.h>
d87 1
a87 1
#  ifdef VMS
d93 1
a93 1
#  else
d129 1
d135 3
d153 8
d175 2
a176 1
" -keyfile arg    - PEM private key file\n",
d186 1
d190 1
d192 1
d195 2
d207 3
a209 3
static unsigned long index_serial_hash(char **a);
static int index_serial_cmp(char **a, char **b);
static unsigned long index_name_hash(char **a);
d211 1
a211 1
static int index_name_cmp(char **a,char **b);
d216 4
a219 2
		   BIGNUM *serial, char *startdate,char *enddate, int days,
		   int batch, char *ext_sect, LHASH *conf,int verbose);
d222 5
a226 3
			TXT_DB *db, BIGNUM *serial,char *startdate,
			char *enddate, int days, int batch, char *ext_sect,
			LHASH *conf,int verbose);
d229 4
a232 3
			 TXT_DB *db, BIGNUM *serial,char *startdate,
			 char *enddate, int days, char *ext_sect,LHASH *conf,
				int verbose);
d236 9
a244 4
	STACK_OF(CONF_VALUE) *policy, TXT_DB *db, BIGNUM *serial,
	char *startdate, char *enddate, int days, int batch, int verbose,
	X509_REQ *req, char *ext_sect, LHASH *conf);
static int do_revoke(X509 *x509, TXT_DB *db);
d246 5
a250 1
static LHASH *conf=NULL;
d256 6
d268 1
d273 1
d278 1
d287 1
d291 1
d298 3
d302 2
d307 1
a307 1
	int days=0;
d310 3
a318 1
	X509_CRL_INFO *ci=NULL;
d320 2
a327 1
	BIO *hex=NULL;
d368 6
d404 5
d446 2
d492 14
d511 24
d554 1
a554 1
			BIO_printf(bio_err,*pp);
d560 1
a560 17
	if (engine != NULL)
		{
		if((e = ENGINE_by_id(engine)) == NULL)
			{
			BIO_printf(bio_err,"invalid engine \"%s\"\n",
				engine);
			goto err;
			}
		if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
			{
			BIO_printf(bio_err,"can't use that engine\n");
			goto err;
			}
		BIO_printf(bio_err,"engine \"%s\" set.\n", engine);
		/* Free our "structural" reference. */
		ENGINE_free(e);
		}
d568 1
a568 1
#ifdef VMS
d574 1
d582 2
a583 1
	if ((conf=CONF_load(NULL,configfile,&errorline)) == NULL)
d594 3
d600 1
a600 1
		section=CONF_get_string(conf,BASE_SECTION,ENV_DEFAULT_CA);
d610 3
a612 1
		p=CONF_get_string(conf,NULL,"oid_file");
d632 1
a632 1
		if(!add_oid_section(bio_err,conf)) 
d639 3
a641 1
	randfile = CONF_get_string(conf, BASE_SECTION, "RANDFILE");
d655 28
a682 1
	/* we definitely need an public key, so lets get it */
d684 1
a684 1
	if ((keyfile == NULL) && ((keyfile=CONF_get_string(conf,
d690 1
a690 1
	if(!key && !app_passwd(bio_err, passargin, NULL, &key, NULL))
d692 6
a697 8
		BIO_printf(bio_err,"Error getting password\n");
		goto err;
		}
	if (BIO_read_filename(in,keyfile) <= 0)
		{
		perror(keyfile);
		BIO_printf(bio_err,"trying to load CA private key\n");
		goto err;
d699 3
a701 2
		pkey=PEM_read_bio_PrivateKey(in,NULL,NULL,key);
		if(key) memset(key,0,strlen(key));
d704 1
a704 1
		BIO_printf(bio_err,"unable to load CA private key\n");
d710 1
a710 1
	if ((certfile == NULL) && ((certfile=CONF_get_string(conf,
d716 2
a717 7
        if (BIO_read_filename(in,certfile) <= 0)
		{
		perror(certfile);
		BIO_printf(bio_err,"trying to load CA certificate\n");
		goto err;
		}
	x509=PEM_read_bio_X509(in,NULL,NULL,NULL);
a718 2
		{
		BIO_printf(bio_err,"unable to load CA certificate\n");
a719 1
		}
d727 3
a729 1
	f=CONF_get_string(conf,BASE_SECTION,ENV_PRESERVE);
d732 3
a734 1
	f=CONF_get_string(conf,BASE_SECTION,ENV_MSIE_HACK);
d738 41
d785 1
a785 1
		if ((outdir=CONF_get_string(conf,section,ENV_NEW_CERTS_DIR))
d791 2
a792 1
#ifndef VMS /* outdir is a directory spec, but access() for VMS demands a
d801 1
a801 1
            */
d828 1
a828 1
	if ((dbfile=CONF_get_string(conf,section,ENV_DATABASE)) == NULL)
d853 1
a853 1
			!check_time_format(pp[DB_rev_date]))
d855 1
a855 2
			BIO_printf(bio_err,"entry %d: invalid revocation date\n",
				i+1);
d865 5
d890 1
a890 1
#ifdef VMS
d902 1
a902 4
	if (!TXT_DB_create_index(db,DB_serial,NULL,index_serial_hash,
		index_serial_cmp))
		{
		BIO_printf(bio_err,"error creating serial number index:(%ld,%ld,%ld)\n",db->error,db->arg1,db->arg2);
a903 1
		}
d905 3
a907 2
	if (!TXT_DB_create_index(db,DB_name,index_name_qual,index_name_hash,
		index_name_cmp))
d915 109
a1027 1

d1037 1
a1037 1
#ifdef VMS
d1048 1
a1048 1
		if ((md == NULL) && ((md=CONF_get_string(conf,
d1054 6
d1068 1
a1068 1
		if ((policy == NULL) && ((policy=CONF_get_string(conf,
d1077 1
a1077 1
		if ((serialfile=CONF_get_string(conf,section,ENV_SERIAL))
d1083 23
a1105 10
		if(!extensions)
			extensions=CONF_get_string(conf,section,ENV_EXTENSIONS);
		if(extensions) {
			/* Check syntax of file */
			X509V3_CTX ctx;
			X509V3_set_ctx_test(&ctx);
			X509V3_set_conf_lhash(&ctx, conf);
			if(!X509V3_EXT_add_conf(conf, &ctx, extensions, NULL)) {
				BIO_printf(bio_err,
				 "Error Loading extension section %s\n",
d1107 4
a1110 2
				ret = 1;
				goto err;
a1111 1
		}
d1115 1
a1115 1
			startdate=CONF_get_string(conf,section,
d1117 2
d1129 1
a1129 1
			enddate=CONF_get_string(conf,section,
d1131 2
d1142 2
a1143 2
			days=(int)CONF_get_number(conf,section,
				ENV_DEFAULT_DAYS);
d1163 1
a1163 1
		if ((attribs=CONF_get_section(conf,policy)) == NULL)
d1178 2
a1179 2
				serial,startdate,enddate, days,extensions,conf,
				verbose);
d1202 3
a1204 2
				db,serial,startdate,enddate,days,batch,
				extensions,conf,verbose);
d1222 3
a1224 2
				serial,startdate,enddate,days,batch,
				extensions,conf,verbose);
d1242 3
a1244 2
				serial,startdate,enddate,days,batch,
				extensions,conf,verbose);
d1281 1
d1283 1
a1283 1
#ifdef VMS
d1292 1
d1294 1
a1294 1
#ifdef VMS
d1323 1
d1325 1
a1325 1
#ifndef VMS
d1361 1
d1363 1
a1363 1
#ifdef VMS
d1390 1
d1392 1
a1392 1
#ifdef VMS
d1420 9
a1428 2
		if(!crl_ext) crl_ext=CONF_get_string(conf,section,ENV_CRLEXT);
		if(crl_ext) {
d1432 3
a1434 2
			X509V3_set_conf_lhash(&ctx, conf);
			if(!X509V3_EXT_add_conf(conf, &ctx, crl_ext, NULL)) {
d1440 1
a1441 2
		}
		if ((hex=BIO_new(BIO_s_mem())) == NULL) goto err;
d1445 6
a1450 4
			crldays=CONF_get_number(conf,section,
				ENV_DEFAULT_CRL_DAYS);
			crlhours=CONF_get_number(conf,section,
				ENV_DEFAULT_CRL_HOURS);
d1460 10
a1469 9
		ci=crl->crl;
		X509_NAME_free(ci->issuer);
		ci->issuer=X509_NAME_dup(x509->cert_info->subject);
		if (ci->issuer == NULL) goto err;

		X509_gmtime_adj(ci->lastUpdate,0);
		if (ci->nextUpdate == NULL)
			ci->nextUpdate=ASN1_UTCTIME_new();
		X509_gmtime_adj(ci->nextUpdate,(crldays*24+crlhours)*60*60);
d1477 9
a1485 8
				ASN1_STRING_set((ASN1_STRING *)
					r->revocationDate,
					(unsigned char *)pp[DB_rev_date],
					strlen(pp[DB_rev_date]));
				/* strcpy(r->revocationDate,pp[DB_rev_date]);*/

				(void)BIO_reset(hex);
				if (!BIO_puts(hex,pp[DB_serial]))
d1487 3
a1489 4
				if (!a2i_ASN1_INTEGER(hex,r->serialNumber,
					buf[0],BSIZE)) goto err;

				sk_X509_REVOKED_push(ci->revoked,r);
d1492 1
d1495 1
a1495 6
		sk_X509_REVOKED_sort(ci->revoked);
		for (i=0; i<sk_X509_REVOKED_num(ci->revoked); i++)
			{
			r=sk_X509_REVOKED_value(ci->revoked,i);
			r->sequence=i;
			}
d1508 5
a1512 5
		    {
#ifndef NO_DSA
		    if (pkey->type == EVP_PKEY_DSA) 
			dgst=EVP_dss1();
		    else
d1514 2
a1515 2
			dgst=EVP_md5();
		    }
d1519 5
a1523 7
		if(crl_ext) {
		    X509V3_CTX crlctx;
		    if (ci->version == NULL)
		    if ((ci->version=ASN1_INTEGER_new()) == NULL) goto err;
		    ASN1_INTEGER_set(ci->version,1); /* version 2 CRL */
		    X509V3_set_ctx(&crlctx, x509, NULL, NULL, crl, 0);
		    X509V3_set_conf_lhash(&crlctx, conf);
d1525 8
a1532 3
		    if(!X509V3_EXT_CRL_add_conf(conf, &crlctx,
						 crl_ext, crl)) goto err;
		}
d1549 2
a1550 7
			if (BIO_read_filename(in,infile) <= 0)
				{
				perror(infile);
				BIO_printf(bio_err,"error trying to load '%s' certificate\n",infile);
				goto err;
				}
			revcert=PEM_read_bio_X509(in,NULL,NULL,NULL);
a1551 2
				{
				BIO_printf(bio_err,"unable to load '%s' certificate\n",infile);
d1553 1
a1553 2
				}
			j=do_revoke(revcert,db);
d1558 2
a1559 1
#ifndef VMS
d1572 4
d1577 2
a1578 1
#ifndef VMS
a1601 1
	BIO_free(hex);
d1605 1
a1605 1
	BIO_free(in);
d1611 2
d1618 1
a1618 1
	CONF_free(conf);
d1620 1
d1629 1
a1629 1
static unsigned long index_serial_hash(char **a)
d1631 1
a1631 1
	char *n;
d1638 1
a1638 1
static int index_serial_cmp(char **a, char **b)
d1640 1
a1640 1
	char *aa,*bb;
d1647 1
a1647 1
static unsigned long index_name_hash(char **a)
d1653 1
a1653 1
static int index_name_cmp(char **a, char **b)
d1729 4
a1732 2
	     BIGNUM *serial, char *startdate, char *enddate, int days,
	     int batch, char *ext_sect, LHASH *lconf, int verbose)
d1779 3
a1781 2
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,startdate, enddate,
		days,batch,verbose,req,ext_sect,lconf);
d1791 4
a1794 2
	     BIGNUM *serial, char *startdate, char *enddate, int days,
	     int batch, char *ext_sect, LHASH *lconf, int verbose)
a1797 1
	BIO *in=NULL;
d1801 1
a1801 10
	in=BIO_new(BIO_s_file());

	if (BIO_read_filename(in,infile) <= 0)
		{
		perror(infile);
		goto err;
		}
	if ((req=PEM_read_bio_X509(in,NULL,NULL,NULL)) == NULL)
		{
		BIO_printf(bio_err,"Error reading self signed certificate in %s\n",infile);
a1802 1
		}
d1833 3
a1835 2
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,startdate,enddate,days,
		batch,verbose,rreq,ext_sect,lconf);
a1839 1
	if (in != NULL) BIO_free(in);
d1844 5
a1848 3
	     STACK_OF(CONF_VALUE) *policy, TXT_DB *db, BIGNUM *serial,
	     char *startdate, char *enddate, int days, int batch, int verbose,
	     X509_REQ *req, char *ext_sect, LHASH *lconf)
d1850 1
a1850 1
	X509_NAME *name=NULL,*CAname=NULL,*subject=NULL;
d1863 1
a1863 1
	char buf[25],*pbuf;
d1875 17
a1891 1
	BIO_printf(bio_err,"The Subjects Distinguished Name is as follows\n");
d1895 2
a1896 1
		ne=(X509_NAME_ENTRY *)X509_NAME_get_entry(name,i);
a1897 8
		j=i2a_ASN1_OBJECT(bio_err,obj);
		str=X509_NAME_ENTRY_get_data(ne);
		pbuf=buf;
		for (j=22-j; j>0; j--)
			*(pbuf++)=' ';
		*(pbuf++)=':';
		*(pbuf++)='\0';
		BIO_puts(bio_err,buf);
d1916 3
a1918 10
		if (str->type == V_ASN1_PRINTABLESTRING)
			BIO_printf(bio_err,"PRINTABLE:'");
		else if (str->type == V_ASN1_T61STRING)
			BIO_printf(bio_err,"T61STRING:'");
		else if (str->type == V_ASN1_IA5STRING)
			BIO_printf(bio_err,"IA5STRING:'");
		else if (str->type == V_ASN1_UNIVERSALSTRING)
			BIO_printf(bio_err,"UNIVERSALSTRING:'");
		else
			BIO_printf(bio_err,"ASN.1 %2d:'",str->type);
d1927 1
a1927 5
		j=ASN1_PRINTABLE_type(str->data,str->length);
		if (	((j == V_ASN1_T61STRING) &&
			 (str->type != V_ASN1_T61STRING)) ||
			((j == V_ASN1_IA5STRING) &&
			 (str->type == V_ASN1_PRINTABLESTRING)))
d1929 9
a1937 2
			BIO_printf(bio_err,"\nThe string contains characters that are illegal for the ASN.1 type\n");
			goto err;
d1939 3
a1941 14
			
		p=(char *)str->data;
		for (j=str->length; j>0; j--)
			{
			if ((*p >= ' ') && (*p <= '~'))
				BIO_printf(bio_err,"%c",*p);
			else if (*p & 0x80)
				BIO_printf(bio_err,"\\0x%02X",*p);
			else if ((unsigned char)*p == 0xf7)
				BIO_printf(bio_err,"^?");
			else	BIO_printf(bio_err,"^%c",*p+'@@');
			p++;
			}
		BIO_printf(bio_err,"'\n");
d2056 2
a2057 1
		subject=X509_NAME_dup(X509_REQ_get_subject_name(req));
d2064 26
a2089 1
	row[DB_name]=X509_NAME_oneline(subject,NULL,0);
a2160 1
	BIO_printf(bio_err,"Certificate is to be certified until ");
a2168 4
	ASN1_UTCTIME_print(bio_err,X509_get_notAfter(ret));
	if(days) BIO_printf(bio_err," (%d days)",days);
	BIO_printf(bio_err, "\n");

d2193 1
a2194 1
		X509V3_set_conf_lhash(&ctx, lconf);
d2196 34
a2229 1
		if(!X509V3_EXT_add_conf(lconf, &ctx, ext_sect, ret)) goto err;
d2231 3
d2236 8
d2245 2
a2246 1
	if (!batch)
d2248 19
d2280 1
a2280 1
#ifndef NO_DSA
d2344 2
d2378 1
a2378 1
	if(!notext)X509_print(bp,x);
d2384 3
a2386 2
	     BIGNUM *serial, char *startdate, char *enddate, int days,
	     char *ext_sect, LHASH *lconf, int verbose)
d2452 7
a2458 6
		for(buf = cv->name; *buf ; buf++)
			if ((*buf == ':') || (*buf == ',') || (*buf == '.')) {
					buf++;
					if(*buf) type = buf;
					break;
		}
d2476 5
d2525 3
a2527 2
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,startdate,enddate,
		   days,1,verbose,req,ext_sect,lconf);
d2562 3
a2564 3
static int do_revoke(X509 *x509, TXT_DB *db)
{
	ASN1_UTCTIME *tm=NULL, *revtm=NULL;
d2566 1
d2635 1
a2635 1
		ok = do_revoke(x509,db);
d2640 1
a2640 1
	else if (index_name_cmp(row,rrow))
d2655 6
a2660 2
		revtm = ASN1_UTCTIME_new();
		revtm=X509_gmtime_adj(revtm,0);
d2663 1
a2663 4
		rrow[DB_rev_date]=(char *)OPENSSL_malloc(revtm->length+1);
		memcpy(rrow[DB_rev_date],revtm->data,revtm->length);
		rrow[DB_rev_date][revtm->length]='\0';
		ASN1_UTCTIME_free(revtm);
d2673 454
d3129 159
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d1250 1
d1252 3
d1264 1
d1266 3
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d77 1
d171 1
a180 1
static int add_oid_section(LHASH *conf);
d221 2
a222 1
	char *key=NULL;
d268 1
a268 1
	STACK *cert_sk=NULL;
d274 1
d340 5
d426 5
d451 18
d532 1
a532 1
		if(!add_oid_section(conf)) 
d561 5
d720 6
d760 1
d762 7
d861 1
a861 1
			Free(f);
d870 1
a870 1
		if ((cert_sk=sk_new_null()) == NULL)
d872 1
a872 1
			BIO_printf(bio_err,"Malloc failure\n");
d887 1
a887 1
				if (!sk_push(cert_sk,(char *)x))
d889 1
a889 1
					BIO_printf(bio_err,"Malloc failure\n");
d911 1
a911 1
				if (!sk_push(cert_sk,(char *)x))
d913 1
a913 1
					BIO_printf(bio_err,"Malloc failure\n");
d930 1
a930 1
				if (!sk_push(cert_sk,(char *)x))
d932 1
a932 1
					BIO_printf(bio_err,"Malloc failure\n");
d949 1
a949 1
				if (!sk_push(cert_sk,(char *)x))
d951 1
a951 1
					BIO_printf(bio_err,"Malloc failure\n");
d960 1
a960 1
		if (sk_num(cert_sk) > 0)
d976 1
a976 1
			BIO_printf(bio_err,"Write out database with %d new entries\n",sk_num(cert_sk));
d1008 1
a1008 1
		for (i=0; i<sk_num(cert_sk); i++)
d1013 1
a1013 1
			x=(X509 *)sk_value(cert_sk,i);
d1052 1
a1052 1
		if (sk_num(cert_sk))
d1064 1
a1064 1
			BIO_free(out);
d1281 3
a1283 3
	BIO_free(Cout);
	BIO_free(Sout);
	BIO_free(out);
d1286 1
a1286 1
	sk_pop_free(cert_sk,X509_free);
d1398 1
a1398 1
	if (out != NULL) BIO_free(out);
d1633 1
a1633 1
		BIO_printf(bio_err,"Malloc failure\n");
d1731 1
a1731 1
					BIO_printf(bio_err,"Malloc failure\n");
d1753 1
a1753 1
		BIO_printf(bio_err,"Malloc failure\n");
d1894 1
a1894 1
	row[DB_type]=(char *)Malloc(2);
d1897 1
a1897 1
	row[DB_exp_date]=(char *)Malloc(tm->length+1);
d1904 1
a1904 1
	row[DB_file]=(char *)Malloc(8);
d1910 1
a1910 1
		BIO_printf(bio_err,"Malloc failure\n");
d1917 1
a1917 1
	if ((irow=(char **)Malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)
d1919 1
a1919 1
		BIO_printf(bio_err,"Malloc failure\n");
d1939 1
a1939 1
		if (row[i] != NULL) Free(row[i]);
a2152 22
static int add_oid_section(LHASH *hconf)
{	
	char *p;
	STACK_OF(CONF_VALUE) *sktmp;
	CONF_VALUE *cnf;
	int i;
	if(!(p=CONF_get_string(hconf,NULL,"oid_section"))) return 1;
	if(!(sktmp = CONF_get_section(hconf, p))) {
		BIO_printf(bio_err, "problem loading oid section %s\n", p);
		return 0;
	}
	for(i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {
		cnf = sk_CONF_VALUE_value(sktmp, i);
		if(OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {
			BIO_printf(bio_err, "problem creating object %s=%s\n",
							 cnf->name, cnf->value);
			return 0;
		}
	}
	return 1;
}

d2168 1
a2168 1
		BIO_printf(bio_err,"Malloc failure\n");
d2180 1
a2180 1
		row[DB_type]=(char *)Malloc(2);
d2183 1
a2183 1
		row[DB_exp_date]=(char *)Malloc(tm->length+1);
d2190 1
a2190 1
		row[DB_file]=(char *)Malloc(8);
d2197 1
a2197 1
			BIO_printf(bio_err,"Malloc failure\n");
d2204 1
a2204 1
		if ((irow=(char **)Malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)
d2206 1
a2206 1
			BIO_printf(bio_err,"Malloc failure\n");
d2249 1
a2249 1
		rrow[DB_rev_date]=(char *)Malloc(revtm->length+1);
d2259 1
a2259 1
			Free(row[i]);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d1665 1
a1665 1
					BIO_printf(bio_err,"The %s field needed to be the same in the\nCA certificate (%s) and the request (%s)\n",cv->name,((str == NULL)?"NULL":(char *)str->data),((str2 == NULL)?"NULL":(char *)str2->data));
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d150 2
d168 2
a180 1
static int MS_CALLBACK key_callback(char *buf,int len,int verify,void *u);
d203 1
a203 1
static void write_new_certificate(BIO *bp, X509 *x, int output_der);
d210 1
a210 2
static LHASH *conf;
static char *key=NULL;
d216 2
d220 1
d252 1
d271 1
d281 3
a283 1
	X509V3_add_standard_extensions();
d286 1
d363 2
d408 10
d501 2
a502 2
		}
		if(!add_oid_section(conf)) {
d505 1
d508 3
d522 1
a522 1
	/* we definitly need an public key, so lets get it */
d536 2
a537 7
	if (key == NULL)
		pkey=PEM_read_bio_PrivateKey(in,NULL,NULL,NULL);
	else
		{
		pkey=PEM_read_bio_PrivateKey(in,NULL,key_callback,NULL);
		memset(key,0,strlen(key));
		}
d590 10
a599 4
#ifdef VMS
		/* For technical reasons, VMS misbehaves with X_OK */
		if (access(outdir,R_OK|W_OK) != 0)
#else
a600 1
#endif
d602 1
a602 1
			BIO_printf(bio_err,"I am unable to acces the %s directory\n",outdir);
d613 1
d620 2
d687 1
a687 1
		BIO_printf(bio_err,"generating indexs\n");
d752 2
a753 2

		extensions=CONF_get_string(conf,section,ENV_EXTENSIONS);
d998 2
a999 2
			write_new_certificate(Cout,x, 0);
			write_new_certificate(Sout,x, output_der);
d1019 1
a1019 1
				BIO_printf(bio_err,"unabel to rename %s to %s\n",
d1026 1
a1026 1
				BIO_printf(bio_err,"unabel to rename %s to %s\n",
d1043 1
a1043 1
				BIO_printf(bio_err,"unabel to rename %s to %s\n",
d1050 1
a1050 1
				BIO_printf(bio_err,"unabel to rename %s to %s\n",
d1063 1
a1063 1
		crl_ext=CONF_get_string(conf,section,ENV_CRLEXT);
a1174 7
		in=BIO_new(BIO_s_file());
		out=BIO_new(BIO_s_file());
		if ((in == NULL) || (out == NULL))
			{
			ERR_print_errors(bio_err);
			goto err;
			}
d1182 1
d1189 2
a1190 2
			x509=PEM_read_bio_X509(in,NULL,NULL,NULL);
			if (x509 == NULL)
d1195 3
a1197 1
			j=do_revoke(x509,db);
a1208 4
			BIO_free(in);
			BIO_free(out);
			in=NULL;
			out=NULL;
d1239 1
a1245 1
	X509V3_EXT_cleanup();
a1254 11
static int MS_CALLBACK key_callback(char *buf, int len, int verify, void *u)
	{
	int i;

	if (key == NULL) return(0);
	i=strlen(key);
	i=(i > len)?len:i;
	memcpy(buf,key,i);
	return(i);
	}

d1677 1
a1677 2
				if (!X509_NAME_add_entry(subject,push,
					X509_NAME_entry_count(subject),0))
d1697 1
a1697 1
		BIO_printf(bio_err,"The subject name apears to be ok, checking data base for clashes\n");
d1754 1
a1754 1
	/* We are now totaly happy, lets make and sign the certificate */
d1801 1
a1801 1
		 * be any I belive */
d1895 2
d1907 1
a1907 1
static void write_new_certificate(BIO *bp, X509 *x, int output_der)
a1908 2
	char *f;
	char buf[256];
d1915 2
a1916 1

d1926 2
a1927 2
	X509_print(bp,x);
	BIO_puts(bp,"\n");
a1928 1
	BIO_puts(bp,"\n");
a1940 1
	unsigned char *spki_der = NULL,*p;
d1997 10
a2007 1

d2012 1
a2012 19
				spki_der=(unsigned char *)Malloc(
					strlen(cv->value)+1);
				if (spki_der == NULL)
					{
					BIO_printf(bio_err,"Malloc failure\n");
					goto err;
					}
				j = EVP_DecodeBlock(spki_der, (unsigned char *)cv->value,
					strlen(cv->value));
				if (j <= 0)
					{
					BIO_printf(bio_err, "Can't b64 decode SPKAC structure\n");
					goto err;
					}

				p=spki_der;
				spki = d2i_NETSCAPE_SPKI(&spki, &p, j);
				Free(spki_der);
				spki_der = NULL;
d2036 1
a2036 2
		if (!X509_NAME_add_entry(n,ne,X509_NAME_entry_count(n),0))
			goto err;
d2051 1
a2051 1
	if ((pktmp=X509_PUBKEY_get(spki->spkac->pubkey)) == NULL)
a2071 1
	if (spki_der != NULL) Free(spki_der);
d2127 1
a2127 1
	ASN1_UTCTIME *tm=NULL;
d2129 1
d2134 4
a2137 2
	row[DB_name]=X509_NAME_oneline(x509->cert_info->subject,NULL,0);
	row[DB_serial]=BN_bn2hex(ASN1_INTEGER_to_BN(x509->cert_info->serialNumber,NULL));
d2143 4
a2146 1
	rrow=TXT_DB_get_by_index(db,DB_name,row);
d2197 1
a2197 1
		do_revoke(x509,db);
a2198 1
		ok=1;
d2202 1
a2202 1
	else if (index_serial_cmp(row,rrow))
d2204 2
a2205 2
		BIO_printf(bio_err,"ERROR:no same serial number %s\n",
			   row[DB_serial]);
d2217 2
a2218 1
		tm=X509_gmtime_adj(tm,0);
d2221 4
a2224 3
		rrow[DB_rev_date]=(char *)Malloc(tm->length+1);
		memcpy(rrow[DB_rev_date],tm->data,tm->length);
		rrow[DB_rev_date][tm->length]='\0';
a2232 1
	ASN1_UTCTIME_free(tm);
@


1.1
log
@Initial revision
@
text
@d67 10
a76 9
#include "bio.h"
#include "err.h"
#include "bn.h"
#include "txt_db.h"
#include "evp.h"
#include "x509.h"
#include "objects.h"
#include "pem.h"
#include "conf.h"
d79 16
a94 1
#include <sys/file.h>
d101 1
a101 1
#define CONFIG_FILE "lib/ssleay.cnf"
d117 1
d124 1
d155 1
a155 1
" -cert           - The CA certificate\n",
d163 3
a165 2
" -batch	  - Don't ask questions\n",
" -msie_hack	  - msie modifications to handle all thos universal strings\n",
d175 1
a175 2
#ifndef NOPROTO
static STACK *load_extensions(char *section);
d177 1
a177 1
static int MS_CALLBACK key_callback(char *buf,int len,int verify);
d186 3
a188 2
	EVP_MD *dgst,STACK *policy,TXT_DB *db,BIGNUM *serial,char *startdate,
	int days, int batch, STACK *extensions,int verbose);
d190 4
a193 2
	EVP_MD *dgst,STACK *policy,TXT_DB *db,BIGNUM *serial,char *startdate,
	int days,int batch,STACK *extensions,int verbose);
d195 4
a198 2
	EVP_MD *dgst,STACK *policy,TXT_DB *db,BIGNUM *serial,char *startdate,
	int days,STACK *extensions,int verbose);
d201 5
a205 3
static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509, EVP_MD *dgst,
	STACK *policy, TXT_DB *db, BIGNUM *serial, char *startdate,
	int days, int batch, int verbose, X509_REQ *req, STACK *extensions);
a206 20
#else
static STACK *load_extensions();
static void lookup_fail();
static int MS_CALLBACK key_callback();
static unsigned long index_serial_hash();
static int index_serial_cmp();
static unsigned long index_name_hash();
static int index_name_qual();
static int index_name_cmp();
static int fix_data();
static BIGNUM *load_serial();
static int save_serial();
static int certify();
static int certify_cert();
static int certify_spkac();
static void write_new_certificate();
static int do_body();
static int check_time_format();
#endif

d214 1
a214 3
int MAIN(argc, argv)
int argc;
char **argv;
d223 1
d241 1
d244 1
d258 2
a259 3
	EVP_MD *dgst=NULL;
	STACK *attribs=NULL;
	STACK *extensions_sk=NULL;
d274 1
a274 1
	X509v3_add_netscape_extensions();
d302 5
d390 6
d417 2
d422 4
d429 1
d457 28
d511 1
a511 1
		pkey=PEM_read_bio_PrivateKey(in,NULL,NULL);
d514 1
a514 1
		pkey=PEM_read_bio_PrivateKey(in,NULL,key_callback);
d537 1
a537 1
	x509=PEM_read_bio_X509(in,NULL,NULL);
d544 6
d569 4
d574 1
d602 1
a602 1
        if (BIO_read_filename(in,dbfile) <= 0)
d618 1
a618 1
			BIO_printf(bio_err,"entry %d: not, revoked yet has a revokation date\n",i+1);
d624 1
a624 1
			BIO_printf(bio_err,"entry %d: invalid revokation date\n",
d724 11
a734 4
		if ((extensions=CONF_get_string(conf,section,ENV_EXTENSIONS))
			!= NULL)
			{
			if ((extensions_sk=load_extensions(extensions)) == NULL)
d737 1
d741 1
a741 1
			startdate=(char *)CONF_get_string(conf,section,
d743 17
a759 10
			if (startdate == NULL)
				startdate="today";
			else
				{
				if (!ASN1_UTCTIME_set_string(NULL,startdate))
					{
					BIO_printf(bio_err,"start date is invalid, it should be YYMMDDHHMMSS\n");
					goto err;
					}
				}
d767 1
a767 1
		if (days == 0)
d780 1
a780 1
			if ((f=BN_bn2ascii(serial)) == NULL) goto err;
d800 2
a801 1
				serial,startdate,days,extensions_sk,verbose);
d824 2
a825 2
				db,serial,startdate,days,batch,
				extensions_sk,verbose);
d843 2
a844 2
				serial,startdate,days,batch,
				extensions_sk,verbose);
d862 2
a863 2
				serial,startdate,days,batch,
				extensions_sk,verbose);
d886 1
a886 1
				BIO_flush(bio_err);
d900 4
d905 1
d910 4
d915 2
d940 2
d943 2
d977 4
d982 2
d1005 4
d1010 2
d1034 14
d1087 1
a1087 1
				BIO_reset(hex);
d1093 1
a1093 1
				sk_push(ci->revoked,(char *)r);
d1098 2
a1099 2
		sk_find(ci->revoked,NULL);
		for (i=0; i<sk_num(ci->revoked); i++)
d1101 1
a1101 1
			r=(X509_REVOKED *)sk_value(ci->revoked,i);
d1105 1
a1105 1
		/* we how have a CRL */
d1116 6
d1123 16
d1144 63
d1209 5
a1213 5
	if (hex != NULL) BIO_free(hex);
	if (Cout != NULL) BIO_free(Cout);
	if (Sout != NULL) BIO_free(Sout);
	if (out != NULL) BIO_free(out);
	if (in != NULL) BIO_free(in);
d1215 1
a1215 3
	if (cert_sk != NULL) sk_pop_free(cert_sk,X509_free);
	if (extensions_sk != NULL)
		sk_pop_free(extensions_sk,X509_EXTENSION_free);
d1218 8
a1225 7
	if (serial != NULL) BN_free(serial);
	if (db != NULL) TXT_DB_free(db);
	if (pkey != NULL) EVP_PKEY_free(pkey);
	if (x509 != NULL) X509_free(x509);
	if (crl != NULL) X509_CRL_free(crl);
	if (conf != NULL) CONF_free(conf);
	X509v3_cleanup_extensions();
d1229 1
a1229 3
static void lookup_fail(name,tag)
char *name;
char *tag;
d1234 1
a1234 3
static int MS_CALLBACK key_callback(buf,len,verify)
char *buf;
int len,verify;
d1245 1
a1245 2
static unsigned long index_serial_hash(a)
char **a;
d1254 1
a1254 3
static int index_serial_cmp(a,b)
char **a;
char **b;
d1263 1
a1263 2
static unsigned long index_name_hash(a)
char **a;
d1266 1
a1266 2
static int index_name_qual(a)
char **a;
d1269 3
a1271 4
static int index_name_cmp(a,b)
char **a;
char **b;
	{ return(strcmp(a[DB_name],b[DB_name])); }
d1273 1
a1273 2
static BIGNUM *load_serial(serialfile)
char *serialfile;
d1311 1
a1311 3
static int save_serial(serialfile,serial)
char *serialfile;
BIGNUM *serial;
d1343 4
a1346 15
static int certify(xret,infile,pkey,x509,dgst,policy,db,serial,startdate,days,
	batch,extensions,verbose)
X509 **xret;
char *infile;
EVP_PKEY *pkey;
X509 *x509;
EVP_MD *dgst;
STACK *policy;
TXT_DB *db;
BIGNUM *serial;
char *startdate;
int days;
int batch;
STACK *extensions;
int verbose;
d1360 1
a1360 1
	if ((req=PEM_read_bio_X509_REQ(in,NULL,NULL)) == NULL)
d1377 1
d1393 2
a1394 2
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,startdate,
		days,batch,verbose,req,extensions);
d1402 4
a1405 15
static int certify_cert(xret,infile,pkey,x509,dgst,policy,db,serial,startdate,
	days, batch,extensions,verbose)
X509 **xret;
char *infile;
EVP_PKEY *pkey;
X509 *x509;
EVP_MD *dgst;
STACK *policy;
TXT_DB *db;
BIGNUM *serial;
char *startdate;
int days;
int batch;
STACK *extensions;
int verbose;
d1420 1
a1420 1
	if ((req=PEM_read_bio_X509(in,NULL,NULL)) == NULL)
d1436 1
d1446 1
a1446 1
		BIO_printf(bio_err,"Signature did not match the certificate request\n");
d1455 2
a1456 2
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,startdate,days,
		batch,verbose,rreq,extensions);
d1465 4
a1468 15
static int do_body(xret,pkey,x509,dgst,policy,db,serial,startdate,days,
	batch,verbose,req, extensions)
X509 **xret;
EVP_PKEY *pkey;
X509 *x509;
EVP_MD *dgst;
STACK *policy;
TXT_DB *db;
BIGNUM *serial;
char *startdate;
int days;
int batch;
int verbose;
X509_REQ *req;
STACK *extensions;
a1477 1
	X509_EXTENSION *ex=NULL;
d1582 1
a1582 1
	for (i=0; i<sk_num(policy); i++)
d1584 1
a1584 1
		cv=(CONF_VALUE *)sk_value(policy,i); /* get the object id */
d1691 1
a1691 1
	row[DB_serial]=BN_bn2ascii(serial);
d1727 1
a1727 1
		BIO_printf(bio_err,"Type          :%s\n",p);;
a1763 1
		{
d1765 3
d1769 2
a1770 6
		}
	else
		{
		/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
		ASN1_UTCTIME_set_string(X509_get_notBefore(ret),startdate);
		}
d1772 2
a1773 1
	BIO_printf(bio_err," (%d days)\n",days);
d1778 3
a1780 1
	if (!X509_set_pubkey(ret,pktmp)) goto err;
d1783 1
a1783 1
	if ((extensions != NULL) && (sk_num(extensions) > 0))
d1785 1
d1794 4
a1797 1
			sk_pop_free(ci->extensions,X509_EXTENSION_free);
d1799 4
a1802 2
		if ((ci->extensions=sk_new_null()) == NULL)
			goto err;
a1803 8
		/* Lets 'copy' in the new ones */
		for (i=0; i<sk_num(extensions); i++)
			{
			ex=X509_EXTENSION_dup((X509_EXTENSION *)
				sk_value(extensions,i));
			if (ex == NULL) goto err;
			if (!sk_push(ci->extensions,(char *)ex)) goto err;
			}
d1810 1
a1810 1
		BIO_flush(bio_err);
d1821 1
d1823 3
a1825 2
        pktmp=X509_get_pubkey(ret);
        if (EVP_PKEY_missing_parameters(pktmp) &&
d1828 1
d1896 1
a1896 4
static void write_new_certificate(bp,x, output_der)
BIO *bp;
X509 *x;
int output_der;
d1922 4
a1925 14
static int certify_spkac(xret,infile,pkey,x509,dgst,policy,db,serial,
	startdate,days,extensions,verbose)
X509 **xret;
char *infile;
EVP_PKEY *pkey;
X509 *x509;
EVP_MD *dgst;
STACK *policy;
TXT_DB *db;
BIGNUM *serial;
char *startdate;
int days;
STACK *extensions;
int verbose;
d1927 1
a1927 1
	STACK *sk=NULL;
d1956 1
a1956 1
	if (sk_num(sk) == 0)
d1985 1
a1985 1
		if ((int)sk_num(sk) <= i) break;
d1987 1
a1987 1
		cv=(CONF_VALUE *)sk_value(sk,i);
d2068 3
a2070 2
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,startdate,
		days,1,verbose,req,extensions);
d2081 1
a2081 3
static int fix_data(nid,type)
int nid;
int *type;
d2096 31
d2128 5
a2132 15
static STACK *load_extensions(sec)
char *sec;
	{
	STACK *ext;
	STACK *ret=NULL;
	CONF_VALUE *cv;
	ASN1_OCTET_STRING *str=NULL;
	ASN1_STRING *tmp=NULL;
	X509_EXTENSION *x;
	BIO *mem=NULL;
	BUF_MEM *buf=NULL;
	int i,nid,len;
	unsigned char *ptr;
	int pack_type;
	int data_type;
d2134 5
a2138 1
	if ((ext=CONF_get_section(conf,sec)) == NULL)
d2140 2
a2141 2
		BIO_printf(bio_err,"unable to find extension section called '%s'\n",sec);
		return(NULL);
d2143 12
d2156 1
a2156 1
	if ((ret=sk_new_null()) == NULL) return(NULL);
d2158 7
a2164 4
	for (i=0; i<sk_num(ext); i++)
		{
		cv=(CONF_VALUE *)sk_value(ext,i); /* get the object id */
		if ((nid=OBJ_txt2nid(cv->name)) == NID_undef)
d2166 1
a2166 1
			BIO_printf(bio_err,"%s:unknown object type in section, '%s'\n",sec,cv->name);
d2169 3
d2173 5
a2177 2
		pack_type=X509v3_pack_type_by_NID(nid);
		data_type=X509v3_data_type_by_NID(nid);
d2179 1
a2179 5
		/* pack up the input bytes */
		ptr=(unsigned char *)cv->value;
		len=strlen((char *)ptr);
		if ((len > 2) && (cv->value[0] == '0') &&
			(cv->value[1] == 'x'))
d2181 2
a2182 19
			if (data_type == V_ASN1_UNDEF)
				{
				BIO_printf(bio_err,"data type for extension %s is unknown\n",cv->name);
				goto err;
				}
			if (mem == NULL)
				if ((mem=BIO_new(BIO_s_mem())) == NULL)
					goto err;
			if (((buf=BUF_MEM_new()) == NULL) ||
				!BUF_MEM_grow(buf,128))
				goto err;
			if ((tmp=ASN1_STRING_new()) == NULL) goto err;

			BIO_reset(mem);
			BIO_write(mem,(char *)&(ptr[2]),len-2);
			if (!a2i_ASN1_STRING(mem,tmp,buf->data,buf->max))
				goto err;
			len=tmp->length;
			ptr=tmp->data;
d2184 1
d2186 1
a2186 1
		switch (pack_type)
d2188 2
a2189 8
		case X509_EXT_PACK_STRING:
			if ((str=X509v3_pack_string(&str,
				data_type,ptr,len)) == NULL)
				goto err;
			break;
		case X509_EXT_PACK_UNKNOWN:
		default:
			BIO_printf(bio_err,"Don't know how to pack extension %s\n",cv->name);
a2190 1
			break;
d2193 18
a2210 3
		if ((x=X509_EXTENSION_create_by_NID(NULL,nid,0,str)) == NULL)
			goto err;
		sk_push(ret,(char *)x);
d2212 1
a2212 2

	if (0)
d2214 9
d2224 4
a2227 2
		if (ret != NULL) sk_pop_free(ret,X509_EXTENSION_free);
		ret=NULL;
d2229 3
a2231 17
	if (str != NULL) ASN1_OCTET_STRING_free(str);
	if (tmp != NULL) ASN1_STRING_free(tmp);
	if (buf != NULL) BUF_MEM_free(buf);
	if (mem != NULL) BIO_free(mem);
	return(ret);
	}

static int check_time_format(str)
char *str;
	{
	ASN1_UTCTIME tm;

	tm.data=(unsigned char *)str;
	tm.length=strlen(str);
	tm.type=V_ASN1_UTCTIME;
	return(ASN1_UTCTIME_check(&tm));
	}
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a63 1
#include <ctype.h>
d67 9
a75 29
#include <openssl/conf.h>
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/bn.h>
#include <openssl/txt_db.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/objects.h>
#include <openssl/ocsp.h>
#include <openssl/pem.h>

#ifdef OPENSSL_SYS_WINDOWS
#define strcasecmp _stricmp
#else
#include <strings.h>
#endif

#ifndef W_OK
#  ifdef OPENSSL_SYS_VMS
#    if defined(__DECC)
#      include <unistd.h>
#    else
#      include <unixlib.h>
#    endif
#  elif !defined(OPENSSL_SYS_VXWORKS)
#    include <sys/file.h>
#  endif
#endif
d78 1
a78 4
#  define F_OK 0
#  define X_OK 1
#  define W_OK 2
#  define R_OK 4
d85 1
a85 1
#define CONFIG_FILE "openssl.cnf"
a100 1
#define ENV_DEFAULT_ENDDATE 	"default_enddate"
a103 1
#define ENV_DEFAULT_EMAIL_DN	"email_in_dn"
a106 1
#define ENV_CRLEXT      	"crl_extensions"
a107 3
#define ENV_NAMEOPT		"name_opt"
#define ENV_CERTOPT		"cert_opt"
#define ENV_EXTCOPY		"copy_extensions"
a122 8
/* Additional revocation information types */

#define REV_NONE		0	/* No addditional information */
#define REV_CRL_REASON		1	/* Value is CRL reason code */
#define REV_HOLD		2	/* Value is hold instruction */
#define REV_KEY_COMPROMISE	3	/* Value is cert key compromise time */
#define REV_CA_COMPROMISE	4	/* Value is CA key compromise time */

a131 2
" -startdate YYMMDDHHMMSSZ  - certificate validity notBefore\n",
" -enddate YYMMDDHHMMSSZ    - certificate validity notAfter (overrides -days)\n",
d135 1
a135 2
" -keyfile arg    - private key file\n",
" -keyform arg    - private key file format (PEM or ENGINE)\n",
d137 1
a137 1
" -cert file      - The CA certificate\n",
d145 2
a146 11
" -noemailDN      - Don't add the EMAIL field into certificate' subject\n",
" -batch          - Don't ask questions\n",
" -msie_hack      - msie modifications to handle all those universal strings\n",
" -revoke file    - Revoke a certificate (given in file)\n",
" -subj arg       - Use arg instead of request's subject\n",
" -extensions ..  - Extension section (override value in config file)\n",
" -extfile file   - Configuration file with X509v3 extentions to add\n",
" -crlexts ..     - CRL extension section (override value in config file)\n",
" -engine e       - use engine e, possibly a hardware device.\n",
" -status serial  - Shows certificate status given the serial number\n",
" -updatedb       - Updates db for expired certificates\n",
d156 2
d159 4
a162 3
static unsigned long index_serial_hash(const char **a);
static int index_serial_cmp(const char **a, const char **b);
static unsigned long index_name_hash(const char **a);
d164 1
a164 1
static int index_name_cmp(const char **a,const char **b);
d168 2
a169 5
		   const EVP_MD *dgst,STACK_OF(CONF_VALUE) *policy,TXT_DB *db,
		   BIGNUM *serial, char *subj, int email_dn, char *startdate,
		   char *enddate, long days, int batch, char *ext_sect, CONF *conf,
		   int verbose, unsigned long certopt, unsigned long nameopt,
		   int default_op, int ext_copy);
d171 2
a172 6
			const EVP_MD *dgst,STACK_OF(CONF_VALUE) *policy,
			TXT_DB *db, BIGNUM *serial, char *subj, int email_dn,
			char *startdate, char *enddate, long days, int batch,
			char *ext_sect, CONF *conf,int verbose, unsigned long certopt,
			unsigned long nameopt, int default_op, int ext_copy,
			ENGINE *e);
d174 2
a175 5
			 const EVP_MD *dgst,STACK_OF(CONF_VALUE) *policy,
			 TXT_DB *db, BIGNUM *serial,char *subj, int email_dn,
			 char *startdate, char *enddate, long days, char *ext_sect,
			 CONF *conf, int verbose, unsigned long certopt, 
			 unsigned long nameopt, int default_op, int ext_copy);
d177 4
a180 10
static void write_new_certificate(BIO *bp, X509 *x, int output_der, int notext);
static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509, const EVP_MD *dgst,
	STACK_OF(CONF_VALUE) *policy, TXT_DB *db, BIGNUM *serial,char *subj,
	int email_dn, char *startdate, char *enddate, long days, int batch,
       	int verbose, X509_REQ *req, char *ext_sect, CONF *conf,
	unsigned long certopt, unsigned long nameopt, int default_op,
	int ext_copy);
static int do_revoke(X509 *x509, TXT_DB *db, int ext, char *extval);
static int get_certificate_status(const char *ser_status, TXT_DB *db);
static int do_updatedb(TXT_DB *db);
d182 22
a203 5
char *make_revocation_str(int rev_type, char *rev_arg);
int make_revoked(X509_REVOKED *rev, char *str);
int old_entry_print(BIO *bp, ASN1_OBJECT *obj, ASN1_STRING *str);
static CONF *conf=NULL;
static CONF *extconf=NULL;
d209 3
a211 9
static IMPLEMENT_LHASH_HASH_FN(index_serial_hash,const char **)
static IMPLEMENT_LHASH_COMP_FN(index_serial_cmp,const char **)
static IMPLEMENT_LHASH_HASH_FN(index_name_hash,const char **)
static IMPLEMENT_LHASH_COMP_FN(index_name_cmp,const char **)


int MAIN(int, char **);

int MAIN(int argc, char **argv)
a212 3
	ENGINE *e = NULL;
	char *key=NULL,*passargin=NULL;
	int free_key = 0;
a216 1
	int email_dn=1;
a219 2
	int dorevoke=0;
	int doupdatedb=0;
a227 1
	int keyform=FORMAT_PEM;
a230 1
	char *ser_status=NULL;
a236 6
	char *extfile=NULL;
	char *subj=NULL;
	char *tmp_email_dn=NULL;
	char *crl_ext=NULL;
	int rev_type = REV_NONE;
	char *rev_arg = NULL;
d239 1
a239 2
	char *enddate=NULL;
	long days=0;
a240 4
	int notext=0;
	unsigned long nameopt = 0, certopt = 0;
	int default_op = 1;
	int ext_copy = EXT_COPY_NONE;
d247 1
a248 2
	ASN1_TIME *tmptm;
	ASN1_INTEGER *tmpser;
d252 5
a256 3
	const EVP_MD *dgst=NULL;
	STACK_OF(CONF_VALUE) *attribs=NULL;
	STACK_OF(X509) *cert_sk=NULL;
a259 2
	char *randfile=NULL;
	char *engine = NULL;
d269 1
a269 3
	conf = NULL;
	key = NULL;
	section = NULL;
a271 1
	msie_hack=0;
a291 6
		else if (strcmp(*argv,"-subj") == 0)
			{
			if (--argc < 1) goto bad;
			subj= *(++argv);
			/* preserve=1; */
			}
a296 5
		else if (strcmp(*argv,"-enddate") == 0)
			{
			if (--argc < 1) goto bad;
			enddate= *(++argv);
			}
a316 10
		else if (strcmp(*argv,"-keyform") == 0)
			{
			if (--argc < 1) goto bad;
			keyform=str2fmt(*(++argv));
			}
		else if (strcmp(*argv,"-passin") == 0)
			{
			if (--argc < 1) goto bad;
			passargin= *(++argv);
			}
a342 2
		else if (strcmp(*argv,"-notext") == 0)
			notext=1;
a346 2
		else if (strcmp(*argv,"-noemailDN") == 0)
			email_dn=0;
a379 59
		else if (strcmp(*argv,"-revoke") == 0)
			{
			if (--argc < 1) goto bad;
			infile= *(++argv);
			dorevoke=1;
			}
		else if (strcmp(*argv,"-extensions") == 0)
			{
			if (--argc < 1) goto bad;
			extensions= *(++argv);
			}
		else if (strcmp(*argv,"-extfile") == 0)
			{
			if (--argc < 1) goto bad;
			extfile= *(++argv);
			}
		else if (strcmp(*argv,"-status") == 0)
			{
			if (--argc < 1) goto bad;
			ser_status= *(++argv);
			}
		else if (strcmp(*argv,"-updatedb") == 0)
			{
			doupdatedb=1;
			}
		else if (strcmp(*argv,"-crlexts") == 0)
			{
			if (--argc < 1) goto bad;
			crl_ext= *(++argv);
			}
		else if (strcmp(*argv,"-crl_reason") == 0)
			{
			if (--argc < 1) goto bad;
			rev_arg = *(++argv);
			rev_type = REV_CRL_REASON;
			}
		else if (strcmp(*argv,"-crl_hold") == 0)
			{
			if (--argc < 1) goto bad;
			rev_arg = *(++argv);
			rev_type = REV_HOLD;
			}
		else if (strcmp(*argv,"-crl_compromise") == 0)
			{
			if (--argc < 1) goto bad;
			rev_arg = *(++argv);
			rev_type = REV_KEY_COMPROMISE;
			}
		else if (strcmp(*argv,"-crl_CA_compromise") == 0)
			{
			if (--argc < 1) goto bad;
			rev_arg = *(++argv);
			rev_type = REV_CA_COMPROMISE;
			}
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
			engine= *(++argv);
			}
d394 1
a394 1
			BIO_printf(bio_err,"%s",*pp);
a399 2
        e = setup_engine(bio_err, engine, 0);

a400 2
	if (configfile == NULL) configfile = getenv("OPENSSL_CONF");
	if (configfile == NULL) configfile = getenv("SSLEAY_CONF");
a403 4
#ifdef OPENSSL_SYS_VMS
		strncpy(buf[0],X509_get_default_cert_area(),
			sizeof(buf[0])-1-sizeof(CONFIG_FILE));
#else
a405 1
		buf[0][sizeof(buf[0])-2-sizeof(CONFIG_FILE)]='\0';
a406 1
#endif
d412 1
a412 2
	conf = NCONF_new(NULL);
	if (NCONF_load(conf,configfile,&errorline) <= 0)
a422 3
	if (!load_config(bio_err, conf))
		goto err;

d426 1
a426 1
		section=NCONF_get_string(conf,BASE_SECTION,ENV_DEFAULT_CA);
a433 36
	if (conf != NULL)
		{
		p=NCONF_get_string(conf,NULL,"oid_file");
		if (p == NULL)
			ERR_clear_error();
		if (p != NULL)
			{
			BIO *oid_bio;

			oid_bio=BIO_new_file(p,"r");
			if (oid_bio == NULL) 
				{
				/*
				BIO_printf(bio_err,"problems opening %s for extra oid's\n",p);
				ERR_print_errors(bio_err);
				*/
				ERR_clear_error();
				}
			else
				{
				OBJ_create_objects(oid_bio);
				BIO_free(oid_bio);
				}
			}
		if (!add_oid_section(bio_err,conf)) 
			{
			ERR_print_errors(bio_err);
			goto err;
			}
		}

	randfile = NCONF_get_string(conf, BASE_SECTION, "RANDFILE");
	if (randfile == NULL)
		ERR_clear_error();
	app_RAND_load_file(randfile, bio_err, 0);
	
d445 1
a445 28
	/* report status of cert with serial number given on command line */
	if (ser_status)
	{
		if ((dbfile=NCONF_get_string(conf,section,ENV_DATABASE)) == NULL)
			{
			lookup_fail(section,ENV_DATABASE);
			goto err;
			}
		if (BIO_read_filename(in,dbfile) <= 0)
			{
			perror(dbfile);
			BIO_printf(bio_err,"unable to open '%s'\n",dbfile);
			goto err;
			}
		db=TXT_DB_read(in,DB_NUMBER);
		if (db == NULL) goto err;

		if (!make_serial_index(db))
			goto err;

		if (get_certificate_status(ser_status,db) != 1)
			BIO_printf(bio_err,"Error verifying serial %s!\n",
				 ser_status);
		goto err;
	}

	/*****************************************************************/
	/* we definitely need a public key, so let's get it */
d447 1
a447 1
	if ((keyfile == NULL) && ((keyfile=NCONF_get_string(conf,
d453 9
a461 1
	if (!key)
d463 2
a464 6
		free_key = 1;
		if (!app_passwd(bio_err, passargin, NULL, &key, NULL))
			{
			BIO_printf(bio_err,"Error getting password\n");
			goto err;
			}
a465 3
	pkey = load_key(bio_err, keyfile, keyform, key, e, 
		"CA private key");
	if (key) memset(key,0,strlen(key));
d468 1
a468 1
		/* load_key() has already printed an appropriate message */
d474 1
a474 1
	if ((certfile == NULL) && ((certfile=NCONF_get_string(conf,
d480 7
a486 2
	x509=load_cert(bio_err, certfile, FORMAT_PEM, NULL, e,
		"CA certificate");
a487 3
		goto err;

	if (!X509_check_private_key(x509,pkey))
d489 1
a489 1
		BIO_printf(bio_err,"CA certificate and CA private key do not match\n");
d493 1
a493 3
	f=NCONF_get_string(conf,BASE_SECTION,ENV_PRESERVE);
	if (f == NULL)
		ERR_clear_error();
d496 1
a496 3
	f=NCONF_get_string(conf,BASE_SECTION,ENV_MSIE_HACK);
	if (f == NULL)
		ERR_clear_error();
a499 41
	f=NCONF_get_string(conf,section,ENV_NAMEOPT);

	if (f)
		{
		if (!set_name_ex(&nameopt, f))
			{
			BIO_printf(bio_err, "Invalid name options: \"%s\"\n", f);
			goto err;
			}
		default_op = 0;
		}
	else
		ERR_clear_error();

	f=NCONF_get_string(conf,section,ENV_CERTOPT);

	if (f)
		{
		if (!set_cert_ex(&certopt, f))
			{
			BIO_printf(bio_err, "Invalid certificate options: \"%s\"\n", f);
			goto err;
			}
		default_op = 0;
		}
	else
		ERR_clear_error();

	f=NCONF_get_string(conf,section,ENV_EXTCOPY);

	if (f)
		{
		if (!set_ext_copy(&ext_copy, f))
			{
			BIO_printf(bio_err, "Invalid extension copy option: \"%s\"\n", f);
			goto err;
			}
		}
	else
		ERR_clear_error();

d506 1
a506 1
		if ((outdir=NCONF_get_string(conf,section,ENV_NEW_CERTS_DIR))
a511 11
#ifndef OPENSSL_SYS_VMS
	    /* outdir is a directory spec, but access() for VMS demands a
	       filename.  In any case, stat(), below, will catch the problem
	       if outdir is not a directory spec, and the fopen() or open()
	       will catch an error if there is no write access.

	       Presumably, this problem could also be solved by using the DEC
	       C routines to convert the directory syntax to Unixly, and give
	       that to access().  However, time's too short to do that just
	       now.
	    */
d514 1
a514 1
			BIO_printf(bio_err,"I am unable to access the %s directory\n",outdir);
a524 1
#ifdef S_IFDIR
a530 2
#endif
#endif
d535 1
a535 1
	if ((dbfile=NCONF_get_string(conf,section,ENV_DATABASE)) == NULL)
d540 1
a540 1
	if (BIO_read_filename(in,dbfile) <= 0)
d556 1
a556 1
			BIO_printf(bio_err,"entry %d: not revoked yet, but has a revocation date\n",i+1);
d560 1
a560 1
			!make_revoked(NULL, pp[DB_rev_date]))
d562 2
a563 1
			BIO_printf(bio_err," in entry %d\n", i+1);
a572 5
		if (*p == '-')
			{
			p++;
			j--;
			}
a592 6
#ifdef OPENSSL_SYS_VMS
		{
		BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		out = BIO_push(tmpbio, out);
		}
#endif
d596 1
a596 1
		BIO_printf(bio_err,"generating index\n");
d599 4
a602 1
	if (!make_serial_index(db))
d604 1
d606 2
a607 3
	if (!TXT_DB_create_index(db, DB_name, index_name_qual,
			LHASH_HASH_FN(index_name_hash),
			LHASH_COMP_FN(index_name_cmp)))
a614 109
	/* Update the db file for expired certificates */
	if (doupdatedb)
		{
		if (verbose)
			BIO_printf(bio_err, "Updating %s ...\n",
							dbfile);

		i = do_updatedb(db);
		if (i == -1)
			{
			BIO_printf(bio_err,"Malloc failure\n");
			goto err;
			}
		else if (i == 0)
			{
			if (verbose) BIO_printf(bio_err,
					"No entries found to mark expired\n"); 
			}
	    	else
			{
			out = BIO_new(BIO_s_file());
			if (out == NULL)
				{
				ERR_print_errors(bio_err);
				goto err;
				}

#ifndef OPENSSL_SYS_VMS
			j = BIO_snprintf(buf[0], sizeof buf[0], "%s.new", dbfile);
#else
			j = BIO_snprintf(buf[0], sizeof buf[0], "%s-new", dbfile);
#endif
			if (j < 0 || j >= sizeof buf[0])
				{
				BIO_printf(bio_err, "file name too long\n");
				goto err;
				}
			if (BIO_write_filename(out,buf[0]) <= 0)
		  		{
		    		perror(dbfile);
		    		BIO_printf(bio_err,"unable to open '%s'\n",
									dbfile);
		    		goto err;
		  		}
			j=TXT_DB_write(out,db);
			if (j <= 0) goto err;
			
			BIO_free(out);
			out = NULL;
#ifndef OPENSSL_SYS_VMS
			j = BIO_snprintf(buf[1], sizeof buf[1], "%s.old", dbfile);
#else
			j = BIO_snprintf(buf[1], sizeof buf[1], "%s-old", dbfile);
#endif
			if (j < 0 || j >= sizeof buf[1])
				{
				BIO_printf(bio_err, "file name too long\n");
				goto err;
				}
			if (rename(dbfile,buf[1]) < 0)
		  		{
		    		BIO_printf(bio_err,
						"unable to rename %s to %s\n",
						dbfile, buf[1]);
		    		perror("reason");
		    		goto err;
		  		}
			if (rename(buf[0],dbfile) < 0)
				{
		    		BIO_printf(bio_err,
						"unable to rename %s to %s\n",
						buf[0],dbfile);
		    		perror("reason");
		    		rename(buf[1],dbfile);
		    		goto err;
		  		}
				
			if (verbose) BIO_printf(bio_err,
				"Done. %d entries marked as expired\n",i); 
	      		}
			goto err;
	  	}

 	/*****************************************************************/
	/* Read extentions config file                                   */
	if (extfile)
		{
		extconf = NCONF_new(NULL);
		if (NCONF_load(extconf,extfile,&errorline) <= 0)
			{
			if (errorline <= 0)
				BIO_printf(bio_err, "ERROR: loading the config file '%s'\n",
					extfile);
			else
				BIO_printf(bio_err, "ERROR: on line %ld of config file '%s'\n",
					errorline,extfile);
			ret = 1;
			goto err;
			}

		if (verbose)
			BIO_printf(bio_err, "Succesfully loaded extensions file %s\n", extfile);

		/* We can have sections in the ext file */
		if (!extensions && !(extensions = NCONF_get_string(extconf, "default", "extensions")))
			extensions = "default";
		}

	/*****************************************************************/
d619 1
a626 1
			{
a627 7
#ifdef OPENSSL_SYS_VMS
			{
			BIO *tmpbio = BIO_new(BIO_f_linebuffer());
			Sout = BIO_push(tmpbio, Sout);
			}
#endif
			}
d632 1
a632 1
		if ((md == NULL) && ((md=NCONF_get_string(conf,
a637 6
		if ((email_dn == 1) && ((tmp_email_dn=NCONF_get_string(conf,
			section,ENV_DEFAULT_EMAIL_DN)) != NULL ))
			{
			if(strcmp(tmp_email_dn,"no") == 0)
				email_dn=0;
			}
d646 1
a646 1
		if ((policy == NULL) && ((policy=NCONF_get_string(conf,
d655 1
a655 1
		if ((serialfile=NCONF_get_string(conf,section,ENV_SERIAL))
d662 2
a663 1
		if (!extconf)
d665 2
a666 25
			/* no '-extfile' option, so we look for extensions
			 * in the main configuration file */
			if (!extensions)
				{
				extensions=NCONF_get_string(conf,section,
								ENV_EXTENSIONS);
				if (!extensions)
					ERR_clear_error();
				}
			if (extensions)
				{
				/* Check syntax of file */
				X509V3_CTX ctx;
				X509V3_set_ctx_test(&ctx);
				X509V3_set_nconf(&ctx, conf);
				if (!X509V3_EXT_add_nconf(conf, &ctx, extensions,
								NULL))
					{
					BIO_printf(bio_err,
				 	"Error Loading extension section %s\n",
								 extensions);
					ret = 1;
					goto err;
					}
				}
d671 1
a671 1
			startdate=NCONF_get_string(conf,section,
d674 9
a682 6
				ERR_clear_error();
			}
		if (startdate && !ASN1_UTCTIME_set_string(NULL,startdate))
			{
			BIO_printf(bio_err,"start date is invalid, it should be YYMMDDHHMMSSZ\n");
			goto err;
a683 1
		if (startdate == NULL) startdate="today";
d685 1
a685 8
		if (enddate == NULL)
			{
			enddate=NCONF_get_string(conf,section,
				ENV_DEFAULT_ENDDATE);
			if (enddate == NULL)
				ERR_clear_error();
			}
		if (enddate && !ASN1_UTCTIME_set_string(NULL,enddate))
d687 2
a688 2
			BIO_printf(bio_err,"end date is invalid, it should be YYMMDDHHMMSSZ\n");
			goto err;
a689 1

a691 5
			if(!NCONF_get_number(conf,section, ENV_DEFAULT_DAYS, &days))
				days = 0;
			}
		if (!enddate && (days == 0))
			{
d703 1
a703 1
			if ((f=BN_bn2hex(serial)) == NULL) goto err;
d705 1
a705 1
			OPENSSL_free(f);
d708 1
a708 1
		if ((attribs=NCONF_get_section(conf,policy)) == NULL)
d714 1
a714 1
		if ((cert_sk=sk_X509_new_null()) == NULL)
d716 1
a716 1
			BIO_printf(bio_err,"Memory allocation failure\n");
d723 1
a723 2
				serial,subj,email_dn,startdate,enddate,days,extensions,
				conf,verbose,certopt,nameopt,default_op,ext_copy);
d730 1
a730 1
				if (!sk_X509_push(cert_sk,x))
d732 1
a732 1
					BIO_printf(bio_err,"Memory allocation failure\n");
d746 2
a747 3
				db,serial,subj,email_dn,startdate,enddate,days,batch,
				extensions,conf,verbose, certopt, nameopt,
				default_op, ext_copy, e);
d754 1
a754 1
				if (!sk_X509_push(cert_sk,x))
d756 1
a756 1
					BIO_printf(bio_err,"Memory allocation failure\n");
d765 2
a766 3
				serial,subj,email_dn,startdate,enddate,days,batch,
				extensions,conf,verbose, certopt, nameopt,
				default_op, ext_copy);
d773 1
a773 1
				if (!sk_X509_push(cert_sk,x))
d775 1
a775 1
					BIO_printf(bio_err,"Memory allocation failure\n");
d784 2
a785 3
				serial,subj,email_dn,startdate,enddate,days,batch,
				extensions,conf,verbose, certopt, nameopt,
				default_op, ext_copy);
d792 1
a792 1
				if (!sk_X509_push(cert_sk,x))
d794 1
a794 1
					BIO_printf(bio_err,"Memory allocation failure\n");
d803 1
a803 1
		if (sk_X509_num(cert_sk) > 0)
d808 1
a808 1
				(void)BIO_flush(bio_err);
d819 1
a819 1
			BIO_printf(bio_err,"Write out database with %d new entries\n",sk_X509_num(cert_sk));
a821 5
			buf[0][BSIZE-4]='\0';

#ifdef OPENSSL_SYS_VMS
			strcat(buf[0],"-new");
#else
a822 1
#endif
a826 5
			buf[1][BSIZE-4]='\0';

#ifdef OPENSSL_SYS_VMS
			strcat(buf[1],"-new");
#else
a827 2
#endif

d840 1
a840 1
		for (i=0; i<sk_X509_num(cert_sk); i++)
d845 1
a845 1
			x=sk_X509_value(cert_sk,i);
a850 3
			buf[2][BSIZE-(j*2)-6]='\0';

#ifndef OPENSSL_SYS_VMS
a851 2
#endif

d876 2
a877 2
			write_new_certificate(Cout,x, 0, notext);
			write_new_certificate(Sout,x, output_der, notext);
d880 1
a880 1
		if (sk_X509_num(cert_sk))
a883 5
			buf[2][BSIZE-4]='\0';

#ifdef OPENSSL_SYS_VMS
			strcat(buf[2],"-old");
#else
a884 2
#endif

d886 1
a886 1
			BIO_free_all(out);
d891 1
a891 1
				BIO_printf(bio_err,"unable to rename %s to %s\n",
d898 1
a898 1
				BIO_printf(bio_err,"unable to rename %s to %s\n",
a905 5
			buf[2][BSIZE-4]='\0';

#ifdef OPENSSL_SYS_VMS
			strcat(buf[2],"-old");
#else
a906 2
#endif

d909 1
a909 1
				BIO_printf(bio_err,"unable to rename %s to %s\n",
d916 1
a916 1
				BIO_printf(bio_err,"unable to rename %s to %s\n",
d929 1
a929 22
		int crl_v2 = 0;
		if (!crl_ext)
			{
			crl_ext=NCONF_get_string(conf,section,ENV_CRLEXT);
			if (!crl_ext)
				ERR_clear_error();
			}
		if (crl_ext)
			{
			/* Check syntax of file */
			X509V3_CTX ctx;
			X509V3_set_ctx_test(&ctx);
			X509V3_set_nconf(&ctx, conf);
			if (!X509V3_EXT_add_nconf(conf, &ctx, crl_ext, NULL))
				{
				BIO_printf(bio_err,
				 "Error Loading CRL extension section %s\n",
								 crl_ext);
				ret = 1;
				goto err;
				}
			}
d933 4
a936 6
			if (!NCONF_get_number(conf,section,
				ENV_DEFAULT_CRL_DAYS, &crldays))
				crldays = 0;
			if (!NCONF_get_number(conf,section,
				ENV_DEFAULT_CRL_HOURS, &crlhours))
				crlhours = 0;
d946 9
a954 10
		if (!X509_CRL_set_issuer_name(crl, X509_get_issuer_name(x509))) goto err;

		tmptm = ASN1_TIME_new();
		if (!tmptm) goto err;
		X509_gmtime_adj(tmptm,0);
		X509_CRL_set_lastUpdate(crl, tmptm);	
		X509_gmtime_adj(tmptm,(crldays*24+crlhours)*60*60);
		X509_CRL_set_nextUpdate(crl, tmptm);	

		ASN1_TIME_free(tmptm);
d962 8
a969 4
				j = make_revoked(r, pp[DB_rev_date]);
				if (!j) goto err;
				if (j == 2) crl_v2 = 1;
				if (!BN_hex2bn(&serial, pp[DB_serial]))
d971 4
a974 8
				tmpser = BN_to_ASN1_INTEGER(serial, NULL);
				BN_free(serial);
				serial = NULL;
				if (!tmpser)
					goto err;
				X509_REVOKED_set_serialNumber(r, tmpser);
				ASN1_INTEGER_free(tmpser);
				X509_CRL_add0_revoked(crl,r);
a976 1

d979 6
a984 1
		X509_CRL_sort(crl);
d986 1
a986 1
		/* we now have a CRL */
d997 2
a998 8
			{
#ifndef OPENSSL_NO_DSA
			if (pkey->type == EVP_PKEY_DSA) 
				dgst=EVP_dss1();
			else
#endif
				dgst=EVP_md5();
			}
d1000 10
a1009 1
		/* Add any extensions asked for */
d1011 3
a1013 5
		if (crl_ext)
			{
			X509V3_CTX crlctx;
			X509V3_set_ctx(&crlctx, x509, NULL, NULL, crl, 0);
			X509V3_set_nconf(&crlctx, conf);
d1015 10
a1024 8
			if (!X509V3_EXT_CRL_add_nconf(conf, &crlctx,
				crl_ext, crl)) goto err;
			}
		if (crl_ext || crl_v2)
			{
			if (!X509_CRL_set_version(crl, 1))
				goto err; /* version 2 CRL */
			}
d1026 6
a1031 1
		if (!X509_CRL_sign(crl,pkey,dgst)) goto err;
d1033 5
a1037 72
		PEM_write_bio_X509_CRL(Sout,crl);
		}
	/*****************************************************************/
	if (dorevoke)
		{
		if (infile == NULL) 
			{
			BIO_printf(bio_err,"no input files\n");
			goto err;
			}
		else
			{
			X509 *revcert;
			revcert=load_cert(bio_err, infile, FORMAT_PEM,
				NULL, e, infile);
			if (revcert == NULL)
				goto err;
			j=do_revoke(revcert,db, rev_type, rev_arg);
			if (j <= 0) goto err;
			X509_free(revcert);

			strncpy(buf[0],dbfile,BSIZE-4);
			buf[0][BSIZE-4]='\0';
#ifndef OPENSSL_SYS_VMS
			strcat(buf[0],".new");
#else
			strcat(buf[0],"-new");
#endif
			if (BIO_write_filename(out,buf[0]) <= 0)
				{
				perror(dbfile);
				BIO_printf(bio_err,"unable to open '%s'\n",dbfile);
				goto err;
				}
			j=TXT_DB_write(out,db);
			if (j <= 0) goto err;
			BIO_free_all(out);
			out = NULL;
			BIO_free_all(in);
			in = NULL;
			strncpy(buf[1],dbfile,BSIZE-4);
			buf[1][BSIZE-4]='\0';
#ifndef OPENSSL_SYS_VMS
			strcat(buf[1],".old");
#else
			strcat(buf[1],"-old");
#endif
			if (rename(dbfile,buf[1]) < 0)
				{
				BIO_printf(bio_err,"unable to rename %s to %s\n", dbfile, buf[1]);
				perror("reason");
				goto err;
				}
			if (rename(buf[0],dbfile) < 0)
				{
				BIO_printf(bio_err,"unable to rename %s to %s\n", buf[0],dbfile);
				perror("reason");
				rename(buf[1],dbfile);
				goto err;
				}
			BIO_printf(bio_err,"Data Base Updated\n"); 
			}
		}
	/*****************************************************************/
	ret=0;
err:
	BIO_free_all(Cout);
	BIO_free_all(Sout);
	BIO_free_all(out);
	BIO_free_all(in);

	sk_X509_pop_free(cert_sk,X509_free);
d1039 5
a1043 13
	if (ret) ERR_print_errors(bio_err);
	app_RAND_write_file(randfile, bio_err);
	if (free_key)
		OPENSSL_free(key);
	BN_free(serial);
	TXT_DB_free(db);
	EVP_PKEY_free(pkey);
	X509_free(x509);
	X509_CRL_free(crl);
	NCONF_free(conf);
	OBJ_cleanup();
	apps_shutdown();
	EXIT(ret);
d1046 2
a1047 1
static void lookup_fail(char *name, char *tag)
d1049 1
a1049 6
	BIO_printf(bio_err,"variable lookup failed for %s::%s\n",name,tag);
	}

static unsigned long index_serial_hash(const char **a)
	{
	const char *n;
d1056 3
a1058 1
static int index_serial_cmp(const char **a, const char **b)
d1060 1
a1060 1
	const char *aa,*bb;
d1067 2
a1068 1
static unsigned long index_name_hash(const char **a)
d1071 2
a1072 1
static int index_name_qual(char **a)
d1075 4
a1078 3
static int index_name_cmp(const char **a, const char **b)
	{ return(strcmp(a[DB_name],
	     b[DB_name])); }
d1080 2
a1081 1
static BIGNUM *load_serial(char *serialfile)
d1119 3
a1121 1
static int save_serial(char *serialfile, BIGNUM *serial)
d1148 1
a1148 1
	if (out != NULL) BIO_free_all(out);
d1153 15
a1167 6
static int certify(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, TXT_DB *db,
	     BIGNUM *serial, char *subj, int email_dn, char *startdate, char *enddate,
	     long days, int batch, char *ext_sect, CONF *lconf, int verbose,
	     unsigned long certopt, unsigned long nameopt, int default_op,
	     int ext_copy)
d1181 1
a1181 1
	if ((req=PEM_read_bio_X509_REQ(in,NULL,NULL,NULL)) == NULL)
a1197 1
	EVP_PKEY_free(pktmp);
d1213 2
a1214 3
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj, email_dn,
		startdate,enddate,days,batch,verbose,req,ext_sect,lconf,
		certopt, nameopt, default_op, ext_copy);
d1222 15
a1236 6
static int certify_cert(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, TXT_DB *db,
	     BIGNUM *serial, char *subj, int email_dn, char *startdate, char *enddate,
	     long days, int batch, char *ext_sect, CONF *lconf, int verbose,
	     unsigned long certopt, unsigned long nameopt, int default_op,
	     int ext_copy, ENGINE *e)
d1240 1
d1244 5
a1248 1
	if ((req=load_cert(bio_err, infile, FORMAT_PEM, NULL, e, infile)) == NULL)
d1250 6
a1266 1
	EVP_PKEY_free(pktmp);
d1276 1
a1276 1
		BIO_printf(bio_err,"Signature did not match the certificate\n");
d1285 2
a1286 3
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj,email_dn,startdate,enddate,
		days,batch,verbose,rreq,ext_sect,lconf, certopt, nameopt, default_op,
		ext_copy);
d1291 1
d1295 15
a1309 6
static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509, const EVP_MD *dgst,
	     STACK_OF(CONF_VALUE) *policy, TXT_DB *db, BIGNUM *serial, char *subj,
	     int email_dn, char *startdate, char *enddate, long days, int batch,
	     int verbose, X509_REQ *req, char *ext_sect, CONF *lconf,
	     unsigned long certopt, unsigned long nameopt, int default_op,
	     int ext_copy)
d1311 1
a1311 1
	X509_NAME *name=NULL,*CAname=NULL,*subject=NULL, *dn_subject=NULL;
d1319 1
d1325 1
a1325 1
	char buf[25];
d1337 1
a1337 17
	if (subj)
		{
		X509_NAME *n = do_subject(subj, MBSTRING_ASC);

		if (!n)
			{
			ERR_print_errors(bio_err);
			goto err;
			}
		X509_REQ_set_subject_name(req,n);
		req->req_info->enc.modified = 1;
		X509_NAME_free(n);
		}

	if (default_op)
		BIO_printf(bio_err,"The Subject's Distinguished Name is as follows\n");

d1341 3
a1343 1
		ne= X509_NAME_get_entry(name,i);
d1345 6
a1350 1
		obj=X509_NAME_ENTRY_get_object(ne);
d1369 10
a1378 3
		/* If no EMAIL is wanted in the subject */
		if ((OBJ_obj2nid(obj) == NID_pkcs9_emailAddress) && (!email_dn))
			continue;
d1387 5
a1391 1
		if ((str->type != V_ASN1_BMPSTRING) && (str->type != V_ASN1_UTF8STRING))
d1393 15
a1407 9
			j=ASN1_PRINTABLE_type(str->data,str->length);
			if (	((j == V_ASN1_T61STRING) &&
				 (str->type != V_ASN1_T61STRING)) ||
				((j == V_ASN1_IA5STRING) &&
				 (str->type == V_ASN1_PRINTABLESTRING)))
				{
				BIO_printf(bio_err,"\nThe string contains characters that are illegal for the ASN.1 type\n");
				goto err;
				}
d1409 1
a1409 3

		if (default_op)
			old_entry_print(bio_err, obj, str);
d1415 1
a1415 1
		BIO_printf(bio_err,"Memory allocation failure\n");
d1424 1
a1424 1
	for (i=0; i<sk_CONF_VALUE_num(policy); i++)
d1426 1
a1426 1
		cv=sk_CONF_VALUE_value(policy,i); /* get the object id */
d1497 1
a1497 1
					BIO_printf(bio_err,"The %s field needed to be the same in the\nCA certificate (%s) and the request (%s)\n",cv->name,((str2 == NULL)?"NULL":(char *)str2->data),((str == NULL)?"NULL":(char *)str->data));
d1509 2
a1510 1
				if (!X509_NAME_add_entry(subject,push, -1, 0))
d1514 1
a1514 1
					BIO_printf(bio_err,"Memory allocation failure\n");
d1525 1
a1525 2
		/* subject=X509_NAME_dup(X509_REQ_get_subject_name(req)); */
		subject=X509_NAME_dup(name);
d1530 1
a1530 26
		BIO_printf(bio_err,"The subject name appears to be ok, checking data base for clashes\n");

	/* Build the correct Subject if no e-mail is wanted in the subject */
	/* and add it later on because of the method extensions are added (altName) */
	 
	if (email_dn)
		dn_subject = subject;
	else
		{
		X509_NAME_ENTRY *tmpne;
		/* Its best to dup the subject DN and then delete any email
		 * addresses because this retains its structure.
		 */
		if (!(dn_subject = X509_NAME_dup(subject)))
			{
			BIO_printf(bio_err,"Memory allocation failure\n");
			goto err;
			}
		while((i = X509_NAME_get_index_by_NID(dn_subject,
					NID_pkcs9_emailAddress, -1)) >= 0)
			{
			tmpne = X509_NAME_get_entry(dn_subject, i);
			X509_NAME_delete_entry(dn_subject, i);
			X509_NAME_ENTRY_free(tmpne);
			}
		}
d1532 2
a1533 2
	row[DB_name]=X509_NAME_oneline(dn_subject,NULL,0);
	row[DB_serial]=BN_bn2hex(serial);
d1536 1
a1536 1
		BIO_printf(bio_err,"Memory allocation failure\n");
d1569 1
a1569 1
		BIO_printf(bio_err,"Type	  :%s\n",p);;
d1587 1
a1587 1
	/* We are now totally happy, lets make and sign the certificate */
d1604 1
d1606 1
a1607 3
	else ASN1_UTCTIME_set_string(X509_get_notBefore(ret),startdate);

	if (enddate == NULL)
d1609 8
a1616 1
	else ASN1_UTCTIME_set_string(X509_get_notAfter(ret),enddate);
d1621 1
a1621 3
	i = X509_set_pubkey(ret,pktmp);
	EVP_PKEY_free(pktmp);
	if (!i) goto err;
d1624 1
a1624 1
	if (ext_sect)
a1625 1
		X509V3_CTX ctx;
d1632 1
a1632 1
		 * be any I believe */
d1634 1
a1634 2
			sk_X509_EXTENSION_pop_free(ci->extensions,
						   X509_EXTENSION_free);
d1636 2
a1637 1
		ci->extensions = NULL;
d1639 2
a1640 4
		/* Initialize the context structure */
		X509V3_set_ctx(&ctx, x509, ret, req, NULL, 0);

		if (extconf)
d1642 4
a1645 35
			if (verbose)
				BIO_printf(bio_err, "Extra configuration file found\n");
 
			/* Use the extconf configuration db LHASH */
			X509V3_set_nconf(&ctx, extconf);
 
			/* Test the structure (needed?) */
			/* X509V3_set_ctx_test(&ctx); */

			/* Adds exts contained in the configuration file */
			if (!X509V3_EXT_add_nconf(extconf, &ctx, ext_sect,ret))
				{
				BIO_printf(bio_err,
				    "ERROR: adding extensions in section %s\n",
								ext_sect);
				ERR_print_errors(bio_err);
				goto err;
				}
			if (verbose)
				BIO_printf(bio_err, "Successfully added extensions from file.\n");
			}
		else if (ext_sect)
			{
			/* We found extensions to be set from config file */
			X509V3_set_nconf(&ctx, lconf);

			if(!X509V3_EXT_add_nconf(lconf, &ctx, ext_sect, ret))
				{
				BIO_printf(bio_err, "ERROR: adding extensions in section %s\n", ext_sect);
				ERR_print_errors(bio_err);
				goto err;
				}

			if (verbose) 
				BIO_printf(bio_err, "Successfully added extensions from config\n");
a1648 27
	/* Copy extensions from request (if any) */

	if (!copy_extensions(ret, req, ext_copy))
		{
		BIO_printf(bio_err, "ERROR: adding extensions from request\n");
		ERR_print_errors(bio_err);
		goto err;
		}

	/* Set the right value for the noemailDN option */
	if( email_dn == 0 )
		{
		if (!X509_set_subject_name(ret,dn_subject)) goto err;
		}

	if (!default_op)
		{
		BIO_printf(bio_err, "Certificate Details:\n");
		/* Never print signature details because signature not present */
		certopt |= X509_FLAG_NO_SIGDUMP | X509_FLAG_NO_SIGNAME;
		X509_print_ex(bio_err, ret, nameopt, certopt); 
		}

	BIO_printf(bio_err,"Certificate is to be certified until ");
	ASN1_UTCTIME_print(bio_err,X509_get_notAfter(ret));
	if (days) BIO_printf(bio_err," (%d days)",days);
	BIO_printf(bio_err, "\n");
a1651 1

d1653 1
a1653 1
		(void)BIO_flush(bio_err);
d1664 3
a1666 5

#ifndef OPENSSL_NO_DSA
	if (pkey->type == EVP_PKEY_DSA) dgst=EVP_dss1();
	pktmp=X509_get_pubkey(ret);
	if (EVP_PKEY_missing_parameters(pktmp) &&
a1668 1
	EVP_PKEY_free(pktmp);
d1675 1
a1675 1
	row[DB_type]=(char *)OPENSSL_malloc(2);
d1678 1
a1678 1
	row[DB_exp_date]=(char *)OPENSSL_malloc(tm->length+1);
d1685 1
a1685 1
	row[DB_file]=(char *)OPENSSL_malloc(8);
d1691 1
a1691 1
		BIO_printf(bio_err,"Memory allocation failure\n");
d1698 1
a1698 1
	if ((irow=(char **)OPENSSL_malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)
d1700 1
a1700 1
		BIO_printf(bio_err,"Memory allocation failure\n");
d1720 1
a1720 1
		if (row[i] != NULL) OPENSSL_free(row[i]);
a1725 4
	if ((dn_subject != NULL) && !email_dn)
		X509_NAME_free(dn_subject);
	if (tmptm != NULL)
		ASN1_UTCTIME_free(tmptm);
d1736 4
a1739 1
static void write_new_certificate(BIO *bp, X509 *x, int output_der, int notext)
d1741 2
d1749 1
a1749 2
#if 0
	/* ??? Not needed since X509_print prints all this stuff anyway */
d1759 2
a1760 2
#endif
	if (!notext)X509_print(bp,x);
d1762 1
d1765 14
a1778 5
static int certify_spkac(X509 **xret, char *infile, EVP_PKEY *pkey, X509 *x509,
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, TXT_DB *db,
	     BIGNUM *serial, char *subj, int email_dn, char *startdate, char *enddate,
	     long days, char *ext_sect, CONF *lconf, int verbose, unsigned long certopt,
	     unsigned long nameopt, int default_op, int ext_copy)
d1780 1
a1780 1
	STACK_OF(CONF_VALUE) *sk=NULL;
d1785 1
d1809 1
a1809 1
	if (sk_CONF_VALUE_num(sk) == 0)
d1838 1
a1838 1
		if (sk_CONF_VALUE_num(sk) <= i) break;
d1840 1
a1840 1
		cv=sk_CONF_VALUE_value(sk,i);
d1842 1
a1842 10
		/* Skip past any leading X. X: X, etc to allow for
		 * multiple instances
		 */
		for (buf = cv->name; *buf ; buf++)
			if ((*buf == ':') || (*buf == ',') || (*buf == '.'))
				{
				buf++;
				if (*buf) type = buf;
				break;
				}
a1843 1
		buf=cv->value;
d1848 19
a1866 1
				spki = NETSCAPE_SPKI_b64_decode(cv->value, -1);
a1876 5
		/*
		if ((nid == NID_pkcs9_emailAddress) && (email_dn == 0))
			continue;
		*/
		
d1890 2
a1891 1
		if (!X509_NAME_add_entry(n,ne,-1, 0)) goto err;
d1906 1
a1906 1
	if ((pktmp=NETSCAPE_SPKI_get_pubkey(spki)) == NULL)
d1921 2
a1922 4
	EVP_PKEY_free(pktmp);
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj,email_dn,startdate,enddate,
		   days,1,verbose,req,ext_sect,lconf, certopt, nameopt, default_op,
			ext_copy);
d1926 1
d1933 3
a1935 1
static int fix_data(int nid, int *type)
a1949 9
static int check_time_format(char *str)
	{
	ASN1_UTCTIME tm;

	tm.data=(unsigned char *)str;
	tm.length=strlen(str);
	tm.type=V_ASN1_UTCTIME;
	return(ASN1_UTCTIME_check(&tm));
	}
d1951 2
a1952 1
static int do_revoke(X509 *x509, TXT_DB *db, int type, char *value)
d1954 12
a1965 5
	ASN1_UTCTIME *tm=NULL;
	char *row[DB_NUMBER],**rrow,**irow;
	char *rev_str = NULL;
	BIGNUM *bn = NULL;
	int ok=-1,i;
d1967 1
a1967 7
	for (i=0; i<DB_NUMBER; i++)
		row[i]=NULL;
	row[DB_name]=X509_NAME_oneline(X509_get_subject_name(x509),NULL,0);
	bn = ASN1_INTEGER_to_BN(X509_get_serialNumber(x509),NULL);
	row[DB_serial]=BN_bn2hex(bn);
	BN_free(bn);
	if ((row[DB_name] == NULL) || (row[DB_serial] == NULL))
d1969 2
a1970 2
		BIO_printf(bio_err,"Memory allocation failure\n");
		goto err;
a1971 7
	/* We have to lookup by serial number because name lookup
	 * skips revoked certs
 	 */
	rrow=TXT_DB_get_by_index(db,DB_serial,row);
	if (rrow == NULL)
		{
		BIO_printf(bio_err,"Adding Entry to DB for %s\n", row[DB_name]);
d1973 1
a1973 2
		/* We now just add it to the database */
		row[DB_type]=(char *)OPENSSL_malloc(2);
d1975 4
a1978 14
		tm=X509_get_notAfter(x509);
		row[DB_exp_date]=(char *)OPENSSL_malloc(tm->length+1);
		memcpy(row[DB_exp_date],tm->data,tm->length);
		row[DB_exp_date][tm->length]='\0';

		row[DB_rev_date]=NULL;

		/* row[DB_serial] done already */
		row[DB_file]=(char *)OPENSSL_malloc(8);

		/* row[DB_name] done already */

		if ((row[DB_type] == NULL) || (row[DB_exp_date] == NULL) ||
			(row[DB_file] == NULL))
d1980 1
a1980 1
			BIO_printf(bio_err,"Memory allocation failure\n");
a1982 3
		strcpy(row[DB_file],"unknown");
		row[DB_type][0]='V';
		row[DB_type][1]='\0';
d1984 2
a1985 5
		if ((irow=(char **)OPENSSL_malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)
			{
			BIO_printf(bio_err,"Memory allocation failure\n");
			goto err;
			}
d1987 5
a1991 1
		for (i=0; i<DB_NUMBER; i++)
d1993 1
a1993 180
			irow[i]=row[i];
			row[i]=NULL;
			}
		irow[DB_NUMBER]=NULL;

		if (!TXT_DB_insert(db,irow))
			{
			BIO_printf(bio_err,"failed to update database\n");
			BIO_printf(bio_err,"TXT_DB error number %ld\n",db->error);
			goto err;
			}

		/* Revoke Certificate */
		ok = do_revoke(x509,db, type, value);

		goto err;

		}
	else if (index_name_cmp((const char **)row,(const char **)rrow))
		{
		BIO_printf(bio_err,"ERROR:name does not match %s\n",
			   row[DB_name]);
		goto err;
		}
	else if (rrow[DB_type][0]=='R')
		{
		BIO_printf(bio_err,"ERROR:Already revoked, serial number %s\n",
			   row[DB_serial]);
		goto err;
		}
	else
		{
		BIO_printf(bio_err,"Revoking Certificate %s.\n", rrow[DB_serial]);
		rev_str = make_revocation_str(type, value);
		if (!rev_str)
			{
			BIO_printf(bio_err, "Error in revocation arguments\n");
			goto err;
			}
		rrow[DB_type][0]='R';
		rrow[DB_type][1]='\0';
		rrow[DB_rev_date] = rev_str;
		}
	ok=1;
err:
	for (i=0; i<DB_NUMBER; i++)
		{
		if (row[i] != NULL) 
			OPENSSL_free(row[i]);
		}
	return(ok);
	}

static int get_certificate_status(const char *serial, TXT_DB *db)
	{
	char *row[DB_NUMBER],**rrow;
	int ok=-1,i;

	/* Free Resources */
	for (i=0; i<DB_NUMBER; i++)
		row[i]=NULL;

	/* Malloc needed char spaces */
	row[DB_serial] = OPENSSL_malloc(strlen(serial) + 2);
	if (row[DB_serial] == NULL)
		{
		BIO_printf(bio_err,"Malloc failure\n");
		goto err;
		}

	if (strlen(serial) % 2)
		{
		/* Set the first char to 0 */;
		row[DB_serial][0]='0';

		/* Copy String from serial to row[DB_serial] */
		memcpy(row[DB_serial]+1, serial, strlen(serial));
		row[DB_serial][strlen(serial)+1]='\0';
		}
	else
		{
		/* Copy String from serial to row[DB_serial] */
		memcpy(row[DB_serial], serial, strlen(serial));
		row[DB_serial][strlen(serial)]='\0';
		}
			
	/* Make it Upper Case */
	for (i=0; row[DB_serial][i] != '\0'; i++)
		row[DB_serial][i] = toupper(row[DB_serial][i]);
	

	ok=1;

	/* Search for the certificate */
	rrow=TXT_DB_get_by_index(db,DB_serial,row);
	if (rrow == NULL)
		{
		BIO_printf(bio_err,"Serial %s not present in db.\n",
				 row[DB_serial]);
		ok=-1;
		goto err;
		}
	else if (rrow[DB_type][0]=='V')
		{
		BIO_printf(bio_err,"%s=Valid (%c)\n",
			row[DB_serial], rrow[DB_type][0]);
		goto err;
		}
	else if (rrow[DB_type][0]=='R')
		{
		BIO_printf(bio_err,"%s=Revoked (%c)\n",
			row[DB_serial], rrow[DB_type][0]);
		goto err;
		}
	else if (rrow[DB_type][0]=='E')
		{
		BIO_printf(bio_err,"%s=Expired (%c)\n",
			row[DB_serial], rrow[DB_type][0]);
		goto err;
		}
	else if (rrow[DB_type][0]=='S')
		{
		BIO_printf(bio_err,"%s=Suspended (%c)\n",
			row[DB_serial], rrow[DB_type][0]);
		goto err;
		}
	else
		{
		BIO_printf(bio_err,"%s=Unknown (%c).\n",
			row[DB_serial], rrow[DB_type][0]);
		ok=-1;
		}
err:
	for (i=0; i<DB_NUMBER; i++)
		{
		if (row[i] != NULL)
			OPENSSL_free(row[i]);
		}
	return(ok);
	}

static int do_updatedb (TXT_DB *db)
	{
	ASN1_UTCTIME	*a_tm = NULL;
	int i, cnt = 0;
	int db_y2k, a_y2k;  /* flags = 1 if y >= 2000 */ 
	char **rrow, *a_tm_s;

	a_tm = ASN1_UTCTIME_new();

	/* get actual time and make a string */
	a_tm = X509_gmtime_adj(a_tm, 0);
	a_tm_s = (char *) OPENSSL_malloc(a_tm->length+1);
	if (a_tm_s == NULL)
		{
		cnt = -1;
		goto err;
		}

	memcpy(a_tm_s, a_tm->data, a_tm->length);
	a_tm_s[a_tm->length] = '\0';

	if (strncmp(a_tm_s, "49", 2) <= 0)
		a_y2k = 1;
	else
		a_y2k = 0;

	for (i = 0; i < sk_num(db->data); i++)
		{
		rrow = (char **) sk_value(db->data, i);

		if (rrow[DB_type][0] == 'V')
		 	{
			/* ignore entries that are not valid */
			if (strncmp(rrow[DB_exp_date], "49", 2) <= 0)
				db_y2k = 1;
			else
				db_y2k = 0;

			if (db_y2k == a_y2k)
d1995 2
a1996 10
				/* all on the same y2k side */
				if (strcmp(rrow[DB_exp_date], a_tm_s) <= 0)
				       	{
				       	rrow[DB_type][0]  = 'E';
				       	rrow[DB_type][1]  = '\0';
	  				cnt++;

					BIO_printf(bio_err, "%s=Expired\n",
							rrow[DB_serial]);
					}
d1998 7
a2004 5
			else if (db_y2k < a_y2k)
				{
		  		rrow[DB_type][0]  = 'E';
		  		rrow[DB_type][1]  = '\0';
	  			cnt++;
d2006 6
a2011 65
				BIO_printf(bio_err, "%s=Expired\n",
							rrow[DB_serial]);
				}

			}
    		}

err:

	ASN1_UTCTIME_free(a_tm);
	OPENSSL_free(a_tm_s);

	return (cnt);
	}

static char *crl_reasons[] = {
	/* CRL reason strings */
	"unspecified",
	"keyCompromise",
	"CACompromise",
	"affiliationChanged",
	"superseded", 
	"cessationOfOperation",
	"certificateHold",
	"removeFromCRL",
	/* Additional pseudo reasons */
	"holdInstruction",
	"keyTime",
	"CAkeyTime"
};

#define NUM_REASONS (sizeof(crl_reasons) / sizeof(char *))

/* Given revocation information convert to a DB string.
 * The format of the string is:
 * revtime[,reason,extra]. Where 'revtime' is the
 * revocation time (the current time). 'reason' is the
 * optional CRL reason and 'extra' is any additional
 * argument
 */

char *make_revocation_str(int rev_type, char *rev_arg)
	{
	char *reason = NULL, *other = NULL, *str;
	ASN1_OBJECT *otmp;
	ASN1_UTCTIME *revtm = NULL;
	int i;
	switch (rev_type)
		{
	case REV_NONE:
		break;

	case REV_CRL_REASON:
		for (i = 0; i < 8; i++)
			{
			if (!strcasecmp(rev_arg, crl_reasons[i]))
				{
				reason = crl_reasons[i];
				break;
				}
			}
		if (reason == NULL)
			{
			BIO_printf(bio_err, "Unknown CRL reason %s\n", rev_arg);
			return NULL;
a2012 1
		break;
d2014 1
a2014 7
	case REV_HOLD:
		/* Argument is an OID */

		otmp = OBJ_txt2obj(rev_arg, 0);
		ASN1_OBJECT_free(otmp);

		if (otmp == NULL)
d2016 10
a2025 2
			BIO_printf(bio_err, "Invalid object identifier %s\n", rev_arg);
			return NULL;
d2028 1
a2028 82
		reason = "holdInstruction";
		other = rev_arg;
		break;
		
	case REV_KEY_COMPROMISE:
	case REV_CA_COMPROMISE:

		/* Argument is the key compromise time  */
		if (!ASN1_GENERALIZEDTIME_set_string(NULL, rev_arg))
			{	
			BIO_printf(bio_err, "Invalid time format %s. Need YYYYMMDDHHMMSSZ\n", rev_arg);
			return NULL;
			}
		other = rev_arg;
		if (rev_type == REV_KEY_COMPROMISE)
			reason = "keyTime";
		else 
			reason = "CAkeyTime";

		break;

		}

	revtm = X509_gmtime_adj(NULL, 0);

	i = revtm->length + 1;

	if (reason) i += strlen(reason) + 1;
	if (other) i += strlen(other) + 1;

	str = OPENSSL_malloc(i);

	if (!str) return NULL;

	strcpy(str, (char *)revtm->data);
	if (reason)
		{
		strcat(str, ",");
		strcat(str, reason);
		}
	if (other)
		{
		strcat(str, ",");
		strcat(str, other);
		}
	ASN1_UTCTIME_free(revtm);
	return str;
	}

/* Convert revocation field to X509_REVOKED entry 
 * return code:
 * 0 error
 * 1 OK
 * 2 OK and some extensions added (i.e. V2 CRL)
 */


int make_revoked(X509_REVOKED *rev, char *str)
	{
	char *tmp = NULL;
	int reason_code = -1;
	int i, ret = 0;
	ASN1_OBJECT *hold = NULL;
	ASN1_GENERALIZEDTIME *comp_time = NULL;
	ASN1_ENUMERATED *rtmp = NULL;

	ASN1_TIME *revDate = NULL;

	i = unpack_revinfo(&revDate, &reason_code, &hold, &comp_time, str);

	if (i == 0)
		goto err;

	if (rev && !X509_REVOKED_set_revocationDate(rev, revDate))
		goto err;

	if (rev && (reason_code != OCSP_REVOKED_STATUS_NOSTATUS))
		{
		rtmp = ASN1_ENUMERATED_new();
		if (!rtmp || !ASN1_ENUMERATED_set(rtmp, reason_code))
			goto err;
		if (!X509_REVOKED_add1_ext_i2d(rev, NID_crl_reason, rtmp, 0, 0))
d2030 1
d2033 1
a2033 1
	if (rev && comp_time)
d2035 3
a2037 2
		if (!X509_REVOKED_add1_ext_i2d(rev, NID_invalidity_date, comp_time, 0, 0))
			goto err;
d2039 5
a2043 19
	if (rev && hold)
		{
		if (!X509_REVOKED_add1_ext_i2d(rev, NID_hold_instruction_code, hold, 0, 0))
			goto err;
		}

	if (reason_code != OCSP_REVOKED_STATUS_NOSTATUS)
		ret = 2;
	else ret = 1;

	err:

	if (tmp) OPENSSL_free(tmp);
	ASN1_OBJECT_free(hold);
	ASN1_GENERALIZEDTIME_free(comp_time);
	ASN1_ENUMERATED_free(rtmp);
	ASN1_TIME_free(revDate);

	return ret;
d2046 2
a2047 5
/*
 * subject is expected to be in the format /type0=value0/type1=value1/type2=...
 * where characters may be escaped by \
 */
X509_NAME *do_subject(char *subject, long chtype)
d2049 1
a2049 5
	size_t buflen = strlen(subject)+1; /* to copy the types and values into. due to escaping, the copy can only become shorter */
	char *buf = OPENSSL_malloc(buflen);
	size_t max_ne = buflen / 2 + 1; /* maximum number of name elements */
	char **ne_types = OPENSSL_malloc(max_ne * sizeof (char *));
	char **ne_values = OPENSSL_malloc(max_ne * sizeof (char *));
d2051 4
a2054 68
	char *sp = subject, *bp = buf;
	int i, ne_num = 0;

	X509_NAME *n = NULL;
	int nid;

	if (!buf || !ne_types || !ne_values)
	{
		BIO_printf(bio_err, "malloc error\n");
		goto error;
	}

	if (*subject != '/')
	{
		BIO_printf(bio_err, "Subject does not start with '/'.\n");
		goto error;
	}
	sp++; /* skip leading / */

	while (*sp)
	{
		/* collect type */
		ne_types[ne_num] = bp;
		while (*sp)
		{
			if (*sp == '\\') /* is there anything to escape in the type...? */
				if (*++sp)
					*bp++ = *sp++;
				else
				{
					BIO_printf(bio_err, "escape character at end of string\n");
					goto error;
				}
			else if (*sp == '=')
			{
				sp++;
				*bp++ = '\0';
				break;
			}
			else
				*bp++ = *sp++;
		}
		if (!*sp)
		{
			BIO_printf(bio_err, "end of string encountered while processing type of subject name element #%d\n", ne_num);
			goto error;
		}
		ne_values[ne_num] = bp;
		while (*sp)
		{
			if (*sp == '\\')
				if (*++sp)
					*bp++ = *sp++;
				else
				{
					BIO_printf(bio_err, "escape character at end of string\n");
					goto error;
				}
			else if (*sp == '/')
			{
				sp++;
				break;
			}
			else
				*bp++ = *sp++;
		}
		*bp++ = '\0';
		ne_num++;
a2056 195
	if (!(n = X509_NAME_new()))
		goto error;

	for (i = 0; i < ne_num; i++)
		{
		if ((nid=OBJ_txt2nid(ne_types[i])) == NID_undef)
			{
			BIO_printf(bio_err, "Subject Attribute %s has no known NID, skipped\n", ne_types[i]);
			continue;
			}

		if (!*ne_values[i])
			{
			BIO_printf(bio_err, "No value provided for Subject Attribute %s, skipped\n", ne_types[i]);
			continue;
			}

		if (!X509_NAME_add_entry_by_NID(n, nid, chtype, (unsigned char*)ne_values[i], -1,-1,0))
			goto error;
		}

	OPENSSL_free(ne_values);
	OPENSSL_free(ne_types);
	OPENSSL_free(buf);
	return n;

error:
	X509_NAME_free(n);
	if (ne_values)
		OPENSSL_free(ne_values);
	if (ne_types)
		OPENSSL_free(ne_types);
	if (buf)
		OPENSSL_free(buf);
	return NULL;
}

int old_entry_print(BIO *bp, ASN1_OBJECT *obj, ASN1_STRING *str)
	{
	char buf[25],*pbuf, *p;
	int j;
	j=i2a_ASN1_OBJECT(bp,obj);
	pbuf=buf;
	for (j=22-j; j>0; j--)
		*(pbuf++)=' ';
	*(pbuf++)=':';
	*(pbuf++)='\0';
	BIO_puts(bp,buf);

	if (str->type == V_ASN1_PRINTABLESTRING)
		BIO_printf(bp,"PRINTABLE:'");
	else if (str->type == V_ASN1_T61STRING)
		BIO_printf(bp,"T61STRING:'");
	else if (str->type == V_ASN1_IA5STRING)
		BIO_printf(bp,"IA5STRING:'");
	else if (str->type == V_ASN1_UNIVERSALSTRING)
		BIO_printf(bp,"UNIVERSALSTRING:'");
	else
		BIO_printf(bp,"ASN.1 %2d:'",str->type);
			
	p=(char *)str->data;
	for (j=str->length; j>0; j--)
		{
		if ((*p >= ' ') && (*p <= '~'))
			BIO_printf(bp,"%c",*p);
		else if (*p & 0x80)
			BIO_printf(bp,"\\0x%02X",*p);
		else if ((unsigned char)*p == 0xf7)
			BIO_printf(bp,"^?");
		else	BIO_printf(bp,"^%c",*p+'@@');
		p++;
		}
	BIO_printf(bp,"'\n");
	return 1;
	}

int unpack_revinfo(ASN1_TIME **prevtm, int *preason, ASN1_OBJECT **phold, ASN1_GENERALIZEDTIME **pinvtm, char *str)
	{
	char *tmp = NULL;
	char *rtime_str, *reason_str = NULL, *arg_str = NULL, *p;
	int reason_code = -1;
	int i, ret = 0;
	ASN1_OBJECT *hold = NULL;
	ASN1_GENERALIZEDTIME *comp_time = NULL;
	tmp = BUF_strdup(str);

	p = strchr(tmp, ',');

	rtime_str = tmp;

	if (p)
		{
		*p = '\0';
		p++;
		reason_str = p;
		p = strchr(p, ',');
		if (p)
			{
			*p = '\0';
			arg_str = p + 1;
			}
		}

	if (prevtm)
		{
		*prevtm = ASN1_UTCTIME_new();
		if (!ASN1_UTCTIME_set_string(*prevtm, rtime_str))
			{
			BIO_printf(bio_err, "invalid revocation date %s\n", rtime_str);
			goto err;
			}
		}
	if (reason_str)
		{
		for (i = 0; i < NUM_REASONS; i++)
			{
			if(!strcasecmp(reason_str, crl_reasons[i]))
				{
				reason_code = i;
				break;
				}
			}
		if (reason_code == OCSP_REVOKED_STATUS_NOSTATUS)
			{
			BIO_printf(bio_err, "invalid reason code %s\n", reason_str);
			goto err;
			}

		if (reason_code == 7)
			reason_code = OCSP_REVOKED_STATUS_REMOVEFROMCRL;
		else if (reason_code == 8)		/* Hold instruction */
			{
			if (!arg_str)
				{	
				BIO_printf(bio_err, "missing hold instruction\n");
				goto err;
				}
			reason_code = OCSP_REVOKED_STATUS_CERTIFICATEHOLD;
			hold = OBJ_txt2obj(arg_str, 0);

			if (!hold)
				{
				BIO_printf(bio_err, "invalid object identifier %s\n", arg_str);
				goto err;
				}
			if (phold) *phold = hold;
			}
		else if ((reason_code == 9) || (reason_code == 10))
			{
			if (!arg_str)
				{	
				BIO_printf(bio_err, "missing compromised time\n");
				goto err;
				}
			comp_time = ASN1_GENERALIZEDTIME_new();
			if (!ASN1_GENERALIZEDTIME_set_string(comp_time, arg_str))
				{	
				BIO_printf(bio_err, "invalid compromised time %s\n", arg_str);
				goto err;
				}
			if (reason_code == 9)
				reason_code = OCSP_REVOKED_STATUS_KEYCOMPROMISE;
			else
				reason_code = OCSP_REVOKED_STATUS_CACOMPROMISE;
			}
		}

	if (preason) *preason = reason_code;
	if (pinvtm) *pinvtm = comp_time;
	else ASN1_GENERALIZEDTIME_free(comp_time);

	ret = 1;

	err:

	if (tmp) OPENSSL_free(tmp);
	if (!phold) ASN1_OBJECT_free(hold);
	if (!pinvtm) ASN1_GENERALIZEDTIME_free(comp_time);

	return ret;
	}

int make_serial_index(TXT_DB *db)
	{
	if (!TXT_DB_create_index(db, DB_serial, NULL,
				LHASH_HASH_FN(index_serial_hash),
				LHASH_COMP_FN(index_serial_cmp)))
		{
		BIO_printf(bio_err,
		  "error creating serial number index:(%ld,%ld,%ld)\n",
		  			db->error,db->arg1,db->arg2);
			return 0;
		}
	return 1;
	}
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d83 1
a83 5
#  ifdef NO_STRINGS_H
    int	strcasecmp();
#  else
#    include <strings.h>
#  endif /* NO_STRINGS_H */
d1453 1
a1453 1
			BIO_printf(bio_err,"cannot lookup how long until the next CRL is issued\n");
d1459 1
a1459 1
		if (!X509_CRL_set_issuer_name(crl, X509_get_subject_name(x509))) goto err;
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d702 1
a702 1
	pkey = load_key(bio_err, keyfile, keyform, 0, key, e, 
d2092 1
d2094 1
a2094 1
	if (row[DB_serial] == NULL)
d2307 1
a2307 1
	row[DB_name]=X509_NAME_oneline(X509_get_subject_name(ret),NULL,0);
d2310 1
a2310 1
		(row[DB_file] == NULL) || (row[DB_name] == NULL))
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@d67 1
d97 1
a97 1
#  elif !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_WINDOWS)
a101 2
#include "apps.h"

a197 1
#ifndef OPENSSL_NO_ENGINE
a198 1
#endif
a334 1
#ifndef OPENSSL_NO_ENGINE
a335 2
#endif
	char *tofree=NULL;
a537 1
#ifndef OPENSSL_NO_ENGINE
a542 1
#endif
d563 1
a563 3
#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine, 0);
#endif
a565 1
	tofree=NULL;
d570 1
a570 2
		const char *s=X509_get_default_cert_area();

d572 2
a573 2
		tofree=OPENSSL_malloc(strlen(s)+sizeof(CONFIG_FILE));
		strcpy(tofree,s);
d575 4
a578 3
		tofree=OPENSSL_malloc(strlen(s)+sizeof(CONFIG_FILE)+1);
		strcpy(tofree,s);
		strcat(tofree,"/");
d580 2
a581 2
		strcat(tofree,CONFIG_FILE);
		configfile=tofree;
a595 5
	if(tofree)
		{
		OPENSSL_free(tofree);
		tofree = NULL;
		}
d704 1
a704 1
	if (key) OPENSSL_cleanse(key,strlen(key));
d1019 1
a1019 1
			BIO_printf(bio_err, "Successfully loaded extensions file %s\n", extfile);
d1161 3
a1163 8
			if (BN_is_zero(serial))
				BIO_printf(bio_err,"next serial number is 00\n");
			else
				{
				if ((f=BN_bn2hex(serial)) == NULL) goto err;
				BIO_printf(bio_err,"next serial number is %s\n",f);
				OPENSSL_free(f);
				}
d1283 2
a1284 7
			if(strlen(serialfile) > BSIZE-5 || strlen(dbfile) > BSIZE-5)
				{
				BIO_printf(bio_err,"file name too long\n");
				goto err;
				}

			strcpy(buf[0],serialfile);
d1294 2
a1295 1
			strcpy(buf[1],dbfile);
d1325 2
a1326 7
			if(strlen(outdir) >= (size_t)(j ? BSIZE-j*2-6 : BSIZE-8))
				{
				BIO_printf(bio_err,"certificate file name too long\n");
				goto err;
				}

			strcpy(buf[2],outdir);
d1560 2
a1561 7
			if(strlen(dbfile) > BSIZE-5)
				{
				BIO_printf(bio_err,"filename too long\n");
				goto err;
				}

			strcpy(buf[0],dbfile);
a1604 2
	if(tofree)
		OPENSSL_free(tofree);
d1610 1
a1610 2
	if (cert_sk)
		sk_X509_pop_free(cert_sk,X509_free);
d1614 1
a1614 1
	if (free_key && key)
d1624 1
a1624 1
	OPENSSL_EXIT(ret);
d1689 1
a1689 1
		BIO_printf(bio_err,"error converting number from bin to BIGNUM\n");
d2092 1
a2092 4
	if (BN_is_zero(serial))
		row[DB_serial]=BUF_strdup("00");
	else
		row[DB_serial]=BN_bn2hex(serial);
d2155 1
a2155 1
	if (!X509_set_version(ret,2)) goto err;
d2576 1
a2576 4
	if (BN_is_zero(bn))
		row[DB_serial]=BUF_strdup("00");
	else
		row[DB_serial]=BN_bn2hex(bn);
d3045 1
a3045 1
		{
d3049 1
a3049 1
			{
a3050 1
				{
d3054 1
a3054 1
					{
a3056 1
					}
d3059 1
a3059 1
				{
d3063 1
a3063 1
				}
d3066 1
a3066 1
			}
d3068 1
a3068 1
			{
d3071 1
a3071 1
			}
d3074 1
a3074 1
			{
a3075 1
				{
d3079 1
a3079 1
					{
a3081 1
					}
d3084 1
a3084 1
				{
d3087 1
a3087 1
				}
d3090 1
a3090 1
			}
d3093 1
a3093 1
		}
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@a124 1
#define ENV_CRLNUMBER		"crlnumber"
d146 12
d214 7
d222 1
a222 1
		   const EVP_MD *dgst,STACK_OF(CONF_VALUE) *policy,CA_DB *db,
d229 1
a229 1
			CA_DB *db, BIGNUM *serial, char *subj, int email_dn,
d236 1
a236 1
			 CA_DB *db, BIGNUM *serial,char *subj, int email_dn,
d243 1
a243 1
	STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial,char *subj,
d248 3
a250 3
static int do_revoke(X509 *x509, CA_DB *db, int ext, char *extval);
static int get_certificate_status(const char *ser_status, CA_DB *db);
static int do_updatedb(CA_DB *db);
d262 5
a302 1
	char *crlnumberfile=NULL;
a310 1
	BIGNUM *crlnumber=NULL;
d323 1
a323 1
	CA_DB *db=NULL;
d330 1
a341 1
	DB_ATTR db_attr;
a581 1
		size_t len;
d584 1
a584 2
		len = strlen(s)+sizeof(CONFIG_FILE);
		tofree=OPENSSL_malloc(len);
d587 3
a589 4
		len = strlen(s)+sizeof(CONFIG_FILE)+1;
		tofree=OPENSSL_malloc(len);
		BUF_strlcpy(tofree,s,len);
		BUF_strlcat(tofree,"/",len);
d591 1
a591 1
		BUF_strlcat(tofree,CONFIG_FILE,len);
a661 33

	db_attr.unique_subject = 1;
	p = NCONF_get_string(conf, section, "unique_subject");
	if (p)
		{
#ifdef RL_DEBUG
		BIO_printf(bio_err, "DEBUG: unique_subject = \"%s\"\n", p);
#endif
		switch(*p)
			{
		case 'f': /* false */
		case 'F': /* FALSE */
		case 'n': /* no */
		case 'N': /* NO */
			db_attr.unique_subject = 0;
			break;
		case 't': /* true */
		case 'T': /* TRUE */
		case 'y': /* yes */
		case 'Y': /* YES */
		default:
			db_attr.unique_subject = 1;
			break;
			}
		}
#ifdef RL_DEBUG
	else
		BIO_printf(bio_err, "DEBUG: unique_subject undefined\n", p);
#endif
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: configured unique_subject is %d\n",
		db_attr.unique_subject);
#endif
d682 7
a688 1
		db = load_index(dbfile,&db_attr);
d691 2
a692 1
		if (!index_index(db)) goto err;
d852 7
a858 1
	db = load_index(dbfile, &db_attr);
d862 1
a862 1
	for (i=0; i<sk_num(db->db->data); i++)
d864 1
a864 1
		pp=(char **)sk_value(db->db->data,i);
d915 1
a915 1
		TXT_DB_write(out,db->db);
d917 1
a917 1
			db->db->data->num);
d921 11
a931 1
	if (!index_index(db)) goto err;
d954 56
a1009 3
			if (!save_index(dbfile,"new",db)) goto err;
				
			if (!rotate_index(dbfile,"new","old")) goto err;
d1170 1
a1170 1
		if ((serial=load_serial(serialfile, 0, NULL)) == NULL)
d1304 15
a1318 1
			if (!save_serial(serialfile,"new",serial,NULL)) goto err;
d1320 16
a1335 1
			if (!save_index(dbfile, "new", db)) goto err;
d1343 1
a1343 1
			char *n;
d1359 1
a1359 1
			BUF_strlcat(buf[2],"/",sizeof(buf[2]));
d1362 1
a1362 1
			n=(char *)&(buf[2][strlen(buf[2])]);
d1367 1
a1367 5
					if (n >= &(buf[2][sizeof(buf[2])]))
						break;
					BIO_snprintf(n,
						     &buf[2][0] + sizeof(buf[2]) - n,
						     "%02X",(unsigned char)*(p++));
d1393 8
a1400 1
			if (!rotate_serial(serialfile,"new","old")) goto err;
d1402 28
a1429 1
			if (!rotate_index(dbfile,"new","old")) goto err;
d1431 15
a1475 8
		if ((crlnumberfile=NCONF_get_string(conf,section,ENV_CRLNUMBER))
			!= NULL)
			if ((crlnumber=load_serial(crlnumberfile,0,NULL)) == NULL)
				{
				BIO_printf(bio_err,"error while loading CRL number\n");
				goto err;
				}

d1504 1
a1504 1
		for (i=0; i<sk_num(db->db->data); i++)
d1506 1
a1506 1
			pp=(char **)sk_value(db->db->data,i);
d1552 1
a1552 1
		if (crl_ext || crlnumberfile != NULL)
d1558 2
a1559 12
			if (crl_ext)
				if (!X509V3_EXT_CRL_add_nconf(conf, &crlctx,
					crl_ext, crl)) goto err;
			if (crlnumberfile != NULL)
				{
				tmpser = BN_to_ASN1_INTEGER(crlnumber, NULL);
				if (!tmpser) goto err;
				X509_CRL_add1_ext_i2d(crl,NID_crl_number,tmpser,0,0);
				ASN1_INTEGER_free(tmpser);
				crl_v2 = 1;
				if (!BN_add_word(crlnumber,1)) goto err;
				}
a1566 4
		
		if (crlnumberfile != NULL)	/* we have a CRL number that need updating */
			if (!save_serial(crlnumberfile,"new",crlnumber,NULL)) goto err;

a1569 4

		if (crlnumberfile != NULL)	/* Rename the crlnumber file */
			if (!rotate_serial(crlnumberfile,"new","old")) goto err;

d1590 5
a1594 3
			if (!save_index(dbfile, "new", db)) goto err;

			if (!rotate_index(dbfile, "new", "old")) goto err;
d1596 38
d1655 1
a1655 1
	free_index(db);
d1670 98
d1769 1
a1769 1
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, CA_DB *db,
d1831 1
a1831 1
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, CA_DB *db,
d1885 1
a1885 1
	     STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial, char *subj,
d1903 1
a1903 1
	char *row[DB_NUMBER],**rrow=NULL,**irow=NULL;
d2140 2
a2141 1
	if (db->attributes.unique_subject)
d2143 2
a2144 7
		rrow=TXT_DB_get_by_index(db->db,DB_name,row);
		if (rrow != NULL)
			{
			BIO_printf(bio_err,
				"ERROR:There is already a certificate for %s\n",
				row[DB_name]);
			}
d2146 1
a2146 1
	if (rrow == NULL)
d2148 1
a2148 1
		rrow=TXT_DB_get_by_index(db->db,DB_serial,row);
d2355 1
a2355 1
	BUF_strlcpy(row[DB_file],"unknown",8);
d2372 1
a2372 1
	if (!TXT_DB_insert(db->db,irow))
d2375 1
a2375 1
		BIO_printf(bio_err,"TXT_DB error number %ld\n",db->db->error);
d2426 1
a2426 1
	     const EVP_MD *dgst, STACK_OF(CONF_VALUE) *policy, CA_DB *db,
d2605 1
a2605 1
static int do_revoke(X509 *x509, CA_DB *db, int type, char *value)
d2630 1
a2630 1
	rrow=TXT_DB_get_by_index(db->db,DB_serial,row);
d2633 1
a2633 1
		BIO_printf(bio_err,"Adding Entry with serial number %s to DB for %s\n", row[DB_serial], row[DB_name]);
d2656 1
a2656 1
		BUF_strlcpy(row[DB_file],"unknown",8);
d2673 1
a2673 1
		if (!TXT_DB_insert(db->db,irow))
d2676 1
a2676 1
			BIO_printf(bio_err,"TXT_DB error number %ld\n",db->db->error);
d2721 1
a2721 1
static int get_certificate_status(const char *serial, CA_DB *db)
d2762 1
a2762 1
	rrow=TXT_DB_get_by_index(db->db,DB_serial,row);
d2809 1
a2809 1
static int do_updatedb (CA_DB *db)
d2835 1
a2835 1
	for (i = 0; i < sk_num(db->db->data); i++)
d2837 1
a2837 1
		rrow = (char **) sk_value(db->db->data, i);
d2980 1
a2980 1
	BUF_strlcpy(str, (char *)revtm->data, i);
d2983 2
a2984 2
		BUF_strlcat(str, ",", i);
		BUF_strlcat(str, reason, i);
d2988 2
a2989 2
		BUF_strlcat(str, ",", i);
		BUF_strlcat(str, other, i);
d3323 14
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d79 10
a250 1
	int create_ser = 0;
d550 4
a597 4
#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine, 0);
#endif

d669 1
a670 3
		ERR_clear_error();
#ifdef RL_DEBUG
	if (!p)
a1003 13
	if ((md == NULL) && ((md=NCONF_get_string(conf,
		section,ENV_DEFAULT_MD)) == NULL))
		{
		lookup_fail(section,ENV_DEFAULT_MD);
		goto err;
		}

	if ((dgst=EVP_get_digestbyname(md)) == NULL)
		{
		BIO_printf(bio_err,"%s is an unsupported message digest type\n",md);
		goto err;
		}

d1006 6
d1018 5
d1109 1
a1109 1
		if ((serial=load_serial(serialfile, create_ser, NULL)) == NULL)
d1405 10
d1416 3
a1418 2
		if (pkey->type == EVP_PKEY_DSA) 
			dgst=EVP_dss1();
d1420 2
@


1.1.1.8
log
@import of openssl-0.9.7j
@
text
@d946 1
@


1.1.1.9
log
@import of OpenSSL 0.9.8h
@
text
@d86 1
a86 1
#  elif !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_NETWARE)
a107 3
#define STRING_MASK	"string_mask"
#define UTF8_IN			"utf8"

a133 1
#define ENV_UNIQUE_SUBJECT	"unique_subject"
d145 1
a145 1
static const char *ca_usage[]={
a162 1
" -selfsign       - sign a certificate with the key associated with it\n",
a174 2
" -utf8           - input characters are UTF8 (default ASCII)\n",
" -multivalue-rdn - enable support for multivalued RDNs\n",
d192 1
a192 1
static void lookup_fail(const char *name, const char *tag);
d195 1
a195 1
		   BIGNUM *serial, char *subj,unsigned long chtype, int multirdn, int email_dn, char *startdate,
d198 1
a198 1
		   int default_op, int ext_copy, int selfsign);
d201 1
a201 1
			CA_DB *db, BIGNUM *serial, char *subj,unsigned long chtype, int multirdn, int email_dn,
d208 1
a208 1
			 CA_DB *db, BIGNUM *serial,char *subj,unsigned long chtype, int multirdn, int email_dn,
d215 1
a215 1
	STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial,char *subj,unsigned long chtype, int multirdn,
d219 1
a219 1
	int ext_copy, int selfsign);
d225 1
a225 1
int make_revoked(X509_REVOKED *rev, const char *str);
a274 2
	unsigned long chtype = MBSTRING_ASC;
	int multirdn = 0;
d289 1
a289 2
	int selfsign = 0;
	X509 *x509=NULL, *x509p = NULL;
d298 1
a298 2
	char *f;
	const char *p, **pp;
a352 6
		else if (strcmp(*argv,"-utf8") == 0)
			chtype = MBSTRING_UTF8;
		else if (strcmp(*argv,"-create_serial") == 0)
			create_ser = 1;
		else if (strcmp(*argv,"-multivalue-rdn") == 0)
			multirdn=1;
a402 2
		else if (strcmp(*argv,"-selfsign") == 0)
			selfsign=1;
a635 17
	f = NCONF_get_string(conf, section, STRING_MASK);
	if (!f)
		ERR_clear_error();

	if(f && !ASN1_STRING_set_default_mask_asc(f)) {
		BIO_printf(bio_err, "Invalid global string mask setting %s\n", f);
		goto err;
	}

	if (chtype != MBSTRING_UTF8){
		f = NCONF_get_string(conf, section, UTF8_IN);
		if (!f)
			ERR_clear_error();
		else if (!strcmp(f, "yes"))
			chtype = MBSTRING_UTF8;
	}

d637 1
a637 1
	p = NCONF_get_string(conf, section, ENV_UNIQUE_SUBJECT);
d643 16
a658 1
		db_attr.unique_subject = parse_yesno(p,1);
d702 1
a702 1
	/* we definitely need a private key, so let's get it */
d730 2
a731 1
	if (!selfsign || spkac_file || ss_cert_file || gencrl)
d733 7
a739 11
		if ((certfile == NULL)
			&& ((certfile=NCONF_get_string(conf,
				     section,ENV_CERTIFICATE)) == NULL))
			{
			lookup_fail(section,ENV_CERTIFICATE);
			goto err;
			}
		x509=load_cert(bio_err, certfile, FORMAT_PEM, NULL, e,
			"CA certificate");
		if (x509 == NULL)
			goto err;
d741 4
a744 5
		if (!X509_check_private_key(x509,pkey))
			{
			BIO_printf(bio_err,"CA certificate and CA private key do not match\n");
			goto err;
			}
a745 1
	if (!selfsign) x509p = x509;
d859 1
a859 1
		pp=(const char **)sk_value(db->db->data,i);
d872 1
a872 1
		if (!check_time_format((char *)pp[DB_exp_date]))
d1135 1
a1135 1
				serial,subj,chtype,multirdn,email_dn,startdate,enddate,days,extensions,
d1159 1
a1159 1
				db,serial,subj,chtype,multirdn,email_dn,startdate,enddate,days,batch,
d1178 2
a1179 2
			j=certify(&x,infile,pkey,x509p,dgst,attribs,db,
				serial,subj,chtype,multirdn,email_dn,startdate,enddate,days,batch,
d1181 1
a1181 1
				default_op, ext_copy, selfsign);
d1198 2
a1199 2
			j=certify(&x,argv[i],pkey,x509p,dgst,attribs,db,
				serial,subj,chtype,multirdn,email_dn,startdate,enddate,days,batch,
d1201 1
a1201 1
				default_op, ext_copy, selfsign);
d1252 1
a1252 1
			p=(const char *)x->cert_info->serialNumber->data;
d1373 1
a1373 1
			pp=(const char **)sk_value(db->db->data,i);
a1401 5
		else
#endif
#ifndef OPENSSL_NO_ECDSA
		if (pkey->type == EVP_PKEY_EC)
			dgst=EVP_ecdsa();
d1489 1
a1489 1
	if (x509) X509_free(x509);
a1491 1
	NCONF_free(extconf);
d1497 1
a1497 1
static void lookup_fail(const char *name, const char *tag)
d1504 1
a1504 1
	     BIGNUM *serial, char *subj,unsigned long chtype, int multirdn, int email_dn, char *startdate, char *enddate,
d1507 1
a1507 1
	     int ext_copy, int selfsign)
a1531 6
	if (selfsign && !X509_REQ_check_private_key(req,pkey))
		{
		BIO_printf(bio_err,"Certificate request and CA private key do not match\n");
		ok=0;
		goto err;
		}
d1554 1
a1554 1
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj,chtype,multirdn, email_dn,
d1556 1
a1556 1
		certopt, nameopt, default_op, ext_copy, selfsign);
d1566 1
a1566 1
	     BIGNUM *serial, char *subj, unsigned long chtype, int multirdn, int email_dn, char *startdate, char *enddate,
d1608 1
a1608 1
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj,chtype,multirdn,email_dn,startdate,enddate,
d1610 1
a1610 1
		ext_copy, 0);
a1619 1
	     unsigned long chtype, int multirdn,
d1623 1
a1623 1
	     int ext_copy, int selfsign)
d1635 1
a1635 1
	const char *p;
d1652 1
a1652 1
		X509_NAME *n = parse_name(subj, chtype, multirdn);
d1727 1
a1727 4
	if (selfsign)
		CAname=X509_NAME_dup(name);
	else
		CAname=X509_NAME_dup(x509->cert_info->subject);
d1939 2
a1940 10
	if (selfsign)
		{
		if (!X509_set_issuer_name(ret,subject))
			goto err;
		}
	else
		{
		if (!X509_set_issuer_name(ret,X509_get_subject_name(x509)))
			goto err;
		}
d1975 1
a1975 4
		if (selfsign)
			X509V3_set_ctx(&ctx, ret, ret, req, NULL, 0);
		else
			X509V3_set_ctx(&ctx, x509, ret, req, NULL, 0);
d2042 1
a2042 1
	if (days) BIO_printf(bio_err," (%ld days)",days);
a2068 10
#ifndef OPENSSL_NO_ECDSA
	if (pkey->type == EVP_PKEY_EC)
		dgst = EVP_ecdsa();
	pktmp = X509_get_pubkey(ret);
	if (EVP_PKEY_missing_parameters(pktmp) &&
		!EVP_PKEY_missing_parameters(pkey))
		EVP_PKEY_copy_parameters(pktmp, pkey);
	EVP_PKEY_free(pktmp);
#endif

d2165 1
a2165 1
	     BIGNUM *serial, char *subj,unsigned long chtype, int multirdn, int email_dn, char *startdate, char *enddate,
d2306 1
a2306 1
	ok=do_body(xret,pkey,x509,dgst,policy,db,serial,subj,chtype,multirdn,email_dn,startdate,enddate,
d2308 1
a2308 1
			ext_copy, 0);
d2619 1
a2619 1
static const char *crl_reasons[] = {
d2647 1
a2647 2
	char *other = NULL, *str;
	const char *reason = NULL;
d2741 1
a2741 1
int make_revoked(X509_REVOKED *rev, const char *str)
d2795 123
a2943 4
#ifdef CHARSET_EBCDIC
		if ((*p >= 0x20) && (*p <= 0x7e))
			BIO_printf(bp,"%c",os_toebcdic[*p]);
#else
a2945 1
#endif
a2949 3
#ifdef CHARSET_EBCDIC
		else	BIO_printf(bp,"^%c",os_toebcdic[*p+0x40]);
#else
a2950 1
#endif
d2957 1
a2957 1
int unpack_revinfo(ASN1_TIME **prevtm, int *preason, ASN1_OBJECT **phold, ASN1_GENERALIZEDTIME **pinvtm, const char *str)
d2962 1
a2962 2
	int ret = 0;
	unsigned int i;
@


1.1.1.10
log
@import of OpenSSL 0.9.8k
@
text
@d86 1
a86 1
#  elif !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_NETWARE) && !defined(__TANDEM)
@


1.1.1.11
log
@import OpenSSL-1.0.0a
@
text
@d66 1
d86 1
a86 1
#  elif !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_NETWARE)
d219 1
d230 1
a230 1
static int check_time_format(const char *str);
a261 1
	long crlsec=0;
d309 1
a309 2
	const char *p;
	char * const *pp;
a459 5
		else if (strcmp(*argv,"-crlsec") == 0)
			{
			if (--argc < 1) goto bad;
			crlsec = atol(*(++argv));
			}
d553 2
a554 4
		const char **pp2;

		for (pp2=ca_usage; (*pp2 != NULL); pp2++)
			BIO_printf(bio_err,"%s",*pp2);
d829 1
a847 1
#ifndef _WIN32
a848 3
#else
		if (_access(outdir,R_OK|W_OK|X_OK) != 0)
#endif
d855 8
a862 1
		if (app_isdir(outdir)<=0)
d869 1
d883 1
a883 1
	for (i=0; i<sk_OPENSSL_PSTRING_num(db->db->data); i++)
d885 1
a885 1
		pp=sk_OPENSSL_PSTRING_value(db->db->data,i);
d938 1
a938 1
			   sk_OPENSSL_PSTRING_num(db->db->data));
a1028 11
	if (!strcmp(md, "default"))
		{
		int def_nid;
		if (EVP_PKEY_get_default_digest_nid(pkey, &def_nid) <= 0)
			{
			BIO_puts(bio_err,"no default digest\n");
			goto err;
			}
		md = (char *)OBJ_nid2sn(def_nid);
		}

d1098 1
a1098 1
		if (startdate && !ASN1_TIME_set_string(NULL, startdate))
d1100 1
a1100 1
			BIO_printf(bio_err,"start date is invalid, it should be YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ\n");
d1112 1
a1112 1
		if (enddate && !ASN1_TIME_set_string(NULL, enddate))
d1114 1
a1114 1
			BIO_printf(bio_err,"end date is invalid, it should be YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ\n");
d1252 1
a1252 6
				if (!fgets(buf[0],10,stdin))
					{
					BIO_printf(bio_err,"CERTIFICATION CANCELED: I/O error\n"); 
					ret=0;
					goto err;
					}
d1369 1
a1369 1
		if (!crldays && !crlhours && !crlsec)
d1378 1
a1378 1
		if ((crldays == 0) && (crlhours == 0) && (crlsec == 0))
d1392 1
a1392 6
		if (!X509_time_adj_ex(tmptm, crldays, crlhours*60*60 + crlsec,
			NULL))
			{
			BIO_puts(bio_err, "error setting CRL nextUpdate\n");
			goto err;
			}
d1397 1
a1397 1
		for (i=0; i<sk_OPENSSL_PSTRING_num(db->db->data); i++)
d1399 1
a1399 1
			pp=sk_OPENSSL_PSTRING_value(db->db->data,i);
d1425 9
a1465 6
		if (crlnumber)
			{
			BN_free(crlnumber);
			crlnumber = NULL;
			}

a1517 1
	BN_free(crlnumber);
d1676 1
a1676 3
	OPENSSL_STRING row[DB_NUMBER];
	OPENSSL_STRING *irow=NULL;
	OPENSSL_STRING *rrow=NULL;
d1918 1
a1918 3
		OPENSSL_STRING *crow=row;

		rrow=TXT_DB_get_by_index(db->db,DB_name,crow);
d1994 1
a1994 1
	else ASN1_TIME_set_string(X509_get_notBefore(ret),startdate);
d1997 2
a1998 2
		X509_time_adj_ex(X509_get_notAfter(ret),days, 0, NULL);
	else ASN1_TIME_set_string(X509_get_notAfter(ret),enddate);
d2094 1
a2094 1
	ASN1_TIME_print(bio_err,X509_get_notAfter(ret));
d2104 1
a2104 6
		if (!fgets(buf,sizeof(buf)-1,stdin))
			{
			BIO_printf(bio_err,"CERTIFICATE WILL NOT BE CERTIFIED: I/O error\n");
			ok=0;
			goto err;
			}
d2113 3
d2121 11
d2233 1
a2233 1
	LHASH_OF(CONF_VALUE) *parms=NULL;
d2320 16
a2335 2
		if (!X509_NAME_add_entry_by_NID(n, nid, chtype,
				(unsigned char *)buf, -1, -1, 0))
d2337 2
d2381 1
a2381 1
static int check_time_format(const char *str)
d2383 21
a2403 1
	return ASN1_TIME_set_string(NULL, str);
a2417 2
	if (!bn)
		goto err;
d2487 1
a2487 1
	else if (index_name_cmp_noconst(row, rrow))
d2636 1
a2636 1
	for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++)
d2638 1
a2638 1
		rrow = sk_OPENSSL_PSTRING_value(db->db->data, i);
d2885 4
d2891 1
d2896 3
d2900 1
@


1.1.1.12
log
@import OpenSSL-1.0.1c
@
text
@d200 1
a200 2
		   const EVP_MD *dgst,STACK_OF(OPENSSL_STRING) *sigopts,
		   STACK_OF(CONF_VALUE) *policy,CA_DB *db,
d206 1
a206 2
			const EVP_MD *dgst,STACK_OF(OPENSSL_STRING) *sigopts,
			STACK_OF(CONF_VALUE) *policy,
d213 1
a213 2
			 const EVP_MD *dgst,STACK_OF(OPENSSL_STRING) *sigopts,
			 STACK_OF(CONF_VALUE) *policy,
a219 1
	STACK_OF(OPENSSL_STRING) *sigopts,
a313 1
	STACK_OF(OPENSSL_STRING) *sigopts = NULL;
a437 9
		else if (strcmp(*argv,"-sigopt") == 0)
			{
			if (--argc < 1)
				goto bad;
			if (!sigopts)
				sigopts = sk_OPENSSL_STRING_new_null();
			if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))
				goto bad;
			}
d1173 2
a1174 3
			j=certify_spkac(&x,spkac_file,pkey,x509,dgst,sigopts,
				attribs,db, serial,subj,chtype,multirdn,
				email_dn,startdate,enddate,days,extensions,
d1197 1
a1197 2
			j=certify_cert(&x,ss_cert_file,pkey,x509,dgst,sigopts,
				attribs,
d1217 1
a1217 1
			j=certify(&x,infile,pkey,x509p,dgst,sigopts, attribs,db,
d1237 1
a1237 1
			j=certify(&x,argv[i],pkey,x509p,dgst,sigopts,attribs,db,
d1486 1
a1486 1
		if (!do_X509_CRL_sign(bio_err,crl,pkey,dgst,sigopts)) goto err;
a1539 2
	if (sigopts)
		sk_OPENSSL_STRING_free(sigopts);
d1556 2
a1557 4
	     const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
	     STACK_OF(CONF_VALUE) *policy, CA_DB *db,
	     BIGNUM *serial, char *subj,unsigned long chtype, int multirdn,
	     int email_dn, char *startdate, char *enddate,
d1613 1
a1613 2
	ok=do_body(xret,pkey,x509,dgst,sigopts, policy,db,serial,subj,chtype,
		multirdn, email_dn,
d1624 1
a1624 2
	     const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
	     STACK_OF(CONF_VALUE) *policy, CA_DB *db,
d1667 1
a1667 1
	ok=do_body(xret,pkey,x509,dgst,sigopts,policy,db,serial,subj,chtype,multirdn,email_dn,startdate,enddate,
d1678 1
a1678 2
	     STACK_OF(OPENSSL_STRING) *sigopts, STACK_OF(CONF_VALUE) *policy,
             CA_DB *db, BIGNUM *serial, char *subj,
d2149 1
a2149 1
	if (!do_X509_sign(bio_err, ret,pkey,dgst, sigopts))
d2243 1
a2243 2
	     const EVP_MD *dgst, STACK_OF(OPENSSL_STRING) *sigopts,
	     STACK_OF(CONF_VALUE) *policy, CA_DB *db,
d2369 3
a2371 3
	ok=do_body(xret,pkey,x509,dgst,sigopts,policy,db,serial,subj,chtype,
		   multirdn,email_dn,startdate,enddate, days,1,verbose,req,
		   ext_sect,lconf, certopt, nameopt, default_op, ext_copy, 0);
d2539 1
a2539 1
		row[DB_serial][i] = toupper((unsigned char)row[DB_serial][i]);
@


1.1.1.13
log
@Import OpenSSL 1.0.1g
@
text
@a1410 1
			ERR_clear_error();
@


