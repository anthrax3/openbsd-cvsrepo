head	1.43;
access;
symbols
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	butholakala:1.16
	openssl_1_0_1_g:1.1.1.9
	OPENBSD_5_5:1.16.0.12
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	openssl_1_0_1_c:1.1.1.9
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	openssl_1_0_0_f:1.1.1.8
	openssl_1_0_0_e:1.1.1.8
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	openssh_1_0_0_a:1.1.1.7
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	openssl_0_9_8_k:1.1.1.6
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	openssl_0_9_8_j:1.1.1.6
	openssl_0_9_8_h:1.1.1.6
	pre_openssl_0_9_8h:1.11
	OPENBSD_4_4:1.11.0.14
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.12
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.10
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	openssl_0_9_7j:1.1.1.5
	openssl:1.1.1
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.42;
commitid	7A7DObXgY4Fni8xJ;

1.42
date	2014.06.28.04.39.41;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	gGtvlhTlvaxlmOBo;

1.41
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	mJUVYpkFBZ0Zv2bG;

1.40
date	2014.05.26.13.55.24;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.25.20.51.21;	author logan;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.23.16.16.55;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2014.05.02.17.05.41;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.25.13.56.39;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.19.16.46.08;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.19.16.38.04;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.19.13.13.01;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.19.13.09.11;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.19.12.36.03;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.19.00.41.37;	author beck;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.18.14.37.41;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.17.21.45.45;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.20.47.22;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.17.14.24.41;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.14.09.44;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.16.02.50.09;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.13.23.31.37;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.01.22.58.51;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.30.03.58.35;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.06.12.20.16;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.10.10.23.11;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.29.05.39.16;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.31.23.17.08;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.04.06.55.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.56.58;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.15.06.18.30;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.19;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.09;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.09;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.38;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.25;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.30;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.00;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2011.11.03.02.32.07;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: s_socket.c,v 1.42 2014/06/28 04:39:41 deraadt Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <sys/socket.h>

#include <netinet/in.h>

#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "apps.h"

#include <openssl/ssl.h>

#include "s_apps.h"

static int ssl_sock_init(void);
static int init_server(int *sock, int port, int type);
static int init_server_long(int *sock, int port, char *ip, int type);
static int do_accept(int acc_sock, int *sock, char **host);

#define SOCKET_PROTOCOL	IPPROTO_TCP

static int
ssl_sock_init(void)
{
	return (1);
}

int
init_client(int *sock, char *host, char *port, int type, int af)
{
	struct addrinfo hints, *ai_top, *ai;
	int i, s;

	if (!ssl_sock_init())
		return (0);

	memset(&hints, '\0', sizeof(hints));
	hints.ai_family = af;
	hints.ai_socktype = type;

	if ((i = getaddrinfo(host, port, &hints, &ai_top)) != 0) {
		BIO_printf(bio_err, "getaddrinfo: %s\n", gai_strerror(i));
		return (0);
	}
	if (ai_top == NULL || ai_top->ai_addr == NULL) {
		BIO_printf(bio_err, "getaddrinfo returned no addresses\n");
		if (ai_top != NULL) {
			freeaddrinfo(ai_top);
		}
		return (0);
	}
	for (ai = ai_top; ai != NULL; ai = ai->ai_next) {
		s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
		if (s == -1) {
			continue;
		}
		if (type == SOCK_STREAM) {
			i = 0;
			i = setsockopt(s, SOL_SOCKET, SO_KEEPALIVE,
			    (char *) &i, sizeof(i));
			if (i < 0) {
				perror("keepalive");
				close(s);
				return (0);
			}
		}
		if ((i = connect(s, ai->ai_addr, ai->ai_addrlen)) == 0) {
			*sock = s;
			freeaddrinfo(ai_top);
			return (1);
		}
		close(s);
	}

	perror("connect");
	close(s);
	freeaddrinfo(ai_top);
	return (0);
}

int
do_server(int port, int type, int *ret,
    int (*cb) (char *hostname, int s, unsigned char *context),
    unsigned char *context)
{
	int sock;
	char *name = NULL;
	int accept_socket = 0;
	int i;

	if (!init_server(&accept_socket, port, type))
		return (0);

	if (ret != NULL) {
		*ret = accept_socket;
		/* return(1); */
	}
	for (;;) {
		if (type == SOCK_STREAM) {
			if (do_accept(accept_socket, &sock, &name) == 0) {
				shutdown(accept_socket, SHUT_RD);
				close(accept_socket);
				return (0);
			}
		} else
			sock = accept_socket;
		i = (*cb) (name, sock, context);
		free(name);
		if (type == SOCK_STREAM) {
			shutdown(sock, SHUT_RDWR);
			close(sock);
		}
		if (i < 0) {
			shutdown(accept_socket, SHUT_RDWR);
			close(accept_socket);
			return (i);
		}
	}
}

static int
init_server_long(int *sock, int port, char *ip, int type)
{
	int ret = 0;
	struct sockaddr_in server;
	int s = -1;

	if (!ssl_sock_init())
		return (0);

	memset((char *) &server, 0, sizeof(server));
	server.sin_family = AF_INET;
	server.sin_port = htons((unsigned short) port);
	if (ip == NULL)
		server.sin_addr.s_addr = INADDR_ANY;
	else
		memcpy(&server.sin_addr.s_addr, ip, 4);

	if (type == SOCK_STREAM)
		s = socket(AF_INET, SOCK_STREAM, SOCKET_PROTOCOL);
	else			/* type == SOCK_DGRAM */
		s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if (s == -1)
		goto err;
#if defined SOL_SOCKET && defined SO_REUSEADDR
	{
		int j = 1;
		setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
		    (void *) &j, sizeof j);
	}
#endif
	if (bind(s, (struct sockaddr *) & server, sizeof(server)) == -1) {
		perror("bind");
		goto err;
	}
	/* Make it 128 for linux */
	if (type == SOCK_STREAM && listen(s, 128) == -1)
		goto err;
	*sock = s;
	ret = 1;
err:
	if ((ret == 0) && (s != -1)) {
		shutdown(s, SHUT_RD);
		close(s);
	}
	return (ret);
}

static int
init_server(int *sock, int port, int type)
{
	return (init_server_long(sock, port, NULL, type));
}

static int
do_accept(int acc_sock, int *sock, char **host)
{
	int ret;
	struct hostent *h1, *h2;
	static struct sockaddr_in from;
	socklen_t len;
/*	struct linger ling; */

	if (!ssl_sock_init())
		return (0);

redoit:

	memset((char *) &from, 0, sizeof(from));
	len = sizeof(from);
	ret = accept(acc_sock, (struct sockaddr *) & from, &len);
	if (ret == -1) {
		if (errno == EINTR) {
			/* check_timeout(); */
			goto redoit;
		}
		fprintf(stderr, "errno=%d ", errno);
		perror("accept");
		return (0);
	}
/*
	ling.l_onoff=1;
	ling.l_linger=0;
	i=setsockopt(ret,SOL_SOCKET,SO_LINGER,(char *)&ling,sizeof(ling));
	if (i < 0) { perror("linger"); return(0); }
	i=0;
	i=setsockopt(ret,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));
	if (i < 0) { perror("keepalive"); return(0); }
*/

	if (host == NULL)
		goto end;
	h1 = gethostbyaddr((char *) &from.sin_addr.s_addr,
	    sizeof(from.sin_addr.s_addr), AF_INET);
	if (h1 == NULL) {
		BIO_printf(bio_err, "bad gethostbyaddr\n");
		*host = NULL;
		/* return(0); */
	} else {
		if ((*host = strdup(h1->h_name)) == NULL) {
			perror("strdup");
			close(ret);
			return (0);
		}

		h2 = gethostbyname(*host);
		if (h2 == NULL) {
			BIO_printf(bio_err, "gethostbyname failure\n");
			close(ret);
			return (0);
		}
		if (h2->h_addrtype != AF_INET) {
			BIO_printf(bio_err, "gethostbyname addr is not AF_INET\n");
			close(ret);
			return (0);
		}
	}

end:
	*sock = ret;
	return (1);
}

int
extract_host_port(char *str, char **host_ptr, unsigned char *ip,
    char **port_ptr)
{
	char *h, *p;

	h = str;
	p = strrchr(str, '/');	/* IPv6 host/port */
	if (p == NULL) {
		p = strrchr(str, ':');
	}
	if (p == NULL) {
		BIO_printf(bio_err, "no port defined\n");
		return (0);
	}
	*(p++) = '\0';

	if (host_ptr != NULL)
		*host_ptr = h;

	if (port_ptr != NULL && p != NULL && *p != '\0')
		*port_ptr = p;

	return (1);
}

int
extract_port(char *str, short *port_ptr)
{
	int i;
	const char *errstr;
	struct servent *s;

	i = strtonum(str, 1, 65535, &errstr);
	if (!errstr) {
		*port_ptr = (unsigned short) i;
	} else {
		s = getservbyname(str, "tcp");
		if (s == NULL) {
			BIO_printf(bio_err, "getservbyname failure for %s\n", str);
			return (0);
		}
		*port_ptr = ntohs((unsigned short) s->s_port);
	}
	return (1);
}
@


1.42
log
@Use strtonum() instead of atoi(), and then impose what are we think
are the current range checks.  Help from millert and lteo.  Please test
now that it is deployed and let us know if any numbers are off..
ok lteo
@
text
@d1 1
a1 1
/* $OpenBSD: s_socket.c,v 1.41 2014/06/12 15:49:27 deraadt Exp $ */
@


1.41
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d336 1
d339 2
a340 2
	i = atoi(str);
	if (i != 0)
d342 1
a342 1
	else {
@


1.40
log
@There is no need to include <openssl/e_os2.h> here, except for the fact
that it brings in <openssl/opensslconf.h>, so just do that instead
(currently via apps.h).
@
text
@d1 1
a1 1
/* apps/s_socket.c -  socket-related functions used by s_client and s_server */
@


1.39
log
@Fix resource descriptor leaks.

CID: 966576 & 966577

OK from guenther@@ and "Yup. looks good." from tedu@@
@
text
@a71 1
#include <openssl/e_os2.h>
@


1.38
log
@signal.h is not needed here.
@
text
@d125 1
d285 1
d292 1
d297 1
@


1.37
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a64 1
#include <signal.h>
@


1.36
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d170 1
a170 2
		if (name != NULL)
			free(name);
@


1.35
log
@Nuke OPENSSL_NO_SOCK since any half sane operating system has sockets.

ok beck@@
@
text
@d59 7
a68 3
#include <errno.h>
#include <signal.h>
#include <netdb.h>
d70 2
a71 2
#include <sys/socket.h>
#include <netinet/in.h>
d74 1
a75 1
#include "apps.h"
a76 3
#include <openssl/ssl.h>


a83 1

@


1.34
log
@NON_MAIN no longer means anything so remove it, along with APP_INIT.

ok miod@@
@
text
@a74 1
#ifndef OPENSSL_NO_SOCK
a349 1
#endif
@


1.33
log
@remove the openssl_fdset wrapper, and a variety of VMS'ism's like
crazy (void *) casts all over the place
ok beck jsing
@
text
@a70 1
#define NON_MAIN
a71 1
#undef NON_MAIN
@


1.32
log
@Remove a gethostbyname() cache layer.  The internet works better these
days.  Initially fixed this, but Ted asked for it to die.
@
text
@d248 1
a248 1
	int len;
d258 1
a258 7
	/*
	 * Note: under VMS with SOCKETSHR the fourth parameter is currently
	 * of type (int *) whereas under other systems it is (void *) if you
	 * don't have a cast it will choke the compiler: if you do have a
	 * cast then you can either go for (int *) or (void *).
	 */
	ret = accept(acc_sock, (struct sockaddr *) & from, (void *) &len);
@


1.31
log
@Remove hacky workaround for Cray T3E.
ok guenther
@
text
@a79 1
static struct hostent *GetHostByName(char *name);
d298 1
a298 1
		h2 = GetHostByName(*host);
a358 48

#define GHBN_NUM	4
static struct ghbn_cache_st {
	char name[128];
	struct hostent ent;
	unsigned long order;
} ghbn_cache[GHBN_NUM];

static unsigned long ghbn_hits = 0L;
static unsigned long ghbn_miss = 0L;

static struct hostent *
GetHostByName(char *name)
{
	struct hostent *ret;
	int i, lowi = 0;
	unsigned long low = (unsigned long) -1;

	for (i = 0; i < GHBN_NUM; i++) {
		if (low > ghbn_cache[i].order) {
			low = ghbn_cache[i].order;
			lowi = i;
		}
		if (ghbn_cache[i].order > 0) {
			if (strncmp(name, ghbn_cache[i].name, 128) == 0)
				break;
		}
	}
	if (i == GHBN_NUM) {	/* no hit */
		ghbn_miss++;
		ret = gethostbyname(name);
		if (ret == NULL)
			return (NULL);
		/* else add to cache */
		if (strlen(name) < sizeof ghbn_cache[0].name) {
			strlcpy(ghbn_cache[lowi].name, name, sizeof(ghbn_cache[0].name));
			memcpy((char *) &(ghbn_cache[lowi].ent), ret, sizeof(struct hostent));
			ghbn_cache[lowi].order = ghbn_miss + ghbn_hits;
		}
		return (ret);
	} else {
		ghbn_hits++;
		ret = &(ghbn_cache[i].ent);
		ghbn_cache[i].order = ghbn_miss + ghbn_hits;
		return (ret);
	}
}

@


1.30
log
@oops, typo got into change
@
text
@a203 2
/* Added for T3E, address-of fails on bit field (beckman@@acl.lanl.gov) */
#ifndef BIT_FIELD_LIMITS
a204 3
#else
		memcpy(&server.sin_addr, ip, 4);
#endif
a286 2
#ifndef BIT_FIELD_LIMITS
	/* I should use WSAAsyncGetHostByName() under windows */
a288 4
#else
	h1 = gethostbyaddr((char *) &from.sin_addr,
	    sizeof(struct in_addr), AF_INET);
#endif
@


1.29
log
@malloc + strlcpy -> strdup
@
text
@d305 1
a305 1
		if ((*host = strdup(h1->h_name) == NULL) {
@


1.28
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d305 2
a306 2
		if ((*host = (char *) malloc(strlen(h1->h_name) + 1)) == NULL) {
			perror("malloc");
a308 1
		strlcpy(*host, h1->h_name, strlen(h1->h_name) + 1);
@


1.27
log
@Put the final pieces from e_os.h in the required places, and remove it.
"dance on it's grave" says beck
ok guenther beck
@
text
@d309 1
a309 1
		BUF_strlcpy(*host, h1->h_name, strlen(h1->h_name) + 1);
@


1.26
log
@KaboomNF
@
text
@d69 1
a69 5
#ifdef FLAT_INC
#include "e_os2.h"
#else
#include "../e_os2.h"
#endif
a75 6

#ifdef FLAT_INC
#include "e_os.h"
#else
#include "../e_os.h"
#endif
@


1.25
log
@unistd.h exposed after -Wall after e_os.h stops doing so; spotted by matthew
@
text
@a128 1

d137 1
a137 1
			    (char *)&i, sizeof(i));
a147 1

d159 1
a159 1
    int (*cb)(char *hostname, int s, unsigned char *context),
d172 1
a172 1
		/* return(1);*/
d183 1
a183 1
		i = (*cb)(name, sock, context);
d208 1
a208 1
	memset((char *)&server, 0,sizeof(server));
d210 1
a210 1
	server.sin_port = htons((unsigned short)port);
d216 1
a216 1
	memcpy(&server.sin_addr.s_addr, ip, 4);
d218 1
a218 1
	memcpy(&server.sin_addr, ip, 4);
d223 1
a223 1
	else /* type == SOCK_DGRAM */
d235 1
a235 1
	if (bind(s, (struct sockaddr *)&server, sizeof(server)) == -1) {
d272 1
a272 1
	memset((char *)&from, 0, sizeof(from));
d274 5
a278 4
	/* Note: under VMS with SOCKETSHR the fourth parameter is currently
	 * of type (int *) whereas under other systems it is (void *) if
	 * you don't have a cast it will choke the compiler: if you do
	 * have a cast then you can either go for (int *) or (void *).
d280 1
a280 1
	ret = accept(acc_sock, (struct sockaddr *)&from, (void *)&len);
d283 1
a283 1
			/*check_timeout(); */
d286 1
a286 1
		fprintf(stderr,"errno=%d ",errno);
a289 1

d304 1
a304 1
	h1 = gethostbyaddr((char *)&from.sin_addr.s_addr,
d307 1
a307 1
	h1 = gethostbyaddr((char *)&from.sin_addr,
d315 1
a315 1
		if ((*host = (char *)malloc(strlen(h1->h_name) + 1)) == NULL) {
d344 1
a344 1
	p = strrchr(str, '/'); /* IPv6 host/port */
d371 1
a371 1
		*port_ptr = (unsigned short)i;
d378 1
a378 1
		*port_ptr = ntohs((unsigned short)s->s_port);
d394 2
a395 1
GetHostByName(char *name) {
d398 1
a398 1
	unsigned long low = (unsigned long) - 1;
d410 1
a410 2
	if (i == GHBN_NUM) /* no hit*/
	{
d418 1
a418 1
			memcpy((char *)&(ghbn_cache[lowi].ent), ret, sizeof(struct hostent));
@


1.24
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d65 1
@


1.23
log
@dead code
@
text
@d64 3
a73 1
#define USE_SOCKETS
a75 1
#undef USE_SOCKETS
@


1.22
log
@Initial KNF.
@
text
@a360 2
err:
	return (0);
@


1.21
log
@Remove defines for unwanted OS support...

ok miod@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d91 1
a91 1
static int init_server_long(int *sock, int port,char *ip, int type);
d97 9
a105 9


static int ssl_sock_init(void)
	{
	return(1);
	}

int init_client(int *sock, char *host, char *port, int type, int af)
	{
d109 2
a110 1
	if (!ssl_sock_init()) return(0);
d116 2
a117 3
	if ((i = getaddrinfo(host, port, &hints, &ai_top)) != 0)
		{
		BIO_printf(bio_err,"getaddrinfo: %s\n", gai_strerror(i));
d119 5
a124 4
	if (ai_top == NULL || ai_top->ai_addr == NULL)
		{
		BIO_printf(bio_err,"getaddrinfo returned no addresses\n");
		if (ai_top != NULL) { freeaddrinfo(ai_top); }
d126 15
d142 4
a145 10

	for (ai = ai_top; ai != NULL; ai = ai->ai_next)
		{
		s=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
		if (s == -1) { continue; }
	if (type == SOCK_STREAM)
		{
		i=0;
		i=setsockopt(s,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));
		if (i < 0) { perror("keepalive"); return(0); }
a146 2
		if ((i = connect(s, ai->ai_addr, ai->ai_addrlen)) == 0)
			{ *sock=s; freeaddrinfo(ai_top); return (1); }
d149 1
a149 1
		}
d154 2
a155 2
	return(0);
	}
d157 5
a161 2
int do_server(int port, int type, int *ret, int (*cb)(char *hostname, int s, unsigned char *context), unsigned char *context)
	{
d167 2
a168 1
	if (!init_server(&accept_socket,port,type)) return(0);
d170 2
a171 3
	if (ret != NULL)
		{
		*ret=accept_socket;
d173 4
a176 7
		}
  	for (;;)
  		{
		if (type==SOCK_STREAM)
			{
			if (do_accept(accept_socket,&sock,&name) == 0)
				{
d179 1
a179 2
				return(0);
				}
d181 1
a181 1
		else
d183 4
a186 3
		i=(*cb)(name,sock, context);
		if (name != NULL) free(name);
		if (type==SOCK_STREAM) {
d190 1
a190 2
		if (i < 0)
			{
d193 1
a193 2
			return(i);
			}
d196 1
d198 4
a201 3
static int init_server_long(int *sock, int port, char *ip, int type)
	{
	int ret=0;
d203 1
a203 1
	int s= -1;
d205 2
a206 1
	if (!ssl_sock_init()) return(0);
d208 3
a210 3
	memset((char *)&server,0,sizeof(server));
	server.sin_family=AF_INET;
	server.sin_port=htons((unsigned short)port);
d212 1
a212 1
		server.sin_addr.s_addr=INADDR_ANY;
d216 1
a216 1
		memcpy(&server.sin_addr.s_addr,ip,4);
d218 1
a218 1
		memcpy(&server.sin_addr,ip,4);
a219 5
	
		if (type == SOCK_STREAM)
			s=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);
		else /* type == SOCK_DGRAM */
			s=socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
d221 7
a227 1
	if (s == -1) goto err;
d229 1
a229 1
		{
d232 2
a233 2
			   (void *) &j, sizeof j);
		}
d235 1
a235 2
	if (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1)
		{
d238 1
a238 1
		}
d240 4
a243 3
	if (type==SOCK_STREAM && listen(s,128) == -1) goto err;
	*sock=s;
	ret=1;
d245 1
a245 2
	if ((ret == 0) && (s != -1))
		{
a247 7
		}
	return(ret);
	}

static int init_server(int *sock, int port, int type)
	{
	return(init_server_long(sock, port, NULL, type));
d249 2
d252 9
a260 2
static int do_accept(int acc_sock, int *sock, char **host)
	{
d262 1
a262 1
	struct hostent *h1,*h2;
d267 2
a268 1
	if (!ssl_sock_init()) return(0);
d272 2
a273 2
	memset((char *)&from,0,sizeof(from));
	len=sizeof(from);
d279 3
a281 5
	ret=accept(acc_sock,(struct sockaddr *)&from,(void *)&len);
	if (ret == -1)
		{
		if (errno == EINTR)
			{
d284 1
a284 1
			}
d287 2
a288 2
		return(0);
		}
d300 2
a301 1
	if (host == NULL) goto end;
d304 2
a305 2
	h1=gethostbyaddr((char *)&from.sin_addr.s_addr,
		sizeof(from.sin_addr.s_addr),AF_INET);
d307 2
a308 2
	h1=gethostbyaddr((char *)&from.sin_addr,
		sizeof(struct in_addr),AF_INET);
d310 3
a312 4
	if (h1 == NULL)
		{
		BIO_printf(bio_err,"bad gethostbyaddr\n");
		*host=NULL;
d314 4
d319 1
a319 8
	else
		{
		if ((*host=(char *)malloc(strlen(h1->h_name)+1)) == NULL)
			{
			perror("malloc");
			return(0);
			}
		BUF_strlcpy(*host,h1->h_name,strlen(h1->h_name)+1);
d321 8
a328 11
		h2=GetHostByName(*host);
		if (h2 == NULL)
			{
			BIO_printf(bio_err,"gethostbyname failure\n");
			return(0);
			}
		if (h2->h_addrtype != AF_INET)
			{
			BIO_printf(bio_err,"gethostbyname addr is not AF_INET\n");
			return(0);
			}
d330 2
d333 18
a350 2
	*sock=ret;
	return(1);
d352 1
d354 2
a355 16
int extract_host_port(char *str, char **host_ptr, unsigned char *ip,
	     char **port_ptr)
	{
	char *h,*p;

	h=str;
	p=strrchr(str,'/'); /* IPv6 host/port */
	if (p == NULL) { p=strrchr(str,':'); }
	if (p == NULL)
		{
		BIO_printf(bio_err,"no port defined\n");
		return(0);
		}
	*(p++)='\0';

	if (host_ptr != NULL) *host_ptr=h;
d360 1
a360 1
	return(1);
d362 2
a363 2
	return(0);
	}
d365 3
a367 2
int extract_port(char *str, short *port_ptr)
	{
d371 1
a371 1
	i=atoi(str);
d373 6
a378 10
		*port_ptr=(unsigned short)i;
	else
		{
		s=getservbyname(str,"tcp");
		if (s == NULL)
			{
			BIO_printf(bio_err,"getservbyname failure for %s\n",str);
			return(0);
			}
		*port_ptr=ntohs((unsigned short)s->s_port);
d380 1
a380 1
	return(1);
d382 2
d386 1
a386 2
static struct ghbn_cache_st
	{
d390 1
a390 1
	} ghbn_cache[GHBN_NUM];
d392 2
a393 2
static unsigned long ghbn_hits=0L;
static unsigned long ghbn_miss=0L;
d395 2
a396 2
static struct hostent *GetHostByName(char *name)
	{
d398 2
a399 2
	int i,lowi=0;
	unsigned long low= (unsigned long)-1;
d401 7
a407 10
	for (i=0; i<GHBN_NUM; i++)
		{
		if (low > ghbn_cache[i].order)
			{
			low=ghbn_cache[i].order;
			lowi=i;
			}
		if (ghbn_cache[i].order > 0)
			{
			if (strncmp(name,ghbn_cache[i].name,128) == 0)
a408 1
			}
d410 1
d412 1
a412 1
		{
d414 3
a416 2
		ret=gethostbyname(name);
		if (ret == NULL) return(NULL);
d418 4
a421 7
		if(strlen(name) < sizeof ghbn_cache[0].name)
			{
			strlcpy(ghbn_cache[lowi].name,name, sizeof(ghbn_cache[0].name));
			memcpy((char *)&(ghbn_cache[lowi].ent),ret,sizeof(struct hostent));
			ghbn_cache[lowi].order=ghbn_miss+ghbn_hits;
			}
		return(ret);
d423 2
a424 2
	else
		{
d426 3
a428 4
		ret= &(ghbn_cache[i].ent);
		ghbn_cache[i].order=ghbn_miss+ghbn_hits;
		return(ret);
		}
d430 1
@


1.20
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a86 3
#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_BSDSOCK)
#include "netdb.h"
#endif
a88 3
#if defined(OPENSSL_SYS_WINDOWS) || (defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK))
static void ssl_sock_cleanup(void);
#endif
a95 3
#if defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
static int wsa_init_done=0;
#endif
a97 10
#if   defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
static void sock_cleanup(void)
    {
    if (wsa_init_done)
        {
        wsa_init_done=0;
		WSACleanup();
		}
	}
#endif
a100 27
#ifdef WATT32
	extern int _watt_do_exit;
	_watt_do_exit = 0;
	if (sock_init())
		return (0);
#elif defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
   WORD wVerReq;
   WSADATA wsaData;
   int err;

   if (!wsa_init_done)
      {
   
# ifdef SIGINT
      signal(SIGINT,(void (*)(int))sock_cleanup);
# endif

      wsa_init_done=1;
      wVerReq = MAKEWORD( 2, 0 );
      err = WSAStartup(wVerReq,&wsaData);
      if (err != 0)
         {
         BIO_printf(bio_err,"unable to start WINSOCK2, error code=%d\n",err);
         return(0);
         }
      }
#endif /* OPENSSL_SYS_WINDOWS */
a130 1
#ifndef OPENSSL_SYS_MPE
a136 1
#endif
a269 5
#if defined(OPENSSL_SYS_WINDOWS) || (defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK))
		int i;
		i=WSAGetLastError();
		BIO_printf(bio_err,"accept error %d\n",i);
#else
a276 1
#endif
@


1.19
log
@first round of unifdef hammering
@
text
@d225 1
a225 1
		if (name != NULL) OPENSSL_free(name);
d361 1
a361 1
		if ((*host=(char *)OPENSSL_malloc(strlen(h1->h_name)+1)) == NULL)
d363 1
a363 1
			perror("OPENSSL_malloc");
@


1.18
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@a99 3
#ifdef OPENSSL_SYS_WIN16
#define SOCKET_PROTOCOL	0 /* more microsoft stupidity */
#else
a100 1
#endif
a105 35
#ifdef OPENSSL_SYS_WINDOWS
static struct WSAData wsa_state;
static int wsa_init_done=0;

#ifdef OPENSSL_SYS_WIN16
static HWND topWnd=0;
static FARPROC lpTopWndProc=NULL;
static FARPROC lpTopHookProc=NULL;
extern HINSTANCE _hInstance;  /* nice global CRT provides */

static LONG FAR PASCAL topHookProc(HWND hwnd, UINT message, WPARAM wParam,
	     LPARAM lParam)
	{
	if (hwnd == topWnd)
		{
		switch(message)
			{
		case WM_DESTROY:
		case WM_CLOSE:
			SetWindowLong(topWnd,GWL_WNDPROC,(LONG)lpTopWndProc);
			ssl_sock_cleanup();
			break;
			}
		}
	return CallWindowProc(lpTopWndProc,hwnd,message,wParam,lParam);
	}

static BOOL CALLBACK enumproc(HWND hwnd,LPARAM lParam)
	{
	topWnd=hwnd;
	return(FALSE);
	}

#endif /* OPENSSL_SYS_WIN32 */
#endif /* OPENSSL_SYS_WINDOWS */
d107 1
a107 13
#ifdef OPENSSL_SYS_WINDOWS
static void ssl_sock_cleanup(void)
	{
	if (wsa_init_done)
		{
		wsa_init_done=0;
#ifndef OPENSSL_SYS_WINCE
		WSACancelBlockingCall();
#endif
		WSACleanup();
		}
	}
#elif defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
a124 25
#elif defined(OPENSSL_SYS_WINDOWS)
	if (!wsa_init_done)
		{
		int err;
	  
#ifdef SIGINT
		signal(SIGINT,(void (*)(int))ssl_sock_cleanup);
#endif
		wsa_init_done=1;
		memset(&wsa_state,0,sizeof(wsa_state));
		if (WSAStartup(0x0101,&wsa_state)!=0)
			{
			err=WSAGetLastError();
			BIO_printf(bio_err,"unable to start WINSOCK, error code=%d\n",err);
			return(0);
			}

#ifdef OPENSSL_SYS_WIN16
		EnumTaskWindows(GetCurrentTask(),enumproc,0L);
		lpTopWndProc=(FARPROC)GetWindowLong(topWnd,GWL_WNDPROC);
		lpTopHookProc=MakeProcInstance((FARPROC)topHookProc,_hInstance);

		SetWindowLong(topWnd,GWL_WNDPROC,(LONG)lpTopHookProc);
#endif /* OPENSSL_SYS_WIN16 */
		}
a274 1
#ifndef OPENSSL_SYS_WINDOWS
a275 1
#endif
a305 1
#ifndef OPENSSL_SYS_WINDOWS
a306 1
#endif
@


1.17
log
@Remove various horrible socket syscall wrappers, especially SHUTDOWN*
which did shutdown + close, all nasty and surprising.  Use the raw
syscalls that everyone knows the behaviour of.
ok beck matthew
@
text
@a70 9
/* With IPv6, it looks like Digital has mixed up the proper order of
   recursive header file inclusion, resulting in the compiler complaining
   that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which
   is needed to have fileno() declared correctly...  So let's define u_int */
#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__U_INT)
#define __U_INT
typedef unsigned int u_int;
#endif

@


1.16
log
@openssl-1.0.0e: resolve conflicts
@
text
@d261 1
a261 1
		if (s == INVALID_SOCKET) { continue; }
d302 2
a303 1
				SHUTDOWN(accept_socket);
d311 4
a314 2
		if (type==SOCK_STREAM)
			SHUTDOWN2(sock);
d317 2
a318 1
			SHUTDOWN2(accept_socket);
d350 1
a350 1
	if (s == INVALID_SOCKET) goto err;
d372 2
a373 1
		SHUTDOWN(s);
d405 1
a405 1
	if (ret == INVALID_SOCKET)
@


1.15
log
@resolve conflicts, fix local changes
@
text
@d324 1
a324 1
	int s= -1,i;
a362 1
	i=0;
d380 1
a380 1
	int ret,i;
d403 1
a457 1
		i=0;
@


1.14
log
@missing ssl_sock_init() call in init_client() (used by
"openssl s_client"), fix an unlikely memory leak
@
text
@d65 6
d286 1
a286 1
	int accept_socket;
@


1.13
log
@remerge local tweaks, update per-arch configuration headers, update
Makefiles, crank shlib_version
@
text
@d234 2
d240 1
a240 2
	if ((i = getaddrinfo(host, port, &hints, &ai_top)) != 0 ||
	    ai_top == NULL || ai_top->ai_addr == NULL)
d245 6
d265 1
a265 1
			{ *sock=s; freeaddrinfo(ai_top); return (1);}
@


1.12
log
@resolve conflicts
@
text
@d229 1
a229 1
int init_client(int *sock, char *host, int port, int type, int af)
a232 1
	char port_s[NI_MAXSERV];
d238 1
a238 2
	snprintf(port_s, sizeof(port_s), "%d", port);
	if ((i = getaddrinfo(host, port_s, &hints, &ai_top)) != 0 ||
d247 1
a247 1
		s=socket(ai->ai_addr->sa_family, SOCK_STREAM, SOCKET_PROTOCOL);
d257 1
a257 1
		if ((i = connect(s, ai->ai_addr, ai->ai_addr->sa_len)) == 0)
@


1.11
log
@kill strcpy; ok hshoexer@@, prodded by david@@
@
text
@a64 2
#include <openssl/e_os2.h>

d82 12
d95 1
a95 1
#ifdef OPENSSL_SYS_WINDOWS
d99 2
a100 2
static int init_server(int *sock, int port);
static int init_server_long(int *sock, int port,char *ip);
d109 4
d161 9
d204 21
d229 1
a229 1
int init_client(int *sock, char *host, char *port, int af)
d233 1
d237 1
a237 1
	hints.ai_socktype = SOCK_STREAM;
d239 2
a240 1
	if ((i = getaddrinfo(host, port, &hints, &ai_top)) != 0 ||
d252 2
d256 2
a257 1
		if (i == -1) { close(s); continue; }
d271 1
a271 1
int do_server(int port, int *ret, int (*cb)(), char *context)
d274 1
a274 1
	char *name;
d278 1
a278 1
	if (!init_server(&accept_socket,port)) return(0);
d285 9
a293 6
	for (;;)
		{
		if (do_accept(accept_socket,&sock,&name) == 0)
			{
			SHUTDOWN(accept_socket);
			return(0);
d295 2
d299 2
a300 1
		SHUTDOWN2(sock);
d309 1
a309 1
static int init_server_long(int *sock, int port, char *ip)
d329 5
a333 1
	s=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);
d351 1
a351 1
	if (listen(s,128) == -1) goto err;
d363 1
a363 1
static int init_server(int *sock, int port)
d365 1
a365 1
	return(init_server_long(sock, port, NULL));
d392 1
a392 1
#ifdef OPENSSL_SYS_WINDOWS
d557 2
@


1.10
log
@resolve conflicts
@
text
@d484 1
a484 1
			strcpy(ghbn_cache[lowi].name,name);
@


1.9
log
@merge 0.9.7d
@
text
@a153 1
	dbug_init();
@


1.8
log
@support IPv6 connections in "openssl s_client", adding -4 and -6 options to
force protocol; ok itojun@@
@
text
@d381 1
a381 1
		strlcpy(*host,h1->h_name,strlen(h1->h_name)+1);
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@a88 1
static int init_client_ip(int *sock,unsigned char ip[4], int port);
a91 1
static int host_ip(char *str, unsigned char ip[4]);
d186 1
a186 1
int init_client(int *sock, char *host, int port)
d188 2
a189 2
	unsigned char ip[4];
	short p=0;
d191 6
a196 1
	if (!host_ip(host,&(ip[0])))
d198 2
a199 1
		return(0);
a200 24
	if (p != 0) port=p;
	return(init_client_ip(sock,ip,port));
	}

static int init_client_ip(int *sock, unsigned char ip[4], int port)
	{
	unsigned long addr;
	struct sockaddr_in them;
	int s,i;

	if (!ssl_sock_init()) return(0);

	memset((char *)&them,0,sizeof(them));
	them.sin_family=AF_INET;
	them.sin_port=htons((unsigned short)port);
	addr=(unsigned long)
		((unsigned long)ip[0]<<24L)|
		((unsigned long)ip[1]<<16L)|
		((unsigned long)ip[2]<< 8L)|
		((unsigned long)ip[3]);
	them.sin_addr.s_addr=htonl(addr);

	s=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);
	if (s == INVALID_SOCKET) { perror("socket"); return(0); }
d202 4
d207 3
a209 3
	i=0;
	i=setsockopt(s,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));
	if (i < 0) { perror("keepalive"); return(0); }
d211 5
d217 4
a220 4
	if (connect(s,(struct sockaddr *)&them,sizeof(them)) == -1)
		{ close(s); perror("connect"); return(0); }
	*sock=s;
	return(1);
d402 1
a402 1
	     short *port_ptr)
d407 2
a408 1
	p=strchr(str,':');
a415 2
	if ((ip != NULL) && !host_ip(str,ip))
		goto err;
d418 2
a419 6
	if (!extract_port(p,port_ptr))
		goto err;
	return(1);
err:
	return(0);
	}
a420 41
static int host_ip(char *str, unsigned char ip[4])
	{
	unsigned int in[4]; 
	int i;

	if (sscanf(str,"%u.%u.%u.%u",&(in[0]),&(in[1]),&(in[2]),&(in[3])) == 4)
		{
		for (i=0; i<4; i++)
			if (in[i] > 255)
				{
				BIO_printf(bio_err,"invalid IP address\n");
				goto err;
				}
		ip[0]=in[0];
		ip[1]=in[1];
		ip[2]=in[2];
		ip[3]=in[3];
		}
	else
		{ /* do a gethostbyname */
		struct hostent *he;

		if (!ssl_sock_init()) return(0);

		he=GetHostByName(str);
		if (he == NULL)
			{
			BIO_printf(bio_err,"gethostbyname failure\n");
			goto err;
			}
		/* cast to short because of win16 winsock definition */
		if ((short)he->h_addrtype != AF_INET)
			{
			BIO_printf(bio_err,"gethostbyname addr is not AF_INET\n");
			return(0);
			}
		ip[0]=he->h_addr_list[0][0];
		ip[1]=he->h_addr_list[0][1];
		ip[2]=he->h_addr_list[0][2];
		ip[3]=he->h_addr_list[0][3];
		}
@


1.6
log
@more strcpy & sprintf murder; ho ok
@
text
@d86 1
a86 1
static void sock_cleanup(void);
d88 1
a88 1
static int sock_init(void);
d121 1
a121 1
			sock_cleanup();
d138 1
a138 1
static void sock_cleanup(void)
d143 1
d145 1
d151 1
a151 1
static int sock_init(void)
d153 7
a159 1
#ifdef OPENSSL_SYS_WINDOWS
d165 1
a165 1
		signal(SIGINT,(void (*)(int))sock_cleanup);
d207 1
a207 1
	if (!sock_init()) return(0);
d272 1
a272 1
	if (!sock_init()) return(0);
d329 1
a329 1
	if (!sock_init()) return(0);
d459 1
a459 1
		if (!sock_init()) return(0);
d540 6
a545 3
		strncpy(ghbn_cache[lowi].name,name,128);
		memcpy((char *)&(ghbn_cache[lowi].ent),ret,sizeof(struct hostent));
		ghbn_cache[lowi].order=ghbn_miss+ghbn_hits;
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d384 1
a384 1
		strcpy(*host,h1->h_name);
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d65 2
d71 1
a71 1
#if defined(VMS) && defined(__DECC) && !defined(__U_INT)
d85 1
a85 1
#ifdef WINDOWS
d95 1
a95 1
#ifdef WIN16
d101 1
a101 1
#ifdef WINDOWS
d105 1
a105 1
#ifdef WIN16
d134 2
a135 2
#endif /* WIN32 */
#endif /* WINDOWS */
d137 1
a137 1
#ifdef WINDOWS
d151 1
a151 1
#ifdef WINDOWS
d168 1
a168 1
#ifdef WIN16
d174 1
a174 1
#endif /* WIN16 */
d176 1
a176 1
#endif /* WINDOWS */
d214 1
a214 1
#ifndef MPE
d290 1
a290 1
#ifndef WINDOWS
d323 1
a323 1
#ifndef WINDOWS
d337 1
a337 1
#ifdef WINDOWS
@


1.3
log
@OpenSSL 0.9.5a merge
@
text
@d212 1
d216 1
d246 1
a246 1
		if (name != NULL) Free(name);
d377 1
a377 1
		if ((*host=(char *)Malloc(strlen(h1->h_name)+1)) == NULL)
d379 1
a379 1
			perror("Malloc");
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d1 1
a1 1
/* apps/s_socket.c */
d82 3
a84 6
#ifdef VMS
#if (__VMS_VER < 70000000) /* FIONBIO used as a switch to enable ioctl,
			      and that isn't in VMS < 7.0 */
#undef FIONBIO
#endif
#include <processes.h> /* for vfork() */
d86 6
a92 2
static struct hostent *GetHostByName(char *name);
int sock_init(void );
d135 2
a136 1
void sock_cleanup(void)
a137 1
#ifdef WINDOWS
d144 1
a145 1
	}
d147 1
a147 1
int sock_init(void)
d191 1
a191 1
int init_client_ip(int *sock, unsigned char ip[4], int port)
a221 69
int nbio_sock_error(int sock)
	{
	int j,i;
	int size;

	size=sizeof(int);
	/* Note: under VMS with SOCKETSHR the third parameter is currently
	 * of type (int *) whereas under other systems it is (void *) if
	 * you don't have a cast it will choke the compiler: if you do
	 * have a cast then you can either go for (int *) or (void *).
	 */
	i=getsockopt(sock,SOL_SOCKET,SO_ERROR,(char *)&j,(void *)&size);
	if (i < 0)
		return(1);
	else
		return(j);
	}

int nbio_init_client_ip(int *sock, unsigned char ip[4], int port)
	{
	unsigned long addr;
	struct sockaddr_in them;
	int s,i;

	if (!sock_init()) return(0);

	memset((char *)&them,0,sizeof(them));
	them.sin_family=AF_INET;
	them.sin_port=htons((unsigned short)port);
	addr=	(unsigned long)
		((unsigned long)ip[0]<<24L)|
		((unsigned long)ip[1]<<16L)|
		((unsigned long)ip[2]<< 8L)|
		((unsigned long)ip[3]);
	them.sin_addr.s_addr=htonl(addr);

	if (*sock <= 0)
		{
#ifdef FIONBIO
		unsigned long l=1;
#endif

		s=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);
		if (s == INVALID_SOCKET) { perror("socket"); return(0); }

		i=0;
		i=setsockopt(s,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));
		if (i < 0) { perror("keepalive"); return(0); }
		*sock=s;

#ifdef FIONBIO
		BIO_socket_ioctl(s,FIONBIO,&l);
#endif
		}
	else
		s= *sock;

	i=connect(s,(struct sockaddr *)&them,sizeof(them));
	if (i == INVALID_SOCKET)
		{
		if (BIO_sock_should_retry(i))
			return(-1);
		else
			return(0);
		}
	else
		return(1);
	}

d254 1
a254 1
int init_server_long(int *sock, int port, char *ip)
d304 1
a304 1
int init_server(int *sock, int port)
d309 1
a309 1
int do_accept(int acc_sock, int *sock, char **host)
d425 1
a425 1
int host_ip(char *str, unsigned char ip[4])
a540 66

#ifndef MSDOS
int spawn(int argc, char **argv, int *in, int *out)
	{
	int pid;
#define CHILD_READ	p1[0]
#define CHILD_WRITE	p2[1]
#define PARENT_READ	p2[0]
#define PARENT_WRITE	p1[1]
	int p1[2],p2[2];

	if ((pipe(p1) < 0) || (pipe(p2) < 0)) return(-1);

#ifdef VMS
	if ((pid=vfork()) == 0)
#else
	if ((pid=fork()) == 0)
#endif
		{ /* child */
		if (dup2(CHILD_WRITE,fileno(stdout)) < 0)
			perror("dup2");
		if (dup2(CHILD_WRITE,fileno(stderr)) < 0)
			perror("dup2");
		if (dup2(CHILD_READ,fileno(stdin)) < 0)
			perror("dup2");
		close(CHILD_READ); 
		close(CHILD_WRITE);

		close(PARENT_READ);
		close(PARENT_WRITE);
		execvp(argv[0],argv);
		perror("child");
		exit(1);
		}

	/* parent */
	*in= PARENT_READ;
	*out=PARENT_WRITE;
	close(CHILD_READ);
	close(CHILD_WRITE);
	return(pid);
	}
#endif /* MSDOS */


#ifdef undef
	/* Turn on synchronous sockets so that we can do a WaitForMultipleObjects
	 * on sockets */
	{
	SOCKET s;
	int optionValue = SO_SYNCHRONOUS_NONALERT;
	int err;

	err = setsockopt( 
	    INVALID_SOCKET, 
	    SOL_SOCKET, 
	    SO_OPENTYPE, 
	    (char *)&optionValue, 
	    sizeof(optionValue));
	if (err != NO_ERROR) {
	/* failed for some reason... */
		BIO_printf(bio_err, "failed to setsockopt(SO_OPENTYPE, SO_SYNCHRONOUS_ALERT) - %d\n",
			WSAGetLastError());
		}
	}
#endif
@


1.1
log
@Initial revision
@
text
@d64 10
d80 9
a88 1
#include "ssl.h"
a89 1
#ifndef NOPROTO
a91 5
#else
static struct hostent *GetHostByName();
int sock_init();
#endif

d108 2
a109 5
static LONG FAR PASCAL topHookProc(hwnd,message,wParam,lParam)
HWND hwnd;
UINT message;
WPARAM wParam;
LPARAM lParam;
d134 1
a134 1
void sock_cleanup()
d146 1
a146 1
int sock_init()
d177 1
a177 4
int init_client(sock, host, port)
int *sock;
char *host;
int port;
d190 1
a190 4
int init_client_ip(sock, ip, port)
int *sock;
unsigned char ip[4];
int port;
d221 1
a221 2
int nbio_sock_error(sock)
int sock;
d223 2
a224 1
	int j,i,size;
d227 6
a232 1
	i=getsockopt(sock,SOL_SOCKET,SO_ERROR,(char *)&j,&size);
d239 1
a239 4
int nbio_init_client_ip(sock, ip, port)
int *sock;
unsigned char ip[4];
int port;
d259 1
d261 1
d290 1
a290 4
int do_server(port, ret, cb)
int port;
int *ret;
int (*cb)();
d311 1
a311 1
		i=(*cb)(name,sock);
d322 1
a322 4
int init_server_long(sock, port, ip)
int *sock;
int port;
char *ip;
d336 2
d339 3
d345 7
d372 1
a372 3
int init_server(sock,port)
int *sock;
int port;
d377 1
a377 4
int do_accept(acc_sock, sock, host)
int acc_sock;
int *sock;
char **host;
d393 6
a398 1
	ret=accept(acc_sock,(struct sockaddr *)&from,&len);
d468 2
a469 5
int extract_host_port(str,host_ptr,ip,port_ptr)
char *str;
char **host_ptr;
unsigned char *ip;
short *port_ptr;
d493 1
a493 3
int host_ip(str,ip)
char *str;
unsigned char ip[4];
d498 1
a498 1
	if (sscanf(str,"%d.%d.%d.%d",&(in[0]),&(in[1]),&(in[2]),&(in[3])) == 4)
d539 1
a539 3
int extract_port(str,port_ptr)
char *str;
short *port_ptr;
d571 1
a571 2
static struct hostent *GetHostByName(name)
char *name;
d611 1
a611 5
int spawn(argc, argv, in, out)
int argc;
char **argv;
int *in;
int *out;
d622 3
d626 1
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 1
/* apps/s_socket.c -  socket-related functions used by s_client and s_server */
a63 12

#include <openssl/e_os2.h>

/* With IPv6, it looks like Digital has mixed up the proper order of
   recursive header file inclusion, resulting in the compiler complaining
   that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which
   is needed to have fileno() declared correctly...  So let's define u_int */
#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__U_INT)
#define __U_INT
typedef unsigned int u_int;
#endif

d70 1
a70 1
#include <openssl/ssl.h>
d72 1
d74 4
a77 2
#ifdef OPENSSL_SYS_WINDOWS
static void sock_cleanup(void);
a78 6
static int sock_init(void);
static int init_client_ip(int *sock,unsigned char ip[4], int port);
static int init_server(int *sock, int port);
static int init_server_long(int *sock, int port,char *ip);
static int do_accept(int acc_sock, int *sock, char **host);
static int host_ip(char *str, unsigned char ip[4]);
d80 1
a80 1
#ifdef OPENSSL_SYS_WIN16
d86 1
a86 1
#ifdef OPENSSL_SYS_WINDOWS
d90 1
a90 1
#ifdef OPENSSL_SYS_WIN16
d96 5
a100 2
static LONG FAR PASCAL topHookProc(HWND hwnd, UINT message, WPARAM wParam,
	     LPARAM lParam)
d122 2
a123 2
#endif /* OPENSSL_SYS_WIN32 */
#endif /* OPENSSL_SYS_WINDOWS */
d125 1
a125 2
#ifdef OPENSSL_SYS_WINDOWS
static void sock_cleanup(void)
d127 1
d134 1
a135 1
#endif
d137 1
a137 1
static int sock_init(void)
d139 1
a139 1
#ifdef OPENSSL_SYS_WINDOWS
d156 1
a156 1
#ifdef OPENSSL_SYS_WIN16
d162 1
a162 1
#endif /* OPENSSL_SYS_WIN16 */
d164 1
a164 1
#endif /* OPENSSL_SYS_WINDOWS */
d168 4
a171 1
int init_client(int *sock, char *host, int port)
d184 4
a187 1
static int init_client_ip(int *sock, unsigned char ip[4], int port)
a207 1
#ifndef OPENSSL_SYS_MPE
a210 1
#endif
d218 69
a286 1
int do_server(int port, int *ret, int (*cb)(), char *context)
d307 2
a308 2
		i=(*cb)(name,sock, context);
		if (name != NULL) OPENSSL_free(name);
d318 4
a321 1
static int init_server_long(int *sock, int port, char *ip)
a334 2
/* Added for T3E, address-of fails on bit field (beckman@@acl.lanl.gov) */
#ifndef BIT_FIELD_LIMITS
a335 3
#else
		memcpy(&server.sin_addr,ip,4);
#endif
a338 7
#if defined SOL_SOCKET && defined SO_REUSEADDR
		{
		int j = 1;
		setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
			   (void *) &j, sizeof j);
		}
#endif
d341 1
a341 1
#ifndef OPENSSL_SYS_WINDOWS
d359 3
a361 1
static int init_server(int *sock, int port)
d366 4
a369 1
static int do_accept(int acc_sock, int *sock, char **host)
d379 1
a379 1
#ifndef OPENSSL_SYS_WINDOWS
d385 1
a385 6
	/* Note: under VMS with SOCKETSHR the fourth parameter is currently
	 * of type (int *) whereas under other systems it is (void *) if
	 * you don't have a cast it will choke the compiler: if you do
	 * have a cast then you can either go for (int *) or (void *).
	 */
	ret=accept(acc_sock,(struct sockaddr *)&from,(void *)&len);
d388 1
a388 1
#ifdef OPENSSL_SYS_WINDOWS
d430 1
a430 1
		if ((*host=(char *)OPENSSL_malloc(strlen(h1->h_name)+1)) == NULL)
d432 1
a432 1
			perror("OPENSSL_malloc");
d455 5
a459 2
int extract_host_port(char *str, char **host_ptr, unsigned char *ip,
	     short *port_ptr)
d483 3
a485 1
static int host_ip(char *str, unsigned char ip[4])
d490 1
a490 1
	if (sscanf(str,"%u.%u.%u.%u",&(in[0]),&(in[1]),&(in[2]),&(in[3])) == 4)
d531 3
a533 1
int extract_port(char *str, short *port_ptr)
d565 2
a566 1
static struct hostent *GetHostByName(char *name)
d604 66
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d86 1
a86 1
static void ssl_sock_cleanup(void);
d88 1
a88 1
static int ssl_sock_init(void);
d121 1
a121 1
			ssl_sock_cleanup();
d138 1
a138 1
static void ssl_sock_cleanup(void)
a142 1
#ifndef OPENSSL_SYS_WINCE
a143 1
#endif
d149 1
a149 1
static int ssl_sock_init(void)
d151 1
a151 7
#ifdef WATT32
	extern int _watt_do_exit;
	_watt_do_exit = 0;
	dbug_init();
	if (sock_init())
		return (0);
#elif defined(OPENSSL_SYS_WINDOWS)
d157 1
a157 1
		signal(SIGINT,(void (*)(int))ssl_sock_cleanup);
d199 1
a199 1
	if (!ssl_sock_init()) return(0);
d264 1
a264 1
	if (!ssl_sock_init()) return(0);
d321 1
a321 1
	if (!ssl_sock_init()) return(0);
d451 1
a451 1
		if (!ssl_sock_init()) return(0);
d532 3
a534 6
		if(strlen(name) < sizeof ghbn_cache[0].name)
			{
			strcpy(ghbn_cache[lowi].name,name);
			memcpy((char *)&(ghbn_cache[lowi].ent),ret,sizeof(struct hostent));
			ghbn_cache[lowi].order=ghbn_miss+ghbn_hits;
			}
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@d392 1
a392 1
		BUF_strlcpy(*host,h1->h_name,strlen(h1->h_name)+1);
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d156 1
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d65 2
a83 12
#ifdef FLAT_INC
#include "e_os.h"
#else
#include "../e_os.h"
#endif

#ifndef OPENSSL_NO_SOCK

#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_BSDSOCK)
#include "netdb.h"
#endif

d85 1
a85 1
#if defined(OPENSSL_SYS_WINDOWS) || (defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK))
d89 3
a91 3
static int init_client_ip(int *sock,unsigned char ip[4], int port, int type);
static int init_server(int *sock, int port, int type);
static int init_server_long(int *sock, int port,char *ip, int type);
a100 4
#if defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
static int wsa_init_done=0;
#endif

a148 9
#elif defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
static void sock_cleanup(void)
    {
    if (wsa_init_done)
        {
        wsa_init_done=0;
		WSACleanup();
		}
	}
a182 21
#elif defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
   WORD wVerReq;
   WSADATA wsaData;
   int err;

   if (!wsa_init_done)
      {
   
# ifdef SIGINT
      signal(SIGINT,(void (*)(int))sock_cleanup);
# endif

      wsa_init_done=1;
      wVerReq = MAKEWORD( 2, 0 );
      err = WSAStartup(wVerReq,&wsaData);
      if (err != 0)
         {
         BIO_printf(bio_err,"unable to start WINSOCK2, error code=%d\n",err);
         return(0);
         }
      }
d187 1
a187 1
int init_client(int *sock, char *host, int port, int type)
d197 1
a197 1
	return(init_client_ip(sock,ip,port,type));
d200 1
a200 1
static int init_client_ip(int *sock, unsigned char ip[4], int port, int type)
d218 1
a218 5
	if (type == SOCK_STREAM)
		s=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);
	else /* ( type == SOCK_DGRAM) */
		s=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
			
d222 3
a224 6
	if (type == SOCK_STREAM)
		{
		i=0;
		i=setsockopt(s,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));
		if (i < 0) { perror("keepalive"); return(0); }
		}
d233 1
a233 1
int do_server(int port, int type, int *ret, int (*cb)(char *hostname, int s, unsigned char *context), unsigned char *context)
d236 1
a236 1
	char *name = NULL;
d240 1
a240 1
	if (!init_server(&accept_socket,port,type)) return(0);
d247 3
a249 3
  	for (;;)
  		{
		if (type==SOCK_STREAM)
d251 2
a252 5
			if (do_accept(accept_socket,&sock,&name) == 0)
				{
				SHUTDOWN(accept_socket);
				return(0);
				}
a253 2
		else
			sock = accept_socket;
d256 1
a256 2
		if (type==SOCK_STREAM)
			SHUTDOWN2(sock);
d265 1
a265 1
static int init_server_long(int *sock, int port, char *ip, int type)
d285 1
a285 5
	
		if (type == SOCK_STREAM)
			s=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);
		else /* type == SOCK_DGRAM */
			s=socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
d303 1
a303 1
	if (type==SOCK_STREAM && listen(s,128) == -1) goto err;
d315 1
a315 1
static int init_server(int *sock, int port, int type)
d317 1
a317 1
	return(init_server_long(sock, port, NULL, type));
d344 1
a344 1
#if defined(OPENSSL_SYS_WINDOWS) || (defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK))
a554 2

#endif
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@a64 6
#ifdef FLAT_INC
#include "e_os2.h"
#else
#include "../e_os2.h"
#endif

d234 1
d240 1
d269 1
a269 1
#if defined(SO_KEEPALIVE) && !defined(OPENSSL_SYS_MPE)
d279 1
a279 1
		{ closesocket(s); perror("connect"); return(0); }
d288 1
a288 1
	int accept_socket = 0;
@


1.1.1.8
log
@import OpenSSL 1.0.0e
@
text
@d330 1
a330 1
	int s= -1;
d369 1
d387 1
a387 1
	int ret;
a409 1
		int i;
d464 1
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@a240 1
	memset(ip, '\0', sizeof ip);
d242 4
a245 2
		return 0;
	return init_client_ip(sock,ip,port,type);
@


