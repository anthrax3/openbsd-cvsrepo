head	1.28;
access;
symbols
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	butholakala:1.9
	openssl_1_0_1_g:1.1.1.8
	OPENBSD_5_5:1.9.0.16
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.12
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	openssl_1_0_1_c:1.1.1.8
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	openssl_1_0_0_f:1.1.1.8
	openssl_1_0_0_e:1.1.1.8
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	openssh_1_0_0_a:1.1.1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	openssl_0_9_8_k:1.1.1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	openssl_0_9_8_j:1.1.1.6
	openssl_0_9_8_h:1.1.1.5
	pre_openssl_0_9_8h:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	openssl_0_9_7j:1.1.1.4
	openssl:1.1.1
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENSSL_0_9_7D:1.1.1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.1.0.4
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.27;
commitid	7A7DObXgY4Fni8xJ;

1.27
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	EB0l28piqIRSpBUh;

1.26
date	2014.07.12.19.31.21;	author jsing;	state Exp;
branches;
next	1.25;
commitid	X84oGf60c5Z5Yd6T;

1.25
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.24;
commitid	0NuggCO2WJOZj8Kh;

1.24
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	mJUVYpkFBZ0Zv2bG;

1.23
date	2014.06.11.01.53.02;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	4evB2EbwDYaBfe0g;

1.22
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.23.19.09.48;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.22.14.54.13;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.19.00.41.37;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.18.04.17.16;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.20.58.07;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.50;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.09.12.15.19;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.27.05.06.54;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.26.18.06.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.31;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.34.19;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.20.41.28;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.06.27.05.05.29;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.01.09.12.13.49;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.04.06.06.30.00;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: engine.c,v 1.27 2014/07/14 00:35:10 deraadt Exp $ */
/* Written by Richard Levitte <richard@@levitte.org> for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "apps.h"

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#include <openssl/err.h>
#include <openssl/ssl.h>

static const char *engine_usage[] = {
	"usage: engine opts [engine ...]\n",
	" -v[v[v[v]]] - verbose mode, for each engine, list its 'control commands'\n",
	"               -vv will additionally display each command's description\n",
	"               -vvv will also add the input flags for each command\n",
	"               -vvvv will also show internal input flags\n",
	" -c          - for each engine, also list the capabilities\n",
	" -t[t]       - for each engine, check that they are really available\n",
	"               -tt will display error trace for unavailable engines\n",
	" -pre <cmd>  - runs command 'cmd' against the ENGINE before any attempts\n",
	"               to load it (if -t is used)\n",
	" -post <cmd> - runs command 'cmd' against the ENGINE after loading it\n",
	"               (only used if -t is also provided)\n",
	" NB: -pre and -post will be applied to all ENGINEs supplied on the command\n",
	" line, or all supported ENGINEs if none are specified.\n",
	" Eg. '-pre \"SO_PATH:/lib/libdriver.so\"' calls command \"SO_PATH\" with\n",
	" argument \"/lib/libdriver.so\".\n",
	NULL
};

static void
identity(char *ptr)
{
	return;
}

static int
append_buf(char **buf, const char *s, int *size, int step)
{
	int l = strlen(s);

	if (*buf == NULL) {
		*size = step;
		*buf = malloc(*size);
		if (*buf == NULL)
			return 0;
		**buf = '\0';
	}
	if (**buf != '\0')
		l += 2;		/* ", " */

	if (strlen(*buf) + strlen(s) >= (unsigned int) *size) {
		*size += step;
		*buf = realloc(*buf, *size);
	}
	if (*buf == NULL)
		return 0;

	if (**buf != '\0')
		strlcat(*buf, ", ", *size);
	strlcat(*buf, s, *size);

	return 1;
}

static int
util_flags(BIO * bio_out, unsigned int flags, const char *indent)
{
	int started = 0, err = 0;
	/* Indent before displaying input flags */
	BIO_printf(bio_out, "%s%s(input flags): ", indent, indent);
	if (flags == 0) {
		BIO_printf(bio_out, "<no flags>\n");
		return 1;
	}
	/*
	 * If the object is internal, mark it in a way that shows instead of
	 * having it part of all the other flags, even if it really is.
	 */
	if (flags & ENGINE_CMD_FLAG_INTERNAL) {
		BIO_printf(bio_out, "[Internal] ");
	}
	if (flags & ENGINE_CMD_FLAG_NUMERIC) {
		BIO_printf(bio_out, "NUMERIC");
		started = 1;
	}
	/*
	 * Now we check that no combinations of the mutually exclusive
	 * NUMERIC, STRING, and NO_INPUT flags have been used. Future flags
	 * that can be OR'd together with these would need to added after
	 * these to preserve the testing logic.
	 */
	if (flags & ENGINE_CMD_FLAG_STRING) {
		if (started) {
			BIO_printf(bio_out, "|");
			err = 1;
		}
		BIO_printf(bio_out, "STRING");
		started = 1;
	}
	if (flags & ENGINE_CMD_FLAG_NO_INPUT) {
		if (started) {
			BIO_printf(bio_out, "|");
			err = 1;
		}
		BIO_printf(bio_out, "NO_INPUT");
		started = 1;
	}
	/* Check for unknown flags */
	flags = flags & ~ENGINE_CMD_FLAG_NUMERIC &
	    ~ENGINE_CMD_FLAG_STRING &
	    ~ENGINE_CMD_FLAG_NO_INPUT &
	    ~ENGINE_CMD_FLAG_INTERNAL;
	if (flags) {
		if (started)
			BIO_printf(bio_out, "|");
		BIO_printf(bio_out, "<0x%04X>", flags);
	}
	if (err)
		BIO_printf(bio_out, "  <illegal flags!>");
	BIO_printf(bio_out, "\n");
	return 1;
}

static int
util_verbose(ENGINE * e, int verbose, BIO * bio_out, const char *indent)
{
	static const int line_wrap = 78;
	int num;
	int ret = 0;
	char *name = NULL;
	char *desc = NULL;
	int flags;
	int xpos = 0;
	STACK_OF(OPENSSL_STRING) * cmds = NULL;
	if (!ENGINE_ctrl(e, ENGINE_CTRL_HAS_CTRL_FUNCTION, 0, NULL, NULL) ||
	    ((num = ENGINE_ctrl(e, ENGINE_CTRL_GET_FIRST_CMD_TYPE,
			0, NULL, NULL)) <= 0)) {
#if 0
		BIO_printf(bio_out, "%s<no control commands>\n", indent);
#endif
		return 1;
	}
	cmds = sk_OPENSSL_STRING_new_null();

	if (!cmds)
		goto err;
	do {
		int len;
		/* Get the command input flags */
		if ((flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num,
			    NULL, NULL)) < 0)
			goto err;
		if (!(flags & ENGINE_CMD_FLAG_INTERNAL) || verbose >= 4) {
			/* Get the command name */
			if ((len = ENGINE_ctrl(e, ENGINE_CTRL_GET_NAME_LEN_FROM_CMD, num,
				    NULL, NULL)) <= 0)
				goto err;
			if ((name = malloc(len + 1)) == NULL)
				goto err;
			if (ENGINE_ctrl(e, ENGINE_CTRL_GET_NAME_FROM_CMD, num, name,
				NULL) <= 0)
				goto err;
			/* Get the command description */
			if ((len = ENGINE_ctrl(e, ENGINE_CTRL_GET_DESC_LEN_FROM_CMD, num,
				    NULL, NULL)) < 0)
				goto err;
			if (len > 0) {
				if ((desc = malloc(len + 1)) == NULL)
					goto err;
				if (ENGINE_ctrl(e, ENGINE_CTRL_GET_DESC_FROM_CMD, num, desc,
					NULL) <= 0)
					goto err;
			}
			/* Now decide on the output */
			if (xpos == 0)
				/* Do an indent */
				xpos = BIO_puts(bio_out, indent);
			else
				/* Otherwise prepend a ", " */
				xpos += BIO_printf(bio_out, ", ");
			if (verbose == 1) {
				/* We're just listing names, comma-delimited */
				if ((xpos > (int) strlen(indent)) &&
				    (xpos + (int) strlen(name) > line_wrap)) {
					BIO_printf(bio_out, "\n");
					xpos = BIO_puts(bio_out, indent);
				}
				xpos += BIO_printf(bio_out, "%s", name);
			} else {
				/* We're listing names plus descriptions */
				BIO_printf(bio_out, "%s: %s\n", name,
				    (desc == NULL) ? "<no description>" : desc);
				/* ... and sometimes input flags */
				if ((verbose >= 3) && !util_flags(bio_out, flags,
					indent))
					goto err;
				xpos = 0;
			}
		}
		free(name);
		name = NULL;
		free(desc);
		desc = NULL;

		/* Move to the next command */
		num = ENGINE_ctrl(e, ENGINE_CTRL_GET_NEXT_CMD_TYPE,
		    num, NULL, NULL);
	} while (num > 0);
	if (xpos > 0)
		BIO_printf(bio_out, "\n");
	ret = 1;
err:
	if (cmds)
		sk_OPENSSL_STRING_pop_free(cmds, identity);
	free(name);
	free(desc);
	return ret;
}

static void
util_do_cmds(ENGINE * e, STACK_OF(OPENSSL_STRING) * cmds,
    BIO * bio_out, const char *indent)
{
	int loop, res, num = sk_OPENSSL_STRING_num(cmds);

	if (num < 0) {
		BIO_printf(bio_out, "[Error]: internal stack error\n");
		return;
	}
	for (loop = 0; loop < num; loop++) {
		char buf[256];
		const char *cmd, *arg;
		cmd = sk_OPENSSL_STRING_value(cmds, loop);
		res = 1;	/* assume success */
		/* Check if this command has no ":arg" */
		if ((arg = strstr(cmd, ":")) == NULL) {
			if (!ENGINE_ctrl_cmd_string(e, cmd, NULL, 0))
				res = 0;
		} else {
			if ((int) (arg - cmd) > 254) {
				BIO_printf(bio_out, "[Error]: command name too long\n");
				return;
			}
			memcpy(buf, cmd, (int) (arg - cmd));
			buf[arg - cmd] = '\0';
			arg++;	/* Move past the ":" */
			/* Call the command with the argument */
			if (!ENGINE_ctrl_cmd_string(e, buf, arg, 0))
				res = 0;
		}
		if (res)
			BIO_printf(bio_out, "[Success]: %s\n", cmd);
		else {
			BIO_printf(bio_out, "[Failure]: %s\n", cmd);
			ERR_print_errors(bio_out);
		}
	}
}

int engine_main(int, char **);

int
engine_main(int argc, char **argv)
{
	int ret = 1, i;
	const char **pp;
	int verbose = 0, list_cap = 0, test_avail = 0, test_avail_noise = 0;
	ENGINE *e;
	STACK_OF(OPENSSL_STRING) * engines = sk_OPENSSL_STRING_new_null();
	STACK_OF(OPENSSL_STRING) * pre_cmds = sk_OPENSSL_STRING_new_null();
	STACK_OF(OPENSSL_STRING) * post_cmds = sk_OPENSSL_STRING_new_null();
	int badops = 1;
	BIO *bio_out = NULL;
	const char *indent = "     ";

	bio_out = BIO_new_fp(stdout, BIO_NOCLOSE);

	argc--;
	argv++;
	while (argc >= 1) {
		if (strncmp(*argv, "-v", 2) == 0) {
			if (strspn(*argv + 1, "v") < strlen(*argv + 1))
				goto skip_arg_loop;
			if ((verbose = strlen(*argv + 1)) > 4)
				goto skip_arg_loop;
		} else if (strcmp(*argv, "-c") == 0)
			list_cap = 1;
		else if (strncmp(*argv, "-t", 2) == 0) {
			test_avail = 1;
			if (strspn(*argv + 1, "t") < strlen(*argv + 1))
				goto skip_arg_loop;
			if ((test_avail_noise = strlen(*argv + 1) - 1) > 1)
				goto skip_arg_loop;
		} else if (strcmp(*argv, "-pre") == 0) {
			argc--;
			argv++;
			if (argc == 0)
				goto skip_arg_loop;
			sk_OPENSSL_STRING_push(pre_cmds, *argv);
		} else if (strcmp(*argv, "-post") == 0) {
			argc--;
			argv++;
			if (argc == 0)
				goto skip_arg_loop;
			sk_OPENSSL_STRING_push(post_cmds, *argv);
		} else if ((strncmp(*argv, "-h", 2) == 0) ||
		    (strcmp(*argv, "-?") == 0))
			goto skip_arg_loop;
		else
			sk_OPENSSL_STRING_push(engines, *argv);
		argc--;
		argv++;
	}
	/* Looks like everything went OK */
	badops = 0;
skip_arg_loop:

	if (badops) {
		for (pp = engine_usage; (*pp != NULL); pp++)
			BIO_printf(bio_err, "%s", *pp);
		goto end;
	}
	if (sk_OPENSSL_STRING_num(engines) == 0) {
		for (e = ENGINE_get_first(); e != NULL; e = ENGINE_get_next(e)) {
			sk_OPENSSL_STRING_push(engines, (char *) ENGINE_get_id(e));
		}
	}
	for (i = 0; i < sk_OPENSSL_STRING_num(engines); i++) {
		const char *id = sk_OPENSSL_STRING_value(engines, i);
		if ((e = ENGINE_by_id(id)) != NULL) {
			const char *name = ENGINE_get_name(e);
			/* Do "id" first, then "name". Easier to auto-parse. */
			BIO_printf(bio_out, "(%s) %s\n", id, name);
			util_do_cmds(e, pre_cmds, bio_out, indent);
			if (strcmp(ENGINE_get_id(e), id) != 0) {
				BIO_printf(bio_out, "Loaded: (%s) %s\n",
				    ENGINE_get_id(e), ENGINE_get_name(e));
			}
			if (list_cap) {
				int cap_size = 256;
				char *cap_buf = NULL;
				int k, n;
				const int *nids;
				ENGINE_CIPHERS_PTR fn_c;
				ENGINE_DIGESTS_PTR fn_d;
				ENGINE_PKEY_METHS_PTR fn_pk;

				if (ENGINE_get_RSA(e) != NULL
				    && !append_buf(&cap_buf, "RSA",
					&cap_size, 256))
					goto end;
				if (ENGINE_get_DSA(e) != NULL
				    && !append_buf(&cap_buf, "DSA",
					&cap_size, 256))
					goto end;
				if (ENGINE_get_DH(e) != NULL
				    && !append_buf(&cap_buf, "DH",
					&cap_size, 256))
					goto end;
				if (ENGINE_get_RAND(e) != NULL
				    && !append_buf(&cap_buf, "RAND",
					&cap_size, 256))
					goto end;

				fn_c = ENGINE_get_ciphers(e);
				if (!fn_c)
					goto skip_ciphers;
				n = fn_c(e, NULL, &nids, 0);
				for (k = 0; k < n; ++k)
					if (!append_buf(&cap_buf,
						OBJ_nid2sn(nids[k]),
						&cap_size, 256))
						goto end;

		skip_ciphers:
				fn_d = ENGINE_get_digests(e);
				if (!fn_d)
					goto skip_digests;
				n = fn_d(e, NULL, &nids, 0);
				for (k = 0; k < n; ++k)
					if (!append_buf(&cap_buf,
						OBJ_nid2sn(nids[k]),
						&cap_size, 256))
						goto end;

		skip_digests:
				fn_pk = ENGINE_get_pkey_meths(e);
				if (!fn_pk)
					goto skip_pmeths;
				n = fn_pk(e, NULL, &nids, 0);
				for (k = 0; k < n; ++k)
					if (!append_buf(&cap_buf,
						OBJ_nid2sn(nids[k]),
						&cap_size, 256))
						goto end;
		skip_pmeths:
				if (cap_buf && (*cap_buf != '\0'))
					BIO_printf(bio_out, " [%s]\n", cap_buf);

				free(cap_buf);
			}
			if (test_avail) {
				BIO_printf(bio_out, "%s", indent);
				if (ENGINE_init(e)) {
					BIO_printf(bio_out, "[ available ]\n");
					util_do_cmds(e, post_cmds, bio_out, indent);
					ENGINE_finish(e);
				} else {
					BIO_printf(bio_out, "[ unavailable ]\n");
					if (test_avail_noise)
						ERR_print_errors_fp(stdout);
					ERR_clear_error();
				}
			}
			if ((verbose > 0) && !util_verbose(e, verbose, bio_out, indent))
				goto end;
			ENGINE_free(e);
		} else
			ERR_print_errors(bio_err);
	}

	ret = 0;
end:

	ERR_print_errors(bio_err);
	sk_OPENSSL_STRING_pop_free(engines, identity);
	sk_OPENSSL_STRING_pop_free(pre_cmds, identity);
	sk_OPENSSL_STRING_pop_free(post_cmds, identity);
	if (bio_out != NULL)
		BIO_free_all(bio_out);

	return (ret);
}
#endif
@


1.27
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: engine.c,v 1.26 2014/07/12 19:31:21 jsing Exp $ */
@


1.26
log
@In openssl_startup(), call SSL_library_init() and SSL_load_error_strings().
This allows us to remove the ERR_load_crypto_strings() call, along with
the various SSL_load_error_strings() and OpenSSL_add_ssl_algorithms()
calls scattered around the place.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: engine.c,v 1.25 2014/07/12 17:54:31 jsing Exp $ */
d90 1
a90 1
static void 
d96 1
a96 1
static int 
d125 1
a125 1
static int 
d184 1
a184 1
static int 
d280 1
a280 1
static void 
d322 1
a322 1
int 
d491 1
a491 1
	
@


1.25
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: engine.c,v 1.24 2014/06/12 15:49:27 deraadt Exp $ */
a334 2

	SSL_load_error_strings();
@


1.24
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a336 3

	if (!load_config(bio_err, NULL))
		goto end;
@


1.23
log
@c-file-style hints, begone; ok beck
@
text
@d1 1
a1 1
/* apps/engine.c */
@


1.22
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@d1 1
a1 1
/* apps/engine.c -*- mode: C; c-file-style: "eay" -*- */
@


1.21
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a335 1
	signal(SIGPIPE, SIG_IGN);
@


1.20
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d262 3
a264 4
		if (desc) {
			free(desc);
			desc = NULL;
		}
d275 2
a276 4
	if (name)
		free(name);
	if (desc)
		free(desc);
@


1.19
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@a58 1

d62 1
d64 1
a64 1
#include <openssl/err.h>
d67 1
a68 1

@


1.18
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a341 3
	if (bio_err == NULL)
		bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);

d344 1
@


1.17
log
@Unifdef -UPEDANTIC. ok beck@@ tedu@@
@
text
@d339 1
a339 1
	apps_startup();
d502 1
a502 1
	apps_shutdown();
@


1.16
log
@Nuke the last of the windows related defines from the openssl apps.

ok deraadt@@
@
text
@a504 6
#else

#if PEDANTIC
static void *dummy = &dummy;
#endif

@


1.15
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@a62 3
#ifdef OPENSSL_NO_STDIO
#define APPS_WIN16
#endif
@


1.14
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d122 2
a123 2
		BUF_strlcat(*buf, ", ", *size);
	BUF_strlcat(*buf, s, *size);
@


1.13
log
@KaboomNF
@
text
@a71 2
#undef PROG
#define PROG	engine_main
d326 1
a326 1
int MAIN(int, char **);
d329 1
a329 1
MAIN(int argc, char **argv)
@


1.12
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d75 18
a92 18
static const char *engine_usage[]={
"usage: engine opts [engine ...]\n",
" -v[v[v[v]]] - verbose mode, for each engine, list its 'control commands'\n",
"               -vv will additionally display each command's description\n",
"               -vvv will also add the input flags for each command\n",
"               -vvvv will also show internal input flags\n",
" -c          - for each engine, also list the capabilities\n",
" -t[t]       - for each engine, check that they are really available\n",
"               -tt will display error trace for unavailable engines\n",
" -pre <cmd>  - runs command 'cmd' against the ENGINE before any attempts\n",
"               to load it (if -t is used)\n",
" -post <cmd> - runs command 'cmd' against the ENGINE after loading it\n",
"               (only used if -t is also provided)\n",
" NB: -pre and -post will be applied to all ENGINEs supplied on the command\n",
" line, or all supported ENGINEs if none are specified.\n",
" Eg. '-pre \"SO_PATH:/lib/libdriver.so\"' calls command \"SO_PATH\" with\n",
" argument \"/lib/libdriver.so\".\n",
NULL
d95 3
a97 2
static void identity(char *ptr)
	{
d99 1
a99 1
	}
d101 3
a103 2
static int append_buf(char **buf, const char *s, int *size, int step)
	{
d106 1
a106 2
	if (*buf == NULL)
		{
d112 1
a112 2
		}

d116 1
a116 2
	if (strlen(*buf) + strlen(s) >= (unsigned int)*size)
		{
d119 1
a119 2
		}

d128 1
a128 1
	}
d130 3
a132 2
static int util_flags(BIO *bio_out, unsigned int flags, const char *indent)
	{
d136 1
a136 2
	if(flags == 0)
		{
d139 6
a144 5
		}
        /* If the object is internal, mark it in a way that shows instead of
         * having it part of all the other flags, even if it really is. */
	if(flags & ENGINE_CMD_FLAG_INTERNAL)
		{
d146 2
a147 4
		}

	if(flags & ENGINE_CMD_FLAG_NUMERIC)
		{
d150 9
a158 9
		}
	/* Now we check that no combinations of the mutually exclusive NUMERIC,
	 * STRING, and NO_INPUT flags have been used. Future flags that can be
	 * OR'd together with these would need to added after these to preserve
	 * the testing logic. */
	if(flags & ENGINE_CMD_FLAG_STRING)
		{
		if(started)
			{
d161 1
a161 1
			}
d164 3
a166 5
		}
	if(flags & ENGINE_CMD_FLAG_NO_INPUT)
		{
		if(started)
			{
d169 1
a169 1
			}
d172 1
a172 1
		}
d175 6
a180 6
			~ENGINE_CMD_FLAG_STRING &
			~ENGINE_CMD_FLAG_NO_INPUT &
			~ENGINE_CMD_FLAG_INTERNAL;
	if(flags)
		{
		if(started) BIO_printf(bio_out, "|");
d182 2
a183 2
		}
	if(err)
d187 1
a187 1
	}
d189 3
a191 2
static int util_verbose(ENGINE *e, int verbose, BIO *bio_out, const char *indent)
	{
d199 4
a202 5
	STACK_OF(OPENSSL_STRING) *cmds = NULL;
	if(!ENGINE_ctrl(e, ENGINE_CTRL_HAS_CTRL_FUNCTION, 0, NULL, NULL) ||
			((num = ENGINE_ctrl(e, ENGINE_CTRL_GET_FIRST_CMD_TYPE,
					0, NULL, NULL)) <= 0))
		{
d207 1
a207 2
		}

d210 1
a210 1
	if(!cmds)
d215 2
a216 2
		if((flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num,
					NULL, NULL)) < 0)
d218 53
a270 55
                if (!(flags & ENGINE_CMD_FLAG_INTERNAL) || verbose >= 4)
                        {
                        /* Get the command name */
                        if((len = ENGINE_ctrl(e, ENGINE_CTRL_GET_NAME_LEN_FROM_CMD, num,
                                NULL, NULL)) <= 0)
                                goto err;
                        if((name = malloc(len + 1)) == NULL)
                                goto err;
                        if(ENGINE_ctrl(e, ENGINE_CTRL_GET_NAME_FROM_CMD, num, name,
                                NULL) <= 0)
                                goto err;
                        /* Get the command description */
                        if((len = ENGINE_ctrl(e, ENGINE_CTRL_GET_DESC_LEN_FROM_CMD, num,
                                NULL, NULL)) < 0)
                                goto err;
                        if(len > 0)
                                {
                                if((desc = malloc(len + 1)) == NULL)
                                        goto err;
                                if(ENGINE_ctrl(e, ENGINE_CTRL_GET_DESC_FROM_CMD, num, desc,
                                        NULL) <= 0)
                                        goto err;
                                }
                        /* Now decide on the output */
                        if(xpos == 0)
                                /* Do an indent */
                                xpos = BIO_puts(bio_out, indent);
                        else
                                /* Otherwise prepend a ", " */
                                xpos += BIO_printf(bio_out, ", ");
                        if(verbose == 1)
                                {
                                /* We're just listing names, comma-delimited */
                                if((xpos > (int)strlen(indent)) &&
					(xpos + (int)strlen(name) > line_wrap))
                                        {
                                        BIO_printf(bio_out, "\n");
                                        xpos = BIO_puts(bio_out, indent);
                                        }
                                xpos += BIO_printf(bio_out, "%s", name);
                                }
                        else
                                {
                                /* We're listing names plus descriptions */
                                BIO_printf(bio_out, "%s: %s\n", name,
                                        (desc == NULL) ? "<no description>" : desc);
                                /* ... and sometimes input flags */
                                if((verbose >= 3) && !util_flags(bio_out, flags,
                                        indent))
                                        goto err;
                                xpos = 0;
                                }
                        }
		free(name); name = NULL;
		if(desc) { free(desc); desc = NULL; }
d273 3
a275 3
					num, NULL, NULL);
		} while(num > 0);
	if(xpos > 0)
d279 6
a284 3
	if(cmds) sk_OPENSSL_STRING_pop_free(cmds, identity);
	if(name) free(name);
	if(desc) free(desc);
d286 1
a286 1
	}
d288 4
a291 3
static void util_do_cmds(ENGINE *e, STACK_OF(OPENSSL_STRING) *cmds,
			BIO *bio_out, const char *indent)
	{
d294 1
a294 2
	if(num < 0)
		{
d297 2
a298 3
		}
	for(loop = 0; loop < num; loop++)
		{
d302 1
a302 1
		res = 1; /* assume success */
d304 2
a305 3
		if((arg = strstr(cmd, ":")) == NULL)
			{
			if(!ENGINE_ctrl_cmd_string(e, cmd, NULL, 0))
d307 4
d312 3
a314 10
		else
			{
			if((int)(arg - cmd) > 254)
				{
				BIO_printf(bio_out,"[Error]: command name too long\n");
				return;
				}
			memcpy(buf, cmd, (int)(arg - cmd));
			buf[arg-cmd] = '\0';
			arg++; /* Move past the ":" */
d316 1
a316 1
			if(!ENGINE_ctrl_cmd_string(e, buf, arg, 0))
d318 2
a319 2
			}
		if(res)
d321 1
a321 2
		else
			{
a323 1
			}
d326 1
d330 4
a333 3
int MAIN(int argc, char **argv)
	{
	int ret=1,i;
d335 1
a335 1
	int verbose=0, list_cap=0, test_avail=0, test_avail_noise = 0;
d337 5
a341 5
	STACK_OF(OPENSSL_STRING) *engines = sk_OPENSSL_STRING_new_null();
	STACK_OF(OPENSSL_STRING) *pre_cmds = sk_OPENSSL_STRING_new_null();
	STACK_OF(OPENSSL_STRING) *post_cmds = sk_OPENSSL_STRING_new_null();
	int badops=1;
	BIO *bio_out=NULL;
d348 1
a348 1
		bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
d352 1
a352 1
	bio_out=BIO_new_fp(stdout,BIO_NOCLOSE);
d356 3
a358 5
	while (argc >= 1)
		{
		if (strncmp(*argv,"-v",2) == 0)
			{
			if(strspn(*argv + 1, "v") < strlen(*argv + 1))
d360 1
a360 1
			if((verbose=strlen(*argv + 1)) > 4)
d362 5
a366 7
			}
		else if (strcmp(*argv,"-c") == 0)
			list_cap=1;
		else if (strncmp(*argv,"-t",2) == 0)
			{
			test_avail=1;
			if(strspn(*argv + 1, "t") < strlen(*argv + 1))
d368 1
a368 1
			if((test_avail_noise = strlen(*argv + 1) - 1) > 1)
d370 3
a372 4
			}
		else if (strcmp(*argv,"-pre") == 0)
			{
			argc--; argv++;
d375 4
a378 5
			sk_OPENSSL_STRING_push(pre_cmds,*argv);
			}
		else if (strcmp(*argv,"-post") == 0)
			{
			argc--; argv++;
d381 3
a383 4
			sk_OPENSSL_STRING_push(post_cmds,*argv);
			}
		else if ((strncmp(*argv,"-h",2) == 0) ||
				(strcmp(*argv,"-?") == 0))
d386 1
a386 1
			sk_OPENSSL_STRING_push(engines,*argv);
d389 1
a389 1
		}
d394 3
a396 4
	if (badops)
		{
		for (pp=engine_usage; (*pp != NULL); pp++)
			BIO_printf(bio_err,"%s",*pp);
d398 4
d403 4
a406 14

	if (sk_OPENSSL_STRING_num(engines) == 0)
		{
		for(e = ENGINE_get_first(); e != NULL; e = ENGINE_get_next(e))
			{
			sk_OPENSSL_STRING_push(engines,(char *)ENGINE_get_id(e));
			}
		}

	for (i=0; i<sk_OPENSSL_STRING_num(engines); i++)
		{
		const char *id = sk_OPENSSL_STRING_value(engines,i);
		if ((e = ENGINE_by_id(id)) != NULL)
			{
d411 1
a411 2
			if (strcmp(ENGINE_get_id(e), id) != 0)
				{
d413 3
a415 4
					ENGINE_get_id(e), ENGINE_get_name(e));
				}
			if (list_cap)
				{
d418 1
a418 1
				int k,n;
d425 2
a426 2
					&& !append_buf(&cap_buf, "RSA",
						&cap_size, 256))
d429 2
a430 2
					&& !append_buf(&cap_buf, "DSA",
						&cap_size, 256))
d433 2
a434 2
					&& !append_buf(&cap_buf, "DH",
						&cap_size, 256))
d437 2
a438 2
					&& !append_buf(&cap_buf, "RAND",
						&cap_size, 256))
d442 2
a443 1
				if(!fn_c) goto skip_ciphers;
d445 4
a448 4
				for(k=0 ; k < n ; ++k)
					if(!append_buf(&cap_buf,
						       OBJ_nid2sn(nids[k]),
						       &cap_size, 256))
d451 1
a451 1
skip_ciphers:
d453 2
a454 1
				if(!fn_d) goto skip_digests;
d456 4
a459 4
				for(k=0 ; k < n ; ++k)
					if(!append_buf(&cap_buf,
						       OBJ_nid2sn(nids[k]),
						       &cap_size, 256))
d462 1
a462 1
skip_digests:
d464 2
a465 1
				if(!fn_pk) goto skip_pmeths;
d467 4
a470 4
				for(k=0 ; k < n ; ++k)
					if(!append_buf(&cap_buf,
						       OBJ_nid2sn(nids[k]),
						       &cap_size, 256))
d472 1
a472 1
skip_pmeths:
d477 2
a478 3
				}
			if(test_avail)
				{
d480 1
a480 2
				if (ENGINE_init(e))
					{
d484 1
a484 3
					}
				else
					{
d486 1
a486 1
					if(test_avail_noise)
a488 1
					}
d490 2
a491 1
			if((verbose > 0) && !util_verbose(e, verbose, bio_out, indent))
d494 1
a494 2
			}
		else
d496 1
a496 1
		}
d498 1
a498 1
	ret=0;
d505 2
a506 1
	if (bio_out != NULL) BIO_free_all(bio_out);
d508 2
a509 2
	return(ret);
	}
d512 3
a514 3
# if PEDANTIC
static void *dummy=&dummy;
# endif
@


1.11
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d535 1
a535 1
	OPENSSL_EXIT(ret);
@


1.10
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d107 1
a107 1
		*buf = OPENSSL_malloc(*size);
d119 1
a119 1
		*buf = OPENSSL_realloc(*buf, *size);
d230 1
a230 1
                        if((name = OPENSSL_malloc(len + 1)) == NULL)
d241 1
a241 1
                                if((desc = OPENSSL_malloc(len + 1)) == NULL)
d277 2
a278 2
		OPENSSL_free(name); name = NULL;
		if(desc) { OPENSSL_free(desc); desc = NULL; }
d288 2
a289 2
	if(name) OPENSSL_free(name);
	if(desc) OPENSSL_free(desc);
d499 1
a499 1
				OPENSSL_free(cap_buf);
@


1.9
log
@resolve conflicts, fix local changes
@
text
@a362 6
#ifdef OPENSSL_SYS_VMS
	{
	BIO *tmpbio = BIO_new(BIO_f_linebuffer());
	bio_out = BIO_push(tmpbio, bio_out);
	}
#endif
@


1.8
log
@resolve conflicts
@
text
@d95 1
a95 1
static void identity(void *ptr)
a150 5
		if(started)
			{
			BIO_printf(bio_out, "|");
			err = 1;
			}
d203 1
a203 1
	STACK *cmds = NULL;
d214 1
a214 1
	cmds = sk_new_null();
d287 1
a287 1
	if(cmds) sk_pop_free(cmds, identity);
d293 2
a294 1
static void util_do_cmds(ENGINE *e, STACK *cmds, BIO *bio_out, const char *indent)
d296 2
a297 1
	int loop, res, num = sk_num(cmds);
d307 1
a307 1
		cmd = sk_value(cmds, loop);
d347 3
a349 3
	STACK *engines = sk_new_null();
	STACK *pre_cmds = sk_new_null();
	STACK *post_cmds = sk_new_null();
d396 1
a396 1
			sk_push(pre_cmds,*argv);
d403 1
a403 1
			sk_push(post_cmds,*argv);
d409 1
a409 1
			sk_push(engines,*argv);
d424 1
a424 1
	if (sk_num(engines) == 0)
d428 1
a428 1
			sk_push(engines,(char *)ENGINE_get_id(e));
d432 1
a432 1
	for (i=0; i<sk_num(engines); i++)
d434 1
a434 1
		const char *id = sk_value(engines,i);
d454 1
d493 9
d536 3
a538 3
	sk_pop_free(engines, identity);
	sk_pop_free(pre_cmds, identity);
	sk_pop_free(post_cmds, identity);
@


1.7
log
@resolve conflicts
@
text
@d255 1
a255 1
                                xpos = BIO_printf(bio_out, indent);
d266 1
a266 1
                                        xpos = BIO_printf(bio_out, indent);
@


1.6
log
@resolve conflicts
@
text
@a58 1
#ifndef OPENSSL_NO_ENGINE
d68 1
@


1.5
log
@resolve conflicts
@
text
@d75 1
a75 1
static char *engine_usage[]={
d82 2
a83 1
" -t          - for each engine, check that they are really available\n",
d347 2
a348 2
	char **pp;
	int verbose=0, list_cap=0, test_avail=0;
d386 2
a387 1
		else if (strcmp(*argv,"-t") == 0)
d389 5
d512 2
a513 1
					ERR_print_errors_fp(stdout);
d527 1
@


1.4
log
@merge 0.9.7d
@
text
@d390 2
d397 2
@


1.3
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d125 2
a126 2
		strlcat(*buf, ", ", *size);
	strlcat(*buf, s, *size);
@


1.2
log
@string cleaning; ok tedu
@
text
@d59 2
d521 1
a521 1
	EXIT(ret);
d523 7
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d123 2
a124 2
		strcat(*buf, ", ");
	strcat(*buf, s);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@a58 2
#ifndef OPENSSL_NO_ENGINE

d519 1
a519 1
	OPENSSL_EXIT(ret);
a520 7
#else

# if PEDANTIC
static void *dummy=&dummy;
# endif

#endif
@


1.1.1.3
log
@import openssl-0.9.7d
@
text
@d125 2
a126 2
		BUF_strlcat(*buf, ", ", *size);
	BUF_strlcat(*buf, s, *size);
@


1.1.1.4
log
@import of openssl-0.9.7j
@
text
@a389 2
			if (argc == 0)
				goto skip_arg_loop;
a394 2
			if (argc == 0)
				goto skip_arg_loop;
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@d75 1
a75 1
static const char *engine_usage[]={
d82 1
a82 2
" -t[t]       - for each engine, check that they are really available\n",
"               -tt will display error trace for unavailable engines\n",
d346 2
a347 2
	const char **pp;
	int verbose=0, list_cap=0, test_avail=0, test_avail_noise = 0;
d385 1
a385 2
		else if (strncmp(*argv,"-t",2) == 0)
			{
a386 5
			if(strspn(*argv + 1, "t") < strlen(*argv + 1))
				goto skip_arg_loop;
			if((test_avail_noise = strlen(*argv + 1) - 1) > 1)
				goto skip_arg_loop;
			}
d505 1
a505 2
					if(test_avail_noise)
						ERR_print_errors_fp(stdout);
a518 1

@


1.1.1.6
log
@import openssl-0.9.8j
@
text
@d59 1
a68 1
#ifndef OPENSSL_NO_ENGINE
@


1.1.1.7
log
@import of OpenSSL 0.9.8k
@
text
@d255 1
a255 1
                                xpos = BIO_puts(bio_out, indent);
d266 1
a266 1
                                        xpos = BIO_puts(bio_out, indent);
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d95 1
a95 1
static void identity(char *ptr)
d151 5
d208 1
a208 1
	STACK_OF(OPENSSL_STRING) *cmds = NULL;
d219 1
a219 1
	cmds = sk_OPENSSL_STRING_new_null();
d292 1
a292 1
	if(cmds) sk_OPENSSL_STRING_pop_free(cmds, identity);
d298 1
a298 2
static void util_do_cmds(ENGINE *e, STACK_OF(OPENSSL_STRING) *cmds,
			BIO *bio_out, const char *indent)
d300 1
a300 2
	int loop, res, num = sk_OPENSSL_STRING_num(cmds);

d310 1
a310 1
		cmd = sk_OPENSSL_STRING_value(cmds, loop);
d350 3
a352 3
	STACK_OF(OPENSSL_STRING) *engines = sk_OPENSSL_STRING_new_null();
	STACK_OF(OPENSSL_STRING) *pre_cmds = sk_OPENSSL_STRING_new_null();
	STACK_OF(OPENSSL_STRING) *post_cmds = sk_OPENSSL_STRING_new_null();
d399 1
a399 1
			sk_OPENSSL_STRING_push(pre_cmds,*argv);
d406 1
a406 1
			sk_OPENSSL_STRING_push(post_cmds,*argv);
d412 1
a412 1
			sk_OPENSSL_STRING_push(engines,*argv);
d427 1
a427 1
	if (sk_OPENSSL_STRING_num(engines) == 0)
d431 1
a431 1
			sk_OPENSSL_STRING_push(engines,(char *)ENGINE_get_id(e));
d435 1
a435 1
	for (i=0; i<sk_OPENSSL_STRING_num(engines); i++)
d437 1
a437 1
		const char *id = sk_OPENSSL_STRING_value(engines,i);
a456 1
				ENGINE_PKEY_METHS_PTR fn_pk;
a494 9
				fn_pk = ENGINE_get_pkey_meths(e);
				if(!fn_pk) goto skip_pmeths;
				n = fn_pk(e, NULL, &nids, 0);
				for(k=0 ; k < n ; ++k)
					if(!append_buf(&cap_buf,
						       OBJ_nid2sn(nids[k]),
						       &cap_size, 256))
						goto end;
skip_pmeths:
d529 3
a531 3
	sk_OPENSSL_STRING_pop_free(engines, identity);
	sk_OPENSSL_STRING_pop_free(pre_cmds, identity);
	sk_OPENSSL_STRING_pop_free(post_cmds, identity);
@


