head	1.11;
access;
symbols
	butholakala:1.1.1.2
	openssl_1_0_1_g:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.8
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.4
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.2
	OPENBSD_5_3_BASE:1.1.1.1
	openssl_1_0_1_c:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.05.06.01.52.07;	author tedu;	state dead;
branches;
next	1.10;

1.10
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.18.18.08.36;	author lteo;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.18.09.38.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.18.04.17.17;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.18.02.45.27;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@bye bye SRP
@
text
@/* apps/srp.c */
/* Written by Peter Sylvester (peter.sylvester@@edelweb.fr)
 * for the EdelKey project and contributed to the OpenSSL project 2004.
 */
/* ====================================================================
 * Copyright (c) 2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
#include <openssl/opensslconf.h>

#ifndef OPENSSL_NO_SRP
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/conf.h>
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/txt_db.h>
#include <openssl/buffer.h>
#include <openssl/srp.h>

#include "apps.h"


#define BASE_SECTION	"srp"

#define ENV_RANDFILE		"RANDFILE"

#define ENV_DATABASE		"srpvfile"
#define ENV_DEFAULT_SRP		"default_srp"

static char *srp_usage[] = {
	"usage: srp [args] [user] \n",
	"\n",
	" -verbose        Talk alot while doing things\n",
	" -config file    A config file\n",
	" -name arg       The particular srp definition to use\n",
	" -srpvfile arg   The srp verifier file name\n",
	" -add            add an user and srp verifier\n",
	" -modify         modify the srp verifier of an existing user\n",
	" -delete         delete user from verifier file\n",
	" -list           list user\n",
	" -gn arg         g and N values to be used for new verifier\n",
	" -userinfo arg   additional info to be set for user\n",
	" -passin arg     input file pass phrase source\n",
	" -passout arg    output file pass phrase source\n",
#ifndef OPENSSL_NO_ENGINE
	" -engine e         - use engine e, possibly a hardware device.\n",
#endif
	NULL
};

#ifdef EFENCE
extern int EF_PROTECT_FREE;
extern int EF_PROTECT_BELOW;
extern int EF_ALIGNMENT;
#endif

static CONF *conf = NULL;
static char *section = NULL;

#define VERBOSE if (verbose)
#define VVERBOSE if (verbose>1)


int srp_main(int, char **);

static int 
get_index(CA_DB * db, char *id, char type)
{
	char **pp;
	int i;
	if (id == NULL)
		return -1;
	if (type == DB_SRP_INDEX)
		for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {
			pp = sk_OPENSSL_PSTRING_value(db->db->data, i);
			if (pp[DB_srptype][0] == DB_SRP_INDEX && !strcmp(id, pp[DB_srpid]))
				return i;
		}
	else
		for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {
			pp = sk_OPENSSL_PSTRING_value(db->db->data, i);

			if (pp[DB_srptype][0] != DB_SRP_INDEX && !strcmp(id, pp[DB_srpid]))
				return i;
		}

	return -1;
}

static void 
print_entry(CA_DB * db, BIO * bio, int indx, int verbose, char *s)
{
	if (indx >= 0 && verbose) {
		int j;
		char **pp = sk_OPENSSL_PSTRING_value(db->db->data, indx);
		BIO_printf(bio, "%s \"%s\"\n", s, pp[DB_srpid]);
		for (j = 0; j < DB_NUMBER; j++) {
			BIO_printf(bio_err, "  %d = \"%s\"\n", j, pp[j]);
		}
	}
}

static void 
print_index(CA_DB * db, BIO * bio, int indexindex, int verbose)
{
	print_entry(db, bio, indexindex, verbose, "g N entry");
}

static void 
print_user(CA_DB * db, BIO * bio, int userindex, int verbose)
{
	if (verbose > 0) {
		char **pp = sk_OPENSSL_PSTRING_value(db->db->data, userindex);

		if (pp[DB_srptype][0] != 'I') {
			print_entry(db, bio, userindex, verbose, "User entry");
			print_entry(db, bio, get_index(db, pp[DB_srpgN], 'I'), verbose, "g N entry");
		}
	}
}

static int 
update_index(CA_DB * db, BIO * bio, char **row)
{
	char **irow;
	int i;

	if ((irow = (char **) malloc(sizeof(char *) * (DB_NUMBER + 1))) == NULL) {
		BIO_printf(bio_err, "Memory allocation failure\n");
		return 0;
	}
	for (i = 0; i < DB_NUMBER; i++) {
		irow[i] = row[i];
		row[i] = NULL;
	}
	irow[DB_NUMBER] = NULL;

	if (!TXT_DB_insert(db->db, irow)) {
		BIO_printf(bio, "failed to update srpvfile\n");
		BIO_printf(bio, "TXT_DB error number %ld\n", db->db->error);
		free(irow);
		return 0;
	}
	return 1;
}

static void 
lookup_fail(const char *name, char *tag)
{
	BIO_printf(bio_err, "variable lookup failed for %s::%s\n", name, tag);
}


static char *
srp_verify_user(const char *user, const char *srp_verifier,
    char *srp_usersalt, const char *g, const char *N,
    const char *passin, BIO * bio, int verbose)
{
	char password[1024];
	PW_CB_DATA cb_tmp;
	char *verifier = NULL;
	char *gNid = NULL;

	cb_tmp.prompt_info = user;
	cb_tmp.password = passin;

	if (password_callback(password, 1024, 0, &cb_tmp) > 0) {
		VERBOSE BIO_printf(bio, "Validating\n   user=\"%s\"\n srp_verifier=\"%s\"\n srp_usersalt=\"%s\"\n g=\"%s\"\n N=\"%s\"\n", user, srp_verifier, srp_usersalt, g, N);
		BIO_printf(bio, "Pass %s\n", password);

		if (!(gNid = SRP_create_verifier(user, password, &srp_usersalt, &verifier, N, g))) {
			BIO_printf(bio, "Internal error validating SRP verifier\n");
		} else {
			if (strcmp(verifier, srp_verifier))
				gNid = NULL;
			free(verifier);
		}
	}
	return gNid;
}

static char *
srp_create_user(char *user, char **srp_verifier,
    char **srp_usersalt, char *g, char *N,
    char *passout, BIO * bio, int verbose)
{
	char password[1024];
	PW_CB_DATA cb_tmp;
	char *gNid = NULL;
	char *salt = NULL;
	cb_tmp.prompt_info = user;
	cb_tmp.password = passout;

	if (password_callback(password, 1024, 1, &cb_tmp) > 0) {
		VERBOSE BIO_printf(bio, "Creating\n user=\"%s\"\n g=\"%s\"\n N=\"%s\"\n", user, g, N);
		if (!(gNid = SRP_create_verifier(user, password, &salt, srp_verifier, N, g))) {
			BIO_printf(bio, "Internal error creating SRP verifier\n");
		} else
			*srp_usersalt = salt;
		VVERBOSE BIO_printf(bio, "gNid=%s salt =\"%s\"\n verifier =\"%s\"\n", gNid, salt, *srp_verifier);

	}
	return gNid;
}

int 
srp_main(int argc, char **argv)
{
	int add_user = 0;
	int list_user = 0;
	int delete_user = 0;
	int modify_user = 0;
	char *user = NULL;

	char *passargin = NULL, *passargout = NULL;
	char *passin = NULL, *passout = NULL;
	char *gN = NULL;
	int gNindex = -1;
	char **gNrow = NULL;
	int maxgN = -1;

	char *userinfo = NULL;

	int badops = 0;
	int ret = 1;
	int errors = 0;
	int verbose = 0;
	int doupdatedb = 0;
	char *configfile = NULL;
	char *dbfile = NULL;
	CA_DB *db = NULL;
	char **pp;
	int i;
	long errorline = -1;
#ifndef OPENSSL_NO_ENGINE
	char *engine = NULL;
#endif
	char *tofree = NULL;
	DB_ATTR db_attr;

#ifdef EFENCE
	EF_PROTECT_FREE = 1;
	EF_PROTECT_BELOW = 1;
	EF_ALIGNMENT = 0;
#endif

	signal(SIGPIPE, SIG_IGN);

	conf = NULL;
	section = NULL;

	if (bio_err == NULL)
		if ((bio_err = BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);

	argc--;
	argv++;
	while (argc >= 1 && badops == 0) {
		if (strcmp(*argv, "-verbose") == 0)
			verbose++;
		else if (strcmp(*argv, "-config") == 0) {
			if (--argc < 1)
				goto bad;
			configfile = *(++argv);
		} else if (strcmp(*argv, "-name") == 0) {
			if (--argc < 1)
				goto bad;
			section = *(++argv);
		} else if (strcmp(*argv, "-srpvfile") == 0) {
			if (--argc < 1)
				goto bad;
			dbfile = *(++argv);
		} else if (strcmp(*argv, "-add") == 0)
			add_user = 1;
		else if (strcmp(*argv, "-delete") == 0)
			delete_user = 1;
		else if (strcmp(*argv, "-modify") == 0)
			modify_user = 1;
		else if (strcmp(*argv, "-list") == 0)
			list_user = 1;
		else if (strcmp(*argv, "-gn") == 0) {
			if (--argc < 1)
				goto bad;
			gN = *(++argv);
		} else if (strcmp(*argv, "-userinfo") == 0) {
			if (--argc < 1)
				goto bad;
			userinfo = *(++argv);
		} else if (strcmp(*argv, "-passin") == 0) {
			if (--argc < 1)
				goto bad;
			passargin = *(++argv);
		} else if (strcmp(*argv, "-passout") == 0) {
			if (--argc < 1)
				goto bad;
			passargout = *(++argv);
		}
#ifndef OPENSSL_NO_ENGINE
		else if (strcmp(*argv, "-engine") == 0) {
			if (--argc < 1)
				goto bad;
			engine = *(++argv);
		}
#endif

		else if (**argv == '-') {
	bad:
			BIO_printf(bio_err, "unknown option %s\n", *argv);
			badops = 1;
			break;
		} else
			break;

		argc--;
		argv++;
	}

	if (dbfile && configfile) {
		BIO_printf(bio_err, "-dbfile and -configfile cannot be specified together.\n");
		badops = 1;
	}
	if (add_user + delete_user + modify_user + list_user != 1) {
		BIO_printf(bio_err, "Exactly one of the options -add, -delete, -modify -list must be specified.\n");
		badops = 1;
	}
	if (delete_user + modify_user + delete_user == 1 && argc <= 0) {
		BIO_printf(bio_err, "Need at least one user for options -add, -delete, -modify. \n");
		badops = 1;
	}
	if ((passin || passout) && argc != 1) {
		BIO_printf(bio_err, "-passin, -passout arguments only valid with one user.\n");
		badops = 1;
	}
	if (badops) {
		for (pp = srp_usage; (*pp != NULL); pp++)
			BIO_printf(bio_err, "%s", *pp);

		BIO_printf(bio_err, " -rand file:file:...\n");
		BIO_printf(bio_err, "                 load the file (or the files in the directory) into\n");
		BIO_printf(bio_err, "                 the random number generator\n");
		goto err;
	}
	ERR_load_crypto_strings();

#ifndef OPENSSL_NO_ENGINE
	setup_engine(bio_err, engine, 0);
#endif

	if (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {
		BIO_printf(bio_err, "Error getting passwords\n");
		goto err;
	}
	if (!dbfile) {


		/*****************************************************************/
		tofree = NULL;
		if (configfile == NULL)
			configfile = getenv("OPENSSL_CONF");
		if (configfile == NULL)
			configfile = getenv("SSLEAY_CONF");
		if (configfile == NULL) {
			if ((tofree = make_config_name()) == NULL) {
				BIO_printf(bio_err, "error making config file name\n");
				goto err;
			}
			configfile = tofree;
		}
		VERBOSE BIO_printf(bio_err, "Using configuration from %s\n", configfile);
		conf = NCONF_new(NULL);
		if (NCONF_load(conf, configfile, &errorline) <= 0) {
			if (errorline <= 0)
				BIO_printf(bio_err, "error loading the config file '%s'\n",
				    configfile);
			else
				BIO_printf(bio_err, "error on line %ld of config file '%s'\n"
				    ,errorline, configfile);
			goto err;
		}
		if (tofree) {
			free(tofree);
			tofree = NULL;
		}
		if (!load_config(bio_err, conf))
			goto err;

		/* Lets get the config section we are using */
		if (section == NULL) {
			VERBOSE BIO_printf(bio_err, "trying to read " ENV_DEFAULT_SRP " in \" BASE_SECTION \"\n");

			section = NCONF_get_string(conf, BASE_SECTION, ENV_DEFAULT_SRP);
			if (section == NULL) {
				lookup_fail(BASE_SECTION, ENV_DEFAULT_SRP);
				goto err;
			}
		}

		VERBOSE BIO_printf(bio_err, "trying to read " ENV_DATABASE " in section \"%s\"\n", section);

		if ((dbfile = NCONF_get_string(conf, section, ENV_DATABASE)) == NULL) {
			lookup_fail(section, ENV_DATABASE);
			goto err;
		}
	}
	ERR_clear_error();

	VERBOSE BIO_printf(bio_err, "Trying to read SRP verifier file \"%s\"\n", dbfile);

	db = load_index(dbfile, &db_attr);
	if (db == NULL)
		goto err;

	/* Lets check some fields */
	for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {
		pp = sk_OPENSSL_PSTRING_value(db->db->data, i);

		if (pp[DB_srptype][0] == DB_SRP_INDEX) {
			maxgN = i;
			if (gNindex < 0 && gN != NULL && !strcmp(gN, pp[DB_srpid]))
				gNindex = i;

			print_index(db, bio_err, i, verbose > 1);
		}
	}

	VERBOSE BIO_printf(bio_err, "Database initialised\n");

	if (gNindex >= 0) {
		gNrow = sk_OPENSSL_PSTRING_value(db->db->data, gNindex);
		print_entry(db, bio_err, gNindex, verbose > 1, "Default g and N");
	} else if (maxgN > 0 && !SRP_get_default_gN(gN)) {
		BIO_printf(bio_err, "No g and N value for index \"%s\"\n", gN);
		goto err;
	} else {
		VERBOSE BIO_printf(bio_err, "Database has no g N information.\n");
		gNrow = NULL;
	}


	VVERBOSE BIO_printf(bio_err, "Starting user processing\n");

	if (argc > 0)
		user = *(argv++);

	while (list_user || user) {
		int userindex = -1;
		if (user)
			VVERBOSE BIO_printf(bio_err, "Processing user \"%s\"\n", user);
		if ((userindex = get_index(db, user, 'U')) >= 0) {
			print_user(db, bio_err, userindex, (verbose > 0) || list_user);
		}
		if (list_user) {
			if (user == NULL) {
				BIO_printf(bio_err, "List all users\n");

				for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {
					print_user(db, bio_err, i, 1);
				}
				list_user = 0;
			} else if (userindex < 0) {
				BIO_printf(bio_err, "user \"%s\" does not exist, ignored. t\n",
				    user);
				errors++;
			}
		} else if (add_user) {
			if (userindex >= 0) {
				/* reactivation of a new user */
				char **row = sk_OPENSSL_PSTRING_value(db->db->data, userindex);
				BIO_printf(bio_err, "user \"%s\" reactivated.\n", user);
				row[DB_srptype][0] = 'V';

				doupdatedb = 1;
			} else {
				char *row[DB_NUMBER];
				char *gNid;
				row[DB_srpverifier] = NULL;
				row[DB_srpsalt] = NULL;
				row[DB_srpinfo] = NULL;
				if (!(gNid = srp_create_user(user, &(row[DB_srpverifier]), &(row[DB_srpsalt]), gNrow ? gNrow[DB_srpsalt] : gN, gNrow ? gNrow[DB_srpverifier] : NULL, passout, bio_err, verbose))) {
					BIO_printf(bio_err, "Cannot create srp verifier for user \"%s\", operation abandoned .\n", user);
					errors++;
					goto err;
				}
				row[DB_srpid] = BUF_strdup(user);
				row[DB_srptype] = BUF_strdup("v");
				row[DB_srpgN] = BUF_strdup(gNid);

				if (!row[DB_srpid] || !row[DB_srpgN] || !row[DB_srptype] || !row[DB_srpverifier] || !row[DB_srpsalt] ||
				    (userinfo && (!(row[DB_srpinfo] = BUF_strdup(userinfo)))) ||
				    !update_index(db, bio_err, row)) {
					if (row[DB_srpid])
						free(row[DB_srpid]);
					if (row[DB_srpgN])
						free(row[DB_srpgN]);
					if (row[DB_srpinfo])
						free(row[DB_srpinfo]);
					if (row[DB_srptype])
						free(row[DB_srptype]);
					if (row[DB_srpverifier])
						free(row[DB_srpverifier]);
					if (row[DB_srpsalt])
						free(row[DB_srpsalt]);
					goto err;
				}
				doupdatedb = 1;
			}
		} else if (modify_user) {
			if (userindex < 0) {
				BIO_printf(bio_err, "user \"%s\" does not exist, operation ignored.\n", user);
				errors++;
			} else {

				char **row = sk_OPENSSL_PSTRING_value(db->db->data, userindex);
				char type = row[DB_srptype][0];
				if (type == 'v') {
					BIO_printf(bio_err, "user \"%s\" already updated, operation ignored.\n", user);
					errors++;
				} else {
					char *gNid;

					if (row[DB_srptype][0] == 'V') {
						int user_gN;
						char **irow = NULL;
						VERBOSE BIO_printf(bio_err, "Verifying password for user \"%s\"\n", user);
						if ((user_gN = get_index(db, row[DB_srpgN], DB_SRP_INDEX)) >= 0)
							irow = (char **) sk_OPENSSL_PSTRING_value(db->db->data, userindex);

						if (!srp_verify_user(user, row[DB_srpverifier], row[DB_srpsalt], irow ? irow[DB_srpsalt] : row[DB_srpgN], irow ? irow[DB_srpverifier] : NULL, passin, bio_err, verbose)) {
							BIO_printf(bio_err, "Invalid password for user \"%s\", operation abandoned.\n", user);
							errors++;
							goto err;
						}
					}
					VERBOSE BIO_printf(bio_err, "Password for user \"%s\" ok.\n", user);

					if (!(gNid = srp_create_user(user, &(row[DB_srpverifier]), &(row[DB_srpsalt]), gNrow ? gNrow[DB_srpsalt] : NULL, gNrow ? gNrow[DB_srpverifier] : NULL, passout, bio_err, verbose))) {
						BIO_printf(bio_err, "Cannot create srp verifier for user \"%s\", operation abandoned.\n", user);
						errors++;
						goto err;
					}
					row[DB_srptype][0] = 'v';
					row[DB_srpgN] = BUF_strdup(gNid);

					if (!row[DB_srpid] || !row[DB_srpgN] || !row[DB_srptype] || !row[DB_srpverifier] || !row[DB_srpsalt] ||
					    (userinfo && (!(row[DB_srpinfo] = BUF_strdup(userinfo)))))
						goto err;

					doupdatedb = 1;
				}
			}
		} else if (delete_user) {
			if (userindex < 0) {
				BIO_printf(bio_err, "user \"%s\" does not exist, operation ignored. t\n", user);
				errors++;
			} else {
				char **xpp = sk_OPENSSL_PSTRING_value(db->db->data, userindex);
				BIO_printf(bio_err, "user \"%s\" revoked. t\n", user);

				xpp[DB_srptype][0] = 'R';

				doupdatedb = 1;
			}
		}
		if (--argc > 0)
			user = *(argv++);
		else {
			user = NULL;
			list_user = 0;
		}
	}

	VERBOSE BIO_printf(bio_err, "User procession done.\n");


	if (doupdatedb) {
		/* Lets check some fields */
		for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {
			pp = sk_OPENSSL_PSTRING_value(db->db->data, i);

			if (pp[DB_srptype][0] == 'v') {
				pp[DB_srptype][0] = 'V';
				print_user(db, bio_err, i, verbose);
			}
		}

		VERBOSE BIO_printf(bio_err, "Trying to update srpvfile.\n");
		if (!save_index(dbfile, "new", db))
			goto err;

		VERBOSE BIO_printf(bio_err, "Temporary srpvfile created.\n");
		if (!rotate_index(dbfile, "new", "old"))
			goto err;

		VERBOSE BIO_printf(bio_err, "srpvfile updated.\n");
	}
	ret = (errors != 0);
err:
	if (errors != 0)
		VERBOSE BIO_printf(bio_err, "User errors %d.\n", errors);

	VERBOSE BIO_printf(bio_err, "SRP terminating with code %d.\n", ret);
	if (tofree)
		free(tofree);
	if (ret)
		ERR_print_errors(bio_err);
	if (conf)
		NCONF_free(conf);
	if (db)
		free_index(db);

	OBJ_cleanup();
	
	return (ret);
}



#endif
@


1.10
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@@


1.9
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d298 1
a298 1
	apps_startup();
d663 1
a663 1
	apps_shutdown();
@


1.8
log
@Use the cleaned up asprintf-based make_config_name() to make the name of
the config file instead of the malloc/BUF_strlcpy/BUF_strlcat calls with
no return value checks (that make_config_name() also used to do prior to
being cleaned up).

ok beck@@
@
text
@a285 1
	char *randfile = NULL;
a447 3
		if (randfile == NULL && conf)
			randfile = NCONF_get_string(conf, BASE_SECTION, "RANDFILE");

d456 1
a456 4
	if (randfile == NULL)
		ERR_clear_error();
	else
		app_RAND_load_file(randfile, bio_err, 0);
a656 2
	if (randfile)
		app_RAND_write_file(randfile, bio_err);
@


1.7
log
@simplify file:file:... stuff
@
text
@a74 1
#define CONFIG_FILE "openssl.cnf"
d415 4
a418 8
			const char *s = X509_get_default_cert_area();
			size_t len;

			len = strlen(s) + sizeof(CONFIG_FILE) + 1;
			tofree = malloc(len);
			BUF_strlcpy(tofree, s, len);
			BUF_strlcat(tofree, "/", len);
			BUF_strlcat(tofree, CONFIG_FILE, len);
@


1.6
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d391 1
a391 1
		BIO_printf(bio_err, " -rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
@


1.5
log
@KaboomNF
@
text
@a72 2
#undef PROG
#define PROG srp_main
d116 1
a116 1
int MAIN(int, char **);
d259 1
a259 1
MAIN(int argc, char **argv)
@


1.4
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d2 1
a2 1
/* Written by Peter Sylvester (peter.sylvester@@edelweb.fr)  
d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d84 15
a98 15
static char *srp_usage[]={
"usage: srp [args] [user] \n",
"\n",
" -verbose        Talk alot while doing things\n",
" -config file    A config file\n",
" -name arg       The particular srp definition to use\n",
" -srpvfile arg   The srp verifier file name\n",
" -add            add an user and srp verifier\n",
" -modify         modify the srp verifier of an existing user\n",
" -delete         delete user from verifier file\n",
" -list           list user\n",
" -gn arg         g and N values to be used for new verifier\n",
" -userinfo arg   additional info to be set for user\n",
" -passin arg     input file pass phrase source\n",
" -passout arg    output file pass phrase source\n",
d100 1
a100 1
" -engine e         - use engine e, possibly a hardware device.\n",
d102 1
a102 1
NULL
d111 2
a112 2
static CONF *conf=NULL;
static char *section=NULL;
d114 2
a115 2
#define VERBOSE if (verbose) 
#define VVERBOSE if (verbose>1) 
d120 4
a123 3
static int get_index(CA_DB *db, char* id, char type)
	{
	char ** pp;
d125 7
a131 7
	if (id == NULL) return -1;
	if (type == DB_SRP_INDEX) 
	for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++)
		{
		pp = sk_OPENSSL_PSTRING_value(db->db->data,i);
		if (pp[DB_srptype][0] == DB_SRP_INDEX  && !strcmp(id,pp[DB_srpid])) 
			return i;
d133 3
a135 3
	else for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++)
		{
		pp = sk_OPENSSL_PSTRING_value(db->db->data,i);
d137 2
a138 2
		if (pp[DB_srptype][0] != DB_SRP_INDEX && !strcmp(id,pp[DB_srpid])) 
			return i;
d141 2
a142 2
	return -1 ; 
	}
d144 4
a147 4
static void print_entry(CA_DB *db, BIO *bio, int indx, int verbose, char *s)
	{
	if (indx >= 0 && verbose)
		{
d151 2
a152 4
		for (j = 0; j < DB_NUMBER; j++)
			{
			BIO_printf(bio_err,"  %d = \"%s\"\n", j, pp[j]);
			}
d155 1
d157 11
a167 10
static void print_index(CA_DB *db, BIO *bio, int indexindex, int verbose)
	{
	print_entry(db, bio, indexindex, verbose, "g N entry") ;
	}

static void print_user(CA_DB *db, BIO *bio, int userindex, int verbose)
	{
	if (verbose > 0)
		{
		char **pp = sk_OPENSSL_PSTRING_value(db->db->data,userindex);
d169 1
a169 2
		if (pp[DB_srptype][0] != 'I')
			{
a171 2
			}

d174 1
d176 4
a179 3
static int update_index(CA_DB *db, BIO *bio, char **row)
	{
	char ** irow;
d182 2
a183 3
	if ((irow=(char **)malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)
		{
		BIO_printf(bio_err,"Memory allocation failure\n");
d185 6
a190 1
		}
d192 3
a194 11
	for (i=0; i<DB_NUMBER; i++)
		{
		irow[i]=row[i];
		row[i]=NULL;
		}
	irow[DB_NUMBER]=NULL;

	if (!TXT_DB_insert(db->db,irow))
		{
		BIO_printf(bio,"failed to update srpvfile\n");
		BIO_printf(bio,"TXT_DB error number %ld\n",db->db->error);
d197 1
a197 1
		}
d199 1
a199 1
	}
d201 5
a205 4
static void lookup_fail(const char *name, char *tag)
	{
	BIO_printf(bio_err,"variable lookup failed for %s::%s\n",name,tag);
	}
d208 5
a212 4
static char *srp_verify_user(const char *user, const char *srp_verifier,
			     char *srp_usersalt, const char *g, const char *N,
			     const char *passin, BIO *bio, int verbose)
	{
d221 2
a222 3
 	if (password_callback(password, 1024, 0, &cb_tmp) >0)
		{
		VERBOSE BIO_printf(bio,"Validating\n   user=\"%s\"\n srp_verifier=\"%s\"\n srp_usersalt=\"%s\"\n g=\"%s\"\n N=\"%s\"\n",user,srp_verifier,srp_usersalt, g, N);
d225 1
a225 2
		if (!(gNid=SRP_create_verifier(user, password, &srp_usersalt, &verifier, N, g)))
			{
d227 1
a227 3
			}
		else
			{
a230 1
			}
d232 1
d234 1
a234 1
	}
d236 7
a242 6
static char *srp_create_user(char *user, char **srp_verifier,
			     char **srp_usersalt, char *g, char *N,
			     char *passout, BIO *bio, int verbose)
	{
 	char password[1024];
        PW_CB_DATA cb_tmp;
d245 2
a246 2
        cb_tmp.prompt_info = user;
        cb_tmp.password = passout;
d248 5
a252 8
	if (password_callback(password,1024,1,&cb_tmp) >0)
		{
		VERBOSE BIO_printf(bio,"Creating\n user=\"%s\"\n g=\"%s\"\n N=\"%s\"\n",user,g,N);
		if (!(gNid =SRP_create_verifier(user, password, &salt, srp_verifier, N, g)))
			{
			BIO_printf(bio,"Internal error creating SRP verifier\n");
			}
		else 
d254 1
a254 1
		VVERBOSE BIO_printf(bio,"gNid=%s salt =\"%s\"\n verifier =\"%s\"\n", gNid,salt, *srp_verifier);
d256 1
a256 1
		}
d258 1
a258 1
	}
d260 3
a262 2
int MAIN(int argc, char **argv)
	{
d264 4
a267 4
	int list_user= 0;
	int delete_user= 0;
	int modify_user= 0;
	char * user = NULL;
d271 1
a271 1
        char * gN = NULL;
d273 1
a273 1
	char ** gNrow = NULL;
d276 1
a276 1
	char * userinfo = NULL;
d278 9
a286 9
	int badops=0;
	int ret=1;
	int errors=0;
	int verbose=0;
	int doupdatedb=0;
	char *configfile=NULL;
	char *dbfile=NULL;
	CA_DB *db=NULL;
	char **pp ;
d289 1
a289 1
	char *randfile=NULL;
d293 1
a293 1
	char *tofree=NULL;
d297 3
a299 3
EF_PROTECT_FREE=1;
EF_PROTECT_BELOW=1;
EF_ALIGNMENT=0;
d308 2
a309 2
		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);
d313 2
a314 3
	while (argc >= 1 && badops == 0)
		{
		if	(strcmp(*argv,"-verbose") == 0)
d316 37
a352 43
		else if	(strcmp(*argv,"-config") == 0)
			{
			if (--argc < 1) goto bad;
			configfile= *(++argv);
			}
		else if (strcmp(*argv,"-name") == 0)
			{
			if (--argc < 1) goto bad;
			section= *(++argv);
			}
		else if	(strcmp(*argv,"-srpvfile") == 0)
			{
			if (--argc < 1) goto bad;
			dbfile= *(++argv);
			}
		else if (strcmp(*argv,"-add") == 0)
			add_user=1;
		else if (strcmp(*argv,"-delete") == 0)
			delete_user=1;
		else if (strcmp(*argv,"-modify") == 0)
			modify_user=1;
		else if (strcmp(*argv,"-list") == 0)
			list_user=1;
		else if (strcmp(*argv,"-gn") == 0)
			{
			if (--argc < 1) goto bad;
			gN= *(++argv);
			}
		else if (strcmp(*argv,"-userinfo") == 0)
			{
			if (--argc < 1) goto bad;
			userinfo= *(++argv);
			}
		else if (strcmp(*argv,"-passin") == 0)
			{
			if (--argc < 1) goto bad;
			passargin= *(++argv);
			}
		else if (strcmp(*argv,"-passout") == 0)
			{
			if (--argc < 1) goto bad;
			passargout= *(++argv);
			}
d354 5
a358 5
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
			engine= *(++argv);
			}
d361 4
a364 5
		else if (**argv == '-')
			{
bad:
			BIO_printf(bio_err,"unknown option %s\n",*argv);
			badops=1;
d366 1
a366 2
			}
		else 
d368 1
a368 1
	
d371 1
a371 1
		}
d373 2
a374 3
	if (dbfile && configfile)
		{
		BIO_printf(bio_err,"-dbfile and -configfile cannot be specified together.\n");
d376 3
a378 4
		}
	if (add_user+delete_user+modify_user+list_user != 1)
		{
		BIO_printf(bio_err,"Exactly one of the options -add, -delete, -modify -list must be specified.\n");
d380 3
a382 4
		}
	if (delete_user+modify_user+delete_user== 1 && argc <= 0)
		{
		BIO_printf(bio_err,"Need at least one user for options -add, -delete, -modify. \n");
d384 3
a386 4
		}
	if ((passin || passout) && argc != 1 )
		{
		BIO_printf(bio_err,"-passin, -passout arguments only valid with one user.\n");
d388 8
a395 10
		}

	if (badops)
		{
		for (pp=srp_usage; (*pp != NULL); pp++)
			BIO_printf(bio_err,"%s",*pp);

		BIO_printf(bio_err," -rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
		BIO_printf(bio_err,"                 load the file (or the files in the directory) into\n");
		BIO_printf(bio_err,"                 the random number generator\n");
d397 1
a397 2
		}

d404 1
a404 2
	if(!app_passwd(bio_err, passargin, passargout, &passin, &passout))
		{
d407 2
a408 1
		}
a409 2
        if (!dbfile)
		{
d411 4
a414 5

	/*****************************************************************/
		tofree=NULL;
		if (configfile == NULL) configfile = getenv("OPENSSL_CONF");
		if (configfile == NULL) configfile = getenv("SSLEAY_CONF");
d416 3
a418 2
			{
			const char *s=X509_get_default_cert_area();
d421 8
a428 9
			len = strlen(s)+sizeof(CONFIG_FILE)+1;
			tofree=malloc(len);
			BUF_strlcpy(tofree,s,len);
			BUF_strlcat(tofree,"/",len);
			BUF_strlcat(tofree,CONFIG_FILE,len);
			configfile=tofree;
			}

		VERBOSE BIO_printf(bio_err,"Using configuration from %s\n",configfile);
d430 1
a430 2
		if (NCONF_load(conf,configfile,&errorline) <= 0)
			{
d432 2
a433 2
				BIO_printf(bio_err,"error loading the config file '%s'\n",
					configfile);
d435 2
a436 2
				BIO_printf(bio_err,"error on line %ld of config file '%s'\n"
					,errorline,configfile);
d438 2
a439 3
			}
		if(tofree)
			{
d442 1
a442 2
			}

d446 7
a452 9
	/* Lets get the config section we are using */
		if (section == NULL)
			{
			VERBOSE BIO_printf(bio_err,"trying to read " ENV_DEFAULT_SRP " in \" BASE_SECTION \"\n");

			section=NCONF_get_string(conf,BASE_SECTION,ENV_DEFAULT_SRP);
			if (section == NULL)
				{
				lookup_fail(BASE_SECTION,ENV_DEFAULT_SRP);
a453 1
				}
d455 1
a455 1
         
d457 2
a458 1
	        	randfile = NCONF_get_string(conf, BASE_SECTION, "RANDFILE");
d460 1
a460 2
	
		VERBOSE BIO_printf(bio_err,"trying to read " ENV_DATABASE " in section \"%s\"\n",section);
d462 2
a463 3
		if ((dbfile=NCONF_get_string(conf,section,ENV_DATABASE)) == NULL)
			{
			lookup_fail(section,ENV_DATABASE);
d465 2
a466 3
			}

        	}
d469 1
a469 1
       	else 
d472 1
a472 1
	VERBOSE BIO_printf(bio_err,"Trying to read SRP verifier file \"%s\"\n",dbfile);
d475 2
a476 1
	if (db == NULL) goto err;
d479 1
a479 2
	for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++)
		{
d481 2
a482 3
	
		if (pp[DB_srptype][0] == DB_SRP_INDEX)
			{
a487 1
			}
d489 2
a490 1
	
d493 2
a494 3
	if (gNindex >= 0)
		{
		gNrow = sk_OPENSSL_PSTRING_value(db->db->data,gNindex);
d496 1
a496 3
		}
	else if (maxgN > 0 && !SRP_get_default_gN(gN))
		{
d499 1
a499 3
		}
	else
		{
d502 2
a503 2
		}
	
d505 1
a505 1
	VVERBOSE BIO_printf(bio_err,"Starting user processing\n");
d508 1
a508 1
		user = *(argv++) ;
d510 1
a510 2
	while (list_user || user)
		{
d512 1
a512 1
		if (user) 
d514 1
a514 2
		if ((userindex = get_index(db, user, 'U')) >= 0)
			{
d516 8
a523 12
			}
		
		if (list_user)
			{
			if (user == NULL)
				{
				BIO_printf(bio_err,"List all users\n");

				for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++)
					{
					print_user(db,bio_err, i, 1);
					}
d525 1
a525 3
				}
			else if (userindex < 0)
				{
d527 1
a527 1
					   user);
a528 1
				}
d530 2
a531 4
		else if (add_user)
			{
			if (userindex >= 0)
				{
d538 3
a540 4
				}
			else
				{
				char *row[DB_NUMBER] ; char *gNid;
d544 5
a548 6
				if (!(gNid = srp_create_user(user,&(row[DB_srpverifier]), &(row[DB_srpsalt]),gNrow?gNrow[DB_srpsalt]:gN,gNrow?gNrow[DB_srpverifier]:NULL, passout, bio_err,verbose)))
					{
						BIO_printf(bio_err, "Cannot create srp verifier for user \"%s\", operation abandoned .\n", user);
						errors++;
						goto err;
					}
d554 14
a567 9
					(userinfo && (!(row[DB_srpinfo] = BUF_strdup(userinfo)))) || 
					!update_index(db, bio_err, row))
					{
					if (row[DB_srpid]) free(row[DB_srpid]);
					if (row[DB_srpgN]) free(row[DB_srpgN]);
					if (row[DB_srpinfo]) free(row[DB_srpinfo]);
					if (row[DB_srptype]) free(row[DB_srptype]);
					if (row[DB_srpverifier]) free(row[DB_srpverifier]);
					if (row[DB_srpsalt]) free(row[DB_srpsalt]);
d569 1
a569 1
					}
a570 1
				}
d572 3
a574 5
		else if (modify_user)
			{
			if (userindex < 0)
				{
				BIO_printf(bio_err,"user \"%s\" does not exist, operation ignored.\n",user);
d576 1
a576 3
				}
			else
				{
d580 2
a581 3
				if (type == 'v')
					{
					BIO_printf(bio_err,"user \"%s\" already updated, operation ignored.\n",user);
d583 1
a583 3
					}
				else
					{
d586 1
a586 2
					if (row[DB_srptype][0] == 'V')
						{
d589 3
a591 3
						VERBOSE BIO_printf(bio_err,"Verifying password for user \"%s\"\n",user);
						if ( (user_gN = get_index(db, row[DB_srpgN], DB_SRP_INDEX)) >= 0)
							irow = (char **)sk_OPENSSL_PSTRING_value(db->db->data, userindex);
d593 1
a593 2
 						if (!srp_verify_user(user, row[DB_srpverifier], row[DB_srpsalt], irow ? irow[DB_srpsalt] : row[DB_srpgN], irow ? irow[DB_srpverifier] : NULL, passin, bio_err, verbose))
							{
d597 3
a599 3
							}
						} 
					VERBOSE BIO_printf(bio_err,"Password for user \"%s\" ok.\n",user);
d601 1
a601 2
					if (!(gNid=srp_create_user(user,&(row[DB_srpverifier]), &(row[DB_srpsalt]),gNrow?gNrow[DB_srpsalt]:NULL, gNrow?gNrow[DB_srpverifier]:NULL, passout, bio_err,verbose)))
						{
d605 1
a605 2
						}

d608 1
a608 1
 
d610 1
a610 1
						(userinfo && (!(row[DB_srpinfo] = BUF_strdup(userinfo)))))  
a613 1
					}
d616 2
a617 4
		else if (delete_user)
			{
			if (userindex < 0)
				{
d620 2
a621 4
				}
			else
				{
				char **xpp = sk_OPENSSL_PSTRING_value(db->db->data,userindex);
d625 1
a625 1
				
a626 1
				}
d628 1
d630 2
a631 3
			user = *(argv++) ;
		else
			{
a633 1
			}
d635 1
d637 1
a637 1
	VERBOSE BIO_printf(bio_err,"User procession done.\n");
d640 1
a640 2
	if (doupdatedb)
		{
d642 4
a645 6
		for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++)
			{
			pp = sk_OPENSSL_PSTRING_value(db->db->data,i);
	
			if (pp[DB_srptype][0] == 'v')
				{
a647 1
				}
d649 1
d652 3
a654 2
		if (!save_index(dbfile, "new", db)) goto err;
				
d656 2
a657 1
		if (!rotate_index(dbfile, "new", "old")) goto err;
d660 1
a660 2
		}

d664 1
a664 1
	VERBOSE BIO_printf(bio_err,"User errors %d.\n",errors);
d666 2
a667 2
	VERBOSE BIO_printf(bio_err,"SRP terminating with code %d.\n",ret);
	if(tofree)
d669 8
a676 4
	if (ret) ERR_print_errors(bio_err);
	if (randfile) app_RAND_write_file(randfile, bio_err);
	if (conf) NCONF_free(conf);
	if (db) free_index(db);
d680 2
a681 2
	return(ret);
	}
a685 1

@


1.3
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d744 1
a744 1
	OPENSSL_EXIT(ret);
@


1.2
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d182 1
a182 1
	if ((irow=(char **)OPENSSL_malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)
d199 1
a199 1
		OPENSSL_free(irow);
d236 1
a236 1
			OPENSSL_free(verifier);
d447 1
a447 1
			tofree=OPENSSL_malloc(len);
d468 1
a468 1
			OPENSSL_free(tofree);
d610 6
a615 6
					if (row[DB_srpid]) OPENSSL_free(row[DB_srpid]);
					if (row[DB_srpgN]) OPENSSL_free(row[DB_srpgN]);
					if (row[DB_srpinfo]) OPENSSL_free(row[DB_srpinfo]);
					if (row[DB_srptype]) OPENSSL_free(row[DB_srptype]);
					if (row[DB_srpverifier]) OPENSSL_free(row[DB_srpverifier]);
					if (row[DB_srpsalt]) OPENSSL_free(row[DB_srpsalt]);
d736 1
a736 1
		OPENSSL_free(tofree);
@


1.1
log
@Initial revision
@
text
@d128 2
a129 2
		pp = (char **)sk_OPENSSL_PSTRING_value(db->db->data, i);
		if (pp[DB_srptype][0] == DB_SRP_INDEX  && !strcmp(id, pp[DB_srpid])) 
d134 1
a134 1
		pp = (char **)sk_OPENSSL_PSTRING_value(db->db->data, i);
d148 1
a148 1
		char **pp = (char **)sk_OPENSSL_PSTRING_value(db->db->data, indx);
d166 1
a166 1
		char **pp = (char **)sk_OPENSSL_PSTRING_value(db->db->data, userindex);
a445 5
#ifdef OPENSSL_SYS_VMS
			len = strlen(s)+sizeof(CONFIG_FILE);
			tofree=OPENSSL_malloc(len);
			strcpy(tofree,s);
#else
a449 1
#endif
d514 1
a514 1
		pp = (char **)sk_OPENSSL_PSTRING_value(db->db->data, i);
d530 2
a531 2
		gNrow = (char **)sk_OPENSSL_PSTRING_value(db->db->data, gNindex);
		print_entry(db, bio_err, gNindex, verbose > 1, "Default g and N") ;
d584 1
a584 1
				char **row = (char **)sk_OPENSSL_PSTRING_value(db->db->data, userindex);
d631 1
a631 1
				char **row = (char **)sk_OPENSSL_PSTRING_value(db->db->data, userindex);
d661 3
a663 3
							BIO_printf(bio_err, "Cannot create srp verifier for user \"%s\", operation abandoned.\n", user);
							errors++;
							goto err;
d686 1
a686 1
				char **xpp = (char **)sk_OPENSSL_PSTRING_value(db->db->data, userindex);
d711 1
a711 1
			pp = (char **)sk_OPENSSL_PSTRING_value(db->db->data, i);
@


1.1.1.1
log
@import OpenSSL-1.0.1c
@
text
@@


1.1.1.2
log
@Import OpenSSL 1.0.1g
@
text
@d128 2
a129 2
		pp = sk_OPENSSL_PSTRING_value(db->db->data,i);
		if (pp[DB_srptype][0] == DB_SRP_INDEX  && !strcmp(id,pp[DB_srpid])) 
d134 1
a134 1
		pp = sk_OPENSSL_PSTRING_value(db->db->data,i);
d148 1
a148 1
		char **pp = sk_OPENSSL_PSTRING_value(db->db->data, indx);
d166 1
a166 1
		char **pp = sk_OPENSSL_PSTRING_value(db->db->data,userindex);
d520 1
a520 1
		pp = sk_OPENSSL_PSTRING_value(db->db->data, i);
d536 2
a537 2
		gNrow = sk_OPENSSL_PSTRING_value(db->db->data,gNindex);
		print_entry(db, bio_err, gNindex, verbose > 1, "Default g and N");
d590 1
a590 1
				char **row = sk_OPENSSL_PSTRING_value(db->db->data, userindex);
d637 1
a637 1
				char **row = sk_OPENSSL_PSTRING_value(db->db->data, userindex);
d667 3
a669 3
						BIO_printf(bio_err, "Cannot create srp verifier for user \"%s\", operation abandoned.\n", user);
						errors++;
						goto err;
d692 1
a692 1
				char **xpp = sk_OPENSSL_PSTRING_value(db->db->data,userindex);
d717 1
a717 1
			pp = sk_OPENSSL_PSTRING_value(db->db->data,i);
@

