head	1.47;
access;
symbols
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	butholakala:1.17
	openssl_1_0_1_g:1.1.1.10
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	openssl_1_0_1_c:1.1.1.9
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	openssl_1_0_0_f:1.1.1.8
	openssl_1_0_0_e:1.1.1.8
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	openssh_1_0_0_a:1.1.1.8
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	openssl_0_9_8_k:1.1.1.7
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	openssl_0_9_8_j:1.1.1.7
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.13
	OPENBSD_4_4:1.13.0.14
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.12
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENSSL_0_9_7G:1.1.1.6
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENSSL_0_9_7D:1.1.1.5
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.46;
commitid	7A7DObXgY4Fni8xJ;

1.46
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	EB0l28piqIRSpBUh;

1.45
date	2014.07.09.21.02.35;	author tedu;	state Exp;
branches;
next	1.44;
commitid	ivoCf1icUxmbGXSc;

1.44
date	2014.06.28.04.39.41;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	gGtvlhTlvaxlmOBo;

1.43
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	mJUVYpkFBZ0Zv2bG;

1.42
date	2014.06.02.16.23.18;	author jsing;	state Exp;
branches;
next	1.41;
commitid	IqYoI5gjfSomu7k2;

1.41
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.24.12.39.02;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.22.14.54.13;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.19.16.18.22;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.19.11.46.39;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.19.00.41.37;	author beck;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.18.04.33.09;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.18.04.17.16;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.17.22.44.34;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.17.21.55.07;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.17.21.04.32;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.15.22.49.20;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.15.17.46.16;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.13.20.37.11;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.01.22.58.51;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.29.05.39.16;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.04.06.55.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.21.01.49.11;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.02.50;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.56.57;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.30;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.12;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.18;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.08;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.08;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.34;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.12.20.42.59;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.22;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.41.29;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.36.59;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: req.c,v 1.46 2014/07/14 00:35:10 deraadt Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/* Until the key-gen callbacks are modified to use newer prototypes, we allow
 * deprecated functions for openssl-internal code */
#ifdef OPENSSL_NO_DEPRECATED
#undef OPENSSL_NO_DEPRECATED
#endif

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <time.h>

#include "apps.h"

#include <openssl/asn1.h>
#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#include <openssl/pem.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>

#include <openssl/dsa.h>

#include <openssl/rsa.h>

#define SECTION		"req"

#define BITS		"default_bits"
#define KEYFILE		"default_keyfile"
#define PROMPT		"prompt"
#define DISTINGUISHED_NAME	"distinguished_name"
#define ATTRIBUTES	"attributes"
#define V3_EXTENSIONS	"x509_extensions"
#define REQ_EXTENSIONS	"req_extensions"
#define STRING_MASK	"string_mask"
#define UTF8_IN		"utf8"

#define DEFAULT_KEY_LENGTH	512
#define MIN_KEY_LENGTH		384


/* -inform arg	- input format - default PEM (DER or PEM)
 * -outform arg - output format - default PEM
 * -in arg	- input file - default stdin
 * -out arg	- output file - default stdout
 * -verify	- check request signature
 * -noout	- don't print stuff out.
 * -text	- print out human readable text.
 * -nodes	- no des encryption
 * -config file	- Load configuration file.
 * -key file	- make a request using key in file (or use it for verification).
 * -keyform arg	- key file format.
 * -newkey	- make a key and a request.
 * -modulus	- print RSA modulus.
 * -pubkey	- output Public Key.
 * -x509	- output a self signed X509 structure instead.
 * -asn1-kludge	- output new certificate request in a format that some CA's
 *		  require.  This format is wrong
 */

static int make_REQ(X509_REQ * req, EVP_PKEY * pkey, char *dn, int mutlirdn,
    int attribs, unsigned long chtype);
static int build_subject(X509_REQ * req, char *subj, unsigned long chtype,
    int multirdn);
static int prompt_info(X509_REQ * req,
    STACK_OF(CONF_VALUE) * dn_sk, char *dn_sect,
    STACK_OF(CONF_VALUE) * attr_sk, char *attr_sect, int attribs,
    unsigned long chtype);
static int auto_info(X509_REQ * req, STACK_OF(CONF_VALUE) * sk,
    STACK_OF(CONF_VALUE) * attr, int attribs,
    unsigned long chtype);
static int add_attribute_object(X509_REQ * req, char *text, const char *def,
    char *value, int nid, int n_min,
    int n_max, unsigned long chtype);
static int add_DN_object(X509_NAME * n, char *text, const char *def, char *value,
    int nid, int n_min, int n_max, unsigned long chtype, int mval);
static int genpkey_cb(EVP_PKEY_CTX * ctx);
static int req_check_len(int len, int n_min, int n_max);
static int check_end(const char *str, const char *end);
static EVP_PKEY_CTX *set_keygen_ctx(BIO * err, const char *gstr, int *pkey_type,
    long *pkeylen, char **palgnam,
    ENGINE * keygen_engine);
static CONF *req_conf = NULL;
static int batch = 0;

int req_main(int, char **);

int
req_main(int argc, char **argv)
{
	ENGINE *e = NULL, *gen_eng = NULL;
	unsigned long nmflag = 0, reqflag = 0;
	int ex = 1, x509 = 0, days = 30;
	X509 *x509ss = NULL;
	X509_REQ *req = NULL;
	EVP_PKEY_CTX *genctx = NULL;
	const char *keyalg = NULL;
	char *keyalgstr = NULL;
	STACK_OF(OPENSSL_STRING) * pkeyopts = NULL, *sigopts = NULL;
	EVP_PKEY *pkey = NULL;
	int i = 0, badops = 0, newreq = 0, verbose = 0, pkey_type = -1;
	long newkey = -1;
	BIO *in = NULL, *out = NULL;
	int informat, outformat, verify = 0, noout = 0, text = 0, keyform = FORMAT_PEM;
	int nodes = 0, kludge = 0, newhdr = 0, subject = 0, pubkey = 0;
	char *infile, *outfile, *prog, *keyfile = NULL, *template = NULL,
	*keyout = NULL;
#ifndef OPENSSL_NO_ENGINE
	char *engine = NULL;
#endif
	char *extensions = NULL;
	char *req_exts = NULL;
	const EVP_CIPHER *cipher = NULL;
	ASN1_INTEGER *serial = NULL;
	int modulus = 0;
	char *passargin = NULL, *passargout = NULL;
	char *passin = NULL, *passout = NULL;
	char *p;
	char *subj = NULL;
	int multirdn = 0;
	const EVP_MD *md_alg = NULL, *digest = NULL;
	unsigned long chtype = MBSTRING_ASC;

	req_conf = NULL;
#ifndef OPENSSL_NO_DES
	cipher = EVP_des_ede3_cbc();
#endif

	infile = NULL;
	outfile = NULL;
	informat = FORMAT_PEM;
	outformat = FORMAT_PEM;

	prog = argv[0];
	argc--;
	argv++;
	while (argc >= 1) {
		if (strcmp(*argv, "-inform") == 0) {
			if (--argc < 1)
				goto bad;
			informat = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-outform") == 0) {
			if (--argc < 1)
				goto bad;
			outformat = str2fmt(*(++argv));
		}
#ifndef OPENSSL_NO_ENGINE
		else if (strcmp(*argv, "-engine") == 0) {
			if (--argc < 1)
				goto bad;
			engine = *(++argv);
		} else if (strcmp(*argv, "-keygen_engine") == 0) {
			if (--argc < 1)
				goto bad;
			gen_eng = ENGINE_by_id(*(++argv));
			if (gen_eng == NULL) {
				BIO_printf(bio_err, "Can't find keygen engine %s\n", *argv);
				goto end;
			}
		}
#endif
		else if (strcmp(*argv, "-key") == 0) {
			if (--argc < 1)
				goto bad;
			keyfile = *(++argv);
		} else if (strcmp(*argv, "-pubkey") == 0) {
			pubkey = 1;
		} else if (strcmp(*argv, "-new") == 0) {
			newreq = 1;
		} else if (strcmp(*argv, "-config") == 0) {
			if (--argc < 1)
				goto bad;
			template = *(++argv);
		} else if (strcmp(*argv, "-keyform") == 0) {
			if (--argc < 1)
				goto bad;
			keyform = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-in") == 0) {
			if (--argc < 1)
				goto bad;
			infile = *(++argv);
		} else if (strcmp(*argv, "-out") == 0) {
			if (--argc < 1)
				goto bad;
			outfile = *(++argv);
		} else if (strcmp(*argv, "-keyout") == 0) {
			if (--argc < 1)
				goto bad;
			keyout = *(++argv);
		} else if (strcmp(*argv, "-passin") == 0) {
			if (--argc < 1)
				goto bad;
			passargin = *(++argv);
		} else if (strcmp(*argv, "-passout") == 0) {
			if (--argc < 1)
				goto bad;
			passargout = *(++argv);
		} else if (strcmp(*argv, "-newkey") == 0) {
			if (--argc < 1)
				goto bad;
			keyalg = *(++argv);
			newreq = 1;
		} else if (strcmp(*argv, "-pkeyopt") == 0) {
			if (--argc < 1)
				goto bad;
			if (!pkeyopts)
				pkeyopts = sk_OPENSSL_STRING_new_null();
			if (!pkeyopts || !sk_OPENSSL_STRING_push(pkeyopts, *(++argv)))
				goto bad;
		} else if (strcmp(*argv, "-sigopt") == 0) {
			if (--argc < 1)
				goto bad;
			if (!sigopts)
				sigopts = sk_OPENSSL_STRING_new_null();
			if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))
				goto bad;
		} else if (strcmp(*argv, "-batch") == 0)
			batch = 1;
		else if (strcmp(*argv, "-newhdr") == 0)
			newhdr = 1;
		else if (strcmp(*argv, "-modulus") == 0)
			modulus = 1;
		else if (strcmp(*argv, "-verify") == 0)
			verify = 1;
		else if (strcmp(*argv, "-nodes") == 0)
			nodes = 1;
		else if (strcmp(*argv, "-noout") == 0)
			noout = 1;
		else if (strcmp(*argv, "-verbose") == 0)
			verbose = 1;
		else if (strcmp(*argv, "-utf8") == 0)
			chtype = MBSTRING_UTF8;
		else if (strcmp(*argv, "-nameopt") == 0) {
			if (--argc < 1)
				goto bad;
			if (!set_name_ex(&nmflag, *(++argv)))
				goto bad;
		} else if (strcmp(*argv, "-reqopt") == 0) {
			if (--argc < 1)
				goto bad;
			if (!set_cert_ex(&reqflag, *(++argv)))
				goto bad;
		} else if (strcmp(*argv, "-subject") == 0)
			subject = 1;
		else if (strcmp(*argv, "-text") == 0)
			text = 1;
		else if (strcmp(*argv, "-x509") == 0)
			x509 = 1;
		else if (strcmp(*argv, "-asn1-kludge") == 0)
			kludge = 1;
		else if (strcmp(*argv, "-no-asn1-kludge") == 0)
			kludge = 0;
		else if (strcmp(*argv, "-subj") == 0) {
			if (--argc < 1)
				goto bad;
			subj = *(++argv);
		} else if (strcmp(*argv, "-multivalue-rdn") == 0)
			multirdn = 1;
		else if (strcmp(*argv, "-days") == 0) {
			const char *errstr;

			if (--argc < 1)
				goto bad;
			days = strtonum(*(++argv), 1, INT_MAX, &errstr);
			if (errstr) {
				BIO_printf(bio_err, "bad -days %s, using 0: %s\n",
				    *argv, errstr);
				days = 30;
			}
		} else if (strcmp(*argv, "-set_serial") == 0) {
			if (--argc < 1)
				goto bad;
			serial = s2i_ASN1_INTEGER(NULL, *(++argv));
			if (!serial)
				goto bad;
		} else if (strcmp(*argv, "-extensions") == 0) {
			if (--argc < 1)
				goto bad;
			extensions = *(++argv);
		} else if (strcmp(*argv, "-reqexts") == 0) {
			if (--argc < 1)
				goto bad;
			req_exts = *(++argv);
		} else if ((md_alg = EVP_get_digestbyname(&((*argv)[1]))) != NULL) {
			/* ok */
			digest = md_alg;
		} else {
			BIO_printf(bio_err, "unknown option %s\n", *argv);
			badops = 1;
			break;
		}
		argc--;
		argv++;
	}

	if (badops) {
bad:
		BIO_printf(bio_err, "%s [options] <infile >outfile\n", prog);
		BIO_printf(bio_err, "where options  are\n");
		BIO_printf(bio_err, " -inform arg    input format - DER or PEM\n");
		BIO_printf(bio_err, " -outform arg   output format - DER or PEM\n");
		BIO_printf(bio_err, " -in arg        input file\n");
		BIO_printf(bio_err, " -out arg       output file\n");
		BIO_printf(bio_err, " -text          text form of request\n");
		BIO_printf(bio_err, " -pubkey        output public key\n");
		BIO_printf(bio_err, " -noout         do not output REQ\n");
		BIO_printf(bio_err, " -verify        verify signature on REQ\n");
		BIO_printf(bio_err, " -modulus       RSA modulus\n");
		BIO_printf(bio_err, " -nodes         don't encrypt the output key\n");
#ifndef OPENSSL_NO_ENGINE
		BIO_printf(bio_err, " -engine e      use engine e, possibly a hardware device\n");
#endif
		BIO_printf(bio_err, " -subject       output the request's subject\n");
		BIO_printf(bio_err, " -passin        private key password source\n");
		BIO_printf(bio_err, " -key file      use the private key contained in file\n");
		BIO_printf(bio_err, " -keyform arg   key file format\n");
		BIO_printf(bio_err, " -keyout arg    file to send the key to\n");
		BIO_printf(bio_err, " -newkey rsa:bits generate a new RSA key of 'bits' in size\n");
		BIO_printf(bio_err, " -newkey dsa:file generate a new DSA key, parameters taken from CA in 'file'\n");
		BIO_printf(bio_err, " -newkey ec:file generate a new EC key, parameters taken from CA in 'file'\n");
		BIO_printf(bio_err, " -[digest]      Digest to sign with (md5, sha1, md2, mdc2, md4)\n");
		BIO_printf(bio_err, " -config file   request template file.\n");
		BIO_printf(bio_err, " -subj arg      set or modify request subject\n");
		BIO_printf(bio_err, " -multivalue-rdn enable support for multivalued RDNs\n");
		BIO_printf(bio_err, " -new           new request.\n");
		BIO_printf(bio_err, " -batch         do not ask anything during request generation\n");
		BIO_printf(bio_err, " -x509          output a x509 structure instead of a cert. req.\n");
		BIO_printf(bio_err, " -days          number of days a certificate generated by -x509 is valid for.\n");
		BIO_printf(bio_err, " -set_serial    serial number to use for a certificate generated by -x509.\n");
		BIO_printf(bio_err, " -newhdr        output \"NEW\" in the header lines\n");
		BIO_printf(bio_err, " -asn1-kludge   Output the 'request' in a format that is wrong but some CA's\n");
		BIO_printf(bio_err, "                have been reported as requiring\n");
		BIO_printf(bio_err, " -extensions .. specify certificate extension section (override value in config file)\n");
		BIO_printf(bio_err, " -reqexts ..    specify request extension section (override value in config file)\n");
		BIO_printf(bio_err, " -utf8          input characters are UTF8 (default ASCII)\n");
		BIO_printf(bio_err, " -nameopt arg    - various certificate name options\n");
		BIO_printf(bio_err, " -reqopt arg    - various request text options\n\n");
		goto end;
	}
	ERR_load_crypto_strings();
	if (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {
		BIO_printf(bio_err, "Error getting passwords\n");
		goto end;
	}
	if (template != NULL) {
		long errline = -1;

		if (verbose)
			BIO_printf(bio_err, "Using configuration from %s\n", template);
		req_conf = NCONF_new(NULL);
		i = NCONF_load(req_conf, template, &errline);
		if (i == 0) {
			BIO_printf(bio_err, "error on line %ld of %s\n", errline, template);
			goto end;
		}
	} else {
		req_conf = config;

		if (req_conf == NULL) {
			BIO_printf(bio_err, "Unable to load config info from %s\n", default_config_file);
			if (newreq)
				goto end;
		} else if (verbose)
			BIO_printf(bio_err, "Using configuration from %s\n",
			    default_config_file);
	}

	if (req_conf != NULL) {
		if (!load_config(bio_err, req_conf))
			goto end;
		p = NCONF_get_string(req_conf, NULL, "oid_file");
		if (p == NULL)
			ERR_clear_error();
		if (p != NULL) {
			BIO *oid_bio;

			oid_bio = BIO_new_file(p, "r");
			if (oid_bio == NULL) {
				/*
				BIO_printf(bio_err,"problems opening %s for extra oid's\n",p);
				ERR_print_errors(bio_err);
				*/
			} else {
				OBJ_create_objects(oid_bio);
				BIO_free(oid_bio);
			}
		}
	}
	if (!add_oid_section(bio_err, req_conf))
		goto end;

	if (md_alg == NULL) {
		p = NCONF_get_string(req_conf, SECTION, "default_md");
		if (p == NULL)
			ERR_clear_error();
		if (p != NULL) {
			if ((md_alg = EVP_get_digestbyname(p)) != NULL)
				digest = md_alg;
		}
	}
	if (!extensions) {
		extensions = NCONF_get_string(req_conf, SECTION, V3_EXTENSIONS);
		if (!extensions)
			ERR_clear_error();
	}
	if (extensions) {
		/* Check syntax of file */
		X509V3_CTX ctx;
		X509V3_set_ctx_test(&ctx);
		X509V3_set_nconf(&ctx, req_conf);
		if (!X509V3_EXT_add_nconf(req_conf, &ctx, extensions, NULL)) {
			BIO_printf(bio_err,
			    "Error Loading extension section %s\n", extensions);
			goto end;
		}
	}
	if (!passin) {
		passin = NCONF_get_string(req_conf, SECTION, "input_password");
		if (!passin)
			ERR_clear_error();
	}
	if (!passout) {
		passout = NCONF_get_string(req_conf, SECTION, "output_password");
		if (!passout)
			ERR_clear_error();
	}
	p = NCONF_get_string(req_conf, SECTION, STRING_MASK);
	if (!p)
		ERR_clear_error();

	if (p && !ASN1_STRING_set_default_mask_asc(p)) {
		BIO_printf(bio_err, "Invalid global string mask setting %s\n", p);
		goto end;
	}
	if (chtype != MBSTRING_UTF8) {
		p = NCONF_get_string(req_conf, SECTION, UTF8_IN);
		if (!p)
			ERR_clear_error();
		else if (!strcmp(p, "yes"))
			chtype = MBSTRING_UTF8;
	}
	if (!req_exts) {
		req_exts = NCONF_get_string(req_conf, SECTION, REQ_EXTENSIONS);
		if (!req_exts)
			ERR_clear_error();
	}
	if (req_exts) {
		/* Check syntax of file */
		X509V3_CTX ctx;
		X509V3_set_ctx_test(&ctx);
		X509V3_set_nconf(&ctx, req_conf);
		if (!X509V3_EXT_add_nconf(req_conf, &ctx, req_exts, NULL)) {
			BIO_printf(bio_err,
			    "Error Loading request extension section %s\n",
			    req_exts);
			goto end;
		}
	}
	in = BIO_new(BIO_s_file());
	out = BIO_new(BIO_s_file());
	if ((in == NULL) || (out == NULL))
		goto end;

#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine, 0);
#endif

	if (keyfile != NULL) {
		pkey = load_key(bio_err, keyfile, keyform, 0, passin, e,
		    "Private Key");
		if (!pkey) {
			/*
			 * load_key() has already printed an appropriate
			 * message
			 */
			goto end;
		}
	}
	if (newreq && (pkey == NULL)) {
		if (!NCONF_get_number(req_conf, SECTION, BITS, &newkey)) {
			newkey = DEFAULT_KEY_LENGTH;
		}
		if (keyalg) {
			genctx = set_keygen_ctx(bio_err, keyalg, &pkey_type, &newkey,
			    &keyalgstr, gen_eng);
			if (!genctx)
				goto end;
		}
		if (newkey < MIN_KEY_LENGTH && (pkey_type == EVP_PKEY_RSA || pkey_type == EVP_PKEY_DSA)) {
			BIO_printf(bio_err, "private key length is too short,\n");
			BIO_printf(bio_err, "it needs to be at least %d bits, not %ld\n", MIN_KEY_LENGTH, newkey);
			goto end;
		}
		if (!genctx) {
			genctx = set_keygen_ctx(bio_err, NULL, &pkey_type, &newkey,
			    &keyalgstr, gen_eng);
			if (!genctx)
				goto end;
		}
		if (pkeyopts) {
			char *genopt;
			for (i = 0; i < sk_OPENSSL_STRING_num(pkeyopts); i++) {
				genopt = sk_OPENSSL_STRING_value(pkeyopts, i);
				if (pkey_ctrl_string(genctx, genopt) <= 0) {
					BIO_printf(bio_err,
					    "parameter error \"%s\"\n",
					    genopt);
					ERR_print_errors(bio_err);
					goto end;
				}
			}
		}
		BIO_printf(bio_err, "Generating a %ld bit %s private key\n",
		    newkey, keyalgstr);

		EVP_PKEY_CTX_set_cb(genctx, genpkey_cb);
		EVP_PKEY_CTX_set_app_data(genctx, bio_err);

		if (EVP_PKEY_keygen(genctx, &pkey) <= 0) {
			BIO_puts(bio_err, "Error Generating Key\n");
			goto end;
		}
		EVP_PKEY_CTX_free(genctx);
		genctx = NULL;

		if (keyout == NULL) {
			keyout = NCONF_get_string(req_conf, SECTION, KEYFILE);
			if (keyout == NULL)
				ERR_clear_error();
		}
		if (keyout == NULL) {
			BIO_printf(bio_err, "writing new private key to stdout\n");
			BIO_set_fp(out, stdout, BIO_NOCLOSE);
		} else {
			BIO_printf(bio_err, "writing new private key to '%s'\n", keyout);
			if (BIO_write_filename(out, keyout) <= 0) {
				perror(keyout);
				goto end;
			}
		}

		p = NCONF_get_string(req_conf, SECTION, "encrypt_rsa_key");
		if (p == NULL) {
			ERR_clear_error();
			p = NCONF_get_string(req_conf, SECTION, "encrypt_key");
			if (p == NULL)
				ERR_clear_error();
		}
		if ((p != NULL) && (strcmp(p, "no") == 0))
			cipher = NULL;
		if (nodes)
			cipher = NULL;

		i = 0;
loop:
		if (!PEM_write_bio_PrivateKey(out, pkey, cipher,
			NULL, 0, NULL, passout)) {
			if ((ERR_GET_REASON(ERR_peek_error()) ==
				PEM_R_PROBLEMS_GETTING_PASSWORD) && (i < 3)) {
				ERR_clear_error();
				i++;
				goto loop;
			}
			goto end;
		}
		BIO_printf(bio_err, "-----\n");
	}
	if (!newreq) {
		/*
		 * Since we are using a pre-existing certificate request, the
		 * kludge 'format' info should not be changed.
		 */
		kludge = -1;
		if (infile == NULL)
			BIO_set_fp(in, stdin, BIO_NOCLOSE);
		else {
			if (BIO_read_filename(in, infile) <= 0) {
				perror(infile);
				goto end;
			}
		}

		if (informat == FORMAT_ASN1)
			req = d2i_X509_REQ_bio(in, NULL);
		else if (informat == FORMAT_PEM)
			req = PEM_read_bio_X509_REQ(in, NULL, NULL, NULL);
		else {
			BIO_printf(bio_err, "bad input format specified for X509 request\n");
			goto end;
		}
		if (req == NULL) {
			BIO_printf(bio_err, "unable to load X509 request\n");
			goto end;
		}
	}
	if (newreq || x509) {
		if (pkey == NULL) {
			BIO_printf(bio_err, "you need to specify a private key\n");
			goto end;
		}
		if (req == NULL) {
			req = X509_REQ_new();
			if (req == NULL) {
				goto end;
			}
			i = make_REQ(req, pkey, subj, multirdn, !x509, chtype);
			subj = NULL;	/* done processing '-subj' option */
			if ((kludge > 0) && !sk_X509_ATTRIBUTE_num(req->req_info->attributes)) {
				sk_X509_ATTRIBUTE_free(req->req_info->attributes);
				req->req_info->attributes = NULL;
			}
			if (!i) {
				BIO_printf(bio_err, "problems making Certificate Request\n");
				goto end;
			}
		}
		if (x509) {
			EVP_PKEY *tmppkey;
			X509V3_CTX ext_ctx;
			if ((x509ss = X509_new()) == NULL)
				goto end;

			/* Set version to V3 */
			if (extensions && !X509_set_version(x509ss, 2))
				goto end;
			if (serial) {
				if (!X509_set_serialNumber(x509ss, serial))
					goto end;
			} else {
				if (!rand_serial(NULL,
					X509_get_serialNumber(x509ss)))
					goto end;
			}

			if (!X509_set_issuer_name(x509ss, X509_REQ_get_subject_name(req)))
				goto end;
			if (!X509_gmtime_adj(X509_get_notBefore(x509ss), 0))
				goto end;
			if (!X509_time_adj_ex(X509_get_notAfter(x509ss), days, 0, NULL))
				goto end;
			if (!X509_set_subject_name(x509ss, X509_REQ_get_subject_name(req)))
				goto end;
			tmppkey = X509_REQ_get_pubkey(req);
			if (!tmppkey || !X509_set_pubkey(x509ss, tmppkey))
				goto end;
			EVP_PKEY_free(tmppkey);

			/* Set up V3 context struct */

			X509V3_set_ctx(&ext_ctx, x509ss, x509ss, NULL, NULL, 0);
			X509V3_set_nconf(&ext_ctx, req_conf);

			/* Add extensions */
			if (extensions && !X509V3_EXT_add_nconf(req_conf,
				&ext_ctx, extensions, x509ss)) {
				BIO_printf(bio_err,
				    "Error Loading extension section %s\n",
				    extensions);
				goto end;
			}
			i = do_X509_sign(bio_err, x509ss, pkey, digest, sigopts);
			if (!i) {
				ERR_print_errors(bio_err);
				goto end;
			}
		} else {
			X509V3_CTX ext_ctx;

			/* Set up V3 context struct */

			X509V3_set_ctx(&ext_ctx, NULL, NULL, req, NULL, 0);
			X509V3_set_nconf(&ext_ctx, req_conf);

			/* Add extensions */
			if (req_exts && !X509V3_EXT_REQ_add_nconf(req_conf,
				&ext_ctx, req_exts, req)) {
				BIO_printf(bio_err,
				    "Error Loading extension section %s\n",
				    req_exts);
				goto end;
			}
			i = do_X509_REQ_sign(bio_err, req, pkey, digest, sigopts);
			if (!i) {
				ERR_print_errors(bio_err);
				goto end;
			}
		}
	}
	if (subj && x509) {
		BIO_printf(bio_err, "Cannot modifiy certificate subject\n");
		goto end;
	}
	if (subj && !x509) {
		if (verbose) {
			BIO_printf(bio_err, "Modifying Request's Subject\n");
			print_name(bio_err, "old subject=", X509_REQ_get_subject_name(req), nmflag);
		}
		if (build_subject(req, subj, chtype, multirdn) == 0) {
			BIO_printf(bio_err, "ERROR: cannot modify subject\n");
			ex = 1;
			goto end;
		}
		req->req_info->enc.modified = 1;

		if (verbose) {
			print_name(bio_err, "new subject=", X509_REQ_get_subject_name(req), nmflag);
		}
	}
	if (verify && !x509) {
		int tmp = 0;

		if (pkey == NULL) {
			pkey = X509_REQ_get_pubkey(req);
			tmp = 1;
			if (pkey == NULL)
				goto end;
		}
		i = X509_REQ_verify(req, pkey);
		if (tmp) {
			EVP_PKEY_free(pkey);
			pkey = NULL;
		}
		if (i < 0) {
			goto end;
		} else if (i == 0) {
			BIO_printf(bio_err, "verify failure\n");
			ERR_print_errors(bio_err);
		} else		/* if (i > 0) */
			BIO_printf(bio_err, "verify OK\n");
	}
	if (noout && !text && !modulus && !subject && !pubkey) {
		ex = 0;
		goto end;
	}
	if (outfile == NULL) {
		BIO_set_fp(out, stdout, BIO_NOCLOSE);
	} else {
		if ((keyout != NULL) && (strcmp(outfile, keyout) == 0))
			i = (int) BIO_append_filename(out, outfile);
		else
			i = (int) BIO_write_filename(out, outfile);
		if (!i) {
			perror(outfile);
			goto end;
		}
	}

	if (pubkey) {
		EVP_PKEY *tpubkey;
		tpubkey = X509_REQ_get_pubkey(req);
		if (tpubkey == NULL) {
			BIO_printf(bio_err, "Error getting public key\n");
			ERR_print_errors(bio_err);
			goto end;
		}
		PEM_write_bio_PUBKEY(out, tpubkey);
		EVP_PKEY_free(tpubkey);
	}
	if (text) {
		if (x509)
			X509_print_ex(out, x509ss, nmflag, reqflag);
		else
			X509_REQ_print_ex(out, req, nmflag, reqflag);
	}
	if (subject) {
		if (x509)
			print_name(out, "subject=", X509_get_subject_name(x509ss), nmflag);
		else
			print_name(out, "subject=", X509_REQ_get_subject_name(req), nmflag);
	}
	if (modulus) {
		EVP_PKEY *tpubkey;

		if (x509)
			tpubkey = X509_get_pubkey(x509ss);
		else
			tpubkey = X509_REQ_get_pubkey(req);
		if (tpubkey == NULL) {
			fprintf(stdout, "Modulus=unavailable\n");
			goto end;
		}
		fprintf(stdout, "Modulus=");
		if (EVP_PKEY_base_id(tpubkey) == EVP_PKEY_RSA)
			BN_print(out, tpubkey->pkey.rsa->n);
		else
			fprintf(stdout, "Wrong Algorithm type");
		EVP_PKEY_free(tpubkey);
		fprintf(stdout, "\n");
	}
	if (!noout && !x509) {
		if (outformat == FORMAT_ASN1)
			i = i2d_X509_REQ_bio(out, req);
		else if (outformat == FORMAT_PEM) {
			if (newhdr)
				i = PEM_write_bio_X509_REQ_NEW(out, req);
			else
				i = PEM_write_bio_X509_REQ(out, req);
		} else {
			BIO_printf(bio_err, "bad output format specified for outfile\n");
			goto end;
		}
		if (!i) {
			BIO_printf(bio_err, "unable to write X509 request\n");
			goto end;
		}
	}
	if (!noout && x509 && (x509ss != NULL)) {
		if (outformat == FORMAT_ASN1)
			i = i2d_X509_bio(out, x509ss);
		else if (outformat == FORMAT_PEM)
			i = PEM_write_bio_X509(out, x509ss);
		else {
			BIO_printf(bio_err, "bad output format specified for outfile\n");
			goto end;
		}
		if (!i) {
			BIO_printf(bio_err, "unable to write X509 certificate\n");
			goto end;
		}
	}
	ex = 0;
end:
	if (ex) {
		ERR_print_errors(bio_err);
	}
	if ((req_conf != NULL) && (req_conf != config))
		NCONF_free(req_conf);
	BIO_free(in);
	BIO_free_all(out);
	EVP_PKEY_free(pkey);
	if (genctx)
		EVP_PKEY_CTX_free(genctx);
	if (pkeyopts)
		sk_OPENSSL_STRING_free(pkeyopts);
	if (sigopts)
		sk_OPENSSL_STRING_free(sigopts);
#ifndef OPENSSL_NO_ENGINE
	if (gen_eng)
		ENGINE_free(gen_eng);
#endif
	free(keyalgstr);
	X509_REQ_free(req);
	X509_free(x509ss);
	ASN1_INTEGER_free(serial);
	if (passargin && passin)
		free(passin);
	if (passargout && passout)
		free(passout);
	OBJ_cleanup();

	return (ex);
}

static int
make_REQ(X509_REQ * req, EVP_PKEY * pkey, char *subj, int multirdn,
    int attribs, unsigned long chtype)
{
	int ret = 0, i;
	char no_prompt = 0;
	STACK_OF(CONF_VALUE) * dn_sk, *attr_sk = NULL;
	char *tmp, *dn_sect, *attr_sect;

	tmp = NCONF_get_string(req_conf, SECTION, PROMPT);
	if (tmp == NULL)
		ERR_clear_error();
	if ((tmp != NULL) && !strcmp(tmp, "no"))
		no_prompt = 1;

	dn_sect = NCONF_get_string(req_conf, SECTION, DISTINGUISHED_NAME);
	if (dn_sect == NULL) {
		BIO_printf(bio_err, "unable to find '%s' in config\n",
		    DISTINGUISHED_NAME);
		goto err;
	}
	dn_sk = NCONF_get_section(req_conf, dn_sect);
	if (dn_sk == NULL) {
		BIO_printf(bio_err, "unable to get '%s' section\n", dn_sect);
		goto err;
	}
	attr_sect = NCONF_get_string(req_conf, SECTION, ATTRIBUTES);
	if (attr_sect == NULL) {
		ERR_clear_error();
		attr_sk = NULL;
	} else {
		attr_sk = NCONF_get_section(req_conf, attr_sect);
		if (attr_sk == NULL) {
			BIO_printf(bio_err, "unable to get '%s' section\n", attr_sect);
			goto err;
		}
	}

	/* setup version number */
	if (!X509_REQ_set_version(req, 0L))
		goto err;	/* version 1 */

	if (no_prompt)
		i = auto_info(req, dn_sk, attr_sk, attribs, chtype);
	else {
		if (subj)
			i = build_subject(req, subj, chtype, multirdn);
		else
			i = prompt_info(req, dn_sk, dn_sect, attr_sk, attr_sect, attribs, chtype);
	}
	if (!i)
		goto err;

	if (!X509_REQ_set_pubkey(req, pkey))
		goto err;

	ret = 1;
err:
	return (ret);
}

/*
 * subject is expected to be in the format /type0=value0/type1=value1/type2=...
 * where characters may be escaped by \
 */
static int
build_subject(X509_REQ * req, char *subject, unsigned long chtype, int multirdn)
{
	X509_NAME *n;

	if (!(n = parse_name(subject, chtype, multirdn)))
		return 0;

	if (!X509_REQ_set_subject_name(req, n)) {
		X509_NAME_free(n);
		return 0;
	}
	X509_NAME_free(n);
	return 1;
}


static int
prompt_info(X509_REQ * req,
    STACK_OF(CONF_VALUE) * dn_sk, char *dn_sect,
    STACK_OF(CONF_VALUE) * attr_sk, char *attr_sect, int attribs,
    unsigned long chtype)
{
	int i;
	char *p, *q;
	char buf[100];
	int nid, mval;
	long n_min, n_max;
	char *type, *value;
	const char *def;
	CONF_VALUE *v;
	X509_NAME *subj;
	subj = X509_REQ_get_subject_name(req);

	if (!batch) {
		BIO_printf(bio_err, "You are about to be asked to enter information that will be incorporated\n");
		BIO_printf(bio_err, "into your certificate request.\n");
		BIO_printf(bio_err, "What you are about to enter is what is called a Distinguished Name or a DN.\n");
		BIO_printf(bio_err, "There are quite a few fields but you can leave some blank\n");
		BIO_printf(bio_err, "For some fields there will be a default value,\n");
		BIO_printf(bio_err, "If you enter '.', the field will be left blank.\n");
		BIO_printf(bio_err, "-----\n");
	}
	if (sk_CONF_VALUE_num(dn_sk)) {
		i = -1;
start:		for (;;) {
			int ret;
			i++;
			if (sk_CONF_VALUE_num(dn_sk) <= i)
				break;

			v = sk_CONF_VALUE_value(dn_sk, i);
			p = q = NULL;
			type = v->name;
			if (!check_end(type, "_min") || !check_end(type, "_max") ||
			    !check_end(type, "_default") ||
			    !check_end(type, "_value"))
				continue;
			/*
			 * Skip past any leading X. X: X, etc to allow for
			 * multiple instances
			 */
			for (p = v->name; *p; p++)
				if ((*p == ':') || (*p == ',') ||
				    (*p == '.')) {
					p++;
					if (*p)
						type = p;
					break;
				}
			if (*type == '+') {
				mval = -1;
				type++;
			} else
				mval = 0;
			/* If OBJ not recognised ignore it */
			if ((nid = OBJ_txt2nid(type)) == NID_undef)
				goto start;
			ret = snprintf(buf, sizeof buf, "%s_default", v->name);
			if (ret == -1 || ret >= sizeof(buf)) {
				BIO_printf(bio_err, "Name '%s' too long for default\n",
				    v->name);
				return 0;
			}
			if ((def = NCONF_get_string(req_conf, dn_sect, buf)) == NULL) {
				ERR_clear_error();
				def = "";
			}
			ret = snprintf(buf, sizeof buf, "%s_value", v->name);
			if (ret == -1 || ret >= sizeof(buf)) {
				BIO_printf(bio_err, "Name '%s' too long for value\n",
				    v->name);
				return 0;
			}
			if ((value = NCONF_get_string(req_conf, dn_sect, buf)) == NULL) {
				ERR_clear_error();
				value = NULL;
			}
			ret = snprintf(buf, sizeof buf, "%s_min", v->name);
			if (ret == -1 || ret >= sizeof(buf)) {
				BIO_printf(bio_err, "Name '%s' too long for min\n",
				    v->name);
				return 0;
			}
			if (!NCONF_get_number(req_conf, dn_sect, buf, &n_min)) {
				ERR_clear_error();
				n_min = -1;
			}
			ret = snprintf(buf, sizeof buf, "%s_max", v->name);
			if (ret == -1 || ret >= sizeof(buf)) {
				BIO_printf(bio_err, "Name '%s' too long for max\n",
				    v->name);
				return 0;
			}
			if (!NCONF_get_number(req_conf, dn_sect, buf, &n_max)) {
				ERR_clear_error();
				n_max = -1;
			}
			if (!add_DN_object(subj, v->value, def, value, nid,
				n_min, n_max, chtype, mval))
				return 0;
		}
		if (X509_NAME_entry_count(subj) == 0) {
			BIO_printf(bio_err, "error, no objects specified in config file\n");
			return 0;
		}
		if (attribs) {
			if ((attr_sk != NULL) && (sk_CONF_VALUE_num(attr_sk) > 0) &&
			    (!batch)) {
				BIO_printf(bio_err,
				    "\nPlease enter the following 'extra' attributes\n");
				BIO_printf(bio_err,
				    "to be sent with your certificate request\n");
			}
			i = -1;
start2:			for (;;) {
				int ret;
				i++;
				if ((attr_sk == NULL) ||
				    (sk_CONF_VALUE_num(attr_sk) <= i))
					break;

				v = sk_CONF_VALUE_value(attr_sk, i);
				type = v->name;
				if ((nid = OBJ_txt2nid(type)) == NID_undef)
					goto start2;
				ret = snprintf(buf, sizeof buf, "%s_default", type);
				if (ret == -1 || ret >= sizeof(buf)) {
					BIO_printf(bio_err, "Name '%s' too long for default\n",
					    v->name);
					return 0;
				}
				if ((def = NCONF_get_string(req_conf, attr_sect, buf))
				    == NULL) {
					ERR_clear_error();
					def = "";
				}
				ret = snprintf(buf, sizeof buf, "%s_value", type);
				if (ret == -1 || ret >= sizeof(buf)) {
					BIO_printf(bio_err, "Name '%s' too long for value\n",
					    v->name);
					return 0;
				}
				if ((value = NCONF_get_string(req_conf, attr_sect, buf))
				    == NULL) {
					ERR_clear_error();
					value = NULL;
				}
				ret = snprintf(buf, sizeof buf, "%s_min", type);
				if (ret == -1 || ret >= sizeof(buf)) {
					BIO_printf(bio_err, "Name '%s' too long for min\n",
					    v->name);
					return 0;
				}
				if (!NCONF_get_number(req_conf, attr_sect, buf, &n_min)) {
					ERR_clear_error();
					n_min = -1;
				}
				ret = snprintf(buf, sizeof buf, "%s_max", type);
				if (ret == -1 || ret >= sizeof(buf)) {
					BIO_printf(bio_err, "Name '%s' too long for max\n",
					    v->name);
					return 0;
				}
				if (!NCONF_get_number(req_conf, attr_sect, buf, &n_max)) {
					ERR_clear_error();
					n_max = -1;
				}
				if (!add_attribute_object(req,
					v->value, def, value, nid, n_min, n_max, chtype))
					return 0;
			}
		}
	} else {
		BIO_printf(bio_err, "No template, please set one up.\n");
		return 0;
	}

	return 1;

}

static int
auto_info(X509_REQ * req, STACK_OF(CONF_VALUE) * dn_sk,
    STACK_OF(CONF_VALUE) * attr_sk, int attribs, unsigned long chtype)
{
	int i;
	char *p, *q;
	char *type;
	CONF_VALUE *v;
	X509_NAME *subj;

	subj = X509_REQ_get_subject_name(req);

	for (i = 0; i < sk_CONF_VALUE_num(dn_sk); i++) {
		int mval;
		v = sk_CONF_VALUE_value(dn_sk, i);
		p = q = NULL;
		type = v->name;
		/*
		 * Skip past any leading X. X: X, etc to allow for multiple
		 * instances
		 */
		for (p = v->name; *p; p++)
			if ((*p == ':') || (*p == ',') || (*p == '.')) {
				p++;
				if (*p)
					type = p;
				break;
			}
		if (*p == '+') {
			p++;
			mval = -1;
		} else
			mval = 0;
		if (!X509_NAME_add_entry_by_txt(subj, type, chtype,
			(unsigned char *) v->value, -1, -1, mval))
			return 0;

	}

	if (!X509_NAME_entry_count(subj)) {
		BIO_printf(bio_err, "error, no objects specified in config file\n");
		return 0;
	}
	if (attribs) {
		for (i = 0; i < sk_CONF_VALUE_num(attr_sk); i++) {
			v = sk_CONF_VALUE_value(attr_sk, i);
			if (!X509_REQ_add1_attr_by_txt(req, v->name, chtype,
				(unsigned char *) v->value, -1))
				return 0;
		}
	}
	return 1;
}


static int
add_DN_object(X509_NAME * n, char *text, const char *def, char *value,
    int nid, int n_min, int n_max, unsigned long chtype, int mval)
{
	int i, ret = 0;
	char buf[1024];
start:
	if (!batch)
		BIO_printf(bio_err, "%s [%s]:", text, def);
	(void) BIO_flush(bio_err);
	if (value != NULL) {
		strlcpy(buf, value, sizeof buf);
		strlcat(buf, "\n", sizeof buf);
		BIO_printf(bio_err, "%s\n", value);
	} else {
		buf[0] = '\0';
		if (!batch) {
			if (!fgets(buf, sizeof buf, stdin))
				return 0;
		} else {
			buf[0] = '\n';
			buf[1] = '\0';
		}
	}

	if (buf[0] == '\0')
		return (0);
	else if (buf[0] == '\n') {
		if ((def == NULL) || (def[0] == '\0'))
			return (1);
		strlcpy(buf, def, sizeof buf);
		strlcat(buf, "\n", sizeof buf);
	} else if ((buf[0] == '.') && (buf[1] == '\n'))
		return (1);

	i = strlen(buf);
	if (buf[i - 1] != '\n') {
		BIO_printf(bio_err, "weird input :-(\n");
		return (0);
	}
	buf[--i] = '\0';
	if (!req_check_len(i, n_min, n_max))
		goto start;
	if (!X509_NAME_add_entry_by_NID(n, nid, chtype,
		(unsigned char *) buf, -1, -1, mval))
		goto err;
	ret = 1;
err:
	return (ret);
}

static int
add_attribute_object(X509_REQ * req, char *text, const char *def,
    char *value, int nid, int n_min,
    int n_max, unsigned long chtype)
{
	int i;
	static char buf[1024];

start:
	if (!batch)
		BIO_printf(bio_err, "%s [%s]:", text, def);
	(void) BIO_flush(bio_err);
	if (value != NULL) {
		strlcpy(buf, value, sizeof buf);
		strlcat(buf, "\n", sizeof buf);
		BIO_printf(bio_err, "%s\n", value);
	} else {
		buf[0] = '\0';
		if (!batch) {
			if (!fgets(buf, sizeof buf, stdin))
				return 0;
		} else {
			buf[0] = '\n';
			buf[1] = '\0';
		}
	}

	if (buf[0] == '\0')
		return (0);
	else if (buf[0] == '\n') {
		if ((def == NULL) || (def[0] == '\0'))
			return (1);
		strlcpy(buf, def, sizeof buf);
		strlcat(buf, "\n", sizeof buf);
	} else if ((buf[0] == '.') && (buf[1] == '\n'))
		return (1);

	i = strlen(buf);
	if (buf[i - 1] != '\n') {
		BIO_printf(bio_err, "weird input :-(\n");
		return (0);
	}
	buf[--i] = '\0';
	if (!req_check_len(i, n_min, n_max))
		goto start;

	if (!X509_REQ_add1_attr_by_NID(req, nid, chtype,
		(unsigned char *) buf, -1)) {
		BIO_printf(bio_err, "Error adding attribute\n");
		ERR_print_errors(bio_err);
		goto err;
	}
	return (1);
err:
	return (0);
}

static int
req_check_len(int len, int n_min, int n_max)
{
	if ((n_min > 0) && (len < n_min)) {
		BIO_printf(bio_err, "string is too short, it needs to be at least %d bytes long\n", n_min);
		return (0);
	}
	if ((n_max >= 0) && (len > n_max)) {
		BIO_printf(bio_err, "string is too long, it needs to be less than  %d bytes long\n", n_max);
		return (0);
	}
	return (1);
}

/* Check if the end of a string matches 'end' */
static int
check_end(const char *str, const char *end)
{
	int elen, slen;
	const char *tmp;
	elen = strlen(end);
	slen = strlen(str);
	if (elen > slen)
		return 1;
	tmp = str + slen - elen;
	return strcmp(tmp, end);
}

static EVP_PKEY_CTX *
set_keygen_ctx(BIO * err, const char *gstr, int *pkey_type,
    long *pkeylen, char **palgnam,
    ENGINE * keygen_engine)
{
	EVP_PKEY_CTX *gctx = NULL;
	EVP_PKEY *param = NULL;
	long keylen = -1;
	BIO *pbio = NULL;
	const char *paramfile = NULL;
	const char *errstr;

	if (gstr == NULL) {
		*pkey_type = EVP_PKEY_RSA;
		keylen = *pkeylen;
	} else if (gstr[0] >= '0' && gstr[0] <= '9') {
		*pkey_type = EVP_PKEY_RSA;
		keylen = strtonum(gstr, 0, LONG_MAX, &errstr);
		if (errstr) {
			BIO_printf(err, "bad algorithm %s: %s\n", gstr, errstr);
			return NULL;
		}
		*pkeylen = keylen;
	} else if (!strncmp(gstr, "param:", 6))
		paramfile = gstr + 6;
	else {
		const char *p = strchr(gstr, ':');
		int len;
		ENGINE *tmpeng;
		const EVP_PKEY_ASN1_METHOD *ameth;

		if (p)
			len = p - gstr;
		else
			len = strlen(gstr);
		/*
		 * The lookup of a the string will cover all engines so keep
		 * a note of the implementation.
		 */

		ameth = EVP_PKEY_asn1_find_str(&tmpeng, gstr, len);

		if (!ameth) {
			BIO_printf(err, "Unknown algorithm %.*s\n", len, gstr);
			return NULL;
		}
		EVP_PKEY_asn1_get0_info(NULL, pkey_type, NULL, NULL, NULL,
		    ameth);
#ifndef OPENSSL_NO_ENGINE
		if (tmpeng)
			ENGINE_finish(tmpeng);
#endif
		if (*pkey_type == EVP_PKEY_RSA) {
			if (p) {
				keylen = strtonum(p + 1, 0, LONG_MAX, &errstr);
				if (errstr) {
					BIO_printf(err, "bad algorithm %s: %s\n",
					    p + 1, errstr);
					return NULL;
				}
				*pkeylen = keylen;
			} else
				keylen = *pkeylen;
		} else if (p)
			paramfile = p + 1;
	}

	if (paramfile) {
		pbio = BIO_new_file(paramfile, "r");
		if (!pbio) {
			BIO_printf(err, "Can't open parameter file %s\n",
			    paramfile);
			return NULL;
		}
		param = PEM_read_bio_Parameters(pbio, NULL);

		if (!param) {
			X509 *x;
			(void) BIO_reset(pbio);
			x = PEM_read_bio_X509(pbio, NULL, NULL, NULL);
			if (x) {
				param = X509_get_pubkey(x);
				X509_free(x);
			}
		}
		BIO_free(pbio);

		if (!param) {
			BIO_printf(err, "Error reading parameter file %s\n",
			    paramfile);
			return NULL;
		}
		if (*pkey_type == -1)
			*pkey_type = EVP_PKEY_id(param);
		else if (*pkey_type != EVP_PKEY_base_id(param)) {
			BIO_printf(err, "Key Type does not match parameters\n");
			EVP_PKEY_free(param);
			return NULL;
		}
	}
	if (palgnam) {
		const EVP_PKEY_ASN1_METHOD *ameth;
		ENGINE *tmpeng;
		const char *anam;
		ameth = EVP_PKEY_asn1_find(&tmpeng, *pkey_type);
		if (!ameth) {
			BIO_puts(err, "Internal error: can't find key algorithm\n");
			return NULL;
		}
		EVP_PKEY_asn1_get0_info(NULL, NULL, NULL, NULL, &anam, ameth);
		*palgnam = BUF_strdup(anam);
#ifndef OPENSSL_NO_ENGINE
		if (tmpeng)
			ENGINE_finish(tmpeng);
#endif
	}
	if (param) {
		gctx = EVP_PKEY_CTX_new(param, keygen_engine);
		*pkeylen = EVP_PKEY_bits(param);
		EVP_PKEY_free(param);
	} else
		gctx = EVP_PKEY_CTX_new_id(*pkey_type, keygen_engine);

	if (!gctx) {
		BIO_puts(err, "Error allocating keygen context\n");
		ERR_print_errors(err);
		return NULL;
	}
	if (EVP_PKEY_keygen_init(gctx) <= 0) {
		BIO_puts(err, "Error initializing keygen context\n");
		ERR_print_errors(err);
		return NULL;
	}
	if ((*pkey_type == EVP_PKEY_RSA) && (keylen != -1)) {
		if (EVP_PKEY_CTX_set_rsa_keygen_bits(gctx, keylen) <= 0) {
			BIO_puts(err, "Error setting RSA keysize\n");
			ERR_print_errors(err);
			EVP_PKEY_CTX_free(gctx);
			return NULL;
		}
	}

	return gctx;
}

static int
genpkey_cb(EVP_PKEY_CTX * ctx)
{
	char c = '*';
	BIO *b = EVP_PKEY_CTX_get_app_data(ctx);
	int p;
	p = EVP_PKEY_CTX_get_keygen_info(ctx, 0);
	if (p == 0)
		c = '.';
	if (p == 1)
		c = '+';
	if (p == 2)
		c = '*';
	if (p == 3)
		c = '\n';
	BIO_write(b, &c, 1);
	(void) BIO_flush(b);
	return 1;
}

static int
do_sign_init(BIO * err, EVP_MD_CTX * ctx, EVP_PKEY * pkey,
    const EVP_MD * md, STACK_OF(OPENSSL_STRING) * sigopts)
{
	EVP_PKEY_CTX *pkctx = NULL;
	int i;
	EVP_MD_CTX_init(ctx);
	if (!EVP_DigestSignInit(ctx, &pkctx, md, NULL, pkey))
		return 0;
	for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++) {
		char *sigopt = sk_OPENSSL_STRING_value(sigopts, i);
		if (pkey_ctrl_string(pkctx, sigopt) <= 0) {
			BIO_printf(err, "parameter error \"%s\"\n", sigopt);
			ERR_print_errors(bio_err);
			return 0;
		}
	}
	return 1;
}

int
do_X509_sign(BIO * err, X509 * x, EVP_PKEY * pkey, const EVP_MD * md,
    STACK_OF(OPENSSL_STRING) * sigopts)
{
	int rv;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);
	rv = do_sign_init(err, &mctx, pkey, md, sigopts);
	if (rv > 0)
		rv = X509_sign_ctx(x, &mctx);
	EVP_MD_CTX_cleanup(&mctx);
	return rv > 0 ? 1 : 0;
}


int
do_X509_REQ_sign(BIO * err, X509_REQ * x, EVP_PKEY * pkey, const EVP_MD * md,
    STACK_OF(OPENSSL_STRING) * sigopts)
{
	int rv;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);
	rv = do_sign_init(err, &mctx, pkey, md, sigopts);
	if (rv > 0)
		rv = X509_REQ_sign_ctx(x, &mctx);
	EVP_MD_CTX_cleanup(&mctx);
	return rv > 0 ? 1 : 0;
}



int
do_X509_CRL_sign(BIO * err, X509_CRL * x, EVP_PKEY * pkey, const EVP_MD * md,
    STACK_OF(OPENSSL_STRING) * sigopts)
{
	int rv;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);
	rv = do_sign_init(err, &mctx, pkey, md, sigopts);
	if (rv > 0)
		rv = X509_CRL_sign_ctx(x, &mctx);
	EVP_MD_CTX_cleanup(&mctx);
	return rv > 0 ? 1 : 0;
}
@


1.46
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: req.c,v 1.45 2014/07/09 21:02:35 tedu Exp $ */
@


1.45
log
@unifdef a whole bunch of NO RSA/DSA/ECDH defines i deleted from libssl
@
text
@d1 1
a1 1
/* $OpenBSD: req.c,v 1.44 2014/06/28 04:39:41 deraadt Exp $ */
d912 1
a912 1
	
d916 1
a916 1
static int 
d981 1
a981 1
static int 
d998 1
a998 1
static int 
d1183 1
a1183 1
static int 
d1238 1
a1238 1
static int 
d1289 1
a1289 1
static int 
d1346 1
a1346 1
static int 
d1361 1
a1361 1
static int 
d1395 1
a1395 1
		} 
d1432 1
a1432 1
					return NULL;					
d1519 1
a1519 1
static int 
d1539 1
a1539 1
static int 
d1559 1
a1559 1
int 
d1574 1
a1574 1
int 
d1590 1
a1590 1
int 
@


1.44
log
@Use strtonum() instead of atoi(), and then impose what are we think
are the current range checks.  Help from millert and lteo.  Please test
now that it is deployed and let us know if any numbers are off..
ok lteo
@
text
@d1 1
a1 1
/* $OpenBSD: req.c,v 1.43 2014/06/12 15:49:27 deraadt Exp $ */
a83 1
#ifndef OPENSSL_NO_DSA
a84 1
#endif
a85 1
#ifndef OPENSSL_NO_RSA
a86 1
#endif
a381 1
#ifndef OPENSSL_NO_ECDSA
a382 1
#endif
a844 1
#ifndef OPENSSL_NO_RSA
a847 1
#endif
a1506 1
#ifndef OPENSSL_NO_RSA
a1514 1
#endif
@


1.43
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d67 1
d326 2
d330 4
a333 2
			days = atoi(*(++argv));
			if (days == 0)
d335 1
d1392 1
d1399 5
a1403 1
		keylen = atol(gstr);
d1436 6
a1441 1
				keylen = atol(p + 1);
@


1.42
log
@Stop pretending that openssl(1) applications support the -rand option.
The underlying code has long been removed, making this a no-op.

If your random subsystem actually requires that you seed it from a file,
then you really should go and buy a new random subsystem that was built
after 1990.

Diff from Brent Cook.

ok deraadt@@
@
text
@d1 1
a1 1
/* apps/req.c */
@


1.41
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@a117 1
 * -rand file(s) - load the file(s) into the PRNG.
a180 1
	char *inrand = NULL;
a262 4
		} else if (strcmp(*argv, "-rand") == 0) {
			if (--argc < 1)
				goto bad;
			inrand = *(++argv);
a377 3
		BIO_printf(bio_err, " -rand file:file:...\n");
		BIO_printf(bio_err, "                load the file (or the files in the directory) into\n");
		BIO_printf(bio_err, "                the random number generator\n");
@


1.40
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a194 1
	signal(SIGPIPE, SIG_IGN);
@


1.39
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d915 1
a915 2
	if (keyalgstr)
		free(keyalgstr);
@


1.38
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d67 1
d69 1
a69 1
#include <string.h>
d71 2
d74 1
a74 1
#include <openssl/evp.h>
d77 3
a79 1
#include <openssl/asn1.h>
d82 5
a86 3
#include <openssl/objects.h>
#include <openssl/pem.h>
#include <openssl/bn.h>
a88 3
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
@


1.37
log
@unifdef -U LINT
@
text
@a192 4
	if (bio_err == NULL)
		if ((bio_err = BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);

@


1.36
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a1540 3
#ifdef LINT
	p = n;
#endif
@


1.35
log
@Nuke the last of the windows related defines from the openssl apps.

ok deraadt@@
@
text
@d191 1
a191 1
	apps_startup();
d925 1
a925 1
	apps_shutdown();
@


1.34
log
@truncation check some snprintf calls (over-cautiously in case)
ok jsing beck
@
text
@a68 3
#ifdef OPENSSL_NO_STDIO
#define APPS_WIN16
#endif
@


1.33
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d1077 2
a1078 1
				BIO_printf(bio_err, "Name '%s' too long\n", v->name);
d1085 6
a1090 1
			snprintf(buf, sizeof buf, "%s_value", v->name);
d1095 6
a1100 1
			snprintf(buf, sizeof buf, "%s_min", v->name);
d1105 6
a1110 1
			snprintf(buf, sizeof buf, "%s_max", v->name);
d1124 6
a1129 3
			if ((attr_sk != NULL) && (sk_CONF_VALUE_num(attr_sk) > 0) && (!batch)) {
				BIO_printf(bio_err, "\nPlease enter the following 'extra' attributes\n");
				BIO_printf(bio_err, "to be sent with your certificate request\n");
d1132 1
a1132 1
	start2:	for (;;) {
d1145 2
a1146 1
					BIO_printf(bio_err, "Name '%s' too long\n", v->name);
d1154 6
a1159 1
				snprintf(buf, sizeof buf, "%s_value", type);
d1165 6
a1170 1
				snprintf(buf, sizeof buf, "%s_min", type);
d1175 6
a1180 1
				snprintf(buf, sizeof buf, "%s_max", type);
@


1.32
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d1084 1
a1084 1
			(void) snprintf(buf, sizeof buf, "%s_value", v->name);
d1089 1
a1089 1
			(void) snprintf(buf, sizeof buf, "%s_min", v->name);
d1094 1
a1094 1
			(void) snprintf(buf, sizeof buf, "%s_max", v->name);
d1134 1
a1134 1
				(void) snprintf(buf, sizeof buf, "%s_value", type);
d1140 1
a1140 1
				(void) snprintf(buf, sizeof buf, "%s_min", type);
d1145 1
a1145 1
				(void) snprintf(buf, sizeof buf, "%s_max", type);
@


1.31
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d1230 2
a1231 2
		BUF_strlcpy(buf, value, sizeof buf);
		BUF_strlcat(buf, "\n", sizeof buf);
d1249 2
a1250 2
		BUF_strlcpy(buf, def, sizeof buf);
		BUF_strlcat(buf, "\n", sizeof buf);
d1283 2
a1284 2
		BUF_strlcpy(buf, value, sizeof buf);
		BUF_strlcat(buf, "\n", sizeof buf);
d1302 2
a1303 2
		BUF_strlcpy(buf, def, sizeof buf);
		BUF_strlcat(buf, "\n", sizeof buf);
@


1.30
log
@whitespace normalization
@
text
@a551 5
		} else {
			char *randfile = NCONF_get_string(req_conf, SECTION, "RANDFILE");
			if (randfile == NULL)
				ERR_clear_error();
			app_RAND_load_file(randfile, bio_err, 0);
a554 7
		char *randfile = NCONF_get_string(req_conf, SECTION, "RANDFILE");
		if (randfile == NULL)
			ERR_clear_error();
		app_RAND_load_file(randfile, bio_err, 0);
		if (inrand)
			app_RAND_load_files(inrand);

a599 2

		app_RAND_write_file(randfile, bio_err);
@


1.29
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d126 1
a126 2
static int 
make_REQ(X509_REQ * req, EVP_PKEY * pkey, char *dn, int mutlirdn,
d128 1
a128 2
static int 
build_subject(X509_REQ * req, char *subj, unsigned long chtype,
d130 1
a130 2
static int 
prompt_info(X509_REQ * req,
d134 1
a134 1
	static int auto_info(X509_REQ * req, STACK_OF(CONF_VALUE) * sk,
d137 13
a149 13
	static int add_attribute_object(X509_REQ * req, char *text, const char *def,
     char *value, int nid, int n_min,
     int n_max, unsigned long chtype);
	static int add_DN_object(X509_NAME * n, char *text, const char *def, char *value,
     int nid, int n_min, int n_max, unsigned long chtype, int mval);
	static int genpkey_cb(EVP_PKEY_CTX * ctx);
	static int req_check_len(int len, int n_min, int n_max);
	static int check_end(const char *str, const char *end);
	static EVP_PKEY_CTX *set_keygen_ctx(BIO * err, const char *gstr, int *pkey_type,
     long *pkeylen, char **palgnam,
     ENGINE * keygen_engine);
	static CONF *req_conf = NULL;
	static int batch = 0;
d151 1
a151 1
	int req_main(int, char **);
d153 2
a154 1
	int req_main(int argc, char **argv)
@


1.28
log
@KaboomNF
@
text
@a104 2
#undef PROG
#define PROG	req_main
d154 1
a154 1
	int MAIN(int, char **);
d156 1
a156 1
	int MAIN(int argc, char **argv)
@


1.27
log
@Make MONOLITH the default and only option

ok deraadt
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d128 27
a154 24
static int make_REQ(X509_REQ *req,EVP_PKEY *pkey,char *dn,int mutlirdn,
		int attribs,unsigned long chtype);
static int build_subject(X509_REQ *req, char *subj, unsigned long chtype,
		int multirdn);
static int prompt_info(X509_REQ *req,
		STACK_OF(CONF_VALUE) *dn_sk, char *dn_sect,
		STACK_OF(CONF_VALUE) *attr_sk, char *attr_sect, int attribs,
		unsigned long chtype);
static int auto_info(X509_REQ *req, STACK_OF(CONF_VALUE) *sk,
				STACK_OF(CONF_VALUE) *attr, int attribs,
				unsigned long chtype);
static int add_attribute_object(X509_REQ *req, char *text, const char *def,
				char *value, int nid, int n_min,
				int n_max, unsigned long chtype);
static int add_DN_object(X509_NAME *n, char *text, const char *def, char *value,
	int nid,int n_min,int n_max, unsigned long chtype, int mval);
static int genpkey_cb(EVP_PKEY_CTX *ctx);
static int req_check_len(int len,int n_min,int n_max);
static int check_end(const char *str, const char *end);
static EVP_PKEY_CTX *set_keygen_ctx(BIO *err, const char *gstr, int *pkey_type,
					long *pkeylen, char **palgnam,
					ENGINE *keygen_engine);
static CONF *req_conf=NULL;
static int batch=0;
d156 1
a156 1
int MAIN(int, char **);
d158 2
a159 2
int MAIN(int argc, char **argv)
	{
d162 3
a164 3
	int ex=1,x509=0,days=30;
	X509 *x509ss=NULL;
	X509_REQ *req=NULL;
d168 3
a170 3
	STACK_OF(OPENSSL_STRING) *pkeyopts = NULL, *sigopts = NULL;
	EVP_PKEY *pkey=NULL;
	int i=0,badops=0,newreq=0,verbose=0,pkey_type=-1;
d172 5
a176 4
	BIO *in=NULL,*out=NULL;
	int informat,outformat,verify=0,noout=0,text=0,keyform=FORMAT_PEM;
	int nodes=0,kludge=0,newhdr=0,subject=0,pubkey=0;
	char *infile,*outfile,*prog,*keyfile=NULL,*template=NULL,*keyout=NULL;
d178 1
a178 1
	char *engine=NULL;
d182 1
a182 1
	const EVP_CIPHER *cipher=NULL;
d184 2
a185 2
	int modulus=0;
	char *inrand=NULL;
d191 1
a191 1
	const EVP_MD *md_alg=NULL,*digest=NULL;
d196 1
a196 1
	cipher=EVP_des_ede3_cbc();
d201 2
a202 2
		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);
d204 4
a207 4
	infile=NULL;
	outfile=NULL;
	informat=FORMAT_PEM;
	outformat=FORMAT_PEM;
d209 1
a209 1
	prog=argv[0];
d212 10
a221 12
	while (argc >= 1)
		{
		if 	(strcmp(*argv,"-inform") == 0)
			{
			if (--argc < 1) goto bad;
			informat=str2fmt(*(++argv));
			}
		else if (strcmp(*argv,"-outform") == 0)
			{
			if (--argc < 1) goto bad;
			outformat=str2fmt(*(++argv));
			}
d223 7
a229 8
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
			engine= *(++argv);
			}
		else if (strcmp(*argv,"-keygen_engine") == 0)
			{
			if (--argc < 1) goto bad;
d231 1
a231 2
			if (gen_eng == NULL)
				{
a233 1
				}
d235 1
d237 41
a277 55
		else if (strcmp(*argv,"-key") == 0)
			{
			if (--argc < 1) goto bad;
			keyfile= *(++argv);
			}
		else if (strcmp(*argv,"-pubkey") == 0)
			{
			pubkey=1;
			}
		else if (strcmp(*argv,"-new") == 0)
			{
			newreq=1;
			}
		else if (strcmp(*argv,"-config") == 0)
			{	
			if (--argc < 1) goto bad;
			template= *(++argv);
			}
		else if (strcmp(*argv,"-keyform") == 0)
			{
			if (--argc < 1) goto bad;
			keyform=str2fmt(*(++argv));
			}
		else if (strcmp(*argv,"-in") == 0)
			{
			if (--argc < 1) goto bad;
			infile= *(++argv);
			}
		else if (strcmp(*argv,"-out") == 0)
			{
			if (--argc < 1) goto bad;
			outfile= *(++argv);
			}
		else if (strcmp(*argv,"-keyout") == 0)
			{
			if (--argc < 1) goto bad;
			keyout= *(++argv);
			}
		else if (strcmp(*argv,"-passin") == 0)
			{
			if (--argc < 1) goto bad;
			passargin= *(++argv);
			}
		else if (strcmp(*argv,"-passout") == 0)
			{
			if (--argc < 1) goto bad;
			passargout= *(++argv);
			}
		else if (strcmp(*argv,"-rand") == 0)
			{
			if (--argc < 1) goto bad;
			inrand= *(++argv);
			}
		else if (strcmp(*argv,"-newkey") == 0)
			{
d281 2
a282 4
			newreq=1;
			}
		else if (strcmp(*argv,"-pkeyopt") == 0)
			{
d289 1
a289 3
			}
		else if (strcmp(*argv,"-sigopt") == 0)
			{
d296 15
a310 16
			}
		else if (strcmp(*argv,"-batch") == 0)
			batch=1;
		else if (strcmp(*argv,"-newhdr") == 0)
			newhdr=1;
		else if (strcmp(*argv,"-modulus") == 0)
			modulus=1;
		else if (strcmp(*argv,"-verify") == 0)
			verify=1;
		else if (strcmp(*argv,"-nodes") == 0)
			nodes=1;
		else if (strcmp(*argv,"-noout") == 0)
			noout=1;
		else if (strcmp(*argv,"-verbose") == 0)
			verbose=1;
		else if (strcmp(*argv,"-utf8") == 0)
d312 35
a346 36
		else if (strcmp(*argv,"-nameopt") == 0)
			{
			if (--argc < 1) goto bad;
			if (!set_name_ex(&nmflag, *(++argv))) goto bad;
			}
		else if (strcmp(*argv,"-reqopt") == 0)
			{
			if (--argc < 1) goto bad;
			if (!set_cert_ex(&reqflag, *(++argv))) goto bad;
			}
		else if (strcmp(*argv,"-subject") == 0)
			subject=1;
		else if (strcmp(*argv,"-text") == 0)
			text=1;
		else if (strcmp(*argv,"-x509") == 0)
			x509=1;
		else if (strcmp(*argv,"-asn1-kludge") == 0)
			kludge=1;
		else if (strcmp(*argv,"-no-asn1-kludge") == 0)
			kludge=0;
		else if (strcmp(*argv,"-subj") == 0)
			{
			if (--argc < 1) goto bad;
			subj= *(++argv);
			}
		else if (strcmp(*argv,"-multivalue-rdn") == 0)
			multirdn=1;
		else if (strcmp(*argv,"-days") == 0)
			{
			if (--argc < 1) goto bad;
			days= atoi(*(++argv));
			if (days == 0) days=30;
			}
		else if (strcmp(*argv,"-set_serial") == 0)
			{
			if (--argc < 1) goto bad;
d348 5
a352 5
			if (!serial) goto bad;
			}
		else if (strcmp(*argv,"-extensions") == 0)
			{
			if (--argc < 1) goto bad;
d354 3
a356 4
			}
		else if (strcmp(*argv,"-reqexts") == 0)
			{
			if (--argc < 1) goto bad;
d358 1
a358 3
			}
		else if ((md_alg=EVP_get_digestbyname(&((*argv)[1]))) != NULL)
			{
d360 4
a363 6
			digest=md_alg;
			}
		else
			{
			BIO_printf(bio_err,"unknown option %s\n",*argv);
			badops=1;
d365 1
a365 1
			}
d368 1
a368 1
		}
d370 1
a370 2
	if (badops)
		{
d372 12
a383 12
		BIO_printf(bio_err,"%s [options] <infile >outfile\n",prog);
		BIO_printf(bio_err,"where options  are\n");
		BIO_printf(bio_err," -inform arg    input format - DER or PEM\n");
		BIO_printf(bio_err," -outform arg   output format - DER or PEM\n");
		BIO_printf(bio_err," -in arg        input file\n");
		BIO_printf(bio_err," -out arg       output file\n");
		BIO_printf(bio_err," -text          text form of request\n");
		BIO_printf(bio_err," -pubkey        output public key\n");
		BIO_printf(bio_err," -noout         do not output REQ\n");
		BIO_printf(bio_err," -verify        verify signature on REQ\n");
		BIO_printf(bio_err," -modulus       RSA modulus\n");
		BIO_printf(bio_err," -nodes         don't encrypt the output key\n");
d385 1
a385 1
		BIO_printf(bio_err," -engine e      use engine e, possibly a hardware device\n");
d387 10
a396 10
		BIO_printf(bio_err," -subject       output the request's subject\n");
		BIO_printf(bio_err," -passin        private key password source\n");
		BIO_printf(bio_err," -key file      use the private key contained in file\n");
		BIO_printf(bio_err," -keyform arg   key file format\n");
		BIO_printf(bio_err," -keyout arg    file to send the key to\n");
		BIO_printf(bio_err," -rand file:file:...\n");
		BIO_printf(bio_err,"                load the file (or the files in the directory) into\n");
		BIO_printf(bio_err,"                the random number generator\n");
		BIO_printf(bio_err," -newkey rsa:bits generate a new RSA key of 'bits' in size\n");
		BIO_printf(bio_err," -newkey dsa:file generate a new DSA key, parameters taken from CA in 'file'\n");
d398 1
a398 1
		BIO_printf(bio_err," -newkey ec:file generate a new EC key, parameters taken from CA in 'file'\n");
d400 17
a416 17
		BIO_printf(bio_err," -[digest]      Digest to sign with (md5, sha1, md2, mdc2, md4)\n");
		BIO_printf(bio_err," -config file   request template file.\n");
		BIO_printf(bio_err," -subj arg      set or modify request subject\n");
		BIO_printf(bio_err," -multivalue-rdn enable support for multivalued RDNs\n");
		BIO_printf(bio_err," -new           new request.\n");
		BIO_printf(bio_err," -batch         do not ask anything during request generation\n");
		BIO_printf(bio_err," -x509          output a x509 structure instead of a cert. req.\n");
		BIO_printf(bio_err," -days          number of days a certificate generated by -x509 is valid for.\n");
		BIO_printf(bio_err," -set_serial    serial number to use for a certificate generated by -x509.\n");
		BIO_printf(bio_err," -newhdr        output \"NEW\" in the header lines\n");
		BIO_printf(bio_err," -asn1-kludge   Output the 'request' in a format that is wrong but some CA's\n");
		BIO_printf(bio_err,"                have been reported as requiring\n");
		BIO_printf(bio_err," -extensions .. specify certificate extension section (override value in config file)\n");
		BIO_printf(bio_err," -reqexts ..    specify request extension section (override value in config file)\n");
		BIO_printf(bio_err," -utf8          input characters are UTF8 (default ASCII)\n");
		BIO_printf(bio_err," -nameopt arg    - various certificate name options\n");
		BIO_printf(bio_err," -reqopt arg    - various request text options\n\n");
d418 1
a418 2
		}

d420 1
a420 1
	if(!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {
d424 1
a424 3

	if (template != NULL)
		{
d427 6
a432 7
		if( verbose )
			BIO_printf(bio_err,"Using configuration from %s\n",template);
		req_conf=NCONF_new(NULL);
		i=NCONF_load(req_conf,template,&errline);
		if (i == 0)
			{
			BIO_printf(bio_err,"error on line %ld of %s\n",errline,template);
a433 1
			}
d435 5
a439 7
	else
		{
		req_conf=config;

		if (req_conf == NULL)
			{
			BIO_printf(bio_err,"Unable to load config info from %s\n", default_config_file);
d442 4
a445 5
			}
		else if( verbose )
			BIO_printf(bio_err,"Using configuration from %s\n",
			default_config_file);
		}
d447 1
a447 2
	if (req_conf != NULL)
		{
d450 1
a450 1
		p=NCONF_get_string(req_conf,NULL,"oid_file");
d453 1
a453 2
		if (p != NULL)
			{
d456 2
a457 3
			oid_bio=BIO_new_file(p,"r");
			if (oid_bio == NULL) 
				{
d462 1
a462 3
				}
			else
				{
a464 1
				}
d467 3
a469 1
	if(!add_oid_section(bio_err, req_conf)) goto end;
d471 2
a472 3
	if (md_alg == NULL)
		{
		p=NCONF_get_string(req_conf,SECTION,"default_md");
d475 3
a477 5
		if (p != NULL)
			{
			if ((md_alg=EVP_get_digestbyname(p)) != NULL)
				digest=md_alg;
			}
d479 2
a480 3

	if (!extensions)
		{
d484 1
a484 1
		}
d490 1
a490 1
		if(!X509V3_EXT_add_nconf(req_conf, &ctx, extensions, NULL)) {
d492 1
a492 1
			 "Error Loading extension section %s\n", extensions);
d496 1
a496 3

	if(!passin)
		{
d500 2
a501 4
		}
	
	if(!passout)
		{
d505 1
a505 2
		}

d510 1
a510 1
	if(p && !ASN1_STRING_set_default_mask_asc(p)) {
d514 1
a514 3

	if (chtype != MBSTRING_UTF8)
		{
d520 2
a521 5
		}


	if(!req_exts)
		{
d525 2
a526 2
		}
	if(req_exts) {
d531 1
a531 1
		if(!X509V3_EXT_add_nconf(req_conf, &ctx, req_exts, NULL)) {
d533 2
a534 2
			 "Error Loading request extension section %s\n",
								req_exts);
d538 2
a539 3

	in=BIO_new(BIO_s_file());
	out=BIO_new(BIO_s_file());
d544 1
a544 1
        e = setup_engine(bio_err, engine, 0);
d547 1
a547 2
	if (keyfile != NULL)
		{
d549 6
a554 5
			"Private Key");
		if (!pkey)
			{
			/* load_key() has already printed an appropriate
			   message */
d556 2
a557 4
			}
		else
			{
			char *randfile = NCONF_get_string(req_conf,SECTION,"RANDFILE");
a560 1
			}
d562 3
a564 4

	if (newreq && (pkey == NULL))
		{
		char *randfile = NCONF_get_string(req_conf,SECTION,"RANDFILE");
d571 4
a574 7
		if (!NCONF_get_number(req_conf,SECTION,BITS, &newkey))
			{
			newkey=DEFAULT_KEY_LENGTH;
			}

		if (keyalg)
			{
d576 1
a576 1
							&keyalgstr, gen_eng);
d579 4
a582 6
			}
	
		if (newkey < MIN_KEY_LENGTH && (pkey_type == EVP_PKEY_RSA || pkey_type == EVP_PKEY_DSA))
			{
			BIO_printf(bio_err,"private key length is too short,\n");
			BIO_printf(bio_err,"it needs to be at least %d bits, not %ld\n",MIN_KEY_LENGTH,newkey);
d584 2
a585 4
			}

		if (!genctx)
			{
d587 1
a587 1
							&keyalgstr, gen_eng);
d590 2
a591 4
			}

		if (pkeyopts)
			{
d593 1
a593 2
			for (i = 0; i < sk_OPENSSL_STRING_num(pkeyopts); i++)
				{
d595 1
a595 2
				if (pkey_ctrl_string(genctx, genopt) <= 0)
					{
d597 2
a598 2
						"parameter error \"%s\"\n",
						genopt);
a600 1
					}
d603 3
a605 3

		BIO_printf(bio_err,"Generating a %ld bit %s private key\n",
				newkey, keyalgstr);
d610 1
a610 2
		if (EVP_PKEY_keygen(genctx, &pkey) <= 0)
			{
d613 1
a613 2
			}

d619 2
a620 3
		if (keyout == NULL)
			{
			keyout=NCONF_get_string(req_conf,SECTION,KEYFILE);
d623 7
a629 12
			}
		
		if (keyout == NULL)
			{
			BIO_printf(bio_err,"writing new private key to stdout\n");
			BIO_set_fp(out,stdout,BIO_NOCLOSE);
			}
		else
			{
			BIO_printf(bio_err,"writing new private key to '%s'\n",keyout);
			if (BIO_write_filename(out,keyout) <= 0)
				{
a631 1
				}
d633 1
d635 2
a636 3
		p=NCONF_get_string(req_conf,SECTION,"encrypt_rsa_key");
		if (p == NULL)
			{
d638 1
a638 1
			p=NCONF_get_string(req_conf,SECTION,"encrypt_key");
d641 7
a647 6
			}
		if ((p != NULL) && (strcmp(p,"no") == 0))
			cipher=NULL;
		if (nodes) cipher=NULL;
		
		i=0;
d649 2
a650 3
		if (!PEM_write_bio_PrivateKey(out,pkey,cipher,
			NULL,0,NULL,passout))
			{
d652 1
a652 2
				PEM_R_PROBLEMS_GETTING_PASSWORD) && (i < 3))
				{
d656 1
a656 1
				}
a657 2
			}
		BIO_printf(bio_err,"-----\n");
d659 8
a666 7

	if (!newreq)
		{
		/* Since we are using a pre-existing certificate
		 * request, the kludge 'format' info should not be
		 * changed. */
		kludge= -1;
d668 3
a670 5
			BIO_set_fp(in,stdin,BIO_NOCLOSE);
		else
			{
			if (BIO_read_filename(in,infile) <= 0)
				{
a672 1
				}
d674 1
d676 2
a677 2
		if	(informat == FORMAT_ASN1)
			req=d2i_X509_REQ_bio(in,NULL);
d679 3
a681 4
			req=PEM_read_bio_X509_REQ(in,NULL,NULL,NULL);
		else
			{
			BIO_printf(bio_err,"bad input format specified for X509 request\n");
d683 3
a685 4
			}
		if (req == NULL)
			{
			BIO_printf(bio_err,"unable to load X509 request\n");
a686 1
			}
d688 4
a691 6

	if (newreq || x509)
		{
		if (pkey == NULL)
			{
			BIO_printf(bio_err,"you need to specify a private key\n");
d693 5
d699 3
a701 13

		if (req == NULL)
			{
			req=X509_REQ_new();
			if (req == NULL)
				{
				goto end;
				}

			i=make_REQ(req,pkey,subj,multirdn,!x509, chtype);
			subj=NULL; /* done processing '-subj' option */
			if ((kludge > 0) && !sk_X509_ATTRIBUTE_num(req->req_info->attributes))
				{
d704 3
a706 4
				}
			if (!i)
				{
				BIO_printf(bio_err,"problems making Certificate Request\n");
a707 1
				}
d709 2
a710 2
		if (x509)
			{
d713 2
a714 1
			if ((x509ss=X509_new()) == NULL) goto end;
d717 6
a722 7
			if(extensions && !X509_set_version(x509ss, 2)) goto end;
			if (serial)
				{
				if (!X509_set_serialNumber(x509ss, serial)) goto end;
				}
			else
				{
d725 2
a726 2
						goto end;
				}
d728 8
a735 4
			if (!X509_set_issuer_name(x509ss, X509_REQ_get_subject_name(req))) goto end;
			if (!X509_gmtime_adj(X509_get_notBefore(x509ss),0)) goto end;
			if (!X509_time_adj_ex(X509_get_notAfter(x509ss), days, 0, NULL)) goto end;
			if (!X509_set_subject_name(x509ss, X509_REQ_get_subject_name(req))) goto end;
d737 2
a738 1
			if (!tmppkey || !X509_set_pubkey(x509ss,tmppkey)) goto end;
d747 2
a748 3
			if(extensions && !X509V3_EXT_add_nconf(req_conf, 
				 	&ext_ctx, extensions, x509ss))
				{
d750 2
a751 2
					"Error Loading extension section %s\n",
					extensions);
d753 3
a755 5
				}

			i=do_X509_sign(bio_err, x509ss, pkey, digest, sigopts);
			if (!i)
				{
a757 1
				}
d759 1
a759 2
		else
			{
d768 2
a769 3
			if(req_exts && !X509V3_EXT_REQ_add_nconf(req_conf, 
				 	&ext_ctx, req_exts, req))
				{
d771 2
a772 2
					"Error Loading extension section %s\n",
					req_exts);
d774 3
a776 4
				}
			i=do_X509_REQ_sign(bio_err, req, pkey, digest, sigopts);
			if (!i)
				{
a778 1
				}
d781 2
a782 3

	if (subj && x509)
		{
d785 3
a787 6
		}

	if (subj && !x509)
		{
		if (verbose)
			{
d790 2
a791 4
			}

		if (build_subject(req, subj, chtype, multirdn) == 0)
			{
d793 1
a793 1
			ex=1;
d795 1
a795 2
			}

d798 1
a798 2
		if (verbose)
			{
a799 1
			}
d801 3
d805 7
a811 12
	if (verify && !x509)
		{
		int tmp=0;

		if (pkey == NULL)
			{
			pkey=X509_REQ_get_pubkey(req);
			tmp=1;
			if (pkey == NULL) goto end;
			}

		i=X509_REQ_verify(req,pkey);
d814 1
a814 1
			pkey=NULL;
d816 1
a816 3

		if (i < 0)
			{
d818 2
a819 4
			}
		else if (i == 0)
			{
			BIO_printf(bio_err,"verify failure\n");
d821 5
a825 8
			}
		else /* if (i > 0) */
			BIO_printf(bio_err,"verify OK\n");
		}

	if (noout && !text && !modulus && !subject && !pubkey)
		{
		ex=0;
d827 6
a832 10
		}

	if (outfile == NULL)
		{
		BIO_set_fp(out,stdout,BIO_NOCLOSE);
		}
	else
		{
		if ((keyout != NULL) && (strcmp(outfile,keyout) == 0))
			i=(int)BIO_append_filename(out,outfile);
d834 2
a835 3
			i=(int)BIO_write_filename(out,outfile);
		if (!i)
			{
a837 1
			}
d839 1
d841 5
a845 7
	if (pubkey)
		{
		EVP_PKEY *tpubkey; 
		tpubkey=X509_REQ_get_pubkey(req);
		if (tpubkey == NULL)
			{
			BIO_printf(bio_err,"Error getting public key\n");
d848 1
a848 1
			}
d851 2
a852 4
		}

	if (text)
		{
d855 1
a855 1
		else	
d857 3
a859 5
		}

	if(subject) 
		{
		if(x509)
d863 2
a864 4
		}

	if (modulus)
		{
d868 1
a868 1
			tpubkey=X509_get_pubkey(x509ss);
d870 6
a875 7
			tpubkey=X509_REQ_get_pubkey(req);
		if (tpubkey == NULL)
			{
			fprintf(stdout,"Modulus=unavailable\n");
			goto end; 
			}
		fprintf(stdout,"Modulus=");
d878 1
a878 1
			BN_print(out,tpubkey->pkey.rsa->n);
d881 1
a881 1
			fprintf(stdout,"Wrong Algorithm type");
d883 5
a887 7
		fprintf(stdout,"\n");
		}

	if (!noout && !x509)
		{
		if 	(outformat == FORMAT_ASN1)
			i=i2d_X509_REQ_bio(out,req);
d889 4
a892 2
			if(newhdr) i=PEM_write_bio_X509_REQ_NEW(out,req);
			else i=PEM_write_bio_X509_REQ(out,req);
d894 1
a894 1
			BIO_printf(bio_err,"bad output format specified for outfile\n");
d896 3
a898 4
			}
		if (!i)
			{
			BIO_printf(bio_err,"unable to write X509 request\n");
a899 1
			}
d901 4
a904 4
	if (!noout && x509 && (x509ss != NULL))
		{
		if 	(outformat == FORMAT_ASN1)
			i=i2d_X509_bio(out,x509ss);
d906 3
a908 3
			i=PEM_write_bio_X509(out,x509ss);
		else	{
			BIO_printf(bio_err,"bad output format specified for outfile\n");
d910 3
a912 4
			}
		if (!i)
			{
			BIO_printf(bio_err,"unable to write X509 certificate\n");
a913 1
			}
d915 2
a916 1
	ex=0;
d918 1
a918 2
	if (ex)
		{
d920 3
a922 2
		}
	if ((req_conf != NULL) && (req_conf != config)) NCONF_free(req_conf);
d941 4
a944 2
	if(passargin && passin) free(passin);
	if(passargout && passout) free(passout);
d947 2
a948 2
	return(ex);
	}
d950 5
a954 4
static int make_REQ(X509_REQ *req, EVP_PKEY *pkey, char *subj, int multirdn,
			int attribs, unsigned long chtype)
	{
	int ret=0,i;
d956 2
a957 2
	STACK_OF(CONF_VALUE) *dn_sk, *attr_sk = NULL;
	char *tmp, *dn_sect,*attr_sect;
d959 1
a959 1
	tmp=NCONF_get_string(req_conf,SECTION,PROMPT);
d962 2
a963 1
	if((tmp != NULL) && !strcmp(tmp, "no")) no_prompt = 1;
d965 4
a968 5
	dn_sect=NCONF_get_string(req_conf,SECTION,DISTINGUISHED_NAME);
	if (dn_sect == NULL)
		{
		BIO_printf(bio_err,"unable to find '%s' in config\n",
			DISTINGUISHED_NAME);
d970 4
a973 5
		}
	dn_sk=NCONF_get_section(req_conf,dn_sect);
	if (dn_sk == NULL)
		{
		BIO_printf(bio_err,"unable to get '%s' section\n",dn_sect);
d975 9
a983 14
		}

	attr_sect=NCONF_get_string(req_conf,SECTION,ATTRIBUTES);
	if (attr_sect == NULL)
		{
		ERR_clear_error();		
		attr_sk=NULL;
		}
	else
		{
		attr_sk=NCONF_get_section(req_conf,attr_sect);
		if (attr_sk == NULL)
			{
			BIO_printf(bio_err,"unable to get '%s' section\n",attr_sect);
a984 1
			}
d986 1
d989 2
a990 1
	if (!X509_REQ_set_version(req,0L)) goto err; /* version 1 */
d992 1
a992 1
	if (no_prompt) 
d994 1
a994 2
	else 
		{
d999 3
a1001 2
		}
	if(!i) goto err;
d1003 2
a1004 1
	if (!X509_REQ_set_pubkey(req,pkey)) goto err;
d1006 1
a1006 1
	ret=1;
d1008 2
a1009 2
	return(ret);
	}
d1015 3
a1017 2
static int build_subject(X509_REQ *req, char *subject, unsigned long chtype, int multirdn)
	{
d1023 1
a1023 2
	if (!X509_REQ_set_subject_name(req, n))
		{
d1026 1
a1026 1
		}
d1032 6
a1037 5
static int prompt_info(X509_REQ *req,
		STACK_OF(CONF_VALUE) *dn_sk, char *dn_sect,
		STACK_OF(CONF_VALUE) *attr_sk, char *attr_sect, int attribs,
		unsigned long chtype)
	{
d1039 1
a1039 1
	char *p,*q;
d1042 1
a1042 1
	long n_min,n_max;
d1049 12
a1060 17
	if(!batch)
		{
		BIO_printf(bio_err,"You are about to be asked to enter information that will be incorporated\n");
		BIO_printf(bio_err,"into your certificate request.\n");
		BIO_printf(bio_err,"What you are about to enter is what is called a Distinguished Name or a DN.\n");
		BIO_printf(bio_err,"There are quite a few fields but you can leave some blank\n");
		BIO_printf(bio_err,"For some fields there will be a default value,\n");
		BIO_printf(bio_err,"If you enter '.', the field will be left blank.\n");
		BIO_printf(bio_err,"-----\n");
		}


	if (sk_CONF_VALUE_num(dn_sk))
		{
		i= -1;
start:		for (;;)
			{
d1063 2
a1064 1
			if (sk_CONF_VALUE_num(dn_sk) <= i) break;
d1066 10
a1075 8
			v=sk_CONF_VALUE_value(dn_sk,i);
			p=q=NULL;
			type=v->name;
			if(!check_end(type,"_min") || !check_end(type,"_max") ||
				!check_end(type,"_default") ||
					 !check_end(type,"_value")) continue;
			/* Skip past any leading X. X: X, etc to allow for
			 * multiple instances 
d1077 1
a1077 1
			for(p = v->name; *p ; p++) 
d1079 1
a1079 1
							 (*p == '.')) {
d1081 2
a1082 1
					if(*p) type = p;
d1085 1
a1085 2
			if (*type == '+')
				{
d1088 1
a1088 2
				}
			else
d1091 8
a1098 10
			if ((nid=OBJ_txt2nid(type)) == NID_undef) goto start;
			ret = snprintf(buf,sizeof buf,"%s_default",v->name);
			if (ret == -1 || ret >= sizeof(buf))
			   {
			   BIO_printf(bio_err,"Name '%s' too long\n",v->name);
			   return 0;
			   }

			if ((def=NCONF_get_string(req_conf,dn_sect,buf)) == NULL)
				{
d1100 4
a1103 6
				def="";
				}
				
			(void) snprintf(buf,sizeof buf,"%s_value",v->name);
			if ((value=NCONF_get_string(req_conf,dn_sect,buf)) == NULL)
				{
d1105 4
a1108 6
				value=NULL;
				}

			(void) snprintf(buf,sizeof buf,"%s_min",v->name);
			if (!NCONF_get_number(req_conf,dn_sect,buf, &n_min))
				{
d1111 3
a1113 5
				}

			(void) snprintf(buf,sizeof buf,"%s_max",v->name);
			if (!NCONF_get_number(req_conf,dn_sect,buf, &n_max))
				{
d1116 3
a1118 4
				}

			if (!add_DN_object(subj,v->value,def,value,nid,
				n_min,n_max, chtype, mval))
d1120 3
a1122 4
			}
		if (X509_NAME_entry_count(subj) == 0)
			{
			BIO_printf(bio_err,"error, no objects specified in config file\n");
d1124 5
d1130 2
a1131 12

		if (attribs)
			{
			if ((attr_sk != NULL) && (sk_CONF_VALUE_num(attr_sk) > 0) && (!batch))
				{
				BIO_printf(bio_err,"\nPlease enter the following 'extra' attributes\n");
				BIO_printf(bio_err,"to be sent with your certificate request\n");
				}

			i= -1;
start2:			for (;;)
				{
d1135 1
a1135 1
					    (sk_CONF_VALUE_num(attr_sk) <= i))
d1138 3
a1140 3
				v=sk_CONF_VALUE_value(attr_sk,i);
				type=v->name;
				if ((nid=OBJ_txt2nid(type)) == NID_undef)
d1142 7
a1148 10
				ret = snprintf(buf,sizeof buf,"%s_default",type);
				if (ret == -1 || ret >= sizeof(buf))
				   {
				   BIO_printf(bio_err,"Name '%s' too long\n",v->name);
				   return 0;
				   }

				if ((def=NCONF_get_string(req_conf,attr_sect,buf))
					== NULL)
					{
d1150 5
a1154 8
					def="";
					}
				
				
				(void) snprintf(buf,sizeof buf,"%s_value",type);
				if ((value=NCONF_get_string(req_conf,attr_sect,buf))
					== NULL)
					{
d1156 4
a1159 6
					value=NULL;
					}

				(void) snprintf(buf,sizeof buf,"%s_min",type);
				if (!NCONF_get_number(req_conf,attr_sect,buf, &n_min))
					{
d1162 3
a1164 5
					}

				(void) snprintf(buf,sizeof buf,"%s_max",type);
				if (!NCONF_get_number(req_conf,attr_sect,buf, &n_max))
					{
d1167 1
a1167 2
					}

d1169 1
a1169 1
					v->value,def,value,nid,n_min,n_max, chtype))
a1170 1
				}
d1173 2
a1174 3
	else
		{
		BIO_printf(bio_err,"No template, please set one up.\n");
d1176 1
a1176 1
		}
d1180 1
a1180 1
	}
d1182 4
a1185 3
static int auto_info(X509_REQ *req, STACK_OF(CONF_VALUE) *dn_sk,
			STACK_OF(CONF_VALUE) *attr_sk, int attribs, unsigned long chtype)
	{
d1187 1
a1187 1
	char *p,*q;
d1194 1
a1194 2
	for (i = 0; i < sk_CONF_VALUE_num(dn_sk); i++)
		{
d1196 6
a1201 5
		v=sk_CONF_VALUE_value(dn_sk,i);
		p=q=NULL;
		type=v->name;
		/* Skip past any leading X. X: X, etc to allow for
		 * multiple instances 
d1203 1
a1203 1
		for(p = v->name; *p ; p++) 
d1206 2
a1207 1
				if(*p) type = p;
d1210 1
a1210 2
		if (*p == '+')
			{
d1213 1
a1213 2
			}
		else
d1215 3
a1217 2
		if (!X509_NAME_add_entry_by_txt(subj,type, chtype,
				(unsigned char *) v->value,-1,-1,mval)) return 0;
d1219 12
d1232 1
a1232 15

		if (!X509_NAME_entry_count(subj))
			{
			BIO_printf(bio_err,"error, no objects specified in config file\n");
			return 0;
			}
		if (attribs)
			{
			for (i = 0; i < sk_CONF_VALUE_num(attr_sk); i++)
				{
				v=sk_CONF_VALUE_value(attr_sk,i);
				if(!X509_REQ_add1_attr_by_txt(req, v->name, chtype,
					(unsigned char *)v->value, -1)) return 0;
				}
			}
d1234 1
a1234 1
	}
d1237 5
a1241 4
static int add_DN_object(X509_NAME *n, char *text, const char *def, char *value,
	     int nid, int n_min, int n_max, unsigned long chtype, int mval)
	{
	int i,ret=0;
d1244 11
a1254 14
	if (!batch) BIO_printf(bio_err,"%s [%s]:",text,def);
	(void)BIO_flush(bio_err);
	if(value != NULL)
		{
		BUF_strlcpy(buf,value,sizeof buf);
		BUF_strlcat(buf,"\n",sizeof buf);
		BIO_printf(bio_err,"%s\n",value);
		}
	else
		{
		buf[0]='\0';
		if (!batch)
			{
			if (!fgets(buf,sizeof buf,stdin))
d1256 1
a1256 3
			}
		else
			{
a1258 1
			}
d1260 1
d1262 3
a1264 3
	if (buf[0] == '\0') return(0);
	else if (buf[0] == '\n')
		{
d1266 18
a1283 17
			return(1);
		BUF_strlcpy(buf,def,sizeof buf);
		BUF_strlcat(buf,"\n",sizeof buf);
		}
	else if ((buf[0] == '.') && (buf[1] == '\n')) return(1);

	i=strlen(buf);
	if (buf[i-1] != '\n')
		{
		BIO_printf(bio_err,"weird input :-(\n");
		return(0);
		}
	buf[--i]='\0';
	if(!req_check_len(i, n_min, n_max)) goto start;
	if (!X509_NAME_add_entry_by_NID(n,nid, chtype,
				(unsigned char *) buf, -1,-1,mval)) goto err;
	ret=1;
d1285 2
a1286 2
	return(ret);
	}
d1288 5
a1292 4
static int add_attribute_object(X509_REQ *req, char *text, const char *def,
				char *value, int nid, int n_min,
				int n_max, unsigned long chtype)
	{
d1297 11
a1307 14
	if (!batch) BIO_printf(bio_err,"%s [%s]:",text,def);
	(void)BIO_flush(bio_err);
	if (value != NULL)
		{
		BUF_strlcpy(buf,value,sizeof buf);
		BUF_strlcat(buf,"\n",sizeof buf);
		BIO_printf(bio_err,"%s\n",value);
		}
	else
		{
		buf[0]='\0';
		if (!batch)
			{
			if (!fgets(buf,sizeof buf,stdin))
d1309 1
a1309 3
			}
		else
			{
a1311 1
			}
d1313 1
d1315 3
a1317 3
	if (buf[0] == '\0') return(0);
	else if (buf[0] == '\n')
		{
d1319 14
a1332 14
			return(1);
		BUF_strlcpy(buf,def,sizeof buf);
		BUF_strlcat(buf,"\n",sizeof buf);
		}
	else if ((buf[0] == '.') && (buf[1] == '\n')) return(1);

	i=strlen(buf);
	if (buf[i-1] != '\n')
		{
		BIO_printf(bio_err,"weird input :-(\n");
		return(0);
		}
	buf[--i]='\0';
	if(!req_check_len(i, n_min, n_max)) goto start;
d1334 2
a1335 2
	if(!X509_REQ_add1_attr_by_NID(req, nid, chtype,
					(unsigned char *)buf, -1)) {
d1340 4
d1345 6
a1350 3
	return(1);
err:
	return(0);
d1352 3
a1354 14

static int req_check_len(int len, int n_min, int n_max)
	{
	if ((n_min > 0) && (len < n_min))
		{
		BIO_printf(bio_err,"string is too short, it needs to be at least %d bytes long\n",n_min);
		return(0);
		}
	if ((n_max >= 0) && (len > n_max))
		{
		BIO_printf(bio_err,"string is too long, it needs to be less than  %d bytes long\n",n_max);
		return(0);
		}
	return(1);
d1356 2
d1360 2
a1361 1
static int check_end(const char *str, const char *end)
d1363 1
a1363 1
	int elen, slen;	
d1367 2
a1368 1
	if(elen > slen) return 1;
d1373 5
a1377 4
static EVP_PKEY_CTX *set_keygen_ctx(BIO *err, const char *gstr, int *pkey_type,
					long *pkeylen, char **palgnam,
					ENGINE *keygen_engine)
	{
d1384 1
a1384 2
	if (gstr == NULL)
		{
d1387 1
a1387 3
		}
	else if (gstr[0] >= '0' && gstr[0] <= '9')
		{
d1391 1
a1391 2
		}
	else if (!strncmp(gstr, "param:", 6))
d1393 1
a1393 2
	else
		{
d1403 3
a1405 2
		/* The lookup of a the string will cover all engines so
		 * keep a note of the implementation.
d1410 1
a1410 2
		if (!ameth)
			{
d1413 1
a1413 2
			}

d1415 1
a1415 1
									ameth);
d1420 2
a1421 4
		if (*pkey_type == EVP_PKEY_RSA)
			{
			if (p)
				{
d1424 1
a1424 2
				}
			else
d1426 1
a1426 2
			}
		else if (p)
d1428 1
a1428 1
		}
d1430 1
a1430 2
	if (paramfile)
		{
d1432 1
a1432 2
		if (!pbio)
			{
d1434 1
a1434 1
					paramfile);
d1436 1
a1436 1
			}
d1439 1
a1439 2
		if (!param)
			{
d1441 1
a1441 1
			(void)BIO_reset(pbio);
d1443 1
a1443 2
			if (x)
				{
a1445 1
				}
d1447 1
a1447 1

d1450 1
a1450 2
		if (!param)
			{
d1452 1
a1452 1
					paramfile);
d1454 1
a1454 1
			}
d1457 1
a1457 2
		else if (*pkey_type != EVP_PKEY_base_id(param))
			{
a1460 1
			}
d1462 2
a1463 3

	if (palgnam)
		{
d1468 1
a1468 2
		if (!ameth)
			{
d1471 1
a1471 1
			}
d1478 2
a1479 4
		}

	if (param)
		{
d1483 1
a1483 2
		}
	else
d1486 1
a1486 2
	if (!gctx)
		{
d1490 2
a1491 4
		}

	if (EVP_PKEY_keygen_init(gctx) <= 0)
		{
d1495 1
a1495 1
		}
d1497 2
a1498 4
	if ((*pkey_type == EVP_PKEY_RSA) && (keylen != -1))
		{
		if (EVP_PKEY_CTX_set_rsa_keygen_bits(gctx, keylen) <= 0)
			{
a1502 1
			}
d1504 1
d1508 1
a1508 1
	}
d1510 4
a1513 3
static int genpkey_cb(EVP_PKEY_CTX *ctx)
	{
	char c='*';
d1517 10
a1526 6
	if (p == 0) c='.';
	if (p == 1) c='+';
	if (p == 2) c='*';
	if (p == 3) c='\n';
	BIO_write(b,&c,1);
	(void)BIO_flush(b);
d1528 1
a1528 1
	p=n;
d1531 1
a1531 1
	}
d1533 4
a1536 3
static int do_sign_init(BIO *err, EVP_MD_CTX *ctx, EVP_PKEY *pkey,
			const EVP_MD *md, STACK_OF(OPENSSL_STRING) *sigopts)
	{
d1542 1
a1542 2
	for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++)
		{
d1544 1
a1544 2
		if (pkey_ctrl_string(pkctx, sigopt) <= 0)
			{
a1547 1
			}
d1549 1
d1551 1
a1551 1
	}
d1553 4
a1556 3
int do_X509_sign(BIO *err, X509 *x, EVP_PKEY *pkey, const EVP_MD *md,
			STACK_OF(OPENSSL_STRING) *sigopts)
	{
d1565 1
a1565 1
	}
d1568 4
a1571 3
int do_X509_REQ_sign(BIO *err, X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md,
			STACK_OF(OPENSSL_STRING) *sigopts)
	{
d1580 3
a1582 3
	}
		
	
d1584 4
a1587 3
int do_X509_CRL_sign(BIO *err, X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md,
			STACK_OF(OPENSSL_STRING) *sigopts)
	{
d1596 1
a1596 3
	}
		
	
@


1.26
log
@oops, exit vs return; spotted by matthew
@
text
@a149 3
#ifndef MONOLITH
static char *default_config_file=NULL;
#endif
a188 4
#ifndef MONOLITH
	char *to_free;
	long errline;
#endif
a451 12
#ifndef MONOLITH /* else this has happened in openssl.c (global `config') */
	/* Lets load up our environment a little */
	p=getenv("OPENSSL_CONF");
	if (p == NULL)
		p=getenv("SSLEAY_CONF");
	if (p == NULL)
		p=to_free=make_config_name();
	default_config_file=p;
	config=NCONF_new(NULL);
	i=NCONF_load(config, p, &errline);
#endif

a1049 4
#ifndef MONOLITH
	if(to_free)
		free(to_free);
#endif
@


1.25
log
@since we're replacing LIST_SEPARATOR_CHAR with ':', no point using %c
in the help printf
@
text
@d1100 1
a1100 1
	exit(ex);
@


1.24
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d425 1
a425 1
		BIO_printf(bio_err," -rand file%cfile%c...\n", ':', ':');
@


1.23
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d425 1
a425 1
		BIO_printf(bio_err," -rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
d1100 1
a1100 1
	OPENSSL_EXIT(ex);
@


1.22
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d1071 1
a1071 1
		OPENSSL_free(to_free);
d1092 1
a1092 1
		OPENSSL_free(keyalgstr);
d1096 2
a1097 2
	if(passargin && passin) OPENSSL_free(passin);
	if(passargout && passout) OPENSSL_free(passout);
@


1.21
log
@remove BIO_snprintf usage - convert to snprintf.
Interestingly this fixes a bug, as the code appears to have been
assuming that BIO_snprintf returns what snprintf does when it does not.
ok tedu@@
@
text
@a719 6
#ifdef OPENSSL_SYS_VMS
			{
			BIO *tmpbio = BIO_new(BIO_f_linebuffer());
			out = BIO_push(tmpbio, out);
			}
#endif
a965 6
#ifdef OPENSSL_SYS_VMS
		{
		BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		out = BIO_push(tmpbio, out);
		}
#endif
@


1.20
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@d1233 1
d1262 2
a1263 2
			if (BIO_snprintf(buf,sizeof buf,"%s_default",v->name)
				>= (int)sizeof(buf))
d1317 1
d1327 2
a1328 3

				if (BIO_snprintf(buf,sizeof buf,"%s_default",type)
					>= (int)sizeof(buf))
d1350 1
a1350 1
				BIO_snprintf(buf,sizeof buf,"%s_min",type);
d1357 1
a1357 1
				BIO_snprintf(buf,sizeof buf,"%s_max",type);
@


1.19
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@a1399 1
#ifndef CHARSET_EBCDIC
a1400 3
#else
			if ((*p == os_toascii[':']) || (*p == os_toascii[',']) || (*p == os_toascii['.'])) {
#endif
a1404 1
#ifndef CHARSET_EBCDIC
a1405 3
#else
		if (*p == os_toascii['+'])
#endif
a1480 3
#ifdef CHARSET_EBCDIC
	ebcdic2ascii(buf, buf, i);
#endif
a1536 3
#ifdef CHARSET_EBCDIC
	ebcdic2ascii(buf, buf, i);
#endif
@


1.18
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@d1274 1
a1274 1
			BIO_snprintf(buf,sizeof buf,"%s_value",v->name);
d1281 1
a1281 1
			BIO_snprintf(buf,sizeof buf,"%s_min",v->name);
d1288 1
a1288 1
			BIO_snprintf(buf,sizeof buf,"%s_max",v->name);
d1341 1
a1341 1
				BIO_snprintf(buf,sizeof buf,"%s_value",type);
@


1.17
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d1447 1
a1447 1
	MS_STATIC char buf[1024];
@


1.16
log
@resolve conflicts
@
text
@d647 5
a659 6
		if (newkey <= 0)
			{
			if (!NCONF_get_number(req_conf,SECTION,BITS, &newkey))
				newkey=DEFAULT_KEY_LENGTH;
			}

d1651 2
@


1.15
log
@resolve conflicts, fix local changes
@
text
@d168 1
a168 1
	STACK_OF(OPENSSL_STRING) *pkeyopts = NULL;
d313 9
d870 3
a872 2
			
			if (!(i=X509_sign(x509ss,pkey,digest)))
d896 2
a897 1
			if (!(i=X509_REQ_sign(req,pkey,digest)))
d1098 2
d1772 65
@


1.14
log
@resolve conflicts
@
text
@d144 1
a144 3
#ifndef OPENSSL_NO_RSA
static int MS_CALLBACK req_cb(int p, int n, BN_GENCB *cb);
#endif
d147 3
a155 5
#define TYPE_RSA	1
#define TYPE_DSA	2
#define TYPE_DH		3
#define TYPE_EC		4

d160 1
a160 7
	ENGINE *e = NULL;
#ifndef OPENSSL_NO_DSA
	DSA *dsa_params=NULL;
#endif
#ifndef OPENSSL_NO_ECDSA
	EC_KEY *ec_params = NULL;
#endif
d165 4
d170 1
a170 1
	int i=0,badops=0,newreq=0,verbose=0,pkey_type=TYPE_RSA;
d190 1
a190 1
	const EVP_MD *md_alg=NULL,*digest=EVP_sha1();
d233 10
d299 1
a299 115
			int is_numeric;

			if (--argc < 1) goto bad;
			p= *(++argv);
			is_numeric = p[0] >= '0' && p[0] <= '9';
			if (strncmp("rsa:",p,4) == 0 || is_numeric)
				{
				pkey_type=TYPE_RSA;
				if(!is_numeric)
				    p+=4;
				newkey= atoi(p);
				}
			else
#ifndef OPENSSL_NO_DSA
				if (strncmp("dsa:",p,4) == 0)
				{
				X509 *xtmp=NULL;
				EVP_PKEY *dtmp;

				pkey_type=TYPE_DSA;
				p+=4;
				if ((in=BIO_new_file(p,"r")) == NULL)
					{
					perror(p);
					goto end;
					}
				if ((dsa_params=PEM_read_bio_DSAparams(in,NULL,NULL,NULL)) == NULL)
					{
					ERR_clear_error();
					(void)BIO_reset(in);
					if ((xtmp=PEM_read_bio_X509(in,NULL,NULL,NULL)) == NULL)
						{
						BIO_printf(bio_err,"unable to load DSA parameters from file\n");
						goto end;
						}

					if ((dtmp=X509_get_pubkey(xtmp)) == NULL) goto end;
					if (dtmp->type == EVP_PKEY_DSA)
						dsa_params=DSAparams_dup(dtmp->pkey.dsa);
					EVP_PKEY_free(dtmp);
					X509_free(xtmp);
					if (dsa_params == NULL)
						{
						BIO_printf(bio_err,"Certificate does not contain DSA parameters\n");
						goto end;
						}
					}
				BIO_free(in);
				in=NULL;
				newkey=BN_num_bits(dsa_params->p);
				}
			else 
#endif
#ifndef OPENSSL_NO_ECDSA
				if (strncmp("ec:",p,3) == 0)
				{
				X509 *xtmp=NULL;
				EVP_PKEY *dtmp;
				EC_GROUP *group;

				pkey_type=TYPE_EC;
				p+=3;
				if ((in=BIO_new_file(p,"r")) == NULL)
					{
					perror(p);
					goto end;
					}
				if ((ec_params = EC_KEY_new()) == NULL)
					goto end;
				group = PEM_read_bio_ECPKParameters(in, NULL, NULL, NULL);
				if (group == NULL)
					{
					EC_KEY_free(ec_params);
					ERR_clear_error();
					(void)BIO_reset(in);
					if ((xtmp=PEM_read_bio_X509(in,NULL,NULL,NULL)) == NULL)
						{	
						BIO_printf(bio_err,"unable to load EC parameters from file\n");
						goto end;
						}

					if ((dtmp=X509_get_pubkey(xtmp))==NULL)
						goto end;
					if (dtmp->type == EVP_PKEY_EC)
						ec_params = EC_KEY_dup(dtmp->pkey.ec);
					EVP_PKEY_free(dtmp);
					X509_free(xtmp);
					if (ec_params == NULL)
						{
						BIO_printf(bio_err,"Certificate does not contain EC parameters\n");
						goto end;
						}
					}
				else
					{
					if (EC_KEY_set_group(ec_params, group) == 0)
						goto end;
					EC_GROUP_free(group);
					}

				BIO_free(in);
				in=NULL;
				newkey = EC_GROUP_get_degree(EC_KEY_get0_group(ec_params));
				}
			else
#endif
#ifndef OPENSSL_NO_DH
				if (strncmp("dh:",p,4) == 0)
				{
				pkey_type=TYPE_DH;
				p+=3;
				}
			else
#endif
				{
d301 1
a301 2
				}

d304 9
a367 5
		else if ((md_alg=EVP_get_digestbyname(&((*argv)[1]))) != NULL)
			{
			/* ok */
			digest=md_alg;
			}
d378 5
a630 3
#ifndef OPENSSL_NO_RSA
		BN_GENCB cb;
#endif
d637 8
d652 1
a652 1
		if (newkey < MIN_KEY_LENGTH && (pkey_type == TYPE_RSA || pkey_type == TYPE_DSA))
a657 3
		BIO_printf(bio_err,"Generating a %ld bit %s private key\n",
			newkey,(pkey_type == TYPE_RSA)?"RSA":
			(pkey_type == TYPE_DSA)?"DSA":"EC");
d659 7
a665 1
		if ((pkey=EVP_PKEY_new()) == NULL) goto end;
d667 1
a667 3
#ifndef OPENSSL_NO_RSA
		BN_GENCB_set(&cb, req_cb, bio_err);
		if (pkey_type == TYPE_RSA)
d669 2
a670 5
			RSA *rsa = RSA_new();
			BIGNUM *bn = BN_new();
			if(!bn || !rsa || !BN_set_word(bn, 0x10001) ||
					!RSA_generate_key_ex(rsa, newkey, bn, &cb) ||
					!EVP_PKEY_assign_RSA(pkey, rsa))
d672 9
a680 3
				if(bn) BN_free(bn);
				if(rsa) RSA_free(rsa);
				goto end;
a681 1
			BN_free(bn);
d683 8
a690 4
		else
#endif
#ifndef OPENSSL_NO_DSA
			if (pkey_type == TYPE_DSA)
d692 2
a693 3
			if (!DSA_generate_key(dsa_params)) goto end;
			if (!EVP_PKEY_assign_DSA(pkey,dsa_params)) goto end;
			dsa_params=NULL;
d695 3
a697 10
#endif
#ifndef OPENSSL_NO_ECDSA
			if (pkey_type == TYPE_EC)
			{
			if (!EC_KEY_generate_key(ec_params)) goto end;
			if (!EVP_PKEY_assign_EC_KEY(pkey, ec_params)) 
				goto end;
			ec_params = NULL;
			}
#endif
a700 2
		if (pkey == NULL) goto end;

d798 1
a798 8
#ifndef OPENSSL_NO_DSA
		if (pkey->type == EVP_PKEY_DSA)
			digest=EVP_dss1();
#endif
#ifndef OPENSSL_NO_ECDSA
		if (pkey->type == EVP_PKEY_EC)
			digest=EVP_ecdsa();
#endif
d841 1
a841 1
			if (!X509_gmtime_adj(X509_get_notAfter(x509ss), (long)60*60*24*days)) goto end;
d863 2
d866 1
d887 2
d890 1
d1027 1
a1027 1
		if (tpubkey->type == EVP_PKEY_RSA)
d1083 10
a1098 6
#ifndef OPENSSL_NO_DSA
	if (dsa_params != NULL) DSA_free(dsa_params);
#endif
#ifndef OPENSSL_NO_ECDSA
	if (ec_params != NULL) EC_KEY_free(ec_params);
#endif
d1339 2
d1342 1
d1346 2
d1349 1
d1450 2
a1451 1
			fgets(buf,sizeof buf,stdin);
d1509 2
a1510 1
			fgets(buf,sizeof buf,stdin);
a1552 18
#ifndef OPENSSL_NO_RSA
static int MS_CALLBACK req_cb(int p, int n, BN_GENCB *cb)
	{
	char c='*';

	if (p == 0) c='.';
	if (p == 1) c='+';
	if (p == 2) c='*';
	if (p == 3) c='\n';
	BIO_write(cb->arg,&c,1);
	(void)BIO_flush(cb->arg);
#ifdef LINT
	p=n;
#endif
	return 1;
	}
#endif

d1579 180
@


1.13
log
@resolve conflicts
@
text
@d59 6
d82 7
a88 1
#include "../crypto/cryptlib.h"
d128 4
a131 3
static int make_REQ(X509_REQ *req,EVP_PKEY *pkey,char *dn,int attribs,
		unsigned long chtype);
static int build_subject(X509_REQ *req, char *subj, unsigned long chtype);
d139 2
a140 2
static int add_attribute_object(X509_REQ *req, char *text,
				char *def, char *value, int nid, int n_min,
d142 2
a143 2
static int add_DN_object(X509_NAME *n, char *text, char *def, char *value,
	int nid,int n_min,int n_max, unsigned long chtype);
d145 1
a145 1
static void MS_CALLBACK req_cb(int p,int n,void *arg);
d148 1
a148 1
static int check_end(char *str, char *end);
d158 1
d168 3
d195 2
a196 1
	const EVP_MD *md_alg=NULL,*digest;
a217 7
#ifdef  OPENSSL_FIPS
	if (FIPS_mode())
		digest = EVP_sha1();
	else
#endif
		digest = EVP_md5();

d343 1
d345 51
d397 1
d399 1
a399 1
			else 
d409 3
a411 1
				pkey_type=TYPE_RSA;
d456 2
d523 3
d529 1
d722 1
a722 1
		if (EVP_PKEY_type(pkey->type) == EVP_PKEY_DSA)
d733 3
d749 1
a749 1
		if (newkey < MIN_KEY_LENGTH)
d752 1
a752 1
			BIO_printf(bio_err,"it needs to be at least %d bits, not %d\n",MIN_KEY_LENGTH,newkey);
d755 3
a757 2
		BIO_printf(bio_err,"Generating a %d bit %s private key\n",
			newkey,(pkey_type == TYPE_RSA)?"RSA":"DSA");
d762 1
d765 8
a772 3
			if (!EVP_PKEY_assign_RSA(pkey,
				RSA_generate_key(newkey,0x10001,
					req_cb,bio_err)))
d774 2
d787 9
d902 4
d914 1
a914 1
			i=make_REQ(req,pkey,subj,!x509, chtype);
d1009 1
a1009 1
		if (build_subject(req, subj, chtype) == 0)
d1193 3
d1200 2
a1201 2
static int make_REQ(X509_REQ *req, EVP_PKEY *pkey, char *subj, int attribs,
			unsigned long chtype)
d1251 1
a1251 1
			i = build_subject(req, subj, chtype);
d1268 1
a1268 1
static int build_subject(X509_REQ *req, char *subject, unsigned long chtype)
d1272 1
a1272 1
	if (!(n = do_subject(subject, chtype)))
d1293 1
a1293 1
	int nid;
d1295 2
a1296 1
	char *type,*def,*value;
d1337 7
d1347 1
a1347 1
				>= sizeof buf)
d1381 1
a1381 1
				n_min,n_max, chtype))
d1412 1
a1412 1
					>= sizeof buf)
d1471 1
d1488 11
d1500 1
a1500 1
				(unsigned char *) v->value,-1,-1,0)) return 0;
d1522 2
a1523 2
static int add_DN_object(X509_NAME *n, char *text, char *def, char *value,
	     int nid, int n_min, int n_max, unsigned long chtype)
d1572 1
a1572 1
				(unsigned char *) buf, -1,-1,0)) goto err;
d1578 2
a1579 2
static int add_attribute_object(X509_REQ *req, char *text,
				char *def, char *value, int nid, int n_min,
d1643 1
a1643 1
static void MS_CALLBACK req_cb(int p, int n, void *arg)
d1651 2
a1652 2
	BIO_write((BIO *)arg,&c,1);
	(void)BIO_flush((BIO *)arg);
d1656 1
d1676 1
a1676 1
static int check_end(char *str, char *end)
d1679 1
a1679 1
	char *tmp;
@


1.12
log
@merge 0.9.7d
@
text
@d178 1
a178 1
	const EVP_MD *md_alg=NULL,*digest=EVP_md5();
d200 7
d509 1
a509 3
		if( verbose )
			BIO_printf(bio_err,"Using configuration from %s\n",
			default_config_file);
d512 3
a514 1
			BIO_printf(bio_err,"Unable to load config info\n");
d516 3
d844 3
a846 1
				if (!ASN1_INTEGER_set(X509_get_serialNumber(x509ss),0L)) goto end;
@


1.11
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d827 1
a827 1
			if(!X509_set_version(x509ss, 2)) goto end;
d1226 1
a1226 1
			if (snprintf(buf,sizeof buf,"%s_default",v->name)
d1239 1
a1239 1
			snprintf(buf,sizeof buf,"%s_value",v->name);
d1246 1
a1246 1
			snprintf(buf,sizeof buf,"%s_min",v->name);
d1253 1
a1253 1
			snprintf(buf,sizeof buf,"%s_max",v->name);
d1291 1
a1291 1
				if (snprintf(buf,sizeof buf,"%s_default",type)
d1306 1
a1306 1
				snprintf(buf,sizeof buf,"%s_value",type);
d1314 1
a1314 1
				snprintf(buf,sizeof buf,"%s_min",type);
d1318 1
a1318 1
				snprintf(buf,sizeof buf,"%s_max",type);
d1400 2
a1401 2
		strlcpy(buf,value,sizeof buf);
		strlcat(buf,"\n",sizeof buf);
d1423 2
a1424 2
		strlcpy(buf,def,sizeof buf);
		strlcat(buf,"\n",sizeof buf);
d1458 2
a1459 2
		strlcpy(buf,value,sizeof buf);
		strlcat(buf,"\n",sizeof buf);
d1481 2
a1482 2
		strlcpy(buf,def,sizeof buf);
		strlcat(buf,"\n",sizeof buf);
@


1.10
log
@more strcpy & sprintf murder; ho ok
@
text
@d76 1
a137 1
static CONF *config=NULL;
d165 1
d167 1
d181 1
a181 1
	MS_STATIC char config_name[256];
d215 1
d221 1
d435 1
d437 1
d462 1
a462 1
		BIO_printf(bio_err," -nameopt arg   - various certificate name options\n");
d479 1
a479 8
		{
		strlcpy(config_name,X509_get_default_cert_area(),sizeof config_name);
#ifndef OPENSSL_SYS_VMS
		strlcat(config_name,"/",sizeof config_name);
#endif
		strlcat(config_name,OPENSSL_CONF,sizeof config_name);
		p=config_name;
		}
d487 1
a487 1
		long errline;
d626 1
d628 1
d1063 4
d1085 1
a1085 1
	EXIT(ex);
d1226 7
a1232 1
			snprintf(buf,sizeof buf,"%s_default",v->name);
d1248 2
d1251 1
d1255 2
d1258 1
d1291 7
a1297 1
				snprintf(buf,sizeof buf,"%s_default",type);
d1409 1
a1409 1
			fgets(buf,1024,stdin);
d1467 1
a1467 1
			fgets(buf,1024,stdin);
@


1.9
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d474 1
a474 1
		strcpy(config_name,X509_get_default_cert_area());
d476 1
a476 1
		strcat(config_name,"/");
d478 1
a478 1
		strcat(config_name,OPENSSL_CONF);
d1221 1
a1221 1
			sprintf(buf,"%s_default",v->name);
d1228 1
a1228 1
			sprintf(buf,"%s_value",v->name);
d1235 1
a1235 1
			sprintf(buf,"%s_min",v->name);
d1239 1
a1239 1
			sprintf(buf,"%s_max",v->name);
d1274 1
a1274 1
				sprintf(buf,"%s_default",type);
d1283 1
a1283 1
				sprintf(buf,"%s_value",type);
d1291 1
a1291 1
				sprintf(buf,"%s_min",type);
d1295 1
a1295 1
				sprintf(buf,"%s_max",type);
d1377 2
a1378 2
		strcpy(buf,value);
		strcat(buf,"\n");
d1400 2
a1401 2
		strcpy(buf,def);
		strcat(buf,"\n");
d1435 2
a1436 2
		strcpy(buf,value);
		strcat(buf,"\n");
d1458 2
a1459 2
		strcpy(buf,def);
		strcat(buf,"\n");
@


1.8
log
@Merge openssl-0.9.7-stable-SNAP-20020519
@
text
@d154 1
a154 1
	unsigned long nmflag = 0;
d359 5
d456 2
a457 1
		BIO_printf(bio_err," -nameopt arg    - various certificate name options\n");
d631 1
a631 1
		pkey = load_key(bio_err, keyfile, keyform, passin, e,
d990 1
a990 1
			X509_print(out,x509ss);
d992 1
a992 1
			X509_REQ_print(out,req);
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d1147 1
a1147 5
	size_t buflen = strlen (subject)+1; /* to copy the types and values into. due to escaping, the copy can only become shorter */
	char *buf = malloc (buflen);
	size_t max_ne = buflen / 2 + 1; /* maximum number of name elements */
	char **ne_types = malloc (max_ne * sizeof (char *));
	char **ne_values = malloc (max_ne * sizeof (char *));
d1149 2
a1150 2
	char *sp = subject, *bp = buf;
	int i, ne_num = 0;
d1152 1
a1152 46
	X509_NAME *n = NULL;
	int nid;

	if (!buf || !ne_types || !ne_values)
	{
		BIO_printf(bio_err, "malloc error\n");
		goto error0;
	}

	if (*subject != '/')
	{
		BIO_printf(bio_err, "Subject does not start with '/'.\n");
		goto error0;
	}
	sp++; /* skip leading / */

	while (*sp)
	{
		/* collect type */
		ne_types[ne_num] = bp;
		while (*sp)
		{
			if (*sp == '\\') /* is there anything to escape in the type...? */
				if (*++sp)
					*bp++ = *sp++;
				else
				{
					BIO_printf(bio_err, "escape character at end of string\n");
					goto error0;
				}
			else if (*sp == '=')
			{
				sp++;
				*bp++ = '\0';
				break;
			}
			else
				*bp++ = *sp++;
		}
		if (!*sp)
		{
			BIO_printf(bio_err, "end of string encountered while processing type of subject name element #%d\n", ne_num);
			goto error0;
		}
		ne_values[ne_num] = bp;
		while (*sp)
d1154 2
a1155 16
			if (*sp == '\\')
				if (*++sp)
					*bp++ = *sp++;
				else
				{
					BIO_printf(bio_err, "escape character at end of string\n");
					goto error0;
				}
			else if (*sp == '/')
			{
				sp++;
				*bp++ = '\0';
				break;
			}
			else
				*bp++ = *sp++;
a1156 28
		*bp++ = '\0';
		ne_num++;
	}

	if (!(n = X509_NAME_new()))
		goto error0;

	for(i = 0; i < ne_num; i++)
		{
		if ((nid=OBJ_txt2nid(ne_types[i])) == NID_undef)
			{
			BIO_printf(bio_err, "Subject Attribute %s has no known NID, skipped\n", ne_types[i]);
			continue;
			}

		if (!*ne_values[i])
			{
			BIO_printf(bio_err, "No value provided for Subject Attribute %s, skipped\n", ne_types[i]);
			continue;
			}

		if (!X509_NAME_add_entry_by_NID(n, nid, chtype, (unsigned char*)ne_values[i], -1,-1,0))
			goto error1;

		}

	if (!X509_REQ_set_subject_name(req, n))
		goto error1;
a1157 3
	free (ne_values);
	free (ne_types);
	free (buf);
a1158 8

error1:
	X509_NAME_free(n);
error0:
	free (ne_values);
	free (ne_types);
	free (buf);
	return 0;
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d63 1
a63 1
#ifdef NO_STDIO
a75 1
#include <openssl/engine.h>
d87 1
d105 1
a105 1
 * -keyform	- key file format.
d109 1
d115 3
a117 1
static int make_REQ(X509_REQ *req,EVP_PKEY *pkey,int attribs);
d120 2
a121 1
		STACK_OF(CONF_VALUE) *attr_sk, char *attr_sect, int attribs);
d123 2
a124 1
				STACK_OF(CONF_VALUE) *attr, int attribs);
d126 2
a127 2
				char *def, char *value, int nid, int min,
				int max);
d129 2
a130 2
	int nid,int min,int max);
#ifndef NO_RSA
d133 1
a133 1
static int req_check_len(int len,int min,int max);
d137 1
a137 1
static LHASH *config=NULL;
d139 2
a140 1
static LHASH *req_conf=NULL;
d151 1
a151 1
#ifndef NO_DSA
d154 1
d159 2
a160 1
	int i,badops=0,newreq=0,newkey= -1,pkey_type=0;
d163 1
a163 1
	int nodes=0,kludge=0,newhdr=0;
d168 2
a169 1
	EVP_CIPHER *cipher=NULL;
d175 1
d177 1
d180 1
d184 1
a184 1
#ifndef NO_DES
d223 4
a228 1
			pkey_type=TYPE_RSA;
d286 1
a286 1
#ifndef NO_DSA
d309 1
a309 1
					dtmp=X509_get_pubkey(xtmp);
d326 1
a326 1
#ifndef NO_DH
d338 2
d350 11
d369 5
d380 6
d421 1
d426 4
a429 2
		BIO_printf(bio_err," -engine e      use engine e, possibly a hardware device.\n");
		BIO_printf(bio_err," -key file	use the private key contained in file\n");
d437 1
a437 2

		BIO_printf(bio_err," -[digest]      Digest to sign with (md5, sha1, md2, mdc2)\n");
d439 1
d441 1
d443 2
a444 1
		BIO_printf(bio_err," -days          number of days a x509 generated by -x509 is valid for.\n");
d450 2
d469 1
a469 1
#ifndef VMS
d476 2
a477 1
	config=CONF_load(config,p,NULL);
d484 5
a488 3
		BIO_printf(bio_err,"Using configuration from %s\n",template);
		req_conf=CONF_load(NULL,template,&errline);
		if (req_conf == NULL)
d497 2
a498 1
		BIO_printf(bio_err,"Using configuration from %s\n",
d508 5
a512 1
		p=CONF_get_string(req_conf,NULL,"oid_file");
d532 1
a532 1
		if(!add_oid_section(bio_err, req_conf)) goto end;
d534 1
a534 2
	if ((md_alg == NULL) &&
		((p=CONF_get_string(req_conf,SECTION,"default_md")) != NULL))
d536 8
a543 2
		if ((md_alg=EVP_get_digestbyname(p)) != NULL)
			digest=md_alg;
d546 7
a552 3
	if(!extensions)
		extensions = CONF_get_string(req_conf, SECTION, V3_EXTENSIONS);
	if(extensions) {
d556 2
a557 2
		X509V3_set_conf_lhash(&ctx, req_conf);
		if(!X509V3_EXT_add_conf(req_conf, &ctx, extensions, NULL)) {
d565 6
a570 2
		passin = CONF_get_string(req_conf, SECTION, "input_password");

d572 5
a576 1
		passout = CONF_get_string(req_conf, SECTION, "output_password");
d578 3
a580 1
	p = CONF_get_string(req_conf, SECTION, STRING_MASK);
d587 10
d598 5
a602 1
		req_exts = CONF_get_string(req_conf, SECTION, REQ_EXTENSIONS);
d607 2
a608 2
		X509V3_set_conf_lhash(&ctx, req_conf);
		if(!X509V3_EXT_add_conf(req_conf, &ctx, req_exts, NULL)) {
d621 1
a621 17
	if (engine != NULL)
		{
		if((e = ENGINE_by_id(engine)) == NULL)
			{
			BIO_printf(bio_err,"invalid engine \"%s\"\n",
				engine);
			goto end;
			}
		if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
			{
			BIO_printf(bio_err,"can't use that engine\n");
			goto end;
			}
		BIO_printf(bio_err,"engine \"%s\" set.\n", engine);
		/* Free our "structural" reference. */
		ENGINE_free(e);
		}
d625 3
a627 10
		if (keyform == FORMAT_ENGINE)
			{
			if (!e)
				{
				BIO_printf(bio_err,"no engine specified\n");
				goto end;
				}
			pkey = ENGINE_load_private_key(e, keyfile, NULL);
			}
		else
d629 2
a630 23
			if (BIO_read_filename(in,keyfile) <= 0)
				{
				perror(keyfile);
				goto end;
				}

			if (keyform == FORMAT_ASN1)
				pkey=d2i_PrivateKey_bio(in,NULL);
			else if (keyform == FORMAT_PEM)
				{
				pkey=PEM_read_bio_PrivateKey(in,NULL,NULL,
					passin);
				}
			else
				{
				BIO_printf(bio_err,"bad input format specified for X509 request\n");
				goto end;
				}
			}

		if (pkey == NULL)
			{
			BIO_printf(bio_err,"unable to load Private key\n");
d633 1
a633 1
                if (EVP_PKEY_type(pkey->type) == EVP_PKEY_DSA)
d635 3
a637 1
			char *randfile = CONF_get_string(req_conf,SECTION,"RANDFILE");
d639 1
a639 1
                	}
d644 3
a646 1
		char *randfile = CONF_get_string(req_conf,SECTION,"RANDFILE");
d653 1
a653 2
			newkey=(int)CONF_get_number(req_conf,SECTION,BITS);
			if (newkey <= 0)
d668 1
a668 1
#ifndef NO_RSA
d678 1
a678 1
#ifndef NO_DSA
d692 6
a697 2
			keyout=CONF_get_string(req_conf,SECTION,KEYFILE);

d702 1
a702 1
#ifdef VMS
d719 1
a719 1
		p=CONF_get_string(req_conf,SECTION,"encrypt_rsa_key");
d721 6
a726 1
			p=CONF_get_string(req_conf,SECTION,"encrypt_key");
d788 1
a788 1
#ifndef NO_DSA
d800 7
a806 3
			i=make_REQ(req,pkey,!x509);
			if (kludge >= 0)
				req->req_info->req_kludge=kludge;
d821 8
a828 1
			ASN1_INTEGER_set(X509_get_serialNumber(x509ss),0L);
d830 4
a833 7
			X509_set_issuer_name(x509ss,
				X509_REQ_get_subject_name(req));
			X509_gmtime_adj(X509_get_notBefore(x509ss),0);
			X509_gmtime_adj(X509_get_notAfter(x509ss),
				(long)60*60*24*days);
			X509_set_subject_name(x509ss,
				X509_REQ_get_subject_name(req));
d835 1
a835 1
			X509_set_pubkey(x509ss,tmppkey);
d841 1
a841 1
			X509V3_set_conf_lhash(&ext_ctx, req_conf);
d844 1
a844 1
			if(extensions && !X509V3_EXT_add_conf(req_conf, 
d846 7
a852 7
			    {
			    BIO_printf(bio_err,
				       "Error Loading extension section %s\n",
				       extensions);
			    goto end;
			    }

d863 1
a863 1
			X509V3_set_conf_lhash(&ext_ctx, req_conf);
d866 1
a866 1
			if(req_exts && !X509V3_EXT_REQ_add_conf(req_conf, 
d868 6
a873 6
			    {
			    BIO_printf(bio_err,
				       "Error Loading extension section %s\n",
				       req_exts);
			    goto end;
			    }
d879 29
d932 1
d938 1
a938 1
	if (noout && !text && !modulus)
d947 1
a947 1
#ifdef VMS
d967 14
d989 8
d999 1
a999 1
		EVP_PKEY *pubkey;
d1002 1
a1002 1
			pubkey=X509_get_pubkey(x509ss);
d1004 2
a1005 2
			pubkey=X509_REQ_get_pubkey(req);
		if (pubkey == NULL)
d1011 3
a1013 3
#ifndef NO_RSA
		if (pubkey->type == EVP_PKEY_RSA)
			BN_print(out,pubkey->pkey.rsa->n);
d1017 1
d1060 1
a1060 1
	if ((req_conf != NULL) && (req_conf != config)) CONF_free(req_conf);
d1066 1
d1070 1
a1070 1
#ifndef NO_DSA
d1073 1
d1077 2
a1078 1
static int make_REQ(X509_REQ *req, EVP_PKEY *pkey, int attribs)
d1085 3
a1087 1
	tmp=CONF_get_string(req_conf,SECTION,PROMPT);
d1090 1
a1090 1
	dn_sect=CONF_get_string(req_conf,SECTION,DISTINGUISHED_NAME);
d1097 1
a1097 1
	dn_sk=CONF_get_section(req_conf,dn_sect);
d1104 1
a1104 1
	attr_sect=CONF_get_string(req_conf,SECTION,ATTRIBUTES);
d1106 2
d1109 1
d1112 1
a1112 1
		attr_sk=CONF_get_section(req_conf,attr_sect);
d1123 9
a1131 2
	if(no_prompt) i = auto_info(req, dn_sk, attr_sk, attribs);
	else i = prompt_info(req, dn_sk, dn_sect, attr_sk, attr_sect, attribs);
d1134 1
a1134 1
	X509_REQ_set_pubkey(req,pkey);
d1141 122
d1266 2
a1267 1
		STACK_OF(CONF_VALUE) *attr_sk, char *attr_sect, int attribs)
d1272 2
a1273 1
	int nid,min,max;
d1278 11
a1288 7
	BIO_printf(bio_err,"You are about to be asked to enter information that will be incorporated\n");
	BIO_printf(bio_err,"into your certificate request.\n");
	BIO_printf(bio_err,"What you are about to enter is what is called a Distinguished Name or a DN.\n");
	BIO_printf(bio_err,"There are quite a few fields but you can leave some blank\n");
	BIO_printf(bio_err,"For some fields there will be a default value,\n");
	BIO_printf(bio_err,"If you enter '.', the field will be left blank.\n");
	BIO_printf(bio_err,"-----\n");
d1318 3
a1320 1
			if ((def=CONF_get_string(req_conf,dn_sect,buf)) == NULL)
d1322 1
d1325 3
a1327 1
			if ((value=CONF_get_string(req_conf,dn_sect,buf)) == NULL)
d1329 1
d1332 2
a1333 1
			min=(int)CONF_get_number(req_conf,dn_sect,buf);
d1336 2
a1337 1
			max=(int)CONF_get_number(req_conf,dn_sect,buf);
d1340 1
a1340 1
				min,max))
d1351 1
a1351 1
			if ((attr_sk != NULL) && (sk_CONF_VALUE_num(attr_sk) > 0))
d1371 1
a1371 1
				if ((def=CONF_get_string(req_conf,attr_sect,buf))
d1373 2
d1376 2
d1380 1
a1380 1
				if ((value=CONF_get_string(req_conf,attr_sect,buf))
d1382 2
d1385 1
d1388 2
a1389 1
				min=(int)CONF_get_number(req_conf,attr_sect,buf);
d1392 2
a1393 1
				max=(int)CONF_get_number(req_conf,attr_sect,buf);
d1396 1
a1396 1
					v->value,def,value,nid,min,max))
d1412 1
a1412 1
			STACK_OF(CONF_VALUE) *attr_sk, int attribs)
d1440 1
a1440 1
		if (!X509_NAME_add_entry_by_txt(subj,type, MBSTRING_ASC,
d1455 1
a1455 1
				if(!X509_REQ_add1_attr_by_txt(req, v->name, MBSTRING_ASC,
d1464 1
a1464 1
	     int nid, int min, int max)
d1469 1
a1469 1
	BIO_printf(bio_err,"%s [%s]:",text,def);
d1471 1
a1471 1
	if (value != NULL)
d1480 9
a1488 1
		fgets(buf,1024,stdin);
a1507 1

d1511 2
a1512 2
	if(!req_check_len(i, min, max)) goto start;
	if (!X509_NAME_add_entry_by_NID(n,nid, MBSTRING_ASC,
d1520 2
a1521 2
				char *def, char *value, int nid, int min,
				int max)
d1527 1
a1527 1
	BIO_printf(bio_err,"%s [%s]:",text,def);
d1538 9
a1546 1
		fgets(buf,1024,stdin);
d1569 1
a1569 1
	if(!req_check_len(i, min, max)) goto start;
d1571 1
a1571 1
	if(!X509_REQ_add1_attr_by_NID(req, nid, MBSTRING_ASC,
d1583 1
a1583 1
#ifndef NO_RSA
d1600 1
a1600 1
static int req_check_len(int len, int min, int max)
d1602 1
a1602 1
	if (len < min)
d1604 1
a1604 1
		BIO_printf(bio_err,"string is too short, it needs to be at least %d bytes long\n",min);
d1607 1
a1607 1
	if ((max != 0) && (len > max))
d1609 1
a1609 1
		BIO_printf(bio_err,"string is too long, it needs to be less than  %d bytes long\n",max);
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@a727 5
#ifndef NO_DSA
		if (pkey->type == EVP_PKEY_DSA)
			digest=EVP_dss1();
#endif

d733 4
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d76 1
d106 1
a129 1
static int add_oid_section(LHASH *conf);
d144 1
d157 1
d162 1
d201 5
d251 5
d386 1
d390 3
d478 1
a478 1
		if(!add_oid_section(req_conf)) goto end;
d534 1
a534 1
	if (keyfile != NULL)
d536 1
a536 1
		if (BIO_read_filename(in,keyfile) <= 0)
d538 2
a539 1
			perror(keyfile);
d542 9
d552 3
a554 3
		if (keyform == FORMAT_ASN1)
			pkey=d2i_PrivateKey_bio(in,NULL);
		else if (keyform == FORMAT_PEM)
d556 6
a561 1
			pkey=PEM_read_bio_PrivateKey(in,NULL,NULL,passin);
d565 18
a582 2
			BIO_printf(bio_err,"bad input format specified for X509 request\n");
			goto end;
d590 5
d601 2
d652 6
d853 1
d855 7
d947 1
a947 1
	BIO_free(out);
d951 2
a952 2
	if(passargin && passin) Free(passin);
	if(passargout && passout) Free(passout);
d1156 1
d1158 3
d1276 3
a1334 22
}

static int add_oid_section(LHASH *conf)
{	
	char *p;
	STACK_OF(CONF_VALUE) *sktmp;
	CONF_VALUE *cnf;
	int i;
	if(!(p=CONF_get_string(conf,NULL,"oid_section"))) return 1;
	if(!(sktmp = CONF_get_section(conf, p))) {
		BIO_printf(bio_err, "problem loading oid section %s\n", p);
		return 0;
	}
	for(i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {
		cnf = sk_CONF_VALUE_value(sktmp, i);
		if(OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {
			BIO_printf(bio_err, "problem creating object %s=%s\n",
							 cnf->name, cnf->value);
			return 0;
		}
	}
	return 1;
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d881 2
a882 2
	if(passin) Free(passin);
	if(passout) Free(passout);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@a68 1
#include <openssl/rand.h>
d81 1
d85 2
d94 1
a94 1
/* -inform arg	- input format - default PEM (one of DER, TXT or PEM)
d113 6
a118 1
static int add_attribute_object(STACK_OF(X509_ATTRIBUTE) *n, char *text,
d123 1
d125 2
a126 1
static int req_fix_data(int nid,int *type,int len,int min,int max);
d139 2
d153 1
a153 1
	int nodes=0,kludge=0;
d156 1
d159 2
d167 1
d232 10
d309 2
d338 10
a348 1

d363 2
a364 2
		BIO_printf(bio_err," -inform arg    input format - one of DER TXT PEM\n");
		BIO_printf(bio_err," -outform arg   output format - one of DER TXT PEM\n");
d383 1
d386 2
a387 1
		BIO_printf(bio_err,"                [ It is now always turned on but can be turned off with -no-asn1-kludge ]\n");
d392 4
a395 1
	X509V3_add_standard_extensions();
d397 1
a397 1
#ifndef MONOLITH
d411 1
a411 1
        default_config_file=p;
d469 2
a470 1
	extensions = CONF_get_string(req_conf, SECTION, V3_EXTENSIONS);
d483 28
d524 6
a529 5
/*		if (keyform == FORMAT_ASN1)
			rsa=d2i_RSAPrivateKey_bio(in,NULL);
		else */
		if (keyform == FORMAT_PEM)
			pkey=PEM_read_bio_PrivateKey(in,NULL,NULL,NULL);
d545 3
a547 19
		char *randfile;
		char buffer[200];

		if ((randfile=CONF_get_string(req_conf,SECTION,"RANDFILE")) == NULL)
			randfile=RAND_file_name(buffer,200);
#ifdef WINDOWS
		BIO_printf(bio_err,"Loading 'screen' into random state -");
		BIO_flush(bio_err);
		RAND_screen();
		BIO_printf(bio_err," done\n");
#endif
		if ((randfile == NULL) || !RAND_load_file(randfile,1024L*1024L))
			{
			BIO_printf(bio_err,"unable to load 'random state'\n");
			BIO_printf(bio_err,"What this means is that the random number generator has not been seeded\n");
			BIO_printf(bio_err,"with much random data.\n");
			BIO_printf(bio_err,"Consider setting the RANDFILE environment variable to point at a file that\n");
			BIO_printf(bio_err,"'random' data can be kept in.\n");
			}
d585 1
a585 2
		if ((randfile == NULL) || (RAND_write_file(randfile) == 0))
			BIO_printf(bio_err,"unable to write 'random state'\n");
d617 1
a617 1
			NULL,0,NULL,NULL))
d734 16
d840 4
a843 3
		else if (outformat == FORMAT_PEM)
			i=PEM_write_bio_X509_REQ(out,req);
		else	{
d881 2
a882 1
	X509V3_EXT_cleanup();
d893 9
a901 10
	char *p,*q;
	X509_REQ_INFO *ri;
	char buf[100];
	int nid,min,max;
	char *type,*def,*tmp,*value,*tmp_attr;
	STACK_OF(CONF_VALUE) *sk, *attr=NULL;
	CONF_VALUE *v;
	
	tmp=CONF_get_string(req_conf,SECTION,DISTINGUISHED_NAME);
	if (tmp == NULL)
d907 2
a908 2
	sk=CONF_get_section(req_conf,tmp);
	if (sk == NULL)
d910 1
a910 1
		BIO_printf(bio_err,"unable to get '%s' section\n",tmp);
d914 3
a916 3
	tmp_attr=CONF_get_string(req_conf,SECTION,ATTRIBUTES);
	if (tmp_attr == NULL)
		attr=NULL;
d919 2
a920 2
		attr=CONF_get_section(req_conf,tmp_attr);
		if (attr == NULL)
d922 1
a922 1
			BIO_printf(bio_err,"unable to get '%s' section\n",tmp_attr);
d927 6
a932 1
	ri=req->req_info;
d934 20
a961 2
	/* setup version number */
	if (!ASN1_INTEGER_set(ri->version,0L)) goto err; /* version 1 */
d963 1
a963 1
	if (sk_CONF_VALUE_num(sk))
d969 1
a969 1
			if (sk_CONF_VALUE_num(sk) <= i) break;
d971 1
a971 1
			v=sk_CONF_VALUE_value(sk,i);
d990 1
a990 1
			if ((def=CONF_get_string(req_conf,tmp,buf)) == NULL)
d994 1
a994 1
			if ((value=CONF_get_string(req_conf,tmp,buf)) == NULL)
d998 1
a998 1
			min=(int)CONF_get_number(req_conf,tmp,buf);
d1001 1
a1001 1
			max=(int)CONF_get_number(req_conf,tmp,buf);
d1003 1
a1003 1
			if (!add_DN_object(ri->subject,v->value,def,value,nid,
d1005 1
a1005 1
				goto err;
d1007 1
a1007 1
		if (sk_X509_NAME_ENTRY_num(ri->subject->entries) == 0)
d1010 1
a1010 1
			goto err;
d1015 1
a1015 1
			if ((attr != NULL) && (sk_CONF_VALUE_num(attr) > 0))
d1025 2
a1026 2
				if ((attr == NULL) ||
					    (sk_CONF_VALUE_num(attr) <= i))
d1029 1
a1029 1
				v=sk_CONF_VALUE_value(attr,i);
d1035 1
a1035 1
				if ((def=CONF_get_string(req_conf,tmp_attr,buf))
d1040 1
a1040 1
				if ((value=CONF_get_string(req_conf,tmp_attr,buf))
d1045 1
a1045 1
				min=(int)CONF_get_number(req_conf,tmp_attr,buf);
d1048 1
a1048 1
				max=(int)CONF_get_number(req_conf,tmp_attr,buf);
d1050 1
a1050 1
				if (!add_attribute_object(ri->attributes,
d1052 1
a1052 1
					goto err;
d1059 1
a1059 1
		goto err;
d1062 33
a1094 1
	X509_REQ_set_pubkey(req,pkey);
d1096 15
a1110 3
	ret=1;
err:
	return(ret);
d1113 1
d1117 1
a1117 2
	int i,j,ret=0;
	X509_NAME_ENTRY *ne=NULL;
d1119 1
a1119 1

a1151 3
	j=ASN1_PRINTABLE_type((unsigned char *)buf,-1);
	if (req_fix_data(nid,&j,i,min,max) == 0)
		goto err;
d1155 3
a1157 6
	if ((ne=X509_NAME_ENTRY_create_by_NID(NULL,nid,j,(unsigned char *)buf,
		strlen(buf)))
		== NULL) goto err;
	if (!X509_NAME_add_entry(n,ne,X509_NAME_entry_count(n),0))
		goto err;

a1159 1
	if (ne != NULL) X509_NAME_ENTRY_free(ne);
d1163 1
a1163 1
static int add_attribute_object(STACK_OF(X509_ATTRIBUTE) *n, char *text,
d1167 1
a1167 2
	int i,z;
	X509_ATTRIBUTE *xa=NULL;
a1168 2
	ASN1_BIT_STRING *bs=NULL;
	ASN1_TYPE *at=NULL;
d1202 1
d1204 4
a1207 2
	/* add object plus value */
	if ((xa=X509_ATTRIBUTE_new()) == NULL)
d1209 1
a1209 3
	if ((xa->value.set=sk_ASN1_TYPE_new_null()) == NULL)
		goto err;
	xa->set=1;
a1210 28
	if (xa->object != NULL) ASN1_OBJECT_free(xa->object);
	xa->object=OBJ_nid2obj(nid);

	if ((bs=ASN1_BIT_STRING_new()) == NULL) goto err;

	bs->type=ASN1_PRINTABLE_type((unsigned char *)buf,-1);

	z=req_fix_data(nid,&bs->type,i,min,max);
	if (z == 0)
		{
		if (value == NULL)
			goto start;
		else	goto err;
		}

	if (!ASN1_STRING_set(bs,(unsigned char *)buf,i+1))
		{ BIO_printf(bio_err,"Malloc failure\n"); goto err; }

	if ((at=ASN1_TYPE_new()) == NULL)
		{ BIO_printf(bio_err,"Malloc failure\n"); goto err; }

	ASN1_TYPE_set(at,bs->type,(char *)bs);
	sk_ASN1_TYPE_push(xa->value.set,at);
	bs=NULL;
	at=NULL;
	/* only one item per attribute */

	if (!sk_X509_ATTRIBUTE_push(n,xa)) goto err;
a1212 3
	if (xa != NULL) X509_ATTRIBUTE_free(xa);
	if (at != NULL) ASN1_TYPE_free(at);
	if (bs != NULL) ASN1_BIT_STRING_free(bs);
d1216 1
d1231 1
d1233 1
a1233 1
static int req_fix_data(int nid, int *type, int len, int min, int max)
a1234 17
	if (nid == NID_pkcs9_emailAddress)
		*type=V_ASN1_IA5STRING;
	if ((nid == NID_commonName) && (*type == V_ASN1_IA5STRING))
		*type=V_ASN1_T61STRING;
	if ((nid == NID_pkcs9_challengePassword) &&
		(*type == V_ASN1_IA5STRING))
		*type=V_ASN1_T61STRING;

	if ((nid == NID_pkcs9_unstructuredName) &&
		(*type == V_ASN1_T61STRING))
		{
		BIO_printf(bio_err,"invalid characters in string, please re-enter the string\n");
		return(0);
		}
	if (nid == NID_pkcs9_unstructuredName)
		*type=V_ASN1_IA5STRING;

@


1.1
log
@Initial revision
@
text
@d67 10
a76 9
#include "bio.h"
#include "evp.h"
#include "rand.h"
#include "conf.h"
#include "err.h"
#include "asn1.h"
#include "x509.h"
#include "objects.h"
#include "pem.h"
d84 1
a109 1
#ifndef NOPROTO
d111 3
a113 2
static int add_attribute_object(STACK *n, char *text, char *def, 
	char *value, int nid,int min,int max);
d116 1
a116 1
static void MS_CALLBACK req_cb(int p,int n,char *arg);
d118 2
a119 8
#else
static int make_REQ();
static int add_attribute_object();
static int add_DN_object();
static void MS_CALLBACK req_cb();
static int req_fix_data();
#endif

d130 1
a130 3
int MAIN(argc, argv)
int argc;
char **argv;
d144 1
d148 1
a148 1
	EVP_MD *md_alg=NULL,*digest=EVP_md5();
d219 2
d223 2
a224 2
			if ((strncmp("rsa:",p,4) == 0) ||
				((p[0] >= '0') && (p[0] <= '9')))
d227 2
a228 1
				p+=4;
d245 1
a245 1
				if ((dsa_params=PEM_read_bio_DSAparams(in,NULL,NULL)) == NULL)
d248 2
a249 2
					BIO_reset(in);
					if ((xtmp=PEM_read_bio_X509(in,NULL,NULL)) == NULL)
a254 2
					/* This will 'disapear'
					 * when we free xtmp */
d258 1
d329 1
a329 1
		BIO_printf(bio_err," -in arg        inout file\n");
d343 1
a343 1
		BIO_printf(bio_err," -config file   request templace file.\n");
d354 1
d358 3
a360 1
	p=getenv("SSLEAY_CONF");
d364 4
a367 2
		strcat(config_name,"/lib/");
		strcat(config_name,SSLEAY_CONF);
d397 24
d428 13
d458 1
a458 1
			pkey=PEM_read_bio_PrivateKey(in,NULL,NULL);
d516 1
a516 1
					req_cb,(char *)bio_err)))
d563 1
a563 1
			NULL,0,NULL))
d597 1
a597 1
			req=PEM_read_bio_X509_REQ(in,NULL,NULL);
d641 2
d645 2
a646 4
			/* don't set the version number, for starters
			 * the field is null and second, null is v0 
			 * if (!ASN1_INTEGER_set(ci->version,0L)) goto end;
			 */
d656 18
a673 1
			X509_set_pubkey(x509ss,X509_REQ_get_pubkey(req));
d697 4
a700 1
		if (tmp) pkey=NULL;
d757 1
d761 1
d805 7
a811 5
	if (in != NULL) BIO_free(in);
	if (out != NULL) BIO_free(out);
	if (pkey != NULL) EVP_PKEY_free(pkey);
	if (req != NULL) X509_REQ_free(req);
	if (x509ss != NULL) X509_free(x509ss);
d818 1
a818 4
static int make_REQ(req,pkey,attribs)
X509_REQ *req;
EVP_PKEY *pkey;
int attribs;
d820 2
a821 2
	int ret=0,i,j;
	unsigned char *p,*q;
d826 1
a826 1
	STACK *sk,*attr=NULL;
d869 1
a869 1
	if (sk_num(sk))
d875 1
a875 1
			if ((int)sk_num(sk) <= i) break;
d877 1
a877 1
			v=(CONF_VALUE *)sk_value(sk,i);
d880 11
a890 17
			/* Allow for raw OIDs */
			/* [n.mm.ooo.ppp] */
			for (j=0; type[j] != '\0'; j++)
				{
				if (	(type[j] == ':') ||
					(type[j] == ',') ||
					(type[j] == '.'))
					p=(unsigned char *)&(type[j+1]);
				if (type[j] == '[')
					{
					p=(unsigned char *)&(type[j+1]);
					for (j++; type[j] != '\0'; j++)
						if (type[j] == ']')
							{
							q=(unsigned char *)&(type[j]);
							break;
							}
a891 1
					}
d893 2
a894 16
			if (p != NULL)
				type=(char *)p;
			if ((nid=OBJ_txt2nid(type)) == NID_undef)
				{
				/* Add a new one if possible */
				if ((p != NULL) && (q != NULL) && (*q == ']'))
					{
					*q='\0';
					nid=OBJ_create((char *)p,NULL,NULL);
					*q=']';
					if (nid == NID_undef) goto start;
					}
				else
					goto start;
				}

d913 1
a913 1
		if (sk_num(ri->subject->entries) == 0)
d921 1
a921 1
			if ((attr != NULL) && (sk_num(attr) > 0))
d931 2
a932 1
				if ((attr == NULL) || ((int)sk_num(attr) <= i))
d935 1
a935 1
				v=(CONF_VALUE *)sk_value(attr,i);
d975 2
a976 8
static int add_DN_object(n,text,def,value,nid,min,max)
X509_NAME *n;
char *text;
char *def;
char *value;
int nid;
int min;
int max;
d983 1
a983 1
	BIO_flush(bio_err);
d1017 3
d1032 3
a1034 8
static int add_attribute_object(n,text,def,value,nid,min,max)
STACK *n;
char *text;
char *def;
char *value;
int nid;
int min;
int max;
d1044 1
a1044 1
	BIO_flush(bio_err);
d1078 1
a1078 1
	if ((xa->value.set=sk_new_null()) == NULL)
d1104 1
a1104 1
	sk_push(xa->value.set,(char *)at);
d1109 1
a1109 1
	if (!sk_push(n,(char *)xa)) goto err;
d1118 1
a1118 4
static void MS_CALLBACK req_cb(p,n,arg)
int p;
int n;
char *arg;
d1127 1
a1127 1
	BIO_flush((BIO *)arg);
d1133 1
a1133 4
static int req_fix_data(nid,type,len,min,max)
int nid;
int *type;
int len,min,max;
d1164 34
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d63 1
a63 1
#ifdef OPENSSL_NO_STDIO
d67 9
a75 9
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/asn1.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/objects.h>
#include <openssl/pem.h>
a80 1
#define PROMPT		"prompt"
a82 4
#define V3_EXTENSIONS	"x509_extensions"
#define REQ_EXTENSIONS	"req_extensions"
#define STRING_MASK	"string_mask"
#define UTF8_IN		"utf8"
d90 1
a90 1
/* -inform arg	- input format - default PEM (DER or PEM)
d100 1
a100 2
 * -keyform arg	- key file format.
 * -rand file(s) - load the file(s) into the PRNG.
a102 1
 * -pubkey	- output Public Key.
d108 4
a111 13
static int make_REQ(X509_REQ *req,EVP_PKEY *pkey,char *dn,int attribs,
		unsigned long chtype);
static int build_subject(X509_REQ *req, char *subj, unsigned long chtype);
static int prompt_info(X509_REQ *req,
		STACK_OF(CONF_VALUE) *dn_sk, char *dn_sect,
		STACK_OF(CONF_VALUE) *attr_sk, char *attr_sect, int attribs,
		unsigned long chtype);
static int auto_info(X509_REQ *req, STACK_OF(CONF_VALUE) *sk,
				STACK_OF(CONF_VALUE) *attr, int attribs,
				unsigned long chtype);
static int add_attribute_object(X509_REQ *req, char *text,
				char *def, char *value, int nid, int n_min,
				int n_max, unsigned long chtype);
d113 9
a121 3
	int nid,int n_min,int n_max, unsigned long chtype);
#ifndef OPENSSL_NO_RSA
static void MS_CALLBACK req_cb(int p,int n,void *arg);
d123 1
a123 2
static int req_check_len(int len,int n_min,int n_max);
static int check_end(char *str, char *end);
d126 1
a126 1
static CONF *config=NULL;
d128 1
a128 2
static CONF *req_conf=NULL;
static int batch=0;
d134 3
a136 3
int MAIN(int, char **);

int MAIN(int argc, char **argv)
d138 1
a138 2
	ENGINE *e = NULL;
#ifndef OPENSSL_NO_DSA
a140 1
	unsigned long nmflag = 0;
d145 1
a145 2
	int i=0,badops=0,newreq=0,verbose=0,pkey_type=TYPE_RSA;
	long newkey = -1;
d148 1
a148 1
	int nodes=0,kludge=0,newhdr=0,subject=0,pubkey=0;
d150 1
a150 5
	char *engine=NULL;
	char *extensions = NULL;
	char *req_exts = NULL;
	const EVP_CIPHER *cipher=NULL;
	ASN1_INTEGER *serial = NULL;
a151 3
	char *inrand=NULL;
	char *passargin = NULL, *passargout = NULL;
	char *passin = NULL, *passout = NULL;
d153 1
a153 3
	char *subj = NULL;
	const EVP_MD *md_alg=NULL,*digest=EVP_md5();
	unsigned long chtype = MBSTRING_ASC;
a155 1
	long errline;
d158 1
a158 2
	req_conf = NULL;
#ifndef OPENSSL_NO_DES
a186 5
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
			engine= *(++argv);
			}
a191 4
		else if (strcmp(*argv,"-pubkey") == 0)
			{
			pubkey=1;
			}
d194 1
a221 15
		else if (strcmp(*argv,"-passin") == 0)
			{
			if (--argc < 1) goto bad;
			passargin= *(++argv);
			}
		else if (strcmp(*argv,"-passout") == 0)
			{
			if (--argc < 1) goto bad;
			passargout= *(++argv);
			}
		else if (strcmp(*argv,"-rand") == 0)
			{
			if (--argc < 1) goto bad;
			inrand= *(++argv);
			}
a223 2
			int is_numeric;

d226 2
a227 2
			is_numeric = p[0] >= '0' && p[0] <= '9';
			if (strncmp("rsa:",p,4) == 0 || is_numeric)
d230 1
a230 2
				if(!is_numeric)
				    p+=4;
d234 1
a234 1
#ifndef OPENSSL_NO_DSA
d247 1
a247 1
				if ((dsa_params=PEM_read_bio_DSAparams(in,NULL,NULL,NULL)) == NULL)
d250 2
a251 2
					(void)BIO_reset(in);
					if ((xtmp=PEM_read_bio_X509(in,NULL,NULL,NULL)) == NULL)
d257 3
a259 1
					if ((dtmp=X509_get_pubkey(xtmp)) == NULL) goto end;
a261 1
					EVP_PKEY_free(dtmp);
d275 1
a275 1
#ifndef OPENSSL_NO_DH
a286 4
		else if (strcmp(*argv,"-batch") == 0)
			batch=1;
		else if (strcmp(*argv,"-newhdr") == 0)
			newhdr=1;
a294 11
		else if (strcmp(*argv,"-verbose") == 0)
			verbose=1;
		else if (strcmp(*argv,"-utf8") == 0)
			chtype = MBSTRING_UTF8;
		else if (strcmp(*argv,"-nameopt") == 0)
			{
			if (--argc < 1) goto bad;
			if (!set_name_ex(&nmflag, *(++argv))) goto bad;
			}
		else if (strcmp(*argv,"-subject") == 0)
			subject=1;
a302 5
		else if (strcmp(*argv,"-subj") == 0)
			{
			if (--argc < 1) goto bad;
			subj= *(++argv);
			}
a308 6
		else if (strcmp(*argv,"-set_serial") == 0)
			{
			if (--argc < 1) goto bad;
			serial = s2i_ASN1_INTEGER(NULL, *(++argv));
			if (!serial) goto bad;
			}
a313 10
		else if (strcmp(*argv,"-extensions") == 0)
			{
			if (--argc < 1) goto bad;
			extensions = *(++argv);
			}
		else if (strcmp(*argv,"-reqexts") == 0)
			{
			if (--argc < 1) goto bad;
			req_exts = *(++argv);
			}
d315 1
d330 3
a332 3
		BIO_printf(bio_err," -inform arg    input format - DER or PEM\n");
		BIO_printf(bio_err," -outform arg   output format - DER or PEM\n");
		BIO_printf(bio_err," -in arg        input file\n");
a334 1
		BIO_printf(bio_err," -pubkey        output public key\n");
d339 1
a339 4
		BIO_printf(bio_err," -engine e      use engine e, possibly a hardware device\n");
		BIO_printf(bio_err," -subject       output the request's subject\n");
		BIO_printf(bio_err," -passin        private key password source\n");
		BIO_printf(bio_err," -key file      use the private key contained in file\n");
a341 3
		BIO_printf(bio_err," -rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
		BIO_printf(bio_err,"                load the file (or the files in the directory) into\n");
		BIO_printf(bio_err,"                the random number generator\n");
d344 3
a346 3
		BIO_printf(bio_err," -[digest]      Digest to sign with (md5, sha1, md2, mdc2, md4)\n");
		BIO_printf(bio_err," -config file   request template file.\n");
		BIO_printf(bio_err," -subj arg      set or modify request subject\n");
a347 1
		BIO_printf(bio_err," -batch         do not ask anything during request generation\n");
d349 1
a349 3
		BIO_printf(bio_err," -days          number of days a certificate generated by -x509 is valid for.\n");
		BIO_printf(bio_err," -set_serial    serial number to use for a certificate generated by -x509.\n");
		BIO_printf(bio_err," -newhdr        output \"NEW\" in the header lines\n");
d352 1
a352 4
		BIO_printf(bio_err," -extensions .. specify certificate extension section (override value in config file)\n");
		BIO_printf(bio_err," -reqexts ..    specify request extension section (override value in config file)\n");
		BIO_printf(bio_err," -utf8          input characters are UTF8 (default ASCII)\n");
		BIO_printf(bio_err," -nameopt arg    - various certificate name options\n");
a356 4
	if(!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {
		BIO_printf(bio_err, "Error getting passwords\n");
		goto end;
	}
d358 1
a358 1
#ifndef MONOLITH /* else this has happened in openssl.c (global `config') */
d360 1
a360 3
	p=getenv("OPENSSL_CONF");
	if (p == NULL)
		p=getenv("SSLEAY_CONF");
d364 2
a365 4
#ifndef OPENSSL_SYS_VMS
		strcat(config_name,"/");
#endif
		strcat(config_name,OPENSSL_CONF);
d368 2
a369 3
	default_config_file=p;
	config=NCONF_new(NULL);
	i=NCONF_load(config, p, &errline);
d376 3
a378 5
		if( verbose )
			BIO_printf(bio_err,"Using configuration from %s\n",template);
		req_conf=NCONF_new(NULL);
		i=NCONF_load(req_conf,template,&errline);
		if (i == 0)
d387 1
a387 2
		if( verbose )
			BIO_printf(bio_err,"Using configuration from %s\n",
d395 2
a396 1
	if (req_conf != NULL)
d398 2
a399 86
		if (!load_config(bio_err, req_conf))
			goto end;
		p=NCONF_get_string(req_conf,NULL,"oid_file");
		if (p == NULL)
			ERR_clear_error();
		if (p != NULL)
			{
			BIO *oid_bio;

			oid_bio=BIO_new_file(p,"r");
			if (oid_bio == NULL) 
				{
				/*
				BIO_printf(bio_err,"problems opening %s for extra oid's\n",p);
				ERR_print_errors(bio_err);
				*/
				}
			else
				{
				OBJ_create_objects(oid_bio);
				BIO_free(oid_bio);
				}
			}
		}
	if(!add_oid_section(bio_err, req_conf)) goto end;

	if (md_alg == NULL)
		{
		p=NCONF_get_string(req_conf,SECTION,"default_md");
		if (p == NULL)
			ERR_clear_error();
		if (p != NULL)
			{
			if ((md_alg=EVP_get_digestbyname(p)) != NULL)
				digest=md_alg;
			}
		}

	if (!extensions)
		{
		extensions = NCONF_get_string(req_conf, SECTION, V3_EXTENSIONS);
		if (!extensions)
			ERR_clear_error();
		}
	if (extensions) {
		/* Check syntax of file */
		X509V3_CTX ctx;
		X509V3_set_ctx_test(&ctx);
		X509V3_set_nconf(&ctx, req_conf);
		if(!X509V3_EXT_add_nconf(req_conf, &ctx, extensions, NULL)) {
			BIO_printf(bio_err,
			 "Error Loading extension section %s\n", extensions);
			goto end;
		}
	}

	if(!passin)
		{
		passin = NCONF_get_string(req_conf, SECTION, "input_password");
		if (!passin)
			ERR_clear_error();
		}
	
	if(!passout)
		{
		passout = NCONF_get_string(req_conf, SECTION, "output_password");
		if (!passout)
			ERR_clear_error();
		}

	p = NCONF_get_string(req_conf, SECTION, STRING_MASK);
	if (!p)
		ERR_clear_error();

	if(p && !ASN1_STRING_set_default_mask_asc(p)) {
		BIO_printf(bio_err, "Invalid global string mask setting %s\n", p);
		goto end;
	}

	if (chtype != MBSTRING_UTF8)
		{
		p = NCONF_get_string(req_conf, SECTION, UTF8_IN);
		if (!p)
			ERR_clear_error();
		else if (!strcmp(p, "yes"))
			chtype = MBSTRING_UTF8;
a401 20

	if(!req_exts)
		{
		req_exts = NCONF_get_string(req_conf, SECTION, REQ_EXTENSIONS);
		if (!req_exts)
			ERR_clear_error();
		}
	if(req_exts) {
		/* Check syntax of file */
		X509V3_CTX ctx;
		X509V3_set_ctx_test(&ctx);
		X509V3_set_nconf(&ctx, req_conf);
		if(!X509V3_EXT_add_nconf(req_conf, &ctx, req_exts, NULL)) {
			BIO_printf(bio_err,
			 "Error Loading request extension section %s\n",
								req_exts);
			goto end;
		}
	}

a406 2
        e = setup_engine(bio_err, engine, 0);

d409 1
a409 3
		pkey = load_key(bio_err, keyfile, keyform, passin, e,
			"Private Key");
		if (!pkey)
d411 1
a411 2
			/* load_key() has already printed an appropriate
			   message */
d414 13
a426 1
		if (EVP_PKEY_type(pkey->type) == EVP_PKEY_DSA)
d428 2
a429 4
			char *randfile = NCONF_get_string(req_conf,SECTION,"RANDFILE");
			if (randfile == NULL)
				ERR_clear_error();
			app_RAND_load_file(randfile, bio_err, 0);
d435 19
a453 7
		char *randfile = NCONF_get_string(req_conf,SECTION,"RANDFILE");
		if (randfile == NULL)
			ERR_clear_error();
		app_RAND_load_file(randfile, bio_err, 0);
		if (inrand)
			app_RAND_load_files(inrand);
	
d456 2
a457 1
			if (!NCONF_get_number(req_conf,SECTION,BITS, &newkey))
d472 1
a472 1
#ifndef OPENSSL_NO_RSA
d477 1
a477 1
					req_cb,bio_err)))
d482 1
a482 1
#ifndef OPENSSL_NO_DSA
d491 2
a492 1
		app_RAND_write_file(randfile, bio_err);
d497 2
a498 6
			{
			keyout=NCONF_get_string(req_conf,SECTION,KEYFILE);
			if (keyout == NULL)
				ERR_clear_error();
			}
		
a502 6
#ifdef OPENSSL_SYS_VMS
			{
			BIO *tmpbio = BIO_new(BIO_f_linebuffer());
			out = BIO_push(tmpbio, out);
			}
#endif
d514 1
a514 1
		p=NCONF_get_string(req_conf,SECTION,"encrypt_rsa_key");
d516 1
a516 6
			{
			ERR_clear_error();
			p=NCONF_get_string(req_conf,SECTION,"encrypt_key");
			if (p == NULL)
				ERR_clear_error();
			}
d524 1
a524 1
			NULL,0,NULL,passout))
d558 1
a558 1
			req=PEM_read_bio_X509_REQ(in,NULL,NULL,NULL);
d573 5
a582 4
#ifndef OPENSSL_NO_DSA
		if (pkey->type == EVP_PKEY_DSA)
			digest=EVP_dss1();
#endif
d591 3
a593 7
			i=make_REQ(req,pkey,subj,!x509, chtype);
			subj=NULL; /* done processing '-subj' option */
			if ((kludge > 0) && !sk_X509_ATTRIBUTE_num(req->req_info->attributes))
				{
				sk_X509_ATTRIBUTE_free(req->req_info->attributes);
				req->req_info->attributes = NULL;
				}
a601 2
			EVP_PKEY *tmppkey;
			X509V3_CTX ext_ctx;
d604 14
a617 10
			/* Set version to V3 */
			if(!X509_set_version(x509ss, 2)) goto end;
			if (serial)
				{
				if (!X509_set_serialNumber(x509ss, serial)) goto end;
				}
			else
				{
				if (!ASN1_INTEGER_set(X509_get_serialNumber(x509ss),0L)) goto end;
				}
a618 23
			if (!X509_set_issuer_name(x509ss, X509_REQ_get_subject_name(req))) goto end;
			if (!X509_gmtime_adj(X509_get_notBefore(x509ss),0)) goto end;
			if (!X509_gmtime_adj(X509_get_notAfter(x509ss), (long)60*60*24*days)) goto end;
			if (!X509_set_subject_name(x509ss, X509_REQ_get_subject_name(req))) goto end;
			tmppkey = X509_REQ_get_pubkey(req);
			if (!tmppkey || !X509_set_pubkey(x509ss,tmppkey)) goto end;
			EVP_PKEY_free(tmppkey);

			/* Set up V3 context struct */

			X509V3_set_ctx(&ext_ctx, x509ss, x509ss, NULL, NULL, 0);
			X509V3_set_nconf(&ext_ctx, req_conf);

			/* Add extensions */
			if(extensions && !X509V3_EXT_add_nconf(req_conf, 
				 	&ext_ctx, extensions, x509ss))
				{
				BIO_printf(bio_err,
					"Error Loading extension section %s\n",
					extensions);
				goto end;
				}
			
a623 16
			X509V3_CTX ext_ctx;

			/* Set up V3 context struct */

			X509V3_set_ctx(&ext_ctx, NULL, NULL, req, NULL, 0);
			X509V3_set_nconf(&ext_ctx, req_conf);

			/* Add extensions */
			if(req_exts && !X509V3_EXT_REQ_add_nconf(req_conf, 
				 	&ext_ctx, req_exts, req))
				{
				BIO_printf(bio_err,
					"Error Loading extension section %s\n",
					req_exts);
				goto end;
				}
a628 29
	if (subj && x509)
		{
		BIO_printf(bio_err, "Cannot modifiy certificate subject\n");
		goto end;
		}

	if (subj && !x509)
		{
		if (verbose)
			{
			BIO_printf(bio_err, "Modifying Request's Subject\n");
			print_name(bio_err, "old subject=", X509_REQ_get_subject_name(req), nmflag);
			}

		if (build_subject(req, subj, chtype) == 0)
			{
			BIO_printf(bio_err, "ERROR: cannot modify subject\n");
			ex=1;
			goto end;
			}

		req->req_info->enc.modified = 1;

		if (verbose)
			{
			print_name(bio_err, "new subject=", X509_REQ_get_subject_name(req), nmflag);
			}
		}

d641 1
a641 4
		if (tmp) {
			EVP_PKEY_free(pkey);
			pkey=NULL;
		}
a649 1
			ERR_print_errors(bio_err);
d655 1
a655 1
	if (noout && !text && !modulus && !subject && !pubkey)
a661 1
		{
a662 7
#ifdef OPENSSL_SYS_VMS
		{
		BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		out = BIO_push(tmpbio, out);
		}
#endif
		}
a675 14
	if (pubkey)
		{
		EVP_PKEY *tpubkey; 
		tpubkey=X509_REQ_get_pubkey(req);
		if (tpubkey == NULL)
			{
			BIO_printf(bio_err,"Error getting public key\n");
			ERR_print_errors(bio_err);
			goto end;
			}
		PEM_write_bio_PUBKEY(out, tpubkey);
		EVP_PKEY_free(tpubkey);
		}

a683 8
	if(subject) 
		{
		if(x509)
			print_name(out, "subject=", X509_get_subject_name(x509ss), nmflag);
		else
			print_name(out, "subject=", X509_REQ_get_subject_name(req), nmflag);
		}

d686 1
a686 1
		EVP_PKEY *tpubkey;
d689 1
a689 1
			tpubkey=X509_get_pubkey(x509ss);
d691 2
a692 2
			tpubkey=X509_REQ_get_pubkey(req);
		if (tpubkey == NULL)
d698 2
a699 3
#ifndef OPENSSL_NO_RSA
		if (tpubkey->type == EVP_PKEY_RSA)
			BN_print(out,tpubkey->pkey.rsa->n);
a700 1
#endif
a701 1
		EVP_PKEY_free(tpubkey);
d709 3
a711 4
		else if (outformat == FORMAT_PEM) {
			if(newhdr) i=PEM_write_bio_X509_REQ_NEW(out,req);
			else i=PEM_write_bio_X509_REQ(out,req);
		} else {
d743 7
a749 11
	if ((req_conf != NULL) && (req_conf != config)) NCONF_free(req_conf);
	BIO_free(in);
	BIO_free_all(out);
	EVP_PKEY_free(pkey);
	X509_REQ_free(req);
	X509_free(x509ss);
	ASN1_INTEGER_free(serial);
	if(passargin && passin) OPENSSL_free(passin);
	if(passargout && passout) OPENSSL_free(passout);
	OBJ_cleanup();
#ifndef OPENSSL_NO_DSA
a751 1
	apps_shutdown();
d755 4
a758 2
static int make_REQ(X509_REQ *req, EVP_PKEY *pkey, char *subj, int attribs,
			unsigned long chtype)
d760 10
a769 6
	int ret=0,i;
	char no_prompt = 0;
	STACK_OF(CONF_VALUE) *dn_sk, *attr_sk = NULL;
	char *tmp, *dn_sect,*attr_sect;

	tmp=NCONF_get_string(req_conf,SECTION,PROMPT);
a770 5
		ERR_clear_error();
	if((tmp != NULL) && !strcmp(tmp, "no")) no_prompt = 1;

	dn_sect=NCONF_get_string(req_conf,SECTION,DISTINGUISHED_NAME);
	if (dn_sect == NULL)
d776 2
a777 2
	dn_sk=NCONF_get_section(req_conf,dn_sect);
	if (dn_sk == NULL)
d779 1
a779 1
		BIO_printf(bio_err,"unable to get '%s' section\n",dn_sect);
d783 3
a785 6
	attr_sect=NCONF_get_string(req_conf,SECTION,ATTRIBUTES);
	if (attr_sect == NULL)
		{
		ERR_clear_error();		
		attr_sk=NULL;
		}
d788 2
a789 2
		attr_sk=NCONF_get_section(req_conf,attr_sect);
		if (attr_sk == NULL)
d791 1
a791 1
			BIO_printf(bio_err,"unable to get '%s' section\n",attr_sect);
d796 1
a796 2
	/* setup version number */
	if (!X509_REQ_set_version(req,0L)) goto err; /* version 1 */
d798 7
a804 10
	if (no_prompt) 
		i = auto_info(req, dn_sk, attr_sk, attribs, chtype);
	else 
		{
		if (subj)
			i = build_subject(req, subj, chtype);
		else
			i = prompt_info(req, dn_sk, dn_sect, attr_sk, attr_sect, attribs, chtype);
		}
	if(!i) goto err;
d806 2
a807 1
	if (!X509_REQ_set_pubkey(req,pkey)) goto err;
d809 1
a809 54
	ret=1;
err:
	return(ret);
	}

/*
 * subject is expected to be in the format /type0=value0/type1=value1/type2=...
 * where characters may be escaped by \
 */
static int build_subject(X509_REQ *req, char *subject, unsigned long chtype)
	{
	X509_NAME *n;

	if (!(n = do_subject(subject, chtype)))
		return 0;

	if (!X509_REQ_set_subject_name(req, n))
		{
		X509_NAME_free(n);
		return 0;
		}
	X509_NAME_free(n);
	return 1;
}


static int prompt_info(X509_REQ *req,
		STACK_OF(CONF_VALUE) *dn_sk, char *dn_sect,
		STACK_OF(CONF_VALUE) *attr_sk, char *attr_sect, int attribs,
		unsigned long chtype)
	{
	int i;
	char *p,*q;
	char buf[100];
	int nid;
	long n_min,n_max;
	char *type,*def,*value;
	CONF_VALUE *v;
	X509_NAME *subj;
	subj = X509_REQ_get_subject_name(req);

	if(!batch)
		{
		BIO_printf(bio_err,"You are about to be asked to enter information that will be incorporated\n");
		BIO_printf(bio_err,"into your certificate request.\n");
		BIO_printf(bio_err,"What you are about to enter is what is called a Distinguished Name or a DN.\n");
		BIO_printf(bio_err,"There are quite a few fields but you can leave some blank\n");
		BIO_printf(bio_err,"For some fields there will be a default value,\n");
		BIO_printf(bio_err,"If you enter '.', the field will be left blank.\n");
		BIO_printf(bio_err,"-----\n");
		}


	if (sk_CONF_VALUE_num(dn_sk))
d815 1
a815 1
			if (sk_CONF_VALUE_num(dn_sk) <= i) break;
d817 1
a817 1
			v=sk_CONF_VALUE_value(dn_sk,i);
d820 17
a836 11
			if(!check_end(type,"_min") || !check_end(type,"_max") ||
				!check_end(type,"_default") ||
					 !check_end(type,"_value")) continue;
			/* Skip past any leading X. X: X, etc to allow for
			 * multiple instances 
			 */
			for(p = v->name; *p ; p++) 
				if ((*p == ':') || (*p == ',') ||
							 (*p == '.')) {
					p++;
					if(*p) type = p;
d838 16
d855 1
a855 2
			/* If OBJ not recognised ignore it */
			if ((nid=OBJ_txt2nid(type)) == NID_undef) goto start;
d857 1
a857 3
			if ((def=NCONF_get_string(req_conf,dn_sect,buf)) == NULL)
				{
				ERR_clear_error();
a858 1
				}
d861 1
a861 3
			if ((value=NCONF_get_string(req_conf,dn_sect,buf)) == NULL)
				{
				ERR_clear_error();
a862 1
				}
d865 1
a865 2
			if (!NCONF_get_number(req_conf,dn_sect,buf, &n_min))
				n_min = -1;
d868 1
a868 2
			if (!NCONF_get_number(req_conf,dn_sect,buf, &n_max))
				n_max = -1;
d870 3
a872 3
			if (!add_DN_object(subj,v->value,def,value,nid,
				n_min,n_max, chtype))
				return 0;
d874 1
a874 1
		if (X509_NAME_entry_count(subj) == 0)
d877 1
a877 1
			return 0;
d882 1
a882 1
			if ((attr_sk != NULL) && (sk_CONF_VALUE_num(attr_sk) > 0) && (!batch))
d892 1
a892 2
				if ((attr_sk == NULL) ||
					    (sk_CONF_VALUE_num(attr_sk) <= i))
d895 1
a895 1
				v=sk_CONF_VALUE_value(attr_sk,i);
d901 1
a901 1
				if ((def=NCONF_get_string(req_conf,attr_sect,buf))
a902 2
					{
					ERR_clear_error();
a903 2
					}
				
d906 1
a906 1
				if ((value=NCONF_get_string(req_conf,attr_sect,buf))
a907 2
					{
					ERR_clear_error();
a908 1
					}
d911 1
a911 2
				if (!NCONF_get_number(req_conf,attr_sect,buf, &n_min))
					n_min = -1;
d914 1
a914 2
				if (!NCONF_get_number(req_conf,attr_sect,buf, &n_max))
					n_max = -1;
d916 3
a918 3
				if (!add_attribute_object(req,
					v->value,def,value,nid,n_min,n_max, chtype))
					return 0;
d925 1
a925 1
		return 0;
d928 1
a928 1
	return 1;
d930 3
d935 8
a942 2
static int auto_info(X509_REQ *req, STACK_OF(CONF_VALUE) *dn_sk,
			STACK_OF(CONF_VALUE) *attr_sk, int attribs, unsigned long chtype)
d944 3
a946 5
	int i;
	char *p,*q;
	char *type;
	CONF_VALUE *v;
	X509_NAME *subj;
d948 3
a950 52
	subj = X509_REQ_get_subject_name(req);

	for (i = 0; i < sk_CONF_VALUE_num(dn_sk); i++)
		{
		v=sk_CONF_VALUE_value(dn_sk,i);
		p=q=NULL;
		type=v->name;
		/* Skip past any leading X. X: X, etc to allow for
		 * multiple instances 
		 */
		for(p = v->name; *p ; p++) 
#ifndef CHARSET_EBCDIC
			if ((*p == ':') || (*p == ',') || (*p == '.')) {
#else
			if ((*p == os_toascii[':']) || (*p == os_toascii[',']) || (*p == os_toascii['.'])) {
#endif
				p++;
				if(*p) type = p;
				break;
			}
		if (!X509_NAME_add_entry_by_txt(subj,type, chtype,
				(unsigned char *) v->value,-1,-1,0)) return 0;

		}

		if (!X509_NAME_entry_count(subj))
			{
			BIO_printf(bio_err,"error, no objects specified in config file\n");
			return 0;
			}
		if (attribs)
			{
			for (i = 0; i < sk_CONF_VALUE_num(attr_sk); i++)
				{
				v=sk_CONF_VALUE_value(attr_sk,i);
				if(!X509_REQ_add1_attr_by_txt(req, v->name, chtype,
					(unsigned char *)v->value, -1)) return 0;
				}
			}
	return 1;
	}


static int add_DN_object(X509_NAME *n, char *text, char *def, char *value,
	     int nid, int n_min, int n_max, unsigned long chtype)
	{
	int i,ret=0;
	MS_STATIC char buf[1024];
start:
	if (!batch) BIO_printf(bio_err,"%s [%s]:",text,def);
	(void)BIO_flush(bio_err);
	if(value != NULL)
d959 1
a959 9
		if (!batch)
			{
			fgets(buf,1024,stdin);
			}
		else
			{
			buf[0] = '\n';
			buf[1] = '\0';
			}
d979 10
a988 6
#ifdef CHARSET_EBCDIC
	ebcdic2ascii(buf, buf, i);
#endif
	if(!req_check_len(i, n_min, n_max)) goto start;
	if (!X509_NAME_add_entry_by_NID(n,nid, chtype,
				(unsigned char *) buf, -1,-1,0)) goto err;
d991 1
d995 8
a1002 3
static int add_attribute_object(X509_REQ *req, char *text,
				char *def, char *value, int nid, int n_min,
				int n_max, unsigned long chtype)
d1004 2
a1005 1
	int i;
d1007 2
d1011 2
a1012 2
	if (!batch) BIO_printf(bio_err,"%s [%s]:",text,def);
	(void)BIO_flush(bio_err);
d1022 1
a1022 9
		if (!batch)
			{
			fgets(buf,1024,stdin);
			}
		else
			{
			buf[0] = '\n';
			buf[1] = '\0';
			}
a1041 4
#ifdef CHARSET_EBCDIC
	ebcdic2ascii(buf, buf, i);
#endif
	if(!req_check_len(i, n_min, n_max)) goto start;
d1043 4
a1046 4
	if(!X509_REQ_add1_attr_by_NID(req, nid, chtype,
					(unsigned char *)buf, -1)) {
		BIO_printf(bio_err, "Error adding attribute\n");
		ERR_print_errors(bio_err);
d1048 28
a1075 1
	}
d1077 1
d1080 3
d1086 4
a1089 2
#ifndef OPENSSL_NO_RSA
static void MS_CALLBACK req_cb(int p, int n, void *arg)
d1098 1
a1098 1
	(void)BIO_flush((BIO *)arg);
a1102 1
#endif
d1104 4
a1107 1
static int req_check_len(int len, int n_min, int n_max)
d1109 10
a1118 1
	if ((n_min > 0) && (len < n_min))
d1120 1
a1120 1
		BIO_printf(bio_err,"string is too short, it needs to be at least %d bytes long\n",n_min);
d1123 4
a1126 1
	if ((n_max >= 0) && (len > n_max))
d1128 6
a1133 1
		BIO_printf(bio_err,"string is too long, it needs to be less than  %d bytes long\n",n_max);
a1137 12

/* Check if the end of a string matches 'end' */
static int check_end(char *str, char *end)
{
	int elen, slen;	
	char *tmp;
	elen = strlen(end);
	slen = strlen(str);
	if(elen > slen) return 1;
	tmp = str + slen - elen;
	return strcmp(tmp, end);
}
@


1.1.1.3
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d154 1
a154 1
	unsigned long nmflag = 0, reqflag = 0;
a358 5
		else if (strcmp(*argv,"-reqopt") == 0)
			{
			if (--argc < 1) goto bad;
			if (!set_cert_ex(&reqflag, *(++argv))) goto bad;
			}
d451 1
a451 2
		BIO_printf(bio_err," -nameopt arg   - various certificate name options\n");
		BIO_printf(bio_err," -reqopt arg    - various request text options\n\n");
d625 1
a625 1
		pkey = load_key(bio_err, keyfile, keyform, 0, passin, e,
d984 1
a984 1
			X509_print_ex(out, x509ss, nmflag, reqflag);
d986 1
a986 1
			X509_REQ_print_ex(out, req, nmflag, reqflag);
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a75 1
#include "../crypto/cryptlib.h"
d137 1
a164 1
#ifndef OPENSSL_NO_ENGINE
a165 1
#endif
d179 1
a179 1
	char *to_free;
a212 1
#ifndef OPENSSL_NO_ENGINE
a217 1
#endif
a430 1
#ifndef OPENSSL_NO_ENGINE
a431 1
#endif
d456 1
a456 1
		BIO_printf(bio_err," -nameopt arg    - various certificate name options\n");
d473 8
a480 1
		p=to_free=make_config_name();
d488 1
a488 1
		long errline = -1;
a626 1
#ifndef OPENSSL_NO_ENGINE
a627 1
#endif
a1061 4
#ifndef MONOLITH
	if(to_free)
		OPENSSL_free(to_free);
#endif
d1080 1
a1080 1
	OPENSSL_EXIT(ex);
a1220 7

			if(strlen(v->name) > sizeof buf-9)
			   {
			   BIO_printf(bio_err,"Name '%s' too long\n",v->name);
			   return 0;
			   }

d1227 1
a1236 2
				{
				ERR_clear_error();
a1237 1
				}
a1240 2
				{
				ERR_clear_error();
a1241 1
				}
a1273 6
				if(strlen(v->name) > sizeof buf-9)
				   {
				   BIO_printf(bio_err,"Name '%s' too long\n",v->name);
				   return 0;
				   }

a1376 1
		OPENSSL_assert(strlen(value) < sizeof buf-2);
d1386 1
a1386 1
			fgets(buf,sizeof buf,stdin);
a1434 1
		OPENSSL_assert(strlen(value) < sizeof buf-2);
d1444 1
a1444 1
			fgets(buf,sizeof buf,stdin);
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@d827 1
a827 1
			if(extensions && !X509_set_version(x509ss, 2)) goto end;
d1226 2
a1227 2
			if (BIO_snprintf(buf,sizeof buf,"%s_default",v->name)
				>= sizeof buf)
d1233 1
d1239 1
a1239 2
				
			BIO_snprintf(buf,sizeof buf,"%s_value",v->name);
d1246 1
a1246 1
			BIO_snprintf(buf,sizeof buf,"%s_min",v->name);
d1253 1
a1253 1
			BIO_snprintf(buf,sizeof buf,"%s_max",v->name);
d1291 1
a1291 2
				if (BIO_snprintf(buf,sizeof buf,"%s_default",type)
					>= sizeof buf)
d1297 1
d1306 1
a1306 1
				BIO_snprintf(buf,sizeof buf,"%s_value",type);
d1314 1
a1314 1
				BIO_snprintf(buf,sizeof buf,"%s_min",type);
d1318 1
a1318 1
				BIO_snprintf(buf,sizeof buf,"%s_max",type);
d1400 3
a1402 2
		BUF_strlcpy(buf,value,sizeof buf);
		BUF_strlcat(buf,"\n",sizeof buf);
d1424 2
a1425 2
		BUF_strlcpy(buf,def,sizeof buf);
		BUF_strlcat(buf,"\n",sizeof buf);
d1459 3
a1461 2
		BUF_strlcpy(buf,value,sizeof buf);
		BUF_strlcat(buf,"\n",sizeof buf);
d1483 2
a1484 2
		BUF_strlcpy(buf,def,sizeof buf);
		BUF_strlcat(buf,"\n",sizeof buf);
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d178 1
a178 1
	const EVP_MD *md_alg=NULL,*digest;
a199 7
#ifdef  OPENSSL_FIPS
	if (FIPS_mode())
		digest = EVP_sha1();
	else
#endif
		digest = EVP_md5();

d502 3
a504 1

d507 1
a507 3
			BIO_printf(bio_err,"Unable to load config info from %s\n", default_config_file);
			if (newreq)
				goto end;
a508 3
		else if( verbose )
			BIO_printf(bio_err,"Using configuration from %s\n",
			default_config_file);
d834 1
a834 3
				if (!rand_serial(NULL,
					X509_get_serialNumber(x509ss)))
						goto end;
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@a58 6
/* Until the key-gen callbacks are modified to use newer prototypes, we allow
 * deprecated functions for openssl-internal code */
#ifdef OPENSSL_NO_DEPRECATED
#undef OPENSSL_NO_DEPRECATED
#endif

d76 1
a76 7
#include <openssl/bn.h>
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
d116 3
a118 4
static int make_REQ(X509_REQ *req,EVP_PKEY *pkey,char *dn,int mutlirdn,
		int attribs,unsigned long chtype);
static int build_subject(X509_REQ *req, char *subj, unsigned long chtype,
		int multirdn);
d126 2
a127 2
static int add_attribute_object(X509_REQ *req, char *text, const char *def,
				char *value, int nid, int n_min,
d129 2
a130 2
static int add_DN_object(X509_NAME *n, char *text, const char *def, char *value,
	int nid,int n_min,int n_max, unsigned long chtype, int mval);
d132 1
a132 1
static int MS_CALLBACK req_cb(int p, int n, BN_GENCB *cb);
d135 1
a135 1
static int check_end(const char *str, const char *end);
a144 1
#define TYPE_EC		4
a153 3
#ifndef OPENSSL_NO_ECDSA
	EC_KEY *ec_params = NULL;
#endif
d178 1
a178 2
	int multirdn = 0;
	const EVP_MD *md_alg=NULL,*digest=EVP_sha1();
d200 7
d332 1
a333 1
				newkey=BN_num_bits(dsa_params->p);
a336 53
#ifndef OPENSSL_NO_ECDSA
				if (strncmp("ec:",p,3) == 0)
				{
				X509 *xtmp=NULL;
				EVP_PKEY *dtmp;
				EC_GROUP *group;

				pkey_type=TYPE_EC;
				p+=3;
				if ((in=BIO_new_file(p,"r")) == NULL)
					{
					perror(p);
					goto end;
					}
				if ((ec_params = EC_KEY_new()) == NULL)
					goto end;
				group = PEM_read_bio_ECPKParameters(in, NULL, NULL, NULL);
				if (group == NULL)
					{
					EC_KEY_free(ec_params);
					ERR_clear_error();
					(void)BIO_reset(in);
					if ((xtmp=PEM_read_bio_X509(in,NULL,NULL,NULL)) == NULL)
						{	
						BIO_printf(bio_err,"unable to load EC parameters from file\n");
						goto end;
						}

					if ((dtmp=X509_get_pubkey(xtmp))==NULL)
						goto end;
					if (dtmp->type == EVP_PKEY_EC)
						ec_params = EC_KEY_dup(dtmp->pkey.ec);
					EVP_PKEY_free(dtmp);
					X509_free(xtmp);
					if (ec_params == NULL)
						{
						BIO_printf(bio_err,"Certificate does not contain EC parameters\n");
						goto end;
						}
					}
				else
					{
					if (EC_KEY_set_group(ec_params, group) == 0)
						goto end;
					EC_GROUP_free(group);
					}

				BIO_free(in);
				in=NULL;
				newkey = EC_GROUP_get_degree(EC_KEY_get0_group(ec_params));
				}
			else
#endif
d345 1
a345 3
				{
				goto bad;
				}
a389 2
		else if (strcmp(*argv,"-multivalue-rdn") == 0)
			multirdn=1;
a454 3
#ifndef OPENSSL_NO_ECDSA
		BIO_printf(bio_err," -newkey ec:file generate a new EC key, parameters taken from CA in 'file'\n");
#endif
a457 1
		BIO_printf(bio_err," -multivalue-rdn enable support for multivalued RDNs\n");
d650 1
a650 1
		else
a660 3
#ifndef OPENSSL_NO_RSA
		BN_GENCB cb;
#endif
d674 1
a674 1
		if (newkey < MIN_KEY_LENGTH && (pkey_type == TYPE_RSA || pkey_type == TYPE_DSA))
d677 1
a677 1
			BIO_printf(bio_err,"it needs to be at least %d bits, not %ld\n",MIN_KEY_LENGTH,newkey);
d680 2
a681 3
		BIO_printf(bio_err,"Generating a %ld bit %s private key\n",
			newkey,(pkey_type == TYPE_RSA)?"RSA":
			(pkey_type == TYPE_DSA)?"DSA":"EC");
a685 1
		BN_GENCB_set(&cb, req_cb, bio_err);
d688 3
a690 8
			RSA *rsa = RSA_new();
			BIGNUM *bn = BN_new();
			if(!bn || !rsa || !BN_set_word(bn, 0x10001) ||
					!RSA_generate_key_ex(rsa, newkey, bn, &cb) ||
					!EVP_PKEY_assign_RSA(pkey, rsa))
				{
				if(bn) BN_free(bn);
				if(rsa) RSA_free(rsa);
a691 2
				}
			BN_free(bn);
a702 9
#ifndef OPENSSL_NO_ECDSA
			if (pkey_type == TYPE_EC)
			{
			if (!EC_KEY_generate_key(ec_params)) goto end;
			if (!EVP_PKEY_assign_EC_KEY(pkey, ec_params)) 
				goto end;
			ec_params = NULL;
			}
#endif
a808 4
#ifndef OPENSSL_NO_ECDSA
		if (pkey->type == EVP_PKEY_EC)
			digest=EVP_ecdsa();
#endif
d817 1
a817 1
			i=make_REQ(req,pkey,subj,multirdn,!x509, chtype);
d912 1
a912 1
		if (build_subject(req, subj, chtype, multirdn) == 0)
a1095 3
#ifndef OPENSSL_NO_ECDSA
	if (ec_params != NULL) EC_KEY_free(ec_params);
#endif
d1100 2
a1101 2
static int make_REQ(X509_REQ *req, EVP_PKEY *pkey, char *subj, int multirdn,
			int attribs, unsigned long chtype)
d1151 1
a1151 1
			i = build_subject(req, subj, chtype, multirdn);
d1168 1
a1168 1
static int build_subject(X509_REQ *req, char *subject, unsigned long chtype, int multirdn)
d1172 1
a1172 1
	if (!(n = parse_name(subject, chtype, multirdn)))
d1193 1
a1193 1
	int nid, mval;
d1195 1
a1195 2
	char *type, *value;
	const char *def;
a1235 7
			if (*type == '+')
				{
				mval = -1;
				type++;
				}
			else
				mval = 0;
d1239 1
a1239 1
				>= (int)sizeof(buf))
d1273 1
a1273 1
				n_min,n_max, chtype, mval))
d1304 1
a1304 1
					>= (int)sizeof(buf))
a1362 1
		int mval;
a1378 11
#ifndef CHARSET_EBCDIC
		if (*p == '+')
#else
		if (*p == os_toascii['+'])
#endif
			{
			p++;
			mval = -1;
			}
		else
			mval = 0;
d1380 1
a1380 1
				(unsigned char *) v->value,-1,-1,mval)) return 0;
d1402 2
a1403 2
static int add_DN_object(X509_NAME *n, char *text, const char *def, char *value,
	     int nid, int n_min, int n_max, unsigned long chtype, int mval)
d1452 1
a1452 1
				(unsigned char *) buf, -1,-1,mval)) goto err;
d1458 2
a1459 2
static int add_attribute_object(X509_REQ *req, char *text, const char *def,
				char *value, int nid, int n_min,
d1523 1
a1523 1
static int MS_CALLBACK req_cb(int p, int n, BN_GENCB *cb)
d1531 2
a1532 2
	BIO_write(cb->arg,&c,1);
	(void)BIO_flush(cb->arg);
a1535 1
	return 1;
d1555 1
a1555 1
static int check_end(const char *str, const char *end)
d1558 1
a1558 1
	const char *tmp;
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d144 3
a146 1
static int genpkey_cb(EVP_PKEY_CTX *ctx);
a148 3
static EVP_PKEY_CTX *set_keygen_ctx(BIO *err, const char *gstr, int *pkey_type,
					long *pkeylen, char **palgnam,
					ENGINE *keygen_engine);
d155 5
d164 7
a170 1
	ENGINE *e = NULL, *gen_eng = NULL;
a174 4
	EVP_PKEY_CTX *genctx = NULL;
	const char *keyalg = NULL;
	char *keyalgstr = NULL;
	STACK_OF(OPENSSL_STRING) *pkeyopts = NULL;
d176 1
a176 1
	int i=0,badops=0,newreq=0,verbose=0,pkey_type=-1;
d196 1
a196 1
	const EVP_MD *md_alg=NULL,*digest=NULL;
a238 10
		else if (strcmp(*argv,"-keygen_engine") == 0)
			{
			if (--argc < 1) goto bad;
			gen_eng = ENGINE_by_id(*(++argv));
			if (gen_eng == NULL)
				{
				BIO_printf(bio_err, "Can't find keygen engine %s\n", *argv);
				goto end;
				}
			}
d295 115
a409 1
			if (--argc < 1)
d411 2
a412 1
			keyalg = *(++argv);
a414 9
		else if (strcmp(*argv,"-pkeyopt") == 0)
			{
			if (--argc < 1)
				goto bad;
			if (!pkeyopts)
				pkeyopts = sk_OPENSSL_STRING_new_null();
			if (!pkeyopts || !sk_OPENSSL_STRING_push(pkeyopts, *(++argv)))
				goto bad;
			}
d470 5
a484 5
		else if ((md_alg=EVP_get_digestbyname(&((*argv)[1]))) != NULL)
			{
			/* ok */
			digest=md_alg;
			}
d733 3
a741 8

		if (keyalg)
			{
			genctx = set_keygen_ctx(bio_err, keyalg, &pkey_type, &newkey,
							&keyalgstr, gen_eng);
			if (!genctx)
				goto end;
			}
d749 1
a749 1
		if (newkey < MIN_KEY_LENGTH && (pkey_type == EVP_PKEY_RSA || pkey_type == EVP_PKEY_DSA))
d755 5
d761 3
a763 1
		if (!genctx)
d765 8
a772 3
			genctx = set_keygen_ctx(bio_err, NULL, &pkey_type, &newkey,
							&keyalgstr, gen_eng);
			if (!genctx)
d774 2
d777 4
a780 2

		if (pkeyopts)
d782 3
a784 13
			char *genopt;
			for (i = 0; i < sk_OPENSSL_STRING_num(pkeyopts); i++)
				{
				genopt = sk_OPENSSL_STRING_value(pkeyopts, i);
				if (pkey_ctrl_string(genctx, genopt) <= 0)
					{
					BIO_printf(bio_err,
						"parameter error \"%s\"\n",
						genopt);
					ERR_print_errors(bio_err);
					goto end;
					}
				}
d786 3
a788 8

		BIO_printf(bio_err,"Generating a %ld bit %s private key\n",
				newkey, keyalgstr);

		EVP_PKEY_CTX_set_cb(genctx, genpkey_cb);
		EVP_PKEY_CTX_set_app_data(genctx, bio_err);

		if (EVP_PKEY_keygen(genctx, &pkey) <= 0)
d790 4
a793 2
			BIO_puts(bio_err, "Error Generating Key\n");
			goto end;
d795 1
d797 1
a797 2
		EVP_PKEY_CTX_free(genctx);
		genctx = NULL;
d799 1
a799 1
		app_RAND_write_file(randfile, bio_err);
d898 8
a905 1

d948 1
a948 1
			if (!X509_time_adj_ex(X509_get_notAfter(x509ss), days, 0, NULL)) goto end;
a969 2
				{
				ERR_print_errors(bio_err);
a970 1
				}
a990 2
				{
				ERR_print_errors(bio_err);
a991 1
				}
d1128 1
a1128 1
		if (EVP_PKEY_base_id(tpubkey) == EVP_PKEY_RSA)
a1183 10
	if (genctx)
		EVP_PKEY_CTX_free(genctx);
	if (pkeyopts)
		sk_OPENSSL_STRING_free(pkeyopts);
#ifndef OPENSSL_NO_ENGINE
	if (gen_eng)
		ENGINE_free(gen_eng);
#endif
	if (keyalgstr)
		OPENSSL_free(keyalgstr);
d1190 6
a1435 2
					{
					ERR_clear_error();
a1436 1
					}
a1439 2
					{
					ERR_clear_error();
a1440 1
					}
d1541 1
a1541 2
			if (!fgets(buf,sizeof buf,stdin))
				return 0;
d1599 1
a1599 2
			if (!fgets(buf,sizeof buf,stdin))
				return 0;
d1642 18
a1685 180

static EVP_PKEY_CTX *set_keygen_ctx(BIO *err, const char *gstr, int *pkey_type,
					long *pkeylen, char **palgnam,
					ENGINE *keygen_engine)
	{
	EVP_PKEY_CTX *gctx = NULL;
	EVP_PKEY *param = NULL;
	long keylen = -1;
	BIO *pbio = NULL;
	const char *paramfile = NULL;

	if (gstr == NULL)
		{
		*pkey_type = EVP_PKEY_RSA;
		keylen = *pkeylen;
		}
	else if (gstr[0] >= '0' && gstr[0] <= '9')
		{
		*pkey_type = EVP_PKEY_RSA;
		keylen = atol(gstr);
		*pkeylen = keylen;
		}
	else if (!strncmp(gstr, "param:", 6))
		paramfile = gstr + 6;
	else
		{
		const char *p = strchr(gstr, ':');
		int len;
		ENGINE *tmpeng;
		const EVP_PKEY_ASN1_METHOD *ameth;

		if (p)
			len = p - gstr;
		else
			len = strlen(gstr);
		/* The lookup of a the string will cover all engines so
		 * keep a note of the implementation.
		 */

		ameth = EVP_PKEY_asn1_find_str(&tmpeng, gstr, len);

		if (!ameth)
			{
			BIO_printf(err, "Unknown algorithm %.*s\n", len, gstr);
			return NULL;
			}

		EVP_PKEY_asn1_get0_info(NULL, pkey_type, NULL, NULL, NULL,
									ameth);
#ifndef OPENSSL_NO_ENGINE
		if (tmpeng)
			ENGINE_finish(tmpeng);
#endif
		if (*pkey_type == EVP_PKEY_RSA)
			{
			if (p)
				{
				keylen = atol(p + 1);
				*pkeylen = keylen;
				}
			}
		else if (p)
			paramfile = p + 1;
		}

	if (paramfile)
		{
		pbio = BIO_new_file(paramfile, "r");
		if (!pbio)
			{
			BIO_printf(err, "Can't open parameter file %s\n",
					paramfile);
			return NULL;
			}
		param = PEM_read_bio_Parameters(pbio, NULL);

		if (!param)
			{
			X509 *x;
			(void)BIO_reset(pbio);
			x = PEM_read_bio_X509(pbio, NULL, NULL, NULL);
			if (x)
				{
				param = X509_get_pubkey(x);
				X509_free(x);
				}
			}

		BIO_free(pbio);

		if (!param)
			{
			BIO_printf(err, "Error reading parameter file %s\n",
					paramfile);
			return NULL;
			}
		if (*pkey_type == -1)
			*pkey_type = EVP_PKEY_id(param);
		else if (*pkey_type != EVP_PKEY_base_id(param))
			{
			BIO_printf(err, "Key Type does not match parameters\n");
			EVP_PKEY_free(param);
			return NULL;
			}
		}

	if (palgnam)
		{
		const EVP_PKEY_ASN1_METHOD *ameth;
		ENGINE *tmpeng;
		const char *anam;
		ameth = EVP_PKEY_asn1_find(&tmpeng, *pkey_type);
		if (!ameth)
			{
			BIO_puts(err, "Internal error: can't find key algorithm\n");
			return NULL;
			}
		EVP_PKEY_asn1_get0_info(NULL, NULL, NULL, NULL, &anam, ameth);
		*palgnam = BUF_strdup(anam);
#ifndef OPENSSL_NO_ENGINE
		if (tmpeng)
			ENGINE_finish(tmpeng);
#endif
		}

	if (param)
		{
		gctx = EVP_PKEY_CTX_new(param, keygen_engine);
		*pkeylen = EVP_PKEY_bits(param);
		EVP_PKEY_free(param);
		}
	else
		gctx = EVP_PKEY_CTX_new_id(*pkey_type, keygen_engine);

	if (!gctx)
		{
		BIO_puts(err, "Error allocating keygen context\n");
		ERR_print_errors(err);
		return NULL;
		}

	if (EVP_PKEY_keygen_init(gctx) <= 0)
		{
		BIO_puts(err, "Error initializing keygen context\n");
		ERR_print_errors(err);
		return NULL;
		}
#ifndef OPENSSL_NO_RSA
	if ((*pkey_type == EVP_PKEY_RSA) && (keylen != -1))
		{
		if (EVP_PKEY_CTX_set_rsa_keygen_bits(gctx, keylen) <= 0)
			{
			BIO_puts(err, "Error setting RSA keysize\n");
			ERR_print_errors(err);
			EVP_PKEY_CTX_free(gctx);
			return NULL;
			}
		}
#endif

	return gctx;
	}

static int genpkey_cb(EVP_PKEY_CTX *ctx)
	{
	char c='*';
	BIO *b = EVP_PKEY_CTX_get_app_data(ctx);
	int p;
	p = EVP_PKEY_CTX_get_keygen_info(ctx, 0);
	if (p == 0) c='.';
	if (p == 1) c='+';
	if (p == 2) c='*';
	if (p == 3) c='\n';
	BIO_write(b,&c,1);
	(void)BIO_flush(b);
#ifdef LINT
	p=n;
#endif
	return 1;
	}
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@d168 1
a168 1
	STACK_OF(OPENSSL_STRING) *pkeyopts = NULL, *sigopts = NULL;
a312 9
		else if (strcmp(*argv,"-sigopt") == 0)
			{
			if (--argc < 1)
				goto bad;
			if (!sigopts)
				sigopts = sk_OPENSSL_STRING_new_null();
			if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))
				goto bad;
			}
d861 2
a862 3

			i=do_X509_sign(bio_err, x509ss, pkey, digest, sigopts);
			if (!i)
d886 1
a886 2
			i=do_X509_REQ_sign(bio_err, req, pkey, digest, sigopts);
			if (!i)
a1086 2
	if (sigopts)
		sk_OPENSSL_STRING_free(sigopts);
a1758 65

static int do_sign_init(BIO *err, EVP_MD_CTX *ctx, EVP_PKEY *pkey,
			const EVP_MD *md, STACK_OF(OPENSSL_STRING) *sigopts)
	{
	EVP_PKEY_CTX *pkctx = NULL;
	int i;
	EVP_MD_CTX_init(ctx);
	if (!EVP_DigestSignInit(ctx, &pkctx, md, NULL, pkey))
		return 0;
	for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++)
		{
		char *sigopt = sk_OPENSSL_STRING_value(sigopts, i);
		if (pkey_ctrl_string(pkctx, sigopt) <= 0)
			{
			BIO_printf(err, "parameter error \"%s\"\n", sigopt);
			ERR_print_errors(bio_err);
			return 0;
			}
		}
	return 1;
	}

int do_X509_sign(BIO *err, X509 *x, EVP_PKEY *pkey, const EVP_MD *md,
			STACK_OF(OPENSSL_STRING) *sigopts)
	{
	int rv;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);
	rv = do_sign_init(err, &mctx, pkey, md, sigopts);
	if (rv > 0)
		rv = X509_sign_ctx(x, &mctx);
	EVP_MD_CTX_cleanup(&mctx);
	return rv > 0 ? 1 : 0;
	}


int do_X509_REQ_sign(BIO *err, X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md,
			STACK_OF(OPENSSL_STRING) *sigopts)
	{
	int rv;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);
	rv = do_sign_init(err, &mctx, pkey, md, sigopts);
	if (rv > 0)
		rv = X509_REQ_sign_ctx(x, &mctx);
	EVP_MD_CTX_cleanup(&mctx);
	return rv > 0 ? 1 : 0;
	}
		
	

int do_X509_CRL_sign(BIO *err, X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md,
			STACK_OF(OPENSSL_STRING) *sigopts)
	{
	int rv;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);
	rv = do_sign_init(err, &mctx, pkey, md, sigopts);
	if (rv > 0)
		rv = X509_CRL_sign_ctx(x, &mctx);
	EVP_MD_CTX_cleanup(&mctx);
	return rv > 0 ? 1 : 0;
	}
		
	
@


1.1.1.10
log
@Import OpenSSL 1.0.1g
@
text
@a646 5
		if (!NCONF_get_number(req_conf,SECTION,BITS, &newkey))
			{
			newkey=DEFAULT_KEY_LENGTH;
			}

d655 6
a1651 2
			else
				keylen = *pkeylen;
@


