head	1.36;
access;
symbols
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	butholakala:1.10
	openssl_1_0_1_g:1.1.1.7
	OPENBSD_5_5:1.10.0.16
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.12
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	openssl_1_0_1_c:1.1.1.7
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.8
	openssl_1_0_0_f:1.1.1.7
	openssl_1_0_0_e:1.1.1.7
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	openssh_1_0_0_a:1.1.1.7
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	openssl_0_9_8_k:1.1.1.6
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	openssl_0_9_8_j:1.1.1.6
	openssl_0_9_8_h:1.1.1.6
	pre_openssl_0_9_8h:1.8
	OPENBSD_4_4:1.8.0.18
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.16
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.14
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.12
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	openssl_0_9_7j:1.1.1.5
	openssl:1.1.1
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENSSL_0_9_7D:1.1.1.5
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.35;
commitid	7A7DObXgY4Fni8xJ;

1.35
date	2014.08.24.16.07.29;	author bcook;	state Exp;
branches;
next	1.34;
commitid	DkRmQqUr5tFLfwxx;

1.34
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	EB0l28piqIRSpBUh;

1.33
date	2014.07.12.19.31.21;	author jsing;	state Exp;
branches;
next	1.32;
commitid	X84oGf60c5Z5Yd6T;

1.32
date	2014.06.28.04.39.41;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	gGtvlhTlvaxlmOBo;

1.31
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	mJUVYpkFBZ0Zv2bG;

1.30
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2014.05.05.16.14.45;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2014.05.02.17.06.46;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.22.14.54.13;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.19.16.46.08;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.19.16.18.22;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.19.11.46.39;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.18.04.17.17;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.17.10.24.08;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.16.17.52.31;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.16.02.50.09;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.15.21.47.56;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.13.23.31.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.13.20.37.11;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.01.22.58.51;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.04.06.55.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.13;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.19;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.09;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.09;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.38;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.34.47;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.25;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.41.30;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: s_time.c,v 1.35 2014/08/24 16:07:29 bcook Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#define NO_SHUTDOWN

/*-----------------------------------------
   s_time - SSL client connection timer program
   Written and donated by Larry Streepy <streepy@@healthcare.com>
  -----------------------------------------*/

#include <sys/select.h>
#include <sys/socket.h>

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>

#include "apps.h"

#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/ssl.h>
#include <openssl/x509.h>

#include "s_apps.h"

#define SSL_CONNECT_NAME	"localhost:4433"

 /*#define TEST_CERT "client.pem" *//* no default cert. */

#define BUFSIZZ 1024*10

#define MYBUFSIZ 1024*8

#undef min
#undef max
#define min(a,b) (((a) < (b)) ? (a) : (b))
#define max(a,b) (((a) > (b)) ? (a) : (b))

#define SECONDS	30
extern int verify_depth;
extern int verify_error;

static void s_time_usage(void);
static int parseArgs(int argc, char **argv);
static SSL *doConnection(SSL * scon);
static void s_time_init(void);

/***********************************************************************
 * Static data declarations
 */

/* static char *port=PORT_STR;*/
static char *host = SSL_CONNECT_NAME;
static char *t_cert_file = NULL;
static char *t_key_file = NULL;
static char *CApath = NULL;
static char *CAfile = NULL;
static char *tm_cipher = NULL;
static int tm_verify = SSL_VERIFY_NONE;
static int maxTime = SECONDS;
static SSL_CTX *tm_ctx = NULL;
static const SSL_METHOD *s_time_meth = NULL;
static char *s_www_path = NULL;
static long bytes_read = 0;
static int st_bugs = 0;
static int perform = 0;
static int t_nbio = 0;

static void
s_time_init(void)
{
	host = SSL_CONNECT_NAME;
	t_cert_file = NULL;
	t_key_file = NULL;
	CApath = NULL;
	CAfile = NULL;
	tm_cipher = NULL;
	tm_verify = SSL_VERIFY_NONE;
	maxTime = SECONDS;
	tm_ctx = NULL;
	s_time_meth = NULL;
	s_www_path = NULL;
	bytes_read = 0;
	st_bugs = 0;
	perform = 0;

	t_nbio = 0;
}

/***********************************************************************
 * usage - display usage message
 */
static void
s_time_usage(void)
{
	static const char umsg[] = "\
-time arg     - max number of seconds to collect data, default %d\n\
-verify arg   - turn on peer certificate verification, arg == depth\n\
-cert arg     - certificate file to use, PEM format assumed\n\
-key arg      - RSA file to use, PEM format assumed, key is in cert file\n\
                file if not specified by this option\n\
-CApath arg   - PEM format directory of CA's\n\
-CAfile arg   - PEM format file of CA's\n\
-cipher       - preferred cipher to use, play with 'openssl ciphers'\n\n";

	printf("usage: s_time <args>\n\n");

	printf("-connect host:port - host:port to connect to (default is %s)\n", SSL_CONNECT_NAME);
	printf("-nbio         - Run with non-blocking IO\n");
	printf("-ssl2         - Just use SSLv2\n");
	printf("-ssl3         - Just use SSLv3\n");
	printf("-bugs         - Turn on SSL bug compatibility\n");
	printf("-new          - Just time new connections\n");
	printf("-reuse        - Just time connection reuse\n");
	printf("-www page     - Retrieve 'page' from the site\n");
	printf(umsg, SECONDS);
}

/***********************************************************************
 * parseArgs - Parse command line arguments and initialize data
 *
 * Returns 0 if ok, -1 on bad args
 */
static int
parseArgs(int argc, char **argv)
{
	int badop = 0;
	const char *errstr;

	verify_depth = 0;
	verify_error = X509_V_OK;

	argc--;
	argv++;

	while (argc >= 1) {
		if (strcmp(*argv, "-connect") == 0) {
			if (--argc < 1)
				goto bad;
			host = *(++argv);
		}
#if 0
		else if (strcmp(*argv, "-host") == 0) {
			if (--argc < 1)
				goto bad;
			host = *(++argv);
		} else if (strcmp(*argv, "-port") == 0) {
			if (--argc < 1)
				goto bad;
			port = *(++argv);
		}
#endif
		else if (strcmp(*argv, "-reuse") == 0)
			perform = 2;
		else if (strcmp(*argv, "-new") == 0)
			perform = 1;
		else if (strcmp(*argv, "-verify") == 0) {
			const char *errstr;

			tm_verify = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;
			if (--argc < 1)
				goto bad;
			verify_depth = strtonum(*(++argv), 0, INT_MAX, &errstr);
			if (errstr)
				goto bad;
			BIO_printf(bio_err, "verify depth is %d\n", verify_depth);

		} else if (strcmp(*argv, "-cert") == 0) {

			if (--argc < 1)
				goto bad;
			t_cert_file = *(++argv);

		} else if (strcmp(*argv, "-key") == 0) {

			if (--argc < 1)
				goto bad;
			t_key_file = *(++argv);

		} else if (strcmp(*argv, "-CApath") == 0) {

			if (--argc < 1)
				goto bad;
			CApath = *(++argv);

		} else if (strcmp(*argv, "-CAfile") == 0) {

			if (--argc < 1)
				goto bad;
			CAfile = *(++argv);

		} else if (strcmp(*argv, "-cipher") == 0) {

			if (--argc < 1)
				goto bad;
			tm_cipher = *(++argv);
		}
		else if (strcmp(*argv, "-nbio") == 0) {
			t_nbio = 1;
		}
		else if (strcmp(*argv, "-www") == 0) {
			if (--argc < 1)
				goto bad;
			s_www_path = *(++argv);
			if (strlen(s_www_path) > MYBUFSIZ - 100) {
				BIO_printf(bio_err, "-www option too long\n");
				badop = 1;
			}
		} else if (strcmp(*argv, "-bugs") == 0)
			st_bugs = 1;
		else if (strcmp(*argv, "-ssl3") == 0)
			s_time_meth = SSLv3_client_method();
		else if (strcmp(*argv, "-time") == 0) {

			if (--argc < 1)
				goto bad;
			maxTime = strtonum(*(++argv), 0, INT_MAX, &errstr);
			if (errstr)
				goto bad;
		} else {
			BIO_printf(bio_err, "unknown option %s\n", *argv);
			badop = 1;
			break;
		}

		argc--;
		argv++;
	}

	if (perform == 0)
		perform = 3;

	if (badop) {
bad:
		s_time_usage();
		return -1;
	}
	return 0;		/* Valid args */
}

/***********************************************************************
 * TIME - time functions
 */
#define START	0
#define STOP	1

static double
tm_Time_F(int s)
{
	return app_tminterval(s, 1);
}

/***********************************************************************
 * MAIN - main processing area for client
 *			real name depends on MONOLITH
 */
int s_time_main(int, char **);

int
s_time_main(int argc, char **argv)
{
	double totalTime = 0.0;
	int nConn = 0;
	SSL *scon = NULL;
	long finishtime = 0;
	int ret = 1, i;
	char buf[1024 * 8];
	int ver;

	s_time_init();

	s_time_meth = SSLv23_client_method();

	/* parse the command line arguments */
	if (parseArgs(argc, argv) < 0)
		goto end;

	if ((tm_ctx = SSL_CTX_new(s_time_meth)) == NULL)
		return (1);

	SSL_CTX_set_quiet_shutdown(tm_ctx, 1);

	if (st_bugs)
		SSL_CTX_set_options(tm_ctx, SSL_OP_ALL);
	SSL_CTX_set_cipher_list(tm_ctx, tm_cipher);
	if (!set_cert_stuff(tm_ctx, t_cert_file, t_key_file))
		goto end;

	if ((!SSL_CTX_load_verify_locations(tm_ctx, CAfile, CApath)) ||
	    (!SSL_CTX_set_default_verify_paths(tm_ctx))) {
		/*
		 * BIO_printf(bio_err,"error setting default verify
		 * locations\n");
		 */
		ERR_print_errors(bio_err);
		/* goto end; */
	}
	if (tm_cipher == NULL)
		tm_cipher = getenv("SSL_CIPHER");

	if (tm_cipher == NULL) {
		fprintf(stderr, "No CIPHER specified\n");
	}
	if (!(perform & 1))
		goto next;
	printf("Collecting connection statistics for %d seconds\n", maxTime);

	/* Loop and time how long it takes to make connections */

	bytes_read = 0;
	finishtime = (long) time(NULL) + maxTime;
	tm_Time_F(START);
	for (;;) {
		if (finishtime < (long) time(NULL))
			break;
		if ((scon = doConnection(NULL)) == NULL)
			goto end;

		if (s_www_path != NULL) {
			int ret = snprintf(buf, sizeof buf,
			    "GET %s HTTP/1.0\r\n\r\n", s_www_path);
			if (ret == -1 || ret >= sizeof buf) {
				fprintf(stderr, "URL too long\n");
				goto end;
			}
			SSL_write(scon, buf, strlen(buf));
			while ((i = SSL_read(scon, buf, sizeof(buf))) > 0)
				bytes_read += i;
		}
#ifdef NO_SHUTDOWN
		SSL_set_shutdown(scon, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
#else
		SSL_shutdown(scon);
#endif
		shutdown(SSL_get_fd(scon), SHUT_RDWR);
		close(SSL_get_fd(scon));

		nConn += 1;
		if (SSL_session_reused(scon))
			ver = 'r';
		else {
			ver = SSL_version(scon);
			if (ver == TLS1_VERSION)
				ver = 't';
			else if (ver == SSL3_VERSION)
				ver = '3';
			else if (ver == SSL2_VERSION)
				ver = '2';
			else
				ver = '*';
		}
		fputc(ver, stdout);
		fflush(stdout);

		SSL_free(scon);
		scon = NULL;
	}
	totalTime += tm_Time_F(STOP);	/* Add the time for this iteration */

	i = (int) ((long) time(NULL) - finishtime + maxTime);
	printf("\n\n%d connections in %.2fs; %.2f connections/user sec, bytes read %ld\n", nConn, totalTime, ((double) nConn / totalTime), bytes_read);
	printf("%d connections in %ld real seconds, %ld bytes read per connection\n", nConn, (long) time(NULL) - finishtime + maxTime, bytes_read / nConn);

	/*
	 * Now loop and time connections using the same session id over and
	 * over
	 */

next:
	if (!(perform & 2))
		goto end;
	printf("\n\nNow timing with session id reuse.\n");

	/* Get an SSL object so we can reuse the session id */
	if ((scon = doConnection(NULL)) == NULL) {
		fprintf(stderr, "Unable to get connection\n");
		goto end;
	}
	if (s_www_path != NULL) {
		int ret = snprintf(buf, sizeof buf,
		    "GET %s HTTP/1.0\r\n\r\n", s_www_path);
		if (ret == -1 || ret >= sizeof buf) {
			fprintf(stderr, "URL too long\n");
			goto end;
		}
		SSL_write(scon, buf, strlen(buf));
		while (SSL_read(scon, buf, sizeof(buf)) > 0);
	}
#ifdef NO_SHUTDOWN
	SSL_set_shutdown(scon, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
#else
	SSL_shutdown(scon);
#endif
	shutdown(SSL_get_fd(scon), SHUT_RDWR);
	close(SSL_get_fd(scon));

	nConn = 0;
	totalTime = 0.0;

	finishtime = (long) time(NULL) + maxTime;

	printf("starting\n");
	bytes_read = 0;
	tm_Time_F(START);

	for (;;) {
		if (finishtime < (long) time(NULL))
			break;
		if ((doConnection(scon)) == NULL)
			goto end;

		if (s_www_path) {
			int ret = snprintf(buf, sizeof buf,
			    "GET %s HTTP/1.0\r\n\r\n", s_www_path);
			if (ret == -1 || ret >= sizeof buf) {
				fprintf(stderr, "URL too long\n");
				goto end;
			}
			SSL_write(scon, buf, strlen(buf));
			while ((i = SSL_read(scon, buf, sizeof(buf))) > 0)
				bytes_read += i;
		}
#ifdef NO_SHUTDOWN
		SSL_set_shutdown(scon, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
#else
		SSL_shutdown(scon);
#endif
		shutdown(SSL_get_fd(scon), SHUT_RDWR);
		close(SSL_get_fd(scon));

		nConn += 1;
		if (SSL_session_reused(scon))
			ver = 'r';
		else {
			ver = SSL_version(scon);
			if (ver == TLS1_VERSION)
				ver = 't';
			else if (ver == SSL3_VERSION)
				ver = '3';
			else if (ver == SSL2_VERSION)
				ver = '2';
			else
				ver = '*';
		}
		fputc(ver, stdout);
		fflush(stdout);
	}
	totalTime += tm_Time_F(STOP);	/* Add the time for this iteration */


	printf("\n\n%d connections in %.2fs; %.2f connections/user sec, bytes read %ld\n", nConn, totalTime, ((double) nConn / totalTime), bytes_read);
	printf("%d connections in %ld real seconds, %ld bytes read per connection\n", nConn, (long) time(NULL) - finishtime + maxTime, bytes_read / nConn);

	ret = 0;
end:
	if (scon != NULL)
		SSL_free(scon);

	if (tm_ctx != NULL) {
		SSL_CTX_free(tm_ctx);
		tm_ctx = NULL;
	}

	return (ret);
}

/***********************************************************************
 * doConnection - make a connection
 * Args:
 *		scon	= earlier ssl connection for session id, or NULL
 * Returns:
 *		SSL *	= the connection pointer.
 */
static SSL *
doConnection(SSL * scon)
{
	BIO *conn;
	SSL *serverCon;
	int width, i;
	fd_set readfds;

	if ((conn = BIO_new(BIO_s_connect())) == NULL)
		return (NULL);

/*	BIO_set_conn_port(conn,port);*/
	BIO_set_conn_hostname(conn, host);

	if (scon == NULL)
		serverCon = SSL_new(tm_ctx);
	else {
		serverCon = scon;
		SSL_set_connect_state(serverCon);
	}

	SSL_set_bio(serverCon, conn, conn);

#if 0
	if (scon != NULL)
		SSL_set_session(serverCon, SSL_get_session(scon));
#endif

	/* ok, lets connect */
	for (;;) {
		i = SSL_connect(serverCon);
		if (BIO_sock_should_retry(i)) {
			BIO_printf(bio_err, "DELAY\n");

			i = SSL_get_fd(serverCon);
			width = i + 1;
			FD_ZERO(&readfds);
			FD_SET(i, &readfds);
			select(width, &readfds, NULL, NULL, NULL);
			continue;
		}
		break;
	}
	if (i <= 0) {
		BIO_printf(bio_err, "ERROR\n");
		if (verify_error != X509_V_OK)
			BIO_printf(bio_err, "verify error:%s\n",
			    X509_verify_cert_error_string(verify_error));
		else
			ERR_print_errors(bio_err);
		if (scon == NULL)
			SSL_free(serverCon);
		return NULL;
	}
	return serverCon;
}
@


1.35
log
@Include <sys/select.h> to get select

These files currently depends on the wrapper <stdlib.h> file indirectly
including a header that provides select().

from Jonas 'Sortie' Termansen

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_time.c,v 1.34 2014/07/14 00:35:10 deraadt Exp $ */
@


1.34
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: s_time.c,v 1.33 2014/07/12 19:31:21 jsing Exp $ */
d66 1
@


1.33
log
@In openssl_startup(), call SSL_library_init() and SSL_load_error_strings().
This allows us to remove the ERR_load_crypto_strings() call, along with
the various SSL_load_error_strings() and OpenSSL_add_ssl_algorithms()
calls scattered around the place.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_time.c,v 1.32 2014/06/28 04:39:41 deraadt Exp $ */
d126 1
a126 1
static void 
d150 1
a150 1
static void 
d181 1
a181 1
static int 
d304 1
a304 1
static double 
d316 1
a316 1
int 
d520 1
a520 1
	
@


1.32
log
@Use strtonum() instead of atoi(), and then impose what are we think
are the current range checks.  Help from millert and lteo.  Please test
now that it is deployed and let us know if any numbers are off..
ok lteo
@
text
@d1 1
a1 1
/* $OpenBSD: s_time.c,v 1.31 2014/06/12 15:49:27 deraadt Exp $ */
a334 1
	OpenSSL_add_ssl_algorithms();
a344 2

	SSL_load_error_strings();
@


1.31
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d70 1
d185 1
d215 1
d220 3
a222 1
			verify_depth = atoi(*(++argv));
d274 3
a276 1
			maxTime = atoi(*(++argv));
@


1.30
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@d1 1
a1 1
/* apps/s_time.c */
@


1.29
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@a319 1
	signal(SIGPIPE, SIG_IGN);
@


1.28
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d66 2
d71 1
a71 1
#include <sys/socket.h>
d74 4
d79 1
a79 2
#include <openssl/ssl.h>
#include <openssl/pem.h>
a80 3
#include <openssl/err.h>
#include <unistd.h>

@


1.27
log
@During the great e_os.h nukathon we stopped pulling in <sys/filio.h> via
the ifdef maze, meaning that FIONBIO was no longer defined. This removes
non-blocking I/O support from s_{client,server,time}.

Remove all FIONBIO ifdefs and import <sys/ioctl.h>, renabling -nbio.

ok miod@@
@
text
@a320 3
	if (bio_err == NULL)
		bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);

@


1.26
log
@remove crazy #undefs; ok jsing
@
text
@a120 1
#ifdef FIONBIO
a121 1
#endif
a140 1
#ifdef FIONBIO
a141 1
#endif
a162 1
#ifdef FIONBIO
a169 1
#endif
a247 1
#ifdef FIONBIO
a250 1
#endif
@


1.25
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a83 1
#undef BUFSIZZ
a92 1
#undef SECONDS
@


1.24
log
@Nuke the last of the windows related defines from the openssl apps.

ok deraadt@@
@
text
@d328 1
a328 1
	apps_startup();
d528 1
a528 1
	apps_shutdown();
@


1.23
log
@remove the openssl_fdset wrapper, and a variety of VMS'ism's like
crazy (void *) casts all over the place
ok beck jsing
@
text
@a71 3
#ifdef OPENSSL_NO_STDIO
#define APPS_WIN16
#endif
a76 4
#ifdef WIN32_STUFF
#include "winmain.h"
#include "wintext.h"
#endif
a380 9
#ifdef WIN32_STUFF

		if (flushWinMsgs(0) == -1)
			goto end;

		if (waitingToDie || exitNow)	/* we're dead */
			goto end;
#endif

a473 9

#ifdef WIN32_STUFF
		if (flushWinMsgs(0) == -1)
			goto end;

		if (waitingToDie || exitNow)	/* we're dead */
			goto end;
#endif

@


1.22
log
@truncation check some snprintf calls (over-cautiously in case)
ok jsing beck
@
text
@d601 2
a602 9
			openssl_fdset(i, &readfds);
			/*
			 * Note: under VMS with SOCKETSHR the 2nd parameter
			 * is currently of type (int *) whereas under other
			 * systems it is (void *) if you don't have a cast it
			 * will choke the compiler: if you do have a cast
			 * then you can either go for (int *) or (void *).
			 */
			select(width, (void *) &readfds, NULL, NULL, NULL);
@


1.21
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d401 6
a406 1
			snprintf(buf, sizeof buf, "GET %s HTTP/1.0\r\n\r\n", s_www_path);
d461 6
a466 1
		snprintf(buf, sizeof buf, "GET %s HTTP/1.0\r\n\r\n", s_www_path);
d503 6
a508 1
			snprintf(buf, sizeof buf, "GET %s HTTP/1.0\r\n\r\n", s_www_path);
@


1.20
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d401 1
a401 1
			(void) snprintf(buf, sizeof buf, "GET %s HTTP/1.0\r\n\r\n", s_www_path);
d456 1
a456 1
		(void) snprintf(buf, sizeof buf, "GET %s HTTP/1.0\r\n\r\n", s_www_path);
d493 1
a493 1
			(void) snprintf(buf, sizeof buf, "GET %s HTTP/1.0\r\n\r\n", s_www_path);
@


1.19
log
@KaboomNF
@
text
@a85 2
#undef PROG
#define PROG s_time_main
d322 1
a322 1
int MAIN(int, char **);
d325 1
a325 1
MAIN(int argc, char **argv)
@


1.18
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d91 1
a91 1
/*#define TEST_CERT "client.pem" */ /* no default cert. */
d109 2
a110 2
static int parseArgs( int argc, char **argv );
static SSL *doConnection( SSL *scon );
d118 6
a123 6
static char *host=SSL_CONNECT_NAME;
static char *t_cert_file=NULL;
static char *t_key_file=NULL;
static char *CApath=NULL;
static char *CAfile=NULL;
static char *tm_cipher=NULL;
d126 6
a131 6
static SSL_CTX *tm_ctx=NULL;
static const SSL_METHOD *s_time_meth=NULL;
static char *s_www_path=NULL;
static long bytes_read=0; 
static int st_bugs=0;
static int perform=0;
d133 1
a133 1
static int t_nbio=0;
d136 9
a144 8
static void s_time_init(void)
	{
	host=SSL_CONNECT_NAME;
	t_cert_file=NULL;
	t_key_file=NULL;
	CApath=NULL;
	CAfile=NULL;
	tm_cipher=NULL;
d147 6
a152 6
	tm_ctx=NULL;
	s_time_meth=NULL;
	s_www_path=NULL;
	bytes_read=0; 
	st_bugs=0;
	perform=0;
d155 1
a155 1
	t_nbio=0;
d157 1
a157 1
	}
d162 2
a163 1
static void s_time_usage(void)
d175 1
a175 1
	printf( "usage: s_time <args>\n\n" );
d177 1
a177 1
	printf("-connect host:port - host:port to connect to (default is %s)\n",SSL_CONNECT_NAME);
d187 1
a187 1
	printf( umsg,SECONDS );
d195 2
a196 1
static int parseArgs(int argc, char **argv)
d198 1
a198 1
    int badop = 0;
d200 2
a201 2
    verify_depth=0;
    verify_error=X509_V_OK;
d203 2
a204 2
    argc--;
    argv++;
d206 5
a210 5
    while (argc >= 1) {
	if (strcmp(*argv,"-connect") == 0)
		{
		if (--argc < 1) goto bad;
		host= *(++argv);
d213 8
a220 9
	else if( strcmp(*argv,"-host") == 0)
		{
		if (--argc < 1) goto bad;
		host= *(++argv);
		}
	else if( strcmp(*argv,"-port") == 0)
		{
		if (--argc < 1) goto bad;
		port= *(++argv);
d223 5
a227 5
	else if (strcmp(*argv,"-reuse") == 0)
		perform=2;
	else if (strcmp(*argv,"-new") == 0)
		perform=1;
	else if( strcmp(*argv,"-verify") == 0) {
d229 5
a233 4
	    tm_verify=SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE;
	    if (--argc < 1) goto bad;
	    verify_depth=atoi(*(++argv));
	    BIO_printf(bio_err,"verify depth is %d\n",verify_depth);
d235 1
a235 1
	} else if( strcmp(*argv,"-cert") == 0) {
d237 3
a239 2
	    if (--argc < 1) goto bad;
	    t_cert_file= *(++argv);
d241 1
a241 1
	} else if( strcmp(*argv,"-key") == 0) {
d243 3
a245 2
	    if (--argc < 1) goto bad;
	    t_key_file= *(++argv);
d247 1
a247 1
	} else if( strcmp(*argv,"-CApath") == 0) {
d249 3
a251 2
	    if (--argc < 1) goto bad;
	    CApath= *(++argv);
d253 1
a253 1
	} else if( strcmp(*argv,"-CAfile") == 0) {
d255 3
a257 2
	    if (--argc < 1) goto bad;
	    CAfile= *(++argv);
d259 1
a259 1
	} else if( strcmp(*argv,"-cipher") == 0) {
d261 4
a264 3
	    if (--argc < 1) goto bad;
	    tm_cipher= *(++argv);
	}
d266 3
a268 3
	else if(strcmp(*argv,"-nbio") == 0) {
	    t_nbio=1;
	}
d270 7
a276 8
	else if(strcmp(*argv,"-www") == 0)
		{
		if (--argc < 1) goto bad;
		s_www_path= *(++argv);
		if(strlen(s_www_path) > MYBUFSIZ-100)
			{
			BIO_printf(bio_err,"-www option too long\n");
			badop=1;
d278 13
a291 5
	else if(strcmp(*argv,"-bugs") == 0)
	    st_bugs=1;
	else if(strcmp(*argv,"-ssl3") == 0)
	    s_time_meth=SSLv3_client_method();
	else if( strcmp(*argv,"-time") == 0) {
d293 2
a294 7
	    if (--argc < 1) goto bad;
	    maxTime= atoi(*(++argv));
	}
	else {
	    BIO_printf(bio_err,"unknown option %s\n",*argv);
	    badop=1;
	    break;
d297 2
a298 3
	argc--;
	argv++;
    }
d300 1
a300 3
    if (perform == 0) perform=3;

    if(badop) {
d304 2
a305 3
    }

	return 0;			/* Valid args */
d314 5
a318 4
static double tm_Time_F(int s)
	{
	return app_tminterval(s,1);
	}
d326 3
a328 2
int MAIN(int argc, char **argv)
	{
d331 4
a334 4
	SSL *scon=NULL;
	long finishtime=0;
	int ret=1,i;
	char buf[1024*8];
d341 1
a341 1
		bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
d343 1
a343 1
	s_time_meth=SSLv23_client_method();
d346 1
a346 1
	if( parseArgs( argc, argv ) < 0 )
d350 2
a351 1
	if ((tm_ctx=SSL_CTX_new(s_time_meth)) == NULL) return(1);
d353 1
a353 1
	SSL_CTX_set_quiet_shutdown(tm_ctx,1);
d355 4
a358 3
	if (st_bugs) SSL_CTX_set_options(tm_ctx,SSL_OP_ALL);
	SSL_CTX_set_cipher_list(tm_ctx,tm_cipher);
	if(!set_cert_stuff(tm_ctx,t_cert_file,t_key_file)) 
d363 6
a368 4
	if ((!SSL_CTX_load_verify_locations(tm_ctx,CAfile,CApath)) ||
		(!SSL_CTX_set_default_verify_paths(tm_ctx)))
		{
		/* BIO_printf(bio_err,"error setting default verify locations\n"); */
d371 1
a371 2
		}

d375 2
a376 2
	if (tm_cipher == NULL ) {
		fprintf( stderr, "No CIPHER specified\n" );
d378 3
a380 3

	if (!(perform & 1)) goto next;
	printf( "Collecting connection statistics for %d seconds\n", maxTime );
d384 2
a385 2
	bytes_read=0;
	finishtime=(long)time(NULL)+maxTime;
d387 3
a389 3
	for (;;)
		{
		if (finishtime < (long)time(NULL)) break;
d392 1
a392 1
		if( flushWinMsgs(0) == -1 )
d395 1
a395 1
		if( waitingToDie || exitNow )		/* we're dead */
d399 1
a399 1
		if( (scon = doConnection( NULL )) == NULL )
d402 6
a407 8
		if (s_www_path != NULL)
			{
			(void) snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
			SSL_write(scon,buf,strlen(buf));
			while ((i=SSL_read(scon,buf,sizeof(buf))) > 0)
				bytes_read+=i;
			}

d409 1
a409 1
		SSL_set_shutdown(scon,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
d418 3
a420 4
			ver='r';
		else
			{
			ver=SSL_version(scon);
d422 1
a422 1
				ver='t';
d424 1
a424 1
				ver='3';
d426 1
a426 1
				ver='2';
d428 3
a430 3
				ver='*';
			}
		fputc(ver,stdout);
d433 4
a436 8
		SSL_free( scon );
		scon=NULL;
		}
	totalTime += tm_Time_F(STOP); /* Add the time for this iteration */

	i=(int)((long)time(NULL)-finishtime+maxTime);
	printf( "\n\n%d connections in %.2fs; %.2f connections/user sec, bytes read %ld\n", nConn, totalTime, ((double)nConn/totalTime),bytes_read);
	printf( "%d connections in %ld real seconds, %ld bytes read per connection\n",nConn,(long)time(NULL)-finishtime+maxTime,bytes_read/nConn);
d438 8
a445 1
	/* Now loop and time connections using the same session id over and over */
d448 3
a450 2
	if (!(perform & 2)) goto end;
	printf( "\n\nNow timing with session id reuse.\n" );
d453 2
a454 3
	if( (scon = doConnection( NULL )) == NULL )
		{
		fprintf( stderr, "Unable to get connection\n" );
d456 6
a461 9
		}

	if (s_www_path != NULL)
		{
		(void) snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
		SSL_write(scon,buf,strlen(buf));
		while (SSL_read(scon,buf,sizeof(buf)) > 0)
			;
		}
d463 1
a463 1
	SSL_set_shutdown(scon,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
d473 1
a473 1
	finishtime=(long)time(NULL)+maxTime;
d475 2
a476 2
	printf( "starting\n" );
	bytes_read=0;
d478 4
a481 4
		
	for (;;)
		{
		if (finishtime < (long)time(NULL)) break;
d484 1
a484 1
		if( flushWinMsgs(0) == -1 )
d487 1
a487 1
		if( waitingToDie || exitNow )	/* we're dead */
d491 1
a491 1
	 	if( (doConnection( scon )) == NULL )
d494 6
a499 8
		if (s_www_path)
			{
			(void) snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
			SSL_write(scon,buf,strlen(buf));
			while ((i=SSL_read(scon,buf,sizeof(buf))) > 0)
				bytes_read+=i;
			}

d501 1
a501 1
		SSL_set_shutdown(scon,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
d507 1
a507 1
	
d510 3
a512 4
			ver='r';
		else
			{
			ver=SSL_version(scon);
d514 1
a514 1
				ver='t';
d516 1
a516 1
				ver='3';
d518 1
a518 1
				ver='2';
d520 3
a522 3
				ver='*';
			}
		fputc(ver,stdout);
d524 2
a525 2
		}
	totalTime += tm_Time_F(STOP); /* Add the time for this iteration*/
d528 2
a529 2
	printf( "\n\n%d connections in %.2fs; %.2f connections/user sec, bytes read %ld\n", nConn, totalTime, ((double)nConn/totalTime),bytes_read);
	printf( "%d connections in %ld real seconds, %ld bytes read per connection\n",nConn,(long)time(NULL)-finishtime+maxTime,bytes_read/nConn);
d531 1
a531 1
	ret=0;
d533 2
a534 1
	if (scon != NULL) SSL_free(scon);
d536 1
a536 2
	if (tm_ctx != NULL)
		{
d538 2
a539 2
		tm_ctx=NULL;
		}
d541 2
a542 2
	return(ret);
	}
d551 3
a553 2
static SSL *doConnection(SSL *scon)
	{
d559 2
a560 2
	if ((conn=BIO_new(BIO_s_connect())) == NULL)
		return(NULL);
d563 1
a563 1
	BIO_set_conn_hostname(conn,host);
d566 3
a568 4
		serverCon=SSL_new(tm_ctx);
	else
		{
		serverCon=scon;
d570 1
a570 1
		}
d572 1
a572 1
	SSL_set_bio(serverCon,conn,conn);
d575 2
a576 2
	if( scon != NULL )
		SSL_set_session(serverCon,SSL_get_session(scon));
d580 4
a583 5
	for(;;) {
		i=SSL_connect(serverCon);
		if (BIO_sock_should_retry(i))
			{
			BIO_printf(bio_err,"DELAY\n");
d585 2
a586 2
			i=SSL_get_fd(serverCon);
			width=i+1;
d588 3
a590 2
			openssl_fdset(i,&readfds);
			/* Note: under VMS with SOCKETSHR the 2nd parameter
d593 2
a594 2
			 * will choke the compiler: if you do have a cast then
			 * you can either go for (int *) or (void *).
d596 1
a596 1
			select(width,(void *)&readfds,NULL,NULL,NULL);
d598 1
a598 1
			}
d600 3
a602 4
		}
	if(i <= 0)
		{
		BIO_printf(bio_err,"ERROR\n");
d604 2
a605 2
			BIO_printf(bio_err,"verify error:%s\n",
				X509_verify_cert_error_string(verify_error));
d611 1
a611 2
		}

d613 1
a613 3
	}


@


1.17
log
@unistd.h is always in the same place; no need to #include the result of
a maze of conditional #define's
@
text
@d69 1
a70 1
#define USE_SOCKETS
d536 1
a536 1
	OPENSSL_EXIT(ret);
@


1.16
log
@SSLv3_client_method() doesn't support TLSv1.*; use SSLv23_client_method()
the for anything where version negotiation would be useful.
Also, constipate a couple formatting strings to make compilers and
linkers happier.

ok tedu@@
@
text
@d84 1
a84 1
#include OPENSSL_UNISTD
@


1.15
log
@first round of unifdef hammering
@
text
@d163 1
a163 1
	static char umsg[] = "\
d335 1
a335 1
	s_time_meth=SSLv3_client_method();
@


1.14
log
@remove ssl2 support even more completely.
in the process, always include ssl3 and tls1, we don't need config options
for them. when the time comes to expire ssl3, it will be with an ax.
checked by miod
@
text
@a83 1
#if !defined(OPENSSL_SYS_MSDOS)
a84 1
#endif
a134 3
#ifdef OPENSSL_SYS_WIN32
static int exitNow = 0;		/* Set when it's time to exit main */
#endif
a154 3
#endif
#ifdef OPENSSL_SYS_WIN32
	exitNow = 0;		/* Set when it's time to exit main */
@


1.13
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@a281 5
#ifndef OPENSSL_NO_SSL2
	else if(strcmp(*argv,"-ssl2") == 0)
	    s_time_meth=SSLv2_client_method();
#endif
#ifndef OPENSSL_NO_SSL3
a283 1
#endif
a342 3
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
	s_time_meth=SSLv23_client_method();
#elif !defined(OPENSSL_NO_SSL3)
a343 3
#elif !defined(OPENSSL_NO_SSL2)
	s_time_meth=SSLv2_client_method();
#endif
@


1.12
log
@Remove various horrible socket syscall wrappers, especially SHUTDOWN*
which did shutdown + close, all nasty and surprising.  Use the raw
syscalls that everyone knows the behaviour of.
ok beck matthew
@
text
@d413 1
a413 1
			BIO_snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
d469 1
a469 1
		BIO_snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
d508 1
a508 1
			BIO_snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
@


1.11
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@a90 3
#undef ioctl
#define ioctl ioctlsocket

d424 2
a425 1
		SHUTDOWN2(SSL_get_fd(scon));
d479 2
a480 1
	SHUTDOWN2(SSL_get_fd(scon));
d519 2
a520 1
		SHUTDOWN2(SSL_get_fd(scon));
@


1.10
log
@resolve conflicts, fix local changes
@
text
@d343 1
a343 1
	MS_STATIC char buf[1024*8];
@


1.9
log
@resolve conflicts
@
text
@a87 48
#if !defined(OPENSSL_SYS_NETWARE) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VXWORKS) && (!defined(OPENSSL_SYS_VMS) || defined(__DECC))
#define TIMES
#endif

#ifndef _IRIX
#include <time.h>
#endif
#ifdef TIMES
#include <sys/types.h>
#include <sys/times.h>
#endif

/* Depending on the VMS version, the tms structure is perhaps defined.
   The __TMS macro will show if it was.  If it wasn't defined, we should
   undefine TIMES, since that tells the rest of the program how things
   should be handled.				-- Richard Levitte */
#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__TMS)
#undef TIMES
#endif

#if !defined(TIMES) && !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_NETWARE)
#include <sys/timeb.h>
#endif

#if defined(sun) || defined(__ultrix)
#define _POSIX_SOURCE
#include <limits.h>
#include <sys/param.h>
#endif

/* The following if from times(3) man page.  It may need to be changed
*/
#ifndef HZ
# ifdef _SC_CLK_TCK
#  define HZ ((double)sysconf(_SC_CLK_TCK))
# else
#  ifndef CLK_TCK
#   ifndef _BSD_CLK_TCK_ /* FreeBSD hack */
#    define HZ	100.0
#   else /* _BSD_CLK_TCK_ */
#    define HZ ((double)_BSD_CLK_TCK_)
#   endif
#  else /* CLK_TCK */
#   define HZ ((double)CLK_TCK)
#  endif
# endif
#endif

d132 1
a132 1
static SSL_METHOD *s_time_meth=NULL;
d327 1
a327 54
	static double ret;
#ifdef TIMES
	static struct tms tstart,tend;

	if(s == START) {
		times(&tstart);
		return(0);
	} else {
		times(&tend);
		ret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;
		return((ret == 0.0)?1e-6:ret);
	}
#elif defined(OPENSSL_SYS_NETWARE)
    static clock_t tstart,tend;

    if (s == START)
    {
        tstart=clock();
        return(0);
    }
    else
    {
        tend=clock();
        ret=(double)((double)(tend)-(double)(tstart));
        return((ret < 0.001)?0.001:ret);
    }
#elif defined(OPENSSL_SYS_VXWORKS)
        {
	static unsigned long tick_start, tick_end;

	if( s == START )
		{
		tick_start = tickGet();
		return 0;
		}
	else
		{
		tick_end = tickGet();
		ret = (double)(tick_end - tick_start) / (double)sysClkRateGet();
		return((ret == 0.0)?1e-6:ret);
		}
        }
#else /* !times() */
	static struct timeb tstart,tend;
	long i;

	if(s == START) {
		ftime(&tstart);
		return(0);
	} else {
		ftime(&tend);
		i=(long)tend.millitm-(long)tstart.millitm;
		ret=((double)(tend.time-tstart.time))+((double)i)/1000.0;
		return((ret == 0.0)?1e-6:ret);
a328 2
#endif
}
d604 1
a604 1
			FD_SET(i,&readfds);
@


1.8
log
@merge 0.9.7d
@
text
@d88 1
a88 1
#if !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VXWORKS) && (!defined(OPENSSL_SYS_VMS) || defined(__DECC))
d108 1
a108 1
#if !defined(TIMES) && !defined(OPENSSL_SYS_VXWORKS)
d387 14
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d505 1
a505 1
			snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
d560 1
a560 1
		snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
d598 1
a598 1
			snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
@


1.6
log
@more strcpy & sprintf murder; ho ok
@
text
@d149 2
d325 5
d490 1
a490 1
		if (finishtime < time(NULL)) break;
d541 1
a541 1
	i=(int)(time(NULL)-finishtime+maxTime);
d543 1
a543 1
	printf( "%d connections in %ld real seconds, %ld bytes read per connection\n",nConn,time(NULL)-finishtime+maxTime,bytes_read/nConn);
d575 1
a575 1
	finishtime=time(NULL)+maxTime;
d583 1
a583 1
		if (finishtime < time(NULL)) break;
d633 1
a633 1
	printf( "%d connections in %ld real seconds, %ld bytes read per connection\n",nConn,time(NULL)-finishtime+maxTime,bytes_read/nConn);
d645 1
a645 1
	EXIT(ret);
@


1.5
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d498 1
a498 1
			sprintf(buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
d553 1
a553 1
		sprintf(buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
d591 1
a591 1
			sprintf(buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d88 1
a88 1
#if !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VXWORKS) && (!defined(OPENSSL_SYS_VMS) || defined(__DECC)) && !defined(OPENSSL_SYS_MACOSX)
a109 4
#endif

#ifdef _AIX
#include <sys/select.h>
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d70 3
a72 1
#ifdef NO_STDIO
a74 1
#define USE_SOCKETS
a77 1
#include "apps.h"
d84 3
d88 1
a88 1
#if !defined(MSDOS) && (!defined(VMS) || defined(__DECC))
d104 1
a104 1
#if defined(VMS) && defined(__DECC) && !defined(__TMS)
d108 1
a108 1
#ifndef TIMES
d125 13
a137 5
#ifndef CLK_TCK
#define HZ      100.0
#else /* CLK_TCK */
#define HZ ((double)CLK_TCK)
#endif
d153 2
d190 1
a190 1
#ifdef WIN32
d214 1
a214 1
#ifdef WIN32
d330 1
a330 1
#ifndef NO_SSL2
d334 1
a334 1
#ifndef NO_SSL3
d384 16
d438 1
a438 1
#if !defined(NO_SSL2) && !defined(NO_SSL3)
d440 1
a440 1
#elif !defined(NO_SSL3)
d442 1
a442 1
#elif !defined(NO_SSL2)
a474 1
/*		EXIT(1); */
d641 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@a69 4
#if defined(NO_RSA) && !defined(NO_SSL2)
#define NO_SSL2
#endif

d219 1
a219 1
-cipher       - prefered cipher to use, play with 'openssl ciphers'\n\n";
d228 1
a228 1
	printf("-bugs         - Turn on SSL bug compatability\n");
a246 9
#ifdef FIONBIO
    t_nbio=0;
#endif

	apps_startup();
	s_time_init();

	if (bio_err == NULL)
		bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
d391 2
d403 6
d421 1
a421 1
	SSLeay_add_ssl_algorithms();
d436 1
a436 1
		/* BIO_printf(bio_err,"error seting default verify locations\n"); */
d637 1
a637 1
		serverCon=(SSL *)SSL_new(tm_ctx);
@


1.1
log
@Initial revision
@
text
@d62 1
a62 1
   cntime - SSL client connection timer program
d70 4
a76 3
#include "x509.h"
#include "ssl.h"
#include "pem.h"
d78 3
d83 1
a83 1
#include "err.h"
d89 1
a89 1
#ifndef MSDOS
a92 1
#ifndef VMS
d100 7
a106 8
#else /* VMS */
#include <types.h>
struct tms {
	time_t tms_utime;
	time_t tms_stime;
	time_t tms_uchild;	/* I dunno...  */
	time_t tms_uchildsys;	/* so these names are a guess :-) */
	}
d108 1
d117 2
a118 1
#ifdef sun
a126 1
#ifndef VMS
a127 3
#else /* VMS */
#define HZ      100.0
#endif
d136 1
a153 1
#ifndef NOPROTO
a157 7
#else
static void s_time_usage();
static int parseArgs();
static SSL *doConnection();
static void s_time_init();
#endif

d185 1
a185 1
static void s_time_init()
d213 1
a213 1
static void s_time_usage()
d219 2
a220 2
-key arg      - RSA file to use, PEM format assumed, in cert file if\n\
                not specified but cert fill is.\n\
d223 1
a223 1
-cipher       - prefered cipher to use, play with 'ssleay ciphers'\n\n";
d225 1
a225 1
	printf( "usage: client <args>\n\n" );
d245 1
a245 3
static int parseArgs(argc,argv)
int argc;
char **argv;
d370 1
a370 2
static double tm_Time_F(s)
int s;
d404 1
a404 4
int
MAIN(argc,argv)
int argc;
char **argv;
d628 1
a628 3
static SSL *
doConnection(scon)
SSL *scon;
d667 7
a673 1
			select(width,&readfds,NULL,NULL,NULL);
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d62 1
a62 1
   s_time - SSL client connection timer program
d70 6
a77 6
#ifdef OPENSSL_NO_STDIO
#define APPS_WIN16
#endif
#include <openssl/x509.h>
#include <openssl/ssl.h>
#include <openssl/pem.h>
d79 1
a79 1
#include <openssl/err.h>
a83 3
#if !defined(OPENSSL_SYS_MSDOS)
#include OPENSSL_UNISTD
#endif
d85 1
a85 1
#if !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VXWORKS) && (!defined(OPENSSL_SYS_VMS) || defined(__DECC)) && !defined(OPENSSL_SYS_MACOSX)
d89 1
d97 8
a104 7

/* Depending on the VMS version, the tms structure is perhaps defined.
   The __TMS macro will show if it was.  If it wasn't defined, we should
   undefine TIMES, since that tells the rest of the program how things
   should be handled.				-- Richard Levitte */
#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__TMS)
#undef TIMES
d106 1
a106 2

#if !defined(TIMES) && !defined(OPENSSL_SYS_VXWORKS)
d114 1
a114 2
#if defined(sun) || defined(__ultrix)
#define _POSIX_SOURCE
d122 9
a130 13
# ifdef _SC_CLK_TCK
#  define HZ ((double)sysconf(_SC_CLK_TCK))
# else
#  ifndef CLK_TCK
#   ifndef _BSD_CLK_TCK_ /* FreeBSD hack */
#    define HZ	100.0
#   else /* _BSD_CLK_TCK_ */
#    define HZ ((double)_BSD_CLK_TCK_)
#   endif
#  else /* CLK_TCK */
#   define HZ ((double)CLK_TCK)
#  endif
# endif
a135 1
#undef ioctl
a144 2
#undef min
#undef max
d153 1
d158 7
d188 1
a188 1
#ifdef OPENSSL_SYS_WIN32
d192 1
a192 1
static void s_time_init(void)
d212 1
a212 1
#ifdef OPENSSL_SYS_WIN32
d220 1
a220 1
static void s_time_usage(void)
d226 2
a227 2
-key arg      - RSA file to use, PEM format assumed, key is in cert file\n\
                file if not specified by this option\n\
d230 1
a230 1
-cipher       - preferred cipher to use, play with 'openssl ciphers'\n\n";
d232 1
a232 1
	printf( "usage: s_time <args>\n\n" );
d239 1
a239 1
	printf("-bugs         - Turn on SSL bug compatibility\n");
d252 3
a254 1
static int parseArgs(int argc, char **argv)
d260 9
d339 1
a339 1
#ifndef OPENSSL_NO_SSL2
d343 1
a343 1
#ifndef OPENSSL_NO_SSL3
d379 2
a380 1
static double tm_Time_F(int s)
a393 16
#elif defined(OPENSSL_SYS_VXWORKS)
        {
	static unsigned long tick_start, tick_end;

	if( s == START )
		{
		tick_start = tickGet();
		return 0;
		}
	else
		{
		tick_end = tickGet();
		ret = (double)(tick_end - tick_start) / (double)sysClkRateGet();
		return((ret == 0.0)?1e-6:ret);
		}
        }
d414 4
a417 3
int MAIN(int, char **);

int MAIN(int argc, char **argv)
d427 1
a427 7
	apps_startup();
	s_time_init();

	if (bio_err == NULL)
		bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);

#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
d429 1
a429 1
#elif !defined(OPENSSL_NO_SSL3)
d431 1
a431 1
#elif !defined(OPENSSL_NO_SSL2)
d439 1
a439 1
	OpenSSL_add_ssl_algorithms();
d454 1
a454 1
		/* BIO_printf(bio_err,"error setting default verify locations\n"); */
d464 1
a630 1
	apps_shutdown();
d641 3
a643 1
static SSL *doConnection(SSL *scon)
d657 1
a657 1
		serverCon=SSL_new(tm_ctx);
d682 1
a682 7
			/* Note: under VMS with SOCKETSHR the 2nd parameter
			 * is currently of type (int *) whereas under other
			 * systems it is (void *) if you don't have a cast it
			 * will choke the compiler: if you do have a cast then
			 * you can either go for (int *) or (void *).
			 */
			select(width,(void *)&readfds,NULL,NULL,NULL);
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d88 1
a88 1
#if !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VXWORKS) && (!defined(OPENSSL_SYS_VMS) || defined(__DECC))
d110 4
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a148 2
#define MYBUFSIZ 1024*8

a322 5
		if(strlen(s_www_path) > MYBUFSIZ-100)
			{
			BIO_printf(bio_err,"-www option too long\n");
			badop=1;
			}
d483 1
a483 1
		if (finishtime < (long)time(NULL)) break;
d534 1
a534 1
	i=(int)((long)time(NULL)-finishtime+maxTime);
d536 1
a536 1
	printf( "%d connections in %ld real seconds, %ld bytes read per connection\n",nConn,(long)time(NULL)-finishtime+maxTime,bytes_read/nConn);
d568 1
a568 1
	finishtime=(long)time(NULL)+maxTime;
d576 1
a576 1
		if (finishtime < (long)time(NULL)) break;
d626 1
a626 1
	printf( "%d connections in %ld real seconds, %ld bytes read per connection\n",nConn,(long)time(NULL)-finishtime+maxTime,bytes_read/nConn);
d638 1
a638 1
	OPENSSL_EXIT(ret);
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@d505 1
a505 1
			BIO_snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
d560 1
a560 1
		BIO_snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
d598 1
a598 1
			BIO_snprintf(buf,sizeof buf,"GET %s HTTP/1.0\r\n\r\n",s_www_path);
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d88 1
a88 1
#if !defined(OPENSSL_SYS_NETWARE) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_VXWORKS) && (!defined(OPENSSL_SYS_VMS) || defined(__DECC))
d108 1
a108 1
#if !defined(TIMES) && !defined(OPENSSL_SYS_VXWORKS) && !defined(OPENSSL_SYS_NETWARE)
a386 14
#elif defined(OPENSSL_SYS_NETWARE)
    static clock_t tstart,tend;

    if (s == START)
    {
        tstart=clock();
        return(0);
    }
    else
    {
        tend=clock();
        ret=(double)((double)(tend)-(double)(tstart));
        return((ret < 0.001)?0.001:ret);
    }
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d88 48
d180 1
a180 1
static const SSL_METHOD *s_time_meth=NULL;
d375 54
a428 1
	return app_tminterval(s,1);
d430 2
d707 1
a707 1
			openssl_fdset(i,&readfds);
@


