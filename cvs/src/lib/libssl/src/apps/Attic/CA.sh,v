head	1.8;
access;
symbols
	butholakala:1.7
	openssl_1_0_1_g:1.1.1.6
	OPENBSD_5_5:1.7.0.16
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.12
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	openssl_1_0_1_c:1.1.1.6
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.8
	openssl_1_0_0_f:1.1.1.6
	openssl_1_0_0_e:1.1.1.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	openssh_1_0_0_a:1.1.1.6
	OPENBSD_4_8:1.6.0.8
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	openssl_0_9_8_k:1.1.1.5
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	openssl_0_9_8_j:1.1.1.5
	openssl_0_9_8_h:1.1.1.5
	pre_openssl_0_9_8h:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	openssl_0_9_7j:1.1.1.4
	openssl:1.1.1
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.3.0.22
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.20
	OPENBSD_3_6_BASE:1.3
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.3.0.18
	OPENBSD_3_5_BASE:1.3
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.3.0.16
	OPENBSD_3_4_BASE:1.3
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@# @;


1.8
date	2014.04.18.14.05.01;	author deraadt;	state dead;
branches;
next	1.7;

1.7
date	2010.10.01.22.58.50;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.27.05.06.53;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.29.05.39.15;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.05;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.13;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.07;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.07;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.30;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.36.58;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.06.27.05.05.29;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.00;	author djm;	state Exp;
branches;
next	;


desc
@@


1.8
log
@These files were never installed in the past, and are not generally
used.  They can go away.
ok guenther reyk
@
text
@#!/bin/sh
#
# CA - wrapper around ca to make it easier to use ... basically ca requires
#      some setup stuff to be done before you can use it and this makes
#      things easier between now and when Eric is convinced to fix it :-)
#
# CA -newca ... will setup the right stuff
# CA -newreq ... will generate a certificate request
# CA -sign ... will sign the generated request and output
#
# At the end of that grab newreq.pem and newcert.pem (one has the key
# and the other the certificate) and cat them together and that is what
# you want/need ... I'll make even this a little cleaner later.
#
#
# 12-Jan-96 tjh    Added more things ... including CA -signcert which
#                  converts a certificate to a request and then signs it.
# 10-Jan-96 eay    Fixed a few more bugs and added the SSLEAY_CONFIG
#                  environment variable so this can be driven from
#                  a script.
# 25-Jul-96 eay    Cleaned up filenames some more.
# 11-Jun-96 eay    Fixed a few filename missmatches.
# 03-May-96 eay    Modified to use 'ssleay cmd' instead of 'cmd'.
# 18-Apr-96 tjh    Original hacking
#
# Tim Hudson
# tjh@@cryptsoft.com
#

# default openssl.cnf file has setup as per the following
# demoCA ... where everything is stored
cp_pem() {
    infile=$1
    outfile=$2
    bound=$3
    flag=0
    exec <$infile;
    while read line; do
	if [ $flag -eq 1 ]; then
		echo $line|grep "^-----END.*$bound"  2>/dev/null 1>/dev/null
		if [ $? -eq 0 ] ; then
			echo $line >>$outfile
			break
		else
			echo $line >>$outfile
		fi
	fi

	echo $line|grep "^-----BEGIN.*$bound"  2>/dev/null 1>/dev/null
	if [ $? -eq 0 ]; then
		echo $line >$outfile
		flag=1
	fi
    done
}

usage() {
 echo "usage: $0 -newcert|-newreq|-newreq-nodes|-newca|-sign|-verify" >&2
}

if [ -z "$OPENSSL" ]; then OPENSSL=openssl; fi

if [ -z "$DAYS" ] ; then DAYS="-days 365" ; fi	# 1 year
CADAYS="-days 1095"	# 3 years
REQ="$OPENSSL req $SSLEAY_CONFIG"
CA="$OPENSSL ca $SSLEAY_CONFIG"
VERIFY="$OPENSSL verify"
X509="$OPENSSL x509"
PKCS12="openssl pkcs12"

if [ -z "$CATOP" ] ; then CATOP=./demoCA ; fi
CAKEY=./cakey.pem
CAREQ=./careq.pem
CACERT=./cacert.pem

RET=0

while [ "$1" != "" ] ; do
case $1 in
-\?|-h|-help)
    usage
    exit 0
    ;;
-newcert)
    # create a certificate
    $REQ -new -x509 -keyout newkey.pem -out newcert.pem $DAYS
    RET=$?
    echo "Certificate is in newcert.pem, private key is in newkey.pem"
    ;;
-newreq)
    # create a certificate request
    $REQ -new -keyout newkey.pem -out newreq.pem $DAYS
    RET=$?
    echo "Request is in newreq.pem, private key is in newkey.pem"
    ;;
-newreq-nodes) 
    # create a certificate request
    $REQ -new -nodes -keyout newreq.pem -out newreq.pem $DAYS
    RET=$?
    echo "Request (and private key) is in newreq.pem"
    ;;
-newca)
    # if explicitly asked for or it doesn't exist then setup the directory
    # structure that Eric likes to manage things
    NEW="1"
    if [ "$NEW" -o ! -f ${CATOP}/serial ]; then
	# create the directory hierarchy
	mkdir -p ${CATOP}
	mkdir -p ${CATOP}/certs
	mkdir -p ${CATOP}/crl
	mkdir -p ${CATOP}/newcerts
	mkdir -p ${CATOP}/private
	touch ${CATOP}/index.txt
    fi
    if [ ! -f ${CATOP}/private/$CAKEY ]; then
	echo "CA certificate filename (or enter to create)"
	read FILE

	# ask user for existing CA certificate
	if [ "$FILE" ]; then
	    cp_pem $FILE ${CATOP}/private/$CAKEY PRIVATE
	    cp_pem $FILE ${CATOP}/$CACERT CERTIFICATE
	    RET=$?
	    if [ ! -f "${CATOP}/serial" ]; then
		$X509 -in ${CATOP}/$CACERT -noout -next_serial \
		      -out ${CATOP}/serial
	    fi
	else
	    echo "Making CA certificate ..."
	    $REQ -new -keyout ${CATOP}/private/$CAKEY \
			   -out ${CATOP}/$CAREQ
	    $CA -create_serial -out ${CATOP}/$CACERT $CADAYS -batch \
			   -keyfile ${CATOP}/private/$CAKEY -selfsign \
			   -extensions v3_ca \
			   -infiles ${CATOP}/$CAREQ
	    RET=$?
	fi
    fi
    ;;
-xsign)
    $CA -policy policy_anything -infiles newreq.pem
    RET=$?
    ;;
-pkcs12)
    if [ -z "$2" ] ; then
	CNAME="My Certificate"
    else
	CNAME="$2"
    fi
    $PKCS12 -in newcert.pem -inkey newreq.pem -certfile ${CATOP}/$CACERT \
	    -out newcert.p12 -export -name "$CNAME"
    RET=$?
    exit $RET
    ;;
-sign|-signreq)
    $CA -policy policy_anything -out newcert.pem -infiles newreq.pem
    RET=$?
    cat newcert.pem
    echo "Signed certificate is in newcert.pem"
    ;;
-signCA)
    $CA -policy policy_anything -out newcert.pem -extensions v3_ca -infiles newreq.pem
    RET=$?
    echo "Signed CA certificate is in newcert.pem"
    ;;
-signcert)
    echo "Cert passphrase will be requested twice - bug?"
    $X509 -x509toreq -in newreq.pem -signkey newreq.pem -out tmp.pem
    $CA -policy policy_anything -out newcert.pem -infiles tmp.pem
    RET=$?
    cat newcert.pem
    echo "Signed certificate is in newcert.pem"
    ;;
-verify)
    shift
    if [ -z "$1" ]; then
	    $VERIFY -CAfile $CATOP/$CACERT newcert.pem
	    RET=$?
    else
	for j
	do
	    $VERIFY -CAfile $CATOP/$CACERT $j
	    if [ $? != 0 ]; then
		    RET=$?
	    fi
	done
    fi
    exit $RET
    ;;
*)
    echo "Unknown arg $i" >&2
    usage
    exit 1
    ;;
esac
shift
done
exit $RET
@


1.7
log
@resolve conflicts, fix local changes
@
text
@@


1.6
log
@resolve conflicts
@
text
@d8 2
a9 2
# CA -newreq ... will generate a certificate request 
# CA -sign ... will sign the generated request and output 
d11 1
a11 1
# At the end of that grab newreq.pem and newcert.pem (one has the key 
d19 2
a20 2
#		   environment variable so this can be driven from
#		   a script.
d32 28
d63 1
a63 1
DAYS="-days 365"	# 1 year
d69 1
d71 1
a71 1
CATOP=./demoCA
d76 4
a79 3
for i
do
case $i in
d81 1
a81 1
    echo "usage: CA -newcert|-newreq|-newca|-sign|-verify" >&2
d84 1
a84 1
-newcert) 
d90 1
a90 1
-newreq) 
d96 7
a102 1
-newca)     
d104 1
a104 1
    # structure that Eric likes to manage things 
d108 5
a112 6
	mkdir ${CATOP} 
	mkdir ${CATOP}/certs 
	mkdir ${CATOP}/crl 
	mkdir ${CATOP}/newcerts
	mkdir ${CATOP}/private
	echo "00" > ${CATOP}/serial
d121 2
a122 1
	    cp $FILE ${CATOP}/private/$CAKEY
d124 4
d132 1
a132 1
	    $CA -out ${CATOP}/$CACERT $CADAYS -batch \
d134 2
a135 1
			   -infiles ${CATOP}/$CAREQ 
d141 1
a141 1
    $CA -policy policy_anything -infiles newreq.pem 
d144 12
a155 1
-sign|-signreq) 
d161 6
a166 1
-signcert) 
d170 1
d174 1
a174 1
-verify) 
d188 1
a188 1
    exit 0
d191 2
a192 1
    echo "Unknown arg $i";
d196 1
a198 1

@


1.5
log
@resolve conflicts
@
text
@d35 2
a36 1
DAYS="-days 365"
d44 1
d77 1
a77 1
	echo "01" > ${CATOP}/serial
d90 5
a94 2
	    $REQ -new -x509 -keyout ${CATOP}/private/$CAKEY \
			   -out ${CATOP}/$CACERT $DAYS
@


1.4
log
@resolve conflicts
@
text
@d54 1
a54 1
    $REQ -new -x509 -keyout newreq.pem -out newreq.pem $DAYS
d56 1
a56 1
    echo "Certificate (and private key) is in newreq.pem"
d60 1
a60 1
    $REQ -new -keyout newreq.pem -out newreq.pem $DAYS
d62 1
a62 1
    echo "Request (and private key) is in newreq.pem"
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d33 2
d36 4
a39 4
REQ="openssl req $SSLEAY_CONFIG"
CA="openssl ca $SSLEAY_CONFIG"
VERIFY="openssl verify"
X509="openssl x509"
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d63 1
a63 1
    # if explictly asked for or it doesn't exist then setup the directory
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
# default ssleay.cnf file has setup as per the following
d34 4
a37 4
REQ="ssleay req $SSLEAY_CONFIG"
CA="ssleay ca $SSLEAY_CONFIG"
VERIFY="ssleay verify"
X509="ssleay x509"
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d30 1
a30 1
# default openssl.cnf file has setup as per the following
d34 4
a37 4
REQ="openssl req $SSLEAY_CONFIG"
CA="openssl ca $SSLEAY_CONFIG"
VERIFY="openssl verify"
X509="openssl x509"
d63 1
a63 1
    # if explicitly asked for or it doesn't exist then setup the directory
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a32 2
if [ -z "$OPENSSL" ]; then OPENSSL=openssl; fi

d34 4
a37 4
REQ="$OPENSSL req $SSLEAY_CONFIG"
CA="$OPENSSL ca $SSLEAY_CONFIG"
VERIFY="$OPENSSL verify"
X509="$OPENSSL x509"
@


1.1.1.4
log
@import of openssl-0.9.7j
@
text
@d54 1
a54 1
    $REQ -new -x509 -keyout newkey.pem -out newcert.pem $DAYS
d56 1
a56 1
    echo "Certificate is in newcert.pem, private key is in newkey.pem"
d60 1
a60 1
    $REQ -new -keyout newkey.pem -out newreq.pem $DAYS
d62 1
a62 1
    echo "Request is in newreq.pem, private key is in newkey.pem"
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@d35 1
a35 2
DAYS="-days 365"	# 1 year
CADAYS="-days 1095"	# 3 years
a42 1
CAREQ=./careq.pem
d75 1
a75 1
	echo "00" > ${CATOP}/serial
d88 2
a89 5
	    $REQ -new -keyout ${CATOP}/private/$CAKEY \
			   -out ${CATOP}/$CAREQ
	    $CA -out ${CATOP}/$CACERT $CADAYS -batch \
			   -keyfile ${CATOP}/private/$CAKEY -selfsign \
			   -infiles ${CATOP}/$CAREQ 
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d8 2
a9 2
# CA -newreq ... will generate a certificate request
# CA -sign ... will sign the generated request and output
d11 1
a11 1
# At the end of that grab newreq.pem and newcert.pem (one has the key
d19 2
a20 2
#                  environment variable so this can be driven from
#                  a script.
a31 28
cp_pem() {
    infile=$1
    outfile=$2
    bound=$3
    flag=0
    exec <$infile;
    while read line; do
	if [ $flag -eq 1 ]; then
		echo $line|grep "^-----END.*$bound"  2>/dev/null 1>/dev/null
		if [ $? -eq 0 ] ; then
			echo $line >>$outfile
			break
		else
			echo $line >>$outfile
		fi
	fi

	echo $line|grep "^-----BEGIN.*$bound"  2>/dev/null 1>/dev/null
	if [ $? -eq 0 ]; then
		echo $line >$outfile
		flag=1
	fi
    done
}

usage() {
 echo "usage: $0 -newcert|-newreq|-newreq-nodes|-newca|-sign|-verify" >&2
}
d35 1
a35 1
if [ -z "$DAYS" ] ; then DAYS="-days 365" ; fi	# 1 year
a40 1
PKCS12="openssl pkcs12"
d42 1
a42 1
if [ -z "$CATOP" ] ; then CATOP=./demoCA ; fi
d47 3
a49 4
RET=0

while [ "$1" != "" ] ; do
case $1 in
d51 1
a51 1
    usage
d54 1
a54 1
-newcert)
d60 1
a60 1
-newreq)
d66 1
a66 7
-newreq-nodes) 
    # create a certificate request
    $REQ -new -nodes -keyout newreq.pem -out newreq.pem $DAYS
    RET=$?
    echo "Request (and private key) is in newreq.pem"
    ;;
-newca)
d68 1
a68 1
    # structure that Eric likes to manage things
d72 6
a77 5
	mkdir -p ${CATOP}
	mkdir -p ${CATOP}/certs
	mkdir -p ${CATOP}/crl
	mkdir -p ${CATOP}/newcerts
	mkdir -p ${CATOP}/private
d86 1
a86 2
	    cp_pem $FILE ${CATOP}/private/$CAKEY PRIVATE
	    cp_pem $FILE ${CATOP}/$CACERT CERTIFICATE
a87 4
	    if [ ! -f "${CATOP}/serial" ]; then
		$X509 -in ${CATOP}/$CACERT -noout -next_serial \
		      -out ${CATOP}/serial
	    fi
d92 1
a92 1
	    $CA -create_serial -out ${CATOP}/$CACERT $CADAYS -batch \
d94 1
a94 2
			   -extensions v3_ca \
			   -infiles ${CATOP}/$CAREQ
d100 1
a100 1
    $CA -policy policy_anything -infiles newreq.pem
d103 1
a103 12
-pkcs12)
    if [ -z "$2" ] ; then
	CNAME="My Certificate"
    else
	CNAME="$2"
    fi
    $PKCS12 -in newcert.pem -inkey newreq.pem -certfile ${CATOP}/$CACERT \
	    -out newcert.p12 -export -name "$CNAME"
    RET=$?
    exit $RET
    ;;
-sign|-signreq)
d109 1
a109 6
-signCA)
    $CA -policy policy_anything -out newcert.pem -extensions v3_ca -infiles newreq.pem
    RET=$?
    echo "Signed CA certificate is in newcert.pem"
    ;;
-signcert)
a112 1
    RET=$?
d116 1
a116 1
-verify)
d130 1
a130 1
    exit $RET
d133 1
a133 2
    echo "Unknown arg $i" >&2
    usage
a136 1
shift
d139 1
@


