head	1.50;
access;
symbols
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	butholakala:1.25
	openssl_1_0_1_g:1.1.1.16
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	openssl_1_0_1_c:1.1.1.15
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	openssl_1_0_0_f:1.1.1.14
	openssl_1_0_0_e:1.1.1.13
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	openssh_1_0_0_a:1.1.1.12
	OPENBSD_4_8:1.20.0.6
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	openssl_0_9_8_k:1.1.1.11
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	openssl_0_9_8_j:1.1.1.10
	openssl_0_9_8_h:1.1.1.9
	pre_openssl_0_9_8h:1.17
	OPENBSD_4_4:1.17.0.14
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.12
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.10
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.8
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	openssl_0_9_7j:1.1.1.8
	openssl:1.1.1
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENSSL_0_9_7G:1.1.1.8
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENSSL_0_9_7D:1.1.1.7
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENSSL_0_9_7C:1.1.1.6
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENSSL_0_9_7B:1.1.1.5
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.4
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.49;
commitid	7A7DObXgY4Fni8xJ;

1.49
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	EB0l28piqIRSpBUh;

1.48
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.47;
commitid	0NuggCO2WJOZj8Kh;

1.47
date	2014.07.09.21.02.35;	author tedu;	state Exp;
branches;
next	1.46;
commitid	ivoCf1icUxmbGXSc;

1.46
date	2014.06.28.04.39.41;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	gGtvlhTlvaxlmOBo;

1.45
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	mJUVYpkFBZ0Zv2bG;

1.44
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.06.02.05.38;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.06.01.53.53;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.02.17.06.46;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.22.14.54.13;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.22.14.05.40;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.19.00.41.37;	author beck;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.18.04.33.09;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.18.04.17.17;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.18.02.45.27;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.13.20.37.11;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2012.01.05.23.01.38;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.01.22.58.51;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.09.12.15.19;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.29.05.39.16;	author djm;	state Exp;
branches
	1.17.12.1
	1.17.14.1;
next	1.16;

1.16
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.11.22.15.18;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.04.18.35.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.04.18.34.45;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.04.06.55.14;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.02.51;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.56.59;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.30;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.16;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.21;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.10;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.10;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.39;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.35.00;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.43.22;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.34.26;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.11.11.21.11.14;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.20.41.30;	author markus;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.04.29.05.37.00;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.01.09.12.13.49;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.04.06.06.30.00;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2011.11.03.02.32.07;	author djm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2012.01.05.22.58.52;	author djm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2012.10.13.21.23.33;	author djm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;

1.17.12.1
date	2009.01.09.11.40.48;	author djm;	state Exp;
branches;
next	;

1.17.14.1
date	2009.01.09.11.40.32;	author djm;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: x509.c,v 1.49 2014/07/14 00:35:10 deraadt Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>

#include "apps.h"

#include <openssl/asn1.h>
#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#include <openssl/pem.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>

#include <openssl/dsa.h>

#include <openssl/rsa.h>

#define	POSTFIX	".srl"
#define DEF_DAYS	30

static const char *x509_usage[] = {
	"usage: x509 args\n",
	" -inform arg     - input format - default PEM (one of DER, NET or PEM)\n",
	" -outform arg    - output format - default PEM (one of DER, NET or PEM)\n",
	" -keyform arg    - private key format - default PEM\n",
	" -CAform arg     - CA format - default PEM\n",
	" -CAkeyform arg  - CA key format - default PEM\n",
	" -in arg         - input file - default stdin\n",
	" -out arg        - output file - default stdout\n",
	" -passin arg     - private key password source\n",
	" -serial         - print serial number value\n",
	" -subject_hash   - print subject hash value\n",
#ifndef OPENSSL_NO_MD5
	" -subject_hash_old   - print old-style (MD5) subject hash value\n",
#endif
	" -issuer_hash    - print issuer hash value\n",
#ifndef OPENSSL_NO_MD5
	" -issuer_hash_old    - print old-style (MD5) issuer hash value\n",
#endif
	" -hash           - synonym for -subject_hash\n",
	" -subject        - print subject DN\n",
	" -issuer         - print issuer DN\n",
	" -email          - print email address(es)\n",
	" -startdate      - notBefore field\n",
	" -enddate        - notAfter field\n",
	" -purpose        - print out certificate purposes\n",
	" -dates          - both Before and After dates\n",
	" -modulus        - print the RSA key modulus\n",
	" -pubkey         - output the public key\n",
	" -fingerprint    - print the certificate fingerprint\n",
	" -alias          - output certificate alias\n",
	" -noout          - no certificate output\n",
	" -ocspid         - print OCSP hash values for the subject name and public key\n",
	" -ocsp_uri       - print OCSP Responder URL(s)\n",
	" -trustout       - output a \"trusted\" certificate\n",
	" -clrtrust       - clear all trusted purposes\n",
	" -clrreject      - clear all rejected purposes\n",
	" -addtrust arg   - trust certificate for a given purpose\n",
	" -addreject arg  - reject certificate for a given purpose\n",
	" -setalias arg   - set certificate alias\n",
	" -days arg       - How long till expiry of a signed certificate - def 30 days\n",
	" -checkend arg   - check whether the cert expires in the next arg seconds\n",
	"                   exit 1 if so, 0 if not\n",
	" -signkey arg    - self sign cert with arg\n",
	" -x509toreq      - output a certification request object\n",
	" -req            - input is a certificate request, sign and output.\n",
	" -CA arg         - set the CA certificate, must be PEM format.\n",
	" -CAkey arg      - set the CA key, must be PEM format\n",
	"                   missing, it is assumed to be in the CA file.\n",
	" -CAcreateserial - create serial number file if it does not exist\n",
	" -CAserial arg   - serial file\n",
	" -set_serial     - serial number to use\n",
	" -text           - print the certificate in text form\n",
	" -C              - print out C code forms\n",
	" -md2/-md5/-sha1/-mdc2 - digest to use\n",
	" -extfile        - configuration file with X509V3 extensions to add\n",
	" -extensions     - section from config file with X509V3 extensions to add\n",
	" -clrext         - delete extensions before signing and input certificate\n",
	" -nameopt arg    - various certificate name options\n",
#ifndef OPENSSL_NO_ENGINE
	" -engine e       - use engine e, possibly a hardware device.\n",
#endif
	" -certopt arg    - various certificate text options\n",
	NULL
};

static int callb(int ok, X509_STORE_CTX *ctx);
static int sign(X509 *x, EVP_PKEY *pkey, int days, int clrext,
    const EVP_MD *digest, CONF *conf, char *section);
static int x509_certify(X509_STORE *ctx, char *CAfile, const EVP_MD *digest,
    X509 *x, X509 *xca, EVP_PKEY *pkey, STACK_OF(OPENSSL_STRING) *sigopts,
    char *serial, int create, int days, int clrext, CONF *conf, char *section,
    ASN1_INTEGER *sno);
static int purpose_print(BIO *bio, X509 *cert, X509_PURPOSE *pt);
static int reqfile = 0;

int x509_main(int, char **);

int
x509_main(int argc, char **argv)
{
	ENGINE *e = NULL;
	int ret = 1;
	X509_REQ *req = NULL;
	X509 *x = NULL, *xca = NULL;
	ASN1_OBJECT *objtmp;
	STACK_OF(OPENSSL_STRING) *sigopts = NULL;
	EVP_PKEY *Upkey = NULL, *CApkey = NULL;
	ASN1_INTEGER *sno = NULL;
	int i, num, badops = 0;
	BIO *out = NULL;
	BIO *STDout = NULL;
	STACK_OF(ASN1_OBJECT) *trust = NULL, *reject = NULL;
	int informat, outformat, keyformat, CAformat, CAkeyformat;
	char *infile = NULL, *outfile = NULL, *keyfile = NULL, *CAfile = NULL;
	char *CAkeyfile = NULL, *CAserial = NULL;
	char *alias = NULL;
	int text = 0, serial = 0, subject = 0, issuer = 0, startdate = 0,
	    enddate = 0;
	int next_serial = 0;
	int subject_hash = 0, issuer_hash = 0, ocspid = 0;
#ifndef OPENSSL_NO_MD5
	int subject_hash_old = 0, issuer_hash_old = 0;
#endif
	int noout = 0, sign_flag = 0, CA_flag = 0, CA_createserial = 0,
	    email = 0;
	int ocsp_uri = 0;
	int trustout = 0, clrtrust = 0, clrreject = 0, aliasout = 0, clrext = 0;
	int C = 0;
	int x509req = 0, days = DEF_DAYS, modulus = 0, pubkey = 0;
	int pprint = 0;
	const char **pp;
	X509_STORE *ctx = NULL;
	X509_REQ *rq = NULL;
	int fingerprint = 0;
	char buf[256];
	const EVP_MD *md_alg, *digest = NULL;
	CONF *extconf = NULL;
	char *extsect = NULL, *extfile = NULL, *passin = NULL, *passargin = NULL;
	int checkend = 0, checkoffset = 0;
	unsigned long nmflag = 0, certflag = 0;
#ifndef OPENSSL_NO_ENGINE
	char *engine = NULL;
#endif
	const char *errstr = NULL;

	reqfile = 0;

	STDout = BIO_new_fp(stdout, BIO_NOCLOSE);

	informat = FORMAT_PEM;
	outformat = FORMAT_PEM;
	keyformat = FORMAT_PEM;
	CAformat = FORMAT_PEM;
	CAkeyformat = FORMAT_PEM;

	ctx = X509_STORE_new();
	if (ctx == NULL)
		goto end;
	X509_STORE_set_verify_cb(ctx, callb);

	argc--;
	argv++;
	num = 0;
	while (argc >= 1) {
		if (strcmp(*argv, "-inform") == 0) {
			if (--argc < 1)
				goto bad;
			informat = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-outform") == 0) {
			if (--argc < 1)
				goto bad;
			outformat = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-keyform") == 0) {
			if (--argc < 1)
				goto bad;
			keyformat = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-req") == 0) {
			reqfile = 1;
		} else if (strcmp(*argv, "-CAform") == 0) {
			if (--argc < 1)
				goto bad;
			CAformat = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-CAkeyform") == 0) {
			if (--argc < 1)
				goto bad;
			CAkeyformat = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-sigopt") == 0) {
			if (--argc < 1)
				goto bad;
			if (!sigopts)
				sigopts = sk_OPENSSL_STRING_new_null();
			if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))
				goto bad;
		} else if (strcmp(*argv, "-days") == 0) {
			if (--argc < 1)
				goto bad;
			days = strtonum(*(++argv), 1, INT_MAX, &errstr);
			if (errstr) {
				BIO_printf(bio_err, "bad number of days: %s\n", errstr);
				goto bad;
			}
		} else if (strcmp(*argv, "-passin") == 0) {
			if (--argc < 1)
				goto bad;
			passargin = *(++argv);
		} else if (strcmp(*argv, "-extfile") == 0) {
			if (--argc < 1)
				goto bad;
			extfile = *(++argv);
		} else if (strcmp(*argv, "-extensions") == 0) {
			if (--argc < 1)
				goto bad;
			extsect = *(++argv);
		} else if (strcmp(*argv, "-in") == 0) {
			if (--argc < 1)
				goto bad;
			infile = *(++argv);
		} else if (strcmp(*argv, "-out") == 0) {
			if (--argc < 1)
				goto bad;
			outfile = *(++argv);
		} else if (strcmp(*argv, "-signkey") == 0) {
			if (--argc < 1)
				goto bad;
			keyfile = *(++argv);
			sign_flag = ++num;
		} else if (strcmp(*argv, "-CA") == 0) {
			if (--argc < 1)
				goto bad;
			CAfile = *(++argv);
			CA_flag = ++num;
		} else if (strcmp(*argv, "-CAkey") == 0) {
			if (--argc < 1)
				goto bad;
			CAkeyfile = *(++argv);
		} else if (strcmp(*argv, "-CAserial") == 0) {
			if (--argc < 1)
				goto bad;
			CAserial = *(++argv);
		} else if (strcmp(*argv, "-set_serial") == 0) {
			if (--argc < 1)
				goto bad;
			if (!(sno = s2i_ASN1_INTEGER(NULL, *(++argv))))
				goto bad;
		} else if (strcmp(*argv, "-addtrust") == 0) {
			if (--argc < 1)
				goto bad;
			if (!(objtmp = OBJ_txt2obj(*(++argv), 0))) {
				BIO_printf(bio_err,
				    "Invalid trust object value %s\n", *argv);
				goto bad;
			}
			if (!trust)
				trust = sk_ASN1_OBJECT_new_null();
			sk_ASN1_OBJECT_push(trust, objtmp);
			trustout = 1;
		} else if (strcmp(*argv, "-addreject") == 0) {
			if (--argc < 1)
				goto bad;
			if (!(objtmp = OBJ_txt2obj(*(++argv), 0))) {
				BIO_printf(bio_err,
				    "Invalid reject object value %s\n", *argv);
				goto bad;
			}
			if (!reject)
				reject = sk_ASN1_OBJECT_new_null();
			sk_ASN1_OBJECT_push(reject, objtmp);
			trustout = 1;
		} else if (strcmp(*argv, "-setalias") == 0) {
			if (--argc < 1)
				goto bad;
			alias = *(++argv);
			trustout = 1;
		} else if (strcmp(*argv, "-certopt") == 0) {
			if (--argc < 1)
				goto bad;
			if (!set_cert_ex(&certflag, *(++argv)))
				goto bad;
		} else if (strcmp(*argv, "-nameopt") == 0) {
			if (--argc < 1)
				goto bad;
			if (!set_name_ex(&nmflag, *(++argv)))
				goto bad;
		}
#ifndef OPENSSL_NO_ENGINE
		else if (strcmp(*argv, "-engine") == 0) {
			if (--argc < 1)
				goto bad;
			engine = *(++argv);
		}
#endif
		else if (strcmp(*argv, "-C") == 0)
			C = ++num;
		else if (strcmp(*argv, "-email") == 0)
			email = ++num;
		else if (strcmp(*argv, "-ocsp_uri") == 0)
			ocsp_uri = ++num;
		else if (strcmp(*argv, "-serial") == 0)
			serial = ++num;
		else if (strcmp(*argv, "-next_serial") == 0)
			next_serial = ++num;
		else if (strcmp(*argv, "-modulus") == 0)
			modulus = ++num;
		else if (strcmp(*argv, "-pubkey") == 0)
			pubkey = ++num;
		else if (strcmp(*argv, "-x509toreq") == 0)
			x509req = ++num;
		else if (strcmp(*argv, "-text") == 0)
			text = ++num;
		else if (strcmp(*argv, "-hash") == 0 ||
		    strcmp(*argv, "-subject_hash") == 0)
			subject_hash = ++num;
#ifndef OPENSSL_NO_MD5
		else if (strcmp(*argv, "-subject_hash_old") == 0)
			subject_hash_old = ++num;
#endif
		else if (strcmp(*argv, "-issuer_hash") == 0)
			issuer_hash = ++num;
#ifndef OPENSSL_NO_MD5
		else if (strcmp(*argv, "-issuer_hash_old") == 0)
			issuer_hash_old = ++num;
#endif
		else if (strcmp(*argv, "-subject") == 0)
			subject = ++num;
		else if (strcmp(*argv, "-issuer") == 0)
			issuer = ++num;
		else if (strcmp(*argv, "-fingerprint") == 0)
			fingerprint = ++num;
		else if (strcmp(*argv, "-dates") == 0) {
			startdate = ++num;
			enddate = ++num;
		} else if (strcmp(*argv, "-purpose") == 0)
			pprint = ++num;
		else if (strcmp(*argv, "-startdate") == 0)
			startdate = ++num;
		else if (strcmp(*argv, "-enddate") == 0)
			enddate = ++num;
		else if (strcmp(*argv, "-checkend") == 0) {
			if (--argc < 1)
				goto bad;
			checkoffset = strtonum(*(++argv), 0, INT_MAX, &errstr);
			if (errstr) {
				BIO_printf(bio_err, "checkend unusable: %s\n", errstr);
				goto bad;
			}
			checkend = 1;
		} else if (strcmp(*argv, "-noout") == 0)
			noout = ++num;
		else if (strcmp(*argv, "-trustout") == 0)
			trustout = 1;
		else if (strcmp(*argv, "-clrtrust") == 0)
			clrtrust = ++num;
		else if (strcmp(*argv, "-clrreject") == 0)
			clrreject = ++num;
		else if (strcmp(*argv, "-alias") == 0)
			aliasout = ++num;
		else if (strcmp(*argv, "-CAcreateserial") == 0)
			CA_createserial = ++num;
		else if (strcmp(*argv, "-clrext") == 0)
			clrext = 1;
		else if (strcmp(*argv, "-ocspid") == 0)
			ocspid = ++num;
		else if ((md_alg = EVP_get_digestbyname(*argv + 1))) {
			/* ok */
			digest = md_alg;
		} else {
			BIO_printf(bio_err, "unknown option %s\n", *argv);
			badops = 1;
			break;
		}
		argc--;
		argv++;
	}

	if (badops) {
bad:
		for (pp = x509_usage; (*pp != NULL); pp++)
			BIO_printf(bio_err, "%s", *pp);
		goto end;
	}
#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine, 0);
#endif

	ERR_load_crypto_strings();

	if (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
	}
	if (!X509_STORE_set_default_paths(ctx)) {
		ERR_print_errors(bio_err);
		goto end;
	}
	if ((CAkeyfile == NULL) && (CA_flag) && (CAformat == FORMAT_PEM)) {
		CAkeyfile = CAfile;
	} else if ((CA_flag) && (CAkeyfile == NULL)) {
		BIO_printf(bio_err,
		    "need to specify a CAkey if using the CA command\n");
		goto end;
	}
	if (extfile) {
		long errorline = -1;
		X509V3_CTX ctx2;
		extconf = NCONF_new(NULL);
		if (!NCONF_load(extconf, extfile, &errorline)) {
			if (errorline <= 0)
				BIO_printf(bio_err,
				    "error loading the config file '%s'\n",
				    extfile);
			else
				BIO_printf(bio_err,
				    "error on line %ld of config file '%s'\n",
				    errorline, extfile);
			goto end;
		}
		if (!extsect) {
			extsect = NCONF_get_string(extconf, "default",
			    "extensions");
			if (!extsect) {
				ERR_clear_error();
				extsect = "default";
			}
		}
		X509V3_set_ctx_test(&ctx2);
		X509V3_set_nconf(&ctx2, extconf);
		if (!X509V3_EXT_add_nconf(extconf, &ctx2, extsect, NULL)) {
			BIO_printf(bio_err,
			    "Error Loading extension section %s\n",
			    extsect);
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (reqfile) {
		EVP_PKEY *pkey;
		BIO *in;

		if (!sign_flag && !CA_flag) {
			BIO_printf(bio_err, "We need a private key to sign with\n");
			goto end;
		}
		in = BIO_new(BIO_s_file());
		if (in == NULL) {
			ERR_print_errors(bio_err);
			goto end;
		}
		if (infile == NULL)
			BIO_set_fp(in, stdin, BIO_NOCLOSE | BIO_FP_TEXT);
		else {
			if (BIO_read_filename(in, infile) <= 0) {
				perror(infile);
				BIO_free(in);
				goto end;
			}
		}
		req = PEM_read_bio_X509_REQ(in, NULL, NULL, NULL);
		BIO_free(in);

		if (req == NULL) {
			ERR_print_errors(bio_err);
			goto end;
		}
		if ((req->req_info == NULL) ||
		    (req->req_info->pubkey == NULL) ||
		    (req->req_info->pubkey->public_key == NULL) ||
		    (req->req_info->pubkey->public_key->data == NULL)) {
			BIO_printf(bio_err, "The certificate request appears to corrupted\n");
			BIO_printf(bio_err, "It does not contain a public key\n");
			goto end;
		}
		if ((pkey = X509_REQ_get_pubkey(req)) == NULL) {
			BIO_printf(bio_err, "error unpacking public key\n");
			goto end;
		}
		i = X509_REQ_verify(req, pkey);
		EVP_PKEY_free(pkey);
		if (i < 0) {
			BIO_printf(bio_err, "Signature verification error\n");
			ERR_print_errors(bio_err);
			goto end;
		}
		if (i == 0) {
			BIO_printf(bio_err, "Signature did not match the certificate request\n");
			goto end;
		} else
			BIO_printf(bio_err, "Signature ok\n");

		print_name(bio_err, "subject=", X509_REQ_get_subject_name(req), nmflag);

		if ((x = X509_new()) == NULL)
			goto end;

		if (sno == NULL) {
			sno = ASN1_INTEGER_new();
			if (!sno || !rand_serial(NULL, sno))
				goto end;
			if (!X509_set_serialNumber(x, sno))
				goto end;
			ASN1_INTEGER_free(sno);
			sno = NULL;
		} else if (!X509_set_serialNumber(x, sno))
			goto end;

		if (!X509_set_issuer_name(x, req->req_info->subject))
			goto end;
		if (!X509_set_subject_name(x, req->req_info->subject))
			goto end;

		X509_gmtime_adj(X509_get_notBefore(x), 0);
		X509_time_adj_ex(X509_get_notAfter(x), days, 0, NULL);

		pkey = X509_REQ_get_pubkey(req);
		X509_set_pubkey(x, pkey);
		EVP_PKEY_free(pkey);
	} else
		x = load_cert(bio_err, infile, informat, NULL, e, "Certificate");

	if (x == NULL)
		goto end;
	if (CA_flag) {
		xca = load_cert(bio_err, CAfile, CAformat, NULL, e, "CA Certificate");
		if (xca == NULL)
			goto end;
	}
	if (!noout || text || next_serial) {
		OBJ_create("2.99999.3",
		    "SET.ex3", "SET x509v3 extension 3");

		out = BIO_new(BIO_s_file());
		if (out == NULL) {
			ERR_print_errors(bio_err);
			goto end;
		}
		if (outfile == NULL) {
			BIO_set_fp(out, stdout, BIO_NOCLOSE);
		} else {
			if (BIO_write_filename(out, outfile) <= 0) {
				perror(outfile);
				goto end;
			}
		}
	}
	if (alias)
		X509_alias_set1(x, (unsigned char *) alias, -1);

	if (clrtrust)
		X509_trust_clear(x);
	if (clrreject)
		X509_reject_clear(x);

	if (trust) {
		for (i = 0; i < sk_ASN1_OBJECT_num(trust); i++) {
			objtmp = sk_ASN1_OBJECT_value(trust, i);
			X509_add1_trust_object(x, objtmp);
		}
	}
	if (reject) {
		for (i = 0; i < sk_ASN1_OBJECT_num(reject); i++) {
			objtmp = sk_ASN1_OBJECT_value(reject, i);
			X509_add1_reject_object(x, objtmp);
		}
	}
	if (num) {
		for (i = 1; i <= num; i++) {
			if (issuer == i) {
				print_name(STDout, "issuer= ",
				    X509_get_issuer_name(x), nmflag);
			} else if (subject == i) {
				print_name(STDout, "subject= ",
				    X509_get_subject_name(x), nmflag);
			} else if (serial == i) {
				BIO_printf(STDout, "serial=");
				i2a_ASN1_INTEGER(STDout,
				    X509_get_serialNumber(x));
				BIO_printf(STDout, "\n");
			} else if (next_serial == i) {
				BIGNUM *bnser;
				ASN1_INTEGER *ser;
				ser = X509_get_serialNumber(x);
				bnser = ASN1_INTEGER_to_BN(ser, NULL);
				if (!bnser)
					goto end;
				if (!BN_add_word(bnser, 1))
					goto end;
				ser = BN_to_ASN1_INTEGER(bnser, NULL);
				if (!ser)
					goto end;
				BN_free(bnser);
				i2a_ASN1_INTEGER(out, ser);
				ASN1_INTEGER_free(ser);
				BIO_puts(out, "\n");
			} else if ((email == i) || (ocsp_uri == i)) {
				int j;
				STACK_OF(OPENSSL_STRING) *emlst;
				if (email == i)
					emlst = X509_get1_email(x);
				else
					emlst = X509_get1_ocsp(x);
				for (j = 0; j < sk_OPENSSL_STRING_num(emlst); j++)
					BIO_printf(STDout, "%s\n",
					    sk_OPENSSL_STRING_value(emlst, j));
				X509_email_free(emlst);
			} else if (aliasout == i) {
				unsigned char *alstr;
				alstr = X509_alias_get0(x, NULL);
				if (alstr)
					BIO_printf(STDout, "%s\n", alstr);
				else
					BIO_puts(STDout, "<No Alias>\n");
			} else if (subject_hash == i) {
				BIO_printf(STDout, "%08lx\n", X509_subject_name_hash(x));
			}
#ifndef OPENSSL_NO_MD5
			else if (subject_hash_old == i) {
				BIO_printf(STDout, "%08lx\n", X509_subject_name_hash_old(x));
			}
#endif
			else if (issuer_hash == i) {
				BIO_printf(STDout, "%08lx\n", X509_issuer_name_hash(x));
			}
#ifndef OPENSSL_NO_MD5
			else if (issuer_hash_old == i) {
				BIO_printf(STDout, "%08lx\n", X509_issuer_name_hash_old(x));
			}
#endif
			else if (pprint == i) {
				X509_PURPOSE *ptmp;
				int j;
				BIO_printf(STDout, "Certificate purposes:\n");
				for (j = 0; j < X509_PURPOSE_get_count(); j++) {
					ptmp = X509_PURPOSE_get0(j);
					purpose_print(STDout, x, ptmp);
				}
			} else if (modulus == i) {
				EVP_PKEY *pkey;

				pkey = X509_get_pubkey(x);
				if (pkey == NULL) {
					BIO_printf(bio_err, "Modulus=unavailable\n");
					ERR_print_errors(bio_err);
					goto end;
				}
				BIO_printf(STDout, "Modulus=");
				if (pkey->type == EVP_PKEY_RSA)
					BN_print(STDout, pkey->pkey.rsa->n);
				else
						if (pkey->type == EVP_PKEY_DSA)
							BN_print(STDout, pkey->pkey.dsa->pub_key);
				else
						BIO_printf(STDout, "Wrong Algorithm type");
				BIO_printf(STDout, "\n");
				EVP_PKEY_free(pkey);
			} else if (pubkey == i) {
				EVP_PKEY *pkey;

				pkey = X509_get_pubkey(x);
				if (pkey == NULL) {
					BIO_printf(bio_err, "Error getting public key\n");
					ERR_print_errors(bio_err);
					goto end;
				}
				PEM_write_bio_PUBKEY(STDout, pkey);
				EVP_PKEY_free(pkey);
			} else if (C == i) {
				unsigned char *d;
				char *m;
				int y, z;

				X509_NAME_oneline(X509_get_subject_name(x),
				    buf, sizeof buf);
				BIO_printf(STDout, "/* subject:%s */\n", buf);
				m = X509_NAME_oneline(
				    X509_get_issuer_name(x), buf,
				    sizeof buf);
				BIO_printf(STDout, "/* issuer :%s */\n", buf);

				z = i2d_X509(x, NULL);
				m = malloc(z);

				d = (unsigned char *) m;
				z = i2d_X509_NAME(X509_get_subject_name(x), &d);
				BIO_printf(STDout, "unsigned char XXX_subject_name[%d]={\n", z);
				d = (unsigned char *) m;
				for (y = 0; y < z; y++) {
					BIO_printf(STDout, "0x%02X,", d[y]);
					if ((y & 0x0f) == 0x0f)
						BIO_printf(STDout, "\n");
				}
				if (y % 16 != 0)
					BIO_printf(STDout, "\n");
				BIO_printf(STDout, "};\n");

				z = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(x), &d);
				BIO_printf(STDout, "unsigned char XXX_public_key[%d]={\n", z);
				d = (unsigned char *) m;
				for (y = 0; y < z; y++) {
					BIO_printf(STDout, "0x%02X,", d[y]);
					if ((y & 0x0f) == 0x0f)
						BIO_printf(STDout, "\n");
				}
				if (y % 16 != 0)
					BIO_printf(STDout, "\n");
				BIO_printf(STDout, "};\n");

				z = i2d_X509(x, &d);
				BIO_printf(STDout, "unsigned char XXX_certificate[%d]={\n", z);
				d = (unsigned char *) m;
				for (y = 0; y < z; y++) {
					BIO_printf(STDout, "0x%02X,", d[y]);
					if ((y & 0x0f) == 0x0f)
						BIO_printf(STDout, "\n");
				}
				if (y % 16 != 0)
					BIO_printf(STDout, "\n");
				BIO_printf(STDout, "};\n");

				free(m);
			} else if (text == i) {
				X509_print_ex(STDout, x, nmflag, certflag);
			} else if (startdate == i) {
				BIO_puts(STDout, "notBefore=");
				ASN1_TIME_print(STDout, X509_get_notBefore(x));
				BIO_puts(STDout, "\n");
			} else if (enddate == i) {
				BIO_puts(STDout, "notAfter=");
				ASN1_TIME_print(STDout, X509_get_notAfter(x));
				BIO_puts(STDout, "\n");
			} else if (fingerprint == i) {
				int j;
				unsigned int n;
				unsigned char md[EVP_MAX_MD_SIZE];
				const EVP_MD *fdig = digest;

				if (!fdig)
					fdig = EVP_sha1();

				if (!X509_digest(x, fdig, md, &n)) {
					BIO_printf(bio_err, "out of memory\n");
					goto end;
				}
				BIO_printf(STDout, "%s Fingerprint=",
				    OBJ_nid2sn(EVP_MD_type(fdig)));
				for (j = 0; j < (int) n; j++) {
					BIO_printf(STDout, "%02X%c", md[j],
					    (j + 1 == (int)n) ? '\n' : ':');
				}
			}
			/* should be in the library */
			else if ((sign_flag == i) && (x509req == 0)) {
				BIO_printf(bio_err, "Getting Private key\n");
				if (Upkey == NULL) {
					Upkey = load_key(bio_err,
					    keyfile, keyformat, 0,
					    passin, e, "Private key");
					if (Upkey == NULL)
						goto end;
				}
				if (!sign(x, Upkey, days, clrext, digest,
				    extconf, extsect))
					goto end;
			} else if (CA_flag == i) {
				BIO_printf(bio_err, "Getting CA Private Key\n");
				if (CAkeyfile != NULL) {
					CApkey = load_key(bio_err,
					    CAkeyfile, CAkeyformat,
					    0, passin, e,
					    "CA Private Key");
					if (CApkey == NULL)
						goto end;
				}
				if (!x509_certify(ctx, CAfile, digest, x, xca,
				    CApkey, sigopts,
				    CAserial, CA_createserial, days, clrext,
				    extconf, extsect, sno))
					goto end;
			} else if (x509req == i) {
				EVP_PKEY *pk;

				BIO_printf(bio_err, "Getting request Private Key\n");
				if (keyfile == NULL) {
					BIO_printf(bio_err, "no request key file specified\n");
					goto end;
				} else {
					pk = load_key(bio_err,
					    keyfile, keyformat, 0,
					    passin, e, "request key");
					if (pk == NULL)
						goto end;
				}

				BIO_printf(bio_err, "Generating certificate request\n");

				rq = X509_to_X509_REQ(x, pk, digest);
				EVP_PKEY_free(pk);
				if (rq == NULL) {
					ERR_print_errors(bio_err);
					goto end;
				}
				if (!noout) {
					X509_REQ_print(out, rq);
					PEM_write_bio_X509_REQ(out, rq);
				}
				noout = 1;
			} else if (ocspid == i) {
				X509_ocspid_print(out, x);
			}
		}
	}
	if (checkend) {
		time_t tcheck = time(NULL) + checkoffset;

		if (X509_cmp_time(X509_get_notAfter(x), &tcheck) < 0) {
			BIO_printf(out, "Certificate will expire\n");
			ret = 1;
		} else {
			BIO_printf(out, "Certificate will not expire\n");
			ret = 0;
		}
		goto end;
	}
	if (noout) {
		ret = 0;
		goto end;
	}
	if (outformat == FORMAT_ASN1)
		i = i2d_X509_bio(out, x);
	else if (outformat == FORMAT_PEM) {
		if (trustout)
			i = PEM_write_bio_X509_AUX(out, x);
		else
			i = PEM_write_bio_X509(out, x);
	} else if (outformat == FORMAT_NETSCAPE) {
		NETSCAPE_X509 nx;
		ASN1_OCTET_STRING hdr;

		hdr.data = (unsigned char *) NETSCAPE_CERT_HDR;
		hdr.length = strlen(NETSCAPE_CERT_HDR);
		nx.header = &hdr;
		nx.cert = x;

		i = ASN1_item_i2d_bio(ASN1_ITEM_rptr(NETSCAPE_X509), out, &nx);
	} else {
		BIO_printf(bio_err, "bad output format specified for outfile\n");
		goto end;
	}
	if (!i) {
		BIO_printf(bio_err, "unable to write certificate\n");
		ERR_print_errors(bio_err);
		goto end;
	}
	ret = 0;

end:
	OBJ_cleanup();
	NCONF_free(extconf);
	BIO_free_all(out);
	BIO_free_all(STDout);
	X509_STORE_free(ctx);
	X509_REQ_free(req);
	X509_free(x);
	X509_free(xca);
	EVP_PKEY_free(Upkey);
	EVP_PKEY_free(CApkey);
	if (sigopts)
		sk_OPENSSL_STRING_free(sigopts);
	X509_REQ_free(rq);
	ASN1_INTEGER_free(sno);
	sk_ASN1_OBJECT_pop_free(trust, ASN1_OBJECT_free);
	sk_ASN1_OBJECT_pop_free(reject, ASN1_OBJECT_free);
	free(passin);

	return (ret);
}

static ASN1_INTEGER *
x509_load_serial(char *CAfile, char *serialfile, int create)
{
	char *buf = NULL, *p;
	ASN1_INTEGER *bs = NULL;
	BIGNUM *serial = NULL;
	size_t len;

	len = ((serialfile == NULL) ? (strlen(CAfile) + strlen(POSTFIX) + 1) :
	    (strlen(serialfile))) + 1;
	buf = malloc(len);
	if (buf == NULL) {
		BIO_printf(bio_err, "out of mem\n");
		goto end;
	}
	if (serialfile == NULL) {
		strlcpy(buf, CAfile, len);
		for (p = buf; *p; p++)
			if (*p == '.') {
				*p = '\0';
				break;
			}
		strlcat(buf, POSTFIX, len);
	} else
		strlcpy(buf, serialfile, len);

	serial = load_serial(buf, create, NULL);
	if (serial == NULL)
		goto end;

	if (!BN_add_word(serial, 1)) {
		BIO_printf(bio_err, "add_word failure\n");
		goto end;
	}
	if (!save_serial(buf, NULL, serial, &bs))
		goto end;

end:
	free(buf);
	BN_free(serial);

	return bs;
}

static int
x509_certify(X509_STORE *ctx, char *CAfile, const EVP_MD *digest, X509 *x,
    X509 *xca, EVP_PKEY *pkey, STACK_OF(OPENSSL_STRING) *sigopts,
    char *serialfile, int create, int days, int clrext, CONF *conf,
    char *section, ASN1_INTEGER *sno)
{
	int ret = 0;
	ASN1_INTEGER *bs = NULL;
	X509_STORE_CTX xsc;
	EVP_PKEY *upkey;

	upkey = X509_get_pubkey(xca);
	EVP_PKEY_copy_parameters(upkey, pkey);
	EVP_PKEY_free(upkey);

	if (!X509_STORE_CTX_init(&xsc, ctx, x, NULL)) {
		BIO_printf(bio_err, "Error initialising X509 store\n");
		goto end;
	}
	if (sno)
		bs = sno;
	else if (!(bs = x509_load_serial(CAfile, serialfile, create)))
		goto end;

/*	if (!X509_STORE_add_cert(ctx,x)) goto end;*/

	/*
	 * NOTE: this certificate can/should be self signed, unless it was a
	 * certificate request in which case it is not.
	 */
	X509_STORE_CTX_set_cert(&xsc, x);
	X509_STORE_CTX_set_flags(&xsc, X509_V_FLAG_CHECK_SS_SIGNATURE);
	if (!reqfile && X509_verify_cert(&xsc) <= 0)
		goto end;

	if (!X509_check_private_key(xca, pkey)) {
		BIO_printf(bio_err, "CA certificate and CA private key do not match\n");
		goto end;
	}
	if (!X509_set_issuer_name(x, X509_get_subject_name(xca)))
		goto end;
	if (!X509_set_serialNumber(x, bs))
		goto end;

	if (X509_gmtime_adj(X509_get_notBefore(x), 0L) == NULL)
		goto end;

	/* hardwired expired */
	if (X509_time_adj_ex(X509_get_notAfter(x), days, 0, NULL) == NULL)
		goto end;

	if (clrext) {
		while (X509_get_ext_count(x) > 0)
			X509_delete_ext(x, 0);
	}
	if (conf) {
		X509V3_CTX ctx2;
		X509_set_version(x, 2);	/* version 3 certificate */
		X509V3_set_ctx(&ctx2, xca, x, NULL, NULL, 0);
		X509V3_set_nconf(&ctx2, conf);
		if (!X509V3_EXT_add_nconf(conf, &ctx2, section, x))
			goto end;
	}
	if (!do_X509_sign(bio_err, x, pkey, digest, sigopts))
		goto end;
	ret = 1;
end:
	X509_STORE_CTX_cleanup(&xsc);
	if (!ret)
		ERR_print_errors(bio_err);
	if (!sno)
		ASN1_INTEGER_free(bs);
	return ret;
}

static int
callb(int ok, X509_STORE_CTX *ctx)
{
	int err;
	X509 *err_cert;

	/*
	 * it is ok to use a self signed certificate This case will catch
	 * both the initial ok == 0 and the final ok == 1 calls to this
	 * function
	 */
	err = X509_STORE_CTX_get_error(ctx);
	if (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)
		return 1;

	/*
	 * BAD we should have gotten an error.  Normally if everything worked
	 * X509_STORE_CTX_get_error(ctx) will still be set to
	 * DEPTH_ZERO_SELF_....
	 */
	if (ok) {
		BIO_printf(bio_err, "error with certificate to be certified - should be self signed\n");
		return 0;
	} else {
		err_cert = X509_STORE_CTX_get_current_cert(ctx);
		print_name(bio_err, NULL, X509_get_subject_name(err_cert), 0);
		BIO_printf(bio_err, "error with certificate - error %d at depth %d\n%s\n",
		    err, X509_STORE_CTX_get_error_depth(ctx),
		    X509_verify_cert_error_string(err));
		return 1;
	}
}

/* self sign */
static int
sign(X509 *x, EVP_PKEY *pkey, int days, int clrext, const EVP_MD *digest,
    CONF *conf, char *section)
{

	EVP_PKEY *pktmp;

	pktmp = X509_get_pubkey(x);
	EVP_PKEY_copy_parameters(pktmp, pkey);
	EVP_PKEY_save_parameters(pktmp, 1);
	EVP_PKEY_free(pktmp);

	if (!X509_set_issuer_name(x, X509_get_subject_name(x)))
		goto err;
	if (X509_gmtime_adj(X509_get_notBefore(x), 0) == NULL)
		goto err;

	/* Lets just make it 12:00am GMT, Jan 1 1970 */
	/* memcpy(x->cert_info->validity->notBefore,"700101120000Z",13); */
	/* 28 days to be certified */

	if (X509_gmtime_adj(X509_get_notAfter(x),
	    (long) 60 * 60 * 24 * days) == NULL)
		goto err;

	if (!X509_set_pubkey(x, pkey))
		goto err;
	if (clrext) {
		while (X509_get_ext_count(x) > 0)
			X509_delete_ext(x, 0);
	}
	if (conf) {
		X509V3_CTX ctx;
		X509_set_version(x, 2);	/* version 3 certificate */
		X509V3_set_ctx(&ctx, x, x, NULL, NULL, 0);
		X509V3_set_nconf(&ctx, conf);
		if (!X509V3_EXT_add_nconf(conf, &ctx, section, x))
			goto err;
	}
	if (!X509_sign(x, pkey, digest))
		goto err;
	return 1;

err:
	ERR_print_errors(bio_err);
	return 0;
}

static int
purpose_print(BIO *bio, X509 *cert, X509_PURPOSE *pt)
{
	int id, i, idret;
	char *pname;

	id = X509_PURPOSE_get_id(pt);
	pname = X509_PURPOSE_get0_name(pt);
	for (i = 0; i < 2; i++) {
		idret = X509_check_purpose(cert, id, i);
		BIO_printf(bio, "%s%s : ", pname, i ? " CA" : "");
		if (idret == 1)
			BIO_printf(bio, "Yes\n");
		else if (idret == 0)
			BIO_printf(bio, "No\n");
		else
			BIO_printf(bio, "Yes (WARNING code=%d)\n", idret);
	}
	return 1;
}
@


1.49
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.48 2014/07/12 17:54:31 jsing Exp $ */
@


1.48
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.47 2014/07/09 21:02:35 tedu Exp $ */
d936 1
a936 1
	
@


1.47
log
@unifdef a whole bunch of NO RSA/DSA/ECDH defines i deleted from libssl
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.46 2014/06/28 04:39:41 deraadt Exp $ */
a210 3

	if (!load_config(bio_err, NULL))
		goto end;
@


1.46
log
@Use strtonum() instead of atoi(), and then impose what are we think
are the current range checks.  Help from millert and lteo.  Please test
now that it is deployed and let us know if any numbers are off..
ok lteo
@
text
@d1 1
a1 1
/* $OpenBSD: x509.c,v 1.45 2014/06/12 15:49:27 deraadt Exp $ */
a76 1
#ifndef OPENSSL_NO_DSA
a77 1
#endif
a78 1
#ifndef OPENSSL_NO_RSA
a79 1
#endif
a711 1
#ifndef OPENSSL_NO_RSA
a714 2
#endif
#ifndef OPENSSL_NO_DSA
a717 1
#endif
@


1.45
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d62 1
d212 1
d268 3
a270 3
			days = atoi(*(++argv));
			if (days == 0) {
				BIO_printf(bio_err, "bad number of days\n");
d412 5
a416 1
			checkoffset = atoi(*(++argv));
@


1.44
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@d1 1
a1 1
/* apps/x509.c */
@


1.43
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a213 2
	signal(SIGPIPE, SIG_IGN);

@


1.42
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d942 1
a942 2
	if (passin)
		free(passin);
d985 1
a985 2
	if (buf)
		free(buf);
d987 1
@


1.41
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d63 1
d65 2
d68 1
a68 1
#include <openssl/asn1.h>
a69 1
#include <openssl/bn.h>
d71 2
d75 1
a75 5
#include <openssl/objects.h>
#include <openssl/pem.h>
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
d80 3
@


1.40
log
@"stay backwards-compatible with 0.9.5; this should go away soon"
it's your lucky day!
@
text
@a212 3
	if (bio_err == NULL)
		bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);

d215 1
@


1.39
log
@move a comment to make unifdef happier
@
text
@a426 8
#if 1
		/* stay backwards-compatible with 0.9.5; this
		 * should go away soon */
		else if (strcmp(*argv, "-crlext") == 0) {
			BIO_printf(bio_err, "use -clrext instead of -crlext\n");
			clrext = 1;
		}
#endif
@


1.38
log
@remove crazy #undefs; ok jsing
@
text
@d427 3
a429 2
#if 1				/* stay backwards-compatible with 0.9.5; this
				 * should go away soon */
@


1.37
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a80 1
#undef POSTFIX
@


1.36
log
@Nuke the last of the windows related defines from the openssl apps.

ok deraadt@@
@
text
@d212 1
a212 1
	apps_startup();
d951 1
a951 1
	apps_shutdown();
@


1.35
log
@More KNF.
@
text
@a62 3
#ifdef OPENSSL_NO_STDIO
#define APPS_WIN16
#endif
@


1.34
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d154 8
a161 9
static int callb(int ok, X509_STORE_CTX * ctx);
static int sign(X509 * x, EVP_PKEY * pkey, int days, int clrext,
    const EVP_MD * digest, CONF * conf, char *section);
static int x509_certify(X509_STORE * ctx, char *CAfile, const EVP_MD * digest,
    X509 * x, X509 * xca, EVP_PKEY * pkey,
    STACK_OF(OPENSSL_STRING) * sigopts,
    char *serial, int create, int days, int clrext,
    CONF * conf, char *section, ASN1_INTEGER * sno);
static int purpose_print(BIO * bio, X509 * cert, X509_PURPOSE * pt);
d174 1
a174 1
	STACK_OF(OPENSSL_STRING) * sigopts = NULL;
d180 1
a180 1
	STACK_OF(ASN1_OBJECT) * trust = NULL, *reject = NULL;
d186 1
a186 1
	 enddate = 0;
d193 1
a193 1
	 email = 0;
d384 2
a385 2
		else if (strcmp(*argv, "-hash") == 0
		    || strcmp(*argv, "-subject_hash") == 0)
d475 2
a476 1
		BIO_printf(bio_err, "need to specify a CAkey if using the CA command\n");
d490 2
a491 2
				    "error on line %ld of config file '%s'\n"
				    ,errorline, extfile);
d495 2
a496 1
			extsect = NCONF_get_string(extconf, "default", "extensions");
d672 1
a672 1
				STACK_OF(OPENSSL_STRING) * emlst;
d728 2
a729 2
				if (pkey->type == EVP_PKEY_DSA)
					BN_print(STDout, pkey->pkey.dsa->pub_key);
d732 1
a732 1
					BIO_printf(STDout, "Wrong Algorithm type");
d827 1
a827 2
					    (j + 1 == (int) n)
					    ? '\n' : ':');
d841 1
a841 1
					extconf, extsect))
d854 3
a856 3
					CApkey, sigopts,
					CAserial, CA_createserial, days, clrext,
					extconf, extsect, sno))
d934 1
d966 2
a967 3
	len = ((serialfile == NULL)
	    ? (strlen(CAfile) + strlen(POSTFIX) + 1)
	    : (strlen(serialfile))) + 1;
d1002 5
a1006 7
static int 
x509_certify(X509_STORE * ctx, char *CAfile, const EVP_MD * digest,
    X509 * x, X509 * xca, EVP_PKEY * pkey,
    STACK_OF(OPENSSL_STRING) * sigopts,
    char *serialfile, int create,
    int days, int clrext, CONF * conf, char *section,
    ASN1_INTEGER * sno)
d1077 2
a1078 2
static int 
callb(int ok, X509_STORE_CTX * ctx)
d1111 3
a1113 3
static int 
sign(X509 * x, EVP_PKEY * pkey, int days, int clrext, const EVP_MD * digest,
    CONF * conf, char *section)
d1132 2
a1133 1
	if (X509_gmtime_adj(X509_get_notAfter(x), (long) 60 * 60 * 24 * days) == NULL)
d1153 1
d1159 2
a1160 2
static int 
purpose_print(BIO * bio, X509 * cert, X509_PURPOSE * pt)
d1164 1
@


1.33
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d974 1
a974 1
		BUF_strlcpy(buf, CAfile, len);
d980 1
a980 1
		BUF_strlcat(buf, POSTFIX, len);
d982 1
a982 1
		BUF_strlcpy(buf, serialfile, len);
@


1.32
log
@whitespace normalization
@
text
@a207 1
	int need_rand = 0;
a253 1
			need_rand = 1;
a301 1
			need_rand = 1;
a306 1
			need_rand = 1;
a462 3
	if (need_rand)
		app_RAND_load_file(NULL, bio_err, 0);

a839 1
				assert(need_rand);
a852 1
				assert(need_rand);
a934 2
	if (need_rand)
		app_RAND_write_file(NULL, bio_err);
@


1.31
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d155 3
a157 5
static int 
sign(X509 * x, EVP_PKEY * pkey, int days, int clrext, const EVP_MD * digest,
    CONF * conf, char *section);
static int 
x509_certify(X509_STORE * ctx, char *CAfile, const EVP_MD * digest,
d162 2
a163 2
	static int purpose_print(BIO * bio, X509 * cert, X509_PURPOSE * pt);
	static int reqfile = 0;
d165 1
a165 1
	int x509_main(int, char **);
d167 2
a168 1
	int x509_main(int argc, char **argv)
@


1.30
log
@KaboomNF
@
text
@a82 2
#undef PROG
#define PROG x509_main
d167 1
a167 1
	int MAIN(int, char **);
d169 1
a169 1
	int MAIN(int argc, char **argv)
@


1.29
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d90 12
a101 12
static const char *x509_usage[]={
"usage: x509 args\n",
" -inform arg     - input format - default PEM (one of DER, NET or PEM)\n",
" -outform arg    - output format - default PEM (one of DER, NET or PEM)\n",
" -keyform arg    - private key format - default PEM\n",
" -CAform arg     - CA format - default PEM\n",
" -CAkeyform arg  - CA key format - default PEM\n",
" -in arg         - input file - default stdin\n",
" -out arg        - output file - default stdout\n",
" -passin arg     - private key password source\n",
" -serial         - print serial number value\n",
" -subject_hash   - print subject hash value\n",
d103 1
a103 1
" -subject_hash_old   - print old-style (MD5) subject hash value\n",
d105 1
a105 1
" -issuer_hash    - print issuer hash value\n",
d107 1
a107 1
" -issuer_hash_old    - print old-style (MD5) issuer hash value\n",
d109 40
a148 40
" -hash           - synonym for -subject_hash\n",
" -subject        - print subject DN\n",
" -issuer         - print issuer DN\n",
" -email          - print email address(es)\n",
" -startdate      - notBefore field\n",
" -enddate        - notAfter field\n",
" -purpose        - print out certificate purposes\n",
" -dates          - both Before and After dates\n",
" -modulus        - print the RSA key modulus\n",
" -pubkey         - output the public key\n",
" -fingerprint    - print the certificate fingerprint\n",
" -alias          - output certificate alias\n",
" -noout          - no certificate output\n",
" -ocspid         - print OCSP hash values for the subject name and public key\n",
" -ocsp_uri       - print OCSP Responder URL(s)\n",
" -trustout       - output a \"trusted\" certificate\n",
" -clrtrust       - clear all trusted purposes\n",
" -clrreject      - clear all rejected purposes\n",
" -addtrust arg   - trust certificate for a given purpose\n",
" -addreject arg  - reject certificate for a given purpose\n",
" -setalias arg   - set certificate alias\n",
" -days arg       - How long till expiry of a signed certificate - def 30 days\n",
" -checkend arg   - check whether the cert expires in the next arg seconds\n",
"                   exit 1 if so, 0 if not\n",
" -signkey arg    - self sign cert with arg\n",
" -x509toreq      - output a certification request object\n",
" -req            - input is a certificate request, sign and output.\n",
" -CA arg         - set the CA certificate, must be PEM format.\n",
" -CAkey arg      - set the CA key, must be PEM format\n",
"                   missing, it is assumed to be in the CA file.\n",
" -CAcreateserial - create serial number file if it does not exist\n",
" -CAserial arg   - serial file\n",
" -set_serial     - serial number to use\n",
" -text           - print the certificate in text form\n",
" -C              - print out C code forms\n",
" -md2/-md5/-sha1/-mdc2 - digest to use\n",
" -extfile        - configuration file with X509V3 extensions to add\n",
" -extensions     - section from config file with X509V3 extensions to add\n",
" -clrext         - delete extensions before signing and input certificate\n",
" -nameopt arg    - various certificate name options\n",
d150 1
a150 1
" -engine e       - use engine e, possibly a hardware device.\n",
d152 2
a153 2
" -certopt arg    - various certificate text options\n",
NULL
d156 12
a167 10
static int callb(int ok, X509_STORE_CTX *ctx);
static int sign (X509 *x, EVP_PKEY *pkey,int days,int clrext, const EVP_MD *digest,
						CONF *conf, char *section);
static int x509_certify (X509_STORE *ctx,char *CAfile,const EVP_MD *digest,
			 X509 *x,X509 *xca,EVP_PKEY *pkey,
			 STACK_OF(OPENSSL_STRING) *sigopts,
			 char *serial, int create ,int days, int clrext,
			 CONF *conf, char *section, ASN1_INTEGER *sno);
static int purpose_print(BIO *bio, X509 *cert, X509_PURPOSE *pt);
static int reqfile=0;
d169 1
a169 1
int MAIN(int, char **);
d171 2
a172 2
int MAIN(int argc, char **argv)
	{
d174 3
a176 3
	int ret=1;
	X509_REQ *req=NULL;
	X509 *x=NULL,*xca=NULL;
d178 2
a179 2
	STACK_OF(OPENSSL_STRING) *sigopts = NULL;
	EVP_PKEY *Upkey=NULL,*CApkey=NULL;
d181 12
a192 11
	int i,num,badops=0;
	BIO *out=NULL;
	BIO *STDout=NULL;
	STACK_OF(ASN1_OBJECT) *trust = NULL, *reject = NULL;
	int informat,outformat,keyformat,CAformat,CAkeyformat;
	char *infile=NULL,*outfile=NULL,*keyfile=NULL,*CAfile=NULL;
	char *CAkeyfile=NULL,*CAserial=NULL;
	char *alias=NULL;
	int text=0,serial=0,subject=0,issuer=0,startdate=0,enddate=0;
	int next_serial=0;
	int subject_hash=0,issuer_hash=0,ocspid=0;
d194 1
a194 1
	int subject_hash_old=0,issuer_hash_old=0;
d196 6
a201 5
	int noout=0,sign_flag=0,CA_flag=0,CA_createserial=0,email=0;
	int ocsp_uri=0;
	int trustout=0,clrtrust=0,clrreject=0,aliasout=0,clrext=0;
	int C=0;
	int x509req=0,days=DEF_DAYS,modulus=0,pubkey=0;
d204 3
a206 3
	X509_STORE *ctx=NULL;
	X509_REQ *rq=NULL;
	int fingerprint=0;
d208 1
a208 1
	const EVP_MD *md_alg,*digest=NULL;
d212 1
a212 1
	int checkend=0,checkoffset=0;
d215 1
a215 1
	char *engine=NULL;
d218 1
a218 1
	reqfile=0;
d223 1
a223 1
		bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
d227 7
a233 1
	STDout=BIO_new_fp(stdout,BIO_NOCLOSE);
d235 4
a238 9
	informat=FORMAT_PEM;
	outformat=FORMAT_PEM;
	keyformat=FORMAT_PEM;
	CAformat=FORMAT_PEM;
	CAkeyformat=FORMAT_PEM;

	ctx=X509_STORE_new();
	if (ctx == NULL) goto end;
	X509_STORE_set_verify_cb(ctx,callb);
d242 16
a257 21
	num=0;
	while (argc >= 1)
		{
		if 	(strcmp(*argv,"-inform") == 0)
			{
			if (--argc < 1) goto bad;
			informat=str2fmt(*(++argv));
			}
		else if (strcmp(*argv,"-outform") == 0)
			{
			if (--argc < 1) goto bad;
			outformat=str2fmt(*(++argv));
			}
		else if (strcmp(*argv,"-keyform") == 0)
			{
			if (--argc < 1) goto bad;
			keyformat=str2fmt(*(++argv));
			}
		else if (strcmp(*argv,"-req") == 0)
			{
			reqfile=1;
d259 9
a267 13
			}
		else if (strcmp(*argv,"-CAform") == 0)
			{
			if (--argc < 1) goto bad;
			CAformat=str2fmt(*(++argv));
			}
		else if (strcmp(*argv,"-CAkeyform") == 0)
			{
			if (--argc < 1) goto bad;
			CAkeyformat=str2fmt(*(++argv));
			}
		else if (strcmp(*argv,"-sigopt") == 0)
			{
d274 7
d282 22
a303 7
		else if (strcmp(*argv,"-days") == 0)
			{
			if (--argc < 1) goto bad;
			days=atoi(*(++argv));
			if (days == 0)
				{
				BIO_printf(bio_err,"bad number of days\n");
d305 2
a306 32
				}
			}
		else if (strcmp(*argv,"-passin") == 0)
			{
			if (--argc < 1) goto bad;
			passargin= *(++argv);
			}
		else if (strcmp(*argv,"-extfile") == 0)
			{
			if (--argc < 1) goto bad;
			extfile= *(++argv);
			}
		else if (strcmp(*argv,"-extensions") == 0)
			{
			if (--argc < 1) goto bad;
			extsect= *(++argv);
			}
		else if (strcmp(*argv,"-in") == 0)
			{
			if (--argc < 1) goto bad;
			infile= *(++argv);
			}
		else if (strcmp(*argv,"-out") == 0)
			{
			if (--argc < 1) goto bad;
			outfile= *(++argv);
			}
		else if (strcmp(*argv,"-signkey") == 0)
			{
			if (--argc < 1) goto bad;
			keyfile= *(++argv);
			sign_flag= ++num;
d308 5
a312 6
			}
		else if (strcmp(*argv,"-CA") == 0)
			{
			if (--argc < 1) goto bad;
			CAfile= *(++argv);
			CA_flag= ++num;
d314 11
a324 14
			}
		else if (strcmp(*argv,"-CAkey") == 0)
			{
			if (--argc < 1) goto bad;
			CAkeyfile= *(++argv);
			}
		else if (strcmp(*argv,"-CAserial") == 0)
			{
			if (--argc < 1) goto bad;
			CAserial= *(++argv);
			}
		else if (strcmp(*argv,"-set_serial") == 0)
			{
			if (--argc < 1) goto bad;
d327 4
a330 6
			}
		else if (strcmp(*argv,"-addtrust") == 0)
			{
			if (--argc < 1) goto bad;
			if (!(objtmp = OBJ_txt2obj(*(++argv), 0)))
				{
d332 1
a332 1
					"Invalid trust object value %s\n", *argv);
d334 3
a336 2
				}
			if (!trust) trust = sk_ASN1_OBJECT_new_null();
d339 4
a342 6
			}
		else if (strcmp(*argv,"-addreject") == 0)
			{
			if (--argc < 1) goto bad;
			if (!(objtmp = OBJ_txt2obj(*(++argv), 0)))
				{
d344 1
a344 1
					"Invalid reject object value %s\n", *argv);
d346 3
a348 2
				}
			if (!reject) reject = sk_ASN1_OBJECT_new_null();
d351 4
a354 5
			}
		else if (strcmp(*argv,"-setalias") == 0)
			{
			if (--argc < 1) goto bad;
			alias= *(++argv);
d356 11
a366 11
			}
		else if (strcmp(*argv,"-certopt") == 0)
			{
			if (--argc < 1) goto bad;
			if (!set_cert_ex(&certflag, *(++argv))) goto bad;
			}
		else if (strcmp(*argv,"-nameopt") == 0)
			{
			if (--argc < 1) goto bad;
			if (!set_name_ex(&nmflag, *(++argv))) goto bad;
			}
d368 5
a372 5
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
			engine= *(++argv);
			}
d374 21
a394 21
		else if (strcmp(*argv,"-C") == 0)
			C= ++num;
		else if (strcmp(*argv,"-email") == 0)
			email= ++num;
		else if (strcmp(*argv,"-ocsp_uri") == 0)
			ocsp_uri= ++num;
		else if (strcmp(*argv,"-serial") == 0)
			serial= ++num;
		else if (strcmp(*argv,"-next_serial") == 0)
			next_serial= ++num;
		else if (strcmp(*argv,"-modulus") == 0)
			modulus= ++num;
		else if (strcmp(*argv,"-pubkey") == 0)
			pubkey= ++num;
		else if (strcmp(*argv,"-x509toreq") == 0)
			x509req= ++num;
		else if (strcmp(*argv,"-text") == 0)
			text= ++num;
		else if (strcmp(*argv,"-hash") == 0
			|| strcmp(*argv,"-subject_hash") == 0)
			subject_hash= ++num;
d396 2
a397 2
		else if (strcmp(*argv,"-subject_hash_old") == 0)
			subject_hash_old= ++num;
d399 2
a400 2
		else if (strcmp(*argv,"-issuer_hash") == 0)
			issuer_hash= ++num;
d402 2
a403 2
		else if (strcmp(*argv,"-issuer_hash_old") == 0)
			issuer_hash_old= ++num;
d405 33
a437 36
		else if (strcmp(*argv,"-subject") == 0)
			subject= ++num;
		else if (strcmp(*argv,"-issuer") == 0)
			issuer= ++num;
		else if (strcmp(*argv,"-fingerprint") == 0)
			fingerprint= ++num;
		else if (strcmp(*argv,"-dates") == 0)
			{
			startdate= ++num;
			enddate= ++num;
			}
		else if (strcmp(*argv,"-purpose") == 0)
			pprint= ++num;
		else if (strcmp(*argv,"-startdate") == 0)
			startdate= ++num;
		else if (strcmp(*argv,"-enddate") == 0)
			enddate= ++num;
		else if (strcmp(*argv,"-checkend") == 0)
			{
			if (--argc < 1) goto bad;
			checkoffset=atoi(*(++argv));
			checkend=1;
			}
		else if (strcmp(*argv,"-noout") == 0)
			noout= ++num;
		else if (strcmp(*argv,"-trustout") == 0)
			trustout= 1;
		else if (strcmp(*argv,"-clrtrust") == 0)
			clrtrust= ++num;
		else if (strcmp(*argv,"-clrreject") == 0)
			clrreject= ++num;
		else if (strcmp(*argv,"-alias") == 0)
			aliasout= ++num;
		else if (strcmp(*argv,"-CAcreateserial") == 0)
			CA_createserial= ++num;
		else if (strcmp(*argv,"-clrext") == 0)
d439 4
a442 4
#if 1 /* stay backwards-compatible with 0.9.5; this should go away soon */
		else if (strcmp(*argv,"-crlext") == 0)
			{
			BIO_printf(bio_err,"use -clrext instead of -crlext\n");
d444 1
a444 1
			}
d446 3
a448 4
		else if (strcmp(*argv,"-ocspid") == 0)
			ocspid= ++num;
		else if ((md_alg=EVP_get_digestbyname(*argv + 1)))
			{
d450 4
a453 6
			digest=md_alg;
			}
		else
			{
			BIO_printf(bio_err,"unknown option %s\n",*argv);
			badops=1;
d455 1
a455 1
			}
d458 1
a458 1
		}
d460 1
a460 2
	if (badops)
		{
d462 2
a463 2
		for (pp=x509_usage; (*pp != NULL); pp++)
			BIO_printf(bio_err,"%s",*pp);
d465 1
a465 2
		}

d467 1
a467 1
        e = setup_engine(bio_err, engine, 0);
d475 1
a475 2
	if (!app_passwd(bio_err, passargin, NULL, &passin, NULL))
		{
d478 2
a479 4
		}

	if (!X509_STORE_set_default_paths(ctx))
		{
d482 5
a486 7
		}

	if ((CAkeyfile == NULL) && (CA_flag) && (CAformat == FORMAT_PEM))
		{ CAkeyfile=CAfile; }
	else if ((CA_flag) && (CAkeyfile == NULL))
		{
		BIO_printf(bio_err,"need to specify a CAkey if using the CA command\n");
d488 2
a489 4
		}

	if (extfile)
		{
d493 1
a493 2
		if (!NCONF_load(extconf, extfile,&errorline))
			{
d496 6
a501 6
					"error loading the config file '%s'\n",
								extfile);
                	else
                        	BIO_printf(bio_err,
				       "error on line %ld of config file '%s'\n"
							,errorline,extfile);
d503 2
a504 3
			}
		if (!extsect)
			{
d506 1
a506 2
			if (!extsect)
				{
a508 1
				}
d510 1
d513 1
a513 2
		if (!X509V3_EXT_add_nconf(extconf, &ctx2, extsect, NULL))
			{
d515 2
a516 2
				"Error Loading extension section %s\n",
								 extsect);
a518 1
			}
d520 2
a521 4


	if (reqfile)
		{
d525 2
a526 3
		if (!sign_flag && !CA_flag)
			{
			BIO_printf(bio_err,"We need a private key to sign with\n");
d528 3
a530 4
			}
		in=BIO_new(BIO_s_file());
		if (in == NULL)
			{
d533 1
a533 2
			}

d535 3
a537 5
			BIO_set_fp(in,stdin,BIO_NOCLOSE|BIO_FP_TEXT);
		else
			{
			if (BIO_read_filename(in,infile) <= 0)
				{
a540 1
				}
d542 2
a543 1
		req=PEM_read_bio_X509_REQ(in,NULL,NULL,NULL);
d546 1
a546 2
		if (req == NULL)
			{
d549 11
a559 9
			}

		if (	(req->req_info == NULL) ||
			(req->req_info->pubkey == NULL) ||
			(req->req_info->pubkey->public_key == NULL) ||
			(req->req_info->pubkey->public_key->data == NULL))
			{
			BIO_printf(bio_err,"The certificate request appears to corrupted\n");
			BIO_printf(bio_err,"It does not contain a public key\n");
d561 2
a562 7
			}
		if ((pkey=X509_REQ_get_pubkey(req)) == NULL)
	                {
	                BIO_printf(bio_err,"error unpacking public key\n");
	                goto end;
	                }
		i=X509_REQ_verify(req,pkey);
d564 2
a565 3
		if (i < 0)
			{
			BIO_printf(bio_err,"Signature verification error\n");
d568 3
a570 4
			}
	        if (i == 0)
			{
			BIO_printf(bio_err,"Signature did not match the certificate request\n");
d572 2
a573 3
			}
		else
			BIO_printf(bio_err,"Signature ok\n");
d577 2
a578 1
		if ((x=X509_new()) == NULL) goto end;
d580 1
a580 2
		if (sno == NULL)
			{
d584 1
a584 1
			if (!X509_set_serialNumber(x, sno)) 
d588 1
a588 2
			}
		else if (!X509_set_serialNumber(x, sno)) 
d591 4
a594 2
		if (!X509_set_issuer_name(x,req->req_info->subject)) goto end;
		if (!X509_set_subject_name(x,req->req_info->subject)) goto end;
d596 2
a597 2
		X509_gmtime_adj(X509_get_notBefore(x),0);
	        X509_time_adj_ex(X509_get_notAfter(x),days, 0, NULL);
d600 1
a600 1
		X509_set_pubkey(x,pkey);
d602 2
a603 3
		}
	else
		x=load_cert(bio_err,infile,informat,NULL,e,"Certificate");
d605 8
a612 9
	if (x == NULL) goto end;
	if (CA_flag)
		{
		xca=load_cert(bio_err,CAfile,CAformat,NULL,e,"CA Certificate");
		if (xca == NULL) goto end;
		}

	if (!noout || text || next_serial)
		{
d614 1
a614 1
			"SET.ex3","SET x509v3 extension 3");
d616 2
a617 3
		out=BIO_new(BIO_s_file());
		if (out == NULL)
			{
d620 5
a624 9
			}
		if (outfile == NULL)
			{
			BIO_set_fp(out,stdout,BIO_NOCLOSE);
			}
		else
			{
			if (BIO_write_filename(out,outfile) <= 0)
				{
a626 1
				}
d629 3
d633 4
a636 1
	if (alias) X509_alias_set1(x, (unsigned char *)alias, -1);
d638 2
a639 7
	if (clrtrust) X509_trust_clear(x);
	if (clrreject) X509_reject_clear(x);

	if (trust)
		{
		for (i = 0; i < sk_ASN1_OBJECT_num(trust); i++)
			{
a641 1
			}
d643 3
a645 5

	if (reject)
		{
		for (i = 0; i < sk_ASN1_OBJECT_num(reject); i++)
			{
a647 1
			}
d649 4
a652 7

	if (num)
		{
		for (i=1; i<=num; i++)
			{
			if (issuer == i)
				{
d654 2
a655 4
					X509_get_issuer_name(x), nmflag);
				}
			else if (subject == i) 
				{
d657 3
a659 5
					X509_get_subject_name(x), nmflag);
				}
			else if (serial == i)
				{
				BIO_printf(STDout,"serial=");
d661 3
a663 5
					X509_get_serialNumber(x));
				BIO_printf(STDout,"\n");
				}
			else if (next_serial == i)
				{
d679 1
a679 3
				}
			else if ((email == i) || (ocsp_uri == i))
				{
d681 1
a681 1
				STACK_OF(OPENSSL_STRING) *emlst;
d688 1
a688 1
						   sk_OPENSSL_STRING_value(emlst, j));
d690 1
a690 3
				}
			else if (aliasout == i)
				{
d693 7
a699 7
				if (alstr) BIO_printf(STDout,"%s\n", alstr);
				else BIO_puts(STDout,"<No Alias>\n");
				}
			else if (subject_hash == i)
				{
				BIO_printf(STDout,"%08lx\n",X509_subject_name_hash(x));
				}
d701 3
a703 4
			else if (subject_hash_old == i)
				{
				BIO_printf(STDout,"%08lx\n",X509_subject_name_hash_old(x));
				}
d705 3
a707 4
			else if (issuer_hash == i)
				{
				BIO_printf(STDout,"%08lx\n",X509_issuer_name_hash(x));
				}
d709 3
a711 4
			else if (issuer_hash_old == i)
				{
				BIO_printf(STDout,"%08lx\n",X509_issuer_name_hash_old(x));
				}
d713 1
a713 2
			else if (pprint == i)
				{
d717 1
a717 2
				for (j = 0; j < X509_PURPOSE_get_count(); j++)
					{
a719 1
					}
d721 1
a721 3
			else
				if (modulus == i)
				{
d724 3
a726 4
				pkey=X509_get_pubkey(x);
				if (pkey == NULL)
					{
					BIO_printf(bio_err,"Modulus=unavailable\n");
d729 2
a730 2
					}
				BIO_printf(STDout,"Modulus=");
d733 1
a733 1
					BN_print(STDout,pkey->pkey.rsa->n);
d738 1
a738 1
					BN_print(STDout,pkey->pkey.dsa->pub_key);
d741 2
a742 2
					BIO_printf(STDout,"Wrong Algorithm type");
				BIO_printf(STDout,"\n");
d744 1
a744 4
				}
			else
				if (pubkey == i)
				{
d747 3
a749 4
				pkey=X509_get_pubkey(x);
				if (pkey == NULL)
					{
					BIO_printf(bio_err,"Error getting public key\n");
d752 1
a752 1
					}
d755 1
a755 4
				}
			else
				if (C == i)
				{
d758 1
a758 1
				int y,z;
d761 16
a776 28
					buf,sizeof buf);
				BIO_printf(STDout,"/* subject:%s */\n",buf);
				m=X509_NAME_oneline(
					X509_get_issuer_name(x),buf,
					sizeof buf);
				BIO_printf(STDout,"/* issuer :%s */\n",buf);

				z=i2d_X509(x,NULL);
				m=malloc(z);

				d=(unsigned char *)m;
				z=i2d_X509_NAME(X509_get_subject_name(x),&d);
				BIO_printf(STDout,"unsigned char XXX_subject_name[%d]={\n",z);
				d=(unsigned char *)m;
				for (y=0; y<z; y++)
					{
					BIO_printf(STDout,"0x%02X,",d[y]);
					if ((y & 0x0f) == 0x0f) BIO_printf(STDout,"\n");
					}
				if (y%16 != 0) BIO_printf(STDout,"\n");
				BIO_printf(STDout,"};\n");

				z=i2d_X509_PUBKEY(X509_get_X509_PUBKEY(x),&d);
				BIO_printf(STDout,"unsigned char XXX_public_key[%d]={\n",z);
				d=(unsigned char *)m;
				for (y=0; y<z; y++)
					{
					BIO_printf(STDout,"0x%02X,",d[y]);
d778 23
a800 11
						BIO_printf(STDout,"\n");
					}
				if (y%16 != 0) BIO_printf(STDout,"\n");
				BIO_printf(STDout,"};\n");

				z=i2d_X509(x,&d);
				BIO_printf(STDout,"unsigned char XXX_certificate[%d]={\n",z);
				d=(unsigned char *)m;
				for (y=0; y<z; y++)
					{
					BIO_printf(STDout,"0x%02X,",d[y]);
d802 5
a806 4
						BIO_printf(STDout,"\n");
					}
				if (y%16 != 0) BIO_printf(STDout,"\n");
				BIO_printf(STDout,"};\n");
d809 11
a819 19
				}
			else if (text == i)
				{
				X509_print_ex(STDout,x,nmflag, certflag);
				}
			else if (startdate == i)
				{
				BIO_puts(STDout,"notBefore=");
				ASN1_TIME_print(STDout,X509_get_notBefore(x));
				BIO_puts(STDout,"\n");
				}
			else if (enddate == i)
				{
				BIO_puts(STDout,"notAfter=");
				ASN1_TIME_print(STDout,X509_get_notAfter(x));
				BIO_puts(STDout,"\n");
				}
			else if (fingerprint == i)
				{
d828 2
a829 3
				if (!X509_digest(x,fdig,md,&n))
					{
					BIO_printf(bio_err,"out of memory\n");
a830 9
					}
				BIO_printf(STDout,"%s Fingerprint=",
						OBJ_nid2sn(EVP_MD_type(fdig)));
				for (j=0; j<(int)n; j++)
					{
					BIO_printf(STDout,"%02X%c",md[j],
						(j+1 == (int)n)
						?'\n':':');
					}
d832 8
a839 1

d841 9
a849 11
			else if ((sign_flag == i) && (x509req == 0))
				{
				BIO_printf(bio_err,"Getting Private key\n");
				if (Upkey == NULL)
					{
					Upkey=load_key(bio_err,
						keyfile, keyformat, 0,
						passin, e, "Private key");
					if (Upkey == NULL) goto end;
					}

d851 12
a862 2
				if (!sign(x,Upkey,days,clrext,digest,
						 extconf, extsect)) goto end;
a863 12
			else if (CA_flag == i)
				{
				BIO_printf(bio_err,"Getting CA Private Key\n");
				if (CAkeyfile != NULL)
					{
					CApkey=load_key(bio_err,
						CAkeyfile, CAkeyformat,
						0, passin, e,
						"CA Private Key");
					if (CApkey == NULL) goto end;
					}
				
d865 1
a865 1
				if (!x509_certify(ctx,CAfile,digest,x,xca,
d867 1
a867 1
					CAserial,CA_createserial,days, clrext,
d870 1
a870 3
				}
			else if (x509req == i)
				{
d873 3
a875 4
				BIO_printf(bio_err,"Getting request Private Key\n");
				if (keyfile == NULL)
					{
					BIO_printf(bio_err,"no request key file specified\n");
d877 7
a883 8
					}
				else
					{
					pk=load_key(bio_err,
						keyfile, keyformat, 0,
						passin, e, "request key");
					if (pk == NULL) goto end;
					}
d885 1
a885 1
				BIO_printf(bio_err,"Generating certificate request\n");
d887 1
a887 1
				rq=X509_to_X509_REQ(x,pk,digest);
d889 1
a889 2
				if (rq == NULL)
					{
a891 7
					}
				if (!noout)
					{
					X509_REQ_print(out,rq);
					PEM_write_bio_X509_REQ(out,rq);
					}
				noout=1;
d893 6
a898 2
			else if (ocspid == i)
				{
a899 1
				}
d902 3
d906 7
a912 14
	if (checkend)
		{
		time_t tcheck=time(NULL) + checkoffset;

		if (X509_cmp_time(X509_get_notAfter(x), &tcheck) < 0)
			{
			BIO_printf(out,"Certificate will expire\n");
			ret=1;
			}
		else
			{
			BIO_printf(out,"Certificate will not expire\n");
			ret=0;
			}
d914 3
a916 5
		}

	if (noout)
		{
		ret=0;
d918 9
a926 11
		}

	if 	(outformat == FORMAT_ASN1)
		i=i2d_X509_bio(out,x);
	else if (outformat == FORMAT_PEM)
		{
		if (trustout) i=PEM_write_bio_X509_AUX(out,x);
		else i=PEM_write_bio_X509(out,x);
		}
	else if (outformat == FORMAT_NETSCAPE)
		{
d930 8
a937 9
		hdr.data=(unsigned char *)NETSCAPE_CERT_HDR;
		hdr.length=strlen(NETSCAPE_CERT_HDR);
		nx.header= &hdr;
		nx.cert=x;

		i=ASN1_item_i2d_bio(ASN1_ITEM_rptr(NETSCAPE_X509),out,&nx);
		}
	else	{
		BIO_printf(bio_err,"bad output format specified for outfile\n");
d939 3
a941 4
		}
	if (!i)
		{
		BIO_printf(bio_err,"unable to write certificate\n");
d944 2
a945 2
		}
	ret=0;
d965 2
a966 1
	if (passin) free(passin);
d968 2
a969 2
	return(ret);
	}
d971 3
a973 2
static ASN1_INTEGER *x509_load_serial(char *CAfile, char *serialfile, int create)
	{
d980 12
a991 11
		?(strlen(CAfile)+strlen(POSTFIX)+1)
		:(strlen(serialfile)))+1;
	buf=malloc(len);
	if (buf == NULL) { BIO_printf(bio_err,"out of mem\n"); goto end; }
	if (serialfile == NULL)
		{
		BUF_strlcpy(buf,CAfile,len);
		for (p=buf; *p; p++)
			if (*p == '.')
				{
				*p='\0';
d993 4
a996 5
				}
		BUF_strlcat(buf,POSTFIX,len);
		}
	else
		BUF_strlcpy(buf,serialfile,len);
d999 2
a1000 1
	if (serial == NULL) goto end;
d1002 6
a1007 2
	if (!BN_add_word(serial,1))
		{ BIO_printf(bio_err,"add_word failure\n"); goto end; }
d1009 3
a1011 4
	if (!save_serial(buf, NULL, serial, &bs)) goto end;

 end:
	if (buf) free(buf);
d1014 1
a1014 1
	}
d1016 10
a1025 9
static int x509_certify(X509_STORE *ctx, char *CAfile, const EVP_MD *digest,
	     		X509 *x, X509 *xca, EVP_PKEY *pkey,
			STACK_OF(OPENSSL_STRING) *sigopts,
	  		char *serialfile, int create,
	     		int days, int clrext, CONF *conf, char *section,
			ASN1_INTEGER *sno)
	{
	int ret=0;
	ASN1_INTEGER *bs=NULL;
d1030 1
a1030 1
	EVP_PKEY_copy_parameters(upkey,pkey);
d1033 2
a1034 3
	if(!X509_STORE_CTX_init(&xsc,ctx,x,NULL))
		{
		BIO_printf(bio_err,"Error initialising X509 store\n");
d1036 3
a1038 2
		}
	if (sno) bs = sno;
d1044 5
a1048 3
	/* NOTE: this certificate can/should be self signed, unless it was
	 * a certificate request in which case it is not. */
	X509_STORE_CTX_set_cert(&xsc,x);
d1053 7
a1059 3
	if (!X509_check_private_key(xca,pkey))
		{
		BIO_printf(bio_err,"CA certificate and CA private key do not match\n");
a1060 4
		}

	if (!X509_set_issuer_name(x,X509_get_subject_name(xca))) goto end;
	if (!X509_set_serialNumber(x,bs)) goto end;
d1062 1
a1062 1
	if (X509_gmtime_adj(X509_get_notBefore(x),0L) == NULL)
d1066 1
a1066 1
	if (X509_time_adj_ex(X509_get_notAfter(x),days, 0, NULL) == NULL)
d1069 5
a1073 7
	if (clrext)
		{
		while (X509_get_ext_count(x) > 0) X509_delete_ext(x, 0);
		}

	if (conf)
		{
d1075 6
a1080 6
		X509_set_version(x,2); /* version 3 certificate */
                X509V3_set_ctx(&ctx2, xca, x, NULL, NULL, 0);
                X509V3_set_nconf(&ctx2, conf);
                if (!X509V3_EXT_add_nconf(conf, &ctx2, section, x)) goto end;
		}

d1083 1
a1083 1
	ret=1;
d1088 2
a1089 1
	if (!sno) ASN1_INTEGER_free(bs);
d1091 1
a1091 1
	}
d1093 3
a1095 2
static int callb(int ok, X509_STORE_CTX *ctx)
	{
d1099 6
a1104 4
	/* it is ok to use a self signed certificate
	 * This case will catch both the initial ok == 0 and the
	 * final ok == 1 calls to this function */
	err=X509_STORE_CTX_get_error(ctx);
d1108 7
a1114 6
	/* BAD we should have gotten an error.  Normally if everything
	 * worked X509_STORE_CTX_get_error(ctx) will still be set to
	 * DEPTH_ZERO_SELF_.... */
	if (ok)
		{
		BIO_printf(bio_err,"error with certificate to be certified - should be self signed\n");
d1116 6
a1121 8
		}
	else
		{
		err_cert=X509_STORE_CTX_get_current_cert(ctx);
		print_name(bio_err, NULL, X509_get_subject_name(err_cert),0);
		BIO_printf(bio_err,"error with certificate - error %d at depth %d\n%s\n",
			err,X509_STORE_CTX_get_error_depth(ctx),
			X509_verify_cert_error_string(err));
a1122 1
		}
d1124 1
d1127 4
a1130 3
static int sign(X509 *x, EVP_PKEY *pkey, int days, int clrext, const EVP_MD *digest, 
						CONF *conf, char *section)
	{
d1135 2
a1136 2
	EVP_PKEY_copy_parameters(pktmp,pkey);
	EVP_PKEY_save_parameters(pktmp,1);
d1139 4
a1142 2
	if (!X509_set_issuer_name(x,X509_get_subject_name(x))) goto err;
	if (X509_gmtime_adj(X509_get_notBefore(x),0) == NULL) goto err;
d1148 1
a1148 1
	if (X509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days) == NULL)
d1151 7
a1157 7
	if (!X509_set_pubkey(x,pkey)) goto err;
	if (clrext)
		{
		while (X509_get_ext_count(x) > 0) X509_delete_ext(x, 0);
		}
	if (conf)
		{
d1159 8
a1166 6
		X509_set_version(x,2); /* version 3 certificate */
                X509V3_set_ctx(&ctx, x, x, NULL, NULL, 0);
                X509V3_set_nconf(&ctx, conf);
                if (!X509V3_EXT_add_nconf(conf, &ctx, section, x)) goto err;
		}
	if (!X509_sign(x,pkey,digest)) goto err;
d1171 1
a1171 1
	}
d1173 2
a1174 1
static int purpose_print(BIO *bio, X509 *cert, X509_PURPOSE *pt)
d1180 1
a1180 2
	for (i = 0; i < 2; i++)
		{
d1182 8
a1189 5
		BIO_printf(bio, "%s%s : ", pname, i ? " CA" : ""); 
		if (idret == 1) BIO_printf(bio, "Yes\n");
		else if (idret == 0) BIO_printf(bio, "No\n");
		else BIO_printf(bio, "Yes (WARNING code=%d)\n", idret);
		}
@


1.28
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d1092 1
a1092 1
	OPENSSL_EXIT(ret);
@


1.27
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d861 1
a861 1
				m=OPENSSL_malloc(z);
d899 1
a899 1
				OPENSSL_free(m);
d1090 1
a1090 1
	if (passin) OPENSSL_free(passin);
d1105 1
a1105 1
	buf=OPENSSL_malloc(len);
d1130 1
a1130 1
	if (buf) OPENSSL_free(buf);
@


1.26
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@a223 6
#ifdef OPENSSL_SYS_VMS
	{
	BIO *tmpbio = BIO_new(BIO_f_linebuffer());
	STDout = BIO_push(tmpbio, STDout);
	}
#endif
a678 6
#ifdef OPENSSL_SYS_VMS
			{
			BIO *tmpbio = BIO_new(BIO_f_linebuffer());
			out = BIO_push(tmpbio, out);
			}
#endif
@


1.25
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d156 1
a156 1
static int MS_CALLBACK callb(int ok, X509_STORE_CTX *ctx);
d1222 1
a1222 1
static int MS_CALLBACK callb(int ok, X509_STORE_CTX *ctx)
@


1.24
log
@resolve conflicts
@
text
@d291 1
a291 1
				BIO_printf(STDout,"bad number of days\n");
d915 1
a915 1
				X509_print_ex(out,x,nmflag, certflag);
@


1.23
log
@OpenSSL 1.0.0f: merge
@
text
@d160 4
a163 3
			 X509 *x,X509 *xca,EVP_PKEY *pkey,char *serial,
			 int create,int days, int clrext, CONF *conf, char *section,
						ASN1_INTEGER *sno);
d176 1
d276 9
d984 2
a985 1
					CApkey, CAserial,CA_createserial,days, clrext,
d1096 2
d1148 5
a1152 2
	     X509 *x, X509 *xca, EVP_PKEY *pkey, char *serialfile, int create,
	     int days, int clrext, CONF *conf, char *section, ASN1_INTEGER *sno)
d1211 2
a1212 1
	if (!X509_sign(x,pkey,digest)) goto end;
@


1.22
log
@openssl-1.0.0e: resolve conflicts
@
text
@d990 1
a990 1
						keyfile, FORMAT_PEM, 0,
@


1.21
log
@resolve conflicts, fix local changes
@
text
@a558 1
		X509_CINF *ci;
a625 1
		ci=x->cert_info;
@


1.20
log
@resolve conflicts
@
text
@d102 3
d106 3
d188 3
d202 1
a202 1
	const EVP_MD *md_alg,*digest=EVP_sha1();
d237 1
a237 1
	X509_STORE_set_verify_cb_func(ctx,callb);
d409 4
d415 4
d646 1
a646 1
	        X509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days);
d758 1
a758 1
				STACK *emlst;
d763 3
a765 2
				for (j = 0; j < sk_num(emlst); j++)
					BIO_printf(STDout, "%s\n", sk_value(emlst, j));
d779 6
d789 6
d925 1
d927 4
a930 1
				if (!X509_digest(x,digest,md,&n))
d936 1
a936 1
						OBJ_nid2sn(EVP_MD_type(digest)));
a955 8
#ifndef OPENSSL_NO_DSA
		                if (Upkey->type == EVP_PKEY_DSA)
		                        digest=EVP_dss1();
#endif
#ifndef OPENSSL_NO_ECDSA
				if (Upkey->type == EVP_PKEY_EC)
					digest=EVP_ecdsa();
#endif
a971 8
#ifndef OPENSSL_NO_DSA
		                if (CApkey->type == EVP_PKEY_DSA)
		                        digest=EVP_dss1();
#endif
#ifndef OPENSSL_NO_ECDSA
				if (CApkey->type == EVP_PKEY_EC)
					digest = EVP_ecdsa();
#endif
a998 9
#ifndef OPENSSL_NO_DSA
		                if (pk->type == EVP_PKEY_DSA)
		                        digest=EVP_dss1();
#endif
#ifndef OPENSSL_NO_ECDSA
				if (pk->type == EVP_PKEY_EC)
					digest=EVP_ecdsa();
#endif

d1052 2
a1053 2
		ASN1_HEADER ah;
		ASN1_OCTET_STRING os;
d1055 4
a1058 5
		os.data=(unsigned char *)NETSCAPE_CERT_HDR;
		os.length=strlen(NETSCAPE_CERT_HDR);
		ah.header= &os;
		ah.data=(char *)x;
		ah.meth=X509_asn1_meth();
d1060 1
a1060 1
		i=ASN1_i2d_bio_of(ASN1_HEADER,i2d_ASN1_HEADER,out,&ah);
d1162 1
d1179 1
a1179 1
	if (X509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days) == NULL)
@


1.19
log
@resolve conflicts
@
text
@d117 1
a117 1
" -ocspurl        - print OCSP Responder URL(s)\n",
@


1.18
log
@resolve conflicts
@
text
@d1154 1
a1154 1
	if (!reqfile && !X509_verify_cert(&xsc))
@


1.17
log
@resolve conflicts
@
text
@d76 6
d90 1
a90 1
static char *x509_usage[]={
d101 3
a103 1
" -hash           - print hash value\n",
d117 1
d179 3
a181 2
	int text=0,serial=0,hash=0,subject=0,issuer=0,startdate=0,enddate=0;
	int next_serial=0,ocspid=0;
d183 1
d188 1
a188 1
	char **pp;
d193 1
a193 1
	const EVP_MD *md_alg,*digest;
a229 7
#ifdef  OPENSSL_FIPS
	if (FIPS_mode())
		digest = EVP_sha1();
	else
#endif
		digest = EVP_md5();

d383 2
d397 5
a401 2
		else if (strcmp(*argv,"-hash") == 0)
			hash= ++num;
d716 2
a717 1
				i2a_ASN1_INTEGER(STDout,x->cert_info->serialNumber);
d738 1
a738 1
			else if (email == i) 
d742 4
a745 1
				emlst = X509_get1_email(x);
d757 1
a757 1
			else if (hash == i)
d761 4
d926 4
d950 4
d985 4
d1052 1
a1052 2
		/* no macro for this one yet */
		i=ASN1_i2d_bio(i2d_ASN1_HEADER,out,(unsigned char *)&ah);
@


1.17.12.1
log
@Fix CVE-2008-5077: Incorrect checks for malformed signatures
@
text
@d1126 1
a1126 1
	if (!reqfile && X509_verify_cert(&xsc) <= 0)
@


1.17.14.1
log
@Fix CVE-2008-5077: Incorrect checks for malformed signatures
@
text
@d1126 1
a1126 1
	if (!reqfile && X509_verify_cert(&xsc) <= 0)
@


1.16
log
@merge 0.9.7d
@
text
@d171 1
a171 1
	int ocspid=0;
d182 1
a182 1
	const EVP_MD *md_alg,*digest=EVP_md5();
d219 7
d381 2
d603 1
a603 1
		if (sno)
d605 4
a608 1
			if (!X509_set_serialNumber(x, sno))
d610 2
d613 3
a615 1
		else if (!ASN1_INTEGER_set(X509_get_serialNumber(x),0)) goto end;
d636 1
a636 1
	if (!noout || text)
d710 18
d984 1
a984 1
		time_t tnow=time(NULL);
d986 1
a986 1
		if (ASN1_UTCTIME_cmp_time_t(X509_get_notAfter(x), tnow+checkoffset) == -1)
a1083 7
	serial=BN_new();
	bs=ASN1_INTEGER_new();
	if ((serial == NULL) || (bs == NULL))
		{
		ERR_print_errors(bio_err);
		goto end;
		}
@


1.15
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d1025 1
a1025 1
static ASN1_INTEGER *load_serial(char *CAfile, char *serialfile, int create)
d1028 1
a1028 3
	MS_STATIC char buf2[1024];
	ASN1_INTEGER *bs = NULL, *bs2 = NULL;
	BIO *io = NULL;
d1039 1
a1039 1
		strlcpy(buf,CAfile,len);
d1046 1
a1046 1
		strlcat(buf,POSTFIX,len);
d1049 1
a1049 1
		strlcpy(buf,serialfile,len);
d1058 2
a1059 38
	io=BIO_new(BIO_s_file());
	if (io == NULL)
		{
		ERR_print_errors(bio_err);
		goto end;
		}
	
	if (BIO_read_filename(io,buf) <= 0)
		{
		if (!create)
			{
			perror(buf);
			goto end;
			}
		else
			{
			ASN1_INTEGER_set(bs,1);
			BN_one(serial);
			}
		}
	else 
		{
		if (!a2i_ASN1_INTEGER(io,bs,buf2,sizeof buf2))
			{
			BIO_printf(bio_err,"unable to load serial number from %s\n",buf);
			ERR_print_errors(bio_err);
			goto end;
			}
		else
			{
			serial=BN_bin2bn(bs->data,bs->length,serial);
			if (serial == NULL)
				{
				BIO_printf(bio_err,"error converting bin 2 bn");
				goto end;
				}
			}
		}
a1062 10
	if (!(bs2 = BN_to_ASN1_INTEGER(serial, NULL)))
		{ BIO_printf(bio_err,"error converting bn 2 asn1_integer\n"); goto end; }
	if (BIO_write_filename(io,buf) <= 0)
		{
		BIO_printf(bio_err,"error attempting to write serial number file\n");
		perror(buf);
		goto end;
		}
	i2a_ASN1_INTEGER(io,bs2);
	BIO_puts(io,"\n");
d1064 3
a1066 1
	BIO_free(io);
a1067 1
	ASN1_INTEGER_free(bs2);
a1068 1
	io=NULL;
a1069 8

	end:
	if (buf) OPENSSL_free(buf);
	BIO_free(io);
	ASN1_INTEGER_free(bs);
	BN_free(serial);
	return NULL;

d1091 1
a1091 1
	else if (!(bs = load_serial(CAfile, serialfile, create)))
@


1.14
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d1150 1
a1150 1
	if (!X509_STORE_add_cert(ctx,x)) goto end;
@


1.13
log
@oops
@
text
@d125 1
a125 1
" -CAserial       - serial file\n",
d134 1
d136 1
d188 1
d190 1
d361 1
a361 6
		else if (strcmp(*argv,"-setalias") == 0)
			{
			if (--argc < 1) goto bad;
			alias= *(++argv);
			trustout = 1;
			}
d367 1
d453 1
d455 1
d484 1
a484 1
		long errorline;
d775 1
a775 1
					buf,256);
d778 2
a779 1
					X509_get_issuer_name(x),buf,256);
d1022 1
a1022 1
	EXIT(ret);
d1082 1
a1082 1
		if (!a2i_ASN1_INTEGER(io,bs,buf2,1024))
@


1.12
log
@incorrect bounds limit; spotted by ho
@
text
@d1033 1
a1033 1
		:(strlen(serialfile)))+1);
@


1.11
log
@more strcpy & sprintf murder; ho ok
@
text
@d1029 1
d1031 4
a1034 3
	buf=OPENSSL_malloc( ((serialfile == NULL)
			?(strlen(CAfile)+strlen(POSTFIX)+1)
			:(strlen(serialfile)))+1);
d1038 1
a1038 1
		strlcpy(buf,CAfile,sizeof buf);
d1045 1
a1045 1
		strcat(buf,POSTFIX);
d1048 1
a1048 1
		strlcpy(buf,serialfile,sizeof buf);
@


1.10
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d1036 1
a1036 1
		strcpy(buf,CAfile);
d1046 1
a1046 1
		strcpy(buf,serialfile);
@


1.9
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d864 2
a865 2
						keyfile,keyformat, passin, e,
						"Private key");
d883 3
a885 2
						CAkeyfile,CAkeyformat, passin,
						e, "CA Private Key");
d912 2
a913 2
						keyfile,FORMAT_PEM, passin, e,
						"request key");
@


1.8
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d918 1
d921 1
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d248 1
a248 1
			CAformat=str2fmt(*(++argv));
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d63 1
a63 1
#ifdef NO_STDIO
a75 1
#include <openssl/engine.h>
d108 1
d126 1
d135 1
d141 1
a141 1
						LHASH *conf, char *section);
d144 2
a145 1
			 int create,int days, int clrext, LHASH *conf, char *section);
d159 1
d169 1
d181 1
a181 1
	LHASH *extconf = NULL;
d185 1
a185 1
	unsigned long nmflag = 0;
d194 3
d198 1
a198 1
#ifdef VMS
d309 6
d347 5
d428 2
d449 1
a449 1
			BIO_printf(bio_err,*pp);
d453 1
a453 17
	if (engine != NULL)
		{
		if((e = ENGINE_by_id(engine)) == NULL)
			{
			BIO_printf(bio_err,"invalid engine \"%s\"\n",
				engine);
			goto end;
			}
		if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
			{
			BIO_printf(bio_err,"can't use that engine\n");
			goto end;
			}
		BIO_printf(bio_err,"engine \"%s\" set.\n", engine);
		/* Free our "structural" reference. */
		ENGINE_free(e);
		}
d484 2
a485 1
		if (!(extconf=CONF_load(NULL,extfile,&errorline)))
d497 9
a505 2
		if (!extsect && !(extsect = CONF_get_string(extconf, "default",
					 "extensions"))) extsect = "default";
d507 2
a508 2
		X509V3_set_conf_lhash(&ctx2, extconf);
		if (!X509V3_EXT_add_conf(extconf, &ctx2, extsect, NULL))
d592 6
a597 1
		if (!ASN1_INTEGER_set(X509_get_serialNumber(x),0)) goto end;
d609 1
a609 1
		x=load_cert(bio_err,infile,informat);
d614 1
a614 1
		xca=load_cert(bio_err,CAfile,CAformat);
d632 1
a632 1
#ifdef VMS
d736 1
a736 1
#ifndef NO_RSA
d741 1
a741 1
#ifndef NO_DSA
d822 1
a822 1
				X509_print(out,x);
d864 2
a865 1
						keyfile,keyformat, passin);
d868 1
a868 1
#ifndef NO_DSA
d883 2
a884 1
						CAkeyfile,CAkeyformat, passin);
d887 1
a887 1
#ifndef NO_DSA
d895 1
a895 1
					extconf, extsect))
d911 2
a912 1
						keyfile,FORMAT_PEM, passin);
a917 1
#ifndef NO_DSA
a919 1
#endif
d935 4
d1001 1
a1001 1
	CONF_free(extconf);
d1011 1
d1015 1
d1019 1
a1019 3
static int x509_certify(X509_STORE *ctx, char *CAfile, const EVP_MD *digest,
	     X509 *x, X509 *xca, EVP_PKEY *pkey, char *serialfile, int create,
	     int days, int clrext, LHASH *conf, char *section)
d1021 1
a1021 2
	int ret=0;
	BIO *io=NULL;
d1023 3
a1025 5
	char *buf=NULL,*p;
	BIGNUM *serial=NULL;
	ASN1_INTEGER *bs=NULL,bs2;
	X509_STORE_CTX xsc;
	EVP_PKEY *upkey;
d1027 1
a1027 7
	upkey = X509_get_pubkey(xca);
	EVP_PKEY_copy_parameters(upkey,pkey);
	EVP_PKEY_free(upkey);

	X509_STORE_CTX_init(&xsc,ctx,x,NULL);
	buf=OPENSSL_malloc(EVP_PKEY_size(pkey)*2+
		((serialfile == NULL)
d1093 2
a1094 3
	bs2.data=(unsigned char *)buf2;
	bs2.length=BN_bn2bin(serial,bs2.data);

d1101 1
a1101 1
	i2a_ASN1_INTEGER(io,&bs2);
d1103 1
d1105 3
d1109 33
a1141 1
	
d1176 2
a1177 2
                X509V3_set_conf_lhash(&ctx2, conf);
                if (!X509V3_EXT_add_conf(conf, &ctx2, section, x)) goto end;
d1186 1
a1186 4
	if (buf != NULL) OPENSSL_free(buf);
	if (bs != NULL) ASN1_INTEGER_free(bs);
	if (io != NULL)	BIO_free(io);
	if (serial != NULL) BN_free(serial);
d1223 1
a1223 1
						LHASH *conf, char *section)
d1253 2
a1254 2
                X509V3_set_conf_lhash(&ctx, conf);
                if (!X509V3_EXT_add_conf(conf, &ctx, section, x)) goto err;
a1278 3



@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d897 1
d900 1
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d76 1
a84 2
#define CERT_HDR	"certificate"

d99 1
d116 2
d132 2
a137 2
static EVP_PKEY *load_key(char *file, int format, char *passin);
static X509 *load_cert(char *file, int format);
d150 1
d165 1
a165 1
	int noout=0,sign_flag=0,CA_flag=0,CA_createserial=0;
d179 3
d190 6
d304 2
a305 1
			if(!(objtmp = OBJ_txt2obj(*(++argv), 0))) {
d309 2
a310 2
			}
			if(!trust) trust = sk_ASN1_OBJECT_new_null();
d317 2
a318 1
			if(!(objtmp = OBJ_txt2obj(*(++argv), 0))) {
d322 2
a323 2
			}
			if(!reject) reject = sk_ASN1_OBJECT_new_null();
d333 5
d344 5
d351 2
d382 6
d432 18
d455 2
a456 1
	if(!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
d459 1
a459 1
	}
d475 2
a476 1
	if (extfile) {
d479 2
a480 1
		if (!(extconf=CONF_load(NULL,extfile,&errorline))) {
d490 2
a491 2
		}
		if(!extsect && !(extsect = CONF_get_string(extconf, "default",
d495 2
a496 1
		if(!X509V3_EXT_add_conf(extconf, &ctx2, extsect, NULL)) {
d502 2
a503 2
                }
	} 
d531 1
d538 5
a542 1
		if (req == NULL) { perror(infile); goto end; }
d573 2
a574 3
		
		X509_NAME_oneline(req->req_info->subject,buf,256);
		BIO_printf(bio_err,"subject=%s\n",buf);
d591 1
a591 1
		x=load_cert(infile,informat);
d596 1
a596 1
		xca=load_cert(CAfile,CAformat);
d612 1
d614 7
d631 1
a631 1
	if(alias) X509_alias_set1(x, (unsigned char *)alias, -1);
d633 2
a634 2
	if(clrtrust) X509_trust_clear(x);
	if(clrreject) X509_reject_clear(x);
d636 4
a639 2
	if(trust) {
		for(i = 0; i < sk_ASN1_OBJECT_num(trust); i++) {
d642 1
a643 1
	}
d645 4
a648 2
	if(reject) {
		for(i = 0; i < sk_ASN1_OBJECT_num(reject); i++) {
d651 1
a652 1
	}
d660 2
a661 3
				X509_NAME_oneline(X509_get_issuer_name(x),
					buf,256);
				BIO_printf(STDout,"issuer= %s\n",buf);
d665 2
a666 3
				X509_NAME_oneline(X509_get_subject_name(x),
					buf,256);
				BIO_printf(STDout,"subject=%s\n",buf);
d674 9
d687 1
a687 1
				if(alstr) BIO_printf(STDout,"%s\n", alstr);
d699 1
a699 1
				for(j = 0; j < X509_PURPOSE_get_count(); j++)
d762 1
a762 1
				m=Malloc(z);
d800 1
a800 1
				Free(m);
d845 2
a846 1
					Upkey=load_key(keyfile,keyformat, passin);
d863 2
a864 1
					CApkey=load_key(CAkeyfile,CAkeyformat, passin);
d890 2
a891 1
					pk=load_key(keyfile,FORMAT_PEM, passin);
d917 17
d942 3
a944 2
	else if (outformat == FORMAT_PEM) {
		if(trustout) i=PEM_write_bio_X509_AUX(out,x);
d946 2
a947 1
	} else if (outformat == FORMAT_NETSCAPE)
d952 2
a953 2
		os.data=(unsigned char *)CERT_HDR;
		os.length=strlen(CERT_HDR);
d965 2
a966 1
	if (!i) {
d977 2
a978 2
	BIO_free(out);
	BIO_free(STDout);
d988 1
a988 1
	if(passin) Free(passin);
d1010 1
a1010 1
	buf=Malloc(EVP_PKEY_size(pkey)*2+
d1115 4
a1118 3
	if(clrext) {
		while(X509_get_ext_count(x) > 0) X509_delete_ext(x, 0);
	}
d1120 2
a1121 1
	if(conf) {
d1126 2
a1127 2
                if(!X509V3_EXT_add_conf(conf, &ctx2, section, x)) goto end;
	}
d1135 1
a1135 1
	if (buf != NULL) Free(buf);
d1139 1
a1139 1
	return(ret);
a1143 1
	char buf[256];
d1152 1
a1152 1
		return(1);
d1160 1
a1160 1
		return(0);
d1165 1
a1165 2
		X509_NAME_oneline(X509_get_subject_name(err_cert),buf,256);
		BIO_printf(bio_err,"%s\n",buf);
d1169 1
a1169 67
		return(1);
		}
	}

static EVP_PKEY *load_key(char *file, int format, char *passin)
	{
	BIO *key=NULL;
	EVP_PKEY *pkey=NULL;

	if (file == NULL)
		{
		BIO_printf(bio_err,"no keyfile specified\n");
		goto end;
		}
	key=BIO_new(BIO_s_file());
	if (key == NULL)
		{
		ERR_print_errors(bio_err);
		goto end;
		}
	if (BIO_read_filename(key,file) <= 0)
		{
		perror(file);
		goto end;
		}
	if (format == FORMAT_ASN1)
		{
		pkey=d2i_PrivateKey_bio(key, NULL);
		}
	else if (format == FORMAT_PEM)
		{
		pkey=PEM_read_bio_PrivateKey(key,NULL,NULL,passin);
		}
	else
		{
		BIO_printf(bio_err,"bad input format specified for key\n");
		goto end;
		}
end:
	if (key != NULL) BIO_free(key);
	if (pkey == NULL)
		BIO_printf(bio_err,"unable to load Private Key\n");
	return(pkey);
	}

static X509 *load_cert(char *file, int format)
	{
	ASN1_HEADER *ah=NULL;
	BUF_MEM *buf=NULL;
	X509 *x=NULL;
	BIO *cert;

	if ((cert=BIO_new(BIO_s_file())) == NULL)
		{
		ERR_print_errors(bio_err);
		goto end;
		}

	if (file == NULL)
		BIO_set_fp(cert,stdin,BIO_NOCLOSE);
	else
		{
		if (BIO_read_filename(cert,file) <= 0)
			{
			perror(file);
			goto end;
			}
a1170 61
	if 	(format == FORMAT_ASN1)
		x=d2i_X509_bio(cert,NULL);
	else if (format == FORMAT_NETSCAPE)
		{
		unsigned char *p,*op;
		int size=0,i;

		/* We sort of have to do it this way because it is sort of nice
		 * to read the header first and check it, then
		 * try to read the certificate */
		buf=BUF_MEM_new();
		for (;;)
			{
			if ((buf == NULL) || (!BUF_MEM_grow(buf,size+1024*10)))
				goto end;
			i=BIO_read(cert,&(buf->data[size]),1024*10);
			size+=i;
			if (i == 0) break;
			if (i < 0)
				{
				perror("reading certificate");
				goto end;
				}
			}
		p=(unsigned char *)buf->data;
		op=p;

		/* First load the header */
		if ((ah=d2i_ASN1_HEADER(NULL,&p,(long)size)) == NULL)
			goto end;
		if ((ah->header == NULL) || (ah->header->data == NULL) ||
			(strncmp(CERT_HDR,(char *)ah->header->data,
			ah->header->length) != 0))
			{
			BIO_printf(bio_err,"Error reading header on certificate\n");
			goto end;
			}
		/* header is ok, so now read the object */
		p=op;
		ah->meth=X509_asn1_meth();
		if ((ah=d2i_ASN1_HEADER(&ah,&p,(long)size)) == NULL)
			goto end;
		x=(X509 *)ah->data;
		ah->data=NULL;
		}
	else if (format == FORMAT_PEM)
		x=PEM_read_bio_X509_AUX(cert,NULL,NULL,NULL);
	else	{
		BIO_printf(bio_err,"bad input format specified for input cert\n");
		goto end;
		}
end:
	if (x == NULL)
		{
		BIO_printf(bio_err,"unable to load certificate\n");
		ERR_print_errors(bio_err);
		}
	if (ah != NULL) ASN1_HEADER_free(ah);
	if (cert != NULL) BIO_free(cert);
	if (buf != NULL) BUF_MEM_free(buf);
	return(x);
d1196 6
a1201 4
	if(clrext) {
		while(X509_get_ext_count(x) > 0) X509_delete_ext(x, 0);
	}
	if(conf) {
d1206 2
a1207 2
                if(!X509V3_EXT_add_conf(conf, &ctx, section, x)) goto err;
	}
d1209 1
a1209 1
	return(1);
d1212 1
a1212 1
	return(0);
d1221 2
a1222 1
	for(i = 0; i < 2; i++) {
d1225 1
a1225 1
		if(idret == 1) BIO_printf(bio, "Yes\n");
d1228 1
a1228 1
	}
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d129 1
a129 1
" -crlext         - delete extensions before signing and input certificate\n",
d368 3
d372 2
d375 2
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d59 1
d95 1
d102 1
d105 1
d107 1
d109 6
a114 1

d121 1
a121 1
"                   missing, it is asssumed to be in the CA file.\n",
d126 1
a126 1
" -md2/-md5/-sha1/-mdc2 - digest to do an RSA sign with\n",
d128 2
d134 1
a134 1
static EVP_PKEY *load_key(char *file, int format);
d136 1
a136 1
static int sign (X509 *x, EVP_PKEY *pkey,int days,const EVP_MD *digest,
d140 2
a141 1
			 int create,int days, LHASH *conf, char *section);
d144 2
d151 1
d156 1
d160 1
d163 1
d165 2
a166 1
	int x509req=0,days=DEF_DAYS,modulus=0;
d174 2
a175 1
	char *extsect = NULL, *extfile = NULL;
d216 1
d218 2
d240 5
d250 5
d270 1
d277 1
d289 36
d331 2
d350 2
d358 8
d368 3
a370 1
		else if ((md_alg=EVP_get_digestbyname(&((*argv)[1]))) != NULL)
d393 3
d397 5
a401 1
	X509V3_add_standard_extensions();
d431 1
a431 1
		if(!(extsect = CONF_get_string(extconf, "default",
a520 5
#if 0
		X509_PUBKEY_free(ci->key);
		ci->key=req->req_info->pubkey;
	        req->req_info->pubkey=NULL;
#else
a523 1
#endif
d558 19
d599 7
d610 11
d649 15
d740 1
a740 1
				if (!X509_digest(x,EVP_md5(),md,&n))
d745 2
a746 1
				BIO_printf(STDout,"MD5 Fingerprint=");
d761 1
a761 1
					Upkey=load_key(keyfile,keyformat);
d769 2
a770 1
				if (!sign(x,Upkey,days,digest,
d778 1
a778 1
					CApkey=load_key(CAkeyfile,CAkeyformat);
d786 1
d788 1
a788 1
					CApkey, CAserial,CA_createserial,days,
d804 1
a804 1
					pk=load_key(keyfile,FORMAT_PEM);
d810 4
a813 1
				rq=X509_to_X509_REQ(x,pk,EVP_md5());
d838 4
a841 3
	else if (outformat == FORMAT_PEM)
		i=PEM_write_bio_X509(out,x);
	else if (outformat == FORMAT_NETSCAPE)
d866 2
d879 3
a881 1
	X509V3_EXT_cleanup();
d887 1
a887 1
	     int days, LHASH *conf, char *section)
d903 1
a903 1
	buf=(char *)Malloc(EVP_PKEY_size(pkey)*2+
d945 2
a946 2
			ASN1_INTEGER_set(bs,0);
			BN_zero(serial);
d1008 4
d1066 1
a1066 1
static EVP_PKEY *load_key(char *file, int format)
d1087 1
a1087 2
#ifndef NO_RSA
	if	(format == FORMAT_ASN1)
d1089 1
a1089 10
		RSA *rsa;

		rsa=d2i_RSAPrivateKey_bio(key,NULL);
		if (rsa != NULL)
			{
			if ((pkey=EVP_PKEY_new()) != NULL)
				EVP_PKEY_assign_RSA(pkey,rsa);
			else
				RSA_free(rsa);
			}
d1091 1
a1091 3
	else
#endif
		if (format == FORMAT_PEM)
d1093 1
a1093 1
		pkey=PEM_read_bio_PrivateKey(key,NULL,NULL,NULL);
d1176 1
a1176 1
		x=PEM_read_bio_X509(cert,NULL,NULL,NULL);
d1194 1
a1194 1
static int sign(X509 *x, EVP_PKEY *pkey, int days, const EVP_MD *digest, 
d1216 3
d1232 19
@


1.1
log
@Initial revision
@
text
@d66 9
a74 8
#include "bio.h"
#include "asn1.h"
#include "err.h"
#include "bn.h"
#include "evp.h"
#include "x509.h"
#include "objects.h"
#include "pem.h"
a82 5
#define FORMAT_UNDEF	0
#define FORMAT_ASN1	1
#define FORMAT_TEXT	2
#define FORMAT_PEM	3

d88 1
a88 1
" -outform arg    - output format - default PEM (one of DER, NET or PEM\n",
d114 1
a114 1
" -text           - print the certitificate in text form\n",
d117 1
a120 1
#ifndef NOPROTO
d124 5
a128 11
static int sign (X509 *x, EVP_PKEY *pkey,int days,EVP_MD *digest);
static int x509_certify (X509_STORE *ctx,char *CAfile, EVP_MD *digest,X509 *x,
	X509 *xca, EVP_PKEY *pkey,char *serial, int create, int days);
#else
static int MS_CALLBACK callb();
static EVP_PKEY *load_key();
static X509 *load_cert();
static int sign ();
static int x509_certify ();
#endif

d131 1
a131 3
int MAIN(argc, argv)
int argc;
char **argv;
d152 3
a154 1
	EVP_MD *md_alg,*digest=EVP_md5();
d212 1
a212 1
				BIO_printf(bio_err,"bad number of days\n");
d216 5
d308 1
d324 28
d380 1
a380 1
		req=PEM_read_bio_X509_REQ(in,NULL,NULL);
d400 1
d428 1
d432 5
d479 1
a479 1
				fprintf(stdout,"issuer= %s\n",buf);
d485 1
a485 1
				fprintf(stdout,"subject=%s\n",buf);
d489 1
a489 1
				fprintf(stdout,"serial=");
d491 1
a491 1
				fprintf(stdout,"\n");
d495 1
a495 2
				fprintf(stdout,"%08lx\n",
					X509_subject_name_hash(x));
a497 1
#ifndef NO_RSA
d505 1
a505 1
					fprintf(stdout,"Modulus=unavailable\n");
d509 2
a510 1
				fprintf(stdout,"Modulus=");
d514 9
a522 2
					fprintf(stdout,"Wrong Algorithm type");
				fprintf(stdout,"\n");
a524 1
#endif
d533 1
a533 1
				printf("/* subject:%s */\n",buf);
d536 1
a536 1
				printf("/* issuer :%s */\n",buf);
d543 1
a543 1
				printf("unsigned char XXX_subject_name[%d]={\n",z);
d547 2
a548 2
					printf("0x%02X,",d[y]);
					if ((y & 0x0f) == 0x0f) printf("\n");
d550 2
a551 2
				if (y%16 != 0) printf("\n");
				printf("};\n");
d554 1
a554 1
				printf("unsigned char XXX_public_key[%d]={\n",z);
d558 3
a560 2
					printf("0x%02X,",d[y]);
					if ((y & 0x0f) == 0x0f) printf("\n");
d562 2
a563 2
				if (y%16 != 0) printf("\n");
				printf("};\n");
d566 1
a566 1
				printf("unsigned char XXX_certificate[%d]={\n",z);
d570 3
a572 2
					printf("0x%02X,",d[y]);
					if ((y & 0x0f) == 0x0f) printf("\n");
d574 2
a575 2
				if (y%16 != 0) printf("\n");
				printf("};\n");
d586 1
a586 1
				ASN1_UTCTIME_print(STDout,X509_get_notBefore(x));
d592 1
a592 1
				ASN1_UTCTIME_print(STDout,X509_get_notAfter(x));
d606 1
a606 1
				fprintf(stdout,"MD5 Fingerprint=");
d609 1
a609 1
					fprintf(stdout,"%02X%c",md[j],
d629 2
a630 1
				if (!sign(x,Upkey,days,digest)) goto end;
d644 1
d646 2
a647 2
					CApkey,
					CAserial,CA_createserial,days))
d721 11
a731 9
	if (out != NULL) BIO_free(out);
	if (STDout != NULL) BIO_free(STDout);
	if (ctx != NULL) X509_STORE_free(ctx);
	if (req != NULL) X509_REQ_free(req);
	if (x != NULL) X509_free(x);
	if (xca != NULL) X509_free(xca);
	if (Upkey != NULL) EVP_PKEY_free(Upkey);
	if (CApkey != NULL) EVP_PKEY_free(CApkey);
	if (rq != NULL) X509_REQ_free(rq);
d735 3
a737 10
static int x509_certify(ctx,CAfile,digest,x,xca,pkey,serialfile,create,days)
X509_STORE *ctx;
char *CAfile;
EVP_MD *digest;
X509 *x;
X509 *xca;
EVP_PKEY *pkey;
char *serialfile;
int create;
int days;
d748 3
a750 1
	EVP_PKEY_copy_parameters(X509_get_pubkey(xca),pkey);
d842 6
d858 7
a864 10
	/* don't save DSA parameters in child if parent has them
	 * and the parents and the childs are the same. */
	upkey=X509_get_pubkey(x);
	if (!EVP_PKEY_missing_parameters(pkey) &&
		(EVP_PKEY_cmp_parameters(pkey,upkey) == 0))
		{
		EVP_PKEY_save_parameters(upkey,0);
		/* Force a re-write */
		X509_set_pubkey(x,upkey);
		}
d879 1
a879 3
static int MS_CALLBACK callb(ok, ctx)
int ok;
X509_STORE_CTX *ctx;
d897 1
a897 1
		printf("error with certificate to be certified - should be self signed\n");
d904 2
a905 2
		printf("%s\n",buf);
		printf("error with certificate - error %d at depth %d\n%s\n",
d912 1
a912 3
static EVP_PKEY *load_key(file, format)
char *file;
int format;
d951 1
a951 1
		pkey=PEM_read_bio_PrivateKey(key,NULL,NULL);
d965 1
a965 3
static X509 *load_cert(file, format)
char *file;
int format;
d1034 1
a1034 1
		x=PEM_read_bio_X509(cert,NULL,NULL);
d1052 2
a1053 5
static int sign(x, pkey, days, digest)
X509 *x;
EVP_PKEY *pkey;
int days;
EVP_MD *digest;
d1056 6
a1061 2
	EVP_PKEY_copy_parameters(X509_get_pubkey(x),pkey);
	EVP_PKEY_save_parameters(X509_get_pubkey(x),1);
d1074 7
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a58 1
#include <assert.h>
d62 1
a62 1
#ifdef OPENSSL_NO_STDIO
d66 8
a73 9
#include <openssl/bio.h>
#include <openssl/asn1.h>
#include <openssl/err.h>
#include <openssl/bn.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/objects.h>
#include <openssl/pem.h>
d82 7
d92 1
a92 1
" -outform arg    - output format - default PEM (one of DER, NET or PEM)\n",
a97 1
" -passin arg     - private key password source\n",
a101 1
" -email          - print email address(es)\n",
a103 1
" -purpose        - print out certificate purposes\n",
a105 1
" -pubkey         - output the public key\n",
a106 1
" -alias          - output certificate alias\n",
d108 1
a108 7
" -ocspid         - print OCSP hash values for the subject name and public key\n",
" -trustout       - output a \"trusted\" certificate\n",
" -clrtrust       - clear all trusted purposes\n",
" -clrreject      - clear all rejected purposes\n",
" -addtrust arg   - trust certificate for a given purpose\n",
" -addreject arg  - reject certificate for a given purpose\n",
" -setalias arg   - set certificate alias\n",
a109 2
" -checkend arg   - check whether the cert expires in the next arg seconds\n",
"                   exit 1 if so, 0 if not\n",
d115 1
a115 1
"                   missing, it is assumed to be in the CA file.\n",
d118 1
a118 2
" -set_serial     - serial number to use\n",
" -text           - print the certificate in text form\n",
d120 1
a120 7
" -md2/-md5/-sha1/-mdc2 - digest to use\n",
" -extfile        - configuration file with X509V3 extensions to add\n",
" -extensions     - section from config file with X509V3 extensions to add\n",
" -clrext         - delete extensions before signing and input certificate\n",
" -nameopt arg    - various certificate name options\n",
" -engine e       - use engine e, possibly a hardware device.\n",
" -certopt arg    - various certificate text options\n",
d124 1
d126 13
a138 7
static int sign (X509 *x, EVP_PKEY *pkey,int days,int clrext, const EVP_MD *digest,
						CONF *conf, char *section);
static int x509_certify (X509_STORE *ctx,char *CAfile,const EVP_MD *digest,
			 X509 *x,X509 *xca,EVP_PKEY *pkey,char *serial,
			 int create,int days, int clrext, CONF *conf, char *section,
						ASN1_INTEGER *sno);
static int purpose_print(BIO *bio, X509 *cert, X509_PURPOSE *pt);
d141 3
a143 3
int MAIN(int, char **);

int MAIN(int argc, char **argv)
a144 1
	ENGINE *e = NULL;
a147 1
	ASN1_OBJECT *objtmp;
a148 1
	ASN1_INTEGER *sno = NULL;
a151 1
	STACK_OF(ASN1_OBJECT) *trust = NULL, *reject = NULL;
a154 1
	char *alias=NULL;
d156 1
a156 3
	int ocspid=0;
	int noout=0,sign_flag=0,CA_flag=0,CA_createserial=0,email=0;
	int trustout=0,clrtrust=0,clrreject=0,aliasout=0,clrext=0;
d158 1
a158 2
	int x509req=0,days=DEF_DAYS,modulus=0,pubkey=0;
	int pprint = 0;
d164 1
a164 7
	const EVP_MD *md_alg,*digest=EVP_md5();
	CONF *extconf = NULL;
	char *extsect = NULL, *extfile = NULL, *passin = NULL, *passargin = NULL;
	int need_rand = 0;
	int checkend=0,checkoffset=0;
	unsigned long nmflag = 0, certflag = 0;
	char *engine=NULL;
a171 3

	if (!load_config(bio_err, NULL))
		goto end;
a172 6
#ifdef OPENSSL_SYS_VMS
	{
	BIO *tmpbio = BIO_new(BIO_f_linebuffer());
	STDout = BIO_push(tmpbio, STDout);
	}
#endif
a204 1
			{
a205 2
			need_rand = 1;
			}
d214 1
a214 1
			CAkeyformat=str2fmt(*(++argv));
d222 1
a222 1
				BIO_printf(STDout,"bad number of days\n");
a225 15
		else if (strcmp(*argv,"-passin") == 0)
			{
			if (--argc < 1) goto bad;
			passargin= *(++argv);
			}
		else if (strcmp(*argv,"-extfile") == 0)
			{
			if (--argc < 1) goto bad;
			extfile= *(++argv);
			}
		else if (strcmp(*argv,"-extensions") == 0)
			{
			if (--argc < 1) goto bad;
			extsect= *(++argv);
			}
a240 1
			need_rand = 1;
a246 1
			need_rand = 1;
a257 59
		else if (strcmp(*argv,"-set_serial") == 0)
			{
			if (--argc < 1) goto bad;
			if (!(sno = s2i_ASN1_INTEGER(NULL, *(++argv))))
				goto bad;
			}
		else if (strcmp(*argv,"-addtrust") == 0)
			{
			if (--argc < 1) goto bad;
			if (!(objtmp = OBJ_txt2obj(*(++argv), 0)))
				{
				BIO_printf(bio_err,
					"Invalid trust object value %s\n", *argv);
				goto bad;
				}
			if (!trust) trust = sk_ASN1_OBJECT_new_null();
			sk_ASN1_OBJECT_push(trust, objtmp);
			trustout = 1;
			}
		else if (strcmp(*argv,"-addreject") == 0)
			{
			if (--argc < 1) goto bad;
			if (!(objtmp = OBJ_txt2obj(*(++argv), 0)))
				{
				BIO_printf(bio_err,
					"Invalid reject object value %s\n", *argv);
				goto bad;
				}
			if (!reject) reject = sk_ASN1_OBJECT_new_null();
			sk_ASN1_OBJECT_push(reject, objtmp);
			trustout = 1;
			}
		else if (strcmp(*argv,"-setalias") == 0)
			{
			if (--argc < 1) goto bad;
			alias= *(++argv);
			trustout = 1;
			}
		else if (strcmp(*argv,"-certopt") == 0)
			{
			if (--argc < 1) goto bad;
			if (!set_cert_ex(&certflag, *(++argv))) goto bad;
			}
		else if (strcmp(*argv,"-nameopt") == 0)
			{
			if (--argc < 1) goto bad;
			if (!set_name_ex(&nmflag, *(++argv))) goto bad;
			}
		else if (strcmp(*argv,"-setalias") == 0)
			{
			if (--argc < 1) goto bad;
			alias= *(++argv);
			trustout = 1;
			}
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
			engine= *(++argv);
			}
a259 2
		else if (strcmp(*argv,"-email") == 0)
			email= ++num;
a263 2
		else if (strcmp(*argv,"-pubkey") == 0)
			pubkey= ++num;
a280 2
		else if (strcmp(*argv,"-purpose") == 0)
			pprint= ++num;
a284 6
		else if (strcmp(*argv,"-checkend") == 0)
			{
			if (--argc < 1) goto bad;
			checkoffset=atoi(*(++argv));
			checkend=1;
			}
a286 8
		else if (strcmp(*argv,"-trustout") == 0)
			trustout= 1;
		else if (strcmp(*argv,"-clrtrust") == 0)
			clrtrust= ++num;
		else if (strcmp(*argv,"-clrreject") == 0)
			clrreject= ++num;
		else if (strcmp(*argv,"-alias") == 0)
			aliasout= ++num;
d289 1
a289 12
		else if (strcmp(*argv,"-clrext") == 0)
			clrext = 1;
#if 1 /* stay backwards-compatible with 0.9.5; this should go away soon */
		else if (strcmp(*argv,"-crlext") == 0)
			{
			BIO_printf(bio_err,"use -clrext instead of -crlext\n");
			clrext = 1;
			}
#endif
		else if (strcmp(*argv,"-ocspid") == 0)
			ocspid= ++num;
		else if ((md_alg=EVP_get_digestbyname(*argv + 1)))
d308 1
a308 1
			BIO_printf(bio_err,"%s",*pp);
a311 5
        e = setup_engine(bio_err, engine, 0);

	if (need_rand)
		app_RAND_load_file(NULL, bio_err, 0);

a313 6
	if (!app_passwd(bio_err, passargin, NULL, &passin, NULL))
		{
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
		}

a327 39
	if (extfile)
		{
		long errorline;
		X509V3_CTX ctx2;
		extconf = NCONF_new(NULL);
		if (!NCONF_load(extconf, extfile,&errorline))
			{
			if (errorline <= 0)
				BIO_printf(bio_err,
					"error loading the config file '%s'\n",
								extfile);
                	else
                        	BIO_printf(bio_err,
				       "error on line %ld of config file '%s'\n"
							,errorline,extfile);
			goto end;
			}
		if (!extsect)
			{
			extsect = NCONF_get_string(extconf, "default", "extensions");
			if (!extsect)
				{
				ERR_clear_error();
				extsect = "default";
				}
			}
		X509V3_set_ctx_test(&ctx2);
		X509V3_set_nconf(&ctx2, extconf);
		if (!X509V3_EXT_add_nconf(extconf, &ctx2, extsect, NULL))
			{
			BIO_printf(bio_err,
				"Error Loading extension section %s\n",
								 extsect);
			ERR_print_errors(bio_err);
			goto end;
			}
		}


a352 1
				BIO_free(in);
d356 1
a356 1
		req=PEM_read_bio_X509_REQ(in,NULL,NULL,NULL);
d359 1
a359 5
		if (req == NULL)
			{
			ERR_print_errors(bio_err);
			goto end;
			}
a375 1
		EVP_PKEY_free(pkey);
d389 3
a391 2

		print_name(bio_err, "subject=", X509_REQ_get_subject_name(req), nmflag);
d396 1
a396 6
		if (sno)
			{
			if (!X509_set_serialNumber(x, sno))
				goto end;
			}
		else if (!ASN1_INTEGER_set(X509_get_serialNumber(x),0)) goto end;
d403 3
a405 3
		pkey = X509_REQ_get_pubkey(req);
		X509_set_pubkey(x,pkey);
		EVP_PKEY_free(pkey);
d408 1
a408 1
		x=load_cert(bio_err,infile,informat,NULL,e,"Certificate");
d413 1
a413 1
		xca=load_cert(bio_err,CAfile,CAformat,NULL,e,"CA Certificate");
a428 1
			{
a429 7
#ifdef OPENSSL_SYS_VMS
			{
			BIO *tmpbio = BIO_new(BIO_f_linebuffer());
			out = BIO_push(tmpbio, out);
			}
#endif
			}
a439 23
	if (alias) X509_alias_set1(x, (unsigned char *)alias, -1);

	if (clrtrust) X509_trust_clear(x);
	if (clrreject) X509_reject_clear(x);

	if (trust)
		{
		for (i = 0; i < sk_ASN1_OBJECT_num(trust); i++)
			{
			objtmp = sk_ASN1_OBJECT_value(trust, i);
			X509_add1_trust_object(x, objtmp);
			}
		}

	if (reject)
		{
		for (i = 0; i < sk_ASN1_OBJECT_num(reject); i++)
			{
			objtmp = sk_ASN1_OBJECT_value(reject, i);
			X509_add1_reject_object(x, objtmp);
			}
		}

d446 3
a448 2
				print_name(STDout, "issuer= ",
					X509_get_issuer_name(x), nmflag);
d452 3
a454 2
				print_name(STDout, "subject= ",
					X509_get_subject_name(x), nmflag);
d458 1
a458 1
				BIO_printf(STDout,"serial=");
d460 1
a460 17
				BIO_printf(STDout,"\n");
				}
			else if (email == i) 
				{
				int j;
				STACK *emlst;
				emlst = X509_get1_email(x);
				for (j = 0; j < sk_num(emlst); j++)
					BIO_printf(STDout, "%s\n", sk_value(emlst, j));
				X509_email_free(emlst);
				}
			else if (aliasout == i)
				{
				unsigned char *alstr;
				alstr = X509_alias_get0(x, NULL);
				if (alstr) BIO_printf(STDout,"%s\n", alstr);
				else BIO_puts(STDout,"<No Alias>\n");
d464 2
a465 12
				BIO_printf(STDout,"%08lx\n",X509_subject_name_hash(x));
				}
			else if (pprint == i)
				{
				X509_PURPOSE *ptmp;
				int j;
				BIO_printf(STDout, "Certificate purposes:\n");
				for (j = 0; j < X509_PURPOSE_get_count(); j++)
					{
					ptmp = X509_PURPOSE_get0(j);
					purpose_print(STDout, x, ptmp);
					}
d468 1
d476 1
a476 1
					BIO_printf(bio_err,"Modulus=unavailable\n");
d480 1
a480 2
				BIO_printf(STDout,"Modulus=");
#ifndef OPENSSL_NO_RSA
d484 2
a485 24
#endif
#ifndef OPENSSL_NO_DSA
				if (pkey->type == EVP_PKEY_DSA)
					BN_print(STDout,pkey->pkey.dsa->pub_key);
				else
#endif
					BIO_printf(STDout,"Wrong Algorithm type");
				BIO_printf(STDout,"\n");
				EVP_PKEY_free(pkey);
				}
			else
				if (pubkey == i)
				{
				EVP_PKEY *pkey;

				pkey=X509_get_pubkey(x);
				if (pkey == NULL)
					{
					BIO_printf(bio_err,"Error getting public key\n");
					ERR_print_errors(bio_err);
					goto end;
					}
				PEM_write_bio_PUBKEY(STDout, pkey);
				EVP_PKEY_free(pkey);
d488 1
d497 1
a497 1
				BIO_printf(STDout,"/* subject:%s */\n",buf);
d500 1
a500 1
				BIO_printf(STDout,"/* issuer :%s */\n",buf);
d503 1
a503 1
				m=OPENSSL_malloc(z);
d507 1
a507 1
				BIO_printf(STDout,"unsigned char XXX_subject_name[%d]={\n",z);
d511 2
a512 2
					BIO_printf(STDout,"0x%02X,",d[y]);
					if ((y & 0x0f) == 0x0f) BIO_printf(STDout,"\n");
d514 2
a515 2
				if (y%16 != 0) BIO_printf(STDout,"\n");
				BIO_printf(STDout,"};\n");
d518 1
a518 1
				BIO_printf(STDout,"unsigned char XXX_public_key[%d]={\n",z);
d522 2
a523 3
					BIO_printf(STDout,"0x%02X,",d[y]);
					if ((y & 0x0f) == 0x0f)
						BIO_printf(STDout,"\n");
d525 2
a526 2
				if (y%16 != 0) BIO_printf(STDout,"\n");
				BIO_printf(STDout,"};\n");
d529 1
a529 1
				BIO_printf(STDout,"unsigned char XXX_certificate[%d]={\n",z);
d533 2
a534 3
					BIO_printf(STDout,"0x%02X,",d[y]);
					if ((y & 0x0f) == 0x0f)
						BIO_printf(STDout,"\n");
d536 2
a537 2
				if (y%16 != 0) BIO_printf(STDout,"\n");
				BIO_printf(STDout,"};\n");
d539 1
a539 1
				OPENSSL_free(m);
d543 1
a543 1
				X509_print_ex(out,x,nmflag, certflag);
d548 1
a548 1
				ASN1_TIME_print(STDout,X509_get_notBefore(x));
d554 1
a554 1
				ASN1_TIME_print(STDout,X509_get_notAfter(x));
d563 1
a563 1
				if (!X509_digest(x,digest,md,&n))
d568 1
a568 2
				BIO_printf(STDout,"%s Fingerprint=",
						OBJ_nid2sn(EVP_MD_type(digest)));
d571 1
a571 1
					BIO_printf(STDout,"%02X%c",md[j],
d583 1
a583 3
					Upkey=load_key(bio_err,
						keyfile,keyformat, passin, e,
						"Private key");
d586 1
a586 1
#ifndef OPENSSL_NO_DSA
d591 1
a591 3
				assert(need_rand);
				if (!sign(x,Upkey,days,clrext,digest,
						 extconf, extsect)) goto end;
d598 1
a598 3
					CApkey=load_key(bio_err,
						CAkeyfile,CAkeyformat, passin,
						e, "CA Private Key");
d601 1
a601 1
#ifndef OPENSSL_NO_DSA
a604 2
				
				assert(need_rand);
d606 2
a607 2
					CApkey, CAserial,CA_createserial,days, clrext,
					extconf, extsect, sno))
d622 1
a622 3
					pk=load_key(bio_err,
						keyfile,FORMAT_PEM, passin, e,
						"request key");
d628 1
a628 4
		                if (pk->type == EVP_PKEY_DSA)
		                        digest=EVP_dss1();

				rq=X509_to_X509_REQ(x,pk,digest);
a641 20
			else if (ocspid == i)
				{
				X509_ocspid_print(out, x);
				}
			}
		}

	if (checkend)
		{
		time_t tnow=time(NULL);

		if (ASN1_UTCTIME_cmp_time_t(X509_get_notAfter(x), tnow+checkoffset) == -1)
			{
			BIO_printf(out,"Certificate will expire\n");
			ret=1;
			}
		else
			{
			BIO_printf(out,"Certificate will not expire\n");
			ret=0;
a642 1
		goto end;
d654 1
a654 4
		{
		if (trustout) i=PEM_write_bio_X509_AUX(out,x);
		else i=PEM_write_bio_X509(out,x);
		}
d660 2
a661 2
		os.data=(unsigned char *)NETSCAPE_CERT_HDR;
		os.length=strlen(NETSCAPE_CERT_HDR);
d673 1
a673 2
	if (!i)
		{
a679 2
	if (need_rand)
		app_RAND_write_file(NULL, bio_err);
d681 9
a689 15
	NCONF_free(extconf);
	BIO_free_all(out);
	BIO_free_all(STDout);
	X509_STORE_free(ctx);
	X509_REQ_free(req);
	X509_free(x);
	X509_free(xca);
	EVP_PKEY_free(Upkey);
	EVP_PKEY_free(CApkey);
	X509_REQ_free(rq);
	ASN1_INTEGER_free(sno);
	sk_ASN1_OBJECT_pop_free(trust, ASN1_OBJECT_free);
	sk_ASN1_OBJECT_pop_free(reject, ASN1_OBJECT_free);
	if (passin) OPENSSL_free(passin);
	apps_shutdown();
d693 10
a702 1
static ASN1_INTEGER *load_serial(char *CAfile, char *serialfile, int create)
d704 2
a705 1
	char *buf = NULL, *p;
d707 7
a713 3
	ASN1_INTEGER *bs = NULL, *bs2 = NULL;
	BIO *io = NULL;
	BIGNUM *serial = NULL;
d715 3
a717 1
	buf=OPENSSL_malloc( ((serialfile == NULL)
d758 2
a759 2
			ASN1_INTEGER_set(bs,1);
			BN_one(serial);
d783 3
a785 2
	if (!(bs2 = BN_to_ASN1_INTEGER(serial, NULL)))
		{ BIO_printf(bio_err,"error converting bn 2 asn1_integer\n"); goto end; }
d792 1
a792 1
	i2a_ASN1_INTEGER(io,bs2);
a793 1

a794 3
	if (buf) OPENSSL_free(buf);
	ASN1_INTEGER_free(bs2);
	BN_free(serial);
d796 1
a796 33
	return bs;

	end:
	if (buf) OPENSSL_free(buf);
	BIO_free(io);
	ASN1_INTEGER_free(bs);
	BN_free(serial);
	return NULL;

	}

static int x509_certify(X509_STORE *ctx, char *CAfile, const EVP_MD *digest,
	     X509 *x, X509 *xca, EVP_PKEY *pkey, char *serialfile, int create,
	     int days, int clrext, CONF *conf, char *section, ASN1_INTEGER *sno)
	{
	int ret=0;
	ASN1_INTEGER *bs=NULL;
	X509_STORE_CTX xsc;
	EVP_PKEY *upkey;

	upkey = X509_get_pubkey(xca);
	EVP_PKEY_copy_parameters(upkey,pkey);
	EVP_PKEY_free(upkey);

	if(!X509_STORE_CTX_init(&xsc,ctx,x,NULL))
		{
		BIO_printf(bio_err,"Error initialising X509 store\n");
		goto end;
		}
	if (sno) bs = sno;
	else if (!(bs = load_serial(CAfile, serialfile, create)))
		goto end;

a804 6
	if (!X509_check_private_key(xca,pkey))
		{
		BIO_printf(bio_err,"CA certificate and CA private key do not match\n");
		goto end;
		}

d815 9
a823 12
	if (clrext)
		{
		while (X509_get_ext_count(x) > 0) X509_delete_ext(x, 0);
		}

	if (conf)
		{
		X509V3_CTX ctx2;
		X509_set_version(x,2); /* version 3 certificate */
                X509V3_set_ctx(&ctx2, xca, x, NULL, NULL, 0);
                X509V3_set_nconf(&ctx2, conf);
                if (!X509V3_EXT_add_nconf(conf, &ctx2, section, x)) goto end;
d832 5
a836 2
	if (!sno) ASN1_INTEGER_free(bs);
	return ret;
d839 3
a841 1
static int MS_CALLBACK callb(int ok, X509_STORE_CTX *ctx)
d843 1
d852 1
a852 1
		return 1;
d859 2
a860 2
		BIO_printf(bio_err,"error with certificate to be certified - should be self signed\n");
		return 0;
d865 3
a867 2
		print_name(bio_err, NULL, X509_get_subject_name(err_cert),0);
		BIO_printf(bio_err,"error with certificate - error %d at depth %d\n%s\n",
d870 1
a870 1
		return 1;
d874 143
d1018 5
a1022 2
static int sign(X509 *x, EVP_PKEY *pkey, int days, int clrext, const EVP_MD *digest, 
						CONF *conf, char *section)
d1025 2
a1026 6
	EVP_PKEY *pktmp;

	pktmp = X509_get_pubkey(x);
	EVP_PKEY_copy_parameters(pktmp,pkey);
	EVP_PKEY_save_parameters(pktmp,1);
	EVP_PKEY_free(pktmp);
a1038 12
	if (clrext)
		{
		while (X509_get_ext_count(x) > 0) X509_delete_ext(x, 0);
		}
	if (conf)
		{
		X509V3_CTX ctx;
		X509_set_version(x,2); /* version 3 certificate */
                X509V3_set_ctx(&ctx, x, x, NULL, NULL, 0);
                X509V3_set_nconf(&ctx, conf);
                if (!X509V3_EXT_add_nconf(conf, &ctx, section, x)) goto err;
		}
d1040 1
a1040 1
	return 1;
d1043 1
a1043 1
	return 0;
a1044 17

static int purpose_print(BIO *bio, X509 *cert, X509_PURPOSE *pt)
{
	int id, i, idret;
	char *pname;
	id = X509_PURPOSE_get_id(pt);
	pname = X509_PURPOSE_get0_name(pt);
	for (i = 0; i < 2; i++)
		{
		idret = X509_check_purpose(cert, id, i);
		BIO_printf(bio, "%s%s : ", pname, i ? " CA" : ""); 
		if (idret == 1) BIO_printf(bio, "Yes\n");
		else if (idret == 0) BIO_printf(bio, "No\n");
		else BIO_printf(bio, "Yes (WARNING code=%d)\n", idret);
		}
	return 1;
}
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a917 1
#ifndef OPENSSL_NO_DSA
a919 1
#endif
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d864 2
a865 2
						keyfile, keyformat, 0,
						passin, e, "Private key");
d883 2
a884 3
						CAkeyfile, CAkeyformat,
						0, passin, e,
						"CA Private Key");
d911 2
a912 2
						keyfile, FORMAT_PEM, 0,
						passin, e, "request key");
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@d125 1
a125 1
" -CAserial arg   - serial file\n",
a133 1
#ifndef OPENSSL_NO_ENGINE
a134 1
#endif
a185 1
#ifndef OPENSSL_NO_ENGINE
a186 1
#endif
d357 6
a362 1
#ifndef OPENSSL_NO_ENGINE
a367 1
#endif
a452 1
#ifndef OPENSSL_NO_ENGINE
a453 1
#endif
d482 1
a482 1
		long errorline = -1;
d773 1
a773 1
					buf,sizeof buf);
d776 1
a776 2
					X509_get_issuer_name(x),buf,
					sizeof buf);
d1019 1
a1019 1
	OPENSSL_EXIT(ret);
d1077 1
a1077 1
		if (!a2i_ASN1_INTEGER(io,bs,buf2,sizeof buf2))
@


1.1.1.6
log
@import 0.9.7c
@
text
@d1148 1
a1148 1
/*	if (!X509_STORE_add_cert(ctx,x)) goto end;*/
@


1.1.1.7
log
@import openssl-0.9.7d
@
text
@d1025 1
a1025 1
static ASN1_INTEGER *x509_load_serial(char *CAfile, char *serialfile, int create)
d1028 3
a1030 1
	ASN1_INTEGER *bs = NULL;
a1031 1
	size_t len;
d1033 3
a1035 4
	len = ((serialfile == NULL)
		?(strlen(CAfile)+strlen(POSTFIX)+1)
		:(strlen(serialfile)))+1;
	buf=OPENSSL_malloc(len);
d1039 1
a1039 1
		BUF_strlcpy(buf,CAfile,len);
d1046 1
a1046 1
		BUF_strlcat(buf,POSTFIX,len);
d1049 1
a1049 1
		BUF_strlcpy(buf,serialfile,len);
d1058 38
a1095 2
	serial = load_serial(buf, create, NULL);
	if (serial == NULL) goto end;
d1099 10
d1110 6
a1115 1
	if (!save_serial(buf, NULL, serial, &bs)) goto end;
d1117 1
a1117 1
 end:
d1119 2
d1122 2
a1123 1
	return bs;
d1145 1
a1145 1
	else if (!(bs = x509_load_serial(CAfile, serialfile, create)))
@


1.1.1.8
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d171 1
a171 1
	int next_serial=0,ocspid=0;
d182 1
a182 1
	const EVP_MD *md_alg,*digest;
a218 7
#ifdef  OPENSSL_FIPS
	if (FIPS_mode())
		digest = EVP_sha1();
	else
#endif
		digest = EVP_md5();

a373 2
		else if (strcmp(*argv,"-next_serial") == 0)
			next_serial= ++num;
d594 1
a594 1
		if (sno == NULL)
d596 1
a596 4
			sno = ASN1_INTEGER_new();
			if (!sno || !rand_serial(NULL, sno))
				goto end;
			if (!X509_set_serialNumber(x, sno)) 
a597 2
			ASN1_INTEGER_free(sno);
			sno = NULL;
d599 1
a599 3
		else if (!X509_set_serialNumber(x, sno)) 
			goto end;

d620 1
a620 1
	if (!noout || text || next_serial)
a693 18
			else if (next_serial == i)
				{
				BIGNUM *bnser;
				ASN1_INTEGER *ser;
				ser = X509_get_serialNumber(x);
				bnser = ASN1_INTEGER_to_BN(ser, NULL);
				if (!bnser)
					goto end;
				if (!BN_add_word(bnser, 1))
					goto end;
				ser = BN_to_ASN1_INTEGER(bnser, NULL);
				if (!ser)
					goto end;
				BN_free(bnser);
				i2a_ASN1_INTEGER(out, ser);
				ASN1_INTEGER_free(ser);
				BIO_puts(out, "\n");
				}
d950 1
a950 1
		time_t tcheck=time(NULL) + checkoffset;
d952 1
a952 1
		if (X509_cmp_time(X509_get_notAfter(x), &tcheck) < 0)
d1050 7
@


1.1.1.9
log
@import of OpenSSL 0.9.8h
@
text
@a75 6
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
d84 1
a84 1
static const char *x509_usage[]={
d95 1
a95 3
" -subject_hash   - print subject hash value\n",
" -issuer_hash    - print issuer hash value\n",
" -hash           - synonym for -subject_hash\n",
a108 1
" -ocspurl        - print OCSP Responder URL(s)\n",
d170 2
a171 3
	int text=0,serial=0,subject=0,issuer=0,startdate=0,enddate=0;
	int next_serial=0;
	int subject_hash=0,issuer_hash=0,ocspid=0;
a172 1
	int ocsp_uri=0;
d177 1
a177 1
	const char **pp;
d182 1
a182 1
	const EVP_MD *md_alg,*digest=EVP_sha1();
d219 7
a378 2
		else if (strcmp(*argv,"-ocsp_uri") == 0)
			ocsp_uri= ++num;
d391 2
a392 5
		else if (strcmp(*argv,"-hash") == 0
			|| strcmp(*argv,"-subject_hash") == 0)
			subject_hash= ++num;
		else if (strcmp(*argv,"-issuer_hash") == 0)
			issuer_hash= ++num;
d707 1
a707 2
				i2a_ASN1_INTEGER(STDout,
					X509_get_serialNumber(x));
d728 1
a728 1
			else if ((email == i) || (ocsp_uri == i))
d732 1
a732 4
				if (email == i)
					emlst = X509_get1_email(x);
				else
					emlst = X509_get1_ocsp(x);
d744 1
a744 1
			else if (subject_hash == i)
a747 4
			else if (issuer_hash == i)
				{
				BIO_printf(STDout,"%08lx\n",X509_issuer_name_hash(x));
				}
a908 4
#ifndef OPENSSL_NO_ECDSA
				if (Upkey->type == EVP_PKEY_EC)
					digest=EVP_ecdsa();
#endif
a928 4
#ifndef OPENSSL_NO_ECDSA
				if (CApkey->type == EVP_PKEY_EC)
					digest = EVP_ecdsa();
#endif
a959 4
#ifndef OPENSSL_NO_ECDSA
				if (pk->type == EVP_PKEY_EC)
					digest=EVP_ecdsa();
#endif
d1023 2
a1024 1
		i=ASN1_i2d_bio_of(ASN1_HEADER,i2d_ASN1_HEADER,out,&ah);
@


1.1.1.10
log
@import openssl-0.9.8j
@
text
@d1154 1
a1154 1
	if (!reqfile && X509_verify_cert(&xsc) <= 0)
@


1.1.1.11
log
@import of OpenSSL 0.9.8k
@
text
@d117 1
a117 1
" -ocsp_uri       - print OCSP Responder URL(s)\n",
@


1.1.1.12
log
@import OpenSSL-1.0.0a
@
text
@a101 3
#ifndef OPENSSL_NO_MD5
" -subject_hash_old   - print old-style (MD5) subject hash value\n",
#endif
a102 3
#ifndef OPENSSL_NO_MD5
" -issuer_hash_old    - print old-style (MD5) issuer hash value\n",
#endif
a181 3
#ifndef OPENSSL_NO_MD5
	int subject_hash_old=0,issuer_hash_old=0;
#endif
d193 1
a193 1
	const EVP_MD *md_alg,*digest=NULL;
d228 1
a228 1
	X509_STORE_set_verify_cb(ctx,callb);
a399 4
#ifndef OPENSSL_NO_MD5
		else if (strcmp(*argv,"-subject_hash_old") == 0)
			subject_hash_old= ++num;
#endif
a401 4
#ifndef OPENSSL_NO_MD5
		else if (strcmp(*argv,"-issuer_hash_old") == 0)
			issuer_hash_old= ++num;
#endif
d629 1
a629 1
	        X509_time_adj_ex(X509_get_notAfter(x),days, 0, NULL);
d741 1
a741 1
				STACK_OF(OPENSSL_STRING) *emlst;
d746 2
a747 3
				for (j = 0; j < sk_OPENSSL_STRING_num(emlst); j++)
					BIO_printf(STDout, "%s\n",
						   sk_OPENSSL_STRING_value(emlst, j));
a760 6
#ifndef OPENSSL_NO_MD5
			else if (subject_hash_old == i)
				{
				BIO_printf(STDout,"%08lx\n",X509_subject_name_hash_old(x));
				}
#endif
a764 6
#ifndef OPENSSL_NO_MD5
			else if (issuer_hash_old == i)
				{
				BIO_printf(STDout,"%08lx\n",X509_issuer_name_hash_old(x));
				}
#endif
a894 1
				const EVP_MD *fdig = digest;
d896 1
a896 4
				if (!fdig)
					fdig = EVP_sha1();

				if (!X509_digest(x,fdig,md,&n))
d902 1
a902 1
						OBJ_nid2sn(EVP_MD_type(fdig)));
d922 8
d946 8
d981 9
d1043 2
a1044 2
		NETSCAPE_X509 nx;
		ASN1_OCTET_STRING hdr;
d1046 5
a1050 4
		hdr.data=(unsigned char *)NETSCAPE_CERT_HDR;
		hdr.length=strlen(NETSCAPE_CERT_HDR);
		nx.header= &hdr;
		nx.cert=x;
d1052 1
a1052 1
		i=ASN1_item_i2d_bio(ASN1_ITEM_rptr(NETSCAPE_X509),out,&nx);
a1153 1
	X509_STORE_CTX_set_flags(&xsc, X509_V_FLAG_CHECK_SS_SIGNATURE);
d1170 1
a1170 1
	if (X509_time_adj_ex(X509_get_notAfter(x),days, 0, NULL) == NULL)
@


1.1.1.13
log
@import OpenSSL 1.0.0e
@
text
@d559 1
d627 1
@


1.1.1.14
log
@OpenSSL 1.0.0f: import upstream source
@
text
@d990 1
a990 1
						keyfile, keyformat, 0,
@


1.1.1.15
log
@import OpenSSL-1.0.1c
@
text
@d160 3
a162 4
			 X509 *x,X509 *xca,EVP_PKEY *pkey,
			 STACK_OF(OPENSSL_STRING) *sigopts,
			 char *serial, int create ,int days, int clrext,
			 CONF *conf, char *section, ASN1_INTEGER *sno);
a174 1
	STACK_OF(OPENSSL_STRING) *sigopts = NULL;
a273 9
		else if (strcmp(*argv,"-sigopt") == 0)
			{
			if (--argc < 1)
				goto bad;
			if (!sigopts)
				sigopts = sk_OPENSSL_STRING_new_null();
			if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))
				goto bad;
			}
d973 1
a973 2
					CApkey, sigopts,
					CAserial,CA_createserial,days, clrext,
a1083 2
	if (sigopts)
		sk_OPENSSL_STRING_free(sigopts);
d1134 2
a1135 5
	     		X509 *x, X509 *xca, EVP_PKEY *pkey,
			STACK_OF(OPENSSL_STRING) *sigopts,
	  		char *serialfile, int create,
	     		int days, int clrext, CONF *conf, char *section,
			ASN1_INTEGER *sno)
d1194 1
a1194 2
	if (!do_X509_sign(bio_err, x, pkey, digest, sigopts))
		goto end;
@


1.1.1.16
log
@Import OpenSSL 1.0.1g
@
text
@d291 1
a291 1
				BIO_printf(bio_err,"bad number of days\n");
d915 1
a915 1
				X509_print_ex(STDout,x,nmflag, certflag);
@


