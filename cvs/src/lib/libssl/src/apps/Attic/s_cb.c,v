head	1.23;
access;
symbols
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	butholakala:1.9
	openssl_1_0_1_g:1.1.1.7
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	openssl_1_0_1_c:1.1.1.6
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.8
	openssl_1_0_0_f:1.1.1.5
	openssl_1_0_0_e:1.1.1.5
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	openssh_1_0_0_a:1.1.1.5
	OPENBSD_4_8:1.6.0.8
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	openssl_0_9_8_k:1.1.1.4
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	openssl_0_9_8_j:1.1.1.4
	openssl_0_9_8_h:1.1.1.4
	pre_openssl_0_9_8h:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	openssl_0_9_7j:1.1.1.3
	openssl:1.1.1
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENSSL_0_9_7D:1.1.1.3
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.22;
commitid	7A7DObXgY4Fni8xJ;

1.22
date	2014.06.13.04.29.13;	author miod;	state Exp;
branches;
next	1.21;
commitid	8Qu6YceLSxhOi4yG;

1.21
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	mJUVYpkFBZ0Zv2bG;

1.20
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.17.19.44.13;	author chl;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.25.13.56.39;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.22.13.34.56;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.18.14.37.41;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.17.14.43.34;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.13.20.37.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.01.22.58.51;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.15.06.18.30;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.19;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.09;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.09;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.35;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.23;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: s_cb.c,v 1.22 2014/06/13 04:29:13 miod Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <sys/socket.h>

#include <netinet/in.h>

#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "apps.h"

#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/ssl.h>
#include <openssl/x509.h>

#include "s_apps.h"

#define	COOKIE_SECRET_LENGTH	16

int verify_depth = 0;
int verify_error = X509_V_OK;
int verify_return_error = 0;
unsigned char cookie_secret[COOKIE_SECRET_LENGTH];
int cookie_initialized = 0;

int
verify_callback(int ok, X509_STORE_CTX * ctx)
{
	X509 *err_cert;
	int err, depth;

	err_cert = X509_STORE_CTX_get_current_cert(ctx);
	err = X509_STORE_CTX_get_error(ctx);
	depth = X509_STORE_CTX_get_error_depth(ctx);

	BIO_printf(bio_err, "depth=%d ", depth);
	if (err_cert) {
		X509_NAME_print_ex(bio_err, X509_get_subject_name(err_cert),
		    0, XN_FLAG_ONELINE);
		BIO_puts(bio_err, "\n");
	} else
		BIO_puts(bio_err, "<no cert>\n");
	if (!ok) {
		BIO_printf(bio_err, "verify error:num=%d:%s\n", err,
		    X509_verify_cert_error_string(err));
		if (verify_depth >= depth) {
			if (!verify_return_error)
				ok = 1;
			verify_error = X509_V_OK;
		} else {
			ok = 0;
			verify_error = X509_V_ERR_CERT_CHAIN_TOO_LONG;
		}
	}
	switch (err) {
	case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
		BIO_puts(bio_err, "issuer= ");
		X509_NAME_print_ex(bio_err, X509_get_issuer_name(err_cert),
		    0, XN_FLAG_ONELINE);
		BIO_puts(bio_err, "\n");
		break;
	case X509_V_ERR_CERT_NOT_YET_VALID:
	case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:
		BIO_printf(bio_err, "notBefore=");
		ASN1_TIME_print(bio_err, X509_get_notBefore(err_cert));
		BIO_printf(bio_err, "\n");
		break;
	case X509_V_ERR_CERT_HAS_EXPIRED:
	case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:
		BIO_printf(bio_err, "notAfter=");
		ASN1_TIME_print(bio_err, X509_get_notAfter(err_cert));
		BIO_printf(bio_err, "\n");
		break;
	case X509_V_ERR_NO_EXPLICIT_POLICY:
		policies_print(bio_err, ctx);
		break;
	}
	if (err == X509_V_OK && ok == 2)
		policies_print(bio_err, ctx);

	BIO_printf(bio_err, "verify return:%d\n", ok);
	return (ok);
}

int
set_cert_stuff(SSL_CTX * ctx, char *cert_file, char *key_file)
{
	if (cert_file != NULL) {
		/*
		SSL *ssl;
		X509 *x509;
		*/

		if (SSL_CTX_use_certificate_file(ctx, cert_file,
		    SSL_FILETYPE_PEM) <= 0) {
			BIO_printf(bio_err,
			    "unable to get certificate from '%s'\n", cert_file);
			ERR_print_errors(bio_err);
			return (0);
		}
		if (key_file == NULL)
			key_file = cert_file;
		if (SSL_CTX_use_PrivateKey_file(ctx, key_file,
		    SSL_FILETYPE_PEM) <= 0) {
			BIO_printf(bio_err,
			    "unable to get private key from '%s'\n", key_file);
			ERR_print_errors(bio_err);
			return (0);
		}
		/*
		In theory this is no longer needed
		ssl=SSL_new(ctx);
		x509=SSL_get_certificate(ssl);

		if (x509 != NULL) {
			EVP_PKEY *pktmp;
			pktmp = X509_get_pubkey(x509);
			EVP_PKEY_copy_parameters(pktmp,
						SSL_get_privatekey(ssl));
			EVP_PKEY_free(pktmp);
		}
		SSL_free(ssl);
		*/

		/*
		 * If we are using DSA, we can copy the parameters from the
		 * private key
		 */


		/*
		 * Now we know that a key and cert have been set against the
		 * SSL context
		 */
		if (!SSL_CTX_check_private_key(ctx)) {
			BIO_printf(bio_err,
			    "Private key does not match the certificate public key\n");
			return (0);
		}
	}
	return (1);
}

int
set_cert_key_stuff(SSL_CTX * ctx, X509 * cert, EVP_PKEY * key)
{
	if (cert == NULL)
		return 1;
	if (SSL_CTX_use_certificate(ctx, cert) <= 0) {
		BIO_printf(bio_err, "error setting certificate\n");
		ERR_print_errors(bio_err);
		return 0;
	}
	if (SSL_CTX_use_PrivateKey(ctx, key) <= 0) {
		BIO_printf(bio_err, "error setting private key\n");
		ERR_print_errors(bio_err);
		return 0;
	}
	/*
	 * Now we know that a key and cert have been set against the SSL
	 * context
	 */
	if (!SSL_CTX_check_private_key(ctx)) {
		BIO_printf(bio_err,
		    "Private key does not match the certificate public key\n");
		return 0;
	}
	return 1;
}

long
bio_dump_callback(BIO * bio, int cmd, const char *argp,
    int argi, long argl, long ret)
{
	BIO *out;

	out = (BIO *) BIO_get_callback_arg(bio);
	if (out == NULL)
		return (ret);

	if (cmd == (BIO_CB_READ | BIO_CB_RETURN)) {
		BIO_printf(out,
		    "read from %p [%p] (%lu bytes => %ld (0x%lX))\n",
		    (void *) bio, argp, (unsigned long) argi, ret, ret);
		BIO_dump(out, argp, (int) ret);
		return (ret);
	} else if (cmd == (BIO_CB_WRITE | BIO_CB_RETURN)) {
		BIO_printf(out,
		    "write to %p [%p] (%lu bytes => %ld (0x%lX))\n",
		    (void *) bio, argp, (unsigned long) argi, ret, ret);
		BIO_dump(out, argp, (int) ret);
	}
	return (ret);
}

void
apps_ssl_info_callback(const SSL * s, int where, int ret)
{
	const char *str;
	int w;

	w = where & ~SSL_ST_MASK;

	if (w & SSL_ST_CONNECT)
		str = "SSL_connect";
	else if (w & SSL_ST_ACCEPT)
		str = "SSL_accept";
	else
		str = "undefined";

	if (where & SSL_CB_LOOP) {
		BIO_printf(bio_err, "%s:%s\n", str, SSL_state_string_long(s));
	} else if (where & SSL_CB_ALERT) {
		str = (where & SSL_CB_READ) ? "read" : "write";
		BIO_printf(bio_err, "SSL3 alert %s:%s:%s\n", str,
		    SSL_alert_type_string_long(ret),
		    SSL_alert_desc_string_long(ret));
	} else if (where & SSL_CB_EXIT) {
		if (ret == 0)
			BIO_printf(bio_err, "%s:failed in %s\n",
			    str, SSL_state_string_long(s));
		else if (ret < 0) {
			BIO_printf(bio_err, "%s:error in %s\n",
			    str, SSL_state_string_long(s));
		}
	}
}


void
msg_cb(int write_p, int version, int content_type, const void *buf, size_t len, SSL * ssl, void *arg)
{
	BIO *bio = arg;
	const char *str_write_p, *str_version, *str_content_type = "",
	    *str_details1 = "", *str_details2 = "";

	str_write_p = write_p ? ">>>" : "<<<";

	switch (version) {
	case SSL2_VERSION:
		str_version = "SSL 2.0";
		break;
	case SSL3_VERSION:
		str_version = "SSL 3.0 ";
		break;
	case TLS1_VERSION:
		str_version = "TLS 1.0 ";
		break;
	case TLS1_1_VERSION:
		str_version = "TLS 1.1 ";
		break;
	case TLS1_2_VERSION:
		str_version = "TLS 1.2 ";
		break;
	case DTLS1_VERSION:
		str_version = "DTLS 1.0 ";
		break;
	case DTLS1_BAD_VER:
		str_version = "DTLS 1.0 (bad) ";
		break;
	default:
		str_version = "???";
	}

	if (version == SSL2_VERSION) {
		str_details1 = "???";

		if (len > 0) {
			switch (((const unsigned char *) buf)[0]) {
			case 0:
				str_details1 = ", ERROR:";
				str_details2 = " ???";
				if (len >= 3) {
					unsigned err = (((const unsigned char *) buf)[1] << 8) + ((const unsigned char *) buf)[2];

					switch (err) {
					case 0x0001:
						str_details2 = " NO-CIPHER-ERROR";
						break;
					case 0x0002:
						str_details2 = " NO-CERTIFICATE-ERROR";
						break;
					case 0x0004:
						str_details2 = " BAD-CERTIFICATE-ERROR";
						break;
					case 0x0006:
						str_details2 = " UNSUPPORTED-CERTIFICATE-TYPE-ERROR";
						break;
					}
				}
				break;
			case 1:
				str_details1 = ", CLIENT-HELLO";
				break;
			case 2:
				str_details1 = ", CLIENT-MASTER-KEY";
				break;
			case 3:
				str_details1 = ", CLIENT-FINISHED";
				break;
			case 4:
				str_details1 = ", SERVER-HELLO";
				break;
			case 5:
				str_details1 = ", SERVER-VERIFY";
				break;
			case 6:
				str_details1 = ", SERVER-FINISHED";
				break;
			case 7:
				str_details1 = ", REQUEST-CERTIFICATE";
				break;
			case 8:
				str_details1 = ", CLIENT-CERTIFICATE";
				break;
			}
		}
	}
	if (version == SSL3_VERSION || version == TLS1_VERSION ||
	    version == TLS1_1_VERSION || version == TLS1_2_VERSION ||
	    version == DTLS1_VERSION || version == DTLS1_BAD_VER) {
		switch (content_type) {
		case 20:
			str_content_type = "ChangeCipherSpec";
			break;
		case 21:
			str_content_type = "Alert";
			break;
		case 22:
			str_content_type = "Handshake";
			break;
		}

		if (content_type == 21) {	/* Alert */
			str_details1 = ", ???";

			if (len == 2) {
				switch (((const unsigned char *) buf)[0]) {
				case 1:
					str_details1 = ", warning";
					break;
				case 2:
					str_details1 = ", fatal";
					break;
				}

				str_details2 = " ???";
				switch (((const unsigned char *) buf)[1]) {
				case 0:
					str_details2 = " close_notify";
					break;
				case 10:
					str_details2 = " unexpected_message";
					break;
				case 20:
					str_details2 = " bad_record_mac";
					break;
				case 21:
					str_details2 = " decryption_failed";
					break;
				case 22:
					str_details2 = " record_overflow";
					break;
				case 30:
					str_details2 = " decompression_failure";
					break;
				case 40:
					str_details2 = " handshake_failure";
					break;
				case 42:
					str_details2 = " bad_certificate";
					break;
				case 43:
					str_details2 = " unsupported_certificate";
					break;
				case 44:
					str_details2 = " certificate_revoked";
					break;
				case 45:
					str_details2 = " certificate_expired";
					break;
				case 46:
					str_details2 = " certificate_unknown";
					break;
				case 47:
					str_details2 = " illegal_parameter";
					break;
				case 48:
					str_details2 = " unknown_ca";
					break;
				case 49:
					str_details2 = " access_denied";
					break;
				case 50:
					str_details2 = " decode_error";
					break;
				case 51:
					str_details2 = " decrypt_error";
					break;
				case 60:
					str_details2 = " export_restriction";
					break;
				case 70:
					str_details2 = " protocol_version";
					break;
				case 71:
					str_details2 = " insufficient_security";
					break;
				case 80:
					str_details2 = " internal_error";
					break;
				case 90:
					str_details2 = " user_canceled";
					break;
				case 100:
					str_details2 = " no_renegotiation";
					break;
				case 110:
					str_details2 = " unsupported_extension";
					break;
				case 111:
					str_details2 = " certificate_unobtainable";
					break;
				case 112:
					str_details2 = " unrecognized_name";
					break;
				case 113:
					str_details2 = " bad_certificate_status_response";
					break;
				case 114:
					str_details2 = " bad_certificate_hash_value";
					break;
				case 115:
					str_details2 = " unknown_psk_identity";
					break;
				}
			}
		}
		if (content_type == 22) {	/* Handshake */
			str_details1 = "???";

			if (len > 0) {
				switch (((const unsigned char *) buf)[0]) {
				case 0:
					str_details1 = ", HelloRequest";
					break;
				case 1:
					str_details1 = ", ClientHello";
					break;
				case 2:
					str_details1 = ", ServerHello";
					break;
				case 3:
					str_details1 = ", HelloVerifyRequest";
					break;
				case 11:
					str_details1 = ", Certificate";
					break;
				case 12:
					str_details1 = ", ServerKeyExchange";
					break;
				case 13:
					str_details1 = ", CertificateRequest";
					break;
				case 14:
					str_details1 = ", ServerHelloDone";
					break;
				case 15:
					str_details1 = ", CertificateVerify";
					break;
				case 16:
					str_details1 = ", ClientKeyExchange";
					break;
				case 20:
					str_details1 = ", Finished";
					break;
				}
			}
		}
	}
	BIO_printf(bio, "%s %s%s [length %04lx]%s%s\n", str_write_p,
	    str_version, str_content_type, (unsigned long) len,
	    str_details1, str_details2);

	if (len > 0) {
		size_t num, i;

		BIO_printf(bio, "   ");
		num = len;
#if 0
		if (num > 16)
			num = 16;
#endif
		for (i = 0; i < num; i++) {
			if (i % 16 == 0 && i > 0)
				BIO_printf(bio, "\n   ");
			BIO_printf(bio, " %02x",
			    ((const unsigned char *) buf)[i]);
		}
		if (i < len)
			BIO_printf(bio, " ...");
		BIO_printf(bio, "\n");
	}
	(void) BIO_flush(bio);
}

void
tlsext_cb(SSL * s, int client_server, int type, unsigned char *data, int len,
    void *arg)
{
	BIO *bio = arg;
	char *extname;

	switch (type) {
	case TLSEXT_TYPE_server_name:
		extname = "server name";
		break;

	case TLSEXT_TYPE_max_fragment_length:
		extname = "max fragment length";
		break;

	case TLSEXT_TYPE_client_certificate_url:
		extname = "client certificate URL";
		break;

	case TLSEXT_TYPE_trusted_ca_keys:
		extname = "trusted CA keys";
		break;

	case TLSEXT_TYPE_truncated_hmac:
		extname = "truncated HMAC";
		break;

	case TLSEXT_TYPE_status_request:
		extname = "status request";
		break;

	case TLSEXT_TYPE_user_mapping:
		extname = "user mapping";
		break;

	case TLSEXT_TYPE_client_authz:
		extname = "client authz";
		break;

	case TLSEXT_TYPE_server_authz:
		extname = "server authz";
		break;

	case TLSEXT_TYPE_cert_type:
		extname = "cert type";
		break;

	case TLSEXT_TYPE_elliptic_curves:
		extname = "elliptic curves";
		break;

	case TLSEXT_TYPE_ec_point_formats:
		extname = "EC point formats";
		break;

	case TLSEXT_TYPE_srp:
		extname = "SRP";
		break;

	case TLSEXT_TYPE_signature_algorithms:
		extname = "signature algorithms";
		break;

	case TLSEXT_TYPE_use_srtp:
		extname = "use SRTP";
		break;

	case TLSEXT_TYPE_heartbeat:
		extname = "heartbeat";
		break;

	case TLSEXT_TYPE_session_ticket:
		extname = "session ticket";
		break;

	case TLSEXT_TYPE_renegotiate:
		extname = "renegotiation info";
		break;

#ifdef TLSEXT_TYPE_next_proto_neg
	case TLSEXT_TYPE_next_proto_neg:
		extname = "next protocol";
		break;
#endif

	default:
		extname = "unknown";
		break;

	}

	BIO_printf(bio, "TLS %s extension \"%s\" (id=%d), len=%d\n",
	    client_server ? "server" : "client", extname, type, len);
	BIO_dump(bio, (char *) data, len);
	(void) BIO_flush(bio);
}

int
generate_cookie_callback(SSL * ssl, unsigned char *cookie,
    unsigned int *cookie_len)
{
	unsigned char *buffer, result[EVP_MAX_MD_SIZE];
	unsigned int length, resultlength;
	union {
		struct sockaddr sa;
		struct sockaddr_in s4;
		struct sockaddr_in6 s6;
	} peer;

	/* Initialize a random secret */
	if (!cookie_initialized) {
		if (!RAND_bytes(cookie_secret, COOKIE_SECRET_LENGTH)) {
			BIO_printf(bio_err,
			    "error setting random cookie secret\n");
			return 0;
		}
		cookie_initialized = 1;
	}
	/* Read peer information */
	(void) BIO_dgram_get_peer(SSL_get_rbio(ssl), &peer);

	/* Create buffer with peer's address and port */
	length = 0;
	switch (peer.sa.sa_family) {
	case AF_INET:
		length += sizeof(struct in_addr);
		length += sizeof(peer.s4.sin_port);
		break;
	case AF_INET6:
		length += sizeof(struct in6_addr);
		length += sizeof(peer.s6.sin6_port);
		break;
	default:
		OPENSSL_assert(0);
		break;
	}
	buffer = malloc(length);

	if (buffer == NULL) {
		BIO_printf(bio_err, "out of memory\n");
		return 0;
	}
	switch (peer.sa.sa_family) {
	case AF_INET:
		memcpy(buffer, &peer.s4.sin_port, sizeof(peer.s4.sin_port));
		memcpy(buffer + sizeof(peer.s4.sin_port),
		    &peer.s4.sin_addr, sizeof(struct in_addr));
		break;
	case AF_INET6:
		memcpy(buffer, &peer.s6.sin6_port, sizeof(peer.s6.sin6_port));
		memcpy(buffer + sizeof(peer.s6.sin6_port),
		    &peer.s6.sin6_addr, sizeof(struct in6_addr));
		break;
	default:
		OPENSSL_assert(0);
		break;
	}

	/* Calculate HMAC of buffer using the secret */
	HMAC(EVP_sha1(), cookie_secret, COOKIE_SECRET_LENGTH,
	    buffer, length, result, &resultlength);
	free(buffer);

	memcpy(cookie, result, resultlength);
	*cookie_len = resultlength;

	return 1;
}

int
verify_cookie_callback(SSL * ssl, unsigned char *cookie, unsigned int cookie_len)
{
	unsigned char *buffer, result[EVP_MAX_MD_SIZE];
	unsigned int length, resultlength;
	union {
		struct sockaddr sa;
		struct sockaddr_in s4;
		struct sockaddr_in6 s6;
	} peer;

	/* If secret isn't initialized yet, the cookie can't be valid */
	if (!cookie_initialized)
		return 0;

	/* Read peer information */
	(void) BIO_dgram_get_peer(SSL_get_rbio(ssl), &peer);

	/* Create buffer with peer's address and port */
	length = 0;
	switch (peer.sa.sa_family) {
	case AF_INET:
		length += sizeof(struct in_addr);
		length += sizeof(peer.s4.sin_port);
		break;
	case AF_INET6:
		length += sizeof(struct in6_addr);
		length += sizeof(peer.s6.sin6_port);
		break;
	default:
		OPENSSL_assert(0);
		break;
	}
	buffer = malloc(length);

	if (buffer == NULL) {
		BIO_printf(bio_err, "out of memory\n");
		return 0;
	}
	switch (peer.sa.sa_family) {
	case AF_INET:
		memcpy(buffer, &peer.s4.sin_port, sizeof(peer.s4.sin_port));
		memcpy(buffer + sizeof(peer.s4.sin_port),
		    &peer.s4.sin_addr, sizeof(struct in_addr));
		break;
	case AF_INET6:
		memcpy(buffer, &peer.s6.sin6_port, sizeof(peer.s6.sin6_port));
		memcpy(buffer + sizeof(peer.s6.sin6_port),
		    &peer.s6.sin6_addr, sizeof(struct in6_addr));
		break;
	default:
		OPENSSL_assert(0);
		break;
	}

	/* Calculate HMAC of buffer using the secret */
	HMAC(EVP_sha1(), cookie_secret, COOKIE_SECRET_LENGTH,
	    buffer, length, result, &resultlength);
	free(buffer);

	if (cookie_len == resultlength &&
	    memcmp(result, cookie, resultlength) == 0)
		return 1;

	return 0;
}
@


1.22
log
@Remove support for the `opaque PRF input' extension, which draft has expired
7 years ago and never made it into an RFC. That code wasn't compiled in
anyway unless one would define the actual on-the-wire extension id bytes;
crank libssl major.

With help and enlightenment from Brendan MacDonell.
@
text
@d1 1
a1 1
/* $OpenBSD: s_cb.c,v 1.21 2014/06/12 15:49:27 deraadt Exp $ */
@


1.21
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a698 5
#ifdef TLSEXT_TYPE_opaque_prf_input
	case TLSEXT_TYPE_opaque_prf_input:
		extname = "opaque PRF input";
		break;
#endif
@


1.20
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d1 1
a1 1
/* apps/s_cb.c - callback functions used by s_client, s_server, and s_time */
@


1.19
log
@add missing header needed for mem{cpy,cmp}()

ok tedu@@
@
text
@d112 5
a119 3
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
d122 1
d125 1
d127 1
a127 1
#include <openssl/ssl.h>
@


1.18
log
@NON_MAIN no longer means anything so remove it, along with APP_INIT.

ok miod@@
@
text
@d114 1
@


1.17
log
@More KNF.
@
text
@a117 1
#define NON_MAIN
a118 1
#undef NON_MAIN
@


1.16
log
@Put the final pieces from e_os.h in the required places, and remove it.
"dance on it's grave" says beck
ok guenther beck
@
text
@d204 1
a204 1
			SSL_FILETYPE_PEM) <= 0) {
d213 1
a213 1
			SSL_FILETYPE_PEM) <= 0) {
d344 1
a344 1
	*str_details1 = "", *str_details2 = "";
@


1.15
log
@KaboomNF
@
text
@a727 1
#if OPENSSL_USE_IPV6
a728 1
#endif
a749 1
#if OPENSSL_USE_IPV6
a753 1
#endif
a769 1
#if OPENSSL_USE_IPV6
a774 1
#endif
a798 1
#if OPENSSL_USE_IPV6
a799 1
#endif
a815 1
#if OPENSSL_USE_IPV6
a819 1
#endif
a835 1
#if OPENSSL_USE_IPV6
a840 1
#endif
@


1.14
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d136 1
a136 1
verify_callback(int ok, X509_STORE_CTX *ctx)
d195 1
a195 1
set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file)
d204 1
a204 1
		    SSL_FILETYPE_PEM) <= 0) {
d213 1
a213 1
		    SSL_FILETYPE_PEM) <= 0) {
a218 1

d234 4
a237 2
		/* If we are using DSA, we can copy the parameters from
		 * the private key */
d240 4
a243 2
		/* Now we know that a key and cert have been set against
		 * the SSL context */
d254 1
a254 1
set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key)
d256 1
a256 1
	if (cert ==  NULL)
d268 4
a271 3

	/* Now we know that a key and cert have been set against
	 * the SSL context */
d281 1
a281 1
bio_dump_callback(BIO *bio, int cmd, const char *argp,
d286 1
a286 1
	out = (BIO *)BIO_get_callback_arg(bio);
d290 1
a290 1
	if (cmd == (BIO_CB_READ|BIO_CB_RETURN)) {
d293 2
a294 2
		    (void *)bio, argp, (unsigned long)argi, ret, ret);
		BIO_dump(out, argp, (int)ret);
d296 1
a296 1
	} else if (cmd == (BIO_CB_WRITE|BIO_CB_RETURN)) {
d299 2
a300 2
		    (void *)bio, argp, (unsigned long)argi, ret, ret);
		BIO_dump(out, argp, (int)ret);
d306 1
a306 1
apps_ssl_info_callback(const SSL *s, int where, int ret)
d340 1
a340 1
msg_cb(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg)
d343 2
a344 1
	const char *str_write_p, *str_version, *str_content_type = "", *str_details1 = "", *str_details2 = "";
d378 1
a378 1
			switch (((const unsigned char*)buf)[0]) {
d383 1
a383 1
					unsigned err = (((const unsigned char*)buf)[1]<<8) + ((const unsigned char*)buf)[2];
a399 1

a427 1

d443 1
a443 2
		if (content_type == 21) /* Alert */
		{
d447 1
a447 1
				switch (((const unsigned char*)buf)[0]) {
d457 1
a457 1
				switch (((const unsigned char*)buf)[1]) {
d548 1
a548 3

		if (content_type == 22) /* Handshake */
		{
d552 1
a552 1
				switch (((const unsigned char*)buf)[0]) {
a589 1

d591 1
a591 1
	    str_version, str_content_type, (unsigned long)len,
d607 1
a607 1
			    ((const unsigned char*)buf)[i]);
d613 1
a613 1
	(void)BIO_flush(bio);
d617 1
a617 1
tlsext_cb(SSL *s, int client_server, int type, unsigned char *data, int len,
d715 2
a716 2
	BIO_dump(bio, (char *)data, len);
	(void)BIO_flush(bio);
d720 1
a720 1
generate_cookie_callback(SSL *ssl, unsigned char *cookie,
a741 1

d743 1
a743 1
	(void)BIO_dgram_get_peer(SSL_get_rbio(ssl), &peer);
a767 1

d798 1
a798 1
verify_cookie_callback(SSL *ssl, unsigned char *cookie, unsigned int cookie_len)
d815 1
a815 1
	(void)BIO_dgram_get_peer(SSL_get_rbio(ssl), &peer);
a839 1

@


1.13
log
@Initial KNF.
@
text
@d114 4
a117 1
#define USE_SOCKETS
a120 1
#undef USE_SOCKETS
@


1.12
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d127 3
a129 3
int verify_depth=0;
int verify_error=X509_V_OK;
int verify_return_error=0;
d131 1
a131 1
int cookie_initialized=0;
d133 3
a135 2
int verify_callback(int ok, X509_STORE_CTX *ctx)
	{
d137 1
a137 1
	int err,depth;
d139 3
a141 3
	err_cert=X509_STORE_CTX_get_current_cert(ctx);
	err=	X509_STORE_CTX_get_error(ctx);
	depth=	X509_STORE_CTX_get_error_depth(ctx);
d143 2
a144 3
	BIO_printf(bio_err,"depth=%d ",depth);
	if (err_cert)
		{
d146 1
a146 1
					0, XN_FLAG_ONELINE);
d148 1
a148 2
		}
	else
d150 4
a153 6
	if (!ok)
		{
		BIO_printf(bio_err,"verify error:num=%d:%s\n",err,
			X509_verify_cert_error_string(err));
		if (verify_depth >= depth)
			{
d155 5
a159 8
				ok=1;
			verify_error=X509_V_OK;
			}
		else
			{
			ok=0;
			verify_error=X509_V_ERR_CERT_CHAIN_TOO_LONG;
			}
d161 2
a162 2
	switch (err)
		{
d164 1
a164 1
		BIO_puts(bio_err,"issuer= ");
d166 1
a166 1
					0, XN_FLAG_ONELINE);
d171 3
a173 3
		BIO_printf(bio_err,"notBefore=");
		ASN1_TIME_print(bio_err,X509_get_notBefore(err_cert));
		BIO_printf(bio_err,"\n");
d177 3
a179 3
		BIO_printf(bio_err,"notAfter=");
		ASN1_TIME_print(bio_err,X509_get_notAfter(err_cert));
		BIO_printf(bio_err,"\n");
d184 1
a184 1
		}
d188 8
a195 8
	BIO_printf(bio_err,"verify return:%d\n",ok);
	return(ok);
	}

int set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file)
	{
	if (cert_file != NULL)
		{
d201 4
a204 4
		if (SSL_CTX_use_certificate_file(ctx,cert_file,
			SSL_FILETYPE_PEM) <= 0)
			{
			BIO_printf(bio_err,"unable to get certificate from '%s'\n",cert_file);
d206 8
a213 7
			return(0);
			}
		if (key_file == NULL) key_file=cert_file;
		if (SSL_CTX_use_PrivateKey_file(ctx,key_file,
			SSL_FILETYPE_PEM) <= 0)
			{
			BIO_printf(bio_err,"unable to get private key from '%s'\n",key_file);
d215 2
a216 2
			return(0);
			}
d219 1
a219 1
		In theory this is no longer needed 
d239 4
a242 5
		if (!SSL_CTX_check_private_key(ctx))
			{
			BIO_printf(bio_err,"Private key does not match the certificate public key\n");
			return(0);
			}
a243 1
	return(1);
d245 2
d248 3
a250 2
int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key)
	{
d253 2
a254 3
	if (SSL_CTX_use_certificate(ctx,cert) <= 0)
		{
		BIO_printf(bio_err,"error setting certificate\n");
d257 3
a259 4
		}
	if (SSL_CTX_use_PrivateKey(ctx,key) <= 0)
		{
		BIO_printf(bio_err,"error setting private key\n");
d262 1
a262 1
		}
d264 5
a268 6
		
		/* Now we know that a key and cert have been set against
		 * the SSL context */
	if (!SSL_CTX_check_private_key(ctx))
		{
		BIO_printf(bio_err,"Private key does not match the certificate public key\n");
d270 1
a270 1
		}
d272 1
a272 1
	}
d274 4
a277 3
long bio_dump_callback(BIO *bio, int cmd, const char *argp,
				   int argi, long argl, long ret)
	{
d280 15
a294 17
	out=(BIO *)BIO_get_callback_arg(bio);
	if (out == NULL) return(ret);

	if (cmd == (BIO_CB_READ|BIO_CB_RETURN))
		{
		BIO_printf(out,"read from %p [%p] (%lu bytes => %ld (0x%lX))\n",
 			(void *)bio,argp,(unsigned long)argi,ret,ret);
		BIO_dump(out,argp,(int)ret);
		return(ret);
		}
	else if (cmd == (BIO_CB_WRITE|BIO_CB_RETURN))
		{
		BIO_printf(out,"write to %p [%p] (%lu bytes => %ld (0x%lX))\n",
			(void *)bio,argp,(unsigned long)argi,ret,ret);
		BIO_dump(out,argp,(int)ret);
		}
	return(ret);
d296 2
d299 3
a301 2
void apps_ssl_info_callback(const SSL *s, int where, int ret)
	{
d305 1
a305 1
	w=where& ~SSL_ST_MASK;
d307 6
a312 3
	if (w & SSL_ST_CONNECT) str="SSL_connect";
	else if (w & SSL_ST_ACCEPT) str="SSL_accept";
	else str="undefined";
d314 8
a321 14
	if (where & SSL_CB_LOOP)
		{
		BIO_printf(bio_err,"%s:%s\n",str,SSL_state_string_long(s));
		}
	else if (where & SSL_CB_ALERT)
		{
		str=(where & SSL_CB_READ)?"read":"write";
		BIO_printf(bio_err,"SSL3 alert %s:%s:%s\n",
			str,
			SSL_alert_type_string_long(ret),
			SSL_alert_desc_string_long(ret));
		}
	else if (where & SSL_CB_EXIT)
		{
d323 5
a327 7
			BIO_printf(bio_err,"%s:failed in %s\n",
				str,SSL_state_string_long(s));
		else if (ret < 0)
			{
			BIO_printf(bio_err,"%s:error in %s\n",
				str,SSL_state_string_long(s));
			}
d330 1
d333 3
a335 2
void msg_cb(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg)
	{
d337 2
a338 2
	const char *str_write_p, *str_version, *str_content_type = "", *str_details1 = "", *str_details2= "";
	
d341 1
a341 2
	switch (version)
		{
d365 1
a365 1
		}
d367 1
a367 2
	if (version == SSL2_VERSION)
		{
d370 7
a376 27
		if (len > 0)
			{
			switch (((const unsigned char*)buf)[0])
				{
				case 0:
					str_details1 = ", ERROR:";
					str_details2 = " ???";
					if (len >= 3)
						{
						unsigned err = (((const unsigned char*)buf)[1]<<8) + ((const unsigned char*)buf)[2];
						
						switch (err)
							{
						case 0x0001:
							str_details2 = " NO-CIPHER-ERROR";
							break;
						case 0x0002:
							str_details2 = " NO-CERTIFICATE-ERROR";
							break;
						case 0x0004:
							str_details2 = " BAD-CERTIFICATE-ERROR";
							break;
						case 0x0006:
							str_details2 = " UNSUPPORTED-CERTIFICATE-TYPE-ERROR";
							break;
							}
						}
d378 14
a391 25
					break;
				case 1:
					str_details1 = ", CLIENT-HELLO";
					break;
				case 2:
					str_details1 = ", CLIENT-MASTER-KEY";
					break;
				case 3:
					str_details1 = ", CLIENT-FINISHED";
					break;
				case 4:
					str_details1 = ", SERVER-HELLO";
					break;
				case 5:
					str_details1 = ", SERVER-VERIFY";
					break;
				case 6:
					str_details1 = ", SERVER-FINISHED";
					break;
				case 7:
					str_details1 = ", REQUEST-CERTIFICATE";
					break;
				case 8:
					str_details1 = ", CLIENT-CERTIFICATE";
					break;
d393 26
d421 1
d423 4
a426 9
	if (version == SSL3_VERSION ||
	    version == TLS1_VERSION ||
	    version == TLS1_1_VERSION ||
	    version == TLS1_2_VERSION ||
	    version == DTLS1_VERSION ||
	    version == DTLS1_BAD_VER)
		{
		switch (content_type)
			{
d436 1
a436 1
			}
d439 1
a439 1
			{
d441 3
a443 5
			
			if (len == 2)
				{
				switch (((const unsigned char*)buf)[0])
					{
d450 1
a450 1
					}
d453 1
a453 2
				switch (((const unsigned char*)buf)[1])
					{
a540 1
					}
d543 2
a544 1
		
d546 1
a546 1
			{
d549 2
a550 4
			if (len > 0)
				{
				switch (((const unsigned char*)buf)[0])
					{
a583 1
					}
d587 1
d589 3
a591 1
	BIO_printf(bio, "%s %s%s [length %04lx]%s%s\n", str_write_p, str_version, str_content_type, (unsigned long)len, str_details1, str_details2);
d593 1
a593 2
	if (len > 0)
		{
d595 1
a595 1
		
d602 1
a602 2
		for (i = 0; i < num; i++)
			{
d605 3
a607 2
			BIO_printf(bio, " %02x", ((const unsigned char*)buf)[i]);
			}
d611 1
a611 1
		}
d613 1
a613 1
	}
d615 4
a618 4
void tlsext_cb(SSL *s, int client_server, int type,
					unsigned char *data, int len,
					void *arg)
	{
d622 2
a623 3
	switch(type)
		{
		case TLSEXT_TYPE_server_name:
d627 1
a627 1
		case TLSEXT_TYPE_max_fragment_length:
d631 1
a631 1
		case TLSEXT_TYPE_client_certificate_url:
d635 1
a635 1
		case TLSEXT_TYPE_trusted_ca_keys:
d639 1
a639 1
		case TLSEXT_TYPE_truncated_hmac:
d643 1
a643 1
		case TLSEXT_TYPE_status_request:
d647 1
a647 1
		case TLSEXT_TYPE_user_mapping:
d651 1
a651 1
		case TLSEXT_TYPE_client_authz:
d655 1
a655 1
		case TLSEXT_TYPE_server_authz:
d659 1
a659 1
		case TLSEXT_TYPE_cert_type:
d663 1
a663 1
		case TLSEXT_TYPE_elliptic_curves:
d667 1
a667 1
		case TLSEXT_TYPE_ec_point_formats:
d671 1
a671 1
		case TLSEXT_TYPE_srp:
d675 1
a675 1
		case TLSEXT_TYPE_signature_algorithms:
d679 1
a679 1
		case TLSEXT_TYPE_use_srtp:
d683 1
a683 1
		case TLSEXT_TYPE_heartbeat:
d687 1
a687 1
		case TLSEXT_TYPE_session_ticket:
d691 1
a691 1
		case TLSEXT_TYPE_renegotiate: 
d696 1
a696 1
		case TLSEXT_TYPE_opaque_prf_input:
d701 1
a701 1
		case TLSEXT_TYPE_next_proto_neg:
d706 1
a706 1
		default:
d710 2
a711 2
		}
	
d713 1
a713 2
			client_server ? "server": "client",
			extname, type, len);
d716 1
a716 1
	}
d718 4
a721 2
int generate_cookie_callback(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len)
	{
d733 4
a736 5
	if (!cookie_initialized)
		{
		if (!RAND_bytes(cookie_secret, COOKIE_SECRET_LENGTH))
			{
			BIO_printf(bio_err,"error setting random cookie secret\n");
d738 1
a738 1
			}
d740 1
a740 1
		}
d747 1
a747 2
	switch (peer.sa.sa_family)
		{
d761 1
a761 1
		}
d764 2
a765 3
	if (buffer == NULL)
		{
		BIO_printf(bio_err,"out of memory\n");
d767 1
a767 1
		}
d769 1
a769 2
	switch (peer.sa.sa_family)
		{
d771 1
a771 3
		memcpy(buffer,
		       &peer.s4.sin_port,
		       sizeof(peer.s4.sin_port));
d773 1
a773 2
		       &peer.s4.sin_addr,
		       sizeof(struct in_addr));
d777 1
a777 3
		memcpy(buffer,
		       &peer.s6.sin6_port,
		       sizeof(peer.s6.sin6_port));
d779 1
a779 2
		       &peer.s6.sin6_addr,
		       sizeof(struct in6_addr));
d785 1
a785 1
		}
d789 1
a789 1
	     buffer, length, result, &resultlength);
d796 1
a796 1
	}
d798 3
a800 2
int verify_cookie_callback(SSL *ssl, unsigned char *cookie, unsigned int cookie_len)
	{
d820 1
a820 2
	switch (peer.sa.sa_family)
		{
d834 1
a834 1
		}
d836 3
a838 4
	
	if (buffer == NULL)
		{
		BIO_printf(bio_err,"out of memory\n");
d840 1
a840 1
		}
d842 1
a842 2
	switch (peer.sa.sa_family)
		{
d844 1
a844 3
		memcpy(buffer,
		       &peer.s4.sin_port,
		       sizeof(peer.s4.sin_port));
d846 1
a846 2
		       &peer.s4.sin_addr,
		       sizeof(struct in_addr));
d850 1
a850 3
		memcpy(buffer,
		       &peer.s6.sin6_port,
		       sizeof(peer.s6.sin6_port));
d852 1
a852 2
		       &peer.s6.sin6_addr,
		       sizeof(struct in6_addr));
d858 1
a858 1
		}
d862 1
a862 1
	     buffer, length, result, &resultlength);
d865 2
a866 1
	if (cookie_len == resultlength && memcmp(result, cookie, resultlength) == 0)
d870 1
a870 1
	}
@


1.11
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@d787 1
a787 1
	buffer = OPENSSL_malloc(length);
d823 1
a823 1
	OPENSSL_free(buffer);
d868 1
a868 1
	buffer = OPENSSL_malloc(length);
d904 1
a904 1
	OPENSSL_free(buffer);
@


1.10
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@a610 20

#ifndef OPENSSL_NO_HEARTBEATS
		if (content_type == 24) /* Heartbeat */
			{
			str_details1 = ", Heartbeat";
			
			if (len > 0)
				{
				switch (((const unsigned char*)buf)[0])
					{
				case 1:
					str_details1 = ", HeartbeatRequest";
					break;
				case 2:
					str_details1 = ", HeartbeatResponse";
					break;
					}
				}
			}
#endif
@


1.9
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d133 1
a133 1
int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx)
d281 1
a281 1
long MS_CALLBACK bio_dump_callback(BIO *bio, int cmd, const char *argp,
d305 1
a305 1
void MS_CALLBACK apps_ssl_info_callback(const SSL *s, int where, int ret)
d342 1
a342 1
void MS_CALLBACK msg_cb(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg)
d658 1
a658 1
void MS_CALLBACK tlsext_cb(SSL *s, int client_server, int type,
d763 1
a763 1
int MS_CALLBACK generate_cookie_callback(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len)
d851 1
a851 1
int MS_CALLBACK verify_cookie_callback(SSL *ssl, unsigned char *cookie, unsigned int cookie_len)
@


1.8
log
@resolve conflicts
@
text
@d240 2
a241 2
		
		
d439 2
@


1.7
log
@resolve conflicts, fix local changes
@
text
@d360 6
d558 3
d609 20
d689 16
d713 16
d730 1
a730 1
		extname = "server ticket";
d733 2
a734 2
		case TLSEXT_TYPE_renegotiate:
		extname = "renegotiate";
d740 5
@


1.6
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d120 1
d125 2
d129 3
a134 1
	char buf[256];
d142 9
a150 2
	X509_NAME_oneline(X509_get_subject_name(err_cert),buf,sizeof buf);
	BIO_printf(bio_err,"depth=%d %s\n",depth,buf);
d157 2
a158 1
			ok=1;
d167 1
a167 1
	switch (ctx->error)
d170 4
a173 2
		X509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,sizeof buf);
		BIO_printf(bio_err,"issuer= %s\n",buf);
d178 1
a178 1
		ASN1_TIME_print(bio_err,X509_get_notBefore(ctx->current_cert));
d184 1
a184 1
		ASN1_TIME_print(bio_err,X509_get_notAfter(ctx->current_cert));
d187 3
d191 3
d282 1
a282 1
	int argi, long argl, long ret)
d291 2
a292 2
		BIO_printf(out,"read from %p [%p] (%d bytes => %ld (0x%lX))\n",
 			(void *)bio,argp,argi,ret,ret);
d298 2
a299 2
		BIO_printf(out,"write to %p [%p] (%d bytes => %ld (0x%lX))\n",
			(void *)bio,argp,argi,ret,ret);
d360 6
d431 4
a434 1
	if (version == SSL3_VERSION || version == TLS1_VERSION)
d537 15
d573 3
d672 9
d693 169
@


1.5
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d232 30
a261 2
long MS_CALLBACK bio_dump_cb(BIO *bio, int cmd, const char *argp, int argi,
	     long argl, long ret)
d270 2
a271 2
		BIO_printf(out,"read from %08X [%08lX] (%d bytes => %ld (0x%X))\n",
			bio,argp,argi,ret,ret);
d277 2
a278 2
		BIO_printf(out,"write to %08X [%08lX] (%d bytes => %ld (0x%X))\n",
			bio,argp,argi,ret,ret);
d286 1
a286 1
	char *str;
d349 1
a349 1
			switch (((unsigned char*)buf)[0])
d356 1
a356 1
						unsigned err = (((unsigned char*)buf)[1]<<8) + ((unsigned char*)buf)[2];
d425 1
a425 1
				switch (((unsigned char*)buf)[0])
d436 1
a436 1
				switch (((unsigned char*)buf)[1])
d517 1
a517 1
				switch (((unsigned char*)buf)[0])
d570 1
a570 1
			BIO_printf(bio, " %02x", ((unsigned char*)buf)[i]);
d576 60
a635 1
	BIO_flush(bio);
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d137 1
a137 1
	X509_NAME_oneline(X509_get_subject_name(err_cert),buf,256);
d157 1
a157 1
		X509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,256);
@


1.3
log
@OpenSSL 0.9.5a merge
@
text
@d58 53
d256 1
a256 1
void MS_CALLBACK apps_ssl_info_callback(SSL *s, int where, int ret)
d292 258
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d1 1
a1 1
/* apps/s_cb.c */
@


1.1
log
@Initial revision
@
text
@d66 3
a68 3
#include "err.h"
#include "x509.h"
#include "ssl.h"
d74 1
a74 3
int MS_CALLBACK verify_callback(ok, ctx)
int ok;
X509_STORE_CTX *ctx;
d110 1
a110 1
		ASN1_UTCTIME_print(bio_err,X509_get_notBefore(ctx->current_cert));
d116 1
a116 1
		ASN1_UTCTIME_print(bio_err,X509_get_notAfter(ctx->current_cert));
d124 1
a124 4
int set_cert_stuff(ctx, cert_file, key_file)
SSL_CTX *ctx;
char *cert_file;
char *key_file;
d128 1
d131 1
d149 2
d154 7
a160 3
		if (x509 != NULL)
			EVP_PKEY_copy_parameters(X509_get_pubkey(x509),
				SSL_get_privatekey(ssl));
d162 1
d179 2
a180 7
long MS_CALLBACK bio_dump_cb(bio,cmd,argp,argi,argl,ret)
BIO *bio;
int cmd;
char *argp;
int argi;
long argl;
long ret;
d203 1
a203 4
void MS_CALLBACK apps_ssl_info_callback(s,where,ret)
SSL *s;
int where;
int ret;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 1
/* apps/s_cb.c - callback functions used by s_client, s_server, and s_time */
a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d66 3
a68 3
#include <openssl/err.h>
#include <openssl/x509.h>
#include <openssl/ssl.h>
d74 3
a76 1
int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx)
d112 1
a112 1
		ASN1_TIME_print(bio_err,X509_get_notBefore(ctx->current_cert));
d118 1
a118 1
		ASN1_TIME_print(bio_err,X509_get_notAfter(ctx->current_cert));
d126 4
a129 1
int set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file)
a132 1
		/*
a134 1
		*/
a151 2
		/*
		In theory this is no longer needed 
d155 3
a157 7
		if (x509 != NULL) {
			EVP_PKEY *pktmp;
			pktmp = X509_get_pubkey(x509);
			EVP_PKEY_copy_parameters(pktmp,
						SSL_get_privatekey(ssl));
			EVP_PKEY_free(pktmp);
		}
a158 1
		*/
d175 7
a181 2
long MS_CALLBACK bio_dump_cb(BIO *bio, int cmd, const char *argp, int argi,
	     long argl, long ret)
d204 4
a207 1
void MS_CALLBACK apps_ssl_info_callback(const SSL *s, int where, int ret)
a242 258

void MS_CALLBACK msg_cb(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg)
	{
	BIO *bio = arg;
	const char *str_write_p, *str_version, *str_content_type = "", *str_details1 = "", *str_details2= "";
	
	str_write_p = write_p ? ">>>" : "<<<";

	switch (version)
		{
	case SSL2_VERSION:
		str_version = "SSL 2.0";
		break;
	case SSL3_VERSION:
		str_version = "SSL 3.0 ";
		break;
	case TLS1_VERSION:
		str_version = "TLS 1.0 ";
		break;
	default:
		str_version = "???";
		}

	if (version == SSL2_VERSION)
		{
		str_details1 = "???";

		if (len > 0)
			{
			switch (((unsigned char*)buf)[0])
				{
				case 0:
					str_details1 = ", ERROR:";
					str_details2 = " ???";
					if (len >= 3)
						{
						unsigned err = (((unsigned char*)buf)[1]<<8) + ((unsigned char*)buf)[2];
						
						switch (err)
							{
						case 0x0001:
							str_details2 = " NO-CIPHER-ERROR";
							break;
						case 0x0002:
							str_details2 = " NO-CERTIFICATE-ERROR";
							break;
						case 0x0004:
							str_details2 = " BAD-CERTIFICATE-ERROR";
							break;
						case 0x0006:
							str_details2 = " UNSUPPORTED-CERTIFICATE-TYPE-ERROR";
							break;
							}
						}

					break;
				case 1:
					str_details1 = ", CLIENT-HELLO";
					break;
				case 2:
					str_details1 = ", CLIENT-MASTER-KEY";
					break;
				case 3:
					str_details1 = ", CLIENT-FINISHED";
					break;
				case 4:
					str_details1 = ", SERVER-HELLO";
					break;
				case 5:
					str_details1 = ", SERVER-VERIFY";
					break;
				case 6:
					str_details1 = ", SERVER-FINISHED";
					break;
				case 7:
					str_details1 = ", REQUEST-CERTIFICATE";
					break;
				case 8:
					str_details1 = ", CLIENT-CERTIFICATE";
					break;
				}
			}
		}

	if (version == SSL3_VERSION || version == TLS1_VERSION)
		{
		switch (content_type)
			{
		case 20:
			str_content_type = "ChangeCipherSpec";
			break;
		case 21:
			str_content_type = "Alert";
			break;
		case 22:
			str_content_type = "Handshake";
			break;
			}

		if (content_type == 21) /* Alert */
			{
			str_details1 = ", ???";
			
			if (len == 2)
				{
				switch (((unsigned char*)buf)[0])
					{
				case 1:
					str_details1 = ", warning";
					break;
				case 2:
					str_details1 = ", fatal";
					break;
					}

				str_details2 = " ???";
				switch (((unsigned char*)buf)[1])
					{
				case 0:
					str_details2 = " close_notify";
					break;
				case 10:
					str_details2 = " unexpected_message";
					break;
				case 20:
					str_details2 = " bad_record_mac";
					break;
				case 21:
					str_details2 = " decryption_failed";
					break;
				case 22:
					str_details2 = " record_overflow";
					break;
				case 30:
					str_details2 = " decompression_failure";
					break;
				case 40:
					str_details2 = " handshake_failure";
					break;
				case 42:
					str_details2 = " bad_certificate";
					break;
				case 43:
					str_details2 = " unsupported_certificate";
					break;
				case 44:
					str_details2 = " certificate_revoked";
					break;
				case 45:
					str_details2 = " certificate_expired";
					break;
				case 46:
					str_details2 = " certificate_unknown";
					break;
				case 47:
					str_details2 = " illegal_parameter";
					break;
				case 48:
					str_details2 = " unknown_ca";
					break;
				case 49:
					str_details2 = " access_denied";
					break;
				case 50:
					str_details2 = " decode_error";
					break;
				case 51:
					str_details2 = " decrypt_error";
					break;
				case 60:
					str_details2 = " export_restriction";
					break;
				case 70:
					str_details2 = " protocol_version";
					break;
				case 71:
					str_details2 = " insufficient_security";
					break;
				case 80:
					str_details2 = " internal_error";
					break;
				case 90:
					str_details2 = " user_canceled";
					break;
				case 100:
					str_details2 = " no_renegotiation";
					break;
					}
				}
			}
		
		if (content_type == 22) /* Handshake */
			{
			str_details1 = "???";

			if (len > 0)
				{
				switch (((unsigned char*)buf)[0])
					{
				case 0:
					str_details1 = ", HelloRequest";
					break;
				case 1:
					str_details1 = ", ClientHello";
					break;
				case 2:
					str_details1 = ", ServerHello";
					break;
				case 11:
					str_details1 = ", Certificate";
					break;
				case 12:
					str_details1 = ", ServerKeyExchange";
					break;
				case 13:
					str_details1 = ", CertificateRequest";
					break;
				case 14:
					str_details1 = ", ServerHelloDone";
					break;
				case 15:
					str_details1 = ", CertificateVerify";
					break;
				case 16:
					str_details1 = ", ClientKeyExchange";
					break;
				case 20:
					str_details1 = ", Finished";
					break;
					}
				}
			}
		}

	BIO_printf(bio, "%s %s%s [length %04lx]%s%s\n", str_write_p, str_version, str_content_type, (unsigned long)len, str_details1, str_details2);

	if (len > 0)
		{
		size_t num, i;
		
		BIO_printf(bio, "   ");
		num = len;
#if 0
		if (num > 16)
			num = 16;
#endif
		for (i = 0; i < num; i++)
			{
			if (i % 16 == 0 && i > 0)
				BIO_printf(bio, "\n   ");
			BIO_printf(bio, " %02x", ((unsigned char*)buf)[i]);
			}
		if (i < len)
			BIO_printf(bio, " ...");
		BIO_printf(bio, "\n");
		}
	BIO_flush(bio);
	}
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d137 1
a137 1
	X509_NAME_oneline(X509_get_subject_name(err_cert),buf,sizeof buf);
d157 1
a157 1
		X509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,sizeof buf);
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d232 2
a233 30
int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key)
	{
	if (cert ==  NULL)
		return 1;
	if (SSL_CTX_use_certificate(ctx,cert) <= 0)
		{
		BIO_printf(bio_err,"error setting certificate\n");
		ERR_print_errors(bio_err);
		return 0;
		}
	if (SSL_CTX_use_PrivateKey(ctx,key) <= 0)
		{
		BIO_printf(bio_err,"error setting private key\n");
		ERR_print_errors(bio_err);
		return 0;
		}

		
		/* Now we know that a key and cert have been set against
		 * the SSL context */
	if (!SSL_CTX_check_private_key(ctx))
		{
		BIO_printf(bio_err,"Private key does not match the certificate public key\n");
		return 0;
		}
	return 1;
	}

long MS_CALLBACK bio_dump_callback(BIO *bio, int cmd, const char *argp,
	int argi, long argl, long ret)
d242 2
a243 2
		BIO_printf(out,"read from %p [%p] (%d bytes => %ld (0x%lX))\n",
 			(void *)bio,argp,argi,ret,ret);
d249 2
a250 2
		BIO_printf(out,"write to %p [%p] (%d bytes => %ld (0x%lX))\n",
			(void *)bio,argp,argi,ret,ret);
d258 1
a258 1
	const char *str;
d321 1
a321 1
			switch (((const unsigned char*)buf)[0])
d328 1
a328 1
						unsigned err = (((const unsigned char*)buf)[1]<<8) + ((const unsigned char*)buf)[2];
d397 1
a397 1
				switch (((const unsigned char*)buf)[0])
d408 1
a408 1
				switch (((const unsigned char*)buf)[1])
d489 1
a489 1
				switch (((const unsigned char*)buf)[0])
d542 1
a542 1
			BIO_printf(bio, " %02x", ((const unsigned char*)buf)[i]);
d548 1
a548 60
	(void)BIO_flush(bio);
	}

void MS_CALLBACK tlsext_cb(SSL *s, int client_server, int type,
					unsigned char *data, int len,
					void *arg)
	{
	BIO *bio = arg;
	char *extname;

	switch(type)
		{
		case TLSEXT_TYPE_server_name:
		extname = "server name";
		break;

		case TLSEXT_TYPE_max_fragment_length:
		extname = "max fragment length";
		break;

		case TLSEXT_TYPE_client_certificate_url:
		extname = "client certificate URL";
		break;

		case TLSEXT_TYPE_trusted_ca_keys:
		extname = "trusted CA keys";
		break;

		case TLSEXT_TYPE_truncated_hmac:
		extname = "truncated HMAC";
		break;

		case TLSEXT_TYPE_status_request:
		extname = "status request";
		break;

		case TLSEXT_TYPE_elliptic_curves:
		extname = "elliptic curves";
		break;

		case TLSEXT_TYPE_ec_point_formats:
		extname = "EC point formats";
		break;

		case TLSEXT_TYPE_session_ticket:
		extname = "server ticket";
		break;


		default:
		extname = "unknown";
		break;

		}
	
	BIO_printf(bio, "TLS %s extension \"%s\" (id=%d), len=%d\n",
			client_server ? "server": "client",
			extname, type, len);
	BIO_dump(bio, (char *)data, len);
	(void)BIO_flush(bio);
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
a119 1
#include <openssl/rand.h>
a123 2
#define	COOKIE_SECRET_LENGTH	16

a125 3
int verify_return_error=0;
unsigned char cookie_secret[COOKIE_SECRET_LENGTH];
int cookie_initialized=0;
d129 1
d137 2
a138 9
	BIO_printf(bio_err,"depth=%d ",depth);
	if (err_cert)
		{
		X509_NAME_print_ex(bio_err, X509_get_subject_name(err_cert),
					0, XN_FLAG_ONELINE);
		BIO_puts(bio_err, "\n");
		}
	else
		BIO_puts(bio_err, "<no cert>\n");
d145 1
a145 2
			if (!verify_return_error)
				ok=1;
d154 1
a154 1
	switch (err)
d157 2
a158 4
		BIO_puts(bio_err,"issuer= ");
		X509_NAME_print_ex(bio_err, X509_get_issuer_name(err_cert),
					0, XN_FLAG_ONELINE);
		BIO_puts(bio_err, "\n");
d163 1
a163 1
		ASN1_TIME_print(bio_err,X509_get_notBefore(err_cert));
d169 1
a169 1
		ASN1_TIME_print(bio_err,X509_get_notAfter(err_cert));
a171 3
	case X509_V_ERR_NO_EXPLICIT_POLICY:
		policies_print(bio_err, ctx);
		break;
a172 3
	if (err == X509_V_OK && ok == 2)
		policies_print(bio_err, ctx);

d261 1
a261 1
				   int argi, long argl, long ret)
d270 2
a271 2
		BIO_printf(out,"read from %p [%p] (%lu bytes => %ld (0x%lX))\n",
 			(void *)bio,argp,(unsigned long)argi,ret,ret);
d277 2
a278 2
		BIO_printf(out,"write to %p [%p] (%lu bytes => %ld (0x%lX))\n",
			(void *)bio,argp,(unsigned long)argi,ret,ret);
a338 6
	case DTLS1_VERSION:
		str_version = "DTLS 1.0 ";
		break;
	case DTLS1_BAD_VER:
		str_version = "DTLS 1.0 (bad) ";
		break;
d404 1
a404 4
	if (version == SSL3_VERSION ||
	    version == TLS1_VERSION ||
	    version == DTLS1_VERSION ||
	    version == DTLS1_BAD_VER)
a506 15
				case 110:
					str_details2 = " unsupported_extension";
					break;
				case 111:
					str_details2 = " certificate_unobtainable";
					break;
				case 112:
					str_details2 = " unrecognized_name";
					break;
				case 113:
					str_details2 = " bad_certificate_status_response";
					break;
				case 114:
					str_details2 = " bad_certificate_hash_value";
					break;
a527 3
				case 3:
					str_details1 = ", HelloVerifyRequest";
					break;
a623 9
		case TLSEXT_TYPE_renegotiate:
		extname = "renegotiate";
		break;

#ifdef TLSEXT_TYPE_opaque_prf_input
		case TLSEXT_TYPE_opaque_prf_input:
		extname = "opaque PRF input";
		break;
#endif
a635 169
	}

int MS_CALLBACK generate_cookie_callback(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len)
	{
	unsigned char *buffer, result[EVP_MAX_MD_SIZE];
	unsigned int length, resultlength;
	union {
		struct sockaddr sa;
		struct sockaddr_in s4;
#if OPENSSL_USE_IPV6
		struct sockaddr_in6 s6;
#endif
	} peer;

	/* Initialize a random secret */
	if (!cookie_initialized)
		{
		if (!RAND_bytes(cookie_secret, COOKIE_SECRET_LENGTH))
			{
			BIO_printf(bio_err,"error setting random cookie secret\n");
			return 0;
			}
		cookie_initialized = 1;
		}

	/* Read peer information */
	(void)BIO_dgram_get_peer(SSL_get_rbio(ssl), &peer);

	/* Create buffer with peer's address and port */
	length = 0;
	switch (peer.sa.sa_family)
		{
	case AF_INET:
		length += sizeof(struct in_addr);
		length += sizeof(peer.s4.sin_port);
		break;
#if OPENSSL_USE_IPV6
	case AF_INET6:
		length += sizeof(struct in6_addr);
		length += sizeof(peer.s6.sin6_port);
		break;
#endif
	default:
		OPENSSL_assert(0);
		break;
		}
	buffer = OPENSSL_malloc(length);

	if (buffer == NULL)
		{
		BIO_printf(bio_err,"out of memory\n");
		return 0;
		}

	switch (peer.sa.sa_family)
		{
	case AF_INET:
		memcpy(buffer,
		       &peer.s4.sin_port,
		       sizeof(peer.s4.sin_port));
		memcpy(buffer + sizeof(peer.s4.sin_port),
		       &peer.s4.sin_addr,
		       sizeof(struct in_addr));
		break;
#if OPENSSL_USE_IPV6
	case AF_INET6:
		memcpy(buffer,
		       &peer.s6.sin6_port,
		       sizeof(peer.s6.sin6_port));
		memcpy(buffer + sizeof(peer.s6.sin6_port),
		       &peer.s6.sin6_addr,
		       sizeof(struct in6_addr));
		break;
#endif
	default:
		OPENSSL_assert(0);
		break;
		}

	/* Calculate HMAC of buffer using the secret */
	HMAC(EVP_sha1(), cookie_secret, COOKIE_SECRET_LENGTH,
	     buffer, length, result, &resultlength);
	OPENSSL_free(buffer);

	memcpy(cookie, result, resultlength);
	*cookie_len = resultlength;

	return 1;
	}

int MS_CALLBACK verify_cookie_callback(SSL *ssl, unsigned char *cookie, unsigned int cookie_len)
	{
	unsigned char *buffer, result[EVP_MAX_MD_SIZE];
	unsigned int length, resultlength;
	union {
		struct sockaddr sa;
		struct sockaddr_in s4;
#if OPENSSL_USE_IPV6
		struct sockaddr_in6 s6;
#endif
	} peer;

	/* If secret isn't initialized yet, the cookie can't be valid */
	if (!cookie_initialized)
		return 0;

	/* Read peer information */
	(void)BIO_dgram_get_peer(SSL_get_rbio(ssl), &peer);

	/* Create buffer with peer's address and port */
	length = 0;
	switch (peer.sa.sa_family)
		{
	case AF_INET:
		length += sizeof(struct in_addr);
		length += sizeof(peer.s4.sin_port);
		break;
#if OPENSSL_USE_IPV6
	case AF_INET6:
		length += sizeof(struct in6_addr);
		length += sizeof(peer.s6.sin6_port);
		break;
#endif
	default:
		OPENSSL_assert(0);
		break;
		}
	buffer = OPENSSL_malloc(length);
	
	if (buffer == NULL)
		{
		BIO_printf(bio_err,"out of memory\n");
		return 0;
		}

	switch (peer.sa.sa_family)
		{
	case AF_INET:
		memcpy(buffer,
		       &peer.s4.sin_port,
		       sizeof(peer.s4.sin_port));
		memcpy(buffer + sizeof(peer.s4.sin_port),
		       &peer.s4.sin_addr,
		       sizeof(struct in_addr));
		break;
#if OPENSSL_USE_IPV6
	case AF_INET6:
		memcpy(buffer,
		       &peer.s6.sin6_port,
		       sizeof(peer.s6.sin6_port));
		memcpy(buffer + sizeof(peer.s6.sin6_port),
		       &peer.s6.sin6_addr,
		       sizeof(struct in6_addr));
		break;
#endif
	default:
		OPENSSL_assert(0);
		break;
		}

	/* Calculate HMAC of buffer using the secret */
	HMAC(EVP_sha1(), cookie_secret, COOKIE_SECRET_LENGTH,
	     buffer, length, result, &resultlength);
	OPENSSL_free(buffer);

	if (cookie_len == resultlength && memcmp(result, cookie, resultlength) == 0)
		return 1;

	return 0;
@


1.1.1.6
log
@import OpenSSL-1.0.1c
@
text
@a359 6
	case TLS1_1_VERSION:
		str_version = "TLS 1.1 ";
		break;
	case TLS1_2_VERSION:
		str_version = "TLS 1.2 ";
		break;
a551 3
				case 115:
					str_details2 = " unknown_psk_identity";
					break;
a599 20

#ifndef OPENSSL_NO_HEARTBEATS
		if (content_type == 24) /* Heartbeat */
			{
			str_details1 = ", Heartbeat";
			
			if (len > 0)
				{
				switch (((const unsigned char*)buf)[0])
					{
				case 1:
					str_details1 = ", HeartbeatRequest";
					break;
				case 2:
					str_details1 = ", HeartbeatResponse";
					break;
					}
				}
			}
#endif
a659 16
		case TLSEXT_TYPE_user_mapping:
		extname = "user mapping";
		break;

		case TLSEXT_TYPE_client_authz:
		extname = "client authz";
		break;

		case TLSEXT_TYPE_server_authz:
		extname = "server authz";
		break;

		case TLSEXT_TYPE_cert_type:
		extname = "cert type";
		break;

a667 16
		case TLSEXT_TYPE_srp:
		extname = "SRP";
		break;

		case TLSEXT_TYPE_signature_algorithms:
		extname = "signature algorithms";
		break;

		case TLSEXT_TYPE_use_srtp:
		extname = "use SRTP";
		break;

		case TLSEXT_TYPE_heartbeat:
		extname = "heartbeat";
		break;

d669 1
a669 1
		extname = "session ticket";
d672 2
a673 2
		case TLSEXT_TYPE_renegotiate: 
		extname = "renegotiation info";
a678 5
		break;
#endif
#ifdef TLSEXT_TYPE_next_proto_neg
		case TLSEXT_TYPE_next_proto_neg:
		extname = "next protocol";
@


1.1.1.7
log
@Import OpenSSL 1.0.1g
@
text
@d240 2
a241 2


a438 2
	    version == TLS1_1_VERSION ||
	    version == TLS1_2_VERSION ||
@


