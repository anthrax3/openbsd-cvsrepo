head	1.21;
access;
symbols
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	butholakala:1.1.1.5
	openssl_1_0_1_g:1.1.1.5
	OPENSSL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.8
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.4
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.2
	OPENBSD_5_3_BASE:1.1.1.4
	openssl_1_0_1_c:1.1.1.4
	OPENBSD_5_2:1.1.1.3.0.2
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.4
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.2
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	openssh_1_0_0_a:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	openssl_0_9_8_k:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	openssl_0_9_8_j:1.1.1.1
	openssl_0_9_8_h:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.20;
commitid	7A7DObXgY4Fni8xJ;

1.20
date	2014.07.13.16.03.09;	author beck;	state Exp;
branches;
next	1.19;
commitid	6xdvCwSqBadTW6X3;

1.19
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.18;
commitid	0NuggCO2WJOZj8Kh;

1.18
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	mJUVYpkFBZ0Zv2bG;

1.17
date	2014.06.02.16.23.18;	author jsing;	state Exp;
branches;
next	1.16;
commitid	IqYoI5gjfSomu7k2;

1.16
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2014.05.17.15.45.50;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.22.13.32.17;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.18.09.38.42;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.18.04.33.09;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.18.04.17.16;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.16.16.55.21;	author jsing;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.01.05.22.58.51;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: cms.c,v 1.20 2014/07/13 16:03:09 beck Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project.
 */
/* ====================================================================
 * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */

/* CMS utility function */

#include <stdio.h>
#include <string.h>

#include "apps.h"

#ifndef OPENSSL_NO_CMS

#include <openssl/cms.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/x509_vfy.h>
#include <openssl/x509v3.h>

static int save_certs(char *signerfile, STACK_OF(X509) * signers);
static int cms_cb(int ok, X509_STORE_CTX * ctx);
static void receipt_request_print(BIO * out, CMS_ContentInfo * cms);
static CMS_ReceiptRequest * make_receipt_request(
    STACK_OF(OPENSSL_STRING) * rr_to, int rr_allorfirst,
    STACK_OF(OPENSSL_STRING) * rr_from);

#define SMIME_OP	0x10
#define SMIME_IP	0x20
#define SMIME_SIGNERS	0x40
#define SMIME_ENCRYPT		(1 | SMIME_OP)
#define SMIME_DECRYPT		(2 | SMIME_IP)
#define SMIME_SIGN		(3 | SMIME_OP | SMIME_SIGNERS)
#define SMIME_VERIFY		(4 | SMIME_IP)
#define SMIME_CMSOUT		(5 | SMIME_IP | SMIME_OP)
#define SMIME_RESIGN		(6 | SMIME_IP | SMIME_OP | SMIME_SIGNERS)
#define SMIME_DATAOUT		(7 | SMIME_IP)
#define SMIME_DATA_CREATE	(8 | SMIME_OP)
#define SMIME_DIGEST_VERIFY	(9 | SMIME_IP)
#define SMIME_DIGEST_CREATE	(10 | SMIME_OP)
#define SMIME_UNCOMPRESS	(11 | SMIME_IP)
#define SMIME_COMPRESS		(12 | SMIME_OP)
#define SMIME_ENCRYPTED_DECRYPT	(13 | SMIME_IP)
#define SMIME_ENCRYPTED_ENCRYPT	(14 | SMIME_OP)
#define SMIME_SIGN_RECEIPT	(15 | SMIME_IP | SMIME_OP)
#define SMIME_VERIFY_RECEIPT	(16 | SMIME_IP)

int verify_err = 0;

int cms_main(int, char **);

int
cms_main(int argc, char **argv)
{
	ENGINE *e = NULL;
	int operation = 0;
	int ret = 0;
	char **args;
	const char *inmode = "r", *outmode = "w";
	char *infile = NULL, *outfile = NULL, *rctfile = NULL;
	char *signerfile = NULL, *recipfile = NULL;
	STACK_OF(OPENSSL_STRING) * sksigners = NULL, *skkeys = NULL;
	char *certfile = NULL, *keyfile = NULL, *contfile = NULL;
	char *certsoutfile = NULL;
	const EVP_CIPHER *cipher = NULL;
	CMS_ContentInfo *cms = NULL, *rcms = NULL;
	X509_STORE *store = NULL;
	X509 *cert = NULL, *recip = NULL, *signer = NULL;
	EVP_PKEY *key = NULL;
	STACK_OF(X509) * encerts = NULL, *other = NULL;
	BIO *in = NULL, *out = NULL, *indata = NULL, *rctin = NULL;
	int badarg = 0;
	int flags = CMS_DETACHED, noout = 0, print = 0;
	int verify_retcode = 0;
	int rr_print = 0, rr_allorfirst = -1;
	STACK_OF(OPENSSL_STRING) * rr_to = NULL, *rr_from = NULL;
	CMS_ReceiptRequest *rr = NULL;
	char *to = NULL, *from = NULL, *subject = NULL;
	char *CAfile = NULL, *CApath = NULL;
	char *passargin = NULL, *passin = NULL;
	const EVP_MD *sign_md = NULL;
	int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;
	int rctformat = FORMAT_SMIME, keyform = FORMAT_PEM;
#ifndef OPENSSL_NO_ENGINE
	char *engine = NULL;
#endif
	unsigned char *secret_key = NULL, *secret_keyid = NULL;
	unsigned char *pwri_pass = NULL, *pwri_tmp = NULL;
	size_t secret_keylen = 0, secret_keyidlen = 0;

	ASN1_OBJECT *econtent_type = NULL;

	X509_VERIFY_PARAM *vpm = NULL;

	args = argv + 1;
	ret = 1;

	while (!badarg && *args && *args[0] == '-') {
		if (!strcmp(*args, "-encrypt"))
			operation = SMIME_ENCRYPT;
		else if (!strcmp(*args, "-decrypt"))
			operation = SMIME_DECRYPT;
		else if (!strcmp(*args, "-sign"))
			operation = SMIME_SIGN;
		else if (!strcmp(*args, "-sign_receipt"))
			operation = SMIME_SIGN_RECEIPT;
		else if (!strcmp(*args, "-resign"))
			operation = SMIME_RESIGN;
		else if (!strcmp(*args, "-verify"))
			operation = SMIME_VERIFY;
		else if (!strcmp(*args, "-verify_retcode"))
			verify_retcode = 1;
		else if (!strcmp(*args, "-verify_receipt")) {
			operation = SMIME_VERIFY_RECEIPT;
			if (!args[1])
				goto argerr;
			args++;
			rctfile = *args;
		} else if (!strcmp(*args, "-cmsout"))
			operation = SMIME_CMSOUT;
		else if (!strcmp(*args, "-data_out"))
			operation = SMIME_DATAOUT;
		else if (!strcmp(*args, "-data_create"))
			operation = SMIME_DATA_CREATE;
		else if (!strcmp(*args, "-digest_verify"))
			operation = SMIME_DIGEST_VERIFY;
		else if (!strcmp(*args, "-digest_create"))
			operation = SMIME_DIGEST_CREATE;
		else if (!strcmp(*args, "-compress"))
			operation = SMIME_COMPRESS;
		else if (!strcmp(*args, "-uncompress"))
			operation = SMIME_UNCOMPRESS;
		else if (!strcmp(*args, "-EncryptedData_decrypt"))
			operation = SMIME_ENCRYPTED_DECRYPT;
		else if (!strcmp(*args, "-EncryptedData_encrypt"))
			operation = SMIME_ENCRYPTED_ENCRYPT;
#ifndef OPENSSL_NO_DES
		else if (!strcmp(*args, "-des3"))
			cipher = EVP_des_ede3_cbc();
		else if (!strcmp(*args, "-des"))
			cipher = EVP_des_cbc();
#endif
#ifndef OPENSSL_NO_RC2
		else if (!strcmp(*args, "-rc2-40"))
			cipher = EVP_rc2_40_cbc();
		else if (!strcmp(*args, "-rc2-128"))
			cipher = EVP_rc2_cbc();
		else if (!strcmp(*args, "-rc2-64"))
			cipher = EVP_rc2_64_cbc();
#endif
#ifndef OPENSSL_NO_AES
		else if (!strcmp(*args, "-aes128"))
			cipher = EVP_aes_128_cbc();
		else if (!strcmp(*args, "-aes192"))
			cipher = EVP_aes_192_cbc();
		else if (!strcmp(*args, "-aes256"))
			cipher = EVP_aes_256_cbc();
#endif
#ifndef OPENSSL_NO_CAMELLIA
		else if (!strcmp(*args, "-camellia128"))
			cipher = EVP_camellia_128_cbc();
		else if (!strcmp(*args, "-camellia192"))
			cipher = EVP_camellia_192_cbc();
		else if (!strcmp(*args, "-camellia256"))
			cipher = EVP_camellia_256_cbc();
#endif
		else if (!strcmp(*args, "-debug_decrypt"))
			flags |= CMS_DEBUG_DECRYPT;
		else if (!strcmp(*args, "-text"))
			flags |= CMS_TEXT;
		else if (!strcmp(*args, "-nointern"))
			flags |= CMS_NOINTERN;
		else if (!strcmp(*args, "-noverify") ||
		    !strcmp(*args, "-no_signer_cert_verify"))
			flags |= CMS_NO_SIGNER_CERT_VERIFY;
		else if (!strcmp(*args, "-nocerts"))
			flags |= CMS_NOCERTS;
		else if (!strcmp(*args, "-noattr"))
			flags |= CMS_NOATTR;
		else if (!strcmp(*args, "-nodetach"))
			flags &= ~CMS_DETACHED;
		else if (!strcmp(*args, "-nosmimecap"))
			flags |= CMS_NOSMIMECAP;
		else if (!strcmp(*args, "-binary"))
			flags |= CMS_BINARY;
		else if (!strcmp(*args, "-keyid"))
			flags |= CMS_USE_KEYID;
		else if (!strcmp(*args, "-nosigs"))
			flags |= CMS_NOSIGS;
		else if (!strcmp(*args, "-no_content_verify"))
			flags |= CMS_NO_CONTENT_VERIFY;
		else if (!strcmp(*args, "-no_attr_verify"))
			flags |= CMS_NO_ATTR_VERIFY;
		else if (!strcmp(*args, "-stream"))
			flags |= CMS_STREAM;
		else if (!strcmp(*args, "-indef"))
			flags |= CMS_STREAM;
		else if (!strcmp(*args, "-noindef"))
			flags &= ~CMS_STREAM;
		else if (!strcmp(*args, "-nooldmime"))
			flags |= CMS_NOOLDMIMETYPE;
		else if (!strcmp(*args, "-crlfeol"))
			flags |= CMS_CRLFEOL;
		else if (!strcmp(*args, "-noout"))
			noout = 1;
		else if (!strcmp(*args, "-receipt_request_print"))
			rr_print = 1;
		else if (!strcmp(*args, "-receipt_request_all"))
			rr_allorfirst = 0;
		else if (!strcmp(*args, "-receipt_request_first"))
			rr_allorfirst = 1;
		else if (!strcmp(*args, "-receipt_request_from")) {
			if (!args[1])
				goto argerr;
			args++;
			if (!rr_from)
				rr_from = sk_OPENSSL_STRING_new_null();
			sk_OPENSSL_STRING_push(rr_from, *args);
		} else if (!strcmp(*args, "-receipt_request_to")) {
			if (!args[1])
				goto argerr;
			args++;
			if (!rr_to)
				rr_to = sk_OPENSSL_STRING_new_null();
			sk_OPENSSL_STRING_push(rr_to, *args);
		} else if (!strcmp(*args, "-print")) {
			noout = 1;
			print = 1;
		} else if (!strcmp(*args, "-secretkey")) {
			long ltmp;
			if (!args[1])
				goto argerr;
			args++;
			secret_key = string_to_hex(*args, &ltmp);
			if (!secret_key) {
				BIO_printf(bio_err, "Invalid key %s\n", *args);
				goto argerr;
			}
			secret_keylen = (size_t) ltmp;
		} else if (!strcmp(*args, "-secretkeyid")) {
			long ltmp;
			if (!args[1])
				goto argerr;
			args++;
			secret_keyid = string_to_hex(*args, &ltmp);
			if (!secret_keyid) {
				BIO_printf(bio_err, "Invalid id %s\n", *args);
				goto argerr;
			}
			secret_keyidlen = (size_t) ltmp;
		} else if (!strcmp(*args, "-pwri_password")) {
			if (!args[1])
				goto argerr;
			args++;
			pwri_pass = (unsigned char *) *args;
		} else if (!strcmp(*args, "-econtent_type")) {
			if (!args[1])
				goto argerr;
			args++;
			econtent_type = OBJ_txt2obj(*args, 0);
			if (!econtent_type) {
				BIO_printf(bio_err, "Invalid OID %s\n", *args);
				goto argerr;
			}
		}
#ifndef OPENSSL_NO_ENGINE
		else if (!strcmp(*args, "-engine")) {
			if (!args[1])
				goto argerr;
			engine = *++args;
		}
#endif
		else if (!strcmp(*args, "-passin")) {
			if (!args[1])
				goto argerr;
			passargin = *++args;
		} else if (!strcmp(*args, "-to")) {
			if (!args[1])
				goto argerr;
			to = *++args;
		} else if (!strcmp(*args, "-from")) {
			if (!args[1])
				goto argerr;
			from = *++args;
		} else if (!strcmp(*args, "-subject")) {
			if (!args[1])
				goto argerr;
			subject = *++args;
		} else if (!strcmp(*args, "-signer")) {
			if (!args[1])
				goto argerr;
			/* If previous -signer argument add signer to list */

			if (signerfile) {
				if (!sksigners)
					sksigners =
					    sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(sksigners, signerfile);
				if (!keyfile)
					keyfile = signerfile;
				if (!skkeys)
					skkeys = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(skkeys, keyfile);
				keyfile = NULL;
			}
			signerfile = *++args;
		} else if (!strcmp(*args, "-recip")) {
			if (!args[1])
				goto argerr;
			recipfile = *++args;
		} else if (!strcmp(*args, "-certsout")) {
			if (!args[1])
				goto argerr;
			certsoutfile = *++args;
		} else if (!strcmp(*args, "-md")) {
			if (!args[1])
				goto argerr;
			sign_md = EVP_get_digestbyname(*++args);
			if (sign_md == NULL) {
				BIO_printf(bio_err, "Unknown digest %s\n",
				    *args);
				goto argerr;
			}
		} else if (!strcmp(*args, "-inkey")) {
			if (!args[1])
				goto argerr;
			/* If previous -inkey arument add signer to list */
			if (keyfile) {
				if (!signerfile) {
					BIO_puts(bio_err,
					    "Illegal -inkey without -signer\n");
					goto argerr;
				}
				if (!sksigners)
					sksigners =
					    sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(sksigners, signerfile);
				signerfile = NULL;
				if (!skkeys)
					skkeys = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(skkeys, keyfile);
			}
			keyfile = *++args;
		} else if (!strcmp(*args, "-keyform")) {
			if (!args[1])
				goto argerr;
			keyform = str2fmt(*++args);
		} else if (!strcmp(*args, "-rctform")) {
			if (!args[1])
				goto argerr;
			rctformat = str2fmt(*++args);
		} else if (!strcmp(*args, "-certfile")) {
			if (!args[1])
				goto argerr;
			certfile = *++args;
		} else if (!strcmp(*args, "-CAfile")) {
			if (!args[1])
				goto argerr;
			CAfile = *++args;
		} else if (!strcmp(*args, "-CApath")) {
			if (!args[1])
				goto argerr;
			CApath = *++args;
		} else if (!strcmp(*args, "-in")) {
			if (!args[1])
				goto argerr;
			infile = *++args;
		} else if (!strcmp(*args, "-inform")) {
			if (!args[1])
				goto argerr;
			informat = str2fmt(*++args);
		} else if (!strcmp(*args, "-outform")) {
			if (!args[1])
				goto argerr;
			outformat = str2fmt(*++args);
		} else if (!strcmp(*args, "-out")) {
			if (!args[1])
				goto argerr;
			outfile = *++args;
		} else if (!strcmp(*args, "-content")) {
			if (!args[1])
				goto argerr;
			contfile = *++args;
		} else if (args_verify(&args, NULL, &badarg, bio_err, &vpm))
			continue;
		else if ((cipher = EVP_get_cipherbyname(*args + 1)) == NULL)
			badarg = 1;
		args++;
	}

	if (((rr_allorfirst != -1) || rr_from) && !rr_to) {
		BIO_puts(bio_err, "No Signed Receipts Recipients\n");
		goto argerr;
	}
	if (!(operation & SMIME_SIGNERS) && (rr_to || rr_from)) {
		BIO_puts(bio_err, "Signed receipts only allowed with -sign\n");
		goto argerr;
	}
	if (!(operation & SMIME_SIGNERS) && (skkeys || sksigners)) {
		BIO_puts(bio_err, "Multiple signers or keys not allowed\n");
		goto argerr;
	}
	if (operation & SMIME_SIGNERS) {
		if (keyfile && !signerfile) {
			BIO_puts(bio_err, "Illegal -inkey without -signer\n");
			goto argerr;
		}
		/* Check to see if any final signer needs to be appended */
		if (signerfile) {
			if (!sksigners)
				sksigners = sk_OPENSSL_STRING_new_null();
			sk_OPENSSL_STRING_push(sksigners, signerfile);
			if (!skkeys)
				skkeys = sk_OPENSSL_STRING_new_null();
			if (!keyfile)
				keyfile = signerfile;
			sk_OPENSSL_STRING_push(skkeys, keyfile);
		}
		if (!sksigners) {
			BIO_printf(bio_err,
			    "No signer certificate specified\n");
			badarg = 1;
		}
		signerfile = NULL;
		keyfile = NULL;
	} else if (operation == SMIME_DECRYPT) {
		if (!recipfile && !keyfile && !secret_key && !pwri_pass) {
			BIO_printf(bio_err,
			    "No recipient certificate or key specified\n");
			badarg = 1;
		}
	} else if (operation == SMIME_ENCRYPT) {
		if (!*args && !secret_key && !pwri_pass) {
			BIO_printf(bio_err,
			    "No recipient(s) certificate(s) specified\n");
			badarg = 1;
		}
	} else if (!operation)
		badarg = 1;

	if (badarg) {
argerr:
		BIO_printf(bio_err, "Usage cms [options] cert.pem ...\n");
		BIO_printf(bio_err, "where options are\n");
		BIO_printf(bio_err, "-encrypt       encrypt message\n");
		BIO_printf(bio_err, "-decrypt       decrypt encrypted message\n");
		BIO_printf(bio_err, "-sign          sign message\n");
		BIO_printf(bio_err, "-verify        verify signed message\n");
		BIO_printf(bio_err, "-cmsout        output CMS structure\n");
#ifndef OPENSSL_NO_DES
		BIO_printf(bio_err, "-des3          encrypt with triple DES\n");
		BIO_printf(bio_err, "-des           encrypt with DES\n");
#endif
#ifndef OPENSSL_NO_RC2
		BIO_printf(bio_err, "-rc2-40        encrypt with RC2-40 (default)\n");
		BIO_printf(bio_err, "-rc2-64        encrypt with RC2-64\n");
		BIO_printf(bio_err, "-rc2-128       encrypt with RC2-128\n");
#endif
#ifndef OPENSSL_NO_AES
		BIO_printf(bio_err, "-aes128, -aes192, -aes256\n");
		BIO_printf(bio_err, "               encrypt PEM output with cbc aes\n");
#endif
#ifndef OPENSSL_NO_CAMELLIA
		BIO_printf(bio_err, "-camellia128, -camellia192, -camellia256\n");
		BIO_printf(bio_err, "               encrypt PEM output with cbc camellia\n");
#endif
		BIO_printf(bio_err, "-nointern      don't search certificates in message for signer\n");
		BIO_printf(bio_err, "-nosigs        don't verify message signature\n");
		BIO_printf(bio_err, "-noverify      don't verify signers certificate\n");
		BIO_printf(bio_err, "-nocerts       don't include signers certificate when signing\n");
		BIO_printf(bio_err, "-nodetach      use opaque signing\n");
		BIO_printf(bio_err, "-noattr        don't include any signed attributes\n");
		BIO_printf(bio_err, "-binary        don't translate message to text\n");
		BIO_printf(bio_err, "-certfile file other certificates file\n");
		BIO_printf(bio_err, "-certsout file certificate output file\n");
		BIO_printf(bio_err, "-signer file   signer certificate file\n");
		BIO_printf(bio_err, "-recip  file   recipient certificate file for decryption\n");
		BIO_printf(bio_err, "-keyid         use subject key identifier\n");
		BIO_printf(bio_err, "-in file       input file\n");
		BIO_printf(bio_err, "-inform arg    input format SMIME (default), PEM or DER\n");
		BIO_printf(bio_err, "-inkey file    input private key (if not signer or recipient)\n");
		BIO_printf(bio_err, "-keyform arg   input private key format (PEM or ENGINE)\n");
		BIO_printf(bio_err, "-out file      output file\n");
		BIO_printf(bio_err, "-outform arg   output format SMIME (default), PEM or DER\n");
		BIO_printf(bio_err, "-content file  supply or override content for detached signature\n");
		BIO_printf(bio_err, "-to addr       to address\n");
		BIO_printf(bio_err, "-from ad       from address\n");
		BIO_printf(bio_err, "-subject s     subject\n");
		BIO_printf(bio_err, "-text          include or delete text MIME headers\n");
		BIO_printf(bio_err, "-CApath dir    trusted certificates directory\n");
		BIO_printf(bio_err, "-CAfile file   trusted certificates file\n");
		BIO_printf(bio_err, "-crl_check     check revocation status of signer's certificate using CRLs\n");
		BIO_printf(bio_err, "-crl_check_all check revocation status of signer's certificate chain using CRLs\n");
#ifndef OPENSSL_NO_ENGINE
		BIO_printf(bio_err, "-engine e      use engine e, possibly a hardware device.\n");
#endif
		BIO_printf(bio_err, "-passin arg    input file pass phrase source\n");
		BIO_printf(bio_err, "cert.pem       recipient certificate(s) for encryption\n");
		goto end;
	}
#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine, 0);
#endif

	if (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
	}
	ret = 2;

	if (!(operation & SMIME_SIGNERS))
		flags &= ~CMS_DETACHED;

	if (operation & SMIME_OP) {
		if (outformat == FORMAT_ASN1)
			outmode = "wb";
	} else {
		if (flags & CMS_BINARY)
			outmode = "wb";
	}

	if (operation & SMIME_IP) {
		if (informat == FORMAT_ASN1)
			inmode = "rb";
	} else {
		if (flags & CMS_BINARY)
			inmode = "rb";
	}

	if (operation == SMIME_ENCRYPT) {
		if (!cipher) {
#ifndef OPENSSL_NO_DES
			cipher = EVP_des_ede3_cbc();
#else
			BIO_printf(bio_err, "No cipher selected\n");
			goto end;
#endif
		}
		if (secret_key && !secret_keyid) {
			BIO_printf(bio_err, "No secret key id\n");
			goto end;
		}
		if (*args)
			encerts = sk_X509_new_null();
		while (*args) {
			if (!(cert = load_cert(bio_err, *args, FORMAT_PEM,
			    NULL, e, "recipient certificate file")))
				goto end;
			sk_X509_push(encerts, cert);
			cert = NULL;
			args++;
		}
	}
	if (certfile) {
		if (!(other = load_certs(bio_err, certfile, FORMAT_PEM, NULL,
		    e, "certificate file"))) {
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (recipfile && (operation == SMIME_DECRYPT)) {
		if (!(recip = load_cert(bio_err, recipfile, FORMAT_PEM, NULL,
		    e, "recipient certificate file"))) {
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (operation == SMIME_SIGN_RECEIPT) {
		if (!(signer = load_cert(bio_err, signerfile, FORMAT_PEM, NULL,
		    e, "receipt signer certificate file"))) {
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (operation == SMIME_DECRYPT) {
		if (!keyfile)
			keyfile = recipfile;
	} else if ((operation == SMIME_SIGN) ||
	    (operation == SMIME_SIGN_RECEIPT)) {
		if (!keyfile)
			keyfile = signerfile;
	} else
		keyfile = NULL;

	if (keyfile) {
		key = load_key(bio_err, keyfile, keyform, 0, passin, e,
		    "signing key file");
		if (!key)
			goto end;
	}
	if (infile) {
		if (!(in = BIO_new_file(infile, inmode))) {
			BIO_printf(bio_err,
			    "Can't open input file %s\n", infile);
			goto end;
		}
	} else
		in = BIO_new_fp(stdin, BIO_NOCLOSE);

	if (operation & SMIME_IP) {
		if (informat == FORMAT_SMIME)
			cms = SMIME_read_CMS(in, &indata);
		else if (informat == FORMAT_PEM)
			cms = PEM_read_bio_CMS(in, NULL, NULL, NULL);
		else if (informat == FORMAT_ASN1)
			cms = d2i_CMS_bio(in, NULL);
		else {
			BIO_printf(bio_err, "Bad input format for CMS file\n");
			goto end;
		}

		if (!cms) {
			BIO_printf(bio_err, "Error reading S/MIME message\n");
			goto end;
		}
		if (contfile) {
			BIO_free(indata);
			if (!(indata = BIO_new_file(contfile, "rb"))) {
				BIO_printf(bio_err,
				    "Can't read content file %s\n", contfile);
				goto end;
			}
		}
		if (certsoutfile) {
			STACK_OF(X509) * allcerts;
			allcerts = CMS_get1_certs(cms);
			if (!save_certs(certsoutfile, allcerts)) {
				BIO_printf(bio_err,
				    "Error writing certs to %s\n",
				    certsoutfile);
				ret = 5;
				goto end;
			}
			sk_X509_pop_free(allcerts, X509_free);
		}
	}
	if (rctfile) {
		char *rctmode = (rctformat == FORMAT_ASN1) ? "rb" : "r";
		if (!(rctin = BIO_new_file(rctfile, rctmode))) {
			BIO_printf(bio_err,
			    "Can't open receipt file %s\n", rctfile);
			goto end;
		}
		if (rctformat == FORMAT_SMIME)
			rcms = SMIME_read_CMS(rctin, NULL);
		else if (rctformat == FORMAT_PEM)
			rcms = PEM_read_bio_CMS(rctin, NULL, NULL, NULL);
		else if (rctformat == FORMAT_ASN1)
			rcms = d2i_CMS_bio(rctin, NULL);
		else {
			BIO_printf(bio_err, "Bad input format for receipt\n");
			goto end;
		}

		if (!rcms) {
			BIO_printf(bio_err, "Error reading receipt\n");
			goto end;
		}
	}
	if (outfile) {
		if (!(out = BIO_new_file(outfile, outmode))) {
			BIO_printf(bio_err,
			    "Can't open output file %s\n", outfile);
			goto end;
		}
	} else {
		out = BIO_new_fp(stdout, BIO_NOCLOSE);
	}

	if ((operation == SMIME_VERIFY) ||
	    (operation == SMIME_VERIFY_RECEIPT)) {
		if (!(store = setup_verify(bio_err, CAfile, CApath)))
			goto end;
		X509_STORE_set_verify_cb(store, cms_cb);
		if (vpm)
			X509_STORE_set1_param(store, vpm);
	}
	ret = 3;

	if (operation == SMIME_DATA_CREATE) {
		cms = CMS_data_create(in, flags);
	} else if (operation == SMIME_DIGEST_CREATE) {
		cms = CMS_digest_create(in, sign_md, flags);
	} else if (operation == SMIME_COMPRESS) {
		cms = CMS_compress(in, -1, flags);
	} else if (operation == SMIME_ENCRYPT) {
		flags |= CMS_PARTIAL;
		cms = CMS_encrypt(encerts, in, cipher, flags);
		if (!cms)
			goto end;
		if (secret_key) {
			if (!CMS_add0_recipient_key(cms, NID_undef, secret_key,
			    secret_keylen, secret_keyid, secret_keyidlen,
			    NULL, NULL, NULL))
				goto end;
			/* NULL these because call absorbs them */
			secret_key = NULL;
			secret_keyid = NULL;
		}
		if (pwri_pass) {
			pwri_tmp = strdup(pwri_pass);
			if (!pwri_tmp)
				goto end;
			if (!CMS_add0_recipient_password(cms, -1, NID_undef,
			    NID_undef, pwri_tmp, -1, NULL))
				goto end;
			pwri_tmp = NULL;
		}
		if (!(flags & CMS_STREAM)) {
			if (!CMS_final(cms, in, NULL, flags))
				goto end;
		}
	} else if (operation == SMIME_ENCRYPTED_ENCRYPT) {
		cms = CMS_EncryptedData_encrypt(in, cipher, secret_key,
		    secret_keylen, flags);

	} else if (operation == SMIME_SIGN_RECEIPT) {
		CMS_ContentInfo *srcms = NULL;
		STACK_OF(CMS_SignerInfo) * sis;
		CMS_SignerInfo *si;
		sis = CMS_get0_SignerInfos(cms);
		if (!sis)
			goto end;
		si = sk_CMS_SignerInfo_value(sis, 0);
		srcms = CMS_sign_receipt(si, signer, key, other, flags);
		if (!srcms)
			goto end;
		CMS_ContentInfo_free(cms);
		cms = srcms;
	} else if (operation & SMIME_SIGNERS) {
		int i;
		/*
		 * If detached data content we enable streaming if S/MIME
		 * output format.
		 */
		if (operation == SMIME_SIGN) {

			if (flags & CMS_DETACHED) {
				if (outformat == FORMAT_SMIME)
					flags |= CMS_STREAM;
			}
			flags |= CMS_PARTIAL;
			cms = CMS_sign(NULL, NULL, other, in, flags);
			if (!cms)
				goto end;
			if (econtent_type)
				CMS_set1_eContentType(cms, econtent_type);

			if (rr_to) {
				rr = make_receipt_request(rr_to, rr_allorfirst,
				    rr_from);
				if (!rr) {
					BIO_puts(bio_err,
					    "Signed Receipt Request Creation Error\n");
					goto end;
				}
			}
		} else
			flags |= CMS_REUSE_DIGEST;
		for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {
			CMS_SignerInfo *si;
			signerfile = sk_OPENSSL_STRING_value(sksigners, i);
			keyfile = sk_OPENSSL_STRING_value(skkeys, i);
			signer = load_cert(bio_err, signerfile, FORMAT_PEM,
			    NULL, e, "signer certificate");
			if (!signer)
				goto end;
			key = load_key(bio_err, keyfile, keyform, 0, passin, e,
			    "signing key file");
			if (!key)
				goto end;
			si = CMS_add1_signer(cms, signer, key, sign_md, flags);
			if (!si)
				goto end;
			if (rr && !CMS_add1_ReceiptRequest(si, rr))
				goto end;
			X509_free(signer);
			signer = NULL;
			EVP_PKEY_free(key);
			key = NULL;
		}
		/* If not streaming or resigning finalize structure */
		if ((operation == SMIME_SIGN) && !(flags & CMS_STREAM)) {
			if (!CMS_final(cms, in, NULL, flags))
				goto end;
		}
	}
	if (!cms) {
		BIO_printf(bio_err, "Error creating CMS structure\n");
		goto end;
	}
	ret = 4;
	if (operation == SMIME_DECRYPT) {
		if (flags & CMS_DEBUG_DECRYPT)
			CMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);

		if (secret_key) {
			if (!CMS_decrypt_set1_key(cms, secret_key,
			    secret_keylen, secret_keyid, secret_keyidlen)) {
				BIO_puts(bio_err,
				    "Error decrypting CMS using secret key\n");
				goto end;
			}
		}
		if (key) {
			if (!CMS_decrypt_set1_pkey(cms, key, recip)) {
				BIO_puts(bio_err,
				    "Error decrypting CMS using private key\n");
				goto end;
			}
		}
		if (pwri_pass) {
			if (!CMS_decrypt_set1_password(cms, pwri_pass, -1)) {
				BIO_puts(bio_err,
				    "Error decrypting CMS using password\n");
				goto end;
			}
		}
		if (!CMS_decrypt(cms, NULL, NULL, indata, out, flags)) {
			BIO_printf(bio_err, "Error decrypting CMS structure\n");
			goto end;
		}
	} else if (operation == SMIME_DATAOUT) {
		if (!CMS_data(cms, out, flags))
			goto end;
	} else if (operation == SMIME_UNCOMPRESS) {
		if (!CMS_uncompress(cms, indata, out, flags))
			goto end;
	} else if (operation == SMIME_DIGEST_VERIFY) {
		if (CMS_digest_verify(cms, indata, out, flags) > 0)
			BIO_printf(bio_err, "Verification successful\n");
		else {
			BIO_printf(bio_err, "Verification failure\n");
			goto end;
		}
	} else if (operation == SMIME_ENCRYPTED_DECRYPT) {
		if (!CMS_EncryptedData_decrypt(cms, secret_key, secret_keylen,
		    indata, out, flags))
			goto end;
	} else if (operation == SMIME_VERIFY) {
		if (CMS_verify(cms, other, store, indata, out, flags) > 0)
			BIO_printf(bio_err, "Verification successful\n");
		else {
			BIO_printf(bio_err, "Verification failure\n");
			if (verify_retcode)
				ret = verify_err + 32;
			goto end;
		}
		if (signerfile) {
			STACK_OF(X509) * signers;
			signers = CMS_get0_signers(cms);
			if (!save_certs(signerfile, signers)) {
				BIO_printf(bio_err,
				    "Error writing signers to %s\n",
				    signerfile);
				ret = 5;
				goto end;
			}
			sk_X509_free(signers);
		}
		if (rr_print)
			receipt_request_print(bio_err, cms);

	} else if (operation == SMIME_VERIFY_RECEIPT) {
		if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0)
			BIO_printf(bio_err, "Verification successful\n");
		else {
			BIO_printf(bio_err, "Verification failure\n");
			goto end;
		}
	} else {
		if (noout) {
			if (print)
				CMS_ContentInfo_print_ctx(out, cms, 0, NULL);
		} else if (outformat == FORMAT_SMIME) {
			if (to)
				BIO_printf(out, "To: %s\n", to);
			if (from)
				BIO_printf(out, "From: %s\n", from);
			if (subject)
				BIO_printf(out, "Subject: %s\n", subject);
			if (operation == SMIME_RESIGN)
				ret = SMIME_write_CMS(out, cms, indata, flags);
			else
				ret = SMIME_write_CMS(out, cms, in, flags);
		} else if (outformat == FORMAT_PEM)
			ret = PEM_write_bio_CMS_stream(out, cms, in, flags);
		else if (outformat == FORMAT_ASN1)
			ret = i2d_CMS_bio_stream(out, cms, in, flags);
		else {
			BIO_printf(bio_err, "Bad output format for CMS file\n");
			goto end;
		}
		if (ret <= 0) {
			ret = 6;
			goto end;
		}
	}
	ret = 0;

end:
	if (ret)
		ERR_print_errors(bio_err);
	sk_X509_pop_free(encerts, X509_free);
	sk_X509_pop_free(other, X509_free);
	if (vpm)
		X509_VERIFY_PARAM_free(vpm);
	if (sksigners)
		sk_OPENSSL_STRING_free(sksigners);
	if (skkeys)
		sk_OPENSSL_STRING_free(skkeys);
	free(secret_key);
	free(secret_keyid);
	free(pwri_tmp);
	if (econtent_type)
		ASN1_OBJECT_free(econtent_type);
	if (rr)
		CMS_ReceiptRequest_free(rr);
	if (rr_to)
		sk_OPENSSL_STRING_free(rr_to);
	if (rr_from)
		sk_OPENSSL_STRING_free(rr_from);
	X509_STORE_free(store);
	X509_free(cert);
	X509_free(recip);
	X509_free(signer);
	EVP_PKEY_free(key);
	CMS_ContentInfo_free(cms);
	CMS_ContentInfo_free(rcms);
	BIO_free(rctin);
	BIO_free(in);
	BIO_free(indata);
	BIO_free_all(out);
	free(passin);
	return (ret);
}

static int
save_certs(char *signerfile, STACK_OF(X509) * signers)
{
	int i;
	BIO *tmp;

	if (!signerfile)
		return 1;
	tmp = BIO_new_file(signerfile, "w");
	if (!tmp)
		return 0;
	for (i = 0; i < sk_X509_num(signers); i++)
		PEM_write_bio_X509(tmp, sk_X509_value(signers, i));
	BIO_free(tmp);
	return 1;
}

/* Minimal callback just to output policy info (if any) */

static int
cms_cb(int ok, X509_STORE_CTX * ctx)
{
	int error;

	error = X509_STORE_CTX_get_error(ctx);

	verify_err = error;

	if ((error != X509_V_ERR_NO_EXPLICIT_POLICY) &&
	    ((error != X509_V_OK) || (ok != 2)))
		return ok;

	policies_print(NULL, ctx);

	return ok;
}

static void
gnames_stack_print(BIO * out, STACK_OF(GENERAL_NAMES) * gns)
{
	STACK_OF(GENERAL_NAME) * gens;
	GENERAL_NAME *gen;
	int i, j;

	for (i = 0; i < sk_GENERAL_NAMES_num(gns); i++) {
		gens = sk_GENERAL_NAMES_value(gns, i);
		for (j = 0; j < sk_GENERAL_NAME_num(gens); j++) {
			gen = sk_GENERAL_NAME_value(gens, j);
			BIO_puts(out, "    ");
			GENERAL_NAME_print(out, gen);
			BIO_puts(out, "\n");
		}
	}
	return;
}

static void
receipt_request_print(BIO * out, CMS_ContentInfo * cms)
{
	STACK_OF(CMS_SignerInfo) * sis;
	CMS_SignerInfo *si;
	CMS_ReceiptRequest *rr;
	int allorfirst;
	STACK_OF(GENERAL_NAMES) * rto, *rlist;
	ASN1_STRING *scid;
	int i, rv;

	sis = CMS_get0_SignerInfos(cms);
	for (i = 0; i < sk_CMS_SignerInfo_num(sis); i++) {
		si = sk_CMS_SignerInfo_value(sis, i);
		rv = CMS_get1_ReceiptRequest(si, &rr);
		BIO_printf(bio_err, "Signer %d:\n", i + 1);
		if (rv == 0)
			BIO_puts(bio_err, "  No Receipt Request\n");
		else if (rv < 0) {
			BIO_puts(bio_err, "  Receipt Request Parse Error\n");
			ERR_print_errors(bio_err);
		} else {
			char *id;
			int idlen;
			CMS_ReceiptRequest_get0_values(rr, &scid, &allorfirst,
			    &rlist, &rto);
			BIO_puts(out, "  Signed Content ID:\n");
			idlen = ASN1_STRING_length(scid);
			id = (char *) ASN1_STRING_data(scid);
			BIO_dump_indent(out, id, idlen, 4);
			BIO_puts(out, "  Receipts From");
			if (rlist) {
				BIO_puts(out, " List:\n");
				gnames_stack_print(out, rlist);
			} else if (allorfirst == 1)
				BIO_puts(out, ": First Tier\n");
			else if (allorfirst == 0)
				BIO_puts(out, ": All\n");
			else
				BIO_printf(out, " Unknown (%d)\n", allorfirst);
			BIO_puts(out, "  Receipts To:\n");
			gnames_stack_print(out, rto);
		}
		if (rr)
			CMS_ReceiptRequest_free(rr);
	}
}

static STACK_OF(GENERAL_NAMES) *
make_names_stack(STACK_OF(OPENSSL_STRING) * ns)
{
	int i;
	STACK_OF(GENERAL_NAMES) * ret;
	GENERAL_NAMES *gens = NULL;
	GENERAL_NAME *gen = NULL;
	ret = sk_GENERAL_NAMES_new_null();
	if (!ret)
		goto err;
	for (i = 0; i < sk_OPENSSL_STRING_num(ns); i++) {
		char *str = sk_OPENSSL_STRING_value(ns, i);
		gen = a2i_GENERAL_NAME(NULL, NULL, NULL, GEN_EMAIL, str, 0);
		if (!gen)
			goto err;
		gens = GENERAL_NAMES_new();
		if (!gens)
			goto err;
		if (!sk_GENERAL_NAME_push(gens, gen))
			goto err;
		gen = NULL;
		if (!sk_GENERAL_NAMES_push(ret, gens))
			goto err;
		gens = NULL;
	}

	return ret;

err:
	if (ret)
		sk_GENERAL_NAMES_pop_free(ret, GENERAL_NAMES_free);
	if (gens)
		GENERAL_NAMES_free(gens);
	if (gen)
		GENERAL_NAME_free(gen);
	return NULL;
}


static CMS_ReceiptRequest *
make_receipt_request(STACK_OF(OPENSSL_STRING) * rr_to, int rr_allorfirst,
    STACK_OF(OPENSSL_STRING) * rr_from)
{
	STACK_OF(GENERAL_NAMES) * rct_to, *rct_from;
	CMS_ReceiptRequest *rr;

	rct_to = make_names_stack(rr_to);
	if (!rct_to)
		goto err;
	if (rr_from) {
		rct_from = make_names_stack(rr_from);
		if (!rct_from)
			goto err;
	} else
		rct_from = NULL;
	rr = CMS_ReceiptRequest_create0(NULL, -1, rr_allorfirst, rct_from,
	    rct_to);
	return rr;

err:
	return NULL;
}

#endif
@


1.20
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cms.c,v 1.19 2014/07/12 17:54:31 jsing Exp $ */
@


1.19
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cms.c,v 1.18 2014/06/12 15:49:27 deraadt Exp $ */
d750 1
a750 2
			pwri_tmp =
			    (unsigned char *)BUF_strdup((char *)pwri_pass);
@


1.18
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a145 3

	if (!load_config(bio_err, NULL))
		goto end;
@


1.17
log
@Stop pretending that openssl(1) applications support the -rand option.
The underlying code has long been removed, making this a no-op.

If your random subsystem actually requires that you seed it from a file,
then you really should go and buy a new random subsystem that was built
after 1990.

Diff from Brent Cook.

ok deraadt@@
@
text
@d1 1
a1 1
/* apps/cms.c */
@


1.16
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@a129 1
	char *inrand = NULL;
a316 5
		} else if (!strcmp(*args, "-rand")) {
			if (!args[1])
				goto argerr;
			args++;
			inrand = *args;
a549 3
		BIO_printf(bio_err, "-rand file:file:...\n");
		BIO_printf(bio_err, "               load the file (or the files in the directory) into\n");
		BIO_printf(bio_err, "               the random number generator\n");
@


1.15
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a147 2
	signal(SIGPIPE, SIG_IGN);

@


1.14
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d976 3
a978 6
	if (secret_key)
		free(secret_key);
	if (secret_keyid)
		free(secret_keyid);
	if (pwri_tmp)
		free(pwri_tmp);
d998 1
a998 2
	if (passin)
		free(passin);
@


1.13
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d58 1
d63 1
d65 1
a66 1
#include <openssl/err.h>
a68 1
#include <openssl/cms.h>
@


1.12
log
@deleted seed some time ago
@
text
@a148 4
	if (bio_err == NULL) {
		if ((bio_err = BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);
	}
@


1.11
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a200 4
#ifndef OPENSSL_NO_SEED
		else if (!strcmp(*args, "-seed"))
			cipher = EVP_seed_cbc();
#endif
a515 3
#endif
#ifndef OPENSSL_NO_SEED
		BIO_printf(bio_err, "-seed          encrypt with SEED\n");
@


1.10
log
@More KNF.
@
text
@d147 1
a147 1
	apps_startup();
@


1.9
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d72 2
a73 3
static CMS_ReceiptRequest *
    make_receipt_request(STACK_OF(OPENSSL_STRING) * rr_to,
    int rr_allorfirst,
d363 2
a364 1
					sksigners = sk_OPENSSL_STRING_new_null();
d397 2
a398 1
					BIO_puts(bio_err, "Illegal -inkey without -signer\n");
d402 2
a403 1
					sksigners = sk_OPENSSL_STRING_new_null();
d487 2
a488 1
			BIO_printf(bio_err, "No signer certificate specified\n");
d495 2
a496 1
			BIO_printf(bio_err, "No recipient certificate or key specified\n");
d501 2
a502 1
			BIO_printf(bio_err, "No recipient(s) certificate(s) specified\n");
d620 1
a620 1
				    NULL, e, "recipient certificate file")))
d629 1
a629 1
			    e, "certificate file"))) {
d636 1
a636 1
			    e, "recipient certificate file"))) {
d643 1
a643 1
			    e, "receipt signer certificate file"))) {
d651 2
a652 1
	} else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT)) {
d692 2
a693 1
				BIO_printf(bio_err, "Can't read content file %s\n", contfile);
d743 2
a744 1
	if ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT)) {
d765 3
a767 4
			if (!CMS_add0_recipient_key(cms, NID_undef,
				secret_key, secret_keylen,
				secret_keyid, secret_keyidlen,
				NULL, NULL, NULL))
d774 2
a775 1
			pwri_tmp = (unsigned char *) BUF_strdup((char *) pwri_pass);
d778 2
a779 3
			if (!CMS_add0_recipient_password(cms,
				-1, NID_undef, NID_undef,
				pwri_tmp, -1, NULL))
d788 2
a789 3
		cms = CMS_EncryptedData_encrypt(in, cipher,
		    secret_key, secret_keylen,
		    flags);
d838 2
a839 2
			signer = load_cert(bio_err, signerfile, FORMAT_PEM, NULL,
			    e, "signer certificate");
d872 2
a873 3
			if (!CMS_decrypt_set1_key(cms,
				secret_key, secret_keylen,
				secret_keyid, secret_keyidlen)) {
d912 1
a912 1
			indata, out, flags))
d974 1
d1021 1
a1032 1

d1059 1
d1082 1
d1120 1
a1120 2
static
STACK_OF(GENERAL_NAMES) *
d1165 1
@


1.8
log
@simplify file:file:... stuff
@
text
@a130 1
	int need_rand = 0;
a332 1
			need_rand = 1;
a489 1
		need_rand = 1;
a499 1
		need_rand = 1;
a576 6
	if (need_rand) {
		app_RAND_load_file(NULL, bio_err, (inrand != NULL));
		if (inrand != NULL)
			BIO_printf(bio_err, "%ld semi-random bytes loaded\n",
			    app_RAND_load_files(inrand));
	}
a971 2
	if (need_rand)
		app_RAND_write_file(NULL, bio_err);
@


1.7
log
@whitespace normalization
@
text
@d567 1
a567 1
		BIO_printf(bio_err, "-rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
@


1.6
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d73 1
a73 1
make_receipt_request(STACK_OF(OPENSSL_STRING) * rr_to,
d97 1
a97 1
	int verify_err = 0;
d99 1
a99 1
	int cms_main(int, char **);
d101 2
a102 2
	int
	 cms_main(int argc, char **argv)
d1125 2
a1126 1
STACK_OF(GENERAL_NAMES) * make_names_stack(STACK_OF(OPENSSL_STRING) * ns)
@


1.5
log
@KaboomNF
@
text
@a68 2
#undef PROG
#define PROG cms_main
d99 1
a99 1
	int MAIN(int, char **);
d102 1
a102 1
	 MAIN(int argc, char **argv)
@


1.4
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d71 3
a73 3
static int save_certs(char *signerfile, STACK_OF(X509) *signers);
static int cms_cb(int ok, X509_STORE_CTX *ctx);
static void receipt_request_print(BIO *out, CMS_ContentInfo *cms);
d75 1
a75 1
make_receipt_request(STACK_OF(OPENSSL_STRING) *rr_to,
d77 1
a77 1
    STACK_OF(OPENSSL_STRING) *rr_from);
d99 1
a99 1
int verify_err = 0;
d101 1
a101 1
int MAIN(int, char **);
d103 2
a104 2
int
MAIN(int argc, char **argv)
d113 1
a113 1
	STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;
d121 1
a121 1
	STACK_OF(X509) *encerts = NULL, *other = NULL;
d127 1
a127 1
	STACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;
d155 1
a155 1
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE|BIO_FP_TEXT);
a156 1

d161 1
a161 1
		if (!strcmp (*args, "-encrypt"))
d163 1
a163 1
		else if (!strcmp (*args, "-decrypt"))
d165 1
a165 1
		else if (!strcmp (*args, "-sign"))
d167 1
a167 1
		else if (!strcmp (*args, "-sign_receipt"))
d169 1
a169 1
		else if (!strcmp (*args, "-resign"))
d171 1
a171 1
		else if (!strcmp (*args, "-verify"))
d173 1
a173 1
		else if (!strcmp (*args, "-verify_retcode"))
d181 1
a181 1
		} else if (!strcmp (*args, "-cmsout"))
d183 1
a183 1
		else if (!strcmp (*args, "-data_out"))
d185 1
a185 1
		else if (!strcmp (*args, "-data_create"))
d187 1
a187 1
		else if (!strcmp (*args, "-digest_verify"))
d189 1
a189 1
		else if (!strcmp (*args, "-digest_create"))
d191 1
a191 1
		else if (!strcmp (*args, "-compress"))
d193 1
a193 1
		else if (!strcmp (*args, "-uncompress"))
d195 1
a195 1
		else if (!strcmp (*args, "-EncryptedData_decrypt"))
d197 1
a197 1
		else if (!strcmp (*args, "-EncryptedData_encrypt"))
d200 1
a200 1
		else if (!strcmp (*args, "-des3"))
d202 1
a202 1
		else if (!strcmp (*args, "-des"))
d206 1
a206 1
		else if (!strcmp (*args, "-seed"))
d210 1
a210 1
		else if (!strcmp (*args, "-rc2-40"))
d212 1
a212 1
		else if (!strcmp (*args, "-rc2-128"))
d214 1
a214 1
		else if (!strcmp (*args, "-rc2-64"))
d233 1
a233 1
		else if (!strcmp (*args, "-debug_decrypt"))
d235 1
a235 1
		else if (!strcmp (*args, "-text"))
d237 1
a237 1
		else if (!strcmp (*args, "-nointern"))
d239 2
a240 2
		else if (!strcmp (*args, "-noverify") ||
		    !strcmp (*args, "-no_signer_cert_verify"))
d242 1
a242 1
		else if (!strcmp (*args, "-nocerts"))
d244 1
a244 1
		else if (!strcmp (*args, "-noattr"))
d246 1
a246 1
		else if (!strcmp (*args, "-nodetach"))
d248 1
a248 1
		else if (!strcmp (*args, "-nosmimecap"))
d250 1
a250 1
		else if (!strcmp (*args, "-binary"))
d252 1
a252 1
		else if (!strcmp (*args, "-keyid"))
d254 1
a254 1
		else if (!strcmp (*args, "-nosigs"))
d256 1
a256 1
		else if (!strcmp (*args, "-no_content_verify"))
d258 1
a258 1
		else if (!strcmp (*args, "-no_attr_verify"))
d260 1
a260 1
		else if (!strcmp (*args, "-stream"))
d262 1
a262 1
		else if (!strcmp (*args, "-indef"))
d264 1
a264 1
		else if (!strcmp (*args, "-noindef"))
d266 1
a266 1
		else if (!strcmp (*args, "-nooldmime"))
d268 1
a268 1
		else if (!strcmp (*args, "-crlfeol"))
d270 1
a270 1
		else if (!strcmp (*args, "-noout"))
d272 1
a272 1
		else if (!strcmp (*args, "-receipt_request_print"))
d274 1
a274 1
		else if (!strcmp (*args, "-receipt_request_all"))
d276 1
a276 1
		else if (!strcmp (*args, "-receipt_request_first"))
d285 1
a285 2
		}
		else if (!strcmp(*args, "-receipt_request_to")) {
d292 1
a292 2
		}
		else if (!strcmp (*args, "-print")) {
d295 1
a295 2
		}
		else if (!strcmp(*args, "-secretkey")) {
d305 2
a306 3
			secret_keylen = (size_t)ltmp;
		}
		else if (!strcmp(*args, "-secretkeyid")) {
d316 2
a317 3
			secret_keyidlen = (size_t)ltmp;
		}
		else if (!strcmp(*args, "-pwri_password")) {
d321 1
a321 1
			pwri_pass = (unsigned char *)*args;
d349 1
a349 2
		}
		else if (!strcmp (*args, "-to")) {
d353 1
a353 2
		}
		else if (!strcmp (*args, "-from")) {
d357 1
a357 2
		}
		else if (!strcmp (*args, "-subject")) {
d361 1
a361 2
		}
		else if (!strcmp (*args, "-signer")) {
d378 1
a378 1
		} else if (!strcmp (*args, "-recip")) {
d382 1
a382 1
		} else if (!strcmp (*args, "-certsout")) {
d386 1
a386 1
		} else if (!strcmp (*args, "-md")) {
d395 1
a395 1
		} else if (!strcmp (*args, "-inkey")) {
d413 1
a413 1
		} else if (!strcmp (*args, "-keyform")) {
d417 1
a417 1
		} else if (!strcmp (*args, "-rctform")) {
d421 1
a421 1
		} else if (!strcmp (*args, "-certfile")) {
d425 1
a425 1
		} else if (!strcmp (*args, "-CAfile")) {
d429 1
a429 1
		} else if (!strcmp (*args, "-CApath")) {
d433 1
a433 1
		} else if (!strcmp (*args, "-in")) {
d437 1
a437 1
		} else if (!strcmp (*args, "-inform")) {
d441 1
a441 1
		} else if (!strcmp (*args, "-outform")) {
d445 1
a445 1
		} else if (!strcmp (*args, "-out")) {
d449 1
a449 1
		} else if (!strcmp (*args, "-content")) {
d464 1
a464 2

	if (!(operation & SMIME_SIGNERS)  && (rr_to || rr_from)) {
a471 1

d510 8
a517 8
		argerr:
		BIO_printf (bio_err, "Usage cms [options] cert.pem ...\n");
		BIO_printf (bio_err, "where options are\n");
		BIO_printf (bio_err, "-encrypt       encrypt message\n");
		BIO_printf (bio_err, "-decrypt       decrypt encrypted message\n");
		BIO_printf (bio_err, "-sign          sign message\n");
		BIO_printf (bio_err, "-verify        verify signed message\n");
		BIO_printf (bio_err, "-cmsout        output CMS structure\n");
d519 2
a520 2
		BIO_printf (bio_err, "-des3          encrypt with triple DES\n");
		BIO_printf (bio_err, "-des           encrypt with DES\n");
d523 1
a523 1
		BIO_printf (bio_err, "-seed          encrypt with SEED\n");
d526 3
a528 3
		BIO_printf (bio_err, "-rc2-40        encrypt with RC2-40 (default)\n");
		BIO_printf (bio_err, "-rc2-64        encrypt with RC2-64\n");
		BIO_printf (bio_err, "-rc2-128       encrypt with RC2-128\n");
d531 2
a532 2
		BIO_printf (bio_err, "-aes128, -aes192, -aes256\n");
		BIO_printf (bio_err, "               encrypt PEM output with cbc aes\n");
d535 2
a536 2
		BIO_printf (bio_err, "-camellia128, -camellia192, -camellia256\n");
		BIO_printf (bio_err, "               encrypt PEM output with cbc camellia\n");
d538 27
a564 27
		BIO_printf (bio_err, "-nointern      don't search certificates in message for signer\n");
		BIO_printf (bio_err, "-nosigs        don't verify message signature\n");
		BIO_printf (bio_err, "-noverify      don't verify signers certificate\n");
		BIO_printf (bio_err, "-nocerts       don't include signers certificate when signing\n");
		BIO_printf (bio_err, "-nodetach      use opaque signing\n");
		BIO_printf (bio_err, "-noattr        don't include any signed attributes\n");
		BIO_printf (bio_err, "-binary        don't translate message to text\n");
		BIO_printf (bio_err, "-certfile file other certificates file\n");
		BIO_printf (bio_err, "-certsout file certificate output file\n");
		BIO_printf (bio_err, "-signer file   signer certificate file\n");
		BIO_printf (bio_err, "-recip  file   recipient certificate file for decryption\n");
		BIO_printf (bio_err, "-keyid         use subject key identifier\n");
		BIO_printf (bio_err, "-in file       input file\n");
		BIO_printf (bio_err, "-inform arg    input format SMIME (default), PEM or DER\n");
		BIO_printf (bio_err, "-inkey file    input private key (if not signer or recipient)\n");
		BIO_printf (bio_err, "-keyform arg   input private key format (PEM or ENGINE)\n");
		BIO_printf (bio_err, "-out file      output file\n");
		BIO_printf (bio_err, "-outform arg   output format SMIME (default), PEM or DER\n");
		BIO_printf (bio_err, "-content file  supply or override content for detached signature\n");
		BIO_printf (bio_err, "-to addr       to address\n");
		BIO_printf (bio_err, "-from ad       from address\n");
		BIO_printf (bio_err, "-subject s     subject\n");
		BIO_printf (bio_err, "-text          include or delete text MIME headers\n");
		BIO_printf (bio_err, "-CApath dir    trusted certificates directory\n");
		BIO_printf (bio_err, "-CAfile file   trusted certificates file\n");
		BIO_printf (bio_err, "-crl_check     check revocation status of signer's certificate using CRLs\n");
		BIO_printf (bio_err, "-crl_check_all check revocation status of signer's certificate chain using CRLs\n");
d566 1
a566 1
		BIO_printf (bio_err, "-engine e      use engine e, possibly a hardware device.\n");
d568 5
a572 5
		BIO_printf (bio_err, "-passin arg    input file pass phrase source\n");
		BIO_printf(bio_err,  "-rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
		BIO_printf(bio_err,  "               load the file (or the files in the directory) into\n");
		BIO_printf(bio_err,  "               the random number generator\n");
		BIO_printf (bio_err, "cert.pem       recipient certificate(s) for encryption\n");
a574 1

a582 1

a588 1

a618 1

a622 1

a633 1

d636 1
a636 1
		    e, "certificate file"))) {
a640 1

d643 1
a643 1
		    e, "recipient certificate file"))) {
a647 1

d650 1
a650 1
		    e, "receipt signer certificate file"))) {
a654 1

a669 1

d672 1
a672 1
			BIO_printf (bio_err,
d703 1
a703 1
			STACK_OF(X509) *allcerts;
a714 1

d718 1
a718 1
			BIO_printf (bio_err,
a721 1

a737 1

d740 1
a740 1
			BIO_printf (bio_err,
a754 2


d770 3
a772 3
			    secret_key, secret_keylen,
			    secret_keyid, secret_keyidlen,
			    NULL, NULL, NULL))
d779 1
a779 1
			pwri_tmp = (unsigned char *)BUF_strdup((char *)pwri_pass);
d783 1
a783 1
			    -1, NID_undef, NID_undef,
d799 1
a799 1
		STACK_OF(CMS_SignerInfo) *sis;
d812 3
a814 2
		/* If detached data content we enable streaming if
		 * S/MIME output format.
a867 1

a871 1

d879 2
a880 2
			    secret_key, secret_keylen,
			    secret_keyid, secret_keyidlen)) {
a885 1

a892 1

a899 1

d919 1
a919 1
			    indata, out, flags))
d931 1
a931 1
			STACK_OF(X509) *signers;
d1025 1
a1025 1
save_certs(char *signerfile, STACK_OF(X509) *signers)
d1044 1
a1044 1
cms_cb(int ok, X509_STORE_CTX *ctx)
d1062 1
a1062 1
gnames_stack_print(BIO *out, STACK_OF(GENERAL_NAMES) *gns)
d1064 1
a1064 1
	STACK_OF(GENERAL_NAME) *gens;
d1080 1
a1080 1
receipt_request_print(BIO *out, CMS_ContentInfo *cms)
d1082 1
a1082 1
	STACK_OF(CMS_SignerInfo) *sis;
d1086 1
a1086 1
	STACK_OF(GENERAL_NAMES) *rto, *rlist;
d1106 1
a1106 1
			id = (char *)ASN1_STRING_data(scid);
d1127 1
a1127 1
STACK_OF(GENERAL_NAMES) *make_names_stack(STACK_OF(OPENSSL_STRING) *ns)
d1130 1
a1130 1
	STACK_OF(GENERAL_NAMES) *ret;
d1166 2
a1167 2
make_receipt_request(STACK_OF(OPENSSL_STRING) *rr_to, int rr_allorfirst,
    STACK_OF(OPENSSL_STRING) *rr_from)
d1169 1
a1169 1
	STACK_OF(GENERAL_NAMES) *rct_to, *rct_from;
@


1.3
log
@Initial KNF.
@
text
@d1026 1
a1026 1
		OPENSSL_free(secret_key);
d1028 1
a1028 1
		OPENSSL_free(secret_keyid);
d1030 1
a1030 1
		OPENSSL_free(pwri_tmp);
d1051 1
a1051 1
		OPENSSL_free(passin);
@


1.2
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d74 4
a77 3
static CMS_ReceiptRequest *make_receipt_request(STACK_OF(OPENSSL_STRING) *rr_to,
						int rr_allorfirst,
					STACK_OF(OPENSSL_STRING) *rr_from);
d103 3
a105 2
int MAIN(int argc, char **argv)
	{
d114 1
a114 1
	char *certfile = NULL, *keyfile = NULL, *contfile=NULL;
d136 1
a136 1
        int rctformat = FORMAT_SMIME, keyform = FORMAT_PEM;
d138 1
a138 1
	char *engine=NULL;
d153 1
a153 2
	if (bio_err == NULL)
		{
d156 1
a156 1
		}
d161 1
a161 2
	while (!badarg && *args && *args[0] == '-')
		{
d176 1
a176 2
		else if (!strcmp(*args,"-verify_receipt"))
			{
d182 1
a182 2
			}
		else if (!strcmp (*args, "-cmsout"))
d201 4
a204 4
		else if (!strcmp (*args, "-des3")) 
				cipher = EVP_des_ede3_cbc();
		else if (!strcmp (*args, "-des")) 
				cipher = EVP_des_cbc();
d207 2
a208 2
		else if (!strcmp (*args, "-seed")) 
				cipher = EVP_seed_cbc();
d211 6
a216 6
		else if (!strcmp (*args, "-rc2-40")) 
				cipher = EVP_rc2_40_cbc();
		else if (!strcmp (*args, "-rc2-128")) 
				cipher = EVP_rc2_cbc();
		else if (!strcmp (*args, "-rc2-64")) 
				cipher = EVP_rc2_64_cbc();
d219 6
a224 6
		else if (!strcmp(*args,"-aes128"))
				cipher = EVP_aes_128_cbc();
		else if (!strcmp(*args,"-aes192"))
				cipher = EVP_aes_192_cbc();
		else if (!strcmp(*args,"-aes256"))
				cipher = EVP_aes_256_cbc();
d227 6
a232 6
		else if (!strcmp(*args,"-camellia128"))
				cipher = EVP_camellia_128_cbc();
		else if (!strcmp(*args,"-camellia192"))
				cipher = EVP_camellia_192_cbc();
		else if (!strcmp(*args,"-camellia256"))
				cipher = EVP_camellia_256_cbc();
d234 15
a248 15
		else if (!strcmp (*args, "-debug_decrypt")) 
				flags |= CMS_DEBUG_DECRYPT;
		else if (!strcmp (*args, "-text")) 
				flags |= CMS_TEXT;
		else if (!strcmp (*args, "-nointern")) 
				flags |= CMS_NOINTERN;
		else if (!strcmp (*args, "-noverify") 
			|| !strcmp (*args, "-no_signer_cert_verify")) 
				flags |= CMS_NO_SIGNER_CERT_VERIFY;
		else if (!strcmp (*args, "-nocerts")) 
				flags |= CMS_NOCERTS;
		else if (!strcmp (*args, "-noattr")) 
				flags |= CMS_NOATTR;
		else if (!strcmp (*args, "-nodetach")) 
				flags &= ~CMS_DETACHED;
d250 1
a250 1
				flags |= CMS_NOSMIMECAP;
d252 1
a252 1
				flags |= CMS_BINARY;
d254 1
a254 1
				flags |= CMS_USE_KEYID;
d256 1
a256 1
				flags |= CMS_NOSIGS;
d258 1
a258 1
				flags |= CMS_NO_CONTENT_VERIFY;
d260 1
a260 1
				flags |= CMS_NO_ATTR_VERIFY;
d262 1
a262 1
				flags |= CMS_STREAM;
d264 1
a264 1
				flags |= CMS_STREAM;
d266 1
a266 1
				flags &= ~CMS_STREAM;
d268 1
a268 1
				flags |= CMS_NOOLDMIMETYPE;
d270 1
a270 1
				flags |= CMS_CRLFEOL;
d272 1
a272 1
				noout = 1;
d274 1
a274 1
				rr_print = 1;
d276 1
a276 1
				rr_allorfirst = 0;
d278 2
a279 3
				rr_allorfirst = 1;
		else if (!strcmp(*args,"-receipt_request_from"))
			{
d286 2
a287 3
			}
		else if (!strcmp(*args,"-receipt_request_to"))
			{
d294 6
a299 8
			}
		else if (!strcmp (*args, "-print"))
				{
				noout = 1;
				print = 1;
				}
		else if (!strcmp(*args,"-secretkey"))
			{
d305 1
a305 2
			if (!secret_key)
				{
d308 1
a308 1
				}
d310 2
a311 3
			}
		else if (!strcmp(*args,"-secretkeyid"))
			{
d317 1
a317 2
			if (!secret_keyid)
				{
d320 1
a320 1
				}
d322 2
a323 3
			}
		else if (!strcmp(*args,"-pwri_password"))
			{
d328 1
a328 3
			}
		else if (!strcmp(*args,"-econtent_type"))
			{
d333 1
a333 2
			if (!econtent_type)
				{
a335 1
				}
d337 1
a337 2
		else if (!strcmp(*args,"-rand"))
			{
d343 1
a343 1
			}
d345 1
a345 2
		else if (!strcmp(*args,"-engine"))
			{
d349 1
a349 1
			}
d351 1
a351 2
		else if (!strcmp(*args,"-passin"))
			{
d355 2
a356 3
			}
		else if (!strcmp (*args, "-to"))
			{
d360 2
a361 3
			}
		else if (!strcmp (*args, "-from"))
			{
d365 2
a366 3
			}
		else if (!strcmp (*args, "-subject"))
			{
d370 2
a371 3
			}
		else if (!strcmp (*args, "-signer"))
			{
d376 1
a376 2
			if (signerfile)
				{
d386 1
a386 1
				}
d388 1
a388 3
			}
		else if (!strcmp (*args, "-recip"))
			{
d392 1
a392 3
			}
		else if (!strcmp (*args, "-certsout"))
			{
d396 1
a396 3
			}
		else if (!strcmp (*args, "-md"))
			{
d400 1
a400 2
			if (sign_md == NULL)
				{
d402 1
a402 1
							*args);
a403 1
				}
d405 2
a406 3
		else if (!strcmp (*args, "-inkey"))
			{
			if (!args[1])	
d409 2
a410 4
			if (keyfile)
				{
				if (!signerfile)
					{
d413 1
a413 1
					}
d421 1
a421 1
				}
d423 1
a423 3
			}
		else if (!strcmp (*args, "-keyform"))
			{
d427 1
a427 3
			}
		else if (!strcmp (*args, "-rctform"))
			{
d431 1
a431 3
			}
		else if (!strcmp (*args, "-certfile"))
			{
d435 1
a435 3
			}
		else if (!strcmp (*args, "-CAfile"))
			{
d439 1
a439 3
			}
		else if (!strcmp (*args, "-CApath"))
			{
d443 1
a443 3
			}
		else if (!strcmp (*args, "-in"))
			{
d447 1
a447 3
			}
		else if (!strcmp (*args, "-inform"))
			{
d451 1
a451 3
			}
		else if (!strcmp (*args, "-outform"))
			{
d455 1
a455 3
			}
		else if (!strcmp (*args, "-out"))
			{
d459 1
a459 3
			}
		else if (!strcmp (*args, "-content"))
			{
d463 1
a463 2
			}
		else if (args_verify(&args, NULL, &badarg, bio_err, &vpm))
d468 1
a468 1
		}
d470 1
a470 2
	if (((rr_allorfirst != -1) || rr_from) && !rr_to)
		{
d473 1
a473 1
		}
d475 1
a475 2
	if (!(operation & SMIME_SIGNERS)  && (rr_to || rr_from))
		{
d478 2
a479 3
		}
	if (!(operation & SMIME_SIGNERS) && (skkeys || sksigners))
		{
d482 1
a482 1
		}
d484 2
a485 4
	if (operation & SMIME_SIGNERS)
		{
		if (keyfile && !signerfile)
			{
d488 1
a488 1
			}
d490 1
a490 2
		if (signerfile)
			{
d499 2
a500 3
			}
		if (!sksigners)
			{
d503 1
a503 1
			}
d507 2
a508 6
		}

	else if (operation == SMIME_DECRYPT)
		{
		if (!recipfile && !keyfile && !secret_key && !pwri_pass)
			{
a510 1
			}
d512 2
a513 4
	else if (operation == SMIME_ENCRYPT)
		{
		if (!*args && !secret_key && !pwri_pass)
			{
d516 1
a516 1
			}
d518 1
a518 2
		}
	else if (!operation)
d521 1
a521 2
	if (badarg)
		{
d586 1
a586 1
		}
d589 1
a589 1
        e = setup_engine(bio_err, engine, 0);
d592 1
a592 2
	if (!app_passwd(bio_err, passargin, NULL, &passin, NULL))
		{
d595 1
a595 1
		}
d597 1
a597 2
	if (need_rand)
		{
d600 3
a602 3
			BIO_printf(bio_err,"%ld semi-random bytes loaded\n",
				app_RAND_load_files(inrand));
		}
d609 1
a609 2
	if (operation & SMIME_OP)
		{
d612 1
a612 3
		}
	else
		{
d615 1
a615 1
		}
d617 1
a617 2
	if (operation & SMIME_IP)
		{
d620 1
a620 3
		}
	else
		{
d623 1
a623 1
		}
d625 3
a627 5
	if (operation == SMIME_ENCRYPT)
		{
		if (!cipher)
			{
#ifndef OPENSSL_NO_DES			
d633 1
a633 1
			}
d635 1
a635 2
		if (secret_key && !secret_keyid)
			{
d638 1
a638 1
			}
d642 3
a644 4
		while (*args)
			{
			if (!(cert = load_cert(bio_err,*args,FORMAT_PEM,
				NULL, e, "recipient certificate file")))
a648 1
			}
d650 1
d652 3
a654 5
	if (certfile)
		{
		if (!(other = load_certs(bio_err,certfile,FORMAT_PEM, NULL,
			e, "certificate file")))
			{
a656 1
			}
d658 1
d660 3
a662 5
	if (recipfile && (operation == SMIME_DECRYPT))
		{
		if (!(recip = load_cert(bio_err,recipfile,FORMAT_PEM,NULL,
			e, "recipient certificate file")))
			{
a664 1
			}
d666 1
d668 3
a670 5
	if (operation == SMIME_SIGN_RECEIPT)
		{
		if (!(signer = load_cert(bio_err,signerfile,FORMAT_PEM,NULL,
			e, "receipt signer certificate file")))
			{
a672 1
			}
d674 1
d676 1
a676 2
	if (operation == SMIME_DECRYPT)
		{
d679 1
a679 3
		}
	else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT))
		{
d682 2
a683 2
		}
	else keyfile = NULL;
d685 1
a685 2
	if (keyfile)
		{
d687 1
a687 1
			       "signing key file");
d690 1
a690 1
		}
d692 2
a693 4
	if (infile)
		{
		if (!(in = BIO_new_file(infile, inmode)))
			{
d695 1
a695 1
				 "Can't open input file %s\n", infile);
a696 1
			}
d698 1
a698 1
	else
d701 2
a702 3
	if (operation & SMIME_IP)
		{
		if (informat == FORMAT_SMIME) 
d704 1
a704 1
		else if (informat == FORMAT_PEM) 
d706 1
a706 1
		else if (informat == FORMAT_ASN1) 
d708 1
a708 2
		else
			{
d711 1
a711 1
			}
d713 1
a713 2
		if (!cms)
			{
d716 2
a717 3
			}
		if (contfile)
			{
d719 1
a719 2
			if (!(indata = BIO_new_file(contfile, "rb")))
				{
a721 1
				}
d723 2
a724 2
		if (certsoutfile)
			{
d727 1
a727 2
			if (!save_certs(certsoutfile, allcerts))
				{
d729 2
a730 2
						"Error writing certs to %s\n",
								certsoutfile);
d733 1
a733 1
				}
a734 1
			}
d736 1
d738 1
a738 2
	if (rctfile)
		{
d740 1
a740 2
		if (!(rctin = BIO_new_file(rctfile, rctmode)))
			{
d742 1
a742 1
				 "Can't open receipt file %s\n", rctfile);
d744 3
a746 3
			}
		
		if (rctformat == FORMAT_SMIME) 
d748 1
a748 1
		else if (rctformat == FORMAT_PEM) 
d750 1
a750 1
		else if (rctformat == FORMAT_ASN1) 
d752 1
a752 2
		else
			{
d755 1
a755 1
			}
d757 1
a757 2
		if (!rcms)
			{
a759 1
			}
d761 1
d763 2
a764 4
	if (outfile)
		{
		if (!(out = BIO_new_file(outfile, outmode)))
			{
d766 1
a766 1
				 "Can't open output file %s\n", outfile);
a767 1
			}
d769 1
a769 2
	else
		{
d771 1
a771 1
		}
d773 1
a773 2
	if ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT))
		{
d779 1
a779 1
		}
d784 1
a784 2
	if (operation == SMIME_DATA_CREATE)
		{
d786 1
a786 3
		}
	else if (operation == SMIME_DIGEST_CREATE)
		{
d788 1
a788 3
		}
	else if (operation == SMIME_COMPRESS)
		{
d790 1
a790 3
		}
	else if (operation == SMIME_ENCRYPT)
		{
d795 5
a799 6
		if (secret_key)
			{
			if (!CMS_add0_recipient_key(cms, NID_undef, 
						secret_key, secret_keylen,
						secret_keyid, secret_keyidlen,
						NULL, NULL, NULL))
d804 2
a805 3
			}
		if (pwri_pass)
			{
d810 2
a811 2
						-1, NID_undef, NID_undef,
						 pwri_tmp, -1, NULL))
d814 2
a815 3
			}
		if (!(flags & CMS_STREAM))
			{
a817 1
			}
d819 1
a819 2
	else if (operation == SMIME_ENCRYPTED_ENCRYPT)
		{
d821 2
a822 2
						secret_key, secret_keylen,
						flags);
d824 1
a824 3
		}
	else if (operation == SMIME_SIGN_RECEIPT)
		{
d837 1
a837 3
		}
	else if (operation & SMIME_SIGNERS)
		{
d842 3
a844 5
		if (operation == SMIME_SIGN)
			{
				
			if (flags & CMS_DETACHED)
				{
d847 1
a847 1
				}
d855 1
a855 2
			if (rr_to)
				{
d857 2
a858 3
								rr_from);
				if (!rr)
					{
d860 1
a860 1
				"Signed Receipt Request Creation Error\n");
a861 1
					}
d864 1
a864 1
		else
d866 1
a866 2
		for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++)
			{
d870 2
a871 2
			signer = load_cert(bio_err, signerfile,FORMAT_PEM, NULL,
					e, "signer certificate");
d875 1
a875 1
			       "signing key file");
d887 1
a887 1
			}
d889 1
a889 2
		if ((operation == SMIME_SIGN) && !(flags & CMS_STREAM))
			{
a891 1
			}
d893 1
d895 1
a895 2
	if (!cms)
		{
d898 1
a898 1
		}
d901 1
a901 2
	if (operation == SMIME_DECRYPT)
		{
d905 1
a905 2
		if (secret_key)
			{
d907 2
a908 3
						secret_key, secret_keylen,
						secret_keyid, secret_keyidlen))
				{
d910 1
a910 1
					"Error decrypting CMS using secret key\n");
a911 1
				}
d913 1
d915 2
a916 4
		if (key)
			{
			if (!CMS_decrypt_set1_pkey(cms, key, recip))
				{
d918 1
a918 1
					"Error decrypting CMS using private key\n");
a919 1
				}
d921 1
d923 2
a924 4
		if (pwri_pass)
			{
			if (!CMS_decrypt_set1_password(cms, pwri_pass, -1))
				{
d926 1
a926 1
					"Error decrypting CMS using password\n");
a927 1
				}
d929 1
d931 1
a931 2
		if (!CMS_decrypt(cms, NULL, NULL, indata, out, flags))
			{
a933 1
			}
d935 1
a935 2
	else if (operation == SMIME_DATAOUT)
		{
d938 1
a938 3
		}
	else if (operation == SMIME_UNCOMPRESS)
		{
d941 1
a941 3
		}
	else if (operation == SMIME_DIGEST_VERIFY)
		{
d944 1
a944 2
		else
			{
a946 1
			}
d948 1
a948 2
	else if (operation == SMIME_ENCRYPTED_DECRYPT)
		{
d950 1
a950 1
						indata, out, flags))
d952 1
a952 3
		}
	else if (operation == SMIME_VERIFY)
		{
d955 1
a955 2
		else
			{
d960 2
a961 3
			}
		if (signerfile)
			{
d964 1
a964 2
			if (!save_certs(signerfile, signers))
				{
d966 2
a967 2
						"Error writing signers to %s\n",
								signerfile);
d970 1
a970 1
				}
d972 1
a972 1
			}
d975 2
a976 4
					
		}
	else if (operation == SMIME_VERIFY_RECEIPT)
		{
d979 1
a979 2
		else
			{
a981 1
			}
d983 2
a984 4
	else
		{
		if (noout)
			{
d987 1
a987 3
			}
		else if (outformat == FORMAT_SMIME)
			{
d998 1
a998 2
			}
		else if (outformat == FORMAT_PEM) 
d1000 3
a1002 4
		else if (outformat == FORMAT_ASN1) 
			ret = i2d_CMS_bio_stream(out,cms, in, flags);
		else
			{
d1005 2
a1006 3
			}
		if (ret <= 0)
			{
a1008 1
			}
d1010 1
d1050 2
a1051 1
	if (passin) OPENSSL_free(passin);
d1055 3
a1057 2
static int save_certs(char *signerfile, STACK_OF(X509) *signers)
	{
d1063 3
a1065 2
	if (!tmp) return 0;
	for(i = 0; i < sk_X509_num(signers); i++)
d1069 2
a1070 2
	}
	
d1074 3
a1076 2
static int cms_cb(int ok, X509_STORE_CTX *ctx)
	{
d1083 2
a1084 2
	if ((error != X509_V_ERR_NO_EXPLICIT_POLICY)
		&& ((error != X509_V_OK) || (ok != 2)))
d1090 1
d1092 3
a1094 4
	}

static void gnames_stack_print(BIO *out, STACK_OF(GENERAL_NAMES) *gns)
	{
d1098 1
a1098 2
	for (i = 0; i < sk_GENERAL_NAMES_num(gns); i++)
		{
d1100 1
a1100 2
		for (j = 0; j < sk_GENERAL_NAME_num(gens); j++)
			{
a1104 1
			}
d1106 1
d1108 1
a1108 1
	}
d1110 3
a1112 2
static void receipt_request_print(BIO *out, CMS_ContentInfo *cms)
	{
d1121 1
a1121 2
	for (i = 0; i < sk_CMS_SignerInfo_num(sis); i++)
		{
d1127 1
a1127 2
		else if (rv < 0)
			{
d1130 1
a1130 3
			}
		else
			{
d1134 1
a1134 1
							&rlist, &rto);
d1140 1
a1140 2
			if (rlist)
				{
d1143 1
a1143 2
				}
			else if (allorfirst == 1)
d1151 1
a1151 1
			}
a1153 1
		}
d1155 1
d1157 3
a1159 2
static STACK_OF(GENERAL_NAMES) *make_names_stack(STACK_OF(OPENSSL_STRING) *ns)
	{
d1167 1
a1167 2
	for (i = 0; i < sk_OPENSSL_STRING_num(ns); i++)
		{
d1181 1
a1181 1
		}
d1185 1
a1185 1
	err:
d1193 1
a1193 1
	}
d1196 4
a1199 4
static CMS_ReceiptRequest *make_receipt_request(STACK_OF(OPENSSL_STRING) *rr_to,
						int rr_allorfirst,
						STACK_OF(OPENSSL_STRING) *rr_from)
	{
d1205 1
a1205 2
	if (rr_from)
		{
d1209 1
a1209 2
		}
	else
d1212 1
a1212 1
						rct_to);
d1214 2
a1215 1
	err:
d1217 1
a1217 1
	}
@


1.1
log
@Initial revision
@
text
@d74 3
a76 2
static CMS_ReceiptRequest *make_receipt_request(STACK *rr_to, int rr_allorfirst,
								STACK *rr_from);
d98 2
d111 1
a111 1
	STACK *sksigners = NULL, *skkeys = NULL;
d122 2
a123 1
	int flags = CMS_DETACHED;
d125 1
a125 1
	STACK *rr_to = NULL, *rr_from = NULL;
d139 1
d174 2
d236 2
d264 1
a264 4
				{
				args++;
				continue;
				}
d266 1
a266 4
				{
				args++;
				continue;
				}
d273 2
d287 2
a288 2
				rr_from = sk_new_null();
			sk_push(rr_from, *args);
d296 2
a297 2
				rr_to = sk_new_null();
			sk_push(rr_to, *args);
d299 5
d332 7
d400 2
a401 2
					sksigners = sk_new_null();
				sk_push(sksigners, signerfile);
d405 2
a406 2
					skkeys = sk_new_null();
				sk_push(skkeys, keyfile);
d448 2
a449 2
					sksigners = sk_new_null();
				sk_push(sksigners, signerfile);
d452 2
a453 2
					skkeys = sk_new_null();
				sk_push(skkeys, keyfile);
d552 2
a553 2
				sksigners = sk_new_null();
			sk_push(sksigners, signerfile);
d555 1
a555 1
				skkeys = sk_new_null();
d558 1
a558 1
			sk_push(skkeys, keyfile);
d572 1
a572 1
		if (!recipfile && !keyfile && !secret_key)
d580 1
a580 1
		if (!*args && !secret_key)
d631 1
a631 1
		BIO_printf (bio_err, "-skeyid        use subject key identifier\n");
d717 1
a717 1
			BIO_printf(bio_err, "No sectre key id\n");
a880 6
#ifdef OPENSSL_SYS_VMS
		{
		    BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		    out = BIO_push(tmpbio, out);
		}
#endif
d887 1
a887 1
		X509_STORE_set_verify_cb_func(store, cms_cb);
d924 11
d998 1
a998 1
		for (i = 0; i < sk_num(sksigners); i++)
d1001 2
a1002 2
			signerfile = sk_value(sksigners, i);
			keyfile = sk_value(skkeys, i);
d1038 2
d1063 10
d1112 2
d1146 6
a1151 1
		if (outformat == FORMAT_SMIME)
d1165 1
a1165 1
			ret = PEM_write_bio_CMS(out, cms);
d1167 1
a1167 1
			ret = i2d_CMS_bio(out,cms);
d1190 1
a1190 1
		sk_free(sksigners);
d1192 1
a1192 1
		sk_free(skkeys);
d1197 2
d1204 1
a1204 1
		sk_free(rr_to);
d1206 1
a1206 1
		sk_free(rr_from);
d1245 2
d1328 1
a1328 1
static STACK_OF(GENERAL_NAMES) *make_names_stack(STACK *ns)
d1337 1
a1337 1
	for (i = 0; i < sk_num(ns); i++)
d1339 2
a1340 4
		CONF_VALUE cnf;
		cnf.name = "email";
		cnf.value = sk_value(ns, i);
		gen = v2i_GENERAL_NAME(NULL, NULL, &cnf);
d1367 3
a1369 2
static CMS_ReceiptRequest *make_receipt_request(STACK *rr_to, int rr_allorfirst,
								STACK *rr_from)
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.0a
@
text
@d74 2
a75 3
static CMS_ReceiptRequest *make_receipt_request(STACK_OF(OPENSSL_STRING) *rr_to,
						int rr_allorfirst,
					STACK_OF(OPENSSL_STRING) *rr_from);
a96 2
int verify_err = 0;

d108 1
a108 1
	STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;
d119 1
a119 2
	int flags = CMS_DETACHED, noout = 0, print = 0;
	int verify_retcode = 0;
d121 1
a121 1
	STACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;
a168 2
		else if (!strcmp (*args, "-verify_retcode"))
			verify_retcode = 1;
d255 4
a258 1
				flags |= CMS_STREAM;
d260 4
a263 1
				flags |= CMS_STREAM;
a269 2
		else if (!strcmp (*args, "-noout"))
				noout = 1;
d282 2
a283 2
				rr_from = sk_OPENSSL_STRING_new_null();
			sk_OPENSSL_STRING_push(rr_from, *args);
d291 2
a292 2
				rr_to = sk_OPENSSL_STRING_new_null();
			sk_OPENSSL_STRING_push(rr_to, *args);
a293 5
		else if (!strcmp (*args, "-print"))
				{
				noout = 1;
				print = 1;
				}
d383 2
a384 2
					sksigners = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(sksigners, signerfile);
d388 2
a389 2
					skkeys = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(skkeys, keyfile);
d431 2
a432 2
					sksigners = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(sksigners, signerfile);
d435 2
a436 2
					skkeys = sk_OPENSSL_STRING_new_null();
				sk_OPENSSL_STRING_push(skkeys, keyfile);
d535 2
a536 2
				sksigners = sk_OPENSSL_STRING_new_null();
			sk_OPENSSL_STRING_push(sksigners, signerfile);
d538 1
a538 1
				skkeys = sk_OPENSSL_STRING_new_null();
d541 1
a541 1
			sk_OPENSSL_STRING_push(skkeys, keyfile);
d700 1
a700 1
			BIO_printf(bio_err, "No secret key id\n");
d876 1
a876 1
		X509_STORE_set_verify_cb(store, cms_cb);
d976 1
a976 1
		for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++)
d979 2
a980 2
			signerfile = sk_OPENSSL_STRING_value(sksigners, i);
			keyfile = sk_OPENSSL_STRING_value(skkeys, i);
a1077 2
			if (verify_retcode)
				ret = verify_err + 32;
d1110 1
a1110 6
		if (noout)
			{
			if (print)
				CMS_ContentInfo_print_ctx(out, cms, 0, NULL);
			}
		else if (outformat == FORMAT_SMIME)
d1124 1
a1124 1
			ret = PEM_write_bio_CMS_stream(out, cms, in, flags);
d1126 1
a1126 1
			ret = i2d_CMS_bio_stream(out,cms, in, flags);
d1149 1
a1149 1
		sk_OPENSSL_STRING_free(sksigners);
d1151 1
a1151 1
		sk_OPENSSL_STRING_free(skkeys);
d1161 1
a1161 1
		sk_OPENSSL_STRING_free(rr_to);
d1163 1
a1163 1
		sk_OPENSSL_STRING_free(rr_from);
a1201 2
	verify_err = error;

d1283 1
a1283 1
static STACK_OF(GENERAL_NAMES) *make_names_stack(STACK_OF(OPENSSL_STRING) *ns)
d1292 1
a1292 1
	for (i = 0; i < sk_OPENSSL_STRING_num(ns); i++)
d1294 4
a1297 2
		char *str = sk_OPENSSL_STRING_value(ns, i);
		gen = a2i_GENERAL_NAME(NULL, NULL, NULL, GEN_EMAIL, str, 0);
d1324 2
a1325 3
static CMS_ReceiptRequest *make_receipt_request(STACK_OF(OPENSSL_STRING) *rr_to,
						int rr_allorfirst,
						STACK_OF(OPENSSL_STRING) *rr_from)
@


1.1.1.3
log
@OpenSSL 1.0.0f: import upstream source
@
text
@d621 1
a621 1
		BIO_printf (bio_err, "-keyid        use subject key identifier\n");
@


1.1.1.4
log
@import OpenSSL-1.0.1c
@
text
@a138 1
	unsigned char *pwri_pass = NULL, *pwri_tmp = NULL;
a328 7
		else if (!strcmp(*args,"-pwri_password"))
			{
			if (!args[1])
				goto argerr;
			args++;
			pwri_pass = (unsigned char *)*args;
			}
d562 1
a562 1
		if (!recipfile && !keyfile && !secret_key && !pwri_pass)
d570 1
a570 1
		if (!*args && !secret_key && !pwri_pass)
d621 1
a621 1
		BIO_printf (bio_err, "-keyid         use subject key identifier\n");
a919 11
		if (pwri_pass)
			{
			pwri_tmp = (unsigned char *)BUF_strdup((char *)pwri_pass);
			if (!pwri_tmp)
				goto end;
			if (!CMS_add0_recipient_password(cms,
						-1, NID_undef, NID_undef,
						 pwri_tmp, -1, NULL))
				goto end;
			pwri_tmp = NULL;
			}
a1045 10
		if (pwri_pass)
			{
			if (!CMS_decrypt_set1_password(cms, pwri_pass, -1))
				{
				BIO_puts(bio_err,
					"Error decrypting CMS using password\n");
				goto end;
				}
			}

a1169 2
	if (pwri_tmp)
		OPENSSL_free(pwri_tmp);
@


1.1.1.5
log
@Import OpenSSL 1.0.1g
@
text
@a235 2
		else if (!strcmp (*args, "-debug_decrypt")) 
				flags |= CMS_DEBUG_DECRYPT;
a1041 2
		if (flags & CMS_DEBUG_DECRYPT)
			CMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);
@


