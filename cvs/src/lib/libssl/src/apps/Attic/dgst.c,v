head	1.40;
access;
symbols
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	butholakala:1.18
	openssl_1_0_1_g:1.1.1.12
	OPENBSD_5_5:1.17.0.8
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	openssl_1_0_1_c:1.1.1.11
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	openssl_1_0_0_f:1.1.1.10
	openssl_1_0_0_e:1.1.1.10
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	openssh_1_0_0_a:1.1.1.10
	OPENBSD_4_8:1.15.0.8
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	openssl_0_9_8_k:1.1.1.9
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	openssl_0_9_8_j:1.1.1.9
	openssl_0_9_8_h:1.1.1.8
	pre_openssl_0_9_8h:1.13
	OPENBSD_4_4:1.13.0.14
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.12
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	openssl_0_9_7j:1.1.1.7
	openssl:1.1.1
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENSSL_0_9_7G:1.1.1.7
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENSSL_0_9_7D:1.1.1.6
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENSSL_0_9_7C:1.1.1.5
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENSSL_0_9_7B:1.1.1.5
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.4
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.39;
commitid	7A7DObXgY4Fni8xJ;

1.39
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	EB0l28piqIRSpBUh;

1.38
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.37;
commitid	0NuggCO2WJOZj8Kh;

1.37
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	mJUVYpkFBZ0Zv2bG;

1.36
date	2014.06.07.14.41.56;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	2nvnQBrv22dLtvTt;

1.35
date	2014.06.02.16.23.18;	author jsing;	state Exp;
branches;
next	1.34;
commitid	IqYoI5gjfSomu7k2;

1.34
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.19.12.18.23;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.02.17.06.46;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.18.04.17.16;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.17.21.55.07;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.20.58.07;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.17.15.17.22;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.16.17.04.13;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.01.22.58.50;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.09.12.15.19;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.29.05.39.15;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.04.06.55.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.12.04.13.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.10.16.31.53;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.01.19.51.16;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.56.54;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.08;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.15;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.07;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.07;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.30;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.34.17;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.42.40;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.34.18;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.41.28;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.36.58;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.01.09.12.13.48;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: dgst.c,v 1.39 2014/07/14 00:35:10 deraadt Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "apps.h"

#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/hmac.h>
#include <openssl/objects.h>
#include <openssl/pem.h>
#include <openssl/x509.h>

#define BUFSIZE	1024*8

int
do_fp(BIO * out, unsigned char *buf, BIO * bp, int sep, int binout,
    EVP_PKEY * key, unsigned char *sigin, int siglen,
    const char *sig_name, const char *md_name,
    const char *file, BIO * bmd);

static void
list_md_fn(const EVP_MD * m, const char *from, const char *to, void *arg)
{
	const char *mname;
	/* Skip aliases */
	if (!m)
		return;
	mname = OBJ_nid2ln(EVP_MD_type(m));
	/* Skip shortnames */
	if (strcmp(from, mname))
		return;
	/* Skip clones */
	if (EVP_MD_flags(m) & EVP_MD_FLAG_PKEY_DIGEST)
		return;
	if (strchr(mname, ' '))
		mname = EVP_MD_name(m);
	BIO_printf(arg, "-%-14s to use the %s message digest algorithm\n",
	    mname, mname);
}

int dgst_main(int, char **);

int
dgst_main(int argc, char **argv)
{
	ENGINE *e = NULL;
	unsigned char *buf = NULL;
	int i, err = 1;
	const EVP_MD *md = NULL, *m;
	BIO *in = NULL, *inp;
	BIO *bmd = NULL;
	BIO *out = NULL;
#define PROG_NAME_SIZE  39
	char pname[PROG_NAME_SIZE + 1];
	int separator = 0;
	int debug = 0;
	int keyform = FORMAT_PEM;
	const char *outfile = NULL, *keyfile = NULL;
	const char *sigfile = NULL;
	int out_bin = -1, want_pub = 0, do_verify = 0;
	EVP_PKEY *sigkey = NULL;
	unsigned char *sigbuf = NULL;
	int siglen = 0;
	char *passargin = NULL, *passin = NULL;
#ifndef OPENSSL_NO_ENGINE
	char *engine = NULL;
#endif
	char *hmac_key = NULL;
	char *mac_name = NULL;
	STACK_OF(OPENSSL_STRING) * sigopts = NULL, *macopts = NULL;

	if ((buf = malloc(BUFSIZE)) == NULL) {
		BIO_printf(bio_err, "out of memory\n");
		goto end;
	}

	/* first check the program name */
	program_name(argv[0], pname, sizeof pname);

	md = EVP_get_digestbyname(pname);

	argc--;
	argv++;
	while (argc > 0) {
		if ((*argv)[0] != '-')
			break;
		if (strcmp(*argv, "-c") == 0)
			separator = 1;
		else if (strcmp(*argv, "-r") == 0)
			separator = 2;
		else if (strcmp(*argv, "-out") == 0) {
			if (--argc < 1)
				break;
			outfile = *(++argv);
		} else if (strcmp(*argv, "-sign") == 0) {
			if (--argc < 1)
				break;
			keyfile = *(++argv);
		} else if (!strcmp(*argv, "-passin")) {
			if (--argc < 1)
				break;
			passargin = *++argv;
		} else if (strcmp(*argv, "-verify") == 0) {
			if (--argc < 1)
				break;
			keyfile = *(++argv);
			want_pub = 1;
			do_verify = 1;
		} else if (strcmp(*argv, "-prverify") == 0) {
			if (--argc < 1)
				break;
			keyfile = *(++argv);
			do_verify = 1;
		} else if (strcmp(*argv, "-signature") == 0) {
			if (--argc < 1)
				break;
			sigfile = *(++argv);
		} else if (strcmp(*argv, "-keyform") == 0) {
			if (--argc < 1)
				break;
			keyform = str2fmt(*(++argv));
		}
#ifndef OPENSSL_NO_ENGINE
		else if (strcmp(*argv, "-engine") == 0) {
			if (--argc < 1)
				break;
			engine = *(++argv);
			e = setup_engine(bio_err, engine, 0);
		}
#endif
		else if (strcmp(*argv, "-hex") == 0)
			out_bin = 0;
		else if (strcmp(*argv, "-binary") == 0)
			out_bin = 1;
		else if (strcmp(*argv, "-d") == 0)
			debug = 1;
		else if (!strcmp(*argv, "-hmac")) {
			if (--argc < 1)
				break;
			hmac_key = *++argv;
		} else if (!strcmp(*argv, "-mac")) {
			if (--argc < 1)
				break;
			mac_name = *++argv;
		} else if (strcmp(*argv, "-sigopt") == 0) {
			if (--argc < 1)
				break;
			if (!sigopts)
				sigopts = sk_OPENSSL_STRING_new_null();
			if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))
				break;
		} else if (strcmp(*argv, "-macopt") == 0) {
			if (--argc < 1)
				break;
			if (!macopts)
				macopts = sk_OPENSSL_STRING_new_null();
			if (!macopts || !sk_OPENSSL_STRING_push(macopts, *(++argv)))
				break;
		} else if ((m = EVP_get_digestbyname(&((*argv)[1]))) != NULL)
			md = m;
		else
			break;
		argc--;
		argv++;
	}


	if (do_verify && !sigfile) {
		BIO_printf(bio_err, "No signature to verify: use the -signature option\n");
		goto end;
	}
	if ((argc > 0) && (argv[0][0] == '-')) {	/* bad option */
		BIO_printf(bio_err, "unknown option '%s'\n", *argv);
		BIO_printf(bio_err, "options are\n");
		BIO_printf(bio_err, "-c              to output the digest with separating colons\n");
		BIO_printf(bio_err, "-r              to output the digest in coreutils format\n");
		BIO_printf(bio_err, "-d              to output debug info\n");
		BIO_printf(bio_err, "-hex            output as hex dump\n");
		BIO_printf(bio_err, "-binary         output in binary form\n");
		BIO_printf(bio_err, "-sign   file    sign digest using private key in file\n");
		BIO_printf(bio_err, "-verify file    verify a signature using public key in file\n");
		BIO_printf(bio_err, "-prverify file  verify a signature using private key in file\n");
		BIO_printf(bio_err, "-keyform arg    key file format (PEM or ENGINE)\n");
		BIO_printf(bio_err, "-out filename   output to filename rather than stdout\n");
		BIO_printf(bio_err, "-signature file signature to verify\n");
		BIO_printf(bio_err, "-sigopt nm:v    signature parameter\n");
		BIO_printf(bio_err, "-hmac key       create hashed MAC with key\n");
		BIO_printf(bio_err, "-mac algorithm  create MAC (not neccessarily HMAC)\n");
		BIO_printf(bio_err, "-macopt nm:v    MAC algorithm parameters or key\n");
#ifndef OPENSSL_NO_ENGINE
		BIO_printf(bio_err, "-engine e       use engine e, possibly a hardware device.\n");
#endif

		EVP_MD_do_all_sorted(list_md_fn, bio_err);
		goto end;
	}
	in = BIO_new(BIO_s_file());
	bmd = BIO_new(BIO_f_md());
	if (debug) {
		BIO_set_callback(in, BIO_debug_callback);
		/* needed for windows 3.1 */
		BIO_set_callback_arg(in, (char *) bio_err);
	}
	if (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
	}
	if ((in == NULL) || (bmd == NULL)) {
		ERR_print_errors(bio_err);
		goto end;
	}
	if (out_bin == -1) {
		if (keyfile)
			out_bin = 1;
		else
			out_bin = 0;
	}

	if (outfile) {
		if (out_bin)
			out = BIO_new_file(outfile, "wb");
		else
			out = BIO_new_file(outfile, "w");
	} else {
		out = BIO_new_fp(stdout, BIO_NOCLOSE);
	}

	if (!out) {
		BIO_printf(bio_err, "Error opening output file %s\n",
		    outfile ? outfile : "(stdout)");
		ERR_print_errors(bio_err);
		goto end;
	}
	if ((!!mac_name + !!keyfile + !!hmac_key) > 1) {
		BIO_printf(bio_err, "MAC and Signing key cannot both be specified\n");
		goto end;
	}
	if (keyfile) {
		if (want_pub)
			sigkey = load_pubkey(bio_err, keyfile, keyform, 0, NULL,
			    e, "key file");
		else
			sigkey = load_key(bio_err, keyfile, keyform, 0, passin,
			    e, "key file");
		if (!sigkey) {
			/*
			 * load_[pub]key() has already printed an appropriate
			 * message
			 */
			goto end;
		}
	}
	if (mac_name) {
		EVP_PKEY_CTX *mac_ctx = NULL;
		int r = 0;
		if (!init_gen_str(bio_err, &mac_ctx, mac_name, e, 0))
			goto mac_end;
		if (macopts) {
			char *macopt;
			for (i = 0; i < sk_OPENSSL_STRING_num(macopts); i++) {
				macopt = sk_OPENSSL_STRING_value(macopts, i);
				if (pkey_ctrl_string(mac_ctx, macopt) <= 0) {
					BIO_printf(bio_err,
					    "MAC parameter error \"%s\"\n",
					    macopt);
					ERR_print_errors(bio_err);
					goto mac_end;
				}
			}
		}
		if (EVP_PKEY_keygen(mac_ctx, &sigkey) <= 0) {
			BIO_puts(bio_err, "Error generating key\n");
			ERR_print_errors(bio_err);
			goto mac_end;
		}
		r = 1;
mac_end:
		if (mac_ctx)
			EVP_PKEY_CTX_free(mac_ctx);
		if (r == 0)
			goto end;
	}
	if (hmac_key) {
		sigkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, e,
		    (unsigned char *) hmac_key, -1);
		if (!sigkey)
			goto end;
	}
	if (sigkey) {
		EVP_MD_CTX *mctx = NULL;
		EVP_PKEY_CTX *pctx = NULL;
		int r;
		if (!BIO_get_md_ctx(bmd, &mctx)) {
			BIO_printf(bio_err, "Error getting context\n");
			ERR_print_errors(bio_err);
			goto end;
		}
		if (do_verify)
			r = EVP_DigestVerifyInit(mctx, &pctx, md, NULL, sigkey);
		else
			r = EVP_DigestSignInit(mctx, &pctx, md, NULL, sigkey);
		if (!r) {
			BIO_printf(bio_err, "Error setting context\n");
			ERR_print_errors(bio_err);
			goto end;
		}
		if (sigopts) {
			char *sigopt;
			for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++) {
				sigopt = sk_OPENSSL_STRING_value(sigopts, i);
				if (pkey_ctrl_string(pctx, sigopt) <= 0) {
					BIO_printf(bio_err,
					    "parameter error \"%s\"\n",
					    sigopt);
					ERR_print_errors(bio_err);
					goto end;
				}
			}
		}
	}
	/* we use md as a filter, reading from 'in' */
	else {
		if (md == NULL)
			md = EVP_md5();
		if (!BIO_set_md(bmd, md)) {
			BIO_printf(bio_err, "Error setting digest %s\n", pname);
			ERR_print_errors(bio_err);
			goto end;
		}
	}

	if (sigfile && sigkey) {
		BIO *sigbio;
		sigbio = BIO_new_file(sigfile, "rb");
		siglen = EVP_PKEY_size(sigkey);
		sigbuf = malloc(siglen);
		if (!sigbio) {
			BIO_printf(bio_err, "Error opening signature file %s\n",
			    sigfile);
			ERR_print_errors(bio_err);
			goto end;
		}
		siglen = BIO_read(sigbio, sigbuf, siglen);
		BIO_free(sigbio);
		if (siglen <= 0) {
			BIO_printf(bio_err, "Error reading signature file %s\n",
			    sigfile);
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	inp = BIO_push(bmd, in);

	if (md == NULL) {
		EVP_MD_CTX *tctx;
		BIO_get_md_ctx(bmd, &tctx);
		md = EVP_MD_CTX_md(tctx);
	}
	if (argc == 0) {
		BIO_set_fp(in, stdin, BIO_NOCLOSE);
		err = do_fp(out, buf, inp, separator, out_bin, sigkey, sigbuf,
		    siglen, NULL, NULL, "stdin", bmd);
	} else {
		const char *md_name = NULL, *sig_name = NULL;
		if (!out_bin) {
			if (sigkey) {
				const EVP_PKEY_ASN1_METHOD *ameth;
				ameth = EVP_PKEY_get0_asn1(sigkey);
				if (ameth)
					EVP_PKEY_asn1_get0_info(NULL, NULL,
					    NULL, NULL, &sig_name, ameth);
			}
			md_name = EVP_MD_name(md);
		}
		err = 0;
		for (i = 0; i < argc; i++) {
			int r;
			if (BIO_read_filename(in, argv[i]) <= 0) {
				perror(argv[i]);
				err++;
				continue;
			} else {
				r = do_fp(out, buf, inp, separator, out_bin,
				    sigkey, sigbuf, siglen, sig_name, md_name,
				    argv[i], bmd);
			}
			if (r)
				err = r;
			(void) BIO_reset(bmd);
		}
	}

end:
	if (buf != NULL) {
		OPENSSL_cleanse(buf, BUFSIZE);
		free(buf);
	}
	if (in != NULL)
		BIO_free(in);
	free(passin);
	BIO_free_all(out);
	EVP_PKEY_free(sigkey);
	if (sigopts)
		sk_OPENSSL_STRING_free(sigopts);
	if (macopts)
		sk_OPENSSL_STRING_free(macopts);
	free(sigbuf);
	if (bmd != NULL)
		BIO_free(bmd);

	return (err);
}

int
do_fp(BIO * out, unsigned char *buf, BIO * bp, int sep, int binout,
    EVP_PKEY * key, unsigned char *sigin, int siglen,
    const char *sig_name, const char *md_name,
    const char *file, BIO * bmd)
{
	size_t len;
	int i;

	for (;;) {
		i = BIO_read(bp, (char *) buf, BUFSIZE);
		if (i < 0) {
			BIO_printf(bio_err, "Read Error in %s\n", file);
			ERR_print_errors(bio_err);
			return 1;
		}
		if (i == 0)
			break;
	}
	if (sigin) {
		EVP_MD_CTX *ctx;
		BIO_get_md_ctx(bp, &ctx);
		i = EVP_DigestVerifyFinal(ctx, sigin, (unsigned int) siglen);
		if (i > 0)
			BIO_printf(out, "Verified OK\n");
		else if (i == 0) {
			BIO_printf(out, "Verification Failure\n");
			return 1;
		} else {
			BIO_printf(bio_err, "Error Verifying Data\n");
			ERR_print_errors(bio_err);
			return 1;
		}
		return 0;
	}
	if (key) {
		EVP_MD_CTX *ctx;
		BIO_get_md_ctx(bp, &ctx);
		len = BUFSIZE;
		if (!EVP_DigestSignFinal(ctx, buf, &len)) {
			BIO_printf(bio_err, "Error Signing Data\n");
			ERR_print_errors(bio_err);
			return 1;
		}
	} else {
		len = BIO_gets(bp, (char *) buf, BUFSIZE);
		if ((int) len < 0) {
			ERR_print_errors(bio_err);
			return 1;
		}
	}

	if (binout)
		BIO_write(out, buf, len);
	else if (sep == 2) {
		for (i = 0; i < (int) len; i++)
			BIO_printf(out, "%02x", buf[i]);
		BIO_printf(out, " *%s\n", file);
	} else {
		if (sig_name)
			BIO_printf(out, "%s-%s(%s)= ", sig_name, md_name, file);
		else if (md_name)
			BIO_printf(out, "%s(%s)= ", md_name, file);
		else
			BIO_printf(out, "(%s)= ", file);
		for (i = 0; i < (int) len; i++) {
			if (sep && (i != 0))
				BIO_printf(out, ":");
			BIO_printf(out, "%02x", buf[i]);
		}
		BIO_printf(out, "\n");
	}
	return 0;
}
@


1.39
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: dgst.c,v 1.38 2014/07/12 17:54:31 jsing Exp $ */
@


1.38
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dgst.c,v 1.37 2014/06/12 15:49:27 deraadt Exp $ */
d470 1
a470 1
	
@


1.37
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a135 3

	if (!load_config(bio_err, NULL))
		goto end;
@


1.36
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* apps/dgst.c */
@


1.35
log
@Stop pretending that openssl(1) applications support the -rand option.
The underlying code has long been removed, making this a no-op.

If your random subsystem actually requires that you seed it from a file,
then you really should go and buy a new random subsystem that was built
after 1990.

Diff from Brent Cook.

ok deraadt@@
@
text
@d132 1
a132 1
	if ((buf = (unsigned char *) malloc(BUFSIZE)) == NULL) {
@


1.34
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@d119 1
a119 1
	const char *sigfile = NULL, *randfile = NULL;
d154 1
a154 5
		else if (strcmp(*argv, "-rand") == 0) {
			if (--argc < 1)
				break;
			randfile = *(++argv);
		} else if (strcmp(*argv, "-out") == 0) {
@


1.33
log
@More whack-a-mole^Wfips.

ok miod@@
@
text
@a131 2
	signal(SIGPIPE, SIG_IGN);

@


1.32
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a129 1
	int non_fips_allow = 0;
a205 4
		else if (!strcmp(*argv, "-fips-fingerprint"))
			hmac_key = "etaonrishdlcupfm";
		else if (strcmp(*argv, "-non-fips-allow") == 0)
			non_fips_allow = 1;
a350 5
	}
	if (non_fips_allow) {
		EVP_MD_CTX *md_ctx;
		BIO_get_md_ctx(bmd, &md_ctx);
		EVP_MD_CTX_set_flags(md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
@


1.31
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d479 1
a479 2
	if (passin)
		free(passin);
d486 1
a486 2
	if (sigbuf)
		free(sigbuf);
@


1.30
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d60 1
d62 1
a62 1
#include <stdlib.h>
d64 1
d68 1
d70 1
a71 2
#include <openssl/pem.h>
#include <openssl/hmac.h>
a73 1

@


1.29
log
@remove crazy #undefs; ok jsing
@
text
@a137 3
	if (bio_err == NULL)
		if ((bio_err = BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);
@


1.28
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a70 1
#undef BUFSIZE
@


1.27
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d133 1
a133 1
	apps_startup();
d494 1
a494 1
	apps_shutdown();
@


1.26
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@a294 2
	if (randfile)
		app_RAND_load_file(randfile, bio_err, 0);
@


1.25
log
@KaboomNF
@
text
@a73 2
#undef PROG
#define PROG	dgst_main
d101 1
a101 1
int MAIN(int, char **);
d104 1
a104 1
MAIN(int argc, char **argv)
@


1.24
log
@oops, exit vs return; spotted by matthew
@
text
@d78 2
a79 2
do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,
    EVP_PKEY *key, unsigned char *sigin, int siglen,
d81 1
a81 1
    const char *file, BIO *bmd);
d84 1
a84 1
list_md_fn(const EVP_MD *m, const char *from, const char *to, void *arg)
d133 1
a133 1
	STACK_OF(OPENSSL_STRING) *sigopts = NULL, *macopts = NULL;
d137 1
a137 1
	if ((buf = (unsigned char *)malloc(BUFSIZE)) == NULL) {
d143 1
a143 1
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE|BIO_FP_TEXT);
d165 1
a165 1
			randfile=*(++argv);
d169 1
a169 1
			outfile=*(++argv);
d173 1
a173 1
			keyfile=*(++argv);
d177 1
a177 1
			passargin=*++argv;
d181 1
a181 1
			keyfile=*(++argv);
d187 1
a187 1
			keyfile=*(++argv);
d192 1
a192 1
			sigfile=*(++argv);
d202 1
a202 1
			engine= *(++argv);
d219 1
a219 1
			hmac_key=*++argv;
d223 1
a223 1
			mac_name=*++argv;
d251 1
a251 3

	if ((argc > 0) && (argv[0][0] == '-')) /* bad option */
	{
a275 1

d281 1
a281 1
		BIO_set_callback_arg(in, (char *)bio_err);
a282 1

a286 1

a290 1

a296 1

a318 1

d327 4
a330 2
			/* load_[pub]key() has already printed an appropriate
			   message */
a333 1

a363 1

a368 1

d371 1
a371 1
		    (unsigned char *)hmac_key, -1);
a374 1

a444 1

d475 1
a475 1
			(void)BIO_reset(bmd);
d499 1
a499 1
	return(err);
d503 2
a504 2
do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,
    EVP_PKEY *key, unsigned char *sigin, int siglen,
d506 1
a506 1
    const char *file, BIO *bmd)
d512 1
a512 1
		i = BIO_read(bp, (char *)buf, BUFSIZE);
d524 1
a524 1
		i = EVP_DigestVerifyFinal(ctx, sigin, (unsigned int)siglen);
d547 2
a548 2
		len = BIO_gets(bp, (char *)buf, BUFSIZE);
		if ((int)len < 0) {
d557 1
a557 1
		for (i = 0; i < (int)len; i++)
d567 1
a567 1
		for (i = 0; i < (int)len; i++) {
@


1.23
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d510 1
a510 1
	exit(err);
@


1.22
log
@More KNF.
@
text
@d510 1
a510 1
	OPENSSL_EXIT(err);
@


1.21
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d77 2
a78 1
int do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,
d365 1
a365 1
		mac_end:
d479 1
a479 1
			} else
d483 1
d505 4
a508 3
	if (sigbuf) free(sigbuf);
		if (bmd != NULL)
			BIO_free(bmd);
d565 3
a567 2
	if (binout) BIO_write(out, buf, len);
		else if (sep == 2) {
@


1.20
log
@Initial KNF.
@
text
@d136 1
a136 1
	if ((buf = (unsigned char *)OPENSSL_malloc(BUFSIZE)) == NULL) {
d431 1
a431 1
		sigbuf = OPENSSL_malloc(siglen);
d491 1
a491 1
		OPENSSL_free(buf);
d496 1
a496 1
		OPENSSL_free(passin);
d503 1
a503 1
	if (sigbuf) OPENSSL_free(sigbuf);
@


1.19
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d78 7
a84 7
	  EVP_PKEY *key, unsigned char *sigin, int siglen,
	  const char *sig_name, const char *md_name,
	  const char *file,BIO *bmd);

static void list_md_fn(const EVP_MD *m,
			const char *from, const char *to, void *arg)
	{
d97 1
a97 1
		mname= EVP_MD_name(m);
d99 2
a100 2
			mname, mname);
	}
d104 3
a106 2
int MAIN(int argc, char **argv)
	{
d108 5
a112 5
	unsigned char *buf=NULL;
	int i,err=1;
	const EVP_MD *md=NULL,*m;
	BIO *in=NULL,*inp;
	BIO *bmd=NULL;
d115 4
a118 4
	char pname[PROG_NAME_SIZE+1];
	int separator=0;
	int debug=0;
	int keyform=FORMAT_PEM;
d127 1
a127 1
	char *engine=NULL;
d129 2
a130 2
	char *hmac_key=NULL;
	char *mac_name=NULL;
d136 2
a137 3
	if ((buf=(unsigned char *)OPENSSL_malloc(BUFSIZE)) == NULL)
		{
		BIO_printf(bio_err,"out of memory\n");
d139 1
a139 1
		}
d141 2
a142 2
		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);
d148 1
a148 1
	program_name(argv[0],pname,sizeof pname);
d150 1
a150 1
	md=EVP_get_digestbyname(pname);
d154 10
a163 10
	while (argc > 0)
		{
		if ((*argv)[0] != '-') break;
		if (strcmp(*argv,"-c") == 0)
			separator=1;
		else if (strcmp(*argv,"-r") == 0)
			separator=2;
		else if (strcmp(*argv,"-rand") == 0)
			{
			if (--argc < 1) break;
d165 3
a167 4
			}
		else if (strcmp(*argv,"-out") == 0)
			{
			if (--argc < 1) break;
d169 3
a171 4
			}
		else if (strcmp(*argv,"-sign") == 0)
			{
			if (--argc < 1) break;
d173 1
a173 3
			}
		else if (!strcmp(*argv,"-passin"))
			{
d177 3
a179 4
			}
		else if (strcmp(*argv,"-verify") == 0)
			{
			if (--argc < 1) break;
d183 3
a185 4
			}
		else if (strcmp(*argv,"-prverify") == 0)
			{
			if (--argc < 1) break;
d188 3
a190 4
			}
		else if (strcmp(*argv,"-signature") == 0)
			{
			if (--argc < 1) break;
d192 5
a196 6
			}
		else if (strcmp(*argv,"-keyform") == 0)
			{
			if (--argc < 1) break;
			keyform=str2fmt(*(++argv));
			}
d198 3
a200 3
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) break;
d202 2
a203 2
        		e = setup_engine(bio_err, engine, 0);
			}
d205 1
a205 1
		else if (strcmp(*argv,"-hex") == 0)
d207 1
a207 1
		else if (strcmp(*argv,"-binary") == 0)
d209 3
a211 3
		else if (strcmp(*argv,"-d") == 0)
			debug=1;
		else if (!strcmp(*argv,"-fips-fingerprint"))
d213 3
a215 4
		else if (strcmp(*argv,"-non-fips-allow") == 0)
			non_fips_allow=1;
		else if (!strcmp(*argv,"-hmac"))
			{
d219 1
a219 3
			}
		else if (!strcmp(*argv,"-mac"))
			{
d223 1
a223 3
			}
		else if (strcmp(*argv,"-sigopt") == 0)
			{
d230 1
a230 3
			}
		else if (strcmp(*argv,"-macopt") == 0)
			{
d237 2
a238 3
			}
		else if ((m=EVP_get_digestbyname(&((*argv)[1]))) != NULL)
			md=m;
d243 1
a243 1
		}
d246 1
a246 1
	if(do_verify && !sigfile) {
d252 18
a269 18
		{
		BIO_printf(bio_err,"unknown option '%s'\n",*argv);
		BIO_printf(bio_err,"options are\n");
		BIO_printf(bio_err,"-c              to output the digest with separating colons\n");
		BIO_printf(bio_err,"-r              to output the digest in coreutils format\n");
		BIO_printf(bio_err,"-d              to output debug info\n");
		BIO_printf(bio_err,"-hex            output as hex dump\n");
		BIO_printf(bio_err,"-binary         output in binary form\n");
		BIO_printf(bio_err,"-sign   file    sign digest using private key in file\n");
		BIO_printf(bio_err,"-verify file    verify a signature using public key in file\n");
		BIO_printf(bio_err,"-prverify file  verify a signature using private key in file\n");
		BIO_printf(bio_err,"-keyform arg    key file format (PEM or ENGINE)\n");
		BIO_printf(bio_err,"-out filename   output to filename rather than stdout\n");
		BIO_printf(bio_err,"-signature file signature to verify\n");
		BIO_printf(bio_err,"-sigopt nm:v    signature parameter\n");
		BIO_printf(bio_err,"-hmac key       create hashed MAC with key\n");
		BIO_printf(bio_err,"-mac algorithm  create MAC (not neccessarily HMAC)\n"); 
		BIO_printf(bio_err,"-macopt nm:v    MAC algorithm parameters or key\n");
d271 1
a271 1
		BIO_printf(bio_err,"-engine e       use engine e, possibly a hardware device.\n");
d276 1
a276 1
		}
d278 4
a281 5
	in=BIO_new(BIO_s_file());
	bmd=BIO_new(BIO_f_md());
	if (debug)
		{
		BIO_set_callback(in,BIO_debug_callback);
d283 2
a284 2
		BIO_set_callback_arg(in,(char *)bio_err);
		}
d286 1
a286 2
	if(!app_passwd(bio_err, passargin, NULL, &passin, NULL))
		{
d289 1
a289 1
		}
d291 1
a291 2
	if ((in == NULL) || (bmd == NULL))
		{
d294 1
a294 1
		}
d296 2
a297 2
	if(out_bin == -1) {
		if(keyfile)
d303 1
a303 1
	if(randfile)
d306 2
a307 2
	if(outfile) {
		if(out_bin)
d309 2
a310 1
		else    out = BIO_new_file(outfile, "w");
d315 3
a317 3
	if(!out) {
		BIO_printf(bio_err, "Error opening output file %s\n", 
					outfile ? outfile : "(stdout)");
d321 1
a321 2
	if ((!!mac_name + !!keyfile + !!hmac_key) > 1)
		{
d324 1
a324 1
		}
d326 1
a326 2
	if(keyfile)
		{
d329 1
a329 1
				e, "key file");
d332 2
a333 3
				e, "key file");
		if (!sigkey)
			{
a336 1
			}
d338 1
d340 1
a340 2
	if (mac_name)
		{
d343 1
a343 1
		if (!init_gen_str(bio_err, &mac_ctx, mac_name,e, 0))
d345 1
a345 2
		if (macopts)
			{
d347 1
a347 2
			for (i = 0; i < sk_OPENSSL_STRING_num(macopts); i++)
				{
d349 1
a349 2
				if (pkey_ctrl_string(mac_ctx, macopt) <= 0)
					{
d351 2
a352 2
						"MAC parameter error \"%s\"\n",
						macopt);
a354 1
					}
d357 2
a358 2
		if (EVP_PKEY_keygen(mac_ctx, &sigkey) <= 0)
			{
d362 1
a362 1
			}
d369 1
a369 1
		}
d371 1
a371 2
	if (non_fips_allow)
		{
d373 1
a373 1
		BIO_get_md_ctx(bmd,&md_ctx);
d375 1
a375 1
		}
d377 1
a377 2
	if (hmac_key)
		{
d379 1
a379 1
					(unsigned char *)hmac_key, -1);
d382 1
a382 1
		}
d384 1
a384 2
	if (sigkey)
		{
d388 1
a388 2
		if (!BIO_get_md_ctx(bmd, &mctx))
			{
d392 1
a392 1
			}
d397 1
a397 2
		if (!r)
			{
d401 2
a402 3
			}
		if (sigopts)
			{
d404 1
a404 2
			for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++)
				{
d406 1
a406 2
				if (pkey_ctrl_string(pctx, sigopt) <= 0)
					{
d408 2
a409 2
						"parameter error \"%s\"\n",
						sigopt);
a411 1
					}
d415 1
d417 1
a417 2
	else
		{
d419 2
a420 3
			md = EVP_md5(); 
		if (!BIO_set_md(bmd,md))
			{
a423 1
			}
d425 1
d427 1
a427 1
	if(sigfile && sigkey) {
d432 1
a432 1
		if(!sigbio) {
d434 1
a434 1
								sigfile);
d440 1
a440 1
		if(siglen <= 0) {
d442 1
a442 1
								sigfile);
d447 1
a447 1
	inp=BIO_push(bmd,in);
d449 1
a449 2
	if (md == NULL)
		{
d453 1
a453 1
		}
d455 5
a459 8
	if (argc == 0)
		{
		BIO_set_fp(in,stdin,BIO_NOCLOSE);
		err=do_fp(out, buf,inp,separator, out_bin, sigkey, sigbuf,
			  siglen,NULL,NULL,"stdin",bmd);
		}
	else
		{
d461 2
a462 4
		if(!out_bin)
			{
			if (sigkey)
				{
d467 2
a468 2
						NULL, NULL, &sig_name, ameth);
				}
d470 1
a470 1
			}
d472 1
a472 2
		for (i=0; i<argc; i++)
			{
d474 1
a474 2
			if (BIO_read_filename(in,argv[i]) <= 0)
				{
d478 6
a483 6
				}
			else
			r=do_fp(out,buf,inp,separator,out_bin,sigkey,sigbuf,
				siglen,sig_name,md_name, argv[i],bmd);
			if(r)
			    err=r;
a484 1
			}
d486 2
d489 2
a490 3
	if (buf != NULL)
		{
		OPENSSL_cleanse(buf,BUFSIZE);
d492 3
a494 2
		}
	if (in != NULL) BIO_free(in);
d503 3
a505 2
	if(sigbuf) OPENSSL_free(sigbuf);
	if (bmd != NULL) BIO_free(bmd);
d508 1
a508 1
	}
d510 6
a515 5
int do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,
	  EVP_PKEY *key, unsigned char *sigin, int siglen,
	  const char *sig_name, const char *md_name,
	  const char *file,BIO *bmd)
	{
d519 4
a522 6
	for (;;)
		{
		i=BIO_read(bp,(char *)buf,BUFSIZE);
		if(i < 0)
			{
			BIO_printf(bio_err, "Read Error in %s\n",file);
a524 2
			}
		if (i == 0) break;
d526 4
a529 2
	if(sigin)
		{
d532 2
a533 2
		i = EVP_DigestVerifyFinal(ctx, sigin, (unsigned int)siglen); 
		if(i > 0)
d535 1
a535 2
		else if(i == 0)
			{
d538 1
a538 3
			}
		else
			{
d542 1
a542 1
			}
d544 2
a545 3
		}
	if(key)
		{
d549 1
a549 2
		if(!EVP_DigestSignFinal(ctx, buf, &len)) 
			{
a552 1
			}
d554 3
a556 5
	else
		{
		len=BIO_gets(bp,(char *)buf,BUFSIZE);
		if ((int)len <0)
			{
a558 1
			}
d560 1
d562 4
a565 5
	if(binout) BIO_write(out, buf, len);
	else if (sep == 2)
		{
		for (i=0; i<(int)len; i++)
			BIO_printf(out, "%02x",buf[i]);
d567 1
a567 3
		}
	else 
		{
d574 1
a574 2
		for (i=0; i<(int)len; i++)
			{
d577 2
a578 2
			BIO_printf(out, "%02x",buf[i]);
			}
d580 1
a580 1
		}
d582 1
a582 2
	}

@


1.18
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a330 6
#ifdef OPENSSL_SYS_VMS
		{
		BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		out = BIO_push(tmpbio, out);
		}
#endif
@


1.17
log
@resolve conflicts
@
text
@d219 2
a222 2
		else if (!strcmp(*argv,"-fips-fingerprint"))
			hmac_key = "etaonrishdlcupfm";
d430 1
a430 1
			r = EVP_DigestVerifyInit(mctx, &pctx, md, e, sigkey);
d432 1
a432 1
			r = EVP_DigestSignInit(mctx, &pctx, md, e, sigkey);
@


1.16
log
@resolve conflicts, fix local changes
@
text
@d130 1
d219 4
d401 7
@


1.15
log
@resolve conflicts
@
text
@d78 23
a100 2
	  EVP_PKEY *key, unsigned char *sigin, int siglen, const char *title,
	  const char *file,BIO *bmd,const char *hmac_key, int non_fips_allow);
a112 1
	const char *name;
a123 1
	unsigned int sig_flags = 0;
d129 2
a130 1
	int non_fips_allow = 0;
d133 1
a133 1
ERR_load_crypto_strings();
d158 2
a193 21
		else if (strcmp(*argv,"-x931") == 0)
			sig_flags = EVP_MD_CTX_FLAG_PAD_X931;
		else if (strcmp(*argv,"-pss_saltlen") == 0)
			{
			int saltlen;
			if (--argc < 1) break;
			saltlen=atoi(*(++argv));
			if (saltlen == -1)
				sig_flags = EVP_MD_CTX_FLAG_PSS_MREC;
			else if (saltlen == -2)
				sig_flags = EVP_MD_CTX_FLAG_PSS_MDLEN;
			else if (saltlen < -2 || saltlen >= 0xFFFE)
				{
				BIO_printf(bio_err, "Invalid PSS salt length %d\n", saltlen);
				goto end;
				}
			else
				sig_flags = saltlen;
			sig_flags <<= 16;
			sig_flags |= EVP_MD_CTX_FLAG_PAD_PSS;
			}
d209 1
a217 4
		else if (strcmp(*argv,"-non-fips-allow") == 0)
			non_fips_allow=1;
		else if (!strcmp(*argv,"-fips-fingerprint"))
			hmac_key = "etaonrishdlcupfm";
d224 24
a255 2
	if (md == NULL)
		md=EVP_md5();
a258 1
		err = 1; 
d267 1
d275 1
d277 1
a277 1
		BIO_printf(bio_err,"-binary         output in binary form\n");
d279 2
d285 1
a285 29
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm (default)\n",
			LN_md5,LN_md5);
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_md4,LN_md4);
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_md2,LN_md2);
#ifndef OPENSSL_NO_SHA
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_sha1,LN_sha1);
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_sha,LN_sha);
#ifndef OPENSSL_NO_SHA256
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_sha224,LN_sha224);
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_sha256,LN_sha256);
#endif
#ifndef OPENSSL_NO_SHA512
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_sha384,LN_sha384);
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_sha512,LN_sha512);
#endif
#endif
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_mdc2,LN_mdc2);
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_ripemd160,LN_ripemd160);
		err=1;
a288 4
#ifndef OPENSSL_NO_ENGINE
        e = setup_engine(bio_err, engine, 0);
#endif

d311 4
a314 2
		if(keyfile) out_bin = 1;
		else out_bin = 0;
d340 5
d362 95
d477 1
d479 1
a479 1
	if (non_fips_allow)
d481 3
a483 3
		EVP_MD_CTX *md_ctx;
		BIO_get_md_ctx(bmd,&md_ctx);
		EVP_MD_CTX_set_flags(md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
a485 17
	if (sig_flags)
		{
		EVP_MD_CTX *md_ctx;
		BIO_get_md_ctx(bmd,&md_ctx);
		EVP_MD_CTX_set_flags(md_ctx, sig_flags);
		}

	/* we use md as a filter, reading from 'in' */
	if (!BIO_set_md(bmd,md))
		{
		BIO_printf(bio_err, "Error setting digest %s\n", pname);
		ERR_print_errors(bio_err);
		goto end;
		}
		
	inp=BIO_push(bmd,in);

d490 1
a490 1
			  siglen,"","(stdin)",bmd,hmac_key,non_fips_allow);
d494 13
a506 1
		name=OBJ_nid2sn(md->type);
a509 1
			char *tmp,*tofree=NULL;
a510 1

a516 7
			if(!out_bin)
				{
				size_t len = strlen(name)+strlen(argv[i])+(hmac_key ? 5 : 0)+5;
				tmp=tofree=OPENSSL_malloc(len);
				BIO_snprintf(tmp,len,"%s%s(%s)= ",
							 hmac_key ? "HMAC-" : "",name,argv[i]);
				}
a517 1
				tmp="";
d519 1
a519 1
				siglen,tmp,argv[i],bmd,hmac_key,non_fips_allow);
a521 2
			if(tofree)
				OPENSSL_free(tofree);
d536 4
d547 3
a549 2
	  EVP_PKEY *key, unsigned char *sigin, int siglen, const char *title,
	  const char *file,BIO *bmd,const char *hmac_key,int non_fips_allow)
d551 1
a551 1
	unsigned int len;
a552 6
	EVP_MD_CTX *md_ctx;
	HMAC_CTX hmac_ctx;

	if (hmac_key)
		{
		EVP_MD *md;
a553 6
		BIO_get_md(bmd,&md);
		HMAC_CTX_init(&hmac_ctx);
		HMAC_Init_ex(&hmac_ctx,hmac_key,strlen(hmac_key),md, NULL);
		BIO_get_md_ctx(bmd,&md_ctx);
		BIO_set_md_ctx(bmd,&hmac_ctx.md_ctx);
		}
d569 1
a569 1
		i = EVP_VerifyFinal(ctx, sigin, (unsigned int)siglen, key); 
d589 2
a590 1
		if(!EVP_SignFinal(ctx, buf, (unsigned int *)&len, key)) 
d597 1
a597 1
	else if(hmac_key)
d599 6
a604 2
		HMAC_Final(&hmac_ctx,buf,&len);
		HMAC_CTX_cleanup(&hmac_ctx);
a605 2
	else
		len=BIO_gets(bp,(char *)buf,BUFSIZE);
d608 6
d616 6
a621 1
		BIO_write(out,title,strlen(title));
a628 4
		}
	if (hmac_key)
		{
		BIO_set_md_ctx(bmd,md_ctx);
@


1.14
log
@resolve conflicts
@
text
@d79 1
a79 1
	  const char *file,BIO *bmd,const char *hmac_key);
d87 1
a87 1
	int i,err=0;
d104 1
d110 1
d113 1
a113 1

d172 21
d216 2
a383 1
		
d385 13
d413 1
a413 1
			  siglen,"","(stdin)",bmd,hmac_key);
d418 1
d440 1
a440 1
				siglen,tmp,argv[i],bmd,hmac_key);
d467 1
a467 1
	  const char *file,BIO *bmd,const char *hmac_key)
@


1.13
log
@resolve conflicts
@
text
@a76 2
static HMAC_CTX hmac_ctx;

d79 1
a79 1
	  const char *file,BIO *bmd,const char *hmac_key, int non_fips_allow);
a108 1
	int non_fips_allow = 0;
d193 2
a194 2
		else if (strcmp(*argv,"-non-fips-allow") == 0)
			non_fips_allow=1;
d232 1
d237 1
a237 1
		BIO_printf(bio_err,"-%3s to use the %s message digest algorithm (default)\n",
d239 1
a239 1
		BIO_printf(bio_err,"-%3s to use the %s message digest algorithm\n",
d241 1
a241 1
		BIO_printf(bio_err,"-%3s to use the %s message digest algorithm\n",
d243 2
a244 1
		BIO_printf(bio_err,"-%3s to use the %s message digest algorithm\n",
d246 1
a246 1
		BIO_printf(bio_err,"-%3s to use the %s message digest algorithm\n",
d248 14
a261 1
		BIO_printf(bio_err,"-%3s to use the %s message digest algorithm\n",
d263 1
a263 1
		BIO_printf(bio_err,"-%3s to use the %s message digest algorithm\n",
d270 1
a270 1
	e = setup_engine(bio_err, engine, 0);
d279 1
a279 1
		BIO_set_callback_arg(in,bio_err);
d359 1
a360 6
	if (non_fips_allow)
		{
		EVP_MD_CTX *md_ctx;
		BIO_get_md_ctx(bmd,&md_ctx);
		EVP_MD_CTX_set_flags(md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
		}
d365 1
a365 2
		BIO_printf(bio_err, "Error setting digest %s\n",
							EVP_MD_name(md));
d376 1
a376 1
			  siglen,"","(stdin)",bmd,hmac_key, non_fips_allow);
d402 1
a402 1
				siglen,tmp,argv[i],bmd,hmac_key,non_fips_allow);
d429 1
a429 1
	  const char *file,BIO *bmd,const char *hmac_key, int non_fips_allow)
d434 1
a441 3
		if (non_fips_allow)
			HMAC_CTX_set_flags(&hmac_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
d500 1
a500 1
		for (i=0; (unsigned int)i<len; i++)
@


1.12
log
@merge 0.9.7d
@
text
@d69 1
d77 2
d81 1
a81 1
	  const char *file);
d106 1
d110 2
d154 6
d196 8
d258 1
a258 1
        e = setup_engine(bio_err, engine, 0);
d270 6
d317 1
a317 1
			sigkey = load_key(bio_err, keyfile, keyform, 0, NULL,
a346 1
		
d348 6
d356 8
a363 1
	BIO_set_md(bmd,md);
d370 1
a370 1
			  siglen,"","(stdin)");
d388 1
a388 1
				size_t len = strlen(name)+strlen(argv[i])+5;
d390 2
a391 1
				BIO_snprintf(tmp,len,"%s(%s)= ",name,argv[i]);
d396 1
a396 1
				siglen,tmp,argv[i]);
d411 2
d423 1
a423 1
	  const char *file)
d425 1
a425 1
	int len;
d427 5
d433 9
d484 5
d496 1
a496 1
		for (i=0; i<len; i++)
d503 4
@


1.11
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d352 1
a352 1
				snprintf(tmp,len,"%s(%s)= ",name,argv[i]);
@


1.10
log
@more strcpy & sprintf murder; ho ok
@
text
@d103 1
d105 1
d122 1
a122 1
	program_name(argv[0],pname,PROG_NAME_SIZE);
d171 1
d177 1
d214 2
d217 1
d237 1
d239 1
d368 1
a368 1
		memset(buf,0,BUFSIZE);
d377 1
a377 1
	EXIT(err);
@


1.9
log
@delete duplicate line; jason@@ackley.net, 3090
@
text
@d341 3
a343 2
				tmp=tofree=OPENSSL_malloc(strlen(name)+strlen(argv[i])+5);
				sprintf(tmp,"%s(%s)= ",name,argv[i]);
@


1.8
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@a209 1
		BIO_printf(bio_err,"-binary         output in binary form\n");
@


1.7
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d280 1
a280 1
			sigkey = load_pubkey(bio_err, keyfile, keyform, NULL,
d283 1
a283 1
			sigkey = load_key(bio_err, keyfile, keyform, NULL,
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d76 3
a78 2
void do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,
		EVP_PKEY *key, unsigned char *sigin, int siglen);
d323 2
a324 1
		do_fp(out, buf,inp,separator, out_bin, sigkey, sigbuf, siglen);
d331 3
d340 13
a352 3
			if(!out_bin) BIO_printf(out, "%s(%s)= ",name,argv[i]);
			do_fp(out, buf,inp,separator, out_bin, sigkey, 
								sigbuf, siglen);
d371 3
a373 2
void do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,
			EVP_PKEY *key, unsigned char *sigin, int siglen)
d381 7
a387 1
		if (i <= 0) break;
d394 7
a400 2
		if(i > 0) BIO_printf(out, "Verified OK\n");
		else if(i == 0) BIO_printf(out, "Verification Failure\n");
d405 1
d407 1
a407 1
		return;
d417 1
a417 1
			return;
d426 1
d435 1
@


1.5
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@a68 1
#include <openssl/engine.h>
d91 2
a92 2
#define PROG_NAME_SIZE  16
	char pname[PROG_NAME_SIZE];
d95 1
d115 3
d163 5
d207 1
d230 1
a230 17
	if (engine != NULL)
		{
		if((e = ENGINE_by_id(engine)) == NULL)
			{
			BIO_printf(bio_err,"invalid engine \"%s\"\n",
				engine);
			goto end;
			}
		if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
			{
			BIO_printf(bio_err,"can't use that engine\n");
			goto end;
			}
		BIO_printf(bio_err,"engine \"%s\" set.\n", engine);
		/* Free our "structural" reference. */
		ENGINE_free(e);
		}
d261 1
a261 1
#ifdef VMS
d276 12
a287 7
	if(keyfile) {
		BIO *keybio;
		keybio = BIO_new_file(keyfile, "r");
		if(!keybio) {
			BIO_printf(bio_err, "Error opening key file %s\n",
								keyfile);
			ERR_print_errors(bio_err);
d289 1
a290 12
		
		if(want_pub) 
			sigkey = PEM_read_bio_PUBKEY(keybio, NULL, NULL, NULL);
		else sigkey = PEM_read_bio_PrivateKey(keybio, NULL, NULL, NULL);
		BIO_free(keybio);
		if(!sigkey) {
			BIO_printf(bio_err, "Error reading key file %s\n",
								keyfile);
			ERR_print_errors(bio_err);
			goto end;
		}
	}
d352 1
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d77 1
a77 1
void do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, char binout,
d98 1
a98 1
	char out_bin = -1, want_pub = 0, do_verify = 0;
d368 1
a368 1
void do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, char binout,
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d69 1
d77 2
a78 1
void do_fp(unsigned char *buf,BIO *f,int sep);
d84 1
d90 1
d96 7
d106 1
a106 1
	if ((buf=(unsigned char *)Malloc(BUFSIZE)) == NULL)
d127 42
d182 6
d192 11
a202 2
		BIO_printf(bio_err,"-c   to output the digest with separating colons\n");
		BIO_printf(bio_err,"-d   to output debug info\n");
d206 2
d220 19
a238 1
	
d254 74
d335 1
a335 1
		do_fp(buf,inp,separator);
d348 3
a350 2
			printf("%s(%s)= ",name,argv[i]);
			do_fp(buf,inp,separator);
d358 1
a358 1
		Free(buf);
d361 3
d368 2
a369 1
void do_fp(unsigned char *buf, BIO *bp, int sep)
d379 27
a405 1
	len=BIO_gets(bp,(char *)buf,BUFSIZE);
d407 2
a408 1
	for (i=0; i<len; i++)
d410 7
a416 3
		if (sep && (i != 0))
			putc(':',stdout);
		printf("%02x",buf[i]);
a417 1
	printf("\n");
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d77 3
@


1.1
log
@Initial revision
@
text
@d63 6
a68 6
#include "bio.h"
#include "err.h"
#include "evp.h"
#include "objects.h"
#include "x509.h"
#include "pem.h"
a75 1
#ifndef NOPROTO
d77 1
a77 7
#else
void do_fp();
#endif

int MAIN(argc,argv)
int argc;
char **argv;
d81 1
a81 1
	EVP_MD *md=NULL,*m;
d84 1
a84 1
	char *name;
d86 1
a86 1
        char pname[PROG_NAME_SIZE];
d102 1
a102 1
        program_name(argv[0],pname,PROG_NAME_SIZE);
d108 1
a108 1
	for (i=0; i<argc; i++)
d142 2
d185 1
a185 1
			BIO_reset(bmd);
d199 1
a199 4
void do_fp(buf,bp,sep)
unsigned char *buf;
BIO *bp;
int sep;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d63 6
a68 6
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
d76 5
a80 4
void do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,
		EVP_PKEY *key, unsigned char *sigin, int siglen);

int MAIN(int, char **);
d82 3
a84 1
int MAIN(int argc, char **argv)
a85 1
	ENGINE *e = NULL;
d88 1
a88 1
	const EVP_MD *md=NULL,*m;
d91 3
a93 4
	BIO *out = NULL;
	const char *name;
#define PROG_NAME_SIZE  39
	char pname[PROG_NAME_SIZE+1];
a95 8
	int keyform=FORMAT_PEM;
	const char *outfile = NULL, *keyfile = NULL;
	const char *sigfile = NULL, *randfile = NULL;
	int out_bin = -1, want_pub = 0, do_verify = 0;
	EVP_PKEY *sigkey = NULL;
	unsigned char *sigbuf = NULL;
	int siglen = 0;
	char *engine=NULL;
d99 1
a99 1
	if ((buf=(unsigned char *)OPENSSL_malloc(BUFSIZE)) == NULL)
a107 3
	if (!load_config(bio_err, NULL))
		goto end;

d109 1
a109 1
	program_name(argv[0],pname,PROG_NAME_SIZE);
d115 1
a115 1
	while (argc > 0)
a119 47
		else if (strcmp(*argv,"-rand") == 0)
			{
			if (--argc < 1) break;
			randfile=*(++argv);
			}
		else if (strcmp(*argv,"-out") == 0)
			{
			if (--argc < 1) break;
			outfile=*(++argv);
			}
		else if (strcmp(*argv,"-sign") == 0)
			{
			if (--argc < 1) break;
			keyfile=*(++argv);
			}
		else if (strcmp(*argv,"-verify") == 0)
			{
			if (--argc < 1) break;
			keyfile=*(++argv);
			want_pub = 1;
			do_verify = 1;
			}
		else if (strcmp(*argv,"-prverify") == 0)
			{
			if (--argc < 1) break;
			keyfile=*(++argv);
			do_verify = 1;
			}
		else if (strcmp(*argv,"-signature") == 0)
			{
			if (--argc < 1) break;
			sigfile=*(++argv);
			}
		else if (strcmp(*argv,"-keyform") == 0)
			{
			if (--argc < 1) break;
			keyform=str2fmt(*(++argv));
			}
		else if (strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) break;
			engine= *(++argv);
			}
		else if (strcmp(*argv,"-hex") == 0)
			out_bin = 0;
		else if (strcmp(*argv,"-binary") == 0)
			out_bin = 1;
a132 6
	if(do_verify && !sigfile) {
		BIO_printf(bio_err, "No signature to verify: use the -signature option\n");
		err = 1; 
		goto end;
	}

d137 2
a138 12
		BIO_printf(bio_err,"-c              to output the digest with separating colons\n");
		BIO_printf(bio_err,"-d              to output debug info\n");
		BIO_printf(bio_err,"-hex            output as hex dump\n");
		BIO_printf(bio_err,"-binary         output in binary form\n");
		BIO_printf(bio_err,"-sign   file    sign digest using private key in file\n");
		BIO_printf(bio_err,"-verify file    verify a signature using public key in file\n");
		BIO_printf(bio_err,"-prverify file  verify a signature using private key in file\n");
		BIO_printf(bio_err,"-keyform arg    key file format (PEM or ENGINE)\n");
		BIO_printf(bio_err,"-signature file signature to verify\n");
		BIO_printf(bio_err,"-binary         output in binary form\n");
		BIO_printf(bio_err,"-engine e       use engine e, possibly a hardware device.\n");

a141 2
			LN_md4,LN_md4);
		BIO_printf(bio_err,"-%3s to use the %s message digest algorithm\n",
a148 2
		BIO_printf(bio_err,"-%3s to use the %s message digest algorithm\n",
			LN_ripemd160,LN_ripemd160);
d152 1
a152 3

        e = setup_engine(bio_err, engine, 0);

a167 68
	if(out_bin == -1) {
		if(keyfile) out_bin = 1;
		else out_bin = 0;
	}

	if(randfile)
		app_RAND_load_file(randfile, bio_err, 0);

	if(outfile) {
		if(out_bin)
			out = BIO_new_file(outfile, "wb");
		else    out = BIO_new_file(outfile, "w");
	} else {
		out = BIO_new_fp(stdout, BIO_NOCLOSE);
#ifdef OPENSSL_SYS_VMS
		{
		BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		out = BIO_push(tmpbio, out);
		}
#endif
	}

	if(!out) {
		BIO_printf(bio_err, "Error opening output file %s\n", 
					outfile ? outfile : "(stdout)");
		ERR_print_errors(bio_err);
		goto end;
	}

	if(keyfile)
		{
		if (want_pub)
			sigkey = load_pubkey(bio_err, keyfile, keyform, NULL,
				e, "key file");
		else
			sigkey = load_key(bio_err, keyfile, keyform, NULL,
				e, "key file");
		if (!sigkey)
			{
			/* load_[pub]key() has already printed an appropriate
			   message */
			goto end;
			}
		}

	if(sigfile && sigkey) {
		BIO *sigbio;
		sigbio = BIO_new_file(sigfile, "rb");
		siglen = EVP_PKEY_size(sigkey);
		sigbuf = OPENSSL_malloc(siglen);
		if(!sigbio) {
			BIO_printf(bio_err, "Error opening signature file %s\n",
								sigfile);
			ERR_print_errors(bio_err);
			goto end;
		}
		siglen = BIO_read(sigbio, sigbuf, siglen);
		BIO_free(sigbio);
		if(siglen <= 0) {
			BIO_printf(bio_err, "Error reading signature file %s\n",
								sigfile);
			ERR_print_errors(bio_err);
			goto end;
		}
	}
		


d175 1
a175 1
		do_fp(out, buf,inp,separator, out_bin, sigkey, sigbuf, siglen);
d188 3
a190 4
			if(!out_bin) BIO_printf(out, "%s(%s)= ",name,argv[i]);
			do_fp(out, buf,inp,separator, out_bin, sigkey, 
								sigbuf, siglen);
			(void)BIO_reset(bmd);
d197 1
a197 1
		OPENSSL_free(buf);
a199 3
	BIO_free_all(out);
	EVP_PKEY_free(sigkey);
	if(sigbuf) OPENSSL_free(sigbuf);
a200 1
	apps_shutdown();
d204 4
a207 2
void do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,
			EVP_PKEY *key, unsigned char *sigin, int siglen)
d217 1
a217 27
	if(sigin)
		{
		EVP_MD_CTX *ctx;
		BIO_get_md_ctx(bp, &ctx);
		i = EVP_VerifyFinal(ctx, sigin, (unsigned int)siglen, key); 
		if(i > 0) BIO_printf(out, "Verified OK\n");
		else if(i == 0) BIO_printf(out, "Verification Failure\n");
		else
			{
			BIO_printf(bio_err, "Error Verifying Data\n");
			ERR_print_errors(bio_err);
			}
		return;
		}
	if(key)
		{
		EVP_MD_CTX *ctx;
		BIO_get_md_ctx(bp, &ctx);
		if(!EVP_SignFinal(ctx, buf, (unsigned int *)&len, key)) 
			{
			BIO_printf(bio_err, "Error Signing Data\n");
			ERR_print_errors(bio_err);
			return;
			}
		}
	else
		len=BIO_gets(bp,(char *)buf,BUFSIZE);
d219 1
a219 2
	if(binout) BIO_write(out, buf, len);
	else 
d221 3
a223 7
		for (i=0; i<len; i++)
			{
			if (sep && (i != 0))
				BIO_printf(out, ":");
			BIO_printf(out, "%02x",buf[i]);
			}
		BIO_printf(out, "\n");
d225 1
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d76 2
a77 3
int do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,
	  EVP_PKEY *key, unsigned char *sigin, int siglen, const char *title,
	  const char *file);
d322 1
a322 2
		err=do_fp(out, buf,inp,separator, out_bin, sigkey, sigbuf,
			  siglen,"","(stdin)");
a328 3
			char *tmp,*tofree=NULL;
			int r;

d335 3
a337 13
			if(!out_bin)
				{
				tmp=tofree=OPENSSL_malloc(strlen(name)+strlen(argv[i])+5);
				sprintf(tmp,"%s(%s)= ",name,argv[i]);
				}
			else
				tmp="";
			r=do_fp(out,buf,inp,separator,out_bin,sigkey,sigbuf,
				siglen,tmp,argv[i]);
			if(r)
			    err=r;
			if(tofree)
				OPENSSL_free(tofree);
d356 2
a357 3
int do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,
	  EVP_PKEY *key, unsigned char *sigin, int siglen, const char *title,
	  const char *file)
d365 1
a365 7
		if(i < 0)
			{
			BIO_printf(bio_err, "Read Error in %s\n",file);
			ERR_print_errors(bio_err);
			return 1;
			}
		if (i == 0) break;
d372 2
a373 7
		if(i > 0)
			BIO_printf(out, "Verified OK\n");
		else if(i == 0)
			{
			BIO_printf(out, "Verification Failure\n");
			return 1;
			}
a377 1
			return 1;
d379 1
a379 1
		return 0;
d389 1
a389 1
			return 1;
a397 1
		BIO_write(out,title,strlen(title));
a405 1
	return 0;
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d280 1
a280 1
			sigkey = load_pubkey(bio_err, keyfile, keyform, 0, NULL,
d283 1
a283 1
			sigkey = load_key(bio_err, keyfile, keyform, 0, NULL,
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@a102 1
#ifndef OPENSSL_NO_ENGINE
a103 1
#endif
d120 1
a120 1
	program_name(argv[0],pname,sizeof pname);
a168 1
#ifndef OPENSSL_NO_ENGINE
a173 1
#endif
a210 1
#ifndef OPENSSL_NO_ENGINE
a211 1
#endif
a230 1
#ifndef OPENSSL_NO_ENGINE
a231 1
#endif
d359 1
a359 1
		OPENSSL_cleanse(buf,BUFSIZE);
d368 1
a368 1
	OPENSSL_EXIT(err);
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d350 2
a351 3
				size_t len = strlen(name)+strlen(argv[i])+5;
				tmp=tofree=OPENSSL_malloc(len);
				BIO_snprintf(tmp,len,"%s(%s)= ",name,argv[i]);
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a68 1
#include <openssl/hmac.h>
a75 2
static HMAC_CTX hmac_ctx;

d78 1
a78 1
	  const char *file,BIO *bmd,const char *hmac_key, int non_fips_allow);
a102 1
	char *passargin = NULL, *passin = NULL;
a105 2
	char *hmac_key=NULL;
	int non_fips_allow = 0;
a147 6
		else if (!strcmp(*argv,"-passin"))
			{
			if (--argc < 1)
				break;
			passargin=*++argv;
			}
a183 8
		else if (strcmp(*argv,"-non-fips-allow") == 0)
			non_fips_allow=1;
		else if (!strcmp(*argv,"-hmac"))
			{
			if (--argc < 1)
				break;
			hmac_key=*++argv;
			}
d238 1
a238 1
	e = setup_engine(bio_err, engine, 0);
a249 6
	if(!app_passwd(bio_err, passargin, NULL, &passin, NULL))
		{
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
		}

d291 1
a291 1
			sigkey = load_key(bio_err, keyfile, keyform, 0, passin,
d321 1
a322 6
	if (non_fips_allow)
		{
		EVP_MD_CTX *md_ctx;
		BIO_get_md_ctx(bmd,&md_ctx);
		EVP_MD_CTX_set_flags(md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
		}
d325 1
a325 8
	if (!BIO_set_md(bmd,md))
		{
		BIO_printf(bio_err, "Error setting digest %s\n",
							EVP_MD_name(md));
		ERR_print_errors(bio_err);
		goto end;
		}
		
d332 1
a332 1
			  siglen,"","(stdin)",bmd,hmac_key, non_fips_allow);
d350 1
a350 1
				size_t len = strlen(name)+strlen(argv[i])+(hmac_key ? 5 : 0)+5;
d352 1
a352 2
				BIO_snprintf(tmp,len,"%s%s(%s)= ",
							 hmac_key ? "HMAC-" : "",name,argv[i]);
d357 1
a357 1
				siglen,tmp,argv[i],bmd,hmac_key,non_fips_allow);
a371 2
	if (passin)
		OPENSSL_free(passin);
d382 1
a382 1
	  const char *file,BIO *bmd,const char *hmac_key, int non_fips_allow)
d384 1
a384 1
	unsigned int len;
a385 5
	EVP_MD_CTX *md_ctx;

	if (hmac_key)
		{
		EVP_MD *md;
a386 9
		BIO_get_md(bmd,&md);
		HMAC_CTX_init(&hmac_ctx);
		if (non_fips_allow)
			HMAC_CTX_set_flags(&hmac_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
		HMAC_Init_ex(&hmac_ctx,hmac_key,strlen(hmac_key),md, NULL);
		BIO_get_md_ctx(bmd,&md_ctx);
		BIO_set_md_ctx(bmd,&hmac_ctx.md_ctx);
		}
a428 5
	else if(hmac_key)
		{
		HMAC_Final(&hmac_ctx,buf,&len);
		HMAC_CTX_cleanup(&hmac_ctx);
		}
d436 1
a436 1
		for (i=0; (unsigned int)i<len; i++)
a442 4
		}
	if (hmac_key)
		{
		BIO_set_md_ctx(bmd,md_ctx);
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@d77 2
d81 1
a81 1
	  const char *file,BIO *bmd,const char *hmac_key);
d111 1
d196 2
a197 2
		else if (!strcmp(*argv,"-fips-fingerprint"))
			hmac_key = "etaonrishdlcupfm";
a234 1
		BIO_printf(bio_err,"-hmac key       create hashed MAC with key\n");
d239 1
a239 1
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm (default)\n",
d241 1
a241 1
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
d243 1
a243 1
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
d245 1
a245 2
#ifndef OPENSSL_NO_SHA
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
d247 1
a247 1
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
d249 1
a249 14
#ifndef OPENSSL_NO_SHA256
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_sha224,LN_sha224);
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_sha256,LN_sha256);
#endif
#ifndef OPENSSL_NO_SHA512
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_sha384,LN_sha384);
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
			LN_sha512,LN_sha512);
#endif
#endif
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
d251 1
a251 1
		BIO_printf(bio_err,"-%-14s to use the %s message digest algorithm\n",
d258 1
a258 1
        e = setup_engine(bio_err, engine, 0);
d267 1
a267 1
		BIO_set_callback_arg(in,(char *)bio_err);
a346 1
		
d348 6
d358 2
a359 1
		BIO_printf(bio_err, "Error setting digest %s\n", pname);
d370 1
a370 1
			  siglen,"","(stdin)",bmd,hmac_key);
d396 1
a396 1
				siglen,tmp,argv[i],bmd,hmac_key);
d423 1
a423 1
	  const char *file,BIO *bmd,const char *hmac_key)
a427 1
	HMAC_CTX hmac_ctx;
d435 3
d496 1
a496 1
		for (i=0; i<(int)len; i++)
@


1.1.1.9
log
@import openssl-0.9.8j
@
text
@d79 1
a79 1
	  const char *file,BIO *bmd,const char *hmac_key, int non_fips_allow);
d87 1
a87 1
	int i,err=1;
a103 1
	unsigned int sig_flags = 0;
a108 1
	int non_fips_allow = 0;
d111 1
a111 1
ERR_load_crypto_strings();
a169 21
		else if (strcmp(*argv,"-x931") == 0)
			sig_flags = EVP_MD_CTX_FLAG_PAD_X931;
		else if (strcmp(*argv,"-pss_saltlen") == 0)
			{
			int saltlen;
			if (--argc < 1) break;
			saltlen=atoi(*(++argv));
			if (saltlen == -1)
				sig_flags = EVP_MD_CTX_FLAG_PSS_MREC;
			else if (saltlen == -2)
				sig_flags = EVP_MD_CTX_FLAG_PSS_MDLEN;
			else if (saltlen < -2 || saltlen >= 0xFFFE)
				{
				BIO_printf(bio_err, "Invalid PSS salt length %d\n", saltlen);
				goto end;
				}
			else
				sig_flags = saltlen;
			sig_flags <<= 16;
			sig_flags |= EVP_MD_CTX_FLAG_PAD_PSS;
			}
a192 2
		else if (strcmp(*argv,"-non-fips-allow") == 0)
			non_fips_allow=1;
d359 1
a360 13
	if (non_fips_allow)
		{
		EVP_MD_CTX *md_ctx;
		BIO_get_md_ctx(bmd,&md_ctx);
		EVP_MD_CTX_set_flags(md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
		}

	if (sig_flags)
		{
		EVP_MD_CTX *md_ctx;
		BIO_get_md_ctx(bmd,&md_ctx);
		EVP_MD_CTX_set_flags(md_ctx, sig_flags);
		}
d376 1
a376 1
			  siglen,"","(stdin)",bmd,hmac_key,non_fips_allow);
a380 1
		err = 0;
d402 1
a402 1
				siglen,tmp,argv[i],bmd,hmac_key,non_fips_allow);
d429 1
a429 1
	  const char *file,BIO *bmd,const char *hmac_key,int non_fips_allow)
@


1.1.1.10
log
@import OpenSSL-1.0.0a
@
text
@d78 2
a79 23
	  EVP_PKEY *key, unsigned char *sigin, int siglen,
	  const char *sig_name, const char *md_name,
	  const char *file,BIO *bmd);

static void list_md_fn(const EVP_MD *m,
			const char *from, const char *to, void *arg)
	{
	const char *mname;
	/* Skip aliases */
	if (!m)
		return;
	mname = OBJ_nid2ln(EVP_MD_type(m));
	/* Skip shortnames */
	if (strcmp(from, mname))
		return;
	/* Skip clones */
	if (EVP_MD_flags(m) & EVP_MD_FLAG_PKEY_DIGEST)
		return;
	if (strchr(mname, ' '))
		mname= EVP_MD_name(m);
	BIO_printf(arg, "-%-14s to use the %s message digest algorithm\n",
			mname, mname);
	}
d92 1
d104 1
d110 1
a110 2
	char *mac_name=NULL;
	STACK_OF(OPENSSL_STRING) *sigopts = NULL, *macopts = NULL;
d113 1
a113 1

a137 2
		else if (strcmp(*argv,"-r") == 0)
			separator=2;
d172 21
a207 1
        		e = setup_engine(bio_err, engine, 0);
d216 4
a225 24
		else if (!strcmp(*argv,"-mac"))
			{
			if (--argc < 1)
				break;
			mac_name=*++argv;
			}
		else if (strcmp(*argv,"-sigopt") == 0)
			{
			if (--argc < 1)
				break;
			if (!sigopts)
				sigopts = sk_OPENSSL_STRING_new_null();
			if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))
				break;
			}
		else if (strcmp(*argv,"-macopt") == 0)
			{
			if (--argc < 1)
				break;
			if (!macopts)
				macopts = sk_OPENSSL_STRING_new_null();
			if (!macopts || !sk_OPENSSL_STRING_push(macopts, *(++argv)))
				break;
			}
d234 2
d239 1
a247 1
		BIO_printf(bio_err,"-r              to output the digest in coreutils format\n");
a254 1
		BIO_printf(bio_err,"-out filename   output to filename rather than stdout\n");
d256 1
a256 1
		BIO_printf(bio_err,"-sigopt nm:v    signature parameter\n");
a257 2
		BIO_printf(bio_err,"-mac algorithm  create MAC (not neccessarily HMAC)\n"); 
		BIO_printf(bio_err,"-macopt nm:v    MAC algorithm parameters or key\n");
d262 29
a290 1
		EVP_MD_do_all_sorted(list_md_fn, bio_err);
d294 4
d320 2
a321 4
		if(keyfile)
			out_bin = 1;
		else
			out_bin = 0;
a346 5
	if ((!!mac_name + !!keyfile + !!hmac_key) > 1)
		{
		BIO_printf(bio_err, "MAC and Signing key cannot both be specified\n");
		goto end;
		}
a363 95
	if (mac_name)
		{
		EVP_PKEY_CTX *mac_ctx = NULL;
		int r = 0;
		if (!init_gen_str(bio_err, &mac_ctx, mac_name,e, 0))
			goto mac_end;
		if (macopts)
			{
			char *macopt;
			for (i = 0; i < sk_OPENSSL_STRING_num(macopts); i++)
				{
				macopt = sk_OPENSSL_STRING_value(macopts, i);
				if (pkey_ctrl_string(mac_ctx, macopt) <= 0)
					{
					BIO_printf(bio_err,
						"MAC parameter error \"%s\"\n",
						macopt);
					ERR_print_errors(bio_err);
					goto mac_end;
					}
				}
			}
		if (EVP_PKEY_keygen(mac_ctx, &sigkey) <= 0)
			{
			BIO_puts(bio_err, "Error generating key\n");
			ERR_print_errors(bio_err);
			goto mac_end;
			}
		r = 1;
		mac_end:
		if (mac_ctx)
			EVP_PKEY_CTX_free(mac_ctx);
		if (r == 0)
			goto end;
		}

	if (hmac_key)
		{
		sigkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, e,
					(unsigned char *)hmac_key, -1);
		if (!sigkey)
			goto end;
		}

	if (sigkey)
		{
		EVP_MD_CTX *mctx = NULL;
		EVP_PKEY_CTX *pctx = NULL;
		int r;
		if (!BIO_get_md_ctx(bmd, &mctx))
			{
			BIO_printf(bio_err, "Error getting context\n");
			ERR_print_errors(bio_err);
			goto end;
			}
		if (do_verify)
			r = EVP_DigestVerifyInit(mctx, &pctx, md, e, sigkey);
		else
			r = EVP_DigestSignInit(mctx, &pctx, md, e, sigkey);
		if (!r)
			{
			BIO_printf(bio_err, "Error setting context\n");
			ERR_print_errors(bio_err);
			goto end;
			}
		if (sigopts)
			{
			char *sigopt;
			for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++)
				{
				sigopt = sk_OPENSSL_STRING_value(sigopts, i);
				if (pkey_ctrl_string(pctx, sigopt) <= 0)
					{
					BIO_printf(bio_err,
						"parameter error \"%s\"\n",
						sigopt);
					ERR_print_errors(bio_err);
					goto end;
					}
				}
			}
		}
	/* we use md as a filter, reading from 'in' */
	else
		{
		if (md == NULL)
			md = EVP_md5(); 
		if (!BIO_set_md(bmd,md))
			{
			BIO_printf(bio_err, "Error setting digest %s\n", pname);
			ERR_print_errors(bio_err);
			goto end;
			}
		}

a383 1
	inp=BIO_push(bmd,in);
d385 8
a392 1
	if (md == NULL)
d394 3
a396 3
		EVP_MD_CTX *tctx;
		BIO_get_md_ctx(bmd, &tctx);
		md = EVP_MD_CTX_md(tctx);
d399 10
d413 1
a413 1
			  siglen,NULL,NULL,"stdin",bmd);
d417 1
a417 13
		const char *md_name = NULL, *sig_name = NULL;
		if(!out_bin)
			{
			if (sigkey)
				{
				const EVP_PKEY_ASN1_METHOD *ameth;
				ameth = EVP_PKEY_get0_asn1(sigkey);
				if (ameth)
					EVP_PKEY_asn1_get0_info(NULL, NULL,
						NULL, NULL, &sig_name, ameth);
				}
			md_name = EVP_MD_name(md);
			}
d421 1
d423 1
d430 7
d438 1
d440 1
a440 1
				siglen,sig_name,md_name, argv[i],bmd);
d443 2
a458 4
	if (sigopts)
		sk_OPENSSL_STRING_free(sigopts);
	if (macopts)
		sk_OPENSSL_STRING_free(macopts);
d466 2
a467 3
	  EVP_PKEY *key, unsigned char *sigin, int siglen,
	  const char *sig_name, const char *md_name,
	  const char *file,BIO *bmd)
d469 1
a469 1
	size_t len;
d471 6
d478 6
d499 1
a499 1
		i = EVP_DigestVerifyFinal(ctx, sigin, (unsigned int)siglen); 
d519 1
a519 2
		len = BUFSIZE;
		if(!EVP_DigestSignFinal(ctx, buf, &len)) 
d526 5
a531 1
		{
a532 6
		if ((int)len <0)
			{
			ERR_print_errors(bio_err);
			return 1;
			}
		}
a534 6
	else if (sep == 2)
		{
		for (i=0; i<(int)len; i++)
			BIO_printf(out, "%02x",buf[i]);
		BIO_printf(out, " *%s\n", file);
		}
d537 1
a537 6
		if (sig_name)
			BIO_printf(out, "%s-%s(%s)= ", sig_name, md_name, file);
		else if (md_name)
			BIO_printf(out, "%s(%s)= ", md_name, file);
		else
			BIO_printf(out, "(%s)= ", file);
d545 4
@


1.1.1.11
log
@import OpenSSL-1.0.1c
@
text
@a129 1
	int non_fips_allow = 0;
a217 4
		else if (strcmp(*argv,"-non-fips-allow") == 0)
			non_fips_allow=1;
		else if (!strcmp(*argv,"-fips-fingerprint"))
			hmac_key = "etaonrishdlcupfm";
a395 7
		}

	if (non_fips_allow)
		{
		EVP_MD_CTX *md_ctx;
		BIO_get_md_ctx(bmd,&md_ctx);
		EVP_MD_CTX_set_flags(md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
@


1.1.1.12
log
@Import OpenSSL 1.0.1g
@
text
@d219 2
a222 2
		else if (strcmp(*argv,"-non-fips-allow") == 0)
			non_fips_allow=1;
d430 1
a430 1
			r = EVP_DigestVerifyInit(mctx, &pctx, md, NULL, sigkey);
d432 1
a432 1
			r = EVP_DigestSignInit(mctx, &pctx, md, NULL, sigkey);
@


