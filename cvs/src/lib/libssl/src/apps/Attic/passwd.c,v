head	1.25;
access;
symbols
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	butholakala:1.7
	openssl_1_0_1_g:1.1.1.3
	OPENBSD_5_5:1.7.0.24
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.20
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.18
	OPENBSD_5_3_BASE:1.7
	openssl_1_0_1_c:1.1.1.3
	OPENBSD_5_2:1.7.0.14
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.16
	openssl_1_0_0_f:1.1.1.3
	openssl_1_0_0_e:1.1.1.3
	OPENBSD_5_0:1.7.0.12
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	openssh_1_0_0_a:1.1.1.3
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	openssl_0_9_8_k:1.1.1.3
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	openssl_0_9_8_j:1.1.1.3
	openssl_0_9_8_h:1.1.1.3
	pre_openssl_0_9_8h:1.6
	OPENBSD_4_4:1.6.0.14
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.12
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.10
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.8
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.6
	OPENBSD_4_0_BASE:1.6
	openssl_0_9_7j:1.1.1.2
	openssl:1.1.1
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENSSL_0_9_7G:1.1.1.2
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.25
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.24;
commitid	7A7DObXgY4Fni8xJ;

1.24
date	2014.07.25.06.05.32;	author doug;	state Exp;
branches;
next	1.23;
commitid	DnBLYuKKjvrWeH3R;

1.23
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	EB0l28piqIRSpBUh;

1.22
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.21;
commitid	0NuggCO2WJOZj8Kh;

1.21
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	mJUVYpkFBZ0Zv2bG;

1.20
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.23.19.09.48;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.18.04.17.16;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.21.55.07;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.15.17.46.16;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.25.07.22.36;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.22.00.02.49;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.56.56;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.08.11;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.33;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.34.21;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: passwd.c,v 1.24 2014/07/25 06:05:32 doug Exp $ */

#if defined OPENSSL_NO_MD5
#define NO_MD5CRYPT_1
#endif

#if !defined(OPENSSL_NO_DES) || !defined(NO_MD5CRYPT_1)

#include <assert.h>
#include <string.h>

#include "apps.h"

#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/rand.h>

#ifndef OPENSSL_NO_DES
#include <openssl/des.h>
#endif

#ifndef NO_MD5CRYPT_1
#include <openssl/md5.h>
#endif

static unsigned const char cov_2char[64] = {
	/* from crypto/des/fcrypt.c */
	0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
	0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44,
	0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
	0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,
	0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
	0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
	0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A
};

static int
do_passwd(int passed_salt, char **salt_p, char **salt_malloc_p,
    char *passwd, BIO * out, int quiet, int table, int reverse,
    size_t pw_maxlen, int usecrypt, int use1, int useapr1);

/* -crypt        - standard Unix password algorithm (default)
 * -1            - MD5-based password algorithm
 * -apr1         - MD5-based password algorithm, Apache variant
 * -salt string  - salt
 * -in file      - read passwords from file
 * -stdin        - read passwords from stdin
 * -noverify     - never verify when reading password from terminal
 * -quiet        - no warnings
 * -table        - format output as table
 * -reverse      - switch table columns
 */

int passwd_main(int, char **);

int
passwd_main(int argc, char **argv)
{
	int ret = 1;
	char *infile = NULL;
	int in_stdin = 0;
	int in_noverify = 0;
	char *salt = NULL, *passwd = NULL, **passwds = NULL;
	char *salt_malloc = NULL, *passwd_malloc = NULL;
	size_t passwd_malloc_size = 0;
	int pw_source_defined = 0;
	BIO *in = NULL, *out = NULL;
	int i, badopt, opt_done;
	int passed_salt = 0, quiet = 0, table = 0, reverse = 0;
	int usecrypt = 0, use1 = 0, useapr1 = 0;
	size_t pw_maxlen = 0;

	out = BIO_new(BIO_s_file());
	if (out == NULL)
		goto err;
	BIO_set_fp(out, stdout, BIO_NOCLOSE | BIO_FP_TEXT);

	badopt = 0, opt_done = 0;
	i = 0;
	while (!badopt && !opt_done && argv[++i] != NULL) {
		if (strcmp(argv[i], "-crypt") == 0)
			usecrypt = 1;
		else if (strcmp(argv[i], "-1") == 0)
			use1 = 1;
		else if (strcmp(argv[i], "-apr1") == 0)
			useapr1 = 1;
		else if (strcmp(argv[i], "-salt") == 0) {
			if ((argv[i + 1] != NULL) && (salt == NULL)) {
				passed_salt = 1;
				salt = argv[++i];
			} else
				badopt = 1;
		} else if (strcmp(argv[i], "-in") == 0) {
			if ((argv[i + 1] != NULL) && !pw_source_defined) {
				pw_source_defined = 1;
				infile = argv[++i];
			} else
				badopt = 1;
		} else if (strcmp(argv[i], "-stdin") == 0) {
			if (!pw_source_defined) {
				pw_source_defined = 1;
				in_stdin = 1;
			} else
				badopt = 1;
		} else if (strcmp(argv[i], "-noverify") == 0)
			in_noverify = 1;
		else if (strcmp(argv[i], "-quiet") == 0)
			quiet = 1;
		else if (strcmp(argv[i], "-table") == 0)
			table = 1;
		else if (strcmp(argv[i], "-reverse") == 0)
			reverse = 1;
		else if (argv[i][0] == '-')
			badopt = 1;
		else if (!pw_source_defined)
			/* non-option arguments, use as passwords */
		{
			pw_source_defined = 1;
			passwds = &argv[i];
			opt_done = 1;
		} else
			badopt = 1;
	}

	if (!usecrypt && !use1 && !useapr1)	/* use default */
		usecrypt = 1;
	if (usecrypt + use1 + useapr1 > 1)	/* conflict */
		badopt = 1;

	/* reject unsupported algorithms */
#ifdef OPENSSL_NO_DES
	if (usecrypt)
		badopt = 1;
#endif
#ifdef NO_MD5CRYPT_1
	if (use1 || useapr1)
		badopt = 1;
#endif

	if (badopt) {
		BIO_printf(bio_err, "Usage: passwd [options] [passwords]\n");
		BIO_printf(bio_err, "where options are\n");
#ifndef OPENSSL_NO_DES
		BIO_printf(bio_err, "-crypt             standard Unix password algorithm (default)\n");
#endif
#ifndef NO_MD5CRYPT_1
		BIO_printf(bio_err, "-1                 MD5-based password algorithm\n");
		BIO_printf(bio_err, "-apr1              MD5-based password algorithm, Apache variant\n");
#endif
		BIO_printf(bio_err, "-salt string       use provided salt\n");
		BIO_printf(bio_err, "-in file           read passwords from file\n");
		BIO_printf(bio_err, "-stdin             read passwords from stdin\n");
		BIO_printf(bio_err, "-noverify          never verify when reading password from terminal\n");
		BIO_printf(bio_err, "-quiet             no warnings\n");
		BIO_printf(bio_err, "-table             format output as table\n");
		BIO_printf(bio_err, "-reverse           switch table columns\n");

		goto err;
	}
	if ((infile != NULL) || in_stdin) {
		in = BIO_new(BIO_s_file());
		if (in == NULL)
			goto err;
		if (infile != NULL) {
			assert(in_stdin == 0);
			if (BIO_read_filename(in, infile) <= 0)
				goto err;
		} else {
			assert(in_stdin);
			BIO_set_fp(in, stdin, BIO_NOCLOSE);
		}
	}
	if (usecrypt)
		pw_maxlen = 8;
	else if (use1 || useapr1)
		pw_maxlen = 256;/* arbitrary limit, should be enough for most
				 * passwords */

	if (passwds == NULL) {
		/* no passwords on the command line */

		passwd_malloc_size = pw_maxlen + 2;
		/* longer than necessary so that we can warn about truncation */
		passwd = passwd_malloc = malloc(passwd_malloc_size);
		if (passwd_malloc == NULL)
			goto err;
	}
	if ((in == NULL) && (passwds == NULL)) {
		/* build a null-terminated list */
		static char *passwds_static[2] = {NULL, NULL};

		passwds = passwds_static;
		if (in == NULL)
			if (EVP_read_pw_string(passwd_malloc, passwd_malloc_size, "Password: ", !(passed_salt || in_noverify)) != 0)
				goto err;
		passwds[0] = passwd_malloc;
	}
	if (in == NULL) {
		assert(passwds != NULL);
		assert(*passwds != NULL);

		do {		/* loop over list of passwords */
			passwd = *passwds++;
			if (!do_passwd(passed_salt, &salt, &salt_malloc, passwd, out,
				quiet, table, reverse, pw_maxlen, usecrypt, use1, useapr1))
				goto err;
		}
		while (*passwds != NULL);
	} else
		/* in != NULL */
	{
		int done;

		assert(passwd != NULL);
		do {
			int r = BIO_gets(in, passwd, pw_maxlen + 1);
			if (r > 0) {
				char *c = (strchr(passwd, '\n'));
				if (c != NULL)
					*c = 0;	/* truncate at newline */
				else {
					/* ignore rest of line */
					char trash[BUFSIZ];
					do
						r = BIO_gets(in, trash, sizeof trash);
					while ((r > 0) && (!strchr(trash, '\n')));
				}

				if (!do_passwd(passed_salt, &salt, &salt_malloc, passwd, out,
					quiet, table, reverse, pw_maxlen, usecrypt, use1, useapr1))
					goto err;
			}
			done = (r <= 0);
		}
		while (!done);
	}
	ret = 0;

err:
	ERR_print_errors(bio_err);
	free(salt_malloc);
	free(passwd_malloc);
	BIO_free(in);
	if (out)
		BIO_free_all(out);

	return (ret);
}


#ifndef NO_MD5CRYPT_1
/* MD5-based password algorithm (should probably be available as a library
 * function; then the static buffer would not be acceptable).
 * For magic string "1", this should be compatible to the MD5-based BSD
 * password algorithm.
 * For 'magic' string "apr1", this is compatible to the MD5-based Apache
 * password algorithm.
 * (Apparently, the Apache password algorithm is identical except that the
 * 'magic' string was changed -- the laziest application of the NIH principle
 * I've ever encountered.)
 */
static char *
md5crypt(const char *passwd, const char *magic, const char *salt)
{
	static char out_buf[6 + 9 + 24 + 2];	/* "$apr1$..salt..$.......md5h
						 * ash..........\0" */
	unsigned char buf[MD5_DIGEST_LENGTH];
	char *salt_out;
	int n;
	unsigned int i;
	EVP_MD_CTX md, md2;
	size_t passwd_len, salt_len;

	passwd_len = strlen(passwd);
	out_buf[0] = '$';
	out_buf[1] = 0;
	assert(strlen(magic) <= 4);	/* "1" or "apr1" */
	strlcat(out_buf, magic, sizeof(out_buf));
	strlcat(out_buf, "$", sizeof(out_buf));
	strlcat(out_buf, salt, sizeof(out_buf));
	assert(strlen(out_buf) <= 6 + 8);	/* "$apr1$..salt.." */
	salt_out = out_buf + 2 + strlen(magic);
	salt_len = strlen(salt_out);
	assert(salt_len <= 8);

	EVP_MD_CTX_init(&md);
	EVP_DigestInit_ex(&md, EVP_md5(), NULL);
	EVP_DigestUpdate(&md, passwd, passwd_len);
	EVP_DigestUpdate(&md, "$", 1);
	EVP_DigestUpdate(&md, magic, strlen(magic));
	EVP_DigestUpdate(&md, "$", 1);
	EVP_DigestUpdate(&md, salt_out, salt_len);

	EVP_MD_CTX_init(&md2);
	EVP_DigestInit_ex(&md2, EVP_md5(), NULL);
	EVP_DigestUpdate(&md2, passwd, passwd_len);
	EVP_DigestUpdate(&md2, salt_out, salt_len);
	EVP_DigestUpdate(&md2, passwd, passwd_len);
	EVP_DigestFinal_ex(&md2, buf, NULL);

	for (i = passwd_len; i > sizeof buf; i -= sizeof buf)
		EVP_DigestUpdate(&md, buf, sizeof buf);
	EVP_DigestUpdate(&md, buf, i);

	n = passwd_len;
	while (n) {
		EVP_DigestUpdate(&md, (n & 1) ? "\0" : passwd, 1);
		n >>= 1;
	}
	EVP_DigestFinal_ex(&md, buf, NULL);

	for (i = 0; i < 1000; i++) {
		EVP_DigestInit_ex(&md2, EVP_md5(), NULL);
		EVP_DigestUpdate(&md2, (i & 1) ? (unsigned const char *) passwd : buf,
		    (i & 1) ? passwd_len : sizeof buf);
		if (i % 3)
			EVP_DigestUpdate(&md2, salt_out, salt_len);
		if (i % 7)
			EVP_DigestUpdate(&md2, passwd, passwd_len);
		EVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned const char *) passwd,
		    (i & 1) ? sizeof buf : passwd_len);
		EVP_DigestFinal_ex(&md2, buf, NULL);
	}
	EVP_MD_CTX_cleanup(&md2);

	{
		/* transform buf into output string */

		unsigned char buf_perm[sizeof buf];
		int dest, source;
		char *output;

		/* silly output permutation */
		for (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17)
			buf_perm[dest] = buf[source];
		buf_perm[14] = buf[5];
		buf_perm[15] = buf[11];
		assert(16 == sizeof buf_perm);

		output = salt_out + salt_len;
		assert(output == out_buf + strlen(out_buf));

		*output++ = '$';

		for (i = 0; i < 15; i += 3) {
			*output++ = cov_2char[buf_perm[i + 2] & 0x3f];
			*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |
			    (buf_perm[i + 2] >> 6)];
			*output++ = cov_2char[((buf_perm[i] & 3) << 4) |
			    (buf_perm[i + 1] >> 4)];
			*output++ = cov_2char[buf_perm[i] >> 2];
		}
		assert(i == 15);
		*output++ = cov_2char[buf_perm[i] & 0x3f];
		*output++ = cov_2char[buf_perm[i] >> 6];
		*output = 0;
		assert(strlen(out_buf) < sizeof(out_buf));
	}
	EVP_MD_CTX_cleanup(&md);

	return out_buf;
}
#endif


static int
do_passwd(int passed_salt, char **salt_p, char **salt_malloc_p,
    char *passwd, BIO * out, int quiet, int table, int reverse,
    size_t pw_maxlen, int usecrypt, int use1, int useapr1)
{
	char *hash = NULL;

	assert(salt_p != NULL);
	assert(salt_malloc_p != NULL);

	/* first make sure we have a salt */
	if (!passed_salt) {
#ifndef OPENSSL_NO_DES
		if (usecrypt) {
			if (*salt_malloc_p == NULL) {
				*salt_p = *salt_malloc_p = malloc(3);
				if (*salt_malloc_p == NULL)
					goto err;
			}
			if (RAND_pseudo_bytes((unsigned char *) *salt_p, 2) < 0)
				goto err;
			(*salt_p)[0] = cov_2char[(*salt_p)[0] & 0x3f];	/* 6 bits */
			(*salt_p)[1] = cov_2char[(*salt_p)[1] & 0x3f];	/* 6 bits */
			(*salt_p)[2] = 0;
		}
#endif				/* !OPENSSL_NO_DES */

#ifndef NO_MD5CRYPT_1
		if (use1 || useapr1) {
			int i;

			if (*salt_malloc_p == NULL) {
				*salt_p = *salt_malloc_p = malloc(9);
				if (*salt_malloc_p == NULL)
					goto err;
			}
			if (RAND_pseudo_bytes((unsigned char *) *salt_p, 8) < 0)
				goto err;

			for (i = 0; i < 8; i++)
				(*salt_p)[i] = cov_2char[(*salt_p)[i] & 0x3f];	/* 6 bits */
			(*salt_p)[8] = 0;
		}
#endif				/* !NO_MD5CRYPT_1 */
	}
	assert(*salt_p != NULL);

	/* truncate password if necessary */
	if ((strlen(passwd) > pw_maxlen)) {
		if (!quiet)
			/*
			 * XXX: really we should know how to print a size_t,
			 * not cast it
			 */
			BIO_printf(bio_err, "Warning: truncating password to %u characters\n", (unsigned) pw_maxlen);
		passwd[pw_maxlen] = 0;
	}
	assert(strlen(passwd) <= pw_maxlen);

	/* now compute password hash */
#ifndef OPENSSL_NO_DES
	if (usecrypt)
		hash = DES_crypt(passwd, *salt_p);
#endif
#ifndef NO_MD5CRYPT_1
	if (use1 || useapr1)
		hash = md5crypt(passwd, (use1 ? "1" : "apr1"), *salt_p);
#endif
	assert(hash != NULL);

	if (table && !reverse)
		BIO_printf(out, "%s\t%s\n", passwd, hash);
	else if (table && reverse)
		BIO_printf(out, "%s\t%s\n", hash, passwd);
	else
		BIO_printf(out, "%s\n", hash);
	return 1;

err:
	return 0;
}
#else

int
passwd_main(int argc, char **argv)
{
	fputs("Program not available.\n", stderr)
	return (1);
}
#endif
@


1.24
log
@BIO_free() returns immediately when the sole input is NULL.
Remove unnecessary NULL check.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: passwd.c,v 1.23 2014/07/14 00:35:10 deraadt Exp $ */
@


1.23
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: passwd.c,v 1.22 2014/07/12 17:54:31 jsing Exp $ */
d245 1
a245 2
	if (in)
		BIO_free(in);
@


1.22
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: passwd.c,v 1.21 2014/06/12 15:49:27 deraadt Exp $ */
d39 1
a39 1
static int 
d58 1
a58 1
int 
d249 1
a249 1
	
d369 1
a369 1
static int 
d452 1
a452 1
int 
@


1.21
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a73 3

	if (!load_config(bio_err, NULL))
		goto err;
@


1.20
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@d1 1
a1 1
/* apps/passwd.c */
@


1.19
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a74 2
	signal(SIGPIPE, SIG_IGN);

@


1.18
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d248 2
a249 4
	if (salt_malloc)
		free(salt_malloc);
	if (passwd_malloc)
		free(passwd_malloc);
@


1.17
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d18 1
d22 1
a25 3



@


1.16
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a77 4
	if (bio_err == NULL)
		if ((bio_err = BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);

d80 1
@


1.15
log
@Unifdef -UPEDANTIC. ok beck@@ tedu@@
@
text
@d76 1
a76 1
	apps_startup();
d260 1
a260 1
	apps_shutdown();
@


1.14
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@a351 2
#ifndef PEDANTIC		/* Unfortunately, this generates a "no
				 * effect" warning */
a352 1
#endif
@


1.13
log
@KaboomNF
@
text
@a25 2
#undef PROG
#define PROG passwd_main
d57 1
a57 1
int MAIN(int, char **);
d60 1
a60 1
MAIN(int argc, char **argv)
d467 1
a467 1
MAIN(int argc, char **argv)
@


1.12
log
@oops, exit vs return; spotted by matthew
@
text
@d4 1
a4 1
# define NO_MD5CRYPT_1
d19 1
a19 1
# include <openssl/des.h>
d22 1
a22 1
# include <openssl/md5.h>
d30 1
a30 1
static unsigned const char cov_2char[64]={
d32 8
a39 8
	0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,
	0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,
	0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,
	0x4D,0x4E,0x4F,0x50,0x51,0x52,0x53,0x54,
	0x55,0x56,0x57,0x58,0x59,0x5A,0x61,0x62,
	0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,
	0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,
	0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A
d42 4
a45 3
static int do_passwd(int passed_salt, char **salt_p, char **salt_malloc_p,
	char *passwd, BIO *out, int quiet, int table, int reverse,
	size_t pw_maxlen, int usecrypt, int use1, int useapr1);
d61 3
a63 2
int MAIN(int argc, char **argv)
	{
d81 2
a82 2
		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);
d93 1
a93 2
	while (!badopt && !opt_done && argv[++i] != NULL)
		{
d100 2
a101 4
		else if (strcmp(argv[i], "-salt") == 0)
			{
			if ((argv[i+1] != NULL) && (salt == NULL))
				{
d104 1
a104 2
				}
			else
d106 2
a107 5
			}
		else if (strcmp(argv[i], "-in") == 0)
			{
			if ((argv[i+1] != NULL) && !pw_source_defined)
				{
d110 1
a110 2
				}
			else
d112 2
a113 5
			}
		else if (strcmp(argv[i], "-stdin") == 0)
			{
			if (!pw_source_defined)
				{
d116 1
a116 2
				}
			else
d118 1
a118 2
			}
		else if (strcmp(argv[i], "-noverify") == 0)
d130 1
a130 1
			{
d134 1
a134 2
			}
		else
d136 1
a136 1
		}
d138 1
a138 1
	if (!usecrypt && !use1 && !useapr1) /* use default */
d140 1
a140 1
	if (usecrypt + use1 + useapr1 > 1) /* conflict */
d145 2
a146 1
	if (usecrypt) badopt = 1;
d149 2
a150 1
	if (use1 || useapr1) badopt = 1;
d153 1
a153 2
	if (badopt) 
		{
d170 1
a170 1
		
d172 2
a173 4
		}

	if ((infile != NULL) || in_stdin)
		{
d177 1
a177 2
		if (infile != NULL)
			{
d181 1
a181 3
			}
		else
			{
a183 1
			}
d185 1
a185 1
	
d189 2
a190 1
		pw_maxlen = 256; /* arbitrary limit, should be enough for most passwords */
d192 1
a192 2
	if (passwds == NULL)
		{
d200 2
a201 4
		}

	if ((in == NULL) && (passwds == NULL))
		{
d204 1
a204 1
		
d210 2
a211 4
		}

	if (in == NULL)
		{
d214 2
a215 3
		
		do /* loop over list of passwords */
			{
d220 1
a220 1
			}
d222 1
a222 2
		}
	else
d224 1
a224 1
		{
d227 2
a228 3
		assert (passwd != NULL);
		do
			{
d230 2
a231 3
			if (r > 0)
				{
				char *c = (strchr(passwd, '\n')) ;
d233 2
a234 3
					*c = 0; /* truncate at newline */
				else
					{
d240 2
a241 2
					}
				
d245 1
a245 1
				}
d247 1
a247 1
			}
d249 1
a249 1
		}
d263 2
a264 2
	return(ret);
	}
d278 5
a282 3
static char *md5crypt(const char *passwd, const char *magic, const char *salt)
	{
	static char out_buf[6 + 9 + 24 + 2]; /* "$apr1$..salt..$.......md5hash..........\0" */
d287 1
a287 1
	EVP_MD_CTX md,md2;
d293 1
a293 1
	assert(strlen(magic) <= 4); /* "1" or "apr1" */
d297 1
a297 1
	assert(strlen(out_buf) <= 6 + 8); /* "$apr1$..salt.." */
d301 1
a301 1
	
d303 1
a303 1
	EVP_DigestInit_ex(&md,EVP_md5(), NULL);
d309 1
a309 1
	
d311 1
a311 1
	EVP_DigestInit_ex(&md2,EVP_md5(), NULL);
d320 1
a320 1
	
d322 1
a322 2
	while (n)
		{
d325 1
a325 1
		}
d328 2
a329 3
	for (i = 0; i < 1000; i++)
		{
		EVP_DigestInit_ex(&md2,EVP_md5(), NULL);
d331 1
a331 1
		                       (i & 1) ? passwd_len : sizeof buf);
d337 1
a337 1
		                       (i & 1) ? sizeof buf : passwd_len);
d339 1
a339 1
		}
d341 2
a342 2
	
	 {
d344 1
a344 1
	
d354 2
a355 1
#ifndef PEDANTIC /* Unfortunately, this generates a "no effect" warning */
d358 1
a358 1
		
d361 1
a361 1
		
d364 4
a367 5
		for (i = 0; i < 15; i += 3)
			{
			*output++ = cov_2char[buf_perm[i+2] & 0x3f];
			*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) |
				                  (buf_perm[i+2] >> 6)];
d369 1
a369 1
				                  (buf_perm[i+1] >> 4)];
d371 1
a371 1
			}
d377 1
a377 1
	 }
d381 1
a381 1
	}
d385 5
a389 4
static int do_passwd(int passed_salt, char **salt_p, char **salt_malloc_p,
	char *passwd, BIO *out,	int quiet, int table, int reverse,
	size_t pw_maxlen, int usecrypt, int use1, int useapr1)
	{
d396 1
a396 2
	if (!passed_salt)
		{
d398 2
a399 4
		if (usecrypt)
			{
			if (*salt_malloc_p == NULL)
				{
d403 2
a404 2
				}
			if (RAND_pseudo_bytes((unsigned char *)*salt_p, 2) < 0)
d406 2
a407 2
			(*salt_p)[0] = cov_2char[(*salt_p)[0] & 0x3f]; /* 6 bits */
			(*salt_p)[1] = cov_2char[(*salt_p)[1] & 0x3f]; /* 6 bits */
d409 2
a410 2
			}
#endif /* !OPENSSL_NO_DES */
d413 1
a413 2
		if (use1 || useapr1)
			{
d415 2
a416 3
			
			if (*salt_malloc_p == NULL)
				{
d420 2
a421 2
				}
			if (RAND_pseudo_bytes((unsigned char *)*salt_p, 8) < 0)
d423 1
a423 1
			
d425 1
a425 1
				(*salt_p)[i] = cov_2char[(*salt_p)[i] & 0x3f]; /* 6 bits */
a426 2
			}
#endif /* !NO_MD5CRYPT_1 */
d428 2
a429 1
	
d431 1
a431 1
	
d433 1
a433 2
	if ((strlen(passwd) > pw_maxlen))
		{
d435 5
a439 2
			/* XXX: really we should know how to print a size_t, not cast it */
			BIO_printf(bio_err, "Warning: truncating password to %u characters\n", (unsigned)pw_maxlen);
d441 1
a441 1
		}
d443 1
a443 1
	
d462 1
a462 1
	
d465 1
a465 1
	}
d468 3
a470 2
int MAIN(int argc, char **argv)
	{
d472 2
a473 2
	return(1);
	}
@


1.11
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d500 1
a500 1
	exit(1);
@


1.10
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d289 1
a289 1
	OPENSSL_EXIT(ret);
d500 1
a500 1
	OPENSSL_EXIT(1);
@


1.9
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d214 1
a214 1
		passwd = passwd_malloc = OPENSSL_malloc(passwd_malloc_size);
d281 1
a281 1
		OPENSSL_free(salt_malloc);
d283 1
a283 1
		OPENSSL_free(passwd_malloc);
d428 1
a428 1
				*salt_p = *salt_malloc_p = OPENSSL_malloc(3);
d447 1
a447 1
				*salt_p = *salt_malloc_p = OPENSSL_malloc(9);
@


1.8
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@a87 6
#ifdef OPENSSL_SYS_VMS
	{
	BIO *tmpbio = BIO_new(BIO_f_linebuffer());
	out = BIO_push(tmpbio, out);
	}
#endif
@


1.7
log
@resolve conflicts
@
text
@d3 1
a3 1
#if defined OPENSSL_NO_MD5 || defined CHARSET_EBCDIC
a442 4
#ifdef CHARSET_EBCDIC
			ascii2ebcdic(*salt_p, *salt_p, 2); /* des_crypt will convert
			                                    * back to ASCII */
#endif
@


1.6
log
@avoid spurious ld evil string func warning, spotted by david@@;
feedback & ok avsm@@
@
text
@d315 2
a316 1
	int n, i;
d362 1
a362 1
		EVP_DigestUpdate(&md2, (i & 1) ? (unsigned char *) passwd : buf,
d368 1
a368 1
		EVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned char *) passwd,
d477 2
a478 1
			BIO_printf(bio_err, "Warning: truncating password to %u characters\n", pw_maxlen);
@


1.5
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d323 3
a325 3
	strncat(out_buf, magic, 4);
	strncat(out_buf, "$", 1);
	strncat(out_buf, salt, 8);
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@a21 1
# include <openssl/evp.h>
d295 1
a295 1
	EXIT(ret);
d508 1
a508 1
	EXIT(1);
@


1.3
log
@openssl-engine-0.9.6a merge
@
text
@d3 1
a3 1
#if defined NO_MD5 || defined CHARSET_EBCDIC
d7 1
a7 1
#if !defined(NO_DES) || !defined(NO_MD5CRYPT_1)
d18 1
a18 2

#ifndef NO_DES
d22 1
d53 1
d66 1
d82 3
d89 1
a89 1
#ifdef VMS
d136 2
d163 1
a163 1
#ifdef NO_DES
d174 1
a174 1
#ifndef NO_DES
d184 1
d233 1
a233 1
			if (EVP_read_pw_string(passwd_malloc, passwd_malloc_size, "Password: ", 0) != 0)
d295 1
d317 1
a317 1
	MD5_CTX md;
d332 7
a338 6
	MD5_Init(&md);
	MD5_Update(&md, passwd, passwd_len);
	MD5_Update(&md, "$", 1);
	MD5_Update(&md, magic, strlen(magic));
	MD5_Update(&md, "$", 1);
	MD5_Update(&md, salt_out, salt_len);
d340 6
a345 2
	 {
		MD5_CTX md2;
a346 6
		MD5_Init(&md2);
		MD5_Update(&md2, passwd, passwd_len);
		MD5_Update(&md2, salt_out, salt_len);
		MD5_Update(&md2, passwd, passwd_len);
		MD5_Final(buf, &md2);
	 }
d348 2
a349 2
		MD5_Update(&md, buf, sizeof buf);
	MD5_Update(&md, buf, i);
d354 1
a354 1
		MD5_Update(&md, (n & 1) ? "\0" : passwd, 1);
d357 1
a357 1
	MD5_Final(buf, &md);
d361 3
a363 5
		MD5_CTX md2;

		MD5_Init(&md2);
		MD5_Update(&md2, (i & 1) ? (unsigned char *) passwd : buf,
		                 (i & 1) ? passwd_len : sizeof buf);
d365 1
a365 1
			MD5_Update(&md2, salt_out, salt_len);
d367 4
a370 4
			MD5_Update(&md2, passwd, passwd_len);
		MD5_Update(&md2, (i & 1) ? buf : (unsigned char *) passwd,
		                 (i & 1) ? sizeof buf : passwd_len);
		MD5_Final(buf, &md2);
d372 1
d410 1
d429 1
a429 1
#ifndef NO_DES
d448 1
a448 1
#endif /* !NO_DES */
d483 1
a483 1
#ifndef NO_DES
d485 1
a485 1
		hash = des_crypt(passwd, *salt_p);
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d275 1
d319 1
a319 1
	salt_out = out_buf + 6;
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d4 1
a4 1
# define NO_APR1
d7 1
a7 1
#if !defined(NO_DES) || !defined(NO_APR1)
d22 1
a22 1
#ifndef NO_APR1
d45 1
a45 1
	size_t pw_maxlen, int usecrypt, int useapr1);
d47 3
a49 2
/* -crypt        - standard Unix password algorithm (default, only choice)
 * -apr1         - MD5-based password algorithm
d67 1
d72 1
a72 1
	int usecrypt = 0, useapr1 = 0;
d84 6
d97 2
d150 1
a150 1
	if (!usecrypt && !useapr1) /* use default */
d152 1
a152 1
	if (usecrypt + useapr1 > 1) /* conflict */
d159 2
a160 2
#ifdef NO_APR1
	if (useapr1) badopt = 1;
d170 3
a172 2
#ifndef NO_APR1
		BIO_printf(bio_err, "-apr1              MD5-based password algorithm\n");
d204 1
a204 1
	else if (useapr1)
d210 4
a213 1
		passwd = passwd_malloc = Malloc(pw_maxlen + 1);
d225 1
a225 1
			if (EVP_read_pw_string(passwd_malloc, pw_maxlen + 1, "Password: ", 0) != 0)
d239 1
a239 1
				quiet, table, reverse, pw_maxlen, usecrypt, useapr1))
d268 1
a268 1
					quiet, table, reverse, pw_maxlen, usecrypt, useapr1))
d279 1
a279 1
		Free(salt_malloc);
d281 1
a281 1
		Free(passwd_malloc);
d285 1
a285 1
		BIO_free(out);
d290 12
a301 5
#ifndef NO_APR1
/* MD5-based password algorithm compatible to the one found in Apache
 * (should probably be available as a library function;
 * then the static buffer would not be acceptable) */
static char *apr1_crypt(const char *passwd, const char *salt)
d311 5
a315 1
	strcpy(out_buf, "$apr1$");
d324 3
a326 1
	MD5_Update(&md, "$apr1$", 6);
d410 1
a410 1
	size_t pw_maxlen, int usecrypt, int useapr1)
d425 1
a425 1
				*salt_p = *salt_malloc_p = Malloc(3);
d441 2
a442 2
#ifndef NO_APR1
		if (useapr1)
d448 1
a448 1
				*salt_p = *salt_malloc_p = Malloc(9);
d459 1
a459 1
#endif /* !NO_APR1 */
d478 3
a480 3
#ifndef NO_APR1
	if (useapr1)
		hash = apr1_crypt(passwd, *salt_p);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d3 2
a4 2
#if defined OPENSSL_NO_MD5 || defined CHARSET_EBCDIC
# define NO_MD5CRYPT_1
d7 1
a7 1
#if !defined(OPENSSL_NO_DES) || !defined(NO_MD5CRYPT_1)
d18 2
a19 1
#ifndef OPENSSL_NO_DES
d22 1
a22 2
#ifndef NO_MD5CRYPT_1
# include <openssl/evp.h>
d45 1
a45 1
	size_t pw_maxlen, int usecrypt, int use1, int useapr1);
d47 2
a48 3
/* -crypt        - standard Unix password algorithm (default)
 * -1            - MD5-based password algorithm
 * -apr1         - MD5-based password algorithm, Apache variant
a51 1
 * -noverify     - never verify when reading password from terminal
a63 1
	int in_noverify = 0;
a65 1
	size_t passwd_malloc_size = 0;
d70 1
a70 1
	int usecrypt = 0, use1 = 0, useapr1 = 0;
a77 3

	if (!load_config(bio_err, NULL))
		goto err;
a81 6
#ifdef OPENSSL_SYS_VMS
	{
	BIO *tmpbio = BIO_new(BIO_f_linebuffer());
	out = BIO_push(tmpbio, out);
	}
#endif
a88 2
		else if (strcmp(argv[i], "-1") == 0)
			use1 = 1;
a120 2
		else if (strcmp(argv[i], "-noverify") == 0)
			in_noverify = 1;
d140 1
a140 1
	if (!usecrypt && !use1 && !useapr1) /* use default */
d142 1
a142 1
	if (usecrypt + use1 + useapr1 > 1) /* conflict */
d146 1
a146 1
#ifdef OPENSSL_NO_DES
d149 2
a150 2
#ifdef NO_MD5CRYPT_1
	if (use1 || useapr1) badopt = 1;
d157 1
a157 1
#ifndef OPENSSL_NO_DES
d160 2
a161 3
#ifndef NO_MD5CRYPT_1
		BIO_printf(bio_err, "-1                 MD5-based password algorithm\n");
		BIO_printf(bio_err, "-apr1              MD5-based password algorithm, Apache variant\n");
a165 1
		BIO_printf(bio_err, "-noverify          never verify when reading password from terminal\n");
d193 1
a193 1
	else if (use1 || useapr1)
d199 1
a199 4

		passwd_malloc_size = pw_maxlen + 2;
		/* longer than necessary so that we can warn about truncation */
		passwd = passwd_malloc = OPENSSL_malloc(passwd_malloc_size);
d211 1
a211 1
			if (EVP_read_pw_string(passwd_malloc, passwd_malloc_size, "Password: ", !(passed_salt || in_noverify)) != 0)
d225 1
a225 1
				quiet, table, reverse, pw_maxlen, usecrypt, use1, useapr1))
d254 1
a254 1
					quiet, table, reverse, pw_maxlen, usecrypt, use1, useapr1))
a260 1
	ret = 0;
d265 1
a265 1
		OPENSSL_free(salt_malloc);
d267 1
a267 1
		OPENSSL_free(passwd_malloc);
d271 1
a271 2
		BIO_free_all(out);
	apps_shutdown();
d276 5
a280 12
#ifndef NO_MD5CRYPT_1
/* MD5-based password algorithm (should probably be available as a library
 * function; then the static buffer would not be acceptable).
 * For magic string "1", this should be compatible to the MD5-based BSD
 * password algorithm.
 * For 'magic' string "apr1", this is compatible to the MD5-based Apache
 * password algorithm.
 * (Apparently, the Apache password algorithm is identical except that the
 * 'magic' string was changed -- the laziest application of the NIH principle
 * I've ever encountered.)
 */
static char *md5crypt(const char *passwd, const char *magic, const char *salt)
d286 1
a286 1
	EVP_MD_CTX md,md2;
d290 1
a290 5
	out_buf[0] = '$';
	out_buf[1] = 0;
	assert(strlen(magic) <= 4); /* "1" or "apr1" */
	strncat(out_buf, magic, 4);
	strncat(out_buf, "$", 1);
d293 1
a293 1
	salt_out = out_buf + 2 + strlen(magic);
d297 4
a300 7
	EVP_MD_CTX_init(&md);
	EVP_DigestInit_ex(&md,EVP_md5(), NULL);
	EVP_DigestUpdate(&md, passwd, passwd_len);
	EVP_DigestUpdate(&md, "$", 1);
	EVP_DigestUpdate(&md, magic, strlen(magic));
	EVP_DigestUpdate(&md, "$", 1);
	EVP_DigestUpdate(&md, salt_out, salt_len);
d302 2
a303 6
	EVP_MD_CTX_init(&md2);
	EVP_DigestInit_ex(&md2,EVP_md5(), NULL);
	EVP_DigestUpdate(&md2, passwd, passwd_len);
	EVP_DigestUpdate(&md2, salt_out, salt_len);
	EVP_DigestUpdate(&md2, passwd, passwd_len);
	EVP_DigestFinal_ex(&md2, buf, NULL);
d305 6
d312 2
a313 2
		EVP_DigestUpdate(&md, buf, sizeof buf);
	EVP_DigestUpdate(&md, buf, i);
d318 1
a318 1
		EVP_DigestUpdate(&md, (n & 1) ? "\0" : passwd, 1);
d321 1
a321 1
	EVP_DigestFinal_ex(&md, buf, NULL);
d325 5
a329 3
		EVP_DigestInit_ex(&md2,EVP_md5(), NULL);
		EVP_DigestUpdate(&md2, (i & 1) ? (unsigned char *) passwd : buf,
		                       (i & 1) ? passwd_len : sizeof buf);
d331 1
a331 1
			EVP_DigestUpdate(&md2, salt_out, salt_len);
d333 4
a336 4
			EVP_DigestUpdate(&md2, passwd, passwd_len);
		EVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned char *) passwd,
		                       (i & 1) ? sizeof buf : passwd_len);
		EVP_DigestFinal_ex(&md2, buf, NULL);
a337 1
	EVP_MD_CTX_cleanup(&md2);
a374 1
	EVP_MD_CTX_cleanup(&md);
d383 1
a383 1
	size_t pw_maxlen, int usecrypt, int use1, int useapr1)
d393 1
a393 1
#ifndef OPENSSL_NO_DES
d398 1
a398 1
				*salt_p = *salt_malloc_p = OPENSSL_malloc(3);
d412 1
a412 1
#endif /* !OPENSSL_NO_DES */
d414 2
a415 2
#ifndef NO_MD5CRYPT_1
		if (use1 || useapr1)
d421 1
a421 1
				*salt_p = *salt_malloc_p = OPENSSL_malloc(9);
d432 1
a432 1
#endif /* !NO_MD5CRYPT_1 */
d447 1
a447 1
#ifndef OPENSSL_NO_DES
d449 1
a449 1
		hash = DES_crypt(passwd, *salt_p);
d451 3
a453 3
#ifndef NO_MD5CRYPT_1
	if (use1 || useapr1)
		hash = md5crypt(passwd, (use1 ? "1" : "apr1"), *salt_p);
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d22 1
d296 1
a296 1
	OPENSSL_EXIT(ret);
d509 1
a509 1
	OPENSSL_EXIT(1);
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d315 1
a315 2
	int n;
	unsigned int i;
d361 1
a361 1
		EVP_DigestUpdate(&md2, (i & 1) ? (unsigned const char *) passwd : buf,
d367 1
a367 1
		EVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned const char *) passwd,
d476 1
a476 2
			/* XXX: really we should know how to print a size_t, not cast it */
			BIO_printf(bio_err, "Warning: truncating password to %u characters\n", (unsigned)pw_maxlen);
@


