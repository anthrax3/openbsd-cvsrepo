head	1.39;
access;
symbols
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	butholakala:1.16
	openssl_1_0_1_g:1.1.1.10
	OPENBSD_5_5:1.15.0.12
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.8
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	openssl_1_0_1_c:1.1.1.9
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	openssl_1_0_0_f:1.1.1.9
	openssl_1_0_0_e:1.1.1.9
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	openssh_1_0_0_a:1.1.1.8
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	openssl_0_9_8_k:1.1.1.7
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	openssl_0_9_8_j:1.1.1.7
	openssl_0_9_8_h:1.1.1.6
	pre_openssl_0_9_8h:1.10
	OPENBSD_4_4:1.10.0.14
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.12
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.10
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	openssl_0_9_7j:1.1.1.5
	openssl:1.1.1
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.39
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.38;
commitid	7A7DObXgY4Fni8xJ;

1.38
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	EB0l28piqIRSpBUh;

1.37
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.36;
commitid	0NuggCO2WJOZj8Kh;

1.36
date	2014.07.09.21.10.06;	author tedu;	state Exp;
branches;
next	1.35;
commitid	GA2B4HdKXrLua6CS;

1.35
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	mJUVYpkFBZ0Zv2bG;

1.34
date	2014.06.02.16.23.18;	author jsing;	state Exp;
branches;
next	1.33;
commitid	IqYoI5gjfSomu7k2;

1.33
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.17.15.45.50;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.19.00.41.37;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.18.09.38.42;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.18.04.33.09;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.18.04.17.16;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.18.01.04.53;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.17.21.55.07;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.01.22.58.50;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.09.12.15.19;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.29.05.39.16;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.04.06.55.14;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.56.57;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.15.06.18.29;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.08.11;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.35.17;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.34;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.12.20.42.55;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.22;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.29;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.36.59;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.01.09.12.13.49;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2011.11.03.02.32.06;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: pkcs12.c,v 1.38 2014/07/14 00:35:10 deraadt Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project.
 */
/* ====================================================================
 * Copyright (c) 1999-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <openssl/opensslconf.h>

#if !defined(OPENSSL_NO_DES) && !defined(OPENSSL_NO_SHA1)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "apps.h"

#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/pkcs12.h>

const EVP_CIPHER *enc;

#define NOKEYS		0x1
#define NOCERTS 	0x2
#define INFO		0x4
#define CLCERTS		0x8
#define CACERTS		0x10

int get_cert_chain(X509 * cert, X509_STORE * store, STACK_OF(X509) ** chain);
int dump_certs_keys_p12(BIO * out, PKCS12 * p12, char *pass, int passlen,
    int options, char *pempass);
int dump_certs_pkeys_bags(BIO * out, STACK_OF(PKCS12_SAFEBAG) * bags, char *pass,
    int passlen, int options, char *pempass);
int dump_certs_pkeys_bag(BIO * out, PKCS12_SAFEBAG * bags, char *pass, int passlen,
    int options, char *pempass);
int print_attribs(BIO * out, STACK_OF(X509_ATTRIBUTE) * attrlst, const char *name);
void hex_prin(BIO * out, unsigned char *buf, int len);
int alg_print(BIO * x, X509_ALGOR * alg);
int cert_load(BIO * in, STACK_OF(X509) * sk);
static int set_pbe(BIO * err, int *ppbe, const char *str);

int pkcs12_main(int, char **);

int
pkcs12_main(int argc, char **argv)
{
	ENGINE *e = NULL;
	char *infile = NULL, *outfile = NULL, *keyname = NULL;
	char *certfile = NULL;
	BIO *in = NULL, *out = NULL;
	char **args;
	char *name = NULL;
	char *csp_name = NULL;
	int add_lmk = 0;
	PKCS12 *p12 = NULL;
	char pass[50], macpass[50];
	int export_cert = 0;
	int options = 0;
	int chain = 0;
	int badarg = 0;
	int iter = PKCS12_DEFAULT_ITER;
	int maciter = PKCS12_DEFAULT_ITER;
	int twopass = 0;
	int keytype = 0;
	int cert_pbe;
	int key_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
	int ret = 1;
	int macver = 1;
	int noprompt = 0;
	STACK_OF(OPENSSL_STRING) * canames = NULL;
	char *cpass = NULL, *mpass = NULL;
	char *passargin = NULL, *passargout = NULL, *passarg = NULL;
	char *passin = NULL, *passout = NULL;
	char *macalg = NULL;
	char *CApath = NULL, *CAfile = NULL;
#ifndef OPENSSL_NO_ENGINE
	char *engine = NULL;
#endif

	cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;

	enc = EVP_des_ede3_cbc();

	args = argv + 1;

	while (*args) {
		if (*args[0] == '-') {
			if (!strcmp(*args, "-nokeys"))
				options |= NOKEYS;
			else if (!strcmp(*args, "-keyex"))
				keytype = KEY_EX;
			else if (!strcmp(*args, "-keysig"))
				keytype = KEY_SIG;
			else if (!strcmp(*args, "-nocerts"))
				options |= NOCERTS;
			else if (!strcmp(*args, "-clcerts"))
				options |= CLCERTS;
			else if (!strcmp(*args, "-cacerts"))
				options |= CACERTS;
			else if (!strcmp(*args, "-noout"))
				options |= (NOKEYS | NOCERTS);
			else if (!strcmp(*args, "-info"))
				options |= INFO;
			else if (!strcmp(*args, "-chain"))
				chain = 1;
			else if (!strcmp(*args, "-twopass"))
				twopass = 1;
			else if (!strcmp(*args, "-nomacver"))
				macver = 0;
			else if (!strcmp(*args, "-descert"))
				cert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
			else if (!strcmp(*args, "-export"))
				export_cert = 1;
			else if (!strcmp(*args, "-des"))
				enc = EVP_des_cbc();
			else if (!strcmp(*args, "-des3"))
				enc = EVP_des_ede3_cbc();
#ifndef OPENSSL_NO_IDEA
			else if (!strcmp(*args, "-idea"))
				enc = EVP_idea_cbc();
#endif
#ifndef OPENSSL_NO_AES
			else if (!strcmp(*args, "-aes128"))
				enc = EVP_aes_128_cbc();
			else if (!strcmp(*args, "-aes192"))
				enc = EVP_aes_192_cbc();
			else if (!strcmp(*args, "-aes256"))
				enc = EVP_aes_256_cbc();
#endif
#ifndef OPENSSL_NO_CAMELLIA
			else if (!strcmp(*args, "-camellia128"))
				enc = EVP_camellia_128_cbc();
			else if (!strcmp(*args, "-camellia192"))
				enc = EVP_camellia_192_cbc();
			else if (!strcmp(*args, "-camellia256"))
				enc = EVP_camellia_256_cbc();
#endif
			else if (!strcmp(*args, "-noiter"))
				iter = 1;
			else if (!strcmp(*args, "-maciter"))
				maciter = PKCS12_DEFAULT_ITER;
			else if (!strcmp(*args, "-nomaciter"))
				maciter = 1;
			else if (!strcmp(*args, "-nomac"))
				maciter = -1;
			else if (!strcmp(*args, "-macalg"))
				if (args[1]) {
					args++;
					macalg = *args;
				} else
					badarg = 1;
			else if (!strcmp(*args, "-nodes"))
				enc = NULL;
			else if (!strcmp(*args, "-certpbe")) {
				if (!set_pbe(bio_err, &cert_pbe, *++args))
					badarg = 1;
			} else if (!strcmp(*args, "-keypbe")) {
				if (!set_pbe(bio_err, &key_pbe, *++args))
					badarg = 1;
			} else if (!strcmp(*args, "-inkey")) {
				if (args[1]) {
					args++;
					keyname = *args;
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-certfile")) {
				if (args[1]) {
					args++;
					certfile = *args;
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-name")) {
				if (args[1]) {
					args++;
					name = *args;
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-LMK"))
				add_lmk = 1;
			else if (!strcmp(*args, "-CSP")) {
				if (args[1]) {
					args++;
					csp_name = *args;
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-caname")) {
				if (args[1]) {
					args++;
					if (!canames)
						canames = sk_OPENSSL_STRING_new_null();
					sk_OPENSSL_STRING_push(canames, *args);
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-in")) {
				if (args[1]) {
					args++;
					infile = *args;
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-out")) {
				if (args[1]) {
					args++;
					outfile = *args;
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-passin")) {
				if (args[1]) {
					args++;
					passargin = *args;
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-passout")) {
				if (args[1]) {
					args++;
					passargout = *args;
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-password")) {
				if (args[1]) {
					args++;
					passarg = *args;
					noprompt = 1;
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-CApath")) {
				if (args[1]) {
					args++;
					CApath = *args;
				} else
					badarg = 1;
			} else if (!strcmp(*args, "-CAfile")) {
				if (args[1]) {
					args++;
					CAfile = *args;
				} else
					badarg = 1;
#ifndef OPENSSL_NO_ENGINE
			} else if (!strcmp(*args, "-engine")) {
				if (args[1]) {
					args++;
					engine = *args;
				} else
					badarg = 1;
#endif
			} else
				badarg = 1;

		} else
			badarg = 1;
		args++;
	}

	if (badarg) {
		BIO_printf(bio_err, "Usage: pkcs12 [options]\n");
		BIO_printf(bio_err, "where options are\n");
		BIO_printf(bio_err, "-export       output PKCS12 file\n");
		BIO_printf(bio_err, "-chain        add certificate chain\n");
		BIO_printf(bio_err, "-inkey file   private key if not infile\n");
		BIO_printf(bio_err, "-certfile f   add all certs in f\n");
		BIO_printf(bio_err, "-CApath arg   - PEM format directory of CA's\n");
		BIO_printf(bio_err, "-CAfile arg   - PEM format file of CA's\n");
		BIO_printf(bio_err, "-name \"name\"  use name as friendly name\n");
		BIO_printf(bio_err, "-caname \"nm\"  use nm as CA friendly name (can be used more than once).\n");
		BIO_printf(bio_err, "-in  infile   input filename\n");
		BIO_printf(bio_err, "-out outfile  output filename\n");
		BIO_printf(bio_err, "-noout        don't output anything, just verify.\n");
		BIO_printf(bio_err, "-nomacver     don't verify MAC.\n");
		BIO_printf(bio_err, "-nocerts      don't output certificates.\n");
		BIO_printf(bio_err, "-clcerts      only output client certificates.\n");
		BIO_printf(bio_err, "-cacerts      only output CA certificates.\n");
		BIO_printf(bio_err, "-nokeys       don't output private keys.\n");
		BIO_printf(bio_err, "-info         give info about PKCS#12 structure.\n");
		BIO_printf(bio_err, "-des          encrypt private keys with DES\n");
		BIO_printf(bio_err, "-des3         encrypt private keys with triple DES (default)\n");
#ifndef OPENSSL_NO_IDEA
		BIO_printf(bio_err, "-idea         encrypt private keys with idea\n");
#endif
#ifndef OPENSSL_NO_AES
		BIO_printf(bio_err, "-aes128, -aes192, -aes256\n");
		BIO_printf(bio_err, "              encrypt PEM output with cbc aes\n");
#endif
#ifndef OPENSSL_NO_CAMELLIA
		BIO_printf(bio_err, "-camellia128, -camellia192, -camellia256\n");
		BIO_printf(bio_err, "              encrypt PEM output with cbc camellia\n");
#endif
		BIO_printf(bio_err, "-nodes        don't encrypt private keys\n");
		BIO_printf(bio_err, "-noiter       don't use encryption iteration\n");
		BIO_printf(bio_err, "-nomaciter    don't use MAC iteration\n");
		BIO_printf(bio_err, "-maciter      use MAC iteration\n");
		BIO_printf(bio_err, "-nomac        don't generate MAC\n");
		BIO_printf(bio_err, "-twopass      separate MAC, encryption passwords\n");
		BIO_printf(bio_err, "-descert      encrypt PKCS#12 certificates with triple DES (default RC2-40)\n");
		BIO_printf(bio_err, "-certpbe alg  specify certificate PBE algorithm (default RC2-40)\n");
		BIO_printf(bio_err, "-keypbe alg   specify private key PBE algorithm (default 3DES)\n");
		BIO_printf(bio_err, "-macalg alg   digest algorithm used in MAC (default SHA1)\n");
		BIO_printf(bio_err, "-keyex        set MS key exchange type\n");
		BIO_printf(bio_err, "-keysig       set MS key signature type\n");
		BIO_printf(bio_err, "-password p   set import/export password source\n");
		BIO_printf(bio_err, "-passin p     input file pass phrase source\n");
		BIO_printf(bio_err, "-passout p    output file pass phrase source\n");
#ifndef OPENSSL_NO_ENGINE
		BIO_printf(bio_err, "-engine e     use engine e, possibly a hardware device.\n");
#endif
		BIO_printf(bio_err, "-CSP name     Microsoft CSP name\n");
		BIO_printf(bio_err, "-LMK          Add local machine keyset attribute to private key\n");
		goto end;
	}
#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine, 0);
#endif

	if (passarg) {
		if (export_cert)
			passargout = passarg;
		else
			passargin = passarg;
	}
	if (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {
		BIO_printf(bio_err, "Error getting passwords\n");
		goto end;
	}
	if (!cpass) {
		if (export_cert)
			cpass = passout;
		else
			cpass = passin;
	}
	if (cpass) {
		mpass = cpass;
		noprompt = 1;
	} else {
		cpass = pass;
		mpass = macpass;
	}

	ERR_load_crypto_strings();


	if (!infile)
		in = BIO_new_fp(stdin, BIO_NOCLOSE);
	else
		in = BIO_new_file(infile, "rb");
	if (!in) {
		BIO_printf(bio_err, "Error opening input file %s\n",
		    infile ? infile : "<stdin>");
		perror(infile);
		goto end;
	}

	if (!outfile) {
		out = BIO_new_fp(stdout, BIO_NOCLOSE);
	} else
		out = BIO_new_file(outfile, "wb");
	if (!out) {
		BIO_printf(bio_err, "Error opening output file %s\n",
		    outfile ? outfile : "<stdout>");
		perror(outfile);
		goto end;
	}
	if (twopass) {
		if (EVP_read_pw_string(macpass, sizeof macpass, "Enter MAC Password:", export_cert)) {
			BIO_printf(bio_err, "Can't read Password\n");
			goto end;
		}
	}
	if (export_cert) {
		EVP_PKEY *key = NULL;
		X509 *ucert = NULL, *x = NULL;
		STACK_OF(X509) * certs = NULL;
		const EVP_MD *macmd = NULL;
		unsigned char *catmp = NULL;
		int i;

		if ((options & (NOCERTS | NOKEYS)) == (NOCERTS | NOKEYS)) {
			BIO_printf(bio_err, "Nothing to do!\n");
			goto export_end;
		}
		if (options & NOCERTS)
			chain = 0;

		if (!(options & NOKEYS)) {
			key = load_key(bio_err, keyname ? keyname : infile,
			    FORMAT_PEM, 1, passin, e, "private key");
			if (!key)
				goto export_end;
		}

		/* Load in all certs in input file */
		if (!(options & NOCERTS)) {
			certs = load_certs(bio_err, infile, FORMAT_PEM, NULL, e,
			    "certificates");
			if (!certs)
				goto export_end;

			if (key) {
				/* Look for matching private key */
				for (i = 0; i < sk_X509_num(certs); i++) {
					x = sk_X509_value(certs, i);
					if (X509_check_private_key(x, key)) {
						ucert = x;
						/* Zero keyid and alias */
						X509_keyid_set1(ucert, NULL, 0);
						X509_alias_set1(ucert, NULL, 0);
						/* Remove from list */
						(void) sk_X509_delete(certs, i);
						break;
					}
				}
				if (!ucert) {
					BIO_printf(bio_err, "No certificate matches private key\n");
					goto export_end;
				}
			}
		}

		/* Add any more certificates asked for */
		if (certfile) {
			STACK_OF(X509) * morecerts = NULL;
			if (!(morecerts = load_certs(bio_err, certfile, FORMAT_PEM,
				    NULL, e,
				    "certificates from certfile")))
				goto export_end;
			while (sk_X509_num(morecerts) > 0)
				sk_X509_push(certs, sk_X509_shift(morecerts));
			sk_X509_free(morecerts);
		}


		/* If chaining get chain from user cert */
		if (chain) {
			int vret;
			STACK_OF(X509) * chain2;
			X509_STORE *store = X509_STORE_new();
			if (!store) {
				BIO_printf(bio_err, "Memory allocation error\n");
				goto export_end;
			}
			if (!X509_STORE_load_locations(store, CAfile, CApath))
				X509_STORE_set_default_paths(store);

			vret = get_cert_chain(ucert, store, &chain2);
			X509_STORE_free(store);

			if (!vret) {
				/* Exclude verified certificate */
				for (i = 1; i < sk_X509_num(chain2); i++)
					sk_X509_push(certs, sk_X509_value(chain2, i));
				/* Free first certificate */
				X509_free(sk_X509_value(chain2, 0));
				sk_X509_free(chain2);
			} else {
				if (vret >= 0)
					BIO_printf(bio_err, "Error %s getting chain.\n",
					    X509_verify_cert_error_string(vret));
				else
					ERR_print_errors(bio_err);
				goto export_end;
			}
		}
		/* Add any CA names */

		for (i = 0; i < sk_OPENSSL_STRING_num(canames); i++) {
			catmp = (unsigned char *) sk_OPENSSL_STRING_value(canames, i);
			X509_alias_set1(sk_X509_value(certs, i), catmp, -1);
		}

		if (csp_name && key)
			EVP_PKEY_add1_attr_by_NID(key, NID_ms_csp_name,
			    MBSTRING_ASC, (unsigned char *) csp_name, -1);

		if (add_lmk && key)
			EVP_PKEY_add1_attr_by_NID(key, NID_LocalKeySet, 0, NULL, -1);


		if (!noprompt &&
		    EVP_read_pw_string(pass, sizeof pass, "Enter Export Password:", 1)) {
			BIO_printf(bio_err, "Can't read Password\n");
			goto export_end;
		}
		if (!twopass)
			strlcpy(macpass, pass, sizeof macpass);


		p12 = PKCS12_create(cpass, name, key, ucert, certs,
		    key_pbe, cert_pbe, iter, -1, keytype);

		if (!p12) {
			ERR_print_errors(bio_err);
			goto export_end;
		}
		if (macalg) {
			macmd = EVP_get_digestbyname(macalg);
			if (!macmd) {
				BIO_printf(bio_err, "Unknown digest algorithm %s\n",
				    macalg);
			}
		}
		if (maciter != -1)
			PKCS12_set_mac(p12, mpass, -1, NULL, 0, maciter, macmd);


		i2d_PKCS12_bio(out, p12);

		ret = 0;

export_end:

		if (key)
			EVP_PKEY_free(key);
		if (certs)
			sk_X509_pop_free(certs, X509_free);
		if (ucert)
			X509_free(ucert);

		goto end;

	}
	if (!(p12 = d2i_PKCS12_bio(in, NULL))) {
		ERR_print_errors(bio_err);
		goto end;
	}
	if (!noprompt && EVP_read_pw_string(pass, sizeof pass, "Enter Import Password:", 0)) {
		BIO_printf(bio_err, "Can't read Password\n");
		goto end;
	}

	if (!twopass)
		strlcpy(macpass, pass, sizeof macpass);

	if ((options & INFO) && p12->mac)
		BIO_printf(bio_err, "MAC Iteration %ld\n", p12->mac->iter ? ASN1_INTEGER_get(p12->mac->iter) : 1);
	if (macver) {
		/* If we enter empty password try no password first */
		if (!mpass[0] && PKCS12_verify_mac(p12, NULL, 0)) {
			/* If mac and crypto pass the same set it to NULL too */
			if (!twopass)
				cpass = NULL;
		} else if (!PKCS12_verify_mac(p12, mpass, -1)) {
			BIO_printf(bio_err, "Mac verify error: invalid password?\n");
			ERR_print_errors(bio_err);
			goto end;
		}
		BIO_printf(bio_err, "MAC verified OK\n");
	}
	if (!dump_certs_keys_p12(out, p12, cpass, -1, options, passout)) {
		BIO_printf(bio_err, "Error outputting keys and certificates\n");
		ERR_print_errors(bio_err);
		goto end;
	}
	ret = 0;
end:
	if (p12)
		PKCS12_free(p12);
	BIO_free(in);
	BIO_free_all(out);
	if (canames)
		sk_OPENSSL_STRING_free(canames);
	free(passin);
	free(passout);

	return (ret);
}

int
dump_certs_keys_p12(BIO * out, PKCS12 * p12, char *pass,
    int passlen, int options, char *pempass)
{
	STACK_OF(PKCS7) * asafes = NULL;
	STACK_OF(PKCS12_SAFEBAG) * bags;
	int i, bagnid;
	int ret = 0;
	PKCS7 *p7;

	if (!(asafes = PKCS12_unpack_authsafes(p12)))
		return 0;
	for (i = 0; i < sk_PKCS7_num(asafes); i++) {
		p7 = sk_PKCS7_value(asafes, i);
		bagnid = OBJ_obj2nid(p7->type);
		if (bagnid == NID_pkcs7_data) {
			bags = PKCS12_unpack_p7data(p7);
			if (options & INFO)
				BIO_printf(bio_err, "PKCS7 Data\n");
		} else if (bagnid == NID_pkcs7_encrypted) {
			if (options & INFO) {
				BIO_printf(bio_err, "PKCS7 Encrypted data: ");
				alg_print(bio_err,
				    p7->d.encrypted->enc_data->algorithm);
			}
			bags = PKCS12_unpack_p7encdata(p7, pass, passlen);
		} else
			continue;
		if (!bags)
			goto err;
		if (!dump_certs_pkeys_bags(out, bags, pass, passlen,
			options, pempass)) {
			sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
			goto err;
		}
		sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
		bags = NULL;
	}
	ret = 1;

err:

	if (asafes)
		sk_PKCS7_pop_free(asafes, PKCS7_free);
	return ret;
}

int
dump_certs_pkeys_bags(BIO * out, STACK_OF(PKCS12_SAFEBAG) * bags,
    char *pass, int passlen, int options, char *pempass)
{
	int i;
	for (i = 0; i < sk_PKCS12_SAFEBAG_num(bags); i++) {
		if (!dump_certs_pkeys_bag(out,
			sk_PKCS12_SAFEBAG_value(bags, i),
			pass, passlen,
			options, pempass))
			return 0;
	}
	return 1;
}

int
dump_certs_pkeys_bag(BIO * out, PKCS12_SAFEBAG * bag, char *pass,
    int passlen, int options, char *pempass)
{
	EVP_PKEY *pkey;
	PKCS8_PRIV_KEY_INFO *p8;
	X509 *x509;

	switch (M_PKCS12_bag_type(bag)) {
	case NID_keyBag:
		if (options & INFO)
			BIO_printf(bio_err, "Key bag\n");
		if (options & NOKEYS)
			return 1;
		print_attribs(out, bag->attrib, "Bag Attributes");
		p8 = bag->value.keybag;
		if (!(pkey = EVP_PKCS82PKEY(p8)))
			return 0;
		print_attribs(out, p8->attributes, "Key Attributes");
		PEM_write_bio_PrivateKey(out, pkey, enc, NULL, 0, NULL, pempass);
		EVP_PKEY_free(pkey);
		break;

	case NID_pkcs8ShroudedKeyBag:
		if (options & INFO) {
			BIO_printf(bio_err, "Shrouded Keybag: ");
			alg_print(bio_err, bag->value.shkeybag->algor);
		}
		if (options & NOKEYS)
			return 1;
		print_attribs(out, bag->attrib, "Bag Attributes");
		if (!(p8 = PKCS12_decrypt_skey(bag, pass, passlen)))
			return 0;
		if (!(pkey = EVP_PKCS82PKEY(p8))) {
			PKCS8_PRIV_KEY_INFO_free(p8);
			return 0;
		}
		print_attribs(out, p8->attributes, "Key Attributes");
		PKCS8_PRIV_KEY_INFO_free(p8);
		PEM_write_bio_PrivateKey(out, pkey, enc, NULL, 0, NULL, pempass);
		EVP_PKEY_free(pkey);
		break;

	case NID_certBag:
		if (options & INFO)
			BIO_printf(bio_err, "Certificate bag\n");
		if (options & NOCERTS)
			return 1;
		if (PKCS12_get_attr(bag, NID_localKeyID)) {
			if (options & CACERTS)
				return 1;
		} else if (options & CLCERTS)
			return 1;
		print_attribs(out, bag->attrib, "Bag Attributes");
		if (M_PKCS12_cert_bag_type(bag) != NID_x509Certificate)
			return 1;
		if (!(x509 = PKCS12_certbag2x509(bag)))
			return 0;
		dump_cert_text(out, x509);
		PEM_write_bio_X509(out, x509);
		X509_free(x509);
		break;

	case NID_safeContentsBag:
		if (options & INFO)
			BIO_printf(bio_err, "Safe Contents bag\n");
		print_attribs(out, bag->attrib, "Bag Attributes");
		return dump_certs_pkeys_bags(out, bag->value.safes, pass,
		    passlen, options, pempass);

	default:
		BIO_printf(bio_err, "Warning unsupported bag type: ");
		i2a_ASN1_OBJECT(bio_err, bag->type);
		BIO_printf(bio_err, "\n");
		return 1;
		break;
	}
	return 1;
}

/* Given a single certificate return a verified chain or NULL if error */

/* Hope this is OK .... */

int
get_cert_chain(X509 * cert, X509_STORE * store, STACK_OF(X509) ** chain)
{
	X509_STORE_CTX store_ctx;
	STACK_OF(X509) * chn;
	int i = 0;

	/*
	 * FIXME: Should really check the return status of
	 * X509_STORE_CTX_init for an error, but how that fits into the
	 * return value of this function is less obvious.
	 */
	X509_STORE_CTX_init(&store_ctx, store, cert, NULL);
	if (X509_verify_cert(&store_ctx) <= 0) {
		i = X509_STORE_CTX_get_error(&store_ctx);
		if (i == 0)
			/*
			 * avoid returning 0 if X509_verify_cert() did not
			 * set an appropriate error value in the context
			 */
			i = -1;
		chn = NULL;
		goto err;
	} else
		chn = X509_STORE_CTX_get1_chain(&store_ctx);
err:
	X509_STORE_CTX_cleanup(&store_ctx);
	*chain = chn;

	return i;
}

int
alg_print(BIO * x, X509_ALGOR * alg)
{
	PBEPARAM *pbe;
	const unsigned char *p;
	p = alg->parameter->value.sequence->data;
	pbe = d2i_PBEPARAM(NULL, &p, alg->parameter->value.sequence->length);
	if (!pbe)
		return 1;
	BIO_printf(bio_err, "%s, Iteration %ld\n",
	    OBJ_nid2ln(OBJ_obj2nid(alg->algorithm)),
	    ASN1_INTEGER_get(pbe->iter));
	PBEPARAM_free(pbe);
	return 1;
}

/* Load all certificates from a given file */

int
cert_load(BIO * in, STACK_OF(X509) * sk)
{
	int ret;
	X509 *cert;
	ret = 0;
	while ((cert = PEM_read_bio_X509(in, NULL, NULL, NULL))) {
		ret = 1;
		sk_X509_push(sk, cert);
	}
	if (ret)
		ERR_clear_error();
	return ret;
}

/* Generalised attribute print: handle PKCS#8 and bag attributes */

int
print_attribs(BIO * out, STACK_OF(X509_ATTRIBUTE) * attrlst, const char *name)
{
	X509_ATTRIBUTE *attr;
	ASN1_TYPE *av;
	char *value;
	int i, attr_nid;
	if (!attrlst) {
		BIO_printf(out, "%s: <No Attributes>\n", name);
		return 1;
	}
	if (!sk_X509_ATTRIBUTE_num(attrlst)) {
		BIO_printf(out, "%s: <Empty Attributes>\n", name);
		return 1;
	}
	BIO_printf(out, "%s\n", name);
	for (i = 0; i < sk_X509_ATTRIBUTE_num(attrlst); i++) {
		attr = sk_X509_ATTRIBUTE_value(attrlst, i);
		attr_nid = OBJ_obj2nid(attr->object);
		BIO_printf(out, "    ");
		if (attr_nid == NID_undef) {
			i2a_ASN1_OBJECT(out, attr->object);
			BIO_printf(out, ": ");
		} else
			BIO_printf(out, "%s: ", OBJ_nid2ln(attr_nid));

		if (sk_ASN1_TYPE_num(attr->value.set)) {
			av = sk_ASN1_TYPE_value(attr->value.set, 0);
			switch (av->type) {
			case V_ASN1_BMPSTRING:
				value = OPENSSL_uni2asc(av->value.bmpstring->data,
				    av->value.bmpstring->length);
				BIO_printf(out, "%s\n", value);
				free(value);
				break;

			case V_ASN1_OCTET_STRING:
				hex_prin(out, av->value.octet_string->data,
				    av->value.octet_string->length);
				BIO_printf(out, "\n");
				break;

			case V_ASN1_BIT_STRING:
				hex_prin(out, av->value.bit_string->data,
				    av->value.bit_string->length);
				BIO_printf(out, "\n");
				break;

			default:
				BIO_printf(out, "<Unsupported tag %d>\n", av->type);
				break;
			}
		} else
			BIO_printf(out, "<No Values>\n");
	}
	return 1;
}

void
hex_prin(BIO * out, unsigned char *buf, int len)
{
	int i;
	for (i = 0; i < len; i++)
		BIO_printf(out, "%02X ", buf[i]);
}

static int
set_pbe(BIO * err, int *ppbe, const char *str)
{
	if (!str)
		return 0;
	if (!strcmp(str, "NONE")) {
		*ppbe = -1;
		return 1;
	}
	*ppbe = OBJ_txt2nid(str);
	if (*ppbe == NID_undef) {
		BIO_printf(bio_err, "Unknown PBE algorithm %s\n", str);
		return 0;
	}
	return 1;
}

#endif
@


1.38
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs12.c,v 1.37 2014/07/12 17:54:31 jsing Exp $ */
@


1.37
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs12.c,v 1.36 2014/07/09 21:10:06 tedu Exp $ */
d613 1
a613 1
	
d617 1
a617 1
int 
d664 1
a664 1
int 
d679 1
a679 1
int 
d763 1
a763 1
int 
d795 1
a795 1
int 
d813 1
a813 1
int 
d830 1
a830 1
int 
d888 1
a888 1
void 
d896 1
a896 1
static int 
@


1.36
log
@firebomb some MDEBUG leftovers
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs12.c,v 1.35 2014/06/12 15:49:27 deraadt Exp $ */
a135 3

	if (!load_config(bio_err, NULL))
		goto end;
@


1.35
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a393 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_push_info("read files");
#endif
a404 4
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("write files");
#endif
a416 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("read MAC password");
#endif
a420 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif
a436 4
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("process -export_cert");
		CRYPTO_push_info("reading private key");
#endif
a442 4
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
		CRYPTO_push_info("reading certs from input");
#endif
a470 4
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
		CRYPTO_push_info("reading certs from input 2");
#endif
a482 4
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
		CRYPTO_push_info("reading certs from certfile");
#endif
a483 4
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
		CRYPTO_push_info("building chain");
#endif
a529 4
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
		CRYPTO_push_info("reading password");
#endif
a538 4
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
		CRYPTO_push_info("creating PKCS#12 structure");
#endif
a556 4
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
		CRYPTO_push_info("writing pkcs12");
#endif
a562 5
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
		CRYPTO_pop_info();
		CRYPTO_push_info("process -export_cert: freeing");
#endif
a570 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif
a577 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_push_info("read import password");
#endif
a581 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
#endif
a588 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("verify MAC");
#endif
a599 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif
a600 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_push_info("output keys and certificates");
#endif
a605 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
#endif
a609 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_remove_all_info();
#endif
a821 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_push_info("cert_load(): reading one cert");
#endif
a822 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif
a824 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("cert_load(): reading one cert");
#endif
a825 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
#endif
@


1.34
log
@Stop pretending that openssl(1) applications support the -rand option.
The underlying code has long been removed, making this a no-op.

If your random subsystem actually requires that you seed it from a file,
then you really should go and buy a new random subsystem that was built
after 1990.

Diff from Brent Cook.

ok deraadt@@
@
text
@d1 1
a1 1
/* pkcs12.c */
@


1.33
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@a126 1
	char *inrand = NULL;
a215 6
			} else if (!strcmp(*args, "-rand")) {
				if (args[1]) {
					args++;
					inrand = *args;
				} else
					badarg = 1;
a359 3
		BIO_printf(bio_err, "-rand file:file:...\n");
		BIO_printf(bio_err, "              load the file (or the files in the directory) into\n");
		BIO_printf(bio_err, "              the random number generator\n");
@


1.32
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a133 2
	signal(SIGPIPE, SIG_IGN);

@


1.31
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d700 2
a701 4
	if (passin)
		free(passin);
	if (passout)
		free(passout);
@


1.30
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d60 1
d66 1
d68 1
a73 1

a74 1

@


1.29
log
@deleted seed some time ago
@
text
@a137 2
	if (bio_err == NULL)
		bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
a142 1

@


1.28
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a182 4
#ifndef OPENSSL_NO_SEED
			else if (!strcmp(*args, "-seed"))
				enc = EVP_seed_cbc();
#endif
a343 3
#endif
#ifndef OPENSSL_NO_SEED
		BIO_printf(bio_err, "-seed         encrypt private keys with seed\n");
@


1.27
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d133 1
a133 1
	apps_startup();
d713 1
a713 1
	apps_shutdown();
@


1.26
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d595 1
a595 1
			BUF_strlcpy(macpass, pass, sizeof macpass);
d664 1
a664 1
		BUF_strlcpy(macpass, pass, sizeof macpass);
@


1.25
log
@simplify file:file:... stuff
@
text
@a412 6
	if (export_cert || inrand) {
		app_RAND_load_file(NULL, bio_err, (inrand != NULL));
		if (inrand != NULL)
			BIO_printf(bio_err, "%ld semi-random bytes loaded\n",
			    app_RAND_load_files(inrand));
	}
a701 2
	if (export_cert || inrand)
		app_RAND_write_file(NULL, bio_err);
@


1.24
log
@whitespace normalization
@
text
@d378 1
a378 1
		BIO_printf(bio_err, "-rand file%cfile%c...\n", ':', ':');
@


1.23
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d82 3
a84 3
int dump_certs_keys_p12(BIO * out, PKCS12 * p12, char *pass, int passlen, int options, char *pempass);
int 
dump_certs_pkeys_bags(BIO * out, STACK_OF(PKCS12_SAFEBAG) * bags, char *pass,
d86 7
a92 6
	int dump_certs_pkeys_bag(BIO * out, PKCS12_SAFEBAG * bags, char *pass, int passlen, int options, char *pempass);
	int print_attribs(BIO * out, STACK_OF(X509_ATTRIBUTE) * attrlst, const char *name);
	void hex_prin(BIO * out, unsigned char *buf, int len);
	int alg_print(BIO * x, X509_ALGOR * alg);
	int cert_load(BIO * in, STACK_OF(X509) * sk);
	static int set_pbe(BIO * err, int *ppbe, const char *str);
d94 1
a94 1
	int pkcs12_main(int, char **);
d96 2
a97 1
	int pkcs12_main(int argc, char **argv)
@


1.22
log
@KaboomNF
@
text
@a70 1
#define PROG pkcs12_main
d93 1
a93 1
	int MAIN(int, char **);
d95 1
a95 1
	int MAIN(int argc, char **argv)
@


1.21
log
@Unifdef OPENSSL_FIPS.

ok miod@@
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d82 11
a92 10
int get_cert_chain (X509 *cert, X509_STORE *store, STACK_OF(X509) **chain);
int dump_certs_keys_p12(BIO *out, PKCS12 *p12, char *pass, int passlen, int options, char *pempass);
int dump_certs_pkeys_bags(BIO *out, STACK_OF(PKCS12_SAFEBAG) *bags, char *pass,
			  int passlen, int options, char *pempass);
int dump_certs_pkeys_bag(BIO *out, PKCS12_SAFEBAG *bags, char *pass, int passlen, int options, char *pempass);
int print_attribs(BIO *out, STACK_OF(X509_ATTRIBUTE) *attrlst,const char *name);
void hex_prin(BIO *out, unsigned char *buf, int len);
int alg_print(BIO *x, X509_ALGOR *alg);
int cert_load(BIO *in, STACK_OF(X509) *sk);
static int set_pbe(BIO *err, int *ppbe, const char *str);
d94 1
a94 1
int MAIN(int, char **);
d96 1
a96 1
int MAIN(int argc, char **argv)
d98 30
a127 30
    ENGINE *e = NULL;
    char *infile=NULL, *outfile=NULL, *keyname = NULL;	
    char *certfile=NULL;
    BIO *in=NULL, *out = NULL;
    char **args;
    char *name = NULL;
    char *csp_name = NULL;
    int add_lmk = 0;
    PKCS12 *p12 = NULL;
    char pass[50], macpass[50];
    int export_cert = 0;
    int options = 0;
    int chain = 0;
    int badarg = 0;
    int iter = PKCS12_DEFAULT_ITER;
    int maciter = PKCS12_DEFAULT_ITER;
    int twopass = 0;
    int keytype = 0;
    int cert_pbe;
    int key_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
    int ret = 1;
    int macver = 1;
    int noprompt = 0;
    STACK_OF(OPENSSL_STRING) *canames = NULL;
    char *cpass = NULL, *mpass = NULL;
    char *passargin = NULL, *passargout = NULL, *passarg = NULL;
    char *passin = NULL, *passout = NULL;
    char *inrand = NULL;
    char *macalg = NULL;
    char *CApath = NULL, *CAfile = NULL;
d129 1
a129 1
    char *engine=NULL;
d132 1
a132 1
    apps_startup();
d134 1
a134 1
    cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;
d136 3
a138 2
    enc = EVP_des_ede3_cbc();
    if (bio_err == NULL ) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE);
d143 1
a143 1
    args = argv + 1;
d146 32
a177 18
    while (*args) {
	if (*args[0] == '-') {
		if (!strcmp (*args, "-nokeys")) options |= NOKEYS;
		else if (!strcmp (*args, "-keyex")) keytype = KEY_EX;
		else if (!strcmp (*args, "-keysig")) keytype = KEY_SIG;
		else if (!strcmp (*args, "-nocerts")) options |= NOCERTS;
		else if (!strcmp (*args, "-clcerts")) options |= CLCERTS;
		else if (!strcmp (*args, "-cacerts")) options |= CACERTS;
		else if (!strcmp (*args, "-noout")) options |= (NOKEYS|NOCERTS);
		else if (!strcmp (*args, "-info")) options |= INFO;
		else if (!strcmp (*args, "-chain")) chain = 1;
		else if (!strcmp (*args, "-twopass")) twopass = 1;
		else if (!strcmp (*args, "-nomacver")) macver = 0;
		else if (!strcmp (*args, "-descert"))
    			cert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
		else if (!strcmp (*args, "-export")) export_cert = 1;
		else if (!strcmp (*args, "-des")) enc=EVP_des_cbc();
		else if (!strcmp (*args, "-des3")) enc = EVP_des_ede3_cbc();
d179 2
a180 1
		else if (!strcmp (*args, "-idea")) enc=EVP_idea_cbc();
d183 2
a184 1
		else if (!strcmp(*args, "-seed")) enc=EVP_seed_cbc();
d187 6
a192 3
		else if (!strcmp(*args,"-aes128")) enc=EVP_aes_128_cbc();
		else if (!strcmp(*args,"-aes192")) enc=EVP_aes_192_cbc();
		else if (!strcmp(*args,"-aes256")) enc=EVP_aes_256_cbc();
d195 121
a315 19
		else if (!strcmp(*args,"-camellia128")) enc=EVP_camellia_128_cbc();
		else if (!strcmp(*args,"-camellia192")) enc=EVP_camellia_192_cbc();
		else if (!strcmp(*args,"-camellia256")) enc=EVP_camellia_256_cbc();
#endif
		else if (!strcmp (*args, "-noiter")) iter = 1;
		else if (!strcmp (*args, "-maciter"))
					 maciter = PKCS12_DEFAULT_ITER;
		else if (!strcmp (*args, "-nomaciter"))
					 maciter = 1;
		else if (!strcmp (*args, "-nomac"))
					 maciter = -1;
		else if (!strcmp (*args, "-macalg"))
		    if (args[1]) {
			args++;	
			macalg = *args;
		    } else badarg = 1;
		else if (!strcmp (*args, "-nodes")) enc=NULL;
		else if (!strcmp (*args, "-certpbe")) {
			if (!set_pbe(bio_err, &cert_pbe, *++args))
d317 28
a344 107
		} else if (!strcmp (*args, "-keypbe")) {
			if (!set_pbe(bio_err, &key_pbe, *++args))
				badarg = 1;
		} else if (!strcmp (*args, "-rand")) {
		    if (args[1]) {
			args++;	
			inrand = *args;
		    } else badarg = 1;
		} else if (!strcmp (*args, "-inkey")) {
		    if (args[1]) {
			args++;	
			keyname = *args;
		    } else badarg = 1;
		} else if (!strcmp (*args, "-certfile")) {
		    if (args[1]) {
			args++;	
			certfile = *args;
		    } else badarg = 1;
		} else if (!strcmp (*args, "-name")) {
		    if (args[1]) {
			args++;	
			name = *args;
		    } else badarg = 1;
		} else if (!strcmp (*args, "-LMK"))
			add_lmk = 1;
		else if (!strcmp (*args, "-CSP")) {
		    if (args[1]) {
			args++;	
			csp_name = *args;
		    } else badarg = 1;
		} else if (!strcmp (*args, "-caname")) {
		    if (args[1]) {
			args++;	
			if (!canames) canames = sk_OPENSSL_STRING_new_null();
			sk_OPENSSL_STRING_push(canames, *args);
		    } else badarg = 1;
		} else if (!strcmp (*args, "-in")) {
		    if (args[1]) {
			args++;	
			infile = *args;
		    } else badarg = 1;
		} else if (!strcmp (*args, "-out")) {
		    if (args[1]) {
			args++;	
			outfile = *args;
		    } else badarg = 1;
		} else if (!strcmp(*args,"-passin")) {
		    if (args[1]) {
			args++;	
			passargin = *args;
		    } else badarg = 1;
		} else if (!strcmp(*args,"-passout")) {
		    if (args[1]) {
			args++;	
			passargout = *args;
		    } else badarg = 1;
		} else if (!strcmp (*args, "-password")) {
		    if (args[1]) {
			args++;	
			passarg = *args;
		    	noprompt = 1;
		    } else badarg = 1;
		} else if (!strcmp(*args,"-CApath")) {
		    if (args[1]) {
			args++;	
			CApath = *args;
		    } else badarg = 1;
		} else if (!strcmp(*args,"-CAfile")) {
		    if (args[1]) {
			args++;	
			CAfile = *args;
		    } else badarg = 1;
#ifndef OPENSSL_NO_ENGINE
		} else if (!strcmp(*args,"-engine")) {
		    if (args[1]) {
			args++;	
			engine = *args;
		    } else badarg = 1;
#endif
		} else badarg = 1;

	} else badarg = 1;
	args++;
    }

    if (badarg) {
	BIO_printf (bio_err, "Usage: pkcs12 [options]\n");
	BIO_printf (bio_err, "where options are\n");
	BIO_printf (bio_err, "-export       output PKCS12 file\n");
	BIO_printf (bio_err, "-chain        add certificate chain\n");
	BIO_printf (bio_err, "-inkey file   private key if not infile\n");
	BIO_printf (bio_err, "-certfile f   add all certs in f\n");
	BIO_printf (bio_err, "-CApath arg   - PEM format directory of CA's\n");
	BIO_printf (bio_err, "-CAfile arg   - PEM format file of CA's\n");
	BIO_printf (bio_err, "-name \"name\"  use name as friendly name\n");
	BIO_printf (bio_err, "-caname \"nm\"  use nm as CA friendly name (can be used more than once).\n");
	BIO_printf (bio_err, "-in  infile   input filename\n");
	BIO_printf (bio_err, "-out outfile  output filename\n");
	BIO_printf (bio_err, "-noout        don't output anything, just verify.\n");
	BIO_printf (bio_err, "-nomacver     don't verify MAC.\n");
	BIO_printf (bio_err, "-nocerts      don't output certificates.\n");
	BIO_printf (bio_err, "-clcerts      only output client certificates.\n");
	BIO_printf (bio_err, "-cacerts      only output CA certificates.\n");
	BIO_printf (bio_err, "-nokeys       don't output private keys.\n");
	BIO_printf (bio_err, "-info         give info about PKCS#12 structure.\n");
	BIO_printf (bio_err, "-des          encrypt private keys with DES\n");
	BIO_printf (bio_err, "-des3         encrypt private keys with triple DES (default)\n");
d346 1
a346 1
	BIO_printf (bio_err, "-idea         encrypt private keys with idea\n");
d349 1
a349 1
	BIO_printf (bio_err, "-seed         encrypt private keys with seed\n");
d352 2
a353 2
	BIO_printf (bio_err, "-aes128, -aes192, -aes256\n");
	BIO_printf (bio_err, "              encrypt PEM output with cbc aes\n");
d356 2
a357 2
	BIO_printf (bio_err, "-camellia128, -camellia192, -camellia256\n");
	BIO_printf (bio_err, "              encrypt PEM output with cbc camellia\n");
d359 15
a373 15
	BIO_printf (bio_err, "-nodes        don't encrypt private keys\n");
	BIO_printf (bio_err, "-noiter       don't use encryption iteration\n");
	BIO_printf (bio_err, "-nomaciter    don't use MAC iteration\n");
	BIO_printf (bio_err, "-maciter      use MAC iteration\n");
	BIO_printf (bio_err, "-nomac        don't generate MAC\n");
	BIO_printf (bio_err, "-twopass      separate MAC, encryption passwords\n");
	BIO_printf (bio_err, "-descert      encrypt PKCS#12 certificates with triple DES (default RC2-40)\n");
	BIO_printf (bio_err, "-certpbe alg  specify certificate PBE algorithm (default RC2-40)\n");
	BIO_printf (bio_err, "-keypbe alg   specify private key PBE algorithm (default 3DES)\n");
	BIO_printf (bio_err, "-macalg alg   digest algorithm used in MAC (default SHA1)\n");
	BIO_printf (bio_err, "-keyex        set MS key exchange type\n");
	BIO_printf (bio_err, "-keysig       set MS key signature type\n");
	BIO_printf (bio_err, "-password p   set import/export password source\n");
	BIO_printf (bio_err, "-passin p     input file pass phrase source\n");
	BIO_printf (bio_err, "-passout p    output file pass phrase source\n");
d375 1
a375 1
	BIO_printf (bio_err, "-engine e     use engine e, possibly a hardware device.\n");
d377 7
a383 8
	BIO_printf(bio_err,  "-rand file%cfile%c...\n", ':', ':');
	BIO_printf(bio_err,  "              load the file (or the files in the directory) into\n");
	BIO_printf(bio_err,  "              the random number generator\n");
	BIO_printf(bio_err,  "-CSP name     Microsoft CSP name\n");
	BIO_printf(bio_err,  "-LMK          Add local machine keyset attribute to private key\n");
    	goto end;
    }

d385 1
a385 1
    e = setup_engine(bio_err, engine, 0);
d388 31
a418 79
    if(passarg) {
	if(export_cert) passargout = passarg;
	else passargin = passarg;
    }

    if(!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {
	BIO_printf(bio_err, "Error getting passwords\n");
	goto end;
    }

    if(!cpass) {
    	if(export_cert) cpass = passout;
    	else cpass = passin;
    }

    if(cpass) {
	mpass = cpass;
	noprompt = 1;
    } else {
	cpass = pass;
	mpass = macpass;
    }

    if(export_cert || inrand) {
    	app_RAND_load_file(NULL, bio_err, (inrand != NULL));
        if (inrand != NULL)
		BIO_printf(bio_err,"%ld semi-random bytes loaded\n",
			app_RAND_load_files(inrand));
    }
    ERR_load_crypto_strings();

#ifdef CRYPTO_MDEBUG
    CRYPTO_push_info("read files");
#endif

    if (!infile) in = BIO_new_fp(stdin, BIO_NOCLOSE);
    else in = BIO_new_file(infile, "rb");
    if (!in) {
	    BIO_printf(bio_err, "Error opening input file %s\n",
						infile ? infile : "<stdin>");
	    perror (infile);
	    goto end;
   }

#ifdef CRYPTO_MDEBUG
    CRYPTO_pop_info();
    CRYPTO_push_info("write files");
#endif

    if (!outfile) {
	out = BIO_new_fp(stdout, BIO_NOCLOSE);
    } else out = BIO_new_file(outfile, "wb");
    if (!out) {
	BIO_printf(bio_err, "Error opening output file %s\n",
						outfile ? outfile : "<stdout>");
	perror (outfile);
	goto end;
    }
    if (twopass) {
#ifdef CRYPTO_MDEBUG
    CRYPTO_push_info("read MAC password");
#endif
	if(EVP_read_pw_string (macpass, sizeof macpass, "Enter MAC Password:", export_cert))
	{
    	    BIO_printf (bio_err, "Can't read Password\n");
    	    goto end;
       	}
#ifdef CRYPTO_MDEBUG
    CRYPTO_pop_info();
#endif
    }

    if (export_cert) {
	EVP_PKEY *key = NULL;
	X509 *ucert = NULL, *x = NULL;
	STACK_OF(X509) *certs=NULL;
	const EVP_MD *macmd = NULL;
	unsigned char *catmp = NULL;
	int i;
d420 3
a422 5
	if ((options & (NOCERTS|NOKEYS)) == (NOCERTS|NOKEYS))
		{	
		BIO_printf(bio_err, "Nothing to do!\n");
		goto export_end;
		}
d424 14
a437 2
	if (options & NOCERTS)
		chain = 0;
d439 11
d451 1
a451 2
	CRYPTO_push_info("process -export_cert");
	CRYPTO_push_info("reading private key");
d453 18
a470 5
	if (!(options & NOKEYS))
		{
		key = load_key(bio_err, keyname ? keyname : infile,
				FORMAT_PEM, 1, passin, e, "private key");
		if (!key)
d473 2
d477 12
a488 2
	CRYPTO_pop_info();
	CRYPTO_push_info("reading certs from input");
d491 6
a496 7
	/* Load in all certs in input file */
	if(!(options & NOCERTS))
		{
		certs = load_certs(bio_err, infile, FORMAT_PEM, NULL, e,
							"certificates");
		if (!certs)
			goto export_end;
d498 12
a509 15
		if (key)
			{
			/* Look for matching private key */
			for(i = 0; i < sk_X509_num(certs); i++)
				{
				x = sk_X509_value(certs, i);
				if(X509_check_private_key(x, key))
					{
					ucert = x;
					/* Zero keyid and alias */
					X509_keyid_set1(ucert, NULL, 0);
					X509_alias_set1(ucert, NULL, 0);
					/* Remove from list */
					(void)sk_X509_delete(certs, i);
					break;
d512 3
a514 4
			if (!ucert)
				{
				BIO_printf(bio_err, "No certificate matches private key\n");
				goto export_end;
a516 1

a517 1

d519 2
a520 2
	CRYPTO_pop_info();
	CRYPTO_push_info("reading certs from input 2");
d523 11
a533 13
	/* Add any more certificates asked for */
	if(certfile)
		{
		STACK_OF(X509) *morecerts=NULL;
		if(!(morecerts = load_certs(bio_err, certfile, FORMAT_PEM,
					    NULL, e,
					    "certificates from certfile")))
			goto export_end;
		while(sk_X509_num(morecerts) > 0)
			sk_X509_push(certs, sk_X509_shift(morecerts));
		sk_X509_free(morecerts);
 		}

d535 2
a536 2
	CRYPTO_pop_info();
	CRYPTO_push_info("reading certs from certfile");
d540 2
a541 2
	CRYPTO_pop_info();
	CRYPTO_push_info("building chain");
d544 8
a551 9
	/* If chaining get chain from user cert */
	if (chain) {
        	int vret;
		STACK_OF(X509) *chain2;
		X509_STORE *store = X509_STORE_new();
		if (!store)
			{
			BIO_printf (bio_err, "Memory allocation error\n");
			goto export_end;
d553 2
a554 2
		if (!X509_STORE_load_locations(store, CAfile, CApath))
			X509_STORE_set_default_paths (store);
d556 2
a557 2
		vret = get_cert_chain (ucert, store, &chain2);
		X509_STORE_free(store);
d559 17
a575 16
		if (!vret) {
		    /* Exclude verified certificate */
		    for (i = 1; i < sk_X509_num (chain2) ; i++) 
			sk_X509_push(certs, sk_X509_value (chain2, i));
		    /* Free first certificate */
		    X509_free(sk_X509_value(chain2, 0));
		    sk_X509_free(chain2);
		} else {
			if (vret >= 0)
				BIO_printf (bio_err, "Error %s getting chain.\n",
					X509_verify_cert_error_string(vret));
			else
				ERR_print_errors(bio_err);
			goto export_end;
		}			
    	}
d577 3
a579 6
	/* Add any CA names */

	for (i = 0; i < sk_OPENSSL_STRING_num(canames); i++)
		{
		catmp = (unsigned char *)sk_OPENSSL_STRING_value(canames, i);
		X509_alias_set1(sk_X509_value(certs, i), catmp, -1);
d582 3
a584 3
	if (csp_name && key)
		EVP_PKEY_add1_attr_by_NID(key, NID_ms_csp_name,
				MBSTRING_ASC, (unsigned char *)csp_name, -1);
d586 2
a587 2
	if (add_lmk && key)
		EVP_PKEY_add1_attr_by_NID(key, NID_LocalKeySet, 0, NULL, -1);
d590 2
a591 2
	CRYPTO_pop_info();
	CRYPTO_push_info("reading password");
d594 7
a600 7
	if(!noprompt &&
		EVP_read_pw_string(pass, sizeof pass, "Enter Export Password:", 1))
		{
	    	BIO_printf (bio_err, "Can't read Password\n");
	    	goto export_end;
        	}
	if (!twopass) BUF_strlcpy(macpass, pass, sizeof macpass);
d603 2
a604 2
	CRYPTO_pop_info();
	CRYPTO_push_info("creating PKCS#12 structure");
d607 2
a608 2
	p12 = PKCS12_create(cpass, name, key, ucert, certs,
				key_pbe, cert_pbe, iter, -1, keytype);
d610 3
a612 4
	if (!p12)
		{
	    	ERR_print_errors (bio_err);
		goto export_end;
d614 5
a618 8

	if (macalg)
		{
		macmd = EVP_get_digestbyname(macalg);
		if (!macmd)
			{
			BIO_printf(bio_err, "Unknown digest algorithm %s\n", 
						macalg);
d621 2
a622 3

	if (maciter != -1)
		PKCS12_set_mac(p12, mpass, -1, NULL, 0, maciter, macmd);
d625 2
a626 2
	CRYPTO_pop_info();
	CRYPTO_push_info("writing pkcs12");
d629 1
a629 1
	i2d_PKCS12_bio(out, p12);
d631 1
a631 1
	ret = 0;
d633 1
a633 1
    export_end:
d635 3
a637 3
	CRYPTO_pop_info();
	CRYPTO_pop_info();
	CRYPTO_push_info("process -export_cert: freeing");
d640 6
a645 3
	if (key) EVP_PKEY_free(key);
	if (certs) sk_X509_pop_free(certs, X509_free);
	if (ucert) X509_free(ucert);
d648 1
a648 1
	CRYPTO_pop_info();
d650 1
a650 8
	goto end;
	
    }

    if (!(p12 = d2i_PKCS12_bio (in, NULL))) {
	ERR_print_errors(bio_err);
	goto end;
    }
d652 5
d658 1
a658 1
    CRYPTO_push_info("read import password");
d660 4
a663 4
    if(!noprompt && EVP_read_pw_string(pass, sizeof pass, "Enter Import Password:", 0)) {
	BIO_printf (bio_err, "Can't read Password\n");
	goto end;
    }
d665 1
a665 1
    CRYPTO_pop_info();
d668 2
a669 1
    if (!twopass) BUF_strlcpy(macpass, pass, sizeof macpass);
d671 17
a687 2
    if ((options & INFO) && p12->mac) BIO_printf (bio_err, "MAC Iteration %ld\n", p12->mac->iter ? ASN1_INTEGER_get (p12->mac->iter) : 1);
    if(macver) {
d689 1
a689 1
    CRYPTO_push_info("verify MAC");
a690 8
	/* If we enter empty password try no password first */
	if(!mpass[0] && PKCS12_verify_mac(p12, NULL, 0)) {
		/* If mac and crypto pass the same set it to NULL too */
		if(!twopass) cpass = NULL;
	} else if (!PKCS12_verify_mac(p12, mpass, -1)) {
	    BIO_printf (bio_err, "Mac verify error: invalid password?\n");
	    ERR_print_errors (bio_err);
	    goto end;
a691 1
	BIO_printf (bio_err, "MAC verified OK\n");
d693 1
a693 1
    CRYPTO_pop_info();
d695 5
a699 2
    }

d701 1
a701 1
    CRYPTO_push_info("output keys and certificates");
d703 19
a721 22
    if (!dump_certs_keys_p12 (out, p12, cpass, -1, options, passout)) {
	BIO_printf(bio_err, "Error outputting keys and certificates\n");
	ERR_print_errors (bio_err);
	goto end;
    }
#ifdef CRYPTO_MDEBUG
    CRYPTO_pop_info();
#endif
    ret = 0;
 end:
    if (p12) PKCS12_free(p12);
    if(export_cert || inrand) app_RAND_write_file(NULL, bio_err);
#ifdef CRYPTO_MDEBUG
    CRYPTO_remove_all_info();
#endif
    BIO_free(in);
    BIO_free_all(out);
    if (canames) sk_OPENSSL_STRING_free(canames);
    if(passin) free(passin);
    if(passout) free(passout);
    apps_shutdown();
    return(ret);
d724 3
a726 2
int dump_certs_keys_p12 (BIO *out, PKCS12 *p12, char *pass,
	     int passlen, int options, char *pempass)
d728 2
a729 2
	STACK_OF(PKCS7) *asafes = NULL;
	STACK_OF(PKCS12_SAFEBAG) *bags;
d734 5
a738 4
	if (!( asafes = PKCS12_unpack_authsafes(p12))) return 0;
	for (i = 0; i < sk_PKCS7_num (asafes); i++) {
		p7 = sk_PKCS7_value (asafes, i);
		bagnid = OBJ_obj2nid (p7->type);
d741 2
a742 1
			if (options & INFO) BIO_printf (bio_err, "PKCS7 Data\n");
d746 2
a747 2
				alg_print(bio_err, 
					p7->d.encrypted->enc_data->algorithm);
d750 7
a756 5
		} else continue;
		if (!bags) goto err;
	    	if (!dump_certs_pkeys_bags (out, bags, pass, passlen, 
						 options, pempass)) {
			sk_PKCS12_SAFEBAG_pop_free (bags, PKCS12_SAFEBAG_free);
d759 1
a759 1
		sk_PKCS12_SAFEBAG_pop_free (bags, PKCS12_SAFEBAG_free);
d764 1
a764 1
	err:
d767 1
a767 1
		sk_PKCS7_pop_free (asafes, PKCS7_free);
d771 3
a773 2
int dump_certs_pkeys_bags (BIO *out, STACK_OF(PKCS12_SAFEBAG) *bags,
			   char *pass, int passlen, int options, char *pempass)
d776 6
a781 6
	for (i = 0; i < sk_PKCS12_SAFEBAG_num (bags); i++) {
		if (!dump_certs_pkeys_bag (out,
					   sk_PKCS12_SAFEBAG_value (bags, i),
					   pass, passlen,
					   options, pempass))
		    return 0;
d786 3
a788 2
int dump_certs_pkeys_bag (BIO *out, PKCS12_SAFEBAG *bag, char *pass,
	     int passlen, int options, char *pempass)
d793 2
a794 3
	
	switch (M_PKCS12_bag_type(bag))
	{
d796 5
a800 3
		if (options & INFO) BIO_printf (bio_err, "Key bag\n");
		if (options & NOKEYS) return 1;
		print_attribs (out, bag->attrib, "Bag Attributes");
d802 4
a805 3
		if (!(pkey = EVP_PKCS82PKEY (p8))) return 0;
		print_attribs (out, p8->attributes, "Key Attributes");
		PEM_write_bio_PrivateKey (out, pkey, enc, NULL, 0, NULL, pempass);
d807 1
a807 1
	break;
d811 2
a812 2
			BIO_printf (bio_err, "Shrouded Keybag: ");
			alg_print (bio_err, bag->value.shkeybag->algor);
d814 3
a816 2
		if (options & NOKEYS) return 1;
		print_attribs (out, bag->attrib, "Bag Attributes");
d818 2
a819 2
				return 0;
		if (!(pkey = EVP_PKCS82PKEY (p8))) {
d823 1
a823 1
		print_attribs (out, p8->attributes, "Key Attributes");
d825 1
a825 1
		PEM_write_bio_PrivateKey (out, pkey, enc, NULL, 0, NULL, pempass);
d827 1
a827 1
	break;
d830 16
a845 11
		if (options & INFO) BIO_printf (bio_err, "Certificate bag\n");
		if (options & NOCERTS) return 1;
                if (PKCS12_get_attr(bag, NID_localKeyID)) {
			if (options & CACERTS) return 1;
		} else if (options & CLCERTS) return 1;
		print_attribs (out, bag->attrib, "Bag Attributes");
		if (M_PKCS12_cert_bag_type(bag) != NID_x509Certificate )
								 return 1;
		if (!(x509 = PKCS12_certbag2x509(bag))) return 0;
		dump_cert_text (out, x509);
		PEM_write_bio_X509 (out, x509);
d847 1
a847 1
	break;
d850 6
a855 5
		if (options & INFO) BIO_printf (bio_err, "Safe Contents bag\n");
		print_attribs (out, bag->attrib, "Bag Attributes");
		return dump_certs_pkeys_bags (out, bag->value.safes, pass,
							    passlen, options, pempass);
					
d857 3
a859 3
		BIO_printf (bio_err, "Warning unsupported bag type: ");
		i2a_ASN1_OBJECT (bio_err, bag->type);
		BIO_printf (bio_err, "\n");
d861 1
a861 1
	break;
d870 2
a871 1
int get_cert_chain (X509 *cert, X509_STORE *store, STACK_OF(X509) **chain)
d874 1
a874 1
	STACK_OF(X509) *chn;
d877 5
a881 3
	/* FIXME: Should really check the return status of X509_STORE_CTX_init
	 * for an error, but how that fits into the return value of this
	 * function is less obvious. */
d884 1
a884 1
		i = X509_STORE_CTX_get_error (&store_ctx);
d886 4
a889 2
			/* avoid returning 0 if X509_verify_cert() did not
			 * set an appropriate error value in the context */
d898 1
a898 1
	
d900 1
a900 1
}	
d902 2
a903 1
int alg_print (BIO *x, X509_ALGOR *alg)
d911 4
a914 4
	BIO_printf (bio_err, "%s, Iteration %ld\n", 
		OBJ_nid2ln(OBJ_obj2nid(alg->algorithm)),
		ASN1_INTEGER_get(pbe->iter));
	PBEPARAM_free (pbe);
d920 2
a921 1
int cert_load(BIO *in, STACK_OF(X509) *sk)
d929 1
a929 1
	while((cert = PEM_read_bio_X509(in, NULL, NULL, NULL))) {
d942 2
a943 1
	if(ret) ERR_clear_error();
d949 2
a950 1
int print_attribs (BIO *out, STACK_OF(X509_ATTRIBUTE) *attrlst,const char *name)
d956 1
a956 1
	if(!attrlst) {
d960 1
a960 1
	if(!sk_X509_ATTRIBUTE_num(attrlst)) {
d965 1
a965 1
	for(i = 0; i < sk_X509_ATTRIBUTE_num(attrlst); i++) {
d969 2
a970 2
		if(attr_nid == NID_undef) {
			i2a_ASN1_OBJECT (out, attr->object);
d972 2
a973 1
		} else BIO_printf(out, "%s: ", OBJ_nid2ln(attr_nid));
d975 1
a975 1
		if(sk_ASN1_TYPE_num(attr->value.set)) {
d977 4
a980 4
			switch(av->type) {
				case V_ASN1_BMPSTRING:
        			value = OPENSSL_uni2asc(av->value.bmpstring->data,
                                	       av->value.bmpstring->length);
d985 1
a985 1
				case V_ASN1_OCTET_STRING:
d987 2
a988 2
					av->value.octet_string->length);
				BIO_printf(out, "\n");	
d991 1
a991 1
				case V_ASN1_BIT_STRING:
d993 2
a994 2
					av->value.bit_string->length);
				BIO_printf(out, "\n");	
d997 2
a998 2
				default:
					BIO_printf(out, "<Unsupported tag %d>\n", av->type);
d1001 2
a1002 1
		} else BIO_printf(out, "<No Values>\n");
d1007 2
a1008 1
void hex_prin(BIO *out, unsigned char *buf, int len)
d1011 2
a1012 1
	for (i = 0; i < len; i++) BIO_printf (out, "%02X ", buf[i]);
d1015 3
a1017 2
static int set_pbe(BIO *err, int *ppbe, const char *str)
	{
d1020 1
a1020 2
	if (!strcmp(str, "NONE"))
		{
d1023 3
a1025 4
		}
	*ppbe=OBJ_txt2nid(str);
	if (*ppbe == NID_undef)
		{
d1028 1
a1028 1
		}
d1030 2
a1031 2
	}
			
@


1.20
log
@oops, exit vs return; spotted by matthew
@
text
@a132 5
#ifdef OPENSSL_FIPS
    if (FIPS_mode())
	cert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
    else
#endif
@


1.19
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d695 1
a695 1
    exit(ret);
@


1.18
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d338 1
a338 1
	BIO_printf(bio_err,  "-rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
d695 1
a695 1
    OPENSSL_EXIT(ret);
@


1.17
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d692 2
a693 2
    if(passin) OPENSSL_free(passin);
    if(passout) OPENSSL_free(passout);
d930 1
a930 1
				OPENSSL_free(value);
@


1.16
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a400 6
#ifdef OPENSSL_SYS_VMS
	{
	    BIO *tmpbio = BIO_new(BIO_f_linebuffer());
	    out = BIO_push(tmpbio, out);
	}
#endif
@


1.15
log
@openssl-1.0.0e: resolve conflicts
@
text
@d115 1
a115 1
    int cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;
d132 7
@


1.14
log
@resolve conflicts, fix local changes
@
text
@d650 1
a650 1
    if (options & INFO) BIO_printf (bio_err, "MAC Iteration %ld\n", p12->mac->iter ? ASN1_INTEGER_get (p12->mac->iter) : 1);
@


1.13
log
@resolve conflicts
@
text
@d91 1
d115 1
a115 1
    int cert_pbe;
d120 1
a120 1
    STACK *canames = NULL;
d125 1
a132 7
#ifdef OPENSSL_FIPS
    if (FIPS_mode())
	cert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
    else
#endif
    cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;

d183 5
d190 2
a191 12
			if (args[1]) {
				args++;
				if (!strcmp(*args, "NONE"))
					cert_pbe = -1;
				else
					cert_pbe=OBJ_txt2nid(*args);
				if(cert_pbe == NID_undef) {
					BIO_printf(bio_err,
						 "Unknown PBE algorithm %s\n", *args);
					badarg = 1;
				}
			} else badarg = 1;
d193 2
a194 12
			if (args[1]) {
				args++;
				if (!strcmp(*args, "NONE"))
					key_pbe = -1;
				else
					key_pbe=OBJ_txt2nid(*args);
				if(key_pbe == NID_undef) {
					BIO_printf(bio_err,
						 "Unknown PBE algorithm %s\n", *args);
					badarg = 1;
				}
			} else badarg = 1;
d225 2
a226 2
			if (!canames) canames = sk_new_null();
			sk_push(canames, *args);
d315 1
d317 1
d322 1
d334 2
a335 2
  	BIO_printf(bio_err,  "-CSP name     Microsoft CSP name\n");
 	BIO_printf(bio_err,  "-LMK          Add local machine keyset attribute to private key\n");
d425 1
d552 1
a552 1
	for (i = 0; i < sk_num(canames); i++)
d554 1
a554 1
		catmp = (unsigned char *)sk_value(canames, i);
d592 10
d603 1
a603 1
		PKCS12_set_mac(p12, mpass, -1, NULL, 0, maciter, NULL);
d690 1
a690 1
    if (canames) sk_free(canames);
d926 1
a926 1
        			value = uni2asc(av->value.bmpstring->data,
d959 18
@


1.12
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
d114 1
a114 1
    int cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;
d130 7
@


1.11
log
@resolve conflicts
@
text
@d103 1
d228 3
a230 1
		} else if (!strcmp (*args, "-CSP")) {
d344 2
d570 3
a572 1
		
@


1.10
log
@resolve conflicts
@
text
@a1 2
#if !defined(OPENSSL_NO_DES) && !defined(OPENSSL_NO_SHA1)

d3 1
a3 1
 * project 1999.
d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d59 3
d87 1
a87 1
int print_attribs(BIO *out, STACK_OF(X509_ATTRIBUTE) *attrlst, char *name);
d113 1
a113 1
    int cert_pbe;
a129 7
#ifdef OPENSSL_FIPS
    if (FIPS_mode())
	cert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
    else
#endif
    cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;

d156 1
d160 3
a162 1
		else if (!strcmp (*args, "-des3")) enc = EVP_des_ede3_cbc();
d168 5
d178 2
d184 4
a187 1
				cert_pbe=OBJ_txt2nid(*args);
d197 4
a200 1
				key_pbe=OBJ_txt2nid(*args);
d312 3
d319 4
a391 18
#if 0
   if (certfile) {
    	if(!(certsin = BIO_new_file(certfile, "r"))) {
	    BIO_printf(bio_err, "Can't open certificate file %s\n", certfile);
	    perror (certfile);
	    goto end;
	}
    }

    if (keyname) {
    	if(!(inkey = BIO_new_file(keyname, "r"))) {
	    BIO_printf(bio_err, "Can't key certificate file %s\n", keyname);
	    perror (keyname);
	    goto end;
	}
     }
#endif

d428 1
a428 6
	STACK_OF(PKCS12_SAFEBAG) *bags = NULL;
	STACK_OF(PKCS7) *safes = NULL;
	PKCS12_SAFEBAG *bag = NULL;
	PKCS8_PRIV_KEY_INFO *p8 = NULL;
	PKCS7 *authsafe = NULL;
	X509 *ucert = NULL;
d430 1
a430 1
	char *catmp = NULL;
d432 9
a440 2
	unsigned char keyid[EVP_MAX_MD_SIZE];
	unsigned int keyidlen = 0;
d446 7
a452 5
	key = load_key(bio_err, keyname ? keyname : infile, FORMAT_PEM, 1,
		passin, e, "private key");
	if (!key) {
		goto export_end;
	}
d460 6
a465 4
	if(!(certs = load_certs(bio_err, infile, FORMAT_PEM, NULL, e,
		"certificates"))) {
		goto export_end;
	}
d467 23
a489 4
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("reading certs from input 2");
#endif
a490 5
	for(i = 0; i < sk_X509_num(certs); i++) {
		ucert = sk_X509_value(certs, i);
		if(X509_check_private_key(ucert, key)) {
			X509_digest(ucert, EVP_sha1(), keyid, &keyidlen);
			break;
d492 1
a492 7
	}
	if(!keyidlen) {
		ucert = NULL;
		BIO_printf(bio_err, "No certificate matches private key\n");
		goto export_end;
	}
	
d495 1
a495 1
	CRYPTO_push_info("reading certs from certfile");
a497 2
	bags = sk_PKCS12_SAFEBAG_new_null ();

d499 2
a500 1
	if (certfile) {
d504 1
a504 1
					    "certificates from certfile"))) {
d506 1
a506 2
		}
		while(sk_X509_num(morecerts) > 0) {
a507 1
		}
d509 6
a514 1
 	}
d545 2
a546 1
			BIO_printf (bio_err, "Error %s getting chain.\n",
d548 2
d554 7
a560 4
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("building bags");
#endif
d562 4
a565 15
	/* We now have loads of certificates: include them all */
	for(i = 0; i < sk_X509_num(certs); i++) {
		X509 *cert = NULL;
		cert = sk_X509_value(certs, i);
		bag = PKCS12_x5092certbag(cert);
		/* If it matches private key set id */
		if(cert == ucert) {
			if(name) PKCS12_add_friendlyname(bag, name, -1);
			PKCS12_add_localkeyid(bag, keyid, keyidlen);
		} else if((catmp = sk_shift(canames))) 
				PKCS12_add_friendlyname(bag, catmp, -1);
		sk_PKCS12_SAFEBAG_push(bags, bag);
	}
	sk_X509_pop_free(certs, X509_free);
	certs = NULL;
d569 1
a569 1
	CRYPTO_push_info("encrypting bags");
d573 5
a577 4
		EVP_read_pw_string(pass, sizeof pass, "Enter Export Password:", 1)) {
	    BIO_printf (bio_err, "Can't read Password\n");
	    goto export_end;
        }
a578 13
	/* Turn certbags into encrypted authsafe */
	authsafe = PKCS12_pack_p7encdata(cert_pbe, cpass, -1, NULL, 0,
								 iter, bags);
	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	bags = NULL;

	if (!authsafe) {
		ERR_print_errors (bio_err);
		goto export_end;
	}

	safes = sk_PKCS7_new_null ();
	sk_PKCS7_push (safes, authsafe);
d582 1
a582 1
	CRYPTO_push_info("building shrouded key bag");
d585 2
a586 11
	/* Make a shrouded key bag */
	p8 = EVP_PKEY2PKCS8 (key);
	if(keytype) PKCS8_add_keyusage(p8, keytype);
	bag = PKCS12_MAKE_SHKEYBAG(key_pbe, cpass, -1, NULL, 0, iter, p8);
	PKCS8_PRIV_KEY_INFO_free(p8);
	p8 = NULL;
        if (name) PKCS12_add_friendlyname (bag, name, -1);
	if(csp_name) PKCS12_add_CSPName_asc(bag, csp_name, -1);
	PKCS12_add_localkeyid (bag, keyid, keyidlen);
	bags = sk_PKCS12_SAFEBAG_new_null();
	sk_PKCS12_SAFEBAG_push (bags, bag);
d588 5
a592 19
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("encrypting shrouded key bag");
#endif

	/* Turn it into unencrypted safe bag */
	authsafe = PKCS12_pack_p7data (bags);
	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	bags = NULL;
	sk_PKCS7_push (safes, authsafe);

#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("building pkcs12");
#endif

	p12 = PKCS12_init(NID_pkcs7_data);

	PKCS12_pack_authsafes(p12, safes);
d594 2
a595 4
	sk_PKCS7_pop_free(safes, PKCS7_free);
	safes = NULL;

	PKCS12_set_mac (p12, mpass, -1, NULL, 0, maciter, NULL);
d602 1
a602 1
	i2d_PKCS12_bio (out, p12);
d615 1
a615 2
	if (safes) sk_PKCS7_pop_free(safes, PKCS7_free);
	if (bags) sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
d823 1
a823 1
	int i;
d831 5
d837 2
a838 4
	}
	chn =  X509_STORE_CTX_get1_chain(&store_ctx);
	i = 0;
	*chain = chn;
d841 1
d849 1
a849 1
	unsigned char *p;
d851 6
a856 3
	pbe = d2i_PBEPARAM (NULL, &p, alg->parameter->value.sequence->length);
	BIO_printf (bio_err, "%s, Iteration %d\n", 
	OBJ_nid2ln(OBJ_obj2nid(alg->algorithm)), ASN1_INTEGER_get(pbe->iter));
d858 1
a858 1
	return 0;
d890 1
a890 1
int print_attribs (BIO *out, STACK_OF(X509_ATTRIBUTE) *attrlst, char *name)
@


1.9
log
@merge 0.9.7d
@
text
@d112 1
a112 1
    int cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;
d129 7
d676 1
a676 1
	if(!macpass[0] && PKCS12_verify_mac(p12, NULL, 0)) {
d720 1
a720 1
	STACK_OF(PKCS7) *asafes;
d723 1
d741 1
a741 1
		if (!bags) return 0;
d745 1
a745 1
			return 0;
d748 1
d750 7
a756 2
	sk_PKCS7_pop_free (asafes, PKCS7_free);
	return 1;
@


1.8
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d560 1
a560 1
	if (!twopass) strlcpy(macpass, pass, sizeof macpass);
d661 1
a661 1
    if (!twopass) strlcpy(macpass, pass, sizeof macpass);
@


1.7
log
@more strcpy & sprintf murder; ho ok
@
text
@d123 1
d125 1
d257 1
d263 1
d311 1
d313 1
d320 1
d322 1
d410 1
a410 1
	if(EVP_read_pw_string (macpass, 50, "Enter MAC Password:", export_cert))
d556 1
a556 1
		EVP_read_pw_string(pass, 50, "Enter Export Password:", 1)) {
d653 1
a653 1
    if(!noprompt && EVP_read_pw_string(pass, 50, "Enter Import Password:", 0)) {
d707 1
a707 1
    EXIT(ret);
@


1.6
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d552 1
a552 1
	if (!twopass) strcpy(macpass, pass);
d653 1
a653 1
    if (!twopass) strcpy(macpass, pass);
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d430 1
a430 1
	key = load_key(bio_err, keyname ? keyname : infile, FORMAT_PEM,
d511 4
a514 3
		}
		sk_X509_free(chain2);
		if (vret) {
a540 2
	/* ucert is part of certs so it is already freed */
	ucert = NULL;
a628 1
	if (ucert) X509_free(ucert);
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d2 1
a2 1
#if !defined(NO_DES) && !defined(NO_SHA1)
a68 1
#include <openssl/engine.h>
d72 1
a72 1
EVP_CIPHER *enc;
d98 1
a98 1
    BIO *in=NULL, *out = NULL, *inkey = NULL, *certsin = NULL;
d101 1
d130 3
d153 1
a153 1
#ifndef NO_IDEA
d157 5
d208 5
d288 1
a288 1
#ifndef NO_IDEA
d291 4
d314 1
a314 13
    if (engine != NULL) {
	if((e = ENGINE_by_id(engine)) == NULL) {
	    BIO_printf(bio_err,"invalid engine \"%s\"\n", engine);
	    goto end;
	}
	if(!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
	    BIO_printf(bio_err,"can't use that engine\n");
	    goto end;
	}
	BIO_printf(bio_err,"engine \"%s\" set.\n", engine);
	/* Free our "structural" reference. */
	ENGINE_free(e);
    }
d360 1
d376 1
d385 1
a385 1
#ifdef VMS
d430 2
a431 3
	key = PEM_read_bio_PrivateKey(inkey ? inkey : in, NULL, NULL, passin);
	if (!inkey) (void) BIO_reset(in);
	else BIO_free(inkey);
a432 2
		BIO_printf (bio_err, "Error loading private key\n");
		ERR_print_errors(bio_err);
a440 2
	certs = sk_X509_new_null();

d442 2
a443 3
	if(!cert_load(in, certs)) {
		BIO_printf(bio_err, "Error loading certificates from input\n");
		ERR_print_errors(bio_err);
d473 5
a477 4
	if (certsin) {
		if(!cert_load(certsin, certs)) {
			BIO_printf(bio_err, "Error loading certificates from certfile\n");
			ERR_print_errors(bio_err);
d480 4
a483 1
	    	BIO_free(certsin);
d529 1
a529 1
		bag = M_PKCS12_x5092certbag(cert);
d580 1
d601 1
a601 1
	p12 = PKCS12_init (NID_pkcs7_data);
d603 1
a603 1
	M_PKCS12_pack_authsafes (p12, safes);
d700 1
d712 1
a712 1
	if (!( asafes = M_PKCS12_unpack_authsafes (p12))) return 0;
d717 1
a717 1
			bags = M_PKCS12_unpack_p7data (p7);
d721 2
a722 2
				BIO_printf (bio_err, "PKCS7 Encrypted data: ");
				alg_print (bio_err, 
d725 1
a725 1
			bags = M_PKCS12_unpack_p7encdata (p7, pass, passlen);
d780 1
a780 1
		if (!(p8 = M_PKCS12_decrypt_skey (bag, pass, passlen)))
d782 4
a785 1
		if (!(pkey = EVP_PKCS82PKEY (p8))) return 0;
d801 1
a801 1
		if (!(x509 = M_PKCS12_certbag2x509(bag))) return 0;
d833 3
@


1.3
log
@OpenSSL 0.9.5a merge
@
text
@d69 1
d82 1
a82 1
int get_cert_chain(X509 *cert, STACK_OF(X509) **chain);
d84 2
a85 1
int dump_certs_pkeys_bags(BIO *out, STACK *bags, char *pass, int passlen, int options, char *pempass);
d96 1
d122 2
d203 1
a203 1
			if (!canames) canames = sk_new(NULL);
d232 15
d260 2
d290 1
d297 14
d376 9
a384 2
    if (!outfile) out = BIO_new_fp(stdout, BIO_NOCLOSE);
    else out = BIO_new_file(outfile, "wb");
d406 6
a411 5
	EVP_PKEY *key;
	STACK *bags, *safes;
	PKCS12_SAFEBAG *bag;
	PKCS8_PRIV_KEY_INFO *p8;
	PKCS7 *authsafe;
d414 1
a414 1
	char *catmp;
d421 1
d429 1
a429 1
		goto end;
d432 6
a437 1
	certs = sk_X509_new(NULL);
d443 1
a443 1
		goto end;
d446 5
a457 1

d459 1
d461 1
a461 1
		goto end;
d464 6
a469 1
	bags = sk_new (NULL);
d476 1
a476 1
			goto end;
d481 5
d490 18
a507 1
		vret = get_cert_chain (ucert, &chain2);
d511 2
a512 7
			goto end;
		}
		/* Exclude verified certificate */
		for (i = 1; i < sk_X509_num (chain2) ; i++) 
				 sk_X509_push(certs, sk_X509_value (chain2, i));
		sk_X509_free(chain2);
			
d515 5
d531 1
a531 1
		sk_push(bags, (char *)bag);
d534 8
a541 1
	if (canames) sk_free(canames);
d546 1
a546 1
	    goto end;
d552 2
a553 1
	sk_pop_free(bags, PKCS12_SAFEBAG_free);
d557 1
a557 1
		goto end;
d560 7
a566 2
	safes = sk_new (NULL);
	sk_push (safes, (char *)authsafe);
a569 1
	EVP_PKEY_free(key);
d573 1
d576 8
a583 2
	bags = sk_new(NULL);
	sk_push (bags, (char *)bag);
d586 8
a593 2
	sk_pop_free(bags, PKCS12_SAFEBAG_free);
	sk_push (safes, (char *)authsafe);
d599 2
a600 1
	sk_pop_free(safes, PKCS7_free);
d604 5
d611 8
a618 1
	PKCS12_free(p12);
d620 5
a624 1
	ret = 0;
d656 5
a660 1
	if (!PKCS12_verify_mac (p12, mpass, -1)) {
d664 2
a665 1
	} else BIO_printf (bio_err, "MAC verified OK\n");
a681 1
    PKCS12_free(p12);
d683 2
a684 1
    end:
d690 4
a693 3
    BIO_free(out);
    if(passin) Free(passin);
    if(passout) Free(passout);
d700 2
a701 1
	STACK *asafes, *bags;
d704 1
d706 2
a707 2
	for (i = 0; i < sk_num (asafes); i++) {
		p7 = (PKCS7 *) sk_value (asafes, i);
d723 1
a723 1
			sk_pop_free (bags, PKCS12_SAFEBAG_free);
d726 1
a726 1
		sk_pop_free (bags, PKCS12_SAFEBAG_free);
d728 1
a728 1
	sk_pop_free (asafes, PKCS7_free);
d732 2
a733 2
int dump_certs_pkeys_bags (BIO *out, STACK *bags, char *pass,
	     int passlen, int options, char *pempass)
d736 1
a736 1
	for (i = 0; i < sk_num (bags); i++) {
d738 4
a741 2
			 (PKCS12_SAFEBAG *)sk_value (bags, i), pass, passlen,
					 	options, pempass)) return 0;
d817 1
a817 1
int get_cert_chain (X509 *cert, STACK_OF(X509) **chain)
a818 1
	X509_STORE *store;
a822 2
	store = X509_STORE_new ();
	X509_STORE_set_default_paths (store);
a832 1
	X509_STORE_free(store);
d856 3
d860 3
d865 3
d869 3
d909 1
a909 1
				Free(value);
d913 2
a914 2
				hex_prin(out, av->value.bit_string->data,
					av->value.bit_string->length);
d919 2
a920 2
				hex_prin(out, av->value.octet_string->data,
					av->value.octet_string->length);
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d268 1
a268 1
	BIO_printf(bio_err,  "-rand file:file:...\n");
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d64 3
a66 1
#include <openssl/des.h>
a67 1
#include <openssl/err.h>
a69 1
#include "apps.h"
d82 3
a84 4
int dump_cert_text (BIO *out, X509 *x);
int dump_certs_keys_p12(BIO *out, PKCS12 *p12, char *pass, int passlen, int options);
int dump_certs_pkeys_bags(BIO *out, STACK *bags, char *pass, int passlen, int options);
int dump_certs_pkeys_bag(BIO *out, PKCS12_SAFEBAG *bags, char *pass, int passlen, int options);
d89 3
d106 1
a106 1
    int maciter = 1;
d110 1
d116 3
d152 2
d155 26
a180 1
		else if (!strcmp (*args, "-inkey")) {
d211 6
a216 1
		} else if (!strcmp (*args, "-envpass")) {
d219 1
a219 6
			if(!(cpass = getenv(*args))) {
				BIO_printf(bio_err,
				 "Can't read environment variable %s\n", *args);
				goto end;
			}
			noprompt = 1;
d224 1
a224 1
			cpass = *args;
d261 2
d265 6
a270 2
	BIO_printf (bio_err, "-password p   set import/export password (NOT RECOMMENDED)\n");
	BIO_printf (bio_err, "-envpass p    set import/export password from environment\n");
d274 19
a292 2
    if(cpass) mpass = cpass;
    else {
d297 6
d305 4
d334 5
d348 3
d356 3
d361 1
a361 1
if (export_cert) {
d367 2
a368 2
	X509 *cert = NULL, *ucert = NULL;
	STACK_OF(X509) *certs;
d373 5
a377 1
	key = PEM_read_bio_PrivateKey(inkey ? inkey : in, NULL, NULL, NULL);
d379 1
d398 1
a398 1
			X509_digest(cert, EVP_sha1(), keyid, &keyidlen);
d439 1
d450 1
a450 1

d476 1
a476 2
	bag = PKCS12_MAKE_SHKEYBAG(NID_pbe_WithSHA1And3_Key_TripleDES_CBC,
			cpass, -1, NULL, 0, iter, p8);
d500 4
d513 3
d520 3
d528 3
d532 1
a532 1
	    BIO_printf (bio_err, "Mac verify errror: invalid password?\n");
d536 3
d541 4
a544 1
    if (!dump_certs_keys_p12 (out, p12, cpass, -1, options)) {
d549 3
d555 5
d561 2
a565 14
int dump_cert_text (BIO *out, X509 *x)
{
	char buf[256];
	X509_NAME_oneline(X509_get_subject_name(x),buf,256);
	BIO_puts(out,"subject=");
	BIO_puts(out,buf);

	X509_NAME_oneline(X509_get_issuer_name(x),buf,256);
	BIO_puts(out,"\nissuer= ");
	BIO_puts(out,buf);
	BIO_puts(out,"\n");
        return 0;
}

d567 1
a567 1
	     int passlen, int options)
d589 1
a589 1
							 options)) {
d600 1
a600 1
	     int passlen, int options)
d606 1
a606 1
					 		options)) return 0;
d612 1
a612 1
	     int passlen, int options)
d627 1
a627 1
		PEM_write_bio_PrivateKey (out, pkey, enc, NULL, 0, NULL, NULL);
d643 1
a643 1
		PEM_write_bio_PrivateKey (out, pkey, enc, NULL, 0, NULL, NULL);
d666 1
a666 1
							    passlen, options);
d688 1
a688 1
	X509 *x;
d696 1
a696 5
	chn =  sk_X509_dup(X509_STORE_CTX_get_chain (&store_ctx));
	for (i = 0; i < sk_X509_num(chn); i++) {
		x = sk_X509_value(chn, i);
		CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
	}
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d2 1
a2 1
#if !defined(OPENSSL_NO_DES) && !defined(OPENSSL_NO_SHA1)
d64 2
a65 2
#include "apps.h"
#include <openssl/crypto.h>
a66 1
#include <openssl/pem.h>
d69 1
d72 1
a72 1
const EVP_CIPHER *enc;
d81 5
a85 5
int get_cert_chain (X509 *cert, X509_STORE *store, STACK_OF(X509) **chain);
int dump_certs_keys_p12(BIO *out, PKCS12 *p12, char *pass, int passlen, int options, char *pempass);
int dump_certs_pkeys_bags(BIO *out, STACK_OF(PKCS12_SAFEBAG) *bags, char *pass,
			  int passlen, int options, char *pempass);
int dump_certs_pkeys_bag(BIO *out, PKCS12_SAFEBAG *bags, char *pass, int passlen, int options, char *pempass);
a89 3

int MAIN(int, char **);

a91 1
    ENGINE *e = NULL;
d94 1
a94 1
    BIO *in=NULL, *out = NULL;
a96 1
    char *csp_name = NULL;
d104 1
a104 1
    int maciter = PKCS12_DEFAULT_ITER;
a107 1
    int key_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
a112 5
    char *passargin = NULL, *passargout = NULL, *passarg = NULL;
    char *passin = NULL, *passout = NULL;
    char *inrand = NULL;
    char *CApath = NULL, *CAfile = NULL;
    char *engine=NULL;
a118 3
	if (!load_config(bio_err, NULL))
		goto end;

d139 1
a139 1
#ifndef OPENSSL_NO_IDEA
a142 5
#ifndef OPENSSL_NO_AES
		else if (!strcmp(*args,"-aes128")) enc=EVP_aes_128_cbc();
		else if (!strcmp(*args,"-aes192")) enc=EVP_aes_192_cbc();
		else if (!strcmp(*args,"-aes256")) enc=EVP_aes_256_cbc();
#endif
a145 2
		else if (!strcmp (*args, "-nomaciter"))
					 maciter = 1;
d147 1
a147 26
		else if (!strcmp (*args, "-certpbe")) {
			if (args[1]) {
				args++;
				cert_pbe=OBJ_txt2nid(*args);
				if(cert_pbe == NID_undef) {
					BIO_printf(bio_err,
						 "Unknown PBE algorithm %s\n", *args);
					badarg = 1;
				}
			} else badarg = 1;
		} else if (!strcmp (*args, "-keypbe")) {
			if (args[1]) {
				args++;
				key_pbe=OBJ_txt2nid(*args);
				if(key_pbe == NID_undef) {
					BIO_printf(bio_err,
						 "Unknown PBE algorithm %s\n", *args);
					badarg = 1;
				}
			} else badarg = 1;
		} else if (!strcmp (*args, "-rand")) {
		    if (args[1]) {
			args++;	
			inrand = *args;
		    } else badarg = 1;
		} else if (!strcmp (*args, "-inkey")) {
a161 5
		} else if (!strcmp (*args, "-CSP")) {
		    if (args[1]) {
			args++;	
			csp_name = *args;
		    } else badarg = 1;
d165 1
a165 1
			if (!canames) canames = sk_new_null();
d178 1
a178 1
		} else if (!strcmp(*args,"-passin")) {
d181 6
a186 6
			passargin = *args;
		    } else badarg = 1;
		} else if (!strcmp(*args,"-passout")) {
		    if (args[1]) {
			args++;	
			passargout = *args;
d191 1
a191 1
			passarg = *args;
a193 15
		} else if (!strcmp(*args,"-CApath")) {
		    if (args[1]) {
			args++;	
			CApath = *args;
		    } else badarg = 1;
		} else if (!strcmp(*args,"-CAfile")) {
		    if (args[1]) {
			args++;	
			CAfile = *args;
		    } else badarg = 1;
		} else if (!strcmp(*args,"-engine")) {
		    if (args[1]) {
			args++;	
			engine = *args;
		    } else badarg = 1;
a206 2
	BIO_printf (bio_err, "-CApath arg   - PEM format directory of CA's\n");
	BIO_printf (bio_err, "-CAfile arg   - PEM format file of CA's\n");
d220 1
a220 1
#ifndef OPENSSL_NO_IDEA
a222 4
#ifndef OPENSSL_NO_AES
	BIO_printf (bio_err, "-aes128, -aes192, -aes256\n");
	BIO_printf (bio_err, "              encrypt PEM output with cbc aes\n");
#endif
a227 2
	BIO_printf (bio_err, "-certpbe alg  specify certificate PBE algorithm (default RC2-40)\n");
	BIO_printf (bio_err, "-keypbe alg   specify private key PBE algorithm (default 3DES)\n");
d230 2
a231 7
	BIO_printf (bio_err, "-password p   set import/export password source\n");
	BIO_printf (bio_err, "-passin p     input file pass phrase source\n");
	BIO_printf (bio_err, "-passout p    output file pass phrase source\n");
	BIO_printf (bio_err, "-engine e     use engine e, possibly a hardware device.\n");
	BIO_printf(bio_err,  "-rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
	BIO_printf(bio_err,  "              load the file (or the files in the directory) into\n");
	BIO_printf(bio_err,  "              the random number generator\n");
d235 2
a236 21
    e = setup_engine(bio_err, engine, 0);

    if(passarg) {
	if(export_cert) passargout = passarg;
	else passargin = passarg;
    }

    if(!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {
	BIO_printf(bio_err, "Error getting passwords\n");
	goto end;
    }

    if(!cpass) {
    	if(export_cert) cpass = passout;
    	else cpass = passin;
    }

    if(cpass) {
	mpass = cpass;
	noprompt = 1;
    } else {
a240 6
    if(export_cert || inrand) {
    	app_RAND_load_file(NULL, bio_err, (inrand != NULL));
        if (inrand != NULL)
		BIO_printf(bio_err,"%ld semi-random bytes loaded\n",
			app_RAND_load_files(inrand));
    }
a242 4
#ifdef CRYPTO_MDEBUG
    CRYPTO_push_info("read files");
#endif

a251 1
#if 0
a266 1
#endif
d268 2
a269 14
#ifdef CRYPTO_MDEBUG
    CRYPTO_pop_info();
    CRYPTO_push_info("write files");
#endif

    if (!outfile) {
	out = BIO_new_fp(stdout, BIO_NOCLOSE);
#ifdef OPENSSL_SYS_VMS
	{
	    BIO *tmpbio = BIO_new(BIO_f_linebuffer());
	    out = BIO_push(tmpbio, out);
	}
#endif
    } else out = BIO_new_file(outfile, "wb");
a276 3
#ifdef CRYPTO_MDEBUG
    CRYPTO_push_info("read MAC password");
#endif
a281 3
#ifdef CRYPTO_MDEBUG
    CRYPTO_pop_info();
#endif
d284 9
a292 10
    if (export_cert) {
	EVP_PKEY *key = NULL;
	STACK_OF(PKCS12_SAFEBAG) *bags = NULL;
	STACK_OF(PKCS7) *safes = NULL;
	PKCS12_SAFEBAG *bag = NULL;
	PKCS8_PRIV_KEY_INFO *p8 = NULL;
	PKCS7 *authsafe = NULL;
	X509 *ucert = NULL;
	STACK_OF(X509) *certs=NULL;
	char *catmp = NULL;
d296 2
a297 7

#ifdef CRYPTO_MDEBUG
	CRYPTO_push_info("process -export_cert");
	CRYPTO_push_info("reading private key");
#endif
	key = load_key(bio_err, keyname ? keyname : infile, FORMAT_PEM,
		passin, e, "private key");
d299 3
a301 1
		goto export_end;
d304 1
a304 4
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("reading certs from input");
#endif
d307 4
a310 3
	if(!(certs = load_certs(bio_err, infile, FORMAT_PEM, NULL, e,
		"certificates"))) {
		goto export_end;
a312 5
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("reading certs from input 2");
#endif

d316 1
a316 1
			X509_digest(ucert, EVP_sha1(), keyid, &keyidlen);
d320 1
a321 1
		ucert = NULL;
d323 1
a323 1
		goto export_end;
d326 1
a326 6
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("reading certs from certfile");
#endif

	bags = sk_PKCS12_SAFEBAG_new_null ();
d329 5
a333 6
	if (certfile) {
		STACK_OF(X509) *morecerts=NULL;
		if(!(morecerts = load_certs(bio_err, certfile, FORMAT_PEM,
					    NULL, e,
					    "certificates from certfile"))) {
			goto export_end;
d335 1
a335 4
		while(sk_X509_num(morecerts) > 0) {
			sk_X509_push(certs, sk_X509_shift(morecerts));
		}
		sk_X509_free(morecerts);
a337 5
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("building chain");
#endif

d342 1
a342 18
		X509_STORE *store = X509_STORE_new();
		if (!store)
			{
			BIO_printf (bio_err, "Memory allocation error\n");
			goto export_end;
			}
		if (!X509_STORE_load_locations(store, CAfile, CApath))
			X509_STORE_set_default_paths (store);

		vret = get_cert_chain (ucert, store, &chain2);
		X509_STORE_free(store);

		if (!vret) {
		    /* Exclude verified certificate */
		    for (i = 1; i < sk_X509_num (chain2) ; i++) 
			sk_X509_push(certs, sk_X509_value (chain2, i));
		}
		sk_X509_free(chain2);
d346 7
a352 2
			goto export_end;
		}			
a354 5
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("building bags");
#endif

a356 1
		X509 *cert = NULL;
d358 1
a358 1
		bag = PKCS12_x5092certbag(cert);
d365 1
a365 1
		sk_PKCS12_SAFEBAG_push(bags, bag);
d367 2
a368 9
	sk_X509_pop_free(certs, X509_free);
	certs = NULL;
	/* ucert is part of certs so it is already freed */
	ucert = NULL;

#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("encrypting bags");
#endif
d373 1
a373 1
	    goto export_end;
d379 1
a379 2
	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	bags = NULL;
d383 1
a383 1
		goto export_end;
d386 2
a387 7
	safes = sk_PKCS7_new_null ();
	sk_PKCS7_push (safes, authsafe);

#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("building shrouded key bag");
#endif
d391 1
d393 2
a394 1
	bag = PKCS12_MAKE_SHKEYBAG(key_pbe, cpass, -1, NULL, 0, iter, p8);
a395 1
	p8 = NULL;
a396 1
	if(csp_name) PKCS12_add_CSPName_asc(bag, csp_name, -1);
d398 2
a399 8
	bags = sk_PKCS12_SAFEBAG_new_null();
	sk_PKCS12_SAFEBAG_push (bags, bag);

#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("encrypting shrouded key bag");
#endif

d402 2
a403 8
	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	bags = NULL;
	sk_PKCS7_push (safes, authsafe);

#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("building pkcs12");
#endif
d405 1
a405 1
	p12 = PKCS12_init(NID_pkcs7_data);
d407 1
a407 1
	PKCS12_pack_authsafes(p12, safes);
d409 1
a409 2
	sk_PKCS7_pop_free(safes, PKCS7_free);
	safes = NULL;
d413 1
a413 4
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("writing pkcs12");
#endif
d415 1
a415 1
	i2d_PKCS12_bio (out, p12);
a417 17

    export_end:
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_pop_info();
	CRYPTO_push_info("process -export_cert: freeing");
#endif

	if (key) EVP_PKEY_free(key);
	if (certs) sk_X509_pop_free(certs, X509_free);
	if (safes) sk_PKCS7_pop_free(safes, PKCS7_free);
	if (bags) sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	if (ucert) X509_free(ucert);

#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
#endif
a426 3
#ifdef CRYPTO_MDEBUG
    CRYPTO_push_info("read import password");
#endif
a430 3
#ifdef CRYPTO_MDEBUG
    CRYPTO_pop_info();
#endif
d436 2
a437 9
#ifdef CRYPTO_MDEBUG
    CRYPTO_push_info("verify MAC");
#endif
	/* If we enter empty password try no password first */
	if(!macpass[0] && PKCS12_verify_mac(p12, NULL, 0)) {
		/* If mac and crypto pass the same set it to NULL too */
		if(!twopass) cpass = NULL;
	} else if (!PKCS12_verify_mac(p12, mpass, -1)) {
	    BIO_printf (bio_err, "Mac verify error: invalid password?\n");
d440 1
a440 5
	}
	BIO_printf (bio_err, "MAC verified OK\n");
#ifdef CRYPTO_MDEBUG
    CRYPTO_pop_info();
#endif
d443 1
a443 4
#ifdef CRYPTO_MDEBUG
    CRYPTO_push_info("output keys and certificates");
#endif
    if (!dump_certs_keys_p12 (out, p12, cpass, -1, options, passout)) {
d448 1
a448 3
#ifdef CRYPTO_MDEBUG
    CRYPTO_pop_info();
#endif
d450 2
a451 12
 end:
    if (p12) PKCS12_free(p12);
    if(export_cert || inrand) app_RAND_write_file(NULL, bio_err);
#ifdef CRYPTO_MDEBUG
    CRYPTO_remove_all_info();
#endif
    BIO_free(in);
    BIO_free_all(out);
    if (canames) sk_free(canames);
    if(passin) OPENSSL_free(passin);
    if(passout) OPENSSL_free(passout);
    apps_shutdown();
d455 14
d470 1
a470 1
	     int passlen, int options, char *pempass)
d472 1
a472 2
	STACK_OF(PKCS7) *asafes;
	STACK_OF(PKCS12_SAFEBAG) *bags;
d475 3
a477 4

	if (!( asafes = PKCS12_unpack_authsafes(p12))) return 0;
	for (i = 0; i < sk_PKCS7_num (asafes); i++) {
		p7 = sk_PKCS7_value (asafes, i);
d480 1
a480 1
			bags = PKCS12_unpack_p7data(p7);
d484 2
a485 2
				BIO_printf(bio_err, "PKCS7 Encrypted data: ");
				alg_print(bio_err, 
d488 1
a488 1
			bags = PKCS12_unpack_p7encdata(p7, pass, passlen);
d492 2
a493 2
						 options, pempass)) {
			sk_PKCS12_SAFEBAG_pop_free (bags, PKCS12_SAFEBAG_free);
d496 1
a496 1
		sk_PKCS12_SAFEBAG_pop_free (bags, PKCS12_SAFEBAG_free);
d498 1
a498 1
	sk_PKCS7_pop_free (asafes, PKCS7_free);
d502 2
a503 2
int dump_certs_pkeys_bags (BIO *out, STACK_OF(PKCS12_SAFEBAG) *bags,
			   char *pass, int passlen, int options, char *pempass)
d506 1
a506 1
	for (i = 0; i < sk_PKCS12_SAFEBAG_num (bags); i++) {
d508 2
a509 4
					   sk_PKCS12_SAFEBAG_value (bags, i),
					   pass, passlen,
					   options, pempass))
		    return 0;
d515 1
a515 1
	     int passlen, int options, char *pempass)
d530 1
a530 1
		PEM_write_bio_PrivateKey (out, pkey, enc, NULL, 0, NULL, pempass);
d541 1
a541 1
		if (!(p8 = PKCS12_decrypt_skey(bag, pass, passlen)))
d543 1
a543 4
		if (!(pkey = EVP_PKCS82PKEY (p8))) {
			PKCS8_PRIV_KEY_INFO_free(p8);
			return 0;
		}
d546 1
a546 1
		PEM_write_bio_PrivateKey (out, pkey, enc, NULL, 0, NULL, pempass);
d559 1
a559 1
		if (!(x509 = PKCS12_certbag2x509(bag))) return 0;
d569 1
a569 1
							    passlen, options, pempass);
d585 1
a585 1
int get_cert_chain (X509 *cert, X509_STORE *store, STACK_OF(X509) **chain)
d587 1
d591 3
a593 4

	/* FIXME: Should really check the return status of X509_STORE_CTX_init
	 * for an error, but how that fits into the return value of this
	 * function is less obvious. */
d599 5
a603 1
	chn =  X509_STORE_CTX_get1_chain(&store_ctx);
d608 1
a631 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_push_info("cert_load(): reading one cert");
#endif
a632 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_pop_info();
#endif
a634 3
#ifdef CRYPTO_MDEBUG
		CRYPTO_push_info("cert_load(): reading one cert");
#endif
a635 3
#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
#endif
d673 1
a673 1
				OPENSSL_free(value);
d677 2
a678 2
				hex_prin(out, av->value.octet_string->data,
					av->value.octet_string->length);
d683 2
a684 2
				hex_prin(out, av->value.bit_string->data,
					av->value.bit_string->length);
@


1.1.1.2
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d430 1
a430 1
	key = load_key(bio_err, keyname ? keyname : infile, FORMAT_PEM, 1,
d511 3
a513 4
		    /* Free first certificate */
		    X509_free(sk_X509_value(chain2, 0));
		    sk_X509_free(chain2);
		} else {
d540 2
d630 1
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@a122 1
#ifndef OPENSSL_NO_ENGINE
a123 1
#endif
a254 1
#ifndef OPENSSL_NO_ENGINE
a259 1
#endif
a306 1
#ifndef OPENSSL_NO_ENGINE
a307 1
#endif
a313 1
#ifndef OPENSSL_NO_ENGINE
a314 1
#endif
d402 1
a402 1
	if(EVP_read_pw_string (macpass, sizeof macpass, "Enter MAC Password:", export_cert))
d548 1
a548 1
		EVP_read_pw_string(pass, sizeof pass, "Enter Export Password:", 1)) {
d645 1
a645 1
    if(!noprompt && EVP_read_pw_string(pass, sizeof pass, "Enter Import Password:", 0)) {
d699 1
a699 1
    OPENSSL_EXIT(ret);
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@d560 1
a560 1
	if (!twopass) BUF_strlcpy(macpass, pass, sizeof macpass);
d661 1
a661 1
    if (!twopass) BUF_strlcpy(macpass, pass, sizeof macpass);
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d112 1
a112 1
    int cert_pbe;
a128 7
#ifdef OPENSSL_FIPS
    if (FIPS_mode())
	cert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
    else
#endif
    cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;

d669 1
a669 1
	if(!mpass[0] && PKCS12_verify_mac(p12, NULL, 0)) {
d713 1
a713 1
	STACK_OF(PKCS7) *asafes = NULL;
a715 1
	int ret = 0;
d733 1
a733 1
		if (!bags) goto err;
d737 1
a737 1
			goto err;
a739 1
		bags = NULL;
d741 2
a742 7
	ret = 1;

	err:

	if (asafes)
		sk_PKCS7_pop_free (asafes, PKCS7_free);
	return ret;
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d2 2
d5 1
a5 1
 * project.
d8 1
a8 1
 * Copyright (c) 1999-2006 The OpenSSL Project.  All rights reserved.
a60 3
#include <openssl/opensslconf.h>
#if !defined(OPENSSL_NO_DES) && !defined(OPENSSL_NO_SHA1)

d86 1
a86 1
int print_attribs(BIO *out, STACK_OF(X509_ATTRIBUTE) *attrlst,const char *name);
d112 1
a112 1
    int cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;
d129 7
a161 1
		else if (!strcmp (*args, "-des3")) enc = EVP_des_ede3_cbc();
d165 1
a165 3
#ifndef OPENSSL_NO_SEED
		else if (!strcmp(*args, "-seed")) enc=EVP_seed_cbc();
#endif
a170 5
#ifndef OPENSSL_NO_CAMELLIA
		else if (!strcmp(*args,"-camellia128")) enc=EVP_camellia_128_cbc();
		else if (!strcmp(*args,"-camellia192")) enc=EVP_camellia_192_cbc();
		else if (!strcmp(*args,"-camellia256")) enc=EVP_camellia_256_cbc();
#endif
a175 2
		else if (!strcmp (*args, "-nomac"))
					 maciter = -1;
d180 1
a180 4
				if (!strcmp(*args, "NONE"))
					cert_pbe = -1;
				else
					cert_pbe=OBJ_txt2nid(*args);
d190 1
a190 4
				if (!strcmp(*args, "NONE"))
					key_pbe = -1;
				else
					key_pbe=OBJ_txt2nid(*args);
a301 3
#ifndef OPENSSL_NO_SEED
	BIO_printf (bio_err, "-seed         encrypt private keys with seed\n");
#endif
a305 4
#ifndef OPENSSL_NO_CAMELLIA
	BIO_printf (bio_err, "-camellia128, -camellia192, -camellia256\n");
	BIO_printf (bio_err, "              encrypt PEM output with cbc camellia\n");
#endif
d375 18
d429 6
a434 1
	X509 *ucert = NULL, *x = NULL;
d436 1
a436 1
	unsigned char *catmp = NULL;
d438 2
a439 9

	if ((options & (NOCERTS|NOKEYS)) == (NOCERTS|NOKEYS))
		{	
		BIO_printf(bio_err, "Nothing to do!\n");
		goto export_end;
		}

	if (options & NOCERTS)
		chain = 0;
d445 5
a449 7
	if (!(options & NOKEYS))
		{
		key = load_key(bio_err, keyname ? keyname : infile,
				FORMAT_PEM, 1, passin, e, "private key");
		if (!key)
			goto export_end;
		}
d457 4
a460 6
	if(!(options & NOCERTS))
		{
		certs = load_certs(bio_err, infile, FORMAT_PEM, NULL, e,
							"certificates");
		if (!certs)
			goto export_end;
d462 4
a465 23
		if (key)
			{
			/* Look for matching private key */
			for(i = 0; i < sk_X509_num(certs); i++)
				{
				x = sk_X509_value(certs, i);
				if(X509_check_private_key(x, key))
					{
					ucert = x;
					/* Zero keyid and alias */
					X509_keyid_set1(ucert, NULL, 0);
					X509_alias_set1(ucert, NULL, 0);
					/* Remove from list */
					(void)sk_X509_delete(certs, i);
					break;
					}
				}
			if (!ucert)
				{
				BIO_printf(bio_err, "No certificate matches private key\n");
				goto export_end;
				}
			}
d467 5
d473 7
a479 1

d482 1
a482 1
	CRYPTO_push_info("reading certs from input 2");
d485 2
d488 1
a488 2
	if(certfile)
		{
d492 1
a492 1
					    "certificates from certfile")))
d494 2
a495 1
		while(sk_X509_num(morecerts) > 0)
d497 1
d499 1
a499 6
 		}

#ifdef CRYPTO_MDEBUG
	CRYPTO_pop_info();
	CRYPTO_push_info("reading certs from certfile");
#endif
d530 1
a530 2
			if (vret >= 0)
				BIO_printf (bio_err, "Error %s getting chain.\n",
a531 2
			else
				ERR_print_errors(bio_err);
d536 4
a539 1
	/* Add any CA names */
d541 15
a555 10
	for (i = 0; i < sk_num(canames); i++)
		{
		catmp = (unsigned char *)sk_value(canames, i);
		X509_alias_set1(sk_X509_value(certs, i), catmp, -1);
		}

	if (csp_name && key)
		EVP_PKEY_add1_attr_by_NID(key, NID_ms_csp_name,
				MBSTRING_ASC, (unsigned char *)csp_name, -1);
		
d559 1
a559 1
	CRYPTO_push_info("reading password");
d563 4
a566 5
		EVP_read_pw_string(pass, sizeof pass, "Enter Export Password:", 1))
		{
	    	BIO_printf (bio_err, "Can't read Password\n");
	    	goto export_end;
        	}
d568 41
d612 1
a612 1
	CRYPTO_push_info("creating PKCS#12 structure");
d615 3
a617 2
	p12 = PKCS12_create(cpass, name, key, ucert, certs,
				key_pbe, cert_pbe, iter, -1, keytype);
d619 2
a620 5
	if (!p12)
		{
	    	ERR_print_errors (bio_err);
		goto export_end;
		}
d622 1
a622 2
	if (maciter != -1)
		PKCS12_set_mac(p12, mpass, -1, NULL, 0, maciter, NULL);
d629 1
a629 1
	i2d_PKCS12_bio(out, p12);
d642 2
a643 1
	if (ucert) X509_free(ucert);
d851 1
a851 1
	int i = 0;
a858 5
		if (i == 0)
			/* avoid returning 0 if X509_verify_cert() did not
			 * set an appropriate error value in the context */
			i = -1;
		chn = NULL;
d860 4
a863 2
	} else
		chn = X509_STORE_CTX_get1_chain(&store_ctx);
a865 1
	*chain = chn;
d873 1
a873 1
	const unsigned char *p;
d875 3
a877 6
	pbe = d2i_PBEPARAM(NULL, &p, alg->parameter->value.sequence->length);
	if (!pbe)
		return 1;
	BIO_printf (bio_err, "%s, Iteration %ld\n", 
		OBJ_nid2ln(OBJ_obj2nid(alg->algorithm)),
		ASN1_INTEGER_get(pbe->iter));
d879 1
a879 1
	return 1;
d911 1
a911 1
int print_attribs (BIO *out, STACK_OF(X509_ATTRIBUTE) *attrlst,const char *name)
@


1.1.1.7
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
a102 1
    int add_lmk = 0;
d113 1
a113 1
    int cert_pbe;
a129 7
#ifdef OPENSSL_FIPS
    if (FIPS_mode())
	cert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
    else
#endif
    cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;

d227 1
a227 3
		} else if (!strcmp (*args, "-LMK"))
			add_lmk = 1;
		else if (!strcmp (*args, "-CSP")) {
a340 2
  	BIO_printf(bio_err,  "-CSP name     Microsoft CSP name\n");
 	BIO_printf(bio_err,  "-LMK          Add local machine keyset attribute to private key\n");
d565 1
a565 3

	if (add_lmk && key)
		EVP_PKEY_add1_attr_by_NID(key, NID_LocalKeySet, 0, NULL, -1);
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@a90 1
static int set_pbe(BIO *err, int *ppbe, const char *str);
d114 1
a114 1
    int cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;
d119 1
a119 1
    STACK_OF(OPENSSL_STRING) *canames = NULL;
a123 1
    char *macalg = NULL;
d131 7
a187 5
		else if (!strcmp (*args, "-macalg"))
		    if (args[1]) {
			args++;	
			macalg = *args;
		    } else badarg = 1;
d190 12
a201 2
			if (!set_pbe(bio_err, &cert_pbe, *++args))
				badarg = 1;
d203 12
a214 2
			if (!set_pbe(bio_err, &key_pbe, *++args))
				badarg = 1;
d245 2
a246 2
			if (!canames) canames = sk_OPENSSL_STRING_new_null();
			sk_OPENSSL_STRING_push(canames, *args);
a334 1
	BIO_printf (bio_err, "-nomaciter    don't use MAC iteration\n");
a335 1
	BIO_printf (bio_err, "-nomac        don't generate MAC\n");
a339 1
	BIO_printf (bio_err, "-macalg alg   digest algorithm used in MAC (default SHA1)\n");
d351 2
a352 2
	BIO_printf(bio_err,  "-CSP name     Microsoft CSP name\n");
	BIO_printf(bio_err,  "-LMK          Add local machine keyset attribute to private key\n");
a441 1
	const EVP_MD *macmd = NULL;
d568 1
a568 1
	for (i = 0; i < sk_OPENSSL_STRING_num(canames); i++)
d570 1
a570 1
		catmp = (unsigned char *)sk_OPENSSL_STRING_value(canames, i);
a607 10
	if (macalg)
		{
		macmd = EVP_get_digestbyname(macalg);
		if (!macmd)
			{
			BIO_printf(bio_err, "Unknown digest algorithm %s\n", 
						macalg);
			}
		}

d609 1
a609 1
		PKCS12_set_mac(p12, mpass, -1, NULL, 0, maciter, macmd);
d696 1
a696 1
    if (canames) sk_OPENSSL_STRING_free(canames);
d932 1
a932 1
        			value = OPENSSL_uni2asc(av->value.bmpstring->data,
a964 18
static int set_pbe(BIO *err, int *ppbe, const char *str)
	{
	if (!str)
		return 0;
	if (!strcmp(str, "NONE"))
		{
		*ppbe = -1;
		return 1;
		}
	*ppbe=OBJ_txt2nid(str);
	if (*ppbe == NID_undef)
		{
		BIO_printf(bio_err, "Unknown PBE algorithm %s\n", str);
		return 0;
		}
	return 1;
	}
			
@


1.1.1.9
log
@import OpenSSL 1.0.0e
@
text
@d650 1
a650 1
    if ((options & INFO) && p12->mac) BIO_printf (bio_err, "MAC Iteration %ld\n", p12->mac->iter ? ASN1_INTEGER_get (p12->mac->iter) : 1);
@


1.1.1.10
log
@Import OpenSSL 1.0.1g
@
text
@d115 1
a115 1
    int cert_pbe;
a131 7

#ifdef OPENSSL_FIPS
    if (FIPS_mode())
	cert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
    else
#endif
    cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;
@


