head	1.71;
access;
symbols
	OPENBSD_5_6:1.69.0.4
	OPENBSD_5_6_BASE:1.69
	butholakala:1.25
	openssl_1_0_1_g:1.1.1.11
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	openssl_1_0_1_c:1.1.1.10
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.8
	openssl_1_0_0_f:1.1.1.9
	openssl_1_0_0_e:1.1.1.9
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	openssh_1_0_0_a:1.1.1.9
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.19.0.4
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	openssl_0_9_8_k:1.1.1.8
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	openssl_0_9_8_j:1.1.1.8
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENSSL_0_9_7G:1.1.1.6
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENSSL_0_9_7D:1.1.1.5
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENSSL_0_9_7C:1.1.1.5
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.71
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.70;
commitid	7A7DObXgY4Fni8xJ;

1.70
date	2014.08.24.16.07.29;	author bcook;	state Exp;
branches;
next	1.69;
commitid	DkRmQqUr5tFLfwxx;

1.69
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.68;
commitid	EB0l28piqIRSpBUh;

1.68
date	2014.07.12.19.31.21;	author jsing;	state Exp;
branches;
next	1.67;
commitid	X84oGf60c5Z5Yd6T;

1.67
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.66;
commitid	0NuggCO2WJOZj8Kh;

1.66
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.65;
commitid	cCGiAdDteN08GytD;

1.65
date	2014.07.10.09.30.53;	author jsing;	state Exp;
branches;
next	1.64;
commitid	Rzw4Fpjc3f9cSU9R;

1.64
date	2014.07.10.09.15.51;	author tedu;	state Exp;
branches;
next	1.63;
commitid	UBEq86QvA3vj9HEw;

1.63
date	2014.07.09.20.59.41;	author tedu;	state Exp;
branches;
next	1.62;
commitid	2mQaONecDqKK2dqY;

1.62
date	2014.06.28.04.39.41;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	gGtvlhTlvaxlmOBo;

1.61
date	2014.06.13.04.29.13;	author miod;	state Exp;
branches;
next	1.60;
commitid	8Qu6YceLSxhOi4yG;

1.60
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	mJUVYpkFBZ0Zv2bG;

1.59
date	2014.06.02.16.23.18;	author jsing;	state Exp;
branches;
next	1.58;
commitid	IqYoI5gjfSomu7k2;

1.58
date	2014.05.26.13.55.24;	author jsing;	state Exp;
branches;
next	1.57;

1.57
date	2014.05.25.16.13.11;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.55;

1.55
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.54;

1.54
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.53;

1.53
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.52;

1.52
date	2014.05.07.21.32.19;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2014.05.06.01.54.42;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2014.05.06.01.52.07;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2014.05.05.16.14.45;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.02.17.06.46;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.46;

1.46
date	2014.04.22.14.54.13;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2014.04.19.16.46.08;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2014.04.19.16.31.51;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2014.04.18.15.39.53;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.18.09.38.42;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.18.04.17.17;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.18.01.07.13;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.17.21.45.45;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.16.02.51.01;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.16.02.50.09;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.15.21.47.56;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.15.20.14.23;	author beck;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.15.17.46.16;	author beck;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.13.23.31.37;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.13.20.37.11;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2012.07.12.20.44.12;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2012.07.11.11.02.48;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.01.22.58.51;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.20.23.01.28;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.30.03.56.05;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.09.12.15.19;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.06.12.20.16;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.06.13.32.49;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.29.05.39.16;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.31.23.17.08;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.11.22.15.18;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.06.21.08.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.10.16.31.53;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.02.50;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.56.58;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.30;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.13;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.19;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.09;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.09;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.35;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.34.42;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.23;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.10.56;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.36.59;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.13.49;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: s_client.c,v 1.70 2014/08/24 16:07:29 bcook Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>

#include "apps.h"

#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/ocsp.h>
#include <openssl/pem.h>
#include <openssl/rand.h>
#include <openssl/ssl.h>
#include <openssl/x509.h>

#include "s_apps.h"
#include "timeouts.h"

/*#define SSL_HOST_NAME	"www.netscape.com" */
/*#define SSL_HOST_NAME	"193.118.187.102" */
#define SSL_HOST_NAME	"localhost"

 /*#define TEST_CERT "client.pem" *//* no default cert. */

#define BUFSIZZ 1024*8

extern int verify_depth;
extern int verify_error;
extern int verify_return_error;

static int c_nbio = 0;
static int c_Pause = 0;
static int c_debug = 0;
#ifndef OPENSSL_NO_TLSEXT
static int c_tlsextdebug = 0;
static int c_status_req = 0;
#endif
static int c_msg = 0;
static int c_showcerts = 0;

static char *keymatexportlabel = NULL;
static int keymatexportlen = 20;

static void sc_usage(void);
static void print_stuff(BIO * berr, SSL * con, int full);
#ifndef OPENSSL_NO_TLSEXT
static int ocsp_resp_cb(SSL * s, void *arg);
#endif
static BIO *bio_c_out = NULL;
static int c_quiet = 0;
static int c_ign_eof = 0;


static void
sc_usage(void)
{
	BIO_printf(bio_err, "usage: s_client args\n");
	BIO_printf(bio_err, "\n");
	BIO_printf(bio_err, " -4            - Force IPv4\n");
	BIO_printf(bio_err, " -6            - Force IPv6\n");
	BIO_printf(bio_err, " -host host     - use -connect instead\n");
	BIO_printf(bio_err, " -port port     - use -connect instead\n");
	BIO_printf(bio_err, " -connect host:port - who to connect to (default is %s:%s)\n", SSL_HOST_NAME, PORT_STR);

	BIO_printf(bio_err, " -verify arg   - turn on peer certificate verification\n");
	BIO_printf(bio_err, " -cert arg     - certificate file to use, PEM format assumed\n");
	BIO_printf(bio_err, " -certform arg - certificate format (PEM or DER) PEM default\n");
	BIO_printf(bio_err, " -key arg      - Private key file to use, in cert file if\n");
	BIO_printf(bio_err, "                 not specified but cert file is.\n");
	BIO_printf(bio_err, " -keyform arg  - key format (PEM or DER) PEM default\n");
	BIO_printf(bio_err, " -pass arg     - private key file pass phrase source\n");
	BIO_printf(bio_err, " -CApath arg   - PEM format directory of CA's\n");
	BIO_printf(bio_err, " -CAfile arg   - PEM format file of CA's\n");
	BIO_printf(bio_err, " -reconnect    - Drop and re-make the connection with the same Session-ID\n");
	BIO_printf(bio_err, " -pause        - sleep(1) after each read(2) and write(2) system call\n");
	BIO_printf(bio_err, " -showcerts    - show all certificates in the chain\n");
	BIO_printf(bio_err, " -debug        - extra output\n");
	BIO_printf(bio_err, " -msg          - Show protocol messages\n");
	BIO_printf(bio_err, " -nbio_test    - more ssl protocol testing\n");
	BIO_printf(bio_err, " -state        - print the 'ssl' states\n");
	BIO_printf(bio_err, " -nbio         - Run with non-blocking IO\n");
	BIO_printf(bio_err, " -crlf         - convert LF from terminal into CRLF\n");
	BIO_printf(bio_err, " -quiet        - no s_client output\n");
	BIO_printf(bio_err, " -ign_eof      - ignore input eof (default when -quiet)\n");
	BIO_printf(bio_err, " -no_ign_eof   - don't ignore input eof\n");
	BIO_printf(bio_err, " -ssl3         - just use SSLv3\n");
	BIO_printf(bio_err, " -tls1_2       - just use TLSv1.2\n");
	BIO_printf(bio_err, " -tls1_1       - just use TLSv1.1\n");
	BIO_printf(bio_err, " -tls1         - just use TLSv1\n");
	BIO_printf(bio_err, " -dtls1        - just use DTLSv1\n");
	BIO_printf(bio_err, " -mtu          - set the link layer MTU\n");
	BIO_printf(bio_err, " -no_tls1_2/-no_tls1_1/-no_tls1/-no_ssl3/-no_ssl2 - turn off that protocol\n");
	BIO_printf(bio_err, " -bugs         - Switch on all SSL implementation bug workarounds\n");
	BIO_printf(bio_err, " -cipher       - preferred cipher to use, use the 'openssl ciphers'\n");
	BIO_printf(bio_err, "                 command to see what is available\n");
	BIO_printf(bio_err, " -starttls prot - use the STARTTLS command before starting TLS\n");
	BIO_printf(bio_err, "                 for those protocols that support it, where\n");
	BIO_printf(bio_err, "                 'prot' defines which one to assume.  Currently,\n");
	BIO_printf(bio_err, "                 only \"smtp\", \"lmtp\", \"pop3\", \"imap\", \"ftp\" and \"xmpp\"\n");
	BIO_printf(bio_err, "                 are supported.\n");
#ifndef OPENSSL_NO_ENGINE
	BIO_printf(bio_err, " -engine id    - Initialise and use the specified engine\n");
#endif
	BIO_printf(bio_err, " -sess_out arg - file to write SSL session to\n");
	BIO_printf(bio_err, " -sess_in arg  - file to read SSL session from\n");
#ifndef OPENSSL_NO_TLSEXT
	BIO_printf(bio_err, " -servername host  - Set TLS extension servername in ClientHello\n");
	BIO_printf(bio_err, " -tlsextdebug      - hex dump of all TLS extensions received\n");
	BIO_printf(bio_err, " -status           - request certificate status from server\n");
	BIO_printf(bio_err, " -no_ticket        - disable use of RFC4507bis session tickets\n");
#ifndef OPENSSL_NO_NEXTPROTONEG
	BIO_printf(bio_err, " -nextprotoneg arg - enable NPN extension, considering named protocols supported (comma-separated list)\n");
#endif
#endif
#ifndef OPENSSL_NO_SRTP
	BIO_printf(bio_err, " -use_srtp profiles - Offer SRTP key management with a colon-separated profile list\n");
#endif
	BIO_printf(bio_err, " -keymatexport label   - Export keying material using label\n");
	BIO_printf(bio_err, " -keymatexportlen len  - Export len bytes of keying material (default 20)\n");
}

#ifndef OPENSSL_NO_TLSEXT

/* This is a context that we pass to callbacks */
typedef struct tlsextctx_st {
	BIO *biodebug;
	int ack;
} tlsextctx;


static int
ssl_servername_cb(SSL * s, int *ad, void *arg)
{
	tlsextctx *p = (tlsextctx *) arg;
	const char *hn = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);
	if (SSL_get_servername_type(s) != -1)
		p->ack = !SSL_session_reused(s) && hn != NULL;
	else
		BIO_printf(bio_err, "Can't use SSL_get_servername\n");

	return SSL_TLSEXT_ERR_OK;
}

#ifndef OPENSSL_NO_SRTP
char *srtp_profiles = NULL;
#endif

#ifndef OPENSSL_NO_NEXTPROTONEG
/* This the context that we pass to next_proto_cb */
typedef struct tlsextnextprotoctx_st {
	unsigned char *data;
	unsigned short len;
	int status;
} tlsextnextprotoctx;

static tlsextnextprotoctx next_proto;

static int
next_proto_cb(SSL * s, unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg)
{
	tlsextnextprotoctx *ctx = arg;

	if (!c_quiet) {
		/* We can assume that |in| is syntactically valid. */
		unsigned i;
		BIO_printf(bio_c_out, "Protocols advertised by server: ");
		for (i = 0; i < inlen;) {
			if (i)
				BIO_write(bio_c_out, ", ", 2);
			BIO_write(bio_c_out, &in[i + 1], in[i]);
			i += in[i] + 1;
		}
		BIO_write(bio_c_out, "\n", 1);
	}
	ctx->status = SSL_select_next_proto(out, outlen, in, inlen, ctx->data, ctx->len);
	return SSL_TLSEXT_ERR_OK;
}
#endif				/* ndef OPENSSL_NO_NEXTPROTONEG */
#endif

enum {
	PROTO_OFF = 0,
	PROTO_SMTP,
	PROTO_LMTP,
	PROTO_POP3,
	PROTO_IMAP,
	PROTO_FTP,
	PROTO_XMPP
};

int s_client_main(int, char **);

int
s_client_main(int argc, char **argv)
{
	unsigned int off = 0, clr = 0;
	SSL *con = NULL;
	int s, k, width, state = 0, af = AF_UNSPEC;
	char *cbuf = NULL, *sbuf = NULL, *mbuf = NULL;
	int cbuf_len, cbuf_off;
	int sbuf_len, sbuf_off;
	fd_set readfds, writefds;
	char *port = PORT_STR;
	int full_log = 1;
	char *host = SSL_HOST_NAME;
	char *cert_file = NULL, *key_file = NULL;
	int cert_format = FORMAT_PEM, key_format = FORMAT_PEM;
	char *passarg = NULL, *pass = NULL;
	X509 *cert = NULL;
	EVP_PKEY *key = NULL;
	char *CApath = NULL, *CAfile = NULL, *cipher = NULL;
	int reconnect = 0, badop = 0, verify = SSL_VERIFY_NONE, bugs = 0;
	int crlf = 0;
	int write_tty, read_tty, write_ssl, read_ssl, tty_on, ssl_pending;
	SSL_CTX *ctx = NULL;
	int ret = 1, in_init = 1, i, nbio_test = 0;
	int starttls_proto = PROTO_OFF;
	int prexit = 0;
	X509_VERIFY_PARAM *vpm = NULL;
	int badarg = 0;
	const SSL_METHOD *meth = NULL;
	int socket_type = SOCK_STREAM;
	BIO *sbio;
	int mbuf_len = 0;
	struct timeval timeout, *timeoutp;
	const char *errstr = NULL;
#ifndef OPENSSL_NO_ENGINE
	char *engine_id = NULL;
	char *ssl_client_engine_id = NULL;
	ENGINE *ssl_client_engine = NULL;
#endif
	ENGINE *e = NULL;
#ifndef OPENSSL_NO_TLSEXT
	char *servername = NULL;
	tlsextctx tlsextcbp =
	{NULL, 0};
#ifndef OPENSSL_NO_NEXTPROTONEG
	const char *next_proto_neg_in = NULL;
#endif
#endif
	char *sess_in = NULL;
	char *sess_out = NULL;
	struct sockaddr peer;
	int peerlen = sizeof(peer);
	int enable_timeouts = 0;
	long socket_mtu = 0;

	meth = SSLv23_client_method();

	c_Pause = 0;
	c_quiet = 0;
	c_ign_eof = 0;
	c_debug = 0;
	c_msg = 0;
	c_showcerts = 0;

	if (((cbuf = malloc(BUFSIZZ)) == NULL) ||
	    ((sbuf = malloc(BUFSIZZ)) == NULL) ||
	    ((mbuf = malloc(BUFSIZZ + 1)) == NULL)) {	/* NUL byte */
		BIO_printf(bio_err, "out of memory\n");
		goto end;
	}
	verify_depth = 0;
	verify_error = X509_V_OK;
	c_nbio = 0;

	argc--;
	argv++;
	while (argc >= 1) {
		if (strcmp(*argv, "-host") == 0) {
			if (--argc < 1)
				goto bad;
			host = *(++argv);
		} else if (strcmp(*argv, "-port") == 0) {
			if (--argc < 1)
				goto bad;
			port = *(++argv);
			if (port == NULL || *port == '\0')
				goto bad;
		} else if (strcmp(*argv, "-connect") == 0) {
			if (--argc < 1)
				goto bad;
			if (!extract_host_port(*(++argv), &host, NULL, &port))
				goto bad;
		} else if (strcmp(*argv, "-verify") == 0) {
			verify = SSL_VERIFY_PEER;
			if (--argc < 1)
				goto bad;
			verify_depth = strtonum(*(++argv), 0, INT_MAX, &errstr);
			if (errstr)
				goto bad;
			BIO_printf(bio_err, "verify depth is %d\n", verify_depth);
		} else if (strcmp(*argv, "-cert") == 0) {
			if (--argc < 1)
				goto bad;
			cert_file = *(++argv);
		} else if (strcmp(*argv, "-sess_out") == 0) {
			if (--argc < 1)
				goto bad;
			sess_out = *(++argv);
		} else if (strcmp(*argv, "-sess_in") == 0) {
			if (--argc < 1)
				goto bad;
			sess_in = *(++argv);
		} else if (strcmp(*argv, "-certform") == 0) {
			if (--argc < 1)
				goto bad;
			cert_format = str2fmt(*(++argv));
		} else if (args_verify(&argv, &argc, &badarg, bio_err, &vpm)) {
			if (badarg)
				goto bad;
			continue;
		} else if (strcmp(*argv, "-verify_return_error") == 0)
			verify_return_error = 1;
		else if (strcmp(*argv, "-prexit") == 0)
			prexit = 1;
		else if (strcmp(*argv, "-crlf") == 0)
			crlf = 1;
		else if (strcmp(*argv, "-quiet") == 0) {
			c_quiet = 1;
			c_ign_eof = 1;
		} else if (strcmp(*argv, "-ign_eof") == 0)
			c_ign_eof = 1;
		else if (strcmp(*argv, "-no_ign_eof") == 0)
			c_ign_eof = 0;
		else if (strcmp(*argv, "-pause") == 0)
			c_Pause = 1;
		else if (strcmp(*argv, "-debug") == 0)
			c_debug = 1;
#ifndef OPENSSL_NO_TLSEXT
		else if (strcmp(*argv, "-tlsextdebug") == 0)
			c_tlsextdebug = 1;
		else if (strcmp(*argv, "-status") == 0)
			c_status_req = 1;
#endif
		else if (strcmp(*argv, "-msg") == 0)
			c_msg = 1;
		else if (strcmp(*argv, "-showcerts") == 0)
			c_showcerts = 1;
		else if (strcmp(*argv, "-nbio_test") == 0)
			nbio_test = 1;
		else if (strcmp(*argv, "-state") == 0)
			state = 1;
		else if (strcmp(*argv, "-ssl3") == 0)
			meth = SSLv3_client_method();
		else if (strcmp(*argv, "-tls1_2") == 0)
			meth = TLSv1_2_client_method();
		else if (strcmp(*argv, "-tls1_1") == 0)
			meth = TLSv1_1_client_method();
		else if (strcmp(*argv, "-tls1") == 0)
			meth = TLSv1_client_method();
#ifndef OPENSSL_NO_DTLS1
		else if (strcmp(*argv, "-dtls1") == 0) {
			meth = DTLSv1_client_method();
			socket_type = SOCK_DGRAM;
		} else if (strcmp(*argv, "-timeout") == 0)
			enable_timeouts = 1;
		else if (strcmp(*argv, "-mtu") == 0) {
			if (--argc < 1)
				goto bad;
			socket_mtu = strtonum(*(++argv), 0, LONG_MAX, &errstr);
			if (errstr)
				goto bad;
		}
#endif
		else if (strcmp(*argv, "-bugs") == 0)
			bugs = 1;
		else if (strcmp(*argv, "-keyform") == 0) {
			if (--argc < 1)
				goto bad;
			key_format = str2fmt(*(++argv));
		} else if (strcmp(*argv, "-pass") == 0) {
			if (--argc < 1)
				goto bad;
			passarg = *(++argv);
		} else if (strcmp(*argv, "-key") == 0) {
			if (--argc < 1)
				goto bad;
			key_file = *(++argv);
		} else if (strcmp(*argv, "-reconnect") == 0) {
			reconnect = 5;
		} else if (strcmp(*argv, "-CApath") == 0) {
			if (--argc < 1)
				goto bad;
			CApath = *(++argv);
		} else if (strcmp(*argv, "-CAfile") == 0) {
			if (--argc < 1)
				goto bad;
			CAfile = *(++argv);
		} else if (strcmp(*argv, "-no_tls1_2") == 0)
			off |= SSL_OP_NO_TLSv1_2;
		else if (strcmp(*argv, "-no_tls1_1") == 0)
			off |= SSL_OP_NO_TLSv1_1;
		else if (strcmp(*argv, "-no_tls1") == 0)
			off |= SSL_OP_NO_TLSv1;
		else if (strcmp(*argv, "-no_ssl3") == 0)
			off |= SSL_OP_NO_SSLv3;
		else if (strcmp(*argv, "-no_ssl2") == 0)
			off |= SSL_OP_NO_SSLv2;
		else if (strcmp(*argv, "-no_comp") == 0) {
			off |= SSL_OP_NO_COMPRESSION;
		}
#ifndef OPENSSL_NO_TLSEXT
		else if (strcmp(*argv, "-no_ticket") == 0) {
			off |= SSL_OP_NO_TICKET;
		}
#ifndef OPENSSL_NO_NEXTPROTONEG
		else if (strcmp(*argv, "-nextprotoneg") == 0) {
			if (--argc < 1)
				goto bad;
			next_proto_neg_in = *(++argv);
		}
#endif
#endif
		else if (strcmp(*argv, "-serverpref") == 0)
			off |= SSL_OP_CIPHER_SERVER_PREFERENCE;
		else if (strcmp(*argv, "-legacy_renegotiation") == 0)
			; /* no-op */
		else if (strcmp(*argv, "-legacy_server_connect") == 0) {
			off |= SSL_OP_LEGACY_SERVER_CONNECT;
		} else if (strcmp(*argv, "-no_legacy_server_connect") == 0) {
			clr |= SSL_OP_LEGACY_SERVER_CONNECT;
		} else if (strcmp(*argv, "-cipher") == 0) {
			if (--argc < 1)
				goto bad;
			cipher = *(++argv);
		}
		else if (strcmp(*argv, "-nbio") == 0) {
			c_nbio = 1;
		}
		else if (strcmp(*argv, "-starttls") == 0) {
			if (--argc < 1)
				goto bad;
			++argv;
			if (strcmp(*argv, "smtp") == 0)
				starttls_proto = PROTO_SMTP;
			else if (strcmp(*argv, "lmtp") == 0)
				starttls_proto = PROTO_LMTP;
			else if (strcmp(*argv, "pop3") == 0)
				starttls_proto = PROTO_POP3;
			else if (strcmp(*argv, "imap") == 0)
				starttls_proto = PROTO_IMAP;
			else if (strcmp(*argv, "ftp") == 0)
				starttls_proto = PROTO_FTP;
			else if (strcmp(*argv, "xmpp") == 0)
				starttls_proto = PROTO_XMPP;
			else
				goto bad;
		}
#ifndef OPENSSL_NO_ENGINE
		else if (strcmp(*argv, "-engine") == 0) {
			if (--argc < 1)
				goto bad;
			engine_id = *(++argv);
		} else if (strcmp(*argv, "-ssl_client_engine") == 0) {
			if (--argc < 1)
				goto bad;
			ssl_client_engine_id = *(++argv);
		}
#endif
		else if (strcmp(*argv, "-4") == 0) {
			af = AF_INET;
		} else if (strcmp(*argv, "-6") == 0) {
			af = AF_INET6;
		}
#ifndef OPENSSL_NO_TLSEXT
		else if (strcmp(*argv, "-servername") == 0) {
			if (--argc < 1)
				goto bad;
			servername = *(++argv);
			/* meth=TLSv1_client_method(); */
		}
#endif
#ifndef OPENSSL_NO_SRTP
		else if (strcmp(*argv, "-use_srtp") == 0) {
			if (--argc < 1)
				goto bad;
			srtp_profiles = *(++argv);
		}
#endif
		else if (strcmp(*argv, "-keymatexport") == 0) {
			if (--argc < 1)
				goto bad;
			keymatexportlabel = *(++argv);
		} else if (strcmp(*argv, "-keymatexportlen") == 0) {
			const char *errstr;

			if (--argc < 1)
				goto bad;
			keymatexportlen = strtonum(*(++argv), 1, INT_MAX, &errstr);
			if (errstr)
				goto bad;
		} else {
			BIO_printf(bio_err, "unknown option %s\n", *argv);
			badop = 1;
			break;
		}
		argc--;
		argv++;
	}
	if (badop) {
bad:
		if (errstr)
			BIO_printf(bio_err, "invalid argument %s: %s\n",
			    *argv, errstr);
		else
			sc_usage();
		goto end;
	}

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	next_proto.status = -1;
	if (next_proto_neg_in) {
		next_proto.data = next_protos_parse(&next_proto.len, next_proto_neg_in);
		if (next_proto.data == NULL) {
			BIO_printf(bio_err, "Error parsing -nextprotoneg argument\n");
			goto end;
		}
	} else
		next_proto.data = NULL;
#endif

#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine_id, 1);
	if (ssl_client_engine_id) {
		ssl_client_engine = ENGINE_by_id(ssl_client_engine_id);
		if (!ssl_client_engine) {
			BIO_printf(bio_err,
			    "Error getting client auth engine\n");
			goto end;
		}
	}
#endif
	if (!app_passwd(bio_err, passarg, NULL, &pass, NULL)) {
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
	}
	if (key_file == NULL)
		key_file = cert_file;


	if (key_file) {

		key = load_key(bio_err, key_file, key_format, 0, pass, e,
		    "client certificate private key file");
		if (!key) {
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (cert_file) {
		cert = load_cert(bio_err, cert_file, cert_format,
		    NULL, e, "client certificate file");

		if (!cert) {
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (bio_c_out == NULL) {
		if (c_quiet && !c_debug && !c_msg) {
			bio_c_out = BIO_new(BIO_s_null());
		} else {
			if (bio_c_out == NULL)
				bio_c_out = BIO_new_fp(stdout, BIO_NOCLOSE);
		}
	}

	ctx = SSL_CTX_new(meth);
	if (ctx == NULL) {
		ERR_print_errors(bio_err);
		goto end;
	}
	if (vpm)
		SSL_CTX_set1_param(ctx, vpm);

#ifndef OPENSSL_NO_ENGINE
	if (ssl_client_engine) {
		if (!SSL_CTX_set_client_cert_engine(ctx, ssl_client_engine)) {
			BIO_puts(bio_err, "Error setting client auth engine\n");
			ERR_print_errors(bio_err);
			ENGINE_free(ssl_client_engine);
			goto end;
		}
		ENGINE_free(ssl_client_engine);
	}
#endif

#ifndef OPENSSL_NO_SRTP
	if (srtp_profiles != NULL)
		SSL_CTX_set_tlsext_use_srtp(ctx, srtp_profiles);
#endif
	if (bugs)
		SSL_CTX_set_options(ctx, SSL_OP_ALL | off);
	else
		SSL_CTX_set_options(ctx, off);

	if (clr)
		SSL_CTX_clear_options(ctx, clr);
	/*
	 * DTLS: partial reads end up discarding unread UDP bytes :-( Setting
	 * read ahead solves this problem.
	 */
	if (socket_type == SOCK_DGRAM)
		SSL_CTX_set_read_ahead(ctx, 1);

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	if (next_proto.data)
		SSL_CTX_set_next_proto_select_cb(ctx, next_proto_cb, &next_proto);
#endif

	if (state)
		SSL_CTX_set_info_callback(ctx, apps_ssl_info_callback);
	if (cipher != NULL)
		if (!SSL_CTX_set_cipher_list(ctx, cipher)) {
			BIO_printf(bio_err, "error setting cipher list\n");
			ERR_print_errors(bio_err);
			goto end;
		}

	SSL_CTX_set_verify(ctx, verify, verify_callback);
	if (!set_cert_key_stuff(ctx, cert, key))
		goto end;

	if ((!SSL_CTX_load_verify_locations(ctx, CAfile, CApath)) ||
	    (!SSL_CTX_set_default_verify_paths(ctx))) {
		/*
		 * BIO_printf(bio_err,"error setting default verify
		 * locations\n");
		 */
		ERR_print_errors(bio_err);
		/* goto end; */
	}
#ifndef OPENSSL_NO_TLSEXT
	if (servername != NULL) {
		tlsextcbp.biodebug = bio_err;
		SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);
		SSL_CTX_set_tlsext_servername_arg(ctx, &tlsextcbp);
	}
#endif

	con = SSL_new(ctx);
	if (sess_in) {
		SSL_SESSION *sess;
		BIO *stmp = BIO_new_file(sess_in, "r");
		if (!stmp) {
			BIO_printf(bio_err, "Can't open session file %s\n",
			    sess_in);
			ERR_print_errors(bio_err);
			goto end;
		}
		sess = PEM_read_bio_SSL_SESSION(stmp, NULL, 0, NULL);
		BIO_free(stmp);
		if (!sess) {
			BIO_printf(bio_err, "Can't open session file %s\n",
			    sess_in);
			ERR_print_errors(bio_err);
			goto end;
		}
		SSL_set_session(con, sess);
		SSL_SESSION_free(sess);
	}
#ifndef OPENSSL_NO_TLSEXT
	if (servername != NULL) {
		if (!SSL_set_tlsext_host_name(con, servername)) {
			BIO_printf(bio_err, "Unable to set TLS servername extension.\n");
			ERR_print_errors(bio_err);
			goto end;
		}
	}
#endif
/*	SSL_set_cipher_list(con,"RC4-MD5"); */

re_start:

	if (init_client(&s, host, port, socket_type, af) == 0) {
		BIO_printf(bio_err, "connect:errno=%d\n", errno);
		shutdown(s, SHUT_RD);
		close(s);
		goto end;
	}
	BIO_printf(bio_c_out, "CONNECTED(%08X)\n", s);

	if (c_nbio) {
		unsigned long l = 1;
		BIO_printf(bio_c_out, "turning on non blocking io\n");
		if (BIO_socket_ioctl(s, FIONBIO, &l) < 0) {
			ERR_print_errors(bio_err);
			goto end;
		}
	}
	if (c_Pause & 0x01)
		SSL_set_debug(con, 1);

	if (SSL_version(con) == DTLS1_VERSION) {

		sbio = BIO_new_dgram(s, BIO_NOCLOSE);
		if (getsockname(s, &peer, (void *) &peerlen) < 0) {
			BIO_printf(bio_err, "getsockname:errno=%d\n",
			    errno);
			shutdown(s, SHUT_RD);
			close(s);
			goto end;
		}
		(void) BIO_ctrl_set_connected(sbio, 1, &peer);

		if (enable_timeouts) {
			timeout.tv_sec = 0;
			timeout.tv_usec = DGRAM_RCV_TIMEOUT;
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);

			timeout.tv_sec = 0;
			timeout.tv_usec = DGRAM_SND_TIMEOUT;
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);
		}
		if (socket_mtu > 28) {
			SSL_set_options(con, SSL_OP_NO_QUERY_MTU);
			SSL_set_mtu(con, socket_mtu - 28);
		} else
			/* want to do MTU discovery */
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);
	} else
		sbio = BIO_new_socket(s, BIO_NOCLOSE);

	if (nbio_test) {
		BIO *test;

		test = BIO_new(BIO_f_nbio_test());
		sbio = BIO_push(test, sbio);
	}
	if (c_debug) {
		SSL_set_debug(con, 1);
		BIO_set_callback(sbio, bio_dump_callback);
		BIO_set_callback_arg(sbio, (char *) bio_c_out);
	}
	if (c_msg) {
		SSL_set_msg_callback(con, msg_cb);
		SSL_set_msg_callback_arg(con, bio_c_out);
	}
#ifndef OPENSSL_NO_TLSEXT
	if (c_tlsextdebug) {
		SSL_set_tlsext_debug_callback(con, tlsext_cb);
		SSL_set_tlsext_debug_arg(con, bio_c_out);
	}
	if (c_status_req) {
		SSL_set_tlsext_status_type(con, TLSEXT_STATUSTYPE_ocsp);
		SSL_CTX_set_tlsext_status_cb(ctx, ocsp_resp_cb);
		SSL_CTX_set_tlsext_status_arg(ctx, bio_c_out);
	}
#endif

	SSL_set_bio(con, sbio, sbio);
	SSL_set_connect_state(con);

	/* ok, lets connect */
	width = SSL_get_fd(con) + 1;

	read_tty = 1;
	write_tty = 0;
	tty_on = 0;
	read_ssl = 1;
	write_ssl = 1;

	cbuf_len = 0;
	cbuf_off = 0;
	sbuf_len = 0;
	sbuf_off = 0;

	/* This is an ugly hack that does a lot of assumptions */
	/*
	 * We do have to handle multi-line responses which may come in a
	 * single packet or not. We therefore have to use BIO_gets() which
	 * does need a buffering BIO. So during the initial chitchat we do
	 * push a buffering BIO into the chain that is removed again later on
	 * to not disturb the rest of the s_client operation.
	 */
	if (starttls_proto == PROTO_SMTP || starttls_proto == PROTO_LMTP) {
		int foundit = 0;
		BIO *fbio = BIO_new(BIO_f_buffer());
		BIO_push(fbio, sbio);
		/* wait for multi-line response to end from SMTP */
		do {
			mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);
		}
		while (mbuf_len > 3 && mbuf[3] == '-');
		/* STARTTLS command requires EHLO... */
		BIO_printf(fbio, "%cHLO openssl.client.net\r\n",
			   starttls_proto == PROTO_SMTP ? 'E' : 'L');
		(void) BIO_flush(fbio);
		/* wait for multi-line response to end EHLO SMTP response */
		do {
			mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);
			if (strstr(mbuf, "STARTTLS"))
				foundit = 1;
		}
		while (mbuf_len > 3 && mbuf[3] == '-');
		(void) BIO_flush(fbio);
		BIO_pop(fbio);
		BIO_free(fbio);
		if (!foundit)
			BIO_printf(bio_err,
			    "didn't found starttls in server response,"
			    " try anyway...\n");
		BIO_printf(sbio, "STARTTLS\r\n");
		BIO_read(sbio, sbuf, BUFSIZZ);
	} else if (starttls_proto == PROTO_POP3) {
		mbuf_len = BIO_read(sbio, mbuf, BUFSIZZ);
		if (mbuf_len == -1) {
			BIO_printf(bio_err, "BIO_read failed\n");
			goto end;
		}
		BIO_printf(sbio, "STLS\r\n");
		BIO_read(sbio, sbuf, BUFSIZZ);
	} else if (starttls_proto == PROTO_IMAP) {
		int foundit = 0;
		BIO *fbio = BIO_new(BIO_f_buffer());
		BIO_push(fbio, sbio);
		BIO_gets(fbio, mbuf, BUFSIZZ);
		/* STARTTLS command requires CAPABILITY... */
		BIO_printf(fbio, ". CAPABILITY\r\n");
		(void) BIO_flush(fbio);
		/* wait for multi-line CAPABILITY response */
		do {
			mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);
			if (strstr(mbuf, "STARTTLS"))
				foundit = 1;
		}
		while (mbuf_len > 3 && mbuf[0] != '.');
		(void) BIO_flush(fbio);
		BIO_pop(fbio);
		BIO_free(fbio);
		if (!foundit)
			BIO_printf(bio_err,
			    "didn't found STARTTLS in server response,"
			    " try anyway...\n");
		BIO_printf(sbio, ". STARTTLS\r\n");
		BIO_read(sbio, sbuf, BUFSIZZ);
	} else if (starttls_proto == PROTO_FTP) {
		BIO *fbio = BIO_new(BIO_f_buffer());
		BIO_push(fbio, sbio);
		/* wait for multi-line response to end from FTP */
		do {
			mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);
		}
		while (mbuf_len > 3 && mbuf[3] == '-');
		(void) BIO_flush(fbio);
		BIO_pop(fbio);
		BIO_free(fbio);
		BIO_printf(sbio, "AUTH TLS\r\n");
		BIO_read(sbio, sbuf, BUFSIZZ);
	}
	if (starttls_proto == PROTO_XMPP) {
		int seen = 0;
		BIO_printf(sbio, "<stream:stream "
		    "xmlns:stream='http://etherx.jabber.org/streams' "
		    "xmlns='jabber:client' to='%s' version='1.0'>", host);
		seen = BIO_read(sbio, mbuf, BUFSIZZ);
		mbuf[seen] = 0;
		while (!strstr(mbuf, "<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'")) {
			if (strstr(mbuf, "/stream:features>"))
				goto shut;
			seen = BIO_read(sbio, mbuf, BUFSIZZ);
			mbuf[seen] = 0;
		}
		BIO_printf(sbio, "<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>");
		seen = BIO_read(sbio, sbuf, BUFSIZZ);
		sbuf[seen] = 0;
		if (!strstr(sbuf, "<proceed"))
			goto shut;
		mbuf[0] = 0;
	}
	for (;;) {
		FD_ZERO(&readfds);
		FD_ZERO(&writefds);

		if ((SSL_version(con) == DTLS1_VERSION) &&
		    DTLSv1_get_timeout(con, &timeout))
			timeoutp = &timeout;
		else
			timeoutp = NULL;

		if (SSL_in_init(con) && !SSL_total_renegotiations(con)) {
			in_init = 1;
			tty_on = 0;
		} else {
			tty_on = 1;
			if (in_init) {
				in_init = 0;
				if (sess_out) {
					BIO *stmp = BIO_new_file(sess_out, "w");
					if (stmp) {
						PEM_write_bio_SSL_SESSION(stmp, SSL_get_session(con));
						BIO_free(stmp);
					} else
						BIO_printf(bio_err, "Error writing session file %s\n", sess_out);
				}
				print_stuff(bio_c_out, con, full_log);
				if (full_log > 0)
					full_log--;

				if (starttls_proto) {
					BIO_write(bio_err, mbuf, mbuf_len);
					/* We don't need to know any more */
					starttls_proto = PROTO_OFF;
				}
				if (reconnect) {
					reconnect--;
					BIO_printf(bio_c_out, "drop connection and then reconnect\n");
					SSL_shutdown(con);
					SSL_set_connect_state(con);
					shutdown(SSL_get_fd(con), SHUT_RD);
					close(SSL_get_fd(con));
					goto re_start;
				}
			}
		}

		ssl_pending = read_ssl && SSL_pending(con);

		/* XXX should add tests for fd_set overflow */

		if (!ssl_pending) {
			if (tty_on) {
				if (read_tty)
					FD_SET(fileno(stdin), &readfds);
				if (write_tty)
					FD_SET(fileno(stdout), &writefds);
			}
			if (read_ssl)
				FD_SET(SSL_get_fd(con), &readfds);
			if (write_ssl)
				FD_SET(SSL_get_fd(con), &writefds);
/*			printf("mode tty(%d %d%d) ssl(%d%d)\n",
				tty_on,read_tty,write_tty,read_ssl,write_ssl);*/

			i = select(width, &readfds, &writefds,
			    NULL, timeoutp);
			if (i < 0) {
				BIO_printf(bio_err, "bad select %d\n",
				    errno);
				goto shut;
				/* goto end; */
			}
		}
		if ((SSL_version(con) == DTLS1_VERSION) && DTLSv1_handle_timeout(con) > 0) {
			BIO_printf(bio_err, "TIMEOUT occured\n");
		}
		if (!ssl_pending && FD_ISSET(SSL_get_fd(con), &writefds)) {
			k = SSL_write(con, &(cbuf[cbuf_off]),
			    (unsigned int) cbuf_len);
			switch (SSL_get_error(con, k)) {
			case SSL_ERROR_NONE:
				cbuf_off += k;
				cbuf_len -= k;
				if (k <= 0)
					goto end;
				/* we have done a  write(con,NULL,0); */
				if (cbuf_len <= 0) {
					read_tty = 1;
					write_ssl = 0;
				} else {	/* if (cbuf_len > 0) */
					read_tty = 0;
					write_ssl = 1;
				}
				break;
			case SSL_ERROR_WANT_WRITE:
				BIO_printf(bio_c_out, "write W BLOCK\n");
				write_ssl = 1;
				read_tty = 0;
				break;
			case SSL_ERROR_WANT_READ:
				BIO_printf(bio_c_out, "write R BLOCK\n");
				write_tty = 0;
				read_ssl = 1;
				write_ssl = 0;
				break;
			case SSL_ERROR_WANT_X509_LOOKUP:
				BIO_printf(bio_c_out, "write X BLOCK\n");
				break;
			case SSL_ERROR_ZERO_RETURN:
				if (cbuf_len != 0) {
					BIO_printf(bio_c_out, "shutdown\n");
					ret = 0;
					goto shut;
				} else {
					read_tty = 1;
					write_ssl = 0;
					break;
				}

			case SSL_ERROR_SYSCALL:
				if ((k != 0) || (cbuf_len != 0)) {
					BIO_printf(bio_err, "write:errno=%d\n",
					    errno);
					goto shut;
				} else {
					read_tty = 1;
					write_ssl = 0;
				}
				break;
			case SSL_ERROR_SSL:
				ERR_print_errors(bio_err);
				goto shut;
			}
		} else if (!ssl_pending && FD_ISSET(fileno(stdout), &writefds)) {
			i = write(fileno(stdout), &(sbuf[sbuf_off]), sbuf_len);

			if (i <= 0) {
				BIO_printf(bio_c_out, "DONE\n");
				ret = 0;
				goto shut;
				/* goto end; */
			}
			sbuf_len -= i;
			sbuf_off += i;
			if (sbuf_len <= 0) {
				read_ssl = 1;
				write_tty = 0;
			}
		} else if (ssl_pending || FD_ISSET(SSL_get_fd(con), &readfds)) {
#ifdef RENEG
			{
				static int iiii;
				if (++iiii == 52) {
					SSL_renegotiate(con);
					iiii = 0;
				}
			}
#endif
			k = SSL_read(con, sbuf, 1024 /* BUFSIZZ */ );

			switch (SSL_get_error(con, k)) {
			case SSL_ERROR_NONE:
				if (k <= 0)
					goto end;
				sbuf_off = 0;
				sbuf_len = k;

				read_ssl = 0;
				write_tty = 1;
				break;
			case SSL_ERROR_WANT_WRITE:
				BIO_printf(bio_c_out, "read W BLOCK\n");
				write_ssl = 1;
				read_tty = 0;
				break;
			case SSL_ERROR_WANT_READ:
				BIO_printf(bio_c_out, "read R BLOCK\n");
				write_tty = 0;
				read_ssl = 1;
				if ((read_tty == 0) && (write_ssl == 0))
					write_ssl = 1;
				break;
			case SSL_ERROR_WANT_X509_LOOKUP:
				BIO_printf(bio_c_out, "read X BLOCK\n");
				break;
			case SSL_ERROR_SYSCALL:
				ret = errno;
				BIO_printf(bio_err, "read:errno=%d\n", ret);
				goto shut;
			case SSL_ERROR_ZERO_RETURN:
				BIO_printf(bio_c_out, "closed\n");
				ret = 0;
				goto shut;
			case SSL_ERROR_SSL:
				ERR_print_errors(bio_err);
				goto shut;
				/* break; */
			}
		} else if (FD_ISSET(fileno(stdin), &readfds)) {
			if (crlf) {
				int j, lf_num;

				i = read(fileno(stdin), cbuf, BUFSIZZ / 2);
				lf_num = 0;
				/* both loops are skipped when i <= 0 */
				for (j = 0; j < i; j++)
					if (cbuf[j] == '\n')
						lf_num++;
				for (j = i - 1; j >= 0; j--) {
					cbuf[j + lf_num] = cbuf[j];
					if (cbuf[j] == '\n') {
						lf_num--;
						i++;
						cbuf[j + lf_num] = '\r';
					}
				}
				assert(lf_num == 0);
			} else
				i = read(fileno(stdin), cbuf, BUFSIZZ);

			if ((!c_ign_eof) && ((i <= 0) || (cbuf[0] == 'Q'))) {
				BIO_printf(bio_err, "DONE\n");
				ret = 0;
				goto shut;
			}
			if ((!c_ign_eof) && (cbuf[0] == 'R')) {
				BIO_printf(bio_err, "RENEGOTIATING\n");
				SSL_renegotiate(con);
				cbuf_len = 0;
			} else {
				cbuf_len = i;
				cbuf_off = 0;
			}

			write_ssl = 1;
			read_tty = 0;
		}
	}

	ret = 0;
shut:
	if (in_init)
		print_stuff(bio_c_out, con, full_log);
	SSL_shutdown(con);
	shutdown(SSL_get_fd(con), SHUT_RD);
	close(SSL_get_fd(con));
end:
	if (con != NULL) {
		if (prexit != 0)
			print_stuff(bio_c_out, con, 1);
		SSL_free(con);
	}
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	free(next_proto.data);
#endif
	if (ctx != NULL)
		SSL_CTX_free(ctx);
	if (cert)
		X509_free(cert);
	if (key)
		EVP_PKEY_free(key);
	free(pass);
	if (vpm)
		X509_VERIFY_PARAM_free(vpm);
	if (cbuf != NULL) {
		OPENSSL_cleanse(cbuf, BUFSIZZ);
		free(cbuf);
	}
	if (sbuf != NULL) {
		OPENSSL_cleanse(sbuf, BUFSIZZ);
		free(sbuf);
	}
	if (mbuf != NULL) {
		OPENSSL_cleanse(mbuf, BUFSIZZ);
		free(mbuf);
	}
	if (bio_c_out != NULL) {
		BIO_free(bio_c_out);
		bio_c_out = NULL;
	}

	return (ret);
}


static void
print_stuff(BIO * bio, SSL * s, int full)
{
	X509 *peer = NULL;
	char *p;
	static const char *space = "                ";
	char buf[BUFSIZ];
	STACK_OF(X509) * sk;
	STACK_OF(X509_NAME) * sk2;
	const SSL_CIPHER *c;
	X509_NAME *xn;
	int j, i;
	unsigned char *exportedkeymat;

	if (full) {
		int got_a_chain = 0;

		sk = SSL_get_peer_cert_chain(s);
		if (sk != NULL) {
			got_a_chain = 1;	/* we don't have it for SSL2
						 * (yet) */

			BIO_printf(bio, "---\nCertificate chain\n");
			for (i = 0; i < sk_X509_num(sk); i++) {
				X509_NAME_oneline(X509_get_subject_name(
					sk_X509_value(sk, i)), buf, sizeof buf);
				BIO_printf(bio, "%2d s:%s\n", i, buf);
				X509_NAME_oneline(X509_get_issuer_name(
					sk_X509_value(sk, i)), buf, sizeof buf);
				BIO_printf(bio, "   i:%s\n", buf);
				if (c_showcerts)
					PEM_write_bio_X509(bio, sk_X509_value(sk, i));
			}
		}
		BIO_printf(bio, "---\n");
		peer = SSL_get_peer_certificate(s);
		if (peer != NULL) {
			BIO_printf(bio, "Server certificate\n");
			if (!(c_showcerts && got_a_chain))	/* Redundant if we
								 * showed the whole
								 * chain */
				PEM_write_bio_X509(bio, peer);
			X509_NAME_oneline(X509_get_subject_name(peer),
			    buf, sizeof buf);
			BIO_printf(bio, "subject=%s\n", buf);
			X509_NAME_oneline(X509_get_issuer_name(peer),
			    buf, sizeof buf);
			BIO_printf(bio, "issuer=%s\n", buf);
		} else
			BIO_printf(bio, "no peer certificate available\n");

		sk2 = SSL_get_client_CA_list(s);
		if ((sk2 != NULL) && (sk_X509_NAME_num(sk2) > 0)) {
			BIO_printf(bio, "---\nAcceptable client certificate CA names\n");
			for (i = 0; i < sk_X509_NAME_num(sk2); i++) {
				xn = sk_X509_NAME_value(sk2, i);
				X509_NAME_oneline(xn, buf, sizeof(buf));
				BIO_write(bio, buf, strlen(buf));
				BIO_write(bio, "\n", 1);
			}
		} else {
			BIO_printf(bio, "---\nNo client certificate CA names sent\n");
		}
		p = SSL_get_shared_ciphers(s, buf, sizeof buf);
		if (p != NULL) {
			/*
			 * This works only for SSL 2.  In later protocol
			 * versions, the client does not know what other
			 * ciphers (in addition to the one to be used in the
			 * current connection) the server supports.
			 */

			BIO_printf(bio, "---\nCiphers common between both SSL endpoints:\n");
			j = i = 0;
			while (*p) {
				if (*p == ':') {
					BIO_write(bio, space, 15 - j % 25);
					i++;
					j = 0;
					BIO_write(bio, ((i % 3) ? " " : "\n"), 1);
				} else {
					BIO_write(bio, p, 1);
					j++;
				}
				p++;
			}
			BIO_write(bio, "\n", 1);
		}
		BIO_printf(bio, "---\nSSL handshake has read %ld bytes and written %ld bytes\n",
		    BIO_number_read(SSL_get_rbio(s)),
		    BIO_number_written(SSL_get_wbio(s)));
	}
	BIO_printf(bio, (SSL_cache_hit(s) ? "---\nReused, " : "---\nNew, "));
	c = SSL_get_current_cipher(s);
	BIO_printf(bio, "%s, Cipher is %s\n",
	    SSL_CIPHER_get_version(c),
	    SSL_CIPHER_get_name(c));
	if (peer != NULL) {
		EVP_PKEY *pktmp;
		pktmp = X509_get_pubkey(peer);
		BIO_printf(bio, "Server public key is %d bit\n",
		    EVP_PKEY_bits(pktmp));
		EVP_PKEY_free(pktmp);
	}
	BIO_printf(bio, "Secure Renegotiation IS%s supported\n",
	    SSL_get_secure_renegotiation_support(s) ? "" : " NOT");

	/* Compression is not supported and will always be none. */
	BIO_printf(bio, "Compression: NONE\n");
	BIO_printf(bio, "Expansion: NONE\n");

#ifdef SSL_DEBUG
	{
		/* Print out local port of connection: useful for debugging */
		int sock;
		struct sockaddr_in ladd;
		socklen_t ladd_size = sizeof(ladd);
		sock = SSL_get_fd(s);
		getsockname(sock, (struct sockaddr *) & ladd, &ladd_size);
		BIO_printf(bio_c_out, "LOCAL PORT is %u\n", ntohs(ladd.sin_port));
	}
#endif

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	if (next_proto.status != -1) {
		const unsigned char *proto;
		unsigned int proto_len;
		SSL_get0_next_proto_negotiated(s, &proto, &proto_len);
		BIO_printf(bio, "Next protocol: (%d) ", next_proto.status);
		BIO_write(bio, proto, proto_len);
		BIO_write(bio, "\n", 1);
	}
#endif

#ifndef OPENSSL_NO_SRTP
	{
		SRTP_PROTECTION_PROFILE *srtp_profile = SSL_get_selected_srtp_profile(s);

		if (srtp_profile)
			BIO_printf(bio, "SRTP Extension negotiated, profile=%s\n",
			    srtp_profile->name);
	}
#endif

	SSL_SESSION_print(bio, SSL_get_session(s));
	if (keymatexportlabel != NULL) {
		BIO_printf(bio, "Keying material exporter:\n");
		BIO_printf(bio, "    Label: '%s'\n", keymatexportlabel);
		BIO_printf(bio, "    Length: %i bytes\n", keymatexportlen);
		exportedkeymat = malloc(keymatexportlen);
		if (exportedkeymat != NULL) {
			if (!SSL_export_keying_material(s, exportedkeymat,
				keymatexportlen,
				keymatexportlabel,
				strlen(keymatexportlabel),
				NULL, 0, 0)) {
				BIO_printf(bio, "    Error\n");
			} else {
				BIO_printf(bio, "    Keying material: ");
				for (i = 0; i < keymatexportlen; i++)
					BIO_printf(bio, "%02X",
					    exportedkeymat[i]);
				BIO_printf(bio, "\n");
			}
			free(exportedkeymat);
		}
	}
	BIO_printf(bio, "---\n");
	if (peer != NULL)
		X509_free(peer);
	/* flush, or debugging output gets mixed with http response */
	(void) BIO_flush(bio);
}

#ifndef OPENSSL_NO_TLSEXT

static int
ocsp_resp_cb(SSL * s, void *arg)
{
	const unsigned char *p;
	int len;
	OCSP_RESPONSE *rsp;
	len = SSL_get_tlsext_status_ocsp_resp(s, &p);
	BIO_puts(arg, "OCSP response: ");
	if (!p) {
		BIO_puts(arg, "no response sent\n");
		return 1;
	}
	rsp = d2i_OCSP_RESPONSE(NULL, &p, len);
	if (!rsp) {
		BIO_puts(arg, "response parse error\n");
		BIO_dump_indent(arg, (char *) p, len, 4);
		return 0;
	}
	BIO_puts(arg, "\n======================================\n");
	OCSP_RESPONSE_print(arg, rsp, 0);
	BIO_puts(arg, "======================================\n");
	OCSP_RESPONSE_free(rsp);
	return 1;
}

#endif
@


1.70
log
@Include <sys/select.h> to get select

These files currently depends on the wrapper <stdlib.h> file indirectly
including a header that provides select().

from Jonas 'Sortie' Termansen

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_client.c,v 1.69 2014/07/14 00:35:10 deraadt Exp $ */
@


1.69
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: s_client.c,v 1.68 2014/07/12 19:31:21 jsing Exp $ */
d140 1
@


1.68
log
@In openssl_startup(), call SSL_library_init() and SSL_load_error_strings().
This allows us to remove the ERR_load_crypto_strings() call, along with
the various SSL_load_error_strings() and OpenSSL_add_ssl_algorithms()
calls scattered around the place.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_client.c,v 1.67 2014/07/12 17:54:31 jsing Exp $ */
d202 1
a202 1
static void 
d279 1
a279 1
static int 
d306 1
a306 1
static int 
d341 1
a341 1
int 
d439 1
a439 1
				goto bad;			
d1300 1
a1300 1
	
d1305 1
a1305 1
static void 
d1481 1
a1481 1
static int 
@


1.67
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_client.c,v 1.66 2014/07/11 09:24:44 beck Exp $ */
a657 3

	OpenSSL_add_ssl_algorithms();
	SSL_load_error_strings();
@


1.66
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s_client.c,v 1.65 2014/07/10 09:30:53 jsing Exp $ */
a403 3

	if (!load_config(bio_err, NULL))
		goto end;
@


1.65
log
@Tame the tedu... we still want to know that Compression and Expansion are
NONE, even if this is due to the fact that we do not support compression.
@
text
@d1 1
a1 1
/* $OpenBSD: s_client.c,v 1.64 2014/07/10 09:15:51 tedu Exp $ */
a200 64
#ifndef OPENSSL_NO_PSK
/* Default PSK identity and key */
static char *psk_identity = "Client_identity";
/*char *psk_key=NULL;  by default PSK is not used */

static unsigned int 
psk_client_cb(SSL * ssl, const char *hint, char *identity,
    unsigned int max_identity_len, unsigned char *psk,
    unsigned int max_psk_len)
{
	unsigned int psk_len = 0;
	size_t maxlen = 0;
	int ret;
	BIGNUM *bn = NULL;

	if (c_debug)
		BIO_printf(bio_c_out, "psk_client_cb\n");
	if (max_identity_len > INT_MAX)
		goto out_err;
	maxlen = max_identity_len;
	if (!hint) {
		/* no ServerKeyExchange message */
		if (c_debug)
			BIO_printf(bio_c_out, "NULL received PSK identity hint, continuing anyway\n");
	} else if (c_debug)
		BIO_printf(bio_c_out, "Received PSK identity hint '%s'\n", hint);

	/*
	 * lookup PSK identity and PSK key based on the given identity hint
	 * here
	 */
	ret = snprintf(identity, maxlen, "%s", psk_identity);
	if (ret == -1 || ret >= maxlen)
		goto out_err;
	if (c_debug)
		BIO_printf(bio_c_out, "created identity '%s' len=%d\n", identity, ret);
	ret = BN_hex2bn(&bn, psk_key);
	if (!ret) {
		BIO_printf(bio_err, "Could not convert PSK key '%s' to BIGNUM\n", psk_key);
		if (bn)
			BN_free(bn);
		return 0;
	}
	if ((unsigned int) BN_num_bytes(bn) > max_psk_len) {
		BIO_printf(bio_err, "psk buffer of callback is too small (%d) for key (%d)\n",
		    max_psk_len, BN_num_bytes(bn));
		BN_free(bn);
		return 0;
	}
	psk_len = BN_bn2bin(bn, psk);
	BN_free(bn);
	if (psk_len == 0)
		goto out_err;

	if (c_debug)
		BIO_printf(bio_c_out, "created PSK len=%d\n", psk_len);

	return psk_len;
out_err:
	if (c_debug)
		BIO_printf(bio_err, "Error in PSK client callback\n");
	return 0;
}
#endif
a233 4
#ifndef OPENSSL_NO_PSK
	BIO_printf(bio_err, " -psk_identity arg - PSK identity\n");
	BIO_printf(bio_err, " -psk arg      - PSK in hex (without 0x)\n");
#endif
a494 19
#ifndef OPENSSL_NO_PSK
		else if (strcmp(*argv, "-psk_identity") == 0) {
			if (--argc < 1)
				goto bad;
			psk_identity = *(++argv);
		} else if (strcmp(*argv, "-psk") == 0) {
			size_t j;

			if (--argc < 1)
				goto bad;
			psk_key = *(++argv);
			for (j = 0; j < strlen(psk_key); j++) {
				if (isxdigit((unsigned char) psk_key[j]))
					continue;
				BIO_printf(bio_err, "Not a hex number '%s'\n", *argv);
				goto bad;
			}
		}
#endif
a742 7
#ifndef OPENSSL_NO_PSK
	if (psk_key != NULL) {
		if (c_debug)
			BIO_printf(bio_c_out, "PSK key given, setting client callback\n");
		SSL_CTX_set_psk_client_callback(ctx, psk_client_cb);
	}
#endif
@


1.64
log
@forgot to decompress here too
@
text
@d1 1
a1 1
/* $OpenBSD: s_client.c,v 1.63 2014/07/09 20:59:41 tedu Exp $ */
d1511 4
@


1.63
log
@clean up if 0/if 1 code. we don't care anymore.
@
text
@d1 1
a1 1
/* $OpenBSD: s_client.c,v 1.62 2014/06/28 04:39:41 deraadt Exp $ */
a1416 3
#ifndef OPENSSL_NO_COMP
	const COMP_METHOD *comp, *expansion;
#endif
a1510 8
#ifndef OPENSSL_NO_COMP
	comp = SSL_get_current_compression(s);
	expansion = SSL_get_current_expansion(s);
	BIO_printf(bio, "Compression: %s\n",
	    comp ? SSL_COMP_get_name(comp) : "NONE");
	BIO_printf(bio, "Expansion: %s\n",
	    expansion ? SSL_COMP_get_name(expansion) : "NONE");
#endif
@


1.62
log
@Use strtonum() instead of atoi(), and then impose what are we think
are the current range checks.  Help from millert and lteo.  Please test
now that it is deployed and let us know if any numbers are off..
ok lteo
@
text
@d1 1
a1 1
/* $OpenBSD: s_client.c,v 1.61 2014/06/13 04:29:13 miod Exp $ */
a867 4
#if 0
		else
			SSL_CTX_set_cipher_list(ctx, getenv("SSL_CIPHER"));
#endif
a996 11
#if 0
		{
			STACK_OF(OCSP_RESPID) * ids = sk_OCSP_RESPID_new_null();
			OCSP_RESPID *id = OCSP_RESPID_new();
			id->value.byKey = ASN1_OCTET_STRING_new();
			id->type = V_OCSP_RESPID_KEY;
			ASN1_STRING_set(id->value.byKey, "Hello World", -1);
			sk_OCSP_RESPID_push(ids, id);
			SSL_set_tlsext_status_ids(con, ids);
		}
#endif
a1136 9
#if 0
				/* This test doesn't really work as intended
				 * (needs to be fixed) */
#ifndef OPENSSL_NO_TLSEXT
				if (servername != NULL && !SSL_session_reused(con)) {
					BIO_printf(bio_c_out, "Server did %sacknowledge servername extension.\n", tlsextcbp.ack ? "" : "not ");
				}
#endif
#endif
a1277 1
#if 1
a1278 8
#else
/* Demo for pending and peek :-) */
			k = SSL_read(con, sbuf, 16);
			{
				char zbuf[10240];
				printf("read=%d pending=%d peek=%d\n", k, SSL_pending(con), SSL_peek(con, zbuf, 10240));
			}
#endif
@


1.61
log
@Remove support for the `opaque PRF input' extension, which draft has expired
7 years ago and never made it into an RFC. That code wasn't compiled in
anyway unless one would define the actual on-the-wire extension id bytes;
crank libssl major.

With help and enlightenment from Brendan MacDonell.
@
text
@d1 1
a1 1
/* $OpenBSD: s_client.c,v 1.60 2014/06/12 15:49:27 deraadt Exp $ */
d150 1
d442 1
d508 3
a510 1
			verify_depth = atoi(*(++argv));
d599 3
a601 1
			socket_mtu = atol(*(++argv));
d724 2
d728 2
a729 2
			keymatexportlen = atoi(*(++argv));
			if (keymatexportlen == 0)
d741 5
a745 1
		sc_usage();
@


1.60
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a912 5
#if 0
#ifdef TLSEXT_TYPE_opaque_prf_input
	SSL_set_tlsext_opaque_prf_input(con, "Test client", 11);
#endif
#endif
@


1.59
log
@Stop pretending that openssl(1) applications support the -rand option.
The underlying code has long been removed, making this a no-op.

If your random subsystem actually requires that you seed it from a file,
then you really should go and buy a new random subsystem that was built
after 1990.

Diff from Brent Cook.

ok deraadt@@
@
text
@d1 1
a1 1
/* apps/s_client.c */
@


1.58
log
@There is no need to include <openssl/e_os2.h> here, except for the fact
that it brings in <openssl/opensslconf.h>, so just do that instead
(currently via apps.h).
@
text
@a318 1
	BIO_printf(bio_err, " -rand file:file:...\n");
a438 1
	char *inrand = NULL;
d693 1
a693 5
		else if (strcmp(*argv, "-rand") == 0) {
			if (--argc < 1)
				goto bad;
			inrand = *(++argv);
		} else if (strcmp(*argv, "-4") == 0) {
@


1.57
log
@There is little interest in supporting Watt-32 TCP/IP debugging.  For
reference, check out http://www.watt-32.net/
ok jsing
@
text
@a155 1
#include <openssl/e_os2.h>
@


1.56
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@a289 3
#ifdef WATT32
	BIO_printf(bio_err, " -wdebug       - WATT-32 tcp debugging\n");
#endif
a552 4
#endif
#ifdef WATT32
		else if (strcmp(*argv, "-wdebug") == 0)
			dbug_init();
@


1.55
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a469 1
	signal(SIGPIPE, SIG_IGN);
@


1.54
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d1414 1
a1414 2
	if (next_proto.data)
		free(next_proto.data);
d1422 1
a1422 2
	if (pass)
		free(pass);
@


1.53
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d140 1
d143 1
d146 2
a149 1
#include <limits.h>
a151 4
#include <openssl/e_os2.h>
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
d154 3
a156 2
#include <openssl/x509.h>
#include <openssl/ssl.h>
d158 1
d161 3
a163 2
#include <openssl/ocsp.h>
#include <openssl/bn.h>
a165 2


@


1.52
log
@less than jpake
@
text
@a477 3
	if (bio_err == NULL)
		bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);

@


1.51
log
@remove Kerberos
@
text
@a303 3
#ifndef OPENSSL_NO_JPAKE
	BIO_printf(bio_err, " -jpake arg    - JPAKE secret to use\n");
#endif
a466 3
#ifndef OPENSSL_NO_JPAKE
	char *jpake_secret = NULL;
#endif
a723 7
#ifndef OPENSSL_NO_JPAKE
		else if (strcmp(*argv, "-jpake") == 0) {
			if (--argc < 1)
				goto bad;
			jpake_secret = *++argv;
		}
#endif
a753 15
#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)
	if (jpake_secret) {
		if (psk_key) {
			BIO_printf(bio_err,
			    "Can't use JPAKE and PSK together\n");
			goto end;
		}
		psk_identity = "JPAKE";
		if (cipher) {
			BIO_printf(bio_err, "JPAKE sets cipher to PSK\n");
			goto end;
		}
		cipher = "PSK";
	}
#endif
d837 1
a837 6
#ifdef OPENSSL_NO_JPAKE
	if (psk_key != NULL)
#else
	if (psk_key != NULL || jpake_secret)
#endif
	{
d839 1
a839 1
			BIO_printf(bio_c_out, "PSK key given or JPAKE in use, setting client callback\n");
a1023 4
#endif
#ifndef OPENSSL_NO_JPAKE
	if (jpake_secret)
		jpake_client_auth(bio_c_out, sbio, jpake_secret);
@


1.50
log
@bye bye SRP
@
text
@a420 3
#ifndef OPENSSL_NO_KRB5
	KSSL_CTX *kctx;
#endif
a962 6
#ifndef OPENSSL_NO_KRB5
	if (con && (kctx = kssl_ctx_new()) != NULL) {
		SSL_set0_kssl_ctx(con, kctx);
		kssl_ctx_setstring(kctx, KSSL_SERVER, host);
	}
#endif				/* OPENSSL_NO_KRB5  */
@


1.49
log
@During the great e_os.h nukathon we stopped pulling in <sys/filio.h> via
the ifdef maze, meaning that FIONBIO was no longer defined. This removes
non-blocking I/O support from s_{client,server,time}.

Remove all FIONBIO ifdefs and import <sys/ioctl.h>, renabling -nbio.

ok miod@@
@
text
@a161 3
#ifndef OPENSSL_NO_SRP
#include <openssl/srp.h>
#endif
a307 7
#ifndef OPENSSL_NO_SRP
	BIO_printf(bio_err, " -srpuser user     - SRP authentification for 'user'\n");
	BIO_printf(bio_err, " -srppass arg      - password for 'user'\n");
	BIO_printf(bio_err, " -srp_lateuser     - SRP username into second ClientHello message\n");
	BIO_printf(bio_err, " -srp_moregroups   - Tolerate other than the known g N values.\n");
	BIO_printf(bio_err, " -srp_strength int - minimal mength in bits for N (default %d).\n", SRP_MINIMAL_N);
#endif
a366 114
#ifndef OPENSSL_NO_SRP

/* This is a context that we pass to all callbacks */
typedef struct srp_arg_st {
	char *srppassin;
	char *srplogin;
	int msg;		/* copy from c_msg */
	int debug;		/* copy from c_debug */
	int amp;		/* allow more groups */
	int strength /* minimal size for N */ ;
} SRP_ARG;

#define SRP_NUMBER_ITERATIONS_FOR_PRIME 64

static int 
srp_Verify_N_and_g(BIGNUM * N, BIGNUM * g)
{
	BN_CTX *bn_ctx = BN_CTX_new();
	BIGNUM *p = BN_new();
	BIGNUM *r = BN_new();
	int ret =
	g != NULL && N != NULL && bn_ctx != NULL && BN_is_odd(N) &&
	BN_is_prime_ex(N, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) &&
	p != NULL && BN_rshift1(p, N) &&

	/* p = (N-1)/2 */
	BN_is_prime_ex(p, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) &&
	r != NULL &&

	/* verify g^((N-1)/2) == -1 (mod N) */
	BN_mod_exp(r, g, p, N, bn_ctx) &&
	BN_add_word(r, 1) &&
	BN_cmp(r, N) == 0;

	if (r)
		BN_free(r);
	if (p)
		BN_free(p);
	if (bn_ctx)
		BN_CTX_free(bn_ctx);
	return ret;
}

/* This callback is used here for two purposes:
   - extended debugging
   - making some primality tests for unknown groups
   The callback is only called for a non default group.

   An application does not need the call back at all if
   only the stanard groups are used.  In real life situations,
   client and server already share well known groups,
   thus there is no need to verify them.
   Furthermore, in case that a server actually proposes a group that
   is not one of those defined in RFC 5054, it is more appropriate
   to add the group to a static list and then compare since
   primality tests are rather cpu consuming.
*/

static int 
ssl_srp_verify_param_cb(SSL * s, void *arg)
{
	SRP_ARG *srp_arg = (SRP_ARG *) arg;
	BIGNUM *N = NULL, *g = NULL;
	if (!(N = SSL_get_srp_N(s)) || !(g = SSL_get_srp_g(s)))
		return 0;
	if (srp_arg->debug || srp_arg->msg || srp_arg->amp == 1) {
		BIO_printf(bio_err, "SRP parameters:\n");
		BIO_printf(bio_err, "\tN=");
		BN_print(bio_err, N);
		BIO_printf(bio_err, "\n\tg=");
		BN_print(bio_err, g);
		BIO_printf(bio_err, "\n");
	}
	if (SRP_check_known_gN_param(g, N))
		return 1;

	if (srp_arg->amp == 1) {
		if (srp_arg->debug)
			BIO_printf(bio_err, "SRP param N and g are not known params, going to check deeper.\n");

/* The srp_moregroups is a real debugging feature.
   Implementors should rather add the value to the known ones.
   The minimal size has already been tested.
*/
		if (BN_num_bits(g) <= BN_BITS && srp_Verify_N_and_g(N, g))
			return 1;
	}
	BIO_printf(bio_err, "SRP param N and g rejected.\n");
	return 0;
}

#define PWD_STRLEN 1024

static char *
ssl_give_srp_client_pwd_cb(SSL * s, void *arg)
{
	SRP_ARG *srp_arg = (SRP_ARG *) arg;
	char *pass = (char *) malloc(PWD_STRLEN + 1);
	PW_CB_DATA cb_tmp;
	int l;

	cb_tmp.password = (char *) srp_arg->srppassin;
	cb_tmp.prompt_info = "SRP user";
	if ((l = password_callback(pass, PWD_STRLEN, 0, &cb_tmp)) < 0) {
		BIO_printf(bio_err, "Can't read Password\n");
		free(pass);
		return NULL;
	}
	*(pass + l) = '\0';

	return pass;
}

#endif
a475 5
#ifndef OPENSSL_NO_SRP
	char *srppass = NULL;
	int srp_lateuser = 0;
	SRP_ARG srp_arg = {NULL, NULL, 0, 0, 0, 1024};
#endif
a600 25
#ifndef OPENSSL_NO_SRP
		else if (strcmp(*argv, "-srpuser") == 0) {
			if (--argc < 1)
				goto bad;
			srp_arg.srplogin = *(++argv);
			meth = TLSv1_client_method();
		} else if (strcmp(*argv, "-srppass") == 0) {
			if (--argc < 1)
				goto bad;
			srppass = *(++argv);
			meth = TLSv1_client_method();
		} else if (strcmp(*argv, "-srp_strength") == 0) {
			if (--argc < 1)
				goto bad;
			srp_arg.strength = atoi(*(++argv));
			BIO_printf(bio_err, "SRP minimal length for N is %d\n", srp_arg.strength);
			meth = TLSv1_client_method();
		} else if (strcmp(*argv, "-srp_lateuser") == 0) {
			srp_lateuser = 1;
			meth = TLSv1_client_method();
		} else if (strcmp(*argv, "-srp_moregroups") == 0) {
			srp_arg.amp = 1;
			meth = TLSv1_client_method();
		}
#endif
a845 6
#ifndef OPENSSL_NO_SRP
	if (!app_passwd(bio_err, srppass, NULL, &srp_arg.srppassin, NULL)) {
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
	}
#endif
a933 15
#ifndef OPENSSL_NO_SRP
	if (srp_arg.srplogin) {
		if (!srp_lateuser && !SSL_CTX_set_srp_username(ctx, srp_arg.srplogin)) {
			BIO_printf(bio_err, "Unable to set SRP username\n");
			goto end;
		}
		srp_arg.msg = c_msg;
		srp_arg.debug = c_debug;
		SSL_CTX_set_srp_cb_arg(ctx, &srp_arg);
		SSL_CTX_set_srp_client_pwd_callback(ctx, ssl_give_srp_client_pwd_cb);
		SSL_CTX_set_srp_strength(ctx, srp_arg.strength);
		if (c_msg || c_debug || srp_arg.amp == 0)
			SSL_CTX_set_srp_verify_param_callback(ctx, ssl_srp_verify_param_cb);
	}
#endif
@


1.48
log
@remove crazy #undefs; ok jsing
@
text
@d139 2
a181 1
#ifdef FIONBIO
a182 1
#endif
a298 1
#ifdef FIONBIO
a299 1
#endif
a629 1
#ifdef FIONBIO
a630 1
#endif
a836 1
#ifdef FIONBIO
a839 1
#endif
a1163 1
#ifdef FIONBIO
a1171 1
#endif
d1384 2
a1385 1
#if 0				/* This test doesn't really work as intended
@


1.47
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a173 1
#undef BUFSIZZ
@


1.46
log
@Nuke the last of the windows related defines from the openssl apps.

ok deraadt@@
@
text
@d611 1
a611 1
	apps_startup();
d1675 1
a1675 1
	apps_shutdown();
@


1.45
log
@remove the openssl_fdset wrapper, and a variety of VMS'ism's like
crazy (void *) casts all over the place
ok beck jsing
@
text
@a150 3
#ifdef OPENSSL_NO_STDIO
#define APPS_WIN16
#endif
@


1.44
log
@ReadFile() and GetStdHandle() are not very POSIX.
ok beck jsing
@
text
@d1435 2
d1440 1
a1440 1
					openssl_fdset(fileno(stdin), &readfds);
d1442 1
a1442 1
					openssl_fdset(fileno(stdout), &writefds);
d1445 1
a1445 1
				openssl_fdset(SSL_get_fd(con), &readfds);
d1447 1
a1447 1
				openssl_fdset(SSL_get_fd(con), &writefds);
d1451 1
a1451 9
			/*
			 * Note: under VMS with SOCKETSHR the second
			 * parameter is currently of type (int *) whereas
			 * under other systems it is (void *) if you don't
			 * have a cast it will choke the compiler: if you do
			 * have a cast then you can either go for (int *) or
			 * (void *).
			 */
			i = select(width, (void *) &readfds, (void *) &writefds,
@


1.43
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d1527 1
a1527 1
			i = raw_write_stdout(&(sbuf[sbuf_off]), sbuf_len);
d1604 1
a1604 1
				i = raw_read_stdin(cbuf, BUFSIZZ / 2);
d1620 1
a1620 1
				i = raw_read_stdin(cbuf, BUFSIZZ);
@


1.42
log
@Finish zapping SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION usage; only keep
the #define for compat, but document that it's a no-op now.  Also, neuter
the -legacy_renegotiation option to "openssl s_{client,server}"

ok beck@@
@
text
@a1001 8
	if (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL
	    && !RAND_status()) {
		BIO_printf(bio_err, "warning, not much extra random data, consider using the -rand option\n");
	}
	if (inrand != NULL)
		BIO_printf(bio_err, "%ld semi-random bytes loaded\n",
		    app_RAND_load_files(inrand));

@


1.41
log
@simplify file:file:... stuff
@
text
@d337 1
a337 1
	BIO_printf(bio_err, "                 only \"smtp\", \"pop3\", \"imap\", \"ftp\" and \"xmpp\"\n");
a353 1
	BIO_printf(bio_err, " -legacy_renegotiation - enable use of legacy renegotiation (dangerous)\n");
d537 1
d835 1
a835 1
			off |= SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
d856 2
d1292 1
a1292 1
	if (starttls_proto == PROTO_SMTP) {
d1302 2
a1303 1
		BIO_printf(fbio, "EHLO openssl.client.net\r\n");
@


1.40
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d342 1
a342 1
	BIO_printf(bio_err, " -rand file%cfile%c...\n", ':', ':');
@


1.39
log
@KaboomNF
@
text
@a169 2
#undef PROG
#define PROG	s_client_main
d544 1
a544 1
int MAIN(int, char **);
d547 1
a547 1
MAIN(int argc, char **argv)
@


1.38
log
@Remove support for unwanted operating systems.

ok miod@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d177 1
a177 1
/*#define TEST_CERT "client.pem" */ /* no default cert. */
d187 1
a187 1
static int c_nbio=0;
d189 2
a190 2
static int c_Pause=0;
static int c_debug=0;
d192 2
a193 2
static int c_tlsextdebug=0;
static int c_status_req=0;
d195 2
a196 2
static int c_msg=0;
static int c_showcerts=0;
d198 2
a199 2
static char *keymatexportlabel=NULL;
static int keymatexportlen=20;
d202 1
a202 1
static void print_stuff(BIO *berr,SSL *con,int full);
d204 1
a204 1
static int ocsp_resp_cb(SSL *s, void *arg);
d206 3
a208 3
static BIO *bio_c_out=NULL;
static int c_quiet=0;
static int c_ign_eof=0;
d212 1
a212 1
static char *psk_identity="Client_identity";
d215 5
a219 4
static unsigned int psk_client_cb(SSL *ssl, const char *hint, char *identity,
	unsigned int max_identity_len, unsigned char *psk,
	unsigned int max_psk_len)
	{
d223 1
a223 1
        BIGNUM *bn=NULL;
d230 2
a231 3
	if (!hint)
                {
                /* no ServerKeyExchange message*/
d233 2
a234 3
			BIO_printf(bio_c_out,"NULL received PSK identity hint, continuing anyway\n");
                }
        else if (c_debug)
d237 4
a240 1
	/* lookup PSK identity and PSK key based on the given identity hint here */
d246 17
a262 21
        ret=BN_hex2bn(&bn, psk_key);
        if (!ret)
                {
                BIO_printf(bio_err,"Could not convert PSK key '%s' to BIGNUM\n", psk_key);
                if (bn)
                        BN_free(bn);
                return 0;
                }

        if ((unsigned int)BN_num_bytes(bn) > max_psk_len)
                {
                BIO_printf(bio_err,"psk buffer of callback is too small (%d) for key (%d)\n",
                        max_psk_len, BN_num_bytes(bn));
                BN_free(bn);
                return 0;
                }

        psk_len=BN_bn2bin(bn, psk);
        BN_free(bn);
        if (psk_len == 0)
                goto out_err;
d267 2
a268 2
        return psk_len;
 out_err:
d271 2
a272 2
        return 0;
	}
d275 24
a298 23
static void sc_usage(void)
	{
	BIO_printf(bio_err,"usage: s_client args\n");
	BIO_printf(bio_err,"\n");
	BIO_printf(bio_err," -4            - Force IPv4\n");
	BIO_printf(bio_err," -6            - Force IPv6\n");
	BIO_printf(bio_err," -host host     - use -connect instead\n");
	BIO_printf(bio_err," -port port     - use -connect instead\n");
	BIO_printf(bio_err," -connect host:port - who to connect to (default is %s:%s)\n",SSL_HOST_NAME,PORT_STR);

	BIO_printf(bio_err," -verify arg   - turn on peer certificate verification\n");
	BIO_printf(bio_err," -cert arg     - certificate file to use, PEM format assumed\n");
	BIO_printf(bio_err," -certform arg - certificate format (PEM or DER) PEM default\n");
	BIO_printf(bio_err," -key arg      - Private key file to use, in cert file if\n");
	BIO_printf(bio_err,"                 not specified but cert file is.\n");
	BIO_printf(bio_err," -keyform arg  - key format (PEM or DER) PEM default\n");
	BIO_printf(bio_err," -pass arg     - private key file pass phrase source\n");
	BIO_printf(bio_err," -CApath arg   - PEM format directory of CA's\n");
	BIO_printf(bio_err," -CAfile arg   - PEM format file of CA's\n");
	BIO_printf(bio_err," -reconnect    - Drop and re-make the connection with the same Session-ID\n");
	BIO_printf(bio_err," -pause        - sleep(1) after each read(2) and write(2) system call\n");
	BIO_printf(bio_err," -showcerts    - show all certificates in the chain\n");
	BIO_printf(bio_err," -debug        - extra output\n");
d300 1
a300 1
	BIO_printf(bio_err," -wdebug       - WATT-32 tcp debugging\n");
d302 3
a304 3
	BIO_printf(bio_err," -msg          - Show protocol messages\n");
	BIO_printf(bio_err," -nbio_test    - more ssl protocol testing\n");
	BIO_printf(bio_err," -state        - print the 'ssl' states\n");
d306 1
a306 1
	BIO_printf(bio_err," -nbio         - Run with non-blocking IO\n");
d308 4
a311 4
	BIO_printf(bio_err," -crlf         - convert LF from terminal into CRLF\n");
	BIO_printf(bio_err," -quiet        - no s_client output\n");
	BIO_printf(bio_err," -ign_eof      - ignore input eof (default when -quiet)\n");
	BIO_printf(bio_err," -no_ign_eof   - don't ignore input eof\n");
d313 5
a317 5
	BIO_printf(bio_err," -psk_identity arg - PSK identity\n");
	BIO_printf(bio_err," -psk arg      - PSK in hex (without 0x)\n");
# ifndef OPENSSL_NO_JPAKE
	BIO_printf(bio_err," -jpake arg    - JPAKE secret to use\n");
# endif
d320 21
a340 21
	BIO_printf(bio_err," -srpuser user     - SRP authentification for 'user'\n");
	BIO_printf(bio_err," -srppass arg      - password for 'user'\n");
	BIO_printf(bio_err," -srp_lateuser     - SRP username into second ClientHello message\n");
	BIO_printf(bio_err," -srp_moregroups   - Tolerate other than the known g N values.\n");
	BIO_printf(bio_err," -srp_strength int - minimal mength in bits for N (default %d).\n",SRP_MINIMAL_N);
#endif
	BIO_printf(bio_err," -ssl3         - just use SSLv3\n");
	BIO_printf(bio_err," -tls1_2       - just use TLSv1.2\n");
	BIO_printf(bio_err," -tls1_1       - just use TLSv1.1\n");
	BIO_printf(bio_err," -tls1         - just use TLSv1\n");
	BIO_printf(bio_err," -dtls1        - just use DTLSv1\n");    
	BIO_printf(bio_err," -mtu          - set the link layer MTU\n");
	BIO_printf(bio_err," -no_tls1_2/-no_tls1_1/-no_tls1/-no_ssl3/-no_ssl2 - turn off that protocol\n");
	BIO_printf(bio_err," -bugs         - Switch on all SSL implementation bug workarounds\n");
	BIO_printf(bio_err," -cipher       - preferred cipher to use, use the 'openssl ciphers'\n");
	BIO_printf(bio_err,"                 command to see what is available\n");
	BIO_printf(bio_err," -starttls prot - use the STARTTLS command before starting TLS\n");
	BIO_printf(bio_err,"                 for those protocols that support it, where\n");
	BIO_printf(bio_err,"                 'prot' defines which one to assume.  Currently,\n");
	BIO_printf(bio_err,"                 only \"smtp\", \"pop3\", \"imap\", \"ftp\" and \"xmpp\"\n");
	BIO_printf(bio_err,"                 are supported.\n");
d342 1
a342 1
	BIO_printf(bio_err," -engine id    - Initialise and use the specified engine\n");
d344 3
a346 3
	BIO_printf(bio_err," -rand file%cfile%c...\n", ':', ':');
	BIO_printf(bio_err," -sess_out arg - file to write SSL session to\n");
	BIO_printf(bio_err," -sess_in arg  - file to read SSL session from\n");
d348 7
a354 7
	BIO_printf(bio_err," -servername host  - Set TLS extension servername in ClientHello\n");
	BIO_printf(bio_err," -tlsextdebug      - hex dump of all TLS extensions received\n");
	BIO_printf(bio_err," -status           - request certificate status from server\n");
	BIO_printf(bio_err," -no_ticket        - disable use of RFC4507bis session tickets\n");
# ifndef OPENSSL_NO_NEXTPROTONEG
	BIO_printf(bio_err," -nextprotoneg arg - enable NPN extension, considering named protocols supported (comma-separated list)\n");
# endif
d356 1
a356 1
	BIO_printf(bio_err," -legacy_renegotiation - enable use of legacy renegotiation (dangerous)\n");
d358 1
a358 1
	BIO_printf(bio_err," -use_srtp profiles - Offer SRTP key management with a colon-separated profile list\n");
d360 3
a362 3
 	BIO_printf(bio_err," -keymatexport label   - Export keying material using label\n");
 	BIO_printf(bio_err," -keymatexportlen len  - Export len bytes of keying material (default 20)\n");
	}
d368 2
a369 2
   BIO * biodebug;
   int ack;
d373 10
a382 9
static int ssl_servername_cb(SSL *s, int *ad, void *arg)
	{
	tlsextctx * p = (tlsextctx *) arg;
	const char * hn= SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);
	if (SSL_get_servername_type(s) != -1) 
 	        p->ack = !SSL_session_reused(s) && hn != NULL;
	else 
		BIO_printf(bio_err,"Can't use SSL_get_servername\n");
	
d384 1
a384 1
	}
d389 1
a389 2
typedef struct srp_arg_st
	{
d392 3
a394 3
	int msg;   /* copy from c_msg */
	int debug; /* copy from c_debug */
	int amp;   /* allow more groups */
d396 1
a396 1
	} SRP_ARG;
d400 3
a402 2
static int srp_Verify_N_and_g(BIGNUM *N, BIGNUM *g)
	{
d407 12
a418 12
		g != NULL && N != NULL && bn_ctx != NULL && BN_is_odd(N) &&
		BN_is_prime_ex(N, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) &&
		p != NULL && BN_rshift1(p, N) &&

		/* p = (N-1)/2 */
		BN_is_prime_ex(p, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) &&
		r != NULL &&

		/* verify g^((N-1)/2) == -1 (mod N) */
		BN_mod_exp(r, g, p, N, bn_ctx) &&
		BN_add_word(r, 1) &&
		BN_cmp(r, N) == 0;
d420 1
a420 1
	if(r)
d422 1
a422 1
	if(p)
d424 1
a424 1
	if(bn_ctx)
d427 1
a427 1
	}
d435 3
a437 3
   only the stanard groups are used.  In real life situations, 
   client and server already share well known groups, 
   thus there is no need to verify them. 
d439 2
a440 2
   is not one of those defined in RFC 5054, it is more appropriate 
   to add the group to a static list and then compare since 
d444 4
a447 3
static int ssl_srp_verify_param_cb(SSL *s, void *arg)
	{
	SRP_ARG *srp_arg = (SRP_ARG *)arg;
d451 9
a459 9
	if (srp_arg->debug || srp_arg->msg || srp_arg->amp == 1)
		{
    		BIO_printf(bio_err, "SRP parameters:\n"); 
		BIO_printf(bio_err,"\tN="); BN_print(bio_err,N);
		BIO_printf(bio_err,"\n\tg="); BN_print(bio_err,g);
		BIO_printf(bio_err,"\n");
		}

	if (SRP_check_known_gN_param(g,N))
d462 1
a462 2
	if (srp_arg->amp == 1)
		{
d470 1
a470 1
		if (BN_num_bits(g) <= BN_BITS && srp_Verify_N_and_g(N,g))
d472 1
a472 1
		}	
d475 1
a475 1
	}
d479 5
a483 4
static char * ssl_give_srp_client_pwd_cb(SSL *s, void *arg)
	{
	SRP_ARG *srp_arg = (SRP_ARG *)arg;
	char *pass = (char *)malloc(PWD_STRLEN+1);
d487 1
a487 1
	cb_tmp.password = (char *)srp_arg->srppassin;
d489 2
a490 3
	if ((l = password_callback(pass, PWD_STRLEN, 0, &cb_tmp))<0)
		{
		BIO_printf (bio_err, "Can't read Password\n");
d493 2
a494 2
		}
	*(pass+l)= '\0';
d497 1
a497 1
	}
d501 1
a501 1
	char *srtp_profiles = NULL;
d504 1
a504 1
# ifndef OPENSSL_NO_NEXTPROTONEG
d514 3
a516 2
static int next_proto_cb(SSL *s, unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg)
	{
d519 1
a519 2
	if (!c_quiet)
		{
d523 1
a523 2
		for (i = 0; i < inlen; )
			{
d528 1
a528 1
			}
d530 1
a530 2
		}

d533 2
a534 2
	}
# endif  /* ndef OPENSSL_NO_NEXTPROTONEG */
d537 2
a538 3
enum
{
	PROTO_OFF	= 0,
d548 5
a552 4
int MAIN(int argc, char **argv)
	{
	unsigned int off=0, clr=0;
	SSL *con=NULL;
d556 9
a564 9
	int s,k,width,state=0, af=AF_UNSPEC;
	char *cbuf=NULL,*sbuf=NULL,*mbuf=NULL;
	int cbuf_len,cbuf_off;
	int sbuf_len,sbuf_off;
	fd_set readfds,writefds;
	char *port=PORT_STR;
	int full_log=1;
	char *host=SSL_HOST_NAME;
	char *cert_file=NULL,*key_file=NULL;
d569 6
a574 6
	char *CApath=NULL,*CAfile=NULL,*cipher=NULL;
	int reconnect=0,badop=0,verify=SSL_VERIFY_NONE,bugs=0;
	int crlf=0;
	int write_tty,read_tty,write_ssl,read_ssl,tty_on,ssl_pending;
	SSL_CTX *ctx=NULL;
	int ret=1,in_init=1,i,nbio_test=0;
d579 2
a580 2
	const SSL_METHOD *meth=NULL;
	int socket_type=SOCK_STREAM;
d582 2
a583 2
	char *inrand=NULL;
	int mbuf_len=0;
d586 3
a588 3
	char *engine_id=NULL;
	char *ssl_client_engine_id=NULL;
	ENGINE *ssl_client_engine=NULL;
d590 1
a590 1
	ENGINE *e=NULL;
d592 4
a595 4
	char *servername = NULL; 
        tlsextctx tlsextcbp = 
        {NULL,0};
# ifndef OPENSSL_NO_NEXTPROTONEG
d597 1
a597 1
# endif
d603 1
a603 1
	int enable_timeouts = 0 ;
d609 1
a609 1
	char * srppass = NULL;
d611 1
a611 1
	SRP_ARG srp_arg = {NULL,NULL,0,0,0,1024};
d614 1
a614 1
	meth=SSLv23_client_method();
d617 6
a622 6
	c_Pause=0;
	c_quiet=0;
	c_ign_eof=0;
	c_debug=0;
	c_msg=0;
	c_showcerts=0;
d625 1
a625 1
		bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
d630 4
a633 5
	if (	((cbuf=malloc(BUFSIZZ)) == NULL) ||
		((sbuf=malloc(BUFSIZZ)) == NULL) ||
		((mbuf=malloc(BUFSIZZ + 1)) == NULL))	/* NUL byte */
		{
		BIO_printf(bio_err,"out of memory\n");
d635 3
a637 4
		}

	verify_depth=0;
	verify_error=X509_V_OK;
d639 1
a639 1
	c_nbio=0;
d644 28
a671 17
	while (argc >= 1)
		{
		if	(strcmp(*argv,"-host") == 0)
			{
			if (--argc < 1) goto bad;
			host= *(++argv);
			}
		else if	(strcmp(*argv,"-port") == 0)
			{
			if (--argc < 1) goto bad;
			port= *(++argv);
			if (port == NULL || *port == '\0') goto bad;
			}
		else if (strcmp(*argv,"-connect") == 0)
			{
			if (--argc < 1) goto bad;
			if (!extract_host_port(*(++argv),&host,NULL,&port))
a672 16
			}
		else if	(strcmp(*argv,"-verify") == 0)
			{
			verify=SSL_VERIFY_PEER;
			if (--argc < 1) goto bad;
			verify_depth=atoi(*(++argv));
			BIO_printf(bio_err,"verify depth is %d\n",verify_depth);
			}
		else if	(strcmp(*argv,"-cert") == 0)
			{
			if (--argc < 1) goto bad;
			cert_file= *(++argv);
			}
		else if	(strcmp(*argv,"-sess_out") == 0)
			{
			if (--argc < 1) goto bad;
d674 3
a676 4
			}
		else if	(strcmp(*argv,"-sess_in") == 0)
			{
			if (--argc < 1) goto bad;
d678 3
a680 4
			}
		else if	(strcmp(*argv,"-certform") == 0)
			{
			if (--argc < 1) goto bad;
d682 1
a682 3
			}
		else if (args_verify(&argv, &argc, &badarg, bio_err, &vpm))
			{
d686 1
a686 2
			}
		else if (strcmp(*argv,"-verify_return_error") == 0)
d688 15
a702 17
		else if	(strcmp(*argv,"-prexit") == 0)
			prexit=1;
		else if	(strcmp(*argv,"-crlf") == 0)
			crlf=1;
		else if	(strcmp(*argv,"-quiet") == 0)
			{
			c_quiet=1;
			c_ign_eof=1;
			}
		else if	(strcmp(*argv,"-ign_eof") == 0)
			c_ign_eof=1;
		else if	(strcmp(*argv,"-no_ign_eof") == 0)
			c_ign_eof=0;
		else if	(strcmp(*argv,"-pause") == 0)
			c_Pause=1;
		else if	(strcmp(*argv,"-debug") == 0)
			c_debug=1;
d704 4
a707 4
		else if	(strcmp(*argv,"-tlsextdebug") == 0)
			c_tlsextdebug=1;
		else if	(strcmp(*argv,"-status") == 0)
			c_status_req=1;
d710 1
a710 1
		else if (strcmp(*argv,"-wdebug") == 0)
d713 8
a720 8
		else if	(strcmp(*argv,"-msg") == 0)
			c_msg=1;
		else if	(strcmp(*argv,"-showcerts") == 0)
			c_showcerts=1;
		else if	(strcmp(*argv,"-nbio_test") == 0)
			nbio_test=1;
		else if	(strcmp(*argv,"-state") == 0)
			state=1;
d722 6
a727 8
                else if (strcmp(*argv,"-psk_identity") == 0)
			{
			if (--argc < 1) goto bad;
			psk_identity=*(++argv);
			}
                else if (strcmp(*argv,"-psk") == 0)
			{
                        size_t j;
d729 8
a736 9
			if (--argc < 1) goto bad;
			psk_key=*(++argv);
			for (j = 0; j < strlen(psk_key); j++)
                                {
                                if (isxdigit((unsigned char)psk_key[j]))
                                        continue;
                                BIO_printf(bio_err,"Not a hex number '%s'\n",*argv);
                                goto bad;
                                }
d738 1
d741 32
a772 38
		else if (strcmp(*argv,"-srpuser") == 0)
			{
			if (--argc < 1) goto bad;
			srp_arg.srplogin= *(++argv);
			meth=TLSv1_client_method();
			}
		else if (strcmp(*argv,"-srppass") == 0)
			{
			if (--argc < 1) goto bad;
			srppass= *(++argv);
			meth=TLSv1_client_method();
			}
		else if (strcmp(*argv,"-srp_strength") == 0)
			{
			if (--argc < 1) goto bad;
			srp_arg.strength=atoi(*(++argv));
			BIO_printf(bio_err,"SRP minimal length for N is %d\n",srp_arg.strength);
			meth=TLSv1_client_method();
			}
		else if (strcmp(*argv,"-srp_lateuser") == 0)
			{
			srp_lateuser= 1;
			meth=TLSv1_client_method();
			}
		else if	(strcmp(*argv,"-srp_moregroups") == 0)
			{
			srp_arg.amp=1;
			meth=TLSv1_client_method();
			}
#endif
		else if	(strcmp(*argv,"-ssl3") == 0)
			meth=SSLv3_client_method();
		else if	(strcmp(*argv,"-tls1_2") == 0)
			meth=TLSv1_2_client_method();
		else if	(strcmp(*argv,"-tls1_1") == 0)
			meth=TLSv1_1_client_method();
		else if	(strcmp(*argv,"-tls1") == 0)
			meth=TLSv1_client_method();
d774 8
a781 10
		else if	(strcmp(*argv,"-dtls1") == 0)
			{
			meth=DTLSv1_client_method();
			socket_type=SOCK_DGRAM;
			}
		else if (strcmp(*argv,"-timeout") == 0)
			enable_timeouts=1;
		else if (strcmp(*argv,"-mtu") == 0)
			{
			if (--argc < 1) goto bad;
d783 1
a783 1
			}
d785 5
a789 5
		else if (strcmp(*argv,"-bugs") == 0)
			bugs=1;
		else if	(strcmp(*argv,"-keyform") == 0)
			{
			if (--argc < 1) goto bad;
d791 3
a793 4
			}
		else if	(strcmp(*argv,"-pass") == 0)
			{
			if (--argc < 1) goto bad;
d795 27
a821 32
			}
		else if	(strcmp(*argv,"-key") == 0)
			{
			if (--argc < 1) goto bad;
			key_file= *(++argv);
			}
		else if	(strcmp(*argv,"-reconnect") == 0)
			{
			reconnect=5;
			}
		else if	(strcmp(*argv,"-CApath") == 0)
			{
			if (--argc < 1) goto bad;
			CApath= *(++argv);
			}
		else if	(strcmp(*argv,"-CAfile") == 0)
			{
			if (--argc < 1) goto bad;
			CAfile= *(++argv);
			}
		else if (strcmp(*argv,"-no_tls1_2") == 0)
			off|=SSL_OP_NO_TLSv1_2;
		else if (strcmp(*argv,"-no_tls1_1") == 0)
			off|=SSL_OP_NO_TLSv1_1;
		else if (strcmp(*argv,"-no_tls1") == 0)
			off|=SSL_OP_NO_TLSv1;
		else if (strcmp(*argv,"-no_ssl3") == 0)
			off|=SSL_OP_NO_SSLv3;
		else if (strcmp(*argv,"-no_ssl2") == 0)
			off|=SSL_OP_NO_SSLv2;
		else if	(strcmp(*argv,"-no_comp") == 0)
			{ off|=SSL_OP_NO_COMPRESSION; }
d823 7
a829 6
		else if	(strcmp(*argv,"-no_ticket") == 0)
			{ off|=SSL_OP_NO_TICKET; }
# ifndef OPENSSL_NO_NEXTPROTONEG
		else if (strcmp(*argv,"-nextprotoneg") == 0)
			{
			if (--argc < 1) goto bad;
d831 2
a832 2
			}
# endif
d834 13
a846 13
		else if (strcmp(*argv,"-serverpref") == 0)
			off|=SSL_OP_CIPHER_SERVER_PREFERENCE;
		else if (strcmp(*argv,"-legacy_renegotiation") == 0)
			off|=SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
		else if	(strcmp(*argv,"-legacy_server_connect") == 0)
			{ off|=SSL_OP_LEGACY_SERVER_CONNECT; }
		else if	(strcmp(*argv,"-no_legacy_server_connect") == 0)
			{ clr|=SSL_OP_LEGACY_SERVER_CONNECT; }
		else if	(strcmp(*argv,"-cipher") == 0)
			{
			if (--argc < 1) goto bad;
			cipher= *(++argv);
			}
d848 3
a850 2
		else if (strcmp(*argv,"-nbio") == 0)
			{ c_nbio=1; }
d852 3
a854 3
		else if	(strcmp(*argv,"-starttls") == 0)
			{
			if (--argc < 1) goto bad;
d856 1
a856 1
			if (strcmp(*argv,"smtp") == 0)
d858 1
a858 1
			else if (strcmp(*argv,"pop3") == 0)
d860 1
a860 1
			else if (strcmp(*argv,"imap") == 0)
d862 1
a862 1
			else if (strcmp(*argv,"ftp") == 0)
d868 1
a868 1
			}
d870 3
a872 3
		else if	(strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
d874 3
a876 4
			}
		else if	(strcmp(*argv,"-ssl_client_engine") == 0)
			{
			if (--argc < 1) goto bad;
d878 1
a878 1
			}
d880 9
a888 7
		else if (strcmp(*argv,"-rand") == 0)
			{
			if (--argc < 1) goto bad;
			inrand= *(++argv);
			}
		else if (strcmp(*argv,"-4") == 0) { af = AF_INET;}
		else if (strcmp(*argv,"-6") == 0) { af = AF_INET6;}
d890 4
a893 4
		else if (strcmp(*argv,"-servername") == 0)
			{
			if (--argc < 1) goto bad;
			servername= *(++argv);
d895 1
a895 1
			}
d898 3
a900 3
		else if (strcmp(*argv,"-jpake") == 0)
			{
			if (--argc < 1) goto bad;
d902 1
a902 1
			}
d905 3
a907 3
		else if (strcmp(*argv,"-use_srtp") == 0)
			{
			if (--argc < 1) goto bad;
d909 1
a909 1
			}
d911 13
a923 15
		else if (strcmp(*argv,"-keymatexport") == 0)
			{
			if (--argc < 1) goto bad;
			keymatexportlabel= *(++argv);
			}
		else if (strcmp(*argv,"-keymatexportlen") == 0)
			{
			if (--argc < 1) goto bad;
			keymatexportlen=atoi(*(++argv));
			if (keymatexportlen == 0) goto bad;
			}
                else
			{
			BIO_printf(bio_err,"unknown option %s\n",*argv);
			badop=1;
d925 1
a925 1
			}
d928 2
a929 3
		}
	if (badop)
		{
d933 1
a933 2
		}

d935 2
a936 4
	if (jpake_secret)
		{
		if (psk_key)
			{
d938 1
a938 1
				   "Can't use JPAKE and PSK together\n");
d940 1
a940 1
			}
d942 1
a942 2
		if (cipher)
			{
d945 1
a945 1
			}
d947 1
a947 1
		}
d955 1
a955 2
	if (next_proto_neg_in)
		{
d957 1
a957 2
		if (next_proto.data == NULL)
			{
a959 1
			}
d961 1
a961 1
	else
d966 2
a967 3
        e = setup_engine(bio_err, engine_id, 1);
	if (ssl_client_engine_id)
		{
d969 1
a969 2
		if (!ssl_client_engine)
			{
d971 1
a971 1
					"Error getting client auth engine\n");
a972 1
			}
d974 1
a974 1

d976 1
a976 2
	if (!app_passwd(bio_err, passarg, NULL, &pass, NULL))
		{
d979 1
a979 2
		}

d984 1
a984 3
	if (key_file)

		{
d987 2
a988 3
			       "client certificate private key file");
		if (!key)
			{
a990 2
			}

d992 4
d997 1
a997 8
	if (cert_file)

		{
		cert = load_cert(bio_err,cert_file,cert_format,
				NULL, e, "client certificate file");

		if (!cert)
			{
a999 1
			}
d1001 1
a1001 1

d1003 3
a1005 4
		&& !RAND_status())
		{
		BIO_printf(bio_err,"warning, not much extra random data, consider using the -rand option\n");
		}
d1007 2
a1008 2
		BIO_printf(bio_err,"%ld semi-random bytes loaded\n",
			app_RAND_load_files(inrand));
d1010 4
a1013 8
	if (bio_c_out == NULL)
		{
		if (c_quiet && !c_debug && !c_msg)
			{
			bio_c_out=BIO_new(BIO_s_null());
			}
		else
			{
d1015 1
a1015 2
				bio_c_out=BIO_new_fp(stdout,BIO_NOCLOSE);
			}
d1017 1
a1017 1

d1019 1
a1019 2
	if(!app_passwd(bio_err, srppass, NULL, &srp_arg.srppassin, NULL))
		{
d1022 1
a1022 1
		}
d1025 2
a1026 3
	ctx=SSL_CTX_new(meth);
	if (ctx == NULL)
		{
d1029 1
a1029 2
		}

d1034 2
a1035 4
	if (ssl_client_engine)
		{
		if (!SSL_CTX_set_client_cert_engine(ctx, ssl_client_engine))
			{
d1040 1
a1040 1
			}
d1042 1
a1042 1
		}
d1051 1
a1051 1
		{
d1055 1
a1055 1
		}
d1062 1
a1062 1
		SSL_CTX_set_options(ctx,SSL_OP_ALL|off);
d1064 1
a1064 1
		SSL_CTX_set_options(ctx,off);
d1068 3
a1070 2
	/* DTLS: partial reads end up discarding unread UDP bytes :-( 
	 * Setting read ahead solves this problem.
d1072 2
a1073 1
	if (socket_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx, 1);
d1080 2
a1081 1
	if (state) SSL_CTX_set_info_callback(ctx,apps_ssl_info_callback);
d1083 5
a1087 5
		if(!SSL_CTX_set_cipher_list(ctx,cipher)) {
		BIO_printf(bio_err,"error setting cipher list\n");
		ERR_print_errors(bio_err);
		goto end;
	}
d1089 2
a1090 2
	else
		SSL_CTX_set_cipher_list(ctx,getenv("SSL_CIPHER"));
d1093 2
a1094 2
	SSL_CTX_set_verify(ctx,verify,verify_callback);
	if (!set_cert_key_stuff(ctx,cert,key))
d1097 6
a1102 4
	if ((!SSL_CTX_load_verify_locations(ctx,CAfile,CApath)) ||
		(!SSL_CTX_set_default_verify_paths(ctx)))
		{
		/* BIO_printf(bio_err,"error setting default verify locations\n"); */
d1105 1
a1105 2
		}

d1107 1
a1107 2
	if (servername != NULL)
		{
d1111 1
a1111 1
		}
d1113 3
a1115 5
        if (srp_arg.srplogin)
		{
		if (!srp_lateuser && !SSL_CTX_set_srp_username(ctx, srp_arg.srplogin))
			{
			BIO_printf(bio_err,"Unable to set SRP username\n");
d1117 1
a1117 1
			}
d1119 2
a1120 2
		srp_arg.debug = c_debug ;
		SSL_CTX_set_srp_cb_arg(ctx,&srp_arg);
d1125 1
a1125 2
		}

d1129 2
a1130 3
	con=SSL_new(ctx);
	if (sess_in)
		{
d1133 1
a1133 2
		if (!stmp)
			{
d1135 1
a1135 1
						sess_in);
d1138 1
a1138 1
			}
d1141 1
a1141 2
		if (!sess)
			{
d1143 1
a1143 1
						sess_in);
d1146 1
a1146 1
			}
d1149 1
a1149 1
		}
d1151 3
a1153 5
	if (servername != NULL)
		{
		if (!SSL_set_tlsext_host_name(con,servername))
			{
			BIO_printf(bio_err,"Unable to set TLS servername extension.\n");
a1155 1
			}
d1157 1
d1160 1
a1160 2
	if (con  &&  (kctx = kssl_ctx_new()) != NULL)
                {
d1162 3
a1164 3
                kssl_ctx_setstring(kctx, KSSL_SERVER, host);
		}
#endif	/* OPENSSL_NO_KRB5  */
d1174 2
a1175 3
	if (init_client(&s,host,port,socket_type,af) == 0)
		{
		BIO_printf(bio_err,"connect:errno=%d\n",errno);
d1179 2
a1180 2
		}
	BIO_printf(bio_c_out,"CONNECTED(%08X)\n",s);
d1183 4
a1186 6
	if (c_nbio)
		{
		unsigned long l=1;
		BIO_printf(bio_c_out,"turning on non blocking io\n");
		if (BIO_socket_ioctl(s,FIONBIO,&l) < 0)
			{
a1188 1
			}
d1190 4
a1193 2
#endif                                              
	if (c_Pause & 0x01) SSL_set_debug(con, 1);
d1195 1
a1195 2
	if ( SSL_version(con) == DTLS1_VERSION)
		{
d1197 2
a1198 3
		sbio=BIO_new_dgram(s,BIO_NOCLOSE);
		if (getsockname(s, &peer, (void *)&peerlen) < 0)
			{
d1200 1
a1200 1
				errno);
d1204 2
a1205 3
			}

		(void)BIO_ctrl_set_connected(sbio, 1, &peer);
d1207 1
a1207 2
		if (enable_timeouts)
			{
d1211 1
a1211 1
			
d1215 2
a1216 4
			}

		if (socket_mtu > 28)
			{
d1219 1
a1219 2
			}
		else
d1222 2
a1223 3
		}
	else
		sbio=BIO_new_socket(s,BIO_NOCLOSE);
d1225 1
a1225 2
	if (nbio_test)
		{
d1228 4
a1231 6
		test=BIO_new(BIO_f_nbio_test());
		sbio=BIO_push(test,sbio);
		}

	if (c_debug)
		{
d1233 4
a1236 5
		BIO_set_callback(sbio,bio_dump_callback);
		BIO_set_callback_arg(sbio,(char *)bio_c_out);
		}
	if (c_msg)
		{
d1239 1
a1239 1
		}
d1241 1
a1241 2
	if (c_tlsextdebug)
		{
d1244 2
a1245 3
		}
	if (c_status_req)
		{
d1250 9
a1258 9
{
STACK_OF(OCSP_RESPID) *ids = sk_OCSP_RESPID_new_null();
OCSP_RESPID *id = OCSP_RESPID_new();
id->value.byKey = ASN1_OCTET_STRING_new();
id->type = V_OCSP_RESPID_KEY;
ASN1_STRING_set(id->value.byKey, "Hello World", -1);
sk_OCSP_RESPID_push(ids, id);
SSL_set_tlsext_status_ids(con, ids);
}
d1260 1
a1260 1
		}
d1267 1
a1267 1
	SSL_set_bio(con,sbio,sbio);
d1271 1
a1271 1
	width=SSL_get_fd(con)+1;
d1273 10
a1282 10
	read_tty=1;
	write_tty=0;
	tty_on=0;
	read_ssl=1;
	write_ssl=1;
	
	cbuf_len=0;
	cbuf_off=0;
	sbuf_len=0;
	sbuf_off=0;
d1285 9
a1293 9
	/* We do have to handle multi-line responses which may come
 	   in a single packet or not. We therefore have to use
	   BIO_gets() which does need a buffering BIO. So during
	   the initial chitchat we do push a buffering BIO into the
	   chain that is removed again later on to not disturb the
	   rest of the s_client operation. */
	if (starttls_proto == PROTO_SMTP)
		{
		int foundit=0;
d1297 4
a1300 5
		do
			{
			mbuf_len = BIO_gets(fbio,mbuf,BUFSIZZ);
			}
		while (mbuf_len>3 && mbuf[3]=='-');
d1302 2
a1303 2
		BIO_printf(fbio,"EHLO openssl.client.net\r\n");
		(void)BIO_flush(fbio);
d1305 7
a1311 8
		do
			{
			mbuf_len = BIO_gets(fbio,mbuf,BUFSIZZ);
			if (strstr(mbuf,"STARTTLS"))
				foundit=1;
			}
		while (mbuf_len>3 && mbuf[3]=='-');
		(void)BIO_flush(fbio);
d1316 8
a1323 11
				   "didn't found starttls in server response,"
				   " try anyway...\n");
		BIO_printf(sbio,"STARTTLS\r\n");
		BIO_read(sbio,sbuf,BUFSIZZ);
		}
	else if (starttls_proto == PROTO_POP3)
		{
		mbuf_len = BIO_read(sbio,mbuf,BUFSIZZ);
		if (mbuf_len == -1)
			{
			BIO_printf(bio_err,"BIO_read failed\n");
a1324 3
			}
		BIO_printf(sbio,"STLS\r\n");
		BIO_read(sbio,sbuf,BUFSIZZ);
d1326 4
a1329 3
	else if (starttls_proto == PROTO_IMAP)
		{
		int foundit=0;
d1332 1
a1332 1
		BIO_gets(fbio,mbuf,BUFSIZZ);
d1334 2
a1335 2
		BIO_printf(fbio,". CAPABILITY\r\n");
		(void)BIO_flush(fbio);
d1337 7
a1343 8
		do
			{
			mbuf_len = BIO_gets(fbio,mbuf,BUFSIZZ);
			if (strstr(mbuf,"STARTTLS"))
				foundit=1;
			}
		while (mbuf_len>3 && mbuf[0]!='.');
		(void)BIO_flush(fbio);
d1348 5
a1352 7
				   "didn't found STARTTLS in server response,"
				   " try anyway...\n");
		BIO_printf(sbio,". STARTTLS\r\n");
		BIO_read(sbio,sbuf,BUFSIZZ);
		}
	else if (starttls_proto == PROTO_FTP)
		{
d1356 5
a1360 6
		do
			{
			mbuf_len = BIO_gets(fbio,mbuf,BUFSIZZ);
			}
		while (mbuf_len>3 && mbuf[3]=='-');
		(void)BIO_flush(fbio);
d1363 4
a1366 5
		BIO_printf(sbio,"AUTH TLS\r\n");
		BIO_read(sbio,sbuf,BUFSIZZ);
		}
	if (starttls_proto == PROTO_XMPP)
		{
d1368 1
a1368 1
		BIO_printf(sbio,"<stream:stream "
d1371 1
a1371 1
		seen = BIO_read(sbio,mbuf,BUFSIZZ);
d1373 1
a1373 2
		while (!strstr(mbuf, "<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'"))
			{
d1376 1
a1376 1
			seen = BIO_read(sbio,mbuf,BUFSIZZ);
d1378 1
a1378 1
			}
d1380 1
a1380 1
		seen = BIO_read(sbio,sbuf,BUFSIZZ);
d1385 2
a1386 4
		}

	for (;;)
		{
d1391 1
a1391 1
			DTLSv1_get_timeout(con, &timeout))
d1396 9
a1404 12
		if (SSL_in_init(con) && !SSL_total_renegotiations(con))
			{
			in_init=1;
			tty_on=0;
			}
		else
			{
			tty_on=1;
			if (in_init)
				{
				in_init=0;
#if 0 /* This test doesn't really work as intended (needs to be fixed) */
d1406 3
a1408 4
				if (servername != NULL && !SSL_session_reused(con))
					{
					BIO_printf(bio_c_out,"Server did %sacknowledge servername extension.\n",tlsextcbp.ack?"":"not ");
					}
d1411 1
a1411 2
				if (sess_out)
					{
d1413 1
a1413 2
					if (stmp)
						{
d1416 1
a1416 2
						}
					else 
d1418 4
a1421 3
					}
				print_stuff(bio_c_out,con,full_log);
				if (full_log > 0) full_log--;
d1423 1
a1423 2
				if (starttls_proto)
					{
d1427 2
a1428 4
					}

				if (reconnect)
					{
d1430 1
a1430 1
					BIO_printf(bio_c_out,"drop connection and then reconnect\n");
a1435 1
					}
d1438 1
d1442 7
a1448 7
		if (!ssl_pending)
			{
			if (tty_on)
				{
				if (read_tty)  openssl_fdset(fileno(stdin),&readfds);
				if (write_tty) openssl_fdset(fileno(stdout),&writefds);
				}
d1450 1
a1450 1
				openssl_fdset(SSL_get_fd(con),&readfds);
d1452 1
a1452 1
				openssl_fdset(SSL_get_fd(con),&writefds);
d1456 7
a1462 5
			/* Note: under VMS with SOCKETSHR the second parameter
			 * is currently of type (int *) whereas under other
			 * systems it is (void *) if you don't have a cast it
			 * will choke the compiler: if you do have a cast then
			 * you can either go for (int *) or (void *).
d1464 4
a1467 5
			i=select(width,(void *)&readfds,(void *)&writefds,
				 NULL,timeoutp);
			if ( i < 0)
				{
				BIO_printf(bio_err,"bad select %d\n",
a1470 1
				}
d1472 8
a1479 12

		if ((SSL_version(con) == DTLS1_VERSION) && DTLSv1_handle_timeout(con) > 0)
			{
			BIO_printf(bio_err,"TIMEOUT occured\n");
			}

		if (!ssl_pending && FD_ISSET(SSL_get_fd(con),&writefds))
			{
			k=SSL_write(con,&(cbuf[cbuf_off]),
				(unsigned int)cbuf_len);
			switch (SSL_get_error(con,k))
				{
d1481 4
a1484 3
				cbuf_off+=k;
				cbuf_len-=k;
				if (k <= 0) goto end;
d1486 7
a1492 10
				if (cbuf_len <= 0)
					{
					read_tty=1;
					write_ssl=0;
					}
				else /* if (cbuf_len > 0) */
					{
					read_tty=0;
					write_ssl=1;
					}
d1495 3
a1497 3
				BIO_printf(bio_c_out,"write W BLOCK\n");
				write_ssl=1;
				read_tty=0;
d1500 4
a1503 4
				BIO_printf(bio_c_out,"write R BLOCK\n");
				write_tty=0;
				read_ssl=1;
				write_ssl=0;
d1506 1
a1506 1
				BIO_printf(bio_c_out,"write X BLOCK\n");
d1509 2
a1510 3
				if (cbuf_len != 0)
					{
					BIO_printf(bio_c_out,"shutdown\n");
d1513 3
a1515 5
					}
				else
					{
					read_tty=1;
					write_ssl=0;
d1517 2
a1518 2
					}
				
d1520 3
a1522 4
				if ((k != 0) || (cbuf_len != 0))
					{
					BIO_printf(bio_err,"write:errno=%d\n",
						errno);
d1524 4
a1527 6
					}
				else
					{
					read_tty=1;
					write_ssl=0;
					}
a1531 1
				}
d1533 2
a1534 3
		else if (!ssl_pending && FD_ISSET(fileno(stdout),&writefds))
			{
			i=raw_write_stdout(&(sbuf[sbuf_off]),sbuf_len);
d1536 2
a1537 3
			if (i <= 0)
				{
				BIO_printf(bio_c_out,"DONE\n");
d1541 14
a1554 8
				}

			sbuf_len-=i;
			sbuf_off+=i;
			if (sbuf_len <= 0)
				{
				read_ssl=1;
				write_tty=0;
a1556 4
		else if (ssl_pending || FD_ISSET(SSL_get_fd(con),&readfds))
			{
#ifdef RENEG
{ static int iiii; if (++iiii == 52) { SSL_renegotiate(con); iiii=0; } }
d1559 1
a1559 1
			k=SSL_read(con,sbuf,1024 /* BUFSIZZ */ );
d1562 5
a1566 4
			k=SSL_read(con,sbuf,16);
{ char zbuf[10240]; 
printf("read=%d pending=%d peek=%d\n",k,SSL_pending(con),SSL_peek(con,zbuf,10240));
}
d1569 1
a1569 2
			switch (SSL_get_error(con,k))
				{
d1573 2
a1574 2
				sbuf_off=0;
				sbuf_len=k;
d1576 2
a1577 2
				read_ssl=0;
				write_tty=1;
d1580 3
a1582 3
				BIO_printf(bio_c_out,"read W BLOCK\n");
				write_ssl=1;
				read_tty=0;
d1585 3
a1587 3
				BIO_printf(bio_c_out,"read R BLOCK\n");
				write_tty=0;
				read_ssl=1;
d1589 1
a1589 1
					write_ssl=1;
d1592 1
a1592 1
				BIO_printf(bio_c_out,"read X BLOCK\n");
d1595 2
a1596 2
				ret=errno;
				BIO_printf(bio_err,"read:errno=%d\n",ret);
d1599 2
a1600 2
				BIO_printf(bio_c_out,"closed\n");
				ret=0;
a1605 1
				}
d1607 2
a1608 5

		else if (FD_ISSET(fileno(stdin),&readfds))
			{
			if (crlf)
				{
d1611 1
a1611 1
				i=raw_read_stdin(cbuf,BUFSIZZ/2);
d1617 3
a1619 5
				for (j = i-1; j >= 0; j--)
					{
					cbuf[j+lf_num] = cbuf[j];
					if (cbuf[j] == '\n')
						{
d1622 1
a1622 2
						cbuf[j+lf_num] = '\r';
						}
d1624 1
d1626 2
a1627 3
				}
			else
				i=raw_read_stdin(cbuf,BUFSIZZ);
d1629 3
a1631 4
			if ((!c_ign_eof) && ((i <= 0) || (cbuf[0] == 'Q')))
				{
				BIO_printf(bio_err,"DONE\n");
				ret=0;
d1633 3
a1635 5
				}

			if ((!c_ign_eof) && (cbuf[0] == 'R'))
				{
				BIO_printf(bio_err,"RENEGOTIATING\n");
d1637 5
a1641 7
				cbuf_len=0;
				}
			else
				{
				cbuf_len=i;
				cbuf_off=0;
				}
d1643 2
a1644 3
			write_ssl=1;
			read_tty=0;
			}
d1646 1
d1648 1
a1648 1
	ret=0;
d1651 1
a1651 1
		print_stuff(bio_c_out,con,full_log);
d1656 1
a1656 2
	if (con != NULL)
		{
d1658 1
a1658 1
			print_stuff(bio_c_out,con,1);
d1660 1
a1660 1
		}
d1665 2
a1666 1
	if (ctx != NULL) SSL_CTX_free(ctx);
d1675 13
a1687 5
	if (cbuf != NULL) { OPENSSL_cleanse(cbuf,BUFSIZZ); free(cbuf); }
	if (sbuf != NULL) { OPENSSL_cleanse(sbuf,BUFSIZZ); free(sbuf); }
	if (mbuf != NULL) { OPENSSL_cleanse(mbuf,BUFSIZZ); free(mbuf); }
	if (bio_c_out != NULL)
		{
d1689 2
a1690 2
		bio_c_out=NULL;
		}
d1692 2
a1693 2
	return(ret);
	}
d1696 4
a1699 3
static void print_stuff(BIO *bio, SSL *s, int full)
	{
	X509 *peer=NULL;
d1701 1
a1701 1
	static const char *space="                ";
d1703 2
a1704 2
	STACK_OF(X509) *sk;
	STACK_OF(X509_NAME) *sk2;
d1707 1
a1707 1
	int j,i;
d1713 1
a1713 2
	if (full)
		{
d1716 4
a1719 4
		sk=SSL_get_peer_cert_chain(s);
		if (sk != NULL)
			{
			got_a_chain = 1; /* we don't have it for SSL2 (yet) */
d1721 2
a1722 3
			BIO_printf(bio,"---\nCertificate chain\n");
			for (i=0; i<sk_X509_num(sk); i++)
				{
d1724 2
a1725 2
					sk_X509_value(sk,i)),buf,sizeof buf);
				BIO_printf(bio,"%2d s:%s\n",i,buf);
d1727 2
a1728 2
					sk_X509_value(sk,i)),buf,sizeof buf);
				BIO_printf(bio,"   i:%s\n",buf);
d1730 1
a1730 2
					PEM_write_bio_X509(bio,sk_X509_value(sk,i));
				}
d1732 9
a1740 8

		BIO_printf(bio,"---\n");
		peer=SSL_get_peer_certificate(s);
		if (peer != NULL)
			{
			BIO_printf(bio,"Server certificate\n");
			if (!(c_showcerts && got_a_chain)) /* Redundant if we showed the whole chain */
				PEM_write_bio_X509(bio,peer);
d1742 2
a1743 2
				buf,sizeof buf);
			BIO_printf(bio,"subject=%s\n",buf);
d1745 21
a1765 26
				buf,sizeof buf);
			BIO_printf(bio,"issuer=%s\n",buf);
			}
		else
			BIO_printf(bio,"no peer certificate available\n");

		sk2=SSL_get_client_CA_list(s);
		if ((sk2 != NULL) && (sk_X509_NAME_num(sk2) > 0))
			{
			BIO_printf(bio,"---\nAcceptable client certificate CA names\n");
			for (i=0; i<sk_X509_NAME_num(sk2); i++)
				{
				xn=sk_X509_NAME_value(sk2,i);
				X509_NAME_oneline(xn,buf,sizeof(buf));
				BIO_write(bio,buf,strlen(buf));
				BIO_write(bio,"\n",1);
				}
			}
		else
			{
			BIO_printf(bio,"---\nNo client certificate CA names sent\n");
			}
		p=SSL_get_shared_ciphers(s,buf,sizeof buf);
		if (p != NULL)
			{
			/* This works only for SSL 2.  In later protocol
d1767 3
a1769 2
			 * ciphers (in addition to the one to be used
			 * in the current connection) the server supports. */
d1771 5
a1775 7
			BIO_printf(bio,"---\nCiphers common between both SSL endpoints:\n");
			j=i=0;
			while (*p)
				{
				if (*p == ':')
					{
					BIO_write(bio,space,15-j%25);
d1777 4
a1780 6
					j=0;
					BIO_write(bio,((i%3)?" ":"\n"),1);
					}
				else
					{
					BIO_write(bio,p,1);
d1782 1
a1782 1
					}
a1783 2
				}
			BIO_write(bio,"\n",1);
d1785 11
a1795 10

		BIO_printf(bio,"---\nSSL handshake has read %ld bytes and written %ld bytes\n",
			BIO_number_read(SSL_get_rbio(s)),
			BIO_number_written(SSL_get_wbio(s)));
		}
	BIO_printf(bio,(SSL_cache_hit(s)?"---\nReused, ":"---\nNew, "));
	c=SSL_get_current_cipher(s);
	BIO_printf(bio,"%s, Cipher is %s\n",
		SSL_CIPHER_get_version(c),
		SSL_CIPHER_get_name(c));
d1799 2
a1800 2
		BIO_printf(bio,"Server public key is %d bit\n",
							 EVP_PKEY_bits(pktmp));
d1804 1
a1804 1
			SSL_get_secure_renegotiation_support(s) ? "" : " NOT");
d1806 6
a1811 6
	comp=SSL_get_current_compression(s);
	expansion=SSL_get_current_expansion(s);
	BIO_printf(bio,"Compression: %s\n",
		comp ? SSL_COMP_get_name(comp) : "NONE");
	BIO_printf(bio,"Expansion: %s\n",
		expansion ? SSL_COMP_get_name(expansion) : "NONE");
d1813 1
a1813 1
 
d1816 7
a1822 7
	/* Print out local port of connection: useful for debugging */
	int sock;
	struct sockaddr_in ladd;
	socklen_t ladd_size = sizeof(ladd);
	sock = SSL_get_fd(s);
	getsockname(sock, (struct sockaddr *)&ladd, &ladd_size);
	BIO_printf(bio_c_out, "LOCAL PORT is %u\n", ntohs(ladd.sin_port));
d1838 6
a1843 6
 	{
 	SRTP_PROTECTION_PROFILE *srtp_profile=SSL_get_selected_srtp_profile(s);
 
	if(srtp_profile)
		BIO_printf(bio,"SRTP Extension negotiated, profile=%s\n",
			   srtp_profile->name);
d1846 3
a1848 4
 
	SSL_SESSION_print(bio,SSL_get_session(s));
	if (keymatexportlabel != NULL)
		{
d1853 1
a1853 2
		if (exportedkeymat != NULL)
			{
d1855 4
a1858 5
						        keymatexportlen,
						        keymatexportlabel,
						        strlen(keymatexportlabel),
						        NULL, 0, 0))
				{
d1860 1
a1860 3
				}
			else
				{
d1862 1
a1862 1
				for (i=0; i<keymatexportlen; i++)
d1864 1
a1864 1
						   exportedkeymat[i]);
d1866 1
a1866 1
				}
a1867 1
			}
d1869 2
a1870 1
	BIO_printf(bio,"---\n");
d1874 2
a1875 2
	(void)BIO_flush(bio);
	}
d1879 3
a1881 2
static int ocsp_resp_cb(SSL *s, void *arg)
	{
d1887 1
a1887 2
	if (!p)
		{
d1890 1
a1890 1
		}
d1892 1
a1892 2
	if (!rsp)
		{
d1894 1
a1894 1
		BIO_dump_indent(arg, (char *)p, len, 4);
d1896 1
a1896 1
		}
d1902 1
a1902 1
	}
@


1.37
log
@unistd.h exposed after -Wall after e_os.h stops doing so; spotted by matthew
@
text
@a592 3
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)
	struct timeval tv;
#endif
a1553 1
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE) && !defined (OPENSSL_SYS_BEOS_R5)
a1562 8
#else
			if(!tty_on || !write_tty) {
				if (read_ssl)
					openssl_fdset(SSL_get_fd(con),&readfds);
				if (write_ssl)
					openssl_fdset(SSL_get_fd(con),&writefds);
			}
#endif
a1571 24
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
                        /* Under Windows/DOS we make the assumption that we can
			 * always write to the tty: therefore if we need to
			 * write to the tty we just fall through. Otherwise
			 * we timeout the select every second and see if there
			 * are any keypresses. Note: this is a hack, in a proper
			 * Windows application we wouldn't do this.
			 */
			i=0;
			if(!write_tty) {
				if(read_tty) {
					tv.tv_sec = 1;
					tv.tv_usec = 0;
					i=select(width,(void *)&readfds,(void *)&writefds,
						 NULL,&tv);
#if defined(OPENSSL_SYS_WINCE) || defined(OPENSSL_SYS_MSDOS)
					if(!i && (!_kbhit() || !read_tty) ) continue;
#else
					if(!i && (!((_kbhit()) || (WAIT_OBJECT_0 == WaitForSingleObject(GetStdHandle(STD_INPUT_HANDLE), 0))) || !read_tty) ) continue;
#endif
				} else 	i=select(width,(void *)&readfds,(void *)&writefds,
					 NULL,timeoutp);
			}
#else
a1573 1
#endif
a1655 4
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)
		/* Assume Windows/DOS/BeOS can always write */
		else if (!ssl_pending && write_tty)
#else
a1656 1
#endif
a1731 7
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
#if defined(OPENSSL_SYS_WINCE) || defined(OPENSSL_SYS_MSDOS)
		else if (_kbhit())
#else
		else if ((_kbhit()) || (WAIT_OBJECT_0 == WaitForSingleObject(GetStdHandle(STD_INPUT_HANDLE), 0)))
#endif
#else
a1732 1
#endif
@


1.36
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d146 1
@


1.35
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d144 1
d147 3
a153 1
#define USE_SOCKETS
d344 1
a344 1
	BIO_printf(bio_err," -rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
d1868 1
a1868 1
	OPENSSL_EXIT(ret);
@


1.34
log
@missed vms comment
@
text
@d478 1
a478 1
	char *pass = (char *)OPENSSL_malloc(PWD_STRLEN+1);
d487 1
a487 1
		OPENSSL_free(pass);
d631 3
a633 3
	if (	((cbuf=OPENSSL_malloc(BUFSIZZ)) == NULL) ||
		((sbuf=OPENSSL_malloc(BUFSIZZ)) == NULL) ||
		((mbuf=OPENSSL_malloc(BUFSIZZ + 1)) == NULL))	/* NUL byte */
d1845 1
a1845 1
		OPENSSL_free(next_proto.data);
d1853 1
a1853 1
		OPENSSL_free(pass);
d1856 3
a1858 3
	if (cbuf != NULL) { OPENSSL_cleanse(cbuf,BUFSIZZ); OPENSSL_free(cbuf); }
	if (sbuf != NULL) { OPENSSL_cleanse(sbuf,BUFSIZZ); OPENSSL_free(sbuf); }
	if (mbuf != NULL) { OPENSSL_cleanse(mbuf,BUFSIZZ); OPENSSL_free(mbuf); }
d2036 1
a2036 1
		exportedkeymat = OPENSSL_malloc(keymatexportlen);
d2055 1
a2055 1
			OPENSSL_free(exportedkeymat);
@


1.33
log
@first round of unifdef hammering
@
text
@a149 4
/* With IPv6, it looks like Digital has mixed up the proper order of
   recursive header file inclusion, resulting in the compiler complaining
   that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which
   is needed to have fileno() declared correctly...  So let's define u_int */
@


1.32
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@a168 3
#if defined(OPENSSL_SYS_BEOS_R5)
#include <fcntl.h>
#endif
a594 3
#if defined(OPENSSL_SYS_BEOS_R5)
	int stdin_set = 0;
#endif
a1606 29
#elif defined(OPENSSL_SYS_NETWARE)
			if(!write_tty) {
				if(read_tty) {
					tv.tv_sec = 1;
					tv.tv_usec = 0;
					i=select(width,(void *)&readfds,(void *)&writefds,
						NULL,&tv);
				} else 	i=select(width,(void *)&readfds,(void *)&writefds,
					NULL,timeoutp);
			}
#elif defined(OPENSSL_SYS_BEOS_R5)
			/* Under BeOS-R5 the situation is similar to DOS */
			i=0;
			stdin_set = 0;
			(void)fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);
			if(!write_tty) {
				if(read_tty) {
					tv.tv_sec = 1;
					tv.tv_usec = 0;
					i=select(width,(void *)&readfds,(void *)&writefds,
						 NULL,&tv);
					if (read(fileno(stdin), sbuf, 0) >= 0)
						stdin_set = 1;
					if (!i && (stdin_set != 1 || !read_tty))
						continue;
				} else 	i=select(width,(void *)&readfds,(void *)&writefds,
					 NULL,timeoutp);
			}
			(void)fcntl(fileno(stdin), F_SETFL, 0);
a1779 4
#elif defined (OPENSSL_SYS_NETWARE)
		else if (_kbhit())
#elif defined(OPENSSL_SYS_BEOS_R5)
		else if (stdin_set)
@


1.31
log
@remove ssl2 support even more completely.
in the process, always include ssl3 and tls1, we don't need config options
for them. when the time comes to expire ssl3, it will be with an ax.
checked by miod
@
text
@a153 5
#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__U_INT)
#define __U_INT
typedef unsigned int u_int;
#endif

a167 5

#if (defined(OPENSSL_SYS_VMS) && __VMS_VER < 70000000)
/* FIONBIO used as a switch to enable ioctl, and that isn't in VMS < 7.0 */
#undef FIONBIO
#endif
@


1.30
log
@convert BIO_snprintf to snprintf
ok deraadt@@ tedu@@
@
text
@a339 3
#ifndef OPENSSL_NO_SSL2
	BIO_printf(bio_err," -ssl2         - just use SSLv2\n");
#endif
a347 3
#ifndef OPENSSL_NO_SSL2
	BIO_printf(bio_err," -serverpref   - Use server's cipher preferences (only SSLv2)\n");
#endif
a807 5
#ifndef OPENSSL_NO_SSL2
		else if	(strcmp(*argv,"-ssl2") == 0)
			meth=SSLv2_client_method();
#endif
#ifndef OPENSSL_NO_SSL3
a809 2
#endif
#ifndef OPENSSL_NO_TLS1
a815 1
#endif
@


1.29
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@d233 1
d239 3
d252 2
a253 2
	ret = BIO_snprintf(identity, max_identity_len, "%s", psk_identity);
	if (ret < 0 || (unsigned int)ret > max_identity_len)
@


1.28
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@a1754 3
#ifdef CHARSET_EBCDIC
			ascii2ebcdic(&(sbuf[sbuf_off]),&(sbuf[sbuf_off]),sbuf_len);
#endif
a1884 3
#ifdef CHARSET_EBCDIC
				ebcdic2ascii(cbuf, cbuf, i);
#endif
@


1.27
log
@Remove various horrible socket syscall wrappers, especially SHUTDOWN*
which did shutdown + close, all nasty and surprising.  Use the raw
syscalls that everyone knows the behaviour of.
ok beck matthew
@
text
@a1883 8
#ifndef OPENSSL_NO_HEARTBEATS
			else if ((!c_ign_eof) && (cbuf[0] == 'B'))
 				{
				BIO_printf(bio_err,"HEARTBEATING\n");
				SSL_heartbeat(con);
				cbuf_len=0;
				}
#endif
@


1.26
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@d1275 3
a1277 2
		BIO_printf(bio_err,"connect:errno=%d\n",get_last_socket_error());
		SHUTDOWN(s);
d1303 3
a1305 2
				get_last_socket_error());
			SHUTDOWN(s);
d1572 2
a1573 1
					SHUTDOWN(SSL_get_fd(con));
d1669 1
a1669 1
				get_last_socket_error());
d1734 1
a1734 1
						get_last_socket_error());
d1818 1
a1818 1
				ret=get_last_socket_error();
d1911 2
a1912 1
	SHUTDOWN(SSL_get_fd(con));
@


1.25
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d389 1
a389 1
static int MS_CALLBACK ssl_servername_cb(SSL *s, int *ad, void *arg)
d459 1
a459 1
static int MS_CALLBACK ssl_srp_verify_param_cb(SSL *s, void *arg)
d494 1
a494 1
static char * MS_CALLBACK ssl_give_srp_client_pwd_cb(SSL *s, void *arg)
@


1.24
log
@resolve conflicts
@
text
@d368 1
a368 1
# if !defined(OPENSSL_NO_NEXTPROTONEG)
d373 1
d375 1
d515 1
d517 1
d551 1
a551 1
# endif
d962 1
d968 1
d1149 2
d1916 4
d1927 2
d2093 1
d2101 1
@


1.23
log
@Skip printing another SSLv2-only command in s_client's usage text.
jmc@@ noticed this in the manpage while updating it, but it applies here too.
@
text
@d168 3
d211 3
d329 7
d340 2
d345 1
a345 1
	BIO_printf(bio_err," -no_tls1/-no_ssl3/-no_ssl2 - turn off that protocol\n");
d368 3
d373 3
d398 150
d566 3
d614 3
d627 5
a632 1
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
a633 5
#elif !defined(OPENSSL_NO_SSL3)
	meth=SSLv3_client_method();
#elif !defined(OPENSSL_NO_SSL2)
	meth=SSLv2_client_method();
#endif
d768 1
a768 1
                                if (isxdigit((int)psk_key[j]))
d775 31
d815 4
d867 4
d882 7
d958 17
a974 1
		else
d1000 6
d1007 4
d1012 3
a1014 1
	if (cipher)
d1016 6
a1021 2
		BIO_printf(bio_err, "JPAKE sets cipher to PSK\n");
		goto end;
d1023 2
a1024 1
	cipher = "PSK";
a1026 3
	OpenSSL_add_ssl_algorithms();
	SSL_load_error_strings();

d1100 8
d1143 2
d1158 5
d1194 18
d1250 1
a1250 1
	if (con  &&  (con->kssl_ctx = kssl_ctx_new()) != NULL)
d1252 2
a1253 1
                kssl_ctx_setstring(con->kssl_ctx, KSSL_SERVER, host);
d1285 1
a1285 1
	if (c_Pause & 0x01) con->debug=1;
d1334 1
a1334 1
		con->debug=1;
d1873 8
d1942 1
d2033 1
a2033 1
	BIO_printf(bio,((s->hit)?"---\nReused, ":"---\nNew, "));
d2055 32
d2088 27
@


1.22
log
@Disable SSLv2 in OpenSSL.  No objections from djm.
Brad, jasper and naddy helped with test builds, fixing ports, etc.
@
text
@d332 1
d334 1
@


1.21
log
@resolve conflicts, fix local changes
@
text
@d323 1
d325 1
@


1.20
log
@The openssl command line tool treats the non-null terminated buffer
"mbuf" as a C string when using the pop3 s_client feature. This causes
a segmentation fault with malloc.conf option "J" set when BIO_printf()
runs off the end of the buffer. The following patch fixes PR 6282
from Matthew Haub (asked to submit upstream), ok djm
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d111 26
d141 1
d167 1
a170 9
#ifdef OPENSSL_SYS_WINCE
/* Windows CE incorrectly defines fileno as returning void*, so to avoid problems below... */
#ifdef fileno
#undef fileno
#endif
#define fileno(a) (int)_fileno(a)
#endif


d176 4
d194 1
d217 63
d290 1
a290 1
	BIO_printf(bio_err," -verify depth - turn on peer certificate verification\n");
d316 7
d327 1
a327 1
	BIO_printf(bio_err," -mtu          - set the MTU\n");
d350 1
d374 1
d389 2
a390 3
	int off=0;
	SSL *con=NULL,*con2=NULL;
	X509_STORE *store = NULL;
d411 5
a415 6
	int prexit = 0, vflags = 0;
	SSL_METHOD *meth=NULL;
#ifdef sock_type
#undef sock_type
#endif
	int sock_type=SOCK_STREAM;
d419 1
d426 1
a426 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)
d428 3
a431 1

d442 1
a442 1
	long mtu = 0;
d531 8
a538 4
		else if	(strcmp(*argv,"-crl_check") == 0)
			vflags |= X509_V_FLAG_CRL_CHECK;
		else if	(strcmp(*argv,"-crl_check_all") == 0)
			vflags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;
d574 21
d611 1
a611 1
			sock_type=SOCK_DGRAM;
d618 1
a618 1
			mtu = atol(*(++argv));
d658 2
d666 6
d748 20
d783 1
d851 3
d868 12
d884 3
d890 1
a890 1
	if (sock_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx, 1);
a915 2
	store = SSL_CTX_get_cert_store(ctx);
	X509_STORE_set_flags(store, vflags);
a959 1

d967 5
d975 1
a975 1
	if (init_client(&s,host,port,sock_type,af) == 0)
a998 1
		struct timeval timeout;
d1011 1
a1011 1
		if ( enable_timeouts)
d1022 1
a1022 1
		if ( mtu > 0)
d1025 1
a1025 1
			SSL_set_mtu(con, mtu);
d1220 6
d1237 8
d1282 1
a1282 1
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE)
d1285 2
a1286 2
				if (read_tty)  FD_SET(fileno(stdin),&readfds);
				if (write_tty) FD_SET(fileno(stdout),&writefds);
d1289 1
a1289 1
				FD_SET(SSL_get_fd(con),&readfds);
d1291 1
a1291 1
				FD_SET(SSL_get_fd(con),&writefds);
d1295 1
a1295 1
					FD_SET(SSL_get_fd(con),&readfds);
d1297 1
a1297 1
					FD_SET(SSL_get_fd(con),&writefds);
d1330 1
a1330 1
					 NULL,NULL);
d1340 19
a1358 1
					NULL,NULL);
d1360 1
d1363 1
a1363 1
				 NULL,NULL);
d1374 5
d1419 1
d1447 2
a1448 2
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)
		/* Assume Windows/DOS can always write */
d1457 1
a1457 1
			i=write(fileno(stdout),&(sbuf[sbuf_off]),sbuf_len);
d1462 1
d1517 2
a1518 1
				BIO_printf(bio_err,"read:errno=%d\n",get_last_socket_error());
d1522 1
d1538 3
a1540 1
        else if (_kbhit())
d1549 1
a1549 1
				i=read(fileno(stdin),cbuf,BUFSIZZ/2);
d1568 1
a1568 1
				i=read(fileno(stdin),cbuf,BUFSIZZ);
d1573 1
d1596 2
d1599 2
a1602 1
	ret=0;
d1604 6
a1609 3
	if(prexit) print_stuff(bio_c_out,con,1);
	if (con != NULL) SSL_free(con);
	if (con2 != NULL) SSL_free(con2);
d1638 1
a1638 1
	SSL_CIPHER *c;
d1746 2
d1791 2
a1792 1
#endif  /* ndef OPENSSL_NO_TLSEXT */
@


1.19
log
@remove some gratuitous changes that do nothing other than inrease
the size of the diff against openssl mainline
@
text
@d1077 1
a1077 1
					BIO_printf(bio_err,"%s",mbuf);
@


1.18
log
@resolve conflicts
@
text
@a299 1
	int mbuf_len;
d324 1
a927 1
	mbuf_len=0;
@


1.17
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d228 1
d242 2
a243 1
	BIO_printf(bio_err,"                 only \"smtp\", \"pop3\", \"imap\", and \"ftp\" are supported.\n");
d285 2
a286 1
	PROTO_FTP
d328 1
a328 1
	ENGINE *e=NULL, *ssl_client_engine=NULL;
d330 1
d346 3
d449 2
d563 2
d595 7
a863 2


d907 4
d1022 22
@


1.16
log
@remerge local tweaks, update per-arch configuration headers, update
Makefiles, crank shlib_version
@
text
@d324 2
a325 1
	ENGINE *e=NULL;
d563 5
d605 10
d681 14
@


1.15
log
@resolve conflicts
@
text
@a321 1
	int mbuf_len=0;
@


1.14
log
@Correctly NUL terminate the message buffer that is used with the
-starttls option. Without this openssl s_client -starttls crashed with
malloc.conf -> J. OK deraadt@@, hshoexer@@
@
text
@d139 1
d141 1
d177 4
d186 3
d203 1
a203 1
	BIO_printf(bio_err," -verify arg   - turn on peer certificate verification\n");
d205 2
a206 1
	BIO_printf(bio_err," -key arg      - Private key file to use, PEM format assumed, in cert file if\n");
d208 2
d231 2
d241 1
a241 1
	BIO_printf(bio_err,"                 only \"smtp\" and \"pop3\" are supported.\n");
d246 11
d258 17
d276 9
d297 1
a297 1
	int mbuf_len,mbuf_off;
d303 4
d313 1
a313 1
	int starttls_proto = 0;
d316 4
d322 1
d327 1
a327 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
d331 12
d412 15
d446 6
d453 1
a453 1
		else if	(strcmp(*argv,"-wdebug") == 0)
d476 14
d492 10
d527 4
d547 1
a547 1
				starttls_proto = 1;
d549 5
a553 1
				starttls_proto = 2;
d571 8
d601 36
d671 4
d689 1
a689 1
	if (!set_cert_stuff(ctx,cert_file,key_file))
d702 8
d712 35
d757 1
a757 1
	if (init_client(&s,host,port,af) == 0)
d778 40
a817 1
	sbio=BIO_new_socket(s,BIO_NOCLOSE);
d830 2
a831 2
		BIO_set_callback(sbio,bio_dump_cb);
		BIO_set_callback_arg(sbio,bio_c_out);
d838 24
a879 1
	mbuf_off=0;
d882 7
a888 1
	if (starttls_proto == 1)
d890 27
a916 13
		mbuf_off = mbuf_len = BIO_read(sbio,mbuf,BUFSIZZ);
		if (mbuf_len == -1)
			{
			BIO_printf(bio_err,"BIO_read failed\n");
			goto end;
			}
		BIO_printf(sbio,"EHLO some.host.name\r\n");
		mbuf_len = BIO_read(sbio,mbuf + mbuf_off,BUFSIZZ - mbuf_off);
		if (mbuf_len == -1)
			{
			BIO_printf(bio_err,"BIO_read failed\n");
			goto end;
			}
d920 1
a920 1
	if (starttls_proto == 2)
d931 43
a973 2

	mbuf[mbuf_off + mbuf_len] = '\0';
d991 11
d1009 1
a1009 1
					starttls_proto = 0;
d1028 1
a1028 1
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS)
d1078 10
d1168 1
a1168 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
d1255 2
d1320 6
d1343 1
a1343 1
	static char *space="                ";
d1350 3
d1455 8
d1468 1
a1468 1
	BIO_flush(bio);
d1471 28
@


1.13
log
@resolve conflicts
@
text
@d246 1
d295 1
a295 1
		((mbuf=OPENSSL_malloc(BUFSIZZ)) == NULL))
d600 2
d606 6
a611 1
		BIO_read(sbio,mbuf,BUFSIZZ);
d613 6
a618 1
		BIO_read(sbio,mbuf,BUFSIZZ);
d624 6
a629 1
		BIO_read(sbio,mbuf,BUFSIZZ);
d633 2
@


1.12
log
@support IPv6 connections in "openssl s_client", adding -4 and -6 options to
force protocol; ok itojun@@
@
text
@d204 3
d358 4
d603 2
@


1.11
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d112 2
d188 2
d239 1
a239 1
	int s,k,width,state=0;
d244 1
a244 1
	short port=PORT;
d315 2
a316 2
			port=atoi(*(++argv));
			if (port == 0) goto bad;
d436 2
d533 1
a533 1
	if (init_client(&s,host,port) == 0)
@


1.10
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@a138 4
#ifdef OPENSSL_SYS_WINDOWS
#include <conio.h>
#endif

d220 1
a220 1
	BIO_printf(bio_err,"                 only \"smtp\" is supported.\n");
d250 1
a250 1
	int smtp_starttls = 0;
d259 1
a259 1
#ifdef OPENSSL_SYS_WINDOWS
d414 3
a416 1
				smtp_starttls = 1;
d588 1
a588 1
	if (smtp_starttls)
d594 6
d620 1
a620 1
				if (smtp_starttls)
d624 1
a624 1
					smtp_starttls = 0;
d643 1
a643 1
#ifndef OPENSSL_SYS_WINDOWS
d670 2
a671 2
#ifdef OPENSSL_SYS_WINDOWS
			/* Under Windows we make the assumption that we can
d685 1
a685 1
#ifdef OPENSSL_SYS_WINCE
d854 2
a855 2
#ifdef OPENSSL_SYS_WINDOWS
#ifdef OPENSSL_SYS_WINCE
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d788 1
a788 1
			sbuf_len-=i;;
@


1.8
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d143 8
d225 1
d227 1
d259 1
d262 1
d422 1
d428 1
d453 1
d455 1
d681 3
d685 1
d769 2
a770 2
#ifdef OPENSSL_SYS_WINDOWS
		/* Assume Windows can always write */
d851 3
d855 1
d919 3
a921 3
	if (cbuf != NULL) { memset(cbuf,0,BUFSIZZ); OPENSSL_free(cbuf); }
	if (sbuf != NULL) { memset(sbuf,0,BUFSIZZ); OPENSSL_free(sbuf); }
	if (mbuf != NULL) { memset(mbuf,0,BUFSIZZ); OPENSSL_free(mbuf); }
d928 1
a928 1
	EXIT(ret);
d957 1
a957 1
					sk_X509_value(sk,i)),buf,BUFSIZ);
d960 1
a960 1
					sk_X509_value(sk,i)),buf,BUFSIZ);
d975 1
a975 1
				buf,BUFSIZ);
d978 1
a978 1
				buf,BUFSIZ);
d1000 1
a1000 1
		p=SSL_get_shared_ciphers(s,buf,BUFSIZ);
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d436 5
a461 5

	OpenSSL_add_ssl_algorithms();
	SSL_load_error_strings();

        e = setup_engine(bio_err, engine_id, 1);
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d58 53
d116 2
a117 1
#ifdef NO_STDIO
d125 1
a125 1
#if defined(VMS) && defined(__DECC) && !defined(__U_INT)
a136 1
#include <openssl/engine.h>
d139 1
a139 1
#ifdef WINDOWS
d144 1
a144 1
#if (defined(VMS) && __VMS_VER < 70000000)
d169 1
d196 1
d210 1
d213 5
d219 1
a219 1
	BIO_printf(bio_err," -engine id    - Initialise and use the specified engine\n");
d228 1
d230 1
a230 1
	char *cbuf=NULL,*sbuf=NULL;
d244 2
a245 1
	int prexit = 0;
d251 1
a251 1
#ifdef WINDOWS
d255 1
a255 1
#if !defined(NO_SSL2) && !defined(NO_SSL3)
d257 1
a257 1
#elif !defined(NO_SSL3)
d259 1
a259 1
#elif !defined(NO_SSL2)
d268 1
d274 3
d278 2
a279 1
		((sbuf=OPENSSL_malloc(BUFSIZZ)) == NULL))
d324 4
d343 2
d351 1
a351 1
#ifndef NO_SSL2
d355 1
a355 1
#ifndef NO_SSL3
d359 1
a359 1
#ifndef NO_TLS1
d390 2
d401 1
a401 1
		else if (strcmp(*argv,"-rand") == 0)
d404 5
a408 1
			inrand= *(++argv);
d415 5
d447 1
a447 1
		if (c_quiet)
d461 1
a461 22
	if (engine_id != NULL)
		{
		if((e = ENGINE_by_id(engine_id)) == NULL)
			{
			BIO_printf(bio_err,"invalid engine\n");
			ERR_print_errors(bio_err);
			goto end;
			}
		if (c_debug)
			{
			ENGINE_ctrl(e, ENGINE_CTRL_SET_LOGSTREAM,
				0, bio_err, 0);
			}
		if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
			{
			BIO_printf(bio_err,"can't use that engine\n");
			ERR_print_errors(bio_err);
			goto end;
			}
		BIO_printf(bio_err,"engine \"%s\" set.\n", engine_id);
		ENGINE_free(e);
		}
d499 2
d503 6
d550 5
d573 8
d600 7
d623 1
a623 1
#ifndef WINDOWS
d650 1
a650 1
#ifdef WINDOWS
d749 1
a749 1
#ifdef WINDOWS
d830 1
a830 1
#ifdef WINDOWS
d897 1
d903 1
d1025 2
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d82 1
d157 1
a158 1

d185 1
d325 5
d351 8
a358 1
	app_RAND_load_file(NULL, bio_err, 0);
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d82 1
d156 1
d184 2
d208 2
a209 2
	if (	((cbuf=Malloc(BUFSIZZ)) == NULL) ||
		((sbuf=Malloc(BUFSIZZ)) == NULL))
d323 5
d361 24
d559 1
a559 1
					if(!i && (!_kbhit() || !read_tty) ) continue;
d725 1
a725 1
		else if (_kbhit())
d789 2
a790 2
	if (cbuf != NULL) { memset(cbuf,0,BUFSIZZ); Free(cbuf); }
	if (sbuf != NULL) { memset(sbuf,0,BUFSIZZ); Free(sbuf); }
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d120 1
d147 1
d197 1
d255 1
d257 4
d722 1
a722 1
			if ((!c_quiet) && ((i <= 0) || (cbuf[0] == 'Q')))
d728 1
a728 1
			if ((!c_quiet) && (cbuf[0] == 'R'))
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d59 1
a59 3
#ifdef APPS_CRLF
# include <assert.h>
#endif
d84 5
a93 4
#if defined(NO_RSA) && !defined(NO_SSL2)
#define NO_SSL2
#endif

a143 1
#ifdef APPS_CRLF /* won't be #ifdef'd in next release */
a144 1
#endif
d151 1
a151 1
	BIO_printf(bio_err," -cipher       - prefered cipher to use, use the 'openssl ciphers'\n");
d156 2
a172 1
#ifdef APPS_CRLF
a173 1
#endif
d177 1
d180 3
a182 1
	/*static struct timeval timeout={10,0};*/
d247 2
a248 1
#ifdef APPS_CRLF
a250 1
#endif
d327 2
d342 2
a343 1
	SSLeay_add_ssl_algorithms();
d358 5
a362 1
		SSL_CTX_set_cipher_list(ctx,cipher);
d375 1
a375 1
		/* BIO_printf(bio_err,"error seting default verify locations\n"); */
a379 1
	SSL_load_error_strings();
d381 1
a381 1
	con=(SSL *)SSL_new(ctx);
a481 1
#endif
d486 8
a493 1

d503 20
d525 1
d602 4
a605 1
#ifndef WINDOWS
d607 1
a628 1
#endif
d683 3
a685 1
#ifndef WINDOWS
d687 1
a688 1
#ifdef APPS_CRLF
a711 1
#endif
a737 1
#endif
d744 1
@


1.1
log
@Initial revision
@
text
@d59 3
a64 1
#define USE_SOCKETS
d68 11
d80 4
a83 4
#include "x509.h"
#include "ssl.h"
#include "err.h"
#include "pem.h"
d86 9
d115 1
a116 1
#ifndef NOPROTO
a118 5
#else
static void sc_usage();
static void print_stuff();
#endif

d122 1
a122 1
static void sc_usage()
d124 1
a124 1
	BIO_printf(bio_err,"usage: client args\n");
d138 1
d145 3
d154 2
a155 2
	BIO_printf(bio_err," -cipher       - prefered cipher to use, use the 'ssleay ciphers'\n");
	BIO_printf(bio_err,"                 command to se what is available\n");
d159 1
a159 3
int MAIN(argc, argv)
int argc;
char **argv;
d174 4
a177 1
	int write_tty,read_tty,write_ssl,read_ssl,tty_on;
d196 1
d247 4
d257 2
d466 4
d471 5
a475 5
		if (tty_on)
			{
			if (read_tty)  FD_SET(fileno(stdin),&readfds);
			if (write_tty) FD_SET(fileno(stdout),&writefds);
			}
d477 19
a495 12
		if (read_ssl)
			FD_SET(SSL_get_fd(con),&readfds);
		if (write_ssl)
			FD_SET(SSL_get_fd(con),&writefds);

/*		printf("mode tty(%d %d%d) ssl(%d%d)\n",
			tty_on,read_tty,write_tty,read_ssl,write_ssl);*/

		i=select(width,&readfds,&writefds,NULL,NULL);
		if ( i < 0)
			{
			BIO_printf(bio_err,"bad select %d\n",
d497 3
a499 2
			goto shut;
			/* goto end; */
d502 1
a502 1
		if (FD_ISSET(SSL_get_fd(con),&writefds))
d570 1
a570 1
		else if (FD_ISSET(fileno(stdout),&writefds))
d572 3
d593 1
a593 1
		else if (FD_ISSET(SSL_get_fd(con),&readfds))
d598 1
d600 7
d643 1
a643 1
				break;
d650 26
a675 1
			i=read(fileno(stdin),cbuf,BUFSIZZ);
d685 1
d687 1
a687 2
				read_tty=0;
				write_ssl=1;
d693 3
d698 1
a699 1
			write_ssl=1;
d722 1
a722 4
static void print_stuff(bio,s,full)
BIO *bio;
SSL *s;
int full;
d728 2
a729 1
	STACK *sk;
d736 2
d741 4
a744 2
			BIO_printf(bio,"---\nCertficate chain\n");
			for (i=0; i<sk_num(sk); i++)
d746 2
a747 2
				X509_NAME_oneline(X509_get_subject_name((X509 *)
					sk_value(sk,i)),buf,BUFSIZ);
d749 2
a750 2
				X509_NAME_oneline(X509_get_issuer_name((X509 *)
					sk_value(sk,i)),buf,BUFSIZ);
d752 2
d762 2
a763 1
			PEM_write_bio_X509(bio,peer);
d774 2
a775 2
		sk=SSL_get_client_CA_list(s);
		if ((sk != NULL) && (sk_num(sk) > 0))
d778 1
a778 1
			for (i=0; i<sk_num(sk); i++)
d780 1
a780 1
				xn=(X509_NAME *)sk_value(sk,i);
d793 5
d828 3
a830 1
	if (peer != NULL)
d832 3
a834 1
			EVP_PKEY_bits(X509_get_pubkey(peer)));
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
a58 1
#include <assert.h>
d62 2
a63 2
#include <openssl/e_os2.h>
#ifdef OPENSSL_NO_STDIO
a65 11

/* With IPv6, it looks like Digital has mixed up the proper order of
   recursive header file inclusion, resulting in the compiler complaining
   that u_int isn't defined, but only if _POSIX_C_SOURCE is defined, which
   is needed to have fileno() declared correctly...  So let's define u_int */
#if defined(OPENSSL_SYS_VMS_DECC) && !defined(__U_INT)
#define __U_INT
typedef unsigned int u_int;
#endif

#define USE_SOCKETS
d67 4
a70 5
#include <openssl/x509.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rand.h>
a72 10
#ifdef OPENSSL_SYS_WINDOWS
#include <conio.h>
#endif


#if (defined(OPENSSL_SYS_VMS) && __VMS_VER < 70000000)
/* FIONBIO used as a switch to enable ioctl, and that isn't in VMS < 7.0 */
#undef FIONBIO
#endif

a92 2
static int c_msg=0;
static int c_showcerts=0;
d94 1
d97 5
a103 1
static int c_ign_eof=0;
d105 1
a105 1
static void sc_usage(void)
d107 1
a107 1
	BIO_printf(bio_err,"usage: s_client args\n");
a120 1
	BIO_printf(bio_err," -showcerts    - show all certificates in the chain\n");
a121 1
	BIO_printf(bio_err," -msg          - Show protocol messages\n");
a126 1
	BIO_printf(bio_err," -crlf         - convert LF from terminal into CRLF\n");
a127 1
	BIO_printf(bio_err," -ign_eof      - ignore input eof (default when -quiet)\n");
d133 2
a134 9
	BIO_printf(bio_err," -serverpref   - Use server's cipher preferences (only SSLv2)\n");
	BIO_printf(bio_err," -cipher       - preferred cipher to use, use the 'openssl ciphers'\n");
	BIO_printf(bio_err,"                 command to see what is available\n");
	BIO_printf(bio_err," -starttls prot - use the STARTTLS command before starting TLS\n");
	BIO_printf(bio_err,"                 for those protocols that support it, where\n");
	BIO_printf(bio_err,"                 'prot' defines which one to assume.  Currently,\n");
	BIO_printf(bio_err,"                 only \"smtp\" is supported.\n");
	BIO_printf(bio_err," -engine id    - Initialise and use the specified engine\n");
	BIO_printf(bio_err," -rand file%cfile%c...\n", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
d138 3
a140 3
int MAIN(int, char **);

int MAIN(int argc, char **argv)
a143 1
	X509_STORE *store = NULL;
d145 1
a145 1
	char *cbuf=NULL,*sbuf=NULL,*mbuf=NULL;
d155 1
a155 2
	int crlf=0;
	int write_tty,read_tty,write_ssl,read_ssl,tty_on,ssl_pending;
a157 2
	int smtp_starttls = 0;
	int prexit = 0, vflags = 0;
d160 1
a160 6
	char *inrand=NULL;
	char *engine_id=NULL;
	ENGINE *e=NULL;
#ifdef OPENSSL_SYS_WINDOWS
	struct timeval tv;
#endif
d162 1
a162 1
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
d164 1
a164 1
#elif !defined(OPENSSL_NO_SSL3)
d166 1
a166 1
#elif !defined(OPENSSL_NO_SSL2)
a172 1
	c_ign_eof=0;
a173 2
	c_msg=0;
	c_showcerts=0;
d178 2
a179 6
	if (!load_config(bio_err, NULL))
		goto end;

	if (	((cbuf=OPENSSL_malloc(BUFSIZZ)) == NULL) ||
		((sbuf=OPENSSL_malloc(BUFSIZZ)) == NULL) ||
		((mbuf=OPENSSL_malloc(BUFSIZZ)) == NULL))
a223 8
		else if	(strcmp(*argv,"-crl_check") == 0)
			vflags |= X509_V_FLAG_CRL_CHECK;
		else if	(strcmp(*argv,"-crl_check_all") == 0)
			vflags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;
		else if	(strcmp(*argv,"-prexit") == 0)
			prexit=1;
		else if	(strcmp(*argv,"-crlf") == 0)
			crlf=1;
a224 1
			{
a225 4
			c_ign_eof=1;
			}
		else if	(strcmp(*argv,"-ign_eof") == 0)
			c_ign_eof=1;
a229 4
		else if	(strcmp(*argv,"-msg") == 0)
			c_msg=1;
		else if	(strcmp(*argv,"-showcerts") == 0)
			c_showcerts=1;
d234 1
a234 1
#ifndef OPENSSL_NO_SSL2
d238 1
a238 1
#ifndef OPENSSL_NO_SSL3
d242 1
a242 1
#ifndef OPENSSL_NO_TLS1
a272 2
		else if (strcmp(*argv,"-serverpref") == 0)
			off|=SSL_OP_CIPHER_SERVER_PREFERENCE;
a281 19
		else if	(strcmp(*argv,"-starttls") == 0)
			{
			if (--argc < 1) goto bad;
			++argv;
			if (strcmp(*argv,"smtp") == 0)
				smtp_starttls = 1;
			else
				goto bad;
			}
		else if	(strcmp(*argv,"-engine") == 0)
			{
			if (--argc < 1) goto bad;
			engine_id = *(++argv);
			}
		else if (strcmp(*argv,"-rand") == 0)
			{
			if (--argc < 1) goto bad;
			inrand= *(++argv);
			}
a297 9
	if (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL
		&& !RAND_status())
		{
		BIO_printf(bio_err,"warning, not much extra random data, consider using the -rand option\n");
		}
	if (inrand != NULL)
		BIO_printf(bio_err,"%ld semi-random bytes loaded\n",
			app_RAND_load_files(inrand));

d300 1
a300 1
		if (c_quiet && !c_debug && !c_msg)
d311 1
a311 5
	OpenSSL_add_ssl_algorithms();
	SSL_load_error_strings();

        e = setup_engine(bio_err, engine_id, 1);

d326 1
a326 5
		if(!SSL_CTX_set_cipher_list(ctx,cipher)) {
		BIO_printf(bio_err,"error setting cipher list\n");
		ERR_print_errors(bio_err);
		goto end;
	}
d339 1
a339 1
		/* BIO_printf(bio_err,"error setting default verify locations\n"); */
d344 1
a344 2
	store = SSL_CTX_get_cert_store(ctx);
	X509_STORE_set_flags(store, vflags);
d346 1
a346 7
	con=SSL_new(ctx);
#ifndef OPENSSL_NO_KRB5
	if (con  &&  (con->kssl_ctx = kssl_ctx_new()) != NULL)
                {
                kssl_ctx_setstring(con->kssl_ctx, KSSL_SERVER, host);
		}
#endif	/* OPENSSL_NO_KRB5  */
a387 5
	if (c_msg)
		{
		SSL_set_msg_callback(con, msg_cb);
		SSL_set_msg_callback_arg(con, bio_c_out);
		}
a405 8
	/* This is an ugly hack that does a lot of assumptions */
	if (smtp_starttls)
		{
		BIO_read(sbio,mbuf,BUFSIZZ);
		BIO_printf(sbio,"STARTTLS\r\n");
		BIO_read(sbio,sbuf,BUFSIZZ);
		}

a424 7
				if (smtp_starttls)
					{
					BIO_printf(bio_err,"%s",mbuf);
					/* We don't need to know any more */
					smtp_starttls = 0;
					}

d437 2
a438 3
		ssl_pending = read_ssl && SSL_pending(con);

		if (!ssl_pending)
d440 2
a441 45
#ifndef OPENSSL_SYS_WINDOWS
			if (tty_on)
				{
				if (read_tty)  FD_SET(fileno(stdin),&readfds);
				if (write_tty) FD_SET(fileno(stdout),&writefds);
				}
			if (read_ssl)
				FD_SET(SSL_get_fd(con),&readfds);
			if (write_ssl)
				FD_SET(SSL_get_fd(con),&writefds);
#else
			if(!tty_on || !write_tty) {
				if (read_ssl)
					FD_SET(SSL_get_fd(con),&readfds);
				if (write_ssl)
					FD_SET(SSL_get_fd(con),&writefds);
			}
#endif
/*			printf("mode tty(%d %d%d) ssl(%d%d)\n",
				tty_on,read_tty,write_tty,read_ssl,write_ssl);*/

			/* Note: under VMS with SOCKETSHR the second parameter
			 * is currently of type (int *) whereas under other
			 * systems it is (void *) if you don't have a cast it
			 * will choke the compiler: if you do have a cast then
			 * you can either go for (int *) or (void *).
			 */
#ifdef OPENSSL_SYS_WINDOWS
			/* Under Windows we make the assumption that we can
			 * always write to the tty: therefore if we need to
			 * write to the tty we just fall through. Otherwise
			 * we timeout the select every second and see if there
			 * are any keypresses. Note: this is a hack, in a proper
			 * Windows application we wouldn't do this.
			 */
			i=0;
			if(!write_tty) {
				if(read_tty) {
					tv.tv_sec = 1;
					tv.tv_usec = 0;
					i=select(width,(void *)&readfds,(void *)&writefds,
						 NULL,&tv);
					if(!i && (!((_kbhit()) || (WAIT_OBJECT_0 == WaitForSingleObject(GetStdHandle(STD_INPUT_HANDLE), 0))) || !read_tty) ) continue;
				} else 	i=select(width,(void *)&readfds,(void *)&writefds,
					 NULL,NULL);
a442 3
#else
			i=select(width,(void *)&readfds,(void *)&writefds,
				 NULL,NULL);
d444 12
a455 3
			if ( i < 0)
				{
				BIO_printf(bio_err,"bad select %d\n",
d457 2
a458 3
				goto shut;
				/* goto end; */
				}
d461 1
a461 1
		if (!ssl_pending && FD_ISSET(SSL_get_fd(con),&writefds))
d528 2
a529 6
#ifdef OPENSSL_SYS_WINDOWS
		/* Assume Windows can always write */
		else if (!ssl_pending && write_tty)
#else
		else if (!ssl_pending && FD_ISSET(fileno(stdout),&writefds))
#endif
a530 3
#ifdef CHARSET_EBCDIC
			ascii2ebcdic(&(sbuf[sbuf_off]),&(sbuf[sbuf_off]),sbuf_len);
#endif
d548 2
a549 1
		else if (ssl_pending || FD_ISSET(SSL_get_fd(con),&readfds))
a553 1
#if 1
a554 7
#else
/* Demo for pending and peek :-) */
			k=SSL_read(con,sbuf,16);
{ char zbuf[10240]; 
printf("read=%d pending=%d peek=%d\n",k,SSL_pending(con),SSL_peek(con,zbuf,10240));
}
#endif
d591 1
a591 1
				/* break; */
d595 1
a595 3
#ifdef OPENSSL_SYS_WINDOWS
		else if ((_kbhit()) || (WAIT_OBJECT_0 == WaitForSingleObject(GetStdHandle(STD_INPUT_HANDLE), 0)))
#else
a596 1
#endif
d598 1
a598 3
			if (crlf)
				{
				int j, lf_num;
d600 1
a600 22
				i=read(fileno(stdin),cbuf,BUFSIZZ/2);
				lf_num = 0;
				/* both loops are skipped when i <= 0 */
				for (j = 0; j < i; j++)
					if (cbuf[j] == '\n')
						lf_num++;
				for (j = i-1; j >= 0; j--)
					{
					cbuf[j+lf_num] = cbuf[j];
					if (cbuf[j] == '\n')
						{
						lf_num--;
						i++;
						cbuf[j+lf_num] = '\r';
						}
					}
				assert(lf_num == 0);
				}
			else
				i=read(fileno(stdin),cbuf,BUFSIZZ);

			if ((!c_ign_eof) && ((i <= 0) || (cbuf[0] == 'Q')))
d606 1
a606 1
			if ((!c_ign_eof) && (cbuf[0] == 'R'))
a607 1
				BIO_printf(bio_err,"RENEGOTIATING\n");
d609 2
a610 1
				cbuf_len=0;
a615 3
#ifdef CHARSET_EBCDIC
				ebcdic2ascii(cbuf, cbuf, i);
#endif
d618 1
a619 1
			read_tty=0;
d621 1
a627 1
	if(prexit) print_stuff(bio_c_out,con,1);
d631 2
a632 3
	if (cbuf != NULL) { memset(cbuf,0,BUFSIZZ); OPENSSL_free(cbuf); }
	if (sbuf != NULL) { memset(sbuf,0,BUFSIZZ); OPENSSL_free(sbuf); }
	if (mbuf != NULL) { memset(mbuf,0,BUFSIZZ); OPENSSL_free(mbuf); }
a637 1
	apps_shutdown();
d642 4
a645 1
static void print_stuff(BIO *bio, SSL *s, int full)
d651 1
a651 2
	STACK_OF(X509) *sk;
	STACK_OF(X509_NAME) *sk2;
a657 2
		int got_a_chain = 0;

d661 2
a662 4
			got_a_chain = 1; /* we don't have it for SSL2 (yet) */

			BIO_printf(bio,"---\nCertificate chain\n");
			for (i=0; i<sk_X509_num(sk); i++)
d664 2
a665 2
				X509_NAME_oneline(X509_get_subject_name(
					sk_X509_value(sk,i)),buf,BUFSIZ);
d667 2
a668 2
				X509_NAME_oneline(X509_get_issuer_name(
					sk_X509_value(sk,i)),buf,BUFSIZ);
a669 2
				if (c_showcerts)
					PEM_write_bio_X509(bio,sk_X509_value(sk,i));
d678 1
a678 2
			if (!(c_showcerts && got_a_chain)) /* Redundant if we showed the whole chain */
				PEM_write_bio_X509(bio,peer);
d689 2
a690 2
		sk2=SSL_get_client_CA_list(s);
		if ((sk2 != NULL) && (sk_X509_NAME_num(sk2) > 0))
d693 1
a693 1
			for (i=0; i<sk_X509_NAME_num(sk2); i++)
d695 1
a695 1
				xn=sk_X509_NAME_value(sk2,i);
a707 5
			/* This works only for SSL 2.  In later protocol
			 * versions, the client does not know what other
			 * ciphers (in addition to the one to be used
			 * in the current connection) the server supports. */

d738 1
a738 3
	if (peer != NULL) {
		EVP_PKEY *pktmp;
		pktmp = X509_get_pubkey(peer);
d740 1
a740 3
							 EVP_PKEY_bits(pktmp));
		EVP_PKEY_free(pktmp);
	}
a744 2
	/* flush, or debugging output gets mixed with http response */
	BIO_flush(bio);
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a435 5
	OpenSSL_add_ssl_algorithms();
	SSL_load_error_strings();

        e = setup_engine(bio_err, engine_id, 1);

d457 5
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a142 8
#ifdef OPENSSL_SYS_WINCE
/* Windows CE incorrectly defines fileno as returning void*, so to avoid problems below... */
#ifdef fileno
#undef fileno
#endif
#define fileno(a) (int)_fileno(a)
#endif

a216 1
#ifndef OPENSSL_NO_ENGINE
a217 1
#endif
a248 1
#ifndef OPENSSL_NO_ENGINE
a250 1
#endif
a409 1
#ifndef OPENSSL_NO_ENGINE
a414 1
#endif
a438 1
#ifndef OPENSSL_NO_ENGINE
a439 1
#endif
a664 3
#ifdef OPENSSL_SYS_WINCE
					if(!i && (!_kbhit() || !read_tty) ) continue;
#else
a665 1
#endif
d749 2
a750 2
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
		/* Assume Windows/DOS can always write */
a830 3
#ifdef OPENSSL_SYS_WINCE
		else if (_kbhit())
#else
a831 1
#endif
d895 3
a897 3
	if (cbuf != NULL) { OPENSSL_cleanse(cbuf,BUFSIZZ); OPENSSL_free(cbuf); }
	if (sbuf != NULL) { OPENSSL_cleanse(sbuf,BUFSIZZ); OPENSSL_free(sbuf); }
	if (mbuf != NULL) { OPENSSL_cleanse(mbuf,BUFSIZZ); OPENSSL_free(mbuf); }
d904 1
a904 1
	OPENSSL_EXIT(ret);
d933 1
a933 1
					sk_X509_value(sk,i)),buf,sizeof buf);
d936 1
a936 1
					sk_X509_value(sk,i)),buf,sizeof buf);
d951 1
a951 1
				buf,sizeof buf);
d954 1
a954 1
				buf,sizeof buf);
d976 1
a976 1
		p=SSL_get_shared_ciphers(s,buf,sizeof buf);
@


1.1.1.5
log
@import 0.9.7c
@
text
@d139 4
d224 1
a224 1
	BIO_printf(bio_err,"                 only \"smtp\" and \"pop3\" are supported.\n");
d254 1
a254 1
	int starttls_proto = 0;
d263 1
a263 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
d418 1
a418 3
				starttls_proto = 1;
			else if (strcmp(*argv,"pop3") == 0)
				starttls_proto = 2;
d590 1
a590 1
	if (starttls_proto == 1)
a595 6
	if (starttls_proto == 2)
		{
		BIO_read(sbio,mbuf,BUFSIZZ);
		BIO_printf(sbio,"STLS\r\n");
		BIO_read(sbio,sbuf,BUFSIZZ);
		}
d616 1
a616 1
				if (starttls_proto)
d620 1
a620 1
					starttls_proto = 0;
d639 1
a639 1
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS)
d666 2
a667 2
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
                        /* Under Windows/DOS we make the assumption that we can
d681 1
a681 1
#if defined(OPENSSL_SYS_WINCE) || defined(OPENSSL_SYS_MSDOS)
d850 2
a851 2
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
#if defined(OPENSSL_SYS_WINCE) || defined(OPENSSL_SYS_MSDOS)
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a199 3
#ifdef WATT32
	BIO_printf(bio_err," -wdebug       - WATT-32 tcp debugging\n");
#endif
a350 4
#ifdef WATT32
		else if	(strcmp(*argv,"-wdebug") == 0)
			dbug_init();
#endif
a589 2
		BIO_read(sbio,mbuf,BUFSIZZ);
		BIO_printf(sbio,"EHLO some.host.name\r\n");
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@a136 1
#include <openssl/ocsp.h>
a137 1
#include "timeouts.h"
a172 4
#ifndef OPENSSL_NO_TLSEXT
static int c_tlsextdebug=0;
static int c_status_req=0;
#endif
a177 3
#ifndef OPENSSL_NO_TLSEXT
static int ocsp_resp_cb(SSL *s, void *arg);
#endif
d190 1
a190 1
	BIO_printf(bio_err," -verify depth - turn on peer certificate verification\n");
d192 1
a192 2
	BIO_printf(bio_err," -certform arg - certificate format (PEM or DER) PEM default\n");
	BIO_printf(bio_err," -key arg      - Private key file to use, in cert file if\n");
a193 2
	BIO_printf(bio_err," -keyform arg  - key format (PEM or DER) PEM default\n");
	BIO_printf(bio_err," -pass arg     - private key file pass phrase source\n");
a214 2
	BIO_printf(bio_err," -dtls1        - just use DTLSv1\n");    
	BIO_printf(bio_err," -mtu          - set the MTU\n");
d223 1
a223 1
	BIO_printf(bio_err,"                 only \"smtp\", \"pop3\", \"imap\", and \"ftp\" are supported.\n");
a227 11
	BIO_printf(bio_err," -sess_out arg - file to write SSL session to\n");
	BIO_printf(bio_err," -sess_in arg  - file to read SSL session from\n");
#ifndef OPENSSL_NO_TLSEXT
	BIO_printf(bio_err," -servername host  - Set TLS extension servername in ClientHello\n");
	BIO_printf(bio_err," -tlsextdebug      - hex dump of all TLS extensions received\n");
	BIO_printf(bio_err," -status           - request certificate status from server\n");
	BIO_printf(bio_err," -no_ticket        - disable use of RFC4507bis session tickets\n");
#endif
	}

#ifndef OPENSSL_NO_TLSEXT
a228 17
/* This is a context that we pass to callbacks */
typedef struct tlsextctx_st {
   BIO * biodebug;
   int ack;
} tlsextctx;


static int MS_CALLBACK ssl_servername_cb(SSL *s, int *ad, void *arg)
	{
	tlsextctx * p = (tlsextctx *) arg;
	const char * hn= SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);
	if (SSL_get_servername_type(s) != -1) 
 	        p->ack = !SSL_session_reused(s) && hn != NULL;
	else 
		BIO_printf(bio_err,"Can't use SSL_get_servername\n");
	
	return SSL_TLSEXT_ERR_OK;
a229 9
#endif
enum
{
	PROTO_OFF	= 0,
	PROTO_SMTP,
	PROTO_POP3,
	PROTO_IMAP,
	PROTO_FTP
};
a246 4
	int cert_format = FORMAT_PEM, key_format = FORMAT_PEM;
	char *passarg = NULL, *pass = NULL;
	X509 *cert = NULL;
	EVP_PKEY *key = NULL;
d253 1
a253 1
	int starttls_proto = PROTO_OFF;
a255 4
#ifdef sock_type
#undef sock_type
#endif
	int sock_type=SOCK_STREAM;
a257 1
	int mbuf_len=0;
d262 1
a262 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)
a265 12
#ifndef OPENSSL_NO_TLSEXT
	char *servername = NULL; 
        tlsextctx tlsextcbp = 
        {NULL,0};
#endif
	char *sess_in = NULL;
	char *sess_out = NULL;
	struct sockaddr peer;
	int peerlen = sizeof(peer);
	int enable_timeouts = 0 ;
	long mtu = 0;

a334 15
		else if	(strcmp(*argv,"-sess_out") == 0)
			{
			if (--argc < 1) goto bad;
			sess_out = *(++argv);
			}
		else if	(strcmp(*argv,"-sess_in") == 0)
			{
			if (--argc < 1) goto bad;
			sess_in = *(++argv);
			}
		else if	(strcmp(*argv,"-certform") == 0)
			{
			if (--argc < 1) goto bad;
			cert_format = str2fmt(*(++argv));
			}
a353 6
#ifndef OPENSSL_NO_TLSEXT
		else if	(strcmp(*argv,"-tlsextdebug") == 0)
			c_tlsextdebug=1;
		else if	(strcmp(*argv,"-status") == 0)
			c_status_req=1;
#endif
d355 1
a355 1
		else if (strcmp(*argv,"-wdebug") == 0)
a377 14
#ifndef OPENSSL_NO_DTLS1
		else if	(strcmp(*argv,"-dtls1") == 0)
			{
			meth=DTLSv1_client_method();
			sock_type=SOCK_DGRAM;
			}
		else if (strcmp(*argv,"-timeout") == 0)
			enable_timeouts=1;
		else if (strcmp(*argv,"-mtu") == 0)
			{
			if (--argc < 1) goto bad;
			mtu = atol(*(++argv));
			}
#endif
a379 10
		else if	(strcmp(*argv,"-keyform") == 0)
			{
			if (--argc < 1) goto bad;
			key_format = str2fmt(*(++argv));
			}
		else if	(strcmp(*argv,"-pass") == 0)
			{
			if (--argc < 1) goto bad;
			passarg = *(++argv);
			}
a404 4
#ifndef OPENSSL_NO_TLSEXT
		else if	(strcmp(*argv,"-no_ticket") == 0)
			{ off|=SSL_OP_NO_TICKET; }
#endif
d421 1
a421 1
				starttls_proto = PROTO_SMTP;
d423 1
a423 5
				starttls_proto = PROTO_POP3;
			else if (strcmp(*argv,"imap") == 0)
				starttls_proto = PROTO_IMAP;
			else if (strcmp(*argv,"ftp") == 0)
				starttls_proto = PROTO_FTP;
a438 8
#ifndef OPENSSL_NO_TLSEXT
		else if (strcmp(*argv,"-servername") == 0)
			{
			if (--argc < 1) goto bad;
			servername= *(++argv);
			/* meth=TLSv1_client_method(); */
			}
#endif
a460 36
	if (!app_passwd(bio_err, passarg, NULL, &pass, NULL))
		{
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
		}

	if (key_file == NULL)
		key_file = cert_file;


	if (key_file)

		{

		key = load_key(bio_err, key_file, key_format, 0, pass, e,
			       "client certificate private key file");
		if (!key)
			{
			ERR_print_errors(bio_err);
			goto end;
			}

		}

	if (cert_file)

		{
		cert = load_cert(bio_err,cert_file,cert_format,
				NULL, e, "client certificate file");

		if (!cert)
			{
			ERR_print_errors(bio_err);
			goto end;
			}
		}
a494 4
	/* DTLS: partial reads end up discarding unread UDP bytes :-( 
	 * Setting read ahead solves this problem.
	 */
	if (sock_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx, 1);
d509 1
a509 1
	if (!set_cert_key_stuff(ctx,cert,key))
a521 8
#ifndef OPENSSL_NO_TLSEXT
	if (servername != NULL)
		{
		tlsextcbp.biodebug = bio_err;
		SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);
		SSL_CTX_set_tlsext_servername_arg(ctx, &tlsextcbp);
		}
#endif
a523 35
	if (sess_in)
		{
		SSL_SESSION *sess;
		BIO *stmp = BIO_new_file(sess_in, "r");
		if (!stmp)
			{
			BIO_printf(bio_err, "Can't open session file %s\n",
						sess_in);
			ERR_print_errors(bio_err);
			goto end;
			}
		sess = PEM_read_bio_SSL_SESSION(stmp, NULL, 0, NULL);
		BIO_free(stmp);
		if (!sess)
			{
			BIO_printf(bio_err, "Can't open session file %s\n",
						sess_in);
			ERR_print_errors(bio_err);
			goto end;
			}
		SSL_set_session(con, sess);
		SSL_SESSION_free(sess);
		}
#ifndef OPENSSL_NO_TLSEXT
	if (servername != NULL)
		{
		if (!SSL_set_tlsext_host_name(con,servername))
			{
			BIO_printf(bio_err,"Unable to set TLS servername extension.\n");
			ERR_print_errors(bio_err);
			goto end;
			}
		}
#endif

d534 1
a534 1
	if (init_client(&s,host,port,sock_type) == 0)
d555 1
a555 40

	if ( SSL_version(con) == DTLS1_VERSION)
		{
		struct timeval timeout;

		sbio=BIO_new_dgram(s,BIO_NOCLOSE);
		if (getsockname(s, &peer, (void *)&peerlen) < 0)
			{
			BIO_printf(bio_err, "getsockname:errno=%d\n",
				get_last_socket_error());
			SHUTDOWN(s);
			goto end;
			}

		(void)BIO_ctrl_set_connected(sbio, 1, &peer);

		if ( enable_timeouts)
			{
			timeout.tv_sec = 0;
			timeout.tv_usec = DGRAM_RCV_TIMEOUT;
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);
			
			timeout.tv_sec = 0;
			timeout.tv_usec = DGRAM_SND_TIMEOUT;
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);
			}

		if ( mtu > 0)
			{
			SSL_set_options(con, SSL_OP_NO_QUERY_MTU);
			SSL_set_mtu(con, mtu);
			}
		else
			/* want to do MTU discovery */
			BIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);
		}
	else
		sbio=BIO_new_socket(s,BIO_NOCLOSE);


d568 2
a569 2
		BIO_set_callback(sbio,bio_dump_callback);
		BIO_set_callback_arg(sbio,(char *)bio_c_out);
a575 24
#ifndef OPENSSL_NO_TLSEXT
	if (c_tlsextdebug)
		{
		SSL_set_tlsext_debug_callback(con, tlsext_cb);
		SSL_set_tlsext_debug_arg(con, bio_c_out);
		}
	if (c_status_req)
		{
		SSL_set_tlsext_status_type(con, TLSEXT_STATUSTYPE_ocsp);
		SSL_CTX_set_tlsext_status_cb(ctx, ocsp_resp_cb);
		SSL_CTX_set_tlsext_status_arg(ctx, bio_c_out);
#if 0
{
STACK_OF(OCSP_RESPID) *ids = sk_OCSP_RESPID_new_null();
OCSP_RESPID *id = OCSP_RESPID_new();
id->value.byKey = ASN1_OCTET_STRING_new();
id->type = V_OCSP_RESPID_KEY;
ASN1_STRING_set(id->value.byKey, "Hello World", -1);
sk_OCSP_RESPID_push(ids, id);
SSL_set_tlsext_status_ids(con, ids);
}
#endif
		}
#endif
d595 1
a595 7
	/* We do have to handle multi-line responses which may come
 	   in a single packet or not. We therefore have to use
	   BIO_gets() which does need a buffering BIO. So during
	   the initial chitchat we do push a buffering BIO into the
	   chain that is removed again later on to not disturb the
	   rest of the s_client operation. */
	if (starttls_proto == PROTO_SMTP)
d597 3
a599 27
		int foundit=0;
		BIO *fbio = BIO_new(BIO_f_buffer());
		BIO_push(fbio, sbio);
		/* wait for multi-line response to end from SMTP */
		do
			{
			mbuf_len = BIO_gets(fbio,mbuf,BUFSIZZ);
			}
		while (mbuf_len>3 && mbuf[3]=='-');
		/* STARTTLS command requires EHLO... */
		BIO_printf(fbio,"EHLO openssl.client.net\r\n");
		(void)BIO_flush(fbio);
		/* wait for multi-line response to end EHLO SMTP response */
		do
			{
			mbuf_len = BIO_gets(fbio,mbuf,BUFSIZZ);
			if (strstr(mbuf,"STARTTLS"))
				foundit=1;
			}
		while (mbuf_len>3 && mbuf[3]=='-');
		(void)BIO_flush(fbio);
		BIO_pop(fbio);
		BIO_free(fbio);
		if (!foundit)
			BIO_printf(bio_err,
				   "didn't found starttls in server response,"
				   " try anyway...\n");
d603 1
a603 1
	else if (starttls_proto == PROTO_POP3)
a608 43
	else if (starttls_proto == PROTO_IMAP)
		{
		int foundit=0;
		BIO *fbio = BIO_new(BIO_f_buffer());
		BIO_push(fbio, sbio);
		BIO_gets(fbio,mbuf,BUFSIZZ);
		/* STARTTLS command requires CAPABILITY... */
		BIO_printf(fbio,". CAPABILITY\r\n");
		(void)BIO_flush(fbio);
		/* wait for multi-line CAPABILITY response */
		do
			{
			mbuf_len = BIO_gets(fbio,mbuf,BUFSIZZ);
			if (strstr(mbuf,"STARTTLS"))
				foundit=1;
			}
		while (mbuf_len>3 && mbuf[0]!='.');
		(void)BIO_flush(fbio);
		BIO_pop(fbio);
		BIO_free(fbio);
		if (!foundit)
			BIO_printf(bio_err,
				   "didn't found STARTTLS in server response,"
				   " try anyway...\n");
		BIO_printf(sbio,". STARTTLS\r\n");
		BIO_read(sbio,sbuf,BUFSIZZ);
		}
	else if (starttls_proto == PROTO_FTP)
		{
		BIO *fbio = BIO_new(BIO_f_buffer());
		BIO_push(fbio, sbio);
		/* wait for multi-line response to end from FTP */
		do
			{
			mbuf_len = BIO_gets(fbio,mbuf,BUFSIZZ);
			}
		while (mbuf_len>3 && mbuf[3]=='-');
		(void)BIO_flush(fbio);
		BIO_pop(fbio);
		BIO_free(fbio);
		BIO_printf(sbio,"AUTH TLS\r\n");
		BIO_read(sbio,sbuf,BUFSIZZ);
		}
a625 11
				if (sess_out)
					{
					BIO *stmp = BIO_new_file(sess_out, "w");
					if (stmp)
						{
						PEM_write_bio_SSL_SESSION(stmp, SSL_get_session(con));
						BIO_free(stmp);
						}
					else 
						BIO_printf(bio_err, "Error writing session file %s\n", sess_out);
					}
d633 1
a633 1
					starttls_proto = PROTO_OFF;
d652 1
a652 1
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE)
a701 10
#elif defined(OPENSSL_SYS_NETWARE)
			if(!write_tty) {
				if(read_tty) {
					tv.tv_sec = 1;
					tv.tv_usec = 0;
					i=select(width,(void *)&readfds,(void *)&writefds,
						NULL,&tv);
				} else 	i=select(width,(void *)&readfds,(void *)&writefds,
					NULL,NULL);
			}
d782 1
a782 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)
a868 2
#elif defined (OPENSSL_SYS_NETWARE)
        else if (_kbhit())
a931 6
	if (cert)
		X509_free(cert);
	if (key)
		EVP_PKEY_free(key);
	if (pass)
		OPENSSL_free(pass);
d949 1
a949 1
	static const char *space="                ";
a955 3
#ifndef OPENSSL_NO_COMP
	const COMP_METHOD *comp, *expansion;
#endif
a1057 8
#ifndef OPENSSL_NO_COMP
	comp=SSL_get_current_compression(s);
	expansion=SSL_get_current_expansion(s);
	BIO_printf(bio,"Compression: %s\n",
		comp ? SSL_COMP_get_name(comp) : "NONE");
	BIO_printf(bio,"Expansion: %s\n",
		expansion ? SSL_COMP_get_name(expansion) : "NONE");
#endif
d1063 1
a1063 1
	(void)BIO_flush(bio);
a1065 28
#ifndef OPENSSL_NO_TLSEXT

static int ocsp_resp_cb(SSL *s, void *arg)
	{
	const unsigned char *p;
	int len;
	OCSP_RESPONSE *rsp;
	len = SSL_get_tlsext_status_ocsp_resp(s, &p);
	BIO_puts(arg, "OCSP response: ");
	if (!p)
		{
		BIO_puts(arg, "no response sent\n");
		return 1;
		}
	rsp = d2i_OCSP_RESPONSE(NULL, &p, len);
	if (!rsp)
		{
		BIO_puts(arg, "response parse error\n");
		BIO_dump_indent(arg, (char *)p, len, 4);
		return 0;
		}
	BIO_puts(arg, "\n======================================\n");
	OCSP_RESPONSE_print(arg, rsp, 0);
	BIO_puts(arg, "======================================\n");
	OCSP_RESPONSE_free(rsp);
	return 1;
	}
#endif  /* ndef OPENSSL_NO_TLSEXT */
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a223 1
	BIO_printf(bio_err," -no_ign_eof   - don't ignore input eof\n");
d237 1
a237 2
	BIO_printf(bio_err,"                 only \"smtp\", \"pop3\", \"imap\", \"ftp\" and \"xmpp\"\n");
	BIO_printf(bio_err,"                 are supported.\n");
d279 1
a279 2
	PROTO_FTP,
	PROTO_XMPP
d320 1
a320 2
	char *ssl_client_engine_id=NULL;
	ENGINE *ssl_client_engine=NULL;
a321 1
	ENGINE *e=NULL;
a336 3
#ifndef OPENSSL_NO_JPAKE
	char *jpake_secret = NULL;
#endif
a436 2
		else if	(strcmp(*argv,"-no_ign_eof") == 0)
			c_ign_eof=0;
a548 2
			else if (strcmp(*argv, "xmpp") == 0)
				starttls_proto = PROTO_XMPP;
a557 5
		else if	(strcmp(*argv,"-ssl_client_engine") == 0)
			{
			if (--argc < 1) goto bad;
			ssl_client_engine_id = *(++argv);
			}
a571 7
#ifndef OPENSSL_NO_JPAKE
		else if (strcmp(*argv,"-jpake") == 0)
			{
			if (--argc < 1) goto bad;
			jpake_secret = *++argv;
			}
#endif
a592 10
	if (ssl_client_engine_id)
		{
		ssl_client_engine = ENGINE_by_id(ssl_client_engine_id);
		if (!ssl_client_engine)
			{
			BIO_printf(bio_err,
					"Error getting client auth engine\n");
			goto end;
			}
		}
a659 14
#ifndef OPENSSL_NO_ENGINE
	if (ssl_client_engine)
		{
		if (!SSL_CTX_set_client_cert_engine(ctx, ssl_client_engine))
			{
			BIO_puts(bio_err, "Error setting client auth engine\n");
			ERR_print_errors(bio_err);
			ENGINE_free(ssl_client_engine);
			goto end;
			}
		ENGINE_free(ssl_client_engine);
		}
#endif

d810 2
a854 4
#ifndef OPENSSL_NO_JPAKE
	if (jpake_secret)
		jpake_client_auth(bio_c_out, sbio, jpake_secret);
#endif
a959 22
		}
	if (starttls_proto == PROTO_XMPP)
		{
		int seen = 0;
		BIO_printf(sbio,"<stream:stream "
		    "xmlns:stream='http://etherx.jabber.org/streams' "
		    "xmlns='jabber:client' to='%s' version='1.0'>", host);
		seen = BIO_read(sbio,mbuf,BUFSIZZ);
		mbuf[seen] = 0;
		while (!strstr(mbuf, "<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'"))
			{
			if (strstr(mbuf, "/stream:features>"))
				goto shut;
			seen = BIO_read(sbio,mbuf,BUFSIZZ);
			mbuf[seen] = 0;
			}
		BIO_printf(sbio, "<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>");
		seen = BIO_read(sbio,sbuf,BUFSIZZ);
		sbuf[seen] = 0;
		if (!strstr(sbuf, "<proceed"))
			goto shut;
		mbuf[0] = 0;
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
a110 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
a112 1
#include <ctype.h>
a137 1
#include <openssl/bn.h>
d141 9
a154 4
#if defined(OPENSSL_SYS_BEOS_R5)
#include <fcntl.h>
#endif

a168 1
extern int verify_return_error;
a190 63
#ifndef OPENSSL_NO_PSK
/* Default PSK identity and key */
static char *psk_identity="Client_identity";
/*char *psk_key=NULL;  by default PSK is not used */

static unsigned int psk_client_cb(SSL *ssl, const char *hint, char *identity,
	unsigned int max_identity_len, unsigned char *psk,
	unsigned int max_psk_len)
	{
	unsigned int psk_len = 0;
	int ret;
        BIGNUM *bn=NULL;

	if (c_debug)
		BIO_printf(bio_c_out, "psk_client_cb\n");
	if (!hint)
                {
                /* no ServerKeyExchange message*/
		if (c_debug)
			BIO_printf(bio_c_out,"NULL received PSK identity hint, continuing anyway\n");
                }
        else if (c_debug)
		BIO_printf(bio_c_out, "Received PSK identity hint '%s'\n", hint);

	/* lookup PSK identity and PSK key based on the given identity hint here */
	ret = BIO_snprintf(identity, max_identity_len, "%s", psk_identity);
	if (ret < 0 || (unsigned int)ret > max_identity_len)
		goto out_err;
	if (c_debug)
		BIO_printf(bio_c_out, "created identity '%s' len=%d\n", identity, ret);
        ret=BN_hex2bn(&bn, psk_key);
        if (!ret)
                {
                BIO_printf(bio_err,"Could not convert PSK key '%s' to BIGNUM\n", psk_key);
                if (bn)
                        BN_free(bn);
                return 0;
                }

        if ((unsigned int)BN_num_bytes(bn) > max_psk_len)
                {
                BIO_printf(bio_err,"psk buffer of callback is too small (%d) for key (%d)\n",
                        max_psk_len, BN_num_bytes(bn));
                BN_free(bn);
                return 0;
                }

        psk_len=BN_bn2bin(bn, psk);
        BN_free(bn);
        if (psk_len == 0)
                goto out_err;

	if (c_debug)
		BIO_printf(bio_c_out, "created PSK len=%d\n", psk_len);

        return psk_len;
 out_err:
	if (c_debug)
		BIO_printf(bio_err, "Error in PSK client callback\n");
        return 0;
	}
#endif

d199 1
a199 1
	BIO_printf(bio_err," -verify arg   - turn on peer certificate verification\n");
a224 7
#ifndef OPENSSL_NO_PSK
	BIO_printf(bio_err," -psk_identity arg - PSK identity\n");
	BIO_printf(bio_err," -psk arg      - PSK in hex (without 0x)\n");
# ifndef OPENSSL_NO_JPAKE
	BIO_printf(bio_err," -jpake arg    - JPAKE secret to use\n");
# endif
#endif
d229 1
a229 1
	BIO_printf(bio_err," -mtu          - set the link layer MTU\n");
a251 1
	BIO_printf(bio_err," -legacy_renegotiation - enable use of legacy renegotiation (dangerous)\n");
a274 1

d289 3
a291 2
	unsigned int off=0, clr=0;
	SSL *con=NULL;
d312 6
a317 5
	int prexit = 0;
	X509_VERIFY_PARAM *vpm = NULL;
	int badarg = 0;
	const SSL_METHOD *meth=NULL;
	int socket_type=SOCK_STREAM;
a320 1
	struct timeval timeout, *timeoutp;
d327 1
a327 1
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)
a328 3
#if defined(OPENSSL_SYS_BEOS_R5)
	int stdin_set = 0;
#endif
d330 1
d341 1
a341 1
	long socket_mtu = 0;
d430 4
a433 8
		else if (args_verify(&argv, &argc, &badarg, bio_err, &vpm))
			{
			if (badarg)
				goto bad;
			continue;
			}
		else if (strcmp(*argv,"-verify_return_error") == 0)
			verify_return_error = 1;
a468 21
#ifndef OPENSSL_NO_PSK
                else if (strcmp(*argv,"-psk_identity") == 0)
			{
			if (--argc < 1) goto bad;
			psk_identity=*(++argv);
			}
                else if (strcmp(*argv,"-psk") == 0)
			{
                        size_t j;

			if (--argc < 1) goto bad;
			psk_key=*(++argv);
			for (j = 0; j < strlen(psk_key); j++)
                                {
                                if (isxdigit((int)psk_key[j]))
                                        continue;
                                BIO_printf(bio_err,"Not a hex number '%s'\n",*argv);
                                goto bad;
                                }
			}
#endif
d485 1
a485 1
			socket_type=SOCK_DGRAM;
d492 1
a492 1
			socket_mtu = atol(*(++argv));
a531 2
		else if	(strcmp(*argv,"-no_comp") == 0)
			{ off|=SSL_OP_NO_COMPRESSION; }
a537 6
		else if (strcmp(*argv,"-legacy_renegotiation") == 0)
			off|=SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
		else if	(strcmp(*argv,"-legacy_server_connect") == 0)
			{ off|=SSL_OP_LEGACY_SERVER_CONNECT; }
		else if	(strcmp(*argv,"-no_legacy_server_connect") == 0)
			{ clr|=SSL_OP_LEGACY_SERVER_CONNECT; }
a611 20
#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)
	if (jpake_secret)
		{
		if (psk_key)
			{
			BIO_printf(bio_err,
				   "Can't use JPAKE and PSK together\n");
			goto end;
			}
		psk_identity = "JPAKE";
		}

	if (cipher)
		{
		BIO_printf(bio_err, "JPAKE sets cipher to PSK\n");
		goto end;
		}
	cipher = "PSK";
#endif

a626 1

a693 3
	if (vpm)
		SSL_CTX_set1_param(ctx, vpm);

a707 12
#ifndef OPENSSL_NO_PSK
#ifdef OPENSSL_NO_JPAKE
	if (psk_key != NULL)
#else
	if (psk_key != NULL || jpake_secret)
#endif
		{
		if (c_debug)
			BIO_printf(bio_c_out, "PSK key given or JPAKE in use, setting client callback\n");
		SSL_CTX_set_psk_client_callback(ctx, psk_client_cb);
		}
#endif
a711 3

	if (clr)
		SSL_CTX_clear_options(ctx, clr);
d715 1
a715 1
	if (socket_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx, 1);
d741 2
d787 1
a794 5
#if 0
#ifdef TLSEXT_TYPE_opaque_prf_input
	SSL_set_tlsext_opaque_prf_input(con, "Test client", 11);
#endif
#endif
d798 1
a798 1
	if (init_client(&s,host,port,socket_type) == 0)
d822 1
d835 1
a835 1
		if (enable_timeouts)
d846 1
a846 1
		if (socket_mtu > 28)
d849 1
a849 1
			SSL_set_mtu(con, socket_mtu - 28);
a1038 6
		if ((SSL_version(con) == DTLS1_VERSION) &&
			DTLSv1_get_timeout(con, &timeout))
			timeoutp = &timeout;
		else
			timeoutp = NULL;

a1049 8
#if 0 /* This test doesn't really work as intended (needs to be fixed) */
#ifndef OPENSSL_NO_TLSEXT
				if (servername != NULL && !SSL_session_reused(con))
					{
					BIO_printf(bio_c_out,"Server did %sacknowledge servername extension.\n",tlsextcbp.ack?"":"not ");
					}
#endif
#endif
d1087 1
a1087 1
#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE) && !defined (OPENSSL_SYS_BEOS_R5)
d1090 2
a1091 2
				if (read_tty)  openssl_fdset(fileno(stdin),&readfds);
				if (write_tty) openssl_fdset(fileno(stdout),&writefds);
d1094 1
a1094 1
				openssl_fdset(SSL_get_fd(con),&readfds);
d1096 1
a1096 1
				openssl_fdset(SSL_get_fd(con),&writefds);
d1100 1
a1100 1
					openssl_fdset(SSL_get_fd(con),&readfds);
d1102 1
a1102 1
					openssl_fdset(SSL_get_fd(con),&writefds);
d1135 1
a1135 1
					 NULL,timeoutp);
d1145 1
a1145 19
					NULL,timeoutp);
			}
#elif defined(OPENSSL_SYS_BEOS_R5)
			/* Under BeOS-R5 the situation is similar to DOS */
			i=0;
			stdin_set = 0;
			(void)fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);
			if(!write_tty) {
				if(read_tty) {
					tv.tv_sec = 1;
					tv.tv_usec = 0;
					i=select(width,(void *)&readfds,(void *)&writefds,
						 NULL,&tv);
					if (read(fileno(stdin), sbuf, 0) >= 0)
						stdin_set = 1;
					if (!i && (stdin_set != 1 || !read_tty))
						continue;
				} else 	i=select(width,(void *)&readfds,(void *)&writefds,
					 NULL,timeoutp);
a1146 1
			(void)fcntl(fileno(stdin), F_SETFL, 0);
d1149 1
a1149 1
				 NULL,timeoutp);
a1159 5
		if ((SSL_version(con) == DTLS1_VERSION) && DTLSv1_handle_timeout(con) > 0)
			{
			BIO_printf(bio_err,"TIMEOUT occured\n");
			}

a1199 1
					ret = 0;
d1227 2
a1228 2
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)
		/* Assume Windows/DOS/BeOS can always write */
d1237 1
a1237 1
			i=raw_write_stdout(&(sbuf[sbuf_off]),sbuf_len);
a1241 1
				ret = 0;
d1296 1
a1296 2
				ret=get_last_socket_error();
				BIO_printf(bio_err,"read:errno=%d\n",ret);
a1299 1
				ret=0;
d1315 1
a1315 3
		else if (_kbhit())
#elif defined(OPENSSL_SYS_BEOS_R5)
		else if (stdin_set)
d1324 1
a1324 1
				i=raw_read_stdin(cbuf,BUFSIZZ/2);
d1343 1
a1343 1
				i=raw_read_stdin(cbuf,BUFSIZZ);
a1347 1
				ret=0;
a1369 2

	ret=0;
a1370 2
	if (in_init)
		print_stuff(bio_c_out,con,full_log);
d1373 1
d1375 3
a1377 6
	if (con != NULL)
		{
		if (prexit != 0)
			print_stuff(bio_c_out,con,1);
		SSL_free(con);
		}
d1406 1
a1406 1
	const SSL_CIPHER *c;
a1513 2
	BIO_printf(bio, "Secure Renegotiation IS%s supported\n",
			SSL_get_secure_renegotiation_support(s) ? "" : " NOT");
d1557 1
a1557 2

#endif
@


1.1.1.10
log
@import OpenSSL-1.0.1c
@
text
@a165 3
#ifndef OPENSSL_NO_SRP
#include <openssl/srp.h>
#endif
a205 3
static char *keymatexportlabel=NULL;
static int keymatexportlen=20;

a318 7
#ifndef OPENSSL_NO_SRP
	BIO_printf(bio_err," -srpuser user     - SRP authentification for 'user'\n");
	BIO_printf(bio_err," -srppass arg      - password for 'user'\n");
	BIO_printf(bio_err," -srp_lateuser     - SRP username into second ClientHello message\n");
	BIO_printf(bio_err," -srp_moregroups   - Tolerate other than the known g N values.\n");
	BIO_printf(bio_err," -srp_strength int - minimal mength in bits for N (default %d).\n",SRP_MINIMAL_N);
#endif
a320 2
	BIO_printf(bio_err," -tls1_2       - just use TLSv1.2\n");
	BIO_printf(bio_err," -tls1_1       - just use TLSv1.1\n");
d324 1
a324 1
	BIO_printf(bio_err," -no_tls1_2/-no_tls1_1/-no_tls1/-no_ssl3/-no_ssl2 - turn off that protocol\n");
a344 3
# if !defined(OPENSSL_NO_NEXTPROTONEG)
	BIO_printf(bio_err," -nextprotoneg arg - enable NPN extension, considering named protocols supported (comma-separated list)\n");
# endif
a346 3
	BIO_printf(bio_err," -use_srtp profiles - Offer SRTP key management with a colon-separated profile list\n");
 	BIO_printf(bio_err," -keymatexport label   - Export keying material using label\n");
 	BIO_printf(bio_err," -keymatexportlen len  - Export len bytes of keying material (default 20)\n");
a368 150

#ifndef OPENSSL_NO_SRP

/* This is a context that we pass to all callbacks */
typedef struct srp_arg_st
	{
	char *srppassin;
	char *srplogin;
	int msg;   /* copy from c_msg */
	int debug; /* copy from c_debug */
	int amp;   /* allow more groups */
	int strength /* minimal size for N */ ;
	} SRP_ARG;

#define SRP_NUMBER_ITERATIONS_FOR_PRIME 64

static int srp_Verify_N_and_g(BIGNUM *N, BIGNUM *g)
	{
	BN_CTX *bn_ctx = BN_CTX_new();
	BIGNUM *p = BN_new();
	BIGNUM *r = BN_new();
	int ret =
		g != NULL && N != NULL && bn_ctx != NULL && BN_is_odd(N) &&
		BN_is_prime_ex(N, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) &&
		p != NULL && BN_rshift1(p, N) &&

		/* p = (N-1)/2 */
		BN_is_prime_ex(p, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) &&
		r != NULL &&

		/* verify g^((N-1)/2) == -1 (mod N) */
		BN_mod_exp(r, g, p, N, bn_ctx) &&
		BN_add_word(r, 1) &&
		BN_cmp(r, N) == 0;

	if(r)
		BN_free(r);
	if(p)
		BN_free(p);
	if(bn_ctx)
		BN_CTX_free(bn_ctx);
	return ret;
	}

/* This callback is used here for two purposes:
   - extended debugging
   - making some primality tests for unknown groups
   The callback is only called for a non default group.

   An application does not need the call back at all if
   only the stanard groups are used.  In real life situations, 
   client and server already share well known groups, 
   thus there is no need to verify them. 
   Furthermore, in case that a server actually proposes a group that
   is not one of those defined in RFC 5054, it is more appropriate 
   to add the group to a static list and then compare since 
   primality tests are rather cpu consuming.
*/

static int MS_CALLBACK ssl_srp_verify_param_cb(SSL *s, void *arg)
	{
	SRP_ARG *srp_arg = (SRP_ARG *)arg;
	BIGNUM *N = NULL, *g = NULL;
	if (!(N = SSL_get_srp_N(s)) || !(g = SSL_get_srp_g(s)))
		return 0;
	if (srp_arg->debug || srp_arg->msg || srp_arg->amp == 1)
		{
    		BIO_printf(bio_err, "SRP parameters:\n"); 
		BIO_printf(bio_err,"\tN="); BN_print(bio_err,N);
		BIO_printf(bio_err,"\n\tg="); BN_print(bio_err,g);
		BIO_printf(bio_err,"\n");
		}

	if (SRP_check_known_gN_param(g,N))
		return 1;

	if (srp_arg->amp == 1)
		{
		if (srp_arg->debug)
			BIO_printf(bio_err, "SRP param N and g are not known params, going to check deeper.\n");

/* The srp_moregroups is a real debugging feature.
   Implementors should rather add the value to the known ones.
   The minimal size has already been tested.
*/
		if (BN_num_bits(g) <= BN_BITS && srp_Verify_N_and_g(N,g))
			return 1;
		}	
	BIO_printf(bio_err, "SRP param N and g rejected.\n");
	return 0;
	}

#define PWD_STRLEN 1024

static char * MS_CALLBACK ssl_give_srp_client_pwd_cb(SSL *s, void *arg)
	{
	SRP_ARG *srp_arg = (SRP_ARG *)arg;
	char *pass = (char *)OPENSSL_malloc(PWD_STRLEN+1);
	PW_CB_DATA cb_tmp;
	int l;

	cb_tmp.password = (char *)srp_arg->srppassin;
	cb_tmp.prompt_info = "SRP user";
	if ((l = password_callback(pass, PWD_STRLEN, 0, &cb_tmp))<0)
		{
		BIO_printf (bio_err, "Can't read Password\n");
		OPENSSL_free(pass);
		return NULL;
		}
	*(pass+l)= '\0';

	return pass;
	}

#endif
	char *srtp_profiles = NULL;

# ifndef OPENSSL_NO_NEXTPROTONEG
/* This the context that we pass to next_proto_cb */
typedef struct tlsextnextprotoctx_st {
	unsigned char *data;
	unsigned short len;
	int status;
} tlsextnextprotoctx;

static tlsextnextprotoctx next_proto;

static int next_proto_cb(SSL *s, unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg)
	{
	tlsextnextprotoctx *ctx = arg;

	if (!c_quiet)
		{
		/* We can assume that |in| is syntactically valid. */
		unsigned i;
		BIO_printf(bio_c_out, "Protocols advertised by server: ");
		for (i = 0; i < inlen; )
			{
			if (i)
				BIO_write(bio_c_out, ", ", 2);
			BIO_write(bio_c_out, &in[i + 1], in[i]);
			i += in[i] + 1;
			}
		BIO_write(bio_c_out, "\n", 1);
		}

	ctx->status = SSL_select_next_proto(out, outlen, in, inlen, ctx->data, ctx->len);
	return SSL_TLSEXT_ERR_OK;
	}
# endif
a386 3
#ifndef OPENSSL_NO_KRB5
	KSSL_CTX *kctx;
#endif
a431 3
# ifndef OPENSSL_NO_NEXTPROTONEG
	const char *next_proto_neg_in = NULL;
# endif
a441 5
#ifndef OPENSSL_NO_SRP
	char * srppass = NULL;
	int srp_lateuser = 0;
	SRP_ARG srp_arg = {NULL,NULL,0,0,0,1024};
#endif
d443 1
d445 5
d584 1
a584 1
                                if (isxdigit((unsigned char)psk_key[j]))
a590 31
#ifndef OPENSSL_NO_SRP
		else if (strcmp(*argv,"-srpuser") == 0)
			{
			if (--argc < 1) goto bad;
			srp_arg.srplogin= *(++argv);
			meth=TLSv1_client_method();
			}
		else if (strcmp(*argv,"-srppass") == 0)
			{
			if (--argc < 1) goto bad;
			srppass= *(++argv);
			meth=TLSv1_client_method();
			}
		else if (strcmp(*argv,"-srp_strength") == 0)
			{
			if (--argc < 1) goto bad;
			srp_arg.strength=atoi(*(++argv));
			BIO_printf(bio_err,"SRP minimal length for N is %d\n",srp_arg.strength);
			meth=TLSv1_client_method();
			}
		else if (strcmp(*argv,"-srp_lateuser") == 0)
			{
			srp_lateuser= 1;
			meth=TLSv1_client_method();
			}
		else if	(strcmp(*argv,"-srp_moregroups") == 0)
			{
			srp_arg.amp=1;
			meth=TLSv1_client_method();
			}
#endif
a599 4
		else if	(strcmp(*argv,"-tls1_2") == 0)
			meth=TLSv1_2_client_method();
		else if	(strcmp(*argv,"-tls1_1") == 0)
			meth=TLSv1_1_client_method();
a647 4
		else if (strcmp(*argv,"-no_tls1_2") == 0)
			off|=SSL_OP_NO_TLSv1_2;
		else if (strcmp(*argv,"-no_tls1_1") == 0)
			off|=SSL_OP_NO_TLSv1_1;
a658 7
# ifndef OPENSSL_NO_NEXTPROTONEG
		else if (strcmp(*argv,"-nextprotoneg") == 0)
			{
			if (--argc < 1) goto bad;
			next_proto_neg_in = *(++argv);
			}
# endif
d726 1
a726 17
		else if (strcmp(*argv,"-use_srtp") == 0)
			{
			if (--argc < 1) goto bad;
			srtp_profiles = *(++argv);
			}
		else if (strcmp(*argv,"-keymatexport") == 0)
			{
			if (--argc < 1) goto bad;
			keymatexportlabel= *(++argv);
			}
		else if (strcmp(*argv,"-keymatexportlen") == 0)
			{
			if (--argc < 1) goto bad;
			keymatexportlen=atoi(*(++argv));
			if (keymatexportlen == 0) goto bad;
			}
                else
a751 6
		if (cipher)
			{
			BIO_printf(bio_err, "JPAKE sets cipher to PSK\n");
			goto end;
			}
		cipher = "PSK";
d753 7
a764 15
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	next_proto.status = -1;
	if (next_proto_neg_in)
		{
		next_proto.data = next_protos_parse(&next_proto.len, next_proto_neg_in);
		if (next_proto.data == NULL)
			{
			BIO_printf(bio_err, "Error parsing -nextprotoneg argument\n");
			goto end;
			}
		}
	else
		next_proto.data = NULL;
#endif

a837 8
#ifndef OPENSSL_NO_SRP
	if(!app_passwd(bio_err, srppass, NULL, &srp_arg.srppassin, NULL))
		{
		BIO_printf(bio_err, "Error getting password\n");
		goto end;
		}
#endif

a872 2
	if (srtp_profiles != NULL)
		SSL_CTX_set_tlsext_use_srtp(ctx, srtp_profiles);
a885 5
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	if (next_proto.data)
		SSL_CTX_set_next_proto_select_cb(ctx, next_proto_cb, &next_proto);
#endif

a916 18
#ifndef OPENSSL_NO_SRP
        if (srp_arg.srplogin)
		{
		if (!srp_lateuser && !SSL_CTX_set_srp_username(ctx, srp_arg.srplogin))
			{
			BIO_printf(bio_err,"Unable to set SRP username\n");
			goto end;
			}
		srp_arg.msg = c_msg;
		srp_arg.debug = c_debug ;
		SSL_CTX_set_srp_cb_arg(ctx,&srp_arg);
		SSL_CTX_set_srp_client_pwd_callback(ctx, ssl_give_srp_client_pwd_cb);
		SSL_CTX_set_srp_strength(ctx, srp_arg.strength);
		if (c_msg || c_debug || srp_arg.amp == 0)
			SSL_CTX_set_srp_verify_param_callback(ctx, ssl_srp_verify_param_cb);
		}

#endif
d955 1
a955 1
	if (con  &&  (kctx = kssl_ctx_new()) != NULL)
d957 1
a957 2
		SSL_set0_kssl_ctx(con, kctx);
                kssl_ctx_setstring(kctx, KSSL_SERVER, host);
d989 1
a989 1
	if (c_Pause & 0x01) SSL_set_debug(con, 1);
d1038 1
a1038 1
		SSL_set_debug(con, 1);
a1571 8
#ifndef OPENSSL_NO_HEARTBEATS
			else if ((!c_ign_eof) && (cbuf[0] == 'B'))
 				{
				BIO_printf(bio_err,"HEARTBEATING\n");
				SSL_heartbeat(con);
				cbuf_len=0;
				}
#endif
a1632 1
	unsigned char *exportedkeymat;
d1723 1
a1723 1
	BIO_printf(bio,(SSL_cache_hit(s)?"---\nReused, ":"---\nNew, "));
a1744 32
 
#ifdef SSL_DEBUG
	{
	/* Print out local port of connection: useful for debugging */
	int sock;
	struct sockaddr_in ladd;
	socklen_t ladd_size = sizeof(ladd);
	sock = SSL_get_fd(s);
	getsockname(sock, (struct sockaddr *)&ladd, &ladd_size);
	BIO_printf(bio_c_out, "LOCAL PORT is %u\n", ntohs(ladd.sin_port));
	}
#endif

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	if (next_proto.status != -1) {
		const unsigned char *proto;
		unsigned int proto_len;
		SSL_get0_next_proto_negotiated(s, &proto, &proto_len);
		BIO_printf(bio, "Next protocol: (%d) ", next_proto.status);
		BIO_write(bio, proto, proto_len);
		BIO_write(bio, "\n", 1);
	}
#endif

 	{
 	SRTP_PROTECTION_PROFILE *srtp_profile=SSL_get_selected_srtp_profile(s);
 
	if(srtp_profile)
		BIO_printf(bio,"SRTP Extension negotiated, profile=%s\n",
			   srtp_profile->name);
	}
 
a1745 27
	if (keymatexportlabel != NULL)
		{
		BIO_printf(bio, "Keying material exporter:\n");
		BIO_printf(bio, "    Label: '%s'\n", keymatexportlabel);
		BIO_printf(bio, "    Length: %i bytes\n", keymatexportlen);
		exportedkeymat = OPENSSL_malloc(keymatexportlen);
		if (exportedkeymat != NULL)
			{
			if (!SSL_export_keying_material(s, exportedkeymat,
						        keymatexportlen,
						        keymatexportlabel,
						        strlen(keymatexportlabel),
						        NULL, 0, 0))
				{
				BIO_printf(bio, "    Error\n");
				}
			else
				{
				BIO_printf(bio, "    Keying material: ");
				for (i=0; i<keymatexportlen; i++)
					BIO_printf(bio, "%02X",
						   exportedkeymat[i]);
				BIO_printf(bio, "\n");
				}
			OPENSSL_free(exportedkeymat);
			}
		}
@


1.1.1.11
log
@Import OpenSSL 1.0.1g
@
text
@d360 1
a360 1
# ifndef OPENSSL_NO_NEXTPROTONEG
a364 1
#ifndef OPENSSL_NO_SRTP
a365 1
#endif
a504 1
#ifndef OPENSSL_NO_SRTP
a505 1
#endif
d539 1
a539 1
# endif  /* ndef OPENSSL_NO_NEXTPROTONEG */
a947 1
#ifndef OPENSSL_NO_SRTP
a952 1
#endif
a1132 2
#endif
#ifndef OPENSSL_NO_SRTP
a1892 4
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	if (next_proto.data)
		OPENSSL_free(next_proto.data);
#endif
a1899 2
	if (vpm)
		X509_VERIFY_PARAM_free(vpm);
a2063 1
#ifndef OPENSSL_NO_SRTP
a2070 1
#endif
@


