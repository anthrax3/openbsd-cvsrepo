head	1.44;
access;
symbols
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	butholakala:1.18
	openssl_1_0_1_g:1.1.1.12
	OPENBSD_5_5:1.17.0.8
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	openssl_1_0_1_c:1.1.1.11
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	openssl_1_0_0_f:1.1.1.10
	openssl_1_0_0_e:1.1.1.10
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	openssh_1_0_0_a:1.1.1.9
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	openssl_0_9_8_k:1.1.1.8
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	openssl_0_9_8_j:1.1.1.8
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.44
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.43;
commitid	7A7DObXgY4Fni8xJ;

1.43
date	2014.07.18.18.01.26;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	qYPk42roNCidiTYq;

1.42
date	2014.07.17.23.50.07;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	O2A46QFugOGiibux;

1.41
date	2014.07.12.19.31.21;	author jsing;	state Exp;
branches;
next	1.40;
commitid	X84oGf60c5Z5Yd6T;

1.40
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.39;
commitid	0NuggCO2WJOZj8Kh;

1.39
date	2014.07.10.09.15.51;	author tedu;	state Exp;
branches;
next	1.38;
commitid	UBEq86QvA3vj9HEw;

1.38
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	mJUVYpkFBZ0Zv2bG;

1.37
date	2014.05.23.16.15.52;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.05.16.08.15;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.25.14.08.32;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.25.14.00.15;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.25.13.55.25;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.24.12.19.59;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.23.12.37.42;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.22.13.48.29;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.18.18.07.59;	author lteo;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.18.01.04.53;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.22.44.34;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.17.20.58.07;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.13.20.37.11;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.01.22.58.50;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.09.12.15.19;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.27.05.06.54;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.29.05.39.15;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.22.21.39.38;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.04.06.55.14;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.10.16.31.53;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.56.56;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.15.06.18.29;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.08.10;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.35.17;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.33;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.34.29;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.21;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.11.21.10.44;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.36.59;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.29;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.13.49;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2011.11.03.02.32.06;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.10.13.21.23.32;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: openssl.c,v 1.43 2014/07/18 18:01:26 deraadt Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <err.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "apps.h"

#include <openssl/bio.h>
#include <openssl/conf.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/lhash.h>
#include <openssl/pem.h>
#include <openssl/rand.h>
#include <openssl/ssl.h>
#include <openssl/x509.h>

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include "progs.h"
#include "s_apps.h"

static void openssl_startup(void);
static void openssl_shutdown(void);

/* The LHASH callbacks ("hash" & "cmp") have been replaced by functions with the
 * base prototypes (we cast each variable inside the function to the required
 * type of "FUNCTION*"). This removes the necessity for macro-generated wrapper
 * functions. */

static LHASH_OF(FUNCTION) *prog_init(void);
static int do_cmd(LHASH_OF(FUNCTION) *prog, int argc, char *argv[]);
static void list_pkey(BIO * out);
static void list_cipher(BIO * out);
static void list_md(BIO * out);
char *default_config_file = NULL;

CONF *config = NULL;
BIO *bio_err = NULL;

static void
lock_dbg_cb(int mode, int type, const char *file, int line)
{
	static int modes[CRYPTO_NUM_LOCKS];	/* = {0, 0, ... } */
	const char *errstr = NULL;
	int rw;

	rw = mode & (CRYPTO_READ | CRYPTO_WRITE);
	if (!((rw == CRYPTO_READ) || (rw == CRYPTO_WRITE))) {
		errstr = "invalid mode";
		goto err;
	}
	if (type < 0 || type >= CRYPTO_NUM_LOCKS) {
		errstr = "type out of bounds";
		goto err;
	}
	if (mode & CRYPTO_LOCK) {
		if (modes[type]) {
			errstr = "already locked";
			/*
			 * must not happen in a single-threaded program
			 * (would deadlock)
			 */
			goto err;
		}
		modes[type] = rw;
	} else if (mode & CRYPTO_UNLOCK) {
		if (!modes[type]) {
			errstr = "not locked";
			goto err;
		}
		if (modes[type] != rw) {
			errstr = (rw == CRYPTO_READ) ?
			    "CRYPTO_r_unlock on write lock" :
			    "CRYPTO_w_unlock on read lock";
		}
		modes[type] = 0;
	} else {
		errstr = "invalid mode";
		goto err;
	}

err:
	if (errstr) {
		/* we cannot use bio_err here */
		fprintf(stderr, "openssl (lock_dbg_cb): %s (mode=%d, type=%d) at %s:%d\n",
		    errstr, mode, type, file, line);
	}
}

static void
openssl_startup(void)
{
	signal(SIGPIPE, SIG_IGN);

	CRYPTO_malloc_init();
	OpenSSL_add_all_algorithms();
	SSL_library_init();
	SSL_load_error_strings();

#ifndef OPENSSL_NO_ENGINE
	ENGINE_load_builtin_engines();
#endif

	setup_ui_method();
}

static void
openssl_shutdown(void)
{
	CONF_modules_unload(1);
	destroy_ui_method();
	OBJ_cleanup();
	EVP_cleanup();

#ifndef OPENSSL_NO_ENGINE
	ENGINE_cleanup();
#endif

	CRYPTO_cleanup_all_ex_data();
	ERR_remove_thread_state(NULL);
	RAND_cleanup();
	ERR_free_strings();
}

int
main(int argc, char **argv)
{
	ARGS arg;
#define PROG_NAME_SIZE	39
	char pname[PROG_NAME_SIZE + 1];
	FUNCTION f, *fp;
	const char *prompt;
	char buf[1024];
	char *to_free = NULL;
	int n, i, ret = 0;
	char *p;
	LHASH_OF(FUNCTION) * prog = NULL;
	long errline;

	arg.data = NULL;
	arg.count = 0;

	bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
	if (bio_err == NULL) {
		fprintf(stderr, "openssl: failed to initialise bio_err\n");
		exit(1);
	}

	CRYPTO_set_locking_callback(lock_dbg_cb);

	openssl_startup();

	/* Lets load up our environment a little */
	p = getenv("OPENSSL_CONF");
	if (p == NULL)
		p = getenv("SSLEAY_CONF");
	if (p == NULL) {
		p = to_free = make_config_name();
		if (p == NULL) {
			BIO_printf(bio_err, "error making config file name\n");
			goto end;
		}
	}

	default_config_file = p;

	config = NCONF_new(NULL);
	i = NCONF_load(config, p, &errline);
	if (i == 0) {
		if (ERR_GET_REASON(ERR_peek_last_error()) ==
		    CONF_R_NO_SUCH_FILE) {
			BIO_printf(bio_err,
			    "WARNING: can't open config file: %s\n", p);
			ERR_clear_error();
			NCONF_free(config);
			config = NULL;
		} else {
			ERR_print_errors(bio_err);
			NCONF_free(config);
			exit(1);
		}
	}

	if (!load_config(bio_err, NULL)) {
		BIO_printf(bio_err, "failed to load configuration\n");
		goto end;
	}

	prog = prog_init();

	/* first check the program name */
	program_name(argv[0], pname, sizeof pname);

	f.name = pname;
	fp = lh_FUNCTION_retrieve(prog, &f);
	if (fp != NULL) {
		argv[0] = pname;
		ret = fp->func(argc, argv);
		goto end;
	}
	/*
	 * ok, now check that there are not arguments, if there are, run with
	 * them, shifting the ssleay off the front
	 */
	if (argc != 1) {
		argc--;
		argv++;
		ret = do_cmd(prog, argc, argv);
		if (ret < 0)
			ret = 0;
		goto end;
	}
	/* ok, lets enter the old 'OpenSSL>' mode */

	for (;;) {
		ret = 0;
		p = buf;
		n = sizeof buf;
		i = 0;
		for (;;) {
			p[0] = '\0';
			if (i++)
				prompt = ">";
			else
				prompt = "OpenSSL> ";
			fputs(prompt, stdout);
			fflush(stdout);
			if (!fgets(p, n, stdin))
				goto end;
			if (p[0] == '\0')
				goto end;
			i = strlen(p);
			if (i <= 1)
				break;
			if (p[i - 2] != '\\')
				break;
			i -= 2;
			p += i;
			n -= i;
		}
		if (!chopup_args(&arg, buf, &argc, &argv))
			break;

		ret = do_cmd(prog, argc, argv);
		if (ret < 0) {
			ret = 0;
			goto end;
		}
		if (ret != 0)
			BIO_printf(bio_err, "error in %s\n", argv[0]);
		(void) BIO_flush(bio_err);
	}
	BIO_printf(bio_err, "bad exit\n");
	ret = 1;

end:
	free(to_free);

	if (config != NULL) {
		NCONF_free(config);
		config = NULL;
	}
	if (prog != NULL)
		lh_FUNCTION_free(prog);
	free(arg.data);

	openssl_shutdown();

	if (bio_err != NULL) {
		BIO_free(bio_err);
		bio_err = NULL;
	}
	return (ret);
}

#define LIST_STANDARD_COMMANDS "list-standard-commands"
#define LIST_MESSAGE_DIGEST_COMMANDS "list-message-digest-commands"
#define LIST_MESSAGE_DIGEST_ALGORITHMS "list-message-digest-algorithms"
#define LIST_CIPHER_COMMANDS "list-cipher-commands"
#define LIST_CIPHER_ALGORITHMS "list-cipher-algorithms"
#define LIST_PUBLIC_KEY_ALGORITHMS "list-public-key-algorithms"


static int
do_cmd(LHASH_OF(FUNCTION) * prog, int argc, char *argv[])
{
	FUNCTION f, *fp;
	int i, ret = 1, tp, nl;

	if ((argc <= 0) || (argv[0] == NULL)) {
		ret = 0;
		goto end;
	}
	f.name = argv[0];
	fp = lh_FUNCTION_retrieve(prog, &f);
	if (fp == NULL) {
		if (EVP_get_digestbyname(argv[0])) {
			f.type = FUNC_TYPE_MD;
			f.func = dgst_main;
			fp = &f;
		} else if (EVP_get_cipherbyname(argv[0])) {
			f.type = FUNC_TYPE_CIPHER;
			f.func = enc_main;
			fp = &f;
		}
	}
	if (fp != NULL) {
		ret = fp->func(argc, argv);
	} else if ((strncmp(argv[0], "no-", 3)) == 0) {
		BIO *bio_stdout = BIO_new_fp(stdout, BIO_NOCLOSE);
		f.name = argv[0] + 3;
		ret = (lh_FUNCTION_retrieve(prog, &f) != NULL);
		if (!ret)
			BIO_printf(bio_stdout, "%s\n", argv[0]);
		else
			BIO_printf(bio_stdout, "%s\n", argv[0] + 3);
		BIO_free_all(bio_stdout);
		goto end;
	} else if ((strcmp(argv[0], "quit") == 0) ||
	    (strcmp(argv[0], "q") == 0) ||
	    (strcmp(argv[0], "exit") == 0) ||
	    (strcmp(argv[0], "bye") == 0)) {
		ret = -1;
		goto end;
	} else if ((strcmp(argv[0], LIST_STANDARD_COMMANDS) == 0) ||
	    (strcmp(argv[0], LIST_MESSAGE_DIGEST_COMMANDS) == 0) ||
	    (strcmp(argv[0], LIST_MESSAGE_DIGEST_ALGORITHMS) == 0) ||
	    (strcmp(argv[0], LIST_CIPHER_COMMANDS) == 0) ||
	    (strcmp(argv[0], LIST_CIPHER_ALGORITHMS) == 0) ||
	    (strcmp(argv[0], LIST_PUBLIC_KEY_ALGORITHMS) == 0)) {
		int list_type;
		BIO *bio_stdout;

		if (strcmp(argv[0], LIST_STANDARD_COMMANDS) == 0)
			list_type = FUNC_TYPE_GENERAL;
		else if (strcmp(argv[0], LIST_MESSAGE_DIGEST_COMMANDS) == 0)
			list_type = FUNC_TYPE_MD;
		else if (strcmp(argv[0], LIST_MESSAGE_DIGEST_ALGORITHMS) == 0)
			list_type = FUNC_TYPE_MD_ALG;
		else if (strcmp(argv[0], LIST_PUBLIC_KEY_ALGORITHMS) == 0)
			list_type = FUNC_TYPE_PKEY;
		else if (strcmp(argv[0], LIST_CIPHER_ALGORITHMS) == 0)
			list_type = FUNC_TYPE_CIPHER_ALG;
		else		/* strcmp(argv[0],LIST_CIPHER_COMMANDS) == 0 */
			list_type = FUNC_TYPE_CIPHER;
		bio_stdout = BIO_new_fp(stdout, BIO_NOCLOSE);

		if (list_type == FUNC_TYPE_PKEY)
			list_pkey(bio_stdout);
		if (list_type == FUNC_TYPE_MD_ALG)
			list_md(bio_stdout);
		if (list_type == FUNC_TYPE_CIPHER_ALG)
			list_cipher(bio_stdout);
		else {
			for (fp = functions; fp->name != NULL; fp++)
				if (fp->type == list_type)
					BIO_printf(bio_stdout, "%s\n",
					    fp->name);
		}
		BIO_free_all(bio_stdout);
		ret = 0;
		goto end;
	} else {
		BIO_printf(bio_err,
		    "openssl:Error: '%s' is an invalid command.\n",
		    argv[0]);
		BIO_printf(bio_err, "\nStandard commands");
		i = 0;
		tp = 0;
		for (fp = functions; fp->name != NULL; fp++) {
			nl = 0;
#ifdef OPENSSL_NO_CAMELLIA
			if (((i++) % 5) == 0)
#else
			if (((i++) % 4) == 0)
#endif
			{
				BIO_printf(bio_err, "\n");
				nl = 1;
			}
			if (fp->type != tp) {
				tp = fp->type;
				if (!nl)
					BIO_printf(bio_err, "\n");
				if (tp == FUNC_TYPE_MD) {
					i = 1;
					BIO_printf(bio_err,
					    "\nMessage Digest commands (see the `dgst' command for more details)\n");
				} else if (tp == FUNC_TYPE_CIPHER) {
					i = 1;
					BIO_printf(bio_err, "\nCipher commands (see the `enc' command for more details)\n");
				}
			}
#ifdef OPENSSL_NO_CAMELLIA
			BIO_printf(bio_err, "%-15s", fp->name);
#else
			BIO_printf(bio_err, "%-18s", fp->name);
#endif
		}
		BIO_printf(bio_err, "\n\n");
		ret = 0;
	}
end:
	return (ret);
}

static int
SortFnByName(const void *_f1, const void *_f2)
{
	const FUNCTION *f1 = _f1;
	const FUNCTION *f2 = _f2;

	if (f1->type != f2->type)
		return f1->type - f2->type;
	return strcmp(f1->name, f2->name);
}

static void
list_pkey(BIO * out)
{
	int i;

	for (i = 0; i < EVP_PKEY_asn1_get_count(); i++) {
		const EVP_PKEY_ASN1_METHOD *ameth;
		int pkey_id, pkey_base_id, pkey_flags;
		const char *pinfo, *pem_str;
		ameth = EVP_PKEY_asn1_get0(i);
		EVP_PKEY_asn1_get0_info(&pkey_id, &pkey_base_id, &pkey_flags,
		    &pinfo, &pem_str, ameth);
		if (pkey_flags & ASN1_PKEY_ALIAS) {
			BIO_printf(out, "Name: %s\n",
			    OBJ_nid2ln(pkey_id));
			BIO_printf(out, "\tType: Alias to %s\n",
			    OBJ_nid2ln(pkey_base_id));
		} else {
			BIO_printf(out, "Name: %s\n", pinfo);
			BIO_printf(out, "\tType: %s Algorithm\n",
			    pkey_flags & ASN1_PKEY_DYNAMIC ?
			    "External" : "Builtin");
			BIO_printf(out, "\tOID: %s\n", OBJ_nid2ln(pkey_id));
			if (pem_str == NULL)
				pem_str = "(none)";
			BIO_printf(out, "\tPEM string: %s\n", pem_str);
		}

	}
}

static void
list_cipher_fn(const EVP_CIPHER * c, const char *from, const char *to,
    void *arg)
{
	if (c)
		BIO_printf(arg, "%s\n", EVP_CIPHER_name(c));
	else {
		if (!from)
			from = "<undefined>";
		if (!to)
			to = "<undefined>";
		BIO_printf(arg, "%s => %s\n", from, to);
	}
}

static void
list_cipher(BIO * out)
{
	EVP_CIPHER_do_all_sorted(list_cipher_fn, out);
}

static void
list_md_fn(const EVP_MD * m, const char *from, const char *to, void *arg)
{
	if (m)
		BIO_printf(arg, "%s\n", EVP_MD_name(m));
	else {
		if (!from)
			from = "<undefined>";
		if (!to)
			to = "<undefined>";
		BIO_printf(arg, "%s => %s\n", from, to);
	}
}

static void
list_md(BIO * out)
{
	EVP_MD_do_all_sorted(list_md_fn, out);
}

static int
function_cmp(const FUNCTION * a, const FUNCTION * b)
{
	return strncmp(a->name, b->name, 8);
}

static IMPLEMENT_LHASH_COMP_FN(function, FUNCTION)

static unsigned long
function_hash(const FUNCTION * a)
{
	return lh_strhash(a->name);
}

static IMPLEMENT_LHASH_HASH_FN(function, FUNCTION)

static LHASH_OF(FUNCTION) *
prog_init(void)
{
	LHASH_OF(FUNCTION) * ret;
	FUNCTION *f;
	size_t i;

	/* Purely so it looks nice when the user hits ? */
	for (i = 0, f = functions; f->name != NULL; ++f, ++i)
		;
	qsort(functions, i, sizeof *functions, SortFnByName);

	if ((ret = lh_FUNCTION_new()) == NULL)
		return (NULL);

	for (f = functions; f->name != NULL; f++)
		(void) lh_FUNCTION_insert(ret, f);
	return (ret);
}
@


1.43
log
@missing newline
@
text
@d1 1
a1 1
/* $OpenBSD: openssl.c,v 1.42 2014/07/17 23:50:07 deraadt Exp $ */
@


1.42
log
@avoid errx(); Jonas Termansen
@
text
@d1 1
a1 1
/* $OpenBSD: openssl.c,v 1.41 2014/07/12 19:31:21 jsing Exp $ */
d260 1
a260 1
		fprintf(stderr, "openssl: failed to initialise bio_err");
@


1.41
log
@In openssl_startup(), call SSL_library_init() and SSL_load_error_strings().
This allows us to remove the ERR_load_crypto_strings() call, along with
the various SSL_load_error_strings() and OpenSSL_add_ssl_algorithms()
calls scattered around the place.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: openssl.c,v 1.40 2014/07/12 17:54:31 jsing Exp $ */
d259 4
a262 2
	if (bio_err == NULL)
		errx(1, "failed to initialise bio_err");
@


1.40
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: openssl.c,v 1.39 2014/07/10 09:15:51 tedu Exp $ */
a210 1
	ERR_load_crypto_strings();
d212 2
@


1.39
log
@forgot to decompress here too
@
text
@d1 1
a1 1
/* $OpenBSD: openssl.c,v 1.38 2014/06/12 15:49:27 deraadt Exp $ */
d295 6
a458 3

		if (!load_config(bio_err, NULL))
			goto end;
@


1.38
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a236 4

#ifndef OPENSSL_NO_COMP
	COMP_zlib_cleanup();
#endif
@


1.37
log
@Stop pulling signal.h into apps.h - just include it from openssl.c where
it is needed.
@
text
@d1 1
a1 1
/* apps/openssl.c */
@


1.36
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@d113 1
@


1.35
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d374 1
a374 2
	if (arg.data != NULL)
		free(arg.data);
@


1.34
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d116 1
d118 1
d120 1
d122 1
a122 1
#include <openssl/rand.h>
a123 2
#include <openssl/conf.h>
#include <openssl/x509.h>
d125 1
d127 2
d132 1
a134 1
#include <openssl/err.h>
@


1.33
log
@Kill memory debug calls that are now noops. While here, nuke an #if 0 and
a unnecessary NULL check before free.

ok miod@@
@
text
@d112 1
d256 1
d258 1
a258 2
		if ((bio_err = BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);
@


1.32
log
@Fold in the zlib_cleanup macro.
@
text
@d259 1
a259 19
	if (getenv("OPENSSL_DEBUG_MEMORY") != NULL) {	/* if not defined, use
							 * compiled-in library
							 * defaults */
		if (!(0 == strcmp(getenv("OPENSSL_DEBUG_MEMORY"), "off"))) {
			CRYPTO_malloc_debug_init();
			CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
		} else {
			/* OPENSSL_DEBUG_MEMORY=off */
			CRYPTO_set_mem_debug_functions(0, 0, 0, 0, 0);
		}
	}
	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);

#if 0
	if (getenv("OPENSSL_DEBUG_LOCKING") != NULL)
#endif
	{
		CRYPTO_set_locking_callback(lock_dbg_cb);
	}
d361 2
a362 2
	if (to_free)
		free(to_free);
a373 1
	CRYPTO_mem_leaks(bio_err);
@


1.31
log
@do_pipe_sig is now only used in openssl.c - just call signal() directly
from there instead and ditch the macro.
@
text
@d231 4
a234 1
	zlib_cleanup();
@


1.30
log
@The apps_{startup,shutdown} macro mess is now only used in openssl.c -
reduce the macro to two functions and just call them instead.

ok miod@@
@
text
@d202 1
a202 1
	do_pipe_sig();
@


1.29
log
@Remove more FIPS tenticles.

ok beck@@
@
text
@a114 2
#define OPENSSL_C		/* tells apps.h to use complete
				 * apps_startup() */
d131 3
d139 2
a140 2
static LHASH_OF(FUNCTION) * prog_init(void);
static int do_cmd(LHASH_OF(FUNCTION) * prog, int argc, char *argv[]);
d199 35
d276 1
a276 1
	apps_startup();
d387 1
a387 1
	apps_shutdown();
@


1.28
log
@We do not need ARGV, Argc and Argv - just use argc and argv like normal
people do.

ok beck@@ (although he wanted #Arrrrrrrgv instead).
@
text
@d239 1
a239 12
	if (getenv("OPENSSL_FIPS")) {
#ifdef OPENSSL_FIPS
		if (!FIPS_mode_set(1)) {
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr, BIO_NOCLOSE));
			exit(1);
		}
#else
		fprintf(stderr, "FIPS mode not supported.\n");
		exit(1);
#endif
	}
@


1.27
log
@More KNF.
@
text
@a197 2
#define ARGV Argv

d199 1
a199 1
main(int Argc, char *ARGV[])
d209 1
a209 2
	int argc;
	char **argv, *p;
d286 1
a286 1
	program_name(Argv[0], pname, sizeof pname);
d291 2
a292 2
		Argv[0] = pname;
		ret = fp->func(Argc, Argv);
d299 4
a302 4
	if (Argc != 1) {
		Argc--;
		Argv++;
		ret = do_cmd(prog, Argc, Argv);
@


1.26
log
@Check the return value of make_config_name() before attempting to use
the config filename.

ok beck@@
@
text
@a111 1

d148 1
a148 1
static void 
d200 1
a200 1
int 
d273 2
a274 2
		if (ERR_GET_REASON(ERR_peek_last_error())
		    == CONF_R_NO_SUCH_FILE) {
d352 1
d383 1
a383 1
static int 
d419 2
a420 2
		    (strcmp(argv[0], "q") == 0) ||
		    (strcmp(argv[0], "exit") == 0) ||
d425 4
a428 4
		    (strcmp(argv[0], LIST_MESSAGE_DIGEST_COMMANDS) == 0) ||
		    (strcmp(argv[0], LIST_MESSAGE_DIGEST_ALGORITHMS) == 0) ||
		    (strcmp(argv[0], LIST_CIPHER_COMMANDS) == 0) ||
		    (strcmp(argv[0], LIST_CIPHER_ALGORITHMS) == 0) ||
d466 2
a467 1
		BIO_printf(bio_err, "openssl:Error: '%s' is an invalid command.\n",
d509 1
a509 1
static int 
d520 1
a520 1
static void 
d524 1
d551 3
a553 3
static void 
list_cipher_fn(const EVP_CIPHER * c,
    const char *from, const char *to, void *arg)
d566 1
a566 1
static void 
d572 2
a573 3
static void 
list_md_fn(const EVP_MD * m,
    const char *from, const char *to, void *arg)
d586 1
a586 1
static void 
d592 1
a592 1
static int 
d597 5
a601 3
static 
IMPLEMENT_LHASH_COMP_FN(function, FUNCTION)
	static unsigned long function_hash(const FUNCTION * a)
d605 5
a609 3
static 
IMPLEMENT_LHASH_HASH_FN(function, FUNCTION)
	static LHASH_OF(FUNCTION) * prog_init(void)
d616 2
a617 1
	for (i = 0, f = functions; f->name != NULL; ++f, ++i);
@


1.25
log
@KaboomNF
@
text
@d261 1
a261 1
	if (p == NULL)
d263 5
@


1.24
log
@Unifdef OPENSSL_FIPS.

ok miod@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d116 2
a117 1
#define OPENSSL_C /* tells apps.h to use complete apps_startup() */
d139 14
a152 13
static LHASH_OF(FUNCTION) *prog_init(void );
static int do_cmd(LHASH_OF(FUNCTION) *prog,int argc,char *argv[]);
static void list_pkey(BIO *out);
static void list_cipher(BIO *out);
static void list_md(BIO *out);
char *default_config_file=NULL;

CONF *config=NULL;
BIO *bio_err=NULL;

static void lock_dbg_cb(int mode, int type, const char *file, int line)
	{
	static int modes[CRYPTO_NUM_LOCKS]; /* = {0, 0, ... } */
d155 3
a157 4
	
	rw = mode & (CRYPTO_READ|CRYPTO_WRITE);
	if (!((rw == CRYPTO_READ) || (rw == CRYPTO_WRITE)))
		{
d160 2
a161 4
		}

	if (type < 0 || type >= CRYPTO_NUM_LOCKS)
		{
d164 3
a166 6
		}

	if (mode & CRYPTO_LOCK)
		{
		if (modes[type])
			{
d168 4
a171 2
			/* must not happen in a single-threaded program
			 * (would deadlock) */
d173 1
a173 2
			}

d175 2
a176 5
		}
	else if (mode & CRYPTO_UNLOCK)
		{
		if (!modes[type])
			{
d179 2
a180 4
			}
		
		if (modes[type] != rw)
			{
d182 3
a184 4
				"CRYPTO_r_unlock on write lock" :
				"CRYPTO_w_unlock on read lock";
			}

d186 1
a186 3
		}
	else
		{
d189 1
a189 1
		}
d191 2
a192 3
 err:
	if (errstr)
		{
d195 1
a195 2
			errstr, mode, type, file, line);
		}
d197 1
d199 1
a199 1
# define ARGV Argv
d201 3
a203 2
int main(int Argc, char *ARGV[])
	{
d206 2
a207 2
	char pname[PROG_NAME_SIZE+1];
	FUNCTION f,*fp;
d210 2
a211 2
	char *to_free=NULL;
	int n,i,ret=0;
d213 2
a214 2
	char **argv,*p;
	LHASH_OF(FUNCTION) *prog=NULL;
d217 2
a218 2
	arg.data=NULL;
	arg.count=0;
d221 2
a222 2
		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);
d224 4
a227 4
	if (getenv("OPENSSL_DEBUG_MEMORY") != NULL) /* if not defined, use compiled-in library defaults */
		{
		if (!(0 == strcmp(getenv("OPENSSL_DEBUG_MEMORY"), "off")))
			{
d230 1
a230 3
			}
		else
			{
a232 1
			}
d234 1
d240 1
a240 1
		{
d242 2
a243 3
		}

	if(getenv("OPENSSL_FIPS")) {
d247 1
a247 1
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
d254 1
a254 2
		}

d258 1
a258 1
	p=getenv("OPENSSL_CONF");
d260 1
a260 1
		p=getenv("SSLEAY_CONF");
d262 1
a262 1
		p=to_free=make_config_name();
d264 1
a264 1
	default_config_file=p;
d266 3
a268 4
	config=NCONF_new(NULL);
	i=NCONF_load(config,p,&errline);
	if (i == 0)
		{
d270 1
a270 2
		    == CONF_R_NO_SUCH_FILE)
			{
d272 1
a272 1
				   "WARNING: can't open config file: %s\n",p);
d276 1
a276 3
			}
		else
			{
a279 1
			}
d281 2
a282 2

	prog=prog_init();
d285 1
a285 1
	program_name(Argv[0],pname,sizeof pname);
d287 5
a291 6
	f.name=pname;
	fp=lh_FUNCTION_retrieve(prog,&f);
	if (fp != NULL)
		{
		Argv[0]=pname;
		ret=fp->func(Argc,Argv);
d293 6
a298 6
		}

	/* ok, now check that there are not arguments, if there are,
	 * run with them, shifting the ssleay off the front */
	if (Argc != 1)
		{
d301 3
a303 2
		ret=do_cmd(prog,Argc,Argv);
		if (ret < 0) ret=0;
d305 2
a306 1
		}
d308 7
a314 11
	/* ok, lets enter the old 'OpenSSL>' mode */
	
	for (;;)
		{
		ret=0;
		p=buf;
		n=sizeof buf;
		i=0;
		for (;;)
			{
			p[0]='\0';
d316 4
a319 3
				prompt=">";
			else	prompt="OpenSSL> ";
			fputs(prompt,stdout);
d321 3
a323 1
			if (!fgets(p,n,stdin))
d325 15
a339 14
			if (p[0] == '\0') goto end;
			i=strlen(p);
			if (i <= 1) break;
			if (p[i-2] != '\\') break;
			i-=2;
			p+=i;
			n-=i;
			}
		if (!chopup_args(&arg,buf,&argc,&argv)) break;

		ret=do_cmd(prog,argc,argv);
		if (ret < 0)
			{
			ret=0;
d341 1
a341 1
			}
d343 5
a347 5
			BIO_printf(bio_err,"error in %s\n",argv[0]);
		(void)BIO_flush(bio_err);
		}
	BIO_printf(bio_err,"bad exit\n");
	ret=1;
d351 1
a351 2
	if (config != NULL)
		{
d353 6
a358 4
		config=NULL;
		}
	if (prog != NULL) lh_FUNCTION_free(prog);
	if (arg.data != NULL) free(arg.data);
d363 1
a363 2
	if (bio_err != NULL)
		{
d365 1
a365 3
		bio_err=NULL;
		}
	return(ret);
d367 2
d378 5
a382 4
static int do_cmd(LHASH_OF(FUNCTION) *prog, int argc, char *argv[])
	{
	FUNCTION f,*fp;
	int i,ret=1,tp,nl;
d384 8
a391 8
	if ((argc <= 0) || (argv[0] == NULL))
		{ ret=0; goto end; }
	f.name=argv[0];
	fp=lh_FUNCTION_retrieve(prog,&f);
	if (fp == NULL)
		{
		if (EVP_get_digestbyname(argv[0]))
			{
d395 1
a395 3
			}
		else if (EVP_get_cipherbyname(argv[0]))
			{
a398 1
			}
d400 7
a406 9
	if (fp != NULL)
		{
		ret=fp->func(argc,argv);
		}
	else if ((strncmp(argv[0],"no-",3)) == 0)
		{
		BIO *bio_stdout = BIO_new_fp(stdout,BIO_NOCLOSE);
		f.name=argv[0]+3;
		ret = (lh_FUNCTION_retrieve(prog,&f) != NULL);
d410 1
a410 1
			BIO_printf(bio_stdout, "%s\n", argv[0]+3);
d413 5
a417 7
		}
	else if ((strcmp(argv[0],"quit") == 0) ||
		(strcmp(argv[0],"q") == 0) ||
		(strcmp(argv[0],"exit") == 0) ||
		(strcmp(argv[0],"bye") == 0))
		{
		ret= -1;
d419 6
a424 8
		}
	else if ((strcmp(argv[0],LIST_STANDARD_COMMANDS) == 0) ||
		(strcmp(argv[0],LIST_MESSAGE_DIGEST_COMMANDS) == 0) ||
		(strcmp(argv[0],LIST_MESSAGE_DIGEST_ALGORITHMS) == 0) ||
		(strcmp(argv[0],LIST_CIPHER_COMMANDS) == 0) ||
		(strcmp(argv[0],LIST_CIPHER_ALGORITHMS) == 0) ||
		(strcmp(argv[0],LIST_PUBLIC_KEY_ALGORITHMS) == 0))
		{
d428 1
a428 1
		if (strcmp(argv[0],LIST_STANDARD_COMMANDS) == 0)
d430 1
a430 1
		else if (strcmp(argv[0],LIST_MESSAGE_DIGEST_COMMANDS) == 0)
d432 1
a432 1
		else if (strcmp(argv[0],LIST_MESSAGE_DIGEST_ALGORITHMS) == 0)
d434 1
a434 1
		else if (strcmp(argv[0],LIST_PUBLIC_KEY_ALGORITHMS) == 0)
d436 1
a436 1
		else if (strcmp(argv[0],LIST_CIPHER_ALGORITHMS) == 0)
d438 1
a438 1
		else /* strcmp(argv[0],LIST_CIPHER_COMMANDS) == 0 */
d440 1
a440 1
		bio_stdout = BIO_new_fp(stdout,BIO_NOCLOSE);
d446 1
a446 1
			list_pkey(bio_stdout);	
d448 1
a448 1
			list_md(bio_stdout);	
d450 3
a452 4
			list_cipher(bio_stdout);	
		else
			{
			for (fp=functions; fp->name != NULL; fp++)
d455 2
a456 2
								fp->name);
			}
d458 1
a458 1
		ret=0;
d460 3
a462 5
		}
	else
		{
		BIO_printf(bio_err,"openssl:Error: '%s' is an invalid command.\n",
			argv[0]);
d464 4
a467 5
		i=0;
		tp=0;
		for (fp=functions; fp->name != NULL; fp++)
			{
			nl=0;
d473 10
a482 11
				{
				BIO_printf(bio_err,"\n");
				nl=1;
				}
			if (fp->type != tp)
				{
				tp=fp->type;
				if (!nl) BIO_printf(bio_err,"\n");
				if (tp == FUNC_TYPE_MD)
					{
					i=1;
d484 4
a487 7
						"\nMessage Digest commands (see the `dgst' command for more details)\n");
					}
				else if (tp == FUNC_TYPE_CIPHER)
					{
					i=1;
					BIO_printf(bio_err,"\nCipher commands (see the `enc' command for more details)\n");
					}
d489 1
d491 1
a491 1
			BIO_printf(bio_err,"%-15s",fp->name);
d493 1
a493 1
			BIO_printf(bio_err,"%-18s",fp->name);
a494 3
			}
		BIO_printf(bio_err,"\n\n");
		ret=0;
d496 3
d500 2
a501 7
	return(ret);
	}

static int SortFnByName(const void *_f1,const void *_f2)
    {
    const FUNCTION *f1=_f1;
    const FUNCTION *f2=_f2;
d503 14
a516 7
    if(f1->type != f2->type)
	return f1->type-f2->type;
    return strcmp(f1->name,f2->name);
    }

static void list_pkey(BIO *out)
	{
d518 1
a518 2
	for (i = 0; i < EVP_PKEY_asn1_get_count(); i++)
		{
d524 4
a527 5
						&pinfo, &pem_str, ameth);
		if (pkey_flags & ASN1_PKEY_ALIAS)
			{
			BIO_printf(out, "Name: %s\n", 
					OBJ_nid2ln(pkey_id));
d529 2
a530 4
					OBJ_nid2ln(pkey_base_id));
			}
		else
			{
d532 3
a534 3
			BIO_printf(out, "\tType: %s Algorithm\n", 
				pkey_flags & ASN1_PKEY_DYNAMIC ?
					"External" : "Builtin");
a538 2
			}
					
d540 1
d542 1
d544 4
a547 3
static void list_cipher_fn(const EVP_CIPHER *c,
			const char *from, const char *to, void *arg)
	{
d550 1
a550 2
	else
		{
a555 1
		}
d557 1
d559 3
a561 2
static void list_cipher(BIO *out)
	{
d563 1
a563 1
	}
d565 4
a568 3
static void list_md_fn(const EVP_MD *m,
			const char *from, const char *to, void *arg)
	{
d571 1
a571 2
	else
		{
a576 1
		}
d578 1
d580 3
a582 2
static void list_md(BIO *out)
	{
d584 1
a584 1
	}
d586 9
a594 8
static int function_cmp(const FUNCTION *a, const FUNCTION *b)
	{
	return strncmp(a->name,b->name,8);
	}
static IMPLEMENT_LHASH_COMP_FN(function, FUNCTION)

static unsigned long function_hash(const FUNCTION *a)
	{
d596 6
a601 6
	}	
static IMPLEMENT_LHASH_HASH_FN(function, FUNCTION)

static LHASH_OF(FUNCTION) *prog_init(void)
	{
	LHASH_OF(FUNCTION) *ret;
d606 5
a610 11
	for(i=0,f=functions ; f->name != NULL ; ++f,++i)
	    ;
	qsort(functions,i,sizeof *functions,SortFnByName);

	if ((ret=lh_FUNCTION_new()) == NULL)
		return(NULL);

	for (f=functions; f->name != NULL; f++)
		(void)lh_FUNCTION_insert(ret,f);
	return(ret);
	}
d612 4
@


1.23
log
@Make MONOLITH the default and only option

ok deraadt
@
text
@a131 3
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif
@


1.22
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@a147 2
/* Make sure there is only one when MONOLITH is defined */
#ifdef MONOLITH
a149 2
#endif

@


1.21
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a128 1
#define USE_SOCKETS /* needed for the _O_BINARY defs in the MS world */
d269 1
a269 1
			EXIT(1);
d273 1
a273 1
		EXIT(1);
d393 1
a393 1
	OPENSSL_EXIT(ret);
@


1.20
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d377 1
a377 1
		OPENSSL_free(to_free);
d384 1
a384 1
	if (arg.data != NULL) OPENSSL_free(arg.data);
@


1.19
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@a218 3
#if defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64)
# define ARGV _Argv
#else
a219 1
#endif
a235 48
#if defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64)
	/* 2011-03-22 SMS.
	 * If we have 32-bit pointers everywhere, then we're safe, and
	 * we bypass this mess, as on non-VMS systems.  (See ARGV,
	 * above.)
	 * Problem 1: Compaq/HP C before V7.3 always used 32-bit
	 * pointers for argv[].
	 * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
	 * everywhere else, we always allocate and use a 64-bit
	 * duplicate of argv[].
	 * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
	 * to NULL-terminate a 64-bit argv[].  (As this was written, the
	 * compiler ECO was available only on IA64.)
	 * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
	 * 64-bit argv[argc] for NULL, and, if necessary, use a
	 * (properly) NULL-terminated (64-bit) duplicate of argv[].
	 * The same code is used in either case to duplicate argv[].
	 * Some of these decisions could be handled in preprocessing,
	 * but the code tends to get even uglier, and the penalty for
	 * deciding at compile- or run-time is tiny.
	 */
	char **Argv = NULL;
	int free_Argv = 0;

	if ((sizeof( _Argv) < 8)        /* 32-bit argv[]. */
# if !defined( VMS_TRUST_ARGV)
	 || (_Argv[ Argc] != NULL)      /* Untrusted argv[argc] not NULL. */
# endif
		)
		{
		int i;
		Argv = OPENSSL_malloc( (Argc+ 1)* sizeof( char *));
		if (Argv == NULL)
			{ ret = -1; goto end; }
		for(i = 0; i < Argc; i++)
			Argv[i] = _Argv[i];
		Argv[ Argc] = NULL;     /* Certain NULL termination. */
		free_Argv = 1;
		}
	else
		{
		/* Use the known-good 32-bit argv[] (which needs the
		 * type cast to satisfy the compiler), or the trusted or
		 * tested-good 64-bit argv[] as-is. */
		Argv = (char **)_Argv;
		}
#endif /* defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64) */

a393 7
#if defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64)
	/* Free any duplicate Argv[] storage. */
	if (free_Argv)
		{
		OPENSSL_free(Argv);
		}
#endif
a435 6
#ifdef OPENSSL_SYS_VMS
		{
		BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		bio_stdout = BIO_push(tmpbio, bio_stdout);
		}
#endif
a475 6
#ifdef OPENSSL_SYS_VMS
		{
		BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		bio_stdout = BIO_push(tmpbio, bio_stdout);
		}
#endif
@


1.18
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d231 2
a232 2
	MS_STATIC const char *prompt;
	MS_STATIC char buf[1024];
d699 1
a699 1
static int MS_CALLBACK function_cmp(const FUNCTION *a, const FUNCTION *b)
d705 1
a705 1
static unsigned long MS_CALLBACK function_hash(const FUNCTION *a)
@


1.17
log
@resolve conflicts
@
text
@d120 1
@


1.16
log
@openssl-1.0.0e: resolve conflicts
@
text
@d132 3
d314 13
@


1.15
log
@resolve conflicts, fix local changes
@
text
@d215 5
d221 1
a221 1
int main(int Argc, char *Argv[])
d235 49
a283 1
 
d429 7
@


1.14
log
@resolve conflicts
@
text
@d138 5
a142 6
/* static unsigned long MS_CALLBACK hash(FUNCTION *a); */
static unsigned long MS_CALLBACK hash(const void *a_void);
/* static int MS_CALLBACK cmp(FUNCTION *a,FUNCTION *b); */
static int MS_CALLBACK cmp(const void *a_void,const void *b_void);
static LHASH *prog_init(void );
static int do_cmd(LHASH *prog,int argc,char *argv[]);
a148 1
int in_FIPS_mode=0;
d228 1
a228 1
	LHASH *prog=NULL;
a233 13
	in_FIPS_mode = 0;

#ifdef OPENSSL_FIPS
	if(getenv("OPENSSL_FIPS")) {
		if (!FIPS_mode_set(1)) {
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
			EXIT(1);
		}
		in_FIPS_mode = 1;
		}
#endif

d275 15
a289 3
		NCONF_free(config);
		config = NULL;
		ERR_clear_error();
d298 1
a298 1
	fp=(FUNCTION *)lh_retrieve(prog,&f);
d333 2
a334 1
			fgets(p,n,stdin);
d365 1
a365 1
	if (prog != NULL) lh_free(prog);
d381 1
d383 3
d387 1
a387 1
static int do_cmd(LHASH *prog, int argc, char *argv[])
d395 16
a410 1
	fp=(FUNCTION *)lh_retrieve(prog,&f);
d425 1
a425 1
		ret = (lh_retrieve(prog,&f) != NULL);
d443 4
a446 1
		(strcmp(argv[0],LIST_CIPHER_COMMANDS) == 0))
d455 6
d470 17
a486 4
		
		for (fp=functions; fp->name != NULL; fp++)
			if (fp->type == list_type)
				BIO_printf(bio_stdout, "%s\n", fp->name);
d549 86
a634 1
static LHASH *prog_init(void)
d636 1
a636 1
	LHASH *ret;
d645 1
a645 1
	if ((ret=lh_new(hash, cmp)) == NULL)
d649 1
a649 1
		lh_insert(ret,f);
a652 12
/* static int MS_CALLBACK cmp(FUNCTION *a, FUNCTION *b) */
static int MS_CALLBACK cmp(const void *a_void, const void *b_void)
	{
	return(strncmp(((const FUNCTION *)a_void)->name,
			((const FUNCTION *)b_void)->name,8));
	}

/* static unsigned long MS_CALLBACK hash(FUNCTION *a) */
static unsigned long MS_CALLBACK hash(const void *a_void)
	{
	return(lh_strhash(((const FUNCTION *)a_void)->name));
	}
@


1.13
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d150 1
d236 13
d290 3
a292 15
		if (ERR_GET_REASON(ERR_peek_last_error())
		    == CONF_R_NO_SUCH_FILE)
			{
			BIO_printf(bio_err,
				   "WARNING: can't open config file: %s\n",p);
			ERR_clear_error();
			NCONF_free(config);
			config = NULL;
			}
		else
			{
			ERR_print_errors(bio_err);
			NCONF_free(config);
			exit(1);
			}
@


1.12
log
@resolve conflicts
@
text
@d276 15
a290 3
		NCONF_free(config);
		config = NULL;
		ERR_clear_error();
@


1.11
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
a131 1
#include <openssl/fips.h>
a149 1
int in_FIPS_mode=0;
d223 2
a224 1
	MS_STATIC char *prompt,buf[1024];
d231 1
a231 1

a234 12
	in_FIPS_mode = 0;

#ifdef OPENSSL_FIPS
	if(getenv("OPENSSL_FIPS")) {
		if (!FIPS_mode_set(1)) {
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
			EXIT(1);
		}
		in_FIPS_mode = 1;
		}
#endif
d448 1
d450 3
d473 1
d475 3
d500 1
a500 1
	int i;
d518 2
a519 2
	return(strncmp(((FUNCTION *)a_void)->name,
			((FUNCTION *)b_void)->name,8));
d525 1
a525 1
	return(lh_strhash(((FUNCTION *)a_void)->name));
@


1.10
log
@resolve conflicts
@
text
@d240 1
a240 8
#if defined(_WIN32)
		char filename[MAX_PATH] = "";
		GetModuleFileNameA( NULL, filename, MAX_PATH) ;
		p = filename;
#else
		p = Argv[0];
#endif
		if (!FIPS_mode_set(1,p)) {
a245 2
		if (getenv("OPENSSL_FIPS_MD5"))
			FIPS_allow_md5(1);
@


1.9
log
@Off-by-ones, from aaron@@
@
text
@d132 1
d151 1
d232 1
a232 1
 
d236 21
@


1.8
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d166 1
a166 1
	if (type < 0 || type > CRYPTO_NUM_LOCKS)
@


1.7
log
@more strcpy & sprintf murder; ho ok
@
text
@d125 1
d127 1
a143 1
CONF *config=NULL;
d148 1
d223 2
a224 1
	MS_STATIC char *prompt,buf[1024],config_name[256];
d234 4
a261 4
	if (bio_err == NULL)
		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);

d267 1
a267 8
		{
		strlcpy(config_name,X509_get_default_cert_area(),sizeof config_name);
#ifndef OPENSSL_SYS_VMS
		strlcat(config_name,"/",sizeof config_name);
#endif
		strlcat(config_name,OPENSSL_CONF,sizeof config_name);
		p=config_name;
		}
d283 1
a283 1
	program_name(Argv[0],pname,PROG_NAME_SIZE);
d311 1
a311 1
		n=1024;
d345 2
d363 1
a363 1
	EXIT(ret);
@


1.6
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d265 1
a265 1
		strcpy(config_name,X509_get_default_cert_area());
d267 1
a267 1
		strcat(config_name,"/");
d269 1
a269 1
		strcat(config_name,OPENSSL_CONF);
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d117 1
a126 1
#include "apps.h"
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d58 54
d124 1
d131 9
a139 2
static unsigned long MS_CALLBACK hash(FUNCTION *a);
static int MS_CALLBACK cmp(FUNCTION *a,FUNCTION *b);
d142 1
a142 1
LHASH *config=NULL;
d150 65
d218 2
a219 2
#define PROG_NAME_SIZE	16
	char pname[PROG_NAME_SIZE];
d231 13
a243 2
	if (getenv("OPENSSL_DEBUG_MEMORY") != NULL)
		CRYPTO_malloc_debug_init();
d246 7
a258 2
	ERR_load_crypto_strings();

d266 1
a266 1
#ifndef VMS
d275 8
a282 2
	config=CONF_load(config,p,&errline);
	if (config == NULL) ERR_clear_error();
d351 1
a351 1
		CONF_free(config);
a355 1
	ERR_remove_state(0);
d357 2
a358 3
	EVP_cleanup();
	ERR_free_strings();
	
d388 1
a388 1
#ifdef VMS
d425 1
a425 1
#ifdef VMS
d500 2
a501 1
	if ((ret=lh_new(hash,cmp)) == NULL) return(NULL);
d508 2
a509 1
static int MS_CALLBACK cmp(FUNCTION *a, FUNCTION *b)
d511 2
a512 1
	return(strncmp(a->name,b->name,8));
d515 2
a516 1
static unsigned long MS_CALLBACK hash(FUNCTION *a)
d518 1
a518 1
	return(lh_strhash(a->name));
@


1.3
log
@OpenSSL 0.9.5a merge
@
text
@d104 2
d206 1
a206 1
	if (arg.data != NULL) Free(arg.data);
d241 6
d253 1
a253 1
		BIO_free(bio_stdout);
d278 6
d288 1
a288 1
		BIO_free(bio_stdout);
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@a58 4
#ifndef DEBUG
#undef DEBUG
#endif

d62 1
a70 1
#define OPENSSL_C /* tells apps.h to use complete apps_startup() */
a75 6
/*
#ifdef WINDOWS
#include "bss_file.c"
#endif
*/

a82 9
#ifdef DEBUG
static void sig_stop(int i)
	{
	char *a=NULL;

	*a='\0';
	}
#endif

a103 9
#if defined(DEBUG) && !defined(WINDOWS) && !defined(MSDOS)
#ifdef SIGBUS
	signal(SIGBUS,sig_stop);
#endif
#ifdef SIGSEGV
	signal(SIGSEGV,sig_stop);
#endif
#endif

d209 1
a209 7

#ifdef LEVITTE_DEBUG
	CRYPTO_push_info("Just to make sure I get a memory leak I can see :-)");
	(void)Malloc(1024);
	CRYPTO_pop_info();
#endif

d235 12
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@a72 1
#define SSLEAY	/* turn off a few special case MONOLITH macros */
d74 1
a74 1
#define SSLEAY_SRC
d76 1
a122 3
	/* SSLeay_add_ssl_algorithms(); is called in apps_startup() */
	apps_startup();

d132 4
a139 2
	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);

d167 1
a167 1
	fp=(FUNCTION *)lh_retrieve(prog,(char *)&f);
d238 6
d265 1
a265 1
	fp=(FUNCTION *)lh_retrieve(prog,(char *)&f);
d364 1
a364 1
		lh_insert(ret,(char *)f);
a376 2

#undef SSLEAY
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d59 3
a65 1
#define OPENSSL_C /* tells apps.h to use complete apps_startup() */
d73 1
a73 1
#include <openssl/engine.h>
d75 1
a76 1
#include "progs.h"
d80 8
a87 9
/* The LHASH callbacks ("hash" & "cmp") have been replaced by functions with the
 * base prototypes (we cast each variable inside the function to the required
 * type of "FUNCTION*"). This removes the necessity for macro-generated wrapper
 * functions. */

/* static unsigned long MS_CALLBACK hash(FUNCTION *a); */
static unsigned long MS_CALLBACK hash(const void *a_void);
/* static int MS_CALLBACK cmp(FUNCTION *a,FUNCTION *b); */
static int MS_CALLBACK cmp(const void *a_void,const void *b_void);
d90 1
a90 1
CONF *config=NULL;
d93 9
a106 65

static void lock_dbg_cb(int mode, int type, const char *file, int line)
	{
	static int modes[CRYPTO_NUM_LOCKS]; /* = {0, 0, ... } */
	const char *errstr = NULL;
	int rw;
	
	rw = mode & (CRYPTO_READ|CRYPTO_WRITE);
	if (!((rw == CRYPTO_READ) || (rw == CRYPTO_WRITE)))
		{
		errstr = "invalid mode";
		goto err;
		}

	if (type < 0 || type > CRYPTO_NUM_LOCKS)
		{
		errstr = "type out of bounds";
		goto err;
		}

	if (mode & CRYPTO_LOCK)
		{
		if (modes[type])
			{
			errstr = "already locked";
			/* must not happen in a single-threaded program
			 * (would deadlock) */
			goto err;
			}

		modes[type] = rw;
		}
	else if (mode & CRYPTO_UNLOCK)
		{
		if (!modes[type])
			{
			errstr = "not locked";
			goto err;
			}
		
		if (modes[type] != rw)
			{
			errstr = (rw == CRYPTO_READ) ?
				"CRYPTO_r_unlock on write lock" :
				"CRYPTO_w_unlock on read lock";
			}

		modes[type] = 0;
		}
	else
		{
		errstr = "invalid mode";
		goto err;
		}

 err:
	if (errstr)
		{
		/* we cannot use bio_err here */
		fprintf(stderr, "openssl (lock_dbg_cb): %s (mode=%d, type=%d) at %s:%d\n",
			errstr, mode, type, file, line);
		}
	}


d110 2
a111 2
#define PROG_NAME_SIZE	39
	char pname[PROG_NAME_SIZE+1];
d123 2
a124 14
	if (getenv("OPENSSL_DEBUG_MEMORY") != NULL) /* if not defined, use compiled-in library defaults */
		{
		if (!(0 == strcmp(getenv("OPENSSL_DEBUG_MEMORY"), "off")))
			{
			CRYPTO_malloc_debug_init();
			CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
			}
		else
			{
			/* OPENSSL_DEBUG_MEMORY=off */
			CRYPTO_set_mem_debug_functions(0, 0, 0, 0, 0);
			}
		}
	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
d126 7
a132 2
#if 0
	if (getenv("OPENSSL_DEBUG_LOCKING") != NULL)
a133 5
		{
		CRYPTO_set_locking_callback(lock_dbg_cb);
		}

	apps_startup();
d139 4
d150 1
a150 1
#ifndef OPENSSL_SYS_VMS
d159 2
a160 8
	config=NCONF_new(NULL);
	i=NCONF_load(config,p,&errline);
	if (i == 0)
		{
		NCONF_free(config);
		config = NULL;
		ERR_clear_error();
		}
d168 1
a168 1
	fp=(FUNCTION *)lh_retrieve(prog,&f);
d229 1
a229 1
		NCONF_free(config);
d233 2
a234 1
	if (arg.data != NULL) OPENSSL_free(arg.data);
d236 2
a237 1
	apps_shutdown();
d260 1
a260 1
	fp=(FUNCTION *)lh_retrieve(prog,&f);
a264 18
	else if ((strncmp(argv[0],"no-",3)) == 0)
		{
		BIO *bio_stdout = BIO_new_fp(stdout,BIO_NOCLOSE);
#ifdef OPENSSL_SYS_VMS
		{
		BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		bio_stdout = BIO_push(tmpbio, bio_stdout);
		}
#endif
		f.name=argv[0]+3;
		ret = (lh_retrieve(prog,&f) != NULL);
		if (!ret)
			BIO_printf(bio_stdout, "%s\n", argv[0]);
		else
			BIO_printf(bio_stdout, "%s\n", argv[0]+3);
		BIO_free_all(bio_stdout);
		goto end;
		}
a286 6
#ifdef OPENSSL_SYS_VMS
		{
		BIO *tmpbio = BIO_new(BIO_f_linebuffer());
		bio_stdout = BIO_push(tmpbio, bio_stdout);
		}
#endif
d291 1
a291 1
		BIO_free_all(bio_stdout);
d356 1
a356 2
	if ((ret=lh_new(hash, cmp)) == NULL)
		return(NULL);
d359 1
a359 1
		lh_insert(ret,f);
d363 1
a363 2
/* static int MS_CALLBACK cmp(FUNCTION *a, FUNCTION *b) */
static int MS_CALLBACK cmp(const void *a_void, const void *b_void)
d365 1
a365 2
	return(strncmp(((FUNCTION *)a_void)->name,
			((FUNCTION *)b_void)->name,8));
d368 1
a368 2
/* static unsigned long MS_CALLBACK hash(FUNCTION *a) */
static unsigned long MS_CALLBACK hash(const void *a_void)
d370 1
a370 1
	return(lh_strhash(((FUNCTION *)a_void)->name));
d372 2
@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@a116 1
#include "apps.h"
d126 1
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@a124 1
#ifndef OPENSSL_NO_ENGINE
a125 1
#endif
d142 1
a146 1
CONF *config=NULL;
d221 1
a221 2
	MS_STATIC char *prompt,buf[1024];
	char *to_free=NULL;
a230 4
	if (bio_err == NULL)
		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
			BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);

d255 4
d264 8
a271 1
		p=to_free=make_config_name();
d287 1
a287 1
	program_name(Argv[0],pname,sizeof pname);
d315 1
a315 1
		n=sizeof buf;
a348 2
	if (to_free)
		OPENSSL_free(to_free);
d365 1
a365 1
	OPENSSL_EXIT(ret);
@


1.1.1.4
log
@import 0.9.7c
@
text
@d166 1
a166 1
	if (type < 0 || type >= CRYPTO_NUM_LOCKS)
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a131 1
#include <openssl/fips.h>
a149 1
int in_FIPS_mode=0;
d230 1
a230 1

a233 21
	in_FIPS_mode = 0;

#ifdef OPENSSL_FIPS
	if(getenv("OPENSSL_FIPS")) {
#if defined(_WIN32)
		char filename[MAX_PATH] = "";
		GetModuleFileNameA( NULL, filename, MAX_PATH) ;
		p = filename;
#else
		p = Argv[0];
#endif
		if (!FIPS_mode_set(1,p)) {
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
			EXIT(1);
		}
		in_FIPS_mode = 1;
		if (getenv("OPENSSL_FIPS_MD5"))
			FIPS_allow_md5(1);
		}
#endif
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@d240 8
a247 1
		if (!FIPS_mode_set(1)) {
d253 2
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
d132 1
d151 1
d225 1
a225 2
	MS_STATIC const char *prompt;
	MS_STATIC char buf[1024];
d232 1
a232 1
 
d236 12
a460 1
#ifdef OPENSSL_NO_CAMELLIA
a461 3
#else
			if (((i++) % 4) == 0)
#endif
a481 1
#ifdef OPENSSL_NO_CAMELLIA
a482 3
#else
			BIO_printf(bio_err,"%-18s",fp->name);
#endif
d505 1
a505 1
	size_t i;
d523 2
a524 2
	return(strncmp(((const FUNCTION *)a_void)->name,
			((const FUNCTION *)b_void)->name,8));
d530 1
a530 1
	return(lh_strhash(((const FUNCTION *)a_void)->name));
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a149 1
int in_FIPS_mode=0;
a233 13

	in_FIPS_mode = 0;

#ifdef OPENSSL_FIPS
	if(getenv("OPENSSL_FIPS")) {
		if (!FIPS_mode_set(1)) {
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
			EXIT(1);
		}
		in_FIPS_mode = 1;
		}
#endif
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d138 6
a143 5
static LHASH_OF(FUNCTION) *prog_init(void );
static int do_cmd(LHASH_OF(FUNCTION) *prog,int argc,char *argv[]);
static void list_pkey(BIO *out);
static void list_cipher(BIO *out);
static void list_md(BIO *out);
d150 1
d230 1
a230 1
	LHASH_OF(FUNCTION) *prog=NULL;
d236 13
d290 3
a292 15
		if (ERR_GET_REASON(ERR_peek_last_error())
		    == CONF_R_NO_SUCH_FILE)
			{
			BIO_printf(bio_err,
				   "WARNING: can't open config file: %s\n",p);
			ERR_clear_error();
			NCONF_free(config);
			config = NULL;
			}
		else
			{
			ERR_print_errors(bio_err);
			NCONF_free(config);
			exit(1);
			}
d301 1
a301 1
	fp=lh_FUNCTION_retrieve(prog,&f);
d336 1
a336 2
			if (!fgets(p,n,stdin))
				goto end;
d367 1
a367 1
	if (prog != NULL) lh_FUNCTION_free(prog);
a382 1
#define LIST_MESSAGE_DIGEST_ALGORITHMS "list-message-digest-algorithms"
a383 3
#define LIST_CIPHER_ALGORITHMS "list-cipher-algorithms"
#define LIST_PUBLIC_KEY_ALGORITHMS "list-public-key-algorithms"

d385 1
a385 1
static int do_cmd(LHASH_OF(FUNCTION) *prog, int argc, char *argv[])
d393 1
a393 16
	fp=lh_FUNCTION_retrieve(prog,&f);
	if (fp == NULL)
		{
		if (EVP_get_digestbyname(argv[0]))
			{
			f.type = FUNC_TYPE_MD;
			f.func = dgst_main;
			fp = &f;
			}
		else if (EVP_get_cipherbyname(argv[0]))
			{
			f.type = FUNC_TYPE_CIPHER;
			f.func = enc_main;
			fp = &f;
			}
		}
d408 1
a408 1
		ret = (lh_FUNCTION_retrieve(prog,&f) != NULL);
d426 1
a426 4
		(strcmp(argv[0],LIST_MESSAGE_DIGEST_ALGORITHMS) == 0) ||
		(strcmp(argv[0],LIST_CIPHER_COMMANDS) == 0) ||
		(strcmp(argv[0],LIST_CIPHER_ALGORITHMS) == 0) ||
		(strcmp(argv[0],LIST_PUBLIC_KEY_ALGORITHMS) == 0))
a434 6
		else if (strcmp(argv[0],LIST_MESSAGE_DIGEST_ALGORITHMS) == 0)
			list_type = FUNC_TYPE_MD_ALG;
		else if (strcmp(argv[0],LIST_PUBLIC_KEY_ALGORITHMS) == 0)
			list_type = FUNC_TYPE_PKEY;
		else if (strcmp(argv[0],LIST_CIPHER_ALGORITHMS) == 0)
			list_type = FUNC_TYPE_CIPHER_ALG;
d444 4
a447 17

		if (!load_config(bio_err, NULL))
			goto end;

		if (list_type == FUNC_TYPE_PKEY)
			list_pkey(bio_stdout);	
		if (list_type == FUNC_TYPE_MD_ALG)
			list_md(bio_stdout);	
		if (list_type == FUNC_TYPE_CIPHER_ALG)
			list_cipher(bio_stdout);	
		else
			{
			for (fp=functions; fp->name != NULL; fp++)
				if (fp->type == list_type)
					BIO_printf(bio_stdout, "%s\n",
								fp->name);
			}
d510 1
a510 86
static void list_pkey(BIO *out)
	{
	int i;
	for (i = 0; i < EVP_PKEY_asn1_get_count(); i++)
		{
		const EVP_PKEY_ASN1_METHOD *ameth;
		int pkey_id, pkey_base_id, pkey_flags;
		const char *pinfo, *pem_str;
		ameth = EVP_PKEY_asn1_get0(i);
		EVP_PKEY_asn1_get0_info(&pkey_id, &pkey_base_id, &pkey_flags,
						&pinfo, &pem_str, ameth);
		if (pkey_flags & ASN1_PKEY_ALIAS)
			{
			BIO_printf(out, "Name: %s\n", 
					OBJ_nid2ln(pkey_id));
			BIO_printf(out, "\tType: Alias to %s\n",
					OBJ_nid2ln(pkey_base_id));
			}
		else
			{
			BIO_printf(out, "Name: %s\n", pinfo);
			BIO_printf(out, "\tType: %s Algorithm\n", 
				pkey_flags & ASN1_PKEY_DYNAMIC ?
					"External" : "Builtin");
			BIO_printf(out, "\tOID: %s\n", OBJ_nid2ln(pkey_id));
			if (pem_str == NULL)
				pem_str = "(none)";
			BIO_printf(out, "\tPEM string: %s\n", pem_str);
			}
					
		}
	}

static void list_cipher_fn(const EVP_CIPHER *c,
			const char *from, const char *to, void *arg)
	{
	if (c)
		BIO_printf(arg, "%s\n", EVP_CIPHER_name(c));
	else
		{
		if (!from)
			from = "<undefined>";
		if (!to)
			to = "<undefined>";
		BIO_printf(arg, "%s => %s\n", from, to);
		}
	}

static void list_cipher(BIO *out)
	{
	EVP_CIPHER_do_all_sorted(list_cipher_fn, out);
	}

static void list_md_fn(const EVP_MD *m,
			const char *from, const char *to, void *arg)
	{
	if (m)
		BIO_printf(arg, "%s\n", EVP_MD_name(m));
	else
		{
		if (!from)
			from = "<undefined>";
		if (!to)
			to = "<undefined>";
		BIO_printf(arg, "%s => %s\n", from, to);
		}
	}

static void list_md(BIO *out)
	{
	EVP_MD_do_all_sorted(list_md_fn, out);
	}

static int MS_CALLBACK function_cmp(const FUNCTION *a, const FUNCTION *b)
	{
	return strncmp(a->name,b->name,8);
	}
static IMPLEMENT_LHASH_COMP_FN(function, FUNCTION)

static unsigned long MS_CALLBACK function_hash(const FUNCTION *a)
	{
	return lh_strhash(a->name);
	}	
static IMPLEMENT_LHASH_HASH_FN(function, FUNCTION)

static LHASH_OF(FUNCTION) *prog_init(void)
d512 1
a512 1
	LHASH_OF(FUNCTION) *ret;
d521 1
a521 1
	if ((ret=lh_FUNCTION_new()) == NULL)
d525 1
a525 1
		(void)lh_FUNCTION_insert(ret,f);
d529 12
@


1.1.1.10
log
@import OpenSSL 1.0.0e
@
text
@a214 5
#if defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64)
# define ARGV _Argv
#else
# define ARGV Argv
#endif
d216 1
a216 1
int main(int Argc, char *ARGV[])
d230 1
a230 49

#if defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64)
	/* 2011-03-22 SMS.
	 * If we have 32-bit pointers everywhere, then we're safe, and
	 * we bypass this mess, as on non-VMS systems.  (See ARGV,
	 * above.)
	 * Problem 1: Compaq/HP C before V7.3 always used 32-bit
	 * pointers for argv[].
	 * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
	 * everywhere else, we always allocate and use a 64-bit
	 * duplicate of argv[].
	 * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
	 * to NULL-terminate a 64-bit argv[].  (As this was written, the
	 * compiler ECO was available only on IA64.)
	 * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
	 * 64-bit argv[argc] for NULL, and, if necessary, use a
	 * (properly) NULL-terminated (64-bit) duplicate of argv[].
	 * The same code is used in either case to duplicate argv[].
	 * Some of these decisions could be handled in preprocessing,
	 * but the code tends to get even uglier, and the penalty for
	 * deciding at compile- or run-time is tiny.
	 */
	char **Argv = NULL;
	int free_Argv = 0;

	if ((sizeof( _Argv) < 8)        /* 32-bit argv[]. */
# if !defined( VMS_TRUST_ARGV)
	 || (_Argv[ Argc] != NULL)      /* Untrusted argv[argc] not NULL. */
# endif
		)
		{
		int i;
		Argv = OPENSSL_malloc( (Argc+ 1)* sizeof( char *));
		if (Argv == NULL)
			{ ret = -1; goto end; }
		for(i = 0; i < Argc; i++)
			Argv[i] = _Argv[i];
		Argv[ Argc] = NULL;     /* Certain NULL termination. */
		free_Argv = 1;
		}
	else
		{
		/* Use the known-good 32-bit argv[] (which needs the
		 * type cast to satisfy the compiler), or the trusted or
		 * tested-good 64-bit argv[] as-is. */
		Argv = (char **)_Argv;
		}
#endif /* defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64) */

a375 7
#if defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64)
	/* Free any duplicate Argv[] storage. */
	if (free_Argv)
		{
		OPENSSL_free(Argv);
		}
#endif
@


1.1.1.11
log
@import OpenSSL-1.0.1c
@
text
@a131 3
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif
a310 13
		}

	if(getenv("OPENSSL_FIPS")) {
#ifdef OPENSSL_FIPS
		if (!FIPS_mode_set(1)) {
			ERR_load_crypto_strings();
			ERR_print_errors(BIO_new_fp(stderr,BIO_NOCLOSE));
			EXIT(1);
		}
#else
		fprintf(stderr, "FIPS mode not supported.\n");
		EXIT(1);
#endif
@


1.1.1.12
log
@Import OpenSSL 1.0.1g
@
text
@a119 1
#include <openssl/rand.h>
@


