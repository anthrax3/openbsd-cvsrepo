head	1.70;
access;
symbols
	OPENBSD_5_6:1.69.0.4
	OPENBSD_5_6_BASE:1.69
	butholakala:1.20
	openssl_1_0_1_g:1.1.1.15
	OPENBSD_5_5:1.19.0.8
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	openssl_1_0_1_c:1.1.1.14
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	openssl_1_0_0_f:1.1.1.13
	openssl_1_0_0_e:1.1.1.13
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	openssh_1_0_0_a:1.1.1.12
	OPENBSD_4_8:1.16.0.6
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	openssl_0_9_8_k:1.1.1.11
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	openssl_0_9_8_j:1.1.1.10
	openssl_0_9_8_h:1.1.1.9
	pre_openssl_0_9_8h:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	openssl_0_9_7j:1.1.1.8
	openssl:1.1.1
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENSSL_0_9_7G:1.1.1.7
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENSSL_0_9_7D:1.1.1.6
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.5
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENSSL_0_9_7B:1.1.1.5
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.4
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.70
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.69;
commitid	7A7DObXgY4Fni8xJ;

1.69
date	2014.07.25.06.05.31;	author doug;	state Exp;
branches;
next	1.68;
commitid	DnBLYuKKjvrWeH3R;

1.68
date	2014.07.19.03.40.26;	author lteo;	state Exp;
branches;
next	1.67;
commitid	YEEl0gkItsP6eC2A;

1.67
date	2014.07.14.00.35.10;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	EB0l28piqIRSpBUh;

1.66
date	2014.07.13.16.03.09;	author beck;	state Exp;
branches;
next	1.65;
commitid	6xdvCwSqBadTW6X3;

1.65
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.64;
commitid	0NuggCO2WJOZj8Kh;

1.64
date	2014.07.09.21.13.34;	author tedu;	state Exp;
branches;
next	1.63;
commitid	QXQcqvx7I5AtKqYK;

1.63
date	2014.07.09.21.02.35;	author tedu;	state Exp;
branches;
next	1.62;
commitid	ivoCf1icUxmbGXSc;

1.62
date	2014.07.09.20.37.20;	author tedu;	state Exp;
branches;
next	1.61;
commitid	3W5dGj2EMu3bJhdc;

1.61
date	2014.07.09.09.06.58;	author bcook;	state Exp;
branches;
next	1.60;
commitid	wo9E4ACdFuC7DqQu;

1.60
date	2014.06.28.04.39.41;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	gGtvlhTlvaxlmOBo;

1.59
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	mJUVYpkFBZ0Zv2bG;

1.58
date	2014.06.07.22.41.15;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	sPRa1x9toEcAndOk;

1.57
date	2014.06.07.14.41.56;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	2nvnQBrv22dLtvTt;

1.56
date	2014.05.30.04.59.14;	author jsing;	state Exp;
branches;
next	1.55;

1.55
date	2014.05.29.21.28.49;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2014.05.29.21.19.30;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2014.05.23.15.55.08;	author jsing;	state Exp;
branches;
next	1.51;

1.51
date	2014.05.19.12.34.53;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2014.05.18.16.26.02;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.47;

1.47
date	2014.05.07.21.32.19;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2014.05.05.16.06.55;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2014.05.03.16.03.54;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2014.05.02.17.06.46;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2014.04.25.13.56.39;	author jsing;	state Exp;
branches;
next	1.42;

1.42
date	2014.04.22.14.54.13;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.22.12.43.34;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.21.18.35.01;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.19.16.31.51;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.19.16.18.22;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.19.15.27.10;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.19.12.22.37;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.19.11.46.39;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.19.00.41.37;	author beck;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.18.15.38.16;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.18.13.41.20;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.17.21.45.45;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.16.19.36.19;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.16.19.33.40;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.16.16.34.09;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.16.15.57.42;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.16.02.50.09;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.15.16.22.30;	author beck;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.13.20.37.11;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.13.15.25.27;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.01.22.58.50;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.09.12.15.18;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.27.05.06.53;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.29.05.39.15;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.25.16.35.12;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.10.16.31.53;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.56.53;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.05;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.13;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.10;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.10;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.28;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.34.08;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.42.31;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.34.16;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.41.27;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.36.58;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.06.27.05.05.29;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.01.09.12.13.48;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.04.06.06.30.00;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.10.01.22.54.00;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2011.11.03.02.32.06;	author djm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2012.10.13.21.23.31;	author djm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: apps.c,v 1.69 2014/07/25 06:05:31 doug Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/times.h>

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>

#include "apps.h"

#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/pkcs12.h>
#include <openssl/safestack.h>
#include <openssl/ui.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include <openssl/rsa.h>

typedef struct {
	const char *name;
	unsigned long flag;
	unsigned long mask;
} NAME_EX_TBL;

static UI_METHOD *ui_method = NULL;

static int set_table_opts(unsigned long *flags, const char *arg,
    const NAME_EX_TBL *in_tbl);
static int set_multi_opts(unsigned long *flags, const char *arg,
    const NAME_EX_TBL *in_tbl);

#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)
/* Looks like this stuff is worth moving into separate function */
static EVP_PKEY *load_netscape_key(BIO *err, BIO *key, const char *file,
    const char *key_descrip, int format);
#endif

int
str2fmt(char *s)
{
	if (s == NULL)
		return FORMAT_UNDEF;
	if ((*s == 'D') || (*s == 'd'))
		return (FORMAT_ASN1);
	else if ((*s == 'T') || (*s == 't'))
		return (FORMAT_TEXT);
	else if ((*s == 'N') || (*s == 'n'))
		return (FORMAT_NETSCAPE);
	else if ((*s == 'S') || (*s == 's'))
		return (FORMAT_SMIME);
	else if ((*s == 'M') || (*s == 'm'))
		return (FORMAT_MSBLOB);
	else if ((*s == '1') ||
	    (strcmp(s, "PKCS12") == 0) || (strcmp(s, "pkcs12") == 0) ||
	    (strcmp(s, "P12") == 0) || (strcmp(s, "p12") == 0))
		return (FORMAT_PKCS12);
	else if ((*s == 'E') || (*s == 'e'))
		return (FORMAT_ENGINE);
	else if ((*s == 'P') || (*s == 'p')) {
		if (s[1] == 'V' || s[1] == 'v')
			return FORMAT_PVK;
		else
			return (FORMAT_PEM);
	} else
		return (FORMAT_UNDEF);
}

void
program_name(char *in, char *out, int size)
{
	char *p;

	p = strrchr(in, '/');
	if (p != NULL)
		p++;
	else
		p = in;
	strlcpy(out, p, size);
}

int
chopup_args(ARGS *arg, char *buf, int *argc, char **argv[])
{
	int num, i;
	char *p;

	*argc = 0;
	*argv = NULL;

	i = 0;
	if (arg->count == 0) {
		arg->count = 20;
		arg->data = reallocarray(NULL, arg->count, sizeof(char *));
	}
	for (i = 0; i < arg->count; i++)
		arg->data[i] = NULL;

	num = 0;
	p = buf;
	for (;;) {
		/* first scan over white space */
		if (!*p)
			break;
		while (*p && ((*p == ' ') || (*p == '\t') || (*p == '\n')))
			p++;
		if (!*p)
			break;

		/* The start of something good :-) */
		if (num >= arg->count) {
			char **tmp_p;
			int tlen = arg->count + 20;
			tmp_p = reallocarray(arg->data, tlen, sizeof(char *));
			if (tmp_p == NULL)
				return 0;
			arg->data = tmp_p;
			arg->count = tlen;
			/* initialize newly allocated data */
			for (i = num; i < arg->count; i++)
				arg->data[i] = NULL;
		}
		arg->data[num++] = p;

		/* now look for the end of this */
		if ((*p == '\'') || (*p == '\"')) {	/* scan for closing
							 * quote */
			i = *(p++);
			arg->data[num - 1]++;	/* jump over quote */
			while (*p && (*p != i))
				p++;
			*p = '\0';
		} else {
			while (*p && ((*p != ' ') &&
			    (*p != '\t') && (*p != '\n')))
				p++;

			if (*p == '\0')
				p--;
			else
				*p = '\0';
		}
		p++;
	}
	*argc = num;
	*argv = arg->data;
	return (1);
}

int
dump_cert_text(BIO *out, X509 *x)
{
	char *p;

	p = X509_NAME_oneline(X509_get_subject_name(x), NULL, 0);
	BIO_puts(out, "subject=");
	BIO_puts(out, p);
	free(p);

	p = X509_NAME_oneline(X509_get_issuer_name(x), NULL, 0);
	BIO_puts(out, "\nissuer=");
	BIO_puts(out, p);
	BIO_puts(out, "\n");
	free(p);

	return 0;
}

static int
ui_open(UI *ui)
{
	return UI_method_get_opener(UI_OpenSSL()) (ui);
}

static int
ui_read(UI *ui, UI_STRING *uis)
{
	if (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD &&
	    UI_get0_user_data(ui)) {
		switch (UI_get_string_type(uis)) {
		case UIT_PROMPT:
		case UIT_VERIFY:
			{
				const char *password =
				    ((PW_CB_DATA *)UI_get0_user_data(ui))->password;
				if (password && password[0] != '\0') {
					UI_set_result(ui, uis, password);
					return 1;
				}
			}
			break;
		default:
			break;
		}
	}
	return UI_method_get_reader(UI_OpenSSL()) (ui, uis);
}

static int
ui_write(UI *ui, UI_STRING *uis)
{
	if (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD &&
	    UI_get0_user_data(ui)) {
		switch (UI_get_string_type(uis)) {
		case UIT_PROMPT:
		case UIT_VERIFY:
			{
				const char *password =
				    ((PW_CB_DATA *)UI_get0_user_data(ui))->password;
				if (password && password[0] != '\0')
					return 1;
			}
			break;
		default:
			break;
		}
	}
	return UI_method_get_writer(UI_OpenSSL()) (ui, uis);
}

static int
ui_close(UI *ui)
{
	return UI_method_get_closer(UI_OpenSSL()) (ui);
}

int
setup_ui_method(void)
{
	ui_method = UI_create_method("OpenSSL application user interface");
	UI_method_set_opener(ui_method, ui_open);
	UI_method_set_reader(ui_method, ui_read);
	UI_method_set_writer(ui_method, ui_write);
	UI_method_set_closer(ui_method, ui_close);
	return 0;
}

void
destroy_ui_method(void)
{
	if (ui_method) {
		UI_destroy_method(ui_method);
		ui_method = NULL;
	}
}

int
password_callback(char *buf, int bufsiz, int verify, void *arg)
{
	PW_CB_DATA *cb_tmp = arg;
	UI *ui = NULL;
	int res = 0;
	const char *prompt_info = NULL;
	const char *password = NULL;
	PW_CB_DATA *cb_data = (PW_CB_DATA *) cb_tmp;

	if (cb_data) {
		if (cb_data->password)
			password = cb_data->password;
		if (cb_data->prompt_info)
			prompt_info = cb_data->prompt_info;
	}
	if (password) {
		res = strlen(password);
		if (res > bufsiz)
			res = bufsiz;
		memcpy(buf, password, res);
		return res;
	}
	ui = UI_new_method(ui_method);
	if (ui) {
		int ok = 0;
		char *buff = NULL;
		int ui_flags = 0;
		char *prompt = NULL;

		prompt = UI_construct_prompt(ui, "pass phrase", prompt_info);

		ui_flags |= UI_INPUT_FLAG_DEFAULT_PWD;
		UI_ctrl(ui, UI_CTRL_PRINT_ERRORS, 1, 0, 0);

		if (ok >= 0)
			ok = UI_add_input_string(ui, prompt, ui_flags, buf,
			    PW_MIN_LENGTH, bufsiz - 1);
		if (ok >= 0 && verify) {
			buff = malloc(bufsiz);
			ok = UI_add_verify_string(ui, prompt, ui_flags, buff,
			    PW_MIN_LENGTH, bufsiz - 1, buf);
		}
		if (ok >= 0)
			do {
				ok = UI_process(ui);
			} while (ok < 0 &&
			    UI_ctrl(ui, UI_CTRL_IS_REDOABLE, 0, 0, 0));

		if (buff) {
			OPENSSL_cleanse(buff, (unsigned int) bufsiz);
			free(buff);
		}
		if (ok >= 0)
			res = strlen(buf);
		if (ok == -1) {
			BIO_printf(bio_err, "User interface error\n");
			ERR_print_errors(bio_err);
			OPENSSL_cleanse(buf, (unsigned int) bufsiz);
			res = 0;
		}
		if (ok == -2) {
			BIO_printf(bio_err, "aborted!\n");
			OPENSSL_cleanse(buf, (unsigned int) bufsiz);
			res = 0;
		}
		UI_free(ui);
		free(prompt);
	}
	return res;
}

static char *app_get_pass(BIO *err, char *arg, int keepbio);

int
app_passwd(BIO *err, char *arg1, char *arg2, char **pass1, char **pass2)
{
	int same;

	if (!arg2 || !arg1 || strcmp(arg1, arg2))
		same = 0;
	else
		same = 1;
	if (arg1) {
		*pass1 = app_get_pass(err, arg1, same);
		if (!*pass1)
			return 0;
	} else if (pass1)
		*pass1 = NULL;
	if (arg2) {
		*pass2 = app_get_pass(err, arg2, same ? 2 : 0);
		if (!*pass2)
			return 0;
	} else if (pass2)
		*pass2 = NULL;
	return 1;
}

static char *
app_get_pass(BIO *err, char *arg, int keepbio)
{
	char *tmp, tpass[APP_PASS_LEN];
	static BIO *pwdbio = NULL;
	const char *errstr = NULL;
	int i;

	if (!strncmp(arg, "pass:", 5))
		return strdup(arg + 5);
	if (!strncmp(arg, "env:", 4)) {
		tmp = getenv(arg + 4);
		if (!tmp) {
			BIO_printf(err, "Can't read environment variable %s\n",
			    arg + 4);
			return NULL;
		}
		return strdup(tmp);
	}
	if (!keepbio || !pwdbio) {
		if (!strncmp(arg, "file:", 5)) {
			pwdbio = BIO_new_file(arg + 5, "r");
			if (!pwdbio) {
				BIO_printf(err, "Can't open file %s\n",
				    arg + 5);
				return NULL;
			}
		} else if (!strncmp(arg, "fd:", 3)) {
			BIO *btmp;
			i = strtonum(arg + 3, 0, INT_MAX, &errstr);
			if (errstr) {
				BIO_printf(err,
				    "Invalid file descriptor %s: %s\n",
				    arg, errstr);
				return NULL;
			}
			pwdbio = BIO_new_fd(i, BIO_NOCLOSE);
			if (!pwdbio) {
				BIO_printf(err,
				    "Can't access file descriptor %s\n",
				    arg + 3);
				return NULL;
			}
			/*
			 * Can't do BIO_gets on an fd BIO so add a buffering
			 * BIO
			 */
			btmp = BIO_new(BIO_f_buffer());
			pwdbio = BIO_push(btmp, pwdbio);
		} else if (!strcmp(arg, "stdin")) {
			pwdbio = BIO_new_fp(stdin, BIO_NOCLOSE);
			if (!pwdbio) {
				BIO_printf(err, "Can't open BIO for stdin\n");
				return NULL;
			}
		} else {
			BIO_printf(err, "Invalid password argument \"%s\"\n",
			    arg);
			return NULL;
		}
	}
	i = BIO_gets(pwdbio, tpass, APP_PASS_LEN);
	if (keepbio != 1) {
		BIO_free_all(pwdbio);
		pwdbio = NULL;
	}
	if (i <= 0) {
		BIO_printf(err, "Error reading password from BIO\n");
		return NULL;
	}
	tmp = strchr(tpass, '\n');
	if (tmp)
		*tmp = 0;
	return strdup(tpass);
}

int
add_oid_section(BIO *err, CONF *conf)
{
	char *p;
	STACK_OF(CONF_VALUE) *sktmp;
	CONF_VALUE *cnf;
	int i;

	if (!(p = NCONF_get_string(conf, NULL, "oid_section"))) {
		ERR_clear_error();
		return 1;
	}
	if (!(sktmp = NCONF_get_section(conf, p))) {
		BIO_printf(err, "problem loading oid section %s\n", p);
		return 0;
	}
	for (i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {
		cnf = sk_CONF_VALUE_value(sktmp, i);
		if (OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {
			BIO_printf(err, "problem creating object %s=%s\n",
			    cnf->name, cnf->value);
			return 0;
		}
	}
	return 1;
}

static int
load_pkcs12(BIO *err, BIO *in, const char *desc, pem_password_cb *pem_cb,
    void *cb_data, EVP_PKEY **pkey, X509 **cert, STACK_OF(X509) **ca)
{
	const char *pass;
	char tpass[PEM_BUFSIZE];
	int len, ret = 0;
	PKCS12 *p12;

	p12 = d2i_PKCS12_bio(in, NULL);
	if (p12 == NULL) {
		BIO_printf(err, "Error loading PKCS12 file for %s\n", desc);
		goto die;
	}
	/* See if an empty password will do */
	if (PKCS12_verify_mac(p12, "", 0) || PKCS12_verify_mac(p12, NULL, 0))
		pass = "";
	else {
		if (!pem_cb)
			pem_cb = password_callback;
		len = pem_cb(tpass, PEM_BUFSIZE, 0, cb_data);
		if (len < 0) {
			BIO_printf(err, "Passpharse callback error for %s\n",
			    desc);
			goto die;
		}
		if (len < PEM_BUFSIZE)
			tpass[len] = 0;
		if (!PKCS12_verify_mac(p12, tpass, len)) {
			BIO_printf(err,
			    "Mac verify error (wrong password?) in PKCS12 file for %s\n", desc);
			goto die;
		}
		pass = tpass;
	}
	ret = PKCS12_parse(p12, pass, pkey, cert, ca);

die:
	if (p12)
		PKCS12_free(p12);
	return ret;
}

X509 *
load_cert(BIO *err, const char *file, int format, const char *pass, ENGINE *e,
    const char *cert_descrip)
{
	X509 *x = NULL;
	BIO *cert;

	if ((cert = BIO_new(BIO_s_file())) == NULL) {
		ERR_print_errors(err);
		goto end;
	}
	if (file == NULL) {
		setvbuf(stdin, NULL, _IONBF, 0);
		BIO_set_fp(cert, stdin, BIO_NOCLOSE);
	} else {
		if (BIO_read_filename(cert, file) <= 0) {
			BIO_printf(err, "Error opening %s %s\n",
			    cert_descrip, file);
			ERR_print_errors(err);
			goto end;
		}
	}

	if (format == FORMAT_ASN1)
		x = d2i_X509_bio(cert, NULL);
	else if (format == FORMAT_NETSCAPE) {
		NETSCAPE_X509 *nx;
		nx = ASN1_item_d2i_bio(ASN1_ITEM_rptr(NETSCAPE_X509),
		    cert, NULL);
		if (nx == NULL)
			goto end;

		if ((strncmp(NETSCAPE_CERT_HDR, (char *) nx->header->data,
		    nx->header->length) != 0)) {
			NETSCAPE_X509_free(nx);
			BIO_printf(err,
			    "Error reading header on certificate\n");
			goto end;
		}
		x = nx->cert;
		nx->cert = NULL;
		NETSCAPE_X509_free(nx);
	} else if (format == FORMAT_PEM)
		x = PEM_read_bio_X509_AUX(cert, NULL, password_callback, NULL);
	else if (format == FORMAT_PKCS12) {
		if (!load_pkcs12(err, cert, cert_descrip, NULL, NULL,
		    NULL, &x, NULL))
			goto end;
	} else {
		BIO_printf(err, "bad input format specified for %s\n",
		    cert_descrip);
		goto end;
	}

end:
	if (x == NULL) {
		BIO_printf(err, "unable to load certificate\n");
		ERR_print_errors(err);
	}
	BIO_free(cert);
	return (x);
}

EVP_PKEY *
load_key(BIO *err, const char *file, int format, int maybe_stdin,
    const char *pass, ENGINE *e, const char *key_descrip)
{
	BIO *key = NULL;
	EVP_PKEY *pkey = NULL;
	PW_CB_DATA cb_data;

	cb_data.password = pass;
	cb_data.prompt_info = file;

	if (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE)) {
		BIO_printf(err, "no keyfile specified\n");
		goto end;
	}
#ifndef OPENSSL_NO_ENGINE
	if (format == FORMAT_ENGINE) {
		if (!e)
			BIO_printf(err, "no engine specified\n");
		else {
			pkey = ENGINE_load_private_key(e, file,
			    ui_method, &cb_data);
			if (!pkey) {
				BIO_printf(err, "cannot load %s from engine\n",
				    key_descrip);
				ERR_print_errors(err);
			}
		}
		goto end;
	}
#endif
	key = BIO_new(BIO_s_file());
	if (key == NULL) {
		ERR_print_errors(err);
		goto end;
	}
	if (file == NULL && maybe_stdin) {
		setvbuf(stdin, NULL, _IONBF, 0);
		BIO_set_fp(key, stdin, BIO_NOCLOSE);
	} else if (BIO_read_filename(key, file) <= 0) {
		BIO_printf(err, "Error opening %s %s\n",
		    key_descrip, file);
		ERR_print_errors(err);
		goto end;
	}
	if (format == FORMAT_ASN1) {
		pkey = d2i_PrivateKey_bio(key, NULL);
	} else if (format == FORMAT_PEM) {
		pkey = PEM_read_bio_PrivateKey(key, NULL, password_callback, &cb_data);
	}
#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)
	else if (format == FORMAT_NETSCAPE || format == FORMAT_IISSGC)
		pkey = load_netscape_key(err, key, file, key_descrip, format);
#endif
	else if (format == FORMAT_PKCS12) {
		if (!load_pkcs12(err, key, key_descrip, password_callback, &cb_data,
		    &pkey, NULL, NULL))
			goto end;
	}
#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_DSA) && !defined (OPENSSL_NO_RC4)
	else if (format == FORMAT_MSBLOB)
		pkey = b2i_PrivateKey_bio(key);
	else if (format == FORMAT_PVK)
		pkey = b2i_PVK_bio(key, password_callback,
		    &cb_data);
#endif
	else {
		BIO_printf(err, "bad input format specified for key file\n");
		goto end;
	}
end:
	BIO_free(key);
	if (pkey == NULL) {
		BIO_printf(err, "unable to load %s\n", key_descrip);
		ERR_print_errors(err);
	}
	return (pkey);
}

EVP_PKEY *
load_pubkey(BIO *err, const char *file, int format, int maybe_stdin,
    const char *pass, ENGINE *e, const char *key_descrip)
{
	BIO *key = NULL;
	EVP_PKEY *pkey = NULL;
	PW_CB_DATA cb_data;

	cb_data.password = pass;
	cb_data.prompt_info = file;

	if (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE)) {
		BIO_printf(err, "no keyfile specified\n");
		goto end;
	}
#ifndef OPENSSL_NO_ENGINE
	if (format == FORMAT_ENGINE) {
		if (!e)
			BIO_printf(bio_err, "no engine specified\n");
		else
			pkey = ENGINE_load_public_key(e, file,
			    ui_method, &cb_data);
		goto end;
	}
#endif
	key = BIO_new(BIO_s_file());
	if (key == NULL) {
		ERR_print_errors(err);
		goto end;
	}
	if (file == NULL && maybe_stdin) {
		setvbuf(stdin, NULL, _IONBF, 0);
		BIO_set_fp(key, stdin, BIO_NOCLOSE);
	} else if (BIO_read_filename(key, file) <= 0) {
		BIO_printf(err, "Error opening %s %s\n", key_descrip, file);
		ERR_print_errors(err);
		goto end;
	}
	if (format == FORMAT_ASN1) {
		pkey = d2i_PUBKEY_bio(key, NULL);
	}
	else if (format == FORMAT_ASN1RSA) {
		RSA *rsa;
		rsa = d2i_RSAPublicKey_bio(key, NULL);
		if (rsa) {
			pkey = EVP_PKEY_new();
			if (pkey)
				EVP_PKEY_set1_RSA(pkey, rsa);
			RSA_free(rsa);
		} else
			pkey = NULL;
	} else if (format == FORMAT_PEMRSA) {
		RSA *rsa;
		rsa = PEM_read_bio_RSAPublicKey(key, NULL, password_callback, &cb_data);
		if (rsa) {
			pkey = EVP_PKEY_new();
			if (pkey)
				EVP_PKEY_set1_RSA(pkey, rsa);
			RSA_free(rsa);
		} else
			pkey = NULL;
	}
	else if (format == FORMAT_PEM) {
		pkey = PEM_read_bio_PUBKEY(key, NULL, password_callback, &cb_data);
	}
#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)
	else if (format == FORMAT_NETSCAPE || format == FORMAT_IISSGC)
		pkey = load_netscape_key(err, key, file, key_descrip, format);
#endif
#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_DSA)
	else if (format == FORMAT_MSBLOB)
		pkey = b2i_PublicKey_bio(key);
#endif
	else {
		BIO_printf(err, "bad input format specified for key file\n");
		goto end;
	}

end:
	BIO_free(key);
	if (pkey == NULL)
		BIO_printf(err, "unable to load %s\n", key_descrip);
	return (pkey);
}

#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)
static EVP_PKEY *
load_netscape_key(BIO *err, BIO *key, const char *file,
    const char *key_descrip, int format)
{
	EVP_PKEY *pkey;
	BUF_MEM *buf;
	RSA *rsa;
	const unsigned char *p;
	int size, i;

	buf = BUF_MEM_new();
	pkey = EVP_PKEY_new();
	size = 0;
	if (buf == NULL || pkey == NULL)
		goto error;
	for (;;) {
		if (!BUF_MEM_grow_clean(buf, size + 1024 * 10))
			goto error;
		i = BIO_read(key, &(buf->data[size]), 1024 * 10);
		size += i;
		if (i == 0)
			break;
		if (i < 0) {
			BIO_printf(err, "Error reading %s %s",
			    key_descrip, file);
			goto error;
		}
	}
	p = (unsigned char *) buf->data;
	rsa = d2i_RSA_NET(NULL, &p, (long) size, NULL,
	    (format == FORMAT_IISSGC ? 1 : 0));
	if (rsa == NULL)
		goto error;
	BUF_MEM_free(buf);
	EVP_PKEY_set1_RSA(pkey, rsa);
	return pkey;

error:
	BUF_MEM_free(buf);
	EVP_PKEY_free(pkey);
	return NULL;
}
#endif				/* ndef OPENSSL_NO_RC4 */

static int
load_certs_crls(BIO *err, const char *file, int format, const char *pass,
    ENGINE *e, const char *desc, STACK_OF(X509) **pcerts,
    STACK_OF(X509_CRL) **pcrls)
{
	int i;
	BIO *bio;
	STACK_OF(X509_INFO) *xis = NULL;
	X509_INFO *xi;
	PW_CB_DATA cb_data;
	int rv = 0;

	cb_data.password = pass;
	cb_data.prompt_info = file;

	if (format != FORMAT_PEM) {
		BIO_printf(err, "bad input format specified for %s\n", desc);
		return 0;
	}
	if (file == NULL)
		bio = BIO_new_fp(stdin, BIO_NOCLOSE);
	else
		bio = BIO_new_file(file, "r");

	if (bio == NULL) {
		BIO_printf(err, "Error opening %s %s\n",
		    desc, file ? file : "stdin");
		ERR_print_errors(err);
		return 0;
	}
	xis = PEM_X509_INFO_read_bio(bio, NULL, password_callback, &cb_data);

	BIO_free(bio);

	if (pcerts) {
		*pcerts = sk_X509_new_null();
		if (!*pcerts)
			goto end;
	}
	if (pcrls) {
		*pcrls = sk_X509_CRL_new_null();
		if (!*pcrls)
			goto end;
	}
	for (i = 0; i < sk_X509_INFO_num(xis); i++) {
		xi = sk_X509_INFO_value(xis, i);
		if (xi->x509 && pcerts) {
			if (!sk_X509_push(*pcerts, xi->x509))
				goto end;
			xi->x509 = NULL;
		}
		if (xi->crl && pcrls) {
			if (!sk_X509_CRL_push(*pcrls, xi->crl))
				goto end;
			xi->crl = NULL;
		}
	}

	if (pcerts && sk_X509_num(*pcerts) > 0)
		rv = 1;

	if (pcrls && sk_X509_CRL_num(*pcrls) > 0)
		rv = 1;

end:
	if (xis)
		sk_X509_INFO_pop_free(xis, X509_INFO_free);

	if (rv == 0) {
		if (pcerts) {
			sk_X509_pop_free(*pcerts, X509_free);
			*pcerts = NULL;
		}
		if (pcrls) {
			sk_X509_CRL_pop_free(*pcrls, X509_CRL_free);
			*pcrls = NULL;
		}
		BIO_printf(err, "unable to load %s\n",
		    pcerts ? "certificates" : "CRLs");
		ERR_print_errors(err);
	}
	return rv;
}

STACK_OF(X509) *
load_certs(BIO *err, const char *file, int format, const char *pass,
    ENGINE *e, const char *desc)
{
	STACK_OF(X509) *certs;

	if (!load_certs_crls(err, file, format, pass, e, desc, &certs, NULL))
		return NULL;
	return certs;
}

STACK_OF(X509_CRL) *
load_crls(BIO *err, const char *file, int format, const char *pass, ENGINE *e,
    const char *desc)
{
	STACK_OF(X509_CRL) *crls;

	if (!load_certs_crls(err, file, format, pass, e, desc, NULL, &crls))
		return NULL;
	return crls;
}

#define X509V3_EXT_UNKNOWN_MASK		(0xfL << 16)
/* Return error for unknown extensions */
#define X509V3_EXT_DEFAULT		0
/* Print error for unknown extensions */
#define X509V3_EXT_ERROR_UNKNOWN	(1L << 16)
/* ASN1 parse unknown extensions */
#define X509V3_EXT_PARSE_UNKNOWN	(2L << 16)
/* BIO_dump unknown extensions */
#define X509V3_EXT_DUMP_UNKNOWN		(3L << 16)

#define X509_FLAG_CA (X509_FLAG_NO_ISSUER | X509_FLAG_NO_PUBKEY | \
			 X509_FLAG_NO_HEADER | X509_FLAG_NO_VERSION)

int
set_cert_ex(unsigned long *flags, const char *arg)
{
	static const NAME_EX_TBL cert_tbl[] = {
		{"compatible", X509_FLAG_COMPAT, 0xffffffffl},
		{"ca_default", X509_FLAG_CA, 0xffffffffl},
		{"no_header", X509_FLAG_NO_HEADER, 0},
		{"no_version", X509_FLAG_NO_VERSION, 0},
		{"no_serial", X509_FLAG_NO_SERIAL, 0},
		{"no_signame", X509_FLAG_NO_SIGNAME, 0},
		{"no_validity", X509_FLAG_NO_VALIDITY, 0},
		{"no_subject", X509_FLAG_NO_SUBJECT, 0},
		{"no_issuer", X509_FLAG_NO_ISSUER, 0},
		{"no_pubkey", X509_FLAG_NO_PUBKEY, 0},
		{"no_extensions", X509_FLAG_NO_EXTENSIONS, 0},
		{"no_sigdump", X509_FLAG_NO_SIGDUMP, 0},
		{"no_aux", X509_FLAG_NO_AUX, 0},
		{"no_attributes", X509_FLAG_NO_ATTRIBUTES, 0},
		{"ext_default", X509V3_EXT_DEFAULT, X509V3_EXT_UNKNOWN_MASK},
		{"ext_error", X509V3_EXT_ERROR_UNKNOWN, X509V3_EXT_UNKNOWN_MASK},
		{"ext_parse", X509V3_EXT_PARSE_UNKNOWN, X509V3_EXT_UNKNOWN_MASK},
		{"ext_dump", X509V3_EXT_DUMP_UNKNOWN, X509V3_EXT_UNKNOWN_MASK},
		{NULL, 0, 0}
	};
	return set_multi_opts(flags, arg, cert_tbl);
}

int
set_name_ex(unsigned long *flags, const char *arg)
{
	static const NAME_EX_TBL ex_tbl[] = {
		{"esc_2253", ASN1_STRFLGS_ESC_2253, 0},
		{"esc_ctrl", ASN1_STRFLGS_ESC_CTRL, 0},
		{"esc_msb", ASN1_STRFLGS_ESC_MSB, 0},
		{"use_quote", ASN1_STRFLGS_ESC_QUOTE, 0},
		{"utf8", ASN1_STRFLGS_UTF8_CONVERT, 0},
		{"ignore_type", ASN1_STRFLGS_IGNORE_TYPE, 0},
		{"show_type", ASN1_STRFLGS_SHOW_TYPE, 0},
		{"dump_all", ASN1_STRFLGS_DUMP_ALL, 0},
		{"dump_nostr", ASN1_STRFLGS_DUMP_UNKNOWN, 0},
		{"dump_der", ASN1_STRFLGS_DUMP_DER, 0},
		{"compat", XN_FLAG_COMPAT, 0xffffffffL},
		{"sep_comma_plus", XN_FLAG_SEP_COMMA_PLUS, XN_FLAG_SEP_MASK},
		{"sep_comma_plus_space", XN_FLAG_SEP_CPLUS_SPC, XN_FLAG_SEP_MASK},
		{"sep_semi_plus_space", XN_FLAG_SEP_SPLUS_SPC, XN_FLAG_SEP_MASK},
		{"sep_multiline", XN_FLAG_SEP_MULTILINE, XN_FLAG_SEP_MASK},
		{"dn_rev", XN_FLAG_DN_REV, 0},
		{"nofname", XN_FLAG_FN_NONE, XN_FLAG_FN_MASK},
		{"sname", XN_FLAG_FN_SN, XN_FLAG_FN_MASK},
		{"lname", XN_FLAG_FN_LN, XN_FLAG_FN_MASK},
		{"align", XN_FLAG_FN_ALIGN, 0},
		{"oid", XN_FLAG_FN_OID, XN_FLAG_FN_MASK},
		{"space_eq", XN_FLAG_SPC_EQ, 0},
		{"dump_unknown", XN_FLAG_DUMP_UNKNOWN_FIELDS, 0},
		{"RFC2253", XN_FLAG_RFC2253, 0xffffffffL},
		{"oneline", XN_FLAG_ONELINE, 0xffffffffL},
		{"multiline", XN_FLAG_MULTILINE, 0xffffffffL},
		{"ca_default", XN_FLAG_MULTILINE, 0xffffffffL},
		{NULL, 0, 0}
	};
	return set_multi_opts(flags, arg, ex_tbl);
}

int
set_ext_copy(int *copy_type, const char *arg)
{
	if (!strcasecmp(arg, "none"))
		*copy_type = EXT_COPY_NONE;
	else if (!strcasecmp(arg, "copy"))
		*copy_type = EXT_COPY_ADD;
	else if (!strcasecmp(arg, "copyall"))
		*copy_type = EXT_COPY_ALL;
	else
		return 0;
	return 1;
}

int
copy_extensions(X509 *x, X509_REQ *req, int copy_type)
{
	STACK_OF(X509_EXTENSION) *exts = NULL;
	X509_EXTENSION *ext, *tmpext;
	ASN1_OBJECT *obj;
	int i, idx, ret = 0;

	if (!x || !req || (copy_type == EXT_COPY_NONE))
		return 1;
	exts = X509_REQ_get_extensions(req);

	for (i = 0; i < sk_X509_EXTENSION_num(exts); i++) {
		ext = sk_X509_EXTENSION_value(exts, i);
		obj = X509_EXTENSION_get_object(ext);
		idx = X509_get_ext_by_OBJ(x, obj, -1);
		/* Does extension exist? */
		if (idx != -1) {
			/* If normal copy don't override existing extension */
			if (copy_type == EXT_COPY_ADD)
				continue;
			/* Delete all extensions of same type */
			do {
				tmpext = X509_get_ext(x, idx);
				X509_delete_ext(x, idx);
				X509_EXTENSION_free(tmpext);
				idx = X509_get_ext_by_OBJ(x, obj, -1);
			} while (idx != -1);
		}
		if (!X509_add_ext(x, ext, -1))
			goto end;
	}

	ret = 1;

end:
	sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);

	return ret;
}

static int
set_multi_opts(unsigned long *flags, const char *arg,
    const NAME_EX_TBL *in_tbl)
{
	STACK_OF(CONF_VALUE) *vals;
	CONF_VALUE *val;
	int i, ret = 1;

	if (!arg)
		return 0;
	vals = X509V3_parse_list(arg);
	for (i = 0; i < sk_CONF_VALUE_num(vals); i++) {
		val = sk_CONF_VALUE_value(vals, i);
		if (!set_table_opts(flags, val->name, in_tbl))
			ret = 0;
	}
	sk_CONF_VALUE_pop_free(vals, X509V3_conf_free);
	return ret;
}

static int
set_table_opts(unsigned long *flags, const char *arg,
    const NAME_EX_TBL *in_tbl)
{
	char c;
	const NAME_EX_TBL *ptbl;

	c = arg[0];
	if (c == '-') {
		c = 0;
		arg++;
	} else if (c == '+') {
		c = 1;
		arg++;
	} else
		c = 1;

	for (ptbl = in_tbl; ptbl->name; ptbl++) {
		if (!strcasecmp(arg, ptbl->name)) {
			*flags &= ~ptbl->mask;
			if (c)
				*flags |= ptbl->flag;
			else
				*flags &= ~ptbl->flag;
			return 1;
		}
	}
	return 0;
}

void
print_name(BIO *out, const char *title, X509_NAME *nm, unsigned long lflags)
{
	char *buf;
	char mline = 0;
	int indent = 0;

	if (title)
		BIO_puts(out, title);
	if ((lflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {
		mline = 1;
		indent = 4;
	}
	if (lflags == XN_FLAG_COMPAT) {
		buf = X509_NAME_oneline(nm, 0, 0);
		BIO_puts(out, buf);
		BIO_puts(out, "\n");
		free(buf);
	} else {
		if (mline)
			BIO_puts(out, "\n");
		X509_NAME_print_ex(out, nm, indent, lflags);
		BIO_puts(out, "\n");
	}
}

X509_STORE *
setup_verify(BIO *bp, char *CAfile, char *CApath)
{
	X509_STORE *store;
	X509_LOOKUP *lookup;

	if (!(store = X509_STORE_new()))
		goto end;
	lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());
	if (lookup == NULL)
		goto end;
	if (CAfile) {
		if (!X509_LOOKUP_load_file(lookup, CAfile, X509_FILETYPE_PEM)) {
			BIO_printf(bp, "Error loading file %s\n", CAfile);
			goto end;
		}
	} else
		X509_LOOKUP_load_file(lookup, NULL, X509_FILETYPE_DEFAULT);

	lookup = X509_STORE_add_lookup(store, X509_LOOKUP_hash_dir());
	if (lookup == NULL)
		goto end;
	if (CApath) {
		if (!X509_LOOKUP_add_dir(lookup, CApath, X509_FILETYPE_PEM)) {
			BIO_printf(bp, "Error loading directory %s\n", CApath);
			goto end;
		}
	} else
		X509_LOOKUP_add_dir(lookup, NULL, X509_FILETYPE_DEFAULT);

	ERR_clear_error();
	return store;

end:
	X509_STORE_free(store);
	return NULL;
}

#ifndef OPENSSL_NO_ENGINE
/* Try to load an engine in a shareable library */
static ENGINE *
try_load_engine(BIO *err, const char *engine, int debug)
{
	ENGINE *e = ENGINE_by_id("dynamic");

	if (e) {
		if (!ENGINE_ctrl_cmd_string(e, "SO_PATH", engine, 0) ||
		    !ENGINE_ctrl_cmd_string(e, "LOAD", NULL, 0)) {
			ENGINE_free(e);
			e = NULL;
		}
	}
	return e;
}

ENGINE *
setup_engine(BIO *err, const char *engine, int debug)
{
	ENGINE *e = NULL;

	if (engine) {
		if (strcmp(engine, "auto") == 0) {
			BIO_printf(err, "enabling auto ENGINE support\n");
			ENGINE_register_all_complete();
			return NULL;
		}
		if ((e = ENGINE_by_id(engine)) == NULL &&
		    (e = try_load_engine(err, engine, debug)) == NULL) {
			BIO_printf(err, "invalid engine \"%s\"\n", engine);
			ERR_print_errors(err);
			return NULL;
		}
		if (debug) {
			ENGINE_ctrl(e, ENGINE_CTRL_SET_LOGSTREAM,
			    0, err, 0);
		}
		ENGINE_ctrl_cmd(e, "SET_USER_INTERFACE", 0, ui_method, 0, 1);
		if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
			BIO_printf(err, "can't use that engine\n");
			ERR_print_errors(err);
			ENGINE_free(e);
			return NULL;
		}
		BIO_printf(err, "engine \"%s\" set.\n", ENGINE_get_id(e));

		/* Free our "structural" reference. */
		ENGINE_free(e);
	}
	return e;
}
#endif

int
load_config(BIO *err, CONF *cnf)
{
	static int load_config_called = 0;

	if (load_config_called)
		return 1;
	load_config_called = 1;
	if (cnf == NULL)
		cnf = config;
	if (cnf == NULL)
		return 1;

	OPENSSL_load_builtin_modules();

	if (CONF_modules_load(cnf, NULL, 0) <= 0) {
		BIO_printf(err, "Error configuring OpenSSL\n");
		ERR_print_errors(err);
		return 0;
	}
	return 1;
}

char *
make_config_name()
{
	const char *t = X509_get_default_cert_area();
	char *p;

	if (asprintf(&p, "%s/openssl.cnf", t) == -1)
		return NULL;
	return p;
}

static unsigned long
index_serial_hash(const OPENSSL_CSTRING *a)
{
	const char *n;

	n = a[DB_serial];
	while (*n == '0')
		n++;
	return (lh_strhash(n));
}

static int
index_serial_cmp(const OPENSSL_CSTRING *a, const OPENSSL_CSTRING *b)
{
	const char *aa, *bb;

	for (aa = a[DB_serial]; *aa == '0'; aa++)
		;
	for (bb = b[DB_serial]; *bb == '0'; bb++)
		;
	return (strcmp(aa, bb));
}

static int
index_name_qual(char **a)
{
	return (a[0][0] == 'V');
}

static unsigned long
index_name_hash(const OPENSSL_CSTRING *a)
{
	return (lh_strhash(a[DB_name]));
}

int
index_name_cmp(const OPENSSL_CSTRING *a, const OPENSSL_CSTRING *b)
{
	return (strcmp(a[DB_name], b[DB_name]));
}

static IMPLEMENT_LHASH_HASH_FN(index_serial, OPENSSL_CSTRING)
static IMPLEMENT_LHASH_COMP_FN(index_serial, OPENSSL_CSTRING)
static IMPLEMENT_LHASH_HASH_FN(index_name, OPENSSL_CSTRING)
static IMPLEMENT_LHASH_COMP_FN(index_name, OPENSSL_CSTRING)

#define BSIZE 256

BIGNUM *
load_serial(char *serialfile, int create, ASN1_INTEGER **retai)
{
	BIO *in = NULL;
	BIGNUM *ret = NULL;
	char buf[1024];
	ASN1_INTEGER *ai = NULL;

	ai = ASN1_INTEGER_new();
	if (ai == NULL)
		goto err;

	if ((in = BIO_new(BIO_s_file())) == NULL) {
		ERR_print_errors(bio_err);
		goto err;
	}
	if (BIO_read_filename(in, serialfile) <= 0) {
		if (!create) {
			perror(serialfile);
			goto err;
		} else {
			ret = BN_new();
			if (ret == NULL || !rand_serial(ret, ai))
				BIO_printf(bio_err, "Out of memory\n");
		}
	} else {
		if (!a2i_ASN1_INTEGER(in, ai, buf, 1024)) {
			BIO_printf(bio_err, "unable to load number from %s\n",
			    serialfile);
			goto err;
		}
		ret = ASN1_INTEGER_to_BN(ai, NULL);
		if (ret == NULL) {
			BIO_printf(bio_err,
			    "error converting number from bin to BIGNUM\n");
			goto err;
		}
	}

	if (ret && retai) {
		*retai = ai;
		ai = NULL;
	}

err:
	if (in != NULL)
		BIO_free(in);
	if (ai != NULL)
		ASN1_INTEGER_free(ai);
	return (ret);
}

int
save_serial(char *serialfile, char *suffix, BIGNUM *serial,
    ASN1_INTEGER **retai)
{
	char buf[1][BSIZE];
	BIO *out = NULL;
	int ret = 0, n;
	ASN1_INTEGER *ai = NULL;
	int j;

	if (suffix == NULL)
		j = strlen(serialfile);
	else
		j = strlen(serialfile) + strlen(suffix) + 1;
	if (j >= BSIZE) {
		BIO_printf(bio_err, "file name too long\n");
		goto err;
	}
	if (suffix == NULL)
		n = strlcpy(buf[0], serialfile, BSIZE);
	else
		n = snprintf(buf[0], sizeof buf[0], "%s.%s",
		    serialfile, suffix);
	if (n == -1 || n >= sizeof(buf[0])) {
		BIO_printf(bio_err, "serial too long\n");
		goto err;
	}
	out = BIO_new(BIO_s_file());
	if (out == NULL) {
		ERR_print_errors(bio_err);
		goto err;
	}
	if (BIO_write_filename(out, buf[0]) <= 0) {
		perror(serialfile);
		goto err;
	}
	if ((ai = BN_to_ASN1_INTEGER(serial, NULL)) == NULL) {
		BIO_printf(bio_err,
		    "error converting serial to ASN.1 format\n");
		goto err;
	}
	i2a_ASN1_INTEGER(out, ai);
	BIO_puts(out, "\n");
	ret = 1;
	if (retai) {
		*retai = ai;
		ai = NULL;
	}

err:
	if (out != NULL)
		BIO_free_all(out);
	if (ai != NULL)
		ASN1_INTEGER_free(ai);
	return (ret);
}

int
rotate_serial(char *serialfile, char *new_suffix, char *old_suffix)
{
	char buf[5][BSIZE];
	int i, j;

	i = strlen(serialfile) + strlen(old_suffix);
	j = strlen(serialfile) + strlen(new_suffix);
	if (i > j)
		j = i;
	if (j + 1 >= BSIZE) {
		BIO_printf(bio_err, "file name too long\n");
		goto err;
	}
	snprintf(buf[0], sizeof buf[0], "%s.%s", serialfile, new_suffix);
	snprintf(buf[1], sizeof buf[1], "%s.%s", serialfile, old_suffix);


	if (rename(serialfile, buf[1]) < 0 &&
	    errno != ENOENT && errno != ENOTDIR) {
		BIO_printf(bio_err, "unable to rename %s to %s\n",
		    serialfile, buf[1]);
		perror("reason");
		goto err;
	}


	if (rename(buf[0], serialfile) < 0) {
		BIO_printf(bio_err, "unable to rename %s to %s\n",
		    buf[0], serialfile);
		perror("reason");
		rename(buf[1], serialfile);
		goto err;
	}
	return 1;

err:
	return 0;
}

int
rand_serial(BIGNUM *b, ASN1_INTEGER *ai)
{
	BIGNUM *btmp;
	int ret = 0;

	if (b)
		btmp = b;
	else
		btmp = BN_new();

	if (!btmp)
		return 0;

	if (!BN_pseudo_rand(btmp, SERIAL_RAND_BITS, 0, 0))
		goto error;
	if (ai && !BN_to_ASN1_INTEGER(btmp, ai))
		goto error;

	ret = 1;

error:
	if (!b)
		BN_free(btmp);

	return ret;
}

CA_DB *
load_index(char *dbfile, DB_ATTR *db_attr)
{
	CA_DB *retdb = NULL;
	TXT_DB *tmpdb = NULL;
	BIO *in = BIO_new(BIO_s_file());
	CONF *dbattr_conf = NULL;
	char buf[1][BSIZE];
	long errorline = -1;

	if (in == NULL) {
		ERR_print_errors(bio_err);
		goto err;
	}
	if (BIO_read_filename(in, dbfile) <= 0) {
		perror(dbfile);
		BIO_printf(bio_err, "unable to open '%s'\n", dbfile);
		goto err;
	}
	if ((tmpdb = TXT_DB_read(in, DB_NUMBER)) == NULL)
		goto err;

	snprintf(buf[0], sizeof buf[0], "%s.attr", dbfile);
	dbattr_conf = NCONF_new(NULL);
	if (NCONF_load(dbattr_conf, buf[0], &errorline) <= 0) {
		if (errorline > 0) {
			BIO_printf(bio_err,
			    "error on line %ld of db attribute file '%s'\n",
			    errorline, buf[0]);
			goto err;
		} else {
			NCONF_free(dbattr_conf);
			dbattr_conf = NULL;
		}
	}
	if ((retdb = malloc(sizeof(CA_DB))) == NULL) {
		fprintf(stderr, "Out of memory\n");
		goto err;
	}
	retdb->db = tmpdb;
	tmpdb = NULL;
	if (db_attr)
		retdb->attributes = *db_attr;
	else {
		retdb->attributes.unique_subject = 1;
	}

	if (dbattr_conf) {
		char *p = NCONF_get_string(dbattr_conf, NULL, "unique_subject");
		if (p) {
			retdb->attributes.unique_subject = parse_yesno(p, 1);
		}
	}

err:
	if (dbattr_conf)
		NCONF_free(dbattr_conf);
	if (tmpdb)
		TXT_DB_free(tmpdb);
	if (in)
		BIO_free_all(in);
	return retdb;
}

int
index_index(CA_DB *db)
{
	if (!TXT_DB_create_index(db->db, DB_serial, NULL,
	    LHASH_HASH_FN(index_serial), LHASH_COMP_FN(index_serial))) {
		BIO_printf(bio_err,
		    "error creating serial number index:(%ld,%ld,%ld)\n",
		    db->db->error, db->db->arg1, db->db->arg2);
		return 0;
	}
	if (db->attributes.unique_subject &&
	    !TXT_DB_create_index(db->db, DB_name, index_name_qual,
	    LHASH_HASH_FN(index_name), LHASH_COMP_FN(index_name))) {
		BIO_printf(bio_err, "error creating name index:(%ld,%ld,%ld)\n",
		    db->db->error, db->db->arg1, db->db->arg2);
		return 0;
	}
	return 1;
}

int
save_index(const char *dbfile, const char *suffix, CA_DB *db)
{
	char buf[3][BSIZE];
	BIO *out = BIO_new(BIO_s_file());
	int j;

	if (out == NULL) {
		ERR_print_errors(bio_err);
		goto err;
	}
	j = strlen(dbfile) + strlen(suffix);
	if (j + 6 >= BSIZE) {
		BIO_printf(bio_err, "file name too long\n");
		goto err;
	}
	snprintf(buf[2], sizeof buf[2], "%s.attr", dbfile);
	snprintf(buf[1], sizeof buf[1], "%s.attr.%s", dbfile, suffix);
	snprintf(buf[0], sizeof buf[0], "%s.%s", dbfile, suffix);


	if (BIO_write_filename(out, buf[0]) <= 0) {
		perror(dbfile);
		BIO_printf(bio_err, "unable to open '%s'\n", dbfile);
		goto err;
	}
	j = TXT_DB_write(out, db->db);
	if (j <= 0)
		goto err;

	BIO_free(out);

	out = BIO_new(BIO_s_file());


	if (BIO_write_filename(out, buf[1]) <= 0) {
		perror(buf[2]);
		BIO_printf(bio_err, "unable to open '%s'\n", buf[2]);
		goto err;
	}
	BIO_printf(out, "unique_subject = %s\n",
	    db->attributes.unique_subject ? "yes" : "no");
	BIO_free(out);

	return 1;

err:
	return 0;
}

int
rotate_index(const char *dbfile, const char *new_suffix, const char *old_suffix)
{
	char buf[5][BSIZE];
	int i, j;

	i = strlen(dbfile) + strlen(old_suffix);
	j = strlen(dbfile) + strlen(new_suffix);
	if (i > j)
		j = i;
	if (j + 6 >= BSIZE) {
		BIO_printf(bio_err, "file name too long\n");
		goto err;
	}
	snprintf(buf[4], sizeof buf[4], "%s.attr", dbfile);
	snprintf(buf[2], sizeof buf[2], "%s.attr.%s", dbfile, new_suffix);
	snprintf(buf[0], sizeof buf[0], "%s.%s", dbfile, new_suffix);
	snprintf(buf[1], sizeof buf[1], "%s.%s", dbfile, old_suffix);
	snprintf(buf[3], sizeof buf[3], "%s.attr.%s", dbfile, old_suffix);


	if (rename(dbfile, buf[1]) < 0 && errno != ENOENT && errno != ENOTDIR) {
		BIO_printf(bio_err, "unable to rename %s to %s\n",
		    dbfile, buf[1]);
		perror("reason");
		goto err;
	}


	if (rename(buf[0], dbfile) < 0) {
		BIO_printf(bio_err, "unable to rename %s to %s\n",
		    buf[0], dbfile);
		perror("reason");
		rename(buf[1], dbfile);
		goto err;
	}


	if (rename(buf[4], buf[3]) < 0 && errno != ENOENT && errno != ENOTDIR) {
		BIO_printf(bio_err, "unable to rename %s to %s\n",
		    buf[4], buf[3]);
		perror("reason");
		rename(dbfile, buf[0]);
		rename(buf[1], dbfile);
		goto err;
	}


	if (rename(buf[2], buf[4]) < 0) {
		BIO_printf(bio_err, "unable to rename %s to %s\n",
		    buf[2], buf[4]);
		perror("reason");
		rename(buf[3], buf[4]);
		rename(dbfile, buf[0]);
		rename(buf[1], dbfile);
		goto err;
	}
	return 1;

err:
	return 0;
}

void
free_index(CA_DB *db)
{
	if (db) {
		if (db->db)
			TXT_DB_free(db->db);
		free(db);
	}
}

int
parse_yesno(const char *str, int def)
{
	int ret = def;

	if (str) {
		switch (*str) {
		case 'f':	/* false */
		case 'F':	/* FALSE */
		case 'n':	/* no */
		case 'N':	/* NO */
		case '0':	/* 0 */
			ret = 0;
			break;
		case 't':	/* true */
		case 'T':	/* TRUE */
		case 'y':	/* yes */
		case 'Y':	/* YES */
		case '1':	/* 1 */
			ret = 1;
			break;
		default:
			ret = def;
			break;
		}
	}
	return ret;
}

/*
 * subject is expected to be in the format /type0=value0/type1=value1/type2=...
 * where characters may be escaped by \
 */
X509_NAME *
parse_name(char *subject, long chtype, int multirdn)
{
	X509_NAME *name = NULL;
	size_t buflen, max_ne;
	char **ne_types, **ne_values;
	char *buf, *bp, *sp;
	int i, nid, ne_num = 0;
	int *mval;

	/*
	 * Buffer to copy the types and values into. Due to escaping the
	 * copy can only become shorter.
	 */
	buflen = strlen(subject) + 1;
	buf = malloc(buflen);

	/* Maximum number of name elements. */
	max_ne = buflen / 2 + 1;
	ne_types = reallocarray(NULL, max_ne, sizeof(char *));
	ne_values = reallocarray(NULL, max_ne, sizeof(char *));
	mval = reallocarray(NULL, max_ne, sizeof(int));

	if (buf == NULL || ne_types == NULL || ne_values == NULL ||
	    mval == NULL) {
		BIO_printf(bio_err, "malloc error\n");
		goto error;
	}

	bp = buf;
	sp = subject;

	if (*subject != '/') {
		BIO_printf(bio_err, "Subject does not start with '/'.\n");
		goto error;
	}

	/* Skip leading '/'. */
	sp++;

	/* No multivalued RDN by default. */
	mval[ne_num] = 0;

	while (*sp) {
		/* Collect type. */
		ne_types[ne_num] = bp;
		while (*sp) {
			/* is there anything to escape in the type...? */
			if (*sp == '\\') {
				if (*++sp)
					*bp++ = *sp++;
				else {
					BIO_printf(bio_err, "escape character "
					    "at end of string\n");
					goto error;
				}
			} else if (*sp == '=') {
				sp++;
				*bp++ = '\0';
				break;
			} else
				*bp++ = *sp++;
		}
		if (!*sp) {
			BIO_printf(bio_err, "end of string encountered while "
			    "processing type of subject name element #%d\n",
			    ne_num);
			goto error;
		}
		ne_values[ne_num] = bp;
		while (*sp) {
			if (*sp == '\\') {
				if (*++sp)
					*bp++ = *sp++;
				else {
					BIO_printf(bio_err, "escape character "
					    "at end of string\n");
					goto error;
				}
			} else if (*sp == '/') {
				sp++;
				/* no multivalued RDN by default */
				mval[ne_num + 1] = 0;
				break;
			} else if (*sp == '+' && multirdn) {
				/* a not escaped + signals a mutlivalued RDN */
				sp++;
				mval[ne_num + 1] = -1;
				break;
			} else
				*bp++ = *sp++;
		}
		*bp++ = '\0';
		ne_num++;
	}

	if ((name = X509_NAME_new()) == NULL)
		goto error;

	for (i = 0; i < ne_num; i++) {
		if ((nid = OBJ_txt2nid(ne_types[i])) == NID_undef) {
			BIO_printf(bio_err,
			    "Subject Attribute %s has no known NID, skipped\n",
			    ne_types[i]);
			continue;
		}
		if (!*ne_values[i]) {
			BIO_printf(bio_err, "No value provided for Subject "
			    "Attribute %s, skipped\n", ne_types[i]);
			continue;
		}
		if (!X509_NAME_add_entry_by_NID(name, nid, chtype,
		    (unsigned char *) ne_values[i], -1, -1, mval[i]))
			goto error;
	}
	goto done;

error:
	X509_NAME_free(name);
	name = NULL;

done:
	free(ne_values);
	free(ne_types);
	free(mval);
	free(buf);

	return name;
}

int
args_verify(char ***pargs, int *pargc, int *badarg, BIO *err,
    X509_VERIFY_PARAM **pm)
{
	ASN1_OBJECT *otmp = NULL;
	unsigned long flags = 0;
	int i;
	int purpose = 0, depth = -1;
	char **oldargs = *pargs;
	char *arg = **pargs, *argn = (*pargs)[1];
	time_t at_time = 0;
	const char *errstr = NULL;

	if (!strcmp(arg, "-policy")) {
		if (!argn)
			*badarg = 1;
		else {
			otmp = OBJ_txt2obj(argn, 0);
			if (!otmp) {
				BIO_printf(err, "Invalid Policy \"%s\"\n",
				    argn);
				*badarg = 1;
			}
		}
		(*pargs)++;
	} else if (strcmp(arg, "-purpose") == 0) {
		X509_PURPOSE *xptmp;
		if (!argn)
			*badarg = 1;
		else {
			i = X509_PURPOSE_get_by_sname(argn);
			if (i < 0) {
				BIO_printf(err, "unrecognized purpose\n");
				*badarg = 1;
			} else {
				xptmp = X509_PURPOSE_get0(i);
				purpose = X509_PURPOSE_get_id(xptmp);
			}
		}
		(*pargs)++;
	} else if (strcmp(arg, "-verify_depth") == 0) {
		if (!argn)
			*badarg = 1;
		else {
			depth = strtonum(argn, 1, INT_MAX, &errstr);
			if (errstr) {
				BIO_printf(err, "invalid depth %s: %s\n",
				    argn, errstr);
				*badarg = 1;
			}
		}
		(*pargs)++;
	} else if (strcmp(arg, "-attime") == 0) {
		if (!argn)
			*badarg = 1;
		else {
			long long timestamp;
			/*
			 * interpret the -attime argument as seconds since
			 * Epoch
			 */
			if (sscanf(argn, "%lli", &timestamp) != 1) {
				BIO_printf(bio_err,
				    "Error parsing timestamp %s\n",
				    argn);
				*badarg = 1;
			}
			/* XXX 2038 truncation */
			at_time = (time_t) timestamp;
		}
		(*pargs)++;
	} else if (!strcmp(arg, "-ignore_critical"))
		flags |= X509_V_FLAG_IGNORE_CRITICAL;
	else if (!strcmp(arg, "-issuer_checks"))
		flags |= X509_V_FLAG_CB_ISSUER_CHECK;
	else if (!strcmp(arg, "-crl_check"))
		flags |= X509_V_FLAG_CRL_CHECK;
	else if (!strcmp(arg, "-crl_check_all"))
		flags |= X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL;
	else if (!strcmp(arg, "-policy_check"))
		flags |= X509_V_FLAG_POLICY_CHECK;
	else if (!strcmp(arg, "-explicit_policy"))
		flags |= X509_V_FLAG_EXPLICIT_POLICY;
	else if (!strcmp(arg, "-inhibit_any"))
		flags |= X509_V_FLAG_INHIBIT_ANY;
	else if (!strcmp(arg, "-inhibit_map"))
		flags |= X509_V_FLAG_INHIBIT_MAP;
	else if (!strcmp(arg, "-x509_strict"))
		flags |= X509_V_FLAG_X509_STRICT;
	else if (!strcmp(arg, "-extended_crl"))
		flags |= X509_V_FLAG_EXTENDED_CRL_SUPPORT;
	else if (!strcmp(arg, "-use_deltas"))
		flags |= X509_V_FLAG_USE_DELTAS;
	else if (!strcmp(arg, "-policy_print"))
		flags |= X509_V_FLAG_NOTIFY_POLICY;
	else if (!strcmp(arg, "-check_ss_sig"))
		flags |= X509_V_FLAG_CHECK_SS_SIGNATURE;
	else
		return 0;

	if (*badarg) {
		if (*pm)
			X509_VERIFY_PARAM_free(*pm);
		*pm = NULL;
		goto end;
	}
	if (!*pm && !(*pm = X509_VERIFY_PARAM_new())) {
		*badarg = 1;
		goto end;
	}
	if (otmp)
		X509_VERIFY_PARAM_add0_policy(*pm, otmp);
	if (flags)
		X509_VERIFY_PARAM_set_flags(*pm, flags);

	if (purpose)
		X509_VERIFY_PARAM_set_purpose(*pm, purpose);

	if (depth >= 0)
		X509_VERIFY_PARAM_set_depth(*pm, depth);

	if (at_time)
		X509_VERIFY_PARAM_set_time(*pm, at_time);

end:
	(*pargs)++;

	if (pargc)
		*pargc -= *pargs - oldargs;

	return 1;
}

/* Read whole contents of a BIO into an allocated memory buffer and
 * return it.
 */

int
bio_to_mem(unsigned char **out, int maxlen, BIO *in)
{
	BIO *mem;
	int len, ret;
	unsigned char tbuf[1024];

	mem = BIO_new(BIO_s_mem());
	if (!mem)
		return -1;
	for (;;) {
		if ((maxlen != -1) && maxlen < 1024)
			len = maxlen;
		else
			len = 1024;
		len = BIO_read(in, tbuf, len);
		if (len <= 0)
			break;
		if (BIO_write(mem, tbuf, len) != len) {
			BIO_free(mem);
			return -1;
		}
		maxlen -= len;

		if (maxlen == 0)
			break;
	}
	ret = BIO_get_mem_data(mem, (char **) out);
	BIO_set_flags(mem, BIO_FLAGS_MEM_RDONLY);
	BIO_free(mem);
	return ret;
}

int
pkey_ctrl_string(EVP_PKEY_CTX *ctx, char *value)
{
	int rv;
	char *stmp, *vtmp = NULL;

	stmp = BUF_strdup(value);
	if (!stmp)
		return -1;
	vtmp = strchr(stmp, ':');
	if (vtmp) {
		*vtmp = 0;
		vtmp++;
	}
	rv = EVP_PKEY_CTX_ctrl_str(ctx, stmp, vtmp);
	free(stmp);

	return rv;
}

static void
nodes_print(BIO *out, const char *name, STACK_OF(X509_POLICY_NODE) *nodes)
{
	X509_POLICY_NODE *node;
	int i;

	BIO_printf(out, "%s Policies:", name);
	if (nodes) {
		BIO_puts(out, "\n");
		for (i = 0; i < sk_X509_POLICY_NODE_num(nodes); i++) {
			node = sk_X509_POLICY_NODE_value(nodes, i);
			X509_POLICY_NODE_print(out, node, 2);
		}
	} else
		BIO_puts(out, " <empty>\n");
}

void
policies_print(BIO *out, X509_STORE_CTX *ctx)
{
	X509_POLICY_TREE *tree;
	int explicit_policy;
	int free_out = 0;

	if (out == NULL) {
		out = BIO_new_fp(stderr, BIO_NOCLOSE);
		free_out = 1;
	}
	tree = X509_STORE_CTX_get0_policy_tree(ctx);
	explicit_policy = X509_STORE_CTX_get_explicit_policy(ctx);

	BIO_printf(out, "Require explicit Policy: %s\n",
	    explicit_policy ? "True" : "False");

	nodes_print(out, "Authority", X509_policy_tree_get0_policies(tree));
	nodes_print(out, "User", X509_policy_tree_get0_user_policies(tree));
	if (free_out)
		BIO_free(out);
}

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
/* next_protos_parse parses a comma separated list of strings into a string
 * in a format suitable for passing to SSL_CTX_set_next_protos_advertised.
 *   outlen: (output) set to the length of the resulting buffer on success.
 *   err: (maybe NULL) on failure, an error message line is written to this BIO.
 *   in: a NUL termianted string like "abc,def,ghi"
 *
 *   returns: a malloced buffer or NULL on failure.
 */
unsigned char *
next_protos_parse(unsigned short *outlen, const char *in)
{
	size_t len;
	unsigned char *out;
	size_t i, start = 0;

	len = strlen(in);
	if (len >= 65535)
		return NULL;

	out = malloc(strlen(in) + 1);
	if (!out)
		return NULL;

	for (i = 0; i <= len; ++i) {
		if (i == len || in[i] == ',') {
			if (i - start > 255) {
				free(out);
				return NULL;
			}
			out[start] = i - start;
			start = i + 1;
		} else
			out[i + 1] = in[i];
	}

	*outlen = len + 1;
	return out;
}
#endif
/* !OPENSSL_NO_TLSEXT && !OPENSSL_NO_NEXTPROTONEG */

double
app_tminterval(int stop, int usertime)
{
	double ret = 0;
	struct tms rus;
	clock_t now = times(&rus);
	static clock_t tmstart;

	if (usertime)
		now = rus.tms_utime;

	if (stop == TM_START)
		tmstart = now;
	else {
		long int tck = sysconf(_SC_CLK_TCK);
		ret = (now - tmstart) / (double) tck;
	}

	return (ret);
}

int
app_isdir(const char *name)
{
	struct stat st;

	if (stat(name, &st) == 0)
		return S_ISDIR(st.st_mode);
	return -1;
}
@


1.69
log
@BIO_free() returns immediately when the sole input is NULL.
Remove unnecessary NULL check.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: apps.c,v 1.68 2014/07/19 03:40:26 lteo Exp $ */
@


1.68
log
@Fix strtonum range to unbreak -pass fd:0

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: apps.c,v 1.67 2014/07/14 00:35:10 deraadt Exp $ */
d672 1
a672 2
	if (cert != NULL)
		BIO_free(cert);
d747 1
a747 2
	if (key != NULL)
		BIO_free(key);
d834 1
a834 2
	if (key != NULL)
		BIO_free(key);
@


1.67
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: apps.c,v 1.66 2014/07/13 16:03:09 beck Exp $ */
d496 1
a496 1
			i = strtonum(arg + 3, 1, INT_MAX, &errstr);
@


1.66
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: apps.c,v 1.65 2014/07/12 17:54:31 jsing Exp $ */
d1803 1
a1803 1
	 * Buffer to copy the types and values into. Due to escaping the 
@


1.65
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: apps.c,v 1.64 2014/07/09 21:13:34 tedu Exp $ */
d476 1
a476 1
		return BUF_strdup(arg + 5);
d484 1
a484 1
		return BUF_strdup(tmp);
d540 1
a540 1
	return BUF_strdup(tpass);
@


1.64
log
@unfidef RL_DEBUG. hopefully it's been debugged by now
@
text
@d1 1
a1 1
/* $OpenBSD: apps.c,v 1.63 2014/07/09 21:02:35 tedu Exp $ */
d1301 1
a1301 1
	if (!cnf)
d1303 1
a1303 1
	if (!cnf)
@


1.63
log
@unifdef a whole bunch of NO RSA/DSA/ECDH defines i deleted from libssl
@
text
@d1 1
a1 1
/* $OpenBSD: apps.c,v 1.62 2014/07/09 20:37:20 tedu Exp $ */
a1453 3
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: writing \"%s\"\n", buf[0]);
#endif
a1500 4
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
	    serialfile, buf[1]);
#endif
a1509 4
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
	    buf[0], serialfile);
#endif
a1601 4
#ifdef RL_DEBUG
			BIO_printf(bio_err,
			    "DEBUG[load_index]: unique_subject = \"%s\"\n", p);
#endif
a1655 3
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: writing \"%s\"\n", buf[0]);
#endif
a1669 3
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: writing \"%s\"\n", buf[1]);
#endif
a1705 4
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
	    dbfile, buf[1]);
#endif
a1713 4
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
	    buf[0], dbfile);
#endif
a1722 4
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
	    buf[4], buf[3]);
#endif
a1732 4
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
	    buf[2], buf[4]);
#endif
@


1.62
log
@move a comment
@
text
@d1 1
a1 1
/* $OpenBSD: apps.c,v 1.61 2014/07/09 09:06:58 bcook Exp $ */
a139 1
#ifndef OPENSSL_NO_RSA
a140 1
#endif
a797 1
#ifndef OPENSSL_NO_RSA
a818 1
#endif
@


1.61
log
@Remove typecasts on password_callback.

Rather than casting password_callback to the correct function pointer
signature at every call site, change it to match the signature instead.

ok miod@@ deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: apps.c,v 1.60 2014/06/28 04:39:41 deraadt Exp $ */
d2232 2
a2233 2
#endif				/* !OPENSSL_NO_TLSEXT &&
				 * !OPENSSL_NO_NEXTPROTONEG */
@


1.60
log
@Use strtonum() instead of atoi(), and then impose what are we think
are the current range checks.  Help from millert and lteo.  Please test
now that it is deployed and let us know if any numbers are off..
ok lteo
@
text
@d1 1
a1 1
/* $OpenBSD: apps.c,v 1.59 2014/06/12 15:49:27 deraadt Exp $ */
d372 1
a372 1
password_callback(char *buf, int bufsiz, int verify, PW_CB_DATA *cb_tmp)
d374 1
d591 1
a591 1
			pem_cb = (pem_password_cb *) password_callback;
d658 1
a658 2
		x = PEM_read_bio_X509_AUX(cert, NULL,
		    (pem_password_cb *) password_callback, NULL);
d727 1
a727 2
		pkey = PEM_read_bio_PrivateKey(key, NULL,
		    (pem_password_cb *) password_callback, &cb_data);
d734 1
a734 2
		if (!load_pkcs12(err, key, key_descrip,
		    (pem_password_cb *) password_callback, &cb_data,
d742 1
a742 1
		pkey = b2i_PVK_bio(key, (pem_password_cb *) password_callback,
d813 1
a813 2
		rsa = PEM_read_bio_RSAPublicKey(key, NULL,
		    (pem_password_cb *) password_callback, &cb_data);
d824 1
a824 2
		pkey = PEM_read_bio_PUBKEY(key, NULL,
		    (pem_password_cb *) password_callback, &cb_data);
d922 1
a922 2
	xis = PEM_X509_INFO_read_bio(bio, NULL,
	    (pem_password_cb *) password_callback, &cb_data);
@


1.59
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d120 1
d473 1
d497 9
a505 4
			i = atoi(arg + 3);
			if (i >= 0)
				pwdbio = BIO_new_fd(i, BIO_NOCLOSE);
			if ((i < 0) || !pwdbio) {
d1979 1
d2012 4
a2015 3
			depth = atoi(argn);
			if (depth < 0) {
				BIO_printf(err, "invalid depth\n");
@


1.58
log
@/* on some platforms time_t may be a float */
In the past, time_t's type was underspecified.  But a floating point type
would not have worked in practice.  Newer specifications effectively forbid it.

While cleaning this up, get partly ready for Y2038.
ok miod
@
text
@d1 1
a1 1
/* apps/apps.c */
@


1.57
log
@malloc() result does not need a cast.
ok miod
@
text
@d2015 1
a2015 1
			long timestamp;
d2020 1
a2020 1
			if (sscanf(argn, "%li", &timestamp) != 1) {
d2026 1
a2026 1
			/* on some platforms time_t may be a float */
@


1.56
log
@Rework parse_name() so that variable declaration is separate from function
based initialisation, use more readable variable names and use a goto
rather than duplicating the frees for the error and non-error paths...

ok beck@@
@
text
@d408 1
a408 1
			buff = (char *) malloc(bufsiz);
@


1.55
log
@trivial realloc -> reallocarray
@
text
@d1834 19
a1852 9
	size_t buflen = strlen(subject) + 1;	/* to copy the types and
						 * values into. due to
						 * escaping, the copy can
						 * only become shorter */
	char *buf = malloc(buflen);
	size_t max_ne = buflen / 2 + 1;	/* maximum number of name elements */
	char **ne_types = reallocarray(NULL, max_ne, sizeof(char *));
	char **ne_values = reallocarray(NULL, max_ne, sizeof(char *));
	int *mval = reallocarray(NULL, max_ne, sizeof(int));
d1854 2
a1855 7
	char *sp = subject, *bp = buf;
	int i, ne_num = 0;

	X509_NAME *n = NULL;
	int nid;

	if (!buf || !ne_types || !ne_values || !mval) {
d1859 4
a1866 1
	sp++;			/* skip leading / */
d1868 4
a1871 1
	/* no multivalued RDN by default */
d1875 1
a1875 1
		/* collect type */
d1878 2
a1879 2
			if (*sp == '\\') {	/* is there anything to
						 * escape in the type...? */
d1883 2
a1884 1
					BIO_printf(bio_err, "escape character at end of string\n");
d1895 3
a1897 1
			BIO_printf(bio_err, "end of string encountered while processing type of subject name element #%d\n", ne_num);
d1906 2
a1907 1
					BIO_printf(bio_err, "escape character at end of string\n");
d1927 1
a1927 1
	if (!(n = X509_NAME_new()))
d1938 2
a1939 1
			BIO_printf(bio_err, "No value provided for Subject Attribute %s, skipped\n", ne_types[i]);
d1942 1
a1942 1
		if (!X509_NAME_add_entry_by_NID(n, nid, chtype,
d1946 1
d1948 3
a1950 6
	free(ne_values);
	free(ne_types);
	free(buf);
	free(mval);

	return n;
d1952 1
a1952 2
error:
	X509_NAME_free(n);
d1958 1
a1958 1
	return NULL;
@


1.54
log
@ok, next pass after review:  when possible, put the reallocarray arguments
in the "size_t nmemb, size_t size"
@
text
@d237 1
a237 2
			tmp_p = (char **) realloc(arg->data,
			    sizeof(char *) * tlen);
@


1.53
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d217 1
a217 1
		arg->data = reallocarray(NULL, sizeof(char *), arg->count);
@


1.52
log
@Move include to the top and nuke pointless comments.
@
text
@d217 1
a217 1
		arg->data = (char **)malloc(sizeof(char *) * arg->count);
d1841 3
a1843 3
	char **ne_types = malloc(max_ne * sizeof(char *));
	char **ne_values = malloc(max_ne * sizeof(char *));
	int *mval = malloc(max_ne * sizeof(int));
@


1.51
log
@More KNF.
@
text
@d114 1
a2218 7
/*
 * Platform-specific sections
 */

/* app_tminterval section */
#include <sys/times.h>

a2238 1

@


1.50
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@d151 1
a151 1
    const NAME_EX_TBL * in_tbl);
d153 1
a153 1
    const NAME_EX_TBL * in_tbl);
d157 1
a157 1
static EVP_PKEY *load_netscape_key(BIO * err, BIO * key, const char *file,
d205 1
a205 1
chopup_args(ARGS * arg, char *buf, int *argc, char **argv[])
d274 1
a274 1
dump_cert_text(BIO * out, X509 * x)
d293 1
a293 1
ui_open(UI * ui)
d299 1
a299 1
ui_read(UI * ui, UI_STRING * uis)
d323 1
a323 1
ui_write(UI * ui, UI_STRING * uis)
d345 1
a345 1
ui_close(UI * ui)
d371 1
a371 1
password_callback(char *buf, int bufsiz, int verify, PW_CB_DATA * cb_tmp)
d441 1
a441 1
static char *app_get_pass(BIO * err, char *arg, int keepbio);
d444 1
a444 1
app_passwd(BIO * err, char *arg1, char *arg2, char **pass1, char **pass2)
d468 1
a468 1
app_get_pass(BIO * err, char *arg, int keepbio)
d538 1
a538 1
add_oid_section(BIO * err, CONF * conf)
d541 1
a541 1
	STACK_OF(CONF_VALUE) * sktmp;
d565 2
a566 2
load_pkcs12(BIO * err, BIO * in, const char *desc, pem_password_cb * pem_cb,
    void *cb_data, EVP_PKEY ** pkey, X509 ** cert, STACK_OF(X509) ** ca)
d608 1
a608 1
load_cert(BIO * err, const char *file, int format, const char *pass, ENGINE * e,
d673 2
a674 2
load_key(BIO * err, const char *file, int format, int maybe_stdin,
    const char *pass, ENGINE * e, const char *key_descrip)
d755 2
a756 2
load_pubkey(BIO * err, const char *file, int format, int maybe_stdin,
    const char *pass, ENGINE * e, const char *key_descrip)
d846 1
a846 1
load_netscape_key(BIO * err, BIO * key, const char *file,
d890 3
a892 3
load_certs_crls(BIO * err, const char *file, int format, const char *pass,
    ENGINE * e, const char *desc, STACK_OF(X509) ** pcerts,
    STACK_OF(X509_CRL) ** pcrls)
d896 1
a896 1
	STACK_OF(X509_INFO) * xis = NULL;
d975 2
a976 2
load_certs(BIO * err, const char *file, int format, const char *pass,
    ENGINE * e, const char *desc)
d978 1
a978 1
	STACK_OF(X509) * certs;
d986 1
a986 1
load_crls(BIO * err, const char *file, int format, const char *pass, ENGINE * e,
d989 1
a989 1
	STACK_OF(X509_CRL) * crls;
d1087 1
a1087 1
copy_extensions(X509 * x, X509_REQ * req, int copy_type)
d1089 1
a1089 1
	STACK_OF(X509_EXTENSION) * exts = NULL;
d1129 1
a1129 1
    const NAME_EX_TBL * in_tbl)
d1131 1
a1131 1
	STACK_OF(CONF_VALUE) * vals;
d1149 1
a1149 1
    const NAME_EX_TBL * in_tbl)
d1178 1
a1178 1
print_name(BIO * out, const char *title, X509_NAME * nm, unsigned long lflags)
d1204 1
a1204 1
setup_verify(BIO * bp, char *CAfile, char *CApath)
d1244 1
a1244 1
try_load_engine(BIO * err, const char *engine, int debug)
d1259 1
a1259 1
setup_engine(BIO * err, const char *engine, int debug)
d1296 1
a1296 1
load_config(BIO * err, CONF * cnf)
d1330 1
a1330 1
index_serial_hash(const OPENSSL_CSTRING * a)
d1341 1
a1341 1
index_serial_cmp(const OPENSSL_CSTRING * a, const OPENSSL_CSTRING * b)
d1359 1
a1359 1
index_name_hash(const OPENSSL_CSTRING * a)
d1365 1
a1365 1
index_name_cmp(const OPENSSL_CSTRING * a, const OPENSSL_CSTRING * b)
d1378 1
a1378 1
load_serial(char *serialfile, int create, ASN1_INTEGER ** retai)
d1430 2
a1431 2
save_serial(char *serialfile, char *suffix, BIGNUM * serial,
    ASN1_INTEGER ** retai)
d1538 1
a1538 1
rand_serial(BIGNUM * b, ASN1_INTEGER * ai)
d1566 1
a1566 1
load_index(char *dbfile, DB_ATTR * db_attr)
d1634 1
a1634 1
index_index(CA_DB * db)
d1654 1
a1654 1
save_index(const char *dbfile, const char *suffix, CA_DB * db)
d1789 1
a1789 1
free_index(CA_DB * db)
d1949 2
a1950 2
args_verify(char ***pargs, int *pargc, int *badarg, BIO * err,
    X509_VERIFY_PARAM ** pm)
d2084 1
a2084 1
bio_to_mem(unsigned char **out, int maxlen, BIO * in)
d2117 1
a2117 1
pkey_ctrl_string(EVP_PKEY_CTX * ctx, char *value)
d2137 1
a2137 1
nodes_print(BIO * out, const char *name, STACK_OF(X509_POLICY_NODE) * nodes)
d2154 1
a2154 1
policies_print(BIO * out, X509_STORE_CTX * ctx)
@


1.49
log
@Remove unused include.
@
text
@d1935 1
d1940 5
a1944 8
	if (ne_values)
		free(ne_values);
	if (ne_types)
		free(ne_types);
	if (mval)
		free(mval);
	if (buf)
		free(buf);
d2132 1
@


1.48
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@a114 1
#include <assert.h>
@


1.47
log
@less than jpake
@
text
@d114 4
a121 3
#include <ctype.h>
#include <errno.h>
#include <assert.h>
d124 3
a127 2
#include <openssl/x509.h>
#include <openssl/x509v3.h>
d130 1
d132 3
a134 1
#include <openssl/safestack.h>
d138 1
a141 4
#include <openssl/bn.h>

#include "apps.h"

@


1.46
log
@OpenBSD has_SC_CLK_TCK.

ok miod@@
@
text
@a2175 234
#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)

static JPAKE_CTX *
jpake_init(const char *us, const char *them,
    const char *secret)
{
	BIGNUM *p = NULL;
	BIGNUM *g = NULL;
	BIGNUM *q = NULL;
	BIGNUM *bnsecret = BN_new();
	JPAKE_CTX *ctx;

	/* Use a safe prime for p (that we found earlier) */
	BN_hex2bn(&p, "F9E5B365665EA7A05A9C534502780FEE6F1AB5BD4F49947FD036DBD7E905269AF46EF28B0FC07487EE4F5D20FB3C0AF8E700F3A2FA3414970CBED44FEDFF80CE78D800F184BB82435D137AADA2C6C16523247930A63B85661D1FC817A51ACD96168E95898A1F83A79FFB529368AA7833ABD1B0C3AEDDB14D2E1A2F71D99F763F");
	g = BN_new();
	BN_set_word(g, 2);
	q = BN_new();
	BN_rshift1(q, p);

	BN_bin2bn((const unsigned char *) secret, strlen(secret), bnsecret);

	ctx = JPAKE_CTX_new(us, them, p, g, q, bnsecret);
	BN_free(bnsecret);
	BN_free(q);
	BN_free(g);
	BN_free(p);

	return ctx;
}

static void
jpake_send_part(BIO * conn, const JPAKE_STEP_PART * p)
{
	BN_print(conn, p->gx);
	BIO_puts(conn, "\n");
	BN_print(conn, p->zkpx.gr);
	BIO_puts(conn, "\n");
	BN_print(conn, p->zkpx.b);
	BIO_puts(conn, "\n");
}

static void
jpake_send_step1(BIO * bconn, JPAKE_CTX * ctx)
{
	JPAKE_STEP1 s1;

	JPAKE_STEP1_init(&s1);
	JPAKE_STEP1_generate(&s1, ctx);
	jpake_send_part(bconn, &s1.p1);
	jpake_send_part(bconn, &s1.p2);
	(void) BIO_flush(bconn);
	JPAKE_STEP1_release(&s1);
}

static void
jpake_send_step2(BIO * bconn, JPAKE_CTX * ctx)
{
	JPAKE_STEP2 s2;

	JPAKE_STEP2_init(&s2);
	JPAKE_STEP2_generate(&s2, ctx);
	jpake_send_part(bconn, &s2);
	(void) BIO_flush(bconn);
	JPAKE_STEP2_release(&s2);
}

static void
jpake_send_step3a(BIO * bconn, JPAKE_CTX * ctx)
{
	JPAKE_STEP3A s3a;

	JPAKE_STEP3A_init(&s3a);
	JPAKE_STEP3A_generate(&s3a, ctx);
	BIO_write(bconn, s3a.hhk, sizeof s3a.hhk);
	(void) BIO_flush(bconn);
	JPAKE_STEP3A_release(&s3a);
}

static void
jpake_send_step3b(BIO * bconn, JPAKE_CTX * ctx)
{
	JPAKE_STEP3B s3b;

	JPAKE_STEP3B_init(&s3b);
	JPAKE_STEP3B_generate(&s3b, ctx);
	BIO_write(bconn, s3b.hk, sizeof s3b.hk);
	(void) BIO_flush(bconn);
	JPAKE_STEP3B_release(&s3b);
}

static void
readbn(BIGNUM ** bn, BIO * bconn)
{
	char buf[10240];
	int l;

	l = BIO_gets(bconn, buf, sizeof buf);
	assert(l > 0);
	assert(buf[l - 1] == '\n');
	buf[l - 1] = '\0';
	BN_hex2bn(bn, buf);
}

static void
jpake_receive_part(JPAKE_STEP_PART * p, BIO * bconn)
{
	readbn(&p->gx, bconn);
	readbn(&p->zkpx.gr, bconn);
	readbn(&p->zkpx.b, bconn);
}

static void
jpake_receive_step1(JPAKE_CTX * ctx, BIO * bconn)
{
	JPAKE_STEP1 s1;

	JPAKE_STEP1_init(&s1);
	jpake_receive_part(&s1.p1, bconn);
	jpake_receive_part(&s1.p2, bconn);
	if (!JPAKE_STEP1_process(ctx, &s1)) {
		ERR_print_errors(bio_err);
		exit(1);
	}
	JPAKE_STEP1_release(&s1);
}

static void
jpake_receive_step2(JPAKE_CTX * ctx, BIO * bconn)
{
	JPAKE_STEP2 s2;

	JPAKE_STEP2_init(&s2);
	jpake_receive_part(&s2, bconn);
	if (!JPAKE_STEP2_process(ctx, &s2)) {
		ERR_print_errors(bio_err);
		exit(1);
	}
	JPAKE_STEP2_release(&s2);
}

static void
jpake_receive_step3a(JPAKE_CTX * ctx, BIO * bconn)
{
	JPAKE_STEP3A s3a;
	int l;

	JPAKE_STEP3A_init(&s3a);
	l = BIO_read(bconn, s3a.hhk, sizeof s3a.hhk);
	assert(l == sizeof s3a.hhk);
	if (!JPAKE_STEP3A_process(ctx, &s3a)) {
		ERR_print_errors(bio_err);
		exit(1);
	}
	JPAKE_STEP3A_release(&s3a);
}

static void
jpake_receive_step3b(JPAKE_CTX * ctx, BIO * bconn)
{
	JPAKE_STEP3B s3b;
	int l;

	JPAKE_STEP3B_init(&s3b);
	l = BIO_read(bconn, s3b.hk, sizeof s3b.hk);
	assert(l == sizeof s3b.hk);
	if (!JPAKE_STEP3B_process(ctx, &s3b)) {
		ERR_print_errors(bio_err);
		exit(1);
	}
	JPAKE_STEP3B_release(&s3b);
}

void
jpake_client_auth(BIO * out, BIO * conn, const char *secret)
{
	JPAKE_CTX *ctx;
	BIO *bconn;

	BIO_puts(out, "Authenticating with JPAKE\n");

	ctx = jpake_init("client", "server", secret);

	bconn = BIO_new(BIO_f_buffer());
	BIO_push(bconn, conn);

	jpake_send_step1(bconn, ctx);
	jpake_receive_step1(ctx, bconn);
	jpake_send_step2(bconn, ctx);
	jpake_receive_step2(ctx, bconn);
	jpake_send_step3a(bconn, ctx);
	jpake_receive_step3b(ctx, bconn);

	BIO_puts(out, "JPAKE authentication succeeded, setting PSK\n");

	psk_key = BN_bn2hex(JPAKE_get_shared_key(ctx));

	BIO_pop(bconn);
	BIO_free(bconn);

	JPAKE_CTX_free(ctx);
}

void
jpake_server_auth(BIO * out, BIO * conn, const char *secret)
{
	JPAKE_CTX *ctx;
	BIO *bconn;

	BIO_puts(out, "Authenticating with JPAKE\n");

	ctx = jpake_init("server", "client", secret);

	bconn = BIO_new(BIO_f_buffer());
	BIO_push(bconn, conn);

	jpake_receive_step1(ctx, bconn);
	jpake_send_step1(bconn, ctx);
	jpake_receive_step2(ctx, bconn);
	jpake_send_step2(bconn, ctx);
	jpake_receive_step3a(ctx, bconn);
	jpake_send_step3b(bconn, ctx);

	BIO_puts(out, "JPAKE authentication succeeded, setting PSK\n");

	psk_key = BN_bn2hex(JPAKE_get_shared_key(ctx));

	BIO_pop(bconn);
	BIO_free(bconn);

	JPAKE_CTX_free(ctx);
}

#endif

@


1.45
log
@Nuke more defines - we have setvbuf() and _IONBF.

ok deraadt@@
@
text
@a2456 1
#if defined(_SC_CLK_TCK)	/* by means of unistd.h */
a2479 26
#else
#include <sys/time.h>
#include <sys/resource.h>

double
app_tminterval(int stop, int usertime)
{
	double ret = 0;
	struct rusage rus;
	struct timeval now;
	static struct timeval tmstart;

	if (usertime)
		getrusage(RUSAGE_SELF, &rus), now = rus.ru_utime;
	else
		gettimeofday(&now, NULL);

	if (stop == TM_START)
		tmstart = now;
	else
		ret = ((now.tv_sec + now.tv_usec * 1e-6) -
		    (tmstart.tv_sec + tmstart.tv_usec * 1e-6));

	return ret;
}
#endif
@


1.44
log
@remove crazy #undefs; ok jsing
@
text
@a617 2
#ifdef _IONBF
#ifndef OPENSSL_NO_SETVBUF_IONBF
a618 2
#endif				/* ndef OPENSSL_NO_SETVBUF_IONBF */
#endif
a707 2
#ifdef _IONBF
#ifndef OPENSSL_NO_SETVBUF_IONBF
a708 2
#endif				/* ndef OPENSSL_NO_SETVBUF_IONBF */
#endif
a783 2
#ifdef _IONBF
#ifndef OPENSSL_NO_SETVBUF_IONBF
a784 2
#endif				/* ndef OPENSSL_NO_SETVBUF_IONBF */
#endif
@


1.43
log
@NON_MAIN no longer means anything so remove it, along with APP_INIT.

ok miod@@
@
text
@a1385 1
#undef BSIZE
@


1.42
log
@Nuke the last of the windows related defines from the openssl apps.

ok deraadt@@
@
text
@a137 1
#define NON_MAIN
a138 1
#undef NON_MAIN
a159 2
int app_init(long mesgwin);

a270 9

#ifndef APP_INIT
int
app_init(long mesgwin)
{
	return (1);
}
#endif

@


1.41
log
@More KNF.
@
text
@a504 8
			/*
			 * Under _WIN32, which covers even Win64 and CE, file
			 * descriptors referenced by BIO_s_fd are not inherited
			 * by child process and therefore below is not an option.
			 * It could have been an option if bss_fd.c was operating
			 * on real Windows descriptors, such as those obtained
			 * with CreateFile.
			 */
@


1.40
log
@you must have S_ISDIR to play
@
text
@d151 4
a154 2
static int set_table_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL * in_tbl);
static int set_multi_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL * in_tbl);
d158 1
a158 2
static EVP_PKEY *
load_netscape_key(BIO * err, BIO * key, const char *file,
d180 1
a180 1
		    (strcmp(s, "PKCS12") == 0) || (strcmp(s, "pkcs12") == 0) ||
d219 1
a219 1
		arg->data = (char **) malloc(sizeof(char *) * arg->count);
d261 1
a261 1
				(*p != '\t') && (*p != '\n')))
d285 1
a285 1
int 
d320 1
a320 1
				((PW_CB_DATA *) UI_get0_user_data(ui))->password;
d344 1
a344 1
				    ((PW_CB_DATA *) UI_get0_user_data(ui))->password;
d383 1
a383 2
password_callback(char *buf, int bufsiz, int verify,
    PW_CB_DATA * cb_tmp)
d411 1
a411 2
		prompt = UI_construct_prompt(ui, "pass phrase",
		    prompt_info);
d459 1
d485 1
d491 2
a492 1
			BIO_printf(err, "Can't read environment variable %s\n", arg + 4);
d501 2
a502 1
				BIO_printf(err, "Can't open file %s\n", arg + 5);
d519 3
a521 1
				BIO_printf(err, "Can't access file descriptor %s\n", arg + 3);
d537 2
a538 1
			BIO_printf(err, "Invalid password argument \"%s\"\n", arg);
d564 1
d592 1
d620 1
d658 2
a659 1
		nx = ASN1_item_d2i_bio(ASN1_ITEM_rptr(NETSCAPE_X509), cert, NULL);
d664 1
a664 1
			    nx->header->length) != 0)) {
d666 2
a667 1
			BIO_printf(err, "Error reading header on certificate\n");
d678 1
a678 1
			NULL, &x, NULL))
d685 1
d719 2
a720 1
				BIO_printf(err, "cannot load %s from engine\n", key_descrip);
d757 2
a758 2
			(pem_password_cb *) password_callback, &cb_data,
			&pkey, NULL, NULL))
d820 1
a820 2
		BIO_printf(err, "Error opening %s %s\n",
		    key_descrip, file);
d867 1
d913 1
d1007 2
a1008 2
load_certs(BIO * err, const char *file, int format, const char *pass, ENGINE * e,
    const char *desc)
d1011 1
d1022 1
d1125 1
d1160 2
a1161 1
set_multi_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL * in_tbl)
d1166 1
d1180 2
a1181 1
set_table_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL * in_tbl)
d1185 1
a1186 1

d1240 1
d1279 1
d1331 1
d1377 4
a1380 2
	for (aa = a[DB_serial]; *aa == '0'; aa++);
	for (bb = b[DB_serial]; *bb == '0'; bb++);
d1443 2
a1444 1
			BIO_printf(bio_err, "error converting number from bin to BIGNUM\n");
d1453 1
d1483 2
a1484 1
		n = snprintf(buf[0], sizeof buf[0], "%s.%s", serialfile, suffix);
d1502 2
a1503 1
		BIO_printf(bio_err, "error converting serial to ASN.1 format\n");
d1513 1
d1536 3
a1538 4
	snprintf(buf[0], sizeof buf[0], "%s.%s",
	    serialfile, new_suffix);
	snprintf(buf[1], sizeof buf[1], "%s.%s",
	    serialfile, old_suffix);
d1543 4
a1546 3
	if (rename(serialfile, buf[1]) < 0 && errno != ENOENT && errno != ENOTDIR) {
		BIO_printf(bio_err,
		    "unable to rename %s to %s\n",
d1551 1
d1556 1
d1558 1
a1558 2
		BIO_printf(bio_err,
		    "unable to rename %s to %s\n",
d1565 1
d1575 1
d1625 2
a1626 2
			    "error on line %ld of db attribute file '%s'\n"
			    ,errorline, buf[0]);
d1649 2
a1650 1
			BIO_printf(bio_err, "DEBUG[load_index]: unique_subject = \"%s\"\n", p);
d1655 1
d1670 1
a1670 2
		LHASH_HASH_FN(index_serial),
		LHASH_COMP_FN(index_serial))) {
d1678 1
a1678 1
		LHASH_HASH_FN(index_name), LHASH_COMP_FN(index_name))) {
d1705 1
d1709 1
d1722 1
d1726 1
d1737 1
d1757 5
a1761 8
	snprintf(buf[2], sizeof buf[2], "%s.attr.%s",
	    dbfile, new_suffix);
	snprintf(buf[0], sizeof buf[0], "%s.%s",
	    dbfile, new_suffix);
	snprintf(buf[1], sizeof buf[1], "%s.%s",
	    dbfile, old_suffix);
	snprintf(buf[3], sizeof buf[3], "%s.attr.%s",
	    dbfile, old_suffix);
d1766 1
d1768 1
a1768 2
		BIO_printf(bio_err,
		    "unable to rename %s to %s\n",
d1773 1
d1778 1
d1780 1
a1780 2
		BIO_printf(bio_err,
		    "unable to rename %s to %s\n",
d1786 1
d1791 1
d1793 1
a1793 2
		BIO_printf(bio_err,
		    "unable to rename %s to %s\n",
d1800 1
d1805 1
d1807 1
a1807 2
		BIO_printf(bio_err,
		    "unable to rename %s to %s\n",
d1835 1
d1950 3
a1952 1
			BIO_printf(bio_err, "Subject Attribute %s has no known NID, skipped\n", ne_types[i]);
d1959 2
a1960 1
		if (!X509_NAME_add_entry_by_NID(n, nid, chtype, (unsigned char *) ne_values[i], -1, -1, mval[i]))
d1984 2
a1985 2
args_verify(char ***pargs, int *pargc,
    int *badarg, BIO * err, X509_VERIFY_PARAM ** pm)
d1994 1
d2124 1
d2156 1
d2175 1
d2193 1
a2540 1

@


1.39
log
@ReadFile() and GetStdHandle() are not very POSIX.
ok beck jsing
@
text
@d112 2
a117 1
#include <sys/types.h>
d122 1
a2493 9
/* app_isdir section */
#include <sys/stat.h>
#ifndef S_ISDIR
#if defined(_S_IFMT) && defined(_S_IFDIR)
#define S_ISDIR(a)   (((a) & _S_IFMT) == _S_IFDIR)
#else
#define S_ISDIR(a)   (((a) & S_IFMT) == S_IFDIR)
#endif
#endif
a2497 1
#if defined(S_ISDIR)
d2502 1
a2502 5
	else
		return -1;
#else
	 return -1;
#endif
@


1.38
log
@truncation check some snprintf calls (over-cautiously in case)
ok jsing beck
@
text
@a2515 37

/* raw_read|write section */
#if defined(_WIN32) && defined(STD_INPUT_HANDLE)
int
raw_read_stdin(void *buf, int siz)
{
	DWORD n;
	if (ReadFile(GetStdHandle(STD_INPUT_HANDLE), buf, siz, &n, NULL))
		return (n);
	else
		return (-1);
}
#else
int
raw_read_stdin(void *buf, int siz)
{
	return read(fileno(stdin), buf, siz);
}
#endif

#if defined(_WIN32) && defined(STD_OUTPUT_HANDLE)
int
raw_write_stdout(const void *buf, int siz)
{
	DWORD n;
	if (WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), buf, siz, &n, NULL))
		return (n);
	else
		return (-1);
}
#else
int
raw_write_stdout(const void *buf, int siz)
{
	return write(fileno(stdout), buf, siz);
}
#endif
@


1.37
log
@Repair some indent to be more KNF, and break instead of fallthrough to
default which does break
@
text
@d1439 1
a1439 1
	int ret = 0;
d1452 1
a1452 1
		strlcpy(buf[0], serialfile, BSIZE);
d1454 5
a1458 1
		snprintf(buf[0], sizeof buf[0], "%s.%s", serialfile, suffix);
@


1.36
log
@unifdef ENOTDIR, everyone has it
@
text
@d313 2
a314 2
			case UIT_PROMPT:
			case UIT_VERIFY:
d323 1
d337 2
a338 2
			case UIT_PROMPT:
			case UIT_VERIFY:
d341 1
a341 1
				((PW_CB_DATA *) UI_get0_user_data(ui))->password;
d345 1
d1375 5
a1379 5
static 
IMPLEMENT_LHASH_HASH_FN(index_serial, OPENSSL_CSTRING)
	static IMPLEMENT_LHASH_COMP_FN(index_serial, OPENSSL_CSTRING)
	static IMPLEMENT_LHASH_HASH_FN(index_name, OPENSSL_CSTRING)
	static IMPLEMENT_LHASH_COMP_FN(index_name, OPENSSL_CSTRING)
d1383 2
a1384 2
	BIGNUM *
	 load_serial(char *serialfile, int create, ASN1_INTEGER ** retai)
@


1.35
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d1506 1
a1506 5
	if (rename(serialfile, buf[1]) < 0 && errno != ENOENT
#ifdef ENOTDIR
	    && errno != ENOTDIR
#endif
	    ) {
d1722 1
a1722 5
	if (rename(dbfile, buf[1]) < 0 && errno != ENOENT
#ifdef ENOTDIR
	    && errno != ENOTDIR
#endif
	    ) {
d1745 1
a1745 5
	if (rename(buf[4], buf[3]) < 0 && errno != ENOENT
#ifdef ENOTDIR
	    && errno != ENOTDIR
#endif
	    ) {
@


1.34
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d1452 1
a1452 1
		(void) snprintf(buf[0], sizeof buf[0], "%s.%s", serialfile, suffix);
d1498 1
a1498 1
	(void) snprintf(buf[0], sizeof buf[0], "%s.%s",
d1500 1
a1500 1
	(void) snprintf(buf[1], sizeof buf[1], "%s.%s",
d1583 1
a1583 1
	(void) snprintf(buf[0], sizeof buf[0], "%s.attr", dbfile);
d1664 3
a1666 3
	(void) snprintf(buf[2], sizeof buf[2], "%s.attr", dbfile);
	(void) snprintf(buf[1], sizeof buf[1], "%s.attr.%s", dbfile, suffix);
	(void) snprintf(buf[0], sizeof buf[0], "%s.%s", dbfile, suffix);
d1713 2
a1714 2
	(void) snprintf(buf[4], sizeof buf[4], "%s.attr", dbfile);
	(void) snprintf(buf[2], sizeof buf[2], "%s.attr.%s",
d1716 1
a1716 1
	(void) snprintf(buf[0], sizeof buf[0], "%s.%s",
d1718 1
a1718 1
	(void) snprintf(buf[1], sizeof buf[1], "%s.%s",
d1720 1
a1720 1
	(void) snprintf(buf[3], sizeof buf[3], "%s.attr.%s",
@


1.33
log
@use the portable construct around asprintf; pointed out by halex
@
text
@d201 1
a201 1
	BUF_strlcpy(out, p, size);
d1450 1
a1450 1
		BUF_strlcpy(buf[0], serialfile, BSIZE);
@


1.32
log
@Use asprintf() for generating path, instead of multiple
return-value-not-checked strlcpy and strlcat
@
text
@d1329 2
a1330 1
	asprintf(&p, "%s/openssl.cnf", t);
@


1.31
log
@KaboomNF
@
text
@a1326 1
	size_t len;
d1329 1
a1329 6
	len = strlen(t) + strlen(OPENSSL_CONF) + 2;
	p = malloc(len);
	BUF_strlcpy(p, t, len);
	BUF_strlcat(p, "/", len);
	BUF_strlcat(p, OPENSSL_CONF, len);

@


1.30
log
@unistd.h exposed after -Wall after e_os.h stops doing so; spotted by matthew
@
text
@d149 2
a150 2
static int set_table_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl);
static int set_multi_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl);
d154 2
a155 1
static EVP_PKEY *load_netscape_key(BIO *err, BIO *key, const char *file,
d177 1
a177 1
	    (strcmp(s, "PKCS12") == 0) || (strcmp(s, "pkcs12") == 0) ||
d205 1
a205 1
chopup_args(ARGS *arg, char *buf, int *argc, char **argv[])
d216 1
a216 1
		arg->data = (char **)malloc(sizeof(char *)*arg->count);
d236 2
a237 2
			tmp_p = (char **)realloc(arg->data,
			    sizeof(char *)*tlen);
d249 4
a252 4
		if ((*p == '\'') || (*p == '\"')) /* scan for closing quote */
		{
			i= *(p++);
			arg->data[num - 1]++; /* jump over quote */
d258 1
a258 1
			    (*p != '\t') && (*p != '\n')))
d282 2
a283 1
int dump_cert_text (BIO *out, X509 *x)
d302 1
a302 1
ui_open(UI *ui)
d304 1
a304 1
	return UI_method_get_opener(UI_OpenSSL())(ui);
d308 1
a308 1
ui_read(UI *ui, UI_STRING *uis)
d313 2
a314 2
		case UIT_PROMPT:
		case UIT_VERIFY:
d317 1
a317 1
				    ((PW_CB_DATA *)UI_get0_user_data(ui))->password;
d327 1
a327 1
	return UI_method_get_reader(UI_OpenSSL())(ui, uis);
d331 1
a331 1
ui_write(UI *ui, UI_STRING *uis)
d336 2
a337 2
		case UIT_PROMPT:
		case UIT_VERIFY:
d340 1
a340 1
				    ((PW_CB_DATA *)UI_get0_user_data(ui))->password;
d348 1
a348 1
	return UI_method_get_writer(UI_OpenSSL())(ui, uis);
d352 1
a352 1
ui_close(UI *ui)
d354 1
a354 1
	return UI_method_get_closer(UI_OpenSSL())(ui);
d379 1
a379 1
    PW_CB_DATA *cb_tmp)
d385 1
a385 1
	PW_CB_DATA *cb_data = (PW_CB_DATA *)cb_tmp;
a392 1

a399 1

d417 1
a417 1
			buff = (char *)malloc(bufsiz);
d428 1
a428 1
			OPENSSL_cleanse(buff, (unsigned int)bufsiz);
a430 1

d436 1
a436 1
			OPENSSL_cleanse(buf, (unsigned int)bufsiz);
d441 1
a441 1
			OPENSSL_cleanse(buf, (unsigned int)bufsiz);
d450 1
a450 1
static char *app_get_pass(BIO *err, char *arg, int keepbio);
d453 1
a453 1
app_passwd(BIO *err, char *arg1, char *arg2, char **pass1, char **pass2)
d476 1
a476 1
app_get_pass(BIO *err, char *arg, int keepbio)
d498 8
a505 8
		/*
		 * Under _WIN32, which covers even Win64 and CE, file
		 * descriptors referenced by BIO_s_fd are not inherited
		 * by child process and therefore below is not an option.
		 * It could have been an option if bss_fd.c was operating
		 * on real Windows descriptors, such as those obtained
		 * with CreateFile.
		 */
d515 4
a518 1
			/* Can't do BIO_gets on an fd BIO so add a buffering BIO */
d548 1
a548 1
add_oid_section(BIO *err, CONF *conf)
d551 1
a551 1
	STACK_OF(CONF_VALUE) *sktmp;
d574 2
a575 2
load_pkcs12(BIO *err, BIO *in, const char *desc, pem_password_cb *pem_cb,
    void *cb_data, EVP_PKEY **pkey, X509 **cert, STACK_OF(X509) **ca)
d591 1
a591 1
			pem_cb = (pem_password_cb *)password_callback;
d615 1
a615 1
load_cert(BIO *err, const char *file, int format, const char *pass, ENGINE *e,
a624 1

d627 1
a627 1
# ifndef OPENSSL_NO_SETVBUF_IONBF
d629 1
a629 1
# endif /* ndef OPENSSL_NO_SETVBUF_IONBF */
d649 2
a650 2
		if ((strncmp(NETSCAPE_CERT_HDR, (char *)nx->header->data,
		    nx->header->length) != 0)) {
d660 1
a660 1
		    (pem_password_cb *)password_callback, NULL);
d663 1
a663 1
		    NULL, &x, NULL))
d681 2
a682 2
load_key(BIO *err, const char *file, int format, int maybe_stdin,
    const char *pass, ENGINE *e, const char *key_descrip)
d717 1
a717 1
# ifndef OPENSSL_NO_SETVBUF_IONBF
d719 1
a719 1
# endif /* ndef OPENSSL_NO_SETVBUF_IONBF */
d732 1
a732 1
		    (pem_password_cb *)password_callback, &cb_data);
d740 2
a741 2
		    (pem_password_cb *)password_callback, &cb_data,
		    &pkey, NULL, NULL))
d748 1
a748 1
		pkey = b2i_PVK_bio(key, (pem_password_cb *)password_callback,
d766 2
a767 2
load_pubkey(BIO *err, const char *file, int format, int maybe_stdin,
    const char *pass, ENGINE *e, const char *key_descrip)
d797 1
a797 1
# ifndef OPENSSL_NO_SETVBUF_IONBF
d799 1
a799 1
# endif /* ndef OPENSSL_NO_SETVBUF_IONBF */
d825 1
a825 1
		    (pem_password_cb *)password_callback, &cb_data);
d837 1
a837 1
		    (pem_password_cb *)password_callback, &cb_data);
d861 1
a861 1
load_netscape_key(BIO *err, BIO *key, const char *file,
d866 1
a866 1
	RSA	*rsa;
d876 1
a876 1
		if (!BUF_MEM_grow_clean(buf, size + 1024*10))
d878 1
a878 1
		i = BIO_read(key, &(buf->data[size]), 1024*10);
d888 2
a889 2
	p = (unsigned char *)buf->data;
	rsa = d2i_RSA_NET(NULL, &p, (long)size, NULL,
d901 1
a901 1
#endif /* ndef OPENSSL_NO_RC4 */
d904 3
a906 3
load_certs_crls(BIO *err, const char *file, int format, const char *pass,
    ENGINE *e, const char *desc, STACK_OF(X509) **pcerts,
    STACK_OF(X509_CRL) **pcrls)
d910 1
a910 1
	STACK_OF(X509_INFO) *xis = NULL;
a921 1

a932 1

d934 1
a934 1
	    (pem_password_cb *)password_callback, &cb_data);
a942 1

a947 1

d949 1
a949 1
		xi = sk_X509_INFO_value (xis, i);
d989 1
a989 1
load_certs(BIO *err, const char *file, int format, const char *pass, ENGINE *e,
d992 1
a992 1
	STACK_OF(X509) *certs;
d999 1
a999 1
load_crls(BIO *err, const char *file, int format, const char *pass, ENGINE *e,
d1002 1
a1002 1
	STACK_OF(X509_CRL) *crls;
d1025 19
a1043 19
		{ "compatible", X509_FLAG_COMPAT, 0xffffffffl},
		{ "ca_default", X509_FLAG_CA, 0xffffffffl},
		{ "no_header", X509_FLAG_NO_HEADER, 0},
		{ "no_version", X509_FLAG_NO_VERSION, 0},
		{ "no_serial", X509_FLAG_NO_SERIAL, 0},
		{ "no_signame", X509_FLAG_NO_SIGNAME, 0},
		{ "no_validity", X509_FLAG_NO_VALIDITY, 0},
		{ "no_subject", X509_FLAG_NO_SUBJECT, 0},
		{ "no_issuer", X509_FLAG_NO_ISSUER, 0},
		{ "no_pubkey", X509_FLAG_NO_PUBKEY, 0},
		{ "no_extensions", X509_FLAG_NO_EXTENSIONS, 0},
		{ "no_sigdump", X509_FLAG_NO_SIGDUMP, 0},
		{ "no_aux", X509_FLAG_NO_AUX, 0},
		{ "no_attributes", X509_FLAG_NO_ATTRIBUTES, 0},
		{ "ext_default", X509V3_EXT_DEFAULT, X509V3_EXT_UNKNOWN_MASK},
		{ "ext_error", X509V3_EXT_ERROR_UNKNOWN, X509V3_EXT_UNKNOWN_MASK},
		{ "ext_parse", X509V3_EXT_PARSE_UNKNOWN, X509V3_EXT_UNKNOWN_MASK},
		{ "ext_dump", X509V3_EXT_DUMP_UNKNOWN, X509V3_EXT_UNKNOWN_MASK},
		{ NULL, 0, 0}
d1052 28
a1079 28
		{ "esc_2253", ASN1_STRFLGS_ESC_2253, 0},
		{ "esc_ctrl", ASN1_STRFLGS_ESC_CTRL, 0},
		{ "esc_msb", ASN1_STRFLGS_ESC_MSB, 0},
		{ "use_quote", ASN1_STRFLGS_ESC_QUOTE, 0},
		{ "utf8", ASN1_STRFLGS_UTF8_CONVERT, 0},
		{ "ignore_type", ASN1_STRFLGS_IGNORE_TYPE, 0},
		{ "show_type", ASN1_STRFLGS_SHOW_TYPE, 0},
		{ "dump_all", ASN1_STRFLGS_DUMP_ALL, 0},
		{ "dump_nostr", ASN1_STRFLGS_DUMP_UNKNOWN, 0},
		{ "dump_der", ASN1_STRFLGS_DUMP_DER, 0},
		{ "compat", XN_FLAG_COMPAT, 0xffffffffL},
		{ "sep_comma_plus", XN_FLAG_SEP_COMMA_PLUS, XN_FLAG_SEP_MASK},
		{ "sep_comma_plus_space", XN_FLAG_SEP_CPLUS_SPC, XN_FLAG_SEP_MASK},
		{ "sep_semi_plus_space", XN_FLAG_SEP_SPLUS_SPC, XN_FLAG_SEP_MASK},
		{ "sep_multiline", XN_FLAG_SEP_MULTILINE, XN_FLAG_SEP_MASK},
		{ "dn_rev", XN_FLAG_DN_REV, 0},
		{ "nofname", XN_FLAG_FN_NONE, XN_FLAG_FN_MASK},
		{ "sname", XN_FLAG_FN_SN, XN_FLAG_FN_MASK},
		{ "lname", XN_FLAG_FN_LN, XN_FLAG_FN_MASK},
		{ "align", XN_FLAG_FN_ALIGN, 0},
		{ "oid", XN_FLAG_FN_OID, XN_FLAG_FN_MASK},
		{ "space_eq", XN_FLAG_SPC_EQ, 0},
		{ "dump_unknown", XN_FLAG_DUMP_UNKNOWN_FIELDS, 0},
		{ "RFC2253", XN_FLAG_RFC2253, 0xffffffffL},
		{ "oneline", XN_FLAG_ONELINE, 0xffffffffL},
		{ "multiline", XN_FLAG_MULTILINE, 0xffffffffL},
		{ "ca_default", XN_FLAG_MULTILINE, 0xffffffffL},
		{ NULL, 0, 0}
d1099 1
a1099 1
copy_extensions(X509 *x, X509_REQ *req, int copy_type)
d1101 1
a1101 1
	STACK_OF(X509_EXTENSION) *exts = NULL;
d1139 1
a1139 1
set_multi_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl)
d1141 1
a1141 1
	STACK_OF(CONF_VALUE) *vals;
d1157 1
a1157 1
set_table_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl)
d1169 2
a1170 1
	} else c = 1;
d1186 1
a1186 1
print_name(BIO *out, const char *title, X509_NAME *nm, unsigned long lflags)
d1212 1
a1212 1
setup_verify(BIO *bp, char *CAfile, char *CApath)
d1251 1
a1251 1
try_load_engine(BIO *err, const char *engine, int debug)
d1265 1
a1265 1
setup_engine(BIO *err, const char *engine, int debug)
a1291 1

d1302 1
a1302 1
load_config(BIO *err, CONF *cnf)
d1340 1
a1340 1
index_serial_hash(const OPENSSL_CSTRING *a)
d1351 1
a1351 1
index_serial_cmp(const OPENSSL_CSTRING *a, const OPENSSL_CSTRING *b)
d1355 2
a1356 4
	for (aa = a[DB_serial]; *aa == '0'; aa++)
		;
	for (bb = b[DB_serial]; *bb == '0'; bb++)
		;
d1367 1
a1367 1
index_name_hash(const OPENSSL_CSTRING *a)
d1373 1
a1373 1
index_name_cmp(const OPENSSL_CSTRING *a, const OPENSSL_CSTRING *b)
d1378 5
a1382 5
static IMPLEMENT_LHASH_HASH_FN(index_serial, OPENSSL_CSTRING)
static IMPLEMENT_LHASH_COMP_FN(index_serial, OPENSSL_CSTRING)
static IMPLEMENT_LHASH_HASH_FN(index_name, OPENSSL_CSTRING)
static IMPLEMENT_LHASH_COMP_FN(index_name, OPENSSL_CSTRING)

d1386 2
a1387 2
BIGNUM *
load_serial(char *serialfile, int create, ASN1_INTEGER **retai)
a1401 1

d1437 2
a1438 2
save_serial(char *serialfile, char *suffix, BIGNUM *serial,
    ASN1_INTEGER **retai)
a1453 1

a1469 1

a1502 1

d1515 1
a1515 1
	) {
d1540 1
a1540 1
rand_serial(BIGNUM *b, ASN1_INTEGER *ai)
d1567 1
a1567 1
load_index(char *dbfile, DB_ATTR *db_attr)
d1593 2
a1594 2
			"error on line %ld of db attribute file '%s'\n"
			, errorline, buf[0]);
a1600 1

a1604 1

a1621 1

d1633 1
a1633 1
index_index(CA_DB *db)
d1636 2
a1637 2
	    LHASH_HASH_FN(index_serial),
	    LHASH_COMP_FN(index_serial))) {
a1642 1

d1645 1
a1645 1
	    LHASH_HASH_FN(index_name), LHASH_COMP_FN(index_name))) {
d1654 1
a1654 1
save_index(const char *dbfile, const char *suffix, CA_DB *db)
a1663 1

a1668 1

a1717 1

d1735 1
a1735 1
	) {
d1762 1
a1762 1
	) {
d1792 1
a1792 1
free_index(CA_DB *db)
d1807 5
a1811 5
		case 'f': /* false */
		case 'F': /* FALSE */
		case 'n': /* no */
		case 'N': /* NO */
		case '0': /* 0 */
d1814 5
a1818 5
		case 't': /* true */
		case 'T': /* TRUE */
		case 'y': /* yes */
		case 'Y': /* YES */
		case '1': /* 1 */
d1836 4
a1839 1
	size_t buflen = strlen(subject)+1; /* to copy the types and values into. due to escaping, the copy can only become shorter */
d1841 4
a1844 4
	size_t max_ne = buflen / 2 + 1; /* maximum number of name elements */
	char **ne_types = malloc(max_ne * sizeof (char *));
	char **ne_values = malloc(max_ne * sizeof (char *));
	int *mval = malloc (max_ne * sizeof (int));
a1855 1

d1860 1
a1860 1
	sp++; /* skip leading / */
d1869 2
a1870 2
			if (*sp == '\\') /* is there anything to escape in the type...? */
			{
a1921 1

d1926 1
a1926 2

		if (!X509_NAME_add_entry_by_NID(n, nid, chtype, (unsigned char*)ne_values[i], -1, -1, mval[i]))
d1951 1
a1951 1
    int *badarg, BIO *err, X509_VERIFY_PARAM **pm)
d2003 4
a2006 2
			/* interpret the -attime argument as seconds since
			 * Epoch */
d2022 1
a2022 1
		flags |=  X509_V_FLAG_CRL_CHECK;
d2024 1
a2024 1
		flags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;
a2051 1

a2055 1

d2084 1
a2084 1
bio_to_mem(unsigned char **out, int maxlen, BIO *in)
d2109 1
a2109 1
	ret = BIO_get_mem_data(mem, (char **)out);
d2116 1
a2116 1
pkey_ctrl_string(EVP_PKEY_CTX *ctx, char *value)
d2134 1
a2134 1
nodes_print(BIO *out, const char *name, STACK_OF(X509_POLICY_NODE) *nodes)
d2150 1
a2150 1
policies_print(BIO *out, X509_STORE_CTX *ctx)
d2190 1
a2190 1
	BN_bin2bn((const unsigned char *)secret, strlen(secret), bnsecret);
d2202 1
a2202 1
jpake_send_part(BIO *conn, const JPAKE_STEP_PART *p)
d2213 1
a2213 1
jpake_send_step1(BIO *bconn, JPAKE_CTX *ctx)
d2221 1
a2221 1
	(void)BIO_flush(bconn);
d2226 1
a2226 1
jpake_send_step2(BIO *bconn, JPAKE_CTX *ctx)
d2233 1
a2233 1
	(void)BIO_flush(bconn);
d2238 1
a2238 1
jpake_send_step3a(BIO *bconn, JPAKE_CTX *ctx)
d2245 1
a2245 1
	(void)BIO_flush(bconn);
d2250 1
a2250 1
jpake_send_step3b(BIO *bconn, JPAKE_CTX *ctx)
d2257 1
a2257 1
	(void)BIO_flush(bconn);
d2262 1
a2262 1
readbn(BIGNUM **bn, BIO *bconn)
d2275 1
a2275 1
jpake_receive_part(JPAKE_STEP_PART *p, BIO *bconn)
d2283 1
a2283 1
jpake_receive_step1(JPAKE_CTX *ctx, BIO *bconn)
d2298 1
a2298 1
jpake_receive_step2(JPAKE_CTX *ctx, BIO *bconn)
d2312 1
a2312 1
jpake_receive_step3a(JPAKE_CTX *ctx, BIO *bconn)
d2328 1
a2328 1
jpake_receive_step3b(JPAKE_CTX *ctx, BIO *bconn)
d2344 1
a2344 1
jpake_client_auth(BIO *out, BIO *conn, const char *secret)
d2374 1
a2374 1
jpake_server_auth(BIO *out, BIO *conn, const char *secret)
d2444 2
a2445 1
#endif  /* !OPENSSL_NO_TLSEXT && !OPENSSL_NO_NEXTPROTONEG */
d2458 4
a2461 4
	double		ret = 0;
	struct tms	rus;
	clock_t		now = times(&rus);
	static clock_t	tmstart;
d2470 1
a2470 1
		ret = (now - tmstart)/(double)tck;
d2483 3
a2485 3
	double		ret = 0;
	struct rusage	rus;
	struct timeval	now;
d2506 5
a2510 5
# if defined(_S_IFMT) && defined(_S_IFDIR)
#  define S_ISDIR(a)   (((a) & _S_IFMT) == _S_IFDIR)
# else
#  define S_ISDIR(a)   (((a) & S_IFMT) == S_IFDIR)
# endif
d2524 1
a2524 1
	return -1;
@


1.29
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d120 1
@


1.28
log
@lots of ifdef cleanup
@
text
@d214 1
a214 1
		arg->data = (char **)OPENSSL_malloc(sizeof(char *)*arg->count);
d234 1
a234 1
			tmp_p = (char **)OPENSSL_realloc(arg->data,
d287 1
a287 1
	OPENSSL_free(p);
d293 1
a293 1
	OPENSSL_free(p);
d416 1
a416 1
			buff = (char *)OPENSSL_malloc(bufsiz);
d428 1
a428 1
			OPENSSL_free(buff);
d445 1
a445 1
		OPENSSL_free(prompt);
d1203 1
a1203 1
		OPENSSL_free(buf);
d1333 1
a1333 1
	p = OPENSSL_malloc(len);
d1610 1
a1610 1
	if ((retdb = OPENSSL_malloc(sizeof(CA_DB))) == NULL) {
d1812 1
a1812 1
		OPENSSL_free(db);
d1852 1
a1852 1
	char *buf = OPENSSL_malloc(buflen);
d1854 3
a1856 3
	char **ne_types = OPENSSL_malloc(max_ne * sizeof (char *));
	char **ne_values = OPENSSL_malloc(max_ne * sizeof (char *));
	int *mval = OPENSSL_malloc (max_ne * sizeof (int));
d1945 4
a1948 4
	OPENSSL_free(ne_values);
	OPENSSL_free(ne_types);
	OPENSSL_free(buf);
	OPENSSL_free(mval);
d1954 1
a1954 1
		OPENSSL_free(ne_values);
d1956 1
a1956 1
		OPENSSL_free(ne_types);
d1958 1
a1958 1
		OPENSSL_free(mval);
d1960 1
a1960 1
		OPENSSL_free(buf);
d2144 1
a2144 1
	OPENSSL_free(stmp);
d2440 1
a2440 1
	out = OPENSSL_malloc(strlen(in) + 1);
d2447 1
a2447 1
				OPENSSL_free(out);
@


1.27
log
@repair knf
@
text
@a114 1
#if !defined(OPENSSL_SYSNAME_WIN32) && !defined(NETWARE_CLIB)
a115 1
#endif
a133 3
#ifndef OPENSSL_NO_JPAKE
#include <openssl/jpake.h>
#endif
a138 4
#ifdef _WIN32
static int WIN32_rename(const char *from, const char *to);
#define rename(from,to) WIN32_rename((from),(to))
#endif
a157 92
#ifdef undef /* never finished - probably never will be :-) */
int
args_from_file(char *file, int *argc, char **argv[])
{
	FILE *fp;
	int num, i;
	unsigned int len;
	static char *buf = NULL;
	static char **arg = NULL;
	char *p;

	fp = fopen(file, "r");
	if (fp == NULL)
		return (0);

	if (fseek(fp, 0, SEEK_END) == 0)
		len = ftell(fp), rewind(fp);
	else
		len = -1;
	if (len <= 0) {
		fclose(fp);
		return (0);
	}

	*argc = 0;
	*argv = NULL;

	if (buf != NULL)
		OPENSSL_free(buf);
	buf = (char *)OPENSSL_malloc(len + 1);
	if (buf == NULL)
		return (0);

	len = fread(buf, 1, len, fp);
	if (len <= 1)
		return (0);
	buf[len] = '\0';

	i = 0;
	for (p = buf; *p; p++)
		if (*p == '\n')
			i++;
	if (arg != NULL)
		OPENSSL_free(arg);
	arg = (char **)OPENSSL_malloc(sizeof(char *)*(i*2));

	*argv = arg;
	num = 0;
	p = buf;
	for (;;) {
		if (!*p)
			break;
		if (*p == '#') /* comment line */
		{
			while (*p && (*p != '\n'))
				p++;
			continue;
		}
		/* else we have a line */
		*(arg++) = p;
		num++;
		while (*p && ((*p != ' ') && (*p != '\t') && (*p != '\n')))
			p++;
		if (!*p)
			break;
		if (*p == '\n') {
			*(p++) = '\0';
			continue;
		}
		/* else it is a tab or space */
		p++;
		while (*p && ((*p == ' ') || (*p == '\t') || (*p == '\n')))
			p++;
		if (!*p)
			break;
		if (*p == '\n') {
			p++;
			continue;
		}
		*(arg++) = p++;
		num++;
		while (*p && (*p != '\n'))
			p++;
		if (!*p)
			break;
		/* else *p == '\n' */
		*(p++) = '\0';
	}
	*argc = num;
	return (1);
}
#endif
a188 38
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16) || defined(OPENSSL_SYS_NETWARE)
void
program_name(char *in, char *out, int size)
{
	int i, n;
	char *p = NULL;

	n = strlen(in);
	/* find the last '/', '\' or ':' */
	for (i = n - 1; i > 0; i--) {
		if ((in[i] == '/') || (in[i] == '\\') || (in[i] == ':')) {
			p = &(in[i + 1]);
			break;
		}
	}
	if (p == NULL)
		p = in;
	n = strlen(p);

	/* strip off trailing .exe if present. */
	if ((n > 4) && (p[n - 4] == '.') &&
	    ((p[n - 3] == 'e') || (p[n - 3] == 'E')) &&
	    ((p[n - 2] == 'x') || (p[n - 2] == 'X')) &&
	    ((p[n - 1] == 'e') || (p[n - 1] == 'E')))
		n -= 4;

	if (n > size - 1)
		n = size - 1;

	for (i = 0; i < n; i++) {
		if ((p[i] >= 'A') && (p[i] <= 'Z'))
			out[i] = p[i] - 'A' + 'a';
		else
			out[i] = p[i];
	}
	out[n] = '\0';
}
#else
a200 1
#endif
a497 1
#if !defined(_WIN32)
a517 1
#endif
a2463 59
#if defined(_WIN32)
# ifdef fileno
#  undef fileno
#  define fileno(a) (int)_fileno(a)
# endif

# include <windows.h>
# include <tchar.h>

static int
WIN32_rename(const char *from, const char *to)
{
	TCHAR  *tfrom = NULL, *tto;
	DWORD	err;
	int	ret = 0;

	if (sizeof(TCHAR) == 1) {
		tfrom = (TCHAR *)from;
		tto = (TCHAR *)to;
	}
	else	/* UNICODE path */
	{
		size_t i, flen = strlen(from) + 1, tlen = strlen(to) + 1;
		tfrom = (TCHAR *)malloc(sizeof(TCHAR)*(flen + tlen));
		if (tfrom == NULL)
			goto err;
		tto = tfrom + flen;
#if !defined(_WIN32_WCE) || _WIN32_WCE>=101
		if (!MultiByteToWideChar(CP_ACP, 0, from, flen, (WCHAR *)tfrom, flen))
#endif
		for (i = 0;i < flen;i++)	tfrom[i] = (TCHAR)from[i];
#if !defined(_WIN32_WCE) || _WIN32_WCE>=101
		if (!MultiByteToWideChar(CP_ACP, 0, to,  tlen, (WCHAR *)tto,  tlen))
#endif
		for (i = 0;i < tlen;i++)	tto[i] = (TCHAR)to[i];
		}

		if (MoveFile(tfrom, tto))
			goto ok;
	err = GetLastError();
	if (err == ERROR_ALREADY_EXISTS || err == ERROR_FILE_EXISTS) {
		if (DeleteFile(tto) && MoveFile(tfrom, tto))
			goto ok;
		err = GetLastError();
	}
	if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND)
		errno = ENOENT;
	else if (err == ERROR_ACCESS_DENIED)
		errno = EACCES;
	else
		errno = EINVAL;	/* we could map more codes... */
err:
	ret = -1;
ok:
	if (tfrom != NULL && tfrom != (TCHAR *)from)
		free(tfrom);
	return ret;
}
#endif
d2466 1
a2466 126
#if defined(_WIN32)
double
app_tminterval(int stop, int usertime)
{
	FILETIME		now;
	double			ret = 0;
	static ULARGE_INTEGER	tmstart;
	static int		warning = 1;
#ifdef _WIN32_WINNT
	static HANDLE		proc = NULL;

	if (proc == NULL) {
		if (check_winnt())
			proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,
			    GetCurrentProcessId());
		if (proc == NULL)
			proc = (HANDLE) - 1;
	}

	if (usertime && proc != (HANDLE) - 1) {
		FILETIME junk;
		GetProcessTimes(proc, &junk, &junk, &junk, &now);
	} else
#endif
	{
		SYSTEMTIME systime;

		if (usertime && warning) {
			BIO_printf(bio_err, "To get meaningful results, run "
			"this program on idle system.\n");
			warning = 0;
		}
		GetSystemTime(&systime);
		SystemTimeToFileTime(&systime, &now);
	}

	if (stop == TM_START) {
		tmstart.u.LowPart = now.dwLowDateTime;
		tmstart.u.HighPart = now.dwHighDateTime;
	} else {
		ULARGE_INTEGER tmstop;

		tmstop.u.LowPart = now.dwLowDateTime;
		tmstop.u.HighPart = now.dwHighDateTime;

		ret = (__int64)(tmstop.QuadPart - tmstart.QuadPart)*1e - 7;
	}

	return (ret);
}

#elif defined(OPENSSL_SYSTEM_VXWORKS)
#include <time.h>

double
app_tminterval(int stop, int usertime)
{
	double ret = 0;
#ifdef CLOCK_REALTIME
	static struct timespec	tmstart;
	struct timespec		now;
#else
	static unsigned long	tmstart;
	unsigned long		now;
#endif
	static int warning = 1;

	if (usertime && warning) {
		BIO_printf(bio_err, "To get meaningful results, run "
		"this program on idle system.\n");
		warning = 0;
	}

#ifdef CLOCK_REALTIME
	clock_gettime(CLOCK_REALTIME, &now);
	if (stop == TM_START)
		tmstart = now;
	else	ret = ( (now.tv_sec + now.tv_nsec*1e - 9)
		- (tmstart.tv_sec + tmstart.tv_nsec*1e - 9) );
#else
	now = tickGet();
	if (stop == TM_START)
		tmstart = now;
	else
		ret = (now - tmstart)/(double)sysClkRateGet();
#endif
	return (ret);
}

#elif defined(OPENSSL_SYSTEM_VMS)
#include <time.h>
#include <times.h>

double
app_tminterval(int stop, int usertime)
{
	static clock_t	tmstart;
	double		ret = 0;
	clock_t		now;
#ifdef __TMS
	struct tms	rus;

	now = times(&rus);
	if (usertime)
		now = rus.tms_utime;
#else
	if (usertime)
		now = clock(); /* sum of user and kernel times */
	else	{
		struct timeval tv;
		gettimeofday(&tv, NULL);
		now = (clock_t)(
		    (unsigned long long)tv.tv_sec*CLK_TCK +
		    (unsigned long long)tv.tv_usec*(1000000/CLK_TCK)
		);
	}
#endif
	if (stop == TM_START)
		tmstart = now;
	else
		ret = (now - tmstart)/(double)(CLK_TCK);

	return (ret);
}

#elif defined(_SC_CLK_TCK)	/* by means of unistd.h */
a2517 28
#ifdef _WIN32
int
app_isdir(const char *name)
{
	HANDLE		hList;
	WIN32_FIND_DATA	FileData;
#if defined(UNICODE) || defined(_UNICODE)
	size_t i, len_0 = strlen(name) + 1;

	if (len_0 > sizeof(FileData.cFileName)/sizeof(FileData.cFileName[0]))
		return -1;

#if !defined(_WIN32_WCE) || _WIN32_WCE>=101
	if (!MultiByteToWideChar(CP_ACP, 0, name, len_0, FileData.cFileName, len_0))
#endif
	for (i = 0; i < len_0; i++)
		FileData.cFileName[i] = (WCHAR)name[i];

	hList = FindFirstFile(FileData.cFileName, &FileData);
#else
	hList = FindFirstFile(name, &FileData);
#endif
	if (hList == INVALID_HANDLE_VALUE)
		return -1;
	FindClose(hList);
	return ((FileData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY) != 0);
}
#else
a2540 1
#endif
@


1.26
log
@More KNF.
@
text
@d2587 1
a2587 1
		if (i == len || in[i] == ', ') {
@


1.25
log
@First pass for KNF.
@
text
@d194 3
a196 2
	if (buf != NULL) OPENSSL_free(buf);
		buf = (char *)OPENSSL_malloc(len + 1);
d201 3
a203 2
	if (len <= 1) return (0);
		buf[len] = '\0';
d209 3
a211 2
	if (arg != NULL) OPENSSL_free(arg);
		arg = (char **)OPENSSL_malloc(sizeof(char *)*(i*2));
d390 1
a390 1
			arg->data[num-1]++; /* jump over quote */
d454 1
a454 1
				((PW_CB_DATA *)UI_get0_user_data(ui))->password;
d596 3
a598 2
	if (!arg2 || !arg1 || strcmp(arg1, arg2)) same = 0;
		else
d602 5
a606 3
		if (!*pass1) return 0;
		} else if (pass1) *pass1 = NULL;
			if (arg2) {
d608 5
a612 3
		if (!*pass2) return 0;
		} else if (pass2) *pass2 = NULL;
		return 1;
d650 2
a651 1
			if (i >= 0) pwdbio = BIO_new_fd(i, BIO_NOCLOSE);
d681 3
a683 2
	if (tmp) *tmp = 0;
		return BUF_strdup(tpass);
d803 1
a803 1
			    NULL, &x, NULL))
d815 3
a817 2
	if (cert != NULL) BIO_free(cert);
		return (x);
d992 4
a995 3
	if (key != NULL) BIO_free(key);
		if (pkey == NULL)
			BIO_printf(err, "unable to load %s\n", key_descrip);
d1288 3
a1290 2
	if (!arg) return 0;
		vals = X509V3_parse_list(arg);
d1576 5
a1580 3
	if (in != NULL) BIO_free(in);
		if (ai != NULL) ASN1_INTEGER_free(ai);
		return (ret);
d1952 3
a1954 2
		if (db->db) TXT_DB_free(db->db);
			OPENSSL_free(db);
d2660 3
a2662 2
	if (tfrom != NULL && tfrom != (TCHAR *)from)	free(tfrom);
		return ret;
d2682 3
a2684 2
		if (proc == NULL) proc = (HANDLE) - 1;
		}
d2686 1
a2686 1
		if (usertime && proc != (HANDLE) - 1) {
d2706 1
a2706 2
	}
	else	{
d2837 1
a2837 1
		    (tmstart.tv_sec + tmstart.tv_usec * 1e-6) );
@


1.24
log
@first round of unifdef hammering
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d162 2
a163 3
static EVP_PKEY *
load_netscape_key(BIO *err, BIO *key, const char *file,
		const char *key_descrip, int format);
d168 3
a170 2
int args_from_file(char *file, int *argc, char **argv[])
	{
d172 1
a172 1
	int num,i;
d174 2
a175 2
	static char *buf=NULL;
	static char **arg=NULL;
d178 1
a178 1
	fp=fopen(file,"r");
d180 1
a180 1
		return(0);
d182 5
a186 5
	if (fseek(fp,0,SEEK_END)==0)
		len=ftell(fp), rewind(fp);
	else	len=-1;
	if (len<=0)
		{
d188 2
a189 2
		return(0);
		}
d191 2
a192 2
	*argc=0;
	*argv=NULL;
d195 7
a201 2
	buf=(char *)OPENSSL_malloc(len+1);
	if (buf == NULL) return(0);
d203 4
a206 7
	len=fread(buf,1,len,fp);
	if (len <= 1) return(0);
	buf[len]='\0';

	i=0;
	for (p=buf; *p; p++)
		if (*p == '\n') i++;
d208 1
a208 1
	arg=(char **)OPENSSL_malloc(sizeof(char *)*(i*2));
d210 7
a216 4
	*argv=arg;
	num=0;
	p=buf;
	for (;;)
d218 2
a219 4
		if (!*p) break;
		if (*p == '#') /* comment line */
			{
			while (*p && (*p != '\n')) p++;
d221 1
a221 1
			}
d223 1
a223 1
		*(arg++)=p;
d227 4
a230 4
		if (!*p) break;
		if (*p == '\n')
			{
			*(p++)='\0';
d232 1
a232 1
			}
d237 3
a239 3
		if (!*p) break;
		if (*p == '\n')
			{
d242 2
a243 2
			}
		*(arg++)=p++;
d245 4
a248 2
		while (*p && (*p != '\n')) p++;
		if (!*p) break;
d250 1
a250 4
		*(p++)='\0';
		}
	*argc=num;
	return(1);
d252 3
d257 3
a259 2
int str2fmt(char *s)
	{
d262 2
a263 2
	if 	((*s == 'D') || (*s == 'd'))
		return(FORMAT_ASN1);
d265 11
a275 11
		return(FORMAT_TEXT);
  	else if ((*s == 'N') || (*s == 'n'))
  		return(FORMAT_NETSCAPE);
  	else if ((*s == 'S') || (*s == 's'))
  		return(FORMAT_SMIME);
 	else if ((*s == 'M') || (*s == 'm'))
 		return(FORMAT_MSBLOB);
	else if ((*s == '1')
		|| (strcmp(s,"PKCS12") == 0) || (strcmp(s,"pkcs12") == 0)
		|| (strcmp(s,"P12") == 0) || (strcmp(s,"p12") == 0))
		return(FORMAT_PKCS12);
d277 9
a285 11
		return(FORMAT_ENGINE);
	else if ((*s == 'P') || (*s == 'p'))
 		{
 		if (s[1] == 'V' || s[1] == 'v')
 			return FORMAT_PVK;
 		else
  			return(FORMAT_PEM);
 		}
	else
		return(FORMAT_UNDEF);
	}
d288 5
a292 4
void program_name(char *in, char *out, int size)
	{
	int i,n;
	char *p=NULL;
d294 1
a294 1
	n=strlen(in);
d296 3
a298 5
	for (i=n-1; i>0; i--)
		{
		if ((in[i] == '/') || (in[i] == '\\') || (in[i] == ':'))
			{
			p= &(in[i+1]);
a299 1
			}
d301 1
d303 2
a304 2
		p=in;
	n=strlen(p);
d307 5
a311 5
	if ((n > 4) && (p[n-4] == '.') &&
		((p[n-3] == 'e') || (p[n-3] == 'E')) &&
		((p[n-2] == 'x') || (p[n-2] == 'X')) &&
		((p[n-1] == 'e') || (p[n-1] == 'E')))
		n-=4;
d313 2
a314 2
	if (n > size-1)
		n=size-1;
d316 1
a316 2
	for (i=0; i<n; i++)
		{
d318 1
a318 1
			out[i]=p[i]-'A'+'a';
d320 1
a320 3
			out[i]=p[i];
		}
	out[n]='\0';
d322 2
d325 3
a327 2
void program_name(char *in, char *out, int size)
	{
d330 1
a330 1
	p=strrchr(in,'/');
d334 3
a336 3
		p=in;
	BUF_strlcpy(out,p,size);
	}
d339 4
a342 3
int chopup_args(ARGS *arg, char *buf, int *argc, char **argv[])
	{
	int num,i;
d345 2
a346 11
	*argc=0;
	*argv=NULL;

	i=0;
	if (arg->count == 0)
		{
		arg->count=20;
		arg->data=(char **)OPENSSL_malloc(sizeof(char *)*arg->count);
		}
	for (i=0; i<arg->count; i++)
		arg->data[i]=NULL;
d348 11
a358 4
	num=0;
	p=buf;
	for (;;)
		{
d360 2
a361 1
		if (!*p) break;
d364 2
a365 1
		if (!*p) break;
d368 1
a368 2
		if (num >= arg->count)
			{
d372 1
a372 1
				sizeof(char *)*tlen);
d375 1
a375 1
			arg->data  = tmp_p;
d380 2
a381 2
			}
		arg->data[num++]=p;
d385 1
a385 1
			{
d390 2
a391 4
			*p='\0';
			}
		else
			{
d393 1
a393 1
				(*p != '\t') && (*p != '\n')))
d399 2
a400 2
				*p='\0';
			}
a401 4
		}
	*argc=num;
	*argv=arg->data;
	return(1);
d403 4
d409 5
a413 4
int app_init(long mesgwin)
	{
	return(1);
	}
d421 3
a423 3
	p=X509_NAME_oneline(X509_get_subject_name(x),NULL,0);
	BIO_puts(out,"subject=");
	BIO_puts(out,p);
d426 4
a429 4
	p=X509_NAME_oneline(X509_get_issuer_name(x),NULL,0);
	BIO_puts(out,"\nissuer=");
	BIO_puts(out,p);
	BIO_puts(out,"\n");
d435 3
a437 2
static int ui_open(UI *ui)
	{
d439 8
a446 8
	}
static int ui_read(UI *ui, UI_STRING *uis)
	{
	if (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD
		&& UI_get0_user_data(ui))
		{
		switch(UI_get_string_type(uis))
			{
d450 1
a450 1
			const char *password =
d452 3
a454 4
			if (password && password[0] != '\0')
				{
				UI_set_result(ui, uis, password);
				return 1;
a458 1
			}
d460 1
d462 8
a469 8
	}
static int ui_write(UI *ui, UI_STRING *uis)
	{
	if (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD
		&& UI_get0_user_data(ui))
		{
		switch(UI_get_string_type(uis))
			{
d473 4
a476 4
			const char *password =
				((PW_CB_DATA *)UI_get0_user_data(ui))->password;
			if (password && password[0] != '\0')
				return 1;
a479 1
			}
d481 1
d483 5
a487 3
	}
static int ui_close(UI *ui)
	{
d489 5
a493 3
	}
int setup_ui_method(void)
	{
d500 6
a505 5
	}
void destroy_ui_method(void)
	{
	if(ui_method)
		{
a507 1
		}
d509 6
a514 3
int password_callback(char *buf, int bufsiz, int verify,
	PW_CB_DATA *cb_tmp)
	{
d521 1
a521 2
	if (cb_data)
		{
d526 1
a526 1
		}
d528 1
a528 2
	if (password)
		{
d534 1
a534 1
		}
d537 1
a537 2
	if (ui)
		{
d544 1
a544 1
			prompt_info);
d550 3
a552 4
			ok = UI_add_input_string(ui,prompt,ui_flags,buf,
				PW_MIN_LENGTH,bufsiz-1);
		if (ok >= 0 && verify)
			{
d554 3
a556 3
			ok = UI_add_verify_string(ui,prompt,ui_flags,buff,
				PW_MIN_LENGTH,bufsiz-1, buf);
			}
d558 1
a558 2
			do
				{
d560 2
a561 2
				}
			while (ok < 0 && UI_ctrl(ui, UI_CTRL_IS_REDOABLE, 0, 0, 0));
d563 2
a564 3
		if (buff)
			{
			OPENSSL_cleanse(buff,(unsigned int)bufsiz);
d566 1
a566 1
			}
d570 1
a570 2
		if (ok == -1)
			{
d573 1
a573 1
			OPENSSL_cleanse(buf,(unsigned int)bufsiz);
d575 4
a578 5
			}
		if (ok == -2)
			{
			BIO_printf(bio_err,"aborted!\n");
			OPENSSL_cleanse(buf,(unsigned int)bufsiz);
d580 1
a580 1
			}
d583 1
a583 1
		}
d585 1
a585 1
	}
d589 2
a590 1
int app_passwd(BIO *err, char *arg1, char *arg2, char **pass1, char **pass2)
d593 4
a596 3
	if(!arg2 || !arg1 || strcmp(arg1, arg2)) same = 0;
	else same = 1;
	if(arg1) {
d598 3
a600 3
		if(!*pass1) return 0;
	} else if(pass1) *pass1 = NULL;
	if(arg2) {
d602 3
a604 3
		if(!*pass2) return 0;
	} else if(pass2) *pass2 = NULL;
	return 1;
d607 2
a608 1
static char *app_get_pass(BIO *err, char *arg, int keepbio)
d613 3
a615 2
	if(!strncmp(arg, "pass:", 5)) return BUF_strdup(arg + 5);
	if(!strncmp(arg, "env:", 4)) {
d617 1
a617 1
		if(!tmp) {
d623 2
a624 2
	if(!keepbio || !pwdbio) {
		if(!strncmp(arg, "file:", 5)) {
d626 1
a626 1
			if(!pwdbio) {
d639 1
a639 1
		} else if(!strncmp(arg, "fd:", 3)) {
d642 2
a643 2
			if(i >= 0) pwdbio = BIO_new_fd(i, BIO_NOCLOSE);
			if((i < 0) || !pwdbio) {
d651 1
a651 1
		} else if(!strcmp(arg, "stdin")) {
d653 1
a653 1
			if(!pwdbio) {
d663 1
a663 1
	if(keepbio != 1) {
d667 1
a667 1
	if(i <= 0) {
d672 2
a673 2
	if(tmp) *tmp = 0;
	return BUF_strdup(tpass);
d676 3
a678 2
int add_oid_section(BIO *err, CONF *conf)
{	
d683 1
a683 2
	if(!(p=NCONF_get_string(conf,NULL,"oid_section")))
		{
d686 2
a687 2
		}
	if(!(sktmp = NCONF_get_section(conf, p))) {
d691 1
a691 1
	for(i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {
d693 1
a693 1
		if(OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {
d695 1
a695 1
							 cnf->name, cnf->value);
d702 5
a706 5
static int load_pkcs12(BIO *err, BIO *in, const char *desc,
		pem_password_cb *pem_cb,  void *cb_data,
		EVP_PKEY **pkey, X509 **cert, STACK_OF(X509) **ca)
	{
 	const char *pass;
d711 2
a712 3
	if (p12 == NULL)
		{
		BIO_printf(err, "Error loading PKCS12 file for %s\n", desc);	
d714 1
a714 1
		}
d718 1
a718 2
	else
		{
d722 1
a722 2
		if (len < 0) 
			{
d724 1
a724 1
					desc);
d726 1
a726 1
			}
d729 1
a729 2
		if (!PKCS12_verify_mac(p12, tpass, len))
			{
d731 1
a731 1
	"Mac verify error (wrong password?) in PKCS12 file for %s\n", desc);	
d733 1
a733 1
			}
d735 1
a735 1
		}
d737 1
a737 1
	die:
d741 1
a741 1
	}
d743 5
a747 4
X509 *load_cert(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *cert_descrip)
	{
	X509 *x=NULL;
d750 1
a750 2
	if ((cert=BIO_new(BIO_s_file())) == NULL)
		{
d753 1
a753 1
		}
d755 1
a755 2
	if (file == NULL)
		{
d761 3
a763 6
		BIO_set_fp(cert,stdin,BIO_NOCLOSE);
		}
	else
		{
		if (BIO_read_filename(cert,file) <= 0)
			{
d765 1
a765 1
				cert_descrip, file);
a767 1
			}
d769 1
d771 3
a773 4
	if 	(format == FORMAT_ASN1)
		x=d2i_X509_bio(cert,NULL);
	else if (format == FORMAT_NETSCAPE)
		{
d775 1
a775 1
		nx=ASN1_item_d2i_bio(ASN1_ITEM_rptr(NETSCAPE_X509),cert,NULL);
d777 1
a777 1
				goto end;
d779 2
a780 3
		if ((strncmp(NETSCAPE_CERT_HDR,(char *)nx->header->data,
			nx->header->length) != 0))
			{
d782 1
a782 1
			BIO_printf(err,"Error reading header on certificate\n");
d784 2
a785 2
			}
		x=nx->cert;
d788 6
a793 8
		}
	else if (format == FORMAT_PEM)
		x=PEM_read_bio_X509_AUX(cert,NULL,
			(pem_password_cb *)password_callback, NULL);
	else if (format == FORMAT_PKCS12)
		{
		if (!load_pkcs12(err, cert,cert_descrip, NULL, NULL,
					NULL, &x, NULL))
d795 3
a797 4
		}
	else	{
		BIO_printf(err,"bad input format specified for %s\n",
			cert_descrip);
d799 1
a799 1
		}
d801 2
a802 3
	if (x == NULL)
		{
		BIO_printf(err,"unable to load certificate\n");
d804 1
a804 1
		}
d806 2
a807 2
	return(x);
	}
d809 6
a814 5
EVP_PKEY *load_key(BIO *err, const char *file, int format, int maybe_stdin,
	const char *pass, ENGINE *e, const char *key_descrip)
	{
	BIO *key=NULL;
	EVP_PKEY *pkey=NULL;
d820 2
a821 3
	if (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE))
		{
		BIO_printf(err,"no keyfile specified\n");
d823 1
a823 1
		}
d825 1
a825 2
	if (format == FORMAT_ENGINE)
		{
d827 2
a828 3
			BIO_printf(err,"no engine specified\n");
		else
			{
d830 3
a832 4
				ui_method, &cb_data);
			if (!pkey) 
				{
				BIO_printf(err,"cannot load %s from engine\n",key_descrip);
a833 1
				}	
d835 1
d837 1
a837 1
		}
d839 2
a840 3
	key=BIO_new(BIO_s_file());
	if (key == NULL)
		{
d843 2
a844 3
		}
	if (file == NULL && maybe_stdin)
		{
d850 13
a862 19
		BIO_set_fp(key,stdin,BIO_NOCLOSE);
		}
	else
		if (BIO_read_filename(key,file) <= 0)
			{
			BIO_printf(err, "Error opening %s %s\n",
				key_descrip, file);
			ERR_print_errors(err);
			goto end;
			}
	if (format == FORMAT_ASN1)
		{
		pkey=d2i_PrivateKey_bio(key, NULL);
		}
	else if (format == FORMAT_PEM)
		{
		pkey=PEM_read_bio_PrivateKey(key,NULL,
			(pem_password_cb *)password_callback, &cb_data);
		}
d867 1
a867 2
	else if (format == FORMAT_PKCS12)
		{
d869 2
a870 2
				(pem_password_cb *)password_callback, &cb_data,
				&pkey, NULL, NULL))
d872 1
a872 1
		}
d878 1
a878 1
								&cb_data);
d880 2
a881 3
	else
		{
		BIO_printf(err,"bad input format specified for key file\n");
d883 6
a888 6
		}
 end:
	if (key != NULL) BIO_free(key);
	if (pkey == NULL) 
		{
		BIO_printf(err,"unable to load %s\n", key_descrip);
a889 2
		}	
	return(pkey);
d891 2
d894 6
a899 5
EVP_PKEY *load_pubkey(BIO *err, const char *file, int format, int maybe_stdin,
	const char *pass, ENGINE *e, const char *key_descrip)
	{
	BIO *key=NULL;
	EVP_PKEY *pkey=NULL;
d905 2
a906 3
	if (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE))
		{
		BIO_printf(err,"no keyfile specified\n");
d908 1
a908 1
		}
d910 1
a910 2
	if (format == FORMAT_ENGINE)
		{
d912 1
a912 1
			BIO_printf(bio_err,"no engine specified\n");
d915 1
a915 1
				ui_method, &cb_data);
d917 1
a917 1
		}
d919 2
a920 3
	key=BIO_new(BIO_s_file());
	if (key == NULL)
		{
d923 2
a924 3
		}
	if (file == NULL && maybe_stdin)
		{
d930 10
a939 14
		BIO_set_fp(key,stdin,BIO_NOCLOSE);
		}
	else
		if (BIO_read_filename(key,file) <= 0)
			{
			BIO_printf(err, "Error opening %s %s\n",
				key_descrip, file);
			ERR_print_errors(err);
			goto end;
		}
	if (format == FORMAT_ASN1)
		{
		pkey=d2i_PUBKEY_bio(key, NULL);
		}
d941 1
a941 2
	else if (format == FORMAT_ASN1RSA)
		{
d944 1
a944 2
		if (rsa)
			{
d949 1
a949 2
			}
		else
d951 1
a951 3
		}
	else if (format == FORMAT_PEMRSA)
		{
d953 3
a955 4
		rsa = PEM_read_bio_RSAPublicKey(key, NULL, 
			(pem_password_cb *)password_callback, &cb_data);
		if (rsa)
			{
d960 1
a960 2
			}
		else
d962 1
a962 1
		}
d964 4
a967 5
	else if (format == FORMAT_PEM)
		{
		pkey=PEM_read_bio_PUBKEY(key,NULL,
			(pem_password_cb *)password_callback, &cb_data);
		}
d976 2
a977 3
	else
		{
		BIO_printf(err,"bad input format specified for key file\n");
d979 2
a980 2
		}
 end:
d982 4
a985 4
	if (pkey == NULL)
		BIO_printf(err,"unable to load %s\n", key_descrip);
	return(pkey);
	}
d990 2
a991 2
		const char *key_descrip, int format)
	{
d998 1
a998 1
	buf=BUF_MEM_new();
d1003 2
a1004 3
	for (;;)
		{
		if (!BUF_MEM_grow_clean(buf,size+1024*10))
d1010 4
a1013 6
		if (i < 0)
			{
				BIO_printf(err, "Error reading %s %s",
					key_descrip, file);
				goto error;
			}
d1015 4
a1018 3
	p=(unsigned char *)buf->data;
	rsa = d2i_RSA_NET(NULL,&p,(long)size,NULL,
		(format == FORMAT_IISSGC ? 1 : 0));
d1028 1
a1028 1
	}
d1031 5
a1035 4
static int load_certs_crls(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *desc,
	STACK_OF(X509) **pcerts, STACK_OF(X509_CRL) **pcrls)
	{
d1046 2
a1047 3
	if (format != FORMAT_PEM)
		{
		BIO_printf(err,"bad input format specified for %s\n", desc);
d1049 1
a1049 1
		}
d1052 1
a1052 1
		bio = BIO_new_fp(stdin,BIO_NOCLOSE);
d1056 1
a1056 2
	if (bio == NULL)
		{
d1058 1
a1058 1
				desc, file ? file : "stdin");
d1061 1
a1061 1
		}
d1064 1
a1064 1
				(pem_password_cb *)password_callback, &cb_data);
d1068 1
a1068 2
	if (pcerts)
		{
d1072 1
a1072 1
		}
d1074 1
a1074 2
	if (pcrls)
		{
d1078 1
a1078 1
		}
d1080 1
a1080 2
	for(i = 0; i < sk_X509_INFO_num(xis); i++)
		{
d1082 1
a1082 2
		if (xi->x509 && pcerts)
			{
d1086 2
a1087 3
			}
		if (xi->crl && pcrls)
			{
a1090 1
			}
d1092 1
d1100 1
a1100 2
	end:

d1104 2
a1105 4
	if (rv == 0)
		{
		if (pcerts)
			{
d1108 2
a1109 3
			}
		if (pcrls)
			{
d1112 3
a1114 3
			}
		BIO_printf(err,"unable to load %s\n",
				pcerts ? "certificates" : "CRLs");
d1116 1
a1116 1
		}
d1118 1
a1118 1
	}
d1120 4
a1123 3
STACK_OF(X509) *load_certs(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *desc)
	{
d1128 1
a1128 1
	}	
d1130 4
a1133 3
STACK_OF(X509_CRL) *load_crls(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *desc)
	{
d1138 1
a1138 1
	}	
d1153 2
a1154 1
int set_cert_ex(unsigned long *flags, const char *arg)
d1180 2
a1181 1
int set_name_ex(unsigned long *flags, const char *arg)
d1216 2
a1217 1
int set_ext_copy(int *copy_type, const char *arg)
d1230 2
a1231 1
int copy_extensions(X509 *x, X509_REQ *req, int copy_type)
d1241 1
a1241 1
	for(i = 0; i < sk_X509_EXTENSION_num(exts); i++) {
d1264 1
a1264 2
	end:

a1268 3
		
		
			
d1270 2
a1271 1
static int set_multi_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl)
d1276 2
a1277 2
	if(!arg) return 0;
	vals = X509V3_parse_list(arg);
d1287 2
a1288 1
static int set_table_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl)
d1294 1
a1294 1
	if(c == '-') {
d1302 2
a1303 2
	for(ptbl = in_tbl; ptbl->name; ptbl++) {
		if(!strcasecmp(arg, ptbl->name)) {
d1305 4
a1308 2
			if(c) *flags |= ptbl->flag;
			else *flags &= ~ptbl->flag;
d1315 2
a1316 1
void print_name(BIO *out, const char *title, X509_NAME *nm, unsigned long lflags)
d1322 3
a1324 2
	if(title) BIO_puts(out, title);
	if((lflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {
d1328 1
a1328 1
	if(lflags == XN_FLAG_COMPAT) {
d1334 2
a1335 1
		if(mline) BIO_puts(out, "\n");
d1341 2
a1342 1
X509_STORE *setup_verify(BIO *bp, char *CAfile, char *CApath)
d1346 5
a1350 3
	if(!(store = X509_STORE_new())) goto end;
	lookup=X509_STORE_add_lookup(store,X509_LOOKUP_file());
	if (lookup == NULL) goto end;
d1352 1
a1352 1
		if(!X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM)) {
d1356 6
a1361 4
	} else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);
		
	lookup=X509_STORE_add_lookup(store,X509_LOOKUP_hash_dir());
	if (lookup == NULL) goto end;
d1363 1
a1363 1
		if(!X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM)) {
d1367 2
a1368 1
	} else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);
d1372 2
a1373 1
	end:
d1380 3
a1382 2
static ENGINE *try_load_engine(BIO *err, const char *engine, int debug)
	{
d1384 3
a1386 5
	if (e)
		{
		if (!ENGINE_ctrl_cmd_string(e, "SO_PATH", engine, 0)
			|| !ENGINE_ctrl_cmd_string(e, "LOAD", NULL, 0))
			{
a1388 1
			}
d1390 1
d1392 6
a1397 1
	}
d1399 3
a1401 9
ENGINE *setup_engine(BIO *err, const char *engine, int debug)
        {
        ENGINE *e = NULL;

        if (engine)
                {
		if(strcmp(engine, "auto") == 0)
			{
			BIO_printf(err,"enabling auto ENGINE support\n");
d1404 4
a1407 5
			}
		if((e = ENGINE_by_id(engine)) == NULL
			&& (e = try_load_engine(err, engine, debug)) == NULL)
			{
			BIO_printf(err,"invalid engine \"%s\"\n", engine);
d1410 2
a1411 3
			}
		if (debug)
			{
d1413 5
a1417 6
				0, err, 0);
			}
                ENGINE_ctrl_cmd(e, "SET_USER_INTERFACE", 0, ui_method, 0, 1);
		if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
			{
			BIO_printf(err,"can't use that engine\n");
d1421 1
a1421 1
			}
d1423 1
a1423 1
		BIO_printf(err,"engine \"%s\" set.\n", ENGINE_get_id(e));
d1427 3
a1429 3
		}
        return e;
        }
d1432 3
a1434 2
int load_config(BIO *err, CONF *cnf)
	{
d1446 1
a1446 2
	if (CONF_modules_load(cnf, NULL, 0) <= 0)
		{
d1450 1
a1450 1
		}
d1452 1
a1452 1
	}
d1454 4
a1457 3
char *make_config_name()
	{
	const char *t=X509_get_default_cert_area();
d1461 5
a1465 5
	len=strlen(t)+strlen(OPENSSL_CONF)+2;
	p=OPENSSL_malloc(len);
	BUF_strlcpy(p,t,len);
	BUF_strlcat(p,"/",len);
	BUF_strlcat(p,OPENSSL_CONF,len);
d1468 1
a1468 1
	}
d1470 3
a1472 2
static unsigned long index_serial_hash(const OPENSSL_CSTRING *a)
	{
d1475 5
a1479 4
	n=a[DB_serial];
	while (*n == '0') n++;
	return(lh_strhash(n));
	}
d1481 4
a1484 3
static int index_serial_cmp(const OPENSSL_CSTRING *a, const OPENSSL_CSTRING *b)
	{
	const char *aa,*bb;
d1486 6
a1491 4
	for (aa=a[DB_serial]; *aa == '0'; aa++);
	for (bb=b[DB_serial]; *bb == '0'; bb++);
	return(strcmp(aa,bb));
	}
d1493 5
a1497 2
static int index_name_qual(char **a)
	{ return(a[0][0] == 'V'); }
d1499 5
a1503 2
static unsigned long index_name_hash(const OPENSSL_CSTRING *a)
	{ return(lh_strhash(a[DB_name])); }
d1505 5
a1509 2
int index_name_cmp(const OPENSSL_CSTRING *a, const OPENSSL_CSTRING *b)
	{ return(strcmp(a[DB_name], b[DB_name])); }
d1519 5
a1523 4
BIGNUM *load_serial(char *serialfile, int create, ASN1_INTEGER **retai)
	{
	BIO *in=NULL;
	BIGNUM *ret=NULL;
d1525 1
a1525 1
	ASN1_INTEGER *ai=NULL;
d1527 3
a1529 2
	ai=ASN1_INTEGER_new();
	if (ai == NULL) goto err;
d1531 1
a1531 2
	if ((in=BIO_new(BIO_s_file())) == NULL)
		{
d1534 1
a1534 1
		}
d1536 2
a1537 4
	if (BIO_read_filename(in,serialfile) <= 0)
		{
		if (!create)
			{
d1540 2
a1541 4
			}
		else
			{
			ret=BN_new();
a1543 1
			}
d1545 4
a1548 6
	else
		{
		if (!a2i_ASN1_INTEGER(in,ai,buf,1024))
			{
			BIO_printf(bio_err,"unable to load number from %s\n",
				serialfile);
d1550 4
a1553 5
			}
		ret=ASN1_INTEGER_to_BN(ai,NULL);
		if (ret == NULL)
			{
			BIO_printf(bio_err,"error converting number from bin to BIGNUM\n");
a1554 1
			}
d1556 1
d1558 1
a1558 2
	if (ret && retai)
		{
d1561 2
a1562 2
		}
 err:
d1564 3
a1566 3
	if (ai != NULL) ASN1_INTEGER_free(ai);
	return(ret);
	}
d1568 4
a1571 2
int save_serial(char *serialfile, char *suffix, BIGNUM *serial, ASN1_INTEGER **retai)
	{
d1574 2
a1575 2
	int ret=0;
	ASN1_INTEGER *ai=NULL;
d1582 2
a1583 3
	if (j >= BSIZE)
		{
		BIO_printf(bio_err,"file name too long\n");
d1585 1
a1585 1
		}
d1594 2
a1595 3
	out=BIO_new(BIO_s_file());
	if (out == NULL)
		{
d1598 2
a1599 3
		}
	if (BIO_write_filename(out,buf[0]) <= 0)
		{
d1602 1
a1602 1
		}
d1604 2
a1605 3
	if ((ai=BN_to_ASN1_INTEGER(serial,NULL)) == NULL)
		{
		BIO_printf(bio_err,"error converting serial to ASN.1 format\n");
d1607 5
a1611 6
		}
	i2a_ASN1_INTEGER(out,ai);
	BIO_puts(out,"\n");
	ret=1;
	if (retai)
		{
d1614 1
a1614 1
		}
d1616 6
a1621 4
	if (out != NULL) BIO_free_all(out);
	if (ai != NULL) ASN1_INTEGER_free(ai);
	return(ret);
	}
d1623 3
a1625 2
int rotate_serial(char *serialfile, char *new_suffix, char *old_suffix)
	{
d1627 1
a1627 1
	int i,j;
d1631 4
a1634 4
	if (i > j) j = i;
	if (j + 1 >= BSIZE)
		{
		BIO_printf(bio_err,"file name too long\n");
d1636 1
a1636 1
		}
d1639 1
a1639 1
		serialfile, new_suffix);
d1641 1
a1641 1
		serialfile, old_suffix);
d1644 1
a1644 1
		serialfile, buf[1]);
d1646 1
a1646 1
	if (rename(serialfile,buf[1]) < 0 && errno != ENOENT
d1648 1
a1648 1
			&& errno != ENOTDIR
d1650 7
a1656 7
	   )		{
			BIO_printf(bio_err,
				"unable to rename %s to %s\n",
				serialfile, buf[1]);
			perror("reason");
			goto err;
			}
d1659 1
a1659 1
		buf[0],serialfile);
d1661 1
a1661 2
	if (rename(buf[0],serialfile) < 0)
		{
d1663 2
a1664 2
			"unable to rename %s to %s\n",
			buf[0],serialfile);
d1666 1
a1666 1
		rename(buf[1],serialfile);
d1668 1
a1668 1
		}
d1670 1
a1670 1
 err:
d1672 1
a1672 1
	}
d1674 3
a1676 2
int rand_serial(BIGNUM *b, ASN1_INTEGER *ai)
	{
a1692 2
	
	error:
d1694 1
d1697 1
a1697 1
	
d1699 1
a1699 1
	}
d1701 3
a1703 2
CA_DB *load_index(char *dbfile, DB_ATTR *db_attr)
	{
d1709 1
a1709 1
	long errorline= -1;
d1711 1
a1711 2
	if (in == NULL)
		{
d1714 2
a1715 3
		}
	if (BIO_read_filename(in,dbfile) <= 0)
		{
d1717 1
a1717 1
		BIO_printf(bio_err,"unable to open '%s'\n",dbfile);
d1719 2
a1720 2
		}
	if ((tmpdb = TXT_DB_read(in,DB_NUMBER)) == NULL)
d1725 2
a1726 4
	if (NCONF_load(dbattr_conf,buf[0],&errorline) <= 0)
		{
		if (errorline > 0)
			{
d1728 2
a1729 2
				"error on line %ld of db attribute file '%s'\n"
				,errorline,buf[0]);
d1731 1
a1731 3
			}
		else
			{
a1733 1
			}
d1735 1
d1737 1
a1737 2
	if ((retdb = OPENSSL_malloc(sizeof(CA_DB))) == NULL)
		{
d1740 1
a1740 1
		}
d1746 1
a1746 2
	else
		{
d1748 1
a1748 1
		}
d1750 3
a1752 5
	if (dbattr_conf)
		{
		char *p = NCONF_get_string(dbattr_conf,NULL,"unique_subject");
		if (p)
			{
d1756 1
a1756 2
			retdb->attributes.unique_subject = parse_yesno(p,1);
			}
d1758 1
d1760 7
a1766 4
 err:
	if (dbattr_conf) NCONF_free(dbattr_conf);
	if (tmpdb) TXT_DB_free(tmpdb);
	if (in) BIO_free_all(in);
d1768 1
a1768 1
	}
d1770 3
a1772 2
int index_index(CA_DB *db)
	{
d1774 2
a1775 3
				LHASH_HASH_FN(index_serial),
				LHASH_COMP_FN(index_serial)))
		{
d1777 4
a1780 4
		  "error creating serial number index:(%ld,%ld,%ld)\n",
		  			db->db->error,db->db->arg1,db->db->arg2);
			return 0;
		}
d1782 5
a1786 7
	if (db->attributes.unique_subject
		&& !TXT_DB_create_index(db->db, DB_name, index_name_qual,
			LHASH_HASH_FN(index_name),
			LHASH_COMP_FN(index_name)))
		{
		BIO_printf(bio_err,"error creating name index:(%ld,%ld,%ld)\n",
			db->db->error,db->db->arg1,db->db->arg2);
d1788 1
a1788 1
		}
d1790 1
a1790 1
	}
d1792 3
a1794 2
int save_index(const char *dbfile, const char *suffix, CA_DB *db)
	{
d1799 1
a1799 2
	if (out == NULL)
		{
d1802 1
a1802 1
		}
d1805 2
a1806 3
	if (j + 6 >= BSIZE)
		{
		BIO_printf(bio_err,"file name too long\n");
d1808 1
a1808 1
		}
d1816 1
a1816 2
	if (BIO_write_filename(out,buf[0]) <= 0)
		{
d1818 1
a1818 1
		BIO_printf(bio_err,"unable to open '%s'\n", dbfile);
d1820 5
a1824 4
		}
	j=TXT_DB_write(out,db->db);
	if (j <= 0) goto err;
			
d1831 1
a1831 2
	if (BIO_write_filename(out,buf[1]) <= 0)
		{
d1833 1
a1833 1
		BIO_printf(bio_err,"unable to open '%s'\n", buf[2]);
d1835 3
a1837 3
		}
	BIO_printf(out,"unique_subject = %s\n",
		db->attributes.unique_subject ? "yes" : "no");
d1841 1
a1841 1
 err:
d1843 1
a1843 1
	}
d1845 3
a1847 2
int rotate_index(const char *dbfile, const char *new_suffix, const char *old_suffix)
	{
d1849 1
a1849 1
	int i,j;
d1853 4
a1856 4
	if (i > j) j = i;
	if (j + 6 >= BSIZE)
		{
		BIO_printf(bio_err,"file name too long\n");
d1858 1
a1858 1
		}
d1862 1
a1862 1
		dbfile, new_suffix);
d1864 1
a1864 1
		dbfile, new_suffix);
d1866 1
a1866 1
		dbfile, old_suffix);
d1868 1
a1868 1
		dbfile, old_suffix);
d1871 1
a1871 1
		dbfile, buf[1]);
d1873 1
a1873 1
	if (rename(dbfile,buf[1]) < 0 && errno != ENOENT
d1875 1
a1875 1
		&& errno != ENOTDIR
d1877 7
a1883 7
	   )		{
			BIO_printf(bio_err,
				"unable to rename %s to %s\n",
				dbfile, buf[1]);
			perror("reason");
			goto err;
			}
d1886 1
a1886 1
		buf[0],dbfile);
d1888 1
a1888 2
	if (rename(buf[0],dbfile) < 0)
		{
d1890 2
a1891 2
			"unable to rename %s to %s\n",
			buf[0],dbfile);
d1893 1
a1893 1
		rename(buf[1],dbfile);
d1895 1
a1895 1
		}
d1898 1
a1898 1
		buf[4],buf[3]);
d1900 1
a1900 1
	if (rename(buf[4],buf[3]) < 0 && errno != ENOENT
d1902 1
a1902 1
		&& errno != ENOTDIR
d1904 9
a1912 9
	   )		{
			BIO_printf(bio_err,
				"unable to rename %s to %s\n",
				buf[4], buf[3]);
			perror("reason");
			rename(dbfile,buf[0]);
			rename(buf[1],dbfile);
			goto err;
			}
d1915 1
a1915 1
		buf[2],buf[4]);
d1917 1
a1917 2
	if (rename(buf[2],buf[4]) < 0)
		{
d1919 2
a1920 2
			"unable to rename %s to %s\n",
			buf[2],buf[4]);
d1922 3
a1924 3
		rename(buf[3],buf[4]);
		rename(dbfile,buf[0]);
		rename(buf[1],dbfile);
d1926 1
a1926 1
		}
d1928 2
a1929 1
 err:
d1931 1
a1931 1
	}
d1933 4
a1936 4
void free_index(CA_DB *db)
	{
	if (db)
		{
d1938 1
a1938 2
		OPENSSL_free(db);
		}
d1940 1
d1942 3
a1944 2
int parse_yesno(const char *str, int def)
	{
d1946 2
a1947 4
	if (str)
		{
		switch (*str)
			{
a1964 1
			}
d1966 1
d1968 1
a1968 1
	}
d1974 3
a1976 2
X509_NAME *parse_name(char *subject, long chtype, int multirdn)
	{
d1990 1
a1990 2
	if (!buf || !ne_types || !ne_values || !mval)
		{
d1993 1
a1993 1
		}	
d1995 1
a1995 2
	if (*subject != '/')
		{
d1998 1
a1998 1
		}
d2004 1
a2004 2
	while (*sp)
		{
d2007 2
a2008 1
		while (*sp)
a2009 2
			if (*sp == '\\') /* is there anything to escape in the type...? */
				{
d2012 1
a2012 2
				else	
					{
d2015 2
a2016 4
					}
				}	
			else if (*sp == '=')
				{
d2020 1
a2020 2
				}
			else
d2022 2
a2023 3
			}
		if (!*sp)
			{
d2026 1
a2026 1
			}
d2028 2
a2029 4
		while (*sp)
			{
			if (*sp == '\\')
				{
d2032 1
a2032 2
				else
					{
a2034 1
					}
d2036 1
a2036 2
			else if (*sp == '/')
				{
d2039 1
a2039 1
				mval[ne_num+1] = 0;
d2041 1
a2041 3
				}
			else if (*sp == '+' && multirdn)
				{
d2044 1
a2044 1
				mval[ne_num+1] = -1;
d2046 1
a2046 2
				}
			else
d2048 1
a2048 1
			}
d2051 1
a2051 1
		}	
d2056 2
a2057 4
	for (i = 0; i < ne_num; i++)
		{
		if ((nid=OBJ_txt2nid(ne_types[i])) == NID_undef)
			{
d2060 1
a2060 1
			}
d2062 1
a2062 2
		if (!*ne_values[i])
			{
d2065 1
a2065 1
			}
d2067 1
a2067 1
		if (!X509_NAME_add_entry_by_NID(n, nid, chtype, (unsigned char*)ne_values[i], -1,-1,mval[i]))
d2069 1
a2069 1
		}
d2090 4
a2093 3
int args_verify(char ***pargs, int *pargc,
			int *badarg, BIO *err, X509_VERIFY_PARAM **pm)
	{
d2101 1
a2101 2
	if (!strcmp(arg, "-policy"))
		{
d2104 1
a2104 2
		else
			{
d2106 1
a2106 2
			if (!otmp)
				{
d2108 1
a2108 1
									argn);
a2109 1
				}
d2111 1
d2113 1
a2113 3
		}
	else if (strcmp(arg,"-purpose") == 0)
		{
d2117 1
a2117 2
		else
			{
d2119 1
a2119 2
			if(i < 0)
				{
d2122 1
a2122 3
				}
			else
				{
a2124 1
				}
d2126 1
d2128 1
a2128 3
		}
	else if (strcmp(arg,"-verify_depth") == 0)
		{
d2131 1
a2131 2
		else
			{
d2133 1
a2133 2
			if(depth < 0)
				{
a2135 1
				}
d2137 1
d2139 1
a2139 3
		}
	else if (strcmp(arg,"-attime") == 0)
		{
d2142 1
a2142 2
		else
			{
d2146 1
a2146 2
			if (sscanf(argn, "%li", &timestamp) != 1)
				{
d2148 2
a2149 2
						"Error parsing timestamp %s\n",
					   	argn);
d2151 1
a2151 1
				}
d2154 1
a2154 1
			}
d2156 1
a2156 2
		}
	else if (!strcmp(arg, "-ignore_critical"))
d2185 1
a2185 2
	if (*badarg)
		{
d2190 1
a2190 1
		}
d2192 1
a2192 2
	if (!*pm && !(*pm = X509_VERIFY_PARAM_new()))
		{
d2195 1
a2195 1
		}
d2208 1
a2208 1
	if (at_time) 
d2211 1
a2211 2
	end:

d2218 1
a2218 2

	}
d2224 3
a2226 2
int bio_to_mem(unsigned char **out, int maxlen, BIO *in)
	{
d2233 1
a2233 2
	for(;;)
		{
d2241 1
a2241 2
		if (BIO_write(mem, tbuf, len) != len)
			{
d2244 1
a2244 1
			}
d2249 1
a2249 1
		}
d2254 1
a2254 1
	}
d2256 3
a2258 2
int pkey_ctrl_string(EVP_PKEY_CTX *ctx, char *value)
	{
d2265 1
a2265 2
	if (vtmp)
		{
d2268 1
a2268 1
		}
d2272 1
a2272 1
	}
d2274 3
a2276 3
static void nodes_print(BIO *out, const char *name,
	STACK_OF(X509_POLICY_NODE) *nodes)
	{
d2280 1
a2280 2
	if (nodes)
		{
d2282 1
a2282 2
		for (i = 0; i < sk_X509_POLICY_NODE_num(nodes); i++)
			{
a2284 1
			}
d2286 1
a2286 1
	else
d2288 1
a2288 1
	}
d2290 3
a2292 2
void policies_print(BIO *out, X509_STORE_CTX *ctx)
	{
d2296 1
a2296 2
	if (out == NULL)
		{
d2299 1
a2299 1
		}
d2304 1
a2304 1
				explicit_policy ? "True" : "False");
d2310 1
a2310 1
	}
d2314 4
a2317 3
static JPAKE_CTX *jpake_init(const char *us, const char *them,
							 const char *secret)
	{
d2340 1
a2340 1
	}
d2342 3
a2344 2
static void jpake_send_part(BIO *conn, const JPAKE_STEP_PART *p)
	{
d2351 1
a2351 1
	}
d2353 3
a2355 2
static void jpake_send_step1(BIO *bconn, JPAKE_CTX *ctx)
	{
d2364 1
a2364 1
	}
d2366 3
a2368 2
static void jpake_send_step2(BIO *bconn, JPAKE_CTX *ctx)
	{
d2376 1
a2376 1
	}
d2378 3
a2380 2
static void jpake_send_step3a(BIO *bconn, JPAKE_CTX *ctx)
	{
d2388 1
a2388 1
	}
d2390 3
a2392 2
static void jpake_send_step3b(BIO *bconn, JPAKE_CTX *ctx)
	{
d2400 1
a2400 1
	}
d2402 3
a2404 2
static void readbn(BIGNUM **bn, BIO *bconn)
	{
d2410 2
a2411 2
	assert(buf[l-1] == '\n');
	buf[l-1] = '\0';
d2413 1
a2413 1
	}
d2415 3
a2417 2
static void jpake_receive_part(JPAKE_STEP_PART *p, BIO *bconn)
	{
d2421 1
a2421 1
	}
d2423 3
a2425 2
static void jpake_receive_step1(JPAKE_CTX *ctx, BIO *bconn)
	{
d2431 1
a2431 2
	if(!JPAKE_STEP1_process(ctx, &s1))
		{
d2434 1
a2434 1
		}
d2436 1
a2436 1
	}
d2438 3
a2440 2
static void jpake_receive_step2(JPAKE_CTX *ctx, BIO *bconn)
	{
d2445 1
a2445 2
	if(!JPAKE_STEP2_process(ctx, &s2))
		{
d2448 1
a2448 1
		}
d2450 1
a2450 1
	}
d2452 3
a2454 2
static void jpake_receive_step3a(JPAKE_CTX *ctx, BIO *bconn)
	{
d2461 1
a2461 2
	if(!JPAKE_STEP3A_process(ctx, &s3a))
		{
d2464 1
a2464 1
		}
d2466 1
a2466 1
	}
d2468 3
a2470 2
static void jpake_receive_step3b(JPAKE_CTX *ctx, BIO *bconn)
	{
d2477 1
a2477 2
	if(!JPAKE_STEP3B_process(ctx, &s3b))
		{
d2480 1
a2480 1
		}
d2482 1
a2482 1
	}
d2484 3
a2486 2
void jpake_client_auth(BIO *out, BIO *conn, const char *secret)
	{
d2512 1
a2512 1
	}
d2514 3
a2516 2
void jpake_server_auth(BIO *out, BIO *conn, const char *secret)
	{
d2542 1
a2542 1
	}
d2555 3
a2557 2
unsigned char *next_protos_parse(unsigned short *outlen, const char *in)
	{
d2570 3
a2572 6
	for (i = 0; i <= len; ++i)
		{
		if (i == len || in[i] == ',')
			{
			if (i - start > 255)
				{
d2575 1
a2575 1
				}
d2578 3
a2580 4
			}
		else
			out[i+1] = in[i];
		}
d2584 1
a2584 1
	}
d2599 4
a2602 3
static int WIN32_rename(const char *from, const char *to)
	{
	TCHAR  *tfrom=NULL,*tto;
d2604 1
a2604 1
	int	ret=0;
d2606 1
a2606 2
	if (sizeof(TCHAR) == 1)
		{
d2608 2
a2609 2
		tto   = (TCHAR *)to;
		}
d2611 6
a2616 5
		{
		size_t i,flen=strlen(from)+1,tlen=strlen(to)+1;
		tfrom = (TCHAR *)malloc(sizeof(TCHAR)*(flen+tlen));
		if (tfrom==NULL) goto err;
		tto=tfrom+flen;
d2618 1
a2618 1
		if (!MultiByteToWideChar(CP_ACP,0,from,flen,(WCHAR *)tfrom,flen))
d2620 1
a2620 1
			for (i=0;i<flen;i++)	tfrom[i]=(TCHAR)from[i];
d2622 1
a2622 1
		if (!MultiByteToWideChar(CP_ACP,0,to,  tlen,(WCHAR *)tto,  tlen))
d2624 1
a2624 1
			for (i=0;i<tlen;i++)	tto[i]  =(TCHAR)to[i];
d2627 5
a2631 5
	if (MoveFile(tfrom,tto))	goto ok;
	err=GetLastError();
	if (err==ERROR_ALREADY_EXISTS || err==ERROR_FILE_EXISTS)
		{
		if (DeleteFile(tto) && MoveFile(tfrom,tto))
d2633 3
a2635 3
		err=GetLastError();
		}
	if (err==ERROR_FILE_NOT_FOUND || err==ERROR_PATH_NOT_FOUND)
d2637 1
a2637 1
	else if (err==ERROR_ACCESS_DENIED)
d2642 1
a2642 1
	ret=-1;
d2644 3
a2646 3
	if (tfrom!=NULL && tfrom!=(TCHAR *)from)	free(tfrom);
	return ret;
	}
d2651 3
a2653 2
double app_tminterval(int stop,int usertime)
	{
d2655 1
a2655 1
	double			ret=0;
d2657 1
a2657 1
	static int		warning=1;
d2659 1
a2659 1
	static HANDLE		proc=NULL;
d2661 1
a2661 2
	if (proc==NULL)
		{
d2663 3
a2665 3
			proc = OpenProcess(PROCESS_QUERY_INFORMATION,FALSE,
						GetCurrentProcessId());
		if (proc==NULL) proc = (HANDLE)-1;
d2668 1
a2668 2
	if (usertime && proc!=(HANDLE)-1)
		{
d2670 2
a2671 3
		GetProcessTimes(proc,&junk,&junk,&junk,&now);
		}
	else
d2673 1
a2673 1
		{
d2676 5
a2680 6
		if (usertime && warning)
			{
			BIO_printf(bio_err,"To get meaningful results, run "
					   "this program on idle system.\n");
			warning=0;
			}
d2682 2
a2683 2
		SystemTimeToFileTime(&systime,&now);
		}
d2685 2
a2686 3
	if (stop==TM_START)
		{
		tmstart.u.LowPart  = now.dwLowDateTime;
d2688 1
a2688 1
		}
d2692 2
a2693 2
		tmstop.u.LowPart   = now.dwLowDateTime;
		tmstop.u.HighPart  = now.dwHighDateTime;
d2695 2
a2696 2
		ret = (__int64)(tmstop.QuadPart - tmstart.QuadPart)*1e-7;
		}
d2699 1
a2699 1
	}
d2704 4
a2707 3
double app_tminterval(int stop,int usertime)
	{
	double ret=0;
d2715 1
a2715 1
	static int warning=1;
d2717 5
a2721 6
	if (usertime && warning)
		{
		BIO_printf(bio_err,"To get meaningful results, run "
				   "this program on idle system.\n");
		warning=0;
		}
d2724 5
a2728 4
	clock_gettime(CLOCK_REALTIME,&now);
	if (stop==TM_START)	tmstart = now;
	else	ret = ( (now.tv_sec+now.tv_nsec*1e-9)
			- (tmstart.tv_sec+tmstart.tv_nsec*1e-9) );
d2731 4
a2734 2
	if (stop==TM_START)	tmstart = now;
	else			ret = (now - tmstart)/(double)sysClkRateGet();
d2737 1
a2737 1
	}
d2743 3
a2745 2
double app_tminterval(int stop,int usertime)
	{
d2753 2
a2754 1
	if (usertime)	now = rus.tms_utime;
d2760 1
a2760 1
		gettimeofday(&tv,NULL);
d2762 4
a2765 4
			(unsigned long long)tv.tv_sec*CLK_TCK +
			(unsigned long long)tv.tv_usec*(1000000/CLK_TCK)
			);
		}
d2767 4
a2770 2
	if (stop==TM_START)	tmstart = now;
	else			ret = (now - tmstart)/(double)(CLK_TCK);
d2773 1
a2773 1
	}
d2778 3
a2780 2
double app_tminterval(int stop,int usertime)
	{
d2786 2
a2787 1
	if (usertime)		now = rus.tms_utime;
d2789 3
a2791 3
	if (stop==TM_START)	tmstart = now;
	else
		{
d2794 1
a2794 1
		}
d2797 1
a2797 1
	}
d2803 3
a2805 2
double app_tminterval(int stop,int usertime)
	{
d2811 4
a2814 2
	if (usertime)		getrusage(RUSAGE_SELF,&rus), now = rus.ru_utime;
	else			gettimeofday(&now,NULL);
d2816 5
a2820 3
	if (stop==TM_START)	tmstart = now;
	else			ret = ( (now.tv_sec+now.tv_usec*1e-6)
					- (tmstart.tv_sec+tmstart.tv_usec*1e-6) );
d2823 1
a2823 1
	}
d2828 3
a2830 2
int app_isdir(const char *name)
	{
d2834 1
a2834 1
	size_t i, len_0 = strlen(name)+1;
d2840 1
a2840 1
	if (!MultiByteToWideChar(CP_ACP,0,name,len_0,FileData.cFileName,len_0))
d2842 2
a2843 2
		for (i=0;i<len_0;i++)
			FileData.cFileName[i] = (WCHAR)name[i];
d2845 1
a2845 1
	hList = FindFirstFile(FileData.cFileName,&FileData);
d2847 1
a2847 1
	hList = FindFirstFile(name,&FileData);
d2849 2
a2850 1
	if (hList == INVALID_HANDLE_VALUE)	return -1;
d2852 2
a2853 2
	return ((FileData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)!=0);
	}
d2859 1
a2859 1
# else 
d2861 2
a2862 2
# endif 
#endif 
d2864 3
a2866 2
int app_isdir(const char *name)
	{
d2870 4
a2873 2
	if (stat(name,&st)==0)	return S_ISDIR(st.st_mode);
	else			return -1;
d2877 1
a2877 1
	}
d2882 3
a2884 2
int raw_read_stdin(void *buf,int siz)
	{
d2886 1
a2886 1
	if (ReadFile(GetStdHandle(STD_INPUT_HANDLE),buf,siz,&n,NULL))
d2888 3
a2890 2
	else	return (-1);
	}
d2892 5
a2896 2
int raw_read_stdin(void *buf,int siz)
	{	return read(fileno(stdin),buf,siz);	}
d2900 3
a2902 2
int raw_write_stdout(const void *buf,int siz)
	{
d2904 1
a2904 1
	if (WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),buf,siz,&n,NULL))
d2906 3
a2908 2
	else	return (-1);
	}
d2910 5
a2914 2
int raw_write_stdout(const void *buf,int siz)
	{	return write(fileno(stdout),buf,siz);	}
@


1.23
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@a302 8
#if defined(OPENSSL_SYS_NETWARE)
   /* strip off trailing .nlm if present. */
   if ((n > 4) && (p[n-4] == '.') &&
      ((p[n-3] == 'n') || (p[n-3] == 'N')) &&
      ((p[n-2] == 'l') || (p[n-2] == 'L')) &&
      ((p[n-1] == 'm') || (p[n-1] == 'M')))
      n-=4;
#else
a308 1
#endif
a2780 22

	return (ret);
	}

#elif defined(OPENSSL_SYS_NETWARE)
#include <time.h>

double app_tminterval(int stop,int usertime)
	{
	double		ret=0;
	static clock_t	tmstart;
	static int	warning=1;

	if (usertime && warning)
		{
		BIO_printf(bio_err,"To get meaningful results, run "
				   "this program on idle system.\n");
		warning=0;
		}

	if (stop==TM_START)	tmstart = clock();
	else			ret     = (clock()-tmstart)/(double)CLOCKS_PER_SEC;
@


1.22
log
@Convert some BIO_snprintf() to (void) snprintf - as although these ones
save the return value, the value is actually ignored.
ok deraadt@@
@
text
@a111 6
#if !defined(_POSIX_C_SOURCE) && defined(OPENSSL_SYS_VMS)
#define _POSIX_C_SOURCE 2	/* On VMS, you need to define this to get
				   the declaration of fileno().  The value
				   2 is to make sure no function defined
				   in POSIX-2 is left undefined. */
#endif
a331 28
#ifdef OPENSSL_SYS_VMS
void program_name(char *in, char *out, int size)
	{
	char *p=in, *q;
	char *chars=":]>";

	while(*chars != '\0')
		{
		q=strrchr(p,*chars);
		if (q > p)
			p = q + 1;
		chars++;
		}

	q=strrchr(p,'.');
	if (q == NULL)
		q = p + strlen(p);
	strncpy(out,p,size-1);
	if (q-p >= size)
		{
		out[size-1]='\0';
		}
	else
		{
		out[q-p]='\0';
		}
	}
#else
a343 1
#endif
a1510 1
#ifndef OPENSSL_SYS_VMS
a1511 1
#endif
@


1.21
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@d1667 1
a1667 7
		{
#ifndef OPENSSL_SYS_VMS
		j = BIO_snprintf(buf[0], sizeof buf[0], "%s.%s", serialfile, suffix);
#else
		j = BIO_snprintf(buf[0], sizeof buf[0], "%s-%s", serialfile, suffix);
#endif
		}
d1716 1
a1716 2
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s.%s",
d1718 1
a1718 6
#else
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s-%s",
		serialfile, new_suffix);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s.%s",
a1719 4
#else
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s-%s",
		serialfile, old_suffix);
#endif
d1803 1
a1803 5
#ifndef OPENSSL_SYS_VMS
	BIO_snprintf(buf[0], sizeof buf[0], "%s.attr", dbfile);
#else
	BIO_snprintf(buf[0], sizeof buf[0], "%s-attr", dbfile);
#endif
d1898 3
a1900 15
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[2], sizeof buf[2], "%s.attr", dbfile);
#else
	j = BIO_snprintf(buf[2], sizeof buf[2], "%s-attr", dbfile);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s.attr.%s", dbfile, suffix);
#else
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s-attr-%s", dbfile, suffix);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s.%s", dbfile, suffix);
#else
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s-%s", dbfile, suffix);
#endif
d1948 2
a1949 14
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[4], sizeof buf[4], "%s.attr", dbfile);
#else
	j = BIO_snprintf(buf[4], sizeof buf[4], "%s-attr", dbfile);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[2], sizeof buf[2], "%s.attr.%s",
		dbfile, new_suffix);
#else
	j = BIO_snprintf(buf[2], sizeof buf[2], "%s-attr-%s",
		dbfile, new_suffix);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s.%s",
d1951 1
a1951 2
#else
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s-%s",
d1953 1
a1953 6
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s.%s",
		dbfile, old_suffix);
#else
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s-%s",
d1955 1
a1955 3
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[3], sizeof buf[3], "%s.attr.%s",
a1956 4
#else
	j = BIO_snprintf(buf[3], sizeof buf[3], "%s-attr-%s",
		dbfile, old_suffix);
#endif
@


1.20
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d1593 1
a1593 1
	MS_STATIC char buf[1024];
@


1.19
log
@resolve conflicts
@
text
@d589 1
a589 1
				PW_MIN_LENGTH,BUFSIZ-1);
d594 1
a594 1
				PW_MIN_LENGTH,BUFSIZ-1, buf);
d2135 1
a2135 1
	if (!buf || !ne_types || !ne_values)
d2239 1
d2248 2
d2844 1
a2844 1
		if (GetVersion() < 0x80000000)
@


1.18
log
@openssl-1.0.0e: resolve conflicts
@
text
@d112 1
a112 1
#ifndef _POSIX_C_SOURCE
d1218 2
a1219 1
	load_certs_crls(err, file, format, pass, e, desc, &certs, NULL);
d1227 2
a1228 1
	load_certs_crls(err, file, format, pass, e, desc, NULL, &crls);
d2261 1
d2314 21
d2389 3
d2722 44
@


1.17
log
@resolve conflicts, fix local changes
@
text
@d260 2
d382 1
a382 1
	int num,len,i;
a387 1
	len=strlen(buf);
d801 1
d803 1
d904 1
d906 1
d995 1
d997 1
@


1.16
log
@resolve conflicts
@
text
@d112 6
d121 3
a124 1
#include <sys/stat.h>
d126 1
d150 5
a182 3
	struct stat stbuf;

	if (stat(file,&stbuf) < 0) return(0);
d188 9
a199 1
	len=(unsigned int)stbuf.st_size;
d264 6
a269 6
	else if ((*s == 'P') || (*s == 'p'))
		return(FORMAT_PEM);
	else if ((*s == 'N') || (*s == 'n'))
		return(FORMAT_NETSCAPE);
	else if ((*s == 'S') || (*s == 's'))
		return(FORMAT_SMIME);
d276 7
d668 9
d688 1
a787 2
	ASN1_HEADER *ah=NULL;
	BUF_MEM *buf=NULL;
d799 1
d801 1
d819 3
a821 17
		const unsigned char *p,*op;
		int size=0,i;

		/* We sort of have to do it this way because it is sort of nice
		 * to read the header first and check it, then
		 * try to read the certificate */
		buf=BUF_MEM_new();
		for (;;)
			{
			if ((buf == NULL) || (!BUF_MEM_grow(buf,size+1024*10)))
				goto end;
			i=BIO_read(cert,&(buf->data[size]),1024*10);
			size+=i;
			if (i == 0) break;
			if (i < 0)
				{
				perror("reading certificate");
a822 4
				}
			}
		p=(unsigned char *)buf->data;
		op=p;
d824 2
a825 6
		/* First load the header */
		if ((ah=d2i_ASN1_HEADER(NULL,&p,(long)size)) == NULL)
			goto end;
		if ((ah->header == NULL) || (ah->header->data == NULL) ||
			(strncmp(NETSCAPE_CERT_HDR,(char *)ah->header->data,
			ah->header->length) != 0))
d827 1
d831 3
a833 7
		/* header is ok, so now read the object */
		p=op;
		ah->meth=X509_asn1_meth();
		if ((ah=d2i_ASN1_HEADER(&ah,&p,(long)size)) == NULL)
			goto end;
		x=(X509 *)ah->data;
		ah->data=NULL;
a854 1
	if (ah != NULL) ASN1_HEADER_free(ah);
a855 1
	if (buf != NULL) BUF_MEM_free(buf);
d878 1
a878 1
			BIO_printf(bio_err,"no engine specified\n");
d880 1
d883 6
d900 1
d902 1
d933 7
d947 2
a948 1
	if (pkey == NULL)
d950 2
d989 1
d991 1
d1006 31
d1046 4
d1108 3
a1110 2
STACK_OF(X509) *load_certs(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *cert_descrip)
a1111 1
	BIO *certs;
d1113 2
a1114 2
	STACK_OF(X509) *othercerts = NULL;
	STACK_OF(X509_INFO) *allcerts = NULL;
d1117 1
d1122 1
a1122 1
	if((certs = BIO_new(BIO_s_file())) == NULL)
d1124 2
a1125 2
		ERR_print_errors(err);
		goto end;
d1129 1
a1129 1
		BIO_set_fp(certs,stdin,BIO_NOCLOSE);
d1131 23
d1155 2
a1156 5
		if (BIO_read_filename(certs,file) <= 0)
			{
			BIO_printf(err, "Error opening %s %s\n",
				cert_descrip, file);
			ERR_print_errors(err);
a1157 1
			}
d1160 1
a1160 1
	if      (format == FORMAT_PEM)
d1162 2
a1163 2
		othercerts = sk_X509_new_null();
		if(!othercerts)
d1165 3
a1167 3
			sk_X509_free(othercerts);
			othercerts = NULL;
			goto end;
d1169 1
a1169 3
		allcerts = PEM_X509_INFO_read_bio(certs, NULL,
				(pem_password_cb *)password_callback, &cb_data);
		for(i = 0; i < sk_X509_INFO_num(allcerts); i++)
d1171 3
a1173 6
			xi = sk_X509_INFO_value (allcerts, i);
			if (xi->x509)
				{
				sk_X509_push(othercerts, xi->x509);
				xi->x509 = NULL;
				}
a1174 1
		goto end;
d1176 13
a1188 7
	else	{
		BIO_printf(err,"bad input format specified for %s\n",
			cert_descrip);
		goto end;
		}
end:
	if (othercerts == NULL)
d1190 12
a1201 1
		BIO_printf(err,"unable to load certificates\n");
d1204 1
a1204 3
	if (allcerts) sk_X509_INFO_pop_free(allcerts, X509_INFO_free);
	if (certs != NULL) BIO_free(certs);
	return(othercerts);
d1207 15
d1508 4
d1545 1
a1545 1
static unsigned long index_serial_hash(const char **a)
d1554 1
a1554 1
static int index_serial_cmp(const char **a, const char **b)
d1566 1
a1566 1
static unsigned long index_name_hash(const char **a)
d1569 7
a1575 8
int index_name_cmp(const char **a, const char **b)
	{ return(strcmp(a[DB_name],
	     b[DB_name])); }

static IMPLEMENT_LHASH_HASH_FN(index_serial_hash,const char **)
static IMPLEMENT_LHASH_COMP_FN(index_serial_cmp,const char **)
static IMPLEMENT_LHASH_HASH_FN(index_name_hash,const char **)
static IMPLEMENT_LHASH_COMP_FN(index_name_cmp,const char **)
a1702 1
	struct stat sb;
d1727 5
a1731 3
	if (stat(serialfile,&sb) < 0)
		{
		if (errno != ENOENT 
d1735 1
a1735 11
		   )
			goto err;
		}
	else
		{
#ifdef RL_DEBUG
		BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
			serialfile, buf[1]);
#endif
		if (rename(serialfile,buf[1]) < 0)
			{
a1741 1
		}
a1807 2
		{
		if (tmpdb != NULL) TXT_DB_free(tmpdb);
a1808 1
		}
d1869 2
a1870 2
				LHASH_HASH_FN(index_serial_hash),
				LHASH_COMP_FN(index_serial_cmp)))
d1880 2
a1881 2
			LHASH_HASH_FN(index_name_hash),
			LHASH_COMP_FN(index_name_cmp)))
a1960 1
	struct stat sb;
d2004 5
a2008 3
	if (stat(dbfile,&sb) < 0)
		{
		if (errno != ENOENT 
d2010 1
a2010 10
			&& errno != ENOTDIR
#endif
		   )
			goto err;
		}
	else
		{
#ifdef RL_DEBUG
		BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
			dbfile, buf[1]);
d2012 1
a2012 2
		if (rename(dbfile,buf[1]) < 0)
			{
a2018 1
		}
d2032 5
a2036 3
	if (stat(buf[4],&sb) < 0)
		{
		if (errno != ENOENT 
d2038 1
a2038 10
			&& errno != ENOTDIR
#endif
		   )
			goto err;
		}
	else
		{
#ifdef RL_DEBUG
		BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
			buf[4],buf[3]);
d2040 1
a2040 2
		if (rename(buf[4],buf[3]) < 0)
			{
a2048 1
		}
a2242 39
/* This code MUST COME AFTER anything that uses rename() */
#ifdef OPENSSL_SYS_WIN32
int WIN32_rename(const char *from, const char *to)
	{
#ifndef OPENSSL_SYS_WINCE
	/* Windows rename gives an error if 'to' exists, so delete it
	 * first and ignore file not found errror
	 */
	if((remove(to) != 0) && (errno != ENOENT))
		return -1;
#undef rename
	return rename(from, to);
#else
	/* convert strings to UNICODE */
	{
	BOOL result = FALSE;
	WCHAR* wfrom;
	WCHAR* wto;
	int i;
	wfrom = malloc((strlen(from)+1)*2);
	wto = malloc((strlen(to)+1)*2);
	if (wfrom != NULL && wto != NULL)
		{
		for (i=0; i<(int)strlen(from)+1; i++)
			wfrom[i] = (short)from[i];
		for (i=0; i<(int)strlen(to)+1; i++)
			wto[i] = (short)to[i];
		result = MoveFile(wfrom, wto);
		}
	if (wfrom != NULL)
		free(wfrom);
	if (wto != NULL)
		free(wto);
	return result;
	}
#endif
	}
#endif

d2249 1
a2249 1
	int purpose = 0;
d2289 15
d2316 4
d2322 4
d2328 2
d2355 3
d2369 55
d2465 1
a2465 1
#ifndef OPENSSL_NO_JPAKE
d2648 3
a2650 8
	/*
	 * The problem is that you must use the derived key in the
	 * session key or you are subject to man-in-the-middle
	 * attacks.
	 */
	BIO_puts(out, "JPAKE authentication succeeded (N.B. This version can"
		 " be MitMed. See the version in HEAD for how to do it"
		 " properly)\n");
d2654 2
d2677 3
a2679 8
	/*
	 * The problem is that you must use the derived key in the
	 * session key or you are subject to man-in-the-middle
	 * attacks.
	 */
	BIO_puts(out, "JPAKE authentication succeeded (N.B. This version can"
		 " be MitMed. See the version in HEAD for how to do it"
		 " properly)\n");
d2683 2
d2687 326
@


1.15
log
@resolve conflicts
@
text
@d2431 1
a2431 1
	assert(l >= 0);
@


1.14
log
@resolve conflicts
@
text
@d118 1
d133 3
d2340 230
@


1.13
log
@resolve conflicts
@
text
@d128 4
d138 1
a138 1
	char *name;
d257 1
a257 1
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)
d276 9
d291 2
d779 1
a779 1
		unsigned char *p,*op;
d1281 1
a1281 1
void print_name(BIO *out, char *title, X509_NAME *nm, unsigned long lflags)
d1749 1
d1751 2
a1752 16
			switch(*p)
				{
			case 'f': /* false */
			case 'F': /* FALSE */
			case 'n': /* no */
			case 'N': /* NO */
				retdb->attributes.unique_subject = 0;
				break;
			case 't': /* true */
			case 'T': /* TRUE */
			case 'y': /* yes */
			case 'Y': /* YES */
			default:
				retdb->attributes.unique_subject = 1;
				break;
				}
d1787 1
a1787 1
int save_index(char *dbfile, char *suffix, CA_DB *db)
d1854 1
a1854 1
int rotate_index(char *dbfile, char *new_suffix, char *old_suffix)
d1994 165
d2161 1
a2161 1
int WIN32_rename(char *from, char *to)
d2197 139
@


1.12
log
@resolve conflicts
@
text
@d364 11
a374 4
			arg->count+=20;
			arg->data=(char **)OPENSSL_realloc(arg->data,
				sizeof(char *)*arg->count);
			if (argc == 0) return(0);
d1601 1
a1601 1
			&& errno != ENOTDIR)
d1603 1
d1904 1
a1904 1
			&& errno != ENOTDIR)
d1906 1
d1941 1
a1941 1
			&& errno != ENOTDIR)
d1943 1
@


1.11
log
@avoid NULL deref; from danh@@
@
text
@a128 10
#ifdef OPENSSL_SYS_WINDOWS
#define strcasecmp _stricmp
#else
#  ifdef NO_STRINGS_H
    int	strcasecmp();
#  else
#    include <strings.h>
#  endif /* NO_STRINGS_H */
#endif

a332 54
#ifdef OPENSSL_SYS_WIN32
int WIN32_rename(char *from, char *to)
	{
#ifndef OPENSSL_SYS_WINCE
	/* Windows rename gives an error if 'to' exists, so delete it
	 * first and ignore file not found errror
	 */
	if((remove(to) != 0) && (errno != ENOENT))
		return -1;
#undef rename
	return rename(from, to);
#else
	/* convert strings to UNICODE */
	{
	BOOL result = FALSE;
	WCHAR* wfrom;
	WCHAR* wto;
	int i;
	wfrom = malloc((strlen(from)+1)*2);
	wto = malloc((strlen(to)+1)*2);
	if (wfrom != NULL && wto != NULL)
		{
		for (i=0; i<(int)strlen(from)+1; i++)
			wfrom[i] = (short)from[i];
		for (i=0; i<(int)strlen(to)+1; i++)
			wto[i] = (short)to[i];
		result = MoveFile(wfrom, wto);
		}
	if (wfrom != NULL)
		free(wfrom);
	if (wto != NULL)
		free(wto);
	return result;
	}
#endif
	}
#endif

#ifdef OPENSSL_SYS_VMS
int VMS_strcasecmp(const char *str1, const char *str2)
	{
	while (*str1 && *str2)
		{
		int res = toupper(*str1) - toupper(*str2);
		if (res) return res < 0 ? -1 : 1;
		}
	if (*str1)
		return 1;
	if (*str2)
		return -1;
	return 0;
	}
#endif

d529 1
a529 1
			cb_data->prompt_info);
d678 45
d803 3
a805 5
		PKCS12 *p12 = d2i_PKCS12_bio(cert, NULL);

		PKCS12_parse(p12, NULL, NULL, &x, NULL);
		PKCS12_free(p12);
		p12 = NULL;
d884 4
a887 5
		PKCS12 *p12 = d2i_PKCS12_bio(key, NULL);

		PKCS12_parse(p12, pass, &pkey, NULL, NULL);
		PKCS12_free(p12);
		p12 = NULL;
a1466 1
			ASN1_INTEGER_set(ai,1);
d1468 1
a1468 1
			if (ret == NULL)
a1469 2
			else
				BN_one(ret);
d1631 27
d1975 1
a1975 1
	if (db != NULL)
d1977 1
a1977 1
		TXT_DB_free(db->db);
d1981 39
@


1.10
log
@merge 0.9.7d
@
text
@d1973 5
a1977 2
	TXT_DB_free(db->db);
	OPENSSL_free(db);
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d504 1
a504 1
			if (password[0] != '\0')
d528 1
a528 1
			if (password[0] != '\0')
d1419 1
a1419 1
	strlcpy(p,t,len);
d1421 1
a1421 1
	strlcat(p,"/",len);
d1423 1
a1423 1
	strlcat(p,OPENSSL_CONF,len);
d1426 549
@


1.8
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d117 1
a117 3
#define NON_MAIN
#include "apps.h"
#undef NON_MAIN
d125 1
d127 1
d139 3
a141 3
#ifdef OPENSSL_SYS_WINDOWS
#  include "bss_file.c"
#endif
d338 1
a338 2
	strncpy(out,p,size-1);
	out[size-1]='\0';
d346 1
d354 40
d472 3
a474 2
	char buf[256];
	X509_NAME_oneline(X509_get_subject_name(x),buf,256);
d476 2
a477 1
	BIO_puts(out,buf);
d479 3
a481 3
	X509_NAME_oneline(X509_get_issuer_name(x),buf,256);
	BIO_puts(out,"\nissuer= ");
	BIO_puts(out,buf);
d483 3
a485 1
        return 0;
d616 1
a616 1
			memset(buff,0,(unsigned int)bufsiz);
d626 1
a626 1
			memset(buf,0,(unsigned int)bufsiz);
d632 1
a632 1
			memset(buf,0,(unsigned int)bufsiz);
d860 1
d870 1
d938 1
d948 1
d1011 1
a1011 1
		if (!BUF_MEM_grow(buf,size+1024*10))
d1286 1
d1334 1
d1391 1
d1409 17
@


1.7
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d801 1
a801 1
EVP_PKEY *load_key(BIO *err, const char *file, int format,
d811 1
a811 1
	if (file == NULL)
d831 1
a831 1
	if (BIO_read_filename(key,file) <= 0)
d833 2
a834 3
		BIO_printf(err, "Error opening %s %s\n", key_descrip, file);
		ERR_print_errors(err);
		goto end;
d836 8
d877 1
a877 1
EVP_PKEY *load_pubkey(BIO *err, const char *file, int format,
d887 1
a887 1
	if (file == NULL)
d907 1
a907 1
	if (BIO_read_filename(key,file) <= 0)
d909 10
a918 3
		BIO_printf(err, "Error opening %s %s\n", key_descrip, file);
		ERR_print_errors(err);
		goto end;
d1091 1
@


1.6
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d132 5
a136 1
#include <strings.h>
d497 1
a497 1
int setup_ui_method()
d506 1
a506 1
void destroy_ui_method()
d932 1
a932 1
EVP_PKEY *
d1220 1
a1220 1
	char buf[256];
d1229 2
a1230 2
		X509_NAME_oneline(nm,buf,256);
		BIO_puts(out,buf);
d1232 1
d1271 1
a1271 1
ENGINE *try_load_engine(BIO *err, const char *engine, int debug)
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d313 10
a322 3
		q = in+size;
	strncpy(out,p,q-p);
	out[q-p]='\0';
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d58 53
d122 1
d125 1
d127 1
d129 7
a135 1
#ifdef WINDOWS
d139 18
d259 1
a259 1
#if defined(MSDOS) || defined(WIN32) || defined(WIN16)
d297 1
a297 1
#ifdef VMS
d333 1
a333 1
#ifdef WIN32
d336 7
a342 10
#ifdef WINNT
	int ret;
/* Note: MoveFileEx() doesn't work under Win95, Win98 */

	ret=MoveFileEx(from,to,MOVEFILE_REPLACE_EXISTING|MOVEFILE_COPY_ALLOWED);
	return(ret?0:-1);
#else
	unlink(to);
	return MoveFile(from, to);
#endif
d433 153
d661 1
a661 1
int add_oid_section(BIO *err, LHASH *conf)
d667 6
a672 2
	if(!(p=CONF_get_string(conf,NULL,"oid_section"))) return 1;
	if(!(sktmp = CONF_get_section(conf, p))) {
d687 2
a688 1
X509 *load_cert(BIO *err, char *file, int format)
d702 2
d705 1
d710 3
a712 1
			perror(file);
d763 2
a764 1
		x=PEM_read_bio_X509_AUX(cert,NULL,NULL,NULL);
d774 2
a775 1
		BIO_printf(err,"bad input format specified for input cert\n");
d790 2
a791 1
EVP_PKEY *load_key(BIO *err, char *file, int format, char *pass)
d795 4
d805 9
d822 2
a823 1
		perror(file);
d832 2
a833 1
		pkey=PEM_read_bio_PrivateKey(key,NULL,NULL,pass);
d835 4
d849 1
a849 1
		BIO_printf(err,"bad input format specified for key\n");
d855 1
a855 1
		BIO_printf(err,"unable to load Private Key\n");
d859 2
a860 1
EVP_PKEY *load_pubkey(BIO *err, char *file, int format)
d864 4
d874 9
d891 2
a892 1
		perror(file);
d901 2
a902 1
		pkey=PEM_read_bio_PUBKEY(key,NULL,NULL,NULL);
d904 4
d910 1
a910 1
		BIO_printf(err,"bad input format specified for key\n");
d916 1
a916 1
		BIO_printf(err,"unable to load Public Key\n");
d920 48
a967 1
STACK_OF(X509) *load_certs(BIO *err, char *file, int format)
d974 4
d991 3
a993 1
			perror(file);
d1007 2
a1008 1
		allcerts = PEM_X509_INFO_read_bio(certs, NULL, NULL, NULL);
d1021 2
a1022 1
		BIO_printf(err,"bad input format specified for input cert\n");
d1036 38
a1073 5
typedef struct {
	char *name;
	unsigned long flag;
	unsigned long mask;
} NAME_EX_TBL;
d1077 1
a1077 2
	char c;
	const NAME_EX_TBL *ptbl, ex_tbl[] = {
d1097 1
d1104 1
d1107 50
d1158 28
d1196 2
a1197 2
	for(ptbl = ex_tbl; ptbl->name; ptbl++) {
		if(!strcmp(arg, ptbl->name)) {
d1228 104
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d67 5
d99 2
a100 2
	if (buf != NULL) Free(buf);
	buf=(char *)Malloc(len+1);
d110 2
a111 2
	if (arg != NULL) Free(arg);
	arg=(char **)Malloc(sizeof(char *)*(i*2));
d167 8
d282 1
a282 1
		arg->data=(char **)Malloc(sizeof(char *)*arg->count);
d301 1
a301 1
			arg->data=(char **)Realloc(arg->data,
d430 349
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d327 90
@


1.1
log
@Initial revision
@
text
@a71 1
#ifndef NOPROTO
a72 4
#else
int app_init();
#endif

d74 1
a74 4
int args_from_file(file,argc,argv)
char *file;
int *argc;
char **argv[];
d152 1
a152 2
int str2fmt(s)
char *s;
d167 1
a167 4
void program_name(in,out,size)
char *in;
char *out;
int size;
d204 22
a225 4
void program_name(in,out,size)
char *in;
char *out;
int size;
d238 1
d241 1
a241 3
int WIN32_rename(from,to)
char *from;
char *to;
d243 1
d245 1
d249 4
d256 1
a256 5
int chopup_args(arg,buf,argc,argv)
ARGS *arg;
char *buf;
int *argc;
char **argv[];
d322 1
a322 2
int app_init(mesgwin)
long mesgwin;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
a66 8
#include <openssl/err.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/pem.h>
#include <openssl/pkcs12.h>
#include <openssl/ui.h>
#include <openssl/safestack.h>
#include <openssl/engine.h>
d68 1
a68 7
#ifdef OPENSSL_SYS_WINDOWS
#define strcasecmp _stricmp
#else
#include <strings.h>
#endif

#ifdef OPENSSL_SYS_WINDOWS
d72 4
a75 16
typedef struct {
	char *name;
	unsigned long flag;
	unsigned long mask;
} NAME_EX_TBL;

static UI_METHOD *ui_method = NULL;

static int set_table_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl);
static int set_multi_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl);

#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)
/* Looks like this stuff is worth moving into separate function */
static EVP_PKEY *
load_netscape_key(BIO *err, BIO *key, const char *file,
		const char *key_descrip, int format);
a77 1
int app_init(long mesgwin);
d79 4
a82 1
int args_from_file(char *file, int *argc, char **argv[])
d102 2
a103 2
	if (buf != NULL) OPENSSL_free(buf);
	buf=(char *)OPENSSL_malloc(len+1);
d113 2
a114 2
	if (arg != NULL) OPENSSL_free(arg);
	arg=(char **)OPENSSL_malloc(sizeof(char *)*(i*2));
d160 2
a161 1
int str2fmt(char *s)
a170 8
	else if ((*s == 'S') || (*s == 's'))
		return(FORMAT_SMIME);
	else if ((*s == '1')
		|| (strcmp(s,"PKCS12") == 0) || (strcmp(s,"pkcs12") == 0)
		|| (strcmp(s,"P12") == 0) || (strcmp(s,"p12") == 0))
		return(FORMAT_PKCS12);
	else if ((*s == 'E') || (*s == 'e'))
		return(FORMAT_ENGINE);
d175 5
a179 2
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)
void program_name(char *in, char *out, int size)
d216 4
a219 29
#ifdef OPENSSL_SYS_VMS
void program_name(char *in, char *out, int size)
	{
	char *p=in, *q;
	char *chars=":]>";

	while(*chars != '\0')
		{
		q=strrchr(p,*chars);
		if (q > p)
			p = q + 1;
		chars++;
		}

	q=strrchr(p,'.');
	if (q == NULL)
		q = p + strlen(p);
	strncpy(out,p,size-1);
	if (q-p >= size)
		{
		out[size-1]='\0';
		}
	else
		{
		out[q-p]='\0';
		}
	}
#else
void program_name(char *in, char *out, int size)
a231 1
#endif
d233 4
a236 2
#ifdef OPENSSL_SYS_WIN32
int WIN32_rename(char *from, char *to)
d238 4
a241 7
	/* Windows rename gives an error if 'to' exists, so delete it
	 * first and ignore file not found errror
	 */
	if((remove(to) != 0) && (errno != ENOENT))
		return -1;
#undef rename
	return rename(from, to);
d245 5
a249 1
int chopup_args(ARGS *arg, char *buf, int *argc, char **argv[])
d262 1
a262 1
		arg->data=(char **)OPENSSL_malloc(sizeof(char *)*arg->count);
d281 1
a281 1
			arg->data=(char **)OPENSSL_realloc(arg->data,
d315 2
a316 1
int app_init(long mesgwin)
a320 915


int dump_cert_text (BIO *out, X509 *x)
{
	char buf[256];
	X509_NAME_oneline(X509_get_subject_name(x),buf,256);
	BIO_puts(out,"subject=");
	BIO_puts(out,buf);

	X509_NAME_oneline(X509_get_issuer_name(x),buf,256);
	BIO_puts(out,"\nissuer= ");
	BIO_puts(out,buf);
	BIO_puts(out,"\n");
        return 0;
}

static int ui_open(UI *ui)
	{
	return UI_method_get_opener(UI_OpenSSL())(ui);
	}
static int ui_read(UI *ui, UI_STRING *uis)
	{
	if (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD
		&& UI_get0_user_data(ui))
		{
		switch(UI_get_string_type(uis))
			{
		case UIT_PROMPT:
		case UIT_VERIFY:
			{
			const char *password =
				((PW_CB_DATA *)UI_get0_user_data(ui))->password;
			if (password[0] != '\0')
				{
				UI_set_result(ui, uis, password);
				return 1;
				}
			}
		default:
			break;
			}
		}
	return UI_method_get_reader(UI_OpenSSL())(ui, uis);
	}
static int ui_write(UI *ui, UI_STRING *uis)
	{
	if (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD
		&& UI_get0_user_data(ui))
		{
		switch(UI_get_string_type(uis))
			{
		case UIT_PROMPT:
		case UIT_VERIFY:
			{
			const char *password =
				((PW_CB_DATA *)UI_get0_user_data(ui))->password;
			if (password[0] != '\0')
				return 1;
			}
		default:
			break;
			}
		}
	return UI_method_get_writer(UI_OpenSSL())(ui, uis);
	}
static int ui_close(UI *ui)
	{
	return UI_method_get_closer(UI_OpenSSL())(ui);
	}
int setup_ui_method()
	{
	ui_method = UI_create_method("OpenSSL application user interface");
	UI_method_set_opener(ui_method, ui_open);
	UI_method_set_reader(ui_method, ui_read);
	UI_method_set_writer(ui_method, ui_write);
	UI_method_set_closer(ui_method, ui_close);
	return 0;
	}
void destroy_ui_method()
	{
	if(ui_method)
		{
		UI_destroy_method(ui_method);
		ui_method = NULL;
		}
	}
int password_callback(char *buf, int bufsiz, int verify,
	PW_CB_DATA *cb_tmp)
	{
	UI *ui = NULL;
	int res = 0;
	const char *prompt_info = NULL;
	const char *password = NULL;
	PW_CB_DATA *cb_data = (PW_CB_DATA *)cb_tmp;

	if (cb_data)
		{
		if (cb_data->password)
			password = cb_data->password;
		if (cb_data->prompt_info)
			prompt_info = cb_data->prompt_info;
		}

	if (password)
		{
		res = strlen(password);
		if (res > bufsiz)
			res = bufsiz;
		memcpy(buf, password, res);
		return res;
		}

	ui = UI_new_method(ui_method);
	if (ui)
		{
		int ok = 0;
		char *buff = NULL;
		int ui_flags = 0;
		char *prompt = NULL;

		prompt = UI_construct_prompt(ui, "pass phrase",
			cb_data->prompt_info);

		ui_flags |= UI_INPUT_FLAG_DEFAULT_PWD;
		UI_ctrl(ui, UI_CTRL_PRINT_ERRORS, 1, 0, 0);

		if (ok >= 0)
			ok = UI_add_input_string(ui,prompt,ui_flags,buf,
				PW_MIN_LENGTH,BUFSIZ-1);
		if (ok >= 0 && verify)
			{
			buff = (char *)OPENSSL_malloc(bufsiz);
			ok = UI_add_verify_string(ui,prompt,ui_flags,buff,
				PW_MIN_LENGTH,BUFSIZ-1, buf);
			}
		if (ok >= 0)
			do
				{
				ok = UI_process(ui);
				}
			while (ok < 0 && UI_ctrl(ui, UI_CTRL_IS_REDOABLE, 0, 0, 0));

		if (buff)
			{
			memset(buff,0,(unsigned int)bufsiz);
			OPENSSL_free(buff);
			}

		if (ok >= 0)
			res = strlen(buf);
		if (ok == -1)
			{
			BIO_printf(bio_err, "User interface error\n");
			ERR_print_errors(bio_err);
			memset(buf,0,(unsigned int)bufsiz);
			res = 0;
			}
		if (ok == -2)
			{
			BIO_printf(bio_err,"aborted!\n");
			memset(buf,0,(unsigned int)bufsiz);
			res = 0;
			}
		UI_free(ui);
		OPENSSL_free(prompt);
		}
	return res;
	}

static char *app_get_pass(BIO *err, char *arg, int keepbio);

int app_passwd(BIO *err, char *arg1, char *arg2, char **pass1, char **pass2)
{
	int same;
	if(!arg2 || !arg1 || strcmp(arg1, arg2)) same = 0;
	else same = 1;
	if(arg1) {
		*pass1 = app_get_pass(err, arg1, same);
		if(!*pass1) return 0;
	} else if(pass1) *pass1 = NULL;
	if(arg2) {
		*pass2 = app_get_pass(err, arg2, same ? 2 : 0);
		if(!*pass2) return 0;
	} else if(pass2) *pass2 = NULL;
	return 1;
}

static char *app_get_pass(BIO *err, char *arg, int keepbio)
{
	char *tmp, tpass[APP_PASS_LEN];
	static BIO *pwdbio = NULL;
	int i;
	if(!strncmp(arg, "pass:", 5)) return BUF_strdup(arg + 5);
	if(!strncmp(arg, "env:", 4)) {
		tmp = getenv(arg + 4);
		if(!tmp) {
			BIO_printf(err, "Can't read environment variable %s\n", arg + 4);
			return NULL;
		}
		return BUF_strdup(tmp);
	}
	if(!keepbio || !pwdbio) {
		if(!strncmp(arg, "file:", 5)) {
			pwdbio = BIO_new_file(arg + 5, "r");
			if(!pwdbio) {
				BIO_printf(err, "Can't open file %s\n", arg + 5);
				return NULL;
			}
		} else if(!strncmp(arg, "fd:", 3)) {
			BIO *btmp;
			i = atoi(arg + 3);
			if(i >= 0) pwdbio = BIO_new_fd(i, BIO_NOCLOSE);
			if((i < 0) || !pwdbio) {
				BIO_printf(err, "Can't access file descriptor %s\n", arg + 3);
				return NULL;
			}
			/* Can't do BIO_gets on an fd BIO so add a buffering BIO */
			btmp = BIO_new(BIO_f_buffer());
			pwdbio = BIO_push(btmp, pwdbio);
		} else if(!strcmp(arg, "stdin")) {
			pwdbio = BIO_new_fp(stdin, BIO_NOCLOSE);
			if(!pwdbio) {
				BIO_printf(err, "Can't open BIO for stdin\n");
				return NULL;
			}
		} else {
			BIO_printf(err, "Invalid password argument \"%s\"\n", arg);
			return NULL;
		}
	}
	i = BIO_gets(pwdbio, tpass, APP_PASS_LEN);
	if(keepbio != 1) {
		BIO_free_all(pwdbio);
		pwdbio = NULL;
	}
	if(i <= 0) {
		BIO_printf(err, "Error reading password from BIO\n");
		return NULL;
	}
	tmp = strchr(tpass, '\n');
	if(tmp) *tmp = 0;
	return BUF_strdup(tpass);
}

int add_oid_section(BIO *err, CONF *conf)
{	
	char *p;
	STACK_OF(CONF_VALUE) *sktmp;
	CONF_VALUE *cnf;
	int i;
	if(!(p=NCONF_get_string(conf,NULL,"oid_section")))
		{
		ERR_clear_error();
		return 1;
		}
	if(!(sktmp = NCONF_get_section(conf, p))) {
		BIO_printf(err, "problem loading oid section %s\n", p);
		return 0;
	}
	for(i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {
		cnf = sk_CONF_VALUE_value(sktmp, i);
		if(OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {
			BIO_printf(err, "problem creating object %s=%s\n",
							 cnf->name, cnf->value);
			return 0;
		}
	}
	return 1;
}

X509 *load_cert(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *cert_descrip)
	{
	ASN1_HEADER *ah=NULL;
	BUF_MEM *buf=NULL;
	X509 *x=NULL;
	BIO *cert;

	if ((cert=BIO_new(BIO_s_file())) == NULL)
		{
		ERR_print_errors(err);
		goto end;
		}

	if (file == NULL)
		{
		setvbuf(stdin, NULL, _IONBF, 0);
		BIO_set_fp(cert,stdin,BIO_NOCLOSE);
		}
	else
		{
		if (BIO_read_filename(cert,file) <= 0)
			{
			BIO_printf(err, "Error opening %s %s\n",
				cert_descrip, file);
			ERR_print_errors(err);
			goto end;
			}
		}

	if 	(format == FORMAT_ASN1)
		x=d2i_X509_bio(cert,NULL);
	else if (format == FORMAT_NETSCAPE)
		{
		unsigned char *p,*op;
		int size=0,i;

		/* We sort of have to do it this way because it is sort of nice
		 * to read the header first and check it, then
		 * try to read the certificate */
		buf=BUF_MEM_new();
		for (;;)
			{
			if ((buf == NULL) || (!BUF_MEM_grow(buf,size+1024*10)))
				goto end;
			i=BIO_read(cert,&(buf->data[size]),1024*10);
			size+=i;
			if (i == 0) break;
			if (i < 0)
				{
				perror("reading certificate");
				goto end;
				}
			}
		p=(unsigned char *)buf->data;
		op=p;

		/* First load the header */
		if ((ah=d2i_ASN1_HEADER(NULL,&p,(long)size)) == NULL)
			goto end;
		if ((ah->header == NULL) || (ah->header->data == NULL) ||
			(strncmp(NETSCAPE_CERT_HDR,(char *)ah->header->data,
			ah->header->length) != 0))
			{
			BIO_printf(err,"Error reading header on certificate\n");
			goto end;
			}
		/* header is ok, so now read the object */
		p=op;
		ah->meth=X509_asn1_meth();
		if ((ah=d2i_ASN1_HEADER(&ah,&p,(long)size)) == NULL)
			goto end;
		x=(X509 *)ah->data;
		ah->data=NULL;
		}
	else if (format == FORMAT_PEM)
		x=PEM_read_bio_X509_AUX(cert,NULL,
			(pem_password_cb *)password_callback, NULL);
	else if (format == FORMAT_PKCS12)
		{
		PKCS12 *p12 = d2i_PKCS12_bio(cert, NULL);

		PKCS12_parse(p12, NULL, NULL, &x, NULL);
		PKCS12_free(p12);
		p12 = NULL;
		}
	else	{
		BIO_printf(err,"bad input format specified for %s\n",
			cert_descrip);
		goto end;
		}
end:
	if (x == NULL)
		{
		BIO_printf(err,"unable to load certificate\n");
		ERR_print_errors(err);
		}
	if (ah != NULL) ASN1_HEADER_free(ah);
	if (cert != NULL) BIO_free(cert);
	if (buf != NULL) BUF_MEM_free(buf);
	return(x);
	}

EVP_PKEY *load_key(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *key_descrip)
	{
	BIO *key=NULL;
	EVP_PKEY *pkey=NULL;
	PW_CB_DATA cb_data;

	cb_data.password = pass;
	cb_data.prompt_info = file;

	if (file == NULL)
		{
		BIO_printf(err,"no keyfile specified\n");
		goto end;
		}
	if (format == FORMAT_ENGINE)
		{
		if (!e)
			BIO_printf(bio_err,"no engine specified\n");
		else
			pkey = ENGINE_load_private_key(e, file,
				ui_method, &cb_data);
		goto end;
		}
	key=BIO_new(BIO_s_file());
	if (key == NULL)
		{
		ERR_print_errors(err);
		goto end;
		}
	if (BIO_read_filename(key,file) <= 0)
		{
		BIO_printf(err, "Error opening %s %s\n", key_descrip, file);
		ERR_print_errors(err);
		goto end;
		}
	if (format == FORMAT_ASN1)
		{
		pkey=d2i_PrivateKey_bio(key, NULL);
		}
	else if (format == FORMAT_PEM)
		{
		pkey=PEM_read_bio_PrivateKey(key,NULL,
			(pem_password_cb *)password_callback, &cb_data);
		}
#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)
	else if (format == FORMAT_NETSCAPE || format == FORMAT_IISSGC)
		pkey = load_netscape_key(err, key, file, key_descrip, format);
#endif
	else if (format == FORMAT_PKCS12)
		{
		PKCS12 *p12 = d2i_PKCS12_bio(key, NULL);

		PKCS12_parse(p12, pass, &pkey, NULL, NULL);
		PKCS12_free(p12);
		p12 = NULL;
		}
	else
		{
		BIO_printf(err,"bad input format specified for key file\n");
		goto end;
		}
 end:
	if (key != NULL) BIO_free(key);
	if (pkey == NULL)
		BIO_printf(err,"unable to load %s\n", key_descrip);
	return(pkey);
	}

EVP_PKEY *load_pubkey(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *key_descrip)
	{
	BIO *key=NULL;
	EVP_PKEY *pkey=NULL;
	PW_CB_DATA cb_data;

	cb_data.password = pass;
	cb_data.prompt_info = file;

	if (file == NULL)
		{
		BIO_printf(err,"no keyfile specified\n");
		goto end;
		}
	if (format == FORMAT_ENGINE)
		{
		if (!e)
			BIO_printf(bio_err,"no engine specified\n");
		else
			pkey = ENGINE_load_public_key(e, file,
				ui_method, &cb_data);
		goto end;
		}
	key=BIO_new(BIO_s_file());
	if (key == NULL)
		{
		ERR_print_errors(err);
		goto end;
		}
	if (BIO_read_filename(key,file) <= 0)
		{
		BIO_printf(err, "Error opening %s %s\n", key_descrip, file);
		ERR_print_errors(err);
		goto end;
		}
	if (format == FORMAT_ASN1)
		{
		pkey=d2i_PUBKEY_bio(key, NULL);
		}
	else if (format == FORMAT_PEM)
		{
		pkey=PEM_read_bio_PUBKEY(key,NULL,
			(pem_password_cb *)password_callback, &cb_data);
		}
#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)
	else if (format == FORMAT_NETSCAPE || format == FORMAT_IISSGC)
		pkey = load_netscape_key(err, key, file, key_descrip, format);
#endif
	else
		{
		BIO_printf(err,"bad input format specified for key file\n");
		goto end;
		}
 end:
	if (key != NULL) BIO_free(key);
	if (pkey == NULL)
		BIO_printf(err,"unable to load %s\n", key_descrip);
	return(pkey);
	}

#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)
EVP_PKEY *
load_netscape_key(BIO *err, BIO *key, const char *file,
		const char *key_descrip, int format)
	{
	EVP_PKEY *pkey;
	BUF_MEM *buf;
	RSA	*rsa;
	const unsigned char *p;
	int size, i;

	buf=BUF_MEM_new();
	pkey = EVP_PKEY_new();
	size = 0;
	if (buf == NULL || pkey == NULL)
		goto error;
	for (;;)
		{
		if (!BUF_MEM_grow(buf,size+1024*10))
			goto error;
		i = BIO_read(key, &(buf->data[size]), 1024*10);
		size += i;
		if (i == 0)
			break;
		if (i < 0)
			{
				BIO_printf(err, "Error reading %s %s",
					key_descrip, file);
				goto error;
			}
		}
	p=(unsigned char *)buf->data;
	rsa = d2i_RSA_NET(NULL,&p,(long)size,NULL,
		(format == FORMAT_IISSGC ? 1 : 0));
	if (rsa == NULL)
		goto error;
	BUF_MEM_free(buf);
	EVP_PKEY_set1_RSA(pkey, rsa);
	return pkey;
error:
	BUF_MEM_free(buf);
	EVP_PKEY_free(pkey);
	return NULL;
	}
#endif /* ndef OPENSSL_NO_RC4 */

STACK_OF(X509) *load_certs(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *cert_descrip)
	{
	BIO *certs;
	int i;
	STACK_OF(X509) *othercerts = NULL;
	STACK_OF(X509_INFO) *allcerts = NULL;
	X509_INFO *xi;
	PW_CB_DATA cb_data;

	cb_data.password = pass;
	cb_data.prompt_info = file;

	if((certs = BIO_new(BIO_s_file())) == NULL)
		{
		ERR_print_errors(err);
		goto end;
		}

	if (file == NULL)
		BIO_set_fp(certs,stdin,BIO_NOCLOSE);
	else
		{
		if (BIO_read_filename(certs,file) <= 0)
			{
			BIO_printf(err, "Error opening %s %s\n",
				cert_descrip, file);
			ERR_print_errors(err);
			goto end;
			}
		}

	if      (format == FORMAT_PEM)
		{
		othercerts = sk_X509_new_null();
		if(!othercerts)
			{
			sk_X509_free(othercerts);
			othercerts = NULL;
			goto end;
			}
		allcerts = PEM_X509_INFO_read_bio(certs, NULL,
				(pem_password_cb *)password_callback, &cb_data);
		for(i = 0; i < sk_X509_INFO_num(allcerts); i++)
			{
			xi = sk_X509_INFO_value (allcerts, i);
			if (xi->x509)
				{
				sk_X509_push(othercerts, xi->x509);
				xi->x509 = NULL;
				}
			}
		goto end;
		}
	else	{
		BIO_printf(err,"bad input format specified for %s\n",
			cert_descrip);
		goto end;
		}
end:
	if (othercerts == NULL)
		{
		BIO_printf(err,"unable to load certificates\n");
		ERR_print_errors(err);
		}
	if (allcerts) sk_X509_INFO_pop_free(allcerts, X509_INFO_free);
	if (certs != NULL) BIO_free(certs);
	return(othercerts);
	}


#define X509V3_EXT_UNKNOWN_MASK		(0xfL << 16)
/* Return error for unknown extensions */
#define X509V3_EXT_DEFAULT		0
/* Print error for unknown extensions */
#define X509V3_EXT_ERROR_UNKNOWN	(1L << 16)
/* ASN1 parse unknown extensions */
#define X509V3_EXT_PARSE_UNKNOWN	(2L << 16)
/* BIO_dump unknown extensions */
#define X509V3_EXT_DUMP_UNKNOWN		(3L << 16)

#define X509_FLAG_CA (X509_FLAG_NO_ISSUER | X509_FLAG_NO_PUBKEY | \
			 X509_FLAG_NO_HEADER | X509_FLAG_NO_VERSION)

int set_cert_ex(unsigned long *flags, const char *arg)
{
	static const NAME_EX_TBL cert_tbl[] = {
		{ "compatible", X509_FLAG_COMPAT, 0xffffffffl},
		{ "ca_default", X509_FLAG_CA, 0xffffffffl},
		{ "no_header", X509_FLAG_NO_HEADER, 0},
		{ "no_version", X509_FLAG_NO_VERSION, 0},
		{ "no_serial", X509_FLAG_NO_SERIAL, 0},
		{ "no_signame", X509_FLAG_NO_SIGNAME, 0},
		{ "no_validity", X509_FLAG_NO_VALIDITY, 0},
		{ "no_subject", X509_FLAG_NO_SUBJECT, 0},
		{ "no_issuer", X509_FLAG_NO_ISSUER, 0},
		{ "no_pubkey", X509_FLAG_NO_PUBKEY, 0},
		{ "no_extensions", X509_FLAG_NO_EXTENSIONS, 0},
		{ "no_sigdump", X509_FLAG_NO_SIGDUMP, 0},
		{ "no_aux", X509_FLAG_NO_AUX, 0},
		{ "ext_default", X509V3_EXT_DEFAULT, X509V3_EXT_UNKNOWN_MASK},
		{ "ext_error", X509V3_EXT_ERROR_UNKNOWN, X509V3_EXT_UNKNOWN_MASK},
		{ "ext_parse", X509V3_EXT_PARSE_UNKNOWN, X509V3_EXT_UNKNOWN_MASK},
		{ "ext_dump", X509V3_EXT_DUMP_UNKNOWN, X509V3_EXT_UNKNOWN_MASK},
		{ NULL, 0, 0}
	};
	return set_multi_opts(flags, arg, cert_tbl);
}

int set_name_ex(unsigned long *flags, const char *arg)
{
	static const NAME_EX_TBL ex_tbl[] = {
		{ "esc_2253", ASN1_STRFLGS_ESC_2253, 0},
		{ "esc_ctrl", ASN1_STRFLGS_ESC_CTRL, 0},
		{ "esc_msb", ASN1_STRFLGS_ESC_MSB, 0},
		{ "use_quote", ASN1_STRFLGS_ESC_QUOTE, 0},
		{ "utf8", ASN1_STRFLGS_UTF8_CONVERT, 0},
		{ "ignore_type", ASN1_STRFLGS_IGNORE_TYPE, 0},
		{ "show_type", ASN1_STRFLGS_SHOW_TYPE, 0},
		{ "dump_all", ASN1_STRFLGS_DUMP_ALL, 0},
		{ "dump_nostr", ASN1_STRFLGS_DUMP_UNKNOWN, 0},
		{ "dump_der", ASN1_STRFLGS_DUMP_DER, 0},
		{ "compat", XN_FLAG_COMPAT, 0xffffffffL},
		{ "sep_comma_plus", XN_FLAG_SEP_COMMA_PLUS, XN_FLAG_SEP_MASK},
		{ "sep_comma_plus_space", XN_FLAG_SEP_CPLUS_SPC, XN_FLAG_SEP_MASK},
		{ "sep_semi_plus_space", XN_FLAG_SEP_SPLUS_SPC, XN_FLAG_SEP_MASK},
		{ "sep_multiline", XN_FLAG_SEP_MULTILINE, XN_FLAG_SEP_MASK},
		{ "dn_rev", XN_FLAG_DN_REV, 0},
		{ "nofname", XN_FLAG_FN_NONE, XN_FLAG_FN_MASK},
		{ "sname", XN_FLAG_FN_SN, XN_FLAG_FN_MASK},
		{ "lname", XN_FLAG_FN_LN, XN_FLAG_FN_MASK},
		{ "align", XN_FLAG_FN_ALIGN, 0},
		{ "oid", XN_FLAG_FN_OID, XN_FLAG_FN_MASK},
		{ "space_eq", XN_FLAG_SPC_EQ, 0},
		{ "dump_unknown", XN_FLAG_DUMP_UNKNOWN_FIELDS, 0},
		{ "RFC2253", XN_FLAG_RFC2253, 0xffffffffL},
		{ "oneline", XN_FLAG_ONELINE, 0xffffffffL},
		{ "multiline", XN_FLAG_MULTILINE, 0xffffffffL},
		{ "ca_default", XN_FLAG_MULTILINE, 0xffffffffL},
		{ NULL, 0, 0}
	};
	return set_multi_opts(flags, arg, ex_tbl);
}

int set_ext_copy(int *copy_type, const char *arg)
{
	if (!strcasecmp(arg, "none"))
		*copy_type = EXT_COPY_NONE;
	else if (!strcasecmp(arg, "copy"))
		*copy_type = EXT_COPY_ADD;
	else if (!strcasecmp(arg, "copyall"))
		*copy_type = EXT_COPY_ALL;
	else
		return 0;
	return 1;
}

int copy_extensions(X509 *x, X509_REQ *req, int copy_type)
{
	STACK_OF(X509_EXTENSION) *exts = NULL;
	X509_EXTENSION *ext, *tmpext;
	ASN1_OBJECT *obj;
	int i, idx, ret = 0;
	if (!x || !req || (copy_type == EXT_COPY_NONE))
		return 1;
	exts = X509_REQ_get_extensions(req);

	for(i = 0; i < sk_X509_EXTENSION_num(exts); i++) {
		ext = sk_X509_EXTENSION_value(exts, i);
		obj = X509_EXTENSION_get_object(ext);
		idx = X509_get_ext_by_OBJ(x, obj, -1);
		/* Does extension exist? */
		if (idx != -1) {
			/* If normal copy don't override existing extension */
			if (copy_type == EXT_COPY_ADD)
				continue;
			/* Delete all extensions of same type */
			do {
				tmpext = X509_get_ext(x, idx);
				X509_delete_ext(x, idx);
				X509_EXTENSION_free(tmpext);
				idx = X509_get_ext_by_OBJ(x, obj, -1);
			} while (idx != -1);
		}
		if (!X509_add_ext(x, ext, -1))
			goto end;
	}

	ret = 1;

	end:

	sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);

	return ret;
}
		
		
			

static int set_multi_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl)
{
	STACK_OF(CONF_VALUE) *vals;
	CONF_VALUE *val;
	int i, ret = 1;
	if(!arg) return 0;
	vals = X509V3_parse_list(arg);
	for (i = 0; i < sk_CONF_VALUE_num(vals); i++) {
		val = sk_CONF_VALUE_value(vals, i);
		if (!set_table_opts(flags, val->name, in_tbl))
			ret = 0;
	}
	sk_CONF_VALUE_pop_free(vals, X509V3_conf_free);
	return ret;
}

static int set_table_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl)
{
	char c;
	const NAME_EX_TBL *ptbl;
	c = arg[0];

	if(c == '-') {
		c = 0;
		arg++;
	} else if (c == '+') {
		c = 1;
		arg++;
	} else c = 1;

	for(ptbl = in_tbl; ptbl->name; ptbl++) {
		if(!strcasecmp(arg, ptbl->name)) {
			*flags &= ~ptbl->mask;
			if(c) *flags |= ptbl->flag;
			else *flags &= ~ptbl->flag;
			return 1;
		}
	}
	return 0;
}

void print_name(BIO *out, char *title, X509_NAME *nm, unsigned long lflags)
{
	char buf[256];
	char mline = 0;
	int indent = 0;
	if(title) BIO_puts(out, title);
	if((lflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {
		mline = 1;
		indent = 4;
	}
	if(lflags == XN_FLAG_COMPAT) {
		X509_NAME_oneline(nm,buf,256);
		BIO_puts(out,buf);
		BIO_puts(out, "\n");
	} else {
		if(mline) BIO_puts(out, "\n");
		X509_NAME_print_ex(out, nm, indent, lflags);
		BIO_puts(out, "\n");
	}
}

X509_STORE *setup_verify(BIO *bp, char *CAfile, char *CApath)
{
	X509_STORE *store;
	X509_LOOKUP *lookup;
	if(!(store = X509_STORE_new())) goto end;
	lookup=X509_STORE_add_lookup(store,X509_LOOKUP_file());
	if (lookup == NULL) goto end;
	if (CAfile) {
		if(!X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM)) {
			BIO_printf(bp, "Error loading file %s\n", CAfile);
			goto end;
		}
	} else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);
		
	lookup=X509_STORE_add_lookup(store,X509_LOOKUP_hash_dir());
	if (lookup == NULL) goto end;
	if (CApath) {
		if(!X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM)) {
			BIO_printf(bp, "Error loading directory %s\n", CApath);
			goto end;
		}
	} else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);

	ERR_clear_error();
	return store;
	end:
	X509_STORE_free(store);
	return NULL;
}

/* Try to load an engine in a shareable library */
ENGINE *try_load_engine(BIO *err, const char *engine, int debug)
	{
	ENGINE *e = ENGINE_by_id("dynamic");
	if (e)
		{
		if (!ENGINE_ctrl_cmd_string(e, "SO_PATH", engine, 0)
			|| !ENGINE_ctrl_cmd_string(e, "LOAD", NULL, 0))
			{
			ENGINE_free(e);
			e = NULL;
			}
		}
	return e;
	}

ENGINE *setup_engine(BIO *err, const char *engine, int debug)
        {
        ENGINE *e = NULL;

        if (engine)
                {
		if(strcmp(engine, "auto") == 0)
			{
			BIO_printf(err,"enabling auto ENGINE support\n");
			ENGINE_register_all_complete();
			return NULL;
			}
		if((e = ENGINE_by_id(engine)) == NULL
			&& (e = try_load_engine(err, engine, debug)) == NULL)
			{
			BIO_printf(err,"invalid engine \"%s\"\n", engine);
			ERR_print_errors(err);
			return NULL;
			}
		if (debug)
			{
			ENGINE_ctrl(e, ENGINE_CTRL_SET_LOGSTREAM,
				0, err, 0);
			}
                ENGINE_ctrl_cmd(e, "SET_USER_INTERFACE", 0, ui_method, 0, 1);
		if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
			{
			BIO_printf(err,"can't use that engine\n");
			ERR_print_errors(err);
			ENGINE_free(e);
			return NULL;
			}

		BIO_printf(err,"engine \"%s\" set.\n", ENGINE_get_id(e));

		/* Free our "structural" reference. */
		ENGINE_free(e);
		}
        return e;
        }

int load_config(BIO *err, CONF *cnf)
	{
	if (!cnf)
		cnf = config;
	if (!cnf)
		return 1;

	OPENSSL_load_builtin_modules();

	if (CONF_modules_load(cnf, NULL, 0) <= 0)
		{
		BIO_printf(err, "Error configuring OpenSSL\n");
		ERR_print_errors(err);
		return 0;
		}
	return 1;
	}
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d132 1
a132 5
#  ifdef NO_STRINGS_H
    int	strcasecmp();
#  else
#    include <strings.h>
#  endif /* NO_STRINGS_H */
d493 1
a493 1
int setup_ui_method(void)
d502 1
a502 1
void destroy_ui_method(void)
d928 1
a928 1
static EVP_PKEY *
d1216 1
a1216 1
	char *buf;
d1225 2
a1226 2
		buf = X509_NAME_oneline(nm, 0, 0);
		BIO_puts(out, buf);
a1227 1
		OPENSSL_free(buf);
d1266 1
a1266 1
static ENGINE *try_load_engine(BIO *err, const char *engine, int debug)
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d801 1
a801 1
EVP_PKEY *load_key(BIO *err, const char *file, int format, int maybe_stdin,
d811 1
a811 1
	if (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE))
d831 1
a831 1
	if (file == NULL && maybe_stdin)
d833 3
a835 2
		setvbuf(stdin, NULL, _IONBF, 0);
		BIO_set_fp(key,stdin,BIO_NOCLOSE);
a836 8
	else
		if (BIO_read_filename(key,file) <= 0)
			{
			BIO_printf(err, "Error opening %s %s\n",
				key_descrip, file);
			ERR_print_errors(err);
			goto end;
			}
d870 1
a870 1
EVP_PKEY *load_pubkey(BIO *err, const char *file, int format, int maybe_stdin,
d880 1
a880 1
	if (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE))
d900 1
a900 1
	if (file == NULL && maybe_stdin)
d902 3
a904 10
		setvbuf(stdin, NULL, _IONBF, 0);
		BIO_set_fp(key,stdin,BIO_NOCLOSE);
		}
	else
		if (BIO_read_filename(key,file) <= 0)
			{
			BIO_printf(err, "Error opening %s %s\n",
				key_descrip, file);
			ERR_print_errors(err);
			goto end;
a1076 1
		{ "no_attributes", X509_FLAG_NO_ATTRIBUTES, 0},
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@d117 3
a119 1
#include <ctype.h>
a126 1
#ifndef OPENSSL_NO_ENGINE
a127 1
#endif
d139 3
a141 3
#define NON_MAIN
#include "apps.h"
#undef NON_MAIN
d338 2
a339 1
	BUF_strlcpy(out,p,size);
a346 1
#ifndef OPENSSL_SYS_WINCE
a353 40
#else
	/* convert strings to UNICODE */
	{
	BOOL result = FALSE;
	WCHAR* wfrom;
	WCHAR* wto;
	int i;
	wfrom = malloc((strlen(from)+1)*2);
	wto = malloc((strlen(to)+1)*2);
	if (wfrom != NULL && wto != NULL)
		{
		for (i=0; i<(int)strlen(from)+1; i++)
			wfrom[i] = (short)from[i];
		for (i=0; i<(int)strlen(to)+1; i++)
			wto[i] = (short)to[i];
		result = MoveFile(wfrom, wto);
		}
	if (wfrom != NULL)
		free(wfrom);
	if (wto != NULL)
		free(wto);
	return result;
	}
#endif
	}
#endif

#ifdef OPENSSL_SYS_VMS
int VMS_strcasecmp(const char *str1, const char *str2)
	{
	while (*str1 && *str2)
		{
		int res = toupper(*str1) - toupper(*str2);
		if (res) return res < 0 ? -1 : 1;
		}
	if (*str1)
		return 1;
	if (*str2)
		return -1;
	return 0;
d432 2
a433 3
	char *p;

	p=X509_NAME_oneline(X509_get_subject_name(x),NULL,0);
d435 1
a435 2
	BIO_puts(out,p);
	OPENSSL_free(p);
d437 3
a439 3
	p=X509_NAME_oneline(X509_get_issuer_name(x),NULL,0);
	BIO_puts(out,"\nissuer=");
	BIO_puts(out,p);
d441 1
a441 3
	OPENSSL_free(p);

	return 0;
d572 1
a572 1
			OPENSSL_cleanse(buff,(unsigned int)bufsiz);
d582 1
a582 1
			OPENSSL_cleanse(buf,(unsigned int)bufsiz);
d588 1
a588 1
			OPENSSL_cleanse(buf,(unsigned int)bufsiz);
a815 1
#ifndef OPENSSL_NO_ENGINE
a824 1
#endif
a891 1
#ifndef OPENSSL_NO_ENGINE
a900 1
#endif
d963 1
a963 1
		if (!BUF_MEM_grow_clean(buf,size+1024*10))
a1237 1

a1284 1
#ifndef OPENSSL_NO_ENGINE
a1340 1
#endif
a1357 15
	}

char *make_config_name()
	{
	const char *t=X509_get_default_cert_area();
	char *p;

	p=OPENSSL_malloc(strlen(t)+strlen(OPENSSL_CONF)+2);
	strcpy(p,t);
#ifndef OPENSSL_SYS_VMS
	strcat(p,"/");
#endif
	strcat(p,OPENSSL_CONF);

	return p;
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d504 1
a504 1
			if (password && password[0] != '\0')
d528 1
a528 1
			if (password && password[0] != '\0')
a1413 1
	size_t len;
d1416 2
a1417 3
	len=strlen(t)+strlen(OPENSSL_CONF)+2;
	p=OPENSSL_malloc(len);
	BUF_strlcpy(p,t,len);
d1419 1
a1419 1
	BUF_strlcat(p,"/",len);
d1421 1
a1421 1
	BUF_strlcat(p,OPENSSL_CONF,len);
a1423 549
	}

static unsigned long index_serial_hash(const char **a)
	{
	const char *n;

	n=a[DB_serial];
	while (*n == '0') n++;
	return(lh_strhash(n));
	}

static int index_serial_cmp(const char **a, const char **b)
	{
	const char *aa,*bb;

	for (aa=a[DB_serial]; *aa == '0'; aa++);
	for (bb=b[DB_serial]; *bb == '0'; bb++);
	return(strcmp(aa,bb));
	}

static int index_name_qual(char **a)
	{ return(a[0][0] == 'V'); }

static unsigned long index_name_hash(const char **a)
	{ return(lh_strhash(a[DB_name])); }

int index_name_cmp(const char **a, const char **b)
	{ return(strcmp(a[DB_name],
	     b[DB_name])); }

static IMPLEMENT_LHASH_HASH_FN(index_serial_hash,const char **)
static IMPLEMENT_LHASH_COMP_FN(index_serial_cmp,const char **)
static IMPLEMENT_LHASH_HASH_FN(index_name_hash,const char **)
static IMPLEMENT_LHASH_COMP_FN(index_name_cmp,const char **)

#undef BSIZE
#define BSIZE 256

BIGNUM *load_serial(char *serialfile, int create, ASN1_INTEGER **retai)
	{
	BIO *in=NULL;
	BIGNUM *ret=NULL;
	MS_STATIC char buf[1024];
	ASN1_INTEGER *ai=NULL;

	ai=ASN1_INTEGER_new();
	if (ai == NULL) goto err;

	if ((in=BIO_new(BIO_s_file())) == NULL)
		{
		ERR_print_errors(bio_err);
		goto err;
		}

	if (BIO_read_filename(in,serialfile) <= 0)
		{
		if (!create)
			{
			perror(serialfile);
			goto err;
			}
		else
			{
			ASN1_INTEGER_set(ai,1);
			ret=BN_new();
			if (ret == NULL)
				BIO_printf(bio_err, "Out of memory\n");
			else
				BN_one(ret);
			}
		}
	else
		{
		if (!a2i_ASN1_INTEGER(in,ai,buf,1024))
			{
			BIO_printf(bio_err,"unable to load number from %s\n",
				serialfile);
			goto err;
			}
		ret=ASN1_INTEGER_to_BN(ai,NULL);
		if (ret == NULL)
			{
			BIO_printf(bio_err,"error converting number from bin to BIGNUM\n");
			goto err;
			}
		}

	if (ret && retai)
		{
		*retai = ai;
		ai = NULL;
		}
 err:
	if (in != NULL) BIO_free(in);
	if (ai != NULL) ASN1_INTEGER_free(ai);
	return(ret);
	}

int save_serial(char *serialfile, char *suffix, BIGNUM *serial, ASN1_INTEGER **retai)
	{
	char buf[1][BSIZE];
	BIO *out = NULL;
	int ret=0;
	ASN1_INTEGER *ai=NULL;
	int j;

	if (suffix == NULL)
		j = strlen(serialfile);
	else
		j = strlen(serialfile) + strlen(suffix) + 1;
	if (j >= BSIZE)
		{
		BIO_printf(bio_err,"file name too long\n");
		goto err;
		}

	if (suffix == NULL)
		BUF_strlcpy(buf[0], serialfile, BSIZE);
	else
		{
#ifndef OPENSSL_SYS_VMS
		j = BIO_snprintf(buf[0], sizeof buf[0], "%s.%s", serialfile, suffix);
#else
		j = BIO_snprintf(buf[0], sizeof buf[0], "%s-%s", serialfile, suffix);
#endif
		}
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: writing \"%s\"\n", buf[0]);
#endif
	out=BIO_new(BIO_s_file());
	if (out == NULL)
		{
		ERR_print_errors(bio_err);
		goto err;
		}
	if (BIO_write_filename(out,buf[0]) <= 0)
		{
		perror(serialfile);
		goto err;
		}

	if ((ai=BN_to_ASN1_INTEGER(serial,NULL)) == NULL)
		{
		BIO_printf(bio_err,"error converting serial to ASN.1 format\n");
		goto err;
		}
	i2a_ASN1_INTEGER(out,ai);
	BIO_puts(out,"\n");
	ret=1;
	if (retai)
		{
		*retai = ai;
		ai = NULL;
		}
err:
	if (out != NULL) BIO_free_all(out);
	if (ai != NULL) ASN1_INTEGER_free(ai);
	return(ret);
	}

int rotate_serial(char *serialfile, char *new_suffix, char *old_suffix)
	{
	char buf[5][BSIZE];
	int i,j;
	struct stat sb;

	i = strlen(serialfile) + strlen(old_suffix);
	j = strlen(serialfile) + strlen(new_suffix);
	if (i > j) j = i;
	if (j + 1 >= BSIZE)
		{
		BIO_printf(bio_err,"file name too long\n");
		goto err;
		}

#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s.%s",
		serialfile, new_suffix);
#else
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s-%s",
		serialfile, new_suffix);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s.%s",
		serialfile, old_suffix);
#else
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s-%s",
		serialfile, old_suffix);
#endif
	if (stat(serialfile,&sb) < 0)
		{
		if (errno != ENOENT 
#ifdef ENOTDIR
			&& errno != ENOTDIR)
#endif
			goto err;
		}
	else
		{
#ifdef RL_DEBUG
		BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
			serialfile, buf[1]);
#endif
		if (rename(serialfile,buf[1]) < 0)
			{
			BIO_printf(bio_err,
				"unable to rename %s to %s\n",
				serialfile, buf[1]);
			perror("reason");
			goto err;
			}
		}
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
		buf[0],serialfile);
#endif
	if (rename(buf[0],serialfile) < 0)
		{
		BIO_printf(bio_err,
			"unable to rename %s to %s\n",
			buf[0],serialfile);
		perror("reason");
		rename(buf[1],serialfile);
		goto err;
		}
	return 1;
 err:
	return 0;
	}

CA_DB *load_index(char *dbfile, DB_ATTR *db_attr)
	{
	CA_DB *retdb = NULL;
	TXT_DB *tmpdb = NULL;
	BIO *in = BIO_new(BIO_s_file());
	CONF *dbattr_conf = NULL;
	char buf[1][BSIZE];
	long errorline= -1;

	if (in == NULL)
		{
		ERR_print_errors(bio_err);
		goto err;
		}
	if (BIO_read_filename(in,dbfile) <= 0)
		{
		perror(dbfile);
		BIO_printf(bio_err,"unable to open '%s'\n",dbfile);
		goto err;
		}
	if ((tmpdb = TXT_DB_read(in,DB_NUMBER)) == NULL)
		{
		if (tmpdb != NULL) TXT_DB_free(tmpdb);
		goto err;
		}

#ifndef OPENSSL_SYS_VMS
	BIO_snprintf(buf[0], sizeof buf[0], "%s.attr", dbfile);
#else
	BIO_snprintf(buf[0], sizeof buf[0], "%s-attr", dbfile);
#endif
	dbattr_conf = NCONF_new(NULL);
	if (NCONF_load(dbattr_conf,buf[0],&errorline) <= 0)
		{
		if (errorline > 0)
			{
			BIO_printf(bio_err,
				"error on line %ld of db attribute file '%s'\n"
				,errorline,buf[0]);
			goto err;
			}
		else
			{
			NCONF_free(dbattr_conf);
			dbattr_conf = NULL;
			}
		}

	if ((retdb = OPENSSL_malloc(sizeof(CA_DB))) == NULL)
		{
		fprintf(stderr, "Out of memory\n");
		goto err;
		}

	retdb->db = tmpdb;
	tmpdb = NULL;
	if (db_attr)
		retdb->attributes = *db_attr;
	else
		{
		retdb->attributes.unique_subject = 1;
		}

	if (dbattr_conf)
		{
		char *p = NCONF_get_string(dbattr_conf,NULL,"unique_subject");
		if (p)
			{
			BIO_printf(bio_err, "DEBUG[load_index]: unique_subject = \"%s\"\n", p);
			switch(*p)
				{
			case 'f': /* false */
			case 'F': /* FALSE */
			case 'n': /* no */
			case 'N': /* NO */
				retdb->attributes.unique_subject = 0;
				break;
			case 't': /* true */
			case 'T': /* TRUE */
			case 'y': /* yes */
			case 'Y': /* YES */
			default:
				retdb->attributes.unique_subject = 1;
				break;
				}
			}
		}

 err:
	if (dbattr_conf) NCONF_free(dbattr_conf);
	if (tmpdb) TXT_DB_free(tmpdb);
	if (in) BIO_free_all(in);
	return retdb;
	}

int index_index(CA_DB *db)
	{
	if (!TXT_DB_create_index(db->db, DB_serial, NULL,
				LHASH_HASH_FN(index_serial_hash),
				LHASH_COMP_FN(index_serial_cmp)))
		{
		BIO_printf(bio_err,
		  "error creating serial number index:(%ld,%ld,%ld)\n",
		  			db->db->error,db->db->arg1,db->db->arg2);
			return 0;
		}

	if (db->attributes.unique_subject
		&& !TXT_DB_create_index(db->db, DB_name, index_name_qual,
			LHASH_HASH_FN(index_name_hash),
			LHASH_COMP_FN(index_name_cmp)))
		{
		BIO_printf(bio_err,"error creating name index:(%ld,%ld,%ld)\n",
			db->db->error,db->db->arg1,db->db->arg2);
		return 0;
		}
	return 1;
	}

int save_index(char *dbfile, char *suffix, CA_DB *db)
	{
	char buf[3][BSIZE];
	BIO *out = BIO_new(BIO_s_file());
	int j;

	if (out == NULL)
		{
		ERR_print_errors(bio_err);
		goto err;
		}

	j = strlen(dbfile) + strlen(suffix);
	if (j + 6 >= BSIZE)
		{
		BIO_printf(bio_err,"file name too long\n");
		goto err;
		}

#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[2], sizeof buf[2], "%s.attr", dbfile);
#else
	j = BIO_snprintf(buf[2], sizeof buf[2], "%s-attr", dbfile);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s.attr.%s", dbfile, suffix);
#else
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s-attr-%s", dbfile, suffix);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s.%s", dbfile, suffix);
#else
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s-%s", dbfile, suffix);
#endif
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: writing \"%s\"\n", buf[0]);
#endif
	if (BIO_write_filename(out,buf[0]) <= 0)
		{
		perror(dbfile);
		BIO_printf(bio_err,"unable to open '%s'\n", dbfile);
		goto err;
		}
	j=TXT_DB_write(out,db->db);
	if (j <= 0) goto err;
			
	BIO_free(out);

	out = BIO_new(BIO_s_file());
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: writing \"%s\"\n", buf[1]);
#endif
	if (BIO_write_filename(out,buf[1]) <= 0)
		{
		perror(buf[2]);
		BIO_printf(bio_err,"unable to open '%s'\n", buf[2]);
		goto err;
		}
	BIO_printf(out,"unique_subject = %s\n",
		db->attributes.unique_subject ? "yes" : "no");
	BIO_free(out);

	return 1;
 err:
	return 0;
	}

int rotate_index(char *dbfile, char *new_suffix, char *old_suffix)
	{
	char buf[5][BSIZE];
	int i,j;
	struct stat sb;

	i = strlen(dbfile) + strlen(old_suffix);
	j = strlen(dbfile) + strlen(new_suffix);
	if (i > j) j = i;
	if (j + 6 >= BSIZE)
		{
		BIO_printf(bio_err,"file name too long\n");
		goto err;
		}

#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[4], sizeof buf[4], "%s.attr", dbfile);
#else
	j = BIO_snprintf(buf[4], sizeof buf[4], "%s-attr", dbfile);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[2], sizeof buf[2], "%s.attr.%s",
		dbfile, new_suffix);
#else
	j = BIO_snprintf(buf[2], sizeof buf[2], "%s-attr-%s",
		dbfile, new_suffix);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s.%s",
		dbfile, new_suffix);
#else
	j = BIO_snprintf(buf[0], sizeof buf[0], "%s-%s",
		dbfile, new_suffix);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s.%s",
		dbfile, old_suffix);
#else
	j = BIO_snprintf(buf[1], sizeof buf[1], "%s-%s",
		dbfile, old_suffix);
#endif
#ifndef OPENSSL_SYS_VMS
	j = BIO_snprintf(buf[3], sizeof buf[3], "%s.attr.%s",
		dbfile, old_suffix);
#else
	j = BIO_snprintf(buf[3], sizeof buf[3], "%s-attr-%s",
		dbfile, old_suffix);
#endif
	if (stat(dbfile,&sb) < 0)
		{
		if (errno != ENOENT 
#ifdef ENOTDIR
			&& errno != ENOTDIR)
#endif
			goto err;
		}
	else
		{
#ifdef RL_DEBUG
		BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
			dbfile, buf[1]);
#endif
		if (rename(dbfile,buf[1]) < 0)
			{
			BIO_printf(bio_err,
				"unable to rename %s to %s\n",
				dbfile, buf[1]);
			perror("reason");
			goto err;
			}
		}
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
		buf[0],dbfile);
#endif
	if (rename(buf[0],dbfile) < 0)
		{
		BIO_printf(bio_err,
			"unable to rename %s to %s\n",
			buf[0],dbfile);
		perror("reason");
		rename(buf[1],dbfile);
		goto err;
		}
	if (stat(buf[4],&sb) < 0)
		{
		if (errno != ENOENT 
#ifdef ENOTDIR
			&& errno != ENOTDIR)
#endif
			goto err;
		}
	else
		{
#ifdef RL_DEBUG
		BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
			buf[4],buf[3]);
#endif
		if (rename(buf[4],buf[3]) < 0)
			{
			BIO_printf(bio_err,
				"unable to rename %s to %s\n",
				buf[4], buf[3]);
			perror("reason");
			rename(dbfile,buf[0]);
			rename(buf[1],dbfile);
			goto err;
			}
		}
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
		buf[2],buf[4]);
#endif
	if (rename(buf[2],buf[4]) < 0)
		{
		BIO_printf(bio_err,
			"unable to rename %s to %s\n",
			buf[2],buf[4]);
		perror("reason");
		rename(buf[3],buf[4]);
		rename(dbfile,buf[0]);
		rename(buf[1],dbfile);
		goto err;
		}
	return 1;
 err:
	return 0;
	}

void free_index(CA_DB *db)
	{
	TXT_DB_free(db->db);
	OPENSSL_free(db);
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d129 10
d343 54
d593 1
a593 1
			prompt_info);
a741 45
static int load_pkcs12(BIO *err, BIO *in, const char *desc,
		pem_password_cb *pem_cb,  void *cb_data,
		EVP_PKEY **pkey, X509 **cert, STACK_OF(X509) **ca)
	{
 	const char *pass;
	char tpass[PEM_BUFSIZE];
	int len, ret = 0;
	PKCS12 *p12;
	p12 = d2i_PKCS12_bio(in, NULL);
	if (p12 == NULL)
		{
		BIO_printf(err, "Error loading PKCS12 file for %s\n", desc);	
		goto die;
		}
	/* See if an empty password will do */
	if (PKCS12_verify_mac(p12, "", 0) || PKCS12_verify_mac(p12, NULL, 0))
		pass = "";
	else
		{
		if (!pem_cb)
			pem_cb = (pem_password_cb *)password_callback;
		len = pem_cb(tpass, PEM_BUFSIZE, 0, cb_data);
		if (len < 0) 
			{
			BIO_printf(err, "Passpharse callback error for %s\n",
					desc);
			goto die;
			}
		if (len < PEM_BUFSIZE)
			tpass[len] = 0;
		if (!PKCS12_verify_mac(p12, tpass, len))
			{
			BIO_printf(err,
	"Mac verify error (wrong password?) in PKCS12 file for %s\n", desc);	
			goto die;
			}
		pass = tpass;
		}
	ret = PKCS12_parse(p12, pass, pkey, cert, ca);
	die:
	if (p12)
		PKCS12_free(p12);
	return ret;
	}

d822 5
a826 3
		if (!load_pkcs12(err, cert,cert_descrip, NULL, NULL,
					NULL, &x, NULL))
			goto end;
d905 5
a909 4
		if (!load_pkcs12(err, key, key_descrip,
				(pem_password_cb *)password_callback, &cb_data,
				&pkey, NULL, NULL))
			goto end;
d1489 1
d1491 1
a1491 1
			if (ret == NULL || !rand_serial(ret, ai))
d1493 2
a1655 27
int rand_serial(BIGNUM *b, ASN1_INTEGER *ai)
	{
	BIGNUM *btmp;
	int ret = 0;
	if (b)
		btmp = b;
	else
		btmp = BN_new();

	if (!btmp)
		return 0;

	if (!BN_pseudo_rand(btmp, SERIAL_RAND_BITS, 0, 0))
		goto error;
	if (ai && !BN_to_ASN1_INTEGER(btmp, ai))
		goto error;

	ret = 1;
	
	error:

	if (!b)
		BN_free(btmp);
	
	return ret;
	}

d1973 2
a1974 41
	if (db)
		{
		if (db->db) TXT_DB_free(db->db);
		OPENSSL_free(db);
		}
	}

/* This code MUST COME AFTER anything that uses rename() */
#ifdef OPENSSL_SYS_WIN32
int WIN32_rename(char *from, char *to)
	{
#ifndef OPENSSL_SYS_WINCE
	/* Windows rename gives an error if 'to' exists, so delete it
	 * first and ignore file not found errror
	 */
	if((remove(to) != 0) && (errno != ENOENT))
		return -1;
#undef rename
	return rename(from, to);
#else
	/* convert strings to UNICODE */
	{
	BOOL result = FALSE;
	WCHAR* wfrom;
	WCHAR* wto;
	int i;
	wfrom = malloc((strlen(from)+1)*2);
	wto = malloc((strlen(to)+1)*2);
	if (wfrom != NULL && wto != NULL)
		{
		for (i=0; i<(int)strlen(from)+1; i++)
			wfrom[i] = (short)from[i];
		for (i=0; i<(int)strlen(to)+1; i++)
			wto[i] = (short)to[i];
		result = MoveFile(wfrom, wto);
		}
	if (wfrom != NULL)
		free(wfrom);
	if (wto != NULL)
		free(wto);
	return result;
a1975 3
#endif
	}
#endif
@


1.1.1.8
log
@import of openssl-0.9.7j
@
text
@d364 4
a367 11
			char **tmp_p;
			int tlen = arg->count + 20;
			tmp_p = (char **)OPENSSL_realloc(arg->data,
				sizeof(char *)*tlen);
			if (tmp_p == NULL)
				return 0;
			arg->data  = tmp_p;
			arg->count = tlen;
			/* initialize newly allocated data */
			for (i = num; i < arg->count; i++)
				arg->data[i] = NULL;
d1594 1
a1594 1
			&& errno != ENOTDIR
a1595 1
		   )
d1896 1
a1896 1
			&& errno != ENOTDIR
a1897 1
		   )
d1932 1
a1932 1
			&& errno != ENOTDIR
a1933 1
		   )
@


1.1.1.9
log
@import of OpenSSL 0.9.8h
@
text
@a127 4
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
#include <openssl/bn.h>
d134 1
a134 1
	const char *name;
d253 1
a253 1
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16) || defined(OPENSSL_SYS_NETWARE)
a271 9

#if defined(OPENSSL_SYS_NETWARE)
   /* strip off trailing .nlm if present. */
   if ((n > 4) && (p[n-4] == '.') &&
      ((p[n-3] == 'n') || (p[n-3] == 'N')) &&
      ((p[n-2] == 'l') || (p[n-2] == 'L')) &&
      ((p[n-1] == 'm') || (p[n-1] == 'M')))
      n-=4;
#else
a277 2
#endif

d764 1
a764 1
		const unsigned char *p,*op;
d1266 1
a1266 1
void print_name(BIO *out, const char *title, X509_NAME *nm, unsigned long lflags)
a1733 1
#ifdef RL_DEBUG
d1735 16
a1750 2
#endif
			retdb->attributes.unique_subject = parse_yesno(p,1);
d1785 1
a1785 1
int save_index(const char *dbfile, const char *suffix, CA_DB *db)
d1852 1
a1852 1
int rotate_index(const char *dbfile, const char *new_suffix, const char *old_suffix)
a1991 165
int parse_yesno(const char *str, int def)
	{
	int ret = def;
	if (str)
		{
		switch (*str)
			{
		case 'f': /* false */
		case 'F': /* FALSE */
		case 'n': /* no */
		case 'N': /* NO */
		case '0': /* 0 */
			ret = 0;
			break;
		case 't': /* true */
		case 'T': /* TRUE */
		case 'y': /* yes */
		case 'Y': /* YES */
		case '1': /* 1 */
			ret = 1;
			break;
		default:
			ret = def;
			break;
			}
		}
	return ret;
	}

/*
 * subject is expected to be in the format /type0=value0/type1=value1/type2=...
 * where characters may be escaped by \
 */
X509_NAME *parse_name(char *subject, long chtype, int multirdn)
	{
	size_t buflen = strlen(subject)+1; /* to copy the types and values into. due to escaping, the copy can only become shorter */
	char *buf = OPENSSL_malloc(buflen);
	size_t max_ne = buflen / 2 + 1; /* maximum number of name elements */
	char **ne_types = OPENSSL_malloc(max_ne * sizeof (char *));
	char **ne_values = OPENSSL_malloc(max_ne * sizeof (char *));
	int *mval = OPENSSL_malloc (max_ne * sizeof (int));

	char *sp = subject, *bp = buf;
	int i, ne_num = 0;

	X509_NAME *n = NULL;
	int nid;

	if (!buf || !ne_types || !ne_values)
		{
		BIO_printf(bio_err, "malloc error\n");
		goto error;
		}	

	if (*subject != '/')
		{
		BIO_printf(bio_err, "Subject does not start with '/'.\n");
		goto error;
		}
	sp++; /* skip leading / */

	/* no multivalued RDN by default */
	mval[ne_num] = 0;

	while (*sp)
		{
		/* collect type */
		ne_types[ne_num] = bp;
		while (*sp)
			{
			if (*sp == '\\') /* is there anything to escape in the type...? */
				{
				if (*++sp)
					*bp++ = *sp++;
				else	
					{
					BIO_printf(bio_err, "escape character at end of string\n");
					goto error;
					}
				}	
			else if (*sp == '=')
				{
				sp++;
				*bp++ = '\0';
				break;
				}
			else
				*bp++ = *sp++;
			}
		if (!*sp)
			{
			BIO_printf(bio_err, "end of string encountered while processing type of subject name element #%d\n", ne_num);
			goto error;
			}
		ne_values[ne_num] = bp;
		while (*sp)
			{
			if (*sp == '\\')
				{
				if (*++sp)
					*bp++ = *sp++;
				else
					{
					BIO_printf(bio_err, "escape character at end of string\n");
					goto error;
					}
				}
			else if (*sp == '/')
				{
				sp++;
				/* no multivalued RDN by default */
				mval[ne_num+1] = 0;
				break;
				}
			else if (*sp == '+' && multirdn)
				{
				/* a not escaped + signals a mutlivalued RDN */
				sp++;
				mval[ne_num+1] = -1;
				break;
				}
			else
				*bp++ = *sp++;
			}
		*bp++ = '\0';
		ne_num++;
		}	

	if (!(n = X509_NAME_new()))
		goto error;

	for (i = 0; i < ne_num; i++)
		{
		if ((nid=OBJ_txt2nid(ne_types[i])) == NID_undef)
			{
			BIO_printf(bio_err, "Subject Attribute %s has no known NID, skipped\n", ne_types[i]);
			continue;
			}

		if (!*ne_values[i])
			{
			BIO_printf(bio_err, "No value provided for Subject Attribute %s, skipped\n", ne_types[i]);
			continue;
			}

		if (!X509_NAME_add_entry_by_NID(n, nid, chtype, (unsigned char*)ne_values[i], -1,-1,mval[i]))
			goto error;
		}

	OPENSSL_free(ne_values);
	OPENSSL_free(ne_types);
	OPENSSL_free(buf);
	return n;

error:
	X509_NAME_free(n);
	if (ne_values)
		OPENSSL_free(ne_values);
	if (ne_types)
		OPENSSL_free(ne_types);
	if (buf)
		OPENSSL_free(buf);
	return NULL;
}

d1994 1
a1994 1
int WIN32_rename(const char *from, const char *to)
a2029 139

int args_verify(char ***pargs, int *pargc,
			int *badarg, BIO *err, X509_VERIFY_PARAM **pm)
	{
	ASN1_OBJECT *otmp = NULL;
	unsigned long flags = 0;
	int i;
	int purpose = 0;
	char **oldargs = *pargs;
	char *arg = **pargs, *argn = (*pargs)[1];
	if (!strcmp(arg, "-policy"))
		{
		if (!argn)
			*badarg = 1;
		else
			{
			otmp = OBJ_txt2obj(argn, 0);
			if (!otmp)
				{
				BIO_printf(err, "Invalid Policy \"%s\"\n",
									argn);
				*badarg = 1;
				}
			}
		(*pargs)++;
		}
	else if (strcmp(arg,"-purpose") == 0)
		{
		X509_PURPOSE *xptmp;
		if (!argn)
			*badarg = 1;
		else
			{
			i = X509_PURPOSE_get_by_sname(argn);
			if(i < 0)
				{
				BIO_printf(err, "unrecognized purpose\n");
				*badarg = 1;
				}
			else
				{
				xptmp = X509_PURPOSE_get0(i);
				purpose = X509_PURPOSE_get_id(xptmp);
				}
			}
		(*pargs)++;
		}
	else if (!strcmp(arg, "-ignore_critical"))
		flags |= X509_V_FLAG_IGNORE_CRITICAL;
	else if (!strcmp(arg, "-issuer_checks"))
		flags |= X509_V_FLAG_CB_ISSUER_CHECK;
	else if (!strcmp(arg, "-crl_check"))
		flags |=  X509_V_FLAG_CRL_CHECK;
	else if (!strcmp(arg, "-crl_check_all"))
		flags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;
	else if (!strcmp(arg, "-policy_check"))
		flags |= X509_V_FLAG_POLICY_CHECK;
	else if (!strcmp(arg, "-explicit_policy"))
		flags |= X509_V_FLAG_EXPLICIT_POLICY;
	else if (!strcmp(arg, "-x509_strict"))
		flags |= X509_V_FLAG_X509_STRICT;
	else if (!strcmp(arg, "-policy_print"))
		flags |= X509_V_FLAG_NOTIFY_POLICY;
	else
		return 0;

	if (*badarg)
		{
		if (*pm)
			X509_VERIFY_PARAM_free(*pm);
		*pm = NULL;
		goto end;
		}

	if (!*pm && !(*pm = X509_VERIFY_PARAM_new()))
		{
		*badarg = 1;
		goto end;
		}

	if (otmp)
		X509_VERIFY_PARAM_add0_policy(*pm, otmp);
	if (flags)
		X509_VERIFY_PARAM_set_flags(*pm, flags);

	if (purpose)
		X509_VERIFY_PARAM_set_purpose(*pm, purpose);

	end:

	(*pargs)++;

	if (pargc)
		*pargc -= *pargs - oldargs;

	return 1;

	}

static void nodes_print(BIO *out, const char *name,
	STACK_OF(X509_POLICY_NODE) *nodes)
	{
	X509_POLICY_NODE *node;
	int i;
	BIO_printf(out, "%s Policies:", name);
	if (nodes)
		{
		BIO_puts(out, "\n");
		for (i = 0; i < sk_X509_POLICY_NODE_num(nodes); i++)
			{
			node = sk_X509_POLICY_NODE_value(nodes, i);
			X509_POLICY_NODE_print(out, node, 2);
			}
		}
	else
		BIO_puts(out, " <empty>\n");
	}

void policies_print(BIO *out, X509_STORE_CTX *ctx)
	{
	X509_POLICY_TREE *tree;
	int explicit_policy;
	int free_out = 0;
	if (out == NULL)
		{
		out = BIO_new_fp(stderr, BIO_NOCLOSE);
		free_out = 1;
		}
	tree = X509_STORE_CTX_get0_policy_tree(ctx);
	explicit_policy = X509_STORE_CTX_get_explicit_policy(ctx);

	BIO_printf(out, "Require explicit Policy: %s\n",
				explicit_policy ? "True" : "False");

	nodes_print(out, "Authority", X509_policy_tree_get0_policies(tree));
	nodes_print(out, "User", X509_policy_tree_get0_user_policies(tree));
	if (free_out)
		BIO_free(out);
	}
@


1.1.1.10
log
@import openssl-0.9.8j
@
text
@a117 1
#include <assert.h>
a131 3
#ifndef OPENSSL_NO_JPAKE
#include <openssl/jpake.h>
#endif
a2335 230

#ifndef OPENSSL_NO_JPAKE

static JPAKE_CTX *jpake_init(const char *us, const char *them,
							 const char *secret)
	{
	BIGNUM *p = NULL;
	BIGNUM *g = NULL;
	BIGNUM *q = NULL;
	BIGNUM *bnsecret = BN_new();
	JPAKE_CTX *ctx;

	/* Use a safe prime for p (that we found earlier) */
	BN_hex2bn(&p, "F9E5B365665EA7A05A9C534502780FEE6F1AB5BD4F49947FD036DBD7E905269AF46EF28B0FC07487EE4F5D20FB3C0AF8E700F3A2FA3414970CBED44FEDFF80CE78D800F184BB82435D137AADA2C6C16523247930A63B85661D1FC817A51ACD96168E95898A1F83A79FFB529368AA7833ABD1B0C3AEDDB14D2E1A2F71D99F763F");
	g = BN_new();
	BN_set_word(g, 2);
	q = BN_new();
	BN_rshift1(q, p);

	BN_bin2bn((const unsigned char *)secret, strlen(secret), bnsecret);

	ctx = JPAKE_CTX_new(us, them, p, g, q, bnsecret);
	BN_free(bnsecret);
	BN_free(q);
	BN_free(g);
	BN_free(p);

	return ctx;
	}

static void jpake_send_part(BIO *conn, const JPAKE_STEP_PART *p)
	{
	BN_print(conn, p->gx);
	BIO_puts(conn, "\n");
	BN_print(conn, p->zkpx.gr);
	BIO_puts(conn, "\n");
	BN_print(conn, p->zkpx.b);
	BIO_puts(conn, "\n");
	}

static void jpake_send_step1(BIO *bconn, JPAKE_CTX *ctx)
	{
	JPAKE_STEP1 s1;

	JPAKE_STEP1_init(&s1);
	JPAKE_STEP1_generate(&s1, ctx);
	jpake_send_part(bconn, &s1.p1);
	jpake_send_part(bconn, &s1.p2);
	(void)BIO_flush(bconn);
	JPAKE_STEP1_release(&s1);
	}

static void jpake_send_step2(BIO *bconn, JPAKE_CTX *ctx)
	{
	JPAKE_STEP2 s2;

	JPAKE_STEP2_init(&s2);
	JPAKE_STEP2_generate(&s2, ctx);
	jpake_send_part(bconn, &s2);
	(void)BIO_flush(bconn);
	JPAKE_STEP2_release(&s2);
	}

static void jpake_send_step3a(BIO *bconn, JPAKE_CTX *ctx)
	{
	JPAKE_STEP3A s3a;

	JPAKE_STEP3A_init(&s3a);
	JPAKE_STEP3A_generate(&s3a, ctx);
	BIO_write(bconn, s3a.hhk, sizeof s3a.hhk);
	(void)BIO_flush(bconn);
	JPAKE_STEP3A_release(&s3a);
	}

static void jpake_send_step3b(BIO *bconn, JPAKE_CTX *ctx)
	{
	JPAKE_STEP3B s3b;

	JPAKE_STEP3B_init(&s3b);
	JPAKE_STEP3B_generate(&s3b, ctx);
	BIO_write(bconn, s3b.hk, sizeof s3b.hk);
	(void)BIO_flush(bconn);
	JPAKE_STEP3B_release(&s3b);
	}

static void readbn(BIGNUM **bn, BIO *bconn)
	{
	char buf[10240];
	int l;

	l = BIO_gets(bconn, buf, sizeof buf);
	assert(l >= 0);
	assert(buf[l-1] == '\n');
	buf[l-1] = '\0';
	BN_hex2bn(bn, buf);
	}

static void jpake_receive_part(JPAKE_STEP_PART *p, BIO *bconn)
	{
	readbn(&p->gx, bconn);
	readbn(&p->zkpx.gr, bconn);
	readbn(&p->zkpx.b, bconn);
	}

static void jpake_receive_step1(JPAKE_CTX *ctx, BIO *bconn)
	{
	JPAKE_STEP1 s1;

	JPAKE_STEP1_init(&s1);
	jpake_receive_part(&s1.p1, bconn);
	jpake_receive_part(&s1.p2, bconn);
	if(!JPAKE_STEP1_process(ctx, &s1))
		{
		ERR_print_errors(bio_err);
		exit(1);
		}
	JPAKE_STEP1_release(&s1);
	}

static void jpake_receive_step2(JPAKE_CTX *ctx, BIO *bconn)
	{
	JPAKE_STEP2 s2;

	JPAKE_STEP2_init(&s2);
	jpake_receive_part(&s2, bconn);
	if(!JPAKE_STEP2_process(ctx, &s2))
		{
		ERR_print_errors(bio_err);
		exit(1);
		}
	JPAKE_STEP2_release(&s2);
	}

static void jpake_receive_step3a(JPAKE_CTX *ctx, BIO *bconn)
	{
	JPAKE_STEP3A s3a;
	int l;

	JPAKE_STEP3A_init(&s3a);
	l = BIO_read(bconn, s3a.hhk, sizeof s3a.hhk);
	assert(l == sizeof s3a.hhk);
	if(!JPAKE_STEP3A_process(ctx, &s3a))
		{
		ERR_print_errors(bio_err);
		exit(1);
		}
	JPAKE_STEP3A_release(&s3a);
	}

static void jpake_receive_step3b(JPAKE_CTX *ctx, BIO *bconn)
	{
	JPAKE_STEP3B s3b;
	int l;

	JPAKE_STEP3B_init(&s3b);
	l = BIO_read(bconn, s3b.hk, sizeof s3b.hk);
	assert(l == sizeof s3b.hk);
	if(!JPAKE_STEP3B_process(ctx, &s3b))
		{
		ERR_print_errors(bio_err);
		exit(1);
		}
	JPAKE_STEP3B_release(&s3b);
	}

void jpake_client_auth(BIO *out, BIO *conn, const char *secret)
	{
	JPAKE_CTX *ctx;
	BIO *bconn;

	BIO_puts(out, "Authenticating with JPAKE\n");

	ctx = jpake_init("client", "server", secret);

	bconn = BIO_new(BIO_f_buffer());
	BIO_push(bconn, conn);

	jpake_send_step1(bconn, ctx);
	jpake_receive_step1(ctx, bconn);
	jpake_send_step2(bconn, ctx);
	jpake_receive_step2(ctx, bconn);
	jpake_send_step3a(bconn, ctx);
	jpake_receive_step3b(ctx, bconn);

	/*
	 * The problem is that you must use the derived key in the
	 * session key or you are subject to man-in-the-middle
	 * attacks.
	 */
	BIO_puts(out, "JPAKE authentication succeeded (N.B. This version can"
		 " be MitMed. See the version in HEAD for how to do it"
		 " properly)\n");

	BIO_pop(bconn);
	BIO_free(bconn);
	}

void jpake_server_auth(BIO *out, BIO *conn, const char *secret)
	{
	JPAKE_CTX *ctx;
	BIO *bconn;

	BIO_puts(out, "Authenticating with JPAKE\n");

	ctx = jpake_init("server", "client", secret);

	bconn = BIO_new(BIO_f_buffer());
	BIO_push(bconn, conn);

	jpake_receive_step1(ctx, bconn);
	jpake_send_step1(bconn, ctx);
	jpake_receive_step2(ctx, bconn);
	jpake_send_step2(bconn, ctx);
	jpake_receive_step3a(ctx, bconn);
	jpake_send_step3b(bconn, ctx);

	/*
	 * The problem is that you must use the derived key in the
	 * session key or you are subject to man-in-the-middle
	 * attacks.
	 */
	BIO_puts(out, "JPAKE authentication succeeded (N.B. This version can"
		 " be MitMed. See the version in HEAD for how to do it"
		 " properly)\n");

	BIO_pop(bconn);
	BIO_free(bconn);
	}

#endif
@


1.1.1.11
log
@import of OpenSSL 0.9.8k
@
text
@d2431 1
a2431 1
	assert(l > 0);
@


1.1.1.12
log
@import OpenSSL-1.0.0a
@
text
@a111 6
#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 2	/* On VMS, you need to define this to get
				   the declaration of fileno().  The value
				   2 is to make sure no function defined
				   in POSIX-2 is left undefined. */
#endif
a114 3
#if !defined(OPENSSL_SYSNAME_WIN32) && !defined(NETWARE_CLIB)
#include <strings.h>
#endif
d116 1
a117 1
#include <errno.h>
a140 5
#ifdef _WIN32
static int WIN32_rename(const char *from, const char *to);
#define rename(from,to) WIN32_rename((from),(to))
#endif

d169 3
a176 9
	if (fseek(fp,0,SEEK_END)==0)
		len=ftell(fp), rewind(fp);
	else	len=-1;
	if (len<=0)
		{
		fclose(fp);
		return(0);
		}

d180 1
d245 6
a250 6
  	else if ((*s == 'N') || (*s == 'n'))
  		return(FORMAT_NETSCAPE);
  	else if ((*s == 'S') || (*s == 's'))
  		return(FORMAT_SMIME);
 	else if ((*s == 'M') || (*s == 'm'))
 		return(FORMAT_MSBLOB);
a256 7
	else if ((*s == 'P') || (*s == 'p'))
 		{
 		if (s[1] == 'V' || s[1] == 'v')
 			return FORMAT_PVK;
 		else
  			return(FORMAT_PEM);
 		}
a641 9
#if !defined(_WIN32)
		/*
		 * Under _WIN32, which covers even Win64 and CE, file
		 * descriptors referenced by BIO_s_fd are not inherited
		 * by child process and therefore below is not an option.
		 * It could have been an option if bss_fd.c was operating
		 * on real Windows descriptors, such as those obtained
		 * with CreateFile.
		 */
a652 1
#endif
d752 2
a764 1
#ifdef _IONBF
a765 1
#endif
d783 17
a799 3
		NETSCAPE_X509 *nx;
		nx=ASN1_item_d2i_bio(ASN1_ITEM_rptr(NETSCAPE_X509),cert,NULL);
		if (nx == NULL)
d801 4
d806 6
a811 2
		if ((strncmp(NETSCAPE_CERT_HDR,(char *)nx->header->data,
			nx->header->length) != 0))
a812 1
			NETSCAPE_X509_free(nx);
d816 7
a822 3
		x=nx->cert;
		nx->cert = NULL;
		NETSCAPE_X509_free(nx);
d844 1
d846 1
d869 1
a869 1
			BIO_printf(err,"no engine specified\n");
a870 1
			{
a872 6
			if (!pkey) 
				{
				BIO_printf(err,"cannot load %s from engine\n",key_descrip);
				ERR_print_errors(err);
				}	
			}
a883 1
#ifdef _IONBF
a884 1
#endif
a914 7
#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_DSA) && !defined (OPENSSL_NO_RC4)
	else if (format == FORMAT_MSBLOB)
		pkey = b2i_PrivateKey_bio(key);
	else if (format == FORMAT_PVK)
		pkey = b2i_PVK_bio(key, (pem_password_cb *)password_callback,
								&cb_data);
#endif
d922 1
a922 2
	if (pkey == NULL) 
		{
a923 2
		ERR_print_errors(err);
		}	
a960 1
#ifdef _IONBF
a961 1
#endif
a975 31
#ifndef OPENSSL_NO_RSA
	else if (format == FORMAT_ASN1RSA)
		{
		RSA *rsa;
		rsa = d2i_RSAPublicKey_bio(key, NULL);
		if (rsa)
			{
			pkey = EVP_PKEY_new();
			if (pkey)
				EVP_PKEY_set1_RSA(pkey, rsa);
			RSA_free(rsa);
			}
		else
			pkey = NULL;
		}
	else if (format == FORMAT_PEMRSA)
		{
		RSA *rsa;
		rsa = PEM_read_bio_RSAPublicKey(key, NULL, 
			(pem_password_cb *)password_callback, &cb_data);
		if (rsa)
			{
			pkey = EVP_PKEY_new();
			if (pkey)
				EVP_PKEY_set1_RSA(pkey, rsa);
			RSA_free(rsa);
			}
		else
			pkey = NULL;
		}
#endif
a984 4
#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_DSA)
	else if (format == FORMAT_MSBLOB)
		pkey = b2i_PublicKey_bio(key);
#endif
d1043 2
a1044 3
static int load_certs_crls(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *desc,
	STACK_OF(X509) **pcerts, STACK_OF(X509_CRL) **pcrls)
d1046 1
d1048 2
a1049 2
	BIO *bio;
	STACK_OF(X509_INFO) *xis = NULL;
a1051 1
	int rv = 0;
d1056 1
a1056 1
	if (format != FORMAT_PEM)
d1058 2
a1059 2
		BIO_printf(err,"bad input format specified for %s\n", desc);
		return 0;
d1063 1
a1063 1
		bio = BIO_new_fp(stdin,BIO_NOCLOSE);
a1064 3
		bio = BIO_new_file(file, "r");

	if (bio == NULL)
d1066 5
a1070 15
		BIO_printf(err, "Error opening %s %s\n",
				desc, file ? file : "stdin");
		ERR_print_errors(err);
		return 0;
		}

	xis = PEM_X509_INFO_read_bio(bio, NULL,
				(pem_password_cb *)password_callback, &cb_data);

	BIO_free(bio);

	if (pcerts)
		{
		*pcerts = sk_X509_new_null();
		if (!*pcerts)
d1072 1
d1075 1
a1075 1
	if (pcrls)
d1077 5
a1081 2
		*pcrls = sk_X509_CRL_new_null();
		if (!*pcrls)
a1082 10
		}

	for(i = 0; i < sk_X509_INFO_num(xis); i++)
		{
		xi = sk_X509_INFO_value (xis, i);
		if (xi->x509 && pcerts)
			{
			if (!sk_X509_push(*pcerts, xi->x509))
				goto end;
			xi->x509 = NULL;
d1084 3
a1086 1
		if (xi->crl && pcrls)
d1088 6
a1093 3
			if (!sk_X509_CRL_push(*pcrls, xi->crl))
				goto end;
			xi->crl = NULL;
d1095 1
d1097 7
a1103 13

	if (pcerts && sk_X509_num(*pcerts) > 0)
		rv = 1;

	if (pcrls && sk_X509_CRL_num(*pcrls) > 0)
		rv = 1;

	end:

	if (xis)
		sk_X509_INFO_pop_free(xis, X509_INFO_free);

	if (rv == 0)
d1105 1
a1105 12
		if (pcerts)
			{
			sk_X509_pop_free(*pcerts, X509_free);
			*pcerts = NULL;
			}
		if (pcrls)
			{
			sk_X509_CRL_pop_free(*pcrls, X509_CRL_free);
			*pcrls = NULL;
			}
		BIO_printf(err,"unable to load %s\n",
				pcerts ? "certificates" : "CRLs");
d1108 3
a1110 1
	return rv;
a1112 15
STACK_OF(X509) *load_certs(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *desc)
	{
	STACK_OF(X509) *certs;
	load_certs_crls(err, file, format, pass, e, desc, &certs, NULL);
	return certs;
	}	

STACK_OF(X509_CRL) *load_crls(BIO *err, const char *file, int format,
	const char *pass, ENGINE *e, const char *desc)
	{
	STACK_OF(X509_CRL) *crls;
	load_certs_crls(err, file, format, pass, e, desc, NULL, &crls);
	return crls;
	}	
a1398 4
	static int load_config_called = 0;
	if (load_config_called)
		return 1;
	load_config_called = 1;
d1432 1
a1432 1
static unsigned long index_serial_hash(const OPENSSL_CSTRING *a)
d1441 1
a1441 1
static int index_serial_cmp(const OPENSSL_CSTRING *a, const OPENSSL_CSTRING *b)
d1453 1
a1453 1
static unsigned long index_name_hash(const OPENSSL_CSTRING *a)
d1456 8
a1463 7
int index_name_cmp(const OPENSSL_CSTRING *a, const OPENSSL_CSTRING *b)
	{ return(strcmp(a[DB_name], b[DB_name])); }

static IMPLEMENT_LHASH_HASH_FN(index_serial, OPENSSL_CSTRING)
static IMPLEMENT_LHASH_COMP_FN(index_serial, OPENSSL_CSTRING)
static IMPLEMENT_LHASH_HASH_FN(index_name, OPENSSL_CSTRING)
static IMPLEMENT_LHASH_COMP_FN(index_name, OPENSSL_CSTRING)
d1591 1
d1616 3
a1618 5
#ifdef RL_DEBUG
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
		serialfile, buf[1]);
#endif
	if (rename(serialfile,buf[1]) < 0 && errno != ENOENT
d1622 11
a1632 1
	   )		{
d1639 1
d1706 2
d1709 1
d1770 2
a1771 2
				LHASH_HASH_FN(index_serial),
				LHASH_COMP_FN(index_serial)))
d1781 2
a1782 2
			LHASH_HASH_FN(index_name),
			LHASH_COMP_FN(index_name)))
d1862 1
d1906 11
d1918 2
a1919 2
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
		dbfile, buf[1]);
d1921 2
a1922 5
	if (rename(dbfile,buf[1]) < 0 && errno != ENOENT
#ifdef ENOTDIR
		&& errno != ENOTDIR
#endif
	   )		{
d1929 1
d1943 11
d1955 2
a1956 2
	BIO_printf(bio_err, "DEBUG: renaming \"%s\" to \"%s\"\n",
		buf[4],buf[3]);
d1958 2
a1959 5
	if (rename(buf[4],buf[3]) < 0 && errno != ENOENT
#ifdef ENOTDIR
		&& errno != ENOTDIR
#endif
	   )		{
d1968 1
d2163 39
d2208 1
a2208 1
	int purpose = 0, depth = -1;
a2247 15
	else if (strcmp(arg,"-verify_depth") == 0)
		{
		if (!argn)
			*badarg = 1;
		else
			{
			depth = atoi(argn);
			if(depth < 0)
				{
				BIO_printf(err, "invalid depth\n");
				*badarg = 1;
				}
			}
		(*pargs)++;
		}
a2259 4
	else if (!strcmp(arg, "-inhibit_any"))
		flags |= X509_V_FLAG_INHIBIT_ANY;
	else if (!strcmp(arg, "-inhibit_map"))
		flags |= X509_V_FLAG_INHIBIT_MAP;
a2261 4
	else if (!strcmp(arg, "-extended_crl"))
		flags |= X509_V_FLAG_EXTENDED_CRL_SUPPORT;
	else if (!strcmp(arg, "-use_deltas"))
		flags |= X509_V_FLAG_USE_DELTAS;
a2263 2
	else if (!strcmp(arg, "-check_ss_sig"))
		flags |= X509_V_FLAG_CHECK_SS_SIGNATURE;
a2288 3
	if (depth >= 0)
		X509_VERIFY_PARAM_set_depth(*pm, depth);

a2299 55
/* Read whole contents of a BIO into an allocated memory buffer and
 * return it.
 */

int bio_to_mem(unsigned char **out, int maxlen, BIO *in)
	{
	BIO *mem;
	int len, ret;
	unsigned char tbuf[1024];
	mem = BIO_new(BIO_s_mem());
	if (!mem)
		return -1;
	for(;;)
		{
		if ((maxlen != -1) && maxlen < 1024)
			len = maxlen;
		else
			len = 1024;
		len = BIO_read(in, tbuf, len);
		if (len <= 0)
			break;
		if (BIO_write(mem, tbuf, len) != len)
			{
			BIO_free(mem);
			return -1;
			}
		maxlen -= len;

		if (maxlen == 0)
			break;
		}
	ret = BIO_get_mem_data(mem, (char **)out);
	BIO_set_flags(mem, BIO_FLAGS_MEM_RDONLY);
	BIO_free(mem);
	return ret;
	}

int pkey_ctrl_string(EVP_PKEY_CTX *ctx, char *value)
	{
	int rv;
	char *stmp, *vtmp = NULL;
	stmp = BUF_strdup(value);
	if (!stmp)
		return -1;
	vtmp = strchr(stmp, ':');
	if (vtmp)
		{
		*vtmp = 0;
		vtmp++;
		}
	rv = EVP_PKEY_CTX_ctrl_str(ctx, stmp, vtmp);
	OPENSSL_free(stmp);
	return rv;
	}

d2341 1
a2341 1
#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)
d2524 8
a2531 3
	BIO_puts(out, "JPAKE authentication succeeded, setting PSK\n");

	psk_key = BN_bn2hex(JPAKE_get_shared_key(ctx));
a2534 2

	JPAKE_CTX_free(ctx);
d2556 8
a2563 3
	BIO_puts(out, "JPAKE authentication succeeded, setting PSK\n");

	psk_key = BN_bn2hex(JPAKE_get_shared_key(ctx));
a2566 2

	JPAKE_CTX_free(ctx);
a2568 326
#endif

/*
 * Platform-specific sections
 */
#if defined(_WIN32)
# ifdef fileno
#  undef fileno
#  define fileno(a) (int)_fileno(a)
# endif

# include <windows.h>
# include <tchar.h>

static int WIN32_rename(const char *from, const char *to)
	{
	TCHAR  *tfrom=NULL,*tto;
	DWORD	err;
	int	ret=0;

	if (sizeof(TCHAR) == 1)
		{
		tfrom = (TCHAR *)from;
		tto   = (TCHAR *)to;
		}
	else	/* UNICODE path */
		{
		size_t i,flen=strlen(from)+1,tlen=strlen(to)+1;
		tfrom = (TCHAR *)malloc(sizeof(TCHAR)*(flen+tlen));
		if (tfrom==NULL) goto err;
		tto=tfrom+flen;
#if !defined(_WIN32_WCE) || _WIN32_WCE>=101
		if (!MultiByteToWideChar(CP_ACP,0,from,flen,(WCHAR *)tfrom,flen))
#endif
			for (i=0;i<flen;i++)	tfrom[i]=(TCHAR)from[i];
#if !defined(_WIN32_WCE) || _WIN32_WCE>=101
		if (!MultiByteToWideChar(CP_ACP,0,to,  tlen,(WCHAR *)tto,  tlen))
#endif
			for (i=0;i<tlen;i++)	tto[i]  =(TCHAR)to[i];
		}

	if (MoveFile(tfrom,tto))	goto ok;
	err=GetLastError();
	if (err==ERROR_ALREADY_EXISTS || err==ERROR_FILE_EXISTS)
		{
		if (DeleteFile(tto) && MoveFile(tfrom,tto))
			goto ok;
		err=GetLastError();
		}
	if (err==ERROR_FILE_NOT_FOUND || err==ERROR_PATH_NOT_FOUND)
		errno = ENOENT;
	else if (err==ERROR_ACCESS_DENIED)
		errno = EACCES;
	else
		errno = EINVAL;	/* we could map more codes... */
err:
	ret=-1;
ok:
	if (tfrom!=NULL && tfrom!=(TCHAR *)from)	free(tfrom);
	return ret;
	}
#endif

/* app_tminterval section */
#if defined(_WIN32)
double app_tminterval(int stop,int usertime)
	{
	FILETIME		now;
	double			ret=0;
	static ULARGE_INTEGER	tmstart;
	static int		warning=1;
#ifdef _WIN32_WINNT
	static HANDLE		proc=NULL;

	if (proc==NULL)
		{
		if (GetVersion() < 0x80000000)
			proc = OpenProcess(PROCESS_QUERY_INFORMATION,FALSE,
						GetCurrentProcessId());
		if (proc==NULL) proc = (HANDLE)-1;
		}

	if (usertime && proc!=(HANDLE)-1)
		{
		FILETIME junk;
		GetProcessTimes(proc,&junk,&junk,&junk,&now);
		}
	else
#endif
		{
		SYSTEMTIME systime;

		if (usertime && warning)
			{
			BIO_printf(bio_err,"To get meaningful results, run "
					   "this program on idle system.\n");
			warning=0;
			}
		GetSystemTime(&systime);
		SystemTimeToFileTime(&systime,&now);
		}

	if (stop==TM_START)
		{
		tmstart.u.LowPart  = now.dwLowDateTime;
		tmstart.u.HighPart = now.dwHighDateTime;
		}
	else	{
		ULARGE_INTEGER tmstop;

		tmstop.u.LowPart   = now.dwLowDateTime;
		tmstop.u.HighPart  = now.dwHighDateTime;

		ret = (__int64)(tmstop.QuadPart - tmstart.QuadPart)*1e-7;
		}

	return (ret);
	}

#elif defined(OPENSSL_SYS_NETWARE)
#include <time.h>

double app_tminterval(int stop,int usertime)
	{
	double		ret=0;
	static clock_t	tmstart;
	static int	warning=1;

	if (usertime && warning)
		{
		BIO_printf(bio_err,"To get meaningful results, run "
				   "this program on idle system.\n");
		warning=0;
		}

	if (stop==TM_START)	tmstart = clock();
	else			ret     = (clock()-tmstart)/(double)CLOCKS_PER_SEC;

	return (ret);
	}

#elif defined(OPENSSL_SYSTEM_VXWORKS)
#include <time.h>

double app_tminterval(int stop,int usertime)
	{
	double ret=0;
#ifdef CLOCK_REALTIME
	static struct timespec	tmstart;
	struct timespec		now;
#else
	static unsigned long	tmstart;
	unsigned long		now;
#endif
	static int warning=1;

	if (usertime && warning)
		{
		BIO_printf(bio_err,"To get meaningful results, run "
				   "this program on idle system.\n");
		warning=0;
		}

#ifdef CLOCK_REALTIME
	clock_gettime(CLOCK_REALTIME,&now);
	if (stop==TM_START)	tmstart = now;
	else	ret = ( (now.tv_sec+now.tv_nsec*1e-9)
			- (tmstart.tv_sec+tmstart.tv_nsec*1e-9) );
#else
	now = tickGet();
	if (stop==TM_START)	tmstart = now;
	else			ret = (now - tmstart)/(double)sysClkRateGet();
#endif
	return (ret);
	}

#elif defined(OPENSSL_SYSTEM_VMS)
#include <time.h>
#include <times.h>

double app_tminterval(int stop,int usertime)
	{
	static clock_t	tmstart;
	double		ret = 0;
	clock_t		now;
#ifdef __TMS
	struct tms	rus;

	now = times(&rus);
	if (usertime)	now = rus.tms_utime;
#else
	if (usertime)
		now = clock(); /* sum of user and kernel times */
	else	{
		struct timeval tv;
		gettimeofday(&tv,NULL);
		now = (clock_t)(
			(unsigned long long)tv.tv_sec*CLK_TCK +
			(unsigned long long)tv.tv_usec*(1000000/CLK_TCK)
			);
		}
#endif
	if (stop==TM_START)	tmstart = now;
	else			ret = (now - tmstart)/(double)(CLK_TCK);

	return (ret);
	}

#elif defined(_SC_CLK_TCK)	/* by means of unistd.h */
#include <sys/times.h>

double app_tminterval(int stop,int usertime)
	{
	double		ret = 0;
	struct tms	rus;
	clock_t		now = times(&rus);
	static clock_t	tmstart;

	if (usertime)		now = rus.tms_utime;

	if (stop==TM_START)	tmstart = now;
	else
		{
		long int tck = sysconf(_SC_CLK_TCK);
		ret = (now - tmstart)/(double)tck;
		}

	return (ret);
	}

#else
#include <sys/time.h>
#include <sys/resource.h>

double app_tminterval(int stop,int usertime)
	{
	double		ret = 0;
	struct rusage	rus;
	struct timeval	now;
	static struct timeval tmstart;

	if (usertime)		getrusage(RUSAGE_SELF,&rus), now = rus.ru_utime;
	else			gettimeofday(&now,NULL);

	if (stop==TM_START)	tmstart = now;
	else			ret = ( (now.tv_sec+now.tv_usec*1e-6)
					- (tmstart.tv_sec+tmstart.tv_usec*1e-6) );

	return ret;
	}
#endif

/* app_isdir section */
#ifdef _WIN32
int app_isdir(const char *name)
	{
	HANDLE		hList;
	WIN32_FIND_DATA	FileData;
#if defined(UNICODE) || defined(_UNICODE)
	size_t i, len_0 = strlen(name)+1;

	if (len_0 > sizeof(FileData.cFileName)/sizeof(FileData.cFileName[0]))
		return -1;

#if !defined(_WIN32_WCE) || _WIN32_WCE>=101
	if (!MultiByteToWideChar(CP_ACP,0,name,len_0,FileData.cFileName,len_0))
#endif
		for (i=0;i<len_0;i++)
			FileData.cFileName[i] = (WCHAR)name[i];

	hList = FindFirstFile(FileData.cFileName,&FileData);
#else
	hList = FindFirstFile(name,&FileData);
#endif
	if (hList == INVALID_HANDLE_VALUE)	return -1;
	FindClose(hList);
	return ((FileData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)!=0);
	}
#else
#include <sys/stat.h>
#ifndef S_ISDIR
# if defined(_S_IFMT) && defined(_S_IFDIR)
#  define S_ISDIR(a)   (((a) & _S_IFMT) == _S_IFDIR)
# else 
#  define S_ISDIR(a)   (((a) & S_IFMT) == S_IFDIR)
# endif 
#endif 

int app_isdir(const char *name)
	{
#if defined(S_ISDIR)
	struct stat st;

	if (stat(name,&st)==0)	return S_ISDIR(st.st_mode);
	else			return -1;
#else
	return -1;
#endif
	}
#endif

/* raw_read|write section */
#if defined(_WIN32) && defined(STD_INPUT_HANDLE)
int raw_read_stdin(void *buf,int siz)
	{
	DWORD n;
	if (ReadFile(GetStdHandle(STD_INPUT_HANDLE),buf,siz,&n,NULL))
		return (n);
	else	return (-1);
	}
#else
int raw_read_stdin(void *buf,int siz)
	{	return read(fileno(stdin),buf,siz);	}
#endif

#if defined(_WIN32) && defined(STD_OUTPUT_HANDLE)
int raw_write_stdout(const void *buf,int siz)
	{
	DWORD n;
	if (WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),buf,siz,&n,NULL))
		return (n);
	else	return (-1);
	}
#else
int raw_write_stdout(const void *buf,int siz)
	{	return write(fileno(stdout),buf,siz);	}
@


1.1.1.13
log
@import OpenSSL 1.0.0e
@
text
@a259 2
	if (s == NULL)
		return FORMAT_UNDEF;
d380 1
a380 1
	int num,i;
d386 1
a799 1
# ifndef OPENSSL_NO_SETVBUF_IONBF
a800 1
# endif /* ndef OPENSSL_NO_SETVBUF_IONBF */
a900 1
# ifndef OPENSSL_NO_SETVBUF_IONBF
a901 1
# endif /* ndef OPENSSL_NO_SETVBUF_IONBF */
a989 1
# ifndef OPENSSL_NO_SETVBUF_IONBF
a990 1
# endif /* ndef OPENSSL_NO_SETVBUF_IONBF */
@


1.1.1.14
log
@import OpenSSL-1.0.1c
@
text
@d112 1
a112 1
#if !defined(_POSIX_C_SOURCE) && defined(OPENSSL_SYS_VMS)
d1218 1
a1218 2
	if (!load_certs_crls(err, file, format, pass, e, desc, &certs, NULL))
		return NULL;
d1226 1
a1226 2
	if (!load_certs_crls(err, file, format, pass, e, desc, NULL, &crls))
		return NULL;
a2258 1
	time_t at_time = 0;
a2310 21
	else if (strcmp(arg,"-attime") == 0)
		{
		if (!argn)
			*badarg = 1;
		else
			{
			long timestamp;
			/* interpret the -attime argument as seconds since
			 * Epoch */
			if (sscanf(argn, "%li", &timestamp) != 1)
				{
				BIO_printf(bio_err,
						"Error parsing timestamp %s\n",
					   	argn);
				*badarg = 1;
				}
			/* on some platforms time_t may be a float */
			at_time = (time_t) timestamp;
			}
		(*pargs)++;
		}
a2364 3
	if (at_time) 
		X509_VERIFY_PARAM_set_time(*pm, at_time);

a2694 44

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
/* next_protos_parse parses a comma separated list of strings into a string
 * in a format suitable for passing to SSL_CTX_set_next_protos_advertised.
 *   outlen: (output) set to the length of the resulting buffer on success.
 *   err: (maybe NULL) on failure, an error message line is written to this BIO.
 *   in: a NUL termianted string like "abc,def,ghi"
 *
 *   returns: a malloced buffer or NULL on failure.
 */
unsigned char *next_protos_parse(unsigned short *outlen, const char *in)
	{
	size_t len;
	unsigned char *out;
	size_t i, start = 0;

	len = strlen(in);
	if (len >= 65535)
		return NULL;

	out = OPENSSL_malloc(strlen(in) + 1);
	if (!out)
		return NULL;

	for (i = 0; i <= len; ++i)
		{
		if (i == len || in[i] == ',')
			{
			if (i - start > 255)
				{
				OPENSSL_free(out);
				return NULL;
				}
			out[start] = i - start;
			start = i + 1;
			}
		else
			out[i+1] = in[i];
		}

	*outlen = len + 1;
	return out;
	}
#endif  /* !OPENSSL_NO_TLSEXT && !OPENSSL_NO_NEXTPROTONEG */
@


1.1.1.15
log
@Import OpenSSL 1.0.1g
@
text
@d589 1
a589 1
				PW_MIN_LENGTH,bufsiz-1);
d594 1
a594 1
				PW_MIN_LENGTH,bufsiz-1, buf);
d2135 1
a2135 1
	if (!buf || !ne_types || !ne_values || !mval)
a2238 1
	OPENSSL_free(mval);
a2246 2
	if (mval)
		OPENSSL_free(mval);
d2841 1
a2841 1
		if (check_winnt())
@


