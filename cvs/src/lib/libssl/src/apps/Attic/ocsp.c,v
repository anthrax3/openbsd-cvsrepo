head	1.32;
access;
symbols
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	butholakala:1.10
	openssl_1_0_1_g:1.1.1.10
	OPENBSD_5_5:1.9.0.16
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.12
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	openssl_1_0_1_c:1.1.1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	openssl_1_0_0_f:1.1.1.9
	openssl_1_0_0_e:1.1.1.9
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	openssh_1_0_0_a:1.1.1.9
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	openssl_0_9_8_k:1.1.1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	openssl_0_9_8_j:1.1.1.8
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.6
	OPENBSD_4_4:1.6.0.18
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.16
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.14
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.12
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.10
	OPENBSD_4_0_BASE:1.6
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.6.0.8
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENSSL_0_9_7G:1.1.1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	OPENSSL_0_9_7D:1.1.1.6
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENSSL_0_9_7C:1.1.1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.31;
commitid	7A7DObXgY4Fni8xJ;

1.31
date	2014.08.24.16.07.29;	author bcook;	state Exp;
branches;
next	1.30;
commitid	DkRmQqUr5tFLfwxx;

1.30
date	2014.07.13.16.03.09;	author beck;	state Exp;
branches;
next	1.29;
commitid	6xdvCwSqBadTW6X3;

1.29
date	2014.07.12.19.31.21;	author jsing;	state Exp;
branches;
next	1.28;
commitid	X84oGf60c5Z5Yd6T;

1.28
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.27;
commitid	0NuggCO2WJOZj8Kh;

1.27
date	2014.06.28.04.39.41;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	gGtvlhTlvaxlmOBo;

1.26
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	mJUVYpkFBZ0Zv2bG;

1.25
date	2014.05.26.13.55.24;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2014.05.02.17.05.41;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.19.16.46.08;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.18.04.33.09;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.18.04.17.16;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.18.02.48.58;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.18.02.45.26;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.18.02.35.57;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.17.20.58.07;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.16.17.52.31;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.16.02.14.27;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.15.21.47.56;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.13.15.25.28;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.50;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.09.12.15.19;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.47;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.11.22.15.18;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.10.16.31.53;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.09;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.33;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.34.28;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.12.20.42.50;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.21;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.10.43;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.41.29;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.38;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.13.49;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: ocsp.c,v 1.31 2014/08/24 16:07:29 bcook Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
#ifndef OPENSSL_NO_OCSP

#include <sys/select.h>

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <time.h>

/* Needs to be included before the openssl headers! */
#include "apps.h"

#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

/* Maximum leeway in validity period: default 5 minutes */
#define MAX_VALIDITY_PERIOD	(5 * 60)

static int
add_ocsp_cert(OCSP_REQUEST ** req, X509 * cert, const EVP_MD * cert_id_md, X509 * issuer,
    STACK_OF(OCSP_CERTID) * ids);
static int add_ocsp_serial(OCSP_REQUEST ** req, char *serial, const EVP_MD * cert_id_md, X509 * issuer,
    STACK_OF(OCSP_CERTID) * ids);
static int print_ocsp_summary(BIO * out, OCSP_BASICRESP * bs, OCSP_REQUEST * req,
    STACK_OF(OPENSSL_STRING) * names,
    STACK_OF(OCSP_CERTID) * ids, long nsec,
    long maxage);

static int make_ocsp_response(OCSP_RESPONSE ** resp, OCSP_REQUEST * req, CA_DB * db,
    X509 * ca, X509 * rcert, EVP_PKEY * rkey,
    STACK_OF(X509) * rother, unsigned long flags,
    int nmin, int ndays);

static char **lookup_serial(CA_DB * db, ASN1_INTEGER * ser);
static BIO *init_responder(char *port);
static int do_responder(OCSP_REQUEST ** preq, BIO ** pcbio, BIO * acbio, char *port);
static int send_ocsp_response(BIO * cbio, OCSP_RESPONSE * resp);
static OCSP_RESPONSE *query_responder(BIO * err, BIO * cbio, char *path,
    STACK_OF(CONF_VALUE) * headers,
    OCSP_REQUEST * req, int req_timeout);


int ocsp_main(int, char **);

int
ocsp_main(int argc, char **argv)
{
	ENGINE *e = NULL;
	char **args;
	char *host = NULL, *port = NULL, *path = "/";
	char *reqin = NULL, *respin = NULL;
	char *reqout = NULL, *respout = NULL;
	char *signfile = NULL, *keyfile = NULL;
	char *rsignfile = NULL, *rkeyfile = NULL;
	char *outfile = NULL;
	int add_nonce = 1, noverify = 0, use_ssl = -1;
	STACK_OF(CONF_VALUE) * headers = NULL;
	OCSP_REQUEST *req = NULL;
	OCSP_RESPONSE *resp = NULL;
	OCSP_BASICRESP *bs = NULL;
	X509 *issuer = NULL, *cert = NULL;
	X509 *signer = NULL, *rsigner = NULL;
	EVP_PKEY *key = NULL, *rkey = NULL;
	BIO *acbio = NULL, *cbio = NULL;
	BIO *derbio = NULL;
	BIO *out = NULL;
	int req_timeout = -1;
	int req_text = 0, resp_text = 0;
	long nsec = MAX_VALIDITY_PERIOD, maxage = -1;
	char *CAfile = NULL, *CApath = NULL;
	X509_STORE *store = NULL;
	STACK_OF(X509) * sign_other = NULL, *verify_other = NULL, *rother = NULL;
	char *sign_certfile = NULL, *verify_certfile = NULL, *rcertfile = NULL;
	unsigned long sign_flags = 0, verify_flags = 0, rflags = 0;
	int ret = 1;
	int accept_count = -1;
	int badarg = 0;
	int i;
	int ignore_err = 0;
	STACK_OF(OPENSSL_STRING) * reqnames = NULL;
	STACK_OF(OCSP_CERTID) * ids = NULL;
	X509 *rca_cert = NULL;
	char *ridx_filename = NULL;
	char *rca_filename = NULL;
	CA_DB *rdb = NULL;
	int nmin = 0, ndays = -1;
	const EVP_MD *cert_id_md = NULL;
	const char *errstr = NULL;

	args = argv + 1;
	reqnames = sk_OPENSSL_STRING_new_null();
	ids = sk_OCSP_CERTID_new_null();
	while (!badarg && *args && *args[0] == '-') {
		if (!strcmp(*args, "-out")) {
			if (args[1]) {
				args++;
				outfile = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-timeout")) {
			if (args[1]) {
				args++;
				req_timeout = strtonum(*args, 0,
				    INT_MAX, &errstr);
				if (errstr) {
					BIO_printf(bio_err,
					    "Illegal timeout value %s: %s\n",
					    *args, errstr);
					badarg = 1;
				}
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-url")) {
			if (args[1]) {
				args++;
				if (!OCSP_parse_url(*args, &host, &port, &path, &use_ssl)) {
					BIO_printf(bio_err, "Error parsing URL\n");
					badarg = 1;
				}
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-host")) {
			if (args[1]) {
				args++;
				host = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-port")) {
			if (args[1]) {
				args++;
				port = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-header")) {
			if (args[1] && args[2]) {
				if (!X509V3_add_value(args[1], args[2], &headers))
					goto end;
				args += 2;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-ignore_err"))
			ignore_err = 1;
		else if (!strcmp(*args, "-noverify"))
			noverify = 1;
		else if (!strcmp(*args, "-nonce"))
			add_nonce = 2;
		else if (!strcmp(*args, "-no_nonce"))
			add_nonce = 0;
		else if (!strcmp(*args, "-resp_no_certs"))
			rflags |= OCSP_NOCERTS;
		else if (!strcmp(*args, "-resp_key_id"))
			rflags |= OCSP_RESPID_KEY;
		else if (!strcmp(*args, "-no_certs"))
			sign_flags |= OCSP_NOCERTS;
		else if (!strcmp(*args, "-no_signature_verify"))
			verify_flags |= OCSP_NOSIGS;
		else if (!strcmp(*args, "-no_cert_verify"))
			verify_flags |= OCSP_NOVERIFY;
		else if (!strcmp(*args, "-no_chain"))
			verify_flags |= OCSP_NOCHAIN;
		else if (!strcmp(*args, "-no_cert_checks"))
			verify_flags |= OCSP_NOCHECKS;
		else if (!strcmp(*args, "-no_explicit"))
			verify_flags |= OCSP_NOEXPLICIT;
		else if (!strcmp(*args, "-trust_other"))
			verify_flags |= OCSP_TRUSTOTHER;
		else if (!strcmp(*args, "-no_intern"))
			verify_flags |= OCSP_NOINTERN;
		else if (!strcmp(*args, "-text")) {
			req_text = 1;
			resp_text = 1;
		} else if (!strcmp(*args, "-req_text"))
			req_text = 1;
		else if (!strcmp(*args, "-resp_text"))
			resp_text = 1;
		else if (!strcmp(*args, "-reqin")) {
			if (args[1]) {
				args++;
				reqin = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-respin")) {
			if (args[1]) {
				args++;
				respin = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-signer")) {
			if (args[1]) {
				args++;
				signfile = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-VAfile")) {
			if (args[1]) {
				args++;
				verify_certfile = *args;
				verify_flags |= OCSP_TRUSTOTHER;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-sign_other")) {
			if (args[1]) {
				args++;
				sign_certfile = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-verify_other")) {
			if (args[1]) {
				args++;
				verify_certfile = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-CAfile")) {
			if (args[1]) {
				args++;
				CAfile = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-CApath")) {
			if (args[1]) {
				args++;
				CApath = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-validity_period")) {
			if (args[1]) {
				args++;
				nsec = strtonum(*args, 0, LONG_MAX, &errstr);
				if (errstr) {
					BIO_printf(bio_err,
					    "Illegal validity period %s: %s\n",
					    *args, errstr);
					badarg = 1;
				}
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-status_age")) {
			if (args[1]) {
				args++;
				maxage = strtonum(*args, 0, LONG_MAX, &errstr);
				if (errstr) {
					BIO_printf(bio_err,
					    "Illegal validity age %s: %s\n",
					    *args, errstr);
					badarg = 1;
				}
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-signkey")) {
			if (args[1]) {
				args++;
				keyfile = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-reqout")) {
			if (args[1]) {
				args++;
				reqout = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-respout")) {
			if (args[1]) {
				args++;
				respout = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-path")) {
			if (args[1]) {
				args++;
				path = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-issuer")) {
			if (args[1]) {
				args++;
				X509_free(issuer);
				issuer = load_cert(bio_err, *args, FORMAT_PEM,
				    NULL, e, "issuer certificate");
				if (!issuer)
					goto end;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-cert")) {
			if (args[1]) {
				args++;
				X509_free(cert);
				cert = load_cert(bio_err, *args, FORMAT_PEM,
				    NULL, e, "certificate");
				if (!cert)
					goto end;
				if (!cert_id_md)
					cert_id_md = EVP_sha1();
				if (!add_ocsp_cert(&req, cert, cert_id_md, issuer, ids))
					goto end;
				if (!sk_OPENSSL_STRING_push(reqnames, *args))
					goto end;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-serial")) {
			if (args[1]) {
				args++;
				if (!cert_id_md)
					cert_id_md = EVP_sha1();
				if (!add_ocsp_serial(&req, *args, cert_id_md, issuer, ids))
					goto end;
				if (!sk_OPENSSL_STRING_push(reqnames, *args))
					goto end;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-index")) {
			if (args[1]) {
				args++;
				ridx_filename = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-CA")) {
			if (args[1]) {
				args++;
				rca_filename = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-nmin")) {
			if (args[1]) {
				args++;
				nmin = strtonum(*args, 0, INT_MAX, &errstr);
				if (errstr) {
					BIO_printf(bio_err,
					    "Illegal update period %s: %s\n",
					    *args, errstr);
					badarg = 1;
				}
			}
			if (ndays == -1)
				ndays = 0;
			else
				badarg = 1;
		} else if (!strcmp(*args, "-nrequest")) {
			if (args[1]) {
				args++;
				accept_count = strtonum(*args, 0, INT_MAX, &errstr);
				if (errstr) {
					BIO_printf(bio_err,
					    "Illegal accept count %s: %s\n",
					    *args, errstr);
					badarg = 1;
				}
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-ndays")) {
			if (args[1]) {
				args++;
				ndays = strtonum(*args, 0, INT_MAX, &errstr);
				if (errstr) {
					BIO_printf(bio_err,
					    "Illegal update period %s: %s\n",
					    *args, errstr);
					badarg = 1;
				}
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-rsigner")) {
			if (args[1]) {
				args++;
				rsignfile = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-rkey")) {
			if (args[1]) {
				args++;
				rkeyfile = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-rother")) {
			if (args[1]) {
				args++;
				rcertfile = *args;
			} else
				badarg = 1;
		} else if ((cert_id_md = EVP_get_digestbyname((*args) + 1)) == NULL) {
			badarg = 1;
		}
		args++;
	}

	/* Have we anything to do? */
	if (!req && !reqin && !respin && !(port && ridx_filename))
		badarg = 1;

	if (badarg) {
		BIO_printf(bio_err, "OCSP utility\n");
		BIO_printf(bio_err, "Usage ocsp [options]\n");
		BIO_printf(bio_err, "where options are\n");
		BIO_printf(bio_err, "-out file          output filename\n");
		BIO_printf(bio_err, "-issuer file       issuer certificate\n");
		BIO_printf(bio_err, "-cert file         certificate to check\n");
		BIO_printf(bio_err, "-serial n          serial number to check\n");
		BIO_printf(bio_err, "-signer file       certificate to sign OCSP request with\n");
		BIO_printf(bio_err, "-signkey file      private key to sign OCSP request with\n");
		BIO_printf(bio_err, "-sign_other file   additional certificates to include in signed request\n");
		BIO_printf(bio_err, "-no_certs          don't include any certificates in signed request\n");
		BIO_printf(bio_err, "-req_text          print text form of request\n");
		BIO_printf(bio_err, "-resp_text         print text form of response\n");
		BIO_printf(bio_err, "-text              print text form of request and response\n");
		BIO_printf(bio_err, "-reqout file       write DER encoded OCSP request to \"file\"\n");
		BIO_printf(bio_err, "-respout file      write DER encoded OCSP reponse to \"file\"\n");
		BIO_printf(bio_err, "-reqin file        read DER encoded OCSP request from \"file\"\n");
		BIO_printf(bio_err, "-respin file       read DER encoded OCSP reponse from \"file\"\n");
		BIO_printf(bio_err, "-nonce             add OCSP nonce to request\n");
		BIO_printf(bio_err, "-no_nonce          don't add OCSP nonce to request\n");
		BIO_printf(bio_err, "-url URL           OCSP responder URL\n");
		BIO_printf(bio_err, "-host host:n       send OCSP request to host on port n\n");
		BIO_printf(bio_err, "-path              path to use in OCSP request\n");
		BIO_printf(bio_err, "-CApath dir        trusted certificates directory\n");
		BIO_printf(bio_err, "-CAfile file       trusted certificates file\n");
		BIO_printf(bio_err, "-VAfile file       validator certificates file\n");
		BIO_printf(bio_err, "-validity_period n maximum validity discrepancy in seconds\n");
		BIO_printf(bio_err, "-status_age n      maximum status age in seconds\n");
		BIO_printf(bio_err, "-noverify          don't verify response at all\n");
		BIO_printf(bio_err, "-verify_other file additional certificates to search for signer\n");
		BIO_printf(bio_err, "-trust_other       don't verify additional certificates\n");
		BIO_printf(bio_err, "-no_intern         don't search certificates contained in response for signer\n");
		BIO_printf(bio_err, "-no_signature_verify don't check signature on response\n");
		BIO_printf(bio_err, "-no_cert_verify    don't check signing certificate\n");
		BIO_printf(bio_err, "-no_chain          don't chain verify response\n");
		BIO_printf(bio_err, "-no_cert_checks    don't do additional checks on signing certificate\n");
		BIO_printf(bio_err, "-port num		 port to run responder on\n");
		BIO_printf(bio_err, "-index file	 certificate status index file\n");
		BIO_printf(bio_err, "-CA file		 CA certificate\n");
		BIO_printf(bio_err, "-rsigner file	 responder certificate to sign responses with\n");
		BIO_printf(bio_err, "-rkey file	 responder key to sign responses with\n");
		BIO_printf(bio_err, "-rother file	 other certificates to include in response\n");
		BIO_printf(bio_err, "-resp_no_certs     don't include any certificates in response\n");
		BIO_printf(bio_err, "-nmin n	 	 number of minutes before next update\n");
		BIO_printf(bio_err, "-ndays n	 	 number of days before next update\n");
		BIO_printf(bio_err, "-resp_key_id       identify reponse by signing certificate key ID\n");
		BIO_printf(bio_err, "-nrequest n        number of requests to accept (default unlimited)\n");
		BIO_printf(bio_err, "-<dgst alg>     use specified digest in the request\n");
		goto end;
	}
	if (outfile)
		out = BIO_new_file(outfile, "w");
	else
		out = BIO_new_fp(stdout, BIO_NOCLOSE);

	if (!out) {
		BIO_printf(bio_err, "Error opening output file\n");
		goto end;
	}
	if (!req && (add_nonce != 2))
		add_nonce = 0;

	if (!req && reqin) {
		derbio = BIO_new_file(reqin, "rb");
		if (!derbio) {
			BIO_printf(bio_err, "Error Opening OCSP request file\n");
			goto end;
		}
		req = d2i_OCSP_REQUEST_bio(derbio, NULL);
		BIO_free(derbio);
		if (!req) {
			BIO_printf(bio_err, "Error reading OCSP request\n");
			goto end;
		}
	}
	if (!req && port) {
		acbio = init_responder(port);
		if (!acbio)
			goto end;
	}
	if (rsignfile && !rdb) {
		if (!rkeyfile)
			rkeyfile = rsignfile;
		rsigner = load_cert(bio_err, rsignfile, FORMAT_PEM,
		    NULL, e, "responder certificate");
		if (!rsigner) {
			BIO_printf(bio_err, "Error loading responder certificate\n");
			goto end;
		}
		rca_cert = load_cert(bio_err, rca_filename, FORMAT_PEM,
		    NULL, e, "CA certificate");
		if (rcertfile) {
			rother = load_certs(bio_err, rcertfile, FORMAT_PEM,
			    NULL, e, "responder other certificates");
			if (!rother)
				goto end;
		}
		rkey = load_key(bio_err, rkeyfile, FORMAT_PEM, 0, NULL, NULL,
		    "responder private key");
		if (!rkey)
			goto end;
	}
	if (acbio)
		BIO_printf(bio_err, "Waiting for OCSP client connections...\n");

redo_accept:

	if (acbio) {
		if (!do_responder(&req, &cbio, acbio, port))
			goto end;
		if (!req) {
			resp = OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST, NULL);
			send_ocsp_response(cbio, resp);
			goto done_resp;
		}
	}
	if (!req && (signfile || reqout || host || add_nonce || ridx_filename)) {
		BIO_printf(bio_err, "Need an OCSP request for this operation!\n");
		goto end;
	}
	if (req && add_nonce)
		OCSP_request_add1_nonce(req, NULL, -1);

	if (signfile) {
		if (!keyfile)
			keyfile = signfile;
		signer = load_cert(bio_err, signfile, FORMAT_PEM,
		    NULL, e, "signer certificate");
		if (!signer) {
			BIO_printf(bio_err, "Error loading signer certificate\n");
			goto end;
		}
		if (sign_certfile) {
			sign_other = load_certs(bio_err, sign_certfile, FORMAT_PEM,
			    NULL, e, "signer certificates");
			if (!sign_other)
				goto end;
		}
		key = load_key(bio_err, keyfile, FORMAT_PEM, 0, NULL, NULL,
		    "signer private key");
		if (!key)
			goto end;

		if (!OCSP_request_sign(req, signer, key, NULL, sign_other, sign_flags)) {
			BIO_printf(bio_err, "Error signing OCSP request\n");
			goto end;
		}
	}
	if (req_text && req)
		OCSP_REQUEST_print(out, req, 0);

	if (reqout) {
		derbio = BIO_new_file(reqout, "wb");
		if (!derbio) {
			BIO_printf(bio_err, "Error opening file %s\n", reqout);
			goto end;
		}
		i2d_OCSP_REQUEST_bio(derbio, req);
		BIO_free(derbio);
	}
	if (ridx_filename && (!rkey || !rsigner || !rca_cert)) {
		BIO_printf(bio_err, "Need a responder certificate, key and CA for this operation!\n");
		goto end;
	}
	if (ridx_filename && !rdb) {
		rdb = load_index(ridx_filename, NULL);
		if (!rdb)
			goto end;
		if (!index_index(rdb))
			goto end;
	}
	if (rdb) {
		i = make_ocsp_response(&resp, req, rdb, rca_cert, rsigner, rkey, rother, rflags, nmin, ndays);
		if (cbio)
			send_ocsp_response(cbio, resp);
	} else if (host) {
		resp = process_responder(bio_err, req, host, path,
		    port, use_ssl, headers, req_timeout);
		if (!resp)
			goto end;
	} else if (respin) {
		derbio = BIO_new_file(respin, "rb");
		if (!derbio) {
			BIO_printf(bio_err, "Error Opening OCSP response file\n");
			goto end;
		}
		resp = d2i_OCSP_RESPONSE_bio(derbio, NULL);
		BIO_free(derbio);
		if (!resp) {
			BIO_printf(bio_err, "Error reading OCSP response\n");
			goto end;
		}
	} else {
		ret = 0;
		goto end;
	}

done_resp:

	if (respout) {
		derbio = BIO_new_file(respout, "wb");
		if (!derbio) {
			BIO_printf(bio_err, "Error opening file %s\n", respout);
			goto end;
		}
		i2d_OCSP_RESPONSE_bio(derbio, resp);
		BIO_free(derbio);
	}
	i = OCSP_response_status(resp);

	if (i != OCSP_RESPONSE_STATUS_SUCCESSFUL) {
		BIO_printf(out, "Responder Error: %s (%d)\n",
		    OCSP_response_status_str(i), i);
		if (ignore_err)
			goto redo_accept;
		ret = 0;
		goto end;
	}
	if (resp_text)
		OCSP_RESPONSE_print(out, resp, 0);

	/* If running as responder don't verify our own response */
	if (cbio) {
		if (accept_count > 0)
			accept_count--;
		/* Redo if more connections needed */
		if (accept_count) {
			BIO_free_all(cbio);
			cbio = NULL;
			OCSP_REQUEST_free(req);
			req = NULL;
			OCSP_RESPONSE_free(resp);
			resp = NULL;
			goto redo_accept;
		}
		goto end;
	}
	if (!store)
		store = setup_verify(bio_err, CAfile, CApath);
	if (!store)
		goto end;
	if (verify_certfile) {
		verify_other = load_certs(bio_err, verify_certfile, FORMAT_PEM,
		    NULL, e, "validator certificate");
		if (!verify_other)
			goto end;
	}
	bs = OCSP_response_get1_basic(resp);

	if (!bs) {
		BIO_printf(bio_err, "Error parsing response\n");
		goto end;
	}
	if (!noverify) {
		if (req && ((i = OCSP_check_nonce(req, bs)) <= 0)) {
			if (i == -1)
				BIO_printf(bio_err, "WARNING: no nonce in response\n");
			else {
				BIO_printf(bio_err, "Nonce Verify error\n");
				goto end;
			}
		}
		i = OCSP_basic_verify(bs, verify_other, store, verify_flags);
		if (i < 0)
			i = OCSP_basic_verify(bs, NULL, store, 0);

		if (i <= 0) {
			BIO_printf(bio_err, "Response Verify Failure\n");
			ERR_print_errors(bio_err);
		} else
			BIO_printf(bio_err, "Response verify OK\n");

	}
	if (!print_ocsp_summary(out, bs, req, reqnames, ids, nsec, maxage))
		goto end;

	ret = 0;

end:
	ERR_print_errors(bio_err);
	X509_free(signer);
	X509_STORE_free(store);
	EVP_PKEY_free(key);
	EVP_PKEY_free(rkey);
	X509_free(issuer);
	X509_free(cert);
	X509_free(rsigner);
	X509_free(rca_cert);
	free_index(rdb);
	BIO_free_all(cbio);
	BIO_free_all(acbio);
	BIO_free(out);
	OCSP_REQUEST_free(req);
	OCSP_RESPONSE_free(resp);
	OCSP_BASICRESP_free(bs);
	sk_OPENSSL_STRING_free(reqnames);
	sk_OCSP_CERTID_free(ids);
	sk_X509_pop_free(sign_other, X509_free);
	sk_X509_pop_free(verify_other, X509_free);
	sk_CONF_VALUE_pop_free(headers, X509V3_conf_free);

	if (use_ssl != -1) {
		free(host);
		free(port);
		free(path);
	}
	return (ret);
}

static int
add_ocsp_cert(OCSP_REQUEST ** req, X509 * cert, const EVP_MD * cert_id_md, X509 * issuer,
    STACK_OF(OCSP_CERTID) * ids)
{
	OCSP_CERTID *id;
	if (!issuer) {
		BIO_printf(bio_err, "No issuer certificate specified\n");
		return 0;
	}
	if (!*req)
		*req = OCSP_REQUEST_new();
	if (!*req)
		goto err;
	id = OCSP_cert_to_id(cert_id_md, cert, issuer);
	if (!id || !sk_OCSP_CERTID_push(ids, id))
		goto err;
	if (!OCSP_request_add0_id(*req, id))
		goto err;
	return 1;

err:
	BIO_printf(bio_err, "Error Creating OCSP request\n");
	return 0;
}

static int
add_ocsp_serial(OCSP_REQUEST ** req, char *serial, const EVP_MD * cert_id_md, X509 * issuer,
    STACK_OF(OCSP_CERTID) * ids)
{
	OCSP_CERTID *id;
	X509_NAME *iname;
	ASN1_BIT_STRING *ikey;
	ASN1_INTEGER *sno;
	if (!issuer) {
		BIO_printf(bio_err, "No issuer certificate specified\n");
		return 0;
	}
	if (!*req)
		*req = OCSP_REQUEST_new();
	if (!*req)
		goto err;
	iname = X509_get_subject_name(issuer);
	ikey = X509_get0_pubkey_bitstr(issuer);
	sno = s2i_ASN1_INTEGER(NULL, serial);
	if (!sno) {
		BIO_printf(bio_err, "Error converting serial number %s\n", serial);
		return 0;
	}
	id = OCSP_cert_id_new(cert_id_md, iname, ikey, sno);
	ASN1_INTEGER_free(sno);
	if (!id || !sk_OCSP_CERTID_push(ids, id))
		goto err;
	if (!OCSP_request_add0_id(*req, id))
		goto err;
	return 1;

err:
	BIO_printf(bio_err, "Error Creating OCSP request\n");
	return 0;
}

static int
print_ocsp_summary(BIO * out, OCSP_BASICRESP * bs, OCSP_REQUEST * req,
    STACK_OF(OPENSSL_STRING) * names,
    STACK_OF(OCSP_CERTID) * ids, long nsec,
    long maxage)
{
	OCSP_CERTID *id;
	char *name;
	int i;

	int status, reason;

	ASN1_GENERALIZEDTIME *rev, *thisupd, *nextupd;

	if (!bs || !req || !sk_OPENSSL_STRING_num(names) || !sk_OCSP_CERTID_num(ids))
		return 1;

	for (i = 0; i < sk_OCSP_CERTID_num(ids); i++) {
		id = sk_OCSP_CERTID_value(ids, i);
		name = sk_OPENSSL_STRING_value(names, i);
		BIO_printf(out, "%s: ", name);

		if (!OCSP_resp_find_status(bs, id, &status, &reason,
			&rev, &thisupd, &nextupd)) {
			BIO_puts(out, "ERROR: No Status found.\n");
			continue;
		}
		/*
		 * Check validity: if invalid write to output BIO so we know
		 * which response this refers to.
		 */
		if (!OCSP_check_validity(thisupd, nextupd, nsec, maxage)) {
			BIO_puts(out, "WARNING: Status times invalid.\n");
			ERR_print_errors(out);
		}
		BIO_printf(out, "%s\n", OCSP_cert_status_str(status));

		BIO_puts(out, "\tThis Update: ");
		ASN1_GENERALIZEDTIME_print(out, thisupd);
		BIO_puts(out, "\n");

		if (nextupd) {
			BIO_puts(out, "\tNext Update: ");
			ASN1_GENERALIZEDTIME_print(out, nextupd);
			BIO_puts(out, "\n");
		}
		if (status != V_OCSP_CERTSTATUS_REVOKED)
			continue;

		if (reason != -1)
			BIO_printf(out, "\tReason: %s\n",
			    OCSP_crl_reason_str(reason));

		BIO_puts(out, "\tRevocation Time: ");
		ASN1_GENERALIZEDTIME_print(out, rev);
		BIO_puts(out, "\n");
	}

	return 1;
}


static int
make_ocsp_response(OCSP_RESPONSE ** resp, OCSP_REQUEST * req, CA_DB * db,
    X509 * ca, X509 * rcert, EVP_PKEY * rkey,
    STACK_OF(X509) * rother, unsigned long flags,
    int nmin, int ndays)
{
	ASN1_TIME *thisupd = NULL, *nextupd = NULL;
	OCSP_CERTID *cid, *ca_id = NULL;
	OCSP_BASICRESP *bs = NULL;
	int i, id_count, ret = 1;

	id_count = OCSP_request_onereq_count(req);

	if (id_count <= 0) {
		*resp = OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST, NULL);
		goto end;
	}
	bs = OCSP_BASICRESP_new();
	thisupd = X509_gmtime_adj(NULL, 0);
	if (ndays != -1)
		nextupd = X509_gmtime_adj(NULL, nmin * 60 + ndays * 3600 * 24);

	/* Examine each certificate id in the request */
	for (i = 0; i < id_count; i++) {
		OCSP_ONEREQ *one;
		ASN1_INTEGER *serial;
		char **inf;
		ASN1_OBJECT *cert_id_md_oid;
		const EVP_MD *cert_id_md;
		one = OCSP_request_onereq_get0(req, i);
		cid = OCSP_onereq_get0_id(one);

		OCSP_id_get0_info(NULL, &cert_id_md_oid, NULL, NULL, cid);

		cert_id_md = EVP_get_digestbyobj(cert_id_md_oid);
		if (!cert_id_md) {
			*resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,
			    NULL);
			goto end;
		}
		if (ca_id)
			OCSP_CERTID_free(ca_id);
		ca_id = OCSP_cert_to_id(cert_id_md, NULL, ca);

		/* Is this request about our CA? */
		if (OCSP_id_issuer_cmp(ca_id, cid)) {
			OCSP_basic_add1_status(bs, cid,
			    V_OCSP_CERTSTATUS_UNKNOWN,
			    0, NULL,
			    thisupd, nextupd);
			continue;
		}
		OCSP_id_get0_info(NULL, NULL, NULL, &serial, cid);
		inf = lookup_serial(db, serial);
		if (!inf)
			OCSP_basic_add1_status(bs, cid,
			    V_OCSP_CERTSTATUS_UNKNOWN,
			    0, NULL,
			    thisupd, nextupd);
		else if (inf[DB_type][0] == DB_TYPE_VAL)
			OCSP_basic_add1_status(bs, cid,
			    V_OCSP_CERTSTATUS_GOOD,
			    0, NULL,
			    thisupd, nextupd);
		else if (inf[DB_type][0] == DB_TYPE_REV) {
			ASN1_OBJECT *inst = NULL;
			ASN1_TIME *revtm = NULL;
			ASN1_GENERALIZEDTIME *invtm = NULL;
			OCSP_SINGLERESP *single;
			int reason = -1;
			unpack_revinfo(&revtm, &reason, &inst, &invtm, inf[DB_rev_date]);
			single = OCSP_basic_add1_status(bs, cid,
			    V_OCSP_CERTSTATUS_REVOKED,
			    reason, revtm,
			    thisupd, nextupd);
			if (invtm)
				OCSP_SINGLERESP_add1_ext_i2d(single, NID_invalidity_date, invtm, 0, 0);
			else if (inst)
				OCSP_SINGLERESP_add1_ext_i2d(single, NID_hold_instruction_code, inst, 0, 0);
			ASN1_OBJECT_free(inst);
			ASN1_TIME_free(revtm);
			ASN1_GENERALIZEDTIME_free(invtm);
		}
	}

	OCSP_copy_nonce(bs, req);

	OCSP_basic_sign(bs, rcert, rkey, NULL, rother, flags);

	*resp = OCSP_response_create(OCSP_RESPONSE_STATUS_SUCCESSFUL, bs);

end:
	ASN1_TIME_free(thisupd);
	ASN1_TIME_free(nextupd);
	OCSP_CERTID_free(ca_id);
	OCSP_BASICRESP_free(bs);
	return ret;

}

static char **
lookup_serial(CA_DB * db, ASN1_INTEGER * ser)
{
	int i;
	BIGNUM *bn = NULL;
	char *itmp, *row[DB_NUMBER], **rrow;
	for (i = 0; i < DB_NUMBER; i++)
		row[i] = NULL;
	bn = ASN1_INTEGER_to_BN(ser, NULL);
	OPENSSL_assert(bn);	/* FIXME: should report an error at this
				 * point and abort */
	if (BN_is_zero(bn))
		itmp = strdup("00");
	else
		itmp = BN_bn2hex(bn);
	row[DB_serial] = itmp;
	BN_free(bn);
	rrow = TXT_DB_get_by_index(db->db, DB_serial, row);
	free(itmp);
	return rrow;
}

/* Quick and dirty OCSP server: read in and parse input request */

static BIO *
init_responder(char *port)
{
	BIO *acbio = NULL, *bufbio = NULL;
	bufbio = BIO_new(BIO_f_buffer());
	if (!bufbio)
		goto err;
	acbio = BIO_new_accept(port);
	if (!acbio)
		goto err;
	BIO_set_accept_bios(acbio, bufbio);
	bufbio = NULL;

	if (BIO_do_accept(acbio) <= 0) {
		BIO_printf(bio_err, "Error setting up accept BIO\n");
		ERR_print_errors(bio_err);
		goto err;
	}
	return acbio;

err:
	BIO_free_all(acbio);
	BIO_free(bufbio);
	return NULL;
}

static int
do_responder(OCSP_REQUEST ** preq, BIO ** pcbio, BIO * acbio, char *port)
{
	int have_post = 0, len;
	OCSP_REQUEST *req = NULL;
	char inbuf[1024];
	BIO *cbio = NULL;

	if (BIO_do_accept(acbio) <= 0) {
		BIO_printf(bio_err, "Error accepting connection\n");
		ERR_print_errors(bio_err);
		return 0;
	}
	cbio = BIO_pop(acbio);
	*pcbio = cbio;

	for (;;) {
		len = BIO_gets(cbio, inbuf, sizeof inbuf);
		if (len <= 0)
			return 1;
		/* Look for "POST" signalling start of query */
		if (!have_post) {
			if (strncmp(inbuf, "POST", 4)) {
				BIO_printf(bio_err, "Invalid request\n");
				return 1;
			}
			have_post = 1;
		}
		/* Look for end of headers */
		if ((inbuf[0] == '\r') || (inbuf[0] == '\n'))
			break;
	}

	/* Try to read OCSP request */

	req = d2i_OCSP_REQUEST_bio(cbio, NULL);

	if (!req) {
		BIO_printf(bio_err, "Error parsing OCSP request\n");
		ERR_print_errors(bio_err);
	}
	*preq = req;

	return 1;

}

static int
send_ocsp_response(BIO * cbio, OCSP_RESPONSE * resp)
{
	static const char http_resp[] =
	"HTTP/1.0 200 OK\r\nContent-type: application/ocsp-response\r\n"
	"Content-Length: %d\r\n\r\n";
	if (!cbio)
		return 0;
	BIO_printf(cbio, http_resp, i2d_OCSP_RESPONSE(resp, NULL));
	i2d_OCSP_RESPONSE_bio(cbio, resp);
	(void) BIO_flush(cbio);
	return 1;
}

static OCSP_RESPONSE *
query_responder(BIO * err, BIO * cbio, char *path,
    STACK_OF(CONF_VALUE) * headers,
    OCSP_REQUEST * req, int req_timeout)
{
	int fd;
	int rv;
	int i;
	OCSP_REQ_CTX *ctx = NULL;
	OCSP_RESPONSE *rsp = NULL;
	fd_set confds;
	struct timeval tv;

	if (req_timeout != -1)
		BIO_set_nbio(cbio, 1);

	rv = BIO_do_connect(cbio);

	if ((rv <= 0) && ((req_timeout == -1) || !BIO_should_retry(cbio))) {
		BIO_puts(err, "Error connecting BIO\n");
		return NULL;
	}
	if (BIO_get_fd(cbio, &fd) <= 0) {
		BIO_puts(err, "Can't get connection fd\n");
		goto err;
	}
	if (req_timeout != -1 && rv <= 0) {
		FD_ZERO(&confds);
		FD_SET(fd, &confds);
		tv.tv_usec = 0;
		tv.tv_sec = req_timeout;
		rv = select(fd + 1, NULL, &confds, NULL, &tv);
		if (rv == 0) {
			BIO_puts(err, "Timeout on connect\n");
			return NULL;
		}
	}
	ctx = OCSP_sendreq_new(cbio, path, NULL, -1);
	if (!ctx)
		return NULL;

	for (i = 0; i < sk_CONF_VALUE_num(headers); i++) {
		CONF_VALUE *hdr = sk_CONF_VALUE_value(headers, i);
		if (!OCSP_REQ_CTX_add1_header(ctx, hdr->name, hdr->value))
			goto err;
	}

	if (!OCSP_REQ_CTX_set1_req(ctx, req))
		goto err;

	for (;;) {
		rv = OCSP_sendreq_nbio(&rsp, ctx);
		if (rv != -1)
			break;
		if (req_timeout == -1)
			continue;
		FD_ZERO(&confds);
		FD_SET(fd, &confds);
		tv.tv_usec = 0;
		tv.tv_sec = req_timeout;
		if (BIO_should_read(cbio))
			rv = select(fd + 1, &confds, NULL, NULL, &tv);
		else if (BIO_should_write(cbio))
			rv = select(fd + 1, NULL, &confds, NULL, &tv);
		else {
			BIO_puts(err, "Unexpected retry condition\n");
			goto err;
		}
		if (rv == 0) {
			BIO_puts(err, "Timeout on request\n");
			break;
		}
		if (rv == -1) {
			BIO_puts(err, "Select error\n");
			break;
		}
	}
err:
	if (ctx)
		OCSP_REQ_CTX_free(ctx);

	return rsp;
}

OCSP_RESPONSE *
process_responder(BIO * err, OCSP_REQUEST * req,
    char *host, char *path, char *port, int use_ssl,
    STACK_OF(CONF_VALUE) * headers,
    int req_timeout)
{
	BIO *cbio = NULL;
	SSL_CTX *ctx = NULL;
	OCSP_RESPONSE *resp = NULL;
	cbio = BIO_new_connect(host);
	if (!cbio) {
		BIO_printf(err, "Error creating connect BIO\n");
		goto end;
	}
	if (port)
		BIO_set_conn_port(cbio, port);
	if (use_ssl == 1) {
		BIO *sbio;
		ctx = SSL_CTX_new(SSLv23_client_method());
		if (ctx == NULL) {
			BIO_printf(err, "Error creating SSL context.\n");
			goto end;
		}
		SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);
		sbio = BIO_new_ssl(ctx, 1);
		cbio = BIO_push(sbio, cbio);
	}
	resp = query_responder(err, cbio, path, headers, req, req_timeout);
	if (!resp)
		BIO_printf(bio_err, "Error querying OCSP responder\n");
end:
	if (cbio)
		BIO_free_all(cbio);
	if (ctx)
		SSL_CTX_free(ctx);
	return resp;
}

#endif
@


1.31
log
@Include <sys/select.h> to get select

These files currently depends on the wrapper <stdlib.h> file indirectly
including a header that provides select().

from Jonas 'Sortie' Termansen

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp.c,v 1.30 2014/07/13 16:03:09 beck Exp $ */
@


1.30
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp.c,v 1.29 2014/07/12 19:31:21 jsing Exp $ */
d59 2
@


1.29
log
@In openssl_startup(), call SSL_library_init() and SSL_load_error_strings().
This allows us to remove the ERR_load_crypto_strings() call, along with
the various SSL_load_error_strings() and OpenSSL_add_ssl_algorithms()
calls scattered around the place.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp.c,v 1.28 2014/07/12 17:54:31 jsing Exp $ */
d994 1
a994 1
		itmp = BUF_strdup("00");
@


1.28
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp.c,v 1.27 2014/06/28 04:39:41 deraadt Exp $ */
a148 3

	SSL_load_error_strings();
	OpenSSL_add_ssl_algorithms();
@


1.27
log
@Use strtonum() instead of atoi(), and then impose what are we think
are the current range checks.  Help from millert and lteo.  Please test
now that it is deployed and let us know if any numbers are off..
ok lteo
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp.c,v 1.26 2014/06/12 15:49:27 deraadt Exp $ */
a148 3

	if (!load_config(bio_err, NULL))
		goto end;
@


1.26
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d62 1
d148 1
d169 3
a171 2
				req_timeout = atol(*args);
				if (req_timeout < 0) {
d173 2
a174 2
					    "Illegal timeout value %s\n",
					    *args);
d294 2
a295 2
				nsec = atol(*args);
				if (nsec < 0) {
d297 2
a298 2
					    "Illegal validity period %s\n",
					    *args);
d306 2
a307 2
				maxage = atol(*args);
				if (maxage < 0) {
d309 2
a310 2
					    "Illegal validity age %s\n",
					    *args);
d391 2
a392 2
				nmin = atol(*args);
				if (nmin < 0) {
d394 2
a395 2
					    "Illegal update period %s\n",
					    *args);
d406 2
a407 2
				accept_count = atol(*args);
				if (accept_count < 0) {
d409 2
a410 2
					    "Illegal accept count %s\n",
					    *args);
d418 2
a419 2
				ndays = atol(*args);
				if (ndays < 0) {
d421 2
a422 2
					    "Illegal update period %s\n",
					    *args);
@


1.25
log
@There is no need to include <openssl/e_os2.h> here, except for the fact
that it brings in <openssl/opensslconf.h>, so just do that instead
(currently via apps.h).
@
text
@d1 1
a1 1
/* ocsp.c */
@


1.24
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@a69 1
#include <openssl/e_os2.h>
@


1.23
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d64 6
a69 2
#include "apps.h"		/* needs to be included before the openssl
				 * headers! */
a70 1
#include <openssl/crypto.h>
d72 1
a73 2
#include <openssl/evp.h>
#include <openssl/bn.h>
@


1.22
log
@Nuke OPENSSL_NO_SOCK since any half sane operating system has sockets.

ok beck@@
@
text
@a139 1

a146 3
	if (bio_err == NULL)
		bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);

d149 1
d152 1
@


1.21
log
@remove the openssl_fdset wrapper, and a variety of VMS'ism's like
crazy (void *) casts all over the place
ok beck jsing
@
text
@a629 1
#ifndef OPENSSL_NO_SOCK
a633 4
#else
		BIO_printf(bio_err, "Error creating connect BIO - sockets not supported.\n");
		goto end;
#endif
a1016 1
#ifndef OPENSSL_NO_SOCK
a1017 3
#else
	BIO_printf(bio_err, "Error setting up accept BIO - sockets not supported.\n");
#endif
@


1.20
log
@whitespace normalization
@
text
@d1134 1
a1134 1
		openssl_fdset(fd, &confds);
d1137 1
a1137 1
		rv = select(fd + 1, NULL, (void *) &confds, NULL, &tv);
d1163 1
a1163 1
		openssl_fdset(fd, &confds);
d1167 1
a1167 1
			rv = select(fd + 1, (void *) &confds, NULL, NULL, &tv);
d1169 1
a1169 1
			rv = select(fd + 1, NULL, (void *) &confds, NULL, &tv);
@


1.19
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d80 3
a82 3
	static int add_ocsp_serial(OCSP_REQUEST ** req, char *serial, const EVP_MD * cert_id_md, X509 * issuer,
     STACK_OF(OCSP_CERTID) * ids);
	static int print_ocsp_summary(BIO * out, OCSP_BASICRESP * bs, OCSP_REQUEST * req,
d87 2
a88 2
	static int make_ocsp_response(OCSP_RESPONSE ** resp, OCSP_REQUEST * req, CA_DB * db,
     X509 * ca, X509 * rcert, EVP_PKEY * rkey,
d92 5
a96 5
	static char **lookup_serial(CA_DB * db, ASN1_INTEGER * ser);
	static BIO *init_responder(char *port);
	static int do_responder(OCSP_REQUEST ** preq, BIO ** pcbio, BIO * acbio, char *port);
	static int send_ocsp_response(BIO * cbio, OCSP_RESPONSE * resp);
	static OCSP_RESPONSE *query_responder(BIO * err, BIO * cbio, char *path,
d101 1
a101 1
	int ocsp_main(int, char **);
d103 2
a104 1
	int ocsp_main(int argc, char **argv)
@


1.18
log
@undef NETWARE_CLIB and NETWARE_LIBC
@
text
@a99 2
#undef PROG
#define PROG ocsp_main
d101 1
a101 1
	int MAIN(int, char **);
d103 1
a103 1
	int MAIN(int argc, char **argv)
@


1.17
log
@KaboomNF
@
text
@a73 15
#if defined(NETWARE_CLIB)
#ifdef NETWARE_BSDSOCK
#include <sys/socket.h>
#include <sys/bsdskt.h>
#else
#include <novsock2.h>
#endif
#elif defined(NETWARE_LIBC)
#ifdef NETWARE_BSDSOCK
#include <sys/select.h>
#else
#include <novsock2.h>
#endif
#endif

@


1.16
log
@spelling fix from Micha Borrmann on openssl-dev
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d64 2
a65 1
#include "apps.h" /* needs to be included before the openssl headers! */
d75 6
a80 6
#  ifdef NETWARE_BSDSOCK
#    include <sys/socket.h>
#    include <sys/bsdskt.h>
#  else
#    include <novsock2.h>
#  endif
d82 4
a85 5
#  ifdef NETWARE_BSDSOCK
#    include <sys/select.h>
#  else
#    include <novsock2.h>
#  endif
d87 2
a88 1
  
d92 22
a113 21
static int add_ocsp_cert(OCSP_REQUEST **req, X509 *cert, const EVP_MD *cert_id_md, X509 *issuer,
				STACK_OF(OCSP_CERTID) *ids);
static int add_ocsp_serial(OCSP_REQUEST **req, char *serial, const EVP_MD * cert_id_md, X509 *issuer,
				STACK_OF(OCSP_CERTID) *ids);
static int print_ocsp_summary(BIO *out, OCSP_BASICRESP *bs, OCSP_REQUEST *req,
			      STACK_OF(OPENSSL_STRING) *names,
			      STACK_OF(OCSP_CERTID) *ids, long nsec,
			      long maxage);

static int make_ocsp_response(OCSP_RESPONSE **resp, OCSP_REQUEST *req, CA_DB *db,
			X509 *ca, X509 *rcert, EVP_PKEY *rkey,
			STACK_OF(X509) *rother, unsigned long flags,
			int nmin, int ndays);

static char **lookup_serial(CA_DB *db, ASN1_INTEGER *ser);
static BIO *init_responder(char *port);
static int do_responder(OCSP_REQUEST **preq, BIO **pcbio, BIO *acbio, char *port);
static int send_ocsp_response(BIO *cbio, OCSP_RESPONSE *resp);
static OCSP_RESPONSE *query_responder(BIO *err, BIO *cbio, char *path,
				STACK_OF(CONF_VALUE) *headers,
				OCSP_REQUEST *req, int req_timeout);
d118 1
a118 1
int MAIN(int, char **);
d120 2
a121 2
int MAIN(int argc, char **argv)
	{
d131 1
a131 1
	STACK_OF(CONF_VALUE) *headers = NULL;
d146 1
a146 1
	STACK_OF(X509) *sign_other = NULL, *verify_other = NULL, *rother = NULL;
d154 2
a155 2
	STACK_OF(OPENSSL_STRING) *reqnames = NULL;
	STACK_OF(OCSP_CERTID) *ids = NULL;
d164 2
a165 1
	if (bio_err == NULL) bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
d174 3
a176 6
	while (!badarg && *args && *args[0] == '-')
		{
		if (!strcmp(*args, "-out"))
			{
			if (args[1])
				{
d179 4
a182 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-timeout"))
			{
			if (args[1])
				{
d185 1
a185 2
				if (req_timeout < 0)
					{
d187 2
a188 2
						"Illegal timeout value %s\n",
						*args);
a189 1
					}
d191 4
a194 6
			else badarg = 1;
			}
		else if (!strcmp(*args, "-url"))
			{
			if (args[1])
				{
d196 1
a196 2
				if (!OCSP_parse_url(*args, &host, &port, &path, &use_ssl))
					{
a198 1
					}
d200 4
a203 6
			else badarg = 1;
			}
		else if (!strcmp(*args, "-host"))
			{
			if (args[1])
				{
d206 4
a209 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-port"))
			{
			if (args[1])
				{
d212 4
a215 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-header"))
			{
			if (args[1] && args[2])
				{
d219 3
a221 4
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-ignore_err"))
d249 1
a249 2
		else if (!strcmp(*args, "-text"))
			{
d252 1
a252 2
			}
		else if (!strcmp(*args, "-req_text"))
d256 2
a257 4
		else if (!strcmp(*args, "-reqin"))
			{
			if (args[1])
				{
d260 4
a263 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-respin"))
			{
			if (args[1])
				{
d266 4
a269 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-signer"))
			{
			if (args[1])
				{
d272 4
a275 7
				}
			else badarg = 1;
			}
		else if (!strcmp (*args, "-VAfile"))
			{
			if (args[1])
				{
d279 4
a282 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-sign_other"))
			{
			if (args[1])
				{
d285 4
a288 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-verify_other"))
			{
			if (args[1])
				{
d291 4
a294 7
				}
			else badarg = 1;
			}
		else if (!strcmp (*args, "-CAfile"))
			{
			if (args[1])
				{
d297 4
a300 7
				}
			else badarg = 1;
			}
		else if (!strcmp (*args, "-CApath"))
			{
			if (args[1])
				{
d303 4
a306 7
				}
			else badarg = 1;
			}
		else if (!strcmp (*args, "-validity_period"))
			{
			if (args[1])
				{
d309 1
a309 2
				if (nsec < 0)
					{
d311 2
a312 2
						"Illegal validity period %s\n",
						*args);
a313 1
					}
d315 4
a318 6
			else badarg = 1;
			}
		else if (!strcmp (*args, "-status_age"))
			{
			if (args[1])
				{
d321 1
a321 2
				if (maxage < 0)
					{
d323 2
a324 2
						"Illegal validity age %s\n",
						*args);
a325 1
					}
d327 4
a330 6
			else badarg = 1;
			}
		 else if (!strcmp(*args, "-signkey"))
			{
			if (args[1])
				{
d333 4
a336 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-reqout"))
			{
			if (args[1])
				{
d339 4
a342 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-respout"))
			{
			if (args[1])
				{
d345 4
a348 7
				}
			else badarg = 1;
			}
		 else if (!strcmp(*args, "-path"))
			{
			if (args[1])
				{
d351 4
a354 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-issuer"))
			{
			if (args[1])
				{
d358 7
a364 9
					NULL, e, "issuer certificate");
				if(!issuer) goto end;
				}
			else badarg = 1;
			}
		else if (!strcmp (*args, "-cert"))
			{
			if (args[1])
				{
d368 6
a373 4
					NULL, e, "certificate");
				if(!cert) goto end;
				if (!cert_id_md) cert_id_md = EVP_sha1();
				if(!add_ocsp_cert(&req, cert, cert_id_md, issuer, ids))
d375 1
a375 1
				if(!sk_OPENSSL_STRING_push(reqnames, *args))
d377 8
a384 10
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-serial"))
			{
			if (args[1])
				{
				args++;
				if (!cert_id_md) cert_id_md = EVP_sha1();
				if(!add_ocsp_serial(&req, *args, cert_id_md, issuer, ids))
d386 1
a386 1
				if(!sk_OPENSSL_STRING_push(reqnames, *args))
d388 4
a391 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-index"))
			{
			if (args[1])
				{
d394 4
a397 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-CA"))
			{
			if (args[1])
				{
d400 4
a403 7
				}
			else badarg = 1;
			}
		else if (!strcmp (*args, "-nmin"))
			{
			if (args[1])
				{
d406 1
a406 2
				if (nmin < 0)
					{
d408 2
a409 2
						"Illegal update period %s\n",
						*args);
a410 1
					}
a411 3
				if (ndays == -1)
					ndays = 0;
			else badarg = 1;
d413 6
a418 4
		else if (!strcmp (*args, "-nrequest"))
			{
			if (args[1])
				{
d421 1
a421 2
				if (accept_count < 0)
					{
d423 2
a424 2
						"Illegal accept count %s\n",
						*args);
a425 1
					}
d427 4
a430 6
			else badarg = 1;
			}
		else if (!strcmp (*args, "-ndays"))
			{
			if (args[1])
				{
d433 1
a433 2
				if (ndays < 0)
					{
d435 2
a436 2
						"Illegal update period %s\n",
						*args);
a437 1
					}
d439 4
a442 6
			else badarg = 1;
			}
		else if (!strcmp(*args, "-rsigner"))
			{
			if (args[1])
				{
d445 4
a448 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-rkey"))
			{
			if (args[1])
				{
d451 4
a454 7
				}
			else badarg = 1;
			}
		else if (!strcmp(*args, "-rother"))
			{
			if (args[1])
				{
d457 3
a459 5
				}
			else badarg = 1;
			}
		else if ((cert_id_md = EVP_get_digestbyname((*args)+1))==NULL)
			{
d461 1
a461 1
			}
d463 1
a463 1
		}
d466 2
a467 1
	if (!req && !reqin && !respin && !(port && ridx_filename)) badarg = 1;
d469 49
a517 50
	if (badarg)
		{
		BIO_printf (bio_err, "OCSP utility\n");
		BIO_printf (bio_err, "Usage ocsp [options]\n");
		BIO_printf (bio_err, "where options are\n");
		BIO_printf (bio_err, "-out file          output filename\n");
		BIO_printf (bio_err, "-issuer file       issuer certificate\n");
		BIO_printf (bio_err, "-cert file         certificate to check\n");
		BIO_printf (bio_err, "-serial n          serial number to check\n");
		BIO_printf (bio_err, "-signer file       certificate to sign OCSP request with\n");
		BIO_printf (bio_err, "-signkey file      private key to sign OCSP request with\n");
		BIO_printf (bio_err, "-sign_other file   additional certificates to include in signed request\n");
		BIO_printf (bio_err, "-no_certs          don't include any certificates in signed request\n");
		BIO_printf (bio_err, "-req_text          print text form of request\n");
		BIO_printf (bio_err, "-resp_text         print text form of response\n");
		BIO_printf (bio_err, "-text              print text form of request and response\n");
		BIO_printf (bio_err, "-reqout file       write DER encoded OCSP request to \"file\"\n");
		BIO_printf (bio_err, "-respout file      write DER encoded OCSP reponse to \"file\"\n");
		BIO_printf (bio_err, "-reqin file        read DER encoded OCSP request from \"file\"\n");
		BIO_printf (bio_err, "-respin file       read DER encoded OCSP reponse from \"file\"\n");
		BIO_printf (bio_err, "-nonce             add OCSP nonce to request\n");
		BIO_printf (bio_err, "-no_nonce          don't add OCSP nonce to request\n");
		BIO_printf (bio_err, "-url URL           OCSP responder URL\n");
		BIO_printf (bio_err, "-host host:n       send OCSP request to host on port n\n");
		BIO_printf (bio_err, "-path              path to use in OCSP request\n");
		BIO_printf (bio_err, "-CApath dir        trusted certificates directory\n");
		BIO_printf (bio_err, "-CAfile file       trusted certificates file\n");
		BIO_printf (bio_err, "-VAfile file       validator certificates file\n");
		BIO_printf (bio_err, "-validity_period n maximum validity discrepancy in seconds\n");
		BIO_printf (bio_err, "-status_age n      maximum status age in seconds\n");
		BIO_printf (bio_err, "-noverify          don't verify response at all\n");
		BIO_printf (bio_err, "-verify_other file additional certificates to search for signer\n");
		BIO_printf (bio_err, "-trust_other       don't verify additional certificates\n");
		BIO_printf (bio_err, "-no_intern         don't search certificates contained in response for signer\n");
		BIO_printf (bio_err, "-no_signature_verify don't check signature on response\n");
		BIO_printf (bio_err, "-no_cert_verify    don't check signing certificate\n");
		BIO_printf (bio_err, "-no_chain          don't chain verify response\n");
		BIO_printf (bio_err, "-no_cert_checks    don't do additional checks on signing certificate\n");
		BIO_printf (bio_err, "-port num		 port to run responder on\n");
		BIO_printf (bio_err, "-index file	 certificate status index file\n");
		BIO_printf (bio_err, "-CA file		 CA certificate\n");
		BIO_printf (bio_err, "-rsigner file	 responder certificate to sign responses with\n");
		BIO_printf (bio_err, "-rkey file	 responder key to sign responses with\n");
		BIO_printf (bio_err, "-rother file	 other certificates to include in response\n");
		BIO_printf (bio_err, "-resp_no_certs     don't include any certificates in response\n");
		BIO_printf (bio_err, "-nmin n	 	 number of minutes before next update\n");
		BIO_printf (bio_err, "-ndays n	 	 number of days before next update\n");
		BIO_printf (bio_err, "-resp_key_id       identify reponse by signing certificate key ID\n");
		BIO_printf (bio_err, "-nrequest n        number of requests to accept (default unlimited)\n");
		BIO_printf (bio_err, "-<dgst alg>     use specified digest in the request\n");
d519 5
a523 1
		}
d525 1
a525 5
	if(outfile) out = BIO_new_file(outfile, "w");
	else out = BIO_new_fp(stdout, BIO_NOCLOSE);

	if(!out)
		{
d528 3
a530 3
		}

	if (!req && (add_nonce != 2)) add_nonce = 0;
d532 1
a532 2
	if (!req && reqin)
		{
d534 1
a534 2
		if (!derbio)
			{
d537 1
a537 1
			}
d540 1
a540 2
		if(!req)
			{
a542 1
			}
d544 2
a545 3

	if (!req && port)
		{
d549 4
a552 5
		}

	if (rsignfile && !rdb)
		{
		if (!rkeyfile) rkeyfile = rsignfile;
d554 2
a555 3
			NULL, e, "responder certificate");
		if (!rsigner)
			{
d558 1
a558 1
			}
d560 2
a561 3
			NULL, e, "CA certificate");
		if (rcertfile)
			{
d563 4
a566 3
				NULL, e, "responder other certificates");
			if (!rother) goto end;
			}
d568 1
a568 1
			"responder private key");
d571 2
a572 2
		}
	if(acbio)
d575 1
a575 1
	redo_accept:
d577 1
a577 2
	if (acbio)
		{
d580 1
a580 2
		if (!req)
			{
a583 1
			}
d585 2
a586 3

	if (!req && (signfile || reqout || host || add_nonce || ridx_filename))
		{
d589 3
a591 1
		}
d593 3
a595 5
	if (req && add_nonce) OCSP_request_add1_nonce(req, NULL, -1);

	if (signfile)
		{
		if (!keyfile) keyfile = signfile;
d597 2
a598 3
			NULL, e, "signer certificate");
		if (!signer)
			{
d601 2
a602 3
			}
		if (sign_certfile)
			{
d604 4
a607 3
				NULL, e, "signer certificates");
			if (!sign_other) goto end;
			}
d609 1
a609 1
			"signer private key");
d613 1
a613 2
		if (!OCSP_request_sign(req, signer, key, NULL, sign_other, sign_flags))
			{
a615 1
			}
d617 3
d621 1
a621 4
	if (req_text && req) OCSP_REQUEST_print(out, req, 0);

	if (reqout)
		{
d623 1
a623 2
		if(!derbio)
			{
d626 1
a626 1
			}
d629 2
a630 4
		}

	if (ridx_filename && (!rkey || !rsigner || !rca_cert))
		{
d633 2
a634 4
		}

	if (ridx_filename && !rdb)
		{
d636 6
a641 6
		if (!rdb) goto end;
		if (!index_index(rdb)) goto end;
		}

	if (rdb)
		{
d645 1
a645 3
		}
	else if (host)
		{
d648 1
a648 1
					port, use_ssl, headers, req_timeout);
d655 1
a655 3
		}
	else if (respin)
		{
d657 1
a657 2
		if (!derbio)
			{
d660 1
a660 1
			}
d663 1
a663 2
		if(!resp)
			{
a665 2
			}
	
d667 1
a667 2
	else
		{
d670 1
a670 1
		}
d672 1
a672 1
	done_resp:
d674 1
a674 2
	if (respout)
		{
d676 1
a676 2
		if(!derbio)
			{
d679 1
a679 1
			}
d682 1
a682 2
		}

d685 1
a685 2
	if (i != OCSP_RESPONSE_STATUS_SUCCESSFUL)
		{
d687 1
a687 1
				OCSP_response_status_str(i), i);
d692 3
a694 3
		}

	if (resp_text) OCSP_RESPONSE_print(out, resp, 0);
d697 1
a697 2
	if (cbio)
		{
d701 1
a701 2
		if (accept_count)
			{
d709 1
a709 1
			}
d711 1
a711 2
		}

d716 1
a716 2
	if (verify_certfile)
		{
d718 4
a721 4
			NULL, e, "validator certificate");
		if (!verify_other) goto end;
		}

d724 1
a724 2
	if (!bs)
		{
d727 3
a729 6
		}

	if (!noverify)
		{
		if (req && ((i = OCSP_check_nonce(req, bs)) <= 0))
			{
d732 1
a732 2
			else
				{
a734 1
				}
d736 1
a736 1

d738 2
a739 1
                if (i < 0) i = OCSP_basic_verify(bs, NULL, store, 0);
d741 1
a741 2
		if(i <= 0)
			{
d744 1
a744 2
			}
		else
d747 1
a747 2
		}

d776 1
a776 2
	if (use_ssl != -1)
		{
d780 2
a781 3
		}

	return(ret);
d784 4
a787 3
static int add_ocsp_cert(OCSP_REQUEST **req, X509 *cert, const EVP_MD *cert_id_md,X509 *issuer,
				STACK_OF(OCSP_CERTID) *ids)
	{
d789 1
a789 2
	if(!issuer)
		{
d792 5
a796 3
		}
	if(!*req) *req = OCSP_REQUEST_new();
	if(!*req) goto err;
d798 4
a801 2
	if(!id || !sk_OCSP_CERTID_push(ids, id)) goto err;
	if(!OCSP_request_add0_id(*req, id)) goto err;
d804 1
a804 1
	err:
d807 1
a807 1
	}
d809 4
a812 3
static int add_ocsp_serial(OCSP_REQUEST **req, char *serial,const EVP_MD *cert_id_md, X509 *issuer,
				STACK_OF(OCSP_CERTID) *ids)
	{
d817 1
a817 2
	if(!issuer)
		{
d820 5
a824 3
		}
	if(!*req) *req = OCSP_REQUEST_new();
	if(!*req) goto err;
d828 1
a828 2
	if(!sno)
		{
d831 1
a831 1
		}
d834 4
a837 2
	if(!id || !sk_OCSP_CERTID_push(ids, id)) goto err;
	if(!OCSP_request_add0_id(*req, id)) goto err;
d840 1
a840 1
	err:
d843 1
a843 1
	}
d845 6
a850 5
static int print_ocsp_summary(BIO *out, OCSP_BASICRESP *bs, OCSP_REQUEST *req,
			      STACK_OF(OPENSSL_STRING) *names,
			      STACK_OF(OCSP_CERTID) *ids, long nsec,
			      long maxage)
	{
d862 1
a862 2
	for (i = 0; i < sk_OCSP_CERTID_num(ids); i++)
		{
d867 2
a868 3
		if(!OCSP_resp_find_status(bs, id, &status, &reason,
					&rev, &thisupd, &nextupd))
			{
d871 4
a874 4
			}

		/* Check validity: if invalid write to output BIO so we
		 * know which response this refers to.
d876 1
a876 2
		if (!OCSP_check_validity(thisupd, nextupd, nsec, maxage))
			{
d879 1
a879 1
			}
d886 1
a886 2
		if(nextupd)
			{
d890 1
a890 2
			}

d896 1
a896 1
				OCSP_crl_reason_str(reason));
d901 1
a901 1
		}
d904 1
a904 1
	}
d907 6
a912 5
static int make_ocsp_response(OCSP_RESPONSE **resp, OCSP_REQUEST *req, CA_DB *db,
			X509 *ca, X509 *rcert, EVP_PKEY *rkey,
			STACK_OF(X509) *rother, unsigned long flags,
			int nmin, int ndays)
	{
d920 1
a920 2
	if (id_count <= 0)
		{
d923 1
a923 3
		}


d927 1
a927 1
		nextupd = X509_gmtime_adj(NULL, nmin * 60 + ndays * 3600 * 24 );
d930 1
a930 2
	for (i = 0; i < id_count; i++)
		{
d939 1
a939 1
		OCSP_id_get0_info(NULL,&cert_id_md_oid, NULL,NULL, cid);
d941 2
a942 3
		cert_id_md = EVP_get_digestbyobj(cert_id_md_oid);	
		if (! cert_id_md) 
			{
d944 5
a948 4
				NULL);
				goto end;
			}	
		if (ca_id) OCSP_CERTID_free(ca_id);
d952 1
a952 2
		if (OCSP_id_issuer_cmp(ca_id, cid))
			{
d954 3
a956 3
						V_OCSP_CERTSTATUS_UNKNOWN,
						0, NULL,
						thisupd, nextupd);
d958 1
a958 1
			}
d963 3
a965 3
						V_OCSP_CERTSTATUS_UNKNOWN,
						0, NULL,
						thisupd, nextupd);
d968 4
a971 5
						V_OCSP_CERTSTATUS_GOOD,
						0, NULL,
						thisupd, nextupd);
		else if (inf[DB_type][0] == DB_TYPE_REV)
			{
d979 3
a981 3
						V_OCSP_CERTSTATUS_REVOKED,
						reason, revtm,
						thisupd, nextupd);
a988 1
			}
d990 1
d993 1
a993 1
	
d998 1
a998 1
	end:
d1005 1
a1005 1
	}
d1007 3
a1009 2
static char **lookup_serial(CA_DB *db, ASN1_INTEGER *ser)
	{
d1012 6
a1017 4
	char *itmp, *row[DB_NUMBER],**rrow;
	for (i = 0; i < DB_NUMBER; i++) row[i] = NULL;
	bn = ASN1_INTEGER_to_BN(ser,NULL);
	OPENSSL_assert(bn); /* FIXME: should report an error at this point and abort */
d1024 1
a1024 1
	rrow=TXT_DB_get_by_index(db->db,DB_serial,row);
d1027 1
a1027 1
	}
d1031 3
a1033 2
static BIO *init_responder(char *port)
	{
d1036 1
a1036 1
	if (!bufbio) 
d1048 5
a1052 7
	if (BIO_do_accept(acbio) <= 0)
		{
			BIO_printf(bio_err, "Error setting up accept BIO\n");
			ERR_print_errors(bio_err);
			goto err;
		}

d1055 1
a1055 1
	err:
d1059 1
a1059 1
	}
d1061 3
a1063 2
static int do_responder(OCSP_REQUEST **preq, BIO **pcbio, BIO *acbio, char *port)
	{
d1069 5
a1073 7
	if (BIO_do_accept(acbio) <= 0)
		{
			BIO_printf(bio_err, "Error accepting connection\n");
			ERR_print_errors(bio_err);
			return 0;
		}

d1077 1
a1077 2
	for(;;)
		{
d1082 2
a1083 4
		if (!have_post)
			{
			if(strncmp(inbuf, "POST", 4))
				{
d1086 1
a1086 1
				}
d1088 1
a1088 1
			}
d1092 1
a1092 1
		}
d1098 1
a1098 2
	if (!req)
		{
d1101 1
a1101 2
		}

d1106 1
a1106 1
	}
d1108 6
a1113 5
static int send_ocsp_response(BIO *cbio, OCSP_RESPONSE *resp)
	{
	static const char http_resp[] = 
		"HTTP/1.0 200 OK\r\nContent-type: application/ocsp-response\r\n"
		"Content-Length: %d\r\n\r\n";
d1118 1
a1118 1
	(void)BIO_flush(cbio);
d1120 1
a1120 1
	}
d1122 5
a1126 4
static OCSP_RESPONSE *query_responder(BIO *err, BIO *cbio, char *path,
				STACK_OF(CONF_VALUE) *headers,
				OCSP_REQUEST *req, int req_timeout)
	{
d1140 1
a1140 2
	if ((rv <= 0) && ((req_timeout == -1) || !BIO_should_retry(cbio)))
		{
d1143 2
a1144 4
		}

	if (BIO_get_fd(cbio, &fd) <= 0)
		{
d1147 2
a1148 4
		}

	if (req_timeout != -1 && rv <= 0)
		{
d1153 2
a1154 3
		rv = select(fd + 1, NULL, (void *)&confds, NULL, &tv);
		if (rv == 0)
			{
a1156 1
			}
d1158 1
a1158 2


d1163 1
a1163 2
	for (i = 0; i < sk_CONF_VALUE_num(headers); i++)
		{
d1167 1
a1167 1
		}
d1171 2
a1172 3
	
	for (;;)
		{
d1183 1
a1183 1
			rv = select(fd + 1, (void *)&confds, NULL, NULL, &tv);
d1185 2
a1186 3
			rv = select(fd + 1, NULL, (void *)&confds, NULL, &tv);
		else
			{
d1189 2
a1190 3
			}
		if (rv == 0)
			{
d1193 2
a1194 3
			}
		if (rv == -1)
			{
a1196 2
			}

d1198 2
a1199 1
	err:
d1204 1
a1204 1
	}
d1206 6
a1211 5
OCSP_RESPONSE *process_responder(BIO *err, OCSP_REQUEST *req,
			char *host, char *path, char *port, int use_ssl,
			STACK_OF(CONF_VALUE) *headers,
			int req_timeout)
	{
d1216 1
a1216 2
	if (!cbio)
		{
d1219 4
a1222 4
		}
	if (port) BIO_set_conn_port(cbio, port);
	if (use_ssl == 1)
		{
d1225 1
a1225 2
		if (ctx == NULL)
			{
d1228 1
a1228 1
			}
d1232 1
a1232 1
		}
d1236 1
a1236 1
	end:
d1242 1
a1242 1
	}
@


1.15
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d1396 1
a1396 1
		BIO_printf(bio_err, "Error querying OCSP responsder\n");
@


1.14
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a59 2
#define USE_SOCKETS

d923 1
a923 1
	OPENSSL_EXIT(ret);
@


1.13
log
@SSLv3_client_method() doesn't support TLSv1.*; use SSLv23_client_method()
the for anything where version negotiation would be useful.
Also, constipate a couple formatting strings to make compilers and
linkers happier.

ok tedu@@
@
text
@d920 3
a922 3
		OPENSSL_free(host);
		OPENSSL_free(port);
		OPENSSL_free(path);
d1168 1
a1168 1
	OPENSSL_free(itmp);
@


1.12
log
@spray the apps directory with anti-VMS napalm.
so that its lovecraftian horror is not forever lost, i reproduce below
a comment from the deleted code.

        /* 2011-03-22 SMS.
         * If we have 32-bit pointers everywhere, then we're safe, and
         * we bypass this mess, as on non-VMS systems.  (See ARGV,
         * above.)
         * Problem 1: Compaq/HP C before V7.3 always used 32-bit
         * pointers for argv[].
         * Fix 1: For a 32-bit argv[], when we're using 64-bit pointers
         * everywhere else, we always allocate and use a 64-bit
         * duplicate of argv[].
         * Problem 2: Compaq/HP C V7.3 (Alpha, IA64) before ECO1 failed
         * to NULL-terminate a 64-bit argv[].  (As this was written, the
         * compiler ECO was available only on IA64.)
         * Fix 2: Unless advised not to (VMS_TRUST_ARGV), we test a
         * 64-bit argv[argc] for NULL, and, if necessary, use a
         * (properly) NULL-terminated (64-bit) duplicate of argv[].
         * The same code is used in either case to duplicate argv[].
         * Some of these decisions could be handled in preprocessing,
         * but the code tends to get even uglier, and the penalty for
         * deciding at compile- or run-time is tiny.
         */
@
text
@d1260 1
a1260 1
	char http_resp[] = 
d1386 1
a1386 1
		ctx = SSL_CTX_new(SSLv3_client_method());
@


1.11
log
@remove ssl2 support even more completely.
in the process, always include ssl3 and tls1, we don't need config options
for them. when the time comes to expire ssl3, it will be with an ax.
checked by miod
@
text
@a59 5
#ifdef OPENSSL_SYS_VMS
#define _XOPEN_SOURCE_EXTENDED	/* So fd_set and friends get properly defined
				   on OpenVMS */
#endif

@


1.10
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a1390 3
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
		ctx = SSL_CTX_new(SSLv23_client_method());
#elif !defined(OPENSSL_NO_SSL3)
a1391 6
#elif !defined(OPENSSL_NO_SSL2)
		ctx = SSL_CTX_new(SSLv2_client_method());
#else
		BIO_printf(err, "SSL is disabled\n");
			goto end;
#endif
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d620 1
a620 1
		BIO_printf (bio_err, "-<dgst alg>     use specified digest in the request");
@


1.8
log
@resolve conflicts
@
text
@d59 6
d66 1
d70 1
d73 2
d76 19
a94 2
#include <openssl/err.h>

d98 1
a98 1
static int add_ocsp_cert(OCSP_REQUEST **req, X509 *cert, X509 *issuer,
d100 1
a100 1
static int add_ocsp_serial(OCSP_REQUEST **req, char *serial, X509 *issuer,
d103 3
a105 2
				STACK *names, STACK_OF(OCSP_CERTID) *ids,
				long nsec, long maxage);
d117 1
d136 1
d159 1
a159 1
	STACK *reqnames = NULL;
d167 1
d176 1
a176 1
	reqnames = sk_new_null();
d236 10
d445 2
a446 1
				if(!add_ocsp_cert(&req, cert, issuer, ids))
d448 1
a448 1
				if(!sk_push(reqnames, *args))
d458 2
a459 1
				if(!add_ocsp_serial(&req, *args, issuer, ids))
d461 1
a461 1
				if(!sk_push(reqnames, *args))
d561 4
a564 1
		else badarg = 1;
d620 1
d727 2
a728 1
		if (!OCSP_request_sign(req, signer, key, EVP_sha1(), sign_other, sign_flags))
d772 1
a772 1
						port, use_ssl, req_timeout);
d917 1
a917 1
	sk_free(reqnames);
d921 1
d933 1
a933 1
static int add_ocsp_cert(OCSP_REQUEST **req, X509 *cert, X509 *issuer,
d944 1
a944 1
	id = OCSP_cert_to_id(NULL, cert, issuer);
d954 1
a954 1
static int add_ocsp_serial(OCSP_REQUEST **req, char *serial, X509 *issuer,
d976 1
a976 1
	id = OCSP_cert_id_new(EVP_sha1(), iname, ikey, sno);
d988 3
a990 2
					STACK *names, STACK_OF(OCSP_CERTID) *ids,
					long nsec, long maxage)
d1000 1
a1000 1
	if (!bs || !req || !sk_num(names) || !sk_OCSP_CERTID_num(ids))
d1006 1
a1006 1
		name = sk_value(names, i);
a1062 1

a1070 1
	ca_id = OCSP_cert_to_id(EVP_sha1(), NULL, ca);
d1083 2
d1087 13
d1144 2
a1145 2
		
	OCSP_basic_sign(bs, rcert, rkey, EVP_sha1(), rother, flags);
d1277 1
d1282 1
a1298 3
	if (req_timeout == -1)
		return OCSP_sendreq_bio(cbio, path, req);

d1305 1
a1305 1
	if (rv <= 0)
d1320 1
a1320 1
	ctx = OCSP_sendreq_new(cbio, path, req, -1);
d1323 10
d1339 2
d1364 1
a1364 1
			
d1375 1
d1410 1
a1410 1
	resp = query_responder(err, cbio, path, req, req_timeout);
d1414 2
a1417 2
	if (cbio)
		BIO_free_all(cbio);
@


1.7
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.6
log
@merge 0.9.7d
@
text
@d59 1
a59 1

d61 1
d63 3
a65 3
#include "apps.h"
#include <openssl/pem.h>
#include <openssl/ocsp.h>
a66 1
#include <openssl/ssl.h>
d88 2
d116 1
a120 1
	SSL_CTX *ctx = NULL;
d143 1
d158 16
d723 4
a726 1
		cbio = BIO_new_connect(host);
a730 36
		if (!cbio)
			{
			BIO_printf(bio_err, "Error creating connect BIO\n");
			goto end;
			}
		if (port) BIO_set_conn_port(cbio, port);
		if (use_ssl == 1)
			{
			BIO *sbio;
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
			ctx = SSL_CTX_new(SSLv23_client_method());
#elif !defined(OPENSSL_NO_SSL3)
			ctx = SSL_CTX_new(SSLv3_client_method());
#elif !defined(OPENSSL_NO_SSL2)
			ctx = SSL_CTX_new(SSLv2_client_method());
#else
			BIO_printf(bio_err, "SSL is disabled\n");
			goto end;
#endif
			SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);
			sbio = BIO_new_ssl(ctx, 1);
			cbio = BIO_push(sbio, cbio);
			}
		if (BIO_do_connect(cbio) <= 0)
			{
			BIO_printf(bio_err, "Error connecting BIO\n");
			goto end;
			}
		resp = OCSP_sendreq_bio(cbio, path, req);
		BIO_free_all(cbio);
		cbio = NULL;
		if (!resp)
			{
			BIO_printf(bio_err, "Error querying OCSP responsder\n");
			goto end;
			}
d773 1
a773 1
		BIO_printf(out, "Responder Error: %s (%ld)\n",
d839 1
a839 1
			BIO_printf(bio_err, "Response Verify Failure\n", i);
a878 1
		SSL_CTX_free(ctx);
d1102 1
d1209 1
a1209 1
	BIO_flush(cbio);
d1211 133
@


1.5
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@a70 13
/* CA index.txt definitions */
#define DB_type         0
#define DB_exp_date     1
#define DB_rev_date     2
#define DB_serial       3       /* index - unique */
#define DB_file         4       
#define DB_name         5       /* index - unique for active */
#define DB_NUMBER       6

#define DB_TYPE_REV	'R'
#define DB_TYPE_EXP	'E'
#define DB_TYPE_VAL	'V'

d79 1
a79 1
static int make_ocsp_response(OCSP_RESPONSE **resp, OCSP_REQUEST *req, TXT_DB *db,
d84 1
a84 1
static char **lookup_serial(TXT_DB *db, ASN1_INTEGER *ser);
d133 1
a133 1
	TXT_DB *rdb = NULL;
d690 3
a692 16
		BIO *db_bio = NULL;
		db_bio = BIO_new_file(ridx_filename, "r");
		if (!db_bio)
			{
			BIO_printf(bio_err, "Error opening index file %s\n", ridx_filename);
			goto end;
			}
		rdb = TXT_DB_read(db_bio, DB_NUMBER);
		BIO_free(db_bio);
		if (!rdb)
			{
			BIO_printf(bio_err, "Error reading index file %s\n", ridx_filename);
			goto end;
			}
		if (!make_serial_index(rdb))
			goto end;
d876 1
a876 1
	TXT_DB_free(rdb);
d1018 1
a1018 1
static int make_ocsp_response(OCSP_RESPONSE **resp, OCSP_REQUEST *req, TXT_DB *db,
d1110 1
a1110 1
static char **lookup_serial(TXT_DB *db, ASN1_INTEGER *ser)
d1123 1
a1123 1
	rrow=TXT_DB_get_by_index(db,DB_serial,row);
@


1.4
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d139 1
d199 2
d815 2
@


1.3
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d58 1
d527 1
a527 1
		BIO_printf (bio_err, "-sign_certs file   additional certificates to include in signed request\n");
d547 1
a547 1
		BIO_printf (bio_err, "-verify_certs file additional certificates to search for signer\n");
d550 1
a550 1
		BIO_printf (bio_err, "-no_sig_verify     don't check signature on response\n");
d726 1
d728 4
d741 1
d743 8
d917 1
a917 1
	EXIT(ret);
d1138 4
a1141 1
	itmp = BN_bn2hex(bn);
d1157 1
d1159 3
d1201 1
a1201 1
		len = BIO_gets(cbio, inbuf, 1024);
d1248 1
@


1.2
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d616 1
a616 1
			rother = load_certs(bio_err, sign_certfile, FORMAT_PEM,
d618 1
a618 1
			if (!sign_other) goto end;
d620 1
a620 1
		rkey = load_key(bio_err, rkeyfile, FORMAT_PEM, NULL, NULL,
d666 1
a666 1
		key = load_key(bio_err, keyfile, FORMAT_PEM, NULL, NULL,
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d61 1
a65 1
#include "apps.h"
d556 2
a557 2
		BIO_printf (bio_err, "-rsigner file	 responder certificate to sign requests with\n");
		BIO_printf (bio_err, "-rkey file	 responder key to sign requests with\n");
d679 12
d824 2
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@a60 1
#include "apps.h"
d65 1
d556 2
a557 2
		BIO_printf (bio_err, "-rsigner file	 responder certificate to sign responses with\n");
		BIO_printf (bio_err, "-rkey file	 responder key to sign responses with\n");
a678 12
	if (reqout)
		{
		derbio = BIO_new_file(reqout, "wb");
		if(!derbio)
			{
			BIO_printf(bio_err, "Error opening file %s\n", reqout);
			goto end;
			}
		i2d_OCSP_REQUEST_bio(derbio, req);
		BIO_free(derbio);
		}

a811 2
	if (!store)
		goto end;
@


1.1.1.3
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d616 1
a616 1
			rother = load_certs(bio_err, rcertfile, FORMAT_PEM,
d618 1
a618 1
			if (!rother) goto end;
d620 1
a620 1
		rkey = load_key(bio_err, rkeyfile, FORMAT_PEM, 0, NULL, NULL,
d666 1
a666 1
		key = load_key(bio_err, keyfile, FORMAT_PEM, 0, NULL, NULL,
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a57 1
#ifndef OPENSSL_NO_OCSP
d526 1
a526 1
		BIO_printf (bio_err, "-sign_other file   additional certificates to include in signed request\n");
d546 1
a546 1
		BIO_printf (bio_err, "-verify_other file additional certificates to search for signer\n");
d549 1
a549 1
		BIO_printf (bio_err, "-no_signature_verify don't check signature on response\n");
a724 1
#ifndef OPENSSL_NO_SOCK
a725 4
#else
		BIO_printf(bio_err, "Error creating connect BIO - sockets not supported.\n");
		goto end;
#endif
a734 1
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
a735 8
#elif !defined(OPENSSL_NO_SSL3)
			ctx = SSL_CTX_new(SSLv3_client_method());
#elif !defined(OPENSSL_NO_SSL2)
			ctx = SSL_CTX_new(SSLv2_client_method());
#else
			BIO_printf(bio_err, "SSL is disabled\n");
			goto end;
#endif
d902 1
a902 1
	OPENSSL_EXIT(ret);
d1123 1
a1123 4
	if (BN_is_zero(bn))
		itmp = BUF_strdup("00");
	else
		itmp = BN_bn2hex(bn);
a1138 1
#ifndef OPENSSL_NO_SOCK
a1139 3
#else
	BIO_printf(bio_err, "Error setting up accept BIO - sockets not supported.\n");
#endif
d1179 1
a1179 1
		len = BIO_gets(cbio, inbuf, sizeof inbuf);
a1225 1
#endif
@


1.1.1.5
log
@import 0.9.7c
@
text
@a138 1
	int ignore_err = 0;
a197 2
		else if (!strcmp(*args, "-ignore_err"))
			ignore_err = 1;
a811 2
		if (ignore_err)
			goto redo_accept;
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d71 13
d92 1
a92 1
static int make_ocsp_response(OCSP_RESPONSE **resp, OCSP_REQUEST *req, CA_DB *db,
d97 1
a97 1
static char **lookup_serial(CA_DB *db, ASN1_INTEGER *ser);
d146 1
a146 1
	CA_DB *rdb = NULL;
d703 16
a718 3
		rdb = load_index(ridx_filename, NULL);
		if (!rdb) goto end;
		if (!index_index(rdb)) goto end;
d902 1
a902 1
	free_index(rdb);
d1044 1
a1044 1
static int make_ocsp_response(OCSP_RESPONSE **resp, OCSP_REQUEST *req, CA_DB *db,
d1136 1
a1136 1
static char **lookup_serial(CA_DB *db, ASN1_INTEGER *ser)
d1149 1
a1149 1
	rrow=TXT_DB_get_by_index(db->db,DB_serial,row);
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d59 1
a59 1
#define USE_SOCKETS
a60 1
#include <stdlib.h>
d62 4
a65 2
#include "apps.h" /* needs to be included before the openssl headers! */
#include <openssl/e_os2.h>
a66 1
#include <openssl/err.h>
a87 2
static OCSP_RESPONSE *query_responder(BIO *err, BIO *cbio, char *path,
				OCSP_REQUEST *req, int req_timeout);
a113 1
	int req_timeout = -1;
d118 1
a140 1
	OpenSSL_add_ssl_algorithms();
a154 16
		else if (!strcmp(*args, "-timeout"))
			{
			if (args[1])
				{
				args++;
				req_timeout = atol(*args);
				if (req_timeout < 0)
					{
					BIO_printf(bio_err,
						"Illegal timeout value %s\n",
						*args);
					badarg = 1;
					}
				}
			else badarg = 1;
			}
d704 1
a704 4
		resp = process_responder(bio_err, req, host, path,
						port, use_ssl, req_timeout);
		if (!resp)
			goto end;
d709 36
d787 1
a787 1
		BIO_printf(out, "Responder Error: %s (%d)\n",
d853 1
a853 1
			BIO_printf(bio_err, "Response Verify Failure\n");
d893 1
a1116 1
	OPENSSL_assert(bn); /* FIXME: should report an error at this point and abort */
d1223 1
a1223 1
	(void)BIO_flush(cbio);
a1224 133
	}

static OCSP_RESPONSE *query_responder(BIO *err, BIO *cbio, char *path,
				OCSP_REQUEST *req, int req_timeout)
	{
	int fd;
	int rv;
	OCSP_REQ_CTX *ctx = NULL;
	OCSP_RESPONSE *rsp = NULL;
	fd_set confds;
	struct timeval tv;

	if (req_timeout != -1)
		BIO_set_nbio(cbio, 1);

	rv = BIO_do_connect(cbio);

	if ((rv <= 0) && ((req_timeout == -1) || !BIO_should_retry(cbio)))
		{
		BIO_puts(err, "Error connecting BIO\n");
		return NULL;
		}

	if (req_timeout == -1)
		return OCSP_sendreq_bio(cbio, path, req);

	if (BIO_get_fd(cbio, &fd) <= 0)
		{
		BIO_puts(err, "Can't get connection fd\n");
		goto err;
		}

	if (rv <= 0)
		{
		FD_ZERO(&confds);
		openssl_fdset(fd, &confds);
		tv.tv_usec = 0;
		tv.tv_sec = req_timeout;
		rv = select(fd + 1, NULL, (void *)&confds, NULL, &tv);
		if (rv == 0)
			{
			BIO_puts(err, "Timeout on connect\n");
			return NULL;
			}
		}


	ctx = OCSP_sendreq_new(cbio, path, req, -1);
	if (!ctx)
		return NULL;
	
	for (;;)
		{
		rv = OCSP_sendreq_nbio(&rsp, ctx);
		if (rv != -1)
			break;
		FD_ZERO(&confds);
		openssl_fdset(fd, &confds);
		tv.tv_usec = 0;
		tv.tv_sec = req_timeout;
		if (BIO_should_read(cbio))
			rv = select(fd + 1, (void *)&confds, NULL, NULL, &tv);
		else if (BIO_should_write(cbio))
			rv = select(fd + 1, NULL, (void *)&confds, NULL, &tv);
		else
			{
			BIO_puts(err, "Unexpected retry condition\n");
			goto err;
			}
		if (rv == 0)
			{
			BIO_puts(err, "Timeout on request\n");
			break;
			}
		if (rv == -1)
			{
			BIO_puts(err, "Select error\n");
			break;
			}
			
		}
	err:
	if (ctx)
		OCSP_REQ_CTX_free(ctx);

	return rsp;
	}

OCSP_RESPONSE *process_responder(BIO *err, OCSP_REQUEST *req,
			char *host, char *path, char *port, int use_ssl,
			int req_timeout)
	{
	BIO *cbio = NULL;
	SSL_CTX *ctx = NULL;
	OCSP_RESPONSE *resp = NULL;
	cbio = BIO_new_connect(host);
	if (!cbio)
		{
		BIO_printf(err, "Error creating connect BIO\n");
		goto end;
		}
	if (port) BIO_set_conn_port(cbio, port);
	if (use_ssl == 1)
		{
		BIO *sbio;
#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)
		ctx = SSL_CTX_new(SSLv23_client_method());
#elif !defined(OPENSSL_NO_SSL3)
		ctx = SSL_CTX_new(SSLv3_client_method());
#elif !defined(OPENSSL_NO_SSL2)
		ctx = SSL_CTX_new(SSLv2_client_method());
#else
		BIO_printf(err, "SSL is disabled\n");
			goto end;
#endif
		if (ctx == NULL)
			{
			BIO_printf(err, "Error creating SSL context.\n");
			goto end;
			}
		SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);
		sbio = BIO_new_ssl(ctx, 1);
		cbio = BIO_push(sbio, cbio);
		}
	resp = query_responder(err, cbio, path, req, req_timeout);
	if (!resp)
		BIO_printf(bio_err, "Error querying OCSP responsder\n");
	end:
	if (ctx)
		SSL_CTX_free(ctx);
	if (cbio)
		BIO_free_all(cbio);
	return resp;
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@a58 6

#ifdef OPENSSL_SYS_VMS
#define _XOPEN_SOURCE_EXTENDED	/* So fd_set and friends get properly defined
				   on OpenVMS */
#endif

a59 1

a62 1
#include <time.h>
d65 1
a65 1
#include <openssl/crypto.h>
d67 1
a67 20
#include <openssl/ssl.h>
#include <openssl/evp.h>
#include <openssl/bn.h>
#include <openssl/x509v3.h>

#if defined(NETWARE_CLIB)
#  ifdef NETWARE_BSDSOCK
#    include <sys/socket.h>
#    include <sys/bsdskt.h>
#  else
#    include <novsock2.h>
#  endif
#elif defined(NETWARE_LIBC)
#  ifdef NETWARE_BSDSOCK
#    include <sys/select.h>
#  else
#    include <novsock2.h>
#  endif
#endif
  
d71 1
a71 1
static int add_ocsp_cert(OCSP_REQUEST **req, X509 *cert, const EVP_MD *cert_id_md, X509 *issuer,
d73 1
a73 1
static int add_ocsp_serial(OCSP_REQUEST **req, char *serial, const EVP_MD * cert_id_md, X509 *issuer,
d76 2
a77 3
			      STACK_OF(OPENSSL_STRING) *names,
			      STACK_OF(OCSP_CERTID) *ids, long nsec,
			      long maxage);
a88 1
				STACK_OF(CONF_VALUE) *headers,
a106 1
	STACK_OF(CONF_VALUE) *headers = NULL;
d129 1
a129 1
	STACK_OF(OPENSSL_STRING) *reqnames = NULL;
a136 1
	const EVP_MD *cert_id_md = NULL;
d145 1
a145 1
	reqnames = sk_OPENSSL_STRING_new_null();
a204 10
		else if (!strcmp(*args, "-header"))
			{
			if (args[1] && args[2])
				{
				if (!X509V3_add_value(args[1], args[2], &headers))
					goto end;
				args += 2;
				}
			else badarg = 1;
			}
d404 1
a404 2
				if (!cert_id_md) cert_id_md = EVP_sha1();
				if(!add_ocsp_cert(&req, cert, cert_id_md, issuer, ids))
d406 1
a406 1
				if(!sk_OPENSSL_STRING_push(reqnames, *args))
d416 1
a416 2
				if (!cert_id_md) cert_id_md = EVP_sha1();
				if(!add_ocsp_serial(&req, *args, cert_id_md, issuer, ids))
d418 1
a418 1
				if(!sk_OPENSSL_STRING_push(reqnames, *args))
d518 1
a518 4
		else if ((cert_id_md = EVP_get_digestbyname((*args)+1))==NULL)
			{
			badarg = 1;
			}
a573 1
		BIO_printf (bio_err, "-<dgst alg>     use specified digest in the request");
d680 1
a680 2

		if (!OCSP_request_sign(req, signer, key, NULL, sign_other, sign_flags))
d724 1
a724 1
					port, use_ssl, headers, req_timeout);
d869 1
a869 1
	sk_OPENSSL_STRING_free(reqnames);
a872 1
	sk_CONF_VALUE_pop_free(headers, X509V3_conf_free);
d884 1
a884 1
static int add_ocsp_cert(OCSP_REQUEST **req, X509 *cert, const EVP_MD *cert_id_md,X509 *issuer,
d895 1
a895 1
	id = OCSP_cert_to_id(cert_id_md, cert, issuer);
d905 1
a905 1
static int add_ocsp_serial(OCSP_REQUEST **req, char *serial,const EVP_MD *cert_id_md, X509 *issuer,
d927 1
a927 1
	id = OCSP_cert_id_new(cert_id_md, iname, ikey, sno);
d939 2
a940 3
			      STACK_OF(OPENSSL_STRING) *names,
			      STACK_OF(OCSP_CERTID) *ids, long nsec,
			      long maxage)
d950 1
a950 1
	if (!bs || !req || !sk_OPENSSL_STRING_num(names) || !sk_OCSP_CERTID_num(ids))
d956 1
a956 1
		name = sk_OPENSSL_STRING_value(names, i);
d1013 1
d1022 1
a1034 2
		ASN1_OBJECT *cert_id_md_oid;
		const EVP_MD *cert_id_md;
a1036 13

		OCSP_id_get0_info(NULL,&cert_id_md_oid, NULL,NULL, cid);

		cert_id_md = EVP_get_digestbyobj(cert_id_md_oid);	
		if (! cert_id_md) 
			{
			*resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,
				NULL);
				goto end;
			}	
		if (ca_id) OCSP_CERTID_free(ca_id);
		ca_id = OCSP_cert_to_id(cert_id_md, NULL, ca);

d1081 2
a1082 2
	
	OCSP_basic_sign(bs, rcert, rkey, NULL, rother, flags);
a1213 1
				STACK_OF(CONF_VALUE) *headers,
a1217 1
	int i;
d1234 3
d1243 1
a1243 1
	if (req_timeout != -1 && rv <= 0)
d1258 1
a1258 1
	ctx = OCSP_sendreq_new(cbio, path, NULL, -1);
a1260 10

	for (i = 0; i < sk_CONF_VALUE_num(headers); i++)
		{
		CONF_VALUE *hdr = sk_CONF_VALUE_value(headers, i);
		if (!OCSP_REQ_CTX_add1_header(ctx, hdr->name, hdr->value))
			goto err;
		}

	if (!OCSP_REQ_CTX_set1_req(ctx, req))
		goto err;
a1266 2
		if (req_timeout == -1)
			continue;
d1290 1
a1290 1

a1300 1
			STACK_OF(CONF_VALUE) *headers,
d1335 1
a1335 1
	resp = query_responder(err, cbio, path, headers, req, req_timeout);
d1339 2
a1342 2
	if (ctx)
		SSL_CTX_free(ctx);
@


1.1.1.10
log
@Import OpenSSL 1.0.1g
@
text
@d620 1
a620 1
		BIO_printf (bio_err, "-<dgst alg>     use specified digest in the request\n");
@


