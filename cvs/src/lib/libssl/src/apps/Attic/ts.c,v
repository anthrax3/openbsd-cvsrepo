head	1.19;
access;
symbols
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	butholakala:1.1.1.2
	openssl_1_0_1_g:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.16
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.12
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	openssl_1_0_1_c:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.6
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.8
	openssl_1_0_0_f:1.1.1.2
	openssl_1_0_0_e:1.1.1.2
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	openssh_1_0_0_a:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.6
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.4
	OPENBSD_4_6_BASE:1.1.1.1
	openssl_0_9_8_k:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.08.26.17.47.25;	author jsing;	state dead;
branches;
next	1.18;
commitid	7A7DObXgY4Fni8xJ;

1.18
date	2014.07.12.17.54.31;	author jsing;	state Exp;
branches;
next	1.17;
commitid	0NuggCO2WJOZj8Kh;

1.17
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	mJUVYpkFBZ0Zv2bG;

1.16
date	2014.06.02.16.23.18;	author jsing;	state Exp;
branches;
next	1.15;
commitid	IqYoI5gjfSomu7k2;

1.15
date	2014.05.23.16.10.02;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2014.05.19.12.13.30;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2014.05.18.16.21.03;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2014.05.18.11.36.24;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.24.12.22.22;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.22.14.05.40;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.18.19.54.57;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.18.09.38.42;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.18.04.33.09;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.18.04.17.17;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.18.02.45.27;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.13.20.37.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.06.30.00;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.04.06.06.30.00;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.10.01.22.54.01;	author djm;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@/* $OpenBSD: ts.c,v 1.18 2014/07/12 17:54:31 jsing Exp $ */
/* Written by Zoltan Glozik (zglozik@@stones.com) for the OpenSSL
 * project 2002.
 */
/* ====================================================================
 * Copyright (c) 2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "apps.h"

#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/rand.h>
#include <openssl/ts.h>

/* Length of the nonce of the request in bits (must be a multiple of 8). */
#define	NONCE_LENGTH		64

/* Macro definitions for the configuration file. */
#define	ENV_OID_FILE		"oid_file"

/* Local function declarations. */

static ASN1_OBJECT *txt2obj(const char *oid);
static CONF *load_config_file(const char *configfile);

/* Query related functions. */
static int query_command(const char *data, char *digest,
    const EVP_MD * md, const char *policy, int no_nonce,
    int cert, const char *in, const char *out, int text);
static BIO *BIO_open_with_default(const char *file, const char *mode,
    FILE * default_fp);
static TS_REQ *create_query(BIO * data_bio, char *digest, const EVP_MD * md,
    const char *policy, int no_nonce, int cert);
static int create_digest(BIO * input, char *digest,
    const EVP_MD * md, unsigned char **md_value);
static ASN1_INTEGER *create_nonce(int bits);

/* Reply related functions. */
static int reply_command(CONF * conf, char *section, char *engine,
    char *queryfile, char *passin, char *inkey,
    char *signer, char *chain, const char *policy,
    char *in, int token_in, char *out, int token_out,
    int text);
static TS_RESP *read_PKCS7(BIO * in_bio);
static TS_RESP *create_response(CONF * conf, const char *section, char *engine,
    char *queryfile, char *passin, char *inkey,
    char *signer, char *chain, const char *policy);
static ASN1_INTEGER *serial_cb(TS_RESP_CTX * ctx, void *data);
static ASN1_INTEGER *next_serial(const char *serialfile);
static int save_ts_serial(const char *serialfile, ASN1_INTEGER * serial);

/* Verify related functions. */
static int verify_command(char *data, char *digest, char *queryfile,
    char *in, int token_in,
    char *ca_path, char *ca_file, char *untrusted);
static TS_VERIFY_CTX *create_verify_ctx(char *data, char *digest,
    char *queryfile,
    char *ca_path, char *ca_file,
    char *untrusted);
static X509_STORE *create_cert_store(char *ca_path, char *ca_file);
static int verify_cb(int ok, X509_STORE_CTX * ctx);

/* Main function definition. */
int ts_main(int, char **);

int
ts_main(int argc, char **argv)
{
	int ret = 1;
	char *configfile = NULL;
	char *section = NULL;
	CONF *conf = NULL;
	enum mode {
		CMD_NONE, CMD_QUERY, CMD_REPLY, CMD_VERIFY
	} mode = CMD_NONE;
	char *data = NULL;
	char *digest = NULL;
	const EVP_MD *md = NULL;
	char *policy = NULL;
	int no_nonce = 0;
	int cert = 0;
	char *in = NULL;
	char *out = NULL;
	int text = 0;
	char *queryfile = NULL;
	char *passin = NULL;	/* Password source. */
	char *password = NULL;	/* Password itself. */
	char *inkey = NULL;
	char *signer = NULL;
	char *chain = NULL;
	char *ca_path = NULL;
	char *ca_file = NULL;
	char *untrusted = NULL;
	char *engine = NULL;
	/* Input is ContentInfo instead of TimeStampResp. */
	int token_in = 0;
	/* Output is ContentInfo instead of TimeStampResp. */
	int token_out = 0;

	ERR_load_crypto_strings();

	for (argc--, argv++; argc > 0; argc--, argv++) {
		if (strcmp(*argv, "-config") == 0) {
			if (argc-- < 1)
				goto usage;
			configfile = *++argv;
		} else if (strcmp(*argv, "-section") == 0) {
			if (argc-- < 1)
				goto usage;
			section = *++argv;
		} else if (strcmp(*argv, "-query") == 0) {
			if (mode != CMD_NONE)
				goto usage;
			mode = CMD_QUERY;
		} else if (strcmp(*argv, "-data") == 0) {
			if (argc-- < 1)
				goto usage;
			data = *++argv;
		} else if (strcmp(*argv, "-digest") == 0) {
			if (argc-- < 1)
				goto usage;
			digest = *++argv;
		} else if (strcmp(*argv, "-policy") == 0) {
			if (argc-- < 1)
				goto usage;
			policy = *++argv;
		} else if (strcmp(*argv, "-no_nonce") == 0) {
			no_nonce = 1;
		} else if (strcmp(*argv, "-cert") == 0) {
			cert = 1;
		} else if (strcmp(*argv, "-in") == 0) {
			if (argc-- < 1)
				goto usage;
			in = *++argv;
		} else if (strcmp(*argv, "-token_in") == 0) {
			token_in = 1;
		} else if (strcmp(*argv, "-out") == 0) {
			if (argc-- < 1)
				goto usage;
			out = *++argv;
		} else if (strcmp(*argv, "-token_out") == 0) {
			token_out = 1;
		} else if (strcmp(*argv, "-text") == 0) {
			text = 1;
		} else if (strcmp(*argv, "-reply") == 0) {
			if (mode != CMD_NONE)
				goto usage;
			mode = CMD_REPLY;
		} else if (strcmp(*argv, "-queryfile") == 0) {
			if (argc-- < 1)
				goto usage;
			queryfile = *++argv;
		} else if (strcmp(*argv, "-passin") == 0) {
			if (argc-- < 1)
				goto usage;
			passin = *++argv;
		} else if (strcmp(*argv, "-inkey") == 0) {
			if (argc-- < 1)
				goto usage;
			inkey = *++argv;
		} else if (strcmp(*argv, "-signer") == 0) {
			if (argc-- < 1)
				goto usage;
			signer = *++argv;
		} else if (strcmp(*argv, "-chain") == 0) {
			if (argc-- < 1)
				goto usage;
			chain = *++argv;
		} else if (strcmp(*argv, "-verify") == 0) {
			if (mode != CMD_NONE)
				goto usage;
			mode = CMD_VERIFY;
		} else if (strcmp(*argv, "-CApath") == 0) {
			if (argc-- < 1)
				goto usage;
			ca_path = *++argv;
		} else if (strcmp(*argv, "-CAfile") == 0) {
			if (argc-- < 1)
				goto usage;
			ca_file = *++argv;
		} else if (strcmp(*argv, "-untrusted") == 0) {
			if (argc-- < 1)
				goto usage;
			untrusted = *++argv;
		} else if (strcmp(*argv, "-engine") == 0) {
			if (argc-- < 1)
				goto usage;
			engine = *++argv;
		} else if ((md = EVP_get_digestbyname(*argv + 1)) != NULL) {
			/* empty. */
		} else
			goto usage;
	}

	/* Get the password if required. */
	if (mode == CMD_REPLY && passin &&
	    !app_passwd(bio_err, passin, NULL, &password, NULL)) {
		BIO_printf(bio_err, "Error getting password.\n");
		goto cleanup;
	}
	/*
	 * Check consistency of parameters and execute the appropriate
	 * function.
	 */
	switch (mode) {
	case CMD_NONE:
		goto usage;
	case CMD_QUERY:
		/*
		 * Data file and message imprint cannot be specified at the
		 * same time.
		 */
		ret = data != NULL && digest != NULL;
		if (ret)
			goto usage;
		/* Load the config file for possible policy OIDs. */
		conf = load_config_file(configfile);
		ret = !query_command(data, digest, md, policy, no_nonce, cert,
		    in, out, text);
		break;
	case CMD_REPLY:
		conf = load_config_file(configfile);
		if (in == NULL) {
			ret = !(queryfile != NULL && conf != NULL && !token_in);
			if (ret)
				goto usage;
		} else {
			/* 'in' and 'queryfile' are exclusive. */
			ret = !(queryfile == NULL);
			if (ret)
				goto usage;
		}

		ret = !reply_command(conf, section, engine, queryfile,
		    password, inkey, signer, chain, policy,
		    in, token_in, out, token_out, text);
		break;
	case CMD_VERIFY:
		ret = !(((queryfile && !data && !digest) ||
		    (!queryfile && data && !digest) ||
		    (!queryfile && !data && digest)) && in != NULL);
		if (ret)
			goto usage;

		ret = !verify_command(data, digest, queryfile, in, token_in,
		    ca_path, ca_file, untrusted);
	}

	goto cleanup;

usage:
	BIO_printf(bio_err, "usage:\n"
	    "ts -query [-config configfile] "
	    "[-data file_to_hash] [-digest digest_bytes]"
	    "[-md2|-md4|-md5|-sha|-sha1|-mdc2|-ripemd160] "
	    "[-policy object_id] [-no_nonce] [-cert] "
	    "[-in request.tsq] [-out request.tsq] [-text]\n");
	BIO_printf(bio_err, "or\n"
	    "ts -reply [-config configfile] [-section tsa_section] "
	    "[-queryfile request.tsq] [-passin password] "
	    "[-signer tsa_cert.pem] [-inkey private_key.pem] "
	    "[-chain certs_file.pem] [-policy object_id] "
	    "[-in response.tsr] [-token_in] "
	    "[-out response.tsr] [-token_out] [-text] [-engine id]\n");
	BIO_printf(bio_err, "or\n"
	    "ts -verify [-data file_to_hash] [-digest digest_bytes] "
	    "[-queryfile request.tsq] "
	    "-in response.tsr [-token_in] "
	    "-CApath ca_path -CAfile ca_file.pem "
	    "-untrusted cert_file.pem\n");

cleanup:
	/* Clean up. */
	NCONF_free(conf);
	free(password);
	OBJ_cleanup();

	return (ret);
}

/*
 * Configuration file-related function definitions.
 */

static ASN1_OBJECT *
txt2obj(const char *oid)
{
	ASN1_OBJECT *oid_obj = NULL;

	if (!(oid_obj = OBJ_txt2obj(oid, 0)))
		BIO_printf(bio_err, "cannot convert %s to OID\n", oid);

	return oid_obj;
}

static CONF *
load_config_file(const char *configfile)
{
	CONF *conf = NULL;
	long errorline = -1;

	if (!configfile)
		configfile = getenv("OPENSSL_CONF");
	if (!configfile)
		configfile = getenv("SSLEAY_CONF");

	if (configfile &&
	    (!(conf = NCONF_new(NULL)) ||
	    NCONF_load(conf, configfile, &errorline) <= 0)) {
		if (errorline <= 0)
			BIO_printf(bio_err, "error loading the config file "
			    "'%s'\n", configfile);
		else
			BIO_printf(bio_err, "error on line %ld of config file "
			    "'%s'\n", errorline, configfile);
	}
	if (conf != NULL) {
		const char *p;

		BIO_printf(bio_err, "Using configuration from %s\n",
		    configfile);
		p = NCONF_get_string(conf, NULL, ENV_OID_FILE);
		if (p != NULL) {
			BIO *oid_bio = BIO_new_file(p, "r");
			if (!oid_bio)
				ERR_print_errors(bio_err);
			else {
				OBJ_create_objects(oid_bio);
				BIO_free_all(oid_bio);
			}
		} else
			ERR_clear_error();
		if (!add_oid_section(bio_err, conf))
			ERR_print_errors(bio_err);
	}
	return conf;
}

/*
 * Query-related method definitions.
 */

static int
query_command(const char *data, char *digest, const EVP_MD * md,
    const char *policy, int no_nonce, int cert, const char *in,
    const char *out, int text)
{
	int ret = 0;
	TS_REQ *query = NULL;
	BIO *in_bio = NULL;
	BIO *data_bio = NULL;
	BIO *out_bio = NULL;

	/* Build query object either from file or from scratch. */
	if (in != NULL) {
		if ((in_bio = BIO_new_file(in, "rb")) == NULL)
			goto end;
		query = d2i_TS_REQ_bio(in_bio, NULL);
	} else {
		/* Open the file if no explicit digest bytes were specified. */
		if (!digest &&
		    !(data_bio = BIO_open_with_default(data, "rb", stdin)))
			goto end;
		/* Creating the query object. */
		query = create_query(data_bio, digest, md,
		    policy, no_nonce, cert);
		/* Saving the random number generator state. */
	}
	if (query == NULL)
		goto end;

	/* Write query either in ASN.1 or in text format. */
	if ((out_bio = BIO_open_with_default(out, "wb", stdout)) == NULL)
		goto end;
	if (text) {
		/* Text output. */
		if (!TS_REQ_print_bio(out_bio, query))
			goto end;
	} else {
		/* ASN.1 output. */
		if (!i2d_TS_REQ_bio(out_bio, query))
			goto end;
	}

	ret = 1;

end:
	ERR_print_errors(bio_err);

	/* Clean up. */
	BIO_free_all(in_bio);
	BIO_free_all(data_bio);
	BIO_free_all(out_bio);
	TS_REQ_free(query);

	return ret;
}

static BIO *
BIO_open_with_default(const char *file, const char *mode, FILE * default_fp)
{
	return file == NULL ? BIO_new_fp(default_fp, BIO_NOCLOSE) :
	    BIO_new_file(file, mode);
}

static TS_REQ *
create_query(BIO * data_bio, char *digest, const EVP_MD * md,
    const char *policy, int no_nonce, int cert)
{
	int ret = 0;
	TS_REQ *ts_req = NULL;
	int len;
	TS_MSG_IMPRINT *msg_imprint = NULL;
	X509_ALGOR *algo = NULL;
	unsigned char *data = NULL;
	ASN1_OBJECT *policy_obj = NULL;
	ASN1_INTEGER *nonce_asn1 = NULL;

	/* Setting default message digest. */
	if (!md && !(md = EVP_get_digestbyname("sha1")))
		goto err;

	/* Creating request object. */
	if (!(ts_req = TS_REQ_new()))
		goto err;

	/* Setting version. */
	if (!TS_REQ_set_version(ts_req, 1))
		goto err;

	/* Creating and adding MSG_IMPRINT object. */
	if (!(msg_imprint = TS_MSG_IMPRINT_new()))
		goto err;

	/* Adding algorithm. */
	if (!(algo = X509_ALGOR_new()))
		goto err;
	if (!(algo->algorithm = OBJ_nid2obj(EVP_MD_type(md))))
		goto err;
	if (!(algo->parameter = ASN1_TYPE_new()))
		goto err;
	algo->parameter->type = V_ASN1_NULL;
	if (!TS_MSG_IMPRINT_set_algo(msg_imprint, algo))
		goto err;

	/* Adding message digest. */
	if ((len = create_digest(data_bio, digest, md, &data)) == 0)
		goto err;
	if (!TS_MSG_IMPRINT_set_msg(msg_imprint, data, len))
		goto err;

	if (!TS_REQ_set_msg_imprint(ts_req, msg_imprint))
		goto err;

	/* Setting policy if requested. */
	if (policy && !(policy_obj = txt2obj(policy)))
		goto err;
	if (policy_obj && !TS_REQ_set_policy_id(ts_req, policy_obj))
		goto err;

	/* Setting nonce if requested. */
	if (!no_nonce && !(nonce_asn1 = create_nonce(NONCE_LENGTH)))
		goto err;
	if (nonce_asn1 && !TS_REQ_set_nonce(ts_req, nonce_asn1))
		goto err;

	/* Setting certificate request flag if requested. */
	if (!TS_REQ_set_cert_req(ts_req, cert))
		goto err;

	ret = 1;

err:
	if (!ret) {
		TS_REQ_free(ts_req);
		ts_req = NULL;
		BIO_printf(bio_err, "could not create query\n");
	}
	TS_MSG_IMPRINT_free(msg_imprint);
	X509_ALGOR_free(algo);
	free(data);
	ASN1_OBJECT_free(policy_obj);
	ASN1_INTEGER_free(nonce_asn1);

	return ts_req;
}

static int
create_digest(BIO * input, char *digest, const EVP_MD * md,
    unsigned char **md_value)
{
	int md_value_len;

	md_value_len = EVP_MD_size(md);
	if (md_value_len < 0)
		goto err;
	if (input) {
		/* Digest must be computed from an input file. */
		EVP_MD_CTX md_ctx;
		unsigned char buffer[4096];
		int length;

		*md_value = malloc(md_value_len);
		if (*md_value == 0)
			goto err;

		EVP_DigestInit(&md_ctx, md);
		while ((length = BIO_read(input, buffer, sizeof(buffer))) > 0) {
			EVP_DigestUpdate(&md_ctx, buffer, length);
		}
		EVP_DigestFinal(&md_ctx, *md_value, NULL);
	} else {
		/* Digest bytes are specified with digest. */
		long digest_len;
		*md_value = string_to_hex(digest, &digest_len);
		if (!*md_value || md_value_len != digest_len) {
			free(*md_value);
			*md_value = NULL;
			BIO_printf(bio_err, "bad digest, %d bytes "
			    "must be specified\n", md_value_len);
			goto err;
		}
	}

	return md_value_len;
err:
	return 0;
}

static ASN1_INTEGER *
create_nonce(int bits)
{
	unsigned char buf[20];
	ASN1_INTEGER *nonce = NULL;
	int len = (bits - 1) / 8 + 1;
	int i;

	/* Generating random byte sequence. */
	if (len > (int) sizeof(buf))
		goto err;
	if (RAND_bytes(buf, len) <= 0)
		goto err;

	/* Find the first non-zero byte and creating ASN1_INTEGER object. */
	for (i = 0; i < len && !buf[i]; ++i)
		;
	if (!(nonce = ASN1_INTEGER_new()))
		goto err;
	free(nonce->data);
	/* Allocate at least one byte. */
	nonce->length = len - i;
	if (!(nonce->data = malloc(nonce->length + 1)))
		goto err;
	memcpy(nonce->data, buf + i, nonce->length);

	return nonce;

err:
	BIO_printf(bio_err, "could not create nonce\n");
	ASN1_INTEGER_free(nonce);
	return NULL;
}
/*
 * Reply-related method definitions.
 */

static int
reply_command(CONF * conf, char *section, char *engine, char *queryfile,
    char *passin, char *inkey, char *signer, char *chain, const char *policy,
    char *in, int token_in, char *out, int token_out, int text)
{
	int ret = 0;
	TS_RESP *response = NULL;
	BIO *in_bio = NULL;
	BIO *query_bio = NULL;
	BIO *inkey_bio = NULL;
	BIO *signer_bio = NULL;
	BIO *out_bio = NULL;

	/* Build response object either from response or query. */
	if (in != NULL) {
		if ((in_bio = BIO_new_file(in, "rb")) == NULL)
			goto end;
		if (token_in) {
			/*
			 * We have a ContentInfo (PKCS7) object, add
			 * 'granted' status info around it.
			 */
			response = read_PKCS7(in_bio);
		} else {
			/* We have a ready-made TS_RESP object. */
			response = d2i_TS_RESP_bio(in_bio, NULL);
		}
	} else {
		response = create_response(conf, section, engine, queryfile,
		    passin, inkey, signer, chain,
		    policy);
		if (response)
			BIO_printf(bio_err, "Response has been generated.\n");
		else
			BIO_printf(bio_err, "Response is not generated.\n");
	}
	if (response == NULL)
		goto end;

	/* Write response either in ASN.1 or text format. */
	if ((out_bio = BIO_open_with_default(out, "wb", stdout)) == NULL)
		goto end;
	if (text) {
		/* Text output. */
		if (token_out) {
			TS_TST_INFO *tst_info = TS_RESP_get_tst_info(response);
			if (!TS_TST_INFO_print_bio(out_bio, tst_info))
				goto end;
		} else {
			if (!TS_RESP_print_bio(out_bio, response))
				goto end;
		}
	} else {
		/* ASN.1 DER output. */
		if (token_out) {
			PKCS7 *token = TS_RESP_get_token(response);
			if (!i2d_PKCS7_bio(out_bio, token))
				goto end;
		} else {
			if (!i2d_TS_RESP_bio(out_bio, response))
				goto end;
		}
	}

	ret = 1;

end:
	ERR_print_errors(bio_err);

	/* Clean up. */
	BIO_free_all(in_bio);
	BIO_free_all(query_bio);
	BIO_free_all(inkey_bio);
	BIO_free_all(signer_bio);
	BIO_free_all(out_bio);
	TS_RESP_free(response);

	return ret;
}

/* Reads a PKCS7 token and adds default 'granted' status info to it. */
static TS_RESP *
read_PKCS7(BIO * in_bio)
{
	int ret = 0;
	PKCS7 *token = NULL;
	TS_TST_INFO *tst_info = NULL;
	TS_RESP *resp = NULL;
	TS_STATUS_INFO *si = NULL;

	/* Read PKCS7 object and extract the signed time stamp info. */
	if (!(token = d2i_PKCS7_bio(in_bio, NULL)))
		goto end;
	if (!(tst_info = PKCS7_to_TS_TST_INFO(token)))
		goto end;

	/* Creating response object. */
	if (!(resp = TS_RESP_new()))
		goto end;

	/* Create granted status info. */
	if (!(si = TS_STATUS_INFO_new()))
		goto end;
	if (!(ASN1_INTEGER_set(si->status, TS_STATUS_GRANTED)))
		goto end;
	if (!TS_RESP_set_status_info(resp, si))
		goto end;

	/* Setting encapsulated token. */
	TS_RESP_set_tst_info(resp, token, tst_info);
	token = NULL;		/* Ownership is lost. */
	tst_info = NULL;	/* Ownership is lost. */

	ret = 1;
end:
	PKCS7_free(token);
	TS_TST_INFO_free(tst_info);
	if (!ret) {
		TS_RESP_free(resp);
		resp = NULL;
	}
	TS_STATUS_INFO_free(si);
	return resp;
}

static TS_RESP *
create_response(CONF * conf, const char *section, char *engine,
    char *queryfile, char *passin, char *inkey,
    char *signer, char *chain, const char *policy)
{
	int ret = 0;
	TS_RESP *response = NULL;
	BIO *query_bio = NULL;
	TS_RESP_CTX *resp_ctx = NULL;

	if (!(query_bio = BIO_new_file(queryfile, "rb")))
		goto end;

	/* Getting TSA configuration section. */
	if (!(section = TS_CONF_get_tsa_section(conf, section)))
		goto end;

	/* Setting up response generation context. */
	if (!(resp_ctx = TS_RESP_CTX_new()))
		goto end;

	/* Setting serial number provider callback. */
	if (!TS_CONF_set_serial(conf, section, serial_cb, resp_ctx))
		goto end;
#ifndef OPENSSL_NO_ENGINE
	/* Setting default OpenSSL engine. */
	if (!TS_CONF_set_crypto_device(conf, section, engine))
		goto end;
#endif

	/* Setting TSA signer certificate. */
	if (!TS_CONF_set_signer_cert(conf, section, signer, resp_ctx))
		goto end;

	/* Setting TSA signer certificate chain. */
	if (!TS_CONF_set_certs(conf, section, chain, resp_ctx))
		goto end;

	/* Setting TSA signer private key. */
	if (!TS_CONF_set_signer_key(conf, section, inkey, passin, resp_ctx))
		goto end;

	/* Setting default policy OID. */
	if (!TS_CONF_set_def_policy(conf, section, policy, resp_ctx))
		goto end;

	/* Setting acceptable policy OIDs. */
	if (!TS_CONF_set_policies(conf, section, resp_ctx))
		goto end;

	/* Setting the acceptable one-way hash algorithms. */
	if (!TS_CONF_set_digests(conf, section, resp_ctx))
		goto end;

	/* Setting guaranteed time stamp accuracy. */
	if (!TS_CONF_set_accuracy(conf, section, resp_ctx))
		goto end;

	/* Setting the precision of the time. */
	if (!TS_CONF_set_clock_precision_digits(conf, section, resp_ctx))
		goto end;

	/* Setting the ordering flaf if requested. */
	if (!TS_CONF_set_ordering(conf, section, resp_ctx))
		goto end;

	/* Setting the TSA name required flag if requested. */
	if (!TS_CONF_set_tsa_name(conf, section, resp_ctx))
		goto end;

	/* Setting the ESS cert id chain flag if requested. */
	if (!TS_CONF_set_ess_cert_id_chain(conf, section, resp_ctx))
		goto end;

	/* Creating the response. */
	if (!(response = TS_RESP_create_response(resp_ctx, query_bio)))
		goto end;

	ret = 1;
end:
	if (!ret) {
		TS_RESP_free(response);
		response = NULL;
	}
	TS_RESP_CTX_free(resp_ctx);
	BIO_free_all(query_bio);

	return response;
}

static ASN1_INTEGER *
serial_cb(TS_RESP_CTX * ctx, void *data)
{
	const char *serial_file = (const char *) data;
	ASN1_INTEGER *serial = next_serial(serial_file);

	if (!serial) {
		TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
		    "Error during serial number "
		    "generation.");
		TS_RESP_CTX_add_failure_info(ctx,
		    TS_INFO_ADD_INFO_NOT_AVAILABLE);
	} else
		save_ts_serial(serial_file, serial);

	return serial;
}

static ASN1_INTEGER *
next_serial(const char *serialfile)
{
	int ret = 0;
	BIO *in = NULL;
	ASN1_INTEGER *serial = NULL;
	BIGNUM *bn = NULL;

	if (!(serial = ASN1_INTEGER_new()))
		goto err;

	if (!(in = BIO_new_file(serialfile, "r"))) {
		ERR_clear_error();
		BIO_printf(bio_err, "Warning: could not open file %s for "
		    "reading, using serial number: 1\n", serialfile);
		if (!ASN1_INTEGER_set(serial, 1))
			goto err;
	} else {
		char buf[1024];
		if (!a2i_ASN1_INTEGER(in, serial, buf, sizeof(buf))) {
			BIO_printf(bio_err, "unable to load number from %s\n",
			    serialfile);
			goto err;
		}
		if (!(bn = ASN1_INTEGER_to_BN(serial, NULL)))
			goto err;
		ASN1_INTEGER_free(serial);
		serial = NULL;
		if (!BN_add_word(bn, 1))
			goto err;
		if (!(serial = BN_to_ASN1_INTEGER(bn, NULL)))
			goto err;
	}
	ret = 1;
err:
	if (!ret) {
		ASN1_INTEGER_free(serial);
		serial = NULL;
	}
	BIO_free_all(in);
	BN_free(bn);
	return serial;
}

static int
save_ts_serial(const char *serialfile, ASN1_INTEGER * serial)
{
	int ret = 0;
	BIO *out = NULL;

	if (!(out = BIO_new_file(serialfile, "w")))
		goto err;
	if (i2a_ASN1_INTEGER(out, serial) <= 0)
		goto err;
	if (BIO_puts(out, "\n") <= 0)
		goto err;
	ret = 1;
err:
	if (!ret)
		BIO_printf(bio_err, "could not save serial number to %s\n",
		    serialfile);
	BIO_free_all(out);
	return ret;
}

/*
 * Verify-related method definitions.
 */

static int
verify_command(char *data, char *digest, char *queryfile, char *in,
    int token_in, char *ca_path, char *ca_file, char *untrusted)
{
	BIO *in_bio = NULL;
	PKCS7 *token = NULL;
	TS_RESP *response = NULL;
	TS_VERIFY_CTX *verify_ctx = NULL;
	int ret = 0;

	/* Decode the token (PKCS7) or response (TS_RESP) files. */
	if (!(in_bio = BIO_new_file(in, "rb")))
		goto end;
	if (token_in) {
		if (!(token = d2i_PKCS7_bio(in_bio, NULL)))
			goto end;
	} else {
		if (!(response = d2i_TS_RESP_bio(in_bio, NULL)))
			goto end;
	}

	if (!(verify_ctx = create_verify_ctx(data, digest, queryfile,
	    ca_path, ca_file, untrusted)))
		goto end;

	/* Checking the token or response against the request. */
	ret = token_in ?
	    TS_RESP_verify_token(verify_ctx, token) :
	    TS_RESP_verify_response(verify_ctx, response);

end:
	printf("Verification: ");
	if (ret)
		printf("OK\n");
	else {
		printf("FAILED\n");
		/* Print errors, if there are any. */
		ERR_print_errors(bio_err);
	}

	/* Clean up. */
	BIO_free_all(in_bio);
	PKCS7_free(token);
	TS_RESP_free(response);
	TS_VERIFY_CTX_free(verify_ctx);
	return ret;
}

static TS_VERIFY_CTX *
create_verify_ctx(char *data, char *digest, char *queryfile, char *ca_path,
    char *ca_file, char *untrusted)
{
	TS_VERIFY_CTX *ctx = NULL;
	BIO *input = NULL;
	TS_REQ *request = NULL;
	int ret = 0;

	if (data != NULL || digest != NULL) {
		if (!(ctx = TS_VERIFY_CTX_new()))
			goto err;
		ctx->flags = TS_VFY_VERSION | TS_VFY_SIGNER;
		if (data != NULL) {
			ctx->flags |= TS_VFY_DATA;
			if (!(ctx->data = BIO_new_file(data, "rb")))
				goto err;
		} else if (digest != NULL) {
			long imprint_len;
			ctx->flags |= TS_VFY_IMPRINT;
			if (!(ctx->imprint = string_to_hex(digest,
				    &imprint_len))) {
				BIO_printf(bio_err, "invalid digest string\n");
				goto err;
			}
			ctx->imprint_len = imprint_len;
		}
	} else if (queryfile != NULL) {
		/*
		 * The request has just to be read, decoded and converted to
		 * a verify context object.
		 */
		if (!(input = BIO_new_file(queryfile, "rb")))
			goto err;
		if (!(request = d2i_TS_REQ_bio(input, NULL)))
			goto err;
		if (!(ctx = TS_REQ_to_TS_VERIFY_CTX(request, NULL)))
			goto err;
	} else
		return NULL;

	/* Add the signature verification flag and arguments. */
	ctx->flags |= TS_VFY_SIGNATURE;

	/* Initialising the X509_STORE object. */
	if (!(ctx->store = create_cert_store(ca_path, ca_file)))
		goto err;

	/* Loading untrusted certificates. */
	if (untrusted && !(ctx->certs = TS_CONF_load_certs(untrusted)))
		goto err;

	ret = 1;
err:
	if (!ret) {
		TS_VERIFY_CTX_free(ctx);
		ctx = NULL;
	}
	BIO_free_all(input);
	TS_REQ_free(request);
	return ctx;
}

static X509_STORE *
create_cert_store(char *ca_path, char *ca_file)
{
	X509_STORE *cert_ctx = NULL;
	X509_LOOKUP *lookup = NULL;
	int i;

	/* Creating the X509_STORE object. */
	cert_ctx = X509_STORE_new();

	/* Setting the callback for certificate chain verification. */
	X509_STORE_set_verify_cb(cert_ctx, verify_cb);

	/* Adding a trusted certificate directory source. */
	if (ca_path) {
		lookup = X509_STORE_add_lookup(cert_ctx,
		    X509_LOOKUP_hash_dir());
		if (lookup == NULL) {
			BIO_printf(bio_err, "memory allocation failure\n");
			goto err;
		}
		i = X509_LOOKUP_add_dir(lookup, ca_path, X509_FILETYPE_PEM);
		if (!i) {
			BIO_printf(bio_err, "Error loading directory %s\n",
			    ca_path);
			goto err;
		}
	}
	/* Adding a trusted certificate file source. */
	if (ca_file) {
		lookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_file());
		if (lookup == NULL) {
			BIO_printf(bio_err, "memory allocation failure\n");
			goto err;
		}
		i = X509_LOOKUP_load_file(lookup, ca_file, X509_FILETYPE_PEM);
		if (!i) {
			BIO_printf(bio_err, "Error loading file %s\n", ca_file);
			goto err;
		}
	}
	return cert_ctx;
err:
	X509_STORE_free(cert_ctx);
	return NULL;
}

static int
verify_cb(int ok, X509_STORE_CTX * ctx)
{
	/*
	char buf[256];

	if (!ok)
		{
		X509_NAME_oneline(X509_get_subject_name(ctx->current_cert),
				  buf, sizeof(buf));
		printf("%s\n", buf);
		printf("error %d at %d depth lookup: %s\n",
		       ctx->error, ctx->error_depth,
			X509_verify_cert_error_string(ctx->error));
		}
	*/

	return ok;
}
@


1.18
log
@openssl(1) is only built as a single monolithic binary, so just call
load_config() once when we start.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ts.c,v 1.17 2014/06/12 15:49:27 deraadt Exp $ */
@


1.17
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a157 3

	if (!load_config(bio_err, NULL))
		goto cleanup;
@


1.16
log
@Stop pretending that openssl(1) applications support the -rand option.
The underlying code has long been removed, making this a no-op.

If your random subsystem actually requires that you seed it from a file,
then you really should go and buy a new random subsystem that was built
after 1990.

Diff from Brent Cook.

ok deraadt@@
@
text
@d1 1
a1 1
/* apps/ts.c */
@


1.15
log
@Calling signal once to ignore SIGPIPE is sufficient - we do not need to do
this again in each app.

ok miod@@
@
text
@a135 1
	char *rnd = NULL;
a182 4
		} else if (strcmp(*argv, "-rand") == 0) {
			if (argc-- < 1)
				goto usage;
			rnd = *++argv;
d313 1
a313 1
	    "ts -query [-rand file:file:...] [-config configfile] "
@


1.14
log
@It is perfectly valid to call free(NULL), so stop checking for non-NULL
before calling free - of some course parts of the code already did this.
@
text
@a159 2
	signal(SIGPIPE, SIG_IGN);

@


1.13
log
@Group and sort includes.

Currently "apps.h" needs to be included before any of the openssl headers
and there are several cases where the code depends on headers that are
included by something included by apps.h...

More untangling saved for later on.
@
text
@d551 1
@


1.12
log
@bio_err is initialised in main, hence there is no need to initialise it
in each application (since there is no longer a non-monolithic mode).

In typical OpenSSL fashion, the code is inconsistent and there are multiple
ways that bio_err was initialised - none of them actually checked to see if
the initialisation actually succeeded. Additionally, it is worth noting
that in at least two cases bio_err was also being used before it would have
been initialised.

ok miod@@
@
text
@d62 1
d64 1
d66 1
a70 2
#include <openssl/bn.h>

@


1.11
log
@When OPENSSL_C is not defined, apps_startup becomes a
signal(SIGPIPE, SIG_IGN) and apps_shutdown is a no-op. So just do that
instead.

ok beck@@
@
text
@a155 1
	int free_bio_err = 0;
d158 1
a160 4
	if (bio_err == NULL && (bio_err = BIO_new(BIO_s_file())) != NULL) {
		free_bio_err = 1;
		BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);
	}
d337 1
d343 1
a343 4
	if (free_bio_err) {
		BIO_free_all(bio_err);
		bio_err = NULL;
	}
@


1.10
log
@More KNF.
@
text
@d159 1
a159 1
	apps_startup();
@


1.9
log
@$HOME/.rnd will never be a good source of entropy. ok beck
@
text
@d122 1
a122 1
int 
d309 3
a311 4
		ret = !(((queryfile && !data && !digest)
			|| (!queryfile && data && !digest)
			|| (!queryfile && !data && digest))
		    && in != NULL);
d381 1
a381 1
		NCONF_load(conf, configfile, &errorline) <= 0)) {
d392 2
a393 1
		BIO_printf(bio_err, "Using configuration from %s\n", configfile);
d415 1
a415 1
static int 
d417 2
a418 2
    const char *policy, int no_nonce,
    int cert, const char *in, const char *out, int text)
d433 2
a434 2
		if (!digest
		    && !(data_bio = BIO_open_with_default(data, "rb", stdin)))
d472 1
a472 2
BIO_open_with_default(const char *file, const char *mode,
    FILE * default_fp)
d474 2
a475 3
	return file == NULL ?
	BIO_new_fp(default_fp, BIO_NOCLOSE)
	: BIO_new_file(file, mode);
d544 1
d559 1
a559 1
static int 
d616 2
a617 1
	for (i = 0; i < len && !buf[i]; ++i);
d628 1
d638 4
a641 6
static int 
reply_command(CONF * conf, char *section, char *engine,
    char *queryfile, char *passin, char *inkey,
    char *signer, char *chain, const char *policy,
    char *in, int token_in,
    char *out, int token_out, int text)
d915 1
a915 1
static int 
d940 3
a942 4
static int 
verify_command(char *data, char *digest, char *queryfile,
    char *in, int token_in,
    char *ca_path, char *ca_file, char *untrusted)
d962 1
a962 1
		    ca_path, ca_file, untrusted)))
d989 2
a990 4
create_verify_ctx(char *data, char *digest,
    char *queryfile,
    char *ca_path, char *ca_file,
    char *untrusted)
d1098 1
a1098 1
static int 
@


1.8
log
@simplify file:file:... stuff
@
text
@a264 9
	/* Seed the random number generator if it is going to be used. */
	if (mode == CMD_QUERY && !no_nonce) {
		if (!app_RAND_load_file(NULL, bio_err, 1) && rnd == NULL)
			BIO_printf(bio_err, "warning, not much extra random "
			    "data, consider using the -rand option\n");
		if (rnd != NULL)
			BIO_printf(bio_err, "%ld semi-random bytes loaded\n",
			    app_RAND_load_files(rnd));
	}
a343 1
	app_RAND_write_file(NULL, bio_err);
@


1.7
log
@whitespace normalization
@
text
@d333 1
a333 1
	    "ts -query [-rand file%cfile%c...] [-config configfile] "
d337 1
a337 2
	    "[-in request.tsq] [-out request.tsq] [-text]\n",
	    ':', ':');
@


1.6
log
@Remove MAIN and PROG defines now that we do not compile non-monolithic.

ok tedu@@
@
text
@d83 1
a83 2
static int 
query_command(const char *data, char *digest,
d86 1
a86 2
static BIO *
BIO_open_with_default(const char *file, const char *mode,
d88 1
a88 2
static TS_REQ *
create_query(BIO * data_bio, char *digest, const EVP_MD * md,
d90 1
a90 2
static int 
create_digest(BIO * input, char *digest,
d95 1
a95 2
static int 
reply_command(CONF * conf, char *section, char *engine,
d101 1
a101 2
static TS_RESP *
create_response(CONF * conf, const char *section, char *engine,
d109 1
a109 2
static int 
verify_command(char *data, char *digest, char *queryfile,
d112 1
a112 2
static TS_VERIFY_CTX *
create_verify_ctx(char *data, char *digest,
@


1.5
log
@KaboomNF
@
text
@a69 2
#undef PROG
#define PROG	ts_main
d128 1
a128 1
int MAIN(int, char **);
d131 1
a131 1
MAIN(int argc, char **argv)
@


1.4
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d85 13
a97 9
static int query_command(const char *data, char *digest,
			 const EVP_MD *md, const char *policy, int no_nonce, 
			 int cert, const char *in, const char *out, int text);
static BIO *BIO_open_with_default(const char *file, const char *mode, 
				  FILE *default_fp);
static TS_REQ *create_query(BIO *data_bio, char *digest, const EVP_MD *md,
			    const char *policy, int no_nonce, int cert);
static int create_digest(BIO *input, char *digest,
			 const EVP_MD *md, unsigned char **md_value);
d101 12
a112 10
static int reply_command(CONF *conf, char *section, char *engine, 
			 char *queryfile, char *passin, char *inkey, 
			 char *signer, char *chain, const char *policy, 
			 char *in, int token_in, char *out, int token_out,
			 int text);
static TS_RESP *read_PKCS7(BIO *in_bio);
static TS_RESP *create_response(CONF *conf, const char *section, char *engine,
				char *queryfile, char *passin, char *inkey,
				char *signer, char *chain, const char *policy);
static ASN1_INTEGER * serial_cb(TS_RESP_CTX *ctx, void *data);
d114 1
a114 1
static int save_ts_serial(const char *serialfile, ASN1_INTEGER *serial);
d117 9
a125 7
static int verify_command(char *data, char *digest, char *queryfile,
			  char *in, int token_in,
			  char *ca_path, char *ca_file, char *untrusted);
static TS_VERIFY_CTX *create_verify_ctx(char *data, char *digest, 
					char *queryfile, 
					char *ca_path, char *ca_file,
					char *untrusted);
d127 1
a127 1
static int verify_cb(int ok, X509_STORE_CTX *ctx);
d132 3
a134 2
int MAIN(int argc, char **argv)
	{
d140 1
a140 1
	CMD_NONE, CMD_QUERY, CMD_REPLY, CMD_VERIFY 
d154 1
a154 1
	char *password =NULL;	/* Password itself. */
d163 1
a163 1
	int token_in = 0;	
d171 1
a171 2
	if (bio_err == NULL && (bio_err = BIO_new(BIO_s_file())) != NULL)
		{
d174 1
a174 2
		}

d178 4
a181 5
	for (argc--, argv++; argc > 0; argc--, argv++)
		{
		if (strcmp(*argv, "-config") == 0)
			{
			if (argc-- < 1) goto usage;
d183 3
a185 4
			}
		else if (strcmp(*argv, "-section") == 0)
			{
			if (argc-- < 1) goto usage;
d187 3
a189 4
			}
		else if (strcmp(*argv, "-query") == 0)
			{
			if (mode != CMD_NONE) goto usage;
d191 3
a193 4
			}
		else if (strcmp(*argv, "-data") == 0)
			{
			if (argc-- < 1) goto usage;
d195 3
a197 4
			}
		else if (strcmp(*argv, "-digest") == 0)
			{
			if (argc-- < 1) goto usage;
d199 3
a201 4
			}
		else if (strcmp(*argv, "-rand") == 0)
			{
			if (argc-- < 1) goto usage;
d203 3
a205 4
			}
		else if (strcmp(*argv, "-policy") == 0)
			{
			if (argc-- < 1) goto usage;
d207 1
a207 3
			}
		else if (strcmp(*argv, "-no_nonce") == 0)
			{
d209 1
a209 3
			}
		else if (strcmp(*argv, "-cert") == 0)
			{
d211 3
a213 4
			}
		else if (strcmp(*argv, "-in") == 0)
			{
			if (argc-- < 1) goto usage;
d215 1
a215 3
			}
		else if (strcmp(*argv, "-token_in") == 0)
			{
d217 3
a219 4
			}
		else if (strcmp(*argv, "-out") == 0)
			{
			if (argc-- < 1) goto usage;
d221 1
a221 3
			}
		else if (strcmp(*argv, "-token_out") == 0)
			{
d223 1
a223 3
			}
		else if (strcmp(*argv, "-text") == 0)
			{
d225 3
a227 4
			}
		else if (strcmp(*argv, "-reply") == 0)
			{
			if (mode != CMD_NONE) goto usage;
d229 3
a231 4
			}
		else if (strcmp(*argv, "-queryfile") == 0)
			{
			if (argc-- < 1) goto usage;
d233 3
a235 4
			}
		else if (strcmp(*argv, "-passin") == 0)
			{
			if (argc-- < 1) goto usage;
d237 3
a239 4
			}
		else if (strcmp(*argv, "-inkey") == 0)
			{
			if (argc-- < 1) goto usage;
d241 3
a243 4
			}
		else if (strcmp(*argv, "-signer") == 0)
			{
			if (argc-- < 1) goto usage;
d245 3
a247 4
			}
		else if (strcmp(*argv, "-chain") == 0)
			{
			if (argc-- < 1) goto usage;
d249 3
a251 4
			}
		else if (strcmp(*argv, "-verify") == 0)
			{
			if (mode != CMD_NONE) goto usage;
d253 3
a255 4
			}
		else if (strcmp(*argv, "-CApath") == 0)
			{
			if (argc-- < 1) goto usage;
d257 3
a259 4
			}
		else if (strcmp(*argv, "-CAfile") == 0)
			{
			if (argc-- < 1) goto usage;
d261 3
a263 4
			}
		else if (strcmp(*argv, "-untrusted") == 0)
			{
			if (argc-- < 1) goto usage;
d265 3
a267 4
			}
		else if (strcmp(*argv, "-engine") == 0)
			{
			if (argc-- < 1) goto usage;
d269 1
a269 3
			}
		else if ((md = EVP_get_digestbyname(*argv + 1)) != NULL)
			{
d271 1
a271 2
			}
		else
d273 2
a274 2
		}
	
d276 1
a276 2
	if (mode == CMD_QUERY && !no_nonce)
		{
d279 1
a279 1
				   "data, consider using the -rand option\n");
d281 3
a283 4
			BIO_printf(bio_err,"%ld semi-random bytes loaded\n",
				   app_RAND_load_files(rnd));
		}

d285 3
a287 4
	if(mode == CMD_REPLY && passin &&
	   !app_passwd(bio_err, passin, NULL, &password, NULL))
		{
		BIO_printf(bio_err,"Error getting password.\n");
d289 6
a294 6
		}

	/* Check consistency of parameters and execute 
	   the appropriate function. */
	switch (mode)
		{
d298 4
a301 2
		/* Data file and message imprint cannot be specified
		   at the same time. */
d303 2
a304 1
		if (ret) goto usage;
d308 1
a308 1
				     in, out, text);
d312 1
a312 2
		if (in == NULL)
			{
d314 3
a316 4
			if (ret) goto usage;
			}
		else
			{
d319 3
a321 2
			if (ret) goto usage;
			}
d323 3
a325 3
		ret = !reply_command(conf, section, engine, queryfile, 
				     password, inkey, signer, chain, policy, 
				     in, token_in, out, token_out, text);
d329 5
a333 4
			 || (!queryfile && data && !digest)
			 || (!queryfile && !data && digest))
			&& in != NULL);
		if (ret) goto usage;
d336 2
a337 2
				      ca_path, ca_file, untrusted);
		}
d341 1
a341 1
 usage:
d343 6
a348 6
		   "ts -query [-rand file%cfile%c...] [-config configfile] "
		   "[-data file_to_hash] [-digest digest_bytes]"
		   "[-md2|-md4|-md5|-sha|-sha1|-mdc2|-ripemd160] "
		   "[-policy object_id] [-no_nonce] [-cert] "
		   "[-in request.tsq] [-out request.tsq] [-text]\n",
		   ':', ':');
d350 6
a355 6
		   "ts -reply [-config configfile] [-section tsa_section] "
		   "[-queryfile request.tsq] [-passin password] "
		   "[-signer tsa_cert.pem] [-inkey private_key.pem] "
		   "[-chain certs_file.pem] [-policy object_id] "
		   "[-in response.tsr] [-token_in] "
		   "[-out response.tsr] [-token_out] [-text] [-engine id]\n");
d357 6
a362 6
		   "ts -verify [-data file_to_hash] [-digest digest_bytes] "
		   "[-queryfile request.tsq] "
		   "-in response.tsr [-token_in] "
		   "-CApath ca_path -CAfile ca_file.pem "
		   "-untrusted cert_file.pem\n");
 cleanup:
d368 1
a368 2
	if (free_bio_err)
		{
a370 3
		}

	return(ret);
d372 2
d379 3
a381 2
static ASN1_OBJECT *txt2obj(const char *oid)
	{
d388 1
a388 1
	}
d390 3
a392 2
static CONF *load_config_file(const char *configfile)
	{
d396 4
a399 2
	if (!configfile) configfile = getenv("OPENSSL_CONF");
	if (!configfile) configfile = getenv("SSLEAY_CONF");
d403 1
a403 2
	     NCONF_load(conf, configfile, &errorline) <= 0))
		{
d406 1
a406 1
				   "'%s'\n", configfile);
d409 3
a411 5
				   "'%s'\n", errorline, configfile);
		}

	if (conf != NULL)
		{
d414 1
a414 1
		BIO_printf(bio_err,"Using configuration from %s\n", configfile);
d416 1
a416 2
		if (p != NULL)
			{
d418 1
a418 1
			if (!oid_bio) 
d420 1
a420 2
			else
				{
a422 1
				}
d424 1
a424 1
		else
d426 1
a426 1
		if(!add_oid_section(bio_err, conf)) 
d428 1
a428 1
		}
d430 1
a430 1
	}
d436 5
a440 4
static int query_command(const char *data, char *digest, const EVP_MD *md,
			 const char *policy, int no_nonce, 
			 int cert, const char *in, const char *out, int text)
	{
d448 3
a450 3
	if (in != NULL)
		{
		if ((in_bio = BIO_new_file(in, "rb")) == NULL) goto end;
d452 1
a452 3
		}
	else
		{
d454 1
a454 1
		if (!digest 
d459 1
a459 1
				     policy, no_nonce, cert);
d461 3
a463 2
		}
	if (query == NULL) goto end;
d468 1
a468 2
	if (text)
		{
d472 1
a472 3
		}
	else
		{
d476 1
a476 1
		}
d480 1
a480 1
 end:
d490 1
a490 9
	}

static BIO *BIO_open_with_default(const char *file, const char *mode, 
				  FILE *default_fp)
	{
	return file == NULL ? 
		BIO_new_fp(default_fp, BIO_NOCLOSE) 
		: BIO_new_file(file, mode);
	}
d492 13
a504 3
static TS_REQ *create_query(BIO *data_bio, char *digest, const EVP_MD *md,
			    const char *policy, int no_nonce, int cert)
	{
d515 2
a516 1
	if (!md && !(md = EVP_get_digestbyname("sha1"))) goto err;
d519 2
a520 1
	if (!(ts_req = TS_REQ_new())) goto err;
d523 2
a524 1
	if (!TS_REQ_set_version(ts_req, 1)) goto err;
d527 2
a528 1
	if (!(msg_imprint = TS_MSG_IMPRINT_new())) goto err;
d531 6
a536 3
	if (!(algo = X509_ALGOR_new())) goto err;
	if (!(algo->algorithm = OBJ_nid2obj(EVP_MD_type(md)))) goto err;
	if (!(algo->parameter = ASN1_TYPE_new())) goto err;
d538 2
a539 1
	if (!TS_MSG_IMPRINT_set_algo(msg_imprint, algo)) goto err;
d544 5
a548 1
	if (!TS_MSG_IMPRINT_set_msg(msg_imprint, data, len)) goto err;
a549 2
	if (!TS_REQ_set_msg_imprint(ts_req, msg_imprint)) goto err;
	
d551 4
a554 2
	if (policy && !(policy_obj = txt2obj(policy))) goto err;
	if (policy_obj && !TS_REQ_set_policy_id(ts_req, policy_obj)) goto err;
d557 4
a560 2
	if (!no_nonce && !(nonce_asn1 = create_nonce(NONCE_LENGTH))) goto err;
	if (nonce_asn1 && !TS_REQ_set_nonce(ts_req, nonce_asn1)) goto err;
d563 2
a564 1
	if (!TS_REQ_set_cert_req(ts_req, cert)) goto err;
d567 2
a568 3
 err:
	if (!ret)
		{
d572 1
a572 1
		}
d579 1
a579 1
	}
d581 4
a584 3
static int create_digest(BIO *input, char *digest, const EVP_MD *md,
			 unsigned char **md_value)
	{
d589 2
a590 3
	    goto err;
	if (input)
		{
d597 2
a598 1
		if (*md_value == 0) goto err;
d601 1
a601 2
		while ((length = BIO_read(input, buffer, sizeof(buffer))) > 0)
			{
d603 1
a603 1
			}
d605 1
a605 3
		}
	else
		{
d609 1
a609 2
		if (!*md_value || md_value_len != digest_len)
			{
d613 1
a613 1
				   "must be specified\n", md_value_len);
a614 1
			}
d616 1
d619 1
a619 1
 err:
d621 1
a621 1
	}
d623 3
a625 2
static ASN1_INTEGER *create_nonce(int bits)
	{
d632 4
a635 2
	if (len > (int)sizeof(buf)) goto err;
	if (RAND_bytes(buf, len) <= 0) goto err;
d639 2
a640 1
	if (!(nonce = ASN1_INTEGER_new())) goto err;
d644 2
a645 1
	if (!(nonce->data = malloc(nonce->length + 1))) goto err;
d649 1
a649 1
 err:
d653 1
a653 1
	}
d658 7
a664 6
static int reply_command(CONF *conf, char *section, char *engine, 
			 char *queryfile, char *passin, char *inkey,
			 char *signer, char *chain, const char *policy, 
			 char *in, int token_in,
			 char *out, int token_out, int text)
	{
d674 8
a681 7
	if (in != NULL)
		{
		if ((in_bio = BIO_new_file(in, "rb")) == NULL) goto end;
		if (token_in)
			{
			/* We have a ContentInfo (PKCS7) object, add
			   'granted' status info around it. */
d683 1
a683 3
			}
		else
			{
a685 1
			}
d687 1
a687 2
	else
		{
d689 2
a690 2
					   passin, inkey, signer, chain,
					   policy);
d695 3
a697 2
		}
	if (response == NULL) goto end;
d702 1
a702 2
	if (text)
		{
d704 1
a704 2
		if (token_out)
			{
d706 5
a710 6
			if (!TS_TST_INFO_print_bio(out_bio, tst_info)) goto end;
			}
		else
			{
			if (!TS_RESP_print_bio(out_bio, response)) goto end;
			}
d712 1
a712 2
	else
		{
d714 1
a714 2
		if (token_out)
			{
d716 5
a720 6
			if (!i2d_PKCS7_bio(out_bio, token)) goto end;
			}
		else
			{
			if (!i2d_TS_RESP_bio(out_bio, response)) goto end;
			}
d722 1
d726 1
a726 1
 end:
d738 1
a738 1
	}
d741 3
a743 2
static TS_RESP *read_PKCS7(BIO *in_bio)
	{
d751 4
a754 2
	if (!(token = d2i_PKCS7_bio(in_bio, NULL))) goto end;
	if (!(tst_info = PKCS7_to_TS_TST_INFO(token))) goto end;
d757 2
a758 1
	if (!(resp = TS_RESP_new())) goto end;
d761 6
a766 3
	if (!(si = TS_STATUS_INFO_new())) goto end;
	if (!(ASN1_INTEGER_set(si->status, TS_STATUS_GRANTED))) goto end;
	if (!TS_RESP_set_status_info(resp, si)) goto end;
d774 1
a774 1
 end:
d777 1
a777 2
	if (!ret)
		{
d780 1
a780 1
		}
d783 1
a783 1
	}
d785 5
a789 4
static TS_RESP *create_response(CONF *conf, const char *section, char *engine, 
				char *queryfile, char *passin, char *inkey,
				char *signer, char *chain, const char *policy)
	{
d803 2
a804 1
	if (!(resp_ctx = TS_RESP_CTX_new())) goto end;
d807 2
a808 1
	if (!TS_CONF_set_serial(conf, section, serial_cb, resp_ctx)) goto end;
d811 2
a812 1
	if (!TS_CONF_set_crypto_device(conf, section, engine)) goto end;
d816 2
a817 1
	if (!TS_CONF_set_signer_cert(conf, section, signer, resp_ctx)) goto end;
d820 2
a821 1
	if (!TS_CONF_set_certs(conf, section, chain, resp_ctx)) goto end;
d828 2
a829 1
	if (!TS_CONF_set_def_policy(conf, section, policy, resp_ctx)) goto end;
d832 2
a833 1
	if (!TS_CONF_set_policies(conf, section, resp_ctx)) goto end;
d836 2
a837 1
	if (!TS_CONF_set_digests(conf, section, resp_ctx)) goto end;
d840 2
a841 1
	if (!TS_CONF_set_accuracy(conf, section, resp_ctx)) goto end;
d848 2
a849 1
	if (!TS_CONF_set_ordering(conf, section, resp_ctx)) goto end;
d852 2
a853 1
	if (!TS_CONF_set_tsa_name(conf, section, resp_ctx)) goto end;
d856 2
a857 1
	if (!TS_CONF_set_ess_cert_id_chain(conf, section, resp_ctx)) goto end;
d864 2
a865 3
 end:
	if (!ret) 
		{
d868 1
a868 1
		}
d873 1
a873 1
	}
d875 3
a877 2
static ASN1_INTEGER * serial_cb(TS_RESP_CTX *ctx, void *data)
	{
d881 1
a881 2
	if (!serial)
		{
d883 2
a884 2
					    "Error during serial number "
					    "generation.");
d886 2
a887 3
					     TS_INFO_ADD_INFO_NOT_AVAILABLE);
		}
	else
d891 1
a891 1
	}
d893 3
a895 2
static ASN1_INTEGER *next_serial(const char *serialfile)
	{
d901 2
a902 1
	if (!(serial = ASN1_INTEGER_new())) goto err;
d904 1
a904 2
	if (!(in = BIO_new_file(serialfile, "r"))) 
		{
d907 4
a910 5
			   "reading, using serial number: 1\n", serialfile);
		if (!ASN1_INTEGER_set(serial, 1)) goto err;
		}
	else
		{
d912 1
a912 2
		if (!a2i_ASN1_INTEGER(in, serial, buf, sizeof(buf)))
			{
d914 4
a917 1
				   serialfile);
a918 2
			}
		if (!(bn = ASN1_INTEGER_to_BN(serial, NULL))) goto err;
d921 5
a925 3
		if (!BN_add_word(bn, 1)) goto err;
		if (!(serial = BN_to_ASN1_INTEGER(bn, NULL))) goto err;
		}
d927 2
a928 3
 err:
	if (!ret)
		{
d931 1
a931 1
		}
d935 1
a935 1
	}
d937 3
a939 2
static int save_ts_serial(const char *serialfile, ASN1_INTEGER *serial)
	{
d943 6
a948 3
	if (!(out = BIO_new_file(serialfile, "w"))) goto err;
	if (i2a_ASN1_INTEGER(out, serial) <= 0) goto err;
	if (BIO_puts(out, "\n") <= 0) goto err;
d950 1
a950 1
 err:
d953 1
a953 1
			   serialfile);
d956 1
a956 1
	}
d962 5
a966 4
static int verify_command(char *data, char *digest, char *queryfile,
			  char *in, int token_in,
			  char *ca_path, char *ca_file, char *untrusted)
	{
d974 9
a982 9
	if (!(in_bio = BIO_new_file(in, "rb"))) goto end;
	if (token_in)
		{
		if (!(token = d2i_PKCS7_bio(in_bio, NULL))) goto end;
		}
	else
		{
		if (!(response = d2i_TS_RESP_bio(in_bio, NULL))) goto end;
		}
d984 2
a985 2
	if (!(verify_ctx = create_verify_ctx(data, digest, queryfile, 
					     ca_path, ca_file, untrusted)))
d990 2
a991 2
		TS_RESP_verify_token(verify_ctx, token) :
		TS_RESP_verify_response(verify_ctx, response);
d993 1
a993 1
 end:
d997 1
a997 2
	else
		{
d1001 2
a1002 2
		}
	
d1009 1
a1009 1
	}
d1011 6
a1016 5
static TS_VERIFY_CTX *create_verify_ctx(char *data, char *digest, 
					char *queryfile, 
					char *ca_path, char *ca_file,
					char *untrusted)
	{
d1022 3
a1024 3
	if (data != NULL || digest != NULL)
		{
		if (!(ctx = TS_VERIFY_CTX_new())) goto err;
d1026 1
a1026 2
		if (data != NULL)
			{
d1028 3
a1030 4
			if (!(ctx->data = BIO_new_file(data, "rb"))) goto err;
			}
		else if (digest != NULL)
			{
d1034 1
a1034 2
							   &imprint_len)))
				{
d1037 1
a1037 1
				}
a1038 2
			}
		
d1040 12
a1051 9
	else if (queryfile != NULL)
		{
		/* The request has just to be read, decoded and converted to
		   a verify context object. */
		if (!(input = BIO_new_file(queryfile, "rb"))) goto err;
		if (!(request = d2i_TS_REQ_bio(input, NULL))) goto err;
		if (!(ctx = TS_REQ_to_TS_VERIFY_CTX(request, NULL))) goto err;
		}
	else
d1058 2
a1059 1
	if (!(ctx->store = create_cert_store(ca_path, ca_file))) goto err;
d1062 1
a1062 1
	if (untrusted && !(ctx->certs = TS_CONF_load_certs(untrusted))) 
d1066 2
a1067 3
 err:
	if (!ret)
		{
d1070 1
a1070 1
		}
d1074 1
a1074 1
	}
d1076 3
a1078 2
static X509_STORE *create_cert_store(char *ca_path, char *ca_file)
	{
d1090 1
a1090 2
	if (ca_path)
		{
d1092 2
a1093 3
					       X509_LOOKUP_hash_dir());
		if (lookup == NULL)
			{
d1096 1
a1096 1
			}
d1098 1
a1098 2
		if (!i)
			{
d1100 1
a1100 1
				   ca_path);
a1101 1
			}
d1103 1
a1103 1

d1105 1
a1105 2
	if (ca_file)
		{
d1107 1
a1107 2
		if (lookup == NULL)
			{
d1110 1
a1110 1
			}
d1112 1
a1112 2
		if (!i)
			{
a1114 1
			}
d1116 1
a1116 1

d1118 1
a1118 1
 err:
d1121 1
a1121 1
	}
d1123 3
a1125 2
static int verify_cb(int ok, X509_STORE_CTX *ctx)
	{
d1141 1
a1141 1
	}
@


1.3
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d374 1
a374 1
		   LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);
d400 1
a400 1
	OPENSSL_EXIT(ret);
@


1.2
log
@remove more cases of MS_STATIC, MS_CALLBACK, and MS_FAR.  Did you
know that MS_STATIC doesn't mean it is static?  How far can lies
and half-truths be layered?  I wonder if anyone got fooled, and
actually returned a pointer..
ok beck
@
text
@d392 1
a392 1
	OPENSSL_free(password);
d592 1
a592 1
	OPENSSL_free(data);
d613 1
a613 1
		*md_value = OPENSSL_malloc(md_value_len);
d630 1
a630 1
			OPENSSL_free(*md_value);
d657 1
a657 1
	OPENSSL_free(nonce->data);
d660 1
a660 1
	if (!(nonce->data = OPENSSL_malloc(nonce->length + 1))) goto err;
@


1.1
log
@Initial revision
@
text
@d106 1
a106 1
static ASN1_INTEGER * MS_CALLBACK serial_cb(TS_RESP_CTX *ctx, void *data);
d119 1
a119 1
static int MS_CALLBACK verify_cb(int ok, X509_STORE_CTX *ctx);
d168 3
d652 1
a652 1
	if (!RAND_bytes(buf, len)) goto err;
d878 1
a878 1
static ASN1_INTEGER * MS_CALLBACK serial_cb(TS_RESP_CTX *ctx, void *data)
d1086 1
a1086 1
	X509_STORE_set_verify_cb_func(cert_ctx, verify_cb);
d1130 1
a1130 1
static int MS_CALLBACK verify_cb(int ok, X509_STORE_CTX *ctx)
@


1.1.1.1
log
@import of OpenSSL 0.9.8k
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.0a
@
text
@a167 3
	if (!load_config(bio_err, NULL))
		goto cleanup;

d649 1
a649 1
	if (RAND_bytes(buf, len) <= 0) goto err;
d1083 1
a1083 1
	X509_STORE_set_verify_cb(cert_ctx, verify_cb);
@

