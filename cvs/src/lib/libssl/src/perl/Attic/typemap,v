head	1.3;
access;
symbols
	OPENBSD_3_1:1.2.0.12
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.10
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.8
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2002.09.03.10.49.48;	author markus;	state dead;
branches;
next	1.2;

1.2
date	99.09.29.04.37.23;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.30;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.30;	author ryker;	state Exp;
branches;
next	;


desc
@@


1.3
log
@unused files, perl subdir not part of OpenSSL 0.9.7
@
text
@
datum			T_DATUM
EVP_MD_CTX *		T_MD_CTX
EVP_CIPHER_CTX *	T_CIPHER_CTX
BIGNUM *		T_BIGNUM
SSL_METHOD *		T_SSL_METHOD
SSL_CTX *		T_SSL_CTX
SSL_CIPHER *		T_SSL_CIPHER
SSL *			T_SSL
BIO *			T_BIO
X509 *			T_X509

INPUT
T_DATUM
	$var.dptr=SvPV($arg,$var.dsize);
T_MD_CTX
	if (sv_derived_from($arg, \"OpenSSL::MD\")) {
		IV tmp = SvIV((SV*)SvRV($arg));
		$var = (EVP_MD_CTX *) tmp;
		}
	else
		croak(\"$var is not of type OpenSSL::MD\")
T_CIPHER_CTX
	if (sv_derived_from($arg, \"OpenSSL::Cipher\")) {
		IV tmp = SvIV((SV*)SvRV($arg));
		$var = (EVP_CIPHER_CTX *) tmp;
		}
	else
		croak(\"$var is not of type OpenSSL::Cipher\")
T_BIGNUM
	sv_to_BIGNUM(&($var),$arg,\"$var is not of type OpenSSL::MD, int or string\")
T_SSL_METHOD
	if (sv_derived_from($arg, \"OpenSSL::SSL::METHOD\")) {
		IV tmp = SvIV((SV*)SvRV($arg));
		$var = (SSL_METHOD *) tmp;
		}
	else
		croak(\"$var is not of type OpenSSL::SSL::METHOD\")
T_SSL_CTX
	if (sv_derived_from($arg, \"OpenSSL::SSL::CTX\")) {
		IV tmp = SvIV((SV*)SvRV($arg));
		$var = (SSL_CTX *) tmp;
		}
	else
		croak(\"$var is not of type OpenSSL::SSL::CTX\")
T_SSL_CIPHER
	if (sv_derived_from($arg, \"OpenSSL::SSL::CIPHER\")) {
		IV tmp = SvIV((SV*)SvRV($arg));
		$var = (SSL_CIPHER *) tmp;
		}
	else
		croak(\"$var is not of type OpenSSL::SSL::CIPHER\")
T_SSL
	if (sv_derived_from($arg, \"OpenSSL::SSL\")) {
		IV tmp = SvIV((SV*)SvRV($arg));
		$var = (SSL *) tmp;
		}
	else
		croak(\"$var is not of type OpenSSL::SSL\")
T_BIO
	if (sv_derived_from($arg, \"OpenSSL::BIO\")) {
		IV tmp = SvIV((SV*)SvRV($arg));
		$var = (BIO *) tmp;
		}
	else
		croak(\"$var is not of type OpenSSL::BIO\")
T_X509
	if (sv_derived_from($arg, \"OpenSSL::X509\")) {
		IV tmp = SvIV((SV*)SvRV($arg));
		$var = (X509 *) tmp;
		}
	else
		croak(\"$var is not of type OpenSSL::X509\")
OUTPUT
T_DATUM
	sv_setpvn($arg,$var.dptr,$var.dsize);
T_MD_CTX
	sv_setref_pv($arg, \"OpenSSL::MD\", (void*)$var);
T_CIPHER_CTX
	sv_setref_pv($arg, \"OpenSSL::Cipher\", (void*)$var);
T_BIGNUM
	sv_setref_pv($arg, \"OpenSSL::BN\", (void*)$var);
T_SSL_METHOD
	sv_setref_pv($arg, \"OpenSSL::SSL::METHOD\", (void*)$var);
T_SSL_CTX
	sv_setref_pv($arg, \"OpenSSL::SSL::CTX\", (void*)$var);
T_SSL_CIPHER
	sv_setref_pv($arg, \"OpenSSL::SSL::CIPHER\", (void*)$var);
T_SSL
	sv_setref_pv($arg, \"OpenSSL::SSL\", (void*)$var);
T_BIO
	sv_setref_pv($arg, \"OpenSSL::BIO\", (void*)$var);
T_X509
	sv_setref_pv($arg, \"OpenSSL::X509\", (void*)$var);


@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
	if (sv_derived_from($arg, \"SSLeay::MD\")) {
d22 1
a22 1
		croak(\"$var is not of type SSLeay::MD\")
d24 1
a24 1
	if (sv_derived_from($arg, \"SSLeay::Cipher\")) {
d29 1
a29 1
		croak(\"$var is not of type SSLeay::Cipher\")
d31 1
a31 1
	sv_to_BIGNUM(&($var),$arg,\"$var is not of type SSLeay::MD, int or string\")
d33 1
a33 1
	if (sv_derived_from($arg, \"SSLeay::SSL::METHOD\")) {
d38 1
a38 1
		croak(\"$var is not of type SSLeay::SSL::METHOD\")
d40 1
a40 1
	if (sv_derived_from($arg, \"SSLeay::SSL::CTX\")) {
d45 1
a45 1
		croak(\"$var is not of type SSLeay::SSL::CTX\")
d47 1
a47 1
	if (sv_derived_from($arg, \"SSLeay::SSL::CIPHER\")) {
d52 1
a52 1
		croak(\"$var is not of type SSLeay::SSL::CIPHER\")
d54 1
a54 1
	if (sv_derived_from($arg, \"SSLeay::SSL\")) {
d59 1
a59 1
		croak(\"$var is not of type SSLeay::SSL\")
d61 1
a61 1
	if (sv_derived_from($arg, \"SSLeay::BIO\")) {
d66 1
a66 1
		croak(\"$var is not of type SSLeay::BIO\")
d68 1
a68 1
	if (sv_derived_from($arg, \"SSLeay::X509\")) {
d73 1
a73 1
		croak(\"$var is not of type SSLeay::X509\")
d78 1
a78 1
	sv_setref_pv($arg, \"SSLeay::MD\", (void*)$var);
d80 1
a80 1
	sv_setref_pv($arg, \"SSLeay::Cipher\", (void*)$var);
d82 1
a82 1
	sv_setref_pv($arg, \"SSLeay::BN\", (void*)$var);
d84 1
a84 1
	sv_setref_pv($arg, \"SSLeay::SSL::METHOD\", (void*)$var);
d86 1
a86 1
	sv_setref_pv($arg, \"SSLeay::SSL::CTX\", (void*)$var);
d88 1
a88 1
	sv_setref_pv($arg, \"SSLeay::SSL::CIPHER\", (void*)$var);
d90 1
a90 1
	sv_setref_pv($arg, \"SSLeay::SSL\", (void*)$var);
d92 1
a92 1
	sv_setref_pv($arg, \"SSLeay::BIO\", (void*)$var);
d94 1
a94 1
	sv_setref_pv($arg, \"SSLeay::X509\", (void*)$var);
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@
