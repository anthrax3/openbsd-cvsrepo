head	1.71;
access;
symbols;
locks; strict;
comment	@ * @;


1.71
date	2017.01.26.05.51.54;	author jsing;	state dead;
branches;
next	1.70;
commitid	UfCZ8lEOJI6kLTjE;

1.70
date	2017.01.26.05.31.25;	author jsing;	state Exp;
branches;
next	1.69;
commitid	GRopTNgx07uByytM;

1.69
date	2017.01.25.06.13.02;	author jsing;	state Exp;
branches;
next	1.68;
commitid	BrXF01BiSMHL1r6O;

1.68
date	2017.01.23.14.35.42;	author jsing;	state Exp;
branches;
next	1.67;
commitid	fvePj4ki9zOwq3SB;

1.67
date	2017.01.23.13.36.13;	author jsing;	state Exp;
branches;
next	1.66;
commitid	xYJ523Ay020rUB5W;

1.66
date	2017.01.23.08.48.44;	author beck;	state Exp;
branches;
next	1.65;
commitid	vAKES6VByBpegTl4;

1.65
date	2017.01.23.08.08.06;	author beck;	state Exp;
branches;
next	1.64;
commitid	INyvrQFO5zrO2vlL;

1.64
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.63;
commitid	grTXB43OAHDwwKOU;

1.63
date	2017.01.23.04.55.26;	author beck;	state Exp;
branches;
next	1.62;
commitid	AhwkqHI5lKK3NR31;

1.62
date	2017.01.23.04.15.28;	author jsing;	state Exp;
branches;
next	1.61;
commitid	j20UnjrPw7WvzMvm;

1.61
date	2017.01.22.09.02.07;	author jsing;	state Exp;
branches;
next	1.60;
commitid	570ElYZpaAvthwZh;

1.60
date	2016.11.17.15.06.22;	author jsing;	state Exp;
branches;
next	1.59;
commitid	ZABoBZT0JRRUrP6z;

1.59
date	2016.11.03.16.23.30;	author jsing;	state Exp;
branches;
next	1.58;
commitid	YQyxqWYssrI5qZfe;

1.58
date	2016.07.10.23.07.34;	author tedu;	state Exp;
branches;
next	1.57;
commitid	v6PUvKelf4s7hS3s;

1.57
date	2015.09.12.16.10.07;	author doug;	state Exp;
branches
	1.57.2.1;
next	1.56;
commitid	VR022UcxWVmcgSOF;

1.56
date	2015.07.24.02.39.43;	author doug;	state Exp;
branches;
next	1.55;
commitid	O3eWxr9uVh996W00;

1.55
date	2015.07.18.19.41.54;	author doug;	state Exp;
branches;
next	1.54;
commitid	iFy6hDttnmi2K987;

1.54
date	2014.12.14.21.49.29;	author bcook;	state Exp;
branches;
next	1.53;
commitid	4WNcCTaBHL0ZTDgF;

1.53
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.52;
commitid	XNZawfRSWvnVv1VS;

1.52
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.51;
commitid	M3pvHgIFoWUHNqJn;

1.51
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.50;
commitid	cGE1JG2i0h4NcVDi;

1.50
date	2014.07.12.13.11.53;	author jsing;	state Exp;
branches;
next	1.49;
commitid	tJhRneQ4w1l9LuV2;

1.49
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.48;
commitid	lsH7iukeZYSZBx6F;

1.48
date	2014.06.19.21.29.51;	author tedu;	state Exp;
branches;
next	1.47;
commitid	CIpPjhmVWPbqgxVA;

1.47
date	2014.06.13.10.52.24;	author jsing;	state Exp;
branches;
next	1.46;
commitid	NX4qoGRCqaBXEm1B;

1.46
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	mJUVYpkFBZ0Zv2bG;

1.45
date	2014.06.11.15.17.19;	author jsing;	state Exp;
branches;
next	1.44;
commitid	yLY4i8WW5UTUfvru;

1.44
date	2014.06.11.14.50.07;	author jsing;	state Exp;
branches;
next	1.43;
commitid	f10bKbk1itccbqtW;

1.43
date	2014.06.05.15.51.06;	author jsing;	state Exp;
branches;
next	1.42;
commitid	7kcmvSBQt6qdykFh;

1.42
date	2014.06.05.15.46.24;	author jsing;	state Exp;
branches;
next	1.41;
commitid	iKdQmUaYF0SZSn3g;

1.41
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.30.14.01.11;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.27.18.51.24;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.25.16.23.10;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.29.15.46.54;	author beck;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.24.19.38.22;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.24.06.02.58;	author beck;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.24.04.31.30;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.19.19.40.11;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.18.15.39.53;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.17.23.35.40;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.14.16.07.22;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.10.19.01.37;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.10.17.48.02;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2014.02.27.21.04.57;	author jca;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2013.02.14.15.11.43;	author markus;	state Exp;
branches
	1.19.2.1
	1.19.4.1;
next	1.18;

1.18
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.14.12.41.05;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.10.09.09.40;	author markus;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches
	1.13.2.1
	1.13.6.1;
next	1.12;

1.12
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.17.12.28.29;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.19.20.37.46;	author markus;	state Exp;
branches
	1.8.2.1
	1.8.4.1;
next	1.7;

1.7
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.03.40;	author beck;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.12.15.02.58.37;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.30;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.28;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.35;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.12;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.40;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.42.06;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.37.27;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2011.11.03.02.32.21;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.5.4.1
date	2003.02.22.17.46.48;	author miod;	state Exp;
branches;
next	;

1.7.2.1
date	2003.02.22.22.12.12;	author margarida;	state Exp;
branches;
next	;

1.8.2.1
date	2004.03.17.18.07.41;	author brad;	state Exp;
branches;
next	;

1.8.4.1
date	2004.03.17.17.50.58;	author brad;	state Exp;
branches;
next	;

1.13.2.1
date	2009.11.17.14.34.37;	author sthen;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2010.03.31.12.16.43;	author jasper;	state Exp;
branches;
next	;

1.13.6.1
date	2009.11.17.14.34.52;	author sthen;	state Exp;
branches;
next	1.13.6.2;

1.13.6.2
date	2010.03.31.12.17.28;	author jasper;	state Exp;
branches;
next	;

1.14.2.1
date	2010.03.31.12.17.40;	author jasper;	state Exp;
branches;
next	;

1.19.2.1
date	2014.04.12.17.00.22;	author deraadt;	state Exp;
branches;
next	;

1.19.4.1
date	2014.04.12.17.00.53;	author deraadt;	state Exp;
branches;
next	1.19.4.2;

1.19.4.2
date	2014.05.01.14.17.40;	author sthen;	state Exp;
branches;
next	1.19.4.3;

1.19.4.3
date	2014.06.05.20.37.47;	author sthen;	state Exp;
branches;
next	1.19.4.4;
commitid	V8zSJibrIbY4vAzC;

1.19.4.4
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.20.4.1
date	2014.04.12.17.01.14;	author deraadt;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2014.05.01.14.16.35;	author sthen;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2014.06.05.17.05.16;	author sthen;	state Exp;
branches;
next	1.20.4.4;
commitid	PBa7adr1t6pFSi7e;

1.20.4.4
date	2014.08.09.16.54.58;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;

1.57.2.1
date	2016.05.03.12.39.48;	author tedu;	state Exp;
branches;
next	1.57.2.2;
commitid	Ekna9eOpYJ6UbVcF;

1.57.2.2
date	2016.05.04.01.10.57;	author tedu;	state Exp;
branches;
next	;
commitid	4TFJppTZXWffqlve;


desc
@@


1.71
log
@Rename s3_{both,clnt,pkt_srvr}.c to have an ssl_ prefix since they are no
longer SSLv3 code.

ok beck@@
@
text
@/* $OpenBSD: s3_pkt.c,v 1.70 2017/01/26 05:31:25 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <errno.h>
#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/buffer.h>
#include <openssl/evp.h>

#include "bytestring.h"

static int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
    unsigned int len, int create_empty_fragment);
static int ssl3_get_record(SSL *s);

/* If extend == 0, obtain new n-byte packet; if extend == 1, increase
 * packet by another n bytes.
 * The packet will be in the sub-array of s->s3->rbuf.buf specified
 * by s->internal->packet and s->internal->packet_length.
 * (If s->internal->read_ahead is set, 'max' bytes may be stored in rbuf
 * [plus s->internal->packet_length bytes if extend == 1].)
 */
static int
ssl3_read_n(SSL *s, int n, int max, int extend)
{
	int i, len, left;
	size_t align;
	unsigned char *pkt;
	SSL3_BUFFER *rb;

	if (n <= 0)
		return n;

	rb = &(s->s3->rbuf);
	if (rb->buf == NULL)
		if (!ssl3_setup_read_buffer(s))
			return -1;

	left = rb->left;
	align = (size_t)rb->buf + SSL3_RT_HEADER_LENGTH;
	align = (-align) & (SSL3_ALIGN_PAYLOAD - 1);

	if (!extend) {
		/* start with empty packet ... */
		if (left == 0)
			rb->offset = align;
		else if (align != 0 && left >= SSL3_RT_HEADER_LENGTH) {
			/* check if next packet length is large
			 * enough to justify payload alignment... */
			pkt = rb->buf + rb->offset;
			if (pkt[0] == SSL3_RT_APPLICATION_DATA &&
			    (pkt[3]<<8|pkt[4]) >= 128) {
				/* Note that even if packet is corrupted
				 * and its length field is insane, we can
				 * only be led to wrong decision about
				 * whether memmove will occur or not.
				 * Header values has no effect on memmove
				 * arguments and therefore no buffer
				 * overrun can be triggered. */
				memmove(rb->buf + align, pkt, left);
				rb->offset = align;
			}
		}
		s->internal->packet = rb->buf + rb->offset;
		s->internal->packet_length = 0;
		/* ... now we can act as if 'extend' was set */
	}

	/* For DTLS/UDP reads should not span multiple packets
	 * because the read operation returns the whole packet
	 * at once (as long as it fits into the buffer). */
	if (SSL_IS_DTLS(s)) {
		if (left > 0 && n > left)
			n = left;
	}

	/* if there is enough in the buffer from a previous read, take some */
	if (left >= n) {
		s->internal->packet_length += n;
		rb->left = left - n;
		rb->offset += n;
		return (n);
	}

	/* else we need to read more data */

	len = s->internal->packet_length;
	pkt = rb->buf + align;
	/* Move any available bytes to front of buffer:
	 * 'len' bytes already pointed to by 'packet',
	 * 'left' extra ones at the end */
	if (s->internal->packet != pkt)  {
		/* len > 0 */
		memmove(pkt, s->internal->packet, len + left);
		s->internal->packet = pkt;
		rb->offset = len + align;
	}

	if (n > (int)(rb->len - rb->offset)) {
		/* does not happen */
		SSLerr(SSL_F_SSL3_READ_N, ERR_R_INTERNAL_ERROR);
		return -1;
	}

	if (!s->internal->read_ahead) {
		/* ignore max parameter */
		max = n;
	} else {
		if (max < n)
			max = n;
		if (max > (int)(rb->len - rb->offset))
			max = rb->len - rb->offset;
	}

	while (left < n) {
		/* Now we have len+left bytes at the front of s->s3->rbuf.buf
		 * and need to read in more until we have len+n (up to
		 * len+max if possible) */

		errno = 0;
		if (s->rbio != NULL) {
			s->internal->rwstate = SSL_READING;
			i = BIO_read(s->rbio, pkt + len + left, max - left);
		} else {
			SSLerr(SSL_F_SSL3_READ_N, SSL_R_READ_BIO_NOT_SET);
			i = -1;
		}

		if (i <= 0) {
			rb->left = left;
			if (s->internal->mode & SSL_MODE_RELEASE_BUFFERS &&
			    !SSL_IS_DTLS(s)) {
				if (len + left == 0)
					ssl3_release_read_buffer(s);
			}
			return (i);
		}
		left += i;

		/*
		 * reads should *never* span multiple packets for DTLS because
		 * the underlying transport protocol is message oriented as
		 * opposed to byte oriented as in the TLS case.
		 */
		if (SSL_IS_DTLS(s)) {
			if (n > left)
				n = left; /* makes the while condition false */
		}
	}

	/* done reading, now the book-keeping */
	rb->offset += n;
	rb->left = left - n;
	s->internal->packet_length += n;
	s->internal->rwstate = SSL_NOTHING;

	return (n);
}

int
ssl3_packet_read(SSL *s, int plen)
{
	int n;

	n = ssl3_read_n(s, plen, s->s3->rbuf.len, 0);
	if (n <= 0)
		return n;
	if (s->internal->packet_length < plen)
		return s->internal->packet_length;

	return plen;
}

int
ssl3_packet_extend(SSL *s, int plen)
{
	int rlen, n;

	if (s->internal->packet_length >= plen)
		return plen;
	rlen = plen - s->internal->packet_length;

	n = ssl3_read_n(s, rlen, rlen, 1);
	if (n <= 0)
		return n;
	if (s->internal->packet_length < plen)
		return s->internal->packet_length;

	return plen;
}

/* Call this to get a new input record.
 * It will return <= 0 if more data is needed, normally due to an error
 * or non-blocking IO.
 * When it finishes, one packet has been decoded and can be found in
 * ssl->s3->internal->rrec.type    - is the type of record
 * ssl->s3->internal->rrec.data, 	 - data
 * ssl->s3->internal->rrec.length, - number of bytes
 */
/* used only by ssl3_read_bytes */
static int
ssl3_get_record(SSL *s)
{
	int al;
	int enc_err, n, i, ret = -1;
	SSL3_RECORD *rr;
	SSL_SESSION *sess;
	unsigned char md[EVP_MAX_MD_SIZE];
	unsigned mac_size, orig_len;

	rr = &(S3I(s)->rrec);
	sess = s->session;

again:
	/* check if we have the header */
	if ((s->internal->rstate != SSL_ST_READ_BODY) ||
	    (s->internal->packet_length < SSL3_RT_HEADER_LENGTH)) {
		CBS header;
		uint16_t len, ssl_version;
		uint8_t type;

		n = ssl3_packet_read(s, SSL3_RT_HEADER_LENGTH);
		if (n <= 0)
			return (n);

		s->internal->mac_packet = 1;
		s->internal->rstate = SSL_ST_READ_BODY;

		if (s->server && s->internal->first_packet) {
			if ((ret = ssl_server_legacy_first_packet(s)) != 1)
				return (ret);
			ret = -1;
		}

		CBS_init(&header, s->internal->packet, SSL3_RT_HEADER_LENGTH);

		/* Pull apart the header into the SSL3_RECORD */
		if (!CBS_get_u8(&header, &type) ||
		    !CBS_get_u16(&header, &ssl_version) ||
		    !CBS_get_u16(&header, &len)) {
			SSLerr(SSL_F_SSL3_GET_RECORD,
			    SSL_R_BAD_PACKET_LENGTH);
			goto err;
		}

		rr->type = type;
		rr->length = len;

		/* Lets check version */
		if (!s->internal->first_packet && ssl_version != s->version) {
			SSLerr(SSL_F_SSL3_GET_RECORD,
			    SSL_R_WRONG_VERSION_NUMBER);
			if ((s->version & 0xFF00) == (ssl_version & 0xFF00) &&
			    !s->internal->enc_write_ctx && !s->internal->write_hash)
				/* Send back error using their minor version number :-) */
				s->version = ssl_version;
			al = SSL_AD_PROTOCOL_VERSION;
			goto f_err;
		}

		if ((ssl_version >> 8) != SSL3_VERSION_MAJOR) {
			SSLerr(SSL_F_SSL3_GET_RECORD,
			    SSL_R_WRONG_VERSION_NUMBER);
			goto err;
		}

		if (rr->length > s->s3->rbuf.len - SSL3_RT_HEADER_LENGTH) {
			al = SSL_AD_RECORD_OVERFLOW;
			SSLerr(SSL_F_SSL3_GET_RECORD,
			    SSL_R_PACKET_LENGTH_TOO_LONG);
			goto f_err;
		}

		/* now s->internal->rstate == SSL_ST_READ_BODY */
	}

	/* s->internal->rstate == SSL_ST_READ_BODY, get and decode the data */

	n = ssl3_packet_extend(s, SSL3_RT_HEADER_LENGTH + rr->length);
	if (n <= 0)
		return (n);
	if (n != SSL3_RT_HEADER_LENGTH + rr->length)
		return (n);

	s->internal->rstate = SSL_ST_READ_HEADER; /* set state for later operations */

	/* At this point, s->internal->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,
	 * and we have that many bytes in s->internal->packet
	 */
	rr->input = &(s->internal->packet[SSL3_RT_HEADER_LENGTH]);

	/* ok, we can now read from 's->internal->packet' data into 'rr'
	 * rr->input points at rr->length bytes, which
	 * need to be copied into rr->data by either
	 * the decryption or by the decompression
	 * When the data is 'copied' into the rr->data buffer,
	 * rr->input will be pointed at the new buffer */

	/* We now have - encrypted [ MAC [ compressed [ plain ] ] ]
	 * rr->length bytes of encrypted compressed stuff. */

	/* check is not needed I believe */
	if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {
		al = SSL_AD_RECORD_OVERFLOW;
		SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
		goto f_err;
	}

	/* decrypt in place in 'rr->input' */
	rr->data = rr->input;

	enc_err = s->method->internal->ssl3_enc->enc(s, 0);
	/* enc_err is:
	 *    0: (in non-constant time) if the record is publically invalid.
	 *    1: if the padding is valid
	 *    -1: if the padding is invalid */
	if (enc_err == 0) {
		al = SSL_AD_DECRYPTION_FAILED;
		SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
		goto f_err;
	}


	/* r->length is now the compressed data plus mac */
	if ((sess != NULL) && (s->enc_read_ctx != NULL) &&
	    (EVP_MD_CTX_md(s->read_hash) != NULL)) {
		/* s->read_hash != NULL => mac_size != -1 */
		unsigned char *mac = NULL;
		unsigned char mac_tmp[EVP_MAX_MD_SIZE];

		mac_size = EVP_MD_CTX_size(s->read_hash);
		OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);

		/* kludge: *_cbc_remove_padding passes padding length in rr->type */
		orig_len = rr->length + ((unsigned int)rr->type >> 8);

		/* orig_len is the length of the record before any padding was
		 * removed. This is public information, as is the MAC in use,
		 * therefore we can safely process the record in a different
		 * amount of time if it's too short to possibly contain a MAC.
		 */
		if (orig_len < mac_size ||
			/* CBC records must have a padding length byte too. */
		    (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
		    orig_len < mac_size + 1)) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
		}

		if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {
			/* We update the length so that the TLS header bytes
			 * can be constructed correctly but we need to extract
			 * the MAC in constant time from within the record,
			 * without leaking the contents of the padding bytes.
			 * */
			mac = mac_tmp;
			ssl3_cbc_copy_mac(mac_tmp, rr, mac_size, orig_len);
			rr->length -= mac_size;
		} else {
			/* In this case there's no padding, so |orig_len|
			 * equals |rec->length| and we checked that there's
			 * enough bytes for |mac_size| above. */
			rr->length -= mac_size;
			mac = &rr->data[rr->length];
		}

		i = s->method->internal->ssl3_enc->mac(s,md,0 /* not send */);
		if (i < 0 || mac == NULL ||
		    timingsafe_memcmp(md, mac, (size_t)mac_size) != 0)
			enc_err = -1;
		if (rr->length >
		    SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)
			enc_err = -1;
	}

	if (enc_err < 0) {
		/*
		 * A separate 'decryption_failed' alert was introduced with
		 * TLS 1.0, SSL 3.0 only has 'bad_record_mac'. But unless a
		 * decryption failure is directly visible from the ciphertext
		 * anyway, we should not reveal which kind of error
		 * occurred -- this might become visible to an attacker
		 * (e.g. via a logfile)
		 */
		al = SSL_AD_BAD_RECORD_MAC;
		SSLerr(SSL_F_SSL3_GET_RECORD,
		    SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
		goto f_err;
	}

	if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH) {
		al = SSL_AD_RECORD_OVERFLOW;
		SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);
		goto f_err;
	}

	rr->off = 0;
	/*
	 * So at this point the following is true
	 *
	 * ssl->s3->internal->rrec.type 	is the type of record
	 * ssl->s3->internal->rrec.length	== number of bytes in record
	 * ssl->s3->internal->rrec.off	== offset to first valid byte
	 * ssl->s3->internal->rrec.data	== where to take bytes from, increment
	 *			   after use :-).
	 */

	/* we have pulled in a full packet so zero things */
	s->internal->packet_length = 0;

	/* just read a 0 length packet */
	if (rr->length == 0)
		goto again;

	return (1);

f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	return (ret);
}

/* Call this to write data in records of type 'type'
 * It will return <= 0 if not all data has been sent or non-blocking IO.
 */
int
ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
{
	const unsigned char *buf = buf_;
	unsigned int tot, n, nw;
	int i;

	if (len < 0) {
		SSLerr(SSL_F_SSL3_WRITE_BYTES, ERR_R_INTERNAL_ERROR);
		return -1;
	}

	s->internal->rwstate = SSL_NOTHING;
	tot = S3I(s)->wnum;
	S3I(s)->wnum = 0;

	if (SSL_in_init(s) && !s->internal->in_handshake) {
		i = s->internal->handshake_func(s);
		if (i < 0)
			return (i);
		if (i == 0) {
			SSLerr(SSL_F_SSL3_WRITE_BYTES,
			    SSL_R_SSL_HANDSHAKE_FAILURE);
			return -1;
		}
	}

	if (len < tot)
		len = tot;
	n = (len - tot);
	for (;;) {
		if (n > s->max_send_fragment)
			nw = s->max_send_fragment;
		else
			nw = n;

		i = do_ssl3_write(s, type, &(buf[tot]), nw, 0);
		if (i <= 0) {
			S3I(s)->wnum = tot;
			return i;
		}

		if ((i == (int)n) || (type == SSL3_RT_APPLICATION_DATA &&
		    (s->internal->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))) {
			/*
			 * Next chunk of data should get another prepended
			 * empty fragment in ciphersuites with known-IV
			 * weakness.
			 */
			S3I(s)->empty_fragment_done = 0;

			return tot + i;
		}

		n -= i;
		tot += i;
	}
}

static int
do_ssl3_write(SSL *s, int type, const unsigned char *buf,
    unsigned int len, int create_empty_fragment)
{
	unsigned char *p, *plen;
	int i, mac_size, clear = 0;
	int prefix_len = 0;
	int eivlen;
	size_t align;
	SSL3_RECORD *wr;
	SSL3_BUFFER *wb = &(s->s3->wbuf);
	SSL_SESSION *sess;

	if (wb->buf == NULL)
		if (!ssl3_setup_write_buffer(s))
			return -1;

	/* first check if there is a SSL3_BUFFER still being written
	 * out.  This will happen with non blocking IO */
	if (wb->left != 0)
		return (ssl3_write_pending(s, type, buf, len));

	/* If we have an alert to send, lets send it */
	if (s->s3->alert_dispatch) {
		i = s->method->ssl_dispatch_alert(s);
		if (i <= 0)
			return (i);
		/* if it went, fall through and send more stuff */
		/* we may have released our buffer, so get it again */
		if (wb->buf == NULL)
			if (!ssl3_setup_write_buffer(s))
				return -1;
	}

	if (len == 0 && !create_empty_fragment)
		return 0;

	wr = &(S3I(s)->wrec);
	sess = s->session;

	if ((sess == NULL) || (s->internal->enc_write_ctx == NULL) ||
	    (EVP_MD_CTX_md(s->internal->write_hash) == NULL)) {
		clear = s->internal->enc_write_ctx ? 0 : 1; /* must be AEAD cipher */
		mac_size = 0;
	} else {
		mac_size = EVP_MD_CTX_size(s->internal->write_hash);
		if (mac_size < 0)
			goto err;
	}

	/*
	 * 'create_empty_fragment' is true only when this function calls
	 * itself.
	 */
	if (!clear && !create_empty_fragment && !S3I(s)->empty_fragment_done) {
		/*
		 * Countermeasure against known-IV weakness in CBC ciphersuites
		 * (see http://www.openssl.org/~bodo/tls-cbc.txt)
		 */
		if (S3I(s)->need_empty_fragments &&
		    type == SSL3_RT_APPLICATION_DATA) {
			/* recursive function call with 'create_empty_fragment' set;
			 * this prepares and buffers the data for an empty fragment
			 * (these 'prefix_len' bytes are sent out later
			 * together with the actual payload) */
			prefix_len = do_ssl3_write(s, type, buf, 0, 1);
			if (prefix_len <= 0)
				goto err;

			if (prefix_len >
				(SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD)) {
				/* insufficient space */
				SSLerr(SSL_F_DO_SSL3_WRITE,
				    ERR_R_INTERNAL_ERROR);
				goto err;
			}
		}

		S3I(s)->empty_fragment_done = 1;
	}

	if (create_empty_fragment) {
		/* extra fragment would be couple of cipher blocks,
		 * which would be multiple of SSL3_ALIGN_PAYLOAD, so
		 * if we want to align the real payload, then we can
		 * just pretent we simply have two headers. */
		align = (size_t)wb->buf + 2 * SSL3_RT_HEADER_LENGTH;
		align = (-align) & (SSL3_ALIGN_PAYLOAD - 1);

		p = wb->buf + align;
		wb->offset = align;
	} else if (prefix_len) {
		p = wb->buf + wb->offset + prefix_len;
	} else {
		align = (size_t)wb->buf + SSL3_RT_HEADER_LENGTH;
		align = (-align) & (SSL3_ALIGN_PAYLOAD - 1);

		p = wb->buf + align;
		wb->offset = align;
	}

	/* write the header */

	*(p++) = type&0xff;
	wr->type = type;

	*(p++) = (s->version >> 8);
	/* Some servers hang if iniatial client hello is larger than 256
	 * bytes and record version number > TLS 1.0
	 */
	if (s->internal->state == SSL3_ST_CW_CLNT_HELLO_B && !s->internal->renegotiate &&
	    TLS1_get_version(s) > TLS1_VERSION)
		*(p++) = 0x1;
	else
		*(p++) = s->version&0xff;

	/* field where we are to write out packet length */
	plen = p;
	p += 2;

	/* Explicit IV length. */
	if (s->internal->enc_write_ctx && SSL_USE_EXPLICIT_IV(s)) {
		int mode = EVP_CIPHER_CTX_mode(s->internal->enc_write_ctx);
		if (mode == EVP_CIPH_CBC_MODE) {
			eivlen = EVP_CIPHER_CTX_iv_length(s->internal->enc_write_ctx);
			if (eivlen <= 1)
				eivlen = 0;
		}
		/* Need explicit part of IV for GCM mode */
		else if (mode == EVP_CIPH_GCM_MODE)
			eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN;
		else
			eivlen = 0;
	} else if (s->internal->aead_write_ctx != NULL &&
	    s->internal->aead_write_ctx->variable_nonce_in_record) {
		eivlen = s->internal->aead_write_ctx->variable_nonce_len;
	} else
		eivlen = 0;

	/* lets setup the record stuff. */
	wr->data = p + eivlen;
	wr->length = (int)len;
	wr->input = (unsigned char *)buf;

	/* we now 'read' from wr->input, wr->length bytes into wr->data */

	memcpy(wr->data, wr->input, wr->length);
	wr->input = wr->data;

	/* we should still have the output to wr->data and the input
	 * from wr->input.  Length should be wr->length.
	 * wr->data still points in the wb->buf */

	if (mac_size != 0) {
		if (s->method->internal->ssl3_enc->mac(s,
		    &(p[wr->length + eivlen]), 1) < 0)
			goto err;
		wr->length += mac_size;
	}

	wr->input = p;
	wr->data = p;

	if (eivlen) {
		/* if (RAND_pseudo_bytes(p, eivlen) <= 0)
			goto err;
		*/
		wr->length += eivlen;
	}

	/* ssl3_enc can only have an error on read */
	s->method->internal->ssl3_enc->enc(s, 1);

	/* record length after mac and block padding */
	s2n(wr->length, plen);

	/* we should now have
	 * wr->data pointing to the encrypted data, which is
	 * wr->length long */
	wr->type=type; /* not needed but helps for debugging */
	wr->length += SSL3_RT_HEADER_LENGTH;

	if (create_empty_fragment) {
		/* we are in a recursive call;
		 * just return the length, don't write out anything here
		 */
		return wr->length;
	}

	/* now let's set up wb */
	wb->left = prefix_len + wr->length;

	/* memorize arguments so that ssl3_write_pending can detect
	 * bad write retries later */
	S3I(s)->wpend_tot = len;
	S3I(s)->wpend_buf = buf;
	S3I(s)->wpend_type = type;
	S3I(s)->wpend_ret = len;

	/* we now just need to write the buffer */
	return ssl3_write_pending(s, type, buf, len);
err:
	return -1;
}

/* if s->s3->wbuf.left != 0, we need to call this */
int
ssl3_write_pending(SSL *s, int type, const unsigned char *buf, unsigned int len)
{
	int i;
	SSL3_BUFFER *wb = &(s->s3->wbuf);

	/* XXXX */
	if ((S3I(s)->wpend_tot > (int)len) || ((S3I(s)->wpend_buf != buf) &&
	    !(s->internal->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER)) ||
	    (S3I(s)->wpend_type != type)) {
		SSLerr(SSL_F_SSL3_WRITE_PENDING, SSL_R_BAD_WRITE_RETRY);
		return (-1);
	}

	for (;;) {
		errno = 0;
		if (s->wbio != NULL) {
			s->internal->rwstate = SSL_WRITING;
			i = BIO_write(s->wbio,
			(char *)&(wb->buf[wb->offset]),
			(unsigned int)wb->left);
		} else {
			SSLerr(SSL_F_SSL3_WRITE_PENDING, SSL_R_BIO_NOT_SET);
			i = -1;
		}
		if (i == wb->left) {
			wb->left = 0;
			wb->offset += i;
			if (s->internal->mode & SSL_MODE_RELEASE_BUFFERS &&
			    !SSL_IS_DTLS(s))
				ssl3_release_write_buffer(s);
			s->internal->rwstate = SSL_NOTHING;
			return (S3I(s)->wpend_ret);
		} else if (i <= 0) {
			/*
			 * For DTLS, just drop it. That's kind of the
			 * whole point in using a datagram service.
			 */
			if (SSL_IS_DTLS(s))
				wb->left = 0;
			return (i);
		}
		wb->offset += i;
		wb->left -= i;
	}
}

/* Return up to 'len' payload bytes received in 'type' records.
 * 'type' is one of the following:
 *
 *   -  SSL3_RT_HANDSHAKE (when ssl3_get_message calls us)
 *   -  SSL3_RT_APPLICATION_DATA (when ssl3_read calls us)
 *   -  0 (during a shutdown, no data has to be returned)
 *
 * If we don't have stored data to work from, read a SSL/TLS record first
 * (possibly multiple records if we still don't have anything to return).
 *
 * This function must handle any surprises the peer may have for us, such as
 * Alert records (e.g. close_notify), ChangeCipherSpec records (not really
 * a surprise, but handled as if it were), or renegotiation requests.
 * Also if record payloads contain fragments too small to process, we store
 * them until there is enough for the respective protocol (the record protocol
 * may use arbitrary fragmentation and even interleaving):
 *     Change cipher spec protocol
 *             just 1 byte needed, no need for keeping anything stored
 *     Alert protocol
 *             2 bytes needed (AlertLevel, AlertDescription)
 *     Handshake protocol
 *             4 bytes needed (HandshakeType, uint24 length) -- we just have
 *             to detect unexpected Client Hello and Hello Request messages
 *             here, anything else is handled by higher layers
 *     Application data protocol
 *             none of our business
 */
int
ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
{
	void (*cb)(const SSL *ssl, int type2, int val) = NULL;
	int al, i, j, ret, rrcount = 0;
	unsigned int n;
	SSL3_RECORD *rr;
	BIO *bio;

	if (s->s3->rbuf.buf == NULL) /* Not initialized yet */
		if (!ssl3_setup_read_buffer(s))
			return (-1);

	if (len < 0) {
		SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);
		return -1;
	}

	if ((type && type != SSL3_RT_APPLICATION_DATA &&
	    type != SSL3_RT_HANDSHAKE) ||
	    (peek && (type != SSL3_RT_APPLICATION_DATA))) {
		SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);
		return -1;
	}

	if ((type == SSL3_RT_HANDSHAKE) &&
	    (S3I(s)->handshake_fragment_len > 0)) {
		/* (partially) satisfy request from storage */
		unsigned char *src = S3I(s)->handshake_fragment;
		unsigned char *dst = buf;
		unsigned int k;

		/* peek == 0 */
		n = 0;
		while ((len > 0) && (S3I(s)->handshake_fragment_len > 0)) {
			*dst++ = *src++;
			len--;
			S3I(s)->handshake_fragment_len--;
			n++;
		}
		/* move any remaining fragment bytes: */
		for (k = 0; k < S3I(s)->handshake_fragment_len; k++)
			S3I(s)->handshake_fragment[k] = *src++;
		return n;
	}

	/*
	 * Now S3I(s)->handshake_fragment_len == 0 if
	 * type == SSL3_RT_HANDSHAKE.
	 */
	if (!s->internal->in_handshake && SSL_in_init(s)) {
		/* type == SSL3_RT_APPLICATION_DATA */
		i = s->internal->handshake_func(s);
		if (i < 0)
			return (i);
		if (i == 0) {
			SSLerr(SSL_F_SSL3_READ_BYTES,
			    SSL_R_SSL_HANDSHAKE_FAILURE);
			return (-1);
		}
	}

start:
	/*
	 * Do not process more than three consecutive records, otherwise the
	 * peer can cause us to loop indefinitely. Instead, return with an
	 * SSL_ERROR_WANT_READ so the caller can choose when to handle further
	 * processing. In the future, the total number of non-handshake and
	 * non-application data records per connection should probably also be
	 * limited...
	 */
	if (rrcount++ >= 3) {
		if ((bio = SSL_get_rbio(s)) == NULL) {
			SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);
			return -1;
		}
		BIO_clear_retry_flags(bio);
		BIO_set_retry_read(bio);
		s->internal->rwstate = SSL_READING;
		return -1;
	}

	s->internal->rwstate = SSL_NOTHING;

	/*
	 * S3I(s)->rrec.type	    - is the type of record
	 * S3I(s)->rrec.data,    - data
	 * S3I(s)->rrec.off,     - offset into 'data' for next read
	 * S3I(s)->rrec.length,  - number of bytes.
	 */
	rr = &(S3I(s)->rrec);

	/* get new packet if necessary */
	if ((rr->length == 0) || (s->internal->rstate == SSL_ST_READ_BODY)) {
		ret = ssl3_get_record(s);
		if (ret <= 0)
			return (ret);
	}

	/* we now have a packet which can be read and processed */

	if (S3I(s)->change_cipher_spec /* set when we receive ChangeCipherSpec,
	                               * reset by ssl3_get_finished */
	    && (rr->type != SSL3_RT_HANDSHAKE)) {
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_READ_BYTES,
		    SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);
		goto f_err;
	}

	/* If the other end has shut down, throw anything we read away
	 * (even in 'peek' mode) */
	if (s->internal->shutdown & SSL_RECEIVED_SHUTDOWN) {
		rr->length = 0;
		s->internal->rwstate = SSL_NOTHING;
		return (0);
	}


	/* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */
	if (type == rr->type) {
		/* make sure that we are not getting application data when we
		 * are doing a handshake for the first time */
		if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&
			(s->enc_read_ctx == NULL)) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES,
			    SSL_R_APP_DATA_IN_HANDSHAKE);
			goto f_err;
		}

		if (len <= 0)
			return (len);

		if ((unsigned int)len > rr->length)
			n = rr->length;
		else
			n = (unsigned int)len;

		memcpy(buf, &(rr->data[rr->off]), n);
		if (!peek) {
			memset(&(rr->data[rr->off]), 0, n);
			rr->length -= n;
			rr->off += n;
			if (rr->length == 0) {
				s->internal->rstate = SSL_ST_READ_HEADER;
				rr->off = 0;
				if (s->internal->mode & SSL_MODE_RELEASE_BUFFERS &&
				    s->s3->rbuf.left == 0)
					ssl3_release_read_buffer(s);
			}
		}
		return (n);
	}


	/* If we get here, then type != rr->type; if we have a handshake
	 * message, then it was unexpected (Hello Request or Client Hello). */

	{
		/*
		 * In case of record types for which we have 'fragment'
		 * storage, * fill that so that we can process the data
		 * at a fixed place.
		 */
		unsigned int dest_maxlen = 0;
		unsigned char *dest = NULL;
		unsigned int *dest_len = NULL;

		if (rr->type == SSL3_RT_HANDSHAKE) {
			dest_maxlen = sizeof S3I(s)->handshake_fragment;
			dest = S3I(s)->handshake_fragment;
			dest_len = &S3I(s)->handshake_fragment_len;
		} else if (rr->type == SSL3_RT_ALERT) {
			dest_maxlen = sizeof S3I(s)->alert_fragment;
			dest = S3I(s)->alert_fragment;
			dest_len = &S3I(s)->alert_fragment_len;
		}
		if (dest_maxlen > 0) {
			/* available space in 'dest' */
			n = dest_maxlen - *dest_len;
			if (rr->length < n)
				n = rr->length; /* available bytes */

			/* now move 'n' bytes: */
			while (n-- > 0) {
				dest[(*dest_len)++] = rr->data[rr->off++];
				rr->length--;
			}

			if (*dest_len < dest_maxlen)
				goto start; /* fragment was too small */
		}
	}

	/* S3I(s)->handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;
	 * S3I(s)->alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.
	 * (Possibly rr is 'empty' now, i.e. rr->length may be 0.) */

	/* If we are a client, check for an incoming 'Hello Request': */
	if ((!s->server) && (S3I(s)->handshake_fragment_len >= 4) &&
	    (S3I(s)->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&
	    (s->session != NULL) && (s->session->cipher != NULL)) {
		S3I(s)->handshake_fragment_len = 0;

		if ((S3I(s)->handshake_fragment[1] != 0) ||
		    (S3I(s)->handshake_fragment[2] != 0) ||
		    (S3I(s)->handshake_fragment[3] != 0)) {
			al = SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);
			goto f_err;
		}

		if (s->internal->msg_callback)
			s->internal->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
			    S3I(s)->handshake_fragment, 4, s,
			    s->internal->msg_callback_arg);

		if (SSL_is_init_finished(s) &&
		    !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&
		    !S3I(s)->renegotiate) {
			ssl3_renegotiate(s);
			if (ssl3_renegotiate_check(s)) {
				i = s->internal->handshake_func(s);
				if (i < 0)
					return (i);
				if (i == 0) {
					SSLerr(SSL_F_SSL3_READ_BYTES,
					    SSL_R_SSL_HANDSHAKE_FAILURE);
					return (-1);
				}

				if (!(s->internal->mode & SSL_MODE_AUTO_RETRY)) {
					if (s->s3->rbuf.left == 0) {
						/* no read-ahead left? */
			/* In the case where we try to read application data,
			 * but we trigger an SSL handshake, we return -1 with
			 * the retry option set.  Otherwise renegotiation may
			 * cause nasty problems in the blocking world */
						s->internal->rwstate = SSL_READING;
						bio = SSL_get_rbio(s);
						BIO_clear_retry_flags(bio);
						BIO_set_retry_read(bio);
						return (-1);
					}
				}
			}
		}
		/* we either finished a handshake or ignored the request,
		 * now try again to obtain the (application) data we were asked for */
		goto start;
	}
	/* If we are a server and get a client hello when renegotiation isn't
	 * allowed send back a no renegotiation alert and carry on.
	 * WARNING: experimental code, needs reviewing (steve)
	 */
	if (s->server &&
	    SSL_is_init_finished(s) &&
	    !S3I(s)->send_connection_binding &&
	    (S3I(s)->handshake_fragment_len >= 4) &&
	    (S3I(s)->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&
	    (s->session != NULL) && (s->session->cipher != NULL)) {
		/*S3I(s)->handshake_fragment_len = 0;*/
		rr->length = 0;
		ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);
		goto start;
	}
	if (S3I(s)->alert_fragment_len >= 2) {
		int alert_level = S3I(s)->alert_fragment[0];
		int alert_descr = S3I(s)->alert_fragment[1];

		S3I(s)->alert_fragment_len = 0;

		if (s->internal->msg_callback)
			s->internal->msg_callback(0, s->version, SSL3_RT_ALERT,
			    S3I(s)->alert_fragment, 2, s, s->internal->msg_callback_arg);

		if (s->internal->info_callback != NULL)
			cb = s->internal->info_callback;
		else if (s->ctx->internal->info_callback != NULL)
			cb = s->ctx->internal->info_callback;

		if (cb != NULL) {
			j = (alert_level << 8) | alert_descr;
			cb(s, SSL_CB_READ_ALERT, j);
		}

		if (alert_level == SSL3_AL_WARNING) {
			S3I(s)->warn_alert = alert_descr;
			if (alert_descr == SSL_AD_CLOSE_NOTIFY) {
				s->internal->shutdown |= SSL_RECEIVED_SHUTDOWN;
				return (0);
			}
			/* This is a warning but we receive it if we requested
			 * renegotiation and the peer denied it. Terminate with
			 * a fatal alert because if application tried to
			 * renegotiatie it presumably had a good reason and
			 * expects it to succeed.
			 *
			 * In future we might have a renegotiation where we
			 * don't care if the peer refused it where we carry on.
			 */
			else if (alert_descr == SSL_AD_NO_RENEGOTIATION) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_READ_BYTES,
				    SSL_R_NO_RENEGOTIATION);
				goto f_err;
			}
		} else if (alert_level == SSL3_AL_FATAL) {
			s->internal->rwstate = SSL_NOTHING;
			S3I(s)->fatal_alert = alert_descr;
			SSLerr(SSL_F_SSL3_READ_BYTES,
			    SSL_AD_REASON_OFFSET + alert_descr);
			ERR_asprintf_error_data("SSL alert number %d",
			    alert_descr);
			s->internal->shutdown |= SSL_RECEIVED_SHUTDOWN;
			SSL_CTX_remove_session(s->ctx, s->session);
			return (0);
		} else {
			al = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNKNOWN_ALERT_TYPE);
			goto f_err;
		}

		goto start;
	}

	if (s->internal->shutdown & SSL_SENT_SHUTDOWN) {
		/* but we have not received a shutdown */
		s->internal->rwstate = SSL_NOTHING;
		rr->length = 0;
		return (0);
	}

	if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC) {
		/* 'Change Cipher Spec' is just a single byte, so we know
		 * exactly what the record payload has to look like */
		if ((rr->length != 1) || (rr->off != 0) ||
			(rr->data[0] != SSL3_MT_CCS)) {
			al = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_READ_BYTES,
			    SSL_R_BAD_CHANGE_CIPHER_SPEC);
			goto f_err;
		}

		/* Check we have a cipher to change to */
		if (S3I(s)->tmp.new_cipher == NULL) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES,
			    SSL_R_CCS_RECEIVED_EARLY);
			goto f_err;
		}

		/* Check that we should be receiving a Change Cipher Spec. */
		if (!(s->s3->flags & SSL3_FLAGS_CCS_OK)) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES,
			    SSL_R_CCS_RECEIVED_EARLY);
			goto f_err;
		}
		s->s3->flags &= ~SSL3_FLAGS_CCS_OK;

		rr->length = 0;

		if (s->internal->msg_callback) {
			s->internal->msg_callback(0, s->version,
			    SSL3_RT_CHANGE_CIPHER_SPEC, rr->data, 1, s,
			    s->internal->msg_callback_arg);
		}

		S3I(s)->change_cipher_spec = 1;
		if (!ssl3_do_change_cipher_spec(s))
			goto err;
		else
			goto start;
	}

	/* Unexpected handshake message (Client Hello, or protocol violation) */
	if ((S3I(s)->handshake_fragment_len >= 4) && !s->internal->in_handshake) {
		if (((s->internal->state&SSL_ST_MASK) == SSL_ST_OK) &&
		    !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {
			s->internal->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;
			s->internal->renegotiate = 1;
			s->internal->new_session = 1;
		}
		i = s->internal->handshake_func(s);
		if (i < 0)
			return (i);
		if (i == 0) {
			SSLerr(SSL_F_SSL3_READ_BYTES,
			    SSL_R_SSL_HANDSHAKE_FAILURE);
			return (-1);
		}

		if (!(s->internal->mode & SSL_MODE_AUTO_RETRY)) {
			if (s->s3->rbuf.left == 0) { /* no read-ahead left? */
				BIO *bio;
				/* In the case where we try to read application data,
				 * but we trigger an SSL handshake, we return -1 with
				 * the retry option set.  Otherwise renegotiation may
				 * cause nasty problems in the blocking world */
				s->internal->rwstate = SSL_READING;
				bio = SSL_get_rbio(s);
				BIO_clear_retry_flags(bio);
				BIO_set_retry_read(bio);
				return (-1);
			}
		}
		goto start;
	}

	switch (rr->type) {
	default:
		/*
		 * TLS up to v1.1 just ignores unknown message types:
		 * TLS v1.2 give an unexpected message alert.
		 */
		if (s->version >= TLS1_VERSION &&
		    s->version <= TLS1_1_VERSION) {
			rr->length = 0;
			goto start;
		}
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);
		goto f_err;
	case SSL3_RT_CHANGE_CIPHER_SPEC:
	case SSL3_RT_ALERT:
	case SSL3_RT_HANDSHAKE:
		/* we already handled all of these, with the possible exception
		 * of SSL3_RT_HANDSHAKE when s->internal->in_handshake is set, but that
		 * should not happen when type != rr->type */
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);
		goto f_err;
	case SSL3_RT_APPLICATION_DATA:
		/* At this point, we were expecting handshake data,
		 * but have application data.  If the library was
		 * running inside ssl3_read() (i.e. in_read_app_data
		 * is set) and it makes sense to read application data
		 * at this point (session renegotiation not yet started),
		 * we will indulge it.
		 */
		if (S3I(s)->in_read_app_data &&
		    (S3I(s)->total_renegotiations != 0) &&
		    (((s->internal->state & SSL_ST_CONNECT) &&
		    (s->internal->state >= SSL3_ST_CW_CLNT_HELLO_A) &&
		    (s->internal->state <= SSL3_ST_CR_SRVR_HELLO_A)) ||
		    ((s->internal->state & SSL_ST_ACCEPT) &&
		    (s->internal->state <= SSL3_ST_SW_HELLO_REQ_A) &&
		    (s->internal->state >= SSL3_ST_SR_CLNT_HELLO_A)))) {
			S3I(s)->in_read_app_data = 2;
			return (-1);
		} else {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);
			goto f_err;
		}
	}
	/* not reached */

f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	return (-1);
}

int
ssl3_do_change_cipher_spec(SSL *s)
{
	int i;
	const char *sender;
	int slen;

	if (s->internal->state & SSL_ST_ACCEPT)
		i = SSL3_CHANGE_CIPHER_SERVER_READ;
	else
		i = SSL3_CHANGE_CIPHER_CLIENT_READ;

	if (S3I(s)->tmp.key_block == NULL) {
		if (s->session == NULL || s->session->master_key_length == 0) {
			/* might happen if dtls1_read_bytes() calls this */
			SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,
			    SSL_R_CCS_RECEIVED_EARLY);
			return (0);
		}

		s->session->cipher = S3I(s)->tmp.new_cipher;
		if (!s->method->internal->ssl3_enc->setup_key_block(s))
			return (0);
	}

	if (!s->method->internal->ssl3_enc->change_cipher_state(s, i))
		return (0);

	/* we have to record the message digest at
	 * this point so we can get it before we read
	 * the finished message */
	if (s->internal->state & SSL_ST_CONNECT) {
		sender = s->method->internal->ssl3_enc->server_finished_label;
		slen = s->method->internal->ssl3_enc->server_finished_label_len;
	} else {
		sender = s->method->internal->ssl3_enc->client_finished_label;
		slen = s->method->internal->ssl3_enc->client_finished_label_len;
	}

	i = s->method->internal->ssl3_enc->final_finish_mac(s, sender, slen,
	    S3I(s)->tmp.peer_finish_md);
	if (i == 0) {
		SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);
		return 0;
	}
	S3I(s)->tmp.peer_finish_md_len = i;

	return (1);
}

int
ssl3_send_alert(SSL *s, int level, int desc)
{
	/* Map tls/ssl alert value to correct one */
	desc = s->method->internal->ssl3_enc->alert_value(desc);
	if (desc < 0)
		return -1;
	/* If a fatal one, remove from cache */
	if ((level == 2) && (s->session != NULL))
		SSL_CTX_remove_session(s->ctx, s->session);

	s->s3->alert_dispatch = 1;
	s->s3->send_alert[0] = level;
	s->s3->send_alert[1] = desc;
	if (s->s3->wbuf.left == 0) /* data still being written out? */
		return s->method->ssl_dispatch_alert(s);

	/* else data is still being written out, we will get written
	 * some time in the future */
	return -1;
}

int
ssl3_dispatch_alert(SSL *s)
{
	int i, j;
	void (*cb)(const SSL *ssl, int type, int val) = NULL;

	s->s3->alert_dispatch = 0;
	i = do_ssl3_write(s, SSL3_RT_ALERT, &s->s3->send_alert[0], 2, 0);
	if (i <= 0) {
		s->s3->alert_dispatch = 1;
	} else {
		/* Alert sent to BIO.  If it is important, flush it now.
		 * If the message does not get sent due to non-blocking IO,
		 * we will not worry too much. */
		if (s->s3->send_alert[0] == SSL3_AL_FATAL)
			(void)BIO_flush(s->wbio);

		if (s->internal->msg_callback)
			s->internal->msg_callback(1, s->version, SSL3_RT_ALERT,
			    s->s3->send_alert, 2, s, s->internal->msg_callback_arg);

		if (s->internal->info_callback != NULL)
			cb = s->internal->info_callback;
		else if (s->ctx->internal->info_callback != NULL)
			cb = s->ctx->internal->info_callback;

		if (cb != NULL) {
			j = (s->s3->send_alert[0]<<8)|s->s3->send_alert[1];
			cb(s, SSL_CB_WRITE_ALERT, j);
		}
	}
	return (i);
}
@


1.70
log
@Merge the client/server version negotiation into the existing (currently
fixed version) client/server code.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.69 2017/01/25 06:13:02 jsing Exp $ */
@


1.69
log
@Provide ssl3_packet_read() and ssl3_packet_extend() functions that improve
the awkward API provided by ssl3_read_n(). Call these when we need to
read or extend a packet.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.68 2017/01/23 14:35:42 jsing Exp $ */
d336 1
d339 7
a345 1
		CBS_init(&header, s->internal->packet, n);
@


1.68
log
@Move options and mode from SSL_CTX and SSL to internal, since these can be
set and cleared via existing functions.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.67 2017/01/23 13:36:13 jsing Exp $ */
d133 1
a133 1
int
d266 1
d270 32
d332 1
a332 1
		n = ssl3_read_n(s, SSL3_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);
d334 2
a335 1
			return(n); /* error or non-blocking */
d382 5
a386 9
	if (rr->length > s->internal->packet_length - SSL3_RT_HEADER_LENGTH) {
		/* now s->internal->packet_length == SSL3_RT_HEADER_LENGTH */
		i = rr->length;
		n = ssl3_read_n(s, i, i, 1);
		if (n <= 0)
			return(n); /* error or non-blocking io */
		/* now n == rr->length,
		 * and s->internal->packet_length == SSL3_RT_HEADER_LENGTH + rr->length */
	}
d388 1
a388 1
	s->internal->rstate=SSL_ST_READ_HEADER; /* set state for later operations */
@


1.67
log
@Split most of SSL_METHOD out into an internal variant, which is opaque.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.66 2017/01/23 08:48:44 beck Exp $ */
d241 1
a241 1
			if (s->mode & SSL_MODE_RELEASE_BUFFERS &&
d543 1
a543 1
		    (s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))) {
d773 1
a773 1
	    !(s->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER)) ||
d793 1
a793 1
			if (s->mode & SSL_MODE_RELEASE_BUFFERS &&
d986 1
a986 1
				if (s->mode & SSL_MODE_RELEASE_BUFFERS &&
d1071 1
a1071 1
				if (!(s->mode & SSL_MODE_AUTO_RETRY)) {
d1233 1
a1233 1
		if (!(s->mode & SSL_MODE_AUTO_RETRY)) {
@


1.66
log
@send state and rstate from ssl_st into internal. There are accessors
so these should not be diddled with directly
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.65 2017/01/23 08:08:06 beck Exp $ */
d385 1
a385 1
	enc_err = s->method->ssl3_enc->enc(s, 0);
d441 1
a441 1
		i = s->method->ssl3_enc->mac(s,md,0 /* not send */);
d713 1
a713 1
		if (s->method->ssl3_enc->mac(s,
d730 1
a730 1
	s->method->ssl3_enc->enc(s, 1);
d1326 1
a1326 1
		if (!s->method->ssl3_enc->setup_key_block(s))
d1330 1
a1330 1
	if (!s->method->ssl3_enc->change_cipher_state(s, i))
d1337 2
a1338 2
		sender = s->method->ssl3_enc->server_finished_label;
		slen = s->method->ssl3_enc->server_finished_label_len;
d1340 2
a1341 2
		sender = s->method->ssl3_enc->client_finished_label;
		slen = s->method->ssl3_enc->client_finished_label_len;
d1344 1
a1344 1
	i = s->method->ssl3_enc->final_finish_mac(s, sender, slen,
d1359 1
a1359 1
	desc = s->method->ssl3_enc->alert_value(desc);
@


1.65
log
@move back read_hash and enc_read_ctx into ssl_st. wpa_supplicant and
other perversions touches them sickly and unnaturally.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.64 2017/01/23 06:45:30 beck Exp $ */
d293 1
a293 1
	if ((s->rstate != SSL_ST_READ_BODY) ||
d302 1
a302 1
		s->rstate = SSL_ST_READ_BODY;
d343 1
a343 1
		/* now s->rstate == SSL_ST_READ_BODY */
d346 1
a346 1
	/* s->rstate == SSL_ST_READ_BODY, get and decode the data */
d358 1
a358 1
	s->rstate=SSL_ST_READ_HEADER; /* set state for later operations */
d669 1
a669 1
	if (s->state == SSL3_ST_CW_CLNT_HELLO_B && !s->internal->renegotiate &&
d932 1
a932 1
	if ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY)) {
d984 1
a984 1
				s->rstate = SSL_ST_READ_HEADER;
d1218 1
a1218 1
		if (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&
d1220 1
a1220 1
			s->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;
d1283 6
a1288 6
		    (((s->state & SSL_ST_CONNECT) &&
		    (s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&
		    (s->state <= SSL3_ST_CR_SRVR_HELLO_A)) ||
		    ((s->state & SSL_ST_ACCEPT) &&
		    (s->state <= SSL3_ST_SW_HELLO_REQ_A) &&
		    (s->state >= SSL3_ST_SR_CLNT_HELLO_A)))) {
d1312 1
a1312 1
	if (s->state & SSL_ST_ACCEPT)
d1336 1
a1336 1
	if (s->state & SSL_ST_CONNECT) {
@


1.64
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.63 2017/01/23 04:55:26 beck Exp $ */
d398 3
a400 3
	if ((sess != NULL) && (s->internal->enc_read_ctx != NULL) &&
	    (EVP_MD_CTX_md(s->internal->read_hash) != NULL)) {
		/* s->internal->read_hash != NULL => mac_size != -1 */
d404 1
a404 1
		mac_size = EVP_MD_CTX_size(s->internal->read_hash);
d417 1
a417 1
		    (EVP_CIPHER_CTX_mode(s->internal->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
d424 1
a424 1
		if (EVP_CIPHER_CTX_mode(s->internal->enc_read_ctx) == EVP_CIPH_CBC_MODE) {
d963 1
a963 1
			(s->internal->enc_read_ctx == NULL)) {
@


1.63
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.62 2017/01/23 04:15:28 jsing Exp $ */
d129 3
a131 3
 * by s->packet and s->packet_length.
 * (If s->read_ahead is set, 'max' bytes may be stored in rbuf
 * [plus s->packet_length bytes if extend == 1].)
d174 2
a175 2
		s->packet = rb->buf + rb->offset;
		s->packet_length = 0;
d189 1
a189 1
		s->packet_length += n;
d197 1
a197 1
	len = s->packet_length;
d202 1
a202 1
	if (s->packet != pkt)  {
d204 2
a205 2
		memmove(pkt, s->packet, len + left);
		s->packet = pkt;
d215 1
a215 1
	if (!s->read_ahead) {
d232 1
a232 1
			s->rwstate = SSL_READING;
d264 2
a265 2
	s->packet_length += n;
	s->rwstate = SSL_NOTHING;
d294 1
a294 1
	    (s->packet_length < SSL3_RT_HEADER_LENGTH)) {
d304 1
a304 1
		CBS_init(&header, s->packet, n);
d319 1
a319 1
		if (!s->first_packet && ssl_version != s->version) {
d323 1
a323 1
			    !s->enc_write_ctx && !s->write_hash)
d348 2
a349 2
	if (rr->length > s->packet_length - SSL3_RT_HEADER_LENGTH) {
		/* now s->packet_length == SSL3_RT_HEADER_LENGTH */
d355 1
a355 1
		 * and s->packet_length == SSL3_RT_HEADER_LENGTH + rr->length */
d360 2
a361 2
	/* At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,
	 * and we have that many bytes in s->packet
d363 1
a363 1
	rr->input = &(s->packet[SSL3_RT_HEADER_LENGTH]);
d365 1
a365 1
	/* ok, we can now read from 's->packet' data into 'rr'
d398 3
a400 3
	if ((sess != NULL) && (s->enc_read_ctx != NULL) &&
	    (EVP_MD_CTX_md(s->read_hash) != NULL)) {
		/* s->read_hash != NULL => mac_size != -1 */
d404 1
a404 1
		mac_size = EVP_MD_CTX_size(s->read_hash);
d417 1
a417 1
		    (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
d424 1
a424 1
		if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {
d483 1
a483 1
	s->packet_length = 0;
d512 1
a512 1
	s->rwstate = SSL_NOTHING;
d599 3
a601 3
	if ((sess == NULL) || (s->enc_write_ctx == NULL) ||
	    (EVP_MD_CTX_md(s->write_hash) == NULL)) {
		clear = s->enc_write_ctx ? 0 : 1; /* must be AEAD cipher */
d604 1
a604 1
		mac_size = EVP_MD_CTX_size(s->write_hash);
d669 1
a669 1
	if (s->state == SSL3_ST_CW_CLNT_HELLO_B && !s->renegotiate &&
d680 2
a681 2
	if (s->enc_write_ctx && SSL_USE_EXPLICIT_IV(s)) {
		int mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);
d683 1
a683 1
			eivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);
d692 3
a694 3
	} else if (s->aead_write_ctx != NULL &&
	    s->aead_write_ctx->variable_nonce_in_record) {
		eivlen = s->aead_write_ctx->variable_nonce_len;
d782 1
a782 1
			s->rwstate = SSL_WRITING;
d796 1
a796 1
			s->rwstate = SSL_NOTHING;
d917 1
a917 1
		s->rwstate = SSL_READING;
d921 1
a921 1
	s->rwstate = SSL_NOTHING;
d951 1
a951 1
	if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {
d953 1
a953 1
		s->rwstate = SSL_NOTHING;
d963 1
a963 1
			(s->enc_read_ctx == NULL)) {
d1078 1
a1078 1
						s->rwstate = SSL_READING;
d1129 1
a1129 1
				s->shutdown |= SSL_RECEIVED_SHUTDOWN;
d1148 1
a1148 1
			s->rwstate = SSL_NOTHING;
d1154 1
a1154 1
			s->shutdown |= SSL_RECEIVED_SHUTDOWN;
d1166 1
a1166 1
	if (s->shutdown & SSL_SENT_SHUTDOWN) {
d1168 1
a1168 1
		s->rwstate = SSL_NOTHING;
d1221 2
a1222 2
			s->renegotiate = 1;
			s->new_session = 1;
d1240 1
a1240 1
				s->rwstate = SSL_READING;
@


1.62
log
@Move callback function pointers and argument pointers from SSL_CTX to
internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.61 2017/01/22 09:02:07 jsing Exp $ */
d516 2
a517 2
	if (SSL_in_init(s) && !s->in_handshake) {
		i = s->handshake_func(s);
d889 1
a889 1
	if (!s->in_handshake && SSL_in_init(s)) {
d891 1
a891 1
		i = s->handshake_func(s);
d1052 2
a1053 2
		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
d1055 1
a1055 1
			    s->msg_callback_arg);
d1062 1
a1062 1
				i = s->handshake_func(s);
d1112 3
a1114 3
		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_ALERT,
			    S3I(s)->alert_fragment, 2, s, s->msg_callback_arg);
d1116 2
a1117 2
		if (s->info_callback != NULL)
			cb = s->info_callback;
d1203 2
a1204 2
		if (s->msg_callback) {
			s->msg_callback(0, s->version,
d1206 1
a1206 1
			    s->msg_callback_arg);
d1217 1
a1217 1
	if ((S3I(s)->handshake_fragment_len >= 4) && !s->in_handshake) {
d1224 1
a1224 1
		i = s->handshake_func(s);
d1268 1
a1268 1
		 * of SSL3_RT_HANDSHAKE when s->in_handshake is set, but that
d1394 3
a1396 3
		if (s->msg_callback)
			s->msg_callback(1, s->version, SSL3_RT_ALERT,
			    s->s3->send_alert, 2, s, s->msg_callback_arg);
d1398 2
a1399 2
		if (s->info_callback != NULL)
			cb = s->info_callback;
@


1.61
log
@Move most of the SSL3_STATE fields to internal - the ones that remain are
known to be used by ports.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.60 2016/11/17 15:06:22 jsing Exp $ */
d1118 2
a1119 2
		else if (s->ctx->info_callback != NULL)
			cb = s->ctx->info_callback;
d1400 2
a1401 2
		else if (s->ctx->info_callback != NULL)
			cb = s->ctx->info_callback;
@


1.60
log
@Use defines instead of magic numbers and comments.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.59 2016/11/03 16:23:30 jsing Exp $ */
d273 3
a275 3
 * ssl->s3->rrec.type    - is the type of record
 * ssl->s3->rrec.data, 	 - data
 * ssl->s3->rrec.length, - number of bytes
d288 1
a288 1
	rr = &(s->s3->rrec);
d475 4
a478 4
	 * ssl->s3->rrec.type 	is the type of record
	 * ssl->s3->rrec.length	== number of bytes in record
	 * ssl->s3->rrec.off	== offset to first valid byte
	 * ssl->s3->rrec.data	== where to take bytes from, increment
d513 2
a514 2
	tot = s->s3->wnum;
	s->s3->wnum = 0;
d538 1
a538 1
			s->s3->wnum = tot;
d549 1
a549 1
			s->s3->empty_fragment_done = 0;
d596 1
a596 1
	wr = &(s->s3->wrec);
d613 1
a613 1
	if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done) {
d618 1
a618 1
		if (s->s3->need_empty_fragments &&
d637 1
a637 1
		s->s3->empty_fragment_done = 1;
d753 4
a756 4
	s->s3->wpend_tot = len;
	s->s3->wpend_buf = buf;
	s->s3->wpend_type = type;
	s->s3->wpend_ret = len;
d772 1
a772 1
	if ((s->s3->wpend_tot > (int)len) || ((s->s3->wpend_buf != buf) &&
d774 1
a774 1
	    (s->s3->wpend_type != type)) {
d797 1
a797 1
			return (s->s3->wpend_ret);
d865 1
a865 1
	    (s->s3->handshake_fragment_len > 0)) {
d867 1
a867 1
		unsigned char *src = s->s3->handshake_fragment;
d873 1
a873 1
		while ((len > 0) && (s->s3->handshake_fragment_len > 0)) {
d876 1
a876 1
			s->s3->handshake_fragment_len--;
d880 2
a881 2
		for (k = 0; k < s->s3->handshake_fragment_len; k++)
			s->s3->handshake_fragment[k] = *src++;
d886 1
a886 1
	 * Now s->s3->handshake_fragment_len == 0 if
d924 4
a927 4
	 * s->s3->rrec.type	    - is the type of record
	 * s->s3->rrec.data,    - data
	 * s->s3->rrec.off,     - offset into 'data' for next read
	 * s->s3->rrec.length,  - number of bytes.
d929 1
a929 1
	rr = &(s->s3->rrec);
d940 1
a940 1
	if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,
d1009 3
a1011 3
			dest_maxlen = sizeof s->s3->handshake_fragment;
			dest = s->s3->handshake_fragment;
			dest_len = &s->s3->handshake_fragment_len;
d1013 3
a1015 3
			dest_maxlen = sizeof s->s3->alert_fragment;
			dest = s->s3->alert_fragment;
			dest_len = &s->s3->alert_fragment_len;
d1034 2
a1035 2
	/* s->s3->handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;
	 * s->s3->alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.
d1039 2
a1040 2
	if ((!s->server) && (s->s3->handshake_fragment_len >= 4) &&
	    (s->s3->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&
d1042 1
a1042 1
		s->s3->handshake_fragment_len = 0;
d1044 3
a1046 3
		if ((s->s3->handshake_fragment[1] != 0) ||
		    (s->s3->handshake_fragment[2] != 0) ||
		    (s->s3->handshake_fragment[3] != 0)) {
d1054 1
a1054 1
			    s->s3->handshake_fragment, 4, s,
d1059 1
a1059 1
		    !s->s3->renegotiate) {
d1097 3
a1099 3
	    !s->s3->send_connection_binding &&
	    (s->s3->handshake_fragment_len >= 4) &&
	    (s->s3->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&
d1101 1
a1101 1
		/*s->s3->handshake_fragment_len = 0;*/
d1106 3
a1108 3
	if (s->s3->alert_fragment_len >= 2) {
		int alert_level = s->s3->alert_fragment[0];
		int alert_descr = s->s3->alert_fragment[1];
d1110 1
a1110 1
		s->s3->alert_fragment_len = 0;
d1114 1
a1114 1
			    s->s3->alert_fragment, 2, s, s->msg_callback_arg);
d1127 1
a1127 1
			s->s3->warn_alert = alert_descr;
d1149 1
a1149 1
			s->s3->fatal_alert = alert_descr;
d1185 1
a1185 1
		if (s->s3->tmp.new_cipher == NULL) {
d1209 1
a1209 1
		s->s3->change_cipher_spec = 1;
d1217 1
a1217 1
	if ((s->s3->handshake_fragment_len >= 4) && !s->in_handshake) {
d1281 2
a1282 2
		if (s->s3->in_read_app_data &&
		    (s->s3->total_renegotiations != 0) &&
d1289 1
a1289 1
			s->s3->in_read_app_data = 2;
d1317 1
a1317 1
	if (s->s3->tmp.key_block == NULL) {
d1325 1
a1325 1
		s->session->cipher = s->s3->tmp.new_cipher;
d1345 1
a1345 1
	    s->s3->tmp.peer_finish_md);
d1350 1
a1350 1
	s->s3->tmp.peer_finish_md_len = i;
@


1.59
log
@In ssl3_read_bytes(), do not process more than three consecutive TLS
records, otherwise a peer can potentially cause us to loop indefinately.
Return with an SSL_ERROR_WANT_READ instead, so that the caller can choose
when they want to handle further processing for this connection.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.58 2016/07/10 23:07:34 tedu Exp $ */
d1126 1
a1126 2
		if (alert_level == 1) {
			/* warning */
d1147 1
a1147 2
		} else if (alert_level == 2) {
			/* fatal */
@


1.58
log
@zero the read buffer after copying data to user so it doesn't linger.
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.57 2015/09/12 16:10:07 doug Exp $ */
d842 2
a843 1
	int al, i, j, ret;
d846 1
a846 1
	void (*cb)(const SSL *ssl, int type2, int val) = NULL;
d900 1
d902 19
a1073 1
						BIO *bio;
@


1.57
log
@Remove most of the SSLv3 version checks and a few TLS v1.0.

We can now assume >= TLS v1.0 since SSL2_VERSION, SSL3_VERSION and
DTLS1_BAD_VER support was removed.

"reads ok" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.56 2015/07/24 02:39:43 doug Exp $ */
d959 1
@


1.57.2.1
log
@backport patch from openssl for multiple issues:
missing padding check in aesni functions
overflow in evp encode functions
use of invalid negative asn.1 types
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.57 2015/09/12 16:10:07 doug Exp $ */
a958 1
			memset(&(rr->data[rr->off]), 0, n);
@


1.57.2.2
log
@this chunk was NOT supposed to be committed. spotted by jsg.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.57.2.1 2016/05/03 12:39:48 tedu Exp $ */
d959 1
@


1.56
log
@Convert ssl3_get_record to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.55 2015/07/18 19:41:54 doug Exp $ */
a1076 1
	    (s->version > SSL3_VERSION) &&
a1340 4
	if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION) {
		/* SSL 3.0 does not have protocol_version alerts */
		desc = SSL_AD_HANDSHAKE_FAILURE;
	}
@


1.55
log
@Remove SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER workaround.

This was a hack to work around problems on IE 6 with SSLv3.

ok miod@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.54 2014/12/14 21:49:29 bcook Exp $ */
d120 2
d281 1
a281 1
	int ssl_major, ssl_minor, al;
a284 1
	unsigned char *p;
a285 1
	short version;
d295 4
d304 1
a304 1
		p = s->packet;
d307 10
a316 5
		rr->type= *(p++);
		ssl_major= *(p++);
		ssl_minor= *(p++);
		version = (ssl_major << 8)|ssl_minor;
		n2s(p, rr->length);
d319 9
a327 11
		if (!s->first_packet) {
			if (version != s->version) {
				SSLerr(SSL_F_SSL3_GET_RECORD,
				    SSL_R_WRONG_VERSION_NUMBER);
				if ((s->version & 0xFF00) == (version & 0xFF00) &&
				    !s->enc_write_ctx && !s->write_hash)
					/* Send back error using their minor version number :-) */
					s->version = (unsigned short)version;
				al = SSL_AD_PROTOCOL_VERSION;
				goto f_err;
			}
d330 1
a330 1
		if ((version >> 8) != SSL3_VERSION_MAJOR) {
@


1.54
log
@unconditionally align SSL payloads

Remove support for conditional payload alignment, since we would never
want to turn it off. Also, consistently use size_t for calculating the
alignment.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.53 2014/12/14 15:30:50 jsing Exp $ */
a286 1
	size_t extra;
a290 12
	if (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)
		extra = SSL3_RT_MAX_EXTRA;
	else
		extra = 0;

	if (extra && !s->s3->init_extra) {
		/* An application error: SLS_OP_MICROSOFT_BIG_SSLV3_BUFFER
		 * set after ssl3_setup_buffers() was done */
		SSLerr(SSL_F_SSL3_GET_RECORD, ERR_R_INTERNAL_ERROR);
		return -1;
	}

d369 1
a369 1
	if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH + extra) {
d439 1
a439 1
		    SSL3_RT_MAX_COMPRESSED_LENGTH + extra + mac_size)
d458 1
a458 1
	if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH + extra) {
@


1.53
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.52 2014/11/16 14:12:47 jsing Exp $ */
d135 1
a135 1
	long align = 0;
d148 2
a149 4
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
	align = (long)rb->buf + SSL3_RT_HEADER_LENGTH;
	align = (-align)&(SSL3_ALIGN_PAYLOAD - 1);
#endif
d573 1
a573 1
	long align = 0;
a646 1
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
d651 3
a653 3
		align = (long)wb->buf + 2*SSL3_RT_HEADER_LENGTH;
		align = (-align)&(SSL3_ALIGN_PAYLOAD - 1);
#endif
d659 3
a661 4
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
		align = (long)wb->buf + SSL3_RT_HEADER_LENGTH;
		align = (-align)&(SSL3_ALIGN_PAYLOAD - 1);
#endif
@


1.52
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.51 2014/10/18 16:13:16 jsing Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d378 1
a378 1
	 * rr->input will be pointed at the new buffer */ 
@


1.51
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.50 2014/07/12 13:11:53 jsing Exp $ */
d112 1
d114 1
a114 1
#include <errno.h>
d116 2
a118 1
#include <openssl/buffer.h>
@


1.50
log
@Remove remnants from PSK, KRB5 and SRP.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.49 2014/07/10 08:51:14 tedu Exp $ */
a116 1
#include <openssl/rand.h>
@


1.49
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.48 2014/06/19 21:29:51 tedu Exp $ */
a1136 4
#ifdef SSL_AD_MISSING_SRP_USERNAME
			else if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)
				return (0);
#endif
@


1.48
log
@convert CRYPTO_memcmp to timingsafe_memcmp based on current policy favoring
libc interfaces over libcrypto interfaces. for now we also prefer
timingsafe_memcmp over timingsafe_bcmp, even when the latter is acceptable.
ok beck deraadt matthew miod
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.47 2014/06/13 10:52:24 jsing Exp $ */
a471 15
	/* r->length is now just compressed */
	if (s->expand != NULL) {
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + extra) {
			al = SSL_AD_RECORD_OVERFLOW;
			SSLerr(SSL_F_SSL3_GET_RECORD,
			    SSL_R_COMPRESSED_LENGTH_TOO_LONG);
			goto f_err;
		}
		if (!ssl3_do_uncompress(s)) {
			al = SSL_AD_DECOMPRESSION_FAILURE;
			SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_DECOMPRESSION);
			goto f_err;
		}
	}

a503 40
int
ssl3_do_uncompress(SSL *ssl)
{
#ifndef OPENSSL_NO_COMP
	int i;
	SSL3_RECORD *rr;

	rr = &(ssl->s3->rrec);
	i = COMP_expand_block(ssl->expand, rr->comp,
	SSL3_RT_MAX_PLAIN_LENGTH, rr->data, (int)rr->length);
	if (i < 0)
		return (0);
	else
		rr->length = i;
	rr->data = rr->comp;
#endif
	return (1);
}

int
ssl3_do_compress(SSL *ssl)
{
#ifndef OPENSSL_NO_COMP
	int i;
	SSL3_RECORD *wr;

	wr = &(ssl->s3->wrec);
	i = COMP_compress_block(ssl->compress, wr->data,
	    SSL3_RT_MAX_COMPRESSED_LENGTH,
	    wr->input, (int)wr->length);
	if (i < 0)
		return (0);
	else
		wr->length = i;

	wr->input = wr->data;
#endif
	return (1);
}

d714 2
a715 10
	/* first we compress */
	if (s->compress != NULL) {
		if (!ssl3_do_compress(s)) {
			SSLerr(SSL_F_DO_SSL3_WRITE, SSL_R_COMPRESSION_FAILURE);
			goto err;
		}
	} else {
		memcpy(wr->data, wr->input, wr->length);
		wr->input = wr->data;
	}
@


1.47
log
@Add an SSL_AEAD_CTX to enable the use of EVP_AEAD with an SSL cipher.
Read and write contexts are also added to the SSL_CTX, along with
supporting code.

Based on Adam Langley's chromium diffs.

Rides the recent SSL library bump.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_pkt.c,v 1.46 2014/06/12 15:49:31 deraadt Exp $ */
d450 1
a450 1
		    CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
@


1.46
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d756 3
@


1.45
log
@Disable TLS support...

Just kidding!

unifdef OPENSSL_NO_TLS since we will never want to actually do that.

ok deraadt@@
@
text
@d1 1
a1 1
/* ssl/s3_pkt.c */
@


1.44
log
@More KNF.
@
text
@a1306 1
#ifndef OPENSSL_NO_TLS
a1315 1
#endif
@


1.43
log
@Ensure that we do not process a ChangeCipherSpec with an empty master
secret. This is an additional safeguard against early ChangeCipherSpec
handling.

From OpenSSL.

ok deraadt@@
@
text
@d248 6
a253 3
		/* reads should *never* span multiple packets for DTLS because
		 * the underlying transport protocol is message oriented as opposed
		 * to byte oriented as in the TLS case. */
d338 2
a339 1
			SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);
d345 2
a346 1
			SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);
d452 2
a453 1
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + extra + mac_size)
d458 8
a465 5
		/* A separate 'decryption_failed' alert was introduced with TLS 1.0,
		 * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption
		 * failure is directly visible from the ciphertext anyway,
		 * we should not reveal which kind of error occured -- this
		 * might become visible to an attacker (e.g. via a logfile) */
d467 2
a468 1
		SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
d476 2
a477 1
			SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);
d583 2
a584 1
			SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
d606 5
a610 2
			/* next chunk of data should get another prepended empty fragment
			 * in ciphersuites with known-IV weakness: */
d671 4
a674 1
	/* 'create_empty_fragment' is true only when this function calls itself */
d676 6
a681 4
		/* countermeasure against known-IV weakness in CBC ciphersuites
		 * (see http://www.openssl.org/~bodo/tls-cbc.txt) */

		if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) {
d693 2
a694 1
				SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);
d782 2
a783 1
		if (s->method->ssl3_enc->mac(s, &(p[wr->length + eivlen]), 1) < 0)
d835 1
a835 2
ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
    unsigned int len)
d925 2
a926 2
	if ((type &&
	     type != SSL3_RT_APPLICATION_DATA && type != SSL3_RT_HANDSHAKE) ||
d932 2
a933 1
	if ((type == SSL3_RT_HANDSHAKE) && (s->s3->handshake_fragment_len > 0)) {
d953 4
a956 2
	/* Now s->s3->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE. */

d963 2
a964 1
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
d992 2
a993 1
		SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);
d1006 2
a1007 1
	if (type == rr->type) { /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */
d1013 2
a1014 1
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);
d1065 2
a1066 1
			n = dest_maxlen - *dest_len; /* available space in 'dest' */
d1101 2
a1102 1
			    s->s3->handshake_fragment, 4, s, s->msg_callback_arg);
d1113 2
a1114 1
					SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
d1193 2
a1194 1
				SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION);
d1205 2
a1206 1
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);
d1209 1
a1209 1
			s->shutdown|=SSL_RECEIVED_SHUTDOWN;
d1234 2
a1235 1
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_CHANGE_CIPHER_SPEC);
d1242 2
a1243 1
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);
d1250 2
a1251 1
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);
d1283 2
a1284 1
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
d1308 2
a1309 1
		/* TLS up to v1.1 just ignores unknown message types:
d1312 2
a1313 1
		if (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION) {
d1340 1
a1340 2
		    ((
		    (s->state & SSL_ST_CONNECT) &&
d1342 2
a1343 3
		    (s->state <= SSL3_ST_CR_SRVR_HELLO_A)
		    ) || (
		    (s->state & SSL_ST_ACCEPT) &&
d1345 1
a1345 3
		    (s->state >= SSL3_ST_SR_CLNT_HELLO_A)
		    )
		    )) {
d1401 2
a1402 2
	i = s->method->ssl3_enc->final_finish_mac(s,
	sender, slen, s->s3->tmp.peer_finish_md);
@


1.42
log
@Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret.

For a detailed analysis see:

  https://www.imperialviolet.org/2014/06/05/earlyccs.html

This is a fix for CVE-2014-0224, from OpenSSL.

This issue was reported to OpenSSL by KIKUCHI Masashi. Unfortunately the
recent OpenSSL commit was the first we were made aware of the issue.

ok deraadt@@ sthen@@
@
text
@d1340 1
a1340 1
		if (s->session == NULL) {
@


1.41
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@d1212 8
@


1.40
log
@Make use of SSL_IS_DTLS, SSL_USE_EXPLICIT_IV, SSL_USE_SIGALGS and
SSL_USE_TLS1_2_CIPHERS.

Largely based on OpenSSL head.
@
text
@a647 1
#if 1
a648 3
#else
		clear = 1;
#endif
@


1.39
log
@Remove redundant test introduced in s3_pkt.c on 20001225, which got cargo-culted
(with an XXX comment, though) in d1_pkt.c in 2005.
@
text
@d181 1
a181 1
	if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER) {
d241 1
a241 2
			    SSL_version(s) != DTLS1_VERSION &&
			    SSL_version(s) != DTLS1_BAD_VER)
d244 1
d251 1
a251 2
		if (SSL_version(s) == DTLS1_VERSION ||
		    SSL_version(s) == DTLS1_BAD_VER) {
d724 1
d726 2
a727 3
	p += 2;
	/* Explicit IV length, block ciphers and TLS version 1.1 or later */
	if (s->enc_write_ctx && s->version >= TLS1_1_VERSION) {
d846 1
a846 2
			    SSL_version(s) != DTLS1_VERSION &&
			    SSL_version(s) != DTLS1_BAD_VER)
d851 5
a855 4
			if (s->version == DTLS1_VERSION ||
			    s->version == DTLS1_BAD_VER) {
				/* For DTLS, just drop it. That's kind of the whole
				   point in using a datagram service */
a856 1
			}
@


1.38
log
@Remove TLS_DEBUG, SSL_DEBUG, CIPHER_DEBUG and OPENSSL_RI_DEBUG. Much of
this is sporadic, hacked up and can easily be put back in an improved form
should we ever need it.

ok miod@@
@
text
@d910 2
a911 2
	if ((type && (type != SSL3_RT_APPLICATION_DATA) &&
	    (type != SSL3_RT_HANDSHAKE) && type) ||
@


1.37
log
@Constrain bytes read/written to positive values.
ok miod@@ tedu@@
@
text
@a398 5
#ifdef TLS_DEBUG
	printf("dec %d\n", rr->length);
	{ unsigned int z; for (z = 0; z<rr->length; z++) printf("%02X%c", rr->data[z],((z+1)%16)?' ':'\n'); }
	printf("\n");
#endif
@


1.36
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d564 5
d909 5
@


1.35
log
@rearrange a bit of code/comments
@
text
@a1171 2
			char tmp[16];

d1175 2
a1176 2
			(void) snprintf(tmp, sizeof tmp, "%d", alert_descr);
			ERR_add_error_data(2, "SSL alert number ", tmp);
@


1.34
log
@A fantastic way to make a large unsigned number is to assign
a small signed one to it.. Some people on OpenSSL's list
noticed - http://marc.info/?l=openssl-dev&m=139809485525663&w=2

This should fix that, and make sure we don't try to write out insane
amounts of stuff.
ok miod@@ tedu@@
@
text
@d123 7
a132 7
	/* If extend == 0, obtain new n-byte packet; if extend == 1, increase
	 * packet by another n bytes.
	 * The packet will be in the sub-array of s->s3->rbuf.buf specified
	 * by s->packet and s->packet_length.
	 * (If s->read_ahead is set, 'max' bytes may be stored in rbuf
	 * [plus s->packet_length bytes if extend == 1].)
	 */
d160 2
a161 2
			if (pkt[0] == SSL3_RT_APPLICATION_DATA
				&& (pkt[3]<<8|pkt[4]) >= 128) {
d169 1
a169 1
				memmove (rb->buf + align, pkt, left);
d201 2
a202 2
	if (s->packet != pkt) /* len > 0 */
	{
d208 2
a209 2
	if (n > (int)(rb->len - rb->offset)) /* does not happen */
	{
d214 1
a214 1
	if (!s->read_ahead)
d217 1
a217 1
	else {
d241 4
a244 3
				SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)
			if (len + left == 0)
				ssl3_release_read_buffer(s);
d251 2
a252 1
		if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER) {
d295 1
d308 3
a310 2
		if (n <= 0) return(n); /* error or non-blocking */
			s->rstate = SSL_ST_READ_BODY;
d324 4
a327 2
				SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);
				if ((s->version & 0xFF00) == (version & 0xFF00) && !s->enc_write_ctx && !s->write_hash)
d329 1
a329 1
				s->version = (unsigned short)version;
d355 2
a356 1
		if (n <= 0) return(n); /* error or non-blocking io */
d411 1
d449 3
a451 2
		i=s->method->ssl3_enc->mac(s,md,0 /* not send */);
		if (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
d489 3
a491 1
	/* So at this point the following is true
d523 1
a523 1
	SSL3_RT_MAX_PLAIN_LENGTH, rr->data,(int)rr->length);
d542 2
a543 2
	SSL3_RT_MAX_COMPRESSED_LENGTH,
	wr->input,(int)wr->length);
d748 1
a748 2
	/* we now 'read' from wr->input, wr->length bytes into
	 * wr->data */
d803 2
a804 1
	/* memorize arguments so that ssl3_write_pending can detect bad write retries later */
d824 1
a824 1
/* XXXX */
d912 1
a912 1
	if ((type == SSL3_RT_HANDSHAKE) && (s->s3->handshake_fragment_len > 0))
a913 1
	{
d947 2
a948 1
	/* s->s3->rrec.type	    - is the type of record
d951 2
a952 1
	 * s->s3->rrec.length,  - number of bytes. */
d981 1
a981 2
	if (type == rr->type) /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */
	{
a1017 3
	/* In case of record types for which we have 'fragment' storage,
	 * fill that so that we can process the data at a fixed place.
	 */
d1019 5
d1072 2
a1073 1
			s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->s3->handshake_fragment, 4, s, s->msg_callback_arg);
d1089 2
a1090 2
					if (s->s3->rbuf.left == 0) /* no read-ahead left? */
					{
d1092 4
a1095 4
						/* In the case where we try to read application data,
						 * but we trigger an SSL handshake, we return -1 with
						 * the retry option set.  Otherwise renegotiation may
						 * cause nasty problems in the blocking world */
d1132 2
a1133 1
			s->msg_callback(0, s->version, SSL3_RT_ALERT, s->s3->alert_fragment, 2, s, s->msg_callback_arg);
d1145 2
a1146 2
		if (alert_level == 1) /* warning */
		{
d1170 2
a1171 2
		} else if (alert_level == 2) /* fatal */
		{
d1191 2
a1192 2
	if (s->shutdown & SSL_SENT_SHUTDOWN) /* but we have not received a shutdown */
	{
d1217 5
a1221 2
		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, rr->data, 1, s, s->msg_callback_arg);
d1247 1
a1247 2
			if (s->s3->rbuf.left == 0) /* no read-ahead left? */
			{
d1337 2
a1338 1
			SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC, SSL_R_CCS_RECEIVED_EARLY);
d1377 4
a1380 2
	if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)
		desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have protocol_version alerts */
d1392 1
d1416 2
a1417 1
			s->msg_callback(1, s->version, SSL3_RT_ALERT, s->s3->send_alert, 2, s, s->msg_callback_arg);
@


1.33
log
@on today's episode of things you didn't want to learn:
do_ssl3_write() is recursive. and not in the simple, obvious way, but in
the sneaky called through ssl3_dispatch_alert way. (alert level: fuchsia)
this then has a decent chance of releasing the buffer that we thought we
were going to use. check for this happening, and if the buffer has gone
missing, put another one back in place.
the direct recursive call is safe because it won't call ssl3_write_pending
which is the function that actually does do the writing and releasing.
as reported by David Ramos to openssl-dev:
http://marc.info/?l=openssl-dev&m=139809493725682&w=2
ok beck
@
text
@d567 2
@


1.32
log
@release buffers fix was lost in merge. put it back.
@
text
@d622 4
@


1.31
log
@More KNF and style consistency tweaks
@
text
@d989 2
a990 1
				if (s->mode & SSL_MODE_RELEASE_BUFFERS)
@


1.30
log
@Finish zapping SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION usage; only keep
the #define for compat, but document that it's a no-op now.  Also, neuter
the -legacy_renegotiation option to "openssl s_{client,server}"

ok beck@@
@
text
@d759 1
a759 1
	/*	if (RAND_pseudo_bytes(p, eivlen) <= 0)
d761 1
a761 1
*/
@


1.29
log
@whack a bunch of disabled code. ok beck lteo
@
text
@d1098 1
a1098 2
	    (s->session != NULL) && (s->session->cipher != NULL) &&
	    !(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
@


1.28
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@a315 3
#if 0
		fprintf(stderr, "Record type=%d, Length=%d\n", rr->type, rr->length);
#endif
a494 4
#if 0
	fprintf(stderr, "Ultimate Record type=%d, Length=%d\n", rr->type, rr->length);
#endif

a1209 6
#if 0 /* worked only because C operator preferences are not as expected (and
			* because this is not really needed for clients except for detecting
       * protocol violations): */
			s->state = SSL_ST_BEFORE |
			    (s->server) ? SSL_ST_ACCEPT : SSL_ST_CONNECT;
#else
a1210 1
#endif
@


1.27
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@a113 1
#define USE_SOCKETS
@


1.26
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@d1164 1
a1164 1
			BIO_snprintf(tmp, sizeof tmp, "%d", alert_descr);
@


1.25
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a1024 13
#ifndef OPENSSL_NO_HEARTBEATS
		else if (rr->type == TLS1_RT_HEARTBEAT) {
			tls1_process_heartbeat(s);

			/* Exit and notify application to read again */
			rr->length = 0;
			s->rwstate = SSL_READING;
			BIO_clear_retry_flags(SSL_get_rbio(s));
			BIO_set_retry_read(SSL_get_rbio(s));
			return (-1);
		}
#endif

@


1.24
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@d121 1
a121 1
			 unsigned int len, int create_empty_fragment);
d124 3
a126 2
int ssl3_read_n(SSL *s, int n, int max, int extend)
	{
d134 2
a135 2
	int i,len,left;
	long align=0;
d139 2
a140 1
	if (n <= 0) return n;
d142 1
a142 1
	rb    = &(s->s3->rbuf);
d147 1
a147 1
	left  = rb->left;
d150 1
a150 1
	align = (-align)&(SSL3_ALIGN_PAYLOAD-1);
d153 1
a153 2
	if (!extend)
		{
d157 1
a157 2
		else if (align != 0 && left >= SSL3_RT_HEADER_LENGTH)
			{
d162 1
a162 2
			    && (pkt[3]<<8|pkt[4]) >= 128)
				{
d170 1
a170 1
				memmove (rb->buf+align,pkt,left);
a171 1
				}
d173 1
d177 1
a177 1
		}
d182 1
a182 2
	if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
		{
d185 1
a185 1
		}
d188 6
a193 7
	if (left >= n)
		{
		s->packet_length+=n;
		rb->left=left-n;
		rb->offset+=n;
		return(n);
		}
d198 1
a198 1
	pkt = rb->buf+align;
d203 2
a204 2
		{
		memmove(pkt, s->packet, len+left);
d207 1
a207 1
		}
d210 2
a211 2
		{
		SSLerr(SSL_F_SSL3_READ_N,ERR_R_INTERNAL_ERROR);
d213 1
a213 1
		}
d218 1
a218 2
	else
		{
d223 1
a223 1
		}
d225 1
a225 2
	while (left < n)
		{
d231 5
a235 8
		if (s->rbio != NULL)
			{
			s->rwstate=SSL_READING;
			i=BIO_read(s->rbio,pkt+len+left, max-left);
			}
		else
			{
			SSLerr(SSL_F_SSL3_READ_N,SSL_R_READ_BIO_NOT_SET);
d237 1
a237 1
			}
d239 1
a239 2
		if (i <= 0)
			{
d242 6
a247 6
			    SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)
				if (len+left == 0)
					ssl3_release_read_buffer(s);
			return(i);
			}
		left+=i;
d251 1
a251 2
		if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
			{
a253 1
			}
d255 1
d261 3
a263 3
	s->rwstate=SSL_NOTHING;
	return(n);
	}
d274 5
a278 4
static int ssl3_get_record(SSL *s)
	{
	int ssl_major,ssl_minor,al;
	int enc_err,n,i,ret= -1;
d287 2
a288 2
	rr= &(s->s3->rrec);
	sess=s->session;
d291 1
a291 1
		extra=SSL3_RT_MAX_EXTRA;
d293 2
a294 3
		extra=0;
	if (extra && !s->s3->init_extra)
		{
d299 1
a299 1
		}
d303 3
a305 4
	if (	(s->rstate != SSL_ST_READ_BODY) ||
		(s->packet_length < SSL3_RT_HEADER_LENGTH)) 
		{
		n=ssl3_read_n(s, SSL3_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);
d307 1
a307 1
		s->rstate=SSL_ST_READ_BODY;
d309 1
a309 1
		p=s->packet;
d315 2
a316 2
		version=(ssl_major<<8)|ssl_minor;
		n2s(p,rr->length);
d318 1
a318 1
fprintf(stderr, "Record type=%d, Length=%d\n", rr->type, rr->length);
d322 7
a328 9
		if (!s->first_packet)
			{
			if (version != s->version)
				{
				SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);
                                if ((s->version & 0xFF00) == (version & 0xFF00) && !s->enc_write_ctx && !s->write_hash)
                                	/* Send back error using their minor version number :-) */
					s->version = (unsigned short)version;
				al=SSL_AD_PROTOCOL_VERSION;
a329 1
				}
d331 1
d333 2
a334 3
		if ((version>>8) != SSL3_VERSION_MAJOR)
			{
			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);
d336 1
a336 1
			}
d338 3
a340 4
		if (rr->length > s->s3->rbuf.len - SSL3_RT_HEADER_LENGTH)
			{
			al=SSL_AD_RECORD_OVERFLOW;
			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_PACKET_LENGTH_TOO_LONG);
d342 1
a342 1
			}
d345 1
a345 1
		}
d349 1
a349 2
	if (rr->length > s->packet_length-SSL3_RT_HEADER_LENGTH)
		{
d351 2
a352 2
		i=rr->length;
		n=ssl3_read_n(s,i,i,1);
d356 1
a356 1
		}
d363 1
a363 1
	rr->input= &(s->packet[SSL3_RT_HEADER_LENGTH]);
d376 3
a378 4
	if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)
		{
		al=SSL_AD_RECORD_OVERFLOW;
		SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
d380 1
a380 1
		}
d383 1
a383 1
	rr->data=rr->input;
d385 1
a385 1
	enc_err = s->method->ssl3_enc->enc(s,0);
d390 3
a392 4
	if (enc_err == 0)
		{
		al=SSL_AD_DECRYPTION_FAILED;
		SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
d394 1
a394 1
		}
d397 3
a399 3
printf("dec %d\n",rr->length);
{ unsigned int z; for (z=0; z<rr->length; z++) printf("%02X%c",rr->data[z],((z+1)%16)?' ':'\n'); }
printf("\n");
d403 2
a404 4
	if ((sess != NULL) &&
	    (s->enc_read_ctx != NULL) &&
	    (EVP_MD_CTX_md(s->read_hash) != NULL))
		{
d408 1
a408 1
		mac_size=EVP_MD_CTX_size(s->read_hash);
d412 1
a412 1
		orig_len = rr->length+((unsigned int)rr->type>>8);
d420 1
a420 1
		    /* CBC records must have a padding length byte too. */
d422 3
a424 4
		     orig_len < mac_size+1))
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);
d426 1
a426 1
			}
d428 1
a428 2
		if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE)
			{
d437 1
a437 3
			}
		else
			{
d443 1
a443 1
			}
d448 1
a448 1
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra+mac_size)
d450 1
a450 1
		}
d452 1
a452 2
	if (enc_err < 0)
		{
d458 2
a459 2
		al=SSL_AD_BAD_RECORD_MAC;
		SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
d461 1
a461 1
		}
d464 4
a467 6
	if (s->expand != NULL)
		{
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra)
			{
			al=SSL_AD_RECORD_OVERFLOW;
			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_COMPRESSED_LENGTH_TOO_LONG);
d469 4
a472 5
			}
		if (!ssl3_do_uncompress(s))
			{
			al=SSL_AD_DECOMPRESSION_FAILURE;
			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_BAD_DECOMPRESSION);
a473 1
			}
d475 1
d477 3
a479 4
	if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH+extra)
		{
		al=SSL_AD_RECORD_OVERFLOW;
		SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DATA_LENGTH_TOO_LONG);
d481 1
a481 1
		}
d483 1
a483 1
	rr->off=0;
d493 1
a493 1
	s->packet_length=0;
d496 2
a497 1
	if (rr->length == 0) goto again;
d500 1
a500 1
fprintf(stderr, "Ultimate Record type=%d, Length=%d\n", rr->type, rr->length);
d503 1
a503 1
	return(1);
d506 1
a506 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d508 2
a509 2
	return(ret);
	}
d511 3
a513 2
int ssl3_do_uncompress(SSL *ssl)
	{
d518 3
a520 3
	rr= &(ssl->s3->rrec);
	i=COMP_expand_block(ssl->expand,rr->comp,
		SSL3_RT_MAX_PLAIN_LENGTH,rr->data,(int)rr->length);
d522 1
a522 1
		return(0);
d524 2
a525 2
		rr->length=i;
	rr->data=rr->comp;
d527 2
a528 2
	return(1);
	}
d530 3
a532 2
int ssl3_do_compress(SSL *ssl)
	{
d537 4
a540 4
	wr= &(ssl->s3->wrec);
	i=COMP_compress_block(ssl->compress,wr->data,
		SSL3_RT_MAX_COMPRESSED_LENGTH,
		wr->input,(int)wr->length);
d542 1
a542 1
		return(0);
d544 1
a544 1
		wr->length=i;
d546 1
a546 1
	wr->input=wr->data;
d548 2
a549 2
	return(1);
	}
d554 5
a558 4
int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
	{
	const unsigned char *buf=buf_;
	unsigned int tot,n,nw;
d561 10
a570 11
	s->rwstate=SSL_NOTHING;
	tot=s->s3->wnum;
	s->s3->wnum=0;

	if (SSL_in_init(s) && !s->in_handshake)
		{
		i=s->handshake_func(s);
		if (i < 0) return(i);
		if (i == 0)
			{
			SSLerr(SSL_F_SSL3_WRITE_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
a571 1
			}
d573 1
d575 2
a576 3
	n=(len-tot);
	for (;;)
		{
d578 1
a578 1
			nw=s->max_send_fragment;
d580 1
a580 1
			nw=n;
d582 3
a584 4
		i=do_ssl3_write(s, type, &(buf[tot]), nw, 0);
		if (i <= 0)
			{
			s->s3->wnum=tot;
d586 1
a586 1
			}
d588 2
a589 4
		if ((i == (int)n) ||
			(type == SSL3_RT_APPLICATION_DATA &&
			 (s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE)))
			{
a592 3
			
			return tot+i;
			}
d594 1
a594 2
		n-=i;
		tot+=i;
d596 3
d600 1
d602 7
a608 6
static int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
			 unsigned int len, int create_empty_fragment)
	{
	unsigned char *p,*plen;
	int i,mac_size,clear=0;
	int prefix_len=0;
d610 1
a610 1
	long align=0;
d612 1
a612 1
	SSL3_BUFFER *wb=&(s->s3->wbuf);
d615 1
a615 1
 	if (wb->buf == NULL)
d622 1
a622 1
		return(ssl3_write_pending(s,type,buf,len));
d625 2
a626 3
	if (s->s3->alert_dispatch)
		{
		i=s->method->ssl_dispatch_alert(s);
d628 1
a628 1
			return(i);
d630 1
a630 1
		}
d635 2
a636 2
	wr= &(s->s3->wrec);
	sess=s->session;
d638 2
a639 4
	if (	(sess == NULL) ||
		(s->enc_write_ctx == NULL) ||
		(EVP_MD_CTX_md(s->write_hash) == NULL))
		{
d641 1
a641 1
		clear=s->enc_write_ctx?0:1;	/* must be AEAD cipher */
d643 1
a643 1
		clear=1;
d645 3
a647 5
		mac_size=0;
		}
	else
		{
		mac_size=EVP_MD_CTX_size(s->write_hash);
d650 1
a650 1
		}
d653 1
a653 2
	if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done)
		{
d657 1
a657 2
		if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA)
			{
d667 1
a667 2
		(SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD))
				{
a670 1
				}
d672 2
a673 1
		
d675 1
a675 1
		}
d677 1
a677 2
	if (create_empty_fragment)
		{
d684 1
a684 1
		align = (-align)&(SSL3_ALIGN_PAYLOAD-1);
d687 2
a688 4
		wb->offset  = align;
		}
	else if (prefix_len)
		{
d690 1
a690 3
		}
	else
		{
d693 1
a693 1
		align = (-align)&(SSL3_ALIGN_PAYLOAD-1);
d696 2
a697 2
		wb->offset  = align;
		}
d701 2
a702 2
	*(p++)=type&0xff;
	wr->type=type;
d704 1
a704 1
	*(p++)=(s->version>>8);
d708 2
a709 3
	if (s->state == SSL3_ST_CW_CLNT_HELLO_B
				&& !s->renegotiate
				&& TLS1_get_version(s) > TLS1_VERSION)
d712 1
a712 1
		*(p++)=s->version&0xff;
d715 3
a717 2
	plen=p; 
	p+=2;
d719 1
a719 2
	if (s->enc_write_ctx && s->version >= TLS1_1_VERSION)
		{
d721 1
a721 2
		if (mode == EVP_CIPH_CBC_MODE)
			{
d725 1
a725 1
			}
d731 1
a731 2
		}
	else 
d735 3
a737 3
	wr->data=p + eivlen;
	wr->length=(int)len;
	wr->input=(unsigned char *)buf;
d743 3
a745 5
	if (s->compress != NULL)
		{
		if (!ssl3_do_compress(s))
			{
			SSLerr(SSL_F_DO_SSL3_WRITE,SSL_R_COMPRESSION_FAILURE);
a746 6
			}
		}
	else
		{
		memcpy(wr->data,wr->input,wr->length);
		wr->input=wr->data;
d748 4
d757 2
a758 3
	if (mac_size != 0)
		{
		if (s->method->ssl3_enc->mac(s,&(p[wr->length + eivlen]),1) < 0)
d760 2
a761 2
		wr->length+=mac_size;
		}
d763 2
a764 2
	wr->input=p;
	wr->data=p;
d766 1
a766 2
	if (eivlen)
		{
d768 2
a769 1
			goto err; */
d771 1
a771 1
		}
d774 1
a774 1
	s->method->ssl3_enc->enc(s,1);
d777 1
a777 1
	s2n(wr->length,plen);
d783 1
a783 1
	wr->length+=SSL3_RT_HEADER_LENGTH;
d785 1
a785 2
	if (create_empty_fragment)
		{
d790 1
a790 1
		}
d796 4
a799 4
	s->s3->wpend_tot=len;
	s->s3->wpend_buf=buf;
	s->s3->wpend_type=type;
	s->s3->wpend_ret=len;
d802 1
a802 1
	return ssl3_write_pending(s,type,buf,len);
d805 1
a805 1
	}
d808 4
a811 3
int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
	unsigned int len)
	{
d813 1
a813 1
	SSL3_BUFFER *wb=&(s->s3->wbuf);
d816 6
a821 8
	if ((s->s3->wpend_tot > (int)len)
		|| ((s->s3->wpend_buf != buf) &&
			!(s->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER))
		|| (s->s3->wpend_type != type))
		{
		SSLerr(SSL_F_SSL3_WRITE_PENDING,SSL_R_BAD_WRITE_RETRY);
		return(-1);
		}
d823 1
a823 2
	for (;;)
		{
d825 12
a836 16
		if (s->wbio != NULL)
			{
			s->rwstate=SSL_WRITING;
			i=BIO_write(s->wbio,
				(char *)&(wb->buf[wb->offset]),
				(unsigned int)wb->left);
			}
		else
			{
			SSLerr(SSL_F_SSL3_WRITE_PENDING,SSL_R_BIO_NOT_SET);
			i= -1;
			}
		if (i == wb->left)
			{
			wb->left=0;
			wb->offset+=i;
d838 2
a839 1
			    SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)
d841 3
a843 4
			s->rwstate=SSL_NOTHING;
			return(s->s3->wpend_ret);
			}
		else if (i <= 0) {
d850 1
a850 4
			return(i);
		}
		wb->offset+=i;
		wb->left-=i;
d852 2
d855 1
d884 4
a887 3
int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
	{
	int al,i,j,ret;
d890 1
a890 1
	void (*cb)(const SSL *ssl,int type2,int val)=NULL;
d894 1
a894 1
			return(-1);
d896 3
a898 3
	if ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE) && type) ||
	    (peek && (type != SSL3_RT_APPLICATION_DATA)))
		{
d901 1
a901 1
		}
d905 1
a905 1
		{
d912 1
a912 2
		while ((len > 0) && (s->s3->handshake_fragment_len > 0))
			{
d914 2
a915 1
			len--; s->s3->handshake_fragment_len--;
d917 1
a917 1
			}
d926 1
a926 2
	if (!s->in_handshake && SSL_in_init(s))
		{
d928 6
a933 7
		i=s->handshake_func(s);
		if (i < 0) return(i);
		if (i == 0)
			{
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
			return(-1);
			}
d935 1
d937 1
a937 1
	s->rwstate=SSL_NOTHING;
d946 5
a950 5
	if ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))
		{
		ret=ssl3_get_record(s);
		if (ret <= 0) return(ret);
		}
d956 3
a958 4
		&& (rr->type != SSL3_RT_HANDSHAKE))
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);
d960 1
a960 1
		}
d964 5
a968 6
	if (s->shutdown & SSL_RECEIVED_SHUTDOWN)
		{
		rr->length=0;
		s->rwstate=SSL_NOTHING;
		return(0);
		}
d972 1
a972 1
		{
d976 3
a978 4
			(s->enc_read_ctx == NULL))
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);
d980 1
a980 1
			}
d982 2
a983 1
		if (len <= 0) return(len);
d990 7
a996 9
		memcpy(buf,&(rr->data[rr->off]),n);
		if (!peek)
			{
			rr->length-=n;
			rr->off+=n;
			if (rr->length == 0)
				{
				s->rstate=SSL_ST_READ_HEADER;
				rr->off=0;
a998 1
				}
a999 1
		return(n);
d1001 2
d1011 1
a1011 1
		{
d1016 1
a1016 2
		if (rr->type == SSL3_RT_HANDSHAKE)
			{
d1020 1
a1020 3
			}
		else if (rr->type == SSL3_RT_ALERT)
			{
d1024 1
a1024 1
			}
d1026 1
a1026 2
		else if (rr->type == TLS1_RT_HEARTBEAT)
			{
d1031 1
a1031 1
			s->rwstate=SSL_READING;
d1034 2
a1035 2
			return(-1);
			}
d1038 1
a1038 2
		if (dest_maxlen > 0)
			{
d1044 1
a1044 2
			while (n-- > 0)
				{
d1047 1
a1047 1
				}
a1050 1
			}
d1052 1
d1059 3
a1061 5
	if ((!s->server) &&
		(s->s3->handshake_fragment_len >= 4) &&
		(s->s3->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&
		(s->session != NULL) && (s->session->cipher != NULL))
		{
d1065 4
a1068 5
			(s->s3->handshake_fragment[2] != 0) ||
			(s->s3->handshake_fragment[3] != 0))
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);
d1070 1
a1070 1
			}
d1076 2
a1077 3
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&
			!s->s3->renegotiate)
			{
d1079 8
a1086 9
			if (ssl3_renegotiate_check(s))
				{
				i=s->handshake_func(s);
				if (i < 0) return(i);
				if (i == 0)
					{
					SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
					return(-1);
					}
d1088 2
a1089 1
				if (!(s->mode & SSL_MODE_AUTO_RETRY))
a1090 2
					if (s->s3->rbuf.left == 0) /* no read-ahead left? */
						{
d1096 2
a1097 2
						s->rwstate=SSL_READING;
						bio=SSL_get_rbio(s);
d1100 1
a1100 2
						return(-1);
						}
d1104 1
d1108 1
a1108 1
		}
d1114 7
a1120 9
		SSL_is_init_finished(s) &&
    		!s->s3->send_connection_binding &&
		(s->version > SSL3_VERSION) &&
		(s->s3->handshake_fragment_len >= 4) &&
		(s->s3->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&
		(s->session != NULL) && (s->session->cipher != NULL) &&
		!(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
		
		{
d1123 1
a1123 1
		ssl3_send_alert(s,SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);
d1125 2
a1126 3
		}
	if (s->s3->alert_fragment_len >= 2)
		{
d1136 1
a1136 1
			cb=s->info_callback;
d1138 1
a1138 1
			cb=s->ctx->info_callback;
d1140 1
a1140 2
		if (cb != NULL)
			{
d1143 1
a1143 1
			}
d1146 1
a1146 1
			{
d1148 1
a1148 2
			if (alert_descr == SSL_AD_CLOSE_NOTIFY)
				{
d1150 2
a1151 2
				return(0);
				}
d1161 1
a1161 2
			else if (alert_descr == SSL_AD_NO_RENEGOTIATION)
				{
d1163 1
a1163 1
				SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_NO_RENEGOTIATION);
d1165 1
a1165 1
				}
d1168 1
a1168 1
				return(0);
d1170 2
a1171 3
			}
		else if (alert_level == 2) /* fatal */
			{
d1174 1
a1174 1
			s->rwstate=SSL_NOTHING;
d1177 2
a1178 2
			BIO_snprintf(tmp,sizeof tmp,"%d",alert_descr);
			ERR_add_error_data(2,"SSL alert number ",tmp);
d1180 5
a1184 7
			SSL_CTX_remove_session(s->ctx,s->session);
			return(0);
			}
		else
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);
d1186 1
a1186 1
			}
d1189 1
a1189 1
		}
d1192 5
a1196 5
		{
		s->rwstate=SSL_NOTHING;
		rr->length=0;
		return(0);
		}
d1198 1
a1198 2
	if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)
		{
d1201 4
a1204 5
		if (	(rr->length != 1) || (rr->off != 0) ||
			(rr->data[0] != SSL3_MT_CCS))
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);
d1206 1
a1206 1
			}
d1209 3
a1211 4
		if (s->s3->tmp.new_cipher == NULL)
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);
d1213 1
a1213 1
			}
d1215 1
a1215 1
		rr->length=0;
d1220 1
a1220 1
		s->s3->change_cipher_spec=1;
d1225 1
a1225 1
		}
d1228 1
a1228 2
	if ((s->s3->handshake_fragment_len >= 4) &&	!s->in_handshake)
		{
d1230 1
a1230 2
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))
			{
d1232 1
a1232 1
       * because this is not really needed for clients except for detecting
d1234 2
a1235 3
			s->state=SSL_ST_BEFORE|(s->server)
				?SSL_ST_ACCEPT
				:SSL_ST_CONNECT;
d1239 10
a1248 10
			s->renegotiate=1;
			s->new_session=1;
			}
		i=s->handshake_func(s);
		if (i < 0) return(i);
		if (i == 0)
			{
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
			return(-1);
			}
d1250 2
a1251 1
		if (!(s->mode & SSL_MODE_AUTO_RETRY))
a1252 2
			if (s->s3->rbuf.left == 0) /* no read-ahead left? */
				{
d1258 2
a1259 2
				s->rwstate=SSL_READING;
				bio=SSL_get_rbio(s);
d1262 1
a1262 2
				return(-1);
				}
d1264 1
d1266 1
a1266 1
		}
d1268 1
a1268 2
	switch (rr->type)
		{
d1274 1
a1274 2
		if (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION)
			{
d1277 1
a1277 1
			}
d1279 2
a1280 2
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
d1288 2
a1289 2
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_READ_BYTES,ERR_R_INTERNAL_ERROR);
d1300 16
a1315 19
			(s->s3->total_renegotiations != 0) &&
			((
				(s->state & SSL_ST_CONNECT) &&
				(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&
				(s->state <= SSL3_ST_CR_SRVR_HELLO_A)
				) || (
					(s->state & SSL_ST_ACCEPT) &&
					(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&
					(s->state >= SSL3_ST_SR_CLNT_HELLO_A)
					)
				))
			{
			s->s3->in_read_app_data=2;
			return(-1);
			}
		else
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
a1316 1
			}
d1318 1
d1322 1
a1322 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d1324 2
a1325 2
	return(-1);
	}
d1327 3
a1329 2
int ssl3_do_change_cipher_spec(SSL *s)
	{
d1335 1
a1335 1
		i=SSL3_CHANGE_CIPHER_SERVER_READ;
d1337 1
a1337 1
		i=SSL3_CHANGE_CIPHER_CLIENT_READ;
d1339 2
a1340 4
	if (s->s3->tmp.key_block == NULL)
		{
		if (s->session == NULL) 
			{
d1342 1
a1342 1
			SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,SSL_R_CCS_RECEIVED_EARLY);
d1344 1
a1344 1
			}
d1346 4
a1349 3
		s->session->cipher=s->s3->tmp.new_cipher;
		if (!s->method->ssl3_enc->setup_key_block(s)) return(0);
		}
d1351 2
a1352 2
	if (!s->method->ssl3_enc->change_cipher_state(s,i))
		return(0);
d1357 7
a1363 10
	if (s->state & SSL_ST_CONNECT)
		{
		sender=s->method->ssl3_enc->server_finished_label;
		slen=s->method->ssl3_enc->server_finished_label_len;
		}
	else
		{
		sender=s->method->ssl3_enc->client_finished_label;
		slen=s->method->ssl3_enc->client_finished_label_len;
		}
d1366 2
a1367 3
		sender,slen,s->s3->tmp.peer_finish_md);
	if (i == 0)
		{
d1370 1
a1370 1
		}
d1373 2
a1374 2
	return(1);
	}
d1376 3
a1378 2
int ssl3_send_alert(SSL *s, int level, int desc)
	{
d1380 1
a1380 1
	desc=s->method->ssl3_enc->alert_value(desc);
d1383 2
a1384 1
	if (desc < 0) return -1;
d1387 1
a1387 1
		SSL_CTX_remove_session(s->ctx,s->session);
d1389 3
a1391 3
	s->s3->alert_dispatch=1;
	s->s3->send_alert[0]=level;
	s->s3->send_alert[1]=desc;
d1397 1
a1397 1
	}
d1399 5
a1403 4
int ssl3_dispatch_alert(SSL *s)
	{
	int i,j;
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
d1405 1
a1405 1
	s->s3->alert_dispatch=0;
d1407 3
a1409 6
	if (i <= 0)
		{
		s->s3->alert_dispatch=1;
		}
	else
		{
d1420 1
a1420 1
			cb=s->info_callback;
d1422 1
a1422 1
			cb=s->ctx->info_callback;
d1424 3
a1426 5
		if (cb != NULL)
			{
			j=(s->s3->send_alert[0]<<8)|s->s3->send_alert[1];
			cb(s,SSL_CB_WRITE_ALERT,j);
			}
a1427 1
	return(i);
d1429 2
@


1.23
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d235 1
a235 1
		clear_sys_error();
d877 1
a877 1
		clear_sys_error();
@


1.22
log
@Piotr Sikora pointed me at a more refined diff for the buffer release
issue. Apply that version. Maybe someday upstream will wake up and then
we can have the same code.
https://rt.openssl.org/Ticket/Display.html?id=2167&user=guest&pass=guest
@
text
@d338 1
a338 1
                                if ((s->version & 0xFF00) == (version & 0xFF00))
d410 1
a410 1
		SSLerr(SSL_F_TLS1_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
d470 1
a470 1
		if (i < 0 || mac == NULL || timingsafe_bcmp(md, mac, (size_t)mac_size) != 0)
d751 1
d1058 1
a1058 1
				if (s->mode & SSL_MODE_RELEASE_BUFFERS && s->s3->rbuf.left == 0)
d1246 1
a1246 1
			if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)
@


1.21
log
@don't release the read buffer if we're not done reading from it.
ok benno deraadt
@
text
@d1057 2
@


1.20
log
@SECURITY fixes backported from openssl-1.0.1f.  ok mikeb@@

CVE-2013-4353 NULL pointer dereference with crafted Next Protocol
 Negotiation record in TLS handshake.
Upstream: 197e0ea

CVE-2013-6449 Fix crash with crafted traffic from a TLS 1.2 client.
Upstream: ca98926, 0294b2b

CVE-2013-6450 Fix DTLS retransmission from previous session.
Upstream: 3462896
@
text
@a1056 2
				if (s->mode & SSL_MODE_RELEASE_BUFFERS)
					ssl3_release_read_buffer(s);
@


1.20.4.1
log
@from head, will become 5.5 004_openssl.patch

Changes by:     tedu@@cvs.openbsd.org    2014/04/10 13:01:37
Piotr Sikora pointed me at a more refined diff for the buffer release
issue. Apply that version. Maybe someday upstream will wake up and then
we can have the same code.
https://rt.openssl.org/Ticket/Display.html?id=2167&user=guest&pass=guest
@
text
@d1057 1
a1057 1
				if (s->mode & SSL_MODE_RELEASE_BUFFERS && s->s3->rbuf.left == 0)
@


1.20.4.2
log
@MFC, requested by deraadt@@

-/--------------------------
revision 1.33
date: 2014/04/24 04:31:30;  author: tedu;  state: Exp;  lines: +4 -0;
on today's episode of things you didn't want to learn:
do_ssl3_write() is recursive. and not in the simple, obvious way, but in
the sneaky called through ssl3_dispatch_alert way. (alert level: fuchsia)
this then has a decent chance of releasing the buffer that we thought we
were going to use. check for this happening, and if the buffer has gone
missing, put another one back in place.
the direct recursive call is safe because it won't call ssl3_write_pending
which is the function that actually does do the writing and releasing.
as reported by David Ramos to openssl-dev:
http://marc.info/?l=openssl-dev&m=139809493725682&w=2
ok beck
-/--------------------------
@
text
@a659 4
		/* we may have released our buffer, so get it again */
		if (wb->buf == NULL)
			if (!ssl3_setup_write_buffer(s))
				return -1;
@


1.20.4.3
log
@MFC ChangeCipherSpec fixes (CVE-2014-0224 and additional safeguard), ok jsing@@

"Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret." From s3_clnt.c r1.64, s3_pkt.c r1.42,
s3_srvr.c r1.59, ssl3.h r1.19 - note that the ssl3.h change has been
applied to s3_locl.h instead to simplify patching.

"Ensure that we do not process a ChangeCipherSpec with an empty master
secret. This is an additional safeguard against early ChangeCipherSpec
handling."  From s3_pkt.c:1.43
@
text
@a1302 8
		/* Check that we should be receiving a Change Cipher Spec. */
		if (!(s->s3->flags & SSL3_FLAGS_CCS_OK)) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);
			goto f_err;
		}
		s->s3->flags &= ~SSL3_FLAGS_CCS_OK;

d1437 1
a1437 1
		if (s->session == NULL || s->session->master_key_length == 0) 
@


1.20.4.4
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d955 1
a955 1
	if ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE)) ||
@


1.19
log
@cherry pick bugfixes for http://www.openssl.org/news/secadv_20130205.txt
from the openssl git (changes between openssl 1.0.1c and 1.0.1d).
ok djm@@
@
text
@d1461 1
a1461 1
	s->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,
d1463 6
@


1.19.4.1
log
@from head, will become 5.4 008_openssl.patch

Changes by:     tedu@@cvs.openbsd.org    2014/04/10 13:01:37
Piotr Sikora pointed me at a more refined diff for the buffer release
issue. Apply that version. Maybe someday upstream will wake up and then
we can have the same code.
https://rt.openssl.org/Ticket/Display.html?id=2167&user=guest&pass=guest
@
text
@d1057 1
a1057 1
				if (s->mode & SSL_MODE_RELEASE_BUFFERS && s->s3->rbuf.left == 0)
@


1.19.4.2
log
@MFC, requested by deraadt@@

-/--------------------------
revision 1.33
date: 2014/04/24 04:31:30;  author: tedu;  state: Exp;  lines: +4 -0;
on today's episode of things you didn't want to learn:
do_ssl3_write() is recursive. and not in the simple, obvious way, but in
the sneaky called through ssl3_dispatch_alert way. (alert level: fuchsia)
this then has a decent chance of releasing the buffer that we thought we
were going to use. check for this happening, and if the buffer has gone
missing, put another one back in place.
the direct recursive call is safe because it won't call ssl3_write_pending
which is the function that actually does do the writing and releasing.
as reported by David Ramos to openssl-dev:
http://marc.info/?l=openssl-dev&m=139809493725682&w=2
ok beck
-/--------------------------
@
text
@a659 4
		/* we may have released our buffer, so get it again */
		if (wb->buf == NULL)
			if (!ssl3_setup_write_buffer(s))
				return -1;
@


1.19.4.3
log
@MFC ChangeCipherSpec fixes (CVE-2014-0224 and additional safeguard), ok jsing@@

"Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret." From s3_clnt.c r1.64, s3_pkt.c r1.42,
s3_srvr.c r1.59, ssl3.h r1.19 - note that the ssl3.h change has been
applied to s3_locl.h instead to simplify patching.

"Ensure that we do not process a ChangeCipherSpec with an empty master
secret. This is an additional safeguard against early ChangeCipherSpec
handling."  From s3_pkt.c:1.43
@
text
@a1302 8
		/* Check that we should be receiving a Change Cipher Spec. */
		if (!(s->s3->flags & SSL3_FLAGS_CCS_OK)) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);
			goto f_err;
		}
		s->s3->flags &= ~SSL3_FLAGS_CCS_OK;

d1437 1
a1437 1
		if (s->session == NULL || s->session->master_key_length == 0) 
@


1.19.4.4
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d955 1
a955 1
	if ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE)) ||
@


1.19.2.1
log
@from head, will become 5.3 015_openssl.patch

Changes by:     tedu@@cvs.openbsd.org    2014/04/10 13:01:37
Piotr Sikora pointed me at a more refined diff for the buffer release
issue. Apply that version. Maybe someday upstream will wake up and then
we can have the same code.
https://rt.openssl.org/Ticket/Display.html?id=2167&user=guest&pass=guest
@
text
@d1057 1
a1057 1
				if (s->mode & SSL_MODE_RELEASE_BUFFERS && s->s3->rbuf.left == 0)
@


1.18
log
@resolve conflicts
@
text
@d293 1
a293 2
	int mac_size;
	int clear=0;
a294 2
	int decryption_failed_or_bad_record_mac = 0;
	unsigned char *mac = NULL;
d403 5
a407 1
	if (enc_err <= 0)
d409 3
a411 9
		if (enc_err == 0)
			/* SSLerr() and ssl3_send_alert() have been called */
			goto err;

		/* Otherwise enc_err == -1, which indicates bad padding
		 * (rec->length has not been changed in this case).
		 * To minimize information leaked via timing, we will perform
		 * the MAC computation anyway. */
		decryption_failed_or_bad_record_mac = 1;
d421 9
a429 4
	if (	(sess == NULL) ||
		(s->enc_read_ctx == NULL) ||
		(EVP_MD_CTX_md(s->read_hash) == NULL))
		clear=1;
d431 2
a432 5
	if (!clear)
		{
		/* !clear => s->read_hash != NULL => mac_size != -1 */
		mac_size=EVP_MD_CTX_size(s->read_hash);
		OPENSSL_assert(mac_size >= 0);
d434 9
a442 1
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra+mac_size)
d444 2
a445 3
#if 0 /* OK only for stream ciphers (then rr->length is visible from ciphertext anyway) */
			al=SSL_AD_RECORD_OVERFLOW;
			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_PRE_MAC_LENGTH_TOO_LONG);
a446 3
#else
			decryption_failed_or_bad_record_mac = 1;
#endif			
d448 2
a449 2
		/* check the MAC for rr->input (it's in mac_size bytes at the tail) */
		if (rr->length >= (unsigned int)mac_size)
d451 7
a458 1
			mac = &rr->data[rr->length];
d462 5
a466 14
			/* record (minus padding) is too short to contain a MAC */
#if 0 /* OK only for stream ciphers */
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
#else
			decryption_failed_or_bad_record_mac = 1;
			rr->length = 0;
#endif
			}
		i=s->method->ssl3_enc->mac(s,md,0);
		if (i < 0 || mac == NULL || memcmp(md, mac, (size_t)mac_size) != 0)
			{
			decryption_failed_or_bad_record_mac = 1;
d468 6
d476 1
a476 1
	if (decryption_failed_or_bad_record_mac)
@


1.17
log
@openssl-1.0.0e: resolve conflicts
@
text
@d118 1
d634 1
d667 4
d672 1
a672 2

	if (clear)
d674 1
d743 8
a750 1
	*(p++)=s->version&0xff;
d755 18
d775 1
a775 1
	wr->data=p;
d803 1
a803 1
		if (s->method->ssl3_enc->mac(s,&(p[wr->length]),1) < 0)
d806 10
a815 2
		wr->input=p;
		wr->data=p;
d1084 13
d1240 4
d1322 1
d1356 4
a1359 2
		/* TLS just ignores unknown message types */
		if (s->version == TLS1_VERSION)
@


1.16
log
@resolve conflicts, fix local changes
@
text
@d249 2
a250 1
			if (s->mode & SSL_MODE_RELEASE_BUFFERS)
d850 2
a851 1
			if (s->mode & SSL_MODE_RELEASE_BUFFERS)
@


1.15
log
@Security fix for CVE-2010-0740

"In TLS connections, certain incorrectly formatted records can cause an OpenSSL
client or server to crash due to a read attempt at NULL."

http://openssl.org/news/secadv_20100324.txt

ok deraadt@@ djm@@ sthen@@
@
text
@d132 17
a148 1
	int i,off,newb;
d153 22
a174 3
		if (s->s3->rbuf.left == 0)
			s->s3->rbuf.offset = 0;
		s->packet = s->s3->rbuf.buf + s->s3->rbuf.offset;
d179 4
a182 3
	/* extend reads should not span multiple packets for DTLS */
	if ( SSL_version(s) == DTLS1_VERSION &&
		extend)
d184 2
a185 2
		if ( s->s3->rbuf.left > 0 && n > s->s3->rbuf.left)
			n = s->s3->rbuf.left;
d189 1
a189 1
	if (s->s3->rbuf.left >= (int)n)
d192 2
a193 2
		s->s3->rbuf.left-=n;
		s->s3->rbuf.offset+=n;
a197 2
	if (!s->read_ahead)
		max=n;
d199 13
a211 7
	{
		/* avoid buffer overflow */
		int max_max = s->s3->rbuf.len - s->packet_length;
		if (max > max_max)
			max = max_max;
	}
	if (n > max) /* does not happen */
d217 4
a220 6
	off = s->packet_length;
	newb = s->s3->rbuf.left;
	/* Move any available bytes to front of buffer:
	 * 'off' bytes already pointed to by 'packet',
	 * 'newb' extra ones at the end */
	if (s->packet != s->s3->rbuf.buf)
d222 4
a225 3
		/*  off > 0 */
		memmove(s->s3->rbuf.buf, s->packet, off+newb);
		s->packet = s->s3->rbuf.buf;
d228 1
a228 1
	while (newb < n)
d230 3
a232 2
		/* Now we have off+newb bytes at the front of s->s3->rbuf.buf and need
		 * to read in more until we have off+n (up to off+max if possible) */
d238 1
a238 1
			i=BIO_read(s->rbio,	&(s->s3->rbuf.buf[off+newb]), max-newb);
d248 4
a251 1
			s->s3->rbuf.left = newb;
d254 9
a262 1
		newb+=i;
d266 2
a267 2
	s->s3->rbuf.offset = off + n;
	s->s3->rbuf.left = newb - n;
d291 1
a291 1
	unsigned int mac_size;
d304 1
a304 1
	if (extra != s->s3->rbuf.len - SSL3_RT_MAX_PACKET_SIZE)
d306 1
a306 1
		/* actually likely an application error: SLS_OP_MICROSOFT_BIG_SSLV3_BUFFER
d329 3
d340 1
a340 2
                                	/* Send back error using their
					 * minor version number :-) */
d353 1
a353 1
		if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)
d426 1
a426 1
		(s->read_hash == NULL))
d431 3
a433 1
		mac_size=EVP_MD_size(s->read_hash);
d446 1
a446 1
		if (rr->length >= mac_size)
d464 1
a464 1
		if (mac == NULL || memcmp(md, mac, mac_size) != 0)
d521 4
d598 2
a599 2
		if (n > SSL3_RT_MAX_PLAIN_LENGTH)
			nw=SSL3_RT_MAX_PLAIN_LENGTH;
d631 2
a632 1
	int prefix_len = 0;
d634 1
a634 1
	SSL3_BUFFER *wb;
d637 4
d643 1
a643 1
	if (s->s3->wbuf.left != 0)
a658 1
	wb= &(s->s3->wbuf);
d663 1
a663 1
		(s->write_hash == NULL))
d669 5
a673 1
		mac_size=EVP_MD_size(s->write_hash);
d691 2
a692 1
			if (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE)
d703 26
a728 1
	p = wb->buf + prefix_len;
d771 2
a772 1
		s->method->ssl3_enc->mac(s,&(p[wr->length]),1);
a799 1
	wb->offset = 0;
d818 1
d837 2
a838 2
				(char *)&(s->s3->wbuf.buf[s->s3->wbuf.offset]),
				(unsigned int)s->s3->wbuf.left);
d845 1
a845 1
		if (i == s->s3->wbuf.left)
d847 4
a850 1
			s->s3->wbuf.left=0;
d859 1
a859 1
				s->s3->wbuf.left = 0;
d863 2
a864 2
		s->s3->wbuf.offset+=i;
		s->s3->wbuf.left-=i;
d903 1
a903 1
		if (!ssl3_setup_buffers(s))
d1012 2
a1087 1
			(s->s3->flags & SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) &&
d1123 19
a1141 1

d1171 15
d1253 1
a1253 2
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&
			(s->s3->flags & SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
a1396 2
		&(s->s3->finish_dgst1),
		&(s->s3->finish_dgst2),
d1402 1
a1402 1
void ssl3_send_alert(SSL *s, int level, int desc)
d1408 1
a1408 1
	if (desc < 0) return;
d1417 1
a1417 1
		s->method->ssl_dispatch_alert(s);
d1420 1
@


1.14
log
@pull Ben Lauries blind prefix injection fix for CVE-2009-3555 from
openssl 0.9.8l; crank minor version; ok djm@@ deraadt@@; initially from jsg@@
@
text
@d285 4
a288 3
				/* Send back error using their
				 * version number :-) */
				s->version=version;
@


1.14.2.1
log
@ecurity fix for CVE-2010-0740

"In TLS connections, certain incorrectly formatted records can cause an OpenSSL
client or server to crash due to a read attempt at NULL."

http://openssl.org/news/secadv_20100324.txt

ok djm@@ sthen@@
@
text
@d285 3
a287 4
                                if ((s->version & 0xFF00) == (version & 0xFF00))
                                	/* Send back error using their
					 * minor version number :-) */
					s->version = (unsigned short)version;
@


1.13
log
@resolve conflicts
@
text
@d988 1
d1121 2
a1122 1
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))
@


1.13.6.1
log
@Pull Ben Lauries blind prefix injection fix for CVE-2009-3555 from
openssl 0.9.8l.

As suggested by markus@@, for -stable the header change is being
restricted to a private file, so the minor version is not cranked here.

Discussed with markus, djm, deraadt.
@
text
@a987 1
			(s->s3->flags & SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) &&
d1120 1
a1120 2
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&
			(s->s3->flags & SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
@


1.13.6.2
log
@Security fix for CVE-2010-0740

"In TLS connections, certain incorrectly formatted records can cause an OpenSSL
client or server to crash due to a read attempt at NULL."

http://openssl.org/news/secadv_20100324.txt

ok djm@@ sthen@@
@
text
@d285 3
a287 4
                                if ((s->version & 0xFF00) == (version & 0xFF00))
                                	/* Send back error using their
					 * minor version number :-) */
					s->version = (unsigned short)version;
@


1.13.2.1
log
@Pull Ben Lauries blind prefix injection fix for CVE-2009-3555 from
openssl 0.9.8l.

As suggested by markus@@, for -stable the header change is being
restricted to a private file, so the minor version is not cranked here.

Discussed with markus, djm, deraadt.
@
text
@a987 1
			(s->s3->flags & SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) &&
d1120 1
a1120 2
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&
			(s->s3->flags & SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
@


1.13.2.2
log
@Security fix for CVE-2010-0740

"In TLS connections, certain incorrectly formatted records can cause an OpenSSL
client or server to crash due to a read attempt at NULL."

http://openssl.org/news/secadv_20100324.txt

ok djm@@ sthen@@
@
text
@d285 3
a287 4
                                if ((s->version & 0xFF00) == (version & 0xFF00))
                                	/* Send back error using their
					 * minor version number :-) */
					s->version = (unsigned short)version;
@


1.12
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d756 7
a762 1
		else if (i <= 0)
d764 1
@


1.11
log
@resolve conflicts
@
text
@d1228 7
@


1.10
log
@resolve conflicts
@
text
@a120 2
static int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
			      unsigned int len);
a121 3
static int do_compress(SSL *ssl);
static int do_uncompress(SSL *ssl);
static int do_change_cipher_spec(SSL *ssl);
d123 1
a123 2
/* used only by ssl3_get_record */
static int ssl3_read_n(SSL *s, int n, int max, int extend)
d144 8
d280 1
a280 5
		if (s->first_packet)
			{
			s->first_packet=0;
			}
		else
d435 1
a435 1
		if (!do_uncompress(s))
d473 1
a473 1
static int do_uncompress(SSL *ssl)
d475 1
d487 1
a487 1

d491 1
a491 1
static int do_compress(SSL *ssl)
d493 1
d507 1
d584 1
a584 1
		i=ssl3_dispatch_alert(s);
d659 1
a659 1
		if (!do_compress(s))
d720 2
a721 2
static int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
			      unsigned int len)
d1093 1
a1093 1
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
d1103 1
a1103 1
		if (!do_change_cipher_spec(s))
d1215 1
a1215 1
static int do_change_cipher_spec(SSL *s)
d1272 1
a1272 1
		ssl3_dispatch_alert(s);
@


1.9
log
@avoid null-pointer deref (aka CAN-2004-0079)
see http://www.openssl.org/news/secadv_20040317.txt
@
text
@d865 1
a865 1
		goto err;
d972 1
a972 1
			goto err;
d1083 1
a1083 1
			i=SSL_AD_ILLEGAL_PARAMETER;
d1085 1
a1085 1
			goto err;
d1091 1
a1091 1
			i=SSL_AD_UNEXPECTED_MESSAGE;
d1093 1
a1093 1
			goto err;
@


1.8
log
@security fix from openssl 0.9.7a:

In ssl3_get_record (ssl/s3_pkt.c), minimize information leaked
via timing by performing a MAC computation even if incorrrect
block cipher padding has been found.  This is a countermeasure
against active attacks where the attacker has to distinguish
between bad padding and a MAC verification error. (CAN-2003-0078)
@
text
@d1088 8
@


1.8.2.1
log
@MFC:
Fix by markus@@

avoid null-pointer deref (aka CAN-2004-0079)
see http://www.openssl.org/news/secadv_20040317.txt

ok deraadt@@ markus@@
@
text
@a1087 8
		/* Check we have a cipher to change to */
		if (s->s3->tmp.new_cipher == NULL)
			{
			i=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
			goto err;
			}

@


1.8.4.1
log
@MFC:
Fix by markus@@

avoid null-pointer deref (aka CAN-2004-0079)
see http://www.openssl.org/news/secadv_20040317.txt

ok deraadt@@ markus@@
@
text
@a1087 8
		/* Check we have a cipher to change to */
		if (s->s3->tmp.new_cipher == NULL)
			{
			i=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
			goto err;
			}

@


1.7
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d241 2
d358 5
a362 2
		/* otherwise enc_err == -1 */
		goto decryption_failed_or_bad_record_mac;
d388 1
a388 1
			goto decryption_failed_or_bad_record_mac;
d392 1
a392 1
		if (rr->length < mac_size)
d394 6
d405 2
a406 1
			goto decryption_failed_or_bad_record_mac;
a408 1
		rr->length-=mac_size;
d410 1
a410 1
		if (memcmp(md,&(rr->data[rr->length]),mac_size) != 0)
d412 1
a412 1
			goto decryption_failed_or_bad_record_mac;
d416 12
a468 8
decryption_failed_or_bad_record_mac:
	/* Separate 'decryption_failed' alert was introduced with TLS 1.0,
	 * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption
	 * failure is directly visible from the ciphertext anyway,
	 * we should not reveal which kind of error occured -- this
	 * might become visible to an attacker (e.g. via logfile) */
	al=SSL_AD_BAD_RECORD_MAC;
	SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
@


1.7.2.1
log
@Pull patch from current:
Fix by markus@@
security fix from openssl 0.9.7a:

In ssl3_get_record (ssl/s3_pkt.c), minimize information leaked
via timing by performing a MAC computation even if incorrrect
block cipher padding has been found.  This is a countermeasure
against active attacks where the attacker has to distinguish
between bad padding and a MAC verification error. (CAN-2003-0078)

markus@@ ok
@
text
@a240 2
	int decryption_failed_or_bad_record_mac = 0;
	unsigned char *mac = NULL;
d356 2
a357 5
		/* Otherwise enc_err == -1, which indicates bad padding
		 * (rec->length has not been changed in this case).
		 * To minimize information leaked via timing, we will perform
		 * the MAC computation anyway. */
		decryption_failed_or_bad_record_mac = 1;
d383 1
a383 1
			decryption_failed_or_bad_record_mac = 1;
d387 1
a387 1
		if (rr->length >= mac_size)
a388 6
			rr->length -= mac_size;
			mac = &rr->data[rr->length];
			}
		else
			{
			/* record (minus padding) is too short to contain a MAC */
d394 1
a394 2
			decryption_failed_or_bad_record_mac = 1;
			rr->length = 0;
d397 1
d399 1
a399 1
		if (mac == NULL || memcmp(md, mac, mac_size) != 0)
d401 1
a401 1
			decryption_failed_or_bad_record_mac = 1;
a404 12
	if (decryption_failed_or_bad_record_mac)
		{
		/* A separate 'decryption_failed' alert was introduced with TLS 1.0,
		 * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption
		 * failure is directly visible from the ciphertext anyway,
		 * we should not reveal which kind of error occured -- this
		 * might become visible to an attacker (e.g. via a logfile) */
		al=SSL_AD_BAD_RECORD_MAC;
		SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
		goto f_err;
		}

d446 8
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d115 1
a117 1
#include "ssl_locl.h"
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
d120 1
a120 1
			 unsigned int len);
d165 1
a165 3
		int max_max = SSL3_RT_MAX_PACKET_SIZE - s->packet_length;
		if (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)
			max_max += SSL3_RT_MAX_EXTRA;
d171 1
a171 1
		SSLerr(SSL_F_SSL3_READ_N,SSL_R_INTERNAL_ERROR);
d232 1
a232 1
	int n,i,ret= -1;
d239 2
a240 1
	int clear=0,extra;
d249 7
d262 1
a262 2
		n=ssl3_read_n(s,SSL3_RT_HEADER_LENGTH,
			SSL3_RT_MAX_PACKET_SIZE,0);
d299 1
a299 2
		if (rr->length > 
			(unsigned int)SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)
d311 1
a311 1
	if (rr->length > (s->packet_length-SSL3_RT_HEADER_LENGTH))
d339 1
a339 1
	if (rr->length > (unsigned int)SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)
d349 2
a350 1
	if (!s->method->ssl3_enc->enc(s,0))
d352 6
a357 2
		al=SSL_AD_DECRYPT_ERROR;
		goto f_err;
d359 1
d365 1
d378 1
d382 3
d389 1
d393 3
d401 1
a401 4
			al=SSL_AD_BAD_RECORD_MAC;
			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_BAD_MAC_DECODE);
			ret= -1;
			goto f_err;
d408 1
a408 2
		if (rr->length > 
			(unsigned int)SSL3_RT_MAX_COMPRESSED_LENGTH+extra)
d422 1
a422 1
	if (rr->length > (unsigned int)SSL3_RT_MAX_PLAIN_LENGTH+extra)
d445 9
d515 1
a515 1
			return(-1);
d527 1
a527 1
		i=do_ssl3_write(s,type,&(buf[tot]),nw);
d531 1
a531 1
			return(i);
d538 5
a542 1
			return(tot+i);
d551 1
a551 1
			 unsigned int len)
d555 1
d560 1
a560 1
	/* first check is there is a SSL3_RECORD still being written
d574 2
a575 1
	if (len == 0) return(len);
d591 28
a618 1
	p=wb->buf;
d621 1
d628 1
a628 1
	/* record where we are to write out packet length */
d679 11
a689 3
	/* Now lets setup wb */
	wb->left=wr->length;
	wb->offset=0;
d691 1
d698 1
a698 1
	return(ssl3_write_pending(s,type,buf,len));
d700 1
a700 1
	return(-1);
d779 1
a779 1
	void (*cb)()=NULL;
d788 1
a788 1
		SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_INTERNAL_ERROR);
d960 3
d1008 3
d1074 4
d1132 1
a1132 1
#ifndef NO_TLS
d1136 1
d1150 1
a1150 1
		SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_INTERNAL_ERROR);
d1173 1
a1173 1
			s->s3->in_read_app_data=0;
d1237 2
d1247 1
a1247 1
	if (s->s3->wbuf.left == 0) /* data still being written out */
d1256 1
a1256 1
	void (*cb)()=NULL;
d1259 1
a1259 1
	i=do_ssl3_write(s,SSL3_RT_ALERT,&s->s3->send_alert[0],2);
d1266 3
a1268 3
		/* If it is important, send it now.  If the message
		 * does not get sent due to non-blocking IO, we will
		 * not worry too much. */
d1271 3
@


1.5.4.1
log
@Errata 021:
security fix from openssl 0.9.7a:

In ssl3_get_record (ssl/s3_pkt.c), minimize information leaked
via timing by performing a MAC computation even if incorrrect
block cipher padding has been found.  This is a countermeasure
against active attacks where the attacker has to distinguish
between bad padding and a MAC verification error. (CAN-2003-0078)

adapted from a patch from Ryan W. Maple, via markus@@
@
text
@d234 1
a234 1
	int enc_err,n,i,ret= -1;
a241 2
	int decryption_failed_or_bad_record_mac = 0;
	unsigned char *mac = NULL;
d345 1
a345 2
	enc_err = s->method->ssl3_enc->enc(s,0);
	if (enc_err <= 0)
d347 2
a348 9
		if (enc_err == 0)
			/* SSLerr() and ssl3_send_alert() have been called */
			goto err;

		/* Otherwise enc_err == -1, which indicates bad padding
		 * (rec->length has not been changed in this case).
		 * To minimize information leaked via timing, we will perform
		 * the MAC computation anyway. */
		decryption_failed_or_bad_record_mac = 1;
a349 1

a354 1

a366 1
#if 0 /* OK only for stream ciphers (then rr->length is visible from ciphertext anyway) */
a369 3
#else
			decryption_failed_or_bad_record_mac = 1;
#endif
d372 1
a372 1
		if (rr->length >= mac_size)
a373 7
			rr->length -= mac_size;
			mac = &rr->data[rr->length];
			}
		else
			{
			/* record (minus padding) is too short to contain a MAC */
#if 0 /* OK only for stream ciphers */
a376 4
#else
			decryption_failed_or_bad_record_mac = 1;
			rr->length = 0;
#endif
d378 1
d380 1
a380 1
		if (mac == NULL || memcmp(md, mac, mac_size) != 0)
d382 4
a385 1
			decryption_failed_or_bad_record_mac = 1;
a386 12
		}

	if (decryption_failed_or_bad_record_mac)
		{
		/* A separate 'decryption_failed' alert was introduced with TLS 1.0,
		 * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption
		 * failure is directly visible from the ciphertext anyway,
		 * we should not reveal which kind of error occured -- this
		 * might become visible to an attacker (e.g. via a logfile) */
		al=SSL_AD_BAD_RECORD_MAC;
		SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
		goto f_err;
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d707 1
a707 1
int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len)
d718 2
a719 1
	if ((type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE) && type)
d732 1
d768 1
a768 1
	/* get new packet */
d786 2
a787 1
	/* If the other end has shutdown, throw anything we read away */
d816 1
a816 3
		rr->length-=n;
		rr->off+=n;
		if (rr->length == 0)
d818 7
a824 2
			s->rstate=SSL_ST_READ_HEADER;
			rr->off=0;
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d902 1
a902 1
				if (s->s3->rbuf.left == 0) /* no read-ahead left? */
d904 13
a916 11
					BIO *bio;
					/* In the case where we try to read application data
					 * the first time, but we trigger an SSL handshake, we
					 * return -1 with the retry option set.  I do this
					 * otherwise renegotiation can cause nasty problems 
					 * in the blocking world */ /* ? */
					s->rwstate=SSL_READING;
					bio=SSL_get_rbio(s);
					BIO_clear_retry_flags(bio);
					BIO_set_retry_read(bio);
					return(-1);
d959 1
a959 1
			sprintf(tmp,"%d",alert_descr);
d1027 1
a1027 1
		if (s->s3->rbuf.left == 0) /* no read-ahead left? */
d1029 13
a1041 11
			BIO *bio;
			/* In the case where we try to read application data
			 * the first time, but we trigger an SSL handshake, we
			 * return -1 with the retry option set.  I do this
			 * otherwise renegotiation can cause nasty problems 
			 * in the blocking world */ /* ? */
			s->rwstate=SSL_READING;
			bio=SSL_get_rbio(s);
			BIO_clear_retry_flags(bio);
			BIO_set_retry_read(bio);
			return(-1);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d58 53
d127 2
d131 7
d140 11
a150 2
	/* if there is stuff still in the buffer from a previous read,
	 * and there is more than we want, take some. */
d153 1
a153 7
		if (extend)
			s->packet_length+=n;
		else
			{
			s->packet= &(s->s3->rbuf.buf[s->s3->rbuf.offset]);
			s->packet_length=n;
			}
d160 2
a161 25
	if (!s->read_ahead) max=n;
	if (max > SSL3_RT_MAX_PACKET_SIZE)
		max=SSL3_RT_MAX_PACKET_SIZE;

	/* First check if there is some left or we want to extend */
	off=0;
	if (	(s->s3->rbuf.left != 0) ||
		((s->packet_length != 0) && extend))
		{
		newb=s->s3->rbuf.left;
		if (extend)
			{
			/* Copy bytes back to the front of the buffer 
			 * Take the bytes already pointed to by 'packet'
			 * and take the extra ones on the end. */
			off=s->packet_length;
			if (s->packet != s->s3->rbuf.buf)
				memcpy(s->s3->rbuf.buf,s->packet,newb+off);
			}
		else if (s->s3->rbuf.offset != 0)
			{ /* so the data is not at the start of the buffer */
			memcpy(s->s3->rbuf.buf,
				&(s->s3->rbuf.buf[s->s3->rbuf.offset]),newb);
			s->s3->rbuf.offset=0;
			}
d163 12
a174 1
		s->s3->rbuf.left=0;
a175 2
	else
		newb=0;
d177 11
a187 5
	/* So we now have 'newb' bytes at the front of 
	 * s->s3->rbuf.buf and need to read some more in on the end
	 * We start reading into the buffer at 's->s3->rbuf.offset'
	 */
	s->packet=s->s3->rbuf.buf;
d191 3
d198 1
a198 3
			i=BIO_read(s->rbio,
				(char *)&(s->s3->rbuf.buf[off+newb]),
				max-newb);
d203 1
a203 1
			i= -1;
d208 1
a208 1
			s->s3->rbuf.left+=newb;
d214 5
a218 16
	/* record used data read */
	if (newb > n)
		{
		s->s3->rbuf.offset=n+off;
		s->s3->rbuf.left=newb-n;
		}
	else
		{
		s->s3->rbuf.offset=0;
		s->s3->rbuf.left=0;
		}

	if (extend)
		s->packet_length+=n;
	else
		s->packet_length+=n;
d226 2
a227 2
 * ssl->s3->rrec.type	- is the type of record
 * ssl->s3->rrec.data, 	- data
d230 1
a234 1
	SSL3_BUFFER *rb;
a243 1
	rb= &(s->s3->rbuf);
d302 1
a302 1
		s->rstate=SSL_ST_READ_BODY;
d305 3
a307 2
	/* get and decode the data */
	if (s->rstate == SSL_ST_READ_BODY)
d309 6
a314 8
		if (rr->length > (s->packet_length-SSL3_RT_HEADER_LENGTH))
			{
			i=rr->length;
			/*-(s->packet_length-SSL3_RT_HEADER_LENGTH); */
			n=ssl3_read_n(s,i,i,1);
			if (n <= 0) return(n); /* error or non-blocking io */
			}
		s->rstate=SSL_ST_READ_HEADER;
d317 1
a317 4
	/* At this point, we have the data in s->packet and there should be
	 * s->packet_length bytes, we must not 'overrun' this buffer :-)
	 * One of the following functions will copy the data from the
	 * s->packet buffer */
d319 3
a330 3
	/* Set the state for the following operations */
	s->rstate=SSL_ST_READ_HEADER;

d334 1
a334 1
	/* check is not needed I belive */
d371 1
a371 1
		/* check MAC for rr->input' */
d471 1
a471 1
/* Call this to write data
d474 1
a474 1
int ssl3_write_bytes(SSL *s, int type, const void *_buf, int len)
d476 1
a476 1
	const unsigned char *buf=_buf;
d502 1
a502 1
			
a509 3
		if (type == SSL3_RT_HANDSHAKE)
			ssl3_finish_mac(s,&(buf[tot]),i);

d545 2
a546 2
	if (len <= 0) return(len);
	
d569 1
a569 1
	
d573 1
a573 1
	
d680 27
d709 2
a710 1
	int al,i,j,n,ret;
a712 1
	BIO *bio;
d714 1
a714 1
	if (s->s3->rbuf.buf == NULL) /* Not initialize yet */
d718 28
d748 1
d760 5
a764 5
	/* s->s3->rrec.type	- is the type of record
	 * s->s3->rrec.data, 	- data
	 * s->s3->rrec.off, 	- ofset into 'data' for next read
	 * s->s3->rrec.length,	- number of bytes. */
	rr= &(s->s3->rrec);
d775 3
a777 1
	if (s->s3->change_cipher_spec && (rr->type != SSL3_RT_HANDSHAKE))
d792 82
a873 3
	/* Check for an incoming 'Client Request' message */
	if ((rr->type == SSL3_RT_HANDSHAKE) && (rr->length == 4) &&
		(rr->data[0] == SSL3_MT_CLIENT_REQUEST) &&
d876 5
a880 2
		if ((rr->data[1] != 0) || (rr->data[2] != 0) ||
			(rr->data[3] != 0))
d883 1
a883 1
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CLIENT_REQUEST);
d894 3
a896 3
				n=s->handshake_func(s);
				if (n < 0) return(n);
				if (n == 0)
d901 15
d918 3
a920 2
		rr->length=0;
/* ZZZ */	goto start;
d923 1
a923 3
	/* if it is not the type we want, or we have shutdown and want
	 * the peer shutdown */
	if ((rr->type != type) || (s->shutdown & SSL_SENT_SHUTDOWN))
d925 2
a926 8
		if (rr->type == SSL3_RT_ALERT)
			{
			if ((rr->length != 2) || (rr->off != 0))
				{
				al=SSL_AD_DECODE_ERROR;
				SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_ALERT_RECORD);
				goto f_err;
				}
d928 1
a928 2
			i=rr->data[0];
			n=rr->data[1];
d930 4
a933 2
			/* clear from buffer */
			rr->length=0;
d935 5
a939 4
			if (s->info_callback != NULL)
				cb=s->info_callback;
			else if (s->ctx->info_callback != NULL)
				cb=s->ctx->info_callback;
d941 4
a944 7
			if (cb != NULL)
				{
				j=(i<<8)|n;
				cb(s,SSL_CB_READ_ALERT,j);
				}

			if (i == 1)
d946 1
a946 19
				s->s3->warn_alert=n;
				if (n == SSL_AD_CLOSE_NOTIFY)
					{
					s->shutdown|=SSL_RECEIVED_SHUTDOWN;
					return(0);
					}
				}
			else if (i == 2)
				{
				char tmp[16];

				s->rwstate=SSL_NOTHING;
				s->s3->fatal_alert=n;
				SSLerr(SSL_F_SSL3_READ_BYTES,
					SSL_AD_REASON_OFFSET+n);
				sprintf(tmp,"%d",n);
				ERR_add_error_data(2,"SSL alert number ",tmp);
				s->shutdown|=SSL_RECEIVED_SHUTDOWN;
				SSL_CTX_remove_session(s->ctx,s->session);
a948 9
			else
				{
				al=SSL_AD_ILLEGAL_PARAMETER;
				SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);
				goto f_err;
				}

			rr->length=0;
			goto start;
d950 3
a953 2
		if (s->shutdown & SSL_SENT_SHUTDOWN)
			{
d955 6
a960 1
			rr->length=0;
d963 9
d973 13
a985 1
		if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)
d987 12
a998 7
			if (	(rr->length != 1) || (rr->off != 0) ||
				(rr->data[0] != SSL3_MT_CCS))
				{
				i=SSL_AD_ILLEGAL_PARAMETER;
				SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);
				goto err;
				}
d1000 23
a1022 6
			rr->length=0;
			s->s3->change_cipher_spec=1;
			if (!do_change_cipher_spec(s))
				goto err;
			else
				goto start;
d1025 1
a1025 3
		/* else we have a handshake */
		if ((rr->type == SSL3_RT_HANDSHAKE) &&
			!s->in_handshake)
d1027 1
a1027 16
			if (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&
				!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))
				{
				s->state=SSL_ST_BEFORE|(s->server)
						?SSL_ST_ACCEPT
						:SSL_ST_CONNECT;
				s->new_session=1;
				}
			n=s->handshake_func(s);
			if (n < 0) return(n);
			if (n == 0)
				{
				SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
				return(-1);
				}

d1032 1
a1032 2
			 * in the non-blocking world */

d1039 2
d1042 6
a1047 1
		switch (rr->type)
d1049 2
a1050 7
		default:
#ifndef NO_TLS
			/* TLS just ignores unknown message types */
			if (s->version == TLS1_VERSION)
				{
				goto start;
				}
d1052 38
a1089 3
		case SSL3_RT_CHANGE_CIPHER_SPEC:
		case SSL3_RT_ALERT:
		case SSL3_RT_HANDSHAKE:
a1092 31
		case SSL3_RT_APPLICATION_DATA:
			/* At this point, we were expecting something else,
			 * but have application data.  What we do is set the
			 * error, and return -1.  On the way out, if the
			 * library was running inside ssl3_read() and it makes
			 * sense to read application data at this point, we
			 * will indulge it.  This will mostly happen during
			 * session renegotiation.
			 */
			if (s->s3->in_read_app_data &&
				(s->s3->total_renegotiations != 0) &&
				((
				  (s->state & SSL_ST_CONNECT) &&
				  (s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&
				  (s->state <= SSL3_ST_CR_SRVR_HELLO_A)
				 ) || (
				  (s->state & SSL_ST_ACCEPT) &&
				  (s->state <= SSL3_ST_SW_HELLO_REQ_A) &&
				  (s->state >= SSL3_ST_SR_CLNT_HELLO_A)
				 )
				))
				{
				s->s3->in_read_app_data=0;
				return(-1);
				}
			else
				{
				al=SSL_AD_UNEXPECTED_MESSAGE;
				SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
				goto f_err;
				}
d1095 1
a1096 29
	/* make sure that we are not getting application data when we
	 * are doing a handshake for the first time */
	if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&
		(s->enc_read_ctx == NULL))
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);
		goto f_err;
		}

	if (len <= 0) return(len);

	if ((unsigned int)len > rr->length)
		n=rr->length;
	else
		n=len;

	memcpy(buf,&(rr->data[rr->off]),(unsigned int)n);
	rr->length-=n;
	rr->off+=n;
	if (rr->length <= 0)
		{
		s->rstate=SSL_ST_READ_HEADER;
		rr->off=0;
		}

	if (type == SSL3_RT_HANDSHAKE)
		ssl3_finish_mac(s,buf,n);
	return(n);
d1106 1
a1106 1
	unsigned char *sender;
d1128 2
a1129 2
		sender=s->method->ssl3_enc->server_finished;
		slen=s->method->ssl3_enc->server_finished_len;
d1133 2
a1134 2
		sender=s->method->ssl3_enc->client_finished;
		slen=s->method->ssl3_enc->client_finished_len;
d1137 1
a1137 1
	s->method->ssl3_enc->final_finish_mac(s,
d1140 1
a1140 1
		sender,slen,&(s->s3->tmp.finish_md[0]));
a1144 14
int ssl3_do_write(SSL *s, int type)
	{
	int ret;

	ret=ssl3_write_bytes(s,type,&s->init_buf->data[s->init_off],
			     s->init_num);
	if (ret == s->init_num)
		return(1);
	if (ret < 0) return(-1);
	s->init_off+=ret;
	s->init_num-=ret;
	return(0);
	}

d1186 1
a1186 1
		
a1194 1

@


1.1
log
@Initial revision
@
text
@d62 2
a63 2
#include "evp.h"
#include "buffer.h"
d66 4
a69 21
/* SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_PEER_ERROR_NO_CIPHER);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_PEER_ERROR_NO_CERTIFICATE);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_PEER_ERROR_CERTIFICATE);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_UNKNOWN_REMOTE_ERROR_TYPE);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_BAD_RECORD_MAC);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_DECOMPRESSION_FAILURE);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_HANDSHAKE_FAILURE);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_NO_CERTIFICATE);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_BAD_CERTIFICATE);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN);
 * SSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_SSLV3_ALERT_ILLEGAL_PARAMETER);
 */

#ifndef NOPROTO
static int do_ssl3_write(SSL *s, int type, char *buf, unsigned int len);
static int ssl3_write_pending(SSL *s, int type, char *buf, unsigned int len);
d74 1
a74 14
#else
static int do_ssl3_write();
static int ssl3_write_pending();
static int ssl3_get_record();
static int do_compress();
static int do_uncompress();
static int do_change_cipher_spec();
#endif

static int ssl3_read_n(s,n,max,extend)
SSL *s;
int n;
int max;
int extend;
d183 1
a183 2
static int ssl3_get_record(s)
SSL *s;
a184 1
	char tmp_buf[512];
a301 1
	memcpy(tmp_buf,rr->input,(rr->length > 512)?512:rr->length);
d310 1
a310 1
{ int z; for (z=0; z<rr->length; z++) printf("%02X%c",rr->data[z],((z+1)%16)?' ':'\n'); }
d348 1
a348 1
	if ((sess != NULL) && (sess->read_compression != NULL))
d394 1
a394 2
static int do_uncompress(ssl)
SSL *ssl;
d396 12
d411 1
a411 2
static int do_compress(ssl)
SSL *ssl;
d413 13
d432 1
a432 5
int ssl3_write_bytes(s,type,buf,len)
SSL *s;
int type;
char *buf;
int len;
d434 1
d469 1
a469 1
			ssl3_finish_mac(s,(unsigned char *)&(buf[tot]),i);
d471 6
a476 1
		if (i == (int)n) return(tot+i);
d483 2
a484 5
static int do_ssl3_write(s,type,buf,len)
SSL *s;
int type;
char *buf;
unsigned int len;
d544 1
a544 1
	if ((sess != NULL) && (sess->write_compression != NULL))
d598 2
a599 5
static int ssl3_write_pending(s,type,buf,len)
SSL *s;
int type;
char *buf;
unsigned int len;
d604 3
a606 1
	if ((s->s3->wpend_tot > (int)len) || (s->s3->wpend_buf != buf)
d641 1
a641 5
int ssl3_read_bytes(s,type,buf,len)
SSL *s;
int type;
char *buf;
int len;
d648 1
a648 1
	if (s->s3->rbuf.buf == NULL) /* Not initalised yet */
d773 2
a774 1
				SSLerr(SSL_F_SSL3_READ_BYTES,1000+n);
d824 3
a826 1
				s->state=SSL_ST_BEFORE;
d927 1
a927 1
		ssl3_finish_mac(s,(unsigned char *)buf,n);
d935 1
a935 2
static int do_change_cipher_spec(s)
SSL *s;
d977 1
a977 3
int ssl3_do_write(s,type)
SSL *s;
int type;
d981 2
a982 2
	ret=ssl3_write_bytes(s,type,(char *)
		&(s->init_buf->data[s->init_off]),s->init_num);
d991 1
a991 4
void ssl3_send_alert(s,level,desc)
SSL *s;
int level;
int desc;
d1009 1
a1009 2
int ssl3_dispatch_alert(s)
SSL *s;
d1015 1
a1015 1
	i=do_ssl3_write(s,SSL3_RT_ALERT,&(s->s3->send_alert[0]),2);
d1026 1
a1026 1
			BIO_flush(s->wbio);
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d62 2
a63 2
#include <openssl/evp.h>
#include <openssl/buffer.h>
d66 21
a86 4
static int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
			 unsigned int len, int create_empty_fragment);
static int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
			      unsigned int len);
d91 8
d100 5
a104 2
/* used only by ssl3_get_record */
static int ssl3_read_n(SSL *s, int n, int max, int extend)
a105 7
	/* If extend == 0, obtain new n-byte packet; if extend == 1, increase
	 * packet by another n bytes.
	 * The packet will be in the sub-array of s->s3->rbuf.buf specified
	 * by s->packet and s->packet_length.
	 * (If s->read_ahead is set, 'max' bytes may be stored in rbuf
	 * [plus s->packet_length bytes if extend == 1].)
	 */
d108 2
a109 11
	if (!extend)
		{
		/* start with empty packet ... */
		if (s->s3->rbuf.left == 0)
			s->s3->rbuf.offset = 0;
		s->packet = s->s3->rbuf.buf + s->s3->rbuf.offset;
		s->packet_length = 0;
		/* ... now we can act as if 'extend' was set */
		}

	/* if there is enough in the buffer from a previous read, take some */
d112 7
a118 1
		s->packet_length+=n;
d125 25
a149 2
	if (!s->read_ahead)
		max=n;
d151 1
a151 10
	{
		/* avoid buffer overflow */
		int max_max = s->s3->rbuf.len - s->packet_length;
		if (max > max_max)
			max = max_max;
	}
	if (n > max) /* does not happen */
		{
		SSLerr(SSL_F_SSL3_READ_N,ERR_R_INTERNAL_ERROR);
		return -1;
d153 2
d156 5
a160 11
	off = s->packet_length;
	newb = s->s3->rbuf.left;
	/* Move any available bytes to front of buffer:
	 * 'off' bytes already pointed to by 'packet',
	 * 'newb' extra ones at the end */
	if (s->packet != s->s3->rbuf.buf)
		{
		/*  off > 0 */
		memmove(s->s3->rbuf.buf, s->packet, off+newb);
		s->packet = s->s3->rbuf.buf;
		}
a163 3
		/* Now we have off+newb bytes at the front of s->s3->rbuf.buf and need
		 * to read in more until we have off+n (up to off+max if possible) */

d168 3
a170 1
			i=BIO_read(s->rbio,	&(s->s3->rbuf.buf[off+newb]), max-newb);
d175 1
a175 1
			i = -1;
d180 1
a180 1
			s->s3->rbuf.left = newb;
d186 16
a201 5
	/* done reading, now the book-keeping */
	s->s3->rbuf.offset = off + n;
	s->s3->rbuf.left = newb - n;
	s->packet_length += n;
	s->rwstate=SSL_NOTHING;
d209 2
a210 2
 * ssl->s3->rrec.type    - is the type of record
 * ssl->s3->rrec.data, 	 - data
d213 2
a214 2
/* used only by ssl3_read_bytes */
static int ssl3_get_record(SSL *s)
d216 1
d218 2
a219 1
	int enc_err,n,i,ret= -1;
d226 1
a226 2
	int clear=0;
	size_t extra;
d229 1
a235 7
	if (extra != s->s3->rbuf.len - SSL3_RT_MAX_PACKET_SIZE)
		{
		/* actually likely an application error: SLS_OP_MICROSOFT_BIG_SSLV3_BUFFER
		 * set after ssl3_setup_buffers() was done */
		SSLerr(SSL_F_SSL3_GET_RECORD, ERR_R_INTERNAL_ERROR);
		return -1;
		}
d242 2
a243 1
		n=ssl3_read_n(s, SSL3_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);
d280 2
a281 1
		if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)
d288 1
a288 1
		/* now s->rstate == SSL_ST_READ_BODY */
d291 2
a292 3
	/* s->rstate == SSL_ST_READ_BODY, get and decode the data */

	if (rr->length > s->packet_length-SSL3_RT_HEADER_LENGTH)
d294 8
a301 6
		/* now s->packet_length == SSL3_RT_HEADER_LENGTH */
		i=rr->length;
		n=ssl3_read_n(s,i,i,1);
		if (n <= 0) return(n); /* error or non-blocking io */
		/* now n == rr->length,
		 * and s->packet_length == SSL3_RT_HEADER_LENGTH + rr->length */
d304 4
a307 1
	s->rstate=SSL_ST_READ_HEADER; /* set state for later operations */
a308 3
	/* At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,
	 * and we have that many bytes in s->packet
	 */
d318 3
d324 2
a325 2
	/* check is not needed I believe */
	if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)
d334 1
d336 1
a336 2
	enc_err = s->method->ssl3_enc->enc(s,0);
	if (enc_err <= 0)
d338 2
a339 6
		if (enc_err == 0)
			/* SSLerr() and ssl3_send_alert() have been called */
			goto err;

		/* otherwise enc_err == -1 */
		goto decryption_failed_or_bad_record_mac;
a340 1

d343 1
a343 1
{ unsigned int z; for (z=0; z<rr->length; z++) printf("%02X%c",rr->data[z],((z+1)%16)?' ':'\n'); }
a345 1

a357 1
#if 0 /* OK only for stream ciphers (then rr->length is visible from ciphertext anyway) */
a360 3
#else
			goto decryption_failed_or_bad_record_mac;
#endif			
d362 1
a362 1
		/* check the MAC for rr->input (it's in mac_size bytes at the tail) */
a364 1
#if 0 /* OK only for stream ciphers */
a367 3
#else
			goto decryption_failed_or_bad_record_mac;
#endif
d373 4
a376 1
			goto decryption_failed_or_bad_record_mac;
d381 1
a381 1
	if (s->expand != NULL)
d383 2
a384 1
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra)
d398 1
a398 1
	if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH+extra)
a420 9

decryption_failed_or_bad_record_mac:
	/* Separate 'decryption_failed' alert was introduced with TLS 1.0,
	 * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption
	 * failure is directly visible from the ciphertext anyway,
	 * we should not reveal which kind of error occured -- this
	 * might become visible to an attacker (e.g. via logfile) */
	al=SSL_AD_BAD_RECORD_MAC;
	SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
d427 2
a428 1
static int do_uncompress(SSL *ssl)
a429 12
	int i;
	SSL3_RECORD *rr;

	rr= &(ssl->s3->rrec);
	i=COMP_expand_block(ssl->expand,rr->comp,
		SSL3_RT_MAX_PLAIN_LENGTH,rr->data,(int)rr->length);
	if (i < 0)
		return(0);
	else
		rr->length=i;
	rr->data=rr->comp;

d433 2
a434 1
static int do_compress(SSL *ssl)
a435 13
	int i;
	SSL3_RECORD *wr;

	wr= &(ssl->s3->wrec);
	i=COMP_compress_block(ssl->compress,wr->data,
		SSL3_RT_MAX_COMPRESSED_LENGTH,
		wr->input,(int)wr->length);
	if (i < 0)
		return(0);
	else
		wr->length=i;

	wr->input=wr->data;
d439 1
a439 1
/* Call this to write data in records of type 'type'
d442 5
a446 1
int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
a447 1
	const unsigned char *buf=buf_;
d462 1
a462 1
			return -1;
d473 2
a474 2

		i=do_ssl3_write(s, type, &(buf[tot]), nw, 0);
d478 1
a478 1
			return i;
d481 4
a484 10
		if ((i == (int)n) ||
			(type == SSL3_RT_APPLICATION_DATA &&
			 (s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE)))
			{
			/* next chunk of data should get another prepended empty fragment
			 * in ciphersuites with known-IV weakness: */
			s->s3->empty_fragment_done = 0;
			
			return tot+i;
			}
d491 5
a495 2
static int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
			 unsigned int len, int create_empty_fragment)
a498 1
	int prefix_len = 0;
d503 1
a503 1
	/* first check if there is a SSL3_BUFFER still being written
d517 2
a518 3
	if (len == 0 && !create_empty_fragment)
		return 0;

d533 1
a533 28
	/* 'create_empty_fragment' is true only when this function calls itself */
	if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done)
		{
		/* countermeasure against known-IV weakness in CBC ciphersuites
		 * (see http://www.openssl.org/~bodo/tls-cbc.txt) */

		if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA)
			{
			/* recursive function call with 'create_empty_fragment' set;
			 * this prepares and buffers the data for an empty fragment
			 * (these 'prefix_len' bytes are sent out later
			 * together with the actual payload) */
			prefix_len = do_ssl3_write(s, type, buf, 0, 1);
			if (prefix_len <= 0)
				goto err;

			if (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE)
				{
				/* insufficient space */
				SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);
				goto err;
				}
			}
		
		s->s3->empty_fragment_done = 1;
		}

	p = wb->buf + prefix_len;
a535 1

d541 2
a542 2

	/* field where we are to write out packet length */
d545 1
a545 1

d555 1
a555 1
	if (s->compress != NULL)
d593 3
a595 11
	if (create_empty_fragment)
		{
		/* we are in a recursive call;
		 * just return the length, don't write out anything here
		 */
		return wr->length;
		}

	/* now let's set up wb */
	wb->left = prefix_len + wr->length;
	wb->offset = 0;
a596 1
	/* memorize arguments so that ssl3_write_pending can detect bad write retries later */
d603 1
a603 1
	return ssl3_write_pending(s,type,buf,len);
d605 1
a605 1
	return -1;
d609 5
a613 2
static int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
			      unsigned int len)
d618 1
a618 3
	if ((s->s3->wpend_tot > (int)len)
		|| ((s->s3->wpend_buf != buf) &&
			!(s->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER))
d653 5
a657 28
/* Return up to 'len' payload bytes received in 'type' records.
 * 'type' is one of the following:
 *
 *   -  SSL3_RT_HANDSHAKE (when ssl3_get_message calls us)
 *   -  SSL3_RT_APPLICATION_DATA (when ssl3_read calls us)
 *   -  0 (during a shutdown, no data has to be returned)
 *
 * If we don't have stored data to work from, read a SSL/TLS record first
 * (possibly multiple records if we still don't have anything to return).
 *
 * This function must handle any surprises the peer may have for us, such as
 * Alert records (e.g. close_notify), ChangeCipherSpec records (not really
 * a surprise, but handled as if it were), or renegotiation requests.
 * Also if record payloads contain fragments too small to process, we store
 * them until there is enough for the respective protocol (the record protocol
 * may use arbitrary fragmentation and even interleaving):
 *     Change cipher spec protocol
 *             just 1 byte needed, no need for keeping anything stored
 *     Alert protocol
 *             2 bytes needed (AlertLevel, AlertDescription)
 *     Handshake protocol
 *             4 bytes needed (HandshakeType, uint24 length) -- we just have
 *             to detect unexpected Client Hello and Hello Request messages
 *             here, anything else is handled by higher layers
 *     Application data protocol
 *             none of our business
 */
int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
d659 1
a659 2
	int al,i,j,ret;
	unsigned int n;
d661 2
a662 1
	void (*cb)(const SSL *ssl,int type2,int val)=NULL;
d664 1
a664 1
	if (s->s3->rbuf.buf == NULL) /* Not initialized yet */
a667 30
	if ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE) && type) ||
	    (peek && (type != SSL3_RT_APPLICATION_DATA)))
		{
		SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);
		return -1;
		}

	if ((type == SSL3_RT_HANDSHAKE) && (s->s3->handshake_fragment_len > 0))
		/* (partially) satisfy request from storage */
		{
		unsigned char *src = s->s3->handshake_fragment;
		unsigned char *dst = buf;
		unsigned int k;

		/* peek == 0 */
		n = 0;
		while ((len > 0) && (s->s3->handshake_fragment_len > 0))
			{
			*dst++ = *src++;
			len--; s->s3->handshake_fragment_len--;
			n++;
			}
		/* move any remaining fragment bytes: */
		for (k = 0; k < s->s3->handshake_fragment_len; k++)
			s->s3->handshake_fragment[k] = *src++;
		return n;
	}

	/* Now s->s3->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE. */

a669 1
		/* type == SSL3_RT_APPLICATION_DATA */
d681 5
a685 5
	/* s->s3->rrec.type	    - is the type of record
	 * s->s3->rrec.data,    - data
	 * s->s3->rrec.off,     - offset into 'data' for next read
	 * s->s3->rrec.length,  - number of bytes. */
	rr = &(s->s3->rrec);
d687 1
a687 1
	/* get new packet if necessary */
d696 1
a696 3
	if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,
	                               * reset by ssl3_get_finished */
		&& (rr->type != SSL3_RT_HANDSHAKE))
d703 1
a703 2
	/* If the other end has shut down, throw anything we read away
	 * (even in 'peek' mode) */
d711 3
a713 85

	if (type == rr->type) /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */
		{
		/* make sure that we are not getting application data when we
		 * are doing a handshake for the first time */
		if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&
			(s->enc_read_ctx == NULL))
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);
			goto f_err;
			}

		if (len <= 0) return(len);

		if ((unsigned int)len > rr->length)
			n = rr->length;
		else
			n = (unsigned int)len;

		memcpy(buf,&(rr->data[rr->off]),n);
		if (!peek)
			{
			rr->length-=n;
			rr->off+=n;
			if (rr->length == 0)
				{
				s->rstate=SSL_ST_READ_HEADER;
				rr->off=0;
				}
			}
		return(n);
		}


	/* If we get here, then type != rr->type; if we have a handshake
	 * message, then it was unexpected (Hello Request or Client Hello). */

	/* In case of record types for which we have 'fragment' storage,
	 * fill that so that we can process the data at a fixed place.
	 */
		{
		unsigned int dest_maxlen = 0;
		unsigned char *dest = NULL;
		unsigned int *dest_len = NULL;

		if (rr->type == SSL3_RT_HANDSHAKE)
			{
			dest_maxlen = sizeof s->s3->handshake_fragment;
			dest = s->s3->handshake_fragment;
			dest_len = &s->s3->handshake_fragment_len;
			}
		else if (rr->type == SSL3_RT_ALERT)
			{
			dest_maxlen = sizeof s->s3->alert_fragment;
			dest = s->s3->alert_fragment;
			dest_len = &s->s3->alert_fragment_len;
			}

		if (dest_maxlen > 0)
			{
			n = dest_maxlen - *dest_len; /* available space in 'dest' */
			if (rr->length < n)
				n = rr->length; /* available bytes */

			/* now move 'n' bytes: */
			while (n-- > 0)
				{
				dest[(*dest_len)++] = rr->data[rr->off++];
				rr->length--;
				}

			if (*dest_len < dest_maxlen)
				goto start; /* fragment was too small */
			}
		}

	/* s->s3->handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;
	 * s->s3->alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.
	 * (Possibly rr is 'empty' now, i.e. rr->length may be 0.) */

	/* If we are a client, check for an incoming 'Hello Request': */
	if ((!s->server) &&
		(s->s3->handshake_fragment_len >= 4) &&
		(s->s3->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&
d716 2
a717 5
		s->s3->handshake_fragment_len = 0;

		if ((s->s3->handshake_fragment[1] != 0) ||
			(s->s3->handshake_fragment[2] != 0) ||
			(s->s3->handshake_fragment[3] != 0))
d720 1
a720 1
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);
a723 3
		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->s3->handshake_fragment, 4, s, s->msg_callback_arg);

d731 3
a733 3
				i=s->handshake_func(s);
				if (i < 0) return(i);
				if (i == 0)
a737 17

				if (!(s->mode & SSL_MODE_AUTO_RETRY))
					{
					if (s->s3->rbuf.left == 0) /* no read-ahead left? */
						{
						BIO *bio;
						/* In the case where we try to read application data,
						 * but we trigger an SSL handshake, we return -1 with
						 * the retry option set.  Otherwise renegotiation may
						 * cause nasty problems in the blocking world */
						s->rwstate=SSL_READING;
						bio=SSL_get_rbio(s);
						BIO_clear_retry_flags(bio);
						BIO_set_retry_read(bio);
						return(-1);
						}
					}
d740 2
a741 3
		/* we either finished a handshake or ignored the request,
		 * now try again to obtain the (application) data we were asked for */
		goto start;
d744 3
a746 1
	if (s->s3->alert_fragment_len >= 2)
d748 8
a755 2
		int alert_level = s->s3->alert_fragment[0];
		int alert_descr = s->s3->alert_fragment[1];
d757 2
a758 1
		s->s3->alert_fragment_len = 0;
d760 2
a761 2
		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_ALERT, s->s3->alert_fragment, 2, s, s->msg_callback_arg);
d763 4
a766 4
		if (s->info_callback != NULL)
			cb=s->info_callback;
		else if (s->ctx->info_callback != NULL)
			cb=s->ctx->info_callback;
d768 5
a772 5
		if (cb != NULL)
			{
			j = (alert_level << 8) | alert_descr;
			cb(s, SSL_CB_READ_ALERT, j);
			}
d774 10
a783 4
		if (alert_level == 1) /* warning */
			{
			s->s3->warn_alert = alert_descr;
			if (alert_descr == SSL_AD_CLOSE_NOTIFY)
d785 9
a793 1
				s->shutdown |= SSL_RECEIVED_SHUTDOWN;
d796 9
d806 2
a807 1
		else if (alert_level == 2) /* fatal */
a808 2
			char tmp[16];

d810 1
a810 6
			s->s3->fatal_alert = alert_descr;
			SSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);
			BIO_snprintf(tmp,sizeof tmp,"%d",alert_descr);
			ERR_add_error_data(2,"SSL alert number ",tmp);
			s->shutdown|=SSL_RECEIVED_SHUTDOWN;
			SSL_CTX_remove_session(s->ctx,s->session);
d813 2
a814 1
		else
d816 14
a829 3
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);
			goto f_err;
d832 3
a834 16
		goto start;
		}

	if (s->shutdown & SSL_SENT_SHUTDOWN) /* but we have not received a shutdown */
		{
		s->rwstate=SSL_NOTHING;
		rr->length=0;
		return(0);
		}

	if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)
		{
		/* 'Change Cipher Spec' is just a single byte, so we know
		 * exactly what the record payload has to look like */
		if (	(rr->length != 1) || (rr->off != 0) ||
			(rr->data[0] != SSL3_MT_CCS))
d836 13
a848 6
			i=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);
			goto err;
			}

		rr->length=0;
d850 5
a854 2
		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, rr->data, 1, s, s->msg_callback_arg);
d856 4
a859 29
		s->s3->change_cipher_spec=1;
		if (!do_change_cipher_spec(s))
			goto err;
		else
			goto start;
		}

	/* Unexpected handshake message (Client Hello, or protocol violation) */
	if ((s->s3->handshake_fragment_len >= 4) &&	!s->in_handshake)
		{
		if (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))
			{
#if 0 /* worked only because C operator preferences are not as expected (and
       * because this is not really needed for clients except for detecting
       * protocol violations): */
			s->state=SSL_ST_BEFORE|(s->server)
				?SSL_ST_ACCEPT
				:SSL_ST_CONNECT;
#else
			s->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;
#endif
			s->new_session=1;
			}
		i=s->handshake_func(s);
		if (i < 0) return(i);
		if (i == 0)
			{
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
d863 1
a863 1
		if (!(s->mode & SSL_MODE_AUTO_RETRY))
d865 35
a899 1
			if (s->s3->rbuf.left == 0) /* no read-ahead left? */
d901 1
a901 9
				BIO *bio;
				/* In the case where we try to read application data,
				 * but we trigger an SSL handshake, we return -1 with
				 * the retry option set.  Otherwise renegotiation may
				 * cause nasty problems in the blocking world */
				s->rwstate=SSL_READING;
				bio=SSL_get_rbio(s);
				BIO_clear_retry_flags(bio);
				BIO_set_retry_read(bio);
d904 6
a910 1
		goto start;
d913 4
a916 1
	switch (rr->type)
a917 9
	default:
#ifndef OPENSSL_NO_TLS
		/* TLS just ignores unknown message types */
		if (s->version == TLS1_VERSION)
			{
			rr->length = 0;
			goto start;
			}
#endif
d919 1
a919 1
		SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
a920 39
	case SSL3_RT_CHANGE_CIPHER_SPEC:
	case SSL3_RT_ALERT:
	case SSL3_RT_HANDSHAKE:
		/* we already handled all of these, with the possible exception
		 * of SSL3_RT_HANDSHAKE when s->in_handshake is set, but that
		 * should not happen when type != rr->type */
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_READ_BYTES,ERR_R_INTERNAL_ERROR);
		goto f_err;
	case SSL3_RT_APPLICATION_DATA:
		/* At this point, we were expecting handshake data,
		 * but have application data.  If the library was
		 * running inside ssl3_read() (i.e. in_read_app_data
		 * is set) and it makes sense to read application data
		 * at this point (session renegotiation not yet started),
		 * we will indulge it.
		 */
		if (s->s3->in_read_app_data &&
			(s->s3->total_renegotiations != 0) &&
			((
				(s->state & SSL_ST_CONNECT) &&
				(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&
				(s->state <= SSL3_ST_CR_SRVR_HELLO_A)
				) || (
					(s->state & SSL_ST_ACCEPT) &&
					(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&
					(s->state >= SSL3_ST_SR_CLNT_HELLO_A)
					)
				))
			{
			s->s3->in_read_app_data=2;
			return(-1);
			}
		else
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
			goto f_err;
			}
a921 1
	/* not reached */
d923 19
d948 2
a949 1
static int do_change_cipher_spec(SSL *s)
d952 1
a952 1
	const char *sender;
d974 2
a975 2
		sender=s->method->ssl3_enc->server_finished_label;
		slen=s->method->ssl3_enc->server_finished_label_len;
d979 2
a980 2
		sender=s->method->ssl3_enc->client_finished_label;
		slen=s->method->ssl3_enc->client_finished_label_len;
d983 1
a983 1
	s->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,
d986 1
a986 1
		sender,slen,s->s3->tmp.peer_finish_md);
d991 20
a1010 1
void ssl3_send_alert(SSL *s, int level, int desc)
a1013 2
	if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)
		desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have protocol_version alerts */
d1022 1
a1022 1
	if (s->s3->wbuf.left == 0) /* data still being written out? */
d1028 2
a1029 1
int ssl3_dispatch_alert(SSL *s)
d1032 1
a1032 1
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
d1035 1
a1035 1
	i = do_ssl3_write(s, SSL3_RT_ALERT, &s->s3->send_alert[0], 2, 0);
d1042 3
a1044 3
		/* Alert sent to BIO.  If it is important, flush it now.
		 * If the message does not get sent due to non-blocking IO,
		 * we will not worry too much. */
d1046 1
a1046 4
			(void)BIO_flush(s->wbio);

		if (s->msg_callback)
			s->msg_callback(1, s->version, SSL3_RT_ALERT, s->s3->send_alert, 2, s, s->msg_callback_arg);
d1052 1
a1052 1

d1061 1
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a114 1
#include "ssl_locl.h"
d117 1
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a240 2
	int decryption_failed_or_bad_record_mac = 0;
	unsigned char *mac = NULL;
d356 2
a357 5
		/* Otherwise enc_err == -1, which indicates bad padding
		 * (rec->length has not been changed in this case).
		 * To minimize information leaked via timing, we will perform
		 * the MAC computation anyway. */
		decryption_failed_or_bad_record_mac = 1;
d383 1
a383 1
			decryption_failed_or_bad_record_mac = 1;
d387 1
a387 1
		if (rr->length >= mac_size)
a388 6
			rr->length -= mac_size;
			mac = &rr->data[rr->length];
			}
		else
			{
			/* record (minus padding) is too short to contain a MAC */
d394 1
a394 2
			decryption_failed_or_bad_record_mac = 1;
			rr->length = 0;
d397 1
d399 1
a399 1
		if (mac == NULL || memcmp(md, mac, mac_size) != 0)
d401 1
a401 1
			decryption_failed_or_bad_record_mac = 1;
a404 12
	if (decryption_failed_or_bad_record_mac)
		{
		/* A separate 'decryption_failed' alert was introduced with TLS 1.0,
		 * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption
		 * failure is directly visible from the ciphertext anyway,
		 * we should not reveal which kind of error occured -- this
		 * might become visible to an attacker (e.g. via a logfile) */
		al=SSL_AD_BAD_RECORD_MAC;
		SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
		goto f_err;
		}

d446 8
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@a1087 8
		/* Check we have a cipher to change to */
		if (s->s3->tmp.new_cipher == NULL)
			{
			i=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
			goto err;
			}

@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d865 1
a865 1
		goto f_err;
d972 1
a972 1
			goto f_err;
d1083 1
a1083 1
			al=SSL_AD_ILLEGAL_PARAMETER;
d1085 1
a1085 1
			goto f_err;
d1091 1
a1091 1
			al=SSL_AD_UNEXPECTED_MESSAGE;
d1093 1
a1093 1
			goto f_err;
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d121 2
d124 3
d128 2
a129 1
int ssl3_read_n(SSL *s, int n, int max, int extend)
a149 8
	/* extend reads should not span multiple packets for DTLS */
	if ( SSL_version(s) == DTLS1_VERSION &&
		extend)
		{
		if ( s->s3->rbuf.left > 0 && n > s->s3->rbuf.left)
			n = s->s3->rbuf.left;
		}

d278 5
a282 1
		if (!s->first_packet)
d437 1
a437 1
		if (!ssl3_do_uncompress(s))
d475 1
a475 1
int ssl3_do_uncompress(SSL *ssl)
a476 1
#ifndef OPENSSL_NO_COMP
d488 1
a488 1
#endif
d492 1
a492 1
int ssl3_do_compress(SSL *ssl)
a493 1
#ifndef OPENSSL_NO_COMP
a506 1
#endif
d583 1
a583 1
		i=s->method->ssl_dispatch_alert(s);
d658 1
a658 1
		if (!ssl3_do_compress(s))
d719 2
a720 2
int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
	unsigned int len)
d1092 1
a1092 1
			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);
d1102 1
a1102 1
		if (!ssl3_do_change_cipher_spec(s))
d1214 1
a1214 1
int ssl3_do_change_cipher_spec(SSL *s)
d1271 1
a1271 1
		s->method->ssl_dispatch_alert(s);
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@d756 1
a756 7
		else if (i <= 0) {
			if (s->version == DTLS1_VERSION ||
			    s->version == DTLS1_BAD_VER) {
				/* For DTLS, just drop it. That's kind of the whole
				   point in using a datagram service */
				s->s3->wbuf.left = 0;
			}
a757 1
		}
a1227 7
		if (s->session == NULL) 
			{
			/* might happen if dtls1_read_bytes() calls this */
			SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,SSL_R_CCS_RECEIVED_EARLY);
			return (0);
			}

@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d132 1
a132 17
	int i,len,left;
	long align=0;
	unsigned char *pkt;
	SSL3_BUFFER *rb;

	if (n <= 0) return n;

	rb    = &(s->s3->rbuf);
	if (rb->buf == NULL)
		if (!ssl3_setup_read_buffer(s))
			return -1;

	left  = rb->left;
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
	align = (long)rb->buf + SSL3_RT_HEADER_LENGTH;
	align = (-align)&(SSL3_ALIGN_PAYLOAD-1);
#endif
d137 3
a139 22
		if (left == 0)
			rb->offset = align;
		else if (align != 0 && left >= SSL3_RT_HEADER_LENGTH)
			{
			/* check if next packet length is large
			 * enough to justify payload alignment... */
			pkt = rb->buf + rb->offset;
			if (pkt[0] == SSL3_RT_APPLICATION_DATA
			    && (pkt[3]<<8|pkt[4]) >= 128)
				{
				/* Note that even if packet is corrupted
				 * and its length field is insane, we can
				 * only be led to wrong decision about
				 * whether memmove will occur or not.
				 * Header values has no effect on memmove
				 * arguments and therefore no buffer
				 * overrun can be triggered. */
				memmove (rb->buf+align,pkt,left);
				rb->offset = align;
				}
			}
		s->packet = rb->buf + rb->offset;
d144 3
a146 4
	/* For DTLS/UDP reads should not span multiple packets
	 * because the read operation returns the whole packet
	 * at once (as long as it fits into the buffer). */
	if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
d148 2
a149 2
		if (left > 0 && n > left)
			n = left;
d153 1
a153 1
	if (left >= n)
d156 2
a157 2
		rb->left=left-n;
		rb->offset+=n;
d162 2
d165 7
a171 13
	len = s->packet_length;
	pkt = rb->buf+align;
	/* Move any available bytes to front of buffer:
	 * 'len' bytes already pointed to by 'packet',
	 * 'left' extra ones at the end */
	if (s->packet != pkt) /* len > 0 */
		{
		memmove(pkt, s->packet, len+left);
		s->packet = pkt;
		rb->offset = len + align;
		}

	if (n > (int)(rb->len - rb->offset)) /* does not happen */
d177 6
a182 4
	if (!s->read_ahead)
		/* ignore max parameter */
		max = n;
	else
d184 3
a186 4
		if (max < n)
			max = n;
		if (max > (int)(rb->len - rb->offset))
			max = rb->len - rb->offset;
d189 1
a189 1
	while (left < n)
d191 2
a192 3
		/* Now we have len+left bytes at the front of s->s3->rbuf.buf
		 * and need to read in more until we have len+n (up to
		 * len+max if possible) */
d198 1
a198 1
			i=BIO_read(s->rbio,pkt+len+left, max-left);
d208 1
a208 4
			rb->left = left;
			if (s->mode & SSL_MODE_RELEASE_BUFFERS)
				if (len+left == 0)
					ssl3_release_read_buffer(s);
d211 1
a211 9
		left+=i;
		/* reads should *never* span multiple packets for DTLS because
		 * the underlying transport protocol is message oriented as opposed
		 * to byte oriented as in the TLS case. */
		if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
			{
			if (n > left)
				n = left; /* makes the while condition false */
			}
d215 2
a216 2
	rb->offset += n;
	rb->left = left - n;
d240 1
a240 1
	int mac_size;
d253 1
a253 1
	if (extra && !s->s3->init_extra)
d255 1
a255 1
		/* An application error: SLS_OP_MICROSOFT_BIG_SSLV3_BUFFER
a277 3
#if 0
fprintf(stderr, "Record type=%d, Length=%d\n", rr->type, rr->length);
#endif
d285 3
a287 3
                                if ((s->version & 0xFF00) == (version & 0xFF00))
                                	/* Send back error using their minor version number :-) */
					s->version = (unsigned short)version;
d299 1
a299 1
		if (rr->length > s->s3->rbuf.len - SSL3_RT_HEADER_LENGTH)
d372 1
a372 1
		(EVP_MD_CTX_md(s->read_hash) == NULL))
d377 1
a377 3
		/* !clear => s->read_hash != NULL => mac_size != -1 */
		mac_size=EVP_MD_CTX_size(s->read_hash);
		OPENSSL_assert(mac_size >= 0);
d390 1
a390 1
		if (rr->length >= (unsigned int)mac_size)
d408 1
a408 1
		if (i < 0 || mac == NULL || memcmp(md, mac, (size_t)mac_size) != 0)
a464 4
#if 0
fprintf(stderr, "Ultimate Record type=%d, Length=%d\n", rr->type, rr->length);
#endif

d538 2
a539 2
		if (n > s->max_send_fragment)
			nw=s->max_send_fragment;
d571 1
a571 2
	int prefix_len=0;
	long align=0;
d573 1
a573 1
	SSL3_BUFFER *wb=&(s->s3->wbuf);
a575 4
 	if (wb->buf == NULL)
		if (!ssl3_setup_write_buffer(s))
			return -1;

d578 1
a578 1
	if (wb->left != 0)
d594 1
d599 1
a599 1
		(EVP_MD_CTX_md(s->write_hash) == NULL))
d605 1
a605 5
		{
		mac_size=EVP_MD_CTX_size(s->write_hash);
		if (mac_size < 0)
			goto err;
		}
d623 1
a623 2
			if (prefix_len >
		(SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD))
d634 1
a634 26
	if (create_empty_fragment)
		{
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
		/* extra fragment would be couple of cipher blocks,
		 * which would be multiple of SSL3_ALIGN_PAYLOAD, so
		 * if we want to align the real payload, then we can
		 * just pretent we simply have two headers. */
		align = (long)wb->buf + 2*SSL3_RT_HEADER_LENGTH;
		align = (-align)&(SSL3_ALIGN_PAYLOAD-1);
#endif
		p = wb->buf + align;
		wb->offset  = align;
		}
	else if (prefix_len)
		{
		p = wb->buf + wb->offset + prefix_len;
		}
	else
		{
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
		align = (long)wb->buf + SSL3_RT_HEADER_LENGTH;
		align = (-align)&(SSL3_ALIGN_PAYLOAD-1);
#endif
		p = wb->buf + align;
		wb->offset  = align;
		}
d677 1
a677 2
		if (s->method->ssl3_enc->mac(s,&(p[wr->length]),1) < 0)
			goto err;
d705 1
a723 1
	SSL3_BUFFER *wb=&(s->s3->wbuf);
d742 2
a743 2
				(char *)&(wb->buf[wb->offset]),
				(unsigned int)wb->left);
d750 1
a750 1
		if (i == wb->left)
d752 1
a752 4
			wb->left=0;
			wb->offset+=i;
			if (s->mode & SSL_MODE_RELEASE_BUFFERS)
				ssl3_release_write_buffer(s);
d761 1
a761 1
				wb->left = 0;
d765 2
a766 2
		wb->offset+=i;
		wb->left-=i;
d805 1
a805 1
		if (!ssl3_setup_read_buffer(s))
a913 2
				if (s->mode & SSL_MODE_RELEASE_BUFFERS)
					ssl3_release_read_buffer(s);
d1023 1
a1023 19
	/* If we are a server and get a client hello when renegotiation isn't
	 * allowed send back a no renegotiation alert and carry on.
	 * WARNING: experimental code, needs reviewing (steve)
	 */
	if (s->server &&
		SSL_is_init_finished(s) &&
    		!s->s3->send_connection_binding &&
		(s->version > SSL3_VERSION) &&
		(s->s3->handshake_fragment_len >= 4) &&
		(s->s3->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&
		(s->session != NULL) && (s->session->cipher != NULL) &&
		!(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
		
		{
		/*s->s3->handshake_fragment_len = 0;*/
		rr->length = 0;
		ssl3_send_alert(s,SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);
		goto start;
		}
a1052 15
			/* This is a warning but we receive it if we requested
			 * renegotiation and the peer denied it. Terminate with
			 * a fatal alert because if application tried to
			 * renegotiatie it presumably had a good reason and
			 * expects it to succeed.
			 *
			 * In future we might have a renegotiation where we
			 * don't care if the peer refused it where we carry on.
			 */
			else if (alert_descr == SSL_AD_NO_RENEGOTIATION)
				{
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_NO_RENEGOTIATION);
				goto f_err;
				}
d1264 2
d1271 1
a1271 1
int ssl3_send_alert(SSL *s, int level, int desc)
d1277 1
a1277 1
	if (desc < 0) return -1;
d1286 1
a1286 1
		return s->method->ssl_dispatch_alert(s);
a1288 1
	return -1;
@


1.1.1.10
log
@import OpenSSL 1.0.0e
@
text
@d249 1
a249 2
			if (s->mode & SSL_MODE_RELEASE_BUFFERS &&
			    SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)
d849 1
a849 2
			if (s->mode & SSL_MODE_RELEASE_BUFFERS &&
			    SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)
@


1.1.1.11
log
@import OpenSSL-1.0.1c
@
text
@a117 1
#include <openssl/rand.h>
a632 1
	int eivlen;
a664 4
		{
#if 1
		clear=s->enc_write_ctx?0:1;	/* must be AEAD cipher */
#else
d666 2
a667 1
#endif
a668 1
		}
d737 1
a737 8
	/* Some servers hang if iniatial client hello is larger than 256
	 * bytes and record version number > TLS 1.0
	 */
	if (s->state == SSL3_ST_CW_CLNT_HELLO_B
				&& TLS1_get_version(s) > TLS1_VERSION)
		*(p++) = 0x1;
	else
		*(p++)=s->version&0xff;
a741 18
	/* Explicit IV length, block ciphers and TLS version 1.1 or later */
	if (s->enc_write_ctx && s->version >= TLS1_1_VERSION)
		{
		int mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);
		if (mode == EVP_CIPH_CBC_MODE)
			{
			eivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);
			if (eivlen <= 1)
				eivlen = 0;
			}
		/* Need explicit part of IV for GCM mode */
		else if (mode == EVP_CIPH_GCM_MODE)
			eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN;
		else
			eivlen = 0;
		}
	else 
		eivlen = 0;
d744 1
a744 1
	wr->data=p + eivlen;
d772 1
a772 1
		if (s->method->ssl3_enc->mac(s,&(p[wr->length + eivlen]),1) < 0)
d775 2
a776 10
		}

	wr->input=p;
	wr->data=p;

	if (eivlen)
		{
	/*	if (RAND_pseudo_bytes(p, eivlen) <= 0)
			goto err; */
		wr->length += eivlen;
a1044 13
#ifndef OPENSSL_NO_HEARTBEATS
		else if (rr->type == TLS1_RT_HEARTBEAT)
			{
			tls1_process_heartbeat(s);

			/* Exit and notify application to read again */
			rr->length = 0;
			s->rwstate=SSL_READING;
			BIO_clear_retry_flags(SSL_get_rbio(s));
			BIO_set_retry_read(SSL_get_rbio(s));
			return(-1);
			}
#endif
a1187 4
#ifdef SSL_AD_MISSING_SRP_USERNAME
			if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)
				return(0);
#endif
a1265 1
			s->renegotiate=1;
d1299 2
a1300 4
		/* TLS up to v1.1 just ignores unknown message types:
		 * TLS v1.2 give an unexpected message alert.
		 */
		if (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION)
@


1.1.1.12
log
@Import OpenSSL 1.0.1g
@
text
@d293 2
a294 1
	unsigned mac_size, orig_len;
d296 2
d341 1
a341 1
                                if ((s->version & 0xFF00) == (version & 0xFF00) && !s->enc_write_ctx && !s->write_hash)
d406 1
a406 5
	/* enc_err is:
	 *    0: (in non-constant time) if the record is publically invalid.
	 *    1: if the padding is valid
	 *    -1: if the padding is invalid */
	if (enc_err == 0)
d408 9
a416 3
		al=SSL_AD_DECRYPTION_FAILED;
		SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
		goto f_err;
d426 8
a433 7
	if ((sess != NULL) &&
	    (s->enc_read_ctx != NULL) &&
	    (EVP_MD_CTX_md(s->read_hash) != NULL))
		{
		/* s->read_hash != NULL => mac_size != -1 */
		unsigned char *mac = NULL;
		unsigned char mac_tmp[EVP_MAX_MD_SIZE];
d435 1
a435 1
		OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);
d437 1
a437 12
		/* kludge: *_cbc_remove_padding passes padding length in rr->type */
		orig_len = rr->length+((unsigned int)rr->type>>8);

		/* orig_len is the length of the record before any padding was
		 * removed. This is public information, as is the MAC in use,
		 * therefore we can safely process the record in a different
		 * amount of time if it's too short to possibly contain a MAC.
		 */
		if (orig_len < mac_size ||
		    /* CBC records must have a padding length byte too. */
		    (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
		     orig_len < mac_size+1))
d439 3
a441 2
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);
d443 3
d447 2
a448 2

		if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE)
a449 7
			/* We update the length so that the TLS header bytes
			 * can be constructed correctly but we need to extract
			 * the MAC in constant time from within the record,
			 * without leaking the contents of the padding bytes.
			 * */
			mac = mac_tmp;
			ssl3_cbc_copy_mac(mac_tmp, rr, mac_size, orig_len);
d451 1
d455 14
a468 5
			/* In this case there's no padding, so |orig_len|
			 * equals |rec->length| and we checked that there's
			 * enough bytes for |mac_size| above. */
			rr->length -= mac_size;
			mac = &rr->data[rr->length];
a469 6

		i=s->method->ssl3_enc->mac(s,md,0 /* not send */);
		if (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
			enc_err = -1;
		if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra+mac_size)
			enc_err = -1;
d472 1
a472 1
	if (enc_err < 0)
a746 1
				&& !s->renegotiate
d1241 1
a1241 1
			else if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)
d1457 1
a1457 1
	i = s->method->ssl3_enc->final_finish_mac(s,
a1458 6
	if (i == 0)
		{
		SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);
		return 0;
		}
	s->s3->tmp.peer_finish_md_len = i;
@


