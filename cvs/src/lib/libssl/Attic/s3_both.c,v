head	1.58;
access;
symbols;
locks; strict;
comment	@ * @;


1.58
date	2017.01.26.05.51.54;	author jsing;	state dead;
branches;
next	1.57;
commitid	UfCZ8lEOJI6kLTjE;

1.57
date	2017.01.26.05.31.25;	author jsing;	state Exp;
branches;
next	1.56;
commitid	GRopTNgx07uByytM;

1.56
date	2017.01.23.14.35.42;	author jsing;	state Exp;
branches;
next	1.55;
commitid	fvePj4ki9zOwq3SB;

1.55
date	2017.01.23.13.36.13;	author jsing;	state Exp;
branches;
next	1.54;
commitid	xYJ523Ay020rUB5W;

1.54
date	2017.01.23.08.48.44;	author beck;	state Exp;
branches;
next	1.53;
commitid	vAKES6VByBpegTl4;

1.53
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.52;
commitid	grTXB43OAHDwwKOU;

1.52
date	2017.01.23.04.55.26;	author beck;	state Exp;
branches;
next	1.51;
commitid	AhwkqHI5lKK3NR31;

1.51
date	2017.01.22.09.02.07;	author jsing;	state Exp;
branches;
next	1.50;
commitid	570ElYZpaAvthwZh;

1.50
date	2016.12.30.15.12.45;	author jsing;	state Exp;
branches;
next	1.49;
commitid	zii5fVlB2KO93yI6;

1.49
date	2016.12.06.13.17.52;	author jsing;	state Exp;
branches;
next	1.48;
commitid	G67mpujAD0pCOeCU;

1.48
date	2015.09.12.15.03.39;	author jsing;	state Exp;
branches;
next	1.47;
commitid	86J9jDyJ44W6WCGe;

1.47
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.46;
commitid	pa8oXRlJthT375Ws;

1.46
date	2015.09.11.16.41.05;	author jsing;	state Exp;
branches;
next	1.45;
commitid	x8i6FbFeaQd2JN4X;

1.45
date	2015.09.11.16.27.40;	author jsing;	state Exp;
branches;
next	1.44;
commitid	HIuH8drWZdM9RI8P;

1.44
date	2015.09.11.15.59.21;	author jsing;	state Exp;
branches;
next	1.43;
commitid	Iv6JVh6ZjpUbHq3L;

1.43
date	2015.07.18.19.41.54;	author doug;	state Exp;
branches;
next	1.42;
commitid	iFy6hDttnmi2K987;

1.42
date	2015.07.15.21.52.02;	author beck;	state Exp;
branches;
next	1.41;
commitid	jJhmu7uxSvJIDi81;

1.41
date	2015.07.14.05.41.07;	author doug;	state Exp;
branches;
next	1.40;
commitid	TY2rOg7h4sdeJXIU;

1.40
date	2015.07.14.03.47.38;	author doug;	state Exp;
branches;
next	1.39;
commitid	arsnUJBYkToLDb1X;

1.39
date	2015.06.18.22.51.05;	author doug;	state Exp;
branches;
next	1.38;
commitid	AcOny6o1iDzXgvTz;

1.38
date	2015.03.27.12.29.54;	author jsing;	state Exp;
branches;
next	1.37;
commitid	GlMku1cNd3nfgnVW;

1.37
date	2014.12.14.21.49.29;	author bcook;	state Exp;
branches;
next	1.36;
commitid	4WNcCTaBHL0ZTDgF;

1.36
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.35;
commitid	XNZawfRSWvnVv1VS;

1.35
date	2014.12.14.14.34.43;	author jsing;	state Exp;
branches;
next	1.34;
commitid	JlmRntBjnvBE29Fz;

1.34
date	2014.12.10.15.43.31;	author jsing;	state Exp;
branches;
next	1.33;
commitid	9GGF3DCNTm9Bs8E3;

1.33
date	2014.12.10.15.36.46;	author jsing;	state Exp;
branches;
next	1.32;
commitid	x50cturILyXAfPoH;

1.32
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.31;
commitid	M3pvHgIFoWUHNqJn;

1.31
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.30;
commitid	cGE1JG2i0h4NcVDi;

1.30
date	2014.09.22.13.18.50;	author jsing;	state Exp;
branches;
next	1.29;
commitid	kaMCAYceEkYlsCfK;

1.29
date	2014.09.22.12.36.06;	author jsing;	state Exp;
branches;
next	1.28;
commitid	EZACi166p77C0zf1;

1.28
date	2014.08.07.20.02.23;	author miod;	state Exp;
branches;
next	1.27;
commitid	DMh9IXTC6aDWVuh5;

1.27
date	2014.08.07.19.46.31;	author miod;	state Exp;
branches;
next	1.26;
commitid	vayOLqnrIMw5dnz8;

1.26
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.25;
commitid	lsH7iukeZYSZBx6F;

1.25
date	2014.06.19.21.29.51;	author tedu;	state Exp;
branches;
next	1.24;
commitid	CIpPjhmVWPbqgxVA;

1.24
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	mJUVYpkFBZ0Zv2bG;

1.23
date	2014.05.31.19.09.20;	author miod;	state Exp;
branches;
next	1.22;
commitid	M7fNcFtAKgxRs3jT;

1.22
date	2014.05.31.10.53.39;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.05.30.14.01.11;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.28.13.03.24;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.20.14.03.04;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.16.21.16.33;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.14.16.07.22;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.13.23.05.18;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2014.02.27.21.04.57;	author jca;	state Exp;
branches;
next	1.12;

1.12
date	2013.02.14.15.11.43;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.03.39;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.37;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.28;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.27;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.33;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.04;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.36.38;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Rename s3_{both,clnt,pkt_srvr}.c to have an ssl_ prefix since they are no
longer SSLv3 code.

ok beck@@
@
text
@/* $OpenBSD: s3_both.c,v 1.57 2017/01/26 05:31:25 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */

#include <limits.h>
#include <stdio.h>
#include <string.h>

#include "ssl_locl.h"

#include <openssl/buffer.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#include <openssl/x509.h>

#include "bytestring.h"

/*
 * Send s->internal->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or
 * SSL3_RT_CHANGE_CIPHER_SPEC).
 */
int
ssl3_do_write(SSL *s, int type)
{
	int ret;

	ret = ssl3_write_bytes(s, type, &s->internal->init_buf->data[s->internal->init_off],
	    s->internal->init_num);
	if (ret < 0)
		return (-1);

	if (type == SSL3_RT_HANDSHAKE)
		/*
		 * Should not be done for 'Hello Request's, but in that case
		 * we'll ignore the result anyway.
		 */
		tls1_finish_mac(s,
		    (unsigned char *)&s->internal->init_buf->data[s->internal->init_off], ret);

	if (ret == s->internal->init_num) {
		if (s->internal->msg_callback)
			s->internal->msg_callback(1, s->version, type, s->internal->init_buf->data,
			    (size_t)(s->internal->init_off + s->internal->init_num), s,
			    s->internal->msg_callback_arg);
		return (1);
	}

	s->internal->init_off += ret;
	s->internal->init_num -= ret;

	return (0);
}

int
ssl3_send_finished(SSL *s, int a, int b, const char *sender, int slen)
{
	unsigned char *p;
	int md_len;

	if (s->internal->state == a) {
		md_len = s->method->internal->ssl3_enc->finish_mac_length;
		OPENSSL_assert(md_len <= EVP_MAX_MD_SIZE);

		if (s->method->internal->ssl3_enc->final_finish_mac(s, sender, slen,
		    S3I(s)->tmp.finish_md) != md_len)
			return (0);
		S3I(s)->tmp.finish_md_len = md_len;

		/* Copy finished so we can use it for renegotiation checks. */
		if (s->internal->type == SSL_ST_CONNECT) {
			memcpy(S3I(s)->previous_client_finished,
			    S3I(s)->tmp.finish_md, md_len);
			S3I(s)->previous_client_finished_len = md_len;
		} else {
			memcpy(S3I(s)->previous_server_finished,
			    S3I(s)->tmp.finish_md, md_len);
			S3I(s)->previous_server_finished_len = md_len;
		}

		p = ssl3_handshake_msg_start(s, SSL3_MT_FINISHED);
		memcpy(p, S3I(s)->tmp.finish_md, md_len);
		ssl3_handshake_msg_finish(s, md_len);

		s->internal->state = b;
	}

	return (ssl3_handshake_write(s));
}

/*
 * ssl3_take_mac calculates the Finished MAC for the handshakes messages seen
 * so far.
 */
static void
ssl3_take_mac(SSL *s)
{
	const char *sender;
	int slen;

	/*
	 * If no new cipher setup return immediately: other functions will
	 * set the appropriate error.
	 */
	if (S3I(s)->tmp.new_cipher == NULL)
		return;

	if (s->internal->state & SSL_ST_CONNECT) {
		sender = s->method->internal->ssl3_enc->server_finished_label;
		slen = s->method->internal->ssl3_enc->server_finished_label_len;
	} else {
		sender = s->method->internal->ssl3_enc->client_finished_label;
		slen = s->method->internal->ssl3_enc->client_finished_label_len;
	}

	S3I(s)->tmp.peer_finish_md_len =
	    s->method->internal->ssl3_enc->final_finish_mac(s, sender, slen,
		S3I(s)->tmp.peer_finish_md);
}

int
ssl3_get_finished(SSL *s, int a, int b)
{
	int al, ok, md_len;
	long n;
	CBS cbs;

	/* should actually be 36+4 :-) */
	n = s->method->internal->ssl_get_message(s, a, b, SSL3_MT_FINISHED, 64, &ok);
	if (!ok)
		return ((int)n);

	/* If this occurs, we have missed a message */
	if (!S3I(s)->change_cipher_spec) {
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_GOT_A_FIN_BEFORE_A_CCS);
		goto f_err;
	}
	S3I(s)->change_cipher_spec = 0;

	md_len = s->method->internal->ssl3_enc->finish_mac_length;

	if (n < 0) {
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_BAD_DIGEST_LENGTH);
		goto f_err;
	}

	CBS_init(&cbs, s->internal->init_msg, n);

	if (S3I(s)->tmp.peer_finish_md_len != md_len ||
	    CBS_len(&cbs) != md_len) {
		al = SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_BAD_DIGEST_LENGTH);
		goto f_err;
	}

	if (!CBS_mem_equal(&cbs, S3I(s)->tmp.peer_finish_md, CBS_len(&cbs))) {
		al = SSL_AD_DECRYPT_ERROR;
		SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_DIGEST_CHECK_FAILED);
		goto f_err;
	}

	/* Copy finished so we can use it for renegotiation checks. */
	OPENSSL_assert(md_len <= EVP_MAX_MD_SIZE);
	if (s->internal->type == SSL_ST_ACCEPT) {
		memcpy(S3I(s)->previous_client_finished,
		    S3I(s)->tmp.peer_finish_md, md_len);
		S3I(s)->previous_client_finished_len = md_len;
	} else {
		memcpy(S3I(s)->previous_server_finished,
		    S3I(s)->tmp.peer_finish_md, md_len);
		S3I(s)->previous_server_finished_len = md_len;
	}

	return (1);
f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
	return (0);
}

/* for these 2 messages, we need to
 * ssl->enc_read_ctx			re-init
 * ssl->s3->internal->read_sequence		zero
 * ssl->s3->internal->read_mac_secret		re-init
 * ssl->session->read_sym_enc		assign
 * ssl->session->read_hash		assign
 */
int
ssl3_send_change_cipher_spec(SSL *s, int a, int b)
{
	unsigned char *p;

	if (s->internal->state == a) {
		p = (unsigned char *)s->internal->init_buf->data;
		*p = SSL3_MT_CCS;
		s->internal->init_num = 1;
		s->internal->init_off = 0;

		s->internal->state = b;
	}

	/* SSL3_ST_CW_CHANGE_B */
	return (ssl3_do_write(s, SSL3_RT_CHANGE_CIPHER_SPEC));
}

static int
ssl3_add_cert(CBB *cbb, X509 *x)
{
	unsigned char *data;
	int cert_len;
	int ret = 0;
	CBB cert;

	if ((cert_len = i2d_X509(x, NULL)) < 0)
		goto err;

	if (!CBB_add_u24_length_prefixed(cbb, &cert))
		goto err;
	if (!CBB_add_space(&cert, &data, cert_len))
		goto err;
	if (i2d_X509(x, &data) < 0)
		goto err;
	if (!CBB_flush(cbb))
		goto err;

	ret = 1;

 err:
	return (ret);
}

int
ssl3_output_cert_chain(SSL *s, CBB *cbb, X509 *x)
{
	int no_chain = 0;
	CBB cert_list;
	int ret = 0;
	int i;

	if (!CBB_add_u24_length_prefixed(cbb, &cert_list))
		goto err;

	if ((s->internal->mode & SSL_MODE_NO_AUTO_CHAIN) || s->ctx->extra_certs)
		no_chain = 1;

	/* TLSv1 sends a chain with nothing in it, instead of an alert. */
	if (x != NULL) {
		if (no_chain) {
			if (!ssl3_add_cert(&cert_list, x))
				goto err;
		} else {
			X509_STORE_CTX xs_ctx;

			if (!X509_STORE_CTX_init(&xs_ctx, s->ctx->cert_store,
			    x, NULL)) {
				SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,
				    ERR_R_X509_LIB);
				goto err;
			}
			X509_verify_cert(&xs_ctx);

			/* Don't leave errors in the queue. */
			ERR_clear_error();
			for (i = 0; i < sk_X509_num(xs_ctx.chain); i++) {
				x = sk_X509_value(xs_ctx.chain, i);
				if (!ssl3_add_cert(&cert_list, x)) {
					X509_STORE_CTX_cleanup(&xs_ctx);
					goto err;
				}
			}
			X509_STORE_CTX_cleanup(&xs_ctx);
		}
	}

	/* Thawte special :-) */
	for (i = 0; i < sk_X509_num(s->ctx->extra_certs); i++) {
		x = sk_X509_value(s->ctx->extra_certs, i);
		if (!ssl3_add_cert(&cert_list, x))
			goto err;
	}

	if (!CBB_flush(cbb))
		goto err;

	ret = 1;

 err:
	return (ret);
}

/*
 * Obtain handshake message of message type 'mt' (any if mt == -1),
 * maximum acceptable body length 'max'.
 * The first four bytes (msg_type and length) are read in state 'st1',
 * the body is read in state 'stn'.
 */
long
ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)
{
	unsigned char *p;
	uint32_t l;
	long n;
	int i, al;
	CBS cbs;
	uint8_t u8;

	if (S3I(s)->tmp.reuse_message) {
		S3I(s)->tmp.reuse_message = 0;
		if ((mt >= 0) && (S3I(s)->tmp.message_type != mt)) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_MESSAGE,
			    SSL_R_UNEXPECTED_MESSAGE);
			goto f_err;
		}
		*ok = 1;
		s->internal->init_msg = s->internal->init_buf->data + 4;
		s->internal->init_num = (int)S3I(s)->tmp.message_size;
		return s->internal->init_num;
	}

	p = (unsigned char *)s->internal->init_buf->data;

	/* s->internal->init_num < 4 */
	if (s->internal->state == st1) {
		int skip_message;

		do {
			while (s->internal->init_num < 4) {
				i = s->method->internal->ssl_read_bytes(s,
				    SSL3_RT_HANDSHAKE, &p[s->internal->init_num],
				    4 - s->internal->init_num, 0);
				if (i <= 0) {
					s->internal->rwstate = SSL_READING;
					*ok = 0;
					return i;
				}
				s->internal->init_num += i;
			}

			skip_message = 0;
			if (!s->server && p[0] == SSL3_MT_HELLO_REQUEST) {
				/*
				 * The server may always send 'Hello Request'
				 * messages -- we are doing a handshake anyway
				 * now, so ignore them if their format is
				 * correct.  Does not count for 'Finished' MAC.
				 */
				if (p[1] == 0 && p[2] == 0 &&p[3] == 0) {
					s->internal->init_num = 0;
					skip_message = 1;

					if (s->internal->msg_callback)
						s->internal->msg_callback(0, s->version,
						    SSL3_RT_HANDSHAKE, p, 4, s,
						    s->internal->msg_callback_arg);
				}
			}
		} while (skip_message);

		/* s->internal->init_num == 4 */

		if ((mt >= 0) && (*p != mt)) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_MESSAGE,
			    SSL_R_UNEXPECTED_MESSAGE);
			goto f_err;
		}

		CBS_init(&cbs, p, 4);
		if (!CBS_get_u8(&cbs, &u8) ||
		    !CBS_get_u24(&cbs, &l)) {
			SSLerr(SSL_F_SSL3_GET_MESSAGE, ERR_R_BUF_LIB);
			goto err;
		}
		S3I(s)->tmp.message_type = u8;

		if (l > (unsigned long)max) {
			al = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_MESSAGE,
			    SSL_R_EXCESSIVE_MESSAGE_SIZE);
			goto f_err;
		}
		if (l && !BUF_MEM_grow_clean(s->internal->init_buf, l + 4)) {
			SSLerr(SSL_F_SSL3_GET_MESSAGE, ERR_R_BUF_LIB);
			goto err;
		}
		S3I(s)->tmp.message_size = l;
		s->internal->state = stn;

		s->internal->init_msg = s->internal->init_buf->data + 4;
		s->internal->init_num = 0;
	}

	/* next state (stn) */
	p = s->internal->init_msg;
	n = S3I(s)->tmp.message_size - s->internal->init_num;
	while (n > 0) {
		i = s->method->internal->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
		    &p[s->internal->init_num], n, 0);
		if (i <= 0) {
			s->internal->rwstate = SSL_READING;
			*ok = 0;
			return i;
		}
		s->internal->init_num += i;
		n -= i;
	}

	/* If receiving Finished, record MAC of prior handshake messages for
	 * Finished verification. */
	if (*s->internal->init_buf->data == SSL3_MT_FINISHED)
		ssl3_take_mac(s);

	/* Feed this message into MAC computation. */
	if (s->internal->mac_packet) {
		tls1_finish_mac(s, (unsigned char *)s->internal->init_buf->data,
		    s->internal->init_num + 4);
		s->internal->mac_packet = 0;

		if (s->internal->msg_callback)
			s->internal->msg_callback(0, s->version,
			    SSL3_RT_HANDSHAKE, s->internal->init_buf->data,
			    (size_t)s->internal->init_num + 4, s,
			    s->internal->msg_callback_arg);
	}

	*ok = 1;
	return (s->internal->init_num);

f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	*ok = 0;
	return (-1);
}

int
ssl_cert_type(X509 *x, EVP_PKEY *pkey)
{
	EVP_PKEY *pk;
	int ret = -1, i;

	if (pkey == NULL)
		pk = X509_get_pubkey(x);
	else
		pk = pkey;
	if (pk == NULL)
		goto err;

	i = pk->type;
	if (i == EVP_PKEY_RSA) {
		ret = SSL_PKEY_RSA_ENC;
	} else if (i == EVP_PKEY_DSA) {
		ret = SSL_PKEY_DSA_SIGN;
	} else if (i == EVP_PKEY_EC) {
		ret = SSL_PKEY_ECC;
	} else if (i == NID_id_GostR3410_2001 ||
	    i == NID_id_GostR3410_2001_cc) {
		ret = SSL_PKEY_GOST01;
	}

err:
	if (!pkey)
		EVP_PKEY_free(pk);
	return (ret);
}

int
ssl_verify_alarm_type(long type)
{
	int al;

	switch (type) {
	case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
	case X509_V_ERR_UNABLE_TO_GET_CRL:
	case X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER:
		al = SSL_AD_UNKNOWN_CA;
		break;
	case X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:
	case X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:
	case X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:
	case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:
	case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:
	case X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:
	case X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:
	case X509_V_ERR_CERT_NOT_YET_VALID:
	case X509_V_ERR_CRL_NOT_YET_VALID:
	case X509_V_ERR_CERT_UNTRUSTED:
	case X509_V_ERR_CERT_REJECTED:
		al = SSL_AD_BAD_CERTIFICATE;
		break;
	case X509_V_ERR_CERT_SIGNATURE_FAILURE:
	case X509_V_ERR_CRL_SIGNATURE_FAILURE:
		al = SSL_AD_DECRYPT_ERROR;
		break;
	case X509_V_ERR_CERT_HAS_EXPIRED:
	case X509_V_ERR_CRL_HAS_EXPIRED:
		al = SSL_AD_CERTIFICATE_EXPIRED;
		break;
	case X509_V_ERR_CERT_REVOKED:
		al = SSL_AD_CERTIFICATE_REVOKED;
		break;
	case X509_V_ERR_OUT_OF_MEM:
		al = SSL_AD_INTERNAL_ERROR;
		break;
	case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
	case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:
	case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
	case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
	case X509_V_ERR_CERT_CHAIN_TOO_LONG:
	case X509_V_ERR_PATH_LENGTH_EXCEEDED:
	case X509_V_ERR_INVALID_CA:
		al = SSL_AD_UNKNOWN_CA;
		break;
	case X509_V_ERR_APPLICATION_VERIFICATION:
		al = SSL_AD_HANDSHAKE_FAILURE;
		break;
	case X509_V_ERR_INVALID_PURPOSE:
		al = SSL_AD_UNSUPPORTED_CERTIFICATE;
		break;
	default:
		al = SSL_AD_CERTIFICATE_UNKNOWN;
		break;
	}
	return (al);
}

int
ssl3_setup_init_buffer(SSL *s)
{
	BUF_MEM *buf = NULL;

	if (s->internal->init_buf != NULL)
		return (1);

	if ((buf = BUF_MEM_new()) == NULL)
		goto err;
	if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH))
		goto err;

	s->internal->init_buf = buf;
	return (1);

err:
	BUF_MEM_free(buf);
	return (0);
}

int
ssl3_setup_read_buffer(SSL *s)
{
	unsigned char *p;
	size_t len, align, headerlen;

	if (SSL_IS_DTLS(s))
		headerlen = DTLS1_RT_HEADER_LENGTH;
	else
		headerlen = SSL3_RT_HEADER_LENGTH;

	align = (-SSL3_RT_HEADER_LENGTH) & (SSL3_ALIGN_PAYLOAD - 1);

	if (s->s3->rbuf.buf == NULL) {
		len = SSL3_RT_MAX_PLAIN_LENGTH +
		    SSL3_RT_MAX_ENCRYPTED_OVERHEAD + headerlen + align;
		if ((p = malloc(len)) == NULL)
			goto err;
		s->s3->rbuf.buf = p;
		s->s3->rbuf.len = len;
	}

	s->internal->packet = &(s->s3->rbuf.buf[0]);
	return 1;

err:
	SSLerr(SSL_F_SSL3_SETUP_READ_BUFFER, ERR_R_MALLOC_FAILURE);
	return 0;
}

int
ssl3_setup_write_buffer(SSL *s)
{
	unsigned char *p;
	size_t len, align, headerlen;

	if (SSL_IS_DTLS(s))
		headerlen = DTLS1_RT_HEADER_LENGTH + 1;
	else
		headerlen = SSL3_RT_HEADER_LENGTH;

	align = (-SSL3_RT_HEADER_LENGTH) & (SSL3_ALIGN_PAYLOAD - 1);

	if (s->s3->wbuf.buf == NULL) {
		len = s->max_send_fragment +
		    SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD + headerlen + align;
		if (!(s->internal->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
			len += headerlen + align +
			    SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD;

		if ((p = malloc(len)) == NULL)
			goto err;
		s->s3->wbuf.buf = p;
		s->s3->wbuf.len = len;
	}

	return 1;

err:
	SSLerr(SSL_F_SSL3_SETUP_WRITE_BUFFER, ERR_R_MALLOC_FAILURE);
	return 0;
}

int
ssl3_setup_buffers(SSL *s)
{
	if (!ssl3_setup_read_buffer(s))
		return 0;
	if (!ssl3_setup_write_buffer(s))
		return 0;
	return 1;
}

int
ssl3_release_write_buffer(SSL *s)
{
	free(s->s3->wbuf.buf);
	s->s3->wbuf.buf = NULL;
	return 1;
}

int
ssl3_release_read_buffer(SSL *s)
{
	free(s->s3->rbuf.buf);
	s->s3->rbuf.buf = NULL;
	return 1;
}
@


1.57
log
@Merge the client/server version negotiation into the existing (currently
fixed version) client/server code.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.56 2017/01/23 14:35:42 jsing Exp $ */
@


1.56
log
@Move options and mode from SSL_CTX and SSL to internal, since these can be
set and cleared via existing functions.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.55 2017/01/23 13:36:13 jsing Exp $ */
d527 11
a537 5
	tls1_finish_mac(s, (unsigned char *)s->internal->init_buf->data, s->internal->init_num + 4);
	if (s->internal->msg_callback)
		s->internal->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
		    s->internal->init_buf->data, (size_t)s->internal->init_num + 4, s,
		    s->internal->msg_callback_arg);
@


1.55
log
@Split most of SSL_METHOD out into an internal variant, which is opaque.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.54 2017/01/23 08:48:44 beck Exp $ */
d355 1
a355 1
	if ((s->mode & SSL_MODE_NO_AUTO_CHAIN) || s->ctx->extra_certs)
d701 1
a701 1
		if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
@


1.54
log
@send state and rstate from ssl_st into internal. There are accessors
so these should not be diddled with directly
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.53 2017/01/23 06:45:30 beck Exp $ */
d173 1
a173 1
		md_len = s->method->ssl3_enc->finish_mac_length;
d176 1
a176 1
		if (s->method->ssl3_enc->final_finish_mac(s, sender, slen,
d220 2
a221 2
		sender = s->method->ssl3_enc->server_finished_label;
		slen = s->method->ssl3_enc->server_finished_label_len;
d223 2
a224 2
		sender = s->method->ssl3_enc->client_finished_label;
		slen = s->method->ssl3_enc->client_finished_label_len;
d228 1
a228 1
	    s->method->ssl3_enc->final_finish_mac(s, sender, slen,
d240 1
a240 1
	n = s->method->ssl_get_message(s, a, b, SSL3_MT_FINISHED, 64, &ok);
d252 1
a252 1
	md_len = s->method->ssl3_enc->finish_mac_length;
d441 1
a441 1
				i = s->method->ssl_read_bytes(s,
d510 1
a510 1
		i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
@


1.53
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.52 2017/01/23 04:55:26 beck Exp $ */
d172 1
a172 1
	if (s->state == a) {
d196 1
a196 1
		s->state = b;
d219 1
a219 1
	if (s->state & SSL_ST_CONNECT) {
d305 1
a305 1
	if (s->state == a) {
d311 1
a311 1
		s->state = b;
d436 1
a436 1
	if (s->state == st1) {
d500 1
a500 1
		s->state = stn;
@


1.52
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.51 2017/01/22 09:02:07 jsing Exp $ */
d131 1
a131 1
 * Send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or
d139 2
a140 2
	ret = ssl3_write_bytes(s, type, &s->init_buf->data[s->init_off],
	    s->init_num);
d150 1
a150 1
		    (unsigned char *)&s->init_buf->data[s->init_off], ret);
d152 1
a152 1
	if (ret == s->init_num) {
d154 2
a155 2
			s->internal->msg_callback(1, s->version, type, s->init_buf->data,
			    (size_t)(s->init_off + s->init_num), s,
d160 2
a161 2
	s->init_off += ret;
	s->init_num -= ret;
d182 1
a182 1
		if (s->type == SSL_ST_CONNECT) {
d260 1
a260 1
	CBS_init(&cbs, s->init_msg, n);
d277 1
a277 1
	if (s->type == SSL_ST_ACCEPT) {
d306 1
a306 1
		p = (unsigned char *)s->init_buf->data;
d308 2
a309 2
		s->init_num = 1;
		s->init_off = 0;
d428 3
a430 3
		s->init_msg = s->init_buf->data + 4;
		s->init_num = (int)S3I(s)->tmp.message_size;
		return s->init_num;
d433 1
a433 1
	p = (unsigned char *)s->init_buf->data;
d435 1
a435 1
	/* s->init_num < 4 */
d440 1
a440 1
			while (s->init_num < 4) {
d442 2
a443 2
				    SSL3_RT_HANDSHAKE, &p[s->init_num],
				    4 - s->init_num, 0);
d445 1
a445 1
					s->rwstate = SSL_READING;
d449 1
a449 1
				s->init_num += i;
d461 1
a461 1
					s->init_num = 0;
d472 1
a472 1
		/* s->init_num == 4 */
d495 1
a495 1
		if (l && !BUF_MEM_grow_clean(s->init_buf, l + 4)) {
d502 2
a503 2
		s->init_msg = s->init_buf->data + 4;
		s->init_num = 0;
d507 2
a508 2
	p = s->init_msg;
	n = S3I(s)->tmp.message_size - s->init_num;
d511 1
a511 1
		    &p[s->init_num], n, 0);
d513 1
a513 1
			s->rwstate = SSL_READING;
d517 1
a517 1
		s->init_num += i;
d523 1
a523 1
	if (*s->init_buf->data == SSL3_MT_FINISHED)
d527 1
a527 1
	tls1_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num + 4);
d530 1
a530 1
		    s->init_buf->data, (size_t)s->init_num + 4, s,
d534 1
a534 1
	return (s->init_num);
d639 1
a639 1
	if (s->init_buf != NULL)
d647 1
a647 1
	s->init_buf = buf;
d677 1
a677 1
	s->packet = &(s->s3->rbuf.buf[0]);
@


1.51
log
@Move most of the SSL3_STATE fields to internal - the ones that remain are
known to be used by ports.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.50 2016/12/30 15:12:45 jsing Exp $ */
d153 2
a154 2
		if (s->msg_callback)
			s->msg_callback(1, s->version, type, s->init_buf->data,
d156 1
a156 1
			    s->msg_callback_arg);
d464 2
a465 2
					if (s->msg_callback)
						s->msg_callback(0, s->version,
d467 1
a467 1
						    s->msg_callback_arg);
d528 2
a529 2
	if (s->msg_callback)
		s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
d531 1
a531 1
		    s->msg_callback_arg);
@


1.50
log
@Remove now unused c2l, c2ln, l2c, n2l, l2cn and n2l3 macros.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.49 2016/12/06 13:17:52 jsing Exp $ */
d177 1
a177 1
		    s->s3->tmp.finish_md) != md_len)
d179 1
a179 1
		s->s3->tmp.finish_md_len = md_len;
d183 3
a185 3
			memcpy(s->s3->previous_client_finished,
			    s->s3->tmp.finish_md, md_len);
			s->s3->previous_client_finished_len = md_len;
d187 3
a189 3
			memcpy(s->s3->previous_server_finished,
			    s->s3->tmp.finish_md, md_len);
			s->s3->previous_server_finished_len = md_len;
d193 1
a193 1
		memcpy(p, s->s3->tmp.finish_md, md_len);
d216 1
a216 1
	if (s->s3->tmp.new_cipher == NULL)
d227 1
a227 1
	s->s3->tmp.peer_finish_md_len =
d229 1
a229 1
		s->s3->tmp.peer_finish_md);
d245 1
a245 1
	if (!s->s3->change_cipher_spec) {
d250 1
a250 1
	s->s3->change_cipher_spec = 0;
d262 1
a262 1
	if (s->s3->tmp.peer_finish_md_len != md_len ||
d269 1
a269 1
	if (!CBS_mem_equal(&cbs, s->s3->tmp.peer_finish_md, CBS_len(&cbs))) {
d278 3
a280 3
		memcpy(s->s3->previous_client_finished,
		    s->s3->tmp.peer_finish_md, md_len);
		s->s3->previous_client_finished_len = md_len;
d282 3
a284 3
		memcpy(s->s3->previous_server_finished,
		    s->s3->tmp.peer_finish_md, md_len);
		s->s3->previous_server_finished_len = md_len;
d295 2
a296 2
 * ssl->s3->read_sequence		zero
 * ssl->s3->read_mac_secret		re-init
d419 3
a421 3
	if (s->s3->tmp.reuse_message) {
		s->s3->tmp.reuse_message = 0;
		if ((mt >= 0) && (s->s3->tmp.message_type != mt)) {
d429 1
a429 1
		s->init_num = (int)s->s3->tmp.message_size;
d487 1
a487 1
		s->s3->tmp.message_type = u8;
d499 1
a499 1
		s->s3->tmp.message_size = l;
d508 1
a508 1
	n = s->s3->tmp.message_size - s->init_num;
@


1.49
log
@Convert certificate handshake message generation to CBB, with some clean
up and restructure.

This also adds CBB based variants of the ssl3_handshake_msg_{start,finish}
functions - for the time being these use a CBB to build the messages, then
copy back into the init_buf.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.48 2015/09/12 15:03:39 jsing Exp $ */
a480 1
		/* XXX remove call to n2l3 */
@


1.48
log
@Move handshake message header length determination into a separate
ssl3_handshake_msg_hdr_len() function. Use this to correct several places
that have magic numbers with header lengths hardcoded as '4'.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.47 2015/09/11 18:08:21 jsing Exp $ */
d319 1
a319 1
ssl3_add_cert_to_buf(BUF_MEM *buf, unsigned long *l, X509 *x)
d321 16
a336 2
	int n;
	unsigned char *p;
d338 1
a338 10
	n = i2d_X509(x, NULL);
	if (!BUF_MEM_grow_clean(buf, n + (*l) + 3)) {
		SSLerr(SSL_F_SSL3_ADD_CERT_TO_BUF, ERR_R_BUF_LIB);
		return (-1);
	}
	/* XXX */
	p = (unsigned char *)&(buf->data[*l]);
	l2n3(n, p);
	i2d_X509(x, &p);
	*l += n + 3;
d340 2
a341 1
	return (0);
d344 2
a345 2
unsigned long
ssl3_output_cert_chain(SSL *s, X509 *x)
d347 3
a349 4
	unsigned char *p;
	unsigned long l = ssl3_handshake_msg_hdr_len(s) + 3;
	BUF_MEM *buf;
	int no_chain;
d352 3
a356 2
	else
		no_chain = 0;
d358 1
a358 6
	/* TLSv1 sends a chain with nothing in it, instead of an alert */
	buf = s->init_buf;
	if (!BUF_MEM_grow_clean(buf, ssl3_handshake_msg_hdr_len(s) + 6)) {
		SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN, ERR_R_BUF_LIB);
		return (0);
	}
d361 2
a362 2
			if (ssl3_add_cert_to_buf(buf, &l, x))
				return (0);
d370 1
a370 1
				return (0);
d378 1
a378 1
				if (ssl3_add_cert_to_buf(buf, &l, x)) {
d380 1
a380 1
					return 0;
d386 1
d390 2
a391 2
		if (ssl3_add_cert_to_buf(buf, &l, x))
			return (0);
d394 7
a400 9
	l -= ssl3_handshake_msg_hdr_len(s) + 3;
	p = (unsigned char *)&(buf->data[4]);
	l2n3(l, p);
	l += 3;
	p = (unsigned char *)&(buf->data[0]);
	*(p++) = SSL3_MT_CERTIFICATE;
	l2n3(l, p);
	l += 4; /* XXX */
	return (l);
@


1.47
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.46 2015/09/11 16:41:05 jsing Exp $ */
d329 1
d342 1
a342 2
	int i;
	unsigned long l = 7;
d345 1
d354 1
a354 1
	if (!BUF_MEM_grow_clean(buf, 10)) {
d392 1
a392 1
	l -= 7;
d399 1
a399 1
	l += 4;
@


1.46
log
@Shuffle the code in ssl3_send_finished() to make it more logical/readable.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.45 2015/09/11 16:27:40 jsing Exp $ */
d149 1
a149 1
		ssl3_finish_mac(s,
d527 1
a527 1
	ssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num + 4);
@


1.45
log
@style(9), fix comments, wrap long lines and tweak whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.44 2015/09/11 15:59:21 jsing Exp $ */
d143 1
a169 1
	unsigned long l;
d173 2
a174 1
		p = ssl3_handshake_msg_start(s, SSL3_MT_FINISHED);
a175 1
		md_len = s->method->ssl3_enc->finish_mac_length;
a179 3
		memcpy(p, s->s3->tmp.finish_md, md_len);
		p += md_len;
		l = md_len;
a181 1
		OPENSSL_assert(md_len <= EVP_MAX_MD_SIZE);
d192 3
a194 1
		ssl3_handshake_msg_finish(s, l);
@


1.44
log
@Convert dtls1_send_finished() and ssl3_send_finished() to
ssl3_handshake_msg_start()/ssl3_handshake_msg_finish().

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.43 2015/07/18 19:41:54 doug Exp $ */
d130 4
a133 1
/* send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or SSL3_RT_CHANGE_CIPHER_SPEC) */
d140 1
a140 1
	s->init_num);
d144 6
a149 3
		/* should not be done for 'Hello Request's, but in that case
		 * we'll ignore the result anyway */
		ssl3_finish_mac(s,(unsigned char *)&s->init_buf->data[s->init_off], ret);
d153 3
a155 1
			s->msg_callback(1, s->version, type, s->init_buf->data, (size_t)(s->init_off + s->init_num), s, s->msg_callback_arg);
d158 1
d161 1
d204 4
a207 1
/* ssl3_take_mac calculates the Finished MAC for the handshakes messages seen to far. */
d213 3
a215 1
	/* If no new cipher setup return immediately: other functions will
d220 1
d229 3
a231 2
	s->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,
	sender, slen, s->s3->tmp.peer_finish_md);
d241 2
a242 3
	n = s->method->ssl_get_message(s, a, b, SSL3_MT_FINISHED,
	    64, /* should actually be 36+4 :-) */ &ok);

d366 4
a369 2
			if (!X509_STORE_CTX_init(&xs_ctx, s->ctx->cert_store, x, NULL)) {
				SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN, ERR_R_X509_LIB);
d373 2
a374 1
			/* Don't leave errors in the queue */
a377 1

d404 2
a405 1
/* Obtain handshake message of message type 'mt' (any if mt == -1),
d424 2
a425 1
			SSLerr(SSL_F_SSL3_GET_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);
d436 2
a437 2
	if (s->state == st1) /* s->init_num < 4 */
	{
d466 3
a468 1
						s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, 4, s, s->msg_callback_arg);
a470 1

d477 2
a478 1
			SSLerr(SSL_F_SSL3_GET_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);
d493 2
a494 1
			SSLerr(SSL_F_SSL3_GET_MESSAGE, SSL_R_EXCESSIVE_MESSAGE_SIZE);
d531 4
a534 1
		s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->init_buf->data, (size_t)s->init_num + 4, s, s->msg_callback_arg);
d536 2
a537 1
	return s->init_num;
d563 1
a563 2
	}
	else if (i == EVP_PKEY_EC) {
d565 2
a566 1
	} else if (i == NID_id_GostR3410_2001 || i == NID_id_GostR3410_2001_cc) {
d569 1
@


1.43
log
@Remove SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER workaround.

This was a hack to work around problems on IE 6 with SSLv3.

ok miod@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.42 2015/07/15 21:52:02 beck Exp $ */
d158 1
a158 1
	unsigned char *p, *d;
d163 1
a163 2
		d = (unsigned char *)s->init_buf->data;
		p = &(d[4]);
d186 1
a186 4
		*(d++) = SSL3_MT_FINISHED;
		l2n3(l, d);
		s->init_num = (int)l + 4;
		s->init_off = 0;
d191 1
a191 2
	/* SSL3_ST_SEND_xxxxxx_HELLO_B */
	return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
@


1.42
log
@test for n<0 before use in CBS_init - mostly to shut up coverity.
reluctant ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.41 2015/07/14 05:41:07 doug Exp $ */
a649 4
		if (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER) {
			s->s3->init_extra = 1;
			len += SSL3_RT_MAX_EXTRA;
		}
@


1.41
log
@Partially convert ssl3_get_message to CBS.

Unlike the other conversions, this only partially converts the function
for now.  This is the second to last function which still uses the n2l3
macro.  That macro is deprecated since we're using CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.40 2015/07/14 03:47:38 doug Exp $ */
d245 6
d253 1
a253 1
	if (n < 0 || s->s3->tmp.peer_finish_md_len != md_len ||
@


1.40
log
@Convert ssl3_get_finished to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.39 2015/06/18 22:51:05 doug Exp $ */
d394 1
a394 1
	unsigned long l;
d397 2
d448 2
a449 2
		}
		while (skip_message);
a457 1
		s->s3->tmp.message_type= *(p++);
d459 9
a467 1
		n2l3(p, l);
@


1.39
log
@Remove Microsoft Server Gated Crypto.

Another relic due to the old US crypto policy.

From OpenSSL commit 63eab8a620944a990ab3985620966ccd9f48d681 and
95275599399e277e71d064790a1f828a99fc661a.

ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.38 2015/03/27 12:29:54 jsing Exp $ */
d128 2
d227 1
a227 2
	unsigned char *p;

a243 1
	p = (unsigned char *)s->init_msg;
d245 4
a248 1
	if (s->s3->tmp.peer_finish_md_len != md_len || n != md_len) {
d254 1
a254 1
	if (timingsafe_memcmp(p, s->s3->tmp.peer_finish_md, md_len) != 0) {
@


1.38
log
@Factor out the init_buf initialisation code, rather than duplicating it
in four different places.

ok doug@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.37 2014/12/14 21:49:29 bcook Exp $ */
a452 14
		if ((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) &&
		    (st1 == SSL3_ST_SR_CERT_A) && (stn == SSL3_ST_SR_CERT_B)) {
			/* At this point we have got an MS SGC second client
			 * hello (maybe we should always allow the client to
			 * start a new handshake?). We need to restart the mac.
			 * Don't increment {num,total}_renegotiations because
			 * we have not completed the handshake. */
			if (!ssl3_init_finished_mac(s)) {
				SSLerr(SSL_F_SSL3_GET_MESSAGE,
				    ERR_R_MALLOC_FAILURE);
				goto err;
			}
		}

@


1.37
log
@unconditionally align SSL payloads

Remove support for conditional payload alignment, since we would never
want to turn it off. Also, consistently use size_t for calculating the
alignment.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.36 2014/12/14 15:30:50 jsing Exp $ */
d610 21
a696 1

a721 1

@


1.36
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.35 2014/12/14 14:34:43 jsing Exp $ */
d613 1
a613 1
	size_t len, align = 0, headerlen;
d620 1
a620 3
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
	align = (-SSL3_RT_HEADER_LENGTH)&(SSL3_ALIGN_PAYLOAD - 1);
#endif
d647 1
a647 1
	size_t len, align = 0, headerlen;
d654 1
a654 3
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
	align = (-SSL3_RT_HEADER_LENGTH)&(SSL3_ALIGN_PAYLOAD - 1);
#endif
@


1.35
log
@unifdef OPENSSL_NO_NEXTPROTONEG, which is one of the last standing #ifndef
mazes in libssl. NPN is being replaced by ALPN, however it is still going
to be around for a while yet.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.34 2014/12/10 15:43:31 jsing Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d113 1
a113 1
 * ECC cipher suite support in OpenSSL originally developed by 
@


1.34
log
@ssl3_init_finished_mac() calls BIO_new() which can fail since it in turn
calls malloc(). Instead of silently continuing on failure, check the return
value of BIO_new() and propagate failure back to the caller for appropriate
handling.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.33 2014/12/10 15:36:46 jsing Exp $ */
a196 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a218 1
#endif
a226 5
#ifdef OPENSSL_NO_NEXTPROTONEG
	/* the mac has already been generated when we received the
	 * change cipher spec message and is in s->s3->tmp.peer_finish_md.
	 */ 
#endif
a500 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a504 1
#endif
@


1.33
log
@Remove support for GOST R 34.10-94 signature authentication, along with
the two ciphersuites that use it. GOST94 public/private keys have been
long obsoleted and libcrypto does not have support for them anyway.

Discussed with Dmitry Eremin-Solenikov.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.32 2014/11/16 14:12:47 jsing Exp $ */
d467 5
a471 1
			ssl3_init_finished_mac(s);
@


1.32
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.31 2014/10/18 16:13:16 jsing Exp $ */
a544 3
	}
	else if (i == NID_id_GostR3410_94 || i == NID_id_GostR3410_94_cc) {
		ret = SSL_PKEY_GOST94;
@


1.31
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.30 2014/09/22 13:18:50 jsing Exp $ */
d118 1
d120 1
a120 1
#include <stdio.h>
d122 1
d124 1
a125 1
#include <openssl/evp.h>
@


1.30
log
@Also check the result from final_finish_mac() against finish_mac_length in
ssl3_send_finished(). While this previously checked against a zero return
value (which could occur on failure), we may as well test against the
expected length, since we already know what that is.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.29 2014/09/22 12:36:06 jsing Exp $ */
a121 1
#include <openssl/rand.h>
@


1.29
log
@It is possible (although unlikely in practice) for peer_finish_md_len to
end up with a value of zero, primarily since ssl3_take_mac() fails to check
the return value from the final_finish_mac() call. This would then mean that
an SSL finished message with a zero-byte payload would successfully match
against the calculated finish MAC.

Avoid this by checking the length of peer_finish_md_len and the SSL
finished message payload, against the known length already stored in
the SSL3_ENC_METHOD finish_mac_length field (making use of a previously
unused field).

ok miod@@ (a little while back)
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.28 2014/08/07 20:02:23 miod Exp $ */
a155 1
	int i;
d157 1
d163 8
a170 8
		i = s->method->ssl3_enc->final_finish_mac(s,
		sender, slen, s->s3->tmp.finish_md);
		if (i == 0)
			return 0;
		s->s3->tmp.finish_md_len = i;
		memcpy(p, s->s3->tmp.finish_md, i);
		p += i;
		l = i;
d172 2
a173 2
                /* Copy the finished so we can use it for
                   renegotiation checks */
a174 1
			OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
d176 2
a177 2
			s->s3->tmp.finish_md, i);
			s->s3->previous_client_finished_len = i;
a178 1
			OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
d180 2
a181 2
			s->s3->tmp.finish_md, i);
			s->s3->previous_server_finished_len = i;
@


1.28
log
@Oops, revert changes commited by mistake. The previous commit was supposed
to only apply to s23_srvr.c.
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.26 2014/07/10 08:51:14 tedu Exp $ */
d226 1
a226 1
	int al, i, ok;
d250 1
a251 1
	i = s->s3->tmp.peer_finish_md_len;
d253 1
a253 1
	if (i != n) {
d259 1
a259 1
	if (timingsafe_memcmp(p, s->s3->tmp.peer_finish_md, i) != 0) {
d265 2
a266 2
        /* Copy the finished so we can use it for
           renegotiation checks */
a267 1
		OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
d269 2
a270 2
		s->s3->tmp.peer_finish_md, i);
		s->s3->previous_client_finished_len = i;
a271 1
		OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
d273 2
a274 2
		s->s3->tmp.peer_finish_md, i);
		s->s3->previous_server_finished_len = i;
@


1.27
log
@When you expect a function to return a particular value, don't put a comment
saying that you expect it to return that value and compare it against zero
because it is supposedly faster, for this leads to bugs (especially given the
high rate of sloppy cut'n'paste within ssl3 and dtls1 routines in this
library).

Instead, compare for the exact value it ought to return upon success.

ok deraadt@@
@
text
@d164 1
a164 1
		    sender, slen, s->s3->tmp.finish_md);
a173 1
		OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
d175 1
d177 1
a177 1
			    s->s3->tmp.finish_md, i);
d180 1
d182 1
a182 1
			    s->s3->tmp.finish_md, i);
d219 1
a219 1
	    sender, slen, s->s3->tmp.peer_finish_md);
d253 1
a253 1
	if (i != n || i > EVP_MAX_MD_SIZE) {
d268 1
d270 1
a270 1
		    s->s3->tmp.peer_finish_md, i);
d273 1
d275 1
a275 1
		    s->s3->tmp.peer_finish_md, i);
@


1.26
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.25 2014/06/19 21:29:51 tedu Exp $ */
d164 1
a164 1
		sender, slen, s->s3->tmp.finish_md);
d174 1
a175 1
			OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
d177 1
a177 1
			s->s3->tmp.finish_md, i);
a179 1
			OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
d181 1
a181 1
			s->s3->tmp.finish_md, i);
d218 1
a218 1
	sender, slen, s->s3->tmp.peer_finish_md);
d252 1
a252 1
	if (i != n) {
a266 1
		OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
d268 1
a268 1
		s->s3->tmp.peer_finish_md, i);
a270 1
		OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
d272 1
a272 1
		s->s3->tmp.peer_finish_md, i);
@


1.25
log
@convert CRYPTO_memcmp to timingsafe_memcmp based on current policy favoring
libc interfaces over libcrypto interfaces. for now we also prefer
timingsafe_memcmp over timingsafe_bcmp, even when the latter is acceptable.
ok beck deraadt matthew miod
@
text
@d1 1
a1 1
/* $OpenBSD: s3_both.c,v 1.24 2014/06/12 15:49:31 deraadt Exp $ */
a289 1
 * ssl->session->read_compression	assign
a641 4
#ifndef OPENSSL_NO_COMP
		if (!(s->options & SSL_OP_NO_COMPRESSION))
			len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
#endif
a673 4
#ifndef OPENSSL_NO_COMP
		if (!(s->options & SSL_OP_NO_COMPRESSION))
			len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
#endif
@


1.24
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d259 1
a259 1
	if (CRYPTO_memcmp(p, s->s3->tmp.peer_finish_md, i) != 0) {
@


1.23
log
@BUF_MEM_grow_clean() takes a size_t as the size argument. Remove false comments
mentioning it's an int, bogus (int) casts and bounds checks against INT_MAX
(BUF_MEM_grow_clean has its own integer bounds checks).

ok deraadt@@
@
text
@d1 1
a1 1
/* ssl/s3_both.c */
@


1.22
log
@ECDH and ECDSA will not work overly well if there is no EC, so unifdef
OPENSSL_NO_EC.

ok tedu@@
@
text
@d318 1
a318 1
	if (!BUF_MEM_grow_clean(buf,(int)(n + (*l) + 3))) {
d482 1
a482 7
		if (l > (INT_MAX-4)) /* BUF_MEM_grow takes an 'int' parameter */
		{
			al = SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_MESSAGE, SSL_R_EXCESSIVE_MESSAGE_SIZE);
			goto f_err;
		}
		if (l && !BUF_MEM_grow_clean(s->init_buf,(int)l + 4)) {
@


1.21
log
@Make use of SSL_IS_DTLS, SSL_USE_EXPLICIT_IV, SSL_USE_SIGALGS and
SSL_USE_TLS1_2_CIPHERS.

Largely based on OpenSSL head.
@
text
@a552 1
#ifndef OPENSSL_NO_EC
a555 1
#endif
@


1.20
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@d635 1
a635 1
	if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
d675 1
a675 1
	if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
@


1.19
log
@Fix indentation, adding braces and combining a nested if to reduce depth
@
text
@d722 2
a723 4
	if (s->s3->wbuf.buf != NULL) {
		free(s->s3->wbuf.buf);
		s->s3->wbuf.buf = NULL;
	}
d730 2
a731 4
	if (s->s3->rbuf.buf != NULL) {
		free(s->s3->rbuf.buf);
		s->s3->rbuf.buf = NULL;
	}
@


1.18
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d439 10
a448 9
			if (!s->server)
				if (p[0] == SSL3_MT_HELLO_REQUEST)
					/* The server may always send 'Hello Request' messages --
					 * we are doing a handshake anyway now, so ignore them
					 * if their format is correct. Does not count for
					 * 'Finished' MAC. */
			if (p[1] == 0 && p[2] == 0 &&p[3] == 0) {
				s->init_num = 0;
				skip_message = 1;
d450 3
a452 2
				if (s->msg_callback)
					s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, 4, s, s->msg_callback_arg);
@


1.17
log
@TANSTAAFL - delete the buf freelist code. if you need a better malloc, get
a better malloc. ok beck deraadt
@
text
@d653 1
a653 1
		if ((p = OPENSSL_malloc(len)) == NULL)
d693 1
a693 1
		if ((p = OPENSSL_malloc(len)) == NULL)
d721 1
a721 1
		OPENSSL_free(s->s3->wbuf.buf);
d731 1
a731 1
		OPENSSL_free(s->s3->rbuf.buf);
@


1.16
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a626 70
#ifndef OPENSSL_NO_BUF_FREELISTS
/* On some platforms, malloc() performance is bad enough that you can't just
 * free() and malloc() buffers all the time, so we need to use freelists from
 * unused buffers.  Currently, each freelist holds memory chunks of only a
 * given size (list->chunklen); other sized chunks are freed and malloced.
 * This doesn't help much if you're using many different SSL option settings
 * with a given context.  (The options affecting buffer size are
 * max_send_fragment, read buffer vs write buffer,
 * SSL_OP_MICROSOFT_BIG_WRITE_BUFFER, SSL_OP_NO_COMPRESSION, and
 * SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS.)  Using a separate freelist for every
 * possible size is not an option, since max_send_fragment can take on many
 * different values.
 *
 * If you are on a platform with a slow malloc(), and you're using SSL
 * connections with many different settings for these options, and you need to
 * use the SSL_MOD_RELEASE_BUFFERS feature, you have a few options:
 *    - Link against a faster malloc implementation.
 *    - Use a separate SSL_CTX for each option set.
 *    - Improve this code.
 */
static void *
freelist_extract(SSL_CTX *ctx, int for_read, int sz)
{
	SSL3_BUF_FREELIST *list;
	SSL3_BUF_FREELIST_ENTRY *ent = NULL;
	void *result = NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
	list = for_read ? ctx->rbuf_freelist : ctx->wbuf_freelist;
	if (list != NULL && sz == (int)list->chunklen)
		ent = list->head;
	if (ent != NULL) {
		list->head = ent->next;
		result = ent;
		if (--list->len == 0)
			list->chunklen = 0;
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
	if (!result)
		result = OPENSSL_malloc(sz);
	return result;
}

static void
freelist_insert(SSL_CTX *ctx, int for_read, size_t sz, void *mem)
{
	SSL3_BUF_FREELIST *list;
	SSL3_BUF_FREELIST_ENTRY *ent;

	CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
	list = for_read ? ctx->rbuf_freelist : ctx->wbuf_freelist;
	if (list != NULL && (sz == list->chunklen || list->chunklen == 0) &&
	    list->len < ctx->freelist_max_len && sz >= sizeof(*ent)) {
		list->chunklen = sz;
		ent = mem;
		ent->next = list->head;
		list->head = ent;
		++list->len;
		mem = NULL;
	}

	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
	if (mem)
		OPENSSL_free(mem);
}
#else
#define freelist_extract(c,fr,sz) OPENSSL_malloc(sz)
#define freelist_insert(c,fr,sz,m) OPENSSL_free(m)
#endif

d653 1
a653 1
		if ((p = freelist_extract(s->ctx, 1, len)) == NULL)
d693 1
a693 1
		if ((p = freelist_extract(s->ctx, 0, len)) == NULL)
d721 1
a721 1
		freelist_insert(s->ctx, 0, s->s3->wbuf.len, s->s3->wbuf.buf);
d731 1
a731 1
		freelist_insert(s->ctx, 1, s->s3->rbuf.len, s->s3->rbuf.buf);
@


1.15
log
@Flense a variety of windows support stuff, and a strange gettimeofday function.
ok deraadt@@
@
text
@d128 3
a130 2
int ssl3_do_write(SSL *s, int type)
	{
d133 4
a136 3
	ret=ssl3_write_bytes(s,type,&s->init_buf->data[s->init_off],
	                     s->init_num);
	if (ret < 0) return(-1);
d140 3
a142 4
		ssl3_finish_mac(s,(unsigned char *)&s->init_buf->data[s->init_off],ret);
	
	if (ret == s->init_num)
		{
d145 1
a145 5
		return(1);
		}
	s->init_off+=ret;
	s->init_num-=ret;
	return(0);
d147 4
d152 4
a155 3
int ssl3_send_finished(SSL *s, int a, int b, const char *sender, int slen)
	{
	unsigned char *p,*d;
d159 3
a161 4
	if (s->state == a)
		{
		d=(unsigned char *)s->init_buf->data;
		p= &(d[4]);
d163 2
a164 2
		i=s->method->ssl3_enc->final_finish_mac(s,
			sender,slen,s->s3->tmp.finish_md);
d169 2
a170 2
		p+=i;
		l=i;
d174 16
a189 19
                if(s->type == SSL_ST_CONNECT)
                        {
                         OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
                         memcpy(s->s3->previous_client_finished, 
                             s->s3->tmp.finish_md, i);
                         s->s3->previous_client_finished_len=i;
                        }
                else
                        {
                        OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
                        memcpy(s->s3->previous_server_finished, 
                            s->s3->tmp.finish_md, i);
                        s->s3->previous_server_finished_len=i;
                        }

		*(d++)=SSL3_MT_FINISHED;
		l2n3(l,d);
		s->init_num=(int)l+4;
		s->init_off=0;
d191 2
a192 2
		s->state=b;
		}
d195 2
a196 2
	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
	}
d200 3
a202 2
static void ssl3_take_mac(SSL *s)
	{
d210 7
a216 10
	if (s->state & SSL_ST_CONNECT)
		{
		sender=s->method->ssl3_enc->server_finished_label;
		slen=s->method->ssl3_enc->server_finished_label_len;
		}
	else
		{
		sender=s->method->ssl3_enc->client_finished_label;
		slen=s->method->ssl3_enc->client_finished_label_len;
		}
d219 2
a220 2
		sender,slen,s->s3->tmp.peer_finish_md);
	}
d223 4
a226 3
int ssl3_get_finished(SSL *s, int a, int b)
	{
	int al,i,ok;
d236 2
a237 6
	n=s->method->ssl_get_message(s,
		a,
		b,
		SSL3_MT_FINISHED,
		64, /* should actually be 36+4 :-) */
		&ok);
d239 2
a240 1
	if (!ok) return((int)n);
d243 3
a245 4
	if (!s->s3->change_cipher_spec)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_GOT_A_FIN_BEFORE_A_CCS);
d247 2
a248 2
		}
	s->s3->change_cipher_spec=0;
d253 3
a255 4
	if (i != n)
		{
		al=SSL_AD_DECODE_ERROR;
		SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_BAD_DIGEST_LENGTH);
d257 1
a257 1
		}
d259 3
a261 4
	if (CRYPTO_memcmp(p, s->s3->tmp.peer_finish_md, i) != 0)
		{
		al=SSL_AD_DECRYPT_ERROR;
		SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
d263 1
a263 1
		}
d267 11
a277 14
        if(s->type == SSL_ST_ACCEPT)
                {
                OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
                memcpy(s->s3->previous_client_finished, 
                    s->s3->tmp.peer_finish_md, i);
                s->s3->previous_client_finished_len=i;
                }
        else
                {
                OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
                memcpy(s->s3->previous_server_finished, 
                    s->s3->tmp.peer_finish_md, i);
                s->s3->previous_server_finished_len=i;
                }
d279 1
a279 1
	return(1);
d281 3
a283 3
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
	return(0);
	}
d293 3
a295 2
int ssl3_send_change_cipher_spec(SSL *s, int a, int b)
	{ 
d298 5
a302 6
	if (s->state == a)
		{
		p=(unsigned char *)s->init_buf->data;
		*p=SSL3_MT_CCS;
		s->init_num=1;
		s->init_off=0;
d304 2
a305 2
		s->state=b;
		}
d308 2
a309 2
	return(ssl3_do_write(s,SSL3_RT_CHANGE_CIPHER_SPEC));
	}
d311 3
a313 2
static int ssl3_add_cert_to_buf(BUF_MEM *buf, unsigned long *l, X509 *x)
	{
d317 9
a325 10
	n=i2d_X509(x,NULL);
	if (!BUF_MEM_grow_clean(buf,(int)(n+(*l)+3)))
		{
		SSLerr(SSL_F_SSL3_ADD_CERT_TO_BUF,ERR_R_BUF_LIB);
		return(-1);
		}
	p=(unsigned char *)&(buf->data[*l]);
	l2n3(n,p);
	i2d_X509(x,&p);
	*l+=n+3;
d327 2
a328 2
	return(0);
	}
d330 3
a332 2
unsigned long ssl3_output_cert_chain(SSL *s, X509 *x)
	{
d335 1
a335 1
	unsigned long l=7;
d345 7
a351 10
	buf=s->init_buf;
	if (!BUF_MEM_grow_clean(buf,10))
		{
		SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);
		return(0);
		}
	if (x != NULL)
		{
		if (no_chain)
			{
d353 2
a354 4
				return(0);
			}
		else
			{
d357 4
a360 5
			if (!X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,x,NULL))
				{
				SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_X509_LIB);
				return(0);
				}
d364 1
a364 2
			for (i=0; i < sk_X509_num(xs_ctx.chain); i++)
				{
d367 1
a367 2
				if (ssl3_add_cert_to_buf(buf, &l, x))
					{
a369 1
					}
d371 1
a372 1
			}
d374 1
d376 2
a377 3
	for (i=0; i<sk_X509_num(s->ctx->extra_certs); i++)
		{
		x=sk_X509_value(s->ctx->extra_certs,i);
d379 2
a380 2
			return(0);
		}
d382 10
a391 10
	l-=7;
	p=(unsigned char *)&(buf->data[4]);
	l2n3(l,p);
	l+=3;
	p=(unsigned char *)&(buf->data[0]);
	*(p++)=SSL3_MT_CERTIFICATE;
	l2n3(l,p);
	l+=4;
	return(l);
	}
d398 3
a400 2
long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)
	{
d404 1
a404 1
	int i,al;
d406 5
a410 7
	if (s->s3->tmp.reuse_message)
		{
		s->s3->tmp.reuse_message=0;
		if ((mt >= 0) && (s->s3->tmp.message_type != mt))
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);
d412 2
a413 2
			}
		*ok=1;
d417 1
a417 1
		}
d419 1
a419 1
	p=(unsigned char *)s->init_buf->data;
d422 1
a422 1
		{
d425 7
a431 9
		do
			{
			while (s->init_num < 4)
				{
				i=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
					&p[s->init_num],4 - s->init_num, 0);
				if (i <= 0)
					{
					s->rwstate=SSL_READING;
a433 2
					}
				s->init_num+=i;
d435 3
a437 1
			
d445 6
a450 8
					if (p[1] == 0 && p[2] == 0 &&p[3] == 0)
						{
						s->init_num = 0;
						skip_message = 1;

						if (s->msg_callback)
							s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, 4, s, s->msg_callback_arg);
						}
d452 1
d457 3
a459 4
		if ((mt >= 0) && (*p != mt))
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);
d461 1
a461 1
			}
d463 1
a463 3
					(st1 == SSL3_ST_SR_CERT_A) &&
					(stn == SSL3_ST_SR_CERT_B))
			{
d470 1
a470 1
			}
d474 4
a477 5
		n2l3(p,l);
		if (l > (unsigned long)max)
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);
d479 1
a479 1
			}
d481 3
a483 3
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);
d485 3
a487 4
			}
		if (l && !BUF_MEM_grow_clean(s->init_buf,(int)l+4))
			{
			SSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB);
d489 3
a491 3
			}
		s->s3->tmp.message_size=l;
		s->state=stn;
d495 1
a495 1
		}
d500 5
a504 6
	while (n > 0)
		{
		i=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n,0);
		if (i <= 0)
			{
			s->rwstate=SSL_READING;
d507 1
a507 1
			}
d510 1
a510 1
		}
d523 1
a523 1
	*ok=1;
d526 1
a526 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d528 3
a530 3
	*ok=0;
	return(-1);
	}
d532 3
a534 2
int ssl_cert_type(X509 *x, EVP_PKEY *pkey)
	{
d536 1
a536 1
	int ret= -1,i;
d539 1
a539 1
		pk=X509_get_pubkey(x);
d541 10
a550 12
		pk=pkey;
	if (pk == NULL) goto err;

	i=pk->type;
	if (i == EVP_PKEY_RSA)
		{
		ret=SSL_PKEY_RSA_ENC;
		}
	else if (i == EVP_PKEY_DSA)
		{
		ret=SSL_PKEY_DSA_SIGN;
		}
d552 1
a552 2
	else if (i == EVP_PKEY_EC)
		{
d554 1
a554 1
		}	
d556 1
a556 2
	else if (i == NID_id_GostR3410_94 || i == NID_id_GostR3410_94_cc) 
		{
d558 1
a558 3
		}
	else if (i == NID_id_GostR3410_2001 || i == NID_id_GostR3410_2001_cc) 
		{
d560 1
a560 1
		}
d562 4
a565 3
	if(!pkey) EVP_PKEY_free(pk);
	return(ret);
	}
d567 3
a569 2
int ssl_verify_alarm_type(long type)
	{
d572 1
a572 2
	switch(type)
		{
d576 1
a576 1
		al=SSL_AD_UNKNOWN_CA;
d589 1
a589 1
		al=SSL_AD_BAD_CERTIFICATE;
d593 1
a593 1
		al=SSL_AD_DECRYPT_ERROR;
d597 1
a597 1
		al=SSL_AD_CERTIFICATE_EXPIRED;
d600 1
a600 1
		al=SSL_AD_CERTIFICATE_REVOKED;
d603 1
a603 1
		al=SSL_AD_INTERNAL_ERROR;
d612 1
a612 1
		al=SSL_AD_UNKNOWN_CA;
d615 1
a615 1
		al=SSL_AD_HANDSHAKE_FAILURE;
d618 1
a618 1
		al=SSL_AD_UNSUPPORTED_CERTIFICATE;
d621 1
a621 1
		al=SSL_AD_CERTIFICATE_UNKNOWN;
a622 2
		}
	return(al);
d624 2
d649 1
a649 1
	{
d658 1
a658 2
	if (ent != NULL)
		{
d663 1
a663 1
		}
d672 1
a672 1
	{
d678 2
a679 5
	if (list != NULL &&
	    (sz == list->chunklen || list->chunklen == 0) &&
	    list->len < ctx->freelist_max_len &&
	    sz >= sizeof(*ent))
		{
d686 1
a686 1
		}
d691 1
a691 1
	}
d697 3
a699 2
int ssl3_setup_read_buffer(SSL *s)
	{
d701 2
a702 2
	size_t len,align=0,headerlen;
	
d709 1
a709 1
	align = (-SSL3_RT_HEADER_LENGTH)&(SSL3_ALIGN_PAYLOAD-1);
d712 4
a715 7
	if (s->s3->rbuf.buf == NULL)
		{
		len = SSL3_RT_MAX_PLAIN_LENGTH
			+ SSL3_RT_MAX_ENCRYPTED_OVERHEAD
			+ headerlen + align;
		if (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)
			{
d718 1
a718 1
			}
d723 1
a723 1
		if ((p=freelist_extract(s->ctx, 1, len)) == NULL)
d727 1
a727 1
		}
d729 1
a729 1
	s->packet= &(s->s3->rbuf.buf[0]);
d733 1
a733 1
	SSLerr(SSL_F_SSL3_SETUP_READ_BUFFER,ERR_R_MALLOC_FAILURE);
d735 1
a735 1
	}
d737 3
a739 2
int ssl3_setup_write_buffer(SSL *s)
	{
d741 1
a741 1
	size_t len,align=0,headerlen;
d749 1
a749 1
	align = (-SSL3_RT_HEADER_LENGTH)&(SSL3_ALIGN_PAYLOAD-1);
d752 3
a754 5
	if (s->s3->wbuf.buf == NULL)
		{
		len = s->max_send_fragment
			+ SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD
			+ headerlen + align;
d760 2
a761 2
			len += headerlen + align
				+ SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD;
d763 1
a763 1
		if ((p=freelist_extract(s->ctx, 0, len)) == NULL)
d767 1
a767 1
		}
d772 1
a772 1
	SSLerr(SSL_F_SSL3_SETUP_WRITE_BUFFER,ERR_R_MALLOC_FAILURE);
d774 1
a774 1
	}
d777 3
a779 2
int ssl3_setup_buffers(SSL *s)
	{
d785 1
a785 1
	}
d787 4
a790 4
int ssl3_release_write_buffer(SSL *s)
	{
	if (s->s3->wbuf.buf != NULL)
		{
d793 1
a793 1
		}
d795 1
a795 1
	}
d797 4
a800 4
int ssl3_release_read_buffer(SSL *s)
	{
	if (s->s3->rbuf.buf != NULL)
		{
d803 1
a803 1
		}
d805 1
a805 1
	}
@


1.14
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a187 7
#ifdef OPENSSL_SYS_WIN16
		/* MSVC 1.5 does not clear the top bytes of the word unless
		 * I do this.
		 */
		l&=0xffff;
#endif

@


1.13
log
@SECURITY fixes backported from openssl-1.0.1f.  ok mikeb@@

CVE-2013-4353 NULL pointer dereference with crafted Next Protocol
 Negotiation record in TLS handshake.
Upstream: 197e0ea

CVE-2013-6449 Fix crash with crafted traffic from a TLS 1.2 client.
Upstream: ca98926, 0294b2b

CVE-2013-6450 Fix DTLS retransmission from previous session.
Upstream: 3462896
@
text
@d209 2
a210 1
static void ssl3_take_mac(SSL *s) {
a212 1

d231 1
a231 1
}
d241 3
a243 2
	/* the mac has already been generated when we received the change
	 * cipher spec message and is in s->s3->tmp.peer_finish_md. */
d274 1
a274 1
	if (timingsafe_bcmp(p, s->s3->tmp.peer_finish_md, i) != 0)
d548 1
d555 1
@


1.12
log
@cherry pick bugfixes for http://www.openssl.org/news/secadv_20130205.txt
from the openssl git (changes between openssl 1.0.1c and 1.0.1d).
ok djm@@
@
text
@d164 2
d213 5
@


1.11
log
@resolve conflicts
@
text
@d266 1
a266 1
	if (memcmp(p, s->s3->tmp.peer_finish_md, i) != 0)
@


1.10
log
@resolve conflicts, fix local changes
@
text
@d205 22
d233 4
a236 3
	/* the mac has already been generated when we received the
	 * change cipher spec message and is in s->s3->tmp.peer_finish_md
	 */ 
d540 7
@


1.9
log
@resolve conflicts
@
text
@a162 2
			&(s->s3->finish_dgst1),
			&(s->s3->finish_dgst2),
d169 17
d250 17
d299 19
d321 1
a321 1
	int n,i;
a323 3
	X509_STORE_CTX xs_ctx;
	X509_OBJECT obj;

d340 1
a340 1
		if(!no_chain && !X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,NULL,NULL))
d342 2
a343 2
			SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_X509_LIB);
			return(0);
d345 3
d349 1
a349 4
		for (;;)
			{
			n=i2d_X509(x,NULL);
			if (!BUF_MEM_grow_clean(buf,(int)(n+l+3)))
d351 1
a351 1
				SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);
d354 14
a367 18
			p=(unsigned char *)&(buf->data[l]);
			l2n3(n,p);
			i2d_X509(x,&p);
			l+=n+3;

			if (no_chain)
				break;

			if (X509_NAME_cmp(X509_get_subject_name(x),
				X509_get_issuer_name(x)) == 0) break;

			i=X509_STORE_get_by_subject(&xs_ctx,X509_LU_X509,
				X509_get_issuer_name(x),&obj);
			if (i <= 0) break;
			x=obj.data.x509;
			/* Count is one too high since the X509_STORE_get uped the
			 * ref count */
			X509_free(x);
a368 2
		if (!no_chain)
			X509_STORE_CTX_cleanup(&xs_ctx);
a369 1

a370 1
	if (s->ctx->extra_certs != NULL)
d374 1
a374 4
		n=i2d_X509(x,NULL);
		if (!BUF_MEM_grow_clean(buf,(int)(n+l+3)))
			{
			SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);
a375 5
			}
		p=(unsigned char *)&(buf->data[l]);
		l2n3(n,p);
		i2d_X509(x,&p);
		l+=n+3;
d553 9
a562 2
#endif

d628 75
a702 1
int ssl3_setup_buffers(SSL *s)
d705 10
a714 2
	unsigned int extra;
	size_t len;
d718 3
d722 9
a730 5
			extra=SSL3_RT_MAX_EXTRA;
		else
			extra=0;
		len = SSL3_RT_MAX_PACKET_SIZE + extra;
		if ((p=OPENSSL_malloc(len)) == NULL)
d736 22
d760 12
a771 3
		len = SSL3_RT_MAX_PACKET_SIZE;
		len += SSL3_RT_HEADER_LENGTH + 256; /* extra space for empty fragment */
		if ((p=OPENSSL_malloc(len)) == NULL)
d776 3
a778 2
	s->packet= &(s->s3->rbuf.buf[0]);
	return(1);
d780 32
a811 2
	SSLerr(SSL_F_SSL3_SETUP_BUFFERS,ERR_R_MALLOC_FAILURE);
	return(0);
d813 1
@


1.8
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d111 5
d200 1
a200 1
	n=ssl3_get_message(s,
d394 2
a395 2
				i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],
					4 - s->init_num, 0);
d475 1
a475 1
		i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n,0);
d500 1
a500 1
	int ret= -1,i,j;
a511 6
		if (x != NULL)
			{
			j=X509_get_ext_count(x);
			/* check to see if this is a signing only certificate */
			/* EAY EAY EAY EAY */
			}
d517 2
a518 1
	else if (i == EVP_PKEY_DH)
d520 1
a520 13
		/* if we just have a key, we needs to be guess */

		if (x == NULL)
			ret=SSL_PKEY_DH_DSA;
		else
			{
			j=X509_get_signature_type(x);
			if (j == EVP_PKEY_RSA)
				ret=SSL_PKEY_DH_RSA;
			else if (j== EVP_PKEY_DSA)
				ret=SSL_PKEY_DH_DSA;
			else ret= -1;
			}
d522 1
a522 2
	else
		ret= -1;
@


1.7
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d271 7
d280 1
a280 1
	if (!BUF_MEM_grow(buf,(int)(10)))
d287 1
a287 1
		if(!X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,NULL,NULL))
d296 1
a296 1
			if (!BUF_MEM_grow(buf,(int)(n+l+3)))
d305 4
d320 2
a321 2

		X509_STORE_CTX_cleanup(&xs_ctx);
d330 1
a330 1
		if (!BUF_MEM_grow(buf,(int)(n+l+3)))
d453 1
a453 1
		if (l && !BUF_MEM_grow(s->init_buf,(int)l+4))
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d115 1
a120 1
#include "ssl_locl.h"
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
d112 1
d122 1
a122 1
/* send s->init_buf in records of type 'type' */
d136 3
d140 1
d166 1
a166 1
#ifdef WIN16
d213 1
a213 1
	p = (unsigned char *)s->init_buf->data;
d280 5
a284 1
		X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,NULL,NULL);
d363 3
a365 1
		return((int)s->s3->tmp.message_size);
d397 2
d400 4
a426 2
		ssl3_finish_mac(s, (unsigned char *)s->init_buf->data, 4);
			
d436 7
a442 1
		if (l && !BUF_MEM_grow(s->init_buf,(int)l))
d450 2
a451 1
		s->init_num=0;
d455 2
a456 2
	p=(unsigned char *)s->init_buf->data;
	n=s->s3->tmp.message_size;
d469 3
a471 1
	ssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num);
d539 1
d551 2
d574 2
d581 3
d595 1
d603 2
a604 2
		if ((p=OPENSSL_malloc(SSL3_RT_MAX_PACKET_SIZE+extra))
			== NULL)
d606 2
a607 1
		s->s3->rbuf.buf=p;
d612 3
a614 2
		if ((p=OPENSSL_malloc(SSL3_RT_MAX_PACKET_SIZE))
			== NULL)
d616 2
a617 1
		s->s3->wbuf.buf=p;
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d368 1
a368 1
					4 - s->init_num);
d437 1
a437 1
		i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d570 1
a570 1
		if ((p=Malloc(SSL3_RT_MAX_PACKET_SIZE+extra))
d578 1
a578 1
		if ((p=Malloc(SSL3_RT_MAX_PACKET_SIZE))
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d58 53
d112 1
d121 21
a141 2
int ssl3_send_finished(SSL *s, int a, int b, unsigned char *sender,
	     int slen)
d155 3
a157 1
			sender,slen,p);
d187 1
a187 1
	 * change cipher spec message and is in s->s3->tmp.in_dgst[12]
d199 1
a199 1
	/* If this occurs if we has missed a message */
d208 2
a209 3
	p=(unsigned char *)s->init_buf->data;

	i=s->method->ssl3_enc->finish_mac_length;
d218 1
a218 1
	if (memcmp(  p,    (char *)&(s->s3->tmp.finish_md[0]),i) != 0)
d332 5
d359 1
a359 1
	if (s->state == st1)
d361 3
a363 3
		i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],
				  4-s->init_num);
		if (i < (4-s->init_num))
d365 22
a386 2
			*ok=0;
			return(ssl3_part_read(s,i));
d388 3
d398 14
d435 1
a435 1
	if (n > 0)
d438 1
a438 1
		if (i != (int)n)
d440 3
a442 2
			*ok=0;
			return(ssl3_part_read(s,i));
d444 2
d447 1
d449 1
a449 1
	return(n);
d570 1
a570 1
		if ((p=(unsigned char *)Malloc(SSL3_RT_MAX_PACKET_SIZE+extra))
d578 1
a578 1
		if ((p=(unsigned char *)Malloc(SSL3_RT_MAX_PACKET_SIZE))
@


1.1
log
@Initial revision
@
text
@d60 5
a64 5
#include "buffer.h"
#include "rand.h"
#include "objects.h"
#include "evp.h"
#include "x509.h"
d67 2
a68 11
#define BREAK	break

/* SSL3err(SSL_F_SSL3_GET_FINISHED,SSL_R_EXCESSIVE_MESSAGE_SIZE);
 */

int ssl3_send_finished(s,a,b,sender,slen)
SSL *s;
int a;
int b;
unsigned char *sender;
int slen;
d86 7
d105 1
a105 4
int ssl3_get_finished(s,a,b)
SSL *s;
int a;
int b;
d165 1
a165 3
int ssl3_send_change_cipher_spec(s,a,b)
SSL *s;
int a,b;
d183 1
a183 3
unsigned long ssl3_output_cert_chain(s,x)
SSL *s;
X509 *x;
d230 17
d258 1
a258 5
long ssl3_get_message(s,st1,stn,mt,max,ok)
SSL *s;
int st1,stn,mt;
long max;
int *ok;
d282 2
a283 3
		i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,
			(char *)&(p[s->init_num]),
			4-s->init_num);
d321 1
a321 2
		i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,
			(char *)&(p[s->init_num]),(int)n);
d337 1
a337 3
int ssl_cert_type(x,pkey)
X509 *x;
EVP_PKEY *pkey;
d383 1
d387 1
a387 2
int ssl_verify_alarm_type(type)
long type;
d439 1
a439 2
int ssl3_setup_buffers(s)
SSL *s;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
a58 2
#include <limits.h>
#include <string.h>
d60 5
a64 5
#include <openssl/buffer.h>
#include <openssl/rand.h>
#include <openssl/objects.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
d67 1
a67 4
/* send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or SSL3_RT_CHANGE_CIPHER_SPEC) */
int ssl3_do_write(SSL *s, int type)
	{
	int ret;
d69 2
a70 18
	ret=ssl3_write_bytes(s,type,&s->init_buf->data[s->init_off],
	                     s->init_num);
	if (ret < 0) return(-1);
	if (type == SSL3_RT_HANDSHAKE)
		/* should not be done for 'Hello Request's, but in that case
		 * we'll ignore the result anyway */
		ssl3_finish_mac(s,(unsigned char *)&s->init_buf->data[s->init_off],ret);
	
	if (ret == s->init_num)
		{
		if (s->msg_callback)
			s->msg_callback(1, s->version, type, s->init_buf->data, (size_t)(s->init_off + s->init_num), s, s->msg_callback_arg);
		return(1);
		}
	s->init_off+=ret;
	s->init_num-=ret;
	return(0);
	}
d72 6
a77 1
int ssl3_send_finished(SSL *s, int a, int b, const char *sender, int slen)
d91 1
a91 3
			sender,slen,s->s3->tmp.finish_md);
		s->s3->tmp.finish_md_len = i;
		memcpy(p, s->s3->tmp.finish_md, i);
a94 7
#ifdef OPENSSL_SYS_WIN16
		/* MSVC 1.5 does not clear the top bytes of the word unless
		 * I do this.
		 */
		l&=0xffff;
#endif

d107 4
a110 1
int ssl3_get_finished(SSL *s, int a, int b)
d117 1
a117 1
	 * change cipher spec message and is in s->s3->tmp.peer_finish_md
d129 1
a129 1
	/* If this occurs, we have missed a message */
d138 3
a140 2
	p = (unsigned char *)s->init_msg;
	i = s->s3->tmp.peer_finish_md_len;
d149 1
a149 1
	if (memcmp(p, s->s3->tmp.peer_finish_md, i) != 0)
d170 3
a172 1
int ssl3_send_change_cipher_spec(SSL *s, int a, int b)
d190 3
a192 1
unsigned long ssl3_output_cert_chain(SSL *s, X509 *x)
d210 1
a210 5
		if(!X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,NULL,NULL))
			{
			SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_X509_LIB);
			return(0);
			}
a238 17
	/* Thawte special :-) */
	if (s->ctx->extra_certs != NULL)
	for (i=0; i<sk_X509_num(s->ctx->extra_certs); i++)
		{
		x=sk_X509_value(s->ctx->extra_certs,i);
		n=i2d_X509(x,NULL);
		if (!BUF_MEM_grow(buf,(int)(n+l+3)))
			{
			SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);
			return(0);
			}
		p=(unsigned char *)&(buf->data[l]);
		l2n3(n,p);
		i2d_X509(x,&p);
		l+=n+3;
		}

d250 5
a254 6
/* Obtain handshake message of message type 'mt' (any if mt == -1),
 * maximum acceptable body length 'max'.
 * The first four bytes (msg_type and length) are read in state 'st1',
 * the body is read in state 'stn'.
 */
long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)
d271 1
a271 3
		s->init_msg = s->init_buf->data + 4;
		s->init_num = (int)s->s3->tmp.message_size;
		return s->init_num;
d276 1
a276 1
	if (s->state == st1) /* s->init_num < 4 */
d278 4
a281 3
		int skip_message;

		do
d283 2
a284 28
			while (s->init_num < 4)
				{
				i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],
					4 - s->init_num, 0);
				if (i <= 0)
					{
					s->rwstate=SSL_READING;
					*ok = 0;
					return i;
					}
				s->init_num+=i;
				}
			
			skip_message = 0;
			if (!s->server)
				if (p[0] == SSL3_MT_HELLO_REQUEST)
					/* The server may always send 'Hello Request' messages --
					 * we are doing a handshake anyway now, so ignore them
					 * if their format is correct. Does not count for
					 * 'Finished' MAC. */
					if (p[1] == 0 && p[2] == 0 &&p[3] == 0)
						{
						s->init_num = 0;
						skip_message = 1;

						if (s->msg_callback)
							s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, 4, s, s->msg_callback_arg);
						}
a285 3
		while (skip_message);

		/* s->init_num == 4 */
a292 12
		if ((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) &&
					(st1 == SSL3_ST_SR_CERT_A) &&
					(stn == SSL3_ST_SR_CERT_B))
			{
			/* At this point we have got an MS SGC second client
			 * hello (maybe we should always allow the client to
			 * start a new handshake?). We need to restart the mac.
			 * Don't increment {num,total}_renegotiations because
			 * we have not completed the handshake. */
			ssl3_init_finished_mac(s);
			}

d302 1
a302 7
		if (l > (INT_MAX-4)) /* BUF_MEM_grow takes an 'int' parameter */
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);
			goto f_err;
			}
		if (l && !BUF_MEM_grow(s->init_buf,(int)l+4))
d310 1
a310 2
		s->init_msg = s->init_buf->data + 4;
		s->init_num = 0;
d314 3
a316 3
	p = s->init_msg;
	n = s->s3->tmp.message_size - s->init_num;
	while (n > 0)
d318 3
a320 2
		i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n,0);
		if (i <= 0)
d322 2
a323 3
			s->rwstate=SSL_READING;
			*ok = 0;
			return i;
a324 2
		s->init_num += i;
		n -= i;
a325 3
	ssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num + 4);
	if (s->msg_callback)
		s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->init_buf->data, (size_t)s->init_num + 4, s, s->msg_callback_arg);
d327 1
a327 1
	return s->init_num;
d335 3
a337 1
int ssl_cert_type(X509 *x, EVP_PKEY *pkey)
a382 1
	if(!pkey) EVP_PKEY_free(pk);
d386 2
a387 1
int ssl_verify_alarm_type(long type)
a394 1
	case X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER:
a405 2
	case X509_V_ERR_CERT_UNTRUSTED:
	case X509_V_ERR_CERT_REJECTED:
a426 2
	case X509_V_ERR_PATH_LENGTH_EXCEEDED:
	case X509_V_ERR_INVALID_CA:
a431 3
	case X509_V_ERR_INVALID_PURPOSE:
		al=SSL_AD_UNSUPPORTED_CERTIFICATE;
		break;
d439 2
a440 1
int ssl3_setup_buffers(SSL *s)
a443 1
	size_t len;
d451 2
a452 2
		len = SSL3_RT_MAX_PACKET_SIZE + extra;
		if ((p=OPENSSL_malloc(len)) == NULL)
d454 1
a454 2
		s->s3->rbuf.buf = p;
		s->s3->rbuf.len = len;
d459 2
a460 3
		len = SSL3_RT_MAX_PACKET_SIZE;
		len += SSL3_RT_HEADER_LENGTH + 256; /* extra space for empty fragment */
		if ((p=OPENSSL_malloc(len)) == NULL)
d462 1
a462 2
		s->s3->wbuf.buf = p;
		s->s3->wbuf.len = len;
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a114 1
#include "ssl_locl.h"
d120 1
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a270 7
	int no_chain;

	if ((s->mode & SSL_MODE_NO_AUTO_CHAIN) || s->ctx->extra_certs)
		no_chain = 1;
	else
		no_chain = 0;

d273 1
a273 1
	if (!BUF_MEM_grow_clean(buf,10))
d280 1
a280 1
		if(!no_chain && !X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,NULL,NULL))
d289 1
a289 1
			if (!BUF_MEM_grow_clean(buf,(int)(n+l+3)))
a297 4

			if (no_chain)
				break;

d309 2
a310 2
		if (!no_chain)
			X509_STORE_CTX_cleanup(&xs_ctx);
d319 1
a319 1
		if (!BUF_MEM_grow_clean(buf,(int)(n+l+3)))
d442 1
a442 1
		if (l && !BUF_MEM_grow_clean(s->init_buf,(int)l+4))
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@a110 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
d195 1
a195 1
	n=s->method->ssl_get_message(s,
d389 2
a390 2
				i=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
					&p[s->init_num],4 - s->init_num, 0);
d470 1
a470 1
		i=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n,0);
d495 1
a495 1
	int ret= -1,i;
d507 6
d518 1
a518 2
#ifndef OPENSSL_NO_EC
	else if (i == EVP_PKEY_EC)
d520 13
a532 1
		ret = SSL_PKEY_ECC;
d534 2
a535 1
#endif
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d163 2
a170 17
                /* Copy the finished so we can use it for
                   renegotiation checks */
                if(s->type == SSL_ST_CONNECT)
                        {
                         OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
                         memcpy(s->s3->previous_client_finished, 
                             s->s3->tmp.finish_md, i);
                         s->s3->previous_client_finished_len=i;
                        }
                else
                        {
                        OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
                        memcpy(s->s3->previous_server_finished, 
                            s->s3->tmp.finish_md, i);
                        s->s3->previous_server_finished_len=i;
                        }

a234 17
        /* Copy the finished so we can use it for
           renegotiation checks */
        if(s->type == SSL_ST_ACCEPT)
                {
                OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
                memcpy(s->s3->previous_client_finished, 
                    s->s3->tmp.peer_finish_md, i);
                s->s3->previous_client_finished_len=i;
                }
        else
                {
                OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
                memcpy(s->s3->previous_server_finished, 
                    s->s3->tmp.peer_finish_md, i);
                s->s3->previous_server_finished_len=i;
                }

a266 19
static int ssl3_add_cert_to_buf(BUF_MEM *buf, unsigned long *l, X509 *x)
	{
	int n;
	unsigned char *p;

	n=i2d_X509(x,NULL);
	if (!BUF_MEM_grow_clean(buf,(int)(n+(*l)+3)))
		{
		SSLerr(SSL_F_SSL3_ADD_CERT_TO_BUF,ERR_R_BUF_LIB);
		return(-1);
		}
	p=(unsigned char *)&(buf->data[*l]);
	l2n3(n,p);
	i2d_X509(x,&p);
	*l+=n+3;

	return(0);
	}

d270 1
a270 1
	int i;
d273 3
d292 1
a292 1
		if (no_chain)
d294 2
a295 2
			if (ssl3_add_cert_to_buf(buf, &l, x))
				return(0);
d297 2
a298 1
		else
d300 2
a301 3
			X509_STORE_CTX xs_ctx;

			if (!X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,x,NULL))
d303 1
a303 1
				SSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_X509_LIB);
d306 20
a325 13
			X509_verify_cert(&xs_ctx);
			/* Don't leave errors in the queue */
			ERR_clear_error();
			for (i=0; i < sk_X509_num(xs_ctx.chain); i++)
				{
				x = sk_X509_value(xs_ctx.chain, i);

				if (ssl3_add_cert_to_buf(buf, &l, x))
					{
					X509_STORE_CTX_cleanup(&xs_ctx);
					return 0;
					}
				}
a326 1
			}
d328 1
d330 1
d334 4
a337 1
		if (ssl3_add_cert_to_buf(buf, &l, x))
d339 5
d521 1
a521 1
		}	
d523 1
a523 8
	else if (i == NID_id_GostR3410_94 || i == NID_id_GostR3410_94_cc) 
		{
		ret = SSL_PKEY_GOST94;
		}
	else if (i == NID_id_GostR3410_2001 || i == NID_id_GostR3410_2001_cc) 
		{
		ret = SSL_PKEY_GOST01;
		}
d589 1
a589 75
#ifndef OPENSSL_NO_BUF_FREELISTS
/* On some platforms, malloc() performance is bad enough that you can't just
 * free() and malloc() buffers all the time, so we need to use freelists from
 * unused buffers.  Currently, each freelist holds memory chunks of only a
 * given size (list->chunklen); other sized chunks are freed and malloced.
 * This doesn't help much if you're using many different SSL option settings
 * with a given context.  (The options affecting buffer size are
 * max_send_fragment, read buffer vs write buffer,
 * SSL_OP_MICROSOFT_BIG_WRITE_BUFFER, SSL_OP_NO_COMPRESSION, and
 * SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS.)  Using a separate freelist for every
 * possible size is not an option, since max_send_fragment can take on many
 * different values.
 *
 * If you are on a platform with a slow malloc(), and you're using SSL
 * connections with many different settings for these options, and you need to
 * use the SSL_MOD_RELEASE_BUFFERS feature, you have a few options:
 *    - Link against a faster malloc implementation.
 *    - Use a separate SSL_CTX for each option set.
 *    - Improve this code.
 */
static void *
freelist_extract(SSL_CTX *ctx, int for_read, int sz)
	{
	SSL3_BUF_FREELIST *list;
	SSL3_BUF_FREELIST_ENTRY *ent = NULL;
	void *result = NULL;

	CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
	list = for_read ? ctx->rbuf_freelist : ctx->wbuf_freelist;
	if (list != NULL && sz == (int)list->chunklen)
		ent = list->head;
	if (ent != NULL)
		{
		list->head = ent->next;
		result = ent;
		if (--list->len == 0)
			list->chunklen = 0;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
	if (!result)
		result = OPENSSL_malloc(sz);
	return result;
}

static void
freelist_insert(SSL_CTX *ctx, int for_read, size_t sz, void *mem)
	{
	SSL3_BUF_FREELIST *list;
	SSL3_BUF_FREELIST_ENTRY *ent;

	CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
	list = for_read ? ctx->rbuf_freelist : ctx->wbuf_freelist;
	if (list != NULL &&
	    (sz == list->chunklen || list->chunklen == 0) &&
	    list->len < ctx->freelist_max_len &&
	    sz >= sizeof(*ent))
		{
		list->chunklen = sz;
		ent = mem;
		ent->next = list->head;
		list->head = ent;
		++list->len;
		mem = NULL;
		}

	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
	if (mem)
		OPENSSL_free(mem);
	}
#else
#define freelist_extract(c,fr,sz) OPENSSL_malloc(sz)
#define freelist_insert(c,fr,sz,m) OPENSSL_free(m)
#endif

int ssl3_setup_read_buffer(SSL *s)
d592 2
a593 10
	size_t len,align=0,headerlen;
	
	if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
		headerlen = DTLS1_RT_HEADER_LENGTH;
	else
		headerlen = SSL3_RT_HEADER_LENGTH;

#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
	align = (-SSL3_RT_HEADER_LENGTH)&(SSL3_ALIGN_PAYLOAD-1);
#endif
a596 3
		len = SSL3_RT_MAX_PLAIN_LENGTH
			+ SSL3_RT_MAX_ENCRYPTED_OVERHEAD
			+ headerlen + align;
d598 5
a602 9
			{
			s->s3->init_extra = 1;
			len += SSL3_RT_MAX_EXTRA;
			}
#ifndef OPENSSL_NO_COMP
		if (!(s->options & SSL_OP_NO_COMPRESSION))
			len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
#endif
		if ((p=freelist_extract(s->ctx, 1, len)) == NULL)
a607 22
	s->packet= &(s->s3->rbuf.buf[0]);
	return 1;

err:
	SSLerr(SSL_F_SSL3_SETUP_READ_BUFFER,ERR_R_MALLOC_FAILURE);
	return 0;
	}

int ssl3_setup_write_buffer(SSL *s)
	{
	unsigned char *p;
	size_t len,align=0,headerlen;

	if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
		headerlen = DTLS1_RT_HEADER_LENGTH + 1;
	else
		headerlen = SSL3_RT_HEADER_LENGTH;

#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
	align = (-SSL3_RT_HEADER_LENGTH)&(SSL3_ALIGN_PAYLOAD-1);
#endif

d610 3
a612 12
		len = s->max_send_fragment
			+ SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD
			+ headerlen + align;
#ifndef OPENSSL_NO_COMP
		if (!(s->options & SSL_OP_NO_COMPRESSION))
			len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
#endif
		if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
			len += headerlen + align
				+ SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD;

		if ((p=freelist_extract(s->ctx, 0, len)) == NULL)
d617 2
a618 3

	return 1;

d620 2
a621 2
	SSLerr(SSL_F_SSL3_SETUP_WRITE_BUFFER,ERR_R_MALLOC_FAILURE);
	return 0;
a622 31


int ssl3_setup_buffers(SSL *s)
	{
	if (!ssl3_setup_read_buffer(s))
		return 0;
	if (!ssl3_setup_write_buffer(s))
		return 0;
	return 1;
	}

int ssl3_release_write_buffer(SSL *s)
	{
	if (s->s3->wbuf.buf != NULL)
		{
		freelist_insert(s->ctx, 0, s->s3->wbuf.len, s->s3->wbuf.buf);
		s->s3->wbuf.buf = NULL;
		}
	return 1;
	}

int ssl3_release_read_buffer(SSL *s)
	{
	if (s->s3->rbuf.buf != NULL)
		{
		freelist_insert(s->ctx, 1, s->s3->rbuf.len, s->s3->rbuf.buf);
		s->s3->rbuf.buf = NULL;
		}
	return 1;
	}

@


1.1.1.7
log
@import OpenSSL-1.0.1c
@
text
@a204 22
#ifndef OPENSSL_NO_NEXTPROTONEG
/* ssl3_take_mac calculates the Finished MAC for the handshakes messages seen to far. */
static void ssl3_take_mac(SSL *s) {
	const char *sender;
	int slen;

	if (s->state & SSL_ST_CONNECT)
		{
		sender=s->method->ssl3_enc->server_finished_label;
		slen=s->method->ssl3_enc->server_finished_label_len;
		}
	else
		{
		sender=s->method->ssl3_enc->client_finished_label;
		slen=s->method->ssl3_enc->client_finished_label_len;
		}

	s->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,
		sender,slen,s->s3->tmp.peer_finish_md);
}
#endif

d211 3
a213 4
#ifdef OPENSSL_NO_NEXTPROTONEG
	/* the mac has already been generated when we received the change
	 * cipher spec message and is in s->s3->tmp.peer_finish_md. */
#endif
a516 7
#ifndef OPENSSL_NO_NEXTPROTONEG
	/* If receiving Finished, record MAC of prior handshake messages for
	 * Finished verification. */
	if (*s->init_buf->data == SSL3_MT_FINISHED)
		ssl3_take_mac(s);
#endif
	/* Feed this message into MAC computation. */
@


1.1.1.8
log
@Import OpenSSL 1.0.1g
@
text
@a163 2
		if (i == 0)
			return 0;
d207 1
a207 2
static void ssl3_take_mac(SSL *s)
	{
d210 1
a210 5
	/* If no new cipher setup return immediately: other functions will
	 * set the appropriate error.
	 */
	if (s->s3->tmp.new_cipher == NULL)
		return;
d224 1
a224 1
	}
d234 2
a235 3
	/* the mac has already been generated when we received the
	 * change cipher spec message and is in s->s3->tmp.peer_finish_md.
	 */ 
d266 1
a266 1
	if (CRYPTO_memcmp(p, s->s3->tmp.peer_finish_md, i) != 0)
a539 1

a545 1

@


