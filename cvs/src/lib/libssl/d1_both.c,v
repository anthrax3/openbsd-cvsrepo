head	1.50;
access;
symbols;
locks; strict;
comment	@ * @;


1.50
date	2017.03.04.16.32.00;	author jsing;	state Exp;
branches;
next	1.49;
commitid	TrWoiZkfDXTvdQj8;

1.49
date	2017.02.07.02.08.38;	author beck;	state Exp;
branches;
next	1.48;
commitid	xH3OeartUDKSlAnB;

1.48
date	2017.01.26.12.16.13;	author beck;	state Exp;
branches;
next	1.47;
commitid	lb4UTPLS9Casn2PL;

1.47
date	2017.01.26.10.40.21;	author beck;	state Exp;
branches;
next	1.46;
commitid	Bi1VygMenL4YtCp7;

1.46
date	2017.01.23.13.36.12;	author jsing;	state Exp;
branches;
next	1.45;
commitid	xYJ523Ay020rUB5W;

1.45
date	2017.01.23.08.48.44;	author beck;	state Exp;
branches;
next	1.44;
commitid	vAKES6VByBpegTl4;

1.44
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.43;
commitid	grTXB43OAHDwwKOU;

1.43
date	2017.01.23.04.55.26;	author beck;	state Exp;
branches;
next	1.42;
commitid	AhwkqHI5lKK3NR31;

1.42
date	2017.01.22.09.02.07;	author jsing;	state Exp;
branches;
next	1.41;
commitid	570ElYZpaAvthwZh;

1.41
date	2017.01.22.07.16.38;	author beck;	state Exp;
branches;
next	1.40;
commitid	qajmn1SU3Rm3vz6g;

1.40
date	2016.12.06.13.38.11;	author jsing;	state Exp;
branches;
next	1.39;
commitid	NUWXcEP3cB3L0fHl;

1.39
date	2016.03.06.14.52.15;	author beck;	state Exp;
branches;
next	1.38;
commitid	7dzq0qLU3rfFj8Ei;

1.38
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.37;
commitid	pa8oXRlJthT375Ws;

1.37
date	2015.09.11.16.28.37;	author jsing;	state Exp;
branches;
next	1.36;
commitid	D3HqE5ZRseh1ZZFx;

1.36
date	2015.09.11.15.59.21;	author jsing;	state Exp;
branches;
next	1.35;
commitid	Iv6JVh6ZjpUbHq3L;

1.35
date	2015.09.10.17.57.50;	author jsing;	state Exp;
branches;
next	1.34;
commitid	T35skZJCouRaXVVY;

1.34
date	2015.07.19.20.32.18;	author doug;	state Exp;
branches;
next	1.33;
commitid	JJGxWtixsF6e0H2B;

1.33
date	2015.07.18.23.00.23;	author doug;	state Exp;
branches;
next	1.32;
commitid	83F4EYjF8aqo7ueq;

1.32
date	2015.02.09.10.53.28;	author jsing;	state Exp;
branches;
next	1.31;
commitid	91DZ31h3Xbk1xWbU;

1.31
date	2014.12.14.16.07.26;	author jsing;	state Exp;
branches;
next	1.30;
commitid	nt2w88sbfSTGqxmB;

1.30
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.29;
commitid	M3pvHgIFoWUHNqJn;

1.29
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.28;
commitid	cGE1JG2i0h4NcVDi;

1.28
date	2014.08.08.05.06.56;	author guenther;	state Exp;
branches;
next	1.27;
commitid	q1sWjcR04QTC5TUr;

1.27
date	2014.08.07.20.24.12;	author guenther;	state Exp;
branches;
next	1.26;
commitid	lTPFL2ZmveaM2edo;

1.26
date	2014.08.07.20.02.23;	author miod;	state Exp;
branches;
next	1.25;
commitid	DMh9IXTC6aDWVuh5;

1.25
date	2014.08.07.19.46.31;	author miod;	state Exp;
branches;
next	1.24;
commitid	vayOLqnrIMw5dnz8;

1.24
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.23;
commitid	lsH7iukeZYSZBx6F;

1.23
date	2014.07.10.08.25.00;	author guenther;	state Exp;
branches;
next	1.22;
commitid	w11OIjBmQPrJwUQI;

1.22
date	2014.07.02.20.45.26;	author miod;	state Exp;
branches;
next	1.21;
commitid	yROGdckN958Fbvp1;

1.21
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	mJUVYpkFBZ0Zv2bG;

1.20
date	2014.06.05.17.53.02;	author jsing;	state Exp;
branches;
next	1.19;
commitid	Acg5cSuNpvtur6b4;

1.19
date	2014.06.05.16.53.15;	author jsing;	state Exp;
branches;
next	1.18;
commitid	IInLyXedeNQrEAzV;

1.18
date	2014.05.31.19.09.20;	author miod;	state Exp;
branches;
next	1.17;
commitid	M7fNcFtAKgxRs3jT;

1.17
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.05.28.13.03.24;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.22.17.37.06;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2014.05.18.16.13.48;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.30.13.51.58;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.24.15.50.02;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.16.18.23.52;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.15.11.50.18;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.14.14.16.33;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.13.23.05.18;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.07.23.57.27;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2014.02.27.21.04.57;	author jca;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.11.03.02.32.19;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.01.05.22.59.08;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches
	1.1.1.5.2.1
	1.1.1.5.4.1;
next	1.1.1.6;

1.1.1.6
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.1.1.5.2.1
date	2014.04.08.00.55.03;	author djm;	state Exp;
branches;
next	;

1.1.1.5.4.1
date	2014.04.08.00.55.23;	author djm;	state Exp;
branches;
next	1.1.1.5.4.2;

1.1.1.5.4.2
date	2014.06.05.20.38.41;	author sthen;	state Exp;
branches;
next	1.1.1.5.4.3;
commitid	gnspbNMI0pd00ehI;

1.1.1.5.4.3
date	2014.06.05.20.39.09;	author sthen;	state Exp;
branches;
next	1.1.1.5.4.4;
commitid	DaKqjhZfj2eAzj4y;

1.1.1.5.4.4
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.2.4.1
date	2014.04.08.00.55.39;	author djm;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2014.06.05.20.12.12;	author sthen;	state Exp;
branches;
next	1.2.4.3;
commitid	5p2A2kGba21gFN7H;

1.2.4.3
date	2014.06.05.20.16.56;	author sthen;	state Exp;
branches;
next	1.2.4.4;
commitid	SJTenZkM9Cdh1hgc;

1.2.4.4
date	2014.08.09.16.54.57;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;


desc
@@


1.50
log
@Drop the second argument of dtls1_set_message_header() and make it a void
function. Nothing makes use of the return value and the second argument
was only used to produce the return value...
@
text
@/* $OpenBSD: d1_both.c,v 1.49 2017/02/07 02:08:38 beck Exp $ */
/*
 * DTLS implementation written by Nagendra Modadugu
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.
 */
/* ====================================================================
 * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <limits.h>
#include <stdio.h>
#include <string.h>

#include "ssl_locl.h"

#include <openssl/buffer.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#include <openssl/x509.h>

#include "pqueue.h"
#include "bytestring.h"

#define RSMBLY_BITMASK_SIZE(msg_len) (((msg_len) + 7) / 8)

#define RSMBLY_BITMASK_MARK(bitmask, start, end) { \
			if ((end) - (start) <= 8) { \
				long ii; \
				for (ii = (start); ii < (end); ii++) bitmask[((ii) >> 3)] |= (1 << ((ii) & 7)); \
			} else { \
				long ii; \
				bitmask[((start) >> 3)] |= bitmask_start_values[((start) & 7)]; \
				for (ii = (((start) >> 3) + 1); ii < ((((end) - 1)) >> 3); ii++) bitmask[ii] = 0xff; \
				bitmask[(((end) - 1) >> 3)] |= bitmask_end_values[((end) & 7)]; \
			} }

#define RSMBLY_BITMASK_IS_COMPLETE(bitmask, msg_len, is_complete) { \
			long ii; \
			OPENSSL_assert((msg_len) > 0); \
			is_complete = 1; \
			if (bitmask[(((msg_len) - 1) >> 3)] != bitmask_end_values[((msg_len) & 7)]) is_complete = 0; \
			if (is_complete) for (ii = (((msg_len) - 1) >> 3) - 1; ii >= 0 ; ii--) \
				if (bitmask[ii] != 0xff) { is_complete = 0; break; } }

static unsigned char bitmask_start_values[] = {
	0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80
};
static unsigned char bitmask_end_values[] = {
	0xff, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f
};

/* XDTLS:  figure out the right values */
static unsigned int g_probable_mtu[] = {1500 - 28, 512 - 28, 256 - 28};

static unsigned int dtls1_guess_mtu(unsigned int curr_mtu);
static void dtls1_fix_message_header(SSL *s, unsigned long frag_off,
    unsigned long frag_len);
static unsigned char *dtls1_write_message_header(SSL *s, unsigned char *p);
static void dtls1_set_message_header_int(SSL *s, unsigned char mt,
    unsigned long len, unsigned short seq_num, unsigned long frag_off,
    unsigned long frag_len);
static long dtls1_get_message_fragment(SSL *s, int st1, int stn, long max,
    int *ok);

static hm_fragment *
dtls1_hm_fragment_new(unsigned long frag_len, int reassembly)
{
	hm_fragment *frag = NULL;
	unsigned char *buf = NULL;
	unsigned char *bitmask = NULL;

	frag = malloc(sizeof(hm_fragment));
	if (frag == NULL)
		return NULL;

	if (frag_len) {
		buf = malloc(frag_len);
		if (buf == NULL) {
			free(frag);
			return NULL;
		}
	}

	/* zero length fragment gets zero frag->fragment */
	frag->fragment = buf;

	/* Initialize reassembly bitmask if necessary */
	if (reassembly) {
		bitmask = malloc(RSMBLY_BITMASK_SIZE(frag_len));
		if (bitmask == NULL) {
			free(buf);
			free(frag);
			return NULL;
		}
		memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
	}

	frag->reassembly = bitmask;

	return frag;
}

static void
dtls1_hm_fragment_free(hm_fragment *frag)
{
	if (frag == NULL)
		return;

	if (frag->msg_header.is_ccs) {
		EVP_CIPHER_CTX_free(
		    frag->msg_header.saved_retransmit_state.enc_write_ctx);
		EVP_MD_CTX_destroy(
		    frag->msg_header.saved_retransmit_state.write_hash);
	}
	free(frag->fragment);
	free(frag->reassembly);
	free(frag);
}

/* send s->internal->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or SSL3_RT_CHANGE_CIPHER_SPEC) */
int
dtls1_do_write(SSL *s, int type)
{
	int ret;
	int curr_mtu;
	unsigned int len, frag_off, mac_size, blocksize;

	/* AHA!  Figure out the MTU, and stick to the right size */
	if (D1I(s)->mtu < dtls1_min_mtu() &&
	    !(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU)) {
		D1I(s)->mtu = BIO_ctrl(SSL_get_wbio(s),
		    BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);

		/*
		 * I've seen the kernel return bogus numbers when it
		 * doesn't know the MTU (ie., the initial write), so just
		 * make sure we have a reasonable number
		 */
		if (D1I(s)->mtu < dtls1_min_mtu()) {
			D1I(s)->mtu = 0;
			D1I(s)->mtu = dtls1_guess_mtu(D1I(s)->mtu);
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SET_MTU,
			    D1I(s)->mtu, NULL);
		}
	}

	OPENSSL_assert(D1I(s)->mtu >= dtls1_min_mtu());
	/* should have something reasonable now */

	if (s->internal->init_off == 0  && type == SSL3_RT_HANDSHAKE)
		OPENSSL_assert(s->internal->init_num ==
		    (int)D1I(s)->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);

	if (s->internal->write_hash)
		mac_size = EVP_MD_CTX_size(s->internal->write_hash);
	else
		mac_size = 0;

	if (s->internal->enc_write_ctx &&
	    (EVP_CIPHER_mode( s->internal->enc_write_ctx->cipher) & EVP_CIPH_CBC_MODE))
		blocksize = 2 * EVP_CIPHER_block_size(s->internal->enc_write_ctx->cipher);
	else
		blocksize = 0;

	frag_off = 0;
	while (s->internal->init_num) {
		curr_mtu = D1I(s)->mtu - BIO_wpending(SSL_get_wbio(s)) -
		    DTLS1_RT_HEADER_LENGTH - mac_size - blocksize;

		if (curr_mtu <= DTLS1_HM_HEADER_LENGTH) {
			/* grr.. we could get an error if MTU picked was wrong */
			ret = BIO_flush(SSL_get_wbio(s));
			if (ret <= 0)
				return ret;
			curr_mtu = D1I(s)->mtu - DTLS1_RT_HEADER_LENGTH -
			    mac_size - blocksize;
		}

		if (s->internal->init_num > curr_mtu)
			len = curr_mtu;
		else
			len = s->internal->init_num;


		/* XDTLS: this function is too long.  split out the CCS part */
		if (type == SSL3_RT_HANDSHAKE) {
			if (s->internal->init_off != 0) {
				OPENSSL_assert(s->internal->init_off > DTLS1_HM_HEADER_LENGTH);
				s->internal->init_off -= DTLS1_HM_HEADER_LENGTH;
				s->internal->init_num += DTLS1_HM_HEADER_LENGTH;

				if (s->internal->init_num > curr_mtu)
					len = curr_mtu;
				else
					len = s->internal->init_num;
			}

			dtls1_fix_message_header(s, frag_off,
			    len - DTLS1_HM_HEADER_LENGTH);

			dtls1_write_message_header(s,
			    (unsigned char *)&s->internal->init_buf->data[s->internal->init_off]);

			OPENSSL_assert(len >= DTLS1_HM_HEADER_LENGTH);
		}

		ret = dtls1_write_bytes(s, type,
		    &s->internal->init_buf->data[s->internal->init_off], len);
		if (ret < 0) {
			/*
			 * Might need to update MTU here, but we don't know
			 * which previous packet caused the failure -- so
			 * can't really retransmit anything.  continue as
			 * if everything is fine and wait for an alert to
			 * handle the retransmit
			 */
			if (BIO_ctrl(SSL_get_wbio(s),
			    BIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL) > 0)
				D1I(s)->mtu = BIO_ctrl(SSL_get_wbio(s),
				    BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);
			else
				return (-1);
		} else {

			/*
			 * Bad if this assert fails, only part of the
			 * handshake message got sent.  but why would
			 * this happen?
			 */
			OPENSSL_assert(len == (unsigned int)ret);

			if (type == SSL3_RT_HANDSHAKE &&
			    !D1I(s)->retransmitting) {
				/*
				 * Should not be done for 'Hello Request's,
				 * but in that case we'll ignore the result
				 * anyway
				 */
				unsigned char *p = (unsigned char *)&s->internal->init_buf->data[s->internal->init_off];
				const struct hm_header_st *msg_hdr = &D1I(s)->w_msg_hdr;
				int xlen;

				if (frag_off == 0) {
					/*
					 * Reconstruct message header is if it
					 * is being sent in single fragment
					 */
					*p++ = msg_hdr->type;
					l2n3(msg_hdr->msg_len, p);
					s2n (msg_hdr->seq, p);
					l2n3(0, p);
					l2n3(msg_hdr->msg_len, p);
					p -= DTLS1_HM_HEADER_LENGTH;
					xlen = ret;
				} else {
					p += DTLS1_HM_HEADER_LENGTH;
					xlen = ret - DTLS1_HM_HEADER_LENGTH;
				}

				tls1_finish_mac(s, p, xlen);
			}

			if (ret == s->internal->init_num) {
				if (s->internal->msg_callback)
					s->internal->msg_callback(1, s->version, type,
					    s->internal->init_buf->data,
					    (size_t)(s->internal->init_off + s->internal->init_num),
					    s, s->internal->msg_callback_arg);

				s->internal->init_off = 0;
				/* done writing this message */
				s->internal->init_num = 0;

				return (1);
			}
			s->internal->init_off += ret;
			s->internal->init_num -= ret;
			frag_off += (ret -= DTLS1_HM_HEADER_LENGTH);
		}
	}
	return (0);
}


/*
 * Obtain handshake message of message type 'mt' (any if mt == -1),
 * maximum acceptable body length 'max'.
 * Read an entire handshake message.  Handshake messages arrive in
 * fragments.
 */
long
dtls1_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)
{
	int i, al;
	struct hm_header_st *msg_hdr;
	unsigned char *p;
	unsigned long msg_len;

	/*
	 * s3->internal->tmp is used to store messages that are unexpected, caused
	 * by the absence of an optional handshake message
	 */
	if (S3I(s)->tmp.reuse_message) {
		S3I(s)->tmp.reuse_message = 0;
		if ((mt >= 0) && (S3I(s)->tmp.message_type != mt)) {
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerror(s, SSL_R_UNEXPECTED_MESSAGE);
			goto f_err;
		}
		*ok = 1;
		s->internal->init_msg = s->internal->init_buf->data + DTLS1_HM_HEADER_LENGTH;
		s->internal->init_num = (int)S3I(s)->tmp.message_size;
		return s->internal->init_num;
	}

	msg_hdr = &D1I(s)->r_msg_hdr;
	memset(msg_hdr, 0x00, sizeof(struct hm_header_st));

again:
	i = dtls1_get_message_fragment(s, st1, stn, max, ok);
	if (i == DTLS1_HM_BAD_FRAGMENT ||
	    i == DTLS1_HM_FRAGMENT_RETRY)  /* bad fragment received */
		goto again;
	else if (i <= 0 && !*ok)
		return i;

	p = (unsigned char *)s->internal->init_buf->data;
	msg_len = msg_hdr->msg_len;

	/* reconstruct message header */
	*(p++) = msg_hdr->type;
	l2n3(msg_len, p);
	s2n (msg_hdr->seq, p);
	l2n3(0, p);
	l2n3(msg_len, p);

	p -= DTLS1_HM_HEADER_LENGTH;
	msg_len += DTLS1_HM_HEADER_LENGTH;

	tls1_finish_mac(s, p, msg_len);
	if (s->internal->msg_callback)
		s->internal->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, msg_len,
		    s, s->internal->msg_callback_arg);

	memset(msg_hdr, 0x00, sizeof(struct hm_header_st));

	/* Don't change sequence numbers while listening */
	if (!D1I(s)->listen)
		D1I(s)->handshake_read_seq++;

	s->internal->init_msg = s->internal->init_buf->data + DTLS1_HM_HEADER_LENGTH;
	return s->internal->init_num;

f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
	*ok = 0;
	return -1;
}


static int
dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr, int max)
{
	size_t frag_off, frag_len, msg_len;

	msg_len = msg_hdr->msg_len;
	frag_off = msg_hdr->frag_off;
	frag_len = msg_hdr->frag_len;

	/* sanity checking */
	if ((frag_off + frag_len) > msg_len) {
		SSLerror(s, SSL_R_EXCESSIVE_MESSAGE_SIZE);
		return SSL_AD_ILLEGAL_PARAMETER;
	}

	if ((frag_off + frag_len) > (unsigned long)max) {
		SSLerror(s, SSL_R_EXCESSIVE_MESSAGE_SIZE);
		return SSL_AD_ILLEGAL_PARAMETER;
	}

	if ( D1I(s)->r_msg_hdr.frag_off == 0) /* first fragment */
	{
		/*
		 * msg_len is limited to 2^24, but is effectively checked
		 * against max above
		 */
		if (!BUF_MEM_grow_clean(s->internal->init_buf,
		    msg_len + DTLS1_HM_HEADER_LENGTH)) {
			SSLerror(s, ERR_R_BUF_LIB);
			return SSL_AD_INTERNAL_ERROR;
		}

		S3I(s)->tmp.message_size = msg_len;
		D1I(s)->r_msg_hdr.msg_len = msg_len;
		S3I(s)->tmp.message_type = msg_hdr->type;
		D1I(s)->r_msg_hdr.type = msg_hdr->type;
		D1I(s)->r_msg_hdr.seq = msg_hdr->seq;
	} else if (msg_len != D1I(s)->r_msg_hdr.msg_len) {
		/*
		 * They must be playing with us! BTW, failure to enforce
		 * upper limit would open possibility for buffer overrun.
		 */
		SSLerror(s, SSL_R_EXCESSIVE_MESSAGE_SIZE);
		return SSL_AD_ILLEGAL_PARAMETER;
	}

	return 0; /* no error */
}

static int
dtls1_retrieve_buffered_fragment(SSL *s, long max, int *ok)
{
	/*
	 * (0) check whether the desired fragment is available
	 * if so:
	 * (1) copy over the fragment to s->internal->init_buf->data[]
	 * (2) update s->internal->init_num
	 */
	pitem *item;
	hm_fragment *frag;
	int al;

	*ok = 0;
	item = pqueue_peek(D1I(s)->buffered_messages);
	if (item == NULL)
		return 0;

	frag = (hm_fragment *)item->data;

	/* Don't return if reassembly still in progress */
	if (frag->reassembly != NULL)
		return 0;

	if (D1I(s)->handshake_read_seq == frag->msg_header.seq) {
		unsigned long frag_len = frag->msg_header.frag_len;
		pqueue_pop(D1I(s)->buffered_messages);

		al = dtls1_preprocess_fragment(s, &frag->msg_header, max);

		if (al == 0) /* no alert */
		{
			unsigned char *p = (unsigned char *)s->internal->init_buf->data + DTLS1_HM_HEADER_LENGTH;
			memcpy(&p[frag->msg_header.frag_off],
			    frag->fragment, frag->msg_header.frag_len);
		}

		dtls1_hm_fragment_free(frag);
		pitem_free(item);

		if (al == 0) {
			*ok = 1;
			return frag_len;
		}

		ssl3_send_alert(s, SSL3_AL_FATAL, al);
		s->internal->init_num = 0;
		*ok = 0;
		return -1;
	} else
		return 0;
}

/*
 * dtls1_max_handshake_message_len returns the maximum number of bytes
 * permitted in a DTLS handshake message for |s|. The minimum is 16KB,
 * but may be greater if the maximum certificate list size requires it.
 */
static unsigned long
dtls1_max_handshake_message_len(const SSL *s)
{
	unsigned long max_len;

	max_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;
	if (max_len < (unsigned long)s->internal->max_cert_list)
		return s->internal->max_cert_list;
	return max_len;
}

static int
dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)
{
	hm_fragment *frag = NULL;
	pitem *item = NULL;
	int i = -1, is_complete;
	unsigned char seq64be[8];
	unsigned long frag_len = msg_hdr->frag_len;

	if ((msg_hdr->frag_off + frag_len) > msg_hdr->msg_len ||
	    msg_hdr->msg_len > dtls1_max_handshake_message_len(s))
		goto err;

	if (frag_len == 0) {
		i = DTLS1_HM_FRAGMENT_RETRY;
		goto err;
	}

	/* Try to find item in queue */
	memset(seq64be, 0, sizeof(seq64be));
	seq64be[6] = (unsigned char)(msg_hdr->seq >> 8);
	seq64be[7] = (unsigned char)msg_hdr->seq;
	item = pqueue_find(D1I(s)->buffered_messages, seq64be);

	if (item == NULL) {
		frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);
		if (frag == NULL)
			goto err;
		memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
		frag->msg_header.frag_len = frag->msg_header.msg_len;
		frag->msg_header.frag_off = 0;
	} else {
		frag = (hm_fragment*)item->data;
		if (frag->msg_header.msg_len != msg_hdr->msg_len) {
			item = NULL;
			frag = NULL;
			goto err;
		}
	}

	/*
	 * If message is already reassembled, this must be a
	 * retransmit and can be dropped.
	 */
	if (frag->reassembly == NULL) {
		unsigned char devnull [256];

		while (frag_len) {
			i = s->method->internal->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
			    devnull, frag_len > sizeof(devnull) ?
			    sizeof(devnull) : frag_len, 0);
			if (i <= 0)
				goto err;
			frag_len -= i;
		}
		i = DTLS1_HM_FRAGMENT_RETRY;
		goto err;
	}

	/* read the body of the fragment (header has already been read */
	i = s->method->internal->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
	    frag->fragment + msg_hdr->frag_off, frag_len, 0);
	if (i <= 0 || (unsigned long)i != frag_len)
		goto err;

	RSMBLY_BITMASK_MARK(frag->reassembly, (long)msg_hdr->frag_off,
	    (long)(msg_hdr->frag_off + frag_len));

	RSMBLY_BITMASK_IS_COMPLETE(frag->reassembly, (long)msg_hdr->msg_len,
	    is_complete);

	if (is_complete) {
		free(frag->reassembly);
		frag->reassembly = NULL;
	}

	if (item == NULL) {
		memset(seq64be, 0, sizeof(seq64be));
		seq64be[6] = (unsigned char)(msg_hdr->seq >> 8);
		seq64be[7] = (unsigned char)(msg_hdr->seq);

		item = pitem_new(seq64be, frag);
		if (item == NULL) {
			i = -1;
			goto err;
		}

		pqueue_insert(D1I(s)->buffered_messages, item);
	}

	return DTLS1_HM_FRAGMENT_RETRY;

err:
	if (item == NULL && frag != NULL)
		dtls1_hm_fragment_free(frag);
	*ok = 0;
	return i;
}


static int
dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok)
{
	int i = -1;
	hm_fragment *frag = NULL;
	pitem *item = NULL;
	unsigned char seq64be[8];
	unsigned long frag_len = msg_hdr->frag_len;

	if ((msg_hdr->frag_off + frag_len) > msg_hdr->msg_len)
		goto err;

	/* Try to find item in queue, to prevent duplicate entries */
	memset(seq64be, 0, sizeof(seq64be));
	seq64be[6] = (unsigned char) (msg_hdr->seq >> 8);
	seq64be[7] = (unsigned char) msg_hdr->seq;
	item = pqueue_find(D1I(s)->buffered_messages, seq64be);

	/*
	 * If we already have an entry and this one is a fragment,
	 * don't discard it and rather try to reassemble it.
	 */
	if (item != NULL && frag_len < msg_hdr->msg_len)
		item = NULL;

	/*
	 * Discard the message if sequence number was already there, is
	 * too far in the future, already in the queue or if we received
	 * a FINISHED before the SERVER_HELLO, which then must be a stale
	 * retransmit.
	 */
	if (msg_hdr->seq <= D1I(s)->handshake_read_seq ||
	    msg_hdr->seq > D1I(s)->handshake_read_seq + 10 || item != NULL ||
	    (D1I(s)->handshake_read_seq == 0 &&
	    msg_hdr->type == SSL3_MT_FINISHED)) {
		unsigned char devnull [256];

		while (frag_len) {
			i = s->method->internal->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
			    devnull, frag_len > sizeof(devnull) ?
			    sizeof(devnull) : frag_len, 0);
			if (i <= 0)
				goto err;
			frag_len -= i;
		}
	} else {
		if (frag_len < msg_hdr->msg_len)
			return dtls1_reassemble_fragment(s, msg_hdr, ok);

		if (frag_len > dtls1_max_handshake_message_len(s))
			goto err;

		frag = dtls1_hm_fragment_new(frag_len, 0);
		if (frag == NULL)
			goto err;

		memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));

		if (frag_len) {
			/* read the body of the fragment (header has already been read */
			i = s->method->internal->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
			    frag->fragment, frag_len, 0);
			if (i <= 0 || (unsigned long)i != frag_len)
				goto err;
		}

		memset(seq64be, 0, sizeof(seq64be));
		seq64be[6] = (unsigned char)(msg_hdr->seq >> 8);
		seq64be[7] = (unsigned char)(msg_hdr->seq);

		item = pitem_new(seq64be, frag);
		if (item == NULL)
			goto err;

		pqueue_insert(D1I(s)->buffered_messages, item);
	}

	return DTLS1_HM_FRAGMENT_RETRY;

err:
	if (item == NULL && frag != NULL)
		dtls1_hm_fragment_free(frag);
	*ok = 0;
	return i;
}


static long
dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok)
{
	unsigned char wire[DTLS1_HM_HEADER_LENGTH];
	unsigned long len, frag_off, frag_len;
	int i, al;
	struct hm_header_st msg_hdr;

again:
	/* see if we have the required fragment already */
	if ((frag_len = dtls1_retrieve_buffered_fragment(s, max, ok)) || *ok) {
		if (*ok)
			s->internal->init_num = frag_len;
		return frag_len;
	}

	/* read handshake message header */
	i = s->method->internal->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, wire,
	    DTLS1_HM_HEADER_LENGTH, 0);
	if (i <= 0) 	/* nbio, or an error */
	{
		s->internal->rwstate = SSL_READING;
		*ok = 0;
		return i;
	}
	/* Handshake fails if message header is incomplete */
	if (i != DTLS1_HM_HEADER_LENGTH ||
	    /* parse the message fragment header */
	    dtls1_get_message_header(wire, &msg_hdr) == 0) {
		al = SSL_AD_UNEXPECTED_MESSAGE;
		SSLerror(s, SSL_R_UNEXPECTED_MESSAGE);
		goto f_err;
	}

	/*
	 * if this is a future (or stale) message it gets buffered
	 * (or dropped)--no further processing at this time
	 * While listening, we accept seq 1 (ClientHello with cookie)
	 * although we're still expecting seq 0 (ClientHello)
	 */
	if (msg_hdr.seq != D1I(s)->handshake_read_seq &&
	    !(D1I(s)->listen && msg_hdr.seq == 1))
		return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);

	len = msg_hdr.msg_len;
	frag_off = msg_hdr.frag_off;
	frag_len = msg_hdr.frag_len;

	if (frag_len && frag_len < len)
		return dtls1_reassemble_fragment(s, &msg_hdr, ok);

	if (!s->server && D1I(s)->r_msg_hdr.frag_off == 0 &&
	    wire[0] == SSL3_MT_HELLO_REQUEST) {
		/*
		 * The server may always send 'Hello Request' messages --
		 * we are doing a handshake anyway now, so ignore them
		 * if their format is correct. Does not count for
		 * 'Finished' MAC.
		 */
		if (wire[1] == 0 && wire[2] == 0 && wire[3] == 0) {
			if (s->internal->msg_callback)
				s->internal->msg_callback(0, s->version,
				    SSL3_RT_HANDSHAKE, wire,
				    DTLS1_HM_HEADER_LENGTH, s,
				    s->internal->msg_callback_arg);

			s->internal->init_num = 0;
			goto again;
		}
		else /* Incorrectly formated Hello request */
		{
			al = SSL_AD_UNEXPECTED_MESSAGE;
			SSLerror(s, SSL_R_UNEXPECTED_MESSAGE);
			goto f_err;
		}
	}

	if ((al = dtls1_preprocess_fragment(s, &msg_hdr, max)))
		goto f_err;

	/* XDTLS:  ressurect this when restart is in place */
	s->internal->state = stn;

	if (frag_len > 0) {
		unsigned char *p = (unsigned char *)s->internal->init_buf->data + DTLS1_HM_HEADER_LENGTH;

		i = s->method->internal->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
		    &p[frag_off], frag_len, 0);
		/* XDTLS:  fix this--message fragments cannot span multiple packets */
		if (i <= 0) {
			s->internal->rwstate = SSL_READING;
			*ok = 0;
			return i;
		}
	} else
		i = 0;

	/*
	 * XDTLS:  an incorrectly formatted fragment should cause the
	 * handshake to fail
	 */
	if (i != (int)frag_len) {
		al = SSL3_AD_ILLEGAL_PARAMETER;
		SSLerror(s, SSL3_AD_ILLEGAL_PARAMETER);
		goto f_err;
	}

	*ok = 1;

	/*
	 * Note that s->internal->init_num is *not* used as current offset in
	 * s->internal->init_buf->data, but as a counter summing up fragments'
	 * lengths: as soon as they sum up to handshake packet
	 * length, we assume we have got all the fragments.
	 */
	s->internal->init_num = frag_len;
	return frag_len;

f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
	s->internal->init_num = 0;

	*ok = 0;
	return (-1);
}

/*
 * for these 2 messages, we need to
 * ssl->enc_read_ctx			re-init
 * ssl->s3->internal->read_sequence		zero
 * ssl->s3->internal->read_mac_secret		re-init
 * ssl->session->read_sym_enc		assign
 * ssl->session->read_hash		assign
 */
int
dtls1_send_change_cipher_spec(SSL *s, int a, int b)
{
	unsigned char *p;

	if (s->internal->state == a) {
		p = (unsigned char *)s->internal->init_buf->data;
		*p++=SSL3_MT_CCS;
		D1I(s)->handshake_write_seq = D1I(s)->next_handshake_write_seq;
		s->internal->init_num = DTLS1_CCS_HEADER_LENGTH;

		s->internal->init_off = 0;

		dtls1_set_message_header_int(s, SSL3_MT_CCS, 0,
		    D1I(s)->handshake_write_seq, 0, 0);

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 1);

		s->internal->state = b;
	}

	/* SSL3_ST_CW_CHANGE_B */
	return (dtls1_do_write(s, SSL3_RT_CHANGE_CIPHER_SPEC));
}

int
dtls1_read_failed(SSL *s, int code)
{
	if (code > 0) {
#ifdef DEBUG
		fprintf(stderr, "invalid state reached %s:%d",
		    __FILE__, __LINE__);
#endif
		return 1;
	}

	if (!dtls1_is_timer_expired(s)) {
		/*
		 * not a timeout, none of our business, let higher layers
		 * handle this.  in fact it's probably an error
		 */
		return code;
	}

	if (!SSL_in_init(s))  /* done, no need to send a retransmit */
	{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
	}

	return dtls1_handle_timeout(s);
}

int
dtls1_get_queue_priority(unsigned short seq, int is_ccs)
{
	/*
	 * The index of the retransmission queue actually is the message
	 * sequence number, since the queue only contains messages of a
	 * single handshake. However, the ChangeCipherSpec has no message
	 * sequence number and so using only the sequence will result in
	 * the CCS and Finished having the same index. To prevent this, the
	 * sequence number is multiplied by 2. In case of a CCS 1 is
	 * subtracted.  This does not only differ CSS and Finished, it also
	 * maintains the order of the index (important for priority queues)
	 * and fits in the unsigned short variable.
	 */
	return seq * 2 - is_ccs;
}

int
dtls1_retransmit_buffered_messages(SSL *s)
{
	pqueue sent = s->d1->sent_messages;
	piterator iter;
	pitem *item;
	hm_fragment *frag;
	int found = 0;

	iter = pqueue_iterator(sent);

	for (item = pqueue_next(&iter); item != NULL;
	    item = pqueue_next(&iter)) {
		frag = (hm_fragment *)item->data;
		if (dtls1_retransmit_message(s,
		    (unsigned short)dtls1_get_queue_priority(
		    frag->msg_header.seq, frag->msg_header.is_ccs), 0,
		    &found) <= 0 && found) {
#ifdef DEBUG
			fprintf(stderr, "dtls1_retransmit_message() failed\n");
#endif
			return -1;
		}
	}

	return 1;
}

int
dtls1_buffer_message(SSL *s, int is_ccs)
{
	pitem *item;
	hm_fragment *frag;
	unsigned char seq64be[8];

	/* Buffer the messsage in order to handle DTLS retransmissions. */

	/*
	 * This function is called immediately after a message has
	 * been serialized
	 */
	OPENSSL_assert(s->internal->init_off == 0);

	frag = dtls1_hm_fragment_new(s->internal->init_num, 0);
	if (frag == NULL)
		return 0;

	memcpy(frag->fragment, s->internal->init_buf->data, s->internal->init_num);

	if (is_ccs) {
		OPENSSL_assert(D1I(s)->w_msg_hdr.msg_len +
		    ((s->version == DTLS1_VERSION) ?
		    DTLS1_CCS_HEADER_LENGTH : 3) == (unsigned int)s->internal->init_num);
	} else {
		OPENSSL_assert(D1I(s)->w_msg_hdr.msg_len +
		    DTLS1_HM_HEADER_LENGTH == (unsigned int)s->internal->init_num);
	}

	frag->msg_header.msg_len = D1I(s)->w_msg_hdr.msg_len;
	frag->msg_header.seq = D1I(s)->w_msg_hdr.seq;
	frag->msg_header.type = D1I(s)->w_msg_hdr.type;
	frag->msg_header.frag_off = 0;
	frag->msg_header.frag_len = D1I(s)->w_msg_hdr.msg_len;
	frag->msg_header.is_ccs = is_ccs;

	/* save current state*/
	frag->msg_header.saved_retransmit_state.enc_write_ctx = s->internal->enc_write_ctx;
	frag->msg_header.saved_retransmit_state.write_hash = s->internal->write_hash;
	frag->msg_header.saved_retransmit_state.session = s->session;
	frag->msg_header.saved_retransmit_state.epoch = D1I(s)->w_epoch;

	memset(seq64be, 0, sizeof(seq64be));
	seq64be[6] = (unsigned char)(dtls1_get_queue_priority(
	    frag->msg_header.seq, frag->msg_header.is_ccs) >> 8);
	seq64be[7] = (unsigned char)(dtls1_get_queue_priority(
	    frag->msg_header.seq, frag->msg_header.is_ccs));

	item = pitem_new(seq64be, frag);
	if (item == NULL) {
		dtls1_hm_fragment_free(frag);
		return 0;
	}

	pqueue_insert(s->d1->sent_messages, item);
	return 1;
}

int
dtls1_retransmit_message(SSL *s, unsigned short seq, unsigned long frag_off,
    int *found)
{
	int ret;
	/* XDTLS: for now assuming that read/writes are blocking */
	pitem *item;
	hm_fragment *frag;
	unsigned long header_length;
	unsigned char seq64be[8];
	struct dtls1_retransmit_state saved_state;
	unsigned char save_write_sequence[8];

	/*
	  OPENSSL_assert(s->internal->init_num == 0);
	  OPENSSL_assert(s->internal->init_off == 0);
	 */

	/* XDTLS:  the requested message ought to be found, otherwise error */
	memset(seq64be, 0, sizeof(seq64be));
	seq64be[6] = (unsigned char)(seq >> 8);
	seq64be[7] = (unsigned char)seq;

	item = pqueue_find(s->d1->sent_messages, seq64be);
	if (item == NULL) {
#ifdef DEBUG
		fprintf(stderr, "retransmit:  message %d non-existant\n", seq);
#endif
		*found = 0;
		return 0;
	}

	*found = 1;
	frag = (hm_fragment *)item->data;

	if (frag->msg_header.is_ccs)
		header_length = DTLS1_CCS_HEADER_LENGTH;
	else
		header_length = DTLS1_HM_HEADER_LENGTH;

	memcpy(s->internal->init_buf->data, frag->fragment,
	    frag->msg_header.msg_len + header_length);
	s->internal->init_num = frag->msg_header.msg_len + header_length;

	dtls1_set_message_header_int(s, frag->msg_header.type,
	    frag->msg_header.msg_len, frag->msg_header.seq, 0,
	    frag->msg_header.frag_len);

	/* save current state */
	saved_state.enc_write_ctx = s->internal->enc_write_ctx;
	saved_state.write_hash = s->internal->write_hash;
	saved_state.session = s->session;
	saved_state.epoch = D1I(s)->w_epoch;

	D1I(s)->retransmitting = 1;

	/* restore state in which the message was originally sent */
	s->internal->enc_write_ctx = frag->msg_header.saved_retransmit_state.enc_write_ctx;
	s->internal->write_hash = frag->msg_header.saved_retransmit_state.write_hash;
	s->session = frag->msg_header.saved_retransmit_state.session;
	D1I(s)->w_epoch = frag->msg_header.saved_retransmit_state.epoch;

	if (frag->msg_header.saved_retransmit_state.epoch ==
	    saved_state.epoch - 1) {
		memcpy(save_write_sequence, S3I(s)->write_sequence,
		    sizeof(S3I(s)->write_sequence));
		memcpy(S3I(s)->write_sequence, D1I(s)->last_write_sequence,
		    sizeof(S3I(s)->write_sequence));
	}

	ret = dtls1_do_write(s, frag->msg_header.is_ccs ?
	    SSL3_RT_CHANGE_CIPHER_SPEC : SSL3_RT_HANDSHAKE);

	/* restore current state */
	s->internal->enc_write_ctx = saved_state.enc_write_ctx;
	s->internal->write_hash = saved_state.write_hash;
	s->session = saved_state.session;
	D1I(s)->w_epoch = saved_state.epoch;

	if (frag->msg_header.saved_retransmit_state.epoch ==
	    saved_state.epoch - 1) {
		memcpy(D1I(s)->last_write_sequence, S3I(s)->write_sequence,
		    sizeof(S3I(s)->write_sequence));
		memcpy(S3I(s)->write_sequence, save_write_sequence,
		    sizeof(S3I(s)->write_sequence));
	}

	D1I(s)->retransmitting = 0;

	(void)BIO_flush(SSL_get_wbio(s));
	return ret;
}

/* call this function when the buffered messages are no longer needed */
void
dtls1_clear_record_buffer(SSL *s)
{
	pitem *item;

	for(item = pqueue_pop(s->d1->sent_messages); item != NULL;
	    item = pqueue_pop(s->d1->sent_messages)) {
		dtls1_hm_fragment_free((hm_fragment *)item->data);
		pitem_free(item);
	}
}

void
dtls1_set_message_header(SSL *s, unsigned char mt, unsigned long len,
    unsigned long frag_off, unsigned long frag_len)
{
	/* Don't change sequence numbers while listening */
	if (frag_off == 0 && !D1I(s)->listen) {
		D1I(s)->handshake_write_seq = D1I(s)->next_handshake_write_seq;
		D1I(s)->next_handshake_write_seq++;
	}

	dtls1_set_message_header_int(s, mt, len, D1I(s)->handshake_write_seq,
	    frag_off, frag_len);
}

/* don't actually do the writing, wait till the MTU has been retrieved */
static void
dtls1_set_message_header_int(SSL *s, unsigned char mt, unsigned long len,
    unsigned short seq_num, unsigned long frag_off, unsigned long frag_len)
{
	struct hm_header_st *msg_hdr = &D1I(s)->w_msg_hdr;

	msg_hdr->type = mt;
	msg_hdr->msg_len = len;
	msg_hdr->seq = seq_num;
	msg_hdr->frag_off = frag_off;
	msg_hdr->frag_len = frag_len;
}

static void
dtls1_fix_message_header(SSL *s, unsigned long frag_off, unsigned long frag_len)
{
	struct hm_header_st *msg_hdr = &D1I(s)->w_msg_hdr;

	msg_hdr->frag_off = frag_off;
	msg_hdr->frag_len = frag_len;
}

static unsigned char *
dtls1_write_message_header(SSL *s, unsigned char *p)
{
	struct hm_header_st *msg_hdr = &D1I(s)->w_msg_hdr;

	*p++ = msg_hdr->type;
	l2n3(msg_hdr->msg_len, p);

	s2n(msg_hdr->seq, p);
	l2n3(msg_hdr->frag_off, p);
	l2n3(msg_hdr->frag_len, p);

	return p;
}

unsigned int
dtls1_min_mtu(void)
{
	return (g_probable_mtu[(sizeof(g_probable_mtu) /
	    sizeof(g_probable_mtu[0])) - 1]);
}

static unsigned int
dtls1_guess_mtu(unsigned int curr_mtu)
{
	unsigned int i;

	if (curr_mtu == 0)
		return g_probable_mtu[0];

	for (i = 0; i < sizeof(g_probable_mtu) / sizeof(g_probable_mtu[0]); i++)
		if (curr_mtu > g_probable_mtu[i])
			return g_probable_mtu[i];

	return curr_mtu;
}

int
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)
{
	CBS header;
	uint32_t msg_len, frag_off, frag_len;
	uint16_t seq;
	uint8_t type;

	CBS_init(&header, data, sizeof(*msg_hdr));

	memset(msg_hdr, 0, sizeof(*msg_hdr));

	if (!CBS_get_u8(&header, &type))
		return 0;
	if (!CBS_get_u24(&header, &msg_len))
		return 0;
	if (!CBS_get_u16(&header, &seq))
		return 0;
	if (!CBS_get_u24(&header, &frag_off))
		return 0;
	if (!CBS_get_u24(&header, &frag_len))
		return 0;

	msg_hdr->type = type;
	msg_hdr->msg_len = msg_len;
	msg_hdr->seq = seq;
	msg_hdr->frag_off = frag_off;
	msg_hdr->frag_len = frag_len;

	return 1;
}

void
dtls1_get_ccs_header(unsigned char *data, struct ccs_header_st *ccs_hdr)
{
	memset(ccs_hdr, 0x00, sizeof(struct ccs_header_st));

	ccs_hdr->type = *(data++);
}

int
dtls1_shutdown(SSL *s)
{
	int ret;

	ret = ssl3_shutdown(s);
	return ret;
}
@


1.49
log
@Change SSLerror() back to taking two args, with the first one being an SSL *.
Make a table of "function codes" which maps the internal state of the SSL *
to something like a useful name so in a typical error in the connection you
know in what sort of place in the handshake things happened. (instead of
by arcane function name).
Add SSLerrorx() for when we don't have an SSL *
ok jsing@@ after us both being prodded by bluhm@@ to make it not terrible
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.48 2017/01/26 12:16:13 beck Exp $ */
d1170 3
a1172 3
unsigned char *
dtls1_set_message_header(SSL *s, unsigned char *p, unsigned char mt,
    unsigned long len, unsigned long frag_off, unsigned long frag_len)
a1181 2

	return p += DTLS1_HM_HEADER_LENGTH;
@


1.48
log
@Finish the fallout of the SSLerr->SSLerror cleanup to get rid of the ugly
line wraps that resulted
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.47 2017/01/26 10:40:21 beck Exp $ */
d413 1
a413 1
			SSLerror(SSL_R_UNEXPECTED_MESSAGE);
d478 1
a478 1
		SSLerror(SSL_R_EXCESSIVE_MESSAGE_SIZE);
d483 1
a483 1
		SSLerror(SSL_R_EXCESSIVE_MESSAGE_SIZE);
d495 1
a495 1
			SSLerror(ERR_R_BUF_LIB);
d509 1
a509 1
		SSLerror(SSL_R_EXCESSIVE_MESSAGE_SIZE);
d802 1
a802 1
		SSLerror(SSL_R_UNEXPECTED_MESSAGE);
d844 1
a844 1
			SSLerror(SSL_R_UNEXPECTED_MESSAGE);
d875 1
a875 1
		SSLerror(SSL3_AD_ILLEGAL_PARAMETER);
@


1.47
log
@Send the error function codes to rot in the depths of hell where they belong
We leave a single funciton code (0xFFF) to say "SSL_internal" so the public
API will not break, and we replace all internal use of the two argument
SSL_err() with the internal only SSL_error() that only takes a reason code.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.46 2017/01/23 13:36:12 jsing Exp $ */
d413 1
a413 2
			SSLerror(
			    SSL_R_UNEXPECTED_MESSAGE);
d478 1
a478 2
		SSLerror(
		    SSL_R_EXCESSIVE_MESSAGE_SIZE);
d483 1
a483 2
		SSLerror(
		    SSL_R_EXCESSIVE_MESSAGE_SIZE);
d509 1
a509 2
		SSLerror(
		    SSL_R_EXCESSIVE_MESSAGE_SIZE);
d802 1
a802 2
		SSLerror(
		    SSL_R_UNEXPECTED_MESSAGE);
d844 1
a844 2
			SSLerror(
			    SSL_R_UNEXPECTED_MESSAGE);
d875 1
a875 2
		SSLerror(
		    SSL3_AD_ILLEGAL_PARAMETER);
@


1.46
log
@Split most of SSL_METHOD out into an internal variant, which is opaque.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.45 2017/01/23 08:48:44 beck Exp $ */
d413 1
a413 1
			SSLerr(SSL_F_DTLS1_GET_MESSAGE,
d479 1
a479 1
		SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,
d485 1
a485 1
		SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,
d498 1
a498 1
			SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, ERR_R_BUF_LIB);
d512 1
a512 1
		SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,
d806 1
a806 1
		SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,
d849 1
a849 1
			SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,
d881 1
a881 1
		SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,
@


1.45
log
@send state and rstate from ssl_st into internal. There are accessors
so these should not be diddled with directly
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.44 2017/01/23 06:45:30 beck Exp $ */
d637 1
a637 1
			i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
d649 1
a649 1
	i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
d727 1
a727 1
			i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
d749 1
a749 1
			i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
d793 1
a793 1
	i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, wire,
d864 1
a864 1
		i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
@


1.44
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.43 2017/01/23 04:55:26 beck Exp $ */
d859 1
a859 1
	s->state = stn;
d918 1
a918 1
	if (s->state == a) {
d932 1
a932 1
		s->state = b;
@


1.43
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.42 2017/01/22 09:02:07 jsing Exp $ */
d226 1
a226 1
/* send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or SSL3_RT_CHANGE_CIPHER_SPEC) */
d256 2
a257 2
	if (s->init_off == 0  && type == SSL3_RT_HANDSHAKE)
		OPENSSL_assert(s->init_num ==
d260 2
a261 2
	if (s->write_hash)
		mac_size = EVP_MD_CTX_size(s->write_hash);
d265 3
a267 3
	if (s->enc_write_ctx &&
	    (EVP_CIPHER_mode( s->enc_write_ctx->cipher) & EVP_CIPH_CBC_MODE))
		blocksize = 2 * EVP_CIPHER_block_size(s->enc_write_ctx->cipher);
d272 1
a272 1
	while (s->init_num) {
d285 1
a285 1
		if (s->init_num > curr_mtu)
d288 1
a288 1
			len = s->init_num;
d293 4
a296 4
			if (s->init_off != 0) {
				OPENSSL_assert(s->init_off > DTLS1_HM_HEADER_LENGTH);
				s->init_off -= DTLS1_HM_HEADER_LENGTH;
				s->init_num += DTLS1_HM_HEADER_LENGTH;
d298 1
a298 1
				if (s->init_num > curr_mtu)
d301 1
a301 1
					len = s->init_num;
d308 1
a308 1
			    (unsigned char *)&s->init_buf->data[s->init_off]);
d314 1
a314 1
		    &s->init_buf->data[s->init_off], len);
d345 1
a345 1
				unsigned char *p = (unsigned char *)&s->init_buf->data[s->init_off];
d369 1
a369 1
			if (ret == s->init_num) {
d372 2
a373 2
					    s->init_buf->data,
					    (size_t)(s->init_off + s->init_num),
d376 1
a376 1
				s->init_off = 0;
d378 1
a378 1
				s->init_num = 0;
d382 2
a383 2
			s->init_off += ret;
			s->init_num -= ret;
d418 3
a420 3
		s->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;
		s->init_num = (int)S3I(s)->tmp.message_size;
		return s->init_num;
d434 1
a434 1
	p = (unsigned char *)s->init_buf->data;
d458 2
a459 2
	s->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;
	return s->init_num;
d496 1
a496 1
		if (!BUF_MEM_grow_clean(s->init_buf,
d526 2
a527 2
	 * (1) copy over the fragment to s->init_buf->data[]
	 * (2) update s->init_num
d552 1
a552 1
			unsigned char *p = (unsigned char *)s->init_buf->data + DTLS1_HM_HEADER_LENGTH;
d566 1
a566 1
		s->init_num = 0;
d584 2
a585 2
	if (max_len < (unsigned long)s->max_cert_list)
		return s->max_cert_list;
d788 1
a788 1
			s->init_num = frag_len;
d797 1
a797 1
		s->rwstate = SSL_READING;
d843 1
a843 1
			s->init_num = 0;
d862 1
a862 1
		unsigned char *p = (unsigned char *)s->init_buf->data + DTLS1_HM_HEADER_LENGTH;
d868 1
a868 1
			s->rwstate = SSL_READING;
d889 2
a890 2
	 * Note that s->init_num is *not* used as current offset in
	 * s->init_buf->data, but as a counter summing up fragments'
d894 1
a894 1
	s->init_num = frag_len;
d899 1
a899 1
	s->init_num = 0;
d919 1
a919 1
		p = (unsigned char *)s->init_buf->data;
d922 1
a922 1
		s->init_num = DTLS1_CCS_HEADER_LENGTH;
d924 1
a924 1
		s->init_off = 0;
d1025 1
a1025 1
	OPENSSL_assert(s->init_off == 0);
d1027 1
a1027 1
	frag = dtls1_hm_fragment_new(s->init_num, 0);
d1031 1
a1031 1
	memcpy(frag->fragment, s->init_buf->data, s->init_num);
d1036 1
a1036 1
		    DTLS1_CCS_HEADER_LENGTH : 3) == (unsigned int)s->init_num);
d1039 1
a1039 1
		    DTLS1_HM_HEADER_LENGTH == (unsigned int)s->init_num);
d1050 2
a1051 2
	frag->msg_header.saved_retransmit_state.enc_write_ctx = s->enc_write_ctx;
	frag->msg_header.saved_retransmit_state.write_hash = s->write_hash;
d1085 2
a1086 2
	  OPENSSL_assert(s->init_num == 0);
	  OPENSSL_assert(s->init_off == 0);
d1111 1
a1111 1
	memcpy(s->init_buf->data, frag->fragment,
d1113 1
a1113 1
	s->init_num = frag->msg_header.msg_len + header_length;
d1120 2
a1121 2
	saved_state.enc_write_ctx = s->enc_write_ctx;
	saved_state.write_hash = s->write_hash;
d1128 2
a1129 2
	s->enc_write_ctx = frag->msg_header.saved_retransmit_state.enc_write_ctx;
	s->write_hash = frag->msg_header.saved_retransmit_state.write_hash;
d1145 2
a1146 2
	s->enc_write_ctx = saved_state.enc_write_ctx;
	s->write_hash = saved_state.write_hash;
@


1.42
log
@Move most of the SSL3_STATE fields to internal - the ones that remain are
known to be used by ports.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.41 2017/01/22 07:16:38 beck Exp $ */
d370 2
a371 2
				if (s->msg_callback)
					s->msg_callback(1, s->version, type,
d374 1
a374 1
					    s, s->msg_callback_arg);
d448 3
a450 3
	if (s->msg_callback)
		s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, msg_len,
		    s, s->msg_callback_arg);
d837 2
a838 2
			if (s->msg_callback)
				s->msg_callback(0, s->version,
d841 1
a841 1
				    s->msg_callback_arg);
@


1.41
log
@Move most of DTLS1_STATE to internal.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.40 2016/12/06 13:38:11 jsing Exp $ */
d406 1
a406 1
	 * s3->tmp is used to store messages that are unexpected, caused
d409 3
a411 3
	if (s->s3->tmp.reuse_message) {
		s->s3->tmp.reuse_message = 0;
		if ((mt >= 0) && (s->s3->tmp.message_type != mt)) {
d419 1
a419 1
		s->init_num = (int)s->s3->tmp.message_size;
d502 1
a502 1
		s->s3->tmp.message_size = msg_len;
d504 1
a504 1
		s->s3->tmp.message_type = msg_hdr->type;
d908 2
a909 2
 * ssl->s3->read_sequence		zero
 * ssl->s3->read_mac_secret		re-init
d1135 4
a1138 4
		memcpy(save_write_sequence, s->s3->write_sequence,
		    sizeof(s->s3->write_sequence));
		memcpy(s->s3->write_sequence, D1I(s)->last_write_sequence,
		    sizeof(s->s3->write_sequence));
d1152 4
a1155 4
		memcpy(D1I(s)->last_write_sequence, s->s3->write_sequence,
		    sizeof(s->s3->write_sequence));
		memcpy(s->s3->write_sequence, save_write_sequence,
		    sizeof(s->s3->write_sequence));
@


1.40
log
@Now that ssl3_send_{client,server}_certificate() are using the common
handshake functions, we can remove more copied code from DTLS.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.39 2016/03/06 14:52:15 beck Exp $ */
d235 1
a235 1
	if (s->d1->mtu < dtls1_min_mtu() &&
d237 1
a237 1
		s->d1->mtu = BIO_ctrl(SSL_get_wbio(s),
d245 3
a247 3
		if (s->d1->mtu < dtls1_min_mtu()) {
			s->d1->mtu = 0;
			s->d1->mtu = dtls1_guess_mtu(s->d1->mtu);
d249 1
a249 1
			    s->d1->mtu, NULL);
d253 1
a253 1
	OPENSSL_assert(s->d1->mtu >= dtls1_min_mtu());
d258 1
a258 1
		    (int)s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);
d273 1
a273 1
		curr_mtu = s->d1->mtu - BIO_wpending(SSL_get_wbio(s)) -
d281 1
a281 1
			curr_mtu = s->d1->mtu - DTLS1_RT_HEADER_LENGTH -
d325 1
a325 1
				s->d1->mtu = BIO_ctrl(SSL_get_wbio(s),
d339 1
a339 1
			    !s->d1->retransmitting) {
d346 1
a346 1
				const struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;
d423 1
a423 1
	msg_hdr = &s->d1->r_msg_hdr;
d455 2
a456 2
	if (!s->d1->listen)
		s->d1->handshake_read_seq++;
d490 1
a490 1
	if ( s->d1->r_msg_hdr.frag_off == 0) /* first fragment */
d503 1
a503 1
		s->d1->r_msg_hdr.msg_len = msg_len;
d505 3
a507 3
		s->d1->r_msg_hdr.type = msg_hdr->type;
		s->d1->r_msg_hdr.seq = msg_hdr->seq;
	} else if (msg_len != s->d1->r_msg_hdr.msg_len) {
d534 1
a534 1
	item = pqueue_peek(s->d1->buffered_messages);
d544 1
a544 1
	if (s->d1->handshake_read_seq == frag->msg_header.seq) {
d546 1
a546 1
		pqueue_pop(s->d1->buffered_messages);
d611 1
a611 1
	item = pqueue_find(s->d1->buffered_messages, seq64be);
d676 1
a676 1
		pqueue_insert(s->d1->buffered_messages, item);
d705 1
a705 1
	item = pqueue_find(s->d1->buffered_messages, seq64be);
d720 3
a722 3
	if (msg_hdr->seq <= s->d1->handshake_read_seq ||
	    msg_hdr->seq > s->d1->handshake_read_seq + 10 || item != NULL ||
	    (s->d1->handshake_read_seq == 0 &&
d763 1
a763 1
		pqueue_insert(s->d1->buffered_messages, item);
d817 2
a818 2
	if (msg_hdr.seq != s->d1->handshake_read_seq &&
	    !(s->d1->listen && msg_hdr.seq == 1))
d828 1
a828 1
	if (!s->server && s->d1->r_msg_hdr.frag_off == 0 &&
d921 1
a921 1
		s->d1->handshake_write_seq = s->d1->next_handshake_write_seq;
d927 1
a927 1
		    s->d1->handshake_write_seq, 0, 0);
d1034 1
a1034 1
		OPENSSL_assert(s->d1->w_msg_hdr.msg_len +
d1038 1
a1038 1
		OPENSSL_assert(s->d1->w_msg_hdr.msg_len +
d1042 3
a1044 3
	frag->msg_header.msg_len = s->d1->w_msg_hdr.msg_len;
	frag->msg_header.seq = s->d1->w_msg_hdr.seq;
	frag->msg_header.type = s->d1->w_msg_hdr.type;
d1046 1
a1046 1
	frag->msg_header.frag_len = s->d1->w_msg_hdr.msg_len;
d1053 1
a1053 1
	frag->msg_header.saved_retransmit_state.epoch = s->d1->w_epoch;
d1123 1
a1123 1
	saved_state.epoch = s->d1->w_epoch;
d1125 1
a1125 1
	s->d1->retransmitting = 1;
d1131 1
a1131 1
	s->d1->w_epoch = frag->msg_header.saved_retransmit_state.epoch;
d1137 1
a1137 1
		memcpy(s->s3->write_sequence, s->d1->last_write_sequence,
d1148 1
a1148 1
	s->d1->w_epoch = saved_state.epoch;
d1152 1
a1152 1
		memcpy(s->d1->last_write_sequence, s->s3->write_sequence,
d1158 1
a1158 1
	s->d1->retransmitting = 0;
d1182 3
a1184 3
	if (frag_off == 0 && !s->d1->listen) {
		s->d1->handshake_write_seq = s->d1->next_handshake_write_seq;
		s->d1->next_handshake_write_seq++;
d1187 1
a1187 1
	dtls1_set_message_header_int(s, mt, len, s->d1->handshake_write_seq,
d1198 1
a1198 1
	struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;
d1210 1
a1210 1
	struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;
d1219 1
a1219 1
	struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;
@


1.39
log
@Make sure stdio functions don't end up in the library, from miod@@
ok doug@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.38 2015/09/11 18:08:21 jsing Exp $ */
a936 74
}

static int
dtls1_add_cert_to_buf(BUF_MEM *buf, unsigned long *l, X509 *x)
{
	int n;
	unsigned char *p;

	n = i2d_X509(x, NULL);
	if (!BUF_MEM_grow_clean(buf, n + (*l) + 3)) {
		SSLerr(SSL_F_DTLS1_ADD_CERT_TO_BUF, ERR_R_BUF_LIB);
		return 0;
	}
	p = (unsigned char *)&(buf->data[*l]);
	l2n3(n, p);
	i2d_X509(x, &p);
	*l += n + 3;

	return 1;
}

unsigned long
dtls1_output_cert_chain(SSL *s, X509 *x)
{
	unsigned char *p;
	int i;
	unsigned long l = 3 + DTLS1_HM_HEADER_LENGTH;
	BUF_MEM *buf;

	/* TLSv1 sends a chain with nothing in it, instead of an alert */
	buf = s->init_buf;
	if (!BUF_MEM_grow_clean(buf, 10)) {
		SSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN, ERR_R_BUF_LIB);
		return (0);
	}
	if (x != NULL) {
		X509_STORE_CTX xs_ctx;

		if (!X509_STORE_CTX_init(&xs_ctx, s->ctx->cert_store,
		    x, NULL)) {
			SSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN, ERR_R_X509_LIB);
			return (0);
		}

		X509_verify_cert(&xs_ctx);
		/* Don't leave errors in the queue */
		ERR_clear_error();
		for (i = 0; i < sk_X509_num(xs_ctx.chain); i++) {
			x = sk_X509_value(xs_ctx.chain, i);

			if (!dtls1_add_cert_to_buf(buf, &l, x)) {
				X509_STORE_CTX_cleanup(&xs_ctx);
				return 0;
			}
		}
		X509_STORE_CTX_cleanup(&xs_ctx);
	}
	/* Thawte special :-) */
	for (i = 0; i < sk_X509_num(s->ctx->extra_certs); i++) {
		x = sk_X509_value(s->ctx->extra_certs, i);
		if (!dtls1_add_cert_to_buf(buf, &l, x))
			return 0;
	}

	l -= (3 + DTLS1_HM_HEADER_LENGTH);

	p = (unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH]);
	l2n3(l, p);
	l += 3;
	p = (unsigned char *)&(buf->data[0]);
	p = dtls1_set_message_header(s, p, SSL3_MT_CERTIFICATE, l, 0, l);

	l += DTLS1_HM_HEADER_LENGTH;
	return (l);
@


1.38
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.37 2015/09/11 16:28:37 jsing Exp $ */
d1017 1
d1020 1
d1076 1
d1078 1
d1170 1
d1172 1
@


1.37
log
@Replace dtls1_send_finished() with ssl3_send_finished() - they're now
both essentially the same (in fact DTLS benefits from improvements
previously made to the ssl3_send_finished() function).

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.36 2015/09/11 15:59:21 jsing Exp $ */
d366 1
a366 1
				ssl3_finish_mac(s, p, xlen);
d447 1
a447 1
	ssl3_finish_mac(s, p, msg_len);
@


1.36
log
@Convert dtls1_send_finished() and ssl3_send_finished() to
ssl3_handshake_msg_start()/ssl3_handshake_msg_finish().

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.35 2015/09/10 17:57:50 jsing Exp $ */
a902 41
}

int
dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen)
{
	unsigned char *p;
	int i;
	unsigned long l;

	if (s->state == a) {
		p = ssl3_handshake_msg_start(s, SSL3_MT_FINISHED);

		i = s->method->ssl3_enc->final_finish_mac(s, sender, slen,
		    s->s3->tmp.finish_md);
		s->s3->tmp.finish_md_len = i;
		memcpy(p, s->s3->tmp.finish_md, i);
		p += i;
		l = i;

		/*
		 * Copy the finished so we can use it for
		 * renegotiation checks
		 */
		if (s->type == SSL_ST_CONNECT) {
			OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
			memcpy(s->s3->previous_client_finished,
			    s->s3->tmp.finish_md, i);
			s->s3->previous_client_finished_len = i;
		} else {
			OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
			memcpy(s->s3->previous_server_finished,
			    s->s3->tmp.finish_md, i);
			s->s3->previous_server_finished_len = i;
		}

		ssl3_handshake_msg_finish(s, l);

		s->state = b;
	}

	return (ssl3_handshake_write(s));
@


1.35
log
@Remove support for DTLS_BAD_VER. We do not support non-standard and
incomplete implementations just so that we can interoperate with products
from vendors who have not bothered to fix things in the last ~10 years.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.34 2015/07/19 20:32:18 doug Exp $ */
d908 1
a908 1
	unsigned char *p, *d;
d913 1
a913 2
		d = (unsigned char *)s->init_buf->data;
		p = &(d[DTLS1_HM_HEADER_LENGTH]);
d938 1
a938 6
		d = dtls1_set_message_header(s, d, SSL3_MT_FINISHED, l, 0, l);
		s->init_num = (int)l + DTLS1_HM_HEADER_LENGTH;
		s->init_off = 0;

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
d943 1
a943 2
	/* SSL3_ST_SEND_xxxxxx_HELLO_B */
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
@


1.34
log
@Allow *_free() functions in libssl to handle NULL input.

This mimics free()'s behavior which makes error handling simpler.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.33 2015/07/18 23:00:23 doug Exp $ */
d349 1
a349 2
				if (frag_off == 0 &&
				    s->version != DTLS1_BAD_VER) {
d443 3
a445 4
	if (s->version != DTLS1_BAD_VER) {
		p -= DTLS1_HM_HEADER_LENGTH;
		msg_len += DTLS1_HM_HEADER_LENGTH;
	}
a970 6

		if (s->version == DTLS1_BAD_VER) {
			s->d1->next_handshake_write_seq++;
			s2n(s->d1->handshake_write_seq, p);
			s->init_num += 2;
		}
@


1.33
log
@Convert dtls1_get_message_header to CBS and change to int.

Changed return value from void to int.  It should never return an error
given that the input length is not checked yet.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.32 2015/02/09 10:53:28 jsing Exp $ */
d212 2
@


1.32
log
@Jettison DTLS over SCTP.

OpenBSD does not have SCTP support and it sees little use in the wild.
OPENSSL_NO_SCTP is already specified via opensslfeatures.h, hence this
is a code removal only and symbols should remain unchanged.

ok beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.31 2014/12/14 16:07:26 jsing Exp $ */
d128 1
d802 3
a804 1
	if (i != DTLS1_HM_HEADER_LENGTH) {
a810 3
	/* parse the message fragment header */
	dtls1_get_message_header(wire, &msg_hdr);

d1375 1
a1375 1
void
d1378 25
a1402 3
	memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
	msg_hdr->type = *(data++);
	n2l3(data, msg_hdr->msg_len);
d1404 1
a1404 3
	n2s(data, msg_hdr->seq);
	n2l3(data, msg_hdr->frag_off);
	n2l3(data, msg_hdr->frag_len);
@


1.31
log
@Provide functions for starting, finishing and writing SSL handshake
messages. This will allow for removal of repeated/duplicated code.

Additionally, DTLS was written by wholesale copying of the SSL/TLS code,
with some DTLS specifics being added to the duplicated code. Since these
SSL handshake message functions know how to handle both SSL/TLS and DTLS,
upon conversion the duplicate versions will become identical (or close to),
at which point the DTLS versions can be removed and the SSL/TLS versions
used for both protocols.

Partially based on similar changes in OpenSSL.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.30 2014/11/16 14:12:47 jsing Exp $ */
a1399 12
#ifndef OPENSSL_NO_SCTP
	if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
	    !(s->shutdown & SSL_SENT_SHUTDOWN)) {
		ret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));
		if (ret < 0)
			return -1;

		if (ret == 0)
			BIO_ctrl(SSL_get_wbio(s),
			    BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN, 1, NULL);
	}
#endif
a1400 3
#ifndef OPENSSL_NO_SCTP
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN, 0, NULL);
#endif
@


1.30
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.29 2014/10/18 16:13:16 jsing Exp $ */
d1142 2
@


1.29
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.28 2014/08/08 05:06:56 guenther Exp $ */
d117 1
d119 1
a119 1
#include <stdio.h>
d121 1
d123 1
a124 1
#include <openssl/evp.h>
@


1.28
log
@Fix CVE-2014-3507, avoid allocating and then leaking a fresh fragment
structure when a zero-length fragment is received.

Based on
https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=d0a4b7d1a2948fce38515b8d862f43e7ba0ebf74

diff by miod@@, ok guenther@@ bcook@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.27 2014/08/07 20:24:12 guenther Exp $ */
a120 1
#include <openssl/rand.h>
@


1.27
log
@Fix CVE-2014-3506, DTLS handshake message size checks.  From
https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=1250f12613b61758675848f6600ebd914ccd7636
with comment/whitespace style tweaks

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.26 2014/08/07 20:02:23 miod Exp $ */
d600 5
d733 1
a733 1
		if (frag_len && frag_len < msg_hdr->msg_len)
@


1.26
log
@Oops, revert changes commited by mistake. The previous commit was supposed
to only apply to s23_srvr.c.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.24 2014/07/10 08:51:14 tedu Exp $ */
d571 15
d594 1
a594 1
	unsigned long frag_len = msg_hdr->frag_len, max_len;
d596 2
a597 14
	if ((msg_hdr->frag_off + frag_len) > msg_hdr->msg_len)
		goto err;

	/*
	 * Determine maximum allowed message size. Depends on (user set)
	 * maximum certificate length, but 16k is minimum.
	 */
	if (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH <
	    s->max_cert_list)
		max_len = s->max_cert_list;
	else
		max_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;

	if ((msg_hdr->frag_off + frag_len) > max_len)
d730 3
@


1.25
log
@When you expect a function to return a particular value, don't put a comment
saying that you expect it to return that value and compare it against zero
because it is supposedly faster, for this leads to bugs (especially given the
high rate of sloppy cut'n'paste within ssl3 and dtls1 routines in this
library).

Instead, compare for the exact value it ought to return upon success.

ok deraadt@@
@
text
@a905 1
		OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
d916 1
d921 1
@


1.24
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.23 2014/07/10 08:25:00 guenther Exp $ */
d906 1
a916 1
			OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
a920 1
			OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
@


1.23
log
@KNF comments, reflowing and moving out of the middle of argument lists in
places

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.22 2014/07/02 20:45:26 miod Exp $ */
a946 1
 * ssl->session->read_compression	assign
a1161 1
	frag->msg_header.saved_retransmit_state.compress = s->compress;
a1229 1
	saved_state.compress = s->compress;
a1237 1
	s->compress = frag->msg_header.saved_retransmit_state.compress;
a1254 1
	s->compress = saved_state.compress;
@


1.22
log
@Memory leak in error path of the day, from clang via dhill@@bitrig;
ok dhill@@bitrig
@
text
@d1 1
a1 1
/* $OpenBSD: d1_both.c,v 1.21 2014/06/12 15:49:31 deraadt Exp $ */
d236 5
a240 2
		/* I've seen the kernel return bogus numbers when it doesn't know
		 * (initial write), so just make sure we have a reasonable number */
d312 6
a317 5
			/* might need to update MTU here, but we don't know
			 * which previous packet caused the failure -- so can't
			 * really retransmit anything.  continue as if everything
			 * is fine and wait for an alert to handle the
			 * retransmit
d327 5
a331 2
			/* bad if this assert fails, only part of the handshake
			 * message got sent.  but why would this happen? */
d336 5
a340 2
				/* should not be done for 'Hello Request's, but in that case
				 * we'll ignore the result anyway */
d347 4
a350 2
					/* reconstruct message header is if it
					 * is being sent in single fragment */
d388 2
a389 1
/* Obtain handshake message of message type 'mt' (any if mt == -1),
d402 4
a405 2
	/* s3->tmp is used to store messages that are unexpected, caused
	 * by the absence of an optional handshake message */
d490 4
a493 2
		/* msg_len is limited to 2^24, but is effectively checked
		 * against max above */
d506 4
a509 2
		/* They must be playing with us! BTW, failure to enforce
		 * upper limit would open possibility for buffer overrun. */
d521 2
a522 1
	/* (0) check whether the desired fragment is available
d584 2
a585 1
	/* Determine maximum allowed message size. Depends on (user set)
d619 2
a620 1
	/* If message is already reassembled, this must be a
d697 2
a698 1
	/* If we already have an entry and this one is a fragment,
d704 2
a705 1
	/* Discard the message if sequence number was already there, is
d818 2
a819 1
		/* The server may always send 'Hello Request' messages --
d822 2
a823 1
		 * 'Finished' MAC. */
d863 4
a866 2
	/* XDTLS:  an incorrectly formatted fragment should cause the
	 * handshake to fail */
d876 2
a877 1
	/* Note that s->init_num is *not* used as current offset in
d880 2
a881 1
	 * length, we assume we have got all the fragments. */
d911 2
a912 1
		/* Copy the finished so we can use it for
d941 2
a942 1
/* for these 2 messages, we need to
d1066 4
a1069 2
		/* not a timeout, none of our business,
		   let higher layers handle this.  in fact it's probably an error */
d1085 10
a1094 7
	/* The index of the retransmission queue actually is the message sequence number,
	 * since the queue only contains messages of a single handshake. However, the
	 * ChangeCipherSpec has no message sequence number and so using only the sequence
	 * will result in the CCS and Finished having the same index. To prevent this,
	 * the sequence number is multiplied by 2. In case of a CCS 1 is subtracted.
	 * This does not only differ CSS and Finished, it also maintains the order of the
	 * index (important for priority queues) and fits in the unsigned short variable.
d1132 4
a1135 2
	/* this function is called immediately after a message has
	 * been serialized */
@


1.21
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d612 2
a613 1
		return DTLS1_HM_FRAGMENT_RETRY;
@


1.20
log
@Do not recurse when a 'Hello Request' message is received while getting
DTLS fragments. A stream of 'Hello Request' messages will result in
infinite recursion, eventually crashing the DTLS client or server.

Fixes CVE-2014-0221, from OpenSSL.

Reported to OpenSSL by Imre Rad.
@
text
@d1 1
a1 1
/* ssl/d1_both.c */
@


1.19
log
@Avoid a buffer overflow that can be triggered by sending specially crafted
DTLS fragments.

Fix for CVE-2014-0195, from OpenSSL.

Reported to OpenSSL by Juri Aedla.

ok deraadt@@ beck@@
@
text
@d746 1
d805 1
a805 1
			return dtls1_get_message_fragment(s, st1, stn, max, ok);
@


1.18
log
@BUF_MEM_grow_clean() takes a size_t as the size argument. Remove false comments
mentioning it's an int, bogus (int) casts and bounds checks against INT_MAX
(BUF_MEM_grow_clean has its own integer bounds checks).

ok deraadt@@
@
text
@d589 1
a589 1
	} else
d591 6
@


1.17
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@d949 1
a949 1
	if (!BUF_MEM_grow_clean(buf, (int)(n + (*l) + 3))) {
@


1.16
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@a148 8
#if 0
#define RSMBLY_BITMASK_PRINT(bitmask, msg_len) { \
			long ii; \
			printf("bitmask: "); for (ii = 0; ii < (msg_len); ii++) \
			printf("%d ", (bitmask[ii >> 3] & (1 << (ii & 7))) >> (ii & 7)); \
			printf("\n"); }
#endif

a244 22
#if 0
	mtu = s->d1->mtu;

	fprintf(stderr, "using MTU = %d\n", mtu);

	mtu -= (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);

	curr_mtu = mtu - BIO_wpending(SSL_get_wbio(s));

	if (curr_mtu > 0)
		mtu = curr_mtu;
	else if (( ret = BIO_flush(SSL_get_wbio(s))) <= 0)
		return ret;

	if (BIO_wpending(SSL_get_wbio(s)) + s->init_num >= mtu) {
		ret = BIO_flush(SSL_get_wbio(s));
		if (ret <= 0)
			return ret;
		mtu = s->d1->mtu - (DTLS1_HM_HEADER_LENGTH +
		    DTLS1_RT_HEADER_LENGTH);
	}
#endif
a1036 13
#if 0 /* for now, each alert contains only one record number */
	item = pqueue_peek(state->rcvd_records);
	if (item ) {
		/* send an alert immediately for all the missing records */
	} else
#endif

#if 0  /* no more alert sending, just retransmit the last set of messages */
	if (state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s, SSL3_AL_WARNING,
		    DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif

a1130 6

#if 0
	fprintf(stderr, "buffered messge: \ttype = %xx\n", msg_buf->type);
	fprintf(stderr, "\t\t\t\t\tlen = %d\n", msg_buf->len);
	fprintf(stderr, "\t\t\t\t\tseq_num = %d\n", msg_buf->seq_num);
#endif
@


1.15
log
@Stop pulling pqueue.h into ssl_locl.h since only a small part of libssl
actually needs it. Instead, just include it in the files where it is
actually necessary.

Also remove standard includes from pqueue.h so that they are not available
as a side effect. Just add the two includes that are needed to pqueue.c.

ok miod@@
@
text
@d203 1
a203 2
			if (buf != NULL)
				free(buf);
d225 2
a226 4
	if (frag->fragment)
		free(frag->fragment);
	if (frag->reassembly)
		free(frag->reassembly);
@


1.14
log
@In dtls1_reassemble_fragment() and dtls1_process_out_of_seq_message(), in case
of error, make sure we do not free pitem which is still linked into the
pqueue.
In the same vain, only free `frag' if we allocated it in this function.

Help and ok beck@@
@
text
@d126 2
@


1.13
log
@Avoid a potential null pointer dereference by checking that we actually
managed to allocate a fragment, before trying to memcpy data into it.

ok miod@@
@
text
@d621 1
a621 1
		frag = (hm_fragment*) item->data;
d674 1
a674 1
	if (frag != NULL)
a675 2
	if (item != NULL)
		free(item);
d756 1
a756 1
	if (frag != NULL)
a757 2
	if (item != NULL)
		free(item);
@


1.12
log
@More KNF.
@
text
@d1140 2
@


1.11
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@d2 1
a2 1
/* 
d4 1
a4 1
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.  
d14 1
a14 1
 *    notice, this list of conditions and the following disclaimer. 
d65 1
a65 1
 * 
d72 1
a72 1
 * 
d79 1
a79 1
 * 
d94 1
a94 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d97 1
a97 1
 * 
d109 1
a109 1
 * 
d219 4
a222 2
		EVP_CIPHER_CTX_free(frag->msg_header.saved_retransmit_state.enc_write_ctx);
		EVP_MD_CTX_destroy(frag->msg_header.saved_retransmit_state.write_hash);
d240 2
a241 1
	if (s->d1->mtu < dtls1_min_mtu() && !(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU)) {
d251 1
a251 1
			s->d1->mtu, NULL);
d254 1
a254 1
#if 0 
d272 2
a273 1
		mtu = s->d1->mtu - (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);
d282 1
a282 1
	(int)s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);
d290 2
a291 2
		(EVP_CIPHER_mode( s->enc_write_ctx->cipher) & EVP_CIPH_CBC_MODE))
	blocksize = 2 * EVP_CIPHER_block_size(s->enc_write_ctx->cipher);
d306 1
a306 1
			mac_size - blocksize;
d329 1
a329 1
			len - DTLS1_HM_HEADER_LENGTH);
d331 2
a332 1
			dtls1_write_message_header(s, (unsigned char *)&s->init_buf->data[s->init_off]);
d344 1
a344 1
			 * retransmit 
d358 2
a359 1
			if (type == SSL3_RT_HANDSHAKE && ! s->d1->retransmitting) {
d366 2
a367 1
				if (frag_off == 0 && s->version != DTLS1_BAD_VER) {
d426 2
a427 1
			SSLerr(SSL_F_DTLS1_GET_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);
d483 2
a484 1
dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr, int max) {
d493 2
a494 1
		SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);
d499 2
a500 1
		SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);
d508 2
a509 1
		if (!BUF_MEM_grow_clean(s->init_buf, msg_len + DTLS1_HM_HEADER_LENGTH)) {
d522 2
a523 1
		SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);
a529 1

d563 1
a563 1
			frag->fragment, frag->msg_header.frag_len);
d584 2
a585 1
dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok) {
d598 2
a599 1
	if (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH < s->max_cert_list)
d632 1
a632 1
			        sizeof(devnull) : frag_len, 0);
d642 1
a642 1
	frag->fragment + msg_hdr->frag_off, frag_len, 0);
d647 1
a647 1
	(long)(msg_hdr->frag_off + frag_len));
d650 1
a650 1
	is_complete);
d684 2
a685 1
dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok) {
d714 2
a715 1
	    (s->d1->handshake_read_seq == 0 && msg_hdr->type == SSL3_MT_FINISHED)) {
d721 1
a721 1
			        sizeof(devnull) : frag_len, 0);
d784 1
a784 1
	DTLS1_HM_HEADER_LENGTH, 0);
d794 2
a795 1
		SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT, SSL_R_UNEXPECTED_MESSAGE);
d802 1
a802 1
	/* 
d808 2
a809 1
	if (msg_hdr.seq != s->d1->handshake_read_seq && !(s->d1->listen && msg_hdr.seq == 1))
d838 2
a839 1
			SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT, SSL_R_UNEXPECTED_MESSAGE);
d864 1
a864 1
	/* XDTLS:  an incorrectly formatted fragment should cause the 
d868 2
a869 1
		SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT, SSL3_AD_ILLEGAL_PARAMETER);
d901 2
a902 2
		i = s->method->ssl3_enc->final_finish_mac(s,
		    sender, slen, s->s3->tmp.finish_md);
d914 1
a914 1
			s->s3->tmp.finish_md, i);
d919 1
a919 1
			s->s3->tmp.finish_md, i);
d965 1
a965 1
		s->d1->handshake_write_seq, 0, 0);
d984 1
a984 1
	if (!BUF_MEM_grow_clean(buf,(int)(n + (*l) + 3))) {
d1013 2
a1014 1
		if (!X509_STORE_CTX_init(&xs_ctx, s->ctx->cert_store, x, NULL)) {
d1055 2
a1056 1
		fprintf( stderr, "invalid state reached %s:%d", __FILE__, __LINE__);
d1061 1
a1061 1
		/* not a timeout, none of our business, 
d1082 1
a1082 1
	DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
d1098 1
a1098 1
	 */	
d1113 2
a1114 1
	for (item = pqueue_next(&iter); item != NULL; item = pqueue_next(&iter)) {
d1118 2
a1119 2
		        frag->msg_header.seq, frag->msg_header.is_ccs), 0,
		        &found) <= 0 && found) {
d1135 1
a1135 1
	/* this function is called immediately after a message has 
d1145 2
a1146 1
		((s->version == DTLS1_VERSION) ? DTLS1_CCS_HEADER_LENGTH : 3) == (unsigned int)s->init_num);
d1149 1
a1149 1
		DTLS1_HM_HEADER_LENGTH == (unsigned int)s->init_num);
d1167 4
a1170 4
	seq64be[6] = (unsigned char)(dtls1_get_queue_priority(frag->msg_header.seq,
	frag->msg_header.is_ccs) >> 8);
	seq64be[7] = (unsigned char)(dtls1_get_queue_priority(frag->msg_header.seq,
	frag->msg_header.is_ccs));
d1227 1
a1227 1
	frag->msg_header.msg_len + header_length);
d1231 2
a1232 2
	frag->msg_header.msg_len, frag->msg_header.seq, 0,
	frag->msg_header.frag_len);
d1250 6
a1255 3
	if (frag->msg_header.saved_retransmit_state.epoch == saved_state.epoch - 1) {
		memcpy(save_write_sequence, s->s3->write_sequence, sizeof(s->s3->write_sequence));
		memcpy(s->s3->write_sequence, s->d1->last_write_sequence, sizeof(s->s3->write_sequence));
d1259 1
a1259 1
	SSL3_RT_CHANGE_CIPHER_SPEC : SSL3_RT_HANDSHAKE);
d1268 6
a1273 3
	if (frag->msg_header.saved_retransmit_state.epoch == saved_state.epoch - 1) {
		memcpy(s->d1->last_write_sequence, s->s3->write_sequence, sizeof(s->s3->write_sequence));
		memcpy(s->s3->write_sequence, save_write_sequence, sizeof(s->s3->write_sequence));
a1294 1

d1306 1
a1306 1
	frag_off, frag_len);
a1310 1

d1313 2
a1314 3
dtls1_set_message_header_int(SSL *s, unsigned char mt,
    unsigned long len, unsigned short seq_num, unsigned long frag_off,
unsigned long frag_len)
d1326 1
a1326 2
dtls1_fix_message_header(SSL *s, unsigned long frag_off,
    unsigned long frag_len)
d1353 1
a1353 1
	sizeof(g_probable_mtu[0])) - 1]);
d1364 1
a1364 1
	for (i = 0; i < sizeof(g_probable_mtu)/sizeof(g_probable_mtu[0]); i++)
d1372 2
a1373 1
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr) {
d1384 2
a1385 1
dtls1_get_ccs_header(unsigned char *data, struct ccs_header_st *ccs_hdr) {
d1395 1
d1404 2
a1405 1
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN, 1, NULL);
@


1.10
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d182 1
a182 1
	frag = (hm_fragment *)malloc(sizeof(hm_fragment));
d187 1
a187 1
		buf = (unsigned char *)malloc(frag_len);
d199 1
a199 1
		bitmask = (unsigned char *)malloc(RSMBLY_BITMASK_SIZE(frag_len));
@


1.9
log
@fix a few bugs observed on http://www.viva64.com/en/b/0250/
ok krw miod
@
text
@d182 1
a182 1
	frag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));
d187 1
a187 1
		buf = (unsigned char *)OPENSSL_malloc(frag_len);
d189 1
a189 1
			OPENSSL_free(frag);
d199 1
a199 1
		bitmask = (unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
d202 2
a203 2
				OPENSSL_free(buf);
			OPENSSL_free(frag);
d223 1
a223 1
		OPENSSL_free(frag->fragment);
d225 2
a226 2
		OPENSSL_free(frag->reassembly);
	OPENSSL_free(frag);
d639 1
a639 1
		OPENSSL_free(frag->reassembly);
d663 1
a663 1
		OPENSSL_free(item);
d745 1
a745 1
		OPENSSL_free(item);
@


1.8
log
@correct cases of code occuring directly after goto/break/return
ok miod@@ guenther@@
@
text
@a1215 1
	saved_state.epoch = s->d1->w_epoch;
@


1.7
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@d650 1
a651 1
			i = -1;
@


1.6
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a1043 3
#ifndef OPENSSL_NO_HEARTBEATS
	if (!SSL_in_init(s) && !s->tlsext_hb_pending)  /* done, no need to send a retransmit */
#else
a1044 1
#endif
a1384 149

#ifndef OPENSSL_NO_HEARTBEATS
int
dtls1_process_heartbeat(SSL *s)
{
	unsigned char *p = &s->s3->rrec.data[0], *pl;
	unsigned short hbtype;
	unsigned int payload;
	unsigned int padding = 16; /* Use minimum padding */

	if (s->msg_callback)
		s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
		    &s->s3->rrec.data[0], s->s3->rrec.length,
		    s, s->msg_callback_arg);

	/* Read type and payload length first */
	if (1 + 2 + 16 > s->s3->rrec.length)
		return 0; /* silently discard */
	hbtype = *p++;
	n2s(p, payload);
	if (1 + 2 + payload + 16 > s->s3->rrec.length)
		return 0; /* silently discard per RFC 6520 sec. 4 */
	pl = p;

	if (hbtype == TLS1_HB_REQUEST) {
		unsigned char *buffer, *bp;
		unsigned int write_length = 1 /* heartbeat type */ +
		    2 /* heartbeat length */ +
		    payload + padding;
		int r;

		if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
			return 0;

		/* Allocate memory for the response, size is 1 byte
		 * message type, plus 2 bytes payload length, plus
		 * payload, plus padding
		 */
		buffer = OPENSSL_malloc(write_length);
		bp = buffer;

		/* Enter response type, length and copy payload */
		*bp++ = TLS1_HB_RESPONSE;
		s2n(payload, bp);
		memcpy(bp, pl, payload);
		bp += payload;
		/* Random padding */
		RAND_pseudo_bytes(bp, padding);

		r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);

		if (r >= 0 && s->msg_callback)
			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
			    buffer, write_length,
			    s, s->msg_callback_arg);

		OPENSSL_free(buffer);

		if (r < 0)
			return r;
	} else if (hbtype == TLS1_HB_RESPONSE) {
		unsigned int seq;

		/* We only send sequence numbers (2 bytes unsigned int),
		 * and 16 random bytes, so we just try to read the
		 * sequence number */
		n2s(pl, seq);

		if (payload == 18 && seq == s->tlsext_hb_seq) {
			dtls1_stop_timer(s);
			s->tlsext_hb_seq++;
			s->tlsext_hb_pending = 0;
		}
	}

	return 0;
}

int
dtls1_heartbeat(SSL *s)
{
	unsigned char *buf, *p;
	int ret;
	unsigned int payload = 18; /* Sequence number + random bytes */
	unsigned int padding = 16; /* Use minimum padding */

	/* Only send if peer supports and accepts HB requests... */
	if (!(s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED) ||
		s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_SEND_REQUESTS) {
		SSLerr(SSL_F_DTLS1_HEARTBEAT, SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT);
		return -1;
	}

	/* ...and there is none in flight yet... */
	if (s->tlsext_hb_pending) {
		SSLerr(SSL_F_DTLS1_HEARTBEAT, SSL_R_TLS_HEARTBEAT_PENDING);
		return -1;
	}

	/* ...and no handshake in progress. */
	if (SSL_in_init(s) || s->in_handshake) {
		SSLerr(SSL_F_DTLS1_HEARTBEAT, SSL_R_UNEXPECTED_MESSAGE);
		return -1;
	}

	/* Check if padding is too long, payload and padding
	 * must not exceed 2^14 - 3 = 16381 bytes in total.
	 */
	OPENSSL_assert(payload + padding <= 16381);

	/* Create HeartBeat message, we just use a sequence number
	 * as payload to distuingish different messages and add
	 * some random stuff.
	 *  - Message Type, 1 byte
	 *  - Payload Length, 2 bytes (unsigned int)
	 *  - Payload, the sequence number (2 bytes uint)
	 *  - Payload, random bytes (16 bytes uint)
	 *  - Padding
	 */
	buf = OPENSSL_malloc(1 + 2 + payload + padding);
	p = buf;
	/* Message Type */
	*p++ = TLS1_HB_REQUEST;
	/* Payload length (18 bytes here) */
	s2n(payload, p);
	/* Sequence number */
	s2n(s->tlsext_hb_seq, p);
	/* 16 random bytes */
	RAND_pseudo_bytes(p, 16);
	p += 16;
	/* Random padding */
	RAND_pseudo_bytes(p, padding);

	ret = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buf, 3 + payload + padding);
	if (ret >= 0) {
		if (s->msg_callback)
			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
		buf, 3 + payload + padding,
		s, s->msg_callback_arg);

		dtls1_start_timer(s);
		s->tlsext_hb_pending = 1;
	}

	OPENSSL_free(buf);

	return ret;
}
#endif
@


1.5
log
@Flense a variety of windows support stuff, and a strange gettimeofday function.
ok deraadt@@
@
text
@d155 6
a160 2
static unsigned char bitmask_start_values[] = {0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80};
static unsigned char bitmask_end_values[]   = {0xff, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f};
d166 3
a168 4
static void dtls1_fix_message_header(SSL *s, unsigned long frag_off, 
	unsigned long frag_len);
static unsigned char *dtls1_write_message_header(SSL *s,
	unsigned char *p);
d170 4
a173 4
	unsigned long len, unsigned short seq_num, unsigned long frag_off, 
	unsigned long frag_len);
static long dtls1_get_message_fragment(SSL *s, int st1, int stn, 
	long max, int *ok);
d177 1
a177 1
	{
d183 1
a183 1
	if ( frag == NULL)
d186 1
a186 2
	if (frag_len)
		{
d188 1
a188 2
		if ( buf == NULL)
			{
a190 1
			}
d192 1
d198 1
a198 2
	if (reassembly)
		{
d200 3
a202 3
		if (bitmask == NULL)
			{
			if (buf != NULL) OPENSSL_free(buf);
d205 1
a205 1
			}
d207 1
a207 1
		}
d212 1
a212 1
	}
d216 1
a216 1
	{
d218 1
a218 2
	if (frag->msg_header.is_ccs)
		{
d221 5
a225 3
		}
	if (frag->fragment) OPENSSL_free(frag->fragment);
	if (frag->reassembly) OPENSSL_free(frag->reassembly);
d227 1
a227 1
	}
d230 3
a232 2
int dtls1_do_write(SSL *s, int type)
	{
d238 3
a240 4
	if (s->d1->mtu < dtls1_min_mtu() && !(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU))
		{
		s->d1->mtu = 
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);
d244 1
a244 2
		if (s->d1->mtu < dtls1_min_mtu())
			{
d247 2
a248 3
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SET_MTU, 
				s->d1->mtu, NULL);
			}
d250 1
d260 1
a260 1
	if ( curr_mtu > 0)
d262 1
a262 1
	else if ( ( ret = BIO_flush(SSL_get_wbio(s))) <= 0)
d265 1
a265 2
	if ( BIO_wpending(SSL_get_wbio(s)) + s->init_num >= mtu)
		{
d267 1
a267 1
		if ( ret <= 0)
d270 1
a270 1
		}
d273 2
a274 1
	OPENSSL_assert(s->d1->mtu >= dtls1_min_mtu());  /* should have something reasonable now */
d276 3
a278 3
	if ( s->init_off == 0  && type == SSL3_RT_HANDSHAKE)
		OPENSSL_assert(s->init_num == 
			(int)s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);
d285 1
a285 1
	if (s->enc_write_ctx && 
d287 1
a287 1
		blocksize = 2 * EVP_CIPHER_block_size(s->enc_write_ctx->cipher);
d292 3
a294 4
	while( s->init_num)
		{
		curr_mtu = s->d1->mtu - BIO_wpending(SSL_get_wbio(s)) - 
			DTLS1_RT_HEADER_LENGTH - mac_size - blocksize;
d296 1
a296 2
		if ( curr_mtu <= DTLS1_HM_HEADER_LENGTH)
			{
d299 1
a299 1
			if ( ret <= 0)
d302 2
a303 2
				mac_size - blocksize;
			}
d305 1
a305 1
		if ( s->init_num > curr_mtu)
d312 2
a313 4
		if ( type == SSL3_RT_HANDSHAKE)
			{
			if ( s->init_off != 0)
				{
d318 1
a318 1
				if ( s->init_num > curr_mtu)
d322 1
a322 1
				}
d324 2
a325 2
			dtls1_fix_message_header(s, frag_off, 
				len - DTLS1_HM_HEADER_LENGTH);
d330 1
a330 1
			}
d332 3
a334 4
		ret=dtls1_write_bytes(s,type,&s->init_buf->data[s->init_off],
			len);
		if (ret < 0)
			{
d341 2
a342 2
			if ( BIO_ctrl(SSL_get_wbio(s),
				BIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL) > 0 )
d344 1
a344 1
					BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);
d346 2
a347 4
				return(-1);
			}
		else
			{
d353 1
a353 2
			if (type == SSL3_RT_HANDSHAKE && ! s->d1->retransmitting)
				{
d360 1
a360 2
				if (frag_off == 0 && s->version != DTLS1_BAD_VER)
					{
d364 5
a368 5
					l2n3(msg_hdr->msg_len,p);
					s2n (msg_hdr->seq,p);
					l2n3(0,p);
					l2n3(msg_hdr->msg_len,p);
					p  -= DTLS1_HM_HEADER_LENGTH;
d370 2
a371 4
					}
				else
					{
					p  += DTLS1_HM_HEADER_LENGTH;
d373 1
a373 1
					}
d376 1
a376 1
				}
d378 1
a378 2
			if (ret == s->init_num)
				{
d380 4
a383 3
					s->msg_callback(1, s->version, type, s->init_buf->data, 
						(size_t)(s->init_off + s->init_num), s, 
						s->msg_callback_arg);
d385 2
a386 1
				s->init_off = 0;  /* done writing this message */
d389 4
a392 4
				return(1);
				}
			s->init_off+=ret;
			s->init_num-=ret;
a393 1
			}
a394 1
	return(0);
d396 2
d405 3
a407 2
long dtls1_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)
	{
d415 5
a419 7
	if (s->s3->tmp.reuse_message)
		{
		s->s3->tmp.reuse_message=0;
		if ((mt >= 0) && (s->s3->tmp.message_type != mt))
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);
d421 2
a422 2
			}
		*ok=1;
d426 1
a426 1
		}
d433 2
a434 2
	if ( i == DTLS1_HM_BAD_FRAGMENT ||
		i == DTLS1_HM_FRAGMENT_RETRY)  /* bad fragment received */
d436 1
a436 1
	else if ( i <= 0 && !*ok)
d444 4
a447 4
	l2n3(msg_len,p);
	s2n (msg_hdr->seq,p);
	l2n3(0,p);
	l2n3(msg_len,p);
d449 1
a449 1
		p       -= DTLS1_HM_HEADER_LENGTH;
d455 2
a456 3
		s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
			p, msg_len,
			s, s->msg_callback_arg);
d468 1
a468 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d471 1
a471 1
	}
d474 3
a476 3
static int dtls1_preprocess_fragment(SSL *s,struct hm_header_st *msg_hdr,int max)
	{
	size_t frag_off,frag_len,msg_len;
d478 1
a478 1
	msg_len  = msg_hdr->msg_len;
d483 2
a484 3
	if ( (frag_off+frag_len) > msg_len)
		{
		SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);
d486 1
a486 1
		}
d488 2
a489 3
	if ( (frag_off+frag_len) > (unsigned long)max)
		{
		SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);
d491 1
a491 1
		}
d494 1
a494 1
		{
d497 2
a498 3
		if (!BUF_MEM_grow_clean(s->init_buf,msg_len+DTLS1_HM_HEADER_LENGTH))
			{
			SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,ERR_R_BUF_LIB);
d500 1
a500 1
			}
d502 1
a502 1
		s->s3->tmp.message_size  = msg_len;
d504 4
a507 6
		s->s3->tmp.message_type  = msg_hdr->type;
		s->d1->r_msg_hdr.type    = msg_hdr->type;
		s->d1->r_msg_hdr.seq     = msg_hdr->seq;
		}
	else if (msg_len != s->d1->r_msg_hdr.msg_len)
		{
d510 1
a510 1
		SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);
d512 1
a512 1
		}
d515 1
a515 1
	}
d520 1
a520 1
	{
d532 1
a532 1
	if ( item == NULL)
d536 1
a536 1
	
d541 1
a541 2
	if ( s->d1->handshake_read_seq == frag->msg_header.seq)
		{
d545 1
a545 1
		al=dtls1_preprocess_fragment(s,&frag->msg_header,max);
d547 3
a549 3
		if (al==0) /* no alert */
			{
			unsigned char *p = (unsigned char *)s->init_buf->data+DTLS1_HM_HEADER_LENGTH;
d551 2
a552 2
				frag->fragment,frag->msg_header.frag_len);
			}
d557 1
a557 2
		if (al==0)
			{
d560 1
a560 1
			}
d562 1
a562 1
		ssl3_send_alert(s,SSL3_AL_FATAL,al);
d566 1
a566 2
		}
	else
d568 1
a568 1
	}
d572 1
a572 2
dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)
	{
d579 1
a579 1
	if ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)
d590 1
a590 1
	if ((msg_hdr->frag_off+frag_len) > max_len)
d594 3
a596 3
	memset(seq64be,0,sizeof(seq64be));
	seq64be[6] = (unsigned char) (msg_hdr->seq>>8);
	seq64be[7] = (unsigned char) msg_hdr->seq;
d599 1
a599 2
	if (item == NULL)
		{
d601 1
a601 1
		if ( frag == NULL)
d606 1
a606 2
		}
	else
d612 1
a612 2
	if (frag->reassembly == NULL)
		{
d615 6
a620 6
		while (frag_len)
			{
			i = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
				devnull,
				frag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);
			if (i<=0) goto err;
d622 1
a622 1
			}
d624 1
a624 1
		}
d627 3
a629 3
	i = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
		frag->fragment + msg_hdr->frag_off,frag_len,0);
	if (i<=0 || (unsigned long)i!=frag_len)
d633 1
a633 1
	                    (long)(msg_hdr->frag_off + frag_len));
d636 1
a636 1
	                           is_complete);
d638 1
a638 2
	if (is_complete)
		{
d641 1
a641 1
		}
d643 3
a645 4
	if (item == NULL)
		{
		memset(seq64be,0,sizeof(seq64be));
		seq64be[6] = (unsigned char)(msg_hdr->seq>>8);
d649 1
a649 2
		if (item == NULL)
			{
d652 1
a652 1
			}
d655 1
a655 1
		}
d660 4
a663 2
	if (frag != NULL) dtls1_hm_fragment_free(frag);
	if (item != NULL) OPENSSL_free(item);
d666 1
a666 1
	}
d670 2
a671 3
dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok)
{
	int i=-1;
d677 1
a677 1
	if ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)
d681 2
a682 2
	memset(seq64be,0,sizeof(seq64be));
	seq64be[6] = (unsigned char) (msg_hdr->seq>>8);
d698 2
a699 3
		msg_hdr->seq > s->d1->handshake_read_seq + 10 || item != NULL ||
		(s->d1->handshake_read_seq == 0 && msg_hdr->type == SSL3_MT_FINISHED))
		{
d702 6
a707 6
		while (frag_len)
			{
			i = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
				devnull,
				frag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);
			if (i<=0) goto err;
a708 1
			}
d710 1
a710 2
	else
		{
d715 1
a715 1
		if ( frag == NULL)
d720 1
a720 2
		if (frag_len)
			{
d722 3
a724 3
			i = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
				frag->fragment,frag_len,0);
			if (i<=0 || (unsigned long)i!=frag_len)
d726 1
a726 1
			}
d728 2
a729 2
		memset(seq64be,0,sizeof(seq64be));
		seq64be[6] = (unsigned char)(msg_hdr->seq>>8);
d733 1
a733 1
		if ( item == NULL)
d737 1
a737 1
		}
d742 4
a745 2
	if ( frag != NULL) dtls1_hm_fragment_free(frag);
	if ( item != NULL) OPENSSL_free(item);
d748 1
a748 1
	}
d753 1
a753 1
	{
d756 1
a756 1
	int i,al;
d760 3
a762 3
	if ((frag_len = dtls1_retrieve_buffered_fragment(s,max,ok)) || *ok)
		{
		if (*ok)	s->init_num = frag_len;
d764 1
a764 1
		}
d767 2
a768 2
	i=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,wire,
		DTLS1_HM_HEADER_LENGTH, 0);
d770 2
a771 2
		{
		s->rwstate=SSL_READING;
d774 1
a774 1
		}
d776 3
a778 4
	if (i != DTLS1_HM_HEADER_LENGTH)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);
d780 1
a780 1
		}
d802 1
a802 2
		wire[0] == SSL3_MT_HELLO_REQUEST)
		{
d807 1
a807 2
		if (wire[1] == 0 && wire[2] == 0 && wire[3] == 0)
			{
d809 5
a813 4
				s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, 
					wire, DTLS1_HM_HEADER_LENGTH, s, 
					s->msg_callback_arg);
			
d815 2
a816 3
			return dtls1_get_message_fragment(s, st1, stn,
				max, ok);
			}
d818 3
a820 3
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);
a821 1
			}
d823 1
d825 1
a825 1
	if ((al=dtls1_preprocess_fragment(s,&msg_hdr,max)))
d829 1
a829 1
	s->state=stn;
d831 2
a832 3
	if ( frag_len > 0)
		{
		unsigned char *p=(unsigned char *)s->init_buf->data+DTLS1_HM_HEADER_LENGTH;
d834 2
a835 2
		i=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
			&p[frag_off],frag_len,0);
d837 2
a838 3
		if (i <= 0)
			{
			s->rwstate=SSL_READING;
a840 1
			}
d842 1
a842 1
	else
d847 3
a849 4
	if (i != (int)frag_len)
		{
		al=SSL3_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL3_AD_ILLEGAL_PARAMETER);
d851 1
a851 1
		}
d863 1
a863 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d866 3
a868 3
	*ok=0;
	return(-1);
	}
d870 4
a873 3
int dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen)
	{
	unsigned char *p,*d;
d877 3
a879 4
	if (s->state == a)
		{
		d=(unsigned char *)s->init_buf->data;
		p= &(d[DTLS1_HM_HEADER_LENGTH]);
d881 2
a882 2
		i=s->method->ssl3_enc->final_finish_mac(s,
			sender,slen,s->s3->tmp.finish_md);
d885 2
a886 2
		p+=i;
		l=i;
d888 13
a900 16
	/* Copy the finished so we can use it for
	 * renegotiation checks
	 */
	if(s->type == SSL_ST_CONNECT)
		{
		OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
		memcpy(s->s3->previous_client_finished, 
		       s->s3->tmp.finish_md, i);
		s->s3->previous_client_finished_len=i;
		}
	else
		{
		OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
		memcpy(s->s3->previous_server_finished, 
		       s->s3->tmp.finish_md, i);
		s->s3->previous_server_finished_len=i;
d904 2
a905 2
		s->init_num=(int)l+DTLS1_HM_HEADER_LENGTH;
		s->init_off=0;
d910 2
a911 2
		s->state=b;
		}
d914 2
a915 2
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
	}
d925 3
a927 2
int dtls1_send_change_cipher_spec(SSL *s, int a, int b)
	{ 
d930 2
a931 3
	if (s->state == a)
		{
		p=(unsigned char *)s->init_buf->data;
d934 1
a934 1
		s->init_num=DTLS1_CCS_HEADER_LENGTH;
d938 2
a939 2
			s2n(s->d1->handshake_write_seq,p);
			s->init_num+=2;
d942 1
a942 1
		s->init_off=0;
d944 2
a945 2
		dtls1_set_message_header_int(s, SSL3_MT_CCS, 0, 
			s->d1->handshake_write_seq, 0, 0);
d950 2
a951 2
		s->state=b;
		}
d954 2
a955 2
	return(dtls1_do_write(s,SSL3_RT_CHANGE_CIPHER_SPEC));
	}
d957 3
a959 2
static int dtls1_add_cert_to_buf(BUF_MEM *buf, unsigned long *l, X509 *x)
	{
d963 3
a965 4
	n=i2d_X509(x,NULL);
	if (!BUF_MEM_grow_clean(buf,(int)(n+(*l)+3)))
		{
		SSLerr(SSL_F_DTLS1_ADD_CERT_TO_BUF,ERR_R_BUF_LIB);
d967 5
a971 5
		}
	p=(unsigned char *)&(buf->data[*l]);
	l2n3(n,p);
	i2d_X509(x,&p);
	*l+=n+3;
d974 5
a978 3
	}
unsigned long dtls1_output_cert_chain(SSL *s, X509 *x)
	{
d981 1
a981 1
	unsigned long l= 3 + DTLS1_HM_HEADER_LENGTH;
d985 11
a995 5
	buf=s->init_buf;
	if (!BUF_MEM_grow_clean(buf,10))
		{
		SSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);
		return(0);
a996 3
	if (x != NULL)
		{
		X509_STORE_CTX xs_ctx;
a997 6
		if (!X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,x,NULL))
  			{
  			SSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_X509_LIB);
  			return(0);
  			}
  
d1001 1
a1001 2
		for (i=0; i < sk_X509_num(xs_ctx.chain); i++)
  			{
d1004 1
a1004 2
			if (!dtls1_add_cert_to_buf(buf, &l, x))
  				{
d1007 7
a1013 8
  				}
  			}
  		X509_STORE_CTX_cleanup(&xs_ctx);
  		}
  	/* Thawte special :-) */
	for (i=0; i<sk_X509_num(s->ctx->extra_certs); i++)
		{
		x=sk_X509_value(s->ctx->extra_certs,i);
d1016 1
a1016 1
		}
d1018 1
a1018 1
	l-= (3 + DTLS1_HM_HEADER_LENGTH);
d1020 4
a1023 4
	p=(unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH]);
	l2n3(l,p);
	l+=3;
	p=(unsigned char *)&(buf->data[0]);
d1026 3
a1028 3
	l+=DTLS1_HM_HEADER_LENGTH;
	return(l);
	}
d1030 4
a1033 4
int dtls1_read_failed(SSL *s, int code)
	{
	if ( code > 0)
		{
d1036 1
a1036 1
		}
d1038 1
a1038 2
	if (!dtls1_is_timer_expired(s))
		{
d1042 1
a1042 1
		}
d1049 1
a1049 1
		{
d1052 1
a1052 1
		}
d1056 1
a1056 2
	if ( item )
		{
d1058 1
a1058 2
		}
	else
d1062 3
a1064 3
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
d1068 1
a1068 1
	}
d1072 1
a1072 1
	{
d1082 1
a1082 1
	}
d1086 1
a1086 1
	{
d1095 1
a1095 2
	for ( item = pqueue_next(&iter); item != NULL; item = pqueue_next(&iter))
		{
d1097 4
a1100 4
			if ( dtls1_retransmit_message(s,
				(unsigned short)dtls1_get_queue_priority(frag->msg_header.seq, frag->msg_header.is_ccs),
				0, &found) <= 0 && found)
			{
a1102 1
			}
d1104 1
d1107 1
a1107 1
	}
d1111 1
a1111 1
	{
d1124 7
a1130 10
	if ( is_ccs)
		{
		OPENSSL_assert(s->d1->w_msg_hdr.msg_len + 
			       ((s->version==DTLS1_VERSION)?DTLS1_CCS_HEADER_LENGTH:3) == (unsigned int)s->init_num);
		}
	else
		{
		OPENSSL_assert(s->d1->w_msg_hdr.msg_len + 
			DTLS1_HM_HEADER_LENGTH == (unsigned int)s->init_num);
		}
d1145 2
a1146 2
	
	memset(seq64be,0,sizeof(seq64be));
d1148 1
a1148 1
														  frag->msg_header.is_ccs)>>8);
d1150 1
a1150 1
														  frag->msg_header.is_ccs));
d1153 1
a1153 2
	if ( item == NULL)
		{
d1156 1
a1156 1
		}
d1159 3
a1161 3
	fprintf( stderr, "buffered messge: \ttype = %xx\n", msg_buf->type);
	fprintf( stderr, "\t\t\t\t\tlen = %d\n", msg_buf->len);
	fprintf( stderr, "\t\t\t\t\tseq_num = %d\n", msg_buf->seq_num);
d1166 1
a1166 1
	}
d1170 2
a1171 2
	int *found)
	{
d1175 1
a1175 1
	hm_fragment *frag ;
d1187 2
a1188 2
	memset(seq64be,0,sizeof(seq64be));
	seq64be[6] = (unsigned char)(seq>>8);
d1192 1
a1192 2
	if ( item == NULL)
		{
d1196 1
a1196 1
		}
d1201 1
a1201 1
	if ( frag->msg_header.is_ccs)
d1206 7
a1212 7
	memcpy(s->init_buf->data, frag->fragment, 
		frag->msg_header.msg_len + header_length);
		s->init_num = frag->msg_header.msg_len + header_length;

	dtls1_set_message_header_int(s, frag->msg_header.type, 
		frag->msg_header.msg_len, frag->msg_header.seq, 0, 
		frag->msg_header.frag_len);
d1221 1
a1221 1
	
d1223 1
a1223 1
	
d1230 2
a1231 3
	
	if (frag->msg_header.saved_retransmit_state.epoch == saved_state.epoch - 1)
	{
d1235 4
a1238 4
	
	ret = dtls1_do_write(s, frag->msg_header.is_ccs ? 
						 SSL3_RT_CHANGE_CIPHER_SPEC : SSL3_RT_HANDSHAKE);
	
d1245 2
a1246 3
	
	if (frag->msg_header.saved_retransmit_state.epoch == saved_state.epoch - 1)
	{
d1255 1
a1255 1
	}
d1260 1
a1260 1
	{
d1263 2
a1264 3
	for(item = pqueue_pop(s->d1->sent_messages);
		item != NULL; item = pqueue_pop(s->d1->sent_messages))
		{
a1266 1
		}
d1268 1
d1273 2
a1274 2
			unsigned long len, unsigned long frag_off, unsigned long frag_len)
	{
d1276 1
a1276 2
	if (frag_off == 0 && !s->d1->listen)
		{
d1279 1
a1279 1
		}
d1282 1
a1282 1
		frag_off, frag_len);
d1285 1
a1285 1
	}
d1291 3
a1293 3
			    unsigned long len, unsigned short seq_num, unsigned long frag_off,
			    unsigned long frag_len)
	{
d1301 1
a1301 1
	}
d1305 2
a1306 2
			unsigned long frag_len)
	{
d1311 1
a1311 1
	}
d1315 1
a1315 1
	{
d1326 1
a1326 1
	}
d1328 1
a1328 1
unsigned int 
d1330 4
a1333 4
	{
	return (g_probable_mtu[(sizeof(g_probable_mtu) / 
		sizeof(g_probable_mtu[0])) - 1]);
	}
d1335 1
a1335 1
static unsigned int 
d1337 1
a1337 1
	{
d1340 2
a1341 2
	if ( curr_mtu == 0 )
		return g_probable_mtu[0] ;
d1343 2
a1344 2
	for ( i = 0; i < sizeof(g_probable_mtu)/sizeof(g_probable_mtu[0]); i++)
		if ( curr_mtu > g_probable_mtu[i])
d1348 1
a1348 1
	}
d1351 1
a1351 2
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)
	{
d1359 1
a1359 1
	}
d1362 1
a1362 2
dtls1_get_ccs_header(unsigned char *data, struct ccs_header_st *ccs_hdr)
	{
d1366 1
a1366 1
	}
d1368 3
a1370 2
int dtls1_shutdown(SSL *s)
	{
d1374 1
a1374 2
	    !(s->shutdown & SSL_SENT_SHUTDOWN))
		{
d1376 2
a1377 1
		if (ret < 0) return -1;
d1381 1
a1381 1
		}
d1388 1
a1388 1
	}
d1393 1
a1393 1
	{
d1401 2
a1402 2
			&s->s3->rrec.data[0], s->s3->rrec.length,
			s, s->msg_callback_arg);
d1413 1
a1413 2
	if (hbtype == TLS1_HB_REQUEST)
		{
d1416 2
a1417 2
					    2 /* heartbeat length */ +
					    payload + padding;
d1442 2
a1443 2
				buffer, write_length,
				s, s->msg_callback_arg);
d1449 1
a1449 3
		}
	else if (hbtype == TLS1_HB_RESPONSE)
		{
d1457 1
a1457 2
		if (payload == 18 && seq == s->tlsext_hb_seq)
			{
a1460 1
			}
d1462 1
d1465 1
a1465 1
	}
d1469 1
a1469 1
	{
d1477 2
a1478 3
	    s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_SEND_REQUESTS)
		{
		SSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT);
d1480 1
a1480 1
		}
d1483 2
a1484 3
	if (s->tlsext_hb_pending)
		{
		SSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PENDING);
d1486 1
a1486 1
		}
d1489 2
a1490 3
	if (SSL_in_init(s) || s->in_handshake)
		{
		SSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_UNEXPECTED_MESSAGE);
d1492 1
a1492 1
		}
d1523 1
a1523 2
	if (ret >= 0)
		{
d1526 2
a1527 2
				buf, 3 + payload + padding,
				s, s->msg_callback_arg);
d1531 1
a1531 1
		}
d1536 1
a1536 1
	}
@


1.4
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a940 7
#ifdef OPENSSL_SYS_WIN16
		/* MSVC 1.5 does not clear the top bytes of the word unless
		 * I do this.
		 */
		l&=0xffff;
#endif

@


1.3
log
@cherrypick fix for CVE-2014-0160 "heartbleed" vulnerability from
OpenSSL git; ok sthen@@
@
text
@a222 1

d322 4
a325 3
				/* write atleast DTLS1_HM_HEADER_LENGTH bytes */
				if ( len <= DTLS1_HM_HEADER_LENGTH)  
					len += DTLS1_HM_HEADER_LENGTH;
@


1.2
log
@SECURITY fixes backported from openssl-1.0.1f.  ok mikeb@@

CVE-2013-4353 NULL pointer dereference with crafted Next Protocol
 Negotiation record in TLS handshake.
Upstream: 197e0ea

CVE-2013-6449 Fix crash with crafted traffic from a TLS 1.2 client.
Upstream: ca98926, 0294b2b

CVE-2013-6450 Fix DTLS retransmission from previous session.
Upstream: 3462896
@
text
@d1462 5
d1468 2
d1472 2
a1475 5
	if (s->msg_callback)
		s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
			&s->s3->rrec.data[0], s->s3->rrec.length,
			s, s->msg_callback_arg);

d1479 3
d1484 3
d1491 1
a1491 1
		buffer = OPENSSL_malloc(1 + 2 + payload + padding);
d1502 1
a1502 1
		r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
d1506 1
a1506 1
				buffer, 3 + payload + padding,
@


1.2.4.1
log
@MFC:
cherrypick fix for CVE-2014-0160 "heartbleed" vulnerability from
OpenSSL git; ok sthen@@
@
text
@d1462 5
a1471 9
	/* Read type and payload length first */
	if (1 + 2 + 16 > s->s3->rrec.length)
		return 0; /* silently discard */
	hbtype = *p++;
	n2s(p, payload);
	if (1 + 2 + payload + 16 > s->s3->rrec.length)
		return 0; /* silently discard per RFC 6520 sec. 4 */
	pl = p;

a1474 3
		unsigned int write_length = 1 /* heartbeat type */ +
					    2 /* heartbeat length */ +
					    payload + padding;
a1476 3
		if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
			return 0;

d1481 1
a1481 1
		buffer = OPENSSL_malloc(write_length);
d1492 1
a1492 1
		r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
d1496 1
a1496 1
				buffer, write_length,
@


1.2.4.2
log
@MFC DTLS "Hello Request" fix (CVE-2014-0221)

"Do not recurse when a 'Hello Request' message is received while getting
DTLS fragments. A stream of 'Hello Request' messages will result in
infinite recursion, eventually crashing the DTLS client or server.
Fixes CVE-2014-0221, from OpenSSL.  Reported to OpenSSL by Imre Rad."
From d1_both.c r1.20
@
text
@a786 1
again:
d845 2
a846 1
			goto again;
@


1.2.4.3
log
@MFC DTLS buffer overflow fix (CVE-2014-0195)

"Avoid a buffer overflow that can be triggered by sending specially crafted
DTLS fragments. Fix for CVE-2014-0195, from OpenSSL. Reported to OpenSSL
by Juri Aedla." From d1_both.c r1.19
@
text
@d629 1
a629 1
	else {
a630 6
		if (frag->msg_header.msg_len != msg_hdr->msg_len) {
			item = NULL;
			frag = NULL;
			goto err;
		}
	}
@


1.2.4.4
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@a589 10
/* dtls1_max_handshake_message_len returns the maximum number of bytes
 * permitted in a DTLS handshake message for |s|. The minimum is 16KB, but may
 * be greater if the maximum certificate list size requires it. */
static unsigned long dtls1_max_handshake_message_len(const SSL *s)
	{
	unsigned long max_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;
	if (max_len < (unsigned long)s->max_cert_list)
		return s->max_cert_list;
	return max_len;
	}
d592 1
a592 1
dtls1_reassemble_fragment(SSL *s, const struct hm_header_st* msg_hdr, int *ok)
d598 1
a598 1
	unsigned long frag_len = msg_hdr->frag_len;
d600 1
a600 2
	if ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len ||
	    msg_hdr->msg_len > dtls1_max_handshake_message_len(s))
d603 10
a612 2
	if (frag_len == 0)
		return DTLS1_HM_FRAGMENT_RETRY;
d639 1
a639 2
	 * retransmit and can be dropped. In this case item != NULL and so frag
	 * does not need to be freed.
d659 1
a659 3
	if ((unsigned long)i!=frag_len)
		i=-1;
	if (i<=0)
d676 4
d687 1
a687 6
		item = pqueue_insert(s->d1->buffered_messages, item);
		/* pqueue_insert fails iff a duplicate item is inserted.
		 * However, |item| cannot be a duplicate. If it were,
		 * |pqueue_find|, above, would have returned it and control
		 * would never have reached this branch. */
		OPENSSL_assert(item != NULL);
d693 2
a694 1
	if (frag != NULL && item == NULL) dtls1_hm_fragment_free(frag);
d701 1
a701 1
dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st* msg_hdr, int *ok)
d721 1
a721 1
	if (item != NULL && frag_len != msg_hdr->msg_len)
d746 1
a746 1
		if (frag_len != msg_hdr->msg_len)
a748 3
		if (frag_len > dtls1_max_handshake_message_len(s))
			goto err;

d760 1
a760 3
			if ((unsigned long)i!=frag_len)
				i = -1;
			if (i<=0)
d764 4
d772 1
a772 9
		item = pqueue_insert(s->d1->buffered_messages, item);
		/* pqueue_insert fails iff a duplicate item is inserted.
		 * However, |item| cannot be a duplicate. If it were,
		 * |pqueue_find|, above, would have returned it. Then, either
		 * |frag_len| != |msg_hdr->msg_len| in which case |item| is set
		 * to NULL and it will have been processed with
		 * |dtls1_reassemble_fragment|, above, or the record will have
		 * been discarded. */
		OPENSSL_assert(item != NULL);
d778 2
a779 1
	if (frag != NULL && item == NULL) dtls1_hm_fragment_free(frag);
a1179 2
	if (!frag)
		return 0;
@


1.1
log
@Initial revision
@
text
@d126 31
a160 1
static unsigned int dtls1_min_mtu(void);
a168 1
static int dtls1_retransmit_buffered_messages(SSL *s);
d173 1
a173 1
dtls1_hm_fragment_new(unsigned long frag_len)
d177 1
d196 15
d217 7
d225 1
d234 1
a234 1
	unsigned int len, frag_off;
d237 1
a237 1
	if ( ! (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU))
d244 1
a244 1
		if ( s->d1->mtu < dtls1_min_mtu())
d273 1
d275 1
a275 3
	OPENSSL_assert(mtu > 0);  /* should have something reasonable now */

#endif
d281 11
d296 1
a296 1
			DTLS1_RT_HEADER_LENGTH;
d304 2
a305 1
			curr_mtu = s->d1->mtu - DTLS1_RT_HEADER_LENGTH;
d347 1
a347 1
				BIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL))
d368 1
a368 1
				if (frag_off == 0 && s->client_version != DTLS1_BAD_VER)
d419 2
d440 9
a448 7
	do
		{
		if ( msg_hdr->frag_off == 0)
			{
			/* s->d1->r_message_header.msg_len = 0; */
			memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
			}
d450 2
a451 6
		i = dtls1_get_message_fragment(s, st1, stn, max, ok);
		if ( i == DTLS1_HM_BAD_FRAGMENT ||
			i == DTLS1_HM_FRAGMENT_RETRY)  /* bad fragment received */
			continue;
		else if ( i <= 0 && !*ok)
			return i;
d453 16
a468 14
		/* Note that s->init_sum is used as a counter summing
		 * up fragments' lengths: as soon as they sum up to
		 * handshake packet length, we assume we have got all
		 * the fragments. Overlapping fragments would cause
		 * premature termination, so we don't expect overlaps.
		 * Well, handling overlaps would require something more
		 * drastic. Indeed, as it is now there is no way to
		 * tell if out-of-order fragment from the middle was
		 * the last. '>=' is the best/least we can do to control
		 * the potential damage caused by malformed overlaps. */
		if ((unsigned int)s->init_num >= msg_hdr->msg_len)
			{
			unsigned char *p = (unsigned char *)s->init_buf->data;
			unsigned long msg_len = msg_hdr->msg_len;
d470 1
a470 10
			/* reconstruct message header as if it was
			 * sent in single fragment */
			*(p++) = msg_hdr->type;
			l2n3(msg_len,p);
			s2n (msg_hdr->seq,p);
			l2n3(0,p);
			l2n3(msg_len,p);
			if (s->client_version != DTLS1_BAD_VER)
				p       -= DTLS1_HM_HEADER_LENGTH,
				msg_len += DTLS1_HM_HEADER_LENGTH;
d472 3
a474 22
			ssl3_finish_mac(s, p, msg_len);
			if (s->msg_callback)
				s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
					p, msg_len,
					s, s->msg_callback_arg);

			memset(msg_hdr, 0x00, sizeof(struct hm_header_st));

			s->d1->handshake_read_seq++;
			/* we just read a handshake message from the other side:
			 * this means that we don't need to retransmit of the
			 * buffered messages.  
			 * XDTLS: may be able clear out this
			 * buffer a little sooner (i.e if an out-of-order
			 * handshake message/record is received at the record
			 * layer.  
			 * XDTLS: exception is that the server needs to
			 * know that change cipher spec and finished messages
			 * have been received by the client before clearing this
			 * buffer.  this can simply be done by waiting for the
			 * first data  segment, but is there a better way?  */
			dtls1_clear_record_buffer(s);
d476 2
a477 6
			s->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;
			return s->init_num;
			}
		else
			msg_hdr->frag_off = i;
		} while(1) ;
d511 1
a511 1
		if (!BUF_MEM_grow_clean(s->init_buf,(int)msg_len+DTLS1_HM_HEADER_LENGTH))
d553 4
d560 1
d578 1
a578 1
			return frag->msg_header.frag_len;
d592 2
a593 3
dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok)
{
	int i=-1;
d596 3
a598 2
	PQ_64BIT seq64;
	unsigned long frag_len = msg_hdr->frag_len;
d603 33
a635 1
	if (msg_hdr->seq <= s->d1->handshake_read_seq)
d647 1
d650 4
a653 2
	frag = dtls1_hm_fragment_new(frag_len);
	if ( frag == NULL)
d656 5
a660 1
	memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
d662 7
a668 1
	if (frag_len)
d670 7
a676 4
		/* read the body of the fragment (header has already been read */
		i = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
			frag->fragment,frag_len,0);
		if (i<=0 || (unsigned long)i!=frag_len)
d678 4
d684 9
a692 2
	pq_64bit_init(&seq64);
	pq_64bit_assign_word(&seq64, msg_hdr->seq);
d694 10
a703 3
	item = pitem_new(seq64, frag);
	pq_64bit_free(&seq64);
	if ( item == NULL)
d706 63
a768 1
	pqueue_insert(s->d1->buffered_messages, item);
d783 1
a783 1
	unsigned long l, frag_off, frag_len;
d790 1
a790 1
		if (*ok)	s->init_num += frag_len;
d803 7
a809 1
	OPENSSL_assert(i == DTLS1_HM_HEADER_LENGTH);
d816 3
a818 1
	 * (or dropped)--no further processing at this time 
d820 1
a820 1
	if ( msg_hdr.seq != s->d1->handshake_read_seq)
d823 1
a823 1
	l = msg_hdr.msg_len;
d827 3
d881 6
a886 1
	OPENSSL_assert(i == (int)frag_len);
d894 1
a894 1
	s->init_num += frag_len;
a916 2
			&(s->s3->finish_dgst1),
			&(s->s3->finish_dgst2),
d923 18
d981 1
a981 2
		if (s->client_version == DTLS1_BAD_VER)
			{
d985 1
a985 1
			}
d1002 18
d1023 1
a1023 1
	int n,i;
a1025 2
	X509_STORE_CTX xs_ctx;
	X509_OBJECT obj;
d1036 1
a1036 5
		if(!X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,NULL,NULL))
			{
			SSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_X509_LIB);
			return(0);
			}
d1038 22
a1059 29
		for (;;)
			{
			n=i2d_X509(x,NULL);
			if (!BUF_MEM_grow_clean(buf,(int)(n+l+3)))
				{
				SSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);
				return(0);
				}
			p=(unsigned char *)&(buf->data[l]);
			l2n3(n,p);
			i2d_X509(x,&p);
			l+=n+3;
			if (X509_NAME_cmp(X509_get_subject_name(x),
				X509_get_issuer_name(x)) == 0) break;

			i=X509_STORE_get_by_subject(&xs_ctx,X509_LU_X509,
				X509_get_issuer_name(x),&obj);
			if (i <= 0) break;
			x=obj.data.x509;
			/* Count is one too high since the X509_STORE_get uped the
			 * ref count */
			X509_free(x);
			}

		X509_STORE_CTX_cleanup(&xs_ctx);
		}

	/* Thawte special :-) */
	if (s->ctx->extra_certs != NULL)
d1063 2
a1064 10
		n=i2d_X509(x,NULL);
		if (!BUF_MEM_grow_clean(buf,(int)(n+l+3)))
			{
			SSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);
			return(0);
			}
		p=(unsigned char *)&(buf->data[l]);
		l2n3(n,p);
		i2d_X509(x,&p);
		l+=n+3;
a1080 4
	DTLS1_STATE *state;
	BIO *bio;
	int send_alert = 0;

d1087 1
a1087 2
	bio = SSL_get_rbio(s);
	if ( ! BIO_dgram_recv_timedout(bio))
d1094 5
a1098 1
	if ( ! SSL_in_init(s))  /* done, no need to send a retransmit */
a1103 17
	state = s->d1;
	state->timeout.num_alerts++;
	if ( state->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT)
		{
		/* fail the connection, enough alerts have been sent */
		SSLerr(SSL_F_DTLS1_READ_FAILED,SSL_R_READ_TIMEOUT_EXPIRED);
		return 0;
		}

	state->timeout.read_timeouts++;
	if ( state->timeout.read_timeouts > DTLS1_TMO_READ_COUNT)
		{
		send_alert = 1;
		state->timeout.read_timeouts = 1;
		}


d1114 3
a1116 3
		if ( send_alert)
			ssl3_send_alert(s,SSL3_AL_WARNING,
				DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
d1119 1
a1119 1
	return dtls1_retransmit_buffered_messages(s) ;
d1122 13
d1136 1
a1136 1
static int
d1150 3
a1152 2
		if ( dtls1_retransmit_message(s, frag->msg_header.seq, 0, &found) <= 0 &&
			found)
d1167 1
a1167 2
	PQ_64BIT seq64;
	unsigned int epoch = s->d1->w_epoch;
d1173 1
a1173 1
	frag = dtls1_hm_fragment_new(s->init_num);
d1180 1
a1180 2
			DTLS1_CCS_HEADER_LENGTH <= (unsigned int)s->init_num);
		epoch++;
d1195 12
a1206 2
	pq_64bit_init(&seq64);
	pq_64bit_assign_word(&seq64, epoch<<16 | frag->msg_header.seq);
d1208 1
a1208 2
	item = pitem_new(seq64, frag);
	pq_64bit_free(&seq64);
d1234 3
a1236 1
	PQ_64BIT seq64;
d1244 3
a1246 2
	pq_64bit_init(&seq64);
	pq_64bit_assign_word(&seq64, seq);
d1248 1
a1248 2
	item = pqueue_find(s->d1->sent_messages, seq64);
	pq_64bit_free(&seq64);
d1272 8
d1281 14
d1296 15
a1310 1
		SSL3_RT_CHANGE_CIPHER_SPEC : SSL3_RT_HANDSHAKE);
d1336 2
a1337 1
	if ( frag_off == 0)
d1390 1
a1390 1
static unsigned int 
d1400 1
a1400 1
	size_t i;
d1431 168
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.0a
@
text
@a125 31
#define RSMBLY_BITMASK_SIZE(msg_len) (((msg_len) + 7) / 8)

#define RSMBLY_BITMASK_MARK(bitmask, start, end) { \
			if ((end) - (start) <= 8) { \
				long ii; \
				for (ii = (start); ii < (end); ii++) bitmask[((ii) >> 3)] |= (1 << ((ii) & 7)); \
			} else { \
				long ii; \
				bitmask[((start) >> 3)] |= bitmask_start_values[((start) & 7)]; \
				for (ii = (((start) >> 3) + 1); ii < ((((end) - 1)) >> 3); ii++) bitmask[ii] = 0xff; \
				bitmask[(((end) - 1) >> 3)] |= bitmask_end_values[((end) & 7)]; \
			} }

#define RSMBLY_BITMASK_IS_COMPLETE(bitmask, msg_len, is_complete) { \
			long ii; \
			OPENSSL_assert((msg_len) > 0); \
			is_complete = 1; \
			if (bitmask[(((msg_len) - 1) >> 3)] != bitmask_end_values[((msg_len) & 7)]) is_complete = 0; \
			if (is_complete) for (ii = (((msg_len) - 1) >> 3) - 1; ii >= 0 ; ii--) \
				if (bitmask[ii] != 0xff) { is_complete = 0; break; } }

#if 0
#define RSMBLY_BITMASK_PRINT(bitmask, msg_len) { \
			long ii; \
			printf("bitmask: "); for (ii = 0; ii < (msg_len); ii++) \
			printf("%d ", (bitmask[ii >> 3] & (1 << (ii & 7))) >> (ii & 7)); \
			printf("\n"); }
#endif

static unsigned char bitmask_start_values[] = {0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80};
static unsigned char bitmask_end_values[]   = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f};
d139 1
d144 1
a144 1
dtls1_hm_fragment_new(unsigned long frag_len, int reassembly)
a147 1
	unsigned char *bitmask = NULL;
a165 15
	/* Initialize reassembly bitmask if necessary */
	if (reassembly)
		{
		bitmask = (unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
		if (bitmask == NULL)
			{
			if (buf != NULL) OPENSSL_free(buf);
			OPENSSL_free(frag);
			return NULL;
			}
		memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
		}

	frag->reassembly = bitmask;

a172 1
	if (frag->reassembly) OPENSSL_free(frag->reassembly);
d181 1
a181 1
	unsigned int len, frag_off, mac_size, blocksize;
a228 11
	if (s->write_hash)
		mac_size = EVP_MD_CTX_size(s->write_hash);
	else
		mac_size = 0;

	if (s->enc_write_ctx && 
		(EVP_CIPHER_mode( s->enc_write_ctx->cipher) & EVP_CIPH_CBC_MODE))
		blocksize = 2 * EVP_CIPHER_block_size(s->enc_write_ctx->cipher);
	else
		blocksize = 0;

d233 1
a233 1
			DTLS1_RT_HEADER_LENGTH - mac_size - blocksize;
d241 1
a241 2
			curr_mtu = s->d1->mtu - DTLS1_RT_HEADER_LENGTH -
				mac_size - blocksize;
d283 1
a283 1
				BIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL) > 0 )
d304 1
a304 1
				if (frag_off == 0 && s->version != DTLS1_BAD_VER)
a354 2
	unsigned char *p;
	unsigned long msg_len;
d374 14
a387 1
	memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
d389 14
a402 7
again:
	i = dtls1_get_message_fragment(s, st1, stn, max, ok);
	if ( i == DTLS1_HM_BAD_FRAGMENT ||
		i == DTLS1_HM_FRAGMENT_RETRY)  /* bad fragment received */
		goto again;
	else if ( i <= 0 && !*ok)
		return i;
d404 10
a413 2
	p = (unsigned char *)s->init_buf->data;
	msg_len = msg_hdr->msg_len;
d415 22
a436 33
	/* reconstruct message header */
	*(p++) = msg_hdr->type;
	l2n3(msg_len,p);
	s2n (msg_hdr->seq,p);
	l2n3(0,p);
	l2n3(msg_len,p);
	if (s->version != DTLS1_BAD_VER) {
		p       -= DTLS1_HM_HEADER_LENGTH;
		msg_len += DTLS1_HM_HEADER_LENGTH;
	}

	ssl3_finish_mac(s, p, msg_len);
	if (s->msg_callback)
		s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
			p, msg_len,
			s, s->msg_callback_arg);

	memset(msg_hdr, 0x00, sizeof(struct hm_header_st));

	s->d1->handshake_read_seq++;
	/* we just read a handshake message from the other side:
	 * this means that we don't need to retransmit of the
	 * buffered messages.  
	 * XDTLS: may be able clear out this
	 * buffer a little sooner (i.e if an out-of-order
	 * handshake message/record is received at the record
	 * layer.  
	 * XDTLS: exception is that the server needs to
	 * know that change cipher spec and finished messages
	 * have been received by the client before clearing this
	 * buffer.  this can simply be done by waiting for the
	 * first data  segment, but is there a better way?  */
	dtls1_clear_record_buffer(s);
d438 6
a443 2
	s->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;
	return s->init_num;
d477 1
a477 1
		if (!BUF_MEM_grow_clean(s->init_buf,msg_len+DTLS1_HM_HEADER_LENGTH))
a518 4
	
	/* Don't return if reassembly still in progress */
	if (frag->reassembly != NULL)
		return 0;
a521 1
		unsigned long frag_len = frag->msg_header.frag_len;
d539 1
a539 1
			return frag_len;
d553 3
a555 2
dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)
	{
d558 2
a559 3
	int i = -1, is_complete;
	unsigned char seq64be[8];
	unsigned long frag_len = msg_hdr->frag_len, max_len;
d564 1
a564 33
	/* Determine maximum allowed message size. Depends on (user set)
	 * maximum certificate length, but 16k is minimum.
	 */
	if (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH < s->max_cert_list)
		max_len = s->max_cert_list;
	else
		max_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;

	if ((msg_hdr->frag_off+frag_len) > max_len)
		goto err;

	/* Try to find item in queue */
	memset(seq64be,0,sizeof(seq64be));
	seq64be[6] = (unsigned char) (msg_hdr->seq>>8);
	seq64be[7] = (unsigned char) msg_hdr->seq;
	item = pqueue_find(s->d1->buffered_messages, seq64be);

	if (item == NULL)
		{
		frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);
		if ( frag == NULL)
			goto err;
		memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
		frag->msg_header.frag_len = frag->msg_header.msg_len;
		frag->msg_header.frag_off = 0;
		}
	else
		frag = (hm_fragment*) item->data;

	/* If message is already reassembled, this must be a
	 * retransmit and can be dropped.
	 */
	if (frag->reassembly == NULL)
a575 1
		return DTLS1_HM_FRAGMENT_RETRY;
d578 2
a579 4
	/* read the body of the fragment (header has already been read */
	i = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
		frag->fragment + msg_hdr->frag_off,frag_len,0);
	if (i<=0 || (unsigned long)i!=frag_len)
d582 1
a582 2
	RSMBLY_BITMASK_MARK(frag->reassembly, (long)msg_hdr->frag_off,
	                    (long)(msg_hdr->frag_off + frag_len));
d584 1
a584 4
	RSMBLY_BITMASK_IS_COMPLETE(frag->reassembly, (long)msg_hdr->msg_len,
	                           is_complete);

	if (is_complete)
d586 4
a589 13
		OPENSSL_free(frag->reassembly);
		frag->reassembly = NULL;
		}

	if (item == NULL)
		{
		memset(seq64be,0,sizeof(seq64be));
		seq64be[6] = (unsigned char)(msg_hdr->seq>>8);
		seq64be[7] = (unsigned char)(msg_hdr->seq);

		item = pitem_new(seq64be, frag);
		if (item == NULL)
			{
a590 4
			i = -1;
			}

		pqueue_insert(s->d1->buffered_messages, item);
d593 2
a594 1
	return DTLS1_HM_FRAGMENT_RETRY;
d596 3
a598 18
err:
	if (frag != NULL) dtls1_hm_fragment_free(frag);
	if (item != NULL) OPENSSL_free(item);
	*ok = 0;
	return i;
	}


static int
dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok)
{
	int i=-1;
	hm_fragment *frag = NULL;
	pitem *item = NULL;
	unsigned char seq64be[8];
	unsigned long frag_len = msg_hdr->frag_len;

	if ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)
d601 1
a601 63
	/* Try to find item in queue, to prevent duplicate entries */
	memset(seq64be,0,sizeof(seq64be));
	seq64be[6] = (unsigned char) (msg_hdr->seq>>8);
	seq64be[7] = (unsigned char) msg_hdr->seq;
	item = pqueue_find(s->d1->buffered_messages, seq64be);

	/* If we already have an entry and this one is a fragment,
	 * don't discard it and rather try to reassemble it.
	 */
	if (item != NULL && frag_len < msg_hdr->msg_len)
		item = NULL;

	/* Discard the message if sequence number was already there, is
	 * too far in the future, already in the queue or if we received
	 * a FINISHED before the SERVER_HELLO, which then must be a stale
	 * retransmit.
	 */
	if (msg_hdr->seq <= s->d1->handshake_read_seq ||
		msg_hdr->seq > s->d1->handshake_read_seq + 10 || item != NULL ||
		(s->d1->handshake_read_seq == 0 && msg_hdr->type == SSL3_MT_FINISHED))
		{
		unsigned char devnull [256];

		while (frag_len)
			{
			i = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
				devnull,
				frag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);
			if (i<=0) goto err;
			frag_len -= i;
			}
		}
	else
		{
		if (frag_len && frag_len < msg_hdr->msg_len)
			return dtls1_reassemble_fragment(s, msg_hdr, ok);

		frag = dtls1_hm_fragment_new(frag_len, 0);
		if ( frag == NULL)
			goto err;

		memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));

		if (frag_len)
			{
			/* read the body of the fragment (header has already been read */
			i = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
				frag->fragment,frag_len,0);
			if (i<=0 || (unsigned long)i!=frag_len)
				goto err;
			}

		memset(seq64be,0,sizeof(seq64be));
		seq64be[6] = (unsigned char)(msg_hdr->seq>>8);
		seq64be[7] = (unsigned char)(msg_hdr->seq);

		item = pitem_new(seq64be, frag);
		if ( item == NULL)
			goto err;

		pqueue_insert(s->d1->buffered_messages, item);
		}

d616 1
a616 1
	unsigned long len, frag_off, frag_len;
d623 1
a623 1
		if (*ok)	s->init_num = frag_len;
d648 1
a648 1
	len = msg_hdr.msg_len;
a651 3
	if (frag_len && frag_len < len)
		return dtls1_reassemble_fragment(s, &msg_hdr, ok);

d711 1
a711 1
	s->init_num = frag_len;
d734 2
a741 18
	/* Copy the finished so we can use it for
	 * renegotiation checks
	 */
	if(s->type == SSL_ST_CONNECT)
		{
		OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
		memcpy(s->s3->previous_client_finished, 
		       s->s3->tmp.finish_md, i);
		s->s3->previous_client_finished_len=i;
		}
	else
		{
		OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
		memcpy(s->s3->previous_server_finished, 
		       s->s3->tmp.finish_md, i);
		s->s3->previous_server_finished_len=i;
		}

d782 2
a783 1
		if (s->version == DTLS1_BAD_VER) {
d787 1
a787 1
		}
a803 18
static int dtls1_add_cert_to_buf(BUF_MEM *buf, unsigned long *l, X509 *x)
	{
	int n;
	unsigned char *p;

	n=i2d_X509(x,NULL);
	if (!BUF_MEM_grow_clean(buf,(int)(n+(*l)+3)))
		{
		SSLerr(SSL_F_DTLS1_ADD_CERT_TO_BUF,ERR_R_BUF_LIB);
		return 0;
		}
	p=(unsigned char *)&(buf->data[*l]);
	l2n3(n,p);
	i2d_X509(x,&p);
	*l+=n+3;

	return 1;
	}
d807 1
a807 1
	int i;
d810 2
d822 5
a826 1
		X509_STORE_CTX xs_ctx;
d828 29
a856 22
		if (!X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,x,NULL))
  			{
  			SSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_X509_LIB);
  			return(0);
  			}
  
		X509_verify_cert(&xs_ctx);
		/* Don't leave errors in the queue */
		ERR_clear_error();
		for (i=0; i < sk_X509_num(xs_ctx.chain); i++)
  			{
			x = sk_X509_value(xs_ctx.chain, i);

			if (!dtls1_add_cert_to_buf(buf, &l, x))
  				{
				X509_STORE_CTX_cleanup(&xs_ctx);
				return 0;
  				}
  			}
  		X509_STORE_CTX_cleanup(&xs_ctx);
  		}
  	/* Thawte special :-) */
d860 10
a869 2
		if (!dtls1_add_cert_to_buf(buf, &l, x))
			return 0;
d886 4
d896 2
a897 1
	if (!dtls1_is_timer_expired(s))
d910 17
d937 3
a939 3
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
d942 1
a942 1
	return dtls1_handle_timeout(s);
a944 13
int
dtls1_get_queue_priority(unsigned short seq, int is_ccs)
	{
	/* The index of the retransmission queue actually is the message sequence number,
	 * since the queue only contains messages of a single handshake. However, the
	 * ChangeCipherSpec has no message sequence number and so using only the sequence
	 * will result in the CCS and Finished having the same index. To prevent this,
	 * the sequence number is multiplied by 2. In case of a CCS 1 is subtracted.
	 * This does not only differ CSS and Finished, it also maintains the order of the
	 * index (important for priority queues) and fits in the unsigned short variable.
	 */	
	return seq * 2 - is_ccs;
	}
d946 1
a946 1
int
d960 2
a961 3
			if ( dtls1_retransmit_message(s,
				(unsigned short)dtls1_get_queue_priority(frag->msg_header.seq, frag->msg_header.is_ccs),
				0, &found) <= 0 && found)
d976 2
a977 1
	unsigned char seq64be[8];
d983 1
a983 1
	frag = dtls1_hm_fragment_new(s->init_num, 0);
d990 2
a991 1
			       ((s->version==DTLS1_VERSION)?DTLS1_CCS_HEADER_LENGTH:3) == (unsigned int)s->init_num);
d1006 2
a1007 12
	/* save current state*/
	frag->msg_header.saved_retransmit_state.enc_write_ctx = s->enc_write_ctx;
	frag->msg_header.saved_retransmit_state.write_hash = s->write_hash;
	frag->msg_header.saved_retransmit_state.compress = s->compress;
	frag->msg_header.saved_retransmit_state.session = s->session;
	frag->msg_header.saved_retransmit_state.epoch = s->d1->w_epoch;
	
	memset(seq64be,0,sizeof(seq64be));
	seq64be[6] = (unsigned char)(dtls1_get_queue_priority(frag->msg_header.seq,
														  frag->msg_header.is_ccs)>>8);
	seq64be[7] = (unsigned char)(dtls1_get_queue_priority(frag->msg_header.seq,
														  frag->msg_header.is_ccs));
d1009 2
a1010 1
	item = pitem_new(seq64be, frag);
d1036 1
a1036 3
	unsigned char seq64be[8];
	struct dtls1_retransmit_state saved_state;
	unsigned char save_write_sequence[8];
d1044 2
a1045 3
	memset(seq64be,0,sizeof(seq64be));
	seq64be[6] = (unsigned char)(seq>>8);
	seq64be[7] = (unsigned char)seq;
d1047 2
a1048 1
	item = pqueue_find(s->d1->sent_messages, seq64be);
a1071 8
	/* save current state */
	saved_state.enc_write_ctx = s->enc_write_ctx;
	saved_state.write_hash = s->write_hash;
	saved_state.compress = s->compress;
	saved_state.session = s->session;
	saved_state.epoch = s->d1->w_epoch;
	saved_state.epoch = s->d1->w_epoch;
	
a1072 14
	
	/* restore state in which the message was originally sent */
	s->enc_write_ctx = frag->msg_header.saved_retransmit_state.enc_write_ctx;
	s->write_hash = frag->msg_header.saved_retransmit_state.write_hash;
	s->compress = frag->msg_header.saved_retransmit_state.compress;
	s->session = frag->msg_header.saved_retransmit_state.session;
	s->d1->w_epoch = frag->msg_header.saved_retransmit_state.epoch;
	
	if (frag->msg_header.saved_retransmit_state.epoch == saved_state.epoch - 1)
	{
		memcpy(save_write_sequence, s->s3->write_sequence, sizeof(s->s3->write_sequence));
		memcpy(s->s3->write_sequence, s->d1->last_write_sequence, sizeof(s->s3->write_sequence));
	}
	
d1074 1
a1074 15
						 SSL3_RT_CHANGE_CIPHER_SPEC : SSL3_RT_HANDSHAKE);
	
	/* restore current state */
	s->enc_write_ctx = saved_state.enc_write_ctx;
	s->write_hash = saved_state.write_hash;
	s->compress = saved_state.compress;
	s->session = saved_state.session;
	s->d1->w_epoch = saved_state.epoch;
	
	if (frag->msg_header.saved_retransmit_state.epoch == saved_state.epoch - 1)
	{
		memcpy(s->d1->last_write_sequence, s->s3->write_sequence, sizeof(s->s3->write_sequence));
		memcpy(s->s3->write_sequence, save_write_sequence, sizeof(s->s3->write_sequence));
	}

d1163 1
a1163 1
	unsigned int i;
@


1.1.1.3
log
@import OpenSSL 1.0.0e
@
text
@d156 1
a156 1
static unsigned char bitmask_end_values[]   = {0xff, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f};
d467 14
a480 3
	/* Don't change sequence numbers while listening */
	if (!s->d1->listen)
		s->d1->handshake_read_seq++;
d816 1
a816 3
	 * (or dropped)--no further processing at this time
	 * While listening, we accept seq 1 (ClientHello with cookie)
	 * although we're still expecting seq 0 (ClientHello)
d818 1
a818 1
	if (msg_hdr.seq != s->d1->handshake_read_seq && !(s->d1->listen && msg_hdr.seq == 1))
d1325 1
a1325 2
	/* Don't change sequence numbers while listening */
	if (frag_off == 0 && !s->d1->listen)
@


1.1.1.4
log
@OpenSSL 1.0.0f: import upstream source
@
text
@d161 1
d267 3
a271 2
	OPENSSL_assert(s->d1->mtu >= dtls1_min_mtu());  /* should have something reasonable now */

d798 1
a798 7
	/* Handshake fails if message header is incomplete */
	if (i != DTLS1_HM_HEADER_LENGTH)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);
		goto f_err;
		}
d870 1
a870 6
	if (i != (int)frag_len)
		{
		al=SSL3_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL3_AD_ILLEGAL_PARAMETER);
		goto f_err;
		}
d1370 1
a1370 1
unsigned int 
@


1.1.1.5
log
@import OpenSSL-1.0.1c
@
text
@d230 1
a230 1
	if (s->d1->mtu < dtls1_min_mtu() && !(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU))
d237 1
a237 1
		if (s->d1->mtu < dtls1_min_mtu())
d1087 1
a1087 5
#ifndef OPENSSL_NO_HEARTBEATS
	if (!SSL_in_init(s) && !s->tlsext_hb_pending)  /* done, no need to send a retransmit */
#else
	if (!SSL_in_init(s))  /* done, no need to send a retransmit */
#endif
a1419 168

int dtls1_shutdown(SSL *s)
	{
	int ret;
#ifndef OPENSSL_NO_SCTP
	if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
	    !(s->shutdown & SSL_SENT_SHUTDOWN))
		{
		ret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));
		if (ret < 0) return -1;

		if (ret == 0)
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN, 1, NULL);
		}
#endif
	ret = ssl3_shutdown(s);
#ifndef OPENSSL_NO_SCTP
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN, 0, NULL);
#endif
	return ret;
	}

#ifndef OPENSSL_NO_HEARTBEATS
int
dtls1_process_heartbeat(SSL *s)
	{
	unsigned char *p = &s->s3->rrec.data[0], *pl;
	unsigned short hbtype;
	unsigned int payload;
	unsigned int padding = 16; /* Use minimum padding */

	/* Read type and payload length first */
	hbtype = *p++;
	n2s(p, payload);
	pl = p;

	if (s->msg_callback)
		s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
			&s->s3->rrec.data[0], s->s3->rrec.length,
			s, s->msg_callback_arg);

	if (hbtype == TLS1_HB_REQUEST)
		{
		unsigned char *buffer, *bp;
		int r;

		/* Allocate memory for the response, size is 1 byte
		 * message type, plus 2 bytes payload length, plus
		 * payload, plus padding
		 */
		buffer = OPENSSL_malloc(1 + 2 + payload + padding);
		bp = buffer;

		/* Enter response type, length and copy payload */
		*bp++ = TLS1_HB_RESPONSE;
		s2n(payload, bp);
		memcpy(bp, pl, payload);
		bp += payload;
		/* Random padding */
		RAND_pseudo_bytes(bp, padding);

		r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);

		if (r >= 0 && s->msg_callback)
			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
				buffer, 3 + payload + padding,
				s, s->msg_callback_arg);

		OPENSSL_free(buffer);

		if (r < 0)
			return r;
		}
	else if (hbtype == TLS1_HB_RESPONSE)
		{
		unsigned int seq;

		/* We only send sequence numbers (2 bytes unsigned int),
		 * and 16 random bytes, so we just try to read the
		 * sequence number */
		n2s(pl, seq);

		if (payload == 18 && seq == s->tlsext_hb_seq)
			{
			dtls1_stop_timer(s);
			s->tlsext_hb_seq++;
			s->tlsext_hb_pending = 0;
			}
		}

	return 0;
	}

int
dtls1_heartbeat(SSL *s)
	{
	unsigned char *buf, *p;
	int ret;
	unsigned int payload = 18; /* Sequence number + random bytes */
	unsigned int padding = 16; /* Use minimum padding */

	/* Only send if peer supports and accepts HB requests... */
	if (!(s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED) ||
	    s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_SEND_REQUESTS)
		{
		SSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT);
		return -1;
		}

	/* ...and there is none in flight yet... */
	if (s->tlsext_hb_pending)
		{
		SSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PENDING);
		return -1;
		}

	/* ...and no handshake in progress. */
	if (SSL_in_init(s) || s->in_handshake)
		{
		SSLerr(SSL_F_DTLS1_HEARTBEAT,SSL_R_UNEXPECTED_MESSAGE);
		return -1;
		}

	/* Check if padding is too long, payload and padding
	 * must not exceed 2^14 - 3 = 16381 bytes in total.
	 */
	OPENSSL_assert(payload + padding <= 16381);

	/* Create HeartBeat message, we just use a sequence number
	 * as payload to distuingish different messages and add
	 * some random stuff.
	 *  - Message Type, 1 byte
	 *  - Payload Length, 2 bytes (unsigned int)
	 *  - Payload, the sequence number (2 bytes uint)
	 *  - Payload, random bytes (16 bytes uint)
	 *  - Padding
	 */
	buf = OPENSSL_malloc(1 + 2 + payload + padding);
	p = buf;
	/* Message Type */
	*p++ = TLS1_HB_REQUEST;
	/* Payload length (18 bytes here) */
	s2n(payload, p);
	/* Sequence number */
	s2n(s->tlsext_hb_seq, p);
	/* 16 random bytes */
	RAND_pseudo_bytes(p, 16);
	p += 16;
	/* Random padding */
	RAND_pseudo_bytes(p, padding);

	ret = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buf, 3 + payload + padding);
	if (ret >= 0)
		{
		if (s->msg_callback)
			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
				buf, 3 + payload + padding,
				s, s->msg_callback_arg);

		dtls1_start_timer(s);
		s->tlsext_hb_pending = 1;
		}

	OPENSSL_free(buf);

	return ret;
	}
#endif
@


1.1.1.6
log
@Import OpenSSL 1.0.1g
@
text
@a216 6

	if (frag->msg_header.is_ccs)
		{
		EVP_CIPHER_CTX_free(frag->msg_header.saved_retransmit_state.enc_write_ctx);
		EVP_MD_CTX_destroy(frag->msg_header.saved_retransmit_state.write_hash);
		}
d316 3
a318 4
				if ( s->init_num > curr_mtu)
					len = curr_mtu;
				else
					len = s->init_num;
d1455 5
a1464 9
	/* Read type and payload length first */
	if (1 + 2 + 16 > s->s3->rrec.length)
		return 0; /* silently discard */
	hbtype = *p++;
	n2s(p, payload);
	if (1 + 2 + payload + 16 > s->s3->rrec.length)
		return 0; /* silently discard per RFC 6520 sec. 4 */
	pl = p;

a1467 3
		unsigned int write_length = 1 /* heartbeat type */ +
					    2 /* heartbeat length */ +
					    payload + padding;
a1469 3
		if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
			return 0;

d1474 1
a1474 1
		buffer = OPENSSL_malloc(write_length);
d1485 1
a1485 1
		r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
d1489 1
a1489 1
				buffer, write_length,
@


1.1.1.5.4.1
log
@MFC:
cherrypick fix for CVE-2014-0160 "heartbleed" vulnerability from
OpenSSL git; ok sthen@@
@
text
@d1455 5
a1464 9
	/* Read type and payload length first */
	if (1 + 2 + 16 > s->s3->rrec.length)
		return 0; /* silently discard */
	hbtype = *p++;
	n2s(p, payload);
	if (1 + 2 + payload + 16 > s->s3->rrec.length)
		return 0; /* silently discard per RFC 6520 sec. 4 */
	pl = p;

a1467 3
		unsigned int write_length = 1 /* heartbeat type */ +
					    2 /* heartbeat length */ +
					    payload + padding;
a1469 3
		if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
			return 0;

d1474 1
a1474 1
		buffer = OPENSSL_malloc(write_length);
d1485 1
a1485 1
		r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
d1489 1
a1489 1
				buffer, write_length,
@


1.1.1.5.4.2
log
@MFC DTLS "Hello Request" fix (CVE-2014-0221)

"Do not recurse when a 'Hello Request' message is received while getting
DTLS fragments. A stream of 'Hello Request' messages will result in
infinite recursion, eventually crashing the DTLS client or server.
Fixes CVE-2014-0221, from OpenSSL.  Reported to OpenSSL by Imre Rad."
From d1_both.c r1.20
@
text
@a779 1
again:
d838 2
a839 1
			goto again;
@


1.1.1.5.4.3
log
@MFC DTLS buffer overflow fix (CVE-2014-0195)

"Avoid a buffer overflow that can be triggered by sending specially crafted
DTLS fragments. Fix for CVE-2014-0195, from OpenSSL. Reported to OpenSSL
by Juri Aedla." From d1_both.c r1.19
@
text
@d622 1
a622 1
	else {
a623 6
		if (frag->msg_header.msg_len != msg_hdr->msg_len) {
			item = NULL;
			frag = NULL;
			goto err;
		}
	}
@


1.1.1.5.4.4
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@a582 10
/* dtls1_max_handshake_message_len returns the maximum number of bytes
 * permitted in a DTLS handshake message for |s|. The minimum is 16KB, but may
 * be greater if the maximum certificate list size requires it. */
static unsigned long dtls1_max_handshake_message_len(const SSL *s)
	{
	unsigned long max_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;
	if (max_len < (unsigned long)s->max_cert_list)
		return s->max_cert_list;
	return max_len;
	}
d585 1
a585 1
dtls1_reassemble_fragment(SSL *s, const struct hm_header_st* msg_hdr, int *ok)
d591 1
a591 1
	unsigned long frag_len = msg_hdr->frag_len;
d593 1
a593 2
	if ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len ||
	    msg_hdr->msg_len > dtls1_max_handshake_message_len(s))
d596 10
a605 2
	if (frag_len == 0)
		return DTLS1_HM_FRAGMENT_RETRY;
d632 1
a632 2
	 * retransmit and can be dropped. In this case item != NULL and so frag
	 * does not need to be freed.
d652 1
a652 3
	if ((unsigned long)i!=frag_len)
		i=-1;
	if (i<=0)
d669 4
d680 1
a680 6
		item = pqueue_insert(s->d1->buffered_messages, item);
		/* pqueue_insert fails iff a duplicate item is inserted.
		 * However, |item| cannot be a duplicate. If it were,
		 * |pqueue_find|, above, would have returned it and control
		 * would never have reached this branch. */
		OPENSSL_assert(item != NULL);
d686 2
a687 1
	if (frag != NULL && item == NULL) dtls1_hm_fragment_free(frag);
d694 1
a694 1
dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st* msg_hdr, int *ok)
d714 1
a714 1
	if (item != NULL && frag_len != msg_hdr->msg_len)
d739 1
a739 1
		if (frag_len != msg_hdr->msg_len)
a741 3
		if (frag_len > dtls1_max_handshake_message_len(s))
			goto err;

d753 1
a753 3
			if ((unsigned long)i!=frag_len)
				i = -1;
			if (i<=0)
d757 4
d765 1
a765 9
		item = pqueue_insert(s->d1->buffered_messages, item);
		/* pqueue_insert fails iff a duplicate item is inserted.
		 * However, |item| cannot be a duplicate. If it were,
		 * |pqueue_find|, above, would have returned it. Then, either
		 * |frag_len| != |msg_hdr->msg_len| in which case |item| is set
		 * to NULL and it will have been processed with
		 * |dtls1_reassemble_fragment|, above, or the record will have
		 * been discarded. */
		OPENSSL_assert(item != NULL);
d771 2
a772 1
	if (frag != NULL && item == NULL) dtls1_hm_fragment_free(frag);
a1172 2
	if (!frag)
		return 0;
@


1.1.1.5.2.1
log
@MFC:
cherrypick fix for CVE-2014-0160 "heartbleed" vulnerability from
OpenSSL git; ok sthen@@
@
text
@d1455 5
a1464 9
	/* Read type and payload length first */
	if (1 + 2 + 16 > s->s3->rrec.length)
		return 0; /* silently discard */
	hbtype = *p++;
	n2s(p, payload);
	if (1 + 2 + payload + 16 > s->s3->rrec.length)
		return 0; /* silently discard per RFC 6520 sec. 4 */
	pl = p;

a1467 3
		unsigned int write_length = 1 /* heartbeat type */ +
					    2 /* heartbeat length */ +
					    payload + padding;
a1469 3
		if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
			return 0;

d1474 1
a1474 1
		buffer = OPENSSL_malloc(write_length);
d1485 1
a1485 1
		r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
d1489 1
a1489 1
				buffer, write_length,
@


