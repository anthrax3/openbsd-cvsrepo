head	1.125;
access;
symbols
	OPENBSD_6_1:1.115.0.4
	OPENBSD_6_1_BASE:1.115;
locks; strict;
comment	@ * @;


1.125
date	2017.08.11.05.06.34;	author doug;	state Exp;
branches;
next	1.124;
commitid	d4zLZL34eKazbGrN;

1.124
date	2017.08.10.17.18.38;	author jsing;	state Exp;
branches;
next	1.123;
commitid	dKulPy2Ty6efAQYX;

1.123
date	2017.08.09.22.24.25;	author jsing;	state Exp;
branches;
next	1.122;
commitid	3OyBuKgMOSBVJcjR;

1.122
date	2017.07.24.17.39.43;	author jsing;	state Exp;
branches;
next	1.121;
commitid	DnBYr6IzlxF246Rk;

1.121
date	2017.07.24.17.10.31;	author jsing;	state Exp;
branches;
next	1.120;
commitid	R1xjgozDDdxwLxCa;

1.120
date	2017.07.23.16.27.44;	author jsing;	state Exp;
branches;
next	1.119;
commitid	UI4NWzBTaYxq05XX;

1.119
date	2017.07.19.17.45.31;	author jsing;	state Exp;
branches;
next	1.118;
commitid	XZUCNlc2MLTbhZV0;

1.118
date	2017.07.16.18.14.37;	author jsing;	state Exp;
branches;
next	1.117;
commitid	x7hgjU5VqATSUFb2;

1.117
date	2017.05.07.04.22.24;	author beck;	state Exp;
branches;
next	1.116;
commitid	lvbt7GJEb5w5u0NS;

1.116
date	2017.05.06.22.24.58;	author beck;	state Exp;
branches;
next	1.115;
commitid	caPZfWYl80TRorLe;

1.115
date	2017.02.07.02.08.38;	author beck;	state Exp;
branches;
next	1.114;
commitid	xH3OeartUDKSlAnB;

1.114
date	2017.01.26.12.16.13;	author beck;	state Exp;
branches;
next	1.113;
commitid	lb4UTPLS9Casn2PL;

1.113
date	2017.01.26.10.40.21;	author beck;	state Exp;
branches;
next	1.112;
commitid	Bi1VygMenL4YtCp7;

1.112
date	2017.01.26.06.32.58;	author jsing;	state Exp;
branches;
next	1.111;
commitid	TbFBd2VdEVckCCsd;

1.111
date	2017.01.24.14.57.31;	author jsing;	state Exp;
branches;
next	1.110;
commitid	nQzaI20w3vrSZN0L;

1.110
date	2017.01.24.12.24.07;	author jsing;	state Exp;
branches;
next	1.109;
commitid	rD7MgIvGZvZLjxul;

1.109
date	2017.01.24.09.03.21;	author jsing;	state Exp;
branches;
next	1.108;
commitid	NTZJ3rEptTLCIZDB;

1.108
date	2017.01.24.08.41.53;	author jsing;	state Exp;
branches;
next	1.107;
commitid	iZySmo9ReKRIeYdP;

1.107
date	2017.01.24.03.41.43;	author jsing;	state Exp;
branches;
next	1.106;
commitid	cZWWaflOgFdha5C9;

1.106
date	2017.01.23.14.35.42;	author jsing;	state Exp;
branches;
next	1.105;
commitid	fvePj4ki9zOwq3SB;

1.105
date	2017.01.23.13.36.13;	author jsing;	state Exp;
branches;
next	1.104;
commitid	xYJ523Ay020rUB5W;

1.104
date	2017.01.23.08.48.45;	author beck;	state Exp;
branches;
next	1.103;
commitid	vAKES6VByBpegTl4;

1.103
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.102;
commitid	grTXB43OAHDwwKOU;

1.102
date	2017.01.23.05.13.02;	author jsing;	state Exp;
branches;
next	1.101;
commitid	XWcFqNClp2MoKERU;

1.101
date	2017.01.23.04.55.27;	author beck;	state Exp;
branches;
next	1.100;
commitid	AhwkqHI5lKK3NR31;

1.100
date	2017.01.23.04.15.28;	author jsing;	state Exp;
branches;
next	1.99;
commitid	j20UnjrPw7WvzMvm;

1.99
date	2017.01.22.09.02.07;	author jsing;	state Exp;
branches;
next	1.98;
commitid	570ElYZpaAvthwZh;

1.98
date	2017.01.22.06.36.49;	author jsing;	state Exp;
branches;
next	1.97;
commitid	jkexAOoo4I6xT9SH;

1.97
date	2017.01.22.05.14.42;	author beck;	state Exp;
branches;
next	1.96;
commitid	cQZFlJKgRV0smF3Q;

1.96
date	2016.12.21.16.44.31;	author jsing;	state Exp;
branches;
next	1.95;
commitid	QsxdTGoZtELBjsxp;

1.95
date	2016.12.18.13.52.53;	author jsing;	state Exp;
branches;
next	1.94;
commitid	SZGgsYK419MoSxtG;

1.94
date	2016.11.05.08.26.37;	author jsing;	state Exp;
branches;
next	1.93;
commitid	PesnxNxHCgdr6Tvs;

1.93
date	2016.10.19.16.38.40;	author jsing;	state Exp;
branches;
next	1.92;
commitid	zBSqJxdzZYua3a3I;

1.92
date	2016.10.02.21.18.08;	author guenther;	state Exp;
branches;
next	1.91;
commitid	70x6yK7Bv7PXlG74;

1.91
date	2016.10.02.21.05.44;	author guenther;	state Exp;
branches;
next	1.90;
commitid	iAWPATMpSNg6Gvxq;

1.90
date	2016.09.22.12.33.50;	author jsing;	state Exp;
branches;
next	1.89;
commitid	Q78RkXaSTv893Ma6;

1.89
date	2016.09.22.06.57.40;	author guenther;	state Exp;
branches;
next	1.88;
commitid	79AjCFKRFr9cgam4;

1.88
date	2016.08.27.15.58.06;	author jsing;	state Exp;
branches;
next	1.87;
commitid	8MiQ2PoaMa1G4v5M;

1.87
date	2016.05.30.13.42.54;	author beck;	state Exp;
branches;
next	1.86;
commitid	P66xC6CnwAnLazTN;

1.86
date	2016.03.10.23.21.46;	author mmcc;	state Exp;
branches;
next	1.85;
commitid	F9QEhracBtu6wNVj;

1.85
date	2015.09.12.16.10.08;	author doug;	state Exp;
branches;
next	1.84;
commitid	VR022UcxWVmcgSOF;

1.84
date	2015.09.01.13.38.27;	author jsing;	state Exp;
branches;
next	1.83;
commitid	181x6cJx2ceVnn0a;

1.83
date	2015.08.19.23.34.34;	author bcook;	state Exp;
branches;
next	1.82;
commitid	GuHkqyW8O1uAvcIE;

1.82
date	2015.07.24.07.57.48;	author doug;	state Exp;
branches
	1.82.4.1;
next	1.81;
commitid	XslgAA8i1lseynfs;

1.81
date	2015.07.24.03.50.12;	author doug;	state Exp;
branches;
next	1.80;
commitid	DVTW2xWd2v8vezHt;

1.80
date	2015.07.19.20.32.18;	author doug;	state Exp;
branches;
next	1.79;
commitid	JJGxWtixsF6e0H2B;

1.79
date	2015.07.17.15.50.37;	author doug;	state Exp;
branches;
next	1.78;
commitid	74rjqXo4BbFp9EDU;

1.78
date	2015.06.19.01.38.54;	author doug;	state Exp;
branches;
next	1.77;
commitid	XxWFwYzELaXJAex8;

1.77
date	2015.06.17.07.52.22;	author doug;	state Exp;
branches;
next	1.76;
commitid	9q4u7B2ZkVtWKWbn;

1.76
date	2015.06.17.07.36.30;	author doug;	state Exp;
branches;
next	1.75;
commitid	f1YcIQMEFuhBWAdQ;

1.75
date	2015.03.02.13.43.09;	author jsing;	state Exp;
branches;
next	1.74;
commitid	2eLUEpcxyRAF94J4;

1.74
date	2014.12.14.14.34.43;	author jsing;	state Exp;
branches;
next	1.73;
commitid	JlmRntBjnvBE29Fz;

1.73
date	2014.12.10.15.36.47;	author jsing;	state Exp;
branches;
next	1.72;
commitid	x50cturILyXAfPoH;

1.72
date	2014.12.10.14.58.56;	author jsing;	state Exp;
branches;
next	1.71;
commitid	GHVxpbbDPbCM2xPo;

1.71
date	2014.12.06.13.51.06;	author jsing;	state Exp;
branches;
next	1.70;
commitid	hIBGoSRrWndOvCaU;

1.70
date	2014.12.06.13.28.56;	author jsing;	state Exp;
branches;
next	1.69;
commitid	FHiZoqndsOARuGdr;

1.69
date	2014.12.06.13.21.14;	author jsing;	state Exp;
branches;
next	1.68;
commitid	VBQ4ltdltLkYn23C;

1.68
date	2014.12.02.20.46.19;	author miod;	state Exp;
branches;
next	1.67;
commitid	nNRVhZzSd6fGWrWz;

1.67
date	2014.11.18.05.33.43;	author miod;	state Exp;
branches;
next	1.66;
commitid	81uwsCsokEuKDUjo;

1.66
date	2014.11.03.17.21.30;	author tedu;	state Exp;
branches;
next	1.65;
commitid	5FL57RDn3yo1rtNG;

1.65
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.64;
commitid	cGE1JG2i0h4NcVDi;

1.64
date	2014.10.15.14.02.16;	author jsing;	state Exp;
branches;
next	1.63;
commitid	D7S2QCUq5SNja4lI;

1.63
date	2014.10.05.14.56.32;	author jsing;	state Exp;
branches;
next	1.62;
commitid	kBFmE0GmetxwxMVP;

1.62
date	2014.10.05.14.53.06;	author jsing;	state Exp;
branches;
next	1.61;
commitid	u0mb70c1yq6J6Phs;

1.61
date	2014.10.05.14.47.30;	author jsing;	state Exp;
branches;
next	1.60;
commitid	SBnddcEVBvir15Ei;

1.60
date	2014.10.03.13.58.18;	author jsing;	state Exp;
branches;
next	1.59;
commitid	TTuHOVoRSWSvd6HI;

1.59
date	2014.09.30.15.40.09;	author jsing;	state Exp;
branches;
next	1.58;
commitid	HYNEHWCCpGJW4ziw;

1.58
date	2014.09.27.11.01.06;	author jsing;	state Exp;
branches;
next	1.57;
commitid	pg2itwAdFVptNvwc;

1.57
date	2014.09.26.14.58.42;	author jsing;	state Exp;
branches;
next	1.56;
commitid	ABqrMH5t1zAT8i2j;

1.56
date	2014.09.22.14.26.22;	author jsing;	state Exp;
branches;
next	1.55;
commitid	g152dWuCWm3g3eij;

1.55
date	2014.09.21.17.11.04;	author jsing;	state Exp;
branches;
next	1.54;
commitid	MNvcHFf1nsj9LKgm;

1.54
date	2014.08.07.22.27.28;	author guenther;	state Exp;
branches;
next	1.53;
commitid	nHVirMuMuGgbqtv3;

1.53
date	2014.08.06.23.16.16;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	4tNq70jH1WQU6hOo;

1.52
date	2014.07.13.16.33.01;	author jsing;	state Exp;
branches;
next	1.51;
commitid	JJmX1elDbecM9IzO;

1.51
date	2014.07.13.16.03.10;	author beck;	state Exp;
branches;
next	1.50;
commitid	6xdvCwSqBadTW6X3;

1.50
date	2014.07.12.22.33.39;	author jsing;	state Exp;
branches;
next	1.49;
commitid	JT7oO4AHgBkjVLfZ;

1.49
date	2014.07.09.11.10.51;	author bcook;	state Exp;
branches;
next	1.48;
commitid	lHJTcoC4c5BhEOGj;

1.48
date	2014.06.19.21.29.51;	author tedu;	state Exp;
branches;
next	1.47;
commitid	CIpPjhmVWPbqgxVA;

1.47
date	2014.06.18.04.49.40;	author miod;	state Exp;
branches;
next	1.46;
commitid	hyW8FZIwVHMLqxzw;

1.46
date	2014.06.13.04.29.13;	author miod;	state Exp;
branches;
next	1.45;
commitid	8Qu6YceLSxhOi4yG;

1.45
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	mJUVYpkFBZ0Zv2bG;

1.44
date	2014.06.04.21.05.30;	author miod;	state Exp;
branches;
next	1.43;
commitid	BBqv4EJ8r3KvbYYE;

1.43
date	2014.06.04.14.10.23;	author tedu;	state Exp;
branches;
next	1.42;
commitid	GMbAFZ4Hukhh97U1;

1.42
date	2014.05.31.10.53.39;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.30.14.01.11;	author jsing;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.29.18.11.13;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2014.05.29.16.00.16;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2014.05.28.13.03.25;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2014.05.26.20.54.06;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2014.05.26.20.11.27;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.24.16.06.28;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2014.05.24.15.21.40;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.24.15.18.58;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.22.11.48.49;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.19.20.09.15;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.26.22.54.54;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.18.21.19.20;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.17.21.15.37;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.20.34.24;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.17.13.37.50;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.16.20.39.09;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.16.18.05.55;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.16.17.59.17;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.14.13.30.33;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.07.23.57.27;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2013.02.14.15.11.44;	author markus;	state Exp;
branches
	1.12.2.1
	1.12.4.1
	1.12.8.1;
next	1.11;

1.11
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2011.02.10.22.40.27;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.17.19.09.32;	author jasper;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches
	1.5.4.1
	1.5.8.1;
next	1.4;

1.4
date	2008.09.06.12.17.54;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.35;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.31;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.12;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.44;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2011.11.03.02.32.21;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2012.01.05.22.59.10;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2012.10.13.21.23.50;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.5.4.1
date	2010.11.17.19.14.21;	author jasper;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2011.02.11.03.23.38;	author djm;	state Exp;
branches;
next	;

1.5.8.1
date	2010.11.17.19.12.56;	author jasper;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2011.02.11.03.24.28;	author djm;	state Exp;
branches;
next	;

1.12.2.1
date	2014.04.08.00.55.03;	author djm;	state Exp;
branches;
next	;

1.12.4.1
date	2014.04.08.00.55.23;	author djm;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	1.12.4.3;
commitid	M9vFauFXshUDHG4j;

1.12.4.3
date	2014.10.19.16.21.56;	author tedu;	state Exp;
branches;
next	;
commitid	GrEje0Z4TDO3Yx0d;

1.12.8.1
date	2014.04.08.00.55.39;	author djm;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2014.08.09.16.54.58;	author tedu;	state Exp;
branches;
next	1.12.8.3;
commitid	iDBdpZ9JdHGZqIAL;

1.12.8.3
date	2014.10.19.16.21.04;	author tedu;	state Exp;
branches;
next	;
commitid	P1Mj4xFbkJxaKkV0;

1.82.4.1
date	2015.08.28.16.31.42;	author jsing;	state Exp;
branches;
next	;
commitid	yCjDs4Ua8G3GbA6l;


desc
@@


1.125
log
@Rewrite the ECPointFormats TLS extension handling using CBB/CBS and the
new extension framework.

input + ok jsing@@
@
text
@/* $OpenBSD: t1_lib.c,v 1.124 2017/08/10 17:18:38 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>

#include <openssl/evp.h>
#include <openssl/hmac.h>
#include <openssl/objects.h>
#include <openssl/ocsp.h>

#include "ssl_locl.h"

#include "bytestring.h"
#include "ssl_tlsext.h"

static int tls_decrypt_ticket(SSL *s, const unsigned char *tick, int ticklen,
    const unsigned char *sess_id, int sesslen,
    SSL_SESSION **psess);

SSL3_ENC_METHOD TLSv1_enc_data = {
	.enc = tls1_enc,
	.enc_flags = 0,
};

SSL3_ENC_METHOD TLSv1_1_enc_data = {
	.enc = tls1_enc,
	.enc_flags = SSL_ENC_FLAG_EXPLICIT_IV,
};

SSL3_ENC_METHOD TLSv1_2_enc_data = {
	.enc = tls1_enc,
	.enc_flags = SSL_ENC_FLAG_EXPLICIT_IV|SSL_ENC_FLAG_SIGALGS|
	    SSL_ENC_FLAG_SHA256_PRF|SSL_ENC_FLAG_TLS1_2_CIPHERS,
};

long
tls1_default_timeout(void)
{
	/* 2 hours, the 24 hours mentioned in the TLSv1 spec
	 * is way too long for http, the cache would over fill */
	return (60 * 60 * 2);
}

int
tls1_new(SSL *s)
{
	if (!ssl3_new(s))
		return (0);
	s->method->internal->ssl_clear(s);
	return (1);
}

void
tls1_free(SSL *s)
{
	if (s == NULL)
		return;

	free(s->internal->tlsext_session_ticket);
	ssl3_free(s);
}

void
tls1_clear(SSL *s)
{
	ssl3_clear(s);
	s->version = s->method->internal->version;
}

static int nid_list[] = {
	NID_sect163k1,		/* sect163k1 (1) */
	NID_sect163r1,		/* sect163r1 (2) */
	NID_sect163r2,		/* sect163r2 (3) */
	NID_sect193r1,		/* sect193r1 (4) */
	NID_sect193r2,		/* sect193r2 (5) */
	NID_sect233k1,		/* sect233k1 (6) */
	NID_sect233r1,		/* sect233r1 (7) */
	NID_sect239k1,		/* sect239k1 (8) */
	NID_sect283k1,		/* sect283k1 (9) */
	NID_sect283r1,		/* sect283r1 (10) */
	NID_sect409k1,		/* sect409k1 (11) */
	NID_sect409r1,		/* sect409r1 (12) */
	NID_sect571k1,		/* sect571k1 (13) */
	NID_sect571r1,		/* sect571r1 (14) */
	NID_secp160k1,		/* secp160k1 (15) */
	NID_secp160r1,		/* secp160r1 (16) */
	NID_secp160r2,		/* secp160r2 (17) */
	NID_secp192k1,		/* secp192k1 (18) */
	NID_X9_62_prime192v1,	/* secp192r1 (19) */
	NID_secp224k1,		/* secp224k1 (20) */
	NID_secp224r1,		/* secp224r1 (21) */
	NID_secp256k1,		/* secp256k1 (22) */
	NID_X9_62_prime256v1,	/* secp256r1 (23) */
	NID_secp384r1,		/* secp384r1 (24) */
	NID_secp521r1,		/* secp521r1 (25) */
	NID_brainpoolP256r1,	/* brainpoolP256r1 (26) */
	NID_brainpoolP384r1,	/* brainpoolP384r1 (27) */
	NID_brainpoolP512r1,	/* brainpoolP512r1 (28) */
	NID_X25519,		/* X25519 (29) */
};

#if 0
static const uint8_t ecformats_list[] = {
	TLSEXT_ECPOINTFORMAT_uncompressed,
	TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime,
	TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2
};
#endif

static const uint8_t ecformats_default[] = {
	TLSEXT_ECPOINTFORMAT_uncompressed,
};

#if 0
static const uint16_t eccurves_list[] = {
	29,			/* X25519 (29) */
	14,			/* sect571r1 (14) */
	13,			/* sect571k1 (13) */
	25,			/* secp521r1 (25) */
	28,			/* brainpoolP512r1 (28) */
	11,			/* sect409k1 (11) */
	12,			/* sect409r1 (12) */
	27,			/* brainpoolP384r1 (27) */
	24,			/* secp384r1 (24) */
	9,			/* sect283k1 (9) */
	10,			/* sect283r1 (10) */
	26,			/* brainpoolP256r1 (26) */
	22,			/* secp256k1 (22) */
	23,			/* secp256r1 (23) */
	8,			/* sect239k1 (8) */
	6,			/* sect233k1 (6) */
	7,			/* sect233r1 (7) */
	20,			/* secp224k1 (20) */
	21,			/* secp224r1 (21) */
	4,			/* sect193r1 (4) */
	5,			/* sect193r2 (5) */
	18,			/* secp192k1 (18) */
	19,			/* secp192r1 (19) */
	1,			/* sect163k1 (1) */
	2,			/* sect163r1 (2) */
	3,			/* sect163r2 (3) */
	15,			/* secp160k1 (15) */
	16,			/* secp160r1 (16) */
	17,			/* secp160r2 (17) */
};
#endif

static const uint16_t eccurves_default[] = {
	29,			/* X25519 (29) */
	23,			/* secp256r1 (23) */
	24,			/* secp384r1 (24) */
};

int
tls1_ec_curve_id2nid(const uint16_t curve_id)
{
	/* ECC curves from draft-ietf-tls-ecc-12.txt (Oct. 17, 2005) */
	if ((curve_id < 1) ||
	    ((unsigned int)curve_id > sizeof(nid_list) / sizeof(nid_list[0])))
		return 0;
	return nid_list[curve_id - 1];
}

uint16_t
tls1_ec_nid2curve_id(int nid)
{
	/* ECC curves from draft-ietf-tls-ecc-12.txt (Oct. 17, 2005) */
	switch (nid) {
	case NID_sect163k1: /* sect163k1 (1) */
		return 1;
	case NID_sect163r1: /* sect163r1 (2) */
		return 2;
	case NID_sect163r2: /* sect163r2 (3) */
		return 3;
	case NID_sect193r1: /* sect193r1 (4) */
		return 4;
	case NID_sect193r2: /* sect193r2 (5) */
		return 5;
	case NID_sect233k1: /* sect233k1 (6) */
		return 6;
	case NID_sect233r1: /* sect233r1 (7) */
		return 7;
	case NID_sect239k1: /* sect239k1 (8) */
		return 8;
	case NID_sect283k1: /* sect283k1 (9) */
		return 9;
	case NID_sect283r1: /* sect283r1 (10) */
		return 10;
	case NID_sect409k1: /* sect409k1 (11) */
		return 11;
	case NID_sect409r1: /* sect409r1 (12) */
		return 12;
	case NID_sect571k1: /* sect571k1 (13) */
		return 13;
	case NID_sect571r1: /* sect571r1 (14) */
		return 14;
	case NID_secp160k1: /* secp160k1 (15) */
		return 15;
	case NID_secp160r1: /* secp160r1 (16) */
		return 16;
	case NID_secp160r2: /* secp160r2 (17) */
		return 17;
	case NID_secp192k1: /* secp192k1 (18) */
		return 18;
	case NID_X9_62_prime192v1: /* secp192r1 (19) */
		return 19;
	case NID_secp224k1: /* secp224k1 (20) */
		return 20;
	case NID_secp224r1: /* secp224r1 (21) */
		return 21;
	case NID_secp256k1: /* secp256k1 (22) */
		return 22;
	case NID_X9_62_prime256v1: /* secp256r1 (23) */
		return 23;
	case NID_secp384r1: /* secp384r1 (24) */
		return 24;
	case NID_secp521r1: /* secp521r1 (25) */
		return 25;
	case NID_brainpoolP256r1: /* brainpoolP256r1 (26) */
		return 26;
	case NID_brainpoolP384r1: /* brainpoolP384r1 (27) */
		return 27;
	case NID_brainpoolP512r1: /* brainpoolP512r1 (28) */
		return 28;
	case NID_X25519:		/* X25519 (29) */
		return 29;
	default:
		return 0;
	}
}

/*
 * Return the appropriate format list. If client_formats is non-zero, return
 * the client/session formats. Otherwise return the custom format list if one
 * exists, or the default formats if a custom list has not been specified.
 */
void
tls1_get_formatlist(SSL *s, int client_formats, const uint8_t **pformats,
    size_t *pformatslen)
{
	if (client_formats != 0) {
		*pformats = SSI(s)->tlsext_ecpointformatlist;
		*pformatslen = SSI(s)->tlsext_ecpointformatlist_length;
		return;
	}

	*pformats = s->internal->tlsext_ecpointformatlist;
	*pformatslen = s->internal->tlsext_ecpointformatlist_length;
	if (*pformats == NULL) {
		*pformats = ecformats_default;
		*pformatslen = sizeof(ecformats_default);
	}
}

/*
 * Return the appropriate curve list. If client_curves is non-zero, return
 * the client/session curves. Otherwise return the custom curve list if one
 * exists, or the default curves if a custom list has not been specified.
 */
static void
tls1_get_curvelist(SSL *s, int client_curves, const uint16_t **pcurves,
    size_t *pcurveslen)
{
	if (client_curves != 0) {
		*pcurves = SSI(s)->tlsext_supportedgroups;
		*pcurveslen = SSI(s)->tlsext_supportedgroups_length;
		return;
	}

	*pcurves = s->internal->tlsext_supportedgroups;
	*pcurveslen = s->internal->tlsext_supportedgroups_length;
	if (*pcurves == NULL) {
		*pcurves = eccurves_default;
		*pcurveslen = sizeof(eccurves_default) / 2;
	}
}

int
tls1_set_groups(uint16_t **out_group_ids, size_t *out_group_ids_len,
    const int *groups, size_t ngroups)
{
	uint16_t *group_ids;
	size_t i;

	group_ids = calloc(ngroups, sizeof(uint16_t));
	if (group_ids == NULL)
		return 0;

	for (i = 0; i < ngroups; i++) {
		group_ids[i] = tls1_ec_nid2curve_id(groups[i]);
		if (group_ids[i] == 0) {
			free(group_ids);
			return 0;
		}
	}

	free(*out_group_ids);
	*out_group_ids = group_ids;
	*out_group_ids_len = ngroups;

	return 1;
}

int
tls1_set_groups_list(uint16_t **out_group_ids, size_t *out_group_ids_len,
    const char *groups)
{
	uint16_t *new_group_ids, *group_ids = NULL;
	size_t ngroups = 0;
	char *gs, *p, *q;
	int nid;

	if ((gs = strdup(groups)) == NULL)
		return 0;

	q = gs;
	while ((p = strsep(&q, ":")) != NULL) {
		nid = OBJ_sn2nid(p);
		if (nid == NID_undef)
			nid = OBJ_ln2nid(p);
		if (nid == NID_undef)
			nid = EC_curve_nist2nid(p);
		if (nid == NID_undef)
			goto err;

		if ((new_group_ids = reallocarray(group_ids, ngroups + 1,
		    sizeof(uint16_t))) == NULL)
			goto err;
		group_ids = new_group_ids;

		group_ids[ngroups] = tls1_ec_nid2curve_id(nid);
		if (group_ids[ngroups] == 0)
			goto err;

		ngroups++;
	}

	free(gs);
	free(*out_group_ids);
	*out_group_ids = group_ids;
	*out_group_ids_len = ngroups;

	return 1;

 err:
	free(gs);
	free(group_ids);

	return 0;
}

/* Check that a curve is one of our preferences. */
int
tls1_check_curve(SSL *s, const uint16_t curve_id)
{
	const uint16_t *curves;
	size_t curveslen, i;

	tls1_get_curvelist(s, 0, &curves, &curveslen);

	for (i = 0; i < curveslen; i++) {
		if (curves[i] == curve_id)
			return (1);
	}
	return (0);
}

int
tls1_get_shared_curve(SSL *s)
{
	size_t preflen, supplen, i, j;
	const uint16_t *pref, *supp;
	unsigned long server_pref;

	/* Cannot do anything on the client side. */
	if (s->server == 0)
		return (NID_undef);

	/* Return first preference shared curve. */
	server_pref = (s->internal->options & SSL_OP_CIPHER_SERVER_PREFERENCE);
	tls1_get_curvelist(s, (server_pref == 0), &pref, &preflen);
	tls1_get_curvelist(s, (server_pref != 0), &supp, &supplen);

	for (i = 0; i < preflen; i++) {
		for (j = 0; j < supplen; j++) {
			if (pref[i] == supp[j])
				return (tls1_ec_curve_id2nid(pref[i]));
		}
	}
	return (NID_undef);
}

/* For an EC key set TLS ID and required compression based on parameters. */
static int
tls1_set_ec_id(uint16_t *curve_id, uint8_t *comp_id, EC_KEY *ec)
{
	const EC_GROUP *grp;
	const EC_METHOD *meth;
	int is_prime = 0;
	int nid, id;

	if (ec == NULL)
		return (0);

	/* Determine if it is a prime field. */
	if ((grp = EC_KEY_get0_group(ec)) == NULL)
		return (0);
	if ((meth = EC_GROUP_method_of(grp)) == NULL)
		return (0);
	if (EC_METHOD_get_field_type(meth) == NID_X9_62_prime_field)
		is_prime = 1;

	/* Determine curve ID. */
	nid = EC_GROUP_get_curve_name(grp);
	id = tls1_ec_nid2curve_id(nid);

	/* If we have an ID set it, otherwise set arbitrary explicit curve. */
	if (id != 0)
		*curve_id = id;
	else
		*curve_id = is_prime ? 0xff01 : 0xff02;

	/* Specify the compression identifier. */
	if (comp_id != NULL) {
		if (EC_KEY_get0_public_key(ec) == NULL)
			return (0);

		if (EC_KEY_get_conv_form(ec) == POINT_CONVERSION_COMPRESSED) {
			*comp_id = is_prime ?
			    TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime :
			    TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2;
		} else {
			*comp_id = TLSEXT_ECPOINTFORMAT_uncompressed;
		}
	}
	return (1);
}

/* Check that an EC key is compatible with extensions. */
static int
tls1_check_ec_key(SSL *s, const uint16_t *curve_id, const uint8_t *comp_id)
{
	size_t curveslen, formatslen, i;
	const uint16_t *curves;
	const uint8_t *formats;

	/*
	 * Check point formats extension if present, otherwise everything
	 * is supported (see RFC4492).
	 */
	tls1_get_formatlist(s, 1, &formats, &formatslen);
	if (comp_id != NULL && formats != NULL) {
		for (i = 0; i < formatslen; i++) {
			if (formats[i] == *comp_id)
				break;
		}
		if (i == formatslen)
			return (0);
	}

	/*
	 * Check curve list if present, otherwise everything is supported.
	 */
	tls1_get_curvelist(s, 1, &curves, &curveslen);
	if (curve_id != NULL && curves != NULL) {
		for (i = 0; i < curveslen; i++) {
			if (curves[i] == *curve_id)
				break;
		}
		if (i == curveslen)
			return (0);
	}

	return (1);
}

/* Check EC server key is compatible with client extensions. */
int
tls1_check_ec_server_key(SSL *s)
{
	CERT_PKEY *cpk = s->cert->pkeys + SSL_PKEY_ECC;
	uint16_t curve_id;
	uint8_t comp_id;
	EVP_PKEY *pkey;
	int rv;

	if (cpk->x509 == NULL || cpk->privatekey == NULL)
		return (0);
	if ((pkey = X509_get_pubkey(cpk->x509)) == NULL)
		return (0);
	rv = tls1_set_ec_id(&curve_id, &comp_id, pkey->pkey.ec);
	EVP_PKEY_free(pkey);
	if (rv != 1)
		return (0);

	return tls1_check_ec_key(s, &curve_id, &comp_id);
}

/* Check EC temporary key is compatible with client extensions. */
int
tls1_check_ec_tmp_key(SSL *s)
{
	EC_KEY *ec = s->cert->ecdh_tmp;
	uint16_t curve_id;

	/* Need a shared curve. */
	if (tls1_get_shared_curve(s) != NID_undef)
		return (1);

	if (ec == NULL)
		return (0);

	if (tls1_set_ec_id(&curve_id, NULL, ec) != 1)
		return (0);

	return tls1_check_ec_key(s, &curve_id, NULL);
}

/*
 * List of supported signature algorithms and hashes. Should make this
 * customisable at some point, for now include everything we support.
 */

static unsigned char tls12_sigalgs[] = {
	TLSEXT_hash_sha512, TLSEXT_signature_rsa,
	TLSEXT_hash_sha512, TLSEXT_signature_dsa,
	TLSEXT_hash_sha512, TLSEXT_signature_ecdsa,
#ifndef OPENSSL_NO_GOST
	TLSEXT_hash_streebog_512, TLSEXT_signature_gostr12_512,
#endif

	TLSEXT_hash_sha384, TLSEXT_signature_rsa,
	TLSEXT_hash_sha384, TLSEXT_signature_dsa,
	TLSEXT_hash_sha384, TLSEXT_signature_ecdsa,

	TLSEXT_hash_sha256, TLSEXT_signature_rsa,
	TLSEXT_hash_sha256, TLSEXT_signature_dsa,
	TLSEXT_hash_sha256, TLSEXT_signature_ecdsa,

#ifndef OPENSSL_NO_GOST
	TLSEXT_hash_streebog_256, TLSEXT_signature_gostr12_256,
	TLSEXT_hash_gost94, TLSEXT_signature_gostr01,
#endif

	TLSEXT_hash_sha224, TLSEXT_signature_rsa,
	TLSEXT_hash_sha224, TLSEXT_signature_dsa,
	TLSEXT_hash_sha224, TLSEXT_signature_ecdsa,

	TLSEXT_hash_sha1, TLSEXT_signature_rsa,
	TLSEXT_hash_sha1, TLSEXT_signature_dsa,
	TLSEXT_hash_sha1, TLSEXT_signature_ecdsa,
};

int
tls12_get_req_sig_algs(SSL *s, unsigned char *p)
{
	size_t slen = sizeof(tls12_sigalgs);

	if (p)
		memcpy(p, tls12_sigalgs, slen);
	return (int)slen;
}

unsigned char *
ssl_add_clienthello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
{
	int extdatalen = 0;
	unsigned char *ret = p;
	int using_ecc;
	size_t len;
	CBB cbb;

	using_ecc = ssl_has_ecc_ciphers(s);

	ret += 2;
	if (ret >= limit)
		return NULL; /* this really never occurs, but ... */

	if (!CBB_init_fixed(&cbb, ret, limit - ret))
		return NULL;
	if (!tlsext_clienthello_build(s, &cbb)) {
		CBB_cleanup(&cbb);
		return NULL;
	}
	if (!CBB_finish(&cbb, NULL, &len)) {
		CBB_cleanup(&cbb);
		return NULL;
	}
	if (len > (limit - ret))
		return NULL;
	ret += len;

	if (using_ecc) {
		size_t curveslen, lenmax;
		const uint16_t *curves;
		int i;

		/*
		 * Add TLS extension EllipticCurves to the ClientHello message.
		 */
		tls1_get_curvelist(s, 0, &curves, &curveslen);

		if ((size_t)(limit - ret) < 6)
			return NULL;

		lenmax = limit - ret - 6;
		if (curveslen * 2 > lenmax)
			return NULL;
		if (curveslen * 2 > 65532) {
			SSLerror(s, ERR_R_INTERNAL_ERROR);
			return NULL;
		}

		s2n(TLSEXT_TYPE_elliptic_curves, ret);
		s2n((curveslen * 2) + 2, ret);

		/* NB: draft-ietf-tls-ecc-12.txt uses a one-byte prefix for
		 * elliptic_curve_list, but the examples use two bytes.
		 * https://www1.ietf.org/mail-archive/web/tls/current/msg00538.html
		 * resolves this to two bytes.
		 */
		s2n(curveslen * 2, ret);
		for (i = 0; i < curveslen; i++)
			s2n(curves[i], ret);
	}

	if (!(SSL_get_options(s) & SSL_OP_NO_TICKET)) {
		int ticklen;
		if (!s->internal->new_session && s->session && s->session->tlsext_tick)
			ticklen = s->session->tlsext_ticklen;
		else if (s->session && s->internal->tlsext_session_ticket &&
		    s->internal->tlsext_session_ticket->data) {
			ticklen = s->internal->tlsext_session_ticket->length;
			s->session->tlsext_tick = malloc(ticklen);
			if (!s->session->tlsext_tick)
				return NULL;
			memcpy(s->session->tlsext_tick,
			    s->internal->tlsext_session_ticket->data, ticklen);
			s->session->tlsext_ticklen = ticklen;
		} else
			ticklen = 0;
		if (ticklen == 0 && s->internal->tlsext_session_ticket &&
		    s->internal->tlsext_session_ticket->data == NULL)
			goto skip_ext;
		/* Check for enough room 2 for extension type, 2 for len
 		 * rest for ticket
  		 */
		if ((size_t)(limit - ret) < 4 + ticklen)
			return NULL;
		s2n(TLSEXT_TYPE_session_ticket, ret);

		s2n(ticklen, ret);
		if (ticklen) {
			memcpy(ret, s->session->tlsext_tick, ticklen);
			ret += ticklen;
		}
	}
skip_ext:

	if (TLS1_get_client_version(s) >= TLS1_2_VERSION) {
		if ((size_t)(limit - ret) < sizeof(tls12_sigalgs) + 6)
			return NULL;

		s2n(TLSEXT_TYPE_signature_algorithms, ret);
		s2n(sizeof(tls12_sigalgs) + 2, ret);
		s2n(sizeof(tls12_sigalgs), ret);
		memcpy(ret, tls12_sigalgs, sizeof(tls12_sigalgs));
		ret += sizeof(tls12_sigalgs);
	}

	if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp &&
	    s->version != DTLS1_VERSION) {
		int i;
		long extlen, idlen, itmp;
		OCSP_RESPID *id;

		idlen = 0;
		for (i = 0; i < sk_OCSP_RESPID_num(s->internal->tlsext_ocsp_ids); i++) {
			id = sk_OCSP_RESPID_value(s->internal->tlsext_ocsp_ids, i);
			itmp = i2d_OCSP_RESPID(id, NULL);
			if (itmp <= 0)
				return NULL;
			idlen += itmp + 2;
		}

		if (s->internal->tlsext_ocsp_exts) {
			extlen = i2d_X509_EXTENSIONS(s->internal->tlsext_ocsp_exts, NULL);
			if (extlen < 0)
				return NULL;
		} else
			extlen = 0;

		if ((size_t)(limit - ret) < 7 + extlen + idlen)
			return NULL;
		s2n(TLSEXT_TYPE_status_request, ret);
		if (extlen + idlen > 0xFFF0)
			return NULL;
		s2n(extlen + idlen + 5, ret);
		*(ret++) = TLSEXT_STATUSTYPE_ocsp;
		s2n(idlen, ret);
		for (i = 0; i < sk_OCSP_RESPID_num(s->internal->tlsext_ocsp_ids); i++) {
			/* save position of id len */
			unsigned char *q = ret;
			id = sk_OCSP_RESPID_value(s->internal->tlsext_ocsp_ids, i);
			/* skip over id len */
			ret += 2;
			itmp = i2d_OCSP_RESPID(id, &ret);
			/* write id len */
			s2n(itmp, q);
		}
		s2n(extlen, ret);
		if (extlen > 0)
			i2d_X509_EXTENSIONS(s->internal->tlsext_ocsp_exts, &ret);
	}

	if (s->ctx->internal->next_proto_select_cb &&
	    !S3I(s)->tmp.finish_md_len) {
		/* The client advertises an emtpy extension to indicate its
		 * support for Next Protocol Negotiation */
		if ((size_t)(limit - ret) < 4)
			return NULL;
		s2n(TLSEXT_TYPE_next_proto_neg, ret);
		s2n(0, ret);
	}

	if (s->internal->alpn_client_proto_list != NULL &&
	    S3I(s)->tmp.finish_md_len == 0) {
		if ((size_t)(limit - ret) <
		    6 + s->internal->alpn_client_proto_list_len)
			return (NULL);
		s2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);
		s2n(2 + s->internal->alpn_client_proto_list_len, ret);
		s2n(s->internal->alpn_client_proto_list_len, ret);
		memcpy(ret, s->internal->alpn_client_proto_list,
		    s->internal->alpn_client_proto_list_len);
		ret += s->internal->alpn_client_proto_list_len;
	}

#ifndef OPENSSL_NO_SRTP
	if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)) {
		int el;

		ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0);

		if ((size_t)(limit - ret) < 4 + el)
			return NULL;

		s2n(TLSEXT_TYPE_use_srtp, ret);
		s2n(el, ret);

		if (ssl_add_clienthello_use_srtp_ext(s, ret, &el, el)) {
			SSLerror(s, ERR_R_INTERNAL_ERROR);
			return NULL;
		}
		ret += el;
	}
#endif

	/*
	 * Add padding to workaround bugs in F5 terminators.
	 * See https://tools.ietf.org/html/draft-agl-tls-padding-03
	 *
	 * Note that this seems to trigger issues with IronPort SMTP
	 * appliances.
	 *
	 * NB: because this code works out the length of all existing
	 * extensions it MUST always appear last.
	 */
	if (s->internal->options & SSL_OP_TLSEXT_PADDING) {
		int hlen = ret - (unsigned char *)s->internal->init_buf->data;

		/*
		 * The code in s23_clnt.c to build ClientHello messages
		 * includes the 5-byte record header in the buffer, while the
		 * code in s3_clnt.c does not.
		 */
		if (S3I(s)->hs.state == SSL23_ST_CW_CLNT_HELLO_A)
			hlen -= 5;
		if (hlen > 0xff && hlen < 0x200) {
			hlen = 0x200 - hlen;
			if (hlen >= 4)
				hlen -= 4;
			else
				hlen = 0;

			s2n(TLSEXT_TYPE_padding, ret);
			s2n(hlen, ret);
			memset(ret, 0, hlen);
			ret += hlen;
		}
	}

	if ((extdatalen = ret - p - 2) == 0)
		return p;

	s2n(extdatalen, p);
	return ret;
}

unsigned char *
ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
{
	int extdatalen = 0;
	unsigned char *ret = p;
	int next_proto_neg_seen;
	size_t len;
	CBB cbb;

	ret += 2;
	if (ret >= limit)
		return NULL; /* this really never occurs, but ... */

	if (!CBB_init_fixed(&cbb, ret, limit - ret))
		return NULL;
	if (!tlsext_serverhello_build(s, &cbb)) {
		CBB_cleanup(&cbb);
		return NULL;
	}
	if (!CBB_finish(&cbb, NULL, &len)) {
		CBB_cleanup(&cbb);
		return NULL;
	}
	if (len > (limit - ret))
		return NULL;
	ret += len;

	/*
	 * Currently the server should not respond with a SupportedCurves
	 * extension.
	 */

	if (s->internal->tlsext_ticket_expected &&
	    !(SSL_get_options(s) & SSL_OP_NO_TICKET)) {
		if ((size_t)(limit - ret) < 4)
			return NULL;

		s2n(TLSEXT_TYPE_session_ticket, ret);
		s2n(0, ret);
	}

	if (s->internal->tlsext_status_expected) {
		if ((size_t)(limit - ret) < 4)
			return NULL;

		s2n(TLSEXT_TYPE_status_request, ret);
		s2n(0, ret);
	}

#ifndef OPENSSL_NO_SRTP
	if (SSL_IS_DTLS(s) && s->internal->srtp_profile) {
		int el;

		ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0);

		if ((size_t)(limit - ret) < 4 + el)
			return NULL;

		s2n(TLSEXT_TYPE_use_srtp, ret);
		s2n(el, ret);

		if (ssl_add_serverhello_use_srtp_ext(s, ret, &el, el)) {
			SSLerror(s, ERR_R_INTERNAL_ERROR);
			return NULL;
		}
		ret += el;
	}
#endif

	if (((S3I(s)->hs.new_cipher->id & 0xFFFF) == 0x80 ||
	    (S3I(s)->hs.new_cipher->id & 0xFFFF) == 0x81) &&
	    (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) {
		static const unsigned char cryptopro_ext[36] = {
			0xfd, 0xe8, /*65000*/
			0x00, 0x20, /*32 bytes length*/
			0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,
			0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,
			0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,
			0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17
		};
		if ((size_t)(limit - ret) < sizeof(cryptopro_ext))
			return NULL;
		memcpy(ret, cryptopro_ext, sizeof(cryptopro_ext));
		ret += sizeof(cryptopro_ext);
	}

	next_proto_neg_seen = S3I(s)->next_proto_neg_seen;
	S3I(s)->next_proto_neg_seen = 0;
	if (next_proto_neg_seen && s->ctx->internal->next_protos_advertised_cb) {
		const unsigned char *npa;
		unsigned int npalen;
		int r;

		r = s->ctx->internal->next_protos_advertised_cb(s, &npa, &npalen,
		    s->ctx->internal->next_protos_advertised_cb_arg);
		if (r == SSL_TLSEXT_ERR_OK) {
			if ((size_t)(limit - ret) < 4 + npalen)
				return NULL;
			s2n(TLSEXT_TYPE_next_proto_neg, ret);
			s2n(npalen, ret);
			memcpy(ret, npa, npalen);
			ret += npalen;
			S3I(s)->next_proto_neg_seen = 1;
		}
	}

	if (S3I(s)->alpn_selected != NULL) {
		const unsigned char *selected = S3I(s)->alpn_selected;
		unsigned int len = S3I(s)->alpn_selected_len;

		if ((long)(limit - ret - 4 - 2 - 1 - len) < 0)
			return (NULL);
		s2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);
		s2n(3 + len, ret);
		s2n(1 + len, ret);
		*ret++ = len;
		memcpy(ret, selected, len);
		ret += len;
	}

	if ((extdatalen = ret - p - 2) == 0)
		return p;

	s2n(extdatalen, p);
	return ret;
}

/*
 * tls1_alpn_handle_client_hello is called to process the ALPN extension in a
 * ClientHello.
 *   data: the contents of the extension, not including the type and length.
 *   data_len: the number of bytes in data.
 *   al: a pointer to the alert value to send in the event of a non-zero
 *       return.
 *   returns: 1 on success.
 */
static int
tls1_alpn_handle_client_hello(SSL *s, const unsigned char *data,
    unsigned int data_len, int *al)
{
	CBS cbs, proto_name_list, alpn;
	const unsigned char *selected;
	unsigned char selected_len;
	int r;

	if (s->ctx->internal->alpn_select_cb == NULL)
		return (1);

	if (data_len < 2)
		goto parse_error;

	CBS_init(&cbs, data, data_len);

	/*
	 * data should contain a uint16 length followed by a series of 8-bit,
	 * length-prefixed strings.
	 */
	if (!CBS_get_u16_length_prefixed(&cbs, &alpn) ||
	    CBS_len(&alpn) < 2 ||
	    CBS_len(&cbs) != 0)
		goto parse_error;

	/* Validate data before sending to callback. */
	CBS_dup(&alpn, &proto_name_list);
	while (CBS_len(&proto_name_list) > 0) {
		CBS proto_name;

		if (!CBS_get_u8_length_prefixed(&proto_name_list, &proto_name) ||
		    CBS_len(&proto_name) == 0)
			goto parse_error;
	}

	r = s->ctx->internal->alpn_select_cb(s, &selected, &selected_len,
	    CBS_data(&alpn), CBS_len(&alpn),
	    s->ctx->internal->alpn_select_cb_arg);
	if (r == SSL_TLSEXT_ERR_OK) {
		free(S3I(s)->alpn_selected);
		if ((S3I(s)->alpn_selected = malloc(selected_len)) == NULL) {
			*al = SSL_AD_INTERNAL_ERROR;
			return (-1);
		}
		memcpy(S3I(s)->alpn_selected, selected, selected_len);
		S3I(s)->alpn_selected_len = selected_len;
	}

	return (1);

parse_error:
	*al = SSL_AD_DECODE_ERROR;
	return (0);
}

int
ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d,
    int n, int *al)
{
	unsigned short type;
	unsigned short size;
	unsigned short len;
	unsigned char *data = *p;
	unsigned char *end = d + n;
	int sigalg_seen = 0;
	CBS cbs;

	s->internal->servername_done = 0;
	s->tlsext_status_type = -1;
	S3I(s)->renegotiate_seen = 0;
	S3I(s)->next_proto_neg_seen = 0;
	free(S3I(s)->alpn_selected);
	S3I(s)->alpn_selected = NULL;
	s->internal->srtp_profile = NULL;

	if (data == end)
		goto ri_check;

	if (end - data < 2)
		goto err;
	n2s(data, len);

	if (end - data != len)
		goto err;

	while (end - data >= 4) {
		n2s(data, type);
		n2s(data, size);

		if (end - data < size)
			goto err;

		if (s->internal->tlsext_debug_cb)
			s->internal->tlsext_debug_cb(s, 0, type, data, size,
			    s->internal->tlsext_debug_arg);

		CBS_init(&cbs, data, size);
		if (!tlsext_clienthello_parse_one(s, &cbs, type, al))
			return 0;

		if (type == TLSEXT_TYPE_elliptic_curves &&
		    s->version != DTLS1_VERSION) {
			unsigned char *sdata = data;
			size_t curveslen, i;
			uint16_t *curves;

			if (size < 2) {
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
			}
			n2s(sdata, curveslen);
			if (curveslen != size - 2 || curveslen % 2 != 0) {
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
			}
			curveslen /= 2;

			if (!s->internal->hit) {
				if (SSI(s)->tlsext_supportedgroups) {
					*al = TLS1_AD_DECODE_ERROR;
					return 0;
				}
				SSI(s)->tlsext_supportedgroups_length = 0;
				if ((curves = reallocarray(NULL, curveslen,
				    sizeof(uint16_t))) == NULL) {
					*al = TLS1_AD_INTERNAL_ERROR;
					return 0;
				}
				for (i = 0; i < curveslen; i++)
					n2s(sdata, curves[i]);
				SSI(s)->tlsext_supportedgroups = curves;
				SSI(s)->tlsext_supportedgroups_length = curveslen;
			}
		} else if (type == TLSEXT_TYPE_session_ticket) {
			if (s->internal->tls_session_ticket_ext_cb &&
			    !s->internal->tls_session_ticket_ext_cb(s, data, size, s->internal->tls_session_ticket_ext_cb_arg)) {
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
			}
		} else if (type == TLSEXT_TYPE_signature_algorithms) {
			int dsize;
			if (sigalg_seen || size < 2) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
			sigalg_seen = 1;
			n2s(data, dsize);
			size -= 2;
			if (dsize != size || dsize & 1) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
			if (!tls1_process_sigalgs(s, data, dsize)) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
		} else if (type == TLSEXT_TYPE_status_request &&
		    s->version != DTLS1_VERSION) {

			if (size < 5) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}

			s->tlsext_status_type = *data++;
			size--;
			if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {
				const unsigned char *sdata;
				int dsize;
				/* Read in responder_id_list */
				n2s(data, dsize);
				size -= 2;
				if (dsize > size) {
					*al = SSL_AD_DECODE_ERROR;
					return 0;
				}

				/*
				 * We remove any OCSP_RESPIDs from a
				 * previous handshake to prevent
				 * unbounded memory growth.
				 */
				sk_OCSP_RESPID_pop_free(s->internal->tlsext_ocsp_ids,
				    OCSP_RESPID_free);
				s->internal->tlsext_ocsp_ids = NULL;
				if (dsize > 0) {
					s->internal->tlsext_ocsp_ids =
					    sk_OCSP_RESPID_new_null();
					if (s->internal->tlsext_ocsp_ids == NULL) {
						*al = SSL_AD_INTERNAL_ERROR;
						return 0;
					}
				}

				while (dsize > 0) {
					OCSP_RESPID *id;
					int idsize;
					if (dsize < 4) {
						*al = SSL_AD_DECODE_ERROR;
						return 0;
					}
					n2s(data, idsize);
					dsize -= 2 + idsize;
					size -= 2 + idsize;
					if (dsize < 0) {
						*al = SSL_AD_DECODE_ERROR;
						return 0;
					}
					sdata = data;
					data += idsize;
					id = d2i_OCSP_RESPID(NULL,
					    &sdata, idsize);
					if (!id) {
						*al = SSL_AD_DECODE_ERROR;
						return 0;
					}
					if (data != sdata) {
						OCSP_RESPID_free(id);
						*al = SSL_AD_DECODE_ERROR;
						return 0;
					}
					if (!sk_OCSP_RESPID_push(
					    s->internal->tlsext_ocsp_ids, id)) {
						OCSP_RESPID_free(id);
						*al = SSL_AD_INTERNAL_ERROR;
						return 0;
					}
				}

				/* Read in request_extensions */
				if (size < 2) {
					*al = SSL_AD_DECODE_ERROR;
					return 0;
				}
				n2s(data, dsize);
				size -= 2;
				if (dsize != size) {
					*al = SSL_AD_DECODE_ERROR;
					return 0;
				}
				sdata = data;
				if (dsize > 0) {
					sk_X509_EXTENSION_pop_free(s->internal->tlsext_ocsp_exts,
					    X509_EXTENSION_free);

					s->internal->tlsext_ocsp_exts =
					    d2i_X509_EXTENSIONS(NULL,
					    &sdata, dsize);
					if (!s->internal->tlsext_ocsp_exts ||
						    (data + dsize != sdata)) {
						*al = SSL_AD_DECODE_ERROR;
						return 0;
					}
				}
			} else {
				/* We don't know what to do with any other type
 			 	* so ignore it.
 			 	*/
				s->tlsext_status_type = -1;
			}
		}
		else if (type == TLSEXT_TYPE_next_proto_neg &&
		    S3I(s)->tmp.finish_md_len == 0 &&
		    S3I(s)->alpn_selected == NULL) {
			/* We shouldn't accept this extension on a
			 * renegotiation.
			 *
			 * s->internal->new_session will be set on renegotiation, but we
			 * probably shouldn't rely that it couldn't be set on
			 * the initial renegotation too in certain cases (when
			 * there's some other reason to disallow resuming an
			 * earlier session -- the current code won't be doing
			 * anything like that, but this might change).

			 * A valid sign that there's been a previous handshake
			 * in this connection is if S3I(s)->tmp.finish_md_len >
			 * 0.  (We are talking about a check that will happen
			 * in the Hello protocol round, well before a new
			 * Finished message could have been computed.) */
			S3I(s)->next_proto_neg_seen = 1;
		}
		else if (type ==
		    TLSEXT_TYPE_application_layer_protocol_negotiation &&
		    s->ctx->internal->alpn_select_cb != NULL &&
		    S3I(s)->tmp.finish_md_len == 0) {
			if (tls1_alpn_handle_client_hello(s, data,
			    size, al) != 1)
				return (0);
			/* ALPN takes precedence over NPN. */
			S3I(s)->next_proto_neg_seen = 0;
		}

		/* session ticket processed earlier */
#ifndef OPENSSL_NO_SRTP
		else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {
			if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
				return 0;
		}
#endif

		data += size;
	}

	/* Spurious data on the end */
	if (data != end)
		goto err;

	*p = data;

ri_check:

	/* Need RI if renegotiating */

	if (!S3I(s)->renegotiate_seen && s->internal->renegotiate) {
		*al = SSL_AD_HANDSHAKE_FAILURE;
		SSLerror(s, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
		return 0;
	}

	return 1;

err:
	*al = SSL_AD_DECODE_ERROR;
	return 0;
}

/*
 * ssl_next_proto_validate validates a Next Protocol Negotiation block. No
 * elements of zero length are allowed and the set of elements must exactly fill
 * the length of the block.
 */
static char
ssl_next_proto_validate(const unsigned char *d, unsigned int len)
{
	CBS npn, value;

	CBS_init(&npn, d, len);
	while (CBS_len(&npn) > 0) {
		if (!CBS_get_u8_length_prefixed(&npn, &value) ||
		    CBS_len(&value) == 0)
			return 0;
	}
	return 1;
}

int
ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, size_t n, int *al)
{
	unsigned short type;
	unsigned short size;
	unsigned short len;
	unsigned char *data = *p;
	unsigned char *end = *p + n;
	CBS cbs;

	S3I(s)->renegotiate_seen = 0;
	S3I(s)->next_proto_neg_seen = 0;
	free(S3I(s)->alpn_selected);
	S3I(s)->alpn_selected = NULL;

	if (data == end)
		goto ri_check;

	if (end - data < 2)
		goto err;
	n2s(data, len);

	if (end - data != len)
		goto err;

	while (end - data >= 4) {
		n2s(data, type);
		n2s(data, size);

		if (end - data < size)
			goto err;

		if (s->internal->tlsext_debug_cb)
			s->internal->tlsext_debug_cb(s, 1, type, data, size,
			    s->internal->tlsext_debug_arg);

		CBS_init(&cbs, data, size);
		if (!tlsext_serverhello_parse_one(s, &cbs, type, al))
			return 0;

		if (type == TLSEXT_TYPE_session_ticket) {
			if (s->internal->tls_session_ticket_ext_cb &&
			    !s->internal->tls_session_ticket_ext_cb(s, data, size, s->internal->tls_session_ticket_ext_cb_arg)) {
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
			}
			if ((SSL_get_options(s) & SSL_OP_NO_TICKET) || (size > 0)) {
				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
				return 0;
			}
			s->internal->tlsext_ticket_expected = 1;
		}
		else if (type == TLSEXT_TYPE_status_request &&
		    s->version != DTLS1_VERSION) {
			/* MUST be empty and only sent if we've requested
			 * a status request message.
			 */
			if ((s->tlsext_status_type == -1) || (size > 0)) {
				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
				return 0;
			}
			/* Set flag to expect CertificateStatus message */
			s->internal->tlsext_status_expected = 1;
		}
		else if (type == TLSEXT_TYPE_next_proto_neg &&
		    S3I(s)->tmp.finish_md_len == 0) {
			unsigned char *selected;
			unsigned char selected_len;

			/* We must have requested it. */
			if (s->ctx->internal->next_proto_select_cb == NULL) {
				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
				return 0;
			}
			/* The data must be valid */
			if (!ssl_next_proto_validate(data, size)) {
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
			}
			if (s->ctx->internal->next_proto_select_cb(s, &selected,
			    &selected_len, data, size,
			    s->ctx->internal->next_proto_select_cb_arg) !=
			    SSL_TLSEXT_ERR_OK) {
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
			}
			s->internal->next_proto_negotiated = malloc(selected_len);
			if (!s->internal->next_proto_negotiated) {
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
			}
			memcpy(s->internal->next_proto_negotiated, selected, selected_len);
			s->internal->next_proto_negotiated_len = selected_len;
			S3I(s)->next_proto_neg_seen = 1;
		}
		else if (type ==
		    TLSEXT_TYPE_application_layer_protocol_negotiation) {
			unsigned int len;

			/* We must have requested it. */
			if (s->internal->alpn_client_proto_list == NULL) {
				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
				return 0;
			}
			if (size < 4) {
				*al = TLS1_AD_DECODE_ERROR;
				return (0);
			}

			/* The extension data consists of:
			 *   uint16 list_length
			 *   uint8 proto_length;
			 *   uint8 proto[proto_length]; */
			len = ((unsigned int)data[0]) << 8 |
			    ((unsigned int)data[1]);
			if (len != (unsigned int)size - 2) {
				*al = TLS1_AD_DECODE_ERROR;
				return (0);
			}
			len = data[2];
			if (len != (unsigned int)size - 3) {
				*al = TLS1_AD_DECODE_ERROR;
				return (0);
			}
			free(S3I(s)->alpn_selected);
			S3I(s)->alpn_selected = malloc(len);
			if (S3I(s)->alpn_selected == NULL) {
				*al = TLS1_AD_INTERNAL_ERROR;
				return (0);
			}
			memcpy(S3I(s)->alpn_selected, data + 3, len);
			S3I(s)->alpn_selected_len = len;

		}
#ifndef OPENSSL_NO_SRTP
		else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {
			if (ssl_parse_serverhello_use_srtp_ext(s, data,
			    size, al))
				return 0;
		}
#endif

		data += size;

	}

	if (data != end) {
		*al = SSL_AD_DECODE_ERROR;
		return 0;
	}

	*p = data;

ri_check:

	/* Determine if we need to see RI. Strictly speaking if we want to
	 * avoid an attack we should *always* see RI even on initial server
	 * hello because the client doesn't see any renegotiation during an
	 * attack. However this would mean we could not connect to any server
	 * which doesn't support RI so for the immediate future tolerate RI
	 * absence on initial connect only.
	 */
	if (!S3I(s)->renegotiate_seen &&
	    !(s->internal->options & SSL_OP_LEGACY_SERVER_CONNECT)) {
		*al = SSL_AD_HANDSHAKE_FAILURE;
		SSLerror(s, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
		return 0;
	}

	return 1;

err:
	*al = SSL_AD_DECODE_ERROR;
	return 0;
}

int
ssl_check_clienthello_tlsext_early(SSL *s)
{
	int ret = SSL_TLSEXT_ERR_NOACK;
	int al = SSL_AD_UNRECOGNIZED_NAME;

	/* The handling of the ECPointFormats extension is done elsewhere, namely in
	 * ssl3_choose_cipher in s3_lib.c.
	 */
	/* The handling of the EllipticCurves extension is done elsewhere, namely in
	 * ssl3_choose_cipher in s3_lib.c.
	 */

	if (s->ctx != NULL && s->ctx->internal->tlsext_servername_callback != 0)
		ret = s->ctx->internal->tlsext_servername_callback(s, &al,
		    s->ctx->internal->tlsext_servername_arg);
	else if (s->initial_ctx != NULL && s->initial_ctx->internal->tlsext_servername_callback != 0)
		ret = s->initial_ctx->internal->tlsext_servername_callback(s, &al,
		    s->initial_ctx->internal->tlsext_servername_arg);

	switch (ret) {
	case SSL_TLSEXT_ERR_ALERT_FATAL:
		ssl3_send_alert(s, SSL3_AL_FATAL, al);
		return -1;
	case SSL_TLSEXT_ERR_ALERT_WARNING:
		ssl3_send_alert(s, SSL3_AL_WARNING, al);
		return 1;
	case SSL_TLSEXT_ERR_NOACK:
		s->internal->servername_done = 0;
	default:
		return 1;
	}
}

int
ssl_check_clienthello_tlsext_late(SSL *s)
{
	int ret = SSL_TLSEXT_ERR_OK;
	int al = 0;	/* XXX gcc3 */

	/* If status request then ask callback what to do.
 	 * Note: this must be called after servername callbacks in case
 	 * the certificate has changed, and must be called after the cipher
	 * has been chosen because this may influence which certificate is sent
 	 */
	if ((s->tlsext_status_type != -1) &&
	    s->ctx && s->ctx->internal->tlsext_status_cb) {
		int r;
		CERT_PKEY *certpkey;
		certpkey = ssl_get_server_send_pkey(s);
		/* If no certificate can't return certificate status */
		if (certpkey == NULL) {
			s->internal->tlsext_status_expected = 0;
			return 1;
		}
		/* Set current certificate to one we will use so
		 * SSL_get_certificate et al can pick it up.
		 */
		s->cert->key = certpkey;
		r = s->ctx->internal->tlsext_status_cb(s,
		    s->ctx->internal->tlsext_status_arg);
		switch (r) {
			/* We don't want to send a status request response */
		case SSL_TLSEXT_ERR_NOACK:
			s->internal->tlsext_status_expected = 0;
			break;
			/* status request response should be sent */
		case SSL_TLSEXT_ERR_OK:
			if (s->internal->tlsext_ocsp_resp)
				s->internal->tlsext_status_expected = 1;
			else
				s->internal->tlsext_status_expected = 0;
			break;
			/* something bad happened */
		case SSL_TLSEXT_ERR_ALERT_FATAL:
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
			al = SSL_AD_INTERNAL_ERROR;
			goto err;
		}
	} else
		s->internal->tlsext_status_expected = 0;

err:
	switch (ret) {
	case SSL_TLSEXT_ERR_ALERT_FATAL:
		ssl3_send_alert(s, SSL3_AL_FATAL, al);
		return -1;
	case SSL_TLSEXT_ERR_ALERT_WARNING:
		ssl3_send_alert(s, SSL3_AL_WARNING, al);
		return 1;
	default:
		return 1;
	}
}

int
ssl_check_serverhello_tlsext(SSL *s)
{
	int ret = SSL_TLSEXT_ERR_NOACK;
	int al = SSL_AD_UNRECOGNIZED_NAME;

	ret = SSL_TLSEXT_ERR_OK;

	if (s->ctx != NULL && s->ctx->internal->tlsext_servername_callback != 0)
		ret = s->ctx->internal->tlsext_servername_callback(s, &al,
		    s->ctx->internal->tlsext_servername_arg);
	else if (s->initial_ctx != NULL && s->initial_ctx->internal->tlsext_servername_callback != 0)
		ret = s->initial_ctx->internal->tlsext_servername_callback(s, &al,
		    s->initial_ctx->internal->tlsext_servername_arg);

	/* If we've requested certificate status and we wont get one
 	 * tell the callback
 	 */
	if ((s->tlsext_status_type != -1) && !(s->internal->tlsext_status_expected) &&
	    s->ctx && s->ctx->internal->tlsext_status_cb) {
		int r;
		/* Set resp to NULL, resplen to -1 so callback knows
 		 * there is no response.
 		 */
		free(s->internal->tlsext_ocsp_resp);
		s->internal->tlsext_ocsp_resp = NULL;
		s->internal->tlsext_ocsp_resplen = -1;
		r = s->ctx->internal->tlsext_status_cb(s,
		    s->ctx->internal->tlsext_status_arg);
		if (r == 0) {
			al = SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE;
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
		}
		if (r < 0) {
			al = SSL_AD_INTERNAL_ERROR;
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
		}
	}

	switch (ret) {
	case SSL_TLSEXT_ERR_ALERT_FATAL:
		ssl3_send_alert(s, SSL3_AL_FATAL, al);

		return -1;
	case SSL_TLSEXT_ERR_ALERT_WARNING:
		ssl3_send_alert(s, SSL3_AL_WARNING, al);

		return 1;
	case SSL_TLSEXT_ERR_NOACK:
		s->internal->servername_done = 0;
	default:
		return 1;
	}
}

/* Since the server cache lookup is done early on in the processing of the
 * ClientHello, and other operations depend on the result, we need to handle
 * any TLS session ticket extension at the same time.
 *
 *   session_id: points at the session ID in the ClientHello. This code will
 *       read past the end of this in order to parse out the session ticket
 *       extension, if any.
 *   len: the length of the session ID.
 *   limit: a pointer to the first byte after the ClientHello.
 *   ret: (output) on return, if a ticket was decrypted, then this is set to
 *       point to the resulting session.
 *
 * If s->internal->tls_session_secret_cb is set then we are expecting a pre-shared key
 * ciphersuite, in which case we have no use for session tickets and one will
 * never be decrypted, nor will s->internal->tlsext_ticket_expected be set to 1.
 *
 * Returns:
 *   -1: fatal error, either from parsing or decrypting the ticket.
 *    0: no ticket was found (or was ignored, based on settings).
 *    1: a zero length extension was found, indicating that the client supports
 *       session tickets but doesn't currently have one to offer.
 *    2: either s->internal->tls_session_secret_cb was set, or a ticket was offered but
 *       couldn't be decrypted because of a non-fatal error.
 *    3: a ticket was successfully decrypted and *ret was set.
 *
 * Side effects:
 *   Sets s->internal->tlsext_ticket_expected to 1 if the server will have to issue
 *   a new session ticket to the client because the client indicated support
 *   (and s->internal->tls_session_secret_cb is NULL) but the client either doesn't have
 *   a session ticket or we couldn't use the one it gave us, or if
 *   s->ctx->tlsext_ticket_key_cb asked to renew the client's ticket.
 *   Otherwise, s->internal->tlsext_ticket_expected is set to 0.
 */
int
tls1_process_ticket(SSL *s, const unsigned char *session, int session_len,
    const unsigned char *limit, SSL_SESSION **ret)
{
	/* Point after session ID in client hello */
	CBS session_id, cookie, cipher_list, compress_algo, extensions;

	*ret = NULL;
	s->internal->tlsext_ticket_expected = 0;

	/* If tickets disabled behave as if no ticket present
	 * to permit stateful resumption.
	 */
	if (SSL_get_options(s) & SSL_OP_NO_TICKET)
		return 0;
	if (!limit)
		return 0;

	if (limit < session)
		return -1;

	CBS_init(&session_id, session, limit - session);

	/* Skip past the session id */
	if (!CBS_skip(&session_id, session_len))
		return -1;

	/* Skip past DTLS cookie */
	if (SSL_IS_DTLS(s)) {
		if (!CBS_get_u8_length_prefixed(&session_id, &cookie))
			return -1;
	}

	/* Skip past cipher list */
	if (!CBS_get_u16_length_prefixed(&session_id, &cipher_list))
		return -1;

	/* Skip past compression algorithm list */
	if (!CBS_get_u8_length_prefixed(&session_id, &compress_algo))
		return -1;

	/* Now at start of extensions */
	if (CBS_len(&session_id) == 0)
		return 0;
	if (!CBS_get_u16_length_prefixed(&session_id, &extensions))
		return -1;

	while (CBS_len(&extensions) > 0) {
		CBS ext_data;
		uint16_t ext_type;

		if (!CBS_get_u16(&extensions, &ext_type) ||
		    !CBS_get_u16_length_prefixed(&extensions, &ext_data))
			return -1;

		if (ext_type == TLSEXT_TYPE_session_ticket) {
			int r;
			if (CBS_len(&ext_data) == 0) {
				/* The client will accept a ticket but doesn't
				 * currently have one. */
				s->internal->tlsext_ticket_expected = 1;
				return 1;
			}
			if (s->internal->tls_session_secret_cb) {
				/* Indicate that the ticket couldn't be
				 * decrypted rather than generating the session
				 * from ticket now, trigger abbreviated
				 * handshake based on external mechanism to
				 * calculate the master secret later. */
				return 2;
			}

			r = tls_decrypt_ticket(s, CBS_data(&ext_data),
			    CBS_len(&ext_data), session, session_len, ret);

			switch (r) {
			case 2: /* ticket couldn't be decrypted */
				s->internal->tlsext_ticket_expected = 1;
				return 2;
			case 3: /* ticket was decrypted */
				return r;
			case 4: /* ticket decrypted but need to renew */
				s->internal->tlsext_ticket_expected = 1;
				return 3;
			default: /* fatal error */
				return -1;
			}
		}
	}
	return 0;
}

/* tls_decrypt_ticket attempts to decrypt a session ticket.
 *
 *   etick: points to the body of the session ticket extension.
 *   eticklen: the length of the session tickets extenion.
 *   sess_id: points at the session ID.
 *   sesslen: the length of the session ID.
 *   psess: (output) on return, if a ticket was decrypted, then this is set to
 *       point to the resulting session.
 *
 * Returns:
 *   -1: fatal error, either from parsing or decrypting the ticket.
 *    2: the ticket couldn't be decrypted.
 *    3: a ticket was successfully decrypted and *psess was set.
 *    4: same as 3, but the ticket needs to be renewed.
 */
static int
tls_decrypt_ticket(SSL *s, const unsigned char *etick, int eticklen,
    const unsigned char *sess_id, int sesslen, SSL_SESSION **psess)
{
	SSL_SESSION *sess;
	unsigned char *sdec;
	const unsigned char *p;
	int slen, mlen, renew_ticket = 0;
	unsigned char tick_hmac[EVP_MAX_MD_SIZE];
	HMAC_CTX hctx;
	EVP_CIPHER_CTX ctx;
	SSL_CTX *tctx = s->initial_ctx;

	/*
	 * The API guarantees EVP_MAX_IV_LENGTH bytes of space for
	 * the iv to tlsext_ticket_key_cb().  Since the total space
	 * required for a session cookie is never less than this,
	 * this check isn't too strict.  The exact check comes later.
	 */
	if (eticklen < 16 + EVP_MAX_IV_LENGTH)
		return 2;

	/* Initialize session ticket encryption and HMAC contexts */
	HMAC_CTX_init(&hctx);
	EVP_CIPHER_CTX_init(&ctx);
	if (tctx->internal->tlsext_ticket_key_cb) {
		unsigned char *nctick = (unsigned char *)etick;
		int rv = tctx->internal->tlsext_ticket_key_cb(s,
		    nctick, nctick + 16, &ctx, &hctx, 0);
		if (rv < 0) {
			HMAC_CTX_cleanup(&hctx);
			EVP_CIPHER_CTX_cleanup(&ctx);
			return -1;
		}
		if (rv == 0) {
			HMAC_CTX_cleanup(&hctx);
			EVP_CIPHER_CTX_cleanup(&ctx);
			return 2;
		}
		if (rv == 2)
			renew_ticket = 1;
	} else {
		/* Check key name matches */
		if (timingsafe_memcmp(etick,
		    tctx->internal->tlsext_tick_key_name, 16))
			return 2;
		HMAC_Init_ex(&hctx, tctx->internal->tlsext_tick_hmac_key,
		    16, tlsext_tick_md(), NULL);
		EVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,
		    tctx->internal->tlsext_tick_aes_key, etick + 16);
	}

	/*
	 * Attempt to process session ticket, first conduct sanity and
	 * integrity checks on ticket.
	 */
	mlen = HMAC_size(&hctx);
	if (mlen < 0) {
		HMAC_CTX_cleanup(&hctx);
		EVP_CIPHER_CTX_cleanup(&ctx);
		return -1;
	}

	/* Sanity check ticket length: must exceed keyname + IV + HMAC */
	if (eticklen <= 16 + EVP_CIPHER_CTX_iv_length(&ctx) + mlen) {
		HMAC_CTX_cleanup(&hctx);
		EVP_CIPHER_CTX_cleanup(&ctx);
		return 2;
	}
	eticklen -= mlen;

	/* Check HMAC of encrypted ticket */
	if (HMAC_Update(&hctx, etick, eticklen) <= 0 ||
	    HMAC_Final(&hctx, tick_hmac, NULL) <= 0) {
		HMAC_CTX_cleanup(&hctx);
		EVP_CIPHER_CTX_cleanup(&ctx);
		return -1;
	}

	HMAC_CTX_cleanup(&hctx);
	if (timingsafe_memcmp(tick_hmac, etick + eticklen, mlen)) {
		EVP_CIPHER_CTX_cleanup(&ctx);
		return 2;
	}

	/* Attempt to decrypt session data */
	/* Move p after IV to start of encrypted ticket, update length */
	p = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);
	eticklen -= 16 + EVP_CIPHER_CTX_iv_length(&ctx);
	sdec = malloc(eticklen);
	if (sdec == NULL ||
	    EVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen) <= 0) {
		free(sdec);
		EVP_CIPHER_CTX_cleanup(&ctx);
		return -1;
	}
	if (EVP_DecryptFinal_ex(&ctx, sdec + slen, &mlen) <= 0) {
		free(sdec);
		EVP_CIPHER_CTX_cleanup(&ctx);
		return 2;
	}
	slen += mlen;
	EVP_CIPHER_CTX_cleanup(&ctx);
	p = sdec;

	sess = d2i_SSL_SESSION(NULL, &p, slen);
	free(sdec);
	if (sess) {
		/* The session ID, if non-empty, is used by some clients to
		 * detect that the ticket has been accepted. So we copy it to
		 * the session structure. If it is empty set length to zero
		 * as required by standard.
		 */
		if (sesslen)
			memcpy(sess->session_id, sess_id, sesslen);
		sess->session_id_length = sesslen;
		*psess = sess;
		if (renew_ticket)
			return 4;
		else
			return 3;
	}
	ERR_clear_error();
	/* For session parse failure, indicate that we need to send a new
	 * ticket. */
	return 2;
}

/* Tables to translate from NIDs to TLS v1.2 ids */

typedef struct {
	int nid;
	int id;
} tls12_lookup;

static tls12_lookup tls12_md[] = {
	{NID_md5, TLSEXT_hash_md5},
	{NID_sha1, TLSEXT_hash_sha1},
	{NID_sha224, TLSEXT_hash_sha224},
	{NID_sha256, TLSEXT_hash_sha256},
	{NID_sha384, TLSEXT_hash_sha384},
	{NID_sha512, TLSEXT_hash_sha512},
	{NID_id_GostR3411_94, TLSEXT_hash_gost94},
	{NID_id_tc26_gost3411_2012_256, TLSEXT_hash_streebog_256},
	{NID_id_tc26_gost3411_2012_512, TLSEXT_hash_streebog_512}
};

static tls12_lookup tls12_sig[] = {
	{EVP_PKEY_RSA, TLSEXT_signature_rsa},
	{EVP_PKEY_DSA, TLSEXT_signature_dsa},
	{EVP_PKEY_EC, TLSEXT_signature_ecdsa},
	{EVP_PKEY_GOSTR01, TLSEXT_signature_gostr01},
};

static int
tls12_find_id(int nid, tls12_lookup *table, size_t tlen)
{
	size_t i;
	for (i = 0; i < tlen; i++) {
		if (table[i].nid == nid)
			return table[i].id;
	}
	return -1;
}

int
tls12_get_sigandhash(unsigned char *p, const EVP_PKEY *pk, const EVP_MD *md)
{
	int sig_id, md_id;
	if (!md)
		return 0;
	md_id = tls12_find_id(EVP_MD_type(md), tls12_md,
	    sizeof(tls12_md) / sizeof(tls12_lookup));
	if (md_id == -1)
		return 0;
	sig_id = tls12_get_sigid(pk);
	if (sig_id == -1)
		return 0;
	p[0] = (unsigned char)md_id;
	p[1] = (unsigned char)sig_id;
	return 1;
}

int
tls12_get_sigid(const EVP_PKEY *pk)
{
	return tls12_find_id(pk->type, tls12_sig,
	    sizeof(tls12_sig) / sizeof(tls12_lookup));
}

const EVP_MD *
tls12_get_hash(unsigned char hash_alg)
{
	switch (hash_alg) {
	case TLSEXT_hash_sha1:
		return EVP_sha1();
	case TLSEXT_hash_sha224:
		return EVP_sha224();
	case TLSEXT_hash_sha256:
		return EVP_sha256();
	case TLSEXT_hash_sha384:
		return EVP_sha384();
	case TLSEXT_hash_sha512:
		return EVP_sha512();
#ifndef OPENSSL_NO_GOST
	case TLSEXT_hash_gost94:
		return EVP_gostr341194();
	case TLSEXT_hash_streebog_256:
		return EVP_streebog256();
	case TLSEXT_hash_streebog_512:
		return EVP_streebog512();
#endif
	default:
		return NULL;
	}
}

/* Set preferred digest for each key type */

int
tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
{
	int idx;
	const EVP_MD *md;
	CERT *c = s->cert;
	CBS cbs;

	/* Extension ignored for inappropriate versions */
	if (!SSL_USE_SIGALGS(s))
		return 1;

	/* Should never happen */
	if (!c || dsize < 0)
		return 0;

	CBS_init(&cbs, data, dsize);

	c->pkeys[SSL_PKEY_DSA_SIGN].digest = NULL;
	c->pkeys[SSL_PKEY_RSA_SIGN].digest = NULL;
	c->pkeys[SSL_PKEY_RSA_ENC].digest = NULL;
	c->pkeys[SSL_PKEY_ECC].digest = NULL;
	c->pkeys[SSL_PKEY_GOST01].digest = NULL;

	while (CBS_len(&cbs) > 0) {
		uint8_t hash_alg, sig_alg;

		if (!CBS_get_u8(&cbs, &hash_alg) ||
		    !CBS_get_u8(&cbs, &sig_alg)) {
			/* Should never happen */
			return 0;
		}

		switch (sig_alg) {
		case TLSEXT_signature_rsa:
			idx = SSL_PKEY_RSA_SIGN;
			break;
		case TLSEXT_signature_dsa:
			idx = SSL_PKEY_DSA_SIGN;
			break;
		case TLSEXT_signature_ecdsa:
			idx = SSL_PKEY_ECC;
			break;
		case TLSEXT_signature_gostr01:
		case TLSEXT_signature_gostr12_256:
		case TLSEXT_signature_gostr12_512:
			idx = SSL_PKEY_GOST01;
			break;
		default:
			continue;
		}

		if (c->pkeys[idx].digest == NULL) {
			md = tls12_get_hash(hash_alg);
			if (md) {
				c->pkeys[idx].digest = md;
				if (idx == SSL_PKEY_RSA_SIGN)
					c->pkeys[SSL_PKEY_RSA_ENC].digest = md;
			}
		}

	}

	/* Set any remaining keys to default values. NOTE: if alg is not
	 * supported it stays as NULL.
	 */
	if (!c->pkeys[SSL_PKEY_DSA_SIGN].digest)
		c->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_sha1();
	if (!c->pkeys[SSL_PKEY_RSA_SIGN].digest) {
		c->pkeys[SSL_PKEY_RSA_SIGN].digest = EVP_sha1();
		c->pkeys[SSL_PKEY_RSA_ENC].digest = EVP_sha1();
	}
	if (!c->pkeys[SSL_PKEY_ECC].digest)
		c->pkeys[SSL_PKEY_ECC].digest = EVP_sha1();
#ifndef OPENSSL_NO_GOST
	if (!c->pkeys[SSL_PKEY_GOST01].digest)
		c->pkeys[SSL_PKEY_GOST01].digest = EVP_gostr341194();
#endif
	return 1;
}
@


1.124
log
@Clean up the EC key/curve configuration handling.

Over the years OpenSSL grew multiple ways of being able to specify EC keys
(and/or curves) for use with ECDH and ECDHE key exchange. You could specify
a static EC key (SSL{_CTX,}_set_tmp_ecdh()), use that as a curve and
generate ephemeral keys (SSL_OP_SINGLE_ECDH_USE), provide the EC key via
a callback that was provided with insufficient information
(SSL{_CTX,}_set_tmp_ecdh_cb()) or enable automatic selection and generation
of EC keys via SSL{_CTX,}_set_ecdh_auto(). This complexity leads to
problems (like ECDHE not being enabled) and potential weird configuration
(like being able to do ECDHE without the ephemeral part...).

We no longer support ECDH and ECDHE can be disabled by removing ECDHE
ciphers from the cipher list. As such, permanently enable automatic EC
curve selection and generation, effectively disabling all of the
configuration knobs. The only exception is the
SSL{_CTX,}_set_tmp_ecdh() functions, which retain part of their previous
behaviour by configuring the curve of the given EC key as the only curve
being enabled. Everything else becomes a no-op.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.123 2017/08/09 22:24:25 jsing Exp $ */
d345 1
a345 1
static void
d702 1
a702 1
		size_t curveslen, formatslen, lenmax;
a703 1
		const uint8_t *formats;
a706 22
		 * Add TLS extension ECPointFormats to the ClientHello message.
		 */
		tls1_get_formatlist(s, 0, &formats, &formatslen);

		if ((size_t)(limit - ret) < 5)
			return NULL;

		lenmax = limit - ret - 5;
		if (formatslen > lenmax)
			return NULL;
		if (formatslen > 255) {
			SSLerror(s, ERR_R_INTERNAL_ERROR);
			return NULL;
		}

		s2n(TLSEXT_TYPE_ec_point_formats, ret);
		s2n(formatslen + 1, ret);
		*(ret++) = (unsigned char)formatslen;
		memcpy(ret, formats, formatslen);
		ret += formatslen;

		/*
d911 1
a911 1
	int using_ecc, extdatalen = 0;
a916 2
	using_ecc = ssl_using_ecc_cipher(s);

a934 27
	if (using_ecc && s->version != DTLS1_VERSION) {
		const unsigned char *formats;
		size_t formatslen, lenmax;

		/*
		 * Add TLS extension ECPointFormats to the ServerHello message.
		 */
		tls1_get_formatlist(s, 0, &formats, &formatslen);

		if ((size_t)(limit - ret) < 5)
			return NULL;

		lenmax = limit - ret - 5;
		if (formatslen > lenmax)
			return NULL;
		if (formatslen > 255) {
			SSLerror(s, ERR_R_INTERNAL_ERROR);
			return NULL;
		}

		s2n(TLSEXT_TYPE_ec_point_formats, ret);
		s2n(formatslen + 1, ret);
		*(ret++) = (unsigned char)formatslen;
		memcpy(ret, formats, formatslen);
		ret += formatslen;
	}

d1145 1
a1145 32
		if (type == TLSEXT_TYPE_ec_point_formats &&
		    s->version != DTLS1_VERSION) {
			unsigned char *sdata = data;
			size_t formatslen;
			uint8_t *formats;

			if (size < 1) {
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
			}
			formatslen = *(sdata++);
			if (formatslen != size - 1) {
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
			}

			if (!s->internal->hit) {
				free(SSI(s)->tlsext_ecpointformatlist);
				SSI(s)->tlsext_ecpointformatlist = NULL;
				SSI(s)->tlsext_ecpointformatlist_length = 0;

				if ((formats = reallocarray(NULL, formatslen,
				    sizeof(uint8_t))) == NULL) {
					*al = TLS1_AD_INTERNAL_ERROR;
					return 0;
				}
				memcpy(formats, sdata, formatslen);
				SSI(s)->tlsext_ecpointformatlist = formats;
				SSI(s)->tlsext_ecpointformatlist_length =
				    formatslen;
			}
		} else if (type == TLSEXT_TYPE_elliptic_curves &&
d1430 1
a1430 33
		if (type == TLSEXT_TYPE_ec_point_formats &&
		    s->version != DTLS1_VERSION) {
			unsigned char *sdata = data;
			size_t formatslen;
			uint8_t *formats;

			if (size < 1) {
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
			}
			formatslen = *(sdata++);
			if (formatslen != size - 1) {
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
			}

			if (!s->internal->hit) {
				free(SSI(s)->tlsext_ecpointformatlist);
				SSI(s)->tlsext_ecpointformatlist = NULL;
				SSI(s)->tlsext_ecpointformatlist_length = 0;

				if ((formats = reallocarray(NULL, formatslen,
				    sizeof(uint8_t))) == NULL) {
					*al = TLS1_AD_INTERNAL_ERROR;
					return 0;
				}
				memcpy(formats, sdata, formatslen);
				SSI(s)->tlsext_ecpointformatlist = formats;
				SSI(s)->tlsext_ecpointformatlist_length =
				    formatslen;
			}
		}
		else if (type == TLSEXT_TYPE_session_ticket) {
a1666 23
	/* If we are client and using an elliptic curve cryptography cipher
	 * suite, then if server returns an EC point formats lists extension
	 * it must contain uncompressed.
	 */
	if (ssl_using_ecc_cipher(s) &&
	    s->internal->tlsext_ecpointformatlist != NULL &&
	    s->internal->tlsext_ecpointformatlist_length > 0) {
		/* we are using an ECC cipher */
		size_t i;
		unsigned char *list;
		int found_uncompressed = 0;
		list = SSI(s)->tlsext_ecpointformatlist;
		for (i = 0; i < SSI(s)->tlsext_ecpointformatlist_length; i++) {
			if (*(list++) == TLSEXT_ECPOINTFORMAT_uncompressed) {
				found_uncompressed = 1;
				break;
			}
		}
		if (!found_uncompressed) {
			SSLerror(s, SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);
			return -1;
		}
	}
@


1.123
log
@Pull out the code that identifies if we have an ECC cipher in the cipher
list or if we are negotiating an ECC cipher in the handshake. This dedups
some of the existing code and will make the EC extension rewrites easier.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.122 2017/07/24 17:39:43 jsing Exp $ */
d614 5
a618 4
	if (s->cert->ecdh_tmp_auto != 0) {
		/* Need a shared curve. */
		if (tls1_get_shared_curve(s) != NID_undef)
			return (1);
a619 1
	}
a620 5
	if (ec == NULL) {
		if (s->cert->ecdh_tmp_cb != NULL)
			return (1);
		return (0);
	}
@


1.122
log
@Rewrite and move the last remnants of the ServerHello SNI handling into
tlsext_sni_serverhello_parse(). This also adds a check to ensure that
if we have an existing session, the name matches what we specified via
SNI.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.119 2017/07/19 17:45:31 jsing Exp $ */
d682 1
a682 1
	int using_ecc = 0;
d686 1
a686 18
	/* See if we support any ECC ciphersuites. */
	if (s->version != DTLS1_VERSION && s->version >= TLS1_VERSION) {
		STACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s);
		unsigned long alg_k, alg_a;
		int i;

		for (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++) {
			SSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i);

			alg_k = c->algorithm_mkey;
			alg_a = c->algorithm_auth;

			if ((alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA)) {
				using_ecc = 1;
				break;
			}
		}
	}
a939 1
	unsigned long alg_a, alg_k;
d945 1
a945 4
	alg_a = S3I(s)->hs.new_cipher->algorithm_auth;
	alg_k = S3I(s)->hs.new_cipher->algorithm_mkey;
	using_ecc = ((alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA)) &&
	    SSI(s)->tlsext_ecpointformatlist != NULL;
d1791 3
a1793 7
	unsigned long alg_k = S3I(s)->hs.new_cipher->algorithm_mkey;
	unsigned long alg_a = S3I(s)->hs.new_cipher->algorithm_auth;
	if ((s->internal->tlsext_ecpointformatlist != NULL) &&
	    (s->internal->tlsext_ecpointformatlist_length > 0) &&
	    (SSI(s)->tlsext_ecpointformatlist != NULL) &&
	    (SSI(s)->tlsext_ecpointformatlist_length > 0) &&
	    ((alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA))) {
@


1.121
log
@Rewrite the TLS Renegotiation Indication extension handling using CBB/CBS
and the new extension framework.

Feedback from doug@@

ok inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.120 2017/07/23 16:27:44 jsing Exp $ */
a1506 1
	int tlsext_servername = 0;
d1539 1
a1539 9
		if (type == TLSEXT_TYPE_server_name) {
			if (s->tlsext_hostname == NULL || size > 0) {
				*al = TLS1_AD_UNRECOGNIZED_NAME;
				return 0;
			}
			tlsext_servername = 1;

		}
		else if (type == TLSEXT_TYPE_ec_point_formats &&
a1679 17
	}

	if (!s->internal->hit && tlsext_servername == 1) {
		if (s->tlsext_hostname) {
			if (s->session->tlsext_hostname == NULL) {
				s->session->tlsext_hostname =
				    strdup(s->tlsext_hostname);

				if (!s->session->tlsext_hostname) {
					*al = SSL_AD_UNRECOGNIZED_NAME;
					return 0;
				}
			} else {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
		}
@


1.120
log
@Hook the TLS extension parsing framework into the serverhello parsing.
Missed in the original commit.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.119 2017/07/19 17:45:31 jsing Exp $ */
a722 23
	/* Add RI if renegotiating */
	if (s->internal->renegotiate) {
		int el;

		if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
			SSLerror(s, ERR_R_INTERNAL_ERROR);
			return NULL;
		}

		if ((size_t)(limit - ret) < 4 + el)
			return NULL;

		s2n(TLSEXT_TYPE_renegotiate, ret);
		s2n(el, ret);

		if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
			SSLerror(s, ERR_R_INTERNAL_ERROR);
			return NULL;
		}

		ret += el;
	}

a985 22
	if (S3I(s)->send_connection_binding) {
		int el;

		if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {
			SSLerror(s, ERR_R_INTERNAL_ERROR);
			return NULL;
		}

		if ((size_t)(limit - ret) < 4 + el)
			return NULL;

		s2n(TLSEXT_TYPE_renegotiate, ret);
		s2n(el, ret);

		if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {
			SSLerror(s, ERR_R_INTERNAL_ERROR);
			return NULL;
		}

		ret += el;
	}

a1186 1
	int renegotiate_seen = 0;
d1192 1
a1292 4
		} else if (type == TLSEXT_TYPE_renegotiate) {
			if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
				return 0;
			renegotiate_seen = 1;
d1467 1
a1467 1
	if (!renegotiate_seen && s->internal->renegotiate) {
a1507 1
	int renegotiate_seen = 0;
d1510 1
a1672 4
		} else if (type == TLSEXT_TYPE_renegotiate) {
			if (!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))
				return 0;
			renegotiate_seen = 1;
d1719 1
a1719 1
	if (!renegotiate_seen &&
@


1.119
log
@Check the return value of CBB_init_fixed(), since it can fail.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.118 2017/07/16 18:14:37 jsing Exp $ */
d1558 1
d1584 4
@


1.118
log
@Start rewriting TLS extension handling.

Introduce a TLS extension handling framework that has per-extension type
functions to determine if an extension is needed, to build the extension
data and parse the extension data. This is somewhat analogous to BoringSSL,
however these build and parse functions are intentionally symetrical. The
framework is hooked into the existing TLS handling code in such a way that
we can gradual convert the extension handling code.

Convert the TLS Server Name Indication extension to the new framework,
while rewriting it to use CBB/CBS and be more strict in the process.

Discussed with beck@@

ok inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.117 2017/05/07 04:22:24 beck Exp $ */
d709 2
a710 1
	CBB_init_fixed(&cbb, ret, limit - ret);
d995 2
a996 1
	CBB_init_fixed(&cbb, ret, limit - ret);
@


1.117
log
@Move state from ssl->internal to the handshake structure.
while we are at it, convert SSLerror to use a function
internally, so that we may later allocate the handshake
structure and check for it
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.116 2017/05/06 22:24:58 beck Exp $ */
d120 1
d122 1
d683 2
a705 1

d709 12
a720 33
	if (s->tlsext_hostname != NULL) {
		/* Add TLS extension servername to the Client Hello message */
		size_t size_str, lenmax;

		/* check for enough space.
		   4 for the servername type and extension length
		   2 for servernamelist length
		   1 for the hostname type
		   2 for hostname length
		   + hostname length
		*/

		if ((size_t)(limit - ret) < 9)
			return NULL;

		lenmax = limit - ret - 9;
		if ((size_str = strlen(s->tlsext_hostname)) > lenmax)
			return NULL;

		/* extension type and length */
		s2n(TLSEXT_TYPE_server_name, ret);

		s2n(size_str + 5, ret);

		/* length of servername list */
		s2n(size_str + 3, ret);

		/* hostname type, length and hostname */
		*(ret++) = (unsigned char) TLSEXT_NAMETYPE_host_name;
		s2n(size_str, ret);
		memcpy(ret, s->tlsext_hostname, size_str);
		ret += size_str;
	}
d982 2
d994 12
a1005 8
	if (!s->internal->hit && s->internal->servername_done == 1 &&
	    s->session->tlsext_hostname != NULL) {
		if ((size_t)(limit - ret) < 4)
			return NULL;

		s2n(TLSEXT_TYPE_server_name, ret);
		s2n(0, ret);
	}
d1232 1
a1260 1
/* The servername extension is treated as follows:
d1262 3
a1264 96
   - Only the hostname type is supported with a maximum length of 255.
   - The servername is rejected if too long or if it contains zeros,
     in which case an fatal alert is generated.
   - The servername field is maintained together with the session cache.
   - When a session is resumed, the servername call back invoked in order
     to allow the application to position itself to the right context.
   - The servername is acknowledged if it is new for a session or when
     it is identical to a previously used for the same session.
     Applications can control the behaviour.  They can at any time
     set a 'desirable' servername for a new SSL object. This can be the
     case for example with HTTPS when a Host: header field is received and
     a renegotiation is requested. In this case, a possible servername
     presented in the new client hello is only acknowledged if it matches
     the value of the Host: field.
   - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
     if they provide for changing an explicit servername context for the session,
     i.e. when the session has been established with a servername extension.
   - On session reconnect, the servername extension may be absent.

*/

		if (type == TLSEXT_TYPE_server_name) {
			unsigned char *sdata;
			int servname_type;
			int dsize;

			if (size < 2) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
			n2s(data, dsize);

			size -= 2;
			if (dsize > size) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}

			sdata = data;
			while (dsize > 3) {
				servname_type = *(sdata++);

				n2s(sdata, len);
				dsize -= 3;

				if (len > dsize) {
					*al = SSL_AD_DECODE_ERROR;
					return 0;
				}
				if (s->internal->servername_done == 0)
					switch (servname_type) {
					case TLSEXT_NAMETYPE_host_name:
						if (!s->internal->hit) {
							if (s->session->tlsext_hostname) {
								*al = SSL_AD_DECODE_ERROR;
								return 0;
							}
							if (len > TLSEXT_MAXLEN_host_name) {
								*al = TLS1_AD_UNRECOGNIZED_NAME;
								return 0;
							}
							if ((s->session->tlsext_hostname =
							    malloc(len + 1)) == NULL) {
								*al = TLS1_AD_INTERNAL_ERROR;
								return 0;
							}
							memcpy(s->session->tlsext_hostname, sdata, len);
							s->session->tlsext_hostname[len] = '\0';
							if (strlen(s->session->tlsext_hostname) != len) {
								free(s->session->tlsext_hostname);
								s->session->tlsext_hostname = NULL;
								*al = TLS1_AD_UNRECOGNIZED_NAME;
								return 0;
							}
							s->internal->servername_done = 1;


						} else {
							s->internal->servername_done = s->session->tlsext_hostname &&
							    strlen(s->session->tlsext_hostname) == len &&
							    strncmp(s->session->tlsext_hostname, (char *)sdata, len) == 0;
						}
						break;

					default:
						break;
					}

				dsize -= len;
			}
			if (dsize != 0) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}

		}
d1266 1
a1266 1
		else if (type == TLSEXT_TYPE_ec_point_formats &&
@


1.116
log
@Bring in an SSL_HANDSHAKE structure and commence the great shovelling
ok jsing@@, gcc@@, regress@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.115 2017/02/07 02:08:38 beck Exp $ */
d970 1
a970 1
		if (s->internal->state == SSL23_ST_CW_CLNT_HELLO_A)
@


1.115
log
@Change SSLerror() back to taking two args, with the first one being an SSL *.
Make a table of "function codes" which maps the internal state of the SSL *
to something like a useful name so in a typical error in the connection you
know in what sort of place in the handshake things happened. (instead of
by arcane function name).
Add SSLerrorx() for when we don't have an SSL *
ok jsing@@ after us both being prodded by bluhm@@ to make it not terrible
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.114 2017/01/26 12:16:13 beck Exp $ */
d1001 2
a1002 2
	alg_a = S3I(s)->tmp.new_cipher->algorithm_auth;
	alg_k = S3I(s)->tmp.new_cipher->algorithm_mkey;
d1110 2
a1111 2
	if (((S3I(s)->tmp.new_cipher->id & 0xFFFF) == 0x80 ||
	    (S3I(s)->tmp.new_cipher->id & 0xFFFF) == 0x81) &&
d1989 2
a1990 2
	unsigned long alg_k = S3I(s)->tmp.new_cipher->algorithm_mkey;
	unsigned long alg_a = S3I(s)->tmp.new_cipher->algorithm_auth;
@


1.114
log
@Finish the fallout of the SSLerr->SSLerror cleanup to get rid of the ugly
line wraps that resulted
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.113 2017/01/26 10:40:21 beck Exp $ */
d745 1
a745 1
			SSLerror(ERR_R_INTERNAL_ERROR);
d756 1
a756 1
			SSLerror(ERR_R_INTERNAL_ERROR);
d781 1
a781 1
			SSLerror(ERR_R_INTERNAL_ERROR);
d803 1
a803 1
			SSLerror(ERR_R_INTERNAL_ERROR);
d945 1
a945 1
			SSLerror(ERR_R_INTERNAL_ERROR);
d1023 1
a1023 1
			SSLerror(ERR_R_INTERNAL_ERROR);
d1034 1
a1034 1
			SSLerror(ERR_R_INTERNAL_ERROR);
d1057 1
a1057 1
			SSLerror(ERR_R_INTERNAL_ERROR);
d1103 1
a1103 1
			SSLerror(ERR_R_INTERNAL_ERROR);
d1621 1
a1621 1
		SSLerror(SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
d1873 1
a1873 1
		SSLerror(SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
d2008 1
a2008 1
			SSLerror(SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);
@


1.113
log
@Send the error function codes to rot in the depths of hell where they belong
We leave a single funciton code (0xFFF) to say "SSL_internal" so the public
API will not break, and we replace all internal use of the two argument
SSL_err() with the internal only SSL_error() that only takes a reason code.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.112 2017/01/26 06:32:58 jsing Exp $ */
d745 1
a745 2
			SSLerror(
			    ERR_R_INTERNAL_ERROR);
d756 1
a756 2
			SSLerror(
			    ERR_R_INTERNAL_ERROR);
d781 1
a781 2
			SSLerror(
			    ERR_R_INTERNAL_ERROR);
d803 1
a803 2
			SSLerror(
			    ERR_R_INTERNAL_ERROR);
d945 1
a945 2
			SSLerror(
			    ERR_R_INTERNAL_ERROR);
d1023 1
a1023 2
			SSLerror(
			    ERR_R_INTERNAL_ERROR);
d1034 1
a1034 2
			SSLerror(
			    ERR_R_INTERNAL_ERROR);
d1057 1
a1057 2
			SSLerror(
			    ERR_R_INTERNAL_ERROR);
d1103 1
a1103 2
			SSLerror(
			    ERR_R_INTERNAL_ERROR);
d1621 1
a1621 2
		SSLerror(
		    SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
d1873 1
a1873 2
		SSLerror(
		    SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
@


1.112
log
@Remove most of SSL3_ENC_METHOD - we can just inline the function calls
and defines since they are the same everywhere.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.111 2017/01/24 14:57:31 jsing Exp $ */
d745 1
a745 1
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT,
d757 1
a757 1
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT,
d783 1
a783 1
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT,
d806 1
a806 1
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT,
d949 1
a949 1
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT,
d1028 1
a1028 1
			SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT,
d1040 1
a1040 1
			SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT,
d1064 1
a1064 1
			SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT,
d1111 1
a1111 1
			SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT,
d1630 1
a1630 1
		SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT,
d1883 1
a1883 1
		SSLerr(SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT,
d2019 1
a2019 1
			SSLerr(SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT, SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);
@


1.111
log
@sk_pop_free() checks for NULL so do not bother doing it from the callers.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.110 2017/01/24 12:24:07 jsing Exp $ */
a127 13
	.mac = tls1_mac,
	.setup_key_block = tls1_setup_key_block,
	.generate_master_secret = tls1_generate_master_secret,
	.change_cipher_state = tls1_change_cipher_state,
	.final_finish_mac = tls1_final_finish_mac,
	.finish_mac_length = TLS1_FINISH_MAC_LENGTH,
	.cert_verify_mac = tls1_cert_verify_mac,
	.client_finished_label = TLS_MD_CLIENT_FINISH_CONST,
	.client_finished_label_len = TLS_MD_CLIENT_FINISH_CONST_SIZE,
	.server_finished_label = TLS_MD_SERVER_FINISH_CONST,
	.server_finished_label_len = TLS_MD_SERVER_FINISH_CONST_SIZE,
	.alert_value = tls1_alert_code,
	.export_keying_material = tls1_export_keying_material,
a132 13
	.mac = tls1_mac,
	.setup_key_block = tls1_setup_key_block,
	.generate_master_secret = tls1_generate_master_secret,
	.change_cipher_state = tls1_change_cipher_state,
	.final_finish_mac = tls1_final_finish_mac,
	.finish_mac_length = TLS1_FINISH_MAC_LENGTH,
	.cert_verify_mac = tls1_cert_verify_mac,
	.client_finished_label = TLS_MD_CLIENT_FINISH_CONST,
	.client_finished_label_len = TLS_MD_CLIENT_FINISH_CONST_SIZE,
	.server_finished_label = TLS_MD_SERVER_FINISH_CONST,
	.server_finished_label_len = TLS_MD_SERVER_FINISH_CONST_SIZE,
	.alert_value = tls1_alert_code,
	.export_keying_material = tls1_export_keying_material,
a137 13
	.mac = tls1_mac,
	.setup_key_block = tls1_setup_key_block,
	.generate_master_secret = tls1_generate_master_secret,
	.change_cipher_state = tls1_change_cipher_state,
	.final_finish_mac = tls1_final_finish_mac,
	.finish_mac_length = TLS1_FINISH_MAC_LENGTH,
	.cert_verify_mac = tls1_cert_verify_mac,
	.client_finished_label = TLS_MD_CLIENT_FINISH_CONST,
	.client_finished_label_len = TLS_MD_CLIENT_FINISH_CONST_SIZE,
	.server_finished_label = TLS_MD_SERVER_FINISH_CONST,
	.server_finished_label_len = TLS_MD_SERVER_FINISH_CONST_SIZE,
	.alert_value = tls1_alert_code,
	.export_keying_material = tls1_export_keying_material,
@


1.110
log
@#if 0 the ecformats_list and eccurves_list - these are currently unused but
will be revisited at some point in the near future.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.109 2017/01/24 09:03:21 jsing Exp $ */
d1596 2
a1597 4
					if (s->internal->tlsext_ocsp_exts) {
						sk_X509_EXTENSION_pop_free(s->internal->tlsext_ocsp_exts,
						    X509_EXTENSION_free);
					}
@


1.109
log
@Add support for setting the supported EC curves via
SSL{_CTX}_set1_groups{_list}() - also provide defines for the previous
SSL{_CTX}_set1_curves{_list} names.

This also changes the default list of EC curves to be X25519, P-256 and
P-384. If you want others (such a brainpool) you need to configure this
yourself.

Inspired by parts of BoringSSL and OpenSSL.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.108 2017/01/24 08:41:53 jsing Exp $ */
a214 1

d247 1
d253 1
d259 1
d291 1
@


1.108
log
@Correct bounds checks used when generating the EC curves extension.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.107 2017/01/24 03:41:43 jsing Exp $ */
d248 1
a248 1
static const uint8_t ecformats_default[] = {
d254 5
a258 1
static const uint16_t eccurves_default[] = {
d290 6
d407 2
a408 2
		*pcurves = SSI(s)->tlsext_ellipticcurvelist;
		*pcurveslen = SSI(s)->tlsext_ellipticcurvelist_length;
d412 2
a413 2
	*pcurves = s->internal->tlsext_ellipticcurvelist;
	*pcurveslen = s->internal->tlsext_ellipticcurvelist_length;
d420 74
d1465 1
a1465 1
				if (SSI(s)->tlsext_ellipticcurvelist) {
d1469 1
a1469 1
				SSI(s)->tlsext_ellipticcurvelist_length = 0;
d1477 2
a1478 2
				SSI(s)->tlsext_ellipticcurvelist = curves;
				SSI(s)->tlsext_ellipticcurvelist_length = curveslen;
d1480 1
a1480 2
		}
		else if (type == TLSEXT_TYPE_session_ticket) {
@


1.107
log
@Fix typo in brainpool curve name within a comment.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.106 2017/01/23 14:35:42 jsing Exp $ */
d755 1
a755 1
		if (curveslen > lenmax)
d757 1
a757 1
		if (curveslen > 65532) {
@


1.106
log
@Move options and mode from SSL_CTX and SSL to internal, since these can be
set and cleared via existing functions.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.105 2017/01/23 13:36:13 jsing Exp $ */
d259 1
a259 1
	28,			/* brainpool512r1 (28) */
@


1.105
log
@Split most of SSL_METHOD out into an internal variant, which is opaque.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.104 2017/01/23 08:48:45 beck Exp $ */
d438 1
a438 1
	server_pref = (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE);
d919 1
a919 1
	if (s->options & SSL_OP_TLSEXT_PADDING) {
d1835 2
a1836 1
	if (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)) {
@


1.104
log
@send state and rstate from ssl_st into internal. There are accessors
so these should not be diddled with directly
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.103 2017/01/23 06:45:30 beck Exp $ */
d194 1
a194 1
	s->method->ssl_clear(s);
d212 1
a212 1
	s->version = s->method->version;
@


1.103
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.102 2017/01/23 05:13:02 jsing Exp $ */
d927 1
a927 1
		if (s->state == SSL23_ST_CW_CLNT_HELLO_A)
@


1.102
log
@Move most of the fields in SSL_CTX to internal - the ones that remain are
known to be in use.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.101 2017/01/23 04:55:27 beck Exp $ */
d204 1
a204 1
	free(s->tlsext_session_ticket);
d379 2
a380 2
	*pformats = s->tlsext_ecpointformatlist;
	*pformatslen = s->tlsext_ecpointformatlist_length;
d402 2
a403 2
	*pcurves = s->tlsext_ellipticcurvelist;
	*pcurveslen = s->tlsext_ellipticcurvelist_length;
d693 1
a693 1
	if (s->renegotiate) {
d778 1
a778 1
		if (!s->new_session && s->session && s->session->tlsext_tick)
d780 3
a782 3
		else if (s->session && s->tlsext_session_ticket &&
		    s->tlsext_session_ticket->data) {
			ticklen = s->tlsext_session_ticket->length;
d787 1
a787 1
			    s->tlsext_session_ticket->data, ticklen);
d791 2
a792 2
		if (ticklen == 0 && s->tlsext_session_ticket &&
		    s->tlsext_session_ticket->data == NULL)
d827 2
a828 2
		for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) {
			id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);
d835 2
a836 2
		if (s->tlsext_ocsp_exts) {
			extlen = i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, NULL);
d850 1
a850 1
		for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) {
d853 1
a853 1
			id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);
d862 1
a862 1
			i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret);
d920 1
a920 1
		int hlen = ret - (unsigned char *)s->init_buf->data;
d967 1
a967 1
	if (!s->hit && s->servername_done == 1 &&
d1033 1
a1033 1
	if (s->tlsext_ticket_expected &&
d1042 1
a1042 1
	if (s->tlsext_status_expected) {
d1051 1
a1051 1
	if (SSL_IS_DTLS(s) && s->srtp_profile) {
d1206 1
a1206 1
	s->servername_done = 0;
d1211 1
a1211 1
	s->srtp_profile = NULL;
d1284 1
a1284 1
				if (s->servername_done == 0)
d1287 1
a1287 1
						if (!s->hit) {
d1309 1
a1309 1
							s->servername_done = 1;
d1313 1
a1313 1
							s->servername_done = s->session->tlsext_hostname &&
d1348 1
a1348 1
			if (!s->hit) {
d1380 1
a1380 1
			if (!s->hit) {
d1450 1
a1450 1
				sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids,
d1452 1
a1452 1
				s->tlsext_ocsp_ids = NULL;
d1454 1
a1454 1
					s->tlsext_ocsp_ids =
d1456 1
a1456 1
					if (s->tlsext_ocsp_ids == NULL) {
d1490 1
a1490 1
					    s->tlsext_ocsp_ids, id)) {
d1510 2
a1511 2
					if (s->tlsext_ocsp_exts) {
						sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,
d1515 1
a1515 1
					s->tlsext_ocsp_exts =
d1518 1
a1518 1
					if (!s->tlsext_ocsp_exts ||
d1537 1
a1537 1
			 * s->new_session will be set on renegotiation, but we
d1583 1
a1583 1
	if (!renegotiate_seen && s->renegotiate) {
d1676 1
a1676 1
			if (!s->hit) {
d1702 1
a1702 1
			s->tlsext_ticket_expected = 1;
d1714 1
a1714 1
			s->tlsext_status_expected = 1;
d1807 1
a1807 1
	if (!s->hit && tlsext_servername == 1) {
d1877 1
a1877 1
		s->servername_done = 0;
d1901 1
a1901 1
			s->tlsext_status_expected = 0;
d1913 1
a1913 1
			s->tlsext_status_expected = 0;
d1917 2
a1918 2
			if (s->tlsext_ocsp_resp)
				s->tlsext_status_expected = 1;
d1920 1
a1920 1
				s->tlsext_status_expected = 0;
d1929 1
a1929 1
		s->tlsext_status_expected = 0;
d1956 2
a1957 2
	if ((s->tlsext_ecpointformatlist != NULL) &&
	    (s->tlsext_ecpointformatlist_length > 0) &&
d1989 1
a1989 1
	if ((s->tlsext_status_type != -1) && !(s->tlsext_status_expected) &&
d1995 3
a1997 3
		free(s->tlsext_ocsp_resp);
		s->tlsext_ocsp_resp = NULL;
		s->tlsext_ocsp_resplen = -1;
d2020 1
a2020 1
		s->servername_done = 0;
d2040 1
a2040 1
 * never be decrypted, nor will s->tlsext_ticket_expected be set to 1.
d2052 1
a2052 1
 *   Sets s->tlsext_ticket_expected to 1 if the server will have to issue
d2057 1
a2057 1
 *   Otherwise, s->tlsext_ticket_expected is set to 0.
d2067 1
a2067 1
	s->tlsext_ticket_expected = 0;
d2119 1
a2119 1
				s->tlsext_ticket_expected = 1;
d2136 1
a2136 1
				s->tlsext_ticket_expected = 1;
d2141 1
a2141 1
				s->tlsext_ticket_expected = 1;
@


1.101
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.100 2017/01/23 04:15:28 jsing Exp $ */
d2209 2
a2210 1
		if (timingsafe_memcmp(etick, tctx->tlsext_tick_key_name, 16))
d2212 2
a2213 2
		HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
		    tlsext_tick_md(), NULL);
d2215 1
a2215 1
		    tctx->tlsext_tick_aes_key, etick + 16);
@


1.100
log
@Move callback function pointers and argument pointers from SSL_CTX to
internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.99 2017/01/22 09:02:07 jsing Exp $ */
d1230 3
a1232 3
		if (s->tlsext_debug_cb)
			s->tlsext_debug_cb(s, 0, type, data, size,
			    s->tlsext_debug_arg);
d1398 2
a1399 2
			if (s->tls_session_ticket_ext_cb &&
			    !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg)) {
d1648 3
a1650 3
		if (s->tlsext_debug_cb)
			s->tlsext_debug_cb(s, 1, type, data, size,
			    s->tlsext_debug_arg);
d1693 2
a1694 2
			if (s->tls_session_ticket_ext_cb &&
			    !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg)) {
d2038 1
a2038 1
 * If s->tls_session_secret_cb is set then we are expecting a pre-shared key
d2047 1
a2047 1
 *    2: either s->tls_session_secret_cb was set, or a ticket was offered but
d2054 1
a2054 1
 *   (and s->tls_session_secret_cb is NULL) but the client either doesn't have
d2122 1
a2122 1
			if (s->tls_session_secret_cb) {
@


1.99
log
@Move most of the SSL3_STATE fields to internal - the ones that remain are
known to be used by ports.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.98 2017/01/22 06:36:49 jsing Exp $ */
d1862 6
a1867 4
	if (s->ctx != NULL && s->ctx->tlsext_servername_callback != 0)
		ret = s->ctx->tlsext_servername_callback(s, &al, s->ctx->tlsext_servername_arg);
	else if (s->initial_ctx != NULL && s->initial_ctx->tlsext_servername_callback != 0)
		ret = s->initial_ctx->tlsext_servername_callback(s, &al, s->initial_ctx->tlsext_servername_arg);
d1895 1
a1895 1
	    s->ctx && s->ctx->tlsext_status_cb) {
d1908 2
a1909 1
		r = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);
d1979 6
a1984 4
	if (s->ctx != NULL && s->ctx->tlsext_servername_callback != 0)
		ret = s->ctx->tlsext_servername_callback(s, &al, s->ctx->tlsext_servername_arg);
	else if (s->initial_ctx != NULL && s->initial_ctx->tlsext_servername_callback != 0)
		ret = s->initial_ctx->tlsext_servername_callback(s, &al, s->initial_ctx->tlsext_servername_arg);
d1990 1
a1990 1
	    s->ctx && s->ctx->tlsext_status_cb) {
d1998 2
a1999 1
		r = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);
d2191 1
a2191 1
	if (tctx->tlsext_ticket_key_cb) {
d2193 2
a2194 2
		int rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,
		    &ctx, &hctx, 0);
@


1.98
log
@Move ALPN and NPN fields from SSL/SSL_CTX to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.97 2017/01/22 05:14:42 beck Exp $ */
d866 1
a866 1
	    !s->s3->tmp.finish_md_len) {
d876 1
a876 1
	    s->s3->tmp.finish_md_len == 0) {
d958 2
a959 2
	alg_a = s->s3->tmp.new_cipher->algorithm_auth;
	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
d976 1
a976 1
	if (s->s3->send_connection_binding) {
d1071 2
a1072 2
	if (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80 ||
	    (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81) &&
d1088 2
a1089 2
	next_proto_neg_seen = s->s3->next_proto_neg_seen;
	s->s3->next_proto_neg_seen = 0;
d1104 1
a1104 1
			s->s3->next_proto_neg_seen = 1;
d1108 3
a1110 3
	if (s->s3->alpn_selected != NULL) {
		const unsigned char *selected = s->s3->alpn_selected;
		unsigned int len = s->s3->alpn_selected_len;
d1178 2
a1179 2
		free(s->s3->alpn_selected);
		if ((s->s3->alpn_selected = malloc(selected_len)) == NULL) {
d1183 2
a1184 2
		memcpy(s->s3->alpn_selected, selected, selected_len);
		s->s3->alpn_selected_len = selected_len;
d1208 3
a1210 3
	s->s3->next_proto_neg_seen = 0;
	free(s->s3->alpn_selected);
	s->s3->alpn_selected = NULL;
d1532 2
a1533 2
		    s->s3->tmp.finish_md_len == 0 &&
		    s->s3->alpn_selected == NULL) {
d1545 1
a1545 1
			 * in this connection is if s->s3->tmp.finish_md_len >
d1549 1
a1549 1
			s->s3->next_proto_neg_seen = 1;
d1554 1
a1554 1
		    s->s3->tmp.finish_md_len == 0) {
d1559 1
a1559 1
			s->s3->next_proto_neg_seen = 0;
d1627 3
a1629 3
	s->s3->next_proto_neg_seen = 0;
	free(s->s3->alpn_selected);
	s->s3->alpn_selected = NULL;
d1717 1
a1717 1
		    s->s3->tmp.finish_md_len == 0) {
d1745 1
a1745 1
			s->s3->next_proto_neg_seen = 1;
d1776 3
a1778 3
			free(s->s3->alpn_selected);
			s->s3->alpn_selected = malloc(len);
			if (s->s3->alpn_selected == NULL) {
d1782 2
a1783 2
			memcpy(s->s3->alpn_selected, data + 3, len);
			s->s3->alpn_selected_len = len;
d1951 2
a1952 2
	unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;
@


1.97
log
@Move internal parts of ssl_session_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.96 2016/12/21 16:44:31 jsing Exp $ */
d865 2
a866 1
	if (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len) {
d875 1
a875 1
	if (s->alpn_client_proto_list != NULL &&
d877 2
a878 1
		if ((size_t)(limit - ret) < 6 + s->alpn_client_proto_list_len)
d881 5
a885 5
		s2n(2 + s->alpn_client_proto_list_len, ret);
		s2n(s->alpn_client_proto_list_len, ret);
		memcpy(ret, s->alpn_client_proto_list,
		    s->alpn_client_proto_list_len);
		ret += s->alpn_client_proto_list_len;
d1090 1
a1090 1
	if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb) {
d1095 2
a1096 2
		r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen,
		    s->ctx->next_protos_advertised_cb_arg);
d1147 1
a1147 1
	if (s->ctx->alpn_select_cb == NULL)
d1174 3
a1176 2
	r = s->ctx->alpn_select_cb(s, &selected, &selected_len,
	    CBS_data(&alpn), CBS_len(&alpn), s->ctx->alpn_select_cb_arg);
d1553 1
a1553 1
		    s->ctx->alpn_select_cb != NULL &&
d1722 1
a1722 1
			if (s->ctx->next_proto_select_cb == NULL) {
d1731 4
a1734 1
			if (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data, size, s->ctx->next_proto_select_cb_arg) != SSL_TLSEXT_ERR_OK) {
d1738 2
a1739 2
			s->next_proto_negotiated = malloc(selected_len);
			if (!s->next_proto_negotiated) {
d1743 2
a1744 2
			memcpy(s->next_proto_negotiated, selected, selected_len);
			s->next_proto_negotiated_len = selected_len;
d1752 1
a1752 1
			if (s->alpn_client_proto_list == NULL) {
@


1.96
log
@Add support for ECDHE with X25519.

Testing of an earlier revision by naddy@@.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.95 2016/12/18 13:52:53 jsing Exp $ */
d374 2
a375 2
		*pformats = s->session->tlsext_ecpointformatlist;
		*pformatslen = s->session->tlsext_ecpointformatlist_length;
d397 2
a398 2
		*pcurves = s->session->tlsext_ellipticcurvelist;
		*pcurveslen = s->session->tlsext_ellipticcurvelist_length;
d959 1
a959 1
	    s->session->tlsext_ecpointformatlist != NULL;
d1346 3
a1348 3
				free(s->session->tlsext_ecpointformatlist);
				s->session->tlsext_ecpointformatlist = NULL;
				s->session->tlsext_ecpointformatlist_length = 0;
d1356 2
a1357 2
				s->session->tlsext_ecpointformatlist = formats;
				s->session->tlsext_ecpointformatlist_length =
d1378 1
a1378 1
				if (s->session->tlsext_ellipticcurvelist) {
d1382 1
a1382 1
				s->session->tlsext_ellipticcurvelist_length = 0;
d1390 2
a1391 2
				s->session->tlsext_ellipticcurvelist = curves;
				s->session->tlsext_ellipticcurvelist_length = curveslen;
d1674 3
a1676 3
				free(s->session->tlsext_ecpointformatlist);
				s->session->tlsext_ecpointformatlist = NULL;
				s->session->tlsext_ecpointformatlist_length = 0;
d1684 2
a1685 2
				s->session->tlsext_ecpointformatlist = formats;
				s->session->tlsext_ecpointformatlist_length =
d1949 2
a1950 2
	    (s->session->tlsext_ecpointformatlist != NULL) &&
	    (s->session->tlsext_ecpointformatlist_length > 0) &&
d1956 2
a1957 2
		list = s->session->tlsext_ecpointformatlist;
		for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) {
@


1.95
log
@Convert ssl3_get_server_hello() to CBS.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.94 2016/11/05 08:26:37 jsing Exp $ */
d244 2
a245 1
	NID_brainpoolP512r1	/* brainpoolP512r1 (28) */
d255 1
d357 2
@


1.94
log
@Convert ssl3_get_server_kex_ecdhe() to CBS, simplifying tls1_check_curve()
in the process. This also fixes a long standing bug where
tls1_ec_curve_id2nid() is called with only one byte of the curve ID.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.93 2016/10/19 16:38:40 jsing Exp $ */
d1610 1
a1610 2
ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d,
    int n, int *al)
d1616 1
a1616 1
	unsigned char *end = d + n;
d1792 1
a1792 1
	if (data != d + n) {
@


1.93
log
@Remove support for fixed ECDH cipher suites - these is not widely supported
and more importantly they do not provide PFS (if you want to use ECDH, use
ECDHE instead).

With input from guenther@@.

ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.92 2016/10/02 21:18:08 guenther Exp $ */
d285 1
a285 1
tls1_ec_curve_id2nid(uint16_t curve_id)
d408 1
a408 1
tls1_check_curve(SSL *s, const unsigned char *p, size_t len)
a409 1
	CBS cbs;
a411 11
	uint8_t type;
	uint16_t cid;

	CBS_init(&cbs, p, len);

	/* Only named curves are supported. */
	if (CBS_len(&cbs) != 3 ||
	    !CBS_get_u8(&cbs, &type) ||
	    type != NAMED_CURVE_TYPE ||
	    !CBS_get_u16(&cbs, &cid))
		return (0);
d416 1
a416 1
		if (curves[i] == cid)
@


1.92
log
@Check for and handle failure of HMAC_{Update,Final} or EVP_DecryptUpdate()

based on openssl commit a5184a6c89ff954261e73d1e8691ab73b9b4b2d4
ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.91 2016/10/02 21:05:44 guenther Exp $ */
d654 1
a654 2
			if ((alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe) ||
			    (alg_a & SSL_aECDSA))) {
d966 1
a966 2
	using_ecc = (alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe) ||
	    alg_a & SSL_aECDSA) &&
d1960 1
a1960 1
	    ((alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe)) || (alg_a & SSL_aECDSA))) {
@


1.91
log
@Detect zero-length encrypted session data early, instead of when malloc(0)
fails or the HMAC check fails.

Noted independently by jsing@@ and Kurt Cancemi (kurt (at) x64architecture.com)
ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.90 2016/09/22 12:33:50 jsing Exp $ */
d2236 7
a2242 2
	HMAC_Update(&hctx, etick, eticklen);
	HMAC_Final(&hctx, tick_hmac, NULL);
d2254 3
a2256 1
	if (!sdec) {
a2259 1
	EVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen);
@


1.90
log
@Avoid unbounded memory growth, which can be triggered by a client
repeatedly renegotiating and sending OCSP Status Request TLS extensions.

Fix based on OpenSSL.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.89 2016/09/22 06:57:40 guenther Exp $ */
d2228 1
a2228 1
	if (eticklen < 16 + EVP_CIPHER_CTX_iv_length(&ctx) + mlen) {
@


1.89
log
@Improve ticket validity checking when tlsext_ticket_key_cb() callback
chooses a different HMAC algorithm.
Avert memory leaks if the callback preps the HMAC in some way.

Based on openssl commit 1bbe48ab149893a78bf99c8eb8895c928900a16f
but retaining a pre-callback length check to guarantee the callback
is provided the buffer that the API claims.

ok bcook@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.88 2016/08/27 15:58:06 jsing Exp $ */
d1447 1
a1447 1
				if (dsize > size  ) {
d1451 18
a1493 7
						return 0;
					}
					if (!s->tlsext_ocsp_ids &&
					    !(s->tlsext_ocsp_ids =
					    sk_OCSP_RESPID_new_null())) {
						OCSP_RESPID_free(id);
						*al = SSL_AD_INTERNAL_ERROR;
@


1.88
log
@Be more strict when parsing TLS extensions.

Based on a diff from Kinichiro Inoguchi.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.87 2016/05/30 13:42:54 beck Exp $ */
d2166 8
a2173 2
	/* Need at least keyname + iv + some encrypted data */
	if (eticklen < 48)
d2175 1
d2184 1
d2189 1
d2204 3
a2206 1
	/* Attempt to process session ticket, first conduct sanity and
d2211 1
d2215 7
d2223 1
d2232 1
@


1.87
log
@deprecate internal use of EVP_[Cipher|Encrypt|Decrypt]_Final.
14 years ago these were changed in OpenSSL to be the same
as the _ex functions. We use the _ex functions only internally
to ensure it is obvious the ctx must be cleared.
ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.86 2016/03/10 23:21:46 mmcc Exp $ */
d1209 1
d1218 1
d1220 1
a1220 1
	if (data >= (d + n - 2))
d1222 3
d1227 2
a1228 2
	if (data > (d + n - len))
		goto ri_check;
d1230 1
a1230 1
	while (data <= (d + n - 4)) {
d1234 3
a1236 2
		if (data + size > (d + n))
			goto ri_check;
d1569 4
d1587 4
a1615 1
	unsigned short length;
d1618 1
d1620 1
d1628 1
a1628 1
	if (data >= (d + n - 2))
d1631 6
a1636 5
	n2s(data, length);
	if (data + length != d + n) {
		*al = SSL_AD_DECODE_ERROR;
		return 0;
	}
d1638 1
a1638 1
	while (data <= (d + n - 4)) {
d1642 2
a1643 2
		if (data + size > (d + n))
			goto ri_check;
d1837 4
@


1.86
log
@http -> https for a few more IETF URLs in comments or man pages
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.85 2015/09/12 16:10:08 doug Exp $ */
d2202 1
a2202 1
	if (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0) {
@


1.85
log
@Remove most of the SSLv3 version checks and a few TLS v1.0.

We can now assume >= TLS v1.0 since SSL2_VERSION, SSL3_VERSION and
DTLS1_BAD_VER support was removed.

"reads ok" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.84 2015/09/01 13:38:27 jsing Exp $ */
d777 1
a777 1
		 * http://www1.ietf.org/mail-archive/web/tls/current/msg00538.html
@


1.84
log
@Remove the ssl_prepare_{client,server}hello_tlsext() functions, which are
now nothing more than noops.

ok bcook@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.83 2015/08/19 23:34:34 bcook Exp $ */
a661 5
	/* don't add extensions for SSLv3 unless doing secure renegotiation */
	if (s->client_version == SSL3_VERSION &&
	    !s->s3->send_connection_binding)
		return p;

a970 4
	/* don't add extensions for SSLv3, unless doing secure renegotiation */
	if (s->version == SSL3_VERSION && !s->s3->send_connection_binding)
		return p;

d2042 1
a2042 1
	if (s->version <= SSL3_VERSION || !limit)
@


1.83
log
@Properly handle missing TLS extensions in client hello as a non-failure.

Noticed by @@Ligushka from github.
ok miod@@, doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.82 2015/07/24 07:57:48 doug Exp $ */
a1828 12
	return 1;
}

int
ssl_prepare_clienthello_tlsext(SSL *s)
{
	return 1;
}

int
ssl_prepare_serverhello_tlsext(SSL *s)
{
@


1.82
log
@Convert tls1_process_ticket to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.81 2015/07/24 03:50:12 doug Exp $ */
d2090 2
@


1.82.4.1
log
@MFC: Correctly handle a ClientHello that contains no TLS extensions, rather
than treating it as invalid and aborting the handshake.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.82 2015/07/24 07:57:48 doug Exp $ */
a2089 2
	if (CBS_len(&session_id) == 0)
		return 0;
@


1.81
log
@Convert tls1_process_sigalgs to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.80 2015/07/19 20:32:18 doug Exp $ */
d2049 1
a2049 1
tls1_process_ticket(SSL *s, unsigned char *session_id, int len,
d2053 1
a2053 2
	const unsigned char *p = session_id + len;
	unsigned short i;
d2063 1
a2063 1
	if ((s->version <= SSL3_VERSION) || !limit)
d2065 2
a2066 1
	if (p >= limit)
d2068 7
d2077 1
a2077 3
		i = *(p++);
		p += i;
		if (p >= limit)
d2080 1
d2082 1
a2082 3
	n2s(p, i);
	p += i;
	if (p >= limit)
d2084 1
d2086 1
a2086 3
	i = *(p++);
	p += i;
	if (p > limit)
d2088 1
d2090 12
a2101 10
	if ((p + 2) >= limit)
		return 0;
	n2s(p, i);
	while ((p + 4) <= limit) {
		unsigned short type, size;
		n2s(p, type);
		n2s(p, size);
		if (p + size > limit)
			return 0;
		if (type == TLSEXT_TYPE_session_ticket) {
d2103 1
a2103 1
			if (size == 0) {
d2117 4
a2120 1
			r = tls_decrypt_ticket(s, p, size, session_id, len, ret);
a2133 1
		p += size;
@


1.80
log
@Allow *_free() functions in libssl to handle NULL input.

This mimics free()'s behavior which makes error handling simpler.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.79 2015/07/17 15:50:37 doug Exp $ */
d2339 1
a2339 1
	int i, idx;
d2342 1
d2349 1
a2349 1
	if (!c)
d2352 2
d2360 8
a2367 2
	for (i = 0; i < dsize; i += 2) {
		unsigned char hash_alg = data[i], sig_alg = data[i + 1];
@


1.79
log
@Remove compat hack that disabled ECDHE-ECDSA on OS X.

For a few old releases, ECDHE-ECDSA was broken on OS X.  This option
cannot differentiate between working and broken OS X so it disabled
ECDHE-ECDSA support on all OS X >= 10.6.  10.8-10.8.3 were the faulty
releases but these are no longer relevant.  Tested on OS X 10.10 by jsing.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.78 2015/06/19 01:38:54 doug Exp $ */
d201 3
@


1.78
log
@Convert tls1_alpn_handle_client_hello() to CBS.

tweak + ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.77 2015/06/17 07:52:22 doug Exp $ */
a1206 81
/* ssl_check_for_safari attempts to fingerprint Safari using OS X
 * SecureTransport using the TLS extension block in |d|, of length |n|.
 * Safari, since 10.6, sends exactly these extensions, in this order:
 *   SNI,
 *   elliptic_curves
 *   ec_point_formats
 *
 * We wish to fingerprint Safari because they broke ECDHE-ECDSA support in 10.8,
 * but they advertise support. So enabling ECDHE-ECDSA ciphers breaks them.
 * Sadly we cannot differentiate 10.6, 10.7 and 10.8.4 (which work), from
 * 10.8..10.8.3 (which don't work).
 */
static void
ssl_check_for_safari(SSL *s, const unsigned char *data, const unsigned char *d,
    int n)
{
	unsigned short type, size;
	static const unsigned char kSafariExtensionsBlock[] = {
		0x00, 0x0a,  /* elliptic_curves extension */
		0x00, 0x08,  /* 8 bytes */
		0x00, 0x06,  /* 6 bytes of curve ids */
		0x00, 0x17,  /* P-256 */
		0x00, 0x18,  /* P-384 */
		0x00, 0x19,  /* P-521 */

		0x00, 0x0b,  /* ec_point_formats */
		0x00, 0x02,  /* 2 bytes */
		0x01,        /* 1 point format */
		0x00,        /* uncompressed */
	};

	/* The following is only present in TLS 1.2 */
	static const unsigned char kSafariTLS12ExtensionsBlock[] = {
		0x00, 0x0d,  /* signature_algorithms */
		0x00, 0x0c,  /* 12 bytes */
		0x00, 0x0a,  /* 10 bytes */
		0x05, 0x01,  /* SHA-384/RSA */
		0x04, 0x01,  /* SHA-256/RSA */
		0x02, 0x01,  /* SHA-1/RSA */
		0x04, 0x03,  /* SHA-256/ECDSA */
		0x02, 0x03,  /* SHA-1/ECDSA */
	};

	if (data >= (d + n - 2))
		return;
	data += 2;

	if (data > (d + n - 4))
		return;
	n2s(data, type);
	n2s(data, size);

	if (type != TLSEXT_TYPE_server_name)
		return;

	if (data + size > d + n)
		return;
	data += size;

	if (TLS1_get_client_version(s) >= TLS1_2_VERSION) {
		const size_t len1 = sizeof(kSafariExtensionsBlock);
		const size_t len2 = sizeof(kSafariTLS12ExtensionsBlock);

		if (data + len1 + len2 != d + n)
			return;
		if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
			return;
		if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
			return;
	} else {
		const size_t len = sizeof(kSafariExtensionsBlock);

		if (data + len != d + n)
			return;
		if (memcmp(data, kSafariExtensionsBlock, len) != 0)
			return;
	}

	s->s3->is_probably_safari = 1;
}

a1222 3

	if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)
		ssl_check_for_safari(s, data, d, n);
@


1.77
log
@Convert ssl_next_proto_validate to CBS.

ok miod@@, tweak + ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.76 2015/06/17 07:36:30 doug Exp $ */
d1156 1
a1158 2
	unsigned int proto_len;
	unsigned int i;
d1167 2
d1173 3
a1175 7
	i = ((unsigned int)data[0]) << 8 | ((unsigned int)data[1]);
	data_len -= 2;
	data += 2;
	if (data_len != i)
		goto parse_error;

	if (data_len < 2)
d1178 4
a1181 3
	for (i = 0; i < data_len; ) {
		proto_len = data[i];
		i++;
d1183 2
a1184 1
		if (proto_len == 0)
a1185 5

		if (i + proto_len < i || i + proto_len > data_len)
			goto parse_error;

		i += proto_len;
d1189 1
a1189 1
	    data, data_len, s->ctx->alpn_select_cb_arg);
@


1.76
log
@Convert tls1_check_curve to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.75 2015/03/02 13:43:09 jsing Exp $ */
d1675 2
a1676 1
/* ssl_next_proto_validate validates a Next Protocol Negotiation block. No
d1678 2
a1679 1
 * the length of the block. */
d1681 1
a1681 1
ssl_next_proto_validate(unsigned char *d, unsigned len)
d1683 1
a1683 1
	unsigned int off = 0;
d1685 4
a1688 2
	while (off < len) {
		if (d[off] == 0)
a1689 2
		off += d[off];
		off++;
d1691 1
a1691 2

	return off == len;
@


1.75
log
@Fix a minor information leak that was introduced in t1_lib.c r1.71, whereby
an additional 28 bytes of .rodata (or .data) is provided to the network. In
most cases this is a non-issue since the memory content is already public.

Issue found and reported by Felix Groebert of the Google Security Team.

ok bcook@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.74 2014/12/14 14:34:43 jsing Exp $ */
d120 1
d407 1
d410 1
d413 2
d416 4
a419 1
	if (len != 3 || p[0] != NAMED_CURVE_TYPE)
a420 2

	cid = (p[1] << 8) | p[2];
@


1.74
log
@unifdef OPENSSL_NO_NEXTPROTONEG, which is one of the last standing #ifndef
mazes in libssl. NPN is being replaced by ALPN, however it is still going
to be around for a while yet.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.73 2014/12/10 15:36:47 jsing Exp $ */
d398 1
a398 1
		*pcurveslen = sizeof(eccurves_default);
@


1.73
log
@Remove support for GOST R 34.10-94 signature authentication, along with
the two ciphersuites that use it. GOST94 public/private keys have been
long obsoleted and libcrypto does not have support for them anyway.

Discussed with Dmitry Eremin-Solenikov.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.72 2014/12/10 14:58:56 jsing Exp $ */
a869 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a877 1
#endif
a958 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a959 1
#endif
a1095 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a1114 1
#endif
a1300 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a1301 1
#endif
a1610 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a1630 1
#endif
a1668 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a1685 1
#endif
a1697 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a1698 1
#endif
a1785 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a1813 1
#endif
@


1.72
log
@Add support for ALPN.

Based on OpenSSL and BoringSSL.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.71 2014/12/06 13:51:06 jsing Exp $ */
a2450 1
	c->pkeys[SSL_PKEY_GOST94].digest = NULL;
a2497 2
	if (!c->pkeys[SSL_PKEY_GOST94].digest)
		c->pkeys[SSL_PKEY_GOST94].digest = EVP_gostr341194();
@


1.71
log
@Use appropriate internal types for EC curves and formats, rather than
storing and processing in wire encoded form.

Inspired by boringssl.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.70 2014/12/06 13:28:56 jsing Exp $ */
d881 12
d1122 14
d1143 70
d1310 2
d1621 2
a1622 1
		    s->s3->tmp.finish_md_len == 0) {
d1641 10
d1713 2
d1830 39
a1868 1
		else if (type == TLSEXT_TYPE_renegotiate) {
@


1.70
log
@Ensure that the client specified EC curve list length is a multiple of two.
The EC curve handling code assumes this to be the case and will read one
byte off the end of the curve list during processing, in the case where it
is not.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.69 2014/12/06 13:21:14 jsing Exp $ */
d243 1
a243 1
static const unsigned char ecformats_default[] = {
d249 29
a277 29
static const unsigned char eccurves_default[] = {
	0,14,			/* sect571r1 (14) */
	0,13,			/* sect571k1 (13) */
	0,25,			/* secp521r1 (25) */
	0,28,			/* brainpool512r1 (28) */
	0,11,			/* sect409k1 (11) */
	0,12,			/* sect409r1 (12) */
	0,27,			/* brainpoolP384r1 (27) */
	0,24,			/* secp384r1 (24) */
	0,9,			/* sect283k1 (9) */
	0,10,			/* sect283r1 (10) */
	0,26,			/* brainpoolP256r1 (26) */
	0,22,			/* secp256k1 (22) */
	0,23,			/* secp256r1 (23) */
	0,8,			/* sect239k1 (8) */
	0,6,			/* sect233k1 (6) */
	0,7,			/* sect233r1 (7) */
	0,20,			/* secp224k1 (20) */
	0,21,			/* secp224r1 (21) */
	0,4,			/* sect193r1 (4) */
	0,5,			/* sect193r2 (5) */
	0,18,			/* secp192k1 (18) */
	0,19,			/* secp192r1 (19) */
	0,1,			/* sect163k1 (1) */
	0,2,			/* sect163r1 (2) */
	0,3,			/* sect163r2 (3) */
	0,15,			/* secp160k1 (15) */
	0,16,			/* secp160r1 (16) */
	0,17,			/* secp160r2 (17) */
d281 1
a281 1
tls1_ec_curve_id2nid(int curve_id)
d290 1
a290 1
int
d362 1
a362 1
tls1_get_formatlist(SSL *s, int client_formats, const unsigned char **pformats,
d385 1
a385 1
tls1_get_curvelist(SSL *s, int client_curves, const unsigned char **pcurves,
d406 1
a406 1
	const unsigned char *curves;
d408 1
d414 2
d418 2
a419 2
	for (i = 0; i < curveslen; i += 2, curves += 2) {
		if (p[1] == curves[0] && p[2] == curves[1])
a427 1
	const unsigned char *pref, *supp, *tsupp;
d429 1
a430 1
	int id;
d441 4
a444 7
	for (i = 0; i < preflen; i += 2, pref += 2) {
		tsupp = supp;
		for (j = 0; j < supplen; j += 2, tsupp += 2) {
			if (pref[0] == tsupp[0] && pref[1] == tsupp[1]) {
				id = (pref[0] << 8) | pref[1];
				return (tls1_ec_curve_id2nid(id));
			}
d452 1
a452 1
tls1_set_ec_id(unsigned char *curve_id, unsigned char *comp_id, EC_KEY *ec)
d475 4
a478 7
	if (id != 0) {
		curve_id[0] = 0;
		curve_id[1] = (unsigned char)id;
	} else {
		curve_id[0] = 0xff;
		curve_id[1] = is_prime ? 0x01 : 0x02;
	}
d498 1
a498 1
tls1_check_ec_key(SSL *s, unsigned char *curve_id, unsigned char *comp_id)
a499 1
	const unsigned char *curves, *formats;
d501 2
d510 2
a511 2
		for (i = 0; i < formatslen; i++, formats++) {
			if (*comp_id == *formats)
d522 3
a524 4
	if (curves != NULL) {
		for (i = 0; i < curveslen; i += 2, curves += 2) {
			if (curves[0] == curve_id[0] &&
			    curves[1] == curve_id[1])
d539 2
a540 1
	unsigned char comp_id, curve_id[2];
d548 1
a548 1
	rv = tls1_set_ec_id(curve_id, &comp_id, pkey->pkey.ec);
d553 1
a553 1
	return tls1_check_ec_key(s, curve_id, &comp_id);
d561 1
a561 1
	unsigned char curve_id[2];
d575 1
a575 1
	if (tls1_set_ec_id(curve_id, NULL, ec) != 1)
d578 1
a578 1
	return tls1_check_ec_key(s, curve_id, NULL);
a722 1
		const unsigned char *curves, *formats;
d724 3
d769 1
a769 1
		s2n(curveslen + 2, ret);
d776 3
a778 3
		s2n(curveslen, ret);
		memcpy(ret, curves, curveslen);
		ret += curveslen;
d1336 2
a1337 1
			int ecpointformatlist_length;
d1340 1
a1340 1
				*al = SSL_AD_DECODE_ERROR;
d1343 2
a1344 3
			ecpointformatlist_length = *(sdata++);

			if (ecpointformatlist_length != size - 1) {
d1348 1
d1351 1
d1353 3
a1355 2
				if ((s->session->tlsext_ecpointformatlist =
				    malloc(ecpointformatlist_length)) == NULL) {
d1359 4
a1362 2
				s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;
				memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);
d1367 2
a1368 1
			int ellipticcurvelist_length;
d1371 1
a1371 1
				*al = SSL_AD_DECODE_ERROR;
d1374 2
a1375 6
			ellipticcurvelist_length = (*(sdata++) << 8);
			ellipticcurvelist_length += (*(sdata++));

			if (ellipticcurvelist_length != size - 2 ||
			    ellipticcurvelist_length < 1 ||
			    ellipticcurvelist_length % 2 != 0) {
d1379 2
d1387 2
a1388 2
				if ((s->session->tlsext_ellipticcurvelist =
				    malloc(ellipticcurvelist_length)) == NULL) {
d1392 4
a1395 2
				s->session->tlsext_ellipticcurvelist_length = ellipticcurvelist_length;
				memcpy(s->session->tlsext_ellipticcurvelist, sdata, ellipticcurvelist_length);
d1636 2
a1637 1
			int ecpointformatlist_length = *(sdata++);
d1639 1
a1639 2
			if (ecpointformatlist_length != size - 1 ||
			    ecpointformatlist_length < 1) {
d1643 6
d1651 1
d1654 2
a1655 2
				if ((s->session->tlsext_ecpointformatlist =
				    malloc(ecpointformatlist_length)) == NULL) {
d1659 2
d1662 1
a1662 3
				    ecpointformatlist_length;
				memcpy(s->session->tlsext_ecpointformatlist,
				    sdata, ecpointformatlist_length);
@


1.69
log
@Fix two cases where it is possible to read one or two bytes past the end of
the buffer. The later size check would catch this, however reading first
and checking later is less than ideal.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.68 2014/12/02 20:46:19 miod Exp $ */
d1373 2
a1374 1
			    ellipticcurvelist_length < 1) {
@


1.68
log
@Add brainpool curves to eccurves_default[], accidentally missing from 1.32;
from OpenSSL HEAD via Thomas Jakobi.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.67 2014/11/18 05:33:43 miod Exp $ */
d1337 7
a1343 1
			int ecpointformatlist_length = *(sdata++);
d1363 7
a1369 1
			int ellipticcurvelist_length = (*(sdata++) << 8);
@


1.67
log
@Update the GOST code in libssl, as contributed by Dmitry Eremin-Solenikov.

This causes a libssl major version bump as this affects the layout of some
internal-but-unfortunately-made-visible structs.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.66 2014/11/03 17:21:30 tedu Exp $ */
d252 2
a253 1
	0,25,			/* secp521r1 (25) */	
d256 1
d260 1
@


1.66
log
@only call SRTP (whatever that is) functions when the connection type is
DTLS (whatever that is) instead of for TLS too. ok jsing.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.65 2014/10/18 16:13:16 jsing Exp $ */
d590 3
d602 5
d2177 4
a2180 1
	{NID_sha512, TLSEXT_hash_sha512}
d2186 2
a2187 1
	{EVP_PKEY_EC, TLSEXT_signature_ecdsa}
d2240 8
d2274 2
d2290 5
d2321 6
@


1.65
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.64 2014/10/15 14:02:16 jsing Exp $ */
d872 1
a872 1
	if (SSL_get_srtp_profiles(s)) {
d1041 1
a1041 1
	if (s->srtp_profile) {
d1516 1
a1516 1
		else if (type == TLSEXT_TYPE_use_srtp) {
d1689 1
a1689 1
		else if (type == TLSEXT_TYPE_use_srtp) {
@


1.64
log
@Only require an EC public key in tls1_set_ec_id(), if we need to provide
a compression identifier. In the case of a server using ephemeral EC keys,
the supplied key is unlikely to have a public key where
SSL_CTX_set_tmp_ecdh() is called after SSL_OP_SINGLE_ECDH_USE has been
set. This makes ECDHE ciphers work again for this use case.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.63 2014/10/05 14:56:32 jsing Exp $ */
a117 1
#include <openssl/rand.h>
@


1.63
log
@Use more specific curves/formats naming for local variables in
ssl_add_clienthello_tlsext() and ssl_add_serverhello_tlsext(), rather than
the current generic naming.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.60 2014/10/03 13:58:18 jsing Exp $ */
a460 3
	if (EC_KEY_get0_public_key(ec) == NULL)
		return (0);

d484 3
@


1.62
log
@Use tls1_get_curvelist() in ssl_add_clienthello_tlsext(), rather than
hand rolling the same code.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.61 2014/10/05 14:47:30 jsing Exp $ */
d716 3
d722 1
a722 5
		const unsigned char *plist;
		size_t plistlen;
		size_t lenmax;

		tls1_get_formatlist(s, 0, &plist, &plistlen);
d728 1
a728 1
		if (plistlen > lenmax)
d730 1
a730 1
		if (plistlen > 255) {
d737 4
a740 4
		s2n(plistlen + 1, ret);
		*(ret++) = (unsigned char)plistlen;
		memcpy(ret, plist, plistlen);
		ret += plistlen;
d745 1
a745 1
		tls1_get_curvelist(s, 0, &plist, &plistlen);
d751 1
a751 1
		if (plistlen > lenmax)
d753 1
a753 1
		if (plistlen > 65532) {
d760 1
a760 1
		s2n(plistlen + 2, ret);
d767 3
a769 3
		s2n(plistlen, ret);
		memcpy(ret, plist, plistlen);
		ret += plistlen;
d992 3
d998 1
a998 5
		const unsigned char *plist;
		size_t plistlen;
		size_t lenmax;

		tls1_get_formatlist(s, 0, &plist, &plistlen);
d1004 1
a1004 1
		if (plistlen > lenmax)
d1006 1
a1006 1
		if (plistlen > 255) {
d1013 4
a1016 4
		s2n(plistlen + 1, ret);
		*(ret++) = (unsigned char)plistlen;
		memcpy(ret, plist, plistlen);
		ret += plistlen;
@


1.61
log
@Make tls1_get_formatlist() behave the same as tls1_get_curvelist() and
return the client format list if the client_formats flag is specified.
Use tls1_get_formatlist()/tls1_get_curvelist() in tls1_check_ec_key(),
simplifying the code.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.60 2014/10/03 13:58:18 jsing Exp $ */
d746 1
a746 10
		plist = s->tlsext_ellipticcurvelist;
		plistlen = s->tlsext_ellipticcurvelist_length;

		/*
		 * If we have a custom curve list use it otherwise use default.
		 */
		if (plist == NULL) {
			plist = eccurves_default;
			plistlen = sizeof(eccurves_default);
		}
@


1.60
log
@Add support for automatic ephemeral EC keys.

This allows an SSL server to enable ECDHE ciphers with a single setting,
which results in an EC key being generated using the first preference
shared curve.

Based on OpenSSL with inspiration from boringssl.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.58 2014/09/27 11:01:06 jsing Exp $ */
d354 5
d360 2
a361 1
tls1_get_formatlist(SSL *s, const unsigned char **pformats, size_t *pformatslen)
d363 6
a368 3
	/*
	 * If we have a custom point format list use it, otherwise use default.
	 */
d502 2
a503 2
	const unsigned char *p;
	size_t plen, i;
d509 4
a512 5
	if (comp_id != NULL && s->session->tlsext_ecpointformatlist != NULL) {
		p = s->session->tlsext_ecpointformatlist;
		plen = s->session->tlsext_ecpointformatlist_length;
		for (i = 0; i < plen; i++, p++) {
			if (*comp_id == *p)
d515 1
a515 1
		if (i == plen)
d522 5
a526 5
	if (s->session->tlsext_ellipticcurvelist != NULL) {
		p = s->session->tlsext_ellipticcurvelist;
		plen = s->session->tlsext_ellipticcurvelist_length;
		for (i = 0; i < plen; i += 2, p += 2) {
			if (p[0] == curve_id[0] && p[1] == curve_id[1])
d529 1
a529 1
		if (i == plen)
d723 1
a723 1
		tls1_get_formatlist(s, &plist, &plistlen);
d1009 1
a1009 1
		tls1_get_formatlist(s, &plist, &plistlen);
@


1.59
log
@Clean up EC cipher handling in ssl3_choose_cipher().

The existing code reaches around into various internals of EC, which it
should not know anything about. Replace this with a set of functions that
that can correctly extract the necessary details and handle the
comparisions.

Based on a commit to OpenSSL, with some inspiration from boringssl.

ok miod@@
@
text
@d411 29
d556 7
d566 1
a566 2
		else
			return (0);
@


1.58
log
@Check that the specified curve is one of the client preferences.

Based on OpenSSL.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.57 2014/09/26 14:58:42 jsing Exp $ */
d113 1
a113 1
#include <openssl/objects.h>
d116 1
d119 1
d411 128
a2264 1

@


1.57
log
@Now that we have a static version of the default EC formats, also use it
for the server hello.

From OpenSSL.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.56 2014/09/22 14:26:22 jsing Exp $ */
d364 43
@


1.56
log
@Refactor and simplify the ECC extension handling. The existing code
effectively built two "static" data structures - instead of doing this,
just use static data structures to start with.

From OpenSSL (part of a larger commit).

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.55 2014/09/21 17:11:04 jsing Exp $ */
d352 14
a502 1
		size_t lenmax;
d505 1
d507 1
a507 10
		/*
		 * If we have a custom point format list use it otherwise
		 * use default.
		 */
		plist = s->tlsext_ecpointformatlist;
		plistlen = s->tlsext_ecpointformatlist_length;
		if (plist == NULL) {
			plist = ecformats_default;
			plistlen = sizeof(ecformats_default);
		}
d731 2
a732 1
	int extdatalen = 0;
d738 6
d785 6
a790 3
	if (s->tlsext_ecpointformatlist != NULL &&
	    s->version != DTLS1_VERSION) {
		/* Add TLS extension ECPointFormats to the ServerHello message */
d793 2
d799 1
a799 1
		if (s->tlsext_ecpointformatlist_length > lenmax)
d801 1
a801 1
		if (s->tlsext_ecpointformatlist_length > 255) {
d808 5
a812 5
		s2n(s->tlsext_ecpointformatlist_length + 1, ret);
		*(ret++) = (unsigned char) s->tlsext_ecpointformatlist_length;
		memcpy(ret, s->tlsext_ecpointformatlist,
		    s->tlsext_ecpointformatlist_length);
		ret += s->tlsext_ecpointformatlist_length;
d814 4
a817 2
	}
	/* Currently the server should not respond with a SupportedCurves extension */
a1547 22
	/* If we are server and using an ECC cipher suite, send the point formats we support
	 * if the client sent us an ECPointsFormat extension.  Note that the server is not
	 * supposed to send an EllipticCurves extension.
	 */

	unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;
	int using_ecc = (alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe)) || (alg_a & SSL_aECDSA);
	using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);

	if (using_ecc) {
		free(s->tlsext_ecpointformatlist);
		if ((s->tlsext_ecpointformatlist = malloc(3)) == NULL) {
			SSLerr(SSL_F_SSL_PREPARE_SERVERHELLO_TLSEXT, ERR_R_MALLOC_FAILURE);
			return -1;
		}
		s->tlsext_ecpointformatlist_length = 3;
		s->tlsext_ecpointformatlist[0] = TLSEXT_ECPOINTFORMAT_uncompressed;
		s->tlsext_ecpointformatlist[1] = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime;
		s->tlsext_ecpointformatlist[2] = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2;
	}

@


1.55
log
@Move the TLS padding extension under an SSL_OP_TLSEXT_PADDING option, which
is off by default (instead of being enabled unconditionally).

The TLS padding extension was added as a workaround for a bug in F5 SSL
terminators, however appears to trigger bugs in IronPort SMTP appliances.
Now the SSL client gets to choose which of these devices it wants to
trigger bugs in...

Ported from OpenSSL.

Discussed with many.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.54 2014/08/07 22:27:28 guenther Exp $ */
d242 32
a273 29
static int pref_list[] = {
	NID_sect571r1,		/* sect571r1 (14) */
	NID_sect571k1,		/* sect571k1 (13) */
	NID_secp521r1,		/* secp521r1 (25) */
	NID_brainpoolP512r1,	/* brainpoolP512r1 (28) */
	NID_sect409k1,		/* sect409k1 (11) */
	NID_sect409r1,		/* sect409r1 (12) */
	NID_brainpoolP384r1,	/* brainpoolP384r1 (27) */
	NID_secp384r1,		/* secp384r1 (24) */
	NID_sect283k1,		/* sect283k1 (9) */
	NID_sect283r1,		/* sect283r1 (10) */
	NID_brainpoolP256r1,	/* brainpoolP256r1 (26) */
	NID_secp256k1,		/* secp256k1 (22) */
	NID_X9_62_prime256v1,	/* secp256r1 (23) */
	NID_sect239k1,		/* sect239k1 (8) */
	NID_sect233k1,		/* sect233k1 (6) */
	NID_sect233r1,		/* sect233r1 (7) */
	NID_secp224k1,		/* secp224k1 (20) */
	NID_secp224r1,		/* secp224r1 (21) */
	NID_sect193r1,		/* sect193r1 (4) */
	NID_sect193r2,		/* sect193r2 (5) */
	NID_secp192k1,		/* secp192k1 (18) */
	NID_X9_62_prime192v1,	/* secp192r1 (19) */
	NID_sect163k1,		/* sect163k1 (1) */
	NID_sect163r1,		/* sect163r1 (2) */
	NID_sect163r2,		/* sect163r2 (3) */
	NID_secp160k1,		/* secp160k1 (15) */
	NID_secp160r1,		/* secp160r1 (16) */
	NID_secp160r2,		/* secp160r2 (17) */
d394 21
d485 7
d493 10
a502 4
	if (s->tlsext_ecpointformatlist != NULL &&
	    s->version != DTLS1_VERSION) {
		/* Add TLS extension ECPointFormats to the ClientHello message */
		size_t lenmax;
d508 1
a508 1
		if (s->tlsext_ecpointformatlist_length > lenmax)
d510 1
a510 1
		if (s->tlsext_ecpointformatlist_length > 255) {
d517 18
a534 10
		s2n(s->tlsext_ecpointformatlist_length + 1, ret);
		*(ret++) = (unsigned char) s->tlsext_ecpointformatlist_length;
		memcpy(ret, s->tlsext_ecpointformatlist,
		    s->tlsext_ecpointformatlist_length);
		ret += s->tlsext_ecpointformatlist_length;
	}
	if (s->tlsext_ellipticcurvelist != NULL &&
	    s->version != DTLS1_VERSION) {
		/* Add TLS extension EllipticCurves to the ClientHello message */
		size_t lenmax;
d540 1
a540 1
		if (s->tlsext_ellipticcurvelist_length > lenmax)
d542 1
a542 1
		if (s->tlsext_ellipticcurvelist_length > 65532) {
d549 1
a549 1
		s2n(s->tlsext_ellipticcurvelist_length + 2, ret);
d556 3
a558 4
		s2n(s->tlsext_ellipticcurvelist_length, ret);
		memcpy(ret, s->tlsext_ellipticcurvelist,
		    s->tlsext_ellipticcurvelist_length);
		ret += s->tlsext_ellipticcurvelist_length;
a1522 48
	/* If we are client and using an elliptic curve cryptography cipher suite, send the point formats
	 * and elliptic curves we support.
	 */
	int using_ecc = 0;
	int i;
	unsigned char *j;
	unsigned long alg_k, alg_a;
	STACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s);

	for (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++) {
		SSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i);

		alg_k = c->algorithm_mkey;
		alg_a = c->algorithm_auth;
		if ((alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe) ||
		    (alg_a & SSL_aECDSA))) {
			using_ecc = 1;
			break;
		}
	}
	using_ecc = using_ecc && (s->version >= TLS1_VERSION);
	if (using_ecc) {
		free(s->tlsext_ecpointformatlist);
		if ((s->tlsext_ecpointformatlist = malloc(3)) == NULL) {
			SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,
			    ERR_R_MALLOC_FAILURE);
			return -1;
		}
		s->tlsext_ecpointformatlist_length = 3;
		s->tlsext_ecpointformatlist[0] = TLSEXT_ECPOINTFORMAT_uncompressed;
		s->tlsext_ecpointformatlist[1] = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime;
		s->tlsext_ecpointformatlist[2] = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2;

		/* we support all named elliptic curves in draft-ietf-tls-ecc-12 */
		free(s->tlsext_ellipticcurvelist);
		s->tlsext_ellipticcurvelist_length = sizeof(pref_list) / sizeof(pref_list[0]) * 2;
		if ((s->tlsext_ellipticcurvelist = malloc(s->tlsext_ellipticcurvelist_length)) == NULL) {
			s->tlsext_ellipticcurvelist_length = 0;
			SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,
			    ERR_R_MALLOC_FAILURE);
			return -1;
		}
		for (i = 0, j = s->tlsext_ellipticcurvelist; (unsigned int)i < sizeof(pref_list) / sizeof(pref_list[0]); i++) {
			int id = tls1_ec_nid2curve_id(pref_list[i]);
			s2n(id, j);
		}
	}

@


1.54
log
@Correct test reversed during merge of fix for CVE-2014-3509

pointed out by Watson Ladd (watson (at) matasano.com)
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.53 2014/08/06 23:16:16 deraadt Exp $ */
d638 2
a639 2
#ifdef TLSEXT_TYPE_padding
	/* Add padding to workaround bugs in F5 terminators.
d642 3
d648 1
a648 1
	{
d650 6
a655 3
	/* The code in s23_clnt.c to build ClientHello messages includes the
	 * 5-byte record header in the buffer, while the code in s3_clnt.c does
	 * not. */
a670 1
#endif
@


1.53
log
@merge fix for CVE-2014-3509 -- basically a missing s->hit check; ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.52 2014/07/13 16:33:01 jsing Exp $ */
d1342 1
a1342 1
			if (s->hit) {
@


1.52
log
@Expand the tlsext_sigalg macros. The end result is about the same number
of lines and much more readable.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.51 2014/07/13 16:03:10 beck Exp $ */
d1342 3
a1344 1
			s->session->tlsext_ecpointformatlist_length = 0;
d1346 9
a1354 5
			free(s->session->tlsext_ecpointformatlist);
			if ((s->session->tlsext_ecpointformatlist =
			    malloc(ecpointformatlist_length)) == NULL) {
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
a1355 2
			s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;
			memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);
@


1.51
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.50 2014/07/12 22:33:39 jsing Exp $ */
d349 2
a350 2

/* List of supported signature algorithms and hashes. Should make this
a353 11
#define tlsext_sigalg_rsa(md) md, TLSEXT_signature_rsa,

#define tlsext_sigalg_dsa(md) md, TLSEXT_signature_dsa,

#define tlsext_sigalg_ecdsa(md) md, TLSEXT_signature_ecdsa,

#define tlsext_sigalg(md) \
	tlsext_sigalg_rsa(md) \
	tlsext_sigalg_dsa(md) \
	tlsext_sigalg_ecdsa(md)

d355 19
a373 5
	tlsext_sigalg(TLSEXT_hash_sha512)
	tlsext_sigalg(TLSEXT_hash_sha384)
	tlsext_sigalg(TLSEXT_hash_sha256)
	tlsext_sigalg(TLSEXT_hash_sha224)
	tlsext_sigalg(TLSEXT_hash_sha1)
@


1.50
log
@The correct name for EDH is DHE, likewise EECDH should be ECDHE.

Based on changes to OpenSSL trunk.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.49 2014/07/09 11:10:51 bcook Exp $ */
d1429 2
a1430 1
				s->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);
@


1.49
log
@remove unused, private version strings except SSL_version_str

Also remove unused des_ver.h, which exports some of these strings, but is not installed.

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.48 2014/06/19 21:29:51 tedu Exp $ */
d1480 1
a1480 1
		if ((alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe) ||
d1527 1
a1527 1
	int using_ecc = (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) || (alg_a & SSL_aECDSA);
d1653 1
a1653 1
	    ((alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) || (alg_a & SSL_aECDSA))) {
@


1.48
log
@convert CRYPTO_memcmp to timingsafe_memcmp based on current policy favoring
libc interfaces over libcrypto interfaces. for now we also prefer
timingsafe_memcmp over timingsafe_bcmp, even when the latter is acceptable.
ok beck deraadt matthew miod
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.47 2014/06/18 04:49:40 miod Exp $ */
a118 2

const char tls1_version_str[] = "TLSv1" OPENSSL_VERSION_PTEXT;
@


1.47
log
@Make sure to always invoke EVP_CIPHER_CTX_cleanup() before returning in the
error paths from tls_decrypt_ticket().

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.46 2014/06/13 04:29:13 miod Exp $ */
d1882 1
a1882 1
		if (CRYPTO_memcmp(etick, tctx->tlsext_tick_key_name, 16))
d1902 1
a1902 1
	if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {
@


1.46
log
@Remove support for the `opaque PRF input' extension, which draft has expired
7 years ago and never made it into an RFC. That code wasn't compiled in
anyway unless one would define the actual on-the-wire extension id bytes;
crank libssl major.

With help and enlightenment from Brendan MacDonell.
@
text
@d1 1
a1 1
/* $OpenBSD: t1_lib.c,v 1.45 2014/06/12 15:49:31 deraadt Exp $ */
d1870 2
a1871 1
		if (rv < 0)
d1873 3
a1875 1
		if (rv == 0)
d1877 1
d1902 2
a1903 1
	if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen))
d1905 1
@


1.45
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a559 19
#ifdef TLSEXT_TYPE_opaque_prf_input
	if (s->s3->client_opaque_prf_input != NULL &&
	    s->version != DTLS1_VERSION) {
		size_t col = s->s3->client_opaque_prf_input_len;

		if ((size_t)(limit - ret) < 6 + col)
			return NULL;
		if (col > 0xFFFD) /* can't happen */
			return NULL;

		s2n(TLSEXT_TYPE_opaque_prf_input, ret);

		s2n(col + 2, ret);
		s2n(col, ret);
		memcpy(ret, s->s3->client_opaque_prf_input, col);
		ret += col;
	}
#endif

a766 19
#ifdef TLSEXT_TYPE_opaque_prf_input
	if (s->s3->server_opaque_prf_input != NULL &&
	    s->version != DTLS1_VERSION) {
		size_t sol = s->s3->server_opaque_prf_input_len;

		if ((size_t)(limit - ret) < 6 + sol)
			return NULL;
		if (sol > 0xFFFD) /* can't happen */
			return NULL;

		s2n(TLSEXT_TYPE_opaque_prf_input, ret);

		s2n(sol + 2, ret);
		s2n(sol, ret);
		memcpy(ret, s->s3->server_opaque_prf_input, sol);
		ret += sol;
	}
#endif

a1095 29
#ifdef TLSEXT_TYPE_opaque_prf_input
		else if (type == TLSEXT_TYPE_opaque_prf_input &&
		    s->version != DTLS1_VERSION) {
			unsigned char *sdata = data;

			if (size < 2) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
			n2s(sdata, s->s3->client_opaque_prf_input_len);
			if (s->s3->client_opaque_prf_input_len != size - 2) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}

			free(s->s3->client_opaque_prf_input);
			s->s3->client_opaque_prf_input = NULL;

			if (s->s3->client_opaque_prf_input_len != 0) {
				s->s3->client_opaque_prf_input =
				    BUF_memdup(sdata,
				      s->s3->client_opaque_prf_input_len);
				if (s->s3->client_opaque_prf_input == NULL) {
					*al = TLS1_AD_INTERNAL_ERROR;
					return 0;
				}
			}
		}
#endif
a1363 29
#ifdef TLSEXT_TYPE_opaque_prf_input
		else if (type == TLSEXT_TYPE_opaque_prf_input &&
		    s->version != DTLS1_VERSION) {
			unsigned char *sdata = data;

			if (size < 2) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
			n2s(sdata, s->s3->server_opaque_prf_input_len);
			if (s->s3->server_opaque_prf_input_len != size - 2) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}

			free(s->s3->server_opaque_prf_input);
			s->s3->server_opaque_prf_input = NULL;

			if (s->s3->server_opaque_prf_input_len != 0)
				s->s3->server_opaque_prf_input =
				    BUF_memdup(sdata,
					s->s3->server_opaque_prf_input_len);
				if (s->s3->server_opaque_prf_input == NULL) {
					*al = TLS1_AD_INTERNAL_ERROR;
					return 0;
				}
			}
		}
#endif
a1515 36
#ifdef TLSEXT_TYPE_opaque_prf_input
	{
		int r = 1;

		if (s->ctx->tlsext_opaque_prf_input_callback != 0) {
			r = s->ctx->tlsext_opaque_prf_input_callback(s, NULL, 0,
			    s->ctx->tlsext_opaque_prf_input_callback_arg);
			if (!r)
				return -1;
		}

		if (s->tlsext_opaque_prf_input != NULL) {
			free(s->s3->client_opaque_prf_input);
			s->s3->client_opaque_prf_input = NULL;
			if (s->tlsext_opaque_prf_input_len != 0) {
				s->s3->client_opaque_prf_input =
				    BUF_memdup(s->tlsext_opaque_prf_input,
				      s->tlsext_opaque_prf_input_len);
				if (s->s3->client_opaque_prf_input == NULL) {
					SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,
					    ERR_R_MALLOC_FAILURE);
					return -1;
				}
			}
			s->s3->client_opaque_prf_input_len =
			    s->tlsext_opaque_prf_input_len;
		}

		if (r == 2) {
			/* at callback's request, insist on receiving an appropriate server opaque PRF input */
			s->s3->server_opaque_prf_input_len =
			    s->tlsext_opaque_prf_input_len;
		}
	}
#endif

a1564 59
#ifdef TLSEXT_TYPE_opaque_prf_input
	{
		/* This sort of belongs into ssl_prepare_serverhello_tlsext(),
		 * but we might be sending an alert in response to the client hello,
		 * so this has to happen here in
		 * ssl_check_clienthello_tlsext_early(). */

		int r = 1;

		if (s->ctx->tlsext_opaque_prf_input_callback != 0) {
			r = s->ctx->tlsext_opaque_prf_input_callback(s, NULL, 0,
			    s->ctx->tlsext_opaque_prf_input_callback_arg);
			if (!r) {
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;
				al = SSL_AD_INTERNAL_ERROR;
				goto err;
			}
		}

		free(s->s3->server_opaque_prf_input);
		s->s3->server_opaque_prf_input = NULL;

		if (s->tlsext_opaque_prf_input != NULL) {
			if (s->s3->client_opaque_prf_input != NULL &&
			    s->s3->client_opaque_prf_input_len ==
			      s->tlsext_opaque_prf_input_len) {
				/*
				 * Can only use this extension if we have a
				 * server opaque PRF input of the same length
				 * as the client opaque PRF input!
				 */
				if (s->tlsext_opaque_prf_input_len != 0) {
					s->s3->server_opaque_prf_input =
					    BUF_memdup(s->tlsext_opaque_prf_input,
					      s->tlsext_opaque_prf_input_len);
					if (s->s3->server_opaque_prf_input ==
					    NULL) {
						ret = SSL_TLSEXT_ERR_ALERT_FATAL;
						al = SSL_AD_INTERNAL_ERROR;
						goto err;
					}
				}
				s->s3->server_opaque_prf_input_len =
				    s->tlsext_opaque_prf_input_len;
			}
		}

		if (r == 2 && s->s3->server_opaque_prf_input == NULL) {
			/* The callback wants to enforce use of the extension,
			 * but we can't do that with the client opaque PRF input;
			 * abort the handshake.
			 */
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
			al = SSL_AD_HANDSHAKE_FAILURE;
		}
	}

err:
#endif
a1677 21

#ifdef TLSEXT_TYPE_opaque_prf_input
	if (s->s3->server_opaque_prf_input_len > 0) {
		/* This case may indicate that we, as a client, want to insist on using opaque PRF inputs.
		 * So first verify that we really have a value from the server too. */

		if (s->s3->server_opaque_prf_input == NULL) {
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
			al = SSL_AD_HANDSHAKE_FAILURE;
		}

		/* Anytime the server *has* sent an opaque PRF input, we need to check
		 * that we have a client opaque PRF input of the same size. */
		if (s->s3->client_opaque_prf_input == NULL ||
		    s->s3->client_opaque_prf_input_len !=
		      s->s3->server_opaque_prf_input_len) {
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
			al = SSL_AD_ILLEGAL_PARAMETER;
		}
	}
#endif
@


1.44
log
@Sanitize use of client_opaque_prf_input: set it to NULL immediately after
free()ing it, rather than in conditional code.

Also do not bother setting server_opaque_prf_input (server, not client) to
NULL in conditional code 10 lines after explicitely free()ing it and setting
it to NULL (were the developers afraid of zombie pointers?)

ok guenther@@
@
text
@d1 1
a1 1
/* ssl/t1_lib.c */
@


1.43
log
@without overthinking it, replace a few memcmp calls with CRYPTO_memcmp
where it is feasible to do so. better safe than sorry.
@
text
@d1150 1
d1152 1
a1152 3
			if (s->s3->client_opaque_prf_input_len == 0)
				s->s3->client_opaque_prf_input = NULL;
			else {
d1617 2
a1618 1
			r = s->ctx->tlsext_opaque_prf_input_callback(s, NULL, 0, s->ctx->tlsext_opaque_prf_input_callback_arg);
d1625 2
a1626 3
			if (s->tlsext_opaque_prf_input_len == 0)
				s->s3->client_opaque_prf_input = NULL;
			else {
d1636 2
a1637 1
			s->s3->client_opaque_prf_input_len = s->tlsext_opaque_prf_input_len;
d1707 2
a1708 1
			r = s->ctx->tlsext_opaque_prf_input_callback(s, NULL, 0, s->ctx->tlsext_opaque_prf_input_callback_arg);
d1721 8
a1728 7
			    s->s3->client_opaque_prf_input_len == s->tlsext_opaque_prf_input_len) {
				/* can only use this extension if we have a server opaque PRF input
				 * of the same length as the client opaque PRF input! */

				if (s->tlsext_opaque_prf_input_len == 0)
					s->s3->server_opaque_prf_input = NULL;
				else {
d1739 2
a1740 1
				s->s3->server_opaque_prf_input_len = s->tlsext_opaque_prf_input_len;
d1883 2
a1884 1
		    s->s3->client_opaque_prf_input_len != s->s3->server_opaque_prf_input_len) {
@


1.42
log
@ECDH and ECDSA will not work overly well if there is no EC, so unifdef
OPENSSL_NO_EC.

ok tedu@@
@
text
@d2086 1
a2086 1
		if (memcmp(etick, tctx->tlsext_tick_key_name, 16))
@


1.41
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@a211 1
#ifndef OPENSSL_NO_EC
a349 1
#endif /* OPENSSL_NO_EC */
a460 1
#ifndef OPENSSL_NO_EC
a514 1
#endif /* OPENSSL_NO_EC */
a741 1
#ifndef OPENSSL_NO_EC
a767 1
#endif /* OPENSSL_NO_EC */
a871 1
#ifndef OPENSSL_NO_EC
a951 1
#endif /* !OPENSSL_NO_EC */
a969 1
#ifndef OPENSSL_NO_EC
a971 1
#endif /* !OPENSSL_NO_EC */
a1087 1
#ifndef OPENSSL_NO_EC
a1133 1
#endif /* OPENSSL_NO_EC */
a1398 1
#ifndef OPENSSL_NO_EC
a1419 1
#endif /* OPENSSL_NO_EC */
a1564 1
#ifndef OPENSSL_NO_EC
a1611 1
#endif /* OPENSSL_NO_EC */
a1653 1
#ifndef OPENSSL_NO_EC
a1674 1
#endif /* OPENSSL_NO_EC */
a1684 1
#ifndef OPENSSL_NO_EC
a1690 1
#endif
a1832 1
#ifndef OPENSSL_NO_EC
a1860 1
#endif /* OPENSSL_NO_EC */
@


1.40
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@a121 1
#ifndef OPENSSL_NO_TLSEXT
a124 1
#endif
a200 1
#ifndef OPENSSL_NO_TLSEXT
a201 1
#endif /* OPENSSL_NO_TLSEXT */
a352 1
#ifndef OPENSSL_NO_TLSEXT
a2312 1
#endif
@


1.39
log
@Make use of SSL_IS_DTLS, SSL_USE_EXPLICIT_IV, SSL_USE_SIGALGS and
SSL_USE_TLS1_2_CIPHERS.

Largely based on OpenSSL head.
@
text
@a1000 3
#if 0
		fprintf(stderr, "Received extension type %d size %d\n", type, size);
#endif
a1123 7
#if 0
			fprintf(stderr, "ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) ", s->session->tlsext_ecpointformatlist_length);
			sdata = s->session->tlsext_ecpointformatlist;
			for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)
				fprintf(stderr, "%i ", *(sdata++));
			fprintf(stderr, "\n");
#endif
a1148 7
#if 0
			fprintf(stderr, "ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) ", s->session->tlsext_ellipticcurvelist_length);
			sdata = s->session->tlsext_ellipticcurvelist;
			for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++)
				fprintf(stderr, "%i ", *(sdata++));
			fprintf(stderr, "\n");
#endif
a1436 7
#if 0
			fprintf(stderr, "ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist ");
			sdata = s->session->tlsext_ecpointformatlist;
			for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)
				fprintf(stderr, "%i ", *(sdata++));
			fprintf(stderr, "\n");
#endif
a2208 12
#if 0
static int
tls12_find_nid(int id, tls12_lookup *table, size_t tlen)
{
	size_t i;
	for (i = 0; i < tlen; i++) {
		if (table[i].id == id)
			return table[i].nid;
	}
	return -1;
}
#endif
@


1.38
log
@unidef DH, ECDH, and ECDSA. there's no purpose to a libssl without them.
ok deraadt jsing
@
text
@d2031 1
a2031 1
	if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER) {
d2299 2
a2300 2
	/* Extension ignored for TLS versions below 1.2 */
	if (TLS1_get_version(s) < TLS1_2_VERSION)
d2302 1
@


1.37
log
@Make it substantially easier to identify protocol version requirements
by adding an enc_flags field to the ssl3_enc_method, specifying four flags
that are used with this field and providing macros for evaluating these
conditions. Currently the version requirements are identified by
continually checking the version number and other criteria.

This change also adds separate SSL3_ENC_METHOD data for TLS v1.1 and v1.2,
since they have different enc_flags from TLS v1.

Based on changes in OpenSSL head.

No objection from miod@@
@
text
@a366 3
#ifdef OPENSSL_NO_ECDSA
#define tlsext_sigalg_ecdsa(md) /* */
#else
a367 1
#endif
a2219 1
#ifndef OPENSSL_NO_ECDSA
a2220 1
#endif
a2320 1
#ifndef OPENSSL_NO_ECDSA
a2323 1
#endif
a2347 1
#ifndef OPENSSL_NO_ECDSA
a2349 1
#endif
@


1.36
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@d143 38
@


1.35
log
@Replace the following logic:

        if (nothing to allocate)
                ptr = malloc(1)
        else {
                if ((ptr = malloc(size to allocate))
                        memcpy(ptr, data to copy, size to allocate)
        }

        if (ptr == NULL)
                OMG ERROR

with a saner logic where the NULL pointer check if moved to the actual
malloc branch, so that we do not need to malloc a single byte, just to avoid
having a NULL pointer.

Whoever thought allocating a single byte was a smart idea was obviously
not taking his meds.

ok beck@@ guenther@@
@
text
@d166 1
a166 3
	if (s->tlsext_session_ticket) {
		free(s->tlsext_session_ticket);
	}
d1083 1
a1083 4
				if (s->session->tlsext_ecpointformatlist) {
					free(s->session->tlsext_ecpointformatlist);
					s->session->tlsext_ecpointformatlist = NULL;
				}
d1149 2
a1150 2
			if (s->s3->client_opaque_prf_input != NULL) /* shouldn't really happen */
				free(s->s3->client_opaque_prf_input);
d1411 2
a1412 2
			if (s->session->tlsext_ecpointformatlist != NULL)
				free(s->session->tlsext_ecpointformatlist);
d1456 4
a1459 5
			if (s->s3->server_opaque_prf_input != NULL) /* shouldn't really happen */
				free(s->s3->server_opaque_prf_input);
			if (s->s3->server_opaque_prf_input_len == 0)
				s->s3->server_opaque_prf_input = NULL;
			else {
d1462 1
a1462 1
				      s->s3->server_opaque_prf_input_len);
d1597 1
a1597 2
		if (s->tlsext_ecpointformatlist != NULL)
			free(s->tlsext_ecpointformatlist);
d1609 1
a1609 2
		if (s->tlsext_ellipticcurvelist != NULL)
			free(s->tlsext_ellipticcurvelist);
d1635 1
a1635 3
			if (s->s3->client_opaque_prf_input != NULL) /* shouldn't really happen */
				free(s->s3->client_opaque_prf_input);

d1677 1
a1677 2
		if (s->tlsext_ecpointformatlist != NULL)
			free(s->tlsext_ecpointformatlist);
d1730 1
a1730 2
		if (s->s3->server_opaque_prf_input != NULL) /* shouldn't really happen */
			free(s->s3->server_opaque_prf_input);
d1913 2
a1914 4
		if (s->tlsext_ocsp_resp) {
			free(s->tlsext_ocsp_resp);
			s->tlsext_ocsp_resp = NULL;
		}
@


1.34
log
@tls_decrypt_ticket(): memory leak and uncleaned EVP_CIPHER_CTX upon error.
@
text
@d1157 9
a1165 6
				s->s3->client_opaque_prf_input = malloc(1); /* dummy byte just to get non-NULL */
			else
				s->s3->client_opaque_prf_input = BUF_memdup(sdata, s->s3->client_opaque_prf_input_len);
			if (s->s3->client_opaque_prf_input == NULL) {
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
d1464 9
a1472 7
				s->s3->server_opaque_prf_input = malloc(1); /* dummy byte just to get non-NULL */
			else
				s->s3->server_opaque_prf_input = BUF_memdup(sdata, s->s3->server_opaque_prf_input_len);

			if (s->s3->server_opaque_prf_input == NULL) {
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
d1647 10
a1656 6
				s->s3->client_opaque_prf_input = malloc(1); /* dummy byte just to get non-NULL */
			else
				s->s3->client_opaque_prf_input = BUF_memdup(s->tlsext_opaque_prf_input, s->tlsext_opaque_prf_input_len);
			if (s->s3->client_opaque_prf_input == NULL) {
				SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT, ERR_R_MALLOC_FAILURE);
				return -1;
d1752 11
a1762 7
					s->s3->server_opaque_prf_input = malloc(1); /* dummy byte just to get non-NULL */
				else
					s->s3->server_opaque_prf_input = BUF_memdup(s->tlsext_opaque_prf_input, s->tlsext_opaque_prf_input_len);
				if (s->s3->server_opaque_prf_input == NULL) {
					ret = SSL_TLSEXT_ERR_ALERT_FATAL;
					al = SSL_AD_INTERNAL_ERROR;
					goto err;
@


1.33
log
@Use C99 initialisers for SSL3_ENC_METHOD structs.

ok miod@@
@
text
@d2136 3
a2138 1
	if (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0)
d2140 1
@


1.32
log
@Enable three brainpool elliptic curves for TLS, as specified in RFC 7027;
from OpenSSL HEAD.

ok beck@@ deraadt@@ jsing@@
@
text
@d129 14
a142 12
	tls1_enc,
	tls1_mac,
	tls1_setup_key_block,
	tls1_generate_master_secret,
	tls1_change_cipher_state,
	tls1_final_finish_mac,
	TLS1_FINISH_MAC_LENGTH,
	tls1_cert_verify_mac,
	TLS_MD_CLIENT_FINISH_CONST, TLS_MD_CLIENT_FINISH_CONST_SIZE,
	TLS_MD_SERVER_FINISH_CONST, TLS_MD_SERVER_FINISH_CONST_SIZE,
	tls1_alert_code,
	tls1_export_keying_material,
@


1.31
log
@Use sizeof(cryptopro_ext) instead of 36 when applicable.
ok jsing@@
@
text
@d205 4
a208 1
	NID_secp521r1		/* secp521r1 (25) */
d215 1
d218 1
d222 1
d307 6
@


1.30
log
@More KNF.
@
text
@d794 1
a794 1
		const unsigned char cryptopro_ext[36] = {
d802 1
a802 1
		if ((size_t)(limit - ret) < 36)
d804 2
a805 2
		memcpy(ret, cryptopro_ext, 36);
		ret += 36;
@


1.29
log
@Fix several bounds checks in ssl_add_clienthello_tlsext() and
ssl_add_serverhello_tlsext(), and convert all of them to the same idiom, for
easier review.

Math is hard, let's go webshopping.

Help and ok guenther@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d120 1
a120 1
const char tls1_version_str[]="TLSv1" OPENSSL_VERSION_PTEXT;
d123 1
a123 2
static int
tls_decrypt_ticket(SSL *s, const unsigned char *tick, int ticklen,
d148 1
a148 1
	return (60*60*2);
d181 25
a205 25
	NID_sect163k1, /* sect163k1 (1) */
	NID_sect163r1, /* sect163r1 (2) */
	NID_sect163r2, /* sect163r2 (3) */
	NID_sect193r1, /* sect193r1 (4) */
	NID_sect193r2, /* sect193r2 (5) */
	NID_sect233k1, /* sect233k1 (6) */
	NID_sect233r1, /* sect233r1 (7) */
	NID_sect239k1, /* sect239k1 (8) */
	NID_sect283k1, /* sect283k1 (9) */
	NID_sect283r1, /* sect283r1 (10) */
	NID_sect409k1, /* sect409k1 (11) */
	NID_sect409r1, /* sect409r1 (12) */
	NID_sect571k1, /* sect571k1 (13) */
	NID_sect571r1, /* sect571r1 (14) */
	NID_secp160k1, /* secp160k1 (15) */
	NID_secp160r1, /* secp160r1 (16) */
	NID_secp160r2, /* secp160r2 (17) */
	NID_secp192k1, /* secp192k1 (18) */
	NID_X9_62_prime192v1, /* secp192r1 (19) */
	NID_secp224k1, /* secp224k1 (20) */
	NID_secp224r1, /* secp224r1 (21) */
	NID_secp256k1, /* secp256k1 (22) */
	NID_X9_62_prime256v1, /* secp256r1 (23) */
	NID_secp384r1, /* secp384r1 (24) */
	NID_secp521r1  /* secp521r1 (25) */
d209 25
a233 25
	NID_sect571r1, /* sect571r1 (14) */
	NID_sect571k1, /* sect571k1 (13) */
	NID_secp521r1, /* secp521r1 (25) */
	NID_sect409k1, /* sect409k1 (11) */
	NID_sect409r1, /* sect409r1 (12) */
	NID_secp384r1, /* secp384r1 (24) */
	NID_sect283k1, /* sect283k1 (9) */
	NID_sect283r1, /* sect283r1 (10) */
	NID_secp256k1, /* secp256k1 (22) */
	NID_X9_62_prime256v1, /* secp256r1 (23) */
	NID_sect239k1, /* sect239k1 (8) */
	NID_sect233k1, /* sect233k1 (6) */
	NID_sect233r1, /* sect233r1 (7) */
	NID_secp224k1, /* secp224k1 (20) */
	NID_secp224r1, /* secp224r1 (21) */
	NID_sect193r1, /* sect193r1 (4) */
	NID_sect193r2, /* sect193r2 (5) */
	NID_secp192k1, /* secp192k1 (18) */
	NID_X9_62_prime192v1, /* secp192r1 (19) */
	NID_sect163k1, /* sect163k1 (1) */
	NID_sect163r1, /* sect163r1 (2) */
	NID_sect163r2, /* sect163r2 (3) */
	NID_secp160k1, /* secp160k1 (15) */
	NID_secp160r1, /* secp160r1 (16) */
	NID_secp160r2, /* secp160r2 (17) */
d240 2
a241 2
	if ((curve_id < 1) || ((unsigned int)curve_id >
	    sizeof(nid_list)/sizeof(nid_list[0])))
d299 1
a299 1
	case NID_secp521r1:  /* secp521r1 (25) */
d324 3
a326 3
		tlsext_sigalg_rsa(md) \
		tlsext_sigalg_dsa(md) \
		tlsext_sigalg_ecdsa(md)
d340 1
d359 1
a359 1
	if (ret>=limit)
a365 1

d371 1
a371 1
		   + hostname length 
d401 2
a402 1
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
d413 2
a414 1
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
d435 2
a436 1
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
d443 2
a444 1
		memcpy(ret, s->tlsext_ecpointformatlist, s->tlsext_ecpointformatlist_length);
d459 2
a460 1
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
d473 2
a474 1
		memcpy(ret, s->tlsext_ellipticcurvelist, s->tlsext_ellipticcurvelist_length);
d611 2
a612 1
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
d669 1
a669 1
	if (ret>=limit)
d672 2
a673 1
	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL) {
d685 2
a686 1
			SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
d697 2
a698 1
			SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
d707 1
a707 1
		s->version != DTLS1_VERSION) {
d718 2
a719 1
			SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
d726 2
a727 1
		memcpy(ret, s->tlsext_ecpointformatlist, s->tlsext_ecpointformatlist_length);
d734 2
a735 1
	if (s->tlsext_ticket_expected && !(SSL_get_options(s) & SSL_OP_NO_TICKET)) {
d752 2
a753 1
	if (s->s3->server_opaque_prf_input != NULL && s->version != DTLS1_VERSION) {
d783 2
a784 1
			SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
d798 1
a798 1
			0x03,   0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,
d816 2
a817 1
		r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen, s->ctx->next_protos_advertised_cb_arg);
d851 3
a853 1
ssl_check_for_safari(SSL *s, const unsigned char *data, const unsigned char *d, int n) {
d960 1
a960 1
		s->tlsext_debug_arg);
d968 3
a970 3
     to allow the application to position itself to the right context. 
   - The servername is acknowledged if it is new for a session or when 
     it is identical to a previously used for the same session. 
d976 1
a976 1
     the value of the Host: field. 
d979 2
a980 2
     i.e. when the session has been established with a servername extension. 
   - On session reconnect, the servername extension may be absent. 
d982 1
a982 1
*/      
d1015 29
a1043 21
					if (!s->hit) {
						if (s->session->tlsext_hostname) {
							*al = SSL_AD_DECODE_ERROR;
							return 0;
						}
						if (len > TLSEXT_MAXLEN_host_name) {
							*al = TLS1_AD_UNRECOGNIZED_NAME;
							return 0;
						}
						if ((s->session->tlsext_hostname =
						    malloc(len + 1)) == NULL) {
							*al = TLS1_AD_INTERNAL_ERROR;
							return 0;
						}
						memcpy(s->session->tlsext_hostname, sdata, len);
						s->session->tlsext_hostname[len] = '\0';
						if (strlen(s->session->tlsext_hostname) != len) {
							free(s->session->tlsext_hostname);
							s->session->tlsext_hostname = NULL;
							*al = TLS1_AD_UNRECOGNIZED_NAME;
							return 0;
d1045 1
a1045 1
						s->servername_done = 1;
d1047 2
a1048 5

					} else {
						s->servername_done = s->session->tlsext_hostname &&
						    strlen(s->session->tlsext_hostname) == len &&
						    strncmp(s->session->tlsext_hostname, (char *)sdata, len) == 0;
a1049 5
					break;

					default:
					break;
				}
d1062 1
a1062 1
			s->version != DTLS1_VERSION) {
d1098 1
a1098 1
				ellipticcurvelist_length < 1) {
d1127 1
a1127 1
			s->version != DTLS1_VERSION) {
d1154 1
a1154 1
				!s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg)) {
d1216 1
a1216 1
					&sdata, idsize);
d1226 3
a1228 3
					if (!s->tlsext_ocsp_ids
						&& !(s->tlsext_ocsp_ids =
					sk_OCSP_RESPID_new_null())) {
d1234 1
a1234 1
						s->tlsext_ocsp_ids, id)) {
d1256 1
a1256 1
						X509_EXTENSION_free);
d1260 4
a1263 4
					d2i_X509_EXTENSIONS(NULL,
					&sdata, dsize);
					if (!s->tlsext_ocsp_exts
						|| (data + dsize != sdata)) {
d1310 1
a1310 1
	ri_check:
d1317 1
a1317 1
		SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
d1345 2
a1346 1
ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)
d1377 1
a1377 1
		s->tlsext_debug_arg);
d1389 1
a1389 1
			s->version != DTLS1_VERSION) {
d1394 1
a1394 1
				ecpointformatlist_length < 1) {
d1461 1
a1461 1
			 */ 
d1506 3
a1508 3
			if (ssl_parse_serverhello_use_srtp_ext(s, data, size,
				al))
			return 0;
d1551 1
a1551 1
		SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
d1562 1
a1562 1
	/* If we are client and using an elliptic curve cryptography cipher suite, send the point formats 
d1587 2
a1588 1
			SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT, ERR_R_MALLOC_FAILURE);
d1599 1
a1599 1
		s->tlsext_ellipticcurvelist_length = sizeof(pref_list)/sizeof(pref_list[0]) * 2;
d1602 2
a1603 1
			SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT, ERR_R_MALLOC_FAILURE);
d1606 1
a1606 3
		for (i = 0, j = s->tlsext_ellipticcurvelist;
		    (unsigned int)i < sizeof(pref_list)/sizeof(pref_list[0]);
		    i++) {
d1641 1
a1641 1
				s->tlsext_opaque_prf_input_len;
d1653 1
a1653 1
	/* If we are server and using an ECC cipher suite, send the point formats we support 
d1687 1
a1687 1
	/* The handling of the ECPointFormats extension is done elsewhere, namely in 
d1690 1
a1690 1
	/* The handling of the EllipticCurves extension is done elsewhere, namely in 
a1755 1

a1756 1

a1759 2


d1774 1
a1774 1
 	 * Note: this must be called after servername callbacks in case 
d1778 2
a1779 1
	if ((s->tlsext_status_type != -1) && s->ctx && s->ctx->tlsext_status_cb) {
a1817 1

a1821 1

d1882 1
a1882 1
			s->s3->client_opaque_prf_input_len != s->s3->server_opaque_prf_input_len) {
d1892 2
a1893 2
	if ((s->tlsext_status_type != -1) && !(s->tlsext_status_expected)
		&& s->ctx && s->ctx->tlsext_status_cb) {
d2093 1
a2093 1
		tlsext_tick_md(), NULL);
d2095 1
a2095 1
		tctx->tlsext_tick_aes_key, etick + 16);
d2205 1
a2205 1
	sizeof(tls12_md)/sizeof(tls12_lookup));
d2220 1
a2220 1
	sizeof(tls12_sig)/sizeof(tls12_lookup));
a2230 1

a2234 1

a2238 1

@


1.28
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@d364 1
a364 2
		unsigned long size_str;
		long lenmax;
d368 1
a368 1
		   4 for the servername type and entension length
d375 5
a379 2
		if ((lenmax = limit - ret - 9) < 0 ||
		    (size_str = strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
d406 1
a406 1
		if ((limit - p - 4 - el) < 0)
d425 1
a425 1
		long lenmax;
d427 1
a427 1
		if ((lenmax = limit - ret - 5) < 0)
d430 2
a431 1
		if (s->tlsext_ecpointformatlist_length > (unsigned long)lenmax)
d447 1
a447 1
		long lenmax;
d449 2
a450 2
		if ((lenmax = limit - ret - 6)
			< 0) return NULL;
d452 4
a455 2
		if (s->tlsext_ellipticcurvelist_length > (unsigned long)lenmax) return NULL;
			if (s->tlsext_ellipticcurvelist_length > 65532) {
d495 1
a495 1
		if ((long)(limit - ret - 4 - ticklen) < 0)
d520 1
a520 1
		s->version != DTLS1_VERSION) {
d523 1
a523 1
		if ((long)(limit - ret - 6 - col < 0))
d559 1
a559 1
		if ((long)(limit - ret - 7 - extlen - idlen) < 0)
d586 1
a586 1
		if (limit - ret - 4 < 0)
d599 1
a599 1
		if ((limit - p - 4 - el) < 0)
d667 1
a667 1
		if ((long)(limit - ret - 4) < 0)
d682 2
a683 2
		if ((limit - p - 4 - el)
			< 0) return NULL;
d700 1
a700 1
		long lenmax;
d702 2
d705 2
a706 4
		if ((lenmax = limit - ret - 5)
			< 0) return NULL;

		if (s->tlsext_ecpointformatlist_length > (unsigned long)lenmax)
d724 1
a724 1
		if ((long)(limit - ret - 4) < 0)
d732 1
a732 1
		if ((long)(limit - ret - 4) < 0)
d743 1
a743 1
		if ((long)(limit - ret - 6 - sol) < 0)
d763 1
a763 1
		if ((limit - p - 4 - el) < 0)
d788 1
a788 1
		if (limit - ret < 36)
d804 1
a804 1
			if ((long)(limit - ret - 4 - npalen) < 0)
@


1.27
log
@Appease gcc3 -Wuninitialized.
@
text
@a417 29
#ifndef OPENSSL_NO_SRP
	/* Add SRP username if there is one */
	if (s->srp_ctx.login != NULL) {
		/* Add TLS extension SRP username to the Client Hello message */

		int login_len = strlen(s->srp_ctx.login);

		if (login_len > 255 || login_len == 0) {
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
			return NULL;
		}

		/* check for enough space.
		   4 for the srp type type and entension length
		   1 for the srp user identity
		   + srp user identity length 
		*/
		if ((limit - ret - 5 - login_len) < 0)
			return NULL;


		/* fill in the extension */
		s2n(TLSEXT_TYPE_srp, ret);
		s2n(login_len + 1, ret);
		(*ret++) = (unsigned char) login_len;
		memcpy(ret, s->srp_ctx.login, login_len);
		ret += login_len;
	}
#endif
a1036 21
#ifndef OPENSSL_NO_SRP
		else if (type == TLSEXT_TYPE_srp) {
			if (size <= 0 || ((len = data[0])) != (size - 1)) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
			if (s->srp_ctx.login != NULL) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
			if ((s->srp_ctx.login = malloc(len + 1)) == NULL)
				return -1;
			memcpy(s->srp_ctx.login, &data[1], len);
			s->srp_ctx.login[len] = '\0';

			if (strlen(s->srp_ctx.login) != len) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
		}
#endif
@


1.26
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@d1802 1
a1802 1
	int al;
@


1.25
log
@More KNF and style consistency tweaks
@
text
@d509 1
a509 2
			s->tlsext_session_ticket->data,
			ticklen);
d1031 2
a1032 1
						if ((s->session->tlsext_hostname = malloc(len + 1)) == NULL) {
d1104 2
a1105 1
				if ((s->session->tlsext_ecpointformatlist = malloc(ecpointformatlist_length)) == NULL) {
d1136 2
a1137 1
				if ((s->session->tlsext_ellipticcurvelist = malloc(ellipticcurvelist_length)) == NULL) {
d1428 2
a1429 1
			if ((s->session->tlsext_ecpointformatlist = malloc(ecpointformatlist_length)) == NULL) {
@


1.24
log
@now that knf carpet bombing is finished, switch to hand to hand combat.
still not sure what to make of mysteries like this:
	for (i = 7; i >= 0; i--) {      /* increment */
@
text
@d346 2
a347 2
unsigned char
*ssl_add_clienthello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
d674 2
a675 2
unsigned char
*ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
d2252 2
a2253 2
const EVP_MD
*tls12_get_hash(unsigned char hash_alg)
@


1.23
log
@always build in RSA and DSA. ok deraadt miod
@
text
@d155 3
a157 2
	if (!ssl3_new(s)) return (0);
		s->method->ssl_clear(s);
d353 3
a355 3
	if (s->client_version == SSL3_VERSION
		&& !s->s3->send_connection_binding)
	return p;
d359 2
a360 1
	if (ret>=limit) return NULL; /* this really never occurs, but ... */
d376 3
a378 3
		if ((lenmax = limit - ret - 9) < 0
			|| (size_str = strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
		return NULL;
d404 2
a405 2
		if ((limit - p - 4 - el)
			< 0) return NULL;
d420 2
a421 2
	if (s->srp_ctx.login != NULL)
			{ /* Add TLS extension SRP username to the Client Hello message */
d435 2
a436 2
		if ((limit - ret - 5 - login_len)
			< 0) return NULL;
d450 1
a450 1
		s->version != DTLS1_VERSION) {
d454 2
d457 3
a459 5
		if ((lenmax = limit - ret - 5)
			< 0) return NULL;

		if (s->tlsext_ecpointformatlist_length > (unsigned long)lenmax) return NULL;
			if (s->tlsext_ecpointformatlist_length > 255) {
d471 1
a471 1
		s->version != DTLS1_VERSION) {
a474 1

d503 1
a503 1
			s->tlsext_session_ticket->data) {
d515 2
a516 2
			s->tlsext_session_ticket->data == NULL)
		goto skip_ext;
d520 3
a522 2
		if ((long)(limit - ret - 4 - ticklen) < 0) return NULL;
			s2n(TLSEXT_TYPE_session_ticket, ret);
d530 1
a530 1
	skip_ext:
d563 1
a563 1
		s->version != DTLS1_VERSION) {
d584 3
a586 2
		if ((long)(limit - ret - 7 - extlen - idlen) < 0) return NULL;
			s2n(TLSEXT_TYPE_status_request, ret);
d624 2
a625 2
		if ((limit - p - 4 - el)
			< 0) return NULL;
d688 2
a689 1
	if (ret>=limit) return NULL; /* this really never occurs, but ... */
d692 2
a693 2
		if ((long)(limit - ret - 4) < 0) return NULL;

d731 3
a733 2
		if (s->tlsext_ecpointformatlist_length > (unsigned long)lenmax) return NULL;
			if (s->tlsext_ecpointformatlist_length > 255) {
d748 3
a750 3
	if (s->tlsext_ticket_expected
		&& !(SSL_get_options(s) & SSL_OP_NO_TICKET)) {
		if ((long)(limit - ret - 4) < 0) return NULL;
d757 2
a758 1
		if ((long)(limit - ret - 4) < 0) return NULL;
d765 1
a765 2
	if (s->s3->server_opaque_prf_input != NULL &&
		s->version != DTLS1_VERSION) {
d802 3
a804 2
	if (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80 || (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81)
	    && (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) {
d829 3
a831 2
			if ((long)(limit - ret - 4 - npalen) < 0) return NULL;
				s2n(TLSEXT_TYPE_next_proto_neg, ret);
a996 1

d1022 1
a1022 1
				case TLSEXT_NAMETYPE_host_name:
d1047 5
a1051 5
					} else
						s->servername_done = s->session->tlsext_hostname
					&& strlen(s->session->tlsext_hostname) == len
					&& strncmp(s->session->tlsext_hostname, (char *)sdata, len) == 0;

d1054 1
a1054 1
				default:
d1294 1
a1294 1
			}
a1297 1
			else
d1299 1
d1326 2
a1327 3
			if (ssl_parse_clienthello_use_srtp_ext(s, data, size,
				al))
			return 0;
a1411 1

a1440 1

d1443 1
a1443 1
				!s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg)) {
d1447 1
a1447 2
			if ((SSL_get_options(s) & SSL_OP_NO_TICKET)
				|| (size > 0)) {
d1455 1
a1455 1
			s->version != DTLS1_VERSION) {
d1482 1
a1482 1
			s->version != DTLS1_VERSION) {
d1495 1
a1495 1
			s->s3->tmp.finish_md_len == 0) {
d1563 1
a1563 1
	ri_check:
d1572 1
a1572 2
	if (!renegotiate_seen
	    && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)) {
a1581 1

d1600 2
a1601 1
		if ((alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe) || (alg_a & SSL_aECDSA))) {
d1629 2
a1630 3
			(unsigned int)i <
		sizeof(pref_list)/sizeof(pref_list[0]);
		i++) {
d1662 1
a1662 1
		if (r == 2)
d1664 3
a1666 1
		s->s3->server_opaque_prf_input_len = s->tlsext_opaque_prf_input_len;
d1748 1
a1748 1
				s->s3->client_opaque_prf_input_len == s->tlsext_opaque_prf_input_len) {
d1775 1
a1775 1
	err:
a1846 1

a1850 1

d1869 5
a1873 3
	if ((s->tlsext_ecpointformatlist != NULL) && (s->tlsext_ecpointformatlist_length > 0) &&
		(s->session->tlsext_ecpointformatlist != NULL) && (s->session->tlsext_ecpointformatlist_length > 0) &&
	((alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) || (alg_a & SSL_aECDSA))) {
a1947 1

d1950 1
a1951 2


d2282 1
a2323 1

@


1.22
log
@SHA and AES (and sadly MD5) can't be considered optional. ok beck miod
@
text
@a312 3
#ifdef OPENSSL_NO_RSA
#define tlsext_sigalg_rsa(md) /* */
#else
a313 1
#endif
a314 3
#ifdef OPENSSL_NO_DSA
#define tlsext_sigalg_dsa(md) /* */
#else
a315 1
#endif
a2196 1
#ifndef OPENSSL_NO_RSA
a2197 2
#endif
#ifndef OPENSSL_NO_DSA
a2198 1
#endif
a2297 1
#ifndef OPENSSL_NO_RSA
a2300 2
#endif
#ifndef OPENSSL_NO_DSA
a2303 1
#endif
a2327 1
#ifndef OPENSSL_NO_DSA
a2329 2
#endif
#ifndef OPENSSL_NO_RSA
a2333 1
#endif
@


1.21
log
@quick pass at removing ability to disable sha256 and sha512. ok miod
@
text
@a340 1
#ifndef OPENSSL_NO_SHA
a341 1
#endif
a2195 1
#ifndef OPENSSL_NO_MD5
a2196 2
#endif
#ifndef OPENSSL_NO_SHA
a2197 1
#endif
a2267 1
#ifndef OPENSSL_NO_SHA
a2269 1
#endif
@


1.20
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a336 1
#ifndef OPENSSL_NO_SHA512
a338 2
#endif
#ifndef OPENSSL_NO_SHA256
a340 1
#endif
a2203 1
#ifndef OPENSSL_NO_SHA256
a2205 2
#endif
#ifndef OPENSSL_NO_SHA512
a2207 1
#endif
a2277 1
#ifndef OPENSSL_NO_SHA256
a2282 2
#endif
#ifndef OPENSSL_NO_SHA512
a2287 1
#endif
@


1.19
log
@add back SRP. i was being too greedy.
@
text
@d165 1
a165 1
		OPENSSL_free(s->tlsext_session_ticket);
d518 1
a518 1
			s->session->tlsext_tick = OPENSSL_malloc(ticklen);
d1040 1
a1040 1
						if ((s->session->tlsext_hostname = OPENSSL_malloc(len + 1)) == NULL) {
d1047 1
a1047 1
							OPENSSL_free(s->session->tlsext_hostname);
d1084 1
a1084 1
			if ((s->srp_ctx.login = OPENSSL_malloc(len + 1)) == NULL)
d1108 1
a1108 1
					OPENSSL_free(s->session->tlsext_ecpointformatlist);
d1112 1
a1112 1
				if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
d1143 1
a1143 1
				if ((s->session->tlsext_ellipticcurvelist = OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
d1175 1
a1175 1
				OPENSSL_free(s->s3->client_opaque_prf_input);
d1177 1
a1177 1
				s->s3->client_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */
d1435 2
a1436 2
				OPENSSL_free(s->session->tlsext_ecpointformatlist);
			if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
d1481 1
a1481 1
				OPENSSL_free(s->s3->server_opaque_prf_input);
d1483 1
a1483 1
				s->s3->server_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */
d1525 1
a1525 1
			s->next_proto_negotiated = OPENSSL_malloc(selected_len);
d1622 2
a1623 2
			OPENSSL_free(s->tlsext_ecpointformatlist);
		if ((s->tlsext_ecpointformatlist = OPENSSL_malloc(3)) == NULL) {
d1634 1
a1634 1
			OPENSSL_free(s->tlsext_ellipticcurvelist);
d1636 1
a1636 1
		if ((s->tlsext_ellipticcurvelist = OPENSSL_malloc(s->tlsext_ellipticcurvelist_length)) == NULL) {
d1663 1
a1663 1
				OPENSSL_free(s->s3->client_opaque_prf_input);
d1666 1
a1666 1
				s->s3->client_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */
d1701 2
a1702 2
			OPENSSL_free(s->tlsext_ecpointformatlist);
		if ((s->tlsext_ecpointformatlist = OPENSSL_malloc(3)) == NULL) {
d1755 1
a1755 1
			OPENSSL_free(s->s3->server_opaque_prf_input);
d1765 1
a1765 1
					s->s3->server_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */
d1940 1
a1940 1
			OPENSSL_free(s->tlsext_ocsp_resp);
d2159 1
a2159 1
	sdec = OPENSSL_malloc(eticklen);
d2172 1
a2172 1
	OPENSSL_free(sdec);
@


1.18
log
@Thanks to the knobs in http://tools.ietf.org/html/rfc5746, we have a knob
to say "allow this connection to negotiate insecurely". de-fang the code
that respects this option to ignore it.
ok miod@@
@
text
@d430 29
d1074 21
@


1.17
log
@disentangle SRP code from TLS
@
text
@d1299 1
a1299 2
	if (!renegotiate_seen && s->renegotiate &&
		!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
d1535 1
a1535 2
		&& !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)
	&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
@


1.16
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@a429 29
#ifndef OPENSSL_NO_SRP
	/* Add SRP username if there is one */
	if (s->srp_ctx.login != NULL)
			{ /* Add TLS extension SRP username to the Client Hello message */

		int login_len = strlen(s->srp_ctx.login);

		if (login_len > 255 || login_len == 0) {
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
			return NULL;
		}

		/* check for enough space.
		   4 for the srp type type and entension length
		   1 for the srp user identity
		   + srp user identity length 
		*/
		if ((limit - ret - 5 - login_len)
			< 0) return NULL;


		/* fill in the extension */
		s2n(TLSEXT_TYPE_srp, ret);
		s2n(login_len + 1, ret);
		(*ret++) = (unsigned char) login_len;
		memcpy(ret, s->srp_ctx.login, login_len);
		ret += login_len;
	}
#endif
a1044 21
#ifndef OPENSSL_NO_SRP
		else if (type == TLSEXT_TYPE_srp) {
			if (size <= 0 || ((len = data[0])) != (size - 1)) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
			if (s->srp_ctx.login != NULL) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
			if ((s->srp_ctx.login = OPENSSL_malloc(len + 1)) == NULL)
				return -1;
			memcpy(s->srp_ctx.login, &data[1], len);
			s->srp_ctx.login[len] = '\0';

			if (strlen(s->srp_ctx.login) != len) {
				*al = SSL_AD_DECODE_ERROR;
				return 0;
			}
		}
#endif
@


1.15
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a617 14
#ifndef OPENSSL_NO_HEARTBEATS
	/* Add Heartbeat extension */
	s2n(TLSEXT_TYPE_heartbeat, ret);
	s2n(1, ret);
	/* Set mode:
	 * 1: peer may send requests
	 * 2: peer not allowed to send requests
	 */
	if (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)
		*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
	else
		*(ret++) = SSL_TLSEXT_HB_ENABLED;
#endif

a826 17
#ifndef OPENSSL_NO_HEARTBEATS
	/* Add Heartbeat extension if we've received one */
	if (s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED) {
		s2n(TLSEXT_TYPE_heartbeat, ret);
		s2n(1, ret);
		/* Set mode:
		 * 1: peer may send requests
		 * 2: peer not allowed to send requests
		 */
		if (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)
			*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
		else
			*(ret++) = SSL_TLSEXT_HB_ENABLED;

	}
#endif

a951 5
#ifndef OPENSSL_NO_HEARTBEATS
	s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |
	SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
#endif

a1308 16
#ifndef OPENSSL_NO_HEARTBEATS
		else if (type == TLSEXT_TYPE_heartbeat) {
			switch (data[0]) {
			case 0x01:	/* Client allows us to send HB requests */
				s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
				break;
			case 0x02:	/* Client doesn't accept HB requests */
				s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
				s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
				break;
			default:
				*al = SSL_AD_ILLEGAL_PARAMETER;
				return 0;
			}
		}
#endif
a1393 5
#ifndef OPENSSL_NO_HEARTBEATS
	s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |
	SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
#endif

a1540 16
#ifndef OPENSSL_NO_HEARTBEATS
		else if (type == TLSEXT_TYPE_heartbeat) {
			switch (data[0]) {
			case 0x01:	/* Server allows us to send HB requests */
				s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
				break;
			case 0x02:	/* Server doesn't accept HB requests */
				s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
				s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
				break;
			default:
				*al = SSL_AD_ILLEGAL_PARAMETER;
				return 0;
			}
		}
#endif
a2382 141
#endif

#ifndef OPENSSL_NO_HEARTBEATS
int
tls1_process_heartbeat(SSL *s)
{
	unsigned char *p = &s->s3->rrec.data[0], *pl;
	unsigned short hbtype;
	unsigned int payload;
	unsigned int padding = 16; /* Use minimum padding */

	if (s->msg_callback)
		s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
	&s->s3->rrec.data[0], s->s3->rrec.length,
	s, s->msg_callback_arg);

	/* Read type and payload length first */
	if (1 + 2 + 16 > s->s3->rrec.length)
		return 0; /* silently discard */
	hbtype = *p++;
	n2s(p, payload);
	if (1 + 2 + payload + 16 > s->s3->rrec.length)
		return 0; /* silently discard per RFC 6520 sec. 4 */
	pl = p;

	if (hbtype == TLS1_HB_REQUEST) {
		unsigned char *buffer, *bp;
		int r;

		/* Allocate memory for the response, size is 1 bytes
		 * message type, plus 2 bytes payload length, plus
		 * payload, plus padding
		 */
		buffer = OPENSSL_malloc(1 + 2 + payload + padding);
		bp = buffer;

		/* Enter response type, length and copy payload */
		*bp++ = TLS1_HB_RESPONSE;
		s2n(payload, bp);
		memcpy(bp, pl, payload);
		bp += payload;
		/* Random padding */
		RAND_pseudo_bytes(bp, padding);

		r = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);

		if (r >= 0 && s->msg_callback)
			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
		buffer, 3 + payload + padding,
		s, s->msg_callback_arg);

		OPENSSL_free(buffer);

		if (r < 0)
			return r;
	} else if (hbtype == TLS1_HB_RESPONSE) {
		unsigned int seq;

		/* We only send sequence numbers (2 bytes unsigned int),
		 * and 16 random bytes, so we just try to read the
		 * sequence number */
		n2s(pl, seq);

		if (payload == 18 && seq == s->tlsext_hb_seq) {
			s->tlsext_hb_seq++;
			s->tlsext_hb_pending = 0;
		}
	}

	return 0;
}

int
tls1_heartbeat(SSL *s)
{
	unsigned char *buf, *p;
	int ret;
	unsigned int payload = 18; /* Sequence number + random bytes */
	unsigned int padding = 16; /* Use minimum padding */

	/* Only send if peer supports and accepts HB requests... */
	if (!(s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED) ||
		s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_SEND_REQUESTS) {
		SSLerr(SSL_F_TLS1_HEARTBEAT, SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT);
		return -1;
	}

	/* ...and there is none in flight yet... */
	if (s->tlsext_hb_pending) {
		SSLerr(SSL_F_TLS1_HEARTBEAT, SSL_R_TLS_HEARTBEAT_PENDING);
		return -1;
	}

	/* ...and no handshake in progress. */
	if (SSL_in_init(s) || s->in_handshake) {
		SSLerr(SSL_F_TLS1_HEARTBEAT, SSL_R_UNEXPECTED_MESSAGE);
		return -1;
	}

	/* Check if padding is too long, payload and padding
	 * must not exceed 2^14 - 3 = 16381 bytes in total.
	 */
	OPENSSL_assert(payload + padding <= 16381);

	/* Create HeartBeat message, we just use a sequence number
	 * as payload to distuingish different messages and add
	 * some random stuff.
	 *  - Message Type, 1 byte
	 *  - Payload Length, 2 bytes (unsigned int)
	 *  - Payload, the sequence number (2 bytes uint)
	 *  - Payload, random bytes (16 bytes uint)
	 *  - Padding
	 */
	buf = OPENSSL_malloc(1 + 2 + payload + padding);
	p = buf;
	/* Message Type */
	*p++ = TLS1_HB_REQUEST;
	/* Payload length (18 bytes here) */
	s2n(payload, p);
	/* Sequence number */
	s2n(s->tlsext_hb_seq, p);
	/* 16 random bytes */
	RAND_pseudo_bytes(p, 16);
	p += 16;
	/* Random padding */
	RAND_pseudo_bytes(p, padding);

	ret = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buf, 3 + payload + padding);
	if (ret >= 0) {
		if (s->msg_callback)
			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
		buf, 3 + payload + padding,
		s, s->msg_callback_arg);

		s->tlsext_hb_pending = 1;
	}

	OPENSSL_free(buf);

	return ret;
}
@


1.14
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d123 4
a126 3
static int tls_decrypt_ticket(SSL *s, const unsigned char *tick, int ticklen,
				const unsigned char *sess_id, int sesslen,
				SSL_SESSION **psess);
d129 1
a129 1
SSL3_ENC_METHOD TLSv1_enc_data={
d138 2
a139 2
	TLS_MD_CLIENT_FINISH_CONST,TLS_MD_CLIENT_FINISH_CONST_SIZE,
	TLS_MD_SERVER_FINISH_CONST,TLS_MD_SERVER_FINISH_CONST_SIZE,
d142 1
a142 1
	};
d144 3
a146 2
long tls1_default_timeout(void)
	{
d149 2
a150 2
	return(60*60*2);
	}
d152 7
a158 6
int tls1_new(SSL *s)
	{
	if (!ssl3_new(s)) return(0);
	s->method->ssl_clear(s);
	return(1);
	}
d160 3
a162 2
void tls1_free(SSL *s)
	{
d164 1
a164 2
	if (s->tlsext_session_ticket)
		{
d166 1
a166 1
		}
d169 1
a169 1
	}
d171 3
a173 2
void tls1_clear(SSL *s)
	{
d176 1
a176 1
	}
d180 27
a206 28
static int nid_list[] =
	{
		NID_sect163k1, /* sect163k1 (1) */
		NID_sect163r1, /* sect163r1 (2) */
		NID_sect163r2, /* sect163r2 (3) */
		NID_sect193r1, /* sect193r1 (4) */ 
		NID_sect193r2, /* sect193r2 (5) */ 
		NID_sect233k1, /* sect233k1 (6) */
		NID_sect233r1, /* sect233r1 (7) */ 
		NID_sect239k1, /* sect239k1 (8) */ 
		NID_sect283k1, /* sect283k1 (9) */
		NID_sect283r1, /* sect283r1 (10) */ 
		NID_sect409k1, /* sect409k1 (11) */ 
		NID_sect409r1, /* sect409r1 (12) */
		NID_sect571k1, /* sect571k1 (13) */ 
		NID_sect571r1, /* sect571r1 (14) */ 
		NID_secp160k1, /* secp160k1 (15) */
		NID_secp160r1, /* secp160r1 (16) */ 
		NID_secp160r2, /* secp160r2 (17) */ 
		NID_secp192k1, /* secp192k1 (18) */
		NID_X9_62_prime192v1, /* secp192r1 (19) */ 
		NID_secp224k1, /* secp224k1 (20) */ 
		NID_secp224r1, /* secp224r1 (21) */
		NID_secp256k1, /* secp256k1 (22) */ 
		NID_X9_62_prime256v1, /* secp256r1 (23) */ 
		NID_secp384r1, /* secp384r1 (24) */
		NID_secp521r1  /* secp521r1 (25) */	
	};
d208 27
a234 28
static int pref_list[] =
	{
		NID_sect571r1, /* sect571r1 (14) */ 
		NID_sect571k1, /* sect571k1 (13) */ 
		NID_secp521r1, /* secp521r1 (25) */	
		NID_sect409k1, /* sect409k1 (11) */ 
		NID_sect409r1, /* sect409r1 (12) */
		NID_secp384r1, /* secp384r1 (24) */
		NID_sect283k1, /* sect283k1 (9) */
		NID_sect283r1, /* sect283r1 (10) */ 
		NID_secp256k1, /* secp256k1 (22) */ 
		NID_X9_62_prime256v1, /* secp256r1 (23) */ 
		NID_sect239k1, /* sect239k1 (8) */ 
		NID_sect233k1, /* sect233k1 (6) */
		NID_sect233r1, /* sect233r1 (7) */ 
		NID_secp224k1, /* secp224k1 (20) */ 
		NID_secp224r1, /* secp224r1 (21) */
		NID_sect193r1, /* sect193r1 (4) */ 
		NID_sect193r2, /* sect193r2 (5) */ 
		NID_secp192k1, /* secp192k1 (18) */
		NID_X9_62_prime192v1, /* secp192r1 (19) */ 
		NID_sect163k1, /* sect163k1 (1) */
		NID_sect163r1, /* sect163r1 (2) */
		NID_sect163r2, /* sect163r2 (3) */
		NID_secp160k1, /* secp160k1 (15) */
		NID_secp160r1, /* secp160r1 (16) */ 
		NID_secp160r2, /* secp160r2 (17) */ 
	};
d236 3
a238 2
int tls1_ec_curve_id2nid(int curve_id)
	{
d241 1
a241 1
				sizeof(nid_list)/sizeof(nid_list[0])))
d243 2
a244 2
	return nid_list[curve_id-1];
	}
d246 3
a248 2
int tls1_ec_nid2curve_id(int nid)
	{
d250 1
a250 2
	switch (nid)
		{
d257 1
a257 1
	case NID_sect193r1: /* sect193r1 (4) */ 
d259 1
a259 1
	case NID_sect193r2: /* sect193r2 (5) */ 
d263 1
a263 1
	case NID_sect233r1: /* sect233r1 (7) */ 
d265 1
a265 1
	case NID_sect239k1: /* sect239k1 (8) */ 
d269 1
a269 1
	case NID_sect283r1: /* sect283r1 (10) */ 
d271 1
a271 1
	case NID_sect409k1: /* sect409k1 (11) */ 
d275 1
a275 1
	case NID_sect571k1: /* sect571k1 (13) */ 
d277 1
a277 1
	case NID_sect571r1: /* sect571r1 (14) */ 
d281 1
a281 1
	case NID_secp160r1: /* secp160r1 (16) */ 
d283 1
a283 1
	case NID_secp160r2: /* secp160r2 (17) */ 
d287 1
a287 1
	case NID_X9_62_prime192v1: /* secp192r1 (19) */ 
d289 1
a289 1
	case NID_secp224k1: /* secp224k1 (20) */ 
d293 1
a293 1
	case NID_secp256k1: /* secp256k1 (22) */ 
d295 1
a295 1
	case NID_X9_62_prime256v1: /* secp256r1 (23) */ 
d299 1
a299 1
	case NID_secp521r1:  /* secp521r1 (25) */	
a302 1
		}
d304 1
d350 3
a352 2
int tls12_get_req_sig_algs(SSL *s, unsigned char *p)
	{
d357 1
a357 1
	}
d359 4
a362 3
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
d367 2
a368 2
					&& !s->s3->send_connection_binding)
		return p;
d370 1
a370 1
	ret+=2;
d374 1
a374 2
 	if (s->tlsext_hostname != NULL)
		{ 
d377 2
a378 1
		long lenmax; 
d387 5
a391 5
		   
		if ((lenmax = limit - ret - 9) < 0 
		    || (size_str = strlen(s->tlsext_hostname)) > (unsigned long)lenmax) 
			return NULL;
			
d393 4
a396 3
		s2n(TLSEXT_TYPE_server_name,ret); 
		s2n(size_str+5,ret);
		
d398 2
a399 2
		s2n(size_str+3,ret);
	
d402 1
a402 1
		s2n(size_str,ret);
d404 10
a413 1
		ret+=size_str;
d416 5
a420 21
        /* Add RI if renegotiating */
        if (s->renegotiate)
          {
          int el;
          
          if(!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0))
              {
              SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
              return NULL;
              }

          if((limit - p - 4 - el) < 0) return NULL;
          
          s2n(TLSEXT_TYPE_renegotiate,ret);
          s2n(el,ret);

          if(!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el))
              {
              SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
              return NULL;
              }
d422 7
a428 2
          ret += el;
        }
d433 1
a433 1
		{ /* Add TLS extension SRP username to the Client Hello message */
d435 3
a437 3
		int login_len = strlen(s->srp_ctx.login);	
		if (login_len > 255 || login_len == 0)
			{
d440 1
a440 1
			} 
d447 3
a449 1
		if ((limit - ret - 5 - login_len) < 0) return NULL; 
d452 2
a453 2
		s2n(TLSEXT_TYPE_srp,ret);
		s2n(login_len+1,ret);
d456 2
a457 2
		ret+=login_len;
		}
d462 1
a462 2
	    s->version != DTLS1_VERSION)
		{
d464 5
a468 1
		long lenmax; 
a469 1
		if ((lenmax = limit - ret - 5) < 0) return NULL; 
d471 1
a471 2
		if (s->tlsext_ecpointformatlist_length > 255)
			{
d474 4
a477 4
			}
		
		s2n(TLSEXT_TYPE_ec_point_formats,ret);
		s2n(s->tlsext_ecpointformatlist_length + 1,ret);
d480 2
a481 2
		ret+=s->tlsext_ecpointformatlist_length;
		}
d483 1
a483 2
	    s->version != DTLS1_VERSION)
		{
d485 5
a489 1
		long lenmax; 
a490 1
		if ((lenmax = limit - ret - 6) < 0) return NULL; 
d492 1
a492 2
		if (s->tlsext_ellipticcurvelist_length > 65532)
			{
d495 3
a497 3
			}
		
		s2n(TLSEXT_TYPE_elliptic_curves,ret);
d507 2
a508 2
		ret+=s->tlsext_ellipticcurvelist_length;
		}
d511 1
a511 2
	if (!(SSL_get_options(s) & SSL_OP_NO_TICKET))
		{
d516 1
a516 2
			 s->tlsext_session_ticket->data)
			{
d522 2
a523 2
			       s->tlsext_session_ticket->data,
			       ticklen);
d525 1
a525 2
			}
		else
d528 2
a529 2
		    s->tlsext_session_ticket->data == NULL)
			goto skip_ext;
d534 4
a537 4
		s2n(TLSEXT_TYPE_session_ticket,ret); 
		s2n(ticklen,ret);
		if (ticklen)
			{
a539 1
			}
d541 2
a542 1
		skip_ext:
d544 1
a544 2
	if (TLS1_get_client_version(s) >= TLS1_2_VERSION)
		{
d546 3
a548 2
			return NULL; 
		s2n(TLSEXT_TYPE_signature_algorithms,ret);
d553 1
a553 1
		}
d557 1
a557 2
	    s->version != DTLS1_VERSION)
		{
d559 1
a559 1
		
d565 2
a566 1
		s2n(TLSEXT_TYPE_opaque_prf_input, ret); 
d571 1
a571 1
		}
d575 1
a575 2
	    s->version != DTLS1_VERSION)
		{
d581 1
a581 2
		for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++)
			{
d587 1
a587 1
			}
d589 1
a589 2
		if (s->tlsext_ocsp_exts)
			{
d593 1
a593 2
			}
		else
d595 1
a595 1
			
d597 1
a597 1
		s2n(TLSEXT_TYPE_status_request, ret);
d603 1
a603 2
		for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++)
			{
d612 1
a612 1
			}
d616 1
a616 1
		}
d620 2
a621 2
	s2n(TLSEXT_TYPE_heartbeat,ret);
	s2n(1,ret);
d633 1
a633 2
	if (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len)
		{
d638 3
a640 3
		s2n(TLSEXT_TYPE_next_proto_neg,ret);
		s2n(0,ret);
		}
d644 4
a647 7
        if(SSL_get_srtp_profiles(s))
                {
                int el;

                ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0);
                
                if((limit - p - 4 - el) < 0) return NULL;
d649 2
a650 2
                s2n(TLSEXT_TYPE_use_srtp,ret);
                s2n(el,ret);
d652 4
a655 2
                if(ssl_add_clienthello_use_srtp_ext(s, ret, &el, el))
			{
d658 3
a660 3
			}
                ret += el;
                }
d671 1
a671 1
	int hlen = ret - (unsigned char *)s->init_buf->data;
d675 8
a682 9
	if (s->state == SSL23_ST_CW_CLNT_HELLO_A)
		hlen -= 5;
	if (hlen > 0xff && hlen < 0x200)
		{
		hlen = 0x200 - hlen;
		if (hlen >= 4)
			hlen -= 4;
		else
			hlen = 0;
d684 4
a687 4
		s2n(TLSEXT_TYPE_padding, ret);
		s2n(hlen, ret);
		memset(ret, 0, hlen);
		ret += hlen;
d692 1
a692 1
	if ((extdatalen = ret-p-2)== 0) 
d695 1
a695 1
	s2n(extdatalen,p);
d697 1
a697 1
	}
d699 4
a702 3
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
d711 2
a712 2
	
	ret+=2;
d715 10
a724 28
	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if ((long)(limit - ret - 4) < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}

	if(s->s3->send_connection_binding)
        {
          int el;
          
          if(!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0))
              {
              SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
              return NULL;
              }

          if((limit - p - 4 - el) < 0) return NULL;
          
          s2n(TLSEXT_TYPE_renegotiate,ret);
          s2n(el,ret);

          if(!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el))
              {
              SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
              return NULL;
              }
d726 18
a743 2
          ret += el;
        }
d747 1
a747 2
	    s->version != DTLS1_VERSION)
		{
d749 5
a753 1
		long lenmax; 
a754 1
		if ((lenmax = limit - ret - 5) < 0) return NULL; 
d756 1
a756 2
		if (s->tlsext_ecpointformatlist_length > 255)
			{
d759 4
a762 4
			}
		
		s2n(TLSEXT_TYPE_ec_point_formats,ret);
		s2n(s->tlsext_ecpointformatlist_length + 1,ret);
d765 1
a765 1
		ret+=s->tlsext_ecpointformatlist_length;
d767 1
a767 1
		}
d772 9
a780 6
		&& !(SSL_get_options(s) & SSL_OP_NO_TICKET)) 
		{ 
		if ((long)(limit - ret - 4) < 0) return NULL; 
		s2n(TLSEXT_TYPE_session_ticket,ret);
		s2n(0,ret);
		}
d782 3
a784 6
	if (s->tlsext_status_expected)
		{ 
		if ((long)(limit - ret - 4) < 0) return NULL; 
		s2n(TLSEXT_TYPE_status_request,ret);
		s2n(0,ret);
		}
d788 1
a788 2
	    s->version != DTLS1_VERSION)
		{
d790 1
a790 1
		
d796 2
a797 1
		s2n(TLSEXT_TYPE_opaque_prf_input, ret); 
d802 1
a802 1
		}
d806 2
a807 7
        if(s->srtp_profile)
                {
                int el;

                ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0);
                
                if((limit - p - 4 - el) < 0) return NULL;
d809 1
a809 2
                s2n(TLSEXT_TYPE_use_srtp,ret);
                s2n(el,ret);
d811 7
a817 2
                if(ssl_add_serverhello_use_srtp_ext(s, ret, &el, el))
			{
d820 3
a822 3
			}
                ret+=el;
                }
d825 3
a827 3
	if (((s->s3->tmp.new_cipher->id & 0xFFFF)==0x80 || (s->s3->tmp.new_cipher->id & 0xFFFF)==0x81) 
		&& (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG))
		{ const unsigned char cryptopro_ext[36] = {
d830 10
a839 9
			0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85, 
			0x03,   0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06, 
			0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08, 
			0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17};
			if (limit-ret<36) return NULL;
			memcpy(ret,cryptopro_ext,36);
			ret+=36;

		}
d843 3
a845 4
	if (s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED)
		{
		s2n(TLSEXT_TYPE_heartbeat,ret);
		s2n(1,ret);
d855 1
a855 1
		}
d861 1
a861 2
	if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb)
		{
d867 1
a867 2
		if (r == SSL_TLSEXT_ERR_OK)
			{
d869 2
a870 2
			s2n(TLSEXT_TYPE_next_proto_neg,ret);
			s2n(npalen,ret);
a873 1
			}
d875 1
d878 1
a878 1
	if ((extdatalen = ret-p-2)== 0) 
d881 1
a881 1
	s2n(extdatalen,p);
d883 1
a883 1
	}
d898 2
a899 1
static void ssl_check_for_safari(SSL *s, const unsigned char *data, const unsigned char *d, int n) {
d927 1
a927 1
	if (data >= (d+n-2))
d931 1
a931 1
	if (data > (d+n-4))
d933 2
a934 2
	n2s(data,type);
	n2s(data,size);
d939 1
a939 1
	if (data+size > d+n)
d943 1
a943 2
	if (TLS1_get_client_version(s) >= TLS1_2_VERSION)
		{
d947 1
a947 1
		if (data + len1 + len2 != d+n)
d953 1
a953 3
		}
	else
		{
d956 1
a956 1
		if (data + len != d+n)
d960 1
a960 1
		}
d966 4
a969 2
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)
	{
d985 1
a985 1
	                       SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
d993 1
a993 1
	if (data >= (d+n-2))
d995 1
a995 1
	n2s(data,len);
d997 1
a997 1
	if (data > (d+n-len)) 
d1000 3
a1002 4
	while (data <= (d+n-4))
		{
		n2s(data,type);
		n2s(data,size);
d1004 2
a1005 2
		if (data+size > (d+n))
	   		goto ri_check;
d1007 1
a1007 1
		fprintf(stderr,"Received extension type %d size %d\n",type,size);
d1011 1
a1011 1
						s->tlsext_debug_arg);
d1035 1
a1035 2
		if (type == TLSEXT_TYPE_server_name)
			{
d1038 4
a1041 4
			int dsize; 
		
			if (size < 2) 
				{
d1044 3
a1046 2
				}
			n2s(data,dsize);  
d1048 1
a1048 2
			if (dsize > size  ) 
				{
d1051 1
a1051 1
				} 
d1054 4
a1057 4
			while (dsize > 3) 
				{
	 			servname_type = *(sdata++); 
				n2s(sdata,len);
d1060 1
a1060 2
				if (len > dsize) 
					{
d1063 1
a1063 1
					}
d1065 1
a1065 2
				switch (servname_type)
					{
d1067 2
a1068 4
					if (!s->hit)
						{
						if(s->session->tlsext_hostname)
							{
d1071 2
a1072 3
							}
						if (len > TLSEXT_MAXLEN_host_name)
							{
d1075 2
a1076 3
							}
						if ((s->session->tlsext_hostname = OPENSSL_malloc(len+1)) == NULL)
							{
d1079 1
a1079 1
							}
d1081 1
a1081 1
						s->session->tlsext_hostname[len]='\0';
d1088 2
a1089 1
						s->servername_done = 1; 
d1091 1
a1091 2
						}
					else 
d1093 3
a1095 3
							&& strlen(s->session->tlsext_hostname) == len 
							&& strncmp(s->session->tlsext_hostname, (char *)sdata, len) == 0;
					
d1100 2
a1101 2
					}
				 
d1103 2
a1104 3
				}
			if (dsize != 0) 
				{
d1107 1
a1107 1
				}
d1109 1
a1109 1
			}
d1111 2
a1112 4
		else if (type == TLSEXT_TYPE_srp)
			{
			if (size <= 0 || ((len = data[0])) != (size -1))
				{
d1115 2
a1116 3
				}
			if (s->srp_ctx.login != NULL)
				{
d1119 2
a1120 2
				}
			if ((s->srp_ctx.login = OPENSSL_malloc(len+1)) == NULL)
d1123 3
a1125 4
			s->srp_ctx.login[len]='\0';
  
			if (strlen(s->srp_ctx.login) != len) 
				{
a1127 1
				}
d1129 1
d1134 1
a1134 2
	             s->version != DTLS1_VERSION)
			{
d1138 1
a1138 2
			if (ecpointformatlist_length != size - 1)
				{
d1141 3
a1143 5
				}
			if (!s->hit)
				{
				if(s->session->tlsext_ecpointformatlist)
					{
d1146 1
a1146 1
					}
d1148 1
a1148 2
				if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)
					{
d1151 1
a1151 1
					}
d1154 1
a1154 1
				}
d1156 1
a1156 1
			fprintf(stderr,"ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) ", s->session->tlsext_ecpointformatlist_length);
d1159 2
a1160 2
				fprintf(stderr,"%i ",*(sdata++));
			fprintf(stderr,"\n");
d1162 2
a1163 4
			}
		else if (type == TLSEXT_TYPE_elliptic_curves &&
	             s->version != DTLS1_VERSION)
			{
d1169 1
a1169 2
				ellipticcurvelist_length < 1)
				{
d1172 3
a1174 5
				}
			if (!s->hit)
				{
				if(s->session->tlsext_ellipticcurvelist)
					{
d1177 1
a1177 1
					}
d1179 1
a1179 2
				if ((s->session->tlsext_ellipticcurvelist = OPENSSL_malloc(ellipticcurvelist_length)) == NULL)
					{
d1182 1
a1182 1
					}
d1185 1
a1185 1
				}
d1187 1
a1187 1
			fprintf(stderr,"ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) ", s->session->tlsext_ellipticcurvelist_length);
d1190 2
a1191 2
				fprintf(stderr,"%i ",*(sdata++));
			fprintf(stderr,"\n");
d1193 1
a1193 1
			}
d1197 1
a1197 2
	             s->version != DTLS1_VERSION)
			{
d1200 1
a1200 2
			if (size < 2)
				{
d1203 1
a1203 1
				}
d1205 1
a1205 2
			if (s->s3->client_opaque_prf_input_len != size - 2)
				{
d1208 1
a1208 1
				}
d1216 1
a1216 2
			if (s->s3->client_opaque_prf_input == NULL)
				{
a1218 1
				}
d1220 1
d1222 1
a1222 2
		else if (type == TLSEXT_TYPE_session_ticket)
			{
d1224 1
a1224 2
			    !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg))
				{
a1226 1
				}
d1228 2
a1229 3
		else if (type == TLSEXT_TYPE_renegotiate)
			{
			if(!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
d1232 1
a1232 3
			}
		else if (type == TLSEXT_TYPE_signature_algorithms)
			{
d1234 1
a1234 2
			if (sigalg_seen || size < 2) 
				{
d1237 1
a1237 1
				}
d1239 1
a1239 1
			n2s(data,dsize);
d1241 1
a1241 2
			if (dsize != size || dsize & 1) 
				{
d1244 2
a1245 3
				}
			if (!tls1_process_sigalgs(s, data, dsize))
				{
a1247 1
				}
d1249 4
a1252 6
		else if (type == TLSEXT_TYPE_status_request &&
		         s->version != DTLS1_VERSION)
			{
		
			if (size < 5) 
				{
d1255 1
a1255 1
				}
d1259 1
a1259 2
			if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp)
				{
d1263 1
a1263 1
				n2s(data,dsize);
d1265 1
a1265 2
				if (dsize > size  ) 
					{
d1268 2
a1269 3
					}
				while (dsize > 0)
					{
d1272 1
a1272 2
					if (dsize < 4)
						{
d1275 1
a1275 1
						}
d1279 1
a1279 2
					if (dsize < 0)
						{
d1282 1
a1282 1
						}
d1286 2
a1287 3
								&sdata, idsize);
					if (!id)
						{
d1290 2
a1291 3
						}
					if (data != sdata)
						{
d1295 1
a1295 1
						}
d1298 1
a1298 2
						sk_OCSP_RESPID_new_null()))
						{
d1302 1
a1302 1
						}
d1304 1
a1304 2
							s->tlsext_ocsp_ids, id))
						{
a1307 1
						}
d1309 1
d1312 1
a1312 2
				if (size < 2)
					{
d1315 2
a1316 2
					}
				n2s(data,dsize);
d1318 1
a1318 2
				if (dsize != size)
					{
d1321 1
a1321 1
					}
d1323 2
a1324 4
				if (dsize > 0)
					{
					if (s->tlsext_ocsp_exts)
						{
d1326 2
a1327 2
									   X509_EXTENSION_free);
						}
d1330 2
a1331 2
						d2i_X509_EXTENSIONS(NULL,
							&sdata, dsize);
d1333 1
a1333 2
						|| (data + dsize != sdata))
						{
a1335 1
						}
d1338 1
d1342 3
a1344 3
				else
					s->tlsext_status_type = -1;
			}
d1346 12
a1357 14
		else if (type == TLSEXT_TYPE_heartbeat)
			{
			switch(data[0])
				{
				case 0x01:	/* Client allows us to send HB requests */
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
							break;
				case 0x02:	/* Client doesn't accept HB requests */
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
							break;
				default:	*al = SSL_AD_ILLEGAL_PARAMETER;
							return 0;
				}
d1359 1
d1363 1
a1363 2
			 s->s3->tmp.finish_md_len == 0)
			{
d1380 1
a1380 1
			}
d1385 5
a1389 6
		else if (type == TLSEXT_TYPE_use_srtp)
			{
			if(ssl_parse_clienthello_use_srtp_ext(s, data, size,
							      al))
				return 0;
			}
d1392 3
a1394 3
		data+=size;
		}
				
d1402 1
a1402 2
		!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
		{
d1404 2
a1405 2
	 	SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT,
				SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
d1407 1
a1407 1
		}
d1410 1
a1410 1
	}
d1416 3
a1418 2
static char ssl_next_proto_validate(unsigned char *d, unsigned len)
	{
d1421 1
a1421 2
	while (off < len)
		{
d1426 1
a1426 1
		}
d1429 1
a1429 1
	}
d1432 3
a1434 2
int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)
	{
d1448 1
a1448 1
	                       SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
d1451 1
a1451 1
	if (data >= (d+n-2))
d1454 2
a1455 3
	n2s(data,length);
	if (data+length != d+n)
		{
d1458 1
a1458 1
		}
d1460 3
a1462 4
	while(data <= (d+n-4))
		{
		n2s(data,type);
		n2s(data,size);
d1464 2
a1465 2
		if (data+size > (d+n))
	   		goto ri_check;
d1469 1
a1469 1
						s->tlsext_debug_arg);
d1471 2
a1472 4
		if (type == TLSEXT_TYPE_server_name)
			{
			if (s->tlsext_hostname == NULL || size > 0)
				{
a1474 2
				}
			tlsext_servername = 1;   
d1476 3
d1482 1
a1482 2
	             s->version != DTLS1_VERSION)
			{
d1486 2
a1487 3
			if (ecpointformatlist_length != size - 1 || 
				ecpointformatlist_length < 1)
				{
d1490 1
a1490 1
				}
d1492 3
a1494 3
			if (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);
			if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)
				{
d1497 1
a1497 1
				}
d1501 1
a1501 1
			fprintf(stderr,"ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist ");
d1504 2
a1505 2
				fprintf(stderr,"%i ",*(sdata++));
			fprintf(stderr,"\n");
d1507 1
a1507 1
			}
d1510 1
a1510 2
		else if (type == TLSEXT_TYPE_session_ticket)
			{
d1512 1
a1512 2
			    !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg))
				{
d1515 1
a1515 1
				}
d1517 1
a1517 2
				|| (size > 0))
				{
d1520 1
a1520 1
				}
d1522 1
a1522 1
			}
d1525 1
a1525 2
	             s->version != DTLS1_VERSION)
			{
d1528 1
a1528 2
			if (size < 2)
				{
d1531 1
a1531 1
				}
d1533 1
a1533 2
			if (s->s3->server_opaque_prf_input_len != size - 2)
				{
d1536 2
a1537 2
				}
			
d1545 1
a1545 2
			if (s->s3->server_opaque_prf_input == NULL)
				{
a1547 1
				}
d1549 1
d1552 1
a1552 2
		         s->version != DTLS1_VERSION)
			{
d1556 1
a1556 2
			if ((s->tlsext_status_type == -1) || (size > 0))
				{
d1559 1
a1559 1
				}
d1562 1
a1562 1
			}
d1565 1
a1565 2
			 s->s3->tmp.finish_md_len == 0)
			{
d1570 1
a1570 2
			if (s->ctx->next_proto_select_cb == NULL)
				{
d1573 1
a1573 1
				}
d1575 1
a1575 2
			if (!ssl_next_proto_validate(data, size))
				{
d1578 2
a1579 3
				}
			if (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data, size, s->ctx->next_proto_select_cb_arg) != SSL_TLSEXT_ERR_OK)
				{
d1582 1
a1582 1
				}
d1584 1
a1584 2
			if (!s->next_proto_negotiated)
				{
d1587 1
a1587 1
				}
d1591 1
a1591 1
			}
d1593 2
a1594 3
		else if (type == TLSEXT_TYPE_renegotiate)
			{
			if(!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))
d1597 1
a1597 1
			}
d1599 12
a1610 14
		else if (type == TLSEXT_TYPE_heartbeat)
			{
			switch(data[0])
				{
				case 0x01:	/* Server allows us to send HB requests */
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
							break;
				case 0x02:	/* Server doesn't accept HB requests */
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
							break;
				default:	*al = SSL_AD_ILLEGAL_PARAMETER;
							return 0;
				}
d1612 1
d1615 5
a1619 6
		else if (type == TLSEXT_TYPE_use_srtp)
			{
                        if(ssl_parse_serverhello_use_srtp_ext(s, data, size,
							      al))
                                return 0;
			}
d1622 3
a1624 2
		data+=size;		
		}
d1626 1
a1626 2
	if (data != d+n)
		{
d1629 6
a1634 1
		}
d1636 1
a1636 9
	if (!s->hit && tlsext_servername == 1)
		{
 		if (s->tlsext_hostname)
			{
			if (s->session->tlsext_hostname == NULL)
				{
				s->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);	
				if (!s->session->tlsext_hostname)
					{
a1638 1
					}
d1640 1
a1640 2
			else 
				{
a1642 1
				}
d1645 1
d1660 1
a1660 2
		&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
		{
d1663 1
a1663 1
				SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
d1665 1
a1665 1
		}
d1668 1
a1668 1
	}
d1671 3
a1673 2
int ssl_prepare_clienthello_tlsext(SSL *s)
	{
d1684 1
a1684 2
	for (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++)
		{
d1689 1
a1689 2
		if ((alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe) || (alg_a & SSL_aECDSA)))
			{
a1691 1
			}
d1693 1
d1695 5
a1699 6
	if (using_ecc)
		{
		if (s->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->tlsext_ecpointformatlist);
		if ((s->tlsext_ecpointformatlist = OPENSSL_malloc(3)) == NULL)
			{
			SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,ERR_R_MALLOC_FAILURE);
d1701 1
a1701 1
			}
d1708 2
a1709 1
		if (s->tlsext_ellipticcurvelist != NULL) OPENSSL_free(s->tlsext_ellipticcurvelist);
d1711 1
a1711 2
		if ((s->tlsext_ellipticcurvelist = OPENSSL_malloc(s->tlsext_ellipticcurvelist_length)) == NULL)
			{
d1713 1
a1713 1
			SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,ERR_R_MALLOC_FAILURE);
d1715 5
a1719 4
			}
		for (i = 0, j = s->tlsext_ellipticcurvelist; (unsigned int)i <
				sizeof(pref_list)/sizeof(pref_list[0]); i++)
			{
d1721 1
a1721 2
			s2n(id,j);
			}
d1723 1
d1727 1
a1727 1
 	{
d1729 2
a1730 3
	
		if (s->ctx->tlsext_opaque_prf_input_callback != 0)
			{
d1734 1
a1734 1
			}
d1736 1
a1736 2
		if (s->tlsext_opaque_prf_input != NULL)
			{
d1744 2
a1745 3
			if (s->s3->client_opaque_prf_input == NULL)
				{
				SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,ERR_R_MALLOC_FAILURE);
d1747 1
a1747 1
				}
d1749 1
a1749 1
			}
d1753 1
a1753 1
			s->s3->server_opaque_prf_input_len = s->tlsext_opaque_prf_input_len;
d1758 1
a1758 1
	}
d1760 3
a1762 2
int ssl_prepare_serverhello_tlsext(SSL *s)
	{
d1773 6
a1778 7
	
	if (using_ecc)
		{
		if (s->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->tlsext_ecpointformatlist);
		if ((s->tlsext_ecpointformatlist = OPENSSL_malloc(3)) == NULL)
			{
			SSLerr(SSL_F_SSL_PREPARE_SERVERHELLO_TLSEXT,ERR_R_MALLOC_FAILURE);
d1780 1
a1780 1
			}
d1785 1
a1785 1
		}
d1789 1
a1789 1
	}
d1791 4
a1794 3
int ssl_check_clienthello_tlsext_early(SSL *s)
	{
	int ret=SSL_TLSEXT_ERR_NOACK;
d1806 1
a1806 1
	if (s->ctx != NULL && s->ctx->tlsext_servername_callback != 0) 
d1808 1
a1808 1
	else if (s->initial_ctx != NULL && s->initial_ctx->tlsext_servername_callback != 0) 		
d1812 1
a1812 1
 	{
d1819 2
a1820 3
	
		if (s->ctx->tlsext_opaque_prf_input_callback != 0)
			{
d1822 1
a1822 2
			if (!r)
				{
a1825 1
				}
d1827 1
d1833 1
a1833 2
		if (s->tlsext_opaque_prf_input != NULL)
			{
d1835 1
a1835 2
				s->s3->client_opaque_prf_input_len == s->tlsext_opaque_prf_input_len)
				{
d1843 1
a1843 2
				if (s->s3->server_opaque_prf_input == NULL)
					{
d1847 1
a1847 1
					}
a1848 1
				}
d1850 1
d1852 1
a1852 2
		if (r == 2 && s->s3->server_opaque_prf_input == NULL)
			{
d1859 1
a1859 1
			}
d1862 1
a1862 1
 err:
d1864 10
a1873 5
	switch (ret)
		{
		case SSL_TLSEXT_ERR_ALERT_FATAL:
			ssl3_send_alert(s,SSL3_AL_FATAL,al); 
			return -1;
d1875 3
a1877 7
		case SSL_TLSEXT_ERR_ALERT_WARNING:
			ssl3_send_alert(s,SSL3_AL_WARNING,al);
			return 1; 
					
		case SSL_TLSEXT_ERR_NOACK:
			s->servername_done=0;
			default:
a1878 1
		}
d1880 1
d1882 3
a1884 2
int ssl_check_clienthello_tlsext_late(SSL *s)
	{
d1893 1
a1893 2
	if ((s->tlsext_status_type != -1) && s->ctx && s->ctx->tlsext_status_cb)
		{
d1898 1
a1898 2
		if (certpkey == NULL)
			{
d1901 1
a1901 1
			}
d1907 1
a1907 2
		switch (r)
			{
d1909 8
a1916 1
			case SSL_TLSEXT_ERR_NOACK:
d1918 1
a1918 8
				break;
			/* status request response should be sent */
			case SSL_TLSEXT_ERR_OK:
				if (s->tlsext_ocsp_resp)
					s->tlsext_status_expected = 1;
				else
					s->tlsext_status_expected = 0;
				break;
d1920 4
a1923 5
			case SSL_TLSEXT_ERR_ALERT_FATAL:
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;
				al = SSL_AD_INTERNAL_ERROR;
				goto err;
			}
d1925 1
a1925 1
	else
d1928 10
a1937 6
 err:
	switch (ret)
		{
		case SSL_TLSEXT_ERR_ALERT_FATAL:
			ssl3_send_alert(s,SSL3_AL_FATAL,al); 
			return -1;
a1938 3
		case SSL_TLSEXT_ERR_ALERT_WARNING:
			ssl3_send_alert(s,SSL3_AL_WARNING,al);
			return 1; 
d1940 2
a1941 3
		default:
			return 1;
		}
d1943 1
d1945 4
a1948 3
int ssl_check_serverhello_tlsext(SSL *s)
	{
	int ret=SSL_TLSEXT_ERR_NOACK;
d1958 3
a1960 4
	if ((s->tlsext_ecpointformatlist != NULL) && (s->tlsext_ecpointformatlist_length > 0) && 
	    (s->session->tlsext_ecpointformatlist != NULL) && (s->session->tlsext_ecpointformatlist_length > 0) && 
	    ((alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) || (alg_a & SSL_aECDSA)))
		{
d1966 2
a1967 4
		for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)
			{
			if (*(list++) == TLSEXT_ECPOINTFORMAT_uncompressed)
				{
a1969 1
				}
d1971 3
a1973 3
		if (!found_uncompressed)
			{
			SSLerr(SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT,SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);
a1974 1
			}
d1976 1
d1980 1
a1980 1
	if (s->ctx != NULL && s->ctx->tlsext_servername_callback != 0) 
d1982 1
a1982 1
	else if (s->initial_ctx != NULL && s->initial_ctx->tlsext_servername_callback != 0) 		
d1986 1
a1986 2
	if (s->s3->server_opaque_prf_input_len > 0)
		{
d1990 1
a1990 2
		if (s->s3->server_opaque_prf_input == NULL)
			{
d1993 2
a1994 2
			}
		
d1998 1
a1998 2
		    s->s3->client_opaque_prf_input_len != s->s3->server_opaque_prf_input_len)
			{
a2000 1
			}
d2002 1
d2009 1
a2009 2
			&& s->ctx && s->ctx->tlsext_status_cb)
		{
d2014 1
a2014 2
		if (s->tlsext_ocsp_resp)
			{
d2017 1
a2017 1
			}
d2020 1
a2020 2
		if (r == 0)
			{
d2023 2
a2024 3
			}
		if (r < 0)
			{
a2026 1
			}
d2028 11
a2039 5
	switch (ret)
		{
		case SSL_TLSEXT_ERR_ALERT_FATAL:
			ssl3_send_alert(s,SSL3_AL_FATAL,al); 
			return -1;
d2041 3
a2043 7
		case SSL_TLSEXT_ERR_ALERT_WARNING:
			ssl3_send_alert(s,SSL3_AL_WARNING,al);
			return 1; 
					
		case SSL_TLSEXT_ERR_NOACK:
			s->servername_done=0;
			default:
a2044 1
		}
d2046 1
d2081 4
a2084 3
int tls1_process_ticket(SSL *s, unsigned char *session_id, int len,
			const unsigned char *limit, SSL_SESSION **ret)
	{
d2102 1
a2102 2
	if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)
		{
d2104 1
a2104 1
		p+= i;
d2107 1
a2107 1
		}
d2110 1
a2110 1
	p+= i;
d2122 1
a2122 2
	while ((p + 4) <= limit)
		{
d2128 1
a2128 2
		if (type == TLSEXT_TYPE_session_ticket)
			{
d2130 1
a2130 2
			if (size == 0)
				{
d2135 2
a2136 3
				}
			if (s->tls_session_secret_cb)
				{
d2143 1
a2143 1
				}
d2145 11
a2155 13
			switch (r)
				{
				case 2: /* ticket couldn't be decrypted */
					s->tlsext_ticket_expected = 1;
					return 2;
				case 3: /* ticket was decrypted */
					return r;
				case 4: /* ticket decrypted but need to renew */
					s->tlsext_ticket_expected = 1;
					return 3;
				default: /* fatal error */
					return -1;
				}
d2157 1
d2159 1
a2159 1
		}
d2161 1
a2161 1
	}
d2178 4
a2181 4
static int tls_decrypt_ticket(SSL *s, const unsigned char *etick, int eticklen,
				const unsigned char *sess_id, int sesslen,
				SSL_SESSION **psess)
	{
d2196 1
a2196 2
	if (tctx->tlsext_ticket_key_cb)
		{
d2199 1
a2199 1
							&ctx, &hctx, 0);
d2206 1
a2206 3
		}
	else
		{
d2211 1
a2211 1
					tlsext_tick_md(), NULL);
d2213 2
a2214 2
				tctx->tlsext_tick_aes_key, etick + 16);
		}
d2219 1
a2219 2
	if (mlen < 0)
		{
d2222 1
a2222 1
		}
d2235 1
a2235 2
	if (!sdec)
		{
d2238 1
a2238 1
		}
d2248 1
a2248 2
	if (sess)
		{
d2262 2
a2263 2
		}
        ERR_clear_error();
d2267 1
a2267 1
	}
d2271 1
a2271 2
typedef struct 
	{
d2274 1
a2274 1
	} tls12_lookup;
d2305 3
a2307 2
static int tls12_find_id(int nid, tls12_lookup *table, size_t tlen)
	{
d2309 1
a2309 2
	for (i = 0; i < tlen; i++)
		{
d2312 1
a2312 1
		}
d2314 1
a2314 1
	}
d2316 3
a2318 2
static int tls12_find_nid(int id, tls12_lookup *table, size_t tlen)
	{
d2320 1
a2320 2
	for (i = 0; i < tlen; i++)
		{
d2323 1
a2323 1
		}
d2325 1
a2325 1
	}
d2328 3
a2330 2
int tls12_get_sigandhash(unsigned char *p, const EVP_PKEY *pk, const EVP_MD *md)
	{
d2335 1
a2335 1
				sizeof(tls12_md)/sizeof(tls12_lookup));
d2344 1
a2344 1
	}
d2346 3
a2348 2
int tls12_get_sigid(const EVP_PKEY *pk)
	{
d2350 2
a2351 2
				sizeof(tls12_sig)/sizeof(tls12_lookup));
	}
d2353 4
a2356 4
const EVP_MD *tls12_get_hash(unsigned char hash_alg)
	{
	switch(hash_alg)
		{
d2358 1
a2358 1
		case TLSEXT_hash_sha1:
d2362 1
a2362 1
		case TLSEXT_hash_sha224:
d2365 1
a2365 1
		case TLSEXT_hash_sha256:
d2369 1
a2369 1
		case TLSEXT_hash_sha384:
d2372 1
a2372 1
		case TLSEXT_hash_sha512:
d2375 1
a2375 1
		default:
a2377 1
		}
d2379 1
d2383 3
a2385 2
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
	{
d2401 2
a2402 3
	for (i = 0; i < dsize; i += 2)
		{
		unsigned char hash_alg = data[i], sig_alg = data[i+1];
d2404 1
a2404 2
		switch(sig_alg)
			{
d2406 1
a2406 1
			case TLSEXT_signature_rsa:
d2411 1
a2411 1
			case TLSEXT_signature_dsa:
d2416 1
a2416 1
			case TLSEXT_signature_ecdsa:
d2420 1
a2420 1
			default:
d2422 1
a2422 1
			}
d2424 1
a2424 2
		if (c->pkeys[idx].digest == NULL)
			{
d2426 1
a2426 2
			if (md)
				{
a2429 1
				}
d2431 1
d2433 1
a2433 1
		}
d2444 1
a2444 2
	if (!c->pkeys[SSL_PKEY_RSA_SIGN].digest)
		{
d2447 1
a2447 1
		}
d2454 1
a2454 1
	}
d2461 1
a2461 1
	{
d2469 2
a2470 2
			&s->s3->rrec.data[0], s->s3->rrec.length,
			s, s->msg_callback_arg);
d2481 1
a2481 2
	if (hbtype == TLS1_HB_REQUEST)
		{
d2491 1
a2491 1
		
d2504 2
a2505 2
				buffer, 3 + payload + padding,
				s, s->msg_callback_arg);
d2511 1
a2511 3
		}
	else if (hbtype == TLS1_HB_RESPONSE)
		{
d2513 1
a2513 1
		
d2518 2
a2519 3
		
		if (payload == 18 && seq == s->tlsext_hb_seq)
			{
a2521 1
			}
d2523 1
d2526 1
a2526 1
	}
d2530 1
a2530 1
	{
d2538 2
a2539 3
	    s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_SEND_REQUESTS)
		{
		SSLerr(SSL_F_TLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT);
d2541 1
a2541 1
		}
d2544 2
a2545 3
	if (s->tlsext_hb_pending)
		{
		SSLerr(SSL_F_TLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PENDING);
d2547 2
a2548 2
		}
		
d2550 2
a2551 3
	if (SSL_in_init(s) || s->in_handshake)
		{
		SSLerr(SSL_F_TLS1_HEARTBEAT,SSL_R_UNEXPECTED_MESSAGE);
d2553 2
a2554 2
		}
		
d2584 1
a2584 2
	if (ret >= 0)
		{
d2587 2
a2588 2
				buf, 3 + payload + padding,
				s, s->msg_callback_arg);
d2591 2
a2592 2
		}
		
d2596 1
a2596 1
	}
@


1.13
log
@cherrypick fix for CVE-2014-0160 "heartbleed" vulnerability from
OpenSSL git; ok sthen@@
@
text
@a344 3
#ifndef OPENSSL_NO_MD5
	tlsext_sigalg_rsa(TLSEXT_hash_md5)
#endif
a349 5
#ifdef OPENSSL_FIPS
	/* If FIPS mode don't include MD5 which is last */
	if (FIPS_mode())
		slen -= 2;
#endif
d644 1
d663 31
d808 1
d827 1
d891 83
d994 5
d1194 2
a1195 1
			if (ellipticcurvelist_length != size - 2)
d1294 1
a1294 1
		         s->version != DTLS1_VERSION && s->ctx->tlsext_status_cb)
d1446 1
d1448 1
a1448 1
                        {
d1452 2
a1453 1
                        }
d1553 2
a1554 1
			if (ecpointformatlist_length != size - 1)
d1648 1
a1648 1
			if ((s->ctx->next_proto_select_cb == NULL))
d1698 1
d1700 1
a1700 1
                        {
d1704 2
a1705 1
                        }
d1886 1
a1886 1
int ssl_check_clienthello_tlsext(SSL *s)
a1904 31
	/* If status request then ask callback what to do.
 	 * Note: this must be called after servername callbacks in case 
 	 * the certificate has changed.
 	 */
	if ((s->tlsext_status_type != -1) && s->ctx && s->ctx->tlsext_status_cb)
		{
		int r;
		r = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);
		switch (r)
			{
			/* We don't want to send a status request response */
			case SSL_TLSEXT_ERR_NOACK:
				s->tlsext_status_expected = 0;
				break;
			/* status request response should be sent */
			case SSL_TLSEXT_ERR_OK:
				if (s->tlsext_ocsp_resp)
					s->tlsext_status_expected = 1;
				else
					s->tlsext_status_expected = 0;
				break;
			/* something bad happened */
			case SSL_TLSEXT_ERR_ALERT_FATAL:
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;
				al = SSL_AD_INTERNAL_ERROR;
				goto err;
			}
		}
	else
		s->tlsext_status_expected = 0;

d1909 2
a1910 1
		 * so this has to happen here in ssl_check_clienthello_tlsext(). */
d1962 1
a1963 1
 err:
d1981 65
d2347 1
a2347 1
	if (timingsafe_bcmp(tick_hmac, etick + eticklen, mlen))
a2476 8
#ifndef OPENSSL_NO_MD5
		case TLSEXT_hash_md5:
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			return NULL;
#endif
		return EVP_md5();
#endif
d2564 1
a2564 1
		c->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_dss1();
d2575 1
a2575 1
		c->pkeys[SSL_PKEY_ECC].digest = EVP_ecdsa();
@


1.12
log
@cherry pick bugfixes for http://www.openssl.org/news/secadv_20130205.txt
from the openssl git (changes between openssl 1.0.1c and 1.0.1d).
ok djm@@
@
text
@d2444 5
d2450 2
d2454 2
a2456 5

	if (s->msg_callback)
		s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
			&s->s3->rrec.data[0], s->s3->rrec.length,
			s, s->msg_callback_arg);
@


1.12.8.1
log
@MFC:
cherrypick fix for CVE-2014-0160 "heartbleed" vulnerability from
OpenSSL git; ok sthen@@
@
text
@d2444 5
a2452 9

	/* Read type and payload length first */
	if (1 + 2 + 16 > s->s3->rrec.length)
		return 0; /* silently discard */
	hbtype = *p++;
	n2s(p, payload);
	if (1 + 2 + payload + 16 > s->s3->rrec.length)
		return 0; /* silently discard per RFC 6520 sec. 4 */
	pl = p;
@


1.12.8.2
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d363 1
a363 1
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf, unsigned char *limit)
d366 1
a366 2
	unsigned char *orig = buf;
	unsigned char *ret = buf;
d371 1
a371 1
		return orig;
d420 1
a420 1
          if((limit - ret - 4 - el) < 0) return NULL;
d463 2
a464 1
	if (s->tlsext_ecpointformatlist != NULL)
d483 2
a484 1
	if (s->tlsext_ellipticcurvelist != NULL)
d658 1
a658 1
                if((limit - ret - 4 - el) < 0) return NULL;
d671 2
a672 2
	if ((extdatalen = ret-orig-2)== 0) 
		return orig;
d674 1
a674 1
	s2n(extdatalen, orig);
d678 1
a678 1
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf, unsigned char *limit)
d681 1
a681 2
	unsigned char *orig = buf;
	unsigned char *ret = buf;
d688 1
a688 1
		return orig;
d711 1
a711 1
          if((limit - ret - 4 - el) < 0) return NULL;
d726 2
a727 1
	if (s->tlsext_ecpointformatlist != NULL)
d790 1
a790 1
                if((limit - ret - 4 - el) < 0) return NULL;
d858 2
a859 2
	if ((extdatalen = ret-orig-2)== 0) 
		return orig;
d861 1
a861 1
	s2n(extdatalen, orig);
d1038 2
a1039 1
		else if (type == TLSEXT_TYPE_ec_point_formats)
d1073 2
a1074 1
		else if (type == TLSEXT_TYPE_elliptic_curves)
d1430 2
a1431 1
		else if (type == TLSEXT_TYPE_ec_point_formats)
d1441 3
a1443 1
			if (!s->hit)
d1445 2
a1446 9
				s->session->tlsext_ecpointformatlist_length = 0;
				if (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);
				if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)
					{
					*al = TLS1_AD_INTERNAL_ERROR;
					return 0;
					}
				s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;
				memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);
d1448 2
@


1.12.8.3
log
@fix two remotely triggerable memory leaks.
tested by jasper
@
text
@d2191 1
a2191 2
	if (timingsafe_bcmp(tick_hmac, etick + eticklen, mlen)) {
		EVP_CIPHER_CTX_cleanup(&ctx);
a2192 1
	}
@


1.12.4.1
log
@MFC:
cherrypick fix for CVE-2014-0160 "heartbleed" vulnerability from
OpenSSL git; ok sthen@@
@
text
@d2444 5
a2452 9

	/* Read type and payload length first */
	if (1 + 2 + 16 > s->s3->rrec.length)
		return 0; /* silently discard */
	hbtype = *p++;
	n2s(p, payload);
	if (1 + 2 + payload + 16 > s->s3->rrec.length)
		return 0; /* silently discard per RFC 6520 sec. 4 */
	pl = p;
@


1.12.4.2
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d363 1
a363 1
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf, unsigned char *limit)
d366 1
a366 2
	unsigned char *orig = buf;
	unsigned char *ret = buf;
d371 1
a371 1
		return orig;
d420 1
a420 1
          if((limit - ret - 4 - el) < 0) return NULL;
d463 2
a464 1
	if (s->tlsext_ecpointformatlist != NULL)
d483 2
a484 1
	if (s->tlsext_ellipticcurvelist != NULL)
d658 1
a658 1
                if((limit - ret - 4 - el) < 0) return NULL;
d671 2
a672 2
	if ((extdatalen = ret-orig-2)== 0) 
		return orig;
d674 1
a674 1
	s2n(extdatalen, orig);
d678 1
a678 1
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf, unsigned char *limit)
d681 1
a681 2
	unsigned char *orig = buf;
	unsigned char *ret = buf;
d688 1
a688 1
		return orig;
d711 1
a711 1
          if((limit - ret - 4 - el) < 0) return NULL;
d726 2
a727 1
	if (s->tlsext_ecpointformatlist != NULL)
d790 1
a790 1
                if((limit - ret - 4 - el) < 0) return NULL;
d858 2
a859 2
	if ((extdatalen = ret-orig-2)== 0) 
		return orig;
d861 1
a861 1
	s2n(extdatalen, orig);
d1038 2
a1039 1
		else if (type == TLSEXT_TYPE_ec_point_formats)
d1073 2
a1074 1
		else if (type == TLSEXT_TYPE_elliptic_curves)
d1430 2
a1431 1
		else if (type == TLSEXT_TYPE_ec_point_formats)
d1441 3
a1443 1
			if (!s->hit)
d1445 2
a1446 9
				s->session->tlsext_ecpointformatlist_length = 0;
				if (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);
				if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)
					{
					*al = TLS1_AD_INTERNAL_ERROR;
					return 0;
					}
				s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;
				memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);
d1448 2
@


1.12.4.3
log
@fix two remotely triggerable memory leaks.
tested by jasper
@
text
@d2191 1
a2191 2
	if (timingsafe_bcmp(tick_hmac, etick + eticklen, mlen)) {
		EVP_CIPHER_CTX_cleanup(&ctx);
a2192 1
	}
@


1.12.2.1
log
@MFC:
cherrypick fix for CVE-2014-0160 "heartbleed" vulnerability from
OpenSSL git; ok sthen@@
@
text
@d2444 5
a2452 9

	/* Read type and payload length first */
	if (1 + 2 + 16 > s->s3->rrec.length)
		return 0; /* silently discard */
	hbtype = *p++;
	n2s(p, payload);
	if (1 + 2 + payload + 16 > s->s3->rrec.length)
		return 0; /* silently discard per RFC 6520 sec. 4 */
	pl = p;
@


1.11
log
@resolve conflicts
@
text
@d2192 1
a2192 1
	if (memcmp(tick_hmac, etick + eticklen, mlen))
@


1.10
log
@OpenSSL 1.0.0f: merge
@
text
@d117 1
d140 1
d171 1
a171 1
	s->version=TLS1_VERSION;
d175 1
d204 30
a233 1
	
d305 58
d410 1
a410 1
        if (s->new_session)
d434 28
d547 11
d626 45
d682 3
d783 20
d818 40
d872 1
d876 8
d1011 25
d1156 22
d1290 39
d1331 7
d1347 1
a1347 1
	if (!renegotiate_seen && s->new_session &&
d1359 20
d1388 9
d1522 35
d1563 24
d1666 1
a1666 1
	using_ecc = using_ecc && (s->version == TLS1_VERSION);
d1682 1
a1682 1
		s->tlsext_ellipticcurvelist_length = sizeof(nid_list)/sizeof(nid_list[0]) * 2;
d1689 6
a1694 3
		for (i = 1, j = s->tlsext_ellipticcurvelist; (unsigned int)i <=
				sizeof(nid_list)/sizeof(nid_list[0]); i++)
			s2n(i,j);
d2003 32
a2034 3
/* Since the server cache lookup is done early on in the processing of client
 * hello and other operations depend on the result we need to handle any TLS
 * session ticket extension at the same time.
a2035 1

d2037 1
a2037 1
				const unsigned char *limit, SSL_SESSION **ret)
d2043 3
d2047 2
a2048 2
 	 * to permit stateful resumption.
 	 */
d2050 1
a2050 2
		return 1;

d2052 1
a2052 1
		return 1;
d2075 1
a2075 1
		return 1;
d2083 1
a2083 1
			return 1;
d2086 1
a2086 8
			/* If tickets disabled indicate cache miss which will
 			 * trigger a full handshake
 			 */
			if (SSL_get_options(s) & SSL_OP_NO_TICKET)
				return 1;
			/* If zero length note client will accept a ticket
 			 * and indicate cache miss to trigger full handshake
 			 */
d2089 2
d2092 1
a2092 1
				return 0;	/* Cache miss */
d2096 20
a2115 6
				/* Indicate cache miss here and instead of
				 * generating the session from ticket now,
				 * trigger abbreviated handshake based on
				 * external mechanism to calculate the master
				 * secret later. */
				return 0;
a2116 2
			return tls_decrypt_ticket(s, p, size, session_id, len,
									ret);
d2120 1
a2120 1
	return 1;
d2123 15
d2152 1
a2152 1
		goto tickerr;
d2164 1
a2164 1
			goto tickerr;
d2172 1
a2172 1
			goto tickerr;
d2179 2
a2180 2
 	 * integrity checks on ticket.
 	 */
d2193 1
a2193 1
		goto tickerr;
d2206 1
a2206 1
		goto tickerr;
d2210 1
a2210 1
		
d2215 5
a2219 5
		/* The session ID if non-empty is used by some clients to
 		 * detect that the ticket has been accepted. So we copy it to
 		 * the session structure. If it is empty set length to zero
 		 * as required by standard.
 		 */
d2224 139
a2362 1
		s->tlsext_ticket_expected = renew_ticket;
d2364 136
d2501 1
a2501 5
	/* If session decrypt failure indicate a cache miss and set state to
 	 * send a new ticket
 	 */
	tickerr:	
	s->tlsext_ticket_expected = 1;
d2505 73
@


1.9
log
@openssl-1.0.0e: resolve conflicts
@
text
@d974 6
@


1.8
log
@fix for CVE-2011-0014 "OCSP stapling vulnerability";
ok markus@@ jasper@@ miod@@

AFAIK nothing in base uses this, though apache2 from ports may be affected.
@
text
@d1016 1
a1018 1
	unsigned short len;  
d1026 6
a1031 1
	n2s(data,len);
d1461 3
a1463 2
	/* If we are client and using an elliptic curve cryptography cipher suite, then server
	 * must return a an EC point formats lists containing uncompressed.
d1468 1
a1474 5
		if ((s->session->tlsext_ecpointformatlist == NULL) || (s->session->tlsext_ecpointformatlist_length == 0))
			{
			SSLerr(SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT,SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);
			return -1;
			}
@


1.7
log
@- Apply security fix for CVE-2010-3864 (+commit 19998 which fixes the fix).

ok djm@@ deraadt@@
@
text
@d920 1
d959 5
d966 1
a966 1
				if (dsize > size) 
@


1.6
log
@resolve conflicts, fix local changes
@
text
@d717 1
a717 1
					if (s->session->tlsext_hostname == NULL)
d719 6
a724 2
						if (len > TLSEXT_MAXLEN_host_name || 
							((s->session->tlsext_hostname = OPENSSL_malloc(len+1)) == NULL))
d729 5
d746 2
a747 1
						s->servername_done = strlen(s->session->tlsext_hostname) == len 
d778 1
a778 3
			s->session->tlsext_ecpointformatlist_length = 0;
			if (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);
			if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)
d780 13
a792 2
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
a793 2
			s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;
			memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);
d814 1
a814 3
			s->session->tlsext_ellipticcurvelist_length = 0;
			if (s->session->tlsext_ellipticcurvelist != NULL) OPENSSL_free(s->session->tlsext_ellipticcurvelist);
			if ((s->session->tlsext_ellipticcurvelist = OPENSSL_malloc(ellipticcurvelist_length)) == NULL)
d816 13
a828 2
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
a829 2
			s->session->tlsext_ellipticcurvelist_length = ellipticcurvelist_length;
			memcpy(s->session->tlsext_ellipticcurvelist, sdata, ellipticcurvelist_length);
@


1.5
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d58 53
a147 5
IMPLEMENT_tls1_meth_func(tlsv1_base_method,
			ssl_undefined_function,
			ssl_undefined_function,
			ssl_bad_method)

d157 6
d172 31
a202 2
#if 0
long tls1_ctrl(SSL *s, int cmd, long larg, char *parg)
d204 5
a208 1
	return(0);
d211 1
a211 1
long tls1_callback_ctrl(SSL *s, int cmd, void *(*fp)())
d213 56
a268 1
	return(0);
d270 1
a270 1
#endif
d278 5
d302 1
a302 1
		|| (size_str = strlen(s->tlsext_hostname)) > (unsigned long)lenmax) 
d317 1
d319 71
d391 1
d396 1
a396 1
		if (s->session && s->session->tlsext_tick)
d398 12
d412 3
d418 1
a418 2
		if (limit - ret - 4 - ticklen < 0)
			return NULL;
d427 20
d448 2
a449 1
	if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp)
d509 4
d518 1
a518 1
		if (limit - ret - 4 < 0) return NULL; 
d523 50
a572 1
	
d576 1
a576 1
		if (limit - ret - 4 < 0) return NULL; 
d588 33
d634 2
d640 1
a640 1
		return 1;
d644 1
a644 1
		return 1;
d652 4
a655 2
	   		return 1;

d755 108
a862 2
		else if (type == TLSEXT_TYPE_status_request
						&& s->ctx->tlsext_status_cb)
d961 1
d963 6
d970 9
a978 1
		data+=size;		
a980 1
	*p = data;
a989 1

d991 1
d994 1
a994 1
		return 1;
d1004 1
a1004 1
	   		return 1;
d1019 32
d1053 6
d1067 34
a1100 1
		else if (type == TLSEXT_TYPE_status_request)
d1113 6
a1118 1

d1150 142
d1300 9
d1318 1
a1318 1
	if ((s->tlsext_status_type != -1) && s->ctx->tlsext_status_cb)
d1344 59
a1402 1
	err:
d1425 36
d1466 23
d1493 1
a1493 1
			&& s->ctx->tlsext_status_cb)
d1557 8
d1588 5
d1601 9
d1629 1
d1636 1
a1636 1
	if (s->ctx->tlsext_ticket_key_cb)
d1639 1
a1639 1
		int rv = s->ctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,
d1651 1
a1651 1
		if (memcmp(etick, s->ctx->tlsext_tick_key_name, 16))
d1653 1
a1653 1
		HMAC_Init_ex(&hctx, s->ctx->tlsext_tick_hmac_key, 16,
d1656 1
a1656 1
				s->ctx->tlsext_tick_aes_key, etick + 16);
d1662 5
@


1.5.4.1
log
@- Apply security fix for CVE-2010-3864.

ok djm@@ deraadt@@
@
text
@d372 1
a372 1
					if (!s->hit)
d374 2
a375 6
						if(s->session->tlsext_hostname)
							{
							*al = SSL_AD_DECODE_ERROR;
							return 0;
							}
						if (len > TLSEXT_MAXLEN_host_name)
a379 5
						if ((s->session->tlsext_hostname = OPENSSL_malloc(len+1)) == NULL)
							{
							*al = TLS1_AD_INTERNAL_ERROR;
							return 0;
							}
d392 1
a392 2
						s->servername_done = s->session->tlsext_hostname
							&& strlen(s->session->tlsext_hostname) == len 
@


1.5.4.2
log
@MFC:

----------------------------
revision 1.8
date: 2011/02/10 22:40:27;  author: djm;  state: Exp;  lines: +7 -1
fix for CVE-2011-0014 "OCSP stapling vulnerability";
ok markus@@ jasper@@ miod@@

AFAIK nothing in base uses this, though apache2 from ports may be affected.
----------------------------
@
text
@a454 1
					size -= 2 + idsize;
a492 5
				if (size < 2)
					{
					*al = SSL_AD_DECODE_ERROR;
					return 0;
					}
d495 1
a495 1
				if (dsize != size)
@


1.5.8.1
log
@- Apply security fix for CVE-2010-3864.

ok djm@@ deraadt@@
@
text
@d372 1
a372 1
					if (!s->hit)
d374 2
a375 6
						if(s->session->tlsext_hostname)
							{
							*al = SSL_AD_DECODE_ERROR;
							return 0;
							}
						if (len > TLSEXT_MAXLEN_host_name)
a379 5
						if ((s->session->tlsext_hostname = OPENSSL_malloc(len+1)) == NULL)
							{
							*al = TLS1_AD_INTERNAL_ERROR;
							return 0;
							}
d392 1
a392 2
						s->servername_done = s->session->tlsext_hostname
							&& strlen(s->session->tlsext_hostname) == len 
@


1.5.8.2
log
@MFC:

----------------------------
revision 1.8
date: 2011/02/10 22:40:27;  author: djm;  state: Exp;  lines: +7 -1
fix for CVE-2011-0014 "OCSP stapling vulnerability";
ok markus@@ jasper@@ miod@@

AFAIK nothing in base uses this, though apache2 from ports may be affected.
----------------------------
@
text
@a454 1
					size -= 2 + idsize;
a492 5
				if (size < 2)
					{
					*al = SSL_AD_DECODE_ERROR;
					return 0;
					}
d495 1
a495 1
				if (dsize != size)
@


1.4
log
@resolve conflicts
@
text
@d737 7
d771 1
a771 6
			/* If tickets disabled indicate cache miss which will
 			 * trigger a full handshake
 			 */
			if (SSL_get_options(s) & SSL_OP_NO_TICKET)
				return 0;
			/* If zero length not client will accept a ticket
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d61 3
d66 1
a66 1
const char *tls1_version_str="TLSv1" OPENSSL_VERSION_PTEXT;
d68 5
a72 1
static long tls1_default_timeout(void);
d74 1
a74 1
static SSL3_ENC_METHOD TLSv1_enc_data={
d88 1
a88 29
static SSL_METHOD TLSv1_data= {
	TLS1_VERSION,
	tls1_new,
	tls1_clear,
	tls1_free,
	ssl_undefined_function,
	ssl_undefined_function,
	ssl3_read,
	ssl3_peek,
	ssl3_write,
	ssl3_shutdown,
	ssl3_renegotiate,
	ssl3_renegotiate_check,
	ssl3_ctrl,
	ssl3_ctx_ctrl,
	ssl3_get_cipher_by_char,
	ssl3_put_cipher_by_char,
	ssl3_pending,
	ssl3_num_ciphers,
	ssl3_get_cipher,
	ssl_bad_method,
	tls1_default_timeout,
	&TLSv1_enc_data,
	ssl_undefined_function,
	ssl3_callback_ctrl,
	ssl3_ctx_callback_ctrl,
	};

static long tls1_default_timeout(void)
d95 4
a98 4
SSL_METHOD *tlsv1_base_method(void)
	{
	return(&TLSv1_data);
	}
d128 748
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d63 1
a63 1
char *tls1_version_str="TLSv1" OPENSSL_VERSION_PTEXT;
a64 1
#ifndef NO_PROTO
a65 3
#else
static long tls1_default_timeout();
#endif
d104 3
d141 5
@


1.1
log
@Initial revision
@
text
@d60 1
a60 1
#include "objects.h"
d63 1
a63 1
char *tls1_version_str="TLSv1 part of SSLeay 0.9.0b 29-Jun-1998";
d97 1
d110 1
a110 1
static long tls1_default_timeout()
d117 1
a117 1
SSL_METHOD *tlsv1_base_method()
d122 1
a122 2
int tls1_new(s)
SSL *s;
d129 1
a129 2
void tls1_free(s)
SSL *s;
d134 1
a134 2
void tls1_clear(s)
SSL *s;
d141 1
a141 5
long tls1_ctrl(s,cmd,larg,parg)
SSL *s;
int cmd;
long larg;
char *parg;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d60 1
a60 1
#include <openssl/objects.h>
d63 1
a63 1
const char *tls1_version_str="TLSv1" OPENSSL_VERSION_PTEXT;
d65 1
d67 3
a96 1
	ssl3_renegotiate_check,
a106 3
	ssl_undefined_function,
	ssl3_callback_ctrl,
	ssl3_ctx_callback_ctrl,
d109 1
a109 1
static long tls1_default_timeout(void)
d116 1
a116 1
SSL_METHOD *tlsv1_base_method(void)
d121 2
a122 1
int tls1_new(SSL *s)
d129 2
a130 1
void tls1_free(SSL *s)
d135 2
a136 1
void tls1_clear(SSL *s)
d143 5
a147 6
long tls1_ctrl(SSL *s, int cmd, long larg, char *parg)
	{
	return(0);
	}

long tls1_callback_ctrl(SSL *s, int cmd, void *(*fp)())
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@a60 3
#include <openssl/evp.h>
#include <openssl/hmac.h>
#include <openssl/ocsp.h>
d63 1
a63 1
const char tls1_version_str[]="TLSv1" OPENSSL_VERSION_PTEXT;
d65 1
a65 5
#ifndef OPENSSL_NO_TLSEXT
static int tls_decrypt_ticket(SSL *s, const unsigned char *tick, int ticklen,
				const unsigned char *sess_id, int sesslen,
				SSL_SESSION **psess);
#endif
d67 1
a67 1
SSL3_ENC_METHOD TLSv1_enc_data={
d81 29
a109 1
long tls1_default_timeout(void)
d116 4
a119 4
IMPLEMENT_tls1_meth_func(tlsv1_base_method,
			ssl_undefined_function,
			ssl_undefined_function,
			ssl_bad_method)
a148 748
#endif

#ifndef OPENSSL_NO_TLSEXT
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;

	ret+=2;

	if (ret>=limit) return NULL; /* this really never occurs, but ... */

 	if (s->tlsext_hostname != NULL)
		{ 
		/* Add TLS extension servername to the Client Hello message */
		unsigned long size_str;
		long lenmax; 

		/* check for enough space.
		   4 for the servername type and entension length
		   2 for servernamelist length
		   1 for the hostname type
		   2 for hostname length
		   + hostname length 
		*/
		   
		if ((lenmax = limit - ret - 9) < 0 
		|| (size_str = strlen(s->tlsext_hostname)) > (unsigned long)lenmax) 
			return NULL;
			
		/* extension type and length */
		s2n(TLSEXT_TYPE_server_name,ret); 
		s2n(size_str+5,ret);
		
		/* length of servername list */
		s2n(size_str+3,ret);
	
		/* hostname type, length and hostname */
		*(ret++) = (unsigned char) TLSEXT_NAMETYPE_host_name;
		s2n(size_str,ret);
		memcpy(ret, s->tlsext_hostname, size_str);
		ret+=size_str;

		}

	if (!(SSL_get_options(s) & SSL_OP_NO_TICKET))
		{
		int ticklen;
		if (s->session && s->session->tlsext_tick)
			ticklen = s->session->tlsext_ticklen;
		else
			ticklen = 0;
		/* Check for enough room 2 for extension type, 2 for len
 		 * rest for ticket
  		 */
		if (limit - ret - 4 - ticklen < 0)
			return NULL;
		s2n(TLSEXT_TYPE_session_ticket,ret); 
		s2n(ticklen,ret);
		if (ticklen)
			{
			memcpy(ret, s->session->tlsext_tick, ticklen);
			ret += ticklen;
			}
		}

	if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp)
		{
		int i;
		long extlen, idlen, itmp;
		OCSP_RESPID *id;

		idlen = 0;
		for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++)
			{
			id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);
			itmp = i2d_OCSP_RESPID(id, NULL);
			if (itmp <= 0)
				return NULL;
			idlen += itmp + 2;
			}

		if (s->tlsext_ocsp_exts)
			{
			extlen = i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, NULL);
			if (extlen < 0)
				return NULL;
			}
		else
			extlen = 0;
			
		if ((long)(limit - ret - 7 - extlen - idlen) < 0) return NULL;
		s2n(TLSEXT_TYPE_status_request, ret);
		if (extlen + idlen > 0xFFF0)
			return NULL;
		s2n(extlen + idlen + 5, ret);
		*(ret++) = TLSEXT_STATUSTYPE_ocsp;
		s2n(idlen, ret);
		for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++)
			{
			/* save position of id len */
			unsigned char *q = ret;
			id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);
			/* skip over id len */
			ret += 2;
			itmp = i2d_OCSP_RESPID(id, &ret);
			/* write id len */
			s2n(itmp, q);
			}
		s2n(extlen, ret);
		if (extlen > 0)
			i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret);
		}

	if ((extdatalen = ret-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return ret;
	}

unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;

	ret+=2;
	if (ret>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - ret - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	
	if (s->tlsext_ticket_expected
		&& !(SSL_get_options(s) & SSL_OP_NO_TICKET)) 
		{ 
		if (limit - ret - 4 < 0) return NULL; 
		s2n(TLSEXT_TYPE_session_ticket,ret);
		s2n(0,ret);
		}

	if (s->tlsext_status_expected)
		{ 
		if ((long)(limit - ret - 4) < 0) return NULL; 
		s2n(TLSEXT_TYPE_status_request,ret);
		s2n(0,ret);
		}

	if ((extdatalen = ret-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return ret;
	}

int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)
	{
	unsigned short type;
	unsigned short size;
	unsigned short len;
	unsigned char *data = *p;
	s->servername_done = 0;
	s->tlsext_status_type = -1;

	if (data >= (d+n-2))
		return 1;
	n2s(data,len);

	if (data > (d+n-len)) 
		return 1;

	while (data <= (d+n-4))
		{
		n2s(data,type);
		n2s(data,size);

		if (data+size > (d+n))
	   		return 1;

		if (s->tlsext_debug_cb)
			s->tlsext_debug_cb(s, 0, type, data, size,
						s->tlsext_debug_arg);
/* The servername extension is treated as follows:

   - Only the hostname type is supported with a maximum length of 255.
   - The servername is rejected if too long or if it contains zeros,
     in which case an fatal alert is generated.
   - The servername field is maintained together with the session cache.
   - When a session is resumed, the servername call back invoked in order
     to allow the application to position itself to the right context. 
   - The servername is acknowledged if it is new for a session or when 
     it is identical to a previously used for the same session. 
     Applications can control the behaviour.  They can at any time
     set a 'desirable' servername for a new SSL object. This can be the
     case for example with HTTPS when a Host: header field is received and
     a renegotiation is requested. In this case, a possible servername
     presented in the new client hello is only acknowledged if it matches
     the value of the Host: field. 
   - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
     if they provide for changing an explicit servername context for the session,
     i.e. when the session has been established with a servername extension. 
   - On session reconnect, the servername extension may be absent. 

*/      

		if (type == TLSEXT_TYPE_server_name)
			{
			unsigned char *sdata;
			int servname_type;
			int dsize; 
		
			if (size < 2) 
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			n2s(data,dsize);  
			size -= 2;
			if (dsize > size  ) 
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				} 

			sdata = data;
			while (dsize > 3) 
				{
	 			servname_type = *(sdata++); 
				n2s(sdata,len);
				dsize -= 3;

				if (len > dsize) 
					{
					*al = SSL_AD_DECODE_ERROR;
					return 0;
					}
				if (s->servername_done == 0)
				switch (servname_type)
					{
				case TLSEXT_NAMETYPE_host_name:
					if (s->session->tlsext_hostname == NULL)
						{
						if (len > TLSEXT_MAXLEN_host_name || 
							((s->session->tlsext_hostname = OPENSSL_malloc(len+1)) == NULL))
							{
							*al = TLS1_AD_UNRECOGNIZED_NAME;
							return 0;
							}
						memcpy(s->session->tlsext_hostname, sdata, len);
						s->session->tlsext_hostname[len]='\0';
						if (strlen(s->session->tlsext_hostname) != len) {
							OPENSSL_free(s->session->tlsext_hostname);
							s->session->tlsext_hostname = NULL;
							*al = TLS1_AD_UNRECOGNIZED_NAME;
							return 0;
						}
						s->servername_done = 1; 

						}
					else 
						s->servername_done = strlen(s->session->tlsext_hostname) == len 
							&& strncmp(s->session->tlsext_hostname, (char *)sdata, len) == 0;
					
					break;

				default:
					break;
					}
				 
				dsize -= len;
				}
			if (dsize != 0) 
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}

			}
		else if (type == TLSEXT_TYPE_status_request
						&& s->ctx->tlsext_status_cb)
			{
		
			if (size < 5) 
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}

			s->tlsext_status_type = *data++;
			size--;
			if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp)
				{
				const unsigned char *sdata;
				int dsize;
				/* Read in responder_id_list */
				n2s(data,dsize);
				size -= 2;
				if (dsize > size  ) 
					{
					*al = SSL_AD_DECODE_ERROR;
					return 0;
					}
				while (dsize > 0)
					{
					OCSP_RESPID *id;
					int idsize;
					if (dsize < 4)
						{
						*al = SSL_AD_DECODE_ERROR;
						return 0;
						}
					n2s(data, idsize);
					dsize -= 2 + idsize;
					if (dsize < 0)
						{
						*al = SSL_AD_DECODE_ERROR;
						return 0;
						}
					sdata = data;
					data += idsize;
					id = d2i_OCSP_RESPID(NULL,
								&sdata, idsize);
					if (!id)
						{
						*al = SSL_AD_DECODE_ERROR;
						return 0;
						}
					if (data != sdata)
						{
						OCSP_RESPID_free(id);
						*al = SSL_AD_DECODE_ERROR;
						return 0;
						}
					if (!s->tlsext_ocsp_ids
						&& !(s->tlsext_ocsp_ids =
						sk_OCSP_RESPID_new_null()))
						{
						OCSP_RESPID_free(id);
						*al = SSL_AD_INTERNAL_ERROR;
						return 0;
						}
					if (!sk_OCSP_RESPID_push(
							s->tlsext_ocsp_ids, id))
						{
						OCSP_RESPID_free(id);
						*al = SSL_AD_INTERNAL_ERROR;
						return 0;
						}
					}

				/* Read in request_extensions */
				n2s(data,dsize);
				size -= 2;
				if (dsize > size) 
					{
					*al = SSL_AD_DECODE_ERROR;
					return 0;
					}
				sdata = data;
				if (dsize > 0)
					{
					s->tlsext_ocsp_exts =
						d2i_X509_EXTENSIONS(NULL,
							&sdata, dsize);
					if (!s->tlsext_ocsp_exts
						|| (data + dsize != sdata))
						{
						*al = SSL_AD_DECODE_ERROR;
						return 0;
						}
					}
				}
				/* We don't know what to do with any other type
 			 	* so ignore it.
 			 	*/
				else
					s->tlsext_status_type = -1;
			}
		/* session ticket processed earlier */

		data+=size;		
		}

	*p = data;
	return 1;
	}

int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)
	{
	unsigned short type;
	unsigned short size;
	unsigned short len;  
	unsigned char *data = *p;

	int tlsext_servername = 0;

	if (data >= (d+n-2))
		return 1;

	n2s(data,len);

	while(data <= (d+n-4))
		{
		n2s(data,type);
		n2s(data,size);

		if (data+size > (d+n))
	   		return 1;

		if (s->tlsext_debug_cb)
			s->tlsext_debug_cb(s, 1, type, data, size,
						s->tlsext_debug_arg);

		if (type == TLSEXT_TYPE_server_name)
			{
			if (s->tlsext_hostname == NULL || size > 0)
				{
				*al = TLS1_AD_UNRECOGNIZED_NAME;
				return 0;
				}
			tlsext_servername = 1;   
			}
		else if (type == TLSEXT_TYPE_session_ticket)
			{
			if ((SSL_get_options(s) & SSL_OP_NO_TICKET)
				|| (size > 0))
				{
				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
				return 0;
				}
			s->tlsext_ticket_expected = 1;
			}
		else if (type == TLSEXT_TYPE_status_request)
			{
			/* MUST be empty and only sent if we've requested
			 * a status request message.
			 */ 
			if ((s->tlsext_status_type == -1) || (size > 0))
				{
				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
				return 0;
				}
			/* Set flag to expect CertificateStatus message */
			s->tlsext_status_expected = 1;
			}

		data+=size;		
		}

	if (data != d+n)
		{
		*al = SSL_AD_DECODE_ERROR;
		return 0;
		}

	if (!s->hit && tlsext_servername == 1)
		{
 		if (s->tlsext_hostname)
			{
			if (s->session->tlsext_hostname == NULL)
				{
				s->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);	
				if (!s->session->tlsext_hostname)
					{
					*al = SSL_AD_UNRECOGNIZED_NAME;
					return 0;
					}
				}
			else 
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			}
		}

	*p = data;
	return 1;
	}

int ssl_check_clienthello_tlsext(SSL *s)
	{
	int ret=SSL_TLSEXT_ERR_NOACK;
	int al = SSL_AD_UNRECOGNIZED_NAME;

	if (s->ctx != NULL && s->ctx->tlsext_servername_callback != 0) 
		ret = s->ctx->tlsext_servername_callback(s, &al, s->ctx->tlsext_servername_arg);
	else if (s->initial_ctx != NULL && s->initial_ctx->tlsext_servername_callback != 0) 		
		ret = s->initial_ctx->tlsext_servername_callback(s, &al, s->initial_ctx->tlsext_servername_arg);

	/* If status request then ask callback what to do.
 	 * Note: this must be called after servername callbacks in case 
 	 * the certificate has changed.
 	 */
	if ((s->tlsext_status_type != -1) && s->ctx->tlsext_status_cb)
		{
		int r;
		r = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);
		switch (r)
			{
			/* We don't want to send a status request response */
			case SSL_TLSEXT_ERR_NOACK:
				s->tlsext_status_expected = 0;
				break;
			/* status request response should be sent */
			case SSL_TLSEXT_ERR_OK:
				if (s->tlsext_ocsp_resp)
					s->tlsext_status_expected = 1;
				else
					s->tlsext_status_expected = 0;
				break;
			/* something bad happened */
			case SSL_TLSEXT_ERR_ALERT_FATAL:
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;
				al = SSL_AD_INTERNAL_ERROR;
				goto err;
			}
		}
	else
		s->tlsext_status_expected = 0;
	err:
	switch (ret)
		{
		case SSL_TLSEXT_ERR_ALERT_FATAL:
			ssl3_send_alert(s,SSL3_AL_FATAL,al); 
			return -1;

		case SSL_TLSEXT_ERR_ALERT_WARNING:
			ssl3_send_alert(s,SSL3_AL_WARNING,al);
			return 1; 
					
		case SSL_TLSEXT_ERR_NOACK:
			s->servername_done=0;
			default:
		return 1;
		}
	}

int ssl_check_serverhello_tlsext(SSL *s)
	{
	int ret=SSL_TLSEXT_ERR_NOACK;
	int al = SSL_AD_UNRECOGNIZED_NAME;

	if (s->ctx != NULL && s->ctx->tlsext_servername_callback != 0) 
		ret = s->ctx->tlsext_servername_callback(s, &al, s->ctx->tlsext_servername_arg);
	else if (s->initial_ctx != NULL && s->initial_ctx->tlsext_servername_callback != 0) 		
		ret = s->initial_ctx->tlsext_servername_callback(s, &al, s->initial_ctx->tlsext_servername_arg);

	/* If we've requested certificate status and we wont get one
 	 * tell the callback
 	 */
	if ((s->tlsext_status_type != -1) && !(s->tlsext_status_expected)
			&& s->ctx->tlsext_status_cb)
		{
		int r;
		/* Set resp to NULL, resplen to -1 so callback knows
 		 * there is no response.
 		 */
		if (s->tlsext_ocsp_resp)
			{
			OPENSSL_free(s->tlsext_ocsp_resp);
			s->tlsext_ocsp_resp = NULL;
			}
		s->tlsext_ocsp_resplen = -1;
		r = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);
		if (r == 0)
			{
			al = SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE;
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
			}
		if (r < 0)
			{
			al = SSL_AD_INTERNAL_ERROR;
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
			}
		}

	switch (ret)
		{
		case SSL_TLSEXT_ERR_ALERT_FATAL:
			ssl3_send_alert(s,SSL3_AL_FATAL,al); 
			return -1;

		case SSL_TLSEXT_ERR_ALERT_WARNING:
			ssl3_send_alert(s,SSL3_AL_WARNING,al);
			return 1; 
					
		case SSL_TLSEXT_ERR_NOACK:
			s->servername_done=0;
			default:
		return 1;
		}
	}

/* Since the server cache lookup is done early on in the processing of client
 * hello and other operations depend on the result we need to handle any TLS
 * session ticket extension at the same time.
 */

int tls1_process_ticket(SSL *s, unsigned char *session_id, int len,
				const unsigned char *limit, SSL_SESSION **ret)
	{
	/* Point after session ID in client hello */
	const unsigned char *p = session_id + len;
	unsigned short i;
	if ((s->version <= SSL3_VERSION) || !limit)
		return 1;
	if (p >= limit)
		return -1;
	/* Skip past cipher list */
	n2s(p, i);
	p+= i;
	if (p >= limit)
		return -1;
	/* Skip past compression algorithm list */
	i = *(p++);
	p += i;
	if (p > limit)
		return -1;
	/* Now at start of extensions */
	if ((p + 2) >= limit)
		return 1;
	n2s(p, i);
	while ((p + 4) <= limit)
		{
		unsigned short type, size;
		n2s(p, type);
		n2s(p, size);
		if (p + size > limit)
			return 1;
		if (type == TLSEXT_TYPE_session_ticket)
			{
			/* If tickets disabled indicate cache miss which will
 			 * trigger a full handshake
 			 */
			if (SSL_get_options(s) & SSL_OP_NO_TICKET)
				return 0;
			/* If zero length not client will accept a ticket
 			 * and indicate cache miss to trigger full handshake
 			 */
			if (size == 0)
				{
				s->tlsext_ticket_expected = 1;
				return 0;	/* Cache miss */
				}
			return tls_decrypt_ticket(s, p, size, session_id, len,
									ret);
			}
		p += size;
		}
	return 1;
	}

static int tls_decrypt_ticket(SSL *s, const unsigned char *etick, int eticklen,
				const unsigned char *sess_id, int sesslen,
				SSL_SESSION **psess)
	{
	SSL_SESSION *sess;
	unsigned char *sdec;
	const unsigned char *p;
	int slen, mlen, renew_ticket = 0;
	unsigned char tick_hmac[EVP_MAX_MD_SIZE];
	HMAC_CTX hctx;
	EVP_CIPHER_CTX ctx;
	/* Need at least keyname + iv + some encrypted data */
	if (eticklen < 48)
		goto tickerr;
	/* Initialize session ticket encryption and HMAC contexts */
	HMAC_CTX_init(&hctx);
	EVP_CIPHER_CTX_init(&ctx);
	if (s->ctx->tlsext_ticket_key_cb)
		{
		unsigned char *nctick = (unsigned char *)etick;
		int rv = s->ctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,
							&ctx, &hctx, 0);
		if (rv < 0)
			return -1;
		if (rv == 0)
			goto tickerr;
		if (rv == 2)
			renew_ticket = 1;
		}
	else
		{
		/* Check key name matches */
		if (memcmp(etick, s->ctx->tlsext_tick_key_name, 16))
			goto tickerr;
		HMAC_Init_ex(&hctx, s->ctx->tlsext_tick_hmac_key, 16,
					tlsext_tick_md(), NULL);
		EVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,
				s->ctx->tlsext_tick_aes_key, etick + 16);
		}
	/* Attempt to process session ticket, first conduct sanity and
 	 * integrity checks on ticket.
 	 */
	mlen = HMAC_size(&hctx);
	eticklen -= mlen;
	/* Check HMAC of encrypted ticket */
	HMAC_Update(&hctx, etick, eticklen);
	HMAC_Final(&hctx, tick_hmac, NULL);
	HMAC_CTX_cleanup(&hctx);
	if (memcmp(tick_hmac, etick + eticklen, mlen))
		goto tickerr;
	/* Attempt to decrypt session data */
	/* Move p after IV to start of encrypted ticket, update length */
	p = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);
	eticklen -= 16 + EVP_CIPHER_CTX_iv_length(&ctx);
	sdec = OPENSSL_malloc(eticklen);
	if (!sdec)
		{
		EVP_CIPHER_CTX_cleanup(&ctx);
		return -1;
		}
	EVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen);
	if (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0)
		goto tickerr;
	slen += mlen;
	EVP_CIPHER_CTX_cleanup(&ctx);
	p = sdec;
		
	sess = d2i_SSL_SESSION(NULL, &p, slen);
	OPENSSL_free(sdec);
	if (sess)
		{
		/* The session ID if non-empty is used by some clients to
 		 * detect that the ticket has been accepted. So we copy it to
 		 * the session structure. If it is empty set length to zero
 		 * as required by standard.
 		 */
		if (sesslen)
			memcpy(sess->session_id, sess_id, sesslen);
		sess->session_id_length = sesslen;
		*psess = sess;
		s->tlsext_ticket_expected = renew_ticket;
		return 1;
		}
	/* If session decrypt failure indicate a cache miss and set state to
 	 * send a new ticket
 	 */
	tickerr:	
	s->tlsext_ticket_expected = 1;
	return 0;
	}

@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@a736 7

	/* If tickets disabled behave as if no ticket present
 	 * to permit stateful resumption.
 	 */
	if (SSL_get_options(s) & SSL_OP_NO_TICKET)
		return 1;

d764 6
a769 1
			/* If zero length note client will accept a ticket
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d95 5
a108 6
#ifndef OPENSSL_NO_TLSEXT
	if (s->tlsext_session_ticket)
		{
		OPENSSL_free(s->tlsext_session_ticket);
		}
#endif /* OPENSSL_NO_TLSEXT */
d118 2
a119 2
#ifndef OPENSSL_NO_EC
static int nid_list[] =
d121 1
a121 34
		NID_sect163k1, /* sect163k1 (1) */
		NID_sect163r1, /* sect163r1 (2) */
		NID_sect163r2, /* sect163r2 (3) */
		NID_sect193r1, /* sect193r1 (4) */ 
		NID_sect193r2, /* sect193r2 (5) */ 
		NID_sect233k1, /* sect233k1 (6) */
		NID_sect233r1, /* sect233r1 (7) */ 
		NID_sect239k1, /* sect239k1 (8) */ 
		NID_sect283k1, /* sect283k1 (9) */
		NID_sect283r1, /* sect283r1 (10) */ 
		NID_sect409k1, /* sect409k1 (11) */ 
		NID_sect409r1, /* sect409r1 (12) */
		NID_sect571k1, /* sect571k1 (13) */ 
		NID_sect571r1, /* sect571r1 (14) */ 
		NID_secp160k1, /* secp160k1 (15) */
		NID_secp160r1, /* secp160r1 (16) */ 
		NID_secp160r2, /* secp160r2 (17) */ 
		NID_secp192k1, /* secp192k1 (18) */
		NID_X9_62_prime192v1, /* secp192r1 (19) */ 
		NID_secp224k1, /* secp224k1 (20) */ 
		NID_secp224r1, /* secp224r1 (21) */
		NID_secp256k1, /* secp256k1 (22) */ 
		NID_X9_62_prime256v1, /* secp256r1 (23) */ 
		NID_secp384r1, /* secp384r1 (24) */
		NID_secp521r1  /* secp521r1 (25) */	
	};
	
int tls1_ec_curve_id2nid(int curve_id)
	{
	/* ECC curves from draft-ietf-tls-ecc-12.txt (Oct. 17, 2005) */
	if ((curve_id < 1) || ((unsigned int)curve_id >
				sizeof(nid_list)/sizeof(nid_list[0])))
		return 0;
	return nid_list[curve_id-1];
d124 1
a124 1
int tls1_ec_nid2curve_id(int nid)
d126 1
a126 56
	/* ECC curves from draft-ietf-tls-ecc-12.txt (Oct. 17, 2005) */
	switch (nid)
		{
	case NID_sect163k1: /* sect163k1 (1) */
		return 1;
	case NID_sect163r1: /* sect163r1 (2) */
		return 2;
	case NID_sect163r2: /* sect163r2 (3) */
		return 3;
	case NID_sect193r1: /* sect193r1 (4) */ 
		return 4;
	case NID_sect193r2: /* sect193r2 (5) */ 
		return 5;
	case NID_sect233k1: /* sect233k1 (6) */
		return 6;
	case NID_sect233r1: /* sect233r1 (7) */ 
		return 7;
	case NID_sect239k1: /* sect239k1 (8) */ 
		return 8;
	case NID_sect283k1: /* sect283k1 (9) */
		return 9;
	case NID_sect283r1: /* sect283r1 (10) */ 
		return 10;
	case NID_sect409k1: /* sect409k1 (11) */ 
		return 11;
	case NID_sect409r1: /* sect409r1 (12) */
		return 12;
	case NID_sect571k1: /* sect571k1 (13) */ 
		return 13;
	case NID_sect571r1: /* sect571r1 (14) */ 
		return 14;
	case NID_secp160k1: /* secp160k1 (15) */
		return 15;
	case NID_secp160r1: /* secp160r1 (16) */ 
		return 16;
	case NID_secp160r2: /* secp160r2 (17) */ 
		return 17;
	case NID_secp192k1: /* secp192k1 (18) */
		return 18;
	case NID_X9_62_prime192v1: /* secp192r1 (19) */ 
		return 19;
	case NID_secp224k1: /* secp224k1 (20) */ 
		return 20;
	case NID_secp224r1: /* secp224r1 (21) */
		return 21;
	case NID_secp256k1: /* secp256k1 (22) */ 
		return 22;
	case NID_X9_62_prime256v1: /* secp256r1 (23) */ 
		return 23;
	case NID_secp384r1: /* secp384r1 (24) */
		return 24;
	case NID_secp521r1:  /* secp521r1 (25) */	
		return 25;
	default:
		return 0;
		}
d128 1
a128 1
#endif /* OPENSSL_NO_EC */
a135 5
	/* don't add extensions for SSLv3 unless doing secure renegotiation */
	if (s->client_version == SSL3_VERSION
					&& !s->s3->send_connection_binding)
		return p;

d155 1
a155 1
		    || (size_str = strlen(s->tlsext_hostname)) > (unsigned long)lenmax) 
a169 1
		}
a170 71
        /* Add RI if renegotiating */
        if (s->new_session)
          {
          int el;
          
          if(!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0))
              {
              SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
              return NULL;
              }

          if((limit - p - 4 - el) < 0) return NULL;
          
          s2n(TLSEXT_TYPE_renegotiate,ret);
          s2n(el,ret);

          if(!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el))
              {
              SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
              return NULL;
              }

          ret += el;
        }

#ifndef OPENSSL_NO_EC
	if (s->tlsext_ecpointformatlist != NULL &&
	    s->version != DTLS1_VERSION)
		{
		/* Add TLS extension ECPointFormats to the ClientHello message */
		long lenmax; 

		if ((lenmax = limit - ret - 5) < 0) return NULL; 
		if (s->tlsext_ecpointformatlist_length > (unsigned long)lenmax) return NULL;
		if (s->tlsext_ecpointformatlist_length > 255)
			{
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
			return NULL;
			}
		
		s2n(TLSEXT_TYPE_ec_point_formats,ret);
		s2n(s->tlsext_ecpointformatlist_length + 1,ret);
		*(ret++) = (unsigned char) s->tlsext_ecpointformatlist_length;
		memcpy(ret, s->tlsext_ecpointformatlist, s->tlsext_ecpointformatlist_length);
		ret+=s->tlsext_ecpointformatlist_length;
		}
	if (s->tlsext_ellipticcurvelist != NULL &&
	    s->version != DTLS1_VERSION)
		{
		/* Add TLS extension EllipticCurves to the ClientHello message */
		long lenmax; 

		if ((lenmax = limit - ret - 6) < 0) return NULL; 
		if (s->tlsext_ellipticcurvelist_length > (unsigned long)lenmax) return NULL;
		if (s->tlsext_ellipticcurvelist_length > 65532)
			{
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
			return NULL;
			}
		
		s2n(TLSEXT_TYPE_elliptic_curves,ret);
		s2n(s->tlsext_ellipticcurvelist_length + 2, ret);

		/* NB: draft-ietf-tls-ecc-12.txt uses a one-byte prefix for
		 * elliptic_curve_list, but the examples use two bytes.
		 * http://www1.ietf.org/mail-archive/web/tls/current/msg00538.html
		 * resolves this to two bytes.
		 */
		s2n(s->tlsext_ellipticcurvelist_length, ret);
		memcpy(ret, s->tlsext_ellipticcurvelist, s->tlsext_ellipticcurvelist_length);
		ret+=s->tlsext_ellipticcurvelist_length;
a171 1
#endif /* OPENSSL_NO_EC */
d176 1
a176 1
		if (!s->new_session && s->session && s->session->tlsext_tick)
a177 12
		else if (s->session && s->tlsext_session_ticket &&
			 s->tlsext_session_ticket->data)
			{
			ticklen = s->tlsext_session_ticket->length;
			s->session->tlsext_tick = OPENSSL_malloc(ticklen);
			if (!s->session->tlsext_tick)
				return NULL;
			memcpy(s->session->tlsext_tick,
			       s->tlsext_session_ticket->data,
			       ticklen);
			s->session->tlsext_ticklen = ticklen;
			}
a179 3
		if (ticklen == 0 && s->tlsext_session_ticket &&
		    s->tlsext_session_ticket->data == NULL)
			goto skip_ext;
d183 2
a184 1
		if ((long)(limit - ret - 4 - ticklen) < 0) return NULL;
a192 20
		skip_ext:

#ifdef TLSEXT_TYPE_opaque_prf_input
	if (s->s3->client_opaque_prf_input != NULL &&
	    s->version != DTLS1_VERSION)
		{
		size_t col = s->s3->client_opaque_prf_input_len;
		
		if ((long)(limit - ret - 6 - col < 0))
			return NULL;
		if (col > 0xFFFD) /* can't happen */
			return NULL;

		s2n(TLSEXT_TYPE_opaque_prf_input, ret); 
		s2n(col + 2, ret);
		s2n(col, ret);
		memcpy(ret, s->s3->client_opaque_prf_input, col);
		ret += col;
		}
#endif
d194 1
a194 2
	if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp &&
	    s->version != DTLS1_VERSION)
a253 4
	/* don't add extensions for SSLv3, unless doing secure renegotiation */
	if (s->version == SSL3_VERSION && !s->s3->send_connection_binding)
		return p;
	
d259 1
a259 1
		if ((long)(limit - ret - 4) < 0) return NULL; 
d264 1
a264 50

	if(s->s3->send_connection_binding)
        {
          int el;
          
          if(!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0))
              {
              SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
              return NULL;
              }

          if((limit - p - 4 - el) < 0) return NULL;
          
          s2n(TLSEXT_TYPE_renegotiate,ret);
          s2n(el,ret);

          if(!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el))
              {
              SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
              return NULL;
              }

          ret += el;
        }

#ifndef OPENSSL_NO_EC
	if (s->tlsext_ecpointformatlist != NULL &&
	    s->version != DTLS1_VERSION)
		{
		/* Add TLS extension ECPointFormats to the ServerHello message */
		long lenmax; 

		if ((lenmax = limit - ret - 5) < 0) return NULL; 
		if (s->tlsext_ecpointformatlist_length > (unsigned long)lenmax) return NULL;
		if (s->tlsext_ecpointformatlist_length > 255)
			{
			SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
			return NULL;
			}
		
		s2n(TLSEXT_TYPE_ec_point_formats,ret);
		s2n(s->tlsext_ecpointformatlist_length + 1,ret);
		*(ret++) = (unsigned char) s->tlsext_ecpointformatlist_length;
		memcpy(ret, s->tlsext_ecpointformatlist, s->tlsext_ecpointformatlist_length);
		ret+=s->tlsext_ecpointformatlist_length;

		}
	/* Currently the server should not respond with a SupportedCurves extension */
#endif /* OPENSSL_NO_EC */

d268 1
a268 1
		if ((long)(limit - ret - 4) < 0) return NULL; 
a279 33
#ifdef TLSEXT_TYPE_opaque_prf_input
	if (s->s3->server_opaque_prf_input != NULL &&
	    s->version != DTLS1_VERSION)
		{
		size_t sol = s->s3->server_opaque_prf_input_len;
		
		if ((long)(limit - ret - 6 - sol) < 0)
			return NULL;
		if (sol > 0xFFFD) /* can't happen */
			return NULL;

		s2n(TLSEXT_TYPE_opaque_prf_input, ret); 
		s2n(sol + 2, ret);
		s2n(sol, ret);
		memcpy(ret, s->s3->server_opaque_prf_input, sol);
		ret += sol;
		}
#endif
	if (((s->s3->tmp.new_cipher->id & 0xFFFF)==0x80 || (s->s3->tmp.new_cipher->id & 0xFFFF)==0x81) 
		&& (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG))
		{ const unsigned char cryptopro_ext[36] = {
			0xfd, 0xe8, /*65000*/
			0x00, 0x20, /*32 bytes length*/
			0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85, 
			0x03,   0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06, 
			0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08, 
			0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17};
			if (limit-ret<36) return NULL;
			memcpy(ret,cryptopro_ext,36);
			ret+=36;

		}

a292 2
	int renegotiate_seen = 0;

d297 1
a297 1
		goto ri_check;
d301 1
a301 1
		goto ri_check;
d309 2
a310 4
	   		goto ri_check;
#if 0
		fprintf(stderr,"Received extension type %d size %d\n",type,size);
#endif
d410 2
a411 108

#ifndef OPENSSL_NO_EC
		else if (type == TLSEXT_TYPE_ec_point_formats &&
	             s->version != DTLS1_VERSION)
			{
			unsigned char *sdata = data;
			int ecpointformatlist_length = *(sdata++);

			if (ecpointformatlist_length != size - 1)
				{
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
				}
			s->session->tlsext_ecpointformatlist_length = 0;
			if (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);
			if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)
				{
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
				}
			s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;
			memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);
#if 0
			fprintf(stderr,"ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) ", s->session->tlsext_ecpointformatlist_length);
			sdata = s->session->tlsext_ecpointformatlist;
			for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)
				fprintf(stderr,"%i ",*(sdata++));
			fprintf(stderr,"\n");
#endif
			}
		else if (type == TLSEXT_TYPE_elliptic_curves &&
	             s->version != DTLS1_VERSION)
			{
			unsigned char *sdata = data;
			int ellipticcurvelist_length = (*(sdata++) << 8);
			ellipticcurvelist_length += (*(sdata++));

			if (ellipticcurvelist_length != size - 2)
				{
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
				}
			s->session->tlsext_ellipticcurvelist_length = 0;
			if (s->session->tlsext_ellipticcurvelist != NULL) OPENSSL_free(s->session->tlsext_ellipticcurvelist);
			if ((s->session->tlsext_ellipticcurvelist = OPENSSL_malloc(ellipticcurvelist_length)) == NULL)
				{
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
				}
			s->session->tlsext_ellipticcurvelist_length = ellipticcurvelist_length;
			memcpy(s->session->tlsext_ellipticcurvelist, sdata, ellipticcurvelist_length);
#if 0
			fprintf(stderr,"ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) ", s->session->tlsext_ellipticcurvelist_length);
			sdata = s->session->tlsext_ellipticcurvelist;
			for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++)
				fprintf(stderr,"%i ",*(sdata++));
			fprintf(stderr,"\n");
#endif
			}
#endif /* OPENSSL_NO_EC */
#ifdef TLSEXT_TYPE_opaque_prf_input
		else if (type == TLSEXT_TYPE_opaque_prf_input &&
	             s->version != DTLS1_VERSION)
			{
			unsigned char *sdata = data;

			if (size < 2)
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			n2s(sdata, s->s3->client_opaque_prf_input_len);
			if (s->s3->client_opaque_prf_input_len != size - 2)
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}

			if (s->s3->client_opaque_prf_input != NULL) /* shouldn't really happen */
				OPENSSL_free(s->s3->client_opaque_prf_input);
			if (s->s3->client_opaque_prf_input_len == 0)
				s->s3->client_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */
			else
				s->s3->client_opaque_prf_input = BUF_memdup(sdata, s->s3->client_opaque_prf_input_len);
			if (s->s3->client_opaque_prf_input == NULL)
				{
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
				}
			}
#endif
		else if (type == TLSEXT_TYPE_session_ticket)
			{
			if (s->tls_session_ticket_ext_cb &&
			    !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg))
				{
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
				}
			}
		else if (type == TLSEXT_TYPE_renegotiate)
			{
			if(!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
				return 0;
			renegotiate_seen = 1;
			}
		else if (type == TLSEXT_TYPE_status_request &&
		         s->version != DTLS1_VERSION && s->ctx->tlsext_status_cb)
a509 1

a510 4
		data+=size;
		}
				
	*p = data;
d512 1
a512 11
	ri_check:

	/* Need RI if renegotiating */

	if (!renegotiate_seen && s->new_session &&
		!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
		{
		*al = SSL_AD_HANDSHAKE_FAILURE;
	 	SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT,
				SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
		return 0;
d515 1
d525 1
a526 1
	int renegotiate_seen = 0;
d529 1
a529 1
		goto ri_check;
d539 1
a539 1
	   		goto ri_check;
a553 32

#ifndef OPENSSL_NO_EC
		else if (type == TLSEXT_TYPE_ec_point_formats &&
	             s->version != DTLS1_VERSION)
			{
			unsigned char *sdata = data;
			int ecpointformatlist_length = *(sdata++);

			if (ecpointformatlist_length != size - 1)
				{
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
				}
			s->session->tlsext_ecpointformatlist_length = 0;
			if (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);
			if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)
				{
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
				}
			s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;
			memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);
#if 0
			fprintf(stderr,"ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist ");
			sdata = s->session->tlsext_ecpointformatlist;
			for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)
				fprintf(stderr,"%i ",*(sdata++));
			fprintf(stderr,"\n");
#endif
			}
#endif /* OPENSSL_NO_EC */

a555 6
			if (s->tls_session_ticket_ext_cb &&
			    !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg))
				{
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
				}
d564 1
a564 34
#ifdef TLSEXT_TYPE_opaque_prf_input
		else if (type == TLSEXT_TYPE_opaque_prf_input &&
	             s->version != DTLS1_VERSION)
			{
			unsigned char *sdata = data;

			if (size < 2)
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			n2s(sdata, s->s3->server_opaque_prf_input_len);
			if (s->s3->server_opaque_prf_input_len != size - 2)
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			
			if (s->s3->server_opaque_prf_input != NULL) /* shouldn't really happen */
				OPENSSL_free(s->s3->server_opaque_prf_input);
			if (s->s3->server_opaque_prf_input_len == 0)
				s->s3->server_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */
			else
				s->s3->server_opaque_prf_input = BUF_memdup(sdata, s->s3->server_opaque_prf_input_len);

			if (s->s3->server_opaque_prf_input == NULL)
				{
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
				}
			}
#endif
		else if (type == TLSEXT_TYPE_status_request &&
		         s->version != DTLS1_VERSION)
d577 1
a577 6
		else if (type == TLSEXT_TYPE_renegotiate)
			{
			if(!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))
				return 0;
			renegotiate_seen = 1;
			}
a608 142

	ri_check:

	/* Determine if we need to see RI. Strictly speaking if we want to
	 * avoid an attack we should *always* see RI even on initial server
	 * hello because the client doesn't see any renegotiation during an
	 * attack. However this would mean we could not connect to any server
	 * which doesn't support RI so for the immediate future tolerate RI
	 * absence on initial connect only.
	 */
	if (!renegotiate_seen
		&& !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)
		&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
		{
		*al = SSL_AD_HANDSHAKE_FAILURE;
		SSLerr(SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT,
				SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
		return 0;
		}

	return 1;
	}


int ssl_prepare_clienthello_tlsext(SSL *s)
	{
#ifndef OPENSSL_NO_EC
	/* If we are client and using an elliptic curve cryptography cipher suite, send the point formats 
	 * and elliptic curves we support.
	 */
	int using_ecc = 0;
	int i;
	unsigned char *j;
	unsigned long alg_k, alg_a;
	STACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s);

	for (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++)
		{
		SSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i);

		alg_k = c->algorithm_mkey;
		alg_a = c->algorithm_auth;
		if ((alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe) || (alg_a & SSL_aECDSA)))
			{
			using_ecc = 1;
			break;
			}
		}
	using_ecc = using_ecc && (s->version == TLS1_VERSION);
	if (using_ecc)
		{
		if (s->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->tlsext_ecpointformatlist);
		if ((s->tlsext_ecpointformatlist = OPENSSL_malloc(3)) == NULL)
			{
			SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,ERR_R_MALLOC_FAILURE);
			return -1;
			}
		s->tlsext_ecpointformatlist_length = 3;
		s->tlsext_ecpointformatlist[0] = TLSEXT_ECPOINTFORMAT_uncompressed;
		s->tlsext_ecpointformatlist[1] = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime;
		s->tlsext_ecpointformatlist[2] = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2;

		/* we support all named elliptic curves in draft-ietf-tls-ecc-12 */
		if (s->tlsext_ellipticcurvelist != NULL) OPENSSL_free(s->tlsext_ellipticcurvelist);
		s->tlsext_ellipticcurvelist_length = sizeof(nid_list)/sizeof(nid_list[0]) * 2;
		if ((s->tlsext_ellipticcurvelist = OPENSSL_malloc(s->tlsext_ellipticcurvelist_length)) == NULL)
			{
			s->tlsext_ellipticcurvelist_length = 0;
			SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,ERR_R_MALLOC_FAILURE);
			return -1;
			}
		for (i = 1, j = s->tlsext_ellipticcurvelist; (unsigned int)i <=
				sizeof(nid_list)/sizeof(nid_list[0]); i++)
			s2n(i,j);
		}
#endif /* OPENSSL_NO_EC */

#ifdef TLSEXT_TYPE_opaque_prf_input
 	{
		int r = 1;
	
		if (s->ctx->tlsext_opaque_prf_input_callback != 0)
			{
			r = s->ctx->tlsext_opaque_prf_input_callback(s, NULL, 0, s->ctx->tlsext_opaque_prf_input_callback_arg);
			if (!r)
				return -1;
			}

		if (s->tlsext_opaque_prf_input != NULL)
			{
			if (s->s3->client_opaque_prf_input != NULL) /* shouldn't really happen */
				OPENSSL_free(s->s3->client_opaque_prf_input);

			if (s->tlsext_opaque_prf_input_len == 0)
				s->s3->client_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */
			else
				s->s3->client_opaque_prf_input = BUF_memdup(s->tlsext_opaque_prf_input, s->tlsext_opaque_prf_input_len);
			if (s->s3->client_opaque_prf_input == NULL)
				{
				SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,ERR_R_MALLOC_FAILURE);
				return -1;
				}
			s->s3->client_opaque_prf_input_len = s->tlsext_opaque_prf_input_len;
			}

		if (r == 2)
			/* at callback's request, insist on receiving an appropriate server opaque PRF input */
			s->s3->server_opaque_prf_input_len = s->tlsext_opaque_prf_input_len;
	}
#endif

	return 1;
	}

int ssl_prepare_serverhello_tlsext(SSL *s)
	{
#ifndef OPENSSL_NO_EC
	/* If we are server and using an ECC cipher suite, send the point formats we support 
	 * if the client sent us an ECPointsFormat extension.  Note that the server is not
	 * supposed to send an EllipticCurves extension.
	 */

	unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;
	int using_ecc = (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) || (alg_a & SSL_aECDSA);
	using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);
	
	if (using_ecc)
		{
		if (s->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->tlsext_ecpointformatlist);
		if ((s->tlsext_ecpointformatlist = OPENSSL_malloc(3)) == NULL)
			{
			SSLerr(SSL_F_SSL_PREPARE_SERVERHELLO_TLSEXT,ERR_R_MALLOC_FAILURE);
			return -1;
			}
		s->tlsext_ecpointformatlist_length = 3;
		s->tlsext_ecpointformatlist[0] = TLSEXT_ECPOINTFORMAT_uncompressed;
		s->tlsext_ecpointformatlist[1] = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime;
		s->tlsext_ecpointformatlist[2] = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2;
		}
#endif /* OPENSSL_NO_EC */

a616 9
#ifndef OPENSSL_NO_EC
	/* The handling of the ECPointFormats extension is done elsewhere, namely in 
	 * ssl3_choose_cipher in s3_lib.c.
	 */
	/* The handling of the EllipticCurves extension is done elsewhere, namely in 
	 * ssl3_choose_cipher in s3_lib.c.
	 */
#endif

d626 1
a626 1
	if ((s->tlsext_status_type != -1) && s->ctx && s->ctx->tlsext_status_cb)
d652 1
a652 59

#ifdef TLSEXT_TYPE_opaque_prf_input
 	{
		/* This sort of belongs into ssl_prepare_serverhello_tlsext(),
		 * but we might be sending an alert in response to the client hello,
		 * so this has to happen here in ssl_check_clienthello_tlsext(). */

		int r = 1;
	
		if (s->ctx->tlsext_opaque_prf_input_callback != 0)
			{
			r = s->ctx->tlsext_opaque_prf_input_callback(s, NULL, 0, s->ctx->tlsext_opaque_prf_input_callback_arg);
			if (!r)
				{
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;
				al = SSL_AD_INTERNAL_ERROR;
				goto err;
				}
			}

		if (s->s3->server_opaque_prf_input != NULL) /* shouldn't really happen */
			OPENSSL_free(s->s3->server_opaque_prf_input);
		s->s3->server_opaque_prf_input = NULL;

		if (s->tlsext_opaque_prf_input != NULL)
			{
			if (s->s3->client_opaque_prf_input != NULL &&
				s->s3->client_opaque_prf_input_len == s->tlsext_opaque_prf_input_len)
				{
				/* can only use this extension if we have a server opaque PRF input
				 * of the same length as the client opaque PRF input! */

				if (s->tlsext_opaque_prf_input_len == 0)
					s->s3->server_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte just to get non-NULL */
				else
					s->s3->server_opaque_prf_input = BUF_memdup(s->tlsext_opaque_prf_input, s->tlsext_opaque_prf_input_len);
				if (s->s3->server_opaque_prf_input == NULL)
					{
					ret = SSL_TLSEXT_ERR_ALERT_FATAL;
					al = SSL_AD_INTERNAL_ERROR;
					goto err;
					}
				s->s3->server_opaque_prf_input_len = s->tlsext_opaque_prf_input_len;
				}
			}

		if (r == 2 && s->s3->server_opaque_prf_input == NULL)
			{
			/* The callback wants to enforce use of the extension,
			 * but we can't do that with the client opaque PRF input;
			 * abort the handshake.
			 */
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
			al = SSL_AD_HANDSHAKE_FAILURE;
			}
	}

#endif
 err:
a674 36
#ifndef OPENSSL_NO_EC
	/* If we are client and using an elliptic curve cryptography cipher suite, then server
	 * must return a an EC point formats lists containing uncompressed.
	 */
	unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;
	if ((s->tlsext_ecpointformatlist != NULL) && (s->tlsext_ecpointformatlist_length > 0) && 
	    ((alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) || (alg_a & SSL_aECDSA)))
		{
		/* we are using an ECC cipher */
		size_t i;
		unsigned char *list;
		int found_uncompressed = 0;
		if ((s->session->tlsext_ecpointformatlist == NULL) || (s->session->tlsext_ecpointformatlist_length == 0))
			{
			SSLerr(SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT,SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);
			return -1;
			}
		list = s->session->tlsext_ecpointformatlist;
		for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)
			{
			if (*(list++) == TLSEXT_ECPOINTFORMAT_uncompressed)
				{
				found_uncompressed = 1;
				break;
				}
			}
		if (!found_uncompressed)
			{
			SSLerr(SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT,SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);
			return -1;
			}
		}
	ret = SSL_TLSEXT_ERR_OK;
#endif /* OPENSSL_NO_EC */

a679 23
#ifdef TLSEXT_TYPE_opaque_prf_input
	if (s->s3->server_opaque_prf_input_len > 0)
		{
		/* This case may indicate that we, as a client, want to insist on using opaque PRF inputs.
		 * So first verify that we really have a value from the server too. */

		if (s->s3->server_opaque_prf_input == NULL)
			{
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
			al = SSL_AD_HANDSHAKE_FAILURE;
			}
		
		/* Anytime the server *has* sent an opaque PRF input, we need to check
		 * that we have a client opaque PRF input of the same size. */
		if (s->s3->client_opaque_prf_input == NULL ||
		    s->s3->client_opaque_prf_input_len != s->s3->server_opaque_prf_input_len)
			{
			ret = SSL_TLSEXT_ERR_ALERT_FATAL;
			al = SSL_AD_ILLEGAL_PARAMETER;
			}
		}
#endif

d684 1
a684 1
			&& s->ctx && s->ctx->tlsext_status_cb)
a747 8
	/* Skip past DTLS cookie */
	if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)
		{
		i = *(p++);
		p+= i;
		if (p >= limit)
			return -1;
		}
a770 5
			/* If tickets disabled indicate cache miss which will
 			 * trigger a full handshake
 			 */
			if (SSL_get_options(s) & SSL_OP_NO_TICKET)
				return 1;
a778 9
			if (s->tls_session_secret_cb)
				{
				/* Indicate cache miss here and instead of
				 * generating the session from ticket now,
				 * trigger abbreviated handshake based on
				 * external mechanism to calculate the master
				 * secret later. */
				return 0;
				}
a797 1
	SSL_CTX *tctx = s->initial_ctx;
d804 1
a804 1
	if (tctx->tlsext_ticket_key_cb)
d807 1
a807 1
		int rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,
d819 1
a819 1
		if (memcmp(etick, tctx->tlsext_tick_key_name, 16))
d821 1
a821 1
		HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
d824 1
a824 1
				tctx->tlsext_tick_aes_key, etick + 16);
a829 5
	if (mlen < 0)
		{
		EVP_CIPHER_CTX_cleanup(&ctx);
		return -1;
		}
@


1.1.1.6
log
@import OpenSSL 1.0.0e
@
text
@d717 1
a717 1
					if (!s->hit)
d719 2
a720 6
						if(s->session->tlsext_hostname)
							{
							*al = SSL_AD_DECODE_ERROR;
							return 0;
							}
						if (len > TLSEXT_MAXLEN_host_name)
a724 5
						if ((s->session->tlsext_hostname = OPENSSL_malloc(len+1)) == NULL)
							{
							*al = TLS1_AD_INTERNAL_ERROR;
							return 0;
							}
d737 1
a737 2
						s->servername_done = s->session->tlsext_hostname
							&& strlen(s->session->tlsext_hostname) == len 
d768 3
a770 1
			if (!s->hit)
d772 2
a773 13
				if(s->session->tlsext_ecpointformatlist)
					{
					OPENSSL_free(s->session->tlsext_ecpointformatlist);
					s->session->tlsext_ecpointformatlist = NULL;
					}
				s->session->tlsext_ecpointformatlist_length = 0;
				if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)
					{
					*al = TLS1_AD_INTERNAL_ERROR;
					return 0;
					}
				s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;
				memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);
d775 2
d797 3
a799 1
			if (!s->hit)
d801 2
a802 13
				if(s->session->tlsext_ellipticcurvelist)
					{
					*al = TLS1_AD_DECODE_ERROR;
					return 0;
					}
				s->session->tlsext_ellipticcurvelist_length = 0;
				if ((s->session->tlsext_ellipticcurvelist = OPENSSL_malloc(ellipticcurvelist_length)) == NULL)
					{
					*al = TLS1_AD_INTERNAL_ERROR;
					return 0;
					}
				s->session->tlsext_ellipticcurvelist_length = ellipticcurvelist_length;
				memcpy(s->session->tlsext_ellipticcurvelist, sdata, ellipticcurvelist_length);
d804 2
a895 1
					size -= 2 + idsize;
a933 5
				if (size < 2)
					{
					*al = SSL_AD_DECODE_ERROR;
					return 0;
					}
d936 1
a936 1
				if (dsize != size)
a985 1
	unsigned short length;
d988 1
d996 1
a996 6
	n2s(data,length);
	if (data+length != d+n)
		{
		*al = SSL_AD_DECODE_ERROR;
		return 0;
		}
d1426 2
a1427 3
	/* If we are client and using an elliptic curve cryptography cipher
	 * suite, then if server returns an EC point formats lists extension
	 * it must contain uncompressed.
a1431 1
	    (s->session->tlsext_ecpointformatlist != NULL) && (s->session->tlsext_ecpointformatlist_length > 0) && 
d1438 5
@


1.1.1.7
log
@OpenSSL 1.0.0f: import upstream source
@
text
@a973 6
					if (s->tlsext_ocsp_exts)
						{
						sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,
									   X509_EXTENSION_free);
						}

@


1.1.1.8
log
@import OpenSSL-1.0.1c
@
text
@a116 1
#include <openssl/rand.h>
a138 1
	tls1_export_keying_material,
d169 1
a169 1
	s->version = s->method->version;
a172 1

d201 1
a201 30

static int pref_list[] =
	{
		NID_sect571r1, /* sect571r1 (14) */ 
		NID_sect571k1, /* sect571k1 (13) */ 
		NID_secp521r1, /* secp521r1 (25) */	
		NID_sect409k1, /* sect409k1 (11) */ 
		NID_sect409r1, /* sect409r1 (12) */
		NID_secp384r1, /* secp384r1 (24) */
		NID_sect283k1, /* sect283k1 (9) */
		NID_sect283r1, /* sect283r1 (10) */ 
		NID_secp256k1, /* secp256k1 (22) */ 
		NID_X9_62_prime256v1, /* secp256r1 (23) */ 
		NID_sect239k1, /* sect239k1 (8) */ 
		NID_sect233k1, /* sect233k1 (6) */
		NID_sect233r1, /* sect233r1 (7) */ 
		NID_secp224k1, /* secp224k1 (20) */ 
		NID_secp224r1, /* secp224r1 (21) */
		NID_sect193r1, /* sect193r1 (4) */ 
		NID_sect193r2, /* sect193r2 (5) */ 
		NID_secp192k1, /* secp192k1 (18) */
		NID_X9_62_prime192v1, /* secp192r1 (19) */ 
		NID_sect163k1, /* sect163k1 (1) */
		NID_sect163r1, /* sect163r1 (2) */
		NID_sect163r2, /* sect163r2 (3) */
		NID_secp160k1, /* secp160k1 (15) */
		NID_secp160r1, /* secp160r1 (16) */ 
		NID_secp160r2, /* secp160r2 (17) */ 
	};

a272 58

/* List of supported signature algorithms and hashes. Should make this
 * customisable at some point, for now include everything we support.
 */

#ifdef OPENSSL_NO_RSA
#define tlsext_sigalg_rsa(md) /* */
#else
#define tlsext_sigalg_rsa(md) md, TLSEXT_signature_rsa,
#endif

#ifdef OPENSSL_NO_DSA
#define tlsext_sigalg_dsa(md) /* */
#else
#define tlsext_sigalg_dsa(md) md, TLSEXT_signature_dsa,
#endif

#ifdef OPENSSL_NO_ECDSA
#define tlsext_sigalg_ecdsa(md) /* */
#else
#define tlsext_sigalg_ecdsa(md) md, TLSEXT_signature_ecdsa,
#endif

#define tlsext_sigalg(md) \
		tlsext_sigalg_rsa(md) \
		tlsext_sigalg_dsa(md) \
		tlsext_sigalg_ecdsa(md)

static unsigned char tls12_sigalgs[] = {
#ifndef OPENSSL_NO_SHA512
	tlsext_sigalg(TLSEXT_hash_sha512)
	tlsext_sigalg(TLSEXT_hash_sha384)
#endif
#ifndef OPENSSL_NO_SHA256
	tlsext_sigalg(TLSEXT_hash_sha256)
	tlsext_sigalg(TLSEXT_hash_sha224)
#endif
#ifndef OPENSSL_NO_SHA
	tlsext_sigalg(TLSEXT_hash_sha1)
#endif
#ifndef OPENSSL_NO_MD5
	tlsext_sigalg_rsa(TLSEXT_hash_md5)
#endif
};

int tls12_get_req_sig_algs(SSL *s, unsigned char *p)
	{
	size_t slen = sizeof(tls12_sigalgs);
#ifdef OPENSSL_FIPS
	/* If FIPS mode don't include MD5 which is last */
	if (FIPS_mode())
		slen -= 2;
#endif
	if (p)
		memcpy(p, tls12_sigalgs, slen);
	return (int)slen;
	}

d320 1
a320 1
        if (s->renegotiate)
a343 28
#ifndef OPENSSL_NO_SRP
	/* Add SRP username if there is one */
	if (s->srp_ctx.login != NULL)
		{ /* Add TLS extension SRP username to the Client Hello message */

		int login_len = strlen(s->srp_ctx.login);	
		if (login_len > 255 || login_len == 0)
			{
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
			return NULL;
			} 

		/* check for enough space.
		   4 for the srp type type and entension length
		   1 for the srp user identity
		   + srp user identity length 
		*/
		if ((limit - ret - 5 - login_len) < 0) return NULL; 

		/* fill in the extension */
		s2n(TLSEXT_TYPE_srp,ret);
		s2n(login_len+1,ret);
		(*ret++) = (unsigned char) login_len;
		memcpy(ret, s->srp_ctx.login, login_len);
		ret+=login_len;
		}
#endif

a428 11
	if (TLS1_get_client_version(s) >= TLS1_2_VERSION)
		{
		if ((size_t)(limit - ret) < sizeof(tls12_sigalgs) + 6)
			return NULL; 
		s2n(TLSEXT_TYPE_signature_algorithms,ret);
		s2n(sizeof(tls12_sigalgs) + 2, ret);
		s2n(sizeof(tls12_sigalgs), ret);
		memcpy(ret, tls12_sigalgs, sizeof(tls12_sigalgs));
		ret += sizeof(tls12_sigalgs);
		}

a496 45
#ifndef OPENSSL_NO_HEARTBEATS
	/* Add Heartbeat extension */
	s2n(TLSEXT_TYPE_heartbeat,ret);
	s2n(1,ret);
	/* Set mode:
	 * 1: peer may send requests
	 * 2: peer not allowed to send requests
	 */
	if (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)
		*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
	else
		*(ret++) = SSL_TLSEXT_HB_ENABLED;
#endif

#ifndef OPENSSL_NO_NEXTPROTONEG
	if (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len)
		{
		/* The client advertises an emtpy extension to indicate its
		 * support for Next Protocol Negotiation */
		if (limit - ret - 4 < 0)
			return NULL;
		s2n(TLSEXT_TYPE_next_proto_neg,ret);
		s2n(0,ret);
		}
#endif

        if(SSL_get_srtp_profiles(s))
                {
                int el;

                ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0);
                
                if((limit - p - 4 - el) < 0) return NULL;

                s2n(TLSEXT_TYPE_use_srtp,ret);
                s2n(el,ret);

                if(ssl_add_clienthello_use_srtp_ext(s, ret, &el, el))
			{
			SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
			return NULL;
			}
                ret += el;
                }

a507 3
#ifndef OPENSSL_NO_NEXTPROTONEG
	int next_proto_neg_seen;
#endif
a605 20

        if(s->srtp_profile)
                {
                int el;

                ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0);
                
                if((limit - p - 4 - el) < 0) return NULL;

                s2n(TLSEXT_TYPE_use_srtp,ret);
                s2n(el,ret);

                if(ssl_add_serverhello_use_srtp_ext(s, ret, &el, el))
			{
			SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
			return NULL;
			}
                ret+=el;
                }

a620 40
#ifndef OPENSSL_NO_HEARTBEATS
	/* Add Heartbeat extension if we've received one */
	if (s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED)
		{
		s2n(TLSEXT_TYPE_heartbeat,ret);
		s2n(1,ret);
		/* Set mode:
		 * 1: peer may send requests
		 * 2: peer not allowed to send requests
		 */
		if (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)
			*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
		else
			*(ret++) = SSL_TLSEXT_HB_ENABLED;

		}
#endif

#ifndef OPENSSL_NO_NEXTPROTONEG
	next_proto_neg_seen = s->s3->next_proto_neg_seen;
	s->s3->next_proto_neg_seen = 0;
	if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb)
		{
		const unsigned char *npa;
		unsigned int npalen;
		int r;

		r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen, s->ctx->next_protos_advertised_cb_arg);
		if (r == SSL_TLSEXT_ERR_OK)
			{
			if ((long)(limit - ret - 4 - npalen) < 0) return NULL;
			s2n(TLSEXT_TYPE_next_proto_neg,ret);
			s2n(npalen,ret);
			memcpy(ret, npa, npalen);
			ret += npalen;
			s->s3->next_proto_neg_seen = 1;
			}
		}
#endif

a634 1
	int sigalg_seen = 0;
a637 8
#ifndef OPENSSL_NO_NEXTPROTONEG
	s->s3->next_proto_neg_seen = 0;
#endif

#ifndef OPENSSL_NO_HEARTBEATS
	s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |
	                       SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
#endif
a764 25
#ifndef OPENSSL_NO_SRP
		else if (type == TLSEXT_TYPE_srp)
			{
			if (size <= 0 || ((len = data[0])) != (size -1))
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			if (s->srp_ctx.login != NULL)
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			if ((s->srp_ctx.login = OPENSSL_malloc(len+1)) == NULL)
				return -1;
			memcpy(s->srp_ctx.login, &data[1], len);
			s->srp_ctx.login[len]='\0';
  
			if (strlen(s->srp_ctx.login) != len) 
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			}
#endif
a884 22
		else if (type == TLSEXT_TYPE_signature_algorithms)
			{
			int dsize;
			if (sigalg_seen || size < 2) 
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			sigalg_seen = 1;
			n2s(data,dsize);
			size -= 2;
			if (dsize != size || dsize & 1) 
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			if (!tls1_process_sigalgs(s, data, dsize))
				{
				*al = SSL_AD_DECODE_ERROR;
				return 0;
				}
			}
a996 39
#ifndef OPENSSL_NO_HEARTBEATS
		else if (type == TLSEXT_TYPE_heartbeat)
			{
			switch(data[0])
				{
				case 0x01:	/* Client allows us to send HB requests */
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
							break;
				case 0x02:	/* Client doesn't accept HB requests */
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
							break;
				default:	*al = SSL_AD_ILLEGAL_PARAMETER;
							return 0;
				}
			}
#endif
#ifndef OPENSSL_NO_NEXTPROTONEG
		else if (type == TLSEXT_TYPE_next_proto_neg &&
			 s->s3->tmp.finish_md_len == 0)
			{
			/* We shouldn't accept this extension on a
			 * renegotiation.
			 *
			 * s->new_session will be set on renegotiation, but we
			 * probably shouldn't rely that it couldn't be set on
			 * the initial renegotation too in certain cases (when
			 * there's some other reason to disallow resuming an
			 * earlier session -- the current code won't be doing
			 * anything like that, but this might change).

			 * A valid sign that there's been a previous handshake
			 * in this connection is if s->s3->tmp.finish_md_len >
			 * 0.  (We are talking about a check that will happen
			 * in the Hello protocol round, well before a new
			 * Finished message could have been computed.) */
			s->s3->next_proto_neg_seen = 1;
			}
#endif
a998 7
		else if (type == TLSEXT_TYPE_use_srtp)
                        {
			if(ssl_parse_clienthello_use_srtp_ext(s, data, size,
							      al))
				return 0;
                        }

d1008 1
a1008 1
	if (!renegotiate_seen && s->renegotiate &&
a1019 20
#ifndef OPENSSL_NO_NEXTPROTONEG
/* ssl_next_proto_validate validates a Next Protocol Negotiation block. No
 * elements of zero length are allowed and the set of elements must exactly fill
 * the length of the block. */
static char ssl_next_proto_validate(unsigned char *d, unsigned len)
	{
	unsigned int off = 0;

	while (off < len)
		{
		if (d[off] == 0)
			return 0;
		off += d[off];
		off++;
		}

	return off == len;
	}
#endif

a1028 9
#ifndef OPENSSL_NO_NEXTPROTONEG
	s->s3->next_proto_neg_seen = 0;
#endif

#ifndef OPENSSL_NO_HEARTBEATS
	s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |
	                       SSL_TLSEXT_HB_DONT_SEND_REQUESTS);
#endif

a1153 35
#ifndef OPENSSL_NO_NEXTPROTONEG
		else if (type == TLSEXT_TYPE_next_proto_neg &&
			 s->s3->tmp.finish_md_len == 0)
			{
			unsigned char *selected;
			unsigned char selected_len;

			/* We must have requested it. */
			if ((s->ctx->next_proto_select_cb == NULL))
				{
				*al = TLS1_AD_UNSUPPORTED_EXTENSION;
				return 0;
				}
			/* The data must be valid */
			if (!ssl_next_proto_validate(data, size))
				{
				*al = TLS1_AD_DECODE_ERROR;
				return 0;
				}
			if (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data, size, s->ctx->next_proto_select_cb_arg) != SSL_TLSEXT_ERR_OK)
				{
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
				}
			s->next_proto_negotiated = OPENSSL_malloc(selected_len);
			if (!s->next_proto_negotiated)
				{
				*al = TLS1_AD_INTERNAL_ERROR;
				return 0;
				}
			memcpy(s->next_proto_negotiated, selected, selected_len);
			s->next_proto_negotiated_len = selected_len;
			s->s3->next_proto_neg_seen = 1;
			}
#endif
a1159 24
#ifndef OPENSSL_NO_HEARTBEATS
		else if (type == TLSEXT_TYPE_heartbeat)
			{
			switch(data[0])
				{
				case 0x01:	/* Server allows us to send HB requests */
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
							break;
				case 0x02:	/* Server doesn't accept HB requests */
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;
							s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
							break;
				default:	*al = SSL_AD_ILLEGAL_PARAMETER;
							return 0;
				}
			}
#endif
		else if (type == TLSEXT_TYPE_use_srtp)
                        {
                        if(ssl_parse_serverhello_use_srtp_ext(s, data, size,
							      al))
                                return 0;
                        }

d1239 1
a1239 1
	using_ecc = using_ecc && (s->version >= TLS1_VERSION);
d1255 1
a1255 1
		s->tlsext_ellipticcurvelist_length = sizeof(pref_list)/sizeof(pref_list[0]) * 2;
d1262 3
a1264 6
		for (i = 0, j = s->tlsext_ellipticcurvelist; (unsigned int)i <
				sizeof(pref_list)/sizeof(pref_list[0]); i++)
			{
			int id = tls1_ec_nid2curve_id(pref_list[i]);
			s2n(id,j);
			}
d1573 3
a1575 32
/* Since the server cache lookup is done early on in the processing of the
 * ClientHello, and other operations depend on the result, we need to handle
 * any TLS session ticket extension at the same time.
 *
 *   session_id: points at the session ID in the ClientHello. This code will
 *       read past the end of this in order to parse out the session ticket
 *       extension, if any.
 *   len: the length of the session ID.
 *   limit: a pointer to the first byte after the ClientHello.
 *   ret: (output) on return, if a ticket was decrypted, then this is set to
 *       point to the resulting session.
 *
 * If s->tls_session_secret_cb is set then we are expecting a pre-shared key
 * ciphersuite, in which case we have no use for session tickets and one will
 * never be decrypted, nor will s->tlsext_ticket_expected be set to 1.
 *
 * Returns:
 *   -1: fatal error, either from parsing or decrypting the ticket.
 *    0: no ticket was found (or was ignored, based on settings).
 *    1: a zero length extension was found, indicating that the client supports
 *       session tickets but doesn't currently have one to offer.
 *    2: either s->tls_session_secret_cb was set, or a ticket was offered but
 *       couldn't be decrypted because of a non-fatal error.
 *    3: a ticket was successfully decrypted and *ret was set.
 *
 * Side effects:
 *   Sets s->tlsext_ticket_expected to 1 if the server will have to issue
 *   a new session ticket to the client because the client indicated support
 *   (and s->tls_session_secret_cb is NULL) but the client either doesn't have
 *   a session ticket or we couldn't use the one it gave us, or if
 *   s->ctx->tlsext_ticket_key_cb asked to renew the client's ticket.
 *   Otherwise, s->tlsext_ticket_expected is set to 0.
d1577 1
d1579 1
a1579 1
			const unsigned char *limit, SSL_SESSION **ret)
a1584 3
	*ret = NULL;
	s->tlsext_ticket_expected = 0;

d1586 2
a1587 2
	 * to permit stateful resumption.
	 */
d1589 2
a1590 1
		return 0;
d1592 1
a1592 1
		return 0;
d1615 1
a1615 1
		return 0;
d1623 1
a1623 1
			return 0;
d1626 8
a1633 1
			int r;
a1635 2
				/* The client will accept a ticket but doesn't
				 * currently have one. */
d1637 1
a1637 1
				return 1;
d1641 6
a1646 20
				/* Indicate that the ticket couldn't be
				 * decrypted rather than generating the session
				 * from ticket now, trigger abbreviated
				 * handshake based on external mechanism to
				 * calculate the master secret later. */
				return 2;
				}
			r = tls_decrypt_ticket(s, p, size, session_id, len, ret);
			switch (r)
				{
				case 2: /* ticket couldn't be decrypted */
					s->tlsext_ticket_expected = 1;
					return 2;
				case 3: /* ticket was decrypted */
					return r;
				case 4: /* ticket decrypted but need to renew */
					s->tlsext_ticket_expected = 1;
					return 3;
				default: /* fatal error */
					return -1;
d1648 2
d1653 1
a1653 1
	return 0;
a1655 15
/* tls_decrypt_ticket attempts to decrypt a session ticket.
 *
 *   etick: points to the body of the session ticket extension.
 *   eticklen: the length of the session tickets extenion.
 *   sess_id: points at the session ID.
 *   sesslen: the length of the session ID.
 *   psess: (output) on return, if a ticket was decrypted, then this is set to
 *       point to the resulting session.
 *
 * Returns:
 *   -1: fatal error, either from parsing or decrypting the ticket.
 *    2: the ticket couldn't be decrypted.
 *    3: a ticket was successfully decrypted and *psess was set.
 *    4: same as 3, but the ticket needs to be renewed.
 */
d1670 1
a1670 1
		return 2;
d1682 1
a1682 1
			return 2;
d1690 1
a1690 1
			return 2;
d1697 2
a1698 2
	 * integrity checks on ticket.
	 */
d1711 1
a1711 1
		return 2;
d1724 1
a1724 1
		return 2;
d1728 1
a1728 1

d1733 5
a1737 5
		/* The session ID, if non-empty, is used by some clients to
		 * detect that the ticket has been accepted. So we copy it to
		 * the session structure. If it is empty set length to zero
		 * as required by standard.
		 */
d1742 1
a1742 139
		if (renew_ticket)
			return 4;
		else
			return 3;
		}
        ERR_clear_error();
	/* For session parse failure, indicate that we need to send a new
	 * ticket. */
	return 2;
	}

/* Tables to translate from NIDs to TLS v1.2 ids */

typedef struct 
	{
	int nid;
	int id;
	} tls12_lookup;

static tls12_lookup tls12_md[] = {
#ifndef OPENSSL_NO_MD5
	{NID_md5, TLSEXT_hash_md5},
#endif
#ifndef OPENSSL_NO_SHA
	{NID_sha1, TLSEXT_hash_sha1},
#endif
#ifndef OPENSSL_NO_SHA256
	{NID_sha224, TLSEXT_hash_sha224},
	{NID_sha256, TLSEXT_hash_sha256},
#endif
#ifndef OPENSSL_NO_SHA512
	{NID_sha384, TLSEXT_hash_sha384},
	{NID_sha512, TLSEXT_hash_sha512}
#endif
};

static tls12_lookup tls12_sig[] = {
#ifndef OPENSSL_NO_RSA
	{EVP_PKEY_RSA, TLSEXT_signature_rsa},
#endif
#ifndef OPENSSL_NO_DSA
	{EVP_PKEY_DSA, TLSEXT_signature_dsa},
#endif
#ifndef OPENSSL_NO_ECDSA
	{EVP_PKEY_EC, TLSEXT_signature_ecdsa}
#endif
};

static int tls12_find_id(int nid, tls12_lookup *table, size_t tlen)
	{
	size_t i;
	for (i = 0; i < tlen; i++)
		{
		if (table[i].nid == nid)
			return table[i].id;
		}
	return -1;
	}
#if 0
static int tls12_find_nid(int id, tls12_lookup *table, size_t tlen)
	{
	size_t i;
	for (i = 0; i < tlen; i++)
		{
		if (table[i].id == id)
			return table[i].nid;
		}
	return -1;
	}
#endif

int tls12_get_sigandhash(unsigned char *p, const EVP_PKEY *pk, const EVP_MD *md)
	{
	int sig_id, md_id;
	if (!md)
		return 0;
	md_id = tls12_find_id(EVP_MD_type(md), tls12_md,
				sizeof(tls12_md)/sizeof(tls12_lookup));
	if (md_id == -1)
		return 0;
	sig_id = tls12_get_sigid(pk);
	if (sig_id == -1)
		return 0;
	p[0] = (unsigned char)md_id;
	p[1] = (unsigned char)sig_id;
	return 1;
	}

int tls12_get_sigid(const EVP_PKEY *pk)
	{
	return tls12_find_id(pk->type, tls12_sig,
				sizeof(tls12_sig)/sizeof(tls12_lookup));
	}

const EVP_MD *tls12_get_hash(unsigned char hash_alg)
	{
	switch(hash_alg)
		{
#ifndef OPENSSL_NO_MD5
		case TLSEXT_hash_md5:
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			return NULL;
#endif
		return EVP_md5();
#endif
#ifndef OPENSSL_NO_SHA
		case TLSEXT_hash_sha1:
		return EVP_sha1();
#endif
#ifndef OPENSSL_NO_SHA256
		case TLSEXT_hash_sha224:
		return EVP_sha224();

		case TLSEXT_hash_sha256:
		return EVP_sha256();
#endif
#ifndef OPENSSL_NO_SHA512
		case TLSEXT_hash_sha384:
		return EVP_sha384();

		case TLSEXT_hash_sha512:
		return EVP_sha512();
#endif
		default:
		return NULL;

		}
	}

/* Set preferred digest for each key type */

int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
	{
	int i, idx;
	const EVP_MD *md;
	CERT *c = s->cert;
	/* Extension ignored for TLS versions below 1.2 */
	if (TLS1_get_version(s) < TLS1_2_VERSION)
a1743 45
	/* Should never happen */
	if (!c)
		return 0;

	c->pkeys[SSL_PKEY_DSA_SIGN].digest = NULL;
	c->pkeys[SSL_PKEY_RSA_SIGN].digest = NULL;
	c->pkeys[SSL_PKEY_RSA_ENC].digest = NULL;
	c->pkeys[SSL_PKEY_ECC].digest = NULL;

	for (i = 0; i < dsize; i += 2)
		{
		unsigned char hash_alg = data[i], sig_alg = data[i+1];

		switch(sig_alg)
			{
#ifndef OPENSSL_NO_RSA
			case TLSEXT_signature_rsa:
			idx = SSL_PKEY_RSA_SIGN;
			break;
#endif
#ifndef OPENSSL_NO_DSA
			case TLSEXT_signature_dsa:
			idx = SSL_PKEY_DSA_SIGN;
			break;
#endif
#ifndef OPENSSL_NO_ECDSA
			case TLSEXT_signature_ecdsa:
			idx = SSL_PKEY_ECC;
			break;
#endif
			default:
			continue;
			}

		if (c->pkeys[idx].digest == NULL)
			{
			md = tls12_get_hash(hash_alg);
			if (md)
				{
				c->pkeys[idx].digest = md;
				if (idx == SSL_PKEY_RSA_SIGN)
					c->pkeys[SSL_PKEY_RSA_ENC].digest = md;
				}
			}

d1745 5
a1749 92


	/* Set any remaining keys to default values. NOTE: if alg is not
	 * supported it stays as NULL.
	 */
#ifndef OPENSSL_NO_DSA
	if (!c->pkeys[SSL_PKEY_DSA_SIGN].digest)
		c->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_dss1();
#endif
#ifndef OPENSSL_NO_RSA
	if (!c->pkeys[SSL_PKEY_RSA_SIGN].digest)
		{
		c->pkeys[SSL_PKEY_RSA_SIGN].digest = EVP_sha1();
		c->pkeys[SSL_PKEY_RSA_ENC].digest = EVP_sha1();
		}
#endif
#ifndef OPENSSL_NO_ECDSA
	if (!c->pkeys[SSL_PKEY_ECC].digest)
		c->pkeys[SSL_PKEY_ECC].digest = EVP_ecdsa();
#endif
	return 1;
	}

#endif

#ifndef OPENSSL_NO_HEARTBEATS
int
tls1_process_heartbeat(SSL *s)
	{
	unsigned char *p = &s->s3->rrec.data[0], *pl;
	unsigned short hbtype;
	unsigned int payload;
	unsigned int padding = 16; /* Use minimum padding */

	/* Read type and payload length first */
	hbtype = *p++;
	n2s(p, payload);
	pl = p;

	if (s->msg_callback)
		s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
			&s->s3->rrec.data[0], s->s3->rrec.length,
			s, s->msg_callback_arg);

	if (hbtype == TLS1_HB_REQUEST)
		{
		unsigned char *buffer, *bp;
		int r;

		/* Allocate memory for the response, size is 1 bytes
		 * message type, plus 2 bytes payload length, plus
		 * payload, plus padding
		 */
		buffer = OPENSSL_malloc(1 + 2 + payload + padding);
		bp = buffer;
		
		/* Enter response type, length and copy payload */
		*bp++ = TLS1_HB_RESPONSE;
		s2n(payload, bp);
		memcpy(bp, pl, payload);
		bp += payload;
		/* Random padding */
		RAND_pseudo_bytes(bp, padding);

		r = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);

		if (r >= 0 && s->msg_callback)
			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
				buffer, 3 + payload + padding,
				s, s->msg_callback_arg);

		OPENSSL_free(buffer);

		if (r < 0)
			return r;
		}
	else if (hbtype == TLS1_HB_RESPONSE)
		{
		unsigned int seq;
		
		/* We only send sequence numbers (2 bytes unsigned int),
		 * and 16 random bytes, so we just try to read the
		 * sequence number */
		n2s(pl, seq);
		
		if (payload == 18 && seq == s->tlsext_hb_seq)
			{
			s->tlsext_hb_seq++;
			s->tlsext_hb_pending = 0;
			}
		}

a1752 73
int
tls1_heartbeat(SSL *s)
	{
	unsigned char *buf, *p;
	int ret;
	unsigned int payload = 18; /* Sequence number + random bytes */
	unsigned int padding = 16; /* Use minimum padding */

	/* Only send if peer supports and accepts HB requests... */
	if (!(s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED) ||
	    s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_SEND_REQUESTS)
		{
		SSLerr(SSL_F_TLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT);
		return -1;
		}

	/* ...and there is none in flight yet... */
	if (s->tlsext_hb_pending)
		{
		SSLerr(SSL_F_TLS1_HEARTBEAT,SSL_R_TLS_HEARTBEAT_PENDING);
		return -1;
		}
		
	/* ...and no handshake in progress. */
	if (SSL_in_init(s) || s->in_handshake)
		{
		SSLerr(SSL_F_TLS1_HEARTBEAT,SSL_R_UNEXPECTED_MESSAGE);
		return -1;
		}
		
	/* Check if padding is too long, payload and padding
	 * must not exceed 2^14 - 3 = 16381 bytes in total.
	 */
	OPENSSL_assert(payload + padding <= 16381);

	/* Create HeartBeat message, we just use a sequence number
	 * as payload to distuingish different messages and add
	 * some random stuff.
	 *  - Message Type, 1 byte
	 *  - Payload Length, 2 bytes (unsigned int)
	 *  - Payload, the sequence number (2 bytes uint)
	 *  - Payload, random bytes (16 bytes uint)
	 *  - Padding
	 */
	buf = OPENSSL_malloc(1 + 2 + payload + padding);
	p = buf;
	/* Message Type */
	*p++ = TLS1_HB_REQUEST;
	/* Payload length (18 bytes here) */
	s2n(payload, p);
	/* Sequence number */
	s2n(s->tlsext_hb_seq, p);
	/* 16 random bytes */
	RAND_pseudo_bytes(p, 16);
	p += 16;
	/* Random padding */
	RAND_pseudo_bytes(p, padding);

	ret = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buf, 3 + payload + padding);
	if (ret >= 0)
		{
		if (s->msg_callback)
			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
				buf, 3 + payload + padding,
				s, s->msg_callback_arg);

		s->tlsext_hb_pending = 1;
		}
		
	OPENSSL_free(buf);

	return ret;
	}
@


1.1.1.9
log
@Import OpenSSL 1.0.1g
@
text
@d345 3
d353 5
a651 1
#ifndef OPENSSL_NO_SRTP
a669 31
#endif

#ifdef TLSEXT_TYPE_padding
	/* Add padding to workaround bugs in F5 terminators.
	 * See https://tools.ietf.org/html/draft-agl-tls-padding-03
	 *
	 * NB: because this code works out the length of all existing
	 * extensions it MUST always appear last.
	 */
	{
	int hlen = ret - (unsigned char *)s->init_buf->data;
	/* The code in s23_clnt.c to build ClientHello messages includes the
	 * 5-byte record header in the buffer, while the code in s3_clnt.c does
	 * not. */
	if (s->state == SSL23_ST_CW_CLNT_HELLO_A)
		hlen -= 5;
	if (hlen > 0xff && hlen < 0x200)
		{
		hlen = 0x200 - hlen;
		if (hlen >= 4)
			hlen -= 4;
		else
			hlen = 0;

		s2n(TLSEXT_TYPE_padding, ret);
		s2n(hlen, ret);
		memset(ret, 0, hlen);
		ret += hlen;
		}
	}
#endif
a783 1
#ifndef OPENSSL_NO_SRTP
a801 1
#endif
a864 83
#ifndef OPENSSL_NO_EC
/* ssl_check_for_safari attempts to fingerprint Safari using OS X
 * SecureTransport using the TLS extension block in |d|, of length |n|.
 * Safari, since 10.6, sends exactly these extensions, in this order:
 *   SNI,
 *   elliptic_curves
 *   ec_point_formats
 *
 * We wish to fingerprint Safari because they broke ECDHE-ECDSA support in 10.8,
 * but they advertise support. So enabling ECDHE-ECDSA ciphers breaks them.
 * Sadly we cannot differentiate 10.6, 10.7 and 10.8.4 (which work), from
 * 10.8..10.8.3 (which don't work).
 */
static void ssl_check_for_safari(SSL *s, const unsigned char *data, const unsigned char *d, int n) {
	unsigned short type, size;
	static const unsigned char kSafariExtensionsBlock[] = {
		0x00, 0x0a,  /* elliptic_curves extension */
		0x00, 0x08,  /* 8 bytes */
		0x00, 0x06,  /* 6 bytes of curve ids */
		0x00, 0x17,  /* P-256 */
		0x00, 0x18,  /* P-384 */
		0x00, 0x19,  /* P-521 */

		0x00, 0x0b,  /* ec_point_formats */
		0x00, 0x02,  /* 2 bytes */
		0x01,        /* 1 point format */
		0x00,        /* uncompressed */
	};

	/* The following is only present in TLS 1.2 */
	static const unsigned char kSafariTLS12ExtensionsBlock[] = {
		0x00, 0x0d,  /* signature_algorithms */
		0x00, 0x0c,  /* 12 bytes */
		0x00, 0x0a,  /* 10 bytes */
		0x05, 0x01,  /* SHA-384/RSA */
		0x04, 0x01,  /* SHA-256/RSA */
		0x02, 0x01,  /* SHA-1/RSA */
		0x04, 0x03,  /* SHA-256/ECDSA */
		0x02, 0x03,  /* SHA-1/ECDSA */
	};

	if (data >= (d+n-2))
		return;
	data += 2;

	if (data > (d+n-4))
		return;
	n2s(data,type);
	n2s(data,size);

	if (type != TLSEXT_TYPE_server_name)
		return;

	if (data+size > d+n)
		return;
	data += size;

	if (TLS1_get_client_version(s) >= TLS1_2_VERSION)
		{
		const size_t len1 = sizeof(kSafariExtensionsBlock);
		const size_t len2 = sizeof(kSafariTLS12ExtensionsBlock);

		if (data + len1 + len2 != d+n)
			return;
		if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
			return;
		if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
			return;
		}
	else
		{
		const size_t len = sizeof(kSafariExtensionsBlock);

		if (data + len != d+n)
			return;
		if (memcmp(data, kSafariExtensionsBlock, len) != 0)
			return;
		}

	s->s3->is_probably_safari = 1;
}
#endif /* !OPENSSL_NO_EC */

a884 5
#ifndef OPENSSL_NO_EC
	if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)
		ssl_check_for_safari(s, data, d, n);
#endif /* !OPENSSL_NO_EC */

d1080 1
a1080 2
			if (ellipticcurvelist_length != size - 2 ||
				ellipticcurvelist_length < 1)
d1179 1
a1179 1
		         s->version != DTLS1_VERSION)
a1330 1
#ifndef OPENSSL_NO_SRTP
d1332 1
a1332 1
			{
d1336 1
a1336 2
			}
#endif
d1436 1
a1436 2
			if (ecpointformatlist_length != size - 1 || 
				ecpointformatlist_length < 1)
d1530 1
a1530 1
			if (s->ctx->next_proto_select_cb == NULL)
a1579 1
#ifndef OPENSSL_NO_SRTP
d1581 1
a1581 1
			{
d1585 1
a1585 2
			}
#endif
d1766 1
a1766 1
int ssl_check_clienthello_tlsext_early(SSL *s)
d1785 31
d1820 1
a1820 2
		 * so this has to happen here in
		 * ssl_check_clienthello_tlsext_early(). */
d1872 1
a1873 1
#endif
a1890 65
int ssl_check_clienthello_tlsext_late(SSL *s)
	{
	int ret = SSL_TLSEXT_ERR_OK;
	int al;

	/* If status request then ask callback what to do.
 	 * Note: this must be called after servername callbacks in case 
 	 * the certificate has changed, and must be called after the cipher
	 * has been chosen because this may influence which certificate is sent
 	 */
	if ((s->tlsext_status_type != -1) && s->ctx && s->ctx->tlsext_status_cb)
		{
		int r;
		CERT_PKEY *certpkey;
		certpkey = ssl_get_server_send_pkey(s);
		/* If no certificate can't return certificate status */
		if (certpkey == NULL)
			{
			s->tlsext_status_expected = 0;
			return 1;
			}
		/* Set current certificate to one we will use so
		 * SSL_get_certificate et al can pick it up.
		 */
		s->cert->key = certpkey;
		r = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);
		switch (r)
			{
			/* We don't want to send a status request response */
			case SSL_TLSEXT_ERR_NOACK:
				s->tlsext_status_expected = 0;
				break;
			/* status request response should be sent */
			case SSL_TLSEXT_ERR_OK:
				if (s->tlsext_ocsp_resp)
					s->tlsext_status_expected = 1;
				else
					s->tlsext_status_expected = 0;
				break;
			/* something bad happened */
			case SSL_TLSEXT_ERR_ALERT_FATAL:
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;
				al = SSL_AD_INTERNAL_ERROR;
				goto err;
			}
		}
	else
		s->tlsext_status_expected = 0;

 err:
	switch (ret)
		{
		case SSL_TLSEXT_ERR_ALERT_FATAL:
			ssl3_send_alert(s,SSL3_AL_FATAL,al); 
			return -1;

		case SSL_TLSEXT_ERR_ALERT_WARNING:
			ssl3_send_alert(s,SSL3_AL_WARNING,al);
			return 1; 

		default:
			return 1;
		}
	}

d2192 1
a2192 1
	if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen))
d2322 8
d2417 1
a2417 1
		c->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_sha1();
d2428 1
a2428 1
		c->pkeys[SSL_PKEY_ECC].digest = EVP_sha1();
d2444 5
a2452 9

	/* Read type and payload length first */
	if (1 + 2 + 16 > s->s3->rrec.length)
		return 0; /* silently discard */
	hbtype = *p++;
	n2s(p, payload);
	if (1 + 2 + payload + 16 > s->s3->rrec.length)
		return 0; /* silently discard per RFC 6520 sec. 4 */
	pl = p;
@


