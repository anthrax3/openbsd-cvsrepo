head	1.70;
access;
symbols
	OPENBSD_6_1_BASE:1.70;
locks; strict;
comment	@ * @;


1.70
date	2017.02.07.02.08.38;	author beck;	state Exp;
branches;
next	1.69;
commitid	xH3OeartUDKSlAnB;

1.69
date	2017.01.26.12.16.13;	author beck;	state Exp;
branches;
next	1.68;
commitid	lb4UTPLS9Casn2PL;

1.68
date	2017.01.26.10.40.21;	author beck;	state Exp;
branches;
next	1.67;
commitid	Bi1VygMenL4YtCp7;

1.67
date	2017.01.24.09.03.21;	author jsing;	state Exp;
branches;
next	1.66;
commitid	NTZJ3rEptTLCIZDB;

1.66
date	2017.01.24.01.44.00;	author jsing;	state Exp;
branches;
next	1.65;
commitid	O8CUaU9Fg23fiAtj;

1.65
date	2017.01.24.01.39.13;	author jsing;	state Exp;
branches;
next	1.64;
commitid	AhKZDIpUdOCSWQUJ;

1.64
date	2017.01.24.01.34.09;	author jsing;	state Exp;
branches;
next	1.63;
commitid	as4WMWZXSFQitsb1;

1.63
date	2017.01.23.13.36.13;	author jsing;	state Exp;
branches;
next	1.62;
commitid	xYJ523Ay020rUB5W;

1.62
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.61;
commitid	grTXB43OAHDwwKOU;

1.61
date	2017.01.23.05.27.22;	author jsing;	state Exp;
branches;
next	1.60;
commitid	Fb8XE84a6xE5r8Gy;

1.60
date	2017.01.23.05.13.02;	author jsing;	state Exp;
branches;
next	1.59;
commitid	XWcFqNClp2MoKERU;

1.59
date	2017.01.23.04.55.27;	author beck;	state Exp;
branches;
next	1.58;
commitid	AhwkqHI5lKK3NR31;

1.58
date	2017.01.23.04.15.28;	author jsing;	state Exp;
branches;
next	1.57;
commitid	j20UnjrPw7WvzMvm;

1.57
date	2017.01.23.01.22.08;	author jsing;	state Exp;
branches;
next	1.56;
commitid	YymiVWgtX4KkSfL3;

1.56
date	2017.01.23.00.12.55;	author jsing;	state Exp;
branches;
next	1.55;
commitid	Ry6OEk67lc2U2xi9;

1.55
date	2017.01.22.05.14.42;	author beck;	state Exp;
branches;
next	1.54;
commitid	cQZFlJKgRV0smF3Q;

1.54
date	2017.01.22.03.50.45;	author jsing;	state Exp;
branches;
next	1.53;
commitid	Q5mGTZ7ZJXh4fPDx;

1.53
date	2016.11.02.11.21.05;	author jsing;	state Exp;
branches;
next	1.52;
commitid	g1bgCX1m3pnzIBLj;

1.52
date	2016.11.02.09.54.47;	author jsing;	state Exp;
branches;
next	1.51;
commitid	cyxwrNwjeYYvuBPL;

1.51
date	2016.09.04.16.12.33;	author jsing;	state Exp;
branches;
next	1.50;
commitid	AeZa54rMEC93q9TG;

1.50
date	2016.09.04.16.11.47;	author jsing;	state Exp;
branches;
next	1.49;
commitid	gj2yEpa0v3NtQ555;

1.49
date	2016.03.11.07.08.45;	author mmcc;	state Exp;
branches;
next	1.48;
commitid	MTdM7aVFdRMAzAYE;

1.48
date	2015.09.10.17.57.50;	author jsing;	state Exp;
branches;
next	1.47;
commitid	T35skZJCouRaXVVY;

1.47
date	2015.09.10.15.56.26;	author jsing;	state Exp;
branches;
next	1.46;
commitid	vHznCDK3idwNEFz4;

1.46
date	2015.08.27.06.21.15;	author doug;	state Exp;
branches;
next	1.45;
commitid	81GzeBdk0eOTcvRE;

1.45
date	2015.07.21.03.34.38;	author doug;	state Exp;
branches;
next	1.44;
commitid	ErzVbKqXKwga1yuP;

1.44
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.43;
commitid	XNZawfRSWvnVv1VS;

1.43
date	2014.11.08.15.21.02;	author jsing;	state Exp;
branches;
next	1.42;
commitid	lIDXnjZtfw9o5vQC;

1.42
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.41;
commitid	cGE1JG2i0h4NcVDi;

1.41
date	2014.09.22.14.26.22;	author jsing;	state Exp;
branches;
next	1.40;
commitid	g152dWuCWm3g3eij;

1.40
date	2014.08.11.01.06.22;	author jsing;	state Exp;
branches;
next	1.39;
commitid	EjXY9DxJ6SGazL3V;

1.39
date	2014.08.10.14.42.56;	author jsing;	state Exp;
branches;
next	1.38;
commitid	wihJupNvfkdpKL9O;

1.38
date	2014.07.13.16.03.10;	author beck;	state Exp;
branches;
next	1.37;
commitid	6xdvCwSqBadTW6X3;

1.37
date	2014.07.12.23.59.11;	author jsing;	state Exp;
branches;
next	1.36;
commitid	TVXRa3Wp3DBayPXm;

1.36
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.35;
commitid	cCGiAdDteN08GytD;

1.35
date	2014.07.10.08.51.15;	author tedu;	state Exp;
branches;
next	1.34;
commitid	lsH7iukeZYSZBx6F;

1.34
date	2014.06.21.20.27.25;	author tedu;	state Exp;
branches;
next	1.33;
commitid	Kp8UIyI3HI6NHi39;

1.33
date	2014.06.19.21.29.51;	author tedu;	state Exp;
branches;
next	1.32;
commitid	CIpPjhmVWPbqgxVA;

1.32
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	mJUVYpkFBZ0Zv2bG;

1.31
date	2014.06.04.14.10.23;	author tedu;	state Exp;
branches;
next	1.30;
commitid	GMbAFZ4Hukhh97U1;

1.30
date	2014.05.31.10.53.39;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2014.05.28.13.03.25;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.23.20.50.18;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.20.12.48.19;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.17.21.32.37;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.13.37.50;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.16.20.39.09;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.16.17.59.17;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.16.15.10.07;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.14.13.10.35;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.06.12.17.54;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.11.22.15.20;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.14.11.18.04;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.30.11.08.06;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.03.41;	author beck;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2000.12.15.02.58.41;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.34;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.30;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.13;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.13;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.43;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.36;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.53.05;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.36.47;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.11.11.21.21.30;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.20.42.07;	author markus;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.04.29.05.37.28;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2012.10.13.21.23.50;	author djm;	state Exp;
branches;
next	;

1.5.2.1
date	2002.07.30.11.07.34;	author miod;	state Exp;
branches;
next	;

1.5.4.1
date	2002.07.30.15.47.52;	author jason;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Change SSLerror() back to taking two args, with the first one being an SSL *.
Make a table of "function codes" which maps the internal state of the SSL *
to something like a useful name so in a typical error in the connection you
know in what sort of place in the handshake things happened. (instead of
by arcane function name).
Add SSLerrorx() for when we don't have an SSL *
ok jsing@@ after us both being prodded by bluhm@@ to make it not terrible
@
text
@/* $OpenBSD: ssl_sess.c,v 1.69 2017/01/26 12:16:13 beck Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#include <openssl/lhash.h>

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include "ssl_locl.h"

static void SSL_SESSION_list_remove(SSL_CTX *ctx, SSL_SESSION *s);
static void SSL_SESSION_list_add(SSL_CTX *ctx, SSL_SESSION *s);
static int remove_session_lock(SSL_CTX *ctx, SSL_SESSION *c, int lck);

/* aka SSL_get0_session; gets 0 objects, just returns a copy of the pointer */
SSL_SESSION *
SSL_get_session(const SSL *ssl)
{
	return (ssl->session);
}

/* variant of SSL_get_session: caller really gets something */
SSL_SESSION *
SSL_get1_session(SSL *ssl)
{
	SSL_SESSION *sess;

	/*
	 * Need to lock this all up rather than just use CRYPTO_add so that
	 * somebody doesn't free ssl->session between when we check it's
	 * non-null and when we up the reference count.
	 */
	CRYPTO_w_lock(CRYPTO_LOCK_SSL_SESSION);
	sess = ssl->session;
	if (sess)
		sess->references++;
	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_SESSION);

	return (sess);
}

int
SSL_SESSION_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION,
	    argl, argp, new_func, dup_func, free_func);
}

int
SSL_SESSION_set_ex_data(SSL_SESSION *s, int idx, void *arg)
{
	return (CRYPTO_set_ex_data(&s->internal->ex_data, idx, arg));
}

void *
SSL_SESSION_get_ex_data(const SSL_SESSION *s, int idx)
{
	return (CRYPTO_get_ex_data(&s->internal->ex_data, idx));
}

SSL_SESSION *
SSL_SESSION_new(void)
{
	SSL_SESSION *ss;

	if ((ss = calloc(1, sizeof(*ss))) == NULL) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}
	if ((ss->internal = calloc(1, sizeof(*ss->internal))) == NULL) {
		free(ss);
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}

	ss->verify_result = 1; /* avoid 0 (= X509_V_OK) just in case */
	ss->references = 1;
	ss->timeout=60*5+4; /* 5 minute timeout by default */
	ss->time = time(NULL);
	ss->internal->prev = NULL;
	ss->internal->next = NULL;
	ss->tlsext_hostname = NULL;

	ss->internal->tlsext_ecpointformatlist_length = 0;
	ss->internal->tlsext_ecpointformatlist = NULL;
	ss->internal->tlsext_supportedgroups_length = 0;
	ss->internal->tlsext_supportedgroups = NULL;

	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->internal->ex_data);

	return (ss);
}

const unsigned char *
SSL_SESSION_get_id(const SSL_SESSION *s, unsigned int *len)
{
	if (len)
		*len = s->session_id_length;
	return s->session_id;
}

unsigned int
SSL_SESSION_get_compress_id(const SSL_SESSION *s)
{
	return 0;
}

/*
 * SSLv3/TLSv1 has 32 bytes (256 bits) of session ID space. As such, filling
 * the ID with random gunk repeatedly until we have no conflict is going to
 * complete in one iteration pretty much "most" of the time (btw:
 * understatement). So, if it takes us 10 iterations and we still can't avoid
 * a conflict - well that's a reasonable point to call it quits. Either the
 * arc4random code is broken or someone is trying to open roughly very close to
 * 2^128 (or 2^256) SSL sessions to our server. How you might store that many
 * sessions is perhaps a more interesting question...
 */

#define MAX_SESS_ID_ATTEMPTS 10

static int
def_generate_session_id(const SSL *ssl, unsigned char *id, unsigned int *id_len)
{
	unsigned int retry = 0;

	do {
		arc4random_buf(id, *id_len);
	} while (SSL_has_matching_session_id(ssl, id, *id_len) &&
	    (++retry < MAX_SESS_ID_ATTEMPTS));

	if (retry < MAX_SESS_ID_ATTEMPTS)
		return 1;

	/* else - woops a session_id match */
	/* XXX We should also check the external cache --
	 * but the probability of a collision is negligible, and
	 * we could not prevent the concurrent creation of sessions
	 * with identical IDs since we currently don't have means
	 * to atomically check whether a session ID already exists
	 * and make a reservation for it if it does not
	 * (this problem applies to the internal cache as well).
	 */
	return 0;
}

int
ssl_get_new_session(SSL *s, int session)
{
	unsigned int tmp;
	SSL_SESSION *ss = NULL;
	GEN_SESSION_CB cb = def_generate_session_id;

	/* This gets used by clients and servers. */

	if ((ss = SSL_SESSION_new()) == NULL)
		return (0);

	/* If the context has a default timeout, use it */
	if (s->session_ctx->session_timeout == 0)
		ss->timeout = SSL_get_default_timeout(s);
	else
		ss->timeout = s->session_ctx->session_timeout;

	if (s->session != NULL) {
		SSL_SESSION_free(s->session);
		s->session = NULL;
	}

	if (session) {
		switch (s->version) {
		case TLS1_VERSION:
		case TLS1_1_VERSION:
		case TLS1_2_VERSION:
		case DTLS1_VERSION:
			ss->ssl_version = s->version;
			ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
			break;
		default:
			SSLerror(s, SSL_R_UNSUPPORTED_SSL_VERSION);
			SSL_SESSION_free(ss);
			return (0);
		}

		/* If RFC4507 ticket use empty session ID. */
		if (s->internal->tlsext_ticket_expected) {
			ss->session_id_length = 0;
			goto sess_id_done;
		}

		/* Choose which callback will set the session ID. */
		CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
		if (s->internal->generate_session_id)
			cb = s->internal->generate_session_id;
		else if (s->session_ctx->internal->generate_session_id)
			cb = s->session_ctx->internal->generate_session_id;
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);

		/* Choose a session ID. */
		tmp = ss->session_id_length;
		if (!cb(s, ss->session_id, &tmp)) {
			/* The callback failed */
			SSLerror(s, SSL_R_SSL_SESSION_ID_CALLBACK_FAILED);
			SSL_SESSION_free(ss);
			return (0);
		}

		/*
		 * Don't allow the callback to set the session length to zero.
		 * nor set it higher than it was.
		 */
		if (!tmp || (tmp > ss->session_id_length)) {
			/* The callback set an illegal length */
			SSLerror(s, SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH);
			SSL_SESSION_free(ss);
			return (0);
		}
		ss->session_id_length = tmp;

		/* Finally, check for a conflict. */
		if (SSL_has_matching_session_id(s, ss->session_id,
			ss->session_id_length)) {
			SSLerror(s, SSL_R_SSL_SESSION_ID_CONFLICT);
			SSL_SESSION_free(ss);
			return (0);
		}

sess_id_done:
		if (s->tlsext_hostname) {
			ss->tlsext_hostname = strdup(s->tlsext_hostname);
			if (ss->tlsext_hostname == NULL) {
				SSLerror(s, ERR_R_INTERNAL_ERROR);
				SSL_SESSION_free(ss);
				return 0;
			}
		}
	} else {
		ss->session_id_length = 0;
	}

	if (s->sid_ctx_length > sizeof ss->sid_ctx) {
		SSLerror(s, ERR_R_INTERNAL_ERROR);
		SSL_SESSION_free(ss);
		return 0;
	}

	memcpy(ss->sid_ctx, s->sid_ctx, s->sid_ctx_length);
	ss->sid_ctx_length = s->sid_ctx_length;
	s->session = ss;
	ss->ssl_version = s->version;
	ss->verify_result = X509_V_OK;

	return (1);
}

/*
 * ssl_get_prev attempts to find an SSL_SESSION to be used to resume this
 * connection. It is only called by servers.
 *
 *   session_id: points at the session ID in the ClientHello. This code will
 *       read past the end of this in order to parse out the session ticket
 *       extension, if any.
 *   len: the length of the session ID.
 *   limit: a pointer to the first byte after the ClientHello.
 *
 * Returns:
 *   -1: error
 *    0: a session may have been found.
 *
 * Side effects:
 *   - If a session is found then s->session is pointed at it (after freeing
 *     an existing session if need be) and s->verify_result is set from the
 *     session.
 *   - Both for new and resumed sessions, s->internal->tlsext_ticket_expected is set
 *     to 1 if the server should issue a new session ticket (to 0 otherwise).
 */
int
ssl_get_prev_session(SSL *s, unsigned char *session_id, int len,
    const unsigned char *limit)
{
	SSL_SESSION *ret = NULL;
	int fatal = 0;
	int try_session_cache = 1;
	int r;

	/* This is used only by servers. */

	if (len > SSL_MAX_SSL_SESSION_ID_LENGTH)
		goto err;

	if (len == 0)
		try_session_cache = 0;

	/* Sets s->internal->tlsext_ticket_expected. */
	r = tls1_process_ticket(s, session_id, len, limit, &ret);
	switch (r) {
	case -1: /* Error during processing */
		fatal = 1;
		goto err;
	case 0: /* No ticket found */
	case 1: /* Zero length ticket found */
		break; /* Ok to carry on processing session id. */
	case 2: /* Ticket found but not decrypted. */
	case 3: /* Ticket decrypted, *ret has been set. */
		try_session_cache = 0;
		break;
	default:
		abort();
	}

	if (try_session_cache && ret == NULL &&
	    !(s->session_ctx->internal->session_cache_mode &
	     SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)) {
		SSL_SESSION data;
		data.ssl_version = s->version;
		data.session_id_length = len;
		memcpy(data.session_id, session_id, len);

		CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
		ret = lh_SSL_SESSION_retrieve(s->session_ctx->internal->sessions, &data);
		if (ret != NULL) {
			/* Don't allow other threads to steal it. */
			CRYPTO_add(&ret->references, 1,
			    CRYPTO_LOCK_SSL_SESSION);
		}
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);

		if (ret == NULL)
			s->session_ctx->internal->stats.sess_miss++;
	}

	if (try_session_cache && ret == NULL &&
	    s->session_ctx->internal->get_session_cb != NULL) {
		int copy = 1;

		if ((ret = s->session_ctx->internal->get_session_cb(s,
		    session_id, len, &copy))) {
			s->session_ctx->internal->stats.sess_cb_hit++;

			/*
			 * Increment reference count now if the session
			 * callback asks us to do so (note that if the session
			 * structures returned by the callback are shared
			 * between threads, it must handle the reference count
			 * itself [i.e. copy == 0], or things won't be
			 * thread-safe).
			 */
			if (copy)
				CRYPTO_add(&ret->references, 1,
				    CRYPTO_LOCK_SSL_SESSION);

			/*
			 * Add the externally cached session to the internal
			 * cache as well if and only if we are supposed to.
			 */
			if (!(s->session_ctx->internal->session_cache_mode &
			    SSL_SESS_CACHE_NO_INTERNAL_STORE))
				/*
				 * The following should not return 1,
				 * otherwise, things are very strange.
				 */
				SSL_CTX_add_session(s->session_ctx, ret);
		}
	}

	if (ret == NULL)
		goto err;

	/* Now ret is non-NULL and we own one of its reference counts. */

	if (ret->sid_ctx_length != s->sid_ctx_length ||
	    timingsafe_memcmp(ret->sid_ctx,
		s->sid_ctx, ret->sid_ctx_length) != 0) {
		/* We have the session requested by the client, but we don't
		 * want to use it in this context. */
		goto err; /* treat like cache miss */
	}

	if ((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0) {
		/*
		 * We can't be sure if this session is being used out of
		 * context, which is especially important for SSL_VERIFY_PEER.
		 * The application should have used
		 * SSL[_CTX]_set_session_id_context.
		 *
		 * For this error case, we generate an error instead of treating
		 * the event like a cache miss (otherwise it would be easy for
		 * applications to effectively disable the session cache by
		 * accident without anyone noticing).
		 */
		SSLerror(s, SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);
		fatal = 1;
		goto err;
	}

	if (ret->cipher == NULL) {
		ret->cipher = ssl3_get_cipher_by_id(ret->cipher_id);
		if (ret->cipher == NULL)
			goto err;
	}

	if (ret->timeout < (time(NULL) - ret->time)) {
		/* timeout */
		s->session_ctx->internal->stats.sess_timeout++;
		if (try_session_cache) {
			/* session was from the cache, so remove it */
			SSL_CTX_remove_session(s->session_ctx, ret);
		}
		goto err;
	}

	s->session_ctx->internal->stats.sess_hit++;

	if (s->session != NULL)
		SSL_SESSION_free(s->session);
	s->session = ret;
	s->verify_result = s->session->verify_result;
	return 1;

err:
	if (ret != NULL) {
		SSL_SESSION_free(ret);
		if (!try_session_cache) {
			/*
			 * The session was from a ticket, so we should
			 * issue a ticket for the new session.
			 */
			s->internal->tlsext_ticket_expected = 1;
		}
	}
	if (fatal)
		return -1;
	else
		return 0;
}

int
SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c)
{
	int ret = 0;
	SSL_SESSION *s;

	/*
	 * Add just 1 reference count for the SSL_CTX's session cache
	 * even though it has two ways of access: each session is in a
	 * doubly linked list and an lhash.
	 */
	CRYPTO_add(&c->references, 1, CRYPTO_LOCK_SSL_SESSION);

	/*
	 * If session c is in already in cache, we take back the increment
	 * later.
	 */
	CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
	s = lh_SSL_SESSION_insert(ctx->internal->sessions, c);

	/*
	 * s != NULL iff we already had a session with the given PID.
	 * In this case, s == c should hold (then we did not really modify
	 * ctx->internal->sessions), or we're in trouble.
	 */
	if (s != NULL && s != c) {
		/* We *are* in trouble ... */
		SSL_SESSION_list_remove(ctx, s);
		SSL_SESSION_free(s);
		/*
		 * ... so pretend the other session did not exist in cache
		 * (we cannot handle two SSL_SESSION structures with identical
		 * session ID in the same cache, which could happen e.g. when
		 * two threads concurrently obtain the same session from an
		 * external cache).
		 */
		s = NULL;
	}

	/* Put at the head of the queue unless it is already in the cache */
	if (s == NULL)
		SSL_SESSION_list_add(ctx, c);

	if (s != NULL) {
		/*
		 * existing cache entry -- decrement previously incremented
		 * reference count because it already takes into account the
		 * cache.
		 */
		SSL_SESSION_free(s); /* s == c */
		ret = 0;
	} else {
		/*
		 * New cache entry -- remove old ones if cache has become
		 * too large.
		 */

		ret = 1;

		if (SSL_CTX_sess_get_cache_size(ctx) > 0) {
			while (SSL_CTX_sess_number(ctx) >
			    SSL_CTX_sess_get_cache_size(ctx)) {
				if (!remove_session_lock(ctx,
				    ctx->internal->session_cache_tail, 0))
					break;
				else
					ctx->internal->stats.sess_cache_full++;
			}
		}
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
	return (ret);
}

int
SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c)
{
	return remove_session_lock(ctx, c, 1);
}

static int
remove_session_lock(SSL_CTX *ctx, SSL_SESSION *c, int lck)
{
	SSL_SESSION *r;
	int ret = 0;

	if ((c != NULL) && (c->session_id_length != 0)) {
		if (lck)
			CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
		if ((r = lh_SSL_SESSION_retrieve(ctx->internal->sessions, c)) == c) {
			ret = 1;
			r = lh_SSL_SESSION_delete(ctx->internal->sessions, c);
			SSL_SESSION_list_remove(ctx, c);
		}
		if (lck)
			CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);

		if (ret) {
			r->internal->not_resumable = 1;
			if (ctx->internal->remove_session_cb != NULL)
				ctx->internal->remove_session_cb(ctx, r);
			SSL_SESSION_free(r);
		}
	} else
		ret = 0;
	return (ret);
}

void
SSL_SESSION_free(SSL_SESSION *ss)
{
	int i;

	if (ss == NULL)
		return;

	i = CRYPTO_add(&ss->references, -1, CRYPTO_LOCK_SSL_SESSION);
	if (i > 0)
		return;

	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->internal->ex_data);

	explicit_bzero(ss->master_key, sizeof ss->master_key);
	explicit_bzero(ss->session_id, sizeof ss->session_id);

	ssl_sess_cert_free(ss->internal->sess_cert);

	X509_free(ss->peer);

	sk_SSL_CIPHER_free(ss->ciphers);

	free(ss->tlsext_hostname);
	free(ss->tlsext_tick);
	free(ss->internal->tlsext_ecpointformatlist);
	free(ss->internal->tlsext_supportedgroups);

	explicit_bzero(ss->internal, sizeof(*ss->internal));
	free(ss->internal);

	explicit_bzero(ss, sizeof(*ss));
	free(ss);
}

int
SSL_set_session(SSL *s, SSL_SESSION *session)
{
	int ret = 0;
	const SSL_METHOD *meth;

	if (session != NULL) {
		meth = s->ctx->method->internal->get_ssl_method(session->ssl_version);
		if (meth == NULL)
			meth = s->method->internal->get_ssl_method(session->ssl_version);
		if (meth == NULL) {
			SSLerror(s, SSL_R_UNABLE_TO_FIND_SSL_METHOD);
			return (0);
		}

		if (meth != s->method) {
			if (!SSL_set_ssl_method(s, meth))
				return (0);
		}

		/* CRYPTO_w_lock(CRYPTO_LOCK_SSL);*/
		CRYPTO_add(&session->references, 1, CRYPTO_LOCK_SSL_SESSION);
		if (s->session != NULL)
			SSL_SESSION_free(s->session);
		s->session = session;
		s->verify_result = s->session->verify_result;
		/* CRYPTO_w_unlock(CRYPTO_LOCK_SSL);*/
		ret = 1;
	} else {
		if (s->session != NULL) {
			SSL_SESSION_free(s->session);
			s->session = NULL;
		}

		meth = s->ctx->method;
		if (meth != s->method) {
			if (!SSL_set_ssl_method(s, meth))
				return (0);
		}
		ret = 1;
	}
	return (ret);
}

long
SSL_SESSION_set_timeout(SSL_SESSION *s, long t)
{
	if (s == NULL)
		return (0);
	s->timeout = t;
	return (1);
}

long
SSL_SESSION_get_timeout(const SSL_SESSION *s)
{
	if (s == NULL)
		return (0);
	return (s->timeout);
}

/* XXX 2038 */
long
SSL_SESSION_get_time(const SSL_SESSION *s)
{
	if (s == NULL)
		return (0);
	return (s->time);
}

/* XXX 2038 */
long
SSL_SESSION_set_time(SSL_SESSION *s, long t)
{
	if (s == NULL)
		return (0);
	s->time = t;
	return (t);
}

X509 *
SSL_SESSION_get0_peer(SSL_SESSION *s)
{
	return s->peer;
}

int
SSL_SESSION_set1_id_context(SSL_SESSION *s, const unsigned char *sid_ctx,
    unsigned int sid_ctx_len)
{
	if (sid_ctx_len > SSL_MAX_SID_CTX_LENGTH) {
		SSLerrorx(SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
		return 0;
	}
	s->sid_ctx_length = sid_ctx_len;
	memcpy(s->sid_ctx, sid_ctx, sid_ctx_len);

	return 1;
}

long
SSL_CTX_set_timeout(SSL_CTX *s, long t)
{
	long l;

	if (s == NULL)
		return (0);
	l = s->session_timeout;
	s->session_timeout = t;

	return (l);
}

long
SSL_CTX_get_timeout(const SSL_CTX *s)
{
	if (s == NULL)
		return (0);
	return (s->session_timeout);
}

int
SSL_set_session_secret_cb(SSL *s, int (*tls_session_secret_cb)(SSL *s,
    void *secret, int *secret_len, STACK_OF(SSL_CIPHER) *peer_ciphers,
    SSL_CIPHER **cipher, void *arg), void *arg)
{
	if (s == NULL)
		return (0);
	s->internal->tls_session_secret_cb = tls_session_secret_cb;
	s->internal->tls_session_secret_cb_arg = arg;
	return (1);
}

int
SSL_set_session_ticket_ext_cb(SSL *s, tls_session_ticket_ext_cb_fn cb,
    void *arg)
{
	if (s == NULL)
		return (0);
	s->internal->tls_session_ticket_ext_cb = cb;
	s->internal->tls_session_ticket_ext_cb_arg = arg;
	return (1);
}

int
SSL_set_session_ticket_ext(SSL *s, void *ext_data, int ext_len)
{
	if (s->version >= TLS1_VERSION) {
		free(s->internal->tlsext_session_ticket);
		s->internal->tlsext_session_ticket =
		    malloc(sizeof(TLS_SESSION_TICKET_EXT) + ext_len);
		if (!s->internal->tlsext_session_ticket) {
			SSLerror(s, ERR_R_MALLOC_FAILURE);
			return 0;
		}

		if (ext_data) {
			s->internal->tlsext_session_ticket->length = ext_len;
			s->internal->tlsext_session_ticket->data =
			    s->internal->tlsext_session_ticket + 1;
			memcpy(s->internal->tlsext_session_ticket->data,
			    ext_data, ext_len);
		} else {
			s->internal->tlsext_session_ticket->length = 0;
			s->internal->tlsext_session_ticket->data = NULL;
		}

		return 1;
	}

	return 0;
}

typedef struct timeout_param_st {
	SSL_CTX *ctx;
	long time;
	struct lhash_st_SSL_SESSION *cache;
} TIMEOUT_PARAM;

static void
timeout_doall_arg(SSL_SESSION *s, TIMEOUT_PARAM *p)
{
	if ((p->time == 0) || (p->time > (s->time + s->timeout))) {
		/* timeout */
		/* The reason we don't call SSL_CTX_remove_session() is to
		 * save on locking overhead */
		(void)lh_SSL_SESSION_delete(p->cache, s);
		SSL_SESSION_list_remove(p->ctx, s);
		s->internal->not_resumable = 1;
		if (p->ctx->internal->remove_session_cb != NULL)
			p->ctx->internal->remove_session_cb(p->ctx, s);
		SSL_SESSION_free(s);
	}
}

static void
timeout_LHASH_DOALL_ARG(void *arg1, void *arg2)
{
	SSL_SESSION *a = arg1;
	TIMEOUT_PARAM *b = arg2;

	timeout_doall_arg(a, b);
}

/* XXX 2038 */
void
SSL_CTX_flush_sessions(SSL_CTX *s, long t)
{
	unsigned long i;
	TIMEOUT_PARAM tp;

	tp.ctx = s;
	tp.cache = s->internal->sessions;
	if (tp.cache == NULL)
		return;
	tp.time = t;
	CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
	i = CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load;
	CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load = 0;
	lh_SSL_SESSION_doall_arg(tp.cache, timeout_LHASH_DOALL_ARG,
	TIMEOUT_PARAM, &tp);
	CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load = i;
	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
}

int
ssl_clear_bad_session(SSL *s)
{
	if ((s->session != NULL) && !(s->internal->shutdown & SSL_SENT_SHUTDOWN) &&
	    !(SSL_in_init(s) || SSL_in_before(s))) {
		SSL_CTX_remove_session(s->ctx, s->session);
		return (1);
	} else
		return (0);
}

/* locked by SSL_CTX in the calling function */
static void
SSL_SESSION_list_remove(SSL_CTX *ctx, SSL_SESSION *s)
{
	if ((s->internal->next == NULL) || (s->internal->prev == NULL))
		return;

	if (s->internal->next == (SSL_SESSION *)&(ctx->internal->session_cache_tail)) {
		/* last element in list */
		if (s->internal->prev == (SSL_SESSION *)&(ctx->internal->session_cache_head)) {
			/* only one element in list */
			ctx->internal->session_cache_head = NULL;
			ctx->internal->session_cache_tail = NULL;
		} else {
			ctx->internal->session_cache_tail = s->internal->prev;
			s->internal->prev->internal->next =
			    (SSL_SESSION *)&(ctx->internal->session_cache_tail);
		}
	} else {
		if (s->internal->prev == (SSL_SESSION *)&(ctx->internal->session_cache_head)) {
			/* first element in list */
			ctx->internal->session_cache_head = s->internal->next;
			s->internal->next->internal->prev =
			    (SSL_SESSION *)&(ctx->internal->session_cache_head);
		} else {
			/* middle of list */
			s->internal->next->internal->prev = s->internal->prev;
			s->internal->prev->internal->next = s->internal->next;
		}
	}
	s->internal->prev = s->internal->next = NULL;
}

static void
SSL_SESSION_list_add(SSL_CTX *ctx, SSL_SESSION *s)
{
	if ((s->internal->next != NULL) && (s->internal->prev != NULL))
		SSL_SESSION_list_remove(ctx, s);

	if (ctx->internal->session_cache_head == NULL) {
		ctx->internal->session_cache_head = s;
		ctx->internal->session_cache_tail = s;
		s->internal->prev = (SSL_SESSION *)&(ctx->internal->session_cache_head);
		s->internal->next = (SSL_SESSION *)&(ctx->internal->session_cache_tail);
	} else {
		s->internal->next = ctx->internal->session_cache_head;
		s->internal->next->internal->prev = s;
		s->internal->prev = (SSL_SESSION *)&(ctx->internal->session_cache_head);
		ctx->internal->session_cache_head = s;
	}
}

void
SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,
    int (*cb)(struct ssl_st *ssl, SSL_SESSION *sess)) {
	ctx->internal->new_session_cb = cb;
}

int
(*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(SSL *ssl, SSL_SESSION *sess)
{
	return ctx->internal->new_session_cb;
}

void
SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,
    void (*cb)(SSL_CTX *ctx, SSL_SESSION *sess))
{
	ctx->internal->remove_session_cb = cb;
}

void
(*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(SSL_CTX * ctx, SSL_SESSION *sess)
{
	return ctx->internal->remove_session_cb;
}

void
SSL_CTX_sess_set_get_cb(SSL_CTX *ctx, SSL_SESSION *(*cb)(struct ssl_st *ssl,
    unsigned char *data, int len, int *copy))
{
	ctx->internal->get_session_cb = cb;
}

SSL_SESSION *
(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(SSL *ssl, unsigned char *data,
    int len, int *copy)
{
	return ctx->internal->get_session_cb;
}

void
SSL_CTX_set_info_callback(SSL_CTX *ctx,
    void (*cb)(const SSL *ssl, int type, int val))
{
	ctx->internal->info_callback = cb;
}

void
(*SSL_CTX_get_info_callback(SSL_CTX *ctx))(const SSL *ssl, int type, int val)
{
	return ctx->internal->info_callback;
}

void
SSL_CTX_set_client_cert_cb(SSL_CTX *ctx,
    int (*cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey))
{
	ctx->internal->client_cert_cb = cb;
}

int
(*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL * ssl, X509 ** x509,
    EVP_PKEY **pkey)
{
	return ctx->internal->client_cert_cb;
}

#ifndef OPENSSL_NO_ENGINE
int
SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e)
{
	if (!ENGINE_init(e)) {
		SSLerrorx(ERR_R_ENGINE_LIB);
		return 0;
	}
	if (!ENGINE_get_ssl_client_cert_function(e)) {
		SSLerrorx(SSL_R_NO_CLIENT_CERT_METHOD);
		ENGINE_finish(e);
		return 0;
	}
	ctx->internal->client_cert_engine = e;
	return 1;
}
#endif

void
SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx,
    int (*cb)(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len))
{
	ctx->internal->app_gen_cookie_cb = cb;
}

void
SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx,
    int (*cb)(SSL *ssl, unsigned char *cookie, unsigned int cookie_len))
{
	ctx->internal->app_verify_cookie_cb = cb;
}

int
PEM_write_SSL_SESSION(FILE *fp, SSL_SESSION *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_SSL_SESSION,
	    PEM_STRING_SSL_SESSION, fp, x, NULL, NULL, 0, NULL, NULL);
}

SSL_SESSION *
PEM_read_SSL_SESSION(FILE *fp, SSL_SESSION **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_SSL_SESSION,
	    PEM_STRING_SSL_SESSION, fp, (void **)x, cb, u);
}

SSL_SESSION *
PEM_read_bio_SSL_SESSION(BIO *bp, SSL_SESSION **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_SSL_SESSION,
	    PEM_STRING_SSL_SESSION, bp, (void **)x, cb, u);
}

int
PEM_write_bio_SSL_SESSION(BIO *bp, SSL_SESSION *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_SSL_SESSION,
	    PEM_STRING_SSL_SESSION, bp, x, NULL, NULL, 0, NULL, NULL);
}
@


1.69
log
@Finish the fallout of the SSLerr->SSLerror cleanup to get rid of the ugly
line wraps that resulted
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.68 2017/01/26 10:40:21 beck Exp $ */
d203 1
a203 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d208 1
a208 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d315 1
a315 1
			SSLerror(SSL_R_UNSUPPORTED_SSL_VERSION);
d338 1
a338 1
			SSLerror(SSL_R_SSL_SESSION_ID_CALLBACK_FAILED);
d349 1
a349 1
			SSLerror(SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH);
d358 1
a358 1
			SSLerror(SSL_R_SSL_SESSION_ID_CONFLICT);
d367 1
a367 1
				SSLerror(ERR_R_INTERNAL_ERROR);
d377 1
a377 1
		SSLerror(ERR_R_INTERNAL_ERROR);
d526 1
a526 1
		SSLerror(SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);
d726 1
a726 1
			SSLerror(SSL_R_UNABLE_TO_FIND_SSL_METHOD);
d806 1
a806 1
		SSLerror(SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
d867 1
a867 1
			SSLerror(ERR_R_MALLOC_FAILURE);
d1074 1
a1074 1
		SSLerror(ERR_R_ENGINE_LIB);
d1078 1
a1078 1
		SSLerror(SSL_R_NO_CLIENT_CERT_METHOD);
@


1.68
log
@Send the error function codes to rot in the depths of hell where they belong
We leave a single funciton code (0xFFF) to say "SSL_internal" so the public
API will not break, and we replace all internal use of the two argument
SSL_err() with the internal only SSL_error() that only takes a reason code.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.67 2017/01/24 09:03:21 jsing Exp $ */
d315 1
a315 2
			SSLerror(
			    SSL_R_UNSUPPORTED_SSL_VERSION);
d338 1
a338 2
			SSLerror(
			SSL_R_SSL_SESSION_ID_CALLBACK_FAILED);
d349 1
a349 2
			SSLerror(
			SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH);
d358 1
a358 2
			SSLerror(
			SSL_R_SSL_SESSION_ID_CONFLICT);
d367 1
a367 2
				SSLerror(
				    ERR_R_INTERNAL_ERROR);
d526 1
a526 2
		SSLerror(
		    SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);
d726 1
a726 2
			SSLerror(
			    SSL_R_UNABLE_TO_FIND_SSL_METHOD);
d806 1
a806 2
		SSLerror(
		    SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
d867 1
a867 2
			SSLerror(
			    ERR_R_MALLOC_FAILURE);
d1074 1
a1074 2
		SSLerror(
		    ERR_R_ENGINE_LIB);
d1078 1
a1078 2
		SSLerror(
		    SSL_R_NO_CLIENT_CERT_METHOD);
@


1.67
log
@Add support for setting the supported EC curves via
SSL{_CTX}_set1_groups{_list}() - also provide defines for the previous
SSL{_CTX}_set1_curves{_list} names.

This also changes the default list of EC curves to be X25519, P-256 and
P-384. If you want others (such a brainpool) you need to configure this
yourself.

Inspired by parts of BoringSSL and OpenSSL.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.66 2017/01/24 01:44:00 jsing Exp $ */
d203 1
a203 1
		SSLerr(SSL_F_SSL_SESSION_NEW, ERR_R_MALLOC_FAILURE);
d208 1
a208 1
		SSLerr(SSL_F_SSL_SESSION_NEW, ERR_R_MALLOC_FAILURE);
d315 1
a315 1
			SSLerr(SSL_F_SSL_GET_NEW_SESSION,
d339 1
a339 1
			SSLerr(SSL_F_SSL_GET_NEW_SESSION,
d351 1
a351 1
			SSLerr(SSL_F_SSL_GET_NEW_SESSION,
d361 1
a361 1
			SSLerr(SSL_F_SSL_GET_NEW_SESSION,
d371 1
a371 1
				SSLerr(SSL_F_SSL_GET_NEW_SESSION,
d382 1
a382 1
		SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);
d531 1
a531 1
		SSLerr(SSL_F_SSL_GET_PREV_SESSION,
d732 1
a732 1
			SSLerr(SSL_F_SSL_SET_SESSION,
d813 1
a813 1
		SSLerr(SSL_F_SSL_SESSION_SET1_ID_CONTEXT,
d875 1
a875 1
			SSLerr(SSL_F_SSL_SET_SESSION_TICKET_EXT,
d1083 1
a1083 1
		SSLerr(SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE,
d1088 1
a1088 1
		SSLerr(SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE,
@


1.66
log
@sk_SSL_CIPHER_free() checks for NULL so do not bother doing the same from
the callers.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.65 2017/01/24 01:39:13 jsing Exp $ */
d222 2
a223 2
	ss->internal->tlsext_ellipticcurvelist_length = 0;
	ss->internal->tlsext_ellipticcurvelist = NULL;
d712 1
a712 1
	free(ss->internal->tlsext_ellipticcurvelist);
@


1.65
log
@ssl_sess_cert_free() checks for NULL, so do not bother doing it at the
call sites.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.64 2017/01/24 01:34:09 jsing Exp $ */
d707 1
a707 2
	if (ss->ciphers != NULL)
		sk_SSL_CIPHER_free(ss->ciphers);
@


1.64
log
@There is no point in zeroing fields that exist within a struct that is
about to be explicit_bzero'd and freed.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.63 2017/01/23 13:36:13 jsing Exp $ */
d702 3
a704 2
	if (ss->internal->sess_cert != NULL)
		ssl_sess_cert_free(ss->internal->sess_cert);
d706 1
d709 1
@


1.63
log
@Split most of SSL_METHOD out into an internal variant, which is opaque.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.62 2017/01/23 06:45:30 beck Exp $ */
a708 1
	ss->internal->tlsext_ecpointformatlist_length = 0;
a709 1
	ss->internal->tlsext_ellipticcurvelist_length = 0;
@


1.62
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.61 2017/01/23 05:27:22 jsing Exp $ */
d728 1
a728 1
		meth = s->ctx->method->get_ssl_method(session->ssl_version);
d730 1
a730 1
			meth = s->method->get_ssl_method(session->ssl_version);
a740 1

@


1.61
log
@Move ex_data, next and prev from SSL_SESSION to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.60 2017/01/23 05:13:02 jsing Exp $ */
d322 1
a322 1
		if (s->tlsext_ticket_expected) {
d414 1
a414 1
 *   - Both for new and resumed sessions, s->tlsext_ticket_expected is set
d434 1
a434 1
	/* Sets s->tlsext_ticket_expected. */
d569 1
a569 1
			s->tlsext_ticket_expected = 1;
d872 2
a873 2
		free(s->tlsext_session_ticket);
		s->tlsext_session_ticket =
d875 1
a875 1
		if (!s->tlsext_session_ticket) {
d882 4
a885 4
			s->tlsext_session_ticket->length = ext_len;
			s->tlsext_session_ticket->data =
			    s->tlsext_session_ticket + 1;
			memcpy(s->tlsext_session_ticket->data,
d888 2
a889 2
			s->tlsext_session_ticket->length = 0;
			s->tlsext_session_ticket->data = NULL;
d953 1
a953 1
	if ((s->session != NULL) && !(s->shutdown & SSL_SENT_SHUTDOWN) &&
@


1.60
log
@Move most of the fields in SSL_CTX to internal - the ones that remain are
known to be in use.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.59 2017/01/23 04:55:27 beck Exp $ */
d188 1
a188 1
	return (CRYPTO_set_ex_data(&s->ex_data, idx, arg));
d194 1
a194 1
	return (CRYPTO_get_ex_data(&s->ex_data, idx));
d216 2
a217 2
	ss->prev = NULL;
	ss->next = NULL;
d225 1
a225 1
	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);
d698 1
a698 1
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);
d965 1
a965 1
	if ((s->next == NULL) || (s->prev == NULL))
d968 1
a968 1
	if (s->next == (SSL_SESSION *)&(ctx->internal->session_cache_tail)) {
d970 1
a970 1
		if (s->prev == (SSL_SESSION *)&(ctx->internal->session_cache_head)) {
d975 2
a976 2
			ctx->internal->session_cache_tail = s->prev;
			s->prev->next =
d980 1
a980 1
		if (s->prev == (SSL_SESSION *)&(ctx->internal->session_cache_head)) {
d982 2
a983 2
			ctx->internal->session_cache_head = s->next;
			s->next->prev =
d987 2
a988 2
			s->next->prev = s->prev;
			s->prev->next = s->next;
d991 1
a991 1
	s->prev = s->next = NULL;
d997 1
a997 1
	if ((s->next != NULL) && (s->prev != NULL))
d1003 2
a1004 2
		s->prev = (SSL_SESSION *)&(ctx->internal->session_cache_head);
		s->next = (SSL_SESSION *)&(ctx->internal->session_cache_tail);
d1006 3
a1008 3
		s->next = ctx->internal->session_cache_head;
		s->next->prev = s;
		s->prev = (SSL_SESSION *)&(ctx->internal->session_cache_head);
@


1.59
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.58 2017/01/23 04:15:28 jsing Exp $ */
d452 1
a452 1
	    !(s->session_ctx->session_cache_mode &
d460 1
a460 1
		ret = lh_SSL_SESSION_retrieve(s->session_ctx->sessions, &data);
d496 1
a496 1
			if (!(s->session_ctx->session_cache_mode &
d596 1
a596 1
	s = lh_SSL_SESSION_insert(ctx->sessions, c);
d601 1
a601 1
	 * ctx->sessions), or we're in trouble.
d641 1
a641 1
				    ctx->session_cache_tail, 0))
d667 1
a667 1
		if ((r = lh_SSL_SESSION_retrieve(ctx->sessions, c)) == c) {
d669 1
a669 1
			r = lh_SSL_SESSION_delete(ctx->sessions, c);
d937 1
a937 1
	tp.cache = s->sessions;
d968 1
a968 1
	if (s->next == (SSL_SESSION *)&(ctx->session_cache_tail)) {
d970 1
a970 1
		if (s->prev == (SSL_SESSION *)&(ctx->session_cache_head)) {
d972 2
a973 2
			ctx->session_cache_head = NULL;
			ctx->session_cache_tail = NULL;
d975 1
a975 1
			ctx->session_cache_tail = s->prev;
d977 1
a977 1
			    (SSL_SESSION *)&(ctx->session_cache_tail);
d980 1
a980 1
		if (s->prev == (SSL_SESSION *)&(ctx->session_cache_head)) {
d982 1
a982 1
			ctx->session_cache_head = s->next;
d984 1
a984 1
			    (SSL_SESSION *)&(ctx->session_cache_head);
d1000 5
a1004 5
	if (ctx->session_cache_head == NULL) {
		ctx->session_cache_head = s;
		ctx->session_cache_tail = s;
		s->prev = (SSL_SESSION *)&(ctx->session_cache_head);
		s->next = (SSL_SESSION *)&(ctx->session_cache_tail);
d1006 1
a1006 1
		s->next = ctx->session_cache_head;
d1008 2
a1009 2
		s->prev = (SSL_SESSION *)&(ctx->session_cache_head);
		ctx->session_cache_head = s;
d1094 1
a1094 1
	ctx->client_cert_engine = e;
@


1.58
log
@Move callback function pointers and argument pointers from SSL_CTX to
internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.57 2017/01/23 01:22:08 jsing Exp $ */
d329 2
a330 2
		if (s->generate_session_id)
			cb = s->generate_session_id;
d852 2
a853 2
	s->tls_session_secret_cb = tls_session_secret_cb;
	s->tls_session_secret_cb_arg = arg;
d863 2
a864 2
	s->tls_session_ticket_ext_cb = cb;
	s->tls_session_ticket_ext_cb_arg = arg;
@


1.57
log
@Move not_resumable and sess_cert from SSL_SESSION to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.56 2017/01/23 00:12:55 jsing Exp $ */
d331 2
a332 2
		else if (s->session_ctx->generate_session_id)
			cb = s->session_ctx->generate_session_id;
d473 1
a473 1
	    s->session_ctx->get_session_cb != NULL) {
d476 2
a477 2
		if ((ret = s->session_ctx->get_session_cb(s, session_id,
		    len, &copy))) {
d677 2
a678 2
			if (ctx->remove_session_cb != NULL)
				ctx->remove_session_cb(ctx, r);
d914 2
a915 2
		if (p->ctx->remove_session_cb != NULL)
			p->ctx->remove_session_cb(p->ctx, s);
d1016 1
a1016 1
	ctx->new_session_cb = cb;
d1022 1
a1022 1
	return ctx->new_session_cb;
d1029 1
a1029 1
	ctx->remove_session_cb = cb;
d1035 1
a1035 1
	return ctx->remove_session_cb;
d1042 1
a1042 1
	ctx->get_session_cb = cb;
d1049 1
a1049 1
	return ctx->get_session_cb;
d1056 1
a1056 1
	ctx->info_callback = cb;
d1062 1
a1062 1
	return ctx->info_callback;
d1069 1
a1069 1
	ctx->client_cert_cb = cb;
d1076 1
a1076 1
	return ctx->client_cert_cb;
d1103 1
a1103 1
	ctx->app_gen_cookie_cb = cb;
d1110 1
a1110 1
	ctx->app_verify_cookie_cb = cb;
@


1.56
log
@Move the stats struct from SSL_CTX to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.55 2017/01/22 05:14:42 beck Exp $ */
d676 1
a676 1
			r->not_resumable = 1;
d702 2
a703 2
	if (ss->sess_cert != NULL)
		ssl_sess_cert_free(ss->sess_cert);
d913 1
a913 1
		s->not_resumable = 1;
@


1.55
log
@Move internal parts of ssl_session_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.54 2017/01/22 03:50:45 jsing Exp $ */
d469 1
a469 1
			s->session_ctx->stats.sess_miss++;
d478 1
a478 1
			s->session_ctx->stats.sess_cb_hit++;
d545 1
a545 1
		s->session_ctx->stats.sess_timeout++;
d553 1
a553 1
	s->session_ctx->stats.sess_hit++;
d644 1
a644 1
					ctx->stats.sess_cache_full++;
@


1.54
log
@Convert publically visible structs to translucent structs.

This change adds an internal opaque struct for each of the significant
publically visible structs. The opaque struct is then allocated and
attached to the publically visible struct when the appropriate *_new()
function is called, then cleared and freed as necessary.

This will allow for changes to be made to the internals of libssl, without
requiring a major bump each time the publically visible structs are
modified.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.53 2016/11/02 11:21:05 jsing Exp $ */
d220 4
a223 4
	ss->tlsext_ecpointformatlist_length = 0;
	ss->tlsext_ecpointformatlist = NULL;
	ss->tlsext_ellipticcurvelist_length = 0;
	ss->tlsext_ellipticcurvelist = NULL;
d709 4
a712 4
	ss->tlsext_ecpointformatlist_length = 0;
	free(ss->tlsext_ecpointformatlist);
	ss->tlsext_ellipticcurvelist_length = 0;
	free(ss->tlsext_ellipticcurvelist);
@


1.53
log
@Expand LHASH_OF, IMPLEMENT_LHASH_DOALL_ARG_FN and LHASH_DOALL_ARG_FN
macros. Only change in generated assembly is due to line numbering.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.52 2016/11/02 09:54:47 jsing Exp $ */
d202 1
a202 2
	ss = calloc(1, sizeof(SSL_SESSION));
	if (ss == NULL) {
d204 6
a209 1
		return (0);
d713 4
@


1.52
log
@Wrap some >80 char lines.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.51 2016/09/04 16:12:33 jsing Exp $ */
d893 1
a893 1
	LHASH_OF(SSL_SESSION) *cache;
d912 8
a919 2
static
IMPLEMENT_LHASH_DOALL_ARG_FN(timeout, SSL_SESSION, TIMEOUT_PARAM)
d936 1
a936 1
	lh_SSL_SESSION_doall_arg(tp.cache, LHASH_DOALL_ARG_FN(timeout),
@


1.51
log
@Sort and group functions.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.50 2016/09/04 16:11:47 jsing Exp $ */
d1102 2
a1103 2
	return PEM_ASN1_write((i2d_of_void *)i2d_SSL_SESSION, PEM_STRING_SSL_SESSION, fp,
	    x, NULL, NULL, 0, NULL, NULL);
d1109 2
a1110 2
	return PEM_ASN1_read((d2i_of_void *)d2i_SSL_SESSION, PEM_STRING_SSL_SESSION, fp,
	    (void **)x, cb, u);
d1116 2
a1117 2
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_SSL_SESSION, PEM_STRING_SSL_SESSION, bp,
	    (void **)x, cb, u);
d1123 2
a1124 2
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_SSL_SESSION, PEM_STRING_SSL_SESSION, bp,
	    x, NULL, NULL, 0, NULL, NULL);
@


1.50
log
@Expand IMPLEMENT_PEM macros.

No change in generated assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.49 2016/03/11 07:08:45 mmcc Exp $ */
d1099 6
d1107 1
a1107 1
PEM_read_bio_SSL_SESSION(BIO *bp, SSL_SESSION **x, pem_password_cb *cb, void *u)
d1109 1
a1109 1
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_SSL_SESSION, PEM_STRING_SSL_SESSION, bp,
d1114 1
a1114 1
PEM_read_SSL_SESSION(FILE *fp, SSL_SESSION **x, pem_password_cb *cb, void *u)
d1116 1
a1116 1
	return PEM_ASN1_read((d2i_of_void *)d2i_SSL_SESSION, PEM_STRING_SSL_SESSION, fp,
a1123 7
	    x, NULL, NULL, 0, NULL, NULL);
}

int
PEM_write_SSL_SESSION(FILE *fp, SSL_SESSION *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_SSL_SESSION, PEM_STRING_SSL_SESSION, fp,
@


1.49
log
@X509_free(3) is NULL-safe, so remove NULL checks before its calls.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.48 2015/09/10 17:57:50 jsing Exp $ */
d1099 28
a1126 1
IMPLEMENT_PEM_rw(SSL_SESSION, SSL_SESSION, PEM_STRING_SSL_SESSION, SSL_SESSION)
@


1.48
log
@Remove support for DTLS_BAD_VER. We do not support non-standard and
incomplete implementations just so that we can interoperate with products
from vendors who have not bothered to fix things in the last ~10 years.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.47 2015/09/10 15:56:26 jsing Exp $ */
d700 1
a700 2
	if (ss->peer != NULL)
		X509_free(ss->peer);
@


1.47
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.46 2015/08/27 06:21:15 doug Exp $ */
a305 1
		case DTLS1_BAD_VER:
@


1.46
log
@Remove SSLv3 support from LibreSSL.

This is the first wave of SSLv3 removal which removes the main SSLv3
functions.  Future commits will remove the rest of the SSLv3 support.

Discussed the plan at c2k15.  Input from jsing@@, beck@@, miod@@, bcook@@,
sthen@@, naddy@@, and deraadt@@.

ok jsing@@, beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.45 2015/07/21 03:34:38 doug Exp $ */
d697 2
a698 2
	OPENSSL_cleanse(ss->master_key, sizeof ss->master_key);
	OPENSSL_cleanse(ss->session_id, sizeof ss->session_id);
d711 1
a711 1
	OPENSSL_cleanse(ss, sizeof(*ss));
@


1.45
log
@Remove duplicate check in libssl.

If len == 0, it already set try_session_cache so there's no need to
check len again.  Fixes Coverity issue 21687.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.44 2014/12/14 15:30:50 jsing Exp $ */
a302 1
		case SSL3_VERSION:
@


1.44
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.43 2014/11/08 15:21:02 jsing Exp $ */
a454 2
		if (len == 0)
			return 0;
@


1.43
log
@Clean up more SSLv2 remnants.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.42 2014/10/18 16:13:16 jsing Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
@


1.42
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.41 2014/09/22 14:26:22 jsing Exp $ */
d241 8
a248 9
 * Even with SSLv2, we have 16 bytes (128 bits) of session ID space.
 * SSLv3/TLSv1 has 32 bytes (256 bits). As such, filling the ID with random
 * gunk repeatedly until we have no conflict is going to complete in one
 * iteration pretty much "most" of the time (btw: understatement). So, if it
 * takes us 10 iterations and we still can't avoid a conflict - well that's a
 * reasonable point to call it quits. Either the RAND code is broken or someone
 * is trying to open roughly very close to 2^128 (or 2^256) SSL sessions to our
 * server. How you might store that many sessions is perhaps a more interesting
 * question...
@


1.41
log
@Refactor and simplify the ECC extension handling. The existing code
effectively built two "static" data structures - instead of doing this,
just use static data structures to start with.

From OpenSSL (part of a larger commit).

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.40 2014/08/11 01:06:22 jsing Exp $ */
a138 1
#include <openssl/rand.h>
d260 1
a260 2
		if (RAND_pseudo_bytes(id, *id_len) <= 0)
			return 0;
@


1.40
log
@Provide a ssl3_get_cipher_by_id() function that allows ciphers to be looked
up by their ID. For one, this avoids an ugly mess in ssl_sess.c, where the
cipher value is manually written into a buffer, just so the cipher can be
located using ssl3_get_cipher_by_char().

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.39 2014/08/10 14:42:56 jsing Exp $ */
a376 20
		}
		if (s->tlsext_ecpointformatlist) {
			free(ss->tlsext_ecpointformatlist);
			if ((ss->tlsext_ecpointformatlist = malloc(s->tlsext_ecpointformatlist_length)) == NULL) {
				SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_MALLOC_FAILURE);
				SSL_SESSION_free(ss);
				return 0;
			}
			ss->tlsext_ecpointformatlist_length = s->tlsext_ecpointformatlist_length;
			memcpy(ss->tlsext_ecpointformatlist, s->tlsext_ecpointformatlist, s->tlsext_ecpointformatlist_length);
		}
		if (s->tlsext_ellipticcurvelist) {
			free(ss->tlsext_ellipticcurvelist);
			if ((ss->tlsext_ellipticcurvelist = malloc(s->tlsext_ellipticcurvelist_length)) == NULL) {
				SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_MALLOC_FAILURE);
				SSL_SESSION_free(ss);
				return 0;
			}
			ss->tlsext_ellipticcurvelist_length = s->tlsext_ellipticcurvelist_length;
			memcpy(ss->tlsext_ellipticcurvelist, s->tlsext_ellipticcurvelist, s->tlsext_ellipticcurvelist_length);
@


1.39
log
@Since we no longer need to support SSLv2-style cipher lists, start
unravelling the maze of function pointers and callbacks by directly
calling ssl3_{get,put}_cipher_by_char() and removing the
ssl_{get,put}_cipher_by_char macros.

Prompted by similar changes in boringssl.

ok guenther.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.38 2014/07/13 16:03:10 beck Exp $ */
d561 1
a561 12
		unsigned char buf[5], *p;
		unsigned long l;

		p = buf;
		l = ret->cipher_id;
		l2n(l, p);

		if ((ret->ssl_version >> 8) >= SSL3_VERSION_MAJOR)
			ret->cipher = ssl3_get_cipher_by_char(&buf[2]);
		else
			ret->cipher = ssl3_get_cipher_by_char(&buf[1]);

@


1.38
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.37 2014/07/12 23:59:11 jsing Exp $ */
d569 1
a569 1
			ret->cipher = ssl_get_cipher_by_char(s, &(buf[2]));
d571 1
a571 1
			ret->cipher = ssl_get_cipher_by_char(s, &(buf[1]));
@


1.37
log
@Apply a large dose of KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.36 2014/07/11 09:24:44 beck Exp $ */
d370 1
a370 1
			ss->tlsext_hostname = BUF_strdup(s->tlsext_hostname);
@


1.36
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.35 2014/07/10 08:51:15 tedu Exp $ */
a137 1
#include <stdio.h>
d140 1
d144 1
d163 3
a165 1
	/* Need to lock this all up rather than just use CRYPTO_add so that
d167 2
a168 1
	 * non-null and when we up the reference count. */
d174 1
d182 2
a183 2
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION, argl, argp,
	new_func, dup_func, free_func);
d221 1
d223 1
d241 11
a251 8
/* Even with SSLv2, we have 16 bytes (128 bits) of session ID space. SSLv3/TLSv1
 * has 32 bytes (256 bits). As such, filling the ID with random gunk repeatedly
 * until we have no conflict is going to complete in one iteration pretty much
 * "most" of the time (btw: understatement). So, if it takes us 10 iterations
 * and we still can't avoid a conflict - well that's a reasonable point to call
 * it quits. Either the RAND code is broken or someone is trying to open roughly
 * very close to 2^128 (or 2^256) SSL sessions to our server. How you might
 * store that many sessions is perhaps a more interesting question ... */
d254 1
d256 1
a256 2
def_generate_session_id(const SSL *ssl, unsigned char *id,
    unsigned int *id_len)
d259 7
a265 5
	do
	if (RAND_pseudo_bytes(id, *id_len) <= 0)
		return 0;
	while (SSL_has_matching_session_id(ssl, id, *id_len) &&
	(++retry < MAX_SESS_ID_ATTEMPTS));
d268 1
a283 2
	/* This gets used by clients and servers. */

d288 4
a291 1
	if ((ss = SSL_SESSION_new()) == NULL) return (0);
d321 2
a322 1
		/* If RFC4507 ticket use empty session ID */
d327 2
a328 1
		/* Choose which callback will set the session ID */
d335 2
a336 1
		/* Choose a session ID */
d345 5
a349 2
		/* Don't allow the callback to set the session length to zero.
		 * nor set it higher than it was. */
d358 2
a359 1
		/* Finally, check for a conflict */
d367 2
a368 1
		sess_id_done:
d372 2
a373 1
				SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);
d407 1
d417 2
a418 1
/* ssl_get_prev attempts to find an SSL_SESSION to be used to resume this
d432 5
a436 4
 *   - If a session is found then s->session is pointed at it (after freeing an
 *     existing session if need be) and s->verify_result is set from the session.
 *   - Both for new and resumed sessions, s->tlsext_ticket_expected is set to 1
 *     if the server should issue a new session ticket (to 0 otherwise).
a441 2
	/* This is used only by servers. */

d447 2
d455 2
a456 1
	r = tls1_process_ticket(s, session_id, len, limit, &ret); /* sets s->tlsext_ticket_expected */
d472 3
a474 3
	if (try_session_cache &&
		ret == NULL &&
	!(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)) {
d481 1
d485 3
a487 2
			/* don't allow other threads to steal it: */
			CRYPTO_add(&ret->references, 1, CRYPTO_LOCK_SSL_SESSION);
d490 1
d495 2
a496 3
	if (try_session_cache &&
		ret == NULL &&
	s->session_ctx->get_session_cb != NULL) {
d499 2
a500 1
		if ((ret = s->session_ctx->get_session_cb(s, session_id, len, &copy))) {
d503 8
a510 5
			/* Increment reference count now if the session callback
			 * asks us to do so (note that if the session structures
			 * returned by the callback are shared between threads,
			 * it must handle the reference count itself [i.e. copy == 0],
			 * or things won't be thread-safe). */
d512 2
a513 1
				CRYPTO_add(&ret->references, 1, CRYPTO_LOCK_SSL_SESSION);
d515 11
a525 6
			/* Add the externally cached session to the internal
			 * cache as well if and only if we are supposed to. */
			if (!(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_STORE))
				/* The following should not return 1, otherwise,
				 * things are very strange */
			SSL_CTX_add_session(s->session_ctx, ret);
d534 3
a536 2
	if (ret->sid_ctx_length != s->sid_ctx_length
	    || timingsafe_memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length) != 0) {
d543 2
a544 1
		/* We can't be sure if this session is being used out of
d546 2
a547 1
		 * The application should have used SSL[_CTX]_set_session_id_context.
d554 2
a555 2

		SSLerr(SSL_F_SSL_GET_PREV_SESSION, SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);
d567 1
d572 1
d577 2
a578 2
	if (ret->timeout < (time(NULL) - ret->time)) /* timeout */
	{
d595 1
a595 1
	err:
d599 4
a602 2
			/* The session was from a ticket, so we should
			 * issue a ticket for the new session */
d618 2
a619 1
	/* add just 1 reference count for the SSL_CTX's session cache
d621 2
a622 1
	 * doubly linked list and an lhash */
a623 1
	/* if session c is in already in cache, we take back the increment later */
d625 4
d632 2
a633 1
	/* s != NULL iff we already had a session with the given PID.
d635 2
a636 1
	 * ctx->sessions), or we're in trouble. */
d641 2
a642 1
		/* ... so pretend the other session did not exist in cache
d645 3
a647 2
		 * two threads concurrently obtain the same session from an external
		 * cache) */
d656 5
a660 3
		/* existing cache entry -- decrement previously incremented reference
		 * count because it already takes into account the cache */

d664 4
a667 1
		/* new cache entry -- remove old ones if cache has become too large */
d673 1
a673 1
			SSL_CTX_sess_get_cache_size(ctx)) {
d675 2
a676 2
					ctx->session_cache_tail, 0))
				break;
d701 1
a701 1
			if ((r = lh_SSL_SESSION_retrieve(ctx->sessions, c)) == c) {
a705 1

d763 2
a764 1
			SSLerr(SSL_F_SSL_SET_SESSION, SSL_R_UNABLE_TO_FIND_SSL_METHOD);
d845 2
a846 1
		SSLerr(SSL_F_SSL_SESSION_SET1_ID_CONTEXT, SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
d859 1
d864 1
d877 3
a879 2
SSL_set_session_secret_cb(SSL *s, int (*tls_session_secret_cb)(SSL *s, void *secret, int *secret_len,
    STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg), void *arg)
d904 2
a905 1
		s->tlsext_session_ticket = malloc(sizeof(TLS_SESSION_TICKET_EXT) + ext_len);
d907 2
a908 1
			SSLerr(SSL_F_SSL_SET_SESSION_TICKET_EXT, ERR_R_MALLOC_FAILURE);
d914 4
a917 2
			s->tlsext_session_ticket->data = s->tlsext_session_ticket + 1;
			memcpy(s->tlsext_session_ticket->data, ext_data, ext_len);
d938 2
a939 2
	if ((p->time == 0) || (p->time > (s->time + s->timeout))) /* timeout */
	{
d978 2
a979 3
	if ((s->session != NULL) &&
		!(s->shutdown & SSL_SENT_SHUTDOWN) &&
	!(SSL_in_init(s) || SSL_in_before(s))) {
d990 2
a991 2
	if ((s->next == NULL)
		|| (s->prev == NULL)) return;
d993 4
a996 4
	if (s->next == (SSL_SESSION *)&(ctx->session_cache_tail))
			{ /* last element in list */
		if (s->prev == (SSL_SESSION *)&(ctx->session_cache_head))
				{ /* only one element in list */
d1001 2
a1002 1
			s->prev->next = (SSL_SESSION *)&(ctx->session_cache_tail);
d1005 2
a1006 2
		if (s->prev == (SSL_SESSION *)&(ctx->session_cache_head))
				{ /* first element in list */
d1008 4
a1011 3
			s->next->prev = (SSL_SESSION *)&(ctx->session_cache_head);
		} else
				{ /* middle of list */
d1044 2
a1045 1
int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(SSL *ssl, SSL_SESSION *sess)
d1057 2
a1058 1
void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(SSL_CTX * ctx, SSL_SESSION *sess)
d1064 2
a1065 3
SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,
    SSL_SESSION *(*cb)(struct ssl_st *ssl,
unsigned char *data, int len, int *copy))
d1070 3
a1072 2
SSL_SESSION * (*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(SSL *ssl,
    unsigned char *data, int len, int *copy)
d1084 2
a1085 1
void (*SSL_CTX_get_info_callback(SSL_CTX *ctx))(const SSL *ssl, int type, int val)
d1097 3
a1099 1
int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL * ssl, X509 ** x509 , EVP_PKEY **pkey)
d1109 2
a1110 1
		SSLerr(SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE, ERR_R_ENGINE_LIB);
d1114 2
a1115 1
		SSLerr(SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE, SSL_R_NO_CLIENT_CERT_METHOD);
@


1.35
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.34 2014/06/21 20:27:25 tedu Exp $ */
a216 4
#ifndef OPENSSL_NO_PSK
	ss->psk_identity_hint = NULL;
	ss->psk_identity = NULL;
#endif
a688 4
#ifndef OPENSSL_NO_PSK
	free(ss->psk_identity_hint);
	free(ss->psk_identity);
#endif
@


1.34
log
@always compare memcmp against 0, for clarity.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.33 2014/06/19 21:29:51 tedu Exp $ */
a209 1
	ss->compress_meth = 0;
d235 1
a235 1
	return s->compress_meth;
@


1.33
log
@convert CRYPTO_memcmp to timingsafe_memcmp based on current policy favoring
libc interfaces over libcrypto interfaces. for now we also prefer
timingsafe_memcmp over timingsafe_bcmp, even when the latter is acceptable.
ok beck deraadt matthew miod
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_sess.c,v 1.32 2014/06/12 15:49:31 deraadt Exp $ */
d501 1
a501 1
	    || timingsafe_memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) {
@


1.32
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d501 1
a501 1
	    || CRYPTO_memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) {
@


1.31
log
@without overthinking it, replace a few memcmp calls with CRYPTO_memcmp
where it is feasible to do so. better safe than sorry.
@
text
@d1 1
a1 1
/* ssl/ssl_sess.c */
@


1.30
log
@ECDH and ECDSA will not work overly well if there is no EC, so unifdef
OPENSSL_NO_EC.

ok tedu@@
@
text
@d501 1
a501 1
		|| memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) {
@


1.29
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@a212 1
#ifndef OPENSSL_NO_EC
a216 1
#endif
a359 1
#ifndef OPENSSL_NO_EC
a379 1
#endif
a689 1
#ifndef OPENSSL_NO_EC
a693 1
#endif /* OPENSSL_NO_EC */
@


1.28
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@a210 1
#ifndef OPENSSL_NO_TLSEXT
a218 1
#endif
a313 1
#ifndef OPENSSL_NO_TLSEXT
a318 1
#endif
a352 1
#ifndef OPENSSL_NO_TLSEXT
a383 1
#endif
a429 1
#ifndef OPENSSL_NO_TLSEXT
a430 1
#endif
a437 1
#ifndef OPENSSL_NO_TLSEXT
a452 1
#endif
a562 1
#ifndef OPENSSL_NO_TLSEXT
a567 1
#endif
a691 1
#ifndef OPENSSL_NO_TLSEXT
a699 1
#endif
a827 1
#ifndef OPENSSL_NO_TLSEXT
a874 1
#endif /* OPENSSL_NO_TLSEXT */
@


1.27
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@d369 1
a369 2
			if (ss->tlsext_ecpointformatlist != NULL)
				free(ss->tlsext_ecpointformatlist);
d379 1
a379 2
			if (ss->tlsext_ellipticcurvelist != NULL)
				free(ss->tlsext_ellipticcurvelist);
d705 2
a706 4
	if (ss->tlsext_hostname != NULL)
		free(ss->tlsext_hostname);
	if (ss->tlsext_tick != NULL)
		free(ss->tlsext_tick);
d709 1
a709 2
	if (ss->tlsext_ecpointformatlist != NULL)
		free(ss->tlsext_ecpointformatlist);
d711 1
a711 2
	if (ss->tlsext_ellipticcurvelist != NULL)
		free(ss->tlsext_ellipticcurvelist);
d715 2
a716 4
	if (ss->psk_identity_hint != NULL)
		free(ss->psk_identity_hint);
	if (ss->psk_identity != NULL)
		free(ss->psk_identity);
d869 1
a869 5
		if (s->tlsext_session_ticket) {
			free(s->tlsext_session_ticket);
			s->tlsext_session_ticket = NULL;
		}

@


1.26
log
@whitespace
@
text
@a225 3
#ifndef OPENSSL_NO_SRP
	ss->srp_username = NULL;
#endif
a725 4
#ifndef OPENSSL_NO_SRP
	if (ss->srp_username != NULL)
		free(ss->srp_username);
#endif
a749 9
#ifndef OPENSSL_NO_KRB5
		if (s->kssl_ctx && !s->kssl_ctx->client_princ &&
		    session->krb5_client_princ_len > 0) {
			s->kssl_ctx->client_princ = malloc(session->krb5_client_princ_len + 1);
			memcpy(s->kssl_ctx->client_princ, session->krb5_client_princ,
			    session->krb5_client_princ_len);
			s->kssl_ctx->client_princ[session->krb5_client_princ_len] = '\0';
		}
#endif /* OPENSSL_NO_KRB5 */
@


1.25
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@d759 1
a759 1
			session->krb5_client_princ_len > 0) {
d762 1
a762 1
			session->krb5_client_princ_len);
@


1.24
log
@Chop off more SSLv2 tentacles and start fixing and noting y2038 issues.
APIs that pass times as longs will have to change at some point...
Bump major on both libcrypto and libssl.

ok tedu@@
@
text
@d198 1
a198 1
	ss = (SSL_SESSION *)malloc(sizeof(SSL_SESSION));
a202 1
	memset(ss, 0, sizeof(SSL_SESSION));
d760 1
a760 1
			s->kssl_ctx->client_princ = (char *)malloc(session->krb5_client_princ_len + 1);
@


1.23
log
@More KNF and style consistency tweaks
@
text
@d208 1
a208 1
	ss->time = (unsigned long)time(NULL);
d558 1
a558 1
	if (ret->timeout < (long)(time(NULL) - ret->time)) /* timeout */
a701 1
	OPENSSL_cleanse(ss->key_arg, sizeof ss->key_arg);
d809 1
d818 1
d930 1
a930 1
	if ((p->time == 0) || (p->time > (s->time+s->timeout))) /* timeout */
d946 1
@


1.22
log
@kill REF_PRINT/REF_CHECK debugging framework noone would use
ok miod
@
text
@a149 2
SSL_SESSION
*SSL_get_session(const SSL *ssl)
d151 2
a156 2
SSL_SESSION
*SSL_get1_session(SSL *ssl)
d158 2
d187 2
a188 2
void
*SSL_SESSION_get_ex_data(const SSL_SESSION *s, int idx)
d193 2
a194 2
SSL_SESSION
*SSL_SESSION_new(void)
d233 2
a234 2
const unsigned char
*SSL_SESSION_get_id(const SSL_SESSION *s, unsigned int *len)
d827 2
a828 2
X509
*SSL_SESSION_get0_peer(SSL_SESSION *s)
@


1.21
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a696 3
#ifdef REF_PRINT
	REF_PRINT("SSL_SESSION", ss);
#endif
a698 6
#ifdef REF_CHECK
	if (i < 0) {
		fprintf(stderr, "SSL_SESSION_free, bad reference count\n");
		abort(); /* ok */
	}
#endif
@


1.20
log
@add back SRP. i was being too greedy.
@
text
@d198 1
a198 1
	ss = (SSL_SESSION *)OPENSSL_malloc(sizeof(SSL_SESSION));
d374 2
a375 2
				OPENSSL_free(ss->tlsext_ecpointformatlist);
			if ((ss->tlsext_ecpointformatlist = OPENSSL_malloc(s->tlsext_ecpointformatlist_length)) == NULL) {
d385 2
a386 2
				OPENSSL_free(ss->tlsext_ellipticcurvelist);
			if ((ss->tlsext_ellipticcurvelist = OPENSSL_malloc(s->tlsext_ellipticcurvelist_length)) == NULL) {
d722 1
a722 1
		OPENSSL_free(ss->tlsext_hostname);
d724 1
a724 1
		OPENSSL_free(ss->tlsext_tick);
d728 1
a728 1
		OPENSSL_free(ss->tlsext_ecpointformatlist);
d731 1
a731 1
		OPENSSL_free(ss->tlsext_ellipticcurvelist);
d736 1
a736 1
		OPENSSL_free(ss->psk_identity_hint);
d738 1
a738 1
		OPENSSL_free(ss->psk_identity);
d742 1
a742 1
		OPENSSL_free(ss->srp_username);
d745 1
a745 1
	OPENSSL_free(ss);
d771 1
a771 1
			s->kssl_ctx->client_princ = (char *)OPENSSL_malloc(session->krb5_client_princ_len + 1);
d903 1
a903 1
			OPENSSL_free(s->tlsext_session_ticket);
d907 1
a907 1
		s->tlsext_session_ticket = OPENSSL_malloc(sizeof(TLS_SESSION_TICKET_EXT) + ext_len);
@


1.19
log
@disentangle SRP code from TLS
@
text
@d227 3
d739 4
@


1.18
log
@Kill the bogus "send an SSLv3/TLS hello in SSLv2 format" crap from
the SSLv23_* client code.  The server continues to accept it.  It
also kills the bits for SSL2 SESSIONs; even when the server gets
an SSLv2-style compat handshake, the session that it creates has
the correct version internally.

ok tedu@@ beck@@
@
text
@a226 3
#ifndef OPENSSL_NO_SRP
	ss->srp_username = NULL;
#endif
a735 4
#endif
#ifndef OPENSSL_NO_SRP
	if (ss->srp_username != NULL)
		OPENSSL_free(ss->srp_username);
@


1.17
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d304 8
a311 5
		if (s->version == SSL2_VERSION) {
			ss->ssl_version = SSL2_VERSION;
			ss->session_id_length = SSL2_SSL_SESSION_ID_LENGTH;
		} else if (s->version == SSL3_VERSION) {
			ss->ssl_version = SSL3_VERSION;
d313 4
a316 17
		} else if (s->version == TLS1_VERSION) {
			ss->ssl_version = TLS1_VERSION;
			ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
		} else if (s->version == TLS1_1_VERSION) {
			ss->ssl_version = TLS1_1_VERSION;
			ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
		} else if (s->version == TLS1_2_VERSION) {
			ss->ssl_version = TLS1_2_VERSION;
			ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
		} else if (s->version == DTLS1_BAD_VER) {
			ss->ssl_version = DTLS1_BAD_VER;
			ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
		} else if (s->version == DTLS1_VERSION) {
			ss->ssl_version = DTLS1_VERSION;
			ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
		} else {
			SSLerr(SSL_F_SSL_GET_NEW_SESSION, SSL_R_UNSUPPORTED_SSL_VERSION);
d352 1
a352 5
		/* If the session length was shrunk and we're SSLv2, pad it */
		if ((tmp < ss->session_id_length) && (s->version == SSL2_VERSION))
			memset(ss->session_id + tmp, 0, ss->session_id_length - tmp);
		else
			ss->session_id_length = tmp;
@


1.16
log
@resolve conflicts
@
text
@d147 1
a147 1
static void SSL_SESSION_list_add(SSL_CTX *ctx,SSL_SESSION *s);
d150 2
a151 1
SSL_SESSION *SSL_get_session(const SSL *ssl)
d153 3
a155 3
	{
	return(ssl->session);
	}
d157 2
a158 1
SSL_SESSION *SSL_get1_session(SSL *ssl)
d160 1
a160 1
	{
d167 1
a167 1
	if(sess)
d170 2
a171 2
	return(sess);
	}
d173 4
a176 3
int SSL_SESSION_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	     CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
	{
d178 2
a179 2
			new_func, dup_func, free_func);
	}
d181 5
a185 4
int SSL_SESSION_set_ex_data(SSL_SESSION *s, int idx, void *arg)
	{
	return(CRYPTO_set_ex_data(&s->ex_data,idx,arg));
	}
d187 5
a191 4
void *SSL_SESSION_get_ex_data(const SSL_SESSION *s, int idx)
	{
	return(CRYPTO_get_ex_data(&s->ex_data,idx));
	}
d193 3
a195 2
SSL_SESSION *SSL_SESSION_new(void)
	{
d198 6
a203 7
	ss=(SSL_SESSION *)OPENSSL_malloc(sizeof(SSL_SESSION));
	if (ss == NULL)
		{
		SSLerr(SSL_F_SSL_SESSION_NEW,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	memset(ss,0,sizeof(SSL_SESSION));
d206 1
a206 1
	ss->references=1;
d208 4
a211 4
	ss->time=(unsigned long)time(NULL);
	ss->prev=NULL;
	ss->next=NULL;
	ss->compress_meth=0;
d213 2
a214 1
	ss->tlsext_hostname = NULL; 
d224 2
a225 2
	ss->psk_identity_hint=NULL;
	ss->psk_identity=NULL;
d228 1
a228 1
	ss->srp_username=NULL;
d230 2
a231 2
	return(ss);
	}
d233 4
a236 3
const unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s, unsigned int *len)
	{
	if(len)
d239 1
a239 1
	}
d241 3
a243 2
unsigned int SSL_SESSION_get_compress_id(const SSL_SESSION *s)
	{
d245 1
a245 1
	}
d257 3
a259 2
static int def_generate_session_id(const SSL *ssl, unsigned char *id,
				unsigned int *id_len)
d263 5
a267 5
		if (RAND_pseudo_bytes(id, *id_len) <= 0)
			return 0;
	while(SSL_has_matching_session_id(ssl, id, *id_len) &&
		(++retry < MAX_SESS_ID_ATTEMPTS));
	if(retry < MAX_SESS_ID_ATTEMPTS)
d281 3
a283 2
int ssl_get_new_session(SSL *s, int session)
	{
d287 1
a287 1
	SSL_SESSION *ss=NULL;
d290 1
a290 1
	if ((ss=SSL_SESSION_new()) == NULL) return(0);
d294 1
a294 1
		ss->timeout=SSL_get_default_timeout(s);
d296 1
a296 1
		ss->timeout=s->session_ctx->session_timeout;
d298 1
a298 2
	if (s->session != NULL)
		{
d300 2
a301 2
		s->session=NULL;
		}
d303 24
a326 40
	if (session)
		{
		if (s->version == SSL2_VERSION)
			{
			ss->ssl_version=SSL2_VERSION;
			ss->session_id_length=SSL2_SSL_SESSION_ID_LENGTH;
			}
		else if (s->version == SSL3_VERSION)
			{
			ss->ssl_version=SSL3_VERSION;
			ss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;
			}
		else if (s->version == TLS1_VERSION)
			{
			ss->ssl_version=TLS1_VERSION;
			ss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;
			}
		else if (s->version == TLS1_1_VERSION)
			{
			ss->ssl_version=TLS1_1_VERSION;
			ss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;
			}
		else if (s->version == TLS1_2_VERSION)
			{
			ss->ssl_version=TLS1_2_VERSION;
			ss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;
			}
		else if (s->version == DTLS1_BAD_VER)
			{
			ss->ssl_version=DTLS1_BAD_VER;
			ss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;
			}
		else if (s->version == DTLS1_VERSION)
			{
			ss->ssl_version=DTLS1_VERSION;
			ss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;
			}
		else
			{
			SSLerr(SSL_F_SSL_GET_NEW_SESSION,SSL_R_UNSUPPORTED_SSL_VERSION);
d328 2
a329 2
			return(0);
			}
d332 1
a332 2
		if (s->tlsext_ticket_expected)
			{
d335 1
a335 1
			}
d339 1
a339 1
		if(s->generate_session_id)
d341 1
a341 1
		else if(s->session_ctx->generate_session_id)
d346 1
a346 2
		if(!cb(s, ss->session_id, &tmp))
			{
d349 1
a349 1
				SSL_R_SSL_SESSION_ID_CALLBACK_FAILED);
d351 2
a352 2
			return(0);
			}
d355 1
a355 2
		if(!tmp || (tmp > ss->session_id_length))
			{
d358 1
a358 1
				SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH);
d360 2
a361 2
			return(0);
			}
d363 1
a363 1
		if((tmp < ss->session_id_length) && (s->version == SSL2_VERSION))
d368 2
a369 3
		if(SSL_has_matching_session_id(s, ss->session_id,
						ss->session_id_length))
			{
d371 1
a371 1
				SSL_R_SSL_SESSION_ID_CONFLICT);
d373 2
a374 2
			return(0);
			}
a382 1
				}
d384 1
d386 4
a389 5
		if (s->tlsext_ecpointformatlist)
			{
			if (ss->tlsext_ecpointformatlist != NULL) OPENSSL_free(ss->tlsext_ecpointformatlist);
			if ((ss->tlsext_ecpointformatlist = OPENSSL_malloc(s->tlsext_ecpointformatlist_length)) == NULL)
				{
d393 1
a393 1
				}
d396 5
a400 6
			}
		if (s->tlsext_ellipticcurvelist)
			{
			if (ss->tlsext_ellipticcurvelist != NULL) OPENSSL_free(ss->tlsext_ellipticcurvelist);
			if ((ss->tlsext_ellipticcurvelist = OPENSSL_malloc(s->tlsext_ellipticcurvelist_length)) == NULL)
				{
d404 1
a404 1
				}
d407 1
a407 1
			}
d410 3
a412 5
		}
	else
		{
		ss->session_id_length=0;
		}
d414 1
a414 2
	if (s->sid_ctx_length > sizeof ss->sid_ctx)
		{
d418 5
a422 5
		}
	memcpy(ss->sid_ctx,s->sid_ctx,s->sid_ctx_length);
	ss->sid_ctx_length=s->sid_ctx_length;
	s->session=ss;
	ss->ssl_version=s->version;
d425 2
a426 2
	return(1);
	}
d447 4
a450 3
int ssl_get_prev_session(SSL *s, unsigned char *session_id, int len,
			const unsigned char *limit)
	{
d453 1
a453 1
	SSL_SESSION *ret=NULL;
d468 1
a468 2
	switch (r)
		{
d481 1
a481 1
		}
d485 2
a486 3
	    ret == NULL &&
	    !(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP))
		{
d488 2
a489 2
		data.ssl_version=s->version;
		data.session_id_length=len;
d492 1
a492 1
		memcpy(data.session_id,session_id,len);
d494 2
a495 3
		ret=lh_SSL_SESSION_retrieve(s->session_ctx->sessions,&data);
		if (ret != NULL)
			{
d497 2
a498 2
			CRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);
			}
d502 1
a502 1
		}
d505 5
a509 7
	    ret == NULL &&
	    s->session_ctx->get_session_cb != NULL)
		{
		int copy=1;
	
		if ((ret=s->session_ctx->get_session_cb(s,session_id,len,&copy)))
			{
d518 1
a518 1
				CRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);
d522 1
a522 1
			if(!(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_STORE))
d525 1
a525 2
				SSL_CTX_add_session(s->session_ctx,ret);
			}
d527 1
d535 1
a535 2
	    || memcmp(ret->sid_ctx,s->sid_ctx,ret->sid_ctx_length))
		{
d539 3
a541 4
		}
	
	if((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0)
		{
d551 2
a552 2
		
		SSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);
d555 1
a555 1
		}
d557 2
a558 3
	if (ret->cipher == NULL)
		{
		unsigned char buf[5],*p;
d561 7
a567 7
		p=buf;
		l=ret->cipher_id;
		l2n(l,p);
		if ((ret->ssl_version>>8) >= SSL3_VERSION_MAJOR)
			ret->cipher=ssl_get_cipher_by_char(s,&(buf[2]));
		else 
			ret->cipher=ssl_get_cipher_by_char(s,&(buf[1]));
d570 1
a570 1
		}
d573 1
a573 1
		{
d575 1
a575 2
		if (try_session_cache)
			{
d577 2
a578 2
			SSL_CTX_remove_session(s->session_ctx,ret);
			}
d580 1
a580 1
		}
d586 1
a586 1
	s->session=ret;
d590 2
a591 3
 err:
	if (ret != NULL)
		{
d594 1
a594 2
		if (!try_session_cache)
			{
d598 1
a598 1
			}
d600 1
a600 1
		}
d605 1
a605 1
	}
d607 4
a610 3
int SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c)
	{
	int ret=0;
d616 1
a616 1
	CRYPTO_add(&c->references,1,CRYPTO_LOCK_SSL_SESSION);
d620 2
a621 2
	s=lh_SSL_SESSION_insert(ctx->sessions,c);
	
d625 1
a625 2
	if (s != NULL && s != c)
		{
d627 1
a627 1
		SSL_SESSION_list_remove(ctx,s);
d635 1
a635 1
		}
d637 1
a637 1
 	/* Put at the head of the queue unless it is already in the cache */
d639 1
a639 1
		SSL_SESSION_list_add(ctx,c);
d641 1
a641 2
	if (s != NULL)
		{
d646 2
a647 4
		ret=0;
		}
	else
		{
a648 2
		
		ret=1;
d650 3
a652 2
		if (SSL_CTX_sess_get_cache_size(ctx) > 0)
			{
d654 1
a654 2
				SSL_CTX_sess_get_cache_size(ctx))
				{
d657 1
a657 1
					break;
a659 1
				}
d662 1
d664 2
a665 2
	return(ret);
	}
d667 2
a668 1
int SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c)
d673 3
a675 2
static int remove_session_lock(SSL_CTX *ctx, SSL_SESSION *c, int lck)
	{
d677 1
a677 1
	int ret=0;
d679 8
a686 9
	if ((c != NULL) && (c->session_id_length != 0))
		{
		if(lck) CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
		if ((r = lh_SSL_SESSION_retrieve(ctx->sessions,c)) == c)
			{
			ret=1;
			r=lh_SSL_SESSION_delete(ctx->sessions,c);
			SSL_SESSION_list_remove(ctx,c);
			}
d688 2
a689 1
		if(lck) CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
d691 2
a692 3
		if (ret)
			{
			r->not_resumable=1;
d694 1
a694 1
				ctx->remove_session_cb(ctx,r);
a695 1
			}
d697 4
a700 4
	else
		ret=0;
	return(ret);
	}
d702 3
a704 2
void SSL_SESSION_free(SSL_SESSION *ss)
	{
d707 2
a708 2
	if(ss == NULL)
	    return;
d710 1
a710 1
	i=CRYPTO_add(&ss->references,-1,CRYPTO_LOCK_SSL_SESSION);
d712 1
a712 1
	REF_PRINT("SSL_SESSION",ss);
d714 2
a715 1
	if (i > 0) return;
d717 2
a718 3
	if (i < 0)
		{
		fprintf(stderr,"SSL_SESSION_free, bad reference count\n");
d720 1
a720 1
		}
d725 9
a733 6
	OPENSSL_cleanse(ss->key_arg,sizeof ss->key_arg);
	OPENSSL_cleanse(ss->master_key,sizeof ss->master_key);
	OPENSSL_cleanse(ss->session_id,sizeof ss->session_id);
	if (ss->sess_cert != NULL) ssl_sess_cert_free(ss->sess_cert);
	if (ss->peer != NULL) X509_free(ss->peer);
	if (ss->ciphers != NULL) sk_SSL_CIPHER_free(ss->ciphers);
d735 4
a738 2
	if (ss->tlsext_hostname != NULL) OPENSSL_free(ss->tlsext_hostname);
	if (ss->tlsext_tick != NULL) OPENSSL_free(ss->tlsext_tick);
d741 2
a742 1
	if (ss->tlsext_ecpointformatlist != NULL) OPENSSL_free(ss->tlsext_ecpointformatlist);
d744 2
a745 1
	if (ss->tlsext_ellipticcurvelist != NULL) OPENSSL_free(ss->tlsext_ellipticcurvelist);
d758 1
a758 1
	OPENSSL_cleanse(ss,sizeof(*ss));
d760 1
a760 1
	}
d762 4
a765 3
int SSL_set_session(SSL *s, SSL_SESSION *session)
	{
	int ret=0;
d768 2
a769 3
	if (session != NULL)
		{
		meth=s->ctx->method->get_ssl_method(session->ssl_version);
d771 5
a775 6
			meth=s->method->get_ssl_method(session->ssl_version);
		if (meth == NULL)
			{
			SSLerr(SSL_F_SSL_SET_SESSION,SSL_R_UNABLE_TO_FIND_SSL_METHOD);
			return(0);
			}
d777 4
a780 5
		if (meth != s->method)
			{
			if (!SSL_set_ssl_method(s,meth))
				return(0);
			}
d783 7
a789 8
                if (s->kssl_ctx && !s->kssl_ctx->client_princ &&
                    session->krb5_client_princ_len > 0)
                {
                    s->kssl_ctx->client_princ = (char *)OPENSSL_malloc(session->krb5_client_princ_len + 1);
                    memcpy(s->kssl_ctx->client_princ,session->krb5_client_princ,
                            session->krb5_client_princ_len);
                    s->kssl_ctx->client_princ[session->krb5_client_princ_len] = '\0';
                }
d793 1
a793 1
		CRYPTO_add(&session->references,1,CRYPTO_LOCK_SSL_SESSION);
d796 1
a796 1
		s->session=session;
d799 5
a803 1
		ret=1;
a804 7
	else
		{
		if (s->session != NULL)
			{
			SSL_SESSION_free(s->session);
			s->session=NULL;
			}
d806 4
a809 7
		meth=s->ctx->method;
		if (meth != s->method)
			{
			if (!SSL_set_ssl_method(s,meth))
				return(0);
			}
		ret=1;
d811 1
a811 1
	return(ret);
d813 2
d816 8
a823 6
long SSL_SESSION_set_timeout(SSL_SESSION *s, long t)
	{
	if (s == NULL) return(0);
	s->timeout=t;
	return(1);
	}
d825 7
a831 5
long SSL_SESSION_get_timeout(const SSL_SESSION *s)
	{
	if (s == NULL) return(0);
	return(s->timeout);
	}
d833 7
a839 5
long SSL_SESSION_get_time(const SSL_SESSION *s)
	{
	if (s == NULL) return(0);
	return(s->time);
	}
d841 8
a848 6
long SSL_SESSION_set_time(SSL_SESSION *s, long t)
	{
	if (s == NULL) return(0);
	s->time=t;
	return(t);
	}
d850 3
a852 2
X509 *SSL_SESSION_get0_peer(SSL_SESSION *s)
	{
d854 1
a854 1
	}
d856 6
a861 6
int SSL_SESSION_set1_id_context(SSL_SESSION *s,const unsigned char *sid_ctx,
			       unsigned int sid_ctx_len)
	{
	if(sid_ctx_len > SSL_MAX_SID_CTX_LENGTH)
		{
		SSLerr(SSL_F_SSL_SESSION_SET1_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
d863 3
a865 3
		}
	s->sid_ctx_length=sid_ctx_len;
	memcpy(s->sid_ctx,sid_ctx,sid_ctx_len);
d868 1
a868 1
	}
d870 3
a872 2
long SSL_CTX_set_timeout(SSL_CTX *s, long t)
	{
d874 6
a879 5
	if (s == NULL) return(0);
	l=s->session_timeout;
	s->session_timeout=t;
	return(l);
	}
d881 7
a887 5
long SSL_CTX_get_timeout(const SSL_CTX *s)
	{
	if (s == NULL) return(0);
	return(s->session_timeout);
	}
d890 6
a895 4
int SSL_set_session_secret_cb(SSL *s, int (*tls_session_secret_cb)(SSL *s, void *secret, int *secret_len,
	STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg), void *arg)
	{
	if (s == NULL) return(0);
d898 2
a899 2
	return(1);
	}
d901 6
a906 4
int SSL_set_session_ticket_ext_cb(SSL *s, tls_session_ticket_ext_cb_fn cb,
				  void *arg)
	{
	if (s == NULL) return(0);
d909 2
a910 2
	return(1);
	}
d912 5
a916 6
int SSL_set_session_ticket_ext(SSL *s, void *ext_data, int ext_len)
	{
	if (s->version >= TLS1_VERSION)
		{
		if (s->tlsext_session_ticket)
			{
d919 1
a919 1
			}
d922 1
a922 2
		if (!s->tlsext_session_ticket)
			{
d925 1
a925 1
			}
d927 1
a927 2
		if (ext_data)
			{
d931 1
a931 3
			}
		else
			{
d934 1
a934 1
			}
d937 1
a937 1
		}
d940 1
a940 1
	}
d943 1
a943 2
typedef struct timeout_param_st
	{
d947 1
a947 1
	} TIMEOUT_PARAM;
d949 4
a952 1
static void timeout_doall_arg(SSL_SESSION *s, TIMEOUT_PARAM *p)
a953 2
	if ((p->time == 0) || (p->time > (s->time+s->timeout))) /* timeout */
		{
d956 3
a958 3
		(void)lh_SSL_SESSION_delete(p->cache,s);
		SSL_SESSION_list_remove(p->ctx,s);
		s->not_resumable=1;
d960 1
a960 1
			p->ctx->remove_session_cb(p->ctx,s);
a961 1
		}
d963 1
d965 2
a966 1
static IMPLEMENT_LHASH_DOALL_ARG_FN(timeout, SSL_SESSION, TIMEOUT_PARAM)
d968 3
a970 2
void SSL_CTX_flush_sessions(SSL_CTX *s, long t)
	{
d974 5
a978 4
	tp.ctx=s;
	tp.cache=s->sessions;
	if (tp.cache == NULL) return;
	tp.time=t;
d980 2
a981 2
	i=CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load;
	CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load=0;
d983 2
a984 2
				 TIMEOUT_PARAM, &tp);
	CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load=i;
d986 1
a986 1
	}
d988 4
a991 3
int ssl_clear_bad_session(SSL *s)
	{
	if (	(s->session != NULL) &&
d993 6
a998 8
		!(SSL_in_init(s) || SSL_in_before(s)))
		{
		SSL_CTX_remove_session(s->ctx,s->session);
		return(1);
		}
	else
		return(0);
	}
d1001 5
a1005 3
static void SSL_SESSION_list_remove(SSL_CTX *ctx, SSL_SESSION *s)
	{
	if ((s->next == NULL) || (s->prev == NULL)) return;
d1008 1
a1008 1
		{ /* last element in list */
d1010 6
a1015 9
			{ /* only one element in list */
			ctx->session_cache_head=NULL;
			ctx->session_cache_tail=NULL;
			}
		else
			{
			ctx->session_cache_tail=s->prev;
			s->prev->next=(SSL_SESSION *)&(ctx->session_cache_tail);
			}
d1017 1
a1017 2
	else
		{
d1019 7
a1025 9
			{ /* first element in list */
			ctx->session_cache_head=s->next;
			s->next->prev=(SSL_SESSION *)&(ctx->session_cache_head);
			}
		else
			{ /* middle of list */
			s->next->prev=s->prev;
			s->prev->next=s->next;
			}
a1026 1
	s->prev=s->next=NULL;
d1028 2
d1031 3
a1033 2
static void SSL_SESSION_list_add(SSL_CTX *ctx, SSL_SESSION *s)
	{
d1035 1
a1035 1
		SSL_SESSION_list_remove(ctx,s);
d1037 10
a1046 14
	if (ctx->session_cache_head == NULL)
		{
		ctx->session_cache_head=s;
		ctx->session_cache_tail=s;
		s->prev=(SSL_SESSION *)&(ctx->session_cache_head);
		s->next=(SSL_SESSION *)&(ctx->session_cache_tail);
		}
	else
		{
		s->next=ctx->session_cache_head;
		s->next->prev=s;
		s->prev=(SSL_SESSION *)&(ctx->session_cache_head);
		ctx->session_cache_head=s;
		}
d1048 1
d1050 5
a1054 5
void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,
	int (*cb)(struct ssl_st *ssl,SSL_SESSION *sess))
	{
	ctx->new_session_cb=cb;
	}
d1057 1
a1057 1
	{
d1059 1
a1059 1
	}
d1061 6
a1066 5
void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,
	void (*cb)(SSL_CTX *ctx,SSL_SESSION *sess))
	{
	ctx->remove_session_cb=cb;
	}
d1068 2
a1069 2
void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(SSL_CTX * ctx,SSL_SESSION *sess)
	{
d1071 1
a1071 1
	}
d1073 7
a1079 6
void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,
	SSL_SESSION *(*cb)(struct ssl_st *ssl,
	         unsigned char *data,int len,int *copy))
	{
	ctx->get_session_cb=cb;
	}
d1082 2
a1083 2
	         unsigned char *data,int len,int *copy)
	{
d1085 1
a1085 1
	}
d1087 6
a1092 5
void SSL_CTX_set_info_callback(SSL_CTX *ctx, 
	void (*cb)(const SSL *ssl,int type,int val))
	{
	ctx->info_callback=cb;
	}
d1094 2
a1095 2
void (*SSL_CTX_get_info_callback(SSL_CTX *ctx))(const SSL *ssl,int type,int val)
	{
d1097 1
a1097 1
	}
d1099 6
a1104 5
void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx,
	int (*cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey))
	{
	ctx->client_cert_cb=cb;
	}
d1107 1
a1107 1
	{
d1109 1
a1109 1
	}
d1112 4
a1115 4
int SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e)
	{
	if (!ENGINE_init(e))
		{
d1118 2
a1119 3
		}
	if(!ENGINE_get_ssl_client_cert_function(e))
		{
d1123 1
a1123 1
		}
d1126 1
a1126 1
	}
d1129 6
a1134 5
void SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx,
	int (*cb)(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len))
	{
	ctx->app_gen_cookie_cb=cb;
	}
d1136 6
a1141 5
void SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx,
	int (*cb)(SSL *ssl, unsigned char *cookie, unsigned int cookie_len))
	{
	ctx->app_verify_cookie_cb=cb;
	}
@


1.15
log
@resolve conflicts, fix local changes
@
text
@d221 3
d234 5
d311 10
d444 19
d470 1
d477 4
d482 2
a483 2
	r = tls1_process_ticket(s, session_id, len, limit, &ret);
	if (r == -1)
d485 1
d488 9
a497 7
	else if (r == 0 || (!ret && !len))
		goto err;
	else if (!ret && !(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP))
#else
	if (len == 0)
		goto err;
	if (!(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP))
d499 4
d513 4
a516 2
		    /* don't allow other threads to steal it: */
		    CRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);
d518 2
d522 3
a524 1
	if (ret == NULL)
d528 1
a528 5
		s->session_ctx->stats.sess_miss++;
		ret=NULL;
		if (s->session_ctx->get_session_cb != NULL
		    && (ret=s->session_ctx->get_session_cb(s,session_id,len,&copy))
		       != NULL)
a546 2
		if (ret == NULL)
			goto err;
d549 4
a552 1
	/* Now ret is non-NULL, and we own one of its reference counts. */
d557 1
a557 1
		/* We've found the session named by the client, but we don't
a558 6

#if 0 /* The client cannot always know when a session is not appropriate,
       * so we shouldn't generate an error message. */

		SSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
#endif
a594 10

#if 0 /* This is way too late. */

	/* If a thread got the session, then 'swaped', and another got
	 * it and then due to a time-out decided to 'OPENSSL_free' it we could
	 * be in trouble.  So I'll increment it now, then double decrement
	 * later - am I speaking rubbish?. */
	CRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);
#endif

d598 5
a602 2
		/* remove it from the cache */
		SSL_CTX_remove_session(s->session_ctx,ret);
a607 4
	/* ret->time=time(NULL); */ /* rezero timeout? */
	/* again, just leave the session 
	 * if it is the same session, we have just incremented and
	 * then decremented the reference count :-) */
d612 1
a612 1
	return(1);
d616 1
d618 9
d777 4
a804 4
			if (s->ctx->session_timeout == 0)
				session->timeout=SSL_get_default_timeout(s);
			else
				session->timeout=s->ctx->session_timeout;
d870 19
@


1.14
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d58 79
d209 6
d217 4
d275 1
a275 1
	if (s->ctx->session_timeout == 0)
d278 1
a278 1
		ss->timeout=s->ctx->session_timeout;
d303 5
d331 2
a332 2
		else if(s->ctx->generate_session_id)
			cb = s->ctx->generate_session_id;
d378 26
d436 1
a436 1
  
d440 1
a440 1
 	r = tls1_process_ticket(s, session_id, len, limit, &ret);
d444 1
a444 1
 		goto err;
d452 1
a452 1
	if (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP))
d460 1
a460 1
 		memcpy(data.session_id,session_id,len);
d462 1
a462 1
		ret=(SSL_SESSION *)lh_retrieve(s->ctx->sessions,&data);
d473 1
a473 1
		s->ctx->stats.sess_miss++;
d475 2
a476 2
		if (s->ctx->get_session_cb != NULL
		    && (ret=s->ctx->get_session_cb(s,session_id,len,&copy))
d479 1
a479 1
			s->ctx->stats.sess_cb_hit++;
d491 1
a491 1
			if(!(s->ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_STORE))
d494 1
a494 1
				SSL_CTX_add_session(s->ctx,ret);
d541 1
a541 1
		if ((ret->ssl_version>>8) == SSL3_VERSION_MAJOR)
d561 1
a561 1
		s->ctx->stats.sess_timeout++;
d563 1
a563 1
		SSL_CTX_remove_session(s->ctx,ret);
d567 1
a567 1
	s->ctx->stats.sess_hit++;
d600 1
a600 1
	s=(SSL_SESSION *)lh_insert(ctx->sessions,c);
d666 1
a666 1
		if ((r = (SSL_SESSION *)lh_retrieve(ctx->sessions,c)) == c)
d669 1
a669 1
			r=(SSL_SESSION *)lh_delete(ctx->sessions,c);
d719 12
d739 1
a739 1
	SSL_METHOD *meth;
d842 55
d901 1
a901 1
	LHASH *cache;
d904 1
a904 1
static void timeout(SSL_SESSION *s, TIMEOUT_PARAM *p)
d910 1
a910 1
		lh_delete(p->cache,s);
d919 1
a919 1
static IMPLEMENT_LHASH_DOALL_ARG_FN(timeout, SSL_SESSION *, TIMEOUT_PARAM *)
d931 5
a935 4
	i=tp.cache->down_load;
	tp.cache->down_load=0;
	lh_doall_arg(tp.cache, LHASH_DOALL_ARG_FN(timeout), &tp);
	tp.cache->down_load=i;
d1095 1
@


1.13
log
@resolve conflicts
@
text
@d62 3
d875 19
@


1.12
log
@resolve conflicts
@
text
@d125 3
d132 7
d154 1
a154 1
		if(RAND_pseudo_bytes(id, *id_len) <= 0)
d211 5
d222 8
d271 11
d303 2
a304 1
int ssl_get_prev_session(SSL *s, unsigned char *session_id, int len)
d308 1
a308 1
	SSL_SESSION *ret=NULL,data;
d310 4
a313 3

	data.ssl_version=s->version;
	data.session_id_length=len;
d316 13
a328 2
	memcpy(data.session_id,session_id,len);

d330 1
d332 6
d379 3
a381 4
	if((s->verify_mode&SSL_VERIFY_PEER)
	   && (!s->sid_ctx_length || ret->sid_ctx_length != s->sid_ctx_length
	       || memcmp(ret->sid_ctx,s->sid_ctx,ret->sid_ctx_length)))
	    {
a383 7
		
		if (s->sid_ctx_length == 0)
			{
			/* application should have used SSL[_CTX]_set_session_id_context
			 * -- we could tolerate this and just pretend we never heard
			 * of this session, but then applications could effectively
			 * disable the session cache by accident without anyone noticing */
a384 6
			SSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);
			fatal = 1;
			goto err;
			}
		else
			{
d386 1
a386 1
	   * so we shouldn't generate an error message. */
d388 1
a388 1
			SSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
d390 18
a407 2
			goto err; /* treat like cache miss */
			}
d593 4
d631 1
a631 1
                    s->kssl_ctx->client_princ = (char *)malloc(session->krb5_client_princ_len + 1);
d814 69
@


1.11
log
@resolve conflicts
@
text
@d121 1
a121 1
	ss->time=time(NULL);
d380 1
a380 1
	if ((long)(ret->time+ret->timeout) < (long)time(NULL)) /* timeout */
@


1.10
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d68 1
a68 1
SSL_SESSION *SSL_get_session(SSL *ssl)
d101 1
a101 1
void *SSL_SESSION_get_ex_data(SSL_SESSION *s, int idx)
d144 2
a145 1
		RAND_pseudo_bytes(id, *id_len);
d613 1
a613 1
long SSL_SESSION_get_timeout(SSL_SESSION *s)
d619 1
a619 1
long SSL_SESSION_get_time(SSL_SESSION *s)
d641 1
a641 1
long SSL_CTX_get_timeout(SSL_CTX *s)
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d81 1
a81 1
	CRYPTO_r_lock(CRYPTO_LOCK_SSL_SESSION);
d85 1
a85 1
	CRYPTO_r_unlock(CRYPTO_LOCK_SSL_SESSION);
@


1.8
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d311 6
a316 3
			/* The following should not return 1, otherwise,
			 * things are very strange */
			SSL_CTX_add_session(s->ctx,ret);
d530 3
a532 3
	memset(ss->key_arg,0,SSL_MAX_KEY_ARG_LENGTH);
	memset(ss->master_key,0,SSL_MAX_MASTER_KEY_LENGTH);
	memset(ss->session_id,0,SSL_MAX_SSL_SESSION_ID_LENGTH);
d536 1
a536 1
	memset(ss,0,sizeof(*ss));
@


1.7
log
@apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@d253 6
a258 1
	die(s->sid_ctx_length <= sizeof ss->sid_ctx);
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d253 1
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@a66 2
static int ssl_session_num=0;
static STACK_OF(CRYPTO_EX_DATA_FUNCS) *ssl_session_meth=NULL;
d92 2
a93 4
	ssl_session_num++;
	return(CRYPTO_get_ex_new_index(ssl_session_num-1,
		&ssl_session_meth,
		argl,argp,new_func,dup_func,free_func));
d125 1
a125 1
	CRYPTO_new_ex_data(ssl_session_meth,ss,&ss->ex_data);
d129 32
d165 1
d167 1
d206 35
a240 2

		for (;;)
d242 4
a245 16
			SSL_SESSION *r;

			RAND_pseudo_bytes(ss->session_id,ss->session_id_length);
			CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
			r=(SSL_SESSION *)lh_retrieve(s->ctx->sessions, ss);
			CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
			if (r == NULL) break;
			/* else - woops a session_id match */
			/* XXX We should also check the external cache --
			 * but the probability of a collision is negligible, and
			 * we could not prevent the concurrent creation of sessions
			 * with identical IDs since we currently don't have means
			 * to atomically check whether a session ID already exists
			 * and make a reservation for it if it does not
			 * (this problem applies to the internal cache as well).
			 */
d477 1
a477 2
		r=(SSL_SESSION *)lh_delete(ctx->sessions,c);
		if (r != NULL)
d480 1
d519 1
a519 1
	CRYPTO_free_ex_data(ssl_session_meth,ss,&ss->ex_data);
d557 11
d659 2
d673 1
a673 1
	lh_doall_arg(tp.cache,(void (*)())timeout,&tp);
@


1.5.4.1
log
@Pull in patch from current:
Fix (markus), errata 013:
apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@a201 1
	die(s->sid_ctx_length <= sizeof ss->sid_ctx);
@


1.5.2.1
log
@Errata #030 (markus):
Fixes for the "OpenSSL Security Advisory [30 July 2002]"
@
text
@a201 1
	die(s->sid_ctx_length <= sizeof ss->sid_ctx);
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d511 1
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d114 1
a114 1
	ss=(SSL_SESSION *)Malloc(sizeof(SSL_SESSION));
d313 1
a313 1
	 * it and then due to a time-out decided to 'Free' it we could
d477 1
a477 1
	Free(ss);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d68 1
a68 1
static STACK *ssl_session_meth=NULL;
d71 1
d76 17
a92 2
int SSL_SESSION_get_ex_new_index(long argl, char *argp, int (*new_func)(),
	     int (*dup_func)(), void (*free_func)())
d122 1
d129 1
a129 1
	CRYPTO_new_ex_data(ssl_session_meth,(char *)ss,&ss->ex_data);
d181 1
a181 1
			RAND_bytes(ss->session_id,ss->session_id_length);
d183 1
a183 2
			r=(SSL_SESSION *)lh_retrieve(s->ctx->sessions,
				(char *)ss);
d187 8
a194 2
			/* XXX should also check external cache!
			 * (But the probability of a collision is negligible, anyway...) */
d206 1
a217 1
	/* conn_init();*/
d227 1
a227 1
		ret=(SSL_SESSION *)lh_retrieve(s->ctx->sessions,(char *)&data);
d336 1
d353 3
a355 1
	/* conn_init(); */
d357 1
d360 1
a360 1
	s=(SSL_SESSION *)lh_insert(ctx->sessions,(char *)c);
d362 17
a378 1
	/* Put on the end of the queue unless it is already in the cache */
a381 4
	/* If the same session if is being 're-added', Free the old
	 * one when the last person stops using it.
	 * This will also work if it is alread in the cache.
	 * The references will go up and then down :-) */
d384 4
a387 1
		SSL_SESSION_free(s);
d392 2
d426 1
a426 1
		r=(SSL_SESSION *)lh_delete(ctx->sessions,(char *)c);
d468 1
a468 1
	CRYPTO_free_ex_data(ssl_session_meth,(char *)ss,&ss->ex_data);
d587 1
a587 1
		lh_delete(p->cache,(char *)s);
d608 1
a608 1
	lh_doall_arg(tp.cache,(void (*)())timeout,(char *)&tp);
@


1.1
log
@Initial revision
@
text
@d60 2
a61 2
#include "lhash.h"
#include "rand.h"
a63 1
#ifndef NOPROTO
d66 2
a67 6
#else
static void SSL_SESSION_list_remove();
static void SSL_SESSION_list_add();
#endif

static ssl_session_num=0;
d70 1
a70 2
SSL_SESSION *SSL_get_session(ssl)
SSL *ssl;
d75 5
a79 9
int SSL_SESSION_get_ex_new_index(argl,argp,new_func,dup_func,free_func)
long argl;
char *argp;
int (*new_func)();
int (*dup_func)();
void (*free_func)();
        {
        ssl_session_num++;
        return(CRYPTO_get_ex_new_index(ssl_session_num-1,
d81 2
a82 2
                argl,argp,new_func,dup_func,free_func));
        }
d84 1
a84 4
int SSL_SESSION_set_ex_data(s,idx,arg)
SSL_SESSION *s;
int idx;
char *arg;
d89 1
a89 3
char *SSL_SESSION_get_ex_data(s,idx)
SSL_SESSION *s;
int idx;
d94 1
a94 1
SSL_SESSION *SSL_SESSION_new()
d111 1
d116 1
a116 3
int ssl_get_new_session(s, session)
SSL *s;
int session;
d118 2
d125 1
a125 1
	if (s->ctx->session_timeout != 0)
d127 2
d138 1
a138 1
		if (s->version == SSL2_CLIENT_VERSION)
d171 2
d180 2
d188 1
a188 4
int ssl_get_prev_session(s,session_id,len)
SSL *s;
unsigned char *session_id;
int len;
d190 2
d193 1
d199 2
a200 2
		return(0);
	memcpy(data.session_id,session_id,len);;
d206 3
d215 2
a216 2

		s->ctx->sess_miss++;
d218 13
a230 5
		if ((s->ctx->get_session_cb != NULL) &&
			((ret=s->ctx->get_session_cb(s,session_id,len,&copy))
				!= NULL))
			{
			s->ctx->sess_cb_hit++;
a234 3
			/* auto free it */
			if (!copy)
				SSL_SESSION_free(ret);
d236 33
a268 1
		if (ret == NULL) return(0);
d273 1
a273 1
		char buf[5],*p;
d284 1
a284 1
			return(0);
d287 3
d295 1
d299 1
a299 1
		s->ctx->sess_timeout++;
d302 1
a302 2
		SSL_SESSION_free(ret);		/* again to actually Free it */
		return(0);
d305 1
a305 1
	s->ctx->sess_hit++;
d315 8
d325 1
a325 3
int SSL_CTX_add_session(ctx,c)
SSL_CTX *ctx;
SSL_SESSION *c;
d358 2
a359 2
				if (!SSL_CTX_remove_session(ctx,
					ctx->session_cache_tail))
d362 1
a362 1
					ctx->sess_cache_full++;
d370 6
a375 3
int SSL_CTX_remove_session(ctx,c)
SSL_CTX *ctx;
SSL_SESSION *c;
d382 1
a382 1
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
d390 1
a390 1
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
d405 1
a405 2
void SSL_SESSION_free(ss)
SSL_SESSION *ss;
d409 3
d430 1
a430 1
	if (ss->cert != NULL) ssl_cert_free(ss->cert);
d432 1
a432 1
	if (ss->ciphers != NULL) sk_free(ss->ciphers);
d437 1
a437 3
int SSL_set_session(s, session)
SSL *s;
SSL_SESSION *session;
d457 4
a460 1
			session->timeout=SSL_get_default_timeout(s);
d478 8
d490 1
a490 3
long SSL_SESSION_set_timeout(s,t)
SSL_SESSION *s;
long t;
d497 1
a497 2
long SSL_SESSION_get_timeout(s)
SSL_SESSION *s;
d503 1
a503 2
long SSL_SESSION_get_time(s)
SSL_SESSION *s;
d509 1
a509 3
long SSL_SESSION_set_time(s,t)
SSL_SESSION *s;
long t;
d516 15
d538 1
a538 3
static void timeout(s,p)
SSL_SESSION *s;
TIMEOUT_PARAM *p;
d553 1
a553 3
void SSL_CTX_flush_sessions(s,t)
SSL_CTX *s;
long t;
d559 1
a559 1
	tp.cache=SSL_CTX_sessions(s);
d570 1
a570 2
int ssl_clear_bad_session(s)
SSL *s;
d584 1
a584 3
static void SSL_SESSION_list_remove(ctx,s)
SSL_CTX *ctx;
SSL_SESSION *s;
d617 1
a617 3
static void SSL_SESSION_list_add(ctx,s)
SSL_CTX *ctx;
SSL_SESSION *s;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d60 2
a61 2
#include <openssl/lhash.h>
#include <openssl/rand.h>
d64 1
d67 7
a73 1
static int remove_session_lock(SSL_CTX *ctx, SSL_SESSION *c, int lck);
d75 2
a76 2
SSL_SESSION *SSL_get_session(SSL *ssl)
/* aka SSL_get0_session; gets 0 objects, just returns a copy of the pointer */
d81 17
a97 23
SSL_SESSION *SSL_get1_session(SSL *ssl)
/* variant of SSL_get_session: caller really gets something */
	{
	SSL_SESSION *sess;
	/* Need to lock this all up rather than just use CRYPTO_add so that
	 * somebody doesn't free ssl->session between when we check it's
	 * non-null and when we up the reference count. */
	CRYPTO_r_lock(CRYPTO_LOCK_SSL_SESSION);
	sess = ssl->session;
	if(sess)
		sess->references++;
	CRYPTO_r_unlock(CRYPTO_LOCK_SSL_SESSION);
	return(sess);
	}

int SSL_SESSION_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	     CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
	{
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION, argl, argp,
			new_func, dup_func, free_func);
	}

int SSL_SESSION_set_ex_data(SSL_SESSION *s, int idx, void *arg)
d102 3
a104 1
void *SSL_SESSION_get_ex_data(SSL_SESSION *s, int idx)
d109 1
a109 1
SSL_SESSION *SSL_SESSION_new(void)
d113 1
a113 1
	ss=(SSL_SESSION *)OPENSSL_malloc(sizeof(SSL_SESSION));
a120 1
	ss->verify_result = 1; /* avoid 0 (= X509_V_OK) just in case */
d126 1
a126 2
	ss->compress_meth=0;
	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);
d130 3
a132 33
/* Even with SSLv2, we have 16 bytes (128 bits) of session ID space. SSLv3/TLSv1
 * has 32 bytes (256 bits). As such, filling the ID with random gunk repeatedly
 * until we have no conflict is going to complete in one iteration pretty much
 * "most" of the time (btw: understatement). So, if it takes us 10 iterations
 * and we still can't avoid a conflict - well that's a reasonable point to call
 * it quits. Either the RAND code is broken or someone is trying to open roughly
 * very close to 2^128 (or 2^256) SSL sessions to our server. How you might
 * store that many sessions is perhaps a more interesting question ... */

#define MAX_SESS_ID_ATTEMPTS 10
static int def_generate_session_id(const SSL *ssl, unsigned char *id,
				unsigned int *id_len)
{
	unsigned int retry = 0;
	do
		RAND_pseudo_bytes(id, *id_len);
	while(SSL_has_matching_session_id(ssl, id, *id_len) &&
		(++retry < MAX_SESS_ID_ATTEMPTS));
	if(retry < MAX_SESS_ID_ATTEMPTS)
		return 1;
	/* else - woops a session_id match */
	/* XXX We should also check the external cache --
	 * but the probability of a collision is negligible, and
	 * we could not prevent the concurrent creation of sessions
	 * with identical IDs since we currently don't have means
	 * to atomically check whether a session ID already exists
	 * and make a reservation for it if it does not
	 * (this problem applies to the internal cache as well).
	 */
	return 0;
}

int ssl_get_new_session(SSL *s, int session)
a133 3
	/* This gets used by clients and servers. */

	unsigned int tmp;
a134 1
	GEN_SESSION_CB cb = def_generate_session_id;
d139 1
a139 1
	if (s->ctx->session_timeout == 0)
a140 2
	else
		ss->timeout=s->ctx->session_timeout;
d150 1
a150 1
		if (s->version == SSL2_VERSION)
d171 2
a172 35
		/* Choose which callback will set the session ID */
		CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
		if(s->generate_session_id)
			cb = s->generate_session_id;
		else if(s->ctx->generate_session_id)
			cb = s->ctx->generate_session_id;
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
		/* Choose a session ID */
		tmp = ss->session_id_length;
		if(!cb(s, ss->session_id, &tmp))
			{
			/* The callback failed */
			SSLerr(SSL_F_SSL_GET_NEW_SESSION,
				SSL_R_SSL_SESSION_ID_CALLBACK_FAILED);
			SSL_SESSION_free(ss);
			return(0);
			}
		/* Don't allow the callback to set the session length to zero.
		 * nor set it higher than it was. */
		if(!tmp || (tmp > ss->session_id_length))
			{
			/* The callback set an illegal length */
			SSLerr(SSL_F_SSL_GET_NEW_SESSION,
				SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH);
			SSL_SESSION_free(ss);
			return(0);
			}
		/* If the session length was shrunk and we're SSLv2, pad it */
		if((tmp < ss->session_id_length) && (s->version == SSL2_VERSION))
			memset(ss->session_id + tmp, 0, ss->session_id_length - tmp);
		else
			ss->session_id_length = tmp;
		/* Finally, check for a conflict */
		if(SSL_has_matching_session_id(s, ss->session_id,
						ss->session_id_length))
d174 9
a182 4
			SSLerr(SSL_F_SSL_GET_NEW_SESSION,
				SSL_R_SSL_SESSION_ID_CONFLICT);
			SSL_SESSION_free(ss);
			return(0);
a189 2
	memcpy(ss->sid_ctx,s->sid_ctx,s->sid_ctx_length);
	ss->sid_ctx_length=s->sid_ctx_length;
a191 1
	ss->verify_result = X509_V_OK;
d196 4
a199 1
int ssl_get_prev_session(SSL *s, unsigned char *session_id, int len)
a200 2
	/* This is used only by servers. */

a201 1
	int fatal = 0;
d203 1
d207 2
a208 2
		goto err;
	memcpy(data.session_id,session_id,len);
d213 1
a213 4
		ret=(SSL_SESSION *)lh_retrieve(s->ctx->sessions,&data);
		if (ret != NULL)
		    /* don't allow other threads to steal it: */
		    CRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);
d220 2
a221 2
	
		s->ctx->stats.sess_miss++;
d223 5
a227 13
		if (s->ctx->get_session_cb != NULL
		    && (ret=s->ctx->get_session_cb(s,session_id,len,&copy))
		       != NULL)
			{
			s->ctx->stats.sess_cb_hit++;

			/* Increment reference count now if the session callback
			 * asks us to do so (note that if the session structures
			 * returned by the callback are shared between threads,
			 * it must handle the reference count itself [i.e. copy == 0],
			 * or things won't be thread-safe). */
			if (copy)
				CRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);
d232 3
d236 1
a236 33
		if (ret == NULL)
			goto err;
		}

	/* Now ret is non-NULL, and we own one of its reference counts. */

	if((s->verify_mode&SSL_VERIFY_PEER)
	   && (!s->sid_ctx_length || ret->sid_ctx_length != s->sid_ctx_length
	       || memcmp(ret->sid_ctx,s->sid_ctx,ret->sid_ctx_length)))
	    {
		/* We've found the session named by the client, but we don't
		 * want to use it in this context. */
		
		if (s->sid_ctx_length == 0)
			{
			/* application should have used SSL[_CTX]_set_session_id_context
			 * -- we could tolerate this and just pretend we never heard
			 * of this session, but then applications could effectively
			 * disable the session cache by accident without anyone noticing */

			SSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);
			fatal = 1;
			goto err;
			}
		else
			{
#if 0 /* The client cannot always know when a session is not appropriate,
	   * so we shouldn't generate an error message. */

			SSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
#endif
			goto err; /* treat like cache miss */
			}
d241 1
a241 1
		unsigned char buf[5],*p;
d252 1
a252 1
			goto err;
a254 3

#if 0 /* This is way too late. */

d256 1
a256 1
	 * it and then due to a time-out decided to 'OPENSSL_free' it we could
a259 1
#endif
d263 1
a263 1
		s->ctx->stats.sess_timeout++;
d266 2
a267 1
		goto err;
d270 1
a270 1
	s->ctx->stats.sess_hit++;
a278 1
	s->verify_result = s->session->verify_result;
a279 8

 err:
	if (ret != NULL)
		SSL_SESSION_free(ret);
	if (fatal)
		return -1;
	else
		return 0;
d282 3
a284 1
int SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c)
d289 1
a289 3
	/* add just 1 reference count for the SSL_CTX's session cache
	 * even though it has two ways of access: each session is in a
	 * doubly linked list and an lhash */
a290 1
	/* if session c is in already in cache, we take back the increment later */
d293 1
a293 1
	s=(SSL_SESSION *)lh_insert(ctx->sessions,c);
d295 1
a295 17
	/* s != NULL iff we already had a session with the given PID.
	 * In this case, s == c should hold (then we did not really modify
	 * ctx->sessions), or we're in trouble. */
	if (s != NULL && s != c)
		{
		/* We *are* in trouble ... */
		SSL_SESSION_list_remove(ctx,s);
		SSL_SESSION_free(s);
		/* ... so pretend the other session did not exist in cache
		 * (we cannot handle two SSL_SESSION structures with identical
		 * session ID in the same cache, which could happen e.g. when
		 * two threads concurrently obtain the same session from an external
		 * cache) */
		s = NULL;
		}

 	/* Put at the head of the queue unless it is already in the cache */
d299 4
d305 1
a305 4
		/* existing cache entry -- decrement previously incremented reference
		 * count because it already takes into account the cache */

		SSL_SESSION_free(s); /* s == c */
a309 2
		/* new cache entry -- remove old ones if cache has become too large */
		
d317 2
a318 2
				if (!remove_session_lock(ctx,
					ctx->session_cache_tail, 0))
d321 1
a321 1
					ctx->stats.sess_cache_full++;
d329 3
a331 6
int SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c)
{
	return remove_session_lock(ctx, c, 1);
}

static int remove_session_lock(SSL_CTX *ctx, SSL_SESSION *c, int lck)
d338 3
a340 2
		if(lck) CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
		if ((r = (SSL_SESSION *)lh_retrieve(ctx->sessions,c)) == c)
a342 1
			r=(SSL_SESSION *)lh_delete(ctx->sessions,c);
d346 1
a346 1
		if(lck) CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
d361 2
a362 1
void SSL_SESSION_free(SSL_SESSION *ss)
a365 3
	if(ss == NULL)
	    return;

d379 1
a379 1
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);
d384 1
a384 1
	if (ss->sess_cert != NULL) ssl_sess_cert_free(ss->sess_cert);
d386 1
a386 1
	if (ss->ciphers != NULL) sk_SSL_CIPHER_free(ss->ciphers);
d388 1
a388 1
	OPENSSL_free(ss);
d391 3
a393 1
int SSL_set_session(SSL *s, SSL_SESSION *session)
d413 2
a414 16
			if (s->ctx->session_timeout == 0)
				session->timeout=SSL_get_default_timeout(s);
			else
				session->timeout=s->ctx->session_timeout;
			}

#ifndef OPENSSL_NO_KRB5
                if (s->kssl_ctx && !s->kssl_ctx->client_princ &&
                    session->krb5_client_princ_len > 0)
                {
                    s->kssl_ctx->client_princ = (char *)malloc(session->krb5_client_princ_len + 1);
                    memcpy(s->kssl_ctx->client_princ,session->krb5_client_princ,
                            session->krb5_client_princ_len);
                    s->kssl_ctx->client_princ[session->krb5_client_princ_len] = '\0';
                }
#endif /* OPENSSL_NO_KRB5 */
a420 1
		s->verify_result = s->session->verify_result;
a430 8

		meth=s->ctx->method;
		if (meth != s->method)
			{
			if (!SSL_set_ssl_method(s,meth))
				return(0);
			}
		ret=1;
d435 3
a437 1
long SSL_SESSION_set_timeout(SSL_SESSION *s, long t)
d444 2
a445 1
long SSL_SESSION_get_timeout(SSL_SESSION *s)
d451 2
a452 1
long SSL_SESSION_get_time(SSL_SESSION *s)
d458 3
a460 1
long SSL_SESSION_set_time(SSL_SESSION *s, long t)
a466 15
long SSL_CTX_set_timeout(SSL_CTX *s, long t)
	{
	long l;
	if (s == NULL) return(0);
	l=s->session_timeout;
	s->session_timeout=t;
	return(l);
	}

long SSL_CTX_get_timeout(SSL_CTX *s)
	{
	if (s == NULL) return(0);
	return(s->session_timeout);
	}

d474 3
a476 1
static void timeout(SSL_SESSION *s, TIMEOUT_PARAM *p)
d482 1
a482 1
		lh_delete(p->cache,s);
d491 3
a493 3
static IMPLEMENT_LHASH_DOALL_ARG_FN(timeout, SSL_SESSION *, TIMEOUT_PARAM *)

void SSL_CTX_flush_sessions(SSL_CTX *s, long t)
d499 1
a499 1
	tp.cache=s->sessions;
d505 1
a505 1
	lh_doall_arg(tp.cache, LHASH_DOALL_ARG_FN(timeout), &tp);
d510 2
a511 1
int ssl_clear_bad_session(SSL *s)
d525 3
a527 1
static void SSL_SESSION_list_remove(SSL_CTX *ctx, SSL_SESSION *s)
d560 3
a562 1
static void SSL_SESSION_list_add(SSL_CTX *ctx, SSL_SESSION *s)
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a62 1
#include "cryptlib.h"
a252 1
	die(s->sid_ctx_length <= sizeof ss->sid_ctx);
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d254 1
a254 6
	if (s->sid_ctx_length > sizeof ss->sid_ctx)
		{
		SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);
		SSL_SESSION_free(ss);
		return 0;
		}
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@d312 3
a314 6
			/* Add the externally cached session to the internal
			 * cache as well if and only if we are supposed to. */
			if(!(s->ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_STORE))
				/* The following should not return 1, otherwise,
				 * things are very strange */
				SSL_CTX_add_session(s->ctx,ret);
d528 3
a530 3
	OPENSSL_cleanse(ss->key_arg,sizeof ss->key_arg);
	OPENSSL_cleanse(ss->master_key,sizeof ss->master_key);
	OPENSSL_cleanse(ss->session_id,sizeof ss->session_id);
d534 1
a534 1
	OPENSSL_cleanse(ss,sizeof(*ss));
@


1.1.1.6
log
@import 0.9.7c
@
text
@d82 1
a82 1
	CRYPTO_w_lock(CRYPTO_LOCK_SSL_SESSION);
d86 1
a86 1
	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_SESSION);
@


1.1.1.7
log
@import openssl-0.9.7d
@
text
@d63 1
@


1.1.1.8
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d68 1
a68 1
SSL_SESSION *SSL_get_session(const SSL *ssl)
d101 1
a101 1
void *SSL_SESSION_get_ex_data(const SSL_SESSION *s, int idx)
d144 1
a144 2
		if(RAND_pseudo_bytes(id, *id_len) <= 0)
			return 0;
d612 1
a612 1
long SSL_SESSION_get_timeout(const SSL_SESSION *s)
d618 1
a618 1
long SSL_SESSION_get_time(const SSL_SESSION *s)
d640 1
a640 1
long SSL_CTX_get_timeout(const SSL_CTX *s)
@


1.1.1.9
log
@import of openssl-0.9.7j
@
text
@d121 1
a121 1
	ss->time=(unsigned long)time(NULL);
d380 1
a380 1
	if (ret->timeout < (long)(time(NULL) - ret->time)) /* timeout */
@


1.1.1.10
log
@import of OpenSSL 0.9.8h
@
text
@a124 3
#ifndef OPENSSL_NO_TLSEXT
	ss->tlsext_hostname = NULL; 
#endif
a128 7
const unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s, unsigned int *len)
	{
	if(len)
		*len = s->session_id_length;
	return s->session_id;
	}

d144 1
a144 1
		if (RAND_pseudo_bytes(id, *id_len) <= 0)
a200 5
		else if (s->version == DTLS1_VERSION)
			{
			ss->ssl_version=DTLS1_VERSION;
			ss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;
			}
a206 8
#ifndef OPENSSL_NO_TLSEXT
		/* If RFC4507 ticket use empty session ID */
		if (s->tlsext_ticket_expected)
			{
			ss->session_id_length = 0;
			goto sess_id_done;
			}
#endif
a247 11
#ifndef OPENSSL_NO_TLSEXT
		sess_id_done:
		if (s->tlsext_hostname) {
			ss->tlsext_hostname = BUF_strdup(s->tlsext_hostname);
			if (ss->tlsext_hostname == NULL) {
				SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);
				SSL_SESSION_free(ss);
				return 0;
				}
			}
#endif
d269 1
a269 2
int ssl_get_prev_session(SSL *s, unsigned char *session_id, int len,
			const unsigned char *limit)
d273 1
a273 1
	SSL_SESSION *ret=NULL;
d275 3
a277 4
#ifndef OPENSSL_NO_TLSEXT
	int r;
#endif
  
d280 2
a281 13
#ifndef OPENSSL_NO_TLSEXT
 	r = tls1_process_ticket(s, session_id, len, limit, &ret);
	if (r == -1)
		{
		fatal = 1;
 		goto err;
		}
	else if (r == 0 || (!ret && !len))
		goto err;
	else if (!ret && !(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP))
#else
	if (len == 0)
		goto err;
a282 1
#endif
a283 6
		SSL_SESSION data;
		data.ssl_version=s->version;
		data.session_id_length=len;
		if (len == 0)
			return 0;
 		memcpy(data.session_id,session_id,len);
d325 4
a328 3
	if (ret->sid_ctx_length != s->sid_ctx_length
	    || memcmp(ret->sid_ctx,s->sid_ctx,ret->sid_ctx_length))
		{
d331 7
d339 6
d346 1
a346 1
       * so we shouldn't generate an error message. */
d348 1
a348 1
		SSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
d350 2
a351 18
		goto err; /* treat like cache miss */
		}
	
	if((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0)
		{
		/* We can't be sure if this session is being used out of
		 * context, which is especially important for SSL_VERIFY_PEER.
		 * The application should have used SSL[_CTX]_set_session_id_context.
		 *
		 * For this error case, we generate an error instead of treating
		 * the event like a cache miss (otherwise it would be easy for
		 * applications to effectively disable the session cache by
		 * accident without anyone noticing).
		 */
		
		SSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);
		fatal = 1;
		goto err;
a536 4
#ifndef OPENSSL_NO_TLSEXT
	if (ss->tlsext_hostname != NULL) OPENSSL_free(ss->tlsext_hostname);
	if (ss->tlsext_tick != NULL) OPENSSL_free(ss->tlsext_tick);
#endif
d571 1
a571 1
                    s->kssl_ctx->client_princ = (char *)OPENSSL_malloc(session->krb5_client_princ_len + 1);
a753 69
	}

void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,
	int (*cb)(struct ssl_st *ssl,SSL_SESSION *sess))
	{
	ctx->new_session_cb=cb;
	}

int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(SSL *ssl, SSL_SESSION *sess)
	{
	return ctx->new_session_cb;
	}

void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,
	void (*cb)(SSL_CTX *ctx,SSL_SESSION *sess))
	{
	ctx->remove_session_cb=cb;
	}

void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(SSL_CTX * ctx,SSL_SESSION *sess)
	{
	return ctx->remove_session_cb;
	}

void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,
	SSL_SESSION *(*cb)(struct ssl_st *ssl,
	         unsigned char *data,int len,int *copy))
	{
	ctx->get_session_cb=cb;
	}

SSL_SESSION * (*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(SSL *ssl,
	         unsigned char *data,int len,int *copy)
	{
	return ctx->get_session_cb;
	}

void SSL_CTX_set_info_callback(SSL_CTX *ctx, 
	void (*cb)(const SSL *ssl,int type,int val))
	{
	ctx->info_callback=cb;
	}

void (*SSL_CTX_get_info_callback(SSL_CTX *ctx))(const SSL *ssl,int type,int val)
	{
	return ctx->info_callback;
	}

void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx,
	int (*cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey))
	{
	ctx->client_cert_cb=cb;
	}

int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL * ssl, X509 ** x509 , EVP_PKEY **pkey)
	{
	return ctx->client_cert_cb;
	}

void SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx,
	int (*cb)(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len))
	{
	ctx->app_gen_cookie_cb=cb;
	}

void SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx,
	int (*cb)(SSL *ssl, unsigned char *cookie, unsigned int cookie_len))
	{
	ctx->app_verify_cookie_cb=cb;
@


1.1.1.11
log
@import openssl-0.9.8j
@
text
@a61 3
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif
a871 19

#ifndef OPENSSL_NO_ENGINE
int SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e)
	{
	if (!ENGINE_init(e))
		{
		SSLerr(SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE, ERR_R_ENGINE_LIB);
		return 0;
		}
	if(!ENGINE_get_ssl_client_cert_function(e))
		{
		SSLerr(SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE, SSL_R_NO_CLIENT_CERT_METHOD);
		ENGINE_finish(e);
		return 0;
		}
	ctx->client_cert_engine = e;
	return 1;
	}
#endif
@


1.1.1.12
log
@import OpenSSL-1.0.0a
@
text
@a57 79
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
a129 6
#ifndef OPENSSL_NO_EC
	ss->tlsext_ecpointformatlist_length = 0;
	ss->tlsext_ecpointformatlist = NULL;
	ss->tlsext_ellipticcurvelist_length = 0;
	ss->tlsext_ellipticcurvelist = NULL;
#endif
a131 4
#ifndef OPENSSL_NO_PSK
	ss->psk_identity_hint=NULL;
	ss->psk_identity=NULL;
#endif
d186 1
a186 1
	if (s->session_ctx->session_timeout == 0)
d189 1
a189 1
		ss->timeout=s->session_ctx->session_timeout;
a213 5
		else if (s->version == DTLS1_BAD_VER)
			{
			ss->ssl_version=DTLS1_BAD_VER;
			ss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;
			}
d237 2
a238 2
		else if(s->session_ctx->generate_session_id)
			cb = s->session_ctx->generate_session_id;
a283 26
#ifndef OPENSSL_NO_EC
		if (s->tlsext_ecpointformatlist)
			{
			if (ss->tlsext_ecpointformatlist != NULL) OPENSSL_free(ss->tlsext_ecpointformatlist);
			if ((ss->tlsext_ecpointformatlist = OPENSSL_malloc(s->tlsext_ecpointformatlist_length)) == NULL)
				{
				SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_MALLOC_FAILURE);
				SSL_SESSION_free(ss);
				return 0;
				}
			ss->tlsext_ecpointformatlist_length = s->tlsext_ecpointformatlist_length;
			memcpy(ss->tlsext_ecpointformatlist, s->tlsext_ecpointformatlist, s->tlsext_ecpointformatlist_length);
			}
		if (s->tlsext_ellipticcurvelist)
			{
			if (ss->tlsext_ellipticcurvelist != NULL) OPENSSL_free(ss->tlsext_ellipticcurvelist);
			if ((ss->tlsext_ellipticcurvelist = OPENSSL_malloc(s->tlsext_ellipticcurvelist_length)) == NULL)
				{
				SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_MALLOC_FAILURE);
				SSL_SESSION_free(ss);
				return 0;
				}
			ss->tlsext_ellipticcurvelist_length = s->tlsext_ellipticcurvelist_length;
			memcpy(ss->tlsext_ellipticcurvelist, s->tlsext_ellipticcurvelist, s->tlsext_ellipticcurvelist_length);
			}
#endif
d316 1
a316 1

d320 1
a320 1
	r = tls1_process_ticket(s, session_id, len, limit, &ret);
d324 1
a324 1
		goto err;
d332 1
a332 1
	if (!(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP))
d340 1
a340 1
		memcpy(data.session_id,session_id,len);
d342 1
a342 1
		ret=lh_SSL_SESSION_retrieve(s->session_ctx->sessions,&data);
d353 1
a353 1
		s->session_ctx->stats.sess_miss++;
d355 2
a356 2
		if (s->session_ctx->get_session_cb != NULL
		    && (ret=s->session_ctx->get_session_cb(s,session_id,len,&copy))
d359 1
a359 1
			s->session_ctx->stats.sess_cb_hit++;
d371 1
a371 1
			if(!(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_STORE))
d374 1
a374 1
				SSL_CTX_add_session(s->session_ctx,ret);
d421 1
a421 1
		if ((ret->ssl_version>>8) >= SSL3_VERSION_MAJOR)
d441 1
a441 1
		s->session_ctx->stats.sess_timeout++;
d443 1
a443 1
		SSL_CTX_remove_session(s->session_ctx,ret);
d447 1
a447 1
	s->session_ctx->stats.sess_hit++;
d480 1
a480 1
	s=lh_SSL_SESSION_insert(ctx->sessions,c);
d546 1
a546 1
		if ((r = lh_SSL_SESSION_retrieve(ctx->sessions,c)) == c)
d549 1
a549 1
			r=lh_SSL_SESSION_delete(ctx->sessions,c);
a598 12
#ifndef OPENSSL_NO_EC
	ss->tlsext_ecpointformatlist_length = 0;
	if (ss->tlsext_ecpointformatlist != NULL) OPENSSL_free(ss->tlsext_ecpointformatlist);
	ss->tlsext_ellipticcurvelist_length = 0;
	if (ss->tlsext_ellipticcurvelist != NULL) OPENSSL_free(ss->tlsext_ellipticcurvelist);
#endif /* OPENSSL_NO_EC */
#endif
#ifndef OPENSSL_NO_PSK
	if (ss->psk_identity_hint != NULL)
		OPENSSL_free(ss->psk_identity_hint);
	if (ss->psk_identity != NULL)
		OPENSSL_free(ss->psk_identity);
d607 1
a607 1
	const SSL_METHOD *meth;
a709 55
#ifndef OPENSSL_NO_TLSEXT
int SSL_set_session_secret_cb(SSL *s, int (*tls_session_secret_cb)(SSL *s, void *secret, int *secret_len,
	STACK_OF(SSL_CIPHER) *peer_ciphers, SSL_CIPHER **cipher, void *arg), void *arg)
	{
	if (s == NULL) return(0);
	s->tls_session_secret_cb = tls_session_secret_cb;
	s->tls_session_secret_cb_arg = arg;
	return(1);
	}

int SSL_set_session_ticket_ext_cb(SSL *s, tls_session_ticket_ext_cb_fn cb,
				  void *arg)
	{
	if (s == NULL) return(0);
	s->tls_session_ticket_ext_cb = cb;
	s->tls_session_ticket_ext_cb_arg = arg;
	return(1);
	}

int SSL_set_session_ticket_ext(SSL *s, void *ext_data, int ext_len)
	{
	if (s->version >= TLS1_VERSION)
		{
		if (s->tlsext_session_ticket)
			{
			OPENSSL_free(s->tlsext_session_ticket);
			s->tlsext_session_ticket = NULL;
			}

		s->tlsext_session_ticket = OPENSSL_malloc(sizeof(TLS_SESSION_TICKET_EXT) + ext_len);
		if (!s->tlsext_session_ticket)
			{
			SSLerr(SSL_F_SSL_SET_SESSION_TICKET_EXT, ERR_R_MALLOC_FAILURE);
			return 0;
			}

		if (ext_data)
			{
			s->tlsext_session_ticket->length = ext_len;
			s->tlsext_session_ticket->data = s->tlsext_session_ticket + 1;
			memcpy(s->tlsext_session_ticket->data, ext_data, ext_len);
			}
		else
			{
			s->tlsext_session_ticket->length = 0;
			s->tlsext_session_ticket->data = NULL;
			}

		return 1;
		}

	return 0;
	}
#endif /* OPENSSL_NO_TLSEXT */

d714 1
a714 1
	LHASH_OF(SSL_SESSION) *cache;
d717 1
a717 1
static void timeout_doall_arg(SSL_SESSION *s, TIMEOUT_PARAM *p)
d723 1
a723 1
		(void)lh_SSL_SESSION_delete(p->cache,s);
d732 1
a732 1
static IMPLEMENT_LHASH_DOALL_ARG_FN(timeout, SSL_SESSION, TIMEOUT_PARAM)
d744 4
a747 5
	i=CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load;
	CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load=0;
	lh_SSL_SESSION_doall_arg(tp.cache, LHASH_DOALL_ARG_FN(timeout),
				 TIMEOUT_PARAM, &tp);
	CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load=i;
a906 1
IMPLEMENT_PEM_rw(SSL_SESSION, SSL_SESSION, PEM_STRING_SSL_SESSION, SSL_SESSION)
@


1.1.1.13
log
@import OpenSSL-1.0.1c
@
text
@a220 3
#ifndef OPENSSL_NO_SRP
	ss->srp_username=NULL;
#endif
a230 5
unsigned int SSL_SESSION_get_compress_id(const SSL_SESSION *s)
	{
	return s->compress_meth;
	}

a302 10
		else if (s->version == TLS1_1_VERSION)
			{
			ss->ssl_version=TLS1_1_VERSION;
			ss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;
			}
		else if (s->version == TLS1_2_VERSION)
			{
			ss->ssl_version=TLS1_2_VERSION;
			ss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;
			}
a425 19
/* ssl_get_prev attempts to find an SSL_SESSION to be used to resume this
 * connection. It is only called by servers.
 *
 *   session_id: points at the session ID in the ClientHello. This code will
 *       read past the end of this in order to parse out the session ticket
 *       extension, if any.
 *   len: the length of the session ID.
 *   limit: a pointer to the first byte after the ClientHello.
 *
 * Returns:
 *   -1: error
 *    0: a session may have been found.
 *
 * Side effects:
 *   - If a session is found then s->session is pointed at it (after freeing an
 *     existing session if need be) and s->verify_result is set from the session.
 *   - Both for new and resumed sessions, s->tlsext_ticket_expected is set to 1
 *     if the server should issue a new session ticket (to 0 otherwise).
 */
a432 1
	int try_session_cache = 1;
a438 4

	if (len == 0)
		try_session_cache = 0;

d440 2
a441 2
	r = tls1_process_ticket(s, session_id, len, limit, &ret); /* sets s->tlsext_ticket_expected */
	switch (r)
a442 1
	case -1: /* Error during processing */
a444 9
	case 0: /* No ticket found */
	case 1: /* Zero length ticket found */
		break; /* Ok to carry on processing session id. */
	case 2: /* Ticket found but not decrypted. */
	case 3: /* Ticket decrypted, *ret has been set. */
		try_session_cache = 0;
		break;
	default:
		abort();
d446 7
a453 4

	if (try_session_cache &&
	    ret == NULL &&
	    !(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP))
d464 2
a465 4
			{
			/* don't allow other threads to steal it: */
			CRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);
			}
a466 2
		if (ret == NULL)
			s->session_ctx->stats.sess_miss++;
d469 1
a469 3
	if (try_session_cache &&
	    ret == NULL &&
	    s->session_ctx->get_session_cb != NULL)
d473 5
a477 1
		if ((ret=s->session_ctx->get_session_cb(s,session_id,len,&copy)))
d496 2
d500 1
a500 4
	if (ret == NULL)
		goto err;

	/* Now ret is non-NULL and we own one of its reference counts. */
d505 1
a505 1
		/* We have the session requested by the client, but we don't
d507 6
d549 10
d562 2
a563 5
		if (try_session_cache)
			{
			/* session was from the cache, so remove it */
			SSL_CTX_remove_session(s->session_ctx,ret);
			}
d569 4
d577 1
a577 1
	return 1;
a580 1
		{
a581 9
#ifndef OPENSSL_NO_TLSEXT
		if (!try_session_cache)
			{
			/* The session was from a ticket, so we should
			 * issue a ticket for the new session */
			s->tlsext_ticket_expected = 1;
			}
#endif
		}
a731 4
#ifndef OPENSSL_NO_SRP
	if (ss->srp_username != NULL)
		OPENSSL_free(ss->srp_username);
#endif
d756 4
a824 19
	}

X509 *SSL_SESSION_get0_peer(SSL_SESSION *s)
	{
	return s->peer;
	}

int SSL_SESSION_set1_id_context(SSL_SESSION *s,const unsigned char *sid_ctx,
			       unsigned int sid_ctx_len)
	{
	if(sid_ctx_len > SSL_MAX_SID_CTX_LENGTH)
		{
		SSLerr(SSL_F_SSL_SESSION_SET1_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
		return 0;
		}
	s->sid_ctx_length=sid_ctx_len;
	memcpy(s->sid_ctx,sid_ctx,sid_ctx_len);

	return 1;
@


