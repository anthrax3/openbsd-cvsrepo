head	1.17;
access;
symbols
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14;
locks; strict;
comment	@ * @;


1.17
date	2017.08.12.02.50.05;	author jsing;	state Exp;
branches;
next	1.16;
commitid	9vNoexOEBzDgH7cE;

1.16
date	2017.05.07.05.03.41;	author jsing;	state Exp;
branches;
next	1.15;
commitid	EpgByjCrj88oMwkt;

1.15
date	2017.04.14.15.20.55;	author jsing;	state Exp;
branches;
next	1.14;
commitid	MTz15fHRkZUiTBxi;

1.14
date	2017.03.10.15.16.20;	author jsing;	state Exp;
branches;
next	1.13;
commitid	NY3EykPyzCoLPr73;

1.13
date	2015.09.01.13.35.39;	author jsing;	state Exp;
branches;
next	1.12;
commitid	jjw6e3eAijZIvuoq;

1.12
date	2015.06.18.23.25.07;	author doug;	state Exp;
branches;
next	1.11;
commitid	wlVTUhjr83mtmDYB;

1.11
date	2015.06.13.09.24.12;	author doug;	state Exp;
branches;
next	1.10;
commitid	VhYLKiLYQcDNB1z4;

1.10
date	2015.06.13.09.16.42;	author doug;	state Exp;
branches;
next	1.9;
commitid	MveRangmB36ez78R;

1.9
date	2015.06.13.09.11.57;	author doug;	state Exp;
branches;
next	1.8;
commitid	D7FrGCP9EqtLiha6;

1.8
date	2015.04.29.02.02.46;	author doug;	state Exp;
branches;
next	1.7;
commitid	iQ7cNw94Ael9oRY6;

1.7
date	2015.04.29.01.49.28;	author doug;	state Exp;
branches;
next	1.6;
commitid	8pycLPyjQbYdWHeS;

1.6
date	2015.04.29.01.39.32;	author doug;	state Exp;
branches;
next	1.5;
commitid	EX1idM5gziW8qe9n;

1.5
date	2015.02.07.06.10.32;	author doug;	state Exp;
branches;
next	1.4;
commitid	C6aBAxrhmc1ZdrMc;

1.4
date	2015.02.07.04.37.35;	author doug;	state Exp;
branches;
next	1.3;
commitid	UeBv3B7saEvlKp8U;

1.3
date	2015.02.06.22.22.33;	author doug;	state Exp;
branches;
next	1.2;
commitid	I6v8UUW6Pnk2wCv3;

1.2
date	2015.02.06.10.06.30;	author doug;	state Exp;
branches;
next	1.1;
commitid	Ib2W0bl7drGleoaA;

1.1
date	2015.02.06.09.36.16;	author doug;	state Exp;
branches;
next	;
commitid	t6BPqtyhmeNgetxc;


desc
@@


1.17
log
@Clear the child pointer in CBB_cleanup(), so that we have fewer pointers
hanging around to potentially invalid address space.

Discussed with beck@@ and doug@@
@
text
@/*	$OpenBSD: bs_cbb.c,v 1.16 2017/05/07 05:03:41 jsing Exp $	*/
/*
 * Copyright (c) 2014, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include "bytestring.h"

#define CBB_INITIAL_SIZE 64

static int
cbb_init(CBB *cbb, uint8_t *buf, size_t cap)
{
	struct cbb_buffer_st *base;

	base = malloc(sizeof(struct cbb_buffer_st));
	if (base == NULL)
		return 0;

	base->buf = buf;
	base->len = 0;
	base->cap = cap;
	base->can_resize = 1;

	cbb->base = base;
	cbb->is_top_level = 1;

	return 1;
}

int
CBB_init(CBB *cbb, size_t initial_capacity)
{
	uint8_t *buf = NULL;

	memset(cbb, 0, sizeof(*cbb));

	if (initial_capacity == 0)
		initial_capacity = CBB_INITIAL_SIZE;

	if ((buf = malloc(initial_capacity)) == NULL)
		return 0;

	if (!cbb_init(cbb, buf, initial_capacity)) {
		free(buf);
		return 0;
	}

	return 1;
}

int
CBB_init_fixed(CBB *cbb, uint8_t *buf, size_t len)
{
	memset(cbb, 0, sizeof(*cbb));

	if (!cbb_init(cbb, buf, len))
		return 0;

	cbb->base->can_resize = 0;

	return 1;
}

void
CBB_cleanup(CBB *cbb)
{
	if (cbb->base) {
		if (cbb->base->can_resize)
			freezero(cbb->base->buf, cbb->base->cap);
		free(cbb->base);
	}
	cbb->base = NULL;
	cbb->child = NULL;
}

static int
cbb_buffer_add(struct cbb_buffer_st *base, uint8_t **out, size_t len)
{
	size_t newlen;

	if (base == NULL)
		return 0;

	newlen = base->len + len;
	if (newlen < base->len)
		/* Overflow */
		return 0;

	if (newlen > base->cap) {
		size_t newcap = base->cap * 2;
		uint8_t *newbuf;

		if (!base->can_resize)
			return 0;

		if (newcap < base->cap || newcap < newlen)
			newcap = newlen;

		newbuf = recallocarray(base->buf, base->cap, newcap, 1);
		if (newbuf == NULL)
			return 0;

		base->buf = newbuf;
		base->cap = newcap;
	}

	if (out)
		*out = base->buf + base->len;

	base->len = newlen;
	return 1;
}

static int
cbb_add_u(CBB *cbb, uint32_t v, size_t len_len)
{
	uint8_t *buf;
	size_t i;

	if (len_len == 0)
		return 1;

	if (len_len > 4)
		return 0;

	if (!CBB_flush(cbb) || !cbb_buffer_add(cbb->base, &buf, len_len))
		return 0;

	for (i = len_len - 1; i < len_len; i--) {
		buf[i] = v;
		v >>= 8;
	}
	return 1;
}

int
CBB_finish(CBB *cbb, uint8_t **out_data, size_t *out_len)
{
	if (!cbb->is_top_level)
		return 0;

	if (!CBB_flush(cbb))
		return 0;

	if (cbb->base->can_resize && (out_data == NULL || out_len == NULL))
		/*
		 * |out_data| and |out_len| can only be NULL if the CBB is
		 * fixed.
		 */
		return 0;

	if (out_data != NULL)
		*out_data = cbb->base->buf;

	if (out_len != NULL)
		*out_len = cbb->base->len;

	cbb->base->buf = NULL;
	CBB_cleanup(cbb);
	return 1;
}

/*
 * CBB_flush recurses and then writes out any pending length prefix. The current
 * length of the underlying base is taken to be the length of the
 * length-prefixed data.
 */
int
CBB_flush(CBB *cbb)
{
	size_t child_start, i, len;

	if (cbb->base == NULL)
		return 0;

	if (cbb->child == NULL || cbb->pending_len_len == 0)
		return 1;

	child_start = cbb->offset + cbb->pending_len_len;

	if (!CBB_flush(cbb->child) || child_start < cbb->offset ||
	    cbb->base->len < child_start)
		return 0;

	len = cbb->base->len - child_start;

	if (cbb->pending_is_asn1) {
		/*
		 * For ASN.1, we assumed that we were using short form which
		 * only requires a single byte for the length octet.
		 *
		 * If it turns out that we need long form, we have to move
		 * the contents along in order to make space for more length
		 * octets.
		 */
		size_t len_len = 1;  /* total number of length octets */
		uint8_t initial_length_byte;

		/* We already wrote 1 byte for the length. */
		assert (cbb->pending_len_len == 1);

		/* Check for long form */
		if (len > 0xfffffffe)
			return 0;	/* 0xffffffff is reserved */
		else if (len > 0xffffff)
			len_len = 5;
		else if (len > 0xffff)
			len_len = 4;
		else if (len > 0xff)
			len_len = 3;
		else if (len > 0x7f)
			len_len = 2;

		if (len_len == 1) {
			/* For short form, the initial byte is the length. */
			initial_length_byte = len;
			len = 0;

		} else {
			/*
			 * For long form, the initial byte is the number of
			 * subsequent length octets (plus bit 8 set).
			 */
			initial_length_byte = 0x80 | (len_len - 1);

			/*
			 * We need to move the contents along in order to make
			 * space for the long form length octets.
			 */
			size_t extra_bytes = len_len - 1;
			if (!cbb_buffer_add(cbb->base, NULL, extra_bytes))
				return 0;

			memmove(cbb->base->buf + child_start + extra_bytes,
			    cbb->base->buf + child_start, len);
		}
		cbb->base->buf[cbb->offset++] = initial_length_byte;
		cbb->pending_len_len = len_len - 1;
	}

	for (i = cbb->pending_len_len - 1; i < cbb->pending_len_len; i--) {
		cbb->base->buf[cbb->offset + i] = len;
		len >>= 8;
	}
	if (len != 0)
		return 0;

	cbb->child->base = NULL;
	cbb->child = NULL;
	cbb->pending_len_len = 0;
	cbb->pending_is_asn1 = 0;
	cbb->offset = 0;

	return 1;
}


static int
cbb_add_length_prefixed(CBB *cbb, CBB *out_contents, size_t len_len)
{
	uint8_t *prefix_bytes;

	if (!CBB_flush(cbb))
		return 0;

	cbb->offset = cbb->base->len;
	if (!cbb_buffer_add(cbb->base, &prefix_bytes, len_len))
		return 0;

	memset(prefix_bytes, 0, len_len);
	memset(out_contents, 0, sizeof(CBB));
	out_contents->base = cbb->base;
	cbb->child = out_contents;
	cbb->pending_len_len = len_len;
	cbb->pending_is_asn1 = 0;

	return 1;
}

int
CBB_add_u8_length_prefixed(CBB *cbb, CBB *out_contents)
{
	return cbb_add_length_prefixed(cbb, out_contents, 1);
}

int
CBB_add_u16_length_prefixed(CBB *cbb, CBB *out_contents)
{
	return cbb_add_length_prefixed(cbb, out_contents, 2);
}

int
CBB_add_u24_length_prefixed(CBB *cbb, CBB *out_contents)
{
	return cbb_add_length_prefixed(cbb, out_contents, 3);
}

int
CBB_add_asn1(CBB *cbb, CBB *out_contents, unsigned int tag)
{
	if (tag > UINT8_MAX)
		return 0;

	/* Long form identifier octets are not supported. */
	if ((tag & 0x1f) == 0x1f)
		return 0;

	/* Short-form identifier octet only needs a single byte */
	if (!CBB_flush(cbb) || !CBB_add_u8(cbb, tag))
		return 0;

	/*
	 * Add 1 byte to cover the short-form length octet case.  If it turns
	 * out we need long-form, it will be extended later.
	 */
	cbb->offset = cbb->base->len;
	if (!CBB_add_u8(cbb, 0))
		return 0;

	memset(out_contents, 0, sizeof(CBB));
	out_contents->base = cbb->base;
	cbb->child = out_contents;
	cbb->pending_len_len = 1;
	cbb->pending_is_asn1 = 1;

	return 1;
}

int
CBB_add_bytes(CBB *cbb, const uint8_t *data, size_t len)
{
	uint8_t *dest;

	if (!CBB_add_space(cbb, &dest, len))
		return 0;

	memcpy(dest, data, len);
	return 1;
}

int
CBB_add_space(CBB *cbb, uint8_t **out_data, size_t len)
{
	if (!CBB_flush(cbb) || !cbb_buffer_add(cbb->base, out_data, len))
		return 0;

	return 1;
}

int
CBB_add_u8(CBB *cbb, size_t value)
{
	if (value > UINT8_MAX)
		return 0;

	return cbb_add_u(cbb, (uint32_t)value, 1);
}

int
CBB_add_u16(CBB *cbb, size_t value)
{
	if (value > UINT16_MAX)
		return 0;

	return cbb_add_u(cbb, (uint32_t)value, 2);
}

int
CBB_add_u24(CBB *cbb, size_t value)
{
	if (value > 0xffffffUL)
		return 0;

	return cbb_add_u(cbb, (uint32_t)value, 3);
}

int
CBB_add_asn1_uint64(CBB *cbb, uint64_t value)
{
	CBB child;
	size_t i;
	int started = 0;

	if (!CBB_add_asn1(cbb, &child, CBS_ASN1_INTEGER))
		return 0;

	for (i = 0; i < 8; i++) {
		uint8_t byte = (value >> 8 * (7 - i)) & 0xff;

		/*
		 * ASN.1 restriction: first 9 bits cannot be all zeroes or
		 * all ones.  Since this function only encodes unsigned
		 * integers, the only concerns are not encoding leading
		 * zeros and adding a padding byte if necessary.
		 *
		 * In practice, this means:
		 * 1) Skip leading octets of all zero bits in the value
		 * 2) After skipping the leading zero octets, if the next 9
		 *    bits are all ones, add an all zero prefix octet (and
		 *    set the high bit of the prefix octet if negative).
		 *
		 * Additionally, for an unsigned value, add an all zero
		 * prefix if the high bit of the first octet would be one.
		 */
		if (!started) {
			if (byte == 0)
				/* Don't encode leading zeros. */
				continue;

			/*
			 * If the high bit is set, add a padding byte to make it
			 * unsigned.
			 */
			if ((byte & 0x80) && !CBB_add_u8(&child, 0))
				return 0;

			started = 1;
		}
		if (!CBB_add_u8(&child, byte))
			return 0;
	}

	/* 0 is encoded as a single 0, not the empty string. */
	if (!started && !CBB_add_u8(&child, 0))
		return 0;

	return CBB_flush(cbb);
}
@


1.16
log
@Instead of starting a 'zero-sized' CBB at the size of the first addition
to the CBB, then doubling, start with an initial size of 64 bytes. Almost
all uses will exceed this size and we avoid multiple small recallocarray()
calls during the initial usage.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.15 2017/04/14 15:20:55 jsing Exp $	*/
d90 1
@


1.15
log
@Use freezero(3) in the CBB clean up path, since this could hold sensitive
information (such as master keys).
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.14 2017/03/10 15:16:20 jsing Exp $	*/
d25 2
d54 5
a58 4
	if (initial_capacity > 0) {
		if ((buf = malloc(initial_capacity)) == NULL)
			return 0;
	}
@


1.14
log
@Switch CBB to use recallocarray() - this ensures that we do not leak
secrets via realloc().

ok inoguchi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.13 2015/09/01 13:35:39 jsing Exp $	*/
d83 1
a83 2
			free(cbb->base->buf);

@


1.13
log
@Make it always safe to call CBB_cleanup() providing that CBB_init() or
CBB_init_fixed() have been attempted.

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.12 2015/06/18 23:25:07 doug Exp $	*/
d113 1
a113 1
		newbuf = realloc(base->buf, newcap);
@


1.12
log
@Extend the input types for CBB_add_*() to help catch bugs.

While the previous types were correct, they can silently accept bad data
via truncation or signed conversion.  We now take size_t as input for
CBB_add_u*() and do a range check.

discussed with deraadt@@
input + ok jsing@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.11 2015/06/13 09:24:12 doug Exp $	*/
a38 1
	memset(cbb, 0, sizeof(*cbb));
d41 1
d50 2
d61 1
d68 2
d74 1
@


1.11
log
@Split up the logic in CBB_flush to separately handle the lengths.

Also, add comments about assuming short-form.

ok miod@@, tweak + ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.10 2015/06/13 09:16:42 doug Exp $	*/
d307 1
a307 1
CBB_add_asn1(CBB *cbb, CBB *out_contents, uint8_t tag)
d309 3
d359 1
a359 1
CBB_add_u8(CBB *cbb, uint8_t value)
d361 4
a364 1
	return cbb_add_u(cbb, value, 1);
d368 1
a368 1
CBB_add_u16(CBB *cbb, uint16_t value)
d370 4
a373 1
	return cbb_add_u(cbb, value, 2);
d377 1
a377 1
CBB_add_u24(CBB *cbb, uint32_t value)
d379 4
a382 1
	return cbb_add_u(cbb, value, 3);
@


1.10
log
@Explain the ASN.1 restriction that requires extra logic for encoding.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.9 2015/06/13 09:11:57 doug Exp $	*/
d197 6
a202 3
		 * For ASN.1 we assume that we'll only need a single byte for
		 * the length.  If that turned out to be incorrect, we have to
		 * move the contents along in order to make space.
d204 1
a204 1
		size_t len_len;
d207 1
d210 4
a213 4
		if (len > 0xfffffffe) {
			/* Too large. */
			return 0;
		} else if (len > 0xffffff) {
d215 1
a215 2
			initial_length_byte = 0x80 | 4;
		} else if (len > 0xffff) {
d217 1
a217 2
			initial_length_byte = 0x80 | 3;
		} else if (len > 0xff) {
d219 1
a219 2
			initial_length_byte = 0x80 | 2;
		} else if (len > 0x7f) {
d221 3
a223 3
			initial_length_byte = 0x80 | 1;
		} else {
			len_len = 1;
a225 1
		}
d227 7
a233 1
		if (len_len != 1) {
d236 1
a236 1
			 * space.
d313 1
d317 4
@


1.9
log
@When initial capacity is 0, always use NULL buffer.

malloc(0) is implementation defined and there's no reason to introduce
that ambiguity here.  Added a few cosmetic changes in sizeof and free.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.8 2015/04/29 02:02:46 doug Exp $	*/
d373 17
a389 1
		uint8_t byte = (value >> 8*(7-i)) & 0xff;
@


1.8
log
@Call CBB_add_space() rather than reimplementing it.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.7 2015/04/29 01:49:28 doug Exp $	*/
d39 1
a39 1
	memset(cbb, 0, sizeof(CBB));
d48 1
a48 1
	uint8_t *buf;
d50 4
a53 3
	buf = malloc(initial_capacity);
	if (initial_capacity > 0 && buf == NULL)
		return 0;
d76 1
a76 1
		if (cbb->base->buf && cbb->base->can_resize)
@


1.7
log
@Rename cbb_buffer_add_u to cbb_add_u and remove redundant code.

All of cbb_buffer_add_u's callers first call CBB_flush and send cbb->base.
cbb_add_u() now has that common code in one place.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.6 2015/04/29 01:39:32 doug Exp $	*/
d327 1
a327 1
	if (!CBB_flush(cbb) || !cbb_buffer_add(cbb->base, &dest, len))
@


1.6
log
@Added len_len error checking for internal cbb_buffer_add_u().

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.5 2015/02/07 06:10:32 doug Exp $	*/
d122 1
a122 1
cbb_buffer_add_u(struct cbb_buffer_st *base, uint32_t v, size_t len_len)
d133 1
a133 1
	if (!cbb_buffer_add(base, &buf, len_len))
d346 1
a346 4
	if (!CBB_flush(cbb))
		return 0;

	return cbb_buffer_add_u(cbb->base, value, 1);
d352 1
a352 4
	if (!CBB_flush(cbb))
		return 0;

	return cbb_buffer_add_u(cbb->base, value, 2);
d358 1
a358 4
	if (!CBB_flush(cbb))
		return 0;

	return cbb_buffer_add_u(cbb->base, value, 3);
@


1.5
log
@Don't allow tag number 31 in CBB_add_asn1().

Tag 31 is invalid for a short form identifier octet (single byte).
KNF a little more.

Based on BoringSSL commit 5ba305643f55d37a3e45e8388a36d50c1b2d4ff5

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.4 2015/02/07 04:37:35 doug Exp $	*/
d129 3
@


1.4
log
@Only call free in CBB_init().

CBB_init_fixed() should not call free because it can lead to use after
free or double free bugs.  The caller should be responsible for
creating and destroying the buffer.

From BoringSSL commit a84f06fc1eee6ea25ce040675fbad72c532afece

miod agrees with the reasoning
ok jsing@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.3 2015/02/06 22:22:33 doug Exp $	*/
d31 1
a31 1
	if (base == NULL) {
a32 1
	}
d150 4
a153 1
		/* |out_data| and |out_len| can only be NULL if the CBB is fixed. */
d192 5
a196 3
		/* For ASN.1 we assume that we'll only need a single byte for the length.
		 * If that turned out to be incorrect, we have to move the contents along
		 * in order to make space. */
d224 4
a227 1
			/* We need to move the contents along in order to make space. */
d299 4
d384 4
a387 2
			/* If the high bit is set, add a padding byte to make it
			 * unsigned. */
@


1.3
log
@KNF bytestring files.

I checked that this doesn't change anything.  Compiled with clang using
-Wno-pointer-sign -g0  to reduce the differences.  Only difference in the
asm is due to assert(0) line number changes in bs_cbs.c and bs_cbb.c.

miod is ok with the general process.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.2 2015/02/06 10:06:30 doug Exp $	*/
a31 1
		free(buf);
d55 5
a59 1
	return cbb_init(cbb, buf, initial_capacity);
@


1.2
log
@Remove accidental, commented out code.

This was to test a patch for upstream.
@
text
@d1 1
a1 1
/*	$OpenBSD: bs_cbb.c,v 1.1 2015/02/06 09:36:16 doug Exp $	*/
d25 4
a28 2
static int cbb_init(CBB *cbb, uint8_t *buf, size_t cap) {
  struct cbb_buffer_st *base;
d30 5
a34 347
  base = malloc(sizeof(struct cbb_buffer_st));
  if (base == NULL) {
    free(buf);
    return 0;
  }

  base->buf = buf;
  base->len = 0;
  base->cap = cap;
  base->can_resize = 1;

  memset(cbb, 0, sizeof(CBB));
  cbb->base = base;
  cbb->is_top_level = 1;
  return 1;
}

int CBB_init(CBB *cbb, size_t initial_capacity) {
  uint8_t *buf;

  buf = malloc(initial_capacity);
  if (initial_capacity > 0 && buf == NULL) {
    return 0;
  }

  return cbb_init(cbb, buf, initial_capacity);
}

int CBB_init_fixed(CBB *cbb, uint8_t *buf, size_t len) {
  if (!cbb_init(cbb, buf, len)) {
    return 0;
  }

  cbb->base->can_resize = 0;
  return 1;
}

void CBB_cleanup(CBB *cbb) {
  if (cbb->base) {
    if (cbb->base->buf && cbb->base->can_resize) {
      free(cbb->base->buf);
    }
    free(cbb->base);
  }
  cbb->base = NULL;
}

static int cbb_buffer_add(struct cbb_buffer_st *base, uint8_t **out,
                          size_t len) {
  size_t newlen;

  if (base == NULL) {
    return 0;
  }

  newlen = base->len + len;
  if (newlen < base->len) {
    /* Overflow */
    return 0;
  }

  if (newlen > base->cap) {
    size_t newcap = base->cap * 2;
    uint8_t *newbuf;

    if (!base->can_resize) {
      return 0;
    }

    if (newcap < base->cap || newcap < newlen) {
      newcap = newlen;
    }
    newbuf = realloc(base->buf, newcap);
    if (newbuf == NULL) {
      return 0;
    }

    base->buf = newbuf;
    base->cap = newcap;
  }

  if (out) {
    *out = base->buf + base->len;
  }
  base->len = newlen;
  return 1;
}

static int cbb_buffer_add_u(struct cbb_buffer_st *base, uint32_t v,
                            size_t len_len) {
  uint8_t *buf;
  size_t i;

  if (len_len == 0) {
    return 1;
  }
  if (!cbb_buffer_add(base, &buf, len_len)) {
    return 0;
  }

  for (i = len_len - 1; i < len_len; i--) {
    buf[i] = v;
    v >>= 8;
  }
  return 1;
}

int CBB_finish(CBB *cbb, uint8_t **out_data, size_t *out_len) {
  if (!cbb->is_top_level) {
    return 0;
  }

  if (!CBB_flush(cbb)) {
    return 0;
  }

  if (cbb->base->can_resize && (out_data == NULL || out_len == NULL)) {
    /* |out_data| and |out_len| can only be NULL if the CBB is fixed. */
    return 0;
  }

  if (out_data != NULL) {
    *out_data = cbb->base->buf;
  }
  if (out_len != NULL) {
    *out_len = cbb->base->len;
  }
  cbb->base->buf = NULL;
  CBB_cleanup(cbb);
  return 1;
}

/* CBB_flush recurses and then writes out any pending length prefix. The
 * current length of the underlying base is taken to be the length of the
 * length-prefixed data. */
int CBB_flush(CBB *cbb) {
  size_t child_start, i, len;

  if (cbb->base == NULL) {
    return 0;
  }

  if (cbb->child == NULL || cbb->pending_len_len == 0) {
    return 1;
  }

  child_start = cbb->offset + cbb->pending_len_len;

  if (!CBB_flush(cbb->child) ||
      child_start < cbb->offset ||
      cbb->base->len < child_start) {
    return 0;
  }

  len = cbb->base->len - child_start;

  if (cbb->pending_is_asn1) {
    /* For ASN.1 we assume that we'll only need a single byte for the length.
     * If that turned out to be incorrect, we have to move the contents along
     * in order to make space. */
    size_t len_len;
    uint8_t initial_length_byte;

    assert (cbb->pending_len_len == 1);

    if (len > 0xfffffffe) {
      /* Too large. */
      return 0;
    } else if (len > 0xffffff) {
      len_len = 5;
      initial_length_byte = 0x80 | 4;
    } else if (len > 0xffff) {
      len_len = 4;
      initial_length_byte = 0x80 | 3;
    } else if (len > 0xff) {
      len_len = 3;
      initial_length_byte = 0x80 | 2;
    } else if (len > 0x7f) {
      len_len = 2;
      initial_length_byte = 0x80 | 1;
    } else {
      len_len = 1;
      initial_length_byte = len;
      len = 0;
    }

    if (len_len != 1) {
      /* We need to move the contents along in order to make space. */
      size_t extra_bytes = len_len - 1;
      if (!cbb_buffer_add(cbb->base, NULL, extra_bytes)) {
        return 0;
      }
      memmove(cbb->base->buf + child_start + extra_bytes,
              cbb->base->buf + child_start, len);
    }
    cbb->base->buf[cbb->offset++] = initial_length_byte;
    cbb->pending_len_len = len_len - 1;
  }

  for (i = cbb->pending_len_len - 1; i < cbb->pending_len_len; i--) {
    cbb->base->buf[cbb->offset + i] = len;
    len >>= 8;
  }
  if (len != 0) {
    return 0;
  }

  cbb->child->base = NULL;
  cbb->child = NULL;
  cbb->pending_len_len = 0;
  cbb->pending_is_asn1 = 0;
  cbb->offset = 0;

  return 1;
}


static int cbb_add_length_prefixed(CBB *cbb, CBB *out_contents,
                                   size_t len_len) {
  uint8_t *prefix_bytes;

  if (!CBB_flush(cbb)) {
    return 0;
  }

  cbb->offset = cbb->base->len;
  if (!cbb_buffer_add(cbb->base, &prefix_bytes, len_len)) {
    return 0;
  }

  memset(prefix_bytes, 0, len_len);
  memset(out_contents, 0, sizeof(CBB));
  out_contents->base = cbb->base;
  cbb->child = out_contents;
  cbb->pending_len_len = len_len;
  cbb->pending_is_asn1 = 0;

  return 1;
}

int CBB_add_u8_length_prefixed(CBB *cbb, CBB *out_contents) {
  return cbb_add_length_prefixed(cbb, out_contents, 1);
}

int CBB_add_u16_length_prefixed(CBB *cbb, CBB *out_contents) {
  return cbb_add_length_prefixed(cbb, out_contents, 2);
}

int CBB_add_u24_length_prefixed(CBB *cbb, CBB *out_contents) {
  return cbb_add_length_prefixed(cbb, out_contents, 3);
}

int CBB_add_asn1(CBB *cbb, CBB *out_contents, uint8_t tag) {
  if (!CBB_flush(cbb) ||
      !CBB_add_u8(cbb, tag)) {
    return 0;
  }

  cbb->offset = cbb->base->len;
  if (!CBB_add_u8(cbb, 0)) {
    return 0;
  }

  memset(out_contents, 0, sizeof(CBB));
  out_contents->base = cbb->base;
  cbb->child = out_contents;
  cbb->pending_len_len = 1;
  cbb->pending_is_asn1 = 1;

  return 1;
}

int CBB_add_bytes(CBB *cbb, const uint8_t *data, size_t len) {
  uint8_t *dest;

  if (!CBB_flush(cbb) ||
      !cbb_buffer_add(cbb->base, &dest, len)) {
    return 0;
  }
  memcpy(dest, data, len);
  return 1;
}

int CBB_add_space(CBB *cbb, uint8_t **out_data, size_t len) {
  if (!CBB_flush(cbb) ||
      !cbb_buffer_add(cbb->base, out_data, len)) {
    return 0;
  }
  return 1;
}

int CBB_add_u8(CBB *cbb, uint8_t value) {
  if (!CBB_flush(cbb)) {
    return 0;
  }

  return cbb_buffer_add_u(cbb->base, value, 1);
}

int CBB_add_u16(CBB *cbb, uint16_t value) {
  if (!CBB_flush(cbb)) {
    return 0;
  }

  return cbb_buffer_add_u(cbb->base, value, 2);
}

int CBB_add_u24(CBB *cbb, uint32_t value) {
  if (!CBB_flush(cbb)) {
    return 0;
  }

  return cbb_buffer_add_u(cbb->base, value, 3);
}

int CBB_add_asn1_uint64(CBB *cbb, uint64_t value) {
  CBB child;
  size_t i;
  int started = 0;

  if (!CBB_add_asn1(cbb, &child, CBS_ASN1_INTEGER)) {
    return 0;
  }

  for (i = 0; i < 8; i++) {
    uint8_t byte = (value >> 8*(7-i)) & 0xff;
    if (!started) {
      if (byte == 0) {
        /* Don't encode leading zeros. */
        continue;
      }
      /* If the high bit is set, add a padding byte to make it
       * unsigned. */
      if ((byte & 0x80) && !CBB_add_u8(&child, 0)) {
        return 0;
      }
      started = 1;
    }
    if (!CBB_add_u8(&child, byte)) {
      return 0;
    }
  }

  /* 0 is encoded as a single 0, not the empty string. */
  if (!started && !CBB_add_u8(&child, 0)) {
    return 0;
  }
d36 350
a385 1
  return CBB_flush(cbb);
@


1.1
log
@Import BoringSSL's crypto bytestring and crypto bytebuilder APIs.

This is imported with as few changes as possible for the initial commit.
I removed OPENSSL_EXPORT, replaced OPENSSL_malloc() etc with malloc()
and changed a few header includes.

BoringSSL has this as part of their public API.  We're leaving it internal
to libssl for now.

Based on BoringSSL's CBB/CBS API as of commit
c5cc15b4f5b1d6e9b9112cb8d30205a638aa2c54.

input + ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a81 10

#if 0
  // XXX Added for boringssl patch testing
  if (len == 0) {
	  if (out) {
		  *out = NULL;
	  }
	  return 1;
  }
#endif
@

