head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.36
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.34
	OPENBSD_5_0:1.1.0.32
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.30
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.28
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.24
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.26
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.22
	OPENBSD_4_5_BASE:1.1
	pre_openssl_0_9_8h:1.1
	OPENBSD_4_4:1.1.0.20
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.18
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.16
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.14
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.12
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.10
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.8
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.6
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.2
	OPENBSD_3_5_BASE:1.1;
locks; strict;
comment	@# @;


1.4
date	2014.04.11.22.51.53;	author miod;	state dead;
branches;
next	1.3;

1.3
date	2013.07.05.21.10.50;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2012.10.13.21.31.56;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.18.12.39.05;	author markus;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Move build machinery for libcrypto from libssl/crypto to libcrypto, as well
as configuration files; split manpages and .pc files between libcrypto and
libssl.
No functional change, only there to make engineering easier, and libcrypto
sources are still found in libssl/src/crypto at the moment.

ok reyk@@, also discussed with deraadt@@ beck@@ and the usual crypto suspects.
@
text
@#	$OpenBSD: bn_asm_vax.S,v 1.3 2013/07/05 21:10:50 miod Exp $
#	$NetBSD: bn_asm_vax.S,v 1.1 2003/11/03 10:22:28 ragge Exp $

#include <machine/asm.h>

# w.j.m. 15-jan-1999
#
# it's magic ...
#
# ULONG bn_mul_add_words(ULONG r[],ULONG a[],int n,ULONG w) {
#	ULONG c = 0;
#	int i;
#	for(i = 0; i < n; i++) <c,r[i]> := r[i] + c + a[i] * w ;
#	return c;
# }

ENTRY(bn_mul_add_words,R6)
	movl	4(%ap),%r2		# *r
	movl	8(%ap),%r3		# *a
	movl	12(%ap),%r4		# n
	movl	16(%ap),%r5		# w
	clrl	%r6			# return value ("carry")

0:	emul	%r5,(%r3),(%r2),%r0	# w * a[0] + r[0] -> r0

	# fixup for "negative" r[]
	tstl	(%r2)
	bgeq	1f
	incl	%r1			# add 1 to highword

1:	# add saved carry to result
	addl2	%r6,%r0
	adwc	$0,%r1

	# combined fixup for "negative" w, a[]
	tstl	%r5		# if w is negative...
	bgeq	1f
	addl2	(%r3),%r1	# ...add a[0] again to highword
1:	tstl	(%r3)		# if a[0] is negative...
	bgeq	1f
	addl2	%r5,%r1		# ...add w again to highword
1:
	movl	%r0,(%r2)+	# save low word in dest & advance *r
	addl2	$4,%r3		# advance *a
	movl	%r1,%r6		# high word in r6 for return value

	sobgtr	%r4,0b		# loop?

	movl	%r6,%r0
	ret

#	.title	vax_bn_mul_words  unsigned multiply & add, 32*32+32=>64
#;
#; w.j.m. 15-jan-1999
#;
#; it's magic ...
#;
#; ULONG bn_mul_words(ULONG r[],ULONG a[],int n,ULONG w) {
#;	ULONG c = 0;
#;	int i;
#;	for(i = 0; i < num; i++) <c,r[i]> := a[i] * w + c ;
#;	return(c);
#; }
#

ENTRY(bn_mul_words,R6)
	movl	4(%ap),%r2		# *r
	movl	8(%ap),%r3		# *a
	movl	12(%ap),%r4		# n
	movl	16(%ap),%r5		# w
	clrl	%r6			# carry

0:	emul	%r5,(%r3),%r6,%r0	# w * a[0] + carry -> r0

	# fixup for "negative" carry
	tstl	%r6
	bgeq	1f
	incl	%r1

1:	# combined fixup for "negative" w, a[]
	tstl	%r5
	bgeq	1f
	addl2	(%r3),%r1
1:	tstl	(%r3)
	bgeq	1f
	addl2	%r5,%r1

1:	movl	%r0,(%r2)+
	addl2	$4,%r3
	movl	%r1,%r6

	sobgtr	%r4,0b

	movl	%r6,%r0
	ret



#	.title	vax_bn_sqr_words  unsigned square, 32*32=>64
#;
#; w.j.m. 15-jan-1999
#;
#; it's magic ...
#;
#; void bn_sqr_words(ULONG r[],ULONG a[],int n) {
#;	int i;
#;	for(i = 0; i < n; i++) <r[2*i+1],r[2*i]> := a[i] * a[i] ;
#; }
#

ENTRY(bn_sqr_words,0)
	movl	4(%ap),%r2		# r
	movl	8(%ap),%r3		# a
	movl	12(%ap),%r4		# n

0:	movl	(%r3)+,%r5		# r5 = a[] & advance

	emul	%r5,%r5,$0,%r0		# a[0] * a[0] + 0 -> r0

	# fixup for "negative" a[]
	tstl	%r5
	bgeq	1f
	addl2	%r5,%r1
	addl2	%r5,%r1

1:	movq	%r0,(%r2)+		# store 64-bit result

	sobgtr	%r4,0b			# loop

	ret


#	.title	vax_bn_div_words  unsigned divide
#;
#; Richard Levitte 20-Nov-2000
#;
#; ULONG bn_div_words(ULONG h, ULONG l, ULONG d)
#; {
#;	return ((ULONG)((((ULLONG)h)<<32)|l) / (ULLONG)d);
#; }
#;
#; Using EDIV would be very easy, if it didn't do signed calculations.
#; Any time any of the input numbers are signed, there are problems,
#; usually with integer overflow, at which point it returns useless
#; data (the quotient gets the value of l, and the remainder becomes 0).
#;
#; If it was just for the dividend, it would be very easy, just divide
#; it by 2 (unsigned), do the division, multiply the resulting quotient
#; and remainder by 2, add the bit that was dropped when dividing by 2
#; to the remainder, and do some adjustment so the remainder doesn't
#; end up larger than the divisor.  For some cases when the divisor is
#; negative (from EDIV's point of view, i.e. when the highest bit is set),
#; dividing the dividend by 2 isn't enough, and since some operations
#; might generate integer overflows even when the dividend is divided by
#; 4 (when the high part of the shifted down dividend ends up being exactly
#; half of the divisor, the result is the quotient 0x80000000, which is
#; negative...) it needs to be divided by 8.  Furthermore, the divisor needs
#; to be divided by 2 (unsigned) as well, to avoid more problems with the sign.
#; In this case, a little extra fiddling with the remainder is required.
#;
#; So, the simplest way to handle this is always to divide the dividend
#; by 8, and to divide the divisor by 2 if it's highest bit is set.
#; After EDIV has been used, the quotient gets multiplied by 8 if the
#; original divisor was positive, otherwise 4.  The remainder, oddly
#; enough, is *always* multiplied by 8.
#; NOTE: in the case mentioned above, where the high part of the shifted
#; down dividend ends up being exactly half the shifted down divisor, we
#; end up with a 33 bit quotient.  That's no problem however, it usually
#; means we have ended up with a too large remainder as well, and the
#; problem is fixed by the last part of the algorithm (next paragraph).
#;
#; The routine ends with comparing the resulting remainder with the
#; original divisor and if the remainder is larger, subtract the
#; original divisor from it, and increase the quotient by 1.  This is
#; done until the remainder is smaller than the divisor.
#;
#; The complete algorithm looks like this:
#;
#; d'    = d
#; l'    = l & 7
#; [h,l] = [h,l] >> 3
#; [q,r] = floor([h,l] / d)	# This is the EDIV operation
#; if (q < 0) q = -q		# I doubt this is necessary any more
#;
#; r'    = r >> 29
#; if (d' >= 0)
#;   q'  = q >> 29
#;   q   = q << 3
#; else
#;   q'  = q >> 30
#;   q   = q << 2
#; r     = (r << 3) + l'
#;
#; if (d' < 0)
#;   {
#;     [r',r] = [r',r] - q
#;     while ([r',r] < 0)
#;       {
#;         [r',r] = [r',r] + d
#;         [q',q] = [q',q] - 1
#;       }
#;   }
#;
#; while ([r',r] >= d')
#;   {
#;     [r',r] = [r',r] - d'
#;     [q',q] = [q',q] + 1
#;   }
#;
#; return q
#
#;r2 = l, q
#;r3 = h, r
#;r4 = d
#;r5 = l'
#;r6 = r'
#;r7 = d'
#;r8 = q'
#

ENTRY(bn_div_words,R6|R7|R8)
	movl	4(%ap),%r3		# h
	movl	8(%ap),%r2		# l
	movl	12(%ap),%r4		# d

	bicl3	$-8,%r2,%r5		# l' = l & 7
	bicl3	$7,%r2,%r2

	bicl3	$-8,%r3,%r6
	bicl3	$7,%r3,%r3

	addl2	%r6,%r2

	rotl	$-3,%r2,%r2		# l = l >> 3
	rotl	$-3,%r3,%r3		# h = h >> 3

	movl	%r4,%r7			# d' = d

	clrl	%r6			# r' = 0
	clrl	%r8			# q' = 0

	tstl	%r4
	beql	0f			# Uh-oh, the divisor is 0...
	bgtr	1f
	rotl	$-1,%r4,%r4	# If d is negative, shift it right.
	bicl2	$0x80000000,%r4	# Since d is then a large number, the
				# lowest bit is insignificant
				# (contradict that, and I'll fix the problem!)
1:
	ediv	%r4,%r2,%r2,%r3		# Do the actual division

	tstl	%r2
	bgeq	1f
	mnegl	%r2,%r2		# if q < 0, negate it
1:
	tstl	%r7
	blss	1f
	rotl	$3,%r2,%r2	#   q = q << 3
	bicl3	$-8,%r2,%r8	#   q' gets the high bits from q
	bicl3	$7,%r2,%r2
	brb	2f

1:				# else
	rotl	$2,%r2,%r2	#   q = q << 2
	bicl3	$-4,%r2,%r8	#   q' gets the high bits from q
	bicl3	$3,%r2,%r2
2:
	rotl	$3,%r3,%r3	# r = r << 3
	bicl3	$-8,%r3,%r6	# r' gets the high bits from r
	bicl3	$7,%r3,%r3
	addl2	%r5,%r3		# r = r + l'

	tstl	%r7
	bgeq	5f
	bitl	$1,%r7
	beql	5f		# if d' < 0 && d' & 1
	subl2	%r2,%r3		#   [r',r] = [r',r] - [q',q]
	sbwc	%r8,%r6
3:
	bgeq	5f		#   while r < 0
	decl	%r2		#     [q',q] = [q',q] - 1
	sbwc	$0,%r8
	addl2	%r7,%r3		#     [r',r] = [r',r] + d'
	adwc	$0,%r6
	brb	3b

# The return points are placed in the middle to keep a short distance from
# all the branch points
1:
#	movl	%r3,%r1
	movl	%r2,%r0
	ret
0:
	movl	$-1,%r0
	ret
5:
	tstl	%r6
	bneq	6f
	cmpl	%r3,%r7
	blssu	1b		# while [r',r] >= d'
6:
	subl2	%r7,%r3		#   [r',r] = [r',r] - d'
	sbwc	$0,%r6
	incl	%r2		#   [q',q] = [q',q] + 1
	adwc	$0,%r8
	brb	5b



#	.title	vax_bn_add_words  unsigned add of two arrays
#;
#; Richard Levitte 20-Nov-2000
#;
#; ULONG bn_add_words(ULONG r[], ULONG a[], ULONG b[], int n) {
#;	ULONG c = 0;
#;	int i;
#;	for (i = 0; i < n; i++) <c,r[i]> = a[i] + b[i] + c;
#;	return(c);
#; }
#

ENTRY(bn_add_words,0)
	movl	4(%ap),%r2	# r
	movl	8(%ap),%r3	# a
	movl	12(%ap),%r4	# b
	movl	16(%ap),%r5	# n
	clrl	%r0

	tstl	%r5
	bleq	1f

0:	movl	(%r3)+,%r1	# carry untouched
	adwc	(%r4)+,%r1	# carry used and touched
	movl	%r1,(%r2)+	# carry untouched
	sobgtr	%r5,0b		# carry untouched

	adwc	$0,%r0
1:	ret

#;
#; Richard Levitte 20-Nov-2000
#;
#; ULONG bn_sub_words(ULONG r[], ULONG a[], ULONG b[], int n) {
#;	ULONG c = 0;
#;	int i;
#;	for (i = 0; i < n; i++) <c,r[i]> = a[i] - b[i] - c;
#;	return(c);
#; }
#

ENTRY(bn_sub_words,R6)
	movl	4(%ap),%r2	# r
	movl	8(%ap),%r3	# a
	movl	12(%ap),%r4	# b
	movl	16(%ap),%r5	# n
	clrl	%r0

	tstl	%r5
	bleq	1f

0:	movl	(%r3)+,%r6	# carry untouched
	sbwc	(%r4)+,%r6	# carry used and touched
	movl	%r6,(%r2)+	# carry untouched
	sobgtr	%r5,0b		# carry untouched

1:	adwc	$0,%r0
	ret

#
#	Ragge 20-Sep-2003
#
#	Multiply a vector of 4/8 longword by another.
#	Uses two loops and 16/64 emuls.
#

ENTRY(bn_mul_comba4,R6|R7|R8|R9)
	movl	$4,%r9		# 4*4
	brb	6f

ENTRY(bn_mul_comba8,R6|R7|R8|R9)
	movl	$8,%r9		# 8*8

6:	movl	8(%ap),%r3	# a[]
	movl	12(%ap),%r7	# b[]
	brb	5f

ENTRY(bn_sqr_comba4,R6|R7|R8|R9)
	movl	$4,%r9		# 4*4
	brb 0f

ENTRY(bn_sqr_comba8,R6|R7|R8|R9)
	movl	$8,%r9		# 8*8

0:
	movl	8(%ap),%r3	# a[]
	movl	%r3,%r7		# a[]

5:	movl	4(%ap),%r5	# r[]
	movl	%r9,%r8

	clrq	(%r5)		# clear destinatino, for add.
	clrq	8(%r5)
	clrq	16(%r5)		# these only needed for comba8
	clrq	24(%r5)

2:	clrl	%r4		# carry
	movl	%r9,%r6		# inner loop count
	movl	(%r7)+,%r2	# value to multiply with

1:	emul	%r2,(%r3),%r4,%r0
	tstl	%r4
	bgeq	3f
	incl	%r1
3:	tstl	%r2
	bgeq	3f
	addl2	(%r3),%r1
3:	tstl	(%r3)
	bgeq	3f
	addl2	%r2,%r1

3:	addl2	%r0,(%r5)+	# add to destination
	adwc	$0,%r1		# remember carry
	movl	%r1,%r4		# add carry in next emul
	addl2	$4,%r3
	sobgtr	%r6,1b

	movl	%r4,(%r5)	# save highest add result

	ashl	$2,%r9,%r4
	subl2	%r4,%r3
	subl2	$4,%r4
	subl2	%r4,%r5

	sobgtr	%r8,2b

	ret
@


1.3
log
@VAX ELF userland bits. Consists mostly of register prefix additions.
@
text
@d1 1
a1 1
#	$OpenBSD: bn_asm_vax.S,v 1.2 2012/10/13 21:31:56 djm Exp $
@


1.2
log
@Makefile and header changes for OpenSSL-1.0.1c

major cranks
@
text
@d1 1
a1 1
#	$OpenBSD$
d18 5
a22 5
	movl	4(ap),r2		# *r
	movl	8(ap),r3		# *a
	movl	12(ap),r4		# n
	movl	16(ap),r5		# w
	clrl	r6			# return value ("carry")
d24 1
a24 1
0:	emul	r5,(r3),(r2),r0	# w * a[0] + r[0] -> r0
d27 1
a27 1
	tstl	(r2)
d29 1
a29 1
	incl	r1			# add 1 to highword
d32 2
a33 2
	addl2	r6,r0
	adwc	$0,r1
d36 1
a36 1
	tstl	r5		# if w is negative...
d38 2
a39 2
	addl2	(r3),r1		# ...add a[0] again to highword
1:	tstl	(r3)		# if a[0] is negative...
d41 1
a41 1
	addl2	r5,r1		# ...add w again to highword
d43 3
a45 3
	movl	r0,(r2)+	# save low word in dest & advance *r
	addl2	$4,r3		# advance *a
	movl	r1,r6		# high word in r6 for return value
d47 1
a47 1
	sobgtr	r4,0b		# loop?
d49 1
a49 1
	movl	r6,r0
d67 5
a71 5
	movl	4(ap),r2		# *r
	movl	8(ap),r3		# *a
	movl	12(ap),r4		# n
	movl	16(ap),r5		# w
	clrl	r6			# carry
d73 1
a73 1
0:	emul	r5,(r3),r6,r0		# w * a[0] + carry -> r0
d76 1
a76 1
	tstl	r6
d78 1
a78 1
	incl	r1
d81 1
a81 1
	tstl	r5
d83 2
a84 2
	addl2	(r3),r1
1:	tstl	(r3)
d86 1
a86 1
	addl2	r5,r1
d88 3
a90 3
1:	movl	r0,(r2)+
	addl2	$4,r3
	movl	r1,r6
d92 1
a92 1
	sobgtr	r4,0b
d94 1
a94 1
	movl	r6,r0
d112 3
a114 3
	movl	4(ap),r2		# r
	movl	8(ap),r3		# a
	movl	12(ap),r4		# n
d116 1
a116 1
0:	movl	(r3)+,r5		# r5 = a[] & advance
d118 1
a118 1
	emul	r5,r5,$0,r0		# a[0] * a[0] + 0 -> r0
d121 1
a121 1
	tstl	r5
d123 2
a124 2
	addl2	r5,r1
	addl2	r5,r1
d126 1
a126 1
1:	movq	r0,(r2)+		# store 64-bit result
d128 1
a128 1
	sobgtr	r4,0b			# loop
d222 3
a224 3
	movl	4(ap),r3		# h
	movl	8(ap),r2		# l
	movl	12(ap),r4		# d
d226 2
a227 2
	bicl3	$-8,r2,r5		# l' = l & 7
	bicl3	$7,r2,r2
d229 2
a230 2
	bicl3	$-8,r3,r6
	bicl3	$7,r3,r3
d232 1
a232 1
	addl2	r6,r2
d234 2
a235 2
	rotl	$-3,r2,r2		# l = l >> 3
	rotl	$-3,r3,r3		# h = h >> 3
d237 1
a237 1
	movl	r4,r7			# d' = d
d239 2
a240 2
	clrl	r6			# r' = 0
	clrl	r8			# q' = 0
d242 1
a242 1
	tstl	r4
d245 2
a246 2
	rotl	$-1,r4,r4	# If d is negative, shift it right.
	bicl2	$0x80000000,r4	# Since d is then a large number, the
d250 1
a250 1
	ediv	r4,r2,r2,r3		# Do the actual division
d252 1
a252 1
	tstl	r2
d254 1
a254 1
	mnegl	r2,r2		# if q < 0, negate it
d256 1
a256 1
	tstl	r7
d258 3
a260 3
	rotl	$3,r2,r2	#   q = q << 3
	bicl3	$-8,r2,r8	#   q' gets the high bits from q
	bicl3	$7,r2,r2
d264 3
a266 3
	rotl	$2,r2,r2	#   q = q << 2
	bicl3	$-4,r2,r8	#   q' gets the high bits from q
	bicl3	$3,r2,r2
d268 4
a271 4
	rotl	$3,r3,r3	# r = r << 3
	bicl3	$-8,r3,r6	# r' gets the high bits from r
	bicl3	$7,r3,r3
	addl2	r5,r3		# r = r + l'
d273 1
a273 1
	tstl	r7
d275 1
a275 1
	bitl	$1,r7
d277 2
a278 2
	subl2	r2,r3		#   [r',r] = [r',r] - [q',q]
	sbwc	r8,r6
d281 4
a284 4
	decl	r2		#     [q',q] = [q',q] - 1
	sbwc	$0,r8
	addl2	r7,r3		#     [r',r] = [r',r] + d'
	adwc	$0,r6
d290 2
a291 2
#	movl	r3,r1
	movl	r2,r0
d294 1
a294 1
	movl	$-1,r0
d297 1
a297 1
	tstl	r6
d299 1
a299 1
	cmpl	r3,r7
d302 4
a305 4
	subl2	r7,r3		#   [r',r] = [r',r] - d'
	sbwc	$0,r6
	incl	r2		#   [q',q] = [q',q] + 1
	adwc	$0,r8
d323 5
a327 5
	movl	4(ap),r2	# r
	movl	8(ap),r3	# a
	movl	12(ap),r4	# b
	movl	16(ap),r5	# n
	clrl	r0
d329 1
a329 1
	tstl	r5
d332 4
a335 4
0:	movl	(r3)+,r1	# carry untouched
	adwc	(r4)+,r1	# carry used and touched
	movl	r1,(r2)+	# carry untouched
	sobgtr	r5,0b		# carry untouched
d337 1
a337 1
	adwc	$0,r0
d352 5
a356 5
	movl	4(ap),r2	# r
	movl	8(ap),r3	# a
	movl	12(ap),r4	# b
	movl	16(ap),r5	# n
	clrl	r0
d358 1
a358 1
	tstl	r5
d361 4
a364 4
0:	movl	(r3)+,r6	# carry untouched
	sbwc	(r4)+,r6	# carry used and touched
	movl	r6,(r2)+	# carry untouched
	sobgtr	r5,0b		# carry untouched
d366 1
a366 1
1:	adwc	$0,r0
d377 1
a377 1
	movl	$4,r9		# 4*4
d381 1
a381 1
	movl	$8,r9		# 8*8
d383 2
a384 2
6:	movl	8(ap),r3	# a[]
	movl	12(ap),r7	# b[]
d388 1
a388 1
	movl	$4,r9		# 4*4
d392 1
a392 1
	movl	$8,r9		# 8*8
d395 2
a396 2
	movl	8(ap),r3	# a[]
	movl	r3,r7		# a[]
d398 2
a399 2
5:	movl	4(ap),r5	# r[]
	movl	r9,r8
d401 8
a408 8
	clrq	(r5)		# clear destinatino, for add.
	clrq	8(r5)
	clrq	16(r5)		# these only needed for comba8
	clrq	24(r5)

2:	clrl	r4		# carry
	movl	r9,r6		# inner loop count
	movl	(r7)+,r2	# value to multiply with
d410 2
a411 2
1:	emul	r2,(r3),r4,r0
	tstl	r4
d413 2
a414 2
	incl	r1
3:	tstl	r2
d416 2
a417 2
	addl2	(r3),r1
3:	tstl	(r3)
d419 1
a419 1
	addl2	r2,r1
d421 12
a432 12
3:	addl2	r0,(r5)+	# add to destination
	adwc	$0,r1		# remember carry
	movl	r1,r4		# add carry in next emul
	addl2	$4,r3
	sobgtr	r6,1b

	movl	r4,(r5)		# save highest add result

	ashl	$2,r9,r4
	subl2	r4,r3
	subl2	$4,r4
	subl2	r4,r5
d434 1
a434 1
	sobgtr	r8,2b
@


1.1
log
@use bn_asm_vax.S (from netbsd); test + ok by miod
use asm code for i386, except for the CBC code, because
it is not clean PIC code.
add <machime/asm.h> support to x86unix.pl
tested by: nick (on 30386), henning, djm, tedu, jmc and more;
no shlib minor crank necessary, only internal symbols changed.
@
text
@@

