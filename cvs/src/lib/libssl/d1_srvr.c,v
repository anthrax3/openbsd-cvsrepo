head	1.86;
access;
symbols
	OPENBSD_6_1:1.86.0.4
	OPENBSD_6_1_BASE:1.86;
locks; strict;
comment	@ * @;


1.86
date	2017.03.10.16.03.27;	author jsing;	state Exp;
branches;
next	1.85;
commitid	CCNwpUSZ1TvGpJJt;

1.85
date	2017.03.05.14.24.12;	author jsing;	state Exp;
branches;
next	1.84;
commitid	8ImCfiRdIH5PNxLQ;

1.84
date	2017.02.07.02.08.38;	author beck;	state Exp;
branches;
next	1.83;
commitid	xH3OeartUDKSlAnB;

1.83
date	2017.01.26.12.16.13;	author beck;	state Exp;
branches;
next	1.82;
commitid	lb4UTPLS9Casn2PL;

1.82
date	2017.01.26.10.40.21;	author beck;	state Exp;
branches;
next	1.81;
commitid	Bi1VygMenL4YtCp7;

1.81
date	2017.01.26.06.32.58;	author jsing;	state Exp;
branches;
next	1.80;
commitid	TbFBd2VdEVckCCsd;

1.80
date	2017.01.26.05.31.25;	author jsing;	state Exp;
branches;
next	1.79;
commitid	GRopTNgx07uByytM;

1.79
date	2017.01.23.13.36.13;	author jsing;	state Exp;
branches;
next	1.78;
commitid	xYJ523Ay020rUB5W;

1.78
date	2017.01.23.10.22.06;	author jsing;	state Exp;
branches;
next	1.77;
commitid	sfluQzS4C53eT1pq;

1.77
date	2017.01.23.08.48.44;	author beck;	state Exp;
branches;
next	1.76;
commitid	vAKES6VByBpegTl4;

1.76
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.75;
commitid	grTXB43OAHDwwKOU;

1.75
date	2017.01.23.04.55.26;	author beck;	state Exp;
branches;
next	1.74;
commitid	AhwkqHI5lKK3NR31;

1.74
date	2017.01.23.04.15.28;	author jsing;	state Exp;
branches;
next	1.73;
commitid	j20UnjrPw7WvzMvm;

1.73
date	2017.01.23.00.12.54;	author jsing;	state Exp;
branches;
next	1.72;
commitid	Ry6OEk67lc2U2xi9;

1.72
date	2017.01.22.09.02.07;	author jsing;	state Exp;
branches;
next	1.71;
commitid	570ElYZpaAvthwZh;

1.71
date	2017.01.22.07.16.39;	author beck;	state Exp;
branches;
next	1.70;
commitid	qajmn1SU3Rm3vz6g;

1.70
date	2017.01.21.06.50.02;	author jsing;	state Exp;
branches;
next	1.69;
commitid	SLShWZcEQp4rguvl;

1.69
date	2016.12.06.13.38.11;	author jsing;	state Exp;
branches;
next	1.68;
commitid	NUWXcEP3cB3L0fHl;

1.68
date	2016.11.04.18.30.21;	author guenther;	state Exp;
branches;
next	1.67;
commitid	SNICeApXI9gSqHEv;

1.67
date	2015.09.13.09.20.19;	author jsing;	state Exp;
branches;
next	1.66;
commitid	yX3x2j9ZNO5kDaVV;

1.66
date	2015.09.12.20.51.33;	author jsing;	state Exp;
branches;
next	1.65;
commitid	fP1SuBQgF4duxdhI;

1.65
date	2015.09.12.20.27.27;	author jsing;	state Exp;
branches;
next	1.64;
commitid	TwVK9yUypBybtgwd;

1.64
date	2015.09.12.15.08.54;	author jsing;	state Exp;
branches;
next	1.63;
commitid	C730Np1tNHtSwNfJ;

1.63
date	2015.09.12.14.32.24;	author jsing;	state Exp;
branches;
next	1.62;
commitid	gmjC21XhF2eUmrWG;

1.62
date	2015.09.12.14.28.23;	author jsing;	state Exp;
branches;
next	1.61;
commitid	qzeNwXAWnhAAuHQE;

1.61
date	2015.09.12.13.35.34;	author jsing;	state Exp;
branches;
next	1.60;
commitid	o1U1iPzyztRMHJTL;

1.60
date	2015.09.12.13.25.26;	author jsing;	state Exp;
branches;
next	1.59;
commitid	fbVoFJTRUmDORcyA;

1.59
date	2015.09.12.13.09.07;	author jsing;	state Exp;
branches;
next	1.58;
commitid	a9egWBSw5wJ7Fh5x;

1.58
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.57;
commitid	pa8oXRlJthT375Ws;

1.57
date	2015.09.11.16.28.37;	author jsing;	state Exp;
branches;
next	1.56;
commitid	D3HqE5ZRseh1ZZFx;

1.56
date	2015.09.10.17.57.50;	author jsing;	state Exp;
branches;
next	1.55;
commitid	T35skZJCouRaXVVY;

1.55
date	2015.06.18.22.51.05;	author doug;	state Exp;
branches;
next	1.54;
commitid	AcOny6o1iDzXgvTz;

1.54
date	2015.06.18.22.30.47;	author doug;	state Exp;
branches;
next	1.53;
commitid	6USLLvqWc6pDand3;

1.53
date	2015.06.15.05.32.58;	author doug;	state Exp;
branches;
next	1.52;
commitid	1aCIJCoHWVyZ3XBP;

1.52
date	2015.06.13.08.38.10;	author doug;	state Exp;
branches;
next	1.51;
commitid	A7PrDVdy9HjfQlSR;

1.51
date	2015.05.15.11.00.14;	author jsg;	state Exp;
branches;
next	1.50;
commitid	DVhfXEEmSZcth64F;

1.50
date	2015.03.27.12.29.54;	author jsing;	state Exp;
branches;
next	1.49;
commitid	GlMku1cNd3nfgnVW;

1.49
date	2015.02.09.10.53.28;	author jsing;	state Exp;
branches;
next	1.48;
commitid	91DZ31h3Xbk1xWbU;

1.48
date	2015.02.07.08.56.39;	author jsing;	state Exp;
branches;
next	1.47;
commitid	r6TLSniZTKxwlBFr;

1.47
date	2015.02.06.08.30.23;	author jsing;	state Exp;
branches;
next	1.46;
commitid	K5MXFl39zEkHakNY;

1.46
date	2014.12.15.00.46.53;	author doug;	state Exp;
branches;
next	1.45;
commitid	I2ue40Sqz1Sg9KmB;

1.45
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.44;
commitid	XNZawfRSWvnVv1VS;

1.44
date	2014.12.14.13.45.47;	author jsing;	state Exp;
branches;
next	1.43;
commitid	3mrPDMyWYQY3sSOz;

1.43
date	2014.12.10.15.43.31;	author jsing;	state Exp;
branches;
next	1.42;
commitid	9GGF3DCNTm9Bs8E3;

1.42
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.41;
commitid	M3pvHgIFoWUHNqJn;

1.41
date	2014.10.31.14.51.01;	author jsing;	state Exp;
branches;
next	1.40;
commitid	cMCIoWtrOiPFZWnD;

1.40
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.39;
commitid	cGE1JG2i0h4NcVDi;

1.39
date	2014.09.27.11.03.43;	author jsing;	state Exp;
branches;
next	1.38;
commitid	SaXgw4tkjiclDQMM;

1.38
date	2014.09.07.12.16.23;	author jsing;	state Exp;
branches;
next	1.37;
commitid	oAt7EW2Y0Fwu0XNB;

1.37
date	2014.08.24.14.36.45;	author jsing;	state Exp;
branches;
next	1.36;
commitid	1vOBE9WdltEkCa6G;

1.36
date	2014.08.10.14.42.56;	author jsing;	state Exp;
branches;
next	1.35;
commitid	wihJupNvfkdpKL9O;

1.35
date	2014.08.06.20.11.09;	author miod;	state Exp;
branches;
next	1.34;
commitid	DOyMZQMCl6y5x0p9;

1.34
date	2014.07.28.04.23.12;	author guenther;	state Exp;
branches;
next	1.33;
commitid	9823pc9SeqrqIVJr;

1.33
date	2014.07.12.22.33.39;	author jsing;	state Exp;
branches;
next	1.32;
commitid	JT7oO4AHgBkjVLfZ;

1.32
date	2014.07.12.13.11.53;	author jsing;	state Exp;
branches;
next	1.31;
commitid	tJhRneQ4w1l9LuV2;

1.31
date	2014.07.12.10.06.04;	author jsing;	state Exp;
branches;
next	1.30;
commitid	NW1vqt0lC8ZwMk18;

1.30
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.29;
commitid	cCGiAdDteN08GytD;

1.29
date	2014.07.10.08.51.14;	author tedu;	state Exp;
branches;
next	1.28;
commitid	lsH7iukeZYSZBx6F;

1.28
date	2014.07.09.11.25.42;	author jsing;	state Exp;
branches;
next	1.27;
commitid	N5P2FUkVkAd7ODs9;

1.27
date	2014.06.30.14.13.27;	author tedu;	state Exp;
branches;
next	1.26;
commitid	H5OTJxdwtWPzPQfq;

1.26
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	mJUVYpkFBZ0Zv2bG;

1.25
date	2014.06.07.22.23.12;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	4IX3BI6FoxwuHgdS;

1.24
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.05.29.18.11.13;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.05.28.13.00.55;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.24.12.44.48;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.23.05.13.57;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.17.11.10;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.16.01.43.06;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.14.17.45.38;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.14.14.51.11;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches
	1.6.4.1
	1.6.8.1;
next	1.5;

1.5
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.14.06;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.11.03.02.32.19;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.01.05.22.59.08;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.10.13.21.23.49;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.6.4.1
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.6.8.1
date	2014.08.09.16.54.57;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;


desc
@@


1.86
log
@Remove the handshake digests and related code, replacing remaining uses
with the handshake hash. For now tls1_digest_cached_records() is retained
to release the handshake buffer.

ok beck@@ inoguchi@@
@
text
@/* $OpenBSD: d1_srvr.c,v 1.85 2017/03/05 14:24:12 jsing Exp $ */
/*
 * DTLS implementation written by Nagendra Modadugu
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.
 */
/* ====================================================================
 * Copyright (c) 1999-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/bn.h>
#include <openssl/buffer.h>
#include <openssl/dh.h>
#include <openssl/evp.h>
#include <openssl/md5.h>
#include <openssl/objects.h>
#include <openssl/x509.h>

static int dtls1_send_hello_verify_request(SSL *s);

static const SSL_METHOD_INTERNAL DTLSv1_server_method_internal_data = {
	.version = DTLS1_VERSION,
	.min_version = DTLS1_VERSION,
	.max_version = DTLS1_VERSION,
	.ssl_new = dtls1_new,
	.ssl_clear = dtls1_clear,
	.ssl_free = dtls1_free,
	.ssl_accept = dtls1_accept,
	.ssl_connect = ssl_undefined_function,
	.ssl_read = ssl3_read,
	.ssl_peek = ssl3_peek,
	.ssl_write = ssl3_write,
	.ssl_shutdown = dtls1_shutdown,
	.ssl_pending = ssl3_pending,
	.get_ssl_method = dtls1_get_server_method,
	.get_timeout = dtls1_default_timeout,
	.ssl_version = ssl_undefined_void_function,
	.ssl_renegotiate = ssl3_renegotiate,
	.ssl_renegotiate_check = ssl3_renegotiate_check,
	.ssl_get_message = dtls1_get_message,
	.ssl_read_bytes = dtls1_read_bytes,
	.ssl_write_bytes = dtls1_write_app_data_bytes,
	.ssl3_enc = &DTLSv1_enc_data,
};

static const SSL_METHOD DTLSv1_server_method_data = {
	.ssl_dispatch_alert = dtls1_dispatch_alert,
	.num_ciphers = ssl3_num_ciphers,
	.get_cipher = dtls1_get_cipher,
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
	.internal = &DTLSv1_server_method_internal_data,
};

const SSL_METHOD *
DTLSv1_server_method(void)
{
	return &DTLSv1_server_method_data;
}

const SSL_METHOD *
dtls1_get_server_method(int ver)
{
	if (ver == DTLS1_VERSION)
		return (DTLSv1_server_method());
	return (NULL);
}

int
dtls1_accept(SSL *s)
{
	void (*cb)(const SSL *ssl, int type, int val) = NULL;
	unsigned long alg_k;
	int ret = -1;
	int new_state, state, skip = 0;
	int listen;

	ERR_clear_error();
	errno = 0;

	if (s->internal->info_callback != NULL)
		cb = s->internal->info_callback;
	else if (s->ctx->internal->info_callback != NULL)
		cb = s->ctx->internal->info_callback;

	listen = D1I(s)->listen;

	/* init things to blank */
	s->internal->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s))
		SSL_clear(s);

	D1I(s)->listen = listen;

	if (s->cert == NULL) {
		SSLerror(s, SSL_R_NO_CERTIFICATE_SET);
		ret = -1;
		goto end;
	}

	for (;;) {
		state = s->internal->state;

		switch (s->internal->state) {
		case SSL_ST_RENEGOTIATE:
			s->internal->renegotiate = 1;
			/* s->internal->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server = 1;
			if (cb != NULL)
				cb(s, SSL_CB_HANDSHAKE_START, 1);

			if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00)) {
				SSLerror(s, ERR_R_INTERNAL_ERROR);
				ret = -1;
				goto end;
			}
			s->internal->type = SSL_ST_ACCEPT;

			if (!ssl3_setup_init_buffer(s)) {
				ret = -1;
				goto end;
			}
			if (!ssl3_setup_buffers(s)) {
				ret = -1;
				goto end;
			}

			s->internal->init_num = 0;

			if (s->internal->state != SSL_ST_RENEGOTIATE) {
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 * ...but not with SCTP :-)
				 */
				if (!ssl_init_wbio_buffer(s, 1)) {
					ret = -1;
					goto end;
				}

				if (!tls1_init_finished_mac(s)) {
					ret = -1;
					goto end;
				}

				s->internal->state = SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->internal->stats.sess_accept++;
			} else {
				/* s->internal->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->internal->stats.sess_accept_renegotiate++;
				s->internal->state = SSL3_ST_SW_HELLO_REQ_A;
			}

			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->internal->shutdown = 0;
			dtls1_clear_record_buffer(s);
			dtls1_start_timer(s);
			ret = ssl3_send_hello_request(s);
			if (ret <= 0)
				goto end;
			S3I(s)->tmp.next_state = SSL3_ST_SR_CLNT_HELLO_A;
			s->internal->state = SSL3_ST_SW_FLUSH;
			s->internal->init_num = 0;

			if (!tls1_init_finished_mac(s)) {
				ret = -1;
				goto end;
			}
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->internal->state = SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			s->internal->shutdown = 0;
			ret = ssl3_get_client_hello(s);
			if (ret <= 0)
				goto end;
			dtls1_stop_timer(s);

			if (ret == 1 && (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE))
				s->internal->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A;
			else
				s->internal->state = SSL3_ST_SW_SRVR_HELLO_A;

			s->internal->init_num = 0;

			/* Reflect ClientHello sequence to remain stateless while listening */
			if (listen) {
				memcpy(S3I(s)->write_sequence, S3I(s)->read_sequence, sizeof(S3I(s)->write_sequence));
			}

			/* If we're just listening, stop here */
			if (listen && s->internal->state == SSL3_ST_SW_SRVR_HELLO_A) {
				ret = 2;
				D1I(s)->listen = 0;
				/* Set expected sequence numbers
				 * to continue the handshake.
				 */
				D1I(s)->handshake_read_seq = 2;
				D1I(s)->handshake_write_seq = 1;
				D1I(s)->next_handshake_write_seq = 1;
				goto end;
			}

			break;

		case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:
		case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:

			ret = dtls1_send_hello_verify_request(s);
			if (ret <= 0)
				goto end;
			s->internal->state = SSL3_ST_SW_FLUSH;
			S3I(s)->tmp.next_state = SSL3_ST_SR_CLNT_HELLO_A;

			/* HelloVerifyRequest resets Finished MAC */
			if (!tls1_init_finished_mac(s)) {
				ret = -1;
				goto end;
			}
			break;


		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			s->internal->renegotiate = 2;
			dtls1_start_timer(s);
			ret = ssl3_send_server_hello(s);
			if (ret <= 0)
				goto end;

			if (s->internal->hit) {
				if (s->internal->tlsext_ticket_expected)
					s->internal->state = SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->internal->state = SSL3_ST_SW_CHANGE_A;
			} else
				s->internal->state = SSL3_ST_SW_CERT_A;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH. */
			if (!(S3I(s)->tmp.new_cipher->algorithm_auth &
			    SSL_aNULL)) {
				dtls1_start_timer(s);
				ret = ssl3_send_server_certificate(s);
				if (ret <= 0)
					goto end;
				if (s->internal->tlsext_status_expected)
					s->internal->state = SSL3_ST_SW_CERT_STATUS_A;
				else
					s->internal->state = SSL3_ST_SW_KEY_EXCH_A;
			} else {
				skip = 1;
				s->internal->state = SSL3_ST_SW_KEY_EXCH_A;
			}
			s->internal->init_num = 0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
		case SSL3_ST_SW_KEY_EXCH_B:
			alg_k = S3I(s)->tmp.new_cipher->algorithm_mkey;

			/* Only send if using a DH key exchange. */
			if (alg_k & (SSL_kDHE|SSL_kECDHE)) {
				dtls1_start_timer(s);
				ret = ssl3_send_server_key_exchange(s);
				if (ret <= 0)
					goto end;
			} else
				skip = 1;

			s->internal->state = SSL3_ST_SW_CERT_REQ_A;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			/*
			 * Determine whether or not we need to request a
			 * certificate.
			 *
			 * Do not request a certificate if:
			 *
			 * - We did not ask for it (SSL_VERIFY_PEER is unset).
			 *
			 * - SSL_VERIFY_CLIENT_ONCE is set and we are
			 *   renegotiating.
			 *
			 * - We are using an anonymous ciphersuites
			 *   (see section "Certificate request" in SSL 3 drafts
			 *   and in RFC 2246) ... except when the application
			 *   insists on verification (against the specs, but
			 *   s3_clnt.c accepts this for SSL 3).
			 */
			if (!(s->verify_mode & SSL_VERIFY_PEER) ||
			    ((s->session->peer != NULL) &&
			     (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
			    ((S3I(s)->tmp.new_cipher->algorithm_auth &
			     SSL_aNULL) && !(s->verify_mode &
			     SSL_VERIFY_FAIL_IF_NO_PEER_CERT))) {
				/* no cert request */
				skip = 1;
				S3I(s)->tmp.cert_request = 0;
				s->internal->state = SSL3_ST_SW_SRVR_DONE_A;
			} else {
				S3I(s)->tmp.cert_request = 1;
				dtls1_start_timer(s);
				ret = ssl3_send_certificate_request(s);
				if (ret <= 0)
					goto end;
				s->internal->state = SSL3_ST_SW_SRVR_DONE_A;
				s->internal->init_num = 0;
			}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			dtls1_start_timer(s);
			ret = ssl3_send_server_done(s);
			if (ret <= 0)
				goto end;
			S3I(s)->tmp.next_state = SSL3_ST_SR_CERT_A;
			s->internal->state = SSL3_ST_SW_FLUSH;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_SW_FLUSH:
			s->internal->rwstate = SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0) {
				/* If the write error was fatal, stop trying */
				if (!BIO_should_retry(s->wbio)) {
					s->internal->rwstate = SSL_NOTHING;
					s->internal->state = S3I(s)->tmp.next_state;
				}

				ret = -1;
				goto end;
			}
			s->internal->rwstate = SSL_NOTHING;
			s->internal->state = S3I(s)->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			if (S3I(s)->tmp.cert_request) {
				ret = ssl3_get_client_certificate(s);
				if (ret <= 0)
					goto end;
			}
			s->internal->init_num = 0;
			s->internal->state = SSL3_ST_SR_KEY_EXCH_A;
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret = ssl3_get_client_key_exchange(s);
			if (ret <= 0)
				goto end;

			s->internal->state = SSL3_ST_SR_CERT_VRFY_A;
			s->internal->init_num = 0;

			if (ret == 2) {
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 */
				s->internal->state = SSL3_ST_SR_FINISHED_A;
				s->internal->init_num = 0;
			} else if (SSL_USE_SIGALGS(s)) {
				s->internal->state = SSL3_ST_SR_CERT_VRFY_A;
				s->internal->init_num = 0;
				if (!s->session->peer)
					break;

				/*
				 * For sigalgs freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!S3I(s)->handshake_buffer) {
					SSLerror(s, ERR_R_INTERNAL_ERROR);
					ret = -1;
					goto end;
				}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!tls1_digest_cached_records(s)) {
					ret = -1;
					goto end;
				}
			} else {
				s->internal->state = SSL3_ST_SR_CERT_VRFY_A;
				s->internal->init_num = 0;

				/*
				 * We need to get hashes here so if there is
				 * a client cert, it can be verified.
				 */
				if (S3I(s)->handshake_buffer) {
					if (!tls1_digest_cached_records(s)) {
						ret = -1;
						goto end;
					}
				}
				if (!tls1_handshake_hash_value(s,
				    S3I(s)->tmp.cert_verify_md,
				    sizeof(S3I(s)->tmp.cert_verify_md),
				    NULL)) {
					ret = -1;
					goto end;
				}
			}
			break;

		case SSL3_ST_SR_CERT_VRFY_A:
		case SSL3_ST_SR_CERT_VRFY_B:

			D1I(s)->change_cipher_spec_ok = 1;
			/* we should decide if we expected this one */
			ret = ssl3_get_cert_verify(s);
			if (ret <= 0)
				goto end;
			s->internal->state = SSL3_ST_SR_FINISHED_A;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_SR_FINISHED_A:
		case SSL3_ST_SR_FINISHED_B:
			D1I(s)->change_cipher_spec_ok = 1;
			ret = ssl3_get_finished(s, SSL3_ST_SR_FINISHED_A,
			SSL3_ST_SR_FINISHED_B);
			if (ret <= 0)
				goto end;
			dtls1_stop_timer(s);
			if (s->internal->hit)
				s->internal->state = SSL_ST_OK;
			else if (s->internal->tlsext_ticket_expected)
				s->internal->state = SSL3_ST_SW_SESSION_TICKET_A;
			else
				s->internal->state = SSL3_ST_SW_CHANGE_A;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret = ssl3_send_newsession_ticket(s);
			if (ret <= 0)
				goto end;
			s->internal->state = SSL3_ST_SW_CHANGE_A;
			s->internal->init_num = 0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret = ssl3_send_cert_status(s);
			if (ret <= 0)
				goto end;
			s->internal->state = SSL3_ST_SW_KEY_EXCH_A;
			s->internal->init_num = 0;
			break;


		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher = S3I(s)->tmp.new_cipher;
			if (!tls1_setup_key_block(s)) {
				ret = -1;
				goto end;
			}

			ret = dtls1_send_change_cipher_spec(s,
			SSL3_ST_SW_CHANGE_A, SSL3_ST_SW_CHANGE_B);

			if (ret <= 0)
				goto end;


			s->internal->state = SSL3_ST_SW_FINISHED_A;
			s->internal->init_num = 0;

			if (!tls1_change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE)) {
				ret = -1;
				goto end;
			}

			dtls1_reset_seq_numbers(s, SSL3_CC_WRITE);
			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret = ssl3_send_finished(s,
			    SSL3_ST_SW_FINISHED_A, SSL3_ST_SW_FINISHED_B,
			    TLS_MD_SERVER_FINISH_CONST,
			    TLS_MD_SERVER_FINISH_CONST_SIZE);
			if (ret <= 0)
				goto end;
			s->internal->state = SSL3_ST_SW_FLUSH;
			if (s->internal->hit) {
				S3I(s)->tmp.next_state = SSL3_ST_SR_FINISHED_A;

			} else {
				S3I(s)->tmp.next_state = SSL_ST_OK;
			}
			s->internal->init_num = 0;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			tls1_cleanup_key_block(s);

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->internal->init_num = 0;

			if (s->internal->renegotiate == 2) /* skipped if we just sent a HelloRequest */
			{
				s->internal->renegotiate = 0;
				s->internal->new_session = 0;

				ssl_update_cache(s, SSL_SESS_CACHE_SERVER);

				s->ctx->internal->stats.sess_accept_good++;
				/* s->server=1; */
				s->internal->handshake_func = dtls1_accept;

				if (cb != NULL)
					cb(s, SSL_CB_HANDSHAKE_DONE, 1);
			}

			ret = 1;

			/* done handshaking, next message is client hello */
			D1I(s)->handshake_read_seq = 0;
			/* next message is server hello */
			D1I(s)->handshake_write_seq = 0;
			D1I(s)->next_handshake_write_seq = 0;
			goto end;
			/* break; */

		default:
			SSLerror(s, SSL_R_UNKNOWN_STATE);
			ret = -1;
			goto end;
			/* break; */
		}

		if (!S3I(s)->tmp.reuse_message && !skip) {
			if (s->internal->debug) {
				if ((ret = BIO_flush(s->wbio)) <= 0)
					goto end;
			}

			if ((cb != NULL) && (s->internal->state != state)) {
				new_state = s->internal->state;
				s->internal->state = state;
				cb(s, SSL_CB_ACCEPT_LOOP, 1);
				s->internal->state = new_state;
			}
		}
		skip = 0;
	}
end:
	/* BIO_flush(s->wbio); */

	s->internal->in_handshake--;

	if (cb != NULL)
		cb(s, SSL_CB_ACCEPT_EXIT, ret);

	return (ret);
}

int
dtls1_send_hello_verify_request(SSL *s)
{
	CBB cbb, verify, cookie;

	memset(&cbb, 0, sizeof(cbb));

	if (s->internal->state == DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A) {
		if (s->ctx->internal->app_gen_cookie_cb == NULL ||
		    s->ctx->internal->app_gen_cookie_cb(s, D1I(s)->cookie,
			&(D1I(s)->cookie_len)) == 0) {
			SSLerror(s, ERR_R_INTERNAL_ERROR);
			return 0;
		}

		if (!ssl3_handshake_msg_start_cbb(s, &cbb, &verify,
		    DTLS1_MT_HELLO_VERIFY_REQUEST))
			goto err;
		if (!CBB_add_u16(&verify, s->version))
			goto err;
		if (!CBB_add_u8_length_prefixed(&verify, &cookie))
			goto err;
		if (!CBB_add_bytes(&cookie, D1I(s)->cookie, D1I(s)->cookie_len))
			goto err;
		if (!ssl3_handshake_msg_finish_cbb(s, &cbb))
			goto err;

		s->internal->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B;
	}

	/* s->internal->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B */
	return (ssl3_handshake_write(s));

 err:
	CBB_cleanup(&cbb);

	return (-1);
}
@


1.85
log
@Convert various handshake message generation functions to CBB.

ok beck@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.84 2017/02/07 02:08:38 beck Exp $ */
d522 17
a538 7
				/* We need to get hashes here so if there is
				 * a client cert, it can be verified */
				tls1_cert_verify_mac(s,
				    NID_md5, &(S3I(s)->tmp.cert_verify_md[0]));
				tls1_cert_verify_mac(s,
				    NID_sha1,
				    &(S3I(s)->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
@


1.84
log
@Change SSLerror() back to taking two args, with the first one being an SSL *.
Make a table of "function codes" which maps the internal state of the SSL *
to something like a useful name so in a typical error in the connection you
know in what sort of place in the handshake things happened. (instead of
by arcane function name).
Add SSLerrorx() for when we don't have an SSL *
ok jsing@@ after us both being prodded by bluhm@@ to make it not terrible
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.83 2017/01/26 12:16:13 beck Exp $ */
d696 3
a698 1
	unsigned char *d, *p;
a700 6
		d = p = ssl3_handshake_msg_start(s,
		    DTLS1_MT_HELLO_VERIFY_REQUEST);

		*(p++) = s->version >> 8;
		*(p++) = s->version & 0xFF;

d702 2
a703 2
		    s->ctx->internal->app_gen_cookie_cb(s,
			D1I(s)->cookie, &(D1I(s)->cookie_len)) == 0) {
d708 11
a718 5
		*(p++) = (unsigned char) D1I(s)->cookie_len;
		memcpy(p, D1I(s)->cookie, D1I(s)->cookie_len);
		p += D1I(s)->cookie_len;

		ssl3_handshake_msg_finish(s, p - d);
d725 5
@


1.83
log
@Finish the fallout of the SSLerr->SSLerror cleanup to get rid of the ugly
line wraps that resulted
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.82 2017/01/26 10:40:21 beck Exp $ */
d205 1
a205 1
		SSLerror(SSL_R_NO_CERTIFICATE_SET);
d228 1
a228 1
				SSLerror(ERR_R_INTERNAL_ERROR);
d509 1
a509 1
					SSLerror(ERR_R_INTERNAL_ERROR);
d661 1
a661 1
			SSLerror(SSL_R_UNKNOWN_STATE);
d708 1
a708 1
			SSLerror(ERR_R_INTERNAL_ERROR);
@


1.82
log
@Send the error function codes to rot in the depths of hell where they belong
We leave a single funciton code (0xFFF) to say "SSL_internal" so the public
API will not break, and we replace all internal use of the two argument
SSL_err() with the internal only SSL_error() that only takes a reason code.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.81 2017/01/26 06:32:58 jsing Exp $ */
d509 1
a509 2
					SSLerror(
					    ERR_R_INTERNAL_ERROR);
d708 1
a708 2
			SSLerror(
			    ERR_R_INTERNAL_ERROR);
@


1.81
log
@Remove most of SSL3_ENC_METHOD - we can just inline the function calls
and defines since they are the same everywhere.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.80 2017/01/26 05:31:25 jsing Exp $ */
d205 1
a205 1
		SSLerr(SSL_F_DTLS1_ACCEPT, SSL_R_NO_CERTIFICATE_SET);
d228 1
a228 1
				SSLerr(SSL_F_DTLS1_ACCEPT, ERR_R_INTERNAL_ERROR);
d509 1
a509 1
					SSLerr(SSL_F_SSL3_ACCEPT,
d662 1
a662 1
			SSLerr(SSL_F_DTLS1_ACCEPT, SSL_R_UNKNOWN_STATE);
d709 1
a709 1
			SSLerr(SSL_F_DTLS1_SEND_HELLO_VERIFY_REQUEST,
@


1.80
log
@Merge the client/server version negotiation into the existing (currently
fixed version) client/server code.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.79 2017/01/23 13:36:13 jsing Exp $ */
d525 1
a525 1
				s->method->internal->ssl3_enc->cert_verify_mac(s,
d527 1
a527 1
				s->method->internal->ssl3_enc->cert_verify_mac(s,
d585 1
a585 1
			if (!s->method->internal->ssl3_enc->setup_key_block(s)) {
d600 1
a600 1
			if (!s->method->internal->ssl3_enc->change_cipher_state(s,
d613 2
a614 2
			    s->method->internal->ssl3_enc->server_finished_label,
			    s->method->internal->ssl3_enc->server_finished_label_len);
@


1.79
log
@Split most of SSL_METHOD out into an internal variant, which is opaque.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.78 2017/01/23 10:22:06 jsing Exp $ */
a127 1
static const SSL_METHOD *dtls1_get_server_method(int ver);
d170 1
a170 1
static const SSL_METHOD *
@


1.78
log
@Remove ssl_ctrl, ssl_ctx_ctrl, ssl_callback_ctrl and ssl_ctx_callback_ctrl
from SSL_METHOD, replacing usage with direct calls to the appropriate
functions.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.77 2017/01/23 08:48:44 beck Exp $ */
d131 1
a131 1
static const SSL_METHOD DTLSv1_server_method_data = {
d144 4
d153 4
d158 2
d162 1
a162 7
	.ssl_pending = ssl3_pending,
	.num_ciphers = ssl3_num_ciphers,
	.get_cipher = dtls1_get_cipher,
	.get_ssl_method = dtls1_get_server_method,
	.get_timeout = dtls1_default_timeout,
	.ssl3_enc = &DTLSv1_enc_data,
	.ssl_version = ssl_undefined_void_function,
d526 1
a526 1
				s->method->ssl3_enc->cert_verify_mac(s,
d528 1
a528 1
				s->method->ssl3_enc->cert_verify_mac(s,
d586 1
a586 1
			if (!s->method->ssl3_enc->setup_key_block(s)) {
d601 1
a601 1
			if (!s->method->ssl3_enc->change_cipher_state(s,
d614 2
a615 2
			    s->method->ssl3_enc->server_finished_label,
			    s->method->ssl3_enc->server_finished_label_len);
@


1.77
log
@send state and rstate from ssl_st into internal. There are accessors
so these should not be diddled with directly
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.76 2017/01/23 06:45:30 beck Exp $ */
a149 2
	.ssl_ctrl = dtls1_ctrl,
	.ssl_ctx_ctrl = ssl3_ctx_ctrl,
a158 2
	.ssl_callback_ctrl = ssl3_callback_ctrl,
	.ssl_ctx_callback_ctrl = ssl3_ctx_callback_ctrl,
@


1.76
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.75 2017/01/23 04:55:26 beck Exp $ */
d212 1
a212 1
		state = s->state;
d214 1
a214 1
		switch (s->state) {
d217 1
a217 1
			/* s->state=SSL_ST_ACCEPT; */
d246 1
a246 1
			if (s->state != SSL_ST_RENEGOTIATE) {
d261 1
a261 1
				s->state = SSL3_ST_SR_CLNT_HELLO_A;
d264 1
a264 1
				/* s->state == SSL_ST_RENEGOTIATE,
d267 1
a267 1
				s->state = SSL3_ST_SW_HELLO_REQ_A;
d282 1
a282 1
			s->state = SSL3_ST_SW_FLUSH;
d292 1
a292 1
			s->state = SSL_ST_OK;
d306 1
a306 1
				s->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A;
d308 1
a308 1
				s->state = SSL3_ST_SW_SRVR_HELLO_A;
d318 1
a318 1
			if (listen && s->state == SSL3_ST_SW_SRVR_HELLO_A) {
d338 1
a338 1
			s->state = SSL3_ST_SW_FLUSH;
d359 1
a359 1
					s->state = SSL3_ST_SW_SESSION_TICKET_A;
d361 1
a361 1
					s->state = SSL3_ST_SW_CHANGE_A;
d363 1
a363 1
				s->state = SSL3_ST_SW_CERT_A;
d377 1
a377 1
					s->state = SSL3_ST_SW_CERT_STATUS_A;
d379 1
a379 1
					s->state = SSL3_ST_SW_KEY_EXCH_A;
d382 1
a382 1
				s->state = SSL3_ST_SW_KEY_EXCH_A;
d400 1
a400 1
			s->state = SSL3_ST_SW_CERT_REQ_A;
d432 1
a432 1
				s->state = SSL3_ST_SW_SRVR_DONE_A;
d439 1
a439 1
				s->state = SSL3_ST_SW_SRVR_DONE_A;
d451 1
a451 1
			s->state = SSL3_ST_SW_FLUSH;
d461 1
a461 1
					s->state = S3I(s)->tmp.next_state;
d468 1
a468 1
			s->state = S3I(s)->tmp.next_state;
d479 1
a479 1
			s->state = SSL3_ST_SR_KEY_EXCH_A;
d488 1
a488 1
			s->state = SSL3_ST_SR_CERT_VRFY_A;
d497 1
a497 1
				s->state = SSL3_ST_SR_FINISHED_A;
d500 1
a500 1
				s->state = SSL3_ST_SR_CERT_VRFY_A;
d521 1
a521 1
				s->state = SSL3_ST_SR_CERT_VRFY_A;
d542 1
a542 1
			s->state = SSL3_ST_SR_FINISHED_A;
d555 1
a555 1
				s->state = SSL_ST_OK;
d557 1
a557 1
				s->state = SSL3_ST_SW_SESSION_TICKET_A;
d559 1
a559 1
				s->state = SSL3_ST_SW_CHANGE_A;
d568 1
a568 1
			s->state = SSL3_ST_SW_CHANGE_A;
d577 1
a577 1
			s->state = SSL3_ST_SW_KEY_EXCH_A;
d598 1
a598 1
			s->state = SSL3_ST_SW_FINISHED_A;
d618 1
a618 1
			s->state = SSL3_ST_SW_FLUSH;
d675 3
a677 3
			if ((cb != NULL) && (s->state != state)) {
				new_state = s->state;
				s->state = state;
d679 1
a679 1
				s->state = new_state;
d700 1
a700 1
	if (s->state == DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A) {
d721 1
a721 1
		s->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B;
d724 1
a724 1
	/* s->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B */
@


1.75
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.74 2017/01/23 04:15:28 jsing Exp $ */
d216 1
a216 1
			s->renegotiate = 1;
d233 1
a233 1
			s->type = SSL_ST_ACCEPT;
d244 1
a244 1
			s->init_num = 0;
d275 1
a275 1
			s->shutdown = 0;
d283 1
a283 1
			s->init_num = 0;
d299 1
a299 1
			s->shutdown = 0;
d310 1
a310 1
			s->init_num = 0;
d351 1
a351 1
			s->renegotiate = 2;
d357 2
a358 2
			if (s->hit) {
				if (s->tlsext_ticket_expected)
d364 1
a364 1
			s->init_num = 0;
d376 1
a376 1
				if (s->tlsext_status_expected)
d384 1
a384 1
			s->init_num = 0;
d401 1
a401 1
			s->init_num = 0;
d440 1
a440 1
				s->init_num = 0;
d452 1
a452 1
			s->init_num = 0;
d456 1
a456 1
			s->rwstate = SSL_WRITING;
d460 1
a460 1
					s->rwstate = SSL_NOTHING;
d467 1
a467 1
			s->rwstate = SSL_NOTHING;
d478 1
a478 1
			s->init_num = 0;
d489 1
a489 1
			s->init_num = 0;
d498 1
a498 1
				s->init_num = 0;
d501 1
a501 1
				s->init_num = 0;
d522 1
a522 1
				s->init_num = 0;
d543 1
a543 1
			s->init_num = 0;
d554 1
a554 1
			if (s->hit)
d556 1
a556 1
			else if (s->tlsext_ticket_expected)
d560 1
a560 1
			s->init_num = 0;
d569 1
a569 1
			s->init_num = 0;
d578 1
a578 1
			s->init_num = 0;
d599 1
a599 1
			s->init_num = 0;
d619 1
a619 1
			if (s->hit) {
d625 1
a625 1
			s->init_num = 0;
d635 1
a635 1
			s->init_num = 0;
d637 1
a637 1
			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
d639 2
a640 2
				s->renegotiate = 0;
				s->new_session = 0;
d670 1
a670 1
			if (s->debug) {
@


1.74
log
@Move callback function pointers and argument pointers from SSL_CTX to
internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.73 2017/01/23 00:12:54 jsing Exp $ */
d191 2
a192 2
	if (s->info_callback != NULL)
		cb = s->info_callback;
d199 1
a199 1
	s->in_handshake++;
d646 1
a646 1
				s->handshake_func = dtls1_accept;
d687 1
a687 1
	s->in_handshake--;
@


1.73
log
@Move the stats struct from SSL_CTX to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.72 2017/01/22 09:02:07 jsing Exp $ */
d193 2
a194 2
	else if (s->ctx->info_callback != NULL)
		cb = s->ctx->info_callback;
d707 3
a709 3
		if (s->ctx->app_gen_cookie_cb == NULL ||
		    s->ctx->app_gen_cookie_cb(s, D1I(s)->cookie,
			&(D1I(s)->cookie_len)) == 0) {
@


1.72
log
@Move most of the SSL3_STATE fields to internal - the ones that remain are
known to be used by ports.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.71 2017/01/22 07:16:39 beck Exp $ */
d262 1
a262 1
				s->ctx->stats.sess_accept++;
d266 1
a266 1
				s->ctx->stats.sess_accept_renegotiate++;
d644 1
a644 1
				s->ctx->stats.sess_accept_good++;
@


1.71
log
@Move most of DTLS1_STATE to internal.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.70 2017/01/21 06:50:02 jsing Exp $ */
d281 1
a281 1
			s->s3->tmp.next_state = SSL3_ST_SR_CLNT_HELLO_A;
d314 1
a314 1
				memcpy(s->s3->write_sequence, s->s3->read_sequence, sizeof(s->s3->write_sequence));
d339 1
a339 1
			s->s3->tmp.next_state = SSL3_ST_SR_CLNT_HELLO_A;
d370 1
a370 1
			if (!(s->s3->tmp.new_cipher->algorithm_auth &
d389 1
a389 1
			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
d426 1
a426 1
			    ((s->s3->tmp.new_cipher->algorithm_auth &
d431 1
a431 1
				s->s3->tmp.cert_request = 0;
d434 1
a434 1
				s->s3->tmp.cert_request = 1;
d450 1
a450 1
			s->s3->tmp.next_state = SSL3_ST_SR_CERT_A;
d461 1
a461 1
					s->state = s->s3->tmp.next_state;
d468 1
a468 1
			s->state = s->s3->tmp.next_state;
d473 1
a473 1
			if (s->s3->tmp.cert_request) {
d509 1
a509 1
				if (!s->s3->handshake_buffer) {
d527 1
a527 1
				    NID_md5, &(s->s3->tmp.cert_verify_md[0]));
d530 1
a530 1
				    &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
d585 1
a585 1
			s->session->cipher = s->s3->tmp.new_cipher;
d620 1
a620 1
				s->s3->tmp.next_state = SSL3_ST_SR_FINISHED_A;
d623 1
a623 1
				s->s3->tmp.next_state = SSL_ST_OK;
d669 1
a669 1
		if (!s->s3->tmp.reuse_message && !skip) {
@


1.70
log
@Specify minimum and maximum protocol version for each method. This is
currently unused, but will be in the near future.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.69 2016/12/06 13:38:11 jsing Exp $ */
d196 1
a196 1
	listen = s->d1->listen;
d203 1
a203 1
	s->d1->listen = listen;
d320 1
a320 1
				s->d1->listen = 0;
d324 3
a326 3
				s->d1->handshake_read_seq = 2;
				s->d1->handshake_write_seq = 1;
				s->d1->next_handshake_write_seq = 1;
d537 1
a537 1
			s->d1->change_cipher_spec_ok = 1;
d548 1
a548 1
			s->d1->change_cipher_spec_ok = 1;
d655 1
a655 1
			s->d1->handshake_read_seq = 0;
d657 2
a658 2
			s->d1->handshake_write_seq = 0;
			s->d1->next_handshake_write_seq = 0;
d708 2
a709 2
		    s->ctx->app_gen_cookie_cb(s, s->d1->cookie,
			&(s->d1->cookie_len)) == 0) {
d715 3
a717 3
		*(p++) = (unsigned char) s->d1->cookie_len;
		memcpy(p, s->d1->cookie, s->d1->cookie_len);
		p += s->d1->cookie_len;
@


1.69
log
@Now that ssl3_send_{client,server}_certificate() are using the common
handshake functions, we can remove more copied code from DTLS.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.68 2016/11/04 18:30:21 guenther Exp $ */
d133 2
@


1.68
log
@The *_method_data structures can be static

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.67 2015/09/13 09:20:19 jsing Exp $ */
d371 1
a371 1
				ret = dtls1_send_server_certificate(s);
a723 27
}

int
dtls1_send_server_certificate(SSL *s)
{
	unsigned long l;
	X509 *x;

	if (s->state == SSL3_ST_SW_CERT_A) {
		x = ssl_get_server_send_cert(s);
		if (x == NULL) {
			SSLerr(SSL_F_DTLS1_SEND_SERVER_CERTIFICATE,
			    ERR_R_INTERNAL_ERROR);
			return (0);
		}

		l = dtls1_output_cert_chain(s, x);
		s->state = SSL3_ST_SW_CERT_B;
		s->init_num = (int)l;
		s->init_off = 0;

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
	}

	/* SSL3_ST_SW_CERT_B */
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
@


1.67
log
@The *_accept() functions increment in_handshake at the start of the function,
then decrement it and call a callback on exit from the function. As such,
these functions should not return in the middle, otherwise in_handshake is
never decremented and the callback never called.

ok beck@@ "with many sighs" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.66 2015/09/12 20:51:33 jsing Exp $ */
d131 1
a131 1
const SSL_METHOD DTLSv1_server_method_data = {
@


1.66
log
@Fix function name.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.65 2015/09/12 20:27:27 jsing Exp $ */
d205 2
a206 1
		return (-1);
d228 2
a229 1
				return -1;
@


1.65
log
@Sync handling of cached record digests with s3_srvr.c.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.64 2015/09/12 15:08:54 jsing Exp $ */
d512 1
a512 1
				if (!ssl3_digest_cached_records(s)) {
@


1.64
log
@Uncopy and unpaste dtls1_send_newsession_ticket() - another 111 lines of
code deduped.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.63 2015/09/12 14:32:24 jsing Exp $ */
d495 21
d687 1
@


1.63
log
@Uncopy and unpaste dtls1_send_certificate_request() - removes another 80
lines of code, while gaining SIGALGs support.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.62 2015/09/12 14:28:23 jsing Exp $ */
d540 1
a540 1
			ret = dtls1_send_newsession_ticket(s);
a725 107
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
}

int
dtls1_send_newsession_ticket(SSL *s)
{
	if (s->state == SSL3_ST_SW_SESSION_TICKET_A) {
		unsigned char *p, *senc, *macstart;
		int len, slen;
		unsigned int hlen, msg_len;
		EVP_CIPHER_CTX ctx;
		HMAC_CTX hctx;
		SSL_CTX *tctx = s->initial_ctx;
		unsigned char iv[EVP_MAX_IV_LENGTH];
		unsigned char key_name[16];

		/* get session encoding length */
		slen = i2d_SSL_SESSION(s->session, NULL);
		/* Some length values are 16 bits, so forget it if session is
 		 * too long
 		 */
		if (slen > 0xFF00)
			return -1;
		/* Grow buffer if need be: the length calculation is as
 		 * follows 12 (DTLS handshake message header) +
 		 * 4 (ticket lifetime hint) + 2 (ticket length) +
 		 * 16 (key name) + max_iv_len (iv length) +
 		 * session_length + max_enc_block_size (max encrypted session
 		 * length) + max_md_size (HMAC).
 		 */
		if (!BUF_MEM_grow(s->init_buf,
		    DTLS1_HM_HEADER_LENGTH + 22 + EVP_MAX_IV_LENGTH +
		    EVP_MAX_BLOCK_LENGTH + EVP_MAX_MD_SIZE + slen))
			return -1;
		senc = malloc(slen);
		if (!senc)
			return -1;
		p = senc;
		i2d_SSL_SESSION(s->session, &p);

		p = (unsigned char *)&(s->init_buf->data[DTLS1_HM_HEADER_LENGTH]);
		EVP_CIPHER_CTX_init(&ctx);
		HMAC_CTX_init(&hctx);
		/* Initialize HMAC and cipher contexts. If callback present
		 * it does all the work otherwise use generated values
		 * from parent ctx.
		 */
		if (tctx->tlsext_ticket_key_cb) {
			if (tctx->tlsext_ticket_key_cb(s, key_name, iv, &ctx,
			    &hctx, 1) < 0) {
				free(senc);
				EVP_CIPHER_CTX_cleanup(&ctx);
				return -1;
			}
		} else {
			arc4random_buf(iv, 16);
			EVP_EncryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,
			    tctx->tlsext_tick_aes_key, iv);
			HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
			    tlsext_tick_md(), NULL);
			memcpy(key_name, tctx->tlsext_tick_key_name, 16);
		}
		l2n(s->session->tlsext_tick_lifetime_hint, p);
		/* Skip ticket length for now */
		p += 2;
		/* Output key name */
		macstart = p;
		memcpy(p, key_name, 16);
		p += 16;
		/* output IV */
		memcpy(p, iv, EVP_CIPHER_CTX_iv_length(&ctx));
		p += EVP_CIPHER_CTX_iv_length(&ctx);
		/* Encrypt session data */
		EVP_EncryptUpdate(&ctx, p, &len, senc, slen);
		p += len;
		EVP_EncryptFinal(&ctx, p, &len);
		p += len;
		EVP_CIPHER_CTX_cleanup(&ctx);

		HMAC_Update(&hctx, macstart, p - macstart);
		HMAC_Final(&hctx, p, &hlen);
		HMAC_CTX_cleanup(&hctx);

		p += hlen;
		/* Now write out lengths: p points to end of data written */
		/* Total length */
		len = p - (unsigned char *)(s->init_buf->data);
		/* Ticket length */
		p = (unsigned char *)&(s->init_buf->data[DTLS1_HM_HEADER_LENGTH]) + 4;
		s2n(len - DTLS1_HM_HEADER_LENGTH - 6, p);

		/* number of bytes to write */
		s->init_num = len;
		s->state = SSL3_ST_SW_SESSION_TICKET_B;
		s->init_off = 0;
		free(senc);

		/* XDTLS:  set message header ? */
		msg_len = s->init_num - DTLS1_HM_HEADER_LENGTH;
		dtls1_set_message_header(s, (void *)s->init_buf->data,
		SSL3_MT_NEWSESSION_TICKET, msg_len, 0, msg_len);

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
	}

	/* SSL3_ST_SW_SESSION_TICKET_B */
@


1.62
log
@Uncopy and unpaste dtls1_send_server_key_exchange(). Removes another 329
lines of code, while gaining bug fixes and SIGALGs support.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.61 2015/09/12 13:35:34 jsing Exp $ */
d432 1
a432 1
				ret = dtls1_send_certificate_request(s);
a699 76
}

int
dtls1_send_certificate_request(SSL *s)
{
	unsigned char *p, *d;
	int i, j, nl, off, n;
	STACK_OF(X509_NAME) *sk = NULL;
	X509_NAME *name;
	BUF_MEM *buf;
	unsigned int msg_len;

	if (s->state == SSL3_ST_SW_CERT_REQ_A) {
		buf = s->init_buf;

		d = p=(unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH]);

		/* get the list of acceptable cert types */
		p++;
		n = ssl3_get_req_cert_type(s, p);
		d[0] = n;
		p += n;
		n++;

		off = n;
		p += 2;
		n += 2;

		sk = SSL_get_client_CA_list(s);
		nl = 0;
		if (sk != NULL) {
			for (i = 0; i < sk_X509_NAME_num(sk); i++) {
				name = sk_X509_NAME_value(sk, i);
				j = i2d_X509_NAME(name, NULL);
				if (!BUF_MEM_grow_clean(buf, DTLS1_HM_HEADER_LENGTH + n + j + 2)) {
					SSLerr(SSL_F_DTLS1_SEND_CERTIFICATE_REQUEST, ERR_R_BUF_LIB);
					goto err;
				}
				p = (unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH + n]);
				s2n(j, p);
				i2d_X509_NAME(name, &p);
				n += 2 + j;
				nl += 2 + j;
			}
		}
		/* else no CA names */
		p = (unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH + off]);
		s2n(nl, p);

		d = (unsigned char *)buf->data;
		*(d++) = SSL3_MT_CERTIFICATE_REQUEST;
		l2n3(n, d);
		s2n(s->d1->handshake_write_seq, d);
		s->d1->handshake_write_seq++;

		/* we should now have things packed up, so lets send
		 * it off */

		s->init_num = n + DTLS1_HM_HEADER_LENGTH;
		s->init_off = 0;

		/* XDTLS:  set message header ? */
		msg_len = s->init_num - DTLS1_HM_HEADER_LENGTH;
		dtls1_set_message_header(s, (void *)s->init_buf->data,
		    SSL3_MT_CERTIFICATE_REQUEST, msg_len, 0, msg_len);

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);

		s->state = SSL3_ST_SW_CERT_REQ_B;
	}

	/* SSL3_ST_SW_CERT_REQ_B */
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
err:
	return (-1);
@


1.61
log
@Uncopy and unpaste dtls1_send_server_done().
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.60 2015/09/12 13:25:26 jsing Exp $ */
d390 1
a390 1
				ret = dtls1_send_server_key_exchange(s);
a699 325
}

int
dtls1_send_server_key_exchange(SSL *s)
{
	unsigned char *q;
	int j, num;
	unsigned char md_buf[MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH];
	unsigned int u;
	DH *dh = NULL, *dhp;
	EC_KEY *ecdh = NULL, *ecdhp;
	unsigned char *encodedPoint = NULL;
	int encodedlen = 0;
	int curve_id = 0;
	BN_CTX *bn_ctx = NULL;

	EVP_PKEY *pkey;
	unsigned char *p, *d;
	int al, i;
	unsigned long type;
	int n;
	CERT *cert;
	BIGNUM *r[4];
	int nr[4], kn;
	BUF_MEM *buf;
	EVP_MD_CTX md_ctx;

	EVP_MD_CTX_init(&md_ctx);
	if (s->state == SSL3_ST_SW_KEY_EXCH_A) {
		type = s->s3->tmp.new_cipher->algorithm_mkey;
		cert = s->cert;

		buf = s->init_buf;

		r[0] = r[1] = r[2] = r[3] = NULL;
		n = 0;

		if (type & SSL_kDHE) {
			dhp = cert->dh_tmp;
			if ((dhp == NULL) && (s->cert->dh_tmp_cb != NULL))
				dhp = s->cert->dh_tmp_cb(s, 0,
				    SSL_C_PKEYLENGTH(s->s3->tmp.new_cipher));
			if (dhp == NULL) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, SSL_R_MISSING_TMP_DH_KEY);
				goto f_err;
			}

			if (s->s3->tmp.dh != NULL) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
				goto err;
			}

			if ((dh = DHparams_dup(dhp)) == NULL) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_DH_LIB);
				goto err;
			}

			s->s3->tmp.dh = dh;
			if ((dhp->pub_key == NULL || dhp->priv_key == NULL ||
			    (s->options & SSL_OP_SINGLE_DH_USE))) {
				if (!DH_generate_key(dh)) {
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,
					ERR_R_DH_LIB);
					goto err;
				}
			} else {
				dh->pub_key = BN_dup(dhp->pub_key);
				dh->priv_key = BN_dup(dhp->priv_key);
				if ((dh->pub_key == NULL) ||
				    (dh->priv_key == NULL)) {
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_DH_LIB);
					goto err;
				}
			}
			r[0] = dh->p;
			r[1] = dh->g;
			r[2] = dh->pub_key;
		} else if (type & SSL_kECDHE) {
			const EC_GROUP *group;

			ecdhp = cert->ecdh_tmp;
			if (ecdhp == NULL && s->cert->ecdh_tmp_cb != NULL)
				ecdhp = s->cert->ecdh_tmp_cb(s, 0,
				    SSL_C_PKEYLENGTH(s->s3->tmp.new_cipher));
			if (ecdhp == NULL) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, SSL_R_MISSING_TMP_ECDH_KEY);
				goto f_err;
			}

			if (s->s3->tmp.ecdh != NULL) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
				goto err;
			}

			/* Duplicate the ECDH structure. */
			if ((ecdh = EC_KEY_dup(ecdhp)) == NULL) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_ECDH_LIB);
				goto err;
			}
			s->s3->tmp.ecdh = ecdh;

			if ((EC_KEY_get0_public_key(ecdh) == NULL) ||
			    (EC_KEY_get0_private_key(ecdh) == NULL) ||
			    (s->options & SSL_OP_SINGLE_ECDH_USE)) {
				if (!EC_KEY_generate_key(ecdh)) {
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_ECDH_LIB);
					goto err;
				}
			}

			if (((group = EC_KEY_get0_group(ecdh)) == NULL) ||
			    (EC_KEY_get0_public_key(ecdh)  == NULL) ||
			    (EC_KEY_get0_private_key(ecdh) == NULL)) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_ECDH_LIB);
				goto err;
			}

			/* XXX: For now, we only support ephemeral ECDH
			 * keys over named (not generic) curves. For
			 * supported named curves, curve_id is non-zero.
			 */
			if ((curve_id = tls1_ec_nid2curve_id(
			    EC_GROUP_get_curve_name(group))) == 0) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);
				goto err;
			}

			/* Encode the public key.
			 * First check the size of encoding and
			 * allocate memory accordingly.
			 */
			encodedlen = EC_POINT_point2oct(group,
			EC_KEY_get0_public_key(ecdh),
			POINT_CONVERSION_UNCOMPRESSED,
			NULL, 0, NULL);

			encodedPoint = malloc(encodedlen);

			bn_ctx = BN_CTX_new();
			if ((encodedPoint == NULL) || (bn_ctx == NULL)) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
				goto err;
			}


			encodedlen = EC_POINT_point2oct(group,
			EC_KEY_get0_public_key(ecdh),
			POINT_CONVERSION_UNCOMPRESSED,
			encodedPoint, encodedlen, bn_ctx);

			if (encodedlen == 0) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_ECDH_LIB);
				goto err;
			}

			BN_CTX_free(bn_ctx);
			bn_ctx = NULL;

			/* XXX: For now, we only support named (not
			 * generic) curves in ECDH ephemeral key exchanges.
			 * In this situation, we need four additional bytes
			 * to encode the entire ServerECDHParams
			 * structure.
			 */
			n = 4 + encodedlen;

			/* We'll generate the serverKeyExchange message
			 * explicitly so we can set these to NULLs
			 */
			r[0] = NULL;
			r[1] = NULL;
			r[2] = NULL;
			r[3] = NULL;
		} else {
			al = SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,
			    SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
			goto f_err;
		}
		for (i = 0; r[i] != NULL; i++) {
			nr[i] = BN_num_bytes(r[i]);
			n += 2 + nr[i];
		}

		if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)) {
			if ((pkey = ssl_get_sign_pkey(s,
			    s->s3->tmp.new_cipher, NULL)) == NULL) {
				al = SSL_AD_DECODE_ERROR;
				goto f_err;
			}
			kn = EVP_PKEY_size(pkey);
		} else {
			pkey = NULL;
			kn = 0;
		}

		if (!BUF_MEM_grow_clean(buf, n + DTLS1_HM_HEADER_LENGTH + kn)) {
			SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_BUF);
			goto err;
		}
		d = (unsigned char *)s->init_buf->data;
		p = &(d[DTLS1_HM_HEADER_LENGTH]);

		for (i = 0; r[i] != NULL; i++) {
			s2n(nr[i], p);
			BN_bn2bin(r[i], p);
			p += nr[i];
		}

		if (type & SSL_kECDHE) {
			/* XXX: For now, we only support named (not generic) curves.
			 * In this situation, the serverKeyExchange message has:
			 * [1 byte CurveType], [2 byte CurveName]
			 * [1 byte length of encoded point], followed by
			 * the actual encoded point itself
			 */
			*p = NAMED_CURVE_TYPE;
			p += 1;
			*p = 0;
			p += 1;
			*p = curve_id;
			p += 1;
			*p = encodedlen;
			p += 1;
			memcpy((unsigned char*)p,
			    (unsigned char *)encodedPoint, encodedlen);
			free(encodedPoint);
			encodedPoint = NULL;
			p += encodedlen;
		}


		/* not anonymous */
		if (pkey != NULL) {
			/* n is the length of the params, they start at
			 * &(d[DTLS1_HM_HEADER_LENGTH]) and p points to the space
			 * at the end. */
			if (pkey->type == EVP_PKEY_RSA) {
				q = md_buf;
				j = 0;
				for (num = 2; num > 0; num--) {
					if (!EVP_DigestInit_ex(&md_ctx, (num == 2)
					    ? s->ctx->md5 : s->ctx->sha1, NULL))
						goto err;
					EVP_DigestUpdate(&md_ctx,
					    &(s->s3->client_random[0]),
					    SSL3_RANDOM_SIZE);
					EVP_DigestUpdate(&md_ctx,
					    &(s->s3->server_random[0]),
					    SSL3_RANDOM_SIZE);
					EVP_DigestUpdate(&md_ctx,
					    &(d[DTLS1_HM_HEADER_LENGTH]), n);
					EVP_DigestFinal_ex(&md_ctx, q,
					    (unsigned int *)&i);
					q += i;
					j += i;
				}
				if (RSA_sign(NID_md5_sha1, md_buf, j, &(p[2]),
				    &u, pkey->pkey.rsa) <= 0) {
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_RSA);
					goto err;
				}
				s2n(u, p);
				n += u + 2;
			} else
			if (pkey->type == EVP_PKEY_DSA) {
				/* lets do DSS */
				EVP_SignInit_ex(&md_ctx, EVP_dss1(), NULL);
				EVP_SignUpdate(&md_ctx, &(s->s3->client_random[0]), SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx, &(s->s3->server_random[0]), SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx, &(d[DTLS1_HM_HEADER_LENGTH]), n);
				if (!EVP_SignFinal(&md_ctx, &(p[2]),
				    (unsigned int *)&i, pkey)) {
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_DSA);
					goto err;
				}
				s2n(i, p);
				n += i + 2;
			} else
			if (pkey->type == EVP_PKEY_EC) {
				/* let's do ECDSA */
				EVP_SignInit_ex(&md_ctx, EVP_ecdsa(), NULL);
				EVP_SignUpdate(&md_ctx, &(s->s3->client_random[0]), SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx, &(s->s3->server_random[0]), SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx, &(d[DTLS1_HM_HEADER_LENGTH]), n);
				if (!EVP_SignFinal(&md_ctx, &(p[2]),
				    (unsigned int *)&i, pkey)) {
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_LIB_ECDSA);
					goto err;
				}
				s2n(i, p);
				n += i + 2;
			} else
			{
				/* Is this error check actually needed? */
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, SSL_R_UNKNOWN_PKEY_TYPE);
				goto f_err;
			}
		}

		d = dtls1_set_message_header(s, d,
		SSL3_MT_SERVER_KEY_EXCHANGE, n, 0, n);

		/* we should now have things packed up, so lets send
		 * it off */
		s->init_num = n + DTLS1_HM_HEADER_LENGTH;
		s->init_off = 0;

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
	}

	s->state = SSL3_ST_SW_KEY_EXCH_B;
	EVP_MD_CTX_cleanup(&md_ctx);
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
f_err:
	ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
	free(encodedPoint);
	BN_CTX_free(bn_ctx);
	EVP_MD_CTX_cleanup(&md_ctx);
	return (-1);
@


1.60
log
@Uncopy and unpaste dtls1_send_server_hello().
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.59 2015/09/12 13:09:07 jsing Exp $ */
d443 1
a443 1
			ret = dtls1_send_server_done(s);
a698 14
	return (ssl3_handshake_write(s));
}

int
dtls1_send_server_done(SSL *s)
{
	if (s->state == SSL3_ST_SW_SRVR_DONE_A) {
		ssl3_handshake_msg_start(s, SSL3_MT_SERVER_DONE);
		ssl3_handshake_msg_finish(s, 0);

		s->state = SSL3_ST_SW_SRVR_DONE_B;
	}

	/* SSL3_ST_SW_SRVR_DONE_B */
@


1.59
log
@Uncopy and unpaste dtls1_send_hello_request().
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.58 2015/09/11 18:08:21 jsing Exp $ */
d349 1
a349 1
			ret = dtls1_send_server_hello(s);
a698 64
	return (ssl3_handshake_write(s));
}

int
dtls1_send_server_hello(SSL *s)
{
	unsigned char *bufend;
	unsigned char *p, *d;
	unsigned int sl;

	if (s->state == SSL3_ST_SW_SRVR_HELLO_A) {
		d = p = ssl3_handshake_msg_start(s, SSL3_MT_SERVER_HELLO);

		*(p++) = s->version >> 8;
		*(p++) = s->version & 0xff;

		/* Random stuff */
		arc4random_buf(s->s3->server_random, SSL3_RANDOM_SIZE);
		memcpy(p, s->s3->server_random, SSL3_RANDOM_SIZE);
		p += SSL3_RANDOM_SIZE;

		/* now in theory we have 3 options to sending back the
		 * session id.  If it is a re-use, we send back the
		 * old session-id, if it is a new session, we send
		 * back the new session-id or we send back a 0 length
		 * session-id if we want it to be single use.
		 * Currently I will not implement the '0' length session-id
		 * 12-Jan-98 - I'll now support the '0' length stuff.
		 */
		if (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER))
			s->session->session_id_length = 0;

		sl = s->session->session_id_length;
		if (sl > sizeof s->session->session_id) {
			SSLerr(SSL_F_DTLS1_SEND_SERVER_HELLO,
			    ERR_R_INTERNAL_ERROR);
			return -1;
		}
		*(p++) = sl;
		memcpy(p, s->session->session_id, sl);
		p += sl;

		/* put the cipher */
		if (s->s3->tmp.new_cipher == NULL)
			return -1;
		s2n(ssl3_cipher_get_value(s->s3->tmp.new_cipher), p);

		/* put the compression method */
		*(p++) = 0;

		bufend = (unsigned char *)s->init_buf->data +
		    SSL3_RT_MAX_PLAIN_LENGTH;
		if ((p = ssl_add_serverhello_tlsext(s, p, bufend)) == NULL) {
			SSLerr(SSL_F_DTLS1_SEND_SERVER_HELLO,
			    ERR_R_INTERNAL_ERROR);
			return -1;
		}

		ssl3_handshake_msg_finish(s, p - d);

		s->state = SSL3_ST_SW_SRVR_HELLO_B;
	}

	/* SSL3_ST_SW_SRVR_HELLO_B */
@


1.58
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.57 2015/09/11 16:28:37 jsing Exp $ */
d274 1
a274 1
			ret = dtls1_send_hello_request(s);
a666 14
}

int
dtls1_send_hello_request(SSL *s)
{
	if (s->state == SSL3_ST_SW_HELLO_REQ_A) {
		ssl3_handshake_msg_start(s, SSL3_MT_HELLO_REQUEST);
		ssl3_handshake_msg_finish(s, 0);

		s->state = SSL3_ST_SW_HELLO_REQ_B;
	}

	/* SSL3_ST_SW_HELLO_REQ_B */
	return (ssl3_handshake_write(s));
@


1.57
log
@Replace dtls1_send_finished() with ssl3_send_finished() - they're now
both essentially the same (in fact DTLS benefits from improvements
previously made to the ssl3_send_finished() function).

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.56 2015/09/10 17:57:50 jsing Exp $ */
d252 1
a252 1
				if (!ssl3_init_finished_mac(s)) {
d281 1
a281 1
			if (!ssl3_init_finished_mac(s)) {
d338 1
a338 1
			if (!ssl3_init_finished_mac(s)) {
d605 1
a605 1
			ssl3_cleanup_key_block(s);
@


1.56
log
@Remove support for DTLS_BAD_VER. We do not support non-standard and
incomplete implementations just so that we can interoperate with products
from vendors who have not bothered to fix things in the last ~10 years.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.55 2015/06/18 22:51:05 doug Exp $ */
d587 1
a587 1
			ret = dtls1_send_finished(s,
@


1.55
log
@Remove Microsoft Server Gated Crypto.

Another relic due to the old US crypto policy.

From OpenSSL commit 63eab8a620944a990ab3985620966ccd9f48d681 and
95275599399e277e71d064790a1f828a99fc661a.

ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.54 2015/06/18 22:30:47 doug Exp $ */
d338 3
a340 5
			if (s->version != DTLS1_BAD_VER) {
				if (!ssl3_init_finished_mac(s)) {
					ret = -1;
					goto end;
				}
@


1.54
log
@Change DTLS client cert request code to match TLS.

DTLS currently doesn't check whether a client cert is expected.  This
change makes the logic in dtls1_accept() match that from ssl3_accept().
From OpenSSL commit c8d710dc5f83d69d802f941a4cc5895eb5fe3d65

input + ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.53 2015/06/15 05:32:58 doug Exp $ */
d471 4
a474 15
			/* Check for second client hello (MS SGC) */
			ret = ssl3_check_client_hello(s);
			if (ret <= 0)
				goto end;
			if (ret == 2) {
				dtls1_stop_timer(s);
				s->state = SSL3_ST_SR_CLNT_HELLO_C;
			} else {
				if (s->s3->tmp.cert_request) {
					ret = ssl3_get_client_certificate(s);
					if (ret <= 0)
						goto end;
				}
				s->init_num = 0;
				s->state = SSL3_ST_SR_KEY_EXCH_A;
d476 2
@


1.53
log
@Remove ancient SSL_OP_NETSCAPE_CA_DN_BUG from SSLeay days.

This commit matches the OpenSSL removal in commit
3c33c6f6b10864355553961e638514a6d1bb00f6.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.52 2015/06/13 08:38:10 doug Exp $ */
d479 5
a483 5
				/* could be sent for a DH cert, even if we
				 * have not asked for it :-) */
				ret = ssl3_get_client_certificate(s);
				if (ret <= 0)
					goto end;
@


1.52
log
@Fix bad indenting in LibreSSL.

jsg@@ noticed that some of the lines in libssl and libcrypto are not
indented properly.  At a quick glance, it looks like it has a different
control flow than it really does.  I checked the history in our tree and
in OpenSSL to make sure these were simple mistakes.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.51 2015/05/15 11:00:14 jsg Exp $ */
d1167 4
a1170 14
				if (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG)) {
					s2n(j, p);
					i2d_X509_NAME(name, &p);
					n += 2 + j;
					nl += 2 + j;
				} else {
					d = p;
					i2d_X509_NAME(name, &p);
					j -= 2;
					s2n(j, d);
					j += 2;
					n += j;
					nl += j;
				}
@


1.51
log
@Fix return paths with missing EVP_CIPHER_CTX_cleanup() calls.
ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.50 2015/03/27 12:29:54 jsing Exp $ */
d528 1
a528 1
				s->state = SSL3_ST_SR_FINISHED_A;
@


1.50
log
@Factor out the init_buf initialisation code, rather than duplicating it
in four different places.

ok doug@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.49 2015/02/09 10:53:28 jsing Exp $ */
d1291 1
@


1.49
log
@Jettison DTLS over SCTP.

OpenBSD does not have SCTP support and it sees little use in the wild.
OPENSSL_NO_SCTP is already specified via opensslfeatures.h, hence this
is a code removal only and symbols should remain unchanged.

ok beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.48 2015/02/07 08:56:39 jsing Exp $ */
d231 3
a233 12
			if (s->init_buf == NULL) {
				BUF_MEM *buf;
				if ((buf = BUF_MEM_new()) == NULL) {
					ret = -1;
					goto end;
				}
				if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {
					BUF_MEM_free(buf);
					ret = -1;
					goto end;
				}
				s->init_buf = buf;
a234 1

@


1.48
log
@Convert several of the server side handshake functions to the new handshake
message handling routines.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.47 2015/02/06 08:30:23 jsing Exp $ */
a184 4
#ifndef OPENSSL_NO_SCTP
	unsigned char sctpauthkey[64];
	char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];
#endif
a201 8
#ifndef OPENSSL_NO_SCTP
	/* Notify SCTP BIO socket to enter handshake
	 * mode and prevent stream identifier other
	 * than 0. Will be ignored if no SCTP is used.
	 */
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,
	    s->in_handshake, NULL);
#endif
a256 3
#ifndef OPENSSL_NO_SCTP
				if (!BIO_dgram_is_sctp(SSL_get_wbio(s)))
#endif
a355 34
#ifndef OPENSSL_NO_SCTP
		case DTLS1_SCTP_ST_SR_READ_SOCK:

			if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {
				s->s3->in_read_app_data = 2;
				s->rwstate = SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				ret = -1;
				goto end;
			}

			s->state = SSL3_ST_SR_FINISHED_A;
			break;

		case DTLS1_SCTP_ST_SW_WRITE_SOCK:
			ret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));
			if (ret < 0)
				goto end;

			if (ret == 0) {
				if (s->d1->next_state != SSL_ST_OK) {
					s->s3->in_read_app_data = 2;
					s->rwstate = SSL_READING;
					BIO_clear_retry_flags(SSL_get_rbio(s));
					BIO_set_retry_read(SSL_get_rbio(s));
					ret = -1;
					goto end;
				}
			}

			s->state = s->d1->next_state;
			break;
#endif
a365 16
#ifndef OPENSSL_NO_SCTP
				/* Add new shared key for SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				snprintf((char*)labelbuffer,
				    sizeof(DTLS1_SCTP_AUTH_LABEL),
				    DTLS1_SCTP_AUTH_LABEL);

				SSL_export_keying_material(s, sctpauthkey,
				    sizeof(sctpauthkey), labelbuffer,
				    sizeof(labelbuffer), NULL, 0, 0);

				BIO_ctrl(SSL_get_wbio(s),
				    BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
				    sizeof(sctpauthkey), sctpauthkey);
#endif
a440 6
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {
					s->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;
					s->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
				}
#endif
a447 6
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {
					s->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;
					s->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
				}
#endif
a503 16
#ifndef OPENSSL_NO_SCTP
			/* Add new shared key for SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			snprintf((char *)labelbuffer,
			    sizeof(DTLS1_SCTP_AUTH_LABEL),
			    DTLS1_SCTP_AUTH_LABEL);

			SSL_export_keying_material(s, sctpauthkey,
			    sizeof(sctpauthkey), labelbuffer,
			    sizeof(labelbuffer), NULL, 0, 0);

			BIO_ctrl(SSL_get_wbio(s),
			    BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
			    sizeof(sctpauthkey), sctpauthkey);
#endif
a537 6
#ifndef OPENSSL_NO_SCTP
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
			    state == SSL_ST_RENEGOTIATE)
				s->state = DTLS1_SCTP_ST_SR_READ_SOCK;
			else
#endif
a592 9
#ifndef OPENSSL_NO_SCTP
			if (!s->hit) {
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s),
				    BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
			}
#endif
a617 7
#ifndef OPENSSL_NO_SCTP
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s),
				    BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
#endif
a619 6
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
				}
#endif
a683 8
#ifndef OPENSSL_NO_SCTP
	/* Notify SCTP BIO socket to leave handshake
	 * mode and prevent stream identifier other
	 * than 0. Will be ignored if no SCTP is used.
	 */
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE,
	    s->in_handshake, NULL);
#endif
@


1.47
log
@Bring back the horrible API that is get_cipher_by_char/put_cipher_by_char.

This API was intended to be an internal only, however like many things in
OpenSSL, it is exposed externally and parts of the software ecosystem are
now using it since there is no real alternative within the public API.

ok doug@@, tedu@@ and reluctantly miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.46 2014/12/15 00:46:53 doug Exp $ */
a821 2
	unsigned char *p;

d823 2
a824 2
		p = (unsigned char *)s->init_buf->data;
		p = dtls1_set_message_header(s, p, SSL3_MT_HELLO_REQUEST, 0, 0, 0);
a826 6
		/* number of bytes to write */
		s->init_num = DTLS1_HM_HEADER_LENGTH;
		s->init_off = 0;

		/* no need to buffer this message, since there are no retransmit
		 * requests for it */
d830 1
a830 1
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
d836 1
a836 2
	unsigned int msg_len;
	unsigned char *msg, *buf, *p;
d839 2
a840 1
		buf = (unsigned char *)s->init_buf->data;
a841 1
		msg = p = &(buf[DTLS1_HM_HEADER_LENGTH]);
d846 4
a849 3
			s->ctx->app_gen_cookie_cb(s, s->d1->cookie,
		&(s->d1->cookie_len)) == 0) {
			SSLerr(SSL_F_DTLS1_SEND_HELLO_VERIFY_REQUEST, ERR_R_INTERNAL_ERROR);
a855 1
		msg_len = p - msg;
d857 1
a857 2
		dtls1_set_message_header(s, buf,
		DTLS1_MT_HELLO_VERIFY_REQUEST, msg_len, 0, msg_len);
a859 3
		/* number of bytes to write */
		s->init_num = p - buf;
		s->init_off = 0;
d863 1
a863 1
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
d869 1
a869 1
	unsigned char *buf;
a871 1
	unsigned long l;
d874 1
a874 5
		buf = (unsigned char *)s->init_buf->data;
		arc4random_buf(s->s3->server_random, SSL3_RANDOM_SIZE);

		/* Do the message type and length last */
		d = p= &(buf[DTLS1_HM_HEADER_LENGTH]);
d877 1
a877 1
		*(p++) = s->version&0xff;
d880 1
d897 2
a898 1
			SSLerr(SSL_F_DTLS1_SEND_SERVER_HELLO, ERR_R_INTERNAL_ERROR);
d913 5
a917 2
		if ((p = ssl_add_serverhello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH)) == NULL) {
			SSLerr(SSL_F_DTLS1_SEND_SERVER_HELLO, ERR_R_INTERNAL_ERROR);
d921 1
a921 5
		/* do the header */
		l = (p - d);
		d = buf;

		d = dtls1_set_message_header(s, d, SSL3_MT_SERVER_HELLO, l, 0, l);
a923 6
		/* number of bytes to write */
		s->init_num = p - buf;
		s->init_off = 0;

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
d927 1
a927 1
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
a932 2
	unsigned char *p;

d934 2
a935 4
		p = (unsigned char *)s->init_buf->data;

		/* do the header */
		p = dtls1_set_message_header(s, p, SSL3_MT_SERVER_DONE, 0, 0, 0);
a937 6
		/* number of bytes to write */
		s->init_num = DTLS1_HM_HEADER_LENGTH;
		s->init_off = 0;

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
d941 1
a941 1
	return (dtls1_do_write(s, SSL3_RT_HANDSHAKE));
@


1.46
log
@Add error handling for EVP_DigestInit_ex().

A few EVP_DigestInit_ex() calls were left alone since reporting an
error would change the public API.

Changed internal ssl3_cbc_digest_record() to return a value due to the above
change.  It will also now set md_out_size=0 on failure.

This is based on part of BoringSSL's commit to fix malloc crashes:
https://boringssl.googlesource.com/boringssl/+/69a01608f33ab6fe2c3485d94aef1fe9eacf5364

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.45 2014/12/14 15:30:50 jsing Exp $ */
d150 2
@


1.45
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.44 2014/12/14 13:45:47 jsing Exp $ */
d1216 3
a1218 2
					EVP_DigestInit_ex(&md_ctx, (num == 2)
					    ? s->ctx->md5 : s->ctx->sha1, NULL);
@


1.44
log
@unifdef NETSCAPE_HANG_BUG from the DTLS code. The code is not currently
enabled and I would hope that no one is using client certificates with DTLS
and Netscape, assuming it even supported it...

ok bcook@@ miod@@
@
text
@d1 2
a2 2
/* $OpenBSD: d1_srvr.c,v 1.43 2014/12/10 15:43:31 jsing Exp $ */
/* 
d4 1
a4 1
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.  
d14 1
a14 1
 *    notice, this list of conditions and the following disclaimer. 
d65 1
a65 1
 * 
d72 1
a72 1
 * 
d79 1
a79 1
 * 
d94 1
a94 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d97 1
a97 1
 * 
d109 1
a109 1
 * 
d612 1
a612 1
				 * a client cert, it can be verified */ 
d634 1
a634 1
#endif			
d831 1
a831 1
		/* no need to buffer this message, since there are no retransmit 
d1093 1
a1093 1
			 * keys over named (not generic) curves. For 
d1133 1
a1133 1
			/* XXX: For now, we only support named (not 
d1137 1
a1137 1
			 * structure. 
@


1.43
log
@ssl3_init_finished_mac() calls BIO_new() which can fail since it in turn
calls malloc(). Instead of silently continuing on failure, check the return
value of BIO_new() and propagate failure back to the caller for appropriate
handling.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.42 2014/11/16 14:12:47 jsing Exp $ */
a515 1
#ifndef NETSCAPE_HANG_BUG
a522 10
#else
				s->state = SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state = SSL3_ST_SR_CERT_A;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
				}
#endif
#endif
a1366 11
#ifdef NETSCAPE_HANG_BUG
/* XXX: what to do about this? */
		p = (unsigned char *)s->init_buf->data + s->init_num;

		/* do the header */
		*(p++) = SSL3_MT_SERVER_DONE;
		*(p++) = 0;
		*(p++) = 0;
		*(p++) = 0;
		s->init_num += 4;
#endif
@


1.42
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.41 2014/10/31 14:51:01 jsing Exp $ */
d275 5
a279 1
				ssl3_init_finished_mac(s);
d304 4
a307 1
			ssl3_init_finished_mac(s);
d361 6
a366 2
			if (s->version != DTLS1_BAD_VER)
				ssl3_init_finished_mac(s);
@


1.41
log
@Remove support for ephemeral/temporary RSA private keys.

The only use for these is via SSL_OP_EPHEMERAL_RSA (which is effectively
a standards violation) and for RSA sign-only, should only be possible if
you are using an export cipher and have an RSA private key that is more
than 512 bits in size (however we no longer support export ciphers).

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.40 2014/10/18 16:13:16 jsing Exp $ */
d117 1
d119 2
d122 3
a125 1
#include <openssl/evp.h>
a126 3
#include <openssl/md5.h>
#include <openssl/bn.h>
#include <openssl/dh.h>
@


1.40
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.39 2014/09/27 11:03:43 jsing Exp $ */
d449 2
a450 21
			/* clear this, it may get reset by
			 * send_server_key_exchange */
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
			)
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
				 * even when forbidden by protocol specs
				 * (handshake may fail as clients are not required to
				 * be able to handle this) */
				s->s3->tmp.use_rsa_tmp = 1;
			else
				s->s3->tmp.use_rsa_tmp = 0;

			/* only send if a DH key exchange or
			 * RSA but we have a sign only certificate */
			if (s->s3->tmp.use_rsa_tmp
			|| (alg_k & (SSL_kDHE|SSL_kECDHE))
			|| ((alg_k & SSL_kRSA)
			&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
			)
			)
			) {
a977 1
	RSA *rsa;
d1007 1
a1007 22
		if (type & SSL_kRSA) {
			rsa = cert->rsa_tmp;
			if ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL)) {
				rsa = s->cert->rsa_tmp_cb(s, 0,
				    SSL_C_PKEYLENGTH(s->s3->tmp.new_cipher));
				if (rsa == NULL) {
					al = SSL_AD_HANDSHAKE_FAILURE;
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, SSL_R_ERROR_GENERATING_TMP_RSA_KEY);
					goto f_err;
				}
				RSA_up_ref(rsa);
				cert->rsa_tmp = rsa;
			}
			if (rsa == NULL) {
				al = SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, SSL_R_MISSING_TMP_RSA_KEY);
				goto f_err;
			}
			r[0] = rsa->n;
			r[1] = rsa->e;
			s->s3->tmp.use_rsa_tmp = 1;
		} else
d1049 1
a1049 2
		} else
		if (type & SSL_kECDHE) {
d1146 1
a1146 2
		} else
		{
d1148 2
a1149 1
			SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
@


1.39
log
@There is not much point checking ecdhp is not NULL... twice.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.38 2014/09/07 12:16:23 jsing Exp $ */
a118 1
#include <openssl/rand.h>
d904 1
a904 2
		p = s->s3->server_random;
		RAND_pseudo_bytes(p, SSL3_RANDOM_SIZE);
d1514 1
a1514 1
			RAND_pseudo_bytes(iv, 16);
@


1.38
log
@Remove SSL_kDHr, SSL_kDHd and SSL_aDH. No supported ciphersuites use them,
nor do we plan on supporting them.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.37 2014/08/24 14:36:45 jsing Exp $ */
a1111 4
			if (ecdhp == NULL) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_ECDH_LIB);
				goto err;
			}
d1116 1
a1117 1
			s->s3->tmp.ecdh = ecdh;
@


1.37
log
@Replace the remaining uses of ssl3_put_cipher_by_char() with s2n and a
ssl3_cipher_get_value() helper function, which returns the cipher suite
value for the given cipher.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.36 2014/08/10 14:42:56 jsing Exp $ */
d465 1
a465 2
			|| (alg_k & (SSL_kDHE|SSL_kDHr|SSL_kDHd))
			|| (alg_k & SSL_kECDHE)
@


1.36
log
@Since we no longer need to support SSLv2-style cipher lists, start
unravelling the maze of function pointers and callbacks by directly
calling ssl3_{get,put}_cipher_by_char() and removing the
ssl_{get,put}_cipher_by_char macros.

Prompted by similar changes in boringssl.

ok guenther.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.35 2014/08/06 20:11:09 miod Exp $ */
a900 1
	int i;
d942 1
a942 2
		i = ssl3_put_cipher_by_char(s->s3->tmp.new_cipher, p);
		p += i;
@


1.35
log
@Prevent a possible use after free by mimicing the s3_srvr.c fixes contributed by
Adam Langley close to three years ago, which were commited in
https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=e7928282d0148af5f28fa3437a625a2006af0214

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.34 2014/07/28 04:23:12 guenther Exp $ */
a148 2
	.get_cipher_by_char = ssl3_get_cipher_by_char,
	.put_cipher_by_char = ssl3_put_cipher_by_char,
@


1.34
log
@The RSA, DH, and ECDH temporary key callbacks expect the number of keybits
for the key (expressed in RSA key bits, which makes *no sense* for ECDH) as
their second argument, not zero.

(jsing@@ notes that the RSA callback is only invoked for 'export' ciphers,
which have been removed from LibreSSL, and for the SSL_OP_EPHEMERAL_RSA
option, which is makes the application non-compliant.  More fuel for the
tedu fire...)

jasper@@ noted the breakage and bisected it down to the diff that broke this
ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.33 2014/07/12 22:33:39 jsing Exp $ */
a1067 1
				DH_free(dh);
a1111 2
				EC_KEY_free(s->s3->tmp.ecdh);

@


1.33
log
@The correct name for EDH is DHE, likewise EECDH should be ECDHE.

Based on changes to OpenSSL trunk.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.32 2014/07/12 13:11:53 jsing Exp $ */
d1037 2
a1038 1
				rsa = s->cert->rsa_tmp_cb(s, 0, 0);
d1059 2
a1060 1
				dhp = s->cert->dh_tmp_cb(s, 0, 0);
d1104 2
a1105 1
				ecdhp = s->cert->ecdh_tmp_cb(s, 0, 0);
@


1.32
log
@Remove remnants from PSK, KRB5 and SRP.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.31 2014/07/12 10:06:04 jsing Exp $ */
d467 2
a468 2
			|| (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
			|| (alg_k & SSL_kEECDH)
d1055 1
a1055 1
		if (type & SSL_kEDH) {
d1097 1
a1097 1
		if (type & SSL_kEECDH) {
d1235 1
a1235 1
		if (type & SSL_kEECDH) {
@


1.31
log
@Place comments in a block above the if statement, rather than attempting
to interleave them within the conditions. Also fix wrapping and
indentation.
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.30 2014/07/11 09:24:44 beck Exp $ */
d430 3
a432 3
			/* Check if it is anon DH or normal PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
			    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {
a502 5
			 *
			 * - We are using a Kerberos ciphersuite.
			 *
			 * - We are using normal PSK certificates and
			 *   Certificate Requests are omitted
d509 1
a509 5
			     SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
			    (s->s3->tmp.new_cipher->algorithm_auth &
			     SSL_aKRB5) ||
			    (s->s3->tmp.new_cipher->algorithm_mkey &
			     SSL_kPSK)) {
d1210 1
a1210 2
		if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
		    && !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {
d1456 3
a1458 6
			/* VRS: allow null cert if auth == KRB5 */
			if ((s->s3->tmp.new_cipher->algorithm_mkey != SSL_kKRB5) ||
				(s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5)) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
				return (0);
			}
@


1.30
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.29 2014/07/10 08:51:14 tedu Exp $ */
d487 23
a509 4
			if (/* don't request cert unless asked for it: */
			    !(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
d511 8
a518 13
			    (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section "Certificate request" in SSL 3 drafts
				 * and in RFC 2246): */
			    ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
			    !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				/* never request cert in Kerberos ciphersuites */
			    (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
			    || (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) {
@


1.29
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.28 2014/07/09 11:25:42 jsing Exp $ */
a466 5
			/* PSK: send ServerKeyExchange if PSK identity
			 * hint if provided */
#ifndef OPENSSL_NO_PSK
			|| ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
a1008 3
#ifndef OPENSSL_NO_PSK
	size_t pskhintlen = 0;
#endif
a1194 7
#ifndef OPENSSL_NO_PSK
		if (type & SSL_kPSK) {
			pskhintlen = strlen(s->ctx->psk_identity_hint);
			/* reserve size for record length and PSK identity hint*/
			n += 2 + pskhintlen;
		} else
#endif /* !OPENSSL_NO_PSK */
a1252 9
#ifndef OPENSSL_NO_PSK
		if (type & SSL_kPSK) {
			/* copy PSK identity hint */
			s2n(pskhintlen, p);

			memcpy(p, s->ctx->psk_identity_hint, pskhintlen);
			p += pskhintlen;
		}
#endif
@


1.28
log
@tedu the SSL export cipher handling - since we do not have enabled export
ciphers we no longer need the flags or code to support it.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.27 2014/06/30 14:13:27 tedu Exp $ */
a948 1
#ifdef OPENSSL_NO_COMP
a949 6
#else
		if (s->s3->tmp.new_compression == NULL)
			*(p++) = 0;
		else
			*(p++) = s->s3->tmp.new_compression->id;
#endif
@


1.27
log
@fix the identical leak in three different files.
reported by Brent Cook, original diff by logan
@
text
@d1 1
a1 1
/* $OpenBSD: d1_srvr.c,v 1.26 2014/06/12 15:49:31 deraadt Exp $ */
a475 3
			|| (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
			&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
			)
d1047 1
a1047 3
				rsa = s->cert->rsa_tmp_cb(s,
				SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
d1068 1
a1068 3
				dhp = s->cert->dh_tmp_cb(s,
				    SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				    SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
d1111 2
a1112 5
			if ((ecdhp == NULL) && (s->cert->ecdh_tmp_cb != NULL)) {
				ecdhp = s->cert->ecdh_tmp_cb(s,
				SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
			}
a1149 6
				goto err;
			}

			if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
			    (EC_GROUP_get_degree(group) > 163)) {
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
@


1.26
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a178 1
	BUF_MEM *buf;
d243 1
d249 1
@


1.25
log
@http://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2016265dfbab162ec30718b5e7480add42598158
Don't know the full story, but it looks like a "can't do random
perfectly, so do it god awful" problem was found in 2013, and
replaced with "only do it badly if a flag is set".  New flags
(SSL_MODE_SEND_SERVERHELLO_TIME and SSL_MODE_SEND_SERVERHELLO_TIME)
were added [Ben Laurie?] to support the old scheme of "use time_t
for first 4 bytes of the random buffer".

Nothing uses these flags [ecosystem scan by sthen]

Fully discourage use of these flags in the future by removing
support & definition of them.  The buflen < 4 check is also interesting,
because no entropy would be returned.  No callers passed such small
buffers.
ok miod sthen
@
text
@d1 1
a1 1
/* ssl/d1_srvr.c */
@


1.24
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@d912 2
a913 1
		ssl_fill_hello_random(s, 1, p, SSL3_RANDOM_SIZE);
@


1.23
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@a417 1
#ifndef OPENSSL_NO_TLSEXT
a421 3
#else
				s->state = SSL3_ST_SW_CHANGE_A;
#endif
a435 1
#ifndef OPENSSL_NO_TLSEXT
a443 6
#else
			} else
				skip = 1;

			s->state = SSL3_ST_SW_KEY_EXCH_A;
#endif
a671 1
#ifndef OPENSSL_NO_TLSEXT
a673 1
#endif
a678 1
#ifndef OPENSSL_NO_TLSEXT
a696 1
#endif
a958 1
#ifndef OPENSSL_NO_TLSEXT
a962 1
#endif
a1517 1
#ifndef OPENSSL_NO_TLSEXT
a1622 1
#endif
@


1.22
log
@unidef DH, ECDH, and ECDSA. there's no purpose to a libssl without them.
ok deraadt jsing
@
text
@a784 5
#if 0
			BUF_MEM_free(s->init_buf);
			s->init_buf = NULL;
#endif

@


1.21
log
@More KNF.
@
text
@a124 1
#ifndef OPENSSL_NO_DH
a125 1
#endif
a1036 1
#ifndef OPENSSL_NO_DH
a1037 2
#endif
#ifndef OPENSSL_NO_ECDH
a1043 1
#endif
a1089 1
#ifndef OPENSSL_NO_DH
a1133 2
#endif
#ifndef OPENSSL_NO_ECDH
a1245 1
#endif /* !OPENSSL_NO_ECDH */
a1288 1
#ifndef OPENSSL_NO_ECDH
a1309 1
#endif
a1366 1
#if !defined(OPENSSL_NO_ECDSA)
a1380 1
#endif
a1406 1
#ifndef OPENSSL_NO_ECDH
a1408 1
#endif
@


1.20
log
@DeIMPLEMENT libssl. Expand the IMPLEMENT_* macros since it is far more
readable and one less layer of abstraction. Use C99 initialisers for
clarity, grepability and to protect from future field reordering/removal.

ok miod@@ (tedu@@ also thought it was a wonderful idea, beck@@ also agreed,
but ran away squealing since it reminded him of the VOP layer...)
@
text
@d1316 1
a1316 2
			(unsigned char *)encodedPoint,
			encodedlen);
d1603 1
a1603 1
				&hctx, 1) < 0) {
@


1.19
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@d132 38
a176 3

IMPLEMENT_dtls1_meth_func(DTLSv1_server_method,
    dtls1_accept, ssl_undefined_function, dtls1_get_server_method)
@


1.18
log
@Make libssl and libcrypto compile with -Werror
ok miod@@
@
text
@a431 3
#ifndef OPENSSL_NO_KRB5
			&& !(alg_k & SSL_kKRB5)
#endif /* OPENSSL_NO_KRB5 */
@


1.17
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@d1019 1
a1019 1
	size_t pskhintlen;
@


1.16
log
@More KNF and style consistency tweaks
@
text
@d1185 1
a1185 2
			encodedPoint = (unsigned char *)
			malloc(encodedlen*sizeof(unsigned char));
@


1.15
log
@always build in RSA and DSA. ok deraadt miod
@
text
@d132 2
a133 2
static const SSL_METHOD
*dtls1_get_server_method(int ver)
d137 1
a137 2
	else
		return (NULL);
@


1.14
log
@fix a potential double free
ok miod@@
@
text
@a1002 1
#ifndef OPENSSL_NO_RSA
a1007 1
#endif
a1041 1
#ifndef OPENSSL_NO_RSA
a1064 1
#endif
a1308 1
#ifndef OPENSSL_NO_RSA
a1335 2
#endif
#if !defined(OPENSSL_NO_DSA)
a1349 1
#endif
@


1.13
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d1293 1
d1401 1
a1401 2
	if (encodedPoint != NULL)
		free(encodedPoint);
@


1.12
log
@strncpy(d, s, strlen(s)) is a special kind of stupid. even when it's right,
it looks wrong. replace with auditable code and eliminate many strlen calls
to improve efficiency. (wait, did somebody say FASTER?) ok beck
@
text
@d1191 1
a1191 1
			OPENSSL_malloc(encodedlen*sizeof(unsigned char));
d1292 1
a1292 1
			OPENSSL_free(encodedPoint);
d1401 1
a1401 1
		OPENSSL_free(encodedPoint);
d1567 1
a1567 1
		senc = OPENSSL_malloc(slen);
d1583 1
a1583 1
				OPENSSL_free(senc);
d1627 1
a1627 1
		OPENSSL_free(senc);
@


1.11
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@d1021 3
d1232 1
d1234 1
a1234 1
			n += 2 + strlen(s->ctx->psk_identity_hint);
d1300 1
a1300 1
			s2n(strlen(s->ctx->psk_identity_hint), p);
d1302 2
a1303 2
			strncpy((char *)p, s->ctx->psk_identity_hint, strlen(s->ctx->psk_identity_hint));
			p += strlen(s->ctx->psk_identity_hint);
@


1.10
log
@So the OpenSSL codebase does "get the time, add it as a random seed"
in a bunch of places inside the TLS engine, to try to keep entropy high.
I wonder if their moto is "If you can't solve a problem, at least try
to do it badly".
ok miod
@
text
@a187 12
#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending) {
		dtls1_stop_timer(s);
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
	}
#endif

@


1.9
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a147 1
	unsigned long Time = (unsigned long)time(NULL);
a157 1
	RAND_add(&Time, sizeof(Time), 0);
@


1.8
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@d132 3
a134 2
static const SSL_METHOD *dtls1_get_server_method(int ver)
	{
d136 1
a136 1
		return(DTLSv1_server_method());
d138 2
a139 2
		return(NULL);
	}
d142 1
a142 3
			dtls1_accept,
			ssl_undefined_function,
			dtls1_get_server_method)
d144 3
a146 2
int dtls1_accept(SSL *s)
	{
d148 2
a149 2
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
d151 2
a152 2
	int ret= -1;
	int new_state,state,skip=0;
d159 1
a159 1
	RAND_add(&Time,sizeof(Time),0);
d164 1
a164 1
		cb=s->info_callback;
d166 2
a167 2
		cb=s->ctx->info_callback;
	
d172 2
a173 1
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);
d181 2
a182 1
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
d185 4
a188 5
	if (s->cert == NULL)
		{
		SSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}
d195 1
a195 2
	if (s->tlsext_hb_pending)
		{
d199 1
a199 1
		}
d202 2
a203 3
	for (;;)
		{
		state=s->state;
d205 1
a205 2
		switch (s->state)
			{
d207 1
a207 1
			s->renegotiate=1;
d215 3
a217 2
			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
d219 1
a219 2
			if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00))
				{
d222 2
a223 2
				}
			s->type=SSL_ST_ACCEPT;
d225 3
a227 5
			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
d229 3
a231 4
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
a232 2
					}
				s->init_buf=buf;
d234 2
d237 2
a238 3
			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
d240 1
a240 1
				}
d242 1
a242 1
			s->init_num=0;
d244 1
a244 2
			if (s->state != SSL_ST_RENEGOTIATE)
				{
d252 4
a255 1
					if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
d258 1
a258 1
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
d260 1
a260 3
				}
			else
				{
d264 2
a265 2
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}
d272 1
a272 1
			s->shutdown=0;
d275 6
a280 5
			ret=dtls1_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
d286 1
a286 1
			s->state=SSL_ST_OK;
d293 4
a296 3
			s->shutdown=0;
			ret=ssl3_get_client_hello(s);
			if (ret <= 0) goto end;
d304 1
a304 1
			s->init_num=0;
d307 1
a307 2
			if (listen)
				{
d309 1
a309 1
				}
d312 1
a312 2
			if (listen && s->state == SSL3_ST_SW_SRVR_HELLO_A)
				{
d322 2
a323 2
				}
			
d325 1
a325 1
			
d330 4
a333 3
			if ( ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			s->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;
d339 1
a339 1
			
d342 4
a345 5
			
			if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))		
				{
				s->s3->in_read_app_data=2;
				s->rwstate=SSL_READING;
d350 3
a352 3
				}
			
			s->state=SSL3_ST_SR_FINISHED_A;
d354 1
a354 1
			
d357 7
a363 8
			if (ret < 0) goto end;
			
			if (ret == 0)
				{
				if (s->d1->next_state != SSL_ST_OK)
					{
					s->s3->in_read_app_data=2;
					s->rwstate=SSL_READING;
a367 1
					}
d369 1
d371 1
a371 1
			s->state=s->d1->next_state;
d379 3
a381 2
			ret=dtls1_send_server_hello(s);
			if (ret <= 0) goto end;
d383 1
a383 2
			if (s->hit)
				{
d388 3
a390 2
				snprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
				         DTLS1_SCTP_AUTH_LABEL);
d393 6
a398 5
				                           sizeof(sctpauthkey), labelbuffer,
				                           sizeof(labelbuffer), NULL, 0, 0);
				
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
                         sizeof(sctpauthkey), sctpauthkey);
d402 1
a402 1
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
d404 1
a404 1
					s->state=SSL3_ST_SW_CHANGE_A;
d406 1
a406 1
				s->state=SSL3_ST_SW_CHANGE_A;
d408 3
a410 4
				}
			else
				s->state=SSL3_ST_SW_CERT_A;
			s->init_num=0;
d416 2
a417 3
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
d419 3
a421 2
				ret=dtls1_send_server_certificate(s);
				if (ret <= 0) goto end;
d424 1
a424 1
					s->state=SSL3_ST_SW_CERT_STATUS_A;
d426 2
a427 4
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
d429 2
a430 2
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
d432 2
a433 3
				}
			else
				skip=1;
d435 1
a435 1
			s->state=SSL3_ST_SW_KEY_EXCH_A;
d437 1
a437 1
			s->init_num=0;
d448 1
a448 1
				&& !(alg_k & SSL_kKRB5)
d450 1
a450 1
				)
d455 1
a455 1
				s->s3->tmp.use_rsa_tmp=1;
d457 1
a457 1
				s->s3->tmp.use_rsa_tmp=0;
d465 1
a465 1
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
d467 10
a476 11
			    || (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
			    || (alg_k & SSL_kEECDH)
			    || ((alg_k & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
			    )
				{
d478 5
a482 5
				ret=dtls1_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;
d484 2
a485 2
			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
d491 1
a491 1
				!(s->verify_mode & SSL_VERIFY_PEER) ||
d494 2
a495 2
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
d499 1
a499 1
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
d502 3
a504 3
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
d507 1
a507 2
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
d509 3
a511 3
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
d513 1
a513 2
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
d516 1
a516 1
					}
d518 2
a519 4
				}
			else
				{
				s->s3->tmp.cert_request=1;
d521 3
a523 2
				ret=dtls1_send_certificate_request(s);
				if (ret <= 0) goto end;
d525 1
a525 1
				s->state=SSL3_ST_SW_SRVR_DONE_A;
d527 1
a527 2
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
d530 1
a530 1
					}
d533 2
a534 2
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
d536 1
a536 2
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
d538 2
a539 2
					s->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
d542 2
a543 2
				s->init_num=0;
				}
d549 6
a554 5
			ret=dtls1_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
d556 1
a556 1
		
d558 2
a559 3
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
d561 6
a566 7
				if (!BIO_should_retry(s->wbio))
					{
					s->rwstate=SSL_NOTHING;
					s->state=s->s3->tmp.next_state;
					}
				
				ret= -1;
d568 3
a570 3
				}
			s->rwstate=SSL_NOTHING;
			s->state=s->s3->tmp.next_state;
d579 1
a579 2
			if (ret == 2)
				{
d582 1
a582 2
				}
			else {
d585 5
a589 4
				ret=ssl3_get_client_certificate(s);
				if (ret <= 0) goto end;
				s->init_num=0;
				s->state=SSL3_ST_SR_KEY_EXCH_A;
d595 3
a597 2
			ret=ssl3_get_client_key_exchange(s);
			if (ret <= 0) goto end;
d602 3
a604 2
			snprintf((char *) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
			         DTLS1_SCTP_AUTH_LABEL);
d607 2
a608 2
			                           sizeof(sctpauthkey), labelbuffer,
			                           sizeof(labelbuffer), NULL, 0, 0);
d610 3
a612 2
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
			         sizeof(sctpauthkey), sctpauthkey);
d615 2
a616 2
			s->state=SSL3_ST_SR_CERT_VRFY_A;
			s->init_num=0;
d618 1
a618 2
			if (ret == 2)
				{
d624 4
a627 1
				s->state=SSL3_ST_SR_FINISHED_A;
a628 5
				}
			else
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
d633 1
a633 2
					NID_md5,
					&(s->s3->tmp.cert_verify_md[0]));
d635 3
a637 3
					NID_sha1,
					&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
				}
d645 3
a647 2
			ret=ssl3_get_cert_verify(s);
			if (ret <= 0) goto end;
d651 1
a651 1
				s->state=DTLS1_SCTP_ST_SR_READ_SOCK;
d654 2
a655 2
				s->state=SSL3_ST_SR_FINISHED_A;
			s->init_num=0;
d661 4
a664 3
			ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
				SSL3_ST_SR_FINISHED_B);
			if (ret <= 0) goto end;
d667 1
a667 1
				s->state=SSL_ST_OK;
d670 1
a670 1
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
d673 2
a674 2
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
d680 5
a684 4
			ret=dtls1_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
d689 5
a693 4
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
d701 5
a705 3
			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }
d707 2
a708 2
			ret=dtls1_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);
d710 2
a711 1
			if (ret <= 0) goto end;
d714 1
a714 2
			if (!s->hit)
				{
d718 3
a720 2
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
				}
d723 2
a724 2
			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;
d727 2
a728 3
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
d730 1
a730 1
				}
d737 9
a745 9
			ret=dtls1_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
d751 2
a752 1
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
d754 2
a755 4
				}
			else
				{
				s->s3->tmp.next_state=SSL_ST_OK;
d757 1
a757 2
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
d759 2
a760 2
					s->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
d762 2
a763 2
				}
			s->init_num=0;
d772 1
a772 1
			s->init_buf=NULL;
d778 1
a778 1
			s->init_num=0;
d781 6
a786 6
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
d789 5
a793 1
				s->handshake_func=dtls1_accept;
a794 3
				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
d806 2
a807 2
			SSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
d810 6
a816 9
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}

d818 5
a822 7
			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
a823 1
		skip=0;
d825 2
d832 6
a837 5
		/* Notify SCTP BIO socket to leave handshake
		 * mode and prevent stream identifier other
		 * than 0. Will be ignored if no SCTP is used.
		 */
		BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
d841 7
a847 6
		cb(s,SSL_CB_ACCEPT_EXIT,ret);
	return(ret);
	}

int dtls1_send_hello_request(SSL *s)
	{
d850 2
a851 3
	if (s->state == SSL3_ST_SW_HELLO_REQ_A)
		{
		p=(unsigned char *)s->init_buf->data;
d854 1
a854 1
		s->state=SSL3_ST_SW_HELLO_REQ_B;
d856 2
a857 2
		s->init_num=DTLS1_HM_HEADER_LENGTH;
		s->init_off=0;
d861 1
a861 1
		}
d864 2
a865 2
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
	}
d867 3
a869 2
int dtls1_send_hello_verify_request(SSL *s)
	{
d873 1
a873 2
	if (s->state == DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A)
		{
d881 3
a883 4
		     s->ctx->app_gen_cookie_cb(s, s->d1->cookie,
			 &(s->d1->cookie_len)) == 0)
			{
			SSLerr(SSL_F_DTLS1_SEND_HELLO_VERIFY_REQUEST,ERR_R_INTERNAL_ERROR);
d885 1
a885 1
			}
d893 1
a893 1
			DTLS1_MT_HELLO_VERIFY_REQUEST, msg_len, 0, msg_len);
d895 1
a895 1
		s->state=DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B;
d897 3
a899 3
		s->init_num=p-buf;
		s->init_off=0;
		}
d902 2
a903 2
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
	}
d905 3
a907 2
int dtls1_send_server_hello(SSL *s)
	{
d909 1
a909 1
	unsigned char *p,*d;
d914 3
a916 4
	if (s->state == SSL3_ST_SW_SRVR_HELLO_A)
		{
		buf=(unsigned char *)s->init_buf->data;
		p=s->s3->server_random;
d919 1
a919 1
		d=p= &(buf[DTLS1_HM_HEADER_LENGTH]);
d921 2
a922 2
		*(p++)=s->version>>8;
		*(p++)=s->version&0xff;
d925 2
a926 2
		memcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);
		p+=SSL3_RANDOM_SIZE;
d937 1
a937 1
			s->session->session_id_length=0;
d939 2
a940 3
		sl=s->session->session_id_length;
		if (sl > sizeof s->session->session_id)
			{
d943 4
a946 4
			}
		*(p++)=sl;
		memcpy(p,s->session->session_id,sl);
		p+=sl;
d951 2
a952 2
		i=ssl3_put_cipher_by_char(s->s3->tmp.new_cipher,p);
		p+=i;
d956 1
a956 1
		*(p++)=0;
d959 1
a959 1
			*(p++)=0;
d961 1
a961 1
			*(p++)=s->s3->tmp.new_compression->id;
d965 2
a966 3
		if ((p = ssl_add_serverhello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
			{
			SSLerr(SSL_F_DTLS1_SEND_SERVER_HELLO,ERR_R_INTERNAL_ERROR);
d968 1
a968 1
			}
d972 2
a973 2
		l=(p-d);
		d=buf;
d977 1
a977 1
		s->state=SSL3_ST_SW_SRVR_HELLO_B;
d979 2
a980 2
		s->init_num=p-buf;
		s->init_off=0;
d984 1
a984 1
		}
d987 2
a988 2
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
	}
d990 3
a992 2
int dtls1_send_server_done(SSL *s)
	{
d995 2
a996 3
	if (s->state == SSL3_ST_SW_SRVR_DONE_A)
		{
		p=(unsigned char *)s->init_buf->data;
d1001 1
a1001 1
		s->state=SSL3_ST_SW_SRVR_DONE_B;
d1003 2
a1004 2
		s->init_num=DTLS1_HM_HEADER_LENGTH;
		s->init_off=0;
d1008 1
a1008 1
		}
d1011 2
a1012 2
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
	}
d1014 3
a1016 2
int dtls1_send_server_key_exchange(SSL *s)
	{
d1019 1
a1019 1
	int j,num;
d1021 1
a1021 1
	unsigned char md_buf[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];
d1025 1
a1025 1
	DH *dh=NULL,*dhp;
d1028 1
a1028 1
	EC_KEY *ecdh=NULL, *ecdhp;
d1032 2
a1033 1
	BN_CTX *bn_ctx = NULL; 
d1036 2
a1037 2
	unsigned char *p,*d;
	int al,i;
d1042 1
a1042 1
	int nr[4],kn;
d1047 3
a1049 4
	if (s->state == SSL3_ST_SW_KEY_EXCH_A)
		{
		type=s->s3->tmp.new_cipher->algorithm_mkey;
		cert=s->cert;
d1051 1
a1051 1
		buf=s->init_buf;
d1053 2
a1054 2
		r[0]=r[1]=r[2]=r[3]=NULL;
		n=0;
d1056 9
a1064 12
		if (type & SSL_kRSA)
			{
			rsa=cert->rsa_tmp;
			if ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL))
				{
				rsa=s->cert->rsa_tmp_cb(s,
				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
				if(rsa == NULL)
				{
					al=SSL_AD_HANDSHAKE_FAILURE;
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_ERROR_GENERATING_TMP_RSA_KEY);
d1068 5
a1072 6
				cert->rsa_tmp=rsa;
				}
			if (rsa == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_KEY);
a1073 4
				}
			r[0]=rsa->n;
			r[1]=rsa->e;
			s->s3->tmp.use_rsa_tmp=1;
d1075 4
a1078 1
		else
d1081 2
a1082 3
			if (type & SSL_kEDH)
			{
			dhp=cert->dh_tmp;
d1084 6
a1089 7
				dhp=s->cert->dh_tmp_cb(s,
				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
			if (dhp == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_DH_KEY);
d1091 1
a1091 1
				}
d1093 1
a1093 2
			if (s->s3->tmp.dh != NULL)
				{
d1097 1
a1097 1
				}
d1099 2
a1100 3
			if ((dh=DHparams_dup(dhp)) == NULL)
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);
d1102 1
a1102 1
				}
d1104 7
a1110 11
			s->s3->tmp.dh=dh;
			if ((dhp->pub_key == NULL ||
			     dhp->priv_key == NULL ||
			     (s->options & SSL_OP_SINGLE_DH_USE)))
				{
				if(!DH_generate_key(dh))
				    {
				    SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,
					   ERR_R_DH_LIB);
				    goto err;
				    }
d1112 3
a1114 4
			else
				{
				dh->pub_key=BN_dup(dhp->pub_key);
				dh->priv_key=BN_dup(dhp->priv_key);
d1116 2
a1117 3
					(dh->priv_key == NULL))
					{
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);
a1118 1
					}
a1119 3
			r[0]=dh->p;
			r[1]=dh->g;
			r[2]=dh->pub_key;
d1121 4
a1124 1
		else 
d1127 1
a1127 2
			if (type & SSL_kEECDH)
			{
d1130 9
a1138 11
			ecdhp=cert->ecdh_tmp;
			if ((ecdhp == NULL) && (s->cert->ecdh_tmp_cb != NULL))
				{
				ecdhp=s->cert->ecdh_tmp_cb(s,
				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
				}
			if (ecdhp == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);
d1140 4
a1143 1
				}
a1144 3
			if (s->s3->tmp.ecdh != NULL)
				{
				EC_KEY_free(s->s3->tmp.ecdh); 
d1147 1
a1147 1
				}
d1150 2
a1151 3
			if (ecdhp == NULL)
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
d1153 3
a1155 4
				}
			if ((ecdh = EC_KEY_dup(ecdhp)) == NULL)
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
d1157 1
a1157 1
				}
d1159 1
a1159 1
			s->s3->tmp.ecdh=ecdh;
d1162 4
a1165 7
			    (s->options & SSL_OP_SINGLE_ECDH_USE))
				{
				if(!EC_KEY_generate_key(ecdh))
				    {
				    SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				    goto err;
				    }
d1167 1
d1171 2
a1172 3
			    (EC_KEY_get0_private_key(ecdh) == NULL))
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
d1174 1
a1174 1
				}
d1177 2
a1178 3
			    (EC_GROUP_get_degree(group) > 163)) 
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
d1180 1
a1180 1
				}
d1186 3
a1188 5
			if ((curve_id = 
			    tls1_ec_nid2curve_id(EC_GROUP_get_curve_name(group)))
			    == 0)
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);
d1190 1
a1190 1
				}
d1196 7
a1202 4
			encodedlen = EC_POINT_point2oct(group, 
			    EC_KEY_get0_public_key(ecdh),
			    POINT_CONVERSION_UNCOMPRESSED, 
			    NULL, 0, NULL);
a1203 2
			encodedPoint = (unsigned char *) 
			    OPENSSL_malloc(encodedlen*sizeof(unsigned char)); 
d1205 2
a1206 3
			if ((encodedPoint == NULL) || (bn_ctx == NULL))
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
d1208 2
a1209 1
				}
d1211 4
d1216 2
a1217 8
			encodedlen = EC_POINT_point2oct(group, 
			    EC_KEY_get0_public_key(ecdh), 
			    POINT_CONVERSION_UNCOMPRESSED, 
			    encodedPoint, encodedlen, bn_ctx);

			if (encodedlen == 0) 
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
d1219 1
a1219 1
				}
d1221 2
a1222 1
			BN_CTX_free(bn_ctx);  bn_ctx=NULL;
d1235 5
a1239 6
			r[0]=NULL;
			r[1]=NULL;
			r[2]=NULL;
			r[3]=NULL;
			}
		else 
d1242 4
a1245 6
			if (type & SSL_kPSK)
				{
				/* reserve size for record length and PSK identity hint*/
				n+=2+strlen(s->ctx->psk_identity_hint);
				}
			else
d1247 3
a1249 3
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
d1251 5
a1255 6
			}
		for (i=0; r[i] != NULL; i++)
			{
			nr[i]=BN_num_bytes(r[i]);
			n+=2+nr[i];
			}
d1258 4
a1261 6
			&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
			{
			if ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher, NULL))
				== NULL)
				{
				al=SSL_AD_DECODE_ERROR;
a1262 7
				}
			kn=EVP_PKEY_size(pkey);
			}
		else
			{
			pkey=NULL;
			kn=0;
d1264 5
d1270 2
a1271 3
		if (!BUF_MEM_grow_clean(buf,n+DTLS1_HM_HEADER_LENGTH+kn))
			{
			SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_BUF);
d1273 3
a1275 3
			}
		d=(unsigned char *)s->init_buf->data;
		p= &(d[DTLS1_HM_HEADER_LENGTH]);
d1277 5
a1281 6
		for (i=0; r[i] != NULL; i++)
			{
			s2n(nr[i],p);
			BN_bn2bin(r[i],p);
			p+=nr[i];
			}
d1284 1
a1284 2
		if (type & SSL_kEECDH) 
			{
d1299 3
a1301 3
			memcpy((unsigned char*)p, 
			    (unsigned char *)encodedPoint, 
			    encodedlen);
d1304 1
a1304 1
			}
d1308 1
a1308 2
		if (type & SSL_kPSK)
			{
d1310 2
a1311 1
			s2n(strlen(s->ctx->psk_identity_hint), p); 
d1313 2
a1314 2
			p+=strlen(s->ctx->psk_identity_hint);
			}
d1318 1
a1318 2
		if (pkey != NULL)
			{
d1323 22
a1344 20
			if (pkey->type == EVP_PKEY_RSA)
				{
				q=md_buf;
				j=0;
				for (num=2; num > 0; num--)
					{
					EVP_DigestInit_ex(&md_ctx,(num == 2)
						?s->ctx->md5:s->ctx->sha1, NULL);
					EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
					EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
					EVP_DigestUpdate(&md_ctx,&(d[DTLS1_HM_HEADER_LENGTH]),n);
					EVP_DigestFinal_ex(&md_ctx,q,
						(unsigned int *)&i);
					q+=i;
					j+=i;
					}
				if (RSA_sign(NID_md5_sha1, md_buf, j,
					&(p[2]), &u, pkey->pkey.rsa) <= 0)
					{
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_RSA);
a1345 3
					}
				s2n(u,p);
				n+=u+2;
d1347 3
a1349 1
			else
d1352 1
a1352 2
				if (pkey->type == EVP_PKEY_DSA)
				{
d1354 7
a1360 8
				EVP_SignInit_ex(&md_ctx,EVP_dss1(), NULL);
				EVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(d[DTLS1_HM_HEADER_LENGTH]),n);
				if (!EVP_SignFinal(&md_ctx,&(p[2]),
					(unsigned int *)&i,pkey))
					{
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_DSA);
a1361 3
					}
				s2n(i,p);
				n+=i+2;
d1363 3
a1365 1
			else
d1368 1
a1368 2
				if (pkey->type == EVP_PKEY_EC)
				{
d1370 7
a1376 8
				EVP_SignInit_ex(&md_ctx,EVP_ecdsa(), NULL);
				EVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(d[DTLS1_HM_HEADER_LENGTH]),n);
				if (!EVP_SignFinal(&md_ctx,&(p[2]),
					(unsigned int *)&i,pkey))
					{
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_ECDSA);
a1377 3
					}
				s2n(i,p);
				n+=i+2;
d1379 3
a1381 1
			else
d1383 1
a1383 1
				{
d1385 2
a1386 2
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_PKEY_TYPE);
a1387 1
				}
d1389 1
d1392 1
a1392 1
			SSL3_MT_SERVER_KEY_EXCHANGE, n, 0, n);
d1396 2
a1397 2
		s->init_num=n+DTLS1_HM_HEADER_LENGTH;
		s->init_off=0;
d1401 1
a1401 1
		}
d1405 1
a1405 1
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
d1407 1
a1407 1
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
d1410 2
a1411 1
	if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
d1415 2
a1416 2
	return(-1);
	}
d1418 6
a1423 5
int dtls1_send_certificate_request(SSL *s)
	{
	unsigned char *p,*d;
	int i,j,nl,off,n;
	STACK_OF(X509_NAME) *sk=NULL;
d1428 2
a1429 3
	if (s->state == SSL3_ST_SW_CERT_REQ_A)
		{
		buf=s->init_buf;
d1431 1
a1431 1
		d=p=(unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH]);
d1435 3
a1437 3
		n=ssl3_get_req_cert_type(s,p);
		d[0]=n;
		p+=n;
d1440 12
a1451 15
		off=n;
		p+=2;
		n+=2;

		sk=SSL_get_client_CA_list(s);
		nl=0;
		if (sk != NULL)
			{
			for (i=0; i<sk_X509_NAME_num(sk); i++)
				{
				name=sk_X509_NAME_value(sk,i);
				j=i2d_X509_NAME(name,NULL);
				if (!BUF_MEM_grow_clean(buf,DTLS1_HM_HEADER_LENGTH+n+j+2))
					{
					SSLerr(SSL_F_DTLS1_SEND_CERTIFICATE_REQUEST,ERR_R_BUF_LIB);
d1453 15
a1467 17
					}
				p=(unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH+n]);
				if (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG))
					{
					s2n(j,p);
					i2d_X509_NAME(name,&p);
					n+=2+j;
					nl+=2+j;
					}
				else
					{
					d=p;
					i2d_X509_NAME(name,&p);
					j-=2; s2n(j,d); j+=2;
					n+=j;
					nl+=j;
					}
d1470 1
d1472 2
a1473 2
		p=(unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH+off]);
		s2n(nl,p);
d1475 4
a1478 4
		d=(unsigned char *)buf->data;
		*(d++)=SSL3_MT_CERTIFICATE_REQUEST;
		l2n3(n,d);
		s2n(s->d1->handshake_write_seq,d);
d1484 2
a1485 2
		s->init_num=n+DTLS1_HM_HEADER_LENGTH;
		s->init_off=0;
d1488 1
a1488 1
		p=(unsigned char *)s->init_buf->data + s->init_num;
d1491 4
a1494 4
		*(p++)=SSL3_MT_SERVER_DONE;
		*(p++)=0;
		*(p++)=0;
		*(p++)=0;
d1501 1
a1501 1
			SSL3_MT_CERTIFICATE_REQUEST, msg_len, 0, msg_len);
d1507 1
a1507 1
		}
d1510 1
a1510 1
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
d1512 2
a1513 2
	return(-1);
	}
d1515 3
a1517 2
int dtls1_send_server_certificate(SSL *s)
	{
d1521 3
a1523 5
	if (s->state == SSL3_ST_SW_CERT_A)
		{
		x=ssl_get_server_send_cert(s);
		if (x == NULL)
			{
d1526 3
a1528 5
			    (s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5))
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_CERTIFICATE,ERR_R_INTERNAL_ERROR);
				return(0);
				}
d1530 1
d1532 4
a1535 4
		l=dtls1_output_cert_chain(s,x);
		s->state=SSL3_ST_SW_CERT_B;
		s->init_num=(int)l;
		s->init_off=0;
d1539 1
a1539 1
		}
d1542 2
a1543 2
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
	}
d1546 4
a1549 4
int dtls1_send_newsession_ticket(SSL *s)
	{
	if (s->state == SSL3_ST_SW_SESSION_TICKET_A)
		{
d1574 2
a1575 2
			DTLS1_HM_HEADER_LENGTH + 22 + EVP_MAX_IV_LENGTH +
			EVP_MAX_BLOCK_LENGTH + EVP_MAX_MD_SIZE + slen))
d1583 1
a1583 1
		p=(unsigned char *)&(s->init_buf->data[DTLS1_HM_HEADER_LENGTH]);
d1590 1
a1590 2
		if (tctx->tlsext_ticket_key_cb)
			{
d1592 1
a1592 2
							 &hctx, 1) < 0)
				{
a1594 1
				}
d1596 1
a1596 2
		else
			{
d1599 1
a1599 1
					tctx->tlsext_tick_aes_key, iv);
d1601 1
a1601 1
					tlsext_tick_md(), NULL);
d1603 1
a1603 1
			}
d1630 1
a1630 1
		p=(unsigned char *)&(s->init_buf->data[DTLS1_HM_HEADER_LENGTH]) + 4;
d1634 3
a1636 3
		s->init_num= len;
		s->state=SSL3_ST_SW_SESSION_TICKET_B;
		s->init_off=0;
d1642 1
a1642 1
			SSL3_MT_NEWSESSION_TICKET, msg_len, 0, msg_len);
d1646 1
a1646 1
		}
d1649 2
a1650 2
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
	}
@


1.7
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d161 1
a161 1
	clear_sys_error();
@


1.6
log
@resolve conflicts
@
text
@d279 1
d283 1
a283 1
			s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
d725 7
a731 4
			/* Change to new shared key of SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
d756 1
d758 8
d928 1
a928 1
	unsigned long l,Time;
d934 1
a934 3
		Time=(unsigned long)time(NULL);			/* Time */
		l2n(Time,p);
		RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4);
@


1.6.4.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d600 4
a603 5
				if (s->s3->tmp.cert_request)
					{
					ret=ssl3_get_client_certificate(s);
					if (ret <= 0) goto end;
					}
a971 5
		if (ssl_prepare_serverhello_tlsext(s) <= 0)
			{
			SSLerr(SSL_F_DTLS1_SEND_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);
			return -1;
			}
@


1.6.8.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d600 4
a603 5
				if (s->s3->tmp.cert_request)
					{
					ret=ssl3_get_client_certificate(s);
					if (ret <= 0) goto end;
					}
a971 5
		if (ssl_prepare_serverhello_tlsext(s) <= 0)
			{
			SSLerr(SSL_F_DTLS1_SEND_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);
			return -1;
			}
@


1.5
log
@OpenSSL 1.0.0f: merge
@
text
@d154 4
d175 7
d189 13
d209 1
a209 1
			s->new_session=1;
d254 1
d256 4
a259 1
				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
d344 37
d383 1
a383 1
			s->new_session = 2;
a387 1
#ifndef OPENSSL_NO_TLSEXT
d390 15
a408 1
				}
d410 1
a410 2
			if (s->hit)
					s->state=SSL3_ST_SW_CHANGE_A;
d412 1
d522 7
d538 7
d548 7
d574 7
a593 1
			dtls1_stop_timer(s);
d595 2
d598 1
a603 1
				dtls1_stop_timer(s);
d613 15
a627 1
			dtls1_stop_timer(s);
d664 7
a670 3
			dtls1_stop_timer(s);

			s->state=SSL3_ST_SR_FINISHED_A;
d722 8
d754 1
d756 8
d781 1
a781 1
			if (s->new_session == 2) /* skipped if we just sent a HelloRequest */
d783 1
a783 3
				/* actually not necessarily a 'new' session unless
				 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
				
d835 8
d923 1
a923 1
		RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));
d1298 1
a1298 1
			if ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher))
@


1.4
log
@openssl-1.0.0e: resolve conflicts
@
text
@d1274 1
a1274 1
				EVP_SignUpdate(&md_ctx,&(d[4]),n);
@


1.3
log
@resolve conflicts, fix local changes
@
text
@d153 1
d163 2
d170 2
d281 6
d288 1
a288 1
			if (s->d1->listen && s->state == SSL3_ST_SW_SRVR_HELLO_A)
d292 6
a305 1
			dtls1_start_timer(s);
a754 3

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
d1033 1
a1033 1
			if (!EC_KEY_up_ref(ecdhp))
a1037 1
			ecdh = ecdhp;
@


1.2
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d7 1
a7 1
 * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
d124 1
d129 1
a129 1
static SSL_METHOD *dtls1_get_server_method(int ver);
d132 1
a132 1
static SSL_METHOD *dtls1_get_server_method(int ver)
d148 1
a148 1
	unsigned long l,Time=(unsigned long)time(NULL);
d150 1
a150 1
	long num1;
a239 5
            if ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE))
                s->d1->send_cookie = 1;
            else
                s->d1->send_cookie = 0;

d246 1
d267 1
a267 1
			s->new_session = 2;
d269 1
a269 1
			if ( s->d1->send_cookie)
d275 9
d289 1
a291 1
			s->d1->send_cookie = 0;
d295 2
a296 2
			/* HelloVerifyRequests resets Finished MAC */
			if (s->client_version != DTLS1_BAD_VER)
d302 2
d307 9
d317 2
a318 1
				s->state=SSL3_ST_SW_CHANGE_A;
d326 3
a328 2
			/* Check if it is anon DH */
			if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))
d330 1
d333 12
d348 1
d350 1
d356 1
a356 1
			l=s->s3->tmp.new_cipher->algorithms;
d362 1
a362 1
				&& !(l & SSL_KRB5)
d373 1
a373 1
			/* only send if a DH key exchange, fortezza or
d376 8
a383 2
			    || (l & (SSL_DH|SSL_kFZA))
			    || ((l & SSL_kRSA)
d392 1
d414 1
a414 1
				((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) &&
d418 5
a422 2
                                 /* never request cert in Kerberos ciphersuites */
                                (s->s3->tmp.new_cipher->algorithms & SSL_aKRB5))
d432 1
d447 1
d456 5
a460 8
			/* number of bytes to be flushed */
			num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);
			if (num1 > 0)
				{
				s->rwstate=SSL_WRITING;
				num1=BIO_flush(s->wbio);
				if (num1 <= 0) { ret= -1; goto end; }
				s->rwstate=SSL_NOTHING;
d462 1
a462 1

d472 1
d480 1
d490 1
d494 14
a507 8
			/* We need to get hashes here so if there is
			 * a client cert, it can be verified */ 
			s->method->ssl3_enc->cert_verify_mac(s,
				&(s->s3->finish_dgst1),
				&(s->s3->tmp.cert_verify_md[0]));
			s->method->ssl3_enc->cert_verify_mac(s,
				&(s->s3->finish_dgst2),
				&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
d509 9
d523 1
d527 1
d535 1
d539 1
d542 4
d551 19
d645 1
d716 2
a717 6
		if (s->client_version == DTLS1_BAD_VER)
			*(p++) = DTLS1_BAD_VER>>8,
			*(p++) = DTLS1_BAD_VER&0xff;
		else
			*(p++) = s->version >> 8,
			*(p++) = s->version & 0xFF;
d719 3
a721 3
		if (s->ctx->app_gen_cookie_cb != NULL &&
		    s->ctx->app_gen_cookie_cb(s, s->d1->cookie, 
		    &(s->d1->cookie_len)) == 0)
a725 2
		/* else the cookie is assumed to have 
		 * been initialized by the application */
d766 2
a767 6
		if (s->client_version == DTLS1_BAD_VER)
			*(p++)=DTLS1_BAD_VER>>8,
			*(p++)=DTLS1_BAD_VER&0xff;
		else
			*(p++)=s->version>>8,
			*(p++)=s->version&0xff;
d795 2
d810 8
d873 7
d894 1
a894 1
		type=s->s3->tmp.new_cipher->algorithms & SSL_MKEY_MASK;
d988 136
d1135 2
a1136 1
		if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))
d1167 35
d1255 19
d1300 4
d1417 1
a1417 5
		if (x == NULL &&
                        /* VRS: allow null cert if auth == KRB5 */
                        (s->s3->tmp.new_cipher->algorithms
                                & (SSL_MKEY_MASK|SSL_AUTH_MASK))
                        != (SSL_aKRB5|SSL_kKRB5))
d1419 7
a1425 2
			SSLerr(SSL_F_DTLS1_SEND_SERVER_CERTIFICATE,ERR_R_INTERNAL_ERROR);
			return(0);
d1440 112
@


1.1
log
@Initial revision
@
text
@d735 1
a735 1
		s->state=SSL3_ST_CW_CLNT_HELLO_B;
d744 1
a744 1
	/* SSL3_ST_CW_CLNT_HELLO_B */
d768 1
a768 1
	/* SSL3_ST_CW_CLNT_HELLO_B */
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@d735 1
a735 1
		s->state=SSL3_ST_SW_SRVR_HELLO_B;
d744 1
a744 1
	/* SSL3_ST_SW_SRVR_HELLO_B */
d768 1
a768 1
	/* SSL3_ST_SW_SRVR_DONE_B */
@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@d7 1
a7 1
 * Copyright (c) 1999-2007 The OpenSSL Project.  All rights reserved.
a123 1
#include <openssl/bn.h>
d128 1
a128 1
static const SSL_METHOD *dtls1_get_server_method(int ver);
d131 1
a131 1
static const SSL_METHOD *dtls1_get_server_method(int ver)
d147 1
a147 1
	unsigned long Time=(unsigned long)time(NULL);
d149 1
a149 1
	unsigned long alg_k;
d239 5
a249 1
			dtls1_start_timer(s);
d270 1
a270 1
			dtls1_stop_timer(s);
d272 1
a272 1
			if (ret == 1 && (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE))
a277 9

			/* If we're just listening, stop here */
			if (s->d1->listen && s->state == SSL3_ST_SW_SRVR_HELLO_A)
				{
				ret = 2;
				s->d1->listen = 0;
				goto end;
				}
			
a282 1
			dtls1_start_timer(s);
d285 1
d289 2
a290 2
			/* HelloVerifyRequest resets Finished MAC */
			if (s->version != DTLS1_BAD_VER)
a295 2
			s->new_session = 2;
			dtls1_start_timer(s);
a298 1
#ifndef OPENSSL_NO_TLSEXT
d300 1
a300 10
				{
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
				}
#else
			if (s->hit)
					s->state=SSL3_ST_SW_CHANGE_A;
#endif
d308 2
a309 3
			/* Check if it is anon DH or normal PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
a310 1
				dtls1_start_timer(s);
a312 12
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
a315 1

a316 1
#endif
d322 1
a322 1
			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
d328 1
a328 1
				&& !(alg_k & SSL_kKRB5)
d339 1
a339 1
			/* only send if a DH key exchange or
d342 2
a343 8
			/* PSK: send ServerKeyExchange if PSK identity
			 * hint if provided */
#ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
			    || (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
			    || (alg_k & SSL_kEECDH)
			    || ((alg_k & SSL_kRSA)
a351 1
				dtls1_start_timer(s);
d373 1
a373 1
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
d377 2
a378 5
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
a387 1
				dtls1_start_timer(s);
a401 1
			dtls1_start_timer(s);
d410 8
a417 5
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
d419 1
a419 1
			s->rwstate=SSL_NOTHING;
a428 1
			dtls1_stop_timer(s);
a435 1
				dtls1_stop_timer(s);
a444 1
			dtls1_stop_timer(s);
d448 8
a455 14
			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 */
				s->state=SSL3_ST_SR_FINISHED_A;
				s->init_num = 0;
				}
			else
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
a456 9
				/* We need to get hashes here so if there is
				 * a client cert, it can be verified */ 
				s->method->ssl3_enc->cert_verify_mac(s,
					NID_md5,
					&(s->s3->tmp.cert_verify_md[0]));
				s->method->ssl3_enc->cert_verify_mac(s,
					NID_sha1,
					&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
				}
a461 1
			s->d1->change_cipher_spec_ok = 1;
a464 1
			dtls1_stop_timer(s);
a471 1
			s->d1->change_cipher_spec_ok = 1;
a474 1
			dtls1_stop_timer(s);
a476 4
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
a481 19
#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=dtls1_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

a556 1
			s->d1->next_handshake_write_seq = 0;
d627 6
a632 2
		*(p++) = s->version >> 8;
		*(p++) = s->version & 0xFF;
d634 3
a636 3
		if (s->ctx->app_gen_cookie_cb == NULL ||
		     s->ctx->app_gen_cookie_cb(s, s->d1->cookie,
			 &(s->d1->cookie_len)) == 0)
d641 2
d683 6
a688 2
		*(p++)=s->version>>8;
		*(p++)=s->version&0xff;
a715 2
		if (s->s3->tmp.new_cipher == NULL)
			return -1;
a728 8
#ifndef OPENSSL_NO_TLSEXT
		if ((p = ssl_add_serverhello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
			{
			SSLerr(SSL_F_DTLS1_SEND_SERVER_HELLO,ERR_R_INTERNAL_ERROR);
			return -1;
			}
#endif

a783 7
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh=NULL, *ecdhp;
	unsigned char *encodedPoint = NULL;
	int encodedlen = 0;
	int curve_id = 0;
	BN_CTX *bn_ctx = NULL; 
#endif
d798 1
a798 1
		type=s->s3->tmp.new_cipher->algorithm_mkey;
a891 136
#ifndef OPENSSL_NO_ECDH
			if (type & SSL_kEECDH)
			{
			const EC_GROUP *group;

			ecdhp=cert->ecdh_tmp;
			if ((ecdhp == NULL) && (s->cert->ecdh_tmp_cb != NULL))
				{
				ecdhp=s->cert->ecdh_tmp_cb(s,
				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
				}
			if (ecdhp == NULL)
				{
				al=SSL_AD_HANDSHAKE_FAILURE;
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);
				goto f_err;
				}

			if (s->s3->tmp.ecdh != NULL)
				{
				EC_KEY_free(s->s3->tmp.ecdh); 
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
				goto err;
				}

			/* Duplicate the ECDH structure. */
			if (ecdhp == NULL)
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				goto err;
				}
			if (!EC_KEY_up_ref(ecdhp))
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				goto err;
				}
			ecdh = ecdhp;

			s->s3->tmp.ecdh=ecdh;
			if ((EC_KEY_get0_public_key(ecdh) == NULL) ||
			    (EC_KEY_get0_private_key(ecdh) == NULL) ||
			    (s->options & SSL_OP_SINGLE_ECDH_USE))
				{
				if(!EC_KEY_generate_key(ecdh))
				    {
				    SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				    goto err;
				    }
				}

			if (((group = EC_KEY_get0_group(ecdh)) == NULL) ||
			    (EC_KEY_get0_public_key(ecdh)  == NULL) ||
			    (EC_KEY_get0_private_key(ecdh) == NULL))
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				goto err;
				}

			if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
			    (EC_GROUP_get_degree(group) > 163)) 
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
				goto err;
				}

			/* XXX: For now, we only support ephemeral ECDH
			 * keys over named (not generic) curves. For 
			 * supported named curves, curve_id is non-zero.
			 */
			if ((curve_id = 
			    tls1_ec_nid2curve_id(EC_GROUP_get_curve_name(group)))
			    == 0)
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);
				goto err;
				}

			/* Encode the public key.
			 * First check the size of encoding and
			 * allocate memory accordingly.
			 */
			encodedlen = EC_POINT_point2oct(group, 
			    EC_KEY_get0_public_key(ecdh),
			    POINT_CONVERSION_UNCOMPRESSED, 
			    NULL, 0, NULL);

			encodedPoint = (unsigned char *) 
			    OPENSSL_malloc(encodedlen*sizeof(unsigned char)); 
			bn_ctx = BN_CTX_new();
			if ((encodedPoint == NULL) || (bn_ctx == NULL))
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
				goto err;
				}


			encodedlen = EC_POINT_point2oct(group, 
			    EC_KEY_get0_public_key(ecdh), 
			    POINT_CONVERSION_UNCOMPRESSED, 
			    encodedPoint, encodedlen, bn_ctx);

			if (encodedlen == 0) 
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
				goto err;
				}

			BN_CTX_free(bn_ctx);  bn_ctx=NULL;

			/* XXX: For now, we only support named (not 
			 * generic) curves in ECDH ephemeral key exchanges.
			 * In this situation, we need four additional bytes
			 * to encode the entire ServerECDHParams
			 * structure. 
			 */
			n = 4 + encodedlen;

			/* We'll generate the serverKeyExchange message
			 * explicitly so we can set these to NULLs
			 */
			r[0]=NULL;
			r[1]=NULL;
			r[2]=NULL;
			r[3]=NULL;
			}
		else 
#endif /* !OPENSSL_NO_ECDH */
#ifndef OPENSSL_NO_PSK
			if (type & SSL_kPSK)
				{
				/* reserve size for record length and PSK identity hint*/
				n+=2+strlen(s->ctx->psk_identity_hint);
				}
			else
#endif /* !OPENSSL_NO_PSK */
d903 1
a903 2
		if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
			&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
a933 35
#ifndef OPENSSL_NO_ECDH
		if (type & SSL_kEECDH) 
			{
			/* XXX: For now, we only support named (not generic) curves.
			 * In this situation, the serverKeyExchange message has:
			 * [1 byte CurveType], [2 byte CurveName]
			 * [1 byte length of encoded point], followed by
			 * the actual encoded point itself
			 */
			*p = NAMED_CURVE_TYPE;
			p += 1;
			*p = 0;
			p += 1;
			*p = curve_id;
			p += 1;
			*p = encodedlen;
			p += 1;
			memcpy((unsigned char*)p, 
			    (unsigned char *)encodedPoint, 
			    encodedlen);
			OPENSSL_free(encodedPoint);
			p += encodedlen;
			}
#endif

#ifndef OPENSSL_NO_PSK
		if (type & SSL_kPSK)
			{
			/* copy PSK identity hint */
			s2n(strlen(s->ctx->psk_identity_hint), p); 
			strncpy((char *)p, s->ctx->psk_identity_hint, strlen(s->ctx->psk_identity_hint));
			p+=strlen(s->ctx->psk_identity_hint);
			}
#endif

a986 19
#if !defined(OPENSSL_NO_ECDSA)
				if (pkey->type == EVP_PKEY_EC)
				{
				/* let's do ECDSA */
				EVP_SignInit_ex(&md_ctx,EVP_ecdsa(), NULL);
				EVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_SignUpdate(&md_ctx,&(d[4]),n);
				if (!EVP_SignFinal(&md_ctx,&(p[2]),
					(unsigned int *)&i,pkey))
					{
					SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_ECDSA);
					goto err;
					}
				s2n(i,p);
				n+=i+2;
				}
			else
#endif
a1012 4
#ifndef OPENSSL_NO_ECDH
	if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
	BN_CTX_free(bn_ctx);
#endif
d1126 5
a1130 1
		if (x == NULL)
d1132 2
a1133 7
			/* VRS: allow null cert if auth == KRB5 */
			if ((s->s3->tmp.new_cipher->algorithm_mkey != SSL_kKRB5) ||
			    (s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5))
				{
				SSLerr(SSL_F_DTLS1_SEND_SERVER_CERTIFICATE,ERR_R_INTERNAL_ERROR);
				return(0);
				}
a1147 112

#ifndef OPENSSL_NO_TLSEXT
int dtls1_send_newsession_ticket(SSL *s)
	{
	if (s->state == SSL3_ST_SW_SESSION_TICKET_A)
		{
		unsigned char *p, *senc, *macstart;
		int len, slen;
		unsigned int hlen, msg_len;
		EVP_CIPHER_CTX ctx;
		HMAC_CTX hctx;
		SSL_CTX *tctx = s->initial_ctx;
		unsigned char iv[EVP_MAX_IV_LENGTH];
		unsigned char key_name[16];

		/* get session encoding length */
		slen = i2d_SSL_SESSION(s->session, NULL);
		/* Some length values are 16 bits, so forget it if session is
 		 * too long
 		 */
		if (slen > 0xFF00)
			return -1;
		/* Grow buffer if need be: the length calculation is as
 		 * follows 12 (DTLS handshake message header) +
 		 * 4 (ticket lifetime hint) + 2 (ticket length) +
 		 * 16 (key name) + max_iv_len (iv length) +
 		 * session_length + max_enc_block_size (max encrypted session
 		 * length) + max_md_size (HMAC).
 		 */
		if (!BUF_MEM_grow(s->init_buf,
			DTLS1_HM_HEADER_LENGTH + 22 + EVP_MAX_IV_LENGTH +
			EVP_MAX_BLOCK_LENGTH + EVP_MAX_MD_SIZE + slen))
			return -1;
		senc = OPENSSL_malloc(slen);
		if (!senc)
			return -1;
		p = senc;
		i2d_SSL_SESSION(s->session, &p);

		p=(unsigned char *)&(s->init_buf->data[DTLS1_HM_HEADER_LENGTH]);
		EVP_CIPHER_CTX_init(&ctx);
		HMAC_CTX_init(&hctx);
		/* Initialize HMAC and cipher contexts. If callback present
		 * it does all the work otherwise use generated values
		 * from parent ctx.
		 */
		if (tctx->tlsext_ticket_key_cb)
			{
			if (tctx->tlsext_ticket_key_cb(s, key_name, iv, &ctx,
							 &hctx, 1) < 0)
				{
				OPENSSL_free(senc);
				return -1;
				}
			}
		else
			{
			RAND_pseudo_bytes(iv, 16);
			EVP_EncryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,
					tctx->tlsext_tick_aes_key, iv);
			HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
					tlsext_tick_md(), NULL);
			memcpy(key_name, tctx->tlsext_tick_key_name, 16);
			}
		l2n(s->session->tlsext_tick_lifetime_hint, p);
		/* Skip ticket length for now */
		p += 2;
		/* Output key name */
		macstart = p;
		memcpy(p, key_name, 16);
		p += 16;
		/* output IV */
		memcpy(p, iv, EVP_CIPHER_CTX_iv_length(&ctx));
		p += EVP_CIPHER_CTX_iv_length(&ctx);
		/* Encrypt session data */
		EVP_EncryptUpdate(&ctx, p, &len, senc, slen);
		p += len;
		EVP_EncryptFinal(&ctx, p, &len);
		p += len;
		EVP_CIPHER_CTX_cleanup(&ctx);

		HMAC_Update(&hctx, macstart, p - macstart);
		HMAC_Final(&hctx, p, &hlen);
		HMAC_CTX_cleanup(&hctx);

		p += hlen;
		/* Now write out lengths: p points to end of data written */
		/* Total length */
		len = p - (unsigned char *)(s->init_buf->data);
		/* Ticket length */
		p=(unsigned char *)&(s->init_buf->data[DTLS1_HM_HEADER_LENGTH]) + 4;
		s2n(len - DTLS1_HM_HEADER_LENGTH - 6, p);

		/* number of bytes to write */
		s->init_num= len;
		s->state=SSL3_ST_SW_SESSION_TICKET_B;
		s->init_off=0;
		OPENSSL_free(senc);

		/* XDTLS:  set message header ? */
		msg_len = s->init_num - DTLS1_HM_HEADER_LENGTH;
		dtls1_set_message_header(s, (void *)s->init_buf->data,
			SSL3_MT_NEWSESSION_TICKET, msg_len, 0, msg_len);

		/* buffer the message to handle re-xmits */
		dtls1_buffer_message(s, 0);
		}

	/* SSL3_ST_SW_SESSION_TICKET_B */
	return(dtls1_do_write(s,SSL3_RT_HANDSHAKE));
	}
#endif
@


1.1.1.4
log
@import OpenSSL 1.0.0e
@
text
@a152 1
	int listen;
a161 2
	
	listen = s->d1->listen;
a166 2
	s->d1->listen = listen;

a275 6
			/* Reflect ClientHello sequence to remain stateless while listening */
			if (listen)
				{
				memcpy(s->s3->write_sequence, s->s3->read_sequence, sizeof(s->s3->write_sequence));
				}

d277 1
a277 1
			if (listen && s->state == SSL3_ST_SW_SRVR_HELLO_A)
a280 6
				/* Set expected sequence numbers
				 * to continue the handshake.
				 */
				s->d1->handshake_read_seq = 2;
				s->d1->handshake_write_seq = 1;
				s->d1->next_handshake_write_seq = 1;
d289 1
d739 3
d1020 1
a1020 1
			if ((ecdh = EC_KEY_dup(ecdhp)) == NULL)
d1025 1
@


1.1.1.5
log
@OpenSSL 1.0.0f: import upstream source
@
text
@d1274 1
a1274 1
				EVP_SignUpdate(&md_ctx,&(d[DTLS1_HM_HEADER_LENGTH]),n);
@


1.1.1.6
log
@import OpenSSL-1.0.1c
@
text
@a153 4
#ifndef OPENSSL_NO_SCTP
	unsigned char sctpauthkey[64];
	char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];
#endif
a170 7
#ifndef OPENSSL_NO_SCTP
	/* Notify SCTP BIO socket to enter handshake
	 * mode and prevent stream identifier other
	 * than 0. Will be ignored if no SCTP is used.
	 */
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
#endif
a177 13
#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		dtls1_stop_timer(s);
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

d185 1
a185 1
			s->renegotiate=1;
a229 1
				 * ...but not with SCTP :-)
d231 1
a231 4
#ifndef OPENSSL_NO_SCTP
				if (!BIO_dgram_is_sctp(SSL_get_wbio(s)))
#endif
					if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
a315 37
#ifndef OPENSSL_NO_SCTP
		case DTLS1_SCTP_ST_SR_READ_SOCK:
			
			if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))		
				{
				s->s3->in_read_app_data=2;
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				ret = -1;
				goto end;
				}
			
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
			
		case DTLS1_SCTP_ST_SW_WRITE_SOCK:
			ret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));
			if (ret < 0) goto end;
			
			if (ret == 0)
				{
				if (s->d1->next_state != SSL_ST_OK)
					{
					s->s3->in_read_app_data=2;
					s->rwstate=SSL_READING;
					BIO_clear_retry_flags(SSL_get_rbio(s));
					BIO_set_retry_read(SSL_get_rbio(s));
					ret = -1;
					goto end;
					}
				}

			s->state=s->d1->next_state;
			break;
#endif

d318 1
a318 1
			s->renegotiate = 2;
d323 1
a325 15
#ifndef OPENSSL_NO_SCTP
				/* Add new shared key for SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				snprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
				         DTLS1_SCTP_AUTH_LABEL);

				SSL_export_keying_material(s, sctpauthkey,
				                           sizeof(sctpauthkey), labelbuffer,
				                           sizeof(labelbuffer), NULL, 0, 0);
				
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
                         sizeof(sctpauthkey), sctpauthkey);
#endif
#ifndef OPENSSL_NO_TLSEXT
d330 1
d332 2
a333 1
				s->state=SSL3_ST_SW_CHANGE_A;
a334 1
				}
a443 7
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;
					s->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
a452 7
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;
					s->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
a455 7
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
a474 7
				/* If the write error was fatal, stop trying */
				if (!BIO_should_retry(s->wbio))
					{
					s->rwstate=SSL_NOTHING;
					s->state=s->s3->tmp.next_state;
					}
				
d488 1
a489 2
				{
				dtls1_stop_timer(s);
a490 1
				}
d496 1
d506 1
a506 15
#ifndef OPENSSL_NO_SCTP
			/* Add new shared key for SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			snprintf((char *) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
			         DTLS1_SCTP_AUTH_LABEL);

			SSL_export_keying_material(s, sctpauthkey,
			                           sizeof(sctpauthkey), labelbuffer,
			                           sizeof(labelbuffer), NULL, 0, 0);

			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
			         sizeof(sctpauthkey), sctpauthkey);
#endif

d543 3
a545 7
#ifndef OPENSSL_NO_SCTP
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
			    state == SSL_ST_RENEGOTIATE)
				s->state=DTLS1_SCTP_ST_SR_READ_SOCK;
			else
#endif			
				s->state=SSL3_ST_SR_FINISHED_A;
a596 8

#ifndef OPENSSL_NO_SCTP
			/* Change to new shared key of SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
#endif

a620 1
				{
a621 8
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
				}
d639 1
a639 1
			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
d641 3
a643 1
				s->renegotiate=0;
a694 8
#ifndef OPENSSL_NO_SCTP
		/* Notify SCTP BIO socket to leave handshake
		 * mode and prevent stream identifier other
		 * than 0. Will be ignored if no SCTP is used.
		 */
		BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
#endif

d775 1
a775 1
		RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4);
d1150 1
a1150 1
			if ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher, NULL))
@


1.1.1.7
log
@Import OpenSSL 1.0.1g
@
text
@a278 1
			dtls1_clear_record_buffer(s);
d282 1
a282 1
			s->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;
d724 4
a727 7
			if (!s->hit)
				{
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
				}
a751 1
				{
a752 8

#ifndef OPENSSL_NO_SCTP
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
#endif
				}
d915 1
a915 1
	unsigned long l;
d921 3
a923 1
		ssl_fill_hello_random(s, 1, p, SSL3_RANDOM_SIZE);
@


