head	1.170;
access;
symbols
	OPENBSD_6_2_BASE:1.170
	OPENBSD_6_1:1.158.0.4
	OPENBSD_6_1_BASE:1.158;
locks; strict;
comment	@ * @;


1.170
date	2017.08.30.16.24.21;	author jsing;	state Exp;
branches;
next	1.169;
commitid	bb5uAl96fNTkBlaY;

1.169
date	2017.08.28.17.36.58;	author jsing;	state Exp;
branches;
next	1.168;
commitid	8Sp0KD8xWCnY2mOk;

1.168
date	2017.08.13.17.04.36;	author doug;	state Exp;
branches;
next	1.167;
commitid	bIEgs56gwFZMJD50;

1.167
date	2017.08.12.21.03.08;	author jsing;	state Exp;
branches;
next	1.166;
commitid	n6G9zNMtfIAJ9B9u;

1.166
date	2017.08.12.02.55.22;	author jsing;	state Exp;
branches;
next	1.165;
commitid	75ze73v4QudzrM8f;

1.165
date	2017.08.11.21.06.52;	author jsing;	state Exp;
branches;
next	1.164;
commitid	ew1edhq7pOmoKBpJ;

1.164
date	2017.08.11.21.06.17;	author jsing;	state Exp;
branches;
next	1.163;
commitid	uGm5hon0xXQYltel;

1.163
date	2017.08.10.17.18.38;	author jsing;	state Exp;
branches;
next	1.162;
commitid	dKulPy2Ty6efAQYX;

1.162
date	2017.08.09.22.24.25;	author jsing;	state Exp;
branches;
next	1.161;
commitid	3OyBuKgMOSBVJcjR;

1.161
date	2017.05.07.04.22.24;	author beck;	state Exp;
branches;
next	1.160;
commitid	lvbt7GJEb5w5u0NS;

1.160
date	2017.05.06.22.24.57;	author beck;	state Exp;
branches;
next	1.159;
commitid	caPZfWYl80TRorLe;

1.159
date	2017.05.06.20.37.25;	author jsing;	state Exp;
branches;
next	1.158;
commitid	TYalkspbBA5xUOBz;

1.158
date	2017.02.28.14.08.49;	author jsing;	state Exp;
branches;
next	1.157;
commitid	4oDOXgdSwn6wlYCL;

1.157
date	2017.02.15.14.56.42;	author jsing;	state Exp;
branches;
next	1.156;
commitid	mdASrgwo7arj2r2Z;

1.156
date	2017.02.07.02.08.38;	author beck;	state Exp;
branches;
next	1.155;
commitid	xH3OeartUDKSlAnB;

1.155
date	2017.01.26.12.16.13;	author beck;	state Exp;
branches;
next	1.154;
commitid	lb4UTPLS9Casn2PL;

1.154
date	2017.01.26.10.40.21;	author beck;	state Exp;
branches;
next	1.153;
commitid	Bi1VygMenL4YtCp7;

1.153
date	2017.01.26.06.32.58;	author jsing;	state Exp;
branches;
next	1.152;
commitid	TbFBd2VdEVckCCsd;

1.152
date	2017.01.26.06.01.44;	author jsing;	state Exp;
branches;
next	1.151;
commitid	8wsXMIqjV5DtyRam;

1.151
date	2017.01.26.00.42.44;	author jsing;	state Exp;
branches;
next	1.150;
commitid	Abyg6hUnK4VyzfBQ;

1.150
date	2017.01.25.10.54.23;	author jsing;	state Exp;
branches;
next	1.149;
commitid	aCcgLh3rT7Wju1Vr;

1.149
date	2017.01.24.15.11.55;	author jsing;	state Exp;
branches;
next	1.148;
commitid	cNCr5Irid71GSRyy;

1.148
date	2017.01.24.15.04.12;	author jsing;	state Exp;
branches;
next	1.147;
commitid	aMjlYSO7tAuwLGon;

1.147
date	2017.01.24.14.57.31;	author jsing;	state Exp;
branches;
next	1.146;
commitid	nQzaI20w3vrSZN0L;

1.146
date	2017.01.24.13.34.26;	author jsing;	state Exp;
branches;
next	1.145;
commitid	ph9D1e6j0HkwlpPg;

1.145
date	2017.01.24.09.03.21;	author jsing;	state Exp;
branches;
next	1.144;
commitid	NTZJ3rEptTLCIZDB;

1.144
date	2017.01.24.01.47.22;	author jsing;	state Exp;
branches;
next	1.143;
commitid	kugp4fWfTcYQGA4s;

1.143
date	2017.01.24.01.46.12;	author jsing;	state Exp;
branches;
next	1.142;
commitid	zUBeb6dCj5fvm3W4;

1.142
date	2017.01.24.01.44.00;	author jsing;	state Exp;
branches;
next	1.141;
commitid	O8CUaU9Fg23fiAtj;

1.141
date	2017.01.23.22.34.38;	author beck;	state Exp;
branches;
next	1.140;
commitid	LjSyQ9gcPyeZpDNB;

1.140
date	2017.01.23.14.35.42;	author jsing;	state Exp;
branches;
next	1.139;
commitid	fvePj4ki9zOwq3SB;

1.139
date	2017.01.23.13.36.13;	author jsing;	state Exp;
branches;
next	1.138;
commitid	xYJ523Ay020rUB5W;

1.138
date	2017.01.23.10.22.06;	author jsing;	state Exp;
branches;
next	1.137;
commitid	sfluQzS4C53eT1pq;

1.137
date	2017.01.23.08.48.44;	author beck;	state Exp;
branches;
next	1.136;
commitid	vAKES6VByBpegTl4;

1.136
date	2017.01.23.08.08.06;	author beck;	state Exp;
branches;
next	1.135;
commitid	INyvrQFO5zrO2vlL;

1.135
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.134;
commitid	grTXB43OAHDwwKOU;

1.134
date	2017.01.23.05.13.02;	author jsing;	state Exp;
branches;
next	1.133;
commitid	XWcFqNClp2MoKERU;

1.133
date	2017.01.23.04.55.27;	author beck;	state Exp;
branches;
next	1.132;
commitid	AhwkqHI5lKK3NR31;

1.132
date	2017.01.23.04.15.28;	author jsing;	state Exp;
branches;
next	1.131;
commitid	j20UnjrPw7WvzMvm;

1.131
date	2017.01.23.01.22.08;	author jsing;	state Exp;
branches;
next	1.130;
commitid	YymiVWgtX4KkSfL3;

1.130
date	2017.01.23.00.12.54;	author jsing;	state Exp;
branches;
next	1.129;
commitid	Ry6OEk67lc2U2xi9;

1.129
date	2017.01.22.09.02.07;	author jsing;	state Exp;
branches;
next	1.128;
commitid	570ElYZpaAvthwZh;

1.128
date	2017.01.22.07.16.39;	author beck;	state Exp;
branches;
next	1.127;
commitid	qajmn1SU3Rm3vz6g;

1.127
date	2017.01.22.06.36.49;	author jsing;	state Exp;
branches;
next	1.126;
commitid	jkexAOoo4I6xT9SH;

1.126
date	2017.01.22.03.50.45;	author jsing;	state Exp;
branches;
next	1.125;
commitid	Q5mGTZ7ZJXh4fPDx;

1.125
date	2017.01.21.04.16.49;	author jsing;	state Exp;
branches;
next	1.124;
commitid	7bOyohAWtCbcCf2O;

1.124
date	2017.01.03.16.57.15;	author jsing;	state Exp;
branches;
next	1.123;
commitid	Y2i9OYGcVG7mIq9R;

1.123
date	2016.12.30.16.57.01;	author jsing;	state Exp;
branches;
next	1.122;
commitid	W0S1uBsnMfMqkUUv;

1.122
date	2016.12.04.14.32.30;	author jsing;	state Exp;
branches;
next	1.121;
commitid	5bdQ9DStxZhVq2ym;

1.121
date	2016.11.02.11.21.05;	author jsing;	state Exp;
branches;
next	1.120;
commitid	g1bgCX1m3pnzIBLj;

1.120
date	2016.11.02.10.45.02;	author jsing;	state Exp;
branches;
next	1.119;
commitid	YW7yjuCAfXQi7LBT;

1.119
date	2016.10.19.16.38.40;	author jsing;	state Exp;
branches;
next	1.118;
commitid	zBSqJxdzZYua3a3I;

1.118
date	2016.09.22.12.34.59;	author jsing;	state Exp;
branches;
next	1.117;
commitid	oxeEsiakeV1XPVXd;

1.117
date	2016.09.20.04.25.09;	author bcook;	state Exp;
branches;
next	1.116;
commitid	HKgoRgTDuYZYd4hh;

1.116
date	2015.10.25.15.52.49;	author doug;	state Exp;
branches;
next	1.115;
commitid	PFU1AgTLzdwceKyd;

1.115
date	2015.10.19.17.59.39;	author beck;	state Exp;
branches;
next	1.114;
commitid	KUJ9Z7XVRL7suhDf;

1.114
date	2015.10.16.14.23.22;	author beck;	state Exp;
branches;
next	1.113;
commitid	oNyRP5xXKYR4Y1Kq;

1.113
date	2015.10.03.06.47.32;	author doug;	state Exp;
branches;
next	1.112;
commitid	ay0tn5IyCnIh1Xhf;

1.112
date	2015.09.12.19.45.16;	author jsing;	state Exp;
branches;
next	1.111;
commitid	0EDj2UqXNzW1SSN4;

1.111
date	2015.09.12.16.10.07;	author doug;	state Exp;
branches;
next	1.110;
commitid	VR022UcxWVmcgSOF;

1.110
date	2015.09.11.17.35.36;	author jsing;	state Exp;
branches;
next	1.109;
commitid	7HJmWOoZGIjCFd3s;

1.109
date	2015.09.11.17.29.36;	author jsing;	state Exp;
branches;
next	1.108;
commitid	VCGEXb1kmMpuyChI;

1.108
date	2015.09.10.17.57.50;	author jsing;	state Exp;
branches;
next	1.107;
commitid	T35skZJCouRaXVVY;

1.107
date	2015.09.09.19.42.39;	author jsing;	state Exp;
branches;
next	1.106;
commitid	iXRpgxTD8dVKz5sD;

1.106
date	2015.08.27.06.21.15;	author doug;	state Exp;
branches;
next	1.105;
commitid	81GzeBdk0eOTcvRE;

1.105
date	2015.07.19.20.32.18;	author doug;	state Exp;
branches;
next	1.104;
commitid	JJGxWtixsF6e0H2B;

1.104
date	2015.06.28.00.08.27;	author doug;	state Exp;
branches;
next	1.103;
commitid	JVzmospDlYt9nhzg;

1.103
date	2015.04.15.16.25.43;	author jsing;	state Exp;
branches;
next	1.102;
commitid	pvAlLTVkoLxmS3rG;

1.102
date	2015.03.27.12.26.41;	author jsing;	state Exp;
branches;
next	1.101;
commitid	hjfMSri3a8NBg8HA;

1.101
date	2015.02.22.15.54.27;	author jsing;	state Exp;
branches;
next	1.100;
commitid	9t8bOP5HFWMq1Big;

1.100
date	2015.02.22.15.29.39;	author jsing;	state Exp;
branches;
next	1.99;
commitid	D6E7dW17NGlJfY49;

1.99
date	2015.02.22.15.19.56;	author jsing;	state Exp;
branches;
next	1.98;
commitid	GMcTlSgvcpkYdpb1;

1.98
date	2015.02.11.03.19.37;	author doug;	state Exp;
branches;
next	1.97;
commitid	5KSZBoxiLebzObKt;

1.97
date	2015.02.09.07.17.55;	author doug;	state Exp;
branches;
next	1.96;
commitid	sxXpN4az6qYTsNYW;

1.96
date	2015.02.07.05.46.01;	author jsing;	state Exp;
branches;
next	1.95;
commitid	kZmiX4Lm74epWPnx;

1.95
date	2015.01.22.09.12.57;	author reyk;	state Exp;
branches;
next	1.94;
commitid	aaSKbEKrSo5DOatY;

1.94
date	2014.12.15.00.46.53;	author doug;	state Exp;
branches;
next	1.93;
commitid	I2ue40Sqz1Sg9KmB;

1.93
date	2014.12.14.14.34.43;	author jsing;	state Exp;
branches;
next	1.92;
commitid	JlmRntBjnvBE29Fz;

1.92
date	2014.12.10.15.36.47;	author jsing;	state Exp;
branches;
next	1.91;
commitid	x50cturILyXAfPoH;

1.91
date	2014.12.10.14.58.56;	author jsing;	state Exp;
branches;
next	1.90;
commitid	GHVxpbbDPbCM2xPo;

1.90
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.89;
commitid	M3pvHgIFoWUHNqJn;

1.89
date	2014.10.31.15.25.55;	author jsing;	state Exp;
branches;
next	1.88;
commitid	NOaAgwTtK29a9Ncs;

1.88
date	2014.10.31.14.51.01;	author jsing;	state Exp;
branches;
next	1.87;
commitid	cMCIoWtrOiPFZWnD;

1.87
date	2014.10.18.16.13.16;	author jsing;	state Exp;
branches;
next	1.86;
commitid	cGE1JG2i0h4NcVDi;

1.86
date	2014.10.15.17.39.34;	author jsing;	state Exp;
branches;
next	1.85;
commitid	Ec7tjZraHyrXyO0X;

1.85
date	2014.10.03.13.58.18;	author jsing;	state Exp;
branches;
next	1.84;
commitid	TTuHOVoRSWSvd6HI;

1.84
date	2014.09.07.12.16.23;	author jsing;	state Exp;
branches;
next	1.83;
commitid	oAt7EW2Y0Fwu0XNB;

1.83
date	2014.08.24.14.36.45;	author jsing;	state Exp;
branches;
next	1.82;
commitid	1vOBE9WdltEkCa6G;

1.82
date	2014.08.23.14.52.41;	author jsing;	state Exp;
branches;
next	1.81;
commitid	hTkCFMErB7xMsqus;

1.81
date	2014.08.11.10.46.19;	author jsing;	state Exp;
branches;
next	1.80;
commitid	qZhw4DZ9er1oPFGb;

1.80
date	2014.08.11.01.10.42;	author jsing;	state Exp;
branches;
next	1.79;
commitid	56Y8ICSiJFJMZq95;

1.79
date	2014.08.10.14.42.56;	author jsing;	state Exp;
branches;
next	1.78;
commitid	wihJupNvfkdpKL9O;

1.78
date	2014.07.12.22.33.39;	author jsing;	state Exp;
branches
	1.78.4.1;
next	1.77;
commitid	JT7oO4AHgBkjVLfZ;

1.77
date	2014.07.12.19.45.53;	author jsing;	state Exp;
branches;
next	1.76;
commitid	foFDfYAdqxlf9LD4;

1.76
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.75;
commitid	G74O1dmRukKsW7IJ;

1.75
date	2014.07.12.13.11.53;	author jsing;	state Exp;
branches;
next	1.74;
commitid	tJhRneQ4w1l9LuV2;

1.74
date	2014.07.11.09.24.44;	author beck;	state Exp;
branches;
next	1.73;
commitid	cCGiAdDteN08GytD;

1.73
date	2014.07.10.11.58.08;	author jsing;	state Exp;
branches;
next	1.72;
commitid	qLodpwcyFbEuMoav;

1.72
date	2014.07.10.08.51.15;	author tedu;	state Exp;
branches;
next	1.71;
commitid	lsH7iukeZYSZBx6F;

1.71
date	2014.07.10.08.18.55;	author bcook;	state Exp;
branches;
next	1.70;
commitid	66EK5YMIkt2EbIoa;

1.70
date	2014.07.09.11.25.42;	author jsing;	state Exp;
branches;
next	1.69;
commitid	N5P2FUkVkAd7ODs9;

1.69
date	2014.06.19.21.29.51;	author tedu;	state Exp;
branches;
next	1.68;
commitid	CIpPjhmVWPbqgxVA;

1.68
date	2014.06.17.01.41.01;	author tedu;	state Exp;
branches;
next	1.67;
commitid	jVyjlW0dG3XDpLSF;

1.67
date	2014.06.13.10.52.24;	author jsing;	state Exp;
branches;
next	1.66;
commitid	NX4qoGRCqaBXEm1B;

1.66
date	2014.06.13.04.29.13;	author miod;	state Exp;
branches;
next	1.65;
commitid	8Qu6YceLSxhOi4yG;

1.65
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	mJUVYpkFBZ0Zv2bG;

1.64
date	2014.06.07.14.03.50;	author jsing;	state Exp;
branches;
next	1.63;
commitid	e0RfLzY73RIGUult;

1.63
date	2014.05.31.16.45.53;	author jsing;	state Exp;
branches;
next	1.62;
commitid	K5BZXxlGuxIiYVKu;

1.62
date	2014.05.31.13.55.45;	author jsing;	state Exp;
branches;
next	1.61;

1.61
date	2014.05.31.10.58.50;	author jsing;	state Exp;
branches;
next	1.60;

1.60
date	2014.05.31.10.53.39;	author jsing;	state Exp;
branches;
next	1.59;

1.59
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.58;

1.58
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2014.05.30.14.01.11;	author jsing;	state Exp;
branches;
next	1.56;

1.56
date	2014.05.29.18.27.52;	author beck;	state Exp;
branches;
next	1.55;

1.55
date	2014.05.29.18.23.25;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2014.05.29.18.15.10;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2014.05.29.18.11.13;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2014.05.29.16.00.16;	author jsing;	state Exp;
branches;
next	1.51;

1.51
date	2014.05.29.14.43.33;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2014.05.28.13.07.47;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2014.05.28.13.03.25;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.25.17.32.20;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2014.05.25.16.23.10;	author jsing;	state Exp;
branches;
next	1.46;

1.46
date	2014.05.24.18.34.03;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2014.05.24.16.06.28;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2014.05.22.17.33.17;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.05.15.03.22;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.02.17.05.41;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.24.13.06.52;	author mcbride;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.24.12.21.26;	author mcbride;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.20.12.48.19;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.17.23.35.40;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.17.21.32.37;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.17.13.37.50;	author beck;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.16.21.16.33;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.16.20.39.09;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.16.17.59.16;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.16.15.10.07;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.15.19.42.56;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.14.13.10.35;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.14.00.00.55;	author beck;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches
	1.24.4.1
	1.24.8.1;
next	1.23;

1.23
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.10.19.39.19;	author moritz;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.27.16.18.12;	author moritz;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.04.07.10.32;	author pvalchev;	state Exp;
branches
	1.15.2.1
	1.15.4.1;
next	1.14;

1.14
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches
	1.13.2.1
	1.13.4.1;
next	1.12;

1.12
date	2003.11.11.22.15.20;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.14.11.18.03;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.30.11.08.06;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.03.41;	author beck;	state Exp;
branches
	1.6.2.1
	1.6.4.1;
next	1.5;

1.5
date	2000.12.15.02.58.41;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.50;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.33;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.30;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.11;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.11;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.42;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.32;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.53.01;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.36.46;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.11.11.21.21.25;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.20.42.07;	author markus;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.04.29.05.37.28;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.04.06.06.30.07;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2011.11.03.02.32.21;	author djm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2012.01.05.22.59.10;	author djm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2012.10.13.21.23.50;	author djm;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.6.2.1
date	2002.07.30.11.07.34;	author miod;	state Exp;
branches;
next	;

1.6.4.1
date	2002.07.30.15.47.52;	author jason;	state Exp;
branches;
next	;

1.13.2.1
date	2006.10.05.18.42.22;	author brad;	state Exp;
branches;
next	;

1.13.4.1
date	2006.10.05.17.36.24;	author brad;	state Exp;
branches;
next	;

1.14.2.1
date	2006.11.02.19.56.23;	author brad;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2007.10.11.11.25.10;	author henning;	state Exp;
branches;
next	;

1.15.2.1
date	2007.10.11.11.27.30;	author henning;	state Exp;
branches;
next	;

1.15.4.1
date	2007.10.11.11.30.06;	author henning;	state Exp;
branches;
next	;

1.24.4.1
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.24.8.1
date	2014.08.09.16.54.58;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;

1.78.4.1
date	2014.10.20.21.24.05;	author tedu;	state Exp;
branches;
next	;
commitid	JsH6R4wwwjA2cHXb;


desc
@@


1.170
log
@Bring back the NPN related symbols.

Several pieces of software make use of these based on a conditional around
OPENSSL_NPN_NEGOTIATED, rather than using the presence of the symbols, the
non-existence of a OPENSSL_NO_NEXTPROTONEG define or even the existence of
the TLS extension type.

Unfortunately we cannot remove OPENSSL_NPN_NEGOTIATED since the API for
ALPN was effectively botched and reuses two parts from the NPN
implementation, rather than providing ALPN specific or generic versions.
@
text
@/* $OpenBSD: ssl_lib.c,v 1.169 2017/08/28 17:36:58 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#include <stdio.h>

#include "ssl_locl.h"

#include <openssl/bn.h>
#include <openssl/dh.h>
#include <openssl/lhash.h>
#include <openssl/objects.h>
#include <openssl/ocsp.h>
#include <openssl/x509v3.h>

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include "bytestring.h"

const char *SSL_version_str = OPENSSL_VERSION_TEXT;

int
SSL_clear(SSL *s)
{
	if (s->method == NULL) {
		SSLerror(s, SSL_R_NO_METHOD_SPECIFIED);
		return (0);
	}

	if (ssl_clear_bad_session(s)) {
		SSL_SESSION_free(s->session);
		s->session = NULL;
	}

	s->error = 0;
	s->internal->hit = 0;
	s->internal->shutdown = 0;

	if (s->internal->renegotiate) {
		SSLerror(s, ERR_R_INTERNAL_ERROR);
		return (0);
	}

	s->internal->type = 0;

	s->version = s->method->internal->version;
	s->client_version = s->version;
	s->internal->rwstate = SSL_NOTHING;
	s->internal->rstate = SSL_ST_READ_HEADER;

	BUF_MEM_free(s->internal->init_buf);
	s->internal->init_buf = NULL;

	ssl_clear_cipher_ctx(s);
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->internal->write_hash);

	s->internal->first_packet = 0;

	/*
	 * Check to see if we were changed into a different method, if
	 * so, revert back if we are not doing session-id reuse.
	 */
	if (!s->internal->in_handshake && (s->session == NULL) &&
	    (s->method != s->ctx->method)) {
		s->method->internal->ssl_free(s);
		s->method = s->ctx->method;
		if (!s->method->internal->ssl_new(s))
			return (0);
	} else
		s->method->internal->ssl_clear(s);

	S3I(s)->hs.state = SSL_ST_BEFORE|((s->server) ? SSL_ST_ACCEPT : SSL_ST_CONNECT);

	return (1);
}

/* Used to change an SSL_CTXs default SSL method type */
int
SSL_CTX_set_ssl_version(SSL_CTX *ctx, const SSL_METHOD *meth)
{
	STACK_OF(SSL_CIPHER)	*sk;

	ctx->method = meth;

	sk = ssl_create_cipher_list(ctx->method, &(ctx->cipher_list),
	    &(ctx->internal->cipher_list_by_id), SSL_DEFAULT_CIPHER_LIST);
	if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= 0)) {
		SSLerrorx(SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS);
		return (0);
	}
	return (1);
}

SSL *
SSL_new(SSL_CTX *ctx)
{
	SSL	*s;

	if (ctx == NULL) {
		SSLerrorx(SSL_R_NULL_SSL_CTX);
		return (NULL);
	}
	if (ctx->method == NULL) {
		SSLerrorx(SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);
		return (NULL);
	}

	if ((s = calloc(1, sizeof(*s))) == NULL) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}
	if ((s->internal = calloc(1, sizeof(*s->internal))) == NULL) {
		free(s);
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}

	s->internal->min_version = ctx->internal->min_version;
	s->internal->max_version = ctx->internal->max_version;

	s->internal->options = ctx->internal->options;
	s->internal->mode = ctx->internal->mode;
	s->internal->max_cert_list = ctx->internal->max_cert_list;

	if (ctx->internal->cert != NULL) {
		/*
		 * Earlier library versions used to copy the pointer to
		 * the CERT, not its contents; only when setting new
		 * parameters for the per-SSL copy, ssl_cert_new would be
		 * called (and the direct reference to the per-SSL_CTX
		 * settings would be lost, but those still were indirectly
		 * accessed for various purposes, and for that reason they
		 * used to be known as s->ctx->default_cert).
		 * Now we don't look at the SSL_CTX's CERT after having
		 * duplicated it once.
		*/
		s->cert = ssl_cert_dup(ctx->internal->cert);
		if (s->cert == NULL)
			goto err;
	} else
		s->cert=NULL; /* Cannot really happen (see SSL_CTX_new) */

	s->internal->read_ahead = ctx->internal->read_ahead;
	s->internal->msg_callback = ctx->internal->msg_callback;
	s->internal->msg_callback_arg = ctx->internal->msg_callback_arg;
	s->verify_mode = ctx->verify_mode;
	s->sid_ctx_length = ctx->sid_ctx_length;
	OPENSSL_assert(s->sid_ctx_length <= sizeof s->sid_ctx);
	memcpy(&s->sid_ctx, &ctx->sid_ctx, sizeof(s->sid_ctx));
	s->internal->verify_callback = ctx->internal->default_verify_callback;
	s->internal->generate_session_id = ctx->internal->generate_session_id;

	s->param = X509_VERIFY_PARAM_new();
	if (!s->param)
		goto err;
	X509_VERIFY_PARAM_inherit(s->param, ctx->param);
	s->internal->quiet_shutdown = ctx->internal->quiet_shutdown;
	s->max_send_fragment = ctx->internal->max_send_fragment;

	CRYPTO_add(&ctx->references, 1, CRYPTO_LOCK_SSL_CTX);
	s->ctx = ctx;
	s->internal->tlsext_debug_cb = 0;
	s->internal->tlsext_debug_arg = NULL;
	s->internal->tlsext_ticket_expected = 0;
	s->tlsext_status_type = -1;
	s->internal->tlsext_status_expected = 0;
	s->internal->tlsext_ocsp_ids = NULL;
	s->internal->tlsext_ocsp_exts = NULL;
	s->internal->tlsext_ocsp_resp = NULL;
	s->internal->tlsext_ocsp_resplen = -1;
	CRYPTO_add(&ctx->references, 1, CRYPTO_LOCK_SSL_CTX);
	s->initial_ctx = ctx;

	if (ctx->internal->tlsext_ecpointformatlist != NULL) {
		s->internal->tlsext_ecpointformatlist =
		    calloc(ctx->internal->tlsext_ecpointformatlist_length,
			sizeof(ctx->internal->tlsext_ecpointformatlist[0]));
		if (s->internal->tlsext_ecpointformatlist == NULL)
			goto err;
		memcpy(s->internal->tlsext_ecpointformatlist,
		    ctx->internal->tlsext_ecpointformatlist,
		    ctx->internal->tlsext_ecpointformatlist_length *
		    sizeof(ctx->internal->tlsext_ecpointformatlist[0]));
		s->internal->tlsext_ecpointformatlist_length =
		    ctx->internal->tlsext_ecpointformatlist_length;
	}
	if (ctx->internal->tlsext_supportedgroups != NULL) {
		s->internal->tlsext_supportedgroups =
		    calloc(ctx->internal->tlsext_supportedgroups_length,
			sizeof(ctx->internal->tlsext_supportedgroups));
		if (s->internal->tlsext_supportedgroups == NULL)
			goto err;
		memcpy(s->internal->tlsext_supportedgroups,
		    ctx->internal->tlsext_supportedgroups,
		    ctx->internal->tlsext_supportedgroups_length *
		    sizeof(ctx->internal->tlsext_supportedgroups[0]));
		s->internal->tlsext_supportedgroups_length =
		    ctx->internal->tlsext_supportedgroups_length;
	}

	if (s->ctx->internal->alpn_client_proto_list != NULL) {
		s->internal->alpn_client_proto_list =
		    malloc(s->ctx->internal->alpn_client_proto_list_len);
		if (s->internal->alpn_client_proto_list == NULL)
			goto err;
		memcpy(s->internal->alpn_client_proto_list,
		    s->ctx->internal->alpn_client_proto_list,
		    s->ctx->internal->alpn_client_proto_list_len);
		s->internal->alpn_client_proto_list_len =
		    s->ctx->internal->alpn_client_proto_list_len;
	}

	s->verify_result = X509_V_OK;

	s->method = ctx->method;

	if (!s->method->internal->ssl_new(s))
		goto err;

	s->references = 1;
	s->server = (ctx->method->internal->ssl_accept == ssl_undefined_function) ? 0 : 1;

	SSL_clear(s);

	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->internal->ex_data);

	return (s);

 err:
	SSL_free(s);
	SSLerrorx(ERR_R_MALLOC_FAILURE);
	return (NULL);
}

int
SSL_CTX_set_session_id_context(SSL_CTX *ctx, const unsigned char *sid_ctx,
    unsigned int sid_ctx_len)
{
	if (sid_ctx_len > sizeof ctx->sid_ctx) {
		SSLerrorx(SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
		return (0);
	}
	ctx->sid_ctx_length = sid_ctx_len;
	memcpy(ctx->sid_ctx, sid_ctx, sid_ctx_len);

	return (1);
}

int
SSL_set_session_id_context(SSL *ssl, const unsigned char *sid_ctx,
    unsigned int sid_ctx_len)
{
	if (sid_ctx_len > SSL_MAX_SID_CTX_LENGTH) {
		SSLerror(ssl, SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
		return (0);
	}
	ssl->sid_ctx_length = sid_ctx_len;
	memcpy(ssl->sid_ctx, sid_ctx, sid_ctx_len);

	return (1);
}

int
SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb)
{
	CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
	ctx->internal->generate_session_id = cb;
	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
	return (1);
}

int
SSL_set_generate_session_id(SSL *ssl, GEN_SESSION_CB cb)
{
	CRYPTO_w_lock(CRYPTO_LOCK_SSL);
	ssl->internal->generate_session_id = cb;
	CRYPTO_w_unlock(CRYPTO_LOCK_SSL);
	return (1);
}

int
SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,
    unsigned int id_len)
{
	/*
	 * A quick examination of SSL_SESSION_hash and SSL_SESSION_cmp
	 * shows how we can "construct" a session to give us the desired
	 * check - ie. to find if there's a session in the hash table
	 * that would conflict with any new session built out of this
	 * id/id_len and the ssl_version in use by this SSL.
	 */
	SSL_SESSION r, *p;

	if (id_len > sizeof r.session_id)
		return (0);

	r.ssl_version = ssl->version;
	r.session_id_length = id_len;
	memcpy(r.session_id, id, id_len);

	CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
	p = lh_SSL_SESSION_retrieve(ssl->ctx->internal->sessions, &r);
	CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
	return (p != NULL);
}

int
SSL_CTX_set_purpose(SSL_CTX *s, int purpose)
{
	return (X509_VERIFY_PARAM_set_purpose(s->param, purpose));
}

int
SSL_set_purpose(SSL *s, int purpose)
{
	return (X509_VERIFY_PARAM_set_purpose(s->param, purpose));
}

int
SSL_CTX_set_trust(SSL_CTX *s, int trust)
{
	return (X509_VERIFY_PARAM_set_trust(s->param, trust));
}

int
SSL_set_trust(SSL *s, int trust)
{
	return (X509_VERIFY_PARAM_set_trust(s->param, trust));
}

int
SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm)
{
	return (X509_VERIFY_PARAM_set1(ctx->param, vpm));
}

int
SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm)
{
	return (X509_VERIFY_PARAM_set1(ssl->param, vpm));
}

void
SSL_free(SSL *s)
{
	int	i;

	if (s == NULL)
		return;

	i = CRYPTO_add(&s->references, -1, CRYPTO_LOCK_SSL);
	if (i > 0)
		return;

	X509_VERIFY_PARAM_free(s->param);

	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->internal->ex_data);

	if (s->bbio != NULL) {
		/* If the buffering BIO is in place, pop it off */
		if (s->bbio == s->wbio) {
			s->wbio = BIO_pop(s->wbio);
		}
		BIO_free(s->bbio);
		s->bbio = NULL;
	}

	if (s->rbio != s->wbio)
		BIO_free_all(s->rbio);
	BIO_free_all(s->wbio);

	BUF_MEM_free(s->internal->init_buf);

	/* add extra stuff */
	sk_SSL_CIPHER_free(s->cipher_list);
	sk_SSL_CIPHER_free(s->internal->cipher_list_by_id);

	/* Make the next call work :-) */
	if (s->session != NULL) {
		ssl_clear_bad_session(s);
		SSL_SESSION_free(s->session);
	}

	ssl_clear_cipher_ctx(s);
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->internal->write_hash);

	ssl_cert_free(s->cert);

	free(s->tlsext_hostname);
	SSL_CTX_free(s->initial_ctx);

	free(s->internal->tlsext_ecpointformatlist);
	free(s->internal->tlsext_supportedgroups);

	sk_X509_EXTENSION_pop_free(s->internal->tlsext_ocsp_exts,
	    X509_EXTENSION_free);
	sk_OCSP_RESPID_pop_free(s->internal->tlsext_ocsp_ids, OCSP_RESPID_free);
	free(s->internal->tlsext_ocsp_resp);

	sk_X509_NAME_pop_free(s->internal->client_CA, X509_NAME_free);

	if (s->method != NULL)
		s->method->internal->ssl_free(s);

	SSL_CTX_free(s->ctx);

	free(s->internal->alpn_client_proto_list);

#ifndef OPENSSL_NO_SRTP
	sk_SRTP_PROTECTION_PROFILE_free(s->internal->srtp_profiles);
#endif

	free(s->internal);
	free(s);
}

void
SSL_set_bio(SSL *s, BIO *rbio, BIO *wbio)
{
	/* If the output buffering BIO is still in place, remove it */
	if (s->bbio != NULL) {
		if (s->wbio == s->bbio) {
			s->wbio = s->wbio->next_bio;
			s->bbio->next_bio = NULL;
		}
	}

	if (s->rbio != rbio && s->rbio != s->wbio)
		BIO_free_all(s->rbio);
	if (s->wbio != wbio)
		BIO_free_all(s->wbio);
	s->rbio = rbio;
	s->wbio = wbio;
}

BIO *
SSL_get_rbio(const SSL *s)
{
	return (s->rbio);
}

BIO *
SSL_get_wbio(const SSL *s)
{
	return (s->wbio);
}

int
SSL_get_fd(const SSL *s)
{
	return (SSL_get_rfd(s));
}

int
SSL_get_rfd(const SSL *s)
{
	int	 ret = -1;
	BIO	*b, *r;

	b = SSL_get_rbio(s);
	r = BIO_find_type(b, BIO_TYPE_DESCRIPTOR);
	if (r != NULL)
		BIO_get_fd(r, &ret);
	return (ret);
}

int
SSL_get_wfd(const SSL *s)
{
	int	 ret = -1;
	BIO	*b, *r;

	b = SSL_get_wbio(s);
	r = BIO_find_type(b, BIO_TYPE_DESCRIPTOR);
	if (r != NULL)
		BIO_get_fd(r, &ret);
	return (ret);
}

int
SSL_set_fd(SSL *s, int fd)
{
	int	 ret = 0;
	BIO	*bio = NULL;

	bio = BIO_new(BIO_s_socket());

	if (bio == NULL) {
		SSLerror(s, ERR_R_BUF_LIB);
		goto err;
	}
	BIO_set_fd(bio, fd, BIO_NOCLOSE);
	SSL_set_bio(s, bio, bio);
	ret = 1;
err:
	return (ret);
}

int
SSL_set_wfd(SSL *s, int fd)
{
	int	 ret = 0;
	BIO	*bio = NULL;

	if ((s->rbio == NULL) || (BIO_method_type(s->rbio) != BIO_TYPE_SOCKET)
	    || ((int)BIO_get_fd(s->rbio, NULL) != fd)) {
		bio = BIO_new(BIO_s_socket());

		if (bio == NULL) {
			SSLerror(s, ERR_R_BUF_LIB);
			goto err;
		}
		BIO_set_fd(bio, fd, BIO_NOCLOSE);
		SSL_set_bio(s, SSL_get_rbio(s), bio);
	} else
		SSL_set_bio(s, SSL_get_rbio(s), SSL_get_rbio(s));
	ret = 1;
err:
	return (ret);
}

int
SSL_set_rfd(SSL *s, int fd)
{
	int	 ret = 0;
	BIO	*bio = NULL;

	if ((s->wbio == NULL) || (BIO_method_type(s->wbio) != BIO_TYPE_SOCKET)
	    || ((int)BIO_get_fd(s->wbio, NULL) != fd)) {
		bio = BIO_new(BIO_s_socket());

		if (bio == NULL) {
			SSLerror(s, ERR_R_BUF_LIB);
			goto err;
		}
		BIO_set_fd(bio, fd, BIO_NOCLOSE);
		SSL_set_bio(s, bio, SSL_get_wbio(s));
	} else
		SSL_set_bio(s, SSL_get_wbio(s), SSL_get_wbio(s));
	ret = 1;
err:
	return (ret);
}


/* return length of latest Finished message we sent, copy to 'buf' */
size_t
SSL_get_finished(const SSL *s, void *buf, size_t count)
{
	size_t	ret = 0;

	if (s->s3 != NULL) {
		ret = S3I(s)->tmp.finish_md_len;
		if (count > ret)
			count = ret;
		memcpy(buf, S3I(s)->tmp.finish_md, count);
	}
	return (ret);
}

/* return length of latest Finished message we expected, copy to 'buf' */
size_t
SSL_get_peer_finished(const SSL *s, void *buf, size_t count)
{
	size_t	ret = 0;

	if (s->s3 != NULL) {
		ret = S3I(s)->tmp.peer_finish_md_len;
		if (count > ret)
			count = ret;
		memcpy(buf, S3I(s)->tmp.peer_finish_md, count);
	}
	return (ret);
}


int
SSL_get_verify_mode(const SSL *s)
{
	return (s->verify_mode);
}

int
SSL_get_verify_depth(const SSL *s)
{
	return (X509_VERIFY_PARAM_get_depth(s->param));
}

int
(*SSL_get_verify_callback(const SSL *s))(int, X509_STORE_CTX *)
{
	return (s->internal->verify_callback);
}

int
SSL_CTX_get_verify_mode(const SSL_CTX *ctx)
{
	return (ctx->verify_mode);
}

int
SSL_CTX_get_verify_depth(const SSL_CTX *ctx)
{
	return (X509_VERIFY_PARAM_get_depth(ctx->param));
}

int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int, X509_STORE_CTX *)
{
	return (ctx->internal->default_verify_callback);
}

void
SSL_set_verify(SSL *s, int mode,
    int (*callback)(int ok, X509_STORE_CTX *ctx))
{
	s->verify_mode = mode;
	if (callback != NULL)
		s->internal->verify_callback = callback;
}

void
SSL_set_verify_depth(SSL *s, int depth)
{
	X509_VERIFY_PARAM_set_depth(s->param, depth);
}

void
SSL_set_read_ahead(SSL *s, int yes)
{
	s->internal->read_ahead = yes;
}

int
SSL_get_read_ahead(const SSL *s)
{
	return (s->internal->read_ahead);
}

int
SSL_pending(const SSL *s)
{
	/*
	 * SSL_pending cannot work properly if read-ahead is enabled
	 * (SSL_[CTX_]ctrl(..., SSL_CTRL_SET_READ_AHEAD, 1, NULL)),
	 * and it is impossible to fix since SSL_pending cannot report
	 * errors that may be observed while scanning the new data.
	 * (Note that SSL_pending() is often used as a boolean value,
	 * so we'd better not return -1.)
	 */
	return (s->method->internal->ssl_pending(s));
}

X509 *
SSL_get_peer_certificate(const SSL *s)
{
	X509	*r;

	if ((s == NULL) || (s->session == NULL))
		r = NULL;
	else
		r = s->session->peer;

	if (r == NULL)
		return (r);

	CRYPTO_add(&r->references, 1, CRYPTO_LOCK_X509);

	return (r);
}

STACK_OF(X509) *
SSL_get_peer_cert_chain(const SSL *s)
{
	STACK_OF(X509)	*r;

	if ((s == NULL) || (s->session == NULL) ||
	    (SSI(s)->sess_cert == NULL))
		r = NULL;
	else
		r = SSI(s)->sess_cert->cert_chain;

	/*
	 * If we are a client, cert_chain includes the peer's own
	 * certificate;
	 * if we are a server, it does not.
	 */
	return (r);
}

/*
 * Now in theory, since the calling process own 't' it should be safe to
 * modify.  We need to be able to read f without being hassled
 */
void
SSL_copy_session_id(SSL *t, const SSL *f)
{
	CERT	*tmp;

	/* Do we need to to SSL locking? */
	SSL_set_session(t, SSL_get_session(f));

	/*
	 * What if we are setup as SSLv2 but want to talk SSLv3 or
	 * vice-versa.
	 */
	if (t->method != f->method) {
		t->method->internal->ssl_free(t);	/* cleanup current */
		t->method = f->method;	/* change method */
		t->method->internal->ssl_new(t);	/* setup new */
	}

	tmp = t->cert;
	if (f->cert != NULL) {
		CRYPTO_add(&f->cert->references, 1, CRYPTO_LOCK_SSL_CERT);
		t->cert = f->cert;
	} else
		t->cert = NULL;
	ssl_cert_free(tmp);
	SSL_set_session_id_context(t, f->sid_ctx, f->sid_ctx_length);
}

/* Fix this so it checks all the valid key/cert options */
int
SSL_CTX_check_private_key(const SSL_CTX *ctx)
{
	if ((ctx == NULL) || (ctx->internal->cert == NULL) ||
	    (ctx->internal->cert->key->x509 == NULL)) {
		SSLerrorx(SSL_R_NO_CERTIFICATE_ASSIGNED);
		return (0);
	}
	if (ctx->internal->cert->key->privatekey == NULL) {
		SSLerrorx(SSL_R_NO_PRIVATE_KEY_ASSIGNED);
		return (0);
	}
	return (X509_check_private_key(ctx->internal->cert->key->x509,
	    ctx->internal->cert->key->privatekey));
}

/* Fix this function so that it takes an optional type parameter */
int
SSL_check_private_key(const SSL *ssl)
{
	if (ssl == NULL) {
		SSLerrorx(ERR_R_PASSED_NULL_PARAMETER);
		return (0);
	}
	if (ssl->cert == NULL) {
		SSLerror(ssl, SSL_R_NO_CERTIFICATE_ASSIGNED);
		return (0);
	}
	if (ssl->cert->key->x509 == NULL) {
		SSLerror(ssl, SSL_R_NO_CERTIFICATE_ASSIGNED);
		return (0);
	}
	if (ssl->cert->key->privatekey == NULL) {
		SSLerror(ssl, SSL_R_NO_PRIVATE_KEY_ASSIGNED);
		return (0);
	}
	return (X509_check_private_key(ssl->cert->key->x509,
	    ssl->cert->key->privatekey));
}

int
SSL_accept(SSL *s)
{
	if (s->internal->handshake_func == NULL)
		SSL_set_accept_state(s); /* Not properly initialized yet */

	return (s->method->internal->ssl_accept(s));
}

int
SSL_connect(SSL *s)
{
	if (s->internal->handshake_func == NULL)
		SSL_set_connect_state(s); /* Not properly initialized yet */

	return (s->method->internal->ssl_connect(s));
}

long
SSL_get_default_timeout(const SSL *s)
{
	return (s->method->internal->get_timeout());
}

int
SSL_read(SSL *s, void *buf, int num)
{
	if (s->internal->handshake_func == NULL) {
		SSLerror(s, SSL_R_UNINITIALIZED);
		return (-1);
	}

	if (s->internal->shutdown & SSL_RECEIVED_SHUTDOWN) {
		s->internal->rwstate = SSL_NOTHING;
		return (0);
	}
	return (s->method->internal->ssl_read(s, buf, num));
}

int
SSL_peek(SSL *s, void *buf, int num)
{
	if (s->internal->handshake_func == NULL) {
		SSLerror(s, SSL_R_UNINITIALIZED);
		return (-1);
	}

	if (s->internal->shutdown & SSL_RECEIVED_SHUTDOWN) {
		return (0);
	}
	return (s->method->internal->ssl_peek(s, buf, num));
}

int
SSL_write(SSL *s, const void *buf, int num)
{
	if (s->internal->handshake_func == NULL) {
		SSLerror(s, SSL_R_UNINITIALIZED);
		return (-1);
	}

	if (s->internal->shutdown & SSL_SENT_SHUTDOWN) {
		s->internal->rwstate = SSL_NOTHING;
		SSLerror(s, SSL_R_PROTOCOL_IS_SHUTDOWN);
		return (-1);
	}
	return (s->method->internal->ssl_write(s, buf, num));
}

int
SSL_shutdown(SSL *s)
{
	/*
	 * Note that this function behaves differently from what one might
	 * expect.  Return values are 0 for no success (yet),
	 * 1 for success; but calling it once is usually not enough,
	 * even if blocking I/O is used (see ssl3_shutdown).
	 */

	if (s->internal->handshake_func == NULL) {
		SSLerror(s, SSL_R_UNINITIALIZED);
		return (-1);
	}

	if ((s != NULL) && !SSL_in_init(s))
		return (s->method->internal->ssl_shutdown(s));
	else
		return (1);
}

int
SSL_renegotiate(SSL *s)
{
	if (s->internal->renegotiate == 0)
		s->internal->renegotiate = 1;

	s->internal->new_session = 1;

	return (s->method->internal->ssl_renegotiate(s));
}

int
SSL_renegotiate_abbreviated(SSL *s)
{
	if (s->internal->renegotiate == 0)
		s->internal->renegotiate = 1;

	s->internal->new_session = 0;

	return (s->method->internal->ssl_renegotiate(s));
}

int
SSL_renegotiate_pending(SSL *s)
{
	/*
	 * Becomes true when negotiation is requested;
	 * false again once a handshake has finished.
	 */
	return (s->internal->renegotiate != 0);
}

long
SSL_ctrl(SSL *s, int cmd, long larg, void *parg)
{
	long	l;

	switch (cmd) {
	case SSL_CTRL_GET_READ_AHEAD:
		return (s->internal->read_ahead);
	case SSL_CTRL_SET_READ_AHEAD:
		l = s->internal->read_ahead;
		s->internal->read_ahead = larg;
		return (l);

	case SSL_CTRL_SET_MSG_CALLBACK_ARG:
		s->internal->msg_callback_arg = parg;
		return (1);

	case SSL_CTRL_OPTIONS:
		return (s->internal->options|=larg);
	case SSL_CTRL_CLEAR_OPTIONS:
		return (s->internal->options&=~larg);
	case SSL_CTRL_MODE:
		return (s->internal->mode|=larg);
	case SSL_CTRL_CLEAR_MODE:
		return (s->internal->mode &=~larg);
	case SSL_CTRL_GET_MAX_CERT_LIST:
		return (s->internal->max_cert_list);
	case SSL_CTRL_SET_MAX_CERT_LIST:
		l = s->internal->max_cert_list;
		s->internal->max_cert_list = larg;
		return (l);
	case SSL_CTRL_SET_MTU:
#ifndef OPENSSL_NO_DTLS1
		if (larg < (long)dtls1_min_mtu())
			return (0);
#endif
		if (SSL_IS_DTLS(s)) {
			D1I(s)->mtu = larg;
			return (larg);
		}
		return (0);
	case SSL_CTRL_SET_MAX_SEND_FRAGMENT:
		if (larg < 512 || larg > SSL3_RT_MAX_PLAIN_LENGTH)
			return (0);
		s->max_send_fragment = larg;
		return (1);
	case SSL_CTRL_GET_RI_SUPPORT:
		if (s->s3)
			return (S3I(s)->send_connection_binding);
		else return (0);
	default:
		if (SSL_IS_DTLS(s))
			return dtls1_ctrl(s, cmd, larg, parg);
		return ssl3_ctrl(s, cmd, larg, parg);
	}
}

long
SSL_callback_ctrl(SSL *s, int cmd, void (*fp)(void))
{
	switch (cmd) {
	case SSL_CTRL_SET_MSG_CALLBACK:
		s->internal->msg_callback = (void (*)(int write_p, int version,
		    int content_type, const void *buf, size_t len,
		    SSL *ssl, void *arg))(fp);
		return (1);

	default:
		return (ssl3_callback_ctrl(s, cmd, fp));
	}
}

struct lhash_st_SSL_SESSION *
SSL_CTX_sessions(SSL_CTX *ctx)
{
	return (ctx->internal->sessions);
}

long
SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)
{
	long	l;

	switch (cmd) {
	case SSL_CTRL_GET_READ_AHEAD:
		return (ctx->internal->read_ahead);
	case SSL_CTRL_SET_READ_AHEAD:
		l = ctx->internal->read_ahead;
		ctx->internal->read_ahead = larg;
		return (l);

	case SSL_CTRL_SET_MSG_CALLBACK_ARG:
		ctx->internal->msg_callback_arg = parg;
		return (1);

	case SSL_CTRL_GET_MAX_CERT_LIST:
		return (ctx->internal->max_cert_list);
	case SSL_CTRL_SET_MAX_CERT_LIST:
		l = ctx->internal->max_cert_list;
		ctx->internal->max_cert_list = larg;
		return (l);

	case SSL_CTRL_SET_SESS_CACHE_SIZE:
		l = ctx->internal->session_cache_size;
		ctx->internal->session_cache_size = larg;
		return (l);
	case SSL_CTRL_GET_SESS_CACHE_SIZE:
		return (ctx->internal->session_cache_size);
	case SSL_CTRL_SET_SESS_CACHE_MODE:
		l = ctx->internal->session_cache_mode;
		ctx->internal->session_cache_mode = larg;
		return (l);
	case SSL_CTRL_GET_SESS_CACHE_MODE:
		return (ctx->internal->session_cache_mode);

	case SSL_CTRL_SESS_NUMBER:
		return (lh_SSL_SESSION_num_items(ctx->internal->sessions));
	case SSL_CTRL_SESS_CONNECT:
		return (ctx->internal->stats.sess_connect);
	case SSL_CTRL_SESS_CONNECT_GOOD:
		return (ctx->internal->stats.sess_connect_good);
	case SSL_CTRL_SESS_CONNECT_RENEGOTIATE:
		return (ctx->internal->stats.sess_connect_renegotiate);
	case SSL_CTRL_SESS_ACCEPT:
		return (ctx->internal->stats.sess_accept);
	case SSL_CTRL_SESS_ACCEPT_GOOD:
		return (ctx->internal->stats.sess_accept_good);
	case SSL_CTRL_SESS_ACCEPT_RENEGOTIATE:
		return (ctx->internal->stats.sess_accept_renegotiate);
	case SSL_CTRL_SESS_HIT:
		return (ctx->internal->stats.sess_hit);
	case SSL_CTRL_SESS_CB_HIT:
		return (ctx->internal->stats.sess_cb_hit);
	case SSL_CTRL_SESS_MISSES:
		return (ctx->internal->stats.sess_miss);
	case SSL_CTRL_SESS_TIMEOUTS:
		return (ctx->internal->stats.sess_timeout);
	case SSL_CTRL_SESS_CACHE_FULL:
		return (ctx->internal->stats.sess_cache_full);
	case SSL_CTRL_OPTIONS:
		return (ctx->internal->options|=larg);
	case SSL_CTRL_CLEAR_OPTIONS:
		return (ctx->internal->options&=~larg);
	case SSL_CTRL_MODE:
		return (ctx->internal->mode|=larg);
	case SSL_CTRL_CLEAR_MODE:
		return (ctx->internal->mode&=~larg);
	case SSL_CTRL_SET_MAX_SEND_FRAGMENT:
		if (larg < 512 || larg > SSL3_RT_MAX_PLAIN_LENGTH)
			return (0);
		ctx->internal->max_send_fragment = larg;
		return (1);
	default:
		return (ssl3_ctx_ctrl(ctx, cmd, larg, parg));
	}
}

long
SSL_CTX_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)(void))
{
	switch (cmd) {
	case SSL_CTRL_SET_MSG_CALLBACK:
		ctx->internal->msg_callback = (void (*)(int write_p, int version,
		    int content_type, const void *buf, size_t len, SSL *ssl,
		    void *arg))(fp);
		return (1);

	default:
		return (ssl3_ctx_callback_ctrl(ctx, cmd, fp));
	}
}

int
ssl_cipher_id_cmp(const SSL_CIPHER *a, const SSL_CIPHER *b)
{
	long	l;

	l = a->id - b->id;
	if (l == 0L)
		return (0);
	else
		return ((l > 0) ? 1:-1);
}

int
ssl_cipher_ptr_id_cmp(const SSL_CIPHER * const *ap,
    const SSL_CIPHER * const *bp)
{
	long	l;

	l = (*ap)->id - (*bp)->id;
	if (l == 0L)
		return (0);
	else
		return ((l > 0) ? 1:-1);
}

/*
 * Return a STACK of the ciphers available for the SSL and in order of
 * preference.
 */
STACK_OF(SSL_CIPHER) *
SSL_get_ciphers(const SSL *s)
{
	if (s != NULL) {
		if (s->cipher_list != NULL) {
			return (s->cipher_list);
		} else if ((s->ctx != NULL) && (s->ctx->cipher_list != NULL)) {
			return (s->ctx->cipher_list);
		}
	}
	return (NULL);
}

/*
 * Return a STACK of the ciphers available for the SSL and in order of
 * algorithm id.
 */
STACK_OF(SSL_CIPHER) *
ssl_get_ciphers_by_id(SSL *s)
{
	if (s != NULL) {
		if (s->internal->cipher_list_by_id != NULL) {
			return (s->internal->cipher_list_by_id);
		} else if ((s->ctx != NULL) &&
		    (s->ctx->internal->cipher_list_by_id != NULL)) {
			return (s->ctx->internal->cipher_list_by_id);
		}
	}
	return (NULL);
}

/* See if we have any ECC cipher suites. */
int
ssl_has_ecc_ciphers(SSL *s)
{
	STACK_OF(SSL_CIPHER) *ciphers;
	unsigned long alg_k, alg_a;
	SSL_CIPHER *cipher;
	int i;

	if (s->version == DTLS1_VERSION)
		return 0;
	if ((ciphers = SSL_get_ciphers(s)) == NULL)
		return 0;

	for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {
		cipher = sk_SSL_CIPHER_value(ciphers, i);

		alg_k = cipher->algorithm_mkey;
		alg_a = cipher->algorithm_auth;

		if ((alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA))
			return 1;
	}

	return 0;
}

/* The old interface to get the same thing as SSL_get_ciphers(). */
const char *
SSL_get_cipher_list(const SSL *s, int n)
{
	SSL_CIPHER		*c;
	STACK_OF(SSL_CIPHER)	*sk;

	if (s == NULL)
		return (NULL);
	sk = SSL_get_ciphers(s);
	if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
		return (NULL);
	c = sk_SSL_CIPHER_value(sk, n);
	if (c == NULL)
		return (NULL);
	return (c->name);
}

/* Specify the ciphers to be used by default by the SSL_CTX. */
int
SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str)
{
	STACK_OF(SSL_CIPHER)	*sk;

	sk = ssl_create_cipher_list(ctx->method, &ctx->cipher_list,
	    &ctx->internal->cipher_list_by_id, str);
	/*
	 * ssl_create_cipher_list may return an empty stack if it
	 * was unable to find a cipher matching the given rule string
	 * (for example if the rule string specifies a cipher which
	 * has been disabled). This is not an error as far as
	 * ssl_create_cipher_list is concerned, and hence
	 * ctx->cipher_list and ctx->internal->cipher_list_by_id has been
	 * updated.
	 */
	if (sk == NULL)
		return (0);
	else if (sk_SSL_CIPHER_num(sk) == 0) {
		SSLerrorx(SSL_R_NO_CIPHER_MATCH);
		return (0);
	}
	return (1);
}

/* Specify the ciphers to be used by the SSL. */
int
SSL_set_cipher_list(SSL *s, const char *str)
{
	STACK_OF(SSL_CIPHER)	*sk;

	sk = ssl_create_cipher_list(s->ctx->method, &s->cipher_list,
	&s->internal->cipher_list_by_id, str);
	/* see comment in SSL_CTX_set_cipher_list */
	if (sk == NULL)
		return (0);
	else if (sk_SSL_CIPHER_num(sk) == 0) {
		SSLerror(s, SSL_R_NO_CIPHER_MATCH);
		return (0);
	}
	return (1);
}

/* works well for SSLv2, not so good for SSLv3 */
char *
SSL_get_shared_ciphers(const SSL *s, char *buf, int len)
{
	char			*end;
	STACK_OF(SSL_CIPHER)	*sk;
	SSL_CIPHER		*c;
	size_t			 curlen = 0;
	int			 i;

	if (s->session == NULL || s->session->ciphers == NULL || len < 2)
		return (NULL);

	sk = s->session->ciphers;
	if (sk_SSL_CIPHER_num(sk) == 0)
		return (NULL);

	buf[0] = '\0';
	for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {
		c = sk_SSL_CIPHER_value(sk, i);
		end = buf + curlen;
		if (strlcat(buf, c->name, len) >= len ||
		    (curlen = strlcat(buf, ":", len)) >= len) {
			/* remove truncated cipher from list */
			*end = '\0';
			break;
		}
	}
	/* remove trailing colon */
	if ((end = strrchr(buf, ':')) != NULL)
		*end = '\0';
	return (buf);
}

int
ssl_cipher_list_to_bytes(SSL *s, STACK_OF(SSL_CIPHER) *sk, unsigned char *p,
    size_t maxlen, size_t *outlen)
{
	SSL_CIPHER *cipher;
	int ciphers = 0;
	CBB cbb;
	int i;

	*outlen = 0;

	if (sk == NULL)
		return (0);

	if (!CBB_init_fixed(&cbb, p, maxlen))
		goto err;

	for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {
		cipher = sk_SSL_CIPHER_value(sk, i);

		/* Skip TLS v1.2 only ciphersuites if lower than v1.2 */
		if ((cipher->algorithm_ssl & SSL_TLSV1_2) &&
		    (TLS1_get_client_version(s) < TLS1_2_VERSION))
			continue;

		if (!CBB_add_u16(&cbb, ssl3_cipher_get_value(cipher)))
			goto err;

		ciphers++;
	}

	/* Add SCSV if there are other ciphers and we're not renegotiating. */
	if (ciphers > 0 && !s->internal->renegotiate) {
		if (!CBB_add_u16(&cbb, SSL3_CK_SCSV & SSL3_CK_VALUE_MASK))
			goto err;
	}

	if (!CBB_finish(&cbb, NULL, outlen))
		goto err;

	return 1;

 err:
	CBB_cleanup(&cbb);

	return 0;
}

STACK_OF(SSL_CIPHER) *
ssl_bytes_to_cipher_list(SSL *s, const unsigned char *p, int num)
{
	CBS			 cbs;
	const SSL_CIPHER	*c;
	STACK_OF(SSL_CIPHER)	*sk = NULL;
	unsigned long		 cipher_id;
	uint16_t		 cipher_value, max_version;

	if (s->s3)
		S3I(s)->send_connection_binding = 0;

	/*
	 * RFC 5246 section 7.4.1.2 defines the interval as [2,2^16-2].
	 */
	if (num < 2 || num > 0x10000 - 2) {
		SSLerror(s, SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);
		return (NULL);
	}

	if ((sk = sk_SSL_CIPHER_new_null()) == NULL) {
		SSLerror(s, ERR_R_MALLOC_FAILURE);
		goto err;
	}

	CBS_init(&cbs, p, num);
	while (CBS_len(&cbs) > 0) {
		if (!CBS_get_u16(&cbs, &cipher_value)) {
			SSLerror(s, SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);
			goto err;
		}

		cipher_id = SSL3_CK_ID | cipher_value;

		if (s->s3 != NULL && cipher_id == SSL3_CK_SCSV) {
			/*
			 * TLS_EMPTY_RENEGOTIATION_INFO_SCSV is fatal if
			 * renegotiating.
			 */
			if (s->internal->renegotiate) {
				SSLerror(s, SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING);
				ssl3_send_alert(s, SSL3_AL_FATAL,
				    SSL_AD_HANDSHAKE_FAILURE);

				goto err;
			}
			S3I(s)->send_connection_binding = 1;
			continue;
		}

		if (cipher_id == SSL3_CK_FALLBACK_SCSV) {
			/*
			 * TLS_FALLBACK_SCSV indicates that the client
			 * previously tried a higher protocol version.
			 * Fail if the current version is an unexpected
			 * downgrade.
			 */
			max_version = ssl_max_server_version(s);
			if (max_version == 0 || s->version < max_version) {
				SSLerror(s, SSL_R_INAPPROPRIATE_FALLBACK);
				if (s->s3 != NULL)
					ssl3_send_alert(s, SSL3_AL_FATAL,
					    SSL_AD_INAPPROPRIATE_FALLBACK);
				goto err;
			}
			continue;
		}

		if ((c = ssl3_get_cipher_by_value(cipher_value)) != NULL) {
			if (!sk_SSL_CIPHER_push(sk, c)) {
				SSLerror(s, ERR_R_MALLOC_FAILURE);
				goto err;
			}
		}
	}

	return (sk);

err:
	sk_SSL_CIPHER_free(sk);

	return (NULL);
}


/*
 * Return a servername extension value if provided in Client Hello, or NULL.
 * So far, only host_name types are defined (RFC 3546).
 */
const char *
SSL_get_servername(const SSL *s, const int type)
{
	if (type != TLSEXT_NAMETYPE_host_name)
		return (NULL);

	return (s->session && !s->tlsext_hostname ?
	    s->session->tlsext_hostname :
	    s->tlsext_hostname);
}

int
SSL_get_servername_type(const SSL *s)
{
	if (s->session &&
	    (!s->tlsext_hostname ?
	    s->session->tlsext_hostname : s->tlsext_hostname))
		return (TLSEXT_NAMETYPE_host_name);
	return (-1);
}

/*
 * SSL_select_next_proto implements standard protocol selection. It is
 * expected that this function is called from the callback set by
 * SSL_CTX_set_alpn_select_cb.
 *
 * The protocol data is assumed to be a vector of 8-bit, length prefixed byte
 * strings. The length byte itself is not included in the length. A byte
 * string of length 0 is invalid. No byte string may be truncated.
 *
 * It returns either:
 * OPENSSL_NPN_NEGOTIATED if a common protocol was found, or
 * OPENSSL_NPN_NO_OVERLAP if the fallback case was reached.
 */
int
SSL_select_next_proto(unsigned char **out, unsigned char *outlen,
    const unsigned char *server, unsigned int server_len,
    const unsigned char *client, unsigned int client_len)
{
	unsigned int		 i, j;
	const unsigned char	*result;
	int			 status = OPENSSL_NPN_UNSUPPORTED;

	/*
	 * For each protocol in server preference order,
	 * see if we support it.
	 */
	for (i = 0; i < server_len; ) {
		for (j = 0; j < client_len; ) {
			if (server[i] == client[j] &&
			    memcmp(&server[i + 1],
			    &client[j + 1], server[i]) == 0) {
				/* We found a match */
				result = &server[i];
				status = OPENSSL_NPN_NEGOTIATED;
				goto found;
			}
			j += client[j];
			j++;
		}
		i += server[i];
		i++;
	}

	/* There's no overlap between our protocols and the server's list. */
	result = client;
	status = OPENSSL_NPN_NO_OVERLAP;

found:
	*out = (unsigned char *) result + 1;
	*outlen = result[0];
	return (status);
}

/* SSL_get0_next_proto_negotiated is deprecated. */
void
SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data,
    unsigned *len)
{
	*data = NULL;
	*len = 0;
}

/* SSL_CTX_set_next_protos_advertised_cb is deprecated. */
void
SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *ctx, int (*cb) (SSL *ssl,
    const unsigned char **out, unsigned int *outlen, void *arg), void *arg)
{
}

/* SSL_CTX_set_next_proto_select_cb is deprecated. */
void
SSL_CTX_set_next_proto_select_cb(SSL_CTX *ctx, int (*cb) (SSL *s,
    unsigned char **out, unsigned char *outlen, const unsigned char *in,
    unsigned int inlen, void *arg), void *arg)
{
}

/*
 * SSL_CTX_set_alpn_protos sets the ALPN protocol list to the specified
 * protocols, which must be in wire-format (i.e. a series of non-empty,
 * 8-bit length-prefixed strings). Returns 0 on success.
 */
int
SSL_CTX_set_alpn_protos(SSL_CTX *ctx, const unsigned char *protos,
    unsigned int protos_len)
{
	int failed = 1;

	if (protos == NULL || protos_len == 0)
		goto err;

	free(ctx->internal->alpn_client_proto_list);
	ctx->internal->alpn_client_proto_list = NULL;
	ctx->internal->alpn_client_proto_list_len = 0;

	if ((ctx->internal->alpn_client_proto_list = malloc(protos_len))
	    == NULL)
		goto err;
	ctx->internal->alpn_client_proto_list_len = protos_len;

	memcpy(ctx->internal->alpn_client_proto_list, protos, protos_len);

	failed = 0;

 err:
	/* NOTE: Return values are the reverse of what you expect. */
	return (failed);
}

/*
 * SSL_set_alpn_protos sets the ALPN protocol list to the specified
 * protocols, which must be in wire-format (i.e. a series of non-empty,
 * 8-bit length-prefixed strings). Returns 0 on success.
 */
int
SSL_set_alpn_protos(SSL *ssl, const unsigned char *protos,
    unsigned int protos_len)
{
	int failed = 1;

	if (protos == NULL || protos_len == 0)
		goto err;

	free(ssl->internal->alpn_client_proto_list);
	ssl->internal->alpn_client_proto_list = NULL;
	ssl->internal->alpn_client_proto_list_len = 0;

	if ((ssl->internal->alpn_client_proto_list = malloc(protos_len))
	    == NULL)
		goto err;
	ssl->internal->alpn_client_proto_list_len = protos_len;

	memcpy(ssl->internal->alpn_client_proto_list, protos, protos_len);

	failed = 0;

 err:
	/* NOTE: Return values are the reverse of what you expect. */
	return (failed);
}

/*
 * SSL_CTX_set_alpn_select_cb sets a callback function that is called during
 * ClientHello processing in order to select an ALPN protocol from the
 * client's list of offered protocols.
 */
void
SSL_CTX_set_alpn_select_cb(SSL_CTX* ctx,
    int (*cb) (SSL *ssl, const unsigned char **out, unsigned char *outlen,
    const unsigned char *in, unsigned int inlen, void *arg), void *arg)
{
	ctx->internal->alpn_select_cb = cb;
	ctx->internal->alpn_select_cb_arg = arg;
}

/*
 * SSL_get0_alpn_selected gets the selected ALPN protocol (if any). On return
 * it sets data to point to len bytes of protocol name (not including the
 * leading length-prefix byte). If the server didn't respond with* a negotiated
 * protocol then len will be zero.
 */
void
SSL_get0_alpn_selected(const SSL *ssl, const unsigned char **data,
    unsigned *len)
{
	*data = NULL;
	*len = 0;

	if (ssl->s3 != NULL) {
		*data = ssl->s3->internal->alpn_selected;
		*len = ssl->s3->internal->alpn_selected_len;
	}
}

int
SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,
    const char *label, size_t llen, const unsigned char *p, size_t plen,
    int use_context)
{
	return (tls1_export_keying_material(s, out, olen,
	    label, llen, p, plen, use_context));
}

static unsigned long
ssl_session_hash(const SSL_SESSION *a)
{
	unsigned long	l;

	l = (unsigned long)
	    ((unsigned int) a->session_id[0]     )|
	    ((unsigned int) a->session_id[1]<< 8L)|
	    ((unsigned long)a->session_id[2]<<16L)|
	    ((unsigned long)a->session_id[3]<<24L);
	return (l);
}

/*
 * NB: If this function (or indeed the hash function which uses a sort of
 * coarser function than this one) is changed, ensure
 * SSL_CTX_has_matching_session_id() is checked accordingly. It relies on being
 * able to construct an SSL_SESSION that will collide with any existing session
 * with a matching session ID.
 */
static int
ssl_session_cmp(const SSL_SESSION *a, const SSL_SESSION *b)
{
	if (a->ssl_version != b->ssl_version)
		return (1);
	if (a->session_id_length != b->session_id_length)
		return (1);
	if (timingsafe_memcmp(a->session_id, b->session_id, a->session_id_length) != 0)
		return (1);
	return (0);
}

/*
 * These wrapper functions should remain rather than redeclaring
 * SSL_SESSION_hash and SSL_SESSION_cmp for void* types and casting each
 * variable. The reason is that the functions aren't static, they're exposed via
 * ssl.h.
 */
static unsigned long
ssl_session_LHASH_HASH(const void *arg)
{
	const SSL_SESSION *a = arg;

	return ssl_session_hash(a);
}

static int
ssl_session_LHASH_COMP(const void *arg1, const void *arg2)
{
	const SSL_SESSION *a = arg1;
	const SSL_SESSION *b = arg2;

	return ssl_session_cmp(a, b);
}

SSL_CTX *
SSL_CTX_new(const SSL_METHOD *meth)
{
	SSL_CTX	*ret;

	if (meth == NULL) {
		SSLerrorx(SSL_R_NULL_SSL_METHOD_PASSED);
		return (NULL);
	}

	if ((ret = calloc(1, sizeof(*ret))) == NULL) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}
	if ((ret->internal = calloc(1, sizeof(*ret->internal))) == NULL) {
		free(ret);
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}

	if (SSL_get_ex_data_X509_STORE_CTX_idx() < 0) {
		SSLerrorx(SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);
		goto err;
	}

	ret->method = meth;
	ret->internal->min_version = meth->internal->min_version;
	ret->internal->max_version = meth->internal->max_version;

	ret->cert_store = NULL;
	ret->internal->session_cache_mode = SSL_SESS_CACHE_SERVER;
	ret->internal->session_cache_size = SSL_SESSION_CACHE_MAX_SIZE_DEFAULT;
	ret->internal->session_cache_head = NULL;
	ret->internal->session_cache_tail = NULL;

	/* We take the system default */
	ret->session_timeout = meth->internal->get_timeout();

	ret->internal->new_session_cb = 0;
	ret->internal->remove_session_cb = 0;
	ret->internal->get_session_cb = 0;
	ret->internal->generate_session_id = 0;

	memset((char *)&ret->internal->stats, 0, sizeof(ret->internal->stats));

	ret->references = 1;
	ret->internal->quiet_shutdown = 0;

	ret->internal->info_callback = NULL;

	ret->internal->app_verify_callback = 0;
	ret->internal->app_verify_arg = NULL;

	ret->internal->max_cert_list = SSL_MAX_CERT_LIST_DEFAULT;
	ret->internal->read_ahead = 0;
	ret->internal->msg_callback = 0;
	ret->internal->msg_callback_arg = NULL;
	ret->verify_mode = SSL_VERIFY_NONE;
	ret->sid_ctx_length = 0;
	ret->internal->default_verify_callback = NULL;
	if ((ret->internal->cert = ssl_cert_new()) == NULL)
		goto err;

	ret->default_passwd_callback = 0;
	ret->default_passwd_callback_userdata = NULL;
	ret->internal->client_cert_cb = 0;
	ret->internal->app_gen_cookie_cb = 0;
	ret->internal->app_verify_cookie_cb = 0;

	ret->internal->sessions = lh_SSL_SESSION_new();
	if (ret->internal->sessions == NULL)
		goto err;
	ret->cert_store = X509_STORE_new();
	if (ret->cert_store == NULL)
		goto err;

	ssl_create_cipher_list(ret->method, &ret->cipher_list,
	    &ret->internal->cipher_list_by_id, SSL_DEFAULT_CIPHER_LIST);
	if (ret->cipher_list == NULL ||
	    sk_SSL_CIPHER_num(ret->cipher_list) <= 0) {
		SSLerrorx(SSL_R_LIBRARY_HAS_NO_CIPHERS);
		goto err2;
	}

	ret->param = X509_VERIFY_PARAM_new();
	if (!ret->param)
		goto err;

	if ((ret->internal->client_CA = sk_X509_NAME_new_null()) == NULL)
		goto err;

	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_CTX, ret, &ret->internal->ex_data);

	ret->extra_certs = NULL;

	ret->internal->max_send_fragment = SSL3_RT_MAX_PLAIN_LENGTH;

	ret->internal->tlsext_servername_callback = 0;
	ret->internal->tlsext_servername_arg = NULL;

	/* Setup RFC4507 ticket keys */
	arc4random_buf(ret->internal->tlsext_tick_key_name, 16);
	arc4random_buf(ret->internal->tlsext_tick_hmac_key, 16);
	arc4random_buf(ret->internal->tlsext_tick_aes_key, 16);

	ret->internal->tlsext_status_cb = 0;
	ret->internal->tlsext_status_arg = NULL;

#ifndef OPENSSL_NO_ENGINE
	ret->internal->client_cert_engine = NULL;
#ifdef OPENSSL_SSL_CLIENT_ENGINE_AUTO
#define eng_strx(x)	#x
#define eng_str(x)	eng_strx(x)
	/* Use specific client engine automatically... ignore errors */
	{
		ENGINE *eng;
		eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));
		if (!eng) {
			ERR_clear_error();
			ENGINE_load_builtin_engines();
			eng = ENGINE_by_id(eng_str(
			    OPENSSL_SSL_CLIENT_ENGINE_AUTO));
		}
		if (!eng || !SSL_CTX_set_client_cert_engine(ret, eng))
			ERR_clear_error();
	}
#endif
#endif
	/*
	 * Default is to connect to non-RI servers. When RI is more widely
	 * deployed might change this.
	 */
	ret->internal->options |= SSL_OP_LEGACY_SERVER_CONNECT;

	return (ret);
err:
	SSLerrorx(ERR_R_MALLOC_FAILURE);
err2:
	SSL_CTX_free(ret);
	return (NULL);
}

void
SSL_CTX_free(SSL_CTX *ctx)
{
	int	i;

	if (ctx == NULL)
		return;

	i = CRYPTO_add(&ctx->references, -1, CRYPTO_LOCK_SSL_CTX);
	if (i > 0)
		return;

	X509_VERIFY_PARAM_free(ctx->param);

	/*
	 * Free internal session cache. However: the remove_cb() may reference
	 * the ex_data of SSL_CTX, thus the ex_data store can only be removed
	 * after the sessions were flushed.
	 * As the ex_data handling routines might also touch the session cache,
	 * the most secure solution seems to be: empty (flush) the cache, then
	 * free ex_data, then finally free the cache.
	 * (See ticket [openssl.org #212].)
	 */
	if (ctx->internal->sessions != NULL)
		SSL_CTX_flush_sessions(ctx, 0);

	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_CTX, ctx, &ctx->internal->ex_data);

	lh_SSL_SESSION_free(ctx->internal->sessions);

	X509_STORE_free(ctx->cert_store);
	sk_SSL_CIPHER_free(ctx->cipher_list);
	sk_SSL_CIPHER_free(ctx->internal->cipher_list_by_id);
	ssl_cert_free(ctx->internal->cert);
	sk_X509_NAME_pop_free(ctx->internal->client_CA, X509_NAME_free);
	sk_X509_pop_free(ctx->extra_certs, X509_free);

#ifndef OPENSSL_NO_SRTP
	if (ctx->internal->srtp_profiles)
		sk_SRTP_PROTECTION_PROFILE_free(ctx->internal->srtp_profiles);
#endif

#ifndef OPENSSL_NO_ENGINE
	if (ctx->internal->client_cert_engine)
		ENGINE_finish(ctx->internal->client_cert_engine);
#endif

	free(ctx->internal->tlsext_ecpointformatlist);
	free(ctx->internal->tlsext_supportedgroups);

	free(ctx->internal->alpn_client_proto_list);

	free(ctx->internal);
	free(ctx);
}

void
SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb)
{
	ctx->default_passwd_callback = cb;
}

void
SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx, void *u)
{
	ctx->default_passwd_callback_userdata = u;
}

void
SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(X509_STORE_CTX *,
    void *), void *arg)
{
	ctx->internal->app_verify_callback = cb;
	ctx->internal->app_verify_arg = arg;
}

void
SSL_CTX_set_verify(SSL_CTX *ctx, int mode, int (*cb)(int, X509_STORE_CTX *))
{
	ctx->verify_mode = mode;
	ctx->internal->default_verify_callback = cb;
}

void
SSL_CTX_set_verify_depth(SSL_CTX *ctx, int depth)
{
	X509_VERIFY_PARAM_set_depth(ctx->param, depth);
}

void
ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)
{
	int		 rsa_enc, rsa_sign, dh_tmp;
	int		 have_ecc_cert;
	unsigned long	 mask_k, mask_a;
	X509		*x = NULL;
	CERT_PKEY	*cpk;

	if (c == NULL)
		return;

	dh_tmp = (c->dh_tmp != NULL || c->dh_tmp_cb != NULL ||
	    c->dh_tmp_auto != 0);

	cpk = &(c->pkeys[SSL_PKEY_RSA_ENC]);
	rsa_enc = (cpk->x509 != NULL && cpk->privatekey != NULL);
	cpk = &(c->pkeys[SSL_PKEY_RSA_SIGN]);
	rsa_sign = (cpk->x509 != NULL && cpk->privatekey != NULL);
	cpk = &(c->pkeys[SSL_PKEY_ECC]);
	have_ecc_cert = (cpk->x509 != NULL && cpk->privatekey != NULL);

	mask_k = 0;
	mask_a = 0;

	cpk = &(c->pkeys[SSL_PKEY_GOST01]);
	if (cpk->x509 != NULL && cpk->privatekey !=NULL) {
		mask_k |= SSL_kGOST;
		mask_a |= SSL_aGOST01;
	}

	if (rsa_enc)
		mask_k |= SSL_kRSA;

	if (dh_tmp)
		mask_k |= SSL_kDHE;

	if (rsa_enc || rsa_sign)
		mask_a |= SSL_aRSA;

	mask_a |= SSL_aNULL;

	/*
	 * An ECC certificate may be usable for ECDH and/or
	 * ECDSA cipher suites depending on the key usage extension.
	 */
	if (have_ecc_cert) {
		x = (c->pkeys[SSL_PKEY_ECC]).x509;

		/* This call populates extension flags (ex_flags). */
		X509_check_purpose(x, -1, 0);

		/* Key usage, if present, must allow signing. */
		if ((x->ex_flags & EXFLAG_KUSAGE) == 0 ||
		    (x->ex_kusage & X509v3_KU_DIGITAL_SIGNATURE))
			mask_a |= SSL_aECDSA;
	}

	mask_k |= SSL_kECDHE;

	c->mask_k = mask_k;
	c->mask_a = mask_a;
	c->valid = 1;
}

/* See if this handshake is using an ECC cipher suite. */
int
ssl_using_ecc_cipher(SSL *s)
{
	unsigned long alg_a, alg_k;

	alg_a = S3I(s)->hs.new_cipher->algorithm_auth;
	alg_k = S3I(s)->hs.new_cipher->algorithm_mkey;

	return SSI(s)->tlsext_ecpointformatlist != NULL &&
	    SSI(s)->tlsext_ecpointformatlist_length > 0 &&
	    ((alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA));
}

int
ssl_check_srvr_ecc_cert_and_alg(X509 *x, SSL *s)
{
	const SSL_CIPHER	*cs = S3I(s)->hs.new_cipher;
	unsigned long		 alg_a;

	alg_a = cs->algorithm_auth;

	if (alg_a & SSL_aECDSA) {
		/* This call populates extension flags (ex_flags). */
		X509_check_purpose(x, -1, 0);

		/* Key usage, if present, must allow signing. */
		if ((x->ex_flags & EXFLAG_KUSAGE) &&
		    ((x->ex_kusage & X509v3_KU_DIGITAL_SIGNATURE) == 0)) {
			SSLerror(s, SSL_R_ECC_CERT_NOT_FOR_SIGNING);
			return (0);
		}
	}

	return (1);
}

CERT_PKEY *
ssl_get_server_send_pkey(const SSL *s)
{
	unsigned long	 alg_a;
	CERT		*c;
	int		 i;

	c = s->cert;
	ssl_set_cert_masks(c, S3I(s)->hs.new_cipher);

	alg_a = S3I(s)->hs.new_cipher->algorithm_auth;

	if (alg_a & SSL_aECDSA) {
		i = SSL_PKEY_ECC;
	} else if (alg_a & SSL_aRSA) {
		if (c->pkeys[SSL_PKEY_RSA_ENC].x509 == NULL)
			i = SSL_PKEY_RSA_SIGN;
		else
			i = SSL_PKEY_RSA_ENC;
	} else if (alg_a & SSL_aGOST01) {
		i = SSL_PKEY_GOST01;
	} else { /* if (alg_a & SSL_aNULL) */
		SSLerror(s, ERR_R_INTERNAL_ERROR);
		return (NULL);
	}

	return (c->pkeys + i);
}

X509 *
ssl_get_server_send_cert(const SSL *s)
{
	CERT_PKEY	*cpk;

	cpk = ssl_get_server_send_pkey(s);
	if (!cpk)
		return (NULL);
	return (cpk->x509);
}

EVP_PKEY *
ssl_get_sign_pkey(SSL *s, const SSL_CIPHER *cipher, const EVP_MD **pmd)
{
	unsigned long	 alg_a;
	CERT		*c;
	int		 idx = -1;

	alg_a = cipher->algorithm_auth;
	c = s->cert;

	if (alg_a & SSL_aRSA) {
		if (c->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL)
			idx = SSL_PKEY_RSA_SIGN;
		else if (c->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL)
			idx = SSL_PKEY_RSA_ENC;
	} else if ((alg_a & SSL_aECDSA) &&
	    (c->pkeys[SSL_PKEY_ECC].privatekey != NULL))
		idx = SSL_PKEY_ECC;
	if (idx == -1) {
		SSLerror(s, ERR_R_INTERNAL_ERROR);
		return (NULL);
	}
	if (pmd)
		*pmd = c->pkeys[idx].digest;
	return (c->pkeys[idx].privatekey);
}

DH *
ssl_get_auto_dh(SSL *s)
{
	CERT_PKEY *cpk;
	int keylen;
	DH *dhp;

	if (s->cert->dh_tmp_auto == 2) {
		keylen = 1024;
	} else if (S3I(s)->hs.new_cipher->algorithm_auth & SSL_aNULL) {
		keylen = 1024;
		if (S3I(s)->hs.new_cipher->strength_bits == 256)
			keylen = 3072;
	} else {
		if ((cpk = ssl_get_server_send_pkey(s)) == NULL)
			return (NULL);
		if (cpk->privatekey == NULL || cpk->privatekey->pkey.dh == NULL)
			return (NULL);
		keylen = EVP_PKEY_bits(cpk->privatekey);
	}

	if ((dhp = DH_new()) == NULL)
		return (NULL);

	dhp->g = BN_new();
	if (dhp->g != NULL)
		BN_set_word(dhp->g, 2);

	if (keylen >= 8192)
		dhp->p = get_rfc3526_prime_8192(NULL);
	else if (keylen >= 4096)
		dhp->p = get_rfc3526_prime_4096(NULL);
	else if (keylen >= 3072)
		dhp->p = get_rfc3526_prime_3072(NULL);
	else if (keylen >= 2048)
		dhp->p = get_rfc3526_prime_2048(NULL);
	else if (keylen >= 1536)
		dhp->p = get_rfc3526_prime_1536(NULL);
	else
		dhp->p = get_rfc2409_prime_1024(NULL);

	if (dhp->p == NULL || dhp->g == NULL) {
		DH_free(dhp);
		return (NULL);
	}
	return (dhp);
}

void
ssl_update_cache(SSL *s, int mode)
{
	int	i;

	/*
	 * If the session_id_length is 0, we are not supposed to cache it,
	 * and it would be rather hard to do anyway :-)
	 */
	if (s->session->session_id_length == 0)
		return;

	i = s->session_ctx->internal->session_cache_mode;
	if ((i & mode) && (!s->internal->hit) && ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE)
	    || SSL_CTX_add_session(s->session_ctx, s->session))
	    && (s->session_ctx->internal->new_session_cb != NULL)) {
		CRYPTO_add(&s->session->references, 1, CRYPTO_LOCK_SSL_SESSION);
		if (!s->session_ctx->internal->new_session_cb(s, s->session))
			SSL_SESSION_free(s->session);
	}

	/* auto flush every 255 connections */
	if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) &&
	    ((i & mode) == mode)) {
		if ((((mode & SSL_SESS_CACHE_CLIENT) ?
		    s->session_ctx->internal->stats.sess_connect_good :
		    s->session_ctx->internal->stats.sess_accept_good) & 0xff) == 0xff) {
			SSL_CTX_flush_sessions(s->session_ctx, time(NULL));
		}
	}
}

const SSL_METHOD *
SSL_get_ssl_method(SSL *s)
{
	return (s->method);
}

int
SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
	int	conn = -1;
	int	ret = 1;

	if (s->method != meth) {
		if (s->internal->handshake_func != NULL)
			conn = (s->internal->handshake_func == s->method->internal->ssl_connect);

		if (s->method->internal->version == meth->internal->version)
			s->method = meth;
		else {
			s->method->internal->ssl_free(s);
			s->method = meth;
			ret = s->method->internal->ssl_new(s);
		}

		if (conn == 1)
			s->internal->handshake_func = meth->internal->ssl_connect;
		else if (conn == 0)
			s->internal->handshake_func = meth->internal->ssl_accept;
	}
	return (ret);
}

int
SSL_get_error(const SSL *s, int i)
{
	int		 reason;
	unsigned long	 l;
	BIO		*bio;

	if (i > 0)
		return (SSL_ERROR_NONE);

	/* Make things return SSL_ERROR_SYSCALL when doing SSL_do_handshake
	 * etc, where we do encode the error */
	if ((l = ERR_peek_error()) != 0) {
		if (ERR_GET_LIB(l) == ERR_LIB_SYS)
			return (SSL_ERROR_SYSCALL);
		else
			return (SSL_ERROR_SSL);
	}

	if ((i < 0) && SSL_want_read(s)) {
		bio = SSL_get_rbio(s);
		if (BIO_should_read(bio)) {
			return (SSL_ERROR_WANT_READ);
		} else if (BIO_should_write(bio)) {
			/*
			 * This one doesn't make too much sense...  We never
			 * try to write to the rbio, and an application
			 * program where rbio and wbio are separate couldn't
			 * even know what it should wait for.  However if we
			 * ever set s->internal->rwstate incorrectly (so that we have
			 * SSL_want_read(s) instead of SSL_want_write(s))
			 * and rbio and wbio *are* the same, this test works
			 * around that bug; so it might be safer to keep it.
			 */
			return (SSL_ERROR_WANT_WRITE);
		} else if (BIO_should_io_special(bio)) {
			reason = BIO_get_retry_reason(bio);
			if (reason == BIO_RR_CONNECT)
				return (SSL_ERROR_WANT_CONNECT);
			else if (reason == BIO_RR_ACCEPT)
				return (SSL_ERROR_WANT_ACCEPT);
			else
				return (SSL_ERROR_SYSCALL); /* unknown */
		}
	}

	if ((i < 0) && SSL_want_write(s)) {
		bio = SSL_get_wbio(s);
		if (BIO_should_write(bio)) {
			return (SSL_ERROR_WANT_WRITE);
		} else if (BIO_should_read(bio)) {
			/*
			 * See above (SSL_want_read(s) with
			 * BIO_should_write(bio))
			 */
			return (SSL_ERROR_WANT_READ);
		} else if (BIO_should_io_special(bio)) {
			reason = BIO_get_retry_reason(bio);
			if (reason == BIO_RR_CONNECT)
				return (SSL_ERROR_WANT_CONNECT);
			else if (reason == BIO_RR_ACCEPT)
				return (SSL_ERROR_WANT_ACCEPT);
			else
				return (SSL_ERROR_SYSCALL);
		}
	}
	if ((i < 0) && SSL_want_x509_lookup(s)) {
		return (SSL_ERROR_WANT_X509_LOOKUP);
	}

	if (i == 0) {
		if ((s->internal->shutdown & SSL_RECEIVED_SHUTDOWN) &&
		    (S3I(s)->warn_alert == SSL_AD_CLOSE_NOTIFY))
		return (SSL_ERROR_ZERO_RETURN);
	}
	return (SSL_ERROR_SYSCALL);
}

int
SSL_do_handshake(SSL *s)
{
	int	ret = 1;

	if (s->internal->handshake_func == NULL) {
		SSLerror(s, SSL_R_CONNECTION_TYPE_NOT_SET);
		return (-1);
	}

	s->method->internal->ssl_renegotiate_check(s);

	if (SSL_in_init(s) || SSL_in_before(s)) {
		ret = s->internal->handshake_func(s);
	}
	return (ret);
}

/*
 * For the next 2 functions, SSL_clear() sets shutdown and so
 * one of these calls will reset it
 */
void
SSL_set_accept_state(SSL *s)
{
	s->server = 1;
	s->internal->shutdown = 0;
	S3I(s)->hs.state = SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->internal->handshake_func = s->method->internal->ssl_accept;
	/* clear the current cipher */
	ssl_clear_cipher_ctx(s);
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->internal->write_hash);
}

void
SSL_set_connect_state(SSL *s)
{
	s->server = 0;
	s->internal->shutdown = 0;
	S3I(s)->hs.state = SSL_ST_CONNECT|SSL_ST_BEFORE;
	s->internal->handshake_func = s->method->internal->ssl_connect;
	/* clear the current cipher */
	ssl_clear_cipher_ctx(s);
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->internal->write_hash);
}

int
ssl_undefined_function(SSL *s)
{
	SSLerror(s, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return (0);
}

int
ssl_undefined_void_function(void)
{
	SSLerrorx(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return (0);
}

int
ssl_undefined_const_function(const SSL *s)
{
	SSLerror(s, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return (0);
}

const char *
ssl_version_string(int ver)
{
	switch (ver) {
	case DTLS1_VERSION:
		return (SSL_TXT_DTLS1);
	case TLS1_VERSION:
		return (SSL_TXT_TLSV1);
	case TLS1_1_VERSION:
		return (SSL_TXT_TLSV1_1);
	case TLS1_2_VERSION:
		return (SSL_TXT_TLSV1_2);
	default:
		return ("unknown");
	}
}

const char *
SSL_get_version(const SSL *s)
{
	return ssl_version_string(s->version);
}

SSL *
SSL_dup(SSL *s)
{
	STACK_OF(X509_NAME) *sk;
	X509_NAME *xn;
	SSL *ret;
	int i;

	if ((ret = SSL_new(SSL_get_SSL_CTX(s))) == NULL)
		return (NULL);

	ret->version = s->version;
	ret->internal->type = s->internal->type;
	ret->method = s->method;

	if (s->session != NULL) {
		/* This copies session-id, SSL_METHOD, sid_ctx, and 'cert' */
		SSL_copy_session_id(ret, s);
	} else {
		/*
		 * No session has been established yet, so we have to expect
		 * that s->cert or ret->cert will be changed later --
		 * they should not both point to the same object,
		 * and thus we can't use SSL_copy_session_id.
		 */

		ret->method->internal->ssl_free(ret);
		ret->method = s->method;
		ret->method->internal->ssl_new(ret);

		if (s->cert != NULL) {
			ssl_cert_free(ret->cert);
			ret->cert = ssl_cert_dup(s->cert);
			if (ret->cert == NULL)
				goto err;
		}

		SSL_set_session_id_context(ret,
		s->sid_ctx, s->sid_ctx_length);
	}

	ret->internal->options = s->internal->options;
	ret->internal->mode = s->internal->mode;
	SSL_set_max_cert_list(ret, SSL_get_max_cert_list(s));
	SSL_set_read_ahead(ret, SSL_get_read_ahead(s));
	ret->internal->msg_callback = s->internal->msg_callback;
	ret->internal->msg_callback_arg = s->internal->msg_callback_arg;
	SSL_set_verify(ret, SSL_get_verify_mode(s),
	SSL_get_verify_callback(s));
	SSL_set_verify_depth(ret, SSL_get_verify_depth(s));
	ret->internal->generate_session_id = s->internal->generate_session_id;

	SSL_set_info_callback(ret, SSL_get_info_callback(s));

	ret->internal->debug = s->internal->debug;

	/* copy app data, a little dangerous perhaps */
	if (!CRYPTO_dup_ex_data(CRYPTO_EX_INDEX_SSL,
	    &ret->internal->ex_data, &s->internal->ex_data))
		goto err;

	/* setup rbio, and wbio */
	if (s->rbio != NULL) {
		if (!BIO_dup_state(s->rbio,(char *)&ret->rbio))
			goto err;
	}
	if (s->wbio != NULL) {
		if (s->wbio != s->rbio) {
			if (!BIO_dup_state(s->wbio,(char *)&ret->wbio))
				goto err;
		} else
			ret->wbio = ret->rbio;
	}
	ret->internal->rwstate = s->internal->rwstate;
	ret->internal->in_handshake = s->internal->in_handshake;
	ret->internal->handshake_func = s->internal->handshake_func;
	ret->server = s->server;
	ret->internal->renegotiate = s->internal->renegotiate;
	ret->internal->new_session = s->internal->new_session;
	ret->internal->quiet_shutdown = s->internal->quiet_shutdown;
	ret->internal->shutdown = s->internal->shutdown;
	/* SSL_dup does not really work at any state, though */
	S3I(ret)->hs.state = S3I(s)->hs.state;
	ret->internal->rstate = s->internal->rstate;

	/*
	 * Would have to copy ret->init_buf, ret->init_msg, ret->init_num,
	 * ret->init_off
	 */
	ret->internal->init_num = 0;

	ret->internal->hit = s->internal->hit;

	X509_VERIFY_PARAM_inherit(ret->param, s->param);

	/* dup the cipher_list and cipher_list_by_id stacks */
	if (s->cipher_list != NULL) {
		if ((ret->cipher_list =
		    sk_SSL_CIPHER_dup(s->cipher_list)) == NULL)
			goto err;
	}
	if (s->internal->cipher_list_by_id != NULL) {
		if ((ret->internal->cipher_list_by_id =
		    sk_SSL_CIPHER_dup(s->internal->cipher_list_by_id)) == NULL)
			goto err;
	}

	/* Dup the client_CA list */
	if (s->internal->client_CA != NULL) {
		if ((sk = sk_X509_NAME_dup(s->internal->client_CA)) == NULL) goto err;
			ret->internal->client_CA = sk;
		for (i = 0; i < sk_X509_NAME_num(sk); i++) {
			xn = sk_X509_NAME_value(sk, i);
			if (sk_X509_NAME_set(sk, i,
			    X509_NAME_dup(xn)) == NULL) {
				X509_NAME_free(xn);
				goto err;
			}
		}
	}

	if (0) {
err:
		if (ret != NULL)
			SSL_free(ret);
		ret = NULL;
	}
	return (ret);
}

void
ssl_clear_cipher_ctx(SSL *s)
{
	EVP_CIPHER_CTX_free(s->enc_read_ctx);
	s->enc_read_ctx = NULL;
	EVP_CIPHER_CTX_free(s->internal->enc_write_ctx);
	s->internal->enc_write_ctx = NULL;

	if (s->internal->aead_read_ctx != NULL) {
		EVP_AEAD_CTX_cleanup(&s->internal->aead_read_ctx->ctx);
		free(s->internal->aead_read_ctx);
		s->internal->aead_read_ctx = NULL;
	}
	if (s->internal->aead_write_ctx != NULL) {
		EVP_AEAD_CTX_cleanup(&s->internal->aead_write_ctx->ctx);
		free(s->internal->aead_write_ctx);
		s->internal->aead_write_ctx = NULL;
	}

}

/* Fix this function so that it takes an optional type parameter */
X509 *
SSL_get_certificate(const SSL *s)
{
	if (s->cert != NULL)
		return (s->cert->key->x509);
	else
		return (NULL);
}

/* Fix this function so that it takes an optional type parameter */
EVP_PKEY *
SSL_get_privatekey(SSL *s)
{
	if (s->cert != NULL)
		return (s->cert->key->privatekey);
	else
		return (NULL);
}

const SSL_CIPHER *
SSL_get_current_cipher(const SSL *s)
{
	if ((s->session != NULL) && (s->session->cipher != NULL))
		return (s->session->cipher);
	return (NULL);
}
const void *
SSL_get_current_compression(SSL *s)
{
	return (NULL);
}

const void *
SSL_get_current_expansion(SSL *s)
{
	return (NULL);
}

int
ssl_init_wbio_buffer(SSL *s, int push)
{
	BIO	*bbio;

	if (s->bbio == NULL) {
		bbio = BIO_new(BIO_f_buffer());
		if (bbio == NULL)
			return (0);
		s->bbio = bbio;
	} else {
		bbio = s->bbio;
		if (s->bbio == s->wbio)
			s->wbio = BIO_pop(s->wbio);
	}
	(void)BIO_reset(bbio);
/*	if (!BIO_set_write_buffer_size(bbio,16*1024)) */
	if (!BIO_set_read_buffer_size(bbio, 1)) {
		SSLerror(s, ERR_R_BUF_LIB);
		return (0);
	}
	if (push) {
		if (s->wbio != bbio)
			s->wbio = BIO_push(bbio, s->wbio);
	} else {
		if (s->wbio == bbio)
			s->wbio = BIO_pop(bbio);
	}
	return (1);
}

void
ssl_free_wbio_buffer(SSL *s)
{
	if (s == NULL)
		return;

	if (s->bbio == NULL)
		return;

	if (s->bbio == s->wbio) {
		/* remove buffering */
		s->wbio = BIO_pop(s->wbio);
	}
	BIO_free(s->bbio);
	s->bbio = NULL;
}

void
SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx, int mode)
{
	ctx->internal->quiet_shutdown = mode;
}

int
SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx)
{
	return (ctx->internal->quiet_shutdown);
}

void
SSL_set_quiet_shutdown(SSL *s, int mode)
{
	s->internal->quiet_shutdown = mode;
}

int
SSL_get_quiet_shutdown(const SSL *s)
{
	return (s->internal->quiet_shutdown);
}

void
SSL_set_shutdown(SSL *s, int mode)
{
	s->internal->shutdown = mode;
}

int
SSL_get_shutdown(const SSL *s)
{
	return (s->internal->shutdown);
}

int
SSL_version(const SSL *s)
{
	return (s->version);
}

SSL_CTX *
SSL_get_SSL_CTX(const SSL *ssl)
{
	return (ssl->ctx);
}

SSL_CTX *
SSL_set_SSL_CTX(SSL *ssl, SSL_CTX* ctx)
{
	CERT *ocert = ssl->cert;

	if (ssl->ctx == ctx)
		return (ssl->ctx);
	if (ctx == NULL)
		ctx = ssl->initial_ctx;
	ssl->cert = ssl_cert_dup(ctx->internal->cert);
	if (ocert != NULL) {
		int i;
		/* Copy negotiated digests from original certificate. */
		for (i = 0; i < SSL_PKEY_NUM; i++)
			ssl->cert->pkeys[i].digest = ocert->pkeys[i].digest;
		ssl_cert_free(ocert);
	}
	CRYPTO_add(&ctx->references, 1, CRYPTO_LOCK_SSL_CTX);
	SSL_CTX_free(ssl->ctx); /* decrement reference count */
	ssl->ctx = ctx;
	return (ssl->ctx);
}

int
SSL_CTX_set_default_verify_paths(SSL_CTX *ctx)
{
	return (X509_STORE_set_default_paths(ctx->cert_store));
}

int
SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,
    const char *CApath)
{
	return (X509_STORE_load_locations(ctx->cert_store, CAfile, CApath));
}

int
SSL_CTX_load_verify_mem(SSL_CTX *ctx, void *buf, int len)
{
	return (X509_STORE_load_mem(ctx->cert_store, buf, len));
}

void
SSL_set_info_callback(SSL *ssl, void (*cb)(const SSL *ssl, int type, int val))
{
	ssl->internal->info_callback = cb;
}

void (*SSL_get_info_callback(const SSL *ssl))(const SSL *ssl, int type, int val)
{
	return (ssl->internal->info_callback);
}

int
SSL_state(const SSL *ssl)
{
	return (S3I(ssl)->hs.state);
}

void
SSL_set_state(SSL *ssl, int state)
{
	S3I(ssl)->hs.state = state;
}

void
SSL_set_verify_result(SSL *ssl, long arg)
{
	ssl->verify_result = arg;
}

long
SSL_get_verify_result(const SSL *ssl)
{
	return (ssl->verify_result);
}

int
SSL_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
	return (CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, argl, argp,
	    new_func, dup_func, free_func));
}

int
SSL_set_ex_data(SSL *s, int idx, void *arg)
{
	return (CRYPTO_set_ex_data(&s->internal->ex_data, idx, arg));
}

void *
SSL_get_ex_data(const SSL *s, int idx)
{
	return (CRYPTO_get_ex_data(&s->internal->ex_data, idx));
}

int
SSL_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
	return (CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, argl, argp,
	    new_func, dup_func, free_func));
}

int
SSL_CTX_set_ex_data(SSL_CTX *s, int idx, void *arg)
{
	return (CRYPTO_set_ex_data(&s->internal->ex_data, idx, arg));
}

void *
SSL_CTX_get_ex_data(const SSL_CTX *s, int idx)
{
	return (CRYPTO_get_ex_data(&s->internal->ex_data, idx));
}

int
ssl_ok(SSL *s)
{
	return (1);
}

X509_STORE *
SSL_CTX_get_cert_store(const SSL_CTX *ctx)
{
	return (ctx->cert_store);
}

void
SSL_CTX_set_cert_store(SSL_CTX *ctx, X509_STORE *store)
{
	X509_STORE_free(ctx->cert_store);
	ctx->cert_store = store;
}

int
SSL_want(const SSL *s)
{
	return (s->internal->rwstate);
}

void
SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx, RSA *(*cb)(SSL *ssl, int is_export,
    int keylength))
{
	SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_TMP_RSA_CB,(void (*)(void))cb);
}

void
SSL_set_tmp_rsa_callback(SSL *ssl, RSA *(*cb)(SSL *ssl, int is_export,
    int keylength))
{
	SSL_callback_ctrl(ssl, SSL_CTRL_SET_TMP_RSA_CB,(void (*)(void))cb);
}

void
SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx, DH *(*dh)(SSL *ssl, int is_export,
    int keylength))
{
	SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_TMP_DH_CB,(void (*)(void))dh);
}

void
SSL_set_tmp_dh_callback(SSL *ssl, DH *(*dh)(SSL *ssl, int is_export,
    int keylength))
{
	SSL_callback_ctrl(ssl, SSL_CTRL_SET_TMP_DH_CB,(void (*)(void))dh);
}

void
SSL_CTX_set_tmp_ecdh_callback(SSL_CTX *ctx, EC_KEY *(*ecdh)(SSL *ssl,
    int is_export, int keylength))
{
	SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_TMP_ECDH_CB,
	    (void (*)(void))ecdh);
}

void
SSL_set_tmp_ecdh_callback(SSL *ssl, EC_KEY *(*ecdh)(SSL *ssl, int is_export,
    int keylength))
{
	SSL_callback_ctrl(ssl, SSL_CTRL_SET_TMP_ECDH_CB,(void (*)(void))ecdh);
}


void
SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version,
    int content_type, const void *buf, size_t len, SSL *ssl, void *arg))
{
	SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK,
	    (void (*)(void))cb);
}

void
SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version,
    int content_type, const void *buf, size_t len, SSL *ssl, void *arg))
{
	SSL_callback_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK, (void (*)(void))cb);
}

void
ssl_clear_hash_ctx(EVP_MD_CTX **hash)
{
	if (*hash)
		EVP_MD_CTX_destroy(*hash);
	*hash = NULL;
}

void
SSL_set_debug(SSL *s, int debug)
{
	s->internal->debug = debug;
}

int
SSL_cache_hit(SSL *s)
{
	return (s->internal->hit);
}

int
SSL_CTX_set_min_proto_version(SSL_CTX *ctx, uint16_t version)
{
	return ssl_version_set_min(ctx->method, version,
	    ctx->internal->max_version, &ctx->internal->min_version);
}

int
SSL_CTX_set_max_proto_version(SSL_CTX *ctx, uint16_t version)
{
	return ssl_version_set_max(ctx->method, version,
	    ctx->internal->min_version, &ctx->internal->max_version);
}

int
SSL_set_min_proto_version(SSL *ssl, uint16_t version)
{
	return ssl_version_set_min(ssl->method, version,
	    ssl->internal->max_version, &ssl->internal->min_version);
}

int
SSL_set_max_proto_version(SSL *ssl, uint16_t version)
{
	return ssl_version_set_max(ssl->method, version,
	    ssl->internal->min_version, &ssl->internal->max_version);
}

static int
ssl_cipher_id_cmp_BSEARCH_CMP_FN(const void *a_, const void *b_)
{
	SSL_CIPHER const *a = a_;
	SSL_CIPHER const *b = b_;
	return ssl_cipher_id_cmp(a, b);
}

SSL_CIPHER *
OBJ_bsearch_ssl_cipher_id(SSL_CIPHER *key, SSL_CIPHER const *base, int num)
{
	return (SSL_CIPHER *)OBJ_bsearch_(key, base, num, sizeof(SSL_CIPHER),
	    ssl_cipher_id_cmp_BSEARCH_CMP_FN);
}
@


1.169
log
@Completely remove NPN remnants.

Based on a diff from doug@@, similar diff from inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.168 2017/08/13 17:04:36 doug Exp $ */
d1591 24
@


1.168
log
@Make SSL{,_CTX}_set_alpn_protos() do atomic updates and handle NULL.

Previously, the code would accept NULL and 0 length and try to
malloc/memcpy it.  On OpenBSD, malloc(0) does not return NULL.  It could
also fail in malloc and leave the old length.

Also, add a note that this public API has backwards semantics of what you
would expect where 0 is success and 1 is failure.

input + ok jsing@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.167 2017/08/12 21:03:08 jsing Exp $ */
a1590 24
}

/* SSL_get0_next_proto_negotiated is deprecated. */
void
SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data,
    unsigned *len)
{
	*data = NULL;
	*len = 0;
}

/* SSL_CTX_set_next_protos_advertised_cb is deprecated. */
void
SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *ctx, int (*cb) (SSL *ssl,
    const unsigned char **out, unsigned int *outlen, void *arg), void *arg)
{
}

/* SSL_CTX_set_next_proto_select_cb is deprecated. */
void
SSL_CTX_set_next_proto_select_cb(SSL_CTX *ctx, int (*cb) (SSL *s,
    unsigned char **out, unsigned char *outlen, const unsigned char *in,
    unsigned int inlen, void *arg), void *arg)
{
@


1.167
log
@Remove NPN support.

NPN was never standardised and the last draft expired in October 2012.
ALPN was standardised in July 2014 and has been supported in LibreSSL
since December 2014. NPN has also been removed from Chromium in May 2016.

TLS clients and servers that try to use/enable NPN will fail gracefully and
fallback to the default protocol, since it will essentially appear that the
otherside does not support NPN. At some point in the future we will
actually remove the NPN related symbols entirely.

ok bcook@@ beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.166 2017/08/12 02:55:22 jsing Exp $ */
d1626 5
d1632 8
a1639 2
	if ((ctx->internal->alpn_client_proto_list = malloc(protos_len)) == NULL)
		return (1);
a1640 1
	ctx->internal->alpn_client_proto_list_len = protos_len;
d1642 5
a1646 1
	return (0);
d1655 1
a1655 1
SSL_set_alpn_protos(SSL *ssl, const unsigned char* protos,
d1658 5
d1664 8
a1671 2
	if ((ssl->internal->alpn_client_proto_list = malloc(protos_len)) == NULL)
		return (1);
a1672 1
	ssl->internal->alpn_client_proto_list_len = protos_len;
d1674 5
a1678 1
	return (0);
@


1.166
log
@Remove support for DSS/DSA, since we removed the cipher suites a while
back.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.165 2017/08/11 21:06:52 jsing Exp $ */
a341 2
	s->internal->next_proto_negotiated = NULL;

a548 1
	free(s->internal->next_proto_negotiated);
d1541 1
a1541 1
 * SSL_select_next_proto implements the standard protocol selection. It is
d1543 1
a1543 1
 * SSL_CTX_set_next_proto_select_cb.
d1549 1
a1549 19
 * The current, but experimental algorithm for selecting the protocol is:
 *
 * 1) If the server doesn't support NPN then this is indicated to the
 * callback. In this case, the client application has to abort the connection
 * or have a default application level protocol.
 *
 * 2) If the server supports NPN, but advertises an empty list then the
 * client selects the first protcol in its list, but indicates via the
 * API that this fallback case was enacted.
 *
 * 3) Otherwise, the client finds the first protocol in the server's list
 * that it supports and selects this protocol. This is because it's
 * assumed that the server has better information about which protocol
 * a client should use.
 *
 * 4) If the client doesn't support any of the server's advertised
 * protocols, then this is treated the same as case 2.
 *
 * It returns either
d1593 1
a1593 9
/*
 * SSL_get0_next_proto_negotiated sets *data and *len to point to the client's
 * requested protocol for this connection and returns 0. If the client didn't
 * request any protocol, then *data is set to NULL.
 *
 * Note that the client can request any protocol it chooses. The value returned
 * from this function need not be a member of the list of supported protocols
 * provided by the callback.
 */
d1598 2
a1599 6
	*data = s->internal->next_proto_negotiated;
	if (!*data) {
		*len = 0;
	} else {
		*len = s->internal->next_proto_negotiated_len;
	}
d1602 1
a1602 11
/*
 * SSL_CTX_set_next_protos_advertised_cb sets a callback that is called when a
 * TLS server needs a list of supported protocols for Next Protocol
 * Negotiation. The returned list must be in wire format.  The list is returned
 * by setting |out| to point to it and |outlen| to its length. This memory will
 * not be modified, but one should assume that the SSL* keeps a reference to
 * it.
 *
 * The callback should return SSL_TLSEXT_ERR_OK if it wishes to advertise.
 * Otherwise, no such extension will be included in the ServerHello.
 */
a1606 2
	ctx->internal->next_protos_advertised_cb = cb;
	ctx->internal->next_protos_advertised_cb_arg = arg;
d1609 1
a1609 11
/*
 * SSL_CTX_set_next_proto_select_cb sets a callback that is called when a
 * client needs to select a protocol from the server's provided list. |out|
 * must be set to point to the selected protocol (which may be within |in|).
 * The length of the protocol name must be written into |outlen|. The server's
 * advertised protocols are provided in |in| and |inlen|. The callback can
 * assume that |in| is syntactically valid.
 *
 * The client must select a protocol. It is fatal to the connection if this
 * callback returns a value other than SSL_TLSEXT_ERR_OK.
 */
a1614 2
	ctx->internal->next_proto_select_cb = cb;
	ctx->internal->next_proto_select_cb_arg = arg;
a1856 3

	ret->internal->next_protos_advertised_cb = 0;
	ret->internal->next_proto_select_cb = 0;
@


1.165
log
@I don't think eay will ever fix this...
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.164 2017/08/11 21:06:17 jsing Exp $ */
d2044 1
a2044 1
	int		 rsa_enc, rsa_sign, dh_tmp, dsa_sign;
a2059 2
	cpk = &(c->pkeys[SSL_PKEY_DSA_SIGN]);
	dsa_sign = (cpk->x509 != NULL && cpk->privatekey != NULL);
a2080 3
	if (dsa_sign)
		mask_a |= SSL_aDSS;

a2156 2
	} else if (alg_a & SSL_aDSS) {
		i = SSL_PKEY_DSA_SIGN;
d2193 1
a2193 4
	if ((alg_a & SSL_aDSS) &&
	    (c->pkeys[SSL_PKEY_DSA_SIGN].privatekey != NULL))
		idx = SSL_PKEY_DSA_SIGN;
	else if (alg_a & SSL_aRSA) {
@


1.164
log
@style(9) in ssl_set_cert_masks().
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.163 2017/08/10 17:18:38 jsing Exp $ */
a2061 1
/* FIX THIS EAY EAY EAY */
d2064 1
@


1.163
log
@Clean up the EC key/curve configuration handling.

Over the years OpenSSL grew multiple ways of being able to specify EC keys
(and/or curves) for use with ECDH and ECDHE key exchange. You could specify
a static EC key (SSL{_CTX,}_set_tmp_ecdh()), use that as a curve and
generate ephemeral keys (SSL_OP_SINGLE_ECDH_USE), provide the EC key via
a callback that was provided with insufficient information
(SSL{_CTX,}_set_tmp_ecdh_cb()) or enable automatic selection and generation
of EC keys via SSL{_CTX,}_set_ecdh_auto(). This complexity leads to
problems (like ECDHE not being enabled) and potential weird configuration
(like being able to do ECDHE without the ephemeral part...).

We no longer support ECDH and ECDHE can be disabled by removing ECDHE
ciphers from the cipher list. As such, permanently enable automatic EC
curve selection and generation, effectively disabling all of the
configuration knobs. The only exception is the
SSL{_CTX,}_set_tmp_ecdh() functions, which retain part of their previous
behaviour by configuring the curve of the given EC key as the only curve
being enabled. Everything else becomes a no-op.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.162 2017/08/09 22:24:25 jsing Exp $ */
d2075 1
a2075 1
		mask_k|=SSL_kRSA;
d2078 1
a2078 1
		mask_k|=SSL_kDHE;
d2081 1
a2081 1
		mask_a|=SSL_aRSA;
d2084 1
a2084 1
		mask_a|=SSL_aDSS;
d2086 1
a2086 1
	mask_a|=SSL_aNULL;
d2101 1
a2101 1
			mask_a|=SSL_aECDSA;
@


1.162
log
@Pull out the code that identifies if we have an ECC cipher in the cipher
list or if we are negotiating an ECC cipher in the handshake. This dedups
some of the existing code and will make the EC extension rewrites easier.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.161 2017/05/07 04:22:24 beck Exp $ */
d2045 1
a2045 1
	int		 have_ecc_cert, have_ecdh_tmp;
a2055 3
	have_ecdh_tmp = (c->ecdh_tmp != NULL || c->ecdh_tmp_cb != NULL ||
	    c->ecdh_tmp_auto != 0);

d2104 1
a2104 2
	if (have_ecdh_tmp)
		mask_k|=SSL_kECDHE;
@


1.161
log
@Move state from ssl->internal to the handshake structure.
while we are at it, convert SSLerror to use a function
internally, so that we may later allocate the handshake
structure and check for it
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.160 2017/05/06 22:24:57 beck Exp $ */
d1262 27
d2113 14
@


1.160
log
@Bring in an SSL_HANDSHAKE structure and commence the great shovelling
ok jsing@@, gcc@@, regress@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.159 2017/05/06 20:37:25 jsing Exp $ */
a185 2
	s->internal->state = SSL_ST_BEFORE|((s->server) ? SSL_ST_ACCEPT : SSL_ST_CONNECT);

d213 2
d2400 1
a2400 1
	s->internal->state = SSL_ST_ACCEPT|SSL_ST_BEFORE;
d2413 1
a2413 1
	s->internal->state = SSL_ST_CONNECT|SSL_ST_BEFORE;
d2547 1
a2547 1
	ret->internal->state = s->internal->state;
d2807 1
a2807 1
	return (ssl->internal->state);
d2813 1
a2813 1
	ssl->internal->state = state;
@


1.159
log
@Provide SSL{,_CTX}_set_{min,max}_proto_version() functions.

Rides minor bump.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.158 2017/02/28 14:08:49 jsing Exp $ */
d2091 1
a2091 1
	const SSL_CIPHER	*cs = S3I(s)->tmp.new_cipher;
d2119 1
a2119 1
	ssl_set_cert_masks(c, S3I(s)->tmp.new_cipher);
d2121 1
a2121 1
	alg_a = S3I(s)->tmp.new_cipher->algorithm_auth;
d2192 1
a2192 1
	} else if (S3I(s)->tmp.new_cipher->algorithm_auth & SSL_aNULL) {
d2194 1
a2194 1
		if (S3I(s)->tmp.new_cipher->strength_bits == 256)
@


1.158
log
@Stop pretending that MD5 and SHA1 might not exist - rather than locating
"ssl3-md5" and "ssl-sha1", call the EVP_md5() and EVP_sha1() functions
directly.

ok beck@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.157 2017/02/15 14:56:42 jsing Exp $ */
d2972 27
@


1.157
log
@Avoid dereferencing a pointer when reporting an error about the same
pointer being NULL.

Found by jsg@@ with cppcheck; also detected by Coverity.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.156 2017/02/07 02:08:38 beck Exp $ */
a1866 9

	if ((ret->internal->md5 = EVP_get_digestbyname("ssl3-md5")) == NULL) {
		SSLerrorx(SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES);
		goto err2;
	}
	if ((ret->internal->sha1 = EVP_get_digestbyname("ssl3-sha1")) == NULL) {
		SSLerrorx(SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES);
		goto err2;
	}
@


1.156
log
@Change SSLerror() back to taking two args, with the first one being an SSL *.
Make a table of "function codes" which maps the internal state of the SSL *
to something like a useful name so in a typical error in the connection you
know in what sort of place in the handshake things happened. (instead of
by arcane function name).
Add SSLerrorx() for when we don't have an SSL *
ok jsing@@ after us both being prodded by bluhm@@ to make it not terrible
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.155 2017/01/26 12:16:13 beck Exp $ */
d889 1
a889 1
		SSLerror(ssl, ERR_R_PASSED_NULL_PARAMETER);
@


1.155
log
@Finish the fallout of the SSLerr->SSLerror cleanup to get rid of the ugly
line wraps that resulted
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.154 2017/01/26 10:40:21 beck Exp $ */
d166 1
a166 1
		SSLerror(SSL_R_NO_METHOD_SPECIFIED);
d180 1
a180 1
		SSLerror(ERR_R_INTERNAL_ERROR);
d229 1
a229 1
		SSLerror(SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS);
d241 1
a241 1
		SSLerror(SSL_R_NULL_SSL_CTX);
d245 1
a245 1
		SSLerror(SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);
d250 1
a250 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d255 1
a255 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d374 1
a374 1
	SSLerror(ERR_R_MALLOC_FAILURE);
d383 1
a383 1
		SSLerror(SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
d397 1
a397 1
		SSLerror(SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
d634 1
a634 1
		SSLerror(ERR_R_BUF_LIB);
d655 1
a655 1
			SSLerror(ERR_R_BUF_LIB);
d678 1
a678 1
			SSLerror(ERR_R_BUF_LIB);
d873 1
a873 1
		SSLerror(SSL_R_NO_CERTIFICATE_ASSIGNED);
d877 1
a877 1
		SSLerror(SSL_R_NO_PRIVATE_KEY_ASSIGNED);
d889 1
a889 1
		SSLerror(ERR_R_PASSED_NULL_PARAMETER);
d893 1
a893 1
		SSLerror(SSL_R_NO_CERTIFICATE_ASSIGNED);
d897 1
a897 1
		SSLerror(SSL_R_NO_CERTIFICATE_ASSIGNED);
d901 1
a901 1
		SSLerror(SSL_R_NO_PRIVATE_KEY_ASSIGNED);
d936 1
a936 1
		SSLerror(SSL_R_UNINITIALIZED);
d951 1
a951 1
		SSLerror(SSL_R_UNINITIALIZED);
d965 1
a965 1
		SSLerror(SSL_R_UNINITIALIZED);
d971 1
a971 1
		SSLerror(SSL_R_PROTOCOL_IS_SHUTDOWN);
d988 1
a988 1
		SSLerror(SSL_R_UNINITIALIZED);
d1300 1
a1300 1
		SSLerror(SSL_R_NO_CIPHER_MATCH);
d1318 1
a1318 1
		SSLerror(SSL_R_NO_CIPHER_MATCH);
d1422 1
a1422 1
		SSLerror(SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);
d1427 1
a1427 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d1434 1
a1434 1
			SSLerror(SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);
d1446 1
a1446 1
				SSLerror(SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING);
d1465 1
a1465 1
				SSLerror(SSL_R_INAPPROPRIATE_FALLBACK);
d1476 1
a1476 1
				SSLerror(ERR_R_MALLOC_FAILURE);
d1786 1
a1786 1
		SSLerror(SSL_R_NULL_SSL_METHOD_PASSED);
d1791 1
a1791 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d1796 1
a1796 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d1801 1
a1801 1
		SSLerror(SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);
d1860 1
a1860 1
		SSLerror(SSL_R_LIBRARY_HAS_NO_CIPHERS);
d1869 1
a1869 1
		SSLerror(SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES);
d1873 1
a1873 1
		SSLerror(SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES);
d1928 1
a1928 1
	SSLerror(ERR_R_MALLOC_FAILURE);
d2112 1
a2112 1
			SSLerror(SSL_R_ECC_CERT_NOT_FOR_SIGNING);
d2144 1
a2144 1
		SSLerror(ERR_R_INTERNAL_ERROR);
d2184 1
a2184 1
		SSLerror(ERR_R_INTERNAL_ERROR);
d2388 1
a2388 1
		SSLerror(SSL_R_CONNECTION_TYPE_NOT_SET);
d2433 1
a2433 1
	SSLerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d2440 1
a2440 1
	SSLerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d2447 1
a2447 1
	SSLerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d2682 1
a2682 1
		SSLerror(ERR_R_BUF_LIB);
@


1.154
log
@Send the error function codes to rot in the depths of hell where they belong
We leave a single funciton code (0xFFF) to say "SSL_internal" so the public
API will not break, and we replace all internal use of the two argument
SSL_err() with the internal only SSL_error() that only takes a reason code.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.153 2017/01/26 06:32:58 jsing Exp $ */
d229 1
a229 2
		SSLerror(
		    SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS);
d383 1
a383 2
		SSLerror(
		    SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
d397 1
a397 2
		SSLerror(
		    SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
d873 1
a873 2
		SSLerror(
		    SSL_R_NO_CERTIFICATE_ASSIGNED);
d877 1
a877 2
		SSLerror(
		    SSL_R_NO_PRIVATE_KEY_ASSIGNED);
d889 1
a889 2
		SSLerror(
		    ERR_R_PASSED_NULL_PARAMETER);
d893 1
a893 2
		SSLerror(
		    SSL_R_NO_CERTIFICATE_ASSIGNED);
d897 1
a897 2
		SSLerror(
		    SSL_R_NO_CERTIFICATE_ASSIGNED);
d901 1
a901 2
		SSLerror(
		    SSL_R_NO_PRIVATE_KEY_ASSIGNED);
d1422 1
a1422 2
		SSLerror(
		    SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);
d1434 1
a1434 2
			SSLerror(
			    SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);
d1446 1
a1446 2
				SSLerror(
				    SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING);
d1465 1
a1465 2
				SSLerror(
				    SSL_R_INAPPROPRIATE_FALLBACK);
d1476 1
a1476 2
				SSLerror(
				    ERR_R_MALLOC_FAILURE);
d1801 1
a1801 2
		SSLerror(
		    SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);
d1869 1
a1869 2
		SSLerror(
		    SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES);
d1873 1
a1873 2
		SSLerror(
		    SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES);
d2112 1
a2112 2
			SSLerror(
			    SSL_R_ECC_CERT_NOT_FOR_SIGNING);
d2433 1
a2433 2
	SSLerror(
	    ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d2440 1
a2440 2
	SSLerror(
	    ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d2447 1
a2447 2
	SSLerror(
	    ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
@


1.153
log
@Remove most of SSL3_ENC_METHOD - we can just inline the function calls
and defines since they are the same everywhere.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.152 2017/01/26 06:01:44 jsing Exp $ */
d166 1
a166 1
		SSLerr(SSL_F_SSL_CLEAR, SSL_R_NO_METHOD_SPECIFIED);
d180 1
a180 1
		SSLerr(SSL_F_SSL_CLEAR, ERR_R_INTERNAL_ERROR);
d229 1
a229 1
		SSLerr(SSL_F_SSL_CTX_SET_SSL_VERSION,
d242 1
a242 1
		SSLerr(SSL_F_SSL_NEW, SSL_R_NULL_SSL_CTX);
d246 1
a246 1
		SSLerr(SSL_F_SSL_NEW, SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);
d251 1
a251 1
		SSLerr(SSL_F_SSL_NEW, ERR_R_MALLOC_FAILURE);
d256 1
a256 1
		SSLerr(SSL_F_SSL_NEW, ERR_R_MALLOC_FAILURE);
d375 1
a375 1
	SSLerr(SSL_F_SSL_NEW, ERR_R_MALLOC_FAILURE);
d384 1
a384 1
		SSLerr(SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT,
d399 1
a399 1
		SSLerr(SSL_F_SSL_SET_SESSION_ID_CONTEXT,
d637 1
a637 1
		SSLerr(SSL_F_SSL_SET_FD, ERR_R_BUF_LIB);
d658 1
a658 1
			SSLerr(SSL_F_SSL_SET_WFD, ERR_R_BUF_LIB);
d681 1
a681 1
			SSLerr(SSL_F_SSL_SET_RFD, ERR_R_BUF_LIB);
d876 1
a876 1
		SSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,
d881 1
a881 1
		SSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,
d894 1
a894 1
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,
d899 1
a899 1
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,
d904 1
a904 1
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,
d909 1
a909 1
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,
d945 1
a945 1
		SSLerr(SSL_F_SSL_READ, SSL_R_UNINITIALIZED);
d960 1
a960 1
		SSLerr(SSL_F_SSL_PEEK, SSL_R_UNINITIALIZED);
d974 1
a974 1
		SSLerr(SSL_F_SSL_WRITE, SSL_R_UNINITIALIZED);
d980 1
a980 1
		SSLerr(SSL_F_SSL_WRITE, SSL_R_PROTOCOL_IS_SHUTDOWN);
d997 1
a997 1
		SSLerr(SSL_F_SSL_SHUTDOWN, SSL_R_UNINITIALIZED);
d1309 1
a1309 1
		SSLerr(SSL_F_SSL_CTX_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);
d1327 1
a1327 1
		SSLerr(SSL_F_SSL_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);
d1431 1
a1431 1
		SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,
d1437 1
a1437 1
		SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST, ERR_R_MALLOC_FAILURE);
d1444 1
a1444 1
			SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,
d1457 1
a1457 1
				SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,
d1477 1
a1477 1
				SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,
d1489 1
a1489 1
				SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,
d1800 1
a1800 1
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_NULL_SSL_METHOD_PASSED);
d1805 1
a1805 1
		SSLerr(SSL_F_SSL_CTX_NEW, ERR_R_MALLOC_FAILURE);
d1810 1
a1810 1
		SSLerr(SSL_F_SSL_CTX_NEW, ERR_R_MALLOC_FAILURE);
d1815 1
a1815 1
		SSLerr(SSL_F_SSL_CTX_NEW,
d1875 1
a1875 1
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_LIBRARY_HAS_NO_CIPHERS);
d1884 1
a1884 1
		SSLerr(SSL_F_SSL_CTX_NEW,
d1889 1
a1889 1
		SSLerr(SSL_F_SSL_CTX_NEW,
d1945 1
a1945 1
	SSLerr(SSL_F_SSL_CTX_NEW, ERR_R_MALLOC_FAILURE);
d2129 1
a2129 1
			SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG,
d2162 1
a2162 1
		SSLerr(SSL_F_SSL_GET_SERVER_SEND_PKEY, ERR_R_INTERNAL_ERROR);
d2202 1
a2202 1
		SSLerr(SSL_F_SSL_GET_SIGN_PKEY, ERR_R_INTERNAL_ERROR);
d2406 1
a2406 1
		SSLerr(SSL_F_SSL_DO_HANDSHAKE, SSL_R_CONNECTION_TYPE_NOT_SET);
d2451 1
a2451 1
	SSLerr(SSL_F_SSL_UNDEFINED_FUNCTION,
d2459 1
a2459 1
	SSLerr(SSL_F_SSL_UNDEFINED_VOID_FUNCTION,
d2467 1
a2467 1
	SSLerr(SSL_F_SSL_UNDEFINED_CONST_FUNCTION,
d2703 1
a2703 1
		SSLerr(SSL_F_SSL_INIT_WBIO_BUFFER, ERR_R_BUF_LIB);
@


1.152
log
@Move relatively new version range code from ssl_lib.c into a separate
ssl_versions.c file.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.151 2017/01/26 00:42:44 jsing Exp $ */
d1735 1
a1735 1
	return (s->method->internal->ssl3_enc->export_keying_material(s, out, olen,
@


1.151
log
@Remove ssl3_undef_enc_method - if we have internal bugs we want to segfault
so that we can debug it, rather than adding a "should not be called" error
to the stack.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.150 2017/01/25 10:54:23 jsing Exp $ */
a2492 155
}

static int
ssl_clamp_version_range(uint16_t *min_ver, uint16_t *max_ver,
    uint16_t clamp_min, uint16_t clamp_max)
{
	if (clamp_min > clamp_max || *min_ver > *max_ver)
		return 0;
	if (clamp_max < *min_ver || clamp_min > *max_ver)
		return 0;

	if (*min_ver < clamp_min)
		*min_ver = clamp_min;
	if (*max_ver > clamp_max)
		*max_ver = clamp_max;

	return 1;
}

int
ssl_enabled_version_range(SSL *s, uint16_t *min_ver, uint16_t *max_ver)
{
	uint16_t min_version, max_version;

	/*
	 * The enabled versions have to be a contiguous range, which means we
	 * cannot enable and disable single versions at our whim, even though
	 * this is what the OpenSSL flags allow. The historical way this has
	 * been handled is by making a flag mean that all higher versions
	 * are disabled, if any version lower than the flag is enabled.
	 */

	min_version = 0;
	max_version = TLS1_2_VERSION;

	if ((s->internal->options & SSL_OP_NO_TLSv1) == 0)
		min_version = TLS1_VERSION;
	else if ((s->internal->options & SSL_OP_NO_TLSv1_1) == 0)
		min_version = TLS1_1_VERSION;
	else if ((s->internal->options & SSL_OP_NO_TLSv1_2) == 0)
		min_version = TLS1_2_VERSION;

	if ((s->internal->options & SSL_OP_NO_TLSv1_2) && min_version < TLS1_2_VERSION)
		max_version = TLS1_1_VERSION;
	if ((s->internal->options & SSL_OP_NO_TLSv1_1) && min_version < TLS1_1_VERSION)
		max_version = TLS1_VERSION;
	if ((s->internal->options & SSL_OP_NO_TLSv1) && min_version < TLS1_VERSION)
		max_version = 0;

	/* Everything has been disabled... */
	if (min_version == 0 || max_version == 0)
		return 0;

	/* Limit to configured version range. */
	if (!ssl_clamp_version_range(&min_version, &max_version,
	    s->internal->min_version, s->internal->max_version))
		return 0;

	if (min_ver != NULL)
		*min_ver = min_version;
	if (max_ver != NULL)
		*max_ver = max_version;

	return 1;
}

int
ssl_supported_version_range(SSL *s, uint16_t *min_ver, uint16_t *max_ver)
{
	uint16_t min_version, max_version;

	/* DTLS cannot currently be disabled... */
	if (SSL_IS_DTLS(s)) {
		min_version = max_version = DTLS1_VERSION;
		goto done;
	}

	if (!ssl_enabled_version_range(s, &min_version, &max_version))
		return 0;

	/* Limit to the versions supported by this method. */
	if (!ssl_clamp_version_range(&min_version, &max_version,
	    s->method->internal->min_version,
	    s->method->internal->max_version))
		return 0;

 done:
	if (min_ver != NULL)
		*min_ver = min_version;
	if (max_ver != NULL)
		*max_ver = max_version;

	return 1;
}

int
ssl_max_shared_version(SSL *s, uint16_t peer_ver, uint16_t *max_ver)
{
	uint16_t min_version, max_version, shared_version;

	*max_ver = 0;

	if (SSL_IS_DTLS(s)) {
		if (peer_ver >= DTLS1_VERSION) {
			*max_ver = DTLS1_VERSION;
			return 1;
		}
		return 0;
	}

	if (peer_ver >= TLS1_2_VERSION)
		shared_version = TLS1_2_VERSION;
	else if (peer_ver >= TLS1_1_VERSION)
		shared_version = TLS1_1_VERSION;
	else if (peer_ver >= TLS1_VERSION)
		shared_version = TLS1_VERSION;
	else
		return 0;

	if (!ssl_supported_version_range(s, &min_version, &max_version))
		return 0;

	if (shared_version < min_version)
		return 0;

	if (shared_version > max_version)
		shared_version = max_version;

	*max_ver = shared_version;

	return 1;
}

uint16_t
ssl_max_server_version(SSL *s)
{
	uint16_t max_version, min_version = 0;

	if (SSL_IS_DTLS(s))
		return (DTLS1_VERSION);

	if (!ssl_enabled_version_range(s, &min_version, &max_version))
		return 0;

	/*
	 * Limit to the versions supported by this method. The SSL method
	 * will be changed during version negotiation, as such we want to
	 * use the SSL method from the context.
	 */
	if (!ssl_clamp_version_range(&min_version, &max_version,
	    s->ctx->method->internal->min_version,
	    s->ctx->method->internal->max_version))
		return 0;

	return (max_version);
@


1.150
log
@Limit enabled version range by the versions configured on the SSL_CTX/SSL,
provide an ssl_supported_versions_range() function which also limits the
versions to those supported by the current method.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.149 2017/01/24 15:11:55 jsing Exp $ */
a160 27

SSL3_ENC_METHOD ssl3_undef_enc_method = {
	/*
	 * Evil casts, but these functions are only called if there's a
	 * library bug.
	 */
	.enc = (int (*)(SSL *, int))ssl_undefined_function,
	.mac = (int (*)(SSL *, unsigned char *, int))ssl_undefined_function,
	.setup_key_block = ssl_undefined_function,
	.generate_master_secret = (int (*)(SSL *, unsigned char *,
	    unsigned char *, int))ssl_undefined_function,
	.change_cipher_state = (int (*)(SSL*, int))ssl_undefined_function,
	.final_finish_mac = (int (*)(SSL *,  const char*, int,
	    unsigned char *))ssl_undefined_function,
	.finish_mac_length = 0,
	.cert_verify_mac = (int (*)(SSL *, int,
	    unsigned char *))ssl_undefined_function,
	.client_finished_label = NULL,
	.client_finished_label_len = 0,
	.server_finished_label = NULL,
	.server_finished_label_len = 0,
	.alert_value = (int (*)(int))ssl_undefined_function,
	.export_keying_material = (int (*)(SSL *, unsigned char *, size_t,
	    const char *, size_t, const unsigned char *, size_t,
	    int use_context))ssl_undefined_function,
	.enc_flags = 0,
};
@


1.149
log
@BUF_MEM_free(), X509_STORE_free() and X509_VERIFY_PARAM_free() all check
for NULL, as does lh_free() - do not do the same from the caller.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.148 2017/01/24 15:04:12 jsing Exp $ */
d287 3
d1848 2
d2522 17
d2573 34
d2622 8
d2639 1
a2639 1
	if (!ssl_enabled_version_range(s, &min_version, &max_version))
d2656 1
a2656 7
	uint16_t max_version;

	/*
	 * The SSL method will be changed during version negotiation, as such
	 * we want to use the SSL method from the context.
	 */
	max_version = s->ctx->method->internal->version;
d2661 2
a2662 9
	if ((s->internal->options & SSL_OP_NO_TLSv1_2) == 0 &&
	    max_version >= TLS1_2_VERSION)
		return (TLS1_2_VERSION);
	if ((s->internal->options & SSL_OP_NO_TLSv1_1) == 0 &&
	    max_version >= TLS1_1_VERSION)
		return (TLS1_1_VERSION);
	if ((s->internal->options & SSL_OP_NO_TLSv1) == 0 &&
	    max_version >= TLS1_VERSION)
		return (TLS1_VERSION);
d2664 11
a2674 1
	return (0);
@


1.148
log
@sk_free() checks for NULL so do not bother doing it from the callers.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.147 2017/01/24 14:57:31 jsing Exp $ */
d525 1
a525 2
	if (s->param)
		X509_VERIFY_PARAM_free(s->param);
d542 1
a542 2
	if (s->internal->init_buf != NULL)
		BUF_MEM_free(s->internal->init_buf);
d1985 1
a1985 2
	if (ctx->param)
		X509_VERIFY_PARAM_free(ctx->param);
d2001 1
a2001 2
	if (ctx->internal->sessions != NULL)
		lh_SSL_SESSION_free(ctx->internal->sessions);
d2003 1
a2003 2
	if (ctx->cert_store != NULL)
		X509_STORE_free(ctx->cert_store);
d3034 1
a3034 2
	if (ctx->cert_store != NULL)
		X509_STORE_free(ctx->cert_store);
@


1.147
log
@sk_pop_free() checks for NULL so do not bother doing it from the callers.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.146 2017/01/24 13:34:26 jsing Exp $ */
d584 1
a584 2
	if (s->internal->srtp_profiles)
		sk_SRTP_PROTECTION_PROFILE_free(s->internal->srtp_profiles);
@


1.146
log
@Within libssl a SSL_CTX * is referred to as a ctx - fix this for
SSL_CTX_free().
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.145 2017/01/24 09:03:21 jsing Exp $ */
d564 1
d567 4
a570 5
	if (s->internal->tlsext_ocsp_exts)
		sk_X509_EXTENSION_pop_free(s->internal->tlsext_ocsp_exts,
		    X509_EXTENSION_free);
	if (s->internal->tlsext_ocsp_ids)
		sk_OCSP_RESPID_pop_free(s->internal->tlsext_ocsp_ids, OCSP_RESPID_free);
d573 1
a573 2
	if (s->internal->client_CA != NULL)
		sk_X509_NAME_pop_free(s->internal->client_CA, X509_NAME_free);
d2013 2
a2014 4
	if (ctx->internal->client_CA != NULL)
		sk_X509_NAME_pop_free(ctx->internal->client_CA, X509_NAME_free);
	if (ctx->extra_certs != NULL)
		sk_X509_pop_free(ctx->extra_certs, X509_free);
@


1.145
log
@Add support for setting the supported EC curves via
SSL{_CTX}_set1_groups{_list}() - also provide defines for the previous
SSL{_CTX}_set1_curves{_list} names.

This also changes the default list of EC curves to be X25519, P-256 and
P-384. If you want others (such a brainpool) you need to configure this
yourself.

Inspired by parts of BoringSSL and OpenSSL.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.144 2017/01/24 01:47:22 jsing Exp $ */
d1978 1
a1978 1
SSL_CTX_free(SSL_CTX *a)
d1982 1
a1982 1
	if (a == NULL)
d1985 1
a1985 1
	i = CRYPTO_add(&a->references, -1, CRYPTO_LOCK_SSL_CTX);
d1989 2
a1990 2
	if (a->param)
		X509_VERIFY_PARAM_free(a->param);
d2001 2
a2002 2
	if (a->internal->sessions != NULL)
		SSL_CTX_flush_sessions(a, 0);
d2004 1
a2004 1
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_CTX, a, &a->internal->ex_data);
d2006 2
a2007 2
	if (a->internal->sessions != NULL)
		lh_SSL_SESSION_free(a->internal->sessions);
d2009 9
a2017 9
	if (a->cert_store != NULL)
		X509_STORE_free(a->cert_store);
	sk_SSL_CIPHER_free(a->cipher_list);
	sk_SSL_CIPHER_free(a->internal->cipher_list_by_id);
	ssl_cert_free(a->internal->cert);
	if (a->internal->client_CA != NULL)
		sk_X509_NAME_pop_free(a->internal->client_CA, X509_NAME_free);
	if (a->extra_certs != NULL)
		sk_X509_pop_free(a->extra_certs, X509_free);
d2020 2
a2021 2
	if (a->internal->srtp_profiles)
		sk_SRTP_PROTECTION_PROFILE_free(a->internal->srtp_profiles);
d2025 2
a2026 2
	if (a->internal->client_cert_engine)
		ENGINE_finish(a->internal->client_cert_engine);
d2029 2
a2030 2
	free(a->internal->tlsext_ecpointformatlist);
	free(a->internal->tlsext_supportedgroups);
d2032 1
a2032 1
	free(a->internal->alpn_client_proto_list);
d2034 2
a2035 2
	free(a->internal);
	free(a);
@


1.144
log
@ssl_cert_free() checks for NULL itself.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.143 2017/01/24 01:46:12 jsing Exp $ */
d339 28
d565 1
a565 1
	free(s->internal->tlsext_ellipticcurvelist);
d2028 3
@


1.143
log
@Remove a "free up if allocated" comment that exists before code that frees
things if they are allocated.

ok captainobvious@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.142 2017/01/24 01:44:00 jsing Exp $ */
d532 1
a532 2
	if (s->cert != NULL)
		ssl_cert_free(s->cert);
d866 1
a866 2
	if (tmp != NULL)
		ssl_cert_free(tmp);
d1985 1
a1985 2
	if (a->internal->cert != NULL)
		ssl_cert_free(a->internal->cert);
d2625 1
a2625 3
			if (ret->cert != NULL) {
				ssl_cert_free(ret->cert);
			}
@


1.142
log
@sk_SSL_CIPHER_free() checks for NULL so do not bother doing the same from
the callers.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.141 2017/01/23 22:34:38 beck Exp $ */
a533 1
	/* Free up if allocated */
@


1.141
log
@move default_passwd_cb and default_passwd_cb_userdata back into
the ssl_ctx from internal - these are used directly by python
and openvpn and a few other things - we have the set accessors
but the get accessors were added in 1.1 and these roll their
own caveat OPENSSL_VERSION chickenpluckery
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.140 2017/01/23 14:35:42 jsing Exp $ */
d519 2
a520 4
	if (s->cipher_list != NULL)
		sk_SSL_CIPHER_free(s->cipher_list);
	if (s->internal->cipher_list_by_id != NULL)
		sk_SSL_CIPHER_free(s->internal->cipher_list_by_id);
d1986 2
a1987 4
	if (a->cipher_list != NULL)
		sk_SSL_CIPHER_free(a->cipher_list);
	if (a->internal->cipher_list_by_id != NULL)
		sk_SSL_CIPHER_free(a->internal->cipher_list_by_id);
@


1.140
log
@Move options and mode from SSL_CTX and SSL to internal, since these can be
set and cleared via existing functions.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.139 2017/01/23 13:36:13 jsing Exp $ */
d1861 2
a1862 2
	ret->internal->default_passwd_callback = 0;
	ret->internal->default_passwd_callback_userdata = NULL;
d2018 1
a2018 1
	ctx->internal->default_passwd_callback = cb;
d2024 1
a2024 1
	ctx->internal->default_passwd_callback_userdata = u;
@


1.139
log
@Split most of SSL_METHOD out into an internal variant, which is opaque.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.138 2017/01/23 10:22:06 jsing Exp $ */
d287 2
a288 2
	s->options = ctx->options;
	s->mode = ctx->mode;
d1062 1
a1062 1
		return (s->options|=larg);
d1064 1
a1064 1
		return (s->options&=~larg);
d1066 1
a1066 1
		return (s->mode|=larg);
d1068 1
a1068 1
		return (s->mode &=~larg);
d1184 1
a1184 1
		return (ctx->options|=larg);
d1186 1
a1186 1
		return (ctx->options&=~larg);
d1188 1
a1188 1
		return (ctx->mode|=larg);
d1190 1
a1190 1
		return (ctx->mode&=~larg);
d1944 1
a1944 1
	ret->options |= SSL_OP_LEGACY_SERVER_CONNECT;
d2519 1
a2519 1
	if ((s->options & SSL_OP_NO_TLSv1) == 0)
d2521 1
a2521 1
	else if ((s->options & SSL_OP_NO_TLSv1_1) == 0)
d2523 1
a2523 1
	else if ((s->options & SSL_OP_NO_TLSv1_2) == 0)
d2526 1
a2526 1
	if ((s->options & SSL_OP_NO_TLSv1_2) && min_version < TLS1_2_VERSION)
d2528 1
a2528 1
	if ((s->options & SSL_OP_NO_TLSv1_1) && min_version < TLS1_1_VERSION)
d2530 1
a2530 1
	if ((s->options & SSL_OP_NO_TLSv1) && min_version < TLS1_VERSION)
d2589 1
a2589 1
	if ((s->options & SSL_OP_NO_TLSv1_2) == 0 &&
d2592 1
a2592 1
	if ((s->options & SSL_OP_NO_TLSv1_1) == 0 &&
d2595 1
a2595 1
	if ((s->options & SSL_OP_NO_TLSv1) == 0 &&
d2645 2
a2646 2
	ret->options = s->options;
	ret->mode = s->mode;
@


1.138
log
@Remove ssl_ctrl, ssl_ctx_ctrl, ssl_callback_ctrl and ssl_ctx_callback_ctrl
from SSL_METHOD, replacing usage with direct calls to the appropriate
functions.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.137 2017/01/23 08:48:44 beck Exp $ */
d215 1
a215 1
	s->version = s->method->version;
d235 1
a235 1
		s->method->ssl_free(s);
d237 1
a237 1
		if (!s->method->ssl_new(s))
d240 1
a240 1
		s->method->ssl_clear(s);
d357 1
a357 1
	if (!s->method->ssl_new(s))
d361 1
a361 1
	s->server = (ctx->method->ssl_accept == ssl_undefined_function) ? 0 : 1;
d553 1
a553 1
		s->method->ssl_free(s);
d802 1
a802 1
	return (s->method->ssl_pending(s));
d859 3
a861 3
		t->method->ssl_free(t);	/* cleanup current */
		t->method=f->method;	/* change method */
		t->method->ssl_new(t);	/* setup new */
d928 1
a928 1
	return (s->method->ssl_accept(s));
d937 1
a937 1
	return (s->method->ssl_connect(s));
d943 1
a943 1
	return (s->method->get_timeout());
d958 1
a958 1
	return (s->method->ssl_read(s, buf, num));
d972 1
a972 1
	return (s->method->ssl_peek(s, buf, num));
d988 1
a988 1
	return (s->method->ssl_write(s, buf, num));
d1007 1
a1007 1
		return (s->method->ssl_shutdown(s));
d1020 1
a1020 1
	return (s->method->ssl_renegotiate(s));
d1031 1
a1031 1
	return (s->method->ssl_renegotiate(s));
d1740 1
a1740 1
	return (s->method->ssl3_enc->export_keying_material(s, out, olen,
d1834 1
a1834 1
	ret->session_timeout = meth->get_timeout();
d2312 1
a2312 1
			conn = (s->internal->handshake_func == s->method->ssl_connect);
d2314 1
a2314 1
		if (s->method->version == meth->version)
d2317 1
a2317 1
			s->method->ssl_free(s);
d2319 1
a2319 1
			ret = s->method->ssl_new(s);
d2323 1
a2323 1
			s->internal->handshake_func = meth->ssl_connect;
d2325 1
a2325 1
			s->internal->handshake_func = meth->ssl_accept;
d2418 1
a2418 1
	s->method->ssl_renegotiate_check(s);
d2436 1
a2436 1
	s->internal->handshake_func = s->method->ssl_accept;
d2449 1
a2449 1
	s->internal->handshake_func = s->method->ssl_connect;
d2584 1
a2584 1
	max_version = s->ctx->method->version;
d2628 1
a2628 1
		ret->method->ssl_free(ret);
d2630 1
a2630 1
		ret->method->ssl_new(ret);
@


1.137
log
@send state and rstate from ssl_st into internal. There are accessors
so these should not be diddled with directly
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.136 2017/01/23 08:08:06 beck Exp $ */
d1095 3
a1097 1
		return (s->method->ssl_ctrl(s, cmd, larg, parg));
d1112 1
a1112 1
		return (s->method->ssl_callback_ctrl(s, cmd, fp));
d1197 1
a1197 1
		return (ctx->method->ssl_ctx_ctrl(ctx, cmd, larg, parg));
d1212 1
a1212 1
		return (ctx->method->ssl_ctx_callback_ctrl(ctx, cmd, fp));
@


1.136
log
@move back read_hash and enc_read_ctx into ssl_st. wpa_supplicant and
other perversions touches them sickly and unnaturally.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.135 2017/01/23 06:45:30 beck Exp $ */
d213 1
a213 1
	s->state = SSL_ST_BEFORE|((s->server) ? SSL_ST_ACCEPT : SSL_ST_CONNECT);
d218 1
a218 1
	s->rstate = SSL_ST_READ_HEADER;
d2433 1
a2433 1
	s->state = SSL_ST_ACCEPT|SSL_ST_BEFORE;
d2446 1
a2446 1
	s->state = SSL_ST_CONNECT|SSL_ST_BEFORE;
d2684 2
a2685 2
	ret->state=s->state;
	ret->rstate = s->rstate;
d2944 1
a2944 1
	return (ssl->state);
d2950 1
a2950 1
	ssl->state = state;
@


1.135
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.134 2017/01/23 05:13:02 jsing Exp $ */
d224 1
a224 1
	ssl_clear_hash_ctx(&s->internal->read_hash);
d531 1
a531 1
	ssl_clear_hash_ctx(&s->internal->read_hash);
d2437 1
a2437 1
	ssl_clear_hash_ctx(&s->internal->read_hash);
d2450 1
a2450 1
	ssl_clear_hash_ctx(&s->internal->read_hash);
d2735 2
a2736 2
	EVP_CIPHER_CTX_free(s->internal->enc_read_ctx);
	s->internal->enc_read_ctx = NULL;
@


1.134
log
@Move most of the fields in SSL_CTX to internal - the ones that remain are
known to be in use.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.133 2017/01/23 04:55:27 beck Exp $ */
d203 2
a204 2
	s->hit = 0;
	s->shutdown = 0;
d206 1
a206 1
	if (s->renegotiate) {
d211 1
a211 1
	s->type = 0;
d217 1
a217 1
	s->rwstate = SSL_NOTHING;
d220 2
a221 2
	BUF_MEM_free(s->init_buf);
	s->init_buf = NULL;
d224 2
a225 2
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->write_hash);
d227 1
a227 1
	s->first_packet = 0;
d289 1
a289 1
	s->max_cert_list = ctx->internal->max_cert_list;
d309 1
a309 1
	s->read_ahead = ctx->internal->read_ahead;
d323 1
a323 1
	s->quiet_shutdown = ctx->internal->quiet_shutdown;
d330 1
a330 1
	s->tlsext_ticket_expected = 0;
d332 5
a336 5
	s->tlsext_status_expected = 0;
	s->tlsext_ocsp_ids = NULL;
	s->tlsext_ocsp_exts = NULL;
	s->tlsext_ocsp_resp = NULL;
	s->tlsext_ocsp_resplen = -1;
d365 1
a365 1
	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);
d500 1
a500 1
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);
d515 2
a516 2
	if (s->init_buf != NULL)
		BUF_MEM_free(s->init_buf);
d521 2
a522 2
	if (s->cipher_list_by_id != NULL)
		sk_SSL_CIPHER_free(s->cipher_list_by_id);
d531 2
a532 2
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->write_hash);
d540 4
a543 4
	free(s->tlsext_ecpointformatlist);
	free(s->tlsext_ellipticcurvelist);
	if (s->tlsext_ocsp_exts)
		sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,
d545 3
a547 3
	if (s->tlsext_ocsp_ids)
		sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids, OCSP_RESPID_free);
	free(s->tlsext_ocsp_resp);
d549 2
a550 2
	if (s->client_CA != NULL)
		sk_X509_NAME_pop_free(s->client_CA, X509_NAME_free);
d561 2
a562 2
	if (s->srtp_profiles)
		sk_SRTP_PROTECTION_PROFILE_free(s->srtp_profiles);
d782 1
a782 1
	s->read_ahead = yes;
d788 1
a788 1
	return (s->read_ahead);
d954 2
a955 2
	if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {
		s->rwstate = SSL_NOTHING;
d969 1
a969 1
	if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {
d983 2
a984 2
	if (s->shutdown & SSL_SENT_SHUTDOWN) {
		s->rwstate = SSL_NOTHING;
d1015 2
a1016 2
	if (s->renegotiate == 0)
		s->renegotiate = 1;
d1018 1
a1018 1
	s->new_session = 1;
d1026 2
a1027 2
	if (s->renegotiate == 0)
		s->renegotiate = 1;
d1029 1
a1029 1
	s->new_session = 0;
d1041 1
a1041 1
	return (s->renegotiate != 0);
d1051 1
a1051 1
		return (s->read_ahead);
d1053 2
a1054 2
		l = s->read_ahead;
		s->read_ahead = larg;
d1070 1
a1070 1
		return (s->max_cert_list);
d1072 2
a1073 2
		l = s->max_cert_list;
		s->max_cert_list = larg;
d1264 2
a1265 2
		if (s->cipher_list_by_id != NULL) {
			return (s->cipher_list_by_id);
d1325 1
a1325 1
	&s->cipher_list_by_id, str);
d1402 1
a1402 1
	if (ciphers > 0 && !s->renegotiate) {
d1459 1
a1459 1
			if (s->renegotiate) {
d2277 1
a2277 1
	if ((i & mode) && (!s->hit) && ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE)
d2357 1
a2357 1
			 * ever set s->rwstate incorrectly (so that we have
d2399 1
a2399 1
		if ((s->shutdown & SSL_RECEIVED_SHUTDOWN) &&
d2432 1
a2432 1
	s->shutdown = 0;
d2437 2
a2438 2
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->write_hash);
d2445 1
a2445 1
	s->shutdown = 0;
d2450 2
a2451 2
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->write_hash);
d2612 1
a2612 1
	ret->type = s->type;
d2656 1
a2656 1
	ret->debug = s->debug;
d2660 1
a2660 1
	    &ret->ex_data, &s->ex_data))
d2675 1
a2675 1
	ret->rwstate = s->rwstate;
d2679 4
a2682 4
	ret->renegotiate = s->renegotiate;
	ret->new_session = s->new_session;
	ret->quiet_shutdown = s->quiet_shutdown;
	ret->shutdown = s->shutdown;
d2691 1
a2691 1
	ret->init_num = 0;
d2693 1
a2693 1
	ret->hit = s->hit;
d2703 3
a2705 3
	if (s->cipher_list_by_id != NULL) {
		if ((ret->cipher_list_by_id =
		    sk_SSL_CIPHER_dup(s->cipher_list_by_id)) == NULL)
d2710 3
a2712 3
	if (s->client_CA != NULL) {
		if ((sk = sk_X509_NAME_dup(s->client_CA)) == NULL) goto err;
			ret->client_CA = sk;
d2735 14
a2748 14
	EVP_CIPHER_CTX_free(s->enc_read_ctx);
	s->enc_read_ctx = NULL;
	EVP_CIPHER_CTX_free(s->enc_write_ctx);
	s->enc_write_ctx = NULL;

	if (s->aead_read_ctx != NULL) {
		EVP_AEAD_CTX_cleanup(&s->aead_read_ctx->ctx);
		free(s->aead_read_ctx);
		s->aead_read_ctx = NULL;
	}
	if (s->aead_write_ctx != NULL) {
		EVP_AEAD_CTX_cleanup(&s->aead_write_ctx->ctx);
		free(s->aead_write_ctx);
		s->aead_write_ctx = NULL;
d2855 1
a2855 1
	s->quiet_shutdown = mode;
d2861 1
a2861 1
	return (s->quiet_shutdown);
d2867 1
a2867 1
	s->shutdown = mode;
d2873 1
a2873 1
	return (s->shutdown);
d2976 1
a2976 1
	return (CRYPTO_set_ex_data(&s->ex_data, idx, arg));
d2982 1
a2982 1
	return (CRYPTO_get_ex_data(&s->ex_data, idx));
d3028 1
a3028 1
	return (s->rwstate);
d3101 1
a3101 1
	s->debug = debug;
d3107 1
a3107 1
	return (s->hit);
@


1.133
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.132 2017/01/23 04:15:28 jsing Exp $ */
d254 1
a254 1
	    &(ctx->cipher_list_by_id), SSL_DEFAULT_CIPHER_LIST);
d289 1
a289 1
	s->max_cert_list = ctx->max_cert_list;
d291 1
a291 1
	if (ctx->cert != NULL) {
d303 1
a303 1
		s->cert = ssl_cert_dup(ctx->cert);
d309 1
a309 1
	s->read_ahead = ctx->read_ahead;
d323 2
a324 2
	s->quiet_shutdown = ctx->quiet_shutdown;
	s->max_send_fragment = ctx->max_send_fragment;
d444 1
a444 1
	p = lh_SSL_SESSION_retrieve(ssl->ctx->sessions, &r);
d879 2
a880 2
	if ((ctx == NULL) || (ctx->cert == NULL) ||
	    (ctx->cert->key->x509 == NULL)) {
d885 1
a885 1
	if (ctx->cert->key->privatekey == NULL) {
d890 2
a891 2
	return (X509_check_private_key(ctx->cert->key->x509,
	    ctx->cert->key->privatekey));
d1117 1
a1117 1
	return (ctx->sessions);
d1127 1
a1127 1
		return (ctx->read_ahead);
d1129 2
a1130 2
		l = ctx->read_ahead;
		ctx->read_ahead = larg;
d1138 1
a1138 1
		return (ctx->max_cert_list);
d1140 2
a1141 2
		l = ctx->max_cert_list;
		ctx->max_cert_list = larg;
d1145 2
a1146 2
		l = ctx->session_cache_size;
		ctx->session_cache_size = larg;
d1149 1
a1149 1
		return (ctx->session_cache_size);
d1151 2
a1152 2
		l = ctx->session_cache_mode;
		ctx->session_cache_mode = larg;
d1155 1
a1155 1
		return (ctx->session_cache_mode);
d1158 1
a1158 1
		return (lh_SSL_SESSION_num_items(ctx->sessions));
d1192 1
a1192 1
		ctx->max_send_fragment = larg;
d1267 2
a1268 2
		    (s->ctx->cipher_list_by_id != NULL)) {
			return (s->ctx->cipher_list_by_id);
d1299 1
a1299 1
	    &ctx->cipher_list_by_id, str);
d1306 1
a1306 1
	 * ctx->cipher_list and ctx->cipher_list_by_id has been
d1826 4
a1829 4
	ret->session_cache_mode = SSL_SESS_CACHE_SERVER;
	ret->session_cache_size = SSL_SESSION_CACHE_MAX_SIZE_DEFAULT;
	ret->session_cache_head = NULL;
	ret->session_cache_tail = NULL;
d1842 1
a1842 1
	ret->quiet_shutdown = 0;
d1849 2
a1850 2
	ret->max_cert_list = SSL_MAX_CERT_LIST_DEFAULT;
	ret->read_ahead = 0;
d1856 1
a1856 1
	if ((ret->cert = ssl_cert_new()) == NULL)
d1865 2
a1866 2
	ret->sessions = lh_SSL_SESSION_new();
	if (ret->sessions == NULL)
d1873 1
a1873 1
	    &ret->cipher_list_by_id, SSL_DEFAULT_CIPHER_LIST);
d1884 1
a1884 1
	if ((ret->md5 = EVP_get_digestbyname("ssl3-md5")) == NULL) {
d1889 1
a1889 1
	if ((ret->sha1 = EVP_get_digestbyname("ssl3-sha1")) == NULL) {
d1895 1
a1895 1
	if ((ret->client_CA = sk_X509_NAME_new_null()) == NULL)
d1898 1
a1898 1
	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_CTX, ret, &ret->ex_data);
d1902 1
a1902 1
	ret->max_send_fragment = SSL3_RT_MAX_PLAIN_LENGTH;
d1908 3
a1910 3
	arc4random_buf(ret->tlsext_tick_key_name, 16);
	arc4random_buf(ret->tlsext_tick_hmac_key, 16);
	arc4random_buf(ret->tlsext_tick_aes_key, 16);
d1917 1
d1919 1
a1919 1
	ret->client_cert_engine = NULL;
d1976 1
a1976 1
	if (a->sessions != NULL)
d1979 1
a1979 1
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_CTX, a, &a->ex_data);
d1981 2
a1982 2
	if (a->sessions != NULL)
		lh_SSL_SESSION_free(a->sessions);
d1988 6
a1993 6
	if (a->cipher_list_by_id != NULL)
		sk_SSL_CIPHER_free(a->cipher_list_by_id);
	if (a->cert != NULL)
		ssl_cert_free(a->cert);
	if (a->client_CA != NULL)
		sk_X509_NAME_pop_free(a->client_CA, X509_NAME_free);
d1998 2
a1999 2
	if (a->srtp_profiles)
		sk_SRTP_PROTECTION_PROFILE_free(a->srtp_profiles);
d2003 2
a2004 2
	if (a->client_cert_engine)
		ENGINE_finish(a->client_cert_engine);
d2276 1
a2276 1
	i = s->session_ctx->session_cache_mode;
d2843 1
a2843 1
	ctx->quiet_shutdown = mode;
d2849 1
a2849 1
	return (ctx->quiet_shutdown);
d2897 1
a2897 1
	ssl->cert = ssl_cert_dup(ctx->cert);
d2996 1
a2996 1
	return (CRYPTO_set_ex_data(&s->ex_data, idx, arg));
d3002 1
a3002 1
	return (CRYPTO_get_ex_data(&s->ex_data, idx));
@


1.132
log
@Move callback function pointers and argument pointers from SSL_CTX to
internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.131 2017/01/23 01:22:08 jsing Exp $ */
d233 1
a233 1
	if (!s->in_handshake && (s->session == NULL) &&
d310 2
a311 2
	s->msg_callback = ctx->internal->msg_callback;
	s->msg_callback_arg = ctx->internal->msg_callback_arg;
d316 2
a317 2
	s->verify_callback = ctx->internal->default_verify_callback;
	s->generate_session_id = ctx->internal->generate_session_id;
d328 2
a329 2
	s->tlsext_debug_cb = 0;
	s->tlsext_debug_arg = NULL;
d418 1
a418 1
	ssl->generate_session_id = cb;
d744 1
a744 1
	return (s->verify_callback);
d770 1
a770 1
		s->verify_callback = callback;
d925 1
a925 1
	if (s->handshake_func == NULL)
d934 1
a934 1
	if (s->handshake_func == NULL)
d949 1
a949 1
	if (s->handshake_func == NULL) {
d964 1
a964 1
	if (s->handshake_func == NULL) {
d978 1
a978 1
	if (s->handshake_func == NULL) {
d1001 1
a1001 1
	if (s->handshake_func == NULL) {
d1058 1
a1058 1
		s->msg_callback_arg = parg;
d1104 1
a1104 1
		s->msg_callback = (void (*)(int write_p, int version,
d2308 2
a2309 2
		if (s->handshake_func != NULL)
			conn = (s->handshake_func == s->method->ssl_connect);
d2320 1
a2320 1
			s->handshake_func = meth->ssl_connect;
d2322 1
a2322 1
			s->handshake_func = meth->ssl_accept;
d2410 1
a2410 1
	if (s->handshake_func == NULL) {
d2418 1
a2418 1
		ret = s->handshake_func(s);
d2433 1
a2433 1
	s->handshake_func = s->method->ssl_accept;
d2446 1
a2446 1
	s->handshake_func = s->method->ssl_connect;
d2646 2
a2647 2
	ret->msg_callback = s->msg_callback;
	ret->msg_callback_arg = s->msg_callback_arg;
d2651 1
a2651 1
	ret->generate_session_id = s->generate_session_id;
d2675 2
a2676 2
	ret->in_handshake = s->in_handshake;
	ret->handshake_func = s->handshake_func;
d2932 1
a2932 1
	ssl->info_callback = cb;
d2937 1
a2937 1
	return (ssl->info_callback);
@


1.131
log
@Move not_resumable and sess_cert from SSL_SESSION to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.130 2017/01/23 00:12:54 jsing Exp $ */
d310 2
a311 2
	s->msg_callback = ctx->msg_callback;
	s->msg_callback_arg = ctx->msg_callback_arg;
d316 2
a317 2
	s->verify_callback = ctx->default_verify_callback;
	s->generate_session_id = ctx->generate_session_id;
d409 1
a409 1
	ctx->generate_session_id = cb;
d761 1
a761 1
	return (ctx->default_verify_callback);
d1134 1
a1134 1
		ctx->msg_callback_arg = parg;
d1204 1
a1204 1
		ctx->msg_callback = (void (*)(int write_p, int version,
d1834 4
a1837 4
	ret->new_session_cb = 0;
	ret->remove_session_cb = 0;
	ret->get_session_cb = 0;
	ret->generate_session_id = 0;
d1844 1
a1844 1
	ret->info_callback = NULL;
d1846 2
a1847 2
	ret->app_verify_callback = 0;
	ret->app_verify_arg = NULL;
d1851 2
a1852 2
	ret->msg_callback = 0;
	ret->msg_callback_arg = NULL;
d1855 1
a1855 1
	ret->default_verify_callback = NULL;
d1859 5
a1863 5
	ret->default_passwd_callback = 0;
	ret->default_passwd_callback_userdata = NULL;
	ret->client_cert_cb = 0;
	ret->app_gen_cookie_cb = 0;
	ret->app_verify_cookie_cb = 0;
d1904 2
a1905 2
	ret->tlsext_servername_callback = 0;
	ret->tlsext_servername_arg = NULL;
d1912 2
a1913 2
	ret->tlsext_status_cb = 0;
	ret->tlsext_status_arg = NULL;
d2015 1
a2015 1
	ctx->default_passwd_callback = cb;
d2021 1
a2021 1
	ctx->default_passwd_callback_userdata = u;
d2028 2
a2029 2
	ctx->app_verify_callback = cb;
	ctx->app_verify_arg = arg;
d2036 1
a2036 1
	ctx->default_verify_callback = cb;
d2278 1
a2278 1
	    && (s->session_ctx->new_session_cb != NULL)) {
d2280 1
a2280 1
		if (!s->session_ctx->new_session_cb(s, s->session))
@


1.130
log
@Move the stats struct from SSL_CTX to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.129 2017/01/22 09:02:07 jsing Exp $ */
d829 1
a829 1
	    (s->session->sess_cert == NULL))
d832 1
a832 1
		r = s->session->sess_cert->cert_chain;
@


1.129
log
@Move most of the SSL3_STATE fields to internal - the ones that remain are
known to be used by ports.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.128 2017/01/22 07:16:39 beck Exp $ */
d1160 1
a1160 1
		return (ctx->stats.sess_connect);
d1162 1
a1162 1
		return (ctx->stats.sess_connect_good);
d1164 1
a1164 1
		return (ctx->stats.sess_connect_renegotiate);
d1166 1
a1166 1
		return (ctx->stats.sess_accept);
d1168 1
a1168 1
		return (ctx->stats.sess_accept_good);
d1170 1
a1170 1
		return (ctx->stats.sess_accept_renegotiate);
d1172 1
a1172 1
		return (ctx->stats.sess_hit);
d1174 1
a1174 1
		return (ctx->stats.sess_cb_hit);
d1176 1
a1176 1
		return (ctx->stats.sess_miss);
d1178 1
a1178 1
		return (ctx->stats.sess_timeout);
d1180 1
a1180 1
		return (ctx->stats.sess_cache_full);
d1839 1
a1839 1
	memset((char *)&ret->stats, 0, sizeof(ret->stats));
d2288 2
a2289 2
		    s->session_ctx->stats.sess_connect_good :
		    s->session_ctx->stats.sess_accept_good) & 0xff) == 0xff) {
@


1.128
log
@Move most of DTLS1_STATE to internal.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.127 2017/01/22 06:36:49 jsing Exp $ */
d705 1
a705 1
		ret = s->s3->tmp.finish_md_len;
d708 1
a708 1
		memcpy(buf, s->s3->tmp.finish_md, count);
d720 1
a720 1
		ret = s->s3->tmp.peer_finish_md_len;
d723 1
a723 1
		memcpy(buf, s->s3->tmp.peer_finish_md, count);
d1092 1
a1092 1
			return (s->s3->send_connection_binding);
d1428 1
a1428 1
		s->s3->send_connection_binding = 0;
d1467 1
a1467 1
			s->s3->send_connection_binding = 1;
d1728 2
a1729 2
		*data = ssl->s3->alpn_selected;
		*len = ssl->s3->alpn_selected_len;
d2122 1
a2122 1
	const SSL_CIPHER	*cs = s->s3->tmp.new_cipher;
d2151 1
a2151 1
	ssl_set_cert_masks(c, s->s3->tmp.new_cipher);
d2153 1
a2153 1
	alg_a = s->s3->tmp.new_cipher->algorithm_auth;
d2224 1
a2224 1
	} else if (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) {
d2226 1
a2226 1
		if (s->s3->tmp.new_cipher->strength_bits == 256)
d2399 1
a2399 1
		    (s->s3->warn_alert == SSL_AD_CLOSE_NOTIFY))
@


1.127
log
@Move ALPN and NPN fields from SSL/SSL_CTX to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.126 2017/01/22 03:50:45 jsing Exp $ */
d1081 1
a1081 1
			s->d1->mtu = larg;
@


1.126
log
@Convert publically visible structs to translucent structs.

This change adds an internal opaque struct for each of the significant
publically visible structs. The opaque struct is then allocated and
attached to the publically visible struct when the appropriate *_new()
function is called, then cleared and freed as necessary.

This will allow for changes to be made to the internals of libssl, without
requiring a major bump each time the publically visible structs are
modified.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.125 2017/01/21 04:16:49 jsing Exp $ */
d339 1
a339 1
	s->next_proto_negotiated = NULL;
d341 4
a344 4
	if (s->ctx->alpn_client_proto_list != NULL) {
		s->alpn_client_proto_list =
		    malloc(s->ctx->alpn_client_proto_list_len);
		if (s->alpn_client_proto_list == NULL)
d346 5
a350 5
		memcpy(s->alpn_client_proto_list,
		    s->ctx->alpn_client_proto_list,
		    s->ctx->alpn_client_proto_list_len);
		s->alpn_client_proto_list_len =
		    s->ctx->alpn_client_proto_list_len;
d557 2
a558 2
	free(s->next_proto_negotiated);
	free(s->alpn_client_proto_list);
d1617 1
a1617 1
	*data = s->next_proto_negotiated;
d1621 1
a1621 1
		*len = s->next_proto_negotiated_len;
d1640 2
a1641 2
	ctx->next_protos_advertised_cb = cb;
	ctx->next_protos_advertised_cb_arg = arg;
d1660 2
a1661 2
	ctx->next_proto_select_cb = cb;
	ctx->next_proto_select_cb_arg = arg;
d1673 2
a1674 2
	free(ctx->alpn_client_proto_list);
	if ((ctx->alpn_client_proto_list = malloc(protos_len)) == NULL)
d1676 2
a1677 2
	memcpy(ctx->alpn_client_proto_list, protos, protos_len);
	ctx->alpn_client_proto_list_len = protos_len;
d1691 2
a1692 2
	free(ssl->alpn_client_proto_list);
	if ((ssl->alpn_client_proto_list = malloc(protos_len)) == NULL)
d1694 2
a1695 2
	memcpy(ssl->alpn_client_proto_list, protos, protos_len);
	ssl->alpn_client_proto_list_len = protos_len;
d1710 2
a1711 2
	ctx->alpn_select_cb = cb;
	ctx->alpn_select_cb_arg = arg;
d1915 2
a1916 2
	ret->next_protos_advertised_cb = 0;
	ret->next_proto_select_cb = 0;
d2006 1
a2006 1
	free(a->alpn_client_proto_list);
@


1.125
log
@Expand IMPLEMENT_OBJ_BSEARCH_GLOBAL_CMP_FN macro.

No change in generated assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.124 2017/01/03 16:57:15 jsing Exp $ */
d277 9
a285 4
	s = calloc(1, sizeof(SSL));
	if (s == NULL)
		goto err;

d369 1
a369 1
err:
a556 1

d565 1
d1800 1
a1800 1
	SSL_CTX	*ret = NULL;
d1807 10
a1821 3
	ret = calloc(1, sizeof(SSL_CTX));
	if (ret == NULL)
		goto err;
d2008 1
@


1.124
log
@Pull out, rework and dedup the code that determines the highest shared
version.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.123 2016/12/30 16:57:01 jsing Exp $ */
d3096 15
a3110 1
IMPLEMENT_OBJ_BSEARCH_GLOBAL_CMP_FN(SSL_CIPHER, SSL_CIPHER, ssl_cipher_id);
@


1.123
log
@Pull out (and largely rewrite) the code that determines the enabled
protocol version range.

This also fixes a bug whereby if all protocols were disabled, the client
would still use TLSv1.2 in the client hello, only to have if fail with
unsupported version when it received and processed the server hello.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.122 2016/12/04 14:32:30 jsing Exp $ */
d2519 1
a2519 1
		return -1;
d2526 31
a2556 1
	return 0;
@


1.122
log
@Convert ssl_cipher_list_to_bytes() to CBB, changing the function to return
the number of bytes written via an explicit *outlen argument and retaining
the return value to indicate success or failure.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.121 2016/11/02 11:21:05 jsing Exp $ */
d2485 42
@


1.121
log
@Expand LHASH_OF, IMPLEMENT_LHASH_DOALL_ARG_FN and LHASH_DOALL_ARG_FN
macros. Only change in generated assembly is due to line numbering.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.120 2016/11/02 10:45:02 jsing Exp $ */
d1366 2
a1367 1
ssl_cipher_list_to_bytes(SSL *s, STACK_OF(SSL_CIPHER) *sk, unsigned char *p)
d1369 6
a1374 3
	int		 i;
	SSL_CIPHER	*c;
	unsigned char	*q;
d1378 3
a1380 1
	q = p;
d1383 1
a1383 1
		c = sk_SSL_CIPHER_value(sk, i);
d1386 1
a1386 1
		if ((c->algorithm_ssl & SSL_TLSV1_2) &&
d1390 10
a1399 1
		s2n(ssl3_cipher_get_value(c), p);
d1402 7
a1408 6
	/*
	 * If p == q, no ciphers and caller indicates an error. Otherwise
	 * add SCSV if not renegotiating.
	 */
	if (p != q && !s->renegotiate)
		s2n(SSL3_CK_SCSV & SSL3_CK_VALUE_MASK, p);
d1410 1
a1410 1
	return (p - q);
@


1.120
log
@Expand IMPLEMENT_LHASH_COMP_FN/IMPLEMENT_LHASH_HASH_FN macros - the only
change to generated assembly results from a difference in line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.119 2016/10/19 16:38:40 jsing Exp $ */
d1109 1
a1109 1
LHASH_OF(SSL_SESSION) *
@


1.119
log
@Remove support for fixed ECDH cipher suites - these is not widely supported
and more importantly they do not provide PFS (if you want to use ECDH, use
ECDHE instead).

With input from guenther@@.

ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.118 2016/09/22 12:34:59 jsing Exp $ */
d1759 16
a1774 4
static
IMPLEMENT_LHASH_HASH_FN(ssl_session, SSL_SESSION)
static
IMPLEMENT_LHASH_COMP_FN(ssl_session, SSL_SESSION)
@


1.118
log
@Improve on code from the previous commit.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.117 2016/09/20 04:25:09 bcook Exp $ */
a2006 1
	CERT_PKEY	*cpk;
d2008 1
a2009 2
	int		 have_ecc_cert, ecdh_ok, ecdsa_ok;
	int		 have_ecdh_tmp;
d2011 1
a2011 2
	EVP_PKEY	*ecc_pkey = NULL;
	int		 signature_nid = 0, pk_nid = 0, md_nid = 0;
d2021 1
a2058 1
		/* This call populates extension flags (ex_flags) */
d2060 2
d2063 4
a2066 21
		ecdh_ok = (x->ex_flags & EXFLAG_KUSAGE) ?
		(x->ex_kusage & X509v3_KU_KEY_AGREEMENT) : 1;
		ecdsa_ok = (x->ex_flags & EXFLAG_KUSAGE) ?
		(x->ex_kusage & X509v3_KU_DIGITAL_SIGNATURE) : 1;
		ecc_pkey = X509_get_pubkey(x);
		EVP_PKEY_free(ecc_pkey);
		if ((x->sig_alg) && (x->sig_alg->algorithm)) {
			signature_nid = OBJ_obj2nid(x->sig_alg->algorithm);
			OBJ_find_sigid_algs(signature_nid, &md_nid, &pk_nid);
		}
		if (ecdh_ok) {
			if (pk_nid == NID_rsaEncryption || pk_nid == NID_rsa) {
				mask_k|=SSL_kECDHr;
				mask_a|=SSL_aECDH;
			}
			if (pk_nid == NID_X9_62_id_ecPublicKey) {
				mask_k|=SSL_kECDHe;
				mask_a|=SSL_aECDH;
			}
		}
		if (ecdsa_ok)
d2070 1
a2070 1
	if (have_ecdh_tmp) {
a2071 2
	}

a2077 5
/* This handy macro borrowed from crypto/x509v3/v3_purp.c */
#define ku_reject(x, usage) \
	(((x)->ex_flags & EXFLAG_KUSAGE) && !((x)->ex_kusage & (usage)))


a2080 2
	unsigned long		 alg_k, alg_a;
	int			 signature_nid = 0, md_nid = 0, pk_nid = 0;
d2082 1
a2083 1
	alg_k = cs->algorithm_mkey;
a2085 32
	/* This call populates the ex_flags field correctly */
	X509_check_purpose(x, -1, 0);
	if ((x->sig_alg) && (x->sig_alg->algorithm)) {
		signature_nid = OBJ_obj2nid(x->sig_alg->algorithm);
		OBJ_find_sigid_algs(signature_nid, &md_nid, &pk_nid);
	}
	if (alg_k & SSL_kECDHe || alg_k & SSL_kECDHr) {
		/* key usage, if present, must allow key agreement */
		if (ku_reject(x, X509v3_KU_KEY_AGREEMENT)) {
			SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG,
			    SSL_R_ECC_CERT_NOT_FOR_KEY_AGREEMENT);
			return (0);
		}
		if ((alg_k & SSL_kECDHe) && TLS1_get_version(s) <
		    TLS1_2_VERSION) {
			/* signature alg must be ECDSA */
			if (pk_nid != NID_X9_62_id_ecPublicKey) {
				SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG,
				    SSL_R_ECC_CERT_SHOULD_HAVE_SHA1_SIGNATURE);
				return (0);
			}
		}
		if ((alg_k & SSL_kECDHr) && TLS1_get_version(s) <
		    TLS1_2_VERSION) {
			/* signature alg must be RSA */
			if (pk_nid != NID_rsaEncryption && pk_nid != NID_rsa) {
				SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG,
				    SSL_R_ECC_CERT_SHOULD_HAVE_RSA_SIGNATURE);
				return (0);
			}
		}
	}
d2087 6
a2092 2
		/* key usage, if present, must allow signing */
		if (ku_reject(x, X509v3_KU_DIGITAL_SIGNATURE)) {
a2099 1
	/* all checks are ok */
a2101 2

/* THIS NEEDS CLEANING UP */
d2105 1
a2105 1
	unsigned long	 alg_k, alg_a;
a2111 1
	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
d2114 1
a2114 15
	if (alg_k & (SSL_kECDHr|SSL_kECDHe)) {
		/*
		 * We don't need to look at SSL_kECDHE
		 * since no certificate is needed for
		 * anon ECDH and for authenticated
		 * ECDHE, the check for the auth
		 * algorithm will set i correctly
		 * NOTE: For ECDH-RSA, we need an ECC
		 * not an RSA cert but for EECDH-RSA
		 * we need an RSA cert. Placing the
		 * checks for SSL_kECDH before RSA
		 * checks ensures the correct cert is chosen.
		 */
		i = SSL_PKEY_ECC;
	} else if (alg_a & SSL_aECDSA) {
@


1.117
log
@Avoid selecting weak digests for (EC)DH when using SNI.

from OpenSSL:

SSL_set_SSL_CTX is normally called for SNI after ClientHello has
received and the digest to use for each certificate has been decided.
The original ssl->cert contains the negotiated digests and is now
copied to the new ssl->cert.

noted by David Benjamin and Kinichiro Inoguchi
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.116 2015/10/25 15:52:49 doug Exp $ */
d2851 1
d2859 3
a2861 6
		/* Copy negotiated digests from original */
		for (i = 0; i < SSL_PKEY_NUM; i++) {
			CERT_PKEY *cpk = ocert->pkeys + i;
			CERT_PKEY *rpk = ssl->cert->pkeys + i;
			rpk->digest = cpk->digest;
		}
@


1.116
log
@Remove last vestige of SSL_OP_NO_SSLv3 support.

No part of LibreSSL checks for this flag any longer.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.115 2015/10/19 17:59:39 beck Exp $ */
d2850 1
a2854 2
	if (ssl->cert != NULL)
		ssl_cert_free(ssl->cert);
d2856 10
@


1.115
log
@free rbio before wbio
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.114 2015/10/16 14:23:22 beck Exp $ */
a1901 3

	/* Disable SSLv3 by default. */
	ret->options |= SSL_OP_NO_SSLv3;
@


1.114
log
@Fix use of pointer value after BIO_free, and remove senseless NULL checks.
ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.113 2015/10/03 06:47:32 doug Exp $ */
d506 3
a508 3
	if (s->wbio != s->rbio)
		BIO_free_all(s->wbio);
	BIO_free_all(s->rbio);
d575 3
a577 1
	if ((s->wbio != wbio) && (s->rbio != s->wbio))
a578 2
	if (s->rbio != rbio)
		BIO_free_all(s->rbio);
@


1.113
log
@SSL_new(): fix ref counting and memory leak in error path.

Rather than a half-hearted attempt to free up resources and fix
ref counting at the SSL_CTX level, let SSL_free() do its job.

This diff got lost in the shuffle somewhere.  It's from last year.
Ref counting error reported by Parakleta in github ticket #51.  Thanks!

ok jsing@@, beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.112 2015/09/12 19:45:16 jsing Exp $ */
d505 2
a506 3
	if (s->rbio != NULL)
		BIO_free_all(s->rbio);
	if ((s->wbio != NULL) && (s->wbio != s->rbio))
d508 1
d574 4
a577 1
	if ((s->rbio != NULL) && (s->rbio != rbio))
a578 2
	if ((s->wbio != NULL) && (s->wbio != wbio) && (s->rbio != s->wbio))
		BIO_free_all(s->wbio);
@


1.112
log
@Unwrap a bunch of lines.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.111 2015/09/12 16:10:07 doug Exp $ */
d362 1
a363 1
	return (s);
d365 1
a365 6
	if (s != NULL) {
		if (s->cert != NULL)
			ssl_cert_free(s->cert);
		SSL_CTX_free(s->ctx); /* decrement reference count */
		free(s);
	}
@


1.111
log
@Remove most of the SSLv3 version checks and a few TLS v1.0.

We can now assume >= TLS v1.0 since SSL2_VERSION, SSL3_VERSION and
DTLS1_BAD_VER support was removed.

"reads ok" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.110 2015/09/11 17:35:36 jsing Exp $ */
d269 1
a269 2
		SSLerr(SSL_F_SSL_NEW,
		    SSL_R_NULL_SSL_CTX);
d273 1
a273 2
		SSLerr(SSL_F_SSL_NEW,
		    SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);
d371 1
a371 2
	SSLerr(SSL_F_SSL_NEW,
	    ERR_R_MALLOC_FAILURE);
d640 1
a640 2
		SSLerr(SSL_F_SSL_SET_FD,
		    ERR_R_BUF_LIB);
d661 1
a661 2
			SSLerr(SSL_F_SSL_SET_WFD,
			    ERR_R_BUF_LIB);
d684 1
a684 2
			SSLerr(SSL_F_SSL_SET_RFD,
			    ERR_R_BUF_LIB);
d949 1
a949 2
		SSLerr(SSL_F_SSL_READ,
		    SSL_R_UNINITIALIZED);
d964 1
a964 2
		SSLerr(SSL_F_SSL_PEEK,
		    SSL_R_UNINITIALIZED);
d978 1
a978 2
		SSLerr(SSL_F_SSL_WRITE,
		    SSL_R_UNINITIALIZED);
d984 1
a984 2
		SSLerr(SSL_F_SSL_WRITE,
		    SSL_R_PROTOCOL_IS_SHUTDOWN);
d1001 1
a1001 2
		SSLerr(SSL_F_SSL_SHUTDOWN,
		    SSL_R_UNINITIALIZED);
d1311 1
a1311 2
		SSLerr(SSL_F_SSL_CTX_SET_CIPHER_LIST,
		    SSL_R_NO_CIPHER_MATCH);
d1329 1
a1329 2
		SSLerr(SSL_F_SSL_SET_CIPHER_LIST,
		    SSL_R_NO_CIPHER_MATCH);
d1774 1
a1774 2
		SSLerr(SSL_F_SSL_CTX_NEW,
		    SSL_R_NULL_SSL_METHOD_PASSED);
d1840 1
a1840 2
		SSLerr(SSL_F_SSL_CTX_NEW,
		    SSL_R_LIBRARY_HAS_NO_CIPHERS);
d1912 1
a1912 2
	SSLerr(SSL_F_SSL_CTX_NEW,
	    ERR_R_MALLOC_FAILURE);
d2450 1
a2450 2
		SSLerr(SSL_F_SSL_DO_HANDSHAKE,
		    SSL_R_CONNECTION_TYPE_NOT_SET);
d2776 1
a2776 2
		SSLerr(SSL_F_SSL_INIT_WBIO_BUFFER,
		    ERR_R_BUF_LIB);
@


1.110
log
@Nuke ssl_bad_method().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.109 2015/09/11 17:29:36 jsing Exp $ */
a1733 3
	if (s->version < TLS1_VERSION)
		return (-1);

@


1.109
log
@Nuke ssl_replace_hash().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.108 2015/09/10 17:57:50 jsing Exp $ */
a2533 8
}

SSL_METHOD *
ssl_bad_method(int ver)
{
	SSLerr(SSL_F_SSL_BAD_METHOD,
	    ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return (NULL);
@


1.108
log
@Remove support for DTLS_BAD_VER. We do not support non-standard and
incomplete implementations just so that we can interoperate with products
from vendors who have not bothered to fix things in the last ~10 years.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.107 2015/09/09 19:42:39 jsing Exp $ */
a3075 20
}

/*
 * Allocates new EVP_MD_CTX and sets pointer to it into given pointer
 * variable, freeing EVP_MD_CTX previously stored in that variable, if
 * any. If EVP_MD pointer is passed, initializes ctx with this md
 * Returns newly allocated ctx;
 */
EVP_MD_CTX *
ssl_replace_hash(EVP_MD_CTX **hash, const EVP_MD *md)
{
	ssl_clear_hash_ctx(hash);
	*hash = EVP_MD_CTX_create();
	if (*hash != NULL && md != NULL) {
		if (!EVP_DigestInit_ex(*hash, md, NULL)) {
			ssl_clear_hash_ctx(hash);
			return (NULL);
		}
	}
	return (*hash);
@


1.107
log
@Check handshake_func against NULL rather than 0, since it is a function
pointer.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.106 2015/08/27 06:21:15 doug Exp $ */
a2547 2
	case DTLS1_BAD_VER:
		return (SSL_TXT_DTLS1_BAD);
@


1.106
log
@Remove SSLv3 support from LibreSSL.

This is the first wave of SSLv3 removal which removes the main SSLv3
functions.  Future commits will remove the rest of the SSLv3 support.

Discussed the plan at c2k15.  Input from jsing@@, beck@@, miod@@, bcook@@,
sthen@@, naddy@@, and deraadt@@.

ok jsing@@, beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.105 2015/07/19 20:32:18 doug Exp $ */
d930 1
a930 1
	if (s->handshake_func == 0)
d939 1
a939 1
	if (s->handshake_func == 0)
d954 1
a954 1
	if (s->handshake_func == 0) {
d970 1
a970 1
	if (s->handshake_func == 0) {
d985 1
a985 1
	if (s->handshake_func == 0) {
d1010 1
a1010 1
	if (s->handshake_func == 0) {
@


1.105
log
@Allow *_free() functions in libssl to handle NULL input.

This mimics free()'s behavior which makes error handling simpler.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.104 2015/06/28 00:08:27 doug Exp $ */
a2551 2
	case SSL3_VERSION:
		return (SSL_TXT_SSLV3);
a2591 3
	if ((s->options & SSL_OP_NO_SSLv3) == 0 &&
	    max_version >= SSL3_VERSION)
		return (SSL3_VERSION);
@


1.104
log
@Convert ssl_bytes_to_cipher_list to CBS.

Link in the new 'unit' regress and expand the invalid tests to include
some that would fail before the CBS conversion.

input + ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.103 2015/04/15 16:25:43 jsing Exp $ */
d2828 3
@


1.103
log
@Clean up the ssl_bytes_to_cipher_list() API - rather than having the
ability to pass or not pass a STACK_OF(SSL_CIPHER) *, which is then either
zeroed or if NULL a new one is allocated, always allocate one and return it
directly.

Inspired by simliar changes in BoringSSL.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.102 2015/03/27 12:26:41 jsing Exp $ */
d158 2
d1415 1
a1415 1
ssl_bytes_to_cipher_list(SSL *s, unsigned char *p, int num)
d1417 1
a1419 1
	int			 i;
d1421 1
a1421 2
	uint16_t		 cipher_value;
	uint16_t		 max_version;
d1426 4
a1429 1
	if ((num % SSL3_CIPHER_VALUE_SIZE) != 0) {
d1440 8
a1447 2
	for (i = 0; i < num; i += SSL3_CIPHER_VALUE_SIZE) {
		n2s(p, cipher_value);
@


1.102
log
@BUF_MEM_free() has its own explicit NULL check.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.101 2015/02/22 15:54:27 jsing Exp $ */
d1413 1
a1413 2
ssl_bytes_to_cipher_list(SSL *s, unsigned char *p, int num,
    STACK_OF(SSL_CIPHER) **skp)
d1416 1
a1416 1
	STACK_OF(SSL_CIPHER)	*sk;
d1430 4
a1433 7
	if (skp == NULL || *skp == NULL) {
		sk = sk_SSL_CIPHER_new_null(); /* change perhaps later */
		if (sk == NULL)
			goto err;
	} else {
		sk = *skp;
		sk_SSL_CIPHER_zero(sk);
a1484 2
	if (skp != NULL)
		*skp = sk;
d1488 2
a1489 2
	if (skp == NULL || *skp == NULL)
		sk_SSL_CIPHER_free(sk);
@


1.101
log
@Reluctantly add server-side support for TLS_FALLBACK_SCSV.

This allows for clients that willingly choose to perform a downgrade and
attempt to establish a second connection at a lower protocol after the
previous attempt unexpectedly failed, to be notified and have the second
connection aborted, if the server does in fact support a higher protocol.

TLS has perfectly good version negotiation and client-side fallback is
dangerous. Despite this, in order to maintain maximum compatability with
broken web servers, most mainstream browsers implement this. Furthermore,
TLS_FALLBACK_SCSV only works if both the client and server support it and
there is effectively no way to tell if this is the case, unless you control
both ends.

Unfortunately, various auditors and vulnerability scanners (including
certain online assessment websites) consider the presence of a not yet
standardised feature to be important for security, even if the clients do
not perform client-side downgrade or the server only supports current TLS
protocols.

Diff is loosely based on OpenSSL with some inspiration from BoringSSL.

Discussed with beck@@ and miod@@.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.100 2015/02/22 15:29:39 jsing Exp $ */
d191 1
a191 2
		SSLerr(SSL_F_SSL_CLEAR,
		    SSL_R_NO_METHOD_SPECIFIED);
d205 1
a205 2
		SSLerr(SSL_F_SSL_CLEAR,
		    ERR_R_INTERNAL_ERROR);
d218 2
a219 4
	if (s->init_buf != NULL) {
		BUF_MEM_free(s->init_buf);
		s->init_buf = NULL;
	}
d239 1
@


1.100
log
@There is not much point constructing an SSL_CIPHER, then calling
ssl3_cipher_get_value() to get the cipher suite value that we just
put in the struct - use the cipher suite value directly.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.99 2015/02/22 15:19:56 jsing Exp $ */
d1422 1
d1424 1
d1445 1
d1447 5
a1451 3
		/* Check for SCSV */
		if (s->s3 && (SSL3_CK_ID | cipher_value) == SSL3_CK_SCSV) {
			/* SCSV is fatal if renegotiating. */
d1464 19
d2568 30
@


1.99
log
@Remove IMPLEMENT_STACK_OF noops.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.98 2015/02/11 03:19:37 doug Exp $ */
d1409 2
a1410 6
	if (p != q && !s->renegotiate) {
		static SSL_CIPHER scsv = {
			0, NULL, SSL3_CK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0
		};
		s2n(ssl3_cipher_get_value(&scsv), p);
	}
@


1.98
log
@Enable building with -DOPENSSL_NO_DEPRECATED.

If you didn't enable deprecated code, there were missing err.h and
bn.h includes.  This commit allows building with or without deprecated
code.

This was not derived from an OpenSSL commit.  However, they recently
enabled OPENSSL_NO_DEPRECATED in git and fixed these header problems
in a different way.

Verified with clang that this only changes line numbers in the generated
asm.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.97 2015/02/09 07:17:55 doug Exp $ */
a3070 1
IMPLEMENT_STACK_OF(SSL_CIPHER)
@


1.97
log
@Return NULL when there are no shared ciphers.

OpenSSL added this change to avoid an out-of-bounds write since
they're accessing p[-1].  We initialize buf and use strrchr() so we
aren't subject to the same OOB write.

However, we should return NULL rather than an empty string when there
are no shared ciphers.

Also, KNF a particularly bad section above here that miod noticed.

Based on OpenSSL commits:
4ee356686f72ff849f6f3d58562224ace732b1a6
308505b838e4e3ce8485bb30f5b26e2766dc7f8b

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.96 2015/02/07 05:46:01 jsing Exp $ */
d147 1
@


1.96
log
@Clean up the {get,put}_cipher_by_char() implementations. Also use
ssl3_get_cipher_by_value() in other parts of the code where it simplifies
things.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.95 2015/01/22 09:12:57 reyk Exp $ */
d1358 2
a1359 3
	if ((s->session == NULL) || (s->session->ciphers == NULL) ||
		(len < 2))
	return (NULL);
d1362 3
@


1.95
log
@Support CA verification in chroot'ed processes without direct file
access to the certificates.  SSL_CTX_load_verify_mem() is a frontend
to the new X509_STORE_load_mem() function that allows to load the CA
chain from a memory buffer that is holding the PEM-encoded files.
This function allows to handle the verification in privsep'ed code.

Adopted for LibreSSL based on older code from relayd (by pyr@@ and myself)
With feedback and OK bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.94 2014/12/15 00:46:53 doug Exp $ */
a1422 1
	unsigned int		 cipher_id;
a1443 1
		cipher_id = SSL3_CK_ID | cipher_value;
d1446 1
a1446 1
		if (s->s3 && cipher_id == SSL3_CK_SCSV) {
d1460 1
a1460 2
		c = ssl3_get_cipher_by_id(cipher_id);
		if (c != NULL) {
@


1.94
log
@Add error handling for EVP_DigestInit_ex().

A few EVP_DigestInit_ex() calls were left alone since reporting an
error would change the public API.

Changed internal ssl3_cbc_digest_record() to return a value due to the above
change.  It will also now set md_out_size=0 on failure.

This is based on part of BoringSSL's commit to fix malloc crashes:
https://boringssl.googlesource.com/boringssl/+/69a01608f33ab6fe2c3485d94aef1fe9eacf5364

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.93 2014/12/14 14:34:43 jsing Exp $ */
d2863 6
@


1.93
log
@unifdef OPENSSL_NO_NEXTPROTONEG, which is one of the last standing #ifndef
mazes in libssl. NPN is being replaced by ALPN, however it is still going
to be around for a while yet.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.92 2014/12/10 15:36:47 jsing Exp $ */
d3036 6
a3041 2
	if (*hash != NULL && md != NULL)
		EVP_DigestInit_ex(*hash, md, NULL);
@


1.92
log
@Remove support for GOST R 34.10-94 signature authentication, along with
the two ciphersuites that use it. GOST94 public/private keys have been
long obsoleted and libcrypto does not have support for them anyway.

Discussed with Dmitry Eremin-Solenikov.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.91 2014/12/10 14:58:56 jsing Exp $ */
a335 1
# ifndef OPENSSL_NO_NEXTPROTONEG
a336 1
# endif
a560 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a561 1
#endif
a1507 1
# ifndef OPENSSL_NO_NEXTPROTONEG
a1637 1
# endif
a1875 1
# ifndef OPENSSL_NO_NEXTPROTONEG
a1877 1
# endif
@


1.91
log
@Add support for ALPN.

Based on OpenSSL and BoringSSL.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.90 2014/11/16 14:12:47 jsing Exp $ */
a2053 5
	cpk = &(c->pkeys[SSL_PKEY_GOST94]);
	if (cpk->x509 != NULL && cpk->privatekey !=NULL) {
		mask_k |= SSL_kGOST;
		mask_a |= SSL_aGOST94;
	}
a2208 2
	} else if (alg_a & SSL_aGOST94) {
		i = SSL_PKEY_GOST94;
@


1.90
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.89 2014/10/31 15:25:55 jsing Exp $ */
d340 12
d566 1
d1645 69
d1978 2
@


1.89
log
@Add support for automatic DH ephemeral keys.

This allows an SSL server to enable DHE ciphers with a single setting,
which results in an DH key being generated based on the server key length.

Partly based on OpenSSL.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.88 2014/10/31 14:51:01 jsing Exp $ */
d144 1
d146 3
d150 1
a150 1
#include <openssl/lhash.h>
d152 1
a152 2
#include <openssl/ocsp.h>
#include <openssl/dh.h>
@


1.88
log
@Remove support for ephemeral/temporary RSA private keys.

The only use for these is via SSL_OP_EPHEMERAL_RSA (which is effectively
a standards violation) and for RSA sign-only, should only be possible if
you are using an export cipher and have an RSA private key that is more
than 512 bits in size (however we no longer support export ciphers).

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.87 2014/10/18 16:13:16 jsing Exp $ */
d1945 2
a1946 1
	dh_tmp = (c->dh_tmp != NULL || c->dh_tmp_cb != NULL);
d2178 48
@


1.87
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random provides high quality pseudo-random numbers, hence there is no
need to differentiate between "strong" and "pseudo". Furthermore, the
arc4random_buf() function is guaranteed to succeed, which avoids the need
to check for and handle failure, simplifying the code.

It is worth noting that a number of the replaced RAND_bytes() and
RAND_pseudo_bytes() calls were missing return value checks and these
functions can fail for a number of reasons (at least in OpenSSL -
thankfully they were converted to wrappers around arc4random_buf() some
time ago in LibreSSL).

ok beck@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.86 2014/10/15 17:39:34 jsing Exp $ */
d1934 1
a1934 1
	int		 rsa_enc, rsa_tmp, rsa_sign, dh_tmp, dsa_sign;
a1944 1
	rsa_tmp = (c->rsa_tmp != NULL || c->rsa_tmp_cb != NULL);
d1972 1
a1972 1
	if (rsa_enc || (rsa_tmp && rsa_sign))
@


1.86
log
@Disable SSLv3 by default.

SSLv3 has been long known to have weaknesses and the POODLE attack has
once again shown that it is effectively broken/insecure. As such, it is
time to stop enabling a protocol was deprecated almost 15 years ago.

If an application really wants to provide backwards compatibility, at the
cost of security, for now SSL_CTX_clear_option(ctx, SSL_OP_NO_SSLv3) can be
used to re-enable it on a per-application basis.

General agreement from many.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.85 2014/10/03 13:58:18 jsing Exp $ */
a147 1
#include <openssl/rand.h>
d1788 1
d1790 3
a1792 4
	if ((RAND_pseudo_bytes(ret->tlsext_tick_key_name, 16) <= 0)
	    || (RAND_bytes(ret->tlsext_tick_hmac_key, 16) <= 0)
	    || (RAND_bytes(ret->tlsext_tick_aes_key, 16) <= 0))
		ret->options |= SSL_OP_NO_TICKET;
@


1.85
log
@Add support for automatic ephemeral EC keys.

This allows an SSL server to enable ECDHE ciphers with a single setting,
which results in an EC key being generated using the first preference
shared curve.

Based on OpenSSL with inspiration from boringssl.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.84 2014/09/07 12:16:23 jsing Exp $ */
d1827 3
@


1.84
log
@Remove SSL_kDHr, SSL_kDHd and SSL_aDH. No supported ciphersuites use them,
nor do we plan on supporting them.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.83 2014/08/24 14:36:45 jsing Exp $ */
d1946 2
a1947 1
	have_ecdh_tmp = (c->ecdh_tmp != NULL || c->ecdh_tmp_cb != NULL);
@


1.83
log
@Replace the remaining uses of ssl3_put_cipher_by_char() with s2n and a
ssl3_cipher_get_value() helper function, which returns the cipher suite
value for the given cipher.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.82 2014/08/23 14:52:41 jsing Exp $ */
d1932 1
a1932 1
	int		 rsa_enc, rsa_tmp, rsa_sign, dh_tmp, dh_rsa, dh_dsa, dsa_sign;
a1952 3
	cpk = &(c->pkeys[SSL_PKEY_DH_RSA]);
	dh_rsa = (cpk->x509 != NULL && cpk->privatekey != NULL);
	cpk = &(c->pkeys[SSL_PKEY_DH_DSA]);
a1953 1
	dh_dsa = (cpk->x509 != NULL && cpk->privatekey != NULL);
a1975 6
	if (dh_rsa)
		mask_k|=SSL_kDHr;

	if (dh_dsa)
		mask_k|=SSL_kDHd;

a2116 4
	} else if (alg_k & SSL_kDHr) {
		i = SSL_PKEY_DH_RSA;
	} else if (alg_k & SSL_kDHd) {
		i = SSL_PKEY_DH_DSA;
@


1.82
log
@Replace the remaining ssl3_get_cipher_by_char() calls with n2s() and
ssl3_get_cipher_by_id().

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.81 2014/08/11 10:46:19 jsing Exp $ */
d1387 2
a1388 1
		p += ssl3_put_cipher_by_char(c, p);
d1399 1
a1399 1
		p += ssl3_put_cipher_by_char(&scsv, p);
@


1.81
log
@Check the return value of sk_SSL_CIPHER_new_null(), since it allocates
memory and can return NULL.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.80 2014/08/11 01:10:42 jsing Exp $ */
d1411 2
d1432 3
d1436 2
a1437 3
		if (s->s3 && (p[0] == ((SSL3_CK_SCSV >> 8) & 0xff)) &&
		    (p[1] == (SSL3_CK_SCSV & 0xff))) {
			/* SCSV fatal if renegotiating */
a1446 1
			p += SSL3_CIPHER_VALUE_SIZE;
d1450 1
a1450 2
		c = ssl3_get_cipher_by_char(p);
		p += SSL3_CIPHER_VALUE_SIZE;
d1463 1
d1465 1
a1465 1
	if ((skp == NULL) || (*skp == NULL))
@


1.80
log
@Currently, ssl3_put_char_by_bytes(NULL, NULL) is just a long handed way
of writing "2". Add a define for the SSL3_CIPHER_VALUE_SIZE (rather than
using a less-readable hardcoded constant everywhere) and replace the
ssl3_put_char_by_bytes(NULL, NULL) calls with it.

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.79 2014/08/10 14:42:56 jsing Exp $ */
d1420 6
a1425 4
	if ((skp == NULL) || (*skp == NULL))
		sk=sk_SSL_CIPHER_new_null(); /* change perhaps later */
	else {
		sk= *skp;
@


1.79
log
@Since we no longer need to support SSLv2-style cipher lists, start
unravelling the maze of function pointers and callbacks by directly
calling ssl3_{get,put}_cipher_by_char() and removing the
ssl_{get,put}_cipher_by_char macros.

Prompted by similar changes in boringssl.

ok guenther.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.78 2014/07/12 22:33:39 jsing Exp $ */
d1410 1
a1410 1
	int			 i, n;
d1415 1
a1415 2
	n = ssl3_put_cipher_by_char(NULL, NULL);
	if ((num % n) != 0) {
d1427 1
a1427 1
	for (i = 0; i < num; i += n) {
d1429 2
a1430 3
		if (s->s3 && (n != 3 || !p[0]) &&
		    (p[n - 2] == ((SSL3_CK_SCSV >> 8) & 0xff)) &&
		    (p[n - 1] == (SSL3_CK_SCSV & 0xff))) {
d1441 1
a1441 1
			p += n;
d1446 1
a1446 1
		p += n;
@


1.78
log
@The correct name for EDH is DHE, likewise EECDH should be ECDHE.

Based on changes to OpenSSL trunk.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.77 2014/07/12 19:45:53 jsing Exp $ */
d1370 1
a1370 2
ssl_cipher_list_to_bytes(SSL *s, STACK_OF(SSL_CIPHER) *sk, unsigned char *p,
    int (*put_cb)(const SSL_CIPHER *, unsigned char *))
d1372 1
a1372 1
	int		 i, j = 0;
d1382 1
d1387 1
a1387 2
		j = put_cb ? put_cb(c, p) : ssl_put_cipher_by_char(s, c, p);
		p += j;
d1389 1
d1398 1
a1398 3
		j = put_cb ? put_cb(&scsv, p) :
		    ssl_put_cipher_by_char(s, &scsv, p);
		p += j;
d1415 1
a1415 1
	n = ssl_put_cipher_by_char(s, NULL, NULL);
d1447 1
a1447 1
		c = ssl_get_cipher_by_char(s, p);
@


1.78.4.1
log
@disable SSLv3 by default. all agreed.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.78 2014/07/12 22:33:39 jsing Exp $ */
a1824 3

	/* Disable SSLv3 by default. */
	ret->options |= SSL_OP_NO_SSLv3;
@


1.77
log
@Provide ssl_version_string() function, which uses one of those modern C
constructs (a switch statement) and returns the appropriate string defined
by SSL_TXT_* for the given version, including support for DTLSv1 and
DTLSv1-bad. Use this function in SSL_get_version() and SSL_SESSION_print().

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.76 2014/07/12 16:03:37 miod Exp $ */
d1976 1
a1976 1
		mask_k|=SSL_kEDH;
d2025 1
a2025 1
		mask_k|=SSL_kEECDH;
d2111 1
a2111 1
		 * We don't need to look at SSL_kEECDH
d2114 1
a2114 1
		 * EECDH, the check for the auth
@


1.76
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.75 2014/07/12 13:11:53 jsing Exp $ */
d2413 21
d2436 1
a2436 10
	if (s->version == TLS1_2_VERSION)
		return ("TLSv1.2");
	else if (s->version == TLS1_1_VERSION)
		return ("TLSv1.1");
	else if (s->version == TLS1_VERSION)
		return ("TLSv1");
	else if (s->version == SSL3_VERSION)
		return ("SSLv3");
	else
		return ("unknown");
@


1.75
log
@Remove remnants from PSK, KRB5 and SRP.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.74 2014/07/11 09:24:44 beck Exp $ */
d358 1
a358 2
		if (s->ctx != NULL)
			SSL_CTX_free(s->ctx); /* decrement reference count */
d530 1
a530 2
	if (s->initial_ctx)
		SSL_CTX_free(s->initial_ctx);
d546 1
a546 2
	if (s->ctx)
		SSL_CTX_free(s->ctx);
d1831 1
a1831 2
	if (ret != NULL)
		SSL_CTX_free(ret);
d2724 1
a2724 2
	if (ssl->ctx != NULL)
		SSL_CTX_free(ssl->ctx); /* decrement reference count */
@


1.74
log
@Remove the PSK code. We don't need to drag around this
baggage.
ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.73 2014/07/10 11:58:08 jsing Exp $ */
a2139 3
	} else if (alg_a & SSL_aKRB5) {
		/* VRS something else here? */
		return (NULL);
@


1.73
log
@Remove more compression tendrils.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.72 2014/07/10 08:51:15 tedu Exp $ */
a351 4
#ifndef OPENSSL_NO_PSK
	s->psk_client_callback = ctx->psk_client_callback;
	s->psk_server_callback = ctx->psk_server_callback;
#endif
a1389 7
#ifndef OPENSSL_NO_PSK
		/* with PSK there must be client callback set */
		if (((c->algorithm_mkey & SSL_kPSK) ||
		    (c->algorithm_auth & SSL_aPSK)) &&
		    s->psk_client_callback == NULL)
			continue;
#endif /* OPENSSL_NO_PSK */
a1802 5
#ifndef OPENSSL_NO_PSK
	ret->psk_identity_hint = NULL;
	ret->psk_client_callback = NULL;
	ret->psk_server_callback = NULL;
#endif
a1888 3
#ifndef OPENSSL_NO_PSK
	free(a->psk_identity_hint);
#endif
a2031 4
#ifndef OPENSSL_NO_PSK
	mask_k |= SSL_kPSK;
	mask_a |= SSL_aPSK;
#endif
a2893 91
#ifndef OPENSSL_NO_PSK
int
SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *identity_hint)
{
	if (identity_hint != NULL && strlen(identity_hint) >
	    PSK_MAX_IDENTITY_LEN) {
		SSLerr(SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT,
		    SSL_R_DATA_LENGTH_TOO_LONG);
		return (0);
	}
	free(ctx->psk_identity_hint);
	if (identity_hint != NULL) {
		ctx->psk_identity_hint = BUF_strdup(identity_hint);
		if (ctx->psk_identity_hint == NULL)
			return (0);
	} else
		ctx->psk_identity_hint = NULL;
	return (1);
}

int
SSL_use_psk_identity_hint(SSL *s, const char *identity_hint)
{
	if (s == NULL)
		return (0);

	if (s->session == NULL)
		return (1); /* session not created yet, ignored */

	if (identity_hint != NULL &&
	    strlen(identity_hint) > PSK_MAX_IDENTITY_LEN) {
		SSLerr(SSL_F_SSL_USE_PSK_IDENTITY_HINT,
		    SSL_R_DATA_LENGTH_TOO_LONG);
		return (0);
	}
	free(s->session->psk_identity_hint);
	if (identity_hint != NULL) {
		s->session->psk_identity_hint = BUF_strdup(identity_hint);
		if (s->session->psk_identity_hint == NULL)
			return (0);
	} else
		s->session->psk_identity_hint = NULL;
	return (1);
}

const char *
SSL_get_psk_identity_hint(const SSL *s)
{
	if (s == NULL || s->session == NULL)
		return (NULL);
	return (s->session->psk_identity_hint);
}

const char *
SSL_get_psk_identity(const SSL *s)
{
	if (s == NULL || s->session == NULL)
		return (NULL);
	return (s->session->psk_identity);
}

void
SSL_set_psk_client_callback(SSL *s, unsigned int (*cb)(SSL *ssl,
    const char *hint, char *identity, unsigned int max_identity_len,
    unsigned char *psk, unsigned int max_psk_len))
{
	s->psk_client_callback = cb;
}

void
SSL_CTX_set_psk_client_callback(SSL_CTX *ctx, unsigned int (*cb)(SSL *ssl,
    const char *hint, char *identity, unsigned int max_identity_len,
    unsigned char *psk, unsigned int max_psk_len))
{
	ctx->psk_client_callback = cb;
}

void
SSL_set_psk_server_callback(SSL *s, unsigned int (*cb)(SSL *ssl,
    const char *identity, unsigned char *psk, unsigned int max_psk_len))
{
	s->psk_server_callback = cb;
}

void
SSL_CTX_set_psk_server_callback(SSL_CTX *ctx, unsigned int (*cb)(SSL *ssl,
    const char *identity, unsigned char *psk, unsigned int max_psk_len))
{
	ctx->psk_server_callback = cb;
}
#endif
@


1.72
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.71 2014/07/10 08:18:55 bcook Exp $ */
a1898 2
	/* Don't free, since it removes a global database */
	a->comp_methods = NULL;
d3061 1
a3061 3
IMPLEMENT_STACK_OF(SSL_COMP)
IMPLEMENT_OBJ_BSEARCH_GLOBAL_CMP_FN(SSL_CIPHER, SSL_CIPHER,
    ssl_cipher_id);
@


1.71
log
@remove unused ecc_pkey_size.

ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.70 2014/07/09 11:25:42 jsing Exp $ */
a1795 3
	/* No compression for DTLS */
	if (meth->version != DTLS1_VERSION)
		ret->comp_methods = SSL_COMP_get_compression_methods();
a2609 6
#ifndef OPENSSL_NO_COMP
	COMP_CTX_free(s->expand);
	s->expand = NULL;
	COMP_CTX_free(s->compress);
	s->compress = NULL;
#endif
a2638 1
#ifdef OPENSSL_NO_COMP
a2649 18
#else

const COMP_METHOD *
SSL_get_current_compression(SSL *s)
{
	if (s->compress != NULL)
		return (s->compress->meth);
	return (NULL);
}

const COMP_METHOD *
SSL_get_current_expansion(SSL *s)
{
	if (s->expand != NULL)
		return (s->expand->meth);
	return (NULL);
}
#endif
@


1.70
log
@tedu the SSL export cipher handling - since we do not have enabled export
ciphers we no longer need the flags or code to support it.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.69 2014/06/19 21:29:51 tedu Exp $ */
d1960 1
a1960 1
	int		 have_ecc_cert, ecdh_ok, ecdsa_ok, ecc_pkey_size;
a2032 2
		ecc_pkey_size = (ecc_pkey != NULL) ?
		EVP_PKEY_bits(ecc_pkey) : 0;
@


1.69
log
@convert CRYPTO_memcmp to timingsafe_memcmp based on current policy favoring
libc interfaces over libcrypto interfaces. for now we also prefer
timingsafe_memcmp over timingsafe_bcmp, even when the latter is acceptable.
ok beck deraadt matthew miod
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.68 2014/06/17 01:41:01 tedu Exp $ */
d1959 1
a1959 3
	int		 rsa_enc_export, dh_rsa_export, dh_dsa_export;
	int		 rsa_tmp_export, dh_tmp_export, kl;
	unsigned long	 mask_k, mask_a, emask_k, emask_a;
a1968 2
	kl = SSL_C_EXPORT_PKEYLENGTH(cipher);

a1969 2
	rsa_tmp_export = (c->rsa_tmp_cb != NULL ||
	(rsa_tmp && RSA_size(c->rsa_tmp)*8 <= kl));
a1970 2
	dh_tmp_export = (c->dh_tmp_cb != NULL ||
	(dh_tmp && DH_size(c->dh_tmp)*8 <= kl));
a1974 1
	rsa_enc_export = (rsa_enc && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
a1980 1
	dh_rsa_export = (dh_rsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
a1983 1
	dh_dsa_export = (dh_dsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
a1987 5
	emask_k = 0;
	emask_a = 0;



a2001 5
	if (rsa_enc_export || (rsa_tmp_export && (rsa_sign || rsa_enc)))
		emask_k|=SSL_kRSA;

	if (dh_tmp_export)
		emask_k|=SSL_kEDH;
a2007 2
	if (dh_rsa_export)
		emask_k|=SSL_kDHr;
a2010 2
	if (dh_dsa_export)
		emask_k|=SSL_kDHd;
d2012 1
a2012 1
	if (rsa_enc || rsa_sign) {
a2013 2
		emask_a|=SSL_aRSA;
	}
d2015 1
a2015 1
	if (dsa_sign) {
a2016 2
		emask_a|=SSL_aDSS;
	}
a2018 2
	emask_a|=SSL_aNULL;

a2040 1

a2043 4
				if (ecc_pkey_size <= 163) {
					emask_k|=SSL_kECDHr;
					emask_a|=SSL_aECDH;
				}
a2044 1

a2047 4
				if (ecc_pkey_size <= 163) {
					emask_k|=SSL_kECDHe;
					emask_a|=SSL_aECDH;
				}
d2050 1
a2050 1
		if (ecdsa_ok) {
a2051 2
			emask_a|=SSL_aECDSA;
		}
a2055 1
		emask_k|=SSL_kEECDH;
a2060 2
	emask_k |= SSL_kPSK;
	emask_a |= SSL_aPSK;
a2064 2
	c->export_mask_k = emask_k;
	c->export_mask_a = emask_a;
a2076 2
	EVP_PKEY		*pkey = NULL;
	int			 keysize = 0;
a2081 11

	if (SSL_C_IS_EXPORT(cs)) {
		/* ECDH key length in export ciphers must be <= 163 bits */
		pkey = X509_get_pubkey(x);
		if (pkey == NULL)
			return (0);
		keysize = EVP_PKEY_bits(pkey);
		EVP_PKEY_free(pkey);
		if (keysize > 163)
			return (0);
	}
@


1.68
log
@ssl_session_cmp is not a sort function, can use CRYPTO_memcmp here too.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.67 2014/06/13 10:52:24 jsing Exp $ */
d1681 1
a1681 1
	if (CRYPTO_memcmp(a->session_id, b->session_id, a->session_id_length) != 0)
@


1.67
log
@Add an SSL_AEAD_CTX to enable the use of EVP_AEAD with an SSL cipher.
Read and write contexts are also added to the SSL_CTX, along with
supporting code.

Based on Adam Langley's chromium diffs.

Rides the recent SSL library bump.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.66 2014/06/13 04:29:13 miod Exp $ */
d1681 3
a1683 1
	return (memcmp(a->session_id, b->session_id, a->session_id_length));
@


1.66
log
@Remove support for the `opaque PRF input' extension, which draft has expired
7 years ago and never made it into an RFC. That code wasn't compiled in
anyway unless one would define the actual on-the-wire extension id bytes;
crank libssl major.

With help and enlightenment from Brendan MacDonell.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_lib.c,v 1.65 2014/06/12 15:49:31 deraadt Exp $ */
d2662 11
@


1.65
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a538 1
	free(s->tlsext_opaque_prf_input);
@


1.64
log
@More KNF.
@
text
@d1 1
@


1.63
log
@Some KNF and fix the vairable spelling.
@
text
@d2237 1
a2237 2
		SSLerr(SSL_F_SSL_GET_SERVER_SEND_PKEY,
		    ERR_R_INTERNAL_ERROR);
d2277 1
a2277 2
		SSLerr(SSL_F_SSL_GET_SIGN_PKEY,
		    ERR_R_INTERNAL_ERROR);
d3026 2
a3027 2
	if (identity_hint != NULL && strlen(identity_hint) >
	    PSK_MAX_IDENTITY_LEN) {
@


1.62
log
@More manual OPENSSL_NO_EC and OPENSSL_NO_TLSEXT cleanup.
@
text
@d2856 1
a2856 2
SSL_set_info_callback(SSL *ssl,
    void (*cb)(const SSL *ssl, int type, int val))
d2957 2
a2958 3
SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx, RSA *(*cb)(SSL *ssl,
    int is_export,
int keylength))
d2964 2
a2965 3
SSL_set_tmp_rsa_callback(SSL *ssl, RSA *(*cb)(SSL *ssl,
    int is_export,
int keylength))
d3061 3
a3063 4
SSL_set_psk_client_callback(SSL *s,
    unsigned int (*cb)(SSL *ssl, const char *hint,
    char *identity, unsigned int max_identity_len, unsigned char *psk,
    unsigned int max_psk_len))
d3069 3
a3071 4
SSL_CTX_set_psk_client_callback(SSL_CTX *ctx,
    unsigned int (*cb)(SSL *ssl, const char *hint,
    char *identity, unsigned int max_identity_len, unsigned char *psk,
    unsigned int max_psk_len))
d3077 2
a3078 3
SSL_set_psk_server_callback(SSL *s,
    unsigned int (*cb)(SSL *ssl, const char *identity,
    unsigned char *psk, unsigned int max_psk_len))
d3084 2
a3085 3
SSL_CTX_set_psk_server_callback(SSL_CTX *ctx,
    unsigned int (*cb)(SSL *ssl, const char *identity,
    unsigned char *psk, unsigned int max_psk_len))
d3108 1
a3108 1
 * vairable, freeing  EVP_MD_CTX previously stored in that variable, if
@


1.61
log
@unifdef -UDOXYGEN and manually remove the few doxygen comments that are not
wrapped in #ifdef DOXYGEN...

Requested by miod@@
@
text
@d556 1
a556 1
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
@


1.60
log
@ECDH and ECDSA will not work overly well if there is no EC, so unifdef
OPENSSL_NO_EC.

ok tedu@@
@
text
@a0 3
/*! \file ssl/ssl_lib.c
 *  \brief Version independent SSL functions.
 */
a2956 6
/*!
 * \brief Set the callback for generating temporary RSA keys.
 * \param ctx the SSL context.
 * \param cb the callback
 */

a2971 22

#ifdef DOXYGEN
/*!
 * \brief The RSA temporary key callback function.
 * \param ssl the SSL session.
 * \param is_export \c TRUE if the temp RSA key is for an export ciphersuite.
 * \param keylength if \c is_export is \c TRUE, then \c keylength is the size
 * of the required key in bits.
 * \return the temporary RSA key.
 * \sa SSL_CTX_set_tmp_rsa_callback, SSL_set_tmp_rsa_callback
 */

RSA *
cb(SSL *ssl, int is_export, int keylength)
{}
#endif

/*!
 * \brief Set the callback for generating temporary DH keys.
 * \param ctx the SSL context.
 * \param dh the callback
 */
@


1.59
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@a538 1
#ifndef OPENSSL_NO_EC
a540 1
#endif /* OPENSSL_NO_EC */
a2120 1
#ifndef OPENSSL_NO_EC
a2189 1
#endif
@


1.58
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@a324 1
#ifndef OPENSSL_NO_TLSEXT
a338 1
#endif
a535 1
#ifndef OPENSSL_NO_TLSEXT
a549 1
#endif
a1488 1
#ifndef OPENSSL_NO_TLSEXT
a1645 1
#endif
a1804 1
#ifndef OPENSSL_NO_TLSEXT
a1819 1
#endif
a2836 1
#ifndef OPENSSL_NO_TLSEXT
a2838 1
#endif
@


1.57
log
@Make use of SSL_IS_DTLS, SSL_USE_EXPLICIT_IV, SSL_USE_SIGALGS and
SSL_USE_TLS1_2_CIPHERS.

Largely based on OpenSSL head.
@
text
@a217 3
#if 0
	s->read_ahead = s->ctx->read_ahead;
#endif
a229 1
#if 1
a240 1
#endif
a309 3
#if 0
	s->verify_depth = ctx->verify_depth;
#endif
a319 4
#if 0
	s->purpose = ctx->purpose;
	s->trust = ctx->trust;
#endif
a1756 3
#if 0
	ret->verify_depth=-1; /* Don't impose a limit (but x509_lu.c does) */
#endif
a1868 8
#if 0
static void
SSL_COMP_free(SSL_COMP *comp)
{
	free(comp);
}
#endif

d1913 1
a1913 4
#if 0 /* This should never be done, since it removes a global database */
	if (a->comp_methods != NULL)
		sk_SSL_COMP_pop_free(a->comp_methods, SSL_COMP_free);
#else
a1914 1
#endif
a2030 10

#if 0
	/* The match needs to be both kEDH and aRSA or aDSA, so don't worry */
	if ((dh_tmp || dh_rsa || dh_dsa) &&
		(rsa_enc || rsa_sign || dsa_sign))
	mask_k|=SSL_kEDH;
	if ((dh_tmp_export || dh_rsa_export || dh_dsa_export) &&
		(rsa_enc || rsa_sign || dsa_sign))
	emask_k|=SSL_kEDH;
#endif
@


1.56
log
@Any sane platform has stdio. Stop pretending we will ever use a platform
that does not.
"fire bomb" tedu@@
@
text
@d1107 1
a1107 3

		if (SSL_version(s) == DTLS1_VERSION ||
		    SSL_version(s) == DTLS1_BAD_VER) {
@


1.55
log
@no space before label
@
text
@a2897 1
#ifndef OPENSSL_NO_STDIO
a2909 1
#endif
@


1.54
log
@consistent braces
@
text
@d374 1
a374 1
 err:
d667 1
a667 1
 err:
d691 1
a691 1
 err:
d715 1
a715 1
 err:
d1500 1
a1500 1
 err:
d1599 1
a1599 1
 found:
d1877 1
a1877 1
 err:
d1880 1
a1880 1
 err2:
d2703 1
a2703 1
 err:
@


1.53
log
@unidef DH, ECDH, and ECDSA. there's no purpose to a libssl without them.
ok deraadt jsing
@
text
@d2272 1
a2272 1
	} else if (alg_k & SSL_kDHr)
d2274 1
a2274 1
	else if (alg_k & SSL_kDHd)
d2276 1
a2276 1
	else if (alg_a & SSL_aDSS)
d2278 1
a2278 1
	else if (alg_a & SSL_aRSA) {
d2286 1
a2286 1
	} else if (alg_a & SSL_aGOST94)
d2288 1
a2288 1
	else if (alg_a & SSL_aGOST01)
d2290 1
a2290 1
	else { /* if (alg_a & SSL_aNULL) */
d2426 1
a2426 1
		if (BIO_should_read(bio))
d2428 1
a2428 1
		else if (BIO_should_write(bio))
d2439 2
a2440 2
		return (SSL_ERROR_WANT_WRITE);
		else if (BIO_should_io_special(bio)) {
d2453 1
a2453 1
		if (BIO_should_write(bio))
d2455 1
a2455 1
		else if (BIO_should_read(bio)) {
@


1.52
log
@Make it substantially easier to identify protocol version requirements
by adding an enc_flags field to the ssl3_enc_method, specifying four flags
that are used with this field and providing macros for evaluating these
conditions. Currently the version requirements are identified by
continually checking the version number and other criteria.

This change also adds separate SSL3_ENC_METHOD data for TLS v1.1 and v1.2,
since they have different enc_flags from TLS v1.

Based on changes in OpenSSL head.

No objection from miod@@
@
text
@a151 1
#ifndef OPENSSL_NO_DH
a152 1
#endif
a2002 1
#ifndef OPENSSL_NO_ECDH
a2003 1
#endif
a2015 1
#ifndef OPENSSL_NO_DH
a2018 3
#else
	dh_tmp = dh_tmp_export = 0;
#endif
a2019 1
#ifndef OPENSSL_NO_ECDH
a2020 1
#endif
a2120 1
#ifndef OPENSSL_NO_ECDH
a2140 2
#endif
#ifndef OPENSSL_NO_ECDSA
a2144 1
#endif
a2146 1
#ifndef OPENSSL_NO_ECDH
a2150 1
#endif
a3058 1
#ifndef OPENSSL_NO_DH
a3071 1
#endif
a3072 1
#ifndef OPENSSL_NO_ECDH
a3086 1
#endif
@


1.51
log
@When you have functions that perform specific functions, use them.

EVP_CIPHER_CTX_free() does a NULL check, then calls EVP_CIPHER_CTX_cleanup()
and frees the memory. COMP_CTX_free() also had its own NULL check, so there
is no point in duplicating that here.

ok beck@@
@
text
@d185 1
@


1.50
log
@EVP_MD_CTX_create() calls malloc and can return NULL. However, only one of
the calls in libssl actually checks the return value before using it. Add
NULL checks for the remaining three calls.

ok miod@@
@
text
@d2729 5
a2733 10
	if (s->enc_read_ctx != NULL) {
		EVP_CIPHER_CTX_cleanup(s->enc_read_ctx);
		free(s->enc_read_ctx);
		s->enc_read_ctx = NULL;
	}
	if (s->enc_write_ctx != NULL) {
		EVP_CIPHER_CTX_cleanup(s->enc_write_ctx);
		free(s->enc_write_ctx);
		s->enc_write_ctx = NULL;
	}
d2735 4
a2738 8
	if (s->expand != NULL) {
		COMP_CTX_free(s->expand);
		s->expand = NULL;
	}
	if (s->compress != NULL) {
		COMP_CTX_free(s->compress);
		s->compress = NULL;
	}
@


1.49
log
@There is no point in checking if a pointer is non-NULL before calling free,
since free already does this for us. Also remove some pointless NULL
assignments, where the result from malloc(3) is immediately assigned to the
same variable.

ok miod@@
@
text
@d3238 1
a3238 1
	if (md)
@


1.48
log
@remove unused shit. from Alexander Schrijver
@
text
@d552 1
a552 2
	if (s->tlsext_hostname)
		free(s->tlsext_hostname);
d556 2
a557 4
	if (s->tlsext_ecpointformatlist)
		free(s->tlsext_ecpointformatlist);
	if (s->tlsext_ellipticcurvelist)
		free(s->tlsext_ellipticcurvelist);
d559 1
a559 2
	if (s->tlsext_opaque_prf_input)
		free(s->tlsext_opaque_prf_input);
d565 1
a565 2
	if (s->tlsext_ocsp_resp)
		free(s->tlsext_ocsp_resp);
d579 1
a579 2
	if (s->next_proto_negotiated)
		free(s->next_proto_negotiated);
d1890 2
a1891 1
	{ free(comp);
d1952 1
a1952 2
	if (a->psk_identity_hint)
		free(a->psk_identity_hint);
d3126 1
a3126 2
	if (ctx->psk_identity_hint != NULL)
		free(ctx->psk_identity_hint);
d3151 1
a3151 2
	if (s->session->psk_identity_hint != NULL)
		free(s->session->psk_identity_hint);
@


1.47
log
@Remove TLS_DEBUG, SSL_DEBUG, CIPHER_DEBUG and OPENSSL_RI_DEBUG. Much of
this is sporadic, hacked up and can easily be put back in an improved form
should we ever need it.

ok miod@@
@
text
@a1767 4
/*	ret->cipher=NULL;
	ret->master_key=NULL;
*/

@


1.46
log
@I'm so sorry to learn that the Diab compiler can't (or used not to) parse C
code. Remove workaround.
@
text
@a1444 3
#ifdef OPENSSL_RI_DEBUG
		fprintf(stderr, "SCSV sent by client\n");
#endif
a1489 3
#ifdef OPENSSL_RI_DEBUG
			fprintf(stderr, "SCSV received by server\n");
#endif
a2062 6
#ifdef CIPHER_DEBUG
	printf("rt=%d rte=%d dht=%d ecdht=%d re=%d ree=%d "
	    "rs=%d ds=%d dhr=%d dhd=%d\n",
	    rsa_tmp, rsa_tmp_export, dh_tmp, have_ecdh_tmp,
	    rsa_enc, rsa_enc_export, rsa_sign, dsa_sign, dh_rsa, dh_dsa);
#endif
@


1.45
log
@Use C99 initialisers for SSL3_ENC_METHOD structs.

ok miod@@
@
text
@d2966 1
a2966 5
/*
 * One compiler (Diab DCC) doesn't like argument names in returned
 * function pointer.
 */
void (*SSL_get_info_callback(const SSL *ssl))(const SSL * /*ssl*/,int /*type*/,int /*val*/)
@


1.44
log
@Stop including kssl_lcl.h and nuke it from orbit - it is a no-op now.

ok beck@@ miod@@
@
text
@d166 19
a184 16
	(int (*)(SSL *, int))ssl_undefined_function,
	(int (*)(SSL *, unsigned char *, int))ssl_undefined_function,
	ssl_undefined_function,
	(int (*)(SSL *, unsigned char *, unsigned char *, int))ssl_undefined_function,
	(int (*)(SSL*, int))ssl_undefined_function,
	(int (*)(SSL *,  const char*, int, unsigned char *))ssl_undefined_function,
	0,	/* finish_mac_length */
	(int (*)(SSL *, int, unsigned char *))ssl_undefined_function,
	NULL,	/* client_finished_label */
	0,	/* client_finished_label_len */
	NULL,	/* server_finished_label */
	0,	/* server_finished_label_len */
	(int (*)(int))ssl_undefined_function,
	(int (*)(SSL *, unsigned char *, size_t, const char *,
	size_t, const unsigned char *, size_t,
	int use_context)) ssl_undefined_function,
@


1.43
log
@Remove SRP and Kerberos support from libssl. These are complex protocols
all on their own and we can't effectively maintain them without using them,
which we don't. If the need arises, the code can be resurrected.
@
text
@a146 1
#include "kssl_lcl.h"
@


1.42
log
@Nuke OPENSSL_NO_SOCK since any half sane operating system has sockets.

ok beck@@
@
text
@a286 3
#ifndef	OPENSSL_NO_KRB5
	s->kssl_ctx = kssl_ctx_new();
#endif	/* OPENSSL_NO_KRB5 */
a579 4
#ifndef	OPENSSL_NO_KRB5
	if (s->kssl_ctx != NULL)
		kssl_ctx_free(s->kssl_ctx);
#endif	/* OPENSSL_NO_KRB5 */
a1410 3
#ifndef OPENSSL_NO_KRB5
	int		 nokrb5 = !kssl_tgt_is_available(s->kssl_ctx);
#endif /* OPENSSL_NO_KRB5 */
a1421 5
#ifndef OPENSSL_NO_KRB5
		if (((c->algorithm_mkey & SSL_kKRB5) ||
		    (c->algorithm_auth & SSL_aKRB5)) && nokrb5)
			continue;
#endif /* OPENSSL_NO_KRB5 */
a1864 3
#ifndef OPENSSL_NO_SRP
	SSL_CTX_SRP_CTX_init(ret);
#endif
a1967 3
#ifndef OPENSSL_NO_SRP
	SSL_CTX_SRP_CTX_free(a);
#endif
a2128 6
#ifndef OPENSSL_NO_KRB5
	mask_k|=SSL_kKRB5;
	mask_a|=SSL_aKRB5;
	emask_k|=SSL_kKRB5;
	emask_a|=SSL_aKRB5;
#endif
@


1.41
log
@More KNF, things that couldn't be verified with md5(1), and some whitespace
I missed on the first go around.
@
text
@a662 1
#ifndef OPENSSL_NO_SOCK
a729 1
#endif
@


1.40
log
@KNF
@
text
@d10 1
a10 1
 * 
d17 1
a17 1
 * 
d24 1
a24 1
 * 
d39 1
a39 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d42 1
a42 1
 * 
d54 1
a54 1
 * 
d68 1
a68 1
 *    notice, this list of conditions and the following disclaimer. 
d115 1
a115 1
 * ECC cipher suite support in OpenSSL originally developed by 
d206 1
a206 1
		return 0;
d396 1
a396 1
		return 0;
d401 1
a401 1
	return 1;
d410 2
a411 2
		   SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
		return 0;
d416 1
a416 1
	return 1;
d425 1
a425 1
	return 1;
d434 1
a434 1
	return 1;
d451 1
a451 1
		return 0;
d466 1
a466 1
	return X509_VERIFY_PARAM_set_purpose(s->param, purpose);
d472 1
a472 1
	return X509_VERIFY_PARAM_set_purpose(s->param, purpose);
d478 1
a478 1
	return X509_VERIFY_PARAM_set_trust(s->param, trust);
d484 1
a484 1
	return X509_VERIFY_PARAM_set_trust(s->param, trust);
d490 1
a490 1
	return X509_VERIFY_PARAM_set1(ctx->param, vpm);
d496 1
a496 1
	return X509_VERIFY_PARAM_set1(ssl->param, vpm);
d746 1
a746 1
	return ret;
d761 1
a761 1
	return ret;
d774 1
a774 1
	return X509_VERIFY_PARAM_get_depth(s->param);
d777 2
a778 1
int (*SSL_get_verify_callback(const SSL *s))(int, X509_STORE_CTX *)
d792 1
a792 1
	return X509_VERIFY_PARAM_get_depth(ctx->param);
d942 1
a942 1
		return 0;
d988 1
a988 1
		return -1;
d1004 1
a1004 1
		return -1;
d1019 1
a1019 1
		return -1;
d1044 1
a1044 1
		return -1;
d1100 1
a1100 1
		return 1;
d1119 1
a1119 1
			return 0;
d1125 1
a1125 1
			return larg;
d1127 1
a1127 1
		return 0;
d1130 1
a1130 1
			return 0;
d1132 1
a1132 1
		return 1;
d1135 2
a1136 2
			return s->s3->send_connection_binding;
		else return 0;
d1150 1
a1150 1
		return 1;
d1160 1
a1160 1
	return ctx->sessions;
d1178 1
a1178 1
		return 1;
d1234 1
a1234 1
			return 0;
d1236 1
a1236 1
		return 1;
d1250 1
a1250 1
		return 1;
d1343 1
a1343 1
	/* 
d1353 1
a1353 1
		return 0;
d1357 1
a1357 1
		return 0;
d1359 1
a1359 1
	return 1;
d1372 1
a1372 1
		return 0;
d1376 1
a1376 1
		return 0;
d1378 1
a1378 1
	return 1;
d1544 1
a1544 1
		return NULL;
d1546 1
a1546 1
	return s->session && !s->tlsext_hostname ?
d1548 1
a1548 1
	    s->tlsext_hostname;
d1557 2
a1558 2
		return TLSEXT_NAMETYPE_host_name;
	return -1;
d1630 1
a1630 1
	return status;
d1701 1
a1701 1
		return -1;
d1703 2
a1704 2
	return s->method->ssl3_enc->export_keying_material(s, out, olen,
	    label, llen, p, plen, use_context);
d2091 2
a2092 1
	printf("rt=%d rte=%d dht=%d ecdht=%d re=%d ree=%d rs=%d ds=%d dhr=%d dhd=%d\n",
d2252 1
a2252 1
			return 0;
d2256 1
a2256 1
			return 0;
d2270 1
a2270 1
			return 0;
d2278 1
a2278 1
				return 0;
d2287 1
a2287 1
				return 0;
d2296 1
a2296 1
			return 0;
d2300 1
a2300 1
	return 1;
d2360 1
a2360 1
	return c->pkeys + i;
d2370 2
a2371 2
		return NULL;
	return cpk->x509;
d2402 1
a2402 1
	return c->pkeys[idx].privatekey;
d2511 1
a2511 1
				return(SSL_ERROR_SYSCALL); /* unknown */
d2519 1
a2519 2
		else if (BIO_should_read(bio))
			return (SSL_ERROR_WANT_READ);
d2524 2
a2525 1
		else if (BIO_should_io_special(bio)) {
d2566 1
a2566 1
/* 
d2632 1
a2632 1
		return("TLSv1.2");
d2634 1
a2634 1
		return("TLSv1.1");
d2636 1
a2636 1
		return("TLSv1");
d2638 1
a2638 1
		return("SSLv3");
d2640 1
a2640 1
		return("unknown");
d2727 1
a2727 1
	ret->state=s->state; 
d2734 1
a2734 1
	ret->init_num = 0; 
d2746 1
a2746 1
	if (s->cipher_list_by_id != NULL)
d2750 1
d2831 1
a2831 1
	return NULL;
d2837 1
a2837 1
	return NULL;
d2956 1
a2956 1
		return ssl->ctx;
d2999 1
a2999 1
	return ssl->info_callback;
d3030 2
a3031 2
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, argl, argp,
	    new_func, dup_func, free_func);
d3050 2
a3051 2
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, argl, argp,
	    new_func, dup_func, free_func);
d3177 1
a3177 1
		return 0;
d3184 1
a3184 1
			return 0;
d3187 1
a3187 1
	return 1;
d3194 1
a3194 1
		return 0;
d3197 1
a3197 1
		return 1; /* session not created yet, ignored */
d3203 1
a3203 1
		return 0;
d3210 1
a3210 1
			return 0;
d3213 1
a3213 1
	return 1;
d3220 1
a3220 1
		return NULL;
d3228 1
a3228 1
		return NULL;
d3295 1
a3295 1
	return *hash;
d3315 1
a3315 1
	return s->hit;
@


1.39
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@d163 4
a166 1
	/* evil casts, but these functions are only called if there's a library bug */
a187 1

d189 2
a190 1
		SSLerr(SSL_F_SSL_CLEAR, SSL_R_NO_METHOD_SPECIFIED);
d204 2
a205 1
		SSLerr(SSL_F_SSL_CLEAR, ERR_R_INTERNAL_ERROR);
d233 6
a238 3
	/* Check to see if we were changed into a different method, if
	 * so, revert back if we are not doing session-id reuse. */
	if (!s->in_handshake && (s->session == NULL) && (s->method != s->ctx->method)) {
d245 1
a245 1
	s->method->ssl_clear(s);
d253 1
a253 1
	STACK_OF(SSL_CIPHER) *sk;
d260 2
a261 1
		SSLerr(SSL_F_SSL_CTX_SET_SSL_VERSION, SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS);
d270 1
a270 1
	SSL *s;
d273 2
a274 1
		SSLerr(SSL_F_SSL_NEW, SSL_R_NULL_SSL_CTX);
d278 2
a279 1
		SSLerr(SSL_F_SSL_NEW, SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);
d296 2
a297 1
		/* Earlier library versions used to copy the pointer to
d305 2
a306 2
		 * duplicated it once. */

d376 1
a376 1
err:
d384 2
a385 1
	SSLerr(SSL_F_SSL_NEW, ERR_R_MALLOC_FAILURE);
d394 2
a395 1
		SSLerr(SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT, SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
d409 2
a410 1
		SSLerr(SSL_F_SSL_SET_SESSION_ID_CONTEXT, SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
d502 1
a502 1
	int i;
d567 1
a567 1
	X509_EXTENSION_free);
d604 1
a604 2
	/* If the output buffering BIO is still in place, remove it
	 */
d640 2
a641 2
	int ret = -1;
	BIO *b, *r;
d653 2
a654 2
	int ret = -1;
	BIO *b, *r;
d667 2
a668 2
	int ret = 0;
	BIO *bio = NULL;
d673 2
a674 1
		SSLerr(SSL_F_SSL_SET_FD, ERR_R_BUF_LIB);
d680 1
a680 1
err:
d687 2
a688 2
	int ret = 0;
	BIO *bio = NULL;
d691 1
a691 1
		|| ((int)BIO_get_fd(s->rbio, NULL) != fd)) {
d694 3
a696 2
		if (bio == NULL)
				{ SSLerr(SSL_F_SSL_SET_WFD, ERR_R_BUF_LIB);
d704 1
a704 1
err:
d711 2
a712 2
	int ret = 0;
	BIO *bio = NULL;
d715 1
a715 1
		|| ((int)BIO_get_fd(s->wbio, NULL) != fd)) {
d719 2
a720 1
			SSLerr(SSL_F_SSL_SET_RFD, ERR_R_BUF_LIB);
d728 1
a728 1
err:
d738 1
a738 1
	size_t ret = 0;
d753 1
a753 1
	size_t ret = 0;
d829 2
a830 1
	/* SSL_pending cannot work properly if read-ahead is enabled
d843 1
a843 1
	X509 *r;
d861 1
a861 1
	STACK_OF(X509) *r;
d863 2
a864 1
	if ((s == NULL) || (s->session == NULL) || (s->session->sess_cert == NULL))
d869 2
a870 1
	/* If we are a client, cert_chain includes the peer's own
d872 2
a873 2
if we are a server, it does not. */

d877 4
a880 2
/* Now in theory, since the calling process own 't' it should be safe to
 * modify.  We need to be able to read f without being hassled */
d884 1
a884 1
	CERT *tmp;
d889 4
a892 2
	/* what if we are setup as SSLv2 but want to talk SSLv3 or
	 * vice-versa */
d914 4
a917 4
	if ((ctx == NULL) ||
		(ctx->cert == NULL) ||
	(ctx->cert->key->x509 == NULL)) {
		SSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY, SSL_R_NO_CERTIFICATE_ASSIGNED);
d921 2
a922 1
		SSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY, SSL_R_NO_PRIVATE_KEY_ASSIGNED);
d925 2
a926 1
	return (X509_check_private_key(ctx->cert->key->x509, ctx->cert->key->privatekey));
d934 2
a935 1
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY, ERR_R_PASSED_NULL_PARAMETER);
d939 2
a940 1
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY, SSL_R_NO_CERTIFICATE_ASSIGNED);
d944 2
a945 1
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY, SSL_R_NO_CERTIFICATE_ASSIGNED);
d949 2
a950 1
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY, SSL_R_NO_PRIVATE_KEY_ASSIGNED);
d953 2
a954 2
	return(X509_check_private_key(ssl->cert->key->x509,
	ssl->cert->key->privatekey));
d961 1
a961 2
		/* Not properly initialized yet */
	SSL_set_accept_state(s);
d970 1
a970 2
		/* Not properly initialized yet */
	SSL_set_connect_state(s);
d985 2
a986 1
		SSLerr(SSL_F_SSL_READ, SSL_R_UNINITIALIZED);
d1001 2
a1002 1
		SSLerr(SSL_F_SSL_PEEK, SSL_R_UNINITIALIZED);
d1016 2
a1017 1
		SSLerr(SSL_F_SSL_WRITE, SSL_R_UNINITIALIZED);
d1023 2
a1024 1
		SSLerr(SSL_F_SSL_WRITE, SSL_R_PROTOCOL_IS_SHUTDOWN);
d1033 2
a1034 1
	/* Note that this function behaves differently from what one might
d1041 2
a1042 1
		SSLerr(SSL_F_SSL_SHUTDOWN, SSL_R_UNINITIALIZED);
d1077 4
a1080 2
	/* becomes true when negotiation is requested;
	 * false again once a handshake has finished */
d1087 1
a1087 1
	long l;
d1122 1
a1122 1
			SSL_version(s) == DTLS1_BAD_VER) {
d1146 3
a1148 1
		s->msg_callback = (void (*)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))(fp);
d1165 1
a1165 1
	long l;
d1246 3
a1248 1
		ctx->msg_callback = (void (*)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))(fp);
d1259 1
a1259 1
	long l;
d1272 1
a1272 1
	long l;
d1281 4
a1284 2
/** return a STACK of the ciphers available for the SSL and in order of
 * preference */
d1291 1
a1291 2
		} else if ((s->ctx != NULL) &&
		(s->ctx->cipher_list != NULL)) {
d1298 4
a1301 2
/** return a STACK of the ciphers available for the SSL and in order of
 * algorithm id */
d1309 1
a1309 1
		(s->ctx->cipher_list_by_id != NULL)) {
d1316 1
a1316 1
/** The old interface to get the same thing as SSL_get_ciphers() */
d1320 2
a1321 2
	SSL_CIPHER *c;
	STACK_OF(SSL_CIPHER) *sk;
d1334 1
a1334 1
/** specify the ciphers to be used by default by the SSL_CTX */
d1338 1
a1338 1
	STACK_OF(SSL_CIPHER) *sk;
d1341 3
a1343 2
	&ctx->cipher_list_by_id, str);
	/* ssl_create_cipher_list may return an empty stack if it
d1349 2
a1350 1
	 * updated. */
d1354 2
a1355 1
		SSLerr(SSL_F_SSL_CTX_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);
d1361 1
a1361 1
/** specify the ciphers to be used by the SSL */
d1365 1
a1365 1
	STACK_OF(SSL_CIPHER) *sk;
d1373 2
a1374 1
		SSLerr(SSL_F_SSL_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);
d1384 5
a1388 5
	char *end;
	STACK_OF(SSL_CIPHER) *sk;
	SSL_CIPHER *c;
	size_t curlen = 0;
	int i;
d1400 1
a1400 1
			(curlen = strlcat(buf, ":", len)) >= len) {
d1416 3
a1418 3
	int i, j = 0;
	SSL_CIPHER *c;
	unsigned char *q;
d1420 1
a1420 1
	int nokrb5 = !kssl_tgt_is_available(s->kssl_ctx);
d1431 2
a1432 2
			(TLS1_get_client_version(s) < TLS1_2_VERSION))
		continue;
d1434 3
a1436 3
		if (((c->algorithm_mkey & SSL_kKRB5) || (c->algorithm_auth & SSL_aKRB5)) &&
			nokrb5)
		continue;
d1440 4
a1443 3
		if (((c->algorithm_mkey & SSL_kPSK) || (c->algorithm_auth & SSL_aPSK)) &&
			s->psk_client_callback == NULL)
		continue;
d1448 2
a1449 1
	/* If p == q, no ciphers and caller indicates an error. Otherwise
d1456 2
a1457 1
		j = put_cb ? put_cb(&scsv, p) : ssl_put_cipher_by_char(s, &scsv, p);
d1471 4
a1474 3
	const SSL_CIPHER *c;
	STACK_OF(SSL_CIPHER) *sk;
	int i, n;
d1480 2
a1481 1
		SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST, SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);
d1494 2
a1495 2
			(p[n - 2] == ((SSL3_CK_SCSV >> 8) & 0xff)) &&
		(p[n - 1] == (SSL3_CK_SCSV & 0xff))) {
d1498 4
a1501 2
				SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST, SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING);
				ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);
d1517 2
a1518 1
				SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST, ERR_R_MALLOC_FAILURE);
d1527 1
a1527 1
err:
d1535 2
a1536 1
/** return a servername extension value if provided in Client Hello, or NULL.
a1538 1

d1546 2
a1547 2
	s->session->tlsext_hostname :
	s->tlsext_hostname;
d1553 3
a1555 1
	if (s->session && (!s->tlsext_hostname ? s->session->tlsext_hostname : s->tlsext_hostname))
d1561 2
a1562 1
/* SSL_select_next_proto implements the standard protocol selection. It is
d1593 7
a1599 5
SSL_select_next_proto(unsigned char **out, unsigned char *outlen, const unsigned char *server, unsigned int server_len, const unsigned char *client, unsigned int client_len)
{
	unsigned int i, j;
	const unsigned char *result;
	int status = OPENSSL_NPN_UNSUPPORTED;
d1601 4
a1604 1
	/* For each protocol in server preference order, see if we support it. */
d1608 2
a1609 1
				memcmp(&server[i + 1], &client[j + 1], server[i]) == 0) {
d1626 1
a1626 1
	found:
d1632 2
a1633 1
/* SSL_get0_next_proto_negotiated sets *data and *len to point to the client's
d1642 2
a1643 1
SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data, unsigned *len)
d1653 2
a1654 1
/* SSL_CTX_set_next_protos_advertised_cb sets a callback that is called when a
d1661 3
a1663 2
 * The callback should return SSL_TLSEXT_ERR_OK if it wishes to advertise. Otherwise, no
 * such extension will be included in the ServerHello. */
d1665 2
a1666 1
SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *ctx, int (*cb) (SSL *ssl, const unsigned char **out, unsigned int *outlen, void *arg), void *arg)
d1672 2
a1673 1
/* SSL_CTX_set_next_proto_select_cb sets a callback that is called when a
d1684 3
a1686 1
SSL_CTX_set_next_proto_select_cb(SSL_CTX *ctx, int (*cb) (SSL *s, unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg), void *arg)
d1697 1
a1697 1
int use_context)
d1702 2
a1703 3
	return s->method->ssl3_enc->export_keying_material(s, out, olen, label,
	llen, p, plen,
	use_context);
d1709 1
a1709 1
	unsigned long l;
d1712 4
a1715 4
	((unsigned int) a->session_id[0]     )|
	((unsigned int) a->session_id[1]<< 8L)|
	((unsigned long)a->session_id[2]<<16L)|
	((unsigned long)a->session_id[3]<<24L);
d1719 2
a1720 1
/* NB: If this function (or indeed the hash function which uses a sort of
d1724 2
a1725 1
 * with a matching session ID. */
d1736 2
a1737 1
/* These wrapper functions should remain rather than redeclaring
d1740 2
a1741 1
 * ssl.h. */
d1750 1
a1750 1
	SSL_CTX *ret = NULL;
d1753 2
a1754 1
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_NULL_SSL_METHOD_PASSED);
d1759 2
a1760 1
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);
d1827 2
a1828 1
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_LIBRARY_HAS_NO_CIPHERS);
d1837 2
a1838 1
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES);
d1842 2
a1843 1
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES);
d1864 3
a1866 3
		|| (RAND_bytes(ret->tlsext_tick_hmac_key, 16) <= 0)
	|| (RAND_bytes(ret->tlsext_tick_aes_key, 16) <= 0))
	ret->options |= SSL_OP_NO_TICKET;
d1896 2
a1897 1
			eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));
d1904 2
a1905 1
	/* Default is to connect to non-RI servers. When RI is more widely
d1911 4
a1914 3
err:
	SSLerr(SSL_F_SSL_CTX_NEW, ERR_R_MALLOC_FAILURE);
err2:
d1930 1
a1930 1
	int i;
d2011 2
a2012 1
SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(X509_STORE_CTX *, void *), void *arg)
d2034 6
a2039 6
	CERT_PKEY *cpk;
	int rsa_enc, rsa_tmp, rsa_sign, dh_tmp, dh_rsa, dh_dsa, dsa_sign;
	int rsa_enc_export, dh_rsa_export, dh_dsa_export;
	int rsa_tmp_export, dh_tmp_export, kl;
	unsigned long mask_k, mask_a, emask_k, emask_a;
	int have_ecc_cert, ecdh_ok, ecdsa_ok, ecc_pkey_size;
d2041 1
a2041 1
	int have_ecdh_tmp;
d2043 3
a2045 3
	X509 *x = NULL;
	EVP_PKEY *ecc_pkey = NULL;
	int signature_nid = 0, pk_nid = 0, md_nid = 0;
d2091 2
a2092 2
	rsa_tmp, rsa_tmp_export, dh_tmp, have_ecdh_tmp,
	rsa_enc, rsa_enc_export, rsa_sign, dsa_sign, dh_rsa, dh_dsa);
d2157 2
a2158 1
	/* An ECC certificate may be usable for ECDH and/or
d2237 5
a2241 5
	unsigned long alg_k, alg_a;
	EVP_PKEY *pkey = NULL;
	int keysize = 0;
	int signature_nid = 0, md_nid = 0, pk_nid = 0;
	const SSL_CIPHER *cs = s->s3->tmp.new_cipher;
d2266 2
a2267 1
			SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_NOT_FOR_KEY_AGREEMENT);
d2270 2
a2271 1
		if ((alg_k & SSL_kECDHe) && TLS1_get_version(s) < TLS1_2_VERSION) {
d2274 2
a2275 1
				SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_SHOULD_HAVE_SHA1_SIGNATURE);
d2279 2
a2280 1
		if ((alg_k & SSL_kECDHr) && TLS1_get_version(s) < TLS1_2_VERSION) {
a2281 1

d2283 2
a2284 1
				SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_SHOULD_HAVE_RSA_SIGNATURE);
d2292 2
a2293 1
			SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_NOT_FOR_SIGNING);
d2308 3
a2310 3
	unsigned long alg_k, alg_a;
	CERT *c;
	int i;
d2319 2
a2320 1
		/* we don't need to look at SSL_kEECDH
d2335 1
a2335 1
	i = SSL_PKEY_DH_RSA;
d2349 1
a2349 1
	i = SSL_PKEY_GOST94;
d2352 3
a2354 3
	else /* if (alg_a & SSL_aNULL) */
	{
		SSLerr(SSL_F_SSL_GET_SERVER_SEND_PKEY, ERR_R_INTERNAL_ERROR);
d2364 2
a2365 1
	CERT_PKEY *cpk;
d2375 3
a2377 3
	unsigned long alg_a;
	CERT *c;
	int idx = -1;
d2383 2
a2384 2
		(c->pkeys[SSL_PKEY_DSA_SIGN].privatekey != NULL))
	idx = SSL_PKEY_DSA_SIGN;
d2391 2
a2392 2
	(c->pkeys[SSL_PKEY_ECC].privatekey != NULL))
	idx = SSL_PKEY_ECC;
d2394 2
a2395 1
		SSLerr(SSL_F_SSL_GET_SIGN_PKEY, ERR_R_INTERNAL_ERROR);
d2406 1
a2406 1
	int i;
d2408 4
a2411 2
	/* If the session_id_length is 0, we are not supposed to cache it,
	 * and it would be rather hard to do anyway :-) */
d2416 3
a2418 4
	if ((i & mode) && (!s->hit)
		&& ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE)
	|| SSL_CTX_add_session(s->session_ctx, s->session))
	&& (s->session_ctx->new_session_cb != NULL)) {
d2426 4
a2429 4
		((i & mode) == mode)) {
		if ((((mode & SSL_SESS_CACHE_CLIENT)
			?s->session_ctx->stats.sess_connect_good
		:s->session_ctx->stats.sess_accept_good) & 0xff) == 0xff) {
d2444 2
a2445 2
	int conn = -1;
	int ret = 1;
d2470 3
a2472 3
	int reason;
	unsigned long l;
	BIO *bio;
d2518 5
a2522 2
			/* See above (SSL_want_read(s) with BIO_should_write(bio)) */
		return (SSL_ERROR_WANT_READ);
d2548 1
a2548 1
	int ret = 1;
d2551 2
a2552 1
		SSLerr(SSL_F_SSL_DO_HANDSHAKE, SSL_R_CONNECTION_TYPE_NOT_SET);
d2564 4
a2567 2
/* For the next 2 functions, SSL_clear() sets shutdown and so
 * one of these calls will reset it */
d2597 2
a2598 1
	SSLerr(SSL_F_SSL_UNDEFINED_FUNCTION, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d2605 2
a2606 1
	SSLerr(SSL_F_SSL_UNDEFINED_VOID_FUNCTION, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d2613 2
a2614 1
	SSLerr(SSL_F_SSL_UNDEFINED_CONST_FUNCTION, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d2621 2
a2622 1
	SSLerr(SSL_F_SSL_BAD_METHOD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d2660 2
a2661 1
		/* No session has been established yet, so we have to expect
d2664 2
a2665 1
		 * and thus we can't use SSL_copy_session_id. */
d2700 2
a2701 1
	if (!CRYPTO_dup_ex_data(CRYPTO_EX_INDEX_SSL, &ret->ex_data, &s->ex_data))
d2724 2
a2725 1
	ret->state=s->state; /* SSL_dup does not really work at any state, though */
d2727 7
a2733 1
	ret->init_num = 0; /* would have to copy ret->init_buf, ret->init_msg, ret->init_num, ret->init_off */
d2740 2
a2741 1
		if ((ret->cipher_list = sk_SSL_CIPHER_dup(s->cipher_list)) == NULL)
d2745 3
a2747 3
		if ((ret->cipher_list_by_id = sk_SSL_CIPHER_dup(s->cipher_list_by_id))
			== NULL)
	goto err;
d2755 2
a2756 1
			if (sk_X509_NAME_set(sk, i, X509_NAME_dup(xn)) == NULL) {
d2764 1
a2764 1
err:
d2858 1
a2858 1
	BIO *bbio;
d2873 2
a2874 1
		SSLerr(SSL_F_SSL_INIT_WBIO_BUFFER, ERR_R_BUF_LIB);
d2990 4
a2993 2
/* One compiler (Diab DCC) doesn't like argument names in returned
   function pointer.  */
d3028 1
a3028 1
	new_func, dup_func, free_func);
d3048 1
a3048 1
	new_func, dup_func, free_func);
d3151 2
a3152 2
SSL_CTX_set_tmp_ecdh_callback(SSL_CTX *ctx, EC_KEY *(*ecdh)(SSL *ssl, int is_export,
    int keylength))
d3154 2
a3155 1
	SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_TMP_ECDH_CB,(void (*)(void))ecdh);
d3170 4
a3173 2
	if (identity_hint != NULL && strlen(identity_hint) > PSK_MAX_IDENTITY_LEN) {
		SSLerr(SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT, SSL_R_DATA_LENGTH_TOO_LONG);
d3196 4
a3199 2
	if (identity_hint != NULL && strlen(identity_hint) > PSK_MAX_IDENTITY_LEN) {
		SSLerr(SSL_F_SSL_USE_PSK_IDENTITY_HINT, SSL_R_DATA_LENGTH_TOO_LONG);
d3232 1
a3232 1
char *identity, unsigned int max_identity_len, unsigned char *psk,
d3241 1
a3241 1
char *identity, unsigned int max_identity_len, unsigned char *psk,
d3250 1
a3250 1
unsigned char *psk, unsigned int max_psk_len))
d3258 1
a3258 1
unsigned char *psk, unsigned int max_psk_len))
d3265 2
a3266 1
SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))
d3268 2
a3269 1
	SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK, (void (*)(void))cb);
d3273 2
a3274 1
SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))
d3279 2
a3280 1
/* Allocates new EVP_MD_CTX and sets pointer to it into given pointer
a3284 1

a3297 1

d3318 1
a3318 1
ssl_cipher_id);
@


1.38
log
@Chop off more SSLv2 tentacles and start fixing and noting y2038 issues.
APIs that pass times as longs will have to change at some point...
Bump major on both libcrypto and libssl.

ok tedu@@
@
text
@d273 1
a273 1
	s = (SSL *)malloc(sizeof(SSL));
a275 1
	memset(s, 0, sizeof(SSL));
d1687 1
a1687 1
	ret = (SSL_CTX *)malloc(sizeof(SSL_CTX));
a1689 2

	memset(ret, 0, sizeof(SSL_CTX));
@


1.37
log
@More KNF and style consistency tweaks
@
text
@d1715 1
a1715 2
/*	ret->cipher=NULL;*/
/*	ret->s2->challenge=NULL;
a1716 2
	ret->key_arg=NULL;
	ret->s2->conn_id=NULL;
d2340 1
a2340 1
			SSL_CTX_flush_sessions(s->session_ctx,(unsigned long)time(NULL));
@


1.36
log
@whack a bunch of disabled code. ok beck lteo
@
text
@d259 2
a260 2
SSL
*SSL_new(SSL_CTX *ctx)
d607 4
a610 3
BIO
*SSL_get_rbio(const SSL *s)
	{ return (s->rbio);
d613 4
a616 3
BIO
*SSL_get_wbio(const SSL *s)
	{ return (s->wbio);
d824 2
a825 2
X509
*SSL_get_peer_certificate(const SSL *s)
d842 2
a843 2
STACK_OF(X509)
*SSL_get_peer_cert_chain(const SSL *s)
d1120 2
a1121 2
LHASH_OF(SSL_SESSION)
*SSL_CTX_sessions(SSL_CTX *ctx)
d1245 2
a1246 2
STACK_OF(SSL_CIPHER)
*SSL_get_ciphers(const SSL *s)
d1261 2
a1262 2
STACK_OF(SSL_CIPHER)
*ssl_get_ciphers_by_id(SSL *s)
d1276 2
a1277 2
const char
*SSL_get_cipher_list(const SSL *s, int n)
d1336 2
a1337 2
char
*SSL_get_shared_ciphers(const SSL *s, char *buf, int len)
d1419 3
a1421 3
STACK_OF(SSL_CIPHER)
*ssl_bytes_to_cipher_list(SSL *s, unsigned char *p, int num,
STACK_OF(SSL_CIPHER) **skp)
d1486 2
a1487 2
const char
*SSL_get_servername(const SSL *s, const int type)
d1674 2
a1675 2
SSL_CTX
*SSL_CTX_new(const SSL_METHOD *meth)
d2222 2
a2223 2
CERT_PKEY
*ssl_get_server_send_pkey(const SSL *s)
d2277 2
a2278 2
X509
*ssl_get_server_send_cert(const SSL *s)
d2287 2
a2288 2
EVP_PKEY
*ssl_get_sign_pkey(SSL *s, const SSL_CIPHER *cipher, const EVP_MD **pmd)
d2348 2
a2349 2
const SSL_METHOD
*SSL_get_ssl_method(SSL *s)
d2689 2
a2690 2
X509
*SSL_get_certificate(const SSL *s)
d2699 2
a2700 2
EVP_PKEY
*SSL_get_privatekey(SSL *s)
d2708 2
a2709 2
const SSL_CIPHER
*SSL_get_current_cipher(const SSL *s)
d2716 2
a2717 2
const void
*SSL_get_current_compression(SSL *s)
d2722 2
a2723 2
const void
*SSL_get_current_expansion(SSL *s)
d2729 2
a2730 2
const COMP_METHOD
*SSL_get_current_compression(SSL *s)
d2737 2
a2738 2
const COMP_METHOD
*SSL_get_current_expansion(SSL *s)
d2833 2
a2834 2
SSL_CTX
*SSL_get_SSL_CTX(const SSL *ssl)
d2839 2
a2840 2
SSL_CTX
*SSL_set_SSL_CTX(SSL *ssl, SSL_CTX* ctx)
d2925 2
a2926 2
void
*SSL_get_ex_data(const SSL *s, int idx)
d2945 2
a2946 2
void
*SSL_CTX_get_ex_data(const SSL_CTX *s, int idx)
d2957 2
a2958 2
X509_STORE
*SSL_CTX_get_cert_store(const SSL_CTX *ctx)
d3010 2
a3011 2
RSA
*cb(SSL *ssl, int is_export, int keylength)
d3096 2
a3097 2
const char
*SSL_get_psk_identity_hint(const SSL *s)
d3104 2
a3105 2
const char
*SSL_get_psk_identity(const SSL *s)
d3165 2
a3166 2
EVP_MD_CTX
*ssl_replace_hash(EVP_MD_CTX **hash, const EVP_MD *md)
@


1.35
log
@always build in RSA and DSA. ok deraadt miod
@
text
@a199 7
#if 0 /* Disabled since version 1.10 of this file (early return not
       * needed because SSL_clear is not called when doing renegotiation) */
	/* This is set if we are doing dynamic renegotiation so keep
	 * the old cipher.  It is sort of a SSL_clear_lite :-) */
	if (s->renegotiate)
		return (1);
#else
a203 1
#endif
@


1.34
log
@kill REF_PRINT/REF_CHECK debugging framework noone would use
ok miod
@
text
@a1980 1
#ifndef OPENSSL_NO_RSA
a1983 3
#else
	rsa_tmp = rsa_tmp_export = 0;
#endif
a2988 1
#ifndef OPENSSL_NO_RSA
a3003 1
#endif
@


1.33
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a144 3
#ifdef REF_CHECK
#  include <assert.h>
#endif
a502 3
#ifdef REF_PRINT
	REF_PRINT("SSL", s);
#endif
a504 6
#ifdef REF_CHECK
	if (i < 0) {
		fprintf(stderr, "SSL_free, bad reference count\n");
		abort(); /* ok */
	}
#endif
a1865 3
#ifdef REF_PRINT
	REF_PRINT("SSL_CTX", a);
#endif
a1867 6
#ifdef REF_CHECK
	if (i < 0) {
		fprintf(stderr, "SSL_CTX_free, bad reference count\n");
		abort(); /* ok */
	}
#endif
a2795 3
#ifdef REF_CHECK /* not the usual REF_CHECK, but this avoids adding one more preprocessor symbol */
		assert(s->wbio != NULL);
#endif
@


1.32
log
@TANSTAAFL - delete the buf freelist code. if you need a better malloc, get
a better malloc. ok beck deraadt
@
text
@d284 1
a284 1
	s = (SSL *)OPENSSL_malloc(sizeof(SSL));
d383 1
a383 1
		OPENSSL_free(s);
d561 1
a561 1
		OPENSSL_free(s->tlsext_hostname);
d566 1
a566 1
		OPENSSL_free(s->tlsext_ecpointformatlist);
d568 1
a568 1
		OPENSSL_free(s->tlsext_ellipticcurvelist);
d571 1
a571 1
		OPENSSL_free(s->tlsext_opaque_prf_input);
d578 1
a578 1
		OPENSSL_free(s->tlsext_ocsp_resp);
d597 1
a597 1
		OPENSSL_free(s->next_proto_negotiated);
d605 1
a605 1
	OPENSSL_free(s);
d1706 1
a1706 1
	ret = (SSL_CTX *)OPENSSL_malloc(sizeof(SSL_CTX));
d1865 1
a1865 1
	{ OPENSSL_free(comp);
d1936 1
a1936 1
		OPENSSL_free(a->psk_identity_hint);
d1946 1
a1946 1
	OPENSSL_free(a);
d2699 1
a2699 1
		OPENSSL_free(s->enc_read_ctx);
d2704 1
a2704 1
		OPENSSL_free(s->enc_write_ctx);
d3098 1
a3098 1
		OPENSSL_free(ctx->psk_identity_hint);
d3122 1
a3122 1
		OPENSSL_free(s->session->psk_identity_hint);
@


1.31
log
@add back SRP. i was being too greedy.
@
text
@a1828 17
#ifndef OPENSSL_NO_BUF_FREELISTS
	ret->freelist_max_len = SSL_MAX_BUF_FREELIST_LEN_DEFAULT;
	ret->rbuf_freelist = OPENSSL_malloc(sizeof(SSL3_BUF_FREELIST));
	if (!ret->rbuf_freelist)
		goto err;
	ret->rbuf_freelist->chunklen = 0;
	ret->rbuf_freelist->len = 0;
	ret->rbuf_freelist->head = NULL;
	ret->wbuf_freelist = OPENSSL_malloc(sizeof(SSL3_BUF_FREELIST));
	if (!ret->wbuf_freelist) {
		OPENSSL_free(ret->rbuf_freelist);
		goto err;
	}
	ret->wbuf_freelist->chunklen = 0;
	ret->wbuf_freelist->len = 0;
	ret->wbuf_freelist->head = NULL;
#endif
a1868 13
#ifndef OPENSSL_NO_BUF_FREELISTS
static void
ssl_buf_freelist_free(SSL3_BUF_FREELIST *list)
{
	SSL3_BUF_FREELIST_ENTRY *ent, *next;
	for (ent = list->head; ent; ent = next) {
		next = ent->next;
		OPENSSL_free(ent);
	}
	OPENSSL_free(list);
}
#endif

a1943 7
#endif

#ifndef OPENSSL_NO_BUF_FREELISTS
	if (a->wbuf_freelist)
		ssl_buf_freelist_free(a->wbuf_freelist);
	if (a->rbuf_freelist)
		ssl_buf_freelist_free(a->rbuf_freelist);
@


1.30
log
@disentangle SRP code from TLS
@
text
@d1826 3
d1967 3
@


1.29
log
@Kill the bogus "send an SSLv3/TLS hello in SSLv2 format" crap from
the SSLv23_* client code.  The server continues to accept it.  It
also kills the bits for SSL2 SESSIONs; even when the server gets
an SSLv2-style compat handshake, the session that it creates has
the correct version internally.

ok tedu@@ beck@@
@
text
@a1825 3
#ifndef OPENSSL_NO_SRP
	SSL_CTX_SRP_CTX_init(ret);
#endif
a1963 3
#endif
#ifndef OPENSSL_NO_SRP
	SSL_CTX_SRP_CTX_free(a);
@


1.28
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok miod
@
text
@d253 1
a253 1
/** Used to change an SSL_CTXs default SSL method type */
d262 1
a262 2
	&(ctx->cipher_list_by_id),
	meth->version == SSL2_VERSION ? "SSLv2" : SSL_DEFAULT_CIPHER_LIST);
d439 7
a445 5
	/* A quick examination of SSL_SESSION_hash and SSL_SESSION_cmp shows how
	 * we can "construct" a session to give us the desired check - ie. to
	 * find if there's a session in the hash table that would conflict with
	 * any new session built out of this id/id_len and the ssl_version in
	 * use by this SSL. */
a453 10
	/* NB: SSLv2 always uses a fixed 16-byte session ID, so even if a
	 * callback is calling us to check the uniqueness of a shorter ID, it
	 * must be compared as a padded-out ID because that is what it will be
	 * converted to when the callback has finished choosing it. */
	if ((r.ssl_version == SSL2_VERSION) &&
		(id_len < SSL2_SSL_SESSION_ID_LENGTH)) {
		memset(r.session_id + id_len, 0,
		SSL2_SSL_SESSION_ID_LENGTH - id_len);
		r.session_id_length = SSL2_SSL_SESSION_ID_LENGTH;
	}
d1771 4
a1774 5
	ssl_create_cipher_list(ret->method,
	&ret->cipher_list, &ret->cipher_list_by_id,
	meth->version == SSL2_VERSION ? "SSLv2" : SSL_DEFAULT_CIPHER_LIST);
	if (ret->cipher_list == NULL
		|| sk_SSL_CIPHER_num(ret->cipher_list) <= 0) {
a1782 4
	if ((ret->rsa_md5 = EVP_get_digestbyname("ssl2-md5")) == NULL) {
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_UNABLE_TO_LOAD_SSL2_MD5_ROUTINES);
		goto err2;
	}
d2472 10
a2481 9
			/* This one doesn't make too much sense ... We never try
			 * to write to the rbio, and an application program where
			 * rbio and wbio are separate couldn't even know what it
			 * should wait for.
			 * However if we ever set s->rwstate incorrectly
			 * (so that we have SSL_want_read(s) instead of
			 * SSL_want_write(s)) and rbio and wbio *are* the same,
			 * this test works around that bug; so it might be safer
			 * to keep it. */
d2516 3
a2518 8
		if (s->version == SSL2_VERSION) {
			/* assume it is the socket being closed */
			return (SSL_ERROR_ZERO_RETURN);
		} else {
			if ((s->shutdown & SSL_RECEIVED_SHUTDOWN) &&
				(s->s3->warn_alert == SSL_AD_CLOSE_NOTIFY))
			return (SSL_ERROR_ZERO_RETURN);
		}
d2590 2
a2591 2
SSL_METHOD
*ssl_bad_method(int ver)
d2597 2
a2598 2
const char
*SSL_get_version(const SSL *s)
a2607 2
	else if (s->version == SSL2_VERSION)
		return("SSLv2");
d2612 2
a2613 2
SSL
*SSL_dup(SSL *s)
@


1.27
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a1710 7
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (meth->version < TLS1_VERSION)) {
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		return NULL;
	}
#endif

@


1.26
log
@remove last vestiges of OPENSSL_SYS_XXX from src/ssl
ok deraadt@@
@
text
@d163 1
a163 1
const char *SSL_version_str=OPENSSL_VERSION_TEXT;
d165 1
a165 1
SSL3_ENC_METHOD ssl3_undef_enc_method={
d167 1
a167 1
	(int (*)(SSL *,int))ssl_undefined_function,
d181 3
a183 3
		 size_t, const unsigned char *, size_t,
		 int use_context)) ssl_undefined_function,
	};
d185 3
a187 2
int SSL_clear(SSL *s)
	{
d189 4
a192 5
	if (s->method == NULL)
		{
		SSLerr(SSL_F_SSL_CLEAR,SSL_R_NO_METHOD_SPECIFIED);
		return(0);
		}
d194 1
a194 2
	if (ssl_clear_bad_session(s))
		{
d196 2
a197 2
		s->session=NULL;
		}
d199 3
a201 3
	s->error=0;
	s->hit=0;
	s->shutdown=0;
d207 2
a208 1
	if (s->renegotiate) return(1);
d210 2
a211 3
	if (s->renegotiate)
		{
		SSLerr(SSL_F_SSL_CLEAR,ERR_R_INTERNAL_ERROR);
d213 1
a213 1
		}
d216 1
a216 1
	s->type=0;
d218 1
a218 1
	s->state=SSL_ST_BEFORE|((s->server)?SSL_ST_ACCEPT:SSL_ST_CONNECT);
d220 4
a223 4
	s->version=s->method->version;
	s->client_version=s->version;
	s->rwstate=SSL_NOTHING;
	s->rstate=SSL_ST_READ_HEADER;
d225 1
a225 1
	s->read_ahead=s->ctx->read_ahead;
d228 1
a228 2
	if (s->init_buf != NULL)
		{
d230 2
a231 2
		s->init_buf=NULL;
		}
d237 1
a237 1
	s->first_packet=0;
d242 1
a242 2
	if (!s->in_handshake && (s->session == NULL) && (s->method != s->ctx->method))
		{
d244 1
a244 1
		s->method=s->ctx->method;
d246 2
a247 3
			return(0);
		}
	else
d249 3
a251 3
		s->method->ssl_clear(s);
	return(1);
	}
d254 3
a256 2
int SSL_CTX_set_ssl_version(SSL_CTX *ctx,const SSL_METHOD *meth)
	{
d259 1
a259 1
	ctx->method=meth;
d261 6
a266 9
	sk=ssl_create_cipher_list(ctx->method,&(ctx->cipher_list),
		&(ctx->cipher_list_by_id),
		meth->version == SSL2_VERSION ? "SSLv2" : SSL_DEFAULT_CIPHER_LIST);
	if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= 0))
		{
		SSLerr(SSL_F_SSL_CTX_SET_SSL_VERSION,SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS);
		return(0);
		}
	return(1);
d268 2
d271 3
a273 2
SSL *SSL_new(SSL_CTX *ctx)
	{
d276 8
a283 10
	if (ctx == NULL)
		{
		SSLerr(SSL_F_SSL_NEW,SSL_R_NULL_SSL_CTX);
		return(NULL);
		}
	if (ctx->method == NULL)
		{
		SSLerr(SSL_F_SSL_NEW,SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);
		return(NULL);
		}
d285 4
a288 3
	s=(SSL *)OPENSSL_malloc(sizeof(SSL));
	if (s == NULL) goto err;
	memset(s,0,sizeof(SSL));
d294 3
a296 3
	s->options=ctx->options;
	s->mode=ctx->mode;
	s->max_cert_list=ctx->max_cert_list;
d298 1
a298 2
	if (ctx->cert != NULL)
		{
d312 1
a312 2
		}
	else
d315 4
a318 4
	s->read_ahead=ctx->read_ahead;
	s->msg_callback=ctx->msg_callback;
	s->msg_callback_arg=ctx->msg_callback_arg;
	s->verify_mode=ctx->verify_mode;
d320 1
a320 1
	s->verify_depth=ctx->verify_depth;
d322 1
a322 1
	s->sid_ctx_length=ctx->sid_ctx_length;
d324 3
a326 3
	memcpy(&s->sid_ctx,&ctx->sid_ctx,sizeof(s->sid_ctx));
	s->verify_callback=ctx->default_verify_callback;
	s->generate_session_id=ctx->generate_session_id;
d336 1
a336 1
	s->quiet_shutdown=ctx->quiet_shutdown;
d339 2
a340 2
	CRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);
	s->ctx=ctx;
d351 2
a352 2
	CRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);
	s->initial_ctx=ctx;
d358 1
a358 1
	s->verify_result=X509_V_OK;
d360 1
a360 1
	s->method=ctx->method;
d365 2
a366 2
	s->references=1;
	s->server=(ctx->method->ssl_accept == ssl_undefined_function)?0:1;
d373 2
a374 2
	s->psk_client_callback=ctx->psk_client_callback;
	s->psk_server_callback=ctx->psk_server_callback;
d377 1
a377 1
	return(s);
d379 1
a379 2
	if (s != NULL)
		{
a384 3
		}
	SSLerr(SSL_F_SSL_NEW,ERR_R_MALLOC_FAILURE);
	return(NULL);
d386 3
d390 7
a396 7
int SSL_CTX_set_session_id_context(SSL_CTX *ctx,const unsigned char *sid_ctx,
				   unsigned int sid_ctx_len)
    {
    if(sid_ctx_len > sizeof ctx->sid_ctx)
	{
	SSLerr(SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
	return 0;
d398 2
a399 2
    ctx->sid_ctx_length=sid_ctx_len;
    memcpy(ctx->sid_ctx,sid_ctx,sid_ctx_len);
d401 2
a402 2
    return 1;
    }
d404 7
a410 7
int SSL_set_session_id_context(SSL *ssl,const unsigned char *sid_ctx,
			       unsigned int sid_ctx_len)
    {
    if(sid_ctx_len > SSL_MAX_SID_CTX_LENGTH)
	{
	SSLerr(SSL_F_SSL_SET_SESSION_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
	return 0;
d412 2
a413 2
    ssl->sid_ctx_length=sid_ctx_len;
    memcpy(ssl->sid_ctx,sid_ctx,sid_ctx_len);
d415 2
a416 2
    return 1;
    }
d418 3
a420 2
int SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb)
	{
d425 1
a425 1
	}
d427 3
a429 2
int SSL_set_generate_session_id(SSL *ssl, GEN_SESSION_CB cb)
	{
d434 1
a434 1
	}
d436 4
a439 3
int SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,
				unsigned int id_len)
	{
d447 1
a447 1
	if(id_len > sizeof r.session_id)
d457 2
a458 3
	if((r.ssl_version == SSL2_VERSION) &&
			(id_len < SSL2_SSL_SESSION_ID_LENGTH))
		{
d460 1
a460 1
			SSL2_SSL_SESSION_ID_LENGTH - id_len);
d462 1
a462 1
		}
d468 1
a468 1
	}
d470 3
a472 2
int SSL_CTX_set_purpose(SSL_CTX *s, int purpose)
	{
d474 1
a474 1
	}
d476 3
a478 2
int SSL_set_purpose(SSL *s, int purpose)
	{
d480 1
a480 1
	}
d482 3
a484 2
int SSL_CTX_set_trust(SSL_CTX *s, int trust)
	{
d486 1
a486 1
	}
d488 3
a490 2
int SSL_set_trust(SSL *s, int trust)
	{
d492 1
a492 1
	}
d494 3
a496 2
int SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm)
	{
d498 1
a498 1
	}
d500 3
a502 2
int SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm)
	{
d504 1
a504 1
	}
d506 3
a508 2
void SSL_free(SSL *s)
	{
d511 2
a512 2
	if(s == NULL)
	    return;
d514 1
a514 1
	i=CRYPTO_add(&s->references,-1,CRYPTO_LOCK_SSL);
d516 1
a516 1
	REF_PRINT("SSL",s);
d518 2
a519 1
	if (i > 0) return;
d521 2
a522 3
	if (i < 0)
		{
		fprintf(stderr,"SSL_free, bad reference count\n");
d524 1
a524 1
		}
d532 1
a532 2
	if (s->bbio != NULL)
		{
d534 3
a536 4
		if (s->bbio == s->wbio)
			{
			s->wbio=BIO_pop(s->wbio);
			}
d538 2
a539 2
		s->bbio=NULL;
		}
d545 2
a546 1
	if (s->init_buf != NULL) BUF_MEM_free(s->init_buf);
d549 4
a552 2
	if (s->cipher_list != NULL) sk_SSL_CIPHER_free(s->cipher_list);
	if (s->cipher_list_by_id != NULL) sk_SSL_CIPHER_free(s->cipher_list_by_id);
d555 1
a555 2
	if (s->session != NULL)
		{
d558 1
a558 1
		}
d564 2
a565 1
	if (s->cert != NULL) ssl_cert_free(s->cert);
d571 2
a572 1
	if (s->initial_ctx) SSL_CTX_free(s->initial_ctx);
d574 4
a577 2
	if (s->tlsext_ecpointformatlist) OPENSSL_free(s->tlsext_ecpointformatlist);
	if (s->tlsext_ellipticcurvelist) OPENSSL_free(s->tlsext_ellipticcurvelist);
d579 2
a580 1
	if (s->tlsext_opaque_prf_input) OPENSSL_free(s->tlsext_opaque_prf_input);
d583 1
a583 1
						X509_EXTENSION_free);
d591 1
a591 1
		sk_X509_NAME_pop_free(s->client_CA,X509_NAME_free);
d593 2
a594 1
	if (s->method != NULL) s->method->ssl_free(s);
d596 2
a597 1
	if (s->ctx) SSL_CTX_free(s->ctx);
d610 2
a611 2
        if (s->srtp_profiles)
            sk_SRTP_PROTECTION_PROFILE_free(s->srtp_profiles);
d615 1
a615 1
	}
d617 3
a619 2
void SSL_set_bio(SSL *s,BIO *rbio,BIO *wbio)
	{
d622 4
a625 7
	if (s->bbio != NULL)
		{
		if (s->wbio == s->bbio)
			{
			s->wbio=s->wbio->next_bio;
			s->bbio->next_bio=NULL;
			}
d627 1
d632 3
a634 3
	s->rbio=rbio;
	s->wbio=wbio;
	}
d636 4
a639 2
BIO *SSL_get_rbio(const SSL *s)
	{ return(s->rbio); }
d641 4
a644 2
BIO *SSL_get_wbio(const SSL *s)
	{ return(s->wbio); }
d646 5
a650 4
int SSL_get_fd(const SSL *s)
	{
	return(SSL_get_rfd(s));
	}
d652 5
a656 4
int SSL_get_rfd(const SSL *s)
	{
	int ret= -1;
	BIO *b,*r;
d658 2
a659 2
	b=SSL_get_rbio(s);
	r=BIO_find_type(b,BIO_TYPE_DESCRIPTOR);
d661 3
a663 3
		BIO_get_fd(r,&ret);
	return(ret);
	}
d665 5
a669 4
int SSL_get_wfd(const SSL *s)
	{
	int ret= -1;
	BIO *b,*r;
d671 2
a672 2
	b=SSL_get_wbio(s);
	r=BIO_find_type(b,BIO_TYPE_DESCRIPTOR);
d674 3
a676 3
		BIO_get_fd(r,&ret);
	return(ret);
	}
d679 5
a683 4
int SSL_set_fd(SSL *s,int fd)
	{
	int ret=0;
	BIO *bio=NULL;
d685 1
a685 1
	bio=BIO_new(BIO_s_socket());
d687 2
a688 3
	if (bio == NULL)
		{
		SSLerr(SSL_F_SSL_SET_FD,ERR_R_BUF_LIB);
d690 4
a693 4
		}
	BIO_set_fd(bio,fd,BIO_NOCLOSE);
	SSL_set_bio(s,bio,bio);
	ret=1;
d695 2
a696 2
	return(ret);
	}
d698 5
a702 4
int SSL_set_wfd(SSL *s,int fd)
	{
	int ret=0;
	BIO *bio=NULL;
d705 2
a706 3
		|| ((int)BIO_get_fd(s->rbio,NULL) != fd))
		{
		bio=BIO_new(BIO_s_socket());
d709 2
a710 3
			{ SSLerr(SSL_F_SSL_SET_WFD,ERR_R_BUF_LIB); goto err; }
		BIO_set_fd(bio,fd,BIO_NOCLOSE);
		SSL_set_bio(s,SSL_get_rbio(s),bio);
d712 5
a716 3
	else
		SSL_set_bio(s,SSL_get_rbio(s),SSL_get_rbio(s));
	ret=1;
d718 2
a719 2
	return(ret);
	}
d721 5
a725 4
int SSL_set_rfd(SSL *s,int fd)
	{
	int ret=0;
	BIO *bio=NULL;
d728 2
a729 3
		|| ((int)BIO_get_fd(s->wbio,NULL) != fd))
		{
		bio=BIO_new(BIO_s_socket());
d731 2
a732 3
		if (bio == NULL)
			{
			SSLerr(SSL_F_SSL_SET_RFD,ERR_R_BUF_LIB);
a733 3
			}
		BIO_set_fd(bio,fd,BIO_NOCLOSE);
		SSL_set_bio(s,bio,SSL_get_wbio(s));
d735 5
a739 3
	else
		SSL_set_bio(s,SSL_get_wbio(s),SSL_get_wbio(s));
	ret=1;
d741 2
a742 2
	return(ret);
	}
d747 3
a749 2
size_t SSL_get_finished(const SSL *s, void *buf, size_t count)
	{
d751 2
a752 3
	
	if (s->s3 != NULL)
		{
d757 1
a757 1
		}
d759 1
a759 1
	}
d762 3
a764 2
size_t SSL_get_peer_finished(const SSL *s, void *buf, size_t count)
	{
d766 2
a767 3
	
	if (s->s3 != NULL)
		{
d772 1
a772 1
		}
d774 1
a774 1
	}
d777 5
a781 4
int SSL_get_verify_mode(const SSL *s)
	{
	return(s->verify_mode);
	}
d783 3
a785 2
int SSL_get_verify_depth(const SSL *s)
	{
d787 1
a787 1
	}
d789 4
a792 4
int (*SSL_get_verify_callback(const SSL *s))(int,X509_STORE_CTX *)
	{
	return(s->verify_callback);
	}
d794 5
a798 4
int SSL_CTX_get_verify_mode(const SSL_CTX *ctx)
	{
	return(ctx->verify_mode);
	}
d800 3
a802 2
int SSL_CTX_get_verify_depth(const SSL_CTX *ctx)
	{
d804 1
a804 1
	}
d806 4
a809 4
int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int,X509_STORE_CTX *)
	{
	return(ctx->default_verify_callback);
	}
d811 5
a815 4
void SSL_set_verify(SSL *s,int mode,
		    int (*callback)(int ok,X509_STORE_CTX *ctx))
	{
	s->verify_mode=mode;
d817 2
a818 2
		s->verify_callback=callback;
	}
d820 3
a822 2
void SSL_set_verify_depth(SSL *s,int depth)
	{
d824 1
a824 1
	}
d826 5
a830 4
void SSL_set_read_ahead(SSL *s,int yes)
	{
	s->read_ahead=yes;
	}
d832 5
a836 4
int SSL_get_read_ahead(const SSL *s)
	{
	return(s->read_ahead);
	}
d838 3
a840 2
int SSL_pending(const SSL *s)
	{
d848 2
a849 2
	return(s->method->ssl_pending(s));
	}
d851 3
a853 2
X509 *SSL_get_peer_certificate(const SSL *s)
	{
d855 1
a855 1
	
d857 1
a857 1
		r=NULL;
d859 1
a859 1
		r=s->session->peer;
d861 2
a862 1
	if (r == NULL) return(r);
d864 1
a864 1
	CRYPTO_add(&r->references,1,CRYPTO_LOCK_X509);
d866 2
a867 2
	return(r);
	}
d869 3
a871 2
STACK_OF(X509) *SSL_get_peer_cert_chain(const SSL *s)
	{
d873 1
a873 1
	
d875 1
a875 1
		r=NULL;
d877 1
a877 1
		r=s->session->sess_cert->cert_chain;
d880 5
a884 4
	 * certificate; if we are a server, it does not. */
	
	return(r);
	}
d888 3
a890 2
void SSL_copy_session_id(SSL *t,const SSL *f)
	{
d894 1
a894 1
	SSL_set_session(t,SSL_get_session(f));
d898 1
a898 2
	if (t->method != f->method)
		{
d902 1
a902 1
		}
d904 10
a913 11
	tmp=t->cert;
	if (f->cert != NULL)
		{
		CRYPTO_add(&f->cert->references,1,CRYPTO_LOCK_SSL_CERT);
		t->cert=f->cert;
		}
	else
		t->cert=NULL;
	if (tmp != NULL) ssl_cert_free(tmp);
	SSL_set_session_id_context(t,f->sid_ctx,f->sid_ctx_length);
	}
d916 4
a919 3
int SSL_CTX_check_private_key(const SSL_CTX *ctx)
	{
	if (	(ctx == NULL) ||
d921 7
a927 11
		(ctx->cert->key->x509 == NULL))
		{
		SSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);
		return(0);
		}
	if 	(ctx->cert->key->privatekey == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,SSL_R_NO_PRIVATE_KEY_ASSIGNED);
		return(0);
		}
	return(X509_check_private_key(ctx->cert->key->x509, ctx->cert->key->privatekey));
d929 2
d933 9
a941 10
int SSL_check_private_key(const SSL *ssl)
	{
	if (ssl == NULL)
		{
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,ERR_R_PASSED_NULL_PARAMETER);
		return(0);
		}
	if (ssl->cert == NULL)
		{
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);
d943 9
a951 11
		}
	if (ssl->cert->key->x509 == NULL)
		{
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);
		return(0);
		}
	if (ssl->cert->key->privatekey == NULL)
		{
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_PRIVATE_KEY_ASSIGNED);
		return(0);
		}
d953 2
a954 2
		ssl->cert->key->privatekey));
	}
d956 3
a958 2
int SSL_accept(SSL *s)
	{
d961 1
a961 1
		SSL_set_accept_state(s);
d963 2
a964 2
	return(s->method->ssl_accept(s));
	}
d966 3
a968 2
int SSL_connect(SSL *s)
	{
d971 1
a971 1
		SSL_set_connect_state(s);
d973 2
a974 2
	return(s->method->ssl_connect(s));
	}
d976 5
a980 4
long SSL_get_default_timeout(const SSL *s)
	{
	return(s->method->get_timeout());
	}
d982 4
a985 4
int SSL_read(SSL *s,void *buf,int num)
	{
	if (s->handshake_func == 0)
		{
d988 1
a988 1
		}
d990 3
a992 6
	if (s->shutdown & SSL_RECEIVED_SHUTDOWN)
		{
		s->rwstate=SSL_NOTHING;
		return(0);
		}
	return(s->method->ssl_read(s,buf,num));
d994 2
d997 4
a1000 4
int SSL_peek(SSL *s,void *buf,int num)
	{
	if (s->handshake_func == 0)
		{
d1003 1
a1003 1
		}
d1005 2
a1006 5
	if (s->shutdown & SSL_RECEIVED_SHUTDOWN)
		{
		return(0);
		}
	return(s->method->ssl_peek(s,buf,num));
d1008 2
d1011 4
a1014 4
int SSL_write(SSL *s,const void *buf,int num)
	{
	if (s->handshake_func == 0)
		{
d1017 1
a1017 1
		}
d1019 4
a1022 7
	if (s->shutdown & SSL_SENT_SHUTDOWN)
		{
		s->rwstate=SSL_NOTHING;
		SSLerr(SSL_F_SSL_WRITE,SSL_R_PROTOCOL_IS_SHUTDOWN);
		return(-1);
		}
	return(s->method->ssl_write(s,buf,num));
d1024 2
d1027 3
a1029 2
int SSL_shutdown(SSL *s)
	{
d1036 1
a1036 2
	if (s->handshake_func == 0)
		{
d1039 1
a1039 1
		}
d1042 1
a1042 1
		return(s->method->ssl_shutdown(s));
d1044 2
a1045 2
		return(1);
	}
d1047 3
a1049 2
int SSL_renegotiate(SSL *s)
	{
d1051 1
a1051 1
		s->renegotiate=1;
d1053 1
a1053 1
	s->new_session=1;
d1055 2
a1056 2
	return(s->method->ssl_renegotiate(s));
	}
d1058 3
a1060 2
int SSL_renegotiate_abbreviated(SSL *s)
	{
d1062 1
a1062 1
		s->renegotiate=1;
d1064 1
a1064 1
	s->new_session=0;
d1066 2
a1067 2
	return(s->method->ssl_renegotiate(s));
	}
d1069 3
a1071 2
int SSL_renegotiate_pending(SSL *s)
	{
d1075 1
a1075 1
	}
d1077 3
a1079 2
long SSL_ctrl(SSL *s,int cmd,long larg,void *parg)
	{
d1082 1
a1082 2
	switch (cmd)
		{
d1084 1
a1084 1
		return(s->read_ahead);
d1086 3
a1088 3
		l=s->read_ahead;
		s->read_ahead=larg;
		return(l);
d1095 1
a1095 1
		return(s->options|=larg);
d1097 1
a1097 1
		return(s->options&=~larg);
d1099 1
a1099 1
		return(s->mode|=larg);
d1101 1
a1101 1
		return(s->mode &=~larg);
d1103 1
a1103 1
		return(s->max_cert_list);
d1105 3
a1107 3
		l=s->max_cert_list;
		s->max_cert_list=larg;
		return(l);
d1115 1
a1115 2
		    SSL_version(s) == DTLS1_BAD_VER)
			{
d1118 1
a1118 1
			}
d1130 1
a1130 2
		return(s->method->ssl_ctrl(s,cmd,larg,parg));
		}
d1132 1
d1134 4
a1137 4
long SSL_callback_ctrl(SSL *s, int cmd, void (*fp)(void))
	{
	switch(cmd)
		{
d1141 1
a1141 1
		
d1143 1
a1143 2
		return(s->method->ssl_callback_ctrl(s,cmd,fp));
		}
d1145 1
d1147 3
a1149 2
LHASH_OF(SSL_SESSION) *SSL_CTX_sessions(SSL_CTX *ctx)
	{
d1151 1
a1151 1
	}
d1153 3
a1155 2
long SSL_CTX_ctrl(SSL_CTX *ctx,int cmd,long larg,void *parg)
	{
d1158 1
a1158 2
	switch (cmd)
		{
d1160 1
a1160 1
		return(ctx->read_ahead);
d1162 4
a1165 4
		l=ctx->read_ahead;
		ctx->read_ahead=larg;
		return(l);
		
d1171 1
a1171 1
		return(ctx->max_cert_list);
d1173 3
a1175 3
		l=ctx->max_cert_list;
		ctx->max_cert_list=larg;
		return(l);
d1178 3
a1180 3
		l=ctx->session_cache_size;
		ctx->session_cache_size=larg;
		return(l);
d1182 1
a1182 1
		return(ctx->session_cache_size);
d1184 3
a1186 3
		l=ctx->session_cache_mode;
		ctx->session_cache_mode=larg;
		return(l);
d1188 1
a1188 1
		return(ctx->session_cache_mode);
d1191 1
a1191 1
		return(lh_SSL_SESSION_num_items(ctx->sessions));
d1193 1
a1193 1
		return(ctx->stats.sess_connect);
d1195 1
a1195 1
		return(ctx->stats.sess_connect_good);
d1197 1
a1197 1
		return(ctx->stats.sess_connect_renegotiate);
d1199 1
a1199 1
		return(ctx->stats.sess_accept);
d1201 1
a1201 1
		return(ctx->stats.sess_accept_good);
d1203 1
a1203 1
		return(ctx->stats.sess_accept_renegotiate);
d1205 1
a1205 1
		return(ctx->stats.sess_hit);
d1207 1
a1207 1
		return(ctx->stats.sess_cb_hit);
d1209 1
a1209 1
		return(ctx->stats.sess_miss);
d1211 1
a1211 1
		return(ctx->stats.sess_timeout);
d1213 1
a1213 1
		return(ctx->stats.sess_cache_full);
d1215 1
a1215 1
		return(ctx->options|=larg);
d1217 1
a1217 1
		return(ctx->options&=~larg);
d1219 1
a1219 1
		return(ctx->mode|=larg);
d1221 1
a1221 1
		return(ctx->mode&=~larg);
d1228 1
a1228 2
		return(ctx->method->ssl_ctx_ctrl(ctx,cmd,larg,parg));
		}
d1230 1
d1232 4
a1235 4
long SSL_CTX_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)(void))
	{
	switch(cmd)
		{
d1241 1
a1241 2
		return(ctx->method->ssl_ctx_callback_ctrl(ctx,cmd,fp));
		}
d1243 1
d1245 3
a1247 2
int ssl_cipher_id_cmp(const SSL_CIPHER *a, const SSL_CIPHER *b)
	{
d1250 1
a1250 1
	l=a->id-b->id;
d1252 1
a1252 1
		return(0);
d1254 2
a1255 2
		return((l > 0)?1:-1);
	}
d1257 4
a1260 3
int ssl_cipher_ptr_id_cmp(const SSL_CIPHER * const *ap,
			const SSL_CIPHER * const *bp)
	{
d1263 1
a1263 1
	l=(*ap)->id-(*bp)->id;
d1265 1
a1265 1
		return(0);
d1267 2
a1268 2
		return((l > 0)?1:-1);
	}
d1272 9
a1280 13
STACK_OF(SSL_CIPHER) *SSL_get_ciphers(const SSL *s)
	{
	if (s != NULL)
		{
		if (s->cipher_list != NULL)
			{
			return(s->cipher_list);
			}
		else if ((s->ctx != NULL) &&
			(s->ctx->cipher_list != NULL))
			{
			return(s->ctx->cipher_list);
			}
a1281 1
	return(NULL);
d1283 2
d1288 9
a1296 13
STACK_OF(SSL_CIPHER) *ssl_get_ciphers_by_id(SSL *s)
	{
	if (s != NULL)
		{
		if (s->cipher_list_by_id != NULL)
			{
			return(s->cipher_list_by_id);
			}
		else if ((s->ctx != NULL) &&
			(s->ctx->cipher_list_by_id != NULL))
			{
			return(s->ctx->cipher_list_by_id);
			}
a1297 1
	return(NULL);
d1299 2
d1303 3
a1305 2
const char *SSL_get_cipher_list(const SSL *s,int n)
	{
d1309 3
a1311 2
	if (s == NULL) return(NULL);
	sk=SSL_get_ciphers(s);
d1313 6
a1318 5
		return(NULL);
	c=sk_SSL_CIPHER_value(sk,n);
	if (c == NULL) return(NULL);
	return(c->name);
	}
d1321 3
a1323 2
int SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str)
	{
d1325 3
a1327 3
	
	sk=ssl_create_cipher_list(ctx->method,&ctx->cipher_list,
		&ctx->cipher_list_by_id,str);
d1337 1
a1337 2
	else if (sk_SSL_CIPHER_num(sk) == 0)
		{
d1340 1
a1340 1
		}
d1342 1
a1342 1
	}
d1345 3
a1347 2
int SSL_set_cipher_list(SSL *s,const char *str)
	{
d1349 3
a1351 3
	
	sk=ssl_create_cipher_list(s->ctx->method,&s->cipher_list,
		&s->cipher_list_by_id,str);
d1355 1
a1355 2
	else if (sk_SSL_CIPHER_num(sk) == 0)
		{
d1358 1
a1358 1
		}
d1360 1
a1360 1
	}
d1363 3
a1365 2
char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
	{
d1374 1
a1374 1
		return(NULL);
d1376 1
a1376 1
	sk=s->session->ciphers;
d1378 2
a1379 3
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
		{
		c=sk_SSL_CIPHER_value(sk,i);
d1382 1
a1382 2
		    (curlen = strlcat(buf, ":", len)) >= len)
			{
a1385 1
			}
d1387 1
d1391 2
a1392 2
	return(buf);
	}
d1394 5
a1398 4
int ssl_cipher_list_to_bytes(SSL *s,STACK_OF(SSL_CIPHER) *sk,unsigned char *p,
			     int (*put_cb)(const SSL_CIPHER *, unsigned char *))
	{
	int i,j=0;
d1405 3
a1407 2
	if (sk == NULL) return(0);
	q=p;
d1409 2
a1410 3
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
		{
		c=sk_SSL_CIPHER_value(sk,i);
d1412 1
a1412 1
		if ((c->algorithm_ssl & SSL_TLSV1_2) && 
d1414 1
a1414 1
			continue;
d1417 2
a1418 2
		    nokrb5)
		    continue;
d1423 2
a1424 2
		    s->psk_client_callback == NULL)
			continue;
d1426 3
a1428 3
		j = put_cb ? put_cb(c,p) : ssl_put_cipher_by_char(s,c,p);
		p+=j;
		}
d1432 2
a1433 4
	if (p != q && !s->renegotiate)
		{
		static SSL_CIPHER scsv =
			{
d1435 3
a1437 3
			};
		j = put_cb ? put_cb(&scsv,p) : ssl_put_cipher_by_char(s,&scsv,p);
		p+=j;
d1441 1
a1441 1
		}
d1443 2
a1444 2
	return(p-q);
	}
d1446 4
a1449 3
STACK_OF(SSL_CIPHER) *ssl_bytes_to_cipher_list(SSL *s,unsigned char *p,int num,
					       STACK_OF(SSL_CIPHER) **skp)
	{
d1452 1
a1452 1
	int i,n;
d1456 5
a1460 6
	n=ssl_put_cipher_by_char(s,NULL,NULL);
	if ((num%n) != 0)
		{
		SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);
		return(NULL);
		}
d1463 1
a1463 2
	else
		{
d1466 1
a1466 1
		}
d1468 1
a1468 2
	for (i=0; i<num; i+=n)
		{
d1471 2
a1472 3
			(p[n-2] == ((SSL3_CK_SCSV >> 8) & 0xff)) &&
			(p[n-1] == (SSL3_CK_SCSV & 0xff)))
			{
d1474 4
a1477 4
			if (s->renegotiate)
				{
				SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE); 
d1479 1
a1479 1
				}
d1486 1
a1486 1
			}
d1488 5
a1492 7
		c=ssl_get_cipher_by_char(s,p);
		p+=n;
		if (c != NULL)
			{
			if (!sk_SSL_CIPHER_push(sk,c))
				{
				SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,ERR_R_MALLOC_FAILURE);
a1493 1
				}
d1496 1
d1499 2
a1500 2
		*skp=sk;
	return(sk);
d1504 2
a1505 2
	return(NULL);
	}
d1513 3
a1515 2
const char *SSL_get_servername(const SSL *s, const int type)
	{
d1520 3
a1522 3
		s->session->tlsext_hostname :
		s->tlsext_hostname;
	}
d1524 3
a1526 2
int SSL_get_servername_type(const SSL *s)
	{
d1530 1
a1530 1
	}
d1563 3
a1565 2
int SSL_select_next_proto(unsigned char **out, unsigned char *outlen, const unsigned char *server, unsigned int server_len, const unsigned char *client, unsigned int client_len)
	{
d1571 2
a1572 4
	for (i = 0; i < server_len; )
		{
		for (j = 0; j < client_len; )
			{
d1574 1
a1574 2
			    memcmp(&server[i+1], &client[j+1], server[i]) == 0)
				{
d1579 1
a1579 1
				}
d1582 1
a1582 1
			}
d1585 1
a1585 1
		}
d1595 1
a1595 1
	}
d1605 3
a1607 2
void SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data, unsigned *len)
	{
d1625 3
a1627 2
void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *ctx, int (*cb) (SSL *ssl, const unsigned char **out, unsigned int *outlen, void *arg), void *arg)
	{
d1630 1
a1630 1
	}
d1642 3
a1644 2
void SSL_CTX_set_next_proto_select_cb(SSL_CTX *ctx, int (*cb) (SSL *s, unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg), void *arg)
	{
d1647 1
a1647 1
	}
d1651 5
a1655 4
int SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,
	const char *label, size_t llen, const unsigned char *p, size_t plen,
	int use_context)
	{
d1660 3
a1662 3
							   llen, p, plen,
							   use_context);
	}
d1664 3
a1666 2
static unsigned long ssl_session_hash(const SSL_SESSION *a)
	{
d1669 7
a1675 7
	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}
d1682 3
a1684 2
static int ssl_session_cmp(const SSL_SESSION *a,const SSL_SESSION *b)
	{
d1686 1
a1686 1
		return(1);
d1688 3
a1690 3
		return(1);
	return(memcmp(a->session_id,b->session_id,a->session_id_length));
	}
d1696 4
a1699 2
static IMPLEMENT_LHASH_HASH_FN(ssl_session, SSL_SESSION)
static IMPLEMENT_LHASH_COMP_FN(ssl_session, SSL_SESSION)
d1701 4
a1704 3
SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth)
	{
	SSL_CTX *ret=NULL;
d1706 4
a1709 5
	if (meth == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_NULL_SSL_METHOD_PASSED);
		return(NULL);
		}
d1712 1
a1712 2
	if (FIPS_mode() && (meth->version < TLS1_VERSION))	
		{
d1715 1
a1715 1
		}
d1718 2
a1719 3
	if (SSL_get_ex_data_X509_STORE_CTX_idx() < 0)
		{
		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);
d1721 2
a1722 2
		}
	ret=(SSL_CTX *)OPENSSL_malloc(sizeof(SSL_CTX));
d1726 1
a1726 1
	memset(ret,0,sizeof(SSL_CTX));
d1728 1
a1728 1
	ret->method=meth;
d1730 5
a1734 5
	ret->cert_store=NULL;
	ret->session_cache_mode=SSL_SESS_CACHE_SERVER;
	ret->session_cache_size=SSL_SESSION_CACHE_MAX_SIZE_DEFAULT;
	ret->session_cache_head=NULL;
	ret->session_cache_tail=NULL;
d1737 1
a1737 1
	ret->session_timeout=meth->get_timeout();
d1739 4
a1742 4
	ret->new_session_cb=0;
	ret->remove_session_cb=0;
	ret->get_session_cb=0;
	ret->generate_session_id=0;
d1744 1
a1744 1
	memset((char *)&ret->stats,0,sizeof(ret->stats));
d1746 2
a1747 2
	ret->references=1;
	ret->quiet_shutdown=0;
d1753 2
a1754 1
	ret->s2->conn_id=NULL; */
d1756 1
a1756 1
	ret->info_callback=NULL;
d1758 2
a1759 2
	ret->app_verify_callback=0;
	ret->app_verify_arg=NULL;
d1761 5
a1765 5
	ret->max_cert_list=SSL_MAX_CERT_LIST_DEFAULT;
	ret->read_ahead=0;
	ret->msg_callback=0;
	ret->msg_callback_arg=NULL;
	ret->verify_mode=SSL_VERIFY_NONE;
d1769 3
a1771 3
	ret->sid_ctx_length=0;
	ret->default_verify_callback=NULL;
	if ((ret->cert=ssl_cert_new()) == NULL)
d1774 12
a1785 10
	ret->default_passwd_callback=0;
	ret->default_passwd_callback_userdata=NULL;
	ret->client_cert_cb=0;
	ret->app_gen_cookie_cb=0;
	ret->app_verify_cookie_cb=0;

	ret->sessions=lh_SSL_SESSION_new();
	if (ret->sessions == NULL) goto err;
	ret->cert_store=X509_STORE_new();
	if (ret->cert_store == NULL) goto err;
d1788 2
a1789 2
		&ret->cipher_list,&ret->cipher_list_by_id,
		meth->version == SSL2_VERSION ? "SSLv2" : SSL_DEFAULT_CIPHER_LIST);
d1791 2
a1792 3
	    || sk_SSL_CIPHER_num(ret->cipher_list) <= 0)
		{
		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_LIBRARY_HAS_NO_CIPHERS);
d1794 1
a1794 1
		}
d1800 2
a1801 3
	if ((ret->rsa_md5=EVP_get_digestbyname("ssl2-md5")) == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL2_MD5_ROUTINES);
d1803 3
a1805 4
		}
	if ((ret->md5=EVP_get_digestbyname("ssl3-md5")) == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES);
d1807 3
a1809 4
		}
	if ((ret->sha1=EVP_get_digestbyname("ssl3-sha1")) == NULL)
		{
		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES);
d1811 1
a1811 1
		}
d1813 1
a1813 1
	if ((ret->client_CA=sk_X509_NAME_new_null()) == NULL)
d1818 1
a1818 1
	ret->extra_certs=NULL;
d1821 1
a1821 1
		ret->comp_methods=SSL_COMP_get_compression_methods();
d1831 2
a1832 2
		|| (RAND_bytes(ret->tlsext_tick_aes_key, 16) <= 0))
		ret->options |= SSL_OP_NO_TICKET;
d1843 3
a1845 3
	ret->psk_identity_hint=NULL;
	ret->psk_client_callback=NULL;
	ret->psk_server_callback=NULL;
d1859 1
a1859 2
	if (!ret->wbuf_freelist)
		{
d1862 1
a1862 1
		}
d1874 1
a1874 6
	ENGINE *eng;
	eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));
	if (!eng)
		{
		ERR_clear_error();
		ENGINE_load_builtin_engines();
d1876 4
d1881 2
a1882 2
	if (!eng || !SSL_CTX_set_client_cert_engine(ret, eng))
		ERR_clear_error();
d1891 1
a1891 1
	return(ret);
d1893 1
a1893 1
	SSLerr(SSL_F_SSL_CTX_NEW,ERR_R_MALLOC_FAILURE);
d1895 4
a1898 3
	if (ret != NULL) SSL_CTX_free(ret);
	return(NULL);
	}
d1901 4
a1904 2
static void SSL_COMP_free(SSL_COMP *comp)
    { OPENSSL_free(comp); }
d1910 1
a1910 1
	{
d1912 1
a1912 2
	for (ent = list->head; ent; ent = next)
		{
d1915 1
a1915 1
		}
d1917 1
a1917 1
	}
d1920 3
a1922 2
void SSL_CTX_free(SSL_CTX *a)
	{
d1925 2
a1926 1
	if (a == NULL) return;
d1928 1
a1928 1
	i=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_SSL_CTX);
d1930 1
a1930 1
	REF_PRINT("SSL_CTX",a);
d1932 2
a1933 1
	if (i > 0) return;
d1935 2
a1936 3
	if (i < 0)
		{
		fprintf(stderr,"SSL_CTX_free, bad reference count\n");
d1938 1
a1938 1
		}
d1954 1
a1954 1
		SSL_CTX_flush_sessions(a,0);
d1970 1
a1970 1
		sk_X509_NAME_pop_free(a->client_CA,X509_NAME_free);
d1972 1
a1972 1
		sk_X509_pop_free(a->extra_certs,X509_free);
d1975 1
a1975 1
		sk_SSL_COMP_pop_free(a->comp_methods,SSL_COMP_free);
d1981 2
a1982 2
        if (a->srtp_profiles)
                sk_SRTP_PROTECTION_PROFILE_free(a->srtp_profiles);
d2005 1
a2005 1
	}
d2007 5
a2011 4
void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb)
	{
	ctx->default_passwd_callback=cb;
	}
d2013 5
a2017 4
void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx,void *u)
	{
	ctx->default_passwd_callback_userdata=u;
	}
d2019 6
a2024 5
void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(X509_STORE_CTX *,void *), void *arg)
	{
	ctx->app_verify_callback=cb;
	ctx->app_verify_arg=arg;
	}
d2026 6
a2031 5
void SSL_CTX_set_verify(SSL_CTX *ctx,int mode,int (*cb)(int, X509_STORE_CTX *))
	{
	ctx->verify_mode=mode;
	ctx->default_verify_callback=cb;
	}
d2033 3
a2035 2
void SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth)
	{
d2037 1
a2037 1
	}
d2039 3
a2041 2
void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)
	{
d2043 4
a2046 4
	int rsa_enc,rsa_tmp,rsa_sign,dh_tmp,dh_rsa,dh_dsa,dsa_sign;
	int rsa_enc_export,dh_rsa_export,dh_dsa_export;
	int rsa_tmp_export,dh_tmp_export,kl;
	unsigned long mask_k,mask_a,emask_k,emask_a;
d2055 2
a2056 1
	if (c == NULL) return;
d2058 1
a2058 1
	kl=SSL_C_EXPORT_PKEYLENGTH(cipher);
d2061 3
a2063 3
	rsa_tmp=(c->rsa_tmp != NULL || c->rsa_tmp_cb != NULL);
	rsa_tmp_export=(c->rsa_tmp_cb != NULL ||
		(rsa_tmp && RSA_size(c->rsa_tmp)*8 <= kl));
d2065 1
a2065 1
	rsa_tmp=rsa_tmp_export=0;
d2068 3
a2070 3
	dh_tmp=(c->dh_tmp != NULL || c->dh_tmp_cb != NULL);
	dh_tmp_export=(c->dh_tmp_cb != NULL ||
		(dh_tmp && DH_size(c->dh_tmp)*8 <= kl));
d2072 1
a2072 1
	dh_tmp=dh_tmp_export=0;
d2076 1
a2076 1
	have_ecdh_tmp=(c->ecdh_tmp != NULL || c->ecdh_tmp_cb != NULL);
d2078 11
a2088 11
	cpk= &(c->pkeys[SSL_PKEY_RSA_ENC]);
	rsa_enc= (cpk->x509 != NULL && cpk->privatekey != NULL);
	rsa_enc_export=(rsa_enc && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
	cpk= &(c->pkeys[SSL_PKEY_RSA_SIGN]);
	rsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);
	cpk= &(c->pkeys[SSL_PKEY_DSA_SIGN]);
	dsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);
	cpk= &(c->pkeys[SSL_PKEY_DH_RSA]);
	dh_rsa=  (cpk->x509 != NULL && cpk->privatekey != NULL);
	dh_rsa_export=(dh_rsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
	cpk= &(c->pkeys[SSL_PKEY_DH_DSA]);
d2090 9
a2098 8
	dh_dsa=  (cpk->x509 != NULL && cpk->privatekey != NULL);
	dh_dsa_export=(dh_dsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
	cpk= &(c->pkeys[SSL_PKEY_ECC]);
	have_ecc_cert= (cpk->x509 != NULL && cpk->privatekey != NULL);
	mask_k=0;
	mask_a=0;
	emask_k=0;
	emask_a=0;
a2099 1
	
d2103 2
a2104 2
	        rsa_tmp,rsa_tmp_export,dh_tmp,have_ecdh_tmp,
		rsa_enc,rsa_enc_export,rsa_sign,dsa_sign,dh_rsa,dh_dsa);
d2106 1
a2106 1
	
d2125 1
a2125 1
	if (	(dh_tmp || dh_rsa || dh_dsa) &&
d2127 1
a2127 1
		mask_k|=SSL_kEDH;
d2130 1
a2130 1
		emask_k|=SSL_kEDH;
d2139 9
a2147 5
	if (dh_rsa) mask_k|=SSL_kDHr;
	if (dh_rsa_export) emask_k|=SSL_kDHr;

	if (dh_dsa) mask_k|=SSL_kDHd;
	if (dh_dsa_export) emask_k|=SSL_kDHd;
d2149 1
a2149 2
	if (rsa_enc || rsa_sign)
		{
d2152 1
a2152 1
		}
d2154 1
a2154 2
	if (dsa_sign)
		{
d2157 1
a2157 1
		}
d2172 1
a2172 2
	if (have_ecc_cert)
		{
d2177 1
a2177 1
		    (x->ex_kusage & X509v3_KU_KEY_AGREEMENT) : 1;
d2179 1
a2179 1
		    (x->ex_kusage & X509v3_KU_DIGITAL_SIGNATURE) : 1;
d2182 1
a2182 1
		    EVP_PKEY_bits(ecc_pkey) : 0;
d2184 1
a2184 2
		if ((x->sig_alg) && (x->sig_alg->algorithm))
			{
d2187 1
a2187 1
			}
d2189 1
a2189 2
		if (ecdh_ok)
			{
d2191 1
a2191 2
			if (pk_nid == NID_rsaEncryption || pk_nid == NID_rsa)
				{
d2194 1
a2194 2
				if (ecc_pkey_size <= 163)
					{
a2196 1
					}
d2198 1
d2200 1
a2200 2
			if (pk_nid == NID_X9_62_id_ecPublicKey)
				{
d2203 1
a2203 2
				if (ecc_pkey_size <= 163)
					{
a2205 1
					}
d2208 1
d2211 1
a2211 2
		if (ecdsa_ok)
			{
d2214 1
a2214 1
			}
d2216 1
a2216 1
		}
d2219 1
a2219 2
	if (have_ecdh_tmp)
		{
d2222 1
a2222 1
		}
d2232 6
a2237 6
	c->mask_k=mask_k;
	c->mask_a=mask_a;
	c->export_mask_k=emask_k;
	c->export_mask_a=emask_a;
	c->valid=1;
	}
d2245 3
a2247 2
int ssl_check_srvr_ecc_cert_and_alg(X509 *x, SSL *s)
	{
d2257 1
a2257 2
	if (SSL_C_IS_EXPORT(cs))
		{
d2260 2
a2261 1
		if (pkey == NULL) return 0;
d2264 3
a2266 2
		if (keysize > 163) return 0;
		}
d2270 1
a2270 2
	if ((x->sig_alg) && (x->sig_alg->algorithm))
		{
d2273 2
a2274 3
		}
	if (alg_k & SSL_kECDHe || alg_k & SSL_kECDHr)
		{
d2276 1
a2276 2
		if (ku_reject(x, X509v3_KU_KEY_AGREEMENT))
			{
d2279 2
a2280 3
			}
		if ((alg_k & SSL_kECDHe) && TLS1_get_version(s) < TLS1_2_VERSION)
			{
d2282 1
a2282 2
			if (pk_nid != NID_X9_62_id_ecPublicKey)
				{
a2284 1
				}
d2286 2
a2287 2
		if ((alg_k & SSL_kECDHr) && TLS1_get_version(s) < TLS1_2_VERSION)
			{
d2290 1
a2290 2
			if (pk_nid != NID_rsaEncryption && pk_nid != NID_rsa)
				{
a2292 1
				}
d2295 2
a2296 2
	if (alg_a & SSL_aECDSA)
		{
d2298 1
a2298 2
		if (ku_reject(x, X509v3_KU_DIGITAL_SIGNATURE))
			{
a2300 1
			}
a2301 2

	return 1;  /* all checks are ok */
d2304 4
d2311 4
a2314 3
CERT_PKEY *ssl_get_server_send_pkey(const SSL *s)
	{
	unsigned long alg_k,alg_a;
d2318 1
a2318 1
	c=s->cert;
d2320 1
a2320 1
	
d2324 1
a2324 2
	if (alg_k & (SSL_kECDHr|SSL_kECDHe))
		{
d2336 5
a2340 8
		i=SSL_PKEY_ECC;
		}
	else if (alg_a & SSL_aECDSA)
		{
		i=SSL_PKEY_ECC;
		}
	else if (alg_k & SSL_kDHr)
		i=SSL_PKEY_DH_RSA;
d2342 1
a2342 1
		i=SSL_PKEY_DH_DSA;
d2344 2
a2345 3
		i=SSL_PKEY_DSA_SIGN;
	else if (alg_a & SSL_aRSA)
		{
d2347 1
a2347 1
			i=SSL_PKEY_RSA_SIGN;
d2349 2
a2350 4
			i=SSL_PKEY_RSA_ENC;
		}
	else if (alg_a & SSL_aKRB5)
		{
d2352 3
a2354 4
		return(NULL);
		}
	else if (alg_a & SSL_aGOST94) 
		i=SSL_PKEY_GOST94;
d2356 1
a2356 1
		i=SSL_PKEY_GOST01;
d2358 4
a2361 4
		{
		SSLerr(SSL_F_SSL_GET_SERVER_SEND_PKEY,ERR_R_INTERNAL_ERROR);
		return(NULL);
		}
d2364 1
a2364 1
	}
d2366 3
a2368 2
X509 *ssl_get_server_send_cert(const SSL *s)
	{
d2374 1
a2374 1
	}
d2376 3
a2378 2
EVP_PKEY *ssl_get_sign_pkey(SSL *s,const SSL_CIPHER *cipher, const EVP_MD **pmd)
	{
d2384 1
a2384 1
	c=s->cert;
d2388 2
a2389 3
		idx = SSL_PKEY_DSA_SIGN;
	else if (alg_a & SSL_aRSA)
		{
d2394 7
a2400 9
		}
	else if ((alg_a & SSL_aECDSA) &&
	         (c->pkeys[SSL_PKEY_ECC].privatekey != NULL))
		idx = SSL_PKEY_ECC;
	if (idx == -1)
		{
		SSLerr(SSL_F_SSL_GET_SIGN_PKEY,ERR_R_INTERNAL_ERROR);
		return(NULL);
		}
d2404 1
a2404 1
	}
d2406 3
a2408 2
void ssl_update_cache(SSL *s,int mode)
	{
d2413 2
a2414 1
	if (s->session->session_id_length == 0) return;
d2416 1
a2416 1
	i=s->session_ctx->session_cache_mode;
d2419 4
a2422 5
		    || SSL_CTX_add_session(s->session_ctx,s->session))
		&& (s->session_ctx->new_session_cb != NULL))
		{
		CRYPTO_add(&s->session->references,1,CRYPTO_LOCK_SSL_SESSION);
		if (!s->session_ctx->new_session_cb(s,s->session))
d2424 1
a2424 1
		}
d2428 2
a2429 3
		((i & mode) == mode))
		{
		if (  (((mode & SSL_SESS_CACHE_CLIENT)
d2431 1
a2431 2
			:s->session_ctx->stats.sess_accept_good) & 0xff) == 0xff)
			{
a2432 1
			}
d2435 1
d2437 5
a2441 4
const SSL_METHOD *SSL_get_ssl_method(SSL *s)
	{
	return(s->method);
	}
d2443 5
a2447 4
int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
	{
	int conn= -1;
	int ret=1;
d2449 1
a2449 2
	if (s->method != meth)
		{
d2451 1
a2451 1
			conn=(s->handshake_func == s->method->ssl_connect);
d2454 2
a2455 3
			s->method=meth;
		else
			{
d2457 3
a2459 3
			s->method=meth;
			ret=s->method->ssl_new(s);
			}
d2462 1
a2462 1
			s->handshake_func=meth->ssl_connect;
d2464 1
a2464 3
			s->handshake_func=meth->ssl_accept;
		}
	return(ret);
d2466 2
d2469 3
a2471 2
int SSL_get_error(const SSL *s,int i)
	{
d2476 2
a2477 1
	if (i > 0) return(SSL_ERROR_NONE);
d2481 1
a2481 2
	if ((l=ERR_peek_error()) != 0)
		{
d2483 1
a2483 1
			return(SSL_ERROR_SYSCALL);
d2485 2
a2486 2
			return(SSL_ERROR_SSL);
		}
d2488 2
a2489 3
	if ((i < 0) && SSL_want_read(s))
		{
		bio=SSL_get_rbio(s);
d2491 1
a2491 1
			return(SSL_ERROR_WANT_READ);
d2502 3
a2504 4
			return(SSL_ERROR_WANT_WRITE);
		else if (BIO_should_io_special(bio))
			{
			reason=BIO_get_retry_reason(bio);
d2506 1
a2506 1
				return(SSL_ERROR_WANT_CONNECT);
d2508 1
a2508 1
				return(SSL_ERROR_WANT_ACCEPT);
a2510 1
			}
d2512 1
d2514 2
a2515 3
	if ((i < 0) && SSL_want_write(s))
		{
		bio=SSL_get_wbio(s);
d2517 1
a2517 1
			return(SSL_ERROR_WANT_WRITE);
d2520 3
a2522 4
			return(SSL_ERROR_WANT_READ);
		else if (BIO_should_io_special(bio))
			{
			reason=BIO_get_retry_reason(bio);
d2524 1
a2524 1
				return(SSL_ERROR_WANT_CONNECT);
d2526 1
a2526 1
				return(SSL_ERROR_WANT_ACCEPT);
d2528 1
a2528 6
				return(SSL_ERROR_SYSCALL);
			}
		}
	if ((i < 0) && SSL_want_x509_lookup(s))
		{
		return(SSL_ERROR_WANT_X509_LOOKUP);
d2530 4
d2535 2
a2536 4
	if (i == 0)
		{
		if (s->version == SSL2_VERSION)
			{
d2538 2
a2539 4
			return(SSL_ERROR_ZERO_RETURN);
			}
		else
			{
d2542 1
a2542 2
				return(SSL_ERROR_ZERO_RETURN);
			}
a2543 1
	return(SSL_ERROR_SYSCALL);
d2545 2
d2548 4
a2551 3
int SSL_do_handshake(SSL *s)
	{
	int ret=1;
d2553 4
a2556 5
	if (s->handshake_func == NULL)
		{
		SSLerr(SSL_F_SSL_DO_HANDSHAKE,SSL_R_CONNECTION_TYPE_NOT_SET);
		return(-1);
		}
d2560 2
a2561 5
	if (SSL_in_init(s) || SSL_in_before(s))
		{
		ret=s->handshake_func(s);
		}
	return(ret);
d2563 2
d2568 7
a2574 6
void SSL_set_accept_state(SSL *s)
	{
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_accept;
d2579 1
a2579 1
	}
d2581 7
a2587 6
void SSL_set_connect_state(SSL *s)
	{
	s->server=0;
	s->shutdown=0;
	s->state=SSL_ST_CONNECT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_connect;
d2592 1
a2592 1
	}
d2594 6
a2599 5
int ssl_undefined_function(SSL *s)
	{
	SSLerr(SSL_F_SSL_UNDEFINED_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return(0);
	}
d2601 6
a2606 5
int ssl_undefined_void_function(void)
	{
	SSLerr(SSL_F_SSL_UNDEFINED_VOID_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return(0);
	}
d2608 6
a2613 5
int ssl_undefined_const_function(const SSL *s)
	{
	SSLerr(SSL_F_SSL_UNDEFINED_CONST_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return(0);
	}
d2615 6
a2620 5
SSL_METHOD *ssl_bad_method(int ver)
	{
	SSLerr(SSL_F_SSL_BAD_METHOD,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return(NULL);
	}
d2622 3
a2624 2
const char *SSL_get_version(const SSL *s)
	{
d2637 1
a2637 1
	}
d2639 3
a2641 2
SSL *SSL_dup(SSL *s)
	{
d2646 3
a2648 3
	
	if ((ret=SSL_new(SSL_get_SSL_CTX(s))) == NULL)
	    return(NULL);
d2654 1
a2654 2
	if (s->session != NULL)
		{
d2656 2
a2657 4
		SSL_copy_session_id(ret,s);
		}
	else
		{
d2667 2
a2668 4
		if (s->cert != NULL)
			{
			if (ret->cert != NULL)
				{
d2670 1
a2670 1
				}
d2674 2
a2675 2
			}
				
d2677 2
a2678 2
			s->sid_ctx, s->sid_ctx_length);
		}
d2680 4
a2683 4
	ret->options=s->options;
	ret->mode=s->mode;
	SSL_set_max_cert_list(ret,SSL_get_max_cert_list(s));
	SSL_set_read_ahead(ret,SSL_get_read_ahead(s));
d2686 3
a2688 3
	SSL_set_verify(ret,SSL_get_verify_mode(s),
		SSL_get_verify_callback(s));
	SSL_set_verify_depth(ret,SSL_get_verify_depth(s));
d2691 3
a2693 3
	SSL_set_info_callback(ret,SSL_get_info_callback(s));
	
	ret->debug=s->debug;
d2700 1
a2700 2
	if (s->rbio != NULL)
		{
d2703 3
a2705 5
		}
	if (s->wbio != NULL)
		{
		if (s->wbio != s->rbio)
			{
d2708 3
a2710 4
			}
		else
			ret->wbio=ret->rbio;
		}
d2718 1
a2718 1
	ret->shutdown=s->shutdown;
d2720 1
a2720 1
	ret->rstate=s->rstate;
d2722 1
a2722 1
	ret->hit=s->hit;
d2727 2
a2728 3
	if (s->cipher_list != NULL)
		{
		if ((ret->cipher_list=sk_SSL_CIPHER_dup(s->cipher_list)) == NULL)
d2730 1
a2730 1
		}
d2732 1
a2732 1
		if ((ret->cipher_list_by_id=sk_SSL_CIPHER_dup(s->cipher_list_by_id))
d2734 1
a2734 1
			goto err;
d2737 6
a2742 9
	if (s->client_CA != NULL)
		{
		if ((sk=sk_X509_NAME_dup(s->client_CA)) == NULL) goto err;
		ret->client_CA=sk;
		for (i=0; i<sk_X509_NAME_num(sk); i++)
			{
			xn=sk_X509_NAME_value(sk,i);
			if (sk_X509_NAME_set(sk,i,X509_NAME_dup(xn)) == NULL)
				{
a2744 1
				}
d2747 1
d2749 1
a2749 2
	if (0)
		{
d2751 3
a2753 4
		if (ret != NULL) SSL_free(ret);
		ret=NULL;
		}
	return(ret);
d2755 2
d2758 4
a2761 4
void ssl_clear_cipher_ctx(SSL *s)
	{
	if (s->enc_read_ctx != NULL)
		{
d2764 3
a2766 4
		s->enc_read_ctx=NULL;
		}
	if (s->enc_write_ctx != NULL)
		{
d2769 2
a2770 2
		s->enc_write_ctx=NULL;
		}
d2772 1
a2772 2
	if (s->expand != NULL)
		{
d2774 3
a2776 4
		s->expand=NULL;
		}
	if (s->compress != NULL)
		{
d2778 2
a2779 2
		s->compress=NULL;
		}
d2781 1
a2781 1
	}
d2784 3
a2786 2
X509 *SSL_get_certificate(const SSL *s)
	{
d2788 1
a2788 1
		return(s->cert->key->x509);
d2790 2
a2791 2
		return(NULL);
	}
d2794 3
a2796 2
EVP_PKEY *SSL_get_privatekey(SSL *s)
	{
d2798 1
a2798 1
		return(s->cert->key->privatekey);
d2800 2
a2801 2
		return(NULL);
	}
d2803 3
a2805 2
const SSL_CIPHER *SSL_get_current_cipher(const SSL *s)
	{
d2807 3
a2809 3
		return(s->session->cipher);
	return(NULL);
	}
d2811 3
a2813 2
const void *SSL_get_current_compression(SSL *s)
	{
d2815 5
a2819 3
	}
const void *SSL_get_current_expansion(SSL *s)
	{
d2821 1
a2821 1
	}
d2824 3
a2826 2
const COMP_METHOD *SSL_get_current_compression(SSL *s)
	{
d2828 3
a2830 3
		return(s->compress->meth);
	return(NULL);
	}
d2832 3
a2834 2
const COMP_METHOD *SSL_get_current_expansion(SSL *s)
	{
d2836 3
a2838 3
		return(s->expand->meth);
	return(NULL);
	}
d2841 3
a2843 2
int ssl_init_wbio_buffer(SSL *s,int push)
	{
d2846 7
a2852 9
	if (s->bbio == NULL)
		{
		bbio=BIO_new(BIO_f_buffer());
		if (bbio == NULL) return(0);
		s->bbio=bbio;
		}
	else
		{
		bbio=s->bbio;
d2854 2
a2855 2
			s->wbio=BIO_pop(s->wbio);
		}
d2858 5
a2862 7
	if (!BIO_set_read_buffer_size(bbio,1))
		{
		SSLerr(SSL_F_SSL_INIT_WBIO_BUFFER,ERR_R_BUF_LIB);
		return(0);
		}
	if (push)
		{
d2864 2
a2865 4
			s->wbio=BIO_push(bbio,s->wbio);
		}
	else
		{
d2867 1
a2867 3
			s->wbio=BIO_pop(bbio);
		}
	return(1);
d2869 2
d2872 5
a2876 3
void ssl_free_wbio_buffer(SSL *s)
	{
	if (s->bbio == NULL) return;
d2878 1
a2878 2
	if (s->bbio == s->wbio)
		{
d2880 1
a2880 1
		s->wbio=BIO_pop(s->wbio);
d2886 8
a2893 7
	s->bbio=NULL;
	}
	
void SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx,int mode)
	{
	ctx->quiet_shutdown=mode;
	}
d2895 5
a2899 4
int SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx)
	{
	return(ctx->quiet_shutdown);
	}
d2901 5
a2905 4
void SSL_set_quiet_shutdown(SSL *s,int mode)
	{
	s->quiet_shutdown=mode;
	}
d2907 5
a2911 4
int SSL_get_quiet_shutdown(const SSL *s)
	{
	return(s->quiet_shutdown);
	}
d2913 5
a2917 4
void SSL_set_shutdown(SSL *s,int mode)
	{
	s->shutdown=mode;
	}
d2919 5
a2923 4
int SSL_get_shutdown(const SSL *s)
	{
	return(s->shutdown);
	}
d2925 5
a2929 4
int SSL_version(const SSL *s)
	{
	return(s->version);
	}
d2931 5
a2935 4
SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl)
	{
	return(ssl->ctx);
	}
d2937 3
a2939 2
SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX* ctx)
	{
d2949 1
a2949 1
	CRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);
d2953 2
a2954 2
	return(ssl->ctx);
	}
d2957 5
a2961 4
int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx)
	{
	return(X509_STORE_set_default_paths(ctx->cert_store));
	}
d2963 6
a2968 5
int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,
		const char *CApath)
	{
	return(X509_STORE_load_locations(ctx->cert_store,CAfile,CApath));
	}
d2971 6
a2976 5
void SSL_set_info_callback(SSL *ssl,
	void (*cb)(const SSL *ssl,int type,int val))
	{
	ssl->info_callback=cb;
	}
d2981 1
a2981 1
	{
d2983 1
a2983 1
	}
d2985 5
a2989 4
int SSL_state(const SSL *ssl)
	{
	return(ssl->state);
	}
d2991 3
a2993 2
void SSL_set_state(SSL *ssl, int state)
	{
d2995 1
a2995 1
	}
d2997 5
a3001 4
void SSL_set_verify_result(SSL *ssl,long arg)
	{
	ssl->verify_result=arg;
	}
d3003 5
a3007 4
long SSL_get_verify_result(const SSL *ssl)
	{
	return(ssl->verify_result);
	}
d3009 4
a3012 3
int SSL_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,
			 CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)
	{
d3014 2
a3015 2
				new_func, dup_func, free_func);
	}
d3017 5
a3021 4
int SSL_set_ex_data(SSL *s,int idx,void *arg)
	{
	return(CRYPTO_set_ex_data(&s->ex_data,idx,arg));
	}
d3023 5
a3027 4
void *SSL_get_ex_data(const SSL *s,int idx)
	{
	return(CRYPTO_get_ex_data(&s->ex_data,idx));
	}
d3029 4
a3032 3
int SSL_CTX_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,
			     CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)
	{
d3034 2
a3035 2
				new_func, dup_func, free_func);
	}
d3037 5
a3041 4
int SSL_CTX_set_ex_data(SSL_CTX *s,int idx,void *arg)
	{
	return(CRYPTO_set_ex_data(&s->ex_data,idx,arg));
	}
d3043 5
a3047 4
void *SSL_CTX_get_ex_data(const SSL_CTX *s,int idx)
	{
	return(CRYPTO_get_ex_data(&s->ex_data,idx));
	}
d3049 5
a3053 4
int ssl_ok(SSL *s)
	{
	return(1);
	}
d3055 5
a3059 4
X509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *ctx)
	{
	return(ctx->cert_store);
	}
d3061 3
a3063 2
void SSL_CTX_set_cert_store(SSL_CTX *ctx,X509_STORE *store)
	{
d3066 2
a3067 2
	ctx->cert_store=store;
	}
d3069 5
a3073 4
int SSL_want(const SSL *s)
	{
	return(s->rwstate);
	}
d3082 15
a3096 13
void SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,RSA *(*cb)(SSL *ssl,
							  int is_export,
							  int keylength))
    {
    SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_RSA_CB,(void (*)(void))cb);
    }

void SSL_set_tmp_rsa_callback(SSL *ssl,RSA *(*cb)(SSL *ssl,
						  int is_export,
						  int keylength))
    {
    SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_RSA_CB,(void (*)(void))cb);
    }
d3110 3
a3112 2
RSA *cb(SSL *ssl,int is_export,int keylength)
    {}
d3122 6
a3127 5
void SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,DH *(*dh)(SSL *ssl,int is_export,
                                                        int keylength))
	{
	SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_DH_CB,(void (*)(void))dh);
	}
d3129 6
a3134 5
void SSL_set_tmp_dh_callback(SSL *ssl,DH *(*dh)(SSL *ssl,int is_export,
                                                int keylength))
	{
	SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_DH_CB,(void (*)(void))dh);
	}
d3138 6
a3143 5
void SSL_CTX_set_tmp_ecdh_callback(SSL_CTX *ctx,EC_KEY *(*ecdh)(SSL *ssl,int is_export,
                                                                int keylength))
	{
	SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_ECDH_CB,(void (*)(void))ecdh);
	}
d3145 6
a3150 5
void SSL_set_tmp_ecdh_callback(SSL *ssl,EC_KEY *(*ecdh)(SSL *ssl,int is_export,
                                                        int keylength))
	{
	SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_ECDH_CB,(void (*)(void))ecdh);
	}
d3154 4
a3157 4
int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *identity_hint)
	{
	if (identity_hint != NULL && strlen(identity_hint) > PSK_MAX_IDENTITY_LEN)
		{
d3160 1
a3160 1
		}
d3163 1
a3163 2
	if (identity_hint != NULL)
		{
d3167 1
a3167 2
		}
	else
d3170 1
a3170 1
	}
d3172 3
a3174 2
int SSL_use_psk_identity_hint(SSL *s, const char *identity_hint)
	{
d3181 1
a3181 2
	if (identity_hint != NULL && strlen(identity_hint) > PSK_MAX_IDENTITY_LEN)
		{
d3184 1
a3184 1
		}
d3187 1
a3187 2
	if (identity_hint != NULL)
		{
d3191 1
a3191 2
		}
	else
d3194 1
a3194 1
	}
d3196 3
a3198 2
const char *SSL_get_psk_identity_hint(const SSL *s)
	{
d3201 2
a3202 2
	return(s->session->psk_identity_hint);
	}
d3204 3
a3206 2
const char *SSL_get_psk_identity(const SSL *s)
	{
d3209 2
a3210 2
	return(s->session->psk_identity);
	}
d3212 2
a3213 1
void SSL_set_psk_client_callback(SSL *s,
d3215 3
a3217 3
                       char *identity, unsigned int max_identity_len, unsigned char *psk,
                       unsigned int max_psk_len))
	{
d3219 1
a3219 1
	}
d3221 2
a3222 1
void SSL_CTX_set_psk_client_callback(SSL_CTX *ctx,
d3224 3
a3226 3
                       char *identity, unsigned int max_identity_len, unsigned char *psk,
                       unsigned int max_psk_len))
	{
d3228 1
a3228 1
	}
d3230 2
a3231 1
void SSL_set_psk_server_callback(SSL *s,
d3233 2
a3234 2
                       unsigned char *psk, unsigned int max_psk_len))
	{
d3236 1
a3236 1
	}
d3238 2
a3239 1
void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx,
d3241 2
a3242 2
                       unsigned char *psk, unsigned int max_psk_len))
	{
d3244 1
a3244 1
	}
d3247 3
a3249 2
void SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))
	{
d3251 5
a3255 3
	}
void SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))
	{
d3257 1
a3257 1
	}
d3265 2
a3266 1
EVP_MD_CTX *ssl_replace_hash(EVP_MD_CTX **hash,const EVP_MD *md) 
d3270 2
a3271 1
	if (md) EVP_DigestInit_ex(*hash,md,NULL);
d3274 3
a3276 1
void ssl_clear_hash_ctx(EVP_MD_CTX **hash) 
d3279 3
a3281 2
	if (*hash) EVP_MD_CTX_destroy(*hash);
	*hash=NULL;
d3284 3
a3286 2
void SSL_set_debug(SSL *s, int debug)
	{
d3288 1
a3288 1
	}
d3290 3
a3292 2
int SSL_cache_hit(SSL *s)
	{
d3294 1
a3294 1
	}
d3299 1
a3299 1
				    ssl_cipher_id);
@


1.25
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a3254 4
#if defined(_WINDLL) && defined(OPENSSL_SYS_WIN16)
#include "../crypto/bio/bss_file.c"
#endif

@


1.24
log
@resolve conflicts
@
text
@d600 1
d603 1
d1797 3
a1799 1
	ret->comp_methods=SSL_COMP_get_compression_methods();
d1956 1
d1959 1
d2293 1
a2293 1
X509 *ssl_get_server_send_cert(SSL *s)
d2348 1
a2348 1
		SSLerr(SSL_F_SSL_GET_SERVER_SEND_CERT,ERR_R_INTERNAL_ERROR);
a2350 1
	if (c->pkeys[i].x509 == NULL) return(NULL);
d2352 10
a2361 1
	return(c->pkeys[i].x509);
d2622 1
a2622 1
	if (s->version == TLS1_VERSION)
@


1.24.4.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@a1399 5
#ifndef OPENSSL_NO_SRP
		if (((c->algorithm_mkey & SSL_kSRP) || (c->algorithm_auth & SSL_aSRP)) &&
		    !(s->srp_ctx.srp_Mask & SSL_kSRP))
		    continue;
#endif /* OPENSSL_NO_SRP */
@


1.24.8.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@a1399 5
#ifndef OPENSSL_NO_SRP
		if (((c->algorithm_mkey & SSL_kSRP) || (c->algorithm_auth & SSL_aSRP)) &&
		    !(s->srp_ctx.srp_Mask & SSL_kSRP))
		    continue;
#endif /* OPENSSL_NO_SRP */
@


1.23
log
@OpenSSL 1.0.0f: merge
@
text
@d179 4
a182 1
	(int (*)(int))ssl_undefined_function
d208 1
a208 1
	if (s->new_session) return(1);
d210 1
a210 1
	if (s->new_session)
d359 3
d595 8
d1025 15
a1039 4
	if (s->new_session == 0)
		{
		s->new_session=1;
		}
d1047 1
a1047 1
	return (s->new_session != 0);
d1082 1
d1085 1
d1385 4
d1406 1
a1406 1
	if (p != q && !s->new_session)
d1453 1
a1453 1
			if (s->new_session)
d1510 117
d1629 12
d1684 8
d1811 4
d1821 3
d1952 3
d1959 3
d2215 1
a2215 1
int ssl_check_srvr_ecc_cert_and_alg(X509 *x, const SSL_CIPHER *cs)
d2221 1
d2251 1
a2251 1
		if (alg_k & SSL_kECDHe)
d2260 1
a2260 1
		if (alg_k & SSL_kECDHr)
d2350 1
a2350 1
EVP_PKEY *ssl_get_sign_pkey(SSL *s,const SSL_CIPHER *cipher)
d2354 1
d2361 1
a2361 1
		return(c->pkeys[SSL_PKEY_DSA_SIGN].privatekey);
d2365 1
a2365 1
			return(c->pkeys[SSL_PKEY_RSA_SIGN].privatekey);
d2367 1
a2367 3
			return(c->pkeys[SSL_PKEY_RSA_ENC].privatekey);
		else
			return(NULL);
d2371 2
a2372 2
		return(c->pkeys[SSL_PKEY_ECC].privatekey);
	else /* if (alg_a & SSL_aNULL) */
d2377 3
d2604 4
d2702 1
d2968 5
d3231 10
a3248 1

@


1.22
log
@openssl-1.0.0e: resolve conflicts
@
text
@d1057 3
@


1.21
log
@resolve conflicts, fix local changes
@
text
@d1833 1
a1833 1
	int signature_nid = 0;
d1963 1
d1965 2
d1970 2
a1971 8
			const char *sig = OBJ_nid2ln(signature_nid);
			if (sig == NULL)
				{
				ERR_clear_error();
				sig = "unknown";
				}
				
			if (strstr(sig, "WithRSA"))
d1982 1
a1982 1
			if (signature_nid == NID_ecdsa_with_SHA1)
d2036 1
a2036 1
	int signature_nid = 0;
d2054 1
d2056 2
d2069 1
a2069 1
			if (signature_nid != NID_ecdsa_with_SHA1)
d2079 1
a2079 7
			const char *sig = OBJ_nid2ln(signature_nid);
			if (sig == NULL)
				{
				ERR_clear_error();
				sig = "unknown";
				}
			if (strstr(sig, "WithRSA") == NULL)
d2104 1
a2104 1
	unsigned long alg_k,alg_a,mask_k,mask_a;
d2106 1
a2106 1
	int i,is_export;
a2109 11
	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
	if (is_export)
		{
		mask_k = c->export_mask_k;
		mask_a = c->export_mask_a;
		}
	else
		{
		mask_k = c->mask_k;
		mask_a = c->mask_a;
		}
@


1.20
log
@resolve conflicts
@
text
@d61 1
a61 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d118 26
d172 1
a172 1
	(int (*)(SSL *, EVP_MD_CTX *, EVP_MD_CTX *, const char*, int, unsigned char *))ssl_undefined_function,
d174 1
a174 1
	(int (*)(SSL *, EVP_MD_CTX *, unsigned char *))ssl_undefined_function,
d233 2
d255 1
a255 1
int SSL_CTX_set_ssl_version(SSL_CTX *ctx,SSL_METHOD *meth)
d262 2
a263 1
		&(ctx->cipher_list_by_id),SSL_DEFAULT_CIPHER_LIST);
d340 1
d357 1
d372 5
d464 1
a464 1
	p = (SSL_SESSION *)lh_retrieve(ssl->ctx->sessions, &r);
d489 10
d553 2
a558 1
	if (s->ctx) SSL_CTX_free(s->ctx);
d563 5
d576 1
d582 2
d901 1
a901 1
                SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);
d1044 2
d1048 2
d1057 2
a1058 1
		if (SSL_version(s) == DTLS1_VERSION)
d1064 9
d1091 1
a1091 1
struct lhash_st *SSL_CTX_sessions(SSL_CTX *ctx)
d1134 1
a1134 1
		return(ctx->sessions->num_items);
d1159 2
d1163 7
d1274 2
a1275 2
	 * has been disabled). This is not an error as far as 
	 * ssl_create_cipher_list is concerned, and hence 
d1340 1
a1340 1
                             int (*put_cb)(const SSL_CIPHER *, unsigned char *))
d1346 1
a1346 1
        int nokrb5 = !kssl_tgt_is_available(s->kssl_ctx);
d1356 10
a1365 4
                if ((c->algorithms & SSL_KRB5) && nokrb5)
                    continue;
#endif /* OPENSSL_NO_KRB5 */                    

d1369 16
d1391 1
a1391 1
	SSL_CIPHER *c;
d1394 2
d1413 20
d1454 1
d1478 1
a1478 1
unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
d1495 1
a1495 1
int SSL_SESSION_cmp(const SSL_SESSION *a,const SSL_SESSION *b)
d1508 2
a1509 2
static IMPLEMENT_LHASH_HASH_FN(SSL_SESSION_hash, SSL_SESSION *)
static IMPLEMENT_LHASH_COMP_FN(SSL_SESSION_cmp, SSL_SESSION *)
d1511 1
a1511 1
SSL_CTX *SSL_CTX_new(SSL_METHOD *meth)
d1514 1
a1514 1
	
a1520 8
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (meth->version < TLS1_VERSION))	
		{
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		return NULL;
		}
#endif

d1583 1
a1583 2
	ret->sessions=lh_new(LHASH_HASH_FN(SSL_SESSION_hash),
			LHASH_COMP_FN(SSL_SESSION_cmp));
d1590 1
a1590 1
		SSL_DEFAULT_CIPHER_LIST);
d1626 2
d1641 23
a1663 1

d1684 4
d1702 14
d1753 1
a1753 1
		lh_free(a->sessions);
d1773 5
d1782 8
d1820 1
a1820 1
void ssl_set_cert_masks(CERT *c, SSL_CIPHER *cipher)
d1826 1
a1826 1
	unsigned long mask,emask;
d1873 6
a1878 2
	mask=0;
	emask=0;
d1881 2
a1882 2
	printf("rt=%d rte=%d dht=%d re=%d ree=%d rs=%d ds=%d dhr=%d dhd=%d\n",
		rsa_tmp,rsa_tmp_export,dh_tmp,
d1885 11
d1898 1
a1898 1
		mask|=SSL_kRSA;
d1900 1
a1900 1
		emask|=SSL_kRSA;
d1904 1
a1904 1
	if (	(dh_tmp || dh_rsa || dh_dsa) && 
d1906 1
a1906 1
		mask|=SSL_kEDH;
d1909 1
a1909 1
		emask|=SSL_kEDH;
d1912 2
a1913 2
	if (dh_tmp_export) 
		emask|=SSL_kEDH;
d1916 1
a1916 1
		mask|=SSL_kEDH;
d1918 2
a1919 2
	if (dh_rsa) mask|=SSL_kDHr;
	if (dh_rsa_export) emask|=SSL_kDHr;
d1921 2
a1922 2
	if (dh_dsa) mask|=SSL_kDHd;
	if (dh_dsa_export) emask|=SSL_kDHd;
d1926 2
a1927 2
		mask|=SSL_aRSA;
		emask|=SSL_aRSA;
d1932 2
a1933 2
		mask|=SSL_aDSS;
		emask|=SSL_aDSS;
d1936 2
a1937 2
	mask|=SSL_aNULL;
	emask|=SSL_aNULL;
d1940 4
a1943 2
	mask|=SSL_kKRB5|SSL_aKRB5;
	emask|=SSL_kKRB5|SSL_aKRB5;
d1951 1
a1951 1
                /* This call populates extension flags (ex_flags) */
d1959 1
a1959 1
		ecc_pkey_size = (ecc_pkey != NULL) ? 
d1967 2
a1968 3
			if ((signature_nid == NID_md5WithRSAEncryption) ||
			    (signature_nid == NID_md4WithRSAEncryption) ||
			    (signature_nid == NID_md2WithRSAEncryption))
d1970 8
a1977 1
				mask|=SSL_kECDH|SSL_aRSA;
d1979 4
a1982 1
					emask|=SSL_kECDH|SSL_aRSA;
d1984 1
d1987 2
a1988 1
				mask|=SSL_kECDH|SSL_aECDSA;
d1990 4
a1993 1
					emask|=SSL_kECDH|SSL_aECDSA;
d2000 2
a2001 2
			mask|=SSL_aECDSA;
			emask|=SSL_aECDSA;
d2009 2
a2010 2
		mask|=SSL_kECDHE;
		emask|=SSL_kECDHE;
d2013 12
a2024 2
	c->mask=mask;
	c->export_mask=emask;
d2032 3
a2034 1
int check_srvr_ecc_cert_and_alg(X509 *x, SSL_CIPHER *cs)
d2036 1
a2036 1
	unsigned long alg = cs->algorithms;
d2041 3
d2058 1
a2058 1
	if (alg & SSL_kECDH) 
d2063 1
d2066 1
a2066 1
		if (alg & SSL_aECDSA) 
d2071 1
d2075 1
a2075 1
		if (alg & SSL_aRSA)
d2078 3
a2080 3
			if ((signature_nid != NID_md5WithRSAEncryption) &&
			    (signature_nid != NID_md4WithRSAEncryption) &&
			    (signature_nid != NID_md2WithRSAEncryption))
d2082 6
d2091 2
a2092 2
		} 
	else if (alg & SSL_aECDSA)
d2097 1
d2105 2
d2110 1
a2110 1
	unsigned long alg,mask,kalg;
a2115 1
	alg=s->s3->tmp.new_cipher->algorithms;
d2117 13
a2129 2
	mask=is_export?c->export_mask:c->mask;
	kalg=alg&(SSL_MKEY_MASK|SSL_AUTH_MASK);
d2131 1
a2131 1
	if (kalg & SSL_kECDH)
d2133 1
a2133 1
		/* we don't need to look at SSL_kECDHE 
d2136 1
a2136 1
		 * ECDHE, the check for the auth 
d2139 1
a2139 1
		 * not an RSA cert but for ECDHE-RSA
d2146 1
a2146 1
	else if (kalg & SSL_aECDSA)
d2150 1
a2150 1
	else if (kalg & SSL_kDHr)
d2152 1
a2152 1
	else if (kalg & SSL_kDHd)
d2154 1
a2154 1
	else if (kalg & SSL_aDSS)
d2156 1
a2156 1
	else if (kalg & SSL_aRSA)
d2163 1
a2163 1
	else if (kalg & SSL_aKRB5)
d2168 5
a2172 1
	else /* if (kalg & SSL_aNULL) */
d2182 1
a2182 1
EVP_PKEY *ssl_get_sign_pkey(SSL *s,SSL_CIPHER *cipher)
d2184 1
a2184 1
	unsigned long alg;
d2187 1
a2187 1
	alg=cipher->algorithms;
d2190 1
a2190 1
	if ((alg & SSL_aDSS) &&
d2193 1
a2193 1
	else if (alg & SSL_aRSA)
d2202 1
a2202 1
	else if ((alg & SSL_aECDSA) &&
d2205 1
a2205 1
	else /* if (alg & SSL_aNULL) */
d2220 1
a2220 1
	i=s->ctx->session_cache_mode;
d2223 2
a2224 2
		    || SSL_CTX_add_session(s->ctx,s->session))
		&& (s->ctx->new_session_cb != NULL))
d2227 1
a2227 1
		if (!s->ctx->new_session_cb(s,s->session))
d2236 2
a2237 2
			?s->ctx->stats.sess_connect_good
			:s->ctx->stats.sess_accept_good) & 0xff) == 0xff)
d2239 1
a2239 1
			SSL_CTX_flush_sessions(s->ctx,(unsigned long)time(NULL));
d2244 1
a2244 1
SSL_METHOD *SSL_get_ssl_method(SSL *s)
d2249 1
a2249 1
int SSL_set_ssl_method(SSL *s,SSL_METHOD *meth)
d2392 2
d2404 2
d2450 1
a2450 1
		 
d2620 1
a2620 1
SSL_CIPHER *SSL_get_current_cipher(const SSL *s)
d2698 1
a2698 1
#endif	
d2783 1
a2783 1
void (*SSL_get_info_callback(const SSL *ssl))(const SSL * /*ssl*/,int /*type*/,int /*val*/) 
d2904 1
a2904 1
							int keylength))
d2910 1
a2910 1
						int keylength))
d2918 1
a2918 1
							int keylength))
d2924 1
a2924 1
						int keylength))
d2930 91
d3031 5
d3037 13
d3057 3
@


1.19
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d513 2
@


1.18
log
@resolve conflicts
@
text
@d133 3
d1396 8
d1524 21
d1614 4
@


1.17
log
@Replace use of strcpy(3) and other pointer goo in
SSL_get_shared_ciphers() with strlcat(3).

ok deraadt@@ markus@@
@
text
@d113 5
a117 1

d128 5
a132 1
#include <openssl/fips.h>
d143 8
a150 1
	(int (*)(SSL *, EVP_MD_CTX *, EVP_MD_CTX *, const char*, int, unsigned char *))ssl_undefined_function
d290 1
d292 1
d298 6
d306 1
d311 13
a323 1

d432 1
a432 1
	return X509_PURPOSE_set(&s->purpose, purpose);
d437 1
a437 1
	return X509_PURPOSE_set(&s->purpose, purpose);
d442 1
a442 1
	return X509_TRUST_set(&s->trust, trust);
d447 1
a447 1
	return X509_TRUST_set(&s->trust, trust);
d470 3
d509 10
a518 1

d694 1
a694 1
	return(s->verify_depth);
d709 1
a709 1
	return(ctx->verify_depth);
d727 1
a727 1
	s->verify_depth=depth;
d901 1
a901 1
		SSLerr(SSL_F_SSL_READ, SSL_R_UNINITIALIZED);
d992 7
d1004 1
a1004 1
long SSL_callback_ctrl(SSL *s, int cmd, void (*fp)())
d1092 1
a1092 1
long SSL_CTX_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)())
d1327 23
a1392 8
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (meth->version < TLS1_VERSION))	
		{
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		return NULL;
		}
#endif

d1441 1
d1443 1
d1452 2
d1471 4
d1499 14
d1545 3
d1610 1
a1610 1
	ctx->verify_depth=depth;
d1620 7
d1647 3
d1664 2
a1665 1

d1722 53
d1780 63
d1857 20
a1876 1
	if 	(kalg & SSL_kDHr)
d1900 1
d1924 3
d2132 6
d2253 2
a2254 2
	ret->purpose=s->purpose;
	ret->trust=s->trust;
d2306 1
d2317 1
d2344 25
d2462 18
d2489 1
a2489 3
	int r;
	r=X509_STORE_load_locations(ctx->cert_store,CAfile,CApath);
	return r;
d2494 1
a2494 1
			   void (*cb)(const SSL *ssl,int type,int val))
d2499 3
a2501 1
void (*SSL_get_info_callback(const SSL *ssl))(const SSL *ssl,int type,int val)
d2588 1
a2588 1
    SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_RSA_CB,(void (*)())cb);
d2595 1
a2595 1
    SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_RSA_CB,(void (*)())cb);
d2624 1
a2624 1
	SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_DH_CB,(void (*)())dh);
d2630 15
a2644 1
	SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_DH_CB,(void (*)())dh);
d2651 1
a2651 1
	SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK, (void (*)())cb);
d2655 1
a2655 1
	SSL_callback_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK, (void (*)())cb);
@


1.16
log
@Fix off-by-one buffer overflow in SSL_get_shared_ciphers().
From OpenSSL_0_9_8-stable branch.

ok djm@@
@
text
@d1171 1
a1171 1
	char *p;
d1174 1
a1180 1
	p=buf;
d1182 1
a1184 2
		int n;

d1186 3
a1188 2
		n=strlen(c->name);
		if (n+1 > len)
d1190 3
a1192 4
			if (p != buf)
				--p;
			*p='\0';
			return buf;
a1193 4
		strcpy(p,c->name);
		p+=n;
		*(p++)=':';
		len-=n+1;
d1195 3
a1197 1
	p[-1]='\0';
@


1.15
log
@openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a1171 1
	const char *cp;
d1184 2
a1185 2
		/* Decrement for either the ':' or a '\0' */
		len--;
d1187 2
a1188 1
		for (cp=c->name; *cp; )
d1190 4
a1193 7
			if (len-- <= 0)
				{
				*p='\0';
				return(buf);
				}
			else
				*(p++)= *(cp++);
d1195 2
d1198 1
@


1.15.4.1
log
@MFC, fix by moritz:
The SSL_get_shared_ciphers() function contains an off-by-one overflow.
@
text
@d1171 2
a1172 1
	char *end;
a1174 1
	size_t curlen = 0;
d1181 1
a1182 1
	buf[0] = '\0';
d1185 2
d1188 1
a1188 3
		end = buf + curlen;
		if (strlcat(buf, c->name, len) >= len ||
		    (curlen = strlcat(buf, ":", len)) >= len)
d1190 7
a1196 3
			/* remove truncated cipher from list */
			*end = '\0';
			break;
d1198 1
d1200 1
a1200 3
	/* remove trailing colon */
	if ((end = strrchr(buf, ':')) != NULL)
		*end = '\0';
@


1.15.2.1
log
@MFC, fix by moritz:
The SSL_get_shared_ciphers() function contains an off-by-one overflow.
@
text
@d1171 2
a1172 1
	char *end;
a1174 1
	size_t curlen = 0;
d1181 1
a1182 1
	buf[0] = '\0';
d1185 2
d1188 1
a1188 3
		end = buf + curlen;
		if (strlcat(buf, c->name, len) >= len ||
		    (curlen = strlcat(buf, ":", len)) >= len)
d1190 7
a1196 3
			/* remove truncated cipher from list */
			*end = '\0';
			break;
d1198 1
d1200 1
a1200 3
	/* remove trailing colon */
	if ((end = strrchr(buf, ':')) != NULL)
		*end = '\0';
@


1.14
log
@resolve conflicts
@
text
@d1190 1
a1190 1
			if (len-- == 0)
@


1.14.2.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@d1190 1
a1190 1
			if (len-- <= 0)
@


1.14.2.2
log
@MFC, fix by moritz:
The SSL_get_shared_ciphers() function contains an off-by-one overflow.
@
text
@d1171 2
a1172 1
	char *end;
a1174 1
	size_t curlen = 0;
d1181 1
a1182 1
	buf[0] = '\0';
d1185 2
d1188 1
a1188 3
		end = buf + curlen;
		if (strlcat(buf, c->name, len) >= len ||
		    (curlen = strlcat(buf, ":", len)) >= len)
d1190 7
a1196 3
			/* remove truncated cipher from list */
			*end = '\0';
			break;
d1198 1
d1200 1
a1200 3
	/* remove trailing colon */
	if ((end = strrchr(buf, ':')) != NULL)
		*end = '\0';
@


1.13
log
@resolve conflicts
@
text
@d128 1
a128 1
OPENSSL_GLOBAL SSL3_ENC_METHOD ssl3_undef_enc_method={
d1133 15
a1147 2
/* XXXX */
	return((sk == NULL)?0:1);
d1157 9
a1165 2
/* XXXX */
	return((sk == NULL)?0:1);
d1204 2
a1205 1
int ssl_cipher_list_to_bytes(SSL *s,STACK_OF(SSL_CIPHER) *sk,unsigned char *p)
d1224 2
a1225 1
		j=ssl_put_cipher_by_char(s,c,p);
d1719 1
a1719 1
			SSL_CTX_flush_sessions(s->ctx,time(NULL));
@


1.13.2.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@d1170 1
a1170 1
			if (len-- <= 0)
@


1.13.4.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@d1170 1
a1170 1
			if (len-- <= 0)
@


1.12
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d124 1
d504 1
a504 1
BIO *SSL_get_rbio(SSL *s)
d507 1
a507 1
BIO *SSL_get_wbio(SSL *s)
d510 1
a510 1
int SSL_get_fd(SSL *s)
d515 1
a515 1
int SSL_get_rfd(SSL *s)
d527 1
a527 1
int SSL_get_wfd(SSL *s)
d609 1
a609 1
size_t SSL_get_finished(SSL *s, void *buf, size_t count)
d624 1
a624 1
size_t SSL_get_peer_finished(SSL *s, void *buf, size_t count)
d639 1
a639 1
int SSL_get_verify_mode(SSL *s)
d644 1
a644 1
int SSL_get_verify_depth(SSL *s)
d649 1
a649 1
int (*SSL_get_verify_callback(SSL *s))(int,X509_STORE_CTX *)
d654 1
a654 1
int SSL_CTX_get_verify_mode(SSL_CTX *ctx)
d659 1
a659 1
int SSL_CTX_get_verify_depth(SSL_CTX *ctx)
d664 1
a664 1
int (*SSL_CTX_get_verify_callback(SSL_CTX *ctx))(int,X509_STORE_CTX *)
d687 1
a687 1
int SSL_get_read_ahead(SSL *s)
d692 1
a692 1
int SSL_pending(SSL *s)
d704 1
a704 1
X509 *SSL_get_peer_certificate(SSL *s)
d720 1
a720 1
STACK_OF(X509) *SSL_get_peer_cert_chain(SSL *s)
d737 1
a737 1
void SSL_copy_session_id(SSL *t,SSL *f)
d766 1
a766 1
int SSL_CTX_check_private_key(SSL_CTX *ctx)
d784 1
a784 1
int SSL_check_private_key(SSL *ssl)
d828 1
a828 1
long SSL_get_default_timeout(SSL *s)
d1075 1
a1075 1
STACK_OF(SSL_CIPHER) *SSL_get_ciphers(SSL *s)
d1112 1
a1112 1
const char *SSL_get_cipher_list(SSL *s,int n)
d1149 1
a1149 1
char *SSL_get_shared_ciphers(SSL *s,char *buf,int len)
d1253 1
a1253 1
unsigned long SSL_SESSION_hash(SSL_SESSION *a)
d1270 1
a1270 1
int SSL_SESSION_cmp(SSL_SESSION *a,SSL_SESSION *b)
d1296 8
d1734 1
a1734 1
int SSL_get_error(SSL *s,int i)
d1868 6
d1880 1
a1880 1
const char *SSL_get_version(SSL *s)
d2049 1
a2049 1
X509 *SSL_get_certificate(SSL *s)
d2066 1
a2066 1
SSL_CIPHER *SSL_get_current_cipher(SSL *s)
d2130 1
a2130 1
int SSL_CTX_get_quiet_shutdown(SSL_CTX *ctx)
d2140 1
a2140 1
int SSL_get_quiet_shutdown(SSL *s)
d2150 1
a2150 1
int SSL_get_shutdown(SSL *s)
d2155 1
a2155 1
int SSL_version(SSL *s)
d2160 1
a2160 1
SSL_CTX *SSL_get_SSL_CTX(SSL *ssl)
d2174 3
a2176 1
	return(X509_STORE_load_locations(ctx->cert_store,CAfile,CApath));
d2186 1
a2186 1
void (*SSL_get_info_callback(SSL *ssl))(const SSL *ssl,int type,int val)
d2191 1
a2191 1
int SSL_state(SSL *ssl)
d2201 1
a2201 1
long SSL_get_verify_result(SSL *ssl)
d2218 1
a2218 1
void *SSL_get_ex_data(SSL *s,int idx)
d2235 1
a2235 1
void *SSL_CTX_get_ex_data(SSL_CTX *s,int idx)
d2245 1
a2245 1
X509_STORE *SSL_CTX_get_cert_store(SSL_CTX *ctx)
d2257 1
a2257 1
int SSL_want(SSL *s)
@


1.11
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d475 5
@


1.10
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d276 1
d318 1
a318 1
    if(sid_ctx_len > SSL_MAX_SID_CTX_LENGTH)
d368 4
d1071 1
a1071 1
	if ((s != NULL) && (s->cipher_list != NULL))
d1073 9
a1081 6
		return(s->cipher_list);
		}
	else if ((s->ctx != NULL) &&
		(s->ctx->cipher_list != NULL))
		{
		return(s->ctx->cipher_list);
d1090 1
a1090 1
	if ((s != NULL) && (s->cipher_list_by_id != NULL))
d1092 9
a1100 6
		return(s->cipher_list_by_id);
		}
	else if ((s != NULL) && (s->ctx != NULL) &&
		(s->ctx->cipher_list_by_id != NULL))
		{
		return(s->ctx->cipher_list_by_id);
d1666 1
a1666 1
		&& ((i & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)
d1898 1
@


1.9
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d1408 13
a1423 2
		{
		SSL_CTX_flush_sessions(a,0);
d1425 1
a1425 1
		}
a2302 7

void OpenSSLDie(const char *file,int line,const char *assertion)
    {
    fprintf(stderr,"%s(%d): OpenSSL internal error, assertion failed: %s\n",
	    file,line,assertion);
    abort();
    }
@


1.8
log
@apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@d119 2
a123 2
#include "ssl_locl.h"
#include "kssl_lcl.h"
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d2292 7
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d60 53
d115 3
a117 1
#include <assert.h>
d123 1
a126 5
static STACK_OF(CRYPTO_EX_DATA_FUNCS) *ssl_meth=NULL;
static STACK_OF(CRYPTO_EX_DATA_FUNCS) *ssl_ctx_meth=NULL;
static int ssl_meth_num=0;
static int ssl_ctx_meth_num=0;

a138 1
	int state;
d146 6
d164 1
a164 1
		SSLerr(SSL_F_SSL_CLEAR,SSL_R_INTERNAL_ERROR);
a168 1
	state=s->state; /* Keep to check if we throw away the session-id */
a188 6
	if (ssl_clear_bad_session(s))
		{
		SSL_SESSION_free(s->session);
		s->session=NULL;
		}

d194 1
a194 1
	if ((s->session == NULL) && (s->method != s->ctx->method))
d243 8
d269 6
a276 2
	s->verify_mode=ctx->verify_mode;
	s->verify_depth=ctx->verify_depth;
d278 1
d281 2
a292 1
	s->quiet_shutdown=ctx->quiet_shutdown;
d295 1
a295 3
	s->options=ctx->options;
	s->mode=ctx->mode;
	s->read_ahead=ctx->read_ahead; /* used to happen in SSL_clear */
d298 1
a298 1
	CRYPTO_new_ex_data(ssl_meth,s,&s->ex_data);
d342 46
d389 2
a390 4
{
	if(X509_PURPOSE_get_by_id(purpose) == -1) {
		SSLerr(SSL_F_SSL_CTX_SET_PURPOSE, SSL_R_INVALID_PURPOSE);
		return 0;
a391 3
	s->purpose = purpose;
	return 1;
}
d394 2
a395 4
{
	if(X509_PURPOSE_get_by_id(purpose) == -1) {
		SSLerr(SSL_F_SSL_SET_PURPOSE, SSL_R_INVALID_PURPOSE);
		return 0;
d397 1
a397 4
	s->purpose = purpose;
	return 1;
}
	
d399 2
a400 4
{
	if(X509_TRUST_get_by_id(trust) == -1) {
		SSLerr(SSL_F_SSL_CTX_SET_TRUST, SSL_R_INVALID_TRUST);
		return 0;
a401 3
	s->trust = trust;
	return 1;
}
d404 2
a405 4
{
	if(X509_TRUST_get_by_id(trust) == -1) {
		SSLerr(SSL_F_SSL_SET_TRUST, SSL_R_INVALID_TRUST);
		return 0;
a406 3
	s->trust = trust;
	return 1;
}
d428 1
a428 1
	CRYPTO_free_ex_data(ssl_meth,(char *)s,&s->ex_data);
d501 5
d516 13
a528 1
#ifndef NO_SOCK
d683 7
d892 4
a895 1
	s->new_session=1;
d899 8
a906 1
long SSL_ctrl(SSL *s,int cmd,long larg,char *parg)
d918 5
d927 6
d942 4
d956 1
a956 1
long SSL_CTX_ctrl(SSL_CTX *ctx,int cmd,long larg,char *parg)
d968 11
d1030 4
d1172 3
d1182 4
d1248 5
d1262 7
d1301 4
a1304 3
	ret->new_session_cb=NULL;
	ret->remove_session_cb=NULL;
	ret->get_session_cb=NULL;
d1319 1
a1319 1
	ret->app_verify_callback=NULL;
d1322 1
d1324 2
d1328 1
d1333 1
a1333 1
	ret->default_passwd_callback=NULL;
d1335 1
a1335 1
	ret->client_cert_cb=NULL;
d1337 2
a1338 1
	ret->sessions=lh_new(SSL_SESSION_hash,SSL_SESSION_cmp);
d1372 1
a1372 1
	CRYPTO_new_ex_data(ssl_ctx_meth,(char *)ret,&ret->ex_data);
d1385 1
d1388 1
d1408 1
a1408 1
	CRYPTO_free_ex_data(ssl_ctx_meth,(char *)a,&a->ex_data);
d1427 1
d1430 3
d1446 1
a1446 1
void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx,int (*cb)(),char *arg)
a1447 5
	/* now
	 *     int (*cb)(X509_STORE_CTX *),
	 * but should be
	 *     int (*cb)(X509_STORE_CTX *, void *arg)
	 */
d1449 1
a1449 1
	ctx->app_verify_arg=arg; /* never used */
a1455 2
	/* This needs cleaning up EAY EAY EAY */
	X509_STORE_set_verify_cb_func(ctx->cert_store,cb);
d1475 1
a1475 1
#ifndef NO_RSA
d1482 1
a1482 1
#ifndef NO_DH
d1556 5
d1593 5
d1600 1
a1600 1
		SSLerr(SSL_F_SSL_GET_SERVER_SEND_CERT,SSL_R_INTERNAL_ERROR);
d1629 1
a1629 1
		SSLerr(SSL_F_SSL_GET_SIGN_PKEY,SSL_R_INTERNAL_ERROR);
d1642 4
a1645 3
	if ((s->ctx->session_cache_mode & mode)
		&& (!s->hit)
		&& SSL_CTX_add_session(s->ctx,s->session)
a1653 1
	i=s->ctx->session_cache_mode;
d1737 2
d1757 2
d1859 5
a1863 1
			  
d1894 3
d1898 2
d1903 1
a1907 1
	ret->options=s->options;
d1910 1
a1910 1
	if (!CRYPTO_dup_ex_data(ssl_meth,&ret->ex_data,&s->ex_data))
d1929 13
a1969 5
	ret->shutdown=s->shutdown;
	ret->state=s->state;
	ret->handshake_func=s->handshake_func;
	ret->server=s->server;

d2122 1
a2122 1
#ifndef NO_STDIO
d2135 2
a2136 1
void SSL_set_info_callback(SSL *ssl,void (*cb)())
d2141 1
a2141 1
void (*SSL_get_info_callback(SSL *ssl))(void)
d2143 1
a2143 1
	return((void (*)())ssl->info_callback);
d2164 2
a2165 3
	ssl_meth_num++;
	return(CRYPTO_get_ex_new_index(ssl_meth_num-1,
		&ssl_meth,argl,argp,new_func,dup_func,free_func));
d2181 2
a2182 3
	ssl_ctx_meth_num++;
	return(CRYPTO_get_ex_new_index(ssl_ctx_meth_num-1,
		&ssl_ctx_meth,argl,argp,new_func,dup_func,free_func));
d2223 1
a2223 1
#ifndef NO_RSA
d2260 1
a2260 1
#ifndef NO_DH
d2263 3
a2265 3
    {
    SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_DH_CB,(void (*)())dh);
    }
d2269 3
a2271 3
    {
    SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_DH_CB,(void (*)())dh);
    }
d2274 13
a2286 1
#if defined(_WINDLL) && defined(WIN16)
@


1.6.4.1
log
@Pull in patch from current:
Fix (markus), errata 013:
apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@a2074 7

void OpenSSLDie(const char *file,int line,const char *assertion)
    {
    fprintf(stderr,"%s(%d): OpenSSL internal error, assertion failed: %s\n",
           file,line,assertion);
    abort();
    }
@


1.6.2.1
log
@Errata #030 (markus):
Fixes for the "OpenSSL Security Advisory [30 July 2002]"
@
text
@a2074 7

void OpenSSLDie(const char *file,int line,const char *assertion)
    {
    fprintf(stderr,"%s(%d): OpenSSL internal error, assertion failed: %s\n",
           file,line,assertion);
    abort();
    }
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d122 1
d124 1
d234 1
d711 1
a711 1
int SSL_read(SSL *s,char *buf,int num)
d727 1
a727 1
int SSL_peek(SSL *s,char *buf,int num)
d729 6
d742 1
a742 1
int SSL_write(SSL *s,const char *buf,int num)
d1688 4
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d61 2
d188 1
a188 1
	s=(SSL *)Malloc(sizeof(SSL));
d244 1
a244 1
		Free(s);
d380 1
a380 1
	Free(s);
d879 1
a879 1
int ssl_cipher_id_cmp(SSL_CIPHER *a,SSL_CIPHER *b)
d890 2
a891 1
int ssl_cipher_ptr_id_cmp(SSL_CIPHER **ap,SSL_CIPHER **bp)
d1039 1
a1039 1
		sk=sk_SSL_CIPHER_new(NULL); /* change perhaps later */
d1105 1
a1105 1
	ret=(SSL_CTX *)Malloc(sizeof(SSL_CTX));
d1201 1
a1201 1
    { Free(comp); }
d1242 1
a1242 1
	Free(a);
d1765 1
a1765 1
		Free(s->enc_read_ctx);
d1771 1
a1771 1
		Free(s->enc_write_ctx);
a1848 2
	BIO *under;

d1854 5
a1858 6
		under=BIO_pop(s->wbio);
		if (under != NULL)
			s->wbio=under;
		else
			abort(); /* ok */
		}
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d602 3
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d64 1
d67 1
a67 1
char *SSL_version_str=OPENSSL_VERSION_TEXT;
d69 2
a70 2
static STACK *ssl_meth=NULL;
static STACK *ssl_ctx_meth=NULL;
d75 3
d79 3
a81 5
	ssl_undefined_function,
	ssl_undefined_function,
	ssl_undefined_function,
	ssl_undefined_function,
	ssl_undefined_function,
d98 2
a99 1
#if 0
d103 6
d213 2
d232 1
a232 1
	CRYPTO_new_ex_data(ssl_meth,(char *)s,&s->ex_data);
d276 40
d378 1
a378 1
	Free((char *)s);
d487 32
d792 14
d865 9
d943 2
a944 2
/** specify the ciphers to be used by defaut by the SSL_CTX */
int SSL_CTX_set_cipher_list(SSL_CTX *ctx,char *str)
d955 1
a955 1
int SSL_set_cipher_list(SSL *s,char *str)
d1236 1
a1236 1
	Free((char *)a);
a1362 1
#ifdef SSL_ALLOW_ADH
a1364 1
#endif
d1381 1
a1381 1
	is_export=SSL_IS_EXPORT(alg);
d1634 1
a1634 1
char *SSL_get_version(SSL *s)
d1938 2
a1939 2
int SSL_get_ex_new_index(long argl,char *argp,int (*new_func)(),
			 int (*dup_func)(),void (*free_func)())
d1956 2
a1957 2
int SSL_CTX_get_ex_new_index(long argl,char *argp,int (*new_func)(),
			     int (*dup_func)(),void (*free_func)())
d2006 3
a2008 2
    { SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_RSA_CB,0,(char *)cb); }
#endif
d2010 6
a2015 4
#ifndef NO_RSA
void SSL_set_tmp_rsa_callback(SSL *ssl,RSA *(*cb)(SSL *ssl,int is_export,
							  int keylength))
    { SSL_ctrl(ssl,SSL_CTRL_SET_TMP_RSA_CB,0,(char *)cb); }
d2042 3
a2044 1
    { SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_DH_CB,0,(char *)dh); }
d2047 4
a2050 2
							int keylength))
    { SSL_ctrl(ssl,SSL_CTRL_SET_TMP_DH_CB,0,(char *)dh); }
@


1.1
log
@Initial revision
@
text
@d1 3
a3 1
/* ssl/ssl_lib.c */
d62 2
a63 2
#include "objects.h"
#include "lhash.h"
d66 1
a66 1
char *SSL_version_str="SSLeay 0.9.0b 29-Jun-1998";
d73 1
a73 1
SSL3_ENC_METHOD ssl3_undef_enc_method={
d82 1
a82 2
void SSL_clear(s)
SSL *s;
d86 5
a90 1
	if (s->method == NULL) return;
d94 1
d96 1
d99 2
a100 1
	if (s->new_session) return;
d105 2
d108 1
a109 1
	s->state=SSL_ST_BEFORE;
d111 1
a111 3
	s->read_ahead=s->ctx->default_read_ahead;

/*	s->shutdown=(SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN); */
a126 1
	s->shutdown=(SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
d129 14
a142 1
	s->method->ssl_clear(s);
d145 2
a146 4
/* Used to change an SSL_CTXs default SSL method type */
int SSL_CTX_set_ssl_version(ctx,meth)
SSL_CTX *ctx;
SSL_METHOD *meth;
d148 1
a148 1
	STACK *sk;
d154 1
a154 1
	if ((sk == NULL) || (sk_num(sk) <= 0))
d162 1
a162 2
SSL *SSL_new(ctx)
SSL_CTX *ctx;
d181 1
a181 1
	if (ctx->default_cert != NULL)
d183 13
a195 3
		CRYPTO_add(&ctx->default_cert->references,1,
			CRYPTO_LOCK_SSL_CERT);
		s->cert=ctx->default_cert;
d198 5
a202 2
		s->cert=NULL;
	s->verify_mode=ctx->default_verify_mode;
a211 3
		{
		SSL_CTX_free(ctx);
		Free(s);
a212 1
		}
d216 1
d218 1
d225 8
d237 29
a265 2
void SSL_free(s)
SSL *s;
d269 3
d305 2
a306 2
	if (s->cipher_list != NULL) sk_free(s->cipher_list);
	if (s->cipher_list_by_id != NULL) sk_free(s->cipher_list_by_id);
d323 1
a323 1
		sk_pop_free(s->client_CA,X509_NAME_free);
d330 1
a330 4
void SSL_set_bio(s, rbio,wbio)
SSL *s;
BIO *rbio;
BIO *wbio;
d350 1
a350 2
BIO *SSL_get_rbio(s)
SSL *s;
d353 1
a353 2
BIO *SSL_get_wbio(s)
SSL *s;
d356 1
a356 2
int SSL_get_fd(s)
SSL *s;
d369 1
a369 3
int SSL_set_fd(s, fd)
SSL *s;
int fd;
d388 1
a388 3
int SSL_set_wfd(s, fd)
SSL *s;
int fd;
d410 1
a410 3
int SSL_set_rfd(s, fd)
SSL *s;
int fd;
d436 1
a436 2
int SSL_get_verify_mode(s)
SSL *s;
d441 6
a446 2
int (*SSL_get_verify_callback(s))()
SSL *s;
d451 1
a451 2
int SSL_CTX_get_verify_mode(ctx)
SSL_CTX *ctx;
d453 1
a453 1
	return(ctx->default_verify_mode);
d456 6
a461 2
int (*SSL_CTX_get_verify_callback(ctx))()
SSL_CTX *ctx;
d466 2
a467 4
void SSL_set_verify(s, mode, callback)
SSL *s;
int mode;
int (*callback)();
d474 6
a479 3
void SSL_set_read_ahead(s, yes)
SSL *s;
int yes;
d484 1
a484 2
int SSL_get_read_ahead(s)
SSL *s;
d489 1
a489 2
int SSL_pending(s)
SSL *s;
d494 1
a494 2
X509 *SSL_get_peer_certificate(s)
SSL *s;
d510 1
a510 2
STACK *SSL_get_peer_cert_chain(s)
SSL *s;
d512 1
a512 1
	STACK *r;
d514 1
a514 1
	if ((s == NULL) || (s->session == NULL) || (s->session->cert == NULL))
d517 1
a517 1
		r=s->session->cert->cert_chain;
d524 1
a524 2
void SSL_copy_session_id(t,f)
SSL *t,*f;
d549 1
d553 1
a553 2
int SSL_CTX_check_private_key(ctx)
SSL_CTX *ctx;
d556 2
a557 2
		(ctx->default_cert == NULL) ||
		(ctx->default_cert->key->x509 == NULL))
d562 1
a562 1
	if 	(ctx->default_cert->key->privatekey == NULL)
d567 1
a567 1
	return(X509_check_private_key(ctx->default_cert->key->x509, ctx->default_cert->key->privatekey));
d571 1
a571 2
int SSL_check_private_key(ssl)
SSL *ssl;
d579 4
a582 1
		return(SSL_CTX_check_private_key(ssl->ctx));
d597 1
a597 2
int SSL_accept(s)
SSL *s;
d599 4
d606 1
a606 2
int SSL_connect(s)
SSL *s;
d608 4
d615 1
a615 2
long SSL_get_default_timeout(s)
SSL *s;
d620 1
a620 4
int SSL_read(s,buf,num)
SSL *s;
char *buf;
int num;
d622 6
d636 1
a636 4
int SSL_peek(s,buf,num)
SSL *s;
char *buf;
int num;
d645 1
a645 4
int SSL_write(s,buf,num)
SSL *s;
char *buf;
int num;
d647 6
d662 1
a662 2
int SSL_shutdown(s)
SSL *s;
d664 12
d682 1
a682 2
int SSL_renegotiate(s)
SSL *s;
d688 1
a688 5
long SSL_ctrl(s,cmd,larg,parg)
SSL *s;
int cmd;
long larg;
char *parg;
d690 17
a706 1
	return(s->method->ssl_ctrl(s,cmd,larg,parg));
d709 1
a709 5
long SSL_CTX_ctrl(ctx,cmd,larg,parg)
SSL_CTX *ctx;
int cmd;
long larg;
char *parg;
d711 55
a765 1
	return(ctx->method->ssl_ctx_ctrl(ctx,cmd,larg,parg));
d768 1
a768 2
int ssl_cipher_id_cmp(a,b)
SSL_CIPHER *a,*b;
d779 1
a779 2
int ssl_cipher_ptr_id_cmp(ap,bp)
SSL_CIPHER **ap,**bp;
d790 1
a790 1
/* return a STACK of the ciphers available for the SSL and in order of
d792 1
a792 2
STACK *SSL_get_ciphers(s)
SSL *s;
d806 1
a806 1
/* return a STACK of the ciphers available for the SSL and in order of
d808 1
a808 2
STACK *ssl_get_ciphers_by_id(s)
SSL *s;
d822 2
a823 4
/* The old interface to get the same thing as SSL_get_ciphers() */
char *SSL_get_cipher_list(s,n)
SSL *s;
int n;
d826 1
a826 1
	STACK *sk;
d830 1
a830 1
	if ((sk == NULL) || (sk_num(sk) <= n))
d832 1
a832 1
	c=(SSL_CIPHER *)sk_value(sk,n);
d837 2
a838 4
/* specify the ciphers to be used by defaut by the SSL_CTX */
int SSL_CTX_set_cipher_list(ctx,str)
SSL_CTX *ctx;
char *str;
d840 1
a840 1
	STACK *sk;
d848 2
a849 4
/* specify the ciphers to be used by the SSL */
int SSL_set_cipher_list(s, str)
SSL *s;
char *str;
d851 1
a851 1
	STACK *sk;
d860 1
a860 4
char *SSL_get_shared_ciphers(s,buf,len)
SSL *s;
char *buf;
int len;
d862 3
a864 2
	char *p,*cp;
	STACK *sk;
d874 1
a874 1
	for (i=0; i<sk_num(sk); i++)
d878 1
a878 1
		c=(SSL_CIPHER *)sk_value(sk,i);
d895 1
a895 4
int ssl_cipher_list_to_bytes(s,sk,p)
SSL *s;
STACK *sk;
unsigned char *p;
d904 1
a904 1
	for (i=0; i<sk_num(sk); i++)
d906 1
a906 1
		c=(SSL_CIPHER *)sk_value(sk,i);
d913 2
a914 5
STACK *ssl_bytes_to_cipher_list(s,p,num,skp)
SSL *s;
unsigned char *p;
int num;
STACK **skp;
d917 1
a917 1
	STACK *sk;
d927 1
a927 1
		sk=sk_new(NULL); /* change perhaps later */
d931 1
a931 1
		sk_zero(sk);
d940 1
a940 1
			if (!sk_push(sk,(char *)c))
d953 1
a953 1
		sk_free(sk);
d957 1
a957 2
unsigned long SSL_SESSION_hash(a)
SSL_SESSION *a;
d961 5
a965 2
	l=      (a->session_id[0]     )|(a->session_id[1]<< 8L)|
		(a->session_id[2]<<16L)|(a->session_id[3]<<24L);
d969 1
a969 3
int SSL_SESSION_cmp(a, b)
SSL_SESSION *a;
SSL_SESSION *b;
d978 1
a978 2
SSL_CTX *SSL_CTX_new(meth)
SSL_METHOD *meth;
d980 1
a980 1
	SSL_CTX *ret;
d987 6
d1014 1
a1014 11
	ret->sess_connect=0;
	ret->sess_connect_good=0;
	ret->sess_accept=0;
	ret->sess_accept_renegotiate=0;
	ret->sess_connect_renegotiate=0;
	ret->sess_accept_good=0;
	ret->sess_miss=0;
	ret->sess_timeout=0;
	ret->sess_cache_full=0;
	ret->sess_hit=0;
	ret->sess_cb_hit=0;
d1030 3
a1032 2
	ret->default_read_ahead=0;
	ret->default_verify_mode=SSL_VERIFY_NONE;
d1034 1
a1034 1
	if ((ret->default_cert=ssl_cert_new()) == NULL)
d1038 1
d1049 2
a1050 1
	if ((ret->cipher_list == NULL) || (sk_num(ret->cipher_list) <= 0))
d1072 1
a1072 1
	if ((ret->client_CA=sk_new_null()) == NULL)
d1077 3
d1088 4
a1091 2
void SSL_CTX_free(a)
SSL_CTX *a;
d1119 1
a1119 1
		sk_free(a->cipher_list);
d1121 3
a1123 3
		sk_free(a->cipher_list_by_id);
	if (a->default_cert != NULL)
		ssl_cert_free(a->default_cert);
d1125 5
a1129 1
		sk_pop_free(a->client_CA,X509_NAME_free);
d1133 1
a1133 3
void SSL_CTX_set_default_passwd_cb(ctx,cb)
SSL_CTX *ctx;
int (*cb)();
d1138 1
a1138 4
void SSL_CTX_set_cert_verify_cb(ctx,cb,arg)
SSL_CTX *ctx;
int (*cb)();
char *arg;
d1140 10
d1151 1
a1151 1
	ctx->app_verify_arg=arg;
d1154 1
a1154 4
void SSL_CTX_set_verify(ctx,mode,cb)
SSL_CTX *ctx;
int mode;
int (*cb)();
d1156 1
a1156 1
	ctx->default_verify_mode=mode;
d1162 6
a1167 2
void ssl_set_cert_masks(c)
CERT *c;
d1172 1
a1172 1
	int rsa_tmp_export,dh_tmp_export;
d1175 3
a1177 1
	if ((c == NULL) || (c->valid)) return;
d1180 3
a1182 3
	rsa_tmp=((c->rsa_tmp != NULL) || (c->rsa_tmp_cb != NULL))?1:0;
	rsa_tmp_export=((c->rsa_tmp_cb != NULL) ||
		(rsa_tmp && (RSA_size(c->rsa_tmp)*8 <= 512)))?1:0;
d1187 3
a1189 3
	dh_tmp=((c->dh_tmp != NULL) || (c->dh_tmp_cb != NULL))?1:0;
	dh_tmp_export=((c->dh_tmp_cb != NULL) ||
		(dh_tmp && (DH_size(c->dh_tmp)*8 <= 512)))?1:0;
d1195 2
a1196 2
	rsa_enc= ((cpk->x509 != NULL) && (cpk->privatekey != NULL))?1:0;
	rsa_enc_export=(rsa_enc && (EVP_PKEY_size(cpk->privatekey)*8 <= 512))?1:0;
d1198 1
a1198 1
	rsa_sign=((cpk->x509 != NULL) && (cpk->privatekey != NULL))?1:0;
d1200 1
a1200 1
	dsa_sign=((cpk->x509 != NULL) && (cpk->privatekey != NULL))?1:0;
d1202 2
a1203 2
	dh_rsa=  ((cpk->x509 != NULL) && (cpk->privatekey != NULL))?1:0;
	dh_rsa_export=(dh_rsa && (EVP_PKEY_size(cpk->privatekey)*8 <= 512))?1:0;
d1206 2
a1207 2
	dh_dsa=  ((cpk->x509 != NULL) && (cpk->privatekey != NULL))?1:0;
	dh_dsa_export=(dh_dsa && (EVP_PKEY_size(cpk->privatekey)*8 <= 512))?1:0;
d1213 3
a1215 3
	printf("rt=%d dht=%d re=%d rs=%d ds=%d dhr=%d dhd=%d\n",
		rsa_tmp,dh_tmp,
		rsa_enc,rsa_sign,dsa_sign,dh_rsa,dh_dsa);
d1220 1
a1220 1
	if (rsa_enc_export || (rsa_tmp_export && rsa_sign))
d1268 1
a1268 2
X509 *ssl_get_server_send_cert(s)
SSL *s;
d1272 1
a1272 1
	int i,export;
d1275 1
a1275 1
	ssl_set_cert_masks(c);
d1277 2
a1278 2
	export=(alg & SSL_EXPORT)?1:0;
	mask=(export)?c->export_mask:c->mask;
d1303 1
a1303 3
EVP_PKEY *ssl_get_sign_pkey(s,cipher)
SSL *s;
SSL_CIPHER *cipher;
d1330 1
a1330 3
void ssl_update_cache(s,mode)
SSL *s;
int mode;
d1354 2
a1355 2
			?s->ctx->sess_connect_good
			:s->ctx->sess_accept_good) & 0xff) == 0xff)
d1362 1
a1362 2
SSL_METHOD *SSL_get_ssl_method(s)
SSL *s;
d1367 1
a1367 3
int SSL_set_ssl_method(s,meth)
SSL *s;
SSL_METHOD *meth;
d1394 1
a1394 3
int SSL_get_error(s,i)
SSL *s;
int i;
d1397 1
d1402 9
a1410 2
	if (ERR_peek_error() != 0)
		return(SSL_ERROR_SSL);
d1418 9
d1444 1
d1477 1
a1477 2
int SSL_do_handshake(s)
SSL *s;
d1486 3
a1488 1
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
d1498 1
a1498 2
void SSL_set_accept_state(s)
SSL *s;
d1500 1
d1508 1
a1508 2
void SSL_set_connect_state(s)
SSL *s;
d1510 1
d1518 1
a1518 2
int ssl_undefined_function(s)
SSL *s;
d1524 1
a1524 2
SSL_METHOD *ssl_bad_method(ver)
int ver;
d1530 1
a1530 2
char *SSL_get_version(s)
SSL *s;
d1542 3
a1544 4
SSL *SSL_dup(s)
SSL *s;
        {
	STACK *sk;
d1546 1
a1546 1
        SSL *ret;
d1549 2
a1550 1
	if ((ret=SSL_new(SSL_get_SSL_CTX(s))) == NULL) return(NULL);
d1552 25
a1576 2
	/* This copies version, session-id, SSL_METHOD and 'cert' */
	SSL_copy_session_id(ret,s);
d1581 1
d1612 1
a1612 1
		if ((ret->cipher_list=sk_dup(s->cipher_list)) == NULL)
d1616 1
a1616 1
		if ((ret->cipher_list_by_id=sk_dup(s->cipher_list_by_id))
d1623 1
a1623 1
		if ((sk=sk_dup(s->client_CA)) == NULL) goto err;
d1625 1
a1625 1
		for (i=0; i<sk_num(sk); i++)
d1627 2
a1628 2
			xn=(X509_NAME *)sk_value(sk,i);
			if ((sk_value(sk,i)=(char *)X509_NAME_dup(xn)) == NULL)
d1639 1
d1650 1
a1650 2
void ssl_clear_cipher_ctx(s)
SSL *s;
d1652 22
a1673 12
        if (s->enc_read_ctx != NULL)
                {
                EVP_CIPHER_CTX_cleanup(s->enc_read_ctx);
                Free(s->enc_read_ctx);
                s->enc_read_ctx=NULL;
                }
        if (s->enc_write_ctx != NULL)
                {
                EVP_CIPHER_CTX_cleanup(s->enc_write_ctx);
                Free(s->enc_write_ctx);
                s->enc_write_ctx=NULL;
                }
d1677 1
a1677 2
X509 *SSL_get_certificate(s)
SSL *s;
d1686 1
a1686 2
EVP_PKEY *SSL_get_privatekey(s)
SSL *s;
d1694 1
a1694 2
SSL_CIPHER *SSL_get_current_cipher(s)
SSL *s;
d1696 3
a1698 3
        if ((s->session != NULL) && (s->session->cipher != NULL))
                return(s->session->cipher);
        return(NULL);
d1701 1
a1701 3
int ssl_init_wbio_buffer(s,push)
SSL *s;
int push;
d1717 1
a1717 1
	BIO_reset(bbio);
d1736 19
d1756 1
a1756 3
void SSL_CTX_set_quiet_shutdown(ctx,mode)
SSL_CTX *ctx;
int mode;
d1761 1
a1761 2
int SSL_CTX_get_quiet_shutdown(ctx)
SSL_CTX *ctx;
d1766 1
a1766 3
void SSL_set_quiet_shutdown(s,mode)
SSL *s;
int mode;
d1771 1
a1771 2
int SSL_get_quiet_shutdown(s)
SSL *s;
d1776 1
a1776 3
void SSL_set_shutdown(s,mode)
SSL *s;
int mode;
d1781 1
a1781 2
int SSL_get_shutdown(s)
SSL *s;
d1786 1
a1786 2
int SSL_version(s)
SSL *s;
d1791 1
a1791 2
SSL_CTX *SSL_get_SSL_CTX(ssl)
SSL *ssl;
d1796 2
a1797 2
int SSL_CTX_set_default_verify_paths(ctx)
SSL_CTX *ctx;
d1802 2
a1803 4
int SSL_CTX_load_verify_locations(ctx,CAfile,CApath)
SSL_CTX *ctx;
char *CAfile;
char *CApath;
d1807 1
d1809 1
a1809 3
void SSL_set_info_callback(ssl,cb)
SSL *ssl;
void (*cb)();
d1814 1
a1814 2
void (*SSL_get_info_callback(ssl))()
SSL *ssl;
d1816 1
a1816 1
	return(ssl->info_callback);
d1819 1
a1819 2
int SSL_state(ssl)
SSL *ssl;
d1824 1
a1824 3
void SSL_set_verify_result(ssl,arg)
SSL *ssl;
long arg;
d1829 1
a1829 2
long SSL_get_verify_result(ssl)
SSL *ssl;
d1834 3
a1836 7
int SSL_get_ex_new_index(argl,argp,new_func,dup_func,free_func)
long argl;
char *argp;
int (*new_func)();
int (*dup_func)();
void (*free_func)();
        {
d1840 1
a1840 1
        }
d1842 1
a1842 4
int SSL_set_ex_data(s,idx,arg)
SSL *s;
int idx;
char *arg;
d1847 1
a1847 3
char *SSL_get_ex_data(s,idx)
SSL *s;
int idx;
d1852 3
a1854 7
int SSL_CTX_get_ex_new_index(argl,argp,new_func,dup_func,free_func)
long argl;
char *argp;
int (*new_func)();
int (*dup_func)();
void (*free_func)();
        {
d1858 1
a1858 1
        }
d1860 1
a1860 4
int SSL_CTX_set_ex_data(s,idx,arg)
SSL_CTX *s;
int idx;
char *arg;
d1865 1
a1865 3
char *SSL_CTX_get_ex_data(s,idx)
SSL_CTX *s;
int idx;
d1870 72
d1946 2
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 3
/*! \file ssl/ssl_lib.c
 *  \brief Version independent SSL functions.
 */
a57 54
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

a58 3
#ifdef REF_CHECK
#  include <assert.h>
#endif
d60 2
a61 3
#include <openssl/objects.h>
#include <openssl/lhash.h>
#include <openssl/x509v3.h>
a62 1
#include "kssl_lcl.h"
d64 1
a64 1
const char *SSL_version_str=OPENSSL_VERSION_TEXT;
d66 11
a76 4
OPENSSL_GLOBAL SSL3_ENC_METHOD ssl3_undef_enc_method={
	/* evil casts, but these functions are only called if there's a library bug */
	(int (*)(SSL *,int))ssl_undefined_function,
	(int (*)(SSL *, unsigned char *, int))ssl_undefined_function,
a77 3
	(int (*)(SSL *, unsigned char *, unsigned char *, int))ssl_undefined_function,
	(int (*)(SSL*, int))ssl_undefined_function,
	(int (*)(SSL *, EVP_MD_CTX *, EVP_MD_CTX *, const char*, int, unsigned char *))ssl_undefined_function
d80 2
a81 1
int SSL_clear(SSL *s)
d83 1
d85 1
a85 11
	if (s->method == NULL)
		{
		SSLerr(SSL_F_SSL_CLEAR,SSL_R_NO_METHOD_SPECIFIED);
		return(0);
		}

	if (ssl_clear_bad_session(s))
		{
		SSL_SESSION_free(s->session);
		s->session=NULL;
		}
a88 1
	s->shutdown=0;
a89 2
#if 0 /* Disabled since version 1.10 of this file (early return not
       * needed because SSL_clear is not called when doing renegotiation) */
d92 1
a92 8
	if (s->new_session) return(1);
#else
	if (s->new_session)
		{
		SSLerr(SSL_F_SSL_CLEAR,ERR_R_INTERNAL_ERROR);
		return 0;
		}
#endif
d94 1
a96 2
	s->state=SSL_ST_BEFORE|((s->server)?SSL_ST_ACCEPT:SSL_ST_CONNECT);

a97 1
	s->client_version=s->version;
d99 1
d101 3
a103 3
#if 0
	s->read_ahead=s->ctx->read_ahead;
#endif
d113 7
d122 1
a122 14
#if 1
	/* Check to see if we were changed into a different method, if
	 * so, revert back if we are not doing session-id reuse. */
	if (!s->in_handshake && (s->session == NULL) && (s->method != s->ctx->method))
		{
		s->method->ssl_free(s);
		s->method=s->ctx->method;
		if (!s->method->ssl_new(s))
			return(0);
		}
	else
#endif
		s->method->ssl_clear(s);
	return(1);
d125 4
a128 2
/** Used to change an SSL_CTXs default SSL method type */
int SSL_CTX_set_ssl_version(SSL_CTX *ctx,SSL_METHOD *meth)
d130 1
a130 1
	STACK_OF(SSL_CIPHER) *sk;
d136 1
a136 1
	if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= 0))
d144 2
a145 1
SSL *SSL_new(SSL_CTX *ctx)
d160 1
a160 1
	s=(SSL *)OPENSSL_malloc(sizeof(SSL));
d164 1
a164 9
#ifndef	OPENSSL_NO_KRB5
	s->kssl_ctx = kssl_ctx_new();
#endif	/* OPENSSL_NO_KRB5 */

	s->options=ctx->options;
	s->mode=ctx->mode;
	s->max_cert_list=ctx->max_cert_list;

	if (ctx->cert != NULL)
d166 3
a168 13
		/* Earlier library versions used to copy the pointer to
		 * the CERT, not its contents; only when setting new
		 * parameters for the per-SSL copy, ssl_cert_new would be
		 * called (and the direct reference to the per-SSL_CTX
		 * settings would be lost, but those still were indirectly
		 * accessed for various purposes, and for that reason they
		 * used to be known as s->ctx->default_cert).
		 * Now we don't look at the SSL_CTX's CERT after having
		 * duplicated it once. */

		s->cert = ssl_cert_dup(ctx->cert);
		if (s->cert == NULL)
			goto err;
d171 2
a172 9
		s->cert=NULL; /* Cannot really happen (see SSL_CTX_new) */

	s->read_ahead=ctx->read_ahead;
	s->msg_callback=ctx->msg_callback;
	s->msg_callback_arg=ctx->msg_callback_arg;
	s->verify_mode=ctx->verify_mode;
	s->verify_depth=ctx->verify_depth;
	s->sid_ctx_length=ctx->sid_ctx_length;
	memcpy(&s->sid_ctx,&ctx->sid_ctx,sizeof(s->sid_ctx));
a173 5
	s->generate_session_id=ctx->generate_session_id;
	s->purpose = ctx->purpose;
	s->trust = ctx->trust;
	s->quiet_shutdown=ctx->quiet_shutdown;

d182 3
d186 1
d188 1
d190 1
a190 2
	s->server=(ctx->method->ssl_accept == ssl_undefined_function)?0:1;

d193 1
a193 1
	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);
a196 8
	if (s != NULL)
		{
		if (s->cert != NULL)
			ssl_cert_free(s->cert);
		if (s->ctx != NULL)
			SSL_CTX_free(s->ctx); /* decrement reference count */
		OPENSSL_free(s);
		}
d201 2
a202 95
int SSL_CTX_set_session_id_context(SSL_CTX *ctx,const unsigned char *sid_ctx,
				   unsigned int sid_ctx_len)
    {
    if(sid_ctx_len > SSL_MAX_SID_CTX_LENGTH)
	{
	SSLerr(SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
	return 0;
	}
    ctx->sid_ctx_length=sid_ctx_len;
    memcpy(ctx->sid_ctx,sid_ctx,sid_ctx_len);

    return 1;
    }

int SSL_set_session_id_context(SSL *ssl,const unsigned char *sid_ctx,
			       unsigned int sid_ctx_len)
    {
    if(sid_ctx_len > SSL_MAX_SID_CTX_LENGTH)
	{
	SSLerr(SSL_F_SSL_SET_SESSION_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);
	return 0;
	}
    ssl->sid_ctx_length=sid_ctx_len;
    memcpy(ssl->sid_ctx,sid_ctx,sid_ctx_len);

    return 1;
    }

int SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb)
	{
	CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
	ctx->generate_session_id = cb;
	CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
	return 1;
	}

int SSL_set_generate_session_id(SSL *ssl, GEN_SESSION_CB cb)
	{
	CRYPTO_w_lock(CRYPTO_LOCK_SSL);
	ssl->generate_session_id = cb;
	CRYPTO_w_unlock(CRYPTO_LOCK_SSL);
	return 1;
	}

int SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,
				unsigned int id_len)
	{
	/* A quick examination of SSL_SESSION_hash and SSL_SESSION_cmp shows how
	 * we can "construct" a session to give us the desired check - ie. to
	 * find if there's a session in the hash table that would conflict with
	 * any new session built out of this id/id_len and the ssl_version in
	 * use by this SSL. */
	SSL_SESSION r, *p;
	r.ssl_version = ssl->version;
	r.session_id_length = id_len;
	memcpy(r.session_id, id, id_len);
	/* NB: SSLv2 always uses a fixed 16-byte session ID, so even if a
	 * callback is calling us to check the uniqueness of a shorter ID, it
	 * must be compared as a padded-out ID because that is what it will be
	 * converted to when the callback has finished choosing it. */
	if((r.ssl_version == SSL2_VERSION) &&
			(id_len < SSL2_SSL_SESSION_ID_LENGTH))
		{
		memset(r.session_id + id_len, 0,
			SSL2_SSL_SESSION_ID_LENGTH - id_len);
		r.session_id_length = SSL2_SSL_SESSION_ID_LENGTH;
		}

	CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
	p = (SSL_SESSION *)lh_retrieve(ssl->ctx->sessions, &r);
	CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
	return (p != NULL);
	}

int SSL_CTX_set_purpose(SSL_CTX *s, int purpose)
	{
	return X509_PURPOSE_set(&s->purpose, purpose);
	}

int SSL_set_purpose(SSL *s, int purpose)
	{
	return X509_PURPOSE_set(&s->purpose, purpose);
	}

int SSL_CTX_set_trust(SSL_CTX *s, int trust)
	{
	return X509_TRUST_set(&s->trust, trust);
	}

int SSL_set_trust(SSL *s, int trust)
	{
	return X509_TRUST_set(&s->trust, trust);
	}

void SSL_free(SSL *s)
a205 3
	if(s == NULL)
	    return;

d219 1
a219 1
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);
d239 2
a240 2
	if (s->cipher_list != NULL) sk_SSL_CIPHER_free(s->cipher_list);
	if (s->cipher_list_by_id != NULL) sk_SSL_CIPHER_free(s->cipher_list_by_id);
d257 1
a257 1
		sk_X509_NAME_pop_free(s->client_CA,X509_NAME_free);
d261 1
a261 1
	OPENSSL_free(s);
d264 4
a267 1
void SSL_set_bio(SSL *s,BIO *rbio,BIO *wbio)
d287 2
a288 1
BIO *SSL_get_rbio(SSL *s)
d291 2
a292 1
BIO *SSL_get_wbio(SSL *s)
d295 2
a296 6
int SSL_get_fd(SSL *s)
	{
	return(SSL_get_rfd(s));
	}

int SSL_get_rfd(SSL *s)
d308 4
a311 14
int SSL_get_wfd(SSL *s)
	{
	int ret= -1;
	BIO *b,*r;

	b=SSL_get_wbio(s);
	r=BIO_find_type(b,BIO_TYPE_DESCRIPTOR);
	if (r != NULL)
		BIO_get_fd(r,&ret);
	return(ret);
	}

#ifndef OPENSSL_NO_SOCK
int SSL_set_fd(SSL *s,int fd)
d330 3
a332 1
int SSL_set_wfd(SSL *s,int fd)
d354 3
a356 1
int SSL_set_rfd(SSL *s,int fd)
d382 2
a383 33

/* return length of latest Finished message we sent, copy to 'buf' */
size_t SSL_get_finished(SSL *s, void *buf, size_t count)
	{
	size_t ret = 0;
	
	if (s->s3 != NULL)
		{
		ret = s->s3->tmp.finish_md_len;
		if (count > ret)
			count = ret;
		memcpy(buf, s->s3->tmp.finish_md, count);
		}
	return ret;
	}

/* return length of latest Finished message we expected, copy to 'buf' */
size_t SSL_get_peer_finished(SSL *s, void *buf, size_t count)
	{
	size_t ret = 0;
	
	if (s->s3 != NULL)
		{
		ret = s->s3->tmp.peer_finish_md_len;
		if (count > ret)
			count = ret;
		memcpy(buf, s->s3->tmp.peer_finish_md, count);
		}
	return ret;
	}


int SSL_get_verify_mode(SSL *s)
d388 2
a389 6
int SSL_get_verify_depth(SSL *s)
	{
	return(s->verify_depth);
	}

int (*SSL_get_verify_callback(SSL *s))(int,X509_STORE_CTX *)
d394 2
a395 6
int SSL_CTX_get_verify_mode(SSL_CTX *ctx)
	{
	return(ctx->verify_mode);
	}

int SSL_CTX_get_verify_depth(SSL_CTX *ctx)
d397 1
a397 1
	return(ctx->verify_depth);
d400 2
a401 1
int (*SSL_CTX_get_verify_callback(SSL_CTX *ctx))(int,X509_STORE_CTX *)
d406 4
a409 2
void SSL_set_verify(SSL *s,int mode,
		    int (*callback)(int ok,X509_STORE_CTX *ctx))
d416 3
a418 6
void SSL_set_verify_depth(SSL *s,int depth)
	{
	s->verify_depth=depth;
	}

void SSL_set_read_ahead(SSL *s,int yes)
d423 2
a424 1
int SSL_get_read_ahead(SSL *s)
d429 2
a430 1
int SSL_pending(SSL *s)
a431 7
	/* SSL_pending cannot work properly if read-ahead is enabled
	 * (SSL_[CTX_]ctrl(..., SSL_CTRL_SET_READ_AHEAD, 1, NULL)),
	 * and it is impossible to fix since SSL_pending cannot report
	 * errors that may be observed while scanning the new data.
	 * (Note that SSL_pending() is often used as a boolean value,
	 * so we'd better not return -1.)
	 */
d435 2
a436 1
X509 *SSL_get_peer_certificate(SSL *s)
d452 2
a453 1
STACK_OF(X509) *SSL_get_peer_cert_chain(SSL *s)
d455 1
a455 1
	STACK_OF(X509) *r;
d457 1
a457 1
	if ((s == NULL) || (s->session == NULL) || (s->session->sess_cert == NULL))
d460 1
a460 1
		r=s->session->sess_cert->cert_chain;
a461 3
	/* If we are a client, cert_chain includes the peer's own
	 * certificate; if we are a server, it does not. */
	
d467 2
a468 1
void SSL_copy_session_id(SSL *t,SSL *f)
a492 1
	SSL_set_session_id_context(t,f->sid_ctx,f->sid_ctx_length);
d496 2
a497 1
int SSL_CTX_check_private_key(SSL_CTX *ctx)
d500 2
a501 2
		(ctx->cert == NULL) ||
		(ctx->cert->key->x509 == NULL))
d506 1
a506 1
	if 	(ctx->cert->key->privatekey == NULL)
d511 1
a511 1
	return(X509_check_private_key(ctx->cert->key->x509, ctx->cert->key->privatekey));
d515 2
a516 1
int SSL_check_private_key(SSL *ssl)
d524 1
a524 4
		{
                SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);
		return 0;
		}
d539 2
a540 1
int SSL_accept(SSL *s)
a541 4
	if (s->handshake_func == 0)
		/* Not properly initialized yet */
		SSL_set_accept_state(s);

d545 2
a546 1
int SSL_connect(SSL *s)
a547 4
	if (s->handshake_func == 0)
		/* Not properly initialized yet */
		SSL_set_connect_state(s);

d551 2
a552 1
long SSL_get_default_timeout(SSL *s)
d557 4
a560 1
int SSL_read(SSL *s,void *buf,int num)
a561 6
	if (s->handshake_func == 0)
		{
		SSLerr(SSL_F_SSL_READ, SSL_R_UNINITIALIZED);
		return -1;
		}

d570 4
a573 1
int SSL_peek(SSL *s,void *buf,int num)
a574 6
	if (s->handshake_func == 0)
		{
		SSLerr(SSL_F_SSL_READ, SSL_R_UNINITIALIZED);
		return -1;
		}

d582 4
a585 1
int SSL_write(SSL *s,const void *buf,int num)
a586 6
	if (s->handshake_func == 0)
		{
		SSLerr(SSL_F_SSL_WRITE, SSL_R_UNINITIALIZED);
		return -1;
		}

d596 2
a597 1
int SSL_shutdown(SSL *s)
a598 12
	/* Note that this function behaves differently from what one might
	 * expect.  Return values are 0 for no success (yet),
	 * 1 for success; but calling it once is usually not enough,
	 * even if blocking I/O is used (see ssl3_shutdown).
	 */

	if (s->handshake_func == 0)
		{
		SSLerr(SSL_F_SSL_SHUTDOWN, SSL_R_UNINITIALIZED);
		return -1;
		}

d605 2
a606 1
int SSL_renegotiate(SSL *s)
d608 1
a608 4
	if (s->new_session == 0)
		{
		s->new_session=1;
		}
d612 5
a616 1
int SSL_renegotiate_pending(SSL *s)
d618 1
a618 3
	/* becomes true when negotiation is requested;
	 * false again once a handshake has finished */
	return (s->new_session != 0);
d621 5
a625 1
long SSL_ctrl(SSL *s,int cmd,long larg,void *parg)
d627 1
a627 28
	long l;

	switch (cmd)
		{
	case SSL_CTRL_GET_READ_AHEAD:
		return(s->read_ahead);
	case SSL_CTRL_SET_READ_AHEAD:
		l=s->read_ahead;
		s->read_ahead=larg;
		return(l);

	case SSL_CTRL_SET_MSG_CALLBACK_ARG:
		s->msg_callback_arg = parg;
		return 1;

	case SSL_CTRL_OPTIONS:
		return(s->options|=larg);
	case SSL_CTRL_MODE:
		return(s->mode|=larg);
	case SSL_CTRL_GET_MAX_CERT_LIST:
		return(s->max_cert_list);
	case SSL_CTRL_SET_MAX_CERT_LIST:
		l=s->max_cert_list;
		s->max_cert_list=larg;
		return(l);
	default:
		return(s->method->ssl_ctrl(s,cmd,larg,parg));
		}
d630 2
a631 102
long SSL_callback_ctrl(SSL *s, int cmd, void (*fp)())
	{
	switch(cmd)
		{
	case SSL_CTRL_SET_MSG_CALLBACK:
		s->msg_callback = (void (*)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))(fp);
		return 1;
		
	default:
		return(s->method->ssl_callback_ctrl(s,cmd,fp));
		}
	}

struct lhash_st *SSL_CTX_sessions(SSL_CTX *ctx)
	{
	return ctx->sessions;
	}

long SSL_CTX_ctrl(SSL_CTX *ctx,int cmd,long larg,void *parg)
	{
	long l;

	switch (cmd)
		{
	case SSL_CTRL_GET_READ_AHEAD:
		return(ctx->read_ahead);
	case SSL_CTRL_SET_READ_AHEAD:
		l=ctx->read_ahead;
		ctx->read_ahead=larg;
		return(l);
		
	case SSL_CTRL_SET_MSG_CALLBACK_ARG:
		ctx->msg_callback_arg = parg;
		return 1;

	case SSL_CTRL_GET_MAX_CERT_LIST:
		return(ctx->max_cert_list);
	case SSL_CTRL_SET_MAX_CERT_LIST:
		l=ctx->max_cert_list;
		ctx->max_cert_list=larg;
		return(l);

	case SSL_CTRL_SET_SESS_CACHE_SIZE:
		l=ctx->session_cache_size;
		ctx->session_cache_size=larg;
		return(l);
	case SSL_CTRL_GET_SESS_CACHE_SIZE:
		return(ctx->session_cache_size);
	case SSL_CTRL_SET_SESS_CACHE_MODE:
		l=ctx->session_cache_mode;
		ctx->session_cache_mode=larg;
		return(l);
	case SSL_CTRL_GET_SESS_CACHE_MODE:
		return(ctx->session_cache_mode);

	case SSL_CTRL_SESS_NUMBER:
		return(ctx->sessions->num_items);
	case SSL_CTRL_SESS_CONNECT:
		return(ctx->stats.sess_connect);
	case SSL_CTRL_SESS_CONNECT_GOOD:
		return(ctx->stats.sess_connect_good);
	case SSL_CTRL_SESS_CONNECT_RENEGOTIATE:
		return(ctx->stats.sess_connect_renegotiate);
	case SSL_CTRL_SESS_ACCEPT:
		return(ctx->stats.sess_accept);
	case SSL_CTRL_SESS_ACCEPT_GOOD:
		return(ctx->stats.sess_accept_good);
	case SSL_CTRL_SESS_ACCEPT_RENEGOTIATE:
		return(ctx->stats.sess_accept_renegotiate);
	case SSL_CTRL_SESS_HIT:
		return(ctx->stats.sess_hit);
	case SSL_CTRL_SESS_CB_HIT:
		return(ctx->stats.sess_cb_hit);
	case SSL_CTRL_SESS_MISSES:
		return(ctx->stats.sess_miss);
	case SSL_CTRL_SESS_TIMEOUTS:
		return(ctx->stats.sess_timeout);
	case SSL_CTRL_SESS_CACHE_FULL:
		return(ctx->stats.sess_cache_full);
	case SSL_CTRL_OPTIONS:
		return(ctx->options|=larg);
	case SSL_CTRL_MODE:
		return(ctx->mode|=larg);
	default:
		return(ctx->method->ssl_ctx_ctrl(ctx,cmd,larg,parg));
		}
	}

long SSL_CTX_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)())
	{
	switch(cmd)
		{
	case SSL_CTRL_SET_MSG_CALLBACK:
		ctx->msg_callback = (void (*)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))(fp);
		return 1;

	default:
		return(ctx->method->ssl_ctx_callback_ctrl(ctx,cmd,fp));
		}
	}

int ssl_cipher_id_cmp(const SSL_CIPHER *a, const SSL_CIPHER *b)
d642 2
a643 2
int ssl_cipher_ptr_id_cmp(const SSL_CIPHER * const *ap,
			const SSL_CIPHER * const *bp)
d654 1
a654 1
/** return a STACK of the ciphers available for the SSL and in order of
d656 2
a657 1
STACK_OF(SSL_CIPHER) *SSL_get_ciphers(SSL *s)
d671 1
a671 1
/** return a STACK of the ciphers available for the SSL and in order of
d673 2
a674 1
STACK_OF(SSL_CIPHER) *ssl_get_ciphers_by_id(SSL *s)
d688 4
a691 2
/** The old interface to get the same thing as SSL_get_ciphers() */
const char *SSL_get_cipher_list(SSL *s,int n)
d694 1
a694 1
	STACK_OF(SSL_CIPHER) *sk;
d698 1
a698 1
	if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
d700 1
a700 1
	c=sk_SSL_CIPHER_value(sk,n);
d705 4
a708 2
/** specify the ciphers to be used by default by the SSL_CTX */
int SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str)
d710 1
a710 1
	STACK_OF(SSL_CIPHER) *sk;
d718 4
a721 2
/** specify the ciphers to be used by the SSL */
int SSL_set_cipher_list(SSL *s,const char *str)
d723 1
a723 1
	STACK_OF(SSL_CIPHER) *sk;
d732 4
a735 1
char *SSL_get_shared_ciphers(SSL *s,char *buf,int len)
d737 2
a738 3
	char *p;
	const char *cp;
	STACK_OF(SSL_CIPHER) *sk;
d748 1
a748 1
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
d752 1
a752 1
		c=sk_SSL_CIPHER_value(sk,i);
d769 4
a772 1
int ssl_cipher_list_to_bytes(SSL *s,STACK_OF(SSL_CIPHER) *sk,unsigned char *p)
a776 3
#ifndef OPENSSL_NO_KRB5
        int nokrb5 = !kssl_tgt_is_available(s->kssl_ctx);
#endif /* OPENSSL_NO_KRB5 */
d781 1
a781 1
	for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
d783 1
a783 5
		c=sk_SSL_CIPHER_value(sk,i);
#ifndef OPENSSL_NO_KRB5
                if ((c->algorithms & SSL_KRB5) && nokrb5)
                    continue;
#endif /* OPENSSL_NO_KRB5 */                    
d790 5
a794 2
STACK_OF(SSL_CIPHER) *ssl_bytes_to_cipher_list(SSL *s,unsigned char *p,int num,
					       STACK_OF(SSL_CIPHER) **skp)
d797 1
a797 1
	STACK_OF(SSL_CIPHER) *sk;
d807 1
a807 1
		sk=sk_SSL_CIPHER_new_null(); /* change perhaps later */
d811 1
a811 1
		sk_SSL_CIPHER_zero(sk);
d820 1
a820 1
			if (!sk_SSL_CIPHER_push(sk,c))
d833 1
a833 1
		sk_SSL_CIPHER_free(sk);
d837 2
a838 1
unsigned long SSL_SESSION_hash(SSL_SESSION *a)
d842 2
a843 5
	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
d847 3
a849 6
/* NB: If this function (or indeed the hash function which uses a sort of
 * coarser function than this one) is changed, ensure
 * SSL_CTX_has_matching_session_id() is checked accordingly. It relies on being
 * able to construct an SSL_SESSION that will collide with any existing session
 * with a matching session ID. */
int SSL_SESSION_cmp(SSL_SESSION *a,SSL_SESSION *b)
d858 2
a859 8
/* These wrapper functions should remain rather than redeclaring
 * SSL_SESSION_hash and SSL_SESSION_cmp for void* types and casting each
 * variable. The reason is that the functions aren't static, they're exposed via
 * ssl.h. */
static IMPLEMENT_LHASH_HASH_FN(SSL_SESSION_hash, SSL_SESSION *)
static IMPLEMENT_LHASH_COMP_FN(SSL_SESSION_cmp, SSL_SESSION *)

SSL_CTX *SSL_CTX_new(SSL_METHOD *meth)
d861 1
a861 1
	SSL_CTX *ret=NULL;
d868 1
a868 7

	if (SSL_get_ex_data_X509_STORE_CTX_idx() < 0)
		{
		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);
		goto err;
		}
	ret=(SSL_CTX *)OPENSSL_malloc(sizeof(SSL_CTX));
d885 15
a899 6
	ret->new_session_cb=0;
	ret->remove_session_cb=0;
	ret->get_session_cb=0;
	ret->generate_session_id=0;

	memset((char *)&ret->stats,0,sizeof(ret->stats));
d912 1
a912 1
	ret->app_verify_callback=0;
d915 2
a916 7
	ret->max_cert_list=SSL_MAX_CERT_LIST_DEFAULT;
	ret->read_ahead=0;
	ret->msg_callback=0;
	ret->msg_callback_arg=NULL;
	ret->verify_mode=SSL_VERIFY_NONE;
	ret->verify_depth=-1; /* Don't impose a limit (but x509_lu.c does) */
	ret->sid_ctx_length=0;
d918 1
a918 1
	if ((ret->cert=ssl_cert_new()) == NULL)
d921 2
a922 3
	ret->default_passwd_callback=0;
	ret->default_passwd_callback_userdata=NULL;
	ret->client_cert_cb=0;
d924 1
a924 2
	ret->sessions=lh_new(LHASH_HASH_FN(SSL_SESSION_hash),
			LHASH_COMP_FN(SSL_SESSION_cmp));
d932 1
a932 2
	if (ret->cipher_list == NULL
	    || sk_SSL_CIPHER_num(ret->cipher_list) <= 0)
d954 1
a954 1
	if ((ret->client_CA=sk_X509_NAME_new_null()) == NULL)
d957 1
a957 4
	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_CTX, ret, &ret->ex_data);

	ret->extra_certs=NULL;
	ret->comp_methods=SSL_COMP_get_compression_methods();
d967 2
a968 6
#if 0
static void SSL_COMP_free(SSL_COMP *comp)
    { OPENSSL_free(comp); }
#endif

void SSL_CTX_free(SSL_CTX *a)
d986 1
a986 1
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_CTX, a, &a->ex_data);
d996 1
a996 1
		sk_SSL_CIPHER_free(a->cipher_list);
d998 3
a1000 3
		sk_SSL_CIPHER_free(a->cipher_list_by_id);
	if (a->cert != NULL)
		ssl_cert_free(a->cert);
d1002 2
a1003 10
		sk_X509_NAME_pop_free(a->client_CA,X509_NAME_free);
	if (a->extra_certs != NULL)
		sk_X509_pop_free(a->extra_certs,X509_free);
#if 0 /* This should never be done, since it removes a global database */
	if (a->comp_methods != NULL)
		sk_SSL_COMP_pop_free(a->comp_methods,SSL_COMP_free);
#else
	a->comp_methods = NULL;
#endif
	OPENSSL_free(a);
d1006 3
a1008 1
void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb)
d1013 4
a1016 6
void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx,void *u)
	{
	ctx->default_passwd_callback_userdata=u;
	}

void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(X509_STORE_CTX *,void *), void *arg)
d1022 4
a1025 1
void SSL_CTX_set_verify(SSL_CTX *ctx,int mode,int (*cb)(int, X509_STORE_CTX *))
d1027 1
a1027 1
	ctx->verify_mode=mode;
d1029 2
d1033 2
a1034 6
void SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth)
	{
	ctx->verify_depth=depth;
	}

void ssl_set_cert_masks(CERT *c, SSL_CIPHER *cipher)
d1039 1
a1039 1
	int rsa_tmp_export,dh_tmp_export,kl;
d1042 1
a1042 3
	if (c == NULL) return;

	kl=SSL_C_EXPORT_PKEYLENGTH(cipher);
d1044 4
a1047 4
#ifndef OPENSSL_NO_RSA
	rsa_tmp=(c->rsa_tmp != NULL || c->rsa_tmp_cb != NULL);
	rsa_tmp_export=(c->rsa_tmp_cb != NULL ||
		(rsa_tmp && RSA_size(c->rsa_tmp)*8 <= kl));
d1051 4
a1054 4
#ifndef OPENSSL_NO_DH
	dh_tmp=(c->dh_tmp != NULL || c->dh_tmp_cb != NULL);
	dh_tmp_export=(c->dh_tmp_cb != NULL ||
		(dh_tmp && DH_size(c->dh_tmp)*8 <= kl));
d1060 2
a1061 2
	rsa_enc= (cpk->x509 != NULL && cpk->privatekey != NULL);
	rsa_enc_export=(rsa_enc && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
d1063 1
a1063 1
	rsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);
d1065 1
a1065 1
	dsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);
d1067 2
a1068 2
	dh_rsa=  (cpk->x509 != NULL && cpk->privatekey != NULL);
	dh_rsa_export=(dh_rsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
d1071 2
a1072 2
	dh_dsa=  (cpk->x509 != NULL && cpk->privatekey != NULL);
	dh_dsa_export=(dh_dsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
d1078 3
a1080 3
	printf("rt=%d rte=%d dht=%d re=%d ree=%d rs=%d ds=%d dhr=%d dhd=%d\n",
		rsa_tmp,rsa_tmp_export,dh_tmp,
		rsa_enc,rsa_enc_export,rsa_sign,dsa_sign,dh_rsa,dh_dsa);
d1085 1
a1085 1
	if (rsa_enc_export || (rsa_tmp_export && (rsa_sign || rsa_enc)))
d1122 1
a1124 4

#ifndef OPENSSL_NO_KRB5
	mask|=SSL_kKRB5|SSL_aKRB5;
	emask|=SSL_kKRB5|SSL_aKRB5;
d1133 2
a1134 1
X509 *ssl_get_server_send_cert(SSL *s)
d1138 1
a1138 1
	int i,is_export;
d1141 1
a1141 1
	ssl_set_cert_masks(c, s->s3->tmp.new_cipher);
d1143 2
a1144 2
	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
	mask=is_export?c->export_mask:c->mask;
a1159 5
	else if (kalg & SSL_aKRB5)
		{
		/* VRS something else here? */
		return(NULL);
		}
d1162 1
a1162 1
		SSLerr(SSL_F_SSL_GET_SERVER_SEND_CERT,ERR_R_INTERNAL_ERROR);
d1169 3
a1171 1
EVP_PKEY *ssl_get_sign_pkey(SSL *s,SSL_CIPHER *cipher)
d1193 1
a1193 1
		SSLerr(SSL_F_SSL_GET_SIGN_PKEY,ERR_R_INTERNAL_ERROR);
d1198 3
a1200 1
void ssl_update_cache(SSL *s,int mode)
d1208 3
a1210 4
	i=s->ctx->session_cache_mode;
	if ((i & mode) && (!s->hit)
		&& ((i & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)
		    || SSL_CTX_add_session(s->ctx,s->session))
d1219 1
d1224 2
a1225 2
			?s->ctx->stats.sess_connect_good
			:s->ctx->stats.sess_accept_good) & 0xff) == 0xff)
d1232 2
a1233 1
SSL_METHOD *SSL_get_ssl_method(SSL *s)
d1238 3
a1240 1
int SSL_set_ssl_method(SSL *s,SSL_METHOD *meth)
d1267 3
a1269 1
int SSL_get_error(SSL *s,int i)
a1271 1
	unsigned long l;
d1276 2
a1277 9
	/* Make things return SSL_ERROR_SYSCALL when doing SSL_do_handshake
	 * etc, where we do encode the error */
	if ((l=ERR_peek_error()) != 0)
		{
		if (ERR_GET_LIB(l) == ERR_LIB_SYS)
			return(SSL_ERROR_SYSCALL);
		else
			return(SSL_ERROR_SSL);
		}
a1284 9
			/* This one doesn't make too much sense ... We never try
			 * to write to the rbio, and an application program where
			 * rbio and wbio are separate couldn't even know what it
			 * should wait for.
			 * However if we ever set s->rwstate incorrectly
			 * (so that we have SSL_want_read(s) instead of
			 * SSL_want_write(s)) and rbio and wbio *are* the same,
			 * this test works around that bug; so it might be safer
			 * to keep it. */
a1290 2
			else if (reason == BIO_RR_ACCEPT)
				return(SSL_ERROR_WANT_ACCEPT);
a1301 1
			/* See above (SSL_want_read(s) with BIO_should_write(bio)) */
a1307 2
			else if (reason == BIO_RR_ACCEPT)
				return(SSL_ERROR_WANT_ACCEPT);
d1334 2
a1335 1
int SSL_do_handshake(SSL *s)
d1344 1
a1344 3

	s->method->ssl_renegotiate_check(s);

d1354 2
a1355 1
void SSL_set_accept_state(SSL *s)
a1356 1
	s->server=1;
d1364 2
a1365 1
void SSL_set_connect_state(SSL *s)
a1366 1
	s->server=0;
d1374 2
a1375 1
int ssl_undefined_function(SSL *s)
d1381 2
a1382 1
SSL_METHOD *ssl_bad_method(int ver)
d1388 2
a1389 1
const char *SSL_get_version(SSL *s)
d1401 4
a1404 3
SSL *SSL_dup(SSL *s)
	{
	STACK_OF(X509_NAME) *sk;
d1406 1
a1406 1
	SSL *ret;
d1409 4
a1412 18
	if ((ret=SSL_new(SSL_get_SSL_CTX(s))) == NULL)
	    return(NULL);

	ret->version = s->version;
	ret->type = s->type;
	ret->method = s->method;

	if (s->session != NULL)
		{
		/* This copies session-id, SSL_METHOD, sid_ctx, and 'cert' */
		SSL_copy_session_id(ret,s);
		}
	else
		{
		/* No session has been established yet, so we have to expect
		 * that s->cert or ret->cert will be changed later --
		 * they should not both point to the same object,
		 * and thus we can't use SSL_copy_session_id. */
a1413 21
		ret->method = s->method;
		ret->method->ssl_new(ret);

		if (s->cert != NULL)
			{
			if (ret->cert != NULL)
				{
				ssl_cert_free(ret->cert);
				}
			ret->cert = ssl_cert_dup(s->cert);
			if (ret->cert == NULL)
				goto err;
			}
				
		SSL_set_session_id_context(ret,
			s->sid_ctx, s->sid_ctx_length);
		}

	ret->options=s->options;
	ret->mode=s->mode;
	SSL_set_max_cert_list(ret,SSL_get_max_cert_list(s));
a1414 2
	ret->msg_callback = s->msg_callback;
	ret->msg_callback_arg = s->msg_callback_arg;
a1416 2
	SSL_set_verify_depth(ret,SSL_get_verify_depth(s));
	ret->generate_session_id = s->generate_session_id;
d1421 1
d1424 1
a1424 1
	if (!CRYPTO_dup_ex_data(CRYPTO_EX_INDEX_SSL, &ret->ex_data, &s->ex_data))
a1442 13
	ret->rwstate = s->rwstate;
	ret->in_handshake = s->in_handshake;
	ret->handshake_func = s->handshake_func;
	ret->server = s->server;
	ret->new_session = s->new_session;
	ret->quiet_shutdown = s->quiet_shutdown;
	ret->shutdown=s->shutdown;
	ret->state=s->state; /* SSL_dup does not really work at any state, though */
	ret->rstate=s->rstate;
	ret->init_num = 0; /* would have to copy ret->init_buf, ret->init_msg, ret->init_num, ret->init_off */
	ret->hit=s->hit;
	ret->purpose=s->purpose;
	ret->trust=s->trust;
d1447 1
a1447 1
		if ((ret->cipher_list=sk_SSL_CIPHER_dup(s->cipher_list)) == NULL)
d1451 1
a1451 1
		if ((ret->cipher_list_by_id=sk_SSL_CIPHER_dup(s->cipher_list_by_id))
d1458 1
a1458 1
		if ((sk=sk_X509_NAME_dup(s->client_CA)) == NULL) goto err;
d1460 1
a1460 1
		for (i=0; i<sk_X509_NAME_num(sk); i++)
d1462 2
a1463 2
			xn=sk_X509_NAME_value(sk,i);
			if (sk_X509_NAME_set(sk,i,X509_NAME_dup(xn)) == NULL)
d1471 4
d1484 2
a1485 1
void ssl_clear_cipher_ctx(SSL *s)
d1487 12
a1498 22
	if (s->enc_read_ctx != NULL)
		{
		EVP_CIPHER_CTX_cleanup(s->enc_read_ctx);
		OPENSSL_free(s->enc_read_ctx);
		s->enc_read_ctx=NULL;
		}
	if (s->enc_write_ctx != NULL)
		{
		EVP_CIPHER_CTX_cleanup(s->enc_write_ctx);
		OPENSSL_free(s->enc_write_ctx);
		s->enc_write_ctx=NULL;
		}
	if (s->expand != NULL)
		{
		COMP_CTX_free(s->expand);
		s->expand=NULL;
		}
	if (s->compress != NULL)
		{
		COMP_CTX_free(s->compress);
		s->compress=NULL;
		}
d1502 2
a1503 1
X509 *SSL_get_certificate(SSL *s)
d1512 2
a1513 1
EVP_PKEY *SSL_get_privatekey(SSL *s)
d1521 2
a1522 1
SSL_CIPHER *SSL_get_current_cipher(SSL *s)
d1524 3
a1526 3
	if ((s->session != NULL) && (s->session->cipher != NULL))
		return(s->session->cipher);
	return(NULL);
d1529 3
a1531 1
int ssl_init_wbio_buffer(SSL *s,int push)
d1547 1
a1547 1
	(void)BIO_reset(bbio);
a1565 16

void ssl_free_wbio_buffer(SSL *s)
	{
	if (s->bbio == NULL) return;

	if (s->bbio == s->wbio)
		{
		/* remove buffering */
		s->wbio=BIO_pop(s->wbio);
#ifdef REF_CHECK /* not the usual REF_CHECK, but this avoids adding one more preprocessor symbol */
		assert(s->wbio != NULL);
#endif	
	}
	BIO_free(s->bbio);
	s->bbio=NULL;
	}
d1567 3
a1569 1
void SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx,int mode)
d1574 2
a1575 1
int SSL_CTX_get_quiet_shutdown(SSL_CTX *ctx)
d1580 3
a1582 1
void SSL_set_quiet_shutdown(SSL *s,int mode)
d1587 2
a1588 1
int SSL_get_quiet_shutdown(SSL *s)
d1593 3
a1595 1
void SSL_set_shutdown(SSL *s,int mode)
d1600 2
a1601 1
int SSL_get_shutdown(SSL *s)
d1606 2
a1607 1
int SSL_version(SSL *s)
d1612 2
a1613 1
SSL_CTX *SSL_get_SSL_CTX(SSL *ssl)
d1618 2
a1619 2
#ifndef OPENSSL_NO_STDIO
int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx)
d1624 4
a1627 2
int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,
		const char *CApath)
a1630 1
#endif
d1632 3
a1634 2
void SSL_set_info_callback(SSL *ssl,
			   void (*cb)(const SSL *ssl,int type,int val))
d1639 2
a1640 1
void (*SSL_get_info_callback(SSL *ssl))(const SSL *ssl,int type,int val)
d1642 1
a1642 1
	return ssl->info_callback;
d1645 2
a1646 1
int SSL_state(SSL *ssl)
d1651 3
a1653 1
void SSL_set_verify_result(SSL *ssl,long arg)
d1658 2
a1659 1
long SSL_get_verify_result(SSL *ssl)
d1664 16
a1679 8
int SSL_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,
			 CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)
	{
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, argl, argp,
				new_func, dup_func, free_func);
	}

int SSL_set_ex_data(SSL *s,int idx,void *arg)
d1684 3
a1686 1
void *SSL_get_ex_data(SSL *s,int idx)
d1691 16
a1706 8
int SSL_CTX_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,
			     CRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)
	{
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, argl, argp,
				new_func, dup_func, free_func);
	}

int SSL_CTX_set_ex_data(SSL_CTX *s,int idx,void *arg)
d1711 3
a1713 1
void *SSL_CTX_get_ex_data(SSL_CTX *s,int idx)
d1718 1
a1718 92
int ssl_ok(SSL *s)
	{
	return(1);
	}

X509_STORE *SSL_CTX_get_cert_store(SSL_CTX *ctx)
	{
	return(ctx->cert_store);
	}

void SSL_CTX_set_cert_store(SSL_CTX *ctx,X509_STORE *store)
	{
	if (ctx->cert_store != NULL)
		X509_STORE_free(ctx->cert_store);
	ctx->cert_store=store;
	}

int SSL_want(SSL *s)
	{
	return(s->rwstate);
	}

/*!
 * \brief Set the callback for generating temporary RSA keys.
 * \param ctx the SSL context.
 * \param cb the callback
 */

#ifndef OPENSSL_NO_RSA
void SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,RSA *(*cb)(SSL *ssl,
							  int is_export,
							  int keylength))
    {
    SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_RSA_CB,(void (*)())cb);
    }

void SSL_set_tmp_rsa_callback(SSL *ssl,RSA *(*cb)(SSL *ssl,
						  int is_export,
						  int keylength))
    {
    SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_RSA_CB,(void (*)())cb);
    }
#endif

#ifdef DOXYGEN
/*!
 * \brief The RSA temporary key callback function.
 * \param ssl the SSL session.
 * \param is_export \c TRUE if the temp RSA key is for an export ciphersuite.
 * \param keylength if \c is_export is \c TRUE, then \c keylength is the size
 * of the required key in bits.
 * \return the temporary RSA key.
 * \sa SSL_CTX_set_tmp_rsa_callback, SSL_set_tmp_rsa_callback
 */

RSA *cb(SSL *ssl,int is_export,int keylength)
    {}
#endif

/*!
 * \brief Set the callback for generating temporary DH keys.
 * \param ctx the SSL context.
 * \param dh the callback
 */

#ifndef OPENSSL_NO_DH
void SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,DH *(*dh)(SSL *ssl,int is_export,
							int keylength))
	{
	SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_DH_CB,(void (*)())dh);
	}

void SSL_set_tmp_dh_callback(SSL *ssl,DH *(*dh)(SSL *ssl,int is_export,
						int keylength))
	{
	SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_DH_CB,(void (*)())dh);
	}
#endif


void SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))
	{
	SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK, (void (*)())cb);
	}
void SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))
	{
	SSL_callback_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK, (void (*)())cb);
	}



#if defined(_WINDLL) && defined(OPENSSL_SYS_WIN16)
a1721 2
IMPLEMENT_STACK_OF(SSL_CIPHER)
IMPLEMENT_STACK_OF(SSL_COMP)
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a118 2
#include "ssl_locl.h"
#include "kssl_lcl.h"
d122 2
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d1408 1
a1409 9
	/*
	 * Free internal session cache. However: the remove_cb() may reference
	 * the ex_data of SSL_CTX, thus the ex_data store can only be removed
	 * after the sessions were flushed.
	 * As the ex_data handling routines might also touch the session cache,
	 * the most secure solution seems to be: empty (flush) the cache, then
	 * free ex_data, then finally free the cache.
	 * (See ticket [openssl.org #212].)
	 */
d1411 1
a1412 4

	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_CTX, a, &a->ex_data);

	if (a->sessions != NULL)
d1414 1
a1414 1

@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@a123 1
#include "cryptlib.h"
a275 1
	OPENSSL_assert(s->sid_ctx_length <= sizeof s->sid_ctx);
d317 1
a317 1
    if(sid_ctx_len > sizeof ctx->sid_ctx)
a366 4

	if(id_len > sizeof r.session_id)
		return 0;

d1066 6
a1071 1
	if (s != NULL)
d1073 1
a1073 9
		if (s->cipher_list != NULL)
			{
			return(s->cipher_list);
			}
		else if ((s->ctx != NULL) &&
			(s->ctx->cipher_list != NULL))
			{
			return(s->ctx->cipher_list);
			}
d1082 6
a1087 1
	if (s != NULL)
d1089 1
a1089 9
		if (s->cipher_list_by_id != NULL)
			{
			return(s->cipher_list_by_id);
			}
		else if ((s->ctx != NULL) &&
			(s->ctx->cipher_list_by_id != NULL))
			{
			return(s->ctx->cipher_list_by_id);
			}
d1655 1
a1655 1
		&& ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE)
a1886 1
		ret->method->ssl_free(ret);
@


1.1.1.6
log
@import 0.9.7c
@
text
@a475 5
#ifndef	OPENSSL_NO_KRB5
	if (s->kssl_ctx != NULL)
		kssl_ctx_free(s->kssl_ctx);
#endif	/* OPENSSL_NO_KRB5 */

@


1.1.1.7
log
@import openssl-0.9.7d
@
text
@d124 1
@


1.1.1.8
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a123 1
#include <openssl/fips.h>
d503 1
a503 1
BIO *SSL_get_rbio(const SSL *s)
d506 1
a506 1
BIO *SSL_get_wbio(const SSL *s)
d509 1
a509 1
int SSL_get_fd(const SSL *s)
d514 1
a514 1
int SSL_get_rfd(const SSL *s)
d526 1
a526 1
int SSL_get_wfd(const SSL *s)
d608 1
a608 1
size_t SSL_get_finished(const SSL *s, void *buf, size_t count)
d623 1
a623 1
size_t SSL_get_peer_finished(const SSL *s, void *buf, size_t count)
d638 1
a638 1
int SSL_get_verify_mode(const SSL *s)
d643 1
a643 1
int SSL_get_verify_depth(const SSL *s)
d648 1
a648 1
int (*SSL_get_verify_callback(const SSL *s))(int,X509_STORE_CTX *)
d653 1
a653 1
int SSL_CTX_get_verify_mode(const SSL_CTX *ctx)
d658 1
a658 1
int SSL_CTX_get_verify_depth(const SSL_CTX *ctx)
d663 1
a663 1
int (*SSL_CTX_get_verify_callback(const SSL_CTX *ctx))(int,X509_STORE_CTX *)
d686 1
a686 1
int SSL_get_read_ahead(const SSL *s)
d691 1
a691 1
int SSL_pending(const SSL *s)
d703 1
a703 1
X509 *SSL_get_peer_certificate(const SSL *s)
d719 1
a719 1
STACK_OF(X509) *SSL_get_peer_cert_chain(const SSL *s)
d736 1
a736 1
void SSL_copy_session_id(SSL *t,const SSL *f)
d765 1
a765 1
int SSL_CTX_check_private_key(const SSL_CTX *ctx)
d783 1
a783 1
int SSL_check_private_key(const SSL *ssl)
d827 1
a827 1
long SSL_get_default_timeout(const SSL *s)
d1074 1
a1074 1
STACK_OF(SSL_CIPHER) *SSL_get_ciphers(const SSL *s)
d1111 1
a1111 1
const char *SSL_get_cipher_list(const SSL *s,int n)
d1148 1
a1148 1
char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)
d1252 1
a1252 1
unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
d1269 1
a1269 1
int SSL_SESSION_cmp(const SSL_SESSION *a,const SSL_SESSION *b)
a1294 8
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (meth->version < TLS1_VERSION))	
		{
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		return NULL;
		}
#endif

d1725 1
a1725 1
int SSL_get_error(const SSL *s,int i)
a1858 6
int ssl_undefined_const_function(const SSL *s)
	{
	SSLerr(SSL_F_SSL_UNDEFINED_CONST_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return(0);
	}

d1865 1
a1865 1
const char *SSL_get_version(const SSL *s)
d2034 1
a2034 1
X509 *SSL_get_certificate(const SSL *s)
d2051 1
a2051 1
SSL_CIPHER *SSL_get_current_cipher(const SSL *s)
d2115 1
a2115 1
int SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx)
d2125 1
a2125 1
int SSL_get_quiet_shutdown(const SSL *s)
d2135 1
a2135 1
int SSL_get_shutdown(const SSL *s)
d2140 1
a2140 1
int SSL_version(const SSL *s)
d2145 1
a2145 1
SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl)
d2159 1
a2159 3
	int r;
	r=X509_STORE_load_locations(ctx->cert_store,CAfile,CApath);
	return r;
d2169 1
a2169 1
void (*SSL_get_info_callback(const SSL *ssl))(const SSL *ssl,int type,int val)
d2174 1
a2174 1
int SSL_state(const SSL *ssl)
d2184 1
a2184 1
long SSL_get_verify_result(const SSL *ssl)
d2201 1
a2201 1
void *SSL_get_ex_data(const SSL *s,int idx)
d2218 1
a2218 1
void *SSL_CTX_get_ex_data(const SSL_CTX *s,int idx)
d2228 1
a2228 1
X509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *ctx)
d2240 1
a2240 1
int SSL_want(const SSL *s)
@


1.1.1.9
log
@import of openssl-0.9.7j
@
text
@d128 1
a128 1
SSL3_ENC_METHOD ssl3_undef_enc_method={
d1133 2
a1134 15
	/* ssl_create_cipher_list may return an empty stack if it
	 * was unable to find a cipher matching the given rule string
	 * (for example if the rule string specifies a cipher which
	 * has been disabled). This is not an error as far as 
	 * ssl_create_cipher_list is concerned, and hence 
	 * ctx->cipher_list and ctx->cipher_list_by_id has been
	 * updated. */
	if (sk == NULL)
		return 0;
	else if (sk_SSL_CIPHER_num(sk) == 0)
		{
		SSLerr(SSL_F_SSL_CTX_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);
		return 0;
		}
	return 1;
d1144 2
a1145 9
	/* see comment in SSL_CTX_set_cipher_list */
	if (sk == NULL)
		return 0;
	else if (sk_SSL_CIPHER_num(sk) == 0)
		{
		SSLerr(SSL_F_SSL_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);
		return 0;
		}
	return 1;
d1184 1
a1184 2
int ssl_cipher_list_to_bytes(SSL *s,STACK_OF(SSL_CIPHER) *sk,unsigned char *p,
                             int (*put_cb)(const SSL_CIPHER *, unsigned char *))
d1203 1
a1203 2

		j = put_cb ? put_cb(c,p) : ssl_put_cipher_by_char(s,c,p);
d1697 1
a1697 1
			SSL_CTX_flush_sessions(s->ctx,(unsigned long)time(NULL));
@


1.1.1.10
log
@import of OpenSSL 0.9.8h
@
text
@d113 1
a113 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
d124 1
a124 5
#include <openssl/rand.h>
#include <openssl/ocsp.h>
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
d135 1
a135 8
	(int (*)(SSL *, EVP_MD_CTX *, EVP_MD_CTX *, const char*, int, unsigned char *))ssl_undefined_function,
	0,	/* finish_mac_length */
	(int (*)(SSL *, EVP_MD_CTX *, unsigned char *))ssl_undefined_function,
	NULL,	/* client_finished_label */
	0,	/* client_finished_label_len */
	NULL,	/* server_finished_label */
	0,	/* server_finished_label_len */
	(int (*)(int))ssl_undefined_function
a274 1
#if 0
a275 1
#endif
a280 6

	s->param = X509_VERIFY_PARAM_new();
	if (!s->param)
		goto err;
	X509_VERIFY_PARAM_inherit(s->param, ctx->param);
#if 0
a282 1
#endif
d287 1
a287 13
#ifndef OPENSSL_NO_TLSEXT
	s->tlsext_debug_cb = 0;
	s->tlsext_debug_arg = NULL;
	s->tlsext_ticket_expected = 0;
	s->tlsext_status_type = -1;
	s->tlsext_status_expected = 0;
	s->tlsext_ocsp_ids = NULL;
	s->tlsext_ocsp_exts = NULL;
	s->tlsext_ocsp_resp = NULL;
	s->tlsext_ocsp_resplen = -1;
	CRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);
	s->initial_ctx=ctx;
#endif
d396 1
a396 1
	return X509_VERIFY_PARAM_set_purpose(s->param, purpose);
d401 1
a401 1
	return X509_VERIFY_PARAM_set_purpose(s->param, purpose);
d406 1
a406 1
	return X509_VERIFY_PARAM_set_trust(s->param, trust);
d411 1
a411 1
	return X509_VERIFY_PARAM_set_trust(s->param, trust);
a433 3
	if (s->param)
		X509_VERIFY_PARAM_free(s->param);

d470 1
a470 10
#ifndef OPENSSL_NO_TLSEXT
	if (s->initial_ctx) SSL_CTX_free(s->initial_ctx);
	if (s->tlsext_ocsp_exts)
		sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,
						X509_EXTENSION_free);
	if (s->tlsext_ocsp_ids)
		sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids, OCSP_RESPID_free);
	if (s->tlsext_ocsp_resp)
		OPENSSL_free(s->tlsext_ocsp_resp);
#endif
d646 1
a646 1
	return X509_VERIFY_PARAM_get_depth(s->param);
d661 1
a661 1
	return X509_VERIFY_PARAM_get_depth(ctx->param);
d679 1
a679 1
	X509_VERIFY_PARAM_set_depth(s->param, depth);
d853 1
a853 1
		SSLerr(SSL_F_SSL_PEEK, SSL_R_UNINITIALIZED);
a943 7
	case SSL_CTRL_SET_MTU:
		if (SSL_version(s) == DTLS1_VERSION)
			{
			s->d1->mtu = larg;
			return larg;
			}
		return 0;
d949 1
a949 1
long SSL_callback_ctrl(SSL *s, int cmd, void (*fp)(void))
d1037 1
a1037 1
long SSL_CTX_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)(void))
d1172 1
d1185 2
a1186 2
		int n;

d1188 1
a1188 2
		n=strlen(c->name);
		if (n+1 > len)
d1190 7
a1196 4
			if (p != buf)
				--p;
			*p='\0';
			return buf;
a1197 2
		strcpy(p,c->name);
		p+=n;
a1198 1
		len-=n+1;
a1274 23
#ifndef OPENSSL_NO_TLSEXT
/** return a servername extension value if provided in Client Hello, or NULL.
 * So far, only host_name types are defined (RFC 3546).
 */

const char *SSL_get_servername(const SSL *s, const int type)
	{
	if (type != TLSEXT_NAMETYPE_host_name)
		return NULL;

	return s->session && !s->tlsext_hostname ?
		s->session->tlsext_hostname :
		s->tlsext_hostname;
	}

int SSL_get_servername_type(const SSL *s)
	{
	if (s->session && (!s->tlsext_hostname ? s->session->tlsext_hostname : s->tlsext_hostname))
		return TLSEXT_NAMETYPE_host_name;
	return -1;
	}
#endif

d1318 8
a1373 1
#if 0
a1374 1
#endif
a1382 2
	ret->app_gen_cookie_cb=0;
	ret->app_verify_cookie_cb=0;
a1399 4
	ret->param = X509_VERIFY_PARAM_new();
	if (!ret->param)
		goto err;

a1423 14
#ifndef OPENSSL_NO_TLSEXT
	ret->tlsext_servername_callback = 0;
	ret->tlsext_servername_arg = NULL;
	/* Setup RFC4507 ticket keys */
	if ((RAND_pseudo_bytes(ret->tlsext_tick_key_name, 16) <= 0)
		|| (RAND_bytes(ret->tlsext_tick_hmac_key, 16) <= 0)
		|| (RAND_bytes(ret->tlsext_tick_aes_key, 16) <= 0))
		ret->options |= SSL_OP_NO_TICKET;

	ret->tlsext_status_cb = 0;
	ret->tlsext_status_arg = NULL;

#endif

a1455 3
	if (a->param)
		X509_VERIFY_PARAM_free(a->param);

d1518 1
a1518 1
	X509_VERIFY_PARAM_set_depth(ctx->param, depth);
a1527 7
	int have_ecc_cert, ecdh_ok, ecdsa_ok, ecc_pkey_size;
#ifndef OPENSSL_NO_ECDH
	int have_ecdh_tmp;
#endif
	X509 *x = NULL;
	EVP_PKEY *ecc_pkey = NULL;
	int signature_nid = 0;
a1547 3
#ifndef OPENSSL_NO_ECDH
	have_ecdh_tmp=(c->ecdh_tmp != NULL || c->ecdh_tmp_cb != NULL);
#endif
d1562 1
a1562 2
	cpk= &(c->pkeys[SSL_PKEY_ECC]);
	have_ecc_cert= (cpk->x509 != NULL && cpk->privatekey != NULL);
a1618 53
	/* An ECC certificate may be usable for ECDH and/or
	 * ECDSA cipher suites depending on the key usage extension.
	 */
	if (have_ecc_cert)
		{
                /* This call populates extension flags (ex_flags) */
		x = (c->pkeys[SSL_PKEY_ECC]).x509;
		X509_check_purpose(x, -1, 0);
		ecdh_ok = (x->ex_flags & EXFLAG_KUSAGE) ?
		    (x->ex_kusage & X509v3_KU_KEY_AGREEMENT) : 1;
		ecdsa_ok = (x->ex_flags & EXFLAG_KUSAGE) ?
		    (x->ex_kusage & X509v3_KU_DIGITAL_SIGNATURE) : 1;
		ecc_pkey = X509_get_pubkey(x);
		ecc_pkey_size = (ecc_pkey != NULL) ? 
		    EVP_PKEY_bits(ecc_pkey) : 0;
		EVP_PKEY_free(ecc_pkey);
		if ((x->sig_alg) && (x->sig_alg->algorithm))
			signature_nid = OBJ_obj2nid(x->sig_alg->algorithm);
#ifndef OPENSSL_NO_ECDH
		if (ecdh_ok)
			{
			if ((signature_nid == NID_md5WithRSAEncryption) ||
			    (signature_nid == NID_md4WithRSAEncryption) ||
			    (signature_nid == NID_md2WithRSAEncryption))
				{
				mask|=SSL_kECDH|SSL_aRSA;
				if (ecc_pkey_size <= 163)
					emask|=SSL_kECDH|SSL_aRSA;
				}
			if (signature_nid == NID_ecdsa_with_SHA1)
				{
				mask|=SSL_kECDH|SSL_aECDSA;
				if (ecc_pkey_size <= 163)
					emask|=SSL_kECDH|SSL_aECDSA;
				}
			}
#endif
#ifndef OPENSSL_NO_ECDSA
		if (ecdsa_ok)
			{
			mask|=SSL_aECDSA;
			emask|=SSL_aECDSA;
			}
#endif
		}

#ifndef OPENSSL_NO_ECDH
	if (have_ecdh_tmp)
		{
		mask|=SSL_kECDHE;
		emask|=SSL_kECDHE;
		}
#endif
a1623 63
/* This handy macro borrowed from crypto/x509v3/v3_purp.c */
#define ku_reject(x, usage) \
	(((x)->ex_flags & EXFLAG_KUSAGE) && !((x)->ex_kusage & (usage)))

int check_srvr_ecc_cert_and_alg(X509 *x, SSL_CIPHER *cs)
	{
	unsigned long alg = cs->algorithms;
	EVP_PKEY *pkey = NULL;
	int keysize = 0;
	int signature_nid = 0;

	if (SSL_C_IS_EXPORT(cs))
		{
		/* ECDH key length in export ciphers must be <= 163 bits */
		pkey = X509_get_pubkey(x);
		if (pkey == NULL) return 0;
		keysize = EVP_PKEY_bits(pkey);
		EVP_PKEY_free(pkey);
		if (keysize > 163) return 0;
		}

	/* This call populates the ex_flags field correctly */
	X509_check_purpose(x, -1, 0);
	if ((x->sig_alg) && (x->sig_alg->algorithm))
		signature_nid = OBJ_obj2nid(x->sig_alg->algorithm);
	if (alg & SSL_kECDH) 
		{
		/* key usage, if present, must allow key agreement */
		if (ku_reject(x, X509v3_KU_KEY_AGREEMENT))
			{
			return 0;
			}
		if (alg & SSL_aECDSA) 
			{
			/* signature alg must be ECDSA */
			if (signature_nid != NID_ecdsa_with_SHA1)
				{
				return 0;
				}
			}
		if (alg & SSL_aRSA)
			{
			/* signature alg must be RSA */
			if ((signature_nid != NID_md5WithRSAEncryption) &&
			    (signature_nid != NID_md4WithRSAEncryption) &&
			    (signature_nid != NID_md2WithRSAEncryption))
				{
				return 0;
				}
			}
		} 
	else if (alg & SSL_aECDSA)
		{
		/* key usage, if present, must allow signing */
		if (ku_reject(x, X509v3_KU_DIGITAL_SIGNATURE))
			{
			return 0;
			}
		}

	return 1;  /* all checks are ok */
	}

d1638 1
a1638 20
	if (kalg & SSL_kECDH)
		{
		/* we don't need to look at SSL_kECDHE 
		 * since no certificate is needed for
		 * anon ECDH and for authenticated
		 * ECDHE, the check for the auth 
		 * algorithm will set i correctly
		 * NOTE: For ECDH-RSA, we need an ECC
		 * not an RSA cert but for ECDHE-RSA
		 * we need an RSA cert. Placing the
		 * checks for SSL_kECDH before RSA
		 * checks ensures the correct cert is chosen.
		 */
		i=SSL_PKEY_ECC;
		}
	else if (kalg & SSL_aECDSA)
		{
		i=SSL_PKEY_ECC;
		}
	else if (kalg & SSL_kDHr)
a1661 1

a1684 3
	else if ((alg & SSL_aECDSA) &&
	         (c->pkeys[SSL_PKEY_ECC].privatekey != NULL))
		return(c->pkeys[SSL_PKEY_ECC].privatekey);
a1889 6
int ssl_undefined_void_function(void)
	{
	SSLerr(SSL_F_SSL_UNDEFINED_VOID_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return(0);
	}

d2005 2
a2006 2

	X509_VERIFY_PARAM_inherit(ret->param, s->param);
a2057 1
#ifndef OPENSSL_NO_COMP
a2067 1
#endif
a2093 25
#ifdef OPENSSL_NO_COMP
const void *SSL_get_current_compression(SSL *s)
	{
	return NULL;
	}
const void *SSL_get_current_expansion(SSL *s)
	{
	return NULL;
	}
#else

const COMP_METHOD *SSL_get_current_compression(SSL *s)
	{
	if (s->compress != NULL)
		return(s->compress->meth);
	return(NULL);
	}

const COMP_METHOD *SSL_get_current_expansion(SSL *s)
	{
	if (s->expand != NULL)
		return(s->expand->meth);
	return(NULL);
	}
#endif
a2186 18
SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX* ctx)
	{
	if (ssl->ctx == ctx)
		return ssl->ctx;
#ifndef OPENSSL_NO_TLSEXT
	if (ctx == NULL)
		ctx = ssl->initial_ctx;
#endif
	if (ssl->cert != NULL)
		ssl_cert_free(ssl->cert);
	ssl->cert = ssl_cert_dup(ctx->cert);
	CRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);
	if (ssl->ctx != NULL)
		SSL_CTX_free(ssl->ctx); /* decrement reference count */
	ssl->ctx = ctx;
	return(ssl->ctx);
	}

d2196 3
a2198 1
	return(X509_STORE_load_locations(ctx->cert_store,CAfile,CApath));
d2203 1
a2203 1
	void (*cb)(const SSL *ssl,int type,int val))
d2208 1
a2208 3
/* One compiler (Diab DCC) doesn't like argument names in returned
   function pointer.  */
void (*SSL_get_info_callback(const SSL *ssl))(const SSL * /*ssl*/,int /*type*/,int /*val*/) 
d2295 1
a2295 1
    SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_RSA_CB,(void (*)(void))cb);
d2302 1
a2302 1
    SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_RSA_CB,(void (*)(void))cb);
d2331 1
a2331 1
	SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_DH_CB,(void (*)(void))dh);
d2337 1
a2337 15
	SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_DH_CB,(void (*)(void))dh);
	}
#endif

#ifndef OPENSSL_NO_ECDH
void SSL_CTX_set_tmp_ecdh_callback(SSL_CTX *ctx,EC_KEY *(*ecdh)(SSL *ssl,int is_export,
							int keylength))
	{
	SSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_ECDH_CB,(void (*)(void))ecdh);
	}

void SSL_set_tmp_ecdh_callback(SSL *ssl,EC_KEY *(*ecdh)(SSL *ssl,int is_export,
						int keylength))
	{
	SSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_ECDH_CB,(void (*)(void))ecdh);
d2344 1
a2344 1
	SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK, (void (*)(void))cb);
d2348 1
a2348 1
	SSL_callback_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK, (void (*)(void))cb);
@


1.1.1.11
log
@import openssl-0.9.8j
@
text
@a132 3
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif
a1395 8
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (meth->version < TLS1_VERSION))	
		{
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		return NULL;
		}
#endif

a1515 21
#ifndef OPENSSL_NO_ENGINE
	ret->client_cert_engine = NULL;
#ifdef OPENSSL_SSL_CLIENT_ENGINE_AUTO
#define eng_strx(x)	#x
#define eng_str(x)	eng_strx(x)
	/* Use specific client engine automatically... ignore errors */
	{
	ENGINE *eng;
	eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));
	if (!eng)
		{
		ERR_clear_error();
		ENGINE_load_builtin_engines();
		eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));
		}
	if (!eng || !SSL_CTX_set_client_cert_engine(ret, eng))
		ERR_clear_error();
	}
#endif
#endif

a1584 4
#endif
#ifndef OPENSSL_NO_ENGINE
	if (a->client_cert_engine)
		ENGINE_finish(a->client_cert_engine);
@


1.1.1.12
log
@import of OpenSSL 0.9.8k
@
text
@a512 2
	if (s->tlsext_hostname)
		OPENSSL_free(s->tlsext_hostname);
@


1.1.1.13
log
@import OpenSSL-1.0.0a
@
text
@d61 1
a61 1
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
a117 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
d146 1
a146 1
	(int (*)(SSL *,  const char*, int, unsigned char *))ssl_undefined_function,
d148 1
a148 1
	(int (*)(SSL *, int, unsigned char *))ssl_undefined_function,
a206 2
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->write_hash);
d227 1
a227 1
int SSL_CTX_set_ssl_version(SSL_CTX *ctx,const SSL_METHOD *meth)
d234 1
a234 2
		&(ctx->cipher_list_by_id),
		meth->version == SSL2_VERSION ? "SSLv2" : SSL_DEFAULT_CIPHER_LIST);
a310 1
	s->max_send_fragment = ctx->max_send_fragment;
a326 1

a340 5
#ifndef OPENSSL_NO_PSK
	s->psk_client_callback=ctx->psk_client_callback;
	s->psk_server_callback=ctx->psk_server_callback;
#endif

d428 1
a428 1
	p = lh_SSL_SESSION_retrieve(ssl->ctx->sessions, &r);
a452 10
int SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm)
	{
	return X509_VERIFY_PARAM_set1(ctx->param, vpm);
	}

int SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm)
	{
	return X509_VERIFY_PARAM_set1(ssl->param, vpm);
	}

a506 2
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->write_hash);
d511 1
a515 5
#ifndef OPENSSL_NO_EC
	if (s->tlsext_ecpointformatlist) OPENSSL_free(s->tlsext_ecpointformatlist);
	if (s->tlsext_ellipticcurvelist) OPENSSL_free(s->tlsext_ellipticcurvelist);
#endif /* OPENSSL_NO_EC */
	if (s->tlsext_opaque_prf_input) OPENSSL_free(s->tlsext_opaque_prf_input);
a523 1

a528 2
	if (s->ctx) SSL_CTX_free(s->ctx);

d846 1
a846 1
		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);
a988 2
	case SSL_CTRL_CLEAR_OPTIONS:
		return(s->options&=~larg);
a990 2
	case SSL_CTRL_CLEAR_MODE:
		return(s->mode &=~larg);
d998 1
a998 2
		if (SSL_version(s) == DTLS1_VERSION ||
		    SSL_version(s) == DTLS1_BAD_VER)
a1003 9
	case SSL_CTRL_SET_MAX_SEND_FRAGMENT:
		if (larg < 512 || larg > SSL3_RT_MAX_PLAIN_LENGTH)
			return 0;
		s->max_send_fragment = larg;
		return 1;
	case SSL_CTRL_GET_RI_SUPPORT:
		if (s->s3)
			return s->s3->send_connection_binding;
		else return 0;
d1022 1
a1022 1
LHASH_OF(SSL_SESSION) *SSL_CTX_sessions(SSL_CTX *ctx)
d1065 1
a1065 1
		return(lh_SSL_SESSION_num_items(ctx->sessions));
a1089 2
	case SSL_CTRL_CLEAR_OPTIONS:
		return(ctx->options&=~larg);
a1091 7
	case SSL_CTRL_CLEAR_MODE:
		return(ctx->mode&=~larg);
	case SSL_CTRL_SET_MAX_SEND_FRAGMENT:
		if (larg < 512 || larg > SSL3_RT_MAX_PLAIN_LENGTH)
			return 0;
		ctx->max_send_fragment = larg;
		return 1;
d1196 2
a1197 2
	 * has been disabled). This is not an error as far as
	 * ssl_create_cipher_list is concerned, and hence
d1265 1
a1265 1
			     int (*put_cb)(const SSL_CIPHER *, unsigned char *))
d1271 1
a1271 1
	int nokrb5 = !kssl_tgt_is_available(s->kssl_ctx);
d1281 4
a1284 10
		if (((c->algorithm_mkey & SSL_kKRB5) || (c->algorithm_auth & SSL_aKRB5)) &&
		    nokrb5)
		    continue;
#endif /* OPENSSL_NO_KRB5 */
#ifndef OPENSSL_NO_PSK
		/* with PSK there must be client callback set */
		if (((c->algorithm_mkey & SSL_kPSK) || (c->algorithm_auth & SSL_aPSK)) &&
		    s->psk_client_callback == NULL)
			continue;
#endif /* OPENSSL_NO_PSK */
a1287 16
	/* If p == q, no ciphers and caller indicates an error. Otherwise
	 * add SCSV if not renegotiating.
	 */
	if (p != q && !s->new_session)
		{
		static SSL_CIPHER scsv =
			{
			0, NULL, SSL3_CK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0
			};
		j = put_cb ? put_cb(&scsv,p) : ssl_put_cipher_by_char(s,&scsv,p);
		p+=j;
#ifdef OPENSSL_RI_DEBUG
		fprintf(stderr, "SCSV sent by client\n");
#endif
		}

d1294 1
a1294 1
	const SSL_CIPHER *c;
a1296 2
	if (s->s3)
		s->s3->send_connection_binding = 0;
a1313 20
		/* Check for SCSV */
		if (s->s3 && (n != 3 || !p[0]) &&
			(p[n-2] == ((SSL3_CK_SCSV >> 8) & 0xff)) &&
			(p[n-1] == (SSL3_CK_SCSV & 0xff)))
			{
			/* SCSV fatal if renegotiating */
			if (s->new_session)
				{
				SSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE); 
				goto err;
				}
			s->s3->send_connection_binding = 1;
			p += n;
#ifdef OPENSSL_RI_DEBUG
			fprintf(stderr, "SCSV received by server\n");
#endif
			continue;
			}

a1334 1

d1358 1
a1358 1
static unsigned long ssl_session_hash(const SSL_SESSION *a)
d1375 1
a1375 1
static int ssl_session_cmp(const SSL_SESSION *a,const SSL_SESSION *b)
d1388 2
a1389 2
static IMPLEMENT_LHASH_HASH_FN(ssl_session, SSL_SESSION)
static IMPLEMENT_LHASH_COMP_FN(ssl_session, SSL_SESSION)
d1391 1
a1391 1
SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth)
d1394 1
a1394 1

d1401 8
d1471 2
a1472 1
	ret->sessions=lh_SSL_SESSION_new();
d1479 1
a1479 1
		meth->version == SSL2_VERSION ? "SSLv2" : SSL_DEFAULT_CIPHER_LIST);
a1514 2
	ret->max_send_fragment = SSL3_RT_MAX_PLAIN_LENGTH;

d1528 1
a1528 23
#ifndef OPENSSL_NO_PSK
	ret->psk_identity_hint=NULL;
	ret->psk_client_callback=NULL;
	ret->psk_server_callback=NULL;
#endif
#ifndef OPENSSL_NO_BUF_FREELISTS
	ret->freelist_max_len = SSL_MAX_BUF_FREELIST_LEN_DEFAULT;
	ret->rbuf_freelist = OPENSSL_malloc(sizeof(SSL3_BUF_FREELIST));
	if (!ret->rbuf_freelist)
		goto err;
	ret->rbuf_freelist->chunklen = 0;
	ret->rbuf_freelist->len = 0;
	ret->rbuf_freelist->head = NULL;
	ret->wbuf_freelist = OPENSSL_malloc(sizeof(SSL3_BUF_FREELIST));
	if (!ret->wbuf_freelist)
		{
		OPENSSL_free(ret->rbuf_freelist);
		goto err;
		}
	ret->wbuf_freelist->chunklen = 0;
	ret->wbuf_freelist->len = 0;
	ret->wbuf_freelist->head = NULL;
#endif
a1548 4
	/* Default is to connect to non-RI servers. When RI is more widely
	 * deployed might change this.
	 */
	ret->options |= SSL_OP_LEGACY_SERVER_CONNECT;
a1562 14
#ifndef OPENSSL_NO_BUF_FREELISTS
static void
ssl_buf_freelist_free(SSL3_BUF_FREELIST *list)
	{
	SSL3_BUF_FREELIST_ENTRY *ent, *next;
	for (ent = list->head; ent; ent = next)
		{
		next = ent->next;
		OPENSSL_free(ent);
		}
	OPENSSL_free(list);
	}
#endif

d1600 1
a1600 1
		lh_SSL_SESSION_free(a->sessions);
a1619 5

#ifndef OPENSSL_NO_PSK
	if (a->psk_identity_hint)
		OPENSSL_free(a->psk_identity_hint);
#endif
a1623 8

#ifndef OPENSSL_NO_BUF_FREELISTS
	if (a->wbuf_freelist)
		ssl_buf_freelist_free(a->wbuf_freelist);
	if (a->rbuf_freelist)
		ssl_buf_freelist_free(a->rbuf_freelist);
#endif

d1654 1
a1654 1
void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)
d1660 1
a1660 1
	unsigned long mask_k,mask_a,emask_k,emask_a;
d1707 2
a1708 6
	mask_k=0;
	mask_a=0;
	emask_k=0;
	emask_a=0;

	
d1711 2
a1712 2
	printf("rt=%d rte=%d dht=%d ecdht=%d re=%d ree=%d rs=%d ds=%d dhr=%d dhd=%d\n",
	        rsa_tmp,rsa_tmp_export,dh_tmp,have_ecdh_tmp,
a1714 11
	
	cpk = &(c->pkeys[SSL_PKEY_GOST01]);
	if (cpk->x509 != NULL && cpk->privatekey !=NULL) {
		mask_k |= SSL_kGOST;
		mask_a |= SSL_aGOST01;
	}
	cpk = &(c->pkeys[SSL_PKEY_GOST94]);
	if (cpk->x509 != NULL && cpk->privatekey !=NULL) {
		mask_k |= SSL_kGOST;
		mask_a |= SSL_aGOST94;
	}
d1717 1
a1717 1
		mask_k|=SSL_kRSA;
d1719 1
a1719 1
		emask_k|=SSL_kRSA;
d1723 1
a1723 1
	if (	(dh_tmp || dh_rsa || dh_dsa) &&
d1725 1
a1725 1
		mask_k|=SSL_kEDH;
d1728 1
a1728 1
		emask_k|=SSL_kEDH;
d1731 2
a1732 2
	if (dh_tmp_export)
		emask_k|=SSL_kEDH;
d1735 1
a1735 1
		mask_k|=SSL_kEDH;
d1737 2
a1738 2
	if (dh_rsa) mask_k|=SSL_kDHr;
	if (dh_rsa_export) emask_k|=SSL_kDHr;
d1740 2
a1741 2
	if (dh_dsa) mask_k|=SSL_kDHd;
	if (dh_dsa_export) emask_k|=SSL_kDHd;
d1745 2
a1746 2
		mask_a|=SSL_aRSA;
		emask_a|=SSL_aRSA;
d1751 2
a1752 2
		mask_a|=SSL_aDSS;
		emask_a|=SSL_aDSS;
d1755 2
a1756 2
	mask_a|=SSL_aNULL;
	emask_a|=SSL_aNULL;
d1759 2
a1760 4
	mask_k|=SSL_kKRB5;
	mask_a|=SSL_aKRB5;
	emask_k|=SSL_kKRB5;
	emask_a|=SSL_aKRB5;
d1768 1
a1768 1
		/* This call populates extension flags (ex_flags) */
d1776 1
a1776 1
		ecc_pkey_size = (ecc_pkey != NULL) ?
d1784 3
a1786 2
			const char *sig = OBJ_nid2ln(signature_nid);
			if (sig == NULL)
d1788 1
a1788 8
				ERR_clear_error();
				sig = "unknown";
				}
				
			if (strstr(sig, "WithRSA"))
				{
				mask_k|=SSL_kECDHr;
				mask_a|=SSL_aECDH;
d1790 1
a1790 4
					{
					emask_k|=SSL_kECDHr;
					emask_a|=SSL_aECDH;
					}
a1791 1

d1794 1
a1794 2
				mask_k|=SSL_kECDHe;
				mask_a|=SSL_aECDH;
d1796 1
a1796 4
					{
					emask_k|=SSL_kECDHe;
					emask_a|=SSL_aECDH;
					}
d1803 2
a1804 2
			mask_a|=SSL_aECDSA;
			emask_a|=SSL_aECDSA;
d1812 2
a1813 2
		mask_k|=SSL_kEECDH;
		emask_k|=SSL_kEECDH;
d1816 2
a1817 12

#ifndef OPENSSL_NO_PSK
	mask_k |= SSL_kPSK;
	mask_a |= SSL_aPSK;
	emask_k |= SSL_kPSK;
	emask_a |= SSL_aPSK;
#endif

	c->mask_k=mask_k;
	c->mask_a=mask_a;
	c->export_mask_k=emask_k;
	c->export_mask_a=emask_a;
d1825 1
a1825 3
#ifndef OPENSSL_NO_EC

int ssl_check_srvr_ecc_cert_and_alg(X509 *x, const SSL_CIPHER *cs)
d1827 1
a1827 1
	unsigned long alg_k, alg_a;
a1831 3
	alg_k = cs->algorithm_mkey;
	alg_a = cs->algorithm_auth;

d1846 1
a1846 1
	if (alg_k & SSL_kECDHe || alg_k & SSL_kECDHr)
a1850 1
			SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_NOT_FOR_KEY_AGREEMENT);
d1853 1
a1853 1
		if (alg_k & SSL_kECDHe)
a1857 1
				SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_SHOULD_HAVE_SHA1_SIGNATURE);
d1861 1
a1861 1
		if (alg_k & SSL_kECDHr)
d1864 3
a1866 3

			const char *sig = OBJ_nid2ln(signature_nid);
			if (sig == NULL)
a1867 6
				ERR_clear_error();
				sig = "unknown";
				}
			if (strstr(sig, "WithRSA") == NULL)
				{
				SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_SHOULD_HAVE_RSA_SIGNATURE);
d1871 2
a1872 2
		}
	if (alg_a & SSL_aECDSA)
a1876 1
			SSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG, SSL_R_ECC_CERT_NOT_FOR_SIGNING);
a1883 2
#endif

d1887 1
a1887 1
	unsigned long alg_k,alg_a,mask_k,mask_a;
d1893 1
d1895 2
a1896 13
	if (is_export)
		{
		mask_k = c->export_mask_k;
		mask_a = c->export_mask_a;
		}
	else
		{
		mask_k = c->mask_k;
		mask_a = c->mask_a;
		}
	
	alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
	alg_a = s->s3->tmp.new_cipher->algorithm_auth;
d1898 1
a1898 1
	if (alg_k & (SSL_kECDHr|SSL_kECDHe))
d1900 1
a1900 1
		/* we don't need to look at SSL_kEECDH
d1903 1
a1903 1
		 * EECDH, the check for the auth
d1906 1
a1906 1
		 * not an RSA cert but for EECDH-RSA
d1913 1
a1913 1
	else if (alg_a & SSL_aECDSA)
d1917 1
a1917 1
	else if (alg_k & SSL_kDHr)
d1919 1
a1919 1
	else if (alg_k & SSL_kDHd)
d1921 1
a1921 1
	else if (alg_a & SSL_aDSS)
d1923 1
a1923 1
	else if (alg_a & SSL_aRSA)
d1930 1
a1930 1
	else if (alg_a & SSL_aKRB5)
d1935 1
a1935 5
	else if (alg_a & SSL_aGOST94) 
		i=SSL_PKEY_GOST94;
	else if (alg_a & SSL_aGOST01)
		i=SSL_PKEY_GOST01;
	else /* if (alg_a & SSL_aNULL) */
d1945 1
a1945 1
EVP_PKEY *ssl_get_sign_pkey(SSL *s,const SSL_CIPHER *cipher)
d1947 1
a1947 1
	unsigned long alg_a;
d1950 1
a1950 1
	alg_a = cipher->algorithm_auth;
d1953 1
a1953 1
	if ((alg_a & SSL_aDSS) &&
d1956 1
a1956 1
	else if (alg_a & SSL_aRSA)
d1965 1
a1965 1
	else if ((alg_a & SSL_aECDSA) &&
d1968 1
a1968 1
	else /* if (alg_a & SSL_aNULL) */
d1983 1
a1983 1
	i=s->session_ctx->session_cache_mode;
d1986 2
a1987 2
		    || SSL_CTX_add_session(s->session_ctx,s->session))
		&& (s->session_ctx->new_session_cb != NULL))
d1990 1
a1990 1
		if (!s->session_ctx->new_session_cb(s,s->session))
d1999 2
a2000 2
			?s->session_ctx->stats.sess_connect_good
			:s->session_ctx->stats.sess_accept_good) & 0xff) == 0xff)
d2002 1
a2002 1
			SSL_CTX_flush_sessions(s->session_ctx,(unsigned long)time(NULL));
d2007 1
a2007 1
const SSL_METHOD *SSL_get_ssl_method(SSL *s)
d2012 1
a2012 1
int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
a2154 2
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->write_hash);
a2164 2
	ssl_clear_hash_ctx(&s->read_hash);
	ssl_clear_hash_ctx(&s->write_hash);
d2209 1
a2209 1
	
d2379 1
a2379 1
const SSL_CIPHER *SSL_get_current_cipher(const SSL *s)
d2457 1
a2457 1
#endif
d2542 1
a2542 1
void (*SSL_get_info_callback(const SSL *ssl))(const SSL * /*ssl*/,int /*type*/,int /*val*/)
d2663 1
a2663 1
                                                        int keylength))
d2669 1
a2669 1
                                                int keylength))
d2677 1
a2677 1
                                                                int keylength))
d2683 1
a2683 1
                                                        int keylength))
a2688 91
#ifndef OPENSSL_NO_PSK
int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *identity_hint)
	{
	if (identity_hint != NULL && strlen(identity_hint) > PSK_MAX_IDENTITY_LEN)
		{
		SSLerr(SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT, SSL_R_DATA_LENGTH_TOO_LONG);
		return 0;
		}
	if (ctx->psk_identity_hint != NULL)
		OPENSSL_free(ctx->psk_identity_hint);
	if (identity_hint != NULL)
		{
		ctx->psk_identity_hint = BUF_strdup(identity_hint);
		if (ctx->psk_identity_hint == NULL)
			return 0;
		}
	else
		ctx->psk_identity_hint = NULL;
	return 1;
	}

int SSL_use_psk_identity_hint(SSL *s, const char *identity_hint)
	{
	if (s == NULL)
		return 0;

	if (s->session == NULL)
		return 1; /* session not created yet, ignored */

	if (identity_hint != NULL && strlen(identity_hint) > PSK_MAX_IDENTITY_LEN)
		{
		SSLerr(SSL_F_SSL_USE_PSK_IDENTITY_HINT, SSL_R_DATA_LENGTH_TOO_LONG);
		return 0;
		}
	if (s->session->psk_identity_hint != NULL)
		OPENSSL_free(s->session->psk_identity_hint);
	if (identity_hint != NULL)
		{
		s->session->psk_identity_hint = BUF_strdup(identity_hint);
		if (s->session->psk_identity_hint == NULL)
			return 0;
		}
	else
		s->session->psk_identity_hint = NULL;
	return 1;
	}

const char *SSL_get_psk_identity_hint(const SSL *s)
	{
	if (s == NULL || s->session == NULL)
		return NULL;
	return(s->session->psk_identity_hint);
	}

const char *SSL_get_psk_identity(const SSL *s)
	{
	if (s == NULL || s->session == NULL)
		return NULL;
	return(s->session->psk_identity);
	}

void SSL_set_psk_client_callback(SSL *s,
    unsigned int (*cb)(SSL *ssl, const char *hint,
                       char *identity, unsigned int max_identity_len, unsigned char *psk,
                       unsigned int max_psk_len))
	{
	s->psk_client_callback = cb;
	}

void SSL_CTX_set_psk_client_callback(SSL_CTX *ctx,
    unsigned int (*cb)(SSL *ssl, const char *hint,
                       char *identity, unsigned int max_identity_len, unsigned char *psk,
                       unsigned int max_psk_len))
	{
	ctx->psk_client_callback = cb;
	}

void SSL_set_psk_server_callback(SSL *s,
    unsigned int (*cb)(SSL *ssl, const char *identity,
                       unsigned char *psk, unsigned int max_psk_len))
	{
	s->psk_server_callback = cb;
	}

void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx,
    unsigned int (*cb)(SSL *ssl, const char *identity,
                       unsigned char *psk, unsigned int max_psk_len))
	{
	ctx->psk_server_callback = cb;
	}
#endif
a2698 5
/* Allocates new EVP_MD_CTX and sets pointer to it into given pointer
 * vairable, freeing  EVP_MD_CTX previously stored in that variable, if
 * any. If EVP_MD pointer is passed, initializes ctx with this md
 * Returns newly allocated ctx;
 */
a2699 13
EVP_MD_CTX *ssl_replace_hash(EVP_MD_CTX **hash,const EVP_MD *md) 
{
	ssl_clear_hash_ctx(hash);
	*hash = EVP_MD_CTX_create();
	if (md) EVP_DigestInit_ex(*hash,md,NULL);
	return *hash;
}
void ssl_clear_hash_ctx(EVP_MD_CTX **hash) 
{

	if (*hash) EVP_MD_CTX_destroy(*hash);
	*hash=NULL;
}
a2706 3
IMPLEMENT_OBJ_BSEARCH_GLOBAL_CMP_FN(SSL_CIPHER, SSL_CIPHER,
				    ssl_cipher_id);

@


1.1.1.14
log
@import OpenSSL 1.0.0e
@
text
@d1836 1
a1836 1
	int signature_nid = 0, pk_nid = 0, md_nid = 0;
a1965 1
			{
a1966 2
			OBJ_find_sigid_algs(signature_nid, &md_nid, &pk_nid);
			}
d1970 8
a1977 2

			if (pk_nid == NID_rsaEncryption || pk_nid == NID_rsa)
d1988 1
a1988 1
			if (pk_nid == NID_X9_62_id_ecPublicKey)
d2042 1
a2042 1
	int signature_nid = 0, md_nid = 0, pk_nid = 0;
a2059 1
		{
a2060 2
		OBJ_find_sigid_algs(signature_nid, &md_nid, &pk_nid);
		}
d2072 1
a2072 1
			if (pk_nid != NID_X9_62_id_ecPublicKey)
d2082 7
a2088 1
			if (pk_nid != NID_rsaEncryption && pk_nid != NID_rsa)
d2113 1
a2113 1
	unsigned long alg_k,alg_a;
d2115 1
a2115 1
	int i;
d2119 11
@


1.1.1.15
log
@OpenSSL 1.0.0f: import upstream source
@
text
@a1056 3
		if (larg < (long)dtls1_min_mtu())
			return 0;

@


1.1.1.16
log
@import OpenSSL-1.0.1c
@
text
@d179 1
a179 4
	(int (*)(int))ssl_undefined_function,
	(int (*)(SSL *, unsigned char *, size_t, const char *,
		 size_t, const unsigned char *, size_t,
		 int use_context)) ssl_undefined_function,
d205 1
a205 1
	if (s->renegotiate) return(1);
d207 1
a207 1
	if (s->renegotiate)
a355 3
# ifndef OPENSSL_NO_NEXTPROTONEG
	s->next_proto_negotiated = NULL;
# endif
a588 8
#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
	if (s->next_proto_negotiated)
		OPENSSL_free(s->next_proto_negotiated);
#endif

        if (s->srtp_profiles)
            sk_SRTP_PROTECTION_PROFILE_free(s->srtp_profiles);

d1011 4
a1014 15
	if (s->renegotiate == 0)
		s->renegotiate=1;

	s->new_session=1;

	return(s->method->ssl_renegotiate(s));
	}

int SSL_renegotiate_abbreviated(SSL *s)
	{
	if (s->renegotiate == 0)
		s->renegotiate=1;

	s->new_session=0;

d1022 1
a1022 1
	return (s->renegotiate != 0);
a1056 1
#ifndef OPENSSL_NO_DTLS1
a1058 1
#endif
a1360 4
		/* Skip TLS v1.2 only ciphersuites if lower than v1.2 */
		if ((c->algorithm_ssl & SSL_TLSV1_2) && 
			(TLS1_get_client_version(s) < TLS1_2_VERSION))
			continue;
d1378 1
a1378 1
	if (p != q && !s->renegotiate)
d1425 1
a1425 1
			if (s->renegotiate)
a1481 117

# ifndef OPENSSL_NO_NEXTPROTONEG
/* SSL_select_next_proto implements the standard protocol selection. It is
 * expected that this function is called from the callback set by
 * SSL_CTX_set_next_proto_select_cb.
 *
 * The protocol data is assumed to be a vector of 8-bit, length prefixed byte
 * strings. The length byte itself is not included in the length. A byte
 * string of length 0 is invalid. No byte string may be truncated.
 *
 * The current, but experimental algorithm for selecting the protocol is:
 *
 * 1) If the server doesn't support NPN then this is indicated to the
 * callback. In this case, the client application has to abort the connection
 * or have a default application level protocol.
 *
 * 2) If the server supports NPN, but advertises an empty list then the
 * client selects the first protcol in its list, but indicates via the
 * API that this fallback case was enacted.
 *
 * 3) Otherwise, the client finds the first protocol in the server's list
 * that it supports and selects this protocol. This is because it's
 * assumed that the server has better information about which protocol
 * a client should use.
 *
 * 4) If the client doesn't support any of the server's advertised
 * protocols, then this is treated the same as case 2.
 *
 * It returns either
 * OPENSSL_NPN_NEGOTIATED if a common protocol was found, or
 * OPENSSL_NPN_NO_OVERLAP if the fallback case was reached.
 */
int SSL_select_next_proto(unsigned char **out, unsigned char *outlen, const unsigned char *server, unsigned int server_len, const unsigned char *client, unsigned int client_len)
	{
	unsigned int i, j;
	const unsigned char *result;
	int status = OPENSSL_NPN_UNSUPPORTED;

	/* For each protocol in server preference order, see if we support it. */
	for (i = 0; i < server_len; )
		{
		for (j = 0; j < client_len; )
			{
			if (server[i] == client[j] &&
			    memcmp(&server[i+1], &client[j+1], server[i]) == 0)
				{
				/* We found a match */
				result = &server[i];
				status = OPENSSL_NPN_NEGOTIATED;
				goto found;
				}
			j += client[j];
			j++;
			}
		i += server[i];
		i++;
		}

	/* There's no overlap between our protocols and the server's list. */
	result = client;
	status = OPENSSL_NPN_NO_OVERLAP;

	found:
	*out = (unsigned char *) result + 1;
	*outlen = result[0];
	return status;
	}

/* SSL_get0_next_proto_negotiated sets *data and *len to point to the client's
 * requested protocol for this connection and returns 0. If the client didn't
 * request any protocol, then *data is set to NULL.
 *
 * Note that the client can request any protocol it chooses. The value returned
 * from this function need not be a member of the list of supported protocols
 * provided by the callback.
 */
void SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data, unsigned *len)
	{
	*data = s->next_proto_negotiated;
	if (!*data) {
		*len = 0;
	} else {
		*len = s->next_proto_negotiated_len;
	}
}

/* SSL_CTX_set_next_protos_advertised_cb sets a callback that is called when a
 * TLS server needs a list of supported protocols for Next Protocol
 * Negotiation. The returned list must be in wire format.  The list is returned
 * by setting |out| to point to it and |outlen| to its length. This memory will
 * not be modified, but one should assume that the SSL* keeps a reference to
 * it.
 *
 * The callback should return SSL_TLSEXT_ERR_OK if it wishes to advertise. Otherwise, no
 * such extension will be included in the ServerHello. */
void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *ctx, int (*cb) (SSL *ssl, const unsigned char **out, unsigned int *outlen, void *arg), void *arg)
	{
	ctx->next_protos_advertised_cb = cb;
	ctx->next_protos_advertised_cb_arg = arg;
	}

/* SSL_CTX_set_next_proto_select_cb sets a callback that is called when a
 * client needs to select a protocol from the server's provided list. |out|
 * must be set to point to the selected protocol (which may be within |in|).
 * The length of the protocol name must be written into |outlen|. The server's
 * advertised protocols are provided in |in| and |inlen|. The callback can
 * assume that |in| is syntactically valid.
 *
 * The client must select a protocol. It is fatal to the connection if this
 * callback returns a value other than SSL_TLSEXT_ERR_OK.
 */
void SSL_CTX_set_next_proto_select_cb(SSL_CTX *ctx, int (*cb) (SSL *s, unsigned char **out, unsigned char *outlen, const unsigned char *in, unsigned int inlen, void *arg), void *arg)
	{
	ctx->next_proto_select_cb = cb;
	ctx->next_proto_select_cb_arg = arg;
	}
# endif
a1483 12
int SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,
	const char *label, size_t llen, const unsigned char *p, size_t plen,
	int use_context)
	{
	if (s->version < TLS1_VERSION)
		return -1;

	return s->method->ssl3_enc->export_keying_material(s, out, olen, label,
							   llen, p, plen,
							   use_context);
	}

a1526 8
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (meth->version < TLS1_VERSION))	
		{
		SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		return NULL;
		}
#endif

a1645 4
# ifndef OPENSSL_NO_NEXTPROTONEG
	ret->next_protos_advertised_cb = 0;
	ret->next_proto_select_cb = 0;
# endif
a1651 3
#ifndef OPENSSL_NO_SRP
	SSL_CTX_SRP_CTX_init(ret);
#endif
a1779 3
        if (a->srtp_profiles)
                sk_SRTP_PROTECTION_PROFILE_free(a->srtp_profiles);

a1783 3
#ifndef OPENSSL_NO_SRP
	SSL_CTX_SRP_CTX_free(a);
#endif
d2037 1
a2037 1
int ssl_check_srvr_ecc_cert_and_alg(X509 *x, SSL *s)
a2042 1
	const SSL_CIPHER *cs = s->s3->tmp.new_cipher;
d2072 1
a2072 1
		if ((alg_k & SSL_kECDHe) && TLS1_get_version(s) < TLS1_2_VERSION)
d2081 1
a2081 1
		if ((alg_k & SSL_kECDHr) && TLS1_get_version(s) < TLS1_2_VERSION)
d2171 1
a2171 1
EVP_PKEY *ssl_get_sign_pkey(SSL *s,const SSL_CIPHER *cipher, const EVP_MD **pmd)
a2174 1
	int idx = -1;
d2181 1
a2181 1
		idx = SSL_PKEY_DSA_SIGN;
d2185 1
a2185 1
			idx = SSL_PKEY_RSA_SIGN;
d2187 3
a2189 1
			idx = SSL_PKEY_RSA_ENC;
d2193 2
a2194 2
		idx = SSL_PKEY_ECC;
	if (idx == -1)
a2198 3
	if (pmd)
		*pmd = c->pkeys[idx].digest;
	return c->pkeys[idx].privatekey;
a2422 4
	if (s->version == TLS1_2_VERSION)
		return("TLSv1.2");
	else if (s->version == TLS1_1_VERSION)
		return("TLSv1.1");
a2516 1
	ret->renegotiate = s->renegotiate;
a2781 5
void SSL_set_state(SSL *ssl, int state)
	{
	ssl->state = state;
	}

a3039 10
void SSL_set_debug(SSL *s, int debug)
	{
	s->debug = debug;
	}

int SSL_cache_hit(SSL *s)
	{
	return s->hit;
	}

d3048 1
@


1.1.1.17
log
@Import OpenSSL 1.0.1g
@
text
@a599 1
#ifndef OPENSSL_NO_SRTP
a601 1
#endif
d1798 1
a1798 3
	/* No compression for DTLS */
	if (meth->version != DTLS1_VERSION)
		ret->comp_methods=SSL_COMP_get_compression_methods();
a1954 1
#ifndef OPENSSL_NO_SRTP
a1956 1
#endif
d2290 1
a2290 1
CERT_PKEY *ssl_get_server_send_pkey(const SSL *s)
d2345 1
a2345 1
		SSLerr(SSL_F_SSL_GET_SERVER_SEND_PKEY,ERR_R_INTERNAL_ERROR);
d2348 1
d2350 1
a2350 10
	return c->pkeys + i;
	}

X509 *ssl_get_server_send_cert(const SSL *s)
	{
	CERT_PKEY *cpk;
	cpk = ssl_get_server_send_pkey(s);
	if (!cpk)
		return NULL;
	return cpk->x509;
d2611 1
a2611 1
	else if (s->version == TLS1_VERSION)
@


