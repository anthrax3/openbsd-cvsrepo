head	1.178;
access;
symbols;
locks; strict;
comment	@ * @;


1.178
date	2017.03.10.16.03.27;	author jsing;	state Exp;
branches;
next	1.177;
commitid	CCNwpUSZ1TvGpJJt;

1.177
date	2017.03.05.14.39.53;	author jsing;	state Exp;
branches;
next	1.176;
commitid	ws87QY8nHNtKAMYH;

1.176
date	2017.03.04.16.32.00;	author jsing;	state Exp;
branches;
next	1.175;
commitid	TrWoiZkfDXTvdQj8;

1.175
date	2017.02.28.14.08.49;	author jsing;	state Exp;
branches;
next	1.174;
commitid	4oDOXgdSwn6wlYCL;

1.174
date	2017.02.21.15.28.27;	author jsing;	state Exp;
branches;
next	1.173;
commitid	iXozEhlUPP0zrXfF;

1.173
date	2017.02.07.02.08.38;	author beck;	state Exp;
branches;
next	1.172;
commitid	xH3OeartUDKSlAnB;

1.172
date	2017.01.26.10.40.21;	author beck;	state Exp;
branches;
next	1.171;
commitid	Bi1VygMenL4YtCp7;

1.171
date	2017.01.26.07.20.57;	author beck;	state Exp;
branches;
next	1.170;
commitid	t6df4Y0447eXpzHd;

1.170
date	2017.01.26.06.32.58;	author jsing;	state Exp;
branches;
next	1.169;
commitid	TbFBd2VdEVckCCsd;

1.169
date	2017.01.26.05.31.25;	author jsing;	state Exp;
branches;
next	1.168;
commitid	GRopTNgx07uByytM;

1.168
date	2017.01.26.00.42.44;	author jsing;	state Exp;
branches;
next	1.167;
commitid	Abyg6hUnK4VyzfBQ;

1.167
date	2017.01.25.10.54.23;	author jsing;	state Exp;
branches;
next	1.166;
commitid	aCcgLh3rT7Wju1Vr;

1.166
date	2017.01.25.06.38.01;	author jsing;	state Exp;
branches;
next	1.165;
commitid	BfbU6dj1dwbGBHiv;

1.165
date	2017.01.25.06.13.02;	author jsing;	state Exp;
branches;
next	1.164;
commitid	BrXF01BiSMHL1r6O;

1.164
date	2017.01.24.09.03.21;	author jsing;	state Exp;
branches;
next	1.163;
commitid	NTZJ3rEptTLCIZDB;

1.163
date	2017.01.23.22.34.38;	author beck;	state Exp;
branches;
next	1.162;
commitid	LjSyQ9gcPyeZpDNB;

1.162
date	2017.01.23.14.35.42;	author jsing;	state Exp;
branches;
next	1.161;
commitid	fvePj4ki9zOwq3SB;

1.161
date	2017.01.23.13.36.13;	author jsing;	state Exp;
branches;
next	1.160;
commitid	xYJ523Ay020rUB5W;

1.160
date	2017.01.23.08.48.44;	author beck;	state Exp;
branches;
next	1.159;
commitid	vAKES6VByBpegTl4;

1.159
date	2017.01.23.08.08.06;	author beck;	state Exp;
branches;
next	1.158;
commitid	INyvrQFO5zrO2vlL;

1.158
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.157;
commitid	grTXB43OAHDwwKOU;

1.157
date	2017.01.23.05.27.22;	author jsing;	state Exp;
branches;
next	1.156;
commitid	Fb8XE84a6xE5r8Gy;

1.156
date	2017.01.23.05.13.02;	author jsing;	state Exp;
branches;
next	1.155;
commitid	XWcFqNClp2MoKERU;

1.155
date	2017.01.23.04.55.27;	author beck;	state Exp;
branches;
next	1.154;
commitid	AhwkqHI5lKK3NR31;

1.154
date	2017.01.23.04.15.28;	author jsing;	state Exp;
branches;
next	1.153;
commitid	j20UnjrPw7WvzMvm;

1.153
date	2017.01.23.01.22.08;	author jsing;	state Exp;
branches;
next	1.152;
commitid	YymiVWgtX4KkSfL3;

1.152
date	2017.01.23.00.12.55;	author jsing;	state Exp;
branches;
next	1.151;
commitid	Ry6OEk67lc2U2xi9;

1.151
date	2017.01.22.09.02.07;	author jsing;	state Exp;
branches;
next	1.150;
commitid	570ElYZpaAvthwZh;

1.150
date	2017.01.22.07.16.39;	author beck;	state Exp;
branches;
next	1.149;
commitid	qajmn1SU3Rm3vz6g;

1.149
date	2017.01.22.06.36.49;	author jsing;	state Exp;
branches;
next	1.148;
commitid	jkexAOoo4I6xT9SH;

1.148
date	2017.01.22.05.14.42;	author beck;	state Exp;
branches;
next	1.147;
commitid	cQZFlJKgRV0smF3Q;

1.147
date	2017.01.22.04.07.44;	author jsing;	state Exp;
branches;
next	1.146;
commitid	BEcuQdhH5OOziMLl;

1.146
date	2017.01.22.03.50.45;	author jsing;	state Exp;
branches;
next	1.145;
commitid	Q5mGTZ7ZJXh4fPDx;

1.145
date	2017.01.21.04.18.18;	author jsing;	state Exp;
branches;
next	1.144;
commitid	jWRTjyshEFBrskg1;

1.144
date	2017.01.03.16.57.15;	author jsing;	state Exp;
branches;
next	1.143;
commitid	Y2i9OYGcVG7mIq9R;

1.143
date	2016.12.30.16.57.01;	author jsing;	state Exp;
branches;
next	1.142;
commitid	W0S1uBsnMfMqkUUv;

1.142
date	2016.12.30.15.12.45;	author jsing;	state Exp;
branches;
next	1.141;
commitid	zii5fVlB2KO93yI6;

1.141
date	2016.12.21.16.44.31;	author jsing;	state Exp;
branches;
next	1.140;
commitid	QsxdTGoZtELBjsxp;

1.140
date	2016.12.18.13.52.53;	author jsing;	state Exp;
branches;
next	1.139;
commitid	SZGgsYK419MoSxtG;

1.139
date	2016.12.06.13.38.11;	author jsing;	state Exp;
branches;
next	1.138;
commitid	NUWXcEP3cB3L0fHl;

1.138
date	2016.12.06.13.17.52;	author jsing;	state Exp;
branches;
next	1.137;
commitid	G67mpujAD0pCOeCU;

1.137
date	2016.12.04.14.32.30;	author jsing;	state Exp;
branches;
next	1.136;
commitid	5bdQ9DStxZhVq2ym;

1.136
date	2016.11.06.17.21.04;	author jsing;	state Exp;
branches;
next	1.135;
commitid	Lh9K5THL4plZd9hw;

1.135
date	2016.11.05.08.26.36;	author jsing;	state Exp;
branches;
next	1.134;
commitid	PesnxNxHCgdr6Tvs;

1.134
date	2016.11.04.19.11.43;	author jsing;	state Exp;
branches;
next	1.133;
commitid	flfhf3ewosqcrbcc;

1.133
date	2016.11.04.18.28.58;	author guenther;	state Exp;
branches;
next	1.132;
commitid	ZlRy5iKYWHc9l7Fq;

1.132
date	2016.11.04.18.00.12;	author guenther;	state Exp;
branches;
next	1.131;
commitid	pSglqyiZvatha7lU;

1.131
date	2016.11.03.08.15.22;	author jsing;	state Exp;
branches;
next	1.130;
commitid	amKlLysXKXV1zexI;

1.130
date	2016.10.19.16.38.40;	author jsing;	state Exp;
branches;
next	1.129;
commitid	zBSqJxdzZYua3a3I;

1.129
date	2016.04.28.16.39.45;	author jsing;	state Exp;
branches;
next	1.128;
commitid	MlZ5jZHGKzYpF9uz;

1.128
date	2015.09.12.15.08.54;	author jsing;	state Exp;
branches;
next	1.127;
commitid	C730Np1tNHtSwNfJ;

1.127
date	2015.09.12.15.03.39;	author jsing;	state Exp;
branches;
next	1.126;
commitid	86J9jDyJ44W6WCGe;

1.126
date	2015.09.12.14.32.24;	author jsing;	state Exp;
branches;
next	1.125;
commitid	gmjC21XhF2eUmrWG;

1.125
date	2015.09.12.14.28.23;	author jsing;	state Exp;
branches;
next	1.124;
commitid	qzeNwXAWnhAAuHQE;

1.124
date	2015.09.12.13.35.34;	author jsing;	state Exp;
branches;
next	1.123;
commitid	o1U1iPzyztRMHJTL;

1.123
date	2015.09.12.13.25.26;	author jsing;	state Exp;
branches;
next	1.122;
commitid	fbVoFJTRUmDORcyA;

1.122
date	2015.09.12.13.09.07;	author jsing;	state Exp;
branches;
next	1.121;
commitid	a9egWBSw5wJ7Fh5x;

1.121
date	2015.09.12.12.58.15;	author jsing;	state Exp;
branches;
next	1.120;
commitid	1jVyIriiuraS5IRJ;

1.120
date	2015.09.12.12.26.56;	author jsing;	state Exp;
branches;
next	1.119;
commitid	U95DqojbIagvkkKK;

1.119
date	2015.09.11.18.08.21;	author jsing;	state Exp;
branches;
next	1.118;
commitid	pa8oXRlJthT375Ws;

1.118
date	2015.09.11.17.37.47;	author jsing;	state Exp;
branches;
next	1.117;
commitid	EbVUFfLy1NvhaoDt;

1.117
date	2015.09.11.17.35.36;	author jsing;	state Exp;
branches;
next	1.116;
commitid	7HJmWOoZGIjCFd3s;

1.116
date	2015.09.11.17.32.23;	author jsing;	state Exp;
branches;
next	1.115;
commitid	ruNQFMbr8IKXZhgD;

1.115
date	2015.09.11.17.29.36;	author jsing;	state Exp;
branches;
next	1.114;
commitid	VCGEXb1kmMpuyChI;

1.114
date	2015.09.11.17.17.44;	author jsing;	state Exp;
branches;
next	1.113;
commitid	EapdYYP87HHB46Zi;

1.113
date	2015.09.11.17.11.53;	author jsing;	state Exp;
branches;
next	1.112;
commitid	rs7MJUl5HqwBT9q6;

1.112
date	2015.09.11.17.08.50;	author jsing;	state Exp;
branches;
next	1.111;
commitid	Cu2QpQbOAsdEyjFC;

1.111
date	2015.09.11.17.04.39;	author jsing;	state Exp;
branches;
next	1.110;
commitid	csGjbouXtrA2P64R;

1.110
date	2015.09.11.17.03.03;	author jsing;	state Exp;
branches;
next	1.109;
commitid	DFvv2qXJy5GNlRwX;

1.109
date	2015.09.11.17.01.19;	author jsing;	state Exp;
branches;
next	1.108;
commitid	jQZ3WzxwYTOZter3;

1.108
date	2015.09.11.16.59.17;	author jsing;	state Exp;
branches;
next	1.107;
commitid	ZY2utudxRbezwjHW;

1.107
date	2015.09.11.16.56.17;	author jsing;	state Exp;
branches;
next	1.106;
commitid	RyfjHG1AQPjhMazY;

1.106
date	2015.09.11.16.53.51;	author jsing;	state Exp;
branches;
next	1.105;
commitid	kcXUxmEdE7K553CY;

1.105
date	2015.09.11.16.50.46;	author jsing;	state Exp;
branches;
next	1.104;
commitid	GO6Y19AqZWCR8cKL;

1.104
date	2015.09.11.16.28.37;	author jsing;	state Exp;
branches;
next	1.103;
commitid	D3HqE5ZRseh1ZZFx;

1.103
date	2015.09.02.17.59.15;	author jsing;	state Exp;
branches;
next	1.102;
commitid	6qqbZhzSEFZnYRiq;

1.102
date	2015.09.01.13.38.27;	author jsing;	state Exp;
branches;
next	1.101;
commitid	181x6cJx2ceVnn0a;

1.101
date	2015.08.29.17.15.52;	author doug;	state Exp;
branches;
next	1.100;
commitid	J5Q7EI1v6Se5pITr;

1.100
date	2015.07.24.07.57.48;	author doug;	state Exp;
branches;
next	1.99;
commitid	XslgAA8i1lseynfs;

1.99
date	2015.07.19.07.30.06;	author doug;	state Exp;
branches;
next	1.98;
commitid	N7VdpUQsePnBwxuL;

1.98
date	2015.07.19.06.31.32;	author doug;	state Exp;
branches;
next	1.97;
commitid	as8DOqEY9XBrHJyu;

1.97
date	2015.07.18.23.00.23;	author doug;	state Exp;
branches;
next	1.96;
commitid	83F4EYjF8aqo7ueq;

1.96
date	2015.07.17.17.36.24;	author doug;	state Exp;
branches;
next	1.95;
commitid	4A1FZfzbj7GfvPA4;

1.95
date	2015.07.14.03.38.26;	author doug;	state Exp;
branches;
next	1.94;
commitid	ClU0QmPPkFs7NYjp;

1.94
date	2015.06.28.00.08.27;	author doug;	state Exp;
branches;
next	1.93;
commitid	JVzmospDlYt9nhzg;

1.93
date	2015.06.20.16.42.48;	author doug;	state Exp;
branches;
next	1.92;
commitid	qOffpViBM0u0pbwX;

1.92
date	2015.06.20.04.04.35;	author doug;	state Exp;
branches;
next	1.91;
commitid	HgxIDjid62RpqPlz;

1.91
date	2015.06.18.22.51.05;	author doug;	state Exp;
branches;
next	1.90;
commitid	AcOny6o1iDzXgvTz;

1.90
date	2015.04.15.16.25.43;	author jsing;	state Exp;
branches;
next	1.89;
commitid	pvAlLTVkoLxmS3rG;

1.89
date	2015.03.27.12.29.54;	author jsing;	state Exp;
branches;
next	1.88;
commitid	GlMku1cNd3nfgnVW;

1.88
date	2015.02.22.15.54.27;	author jsing;	state Exp;
branches;
next	1.87;
commitid	9t8bOP5HFWMq1Big;

1.87
date	2015.02.12.03.45.25;	author jsing;	state Exp;
branches;
next	1.86;
commitid	ZdeeylZ91TlYBz1I;

1.86
date	2015.02.07.04.17.11;	author jsing;	state Exp;
branches;
next	1.85;
commitid	kTcp4bxIaEX3QOn0;

1.85
date	2015.02.06.08.30.23;	author jsing;	state Exp;
branches;
next	1.84;
commitid	K5MXFl39zEkHakNY;

1.84
date	2014.12.15.00.46.53;	author doug;	state Exp;
branches;
next	1.83;
commitid	I2ue40Sqz1Sg9KmB;

1.83
date	2014.12.14.16.19.38;	author jsing;	state Exp;
branches;
next	1.82;
commitid	LQ4CRrGioEdszPsH;

1.82
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.81;
commitid	XNZawfRSWvnVv1VS;

1.81
date	2014.12.10.15.43.31;	author jsing;	state Exp;
branches;
next	1.80;
commitid	9GGF3DCNTm9Bs8E3;

1.80
date	2014.12.10.15.36.47;	author jsing;	state Exp;
branches;
next	1.79;
commitid	x50cturILyXAfPoH;

1.79
date	2014.12.06.14.24.26;	author jsing;	state Exp;
branches;
next	1.78;
commitid	R8J9s9ZDvNB7vidN;

1.78
date	2014.12.06.13.51.06;	author jsing;	state Exp;
branches;
next	1.77;
commitid	hIBGoSRrWndOvCaU;

1.77
date	2014.11.18.05.33.43;	author miod;	state Exp;
branches;
next	1.76;
commitid	81uwsCsokEuKDUjo;

1.76
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.75;
commitid	M3pvHgIFoWUHNqJn;

1.75
date	2014.11.08.15.21.02;	author jsing;	state Exp;
branches;
next	1.74;
commitid	lIDXnjZtfw9o5vQC;

1.74
date	2014.11.02.10.42.38;	author jsing;	state Exp;
branches;
next	1.73;
commitid	neOGF3Pv7ccNdldy;

1.73
date	2014.10.31.15.25.55;	author jsing;	state Exp;
branches;
next	1.72;
commitid	NOaAgwTtK29a9Ncs;

1.72
date	2014.10.31.14.51.01;	author jsing;	state Exp;
branches;
next	1.71;
commitid	cMCIoWtrOiPFZWnD;

1.71
date	2014.10.03.13.58.18;	author jsing;	state Exp;
branches;
next	1.70;
commitid	TTuHOVoRSWSvd6HI;

1.70
date	2014.09.30.15.40.09;	author jsing;	state Exp;
branches;
next	1.69;
commitid	HYNEHWCCpGJW4ziw;

1.69
date	2014.09.27.11.01.06;	author jsing;	state Exp;
branches;
next	1.68;
commitid	pg2itwAdFVptNvwc;

1.68
date	2014.09.07.12.16.23;	author jsing;	state Exp;
branches;
next	1.67;
commitid	oAt7EW2Y0Fwu0XNB;

1.67
date	2014.08.24.14.36.46;	author jsing;	state Exp;
branches;
next	1.66;
commitid	1vOBE9WdltEkCa6G;

1.66
date	2014.08.23.14.52.41;	author jsing;	state Exp;
branches;
next	1.65;
commitid	hTkCFMErB7xMsqus;

1.65
date	2014.08.11.01.06.22;	author jsing;	state Exp;
branches;
next	1.64;
commitid	EjXY9DxJ6SGazL3V;

1.64
date	2014.08.10.14.42.56;	author jsing;	state Exp;
branches;
next	1.63;
commitid	wihJupNvfkdpKL9O;

1.63
date	2014.07.28.04.23.12;	author guenther;	state Exp;
branches
	1.63.4.1;
next	1.62;
commitid	9823pc9SeqrqIVJr;

1.62
date	2014.07.12.22.33.39;	author jsing;	state Exp;
branches;
next	1.61;
commitid	JT7oO4AHgBkjVLfZ;

1.61
date	2014.07.12.19.45.53;	author jsing;	state Exp;
branches;
next	1.60;
commitid	foFDfYAdqxlf9LD4;

1.60
date	2014.07.12.13.11.53;	author jsing;	state Exp;
branches;
next	1.59;
commitid	tJhRneQ4w1l9LuV2;

1.59
date	2014.07.11.08.17.36;	author miod;	state Exp;
branches;
next	1.58;
commitid	3cdQWc5wTDwlWJsQ;

1.58
date	2014.07.10.10.09.54;	author jsing;	state Exp;
branches;
next	1.57;
commitid	ClZ3wY7kSvwpyKpe;

1.57
date	2014.07.10.08.51.15;	author tedu;	state Exp;
branches;
next	1.56;
commitid	lsH7iukeZYSZBx6F;

1.56
date	2014.07.09.11.25.42;	author jsing;	state Exp;
branches;
next	1.55;
commitid	N5P2FUkVkAd7ODs9;

1.55
date	2014.07.08.21.50.40;	author jsing;	state Exp;
branches;
next	1.54;
commitid	kLhCDmTWLPmmRB38;

1.54
date	2014.07.08.21.31.54;	author jsing;	state Exp;
branches;
next	1.53;
commitid	u8sNaJWXrZLtsBK5;

1.53
date	2014.06.21.17.02.25;	author jsing;	state Exp;
branches;
next	1.52;
commitid	pgD7ISJAPEuMy3ok;

1.52
date	2014.06.15.15.29.25;	author jsing;	state Exp;
branches;
next	1.51;
commitid	G9UpwpcoMkFCFqBD;

1.51
date	2014.06.13.13.28.53;	author jsing;	state Exp;
branches;
next	1.50;
commitid	Ujg3vMZHX0kgoEuK;

1.50
date	2014.06.13.10.52.24;	author jsing;	state Exp;
branches;
next	1.49;
commitid	NX4qoGRCqaBXEm1B;

1.49
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	mJUVYpkFBZ0Zv2bG;

1.48
date	2014.06.08.16.24.49;	author jsing;	state Exp;
branches;
next	1.47;
commitid	jNUDlA3Vuq6B2gbp;

1.47
date	2014.06.07.22.23.12;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	4IX3BI6FoxwuHgdS;

1.46
date	2014.05.31.10.53.39;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2014.05.31.10.49.28;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2014.05.30.05.27.32;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.29.21.22.54;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.29.18.11.13;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.29.16.00.16;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.27.20.22.00;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.25.17.32.20;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.25.13.27.38;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2014.05.24.12.44.48;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2014.05.22.17.43.52;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2014.05.22.17.37.06;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2014.05.15.19.39.46;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.27.20.34.33;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.27.20.22.32;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.23.22.26.26;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.19.10.59.54;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.17.20.34.24;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.16.21.16.33;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.16.15.10.07;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.15.12.00.25;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.14.18.45.55;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.13.23.50.02;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2014.02.27.21.04.57;	author jca;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2013.02.14.15.11.43;	author markus;	state Exp;
branches
	1.19.4.1;
next	1.18;

1.18
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches
	1.15.2.1
	1.15.6.1;
next	1.14;

1.14
date	2009.01.05.21.36.39;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.06.12.17.54;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.14.11.18.04;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.10.16.31.57;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.05.22.12.11;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.30.11.08.06;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.03.41;	author beck;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2000.12.15.02.58.41;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.33;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.30;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.13;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.13;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.42;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.44.34;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.53.03;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.28;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.14.07;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2012.01.05.22.59.10;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.10.13.21.23.50;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.5.2.1
date	2002.07.30.11.07.34;	author miod;	state Exp;
branches;
next	;

1.5.4.1
date	2002.07.30.15.47.52;	author jason;	state Exp;
branches;
next	;

1.15.2.1
date	2009.11.17.14.34.37;	author sthen;	state Exp;
branches;
next	;

1.15.6.1
date	2009.11.17.14.34.52;	author sthen;	state Exp;
branches;
next	;

1.19.4.1
date	2014.06.05.20.37.47;	author sthen;	state Exp;
branches;
next	;
commitid	V8zSJibrIbY4vAzC;

1.20.4.1
date	2014.06.05.17.05.16;	author sthen;	state Exp;
branches;
next	;
commitid	PBa7adr1t6pFSi7e;

1.63.4.1
date	2015.03.11.19.52.37;	author tedu;	state Exp;
branches;
next	;
commitid	hkSvLV4ooBbkYqsi;


desc
@@


1.178
log
@Remove the handshake digests and related code, replacing remaining uses
with the handshake hash. For now tls1_digest_cached_records() is retained
to release the handshake buffer.

ok beck@@ inoguchi@@
@
text
@/* $OpenBSD: ssl_locl.h,v 1.177 2017/03/05 14:39:53 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */

#ifndef HEADER_SSL_LOCL_H
#define HEADER_SSL_LOCL_H

#include <sys/types.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include <openssl/opensslconf.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <openssl/dsa.h>
#include <openssl/err.h>
#include <openssl/rsa.h>
#include <openssl/ssl.h>
#include <openssl/stack.h>

#include "bytestring.h"

__BEGIN_HIDDEN_DECLS

#define l2n(l,c)	(*((c)++)=(unsigned char)(((l)>>24)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>16)&0xff), \
			 *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
			 *((c)++)=(unsigned char)(((l)    )&0xff))

#define l2n8(l,c)	(*((c)++)=(unsigned char)(((l)>>56)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>48)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>40)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>32)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>24)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>16)&0xff), \
			 *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
			 *((c)++)=(unsigned char)(((l)    )&0xff))

#define n2s(c,s)	((s=(((unsigned int)(c[0]))<< 8)| \
			    (((unsigned int)(c[1]))    )),c+=2)
#define s2n(s,c)	((c[0]=(unsigned char)(((s)>> 8)&0xff), \
			  c[1]=(unsigned char)(((s)    )&0xff)),c+=2)

#define l2n3(l,c)	((c[0]=(unsigned char)(((l)>>16)&0xff), \
			  c[1]=(unsigned char)(((l)>> 8)&0xff), \
			  c[2]=(unsigned char)(((l)    )&0xff)),c+=3)

/* LOCAL STUFF */

#define SSL_DECRYPT	0
#define SSL_ENCRYPT	1

/*
 * Define the Bitmasks for SSL_CIPHER.algorithms.
 * This bits are used packed as dense as possible. If new methods/ciphers
 * etc will be added, the bits a likely to change, so this information
 * is for internal library use only, even though SSL_CIPHER.algorithms
 * can be publicly accessed.
 * Use the according functions for cipher management instead.
 *
 * The bit mask handling in the selection and sorting scheme in
 * ssl_create_cipher_list() has only limited capabilities, reflecting
 * that the different entities within are mutually exclusive:
 * ONLY ONE BIT PER MASK CAN BE SET AT A TIME.
 */

/* Bits for algorithm_mkey (key exchange algorithm) */
#define SSL_kRSA		0x00000001L /* RSA key exchange */
#define SSL_kDHE		0x00000008L /* tmp DH key no DH cert */
#define SSL_kECDHE		0x00000080L /* ephemeral ECDH */
#define SSL_kGOST		0x00000200L /* GOST key exchange */

/* Bits for algorithm_auth (server authentication) */
#define SSL_aRSA		0x00000001L /* RSA auth */
#define SSL_aDSS 		0x00000002L /* DSS auth */
#define SSL_aNULL 		0x00000004L /* no auth (i.e. use ADH or AECDH) */
#define SSL_aECDSA              0x00000040L /* ECDSA auth*/
#define SSL_aGOST01 		0x00000200L /* GOST R 34.10-2001 signature auth */

/* Bits for algorithm_enc (symmetric encryption) */
#define SSL_DES			0x00000001L
#define SSL_3DES		0x00000002L
#define SSL_RC4			0x00000004L
#define SSL_IDEA		0x00000008L
#define SSL_eNULL		0x00000010L
#define SSL_AES128		0x00000020L
#define SSL_AES256		0x00000040L
#define SSL_CAMELLIA128		0x00000080L
#define SSL_CAMELLIA256		0x00000100L
#define SSL_eGOST2814789CNT	0x00000200L
#define SSL_AES128GCM		0x00000400L
#define SSL_AES256GCM		0x00000800L
#define SSL_CHACHA20POLY1305	0x00001000L
#define SSL_CHACHA20POLY1305_OLD	0x00002000L

#define SSL_AES        		(SSL_AES128|SSL_AES256|SSL_AES128GCM|SSL_AES256GCM)
#define SSL_CAMELLIA		(SSL_CAMELLIA128|SSL_CAMELLIA256)


/* Bits for algorithm_mac (symmetric authentication) */

#define SSL_MD5			0x00000001L
#define SSL_SHA1		0x00000002L
#define SSL_GOST94      0x00000004L
#define SSL_GOST89MAC   0x00000008L
#define SSL_SHA256		0x00000010L
#define SSL_SHA384		0x00000020L
/* Not a real MAC, just an indication it is part of cipher */
#define SSL_AEAD		0x00000040L
#define SSL_STREEBOG256		0x00000080L

/* Bits for algorithm_ssl (protocol version) */
#define SSL_SSLV3		0x00000002L
#define SSL_TLSV1		SSL_SSLV3	/* for now */
#define SSL_TLSV1_2		0x00000004L


/* Bits for algorithm2 (handshake digests and other extra flags) */

#define SSL_HANDSHAKE_MAC_MASK		0xff0
#define SSL_HANDSHAKE_MAC_MD5		0x010
#define SSL_HANDSHAKE_MAC_SHA		0x020
#define SSL_HANDSHAKE_MAC_GOST94	0x040
#define SSL_HANDSHAKE_MAC_SHA256	0x080
#define SSL_HANDSHAKE_MAC_SHA384	0x100
#define SSL_HANDSHAKE_MAC_STREEBOG256	0x200
#define SSL_HANDSHAKE_MAC_DEFAULT (SSL_HANDSHAKE_MAC_MD5 | SSL_HANDSHAKE_MAC_SHA)

/* When adding new digest in the ssl_ciph.c and increment SSM_MD_NUM_IDX
 * make sure to update this constant too */
#define SSL_MAX_DIGEST 7

#define SSL3_CK_ID		0x03000000
#define SSL3_CK_VALUE_MASK	0x0000ffff

#define TLS1_PRF_DGST_MASK	(0xff << TLS1_PRF_DGST_SHIFT)

#define TLS1_PRF_DGST_SHIFT 10
#define TLS1_PRF_MD5 (SSL_HANDSHAKE_MAC_MD5 << TLS1_PRF_DGST_SHIFT)
#define TLS1_PRF_SHA1 (SSL_HANDSHAKE_MAC_SHA << TLS1_PRF_DGST_SHIFT)
#define TLS1_PRF_SHA256 (SSL_HANDSHAKE_MAC_SHA256 << TLS1_PRF_DGST_SHIFT)
#define TLS1_PRF_SHA384 (SSL_HANDSHAKE_MAC_SHA384 << TLS1_PRF_DGST_SHIFT)
#define TLS1_PRF_GOST94 (SSL_HANDSHAKE_MAC_GOST94 << TLS1_PRF_DGST_SHIFT)
#define TLS1_PRF_STREEBOG256 (SSL_HANDSHAKE_MAC_STREEBOG256 << TLS1_PRF_DGST_SHIFT)
#define TLS1_PRF (TLS1_PRF_MD5 | TLS1_PRF_SHA1)

/* Stream MAC for GOST ciphersuites from cryptopro draft
 * (currently this also goes into algorithm2) */
#define TLS1_STREAM_MAC 0x04

/*
 * SSL_CIPHER_ALGORITHM2_VARIABLE_NONCE_IN_RECORD is an algorithm2 flag that
 * indicates that the variable part of the nonce is included as a prefix of
 * the record (AES-GCM, for example, does this with an 8-byte variable nonce.)
 */
#define SSL_CIPHER_ALGORITHM2_VARIABLE_NONCE_IN_RECORD (1 << 22)

/*
 * SSL_CIPHER_ALGORITHM2_AEAD is an algorithm2 flag that indicates the cipher
 * is implemented via an EVP_AEAD.
 */
#define SSL_CIPHER_ALGORITHM2_AEAD (1 << 23)

/*
 * SSL_CIPHER_AEAD_FIXED_NONCE_LEN returns the number of bytes of fixed nonce
 * for an SSL_CIPHER with the SSL_CIPHER_ALGORITHM2_AEAD flag.
 */
#define SSL_CIPHER_AEAD_FIXED_NONCE_LEN(ssl_cipher) \
	(((ssl_cipher->algorithm2 >> 24) & 0xf) * 2)

/*
 * Cipher strength information.
 */
#define SSL_STRONG_MASK		0x000001fcL
#define SSL_STRONG_NONE		0x00000004L
#define SSL_LOW			0x00000020L
#define SSL_MEDIUM		0x00000040L
#define SSL_HIGH		0x00000080L

/*
 * The keylength (measured in RSA key bits, I guess)  for temporary keys.
 * Cipher argument is so that this can be variable in the future.
 */
#define SSL_C_PKEYLENGTH(c)	1024

/* Check if an SSL structure is using DTLS. */
#define SSL_IS_DTLS(s) \
	(s->method->internal->version == DTLS1_VERSION)

/* See if we need explicit IV. */
#define SSL_USE_EXPLICIT_IV(s) \
	(s->method->internal->ssl3_enc->enc_flags & SSL_ENC_FLAG_EXPLICIT_IV)

/* See if we use signature algorithms extension. */
#define SSL_USE_SIGALGS(s) \
	(s->method->internal->ssl3_enc->enc_flags & SSL_ENC_FLAG_SIGALGS)

/* Allow TLS 1.2 ciphersuites: applies to DTLS 1.2 as well as TLS 1.2. */
#define SSL_USE_TLS1_2_CIPHERS(s) \
	(s->method->internal->ssl3_enc->enc_flags & SSL_ENC_FLAG_TLS1_2_CIPHERS)

/* Mostly for SSLv3 */
#define SSL_PKEY_RSA_ENC	0
#define SSL_PKEY_RSA_SIGN	1
#define SSL_PKEY_DSA_SIGN	2
#define SSL_PKEY_DH_RSA		3
#define SSL_PKEY_DH_DSA		4
#define SSL_PKEY_ECC            5
#define SSL_PKEY_GOST01		6
#define SSL_PKEY_NUM		7

#define SSL_MAX_EMPTY_RECORDS	32

/* SSL_kRSA <- RSA_ENC | (RSA_TMP & RSA_SIGN) |
 * 	    <- (EXPORT & (RSA_ENC | RSA_TMP) & RSA_SIGN)
 * SSL_kDH  <- DH_ENC & (RSA_ENC | RSA_SIGN | DSA_SIGN)
 * SSL_kDHE <- RSA_ENC | RSA_SIGN | DSA_SIGN
 * SSL_aRSA <- RSA_ENC | RSA_SIGN
 * SSL_aDSS <- DSA_SIGN
 */

/*
#define CERT_INVALID		0
#define CERT_PUBLIC_KEY		1
#define CERT_PRIVATE_KEY	2
*/

/* From ECC-TLS draft, used in encoding the curve type in
 * ECParameters
 */
#define EXPLICIT_PRIME_CURVE_TYPE  1
#define EXPLICIT_CHAR2_CURVE_TYPE  2
#define NAMED_CURVE_TYPE           3

typedef struct ssl_method_internal_st {
	int version;

	uint16_t min_version;
	uint16_t max_version;

	int (*ssl_new)(SSL *s);
	void (*ssl_clear)(SSL *s);
	void (*ssl_free)(SSL *s);

	int (*ssl_accept)(SSL *s);
	int (*ssl_connect)(SSL *s);
	int (*ssl_read)(SSL *s, void *buf, int len);
	int (*ssl_peek)(SSL *s, void *buf, int len);
	int (*ssl_write)(SSL *s, const void *buf, int len);
	int (*ssl_shutdown)(SSL *s);

	int (*ssl_renegotiate)(SSL *s);
	int (*ssl_renegotiate_check)(SSL *s);

	long (*ssl_get_message)(SSL *s, int st1, int stn, int mt,
	    long max, int *ok);
	int (*ssl_read_bytes)(SSL *s, int type, unsigned char *buf,
	    int len, int peek);
	int (*ssl_write_bytes)(SSL *s, int type, const void *buf_, int len);

	int (*ssl_pending)(const SSL *s);
	const struct ssl_method_st *(*get_ssl_method)(int version);

	long (*get_timeout)(void);
	int (*ssl_version)(void);

	struct ssl3_enc_method *ssl3_enc; /* Extra SSLv3/TLS stuff */
} SSL_METHOD_INTERNAL;

typedef struct ssl_session_internal_st {
	CRYPTO_EX_DATA ex_data; /* application specific data */

	/* These are used to make removal of session-ids more
	 * efficient and to implement a maximum cache size. */
	struct ssl_session_st *prev, *next;

	/* Used to indicate that session resumption is not allowed.
	 * Applications can also set this bit for a new session via
	 * not_resumable_session_cb to disable session caching and tickets. */
	int not_resumable;

	/* The cert is the certificate used to establish this connection */
	struct sess_cert_st /* SESS_CERT */ *sess_cert;

	size_t tlsext_ecpointformatlist_length;
	uint8_t *tlsext_ecpointformatlist; /* peer's list */
	size_t tlsext_supportedgroups_length;
	uint16_t *tlsext_supportedgroups; /* peer's list */
} SSL_SESSION_INTERNAL;
#define SSI(s) (s->session->internal)

typedef struct ssl_ctx_internal_st {
	uint16_t min_version;
	uint16_t max_version;

	unsigned long options;
	unsigned long mode;

	/* If this callback is not null, it will be called each
	 * time a session id is added to the cache.  If this function
	 * returns 1, it means that the callback will do a
	 * SSL_SESSION_free() when it has finished using it.  Otherwise,
	 * on 0, it means the callback has finished with it.
	 * If remove_session_cb is not null, it will be called when
	 * a session-id is removed from the cache.  After the call,
	 * OpenSSL will SSL_SESSION_free() it. */
	int (*new_session_cb)(struct ssl_st *ssl, SSL_SESSION *sess);
	void (*remove_session_cb)(struct ssl_ctx_st *ctx, SSL_SESSION *sess);
	SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl,
	    unsigned char *data, int len, int *copy);

	/* if defined, these override the X509_verify_cert() calls */
	int (*app_verify_callback)(X509_STORE_CTX *, void *);
	    void *app_verify_arg;

	/* get client cert callback */
	int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey);

	/* cookie generate callback */
	int (*app_gen_cookie_cb)(SSL *ssl, unsigned char *cookie,
	    unsigned int *cookie_len);

	/* verify cookie callback */
	int (*app_verify_cookie_cb)(SSL *ssl, unsigned char *cookie,
	    unsigned int cookie_len);

	void (*info_callback)(const SSL *ssl,int type,int val); /* used if SSL's info_callback is NULL */

	/* callback that allows applications to peek at protocol messages */
	void (*msg_callback)(int write_p, int version, int content_type,
	    const void *buf, size_t len, SSL *ssl, void *arg);
	void *msg_callback_arg;

	int (*default_verify_callback)(int ok,X509_STORE_CTX *ctx); /* called 'verify_callback' in the SSL */

	/* Default generate session ID callback. */
	GEN_SESSION_CB generate_session_id;

	/* TLS extensions servername callback */
	int (*tlsext_servername_callback)(SSL*, int *, void *);
	void *tlsext_servername_arg;

	/* Callback to support customisation of ticket key setting */
	int (*tlsext_ticket_key_cb)(SSL *ssl, unsigned char *name,
	    unsigned char *iv, EVP_CIPHER_CTX *ectx, HMAC_CTX *hctx, int enc);

	/* certificate status request info */
	/* Callback for status request */
	int (*tlsext_status_cb)(SSL *ssl, void *arg);
	void *tlsext_status_arg;

	struct lhash_st_SSL_SESSION *sessions;

	/* Most session-ids that will be cached, default is
	 * SSL_SESSION_CACHE_MAX_SIZE_DEFAULT. 0 is unlimited. */
	unsigned long session_cache_size;
	struct ssl_session_st *session_cache_head;
	struct ssl_session_st *session_cache_tail;

	/* This can have one of 2 values, ored together,
	 * SSL_SESS_CACHE_CLIENT,
	 * SSL_SESS_CACHE_SERVER,
	 * Default is SSL_SESSION_CACHE_SERVER, which means only
	 * SSL_accept which cache SSL_SESSIONS. */
	int session_cache_mode;

	struct {
		int sess_connect;	/* SSL new conn - started */
		int sess_connect_renegotiate;/* SSL reneg - requested */
		int sess_connect_good;	/* SSL new conne/reneg - finished */
		int sess_accept;	/* SSL new accept - started */
		int sess_accept_renegotiate;/* SSL reneg - requested */
		int sess_accept_good;	/* SSL accept/reneg - finished */
		int sess_miss;		/* session lookup misses  */
		int sess_timeout;	/* reuse attempt on timeouted session */
		int sess_cache_full;	/* session removed due to full cache */
		int sess_hit;		/* session reuse actually done */
		int sess_cb_hit;	/* session-id that was not
					 * in the cache was
					 * passed back via the callback.  This
					 * indicates that the application is
					 * supplying session-id's from other
					 * processes - spooky :-) */
	} stats;

	CRYPTO_EX_DATA ex_data;

	/* same cipher_list but sorted for lookup */
	STACK_OF(SSL_CIPHER) *cipher_list_by_id;

	struct cert_st /* CERT */ *cert;

	/* Default values used when no per-SSL value is defined follow */

	/* what we put in client cert requests */
	STACK_OF(X509_NAME) *client_CA;

	long max_cert_list;

	int read_ahead;

	int quiet_shutdown;

	/* Maximum amount of data to send in one fragment.
	 * actual record size can be more than this due to
	 * padding and MAC overheads.
	 */
	unsigned int max_send_fragment;

#ifndef OPENSSL_NO_ENGINE
	/* Engine to pass requests for client certs to
	 */
	ENGINE *client_cert_engine;
#endif

	/* RFC 4507 session ticket keys */
	unsigned char tlsext_tick_key_name[16];
	unsigned char tlsext_tick_hmac_key[16];
	unsigned char tlsext_tick_aes_key[16];

	/* SRTP profiles we are willing to do from RFC 5764 */
	STACK_OF(SRTP_PROTECTION_PROFILE) *srtp_profiles;

	/* Next protocol negotiation information */
	/* (for experimental NPN extension). */

	/* For a server, this contains a callback function by which the set of
	 * advertised protocols can be provided. */
	int (*next_protos_advertised_cb)(SSL *s, const unsigned char **buf,
	    unsigned int *len, void *arg);
	void *next_protos_advertised_cb_arg;
	/* For a client, this contains a callback function that selects the
	 * next protocol from the list provided by the server. */
	int (*next_proto_select_cb)(SSL *s, unsigned char **out,
	    unsigned char *outlen, const unsigned char *in,
	    unsigned int inlen, void *arg);
	void *next_proto_select_cb_arg;

	/*
	 * ALPN information
	 * (we are in the process of transitioning from NPN to ALPN).
	 */

	/*
	 * Server callback function that allows the server to select the
	 * protocol for the connection.
	 *   out: on successful return, this must point to the raw protocol
	 *       name (without the length prefix).
	 *   outlen: on successful return, this contains the length of out.
	 *   in: points to the client's list of supported protocols in
	 *       wire-format.
	 *   inlen: the length of in.
	 */
	int (*alpn_select_cb)(SSL *s, const unsigned char **out,
	    unsigned char *outlen, const unsigned char *in, unsigned int inlen,
	    void *arg);
	void *alpn_select_cb_arg;

	/* Client list of supported protocols in wire format. */
	unsigned char *alpn_client_proto_list;
	unsigned int alpn_client_proto_list_len;

	size_t tlsext_ecpointformatlist_length;
	uint8_t *tlsext_ecpointformatlist; /* our list */
	size_t tlsext_supportedgroups_length;
	uint16_t *tlsext_supportedgroups; /* our list */
} SSL_CTX_INTERNAL;

typedef struct ssl_internal_st {
	uint16_t min_version;
	uint16_t max_version;

	unsigned long options; /* protocol behaviour */
	unsigned long mode; /* API behaviour */

	/* Next protocol negotiation. For the client, this is the protocol that
	 * we sent in NextProtocol and is set when handling ServerHello
	 * extensions.
	 *
	 * For a server, this is the client's selected_protocol from
	 * NextProtocol and is set when handling the NextProtocol message,
	 * before the Finished message. */
	unsigned char *next_proto_negotiated;
	unsigned char next_proto_negotiated_len;

	/* Client list of supported protocols in wire format. */
	unsigned char *alpn_client_proto_list;
	unsigned int alpn_client_proto_list_len;

	/* XXX Callbacks */

	/* true when we are actually in SSL_accept() or SSL_connect() */
	int in_handshake;
	int (*handshake_func)(SSL *);
	/* callback that allows applications to peek at protocol messages */
	void (*msg_callback)(int write_p, int version, int content_type,
	    const void *buf, size_t len, SSL *ssl, void *arg);
	void *msg_callback_arg;

	/* Default generate session ID callback. */
	GEN_SESSION_CB generate_session_id;

	int (*verify_callback)(int ok,X509_STORE_CTX *ctx); /* fail if callback returns 0 */

	void (*info_callback)(const SSL *ssl,int type,int val); /* optional informational callback */

	/* TLS extension debug callback */
	void (*tlsext_debug_cb)(SSL *s, int client_server, int type,
	    unsigned char *data, int len, void *arg);
	void *tlsext_debug_arg;

	/* TLS Session Ticket extension callback */
	tls_session_ticket_ext_cb_fn tls_session_ticket_ext_cb;
	void *tls_session_ticket_ext_cb_arg;

	/* TLS pre-shared secret session resumption */
	tls_session_secret_cb_fn tls_session_secret_cb;
	void *tls_session_secret_cb_arg;

	/* XXX non-callback */

	int type; /* SSL_ST_CONNECT or SSL_ST_ACCEPT */

	/* This holds a variable that indicates what we were doing
	 * when a 0 or -1 is returned.  This is needed for
	 * non-blocking IO so we know what request needs re-doing when
	 * in SSL_accept or SSL_connect */
	int rwstate;

	/* Imagine that here's a boolean member "init" that is
	 * switched as soon as SSL_set_{accept/connect}_state
	 * is called for the first time, so that "state" and
	 * "handshake_func" are properly initialized.  But as
	 * handshake_func is == 0 until then, we use this
	 * test instead of an "init" member.
	 */

	int new_session;/* Generate a new session or reuse an old one.
			 * NB: For servers, the 'new' session may actually be a previously
			 * cached session or even the previous session unless
			 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
	int quiet_shutdown;/* don't send shutdown packets */
	int shutdown;	/* we have shut things down, 0x01 sent, 0x02
			 * for received */
	BUF_MEM *init_buf;	/* buffer used during init */
	void *init_msg;		/* pointer to handshake message body, set by ssl3_get_message() */
	int init_num;		/* amount read/written */
	int init_off;		/* amount read/written */

	/* used internally to point at a raw packet */
	unsigned char *packet;
	unsigned int packet_length;

	int read_ahead;		/* Read as many input bytes as possible
				 * (for non-blocking reads) */

	int hit;		/* reusing a previous session */

	/* crypto */
	STACK_OF(SSL_CIPHER) *cipher_list_by_id;

	/* These are the ones being used, the ones in SSL_SESSION are
	 * the ones to be 'copied' into these ones */
	int mac_flags;

	SSL_AEAD_CTX *aead_read_ctx;	/* AEAD context. If non-NULL, then
					   enc_read_ctx and read_hash are
					   ignored. */

	SSL_AEAD_CTX *aead_write_ctx;	/* AEAD context. If non-NULL, then
					   enc_write_ctx and write_hash are
					   ignored. */

	EVP_CIPHER_CTX *enc_write_ctx;		/* cryptographic state */
	EVP_MD_CTX *write_hash;			/* used for mac generation */

	/* session info */

	/* extra application data */
	CRYPTO_EX_DATA ex_data;

	/* client cert? */
	/* for server side, keep the list of CA_dn we can use */
	STACK_OF(X509_NAME) *client_CA;

	/* set this flag to 1 and a sleep(1) is put into all SSL_read()
	 * and SSL_write() calls, good for nbio debuging :-) */
	int debug;
	long max_cert_list;
	int first_packet;

	int servername_done;	/* no further mod of servername
				   0 : call the servername extension callback.
				   1 : prepare 2, allow last ack just after in server callback.
				   2 : don't call servername callback, no ack in server hello
				   */

	/* Expect OCSP CertificateStatus message */
	int tlsext_status_expected;
	/* OCSP status request only */
	STACK_OF(OCSP_RESPID) *tlsext_ocsp_ids;
	X509_EXTENSIONS *tlsext_ocsp_exts;
	/* OCSP response received or to be sent */
	unsigned char *tlsext_ocsp_resp;
	int tlsext_ocsp_resplen;

	/* RFC4507 session ticket expected to be received or sent */
	int tlsext_ticket_expected;

	size_t tlsext_ecpointformatlist_length;
	uint8_t *tlsext_ecpointformatlist; /* our list */
	size_t tlsext_supportedgroups_length;
	uint16_t *tlsext_supportedgroups; /* our list */

	/* TLS Session Ticket extension override */
	TLS_SESSION_TICKET_EXT *tlsext_session_ticket;

	STACK_OF(SRTP_PROTECTION_PROFILE) *srtp_profiles;	/* What we'll do */
	SRTP_PROTECTION_PROFILE *srtp_profile;			/* What's been chosen */

	int renegotiate;/* 1 if we are renegotiating.
		 	 * 2 if we are a server and are inside a handshake
	                 * (i.e. not just sending a HelloRequest) */

	int state;	/* where we are */
	int rstate;	/* where we are when reading */

	int mac_packet;

	int empty_record_count;
} SSL_INTERNAL;

typedef struct ssl3_state_internal_st {
	int delay_buf_pop_ret;

	unsigned char read_sequence[SSL3_SEQUENCE_SIZE];
	int read_mac_secret_size;
	unsigned char read_mac_secret[EVP_MAX_MD_SIZE];
	unsigned char write_sequence[SSL3_SEQUENCE_SIZE];
	int write_mac_secret_size;
	unsigned char write_mac_secret[EVP_MAX_MD_SIZE];

	/* flags for countermeasure against known-IV weakness */
	int need_empty_fragments;
	int empty_fragment_done;

	SSL3_RECORD rrec;	/* each decoded record goes in here */
	SSL3_RECORD wrec;	/* goes out from here */

	/* storage for Alert/Handshake protocol data received but not
	 * yet processed by ssl3_read_bytes: */
	unsigned char alert_fragment[2];
	unsigned int alert_fragment_len;
	unsigned char handshake_fragment[4];
	unsigned int handshake_fragment_len;

	/* partial write - check the numbers match */
	unsigned int wnum;	/* number of bytes sent so far */
	int wpend_tot;		/* number bytes written */
	int wpend_type;
	int wpend_ret;		/* number of bytes submitted */
	const unsigned char *wpend_buf;

	/* used during startup, digest all incoming/outgoing packets */
	BIO *handshake_buffer;

	/* Rolling hash of handshake messages. */
	EVP_MD_CTX *handshake_hash;

	/* this is set whenerver we see a change_cipher_spec message
	 * come in when we are not looking for one */
	int change_cipher_spec;

	int warn_alert;
	int fatal_alert;

	/* This flag is set when we should renegotiate ASAP, basically when
	 * there is no more data in the read or write buffers */
	int renegotiate;
	int total_renegotiations;
	int num_renegotiations;

	int in_read_app_data;

	struct	{
		/* actually only needs to be 16+20 */
		unsigned char cert_verify_md[EVP_MAX_MD_SIZE*2];

		/* actually only need to be 16+20 for SSLv3 and 12 for TLS */
		unsigned char finish_md[EVP_MAX_MD_SIZE*2];
		int finish_md_len;
		unsigned char peer_finish_md[EVP_MAX_MD_SIZE*2];
		int peer_finish_md_len;

		unsigned long message_size;
		int message_type;

		/* used to hold the new cipher we are going to use */
		const SSL_CIPHER *new_cipher;
		DH *dh;

		EC_KEY *ecdh; /* holds short lived ECDH key */

		uint8_t *x25519;

		/* used when SSL_ST_FLUSH_DATA is entered */
		int next_state;

		int reuse_message;

		/* used for certificate requests */
		int cert_req;
		int ctype_num;
		char ctype[SSL3_CT_NUMBER];
		STACK_OF(X509_NAME) *ca_names;

		int key_block_length;
		unsigned char *key_block;

		const EVP_CIPHER *new_sym_enc;
		const EVP_AEAD *new_aead;
		const EVP_MD *new_hash;
		int new_mac_pkey_type;
		int cert_request;
	} tmp;

	/* Connection binding to prevent renegotiation attacks */
	unsigned char previous_client_finished[EVP_MAX_MD_SIZE];
	unsigned char previous_client_finished_len;
	unsigned char previous_server_finished[EVP_MAX_MD_SIZE];
	unsigned char previous_server_finished_len;
	int send_connection_binding; /* TODOEKR */

	/* Set if we saw the Next Protocol Negotiation extension from our peer.
	 */
	int next_proto_neg_seen;

	/*
	 * ALPN information
	 * (we are in the process of transitioning from NPN to ALPN).
	 */

	/*
	 * In a server these point to the selected ALPN protocol after the
	 * ClientHello has been processed. In a client these contain the
	 * protocol that the server selected once the ServerHello has been
	 * processed.
	 */
	unsigned char *alpn_selected;
	unsigned int alpn_selected_len;
} SSL3_STATE_INTERNAL;
#define S3I(s) (s->s3->internal)

typedef struct dtls1_state_internal_st {
	unsigned int send_cookie;
	unsigned char cookie[DTLS1_COOKIE_LENGTH];
	unsigned char rcvd_cookie[DTLS1_COOKIE_LENGTH];
	unsigned int cookie_len;

	/*
	 * The current data and handshake epoch.  This is initially
	 * undefined, and starts at zero once the initial handshake is
	 * completed
	 */
	unsigned short r_epoch;
	unsigned short w_epoch;

	/* records being received in the current epoch */
	DTLS1_BITMAP bitmap;

	/* renegotiation starts a new set of sequence numbers */
	DTLS1_BITMAP next_bitmap;

	/* handshake message numbers */
	unsigned short handshake_write_seq;
	unsigned short next_handshake_write_seq;

	unsigned short handshake_read_seq;

	/* save last sequence number for retransmissions */
	unsigned char last_write_sequence[8];

	/* Received handshake records (processed and unprocessed) */
	record_pqueue unprocessed_rcds;
	record_pqueue processed_rcds;

	/* Buffered handshake messages */
	struct _pqueue *buffered_messages;

	/* Buffered application records.
	 * Only for records between CCS and Finished
	 * to prevent either protocol violation or
	 * unnecessary message loss.
	 */
	record_pqueue buffered_app_data;

	/* Is set when listening for new connections with dtls1_listen() */
	unsigned int listen;

	unsigned int mtu; /* max DTLS packet size */

	struct hm_header_st w_msg_hdr;
	struct hm_header_st r_msg_hdr;

	struct dtls1_timeout_st timeout;

	/* storage for Alert/Handshake protocol data received but not
	 * yet processed by ssl3_read_bytes: */
	unsigned char alert_fragment[DTLS1_AL_HEADER_LENGTH];
	unsigned int alert_fragment_len;
	unsigned char handshake_fragment[DTLS1_HM_HEADER_LENGTH];
	unsigned int handshake_fragment_len;

	unsigned int retransmitting;
	unsigned int change_cipher_spec_ok;
} DTLS1_STATE_INTERNAL;
#define D1I(s) (s->d1->internal)

typedef struct cert_pkey_st {
	X509 *x509;
	EVP_PKEY *privatekey;
	/* Digest to use when signing */
	const EVP_MD *digest;
} CERT_PKEY;

typedef struct cert_st {
	/* Current active set */
	CERT_PKEY *key; /* ALWAYS points to an element of the pkeys array
			 * Probably it would make more sense to store
			 * an index, not a pointer. */

	/* The following masks are for the key and auth
	 * algorithms that are supported by the certs below */
	int valid;
	unsigned long mask_k;
	unsigned long mask_a;

	DH *dh_tmp;
	DH *(*dh_tmp_cb)(SSL *ssl, int is_export, int keysize);
	int dh_tmp_auto;

	EC_KEY *ecdh_tmp;
	EC_KEY *(*ecdh_tmp_cb)(SSL *ssl, int is_export, int keysize);
	int ecdh_tmp_auto;

	CERT_PKEY pkeys[SSL_PKEY_NUM];

	int references; /* >1 only if SSL_copy_session_id is used */
} CERT;


typedef struct sess_cert_st {
	STACK_OF(X509) *cert_chain; /* as received from peer */

	/* The 'peer_...' members are used only by clients. */
	int peer_cert_type;

	CERT_PKEY *peer_key; /* points to an element of peer_pkeys (never NULL!) */
	CERT_PKEY peer_pkeys[SSL_PKEY_NUM];
	/* Obviously we don't have the private keys of these,
	 * so maybe we shouldn't even use the CERT_PKEY type here. */

	DH *peer_dh_tmp;
	EC_KEY *peer_ecdh_tmp;
	uint8_t *peer_x25519_tmp;

	int references; /* actually always 1 at the moment */
} SESS_CERT;

/*#define SSL_DEBUG	*/
/*#define RSA_DEBUG	*/

typedef struct ssl3_enc_method {
	int (*enc)(SSL *, int);
	unsigned int enc_flags;
} SSL3_ENC_METHOD;

/*
 * Flag values for enc_flags.
 */

/* Uses explicit IV. */
#define SSL_ENC_FLAG_EXPLICIT_IV        (1 << 0)

/* Uses signature algorithms extension. */
#define SSL_ENC_FLAG_SIGALGS            (1 << 1)

/* Uses SHA256 default PRF. */
#define SSL_ENC_FLAG_SHA256_PRF         (1 << 2)

/* Allow TLS 1.2 ciphersuites: applies to DTLS 1.2 as well as TLS 1.2. */
#define SSL_ENC_FLAG_TLS1_2_CIPHERS     (1 << 4)

/*
 * ssl_aead_ctx_st contains information about an AEAD that is being used to
 * encrypt an SSL connection.
 */
struct ssl_aead_ctx_st {
	EVP_AEAD_CTX ctx;
	/*
	 * fixed_nonce contains any bytes of the nonce that are fixed for all
	 * records.
	 */
	unsigned char fixed_nonce[12];
	unsigned char fixed_nonce_len;
	unsigned char variable_nonce_len;
	unsigned char xor_fixed_nonce;
	unsigned char tag_len;
	/*
	 * variable_nonce_in_record is non-zero if the variable nonce
	 * for a record is included as a prefix before the ciphertext.
	 */
	char variable_nonce_in_record;
};

extern SSL_CIPHER ssl3_ciphers[];

const char *ssl_version_string(int ver);
int ssl_enabled_version_range(SSL *s, uint16_t *min_ver, uint16_t *max_ver);
int ssl_supported_version_range(SSL *s, uint16_t *min_ver, uint16_t *max_ver);
int ssl_max_shared_version(SSL *s, uint16_t peer_ver, uint16_t *max_ver);
uint16_t ssl_max_server_version(SSL *s);

const SSL_METHOD *dtls1_get_client_method(int ver);
const SSL_METHOD *dtls1_get_server_method(int ver);
const SSL_METHOD *tls1_get_client_method(int ver);
const SSL_METHOD *tls1_get_server_method(int ver);

extern SSL3_ENC_METHOD DTLSv1_enc_data;
extern SSL3_ENC_METHOD TLSv1_enc_data;
extern SSL3_ENC_METHOD TLSv1_1_enc_data;
extern SSL3_ENC_METHOD TLSv1_2_enc_data;

void ssl_clear_cipher_ctx(SSL *s);
int ssl_clear_bad_session(SSL *s);
CERT *ssl_cert_new(void);
CERT *ssl_cert_dup(CERT *cert);
int ssl_cert_inst(CERT **o);
void ssl_cert_free(CERT *c);
SESS_CERT *ssl_sess_cert_new(void);
void ssl_sess_cert_free(SESS_CERT *sc);
int ssl_get_new_session(SSL *s, int session);
int ssl_get_prev_session(SSL *s, unsigned char *session, int len,
    const unsigned char *limit);
int ssl_cipher_id_cmp(const SSL_CIPHER *a, const SSL_CIPHER *b);
SSL_CIPHER *OBJ_bsearch_ssl_cipher_id(SSL_CIPHER *key, SSL_CIPHER const *base, int num);
int ssl_cipher_ptr_id_cmp(const SSL_CIPHER * const *ap,
    const SSL_CIPHER * const *bp);
STACK_OF(SSL_CIPHER) *ssl_bytes_to_cipher_list(SSL *s, const unsigned char *p,
    int num);
int ssl_cipher_list_to_bytes(SSL *s, STACK_OF(SSL_CIPHER) *sk,
    unsigned char *p, size_t maxlen, size_t *outlen);
STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(const SSL_METHOD *meth,
    STACK_OF(SSL_CIPHER) **pref, STACK_OF(SSL_CIPHER) **sorted,
    const char *rule_str);
void ssl_update_cache(SSL *s, int mode);
int ssl_cipher_get_evp(const SSL_SESSION *s, const EVP_CIPHER **enc,
    const EVP_MD **md, int *mac_pkey_type, int *mac_secret_size);
int ssl_cipher_get_evp_aead(const SSL_SESSION *s, const EVP_AEAD **aead);
int ssl_get_handshake_evp_md(SSL *s, const EVP_MD **md);

int ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk);
int ssl_undefined_function(SSL *s);
int ssl_undefined_void_function(void);
int ssl_undefined_const_function(const SSL *s);
CERT_PKEY *ssl_get_server_send_pkey(const SSL *s);
X509 *ssl_get_server_send_cert(const SSL *);
EVP_PKEY *ssl_get_sign_pkey(SSL *s, const SSL_CIPHER *c, const EVP_MD **pmd);
DH *ssl_get_auto_dh(SSL *s);
int ssl_cert_type(X509 *x, EVP_PKEY *pkey);
void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher);
STACK_OF(SSL_CIPHER) *ssl_get_ciphers_by_id(SSL *s);
int ssl_verify_alarm_type(long type);
void ssl_load_ciphers(void);

const SSL_CIPHER *ssl3_get_cipher_by_char(const unsigned char *p);
int ssl3_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p);
int ssl3_send_server_certificate(SSL *s);
int ssl3_send_newsession_ticket(SSL *s);
int ssl3_send_cert_status(SSL *s);
int ssl3_get_finished(SSL *s, int state_a, int state_b);
int ssl3_send_change_cipher_spec(SSL *s, int state_a, int state_b);
int ssl3_do_write(SSL *s, int type);
int ssl3_send_alert(SSL *s, int level, int desc);
int ssl3_get_req_cert_type(SSL *s, unsigned char *p);
long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok);
int ssl3_send_finished(SSL *s, int a, int b, const char *sender, int slen);
int ssl3_num_ciphers(void);
const SSL_CIPHER *ssl3_get_cipher(unsigned int u);
const SSL_CIPHER *ssl3_get_cipher_by_id(unsigned int id);
const SSL_CIPHER *ssl3_get_cipher_by_value(uint16_t value);
uint16_t ssl3_cipher_get_value(const SSL_CIPHER *c);
int ssl3_renegotiate(SSL *ssl);

int ssl3_renegotiate_check(SSL *ssl);

int ssl3_dispatch_alert(SSL *s);
int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek);
int ssl3_write_bytes(SSL *s, int type, const void *buf, int len);
int ssl3_output_cert_chain(SSL *s, CBB *cbb, X509 *x);
SSL_CIPHER *ssl3_choose_cipher(SSL *ssl, STACK_OF(SSL_CIPHER) *clnt,
    STACK_OF(SSL_CIPHER) *srvr);
int	ssl3_setup_buffers(SSL *s);
int	ssl3_setup_init_buffer(SSL *s);
int	ssl3_setup_read_buffer(SSL *s);
int	ssl3_setup_write_buffer(SSL *s);
int	ssl3_release_read_buffer(SSL *s);
int	ssl3_release_write_buffer(SSL *s);
int	ssl3_new(SSL *s);
void	ssl3_free(SSL *s);
int	ssl3_accept(SSL *s);
int	ssl3_connect(SSL *s);
int	ssl3_read(SSL *s, void *buf, int len);
int	ssl3_peek(SSL *s, void *buf, int len);
int	ssl3_write(SSL *s, const void *buf, int len);
int	ssl3_shutdown(SSL *s);
void	ssl3_clear(SSL *s);
long	ssl3_ctrl(SSL *s, int cmd, long larg, void *parg);
long	ssl3_ctx_ctrl(SSL_CTX *s, int cmd, long larg, void *parg);
long	ssl3_callback_ctrl(SSL *s, int cmd, void (*fp)(void));
long	ssl3_ctx_callback_ctrl(SSL_CTX *s, int cmd, void (*fp)(void));
int	ssl3_pending(const SSL *s);

int ssl3_handshake_msg_hdr_len(SSL *s);
unsigned char *ssl3_handshake_msg_start(SSL *s, uint8_t htype);
void ssl3_handshake_msg_finish(SSL *s, unsigned int len);
int ssl3_handshake_msg_start_cbb(SSL *s, CBB *handshake, CBB *body,
    uint8_t msg_type);
int ssl3_handshake_msg_finish_cbb(SSL *s, CBB *handshake);
int ssl3_handshake_write(SSL *s);

void tls1_record_sequence_increment(unsigned char *seq);
int ssl3_do_change_cipher_spec(SSL *ssl);

int ssl23_read(SSL *s, void *buf, int len);
int ssl23_peek(SSL *s, void *buf, int len);
int ssl23_write(SSL *s, const void *buf, int len);
long ssl23_default_timeout(void);

long tls1_default_timeout(void);
int dtls1_do_write(SSL *s, int type);
int ssl3_packet_read(SSL *s, int plen);
int ssl3_packet_extend(SSL *s, int plen);
int ssl_server_legacy_first_packet(SSL *s);
int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek);
int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
    unsigned int len);
void dtls1_set_message_header(SSL *s, unsigned char mt, unsigned long len,
    unsigned long frag_off, unsigned long frag_len);

int dtls1_write_app_data_bytes(SSL *s, int type, const void *buf, int len);
int dtls1_write_bytes(SSL *s, int type, const void *buf, int len);

int dtls1_send_change_cipher_spec(SSL *s, int a, int b);
unsigned long dtls1_output_cert_chain(SSL *s, X509 *x);
int dtls1_read_failed(SSL *s, int code);
int dtls1_buffer_message(SSL *s, int ccs);
int dtls1_retransmit_message(SSL *s, unsigned short seq,
    unsigned long frag_off, int *found);
int dtls1_get_queue_priority(unsigned short seq, int is_ccs);
int dtls1_retransmit_buffered_messages(SSL *s);
void dtls1_clear_record_buffer(SSL *s);
int dtls1_get_message_header(unsigned char *data,
    struct hm_header_st *msg_hdr);
void dtls1_get_ccs_header(unsigned char *data, struct ccs_header_st *ccs_hdr);
void dtls1_reset_seq_numbers(SSL *s, int rw);
void dtls1_build_sequence_number(unsigned char *dst, unsigned char *seq,
    unsigned short epoch);
long dtls1_default_timeout(void);
struct timeval* dtls1_get_timeout(SSL *s, struct timeval* timeleft);
int dtls1_check_timeout_num(SSL *s);
int dtls1_handle_timeout(SSL *s);
const SSL_CIPHER *dtls1_get_cipher(unsigned int u);
void dtls1_start_timer(SSL *s);
void dtls1_stop_timer(SSL *s);
int dtls1_is_timer_expired(SSL *s);
void dtls1_double_timeout(SSL *s);
unsigned int dtls1_min_mtu(void);

/* some client-only functions */
int ssl3_client_hello(SSL *s);
int ssl3_get_server_hello(SSL *s);
int ssl3_get_certificate_request(SSL *s);
int ssl3_get_new_session_ticket(SSL *s);
int ssl3_get_cert_status(SSL *s);
int ssl3_get_server_done(SSL *s);
int ssl3_send_client_verify(SSL *s);
int ssl3_send_client_certificate(SSL *s);
int ssl_do_client_cert_cb(SSL *s, X509 **px509, EVP_PKEY **ppkey);
int ssl3_send_client_key_exchange(SSL *s);
int ssl3_get_server_key_exchange(SSL *s);
int ssl3_get_server_certificate(SSL *s);
int ssl3_check_cert_and_algorithm(SSL *s);
int ssl3_check_finished(SSL *s);
int ssl3_send_next_proto(SSL *s);

/* some server-only functions */
int ssl3_get_client_hello(SSL *s);
int ssl3_send_server_hello(SSL *s);
int ssl3_send_hello_request(SSL *s);
int ssl3_send_server_key_exchange(SSL *s);
int ssl3_send_certificate_request(SSL *s);
int ssl3_send_server_done(SSL *s);
int ssl3_get_client_certificate(SSL *s);
int ssl3_get_client_key_exchange(SSL *s);
int ssl3_get_cert_verify(SSL *s);
int ssl3_get_next_proto(SSL *s);

int ssl23_accept(SSL *s);
int ssl23_connect(SSL *s);
int ssl23_read_bytes(SSL *s, int n);
int ssl23_write_bytes(SSL *s);

int tls1_new(SSL *s);
void tls1_free(SSL *s);
void tls1_clear(SSL *s);

int dtls1_new(SSL *s);
int dtls1_accept(SSL *s);
int dtls1_connect(SSL *s);
void dtls1_free(SSL *s);
void dtls1_clear(SSL *s);
long dtls1_ctrl(SSL *s, int cmd, long larg, void *parg);
int dtls1_shutdown(SSL *s);

long dtls1_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok);
int dtls1_get_record(SSL *s);
int dtls1_dispatch_alert(SSL *s);
int dtls1_enc(SSL *s, int snd);

int ssl_init_wbio_buffer(SSL *s, int push);
void ssl_free_wbio_buffer(SSL *s);

int tls1_handshake_hash_init(SSL *s);
int tls1_handshake_hash_update(SSL *s, const unsigned char *buf, size_t len);
int tls1_handshake_hash_value(SSL *s, const unsigned char *out, size_t len,
    size_t *outlen);
void tls1_handshake_hash_free(SSL *s);

int tls1_init_finished_mac(SSL *s);
int tls1_finish_mac(SSL *s, const unsigned char *buf, int len);
void tls1_free_digest_list(SSL *s);
void tls1_cleanup_key_block(SSL *s);
int tls1_digest_cached_records(SSL *s);
int tls1_change_cipher_state(SSL *s, int which);
int tls1_setup_key_block(SSL *s);
int tls1_enc(SSL *s, int snd);
int tls1_final_finish_mac(SSL *s, const char *str, int slen, unsigned char *p);
int tls1_mac(SSL *ssl, unsigned char *md, int snd);
int tls1_generate_master_secret(SSL *s, unsigned char *out,
    unsigned char *p, int len);
int tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,
    const char *label, size_t llen, const unsigned char *p, size_t plen,
    int use_context);
int tls1_alert_code(int code);
int ssl_ok(SSL *s);

int ssl_check_srvr_ecc_cert_and_alg(X509 *x, SSL *s);

int tls1_set_groups(uint16_t **out_group_ids, size_t *out_group_ids_len,
    const int *groups, size_t ngroups);
int tls1_set_groups_list(uint16_t **out_group_ids, size_t *out_group_ids_len,
    const char *groups);

int tls1_ec_curve_id2nid(const uint16_t curve_id);
uint16_t tls1_ec_nid2curve_id(const int nid);
int tls1_check_curve(SSL *s, const uint16_t curve_id);
int tls1_get_shared_curve(SSL *s);

unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *p,
    unsigned char *limit);

unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p,
    unsigned char *limit);

int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **data,
    unsigned char *d, int n, int *al);
int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **data,
    size_t n, int *al);
int ssl_check_clienthello_tlsext_early(SSL *s);
int ssl_check_clienthello_tlsext_late(SSL *s);
int ssl_check_serverhello_tlsext(SSL *s);

#define tlsext_tick_md	EVP_sha256
int tls1_process_ticket(SSL *s, const unsigned char *session_id, int len,
    const unsigned char *limit, SSL_SESSION **ret);
int tls12_get_sigandhash(unsigned char *p, const EVP_PKEY *pk,
    const EVP_MD *md);
int tls12_get_sigid(const EVP_PKEY *pk);
const EVP_MD *tls12_get_hash(unsigned char hash_alg);

void ssl_clear_hash_ctx(EVP_MD_CTX **hash);
int ssl_add_serverhello_renegotiate_ext(SSL *s, unsigned char *p,
    int *len, int maxlen);
int ssl_parse_serverhello_renegotiate_ext(SSL *s, const unsigned char *d,
    int len, int *al);
int ssl_add_clienthello_renegotiate_ext(SSL *s, unsigned char *p,
    int *len, int maxlen);
int ssl_parse_clienthello_renegotiate_ext(SSL *s, const unsigned char *d,
    int len, int *al);
long ssl_get_algorithm2(SSL *s);
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize);
int tls12_get_req_sig_algs(SSL *s, unsigned char *p);

int tls1_check_ec_server_key(SSL *s);
int tls1_check_ec_tmp_key(SSL *s);

int ssl_add_clienthello_use_srtp_ext(SSL *s, unsigned char *p,
    int *len, int maxlen);
int ssl_parse_clienthello_use_srtp_ext(SSL *s, const unsigned char *d,
    int len, int *al);
int ssl_add_serverhello_use_srtp_ext(SSL *s, unsigned char *p,
    int *len, int maxlen);
int ssl_parse_serverhello_use_srtp_ext(SSL *s, const unsigned char *d,
    int len, int *al);

/* s3_cbc.c */
void ssl3_cbc_copy_mac(unsigned char *out, const SSL3_RECORD *rec,
    unsigned md_size, unsigned orig_len);
int tls1_cbc_remove_padding(const SSL *s, SSL3_RECORD *rec,
    unsigned block_size, unsigned mac_size);
char ssl3_cbc_record_digest_supported(const EVP_MD_CTX *ctx);
int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, unsigned char *md_out,
    size_t *md_out_size, const unsigned char header[13],
    const unsigned char *data, size_t data_plus_mac_size,
    size_t data_plus_mac_plus_padding_size, const unsigned char *mac_secret,
    unsigned mac_secret_length);
int SSL_state_func_code(int _state);

#define SSLerror(s, r)  ERR_PUT_error(ERR_LIB_SSL,			\
    (SSL_state_func_code(s->internal->state)),(r),__FILE__,__LINE__)
#define SSLerrorx(r) ERR_PUT_error(ERR_LIB_SSL,(0xfff),(r),__FILE__,__LINE__)

__END_HIDDEN_DECLS

#endif
@


1.177
log
@Provide a rolling handshake hash that commences as soon as the cipher
suite has been selected, and convert the final finish MAC to use this
handshake hash.

This is a first step towards cleaning up the current handshake
buffer/digest code.

ok beck@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.176 2017/03/04 16:32:00 jsing Exp $ */
a807 4
	/* When set of handshake digests is determined, buffer is hashed
	 * and freed and MD_CTX-es for all required digests are stored in
	 * this array */
	EVP_MD_CTX **handshake_dgst;
a1101 1
int ssl_get_handshake_digest(int i, long *mask, const EVP_MD **md);
a1290 1
int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *p);
@


1.176
log
@Drop the second argument of dtls1_set_message_header() and make it a void
function. Nothing makes use of the return value and the second argument
was only used to produce the return value...
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.175 2017/02/28 14:08:49 jsing Exp $ */
d262 7
a268 6
#define SSL_HANDSHAKE_MAC_MD5 0x10
#define SSL_HANDSHAKE_MAC_SHA 0x20
#define SSL_HANDSHAKE_MAC_GOST94 0x40
#define SSL_HANDSHAKE_MAC_SHA256 0x80
#define SSL_HANDSHAKE_MAC_SHA384 0x100
#define SSL_HANDSHAKE_MAC_STREEBOG256 0x200
d812 4
d1107 1
d1280 6
@


1.175
log
@Stop pretending that MD5 and SHA1 might not exist - rather than locating
"ssl3-md5" and "ssl-sha1", call the EVP_md5() and EVP_sha1() functions
directly.

ok beck@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.174 2017/02/21 15:28:27 jsing Exp $ */
d1189 2
a1190 3
unsigned char *dtls1_set_message_header(SSL *s, unsigned char *p,
    unsigned char mt, unsigned long len, unsigned long frag_off,
    unsigned long frag_len);
@


1.174
log
@Remove STREEBOG 512 as a TLS MAC since there are currently no cipher suites
that make use of it.

ok bcook@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.173 2017/02/07 02:08:38 beck Exp $ */
a532 3

	const EVP_MD *md5;	/* For SSLv3/TLSv1 'ssl3-md5' */
	const EVP_MD *sha1;	/* For SSLv3/TLSv1 'ssl3-sha1' */
@


1.173
log
@Change SSLerror() back to taking two args, with the first one being an SSL *.
Make a table of "function codes" which maps the internal state of the SSL *
to something like a useful name so in a typical error in the connection you
know in what sort of place in the handshake things happened. (instead of
by arcane function name).
Add SSLerrorx() for when we don't have an SSL *
ok jsing@@ after us both being prodded by bluhm@@ to make it not terrible
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.172 2017/01/26 10:40:21 beck Exp $ */
a252 1
#define SSL_STREEBOG512		0x00000100L
a267 1
#define SSL_HANDSHAKE_MAC_STREEBOG512 0x400
d272 1
a272 1
#define SSL_MAX_DIGEST 8
@


1.172
log
@Send the error function codes to rot in the depths of hell where they belong
We leave a single funciton code (0xFFF) to say "SSL_internal" so the public
API will not break, and we replace all internal use of the two argument
SSL_err() with the internal only SSL_error() that only takes a reason code.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.171 2017/01/26 07:20:57 beck Exp $ */
d1370 1
d1372 3
a1374 1
#define SSLerror(r)  ERR_PUT_error(ERR_LIB_SSL,(0xfff),(r),__FILE__,__LINE__)
@


1.171
log
@Limit the number of sequential empty records that we will process
before yielding, and fail if we exceed a maximum. loosely based
on what boring and openssl are doing
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.170 2017/01/26 06:32:58 jsing Exp $ */
d1370 2
@


1.170
log
@Remove most of SSL3_ENC_METHOD - we can just inline the function calls
and defines since they are the same everywhere.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.169 2017/01/26 05:31:25 jsing Exp $ */
d355 2
d775 2
@


1.169
log
@Merge the client/server version negotiation into the existing (currently
fixed version) client/server code.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.168 2017/01/26 00:42:44 jsing Exp $ */
a1014 3
/* This is for the SSLv3/TLSv1.0 differences in crypto/hash stuff
 * It is a bit of a mess of functions, but hell, think of it as
 * an opaque structure :-) */
a1016 17
	int (*mac)(SSL *, unsigned char *, int);
	int (*setup_key_block)(SSL *);
	int (*generate_master_secret)(SSL *, unsigned char *,
	    unsigned char *, int);
	int (*change_cipher_state)(SSL *, int);
	int (*final_finish_mac)(SSL *,  const char *, int, unsigned char *);
	int finish_mac_length;
	int (*cert_verify_mac)(SSL *, int, unsigned char *);
	const char *client_finished_label;
	int client_finished_label_len;
	const char *server_finished_label;
	int server_finished_label_len;
	int (*alert_value)(int);
	int (*export_keying_material)(SSL *, unsigned char *, size_t,
	    const char *, size_t, const unsigned char *, size_t,
	    int use_context);
	/* Flags indicating protocol version requirements. */
@


1.168
log
@Remove ssl3_undef_enc_method - if we have internal bugs we want to segfault
so that we can debug it, rather than adding a "should not be called" error
to the stack.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.167 2017/01/25 10:54:23 jsing Exp $ */
d772 1
d1086 5
d1206 1
@


1.167
log
@Limit enabled version range by the versions configured on the SSL_CTX/SSL,
provide an ssl_supported_versions_range() function which also limits the
versions to those supported by the current method.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.166 2017/01/25 06:38:01 jsing Exp $ */
a1076 1
extern SSL3_ENC_METHOD ssl3_undef_enc_method;
@


1.166
log
@Change the SSL_IS_DTLS() macro to check the version, rather than using a
flag in the encryption methods. We can do this since there is currently
only one DTLS version. This makes upcoming changes easier.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.165 2017/01/25 06:13:02 jsing Exp $ */
d1082 1
@


1.165
log
@Provide ssl3_packet_read() and ssl3_packet_extend() functions that improve
the awkward API provided by ssl3_read_n(). Call these when we need to
read or extend a packet.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.164 2017/01/24 09:03:21 jsing Exp $ */
d331 1
a331 1
	(s->method->internal->ssl3_enc->enc_flags & SSL_ENC_FLAG_DTLS)
a1050 3

/* Is DTLS. */
#define SSL_ENC_FLAG_DTLS               (1 << 3)
@


1.164
log
@Add support for setting the supported EC curves via
SSL{_CTX}_set1_groups{_list}() - also provide defines for the previous
SSL{_CTX}_set1_curves{_list} names.

This also changes the default list of EC curves to be X25519, P-256 and
P-384. If you want others (such a brainpool) you need to configure this
yourself.

Inspired by parts of BoringSSL and OpenSSL.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.163 2017/01/23 22:34:38 beck Exp $ */
d1201 2
a1202 1
int ssl3_read_n(SSL *s, int n, int max, int extend);
@


1.163
log
@move default_passwd_cb and default_passwd_cb_userdata back into
the ssl_ctx from internal - these are used directly by python
and openvpn and a few other things - we have the set accessors
but the get accessors were added in 1.1 and these roll their
own caveat OPENSSL_VERSION chickenpluckery
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.162 2017/01/23 14:35:42 jsing Exp $ */
d428 2
a429 2
	size_t tlsext_ellipticcurvelist_length;
	uint16_t *tlsext_ellipticcurvelist; /* peer's list */
d606 5
d753 1
d756 2
a757 2
	size_t tlsext_ellipticcurvelist_length;
	uint16_t *tlsext_ellipticcurvelist; /* our list */
d1312 5
@


1.162
log
@Move options and mode from SSL_CTX and SSL to internal, since these can be
set and cleared via existing functions.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.161 2017/01/23 13:36:13 jsing Exp $ */
a455 6

	/* Default password callback. */
	pem_password_cb *default_passwd_callback;

	/* Default password callback user data. */
	void *default_passwd_callback_userdata;
@


1.161
log
@Split most of SSL_METHOD out into an internal variant, which is opaque.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.160 2017/01/23 08:48:44 beck Exp $ */
d437 3
d617 3
@


1.160
log
@send state and rstate from ssl_st into internal. There are accessors
so these should not be diddled with directly
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.159 2017/01/23 08:08:06 beck Exp $ */
d330 2
a331 1
#define SSL_IS_DTLS(s) (s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_DTLS)
d335 1
a335 1
	(s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_EXPLICIT_IV)
d339 1
a339 1
	(s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_SIGALGS)
d343 1
a343 1
	(s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_TLS1_2_CIPHERS)
d375 35
@


1.159
log
@move back read_hash and enc_read_ctx into ssl_st. wpa_supplicant and
other perversions touches them sickly and unnaturally.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.158 2017/01/23 06:45:30 beck Exp $ */
d726 4
@


1.158
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.157 2017/01/23 05:27:22 jsing Exp $ */
a671 3

	EVP_CIPHER_CTX *enc_read_ctx;		/* cryptographic state */
	EVP_MD_CTX *read_hash;			/* used for mac generation */
@


1.157
log
@Move ex_data, next and prev from SSL_SESSION to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.156 2017/01/23 05:13:02 jsing Exp $ */
d623 106
@


1.156
log
@Move most of the fields in SSL_CTX to internal - the ones that remain are
known to be in use.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.155 2017/01/23 04:55:27 beck Exp $ */
d376 6
@


1.155
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.154 2017/01/23 04:15:28 jsing Exp $ */
d454 15
d487 41
@


1.154
log
@Move callback function pointers and argument pointers from SSL_CTX to
internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.153 2017/01/23 01:22:08 jsing Exp $ */
d530 31
@


1.153
log
@Move not_resumable and sess_cert from SSL_SESSION to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.152 2017/01/23 00:12:55 jsing Exp $ */
d394 59
@


1.152
log
@Move the stats struct from SSL_CTX to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.151 2017/01/22 09:02:07 jsing Exp $ */
d376 8
@


1.151
log
@Move most of the SSL3_STATE fields to internal - the ones that remain are
known to be used by ports.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.150 2017/01/22 07:16:39 beck Exp $ */
d387 19
a443 1

@


1.150
log
@Move most of DTLS1_STATE to internal.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.149 2017/01/22 06:36:49 jsing Exp $ */
d448 1
d450 115
d566 1
a682 1

@


1.149
log
@Move ALPN and NPN fields from SSL/SSL_CTX to internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.148 2017/01/22 05:14:42 beck Exp $ */
d452 4
d457 56
d514 1
@


1.148
log
@Move internal parts of ssl_session_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.147 2017/01/22 04:07:44 jsing Exp $ */
d386 40
d431 14
@


1.147
log
@Move recently added min_version/max_version from SSL and SSL_CTX to their
opaque structs.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.146 2017/01/22 03:50:45 jsing Exp $ */
d376 4
a379 1

d381 1
@


1.146
log
@Convert publically visible structs to translucent structs.

This change adds an internal opaque struct for each of the significant
publically visible structs. The opaque struct is then allocated and
attached to the publically visible struct when the appropriate *_new()
function is called, then cleared and freed as necessary.

This will allow for changes to be made to the internals of libssl, without
requiring a major bump each time the publically visible structs are
modified.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.145 2017/01/21 04:18:18 jsing Exp $ */
d380 2
a381 1

d385 2
a386 1

@


1.145
log
@Expand DECLARE_OBJ_BSEARCH_GLOBAL_CMP_FN macro.

No change in preprocessor output (ignoring whitespace and line numbers).
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.144 2017/01/03 16:57:15 jsing Exp $ */
d374 20
@


1.144
log
@Pull out, rework and dedup the code that determines the highest shared
version.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.143 2016/12/30 16:57:01 jsing Exp $ */
d521 1
a521 1
DECLARE_OBJ_BSEARCH_GLOBAL_CMP_FN(SSL_CIPHER, SSL_CIPHER, ssl_cipher_id);
@


1.143
log
@Pull out (and largely rewrite) the code that determines the enabled
protocol version range.

This also fixes a bug whereby if all protocols were disabled, the client
would still use TLSv1.2 in the client hello, only to have if fail with
unsupported version when it received and processed the server hello.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.142 2016/12/30 15:12:45 jsing Exp $ */
d501 1
@


1.142
log
@Remove now unused c2l, c2ln, l2c, n2l, l2cn and n2l3 macros.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.141 2016/12/21 16:44:31 jsing Exp $ */
d500 1
@


1.141
log
@Add support for ECDHE with X25519.

Testing of an earlier revision by naddy@@.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.140 2016/12/18 13:52:53 jsing Exp $ */
a166 31
#define c2l(c,l)	(l = ((unsigned long)(*((c)++)))     , \
			 l|=(((unsigned long)(*((c)++)))<< 8), \
			 l|=(((unsigned long)(*((c)++)))<<16), \
			 l|=(((unsigned long)(*((c)++)))<<24))

/* NOTE - c is not incremented as per c2l */
#define c2ln(c,l1,l2,n)	{ \
			c+=n; \
			l1=l2=0; \
			switch (n) { \
			case 8: l2 =((unsigned long)(*(--(c))))<<24; \
			case 7: l2|=((unsigned long)(*(--(c))))<<16; \
			case 6: l2|=((unsigned long)(*(--(c))))<< 8; \
			case 5: l2|=((unsigned long)(*(--(c))));     \
			case 4: l1 =((unsigned long)(*(--(c))))<<24; \
			case 3: l1|=((unsigned long)(*(--(c))))<<16; \
			case 2: l1|=((unsigned long)(*(--(c))))<< 8; \
			case 1: l1|=((unsigned long)(*(--(c))));     \
				} \
			}

#define l2c(l,c)	(*((c)++)=(unsigned char)(((l)    )&0xff), \
			 *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>16)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>24)&0xff))

#define n2l(c,l)	(l =((unsigned long)(*((c)++)))<<24, \
			 l|=((unsigned long)(*((c)++)))<<16, \
			 l|=((unsigned long)(*((c)++)))<< 8, \
			 l|=((unsigned long)(*((c)++))))

a180 15
/* NOTE - c is not incremented as per l2c */
#define l2cn(l1,l2,c,n)	{ \
			c+=n; \
			switch (n) { \
			case 8: *(--(c))=(unsigned char)(((l2)>>24)&0xff); \
			case 7: *(--(c))=(unsigned char)(((l2)>>16)&0xff); \
			case 6: *(--(c))=(unsigned char)(((l2)>> 8)&0xff); \
			case 5: *(--(c))=(unsigned char)(((l2)    )&0xff); \
			case 4: *(--(c))=(unsigned char)(((l1)>>24)&0xff); \
			case 3: *(--(c))=(unsigned char)(((l1)>>16)&0xff); \
			case 2: *(--(c))=(unsigned char)(((l1)>> 8)&0xff); \
			case 1: *(--(c))=(unsigned char)(((l1)    )&0xff); \
				} \
			}

a184 4

#define n2l3(c,l)	((l =(((unsigned long)(c[0]))<<16)| \
			     (((unsigned long)(c[1]))<< 8)| \
			     (((unsigned long)(c[2]))    )),c+=3)
@


1.140
log
@Convert ssl3_get_server_hello() to CBS.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.139 2016/12/06 13:38:11 jsing Exp $ */
d471 1
@


1.139
log
@Now that ssl3_send_{client,server}_certificate() are using the common
handshake functions, we can remove more copied code from DTLS.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.138 2016/12/06 13:17:52 jsing Exp $ */
d790 1
a790 1
    unsigned char *d, int n, int *al);
@


1.138
log
@Convert certificate handshake message generation to CBB, with some clean
up and restructure.

This also adds CBB based variants of the ssl3_handshake_msg_{start,finish}
functions - for the time being these use a CBB to build the messages, then
copy back into the init_buf.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.137 2016/12/04 14:32:30 jsing Exp $ */
a717 2
int dtls1_send_client_certificate(SSL *s);

a728 2

int dtls1_send_server_certificate(SSL *s);
@


1.137
log
@Convert ssl_cipher_list_to_bytes() to CBB, changing the function to return
the number of bytes written via an explicit *outlen argument and retaining
the return value to indicate success or failure.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.136 2016/11/06 17:21:04 jsing Exp $ */
d163 2
d622 1
a622 1
unsigned long ssl3_output_cert_chain(SSL *s, X509 *x);
d649 3
@


1.136
log
@Remove unused SSLv3 from ssl3_cbc_record_digest_supported().

From Markus Uhlin <markus.uhlin at bredband dot net>

ok beck@@ bcooK@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.135 2016/11/05 08:26:36 jsing Exp $ */
d572 1
a572 1
    unsigned char *p);
@


1.135
log
@Convert ssl3_get_server_kex_ecdhe() to CBS, simplifying tls1_check_curve()
in the process. This also fixes a long standing bug where
tls1_ec_curve_id2nid() is called with only one byte of the curve ID.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.134 2016/11/04 19:11:43 jsing Exp $ */
d837 1
a837 1
    unsigned mac_secret_length, char is_sslv3);
@


1.134
log
@Rename ssl3_get_key_exchange() to ssl3_get_server_key_exchange(), since
that's what it really is.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.133 2016/11/04 18:28:58 guenther Exp $ */
d775 3
a777 3
int tls1_ec_curve_id2nid(uint16_t curve_id);
uint16_t tls1_ec_nid2curve_id(int nid);
int tls1_check_curve(SSL *s, const unsigned char *p, size_t len);
@


1.133
log
@Add an explict list of exported symbols with just the functions
declared in the public headers, and use __{BEGIN,END}_HIDDEN_DECLS
in the internal headers to optimize internal functions

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.132 2016/11/04 18:00:12 guenther Exp $ */
d707 1
a707 1
int ssl3_get_key_exchange(SSL *s);
@


1.132
log
@Make do_dtls1_write() static to d1_pkt.c and delete declarations for
three functions that were removed a while ago

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.131 2016/11/03 08:15:22 jsing Exp $ */
d163 2
d838 2
@


1.131
log
@Clean up the TLS handshake digest handling - this refactors some of the
code for improved readability, however it also address two issues.

The first of these is a hard-to-hit double free that will occur if
EVP_DigestInit_ex() fails. To avoid this and to be more robust, ensure
that tls1_digest_cached_records() either completes successfully and sets
up all of the necessary digests, or it cleans up and frees everything
that was allocated.

The second issue is that EVP_DigestUpdate() can fail - detect and handle
this in tls1_finish_mac() and change the return type to an int so that a
failure can be propagated to the caller (the callers still need to be
fixed to handle this, in a later diff).

The double-free was reported by Matthew Dillon.

ok beck@@ doug@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.130 2016/10/19 16:38:40 jsing Exp $ */
a734 2
long tls1_ctrl(SSL *s, int cmd, long larg, void *parg);
long tls1_callback_ctrl(SSL *s, int cmd, void (*fp)(void));
a745 2
int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
    unsigned int len);
a771 2

SSL_COMP *ssl3_comp_find(STACK_OF(SSL_COMP) *sk, int n);
@


1.130
log
@Remove support for fixed ECDH cipher suites - these is not widely supported
and more importantly they do not provide PFS (if you want to use ECDH, use
ECDHE instead).

With input from guenther@@.

ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.129 2016/04/28 16:39:45 jsing Exp $ */
d757 1
a757 1
void tls1_finish_mac(SSL *s, const unsigned char *buf, int len);
@


1.129
log
@Implement the IETF ChaCha20-Poly1305 cipher suites.

Rename the existing ChaCha20-Poly1305 cipher suites with an "-OLD" suffix,
effectively replaces the original Google implementation. We continue to
support both the IETF and Google versions, however the existing names
now refer to the ciphers from draft-ietf-tls-chacha20-poly1305-04.

Feedback from doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.128 2015/09/12 15:08:54 jsing Exp $ */
a257 2
#define SSL_kECDHr		0x00000020L /* ECDH cert, RSA CA cert */
#define SSL_kECDHe		0x00000040L /* ECDH cert, ECDSA CA cert */
a264 1
#define SSL_aECDH 		0x00000010L /* Fixed ECDH auth (kECDHe or kECDHr) */
a266 1

@


1.128
log
@Uncopy and unpaste dtls1_send_newsession_ticket() - another 111 lines of
code deduped.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.127 2015/09/12 15:03:39 jsing Exp $ */
d286 1
d533 1
a533 1
	unsigned char fixed_nonce[8];
d536 1
@


1.127
log
@Move handshake message header length determination into a separate
ssl3_handshake_msg_hdr_len() function. Use this to correct several places
that have magic numbers with header lengths hardcoded as '4'.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.126 2015/09/12 14:32:24 jsing Exp $ */
a693 1
int dtls1_send_newsession_ticket(SSL *s);
@


1.126
log
@Uncopy and unpaste dtls1_send_certificate_request() - removes another 80
lines of code, while gaining SIGALGs support.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.125 2015/09/12 14:28:23 jsing Exp $ */
d644 1
@


1.125
log
@Uncopy and unpaste dtls1_send_server_key_exchange(). Removes another 329
lines of code, while gaining bug fixes and SIGALGs support.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.124 2015/09/12 13:35:34 jsing Exp $ */
a727 1
int dtls1_send_certificate_request(SSL *s);
@


1.124
log
@Uncopy and unpaste dtls1_send_server_done().
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.123 2015/09/12 13:25:26 jsing Exp $ */
a727 1
int dtls1_send_server_key_exchange(SSL *s);
@


1.123
log
@Uncopy and unpaste dtls1_send_server_hello().
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.122 2015/09/12 13:09:07 jsing Exp $ */
a729 1
int dtls1_send_server_done(SSL *s);
@


1.122
log
@Uncopy and unpaste dtls1_send_hello_request().
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.121 2015/09/12 12:58:15 jsing Exp $ */
a726 1
int dtls1_send_server_hello(SSL *s);
@


1.121
log
@Uncopy and unpaste dtls1_send_client_verify() - the
ssl3_send_client_verify() is different, but it correctly supports things
like SIGALGS. Another 74 lines of code bites the dust.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.120 2015/09/12 12:26:56 jsing Exp $ */
a726 1
int dtls1_send_hello_request(SSL *s);
@


1.120
log
@Uncopy and unpaste dtls1_send_client_key_exchange() - the
ssl3_send_client_key_exchange() is effectively identical, in fact it has
a number of bug fixes and improvements that never got merged into the
DTLS copy of the code. Flenses another 264 lines of code.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.119 2015/09/11 18:08:21 jsing Exp $ */
a713 1
int dtls1_send_client_verify(SSL *s);
@


1.119
log
@Rename functions that moved to t1_enc.c, with a tls1_ prefix instead of a
ssl3_ prefix.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.118 2015/09/11 17:37:47 jsing Exp $ */
a713 1
int dtls1_send_client_key_exchange(SSL *s);
@


1.118
log
@Nuke ssl_set_peer_cert_type().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.117 2015/09/11 17:35:36 jsing Exp $ */
a597 1
int ssl3_init_finished_mac(SSL *s);
a602 1
void ssl3_cleanup_key_block(SSL *s);
a619 2
void ssl3_finish_mac(SSL *s, const unsigned char *buf, int len);
void ssl3_free_digest_list(SSL *s);
a628 1
int	ssl3_digest_cached_records(SSL *s);
d648 1
a648 1
void ssl3_record_sequence_increment(unsigned char *seq);
d765 5
@


1.117
log
@Nuke ssl_bad_method().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.116 2015/09/11 17:32:23 jsing Exp $ */
a561 1
int ssl_set_peer_cert_type(SESS_CERT *c, int type);
@


1.116
log
@Nuke ssl3_default_timeout().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.115 2015/09/11 17:29:36 jsing Exp $ */
a545 1
SSL_METHOD *ssl_bad_method(int ver);
@


1.115
log
@Nuke ssl_replace_hash().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.114 2015/09/11 17:17:44 jsing Exp $ */
a656 1
long ssl3_default_timeout(void);
@


1.114
log
@Nuke ssl3_cbc_remove_padding().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.113 2015/09/11 17:11:53 jsing Exp $ */
a817 1
EVP_MD_CTX* ssl_replace_hash(EVP_MD_CTX **hash, const EVP_MD *md);
@


1.113
log
@Nuke ssl3_alert_code().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.112 2015/09/11 17:08:50 jsing Exp $ */
a846 2
int ssl3_cbc_remove_padding(const SSL *s, SSL3_RECORD *rec,
    unsigned block_size, unsigned mac_size);
@


1.112
log
@Nuke ssl3_cert_verify_mac() and ssl3_handshake_mac().

We also no longer need the ssl3_pad_1 and ssl3_pad_2 arrays...

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.111 2015/09/11 17:04:39 jsing Exp $ */
a784 1
int ssl3_alert_code(int code);
@


1.111
log
@Nuke ssl3_final_finish_mac().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.110 2015/09/11 17:03:03 jsing Exp $ */
a623 1
int ssl3_cert_verify_mac(SSL *s, int md_nid, unsigned char *p);
@


1.110
log
@Nuke ssl3_change_cipher_state().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.109 2015/09/11 17:01:19 jsing Exp $ */
a623 2
int ssl3_final_finish_mac(SSL *s, const char *sender, int slen,
    unsigned char *p);
@


1.109
log
@Nuke ssl3_generate_master_secret().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.108 2015/09/11 16:59:17 jsing Exp $ */
a605 1
int ssl3_change_cipher_state(SSL *s, int which);
@


1.108
log
@Nuke ssl3_setup_key_block() and ssl3_generate_key_block().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.107 2015/09/11 16:56:17 jsing Exp $ */
a609 2
int ssl3_generate_master_secret(SSL *s, unsigned char *out,
    unsigned char *p, int len);
@


1.107
log
@Nuke n_ssl3_mac().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.106 2015/09/11 16:53:51 jsing Exp $ */
a604 1
int ssl3_setup_key_block(SSL *s);
@


1.106
log
@Nuke ssl3_enc().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.105 2015/09/11 16:50:46 jsing Exp $ */
a631 1
int n_ssl3_mac(SSL *ssl, unsigned char *md, int send_data);
@


1.105
log
@Nuke SSLv3_enc_data.

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.104 2015/09/11 16:28:37 jsing Exp $ */
a631 1
int ssl3_enc(SSL *s, int send_data);
@


1.104
log
@Replace dtls1_send_finished() with ssl3_send_finished() - they're now
both essentially the same (in fact DTLS benefits from improvements
previously made to the ssl3_send_finished() function).

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.103 2015/09/02 17:59:15 jsing Exp $ */
d550 1
a553 2
extern SSL3_ENC_METHOD SSLv3_enc_data;
extern SSL3_ENC_METHOD DTLSv1_enc_data;
@


1.103
log
@Replace dtls1_client_hello() with ssl3_client_hello() - both are basically
the same code, with two slight differences for DTLS handling.

Also, make use of send_cookie to determine if the client random needs to
be preserved, rather than testing if it is zeroed (hopefully your random
number generator never returned all zeros, since the existing code would
break). Inspired by BoringSSL.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.102 2015/09/01 13:38:27 jsing Exp $ */
a687 1
int dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen);
@


1.102
log
@Remove the ssl_prepare_{client,server}hello_tlsext() functions, which are
now nothing more than noops.

ok bcook@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.101 2015/08/29 17:15:52 doug Exp $ */
a731 1
int dtls1_client_hello(SSL *s);
@


1.101
log
@Now that SSLv3 is going away, TLS_* and SSLv23 are equivalent.

Remove the TLS method data and tls_any_* functions.  Point to SSLv23.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.100 2015/07/24 07:57:48 doug Exp $ */
a818 2
int ssl_prepare_clienthello_tlsext(SSL *s);
int ssl_prepare_serverhello_tlsext(SSL *s);
@


1.100
log
@Convert tls1_process_ticket to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.99 2015/07/19 07:30:06 doug Exp $ */
a759 2
int tls_any_accept(SSL *s);
int tls_any_connect(SSL *s);
@


1.99
log
@Fix symbol collision with libtls.

Pointed out by guenther.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.98 2015/07/19 06:31:32 doug Exp $ */
d828 1
a828 1
int tls1_process_ticket(SSL *s, unsigned char *session_id, int len,
a829 1

@


1.98
log
@Add TLS_method, TLS_client_method and TLS_server_method.

Use these instead of SSLv23_*method when you want to make sure TLS is
used.

By default, we disable SSLv3 but it's still possible for the user to
re-enable it.  TLS_*method does not allow SSLv3.

Both BoringSSL and (next version of) OpenSSL have these methods.
However, they have changed the implementation significantly.  We will
as well, but not right now.

Riding the libssl major bump.

ok miod@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.97 2015/07/18 23:00:23 doug Exp $ */
d760 2
a761 2
int tls_accept(SSL *s);
int tls_connect(SSL *s);
@


1.97
log
@Convert dtls1_get_message_header to CBS and change to int.

Changed return value from void to int.  It should never return an error
given that the input length is not checked yet.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.96 2015/07/17 17:36:24 doug Exp $ */
d760 2
@


1.96
log
@Convert ssl_parse_serverhello_use_srtp_ext to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.95 2015/07/14 03:38:26 doug Exp $ */
d697 1
a697 1
void dtls1_get_message_header(unsigned char *data,
@


1.95
log
@Convert ssl_parse_clienthello_use_srtp_ext to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.94 2015/06/28 00:08:27 doug Exp $ */
d857 1
a857 1
int ssl_parse_serverhello_use_srtp_ext(SSL *s, unsigned char *d,
@


1.94
log
@Convert ssl_bytes_to_cipher_list to CBS.

Link in the new 'unit' regress and expand the invalid tests to include
some that would fail before the CBS conversion.

input + ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.93 2015/06/20 16:42:48 doug Exp $ */
d853 1
a853 1
int ssl_parse_clienthello_use_srtp_ext(SSL *s, unsigned char *d,
@


1.93
log
@Convert ssl_parse_serverhello_renegotiate_ext to CBS.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.92 2015/06/20 04:04:35 doug Exp $ */
d572 1
a572 1
STACK_OF(SSL_CIPHER) *ssl_bytes_to_cipher_list(SSL *s, unsigned char *p,
@


1.92
log
@Convert ssl_parse_clienthello_renegotiate_ext to CBS.

ok miod@@, tweak + ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.91 2015/06/18 22:51:05 doug Exp $ */
d838 1
a838 1
int ssl_parse_serverhello_renegotiate_ext(SSL *s, unsigned char *d,
@


1.91
log
@Remove Microsoft Server Gated Crypto.

Another relic due to the old US crypto policy.

From OpenSSL commit 63eab8a620944a990ab3985620966ccd9f48d681 and
95275599399e277e71d064790a1f828a99fc661a.

ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.90 2015/04/15 16:25:43 jsing Exp $ */
d842 1
a842 1
int ssl_parse_clienthello_renegotiate_ext(SSL *s, unsigned char *d,
@


1.90
log
@Clean up the ssl_bytes_to_cipher_list() API - rather than having the
ability to pass or not pass a STACK_OF(SSL_CIPHER) *, which is then either
zeroed or if NULL a new one is allocated, always allocate one and return it
directly.

Inspired by simliar changes in BoringSSL.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.89 2015/03/27 12:29:54 jsing Exp $ */
a743 1
int ssl3_check_client_hello(SSL *s);
@


1.89
log
@Factor out the init_buf initialisation code, rather than duplicating it
in four different places.

ok doug@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.88 2015/02/22 15:54:27 jsing Exp $ */
d573 1
a573 1
    int num, STACK_OF(SSL_CIPHER) **skp);
@


1.88
log
@Reluctantly add server-side support for TLS_FALLBACK_SCSV.

This allows for clients that willingly choose to perform a downgrade and
attempt to establish a second connection at a lower protocol after the
previous attempt unexpectedly failed, to be notified and have the second
connection aborted, if the server does in fact support a higher protocol.

TLS has perfectly good version negotiation and client-side fallback is
dangerous. Despite this, in order to maintain maximum compatability with
broken web servers, most mainstream browsers implement this. Furthermore,
TLS_FALLBACK_SCSV only works if both the client and server support it and
there is effectively no way to tell if this is the case, unless you control
both ends.

Unfortunately, various auditors and vulnerability scanners (including
certain online assessment websites) consider the presence of a not yet
standardised feature to be important for security, even if the clients do
not perform client-side downgrade or the server only supports current TLS
protocols.

Diff is loosely based on OpenSSL with some inspiration from BoringSSL.

Discussed with beck@@ and miod@@.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.87 2015/02/12 03:45:25 jsing Exp $ */
d640 1
@


1.87
log
@unifdef -m -UOPENSSL_NO_NEXTPROTONEG - NPN is being replaced with ALPN,
however it is not likely to be removed any time soon.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.86 2015/02/07 04:17:11 jsing Exp $ */
d548 1
@


1.86
log
@Provide a SSL_CIPHER_get_by_value() function that allows a cipher to be
retrieved via its cipher suite value. A corresponding SSL_CIPHER_by_value()
function returns the cipher suite value for a given SSL_CIPHER. These
functions should mean that software does not need to resort to
put_cipher_by_char()/get_cipher_by_char() in order to locate a cipher.

Begrudgingly also provide a SSL_CIPHER_get_by_id() function that locates a
cipher via the internal cipher identifier. Unfortunately these have already
been leaked outside the library via SSL_CIPHER_by_id() and the various
SSL3_CK_* and TLS1_CK_* defines in the ssl3.h/tls1.h headers.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.85 2015/02/06 08:30:23 jsing Exp $ */
a727 1
# ifndef OPENSSL_NO_NEXTPROTONEG
a728 1
# endif
a745 1
#ifndef OPENSSL_NO_NEXTPROTONEG
a746 1
#endif
@


1.85
log
@Bring back the horrible API that is get_cipher_by_char/put_cipher_by_char.

This API was intended to be an internal only, however like many things in
OpenSSL, it is exposed externally and parts of the software ecosystem are
now using it since there is no real alternative within the public API.

ok doug@@, tedu@@ and reluctantly miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.84 2014/12/15 00:46:53 doug Exp $ */
d619 1
@


1.84
log
@Add error handling for EVP_DigestInit_ex().

A few EVP_DigestInit_ex() calls were left alone since reporting an
error would change the public API.

Changed internal ssl3_cbc_digest_record() to return a value due to the above
change.  It will also now set md_out_size=0 on failure.

This is based on part of BoringSSL's commit to fix malloc crashes:
https://boringssl.googlesource.com/boringssl/+/69a01608f33ab6fe2c3485d94aef1fe9eacf5364

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.83 2014/12/14 16:19:38 jsing Exp $ */
d598 2
@


1.83
log
@Convert all of the straight forward client handshake handling code to use
the new handshake functions.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.82 2014/12/14 15:30:50 jsing Exp $ */
d868 1
a868 1
void ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, unsigned char *md_out,
@


1.82
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.81 2014/12/10 15:43:31 jsing Exp $ */
d655 4
@


1.81
log
@ssl3_init_finished_mac() calls BIO_new() which can fail since it in turn
calls malloc(). Instead of silently continuing on failure, check the return
value of BIO_new() and propagate failure back to the caller for appropriate
handling.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.80 2014/12/10 15:36:47 jsing Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d113 1
a113 1
 * ECC cipher suite support in OpenSSL originally developed by 
d349 1
a349 1
 
d417 1
a417 1
/* From ECC-TLS draft, used in encoding the curve type in 
d420 1
a420 1
#define EXPLICIT_PRIME_CURVE_TYPE  1   
d476 1
a476 1
/*#define RSA_DEBUG	*/ 
@


1.80
log
@Remove support for GOST R 34.10-94 signature authentication, along with
the two ciphersuites that use it. GOST94 public/private keys have been
long obsoleted and libcrypto does not have support for them anyway.

Discussed with Dmitry Eremin-Solenikov.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.79 2014/12/06 14:24:26 jsing Exp $ */
d598 1
a598 1
void ssl3_init_finished_mac(SSL *s);
@


1.79
log
@Remove client handling of RSA in ServerKeyExchange messages, along with
the associated peer_rsa_tmp goop.

This was only needed for export cipher handling and intentional RFC
violations. The export cipher suites have already been removed and
previous cleanup means that we will never send ServerKeyExchange messages
from the server side for RSA.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.78 2014/12/06 13:51:06 jsing Exp $ */
a268 1
#define SSL_aGOST94		0x00000100L /* GOST R 34.10-94 signature auth */
d400 2
a401 3
#define SSL_PKEY_GOST94		6
#define SSL_PKEY_GOST01		7
#define SSL_PKEY_NUM		8
@


1.78
log
@Use appropriate internal types for EC curves and formats, rather than
storing and processing in wire encoded form.

Inspired by boringssl.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.77 2014/11/18 05:33:43 miod Exp $ */
a469 1
	RSA *peer_rsa_tmp;
@


1.77
log
@Update the GOST code in libssl, as contributed by Dmitry Eremin-Solenikov.

This causes a libssl major version bump as this affects the layout of some
internal-but-unfortunately-made-visible structs.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.76 2014/11/16 14:12:47 jsing Exp $ */
d803 2
a804 2
int tls1_ec_curve_id2nid(int curve_id);
int tls1_ec_nid2curve_id(int nid);
@


1.76
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.75 2014/11/08 15:21:02 jsing Exp $ */
d302 2
d318 2
d324 1
a324 1
#define SSL_MAX_DIGEST 6
d337 1
@


1.75
log
@Clean up more SSLv2 remnants.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.74 2014/11/02 10:42:38 jsing Exp $ */
d148 1
d150 1
a151 2
#include <string.h>
#include <errno.h>
d155 1
a156 3
#include <openssl/bio.h>
#include <openssl/stack.h>
#include <openssl/rsa.h>
d159 1
d161 1
@


1.74
log
@Remove remnants from RC2 and SEED - there are no longer any cipher suites
that use these algorithms (and SEED was removed from libcrypto some time
ago).

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.73 2014/10/31 15:25:55 jsing Exp $ */
a303 1
#define SSL_SSLV2		0x00000001L
@


1.73
log
@Add support for automatic DH ephemeral keys.

This allows an SSL server to enable DHE ciphers with a single setting,
which results in an DH key being generated based on the server key length.

Partly based on OpenSSL.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.72 2014/10/31 14:51:01 jsing Exp $ */
d277 10
a286 12
#define SSL_RC2			0x00000008L
#define SSL_IDEA		0x00000010L
#define SSL_eNULL		0x00000020L
#define SSL_AES128		0x00000040L
#define SSL_AES256		0x00000080L
#define SSL_CAMELLIA128		0x00000100L
#define SSL_CAMELLIA256		0x00000200L
#define SSL_eGOST2814789CNT	0x00000400L
#define SSL_SEED		0x00000800L
#define SSL_AES128GCM		0x00001000L
#define SSL_AES256GCM		0x00002000L
#define SSL_CHACHA20POLY1305	0x00004000L
@


1.72
log
@Remove support for ephemeral/temporary RSA private keys.

The only use for these is via SSL_OP_EPHEMERAL_RSA (which is effectively
a standards violation) and for RSA sign-only, should only be possible if
you are using an export cipher and have an RSA private key that is more
than 512 bits in size (however we no longer support export ciphers).

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.71 2014/10/03 13:58:18 jsing Exp $ */
d445 1
d592 1
@


1.71
log
@Add support for automatic ephemeral EC keys.

This allows an SSL server to enable ECDHE ciphers with a single setting,
which results in an EC key being generated using the first preference
shared curve.

Based on OpenSSL with inspiration from boringssl.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.69 2014/09/27 11:01:06 jsing Exp $ */
a441 3

	RSA *rsa_tmp;
	RSA *(*rsa_tmp_cb)(SSL *ssl, int is_export, int keysize);
@


1.70
log
@Clean up EC cipher handling in ssl3_choose_cipher().

The existing code reaches around into various internals of EC, which it
should not know anything about. Replace this with a set of functions that
that can correctly extract the necessary details and handle the
comparisions.

Based on a commit to OpenSSL, with some inspiration from boringssl.

ok miod@@
@
text
@d442 1
d445 1
d448 1
a449 1
	/* Callback for generating ephemeral ECDH keys */
d451 1
d805 1
@


1.69
log
@Check that the specified curve is one of the client preferences.

Based on OpenSSL.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.68 2014/09/07 12:16:23 jsing Exp $ */
d841 3
@


1.68
log
@Remove SSL_kDHr, SSL_kDHd and SSL_aDH. No supported ciphersuites use them,
nor do we plan on supporting them.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.67 2014/08/24 14:36:46 jsing Exp $ */
d801 1
@


1.67
log
@Replace the remaining uses of ssl3_put_cipher_by_char() with s2n and a
ssl3_cipher_get_value() helper function, which returns the cipher suite
value for the given cipher.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.66 2014/08/23 14:52:41 jsing Exp $ */
a256 2
#define SSL_kDHr		0x00000002L /* DH cert, RSA CA cert */ /* no such ciphersuites supported! */
#define SSL_kDHd		0x00000004L /* DH cert, DSA CA cert */ /* no such ciphersuite supported! */
a266 1
#define SSL_aDH 		0x00000008L /* Fixed DH auth (kDHd or kDHr) */ /* no such ciphersuites supported! */
d269 2
a270 2
#define SSL_aGOST94				0x00000100L /* GOST R 34.10-94 signature auth */
#define SSL_aGOST01 			0x00000200L /* GOST R 34.10-2001 signature auth */
@


1.66
log
@Replace the remaining ssl3_get_cipher_by_char() calls with n2s() and
ssl3_get_cipher_by_id().

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.65 2014/08/11 01:06:22 jsing Exp $ */
d329 1
a599 1
int ssl3_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p);
d619 1
@


1.65
log
@Provide a ssl3_get_cipher_by_id() function that allows ciphers to be looked
up by their ID. For one, this avoids an ugly mess in ssl_sess.c, where the
cipher value is manually written into a buffer, just so the cipher can be
located using ssl3_get_cipher_by_char().

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.64 2014/08/10 14:42:56 jsing Exp $ */
d328 2
a598 1
const SSL_CIPHER *ssl3_get_cipher_by_char(const unsigned char *p);
@


1.64
log
@Since we no longer need to support SSLv2-style cipher lists, start
unravelling the maze of function pointers and callbacks by directly
calling ssl3_{get,put}_cipher_by_char() and removing the
ssl_{get,put}_cipher_by_char macros.

Prompted by similar changes in boringssl.

ok guenther.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.63 2014/07/28 04:23:12 guenther Exp $ */
d617 1
@


1.63
log
@The RSA, DH, and ECDH temporary key callbacks expect the number of keybits
for the key (expressed in RSA key bits, which makes *no sense* for ECDH) as
their second argument, not zero.

(jsing@@ notes that the RSA callback is only invoked for 'export' ciphers,
which have been removed from LibreSSL, and for the SSL_OP_EPHEMERAL_RSA
option, which is makes the application non-compliant.  More fuel for the
tedu fire...)

jasper@@ noted the breakage and bisected it down to the diff that broke this
ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.62 2014/07/12 22:33:39 jsing Exp $ */
a477 5
#define ssl_put_cipher_by_char(ssl,ciph,ptr) \
		((ssl)->method->put_cipher_by_char((ciph),(ptr)))
#define ssl_get_cipher_by_char(ssl,ptr) \
		((ssl)->method->get_cipher_by_char(ptr))

d574 1
a574 1
    unsigned char *p, int (*put_cb)(const SSL_CIPHER *, unsigned char *));
a661 1
int ssl23_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p);
@


1.63.4.1
log
@backport fixes to prevent connections from being downgraded to weak keys.
ok bluhm miod
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.63 2014/07/28 04:23:12 guenther Exp $ */
d467 1
a467 1
	RSA *__peer_rsa_tmp;
@


1.62
log
@The correct name for EDH is DHE, likewise EECDH should be ECDHE.

Based on changes to OpenSSL trunk.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.61 2014/07/12 19:45:53 jsing Exp $ */
d370 6
@


1.61
log
@Provide ssl_version_string() function, which uses one of those modern C
constructs (a switch statement) and returns the appropriate string defined
by SSL_TXT_* for the given version, including support for DTLSv1 and
DTLSv1-bad. Use this function in SSL_get_version() and SSL_SESSION_print().

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.60 2014/07/12 13:11:53 jsing Exp $ */
d259 1
a259 1
#define SSL_kEDH		0x00000008L /* tmp DH key no DH cert */
d262 1
a262 1
#define SSL_kEECDH		0x00000080L /* ephemeral ECDH */
d400 1
a400 1
 * SSL_kEDH <- RSA_ENC | RSA_SIGN | DSA_SIGN
@


1.60
log
@Remove remnants from PSK, KRB5 and SRP.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.59 2014/07/11 08:17:36 miod Exp $ */
d546 1
@


1.59
log
@No need to keep ssl23_foo() flavours mapping to ssl3_foo().
ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.58 2014/07/10 10:09:54 jsing Exp $ */
a259 1
#define SSL_kKRB5		0x00000010L /* Kerberos5 key exchange */
d263 1
a263 3
#define SSL_kPSK		0x00000100L /* PSK */
#define SSL_kGOST       0x00000200L /* GOST key exchange */
#define SSL_kSRP        0x00000400L /* SRP */
a270 1
#define SSL_aKRB5               0x00000020L /* KRB5 auth */
a271 1
#define SSL_aPSK                0x00000080L /* PSK auth */
@


1.58
log
@Remove more compression related code.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.57 2014/07/10 08:51:15 tedu Exp $ */
a661 2
int ssl23_num_ciphers(void);
const SSL_CIPHER *ssl23_get_cipher(unsigned int u);
a665 1
const SSL_CIPHER *ssl23_get_cipher_by_char(const unsigned char *p);
@


1.57
log
@decompress libssl. ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.56 2014/07/09 11:25:42 jsing Exp $ */
a581 1
int ssl_cipher_get_comp(const SSL_SESSION *s, SSL_COMP **comp);
@


1.56
log
@tedu the SSL export cipher handling - since we do not have enabled export
ciphers we no longer need the flags or code to support it.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.55 2014/07/08 21:50:40 jsing Exp $ */
a155 3
#ifndef OPENSSL_NO_COMP
#include <openssl/comp.h>
#endif
a546 9
#ifndef OPENSSL_NO_COMP
/* Used for holding the relevant compression methods loaded into SSL_CTX */
typedef struct ssl3_comp_st {
	int comp_id;	/* The identifier byte for this compression type */
	char *name;	/* Text name used for the compression type */
	COMP_METHOD *method; /* The method :-) */
} SSL3_COMP;
#endif

a675 2
int ssl3_do_compress(SSL *ssl);
int ssl3_do_uncompress(SSL *ssl);
@


1.55
log
@Remove SSL_FIPS.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.54 2014/07/08 21:31:54 jsing Exp $ */
d371 1
a371 13
 * Export and cipher strength information. For each cipher we have to decide
 * whether it is exportable or not. This information is likely to change
 * over time, since the export control rules are no static technical issue.
 *
 * Independent of the export flag the cipher strength is sorted into classes.
 * SSL_EXP40 was denoting the 40bit US export limit of past times, which now
 * is at 56bit (SSL_EXP56). If the exportable cipher class is going to change
 * again (eg. to 64bit) the use of "SSL_EXP*" becomes blurred even more,
 * since SSL_EXP64 could be similar to SSL_LOW.
 * For this reason SSL_MICRO and SSL_MINI macros are included to widen the
 * namespace of SSL_LOW-SSL_HIGH to lower values. As development of speed
 * and ciphers goes, another extension to SSL_SUPER and/or SSL_ULTRA would
 * be possible.
a372 1
#define SSL_EXP_MASK		0x00000003L
a373 3

#define SSL_EXPORT		0x00000002L

a374 4
#define SSL_EXP40		0x00000008L
#define SSL_MICRO		(SSL_EXP40)
#define SSL_EXP56		0x00000010L
#define SSL_MINI		(SSL_EXP56)
a378 29
/* we have used 000001ff - 23 bits left to go */

/*
 * Macros to check the export status and cipher strength for export ciphers.
 * Even though the macros for EXPORT and EXPORT40/56 have similar names,
 * their meaning is different:
 * *_EXPORT macros check the 'exportable' status.
 * *_EXPORT40/56 macros are used to check whether a certain cipher strength
 *          is given.
 * Since the SSL_IS_EXPORT* and SSL_EXPORT* macros depend on the correct
 * algorithm structure element to be passed (algorithms, algo_strength) and no
 * typechecking can be done as they are all of type unsigned long, their
 * direct usage is discouraged.
 * Use the SSL_C_* macros instead.
 */
#define SSL_IS_EXPORT(a)	((a)&SSL_EXPORT)
#define SSL_IS_EXPORT56(a)	((a)&SSL_EXP56)
#define SSL_IS_EXPORT40(a)	((a)&SSL_EXP40)
#define SSL_C_IS_EXPORT(c)	SSL_IS_EXPORT((c)->algo_strength)
#define SSL_C_IS_EXPORT56(c)	SSL_IS_EXPORT56((c)->algo_strength)
#define SSL_C_IS_EXPORT40(c)	SSL_IS_EXPORT40((c)->algo_strength)

#define SSL_EXPORT_KEYLENGTH(a,s)	(SSL_IS_EXPORT40(s) ? 5 : \
				 (a) == SSL_DES ? 8 : 7)
#define SSL_EXPORT_PKEYLENGTH(a) (SSL_IS_EXPORT40(a) ? 512 : 1024)
#define SSL_C_EXPORT_KEYLENGTH(c)	SSL_EXPORT_KEYLENGTH((c)->algorithm_enc, \
				(c)->algo_strength)
#define SSL_C_EXPORT_PKEYLENGTH(c)	SSL_EXPORT_PKEYLENGTH((c)->algo_strength)

a443 2
	unsigned long export_mask_k;
	unsigned long export_mask_a;
@


1.54
log
@Nuke SSL_NOT_EXP since it does nothing.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.53 2014/06/21 17:02:25 jsing Exp $ */
a397 1
#define SSL_FIPS		0x00000100L
@


1.53
log
@Pull the code that builds a DTLS sequence number out into its own function
to avoid duplication. Also use fewer magic numbers.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.52 2014/06/15 15:29:25 jsing Exp $ */
a387 1
#define SSL_NOT_EXP		0x00000001L
@


1.52
log
@Rename ssl3_record_sequence_update() to ssl3_record_sequence_increment(),
so that it reflects what it is actually doing. Use this function in a
number of places that still have the hand rolled version.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.51 2014/06/13 13:28:53 jsing Exp $ */
d762 2
a763 1
void dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr);
d766 2
@


1.51
log
@Add ChaCha20-Poly1305 based ciphersuites.

Based on Adam Langley's chromium patches.

Tested by and ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.50 2014/06/13 10:52:24 jsing Exp $ */
d724 1
a724 1
void ssl3_record_sequence_update(unsigned char *seq);
d726 1
a726 1
long ssl3_default_timeout(void );
d728 1
a728 1
int ssl23_num_ciphers(void );
d735 1
a735 1
long ssl23_default_timeout(void );
@


1.50
log
@Add an SSL_AEAD_CTX to enable the use of EVP_AEAD with an SSL cipher.
Read and write contexts are also added to the SSL_CTX, along with
supporting code.

Based on Adam Langley's chromium diffs.

Rides the recent SSL library bump.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_locl.h,v 1.49 2014/06/12 15:49:31 deraadt Exp $ */
d299 1
@


1.49
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d580 21
@


1.48
log
@Add an SSL_CIPHER_ALGORITHM2_AEAD flag that is used to mark a cipher as
using EVP_AEAD. Also provide an EVP_AEAD-only equivalent of
ssl_cipher_get_evp().
@
text
@d1 1
a1 1
/* ssl/ssl_locl.h */
@


1.47
log
@http://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2016265dfbab162ec30718b5e7480add42598158
Don't know the full story, but it looks like a "can't do random
perfectly, so do it god awful" problem was found in 2013, and
replaced with "only do it badly if a flag is set".  New flags
(SSL_MODE_SEND_SERVERHELLO_TIME and SSL_MODE_SEND_SERVERHELLO_TIME)
were added [Ben Laurie?] to support the old scheme of "use time_t
for first 4 bytes of the random buffer".

Nothing uses these flags [ecosystem scan by sthen]

Fully discourage use of these flags in the future by removing
support & definition of them.  The buflen < 4 check is also interesting,
because no entropy would be returned.  No callers passed such small
buffers.
ok miod sthen
@
text
@d349 12
d362 6
d628 1
@


1.46
log
@ECDH and ECDSA will not work overly well if there is no EC, so unifdef
OPENSSL_NO_EC.

ok tedu@@
@
text
@a623 1
int ssl_fill_hello_random(SSL *s, int server, unsigned char *field, int len);
@


1.45
log
@TLS would not be entirely functional without extensions, so unifdef
OPENSSL_NO_TLSEXT.

ok tedu@@
@
text
@a450 1
#ifndef OPENSSL_NO_EC
a456 1
#endif  /* OPENSSL_NO_EC */
a830 1
#ifndef OPENSSL_NO_EC
a832 1
#endif /* OPENSSL_NO_EC */
@


1.44
log
@While working on another diff I ended up looking to see why on earth the
DTLS code had a chunk that checked to see if the SSL version was *not*
DTLS. Turns out that this is inside a big #if 0 block with a comment
explaining why DTLS will never need this code...

The DTLS code was clearly written by wholesale copying the SSLv3 code.
Any code not applicable to DTLS was seemingly #if 0'd or commented out
and left for others to find.

d1_pkt.c is copied from s3_pkt.c and it has a do_dtls1_write() function
that has the same function signature as do_ssl3_write(), except that the
create_empty_fragement (yes, that is the spelling in ssl_locl.h) argument
is unused for DTLS (although there is code that pretends to use it) since
it uses explicit IV (as the comment notes).

Instead of leaving this turd lying around, nuke the #if 0'd code (along
with the check for *not* DTLS) and remove the pointless
create_empty_fragment argument given the only two do_dtls1_write() calls
specify zero.

This kind of thing also makes you wonder how much actual peer review
occurred before the code was initially committed...

ok beck@@
@
text
@a752 1
#ifndef OPENSSL_NO_TLSEXT
a756 1
#endif
a837 1
#ifndef OPENSSL_NO_TLSEXT
a862 1
#endif
@


1.43
log
@we no longer care that these aren't used for ssl2
@
text
@d809 1
a809 1
    unsigned int len, int create_empty_fragement);
@


1.42
log
@unidef DH, ECDH, and ECDSA. there's no purpose to a libssl without them.
ok deraadt jsing
@
text
@d505 2
a506 2
	RSA *peer_rsa_tmp; /* not used for SSL 2 */
	DH *peer_dh_tmp; /* not used for SSL 2 */
@


1.41
log
@Make it substantially easier to identify protocol version requirements
by adding an enc_flags field to the ssl3_enc_method, specifying four flags
that are used with this field and providing macros for evaluating these
conditions. Currently the version requirements are identified by
continually checking the version number and other criteria.

This change also adds separate SSL3_ENC_METHOD data for TLS v1.1 and v1.2,
since they have different enc_flags from TLS v1.

Based on changes in OpenSSL head.

No objection from miod@@
@
text
@a481 1
#ifndef OPENSSL_NO_DH
a483 2
#endif
#ifndef OPENSSL_NO_ECDH
a486 1
#endif
a505 1
#ifndef OPENSSL_NO_DH
a506 2
#endif
#ifndef OPENSSL_NO_ECDH
a507 1
#endif
a830 1
#ifndef OPENSSL_NO_ECDH
a831 1
#endif
@


1.40
log
@Remove unused defines.
@
text
@d411 2
d414 11
a424 1

d550 2
d554 19
d588 2
a591 2

#define SSL_IS_DTLS(s) (s->method->version == DTLS1_VERSION)
@


1.39
log
@remove unused shit. from Alexander Schrijver
@
text
@a243 9
#define TWO_BYTE_BIT	0x80
#define SEC_ESC_BIT	0x40
#define TWO_BYTE_MASK	0x7fff
#define THREE_BYTE_MASK	0x3fff

#define INC32(a)	((a)=((a)+1)&0xffffffffL)
#define DEC32(a)	((a)=((a)-1)&0xffffffffL)
#define MAX_MAC_SIZE	20 /* up from 16 for SSLv3 */

@


1.38
log
@The ssl_ciper_get_evp() function is currently overloaded to also return the
compression associated with the SSL session. Based on one of Adam Langley's
chromium diffs, factor out the compression handling code into a separate
ssl_cipher_get_comp() function.

Rewrite the compression handling code to avoid pointless duplication and so
that failures are actually returned to and detectable by the caller.

ok miod@@
@
text
@a517 7
/*#define MAC_DEBUG	*/

/*#define ERR_DEBUG	*/
/*#define ABORT_DEBUG	*/
/*#define PKT_DEBUG 1   */
/*#define DES_DEBUG	*/
/*#define DES_OFB_DEBUG	*/
a519 1
/*#define IDEA_DEBUG	*/ 
a520 1
#define FP_ICC  (int (*)(const void *,const void *))
a888 4

void tls_fips_digest_extra(const EVP_CIPHER_CTX *cipher_ctx,
    EVP_MD_CTX *mac_ctx, const unsigned char *data, size_t data_len,
    size_t orig_len);
@


1.37
log
@DeIMPLEMENT libssl. Expand the IMPLEMENT_* macros since it is far more
readable and one less layer of abstraction. Use C99 initialisers for
clarity, grepability and to protect from future field reordering/removal.

ok miod@@ (tedu@@ also thought it was a wonderful idea, beck@@ also agreed,
but ran away squealing since it reminded him of the VOP layer...)
@
text
@d602 1
d604 1
a604 2
    const EVP_MD **md, int *mac_pkey_type, int *mac_secret_size,
    SSL_COMP **comp);
@


1.36
log
@There are two actual uses of e_os2.h in libssl - an OPENSSL_GLOBAL (an
empty define) and an OPENSSL_EXTERN (which is defined as, well... extern).
The use of OPENSSL_EXTERN is already inconsistent since the lines above
and below just use plain old "extern". Expand the two uses of these macros
and stop including e_os2.h in libssl.

ok miod@@
@
text
@a577 149
#define IMPLEMENT_tls_meth_func(version, func_name, s_accept, s_connect, \
				s_get_meth) \
const SSL_METHOD *func_name(void)  \
	{ \
	static const SSL_METHOD func_name##_data= { \
		version, \
		tls1_new, \
		tls1_clear, \
		tls1_free, \
		s_accept, \
		s_connect, \
		ssl3_read, \
		ssl3_peek, \
		ssl3_write, \
		ssl3_shutdown, \
		ssl3_renegotiate, \
		ssl3_renegotiate_check, \
		ssl3_get_message, \
		ssl3_read_bytes, \
		ssl3_write_bytes, \
		ssl3_dispatch_alert, \
		ssl3_ctrl, \
		ssl3_ctx_ctrl, \
		ssl3_get_cipher_by_char, \
		ssl3_put_cipher_by_char, \
		ssl3_pending, \
		ssl3_num_ciphers, \
		ssl3_get_cipher, \
		s_get_meth, \
		tls1_default_timeout, \
		&TLSv1_enc_data, \
		ssl_undefined_void_function, \
		ssl3_callback_ctrl, \
		ssl3_ctx_callback_ctrl, \
	}; \
	return &func_name##_data; \
	}

#define IMPLEMENT_ssl3_meth_func(func_name, s_accept, s_connect, s_get_meth) \
const SSL_METHOD *func_name(void)  \
	{ \
	static const SSL_METHOD func_name##_data= { \
		SSL3_VERSION, \
		ssl3_new, \
		ssl3_clear, \
		ssl3_free, \
		s_accept, \
		s_connect, \
		ssl3_read, \
		ssl3_peek, \
		ssl3_write, \
		ssl3_shutdown, \
		ssl3_renegotiate, \
		ssl3_renegotiate_check, \
		ssl3_get_message, \
		ssl3_read_bytes, \
		ssl3_write_bytes, \
		ssl3_dispatch_alert, \
		ssl3_ctrl, \
		ssl3_ctx_ctrl, \
		ssl3_get_cipher_by_char, \
		ssl3_put_cipher_by_char, \
		ssl3_pending, \
		ssl3_num_ciphers, \
		ssl3_get_cipher, \
		s_get_meth, \
		ssl3_default_timeout, \
		&SSLv3_enc_data, \
		ssl_undefined_void_function, \
		ssl3_callback_ctrl, \
		ssl3_ctx_callback_ctrl, \
	}; \
	return &func_name##_data; \
	}

#define IMPLEMENT_ssl23_meth_func(func_name, s_accept, s_connect, s_get_meth) \
const SSL_METHOD *func_name(void)  \
	{ \
	static const SSL_METHOD func_name##_data= { \
	TLS1_2_VERSION, \
	tls1_new, \
	tls1_clear, \
	tls1_free, \
	s_accept, \
	s_connect, \
	ssl23_read, \
	ssl23_peek, \
	ssl23_write, \
	ssl_undefined_function, \
	ssl_undefined_function, \
	ssl_ok, \
	ssl3_get_message, \
	ssl3_read_bytes, \
	ssl3_write_bytes, \
	ssl3_dispatch_alert, \
	ssl3_ctrl, \
	ssl3_ctx_ctrl, \
	ssl23_get_cipher_by_char, \
	ssl23_put_cipher_by_char, \
	ssl_undefined_const_function, \
	ssl23_num_ciphers, \
	ssl23_get_cipher, \
	s_get_meth, \
	ssl23_default_timeout, \
	&ssl3_undef_enc_method, \
	ssl_undefined_void_function, \
	ssl3_callback_ctrl, \
	ssl3_ctx_callback_ctrl, \
	}; \
	return &func_name##_data; \
	}

#define IMPLEMENT_dtls1_meth_func(func_name, s_accept, s_connect, s_get_meth) \
const SSL_METHOD *func_name(void)  \
	{ \
	static const SSL_METHOD func_name##_data= { \
		DTLS1_VERSION, \
		dtls1_new, \
		dtls1_clear, \
		dtls1_free, \
		s_accept, \
		s_connect, \
		ssl3_read, \
		ssl3_peek, \
		ssl3_write, \
		dtls1_shutdown, \
		ssl3_renegotiate, \
		ssl3_renegotiate_check, \
		dtls1_get_message, \
		dtls1_read_bytes, \
		dtls1_write_app_data_bytes, \
		dtls1_dispatch_alert, \
		dtls1_ctrl, \
		ssl3_ctx_ctrl, \
		ssl3_get_cipher_by_char, \
		ssl3_put_cipher_by_char, \
		ssl3_pending, \
		ssl3_num_ciphers, \
		dtls1_get_cipher, \
		s_get_meth, \
		dtls1_default_timeout, \
		&DTLSv1_enc_data, \
		ssl_undefined_void_function, \
		ssl3_callback_ctrl, \
		ssl3_ctx_callback_ctrl, \
	}; \
	return &func_name##_data; \
	}

a779 2


d792 2
a793 2
int	dtls1_accept(SSL *s);
int	dtls1_connect(SSL *s);
@


1.35
log
@Stop pulling pqueue.h into ssl_locl.h since only a small part of libssl
actually needs it. Instead, just include it in the files where it is
actually necessary.

Also remove standard includes from pqueue.h so that they are not available
as a side effect. Just add the two includes that are needed to pqueue.c.

ok miod@@
@
text
@a154 1
#include <openssl/e_os2.h>
d568 1
a568 2
OPENSSL_EXTERN SSL_CIPHER ssl3_ciphers[];

@


1.34
log
@No longer make pqueue.h a public (and installed) header file. Replace its
inclusion in <ssl/dtls1.h> by the benign
`struct _pqueue; typedef struct _pqueue *pqueue;'.

Note that said dtls1.h should probably be considered a private header as well...

ok beck@@
@
text
@a166 2
#include "pqueue.h"

@


1.33
log
@Remove orphaned l2n6 and n2l6 macros.
@
text
@d167 2
@


1.32
log
@Unifdef -U OPENSSL_BUILD_SHLIBCRYPTO, since all it causes under Unix is to
redefine OPENSSL_EXTERN from `extern' to `extern'.
@
text
@a202 7
#define l2n6(l,c)	(*((c)++)=(unsigned char)(((l)>>40)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>32)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>24)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>16)&0xff), \
			 *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
			 *((c)++)=(unsigned char)(((l)    )&0xff))

a210 7

#define n2l6(c,l)	(l =((BN_ULLONG)(*((c)++)))<<40, \
			 l|=((BN_ULLONG)(*((c)++)))<<32, \
			 l|=((BN_ULLONG)(*((c)++)))<<24, \
			 l|=((BN_ULLONG)(*((c)++)))<<16, \
			 l|=((BN_ULLONG)(*((c)++)))<< 8, \
			 l|=((BN_ULLONG)(*((c)++))))
@


1.31
log
@Unifdef -UPKCS1_CHECK and remove SSL_OP_PKCS1_CHECK_[12], this is leftover
``debug'' code from a 15+ years old bugfix and the SSL_OP_PKCS1_CHECK_*
constants have had a value of zero since ages. No production code should use
them.

ok beck@@
@
text
@a166 5
#ifdef OPENSSL_BUILD_SHLIBSSL
# undef OPENSSL_EXTERN
# define OPENSSL_EXTERN OPENSSL_EXPORT
#endif

@


1.30
log
@The internal ssl2_* functions and variables are gone
@
text
@a171 2
#undef PKCS1_CHECK

@


1.29
log
@always build in RSA and DSA. ok deraadt miod
@
text
@a589 1
OPENSSL_EXTERN const SSL_CIPHER ssl2_ciphers[];
a791 29

int ssl2_enc_init(SSL *s, int client);
int ssl2_generate_key_material(SSL *s);
void ssl2_enc(SSL *s, int send_data);
void ssl2_mac(SSL *s, unsigned char *mac, int send_data);
const SSL_CIPHER *ssl2_get_cipher_by_char(const unsigned char *p);
int ssl2_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p);
int ssl2_part_read(SSL *s, unsigned long f, int i);
int ssl2_do_write(SSL *s);
int ssl2_set_certificate(SSL *s, int type, int len, const unsigned char *data);
void ssl2_return_error(SSL *s, int reason);
void ssl2_write_error(SSL *s);
int ssl2_num_ciphers(void);
const SSL_CIPHER *ssl2_get_cipher(unsigned int u);
int	ssl2_new(SSL *s);
void	ssl2_free(SSL *s);
int	ssl2_accept(SSL *s);
int	ssl2_connect(SSL *s);
int	ssl2_read(SSL *s, void *buf, int len);
int	ssl2_peek(SSL *s, void *buf, int len);
int	ssl2_write(SSL *s, const void *buf, int len);
int	ssl2_shutdown(SSL *s);
void	ssl2_clear(SSL *s);
long	ssl2_ctrl(SSL *s, int cmd, long larg, void *parg);
long	ssl2_ctx_ctrl(SSL_CTX *s, int cmd, long larg, void *parg);
long	ssl2_callback_ctrl(SSL *s, int cmd, void (*fp)(void));
long	ssl2_ctx_callback_ctrl(SSL_CTX *s, int cmd, void (*fp)(void));
int	ssl2_pending(const SSL *s);
long	ssl2_default_timeout(void );
@


1.28
log
@quick pass at removing ability to disable sha256 and sha512. ok miod
@
text
@a161 1
#ifndef OPENSSL_NO_RSA
a162 2
#endif
#ifndef OPENSSL_NO_DSA
a163 1
#endif
a498 1
#ifndef OPENSSL_NO_RSA
a500 1
#endif
a527 1
#ifndef OPENSSL_NO_RSA
a528 1
#endif
@


1.27
log
@TANSTAAFL - delete the buf freelist code. if you need a better malloc, get
a better malloc. ok beck deraadt
@
text
@a1063 3
#ifdef OPENSSL_NO_SHA256
#define tlsext_tick_md	EVP_sha1
#else
a1064 1
#endif
@


1.26
log
@Kill the bogus "send an SSLv3/TLS hello in SSLv2 format" crap from
the SSLv23_* client code.  The server continues to accept it.  It
also kills the bits for SSL2 SESSIONs; even when the server gets
an SSLv2-style compat handshake, the session that it creates has
the correct version internally.

ok tedu@@ beck@@
@
text
@a596 12
#ifndef OPENSSL_NO_BUF_FREELISTS
typedef struct ssl3_buf_freelist_st {
	size_t chunklen;
	unsigned int len;
	struct ssl3_buf_freelist_entry_st *head;
} SSL3_BUF_FREELIST;

typedef struct ssl3_buf_freelist_entry_st {
	struct ssl3_buf_freelist_entry_st *next;
} SSL3_BUF_FREELIST_ENTRY;
#endif

@


1.25
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.

There is still a huge amount of inconsistency within these headers.
@
text
@d524 1
a524 1
	STACK_OF(X509) *cert_chain; /* as received from peer (not for SSL2) */
a729 37
	}; \
	return &func_name##_data; \
	}

#define IMPLEMENT_ssl2_meth_func(func_name, s_accept, s_connect, s_get_meth) \
const SSL_METHOD *func_name(void)  \
	{ \
	static const SSL_METHOD func_name##_data= { \
		SSL2_VERSION, \
		ssl2_new,	/* local */ \
		ssl2_clear,	/* local */ \
		ssl2_free,	/* local */ \
		s_accept, \
		s_connect, \
		ssl2_read, \
		ssl2_peek, \
		ssl2_write, \
		ssl2_shutdown, \
		ssl_ok,	/* NULL - renegotiate */ \
		ssl_ok,	/* NULL - check renegotiate */ \
		NULL, /* NULL - ssl_get_message */ \
		NULL, /* NULL - ssl_get_record */ \
		NULL, /* NULL - ssl_write_bytes */ \
		NULL, /* NULL - dispatch_alert */ \
		ssl2_ctrl,	/* local */ \
		ssl2_ctx_ctrl,	/* local */ \
		ssl2_get_cipher_by_char, \
		ssl2_put_cipher_by_char, \
		ssl2_pending, \
		ssl2_num_ciphers, \
		ssl2_get_cipher, \
		s_get_meth, \
		ssl2_default_timeout, \
		&ssl3_undef_enc_method, \
		ssl_undefined_void_function, \
		ssl2_callback_ctrl,	/* local */ \
		ssl2_ctx_callback_ctrl,	/* local */ \
@


1.24
log
@make OPENSSL_NO_HEARTBLEED the default and only option. ok deraadt miod
@
text
@d483 1
a483 2
typedef struct cert_pkey_st
	{
d488 1
a488 1
	} CERT_PKEY;
d490 1
a490 2
typedef struct cert_st
	{
d495 1
a495 1
 
d505 1
a505 1
	RSA *(*rsa_tmp_cb)(SSL *ssl,int is_export,int keysize);
d509 1
a509 1
	DH *(*dh_tmp_cb)(SSL *ssl,int is_export,int keysize);
d514 1
a514 1
	EC_KEY *(*ecdh_tmp_cb)(SSL *ssl,int is_export,int keysize);
d520 1
a520 1
	} CERT;
d523 1
a523 2
typedef struct sess_cert_st
	{
d545 1
a545 1
	} SESS_CERT;
d568 1
a568 2
typedef struct ssl3_enc_method
	{
d572 2
a573 1
	int (*generate_master_secret)(SSL *, unsigned char *, unsigned char *, int);
d584 3
a586 4
				      const char *, size_t,
				      const unsigned char *, size_t,
				      int use_context);
	} SSL3_ENC_METHOD;
d590 1
a590 2
typedef struct ssl3_comp_st
	{
d594 1
a594 1
	} SSL3_COMP;
d598 1
a598 2
typedef struct ssl3_buf_freelist_st
	{
d602 1
a602 1
	} SSL3_BUF_FREELIST;
d604 1
a604 2
typedef struct ssl3_buf_freelist_entry_st
	{
d606 1
a606 1
	} SSL3_BUF_FREELIST_ENTRY;
d818 4
a821 4
int ssl_get_prev_session(SSL *s, unsigned char *session,int len, const unsigned char *limit);
int ssl_cipher_id_cmp(const SSL_CIPHER *a,const SSL_CIPHER *b);
DECLARE_OBJ_BSEARCH_GLOBAL_CMP_FN(SSL_CIPHER, SSL_CIPHER,
				  ssl_cipher_id);
d823 5
a827 5
			const SSL_CIPHER * const *bp);
STACK_OF(SSL_CIPHER) *ssl_bytes_to_cipher_list(SSL *s,unsigned char *p,int num,
					       STACK_OF(SSL_CIPHER) **skp);
int ssl_cipher_list_to_bytes(SSL *s,STACK_OF(SSL_CIPHER) *sk,unsigned char *p,
                             int (*put_cb)(const SSL_CIPHER *, unsigned char *));
d829 2
a830 3
					     STACK_OF(SSL_CIPHER) **pref,
					     STACK_OF(SSL_CIPHER) **sorted,
					     const char *rule_str);
d832 6
a837 4
int ssl_cipher_get_evp(const SSL_SESSION *s,const EVP_CIPHER **enc,
		       const EVP_MD **md,int *mac_pkey_type,int *mac_secret_size, SSL_COMP **comp);
int ssl_get_handshake_digest(int i,long *mask,const EVP_MD **md);			   
int ssl_verify_cert_chain(SSL *s,STACK_OF(X509) *sk);
d843 2
a844 2
EVP_PKEY *ssl_get_sign_pkey(SSL *s,const SSL_CIPHER *c, const EVP_MD **pmd);
int ssl_cert_type(X509 *x,EVP_PKEY *pkey);
d853 2
a854 2
void ssl2_enc(SSL *s,int send_data);
void ssl2_mac(SSL *s,unsigned char *mac,int send_data);
d856 1
a856 1
int ssl2_put_cipher_by_char(const SSL_CIPHER *c,unsigned char *p);
d860 1
a860 1
void ssl2_return_error(SSL *s,int reason);
d873 4
a876 4
long	ssl2_ctrl(SSL *s,int cmd, long larg, void *parg);
long	ssl2_ctx_ctrl(SSL_CTX *s,int cmd, long larg, void *parg);
long	ssl2_callback_ctrl(SSL *s,int cmd, void (*fp)(void));
long	ssl2_ctx_callback_ctrl(SSL_CTX *s,int cmd, void (*fp)(void));
d881 1
a881 1
int ssl3_put_cipher_by_char(const SSL_CIPHER *c,unsigned char *p);
d886 1
a886 1
int ssl3_get_finished(SSL *s,int state_a,int state_b);
d888 2
a889 2
int ssl3_send_change_cipher_spec(SSL *s,int state_a,int state_b);
int ssl3_change_cipher_state(SSL *s,int which);
d891 2
a892 2
int ssl3_do_write(SSL *s,int type);
int ssl3_send_alert(SSL *s,int level, int desc);
d894 2
a895 2
	unsigned char *p, int len);
int ssl3_get_req_cert_type(SSL *s,unsigned char *p);
d897 1
a897 1
int ssl3_send_finished(SSL *s, int a, int b, const char *sender,int slen);
d900 4
a903 2
int ssl3_renegotiate(SSL *ssl); 
int ssl3_renegotiate_check(SSL *ssl); 
d907 2
a908 1
int ssl3_final_finish_mac(SSL *s, const char *sender, int slen,unsigned char *p);
d915 2
a916 2
SSL_CIPHER *ssl3_choose_cipher(SSL *ssl,STACK_OF(SSL_CIPHER) *clnt,
			       STACK_OF(SSL_CIPHER) *srvr);
d932 4
a935 4
long	ssl3_ctrl(SSL *s,int cmd, long larg, void *parg);
long	ssl3_ctx_ctrl(SSL_CTX *s,int cmd, long larg, void *parg);
long	ssl3_callback_ctrl(SSL *s,int cmd, void (*fp)(void));
long	ssl3_ctx_callback_ctrl(SSL_CTX *s,int cmd, void (*fp)(void));
d952 1
a952 1
int dtls1_do_write(SSL *s,int type);
d958 4
a961 4
	unsigned int len);
unsigned char *dtls1_set_message_header(SSL *s, 
	unsigned char *p, unsigned char mt,	unsigned long len, 
	unsigned long frag_off, unsigned long frag_len);
d971 2
a972 2
int dtls1_retransmit_message(SSL *s, unsigned short seq, 
	unsigned long frag_off, int *found);
d1049 2
a1050 2
long tls1_ctrl(SSL *s,int cmd, long larg, void *parg);
long tls1_callback_ctrl(SSL *s,int cmd, void (*fp)(void));
d1057 1
a1057 1
long dtls1_ctrl(SSL *s,int cmd, long larg, void *parg);
d1063 1
a1063 1
	unsigned int len, int create_empty_fragement);
d1073 1
a1073 2
int tls1_final_finish_mac(SSL *s,
	const char *str, int slen, unsigned char *p);
d1077 1
a1077 1
	unsigned char *p, int len);
d1079 2
a1080 2
	const char *label, size_t llen,
	const unsigned char *p, size_t plen, int use_context);
d1097 10
a1106 4
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *p, unsigned char *limit); 
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit); 
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **data, unsigned char *d, int n, int *al);
int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **data, unsigned char *d, int n, int *al);
d1119 1
a1119 1
				const unsigned char *limit, SSL_SESSION **ret);
d1122 1
a1122 1
				const EVP_MD *md);
d1127 1
a1127 1
EVP_MD_CTX* ssl_replace_hash(EVP_MD_CTX **hash,const EVP_MD *md) ;
d1129 8
a1136 8
int ssl_add_serverhello_renegotiate_ext(SSL *s, unsigned char *p, int *len,
					int maxlen);
int ssl_parse_serverhello_renegotiate_ext(SSL *s, unsigned char *d, int len,
					  int *al);
int ssl_add_clienthello_renegotiate_ext(SSL *s, unsigned char *p, int *len,
					int maxlen);
int ssl_parse_clienthello_renegotiate_ext(SSL *s, unsigned char *d, int len,
					  int *al);
d1141 8
a1148 4
int ssl_add_clienthello_use_srtp_ext(SSL *s, unsigned char *p, int *len, int maxlen);
int ssl_parse_clienthello_use_srtp_ext(SSL *s, unsigned char *d, int len,int *al);
int ssl_add_serverhello_use_srtp_ext(SSL *s, unsigned char *p, int *len, int maxlen);
int ssl_parse_serverhello_use_srtp_ext(SSL *s, unsigned char *d, int len,int *al);
d1151 6
a1156 11
void ssl3_cbc_copy_mac(unsigned char* out,
		       const SSL3_RECORD *rec,
		       unsigned md_size,unsigned orig_len);
int ssl3_cbc_remove_padding(const SSL* s,
			    SSL3_RECORD *rec,
			    unsigned block_size,
			    unsigned mac_size);
int tls1_cbc_remove_padding(const SSL* s,
			    SSL3_RECORD *rec,
			    unsigned block_size,
			    unsigned mac_size);
d1158 9
a1166 15
void ssl3_cbc_digest_record(
	const EVP_MD_CTX *ctx,
	unsigned char* md_out,
	size_t* md_out_size,
	const unsigned char header[13],
	const unsigned char *data,
	size_t data_plus_mac_size,
	size_t data_plus_mac_plus_padding_size,
	const unsigned char *mac_secret,
	unsigned mac_secret_length,
	char is_sslv3);

void tls_fips_digest_extra(
	const EVP_CIPHER_CTX *cipher_ctx, EVP_MD_CTX *mac_ctx,
	const unsigned char *data, size_t data_len, size_t orig_len);
@


1.23
log
@Cope with the removal of openssl/symhacks.h
@
text
@a1110 7
#ifndef OPENSSL_NO_HEARTBEATS
int tls1_heartbeat(SSL *s);
int dtls1_heartbeat(SSL *s);
int tls1_process_heartbeat(SSL *s);
int dtls1_process_heartbeat(SSL *s);
#endif

@


1.22
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@a169 1
#include <openssl/symhacks.h>
@


1.21
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d145 3
d152 1
d154 2
a155 2
#include "e_os.h"

@


1.20
log
@SECURITY fixes backported from openssl-1.0.1f.  ok mikeb@@

CVE-2013-4353 NULL pointer dereference with crafted Next Protocol
 Negotiation record in TLS handshake.
Upstream: 197e0ea

CVE-2013-6449 Fix crash with crafted traffic from a TLS 1.2 client.
Upstream: ca98926, 0294b2b

CVE-2013-6450 Fix DTLS retransmission from previous session.
Upstream: 3462896
@
text
@d844 2
a845 1
X509 *ssl_get_server_send_cert(SSL *);
d852 1
d1104 2
a1105 1
int ssl_check_clienthello_tlsext(SSL *s);
@


1.20.4.1
log
@MFC ChangeCipherSpec fixes (CVE-2014-0224 and additional safeguard), ok jsing@@

"Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret." From s3_clnt.c r1.64, s3_pkt.c r1.42,
s3_srvr.c r1.59, ssl3.h r1.19 - note that the ssl3.h change has been
applied to s3_locl.h instead to simplify patching.

"Ensure that we do not process a ChangeCipherSpec with an empty master
secret. This is an additional safeguard against early ChangeCipherSpec
handling."  From s3_pkt.c:1.43
@
text
@a167 6
/*
 * Macro defined here rather than in ssl.h for -stable, avoiding
 * the need to update installed headers before building.
 */
#define SSL3_FLAGS_CCS_OK	0x0080

@


1.19
log
@cherry pick bugfixes for http://www.openssl.org/news/secadv_20130205.txt
from the openssl git (changes between openssl 1.0.1c and 1.0.1d).
ok djm@@
@
text
@d624 2
@


1.19.4.1
log
@MFC ChangeCipherSpec fixes (CVE-2014-0224 and additional safeguard), ok jsing@@

"Be selective as to when ChangeCipherSpec messages will be accepted.
Without this an early ChangeCipherSpec message would result in session
keys being generated, along with the Finished hash for the handshake,
using an empty master secret." From s3_clnt.c r1.64, s3_pkt.c r1.42,
s3_srvr.c r1.59, ssl3.h r1.19 - note that the ssl3.h change has been
applied to s3_locl.h instead to simplify patching.

"Ensure that we do not process a ChangeCipherSpec with an empty master
secret. This is an additional safeguard against early ChangeCipherSpec
handling."  From s3_pkt.c:1.43
@
text
@a167 6
/*
 * Macro defined here rather than in ssl.h for -stable, avoiding
 * the need to update installed headers before building.
 */
#define SSL3_FLAGS_CCS_OK	0x0080

@


1.18
log
@resolve conflicts
@
text
@d218 9
d1142 29
@


1.17
log
@OpenSSL 1.0.0f: merge
@
text
@d173 1
a173 1
#define PKCS1_CHECK
d292 1
d320 2
d323 1
a323 1
#define SSL_AES        		(SSL_AES128|SSL_AES256)
d328 1
d333 4
d342 1
d350 2
d356 3
a358 1
#define SSL_MAX_DIGEST 4
d360 1
a360 1
#define TLS1_PRF_DGST_SHIFT 8
d363 2
d475 2
d574 4
d615 2
a616 1
#define IMPLEMENT_tls1_meth_func(func_name, s_accept, s_connect, s_get_meth) \
d620 1
a620 1
		TLS1_VERSION, \
d694 1
a694 1
	TLS1_VERSION, \
d777 1
a777 1
		ssl3_shutdown, \
d834 1
a834 1
EVP_PKEY *ssl_get_sign_pkey(SSL *,const SSL_CIPHER *);
d968 1
d994 3
d1015 3
d1045 1
d1066 3
d1074 1
a1074 1
int ssl_check_srvr_ecc_cert_and_alg(X509 *x, const SSL_CIPHER *cs);
d1094 7
d1108 6
d1125 9
@


1.16
log
@resolve conflicts, fix local changes
@
text
@d953 1
@


1.15
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d116 26
d280 2
a281 1
#define SSL_MKEY_MASK		0x000000FFL
d283 50
a332 47
#define SSL_kDHr		0x00000002L /* DH cert RSA CA cert */
#define SSL_kDHd		0x00000004L /* DH cert DSA CA cert */
#define SSL_kFZA		0x00000008L
#define SSL_kEDH		0x00000010L /* tmp DH key no DH cert */
#define SSL_kKRB5		0x00000020L /* Kerberos5 key exchange */
#define SSL_kECDH               0x00000040L /* ECDH w/ long-term keys */
#define SSL_kECDHE              0x00000080L /* ephemeral ECDH */
#define SSL_EDH			(SSL_kEDH|(SSL_AUTH_MASK^SSL_aNULL))

#define SSL_AUTH_MASK		0x00007F00L
#define SSL_aRSA		0x00000100L /* Authenticate with RSA */
#define SSL_aDSS 		0x00000200L /* Authenticate with DSS */
#define SSL_DSS 		SSL_aDSS
#define SSL_aFZA 		0x00000400L
#define SSL_aNULL 		0x00000800L /* no Authenticate, ADH */
#define SSL_aDH 		0x00001000L /* no Authenticate, ADH */
#define SSL_aKRB5               0x00002000L /* Authenticate with KRB5 */
#define SSL_aECDSA              0x00004000L /* Authenticate with ECDSA */

#define SSL_NULL		(SSL_eNULL)
#define SSL_ADH			(SSL_kEDH|SSL_aNULL)
#define SSL_RSA			(SSL_kRSA|SSL_aRSA)
#define SSL_DH			(SSL_kDHr|SSL_kDHd|SSL_kEDH)
#define SSL_ECDH		(SSL_kECDH|SSL_kECDHE)
#define SSL_FZA			(SSL_aFZA|SSL_kFZA|SSL_eFZA)
#define SSL_KRB5                (SSL_kKRB5|SSL_aKRB5)

#define SSL_ENC_MASK		0x1C3F8000L
#define SSL_DES			0x00008000L
#define SSL_3DES		0x00010000L
#define SSL_RC4			0x00020000L
#define SSL_RC2			0x00040000L
#define SSL_IDEA		0x00080000L
#define SSL_eFZA		0x00100000L
#define SSL_eNULL		0x00200000L
#define SSL_AES			0x04000000L
#define SSL_CAMELLIA		0x08000000L
#define SSL_SEED          	0x10000000L

#define SSL_MAC_MASK		0x00c00000L
#define SSL_MD5			0x00400000L
#define SSL_SHA1		0x00800000L
#define SSL_SHA			(SSL_SHA1)

#define SSL_SSL_MASK		0x03000000L
#define SSL_SSLV2		0x01000000L
#define SSL_SSLV3		0x02000000L
d335 23
a357 1
/* we have used 1fffffff - 3 bits left to go. */
d375 2
a379 1
#define SSL_STRONG_MASK		0x000000fcL
d413 1
a413 1
				 ((a)&SSL_ENC_MASK) == SSL_DES ? 8 : 7)
d415 1
a415 1
#define SSL_C_EXPORT_KEYLENGTH(c)	SSL_EXPORT_KEYLENGTH((c)->algorithms, \
d420 1
a420 4
#define SSL_ALL			0xffffffffL
#define SSL_ALL_CIPHERS		(SSL_MKEY_MASK|SSL_AUTH_MASK|SSL_ENC_MASK|\
				SSL_MAC_MASK)
#define SSL_ALL_STRENGTHS	(SSL_EXP_MASK|SSL_STRONG_MASK)
d429 3
a431 1
#define SSL_PKEY_NUM		6
d472 4
a475 2
	unsigned long mask;
	unsigned long export_mask;
d549 1
a549 1
	int (*final_finish_mac)(SSL *, EVP_MD_CTX *, EVP_MD_CTX *, const char *, int, unsigned char *);
d551 1
a551 1
	int (*cert_verify_mac)(SSL *, EVP_MD_CTX *, unsigned char *);
d569 14
d584 1
a584 1
OPENSSL_EXTERN SSL_CIPHER ssl2_ciphers[];
a588 3
SSL_METHOD *sslv2_base_method(void);
SSL_METHOD *sslv23_base_method(void);
SSL_METHOD *sslv3_base_method(void);
d595 1
a595 1
SSL_METHOD *func_name(void)  \
d597 1
a597 1
	static SSL_METHOD func_name##_data= { \
d632 1
a632 1
SSL_METHOD *func_name(void)  \
d634 1
a634 1
	static SSL_METHOD func_name##_data= { \
d669 1
a669 1
SSL_METHOD *func_name(void)  \
d671 1
a671 1
	static SSL_METHOD func_name##_data= { \
d706 1
a706 1
SSL_METHOD *func_name(void)  \
d708 1
a708 1
	static SSL_METHOD func_name##_data= { \
d743 1
a743 1
SSL_METHOD *func_name(void)  \
d745 1
a745 1
	static SSL_METHOD func_name##_data= { \
d762 1
a762 1
		ssl3_ctrl, \
d791 2
d805 2
a806 1
		       const EVP_MD **md,SSL_COMP **comp);
d812 1
a812 1
EVP_PKEY *ssl_get_sign_pkey(SSL *,SSL_CIPHER *);
d814 1
a814 1
void ssl_set_cert_masks(CERT *c, SSL_CIPHER *cipher);
d823 1
a823 1
SSL_CIPHER *ssl2_get_cipher_by_char(const unsigned char *p);
d831 1
a831 1
SSL_CIPHER *ssl2_get_cipher(unsigned int u);
d848 1
a848 1
SSL_CIPHER *ssl3_get_cipher_by_char(const unsigned char *p);
d860 1
a860 1
void ssl3_send_alert(SSL *s,int level, int desc);
d867 1
a867 1
SSL_CIPHER *ssl3_get_cipher(unsigned int u);
d873 2
a874 3
int ssl3_final_finish_mac(SSL *s, EVP_MD_CTX *ctx1, EVP_MD_CTX *ctx2,
	const char *sender, int slen,unsigned char *p);
int ssl3_cert_verify_mac(SSL *s, EVP_MD_CTX *in, unsigned char *p);
d877 2
a878 1
int ssl3_mac(SSL *ssl, unsigned char *md, int send_data);
d883 5
d908 1
a908 1
SSL_CIPHER *ssl23_get_cipher(unsigned int u);
d913 1
a913 1
SSL_CIPHER *ssl23_get_cipher_by_char(const unsigned char *p);
d938 2
d945 8
a952 3
SSL_CIPHER *dtls1_get_cipher(unsigned int u);


d962 1
a963 1
int ssl3_send_client_certificate(SSL *s);
d968 3
a1007 1
SSL_METHOD *tlsv1_base_method(void );
a1014 1
SSL_METHOD *dtlsv1_base_method(void );
d1029 1
a1029 1
int tls1_final_finish_mac(SSL *s, EVP_MD_CTX *in1_ctx, EVP_MD_CTX *in2_ctx,
d1031 1
a1031 1
int tls1_cert_verify_mac(SSL *s, EVP_MD_CTX *in, unsigned char *p);
d1039 3
a1041 1
int check_srvr_ecc_cert_and_alg(X509 *x, SSL_CIPHER *cs);
d1045 5
d1059 1
d1067 1
d1070 8
a1077 2
#endif

@


1.15.6.1
log
@Pull Ben Lauries blind prefix injection fix for CVE-2009-3555 from
openssl 0.9.8l.

As suggested by markus@@, for -stable the header change is being
restricted to a private file, so the minor version is not cranked here.

Discussed with markus, djm, deraadt.
@
text
@a403 2
#define SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION	0x0010

@


1.15.2.1
log
@Pull Ben Lauries blind prefix injection fix for CVE-2009-3555 from
openssl 0.9.8l.

As suggested by markus@@, for -stable the header change is being
restricted to a private file, so the minor version is not cranked here.

Discussed with markus, djm, deraadt.
@
text
@a403 2
#define SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION	0x0010

@


1.14
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d127 1
d129 1
d505 1
d513 1
@


1.13
log
@resolve conflicts
@
text
@d333 1
d335 1
a335 1
/* we have used 000000ff - 24 bits left to go */
d878 1
@


1.12
log
@resolve conflicts
@
text
@d111 5
a128 2
#include <openssl/crypto.h>
#include <openssl/evp.h>
d130 6
a135 1
#include <openssl/x509.h>
d183 14
d252 1
a252 1
#define SSL_MKEY_MASK		0x0000003FL
d259 2
d263 3
a265 3
#define SSL_AUTH_MASK		0x00000FC0L
#define SSL_aRSA		0x00000040L /* Authenticate with RSA */
#define SSL_aDSS 		0x00000080L /* Authenticate with DSS */
d267 5
a271 4
#define SSL_aFZA 		0x00000100L
#define SSL_aNULL 		0x00000200L /* no Authenticate, ADH */
#define SSL_aDH 		0x00000400L /* no Authenticate, ADH */
#define SSL_aKRB5               0x00000800L /* Authenticate with KRB5 */
d277 1
d281 15
a295 13
#define SSL_ENC_MASK		0x0087F000L
#define SSL_DES			0x00001000L
#define SSL_3DES		0x00002000L
#define SSL_RC4			0x00004000L
#define SSL_RC2			0x00008000L
#define SSL_IDEA		0x00010000L
#define SSL_eFZA		0x00020000L
#define SSL_eNULL		0x00040000L
#define SSL_AES			0x00800000L

#define SSL_MAC_MASK		0x00180000L
#define SSL_MD5			0x00080000L
#define SSL_SHA1		0x00100000L
d298 3
a300 3
#define SSL_SSL_MASK		0x00600000L
#define SSL_SSLV2		0x00200000L
#define SSL_SSLV3		0x00400000L
d303 1
a303 1
/* we have used 007fffff - 9 bits left to go */
a332 1
#define SSL_FIPS		0x00000100L
d334 1
a334 1
/* we have used 000001ff - 23 bits left to go */
d375 2
a376 1
#define SSL_PKEY_NUM		5
d392 9
d427 5
d457 3
a513 5
#ifdef OPENSSL_SYS_VMS
#undef SSL_COMP_get_compression_methods
#define SSL_COMP_get_compression_methods	SSL_COMP_get_compress_methods
#endif

d520 189
d719 1
a719 1
int ssl_get_prev_session(SSL *s, unsigned char *session,int len);
d736 1
d744 1
d754 1
a754 1
int ssl2_set_certificate(SSL *s, int type, int len, unsigned char *data);
d770 2
a771 2
long	ssl2_callback_ctrl(SSL *s,int cmd, void (*fp)());
long	ssl2_ctx_callback_ctrl(SSL_CTX *s,int cmd, void (*fp)());
d773 1
d779 2
d821 2
a822 2
long	ssl3_callback_ctrl(SSL *s,int cmd, void (*fp)());
long	ssl3_ctx_callback_ctrl(SSL_CTX *s,int cmd, void (*fp)());
d825 84
d918 1
a918 1
long tls1_callback_ctrl(SSL *s,int cmd, void (*fp)());
d921 15
d952 2
a954 1
STACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void);
d956 19
@


1.11
log
@resolve conflicts
@
text
@d465 1
a465 1
OPENSSL_EXTERN SSL3_ENC_METHOD ssl3_undef_enc_method;
d496 2
a497 1
int ssl_cipher_list_to_bytes(SSL *s,STACK_OF(SSL_CIPHER) *sk,unsigned char *p);
@


1.10
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d305 1
d307 1
a307 1
/* we have used 000000ff - 24 bits left to go */
d502 2
a503 2
int ssl_cipher_get_evp(SSL_SESSION *s,const EVP_CIPHER **enc,const EVP_MD **md,
		       SSL_COMP **comp);
d506 1
d540 1
a540 1
int	ssl2_pending(SSL *s);
d588 1
a588 1
int	ssl3_pending(SSL *s);
@


1.9
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d513 1
a513 1
void ssl2_generate_key_material(SSL *s);
a618 3
/* die if we have to */
void OpenSSLDie(const char *file,int line,const char *assertion);
#define die(e)	((e) ? (void)0 : OpenSSLDie(__FILE__, __LINE__, #e))
@


1.8
log
@merge with 0.9.7-beta1
@
text
@d296 3
a298 2
#define SSL_STRONG_MASK		0x0000007cL
#define SSL_EXP40		0x00000004L
d300 1
a300 1
#define SSL_EXP56		0x00000008L
d302 3
a304 3
#define SSL_LOW			0x00000010L
#define SSL_MEDIUM		0x00000020L
#define SSL_HIGH		0x00000040L
d306 1
a306 1
/* we have used 0000007f - 25 bits left to go */
@


1.7
log
@apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@d119 1
a119 1
#include <e_os.h> 
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d618 3
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
d119 1
a119 1
#include "openssl/e_os.h"
d130 6
d230 1
a230 1
#define SSL_MKEY_MASK		0x0000001FL
d236 1
d239 3
a241 3
#define SSL_AUTH_MASK		0x000003e0L
#define SSL_aRSA		0x00000020L /* Authenticate with RSA */
#define SSL_aDSS 		0x00000040L /* Authenticate with DSS */
d243 4
a246 3
#define SSL_aFZA 		0x00000080L
#define SSL_aNULL 		0x00000100L /* no Authenticate, ADH */
#define SSL_aDH 		0x00000200L /* no Authenticate, ADH */
d253 1
d255 13
a267 12
#define SSL_ENC_MASK		0x0001Fc00L
#define SSL_DES			0x00000400L
#define SSL_3DES		0x00000800L
#define SSL_RC4			0x00001000L
#define SSL_RC2			0x00002000L
#define SSL_IDEA		0x00004000L
#define SSL_eFZA		0x00008000L
#define SSL_eNULL		0x00010000L

#define SSL_MAC_MASK		0x00060000L
#define SSL_MD5			0x00020000L
#define SSL_SHA1		0x00040000L
d270 3
a272 3
#define SSL_SSL_MASK		0x00180000L
#define SSL_SSLV2		0x00080000L
#define SSL_SSLV3		0x00100000L
d275 1
a275 1
/* we have used 001fffff - 11 bits left to go */
d380 1
a380 1
#ifndef NO_RSA
d384 1
a384 1
#ifndef NO_DH
d407 1
a407 1
#ifndef NO_RSA
d410 1
a410 1
#ifndef NO_DH
d467 1
a467 1
#ifdef VMS
d469 1
a469 1
#define SSL_COMP_get_compression_methods SSL_COMP_get_compress_methods
d533 2
a534 2
long	ssl2_ctrl(SSL *s,int cmd, long larg, char *parg);
long	ssl2_ctx_ctrl(SSL_CTX *s,int cmd, long larg, char *parg);
d569 2
a570 2
SSL_CIPHER *ssl3_choose_cipher(SSL *ssl,STACK_OF(SSL_CIPHER) *have,
			       STACK_OF(SSL_CIPHER) *pref);
d581 2
a582 2
long	ssl3_ctrl(SSL *s,int cmd, long larg, char *parg);
long	ssl3_ctx_ctrl(SSL_CTX *s,int cmd, long larg, char *parg);
d595 1
a595 1
long tls1_ctrl(SSL *s,int cmd, long larg, char *parg);
@


1.5.4.1
log
@Pull in patch from current:
Fix (markus), errata 013:
apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@a607 3
/* die if we have to */
void OpenSSLDie(const char *file,int line,const char *assertion);
#define die(e)	((e) ? (void)0 : OpenSSLDie(__FILE__, __LINE__, #e))
@


1.5.2.1
log
@Errata #030 (markus):
Fixes for the "OpenSSL Security Advisory [30 July 2002]"
@
text
@a607 3
/* die if we have to */
void OpenSSLDie(const char *file,int line,const char *assertion);
#define die(e)	((e) ? (void)0 : OpenSSLDie(__FILE__, __LINE__, #e))
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d58 53
d519 1
a519 1
int	ssl2_peek(SSL *s, char *buf, int len);
d550 1
a550 1
int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len);
d567 1
a567 1
int	ssl3_peek(SSL *s,char *buf, int len);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d426 3
a428 2
int ssl_cipher_id_cmp(SSL_CIPHER *a,SSL_CIPHER *b);
int ssl_cipher_ptr_id_cmp(SSL_CIPHER **ap,SSL_CIPHER **bp);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d158 13
d207 58
a264 11
#define SSL_EXP_MASK		0x00300000L
#define SSL_EXP40		0x00100000L
#define SSL_NOT_EXP		0x00200000L
#define SSL_EXP56		0x00300000L
#define SSL_IS_EXPORT(a)	((a)&SSL_EXP40)
#define SSL_IS_EXPORT56(a)	(((a)&SSL_EXP_MASK) == SSL_EXP56)
#define SSL_IS_EXPORT40(a)	(((a)&SSL_EXP_MASK) == SSL_EXP40)
#define SSL_C_IS_EXPORT(c)	SSL_IS_EXPORT((c)->algorithms)
#define SSL_C_IS_EXPORT56(c)	SSL_IS_EXPORT56((c)->algorithms)
#define SSL_C_IS_EXPORT40(c)	SSL_IS_EXPORT40((c)->algorithms)
#define SSL_EXPORT_KEYLENGTH(a)	(SSL_IS_EXPORT40(a) ? 5 : \
d267 3
a269 2
#define SSL_C_EXPORT_KEYLENGTH(c)	SSL_EXPORT_KEYLENGTH((c)->algorithms)
#define SSL_C_EXPORT_PKEYLENGTH(c)	SSL_EXPORT_PKEYLENGTH((c)->algorithms)
a270 9
#define SSL_SSL_MASK		0x00c00000L
#define SSL_SSLV2		0x00400000L
#define SSL_SSLV3		0x00800000L
#define SSL_TLSV1		SSL_SSLV3	/* for now */

#define SSL_STRONG_MASK		0x07000000L
#define SSL_LOW			0x01000000L
#define SSL_MEDIUM		0x02000000L
#define SSL_HIGH		0x04000000L
a271 1
/* we have used 0fffffff - 4 bits left to go */
d274 2
a275 1
				SSL_MAC_MASK|SSL_EXP_MASK)
d309 3
a311 3
					 * Probably it would make more sense to store
					 * an index, not a pointer. */

d374 1
a374 1
 * an opaque strucute :-) */
d377 6
a382 6
	int (*enc)();
	int (*mac)();
	int (*setup_key_block)();
	int (*generate_master_secret)();
	int (*change_cipher_state)();
	int (*final_finish_mac)();
d384 6
a389 6
	int (*cert_verify_mac)();
	unsigned char client_finished[20];
	int client_finished_len;
	unsigned char server_finished[20];
	int server_finished_len;
	int (*alert_value)();
d395 1
a395 1
	int comp_id;	/* The identifer byte for this compression type */
d431 1
a431 1
STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(SSL_METHOD *meth,
d434 1
a434 1
					     char *str);
d471 2
d490 1
a490 1
int ssl3_send_finished(SSL *s, int a, int b, unsigned char *sender,int slen);
a496 1
int ssl3_part_read(SSL *s, int i);
d498 2
a499 2
int ssl3_final_finish_mac(SSL *s, EVP_MD_CTX *ctx1,EVP_MD_CTX *ctx2,
	unsigned char *sender, int slen,unsigned char *p);
d519 2
d532 1
d542 1
a542 1
	unsigned char *str, int slen, unsigned char *p);
@


1.1
log
@Initial revision
@
text
@d66 1
a66 1
#include "e_os.h"
d68 9
a76 8
#include "buffer.h"
#include "bio.h"
#include "crypto.h"
#include "evp.h"
#include "stack.h"
#include "x509.h"
#include "err.h"
#include "ssl.h"
d78 1
d131 12
a142 12
#define n2s(c,s)	(s =((unsigned int)(*((c)++)))<< 8, \
			 s|=((unsigned int)(*((c)++))))
#define s2n(s,c)	(*((c)++)=(unsigned char)(((s)>> 8)&0xff), \
			 *((c)++)=(unsigned char)(((s)    )&0xff))

#define n2l3(c,l)	(l =((unsigned long)(*((c)++)))<<16, \
			 l|=((unsigned long)(*((c)++)))<< 8, \
			 l|=((unsigned long)(*((c)++))))

#define l2n3(l,c)	(*((c)++)=(unsigned char)(((l)>>16)&0xff), \
			 *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
			 *((c)++)=(unsigned char)(((l)    )&0xff))
d195 1
a195 1
#define SSL_EXP			0x00100000L
d197 12
a208 1
#define SSL_EXPORT		SSL_EXP
d213 1
a249 1
/*	EVP_PKEY *publickey; *//* when extracted */
a254 12
	int cert_type;

#ifdef undef
	X509 *x509;
	EVP_PKEY *publickey; /* when extracted */
	EVP_PKEY *privatekey;

	pkeys[SSL_PKEY_RSA_ENC].x509
/*	pkeys[SSL_PKEY_RSA_ENC].publickey */
	pkeys[SSL_PKEY_RSA_ENC].privatekey
#endif

d256 3
a258 1
	CERT_PKEY *key;
d265 1
a265 1

d267 3
d271 3
a273 2
	RSA *(*rsa_tmp_cb)();
	DH *(*dh_tmp_cb)();
d276 25
a300 1
	STACK *cert_chain;
a301 2
	int references;
	} CERT;
a313 1
#ifndef NOPROTO
a314 4
#else
#define FP_ICC
#endif

d340 16
a355 3
extern SSL3_ENC_METHOD ssl3_undef_enc_method;
extern SSL_CIPHER ssl2_ciphers[];
extern SSL_CIPHER ssl3_ciphers[];
a356 1
#ifndef NOPROTO
d366 2
d369 3
a371 1
int ssl_set_cert_type(CERT *c, int type);
d376 7
a382 4
STACK *ssl_bytes_to_cipher_list(SSL *s,unsigned char *p,int num,STACK **skp);
int ssl_cipher_list_to_bytes(SSL *s,STACK *sk,unsigned char *p);
STACK *ssl_create_cipher_list(SSL_METHOD *meth,STACK **pref,
	STACK **sorted,char *str);
d384 3
a386 2
int ssl_cipher_get_evp(SSL_CIPHER *c, EVP_CIPHER **enc, EVP_MD **md);
int ssl_verify_cert_chain(SSL *s,STACK *sk);
d391 2
a392 2
void ssl_set_cert_masks(CERT *c);
STACK *ssl_get_ciphers_by_id(SSL *s);
d399 2
a400 2
SSL_CIPHER *ssl2_get_cipher_by_char(unsigned char *p);
int ssl2_put_cipher_by_char(SSL_CIPHER *c,unsigned char *p);
d412 1
a412 1
int	ssl2_read(SSL *s, char *buf, int len);
d414 1
a414 1
int	ssl2_write(SSL *s, char *buf, int len);
d421 2
a422 2
SSL_CIPHER *ssl3_get_cipher_by_char(unsigned char *p);
int ssl3_put_cipher_by_char(SSL_CIPHER *c,unsigned char *p);
d442 1
a442 1
int ssl3_read_bytes(SSL *s, int type, char *buf, int len);
d444 1
a444 1
int ssl3_write_bytes(SSL *s, int type, char *buf, int len);
d448 1
a448 1
void ssl3_finish_mac(SSL *s, unsigned char *buf, int len);
d452 2
a453 1
SSL_CIPHER *ssl3_choose_cipher(SSL *ssl,STACK *have,STACK *pref);
d459 1
a459 1
int	ssl3_read(SSL *s, char *buf, int len);
d461 1
a461 1
int	ssl3_write(SSL *s, char *buf, int len);
a478 1

d480 1
d493 1
d495 2
a497 107
#else

SSL_METHOD *ssl_bad_method();
SSL_METHOD *sslv2_base_method();
SSL_METHOD *sslv23_base_method();
SSL_METHOD *sslv3_base_method();

void ssl_clear_cipher_ctx();
int ssl_clear_bad_session();
CERT *ssl_cert_new();
void ssl_cert_free();
int ssl_set_cert_type();
int ssl_get_new_session();
int ssl_get_prev_session();
int ssl_cipher_id_cmp();
int ssl_cipher_ptr_id_cmp();
STACK *ssl_bytes_to_cipher_list();
int ssl_cipher_list_to_bytes();
STACK *ssl_create_cipher_list();
void ssl_update_cache();
int ssl_session_get_ciphers();
int ssl_verify_cert_chain();
int ssl_undefined_function();
X509 *ssl_get_server_send_cert();
EVP_PKEY *ssl_get_sign_pkey();
int ssl_cert_type();
void ssl_set_cert_masks();
STACK *ssl_get_ciphers_by_id();
int ssl_verify_alarm_type();

int ssl2_enc_init();
void ssl2_generate_key_material();
void ssl2_enc();
void ssl2_mac();
SSL_CIPHER *ssl2_get_cipher_by_char();
int ssl2_put_cipher_by_char();
int ssl2_part_read();
int ssl2_do_write();
int ssl2_set_certificate();
void ssl2_return_error();
void ssl2_write_error();
int ssl2_num_ciphers();
SSL_CIPHER *ssl2_get_cipher();
int	ssl2_new();
void	ssl2_free();
int	ssl2_accept();
int	ssl2_connect();
int	ssl2_read();
int	ssl2_peek();
int	ssl2_write();
int	ssl2_shutdown();
void	ssl2_clear();
long	ssl2_ctrl();
long	ssl2_ctx_ctrl();
int	ssl2_pending();

SSL_CIPHER *ssl3_get_cipher_by_char();
int ssl3_put_cipher_by_char();
void ssl3_init_finished_mac();
int ssl3_send_server_certificate();
int ssl3_get_finished();
int ssl3_setup_key_block();
int ssl3_send_change_cipher_spec();
int ssl3_change_cipher_state();
void ssl3_cleanup_key_block();
int ssl3_do_write();
void ssl3_send_alert();
int ssl3_generate_master_secret();
int ssl3_get_req_cert_type();
long ssl3_get_message();
int ssl3_send_finished();
int ssl3_num_ciphers();
SSL_CIPHER *ssl3_get_cipher();
int ssl3_renegotiate();
int ssl3_renegotiate_check();
int ssl3_dispatch_alert();
int ssl3_read_bytes();
int ssl3_part_read();
int ssl3_write_bytes();
int ssl3_final_finish_mac();
void ssl3_finish_mac();
int ssl3_enc();
int ssl3_mac();
unsigned long ssl3_output_cert_chain();
SSL_CIPHER *ssl3_choose_cipher();
int	ssl3_setup_buffers();
int	ssl3_new();
void	ssl3_free();
int	ssl3_accept();
int	ssl3_connect();
int	ssl3_read();
int	ssl3_peek();
int	ssl3_write();
int	ssl3_shutdown();
void	ssl3_clear();
long	ssl3_ctrl();
long	ssl3_ctx_ctrl();
int	ssl3_pending();

int ssl23_accept();
int ssl23_connect();
int ssl23_read_bytes();
int ssl23_write_bytes();

int ssl_init_wbio_buffer();

#endif
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d68 8
a75 15
#include <openssl/buffer.h>
#include <openssl/comp.h>
#include <openssl/bio.h>
#include <openssl/crypto.h>
#include <openssl/evp.h>
#include <openssl/stack.h>
#include <openssl/x509.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
#include <openssl/symhacks.h>

#ifdef OPENSSL_BUILD_SHLIBSSL
# undef OPENSSL_EXTERN
# define OPENSSL_EXTERN OPENSSL_EXPORT
#endif
a76 1
#define PKCS1_CHECK
d129 12
a140 12
#define n2s(c,s)	((s=(((unsigned int)(c[0]))<< 8)| \
			    (((unsigned int)(c[1]))    )),c+=2)
#define s2n(s,c)	((c[0]=(unsigned char)(((s)>> 8)&0xff), \
			  c[1]=(unsigned char)(((s)    )&0xff)),c+=2)

#define n2l3(c,l)	((l =(((unsigned long)(c[0]))<<16)| \
			     (((unsigned long)(c[1]))<< 8)| \
			     (((unsigned long)(c[2]))    )),c+=3)

#define l2n3(l,c)	((c[0]=(unsigned char)(((l)>>16)&0xff), \
			  c[1]=(unsigned char)(((l)>> 8)&0xff), \
			  c[2]=(unsigned char)(((l)    )&0xff)),c+=3)
d156 1
a156 14
/*
 * Define the Bitmasks for SSL_CIPHER.algorithms.
 * This bits are used packed as dense as possible. If new methods/ciphers
 * etc will be added, the bits a likely to change, so this information
 * is for internal library use only, even though SSL_CIPHER.algorithms
 * can be publicly accessed.
 * Use the according functions for cipher management instead.
 *
 * The bit mask handling in the selection and sorting scheme in
 * ssl_create_cipher_list() has only limited capabilities, reflecting
 * that the different entities within are mutually exclusive:
 * ONLY ONE BIT PER MASK CAN BE SET AT A TIME.
 */
#define SSL_MKEY_MASK		0x0000003FL
a161 1
#define SSL_kKRB5		0x00000020L /* Kerberos5 key exchange */
d164 3
a166 3
#define SSL_AUTH_MASK		0x00000FC0L
#define SSL_aRSA		0x00000040L /* Authenticate with RSA */
#define SSL_aDSS 		0x00000080L /* Authenticate with DSS */
d168 3
a170 4
#define SSL_aFZA 		0x00000100L
#define SSL_aNULL 		0x00000200L /* no Authenticate, ADH */
#define SSL_aDH 		0x00000400L /* no Authenticate, ADH */
#define SSL_aKRB5               0x00000800L /* Authenticate with KRB5 */
a176 1
#define SSL_KRB5                (SSL_kKRB5|SSL_aKRB5)
d178 12
a189 13
#define SSL_ENC_MASK		0x0087F000L
#define SSL_DES			0x00001000L
#define SSL_3DES		0x00002000L
#define SSL_RC4			0x00004000L
#define SSL_RC2			0x00008000L
#define SSL_IDEA		0x00010000L
#define SSL_eFZA		0x00020000L
#define SSL_eNULL		0x00040000L
#define SSL_AES			0x00800000L

#define SSL_MAC_MASK		0x00180000L
#define SSL_MD5			0x00080000L
#define SSL_SHA1		0x00100000L
d192 13
a204 64
#define SSL_SSL_MASK		0x00600000L
#define SSL_SSLV2		0x00200000L
#define SSL_SSLV3		0x00400000L
#define SSL_TLSV1		SSL_SSLV3	/* for now */

/* we have used 007fffff - 9 bits left to go */

/*
 * Export and cipher strength information. For each cipher we have to decide
 * whether it is exportable or not. This information is likely to change
 * over time, since the export control rules are no static technical issue.
 *
 * Independent of the export flag the cipher strength is sorted into classes.
 * SSL_EXP40 was denoting the 40bit US export limit of past times, which now
 * is at 56bit (SSL_EXP56). If the exportable cipher class is going to change
 * again (eg. to 64bit) the use of "SSL_EXP*" becomes blurred even more,
 * since SSL_EXP64 could be similar to SSL_LOW.
 * For this reason SSL_MICRO and SSL_MINI macros are included to widen the
 * namespace of SSL_LOW-SSL_HIGH to lower values. As development of speed
 * and ciphers goes, another extension to SSL_SUPER and/or SSL_ULTRA would
 * be possible.
 */
#define SSL_EXP_MASK		0x00000003L
#define SSL_NOT_EXP		0x00000001L
#define SSL_EXPORT		0x00000002L

#define SSL_STRONG_MASK		0x0000007cL
#define SSL_EXP40		0x00000004L
#define SSL_MICRO		(SSL_EXP40)
#define SSL_EXP56		0x00000008L
#define SSL_MINI		(SSL_EXP56)
#define SSL_LOW			0x00000010L
#define SSL_MEDIUM		0x00000020L
#define SSL_HIGH		0x00000040L

/* we have used 0000007f - 25 bits left to go */

/*
 * Macros to check the export status and cipher strength for export ciphers.
 * Even though the macros for EXPORT and EXPORT40/56 have similar names,
 * their meaning is different:
 * *_EXPORT macros check the 'exportable' status.
 * *_EXPORT40/56 macros are used to check whether a certain cipher strength
 *          is given.
 * Since the SSL_IS_EXPORT* and SSL_EXPORT* macros depend on the correct
 * algorithm structure element to be passed (algorithms, algo_strength) and no
 * typechecking can be done as they are all of type unsigned long, their
 * direct usage is discouraged.
 * Use the SSL_C_* macros instead.
 */
#define SSL_IS_EXPORT(a)	((a)&SSL_EXPORT)
#define SSL_IS_EXPORT56(a)	((a)&SSL_EXP56)
#define SSL_IS_EXPORT40(a)	((a)&SSL_EXP40)
#define SSL_C_IS_EXPORT(c)	SSL_IS_EXPORT((c)->algo_strength)
#define SSL_C_IS_EXPORT56(c)	SSL_IS_EXPORT56((c)->algo_strength)
#define SSL_C_IS_EXPORT40(c)	SSL_IS_EXPORT40((c)->algo_strength)

#define SSL_EXPORT_KEYLENGTH(a,s)	(SSL_IS_EXPORT40(s) ? 5 : \
				 ((a)&SSL_ENC_MASK) == SSL_DES ? 8 : 7)
#define SSL_EXPORT_PKEYLENGTH(a) (SSL_IS_EXPORT40(a) ? 512 : 1024)
#define SSL_C_EXPORT_KEYLENGTH(c)	SSL_EXPORT_KEYLENGTH((c)->algorithms, \
				(c)->algo_strength)
#define SSL_C_EXPORT_PKEYLENGTH(c)	SSL_EXPORT_PKEYLENGTH((c)->algo_strength)

d206 1
d209 1
a209 2
				SSL_MAC_MASK)
#define SSL_ALL_STRENGTHS	(SSL_EXP_MASK|SSL_STRONG_MASK)
d236 1
d242 12
d255 2
a256 4
	CERT_PKEY *key; /* ALWAYS points to an element of the pkeys array
			 * Probably it would make more sense to store
			 * an index, not a pointer. */
 
d262 1
a262 1
#ifndef OPENSSL_NO_RSA
a263 3
	RSA *(*rsa_tmp_cb)(SSL *ssl,int is_export,int keysize);
#endif
#ifndef OPENSSL_NO_DH
d265 3
a267 2
	DH *(*dh_tmp_cb)(SSL *ssl,int is_export,int keysize);
#endif
d269 1
a269 1
	CERT_PKEY pkeys[SSL_PKEY_NUM];
d271 1
a271 1
	int references; /* >1 only if SSL_copy_session_id is used */
a273 24

typedef struct sess_cert_st
	{
	STACK_OF(X509) *cert_chain; /* as received from peer (not for SSL2) */

	/* The 'peer_...' members are used only by clients. */
	int peer_cert_type;

	CERT_PKEY *peer_key; /* points to an element of peer_pkeys (never NULL!) */
	CERT_PKEY peer_pkeys[SSL_PKEY_NUM];
	/* Obviously we don't have the private keys of these,
	 * so maybe we shouldn't even use the CERT_PKEY type here. */

#ifndef OPENSSL_NO_RSA
	RSA *peer_rsa_tmp; /* not used for SSL 2 */
#endif
#ifndef OPENSSL_NO_DH
	DH *peer_dh_tmp; /* not used for SSL 2 */
#endif

	int references; /* actually always 1 at the moment */
	} SESS_CERT;


d285 1
d287 4
d298 1
a298 1
 * an opaque structure :-) */
d301 6
a306 6
	int (*enc)(SSL *, int);
	int (*mac)(SSL *, unsigned char *, int);
	int (*setup_key_block)(SSL *);
	int (*generate_master_secret)(SSL *, unsigned char *, unsigned char *, int);
	int (*change_cipher_state)(SSL *, int);
	int (*final_finish_mac)(SSL *, EVP_MD_CTX *, EVP_MD_CTX *, const char *, int, unsigned char *);
d308 6
a313 6
	int (*cert_verify_mac)(SSL *, EVP_MD_CTX *, unsigned char *);
	const char *client_finished_label;
	int client_finished_label_len;
	const char *server_finished_label;
	int server_finished_label_len;
	int (*alert_value)(int);
d316 3
a318 16
/* Used for holding the relevant compression methods loaded into SSL_CTX */
typedef struct ssl3_comp_st
	{
	int comp_id;	/* The identifier byte for this compression type */
	char *name;	/* Text name used for the compression type */
	COMP_METHOD *method; /* The method :-) */
	} SSL3_COMP;

OPENSSL_EXTERN SSL3_ENC_METHOD ssl3_undef_enc_method;
OPENSSL_EXTERN SSL_CIPHER ssl2_ciphers[];
OPENSSL_EXTERN SSL_CIPHER ssl3_ciphers[];

#ifdef OPENSSL_SYS_VMS
#undef SSL_COMP_get_compression_methods
#define SSL_COMP_get_compression_methods	SSL_COMP_get_compress_methods
#endif
d320 1
a329 2
CERT *ssl_cert_dup(CERT *cert);
int ssl_cert_inst(CERT **o);
d331 1
a331 3
SESS_CERT *ssl_sess_cert_new(void);
void ssl_sess_cert_free(SESS_CERT *sc);
int ssl_set_peer_cert_type(SESS_CERT *c, int type);
d334 6
a339 10
int ssl_cipher_id_cmp(const SSL_CIPHER *a,const SSL_CIPHER *b);
int ssl_cipher_ptr_id_cmp(const SSL_CIPHER * const *ap,
			const SSL_CIPHER * const *bp);
STACK_OF(SSL_CIPHER) *ssl_bytes_to_cipher_list(SSL *s,unsigned char *p,int num,
					       STACK_OF(SSL_CIPHER) **skp);
int ssl_cipher_list_to_bytes(SSL *s,STACK_OF(SSL_CIPHER) *sk,unsigned char *p);
STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(const SSL_METHOD *meth,
					     STACK_OF(SSL_CIPHER) **pref,
					     STACK_OF(SSL_CIPHER) **sorted,
					     const char *rule_str);
d341 2
a342 3
int ssl_cipher_get_evp(SSL_SESSION *s,const EVP_CIPHER **enc,const EVP_MD **md,
		       SSL_COMP **comp);
int ssl_verify_cert_chain(SSL *s,STACK_OF(X509) *sk);
d347 2
a348 2
void ssl_set_cert_masks(CERT *c, SSL_CIPHER *cipher);
STACK_OF(SSL_CIPHER) *ssl_get_ciphers_by_id(SSL *s);
d355 2
a356 2
SSL_CIPHER *ssl2_get_cipher_by_char(const unsigned char *p);
int ssl2_put_cipher_by_char(const SSL_CIPHER *c,unsigned char *p);
d368 3
a370 3
int	ssl2_read(SSL *s, void *buf, int len);
int	ssl2_peek(SSL *s, void *buf, int len);
int	ssl2_write(SSL *s, const void *buf, int len);
d373 2
a374 4
long	ssl2_ctrl(SSL *s,int cmd, long larg, void *parg);
long	ssl2_ctx_ctrl(SSL_CTX *s,int cmd, long larg, void *parg);
long	ssl2_callback_ctrl(SSL *s,int cmd, void (*fp)());
long	ssl2_ctx_callback_ctrl(SSL_CTX *s,int cmd, void (*fp)());
d377 2
a378 2
SSL_CIPHER *ssl3_get_cipher_by_char(const unsigned char *p);
int ssl3_put_cipher_by_char(const SSL_CIPHER *c,unsigned char *p);
d392 1
a392 1
int ssl3_send_finished(SSL *s, int a, int b, const char *sender,int slen);
d398 5
a402 4
int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek);
int ssl3_write_bytes(SSL *s, int type, const void *buf, int len);
int ssl3_final_finish_mac(SSL *s, EVP_MD_CTX *ctx1, EVP_MD_CTX *ctx2,
	const char *sender, int slen,unsigned char *p);
d404 1
a404 1
void ssl3_finish_mac(SSL *s, const unsigned char *buf, int len);
d408 1
a408 2
SSL_CIPHER *ssl3_choose_cipher(SSL *ssl,STACK_OF(SSL_CIPHER) *clnt,
			       STACK_OF(SSL_CIPHER) *srvr);
d414 3
a416 3
int	ssl3_read(SSL *s, void *buf, int len);
int	ssl3_peek(SSL *s, void *buf, int len);
int	ssl3_write(SSL *s, const void *buf, int len);
d419 2
a420 4
long	ssl3_ctrl(SSL *s,int cmd, long larg, void *parg);
long	ssl3_ctx_ctrl(SSL_CTX *s,int cmd, long larg, void *parg);
long	ssl3_callback_ctrl(SSL *s,int cmd, void (*fp)());
long	ssl3_ctx_callback_ctrl(SSL_CTX *s,int cmd, void (*fp)());
d431 1
a431 2
long tls1_ctrl(SSL *s,int cmd, long larg, void *parg);
long tls1_callback_ctrl(SSL *s,int cmd, void (*fp)());
d434 1
a435 1
void ssl_free_wbio_buffer(SSL *s);
d441 1
a441 1
	const char *str, int slen, unsigned char *p);
a447 1
int ssl_ok(SSL *s);
a448 2
SSL_COMP *ssl3_comp_find(STACK_OF(SSL_COMP) *sk, int n);
STACK_OF(SSL_COMP) *SSL_COMP_get_compression_methods(void);
d450 107
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d296 2
a297 3
#define SSL_STRONG_MASK		0x000000fcL
#define SSL_STRONG_NONE		0x00000004L
#define SSL_EXP40		0x00000008L
d299 1
a299 1
#define SSL_EXP56		0x00000010L
d301 3
a303 3
#define SSL_LOW			0x00000020L
#define SSL_MEDIUM		0x00000040L
#define SSL_HIGH		0x00000080L
d305 1
a305 1
/* we have used 000000ff - 24 bits left to go */
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d513 1
a513 1
int ssl2_generate_key_material(SSL *s);
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a304 1
#define SSL_FIPS		0x00000100L
d306 1
a306 1
/* we have used 000001ff - 23 bits left to go */
d501 2
a502 2
int ssl_cipher_get_evp(const SSL_SESSION *s,const EVP_CIPHER **enc,
		       const EVP_MD **md,SSL_COMP **comp);
a504 1
int ssl_undefined_const_function(const SSL *s);
d538 1
a538 1
int	ssl2_pending(const SSL *s);
d586 1
a586 1
int	ssl3_pending(const SSL *s);
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@d465 1
a465 1
extern SSL3_ENC_METHOD ssl3_undef_enc_method;
d496 1
a496 2
int ssl_cipher_list_to_bytes(SSL *s,STACK_OF(SSL_CIPHER) *sk,unsigned char *p,
                             int (*put_cb)(const SSL_CIPHER *, unsigned char *));
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@a110 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
d124 2
d127 1
a127 6
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
a174 14
#define l2n6(l,c)	(*((c)++)=(unsigned char)(((l)>>40)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>32)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>24)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>16)&0xff), \
			 *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
			 *((c)++)=(unsigned char)(((l)    )&0xff))

#define n2l6(c,l)	(l =((BN_ULLONG)(*((c)++)))<<40, \
			 l|=((BN_ULLONG)(*((c)++)))<<32, \
			 l|=((BN_ULLONG)(*((c)++)))<<24, \
			 l|=((BN_ULLONG)(*((c)++)))<<16, \
			 l|=((BN_ULLONG)(*((c)++)))<< 8, \
			 l|=((BN_ULLONG)(*((c)++))))

d230 1
a230 1
#define SSL_MKEY_MASK		0x000000FFL
a236 2
#define SSL_kECDH               0x00000040L /* ECDH w/ long-term keys */
#define SSL_kECDHE              0x00000080L /* ephemeral ECDH */
d239 3
a241 3
#define SSL_AUTH_MASK		0x00007F00L
#define SSL_aRSA		0x00000100L /* Authenticate with RSA */
#define SSL_aDSS 		0x00000200L /* Authenticate with DSS */
d243 4
a246 5
#define SSL_aFZA 		0x00000400L
#define SSL_aNULL 		0x00000800L /* no Authenticate, ADH */
#define SSL_aDH 		0x00001000L /* no Authenticate, ADH */
#define SSL_aKRB5               0x00002000L /* Authenticate with KRB5 */
#define SSL_aECDSA              0x00004000L /* Authenticate with ECDSA */
a251 1
#define SSL_ECDH		(SSL_kECDH|SSL_kECDHE)
d255 13
a267 15
#define SSL_ENC_MASK		0x1C3F8000L
#define SSL_DES			0x00008000L
#define SSL_3DES		0x00010000L
#define SSL_RC4			0x00020000L
#define SSL_RC2			0x00040000L
#define SSL_IDEA		0x00080000L
#define SSL_eFZA		0x00100000L
#define SSL_eNULL		0x00200000L
#define SSL_AES			0x04000000L
#define SSL_CAMELLIA		0x08000000L
#define SSL_SEED          	0x10000000L

#define SSL_MAC_MASK		0x00c00000L
#define SSL_MD5			0x00400000L
#define SSL_SHA1		0x00800000L
d270 3
a272 3
#define SSL_SSL_MASK		0x03000000L
#define SSL_SSLV2		0x01000000L
#define SSL_SSLV3		0x02000000L
d275 1
a275 1
/* we have used 1fffffff - 3 bits left to go. */
d305 1
d307 1
a307 1
/* we have used 000000ff - 24 bits left to go */
d348 1
a348 2
#define SSL_PKEY_ECC            5
#define SSL_PKEY_NUM		6
a363 9
#ifndef OPENSSL_NO_EC
/* From ECC-TLS draft, used in encoding the curve type in 
 * ECParameters
 */
#define EXPLICIT_PRIME_CURVE_TYPE  1   
#define EXPLICIT_CHAR2_CURVE_TYPE  2
#define NAMED_CURVE_TYPE           3
#endif  /* OPENSSL_NO_EC */

a389 5
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh_tmp;
	/* Callback for generating ephemeral ECDH keys */
	EC_KEY *(*ecdh_tmp_cb)(SSL *ssl,int is_export,int keysize);
#endif
a414 3
#ifndef OPENSSL_NO_ECDH
	EC_KEY *peer_ecdh_tmp;
#endif
d469 5
a479 189
extern SSL3_ENC_METHOD TLSv1_enc_data;
extern SSL3_ENC_METHOD SSLv3_enc_data;
extern SSL3_ENC_METHOD DTLSv1_enc_data;

#define IMPLEMENT_tls1_meth_func(func_name, s_accept, s_connect, s_get_meth) \
SSL_METHOD *func_name(void)  \
	{ \
	static SSL_METHOD func_name##_data= { \
		TLS1_VERSION, \
		tls1_new, \
		tls1_clear, \
		tls1_free, \
		s_accept, \
		s_connect, \
		ssl3_read, \
		ssl3_peek, \
		ssl3_write, \
		ssl3_shutdown, \
		ssl3_renegotiate, \
		ssl3_renegotiate_check, \
		ssl3_get_message, \
		ssl3_read_bytes, \
		ssl3_write_bytes, \
		ssl3_dispatch_alert, \
		ssl3_ctrl, \
		ssl3_ctx_ctrl, \
		ssl3_get_cipher_by_char, \
		ssl3_put_cipher_by_char, \
		ssl3_pending, \
		ssl3_num_ciphers, \
		ssl3_get_cipher, \
		s_get_meth, \
		tls1_default_timeout, \
		&TLSv1_enc_data, \
		ssl_undefined_void_function, \
		ssl3_callback_ctrl, \
		ssl3_ctx_callback_ctrl, \
	}; \
	return &func_name##_data; \
	}

#define IMPLEMENT_ssl3_meth_func(func_name, s_accept, s_connect, s_get_meth) \
SSL_METHOD *func_name(void)  \
	{ \
	static SSL_METHOD func_name##_data= { \
		SSL3_VERSION, \
		ssl3_new, \
		ssl3_clear, \
		ssl3_free, \
		s_accept, \
		s_connect, \
		ssl3_read, \
		ssl3_peek, \
		ssl3_write, \
		ssl3_shutdown, \
		ssl3_renegotiate, \
		ssl3_renegotiate_check, \
		ssl3_get_message, \
		ssl3_read_bytes, \
		ssl3_write_bytes, \
		ssl3_dispatch_alert, \
		ssl3_ctrl, \
		ssl3_ctx_ctrl, \
		ssl3_get_cipher_by_char, \
		ssl3_put_cipher_by_char, \
		ssl3_pending, \
		ssl3_num_ciphers, \
		ssl3_get_cipher, \
		s_get_meth, \
		ssl3_default_timeout, \
		&SSLv3_enc_data, \
		ssl_undefined_void_function, \
		ssl3_callback_ctrl, \
		ssl3_ctx_callback_ctrl, \
	}; \
	return &func_name##_data; \
	}

#define IMPLEMENT_ssl23_meth_func(func_name, s_accept, s_connect, s_get_meth) \
SSL_METHOD *func_name(void)  \
	{ \
	static SSL_METHOD func_name##_data= { \
	TLS1_VERSION, \
	tls1_new, \
	tls1_clear, \
	tls1_free, \
	s_accept, \
	s_connect, \
	ssl23_read, \
	ssl23_peek, \
	ssl23_write, \
	ssl_undefined_function, \
	ssl_undefined_function, \
	ssl_ok, \
	ssl3_get_message, \
	ssl3_read_bytes, \
	ssl3_write_bytes, \
	ssl3_dispatch_alert, \
	ssl3_ctrl, \
	ssl3_ctx_ctrl, \
	ssl23_get_cipher_by_char, \
	ssl23_put_cipher_by_char, \
	ssl_undefined_const_function, \
	ssl23_num_ciphers, \
	ssl23_get_cipher, \
	s_get_meth, \
	ssl23_default_timeout, \
	&ssl3_undef_enc_method, \
	ssl_undefined_void_function, \
	ssl3_callback_ctrl, \
	ssl3_ctx_callback_ctrl, \
	}; \
	return &func_name##_data; \
	}

#define IMPLEMENT_ssl2_meth_func(func_name, s_accept, s_connect, s_get_meth) \
SSL_METHOD *func_name(void)  \
	{ \
	static SSL_METHOD func_name##_data= { \
		SSL2_VERSION, \
		ssl2_new,	/* local */ \
		ssl2_clear,	/* local */ \
		ssl2_free,	/* local */ \
		s_accept, \
		s_connect, \
		ssl2_read, \
		ssl2_peek, \
		ssl2_write, \
		ssl2_shutdown, \
		ssl_ok,	/* NULL - renegotiate */ \
		ssl_ok,	/* NULL - check renegotiate */ \
		NULL, /* NULL - ssl_get_message */ \
		NULL, /* NULL - ssl_get_record */ \
		NULL, /* NULL - ssl_write_bytes */ \
		NULL, /* NULL - dispatch_alert */ \
		ssl2_ctrl,	/* local */ \
		ssl2_ctx_ctrl,	/* local */ \
		ssl2_get_cipher_by_char, \
		ssl2_put_cipher_by_char, \
		ssl2_pending, \
		ssl2_num_ciphers, \
		ssl2_get_cipher, \
		s_get_meth, \
		ssl2_default_timeout, \
		&ssl3_undef_enc_method, \
		ssl_undefined_void_function, \
		ssl2_callback_ctrl,	/* local */ \
		ssl2_ctx_callback_ctrl,	/* local */ \
	}; \
	return &func_name##_data; \
	}

#define IMPLEMENT_dtls1_meth_func(func_name, s_accept, s_connect, s_get_meth) \
SSL_METHOD *func_name(void)  \
	{ \
	static SSL_METHOD func_name##_data= { \
		DTLS1_VERSION, \
		dtls1_new, \
		dtls1_clear, \
		dtls1_free, \
		s_accept, \
		s_connect, \
		ssl3_read, \
		ssl3_peek, \
		ssl3_write, \
		ssl3_shutdown, \
		ssl3_renegotiate, \
		ssl3_renegotiate_check, \
		dtls1_get_message, \
		dtls1_read_bytes, \
		dtls1_write_app_data_bytes, \
		dtls1_dispatch_alert, \
		ssl3_ctrl, \
		ssl3_ctx_ctrl, \
		ssl3_get_cipher_by_char, \
		ssl3_put_cipher_by_char, \
		ssl3_pending, \
		ssl3_num_ciphers, \
		dtls1_get_cipher, \
		s_get_meth, \
		dtls1_default_timeout, \
		&DTLSv1_enc_data, \
		ssl_undefined_void_function, \
		ssl3_callback_ctrl, \
		ssl3_ctx_callback_ctrl, \
	}; \
	return &func_name##_data; \
	}

d490 1
a490 1
int ssl_get_prev_session(SSL *s, unsigned char *session,int len, const unsigned char *limit);
a506 1
int ssl_undefined_void_function(void);
a513 1
void ssl_load_ciphers(void);
d523 1
a523 1
int ssl2_set_certificate(SSL *s, int type, int len, const unsigned char *data);
d539 2
a540 2
long	ssl2_callback_ctrl(SSL *s,int cmd, void (*fp)(void));
long	ssl2_ctx_callback_ctrl(SSL_CTX *s,int cmd, void (*fp)(void));
a541 1
long	ssl2_default_timeout(void );
a546 2
int ssl3_send_newsession_ticket(SSL *s);
int ssl3_send_cert_status(SSL *s);
d587 2
a588 2
long	ssl3_callback_ctrl(SSL *s,int cmd, void (*fp)(void));
long	ssl3_ctx_callback_ctrl(SSL_CTX *s,int cmd, void (*fp)(void));
a590 84
void ssl3_record_sequence_update(unsigned char *seq);
int ssl3_do_change_cipher_spec(SSL *ssl);
long ssl3_default_timeout(void );

int ssl23_num_ciphers(void );
SSL_CIPHER *ssl23_get_cipher(unsigned int u);
int ssl23_read(SSL *s, void *buf, int len);
int ssl23_peek(SSL *s, void *buf, int len);
int ssl23_write(SSL *s, const void *buf, int len);
int ssl23_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p);
SSL_CIPHER *ssl23_get_cipher_by_char(const unsigned char *p);
long ssl23_default_timeout(void );

long tls1_default_timeout(void);
int dtls1_do_write(SSL *s,int type);
int ssl3_read_n(SSL *s, int n, int max, int extend);
int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek);
int ssl3_do_compress(SSL *ssl);
int ssl3_do_uncompress(SSL *ssl);
int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
	unsigned int len);
unsigned char *dtls1_set_message_header(SSL *s, 
	unsigned char *p, unsigned char mt,	unsigned long len, 
	unsigned long frag_off, unsigned long frag_len);

int dtls1_write_app_data_bytes(SSL *s, int type, const void *buf, int len);
int dtls1_write_bytes(SSL *s, int type, const void *buf, int len);

int dtls1_send_change_cipher_spec(SSL *s, int a, int b);
int dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen);
unsigned long dtls1_output_cert_chain(SSL *s, X509 *x);
int dtls1_read_failed(SSL *s, int code);
int dtls1_buffer_message(SSL *s, int ccs);
int dtls1_retransmit_message(SSL *s, unsigned short seq, 
	unsigned long frag_off, int *found);
void dtls1_clear_record_buffer(SSL *s);
void dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr);
void dtls1_get_ccs_header(unsigned char *data, struct ccs_header_st *ccs_hdr);
void dtls1_reset_seq_numbers(SSL *s, int rw);
long dtls1_default_timeout(void);
SSL_CIPHER *dtls1_get_cipher(unsigned int u);



/* some client-only functions */
int ssl3_client_hello(SSL *s);
int ssl3_get_server_hello(SSL *s);
int ssl3_get_certificate_request(SSL *s);
int ssl3_get_new_session_ticket(SSL *s);
int ssl3_get_cert_status(SSL *s);
int ssl3_get_server_done(SSL *s);
int ssl3_send_client_verify(SSL *s);
int ssl3_send_client_certificate(SSL *s);
int ssl3_send_client_key_exchange(SSL *s);
int ssl3_get_key_exchange(SSL *s);
int ssl3_get_server_certificate(SSL *s);
int ssl3_check_cert_and_algorithm(SSL *s);

int dtls1_client_hello(SSL *s);
int dtls1_send_client_certificate(SSL *s);
int dtls1_send_client_key_exchange(SSL *s);
int dtls1_send_client_verify(SSL *s);

/* some server-only functions */
int ssl3_get_client_hello(SSL *s);
int ssl3_send_server_hello(SSL *s);
int ssl3_send_hello_request(SSL *s);
int ssl3_send_server_key_exchange(SSL *s);
int ssl3_send_certificate_request(SSL *s);
int ssl3_send_server_done(SSL *s);
int ssl3_check_client_hello(SSL *s);
int ssl3_get_client_certificate(SSL *s);
int ssl3_get_client_key_exchange(SSL *s);
int ssl3_get_cert_verify(SSL *s);

int dtls1_send_hello_request(SSL *s);
int dtls1_send_server_hello(SSL *s);
int dtls1_send_server_certificate(SSL *s);
int dtls1_send_server_key_exchange(SSL *s);
int dtls1_send_certificate_request(SSL *s);
int dtls1_send_server_done(SSL *s);



d600 1
a600 1
long tls1_callback_ctrl(SSL *s,int cmd, void (*fp)(void));
a602 15
int dtls1_new(SSL *s);
int	dtls1_accept(SSL *s);
int	dtls1_connect(SSL *s);
void dtls1_free(SSL *s);
void dtls1_clear(SSL *s);
long dtls1_ctrl(SSL *s,int cmd, long larg, void *parg);
SSL_METHOD *dtlsv1_base_method(void );

long dtls1_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok);
int dtls1_get_record(SSL *s);
int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
	unsigned int len, int create_empty_fragement);
int dtls1_dispatch_alert(SSL *s);
int dtls1_enc(SSL *s, int snd);

a618 2
int check_srvr_ecc_cert_and_alg(X509 *x, SSL_CIPHER *cs);

d620 1
a621 19
#ifndef OPENSSL_NO_TLSEXT
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *p, unsigned char *limit); 
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit); 
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **data, unsigned char *d, int n, int *al);
int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **data, unsigned char *d, int n, int *al);
int ssl_prepare_clienthello_tlsext(SSL *s);
int ssl_prepare_serverhello_tlsext(SSL *s);
int ssl_check_clienthello_tlsext(SSL *s);
int ssl_check_serverhello_tlsext(SSL *s);
#ifdef OPENSSL_NO_SHA256
#define tlsext_tick_md	EVP_sha1
#else
#define tlsext_tick_md	EVP_sha256
#endif
int tls1_process_ticket(SSL *s, unsigned char *session_id, int len,
				const unsigned char *limit, SSL_SESSION **ret);
EVP_MD_CTX* ssl_replace_hash(EVP_MD_CTX **hash,const EVP_MD *md) ;
void ssl_clear_hash_ctx(EVP_MD_CTX **hash);
#endif
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a126 1
#ifndef OPENSSL_NO_COMP
a127 1
#endif
a332 1
#define SSL_FIPS		0x00000100L
d334 1
a334 1
/* we have used 000001ff - 23 bits left to go */
a501 1
#ifndef OPENSSL_NO_COMP
a508 1
#endif
a876 1
int ssl_do_client_cert_cb(SSL *s, X509 **px509, EVP_PKEY **ppkey);
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
a115 26
/* ====================================================================
 * Copyright 2005 Nokia. All rights reserved.
 *
 * The portions of the attached software ("Contribution") is developed by
 * Nokia Corporation and is licensed pursuant to the OpenSSL open source
 * license.
 *
 * The Contribution, originally written by Mika Kousa and Pasi Eronen of
 * Nokia Corporation, consists of the "PSK" (Pre-Shared Key) ciphersuites
 * support (see RFC 4279) to OpenSSL.
 *
 * No patent licenses or other rights except those expressly stated in
 * the OpenSSL open source license shall be deemed granted or received
 * expressly, by implication, estoppel, or otherwise.
 *
 * No assurances are provided by Nokia that the Contribution does not
 * infringe the patent or other intellectual property rights of any third
 * party or that the license provides you with all the necessary rights
 * to make use of the Contribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. IN
 * ADDITION TO THE DISCLAIMERS INCLUDED IN THE LICENSE, NOKIA
 * SPECIFICALLY DISCLAIMS ANY LIABILITY FOR CLAIMS BROUGHT BY YOU OR ANY
 * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
 * OTHERWISE.
 */
d254 1
a254 2

/* Bits for algorithm_mkey (key exchange algorithm) */
d256 47
a302 50
#define SSL_kDHr		0x00000002L /* DH cert, RSA CA cert */ /* no such ciphersuites supported! */
#define SSL_kDHd		0x00000004L /* DH cert, DSA CA cert */ /* no such ciphersuite supported! */
#define SSL_kEDH		0x00000008L /* tmp DH key no DH cert */
#define SSL_kKRB5		0x00000010L /* Kerberos5 key exchange */
#define SSL_kECDHr		0x00000020L /* ECDH cert, RSA CA cert */
#define SSL_kECDHe		0x00000040L /* ECDH cert, ECDSA CA cert */
#define SSL_kEECDH		0x00000080L /* ephemeral ECDH */
#define SSL_kPSK		0x00000100L /* PSK */
#define SSL_kGOST       0x00000200L /* GOST key exchange */

/* Bits for algorithm_auth (server authentication) */
#define SSL_aRSA		0x00000001L /* RSA auth */
#define SSL_aDSS 		0x00000002L /* DSS auth */
#define SSL_aNULL 		0x00000004L /* no auth (i.e. use ADH or AECDH) */
#define SSL_aDH 		0x00000008L /* Fixed DH auth (kDHd or kDHr) */ /* no such ciphersuites supported! */
#define SSL_aECDH 		0x00000010L /* Fixed ECDH auth (kECDHe or kECDHr) */
#define SSL_aKRB5               0x00000020L /* KRB5 auth */
#define SSL_aECDSA              0x00000040L /* ECDSA auth*/
#define SSL_aPSK                0x00000080L /* PSK auth */
#define SSL_aGOST94				0x00000100L /* GOST R 34.10-94 signature auth */
#define SSL_aGOST01 			0x00000200L /* GOST R 34.10-2001 signature auth */


/* Bits for algorithm_enc (symmetric encryption) */
#define SSL_DES			0x00000001L
#define SSL_3DES		0x00000002L
#define SSL_RC4			0x00000004L
#define SSL_RC2			0x00000008L
#define SSL_IDEA		0x00000010L
#define SSL_eNULL		0x00000020L
#define SSL_AES128		0x00000040L
#define SSL_AES256		0x00000080L
#define SSL_CAMELLIA128		0x00000100L
#define SSL_CAMELLIA256		0x00000200L
#define SSL_eGOST2814789CNT	0x00000400L
#define SSL_SEED		0x00000800L

#define SSL_AES        		(SSL_AES128|SSL_AES256)
#define SSL_CAMELLIA		(SSL_CAMELLIA128|SSL_CAMELLIA256)


/* Bits for algorithm_mac (symmetric authentication) */
#define SSL_MD5			0x00000001L
#define SSL_SHA1		0x00000002L
#define SSL_GOST94      0x00000004L
#define SSL_GOST89MAC   0x00000008L

/* Bits for algorithm_ssl (protocol version) */
#define SSL_SSLV2		0x00000001L
#define SSL_SSLV3		0x00000002L
d305 1
a305 23

/* Bits for algorithm2 (handshake digests and other extra flags) */

#define SSL_HANDSHAKE_MAC_MD5 0x10
#define SSL_HANDSHAKE_MAC_SHA 0x20
#define SSL_HANDSHAKE_MAC_GOST94 0x40
#define SSL_HANDSHAKE_MAC_DEFAULT (SSL_HANDSHAKE_MAC_MD5 | SSL_HANDSHAKE_MAC_SHA)

/* When adding new digest in the ssl_ciph.c and increment SSM_MD_NUM_IDX
 * make sure to update this constant too */
#define SSL_MAX_DIGEST 4

#define TLS1_PRF_DGST_SHIFT 8
#define TLS1_PRF_MD5 (SSL_HANDSHAKE_MAC_MD5 << TLS1_PRF_DGST_SHIFT)
#define TLS1_PRF_SHA1 (SSL_HANDSHAKE_MAC_SHA << TLS1_PRF_DGST_SHIFT)
#define TLS1_PRF_GOST94 (SSL_HANDSHAKE_MAC_GOST94 << TLS1_PRF_DGST_SHIFT)
#define TLS1_PRF (TLS1_PRF_MD5 | TLS1_PRF_SHA1)

/* Stream MAC for GOST ciphersuites from cryptopro draft
 * (currently this also goes into algorithm2) */
#define TLS1_STREAM_MAC 0x04


a322 2
#define SSL_STRONG_MASK		0x000001fcL

d326 1
d360 1
a360 1
				 (a) == SSL_DES ? 8 : 7)
d362 1
a362 1
#define SSL_C_EXPORT_KEYLENGTH(c)	SSL_EXPORT_KEYLENGTH((c)->algorithm_enc, \
d367 4
a370 1

d379 1
a379 3
#define SSL_PKEY_GOST94		6
#define SSL_PKEY_GOST01		7
#define SSL_PKEY_NUM		8
d420 2
a421 4
	unsigned long mask_k;
	unsigned long mask_a;
	unsigned long export_mask_k;
	unsigned long export_mask_a;
d495 1
a495 1
	int (*final_finish_mac)(SSL *,  const char *, int, unsigned char *);
d497 1
a497 1
	int (*cert_verify_mac)(SSL *, int, unsigned char *);
a514 14
#ifndef OPENSSL_NO_BUF_FREELISTS
typedef struct ssl3_buf_freelist_st
	{
	size_t chunklen;
	unsigned int len;
	struct ssl3_buf_freelist_entry_st *head;
	} SSL3_BUF_FREELIST;

typedef struct ssl3_buf_freelist_entry_st
	{
	struct ssl3_buf_freelist_entry_st *next;
	} SSL3_BUF_FREELIST_ENTRY;
#endif

d516 1
a516 1
OPENSSL_EXTERN const SSL_CIPHER ssl2_ciphers[];
d521 3
d530 1
a530 1
const SSL_METHOD *func_name(void)  \
d532 1
a532 1
	static const SSL_METHOD func_name##_data= { \
d567 1
a567 1
const SSL_METHOD *func_name(void)  \
d569 1
a569 1
	static const SSL_METHOD func_name##_data= { \
d604 1
a604 1
const SSL_METHOD *func_name(void)  \
d606 1
a606 1
	static const SSL_METHOD func_name##_data= { \
d641 1
a641 1
const SSL_METHOD *func_name(void)  \
d643 1
a643 1
	static const SSL_METHOD func_name##_data= { \
d678 1
a678 1
const SSL_METHOD *func_name(void)  \
d680 1
a680 1
	static const SSL_METHOD func_name##_data= { \
d697 1
a697 1
		dtls1_ctrl, \
a725 2
DECLARE_OBJ_BSEARCH_GLOBAL_CMP_FN(SSL_CIPHER, SSL_CIPHER,
				  ssl_cipher_id);
d738 1
a738 2
		       const EVP_MD **md,int *mac_pkey_type,int *mac_secret_size, SSL_COMP **comp);
int ssl_get_handshake_digest(int i,long *mask,const EVP_MD **md);			   
d744 1
a744 1
EVP_PKEY *ssl_get_sign_pkey(SSL *,const SSL_CIPHER *);
d746 1
a746 1
void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher);
d755 1
a755 1
const SSL_CIPHER *ssl2_get_cipher_by_char(const unsigned char *p);
d763 1
a763 1
const SSL_CIPHER *ssl2_get_cipher(unsigned int u);
d780 1
a780 1
const SSL_CIPHER *ssl3_get_cipher_by_char(const unsigned char *p);
d792 1
a792 1
int ssl3_send_alert(SSL *s,int level, int desc);
d799 1
a799 1
const SSL_CIPHER *ssl3_get_cipher(unsigned int u);
d805 3
a807 2
int ssl3_final_finish_mac(SSL *s, const char *sender, int slen,unsigned char *p);
int ssl3_cert_verify_mac(SSL *s, int md_nid, unsigned char *p);
d810 1
a810 2
int n_ssl3_mac(SSL *ssl, unsigned char *md, int send_data);
void ssl3_free_digest_list(SSL *s);
a814 5
int	ssl3_setup_read_buffer(SSL *s);
int	ssl3_setup_write_buffer(SSL *s);
int	ssl3_release_read_buffer(SSL *s);
int	ssl3_release_write_buffer(SSL *s);
int	ssl3_digest_cached_records(SSL *s);
d835 1
a835 1
const SSL_CIPHER *ssl23_get_cipher(unsigned int u);
d840 1
a840 1
const SSL_CIPHER *ssl23_get_cipher_by_char(const unsigned char *p);
a864 2
int dtls1_get_queue_priority(unsigned short seq, int is_ccs);
int dtls1_retransmit_buffered_messages(SSL *s);
d870 3
a872 8
struct timeval* dtls1_get_timeout(SSL *s, struct timeval* timeleft);
int dtls1_handle_timeout(SSL *s);
const SSL_CIPHER *dtls1_get_cipher(unsigned int u);
void dtls1_start_timer(SSL *s);
void dtls1_stop_timer(SSL *s);
int dtls1_is_timer_expired(SSL *s);
void dtls1_double_timeout(SSL *s);
int dtls1_send_newsession_ticket(SSL *s);
d882 1
a883 1
int ssl_do_client_cert_cb(SSL *s, X509 **px509, EVP_PKEY **ppkey);
a887 3
#ifndef OPENSSL_NO_TLSEXT
int ssl3_check_finished(SSL *s);
#endif
d925 1
d933 1
d948 1
a948 1
int tls1_final_finish_mac(SSL *s,
d950 1
a950 1
int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *p);
d958 1
a958 3
#ifndef OPENSSL_NO_ECDH
int ssl_check_srvr_ecc_cert_and_alg(X509 *x, const SSL_CIPHER *cs);
#endif
a961 5
#ifndef OPENSSL_NO_EC
int tls1_ec_curve_id2nid(int curve_id);
int tls1_ec_nid2curve_id(int nid);
#endif /* OPENSSL_NO_EC */

a970 1

a977 1
#endif
d980 2
a981 8
int ssl_add_serverhello_renegotiate_ext(SSL *s, unsigned char *p, int *len,
					int maxlen);
int ssl_parse_serverhello_renegotiate_ext(SSL *s, unsigned char *d, int len,
					  int *al);
int ssl_add_clienthello_renegotiate_ext(SSL *s, unsigned char *p, int *len,
					int maxlen);
int ssl_parse_clienthello_renegotiate_ext(SSL *s, unsigned char *d, int len,
					  int *al);
@


1.1.1.10
log
@OpenSSL 1.0.0f: import upstream source
@
text
@a952 1
unsigned int dtls1_min_mtu(void);
@


1.1.1.11
log
@import OpenSSL-1.0.1c
@
text
@d173 1
a173 1
#undef PKCS1_CHECK
a291 1
#define SSL_kSRP        0x00000400L /* SRP */
a318 2
#define SSL_AES128GCM		0x00001000L
#define SSL_AES256GCM		0x00002000L
d320 1
a320 1
#define SSL_AES        		(SSL_AES128|SSL_AES256|SSL_AES128GCM|SSL_AES256GCM)
a324 1

a328 4
#define SSL_SHA256		0x00000010L
#define SSL_SHA384		0x00000020L
/* Not a real MAC, just an indication it is part of cipher */
#define SSL_AEAD		0x00000040L
a333 1
#define SSL_TLSV1_2		0x00000004L
a340 2
#define SSL_HANDSHAKE_MAC_SHA256 0x80
#define SSL_HANDSHAKE_MAC_SHA384 0x100
d345 1
a345 3
#define SSL_MAX_DIGEST 6

#define TLS1_PRF_DGST_MASK	(0xff << TLS1_PRF_DGST_SHIFT)
d347 1
a347 1
#define TLS1_PRF_DGST_SHIFT 10
a349 2
#define TLS1_PRF_SHA256 (SSL_HANDSHAKE_MAC_SHA256 << TLS1_PRF_DGST_SHIFT)
#define TLS1_PRF_SHA384 (SSL_HANDSHAKE_MAC_SHA384 << TLS1_PRF_DGST_SHIFT)
a459 2
	/* Digest to use when signing */
	const EVP_MD *digest;
a556 4
	int (*export_keying_material)(SSL *, unsigned char *, size_t,
				      const char *, size_t,
				      const unsigned char *, size_t,
				      int use_context);
d594 1
a594 2
#define IMPLEMENT_tls_meth_func(version, func_name, s_accept, s_connect, \
				s_get_meth) \
d598 1
a598 1
		version, \
d672 1
a672 1
	TLS1_2_VERSION, \
d755 1
a755 1
		dtls1_shutdown, \
d812 1
a812 1
EVP_PKEY *ssl_get_sign_pkey(SSL *s,const SSL_CIPHER *c, const EVP_MD **pmd);
a945 1
int dtls1_check_timeout_num(SSL *s);
a970 3
# ifndef OPENSSL_NO_NEXTPROTONEG
int ssl3_send_next_proto(SSL *s);
# endif
a988 3
#ifndef OPENSSL_NO_NEXTPROTONEG
int ssl3_get_next_proto(SSL *s);
#endif
a1015 1
int dtls1_shutdown(SSL *s);
a1035 3
int tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,
	const char *label, size_t llen,
	const unsigned char *p, size_t plen, int use_context);
d1041 1
a1041 1
int ssl_check_srvr_ecc_cert_and_alg(X509 *x, SSL *s);
a1060 7
#ifndef OPENSSL_NO_HEARTBEATS
int tls1_heartbeat(SSL *s);
int dtls1_heartbeat(SSL *s);
int tls1_process_heartbeat(SSL *s);
int dtls1_process_heartbeat(SSL *s);
#endif

a1067 6

int tls12_get_sigandhash(unsigned char *p, const EVP_PKEY *pk,
				const EVP_MD *md);
int tls12_get_sigid(const EVP_PKEY *pk);
const EVP_MD *tls12_get_hash(unsigned char hash_alg);

a1078 9
long ssl_get_algorithm2(SSL *s);
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize);
int tls12_get_req_sig_algs(SSL *s, unsigned char *p);

int ssl_add_clienthello_use_srtp_ext(SSL *s, unsigned char *p, int *len, int maxlen);
int ssl_parse_clienthello_use_srtp_ext(SSL *s, unsigned char *d, int len,int *al);
int ssl_add_serverhello_use_srtp_ext(SSL *s, unsigned char *p, int *len, int maxlen);
int ssl_parse_serverhello_use_srtp_ext(SSL *s, unsigned char *d, int len,int *al);

@


1.1.1.12
log
@Import OpenSSL 1.0.1g
@
text
@a217 9
#define l2n8(l,c)	(*((c)++)=(unsigned char)(((l)>>56)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>48)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>40)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>32)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>24)&0xff), \
			 *((c)++)=(unsigned char)(((l)>>16)&0xff), \
			 *((c)++)=(unsigned char)(((l)>> 8)&0xff), \
			 *((c)++)=(unsigned char)(((l)    )&0xff))

a614 2
#define SSL_IS_DTLS(s) (s->method->version == DTLS1_VERSION)

d833 1
a833 2
CERT_PKEY *ssl_get_server_send_pkey(const SSL *s);
X509 *ssl_get_server_send_cert(const SSL *);
a839 1
int ssl_fill_hello_random(SSL *s, int server, unsigned char *field, int len);
d1091 1
a1091 2
int ssl_check_clienthello_tlsext_early(SSL *s);
int ssl_check_clienthello_tlsext_late(SSL *s);
a1132 29

/* s3_cbc.c */
void ssl3_cbc_copy_mac(unsigned char* out,
		       const SSL3_RECORD *rec,
		       unsigned md_size,unsigned orig_len);
int ssl3_cbc_remove_padding(const SSL* s,
			    SSL3_RECORD *rec,
			    unsigned block_size,
			    unsigned mac_size);
int tls1_cbc_remove_padding(const SSL* s,
			    SSL3_RECORD *rec,
			    unsigned block_size,
			    unsigned mac_size);
char ssl3_cbc_record_digest_supported(const EVP_MD_CTX *ctx);
void ssl3_cbc_digest_record(
	const EVP_MD_CTX *ctx,
	unsigned char* md_out,
	size_t* md_out_size,
	const unsigned char header[13],
	const unsigned char *data,
	size_t data_plus_mac_size,
	size_t data_plus_mac_plus_padding_size,
	const unsigned char *mac_secret,
	unsigned mac_secret_length,
	char is_sslv3);

void tls_fips_digest_extra(
	const EVP_CIPHER_CTX *cipher_ctx, EVP_MD_CTX *mac_ctx,
	const unsigned char *data, size_t data_len, size_t orig_len);
@


