head	1.10;
access;
symbols
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.36
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.34
	OPENBSD_5_0:1.8.0.32
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.30
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.28
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.24
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.26
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.22
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.20
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.18
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.16
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.14
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2013.12.03.06.21.41;	author guenther;	state dead;
branches;
next	1.9;

1.9
date	2012.12.24.19.29.12;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.01.19.27.20;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.28.18.05.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.11.22.58.06;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.22.19.15.40;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.20;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.08.20.14.11.36;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.06.24.17.15.53;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.18;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Merge the per-arch crt0.c files into common_elf/crt0.c, with MD macros in
the md_init.h files.

Worked out with and ok miod@@; ok matthew@@
@
text
@/* $NetBSD: crt0.c,v 1.9 2000/06/14 22:52:50 cgd Exp $ */

/*
 * Copyright (c) 1998 Christos Zoulas
 * Copyright (c) 1995 Christopher G. Demetriou
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *          This product includes software developed for the
 *          NetBSD Project.  See http://www.netbsd.org/ for
 *          information about NetBSD.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * <<Id: LICENSE,v 1.2 2000/06/14 15:57:33 cgd Exp>>
 */

#include <stdlib.h>
#include <limits.h>

void ___start(int, char **, char **, void (*cleanup)(void));

__asm(
"	.text\n"
"	.align 4\n"
"	.global	__start\n"
"	.global	_start\n"
"__start:\n"
"_start:\n"
"	mov	0, %fp\n"
"	ld	[%sp + 64], %o0		! get argc\n"
"	add	%sp, 68, %o1		! get argv\n"
"	sll	%o0, 2,	%o2\n"
"	add	%o2, 4,	%o2		! envp = argv + (argc << 2) + 4\n"
"	add	%o1, %o2, %o2\n"
"	andn	%sp, 7,	%sp		! align\n"
"	sub	%sp, 24, %sp		! expand to standard stack frame size\n"
"	call	___start\n"
"	 mov	%g1, %o3\n"
);

char **environ;
char *__progname = "";
char __progname_storage[NAME_MAX+1];

#ifdef MCRT0
extern void     monstartup(u_long, u_long);
extern void     _mcleanup(void);
extern unsigned char _etext, _eprol;
#endif /* MCRT0 */

static char *_strrchr(const char *, char);

void
___start(int argc, char **argv, char **envp, void (*cleanup)(void))
{
	char *s;

	environ = envp;

	if ((__progname = argv[0]) != NULL) {	/* NULL ptr if argc = 0 */
		if ((__progname = _strrchr(__progname, '/')) == NULL)
			__progname = argv[0];
		else
			__progname++;
		for (s = __progname_storage; *__progname &&
		    s < &__progname_storage[sizeof __progname_storage - 1]; )
			*s++ = *__progname++;
		*s = '\0';
		__progname = __progname_storage;
	}

	if (cleanup)
		atexit(cleanup);

#ifdef MCRT0
	atexit(_mcleanup);
	monstartup((u_long)&_eprol, (u_long)&_etext);
#endif

	__init();

	exit(main(argc, argv, environ));
}

static char *
_strrchr(const char *p, char ch)
{
	char *save;

	for (save = NULL;; ++p) {
		if (*p == ch)
			save = (char *)p;
		if (!*p)
			return(save);
	}
}

#ifdef MCRT0
asm ("  .text");
asm ("_eprol:");
#endif
@


1.9
log
@Register cleanup handler passed by ld.so with atexit(3).

tested by benno@@
@
text
@@


1.8
log
@No multi-line strings, to please gcc3. No functional change.
@
text
@d41 1
a41 1
void ___start(int, char **, char **, void (*cleanup)(void), void *);
a57 2
"	mov	%g3, %o3\n"
"	mov	%g2, %o4\n"
d59 1
a59 1
"	 mov	%g1, %o5\n"
d75 1
a75 2
___start(int argc, char **argv, char **envp, void (*cleanup)(void),
	void *obj)
d92 3
@


1.7
log
@copy basename of argv[0] to bss for __progname, so that large stack smash
does not make propolice reporting ineffective; millert miod ok
@
text
@d43 20
a62 20
__asm("
	.text
	.align	4
	.global	__start
	.global	_start
__start:
_start:
	mov	0, %fp
	ld	[%sp + 64], %o0		! get argc
	add	%sp, 68, %o1		! get argv
	sll	%o0, 2,	%o2		!
	add	%o2, 4,	%o2		! envp = argv + (argc << 2) + 4
	add	%o1, %o2, %o2		!
	andn	%sp, 7,	%sp		! align
	sub	%sp, 24, %sp		! expand to standard stack frame size
	mov	%g3, %o3
	mov	%g2, %o4
	call	___start
	 mov	%g1, %o5
");
@


1.6
log
@Adapt sparc crt* to how things are done on our other ELF architectures.
Some parts of crt0.c are from NetBSD.
@
text
@d39 1
d66 1
d80 2
d89 5
@


1.5
log
@Remove some dead ifdefs to make the code more readable.
@
text
@d1 2
a2 2
/*	$OpenBSD: crt0.c,v 1.4 2002/02/16 21:27:20 millert Exp $	*/
/*	$NetBSD: crt0.c,v 1.15 1995/06/15 21:41:55 pk Exp $	*/
d4 2
a5 1
 * Copyright (c) 1993 Paul Kranenburg
d7 1
a7 1
 *
d18 3
a20 1
 *      This product includes software developed by Paul Kranenburg.
d22 2
a23 2
 *    derived from this software without specific prior written permission
 *
d34 2
a35 1
 *
d38 1
d40 1
a40 3
#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: crt0.c,v 1.4 2002/02/16 21:27:20 millert Exp $";
#endif /* LIBC_SCCS and not lint */
d42 20
a61 2
#include <sys/param.h>
#include <stdlib.h>
d63 2
a64 1
#include "common.h"
d66 20
a85 27
extern	unsigned char	etext;
extern	unsigned char	eprol asm ("eprol");
extern void		start(void) asm("start");

#undef mmap
#define mmap(addr, len, prot, flags, fd, off)	\
    __syscall2((quad_t)SYS_mmap, (addr), (len), (prot), (flags), \
	(fd), 0, (off_t)(off))
extern int		__syscall2(quad_t, ...);

asm ("	.global start");
asm ("	.text");
asm ("	start:");

/* Set up `argc', `argv', and `envp' into local registers (from GNU Emacs). */
asm ("	mov	0, %fp");
asm ("	ld	[%sp + 64], %l0");	/* argc */
asm ("	add	%sp, 68, %l1");		/* argv */
asm ("	sll	%l0, 2,	%l2");		/**/
asm ("	add	%l2, 4,	%l2");		/* envp = argv + (argc << 2) + 4 */
asm ("	add	%l1, %l2, %l2");	/**/
asm ("	sethi	%hi(_environ), %l3");
asm ("	st	%l2, [%l3+%lo(_environ)]");	/* *environ = l2 */

/* Finish diddling with stack. */
asm ("	andn	%sp, 7,	%sp");
asm ("	sub	%sp, 24, %sp");
d87 3
a89 35
/*
 * Set __progname:
 *	if (argv[0])
 *		if ((__progname = _strrchr(argv[0], '/')) == NULL)
 *			__progname = argv[0];
 *		else
 *			++__progname;
 */
asm ("	ld	[%l1], %o0");
asm ("	cmp	%o0, 0");
asm ("	mov	%o0, %l6");
asm ("	be	1f");
asm ("	sethi	%hi(___progname), %l7");
#ifdef DYNAMIC
asm ("	call	__strrchr");
#else
asm ("	call	_strrchr");
#endif
asm ("	mov	47, %o1");
asm ("	cmp	%o0, 0");
asm ("	be,a	1f");
asm ("	st	%l6, [%l7+%lo(___progname)]");
asm ("	add	%o0, 1, %o0");
asm ("	st	%o0, [%l7+%lo(___progname)]");
asm ("1:");

#ifdef DYNAMIC
/* Resolve symbols in dynamic libraries */
asm ("	sethi	%hi(__DYNAMIC), %o0");
asm ("	orcc	%o0, %lo(__DYNAMIC), %o0");
asm ("	be	1f");
asm ("	nop");
asm ("	call	___load_rtld");
asm ("	nop");
asm ("1:");
d92 1
a92 15
/* From here, all symbols should have been resolved, so we can use libc */
#ifdef MCRT0
/*
 * atexit(_mcleanup);
 * monstartup((u_long)&eprol, (u_long)&etext);
 */
asm ("	sethi	%hi(__mcleanup), %o0");
asm ("	call	_atexit");
asm ("	or	%o0, %lo(__mcleanup), %o0");
asm ("	sethi	%hi(_eprol), %o0");
asm ("	or	%o0, %lo(_eprol), %o0");
asm ("	sethi	%hi(_etext), %o1");
asm ("	call	_monstartup");
asm ("	or	%o1, %lo(_etext), %o1");
#endif
d94 2
a95 28
/* Move `argc', `argv', and `envp' from locals to parameters for `main'.  */
asm ("	mov	%l0,%o0");
asm ("	mov	%l1,%o1");
asm ("__callmain:");		/* Defined for the benefit of debuggers */
asm ("	call	_main");
asm ("	mov	%l2,%o2");

asm ("	call	_exit");
asm ("	nop");

#ifdef DYNAMIC
/* System call entry */
asm("	.set	SYSCALL_G2RFLAG, 0x400");
asm("	.set	SYS___syscall, 198");
asm("___syscall2:");
asm("	sethi	%hi(SYS___syscall), %g1");	/* `SYS___syscall' */
asm("	ba	1f");
asm("	or	%g1, %lo(SYS___syscall), %g1");
asm("___syscall:");
asm("	clr	%g1");				/* `SYS_syscall' */
asm("1:");
asm("	or	%g1, SYSCALL_G2RFLAG, %g1");	/* Use quick return */
asm("	add	%o7, 8, %g2");
asm("	ta	%g0");
asm("	mov	-0x1, %o0");			/* Note: no `errno' */
asm("	jmp	%o7 + 0x8");
asm("	mov	-0x1, %o1");
#endif
d97 12
a108 1
#include "common.c"
d111 1
a111 1
asm ("	.text");
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.3 1999/08/20 14:11:36 niklas Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: crt0.c,v 1.3 1999/08/20 14:11:36 niklas Exp $";
a47 5
#if defined(sun) && defined(sparc)
static void		__call(void);
#endif

#ifdef BSD
a52 1
#endif
a124 6
#ifdef sun
/* SunOS compatibility */
asm ("	call	start_float");
asm ("	nop");
#endif

a151 16
#endif

#ifdef sun
static
__call()
{
	/*
	 * adjust the C generated pointer to the crt struct to the
	 * likings of ld.so, which is an offset relative to its %fp
	 */
	asm("mov	%i0, %o0");
	asm("mov	%i1, %o1");
	asm("call	%i2");
	asm("sub	%o1, %sp, %o1");
	/*NOTREACHED, control is transferred directly to our caller */
}
@


1.3
log
@Fix RCS Ids
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.2 1997/06/24 17:15:53 tholo Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: crt0.c,v 1.2 1997/06/24 17:15:53 tholo Exp $";
d46 1
a46 1
extern void		start __P((void)) asm("start");
d49 1
a49 1
static void		__call __P((void));
d57 1
a57 1
extern int		__syscall2 __P((quad_t, ...));
@


1.2
log
@Use OpenBSD tags and not SCCS or RCS Id tags
@
text
@d1 1
a2 1
/*	$OpenBSD$	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD$";
@


1.1
log
@Initial revision
@
text
@d2 1
d36 1
a36 1
static char sccsid[] = "%W% (Erasmus) %G%";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
