head	1.3;
access;
symbols
	OPENBSD_2_9:1.2.0.8
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2001.05.28.21.38.13;	author drahn;	state dead;
branches;
next	1.2;

1.2
date	99.08.20.14.11.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.28.05.01.16;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Commonize csu code for elf systems, powerpc now no longer has it's own
versions of these files.

Fixed a bug in ld.so in this, instead of scheduling the fini of each of
the shared libraries with atexit. schedule a function of ld.so itself
and it will walk all of the open libraries when the program exits.
otherwise a shared library could be dl_open()ed and then dl_close()d
and then it would not be mapped for the atexit processing.

TODO:
What if atexit is not found (process did not link against libc?)
Do shared libraries that are dl_closed have their global destructors run?
@
text
@/*	$OpenBSD: crtend.c,v 1.2 1999/08/20 14:11:36 niklas Exp $	*/
/*	$NetBSD: crtend.c,v 1.1 1997/04/16 19:38:24 thorpej Exp $	*/

#include <sys/cdefs.h>

static void (*__CTOR_LIST__[1]) __P((void))
    __attribute__((section(".ctors"))) = { (void *)0 };		/* XXX */
static void (*__DTOR_LIST__[1]) __P((void))
    __attribute__((section(".dtors"))) = { (void *)0 };		/* XXX */
@


1.2
log
@Fix RCS Ids
@
text
@d1 1
a1 1
/*	$OpenBSD: crtend.c,v 1.1 1997/04/16 19:38:24 thorpej Exp $	*/
@


1.1
log
@update for binutils 2.9.1, whenever it might show up... The changes
are cleanup that would not work correctly with the newer version. works
fine with the current (old) version of gas/ld.

ALSO:
Found a very long outstanding bug on the powerpc port. whenever
nroff was run, say during a build, it would complain about memory being
freed twice. Found the cause of this was that *roff which is written in
C++ was using globals that had constructors/destructors and due to a
bug in the crt code, the destructors were getting called when a program
exited via falling out of the main loop. calling exit directly would
not exersize the bug that ran the destructors twice. THIS BUG IS NOW FIXED.
@
text
@d1 1
@

