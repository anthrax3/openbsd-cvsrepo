head	1.3;
access;
symbols
	OPENBSD_2_9:1.2.0.10
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2001.05.28.21.38.13;	author drahn;	state dead;
branches;
next	1.2;

1.2
date	99.01.28.05.01.15;	author rahnds;	state Exp;
branches;
next	1.1;

1.1
date	96.12.21.20.53.48;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.21.20.53.48;	author rahnds;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Commonize csu code for elf systems, powerpc now no longer has it's own
versions of these files.

Fixed a bug in ld.so in this, instead of scheduling the fini of each of
the shared libraries with atexit. schedule a function of ld.so itself
and it will walk all of the open libraries when the program exits.
otherwise a shared library could be dl_open()ed and then dl_close()d
and then it would not be mapped for the atexit processing.

TODO:
What if atexit is not found (process did not link against libc?)
Do shared libraries that are dl_closed have their global destructors run?
@
text
@/*	$OpenBSD: crtbegin.c,v 1.2 1999/01/28 05:01:15 rahnds Exp $	*/
/*	$NetBSD: crtbegin.c,v 1.1 1996/09/12 16:59:03 cgd Exp $	*/

/*
 * Copyright (c) 1993 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef ECOFF_COMPAT

/*
 * XXX EVENTUALLY SHOULD BE MERGED BACK WITH c++rt0.c
 */

/*
 * Run-time module for GNU C++ compiled shared libraries.
 *
 * The linker constructs the following arrays of pointers to global
 * constructors and destructors. The first element contains the
 * number of pointers in each.
 * The tables are also null-terminated.

 */
#include <stdlib.h>

void (*__CTOR_LIST__[0]) __P((void))
    __attribute__((section(".ctors"))) = { (void *)-1 };	/* XXX */
void (*__DTOR_LIST__[0]) __P((void))
    __attribute__((section(".dtors"))) = { (void *)-1 };	/* XXX */

static void	__dtors __P((void));
static void	__ctors __P((void));

static void
__dtors()
{
	unsigned long i = (unsigned long) __DTOR_LIST__[0];
	void (**p)(void);

	if (i == -1)  {
		for (i = 1; __DTOR_LIST__[i] != NULL; i++)
			;
		i--;
	}
	p = __DTOR_LIST__ + i;
	while (i--)
		(**p--)();
}

static void
__ctors()
{
	void (**p)(void) = __CTOR_LIST__ + 1;

	while (*p)
		(**p++)();
}

void
__init()
{
	static int initialized = 0;

	/*
	 * Call global constructors.
	 * Arrange to call global destructors at exit.
	 */
	if (!initialized) {
		initialized = 1;
		__ctors();
	}
	atexit(__dtors);

}

void
__fini()
{
	/*
	 * Call global destructors.
	 */
	__dtors();
}

#endif /* !ECOFF_COMPAT */
@


1.2
log
@update for binutils 2.9.1, whenever it might show up... The changes
are cleanup that would not work correctly with the newer version. works
fine with the current (old) version of gas/ld.

ALSO:
Found a very long outstanding bug on the powerpc port. whenever
nroff was run, say during a build, it would complain about memory being
freed twice. Found the cause of this was that *roff which is written in
C++ was using globals that had constructors/destructors and due to a
bug in the crt code, the destructors were getting called when a program
exited via falling out of the main loop. calling exit directly would
not exersize the bug that ran the destructors twice. THIS BUG IS NOW FIXED.
@
text
@d1 1
a1 1
/*	$OpenBSD: crtbegin.c,v 1.1.1.1 1996/12/21 20:53:48 rahnds Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: crtbegin.c,v 1.1 1996/11/13 21:28:03 niklas Exp $	*/
d51 4
a54 10
/* XXX hack */
__asm__("
.section	.ctors,\"aw\"
	.long	 -1
.section	.dtors,\"aw\"
	.long	 -1
");

void (*__CTOR_LIST__[0]) __P((void));
void (*__DTOR_LIST__[0]) __P((void));
@


1.1.1.1
log
@Check-in of powerpc csu support.
NOTE: This will not work until the other pieces are checked in.
This is primarily the NetBSD powerpc port, with modifications
to support ELF.

A change needs to be made to one of the bsd.*.mk files to support
DESTDIR compilation with the crtbegin and crtend files.

@
text
@@
