head	1.28;
access;
symbols
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10;
locks; strict;
comment	@ * @;


1.28
date	2017.01.29.22.31.09;	author chl;	state Exp;
branches;
next	1.27;
commitid	HgoJpLpcEtd7jmiR;

1.27
date	2017.01.02.15.25.50;	author kettenis;	state Exp;
branches;
next	1.26;
commitid	PCxnpRVHJFBpmZfp;

1.26
date	2016.12.24.16.00.35;	author kettenis;	state Exp;
branches;
next	1.25;
commitid	nS5VbtiNNYGWgqpw;

1.25
date	2016.12.24.15.55.07;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	RutAyQh4AgsIK3th;

1.24
date	2016.12.19.18.30.50;	author krw;	state Exp;
branches;
next	1.23;
commitid	6uhw8deuBt1RwfPK;

1.23
date	2016.09.01.09.33.30;	author tedu;	state Exp;
branches;
next	1.22;
commitid	pzmnYX8KstYooFrj;

1.22
date	2016.08.08.22.05.26;	author guenther;	state Exp;
branches;
next	1.21;
commitid	YLEeMVXfrH3ggsry;

1.21
date	2016.08.07.02.44.00;	author guenther;	state Exp;
branches;
next	1.20;
commitid	6WdLcgMlrNAmywly;

1.20
date	2016.08.07.02.34.52;	author guenther;	state Exp;
branches;
next	1.19;
commitid	gwLjhbz16APKwjcf;

1.19
date	2016.08.07.02.30.55;	author guenther;	state Exp;
branches;
next	1.18;
commitid	0pC9OLvtSON7f3wH;

1.18
date	2016.08.07.02.30.04;	author guenther;	state Exp;
branches;
next	1.17;
commitid	Mxkf0Zdboz6anLz9;

1.17
date	2016.08.07.02.28.12;	author guenther;	state Exp;
branches;
next	1.16;
commitid	i884eYFTcKDezCrE;

1.16
date	2016.07.05.00.44.41;	author guenther;	state Exp;
branches;
next	1.15;
commitid	pD3gRXmODIF73eNL;

1.15
date	2016.03.12.23.28.47;	author guenther;	state Exp;
branches;
next	1.14;
commitid	tKCV3flghBqFzJKz;

1.14
date	2015.12.06.23.36.12;	author guenther;	state Exp;
branches;
next	1.13;
commitid	g8Z7pgqt28AVPEBX;

1.13
date	2015.09.19.20.11.22;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	y5BR32WWvTrZZfZF;

1.12
date	2015.08.17.17.13.58;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	MQsDCh7xJGMOWJDZ;

1.11
date	2015.07.03.11.17.25;	author miod;	state Exp;
branches;
next	1.10;
commitid	H6CiqVmJEKb1bjxL;

1.10
date	2015.01.16.06.47.03;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	Ie6aMcgwne0656CG;

1.9
date	2014.12.29.20.18.20;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	UHswipWsps6xxr74;

1.8
date	2014.12.27.13.17.51;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	szLCPbXaGN94NYFQ;

1.7
date	2014.12.25.21.38.45;	author kurt;	state Exp;
branches;
next	1.6;
commitid	YHCqzTF9jN9wPOIO;

1.6
date	2014.12.24.14.04.09;	author kurt;	state Exp;
branches;
next	1.5;
commitid	J7iiCQ72GxS0ZQVy;

1.5
date	2014.12.24.08.58.46;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	tEy93hEDcKKm163M;

1.4
date	2014.12.23.20.38.20;	author kettenis;	state Exp;
branches;
next	1.3;
commitid	6NI90ZjPpoNO4Qle;

1.3
date	2014.12.23.16.45.04;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	R031SDP1ggrFBcP7;

1.2
date	2014.12.22.13.32.51;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	qFcuDPN1Jvqgbo1R;

1.1
date	2014.12.22.03.51.08;	author kurt;	state Exp;
branches;
next	;
commitid	IDpxsqs0vh0PbV5Z;


desc
@@


1.28
log
@remove unused variables

ok krw@@ guenther@@
@
text
@/*	$OpenBSD: boot.h,v 1.27 2017/01/02 15:25:50 kettenis Exp $ */

/*
 * Copyright (c) 1998 Per Fogelstrom, Opsycon AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * IMPORTANT: any functions below are NOT protected by SSP.  Please
 * do not add anything except what is required to reach GOT with
 * an adjustment.
 */

#define	_DYN_LOADER

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <nlist.h>
#include <link.h>
#include <dlfcn.h>

#include "syscall.h"
#include "archdep.h"
#include "path.h"
#include "resolve.h"
#include "sod.h"
#include "stdlib.h"

/*
 * Use the internal, hidden name for any syscalls we need, to avoid
 * accidental override by application code
 */
#define REDIRECT_SYSCALL(x)	typeof(x) x asm("_libc_"#x) __dso_hidden
REDIRECT_SYSCALL(mprotect);

#ifdef RCRT0

#define	DT_PROC(n)	((n) - DT_LOPROC)

#if RELOC_TAG == DT_RELA
typedef	Elf_RelA	RELOC_TYPE;
#elif RELOC_TAG == DT_REL
typedef	Elf_Rel		RELOC_TYPE;
#else
# error "unknown RELOC_TAG"
#endif

/* The set of dynamic tags that we're interested in for bootstrapping */
struct boot_dyn {
	RELOC_TYPE	*dt_reloc;	/* DT_RELA   or DT_REL */
	Elf_Addr	dt_relocsz;	/* DT_RELASZ or DT_RELSZ */
	Elf_Addr	*dt_pltgot;
	Elf_Addr	dt_pltrelsz;
	const Elf_Sym	*dt_symtab;
	RELOC_TYPE	*dt_jmprel;
#if DT_PROCNUM > 0
	u_long		dt_proc[DT_PROCNUM];
#endif
};

/*
 * Local decls.
 */
void _dl_boot_bind(const long, long *, Elf_Dyn *);

void
_dl_boot_bind(const long sp, long *dl_data, Elf_Dyn *dynamicp)
{
	struct boot_dyn	dynld;		/* Resolver data for the loader */
	AuxInfo		*auxstack;
	long		*stack;
	Elf_Dyn		*dynp;
	int		n, argc;
	char		**argv, **envp;
	long		loff;
	RELOC_TYPE	*rp;
	Elf_Phdr	*phdp;
	Elf_Addr	i;

	/*
	 * Scan argument and environment vectors. Find dynamic
	 * data vector put after them.
	 */
	stack = (long *)sp;
	argc = *stack++;
	argv = (char **)stack;
	envp = &argv[argc + 1];
	stack = (long *)envp;
	while (*stack++ != 0L)
		;

	/*
	 * Zero out dl_data.
	 */
	for (n = 0; n <= AUX_entry; n++)
		dl_data[n] = 0;

	/*
	 * Dig out auxiliary data set up by exec call. Move all known
	 * tags to an indexed local table for easy access.
	 */
	for (auxstack = (AuxInfo *)stack; auxstack->au_id != AUX_null;
	    auxstack++) {
		if (auxstack->au_id > AUX_entry)
			continue;
		dl_data[auxstack->au_id] = auxstack->au_v;
	}
	loff = dl_data[AUX_base];	/* XXX assumes ld.so is linked at 0x0 */

	/*
	 * We need to do 'selfreloc' in case the code weren't
	 * loaded at the address it was linked to.
	 *
	 * Scan the DYNAMIC section for the loader.
	 * Cache the data for easier access.
	 */
	dynp = dynamicp;

	_dl_memset(&dynld, 0, sizeof(dynld));
	while (dynp->d_tag != DT_NULL) {
		/* first the tags that are pointers to be relocated */
		if (dynp->d_tag == DT_PLTGOT)
			dynld.dt_pltgot = (void *)(dynp->d_un.d_ptr + loff);
		else if (dynp->d_tag == DT_SYMTAB)
			dynld.dt_symtab = (void *)(dynp->d_un.d_ptr + loff);
		else if (dynp->d_tag == RELOC_TAG)	/* DT_{RELA,REL} */
			dynld.dt_reloc = (void *)(dynp->d_un.d_ptr + loff);
		else if (dynp->d_tag == DT_JMPREL)
			dynld.dt_jmprel = (void *)(dynp->d_un.d_ptr + loff);

		/* Now for the tags that are just sizes or counts */
		else if (dynp->d_tag == DT_PLTRELSZ)
			dynld.dt_pltrelsz = dynp->d_un.d_val;
		else if (dynp->d_tag == RELOC_TAG+1)	/* DT_{RELA,REL}SZ */
			dynld.dt_relocsz = dynp->d_un.d_val;
#if DT_PROCNUM > 0
		else if (dynp->d_tag >= DT_LOPROC &&
		    dynp->d_tag < DT_LOPROC + DT_PROCNUM)
			dynld.dt_proc[dynp->d_tag - DT_LOPROC] =
			    dynp->d_un.d_val;
#endif /* DT_PROCNUM */
		dynp++;
	}

	rp = dynld.dt_jmprel;
	for (i = 0; i < dynld.dt_pltrelsz; i += sizeof *rp) {
		const Elf_Sym *sp;

		sp = dynld.dt_symtab + ELF_R_SYM(rp->r_info);
		if (!ELF_R_SYM(rp->r_info) || sp->st_value != 0) {
#ifdef HAVE_JMPREL
			Elf_Addr *ra = (Elf_Addr *)(rp->r_offset + loff);
			RELOC_JMPREL(rp, sp, ra, loff, dynld.dt_pltgot);
#else
			_dl_exit(6);
#endif
		}
		rp++;
	}

	rp = dynld.dt_reloc;
	for (i = 0; i < dynld.dt_relocsz; i += sizeof *rp) {
		Elf_Addr *ra;
		const Elf_Sym *sp;

		sp = dynld.dt_symtab + ELF_R_SYM(rp->r_info);
		if (!ELF_R_SYM(rp->r_info) || sp->st_value != 0) {
			ra = (Elf_Addr *)(rp->r_offset + loff);
			RELOC_DYN(rp, sp, ra, loff);
		}
		rp++;
	}

	RELOC_GOT(&dynld, loff);

	/*
	 * we have been fully relocated here, so most things no longer
	 * need the loff adjustment
	 */

	/*
	 * No further changes to the PLT and/or GOT are needed so make
	 * them read-only.
	 */

	/* do any RWX -> RX fixups for executable PLTs and apply GNU_RELRO */
	phdp = (Elf_Phdr *)dl_data[AUX_phdr];
	for (i = 0; i < dl_data[AUX_phnum]; i++, phdp++) {
		switch (phdp->p_type) {
#if defined(__alpha__) || defined(__hppa__) || defined(__powerpc__) || \
    defined(__sparc64__)
		case PT_LOAD:
			if ((phdp->p_flags & (PF_X | PF_W)) != (PF_X | PF_W))
				break;
			mprotect((void *)(phdp->p_vaddr + loff), phdp->p_memsz,
			    PROT_READ);
			break;
#endif
		case PT_GNU_RELRO:
			mprotect((void *)(phdp->p_vaddr + loff), phdp->p_memsz,
			    PROT_READ);
			/*
			 * GNU_RELRO (a) covers the GOT, and (b) comes after
			 * all LOAD sections, so if we found it then we're done
			 */
			break;
		}
	}
}

#ifdef __alpha__

void	_reloc_alpha_got(Elf_Dyn *dynp, Elf_Addr relocbase);

void
_reloc_alpha_got(Elf_Dyn *dynp, Elf_Addr relocbase)
{
	const Elf_RelA *rela = 0, *relalim;
	Elf_Addr relasz = 0;
	Elf_Addr *where;

	for (; dynp->d_tag != DT_NULL; dynp++) {
		switch (dynp->d_tag) {
		case DT_RELA:
			rela = (const Elf_RelA *)(relocbase + dynp->d_un.d_ptr);
			break;
		case DT_RELASZ:
			relasz = dynp->d_un.d_val;
			break;
		}
	}
	relalim = (const Elf_RelA *)((caddr_t)rela + relasz);
	for (; rela < relalim; rela++) {
		if (ELF64_R_TYPE(rela->r_info) != RELOC_RELATIVE)
			continue;
		where = (Elf_Addr *)(relocbase + rela->r_offset);
		*where += (Elf_Addr)relocbase;
	}
}

#endif

#endif /* RCRT0 */
@


1.27
log
@Remove the (now unused) code to determine the page size.  Also get rid of
the extern declaration of __got_{start,end}.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.26 2016/12/24 16:00:35 kettenis Exp $ */
a95 2
	Elf_Addr	start;
	size_t		size;
@


1.26
log
@Replace return by break; requested by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.25 2016/12/24 15:55:07 kettenis Exp $ */
a88 3
extern char __got_start[];
extern char __got_end[];

a97 1
	int		pagesize;
a209 5

	if (dl_data[AUX_pagesz] != 0)
		pagesize = dl_data[AUX_pagesz];
	else
		pagesize = 4096;
@


1.25
log
@Remove code that reprotects the GOT based on the __got_start and __got_end
symbols.  Either the PT_LOAD RWX->RX case ot PT_GNU_RELRO should cover this
already for anything we care about.  And lld, the llvm linker, doesn't emit
the __got_start and __got_end symbols and there are good reasons to leave it
that way.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.24 2016/12/19 18:30:50 krw Exp $ */
d240 1
a240 1
			return;
@


1.24
log
@A couple more unused variables.

tweak & ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.23 2016/09/01 09:33:30 tedu Exp $ */
a104 1
	int		prot_exec = 0;
a242 9

#if defined(__powerpc__)
	if (dynld.dt_proc[DT_PROC(DT_PPC_GOT)] == 0)
		prot_exec = PROT_EXEC;
#endif

	start = ELF_TRUNC((Elf_Addr)__got_start, pagesize);
	size = ELF_ROUND((Elf_Addr)__got_end - start, pagesize);
	mprotect((void *)start, size, GOT_PERMS | prot_exec);
@


1.23
log
@retire sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.22 2016/08/08 22:05:26 guenther Exp $ */
a176 1
		Elf_Addr *ra;
d182 1
a182 1
			ra = (Elf_Addr *)(rp->r_offset + loff);
@


1.22
log
@Look for a PT_GNU_RELRO section and, if present, mprotect that range
instead of the [__got_start, __got_end) range.

Also, instead of mprotecting the [__plt_start, __plt_end) range,
just scan for sections which are both writable and executable and
mprotect them to read-only.  (This part was stolen from kettenis@@)

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.21 2016/08/07 02:44:00 guenther Exp $ */
d227 1
a227 1
    defined(__sparc__) || defined(__sparc64__)
@


1.21
log
@Teach mips64 to pass &_DYNAMIC to _dl_boot_bind().

mips64be testing by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.20 2016/08/07 02:34:52 guenther Exp $ */
a88 2
extern char __plt_start[];
extern char __plt_end[];
d107 1
d222 12
a233 5
#if defined(__alpha__) || defined(__powerpc__) || defined(__sparc__) || \
    defined(__sparc64__)
	start = ELF_TRUNC((Elf_Addr)__plt_start, pagesize);
	size = ELF_ROUND((Elf_Addr)__plt_end - start, pagesize);
	mprotect((void *)start, size, PROT_READ);
d235 10
@


1.20
log
@alpha already calculates &_DYNAMIC for the _reloc_alpha_got() call, so
save that and pass it to _dl_boot_bind() too
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.19 2016/08/07 02:30:55 guenther Exp $ */
a147 4

#if defined(__mips64__)
	dynp = (Elf_Dyn *)((long)_DYNAMIC + loff);
#else
a148 1
#endif
@


1.19
log
@Teach i386 to pass &_DYNAMIC to _dl_boot_bind()
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.18 2016/08/07 02:30:04 guenther Exp $ */
d149 1
a149 3
#if defined(__alpha__)
	dynp = (Elf_Dyn *)((long)_DYNAMIC);
#elif defined(__mips64__)
@


1.18
log
@Psych: amd64 has been passing &_DYNAMIC to _dl_boot_bind() for 19 months
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.17 2016/08/07 02:28:12 guenther Exp $ */
d151 1
a151 1
#elif defined(__i386__) || defined(__mips64__)
@


1.17
log
@Flip the #ifdef logic: amd64, i386, and mips64 were the only static PIE
archs using the #else case
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.16 2016/07/05 00:44:41 guenther Exp $ */
d151 1
a151 1
#elif defined(__amd64__) || defined(__i386__) || defined(__mips64__)
@


1.16
log
@Missed a reference to dl_prebind.h

problem noted by Andrew Ngo (andrew.ngo (at) gmail.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.15 2016/03/12 23:28:47 guenther Exp $ */
d151 3
a153 2
#elif defined(__sparc__) || defined(__sparc64__) || defined(__powerpc__) || \
    defined(__hppa__) || defined(__sh__)
a154 2
#else
	dynp = (Elf_Dyn *)((long)_DYNAMIC + loff);
@


1.15
log
@Call mprotect() via its hidden _lib_mprotect alias to avoid accidental
overriding

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.14 2015/12/06 23:36:12 guenther Exp $ */
a50 1
#include "dl_prebind.h"
@


1.14
log
@Simplify the relocation code for the ld.so bootstrap and static pie: track
just the dynamic tags are needed instead of reusing the generic elf_object_t
structure.

testing and feedback from miod@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.13 2015/09/19 20:11:22 kettenis Exp $ */
d52 7
@


1.13
log
@Make sure we set PROT_EXEC on the GOT for BSS-PLT binaries on powerpc.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.12 2015/08/17 17:13:58 kettenis Exp $ */
d53 3
a55 1
#define	DT_PROC(n)	((n) - DT_LOPROC + DT_NUM)
d57 20
a76 1
#ifdef RCRT0
d91 1
a91 1
	struct elf_object  dynld;	/* Resolver data for the loader */
d99 5
a103 3
	char **argv, **envp;
	long loff;
	int prot_exec = 0;
d151 19
a169 4
	_dl_memset(dynld.Dyn.info, 0, sizeof(dynld.Dyn.info));
	while (dynp != NULL && dynp->d_tag != DT_NULL) {
		if (dynp->d_tag < DT_NUM)
			dynld.Dyn.info[dynp->d_tag] = dynp->d_un.d_val;
d172 1
a172 1
			dynld.Dyn.info[dynp->d_tag - DT_LOPROC + DT_NUM] =
d174 1
a174 2
		if (dynp->d_tag == DT_TEXTREL)
			dynld.dyn.textrel = 1;
d178 10
a187 73
	/*
	 * Do the 'bootstrap relocation'. This is really only needed if
	 * the code was loaded at another location than it was linked to.
	 * We don't do undefined symbols resolving (to difficult..)
	 */

	/* "relocate" dyn.X values if they represent addresses */
	{
		int i, val;
		/* must be code, not pic data */
		int table[20];

		i = 0;
		table[i++] = DT_PLTGOT;
		table[i++] = DT_HASH;
		table[i++] = DT_STRTAB;
		table[i++] = DT_SYMTAB;
		table[i++] = DT_RELA;
		table[i++] = DT_INIT;
		table[i++] = DT_FINI;
		table[i++] = DT_REL;
		table[i++] = DT_JMPREL;
		table[i++] = DT_PLTREL;
		/* other processors insert their extras here */
		table[i++] = DT_NULL;
		for (i = 0; table[i] != DT_NULL; i++) {
			val = table[i];
			if (val >= DT_LOPROC && val < DT_LOPROC + DT_PROCNUM)
				val = val - DT_LOPROC + DT_NUM;
			else if (val >= DT_NUM || val == DT_PLTREL)
				continue;
			if (dynld.Dyn.info[val] != 0)
				dynld.Dyn.info[val] += loff;
		}
	}

	for (n = 0; n < 2; n++) {
		u_int32_t rs;
		Elf_Rel *rp;
		int	i;

		switch (n) {
		case 0:
			if (dynld.Dyn.info[DT_PLTREL] != DT_REL)
				continue;
			rp = (Elf_Rel *)(dynld.Dyn.info[DT_JMPREL]);
			rs = dynld.dyn.pltrelsz;
			break;
		case 1:
			rp = (Elf_Rel *)(dynld.Dyn.info[DT_REL]);
			rs = dynld.dyn.relsz;
			break;
		default:
			rp = NULL;
			rs = 0;
		}
		for (i = 0; i < rs; i += sizeof (Elf_Rel), rp++) {
			Elf_Addr *ra;
			const Elf_Sym *sp;

			sp = dynld.dyn.symtab;
			sp += ELF_R_SYM(rp->r_info);

			if (ELF_R_SYM(rp->r_info) && sp->st_value == 0) {
#if 0
/* cannot printf in this function */
				_dl_wrstderr("Dynamic loader failure: self bootstrapping impossible.\n");
				_dl_wrstderr("Undefined symbol: ");
				_dl_wrstderr((char *)dynld.dyn.strtab +
				    sp->st_name);
#endif
#ifdef RCRT0
				continue;
d189 1
a189 1
				_dl_exit(5);
a190 4
			}

			ra = (Elf_Addr *)(rp->r_offset + loff);
			RELOC_REL(rp, sp, ra, loff);
d192 1
d195 4
a198 39
	for (n = 0; n < 2; n++) {
		unsigned long rs;
		Elf_RelA *rp;
		int	i;

		switch (n) {
		case 0:
			if (dynld.Dyn.info[DT_PLTREL] != DT_RELA)
				continue;
			rp = (Elf_RelA *)(dynld.Dyn.info[DT_JMPREL]);
			rs = dynld.dyn.pltrelsz;
			break;
		case 1:
			rp = (Elf_RelA *)(dynld.Dyn.info[DT_RELA]);
			rs = dynld.dyn.relasz;
			break;
		default:
			rp = NULL;
			rs = 0;
		}
		for (i = 0; i < rs; i += sizeof (Elf_RelA), rp++) {
			Elf_Addr *ra;
			const Elf_Sym *sp;

			sp = dynld.dyn.symtab;
			sp += ELF_R_SYM(rp->r_info);
			if (ELF_R_SYM(rp->r_info) && sp->st_value == 0) {
#if 0
				_dl_wrstderr("Dynamic loader failure: self bootstrapping impossible.\n");
				_dl_wrstderr("Undefined symbol: ");
				_dl_wrstderr((char *)dynld.dyn.strtab +
				    sp->st_name);
#endif
#ifdef RCRT0
				continue;
#else
				_dl_exit(6);
#endif
			}
d200 2
d203 1
a203 1
			RELOC_RELA(rp, sp, ra, loff, dynld.dyn.pltgot);
d205 1
d233 1
a233 1
	if (dynld.Dyn.info[DT_PROC(DT_PPC_GOT)] == 0)
@


1.12
log
@Do not include os-note-elf.h here, otherwise we end up with duplicate OS notes
in our binaries.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.11 2015/07/03 11:17:25 miod Exp $ */
d53 2
d80 1
d293 5
d300 1
a300 1
	mprotect((void *)start, size, GOT_PERMS);
@


1.11
log
@static pie support for sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.10 2015/01/16 06:47:03 deraadt Exp $ */
a51 2

#include "../../lib/csu/os-note-elf.h"
@


1.10
log
@<sys/param.h> is not needed here either.
ok guenther millert doug
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.9 2014/12/29 20:18:20 kettenis Exp $ */
d285 2
a286 1
#if defined(__alpha__) || defined(__powerpc__) || defined(__sparc64__)
@


1.9
log
@Make the PLT read-only on powerpc as well.

ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.8 2014/12/27 13:17:51 kettenis Exp $ */
a39 1
#include <sys/param.h>
@


1.8
log
@Static PIE support for alpha.

This adds alpha-specific first-pass GOT relocation code to boot.h.
The assembly code is pure magic.  The numeric register
names don't make it easier to understand (or compare with the
equivalent ld.so code).  Unfortunately the assembler only understands
a few symbolic register names.

Renames the crt0.o entry point to __start.  Our compiler was already using
__start and the linker will soon follow.

ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.7 2014/12/25 21:38:45 kurt Exp $ */
d286 1
a286 1
#if defined(__alpha__) || defined(__sparc64__)
@


1.7
log
@Use archdep.h GOT_PERMS define for mprotect of GOT. okay kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.6 2014/12/24 14:04:09 kurt Exp $ */
d57 1
d286 1
a286 1
#if defined(__sparc64__)
d296 33
@


1.6
log
@Expand Elf_Rel relocations to include DT_JMPREL. Inspect DT_PLTREL value
to determine if DT_JMPREL relocations are REL or RELA and conditionally
perform DT_JMPREL in either REL or RELA as needed (idea from kettenis@@).
Remove unneeded i386 RELA implementation. i386 static pie working now.

okay kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.5 2014/12/24 08:58:46 kettenis Exp $ */
d293 1
a293 1
	mprotect((void *)start, size, PROT_READ);
@


1.5
log
@Fix previos.  Pointed out by kurt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.4 2014/12/23 20:38:20 kettenis Exp $ */
d162 1
d169 1
a169 1
			else if (val >= DT_NUM)
d176 1
a176 1
	{
d181 15
a195 3
		rp = (Elf_Rel *)(dynld.Dyn.info[DT_REL]);
		rs = dynld.dyn.relsz;

d230 2
@


1.4
log
@Use the page size passed by the kernel in the Auxilliary Vector to handle
architectures with variable page size.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.3 2014/12/23 16:45:04 kettenis Exp $ */
d265 1
a265 1
	if (dl_data[AUX_pagesz] == 0)
@


1.3
log
@Make sure the GOT and PLT are not writable.

Note that ommitting PROT_EXEC for the PLT is deliberate; static PIE
binaries should never actually hit the PLT.

We're still debating what to do when mprotect(2) fails.  But that is no
excuse not to at least attempt to fix things up.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.2 2014/12/22 13:32:51 kettenis Exp $ */
d76 1
d265 5
d271 2
a272 2
	start = ELF_TRUNC((Elf_Addr)__plt_start, PAGE_SIZE);
	size = ELF_ROUND((Elf_Addr)__plt_end - start, PAGE_SIZE);
d276 2
a277 2
	start = ELF_TRUNC((Elf_Addr)__got_start, PAGE_SIZE);
	size = ELF_ROUND((Elf_Addr)__got_end - start, PAGE_SIZE);
@


1.2
log
@When skipping a relocation because the referenced symbol is undefined, make
sure we move on to the next relocation entry.

While there, also skip relocations for REL architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.h,v 1.1 2014/12/22 03:51:08 kurt Exp $ */
d62 5
d74 2
d258 15
@


1.1
log
@Introduce new csu0 variant for -static -pie binaries to use called
rcsu0.o where the initial 'r' is for relocatable. rcsu0.o performs
self-relocation on static pie binaries by calling a slightly modified
copy of ld.so's _dl_boot_bind() in boot.h.

The first arch implementatation is also included for amd64 where
__start calls _dl_boot_bind() and then calls ___start(). Includes
parts from kettenis@@ to help get R_X86_64_64 relocations working
and proper handling for undefined weak symbols.

This is the first part of several to get static pie self-relocating
binaries working. binutils, gcc and kernel changes are forthcoming
to complete the solution, then per-arch implementations are needed
for MD_RCRT0_START in csu.

okay kettenis@@ pascal@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4 2014/11/15 02:14:10 guenther Exp $ */
d175 1
a175 1
		for (i = 0; i < rs; i += sizeof (Elf_Rel)) {
d190 3
d194 1
a198 1
			rp++;
d220 1
a220 1
		for (i = 0; i < rs; i += sizeof (Elf_RelA)) {
a241 1
			rp++;
@

