head	1.12;
access;
symbols
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.30
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.28
	OPENBSD_5_0:1.9.0.26
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.24
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.22
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.18
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.20
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.16
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.14
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.12
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.10
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.1.0.6
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.4
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2013.12.03.06.21.41;	author guenther;	state dead;
branches;
next	1.11;

1.11
date	2013.05.08.16.06.45;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.05.11.20.55;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.04.16.33.05;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.24.19.12.33;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.04.20.05.38;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.26.00.29.11;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.26.00.04.23;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.25.23.26.09;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.10.04.02.49;	author david;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.28.18.05.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.26.22.42.55;	author miod;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Merge the per-arch crt0.c files into common_elf/crt0.c, with MD macros in
the md_init.h files.

Worked out with and ok miod@@; ok matthew@@
@
text
@/*	$OpenBSD: crt0.c,v 1.11 2013/05/08 16:06:45 miod Exp $	*/

/*   
 *   Mach Operating System
 *   Copyright (c) 1991, 1992 Carnegie Mellon University
 *   Copyright (c) 1991, 1992 Omron Corporation
 *   All Rights Reserved.
 *   
 *   Permission to use, copy, modify and distribute this software and its
 *   documentation is hereby granted, provided that both the copyright
 *   notice and this permission notice appear in all copies of the
 *   software, derivative works or modified versions, and any portions
 *   thereof, and that both notices appear in supporting documentation.
 *   
 *   CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 *   CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 *   ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *   
 *   Carnegie Mellon requests users of this software to return to
 *   
 *    Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *    School of Computer Science
 *    Carnegie Mellon University
 *    Pittsburgh PA 15213-3890
 *   
 *   any improvements or extensions that they make and grant Carnegie Mellon 
 *   the rights to redistribute these changes.
 */

/*
 * When a program begins, r31 points to a structure passed by the kernel.
 *
 * This structure contains argc, the argv[] NULL-terminated array, and
 * the envp[] NULL-terminated array.
 */

#include <sys/param.h>
#include <stdlib.h>

char **environ;
char *__progname = "";

char __progname_storage[NAME_MAX + 1];

#ifdef MCRT0
extern void	monstartup(u_long, u_long);
extern void	_mcleanup(void);
extern unsigned char _etext, _eprol;
#endif /* MCRT0 */

static inline char *_strrchr(const char *p, char ch);

__asm__ (
"	.text\n"
"	.align 3\n"
"	.globl __start\n"
"	.globl _start\n"
"__start:\n"
"_start:\n"
"	or	%r0, %r0, %r0\n"	/* two nop because execution may */
"	or	%r0, %r0, %r0\n"	/* skip up to two instructions */
					/* see setregs() in the kernel */
					/* for details. */
"	ld	%r2, %r31, 0\n"		/* argc */
"	addu	%r3, %r31, 4\n"		/* argv */
"	lda	%r4, %r3[%r2]\n"
"	br.n	___start\n"
"	 addu	%r4, %r4, 4\n"		/* envp = argv + argc + 1 */
/* cleanup is %r5, zeroed in setregs() at the moment */
);

void
___start(int argc, char **argv, char **envp, void (*cleanup)(void))
{
	char *s;

	environ = envp;

	if ((__progname = argv[0]) != NULL) {	/* NULL ptr if argc = 0 */
		if ((__progname = _strrchr(__progname, '/')) == NULL)
			__progname = argv[0];
		else
			__progname++;
		for (s = __progname_storage; *__progname &&
		    s < &__progname_storage[sizeof __progname_storage - 1]; )
			*s++ = *__progname++;
		*s = '\0';
		__progname = __progname_storage;
	}

	if (cleanup)
		atexit(cleanup);

#ifdef MCRT0
	atexit(_mcleanup);
	monstartup((u_long)&_eprol, (u_long)&_etext);
#endif

	__init();

	exit(main(argc, argv, environ));
}

static char *
_strrchr(const char *p, char ch)
{
	char *save;

	for (save = NULL;; ++p) {
		if (*p == ch)
			save = (char *)p;
		if (!*p)
			return(save);
	}
}

#ifdef MCRT0
asm("\t.text\n_eprol:\n");
#endif
@


1.11
log
@Don't declare ___start static, for gcc4 would optimize it out.
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.10 2013/01/05 11:20:55 miod Exp $	*/
@


1.10
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.9 2005/08/04 16:33:05 espie Exp $	*/
d72 1
a72 1
static void
@


1.9
log
@zap rcsid. Okay deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.8 2004/07/24 19:12:33 miod Exp $	*/
d37 1
d40 2
a41 1
#include "common.h"
d43 9
a51 4
struct kframe {
	int argc;
	char *argv[0];
};
d55 15
a69 5
"	.align 8\n"
"	.globl start\n"
"start:\n"
"	br.n	_start\n"
"	 or	r2, r31, r0\n"
d73 1
a73 1
start(struct kframe *kfp)
d75 1
a75 1
	char **argv, *ap, *s;
d77 1
a77 2
	argv = &kfp->argv[0];
	environ = argv + kfp->argc + 1;
d79 3
a81 3
	if (ap = argv[0]) {
		if ((__progname = _strrchr(ap, '/')) == NULL)
			__progname = ap;
d83 1
a83 1
			++__progname;
d91 2
a92 1
__asm__ ("eprol:");
d96 1
a96 1
	monstartup((u_long)&eprol, (u_long)&etext);
d99 3
a101 2
__asm__ ("__callmain:");	/* Defined for the benefit of debuggers */
	exit(main(kfp->argc, argv, environ));
d104 12
a115 1
#include "common.c"
d118 1
a118 5
__asm__ ("\
	text\n\
	global	_eprol\n\
_eprol:\n\
");
@


1.8
log
@New, working, profiling code for m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.7 2004/01/04 20:05:38 pvalchev Exp $	*/
a28 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: crt0.c,v 1.7 2004/01/04 20:05:38 pvalchev Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.7
log
@kill multi-line string; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.6 2003/12/26 00:29:11 miod Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: crt0.c,v 1.6 2003/12/26 00:29:11 miod Exp $";
d79 8
a86 1
asm ("__callmain:");		/* Defined for the benefit of debuggers */
d91 8
@


1.6
log
@Put this again, but this time make sure the compiler really does not frob the
stack frame before we get a chance to tinker with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.3 2003/03/10 04:02:49 david Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: crt0.c,v 1.3 2003/03/10 04:02:49 david Exp $";
d50 8
a57 8
__asm__ ("
	.text
	.align 8
	.globl start
start:
	br.n	_start
	 or	r2, r31, r0
");
@


1.5
log
@Revert - this was a bit premature.
@
text
@a33 12
/* 
 *   Author :   Jeffrey Friedl
 *   Created:   July 1992
 *   Standalone crt0.
 */

/*
 * GCCisms used:
 * 	A "volatile void fcn()" is one that never returns.
 *	register var asm("r1"): variable VAR is raw access to named register.
 */

d35 1
a35 1
 * When a program begins, r31 points to info passed from the kernel.
d37 2
a38 26
 * The following shows the memory to which r31 points (think "int *r31;"),
 * and how we derive argc, argv, and envp from that:
 *
 *    +-------------------+ <-------------------------------------- r31
 *    | ARGC		  | <- argc = r31[0];
 *    +-------------------+ <- argv = &r31[1];
 *    | &(argument #1)    |
 *    +-------------------+
 *    | &(argument #2)    |
 *     -  - - - - - - -  - 
 *    | &(argument #ARGC) |
 *    +-------------------+
 *    | 0x00000000	  | <- end-of-ARGV-list marker (redundant information).
 *    +-------------------+ <- environ = envp =  &argv[argc+1];
 *    | &(env. var. #1)   |
 *    +-------------------+
 *    | &(env. var. #2)   |
 *     -  - - - - - - -  - 
 *    | &(env. var. #N)   |
 *    +-------------------+
 *    | 0x00000000	  | <- end-of-ENVP-list marker (not redundant!).
 *    +-------------------+
 *
 * We use 'start:' to grab r31 and call real_start(argc, argv, envp).
 * We must do this since the function prologue makes finding the initial
 * r31 difficult in C.
d45 13
a57 14
asm("	    text		");
asm("	    align  4		");
asm("start: global start	");
asm("       ld     r2, r31,   0 "); /* First arg to real_start: argc */
asm("       addu   r3, r31,   4 "); /* Second arg to real_start: argv */
asm("       lda    r4,  r3  [r2]"); /* Third arg to real_start: envp, but.... */
asm("       addu   r4,  r4,   4 "); /*   ... don't forget to skip past marker */
asm("       br.n   ___crt0_real_start");
asm("       subu   r31, r31, 32 ");

#ifdef DYNAMIC
extern struct _dynamic	_DYNAMIC;
struct _dynamic	*___pdynamic = &_DYNAMIC;
#endif
d59 2
a60 2
/* static */ void volatile
__crt0_real_start(int argc, char *argv[], char *envp[])
d62 1
a62 4
	register char *ap;
	volatile int a = 0;
	extern int end;
	char *s;
d64 2
a65 1
	environ = envp; /* environ is for the user that can't get at 'envp' */
d78 1
d80 1
a80 3
	exit(main(argc, argv, environ));

    /*NOTREACHED*/
@


1.4
log
@A much simpler and more readable start() routine...
@
text
@d34 12
d47 1
a47 1
 * When a program starts, r31 points to a structure passed from the kernel.
d49 26
a74 2
 * This structure contains argc, the argv[] array, a NULL marker, then
 * the envp[] array, and another NULL marker.
d81 14
a94 1
extern void start(void) __asm__("start");
d96 2
a97 2
void
start(void)
d99 4
a102 12
	struct kframe {
		int	argc;
		char	*argv[0];
	};

	struct kframe *kfp;
	char **argv, *ap, *s;

	/*
	 * Pick the arguments frame as early as possible
	 */
	__asm__ __volatile__ ("or %0, r31, 0" : "=r" (kfp) :: "r31");
d104 1
a104 2
	argv = &kfp->argv[0];
	environ = argv + kfp->argc + 1;
d117 2
d120 1
a120 2
asm ("__callmain:");		/* Defined for the benefit of debuggers */
	exit(main(kfp->argc, argv, environ));
@


1.3
log
@duplicate words and spelling fixes in comments
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.2 2003/02/28 18:05:51 deraadt Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: crt0.c,v 1.2 2003/02/28 18:05:51 deraadt Exp $";
a33 12
/* 
 *   Author :   Jeffrey Friedl
 *   Created:   July 1992
 *   Standalone crt0.
 */

/*
 * GCCisms used:
 * 	A "volatile void fcn()" is one that never returns.
 *	register var asm("r1"): variable VAR is raw access to named register.
 */

d35 1
a35 1
 * When a program begins, r31 points to info passed from the kernel.
d37 2
a38 26
 * The following shows the memory to which r31 points (think "int *r31;"),
 * and how we derive argc, argv, and envp from that:
 *
 *    +-------------------+ <-------------------------------------- r31
 *    | ARGC		  | <- argc = r31[0];
 *    +-------------------+ <- argv = &r31[1];
 *    | &(argument #1)    |
 *    +-------------------+
 *    | &(argument #2)    |
 *     -  - - - - - - -  - 
 *    | &(argument #ARGC) |
 *    +-------------------+
 *    | 0x00000000	  | <- end-of-ARGV-list marker (redundant information).
 *    +-------------------+ <- environ = envp =  &argv[argc+1];
 *    | &(env. var. #1)   |
 *    +-------------------+
 *    | &(env. var. #2)   |
 *     -  - - - - - - -  - 
 *    | &(env. var. #N)   |
 *    +-------------------+
 *    | 0x00000000	  | <- end-of-ENVP-list marker (not redundant!).
 *    +-------------------+
 *
 * We use 'start:' to grab r31 and call real_start(argc, argv, envp).
 * We must do this since the function prologue makes finding the initial
 * r31 difficult in C.
d45 1
a45 14
asm("	    text		");
asm("	    align  4		");
asm("start: global start	");
asm("       ld     r2, r31,   0 "); /* First arg to real_start: argc */
asm("       addu   r3, r31,   4 "); /* Second arg to real_start: argv */
asm("       lda    r4,  r3  [r2]"); /* Third arg to real_start: envp, but.... */
asm("       addu   r4,  r4,   4 "); /*   ... don't forget to skip past marker */
asm("       br.n   ___crt0_real_start");
asm("       subu   r31, r31, 32 ");

#ifdef DYNAMIC
extern struct _dynamic	_DYNAMIC;
struct _dynamic	*___pdynamic = &_DYNAMIC;
#endif
d47 2
a48 2
/* static */ void volatile
__crt0_real_start(int argc, char *argv[], char *envp[])
d50 12
a61 4
	register char *ap;
	volatile int a = 0;
	extern int end;
	char *s;
d63 2
a64 1
	environ = envp; /* environ is for the user that can't get at 'envp' */
d77 1
d79 1
a79 3
	exit(main(argc, argv, environ));

    /*NOTREACHED*/
@


1.2
log
@copy basename of argv[0] to bss for __progname, so that large stack smash
does not make propolice reporting ineffective; millert miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.1 2001/06/26 22:42:55 miod Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: crt0.c,v 1.1 2001/06/26 22:42:55 miod Exp $";
d72 1
a72 1
 * We use 'start:' to grab r31 and and call real_start(argc, argv, envp).
@


1.1
log
@Put m88k-related files in the correctly named directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: crt0.c,v 1.5 1997/07/23 20:39:32 kstailey Exp $	*/
d31 1
a31 1
static char rcsid[] = "$OpenBSD: crt0.c,v 1.5 1997/07/23 20:39:32 kstailey Exp $";
d102 1
d106 1
a106 1
	if (ap = argv[0])
d111 6
@

