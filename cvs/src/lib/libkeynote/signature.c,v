head	1.26;
access;
symbols
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.19.0.10
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.28
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.26
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.24
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.22
	OPENBSD_5_0:1.18.0.20
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.18
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.16
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.12
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.14
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.10
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.15.0.6
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.4
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.6
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	KeyNote-v2:1.1.1.1
	Angelos:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2017.05.09.13.52.45;	author mestre;	state Exp;
branches;
next	1.25;
commitid	EpgloUmMeo9SbpPd;

1.25
date	2015.12.23.21.15.58;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	hxiktZELbHbEI0N5;

1.24
date	2015.12.23.21.07.37;	author mmcc;	state Exp;
branches;
next	1.23;
commitid	V64inYUk3133Hm0T;

1.23
date	2015.12.19.18.49.02;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	Dfw4Vl9QohWNxUKh;

1.22
date	2015.12.19.01.15.45;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	YfsUBp4N7AxhUEml;

1.21
date	2015.12.18.22.55.04;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	hcPO2tvXfxJW8RDN;

1.20
date	2015.12.14.03.35.40;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	4Dxq4yN4wrkEGKym;

1.19
date	2013.11.13.16.28.17;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.16.06.18.35;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.29.11.35.56;	author msf;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.25.05.06.49;	author msf;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.14.15.49.36;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.17.19.39.20;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.02.12.55;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.27.06.29.14;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.03.20.14.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.10.26.22.31.39;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	99.10.09.19.47.33;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	99.10.09.06.59.37;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	99.10.01.01.08.30;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	99.08.16.02.33.37;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.08.13.22.49.54;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.05.31.20.10.00;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.05.31.18.29.19;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.05.25.21.42.23;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.05.23.22.11.06;	author angelos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.23.22.11.06;	author angelos;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Prevent memory leak on sbuf by freeing it unconditionally and ensure
finalbuf is also free'd if kn_encode_base64 somehow fails

hint from tb@@, OK millert@@ and tb@@
@
text
@/* $OpenBSD: signature.c,v 1.25 2015/12/23 21:15:58 mmcc Exp $ */
/*
 * The author of this code is Angelos D. Keromytis (angelos@@dsl.cis.upenn.edu)
 *
 * This code was written by Angelos D. Keromytis in Philadelphia, PA, USA,
 * in April-May 1998
 *
 * Copyright (C) 1998, 1999 by Angelos D. Keromytis.
 *	
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, THE AUTHORS MAKES NO
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

/*
 * Support for X509 keys and signing added by Ben Laurie <ben@@algroup.co.uk>
 * 3 May 1999
 */

#include <sys/types.h>

#include <limits.h>
#include <regex.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <openssl/dsa.h>
#include <openssl/md5.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/sha.h>
#include <openssl/x509.h>

#include "keynote.h"
#include "assertion.h"
#include "signature.h"

static const char hextab[] = {
     '0', '1', '2', '3', '4', '5', '6', '7',
     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
}; 

/*
 * Actual conversion to hex.
 */   
static void
bin2hex(unsigned char *data, unsigned char *buffer, int len)
{
    int off = 0;
     
    while(len > 0) 
    {
	buffer[off++] = hextab[*data >> 4];
	buffer[off++] = hextab[*data & 0xF];
	data++;
	len--;
    }
}

/*
 * Encode a binary string with hex encoding. Return 0 on success.
 */
int
kn_encode_hex(unsigned char *buf, char **dest, int len)
{
    keynote_errno = 0;
    if (dest == NULL)
    {
	keynote_errno = ERROR_SYNTAX;
	return -1;
    }

    *dest = calloc(2 * len + 1, sizeof(char));
    if (*dest == NULL)
    {
	keynote_errno = ERROR_MEMORY;
	return -1;
    }

    bin2hex(buf, *dest, len);
    return 0;
}

/*
 * Decode a hex encoding. Return 0 on success. The second argument
 * will be half as large as the first.
 */
int
kn_decode_hex(char *hex, char **dest)
{
    int i, decodedlen;
    char ptr[3];

    keynote_errno = 0;
    if (dest == NULL)
    {
	keynote_errno = ERROR_SYNTAX;
	return -1;
    }

    if (strlen(hex) % 2)			/* Should be even */
    {
	keynote_errno = ERROR_SYNTAX;
	return -1;
    }

    decodedlen = strlen(hex) / 2;
    *dest = calloc(decodedlen, sizeof(char));
    if (*dest == NULL)
    {
	keynote_errno = ERROR_MEMORY;
	return -1;
    }

    ptr[2] = '\0';
    for (i = 0; i < decodedlen; i++)
    {
	ptr[0] = hex[2 * i];
	ptr[1] = hex[(2 * i) + 1];
      	(*dest)[i] = (unsigned char) strtoul(ptr, NULL, 16);
    }

    return 0;
}

void
keynote_free_key(void *key, int type)
{
    if (key == NULL)
      return;

    /* DSA keys */
    if (type == KEYNOTE_ALGORITHM_DSA)
    {
	DSA_free(key);
	return;
    }

    /* RSA keys */
    if (type == KEYNOTE_ALGORITHM_RSA)
    {
	RSA_free(key);
	return;
    }

    /* X509 keys */
    if (type == KEYNOTE_ALGORITHM_X509)
    {
	RSA_free(key); /* RSA-specific */
	return;
    }

    /* BINARY keys */
    if (type == KEYNOTE_ALGORITHM_BINARY)
    {
	free(((struct keynote_binary *) key)->bn_key);
	free(key);
	return;
    }

    /* Catch-all case */
    if (type == KEYNOTE_ALGORITHM_NONE)
      free(key);
}

/*
 * Map a signature to an algorithm. Return algorithm number (defined in
 * keynote.h), or KEYNOTE_ALGORITHM_NONE if unknown.
 * Also return in the second, third and fourth arguments the digest
 * algorithm, ASCII and internal encodings respectively.
 */
static int
keynote_get_sig_algorithm(char *sig, int *hash, int *enc, int *internal)
{
    if (sig == NULL)
      return KEYNOTE_ALGORITHM_NONE;

    if (!strncasecmp(SIG_DSA_SHA1_HEX, sig, SIG_DSA_SHA1_HEX_LEN))
    {
	*hash = KEYNOTE_HASH_SHA1;
	*enc = ENCODING_HEX;
	*internal = INTERNAL_ENC_ASN1;
	return KEYNOTE_ALGORITHM_DSA;
    }

    if (!strncasecmp(SIG_DSA_SHA1_BASE64, sig, SIG_DSA_SHA1_BASE64_LEN))
    {
	*hash = KEYNOTE_HASH_SHA1;
	*enc = ENCODING_BASE64;
	*internal = INTERNAL_ENC_ASN1;
	return KEYNOTE_ALGORITHM_DSA;
    }

    if (!strncasecmp(SIG_RSA_MD5_PKCS1_HEX, sig, SIG_RSA_MD5_PKCS1_HEX_LEN))
    {
	*hash = KEYNOTE_HASH_MD5;
	*enc = ENCODING_HEX;
	*internal = INTERNAL_ENC_PKCS1;
	return KEYNOTE_ALGORITHM_RSA;
    }

    if (!strncasecmp(SIG_RSA_SHA1_PKCS1_HEX, sig, SIG_RSA_SHA1_PKCS1_HEX_LEN))
    {
	*hash = KEYNOTE_HASH_SHA1;
	*enc = ENCODING_HEX;
	*internal = INTERNAL_ENC_PKCS1;
	return KEYNOTE_ALGORITHM_RSA;
    }

    if (!strncasecmp(SIG_RSA_MD5_PKCS1_BASE64, sig,
                     SIG_RSA_MD5_PKCS1_BASE64_LEN))
    {
	*hash = KEYNOTE_HASH_MD5;
	*enc = ENCODING_BASE64;
	*internal = INTERNAL_ENC_PKCS1;
	return KEYNOTE_ALGORITHM_RSA;
    }

    if (!strncasecmp(SIG_RSA_SHA1_PKCS1_BASE64, sig,
                     SIG_RSA_SHA1_PKCS1_BASE64_LEN))
    {
	*hash = KEYNOTE_HASH_SHA1;
	*enc = ENCODING_BASE64;
	*internal = INTERNAL_ENC_PKCS1;
	return KEYNOTE_ALGORITHM_RSA;
    }

    if (!strncasecmp(SIG_X509_SHA1_BASE64, sig, SIG_X509_SHA1_BASE64_LEN))
    {
	*hash = KEYNOTE_HASH_SHA1;
	*enc = ENCODING_BASE64;
	*internal = INTERNAL_ENC_ASN1;
	return KEYNOTE_ALGORITHM_X509;
    }

    if (!strncasecmp(SIG_X509_SHA1_HEX, sig, SIG_X509_SHA1_HEX_LEN))
    {
	*hash = KEYNOTE_HASH_SHA1;
	*enc = ENCODING_HEX;
	*internal = INTERNAL_ENC_ASN1;
	return KEYNOTE_ALGORITHM_X509;
    }

    *hash = KEYNOTE_HASH_NONE;
    *enc = ENCODING_NONE;
    *internal = INTERNAL_ENC_NONE;
    return KEYNOTE_ALGORITHM_NONE;
}

/*
 * Map a key to an algorithm. Return algorithm number (defined in
 * keynote.h), or KEYNOTE_ALGORITHM_NONE if unknown. 
 * This latter is also a valid algorithm (for logical tags). Also return
 * in the second and third arguments the ASCII and internal encodings.
 */
int
keynote_get_key_algorithm(char *key, int *encoding, int *internalencoding)
{
    if (!strncasecmp(DSA_HEX, key, DSA_HEX_LEN))
    {
	*internalencoding = INTERNAL_ENC_ASN1;
	*encoding = ENCODING_HEX;
	return KEYNOTE_ALGORITHM_DSA;
    }

    if (!strncasecmp(DSA_BASE64, key, DSA_BASE64_LEN))
    {
	*internalencoding = INTERNAL_ENC_ASN1;
	*encoding = ENCODING_BASE64;
	return KEYNOTE_ALGORITHM_DSA;
    }

    if (!strncasecmp(RSA_PKCS1_HEX, key, RSA_PKCS1_HEX_LEN))
    {
	*internalencoding = INTERNAL_ENC_PKCS1;
	*encoding = ENCODING_HEX;
	return KEYNOTE_ALGORITHM_RSA;
    }

    if (!strncasecmp(RSA_PKCS1_BASE64, key, RSA_PKCS1_BASE64_LEN))
    {
	*internalencoding = INTERNAL_ENC_PKCS1;
	*encoding = ENCODING_BASE64;
	return KEYNOTE_ALGORITHM_RSA;
    }

    if (!strncasecmp(X509_BASE64, key, X509_BASE64_LEN))
    {
	*internalencoding = INTERNAL_ENC_ASN1;
	*encoding = ENCODING_BASE64;
	return KEYNOTE_ALGORITHM_X509;
    }

    if (!strncasecmp(X509_HEX, key, X509_HEX_LEN))
    {
	*internalencoding = INTERNAL_ENC_ASN1;
	*encoding = ENCODING_HEX;
	return KEYNOTE_ALGORITHM_X509;
    }

    if (!strncasecmp(BINARY_HEX, key, BINARY_HEX_LEN))
    {
	*internalencoding = INTERNAL_ENC_NONE;
	*encoding = ENCODING_HEX;
	return KEYNOTE_ALGORITHM_BINARY;
    }
    
    if (!strncasecmp(BINARY_BASE64, key, BINARY_BASE64_LEN))
    {
	*internalencoding = INTERNAL_ENC_NONE;
	*encoding = ENCODING_BASE64;
	return KEYNOTE_ALGORITHM_BINARY;
    }
    
    *internalencoding = INTERNAL_ENC_NONE;
    *encoding = ENCODING_NONE;
    return KEYNOTE_ALGORITHM_NONE;
}

/*
 * Same as keynote_get_key_algorithm(), only verify that this is
 * a private key (just look at the prefix).
 */
static int
keynote_get_private_key_algorithm(char *key, int *encoding,
				  int *internalencoding)
{
    if (strncasecmp(KEYNOTE_PRIVATE_KEY_PREFIX, key, 
		    KEYNOTE_PRIVATE_KEY_PREFIX_LEN))
    {
	*internalencoding = INTERNAL_ENC_NONE;
	*encoding = ENCODING_NONE;
	return KEYNOTE_ALGORITHM_NONE;
    }

    return keynote_get_key_algorithm(key + KEYNOTE_PRIVATE_KEY_PREFIX_LEN,
				     encoding, internalencoding);
}

/*
 * Decode a string to a key. Return 0 on success.
 */
int
kn_decode_key(struct keynote_deckey *dc, char *key, int keytype)
{
    void *kk = NULL;
    X509 *px509Cert;
    EVP_PKEY *pPublicKey;
    unsigned char *ptr = NULL, *decoded = NULL;
    int encoding, internalencoding;
    long len = 0;

    keynote_errno = 0;
    if (keytype == KEYNOTE_PRIVATE_KEY)
      dc->dec_algorithm = keynote_get_private_key_algorithm(key, &encoding,
							    &internalencoding);
    else
      dc->dec_algorithm = keynote_get_key_algorithm(key, &encoding,
						    &internalencoding);
    if (dc->dec_algorithm == KEYNOTE_ALGORITHM_NONE)
    {
	if ((dc->dec_key = strdup(key)) == NULL) {
	    keynote_errno = ERROR_MEMORY;
	    return -1;
	}

	return 0;
    }

    key = strchr(key, ':'); /* Move forward, to the Encoding. We're guaranteed
			    * to have a ':' character, since this is a key */
    key++;

    /* Remove ASCII encoding */
    switch (encoding)
    {
	case ENCODING_NONE:
	    break;

	case ENCODING_HEX:
            len = strlen(key) / 2;
	    if (kn_decode_hex(key, (char **) &decoded) != 0)
	      return -1;
	    ptr = decoded;
	    break;

	case ENCODING_BASE64:
	    len = strlen(key);
	    if (len % 4)  /* Base64 encoding must be a multiple of 4 */
	    {
		keynote_errno = ERROR_SYNTAX;
		return -1;
	    }

	    len = 3 * (len / 4);
	    decoded = calloc(len, sizeof(unsigned char));
	    ptr = decoded;
	    if (decoded == NULL) {
		keynote_errno = ERROR_MEMORY;
		return -1;
	    }

	    if ((len = kn_decode_base64(key, decoded, len)) == -1)
	      return -1;
	    break;

	case ENCODING_NATIVE:
	    decoded = strdup(key);
	    if (decoded == NULL) {
		keynote_errno = ERROR_MEMORY;
		return -1;
	    }
	    len = strlen(key);
	    ptr = decoded;
	    break;

	default:
	    keynote_errno = ERROR_SYNTAX;
	    return -1;
    }

    /* DSA-HEX */
    if ((dc->dec_algorithm == KEYNOTE_ALGORITHM_DSA) &&
	(internalencoding == INTERNAL_ENC_ASN1))
    {
	dc->dec_key = DSA_new();
	if (dc->dec_key == NULL) {
	    keynote_errno = ERROR_MEMORY;
	    return -1;
	}

	kk = dc->dec_key;
	if (keytype == KEYNOTE_PRIVATE_KEY)
	{
	    if (d2i_DSAPrivateKey((DSA **) &kk,(const unsigned char **) &decoded, len) == NULL) {
		free(ptr);
		DSA_free(kk);
		keynote_errno = ERROR_SYNTAX; /* Could be a memory error */
		return -1;
	    }
	}
	else
	{
	    if (d2i_DSAPublicKey((DSA **) &kk, (const unsigned char **) &decoded, len) == NULL) {
		free(ptr);
		DSA_free(kk);
		keynote_errno = ERROR_SYNTAX; /* Could be a memory error */
		return -1;
	    }
	}

	free(ptr);

	return 0;
    }

    /* RSA-PKCS1-HEX */
    if ((dc->dec_algorithm == KEYNOTE_ALGORITHM_RSA) &&
        (internalencoding == INTERNAL_ENC_PKCS1))
    {
        dc->dec_key = RSA_new();
        if (dc->dec_key == NULL) {
            keynote_errno = ERROR_MEMORY;
            return -1;
        }

        kk = dc->dec_key;
        if (keytype == KEYNOTE_PRIVATE_KEY)
        {
            if (d2i_RSAPrivateKey((RSA **) &kk, (const unsigned char **) &decoded, len) == NULL) {
                free(ptr);
                RSA_free(kk);
                keynote_errno = ERROR_SYNTAX; /* Could be a memory error */
                return -1;
            }
	    if (RSA_blinding_on((RSA *) kk, NULL) != 1) {
                free(ptr);
                RSA_free(kk);
                keynote_errno = ERROR_MEMORY;
                return -1;
	    }		
        }
        else
        {
            if (d2i_RSAPublicKey((RSA **) &kk, (const unsigned char **) &decoded, len) == NULL) {
                free(ptr);
                RSA_free(kk);
                keynote_errno = ERROR_SYNTAX; /* Could be a memory error */
                return -1;
            }
        }

        free(ptr);

        return 0;
    }

    /* X509 Cert */
    if ((dc->dec_algorithm == KEYNOTE_ALGORITHM_X509) &&
	(internalencoding == INTERNAL_ENC_ASN1) &&
	(keytype == KEYNOTE_PUBLIC_KEY))
    {
	if ((px509Cert = X509_new()) == NULL) {
	    free(ptr);
	    keynote_errno = ERROR_MEMORY;
	    return -1;
	}

	if(d2i_X509(&px509Cert, (const unsigned char **)&decoded, len) == NULL)
	{
	    free(ptr);
	    X509_free(px509Cert);
	    keynote_errno = ERROR_SYNTAX;
	    return -1;
	}

	if ((pPublicKey = X509_get_pubkey(px509Cert)) == NULL) {
	    free(ptr);
	    X509_free(px509Cert);
	    keynote_errno = ERROR_SYNTAX;
	    return -1;
	}

	/* RSA-specific */
	dc->dec_key = pPublicKey->pkey.rsa;

	free(ptr);
	return 0;
    }    

    /* BINARY keys */
    if ((dc->dec_algorithm == KEYNOTE_ALGORITHM_BINARY) &&
	(internalencoding == INTERNAL_ENC_NONE))
    {
	dc->dec_key = calloc(1, sizeof(struct keynote_binary));
	if (dc->dec_key == NULL)
	{
	    keynote_errno = ERROR_MEMORY;
	    return -1;
	}

	((struct keynote_binary *) dc->dec_key)->bn_key = decoded;
	((struct keynote_binary *) dc->dec_key)->bn_len = len;
	return RESULT_TRUE;
    }

    /* Add support for more algorithms here */

    free(ptr);

    /* This shouldn't ever be reached really */
    keynote_errno = ERROR_SYNTAX;
    return -1;
}

/*
 * Compare two keys for equality. Return RESULT_TRUE if equal,
 * RESULT_FALSE otherwise.
 */
int
kn_keycompare(void *key1, void *key2, int algorithm)
{
    DSA *p1, *p2;
    RSA *p3, *p4;
    struct keynote_binary *bn1, *bn2;

    if (key1 == NULL || key2 == NULL)
      return RESULT_FALSE;

    switch (algorithm)
    {
	case KEYNOTE_ALGORITHM_NONE:
	    if (!strcmp(key1, key2))
	      return RESULT_TRUE;
	    else
	      return RESULT_FALSE;
	    
	case KEYNOTE_ALGORITHM_DSA:
	    p1 = (DSA *) key1;
	    p2 = (DSA *) key2;
	    if (!BN_cmp(p1->p, p2->p) &&
		!BN_cmp(p1->q, p2->q) &&
		!BN_cmp(p1->g, p2->g) &&
		!BN_cmp(p1->pub_key, p2->pub_key))
	      return RESULT_TRUE;
	    else
	      return RESULT_FALSE;

	case KEYNOTE_ALGORITHM_X509:
            p3 = (RSA *) key1;
            p4 = (RSA *) key2;
            if (!BN_cmp(p3->n, p4->n) &&
                !BN_cmp(p3->e, p4->e))
              return RESULT_TRUE;
            else
	      return RESULT_FALSE;

	case KEYNOTE_ALGORITHM_RSA:
            p3 = (RSA *) key1;
            p4 = (RSA *) key2;
            if (!BN_cmp(p3->n, p4->n) &&
                !BN_cmp(p3->e, p4->e))
              return RESULT_TRUE;
            else
	      return RESULT_FALSE;

	case KEYNOTE_ALGORITHM_ELGAMAL:
	    /* Not supported yet */
	    return RESULT_FALSE;

	case KEYNOTE_ALGORITHM_PGP:
	    /* Not supported yet */
	    return RESULT_FALSE;

	case KEYNOTE_ALGORITHM_BINARY:
	    bn1 = (struct keynote_binary *) key1;
	    bn2 = (struct keynote_binary *) key2;
	    if ((bn1->bn_len == bn2->bn_len) &&
		!memcmp(bn1->bn_key, bn2->bn_key, bn1->bn_len))
	      return RESULT_TRUE;
	    else
	      return RESULT_FALSE;

	default:
	    return RESULT_FALSE;
    }
}

/*
 * Verify the signature on an assertion; return SIGRESULT_TRUE is
 * success, SIGRESULT_FALSE otherwise.
 */
int
keynote_sigverify_assertion(struct assertion *as)
{
    int hashtype, enc, intenc, alg = KEYNOTE_ALGORITHM_NONE, hashlen = 0;
    unsigned char *sig, *decoded = NULL, *ptr;
    unsigned char res2[20];
    SHA_CTX shscontext;
    MD5_CTX md5context;
    int len = 0;
    DSA *dsa;
    RSA *rsa;
    if (as->as_signature == NULL ||
	as->as_startofsignature == NULL ||
	as->as_allbutsignature == NULL ||
	as->as_allbutsignature - as->as_startofsignature <= 0)
      return SIGRESULT_FALSE;

    alg = keynote_get_sig_algorithm(as->as_signature, &hashtype, &enc,
				    &intenc);
    if (alg == KEYNOTE_ALGORITHM_NONE)
      return SIGRESULT_FALSE;

    /* Check for matching algorithms */
    if ((alg != as->as_signeralgorithm) &&
	!((alg == KEYNOTE_ALGORITHM_RSA) &&
	  (as->as_signeralgorithm == KEYNOTE_ALGORITHM_X509)) &&
	!((alg == KEYNOTE_ALGORITHM_X509) &&
	  (as->as_signeralgorithm == KEYNOTE_ALGORITHM_RSA)))
      return SIGRESULT_FALSE;

    sig = strchr(as->as_signature, ':');   /* Move forward to the Encoding. We
					   * are guaranteed to have a ':'
					   * character, since this is a valid
					   * signature */
    sig++;

    switch (hashtype)
    {
	case KEYNOTE_HASH_SHA1:
	    hashlen = 20;
	    memset(res2, 0, hashlen);
	    SHA1_Init(&shscontext);
	    SHA1_Update(&shscontext, as->as_startofsignature,
			as->as_allbutsignature - as->as_startofsignature);
	    SHA1_Update(&shscontext, as->as_signature, 
			(char *) sig - as->as_signature);
	    SHA1_Final(res2, &shscontext);
	    break;
	    
	case KEYNOTE_HASH_MD5:
	    hashlen = 16;
	    memset(res2, 0, hashlen);
	    MD5_Init(&md5context);
	    MD5_Update(&md5context, as->as_startofsignature,
		       as->as_allbutsignature - as->as_startofsignature);
	    MD5_Update(&md5context, as->as_signature,
		       (char *) sig - as->as_signature);
	    MD5_Final(res2, &md5context);
	    break;

	case KEYNOTE_HASH_NONE:
	    break;
    }

    /* Remove ASCII encoding */
    switch (enc)
    {
	case ENCODING_NONE:
	    ptr = NULL;
	    break;

	case ENCODING_HEX:
	    len = strlen(sig) / 2;
	    if (kn_decode_hex(sig, (char **) &decoded) != 0)
	      return -1;
	    ptr = decoded;
	    break;

	case ENCODING_BASE64:
	    len = strlen(sig);
	    if (len % 4)  /* Base64 encoding must be a multiple of 4 */
	    {
		keynote_errno = ERROR_SYNTAX;
		return -1;
	    }

	    len = 3 * (len / 4);
	    decoded = calloc(len, sizeof(unsigned char));
	    ptr = decoded;
	    if (decoded == NULL) {
		keynote_errno = ERROR_MEMORY;
		return -1;
	    }

	    len = kn_decode_base64(sig, decoded, len);
	    if ((len == -1) || (len == 0) || (len == 1))
	      return -1;
	    break;

	case ENCODING_NATIVE:
	    
	    if ((decoded = strdup(sig)) == NULL) {
		keynote_errno = ERROR_MEMORY;
		return -1;
	    }
	    len = strlen(sig);
	    ptr = decoded;
	    break;

	default:
	    keynote_errno = ERROR_SYNTAX;
	    return -1;
    }

    /* DSA */
    if ((alg == KEYNOTE_ALGORITHM_DSA) && (intenc == INTERNAL_ENC_ASN1))
    {
	dsa = (DSA *) as->as_authorizer;
	if (DSA_verify(0, res2, hashlen, decoded, len, dsa) == 1) {
	    free(ptr);
	    return SIGRESULT_TRUE;
	}
    }
    else /* RSA */
      if ((alg == KEYNOTE_ALGORITHM_RSA) && (intenc == INTERNAL_ENC_PKCS1))
      {
          rsa = (RSA *) as->as_authorizer;
          if (RSA_verify_ASN1_OCTET_STRING(RSA_PKCS1_PADDING, res2, hashlen,
					   decoded, len, rsa) == 1) {
              free(ptr);
              return SIGRESULT_TRUE;
          }
      }
      else
	if ((alg == KEYNOTE_ALGORITHM_X509) && (intenc == INTERNAL_ENC_ASN1))
	{
	    /* RSA-specific */
	    rsa = (RSA *) as->as_authorizer;
	    if (RSA_verify(NID_shaWithRSAEncryption, res2, hashlen, decoded,
			   len, rsa) == 1) {
		free(ptr);
		return SIGRESULT_TRUE;
	    }
	}
    
    /* Handle more algorithms here */
    
    free(ptr);

    return SIGRESULT_FALSE;
}

/*
 * Sign an assertion.
 */
static char *
keynote_sign_assertion(struct assertion *as, char *sigalg, void *key,
		       int keyalg, int verifyflag)
{
    int slen, i, hashlen = 0, hashtype, alg, encoding, internalenc;
    unsigned char *sig = NULL, *finalbuf = NULL;
    unsigned char res2[LARGEST_HASH_SIZE], *sbuf = NULL;
    BIO *biokey = NULL;
    DSA *dsa = NULL;
    RSA *rsa = NULL;
    SHA_CTX shscontext;
    MD5_CTX md5context;
    int len;

    if (as->as_signature_string_s == NULL ||
	as->as_startofsignature == NULL ||
	as->as_allbutsignature == NULL ||
	as->as_allbutsignature - as->as_startofsignature <= 0 ||
	as->as_authorizer == NULL ||
	key == NULL ||
	as->as_signeralgorithm == KEYNOTE_ALGORITHM_NONE)
    {
	keynote_errno = ERROR_SYNTAX;
	return NULL;
    }

    alg = keynote_get_sig_algorithm(sigalg, &hashtype, &encoding,
				    &internalenc);
    if (((alg != as->as_signeralgorithm) &&
	 !((alg == KEYNOTE_ALGORITHM_RSA) &&
	   (as->as_signeralgorithm == KEYNOTE_ALGORITHM_X509)) &&
	 !((alg == KEYNOTE_ALGORITHM_X509) &&
	   (as->as_signeralgorithm == KEYNOTE_ALGORITHM_RSA))) ||
        ((alg != keyalg) &&
	 !((alg == KEYNOTE_ALGORITHM_RSA) &&
	   (keyalg == KEYNOTE_ALGORITHM_X509)) &&
	 !((alg == KEYNOTE_ALGORITHM_X509) &&
	   (keyalg == KEYNOTE_ALGORITHM_RSA))))
    {
	keynote_errno = ERROR_SYNTAX;
	return NULL;
    }

    sig = strchr(sigalg, ':');
    if (sig == NULL)
    {
	keynote_errno = ERROR_SYNTAX;
	return NULL;
    }

    sig++;

    switch (hashtype)
    {
	case KEYNOTE_HASH_SHA1:
    	    hashlen = 20;
	    memset(res2, 0, hashlen);
	    SHA1_Init(&shscontext);
	    SHA1_Update(&shscontext, as->as_startofsignature,
			as->as_allbutsignature - as->as_startofsignature);
	    SHA1_Update(&shscontext, sigalg, (char *) sig - sigalg);
	    SHA1_Final(res2, &shscontext);
	    break;
   
	case KEYNOTE_HASH_MD5:
	    hashlen = 16;
	    memset(res2, 0, hashlen);
	    MD5_Init(&md5context);
	    MD5_Update(&md5context, as->as_startofsignature,
		       as->as_allbutsignature - as->as_startofsignature);
	    MD5_Update(&md5context, sigalg, (char *) sig - sigalg);
	    MD5_Final(res2, &md5context);
	    break;

	case KEYNOTE_HASH_NONE:
	    break;
    }

    if ((alg == KEYNOTE_ALGORITHM_DSA) &&
	(hashtype == KEYNOTE_HASH_SHA1) &&
	(internalenc == INTERNAL_ENC_ASN1) &&
	((encoding == ENCODING_HEX) || (encoding == ENCODING_BASE64)))
    {
	dsa = (DSA *) key;
	sbuf = calloc(DSA_size(dsa), sizeof(unsigned char));
	if (sbuf == NULL)
	{
	    keynote_errno = ERROR_MEMORY;
	    return NULL;
	}

	if (DSA_sign(0, res2, hashlen, sbuf, &slen, dsa) <= 0)
	{
	    free(sbuf);
	    keynote_errno = ERROR_SYNTAX;
	    return NULL;
	}
    }
    else
      if ((alg == KEYNOTE_ALGORITHM_RSA) &&
          ((hashtype == KEYNOTE_HASH_SHA1) ||
           (hashtype == KEYNOTE_HASH_MD5)) &&
          (internalenc == INTERNAL_ENC_PKCS1) &&
          ((encoding == ENCODING_HEX) || (encoding == ENCODING_BASE64)))
      {
          rsa = (RSA *) key;
          sbuf = calloc(RSA_size(rsa), sizeof(unsigned char));
          if (sbuf == NULL)
          {
              keynote_errno = ERROR_MEMORY;
              return NULL;
          }

          if (RSA_sign_ASN1_OCTET_STRING(RSA_PKCS1_PADDING, res2, hashlen,
					 sbuf, &slen, rsa) <= 0)
          {
              free(sbuf);
              keynote_errno = ERROR_SYNTAX;
              return NULL;
          }
      }
    else
      if ((alg == KEYNOTE_ALGORITHM_X509) &&
	  (hashtype == KEYNOTE_HASH_SHA1) &&
	  (internalenc == INTERNAL_ENC_ASN1))
      {
	  if ((biokey = BIO_new(BIO_s_mem())) == NULL)
	  {
	      keynote_errno = ERROR_SYNTAX;
	      return NULL;
	  }
	  
	  if (BIO_write(biokey, key, strlen(key) + 1) <= 0)
	  {
	      BIO_free(biokey);
	      keynote_errno = ERROR_SYNTAX;
	      return NULL;
	  }

	  /* RSA-specific */
	  rsa = (RSA *) PEM_read_bio_RSAPrivateKey(biokey, NULL, NULL, NULL);
	  if (rsa == NULL)
	  {
	      BIO_free(biokey);
	      keynote_errno = ERROR_SYNTAX;
	      return NULL;
	  }

	  sbuf = calloc(RSA_size(rsa), sizeof(char));
	  if (sbuf == NULL)
	  {
	      BIO_free(biokey);
	      RSA_free(rsa);
	      keynote_errno = ERROR_MEMORY;
	      return NULL;
	  }

	  if (RSA_sign(NID_shaWithRSAEncryption, res2, hashlen, sbuf, &slen,
		       rsa) <= 0)
          {
	      BIO_free(biokey);
	      RSA_free(rsa);
	      free(sbuf);
	      keynote_errno = ERROR_SIGN_FAILURE;
	      return NULL;
	  }

	  BIO_free(biokey);
	  RSA_free(rsa);
      }
      else /* Other algorithms here */
      {
	  keynote_errno = ERROR_SYNTAX;
	  return NULL;
      }

    /* ASCII encoding */
    switch (encoding)
    {
	case ENCODING_HEX:
	    i = kn_encode_hex(sbuf, (char **) &finalbuf, slen);
	    free(sbuf);
	    if (i != 0)
	      return NULL;
	    break;

	case ENCODING_BASE64:
	    finalbuf = calloc(2 * slen, sizeof(unsigned char));
	    if (finalbuf == NULL)
	    {
		keynote_errno = ERROR_MEMORY;
		free(sbuf);
		return NULL;
	    }

	    slen = kn_encode_base64(sbuf, slen, finalbuf, 2 * slen);
	    free(sbuf);
	    if (slen == -1) {
	      free(finalbuf);
	      return NULL;
	    }
	    break;

	default:
	    free(sbuf);
	    keynote_errno = ERROR_SYNTAX;
	    return NULL;
    }

    /* Replace as->as_signature */
    len = strlen(sigalg) + strlen(finalbuf) + 1;
    as->as_signature = calloc(len, sizeof(char));
    if (as->as_signature == NULL)
    {
	free(finalbuf);
	keynote_errno = ERROR_MEMORY;
	return NULL;
    }

    /* Concatenate algorithm name and signature value */
    snprintf(as->as_signature, len, "%s%s", sigalg, finalbuf);
    free(finalbuf);
    finalbuf = as->as_signature;

    /* Verify the newly-created signature if requested */
    if (verifyflag)
    {
	/* Do the signature verification */
	if (keynote_sigverify_assertion(as) != SIGRESULT_TRUE)
	{
	    as->as_signature = NULL;
	    free(finalbuf);
	    if (keynote_errno == 0)
	      keynote_errno = ERROR_SYNTAX;
	    return NULL;
	}

	as->as_signature = NULL;
    }
    else
      as->as_signature = NULL;

    /* Everything ok */
    return (char *) finalbuf;
}

/*
 * Verify the signature on an assertion.
 */
int
kn_verify_assertion(char *buf, int len)
{
    struct assertion *as;
    int res;

    keynote_errno = 0;
    as = keynote_parse_assertion(buf, len, ASSERT_FLAG_SIGVER);
    if (as == NULL)
      return -1;

    res = keynote_sigverify_assertion(as);
    keynote_free_assertion(as);
    return res;
}

/*
 * Produce the signature for an assertion.
 */
char *
kn_sign_assertion(char *buf, int buflen, char *key, char *sigalg, int vflag)
{
    int i, alg, hashtype, encoding, internalenc;
    struct keynote_deckey dc;
    struct assertion *as;
    char *s, *sig;

    keynote_errno = 0;
    s = NULL;

    if (sigalg == NULL || buf == NULL || key == NULL)
    {
	keynote_errno = ERROR_NOTFOUND;
	return NULL;
    }

    if (sigalg[0] == '\0' || sigalg[strlen(sigalg) - 1] != ':')
    {
	keynote_errno = ERROR_SYNTAX;
	return NULL;
    }

    /* We're using a different format for X509 private keys, so... */
    alg = keynote_get_sig_algorithm(sigalg, &hashtype, &encoding,
				    &internalenc);
    if (alg != KEYNOTE_ALGORITHM_X509)
    {
	/* Parse the private key */
	s = keynote_get_private_key(key);
	if (s == NULL)
	  return NULL;

	/* Decode private key */
	i = kn_decode_key(&dc, s, KEYNOTE_PRIVATE_KEY);
	if (i == -1)
	{
	    free(s);
	    return NULL;
	}
    }
    else /* X509 private key */
    {
	dc.dec_key = key;
	dc.dec_algorithm = alg;
    }

    as = keynote_parse_assertion(buf, buflen, ASSERT_FLAG_SIGGEN);
    if (as == NULL)
    {
	if (alg != KEYNOTE_ALGORITHM_X509)
	{
	    keynote_free_key(dc.dec_key, dc.dec_algorithm);
	    free(s);
	}
	return NULL;
    }

    sig = keynote_sign_assertion(as, sigalg, dc.dec_key, dc.dec_algorithm,
				 vflag);
    if (alg != KEYNOTE_ALGORITHM_X509)
      keynote_free_key(dc.dec_key, dc.dec_algorithm);
    keynote_free_assertion(as);
    if (s != NULL)
      free(s);
    return sig;
}

/*
 * ASCII-encode a key.
 */
char *
kn_encode_key(struct keynote_deckey *dc, int iencoding,
	      int encoding, int keytype)
{
    char *foo, *ptr;
    DSA *dsa;
    RSA *rsa;
    int i;
    struct keynote_binary *bn;
    char *s;

    keynote_errno = 0;
    if (dc == NULL || dc->dec_key == NULL)
    {
	keynote_errno = ERROR_NOTFOUND;
	return NULL;
    }

    /* DSA keys */
    if ((dc->dec_algorithm == KEYNOTE_ALGORITHM_DSA) &&
	(iencoding == INTERNAL_ENC_ASN1) &&
	((encoding == ENCODING_HEX) || (encoding == ENCODING_BASE64)))
    {
	dsa = (DSA *) dc->dec_key;
	if (keytype == KEYNOTE_PUBLIC_KEY)
	  i = i2d_DSAPublicKey(dsa, NULL);
	else
	  i = i2d_DSAPrivateKey(dsa, NULL);

	if (i <= 0)
	{
	    keynote_errno = ERROR_SYNTAX;
	    return NULL;
	}

 	ptr = foo = calloc(i, sizeof(char));
	if (foo == NULL)
	{
	    keynote_errno = ERROR_MEMORY;
	    return NULL;
	}

	dsa->write_params = 1;
	if (keytype == KEYNOTE_PUBLIC_KEY)
	  i2d_DSAPublicKey(dsa, (unsigned char **) &foo);
	else
	  i2d_DSAPrivateKey(dsa, (unsigned char **) &foo);

	if (encoding == ENCODING_HEX)
	{
	    if (kn_encode_hex(ptr, &s, i) != 0)
	    {
		free(ptr);
		return NULL;
	    }

	    free(ptr);
	    return s;
	}
	else
	  if (encoding == ENCODING_BASE64)
	  {
	      s = calloc(2 * i, sizeof(char));
	      if (s == NULL)
	      {
		  free(ptr);
		  keynote_errno = ERROR_MEMORY;
		  return NULL;
	      }

	      if (kn_encode_base64(ptr, i, s, 2 * i) == -1)
	      {
		  free(s);
		  free(ptr);
		  return NULL;
	      }

	      free(ptr);
	      return s;
	  }
    }

    /* RSA keys */
    if ((dc->dec_algorithm == KEYNOTE_ALGORITHM_RSA) &&
	(iencoding == INTERNAL_ENC_PKCS1) &&
	((encoding == ENCODING_HEX) || (encoding == ENCODING_BASE64)))
    {
	rsa = (RSA *) dc->dec_key;
	if (keytype == KEYNOTE_PUBLIC_KEY)
	  i = i2d_RSAPublicKey(rsa, NULL);
	else
	  i = i2d_RSAPrivateKey(rsa, NULL);

	if (i <= 0)
	{
	    keynote_errno = ERROR_SYNTAX;
	    return NULL;
	}

	ptr = foo = calloc(i, sizeof(char));
	if (foo == NULL)
	{
	    keynote_errno = ERROR_MEMORY;
	    return NULL;
	}

	if (keytype == KEYNOTE_PUBLIC_KEY)
	  i2d_RSAPublicKey(rsa, (unsigned char **) &foo);
	else
	  i2d_RSAPrivateKey(rsa, (unsigned char **) &foo);

	if (encoding == ENCODING_HEX)
	{
	    if (kn_encode_hex(ptr, &s, i) != 0)
	    {
		free(ptr);
		return NULL;
	    }

	    free(ptr);
	    return s;
	}
	else
	  if (encoding == ENCODING_BASE64)
	  {
	      s = calloc(2 * i, sizeof(char));
	      if (s == NULL)
	      {
		  free(ptr);
		  keynote_errno = ERROR_MEMORY;
		  return NULL;
	      }

	      if (kn_encode_base64(ptr, i, s, 2 * i) == -1)
	      {
		  free(s);
		  free(ptr);
		  return NULL;
	      }

	      free(ptr);
	      return s;
	  }
    }

    /* BINARY keys */
    if ((dc->dec_algorithm == KEYNOTE_ALGORITHM_BINARY) &&
	(iencoding == INTERNAL_ENC_NONE) &&
	((encoding == ENCODING_HEX) || (encoding == ENCODING_BASE64)))
    {
	bn = (struct keynote_binary *) dc->dec_key;

	if (encoding == ENCODING_HEX)
	{
	    if (kn_encode_hex(bn->bn_key, &s, bn->bn_len) != 0)
	      return NULL;

	    return s;
	}
	else
	  if (encoding == ENCODING_BASE64)
	  {
	      s = calloc(2 * bn->bn_len, sizeof(char));
	      if (s == NULL)
	      {
		  keynote_errno = ERROR_MEMORY;
		  return NULL;
	      }

	      if (kn_encode_base64(bn->bn_key, bn->bn_len, s,
				   2 * bn->bn_len) == -1)
	      {
		  free(s);
		  return NULL;
	      }

	      return s;
	  }
    }

    keynote_errno = ERROR_NOTFOUND;
    return NULL;
}
@


1.25
log
@Remove the rest of the scaffolding for nonexistent ElGamal support,
which has been disabled for sixteen years.

ok millert@@, tb@@, sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.24 2015/12/23 21:07:37 mmcc Exp $ */
d991 5
a995 5
	    if ((slen = kn_encode_base64(sbuf, slen, finalbuf, 
					 2 * slen)) == -1)
	    {
		free(sbuf);
		return NULL;
@


1.24
log
@Remove NULL casts and tweak style in a few places. A more invasive
version of this diff was reviewed by tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.23 2015/12/19 18:49:02 mmcc Exp $ */
a307 16

#if 0 /* Not supported yet */
    if (!strncasecmp(ELGAMAL_HEX, key, ELGAMAL_HEX_LEN))
    {
	*internalencoding = INTERNAL_ENC_ASN1;
	*encoding = ENCODING_HEX;
	return KEYNOTE_ALGORITHM_ELGAMAL;
    }

    if (!strncasecmp(ELGAMAL_BASE64, key, ELGAMAL_BASE64_LEN))
    {
	*internalencoding = INTERNAL_ENC_ASN1;
	*encoding = ENCODING_BASE64;
	return KEYNOTE_ALGORITHM_ELGAMAL;
    }
#endif /* 0 */
@


1.23
log
@Style cleanup and removal of needless casts. ok tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.22 2015/12/19 01:15:45 mmcc Exp $ */
d75 1
a75 1
    if (dest == (char **) NULL)
d81 2
a82 2
    *dest = (char *) calloc(2 * len + 1, sizeof(char));
    if (*dest == (char *) NULL)
d103 1
a103 1
    if (dest == (char **) NULL)
d116 2
a117 2
    *dest = (char *) calloc(decodedlen, sizeof(char));
    if (*dest == (char *) NULL)
d128 1
a128 1
      	(*dest)[i] = (unsigned char) strtoul(ptr, (char **) NULL, 16);
d137 1
a137 1
    if (key == (void *) NULL)
d183 1
a183 1
    if (sig == (char *) NULL)
d559 2
a560 2
	dc->dec_key = (void *) calloc(1, sizeof(struct keynote_binary));
	if (dc->dec_key == (struct keynote_binary *) NULL)
d819 3
a821 3
    BIO *biokey = (BIO *) NULL;
    DSA *dsa = (DSA *) NULL;
    RSA *rsa = (RSA *) NULL;
d856 1
a856 1
    if (sig == (unsigned char *) NULL)
d859 1
a859 1
	return (char *) NULL;
d896 2
a897 2
	sbuf = (unsigned char *) calloc(DSA_size(dsa), sizeof(unsigned char));
	if (sbuf == (unsigned char *) NULL)
d900 1
a900 1
	    return (char *) NULL;
d907 1
a907 1
	    return (char *) NULL;
d918 2
a919 3
          sbuf = (unsigned char *) calloc(RSA_size(rsa),
                                          sizeof(unsigned char));
          if (sbuf == (unsigned char *) NULL)
d922 1
a922 1
              return (char *) NULL;
d930 1
a930 1
              return (char *) NULL;
d938 1
a938 1
	  if ((biokey = BIO_new(BIO_s_mem())) == (BIO *) NULL)
d941 1
a941 1
	      return (char *) NULL;
d948 1
a948 1
	      return (char *) NULL;
d953 1
a953 1
	  if (rsa == (RSA *) NULL)
d957 1
a957 1
	      return (char *) NULL;
d961 1
a961 1
	  if (sbuf == (unsigned char *) NULL)
d966 1
a966 1
	      return (char *) NULL;
d985 1
a985 1
	  return (char *) NULL;
d995 1
a995 1
	      return (char *) NULL;
d999 2
a1000 3
	    finalbuf = (unsigned char *) calloc(2 * slen,
						sizeof(unsigned char));
	    if (finalbuf == (unsigned char *) NULL)
d1004 1
a1004 1
		return (char *) NULL;
d1011 1
a1011 1
		return (char *) NULL;
d1018 1
a1018 1
	    return (char *) NULL;
d1023 2
a1024 2
    as->as_signature = (char *) calloc(len, sizeof(char));
    if (as->as_signature == (char *) NULL)
d1028 1
a1028 1
	return (char *) NULL;
d1042 1
a1042 1
	    as->as_signature = (char *) NULL;
d1046 1
a1046 1
	    return (char *) NULL;
d1049 1
a1049 1
	as->as_signature = (char *) NULL;
d1052 1
a1052 1
      as->as_signature = (char *) NULL;
d1069 1
a1069 1
    if (as == (struct assertion *) NULL)
d1089 1
a1089 1
    s = (char *) NULL;
d1091 1
a1091 2
    if ((sigalg == (char *) NULL) || (buf == (char *) NULL) ||
	(key == (char *) NULL))
d1094 1
a1094 1
	return (char *) NULL;
d1100 1
a1100 1
	return (char *) NULL;
d1110 2
a1111 2
	if (s == (char *) NULL)
	  return (char *) NULL;
d1118 1
a1118 1
	    return (char *) NULL;
d1128 1
a1128 1
    if (as == (struct assertion *) NULL)
d1135 1
a1135 1
	return (char *) NULL;
d1143 1
a1143 1
    if (s != (char *) NULL)
d1163 1
a1163 2
    if ((dc == (struct keynote_deckey *) NULL) ||
	(dc->dec_key == (void *) NULL))
d1166 1
a1166 1
	return (char *) NULL;
d1183 1
a1183 1
	    return (char *) NULL;
d1186 2
a1187 2
 	ptr = foo = (char *) calloc(i, sizeof(char));
	if (foo == (char *) NULL)
d1190 1
a1190 1
	    return (char *) NULL;
d1204 1
a1204 1
		return (char *) NULL;
d1213 2
a1214 2
	      s = (char *) calloc(2 * i, sizeof(char));
	      if (s == (char *) NULL)
d1218 1
a1218 1
		  return (char *) NULL;
d1225 1
a1225 1
		  return (char *) NULL;
d1247 1
a1247 1
	    return (char *) NULL;
d1250 2
a1251 2
	ptr = foo = (char *) calloc(i, sizeof(char));
	if (foo == (char *) NULL)
d1254 1
a1254 1
	    return (char *) NULL;
d1267 1
a1267 1
		return (char *) NULL;
d1276 2
a1277 2
	      s = (char *) calloc(2 * i, sizeof(char));
	      if (s == (char *) NULL)
d1281 1
a1281 1
		  return (char *) NULL;
d1288 1
a1288 1
		  return (char *) NULL;
d1306 1
a1306 1
	      return (char *) NULL;
d1313 2
a1314 2
	      s = (char *) calloc(2 * bn->bn_len, sizeof(char));
	      if (s == (char *) NULL)
d1317 1
a1317 1
		  return (char *) NULL;
d1324 1
a1324 1
		  return (char *) NULL;
d1332 1
a1332 1
    return (char *) NULL;
@


1.22
log
@More style improvement and removal of NULL/allocation casts.

ok tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.21 2015/12/18 22:55:04 mmcc Exp $ */
d591 1
a591 2
    if ((key1 == (void *) NULL) ||
	(key2 == (void *) NULL))
d597 1
a597 1
	    if  (!strcmp((char *) key1, (char *) key2))
d661 1
a661 1
    unsigned char *sig, *decoded = (char *) NULL, *ptr;
d668 4
a671 4
    if ((as->as_signature == (char *) NULL) ||
	(as->as_startofsignature == (char *) NULL) ||
	(as->as_allbutsignature == (char *) NULL) ||
	(as->as_allbutsignature - as->as_startofsignature <= 0))
d725 1
a725 1
	    ptr = (char *) NULL;
d744 1
a744 1
	    decoded = (unsigned char *) calloc(len, sizeof(unsigned char));
d746 1
a746 2
	    if (decoded == (unsigned char *) NULL)
	    {
d757 2
a758 3
	    decoded = (unsigned char *) strdup(sig);
	    if (decoded == (unsigned char *) NULL)
	    {
d775 2
a776 4
	if (DSA_verify(0, res2, hashlen, decoded, len, dsa) == 1)
	{
	    if (ptr != (unsigned char *) NULL)
	      free(ptr);
d785 2
a786 4
					   decoded, len, rsa) == 1)
          {
              if (ptr != (unsigned char *) NULL)
                free(ptr);
d796 2
a797 4
			   len, rsa) == 1)
	    {
		if (ptr != (unsigned char *) NULL)
		  free(ptr);
d804 1
a804 2
    if (ptr != (unsigned char *) NULL)
      free(ptr);
d817 2
a818 2
    unsigned char *sig = (char *) NULL, *finalbuf = (char *) NULL;
    unsigned char res2[LARGEST_HASH_SIZE], *sbuf = (char *) NULL;
d826 7
a832 7
    if ((as->as_signature_string_s == (char *) NULL) ||
	(as->as_startofsignature == (char *) NULL) ||
	(as->as_allbutsignature == (char *) NULL) ||
	(as->as_allbutsignature - as->as_startofsignature <= 0) ||
	(as->as_authorizer == (void *) NULL) ||
	(key == (void *) NULL) ||
	(as->as_signeralgorithm == KEYNOTE_ALGORITHM_NONE))
d835 1
a835 1
	return (char *) NULL;
d852 1
a852 1
	return (char *) NULL;
@


1.21
log
@Remove code for unimplemented ElGamel support that's been disabled for
sixteen years.

ok millert@@, tb@@, sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.20 2015/12/14 03:35:40 mmcc Exp $ */
d370 1
a370 1
    void *kk = (void *) NULL;
d386 1
a386 3
	dc->dec_key = (void *) strdup(key);
	if (dc->dec_key == (void *) NULL)
	{
d420 1
a420 1
	    decoded = (unsigned char *) calloc(len, sizeof(unsigned char));
d422 1
a422 2
	    if (decoded == (unsigned char *) NULL)
	    {
d433 1
a433 2
	    if (decoded == (unsigned char *) NULL)
	    {
d451 1
a451 2
	if (dc->dec_key == (DSA *) NULL)
	{
d459 2
a460 4
	    if (d2i_DSAPrivateKey((DSA **) &kk,(const unsigned char **) &decoded, len) == (DSA *) NULL)
	    {
		if (ptr != (unsigned char *) NULL)
		  free(ptr);
d468 2
a469 4
	    if (d2i_DSAPublicKey((DSA **) &kk, (const unsigned char **) &decoded, len) == (DSA *) NULL)
	    {
		if (ptr != (unsigned char *) NULL)
		  free(ptr);
d476 1
a476 2
	if (ptr != (unsigned char *) NULL)
	  free(ptr);
d486 1
a486 2
        if (dc->dec_key == (RSA *) NULL)
        {
d494 2
a495 4
            if (d2i_RSAPrivateKey((RSA **) &kk, (const unsigned char **) &decoded, len) == (RSA *) NULL)
            {
                if (ptr != (unsigned char *) NULL)
                  free(ptr);
d500 2
a501 4
	    if (RSA_blinding_on ((RSA *) kk, NULL) != 1)
	    {
                if (ptr != (unsigned char *) NULL)
                  free(ptr);
d509 2
a510 4
            if (d2i_RSAPublicKey((RSA **) &kk, (const unsigned char **) &decoded, len) == (RSA *) NULL)
            {
                if (ptr != (unsigned char *) NULL)
                  free(ptr);
d517 1
a517 2
        if (ptr != (unsigned char *) NULL)
          free(ptr);
d527 1
a527 2
	if ((px509Cert = X509_new()) == (X509 *) NULL)
	{
d541 1
a541 2
	if ((pPublicKey = X509_get_pubkey(px509Cert)) == (EVP_PKEY *) NULL)
	{
d573 1
a573 2
    if (ptr != (unsigned char *) NULL)
      free(ptr);
@


1.20
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.19 2013/11/13 16:28:17 deraadt Exp $ */
a250 19

#if 0 /* Not supported yet */
    if (!strncasecmp(SIG_ELGAMAL_SHA1_HEX, sig, SIG_ELGAMAL_SHA1_HEX_LEN))
    {
	*hash = KEYNOTE_HASH_SHA1;
	*enc = ENCODING_HEX;
	*internal = INTERNAL_ENC_ASN1;
	return KEYNOTE_ALGORITHM_ELGAMAL;
    }

    if (!strncasecmp(SIG_ELGAMAL_SHA1_BASE64, sig,
		     SIG_ELGAMAL_SHA1_BASE64_LEN))
    {
	*hash = KEYNOTE_HASH_SHA1;
	*enc = ENCODING_BASE64;
	*internal = INTERNAL_ENC_ASN1;
	return KEYNOTE_ALGORITHM_ELGAMAL;
    }
#endif /* 0 */
@


1.19
log
@correct types for arguments to the x509 functions
ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.18 2006/12/16 06:18:35 ray Exp $ */
d566 1
a566 2
	    if (ptr)
	      free(ptr);
d573 1
a573 2
	    if (ptr)
	      free(ptr);
d581 1
a581 2
	    if (ptr)
	      free(ptr);
d590 1
a590 2
	if(ptr)
	  free(ptr);
@


1.18
log
@strlen fix.

OK jaredy@@ and millert@@.
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.17 2004/06/29 11:35:56 msf Exp $ */
d392 3
a394 2
    unsigned char *ptr = (char *) NULL, *decoded = (char *) NULL;
    int encoding, internalencoding, len = 0;
d572 1
a572 1
	if(d2i_X509(&px509Cert, &decoded, len) == NULL)
d1244 1
a1244 1
	ptr = foo = (char *) calloc(i, sizeof(char));
@


1.17
log
@Header cleanup.
ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.16 2004/06/25 05:06:49 msf Exp $ */
d1153 1
a1153 1
    if (sigalg[strlen(sigalg) - 1] != ':')
@


1.16
log
@Make crufty configure stuff go away. Remove all unused code paths.
No change in binaries.

ok millert@@ deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.15 2003/03/14 15:49:36 ho Exp $ */
d30 1
d35 7
a41 1
#include "header.h"
@


1.15
log
@RSA blinding on private keys. angelos@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.14 2002/06/17 19:39:20 angelos Exp $ */
d27 1
a27 3
#if HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */
d29 1
a29 1
#include <sys/types.h>
a31 2

#if STDC_HEADERS
a32 5
#endif /* STDC_HEADERS */

#if HAVE_LIMITS_H
#include <limits.h>
#endif /* HAVE_LIMITS_H */
a132 1
#ifdef CRYPTO
a152 10
#endif /* CRYPTO */

#ifdef PGPLIB
    /* PGP keys */
    if (type == KEYNOTE_ALGORITHM_PGP)
    {
	/* Unsupported yet */
	return;
    }
#endif /* PGPLIB */
a263 10
#ifdef PGPLIB
    if (!strncasecmp(SIG_PGP_NATIVE, sig, SIG_PGP_NATIVE_LEN))
    {
	*hash = KEYNOTE_HASH_NONE;
	*enc = ENCODING_NATIVE;
	*internal = INTERNAL_ENC_NATIVE;
	return KEYNOTE_ALGORITHM_PGP;
    }
#endif /* PGPLIB */

a278 1
#ifdef CRYPTO
a335 10
#endif /* CRYPTO */

#ifdef PGPLIB
    if (!strncasecmp(PGP_NATIVE, key, PGP_NATIVE_LEN))
    {
	*internalencoding = INTERNAL_ENC_NATIVE;
	*encoding = ENCODING_NATIVE;
	return KEYNOTE_ALGORITHM_PGP;
    }
#endif /* PGPLIB */
a381 1
#ifdef CRYPTO
a384 1
#endif /* CRYPTO */
a460 1
#ifdef CRYPTO
a588 1
#endif /* CRYPTO */
a622 1
#ifdef CRYPTO
a624 1
#endif /* CRYPTO */
a639 1
#ifdef CRYPTO
a648 3
#else /* CRYPTO */
	    return RESULT_FALSE;
#endif /* CRYPTO */
a650 1
#ifdef CRYPTO
a657 3
#else /* CRYPTO */
	    return RESULT_FALSE;
#endif /* CRYPTO */
a659 1
#ifdef CRYPTO
a666 3
#else /* CRYPTO */
	    return RESULT_FALSE;
#endif /* CRYPTO */
a696 1
#if defined(CRYPTO) || defined(PGPLIB)
a698 1
#ifdef CRYPTO
a704 1
#endif /* CRYPTO */
a732 1
#ifdef CRYPTO
a740 1
#endif /* CRYPTO */
a743 1
#ifdef CRYPTO
a751 1
#endif /* CRYPTO */
a850 1
#endif /* CRYPTO || PGPLIB */
a861 2
#if defined(CRYPTO) || defined(PGPLIB)
#ifdef CRYPTO
a869 1
#endif /* CRYPTO */
a912 1
#ifdef CRYPTO
a919 1
#endif /* CRYPTO */
a922 1
#ifdef CRYPTO
a929 1
#endif /* CRYPTO */
a935 1
#ifdef CRYPTO
a998 1
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
a999 3
#else /* SSLEAY_VERSION_NUMBER */
	  rsa = (RSA *) PEM_read_bio_RSAPrivateKey(biokey, NULL, NULL);
#endif /* SSLEAY_VERSION_NUMBER */
a1103 5
#endif /* CRYPTO */
#else  /* CRYPTO || PGPLIB */
    keynote_errno = ERROR_SYNTAX;
    return (char *) NULL;
#endif /* CRYPTO || PGPLIB */
a1203 1
#ifdef CRYPTO
a1207 1
#endif /* CRYPTO */
a1218 1
#ifdef CRYPTO
a1344 1
#endif /* CRYPTO */
@


1.14
log
@Make the stupid warnings go away.
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.13 2002/06/09 02:12:55 deraadt Exp $ */
d568 8
@


1.13
log
@use strchr() instead of index()
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.12 2002/05/27 06:29:14 deraadt Exp $ */
d519 1
a519 1
	    if (d2i_DSAPrivateKey((DSA **) &kk, &decoded, len) == (DSA *) NULL)
d530 1
a530 1
	    if (d2i_DSAPublicKey((DSA **) &kk, &decoded, len) == (DSA *) NULL)
d560 1
a560 1
            if (d2i_RSAPrivateKey((RSA **) &kk, &decoded, len) == (RSA *) NULL)
d571 1
a571 1
            if (d2i_RSAPublicKey((RSA **) &kk, &decoded, len) == (RSA *) NULL)
@


1.12
log
@snprintf and strlcpy cleanup; angelos ok
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.11 2001/09/03 20:14:51 deraadt Exp $ */
d450 1
a450 1
    key = index(key, ':'); /* Move forward, to the Encoding. We're guaranteed
d778 1
a778 1
    sig = index(as->as_signature, ':');   /* Move forward to the Encoding. We
d963 1
a963 1
    sig = index(sigalg, ':');
@


1.11
log
@with or without fee; received mail permitting this change from angelos
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.10 1999/10/26 22:31:39 angelos Exp $ */
d932 1
d1141 2
a1142 2
    as->as_signature = (char *) calloc(strlen(sigalg) +
				       strlen(finalbuf) + 1, sizeof(char));
d1151 1
a1151 1
    sprintf(as->as_signature, "%s%s", sigalg, finalbuf);
@


1.10
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.8 1999/10/09 06:59:37 angelos Exp $ */
d10 1
a10 1
 * Permission to use, copy, and modify this software without fee
@


1.9
log
@Roll back yesterday's commit, will wait until after 2.6.
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.7 1999/10/01 01:08:30 angelos Exp $ */
d43 1
@


1.8
log
@Move all ifdefs in header.h (instead of keynote.h), include header.h
in all files including keynote.h, update manpage.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a42 1
#include "header.h"
@


1.7
log
@Update for version 2.0
@
text
@d43 1
@


1.6
log
@Indentation.
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.5 1999/08/13 22:49:54 angelos Exp $ */
d27 6
d34 6
a39 1
#include <stdlib.h>
d41 1
a41 1
#include <string.h>
a185 2
#if defined(CRYPTO) || defined(PGPLIB)

a297 1
#endif /* CRYPTO || PGPLIB */
d692 13
d715 1
a715 1
	    return RETURN_FALSE;
d770 5
a774 1
    if (alg != as->as_signeralgorithm)
d946 10
a955 1
    if ((alg != as->as_signeralgorithm) || (alg != keyalg))
d1064 1
a1064 1
#if SSLEAY_VERSION_NUMBER >= 0x00904
a1068 1

@


1.5
log
@Work with newest version of OpenSSL.
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.4 1999/05/31 20:10:00 angelos Exp $ */
d331 2
a332 2
	*internalencoding=INTERNAL_ENC_ASN1;
	*encoding=ENCODING_BASE64;
d338 2
a339 2
	*internalencoding=INTERNAL_ENC_ASN1;
	*encoding=ENCODING_HEX;
@


1.4
log
@Sanitize prototypes and variable extern definitions, remove
unnecessary header file, add prototypes header file for utility building.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1030 3
d1034 2
@


1.3
log
@Correct prototype and invocation, eliminate a warning or three.
@
text
@d1 1
a1 2
/* $OpenBSD: signature.c,v 1.2 1999/05/25 21:42:23 angelos Exp $ */

d31 3
@


1.2
log
@Export kn_keycompare() in the API, update the spec and man pages.

Note that the *.1 manpages will all be rolled into a single one soon.
@
text
@d1 1
a1 1
/* $OpenBSD: signature.c,v 1.1.1.1 1999/05/23 22:11:06 angelos Exp $ */
d418 1
a418 1
    int encoding, internalencoding, len;
a478 1
	    len = strlen(key);
d484 1
d731 1
a733 1
    int len;
d831 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d647 1
a647 1
keynote_keycompare(void *key1, void *key2, int algorithm)
@


1.1.1.1
log
@KeyNote version 2 trust-management system (security policy handling).
Utilities to follow.

@
text
@@
