head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.6
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.8
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.36
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.34
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.32
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.30
	OPENBSD_5_0:1.20.0.28
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.26
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.24
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.20
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.22
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.18
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.16
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.14
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.12
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.10
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.8
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.6
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.8
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.6
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.4
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.15.0.4
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	KeyNote-v2:1.1.1.1
	Angelos:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2015.12.23.20.28.15;	author mmcc;	state Exp;
branches;
next	1.28;
commitid	UNfgHU263dFB4fLV;

1.28
date	2015.12.19.01.15.44;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	YfsUBp4N7AxhUEml;

1.27
date	2015.12.18.17.51.29;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	N0LzmXTDZr0ds65i;

1.26
date	2015.12.18.17.48.13;	author mmcc;	state Exp;
branches;
next	1.25;
commitid	xiRjC3btcGaefEhD;

1.25
date	2015.12.14.06.34.25;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	ywbZJKLcmn6VLNIQ;

1.24
date	2015.12.14.06.18.06;	author mmcc;	state Exp;
branches;
next	1.23;
commitid	FYKbafTkhcSVBvkU;

1.23
date	2015.11.18.16.08.39;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	tTDiHUWlGlmbqaDK;

1.22
date	2014.10.08.11.28.07;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	PoH8FRhvT6pWAW8l;

1.21
date	2013.11.29.19.00.51;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.05.09.58.38;	author hshoexer;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.29.11.35.56;	author msf;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.25.05.06.49;	author msf;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.02.23.01.10;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.03.20.14.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.03.01.33.56;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.27.00.09.54;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.26.23.28.46;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.13.19.16.15;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.18.17.22.44;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.18.07.58.45;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	99.10.26.22.31.38;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	99.10.09.19.47.31;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	99.10.09.06.59.37;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	99.10.09.06.34.14;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.10.06.20.27.46;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.10.06.19.26.14;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.10.01.01.08.29;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.05.31.20.09.58;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.05.23.22.11.04;	author angelos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.23.22.11.04;	author angelos;	state Exp;
branches;
next	;


desc
@@


1.29
log
@remove a few NULL-checks before free()
@
text
@/* $OpenBSD: environment.c,v 1.28 2015/12/19 01:15:44 mmcc Exp $ */
/*
 * The author of this code is Angelos D. Keromytis (angelos@@dsl.cis.upenn.edu)
 *
 * This code was written by Angelos D. Keromytis in Philadelphia, PA, USA,
 * in April-May 1998
 *
 * Copyright (C) 1998, 1999 by Angelos D. Keromytis.
 *	
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, THE AUTHORS MAKES NO
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */


#include <sys/types.h>

#include <ctype.h>
#include <fcntl.h>
#include <regex.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "keynote.h"
#include "assertion.h"

static int sessioncounter = 0;

char **keynote_values = NULL;
char *keynote_privkey = NULL;

struct assertion *keynote_current_assertion = NULL;

struct environment *keynote_init_list = NULL;
struct environment *keynote_temp_list = NULL;

struct keylist *keynote_keypred_keylist = NULL;

struct keynote_session *keynote_sessions[SESSIONTABLESIZE];
struct keynote_session *keynote_current_session = NULL;

int keynote_exceptionflag = 0;
int keynote_used_variable = 0;
int keynote_returnvalue = 0;
int keynote_justrecord = 0;
int keynote_donteval = 0;
int keynote_errno = 0;

/*
 * Construct the _ACTION_AUTHORIZERS variable value.
 */
static char *
keynote_get_action_authorizers(char *name)
{
    struct keylist *kl;
    size_t cachesize;
    int len;

    if (!strcmp(name, KEYNOTE_CALLBACK_CLEANUP) ||
        !strcmp(name, KEYNOTE_CALLBACK_INITIALIZE))
    {
        free(keynote_current_session->ks_authorizers_cache);
        keynote_current_session->ks_authorizers_cache = NULL;

	return "";
    }

    if (keynote_current_session->ks_authorizers_cache != NULL)
      return keynote_current_session->ks_authorizers_cache;

    for (cachesize = 0, kl = keynote_current_session->ks_action_authorizers;
	 kl != NULL;
	 kl = kl->key_next)
      if (kl->key_stringkey != NULL)
        cachesize += strlen(kl->key_stringkey) + 1;

    if (cachesize == 0)
      return "";

    keynote_current_session->ks_authorizers_cache =
	calloc(cachesize, sizeof(char));
    if (keynote_current_session->ks_authorizers_cache == NULL) {
	keynote_errno = ERROR_MEMORY;
	return NULL;
    }

    for (len = 0, kl = keynote_current_session->ks_action_authorizers;
	 kl != NULL;
	 kl = kl->key_next)
      if (kl->key_stringkey != NULL) {
	  snprintf(keynote_current_session->ks_authorizers_cache + len,
		   cachesize - len, "%s,", kl->key_stringkey);
	  len += strlen(kl->key_stringkey) + 1;
      }

    keynote_current_session->ks_authorizers_cache[len - 1] = '\0';
    return keynote_current_session->ks_authorizers_cache;
}

/*
 * Construct the _VALUES variable value.
 */
static char *
keynote_get_values(char *name)
{
    int i, len;
    size_t cachesize;

    if (!strcmp(name, KEYNOTE_CALLBACK_CLEANUP) ||
        !strcmp(name, KEYNOTE_CALLBACK_INITIALIZE))
    {
        free(keynote_current_session->ks_values_cache);
        keynote_current_session->ks_values_cache = NULL;

	return "";
    }

    if (keynote_current_session->ks_values_cache != NULL)
      return keynote_current_session->ks_values_cache;

    for (cachesize = 0, i = 0; i < keynote_current_session->ks_values_num; i++)
      cachesize += strlen(keynote_current_session->ks_values[i]) + 1;

    if (cachesize == 0)
      return "";

    keynote_current_session->ks_values_cache =
	calloc(cachesize, sizeof(char));
    if (keynote_current_session->ks_values_cache == NULL) {
	keynote_errno = ERROR_MEMORY;
	return NULL;
    }

    for (len = 0, i = 0; i < keynote_current_session->ks_values_num; i++)
    {
	snprintf(keynote_current_session->ks_values_cache + len,
		 cachesize - len, "%s,", keynote_current_session->ks_values[i]);
	len += strlen(keynote_current_session->ks_values[i]) + 1;
    }

    keynote_current_session->ks_values_cache[len - 1] = '\0';
    return keynote_current_session->ks_values_cache;
}

/*
 * Free an environment structure.
 */
void
keynote_free_env(struct environment *en)
{
    if (en == NULL)
      return;

    free(en->env_name);

    if (en->env_flags & ENVIRONMENT_FLAG_REGEX)
      regfree(&(en->env_regex));

    if (!(en->env_flags & ENVIRONMENT_FLAG_FUNC))
    {
        free(en->env_value);
    }
    else
      ((char * (*) (char *))en->env_value)(KEYNOTE_CALLBACK_CLEANUP);

    free(en);
}

/*
 * Lookup for variable "name" in the hash table. If hashsize is 1,
 * then the second argument is actually a pointer to a list. Last
 * argument specifies case-insensitivity.
 */
char *
keynote_env_lookup(char *name, struct environment **table,
                   unsigned int hashsize)
{
    struct environment *en;

    for (en = table[keynote_stringhash(name, hashsize)]; 
	 en != NULL;
	 en = en->env_next)
      if (((en->env_flags & ENVIRONMENT_FLAG_REGEX) &&
	   (regexec(&(en->env_regex), name, 0, NULL, 0) == 0)) ||
	    (!strcmp(name, en->env_name)))
      {
	  if ((en->env_flags & ENVIRONMENT_FLAG_FUNC) &&
	      (en->env_value != NULL))
	    return ((char * (*) (char *)) en->env_value)(name);
	  else
	    return en->env_value;
      }

    return NULL;
}

/*
 * Delete a variable from hash table. Return RESULT_TRUE if the deletion was
 * successful, and RESULT_FALSE if the variable was not found.
 */
int
keynote_env_delete(char *name, struct environment **table,
                   unsigned int hashsize)
{
    struct environment *en, *en2;
    unsigned int h;
    
    h = keynote_stringhash(name, hashsize);
    
    if (table[h] != NULL)
    {
	if (!strcmp(table[h]->env_name, name))
	{
	    en = table[h];
	    table[h] = en->env_next;
	    keynote_free_env(en);
	    return RESULT_TRUE;
	}
	else
	  for (en = table[h]; 
	       en->env_next != NULL;
	       en = en->env_next)
	    if (!strcmp(en->env_next->env_name, name))
	    {
		en2 = en->env_next;
		en->env_next = en2->env_next;
		keynote_free_env(en2);
		return RESULT_TRUE;
	    }
    }

   return RESULT_FALSE;
}

/* 
 * Add a new variable in hash table. Return RESULT_TRUE on success,
 * ERROR_MEMORY on failure. If hashsize is 1, second argument is
 * actually a pointer to a list. The arguments are duplicated.
 */
int
keynote_env_add(char *name, char *value, struct environment **table,
		unsigned int hashsize, int flags)
{
    struct environment *en;
    unsigned int h, i;
    
    en = calloc(1, sizeof(struct environment));
    if (en == NULL) {
	keynote_errno = ERROR_MEMORY;
	return -1;
    }

    en->env_name = strdup(name);
    if (en->env_name == NULL) {
	keynote_free_env(en);
	keynote_errno = ERROR_MEMORY;
	return -1;
    }

    if (flags & ENVIRONMENT_FLAG_REGEX) /* Regular expression for name */
    {
	if ((i = regcomp(&(en->env_regex), name, REG_EXTENDED)) != 0)
	{
	    keynote_free_env(en);
	    if (i == REG_ESPACE)
	      keynote_errno = ERROR_MEMORY;
	    else
	      keynote_errno = ERROR_SYNTAX;
	    return -1;
	}
        en->env_flags |= ENVIRONMENT_FLAG_REGEX;
    }

    if (flags & ENVIRONMENT_FLAG_FUNC) /* Callback registration */
    {
	en->env_value = value;
	en->env_flags |= ENVIRONMENT_FLAG_FUNC;
        ((char * (*) (char *))en->env_value)(KEYNOTE_CALLBACK_INITIALIZE);
	if (keynote_errno != 0)
	{
	    keynote_free_env(en);
	    return -1;
	}
    }
    else
    {
	en->env_value = strdup(value);
	if (en->env_value == NULL) {
	    keynote_free_env(en);
	    keynote_errno = ERROR_MEMORY;
	    return -1;
	}
    }

    /* 
     * This means that new assignments of existing variable will override 
     * the old ones.
     */
    h = keynote_stringhash(name, hashsize);
    en->env_next = table[h];
    table[h] = en;
    return RESULT_TRUE;
}

/*
 * Cleanup an environment table.
 */
void
keynote_env_cleanup(struct environment **table, unsigned int hashsize)
{
    struct environment *en2;

    if ((hashsize == 0) || (table == NULL))
      return;
    
    while (hashsize > 0)
    {
	while (table[hashsize - 1] != NULL) {
	    en2 = table[hashsize - 1]->env_next;
	    keynote_free_env(table[hashsize - 1]);
	    table[hashsize - 1] = en2;
	}

	hashsize--;
    }
}

/*
 * Zero out the attribute structures, seed the RNG.
 */
static int
keynote_init_environment(void)
{
    memset(keynote_current_session->ks_env_table, 0,
	   HASHTABLESIZE * sizeof(struct environment *));
    memset(keynote_current_session->ks_assertion_table, 0,
	   HASHTABLESIZE * sizeof(struct assertion *));
    keynote_current_session->ks_env_regex = NULL;

    if (keynote_env_add("_ACTION_AUTHORIZERS",
			(char *) keynote_get_action_authorizers,
			keynote_current_session->ks_env_table, HASHTABLESIZE,
			ENVIRONMENT_FLAG_FUNC) != RESULT_TRUE)
      return -1;

    if (keynote_env_add("_VALUES", (char *) keynote_get_values,
			keynote_current_session->ks_env_table, HASHTABLESIZE,
			ENVIRONMENT_FLAG_FUNC) != RESULT_TRUE)
      return -1;

    return RESULT_TRUE;
}

/*
 * Return the index of argument in keynote_values[].
 */
int
keynote_retindex(char *s)
{
    int i;
    
    for (i = 0; i < keynote_current_session->ks_values_num; i++)
      if (!strcmp(s, keynote_current_session->ks_values[i]))
	return i;

    return -1;
}

/*
 * Find a session by its id.
 */
struct keynote_session *
keynote_find_session(int sessid)
{
    unsigned int h = sessid % SESSIONTABLESIZE;
    struct keynote_session *ks;
    
    for (ks = keynote_sessions[h];
	 ks != NULL;
	 ks = ks->ks_next)
      if (ks->ks_id == sessid)
	return ks;

    return NULL;
}

/*
 * Add a session in the hash table.
 */
static void
keynote_add_session(struct keynote_session *ks)
{
    unsigned int h = ks->ks_id % SESSIONTABLESIZE;

    ks->ks_next = keynote_sessions[h];
    if (ks->ks_next != NULL)
      ks->ks_next->ks_prev = ks;

    keynote_sessions[h] = ks;
}

/*
 * Initialize a KeyNote session.
 */
int
kn_init(void)
{
    keynote_errno = 0;
    keynote_current_session = calloc(1, sizeof(struct keynote_session));
    if (keynote_current_session == NULL) {
	keynote_errno = ERROR_MEMORY;
	return -1;
    }

    while (keynote_find_session(sessioncounter) != NULL) {
	sessioncounter++;
	if (sessioncounter < 0)
	  sessioncounter = 0;
    }

    keynote_current_session->ks_id = sessioncounter++;
    keynote_init_environment();
    keynote_add_session(keynote_current_session);
    return keynote_current_session->ks_id;
}

/*
 * Cleanup the action environment.
 */
int
kn_cleanup_action_environment(int sessid)
{
    struct keynote_session *ks;

    keynote_errno = 0;
    if ((keynote_current_session == NULL) ||
	(keynote_current_session->ks_id != sessid))
    {
	keynote_current_session = keynote_find_session(sessid);
	if (keynote_current_session == NULL) {
	    keynote_errno = ERROR_NOTFOUND;
	    return -1;
	}
    }

    ks = keynote_current_session;

    /* Cleanup environment */
    keynote_env_cleanup(ks->ks_env_table, HASHTABLESIZE);
    keynote_env_cleanup(&(ks->ks_env_regex), 1);

    return 0;
}

/*
 * Close a session.
 */
int
kn_close(int sessid)
{
    struct keynote_session *ks;
    struct assertion *as, *as2;
    int i;

    keynote_errno = 0;
    if ((keynote_current_session == NULL) ||
	(keynote_current_session->ks_id != sessid))
    {
	keynote_current_session = keynote_find_session(sessid);
	if (keynote_current_session == NULL) {
	    keynote_errno = ERROR_NOTFOUND;
	    return -1;
	}
    }

    ks = keynote_current_session;

    /* Cleanup environment -- no point using kn_cleanup_action_environment() */
    keynote_env_cleanup(ks->ks_env_table, HASHTABLESIZE);
    keynote_env_cleanup(&(ks->ks_env_regex), 1);

    /* Cleanup assertions */
    for (i = 0; i < HASHTABLESIZE; i++)
      for (as = ks->ks_assertion_table[i];
	   as != NULL;
	   as = as2)
      {
	  as2 = as->as_next;
	  keynote_free_assertion(as);
      }

    /* Cleanup action authorizers */
    keynote_keylist_free(ks->ks_action_authorizers);

    /* Unlink from chain */
    if (ks->ks_prev == NULL) {
	keynote_sessions[ks->ks_id % SESSIONTABLESIZE] = ks->ks_next;
	if (ks->ks_next != NULL)
	  ks->ks_next->ks_prev = NULL;
	
    }
    else
    {
	ks->ks_prev->ks_next = ks->ks_next;
	if (ks->ks_next != NULL)
	  ks->ks_next->ks_prev = ks->ks_prev;
    }
    
    free(ks);
    keynote_current_session = NULL;
    return 0;
}
	
/*
 * Add an action attribute.
 */
int
kn_add_action(int sessid, char *name, char *value, int flags)
{
    int i;

    keynote_errno = 0;
    if (name == NULL || value == NULL || name[0] == '_') {
	keynote_errno = ERROR_SYNTAX;
	return -1;
    }

    if (keynote_current_session == NULL ||
	keynote_current_session->ks_id != sessid)
    {
	keynote_current_session = keynote_find_session(sessid);
	if (keynote_current_session == NULL) {
	    keynote_errno = ERROR_NOTFOUND;
	    return -1;
	}
    }

    if (flags & ENVIRONMENT_FLAG_REGEX)
      i = keynote_env_add(name, value, 
			  &(keynote_current_session->ks_env_regex), 1, flags);
    else
      i = keynote_env_add(name, value, keynote_current_session->ks_env_table,
			  HASHTABLESIZE, flags);

    if (i == RESULT_TRUE)
      return 0;
    else
      return -1;
}

/*
 * Remove an action attribute.
 */
int
kn_remove_action(int sessid, char *name)
{
    int i;

    keynote_errno = 0;
    if (name == NULL || name[0] == '_') {
	keynote_errno = ERROR_SYNTAX;
	return -1;
    }

    if (keynote_current_session == NULL ||
	keynote_current_session->ks_id != sessid)
    {
	keynote_current_session = keynote_find_session(sessid);
	if (keynote_current_session == NULL) {
	    keynote_errno = ERROR_NOTFOUND;
	    return -1;
	}
    }

    i = keynote_env_delete(name, keynote_current_session->ks_env_table,
			   HASHTABLESIZE);
    if (i == RESULT_TRUE)
      return 0;

    i = keynote_env_delete(name, &(keynote_current_session->ks_env_regex),
			   HASHTABLESIZE);
    if (i == RESULT_TRUE)
      return 0;

    keynote_errno = ERROR_NOTFOUND;
    return -1;
}

/*
 * Execute a query.
 */
int
kn_do_query(int sessid, char **returnvalues, int numvalues)
{
    struct assertion *as;
    int i;

    keynote_errno = 0;
    if (keynote_current_session == NULL ||
	keynote_current_session->ks_id != sessid)
    {
	keynote_current_session = keynote_find_session(sessid);
	if (keynote_current_session == NULL) {
	    keynote_errno = ERROR_NOTFOUND;
	    return -1;
	}
    }

    /* Check that we have at least one action authorizer */
    if (keynote_current_session->ks_action_authorizers == NULL) {
	keynote_errno = ERROR_NOTFOUND;
	return -1;
    }

    /* 
     * We may use already set returnvalues, or use new ones,
     * but we must have some before we can evaluate.
     */
    if (returnvalues == NULL &&
	keynote_current_session->ks_values == NULL)
    {
	keynote_errno = ERROR_SYNTAX;
	return -1;
    }

    /* Replace any existing returnvalues */
    if (returnvalues != NULL) {
	keynote_current_session->ks_values = returnvalues;
	keynote_current_session->ks_values_num = numvalues;
    }

    /* Reset assertion state from any previous queries */
    for (i = 0; i < HASHTABLESIZE; i++)
      for (as = keynote_current_session->ks_assertion_table[i];
	   as != NULL;
	   as = as->as_next)
      {
	  as->as_kresult = KRESULT_UNTOUCHED;
	  as->as_result = 0;
	  as->as_internalflags &= ~ASSERT_IFLAG_PROCESSED;
	  as->as_error = 0;
	  if (as->as_internalflags & ASSERT_IFLAG_WEIRDSIG)
	    as->as_sigresult = SIGRESULT_UNTOUCHED;
      }

    return keynote_evaluate_query();
}

/*
 * Return assertions that failed, by error type.
 */
int
kn_get_failed(int sessid, int type, int num)
{
    struct assertion *as;
    int i;

    keynote_errno = 0;
    if (keynote_current_session == NULL ||
	keynote_current_session->ks_id != sessid)
    {
	keynote_current_session = keynote_find_session(sessid);
	if (keynote_current_session == NULL) {
	    keynote_errno = ERROR_NOTFOUND;
	    return -1;
	}
    }

    for (i = 0; i < HASHTABLESIZE; i++)
      for (as = keynote_current_session->ks_assertion_table[i];
	   as != NULL;
	   as = as->as_next)
	switch (type)
	{
	    case KEYNOTE_ERROR_ANY:
		if ((as->as_error != 0) ||
		    ((as->as_sigresult != SIGRESULT_TRUE) &&
		     !(as->as_sigresult == SIGRESULT_UNTOUCHED) &&
		     !(as->as_flags & ASSERT_FLAG_LOCAL)))
		  if (num-- == 0)  /* Return it if it's the num-th found */
		    return as->as_id;
		break;

	    case KEYNOTE_ERROR_MEMORY:
		if (as->as_error == ERROR_MEMORY)
		  if (num-- == 0)
		    return as->as_id;
		break;

	    case KEYNOTE_ERROR_SYNTAX:
		if (as->as_error == ERROR_SYNTAX)
		  if (num-- == 0)
		    return as->as_id;
		break;

	    case KEYNOTE_ERROR_SIGNATURE:
		if ((as->as_sigresult != SIGRESULT_TRUE) &&
		    !(as->as_sigresult == SIGRESULT_UNTOUCHED) &&
		    !(as->as_flags & ASSERT_FLAG_LOCAL))
		  if (num-- == 0)
		    return as->as_id;
		break;
	}

    keynote_errno = ERROR_NOTFOUND;
    return -1;
}

/*
 * Simple API for doing a single KeyNote query.
 */
int
kn_query(struct environment *env, char **retvalues, int numval,
	 char **trusted, int *trustedlen, int numtrusted,
	 char **untrusted, int *untrustedlen, int numuntrusted,
	 char **authorizers, int numauthorizers)
{
    struct environment *en;
    int sessid, i, serrno;

    keynote_errno = 0;
    if ((sessid = kn_init()) == -1)
      return -1;

    /* Action set */
    for (en = env; en != NULL; en = en->env_next)
      if (kn_add_action(sessid, en->env_name, en->env_value,
          en->env_flags) == -1)
      {
	  serrno = keynote_errno;
	  kn_close(sessid);
	  keynote_errno = serrno;
	  return -1;
      }

    /* Locally trusted assertions */
    for (i = 0; i < numtrusted; i++)
      if ((kn_add_assertion(sessid, trusted[i], trustedlen[i],
	  ASSERT_FLAG_LOCAL) == -1) && (keynote_errno == ERROR_MEMORY))
      {
	  serrno = keynote_errno;
	  kn_close(sessid);
	  keynote_errno = serrno;
	  return -1;
      }

    /* Untrusted assertions */
    for (i = 0; i < numuntrusted; i++)
      if ((kn_add_assertion(sessid, untrusted[i], untrustedlen[i], 0) == -1)
	  && (keynote_errno == ERROR_MEMORY))
      {
	  serrno = keynote_errno;
	  kn_close(sessid);
	  keynote_errno = serrno;
	  return -1;
      }

    /* Authorizers */
    for (i = 0; i < numauthorizers; i++)
      if (kn_add_authorizer(sessid, authorizers[i]) == -1)
      {
	  serrno = keynote_errno;
	  kn_close(sessid);
	  keynote_errno = serrno;
	  return -1;
      }

    i = kn_do_query(sessid, retvalues, numval);
    serrno = keynote_errno;
    kn_close(sessid);

    if (serrno)
      keynote_errno = serrno;

    return i;
}

/*
 * Read a buffer, break it up in assertions.
 */
char **
kn_read_asserts(char *buffer, int bufferlen, int *numassertions)
{
    int bufsize = 32, i, flag, valid;
    char **buf, **tempbuf, *ptr;

    keynote_errno = 0;
    if (buffer == NULL) {
	keynote_errno = ERROR_SYNTAX;
	return NULL;
    }

    if ((buf = calloc(bufsize, sizeof(char *))) == NULL) {
	keynote_errno = ERROR_MEMORY;
	return NULL;
    }

    /*
     * We'll go through the whole buffer looking for consecutive newlines,
     * which imply newline separation. We use the valid flag to keep
     * track of whether there may be an assertion after the last pair of
     * newlines, or whether there may be an assertion in the buffer to
     * begin with, if there are no consecutive newlines.
     */
    for (i = 0, flag = 0, valid = 0, *numassertions = 0, ptr = buffer;
	 i < bufferlen;
	 i++)
    {
	if (buffer[i] == '\n')
	{
	    if (flag)  /* Two newlines in a row, copy if there's anything */
	    {
		if (valid)  /* Something there */
		{
		    /* Allocate enough memory */
		    buf[*numassertions] = calloc((buffer + i) - ptr
							  + 1, sizeof(char));
		    if (buf[*numassertions] == NULL) {
			/* Free any already-allocated strings */
			for (flag = 0; flag < *numassertions; flag++)
			  free(buf[flag]);
			free(buf);
			keynote_errno = ERROR_MEMORY;
			return NULL;
		    }

		    /* Copy string */
		    memcpy(buf[*numassertions], ptr, (buffer + i) - ptr);
		    (*numassertions)++;
		}

		valid = 0; /* Reset */
		flag = 0;
		ptr = buffer + i + 1; /* Point right after this newline */

		/* See if we need to resize the buffer */
		if (*numassertions > bufsize - 4)
		{
		    /* Allocate twice the space */
		    tempbuf = reallocarray(buf, bufsize, 2 * sizeof(char *));
		    if (tempbuf == NULL) {
			for (flag = 0; flag < *numassertions; flag++)
			  free(buf[flag]);
			free(buf);
			keynote_errno = ERROR_MEMORY;
			return NULL;
		    }

		    buf = tempbuf;
		    bufsize *= 2;
		}
	    }
	    else
	      flag = 1;  /* One newline so far */

	    continue;
	}
	else
	  flag = 0;

	if (!isspace((unsigned char)buffer[i]))
	  valid = 1;
    }

    /*
     * There may be a valid assertion after the last pair of newlines.
     * Notice that because of the resizing check above, there will be
     * a valid memory location to store this last string.
     */
    if (valid)
    {
	/* This one's easy, we can just use strdup() */
	if ((buf[*numassertions] = strdup(ptr)) == NULL) {
	    for (flag = 0; flag < *numassertions; flag++)
	      free(buf[flag]);
	    free(buf);
	    keynote_errno = ERROR_MEMORY;
	    return NULL;
	}
	(*numassertions)++;
    }

    return buf;
}

/*
 * Return the authorizer key for a given assertion.
 */
void *
kn_get_authorizer(int sessid, int assertid, int *algorithm)
{
    struct assertion *as;
    int i;

    keynote_errno = *algorithm = 0;
    if (keynote_current_session == NULL ||
	keynote_current_session->ks_id != sessid)
    {
	keynote_current_session = keynote_find_session(sessid);
	if (keynote_current_session == NULL) {
	    keynote_errno = ERROR_NOTFOUND;
	    return NULL;
	}
    }

    /* Traverse the hash table looking for assertid */
    for (i = 0; i < HASHTABLESIZE; i++)
      for (as = keynote_current_session->ks_assertion_table[i];
	   as != NULL;
	   as = as->as_next)
	if (as->as_id == assertid)
	  goto out;

 out:
    if (as == NULL) {
	keynote_errno = ERROR_NOTFOUND;
	return NULL;
    }

    if (as->as_authorizer == NULL)
      if (keynote_evaluate_authorizer(as, 1) != RESULT_TRUE)
	return NULL;

    *algorithm = as->as_signeralgorithm;
    return as->as_authorizer;
}

/*
 * Return the licensees for a given assertion.
 */
struct keynote_keylist *
kn_get_licensees(int sessid, int assertid)
{
    struct assertion *as;
    int i;

    keynote_errno = 0;
    if (keynote_current_session == NULL ||
	keynote_current_session->ks_id != sessid)
    {
	keynote_current_session = keynote_find_session(sessid);
	if (keynote_current_session == NULL) {
	    keynote_errno = ERROR_NOTFOUND;
	    return NULL;
	}
    }

    /* Traverse the hash table looking for assertid */
    for (i = 0; i < HASHTABLESIZE; i++)
      for (as = keynote_current_session->ks_assertion_table[i];
	   as != NULL;
	   as = as->as_next)
	if (as->as_id == assertid)
	  goto out;

 out:
    if (as == NULL) {
	keynote_errno = ERROR_NOTFOUND;
	return NULL;
    }

    if (as->as_keylist == NULL)
      if (keynote_parse_keypred(as, 1) != RESULT_TRUE)
	return NULL;

    return (struct keynote_keylist *) as->as_keylist;
}
@


1.28
log
@More style improvement and removal of NULL/allocation casts.

ok tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.27 2015/12/18 17:51:29 mmcc Exp $ */
d71 2
a72 4
        if (keynote_current_session->ks_authorizers_cache != NULL) {
	    free(keynote_current_session->ks_authorizers_cache);
	    keynote_current_session->ks_authorizers_cache = NULL;
	}
d121 2
a122 4
        if (keynote_current_session->ks_values_cache != NULL) {
	    free(keynote_current_session->ks_values_cache);
	    keynote_current_session->ks_values_cache = NULL;
	}
d163 1
a163 2
    if (en->env_name != NULL)
      free(en->env_name);
d170 1
a170 2
        if (en->env_value != NULL)
	  free(en->env_value);
@


1.27
log
@A few more NULL casts and style tweaks. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.26 2015/12/18 17:48:13 mmcc Exp $ */
d199 2
a200 2
	   (regexec(&(en->env_regex), name, 0, (regmatch_t *) NULL, 0) ==
	    0)) || (!strcmp(name, en->env_name)))
@


1.26
log
@Cleanup and modernization. No functional change. Discussed with halex@@.
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.25 2015/12/14 06:34:25 mmcc Exp $ */
d911 2
a912 2
    if ((keynote_current_session == (struct keynote_session *) NULL) ||
	(keynote_current_session->ks_id != sessid))
d915 1
a915 2
	if (keynote_current_session == (struct keynote_session *) NULL)
	{
d917 1
a917 1
	    return (void *) NULL;
d924 1
a924 1
	   as != (struct assertion *) NULL;
d930 1
a930 2
    if (as == (struct assertion *) NULL)
    {
d932 1
a932 1
	return (void *) NULL;
d953 2
a954 2
    if ((keynote_current_session == (struct keynote_session *) NULL) ||
	(keynote_current_session->ks_id != sessid))
d957 1
a957 2
	if (keynote_current_session == (struct keynote_session *) NULL)
	{
d959 1
a959 1
	    return (struct keynote_keylist *) NULL;
d966 1
a966 1
	   as != (struct assertion *) NULL;
d972 1
a972 2
    if (as == (struct assertion *) NULL)
    {
d974 1
a974 1
	return (struct keynote_keylist *) NULL;
d979 1
a979 1
	return (struct keynote_keylist *) NULL;
@


1.25
log
@Remove more needless casts of NULL and allocations.
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.24 2015/12/14 06:18:06 mmcc Exp $ */
d538 1
a538 3
    if ((name == (char *) NULL) || (value == (char *) NULL) ||
	(name[0] == '_'))
    {
d543 2
a544 2
    if ((keynote_current_session == (struct keynote_session *) NULL) ||
	(keynote_current_session->ks_id != sessid))
d547 1
a547 2
	if (keynote_current_session == (struct keynote_session *) NULL)
	{
d575 1
a575 2
    if ((name == (char *) NULL) || (name[0] == '_'))
    {
d580 2
a581 2
    if ((keynote_current_session == (struct keynote_session *) NULL) ||
	(keynote_current_session->ks_id != sessid))
d584 1
a584 2
	if (keynote_current_session == (struct keynote_session *) NULL)
	{
d614 2
a615 2
    if ((keynote_current_session == (struct keynote_session *) NULL) ||
	(keynote_current_session->ks_id != sessid))
d618 1
a618 2
	if (keynote_current_session == (struct keynote_session *) NULL)
	{
d625 1
a625 3
    if (keynote_current_session->ks_action_authorizers ==
	(struct keylist *) NULL)
    {
d634 2
a635 2
    if ((returnvalues == (char **) NULL) &&
	(keynote_current_session->ks_values == (char **) NULL))
d642 1
a642 2
    if (returnvalues != (char **) NULL)
    {
d650 1
a650 1
	   as != (struct assertion *) NULL;
d674 2
a675 2
    if ((keynote_current_session == (struct keynote_session *) NULL) ||
	(keynote_current_session->ks_id != sessid))
d678 1
a678 2
	if (keynote_current_session == (struct keynote_session *) NULL)
	{
d686 1
a686 1
	   as != (struct assertion *) NULL;
d741 1
a741 1
    for (en = env; en != (struct environment *) NULL; en = en->env_next)
d803 1
a803 2
    if (buffer == (char *) NULL)
    {
d805 1
a805 1
	return (char **) NULL;
d808 1
a808 3
    buf = (char **) calloc(bufsize, sizeof(char *));
    if (buf == (char **) NULL)
    {
d810 1
a810 1
	return (char **) NULL;
d831 1
a831 1
		    buf[*numassertions] = (char *) calloc((buffer + i) - ptr
d833 1
a833 2
		    if (buf[*numassertions] == (char *) NULL)
		    {
d839 1
a839 1
			return (char **) NULL;
d855 2
a856 4
		    tempbuf = reallocarray(buf, bufsize,
			2 * sizeof(char *));
		    if (tempbuf == (char **) NULL)
		    {
d861 1
a861 1
			return (char **) NULL;
d888 1
a888 2
	if ((buf[*numassertions] = strdup(ptr)) == (char *) NULL)
	{
d893 1
a893 1
	    return (char **) NULL;
@


1.24
log
@Remove casts of allocations and NULL. There are a *ton* of these to
remove in libkeynote, but I'm doing it in small chunks so I don't slip
up.

Previously discussed and approved on the lists, although I backed off
after making a dumb mistake in a mega-diff.
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.23 2015/11/18 16:08:39 mmcc Exp $ */
d131 1
a131 1
    if (keynote_current_session->ks_values_cache != (char *) NULL)
d141 2
a142 3
	(char *) calloc(cachesize, sizeof(char));
    if (keynote_current_session->ks_values_cache == (char *) NULL)
    {
d144 1
a144 1
	return (char *) NULL;
d164 1
a164 1
    if (en == (struct environment *) NULL)
d167 1
a167 1
    if (en->env_name != (char *) NULL)
d175 1
a175 1
        if (en->env_value != (char *) NULL)
d196 1
a196 1
	 en != (struct environment *) NULL;
d203 1
a203 1
	      (en->env_value != (char *) NULL))
d209 1
a209 1
    return (char *) NULL;
d225 1
a225 1
    if (table[h] != (struct environment *) NULL)
d236 1
a236 1
	       en->env_next != (struct environment *) NULL;
d263 1
a263 2
    if (en == (struct environment *) NULL)
    {
d269 1
a269 2
    if (en->env_name == (char *) NULL)
    {
d303 1
a303 2
	if (en->env_value == (char *) NULL)
	{
d328 1
a328 1
    if ((hashsize == 0) || (table == (struct environment **) NULL))
d333 1
a333 2
	while (table[hashsize - 1] != (struct environment *) NULL)
	{
d353 1
a353 1
    keynote_current_session->ks_env_regex = (struct environment *) NULL;
d394 1
a394 1
	 ks != (struct keynote_session *) NULL;
d399 1
a399 1
    return (struct keynote_session *) NULL;
d411 1
a411 1
    if (ks->ks_next != (struct keynote_session *) NULL)
d424 2
a425 3
    keynote_current_session = (struct keynote_session *) calloc(1, sizeof(struct keynote_session));
    if (keynote_current_session == (struct keynote_session *) NULL)
    {
d430 1
a430 3
    while (keynote_find_session(sessioncounter) !=
	   (struct keynote_session *) NULL)
    {
d451 1
a451 1
    if ((keynote_current_session == (struct keynote_session *) NULL) ||
d455 1
a455 2
	if (keynote_current_session == (struct keynote_session *) NULL)
	{
d481 1
a481 1
    if ((keynote_current_session == (struct keynote_session *) NULL) ||
d485 1
a485 2
	if (keynote_current_session == (struct keynote_session *) NULL)
	{
d500 1
a500 1
	   as != (struct assertion *) NULL;
d511 1
a511 2
    if (ks->ks_prev == (struct keynote_session *) NULL)
    {
d513 2
a514 2
	if (ks->ks_next != (struct keynote_session *) NULL)
	  ks->ks_next->ks_prev = (struct keynote_session *) NULL;
d520 1
a520 1
	if (ks->ks_next != (struct keynote_session *) NULL)
d525 1
a525 1
    keynote_current_session = (struct keynote_session *) NULL;
@


1.23
log
@Remove memory.h includes.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.22 2014/10/08 11:28:07 deraadt Exp $ */
d38 2
a39 2
char **keynote_values = (char **) NULL;
char *keynote_privkey = (char *) NULL;
d41 1
a41 1
struct assertion *keynote_current_assertion = (struct assertion *) NULL;
d43 2
a44 2
struct environment *keynote_init_list = (struct environment *) NULL;
struct environment *keynote_temp_list = (struct environment *) NULL;
d46 1
a46 1
struct keylist *keynote_keypred_keylist = (struct keylist *) NULL;
d71 1
a71 2
        if (keynote_current_session->ks_authorizers_cache != (char *) NULL)
	{
d73 1
a73 1
	    keynote_current_session->ks_authorizers_cache = (char *) NULL;
d79 1
a79 1
    if (keynote_current_session->ks_authorizers_cache != (char *) NULL)
d83 1
a83 1
	 kl != (struct keylist *) NULL;
d85 1
a85 1
      if (kl->key_stringkey != (char *) NULL)
d92 2
a93 3
	(char *) calloc(cachesize, sizeof(char));
    if (keynote_current_session->ks_authorizers_cache == (char *) NULL)
    {
d95 1
a95 1
	return (char *) NULL;
d99 1
a99 1
	 kl != (struct keylist *) NULL;
d101 1
a101 2
      if (kl->key_stringkey != (char *) NULL)
      {
d123 1
a123 2
        if (keynote_current_session->ks_values_cache != (char *) NULL)
	{
d125 1
a125 1
	    keynote_current_session->ks_values_cache = (char *) NULL;
@


1.22
log
@obvious reallocarray()
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.21 2013/11/29 19:00:51 deraadt Exp $ */
a26 1
#include <memory.h>
@


1.21
log
@fairly simple unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.20 2005/01/05 09:58:38 hshoexer Exp $ */
d885 2
a886 2
		    tempbuf = (char **) realloc(buf, 2 * bufsize *
						sizeof(char *));
@


1.20
log
@remove wrong free() after realloc().

ok miod millert markus
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.19 2004/06/29 11:35:56 msf Exp $ */
d908 1
a908 1
	if (!isspace((int) buffer[i]))
@


1.19
log
@Header cleanup.
ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.18 2004/06/25 05:06:49 msf Exp $ */
a895 1
		    free(buf);     /* Free old buffer */
@


1.18
log
@Make crufty configure stuff go away. Remove all unused code paths.
No change in binaries.

ok millert@@ deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.17 2003/04/02 23:01:10 millert Exp $ */
d28 1
a33 1
#include "header.h"
@


1.17
log
@Use snprintf instead of sprintf; deraadt@@ OK
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.16 2001/09/03 20:14:51 deraadt Exp $ */
a21 3
#if HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */
d24 4
a29 3
#include <ctype.h>

#if STDC_HEADERS
a30 16
#if !defined(HAVE_MEMCPY)
#define memcpy(d, s, n) bcopy ((s), (d), (n))
#endif /* !HAVE_MEMCPY */
#endif /* STDC_HEADERS */

#if HAVE_MEMORY_H
#include <memory.h>
#endif /* HAVE_MEMORY_H */

#if HAVE_FCNTL_H
#include <fcntl.h>
#endif /* HAVE_FCNTL_H */

#if HAVE_IO_H
#include <io.h>
#elif HAVE_UNISTD_H
a31 1
#endif /* HAVE_IO_H */
a105 4
#if !defined(HAVE_SNPRINTF)
	  sprintf(keynote_current_session->ks_authorizers_cache + len,
		  "%s,", kl->key_stringkey);
#else /* !HAVE_SNPRINTF */
a107 1
#endif /* !HAVE_SNPRINTF */	
a154 4
#if !defined(HAVE_SNPRINTF)
	sprintf(keynote_current_session->ks_values_cache + len,
		"%s,", keynote_current_session->ks_values[i]);
#else /* !HAVE_SNPRINTF */
a156 1
#endif /* !HAVE_SNPRINTF */	
@


1.16
log
@with or without fee; received mail permitting this change from angelos
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.15 2000/10/03 01:33:56 angelos Exp $ */
d85 1
d103 1
a103 1
    for (len = 0, kl = keynote_current_session->ks_action_authorizers;
d107 1
a107 1
        len += strlen(kl->key_stringkey) + 1;
d109 1
a109 1
    if (len == 0)
d112 2
a113 1
    keynote_current_session->ks_authorizers_cache = (char *) calloc(len, sizeof(char));
d125 7
a131 2
	  sprintf(keynote_current_session->ks_authorizers_cache + len, "%s,",
		  kl->key_stringkey);
d146 1
d163 5
a167 2
    for (len = 0, i = 0; i < keynote_current_session->ks_values_num; i++)
      len += strlen(keynote_current_session->ks_values[i]) + 1;
d169 2
a170 2
    keynote_current_session->ks_values_cache = (char *) calloc(len,
							       sizeof(char));
a176 3
    if (len == 0)
      return "";

d179 7
a185 2
	sprintf(keynote_current_session->ks_values_cache + len, "%s,",
		keynote_current_session->ks_values[i]);
@


1.15
log
@Sync.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d10 1
a10 1
 * Permission to use, copy, and modify this software without fee
@


1.14
log
@Sync again (remove unneeded RAND_set calls).
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.13 2000/09/26 23:28:46 angelos Exp $ */
d212 2
a213 1
keynote_env_lookup(char *name, struct environment **table, u_int hashsize)
d239 2
a240 1
keynote_env_delete(char *name, struct environment **table, u_int hashsize)
d243 1
a243 1
    u_int h;
d279 1
a279 1
		u_int hashsize, int flags)
d282 1
a282 1
    u_int h, i;
d349 1
a349 1
keynote_env_cleanup(struct environment **table, u_int hashsize)
@


1.13
log
@Sync.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a372 4
#ifdef CRYPTO
    RAND_set_rand_method(RAND_SSLeay());
#endif /* CRYPTO */

@


1.12
log
@Fix some compile warnings.
@
text
@d374 1
a374 12
    int cnt = KEYNOTE_RAND_INIT_LEN, i;

    do
    {
        if ((i = RAND_load_file(KEYNOTERNDFILENAME, cnt)) <= 0)
        {
            keynote_errno = ERROR_MEMORY;
	    return -1;
        }
    
        cnt -= i;   
    } while (cnt > 0);
@


1.11
log
@Really find the requested assertions, and fix authorizer retrieval.
@
text
@d938 1
a938 1
	if (!isspace(buffer[i]))
@


1.10
log
@Plug a minor memory leak associated with kn_get_licensees(), and make
the latter work before a query has been issued.
@
text
@d973 1
a973 1
    keynote_errno = 0;
d991 1
a991 1
	  break;
d993 1
d1000 4
d1035 1
a1035 1
	  break;
d1037 1
@


1.9
log
@sync
@
text
@d1 1
a1 1
/*  $OpenBSD: environment.c,v 1.7 1999/10/09 06:59:37 angelos Exp $ */
d1037 4
@


1.8
log
@Roll back yesterday's commit, will wait until after 2.6.
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.5 1999/10/06 20:27:46 angelos Exp $ */
d52 1
d797 2
a798 2
      if (kn_add_action(sessid, en->env_name, en->env_value, en->env_flags) ==
	  -1)
d808 2
a809 2
      if (kn_add_assertion(sessid, trusted[i], trustedlen[i],
	  ASSERT_FLAG_LOCAL) == -1)
d819 2
a820 1
      if (kn_add_assertion(sessid, untrusted[i], untrustedlen[i], 0) == -1)
@


1.7
log
@Move all ifdefs in header.h (instead of keynote.h), include header.h
in all files including keynote.h, update manpage.
@
text
@d1 1
a1 1
/*  $OpenBSD$ */
a51 1
#include "header.h"
d796 2
a797 2
      if (kn_add_action(sessid, en->env_name, en->env_value,
          en->env_flags) == -1)
d807 2
a808 2
      if ((kn_add_assertion(sessid, trusted[i], trustedlen[i],
	  ASSERT_FLAG_LOCAL) == -1) && (keynote_errno == ERROR_MEMORY))
d818 1
a818 2
      if ((kn_add_assertion(sessid, untrusted[i], untrustedlen[i], 0) == -1)
	  && (keynote_errno == ERROR_MEMORY))
@


1.6
log
@Better handling of errors in kn_query, update manpage accordingly.
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* 
d52 1
@


1.5
log
@Make some of the perror() calls more informative, correct some
inconsistencies in the man page and the query tool, update the
testsuite accordingly.
@
text
@d1 2
a2 2
/* $OpenBSD: environment.c,v 1.4 1999/10/06 19:26:14 angelos Exp $ */
/*
d796 2
a797 2
      if (kn_add_action(sessid, en->env_name, en->env_value, en->env_flags) ==
	  -1)
d807 2
a808 2
      if (kn_add_assertion(sessid, trusted[i], trustedlen[i],
	  ASSERT_FLAG_LOCAL) == -1)
d818 2
a819 1
      if (kn_add_assertion(sessid, untrusted[i], untrustedlen[i], 0) == -1)
@


1.4
log
@Fix a typo in manpage, as well as bogus error reporting.
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.3 1999/10/01 01:08:29 angelos Exp $ */
d726 1
d796 8
a803 1
      kn_add_action(sessid, en->env_name, en->env_value, en->env_flags);
d807 8
a814 1
      kn_add_assertion(sessid, trusted[i], trustedlen[i], ASSERT_FLAG_LOCAL);
d818 7
a824 1
      kn_add_assertion(sessid, untrusted[i], untrustedlen[i], 0);
d828 7
a834 1
      kn_add_authorizer(sessid, authorizers[i]);
a855 1

d971 1
d1010 1
a1037 1

@


1.3
log
@Update for version 2.0
@
text
@d1 1
a1 1
/* $OpenBSD: environment.c,v 1.2 1999/05/31 20:09:58 angelos Exp $ */
d746 1
d766 1
@


1.2
log
@Sanitize prototypes and variable extern definitions, remove
unnecessary header file, add prototypes header file for utility building.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d22 6
d29 3
a31 1
#include <stdlib.h>
d33 10
a42 1
#include <ctype.h>
d44 3
a46 1
#ifdef WIN32
d48 1
a48 1
#else
d50 1
a50 1
#endif
a372 1
#if defined(KEYNOTERNDFILENAME)
a384 3
#else /* KEYNOTERNDFILENAME */
#error "You need to seed the RNG."
#endif /* KEYNOTERNDFILENAME */
d386 1
d484 29
d536 1
a536 1
    /* Cleanup environment */
d872 1
a872 1
		    bcopy(ptr, buf[*numassertions], (buffer + i) - ptr);
d933 76
@


1.1
log
@Initial revision
@
text
@a1 1

d33 2
a34 2
#include "environment.h"
#include "signature.h"
d38 10
a47 1
/* Globals */
d49 8
a56 3
struct keynote_session *keynote_current_session;
int    keynote_justrecord = 0;
int    keynote_returnvalue = 0;
@


1.1.1.1
log
@KeyNote version 2 trust-management system (security policy handling).
Utilities to follow.

@
text
@@
