head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.2
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.17.0.8
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.10
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.38
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.36
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.34
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.32
	OPENBSD_5_0:1.15.0.30
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.28
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.26
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.22
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.24
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.20
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.18
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.16
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.14
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.12
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.10
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	KeyNote-v2:1.1.1.1
	Angelos:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2017.04.27.15.35.36;	author millert;	state Exp;
branches;
next	1.17;
commitid	6Uzar68WoGNZN1G8;

1.17
date	2015.11.19.02.35.24;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	bCQllQH6f0Sp4lOD;

1.16
date	2013.11.29.19.00.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.29.11.35.56;	author msf;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.25.05.06.49;	author msf;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.02.23.01.10;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.27.06.29.14;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.03.20.14.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.18.22.41.01;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.06.23.51.29;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.09.23.41.46;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.13.19.03.11;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	99.10.26.22.31.38;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.10.09.19.47.33;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.10.09.06.59.37;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.10.01.01.08.30;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.05.31.20.09.59;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.05.23.22.11.05;	author angelos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.23.22.11.05;	author angelos;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Remove useless check for ks_env_table being NULL.  Since ks_env_table
is an array embedded in struct keynote_session it can never be NULL.
Quiets a clang warning.
@
text
@/* $OpenBSD: keynote.y,v 1.17 2015/11/19 02:35:24 mmcc Exp $ */
/*
 * The author of this code is Angelos D. Keromytis (angelos@@dsl.cis.upenn.edu)
 *
 * This code was written by Angelos D. Keromytis in Philadelphia, PA, USA,
 * in April-May 1998
 *
 * Copyright (C) 1998, 1999 by Angelos D. Keromytis.
 *	
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, THE AUTHORS MAKES NO
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */
%union {
    char   *string;
    double  doubval;
    int     intval;
    int     bool;
};
%type <bool> stringexp numexp expr floatexp
%type <intval> NUM KOF numex afterhint notemptyprog
%type <intval> notemptykeypredicate prog key keyexp keylist
%type <doubval> FLOAT floatex
%type <string> STRING VARIABLE str strnotconcat 
%token TRUE FALSE NUM FLOAT STRING VARIABLE 
%token OPENPAREN CLOSEPAREN EQQ COMMA ACTSTR LOCINI KOF KEYPRE KNVERSION
%token DOTT SIGNERKEY HINT OPENBLOCK CLOSEBLOCK SIGNATUREENTRY PRIVATEKEY
%token SEMICOLON TRUE FALSE
%nonassoc EQ NE LT GT LE GE REGEXP
%left OR
%left AND
%right NOT
%left PLUS MINUS DOTT
%left MULT DIV MOD
%left EXP
%nonassoc UNARYMINUS DEREF OPENNUM OPENFLT
%start grammarswitch
%{
#include <sys/types.h>

#include <ctype.h>
#include <math.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "keynote.h"
#include "assertion.h"

static int *keynote_kth_array = NULL;
static int keylistcount = 0;

static int   resolve_assertion(char *);
static int   keynote_init_kth(void);
static int   isfloatstring(char *);
static int   checkexception(int);
static char *my_lookup(char *);
static int   intpow(int, int);
static int   get_kth(int);
%}
%%

grammarswitch: LOCINI { keynote_exceptionflag = keynote_donteval = 0; }
                localinit
             | ACTSTR { keynote_exceptionflag = keynote_donteval = 0; } program
   	     | KEYPRE { keynote_exceptionflag = keynote_donteval = 0; }
                keypredicate
             | SIGNERKEY { keynote_exceptionflag = keynote_donteval = 0; } key
             | SIGNATUREENTRY { keynote_exceptionflag = keynote_donteval = 0; }
                key
             | KNVERSION { keynote_exceptionflag = keynote_donteval = 0; }
                        STRING { keynote_lex_remove($3);
				 if (strcmp($3, KEYNOTE_VERSION_STRING))
				   keynote_errno = ERROR_SYNTAX;
				 free($3);
			       }
             | PRIVATEKEY { keynote_exceptionflag = keynote_donteval = 0; }
                        STRING { keynote_lex_remove($3);
			         keynote_privkey = $3;
			       }
    
keypredicate: /* Nothing */   { keynote_returnvalue = 0;
                                return 0; 
                              }
       | notemptykeypredicate { keynote_returnvalue = $1;
				return 0;
                              }

notemptykeypredicate:  key     { $$ = $1; }
       		     | keyexp  { $$ = $1; }

keyexp: notemptykeypredicate AND { if (($1 == 0) && !keynote_justrecord)
                                     keynote_donteval = 1;
                                 } notemptykeypredicate 
                 { if ($1 > $4)
		     $$ = $4;
		   else
	       	     $$ = $1;
		   keynote_donteval = 0;
                 }  /* Min */
      | notemptykeypredicate OR { if (($1 == (keynote_current_session->ks_values_num - 1)) && !keynote_justrecord)
	                             keynote_donteval = 1;
       	                         } notemptykeypredicate
                 { if ($1 >= $4)
		     $$ = $1;
		   else
		     $$ = $4;
		   keynote_donteval = 0;
                 }  /* Max */
       | OPENPAREN keyexp CLOSEPAREN { $$ = $2; }
       | KOF { keylistcount = 0; } OPENPAREN {
			 if (!keynote_justrecord && !keynote_donteval)
 	                   if (keynote_init_kth() == -1)
			     return -1;
                       } keylist CLOSEPAREN 
                          {
			      if (keylistcount < $1)
			      {
				  keynote_errno = ERROR_SYNTAX;
				  return -1;
			      }

			    if (!keynote_justrecord && !keynote_donteval)
			      $$ = get_kth($1);
			    else
			      $$ = 0;
			  }  /* K-th */

keylist: key
	    { /* Don't do anything if we're just recording */ 
              if (!keynote_justrecord && !keynote_donteval)
		if (($1 < keynote_current_session->ks_values_num) && ($1 >= 0))
		  keynote_kth_array[$1]++;

	      keylistcount++;
            }
        | key COMMA keylist
            { /* Don't do anything if we're just recording */ 
	      if (!keynote_justrecord && !keynote_donteval)
		if (($1 < keynote_current_session->ks_values_num) && ($1 >= 0))
		  keynote_kth_array[$1]++;

	      keylistcount++;
            }

key: str        {
		   if (keynote_donteval)
		     $$ = 0;
		   else
		   {
		       keynote_lex_remove($1);
		       if (keynote_justrecord)
		       {
			   if (keynote_keylist_add(&keynote_keypred_keylist,
						   $1) == -1)
			   {
			       free($1);
			       return -1;
			   }

			   $$ = 0;
		       }
		       else
			 switch (keynote_in_action_authorizers($1, KEYNOTE_ALGORITHM_UNSPEC))
			 {
			     case -1:
				 free($1);
				 return -1;
				 
			     case RESULT_TRUE:
				 free($1);
				 $$ = keynote_current_session->ks_values_num -
				      1;
				 break;
				 
			     default:
				 $$ = resolve_assertion($1);
				 free($1);
				 break;
			 }
		   }
                 }

localinit: /* Nothing */
         | localconstants

localconstants: VARIABLE EQQ STRING 
	  {
            int i;

            keynote_lex_remove($1);
	    keynote_lex_remove($3);
 
	    /*
	     * Variable names starting with underscores are illegal here.
	     */
	    if ($1[0] == '_')
	    {
		free($1);
		free($3);
		keynote_errno = ERROR_SYNTAX;
		return -1;
	    }
	    
	    /* If the identifier already exists, report error. */
	    if (keynote_env_lookup($1, &keynote_init_list, 1) != NULL)
	    {
		free($1);
		free($3);
		keynote_errno = ERROR_SYNTAX;
		return -1;
	    }

	    i = keynote_env_add($1, $3, &keynote_init_list, 1, 0);
	    free($1);
	    free($3);

	    if (i != RESULT_TRUE)
	      return -1;
	  }
         | VARIABLE EQQ STRING
	  {
            int i;

	    keynote_lex_remove($1);
	    keynote_lex_remove($3);

	    /*
	     * Variable names starting with underscores are illegal here.
	     */
	    if ($1[0] == '_')
	    {
		free($1);
		free($3);
		keynote_errno = ERROR_SYNTAX;
		return -1;
	    }
	 
	    /* If the identifier already exists, report error. */
	    if (keynote_env_lookup($1, &keynote_init_list, 1) != NULL)
	    {
		free($1);
		free($3);
		keynote_errno = ERROR_SYNTAX;
		return -1;
	    }

	    i = keynote_env_add($1, $3, &keynote_init_list, 1, 0);
	    free($1);
	    free($3);

	    if (i != RESULT_TRUE)
	      return -1;
	  } localconstants

program: prog { 
	        keynote_returnvalue = $1;
		return 0;
	      }

prog:   /* Nada */ { $$ = 0; }
       | notemptyprog {
			  /* 
			   * Cleanup envlist of additions such as 
			   * regexp results
			   */
			  keynote_env_cleanup(&keynote_temp_list, 1);
                    } SEMICOLON prog
                    {
		      if ($1 > $4)
			$$ = $1;
		      else
			$$ = $4;
                    } 

notemptyprog: expr HINT afterhint
              {
		if (checkexception($1))
		  $$ = $3;
		else
		  $$ = 0;
	      }
       |  expr 
              {
		if (checkexception($1))
		  $$ = keynote_current_session->ks_values_num - 1;
		else
		  $$ = 0;
	      }

afterhint: str {  if (keynote_exceptionflag || keynote_donteval)
		    $$ = 0;
		  else
		  {
		      keynote_lex_remove($1);

		      $$ = keynote_retindex($1);
		      if ($$ == -1)   /* Invalid return value */
			$$ = 0;

		      free($1);
		  }
                }
         | OPENBLOCK prog CLOSEBLOCK { $$ = $2; }


expr:     OPENPAREN expr CLOSEPAREN 	{ $$ = $2; }
	| expr AND { if ($1 == 0)
	               keynote_donteval = 1;
	           } expr               { $$ = ($1 && $4);
		                          keynote_donteval = 0;
		                        }
	| expr OR { if ($1)
	              keynote_donteval = 1; 
	          } expr 		{ $$ = ($1 || $4);
		                          keynote_donteval = 0;
                                        }
	| NOT expr 			{ $$ = !($2); }
	| numexp 			{ $$ = $1; }
	| floatexp			{ $$ = $1; }
	| stringexp 			{ $$ = $1; }
        | TRUE	  		        { $$ = 1; }
        | FALSE	  		        { $$ = 0; }

numexp:	  numex LT numex { $$ = $1 < $3; }
	| numex GT numex { $$ = $1 > $3; }
	| numex EQ numex { $$ = $1 == $3; }
	| numex LE numex { $$ = $1 <= $3; }
	| numex GE numex { $$ = $1 >= $3; }
	| numex NE numex { $$ = $1 != $3; }

floatexp: floatex LT floatex { $$ = $1 < $3; }
	| floatex GT floatex { $$ = $1 > $3; }
	| floatex LE floatex { $$ = $1 <= $3; }
	| floatex GE floatex { $$ = $1 >= $3; }

numex:	  numex PLUS numex  { $$ = $1 + $3; }
	| numex MINUS numex { $$ = $1 - $3; }
	| numex MULT numex  { $$ = $1 * $3; }
        | numex DIV numex   { if ($3 == 0)
	                      {
				  if (!keynote_donteval)
				    keynote_exceptionflag = 1;
			      }
	                      else
			        $$ = ($1 / $3);
			    }
	| numex MOD numex   { if ($3 == 0)
	                      {
				  if (!keynote_donteval)
				    keynote_exceptionflag = 1;
			      }
	                      else
			        $$ = $1 % $3;
			    }
	| numex EXP numex   		{ $$ = intpow($1, $3); }
	| MINUS numex %prec UNARYMINUS 	{ $$ = -($2); }
	| OPENPAREN numex CLOSEPAREN   	{ $$ = $2; }
	| NUM 			       	{ $$ = $1; }
        | OPENNUM strnotconcat         	{ if (keynote_exceptionflag ||
					      keynote_donteval)
	                                    $$ = 0;
 	                                  else
					  {
					      keynote_lex_remove($2);

					      if (!isfloatstring($2))
						$$ = 0;
					      else
						$$ = (int) floor(atof($2));
					      free($2);
					  }
					}

floatex:  floatex PLUS floatex  	{ $$ = ($1 + $3); }
	| floatex MINUS floatex 	{ $$ = ($1 - $3); }
	| floatex MULT floatex          { $$ = ($1 * $3); }
        | floatex DIV floatex   	{ if ($3 == 0)
	                                  {
					      if (!keynote_donteval)
						keynote_exceptionflag = 1;
					  }
	                                  else
			        	   $$ = ($1 / $3);
					}
	| floatex EXP floatex  			{ if (!keynote_exceptionflag &&
						      !keynote_donteval)
	                                            $$ = pow($1, $3);
	                                        }
	| MINUS floatex %prec UNARYMINUS 	{ $$ = -($2); }
	| OPENPAREN floatex CLOSEPAREN	 	{ $$ = $2; }
	| FLOAT			       		{ $$ = $1; }
        | OPENFLT strnotconcat          {
	                                  if (keynote_exceptionflag ||
					      keynote_donteval)
					    $$ = 0.0;
					  else
					  {
					      keynote_lex_remove($2);
					  
					      if (!isfloatstring($2))
						$$ = 0.0;
					      else
						$$ = atof($2);
					      free($2);
					  }
	                                }

stringexp: str EQ str {
                        if (keynote_exceptionflag || keynote_donteval)
			  $$ = 0;
			else
			{
			    $$ = strcmp($1, $3) == 0 ? 1 : 0;
			    keynote_lex_remove($1);
			    keynote_lex_remove($3);
			    free($1);
			    free($3);
			}
		      }
	 | str NE str {
	                if (keynote_exceptionflag || keynote_donteval)
			  $$ = 0;
			else
			{
			    $$ = strcmp($1, $3) != 0 ? 1 : 0;
			    keynote_lex_remove($1);
			    keynote_lex_remove($3);
			    free($1);
			    free($3);
			}
		      }
	 | str LT str {
	                if (keynote_exceptionflag || keynote_donteval)
			  $$ = 0;
			else
			{
			    $$ = strcmp($1, $3) < 0 ? 1 : 0;
			    keynote_lex_remove($1);
			    keynote_lex_remove($3);
			    free($1);
			    free($3);
			}
		      }
	 | str GT str {
	                if (keynote_exceptionflag || keynote_donteval)
			  $$ = 0;
			else
			{
			    $$ = strcmp($1, $3) > 0 ? 1 : 0;
			    keynote_lex_remove($1);
			    keynote_lex_remove($3);
			    free($1);
			    free($3);
			}
		      }
	 | str LE str {
	                if (keynote_exceptionflag || keynote_donteval)
			  $$ = 0;
			else
			{
			    $$ = strcmp($1, $3) <= 0 ? 1 : 0;
			    keynote_lex_remove($1);
			    keynote_lex_remove($3);
			    free($1);
			    free($3);
			}
		      }
	 | str GE str {
	                if (keynote_exceptionflag || keynote_donteval)
			  $$ = 0;
			else
			{
			    $$ = strcmp($1, $3) >= 0 ? 1 : 0;
			    keynote_lex_remove($1);
			    keynote_lex_remove($3);
			    free($1);
			    free($3);
			}
		      }
	 | str REGEXP str 
            {
	      regmatch_t pmatch[32];
	      char grp[10], *gr;
	      regex_t preg;
	      int i;

	      if (keynote_exceptionflag || keynote_donteval)
		$$ = 0;
	      else
	      {
		  keynote_lex_remove($1);
		  keynote_lex_remove($3);

		  memset(pmatch, 0, sizeof(pmatch));
		  memset(grp, 0, sizeof(grp));

		  if (regcomp(&preg, $3, REG_EXTENDED))
		  {
		      free($1);
		      free($3);
		      keynote_exceptionflag = 1;
		  }
		  else
		  {
		      /* Clean-up residuals from previous regexps */
		      keynote_env_cleanup(&keynote_temp_list, 1);

		      free($3);
		      i = regexec(&preg, $1, 32, pmatch, 0);
		      $$ = (i == 0 ? 1 : 0);
		      if (i == 0)
		      {
			  snprintf(grp, sizeof grp, "%lu",
			        (unsigned long)preg.re_nsub);
			  if (keynote_env_add("_0", grp, &keynote_temp_list,
					      1, 0) != RESULT_TRUE)
			  {
			      free($1);
			      regfree(&preg);
			      return -1;
			  }

			  for (i = 1; i < 32 && pmatch[i].rm_so != -1; i++)
			  {
			      gr = calloc(pmatch[i].rm_eo - pmatch[i].rm_so +
					  1, sizeof(char));
			      if (gr == NULL)
			      {
				  free($1);
				  regfree(&preg);
				  keynote_errno = ERROR_MEMORY;
				  return -1;
			      }

			      strncpy(gr, $1 + pmatch[i].rm_so,
				      pmatch[i].rm_eo - pmatch[i].rm_so);
			      gr[pmatch[i].rm_eo - pmatch[i].rm_so] = '\0';
			      snprintf(grp, sizeof grp, "_%d", i);
			      if (keynote_env_add(grp, gr, &keynote_temp_list,
						  1, 0) == -1)
			      {
				  free($1);
				  regfree(&preg);
				  free(gr);
				  return -1;
			      }
			      else
				free(gr);
			  }
		      }

		      regfree(&preg);
		      free($1);
		  }
	      }
	    }

str: str DOTT str    {  if (keynote_exceptionflag || keynote_donteval)
			  $$ = NULL;
			else
			{
			    int len = strlen($1) + strlen($3) + 1;
			    $$ = calloc(len, sizeof(char));
			    keynote_lex_remove($1);
			    keynote_lex_remove($3);
			    if ($$ == NULL)
			    {
				free($1);
				free($3);
				keynote_errno = ERROR_MEMORY;
				return -1;
			    }
			    snprintf($$, len, "%s%s", $1, $3);
			    free($1);
			    free($3);
			    if (keynote_lex_add($$, LEXTYPE_CHAR) == -1)
			      return -1;
			}
		      }
	| strnotconcat { $$ = $1; }

strnotconcat: STRING 	                { $$ = $1; }
        | OPENPAREN str CLOSEPAREN 	{ $$ = $2; }
        | VARIABLE      {  if (keynote_exceptionflag || keynote_donteval)
	                     $$ = NULL;
 	                   else
			   {
			       $$ = my_lookup($1);
			       keynote_lex_remove($1);
			       free($1);
			       if ($$ == NULL)
			       {
				   if (keynote_errno)
				     return -1;
				   $$ = strdup("");
			       }
			       else
				 $$ = strdup($$);

			       if ($$ == NULL)
			       {
				   keynote_errno = ERROR_MEMORY;
				   return -1;
			       }

			       if (keynote_lex_add($$, LEXTYPE_CHAR) == -1)
				 return -1;
			   }
	                 }
	| DEREF str      {  if (keynote_exceptionflag || keynote_donteval)
			      $$ = NULL;
			    else
			    {
				$$ = my_lookup($2);
				keynote_lex_remove($2);
				free($2);
				if ($$ == NULL)
				{
				    if (keynote_errno)
				      return -1;
				    $$ = strdup("");
				}
				else
				  $$ = strdup($$);

				if ($$ == NULL)
				{
				    keynote_errno = ERROR_MEMORY;
				    return -1;
				}

				if (keynote_lex_add($$, LEXTYPE_CHAR) == -1)
				  return -1;
			    }
			 }
%%

/*
 * Find all assertions signed by s and give us the one with the highest
 * return value.
 */
static int
resolve_assertion(char *s)
{
    int i, alg = KEYNOTE_ALGORITHM_NONE, p = 0;
    void *key = (void *) s;
    struct assertion *as;
    struct keylist *kl;

    kl = keynote_keylist_find(keynote_current_assertion->as_keylist, s);
    if (kl != NULL)
    {
	alg = kl->key_alg;
	key = kl->key_key;
    }

    for (i = 0;; i++)
    {
	as = keynote_find_assertion(key, i, alg);
	if (as == NULL)  /* Gone through all of them */
	  return p;

	if (as->as_kresult == KRESULT_DONE)
	  if (p < as->as_result)
	    p = as->as_result;

	/* Short circuit if we find an assertion with maximum return value */
	if (p == (keynote_current_session->ks_values_num - 1))
	  return p;
    }

    return 0;
}

/* 
 * Environment variable lookup. 
 */
static char *
my_lookup(char *s)
{
    struct keynote_session *ks = keynote_current_session;
    char *ret;

    if (!strcmp(s, "_MIN_TRUST"))
    {
	keynote_used_variable = 1;
	return ks->ks_values[0];
    }
    else
    {
	if (!strcmp(s, "_MAX_TRUST"))
	{
	    keynote_used_variable = 1;
	    return ks->ks_values[ks->ks_values_num - 1];
	}
	else
	{
	    if (!strcmp(s, "_VALUES"))
	    {
		keynote_used_variable = 1;
		return keynote_env_lookup("_VALUES", ks->ks_env_table,
					  HASHTABLESIZE);
	    }
	    else
	    {
		if (!strcmp(s, "_ACTION_AUTHORIZERS"))
		{
		    keynote_used_variable = 1;
		    return keynote_env_lookup("_ACTION_AUTHORIZERS",
					      ks->ks_env_table, HASHTABLESIZE);
		}
	    }
	}
    }

    /* Temporary list (regexp results) */
    if (keynote_temp_list != NULL)
    {
	ret = keynote_env_lookup(s, &keynote_temp_list, 1);
	if (ret != NULL)
	  return ret;
	else
	  if (keynote_errno != 0)
	    return NULL;
    }

    /* Local-Constants */
    if (keynote_init_list != NULL)
    {
	ret = keynote_env_lookup(s, &keynote_init_list, 1);
	if (ret != NULL)
	  return ret;
	else
	  if (keynote_errno != 0)
	    return NULL;
    }

    if (ks != NULL)
    {
	/* Action environment */
	ret = keynote_env_lookup(s, ks->ks_env_table, HASHTABLESIZE);
	if (ret != NULL)
	{
	    keynote_used_variable = 1;
	    return ret;
	}
	else
	  if (keynote_errno != 0)
	    return NULL;
    }

    /* Regex table */
    if ((ks != NULL) && (ks->ks_env_regex != NULL))
    {
	ret = keynote_env_lookup(s, &(ks->ks_env_regex), 1);
	if (ret != NULL)
	{
	    keynote_used_variable = 1;
	    return ret;
	}

	return NULL;
    }

    return NULL;
}

/*
 * If we had an exception, the boolean expression should return false.
 * Otherwise, return the result of the expression (the argument).
 */
static int
checkexception(int i)
{
    if (keynote_exceptionflag)
    {
	keynote_exceptionflag = 0;
	return 0;
    }
    else
      return i;
}


/* 
 * Integer exponentation -- copied from Schneier's AC2, page 244. 
 */
static int
intpow(int x, int y)
{
    int s = 1;
    
    /* 
     * x^y with y < 0 is equivalent to 1/(x^y), which for
     * integer arithmetic is 0.
     */
    if (y < 0)
      return 0;

    while (y)
    {
	if (y & 1)
	  s *= x;
	
	y >>= 1;
	x *= x;
    }

    return s;
}

/* 
 * Check whether the string is a floating point number. 
 */
static int
isfloatstring(char *s)
{
    int i, point = 0;
    
    for (i = strlen(s) - 1; i >= 0; i--)
      if (!isdigit((unsigned char)s[i]))
      {
	  if (s[i] == '.')
	  {
	      if (point == 1)
	        return 0;
	      else
	        point = 1;
	  }
	  else
	    return 0;
      }

    return 1;
}

/*
 * Initialize array for threshold search.
 */
static int
keynote_init_kth(void)
{
    int i = keynote_current_session->ks_values_num;
    
    if (i == -1)
      return -1;
    
    keynote_kth_array = calloc(i, sizeof(int));
    if (keynote_kth_array == NULL)
    {
	keynote_errno = ERROR_MEMORY;
	return -1;
    }

    return RESULT_TRUE;
}

/*
 * Get the k-th best return value.
 */
static int
get_kth(int k)
{
    int i;

    for (i = keynote_current_session->ks_values_num - 1; i >= 0; i--)
    {
	k -= keynote_kth_array[i];
	
	if (k <= 0)
	  return i;
    }

    return 0;
}

/*
 * Cleanup array.
 */
void
keynote_cleanup_kth(void)
{
    if (keynote_kth_array != NULL)
    {
	free(keynote_kth_array);
	keynote_kth_array = NULL;
    }
}

void
knerror(char *s)
{}
@


1.17
log
@Remove a ton of ugly, needless casts for NULL, calloc(), and strdup().
No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.16 2013/11/29 19:00:51 deraadt Exp $ */
d747 1
a747 1
    if ((ks != NULL) && (ks->ks_env_table != NULL))
@


1.16
log
@fairly simple unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.15 2004/06/29 11:35:56 msf Exp $ */
d58 1
a58 1
static int *keynote_kth_array = (int *) NULL;
d214 1
a214 1
	    if (keynote_env_lookup($1, &keynote_init_list, 1) != (char *) NULL)
d248 1
a248 1
	    if (keynote_env_lookup($1, &keynote_init_list, 1) != (char *) NULL)
d536 1
a536 1
			      if (gr == (char *) NULL)
d568 1
a568 1
			  $$ = (char *) NULL;
d575 1
a575 1
			    if ($$ == (char *) NULL)
d594 1
a594 1
	                     $$ = (char *) NULL;
d600 1
a600 1
			       if ($$ == (char *) NULL)
d609 1
a609 1
			       if ($$ == (char *) NULL)
d620 1
a620 1
			      $$ = (char *) NULL;
d626 1
a626 1
				if ($$ == (char *) NULL)
d635 1
a635 1
				if ($$ == (char *) NULL)
d660 1
a660 1
    if (kl != (struct keylist *) NULL)
d669 1
a669 1
	if (as == (struct assertion *) NULL)  /* Gone through all of them */
d729 1
a729 1
	if (ret != (char *) NULL)
d733 1
a733 1
	    return (char *) NULL;
d740 1
a740 1
	if (ret != (char *) NULL)
d744 1
a744 1
	    return (char *) NULL;
d751 1
a751 1
	if (ret != (char *) NULL)
d758 1
a758 1
	    return (char *) NULL;
d765 1
a765 1
	if (ret != (char *) NULL)
d771 1
a771 1
	return (char *) NULL;
d774 1
a774 1
    return (char *) NULL;
d857 2
a858 2
    keynote_kth_array = (int *) calloc(i, sizeof(int));
    if (keynote_kth_array == (int *) NULL)
d892 1
a892 1
    if (keynote_kth_array != (int *) NULL)
d895 1
a895 1
	keynote_kth_array = (int *) NULL;
@


1.15
log
@Header cleanup.
ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.14 2004/06/25 05:06:49 msf Exp $ */
d830 1
a830 1
      if (!isdigit((int) s[i]))
@


1.14
log
@Make crufty configure stuff go away. Remove all unused code paths.
No change in binaries.

ok millert@@ deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.13 2003/04/02 23:01:10 millert Exp $ */
d50 1
a54 1
#include "header.h"
@


1.13
log
@Use snprintf instead of sprintf; deraadt@@ OK
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.12 2002/05/27 06:29:14 deraadt Exp $ */
d46 1
a46 3
#if HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */
a47 3
#include <sys/types.h>
#include <stdlib.h>
#include <stdio.h>
d50 2
a51 2

#if STDC_HEADERS
a52 1
#endif /* STDC_HEADERS */
a505 1
#if HAVE_REGCOMP
a507 3
#else /* HAVE_REGCOMP */
#error "This system does not have regcomp()."
#endif /* HAVE_REGCOMP */
a521 3
#if !defined(HAVE_SNPRINTF)
			  sprintf(grp, "%lu", (unsigned long)preg.re_nsub);
#else /* !HAVE_SNPRINTF */
a523 1
#endif /* !HAVE_SNPRINTF */	
a546 3
#if !defined(HAVE_SNPRINTF)
			      sprintf(grp, "_%d", i);
#else /* !HAVE_SNPRINTF */
a547 1
#endif /* !HAVE_SNPRINTF */
a581 4
 
#if !defined(HAVE_SNPRINTF)
			    sprintf($$, "%s%s", $1, $3);
#else /* !HAVE_SNPRINTF */
a582 1
#endif /* !HAVE_SNPRINTF */
@


1.12
log
@snprintf and strlcpy cleanup; angelos ok
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.11 2001/09/03 20:14:51 deraadt Exp $ */
d601 3
d605 1
@


1.11
log
@with or without fee; received mail permitting this change from angelos
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.10 2001/07/18 22:41:01 deraadt Exp $ */
d498 1
a498 1
	      char grp[4], *gr;
d535 2
a536 1
			  snprintf(grp, 3, "%lu", (unsigned long)preg.re_nsub);
d564 1
a564 1
			      snprintf(grp, 3, "_%d", i);
d589 2
a590 2
			    $$ = calloc(strlen($1) + strlen($3) + 1,
					sizeof(char));
d601 1
a601 2
			    strcpy($$, $1);
			    strcpy($$ + strlen($1), $3);
@


1.10
log
@no, size_t can be unsigned long or int
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.9 2001/07/06 23:51:29 millert Exp $ */
d10 1
a10 1
 * Permission to use, copy, and modify this software without fee
@


1.9
log
@Fix warning on, use "%lu" to print a size_t since it is a u_long
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.8 2000/10/09 23:41:46 angelos Exp $ */
d533 1
a533 1
			  sprintf(grp, "%lu", preg.re_nsub);
d535 2
a536 2
			  snprintf(grp, 3, "%lu", preg.re_nsub);
#endif /* !HAVE_SNPRINTF */
@


1.8
log
@Sync.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d533 1
a533 1
			  sprintf(grp, "%d", preg.re_nsub);
d535 1
a535 1
			  snprintf(grp, 3, "%d", preg.re_nsub);
@


1.7
log
@Cast to avoid warning.
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.6 1999/10/26 22:31:38 angelos Exp $ */
d745 9
a753 6
    ret = keynote_env_lookup(s, &keynote_temp_list, 1);
    if (ret != (char *) NULL)
      return ret;
    else
      if (keynote_errno != 0)
	return (char *) NULL;
d756 23
a778 6
    ret = keynote_env_lookup(s, &keynote_init_list, 1);
    if (ret != (char *) NULL)
      return ret;
    else
      if (keynote_errno != 0)
	return (char *) NULL;
d780 9
a788 1
    keynote_used_variable = 1;
a789 6
    /* Action environment */
    ret = keynote_env_lookup(s, ks->ks_env_table, HASHTABLESIZE);
    if (ret != (char *) NULL)
      return ret;
    else
      if (keynote_errno != 0)
d791 1
d793 1
a793 2
    /* Regex table */
    return keynote_env_lookup(s, &(ks->ks_env_regex), 1);
@


1.6
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.4 1999/10/09 06:59:37 angelos Exp $ */
d827 1
a827 1
      if (!isdigit(s[i]))
@


1.5
log
@Roll back yesterday's commit, will wait until after 2.6.
@
text
@d1 1
a1 1
/* $OpenBSD: keynote.y,v 1.3 1999/10/01 01:08:30 angelos Exp $ */
d60 1
@


1.4
log
@Move all ifdefs in header.h (instead of keynote.h), include header.h
in all files including keynote.h, update manpage.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a59 1
#include "header.h"
@


1.3
log
@Update for version 2.0
@
text
@d60 1
@


1.2
log
@Sanitize prototypes and variable extern definitions, remove
unnecessary header file, add prototypes header file for utility building.
@
text
@d46 4
d51 1
d53 1
d55 2
d58 1
a58 3
#include <stdlib.h>
#include <ctype.h>
#include <regex.h>
d511 1
d514 3
d531 1
a531 1
#ifdef NO_SNPRINTF
d533 1
a533 1
#else /* NO_SNPRINTF */
d535 1
a535 1
#endif /* NO_SNPRINTF */
d559 1
a559 1
#ifdef NO_SNPRINTF
d561 1
a561 1
#else /* NO_SNPRINTF */
d563 1
a563 1
#endif /* NO_SNPRINTF */
@


1.1
log
@Initial revision
@
text
@a1 1

d53 3
a55 2
#include "environment.h"
#include "signature.h"
a66 12

extern int keynote_in_action_authorizers(void *, int);
extern int knlex();

extern int keynote_exceptionflag, keynote_donteval;
extern char **keynote_values, *keynote_privkey;
extern struct keylist *keynote_keypred_keylist;
extern struct environment *keynote_temp_list;
extern struct environment *keynote_init_list;
extern int knlineno, keynote_used_variable;
 
void knerror(char *);
@


1.1.1.1
log
@KeyNote version 2 trust-management system (security policy handling).
Utilities to follow.

@
text
@@
