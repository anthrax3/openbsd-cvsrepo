head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.14.0.10
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.38
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.36
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.34
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.32
	OPENBSD_5_0:1.13.0.30
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.28
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.26
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.22
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.24
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.20
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.18
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.16
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.11.0.12
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.10
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.8
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.6
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	KeyNote-v2:1.1.1.1
	Angelos:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.12.14.03.25.59;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	6idgy7jHjp60ENt8;

1.15
date	2015.11.19.02.35.24;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	bCQllQH6f0Sp4lOD;

1.14
date	2013.11.29.19.00.51;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.29.11.35.56;	author msf;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.25.05.06.49;	author msf;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.03.20.14.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.07.05.01.08;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.13.19.16.16;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.12.14.28.00;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	99.11.03.19.52.22;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	99.10.26.22.31.38;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.10.09.19.47.33;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.10.09.06.59.37;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.10.01.01.08.30;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.05.31.20.09.59;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.05.23.22.11.06;	author angelos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.23.22.11.06;	author angelos;	state Exp;
branches;
next	;


desc
@@


1.16
log
@s/begining/beginning/g
@
text
@/* $OpenBSD: parse_assertion.c,v 1.15 2015/11/19 02:35:24 mmcc Exp $ */
/*
 * The author of this code is Angelos D. Keromytis (angelos@@dsl.cis.upenn.edu)
 *
 * This code was written by Angelos D. Keromytis in Philadelphia, PA, USA,
 * in April-May 1998
 *
 * Copyright (C) 1998, 1999 by Angelos D. Keromytis.
 *	
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, THE AUTHORS MAKES NO
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <limits.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "keynote.h"
#include "assertion.h"
#include "signature.h"

/*
 * Recurse on graph discovery.
 */
static int
rec_evaluate_query(struct assertion *as)
{
    struct assertion *ast;
    struct keylist *kl;
    int i, s;

    as->as_kresult = KRESULT_IN_PROGRESS;

    /*
     * If we get the minimum result or an error from evaluating this
     * assertion, we don't need to recurse. 
     */
    keynote_evaluate_assertion(as);
    if (keynote_errno != 0)
    {
	as->as_kresult = KRESULT_DONE;
	if (keynote_errno)
	  as->as_error = keynote_errno;
	if (keynote_errno == ERROR_MEMORY)
	  return -1;
	else
	{
	    keynote_errno = 0;  /* Ignore syntax errors for now */
	    return 0;
	}
    }

    if (as->as_result == 0)
    {
        as->as_kresult = KRESULT_DONE;
        return as->as_result;
    }

    for (kl = as->as_keylist;
	 kl != NULL;
	 kl = kl->key_next)
    {
	switch (keynote_in_action_authorizers(kl->key_key, kl->key_alg))
	{
	    case -1:
		as->as_kresult = KRESULT_DONE;
		if (keynote_errno == ERROR_MEMORY)
		{
		    as->as_error = ERROR_MEMORY;
		    return -1;
		}
		else
		{
		    keynote_errno = 0; /* Reset */
		    continue;
		}

	    case RESULT_FALSE:    /* Not there, check for assertions instead */
		break;

	    case RESULT_TRUE:     /* Ok, don't bother with assertions */
		keynote_current_assertion = NULL;
		continue;
	}

	for (i = 0;; i++)
	{
	    ast = keynote_find_assertion(kl->key_key, i, kl->key_alg);
	    if (ast == NULL)
	      break;

	    if (ast->as_kresult == KRESULT_IN_PROGRESS) /* Cycle detected */
	      continue;

	    if (ast->as_kresult == KRESULT_UNTOUCHED)   /* Recurse if needed */
	      rec_evaluate_query(ast);

	    /* Check for errors */
	    if (keynote_errno == ERROR_MEMORY)
	    {
		as->as_error = ERROR_MEMORY;
		as->as_kresult = KRESULT_DONE;
		return -1;
	    }
	    else
	      keynote_errno = 0; /* Reset */
	}
    }

    keynote_current_assertion = as;
    s = keynote_parse_keypred(as, 0);
    keynote_current_assertion = NULL;

    if (keynote_errno == ERROR_MEMORY)
    {
	as->as_error = ERROR_MEMORY;
	as->as_kresult = KRESULT_DONE;
	return -1;
    }
    else
      if (keynote_errno)
      {
	  keynote_errno = 0;
	  s = 0;
      }

    /* Keep lower of two */
    as->as_result = (as->as_result < s ? as->as_result : s);

    /* Check the signature now if we haven't done so already */
    if (as->as_sigresult == SIGRESULT_UNTOUCHED)
    {
	if (!(as->as_flags & ASSERT_FLAG_LOCAL))
	  as->as_sigresult = keynote_sigverify_assertion(as);
	else
	  as->as_sigresult = SIGRESULT_TRUE;    /* Trusted assertion */
    }

    if (as->as_sigresult != SIGRESULT_TRUE)
    {
	as->as_result = 0;
	as->as_sigresult = SIGRESULT_FALSE;
	if (keynote_errno != ERROR_MEMORY)
	  keynote_errno = 0; /* Reset */
	else
	{
	    as->as_error = ERROR_MEMORY;
	    as->as_kresult = KRESULT_DONE;
	    return -1;
	}
    }

    as->as_kresult = KRESULT_DONE;
    return as->as_result;
}

/*
 * Fix the Authorizer/Licencees/Signature fields. If the first argument is
 * empty, fix all assertions. The second argument specifies whether the
 * Signature field should be parsed or not.
 */
static int
keynote_fix_fields(struct assertion *ast, int sigfield)
{
    struct assertion *as;
    int i;
 
    /* Signature generation/verification handling, no need to eval Licensees */
    if (ast != NULL)
    {
	/* Authorizer */
	if (keynote_evaluate_authorizer(ast, 1) != RESULT_TRUE)
	  return -1;

	/* Signature */
	if ((sigfield) && (ast->as_signature_string_s != NULL))
	  if (keynote_evaluate_authorizer(ast, 0) != RESULT_TRUE)
	    return -1;

	return RESULT_TRUE;
    }
    
    for (i = 0; i < HASHTABLESIZE; i++)
      for (as = keynote_current_session->ks_assertion_table[i];
	   as != NULL;
	   as = as->as_next)
      {
	  if (!(as->as_internalflags & ASSERT_IFLAG_NEEDPROC) &&
	      !(as->as_internalflags & ASSERT_IFLAG_WEIRDLICS) &&
	      !(as->as_internalflags & ASSERT_IFLAG_WEIRDAUTH) &&
	      !(as->as_internalflags & ASSERT_IFLAG_WEIRDSIG))
	    continue;
	  
	  /* Parse the Signature field */
	  if (((as->as_internalflags & ASSERT_IFLAG_WEIRDSIG) ||
	       (as->as_internalflags & ASSERT_IFLAG_NEEDPROC)) &&
	      (as->as_signature_string_s != NULL))
	    if (keynote_evaluate_authorizer(as, 0) == -1)
	    {
		if (keynote_errno)
		  as->as_error = keynote_errno;
		if (keynote_errno == ERROR_MEMORY)
		  return -1;
		else
		  keynote_errno = 0;
	    }
	  
	  /* Parse the Licensees field */
	  if ((as->as_internalflags & ASSERT_IFLAG_WEIRDLICS) ||
	      (as->as_internalflags & ASSERT_IFLAG_NEEDPROC))
	    if (keynote_parse_keypred(as, 1) == -1)
	    {
		if (keynote_errno)
		    as->as_error = keynote_errno;
		if (keynote_errno == ERROR_MEMORY)
		  return -1;
		else
		  keynote_errno = 0;
	    }

	  /* Parse the Authorizer field */
	  if ((as->as_internalflags & ASSERT_IFLAG_WEIRDAUTH) ||
	      (as->as_internalflags & ASSERT_IFLAG_NEEDPROC))
	    if (keynote_evaluate_authorizer(as, 1) == -1)
	    {
		if (keynote_errno)
		  as->as_error = keynote_errno;
		if (keynote_errno == ERROR_MEMORY)
		  return -1;
		else
		  keynote_errno = 0;
	    }
      }

    /* Reposition if necessary */
    for (i = 0; i < HASHTABLESIZE; i++)
      for (as = keynote_current_session->ks_assertion_table[i];
	   as != NULL;
	   as = as->as_next)
	if (((as->as_internalflags & ASSERT_IFLAG_WEIRDAUTH) &&
	     !(as->as_internalflags & ASSERT_IFLAG_PROCESSED)) ||
	    (as->as_internalflags & ASSERT_IFLAG_NEEDPROC))
	{
	    as->as_internalflags &= ~ASSERT_IFLAG_NEEDPROC;
	    as->as_internalflags |= ASSERT_IFLAG_PROCESSED;
	    keynote_sremove_assertion(keynote_current_session->ks_id,
				      as->as_id);

	    if (keynote_add_htable(as, 1) != RESULT_TRUE)
	      return -1;

	    /* Point to beginning of the previous list. */
	    i--;
	    break;
	}

    return RESULT_TRUE;
}

/*
 * Find the trust graph. This is a depth-first search, starting at
 * POLICY assertions.
 */
int
keynote_evaluate_query(void)
{
    struct assertion *as;
    int p, prev;
    int i;

    /* Fix the authorizer/licensees/signature fields */
    if (keynote_fix_fields(NULL, 0) != RESULT_TRUE)
      return -1;

    /* Find POLICY assertions and try to evaluate the query. */
    for (i = 0, prev = 0; i < HASHTABLESIZE; i++)
      for (as = keynote_current_session->ks_assertion_table[i];
	   as != NULL;
	   as = as->as_next)
	if ((as->as_authorizer != NULL) &&      /* Paranoid */
            (as->as_signeralgorithm == KEYNOTE_ALGORITHM_NONE))
	  if ((!strcmp("POLICY", as->as_authorizer)) &&
	      (as->as_flags & ASSERT_FLAG_LOCAL))
	  {
	      if ((p = rec_evaluate_query(as)) == -1)
	      {
		  if (keynote_errno)
		    as->as_error = keynote_errno;
		  if (keynote_errno == ERROR_MEMORY)
		    return -1;
		  else
		  {
		      keynote_errno = 0;
		      continue;
		  }
	      }

	      if (p > prev)
		prev = p;

	      /* If we get the highest possible return value, just return */
	      if (prev == (keynote_current_session->ks_values_num - 1))
		return prev;
	  }
    
    return prev;
}

/*
 * Return keyword type.
 */
static int
whichkeyword(char *start, char *end)
{
    int len = (end - start);

    if (len <= 0)
    {
	keynote_errno = ERROR_MEMORY;
	return -1;
    }

    if (!strncasecmp("keynote-version:", start, len))
      return KEYWORD_VERSION;

    if (!strncasecmp("local-constants:", start, len))
      return KEYWORD_LOCALINIT;

    if (!strncasecmp("authorizer:", start, len))
      return KEYWORD_AUTHORIZER;

    if (!strncasecmp("licensees:", start, len))
      return KEYWORD_LICENSEES;

    if (!strncasecmp("conditions:", start, len))
      return KEYWORD_CONDITIONS;

    if (!strncasecmp("signature:", start, len))
      return KEYWORD_SIGNATURE;

    if (!strncasecmp("comment:", start, len))
      return KEYWORD_COMMENT;

    keynote_errno = ERROR_SYNTAX;
    return -1;
}

/* 
 * Parse an assertion. Set keynote_errno to ERROR_SYNTAX if parsing
 * failed due to certificate badness, and ERROR_MEMORY if memory
 * problem. If more than one assertions have been passed in the
 * buffer, they will be linked.
 */
struct assertion *
keynote_parse_assertion(char *buf, int len, int assertion_flags)
{
    int k, i, j, seen_field = 0, ver = 0, end_of_assertion = 0;
    char *ks, *ke, *ts, *te = NULL;
    struct assertion *as;

    /* Allocate memory for assertion */
    as = calloc(1, sizeof(struct assertion));
    if (as == NULL)
    {
	keynote_errno = ERROR_MEMORY;
	return NULL;
    }

    /* Keep a copy of the assertion around */
    as->as_buf = strdup(buf);
    if (as->as_buf == NULL)
    {
	keynote_errno = ERROR_MEMORY;
	keynote_free_assertion(as);
	return NULL;
    }

    as->as_flags = assertion_flags & ~(ASSERT_FLAG_SIGGEN |
				       ASSERT_FLAG_SIGVER);

    /* Skip any leading whitespace */
    for (i = 0, j = len; i < j && isspace((unsigned char)as->as_buf[i]); i++)
     ;

    /* Keyword must start at begining of buffer or line */
    if ((i >= j) || ((i != 0) && (as->as_buf[i - 1] != '\n')))
    {
	keynote_free_assertion(as);
	keynote_errno = ERROR_SYNTAX;
	return NULL;
    }

    while (i < j)			/* Decomposition loop */
    {
	ks = as->as_buf + i;

	/* Mark begining of assertion for signature purposes */
	if (as->as_startofsignature == NULL)
	  as->as_startofsignature = ks;

	/* This catches comments at the begining of an assertion only */
	if (as->as_buf[i] == '#')	/* Comment */
	{
	    seen_field = 1;

   	    /* Skip until the end of line */
	    while ((i< j) && as->as_buf[++i] != '\n')
	      ;

	    i++;
	    continue;  /* Loop */
	}

	/* Advance until we find a keyword separator */
	for (; (as->as_buf[i] != ':') && (i < j); i++)
	  ;

	if (i + 1 > j)
	{
	    keynote_free_assertion(as);
	    keynote_errno = ERROR_SYNTAX;
	    return NULL;
	}

	/* ks points at begining of keyword, ke points at end */
	ke = as->as_buf + i;

	/* ts points at begining of value field */
	ts = as->as_buf + i + 1;	/* Skip ':' */

	/*
	 * Find the end of the field -- means end of buffer,
	 * a newline followed by a non-whitespace character,
	 * or two newlines.
	 */
	while (++i <= j)
	{
	    /* If end of buffer, we're at the end of the field */
	    if (i == j)
	    {
		end_of_assertion = 1;
		te = as->as_buf + i;
		break;
	    }

	    /* If two newlines, end of assertion */
	    if ((as->as_buf[i] == '\n') && (i + 1 < j) && 
		(as->as_buf[i + 1] == '\n'))
	    {
		end_of_assertion = 1;
		te = as->as_buf + i;
		break;
	    }

	    /* If newline followed by non-whitespace or comment character */
	    if ((as->as_buf[i] == '\n') && 
		(!isspace((unsigned char)as->as_buf[i + 1])) &&
                (as->as_buf[i + 1] != '#'))
	    {
	        te = as->as_buf + i;
	        break;
	    }
	}

	i++;

	/* 
	 * On each of the cases (except the first), we check that:
	 *  - we've already seen a keynote-version field (and that
	 *    it's the first one that appears in the assertion)
	 *  - the signature field, if present, is the last one
	 *  - no field appears more than once
	 */
	switch (whichkeyword(ks, ke))
	{
	    case -1:
		keynote_free_assertion(as);
		return NULL;

	    case KEYWORD_VERSION:
		if ((ver == 1) || (seen_field == 1))
		{
		    keynote_free_assertion(as);
		    keynote_errno = ERROR_SYNTAX;
		    return NULL;
		}

		/* Test for version correctness */
		keynote_get_envlist(ts, te, 1);
		if (keynote_errno != 0)
		{
		    keynote_free_assertion(as);
		    return NULL;
		}

		ver = 1;
		break;

	    case KEYWORD_LOCALINIT:
		if (as->as_env != NULL)
		{
		    keynote_free_assertion(as);
		    keynote_errno = ERROR_SYNTAX;
		    return NULL;
		}

		as->as_env = keynote_get_envlist(ts, te, 0);
		if (keynote_errno != 0)
		{
		    keynote_free_assertion(as);
		    return NULL;
		}
		break;

	    case KEYWORD_AUTHORIZER:
		if (as->as_authorizer_string_s != NULL)
		{
		    keynote_free_assertion(as);
		    keynote_errno = ERROR_SYNTAX;
		    return NULL;
		}

		as->as_authorizer_string_s = ts;
		as->as_authorizer_string_e = te;
		break;

	    case KEYWORD_LICENSEES:
		if (as->as_keypred_s != NULL)
		{
		    keynote_free_assertion(as);
		    keynote_errno = ERROR_SYNTAX;
		    return NULL;
		}

		as->as_keypred_s = ts;
		as->as_keypred_e = te;
		break;

	    case KEYWORD_CONDITIONS:
		if (as->as_conditions_s != NULL)
		{
		    keynote_free_assertion(as);
		    keynote_errno = ERROR_SYNTAX;
		    return NULL;
		}

		as->as_conditions_s = ts;
		as->as_conditions_e = te;
		break;

	    case KEYWORD_SIGNATURE:
		if (as->as_signature_string_s != NULL)
		{
		    keynote_free_assertion(as);
		    keynote_errno = ERROR_SYNTAX;
		    return NULL;
		}

		end_of_assertion = 1;
		as->as_allbutsignature = ks;
		as->as_signature_string_s = ts;
		as->as_signature_string_e = te;
		break;

	    case KEYWORD_COMMENT:
		if (as->as_comment_s != NULL)
		{
		    keynote_free_assertion(as);
		    keynote_errno = ERROR_SYNTAX;
		    return NULL;
		}

		as->as_comment_s = ts;
		as->as_comment_e = te;
		break;
	}

	seen_field = 1;
	if (end_of_assertion == 1)
	{
	    /* End of buffer, good termination */
	    if ((te == as->as_buf + len) || (te + 1 == as->as_buf + len) ||
		(*(te) == '\0') || (*(te + 1) == '\0'))
	      break;

	    /* Check whether there's something else following */
	    for (k = 1; te + k < as->as_buf + len && *(te + k) != '\n'; k++)   
	      if (!isspace((unsigned char)*(te + k)))
	      {
		  keynote_free_assertion(as);
		  keynote_errno = ERROR_SYNTAX;
		  return NULL;
	      }

	    break; /* Assertion is "properly" terminated */
	}
    }

    /* Check that the basic fields are there */
    if (as->as_authorizer_string_s == NULL)
    {
	keynote_free_assertion(as);
	keynote_errno = ERROR_SYNTAX;
	return NULL;
    }

    /* Signature generation/verification handling */
    if (assertion_flags & ASSERT_FLAG_SIGGEN)
    {
        if (keynote_fix_fields(as, 0) != RESULT_TRUE)
        {
	    keynote_free_assertion(as);
	    return NULL;
        }
    }
    else
      if (assertion_flags & ASSERT_FLAG_SIGVER)
	if (keynote_fix_fields(as, 1) != RESULT_TRUE)
	{
	    keynote_free_assertion(as);
	    return NULL;
	}

    return as;
}
@


1.15
log
@Remove a ton of ugly, needless casts for NULL, calloc(), and strdup().
No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: parse_assertion.c,v 1.14 2013/11/29 19:00:51 deraadt Exp $ */
d265 1
a265 1
	    /* Point to begining of the previous list. */
@


1.14
log
@fairly simple unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/* $OpenBSD: parse_assertion.c,v 1.13 2004/06/29 11:35:56 msf Exp $ */
d73 1
a73 1
	 kl != (struct keylist *) NULL;
d95 1
a95 1
		keynote_current_assertion = (struct assertion *) NULL;
d102 1
a102 1
	    if (ast == (struct assertion *) NULL)
d125 1
a125 1
    keynote_current_assertion = (struct assertion *) NULL;
d182 1
a182 1
    if (ast != (struct assertion *) NULL)
d189 1
a189 1
	if ((sigfield) && (ast->as_signature_string_s != (char *) NULL))
d198 1
a198 1
	   as != (struct assertion *) NULL;
d210 1
a210 1
	      (as->as_signature_string_s != (char *) NULL))
d251 1
a251 1
	   as != (struct assertion *) NULL;
d285 1
a285 1
    if (keynote_fix_fields((struct assertion *) NULL, 0) != RESULT_TRUE)
d291 1
a291 1
	   as != (struct assertion *) NULL;
d293 1
a293 1
	if ((as->as_authorizer != (void *) NULL) &&      /* Paranoid */
d371 1
a371 1
    char *ks, *ke, *ts, *te = (char *) NULL;
d375 2
a376 2
    as = (struct assertion *) calloc(1, sizeof(struct assertion));
    if (as == (struct assertion *) NULL)
d379 1
a379 1
	return (struct assertion *) NULL;
d384 1
a384 1
    if (as->as_buf == (char *) NULL)
d388 1
a388 1
	return (struct assertion *) NULL;
d403 1
a403 1
	return (struct assertion *) NULL;
d411 1
a411 1
	if (as->as_startofsignature == (char *) NULL)
d435 1
a435 1
	    return (struct assertion *) NULL;
d491 1
a491 1
		return (struct assertion *) NULL;
d498 1
a498 1
		    return (struct assertion *) NULL;
d506 1
a506 1
		    return (struct assertion *) NULL;
d513 1
a513 1
		if (as->as_env != (struct environment *) NULL)
d517 1
a517 1
		    return (struct assertion *) NULL;
d524 1
a524 1
		    return (struct assertion *) NULL;
d529 1
a529 1
		if (as->as_authorizer_string_s != (void *) NULL)
d533 1
a533 1
		    return (struct assertion *) NULL;
d541 1
a541 1
		if (as->as_keypred_s != (char *) NULL)
d545 1
a545 1
		    return (struct assertion *) NULL;
d553 1
a553 1
		if (as->as_conditions_s != (char *) NULL)
d557 1
a557 1
		    return (struct assertion *) NULL;
d565 1
a565 1
		if (as->as_signature_string_s != (char *) NULL)
d569 1
a569 1
		    return (struct assertion *) NULL;
d579 1
a579 1
		if (as->as_comment_s != (char *) NULL)
d583 1
a583 1
		    return (struct assertion *) NULL;
d605 1
a605 1
		  return (struct assertion *) NULL;
d613 1
a613 1
    if (as->as_authorizer_string_s == (char *) NULL)
d617 1
a617 1
	return (struct assertion *) NULL;
d626 1
a626 1
	    return (struct assertion *) NULL;
d634 1
a634 1
	    return (struct assertion *) NULL;
@


1.13
log
@Header cleanup.
ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: parse_assertion.c,v 1.12 2004/06/25 05:06:49 msf Exp $ */
d395 1
a395 1
    for (i = 0, j = len; i < j && isspace((int) as->as_buf[i]); i++)
d470 1
a470 1
		(!isspace((int) as->as_buf[i + 1])) &&
d601 1
a601 1
	      if (!isspace((int) *(te + k)))
@


1.12
log
@Make crufty configure stuff go away. Remove all unused code paths.
No change in binaries.

ok millert@@ deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: parse_assertion.c,v 1.11 2001/09/03 20:14:51 deraadt Exp $ */
d26 1
a30 1
#include "header.h"
@


1.11
log
@with or without fee; received mail permitting this change from angelos
@
text
@d1 1
a1 1
/* $OpenBSD: parse_assertion.c,v 1.10 2001/06/07 05:01:08 angelos Exp $ */
d22 1
a22 3
#if HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */
d24 3
a26 1
#include <sys/types.h>
a27 4
#include <stdio.h>
#include <ctype.h>

#if STDC_HEADERS
a28 5
#endif /* STDC_HEADERS */

#if HAVE_LIMITS_H
#include <limits.h>
#endif /* HAVE_LIMITS_H */
@


1.10
log
@Rogue debug printf.
@
text
@d1 1
a1 1
/* $OpenBSD: parse_assertion.c,v 1.9 2000/06/13 19:16:16 angelos Exp $ */
d10 1
a10 1
 * Permission to use, copy, and modify this software without fee
@


1.9
log
@Fix some compile warnings.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a611 1
		  printf("here %c\n", *(te + k));
@


1.8
log
@Correctly handle comments at the beginning of an assertion (noted by
ho@@openbsd.org)
@
text
@d1 1
a1 1
/* $OpenBSD: parse_assertion.c,v 1.7 1999/11/03 19:52:22 angelos Exp $ */
d404 1
a404 1
    for (i = 0, j = len; i < j && isspace(as->as_buf[i]); i++)
d479 2
a480 1
		(!isspace(as->as_buf[i + 1])) && (as->as_buf[i + 1] != '#'))
d610 1
a610 1
	      if (!isspace(*(te + k)))
@


1.7
log
@Handle multiple assertions per file in signature verification, better
detection of malformed credentials, update manpages, sync with release.
@
text
@d1 1
a1 1
/* $OpenBSD: parse_assertion.c,v 1.6 1999/10/26 22:31:38 angelos Exp $ */
d423 1
d432 1
@


1.6
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD: parse_assertion.c,v 1.4 1999/10/09 06:59:37 angelos Exp $ */
d379 1
a379 1
    int i, j, seen_field = 0, ver = 0, end_of_assertion = 0;
d599 18
a616 1
	  break;
@


1.5
log
@Roll back yesterday's commit, will wait until after 2.6.
@
text
@d1 1
a1 1
/* $OpenBSD: parse_assertion.c,v 1.3 1999/10/01 01:08:30 angelos Exp $ */
d39 1
@


1.4
log
@Move all ifdefs in header.h (instead of keynote.h), include header.h
in all files including keynote.h, update manpage.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a38 1
#include "header.h"
@


1.3
log
@Update for version 2.0
@
text
@d39 1
@


1.2
log
@Sanitize prototypes and variable extern definitions, remove
unnecessary header file, add prototypes header file for utility building.
@
text
@d22 4
d30 2
d33 3
d37 1
@


1.1
log
@Initial revision
@
text
@a1 1

d28 2
a30 1
#include "environment.h"
a31 6

/* Globals */
struct assertion *keynote_current_assertion = (struct assertion *) NULL;
int keynote_errno = 0;

extern int keynote_in_action_authorizers(void *, int);
@


1.1.1.1
log
@KeyNote version 2 trust-management system (security policy handling).
Utilities to follow.

@
text
@@
