head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.10
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.8
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.24
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.20
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.18
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.16
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.14
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.12
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.10
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	KeyNote-v2:1.1.1.1
	Angelos:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.11.19.19.48.27;	author tedu;	state Exp;
branches;
next	1.22;
commitid	yZnAp5ubIOGqXkTj;

1.22
date	2015.11.19.02.35.24;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	bCQllQH6f0Sp4lOD;

1.21
date	2015.02.04.20.35.51;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	YNwPurZLi9N9RhZq;

1.20
date	2013.11.29.19.00.51;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.06.11.36.23;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.11.17.25.43;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.29.11.35.56;	author msf;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.25.05.06.49;	author msf;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.08.19.17.27;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.27.06.29.14;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.03.20.14.51;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.11.20.51.38;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.13.19.16.16;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.18.08.31.02;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.18.07.58.46;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.18.13.36.13;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.12.00.26.16;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	99.10.26.22.31.38;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.10.09.19.47.32;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.10.09.06.59.37;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.10.01.01.08.30;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.05.31.20.09.59;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.05.23.22.11.05;	author angelos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.23.22.11.05;	author angelos;	state Exp;
branches;
next	;


desc
@@


1.23
log
@lexer fixes to work with new flex. from Serguey Parkhomovsky
@
text
@%{
/* $OpenBSD: keynote.l,v 1.22 2015/11/19 02:35:24 mmcc Exp $ */
/*
 * The author of this code is Angelos D. Keromytis (angelos@@dsl.cis.upenn.edu)
 *
 * This code was written by Angelos D. Keromytis in Philadelphia, PA, USA,
 * in April-May 1998
 *
 * Copyright (C) 1998, 1999 by Angelos D. Keromytis.
 *	
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software. 
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, THE AUTHORS MAKES NO
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include <sys/time.h>
#include <sys/types.h>

#include <ctype.h>
#include <regex.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "k.tab.h"
#include "keynote.h"
#include "assertion.h"

static void mystrncpy(char *, char *, int);

struct lex_list
{
    int   lex_type;
    void *lex_s;
};

static struct lex_list *keynote_lex_list = NULL;
static int    keynote_max_lex_list = 32;
static int    keynote_lex_counter = 0;
static int    first_tok = 0;
%}
digit		[0-9]
specnumber      [1-9][0-9]*
number		{digit}+
flt		{digit}+"."{digit}+
vstring		[a-zA-Z_][a-zA-Z0-9_]*
litstring	\"(((\\\n)|(\\.)|([^\\\n\"]))*)\"
variable	{vstring}
comment		"#"[^\n]*
%s ACTIONSTRING LOCALINIT KEYPREDICATE SIGNERINIT KEYNOTEVERSION
%pointer
%option noyywrap never-interactive yylineno
%%
%{
    /*
     * Return a preset token, so we can have more than one grammars
     * in yacc.
     */
    extern int first_tok;
    
    if (first_tok)
    {
	int holdtok = first_tok;
	
	first_tok = 0;
	return holdtok;
    }
%}

<KEYPREDICATE>{specnumber}"-of"		{
					  knlval.intval = atoi(kntext);
					  return KOF;
					}
<ACTIONSTRING,KEYPREDICATE>"("		return OPENPAREN;
<ACTIONSTRING,KEYPREDICATE>")"		return CLOSEPAREN;
<ACTIONSTRING,KEYPREDICATE>"&&"		return AND;
<ACTIONSTRING,KEYPREDICATE>"||"		return OR;
<ACTIONSTRING>"+"			return PLUS;
<ACTIONSTRING>"->"              return HINT;
<ACTIONSTRING>"{"               return OPENBLOCK;
<ACTIONSTRING>"}"               return CLOSEBLOCK;
<ACTIONSTRING>";"               return SEMICOLON;
<ACTIONSTRING>"!"		return NOT;
<ACTIONSTRING>"~="		return REGEXP;
<ACTIONSTRING>"=="		return EQ;
<ACTIONSTRING>"!="		return NE;
<ACTIONSTRING>"<"		return LT;
<ACTIONSTRING>">"		return GT;
<ACTIONSTRING>"<="		return LE;
<ACTIONSTRING>">="		return GE;
<ACTIONSTRING>"-"		return MINUS;
<ACTIONSTRING>"*"		return MULT;
<ACTIONSTRING>"/"		return DIV;
<ACTIONSTRING>"%"		return MOD;
<ACTIONSTRING>"^"		return EXP;
"."		                return DOTT;
<ACTIONSTRING>"true"            return TRUE;
<ACTIONSTRING>"false"           return FALSE;
{comment}		/* eat up comments */
<LOCALINIT>"="	                return EQQ;
<KEYPREDICATE>"," 		return COMMA;
<ACTIONSTRING,KEYPREDICATE,SIGNERINIT,LOCALINIT>{variable} {
					int len;
                                        if (keynote_exceptionflag ||
					    keynote_donteval)
					{
					    knlval.string = NULL;
					    return VARIABLE;
					}

					len = strlen(kntext) + 1;
					knlval.string = calloc(len, sizeof(char));
                                        if (knlval.string == NULL)
					{
					    keynote_errno = ERROR_MEMORY;
					    return -1;
					}
		  	          	strlcpy(knlval.string, kntext, len);
					if (keynote_lex_add(knlval.string,
							    LEXTYPE_CHAR) ==
					    -1)
					  return -1;
		  	         	return VARIABLE;
			      	      }
"$"                             return DEREF;
<ACTIONSTRING>"@@"	    	return OPENNUM;
<ACTIONSTRING>"&"	    	return OPENFLT;
<ACTIONSTRING>{flt}	      {
				knlval.doubval = atof(kntext);
				return FLOAT;
			      }
<KEYNOTEVERSION>{number}      {
				int len;

                                if (keynote_exceptionflag ||
				    keynote_donteval)
				{
				    knlval.string = NULL;
				    return STRING;
				}

				len = strlen(kntext) + 1;
				knlval.string = calloc(len, sizeof(char));
                                if (knlval.string == NULL)
				{
				    keynote_errno = ERROR_MEMORY;
				    return -1;
				}
		  	        strlcpy(knlval.string, kntext, len);
				if (keynote_lex_add(knlval.string,
						    LEXTYPE_CHAR) == -1)
				  return -1;
		  	        return STRING;
			      }
<ACTIONSTRING>{number}	      {
				knlval.intval = atoi(kntext);
				return NUM;
			      }
{litstring}                   {
                                if (keynote_exceptionflag ||
				    keynote_donteval)
				{
				    knlval.string = NULL;
				    return STRING;
				}
    
				knlval.string = calloc(strlen(kntext) - 1,
						       sizeof(char));
                                if (knlval.string == NULL)
				{
				    keynote_errno = ERROR_MEMORY;
				    return -1;
				}

				mystrncpy(knlval.string, kntext + 1, 
					  strlen(kntext) - 2);

				if (keynote_lex_add(knlval.string,
						    LEXTYPE_CHAR) == -1)
				  return -1;
				return STRING;
                              }
[ \t\n]
.                             { keynote_errno = ERROR_SYNTAX; 
                                return -1;
				REJECT; /* Avoid -Wall warning. Not reached */
                              }
%%

/*
 * Zap everything.
 */
static void
keynote_lex_zap(void)
{
    int i;
    
    if (keynote_lex_counter == 0)
      return;

    for (i = 0; i < keynote_max_lex_list; i++)
      if (keynote_lex_list[i].lex_s != NULL)
      {
	  switch (keynote_lex_list[i].lex_type)
	  {
	      case LEXTYPE_CHAR:
	          free(keynote_lex_list[i].lex_s);
		  break;
	  }

	  keynote_lex_counter--;
	  keynote_lex_list[i].lex_s = NULL;
	  keynote_lex_list[i].lex_type = 0;
      }
}
	
/*
 * Initialize.
 */
static int
keynote_lex_init(void)
{
    if (keynote_lex_list != NULL)
      memset(keynote_lex_list, 0,
	     keynote_max_lex_list * sizeof(struct lex_list));
    else
    {
	keynote_lex_list = calloc(keynote_max_lex_list,
					              sizeof(struct lex_list));
        if (keynote_lex_list == NULL)
	{
	    keynote_errno = ERROR_MEMORY;
	    return -1;
	}
    }

    return RESULT_TRUE;
}

/*
 * Add the string in a list of allocated but "dangling" memory references.
 * If out of memory, free the string and return -1 (and set keynote_errno).
 */
int
keynote_lex_add(void *s, int type)
{
    struct lex_list *p;
    int i;

    if (s == NULL)
      return RESULT_TRUE;

    for (i = 0; i < keynote_max_lex_list; i++)
      if (keynote_lex_list[i].lex_s == NULL)
      {
    	  keynote_lex_list[i].lex_s = (void *) s;
	  keynote_lex_list[i].lex_type = type;
	  keynote_lex_counter++;
     	  return RESULT_TRUE;
      }

    /* Not enough space, increase the size of the array */
    keynote_max_lex_list *= 2;

    p = (struct lex_list *) reallocarray(keynote_lex_list,
					 keynote_max_lex_list,
					 sizeof(struct lex_list));
    if (p == NULL)
    {
	switch (type)
	{
	    case LEXTYPE_CHAR:
	        free(s);
		break;
	}

        keynote_max_lex_list /= 2;
	keynote_errno = ERROR_MEMORY;
        return -1;
    }

    keynote_lex_list = p;
    keynote_lex_list[i].lex_s = s;
    keynote_lex_list[i++].lex_type = type;
    keynote_lex_counter++;

    /* Zero out the rest */
    memset(&(keynote_lex_list[i]), 0,
	   (keynote_max_lex_list - i) * sizeof(struct lex_list));

    return RESULT_TRUE;
}

/*
 * Remove string.
 */
void
keynote_lex_remove(void *s)
{
    int i;

    for (i = 0; i < keynote_max_lex_list; i++)
      if (keynote_lex_list[i].lex_s == s)
      {
	  memset(&(keynote_lex_list[i]), 0, sizeof(struct lex_list));
	  keynote_lex_counter--;
	  return;
      }
}

/*
 * Return RESULT_TRUE if character is octal digit, RESULT_FALSE otherwise.
 */
static int
is_octal(char c)
{
    switch (c)
    {
	case '0': case '1': case '2': case '3':
	case '4': case '5': case '6': case '7':
	    return RESULT_TRUE;

	default:
	    return RESULT_FALSE;
    }
}

/*
 * Return octal value (non-zero) if argument starts with such a
 * representation, otherwise 0.
 */
static unsigned char
get_octal(char *s, int len, int *adv)
{
    unsigned char res = 0;

    if (*s == '0')
    {
	if (len > 0)
	{
	    if (is_octal(*(s + 1)))
	    {
		res = *(s + 1) - '0';
		*adv = 2;

		if (is_octal(*(s + 2)) && (len - 1 > 0))
		{
		    res = res * 8 + (*(s + 2) - '0');
		    *adv = 3;
		}
	    }
	}
    }
    else
      if (is_octal(*s) && (len - 1 > 0))  /* Non-zero leading */
      {
	  if (is_octal(*(s + 1)) &&
	      is_octal(*(s + 2)))
	  {
	      *adv = 3;
	      res = (((*s) - '0') * 64) +
		    (((*(s + 1)) - '0') * 8) +
		    ((*(s + 2)) - '0');
	  }
      }

    return res;
}

/*
 * Copy at most len characters to string s1 from string s2, taking
 * care of escaped characters in the process. String s1 is assumed
 * to have enough space, and be zero'ed.
 */
static void
mystrncpy(char *s1, char *s2, int len)
{
    unsigned char c;
    int advance;

    if (len == 0)
      return;

    while (len-- > 0)
    {
        if (*s2 == '\\')
	{
	    s2++;

	    if (len-- <= 0)
	      break;

	    if (*s2 == '\n')
	    {
		while (isspace((unsigned char)*(++s2)) && (len-- > 0))
		  ;
	    }
	    else
	      if ((c = get_octal(s2, len, &advance)) != 0)
	      {
		  len -= advance - 1;
		  s2 += advance;
		  *s1++ = c;
	      }
	      else
		if (*s2 == 'n')  /* Newline */
		{
		    *s1++ = '\n';
		    s2++;
		}
		else
		  if (*s2 == 't')  /* Tab */
		  {
		      *s1++ = '\t';
		      s2++;
		  }
		  else
		    if (*s2 == 'r')  /* Linefeed */
		    {
			*s1++ = '\r';
			s2++;
		    }
		    else
		      if (*s2 == 'f')  /* Formfeed */
		      {
			  *s1++ = '\f';
			  s2++;
		      }
		      else
			if ((*s1++ = *s2++) == 0)
			  break;

	    continue;
	}

        if ((*s1++ = *s2++) == 0)
	  break;
     }
}

/* 
 * Evaluate an assertion, with as->as_result holding the result.
 * Return RESULT_TRUE if all ok. Also return the result.
 */
int
keynote_evaluate_assertion(struct assertion *as)
{
    YY_BUFFER_STATE keynote_bs;

    /* Non-existent Conditions field means highest return value */
    if (as->as_conditions_s == NULL)
    {
	as->as_result = keynote_current_session->ks_values_num - 1;
	return RESULT_TRUE;
    }

    if (keynote_lex_init() != RESULT_TRUE)
      return -1;

    keynote_used_variable = 0;
    keynote_init_list = as->as_env;     /* Setup the local-init var list */

    keynote_bs = kn_scan_bytes(as->as_conditions_s,
			       as->as_conditions_e - as->as_conditions_s);
    BEGIN(ACTIONSTRING);	/* We're doing conditions-string parsing */
    first_tok = ACTSTR;
    as->as_result = 0;
    keynote_returnvalue = 0;
    
    switch (knparse())
    {
	case 1:  /* Fall through */
	    keynote_errno = ERROR_SYNTAX;
	case -1:
	    as->as_result = 0;
	    break;
	    
	case 0:
	    as->as_result = keynote_returnvalue;
	    break;
    }

    keynote_env_cleanup(&keynote_temp_list, 1);
    keynote_lex_zap();
    kn_delete_buffer(keynote_bs);

    keynote_used_variable = 0;
    keynote_returnvalue = 0;
    keynote_temp_list = NULL;
    keynote_init_list = NULL;

    if (keynote_errno != 0)
      return -1;
    else
      return RESULT_TRUE;
}

/* 
 * Parse/evaluate a key predicate field. 
 * Store keys in key predicate as keylist in as->as_keylist, if second
 * argument is true.
 */
int
keynote_parse_keypred(struct assertion *as, int record)
{
    YY_BUFFER_STATE keypred_state;
    int p = 0, err;

    if (as->as_keypred_s == NULL)
      return keynote_current_session->ks_values_num - 1;

    if (keynote_lex_init() != RESULT_TRUE)
      return -1;

    keynote_used_variable = 0;
    keynote_returnvalue = 0;
    keynote_justrecord = record; /* Just want the list of keys in predicate */
    keynote_init_list = as->as_env;

    keypred_state = kn_scan_bytes(as->as_keypred_s,
				  as->as_keypred_e - as->as_keypred_s);
    BEGIN(KEYPREDICATE);
    first_tok = KEYPRE;

    err = knparse();
    if (err != 0)
      if (keynote_errno == 0)
	keynote_errno = ERROR_SYNTAX;

    kn_delete_buffer(keypred_state);
    keynote_lex_zap(); 
    keynote_cleanup_kth();

    keynote_init_list = NULL;
    keynote_justrecord = 0;
    p = keynote_returnvalue;
    keynote_returnvalue = 0;

    if (record)
    {
	if (keynote_errno != 0)
	{
	    keynote_keylist_free(keynote_keypred_keylist);
	    keynote_keypred_keylist = NULL;
	    return -1;
	}
	else
	{
	    /* Mark for re-processing if/when environment changes */
	    if (keynote_used_variable)
	    {
		keynote_used_variable = 0;
		as->as_internalflags |= ASSERT_IFLAG_WEIRDLICS;
	    }

	    if (as->as_keylist)
              keynote_keylist_free(as->as_keylist);
	    as->as_keylist = keynote_keypred_keylist;
	    keynote_keypred_keylist = NULL;
	    return RESULT_TRUE;
	}
    }
    else
      return p;
}

/* Evaluate an authorizer or signature field. Return RESULT_TRUE on success.
 * Store key in as->as_authorizer. Second argument is set only for Authorizer
 * field parsing.
 */
int
keynote_evaluate_authorizer(struct assertion *as, int flag)
{
    YY_BUFFER_STATE authorizer_state;
    int err;

    if (keynote_lex_init() != RESULT_TRUE)
      return -1;

    keynote_init_list = as->as_env;
    keynote_justrecord = 1;
    keynote_used_variable = 0;

    if ((flag) && (as->as_authorizer != NULL))
    {
	keynote_free_key(as->as_authorizer, as->as_signeralgorithm);
	as->as_authorizer = NULL;
    }

    if (flag)
      authorizer_state = kn_scan_bytes(as->as_authorizer_string_s,
				       as->as_authorizer_string_e -
				       as->as_authorizer_string_s);
    else
      authorizer_state = kn_scan_bytes(as->as_signature_string_s,
				       as->as_signature_string_e -
				       as->as_signature_string_s);

    BEGIN(SIGNERINIT);
    if (flag)
      first_tok = SIGNERKEY;
    else
      first_tok = SIGNATUREENTRY;

    err = knparse();
    if ((err != 0) && (keynote_errno == 0))
      keynote_errno = ERROR_SYNTAX;

    kn_delete_buffer(authorizer_state);
    keynote_lex_zap();

    keynote_justrecord = 0;
    keynote_init_list = NULL;
    keynote_returnvalue = 0;

    if (keynote_keypred_keylist != NULL)
    {
	if (flag)
	{
	    if (keynote_used_variable)
	      as->as_internalflags |= ASSERT_IFLAG_WEIRDAUTH;

	    as->as_authorizer = keynote_keypred_keylist->key_key;
	    as->as_signeralgorithm = keynote_keypred_keylist->key_alg;
	}
	else
	{
	    if (keynote_used_variable)
	      as->as_internalflags |= ASSERT_IFLAG_WEIRDSIG;

	    as->as_signature = keynote_keypred_keylist->key_key;
	}
	
	keynote_keypred_keylist->key_key = NULL;
	keynote_keylist_free(keynote_keypred_keylist);
	keynote_keypred_keylist = NULL;
    }

    keynote_used_variable = 0;

    if (keynote_errno != 0)
      return -1;
    else
      return RESULT_TRUE;
}

/*
 * Exportable front-end to keynote_get_private_key().
 */
char *
kn_get_string(char *buf)
{
    return keynote_get_private_key(buf);
}

/*
 * Parse a private key -- actually, it can deal with any kind of string.
 */
char *
keynote_get_private_key(char *buf)
{
    YY_BUFFER_STATE pkey;
    char *s;
    int err;

    if (keynote_lex_init() != RESULT_TRUE)
      return NULL;

    keynote_privkey = NULL;
    pkey = kn_scan_bytes(buf, strlen(buf));
    first_tok = PRIVATEKEY;
    err = knparse();
    kn_delete_buffer(pkey);
    keynote_lex_zap();

    if (err != 0)
    {
	if (keynote_privkey != NULL)
	{
	    free(keynote_privkey);
	    keynote_privkey = NULL;
	}

	if (keynote_errno == 0)
	  keynote_errno = ERROR_SYNTAX;

	return NULL;
    }

    s = keynote_privkey;
    keynote_privkey = NULL;
    return s;
}

/*
 * Parse Local-Constants and KeyNote-Version fields.
 */
struct environment *
keynote_get_envlist(char *buf, char *bufend, int whichfield)
{
    struct environment *en = NULL;
    YY_BUFFER_STATE localinit_state;
    int err;

    if (keynote_lex_init() != RESULT_TRUE)
      return NULL;

    localinit_state = kn_scan_bytes(buf, bufend - buf);
    if (whichfield == 0)
    {
	BEGIN(LOCALINIT);	/* We're doing Local-Constants parsing */
	first_tok = LOCINI;
    }
    else
    {
	BEGIN(KEYNOTEVERSION);	/* KeyNote-Version parsing */
      	first_tok = KNVERSION;
    }

    err = knparse();
    if (err != 0)
      if (keynote_errno == 0)
	keynote_errno = ERROR_SYNTAX;

    kn_delete_buffer(localinit_state);
    keynote_lex_zap();

    if (!whichfield)
    {
	if (keynote_errno != 0)
	  keynote_env_cleanup(&keynote_init_list, 1);
	else
	  en = keynote_init_list;

    	keynote_init_list = NULL;
    }

    /* Avoid compiler (-Wall) warnings. Never reached. */
    if (0)
    {
	yyunput(0, NULL);
    }

    return en;
}
@


1.22
log
@Remove a ton of ugly, needless casts for NULL, calloc(), and strdup().
No binary change.
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.21 2015/02/04 20:35:51 bluhm Exp $ */
a748 1
	yy_flex_realloc(0, 0);
@


1.21
log
@Replace realloc() with reallocarray() in libkeynote.  Do not free
keynote_lex_list after it has been reallocated.
Found by Benjamin Baier with llvm/scan-build;  OK florian@@
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.20 2013/11/29 19:00:51 deraadt Exp $ */
d44 1
a44 1
static struct lex_list *keynote_lex_list = (struct lex_list *) NULL;
d114 1
a114 1
					    knlval.string = (char *) NULL;
d120 1
a120 1
                                        if (knlval.string == (char *) NULL)
d145 1
a145 1
				    knlval.string = (char *) NULL;
d151 1
a151 1
                                if (knlval.string == (char *) NULL)
d170 1
a170 1
				    knlval.string = (char *) NULL;
d176 1
a176 1
                                if (knlval.string == (char *) NULL)
d209 1
a209 1
      if (keynote_lex_list[i].lex_s != (void *) NULL)
d219 1
a219 1
	  keynote_lex_list[i].lex_s = (void *) NULL;
d230 1
a230 1
    if (keynote_lex_list != (struct lex_list *) NULL)
d235 1
a235 1
	keynote_lex_list = (struct lex_list *) calloc(keynote_max_lex_list,
d237 1
a237 1
        if (keynote_lex_list == (struct lex_list *) NULL)
d257 1
a257 1
    if (s == (void *) NULL)
d261 1
a261 1
      if (keynote_lex_list[i].lex_s == (void *) NULL)
d275 1
a275 1
    if (p == (struct lex_list *) NULL)
d458 1
a458 1
    if (as->as_conditions_s == (char *) NULL)
d496 2
a497 2
    keynote_temp_list = (struct environment *) NULL;
    keynote_init_list = (struct environment *) NULL;
d516 1
a516 1
    if (as->as_keypred_s == (char *) NULL)
d541 1
a541 1
    keynote_init_list = (struct environment *) NULL;
d551 1
a551 1
	    keynote_keypred_keylist = (struct keylist *) NULL;
d566 1
a566 1
	    keynote_keypred_keylist = (struct keylist *) NULL;
d591 1
a591 1
    if ((flag) && (as->as_authorizer != (void *) NULL))
d594 1
a594 1
	as->as_authorizer = (void *) NULL;
d620 1
a620 1
    keynote_init_list = (struct environment *) NULL;
d623 1
a623 1
    if (keynote_keypred_keylist != (struct keylist *) NULL)
d641 1
a641 1
	keynote_keypred_keylist->key_key = (char *) NULL;
d643 1
a643 1
	keynote_keypred_keylist = (struct keylist *) NULL;
d674 1
a674 1
      return (char *) NULL;
d676 1
a676 1
    keynote_privkey = (char *) NULL;
d685 1
a685 1
	if (keynote_privkey != (char *) NULL)
d688 1
a688 1
	    keynote_privkey = (char *) NULL;
d694 1
a694 1
	return (char *) NULL;
d698 1
a698 1
    keynote_privkey = (char *) NULL;
d708 1
a708 1
    struct environment *en = (struct environment *) NULL;
d713 1
a713 1
      return (struct environment *) NULL;
d742 1
a742 1
    	keynote_init_list = (struct environment *) NULL;
@


1.20
log
@fairly simple unsigned char casts for ctype
ok krw
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.19 2011/04/06 11:36:23 miod Exp $ */
d272 3
a274 3
    p = (struct lex_list *) realloc(keynote_lex_list,
				    keynote_max_lex_list *
				    sizeof(struct lex_list));
a287 3

    if (p != keynote_lex_list)
 	free(keynote_lex_list);
@


1.19
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.18 2009/12/11 17:25:43 deraadt Exp $ */
d405 1
a405 1
		while (isspace((int) *(++s2)) && (len-- > 0))
@


1.18
log
@clean up the realloc code to make a parfait false positive go away.

parfait still does not completely understand how realloc() behaves
(or %, ?:, >>, or << and its terminal function tracking remains weak)
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.17 2004/06/29 11:35:56 msf Exp $ */
d752 1
a752 1
	yy_flex_realloc(0, NULL);
@


1.17
log
@Header cleanup.
ok hshoexer@@
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.16 2004/06/25 05:06:49 msf Exp $ */
d290 1
a290 4
    {
	free(keynote_lex_list);
        keynote_lex_list = p;
    }
d292 1
@


1.16
log
@Make crufty configure stuff go away. Remove all unused code paths.
No change in binaries.

ok millert@@ deraadt@@ hshoexer@@
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.15 2003/11/08 19:17:27 jmc Exp $ */
d27 1
a32 1
#include "header.h"
@


1.15
log
@typos from Jonathon Gray;
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.14 2002/05/27 06:29:14 deraadt Exp $ */
d23 2
a24 3
#if HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */
a25 1
#include <sys/types.h>
a26 2

#if STDC_HEADERS
d28 1
a28 3
#endif /* STDC_HEADERS */

#if HAVE_UNISTD_H
a29 12
#endif /* HAVE_UNISTD_H */

#if TIME_WITH_SYS_TIME
#include <sys/time.h>
#include <time.h>
#else
#if HAVE_SYS_TIME_H
#include <sys/time.h>
#else
#include <time.h>
#endif
#endif
@


1.14
log
@snprintf and strlcpy cleanup; angelos ok
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.13 2001/09/03 20:14:51 deraadt Exp $ */
d480 1
a480 1
    /* Non-existant Conditions field means highest return value */
@


1.13
log
@with or without fee; received mail permitting this change from angelos
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.12 2000/08/11 20:51:38 angelos Exp $ */
d128 1
d136 2
a137 3
					knlval.string = calloc(strlen(kntext)
							       + 1,
							       sizeof(char));
d143 1
a143 1
		  	          	strcpy(knlval.string, kntext);
d158 2
d167 2
a168 2
				knlval.string = calloc(strlen(kntext) + 1,
						       sizeof(char));
d174 1
a174 1
		  	        strcpy(knlval.string, kntext);
@


1.12
log
@Fix lexer bug (bad handling of escaped double-quote).
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.11 2000/06/13 19:16:16 angelos Exp $ */
d11 1
a11 1
 * Permission to use, copy, and modify this software without fee
@


1.11
log
@Fix some compile warnings.
@
text
@d2 1
a2 1
/* $OpenBSD$ */
d72 1
a72 1
litstring	\"(([^\"\n])|(\\[\"\n.]))*\"
a78 1

@


1.10
log
@Manpage links.
@
text
@d424 1
a424 1
		while (isspace(*(++s2)) && (len-- > 0))
@


1.9
log
@Plug a minor memory leak associated with kn_get_licensees(), and make
the latter work before a query has been issued.
@
text
@d677 10
a686 1
 * Parse a private key.
@


1.8
log
@Scale-down cleanup table on allocation failure (Stanley@@webspective.com)
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.7 2000/02/12 00:26:16 angelos Exp $ */
d529 1
a529 1
 * Store keys in key predicate as keylist in as->as_keylist, if third
d584 3
a586 1
	    
@


1.7
log
@Simplify a couple of things in the lexer, make the compiler happy so
-Wall doesn't complain at the lexers.
@
text
@d2 1
a2 1
/* $OpenBSD$ */
d301 1
@


1.6
log
@sync
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.4 1999/10/09 06:59:37 angelos Exp $ */
d69 2
a70 2
number		({digit}+)
flt		({digit}+"."{digit}+)
d72 1
a72 2
white           ((\\[\n][[:space:]]*))
litstring	\"(([^\"\n])|(\\[\"\n\f\r\t.]))*\"
d210 1
d753 7
@


1.5
log
@Roll back yesterday's commit, will wait until after 2.6.
@
text
@d2 1
a2 1
/* $OpenBSD: keynote.l,v 1.3 1999/10/01 01:08:30 angelos Exp $ */
d50 1
@


1.4
log
@Move all ifdefs in header.h (instead of keynote.h), include header.h
in all files including keynote.h, update manpage.
@
text
@d2 1
a2 1
/* $OpenBSD$ */
a49 1
#include "header.h"
@


1.3
log
@Update for version 2.0
@
text
@d50 1
@


1.2
log
@Sanitize prototypes and variable extern definitions, remove
unnecessary header file, add prototypes header file for utility building.
@
text
@d23 4
d28 7
d36 9
a44 2
#include <ctype.h>
#ifndef PILOT
d46 2
a47 2
#endif /* PILOT */
#include <string.h>
d512 1
a512 1
    kn_delete_buffer(keynote_bs);	/* Free the space */
d557 1
a557 1
    kn_delete_buffer(keypred_state);  /* Free memory */
d634 1
a634 1
    kn_delete_buffer(authorizer_state);  /* Free memory */
@


1.1
log
@Initial revision
@
text
@a2 1

d30 1
d32 1
a32 1
#include "environment.h"
a33 1
#include "signature.h"
a35 1
extern int knparse();
a46 10

int keynote_used_variable = 0;
int keynote_exceptionflag = 0;
int keynote_donteval = 0;

char *keynote_privkey = (char *) NULL;
 
struct environment *keynote_init_list = (struct environment *) NULL;
struct environment *keynote_temp_list = (struct environment *) NULL;
struct keylist *keynote_keypred_keylist = (struct keylist *) NULL;
@


1.1.1.1
log
@KeyNote version 2 trust-management system (security policy handling).
Utilities to follow.

@
text
@@
