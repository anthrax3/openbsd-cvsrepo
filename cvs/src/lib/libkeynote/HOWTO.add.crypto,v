head	1.3;
access;
symbols
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.72
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.68
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.64
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.66
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.58
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.62
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.60
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.56
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.54
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.52
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.50
	OPENBSD_5_0:1.3.0.48
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.46
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.44
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.40
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.42
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.38
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.36
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.34
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.32
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.30
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.28
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.26
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.24
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.22
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.20
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.18
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.16
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	KeyNote-v2:1.1.1.1
	Angelos:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2000.01.25.09.08.09;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.05.25.21.42.19;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.05.23.22.11.04;	author angelos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.23.22.11.04;	author angelos;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Sync with current version (just the file renamed).
@
text
@# $OpenBSD$

This document describes how to add support for digital signature algorithms,
hash functions, and ASCII encoding mechanisms in this implementation.

For a signature algorithm:

- Add the appropriate include files in keynote.h
- Create one or more strings describing the signature algorithm
  prefixes, and add those to keynote.h (the SIG_* definitions).
- Add a definition for the algorithm in keynote.h (the
  KEYNOTE_ALGORITHM_* definitions).
- Define the algorithm public key prefixes, and add them to
  signature.h (the *_HEX, *_HEX_LEN, *_BASE64, *_BASE64_LEN
  definitions).
- In auxil.c, function keynote_keyhash(), add to the switch statement
  a case handling the new algorithm; the return value is an integer,
  and is used as an index into a hash table.
- In signature.c:
  - In keynote_free_key(), add code to free any memory allocated for
    storing a key for the new algorithm.
  - In keynote_get_sig_algorithm(), add code that checks whether a
    signature string begins with one of the prefixes for the new
    algorithm that were defined in keynote.h
  - Similarly, in keynote_get_key_algorithm() for key strings, using
    the key prefixes defined in signature.h
  - In kn_decode_key(), add code that converts a bit string to
    the new algorithm's structure for storing a key (use the DSA
    code as a guide).
  - Similarly for kn_encode_key()
  - In kn_keycompare(), add code that compares two keys and
    returns RETURN_TRUE if they are equal, and RETURN_FALSE otherwise.
  - In keynote_signverify_assertion, add code that verifies a
    signature for the new algorithm.
  - Likewise for signature generation in keynote_sign_assertion()
- In keynote-keygen.c, replicate the code for DSA key generation to
  support the new algorithm.

For a hash algorithm:

- Add the necessary include files in keynote.h
- Add a KEYNOTE_HASH_* definition for the algorithm in signature.h
- In signature.h, if the length of the new hash function's result is
  more than LARGEST_HASH_SIZE (currently 20 bytes, for SHA1), then
  replace that value with the new function's hash result length.
- In signature.c:
  - In keynote_sigverify_assertion(), add code in the switch statement
    for generating a hash of the assertion and the signature algorithm
    name (use the SHA1 code as an example).
  - Likewise in keynote_sign_assertion()

For an ASCII-encoding algorithm:

- Add the necessary include files in keynote.h
- Add additional SIG_* definitions in keynote.h
- Add an ENCODING_* definition in keynote.h
- Add additional key prefix string definitions in signature.h
- In signature.c:
  - In keynote_get_sig_algorithm(), add code for detecting signatures 
    with this encoding.
  - Likewise for keys in keynote_get_key_algorithm()
  - In kn_decode_key(), add code in the switch statement for decoding
    ASCII-encoded keys.
  - Likewise in kn_encode_key() for encoding keys.
  - Likewise in keynote_sigverify_assertion() for decoding signatures.
  - Add the necessary checks in keynote_sign_assertion() for handling
    the new encoding, and code in the switch statement for doing the
    encoding of the signature.
- Add the necessary checks in keynote-keygen.c for handling the
  new algorithm.

@


1.2
log
@Export kn_keycompare() in the API, update the spec and man pages.

Note that the *.1 manpages will all be rolled into a single one soon.
@
text
@d1 1
a1 1
# $OpenBSD: HOWTO.add.crypto,v 1.1.1.1 1999/05/23 22:11:04 angelos Exp $
d16 1
a16 1
- In aux.c, function keynote_keyhash(), add to the switch statement
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $OpenBSD$
d31 1
a31 1
  - In keynote_keycompare(), add code that compares two keys and
@


1.1.1.1
log
@KeyNote version 2 trust-management system (security policy handling).
Utilities to follow.

@
text
@@
