head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7;
locks; strict;
comment	@ * @;


1.19
date	2017.04.10.17.11.13;	author jsing;	state Exp;
branches;
next	1.18;
commitid	3nmBs0stdHQq3Td1;

1.18
date	2016.11.04.15.32.40;	author jsing;	state Exp;
branches;
next	1.17;
commitid	wrxK1ijhFnJWDNkU;

1.17
date	2016.09.04.12.26.43;	author bcook;	state Exp;
branches;
next	1.16;
commitid	pRMpDkZhqg5jtYzf;

1.16
date	2016.08.02.07.47.11;	author jsing;	state Exp;
branches;
next	1.15;
commitid	0rb7ZAopgz9STgBs;

1.15
date	2015.09.29.13.10.53;	author jsing;	state Exp;
branches;
next	1.14;
commitid	oxmr750TVHvGS4sq;

1.14
date	2015.09.29.10.17.04;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	YDjtN3rqnZIVf1NW;

1.13
date	2015.09.11.13.12.29;	author beck;	state Exp;
branches;
next	1.12;
commitid	zpBwiLNH4QxT2cDI;

1.12
date	2015.09.11.12.56.55;	author beck;	state Exp;
branches;
next	1.11;
commitid	sb4du43rG1oa1RCm;

1.11
date	2015.09.09.19.49.07;	author jsing;	state Exp;
branches;
next	1.10;
commitid	8fjywsQemyYNWdJq;

1.10
date	2015.08.27.15.26.50;	author jsing;	state Exp;
branches;
next	1.9;
commitid	5FIlAb8mLiRyTsjH;

1.9
date	2015.08.27.07.15.39;	author jsing;	state Exp;
branches;
next	1.8;
commitid	WntzmW99p0nTphih;

1.8
date	2015.04.29.00.24.31;	author doug;	state Exp;
branches;
next	1.7;
commitid	sZYMTpjUiqc88ojT;

1.7
date	2015.02.11.06.46.33;	author jsing;	state Exp;
branches;
next	1.6;
commitid	IjYTp2gC6lDO8mXr;

1.6
date	2014.12.17.17.51.33;	author doug;	state Exp;
branches;
next	1.5;
commitid	FJcG0ONhp35NLtZH;

1.5
date	2014.12.07.16.56.17;	author bcook;	state Exp;
branches;
next	1.4;
commitid	ig91zabTuUs7Q4W8;

1.4
date	2014.12.07.16.01.03;	author jsing;	state Exp;
branches;
next	1.3;
commitid	pxVVjBjNkMTIeTHg;

1.3
date	2014.12.07.15.48.02;	author bcook;	state Exp;
branches;
next	1.2;
commitid	fFnOSh51GKLvzA5B;

1.2
date	2014.12.07.15.00.32;	author bcook;	state Exp;
branches;
next	1.1;
commitid	KH9lDmo5JWgqgo2G;

1.1
date	2014.10.31.13.46.17;	author jsing;	state Exp;
branches;
next	;
commitid	y63FmUITd26yVanM;


desc
@@


1.19
log
@Rework name verification code so that a match is indicated via an argument,
rather than return codes. More strictly follow RFC 6125, in particular only
check the CN if there are no SAN identifiers present in the certificate
(per section 6.4.4).

Previous behaviour questioned by Daniel Stenberg <daniel at haxx dot se>.

ok beck@@ jca@@
@
text
@/* $OpenBSD: tls_verify.c,v 1.18 2016/11/04 15:32:40 jsing Exp $ */
/*
 * Copyright (c) 2014 Jeremie Courreges-Anglas <jca@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/socket.h>

#include <arpa/inet.h>
#include <netinet/in.h>

#include <string.h>

#include <openssl/x509v3.h>

#include <tls.h>
#include "tls_internal.h"

static int
tls_match_name(const char *cert_name, const char *name)
{
	const char *cert_domain, *domain, *next_dot;

	if (strcasecmp(cert_name, name) == 0)
		return 0;

	/* Wildcard match? */
	if (cert_name[0] == '*') {
		/*
		 * Valid wildcards:
		 * - "*.domain.tld"
		 * - "*.sub.domain.tld"
		 * - etc.
		 * Reject "*.tld".
		 * No attempt to prevent the use of eg. "*.co.uk".
		 */
		cert_domain = &cert_name[1];
		/* Disallow "*"  */
		if (cert_domain[0] == '\0')
			return -1;
		/* Disallow "*foo" */
		if (cert_domain[0] != '.')
			return -1;
		/* Disallow "*.." */
		if (cert_domain[1] == '.')
			return -1;
		next_dot = strchr(&cert_domain[1], '.');
		/* Disallow "*.bar" */
		if (next_dot == NULL)
			return -1;
		/* Disallow "*.bar.." */
		if (next_dot[1] == '.')
			return -1;

		domain = strchr(name, '.');

		/* No wildcard match against a name with no host part. */
		if (name[0] == '.')
			return -1;
		/* No wildcard match against a name with no domain part. */
		if (domain == NULL || strlen(domain) == 1)
			return -1;

		if (strcasecmp(cert_domain, domain) == 0)
			return 0;
	}

	return -1;
}

/*
 * See RFC 5280 section 4.2.1.6 for SubjectAltName details.
 * alt_match is set to 1 if a matching alternate name is found.
 * alt_exists is set to 1 if any known alternate name exists in the certificate.
 */
static int
tls_check_subject_altname(struct tls *ctx, X509 *cert, const char *name,
    int *alt_match, int *alt_exists)
{
	STACK_OF(GENERAL_NAME) *altname_stack = NULL;
	union tls_addr addrbuf;
	int addrlen, type;
	int count, i;
	int rv = 0;

	*alt_match = 0;
	*alt_exists = 0;

	altname_stack = X509_get_ext_d2i(cert, NID_subject_alt_name,
	    NULL, NULL);
	if (altname_stack == NULL)
		return 0;

	if (inet_pton(AF_INET, name, &addrbuf) == 1) {
		type = GEN_IPADD;
		addrlen = 4;
	} else if (inet_pton(AF_INET6, name, &addrbuf) == 1) {
		type = GEN_IPADD;
		addrlen = 16;
	} else {
		type = GEN_DNS;
		addrlen = 0;
	}

	count = sk_GENERAL_NAME_num(altname_stack);
	for (i = 0; i < count; i++) {
		GENERAL_NAME	*altname;

		altname = sk_GENERAL_NAME_value(altname_stack, i);

		if (altname->type == GEN_DNS || altname->type == GEN_IPADD)
			*alt_exists = 1;

		if (altname->type != type)
			continue;

		if (type == GEN_DNS) {
			unsigned char	*data;
			int		 format, len;

			format = ASN1_STRING_type(altname->d.dNSName);
			if (format == V_ASN1_IA5STRING) {
				data = ASN1_STRING_data(altname->d.dNSName);
				len = ASN1_STRING_length(altname->d.dNSName);

				if (len < 0 || (size_t)len != strlen(data)) {
					tls_set_errorx(ctx,
					    "error verifying name '%s': "
					    "NUL byte in subjectAltName, "
					    "probably a malicious certificate",
					    name);
					rv = -1;
					break;
				}

				/*
				 * Per RFC 5280 section 4.2.1.6:
				 * " " is a legal domain name, but that
				 * dNSName must be rejected.
				 */
				if (strcmp(data, " ") == 0) {
					tls_set_errorx(ctx,
					    "error verifying name '%s': "
					    "a dNSName of \" \" must not be "
					    "used", name);
					rv = -1;
					break;
				}

				if (tls_match_name(data, name) == 0) {
					*alt_match = 1;
					break;
				}
			} else {
#ifdef DEBUG
				fprintf(stdout, "%s: unhandled subjectAltName "
				    "dNSName encoding (%d)\n", getprogname(),
				    format);
#endif
			}

		} else if (type == GEN_IPADD) {
			unsigned char	*data;
			int		 datalen;

			datalen = ASN1_STRING_length(altname->d.iPAddress);
			data = ASN1_STRING_data(altname->d.iPAddress);

			if (datalen < 0) {
				tls_set_errorx(ctx,
				    "Unexpected negative length for an "
				    "IP address: %d", datalen);
				rv = -1;
				break;
			}

			/*
			 * Per RFC 5280 section 4.2.1.6:
			 * IPv4 must use 4 octets and IPv6 must use 16 octets.
			 */
			if (datalen == addrlen &&
			    memcmp(data, &addrbuf, addrlen) == 0) {
				*alt_match = 1;
				break;
			}
		}
	}

	sk_GENERAL_NAME_pop_free(altname_stack, GENERAL_NAME_free);
	return rv;
}

static int
tls_check_common_name(struct tls *ctx, X509 *cert, const char *name,
    int *cn_match)
{
	X509_NAME *subject_name;
	char *common_name = NULL;
	union tls_addr addrbuf;
	int common_name_len;
	int rv = 0;

	*cn_match = 0;

	subject_name = X509_get_subject_name(cert);
	if (subject_name == NULL)
		goto out;

	common_name_len = X509_NAME_get_text_by_NID(subject_name,
	    NID_commonName, NULL, 0);
	if (common_name_len < 0)
		goto out;

	common_name = calloc(common_name_len + 1, 1);
	if (common_name == NULL)
		goto out;

	X509_NAME_get_text_by_NID(subject_name, NID_commonName, common_name,
	    common_name_len + 1);

	/* NUL bytes in CN? */
	if (common_name_len < 0 ||
	    (size_t)common_name_len != strlen(common_name)) {
		tls_set_errorx(ctx, "error verifying name '%s': "
		    "NUL byte in Common Name field, "
		    "probably a malicious certificate", name);
		rv = -1;
		goto out;
	}

	/*
	 * We don't want to attempt wildcard matching against IP addresses,
	 * so perform a simple comparison here.
	 */
	if (inet_pton(AF_INET,  name, &addrbuf) == 1 ||
	    inet_pton(AF_INET6, name, &addrbuf) == 1) {
		if (strcmp(common_name, name) == 0)
			*cn_match = 1;
		goto out;
	}

	if (tls_match_name(common_name, name) == 0)
		*cn_match = 1;

 out:
	free(common_name);
	return rv;
}

int
tls_check_name(struct tls *ctx, X509 *cert, const char *name, int *match)
{
	int alt_exists;

	*match = 0;

	if (tls_check_subject_altname(ctx, cert, name, match,
	    &alt_exists) == -1)
		return -1;

	/*
	 * As per RFC 6125 section 6.4.4, if any known alternate name existed
	 * in the certificate, we do not attempt to match on the CN.
	 */
	if (*match || alt_exists)
		return 0;

	return tls_check_common_name(ctx, cert, name, match);
}
@


1.18
log
@Avoid signed vs unsigned comparisons.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.17 2016/09/04 12:26:43 bcook Exp $ */
a29 5
static int tls_match_name(const char *cert_name, const char *name);
static int tls_check_subject_altname(struct tls *ctx, X509 *cert,
    const char *name);
static int tls_check_common_name(struct tls *ctx, X509 *cert, const char *name);

d82 5
a86 1
/* See RFC 5280 section 4.2.1.6 for SubjectAltName details. */
d88 2
a89 1
tls_check_subject_altname(struct tls *ctx, X509 *cert, const char *name)
d95 4
a98 1
	int rv = -1;
d103 1
a103 1
		return -1;
d121 4
d143 1
a143 1
					rv = -2;
d153 1
a153 1
					tls_set_error(ctx,
d157 1
a157 1
					rv = -2;
d162 1
a162 1
					rv = 0;
d184 1
a184 1
				rv = -2;
d194 1
a194 1
				rv = 0;
d205 2
a206 1
tls_check_common_name(struct tls *ctx, X509 *cert, const char *name)
d212 3
a214 1
	int rv = -1;
d238 1
a238 1
		rv = -2;
d242 4
a247 4
		/*
		 * We don't want to attempt wildcard matching against IP
		 * addresses, so perform a simple comparison here.
		 */
d249 1
a249 3
			rv = 0;
		else
			rv = -1;
d254 2
a255 1
		rv = 0;
d262 1
a262 1
tls_check_name(struct tls *ctx, X509 *cert, const char *name)
d264 1
a264 1
	int	rv;
d266 12
a277 3
	rv = tls_check_subject_altname(ctx, cert, name);
	if (rv == 0 || rv == -2)
		return rv;
d279 1
a279 1
	return tls_check_common_name(ctx, cert, name);
@


1.17
log
@Add callback-based interface to libtls.

This allows working with buffers and callback functions instead of directly on
sockets or file descriptors.
Original patch from Tobias Pape <tobias_at_netshed.de>.
ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.16 2016/08/02 07:47:11 jsing Exp $ */
d130 1
a130 1
				if (len < 0 || len != strlen(data)) {
d223 2
a224 1
	if (common_name_len != strlen(common_name)) {
@


1.16
log
@Revert previous since it adds new symbols.

Requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.15 2015/09/29 13:10:53 jsing Exp $ */
d27 1
@


1.15
log
@Instead of declaring a union in multiple places, move it to tls_internal.h.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.14 2015/09/29 10:17:04 deraadt Exp $ */
a116 1

@


1.14
log
@clean some ugly intendation warts
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.13 2015/09/11 13:12:29 beck Exp $ */
d91 1
a91 4
	union {
		struct in_addr ip4;
		struct in6_addr ip6;
	} addrbuf;
d202 1
a204 4
	union {
		struct in_addr ip4;
		struct in6_addr ip6;
	} addrbuf;
@


1.13
log
@Do not match a wildcard against a name with no host part.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.12 2015/09/11 12:56:55 beck Exp $ */
d91 4
a94 1
	union { struct in_addr ip4; struct in6_addr ip6; } addrbuf;
d207 4
a210 1
	union { struct in_addr ip4; struct in6_addr ip6; } addrbuf;
@


1.12
log
@add tls_peer functions for checking names and issuers of peer certificates.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.11 2015/09/09 19:49:07 jsing Exp $ */
d72 3
@


1.11
log
@Indent labels with a space so that diff -p is more friendly.

Requested by bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.10 2015/08/27 15:26:50 jsing Exp $ */
d249 1
a249 1
tls_check_servername(struct tls *ctx, X509 *cert, const char *servername)
d253 1
a253 1
	rv = tls_check_subject_altname(ctx, cert, servername);
d257 1
a257 1
	return tls_check_common_name(ctx, cert, servername);
@


1.10
log
@Improve libtls error messages.

The tls_set_error() function previously stored the errno but did nothing
with it. Change tls_set_error() to append the strerror(3) of the stored
errno so that we include useful information regarding failures.

Provide a tls_set_errorx() function that does not store the errno or
include strerror(3) in the error message. Call this function instead of
tls_set_error() for errors where the errno value has no useful meaning.

With feedback from and ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.9 2015/08/27 07:15:39 jsing Exp $ */
d243 1
a243 1
out:
@


1.9
log
@Make functions that are internal to tls verify static.

Spotted by Marko Kreen.

Rides libtls major bump.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.8 2015/04/29 00:24:31 doug Exp $ */
d128 1
a128 1
					tls_set_error(ctx,
d171 1
a171 1
				tls_set_error(ctx,
d221 1
a221 1
		tls_set_error(ctx, "error verifying name '%s': "
@


1.8
log
@Reject dNSName of " " for subjectAltName extension.

RFC 5280 says " " must not be used as a dNSName.

ok jsing@@ jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.7 2015/02/11 06:46:33 jsing Exp $ */
d29 4
a32 3
int tls_match_name(const char *cert_name, const char *name);
int tls_check_subject_altname(struct tls *ctx, X509 *cert, const char *name);
int tls_check_common_name(struct tls *ctx, X509 *cert, const char *name);
d34 1
a34 1
int
d84 1
a84 1
int
d194 1
a194 1
int
@


1.7
log
@Be consistent with naming - only use "host" and "hostname" when referring
to an actual host and use "servername" when referring to the name of the
TLS server that we expect to be indentified in the server certificate.

Likewise, rename verify_host to verify_name and use the term "name"
throughout the verification code (rather than host or hostname).

Requested by and ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.6 2014/12/17 17:51:33 doug Exp $ */
d82 1
d136 14
d177 4
@


1.6
log
@Add size_t to int checks for SSL functions.

libtls accepts size_t for lengths but libssl accepts int.  This verifies
that the input does not exceed INT_MAX.  It also avoids truncating size_t
when comparing with int and adds printf-style attributes for
tls_set_error().

with input from deraadt@@ and tedu@@
ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.5 2014/12/07 16:56:17 bcook Exp $ */
d29 3
a31 3
int tls_match_hostname(const char *cert_hostname, const char *hostname);
int tls_check_subject_altname(struct tls *ctx, X509 *cert, const char *host);
int tls_check_common_name(struct tls *ctx, X509 *cert, const char *host);
d34 1
a34 1
tls_match_hostname(const char *cert_hostname, const char *hostname)
d38 1
a38 1
	if (strcasecmp(cert_hostname, hostname) == 0)
d42 1
a42 1
	if (cert_hostname[0] == '*') {
d51 1
a51 1
		cert_domain = &cert_hostname[1];
d69 1
a69 1
		domain = strchr(hostname, '.');
d71 1
a71 1
		/* No wildcard match against a hostname with no domain part. */
d83 1
a83 1
tls_check_subject_altname(struct tls *ctx, X509 *cert, const char *host)
d96 1
a96 1
	if (inet_pton(AF_INET, host, &addrbuf) == 1) {
d99 1
a99 1
	} else if (inet_pton(AF_INET6, host, &addrbuf) == 1) {
d127 1
a127 1
					    "error verifying host '%s': "
d130 1
a130 1
					    host);
d135 1
a135 1
				if (tls_match_hostname(data, host) == 0) {
d175 1
a175 1
tls_check_common_name(struct tls *ctx, X509 *cert, const char *host)
d177 1
a177 1
	X509_NAME *name;
d183 2
a184 2
	name = X509_get_subject_name(cert);
	if (name == NULL)
d187 2
a188 2
	common_name_len = X509_NAME_get_text_by_NID(name, NID_commonName,
	    NULL, 0);
d196 1
a196 1
	X509_NAME_get_text_by_NID(name, NID_commonName, common_name,
d201 1
a201 1
		tls_set_error(ctx, "error verifying host '%s': "
d203 1
a203 1
		    "probably a malicious certificate.", host);
d208 2
a209 2
	if (inet_pton(AF_INET,  host, &addrbuf) == 1 ||
	    inet_pton(AF_INET6, host, &addrbuf) == 1) {
d214 1
a214 1
		if (strcmp(common_name, host) == 0)
d221 1
a221 1
	if (tls_match_hostname(common_name, host) == 0)
d229 1
a229 1
tls_check_hostname(struct tls *ctx, X509 *cert, const char *host)
d233 1
a233 1
	rv = tls_check_subject_altname(ctx, cert, host);
d237 1
a237 1
	return tls_check_common_name(ctx, cert, host);
@


1.5
log
@Allow specific libtls hostname validation errors to propagate.

Remove direct calls to printf from the tls_check_hostname() path. This allows
NUL byte error messages to bubble up to the caller, to be logged in a
program-appropriate way. It also removes non-portable calls to getprogname().

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.4 2014/12/07 16:01:03 jsing Exp $ */
d118 1
a118 1
			int		 format;
d123 1
d125 1
a125 2
				if (ASN1_STRING_length(altname->d.dNSName) !=
				    (int)strlen(data)) {
d154 8
d200 1
a200 1
	if (common_name_len != (int)strlen(common_name)) {
@


1.4
log
@Fix a memory leak in tls_check_subject_altname() by calling
sk_GENERAL_NAME_pop_free() instead of sk_GENERAL_NAME_free(). The latter
only frees the stack itself and does not free the items.

From Basskrapfen on github.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.3 2014/12/07 15:48:02 bcook Exp $ */
d30 2
a31 2
int tls_check_subject_altname(X509 *cert, const char *host);
int tls_check_common_name(X509 *cert, const char *host);
d83 1
a83 1
tls_check_subject_altname(X509 *cert, const char *host)
d126 5
a130 4
					fprintf(stdout, "%s: NUL byte in "
					    "subjectAltName, probably a "
					    "malicious certificate.\n",
					    getprogname());
d139 2
a140 1
			} else
d144 2
d167 1
a167 1
tls_check_common_name(X509 *cert, const char *host)
d193 3
a195 2
		fprintf(stdout, "%s: NUL byte in Common Name field, "
		    "probably a malicious certificate.\n", getprogname());
d221 1
a221 1
tls_check_hostname(X509 *cert, const char *host)
d225 1
a225 1
	rv = tls_check_subject_altname(cert, host);
d229 1
a229 1
	return tls_check_common_name(cert, host);
@


1.3
log
@revert previous change for now, adjusting based on comments from jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.2 2014/12/07 15:00:32 bcook Exp $ */
d158 1
a158 1
	sk_GENERAL_NAME_free(altname_stack);
@


1.2
log
@Allow specific libtls hostname validation errors to propagate.

Remove direct calls to printf from the tls_check_hostname() path. This allows
NUL byte error messages to bubble up to the caller, to be logged in a
program-appropriate way. It also removes non-portable calls to getprogname().

The semantics of tls_error() are changed slightly: the last error message is
not necessarily preserved between subsequent calls into the library.
When the previous call to libtls succeeds, client programs should treat the
return value of tls_error() as undefined.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.1 2014/10/31 13:46:17 jsing Exp $ */
d30 2
a31 2
int tls_check_subject_altname(struct tls *ctx, X509 *cert, const char *host);
int tls_check_common_name(struct tls *ctx, X509 *cert, const char *host);
d83 1
a83 1
tls_check_subject_altname(struct tls *ctx, X509 *cert, const char *host)
d126 4
a129 5
					tls_set_error(ctx,
					    "error verifying host '%s': "
					    "NUL byte in subjectAltName, "
					    "probably a malicious certificate",
					    host);
d138 4
a141 1
			}
d163 1
a163 1
tls_check_common_name(struct tls *ctx, X509 *cert, const char *host)
d189 2
a190 3
		tls_set_error(ctx, "error verifying host '%s': "
		    "NUL byte in Common Name field, "
		    "probably a malicious certificate.", host);
d216 1
a216 1
tls_check_hostname(struct tls *ctx, X509 *cert, const char *host)
d220 1
a220 1
	rv = tls_check_subject_altname(ctx, cert, host);
d224 1
a224 1
	return tls_check_common_name(ctx, cert, host);
@


1.1
log
@Rename libressl to libtls to avoid confusion and to make it easier to
distinguish between LibreSSL (the project) and libressl (the library).

Discussed with many.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_verify.c,v 1.5 2014/10/06 11:55:48 jca Exp $ */
d30 2
a31 2
int tls_check_subject_altname(X509 *cert, const char *host);
int tls_check_common_name(X509 *cert, const char *host);
d83 1
a83 1
tls_check_subject_altname(X509 *cert, const char *host)
d126 5
a130 4
					fprintf(stdout, "%s: NUL byte in "
					    "subjectAltName, probably a "
					    "malicious certificate.\n",
					    getprogname());
d139 1
a139 4
			} else
				fprintf(stdout, "%s: unhandled subjectAltName "
				    "dNSName encoding (%d)\n", getprogname(),
				    format);
d161 1
a161 1
tls_check_common_name(X509 *cert, const char *host)
d187 3
a189 2
		fprintf(stdout, "%s: NUL byte in Common Name field, "
		    "probably a malicious certificate.\n", getprogname());
d215 1
a215 1
tls_check_hostname(X509 *cert, const char *host)
d219 1
a219 1
	rv = tls_check_subject_altname(cert, host);
d223 1
a223 1
	return tls_check_common_name(cert, host);
@

