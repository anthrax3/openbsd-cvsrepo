head	1.59;
access;
symbols
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7;
locks; strict;
comment	@ * @;


1.59
date	2017.01.26.12.56.37;	author jsing;	state Exp;
branches;
next	1.58;
commitid	fXjilM4ZG2ENdzA8;

1.58
date	2017.01.22.08.27.50;	author claudio;	state Exp;
branches;
next	1.57;
commitid	XyxfjwSrIhbxkSK8;

1.57
date	2017.01.13.17.09.51;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	hPT0hsr5yRp0kvrL;

1.56
date	2017.01.03.17.19.57;	author jsing;	state Exp;
branches;
next	1.55;
commitid	nM1mbppBdp0t9fMn;

1.55
date	2017.01.03.17.13.41;	author jsing;	state Exp;
branches;
next	1.54;
commitid	yX7qdoEoQsP4jd3p;

1.54
date	2017.01.02.22.03.56;	author tedu;	state Exp;
branches;
next	1.53;
commitid	6Jz2SfPzqpeGvcyO;

1.53
date	2016.12.26.16.20.58;	author jsing;	state Exp;
branches;
next	1.52;
commitid	Z4OhofWr8Q2T59FE;

1.52
date	2016.11.05.14.50.05;	author beck;	state Exp;
branches;
next	1.51;
commitid	vIHPrOGMa5sQTHt5;

1.51
date	2016.11.03.10.05.32;	author jsing;	state Exp;
branches;
next	1.50;
commitid	VAmEYsdUv3IyIABe;

1.50
date	2016.11.02.15.18.42;	author beck;	state Exp;
branches;
next	1.49;
commitid	OsrmWrsuHXqdXb2Z;

1.49
date	2016.09.04.12.26.43;	author bcook;	state Exp;
branches;
next	1.48;
commitid	pRMpDkZhqg5jtYzf;

1.48
date	2016.08.22.17.12.35;	author jsing;	state Exp;
branches;
next	1.47;
commitid	WaQ5KFxCfd7HOivZ;

1.47
date	2016.08.22.14.51.37;	author jsing;	state Exp;
branches;
next	1.46;
commitid	8BA0jRjLExCiDXSD;

1.46
date	2016.08.15.14.04.23;	author jsing;	state Exp;
branches;
next	1.45;
commitid	skqiBPIfpiAFudga;

1.45
date	2016.08.13.13.05.51;	author jsing;	state Exp;
branches;
next	1.44;
commitid	dEFnw34DXI0aEQXO;

1.44
date	2016.08.12.15.10.59;	author jsing;	state Exp;
branches;
next	1.43;
commitid	JoLVmCulWsGsIXUK;

1.43
date	2016.08.02.07.47.11;	author jsing;	state Exp;
branches;
next	1.42;
commitid	0rb7ZAopgz9STgBs;

1.42
date	2016.08.01.17.32.19;	author jsing;	state Exp;
branches;
next	1.41;
commitid	s3UFLNfN0t7jV6pK;

1.41
date	2016.07.07.14.09.03;	author jsing;	state Exp;
branches;
next	1.40;
commitid	0fGHFHTpGSNSAMDC;

1.40
date	2016.07.06.16.16.36;	author jsing;	state Exp;
branches;
next	1.39;
commitid	kH7xEZhqwkoUIN0m;

1.39
date	2016.07.06.02.32.57;	author jsing;	state Exp;
branches;
next	1.38;
commitid	jdysS9LPBSbzoiUh;

1.38
date	2016.05.27.14.38.40;	author jsing;	state Exp;
branches;
next	1.37;
commitid	VY5Ci9qTBsSOcCgx;

1.37
date	2016.04.28.17.05.59;	author jsing;	state Exp;
branches;
next	1.36;
commitid	DKpbOonvEBeRoW5p;

1.36
date	2016.04.28.16.48.44;	author jsing;	state Exp;
branches;
next	1.35;
commitid	pJ2jMgrYqvai7CXS;

1.35
date	2016.01.18.16.15.14;	author bcook;	state Exp;
branches;
next	1.34;
commitid	UNFnYwpRgElebVh2;

1.34
date	2015.10.07.23.25.45;	author beck;	state Exp;
branches;
next	1.33;
commitid	5h819tXbrcEfaD7k;

1.33
date	2015.09.29.10.17.04;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	YDjtN3rqnZIVf1NW;

1.32
date	2015.09.14.16.16.38;	author jsing;	state Exp;
branches;
next	1.31;
commitid	Fd6WDkwQWggESQVJ;

1.31
date	2015.09.14.12.29.16;	author jsing;	state Exp;
branches;
next	1.30;
commitid	G1hTgD0N6J7qusS7;

1.30
date	2015.09.14.12.20.40;	author jsing;	state Exp;
branches;
next	1.29;
commitid	nPcvJl0BZBIMuFhj;

1.29
date	2015.09.13.15.39.15;	author beck;	state Exp;
branches;
next	1.28;
commitid	sGDFPrMphMLS1hyC;

1.28
date	2015.09.13.13.44.07;	author beck;	state Exp;
branches;
next	1.27;
commitid	E2vqp3AohbRdBgiQ;

1.27
date	2015.09.12.21.00.38;	author beck;	state Exp;
branches;
next	1.26;
commitid	iEhBM6X1bQFFdcQ1;

1.26
date	2015.09.12.19.54.31;	author jsing;	state Exp;
branches;
next	1.25;
commitid	tI7XkG4J1fY7en1u;

1.25
date	2015.09.11.09.24.54;	author jsing;	state Exp;
branches;
next	1.24;
commitid	eNherZWGYH2vTTyu;

1.24
date	2015.09.10.18.43.03;	author jsing;	state Exp;
branches;
next	1.23;
commitid	pmkiPTxBa5UfZFdl;

1.23
date	2015.09.10.10.59.22;	author beck;	state Exp;
branches;
next	1.22;
commitid	XvKhmCqeyI8xzhBD;

1.22
date	2015.09.10.10.26.49;	author beck;	state Exp;
branches;
next	1.21;
commitid	LulMRRGp3SkwbieR;

1.21
date	2015.09.10.10.22.28;	author beck;	state Exp;
branches;
next	1.20;
commitid	d4drHlNVn9rkwmBp;

1.20
date	2015.09.10.10.14.20;	author jsing;	state Exp;
branches;
next	1.19;
commitid	XGvr88Fsecamv3XQ;

1.19
date	2015.09.09.19.49.07;	author jsing;	state Exp;
branches;
next	1.18;
commitid	8fjywsQemyYNWdJq;

1.18
date	2015.09.09.19.23.04;	author beck;	state Exp;
branches;
next	1.17;
commitid	nJxZtGxH6XzyXez3;

1.17
date	2015.09.09.18.22.33;	author beck;	state Exp;
branches;
next	1.16;
commitid	KlUYCJD0qmt0mtJJ;

1.16
date	2015.09.09.17.43.42;	author beck;	state Exp;
branches;
next	1.15;
commitid	9og5OkoZKrWJ8eg7;

1.15
date	2015.08.27.15.26.49;	author jsing;	state Exp;
branches;
next	1.14;
commitid	5FIlAb8mLiRyTsjH;

1.14
date	2015.08.27.14.34.46;	author jsing;	state Exp;
branches;
next	1.13;
commitid	VxGExiBacrXbtka4;

1.13
date	2015.08.22.14.20.53;	author jsing;	state Exp;
branches;
next	1.12;
commitid	wkTYiPvxAxJW0W5O;

1.12
date	2015.07.18.22.15.09;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	W7M7UZ0DfM97FmM2;

1.11
date	2015.04.15.16.08.43;	author jsing;	state Exp;
branches;
next	1.10;
commitid	FcIaf9sacJrfyPB1;

1.10
date	2015.04.15.16.05.23;	author jsing;	state Exp;
branches;
next	1.9;
commitid	M6hepf9HQqTE5Mr2;

1.9
date	2015.04.02.13.19.15;	author jsing;	state Exp;
branches;
next	1.8;
commitid	gEbGjQ3WrLkgYiLT;

1.8
date	2015.03.31.12.21.27;	author jsing;	state Exp;
branches;
next	1.7;
commitid	zTdtFn3A4fRovB4F;

1.7
date	2015.02.07.09.50.09;	author jsing;	state Exp;
branches;
next	1.6;
commitid	QsFM5heC1IRpgG38;

1.6
date	2015.02.07.04.33.51;	author jsing;	state Exp;
branches;
next	1.5;
commitid	VdANM6dHB8frQwsh;

1.5
date	2015.02.06.01.37.11;	author reyk;	state Exp;
branches;
next	1.4;
commitid	Lv0p59uUkApDv6rT;

1.4
date	2014.12.17.17.51.33;	author doug;	state Exp;
branches;
next	1.3;
commitid	FJcG0ONhp35NLtZH;

1.3
date	2014.12.07.15.48.02;	author bcook;	state Exp;
branches;
next	1.2;
commitid	fFnOSh51GKLvzA5B;

1.2
date	2014.12.07.15.00.32;	author bcook;	state Exp;
branches;
next	1.1;
commitid	KH9lDmo5JWgqgo2G;

1.1
date	2014.10.31.13.46.17;	author jsing;	state Exp;
branches;
next	;
commitid	y63FmUITd26yVanM;


desc
@@


1.59
log
@Use a flag to track when we need to call SSL_shutdown(). This avoids an
issue where by calling tls_close() on a TLS context that has not attempted
a handshake, results in an unexpected failure.

Reported by Vinay Sajip.

ok beck@@
@
text
@/* $OpenBSD: tls.c,v 1.58 2017/01/22 08:27:50 claudio Exp $ */
/*
 * Copyright (c) 2014 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/socket.h>

#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>

#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/x509.h>

#include <tls.h>
#include "tls_internal.h"

static struct tls_config *tls_config_default;

int
tls_init(void)
{
	static int tls_initialised = 0;

	if (tls_initialised)
		return (0);

	SSL_load_error_strings();
	SSL_library_init();

	if (BIO_sock_init() != 1)
		return (-1);

	if ((tls_config_default = tls_config_new()) == NULL)
		return (-1);

	tls_initialised = 1;

	return (0);
}

const char *
tls_error(struct tls *ctx)
{
	return ctx->error.msg;
}

void
tls_error_clear(struct tls_error *error)
{
	free(error->msg);
	error->msg = NULL;
	error->num = 0;
	error->tls = 0;
}

static int
tls_error_vset(struct tls_error *error, int errnum, const char *fmt, va_list ap)
{
	char *errmsg = NULL;
	int rv = -1;

	tls_error_clear(error);

	error->num = errnum;
	error->tls = 1;

	if (vasprintf(&errmsg, fmt, ap) == -1) {
		errmsg = NULL;
		goto err;
	}

	if (errnum == -1) {
		error->msg = errmsg;
		return (0);
	}

	if (asprintf(&error->msg, "%s: %s", errmsg, strerror(errnum)) == -1) {
		error->msg = NULL;
		goto err;
	}
	rv = 0;

 err:
	free(errmsg);

	return (rv);
}

int
tls_error_set(struct tls_error *error, const char *fmt, ...)
{
	va_list ap;
	int errnum, rv;

	errnum = errno;

	va_start(ap, fmt);
	rv = tls_error_vset(error, errnum, fmt, ap);
	va_end(ap);

	return (rv);
}

int
tls_error_setx(struct tls_error *error, const char *fmt, ...)
{
	va_list ap;
	int rv;

	va_start(ap, fmt);
	rv = tls_error_vset(error, -1, fmt, ap);
	va_end(ap);

	return (rv);
}

int
tls_config_set_error(struct tls_config *config, const char *fmt, ...)
{
	va_list ap;
	int errnum, rv;

	errnum = errno;

	va_start(ap, fmt);
	rv = tls_error_vset(&config->error, errnum, fmt, ap);
	va_end(ap);

	return (rv);
}

int
tls_config_set_errorx(struct tls_config *config, const char *fmt, ...)
{
	va_list ap;
	int rv;

	va_start(ap, fmt);
	rv = tls_error_vset(&config->error, -1, fmt, ap);
	va_end(ap);

	return (rv);
}

int
tls_set_error(struct tls *ctx, const char *fmt, ...)
{
	va_list ap;
	int errnum, rv;

	errnum = errno;

	va_start(ap, fmt);
	rv = tls_error_vset(&ctx->error, errnum, fmt, ap);
	va_end(ap);

	return (rv);
}

int
tls_set_errorx(struct tls *ctx, const char *fmt, ...)
{
	va_list ap;
	int rv;

	va_start(ap, fmt);
	rv = tls_error_vset(&ctx->error, -1, fmt, ap);
	va_end(ap);

	return (rv);
}

int
tls_set_ssl_errorx(struct tls *ctx, const char *fmt, ...)
{
	va_list ap;
	int rv;

	/* Only set an error if a more specific one does not already exist. */
	if (ctx->error.tls != 0)
		return (0);

	va_start(ap, fmt);
	rv = tls_error_vset(&ctx->error, -1, fmt, ap);
	va_end(ap);

	return (rv);
}

struct tls_sni_ctx *
tls_sni_ctx_new(void)
{
	return (calloc(1, sizeof(struct tls_sni_ctx)));
}

void
tls_sni_ctx_free(struct tls_sni_ctx *sni_ctx)
{
	if (sni_ctx == NULL)
		return;

	SSL_CTX_free(sni_ctx->ssl_ctx);
	X509_free(sni_ctx->ssl_cert);

	free(sni_ctx);
}

struct tls *
tls_new(void)
{
	struct tls *ctx;

	if ((ctx = calloc(1, sizeof(*ctx))) == NULL)
		return (NULL);

	ctx->config = tls_config_default;

	tls_reset(ctx);

	return (ctx);
}

int
tls_configure(struct tls *ctx, struct tls_config *config)
{
	if (config == NULL)
		config = tls_config_default;

	ctx->config = config;

	if ((ctx->flags & TLS_SERVER) != 0)
		return (tls_configure_server(ctx));

	return (0);
}

int
tls_configure_ssl_keypair(struct tls *ctx, SSL_CTX *ssl_ctx,
    struct tls_keypair *keypair, int required)
{
	EVP_PKEY *pkey = NULL;
	X509 *cert = NULL;
	BIO *bio = NULL;

	if (!required &&
	    keypair->cert_mem == NULL &&
	    keypair->key_mem == NULL)
		return(0);

	if (keypair->cert_mem != NULL) {
		if (keypair->cert_len > INT_MAX) {
			tls_set_errorx(ctx, "certificate too long");
			goto err;
		}

		if (SSL_CTX_use_certificate_chain_mem(ssl_ctx,
		    keypair->cert_mem, keypair->cert_len) != 1) {
			tls_set_errorx(ctx, "failed to load certificate");
			goto err;
		}
		cert = NULL;
	}
	if (keypair->key_mem != NULL) {
		if (keypair->key_len > INT_MAX) {
			tls_set_errorx(ctx, "key too long");
			goto err;
		}

		if ((bio = BIO_new_mem_buf(keypair->key_mem,
		    keypair->key_len)) == NULL) {
			tls_set_errorx(ctx, "failed to create buffer");
			goto err;
		}
		if ((pkey = PEM_read_bio_PrivateKey(bio, NULL, NULL,
		    NULL)) == NULL) {
			tls_set_errorx(ctx, "failed to read private key");
			goto err;
		}
		if (SSL_CTX_use_PrivateKey(ssl_ctx, pkey) != 1) {
			tls_set_errorx(ctx, "failed to load private key");
			goto err;
		}
		BIO_free(bio);
		bio = NULL;
		EVP_PKEY_free(pkey);
		pkey = NULL;
	}

	if (SSL_CTX_check_private_key(ssl_ctx) != 1) {
		tls_set_errorx(ctx, "private/public key mismatch");
		goto err;
	}

	return (0);

 err:
	EVP_PKEY_free(pkey);
	X509_free(cert);
	BIO_free(bio);

	return (1);
}

int
tls_configure_ssl(struct tls *ctx, SSL_CTX *ssl_ctx)
{
	SSL_CTX_set_mode(ssl_ctx, SSL_MODE_ENABLE_PARTIAL_WRITE);
	SSL_CTX_set_mode(ssl_ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);

	SSL_CTX_set_options(ssl_ctx, SSL_OP_NO_SSLv2);
	SSL_CTX_set_options(ssl_ctx, SSL_OP_NO_SSLv3);

	SSL_CTX_clear_options(ssl_ctx, SSL_OP_NO_TLSv1);
	SSL_CTX_clear_options(ssl_ctx, SSL_OP_NO_TLSv1_1);
	SSL_CTX_clear_options(ssl_ctx, SSL_OP_NO_TLSv1_2);

	if ((ctx->config->protocols & TLS_PROTOCOL_TLSv1_0) == 0)
		SSL_CTX_set_options(ssl_ctx, SSL_OP_NO_TLSv1);
	if ((ctx->config->protocols & TLS_PROTOCOL_TLSv1_1) == 0)
		SSL_CTX_set_options(ssl_ctx, SSL_OP_NO_TLSv1_1);
	if ((ctx->config->protocols & TLS_PROTOCOL_TLSv1_2) == 0)
		SSL_CTX_set_options(ssl_ctx, SSL_OP_NO_TLSv1_2);

	if (ctx->config->alpn != NULL) {
		if (SSL_CTX_set_alpn_protos(ssl_ctx, ctx->config->alpn,
		    ctx->config->alpn_len) != 0) {
			tls_set_errorx(ctx, "failed to set alpn");
			goto err;
		}
	}

	if (ctx->config->ciphers != NULL) {
		if (SSL_CTX_set_cipher_list(ssl_ctx,
		    ctx->config->ciphers) != 1) {
			tls_set_errorx(ctx, "failed to set ciphers");
			goto err;
		}
	}

	if (ctx->config->verify_time == 0) {
		X509_VERIFY_PARAM_set_flags(ssl_ctx->param,
		    X509_V_FLAG_NO_CHECK_TIME);
	}

	/* Disable any form of session caching by default */
	SSL_CTX_set_session_cache_mode(ssl_ctx, SSL_SESS_CACHE_OFF);
	SSL_CTX_set_options(ssl_ctx, SSL_OP_NO_TICKET);

	return (0);

 err:
	return (-1);
}

static int
tls_ssl_cert_verify_cb(X509_STORE_CTX *x509_ctx, void *arg)
{
	struct tls *ctx = arg;
	int x509_err;

	if (ctx->config->verify_cert == 0)
		return (1);

	if ((X509_verify_cert(x509_ctx)) < 0) {
		tls_set_errorx(ctx, "X509 verify cert failed");
		return (0);
	}

	x509_err = X509_STORE_CTX_get_error(x509_ctx);
	if (x509_err == X509_V_OK)
		return (1);

	tls_set_errorx(ctx, "certificate verification failed: %s",
	    X509_verify_cert_error_string(x509_err));

	return (0);
}

int
tls_configure_ssl_verify(struct tls *ctx, SSL_CTX *ssl_ctx, int verify)
{
	size_t ca_len = ctx->config->ca_len;
	char *ca_mem = ctx->config->ca_mem;
	char *ca_free = NULL;
	int rv = -1;

	SSL_CTX_set_verify(ssl_ctx, verify, NULL);
	SSL_CTX_set_cert_verify_callback(ssl_ctx, tls_ssl_cert_verify_cb, ctx);

	if (ctx->config->verify_depth >= 0)
		SSL_CTX_set_verify_depth(ssl_ctx, ctx->config->verify_depth);

	if (ctx->config->verify_cert == 0)
		goto done;

	/* If no CA has been specified, attempt to load the default. */
	if (ctx->config->ca_mem == NULL && ctx->config->ca_path == NULL) {
		if (tls_config_load_file(&ctx->error, "CA", _PATH_SSL_CA_FILE,
		    &ca_mem, &ca_len) != 0)
			goto err;
		ca_free = ca_mem;
	}

	if (ca_mem != NULL) {
		if (ca_len > INT_MAX) {
			tls_set_errorx(ctx, "ca too long");
			goto err;
		}
		if (SSL_CTX_load_verify_mem(ssl_ctx, ca_mem, ca_len) != 1) {
			tls_set_errorx(ctx, "ssl verify memory setup failure");
			goto err;
		}
	} else if (SSL_CTX_load_verify_locations(ssl_ctx, NULL,
	    ctx->config->ca_path) != 1) {
		tls_set_errorx(ctx, "ssl verify locations failure");
		goto err;
	}

 done:
	rv = 0;

 err:
	free(ca_free);

	return (rv);
}

void
tls_free(struct tls *ctx)
{
	if (ctx == NULL)
		return;

	tls_reset(ctx);

	free(ctx);
}

void
tls_reset(struct tls *ctx)
{
	struct tls_sni_ctx *sni, *nsni;

	SSL_CTX_free(ctx->ssl_ctx);
	SSL_free(ctx->ssl_conn);
	X509_free(ctx->ssl_peer_cert);

	ctx->ssl_conn = NULL;
	ctx->ssl_ctx = NULL;
	ctx->ssl_peer_cert = NULL;

	ctx->socket = -1;
	ctx->state = 0;

	free(ctx->servername);
	ctx->servername = NULL;

	free(ctx->error.msg);
	ctx->error.msg = NULL;
	ctx->error.num = -1;

	tls_conninfo_free(ctx->conninfo);
	ctx->conninfo = NULL;

	tls_ocsp_free(ctx->ocsp);
	ctx->ocsp = NULL;

	for (sni = ctx->sni_ctx; sni != NULL; sni = nsni) {
		nsni = sni->next;
		tls_sni_ctx_free(sni);
	}
	ctx->sni_ctx = NULL;

	ctx->read_cb = NULL;
	ctx->write_cb = NULL;
	ctx->cb_arg = NULL;
}

int
tls_ssl_error(struct tls *ctx, SSL *ssl_conn, int ssl_ret, const char *prefix)
{
	const char *errstr = "unknown error";
	unsigned long err;
	int ssl_err;

	ssl_err = SSL_get_error(ssl_conn, ssl_ret);
	switch (ssl_err) {
	case SSL_ERROR_NONE:
	case SSL_ERROR_ZERO_RETURN:
		return (0);

	case SSL_ERROR_WANT_READ:
		return (TLS_WANT_POLLIN);

	case SSL_ERROR_WANT_WRITE:
		return (TLS_WANT_POLLOUT);

	case SSL_ERROR_SYSCALL:
		if ((err = ERR_peek_error()) != 0) {
			errstr = ERR_error_string(err, NULL);
		} else if (ssl_ret == 0) {
			if ((ctx->state & TLS_HANDSHAKE_COMPLETE) != 0) {
				ctx->state |= TLS_EOF_NO_CLOSE_NOTIFY;
				return (0);
			}
			errstr = "unexpected EOF";
		} else if (ssl_ret == -1) {
			errstr = strerror(errno);
		}
		tls_set_ssl_errorx(ctx, "%s failed: %s", prefix, errstr);
		return (-1);

	case SSL_ERROR_SSL:
		if ((err = ERR_peek_error()) != 0) {
			errstr = ERR_error_string(err, NULL);
		}
		tls_set_ssl_errorx(ctx, "%s failed: %s", prefix, errstr);
		return (-1);

	case SSL_ERROR_WANT_CONNECT:
	case SSL_ERROR_WANT_ACCEPT:
	case SSL_ERROR_WANT_X509_LOOKUP:
	default:
		tls_set_ssl_errorx(ctx, "%s failed (%i)", prefix, ssl_err);
		return (-1);
	}
}

int
tls_handshake(struct tls *ctx)
{
	int rv = -1;

	tls_error_clear(&ctx->error);

	if ((ctx->flags & (TLS_CLIENT | TLS_SERVER_CONN)) == 0) {
		tls_set_errorx(ctx, "invalid operation for context");
		goto out;
	}

	if ((ctx->flags & TLS_CLIENT) != 0)
		rv = tls_handshake_client(ctx);
	else if ((ctx->flags & TLS_SERVER_CONN) != 0)
		rv = tls_handshake_server(ctx);

	if (rv == 0) {
		ctx->ssl_peer_cert = SSL_get_peer_certificate(ctx->ssl_conn);
		if (tls_conninfo_populate(ctx) == -1)
		    rv = -1;
		if (ctx->ocsp == NULL)
			ctx->ocsp = tls_ocsp_setup_from_peer(ctx);
	}
 out:
	/* Prevent callers from performing incorrect error handling */
	errno = 0;
	return (rv);
}

ssize_t
tls_read(struct tls *ctx, void *buf, size_t buflen)
{
	ssize_t rv = -1;
	int ssl_ret;

	tls_error_clear(&ctx->error);

	if ((ctx->state & TLS_HANDSHAKE_COMPLETE) == 0) {
		if ((rv = tls_handshake(ctx)) != 0)
			goto out;
	}

	if (buflen > INT_MAX) {
		tls_set_errorx(ctx, "buflen too long");
		goto out;
	}

	ERR_clear_error();
	if ((ssl_ret = SSL_read(ctx->ssl_conn, buf, buflen)) > 0) {
		rv = (ssize_t)ssl_ret;
		goto out;
	}
	rv = (ssize_t)tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "read");

 out:
	/* Prevent callers from performing incorrect error handling */
	errno = 0;
	return (rv);
}

ssize_t
tls_write(struct tls *ctx, const void *buf, size_t buflen)
{
	ssize_t rv = -1;
	int ssl_ret;

	tls_error_clear(&ctx->error);

	if ((ctx->state & TLS_HANDSHAKE_COMPLETE) == 0) {
		if ((rv = tls_handshake(ctx)) != 0)
			goto out;
	}

	if (buflen > INT_MAX) {
		tls_set_errorx(ctx, "buflen too long");
		goto out;
	}

	ERR_clear_error();
	if ((ssl_ret = SSL_write(ctx->ssl_conn, buf, buflen)) > 0) {
		rv = (ssize_t)ssl_ret;
		goto out;
	}
	rv = (ssize_t)tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "write");

 out:
	/* Prevent callers from performing incorrect error handling */
	errno = 0;
	return (rv);
}

int
tls_close(struct tls *ctx)
{
	int ssl_ret;
	int rv = 0;

	tls_error_clear(&ctx->error);

	if ((ctx->flags & (TLS_CLIENT | TLS_SERVER_CONN)) == 0) {
		tls_set_errorx(ctx, "invalid operation for context");
		rv = -1;
		goto out;
	}

	if (ctx->state & TLS_SSL_NEEDS_SHUTDOWN) {
		ERR_clear_error();
		ssl_ret = SSL_shutdown(ctx->ssl_conn);
		if (ssl_ret < 0) {
			rv = tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret,
			    "shutdown");
			if (rv == TLS_WANT_POLLIN || rv == TLS_WANT_POLLOUT)
				goto out;
		}
		ctx->state &= ~TLS_SSL_NEEDS_SHUTDOWN;
	}

	if (ctx->socket != -1) {
		if (shutdown(ctx->socket, SHUT_RDWR) != 0) {
			if (rv == 0 &&
			    errno != ENOTCONN && errno != ECONNRESET) {
				tls_set_error(ctx, "shutdown");
				rv = -1;
			}
		}
		if (close(ctx->socket) != 0) {
			if (rv == 0) {
				tls_set_error(ctx, "close");
				rv = -1;
			}
		}
		ctx->socket = -1;
	}

	if ((ctx->state & TLS_EOF_NO_CLOSE_NOTIFY) != 0) {
		tls_set_errorx(ctx, "EOF without close notify");
		rv = -1;
	}

 out:
	/* Prevent callers from performing incorrect error handling */
	errno = 0;
	return (rv);
}
@


1.58
log
@Disable session cache and tickets by default.
OK beck@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.57 2017/01/13 17:09:51 deraadt Exp $ */
d652 1
a652 1
	if (ctx->ssl_conn != NULL) {
d661 1
@


1.57
log
@whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.56 2017/01/03 17:19:57 jsing Exp $ */
d361 4
@


1.56
log
@If certificate verification has been disabled, do not attempt to load a
CA chain or specify CA paths. This prevents attempts to access the file
system, which may fail due to pledge.

ok bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.55 2017/01/03 17:13:41 jsing Exp $ */
d560 1
a560 1
		ctx->ssl_peer_cert =  SSL_get_peer_certificate(ctx->ssl_conn);
d626 1
a626 1
	rv =  (ssize_t)tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "write");
@


1.55
log
@Revert previous - the original code was correct since X509_verify_cert()
should not have changed the X509_STORE_CTX error value on success and it
was initialised to X509_V_OK by X509_STORE_CTX_init(). Other software also
depends on this behaviour.

Previously X509_verify_cert() was mishandling the X509_STORE_CTX error
value when validating alternate chains. This has been fixed and further
changes now explicitly ensure that the error value will be set to X509_V_OK
if X509_verify_cert() returns success.
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.53 2016/12/26 16:20:58 jsing Exp $ */
d401 7
a430 4
	if (ctx->config->verify_depth >= 0)
		SSL_CTX_set_verify_depth(ssl_ctx, ctx->config->verify_depth);

	SSL_CTX_set_cert_verify_callback(ssl_ctx, tls_ssl_cert_verify_cb, ctx);
d432 1
@


1.54
log
@fix cert verify. a cert with an alt chain may verify but leave an error
in the context. don't look for errors in case of success.
fixes spurious verify errors.
guilty change tracked and fix tested by sthen
@
text
@d372 1
a372 1
	int x509_err, rv;
d377 1
a377 1
	if ((rv = X509_verify_cert(x509_ctx)) < 0) {
a380 2
	if (rv == 1)
		return 1;
d383 2
@


1.53
log
@Hook up a certificate verify callback so that we can set user friendly
error messages, instead of libssl error strings. This gives us messages
like:

  certificate verification failed: certificate has expired

Instead of:

  14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed

This also lets us always enable peer verification since the no verification
case is now handled via the callback.

Tested by tedu@@

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.52 2016/11/05 14:50:05 beck Exp $ */
d372 1
a372 1
	int x509_err;
d377 1
a377 1
	if ((X509_verify_cert(x509_ctx)) < 0) {
d381 2
a384 2
	if (x509_err == X509_V_OK)
		return (1);
@


1.52
log
@rename ocsp_ctx to ocsp
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.51 2016/11/03 10:05:32 jsing Exp $ */
d368 24
d398 1
d427 1
a427 1
	free(ca_free);
d429 1
a429 1
	return (0);
d434 1
a434 1
	return (-1);
@


1.51
log
@Only set an error from libssl related code, if an error has not already
been set by libtls code. This avoids the situation where a libtls callback
has set an error, only to have it replaced by a less useful libssl based
error.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.50 2016/11/02 15:18:42 beck Exp $ */
d449 3
a451 3
	tls_ocsp_ctx_free(ctx->ocsp_ctx);
	ctx->ocsp_ctx = NULL;
	
d534 2
a535 2
		if (ctx->ocsp_ctx == NULL)
			ctx->ocsp_ctx = tls_ocsp_setup_from_peer(ctx);
@


1.50
log
@Add OCSP client side support to libtls.
   - Provide access to certificate OCSP URL
   - Provide ability to check a raw OCSP reply against an
     established TLS ctx
   - Check and validate OCSP stapling info in the TLS handshake
     if a stapled OCSP response is provided.`

Add example code to show OCSP URL and stapled info
into netcat.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.49 2016/09/04 12:26:43 bcook Exp $ */
d64 9
d79 2
a80 2
	free(error->msg);
	error->msg = NULL;
d82 1
d190 17
d494 1
a494 1
		tls_set_errorx(ctx, "%s failed: %s", prefix, errstr);
d501 1
a501 1
		tls_set_errorx(ctx, "%s failed: %s", prefix, errstr);
d508 1
a508 1
		tls_set_errorx(ctx, "%s failed (%i)", prefix, ssl_err);
d518 2
d549 2
d580 2
d610 2
@


1.49
log
@Add callback-based interface to libtls.

This allows working with buffers and callback functions instead of directly on
sockets or file descriptors.
Original patch from Tobias Pape <tobias_at_netshed.de>.
ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.48 2016/08/22 17:12:35 jsing Exp $ */
d422 3
d505 2
@


1.48
log
@Various clean up and reorganisation of the connection info handling code.
In particular, rename tls_free_conninfo() to tls_conninfo_free() and make
it a real free function. Rename tls_get_conninfo() to
tls_conninfo_populate() and have it allocate the struct tls_conninfo (after
freeing any existing one).

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.47 2016/08/22 14:51:37 jsing Exp $ */
d427 4
@


1.47
log
@Create contexts for server side SNI - these include the additional SSL_CTX
that is required for certificate switching with libssl and the certificate
itself so that we can match against the subject and SANs. Hook up the
servername callback and switch to the appropriate SSL_CTX if we find a
matching certificate.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.46 2016/08/15 14:04:23 jsing Exp $ */
d390 1
d392 1
d419 1
a419 2
	tls_free_conninfo(ctx->conninfo);
	free(ctx->conninfo);
a488 4
	if (ctx->conninfo == NULL &&
	    (ctx->conninfo = calloc(1, sizeof(*ctx->conninfo))) == NULL)
		goto out;

d496 1
a496 1
		if (tls_get_conninfo(ctx) == -1)
@


1.46
log
@Explicitly pass in an SSL_CTX * to the functions that operate on one,
instead of assuming that they should use the one associated with the TLS
context. This allows these functions to be used with the additional
SSL contexts that are needed to support server-side SNI.

Also rename tls_configure_keypair() to tls_configure_ssl_keypair(), so that
these functions have a common prefix.

ok reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.45 2016/08/13 13:05:51 jsing Exp $ */
d180 18
d397 2
d420 6
@


1.45
log
@Load CA, certificate and key files into memory when the appropriate
tls_config_set_*_file() function is called. This allows us to immediately
propagate useful error messages, play more nicely with privsep/pledge and
have a single code path. Instead of always loading the default CA when
tls_config_new() is called, defer and only load the default CA when
tls_configure() is invoked, if a CA has not already been specified.

ok beck@@ bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.44 2016/08/12 15:10:59 jsing Exp $ */
d210 1
a210 1
tls_configure_keypair(struct tls *ctx, SSL_CTX *ssl_ctx,
d277 1
a277 1
tls_configure_ssl(struct tls *ctx)
d279 2
a280 2
	SSL_CTX_set_mode(ctx->ssl_ctx, SSL_MODE_ENABLE_PARTIAL_WRITE);
	SSL_CTX_set_mode(ctx->ssl_ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
d282 2
a283 2
	SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_SSLv2);
	SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_SSLv3);
d285 3
a287 3
	SSL_CTX_clear_options(ctx->ssl_ctx, SSL_OP_NO_TLSv1);
	SSL_CTX_clear_options(ctx->ssl_ctx, SSL_OP_NO_TLSv1_1);
	SSL_CTX_clear_options(ctx->ssl_ctx, SSL_OP_NO_TLSv1_2);
d290 1
a290 1
		SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_TLSv1);
d292 1
a292 1
		SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_TLSv1_1);
d294 1
a294 1
		SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_NO_TLSv1_2);
d297 1
a297 1
		if (SSL_CTX_set_alpn_protos(ctx->ssl_ctx, ctx->config->alpn,
d305 1
a305 1
		if (SSL_CTX_set_cipher_list(ctx->ssl_ctx,
d313 1
a313 1
		X509_VERIFY_PARAM_set_flags(ctx->ssl_ctx->param,
d324 1
a324 1
tls_configure_ssl_verify(struct tls *ctx, int verify)
d330 1
a330 1
	SSL_CTX_set_verify(ctx->ssl_ctx, verify, NULL);
d345 1
a345 2
		if (SSL_CTX_load_verify_mem(ctx->ssl_ctx, ca_mem,
		    ca_len) != 1) {
d349 1
a349 1
	} else if (SSL_CTX_load_verify_locations(ctx->ssl_ctx, NULL,
d355 1
a355 2
		SSL_CTX_set_verify_depth(ctx->ssl_ctx,
		    ctx->config->verify_depth);
@


1.44
log
@Add ALPN support to libtls.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.43 2016/08/02 07:47:11 jsing Exp $ */
d219 1
a219 3
	    keypair->key_mem == NULL &&
	    keypair->cert_file == NULL &&
	    keypair->key_file == NULL)
a260 15
	if (keypair->cert_file != NULL) {
		if (SSL_CTX_use_certificate_chain_file(ssl_ctx,
		    keypair->cert_file) != 1) {
			tls_set_errorx(ctx, "failed to load certificate file");
			goto err;
		}
	}
	if (keypair->key_file != NULL) {
		if (SSL_CTX_use_PrivateKey_file(ssl_ctx,
		    keypair->key_file, SSL_FILETYPE_PEM) != 1) {
			tls_set_errorx(ctx, "failed to load private key file");
			goto err;
		}
	}

d326 4
d332 10
a341 3
	if (ctx->config->ca_mem != NULL) {
		/* XXX do this in set. */
		if (ctx->config->ca_len > INT_MAX) {
d345 2
a346 2
		if (SSL_CTX_load_verify_mem(ctx->ssl_ctx,
		    ctx->config->ca_mem, ctx->config->ca_len) != 1) {
d350 3
a352 3
	} else if (SSL_CTX_load_verify_locations(ctx->ssl_ctx,
	    ctx->config->ca_file, ctx->config->ca_path) != 1) {
		tls_set_errorx(ctx, "ssl verify setup failure");
d359 2
d364 2
@


1.43
log
@Revert previous since it adds new symbols.

Requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.42 2016/08/01 17:32:19 jsing Exp $ */
d312 8
@


1.42
log
@Add ALPN support to libtls.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.41 2016/07/07 14:09:03 jsing Exp $ */
a311 8

	if (ctx->config->alpn != NULL) {
		if (SSL_CTX_set_alpn_protos(ctx->ssl_ctx, ctx->config->alpn,
		    ctx->config->alpn_len) != 0) {
			tls_set_errorx(ctx, "failed to set alpn");
			goto err;
		}
	}
@


1.41
log
@Revert previous - it introduces problems with a common privsep use case.
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.40 2016/07/06 16:16:36 jsing Exp $ */
d312 8
@


1.40
log
@Always load CA, key and certificate files at the time the configuration
function is called. This simplifies code and results in a single memory
based code path being used to provide data to libssl. Errors that occur
when accessing the specified file are now detected and propagated
immediately. Since the file access now occurs when the configuration
function is called, we now play nicely with privsep/pledge.

ok beck@@ bluhm@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.39 2016/07/06 02:32:57 jsing Exp $ */
d219 3
a221 1
	    keypair->key_mem == NULL)
d263 15
d349 1
a349 1
	    NULL, ctx->config->ca_path) != 1) {
@


1.39
log
@Correctly handle an EOF that occurs prior to the TLS handshake completing.

Reported by Vasily Kolobkov, based on a diff from Marko Kreen.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.38 2016/05/27 14:38:40 jsing Exp $ */
d219 1
a219 3
	    keypair->key_mem == NULL &&
	    keypair->cert_file == NULL &&
	    keypair->key_file == NULL)
a260 15
	if (keypair->cert_file != NULL) {
		if (SSL_CTX_use_certificate_chain_file(ssl_ctx,
		    keypair->cert_file) != 1) {
			tls_set_errorx(ctx, "failed to load certificate file");
			goto err;
		}
	}
	if (keypair->key_file != NULL) {
		if (SSL_CTX_use_PrivateKey_file(ssl_ctx,
		    keypair->key_file, SSL_FILETYPE_PEM) != 1) {
			tls_set_errorx(ctx, "failed to load private key file");
			goto err;
		}
	}

d332 1
a332 1
	    ctx->config->ca_file, ctx->config->ca_path) != 1) {
@


1.38
log
@Rename some of the internal error setting functions to more closely follow
existing naming standards. Also provide functions for setting a struct
tls_error * directly (rather than having to have a struct tls * or a
struct tls_config *).
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.37 2016/04/28 17:05:59 jsing Exp $ */
d421 5
a425 2
			ctx->state |= TLS_EOF_NO_CLOSE_NOTIFY;
			return (0);
@


1.37
log
@Factor our the keypair handling in libtls. This results in more readable
and self-contained code, while preparing for the ability to handle
multiple keypairs. Also provide two additional functions that allow
a public certificate and private key to be set with a single function
call.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.36 2016/04/28 16:48:44 jsing Exp $ */
d65 1
a65 1
tls_set_verror(struct tls_error *error, int errnum, const char *fmt, va_list ap)
d97 1
a97 1
tls_set_config_error(struct tls_config *config, const char *fmt, ...)
d105 1
a105 1
	rv = tls_set_verror(&config->error, errnum, fmt, ap);
d112 1
a112 1
tls_set_config_errorx(struct tls_config *config, const char *fmt, ...)
d118 29
a146 1
	rv = tls_set_verror(&config->error, -1, fmt, ap);
d161 1
a161 1
	rv = tls_set_verror(&ctx->error, errnum, fmt, ap);
d174 1
a174 1
	rv = tls_set_verror(&ctx->error, -1, fmt, ap);
@


1.36
log
@Rework the error handling in libtls so that we can associate errors with
both configuration and contexts. This allows us to propagate errors that
occur during configuration, rather than either just failing with no reason
or delaying the failure until it can be propagated via the tls context.

Also provide a tls_config_error() function for retrieving the last error
from a tls_config *.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.35 2016/01/18 16:15:14 bcook Exp $ */
d182 2
a183 1
tls_configure_keypair(struct tls *ctx, int required)
d190 4
a193 4
	    ctx->config->cert_mem == NULL &&
	    ctx->config->key_mem == NULL &&
	    ctx->config->cert_file == NULL &&
	    ctx->config->key_file == NULL)
d196 2
a197 2
	if (ctx->config->cert_mem != NULL) {
		if (ctx->config->cert_len > INT_MAX) {
d202 2
a203 2
		if (SSL_CTX_use_certificate_chain_mem(ctx->ssl_ctx,
		    ctx->config->cert_mem, ctx->config->cert_len) != 1) {
d209 2
a210 2
	if (ctx->config->key_mem != NULL) {
		if (ctx->config->key_len > INT_MAX) {
d215 2
a216 2
		if ((bio = BIO_new_mem_buf(ctx->config->key_mem,
		    ctx->config->key_len)) == NULL) {
d225 1
a225 1
		if (SSL_CTX_use_PrivateKey(ctx->ssl_ctx, pkey) != 1) {
d235 3
a237 3
	if (ctx->config->cert_file != NULL) {
		if (SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx,
		    ctx->config->cert_file) != 1) {
d242 3
a244 3
	if (ctx->config->key_file != NULL) {
		if (SSL_CTX_use_PrivateKey_file(ctx->ssl_ctx,
		    ctx->config->key_file, SSL_FILETYPE_PEM) != 1) {
d250 1
a250 1
	if (SSL_CTX_check_private_key(ctx->ssl_ctx) != 1) {
@


1.35
log
@Call BIO_sock_init() from tls_init() to ensure sockets are enabled on Windows.

This is of course a no-op on other platforms.  Noted by equalsraf from github.
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.34 2015/10/07 23:25:45 beck Exp $ */
d61 1
a61 1
	return ctx->errmsg;
d65 1
a65 1
tls_set_verror(struct tls *ctx, int errnum, const char *fmt, va_list ap)
d70 3
a72 2
	free(ctx->errmsg);
	ctx->errmsg = NULL;
d80 1
a80 1
		ctx->errmsg = errmsg;
d84 2
a85 2
	if (asprintf(&ctx->errmsg, "%s: %s", errmsg, strerror(errnum)) == -1) {
		ctx->errmsg = NULL;
d97 28
d128 1
a128 1
	int rv;
d130 1
a130 1
	ctx->errnum = errno;
d133 1
a133 1
	rv = tls_set_verror(ctx, ctx->errnum, fmt, ap);
d146 1
a146 1
	rv = tls_set_verror(ctx, -1, fmt, ap);
d360 3
a362 3
	free(ctx->errmsg);
	ctx->errmsg = NULL;
	ctx->errnum = 0;
@


1.34
log
@Allow us to get cipher and version even if there is not a peer certificate.
ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.33 2015/09/29 10:17:04 deraadt Exp $ */
d46 3
@


1.33
log
@clean some ugly intendation warts
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.32 2015/09/14 16:16:38 jsing Exp $ */
d403 5
a407 4
	if (rv == 0 &&
	    (ctx->ssl_peer_cert = SSL_get_peer_certificate(ctx->ssl_conn)) &&
	    (tls_get_conninfo(ctx) == -1))
		rv = -1;
@


1.32
log
@Provide tls_config_insecure_noverifytime() in order to be able to disable
certificate validity checking.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.31 2015/09/14 12:29:16 jsing Exp $ */
d288 1
a288 1
            ctx->config->ca_file, ctx->config->ca_path) != 1) {
@


1.31
log
@Expose EOF without close-notify via tls_close().

Make tls_read(3)/tls_write(3) follow read(2)/write(2) like semantics and
return 0 on EOF with and without close-notify. However, if we saw an EOF
from the underlying file descriptors without getting a close-notify, save
this and make it visible when tls_close(3) is called. This keeps the
semantics we want, but makes it possible to detect truncation at higher
layers, if necessary.

ok beck@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.29 2015/09/13 15:39:15 beck Exp $ */
d258 5
@


1.30
log
@Return an error if tls_handshake() or tls_close() is called on a context
for which they are not valid operations.

ok beck@@
@
text
@d355 2
a356 1
			errstr = "EOF";
d425 1
a425 1
	if ((ssl_ret = SSL_read(ctx->ssl_conn, buf, buflen)) >= 0) {
d454 1
a454 1
	if ((ssl_ret = SSL_write(ctx->ssl_conn, buf, buflen)) >= 0) {
d505 6
@


1.29
log
@work around the stupid semantics of SSL_read and SSL_write to make sure
we can indicate an EOF properly on tls_read and tls_write
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.28 2015/09/13 13:44:07 beck Exp $ */
d383 5
d401 1
a401 1
out:
d470 6
@


1.28
log
@Don't leak conninfo - spotted by marko kreen.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.27 2015/09/12 21:00:38 beck Exp $ */
d419 1
a419 1
	if ((ssl_ret = SSL_read(ctx->ssl_conn, buf, buflen)) > 0) {
d448 1
a448 1
	if ((ssl_ret = SSL_write(ctx->ssl_conn, buf, buflen)) > 0) {
@


1.27
log
@Move connection info into it's own private structure allocated and filled in
at handshake time. change accessors to return const char * to remove need
for caller to free memory.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.26 2015/09/12 19:54:31 jsing Exp $ */
d383 2
a384 1
	if ((ctx->conninfo = calloc(1, sizeof(*ctx->conninfo))) == NULL)
@


1.26
log
@Ensure that we clear the libssl error stack before we make a function call
that we will pass the result through tls_ssl_error() on failure. Otherwise
we can end up reporting spurious errors due to their being unrelated errors
already on the error stack.

Spotted by Marko Kreen.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.25 2015/09/11 09:24:54 jsing Exp $ */
d326 4
d383 3
d391 5
a395 3
	if (rv == 0)
		ctx->ssl_peer_cert = SSL_get_peer_certificate(ctx->ssl_conn);

@


1.25
log
@Store a reference to the peer certificate (if any) upon completion of the
handshake. Free the reference when we reset the TLS context.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.24 2015/09/10 18:43:03 jsing Exp $ */
d408 1
d413 1
a414 1
	rv = (ssize_t)tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "read");
d437 1
d442 1
a443 1
	rv =  (ssize_t)tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "write");
d457 1
@


1.24
log
@Call tls_set_errorx() instead of tls_set_error() in
tls_configure_ssl_verify(). Also tweak an error message and unwrap a line.
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.23 2015/09/10 10:59:22 beck Exp $ */
d311 1
d315 1
d383 3
@


1.23
log
@comment for errno clobbering, to indicate why we do this.
ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.22 2015/09/10 10:26:49 beck Exp $ */
d274 1
a274 1
			tls_set_error(ctx, "client ca too long");
d279 1
a279 2
			tls_set_error(ctx,
			    "ssl verify memory setup failure");
d284 1
a284 1
		tls_set_error(ctx, "ssl verify setup failure");
d290 1
@


1.22
log
@change TLS_READ_AGAIN to TLS_WANT_POLLIN and TLS_WRITE_AGAIN to TLS_WANT_POLLOUT
to make it more clear to users of this api what needs to be done in these error
cases.
Discussed extensively with bluhm@@ and jsing@@ and others.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.21 2015/09/10 10:22:28 beck Exp $ */
d382 1
d410 1
d438 1
d476 1
@


1.21
log
@Change tls_read and tls_write semantics to return an ssize_t to better
match read() and write() semantics to make porting existing code using
read/write easier.. requested by bluhm@@ who convinced jsing and I to break
the api

ok jsing@@ bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.20 2015/09/10 10:14:20 jsing Exp $ */
d340 1
a340 1
		return (TLS_READ_AGAIN);
d343 1
a343 1
		return (TLS_WRITE_AGAIN);
d451 1
a451 1
			if (rv == TLS_READ_AGAIN || rv == TLS_WRITE_AGAIN)
@


1.20
log
@Split tls_handshake() out from tls_accept/tls_connect. By doing this the
tls_accept/tls_connect functions can be guaranteed to succeed or fail and
will no longer return TLS_READ_AGAIN/TLS_WRITE_AGAIN. This also resolves
the semantics of tls_accept_*.

The tls_handshake() function now does I/O and can return
TLS_READ_AGAIN/TLS_WRITE_AGAIN. Calls to tls_read() and tls_write() will
trigger the handshake if it has not already completed, meaning that in many
cases existing code will continue to work.

Discussed over many coffees at l2k15.

ok beck@@ bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.19 2015/09/09 19:49:07 jsing Exp $ */
d386 2
a387 2
int
tls_read(struct tls *ctx, void *buf, size_t buflen, size_t *outlen)
d389 1
a390 3
	int rv = -1;

	*outlen = 0;
d403 1
a403 2
		*outlen = (size_t)ssl_ret;
		rv = 0;
d407 1
a407 1
	rv = tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "read");
d413 2
a414 2
int
tls_write(struct tls *ctx, const void *buf, size_t buflen, size_t *outlen)
d416 1
a417 3
	int rv = -1;

	*outlen = 0;
d430 1
a430 2
		*outlen = (size_t)ssl_ret;
		rv = 0;
d434 1
a434 1
	rv =  tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "write");
@


1.19
log
@Indent labels with a space so that diff -p is more friendly.

Requested by bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.18 2015/09/09 19:23:04 beck Exp $ */
d318 3
d373 14
d394 5
d404 1
a404 2
	ssl_ret = SSL_read(ctx->ssl_conn, buf, buflen);
	if (ssl_ret > 0) {
d424 5
d434 1
a434 2
	ssl_ret = SSL_write(ctx->ssl_conn, buf, buflen);
	if (ssl_ret > 0) {
@


1.18
log
@Add client certificate support. Still needs a few tweaks but this will
ride upcoming minor bump
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.17 2015/09/09 18:22:33 beck Exp $ */
d86 1
a86 1
err:
d224 1
a224 1
err:
d262 1
a262 1
err:
@


1.17
log
@always clear errno when coming back from tls_read tls_write, and tls_close.

this avoids the problem of people checking for return values < 0
and then checking for errno before checking for TLS_READ_AGAIN
TLS_WRITE_AGAIN - since we can not guarantee what errno will be
set to from the underlying library calls
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.16 2015/09/09 17:43:42 beck Exp $ */
d150 1
a150 1
tls_configure_keypair(struct tls *ctx)
d156 7
d263 31
@


1.16
log
@nuke trailing whitespace
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.15 2015/08/27 15:26:49 jsing Exp $ */
d335 1
d341 1
a341 1
		return (-1);
d347 2
a348 1
		return (0);
d351 4
a354 1
	return tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "read");
d361 1
d367 1
a367 1
		return (-1);
d373 2
a374 1
		return (0);
d377 4
a380 1
	return tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "write");
d395 1
a395 1
				return (rv);
d415 2
a416 1

@


1.15
log
@Improve libtls error messages.

The tls_set_error() function previously stored the errno but did nothing
with it. Change tls_set_error() to append the strerror(3) of the stored
errno so that we include useful information regarding failures.

Provide a tls_set_errorx() function that does not store the errno or
include strerror(3) in the error message. Call this function instead of
tls_set_error() for errors where the errno value has no useful meaning.

With feedback from and ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.14 2015/08/27 14:34:46 jsing Exp $ */
a83 1
	
d349 1
a349 1
	return tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "read"); 
d370 1
a370 1
	return tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "write"); 
@


1.14
log
@Split the persistent/configuration flags from temporary state flags and
ensure that the temporary state flags get cleared in tls_reset(). Fixes a
bug spotted by Marko Kreen whereby TLS_CONNECTING could remain on reset.

While here, also move the TLS_STATE_CONNECTING check to after the
TLS_CLIENT check - if TLS_STATE_CONNECTING was ever set on any other
context type it would allow a bypass.

ok bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.13 2015/08/22 14:20:53 jsing Exp $ */
d61 32
d94 1
a94 1
tls_set_error(struct tls *ctx, char *fmt, ...)
d99 14
a112 3
	ctx->err = errno;
	free(ctx->errmsg);
	ctx->errmsg = NULL;
d115 1
a115 1
	rv = vasprintf(&ctx->errmsg, fmt, ap);
d159 1
a159 1
			tls_set_error(ctx, "certificate too long");
d165 1
a165 1
			tls_set_error(ctx, "failed to load certificate");
d172 1
a172 1
			tls_set_error(ctx, "key too long");
d178 1
a178 1
			tls_set_error(ctx, "failed to create buffer");
d183 1
a183 1
			tls_set_error(ctx, "failed to read private key");
d187 1
a187 1
			tls_set_error(ctx, "failed to load private key");
d199 1
a199 1
			tls_set_error(ctx, "failed to load certificate file");
d206 1
a206 1
			tls_set_error(ctx, "failed to load private key file");
d212 1
a212 1
		tls_set_error(ctx, "private/public key mismatch");
d249 1
a249 1
			tls_set_error(ctx, "failed to set ciphers");
a280 1
	ctx->err = 0;
d283 1
d313 1
a313 1
		tls_set_error(ctx, "%s failed: %s", prefix, errstr);
d320 1
a320 1
		tls_set_error(ctx, "%s failed: %s", prefix, errstr);
d327 1
a327 1
		tls_set_error(ctx, "%s failed (%i)", prefix, ssl_err);
d340 1
a340 1
		tls_set_error(ctx, "buflen too long");
d361 1
a361 1
		tls_set_error(ctx, "buflen too long");
@


1.13
log
@Make tls_read()/tls_write always set outlen to zero on error - this got
broken by r1.4.

Spotted by Marko Kreen.
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.12 2015/07/18 22:15:09 bluhm Exp $ */
d236 1
@


1.12
log
@Set SSL_MODE_ENABLE_PARTIAL_WRITE and SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER
in libtls.  This gives tls_write() a similar short write semantics
as write(2).  So implementing daemons with libevent buffers will
be easier and workarounds in syslogd and httpd can be removed.
OK tedu@@ beck@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.11 2015/04/15 16:08:43 jsing Exp $ */
d293 2
a305 2
	*outlen = 0;

d314 2
a325 2

	*outlen = 0;
@


1.11
log
@Treat SSL_ERROR_ZERO_RETURN as a success, rather than a failure. Also
ensure that outlen is set to zero so that tls_read() has read(2) like
semantics for EOF.

Spotted by doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.9 2015/04/02 13:19:15 jsing Exp $ */
d186 3
@


1.10
log
@Make tls_close() more robust - do not rely on a close notify being received
from the other side and only return TLS_READ_AGAIN/TLS_WRITE_AGAIN if we
failed to send a close notify on a non-blocking socket.

Otherwise be more forceful and always shutdown/close the socket regardless
of other failures. Also do not consider ENOTCONN or ECONNRESET to be a
shutdown failure, since there are various situations where this can occur.

ok doug@@ guenther@@
@
text
@d249 1
a251 4
	case SSL_ERROR_ZERO_RETURN:
		tls_set_error(ctx, "%s failed: TLS connection closed", prefix);
		return (-1);

d301 2
d321 2
@


1.9
log
@Handle the case where multiple calls to SSL_shutdown() are required to
close the connection. Also correctly handle the error on failure.

Diff from cookieandscream via github.
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.8 2015/03/31 12:21:27 jsing Exp $ */
d330 1
d334 2
a335 4
		if (ssl_ret == 0)
			ssl_ret = SSL_shutdown(ctx->ssl_conn);
		if (ssl_ret < 0)
			return tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret,
d337 3
d344 5
a348 2
			tls_set_error(ctx, "shutdown");
			goto err;
d351 4
a354 2
			tls_set_error(ctx, "close");
			goto err;
d359 1
a359 4
	return (0);

err:
	return (-1);
@


1.8
log
@Store errors that occur during a tls_accept_socket() call on the context
for the server, rather than on the context for the connection. This makes
more sense than the current behaviour does.

Issue reported by Tim van der Molen.
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.7 2015/02/07 09:50:09 jsing Exp $ */
d329 2
a330 1
	/* XXX - handle case where multiple calls are required. */
d332 6
a337 4
		if (SSL_shutdown(ctx->ssl_conn) == -1) {
			tls_set_error(ctx, "SSL shutdown failed");
			goto err;
		}
@


1.7
log
@Convert tls_connect_fds() and tls_accept_socket() to the new OpenSSL error
dance handling code. This means that we get slightly useful messages when
a TLS connection or accept fails.

Requested by reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.6 2015/02/07 04:33:51 jsing Exp $ */
d240 1
a240 1
tls_ssl_error(struct tls *ctx, int ssl_ret, const char *prefix)
d246 1
a246 1
	ssl_err = SSL_get_error(ctx->ssl_conn, ssl_ret);
d304 1
a304 1
	return tls_ssl_error(ctx, ssl_ret, "read"); 
d323 1
a323 1
	return tls_ssl_error(ctx, ssl_ret, "write"); 
@


1.6
log
@Attempt to implement the OpenSSL error dance so that TLS read/write
failures return something that is actually useful to the caller.

ok reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.5 2015/02/06 01:37:11 reyk Exp $ */
d239 1
a239 1
static int
@


1.5
log
@Rename SSL_CTX_use_certificate_chain() to SSL_CTX_use_certificate_chain_mem().

As discussed with beck@@ jsing@@ and others
OK beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.4 2014/12/17 17:51:33 doug Exp $ */
d26 1
d239 49
d291 1
a291 1
	int ret, ssl_err;
d298 3
a300 3
	ret = SSL_read(ctx->ssl_conn, buf, buflen);
	if (ret > 0) {
		*outlen = (size_t)ret;
d304 1
a304 10
	ssl_err = SSL_get_error(ctx->ssl_conn, ret);
	switch (ssl_err) {
	case SSL_ERROR_WANT_READ:
		return (TLS_READ_AGAIN);
	case SSL_ERROR_WANT_WRITE:
		return (TLS_WRITE_AGAIN);
	default:
		tls_set_error(ctx, "read failed (%i)", ssl_err);
		return (-1);
	}
d310 1
a310 1
	int ret, ssl_err;
d317 3
a319 3
	ret = SSL_write(ctx->ssl_conn, buf, buflen);
	if (ret > 0) {
		*outlen = (size_t)ret;
d323 1
a323 10
	ssl_err = SSL_get_error(ctx->ssl_conn, ret);
	switch (ssl_err) {
	case SSL_ERROR_WANT_READ:
		return (TLS_READ_AGAIN);
	case SSL_ERROR_WANT_WRITE:
		return (TLS_WRITE_AGAIN);
	default:
		tls_set_error(ctx, "write failed (%i)", ssl_err);
		return (-1);
	}
@


1.4
log
@Add size_t to int checks for SSL functions.

libtls accepts size_t for lengths but libssl accepts int.  This verifies
that the input does not exceed INT_MAX.  It also avoids truncating size_t
when comparing with int and adds printf-style attributes for
tls_set_error().

with input from deraadt@@ and tedu@@
ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.3 2014/12/07 15:48:02 bcook Exp $ */
d119 1
a119 1
		if (SSL_CTX_use_certificate_chain(ctx->ssl_ctx,
@


1.3
log
@revert previous change for now, adjusting based on comments from jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.2 2014/12/07 15:00:32 bcook Exp $ */
d21 1
d114 5
d127 5
d243 5
d270 5
@


1.2
log
@Allow specific libtls hostname validation errors to propagate.

Remove direct calls to printf from the tls_check_hostname() path. This allows
NUL byte error messages to bubble up to the caller, to be logged in a
program-appropriate way. It also removes non-portable calls to getprogname().

The semantics of tls_error() are changed slightly: the last error message is
not necessarily preserved between subsequent calls into the library.
When the previous call to libtls succeeds, client programs should treat the
return value of tls_error() as undefined.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.1 2014/10/31 13:46:17 jsing Exp $ */
a58 8
void
tls_clear_error(struct tls *ctx)
{
	ctx->err = 0;
	free(ctx->errmsg);
	ctx->errmsg = NULL;
}

a64 1
	tls_clear_error(ctx);
d66 2
@


1.1
log
@Rename libressl to libtls to avoid confusion and to make it easier to
distinguish between LibreSSL (the project) and libressl (the library).

Discussed with many.
@
text
@d1 1
a1 1
/* $OpenBSD: tls.c,v 1.18 2014/10/15 21:02:39 tedu Exp $ */
d59 8
d73 1
a74 2
	free(ctx->errmsg);
	ctx->errmsg = NULL;
@

