head	1.44;
access;
symbols
	OPENBSD_6_2:1.44.0.2
	OPENBSD_6_2_BASE:1.44
	OPENBSD_6_1:1.36.0.4
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9;
locks; strict;
comment	@ * @;


1.44
date	2017.09.25.18.07.03;	author jsing;	state Exp;
branches;
next	1.43;
commitid	PSU6OqMUN7X9kusb;

1.43
date	2017.08.10.18.18.30;	author jsing;	state Exp;
branches;
next	1.42;
commitid	JWjAtg2Qibcivg2a;

1.42
date	2017.08.09.21.27.24;	author claudio;	state Exp;
branches;
next	1.41;
commitid	3iIfALS7OGyzkioe;

1.41
date	2017.07.06.17.12.22;	author jsing;	state Exp;
branches;
next	1.40;
commitid	fv2Kdpq5NVcxboLK;

1.40
date	2017.05.06.20.59.28;	author jsing;	state Exp;
branches;
next	1.39;
commitid	lKAI2ck8n3yTWNjk;

1.39
date	2017.05.02.03.59.45;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	Dm63V7JYy6WzetfM;

1.38
date	2017.04.30.02.10.22;	author jsing;	state Exp;
branches;
next	1.37;
commitid	CtyodDg2PXeEosMn;

1.37
date	2017.04.05.03.13.53;	author beck;	state Exp;
branches;
next	1.36;
commitid	SWbRdnAypDhJYgn8;

1.36
date	2017.01.31.16.18.57;	author beck;	state Exp;
branches;
next	1.35;
commitid	xEmNr0q3vZFvI7yp;

1.35
date	2017.01.29.17.52.11;	author beck;	state Exp;
branches;
next	1.34;
commitid	DZ2gL9MkhCf6eTgX;

1.34
date	2017.01.24.01.48.05;	author claudio;	state Exp;
branches;
next	1.33;
commitid	k0nZBOjpyTl9Tz16;

1.33
date	2016.11.11.14.02.24;	author jsing;	state Exp;
branches;
next	1.32;
commitid	Raxw7C0Peowb71As;

1.32
date	2016.11.05.15.13.26;	author beck;	state Exp;
branches;
next	1.31;
commitid	3VJnu6rXiOGWa3uh;

1.31
date	2016.11.04.19.01.04;	author jsing;	state Exp;
branches;
next	1.30;
commitid	z5WvCf9ejTOryRAX;

1.30
date	2016.11.04.18.59.35;	author jsing;	state Exp;
branches;
next	1.29;
commitid	ICmMn1U6DBe57yA8;

1.29
date	2016.11.04.05.13.13;	author beck;	state Exp;
branches;
next	1.28;
commitid	vHqLGL1n0DAh4s4y;

1.28
date	2016.08.22.14.55.59;	author jsing;	state Exp;
branches;
next	1.27;
commitid	WuoLREAZSBiJsrrv;

1.27
date	2016.08.13.13.15.53;	author jsing;	state Exp;
branches;
next	1.26;
commitid	G0kCJ8ZEToWLi5Ti;

1.26
date	2016.08.13.13.05.51;	author jsing;	state Exp;
branches;
next	1.25;
commitid	dEFnw34DXI0aEQXO;

1.25
date	2016.08.12.15.10.59;	author jsing;	state Exp;
branches;
next	1.24;
commitid	JoLVmCulWsGsIXUK;

1.24
date	2016.08.02.07.47.11;	author jsing;	state Exp;
branches;
next	1.23;
commitid	0rb7ZAopgz9STgBs;

1.23
date	2016.08.01.17.32.19;	author jsing;	state Exp;
branches;
next	1.22;
commitid	s3UFLNfN0t7jV6pK;

1.22
date	2016.07.13.16.30.48;	author jsing;	state Exp;
branches;
next	1.21;
commitid	Mw54YoRDL3QkFJKB;

1.21
date	2016.07.07.14.09.03;	author jsing;	state Exp;
branches;
next	1.20;
commitid	0fGHFHTpGSNSAMDC;

1.20
date	2016.07.06.16.47.18;	author jsing;	state Exp;
branches;
next	1.19;
commitid	Q4eopJMMAdgNLYU4;

1.19
date	2016.07.06.16.16.36;	author jsing;	state Exp;
branches;
next	1.18;
commitid	kH7xEZhqwkoUIN0m;

1.18
date	2016.05.27.14.38.40;	author jsing;	state Exp;
branches;
next	1.17;
commitid	VY5Ci9qTBsSOcCgx;

1.17
date	2016.05.27.14.27.22;	author jsing;	state Exp;
branches;
next	1.16;
commitid	7hnYtJ64waVXGdkE;

1.16
date	2016.04.28.17.05.59;	author jsing;	state Exp;
branches;
next	1.15;
commitid	DKpbOonvEBeRoW5p;

1.15
date	2016.04.28.16.48.44;	author jsing;	state Exp;
branches;
next	1.14;
commitid	pJ2jMgrYqvai7CXS;

1.14
date	2015.09.29.10.17.04;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	YDjtN3rqnZIVf1NW;

1.13
date	2015.09.14.16.16.38;	author jsing;	state Exp;
branches;
next	1.12;
commitid	Fd6WDkwQWggESQVJ;

1.12
date	2015.09.10.09.10.42;	author jsing;	state Exp;
branches;
next	1.11;
commitid	QGGZQQxHecOSmNyK;

1.11
date	2015.09.09.19.49.07;	author jsing;	state Exp;
branches;
next	1.10;
commitid	8fjywsQemyYNWdJq;

1.10
date	2015.09.09.19.23.04;	author beck;	state Exp;
branches;
next	1.9;
commitid	nJxZtGxH6XzyXez3;

1.9
date	2015.02.22.15.09.54;	author jsing;	state Exp;
branches;
next	1.8;
commitid	lRyL0pnPfoLbeA76;

1.8
date	2015.02.22.14.59.37;	author jsing;	state Exp;
branches;
next	1.7;
commitid	osZsLGdrQFxrayri;

1.7
date	2015.02.22.14.50.41;	author jsing;	state Exp;
branches;
next	1.6;
commitid	HqV3HmGpJHWot77o;

1.6
date	2015.02.12.04.35.17;	author jsing;	state Exp;
branches;
next	1.5;
commitid	nClddflyeaKNhSCO;

1.5
date	2015.02.12.04.31.27;	author jsing;	state Exp;
branches;
next	1.4;
commitid	vfgtVEYwqZVhgE9H;

1.4
date	2015.02.11.06.46.33;	author jsing;	state Exp;
branches;
next	1.3;
commitid	IjYTp2gC6lDO8mXr;

1.3
date	2015.02.07.06.19.26;	author jsing;	state Exp;
branches;
next	1.2;
commitid	cwopaOfpwORA2vUX;

1.2
date	2015.01.22.09.16.24;	author reyk;	state Exp;
branches;
next	1.1;
commitid	MIkUgu4UHo6s43H0;

1.1
date	2014.10.31.13.46.17;	author jsing;	state Exp;
branches;
next	;
commitid	y63FmUITd26yVanM;


desc
@@


1.44
log
@If tls_config_parse_protocols() is called with a NULL pointer, return the
default protocols instead of crashing - this makes the behaviour more
useful and mirrors what we already do in tls_config_set_ciphers() et al.
@
text
@/* $OpenBSD: tls_config.c,v 1.43 2017/08/10 18:18:30 jsing Exp $ */
/*
 * Copyright (c) 2014 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>

#include <tls.h>
#include "tls_internal.h"

static int
set_string(const char **dest, const char *src)
{
	free((char *)*dest);
	*dest = NULL;
	if (src != NULL)
		if ((*dest = strdup(src)) == NULL)
			return -1;
	return 0;
}

static void *
memdup(const void *in, size_t len)
{
	void *out;

	if ((out = malloc(len)) == NULL)
		return NULL;
	memcpy(out, in, len);
	return out;
}

static int
set_mem(char **dest, size_t *destlen, const void *src, size_t srclen)
{
	free(*dest);
	*dest = NULL;
	*destlen = 0;
	if (src != NULL)
		if ((*dest = memdup(src, srclen)) == NULL)
			return -1;
	*destlen = srclen;
	return 0;
}

static struct tls_keypair *
tls_keypair_new(void)
{
	return calloc(1, sizeof(struct tls_keypair));
}

static void
tls_keypair_clear_key(struct tls_keypair *keypair)
{
	freezero(keypair->key_mem, keypair->key_len);
	keypair->key_mem = NULL;
	keypair->key_len = 0;
}

static int
tls_keypair_set_cert_file(struct tls_keypair *keypair, struct tls_error *error,
    const char *cert_file)
{
	return tls_config_load_file(error, "certificate", cert_file,
	    &keypair->cert_mem, &keypair->cert_len);
}

static int
tls_keypair_set_cert_mem(struct tls_keypair *keypair, const uint8_t *cert,
    size_t len)
{
	return set_mem(&keypair->cert_mem, &keypair->cert_len, cert, len);
}

static int
tls_keypair_set_key_file(struct tls_keypair *keypair, struct tls_error *error,
    const char *key_file)
{
	tls_keypair_clear_key(keypair);
	return tls_config_load_file(error, "key", key_file,
	    &keypair->key_mem, &keypair->key_len);
}

static int
tls_keypair_set_key_mem(struct tls_keypair *keypair, const uint8_t *key,
    size_t len)
{
	tls_keypair_clear_key(keypair);
	return set_mem(&keypair->key_mem, &keypair->key_len, key, len);
}

static int
tls_keypair_set_ocsp_staple_file(struct tls_keypair *keypair,
    struct tls_error *error, const char *ocsp_file)
{
	return tls_config_load_file(error, "ocsp", ocsp_file,
	    &keypair->ocsp_staple, &keypair->ocsp_staple_len);
}

static int
tls_keypair_set_ocsp_staple_mem(struct tls_keypair *keypair,
    const uint8_t *staple, size_t len)
{
	return set_mem(&keypair->ocsp_staple, &keypair->ocsp_staple_len, staple,
	    len);
}

static void
tls_keypair_clear(struct tls_keypair *keypair)
{
	tls_keypair_set_cert_mem(keypair, NULL, 0);
	tls_keypair_set_key_mem(keypair, NULL, 0);
}

static void
tls_keypair_free(struct tls_keypair *keypair)
{
	if (keypair == NULL)
		return;

	tls_keypair_clear(keypair);

	free(keypair->cert_mem);
	free(keypair->key_mem);
	free(keypair->ocsp_staple);
	free(keypair->pubkey_hash);

	free(keypair);
}

int
tls_config_load_file(struct tls_error *error, const char *filetype,
    const char *filename, char **buf, size_t *len)
{
	struct stat st;
	int fd = -1;
	ssize_t n;

	free(*buf);
	*buf = NULL;
	*len = 0;

	if ((fd = open(filename, O_RDONLY)) == -1) {
		tls_error_set(error, "failed to open %s file '%s'",
		    filetype, filename);
		goto fail;
	}
	if (fstat(fd, &st) != 0) {
		tls_error_set(error, "failed to stat %s file '%s'",
		    filetype, filename);
		goto fail;
	}
	if (st.st_size < 0)
		goto fail;
	*len = (size_t)st.st_size;
	if ((*buf = malloc(*len)) == NULL) {
		tls_error_set(error, "failed to allocate buffer for "
		    "%s file", filetype);
		goto fail;
	}
	n = read(fd, *buf, *len);
	if (n < 0 || (size_t)n != *len) {
		tls_error_set(error, "failed to read %s file '%s'",
		    filetype, filename);
		goto fail;
	}
	close(fd);
	return 0;

 fail:
	if (fd != -1)
		close(fd);
	freezero(*buf, *len);
	*buf = NULL;
	*len = 0;

	return -1;
}

struct tls_config *
tls_config_new(void)
{
	struct tls_config *config;
	unsigned char sid[TLS_MAX_SESSION_ID_LENGTH];

	if ((config = calloc(1, sizeof(*config))) == NULL)
		return (NULL);

	if ((config->keypair = tls_keypair_new()) == NULL)
		goto err;

	config->refcount = 1;

	/*
	 * Default configuration.
	 */
	if (tls_config_set_dheparams(config, "none") != 0)
		goto err;
	if (tls_config_set_ecdhecurves(config, "default") != 0)
		goto err;
	if (tls_config_set_ciphers(config, "secure") != 0)
		goto err;

	if (tls_config_set_protocols(config, TLS_PROTOCOLS_DEFAULT) != 0)
		goto err;
	if (tls_config_set_verify_depth(config, 6) != 0)
		goto err;

	/*
	 * Set session ID context to a random value.  For the simple case
	 * of a single process server this is good enough. For multiprocess
	 * servers the session ID needs to be set by the caller.
	 */
	arc4random_buf(sid, sizeof(sid));
	if (tls_config_set_session_id(config, sid, sizeof(sid)) != 0)
		goto err;
	config->ticket_keyrev = arc4random();
	config->ticket_autorekey = 1;

	tls_config_prefer_ciphers_server(config);

	tls_config_verify(config);

	return (config);

 err:
	tls_config_free(config);
	return (NULL);
}

void
tls_config_free(struct tls_config *config)
{
	struct tls_keypair *kp, *nkp;

	if (config == NULL)
		return;

	if (--config->refcount > 0)
		return;

	for (kp = config->keypair; kp != NULL; kp = nkp) {
		nkp = kp->next;
		tls_keypair_free(kp);
	}

	free(config->error.msg);

	free(config->alpn);
	free((char *)config->ca_mem);
	free((char *)config->ca_path);
	free((char *)config->ciphers);
	free((char *)config->crl_mem);
	free(config->ecdhecurves);

	free(config);
}

static void
tls_config_keypair_add(struct tls_config *config, struct tls_keypair *keypair)
{
	struct tls_keypair *kp;

	kp = config->keypair;
	while (kp->next != NULL)
		kp = kp->next;

	kp->next = keypair;
}

const char *
tls_config_error(struct tls_config *config)
{
	return config->error.msg;
}

void
tls_config_clear_keys(struct tls_config *config)
{
	struct tls_keypair *kp;

	for (kp = config->keypair; kp != NULL; kp = kp->next)
		tls_keypair_clear(kp);

	tls_config_set_ca_mem(config, NULL, 0);
	tls_config_set_crl_mem(config, NULL, 0);
}

int
tls_config_parse_protocols(uint32_t *protocols, const char *protostr)
{
	uint32_t proto, protos = 0;
	char *s, *p, *q;
	int negate;

	if (protostr == NULL)
		return TLS_PROTOCOLS_DEFAULT;

	if ((s = strdup(protostr)) == NULL)
		return (-1);

	q = s;
	while ((p = strsep(&q, ",:")) != NULL) {
		while (*p == ' ' || *p == '\t')
			p++;

		negate = 0;
		if (*p == '!') {
			negate = 1;
			p++;
		}

		if (negate && protos == 0)
			protos = TLS_PROTOCOLS_ALL;

		proto = 0;
		if (strcasecmp(p, "all") == 0 ||
		    strcasecmp(p, "legacy") == 0)
			proto = TLS_PROTOCOLS_ALL;
		else if (strcasecmp(p, "default") == 0 ||
		    strcasecmp(p, "secure") == 0)
			proto = TLS_PROTOCOLS_DEFAULT;
		if (strcasecmp(p, "tlsv1") == 0)
			proto = TLS_PROTOCOL_TLSv1;
		else if (strcasecmp(p, "tlsv1.0") == 0)
			proto = TLS_PROTOCOL_TLSv1_0;
		else if (strcasecmp(p, "tlsv1.1") == 0)
			proto = TLS_PROTOCOL_TLSv1_1;
		else if (strcasecmp(p, "tlsv1.2") == 0)
			proto = TLS_PROTOCOL_TLSv1_2;

		if (proto == 0) {
			free(s);
			return (-1);
		}

		if (negate)
			protos &= ~proto;
		else
			protos |= proto;
	}

	*protocols = protos;

	free(s);

	return (0);
}

static int
tls_config_parse_alpn(struct tls_config *config, const char *alpn,
    char **alpn_data, size_t *alpn_len)
{
	size_t buf_len, i, len;
	char *buf = NULL;
	char *s = NULL;
	char *p, *q;

	free(*alpn_data);
	*alpn_data = NULL;
	*alpn_len = 0;

	if ((buf_len = strlen(alpn) + 1) > 65535) {
		tls_config_set_errorx(config, "alpn too large");
		goto err;
	}

	if ((buf = malloc(buf_len)) == NULL) {
		tls_config_set_errorx(config, "out of memory");
		goto err;
	}

	if ((s = strdup(alpn)) == NULL) {
		tls_config_set_errorx(config, "out of memory");
		goto err;
	}

	i = 0;
	q = s;
	while ((p = strsep(&q, ",")) != NULL) {
		if ((len = strlen(p)) == 0) {
			tls_config_set_errorx(config,
			    "alpn protocol with zero length");
			goto err;
		}
		if (len > 255) {
			tls_config_set_errorx(config,
			    "alpn protocol too long");
			goto err;
		}
		buf[i++] = len & 0xff;
		memcpy(&buf[i], p, len);
		i += len;
	}

	free(s);

	*alpn_data = buf;
	*alpn_len = buf_len;

	return (0);

 err:
	free(buf);
	free(s);

	return (-1);
}

int
tls_config_set_alpn(struct tls_config *config, const char *alpn)
{
	return tls_config_parse_alpn(config, alpn, &config->alpn,
	    &config->alpn_len);
}

static int
tls_config_add_keypair_file_internal(struct tls_config *config,
    const char *cert_file, const char *key_file, const char *ocsp_file)
{
	struct tls_keypair *keypair;

	if ((keypair = tls_keypair_new()) == NULL)
		return (-1);
	if (tls_keypair_set_cert_file(keypair, &config->error, cert_file) != 0)
		goto err;
	if (tls_keypair_set_key_file(keypair, &config->error, key_file) != 0)
		goto err;
	if (ocsp_file != NULL &&
	    tls_keypair_set_ocsp_staple_file(keypair, &config->error,
		ocsp_file) != 0)
		goto err;

	tls_config_keypair_add(config, keypair);

	return (0);

 err:
	tls_keypair_free(keypair);
	return (-1);
}

static int
tls_config_add_keypair_mem_internal(struct tls_config *config, const uint8_t *cert,
    size_t cert_len, const uint8_t *key, size_t key_len,
    const uint8_t *staple, size_t staple_len)
{
	struct tls_keypair *keypair;

	if ((keypair = tls_keypair_new()) == NULL)
		return (-1);
	if (tls_keypair_set_cert_mem(keypair, cert, cert_len) != 0)
		goto err;
	if (tls_keypair_set_key_mem(keypair, key, key_len) != 0)
		goto err;
	if (staple != NULL &&
	    tls_keypair_set_ocsp_staple_mem(keypair, staple, staple_len) != 0)
		goto err;

	tls_config_keypair_add(config, keypair);

	return (0);

 err:
	tls_keypair_free(keypair);
	return (-1);
}

int
tls_config_add_keypair_mem(struct tls_config *config, const uint8_t *cert,
    size_t cert_len, const uint8_t *key, size_t key_len)
{
	return tls_config_add_keypair_mem_internal(config, cert, cert_len, key,
	    key_len, NULL, 0);
}

int
tls_config_add_keypair_file(struct tls_config *config,
    const char *cert_file, const char *key_file)
{
	return tls_config_add_keypair_file_internal(config, cert_file,
	    key_file, NULL);
}

int
tls_config_add_keypair_ocsp_mem(struct tls_config *config, const uint8_t *cert,
    size_t cert_len, const uint8_t *key, size_t key_len, const uint8_t *staple,
    size_t staple_len)
{
	return tls_config_add_keypair_mem_internal(config, cert, cert_len, key,
	    key_len, staple, staple_len);
}

int
tls_config_add_keypair_ocsp_file(struct tls_config *config,
    const char *cert_file, const char *key_file, const char *ocsp_file)
{
	return tls_config_add_keypair_file_internal(config, cert_file,
	    key_file, ocsp_file);
}

int
tls_config_set_ca_file(struct tls_config *config, const char *ca_file)
{
	return tls_config_load_file(&config->error, "CA", ca_file,
	    &config->ca_mem, &config->ca_len);
}

int
tls_config_set_ca_path(struct tls_config *config, const char *ca_path)
{
	return set_string(&config->ca_path, ca_path);
}

int
tls_config_set_ca_mem(struct tls_config *config, const uint8_t *ca, size_t len)
{
	return set_mem(&config->ca_mem, &config->ca_len, ca, len);
}

int
tls_config_set_cert_file(struct tls_config *config, const char *cert_file)
{
	return tls_keypair_set_cert_file(config->keypair, &config->error,
	    cert_file);
}

int
tls_config_set_cert_mem(struct tls_config *config, const uint8_t *cert,
    size_t len)
{
	return tls_keypair_set_cert_mem(config->keypair, cert, len);
}

int
tls_config_set_ciphers(struct tls_config *config, const char *ciphers)
{
	SSL_CTX *ssl_ctx = NULL;

	if (ciphers == NULL ||
	    strcasecmp(ciphers, "default") == 0 ||
	    strcasecmp(ciphers, "secure") == 0)
		ciphers = TLS_CIPHERS_DEFAULT;
	else if (strcasecmp(ciphers, "compat") == 0)
		ciphers = TLS_CIPHERS_COMPAT;
	else if (strcasecmp(ciphers, "legacy") == 0)
		ciphers = TLS_CIPHERS_LEGACY;
	else if (strcasecmp(ciphers, "all") == 0 ||
	    strcasecmp(ciphers, "insecure") == 0)
		ciphers = TLS_CIPHERS_ALL;

	if ((ssl_ctx = SSL_CTX_new(SSLv23_method())) == NULL) {
		tls_config_set_errorx(config, "out of memory");
		goto fail;
	}
	if (SSL_CTX_set_cipher_list(ssl_ctx, ciphers) != 1) {
		tls_config_set_errorx(config, "no ciphers for '%s'", ciphers);
		goto fail;
	}

	SSL_CTX_free(ssl_ctx);
	return set_string(&config->ciphers, ciphers);

 fail:
	SSL_CTX_free(ssl_ctx);
	return -1;
}

int
tls_config_set_crl_file(struct tls_config *config, const char *crl_file)
{
	return tls_config_load_file(&config->error, "CRL", crl_file,
	    &config->crl_mem, &config->crl_len);
}

int
tls_config_set_crl_mem(struct tls_config *config, const uint8_t *crl,
    size_t len)
{
	return set_mem(&config->crl_mem, &config->crl_len, crl, len);
}

int
tls_config_set_dheparams(struct tls_config *config, const char *params)
{
	int keylen;

	if (params == NULL || strcasecmp(params, "none") == 0)
		keylen = 0;
	else if (strcasecmp(params, "auto") == 0)
		keylen = -1;
	else if (strcasecmp(params, "legacy") == 0)
		keylen = 1024;
	else {
		tls_config_set_errorx(config, "invalid dhe param '%s'", params);
		return (-1);
	}

	config->dheparams = keylen;

	return (0);
}

int
tls_config_set_ecdhecurve(struct tls_config *config, const char *curve)
{
	if (strchr(curve, ',') != NULL || strchr(curve, ':') != NULL) {
		tls_config_set_errorx(config, "invalid ecdhe curve '%s'",
		    curve);
		return (-1);
	}

	if (curve == NULL ||
	    strcasecmp(curve, "none") == 0 ||
	    strcasecmp(curve, "auto") == 0)
		curve = TLS_ECDHE_CURVES;
		
	return tls_config_set_ecdhecurves(config, curve);
}

int
tls_config_set_ecdhecurves(struct tls_config *config, const char *curves)
{
	int *curves_list = NULL, *curves_new;
	size_t curves_num = 0;
	char *cs = NULL;
	char *p, *q;
	int rv = -1;
	int nid;

	free(config->ecdhecurves);
	config->ecdhecurves = NULL;
	config->ecdhecurves_len = 0;

	if (curves == NULL || strcasecmp(curves, "default") == 0)
		curves = TLS_ECDHE_CURVES;

	if ((cs = strdup(curves)) == NULL) {
		tls_config_set_errorx(config, "out of memory");
		goto err;
	}

	q = cs;
	while ((p = strsep(&q, ",:")) != NULL) {
		while (*p == ' ' || *p == '\t')
			p++;

		nid = OBJ_sn2nid(p);
		if (nid == NID_undef)
			nid = OBJ_ln2nid(p);
		if (nid == NID_undef)
			nid = EC_curve_nist2nid(p);
		if (nid == NID_undef) {
			tls_config_set_errorx(config,
			    "invalid ecdhe curve '%s'", p);
			goto err;
		}

		if ((curves_new = reallocarray(curves_list, curves_num + 1,
		    sizeof(int))) == NULL) {
			tls_config_set_errorx(config, "out of memory");
			goto err;
		}
		curves_list = curves_new;
		curves_list[curves_num] = nid;
		curves_num++;
	}

	config->ecdhecurves = curves_list;
	config->ecdhecurves_len = curves_num;
	curves_list = NULL;

	rv = 0;

 err:
	free(cs);
	free(curves_list);

	return (rv);
}

int
tls_config_set_key_file(struct tls_config *config, const char *key_file)
{
	return tls_keypair_set_key_file(config->keypair, &config->error,
	    key_file);
}

int
tls_config_set_key_mem(struct tls_config *config, const uint8_t *key,
    size_t len)
{
	return tls_keypair_set_key_mem(config->keypair, key, len);
}

static int
tls_config_set_keypair_file_internal(struct tls_config *config,
    const char *cert_file, const char *key_file, const char *ocsp_file)
{
	if (tls_config_set_cert_file(config, cert_file) != 0)
		return (-1);
	if (tls_config_set_key_file(config, key_file) != 0)
		return (-1);
	if (tls_config_set_key_file(config, key_file) != 0)
		return (-1);
	if (ocsp_file != NULL &&
	    tls_config_set_ocsp_staple_file(config, ocsp_file) != 0)
		return (-1);

	return (0);
}

static int
tls_config_set_keypair_mem_internal(struct tls_config *config, const uint8_t *cert,
    size_t cert_len, const uint8_t *key, size_t key_len,
    const uint8_t *staple, size_t staple_len)
{
	if (tls_config_set_cert_mem(config, cert, cert_len) != 0)
		return (-1);
	if (tls_config_set_key_mem(config, key, key_len) != 0)
		return (-1);
	if ((staple != NULL) &&
	    (tls_config_set_ocsp_staple_mem(config, staple, staple_len) != 0))
		return (-1);

	return (0);
}

int
tls_config_set_keypair_file(struct tls_config *config,
    const char *cert_file, const char *key_file)
{
	return tls_config_set_keypair_file_internal(config, cert_file, key_file,
	    NULL);
}

int
tls_config_set_keypair_mem(struct tls_config *config, const uint8_t *cert,
    size_t cert_len, const uint8_t *key, size_t key_len)
{
	return tls_config_set_keypair_mem_internal(config, cert, cert_len,
	    key, key_len, NULL, 0);
}

int
tls_config_set_keypair_ocsp_file(struct tls_config *config,
    const char *cert_file, const char *key_file, const char *ocsp_file)
{
	return tls_config_set_keypair_file_internal(config, cert_file, key_file,
	    ocsp_file);
}

int
tls_config_set_keypair_ocsp_mem(struct tls_config *config, const uint8_t *cert,
    size_t cert_len, const uint8_t *key, size_t key_len,
    const uint8_t *staple, size_t staple_len)
{
	return tls_config_set_keypair_mem_internal(config, cert, cert_len,
	    key, key_len, staple, staple_len);
}


int
tls_config_set_protocols(struct tls_config *config, uint32_t protocols)
{
	config->protocols = protocols;

	return (0);
}

int
tls_config_set_verify_depth(struct tls_config *config, int verify_depth)
{
	config->verify_depth = verify_depth;

	return (0);
}

void
tls_config_prefer_ciphers_client(struct tls_config *config)
{
	config->ciphers_server = 0;
}

void
tls_config_prefer_ciphers_server(struct tls_config *config)
{
	config->ciphers_server = 1;
}

void
tls_config_insecure_noverifycert(struct tls_config *config)
{
	config->verify_cert = 0;
}

void
tls_config_insecure_noverifyname(struct tls_config *config)
{
	config->verify_name = 0;
}

void
tls_config_insecure_noverifytime(struct tls_config *config)
{
	config->verify_time = 0;
}

void
tls_config_verify(struct tls_config *config)
{
	config->verify_cert = 1;
	config->verify_name = 1;
	config->verify_time = 1;
}

void
tls_config_ocsp_require_stapling(struct tls_config *config)
{
	config->ocsp_require_stapling = 1;
}

void
tls_config_verify_client(struct tls_config *config)
{
	config->verify_client = 1;
}

void
tls_config_verify_client_optional(struct tls_config *config)
{
	config->verify_client = 2;
}

void
tls_config_skip_private_key_check(struct tls_config *config)
{
	config->skip_private_key_check = 1;
}

int
tls_config_set_ocsp_staple_file(struct tls_config *config, const char *staple_file)
{
	return tls_keypair_set_ocsp_staple_file(config->keypair, &config->error,
	    staple_file);
}

int
tls_config_set_ocsp_staple_mem(struct tls_config *config, const uint8_t *staple,
    size_t len)
{
	return tls_keypair_set_ocsp_staple_mem(config->keypair, staple, len);
}

int
tls_config_set_session_id(struct tls_config *config,
    const unsigned char *session_id, size_t len)
{
	if (len > TLS_MAX_SESSION_ID_LENGTH) {
		tls_config_set_errorx(config, "session ID too large");
		return (-1);
	}
	memset(config->session_id, 0, sizeof(config->session_id));
	memcpy(config->session_id, session_id, len);
	return (0);
}

int
tls_config_set_session_lifetime(struct tls_config *config, int lifetime)
{
	if (lifetime > TLS_MAX_SESSION_TIMEOUT) {
		tls_config_set_errorx(config, "session lifetime too large");
		return (-1);
	}
	if (lifetime != 0 && lifetime < TLS_MIN_SESSION_TIMEOUT) {
		tls_config_set_errorx(config, "session lifetime too small");
		return (-1);
	}

	config->session_lifetime = lifetime;
	return (0);
}

int
tls_config_add_ticket_key(struct tls_config *config, uint32_t keyrev,
    unsigned char *key, size_t keylen)
{
	struct tls_ticket_key newkey;
	int i;

	if (TLS_TICKET_KEY_SIZE != keylen ||
	    sizeof(newkey.aes_key) + sizeof(newkey.hmac_key) > keylen) {
		tls_config_set_errorx(config,
		    "wrong amount of ticket key data");
		return (-1);
	}

	keyrev = htonl(keyrev);
	memset(&newkey, 0, sizeof(newkey));
	memcpy(newkey.key_name, &keyrev, sizeof(keyrev));
	memcpy(newkey.aes_key, key, sizeof(newkey.aes_key));
	memcpy(newkey.hmac_key, key + sizeof(newkey.aes_key),
	    sizeof(newkey.hmac_key));
	newkey.time = time(NULL);

	for (i = 0; i < TLS_NUM_TICKETS; i++) {
		struct tls_ticket_key *tk = &config->ticket_keys[i];
		if (memcmp(newkey.key_name, tk->key_name,
		    sizeof(tk->key_name)) != 0)
			continue;

		/* allow re-entry of most recent key */
		if (i == 0 && memcmp(newkey.aes_key, tk->aes_key,
		    sizeof(tk->aes_key)) == 0 && memcmp(newkey.hmac_key,
		    tk->hmac_key, sizeof(tk->hmac_key)) == 0)
			return (0);
		tls_config_set_errorx(config, "ticket key already present");
		return (-1);
	}

	memmove(&config->ticket_keys[1], &config->ticket_keys[0],
	    sizeof(config->ticket_keys) - sizeof(config->ticket_keys[0]));
	config->ticket_keys[0] = newkey;

	config->ticket_autorekey = 0;

	return (0);
}

int
tls_config_ticket_autorekey(struct tls_config *config)
{
	unsigned char key[TLS_TICKET_KEY_SIZE];
	int rv;

	arc4random_buf(key, sizeof(key));
	rv = tls_config_add_ticket_key(config, config->ticket_keyrev++, key,
	    sizeof(key));
	config->ticket_autorekey = 1;
	return (rv);
}
@


1.43
log
@Add a tls_config_set_ecdhecurves() function to libtls, which allows the
names of the elliptic curves that may be used during client and server
key exchange to be specified.

This deprecates tls_config_set_ecdhecurve(), which could only be used to
specify a single supported curve.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.42 2017/08/09 21:27:24 claudio Exp $ */
d313 3
@


1.42
log
@Don't use tls_cert_hash for the hashing used by the engine offloading magic
for the TLS privsep code. Instead use X509_pubkey_digest() because only the
key should be used as identifier. Relayd is rewriting certificates and then
the hash would change. Rename the hash is struct tls_keypair to pubkey_hash
to make clear what this hash is about.
With input and OK jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.41 2017/07/06 17:12:22 jsing Exp $ */
d217 1
a217 1
	if (tls_config_set_ecdhecurve(config, "auto") != 0)
d272 1
d620 1
a620 1
tls_config_set_ecdhecurve(struct tls_config *config, const char *name)
d622 22
d646 36
a681 7
	if (name == NULL || strcasecmp(name, "none") == 0)
		nid = NID_undef;
	else if (strcasecmp(name, "auto") == 0)
		nid = -1;
	else if ((nid = OBJ_txt2nid(name)) == NID_undef) {
		tls_config_set_errorx(config, "invalid ecdhe curve '%s'", name);
		return (-1);
d684 5
a688 1
	config->ecdhecurve = nid;
d690 5
a694 1
	return (0);
@


1.41
log
@Add support for providing CRLs to libtls - once a CRL is provided we
enable CRL checking for the full certificate chain.

Based on a diff from Jack Burton <jack at saosce dot com dot au>, thanks!

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.40 2017/05/06 20:59:28 jsing Exp $ */
d144 1
a144 1
	free(keypair->cert_hash);
@


1.40
log
@Perform reference counting for tls_config. This allows tls_config_free() to
be called as soon as it has been passed to the final tls_configure() call,
simplifying lifetime tracking for the application.

Requested some time ago by tedu@@.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.39 2017/05/02 03:59:45 deraadt Exp $ */
d271 1
d303 1
d581 14
@


1.39
log
@use freezero() instead of memset/explicit_bzero + free.  Substantially
reduces conditional logic (-218, +82).

MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH cache alignment calculation bn/bn_exp.c
wasn'tt quite right.  Two other tricky bits with ASN1_STRING_FLAG_NDEF and
BN_FLG_STATIC_DATA where the condition cannot be collapsed completely.

Passes regress.  ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.38 2017/04/30 02:10:22 jsing Exp $ */
d210 2
d255 3
@


1.38
log
@Add a tls_keypair_clear_key() function that uses freezero() to make key
material inaccessible, then call it from the appropriate places.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.37 2017/04/05 03:13:53 beck Exp $ */
d191 1
a191 3
	if (*buf != NULL)
		explicit_bzero(*buf, *len);
	free(*buf);
@


1.37
log
@Internal changes to allow for relayd engine privsep. sends the hash of the
public key as an identifier to RSA, and adds an function for relayd to
use to disable private key checking when doing engine privsep.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.36 2017/01/31 16:18:57 beck Exp $ */
d70 8
d97 1
a97 2
	if (keypair->key_mem != NULL)
		explicit_bzero(keypair->key_mem, keypair->key_len);
d106 1
a106 2
	if (keypair->key_mem != NULL)
		explicit_bzero(keypair->key_mem, keypair->key_len);
@


1.36
log
@Add tls_config_[add|set]keypair_ocsp functions so that ocsp staples may be
added associated to a keypair used for SNI, and are usable for more than
just the "main" certificate. Modify httpd to use this.
Bump libtls minor.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.35 2017/01/29 17:52:11 beck Exp $ */
d138 1
d763 6
@


1.35
log
@Move the ocsp staple to being part of the keypair structure internally,
so that it does not send back bogus staples when SNI is in use.
(Further change is required to be able to use staples on all keypairs
and not just the main one)
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.34 2017/01/24 01:48:05 claudio Exp $ */
d419 3
a421 3
int
tls_config_add_keypair_file(struct tls_config *config,
    const char *cert_file, const char *key_file)
d431 4
d445 4
a448 3
int
tls_config_add_keypair_mem(struct tls_config *config, const uint8_t *cert,
    size_t cert_len, const uint8_t *key, size_t key_len)
d458 3
d472 33
d625 3
a627 3
int
tls_config_set_keypair_file(struct tls_config *config,
    const char *cert_file, const char *key_file)
d633 5
d642 4
a645 3
int
tls_config_set_keypair_mem(struct tls_config *config, const uint8_t *cert,
    size_t cert_len, const uint8_t *key, size_t key_len)
d651 3
d659 34
d772 2
a773 1
tls_config_set_ocsp_staple_mem(struct tls_config *config, char *staple, size_t len)
@


1.34
log
@Introduce ticket support. To enable them it is enough to set a positive
lifetime with tls_config_set_session_lifetime(). This enables tickets
and uses an internal automatic rekeying mode for the ticket keys.

If multiple processes are involved the following functions can be used to make
tickets work accross all instances:
- tls_config_set_session_id() sets the session identifier
- tls_config_add_ticket_key() adds an encryption and authentication key

For now only the last 4 keys added will be used (unless they are too old).
If tls_config_add_ticket_key() is used the caller must ensure to add new keys
regularly. It is best to do this 4 times per session lifetime (which is also
the ticket key lifetime).

Since tickets break PFS it is best to minimize the session lifetime according
to needs.

With a lot of help, input and OK beck@@, jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.33 2016/11/11 14:02:24 jsing Exp $ */
d104 16
d137 1
a260 1
	free(config->ocsp_staple);
d683 2
a684 2
	return tls_config_load_file(&config->error, "OCSP", staple_file,
	    &config->ocsp_staple, &config->ocsp_staple_len);
d690 1
a690 1
	return set_mem(&config->ocsp_staple, &config->ocsp_staple_len, staple, len);
@


1.33
log
@Change the return value of tls_config_set_protocols() and
tls_config_set_verify_depth() from void to int. This makes them consistent
with all other tls_config_set_* functions and will allow for call time
validation to be implemented.

Rides libtls major bump.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.32 2016/11/05 15:13:26 beck Exp $ */
d180 1
d203 11
d675 88
@


1.32
log
@Add support for server side OCSP stapling to libtls.
Add support for server side OCSP stapling to netcat.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.31 2016/11/04 19:01:04 jsing Exp $ */
d197 4
a200 2
	tls_config_set_protocols(config, TLS_PROTOCOLS_DEFAULT);
	tls_config_set_verify_depth(config, 6);
d580 1
a580 1
void
d584 2
d588 1
a588 1
void
d592 2
@


1.31
log
@Make the tls_keypair_new() function a valid prototype.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.30 2016/11/04 18:59:35 jsing Exp $ */
d230 1
d644 13
@


1.30
log
@Avoid another signed vs unsigned comparison.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.29 2016/11/04 05:13:13 beck Exp $ */
d65 1
a65 1
tls_keypair_new()
@


1.29
log
@Add ocsp_require_stapling config option for tls - allows a connection
to indicate that it requires the peer to provide a stapled OCSP response
with the handshake.  Provide a "-T muststaple" for nc that uses it.
ok jsing@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.28 2016/08/22 14:55:59 jsing Exp $ */
d131 1
d147 2
d155 2
a156 1
	if (read(fd, *buf, *len) != *len) {
@


1.28
log
@Provide an API that enables server side SNI support - add the ability to
provide additional keypairs (via tls_config_add_keypair_{file,mem}()) and
allow the server to determine what servername the client requested (via
tls_conn_servername()).

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.27 2016/08/13 13:15:53 jsing Exp $ */
d621 6
@


1.27
log
@Avoid leaking memory if tls_config_set_alpn() is called multiple times
(this was in the original commit, but got reverted in the recommit).
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.26 2016/08/13 13:05:51 jsing Exp $ */
d230 12
d382 44
@


1.26
log
@Load CA, certificate and key files into memory when the appropriate
tls_config_set_*_file() function is called. This allows us to immediately
propagate useful error messages, play more nicely with privsep/pledge and
have a single code path. Instead of always loading the default CA when
tls_config_new() is called, defer and only load the default CA when
tls_configure() is invoked, if a CA has not already been specified.

ok beck@@ bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.25 2016/08/12 15:10:59 jsing Exp $ */
d314 4
a360 3

	*alpn_data = NULL;
	*alpn_len = 0;
@


1.25
log
@Add ALPN support to libtls.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.24 2016/08/02 07:47:11 jsing Exp $ */
d18 2
d22 1
d24 1
d71 2
a72 1
tls_keypair_set_cert_file(struct tls_keypair *keypair, const char *cert_file)
d74 2
a75 1
	return set_string(&keypair->cert_file, cert_file);
d86 2
a87 1
tls_keypair_set_key_file(struct tls_keypair *keypair, const char *key_file)
d89 4
a92 1
	return set_string(&keypair->key_file, key_file);
a118 1
	free((char *)keypair->cert_file);
a119 1
	free((char *)keypair->key_file);
d125 47
a185 2
	if (tls_config_set_ca_file(config, _PATH_SSL_CA_FILE) != 0)
		goto err;
a222 1
	free((char *)config->ca_file);
d374 2
a375 1
	return set_string(&config->ca_file, ca_file);
d393 2
a394 1
	return tls_keypair_set_cert_file(config->keypair, cert_file);
d481 2
a482 1
	return tls_keypair_set_key_file(config->keypair, key_file);
@


1.24
log
@Revert previous since it adds new symbols.

Requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.22 2016/07/13 16:30:48 jsing Exp $ */
d169 1
d251 66
@


1.23
log
@Add ALPN support to libtls.

ok beck@@ doug@@
@
text
@a168 1
	free(config->alpn);
a249 67
}

static int
tls_config_parse_alpn(struct tls_config *config, const char *alpn,
    char **alpn_data, size_t *alpn_len)
{
	size_t buf_len, i, len;
	char *buf = NULL;
	char *s = NULL;
	char *p, *q;

	free(*alpn_data);
	*alpn_data = NULL;
	*alpn_len = 0;

	if ((buf_len = strlen(alpn) + 1) > 65535) {
		tls_config_set_errorx(config, "alpn too large");
		goto err;
	}

	if ((buf = malloc(buf_len)) == NULL) {
		tls_config_set_errorx(config, "out of memory");
		goto err;
	}

	if ((s = strdup(alpn)) == NULL) {
		tls_config_set_errorx(config, "out of memory");
		goto err;
	}

	i = 0;
	q = s;
	while ((p = strsep(&q, ",")) != NULL) {
		if ((len = strlen(p)) == 0) {
			tls_config_set_errorx(config,
			    "alpn protocol with zero length");
			goto err;
		}
		if (len > 255) {
			tls_config_set_errorx(config,
			    "alpn protocol too long");
			goto err;
		}
		buf[i++] = len & 0xff;
		memcpy(&buf[i], p, len);
		i += len;
	}

	free(s);

	*alpn_data = buf;
	*alpn_len = buf_len;

	return (0);

 err:
	free(buf);
	free(s);

	return (-1);
}

int
tls_config_set_alpn(struct tls_config *config, const char *alpn)
{
	return tls_config_parse_alpn(config, alpn, &config->alpn,
	    &config->alpn_len);
@


1.22
log
@Split the existing TLS cipher suite groups into four:

"secure" (TLSv1.2+AEAD+PFS)
"compat" (HIGH:!aNULL)
"legacy" (HIGH:MEDIUM:!aNULL)
"insecure" (ALL:!aNULL:!eNULL)

This allows for flexibility and finer grained control, rather than having
two extremes (an issue raised by Marko Kreen some time ago).

ok beck@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.21 2016/07/07 14:09:03 jsing Exp $ */
d169 1
d251 67
@


1.21
log
@Revert previous - it introduces problems with a common privsep use case.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.20 2016/07/06 16:47:18 jsing Exp $ */
d292 1
a292 2
	else if (strcasecmp(ciphers, "compat") == 0 ||
	    strcasecmp(ciphers, "legacy") == 0)
d294 5
@


1.20
log
@Check that the given ciphers string is syntactically valid and results in
at least one matching cipher suite.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.19 2016/07/06 16:16:36 jsing Exp $ */
a17 2
#include <sys/stat.h>

a19 1
#include <fcntl.h>
a20 1
#include <unistd.h>
a59 47
static int
load_file(struct tls_error *error, const char *filetype, const char *filename,
    char **buf, size_t *len)
{
	struct stat st;
	int fd = -1;

	free(*buf);
	*buf = NULL;
	*len = 0;

	if ((fd = open(filename, O_RDONLY)) == -1) {
		tls_error_set(error, "failed to open %s file '%s'",
		    filetype, filename);
		goto fail;
	}
	if (fstat(fd, &st) != 0) {
		tls_error_set(error, "failed to stat %s file '%s'",
		    filetype, filename);
		goto fail;
	}
	*len = (size_t)st.st_size;
	if ((*buf = malloc(*len)) == NULL) {
		tls_error_set(error, "failed to allocate buffer for "
		    "%s file '%s'", filetype, filename);
		goto fail;
	}
	if (read(fd, *buf, *len) != *len) {
		tls_error_set(error, "failed to read %s file '%s'",
		    filetype, filename);
		goto fail;
	}
	close(fd);
	return 0;

 fail:
	if (fd != -1)
		close(fd);
	if (*buf != NULL)
		explicit_bzero(*buf, *len);
	free(*buf);
	*buf = NULL;
	*len = 0;

	return -1;
}

d67 1
a67 2
tls_keypair_set_cert_file(struct tls_keypair *keypair, struct tls_error *error,
    const char *cert_file)
d69 1
a69 2
	return load_file(error, "certificate", cert_file, &keypair->cert_mem,
	    &keypair->cert_len);
d80 1
a80 2
tls_keypair_set_key_file(struct tls_keypair *keypair, struct tls_error *error,
    const char *key_file)
d82 1
a82 4
	if (keypair->key_mem != NULL)
		explicit_bzero(keypair->key_mem, keypair->key_len);
	return load_file(error, "key", key_file, &keypair->key_mem,
	    &keypair->key_len);
d109 1
d111 1
d169 1
d255 1
a255 2
	return load_file(&config->error, "CA", ca_file, &config->ca_mem,
	    &config->ca_len);
d273 1
a273 2
	return tls_keypair_set_cert_file(config->keypair, &config->error,
	    cert_file);
d356 1
a356 2
	return tls_keypair_set_key_file(config->keypair, &config->error,
	    key_file);
@


1.19
log
@Always load CA, key and certificate files at the time the configuration
function is called. This simplifies code and results in a single memory
based code path being used to provide data to libssl. Errors that occur
when accessing the specified file are now detected and propagated
immediately. Since the file access now occurs when the configuration
function is called, we now play nicely with privsep/pledge.

ok beck@@ bluhm@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.18 2016/05/27 14:38:40 jsing Exp $ */
d342 2
d352 10
d363 4
@


1.18
log
@Rename some of the internal error setting functions to more closely follow
existing naming standards. Also provide functions for setting a struct
tls_error * directly (rather than having to have a struct tls * or a
struct tls_config *).
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.17 2016/05/27 14:27:22 jsing Exp $ */
d18 2
d22 1
d24 1
d64 47
d118 2
a119 1
tls_keypair_set_cert_file(struct tls_keypair *keypair, const char *cert_file)
d121 2
a122 1
	return set_string(&keypair->cert_file, cert_file);
d133 2
a134 1
tls_keypair_set_key_file(struct tls_keypair *keypair, const char *key_file)
d136 4
a139 1
	return set_string(&keypair->key_file, key_file);
a165 1
	free((char *)keypair->cert_file);
a166 1
	free((char *)keypair->key_file);
a223 1
	free((char *)config->ca_file);
d309 2
a310 1
	return set_string(&config->ca_file, ca_file);
d328 2
a329 1
	return tls_keypair_set_cert_file(config->keypair, cert_file);
d396 2
a397 1
	return tls_keypair_set_key_file(config->keypair, key_file);
@


1.17
log
@Avoid leaking ca_mem when freeing a tls_config.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.16 2016/04/28 17:05:59 jsing Exp $ */
d309 1
a309 1
		tls_set_config_errorx(config, "invalid dhe param '%s'", params);
d328 1
a328 1
		tls_set_config_errorx(config, "invalid ecdhe curve '%s'", name);
@


1.16
log
@Factor our the keypair handling in libtls. This results in more readable
and self-contained code, while preparing for the ability to handle
multiple keypairs. Also provide two additional functions that allow
a public certificate and private key to be set with a single function
call.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.15 2016/04/28 16:48:44 jsing Exp $ */
d170 1
@


1.15
log
@Rework the error handling in libtls so that we can associate errors with
both configuration and contexts. This allows us to propagate errors that
occur during configuration, rather than either just failing with no reason
or delaying the failure until it can be propagated via the tls context.

Also provide a tls_config_error() function for retrieving the last error
from a tls_config *.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.14 2015/09/29 10:17:04 deraadt Exp $ */
d60 57
d125 3
d157 2
d162 4
a165 1
	tls_config_clear_keys(config);
a170 2
	free((char *)config->cert_file);
	free(config->cert_mem);
a171 2
	free((char *)config->key_file);
	free(config->key_mem);
d185 5
a190 2
	tls_config_set_cert_mem(config, NULL, 0);
	tls_config_set_key_mem(config, NULL, 0);
d272 1
a272 1
	return set_string(&config->cert_file, cert_file);
d279 1
a279 1
	return set_mem(&config->cert_mem, &config->cert_len, cert, len);
d339 1
a339 1
	return set_string(&config->key_file, key_file);
d346 25
a370 3
	if (config->key_mem)
		explicit_bzero(config->key_mem, config->key_len);
	return set_mem(&config->key_mem, &config->key_len, key, len);
@


1.14
log
@clean some ugly intendation warts
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.13 2015/09/14 16:16:38 jsing Exp $ */
d102 2
d115 6
d243 2
a244 1
	else
d246 1
d262 2
a263 1
	else if ((nid = OBJ_txt2nid(name)) == NID_undef)
d265 1
@


1.13
log
@Provide tls_config_insecure_noverifytime() in order to be able to disable
certificate validity checking.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.12 2015/09/10 09:10:42 jsing Exp $ */
d82 1
a82 1
	
@


1.12
log
@Add support for preferring the server's cipher list or the client's cipher
list. Prefer the server's cipher list by default.

Based on a diff from Kyle Thompson <jmp at giga dot moe>.

ok beck@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.11 2015/09/09 19:49:07 jsing Exp $ */
d312 6
d322 1
@


1.11
log
@Indent labels with a space so that diff -p is more friendly.

Requested by bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.10 2015/09/09 19:23:04 beck Exp $ */
d83 2
d285 12
@


1.10
log
@Add client certificate support. Still needs a few tweaks but this will
ride upcoming minor bump
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.9 2015/02/22 15:09:54 jsing Exp $ */
d87 1
a87 1
err:
@


1.9
log
@Rename tls_config_insecure_noverifyhost() to
tls_config_insecure_noverifyname(), so that it is more accurate and keeps
inline with the distinction between DNS hostname and server name.

Requested by tedu@@ during s2k15.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.8 2015/02/22 14:59:37 jsing Exp $ */
d302 12
@


1.8
log
@Check return values when setting dheparams and ecdhecurve for the default
configuration.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.7 2015/02/22 14:50:41 jsing Exp $ */
a284 1
/* XXX - rename to noverifyname. */
d286 1
a286 1
tls_config_insecure_noverifyhost(struct tls_config *config)
d288 1
a288 1
	config->verify_name = 0;
d292 1
a292 1
tls_config_insecure_noverifycert(struct tls_config *config)
d294 1
a294 1
	config->verify_cert = 0;
@


1.7
log
@In the interests of being secure by default, make the default TLS ciphers
be those that are TLSv1.2 with AEAD and PFS. Provide a "compat" mode that
allows the previous default ciphers to be selected.

Discussed with tedu@@ during s2k15.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.6 2015/02/12 04:35:17 jsing Exp $ */
d71 9
a79 10
	if (tls_config_set_ca_file(config, _PATH_SSL_CA_FILE) != 0) {
		tls_config_free(config);
		return (NULL);
	}
	tls_config_set_dheparams(config, "none");
	tls_config_set_ecdhecurve(config, "auto");
	if (tls_config_set_ciphers(config, "secure") != 0) {
		tls_config_free(config);
		return (NULL);
	}
d86 4
@


1.6
log
@Add a tls_config_parse_protocols() function that allows a protocols string
to be converted into a libtls protocols value. This allows for things like:

	"tlsv1.0,tlsv1.1" (TLSv1.0 and TLSv1.1)
	"all,!tlsv1.0" (all protocols except TLSv1.0)

Discussed with tedu@@ and reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.5 2015/02/12 04:31:27 jsing Exp $ */
d77 4
d208 8
@


1.5
log
@Fix handling of "legacy" mode for tls_config_set_dheparams().

Found by reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.4 2015/02/11 06:46:33 jsing Exp $ */
d18 1
d110 58
@


1.4
log
@Be consistent with naming - only use "host" and "hostname" when referring
to an actual host and use "servername" when referring to the name of the
TLS server that we expect to be indentified in the server certificate.

Likewise, rename verify_host to verify_name and use the term "name"
throughout the verification code (rather than host or hostname).

Requested by and ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.3 2015/02/07 06:19:26 jsing Exp $ */
d157 1
a157 1
	else if (strcmp(params, "legacy"))
@


1.3
log
@Add tls_config_set_dheparams() to allow specification of the parameters to
use for DHE. This enables the use of DHE cipher suites.

Rename tls_config_set_ecdhcurve() to tls_config_set_ecdhecurve() since it
is only used to specify the curve for ephemeral ECDH.

Discussed with reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.2 2015/01/22 09:16:24 reyk Exp $ */
d211 1
d215 1
a215 1
	config->verify_host = 0;
a226 1
	config->verify_host = 1;
d228 1
@


1.2
log
@Allow to to load the CA chain directly from memory instead of
specifying a file.  This enables CA verification in privsep'ed
processes that are running chroot'ed without direct access to the
certificate files.

With feedback, tests, and OK from bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.1 2014/10/31 13:46:17 jsing Exp $ */
d74 2
a75 1
	tls_config_set_ecdhcurve(config, "auto");
d149 20
a168 1
tls_config_set_ecdhcurve(struct tls_config *config, const char *name)
d172 1
a172 1
	if (name == NULL)
d179 1
a179 1
	config->ecdhcurve = nid;
@


1.1
log
@Rename libressl to libtls to avoid confusion and to make it easier to
distinguish between LibreSSL (the project) and libressl (the library).

Discussed with many.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_config.c,v 1.14 2014/10/03 14:14:40 tedu Exp $ */
d105 1
d120 6
@

