head	1.6;
access;
symbols
	OPENBSD_6_1:1.5.0.4
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.3.0.4
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.2.0.6
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2017.05.06.20.57.45;	author jsing;	state Exp;
branches;
next	1.5;
commitid	7knj8PI0VBvDV9Tw;

1.5
date	2016.11.04.15.59.16;	author jsing;	state Exp;
branches;
next	1.4;
commitid	QfENYhrH2M3pJBVT;

1.4
date	2016.10.03.04.13.58;	author bcook;	state Exp;
branches;
next	1.3;
commitid	M4nkiebLtwIn1YCP;

1.3
date	2015.09.09.19.49.07;	author jsing;	state Exp;
branches;
next	1.2;
commitid	8fjywsQemyYNWdJq;

1.2
date	2015.02.07.23.25.37;	author reyk;	state Exp;
branches;
next	1.1;
commitid	UD3ba1TAdmMVSwwo;

1.1
date	2014.10.31.13.46.17;	author jsing;	state Exp;
branches;
next	;
commitid	y63FmUITd26yVanM;


desc
@@


1.6
log
@Provide a tls_unload_file() function, that frees the memory returned from
a tls_load_file() call, ensuring that it the contents become inaccessible.
This is specifically needed on platforms where the library allocators may
be different from the application allocator.

ok beck@@
@
text
@/* $OpenBSD: tls_util.c,v 1.5 2016/11/04 15:59:16 jsing Exp $ */
/*
 * Copyright (c) 2014 Joel Sing <jsing@@openbsd.org>
 * Copyright (c) 2015 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

#include "tls.h"
#include "tls_internal.h"

/*
 * Extract the host and port from a colon separated value. For a literal IPv6
 * address the address must be contained with square braces. If a host and
 * port are successfully extracted, the function will return 0 and the
 * caller is responsible for freeing the host and port. If no port is found
 * then the function will return 1, with both host and port being NULL.
 * On memory allocation failure -1 will be returned.
 */
int
tls_host_port(const char *hostport, char **host, char **port)
{
	char *h, *p, *s;
	int rv = 1;

	*host = NULL;
	*port = NULL;

	if ((s = strdup(hostport)) == NULL)
		goto fail;

	h = p = s;

	/* See if this is an IPv6 literal with square braces. */
	if (p[0] == '[') {
		h++;
		if ((p = strchr(s, ']')) == NULL)
			goto done;
		*p++ = '\0';
	}

	/* Find the port seperator. */
	if ((p = strchr(p, ':')) == NULL)
		goto done;

	/* If there is another separator then we have issues. */
	if (strchr(p + 1, ':') != NULL)
		goto done;

	*p++ = '\0';

	if (asprintf(host, "%s", h) == -1)
		goto fail;
	if (asprintf(port, "%s", p) == -1)
		goto fail;

	rv = 0;
	goto done;

 fail:
	free(*host);
	*host = NULL;
	free(*port);
	*port = NULL;
	rv = -1;

 done:
	free(s);

	return (rv);
}

static int
tls_password_cb(char *buf, int size, int rwflag, void *u)
{
	size_t len;

	if (size < 0)
		return (0);

	if (u == NULL) {
		memset(buf, 0, size);
		return (0);
	}

	if ((len = strlcpy(buf, u, size)) >= (size_t)size)
		return (0);

	return (len);
}

uint8_t *
tls_load_file(const char *name, size_t *len, char *password)
{
	FILE *fp;
	EVP_PKEY *key = NULL;
	BIO *bio = NULL;
	char *data;
	uint8_t *buf = NULL;
	struct stat st;
	size_t size;
	int fd = -1;
	ssize_t n;

	*len = 0;

	if ((fd = open(name, O_RDONLY)) == -1)
		return (NULL);

	/* Just load the file into memory without decryption */
	if (password == NULL) {
		if (fstat(fd, &st) != 0)
			goto fail;
		if (st.st_size < 0)
			goto fail;
		size = (size_t)st.st_size;
		if ((buf = malloc(size)) == NULL)
			goto fail;
		n = read(fd, buf, size);
		if (n < 0 || (size_t)n != size)
			goto fail;
		close(fd);
		goto done;
	}

	/* Or read the (possibly) encrypted key from file */
	if ((fp = fdopen(fd, "r")) == NULL)
		goto fail;
	fd = -1;

	key = PEM_read_PrivateKey(fp, NULL, tls_password_cb, password);
	fclose(fp);
	if (key == NULL)
		goto fail;

	/* Write unencrypted key to memory buffer */
	if ((bio = BIO_new(BIO_s_mem())) == NULL)
		goto fail;
	if (!PEM_write_bio_PrivateKey(bio, key, NULL, NULL, 0, NULL, NULL))
		goto fail;
	if ((size = BIO_get_mem_data(bio, &data)) <= 0)
		goto fail;
	if ((buf = calloc(1, size)) == NULL)
		goto fail;
	memcpy(buf, data, size);

	BIO_free_all(bio);
	EVP_PKEY_free(key);

 done:
	*len = size;
	return (buf);

 fail:
	free(buf);
	if (fd != -1)
		close(fd);
	if (bio != NULL)
		BIO_free_all(bio);
	if (key != NULL)
		EVP_PKEY_free(key);

	return (NULL);
}

void
tls_unload_file(uint8_t *buf, size_t len)
{
	freezero(buf, len);
}
@


1.5
log
@Address some signed vs unsigned warnings and check that an integer value
is positive before passing it to several functions as a size_t.
Additionally, in tls_load_file() there is not much point using calloc(),
when we're immediately reading into the buffer (having an extra byte for
NUL termination seems pointless given the API).

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_util.c,v 1.4 2016/10/03 04:13:58 bcook Exp $ */
d180 6
@


1.4
log
@use the same type for buf as the return type in tls_load_file

ok tedu@@, noted by kinichiro
@
text
@d1 1
a1 1
/* $OpenBSD: tls_util.c,v 1.3 2015/09/09 19:49:07 jsing Exp $ */
d92 5
a96 1
	size_t	len;
d101 1
d104 1
d119 1
d130 2
d133 1
a133 1
		if ((buf = calloc(1, size + 1)) == NULL)
d135 2
a136 1
		if (read(fd, buf, size) != size)
@


1.3
log
@Indent labels with a space so that diff -p is more friendly.

Requested by bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_util.c,v 1.2 2015/02/07 23:25:37 reyk Exp $ */
d108 2
a109 1
	char *data, *buf = NULL;
@


1.2
log
@Add tls_load_file() as a helper to load certificates or encrypted keys
into memory.  This can be used for tls_config_set_ca_mem(),
tls_config_set_cert_mem() or tls_config_set_key_mem().

With input from jsing@@, tedu@@ and henning@@

OK tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_util.c,v 1.1 2014/10/31 13:46:17 jsing Exp $ */
d76 1
a76 1
fail:
d83 1
a83 1
done:
@


1.1
log
@Rename libressl to libtls to avoid confusion and to make it easier to
distinguish between LibreSSL (the project) and libressl (the library).

Discussed with many.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_util.c,v 1.2 2014/08/05 12:46:16 jsing Exp $ */
d4 1
d19 2
d22 2
d25 1
d87 82
@

