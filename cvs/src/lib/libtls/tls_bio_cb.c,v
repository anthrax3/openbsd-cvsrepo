head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.2
	OPENBSD_6_1_BASE:1.19;
locks; strict;
comment	@ * @;


1.19
date	2017.01.12.16.18.39;	author jsing;	state Exp;
branches;
next	1.18;
commitid	ktJFM3fZY92aw7Y9;

1.18
date	2017.01.12.16.17.22;	author jsing;	state Exp;
branches;
next	1.17;
commitid	hJ7LUWc2BxOocKI4;

1.17
date	2017.01.12.16.08.49;	author jsing;	state Exp;
branches;
next	1.16;
commitid	ppPZeDb0weNWP2er;

1.16
date	2017.01.12.16.01.47;	author jsing;	state Exp;
branches;
next	1.15;
commitid	uei7IOBmxWIoEfH1;

1.15
date	2017.01.12.15.58.56;	author jsing;	state Exp;
branches;
next	1.14;
commitid	BHTeXmF7ZzTghPmg;

1.14
date	2016.11.04.15.45.55;	author jsing;	state Exp;
branches;
next	1.13;
commitid	BGsswa6dlrh5Ks8R;

1.13
date	2016.11.04.15.43.46;	author jsing;	state Exp;
branches;
next	1.12;
commitid	gYCEiDpCFt9Wecbd;

1.12
date	2016.11.04.15.42.29;	author jsing;	state Exp;
branches;
next	1.11;
commitid	NZZs2V14r4heyBz2;

1.11
date	2016.11.04.15.39.16;	author jsing;	state Exp;
branches;
next	1.10;
commitid	dr9eXQq1nH1LDFwt;

1.10
date	2016.11.04.15.37.49;	author jsing;	state Exp;
branches;
next	1.9;
commitid	ntVAJ3oJvAinq1BV;

1.9
date	2016.11.04.10.54.25;	author jsing;	state Exp;
branches;
next	1.8;
commitid	HuLITeNyHr20DgMI;

1.8
date	2016.11.04.10.51.35;	author jsing;	state Exp;
branches;
next	1.7;
commitid	L1uW9P9nsE7Tyu7u;

1.7
date	2016.11.04.10.50.32;	author jsing;	state Exp;
branches;
next	1.6;
commitid	ukUMOKjwuw6n5gCt;

1.6
date	2016.11.04.08.17.43;	author jsing;	state Exp;
branches;
next	1.5;
commitid	0n2OEwAABcibUXEg;

1.5
date	2016.09.14.11.30.41;	author bcook;	state Exp;
branches;
next	1.4;
commitid	Ml50cEeFjwcBiKfs;

1.4
date	2016.09.14.11.26.56;	author bcook;	state Exp;
branches;
next	1.3;
commitid	WEmWn0LmNI85aQJS;

1.3
date	2016.09.04.13.17.08;	author jsing;	state Exp;
branches;
next	1.2;
commitid	VCs88Wcgh3zi5rtW;

1.2
date	2016.09.04.12.54.33;	author jsing;	state Exp;
branches;
next	1.1;
commitid	2PBBloDjlZMhqgf5;

1.1
date	2016.09.04.12.26.43;	author bcook;	state Exp;
branches;
next	;
commitid	pRMpDkZhqg5jtYzf;


desc
@@


1.19
log
@Inline strlen() call to reduce/simplify code.
@
text
@/* $OpenBSD: tls_bio_cb.c,v 1.18 2017/01/12 16:17:22 jsing Exp $ */
/*
 * Copyright (c) 2016 Tobias Pape <tobias@@netshed.de>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>

#include <openssl/bio.h>

#include <tls.h>
#include "tls_internal.h"

static int bio_cb_write(BIO *bio, const char *buf, int num);
static int bio_cb_read(BIO *bio, char *buf, int size);
static int bio_cb_puts(BIO *bio, const char *str);
static long bio_cb_ctrl(BIO *bio, int cmd, long num, void *ptr);

static BIO_METHOD bio_cb_method = {
	.type = BIO_TYPE_MEM,
	.name = "libtls_callbacks",
	.bwrite = bio_cb_write,
	.bread = bio_cb_read,
	.bputs = bio_cb_puts,
	.ctrl = bio_cb_ctrl,
};

static BIO_METHOD *
bio_s_cb(void)
{
	return (&bio_cb_method);
}

static int
bio_cb_puts(BIO *bio, const char *str)
{
	return (bio_cb_write(bio, str, strlen(str)));
}

static long
bio_cb_ctrl(BIO *bio, int cmd, long num, void *ptr)
{
	long ret = 1;

	switch (cmd) {
	case BIO_CTRL_GET_CLOSE:
		ret = (long)bio->shutdown;
		break;
	case BIO_CTRL_SET_CLOSE:
		bio->shutdown = (int)num;
		break;
	case BIO_CTRL_DUP:
	case BIO_CTRL_FLUSH:
		break;
	case BIO_CTRL_INFO:
	case BIO_CTRL_GET:
	case BIO_CTRL_SET:
	default:
		ret = BIO_ctrl(bio->next_bio, cmd, num, ptr);
	}

	return (ret);
}

static int
bio_cb_write(BIO *bio, const char *buf, int num)
{
	struct tls *ctx = bio->ptr;
	int rv;

	BIO_clear_retry_flags(bio);
	rv = (ctx->write_cb)(ctx, buf, num, ctx->cb_arg);
	if (rv == TLS_WANT_POLLIN) {
		BIO_set_retry_read(bio);
		rv = -1;
	} else if (rv == TLS_WANT_POLLOUT) {
		BIO_set_retry_write(bio);
		rv = -1;
	}
	return (rv);
}

static int
bio_cb_read(BIO *bio, char *buf, int size)
{
	struct tls *ctx = bio->ptr;
	int rv;

	BIO_clear_retry_flags(bio);
	rv = (ctx->read_cb)(ctx, buf, size, ctx->cb_arg);
	if (rv == TLS_WANT_POLLIN) {
		BIO_set_retry_read(bio);
		rv = -1;
	} else if (rv == TLS_WANT_POLLOUT) {
		BIO_set_retry_write(bio);
		rv = -1;
	}
	return (rv);
}

int
tls_set_cbs(struct tls *ctx, tls_read_cb read_cb, tls_write_cb write_cb,
    void *cb_arg)
{
	int rv = -1;
	BIO *bio;

	if (read_cb == NULL || write_cb == NULL) {
		tls_set_errorx(ctx, "no callbacks provided");
		goto err;
	}

	ctx->read_cb = read_cb;
	ctx->write_cb = write_cb;
	ctx->cb_arg = cb_arg;

	if ((bio = BIO_new(bio_s_cb())) == NULL) {
		tls_set_errorx(ctx, "failed to create callback i/o");
		goto err;
	}
	bio->ptr = ctx;
	bio->init = 1;

	SSL_set_bio(ctx->ssl_conn, bio, bio);

	rv = 0;

 err:
	return (rv);
}
@


1.18
log
@Inline tls_get_new_cb_bio() from the only place that it gets called,
simplifying the code. Also check the provided read and write callbacks
before assigning to the context.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.17 2017/01/12 16:08:49 jsing Exp $ */
d50 1
a50 4
	int n;

	n = strlen(str);
	return (bio_cb_write(bio, str, n));
@


1.17
log
@Simplify the TLS callback BIO code - a pointer to the tls context can be
stored directly in bio->ptr, rather than allocating and deallocating an
intermediate struct.

Diff from Marko Kreen <markokr at gmail dot com> - thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.16 2017/01/12 16:01:47 jsing Exp $ */
a116 20
static BIO *
tls_get_new_cb_bio(struct tls *ctx)
{
	BIO *bio;

	if (ctx->read_cb == NULL || ctx->write_cb == NULL) {
		tls_set_errorx(ctx, "no callbacks registered");
		return (NULL);
	}
	if ((bio = BIO_new(bio_s_cb())) == NULL) {
		tls_set_errorx(ctx, "failed to create callback i/o");
		return (NULL);
	}

	bio->ptr = ctx;
	bio->init = 1;

	return (bio);
}

d124 5
d133 2
a134 1
	if ((bio = tls_get_new_cb_bio(ctx)) == NULL)
d136 3
@


1.16
log
@If tls_get_new_cb_bio() fails, an error will already be set.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.14 2016/11/04 15:45:55 jsing Exp $ */
a30 8
static int bio_cb_new(BIO *bio);
static int bio_cb_free(BIO *bio);

struct bio_cb {
	int (*write_cb)(BIO *bio, const char *buf, int num, void *cb_arg);
	int (*read_cb)(BIO *bio, char *buf, int size, void *cb_arg);
	void *cb_arg;
};
a38 2
	.create = bio_cb_new,
	.destroy = bio_cb_free,
a47 46
bio_cb_new(BIO *bio)
{
	struct bio_cb *bcb;

	if ((bcb = calloc(1, sizeof(struct bio_cb))) == NULL)
		return (0);

	bio->shutdown = 1;
	bio->init = 1;
	bio->num = -1;
	bio->ptr = bcb;

	return (1);
}

static int
bio_cb_free(BIO *bio)
{
	if (bio == NULL)
		return (0);

	if (bio->shutdown) {
		if ((bio->init) && (bio->ptr != NULL)) {
			free(bio->ptr);
			bio->ptr = NULL;
		}
	}

	return (1);
}

static int
bio_cb_read(BIO *bio, char *buf, int size)
{
	struct bio_cb *bcb = bio->ptr;
	return (bcb->read_cb(bio, buf, size, bcb->cb_arg));
}

static int
bio_cb_write(BIO *bio, const char *buf, int num)
{
	struct bio_cb *bcb = bio->ptr;
	return (bcb->write_cb(bio, buf, num, bcb->cb_arg));
}

static int
d82 1
a82 1
tls_bio_write_cb(BIO *bio, const char *buf, int num, void *cb_arg)
d84 1
a84 1
	struct tls *ctx = cb_arg;
d100 1
a100 1
tls_bio_read_cb(BIO *bio, char *buf, int size, void *cb_arg)
d102 1
a102 1
	struct tls *ctx = cb_arg;
a119 1
	struct bio_cb *bcb;
d131 2
a132 4
	bcb = (struct bio_cb *)bio->ptr;
	bcb->read_cb = tls_bio_read_cb;
	bcb->write_cb = tls_bio_write_cb;
	bcb->cb_arg = ctx;
@


1.15
log
@If no callbacks are specified, return after setting an error rather than
continuing on.

Also noticed by Marko Kreen.
@
text
@a182 1

d207 1
a207 2
	if ((bio = tls_get_new_cb_bio(ctx)) == NULL) {
		tls_set_errorx(ctx, "failed to create callback i/o");
a208 1
	}
@


1.14
log
@Assign and test, as is consistent with the rest of the libtls code.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.13 2016/11/04 15:43:46 jsing Exp $ */
d179 1
a179 1
	if (ctx->read_cb == NULL || ctx->write_cb == NULL)
d181 2
@


1.13
log
@Use a consistent name for struct bio_cb * variables.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.12 2016/11/04 15:42:29 jsing Exp $ */
d62 1
a62 2
	bcb = calloc(1, sizeof(struct bio_cb));
	if (bcb == NULL)
d182 1
a182 2
	bio = BIO_new(bio_s_cb());
	if (bio == NULL) {
d206 1
a206 2
	bio = tls_get_new_cb_bio(ctx);
	if (bio == NULL) {
@


1.12
log
@Rename struct bio_cb_st to struct bio_cb.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.11 2016/11/04 15:39:16 jsing Exp $ */
d177 1
a177 1
	struct bio_cb *b;
d189 4
a192 4
	b = (struct bio_cb *)bio->ptr;
	b->read_cb = tls_bio_read_cb;
	b->write_cb = tls_bio_write_cb;
	b->cb_arg = ctx;
@


1.11
log
@Do not cast a pointer to a struct, to a char * when assigning to a void *.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.10 2016/11/04 15:37:49 jsing Exp $ */
d34 1
a34 1
struct bio_cb_st {
d60 1
a60 1
	struct bio_cb_st *bcb;
d62 1
a62 1
	bcb = calloc(1, sizeof(struct bio_cb_st));
d93 1
a93 1
	struct bio_cb_st *bcb = bio->ptr;
d100 1
a100 1
	struct bio_cb_st *bcb = bio->ptr;
d177 1
a177 1
	struct bio_cb_st *b;
d189 1
a189 1
	b = (struct bio_cb_st *)bio->ptr;
@


1.10
log
@Use a consistent name for a BIO *, rather than having four different names
in the same file.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.8 2016/11/04 10:51:35 jsing Exp $ */
d69 1
a69 1
	bio->ptr = (char *)bcb;
@


1.9
log
@There's not much point having three static functions that do a cast and
assign a pointer, when we can just inline the three and do one cast
followed by three pointer assignments.
@
text
@d27 6
a32 6
static int bio_cb_write(BIO *b, const char *buf, int num);
static int bio_cb_read(BIO *b, char *buf, int size);
static int bio_cb_puts(BIO *b, const char *str);
static long bio_cb_ctrl(BIO *b, int cmd, long num, void *ptr);
static int bio_cb_new(BIO *b);
static int bio_cb_free(BIO *data);
d35 2
a36 2
	int (*write_cb)(BIO *h, const char *buf, int num, void *cb_arg);
	int (*read_cb)(BIO *h, char *buf, int size, void *cb_arg);
d58 1
a58 1
bio_cb_new(BIO *bi)
d66 4
a69 4
	bi->shutdown = 1;
	bi->init = 1;
	bi->num = -1;
	bi->ptr = (char *)bcb;
d75 1
a75 1
bio_cb_free(BIO *bi)
d77 1
a77 1
	if (bi == NULL)
d80 4
a83 4
	if (bi->shutdown) {
		if ((bi->init) && (bi->ptr != NULL)) {
			free(bi->ptr);
			bi->ptr = NULL;
d91 1
a91 1
bio_cb_read(BIO *b, char *buf, int size)
d93 2
a94 2
	struct bio_cb_st *bcb = b->ptr;
	return (bcb->read_cb(b, buf, size, bcb->cb_arg));
d98 1
a98 1
bio_cb_write(BIO *b, const char *buf, int num)
d100 2
a101 2
	struct bio_cb_st *bcb = b->ptr;
	return (bcb->write_cb(b, buf, num, bcb->cb_arg));
d105 1
a105 1
bio_cb_puts(BIO *b, const char *str)
d110 1
a110 1
	return (bio_cb_write(b, str, n));
d114 1
a114 1
bio_cb_ctrl(BIO *b, int cmd, long num, void *ptr)
d120 1
a120 1
		ret = (long)b->shutdown;
d123 1
a123 1
		b->shutdown = (int)num;
d132 1
a132 1
		ret = BIO_ctrl(b->next_bio, cmd, num, ptr);
d139 1
a139 1
tls_bio_write_cb(BIO *h, const char *buf, int num, void *cb_arg)
d144 1
a144 1
	BIO_clear_retry_flags(h);
d147 1
a147 1
		BIO_set_retry_read(h);
d150 1
a150 1
		BIO_set_retry_write(h);
d157 1
a157 1
tls_bio_read_cb(BIO *h, char *buf, int size, void *cb_arg)
d162 1
a162 1
	BIO_clear_retry_flags(h);
d165 1
a165 1
		BIO_set_retry_read(h);
d168 1
a168 1
		BIO_set_retry_write(h);
d178 2
a179 1
	BIO *bcb;
d183 2
a184 2
	bcb = BIO_new(bio_s_cb());
	if (bcb == NULL) {
d189 1
a189 1
	b = (struct bio_cb_st *)bcb->ptr;
d194 1
a194 1
	return (bcb);
d202 2
a203 1
	BIO *bcb;
d208 2
a209 2
	bcb = tls_get_new_cb_bio(ctx);
	if (bcb == NULL) {
d214 1
a214 1
	SSL_set_bio(ctx->ssl_conn, bcb, bcb);
@


1.8
log
@Do not mix declarations and code.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.7 2016/11/04 10:50:32 jsing Exp $ */
a57 29
bio_set_write_cb(BIO *bi,
    int (*write_cb)(BIO *h, const char *buf, int num, void *cb_arg))
{
	struct bio_cb_st *b;
	b = (struct bio_cb_st *)bi->ptr;
	b->write_cb = write_cb;
	return (0);
}

static int
bio_set_read_cb(BIO *bi,
    int (*read_cb)(BIO *h, char *buf, int size, void *cb_arg))
{
	struct bio_cb_st *b;
	b = (struct bio_cb_st *)bi->ptr;
	b->read_cb = read_cb;
	return (0);
}

static int
bio_set_cb_arg(BIO *bi, void *cb_arg)
{
	struct bio_cb_st *b;
	b = (struct bio_cb_st *)bi->ptr;
	b->cb_arg = cb_arg;
	return (0);
}

static int
d177 1
d188 4
a191 3
	bio_set_write_cb(bcb, tls_bio_write_cb);
	bio_set_read_cb(bcb, tls_bio_read_cb);
	bio_set_cb_arg(bcb, ctx);
@


1.7
log
@Rename the internal bio related functions so that they have a common
prefix. Makes the code more readable and removes shadowing.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.6 2016/11/04 08:17:43 jsing Exp $ */
d171 2
d174 1
a174 1
	int rv = (ctx->write_cb)(ctx, buf, num, ctx->cb_arg);
d189 2
d192 1
a192 1
	int rv = (ctx->read_cb)(ctx, buf, size, ctx->cb_arg);
@


1.6
log
@There's not much point in casting a void * to a specific type just before
calling free().

ok beck@@ ingo@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.5 2016/09/14 11:30:41 bcook Exp $ */
d27 6
a32 6
static int write_cb(BIO *b, const char *buf, int num);
static int read_cb(BIO *b, char *buf, int size);
static int puts_cb(BIO *b, const char *str);
static long ctrl_cb(BIO *b, int cmd, long num, void *ptr);
static int new_cb(BIO *b);
static int free_cb(BIO *data);
d40 1
a40 1
static BIO_METHOD cb_method = {
d43 6
a48 6
	.bwrite = write_cb,
	.bread = read_cb,
	.bputs = puts_cb,
	.ctrl = ctrl_cb,
	.create = new_cb,
	.destroy = free_cb
d54 1
a54 1
	return (&cb_method);
d87 1
a87 1
new_cb(BIO *bi)
d104 1
a104 1
free_cb(BIO *bi)
d120 1
a120 1
read_cb(BIO *b, char *buf, int size)
d127 1
a127 1
write_cb(BIO *b, const char *buf, int num)
d134 1
a134 1
puts_cb(BIO *b, const char *str)
d139 1
a139 1
	return (write_cb(b, str, n));
d143 1
a143 1
ctrl_cb(BIO *b, int cmd, long num, void *ptr)
@


1.5
log
@Handle the FLUSH BIO cntl, that happens at the end of SSL handshakes.

from Tobias Pape
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.4 2016/09/14 11:26:56 bcook Exp $ */
d111 1
a111 3
			struct bio_cb_st *b;
			b = (struct bio_cb_st *)bi->ptr;
			free(b);
@


1.4
log
@Allow callback read/write functions to set TLS_WANT_POLLOUT/POLLIN.

from Tobias Pape
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.3 2016/09/04 13:17:08 jsing Exp $ */
d157 1
@


1.3
log
@Sort headers and use the installed tls.h, rather than the local one.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_bio_cb.c,v 1.2 2016/09/04 12:54:33 jsing Exp $ */
d172 10
a181 1
	return (ctx->write_cb)(ctx, buf, num, ctx->cb_arg);
d188 10
a197 1
	return (ctx->read_cb)(ctx, buf, size, ctx->cb_arg);
@


1.2
log
@$OpenBSD$ tag
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d18 1
a20 1
#include <fcntl.h>
d22 3
a24 1
#include "tls.h"
a25 2

#include <openssl/bio.h>
@


1.1
log
@Add callback-based interface to libtls.

This allows working with buffers and callback functions instead of directly on
sockets or file descriptors.
Original patch from Tobias Pape <tobias_at_netshed.de>.
ok beck@@
@
text
@d1 1
a1 1
/* $ID$ */
@

