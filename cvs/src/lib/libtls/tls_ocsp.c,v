head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.4
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11;
locks; strict;
comment	@ * @;


1.16
date	2017.09.20.17.05.17;	author jsing;	state Exp;
branches;
next	1.15;
commitid	o6GWlV1Lb1RLZUMT;

1.15
date	2017.09.20.16.52.37;	author jsing;	state Exp;
branches;
next	1.14;
commitid	QD7SyWczPJqDEP03;

1.14
date	2017.09.20.16.38.23;	author jsing;	state Exp;
branches;
next	1.13;
commitid	lXvDWCLLLB1Un3ll;

1.13
date	2017.09.20.16.36.45;	author jsing;	state Exp;
branches;
next	1.12;
commitid	mM0wSVAArdW3dooh;

1.12
date	2017.05.16.05.52.52;	author claudio;	state Exp;
branches;
next	1.11;
commitid	Y7Yu9z9lIh6pJo1Q;

1.11
date	2017.01.29.17.52.11;	author beck;	state Exp;
branches;
next	1.10;
commitid	DZ2gL9MkhCf6eTgX;

1.10
date	2017.01.27.07.03.27;	author tom;	state Exp;
branches;
next	1.9;
commitid	slOBNDigsyjRr000;

1.9
date	2016.11.05.15.13.26;	author beck;	state Exp;
branches;
next	1.8;
commitid	3VJnu6rXiOGWa3uh;

1.8
date	2016.11.05.14.50.05;	author beck;	state Exp;
branches;
next	1.7;
commitid	vIHPrOGMa5sQTHt5;

1.7
date	2016.11.04.18.07.24;	author beck;	state Exp;
branches;
next	1.6;
commitid	pAy02smoQCuRvYaT;

1.6
date	2016.11.04.05.13.13;	author beck;	state Exp;
branches;
next	1.5;
commitid	vHqLGL1n0DAh4s4y;

1.5
date	2016.11.03.12.54.16;	author beck;	state Exp;
branches;
next	1.4;
commitid	3tcXryionRDZcT0q;

1.4
date	2016.11.03.08.51.56;	author beck;	state Exp;
branches;
next	1.3;
commitid	lJDqspiUUphL2t9d;

1.3
date	2016.11.02.17.41.15;	author beck;	state Exp;
branches;
next	1.2;
commitid	zrIIoucnQRyZb6j0;

1.2
date	2016.11.02.17.35.10;	author beck;	state Exp;
branches;
next	1.1;
commitid	KgDdI4KZ7IuCNHre;

1.1
date	2016.11.02.15.18.42;	author beck;	state Exp;
branches;
next	;
commitid	OsrmWrsuHXqdXb2Z;


desc
@@


1.16
log
@Keep track of which keypair is in use by a TLS context.

This fixes a bug where by a TLS server with SNI would always only return
the OCSP staple for the default keypair, rather than returning the OCSP
staple associated with the keypair that was selected via SNI.

Issue reported by William Graeber and confirmed by Andreas Bartelt.

Fix tested by William Graeber and Andreas Bartelt - thanks!
@
text
@/*
 * Copyright (c) 2015 Marko Kreen <markokr@@gmail.com>
 * Copyright (c) 2016 Bob Beck <beck@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <arpa/inet.h>
#include <netinet/in.h>

#include <openssl/err.h>
#include <openssl/ocsp.h>
#include <openssl/x509.h>

#include <tls.h>
#include "tls_internal.h"

#define MAXAGE_SEC (14*24*60*60)
#define JITTER_SEC (60)

/*
 * State for request.
 */

static struct tls_ocsp *
tls_ocsp_new(void)
{
	return (calloc(1, sizeof(struct tls_ocsp)));
}

void
tls_ocsp_free(struct tls_ocsp *ocsp)
{
	if (ocsp == NULL)
		return;

	X509_free(ocsp->main_cert);
	ocsp->main_cert = NULL;
	free(ocsp->ocsp_result);
	ocsp->ocsp_result = NULL;
	free(ocsp->ocsp_url);
	ocsp->ocsp_url = NULL;
	free(ocsp);
}

static int
tls_ocsp_asn1_parse_time(struct tls *ctx, ASN1_GENERALIZEDTIME *gt, time_t *gt_time)
{
	struct tm tm;

	if (gt == NULL)
		return -1;
	/* RFC 6960 specifies that all times in OCSP must be GENERALIZEDTIME */
	if (ASN1_time_parse(gt->data, gt->length, &tm,
		V_ASN1_GENERALIZEDTIME) == -1)
		return -1;
	if ((*gt_time = timegm(&tm)) == -1)
		return -1;
	return 0;
}

static int
tls_ocsp_fill_info(struct tls *ctx, int response_status, int cert_status,
    int crl_reason, ASN1_GENERALIZEDTIME *revtime,
    ASN1_GENERALIZEDTIME *thisupd, ASN1_GENERALIZEDTIME *nextupd)
{
	struct tls_ocsp_result *info = NULL;

	free(ctx->ocsp->ocsp_result);
	ctx->ocsp->ocsp_result = NULL;

	if ((info = calloc(1, sizeof (struct tls_ocsp_result))) == NULL) {
		tls_set_error(ctx, "calloc");
		return -1;
	}
	info->response_status = response_status;
	info->cert_status = cert_status;
	info->crl_reason = crl_reason;
	if (info->response_status != OCSP_RESPONSE_STATUS_SUCCESSFUL) {
		info->result_msg =
		    OCSP_response_status_str(info->response_status);
	} else if (info->cert_status != V_OCSP_CERTSTATUS_REVOKED) {
		info->result_msg = OCSP_cert_status_str(info->cert_status);
	} else {
		info->result_msg = OCSP_crl_reason_str(info->crl_reason);
	}
	info->revocation_time = info->this_update = info->next_update = -1;
	if (revtime != NULL &&
	    tls_ocsp_asn1_parse_time(ctx, revtime, &info->revocation_time) != 0) {
		tls_set_error(ctx,
		    "unable to parse revocation time in OCSP reply");
		goto error;
	}
	if (thisupd != NULL &&
	    tls_ocsp_asn1_parse_time(ctx, thisupd, &info->this_update) != 0) {
		tls_set_error(ctx,
		    "unable to parse this update time in OCSP reply");
		goto error;
	}
	if (nextupd != NULL &&
	    tls_ocsp_asn1_parse_time(ctx, nextupd, &info->next_update) != 0) {
		tls_set_error(ctx,
		    "unable to parse next update time in OCSP reply");
		goto error;
	}
	ctx->ocsp->ocsp_result = info;
	return 0;
 error:
	free(info);
	return -1;
}

static OCSP_CERTID *
tls_ocsp_get_certid(X509 *main_cert, STACK_OF(X509) *extra_certs,
    SSL_CTX *ssl_ctx)
{
	X509_NAME *issuer_name;
	X509 *issuer;
	X509_STORE_CTX storectx;
	X509_OBJECT tmpobj;
	OCSP_CERTID *cid = NULL;
	X509_STORE *store;

	if ((issuer_name = X509_get_issuer_name(main_cert)) == NULL)
		return NULL;

	if (extra_certs != NULL) {
		issuer = X509_find_by_subject(extra_certs, issuer_name);
		if (issuer != NULL)
			return OCSP_cert_to_id(NULL, main_cert, issuer);
	}

	if ((store = SSL_CTX_get_cert_store(ssl_ctx)) == NULL)
		return NULL;
	if (X509_STORE_CTX_init(&storectx, store, main_cert, extra_certs) != 1)
		return NULL;
	if (X509_STORE_get_by_subject(&storectx, X509_LU_X509, issuer_name,
		&tmpobj) == 1) {
		cid = OCSP_cert_to_id(NULL, main_cert, tmpobj.data.x509);
		X509_OBJECT_free_contents(&tmpobj);
	}
	X509_STORE_CTX_cleanup(&storectx);
	return cid;
}

struct tls_ocsp *
tls_ocsp_setup_from_peer(struct tls *ctx)
{
	struct tls_ocsp *ocsp = NULL;
	STACK_OF(OPENSSL_STRING) *ocsp_urls = NULL;

	if ((ocsp = tls_ocsp_new()) == NULL)
		goto failed;

	/* steal state from ctx struct */
	ocsp->main_cert = SSL_get_peer_certificate(ctx->ssl_conn);
	ocsp->extra_certs = SSL_get_peer_cert_chain(ctx->ssl_conn);
	if (ocsp->main_cert == NULL) {
		tls_set_errorx(ctx, "no peer certificate for OCSP");
		goto failed;
	}

	ocsp_urls = X509_get1_ocsp(ocsp->main_cert);
	if (ocsp_urls == NULL) {
		tls_set_errorx(ctx, "no OCSP URLs in peer certificate");
		goto failed;
	}

	ocsp->ocsp_url = strdup(sk_OPENSSL_STRING_value(ocsp_urls, 0));
	if (ocsp->ocsp_url == NULL) {
		tls_set_errorx(ctx, "out of memory");
		goto failed;
	}

	X509_email_free(ocsp_urls);
	return ocsp;

 failed:
	tls_ocsp_free(ocsp);
	X509_email_free(ocsp_urls);
	return NULL;
}

static int
tls_ocsp_verify_response(struct tls *ctx, OCSP_RESPONSE *resp)
{
	OCSP_BASICRESP *br = NULL;
	ASN1_GENERALIZEDTIME *revtime = NULL, *thisupd = NULL, *nextupd = NULL;
	OCSP_CERTID *cid = NULL;
	STACK_OF(X509) *combined = NULL;
	int response_status=0, cert_status=0, crl_reason=0;
	int ret = -1;
	unsigned long flags;

	if ((br = OCSP_response_get1_basic(resp)) == NULL) {
		tls_set_errorx(ctx, "cannot load ocsp reply");
		goto error;
	}

	/*
	 * Skip validation of 'extra_certs' as this should be done
	 * already as part of main handshake.
	 */
	flags = OCSP_TRUSTOTHER;

	/* now verify */
	if (OCSP_basic_verify(br, ctx->ocsp->extra_certs,
		SSL_CTX_get_cert_store(ctx->ssl_ctx), flags) != 1) {
		tls_set_error(ctx, "ocsp verify failed");
		goto error;
	}

	/* signature OK, look inside */
	response_status = OCSP_response_status(resp);
	if (response_status != OCSP_RESPONSE_STATUS_SUCCESSFUL) {
		tls_set_errorx(ctx, "ocsp verify failed: response - %s",
		    OCSP_response_status_str(response_status));
		goto error;
	}

	cid = tls_ocsp_get_certid(ctx->ocsp->main_cert,
	    ctx->ocsp->extra_certs, ctx->ssl_ctx);
	if (cid == NULL) {
		tls_set_errorx(ctx, "ocsp verify failed: no issuer cert");
		goto error;
	}

	if (OCSP_resp_find_status(br, cid, &cert_status, &crl_reason,
	    &revtime, &thisupd, &nextupd) != 1) {
		tls_set_errorx(ctx, "ocsp verify failed: no result for cert");
		goto error;
	}

	if (OCSP_check_validity(thisupd, nextupd, JITTER_SEC,
	    MAXAGE_SEC) != 1) {
		tls_set_errorx(ctx,
		    "ocsp verify failed: ocsp response not current");
		goto error;
	}

	if (tls_ocsp_fill_info(ctx, response_status, cert_status,
	    crl_reason, revtime, thisupd, nextupd) != 0)
		goto error;

	/* finally can look at status */
	if (cert_status != V_OCSP_CERTSTATUS_GOOD && cert_status !=
	    V_OCSP_CERTSTATUS_UNKNOWN) {
		tls_set_errorx(ctx, "ocsp verify failed: revoked cert - %s",
			       OCSP_crl_reason_str(crl_reason));
		goto error;
	}
	ret = 0;

 error:
	sk_X509_free(combined);
	OCSP_CERTID_free(cid);
	OCSP_BASICRESP_free(br);
	return ret;
}

/*
 * Process a raw OCSP response from an OCSP server request.
 * OCSP details can then be retrieved with tls_peer_ocsp_* functions.
 * returns 0 if certificate ok, -1 otherwise.
 */
static int
tls_ocsp_process_response_internal(struct tls *ctx, const unsigned char *response,
    size_t size)
{
	int ret;
	OCSP_RESPONSE *resp;

	resp = d2i_OCSP_RESPONSE(NULL, &response, size);
	if (resp == NULL) {
		tls_ocsp_free(ctx->ocsp);
		ctx->ocsp = NULL;
		tls_set_error(ctx, "unable to parse OCSP response");
		return -1;
	}
	ret = tls_ocsp_verify_response(ctx, resp);
	OCSP_RESPONSE_free(resp);
	return ret;
}

/* TLS handshake verification callback for stapled requests */
int
tls_ocsp_verify_cb(SSL *ssl, void *arg)
{
	const unsigned char *raw = NULL;
	int size, res = -1;
	struct tls *ctx;

	if ((ctx = SSL_get_app_data(ssl)) == NULL)
		return -1;

	size = SSL_get_tlsext_status_ocsp_resp(ssl, &raw);
	if (size <= 0) {
		if (ctx->config->ocsp_require_stapling) {
			tls_set_errorx(ctx, "no stapled OCSP response provided");
			return 0;
		}
		return 1;
	}

	tls_ocsp_free(ctx->ocsp);
	if ((ctx->ocsp = tls_ocsp_setup_from_peer(ctx)) == NULL)
		return 0;

	if (ctx->config->verify_cert == 0 || ctx->config->verify_time == 0)
		return 1;

	res = tls_ocsp_process_response_internal(ctx, raw, size);

	return (res == 0) ? 1 : 0;
}


/* Staple the OCSP information in ctx->ocsp to the server handshake. */
int
tls_ocsp_stapling_cb(SSL *ssl, void *arg)
{
	int ret = SSL_TLSEXT_ERR_ALERT_FATAL;
	unsigned char *ocsp_staple = NULL;
	struct tls *ctx;

	if ((ctx = SSL_get_app_data(ssl)) == NULL)
		goto err;

	if (ctx->keypair == NULL || ctx->keypair->ocsp_staple == NULL ||
	    ctx->keypair->ocsp_staple_len == 0)
		return SSL_TLSEXT_ERR_NOACK;

	if ((ocsp_staple = malloc(ctx->keypair->ocsp_staple_len)) == NULL)
		goto err;

	memcpy(ocsp_staple, ctx->keypair->ocsp_staple,
	    ctx->keypair->ocsp_staple_len);

	if (SSL_set_tlsext_status_ocsp_resp(ctx->ssl_conn, ocsp_staple,
	    ctx->keypair->ocsp_staple_len) != 1)
		goto err;

	ret = SSL_TLSEXT_ERR_OK;
 err:
	if (ret != SSL_TLSEXT_ERR_OK)
		free(ocsp_staple);

	return ret;
}

/*
 * Public API
 */

/* Retrieve OCSP URL from peer certificate, if present. */
const char *
tls_peer_ocsp_url(struct tls *ctx)
{
	if (ctx->ocsp == NULL)
		return NULL;
	return ctx->ocsp->ocsp_url;
}

const char *
tls_peer_ocsp_result(struct tls *ctx)
{
	if (ctx->ocsp == NULL)
		return NULL;
	if (ctx->ocsp->ocsp_result == NULL)
		return NULL;
	return ctx->ocsp->ocsp_result->result_msg;
}

int
tls_peer_ocsp_response_status(struct tls *ctx)
{
	if (ctx->ocsp == NULL)
		return -1;
	if (ctx->ocsp->ocsp_result == NULL)
		return -1;
	return ctx->ocsp->ocsp_result->response_status;
}

int
tls_peer_ocsp_cert_status(struct tls *ctx)
{
	if (ctx->ocsp == NULL)
		return -1;
	if (ctx->ocsp->ocsp_result == NULL)
		return -1;
	return ctx->ocsp->ocsp_result->cert_status;
}

int
tls_peer_ocsp_crl_reason(struct tls *ctx)
{
	if (ctx->ocsp == NULL)
		return -1;
	if (ctx->ocsp->ocsp_result == NULL)
		return -1;
	return ctx->ocsp->ocsp_result->crl_reason;
}

time_t
tls_peer_ocsp_this_update(struct tls *ctx)
{
	if (ctx->ocsp == NULL)
		return -1;
	if (ctx->ocsp->ocsp_result == NULL)
		return -1;
	return ctx->ocsp->ocsp_result->this_update;
}

time_t
tls_peer_ocsp_next_update(struct tls *ctx)
{
	if (ctx->ocsp == NULL)
		return -1;
	if (ctx->ocsp->ocsp_result == NULL)
		return -1;
	return ctx->ocsp->ocsp_result->next_update;
}

time_t
tls_peer_ocsp_revocation_time(struct tls *ctx)
{
	if (ctx->ocsp == NULL)
		return -1;
	if (ctx->ocsp->ocsp_result == NULL)
		return -1;
	return ctx->ocsp->ocsp_result->revocation_time;
}

int
tls_ocsp_process_response(struct tls *ctx, const unsigned char *response,
    size_t size)
{
	if ((ctx->state & TLS_HANDSHAKE_COMPLETE) == 0)
		return -1;
	return tls_ocsp_process_response_internal(ctx, response, size);
}
@


1.15
log
@Slightly restructure tls_ocsp_verify_cb() to make it more like libtls code.
@
text
@d334 2
a336 2
	unsigned char *ocsp_staple = NULL;
	int ret = SSL_TLSEXT_ERR_ALERT_FATAL;
d341 2
a342 3
	if (ctx->config->keypair == NULL ||
	    ctx->config->keypair->ocsp_staple == NULL ||
	    ctx->config->keypair->ocsp_staple_len == 0)
d345 1
a345 2
	if ((ocsp_staple = malloc(ctx->config->keypair->ocsp_staple_len)) ==
	    NULL)
d348 3
a350 2
	memcpy(ocsp_staple, ctx->config->keypair->ocsp_staple,
	    ctx->config->keypair->ocsp_staple_len);
d352 1
a352 1
	    ctx->config->keypair->ocsp_staple_len) != 1)
d359 1
d367 1
a367 1
/* Retrieve OCSP URL from peer certificate, if present */
@


1.14
log
@Provide a useful error if there are no OCSP URLs in the peer certificate.
@
text
@d318 7
a324 6
	ctx->ocsp = tls_ocsp_setup_from_peer(ctx);
	if (ctx->ocsp != NULL) {
		if (ctx->config->verify_cert == 0 || ctx->config->verify_time == 0)
			return 1;
		res = tls_ocsp_process_response_internal(ctx, raw, size);
	}
@


1.13
log
@Fix indentation.
@
text
@d176 2
a177 1
	if (ocsp_urls == NULL)
d179 2
@


1.12
log
@Plug a memory leak. The main_cert needs to be X509_free()ed since
SSL_get_peer_certificate() increases the ref count whereas extra_certs
do not because SSL_get_peer_cert_chain() won't increase ref counts.
OK beck@@
@
text
@d349 1
a349 1
		ctx->config->keypair->ocsp_staple_len) != 1)
@


1.11
log
@Move the ocsp staple to being part of the keypair structure internally,
so that it does not send back bogus staples when SNI is in use.
(Further change is required to be able to use staples on all keypairs
and not just the main one)
ok jsing@@
@
text
@d49 2
@


1.10
log
@More s/OSCP/OCSP/ typos

ok jmc@@
@
text
@d335 3
a337 2
	if (ctx->config->ocsp_staple == NULL ||
	    ctx->config->ocsp_staple_len == 0)
d340 2
a341 1
	if ((ocsp_staple = malloc(ctx->config->ocsp_staple_len)) == NULL)
d344 2
a345 2
	memcpy(ocsp_staple, ctx->config->ocsp_staple,
	    ctx->config->ocsp_staple_len);
d347 1
a347 1
		ctx->config->ocsp_staple_len) != 1)
@


1.9
log
@Add support for server side OCSP stapling to libtls.
Add support for server side OCSP stapling to netcat.
@
text
@d359 1
a359 1
/* Retrieve OSCP URL from peer certificate, if present */
@


1.8
log
@rename ocsp_ctx to ocsp
ok jsing@@
@
text
@a52 2
	free(ocsp->request_data);
	ocsp->request_data = NULL;
d321 32
@


1.7
log
@make public ASN1_time_parse and ASN1_time_tm_cmp to replace former hidden
functions.. document with a man page.
bump majors on libtls, libssl, libcrypto
ok jsing@@ guenther@@
@
text
@d37 2
a38 2
static struct tls_ocsp_ctx *
tls_ocsp_ctx_new(void)
d40 1
a40 1
	return (calloc(1, sizeof(struct tls_ocsp_ctx)));
d44 1
a44 1
tls_ocsp_ctx_free(struct tls_ocsp_ctx *ocsp_ctx)
d46 1
a46 1
	if (ocsp_ctx == NULL)
d49 7
a55 7
	free(ocsp_ctx->ocsp_result);
	ocsp_ctx->ocsp_result = NULL;
	free(ocsp_ctx->ocsp_url);
	ocsp_ctx->ocsp_url = NULL;
	free(ocsp_ctx->request_data);
	ocsp_ctx->request_data = NULL;
	free(ocsp_ctx);
d81 2
a82 2
	free(ctx->ocsp_ctx->ocsp_result);
	ctx->ocsp_ctx->ocsp_result = NULL;
d118 1
a118 1
	ctx->ocsp_ctx->ocsp_result = info;
d158 1
a158 1
struct tls_ocsp_ctx *
d161 1
a161 1
	struct tls_ocsp_ctx *ocsp_ctx = NULL;
d164 1
a164 1
	if ((ocsp_ctx = tls_ocsp_ctx_new()) == NULL)
d168 3
a170 3
	ocsp_ctx->main_cert = SSL_get_peer_certificate(ctx->ssl_conn);
	ocsp_ctx->extra_certs = SSL_get_peer_cert_chain(ctx->ssl_conn);
	if (ocsp_ctx->main_cert == NULL) {
d175 1
a175 1
	ocsp_urls = X509_get1_ocsp(ocsp_ctx->main_cert);
d178 2
a179 2
	ocsp_ctx->ocsp_url = strdup(sk_OPENSSL_STRING_value(ocsp_urls, 0));
	if (ocsp_ctx->ocsp_url == NULL) {
d185 1
a185 1
	return ocsp_ctx;
d188 1
a188 1
	tls_ocsp_ctx_free(ocsp_ctx);
d216 1
a216 1
	if (OCSP_basic_verify(br, ctx->ocsp_ctx->extra_certs,
d230 2
a231 2
	cid = tls_ocsp_get_certid(ctx->ocsp_ctx->main_cert,
	    ctx->ocsp_ctx->extra_certs, ctx->ssl_ctx);
d284 2
a285 2
		tls_ocsp_ctx_free(ctx->ocsp_ctx);
		ctx->ocsp_ctx = NULL;
d314 3
a316 3
	tls_ocsp_ctx_free(ctx->ocsp_ctx);
	ctx->ocsp_ctx = tls_ocsp_setup_from_peer(ctx);
	if (ctx->ocsp_ctx != NULL) {
d333 1
a333 1
	if (ctx->ocsp_ctx == NULL)
d335 1
a335 1
	return ctx->ocsp_ctx->ocsp_url;
d341 1
a341 1
	if (ctx->ocsp_ctx == NULL)
d343 1
a343 1
	if (ctx->ocsp_ctx->ocsp_result == NULL)
d345 1
a345 1
	return ctx->ocsp_ctx->ocsp_result->result_msg;
d351 1
a351 1
	if (ctx->ocsp_ctx == NULL)
d353 1
a353 1
	if (ctx->ocsp_ctx->ocsp_result == NULL)
d355 1
a355 1
	return ctx->ocsp_ctx->ocsp_result->response_status;
d361 1
a361 1
	if (ctx->ocsp_ctx == NULL)
d363 1
a363 1
	if (ctx->ocsp_ctx->ocsp_result == NULL)
d365 1
a365 1
	return ctx->ocsp_ctx->ocsp_result->cert_status;
d371 1
a371 1
	if (ctx->ocsp_ctx == NULL)
d373 1
a373 1
	if (ctx->ocsp_ctx->ocsp_result == NULL)
d375 1
a375 1
	return ctx->ocsp_ctx->ocsp_result->crl_reason;
d381 1
a381 1
	if (ctx->ocsp_ctx == NULL)
d383 1
a383 1
	if (ctx->ocsp_ctx->ocsp_result == NULL)
d385 1
a385 1
	return ctx->ocsp_ctx->ocsp_result->this_update;
d391 1
a391 1
	if (ctx->ocsp_ctx == NULL)
d393 1
a393 1
	if (ctx->ocsp_ctx->ocsp_result == NULL)
d395 1
a395 1
	return ctx->ocsp_ctx->ocsp_result->next_update;
d401 1
a401 1
	if (ctx->ocsp_ctx == NULL)
d403 1
a403 1
	if (ctx->ocsp_ctx->ocsp_result == NULL)
d405 1
a405 1
	return ctx->ocsp_ctx->ocsp_result->revocation_time;
@


1.6
log
@Add ocsp_require_stapling config option for tls - allows a connection
to indicate that it requires the peer to provide a stapled OCSP response
with the handshake.  Provide a "-T muststaple" for nc that uses it.
ok jsing@@, guenther@@
@
text
@d66 1
a66 1
	if (asn1_time_parse(gt->data, gt->length, &tm,
a260 1

@


1.5
log
@Don't do OCSP validation when we have disabled certificate verification
or certificate validation.
ok jsing@@
@
text
@d307 5
a311 1
	if (size <= 0)
d313 1
@


1.4
log
@Fix handshake failures:
split out internals of OCSP verification to allow callback
to verify before TLS handshake is complete
@
text
@d312 3
a314 1
	if (ctx->ocsp_ctx != NULL)
d316 1
@


1.3
log
@fix shadow declaration of time in parameter list.
ok jsing@@
@
text
@d271 24
d313 1
a313 1
		res = tls_ocsp_process_response(ctx, raw, size);
a400 5
/*
 * Process a raw OCSP response from an OCSP server request.
 * OCSP details can then be retrieved with tls_peer_ocsp_* functions.
 * returns 0 if certificate ok, -1 otherwise.
 */
a404 3
	int ret;
	OCSP_RESPONSE *resp;

d407 1
a407 11

	resp = d2i_OCSP_RESPONSE(NULL, &response, size);
	if (resp == NULL) {
		tls_ocsp_ctx_free(ctx->ocsp_ctx);
		ctx->ocsp_ctx = NULL;
		tls_set_error(ctx, "unable to parse OCSP response");
		return -1;
	}
	ret = tls_ocsp_verify_response(ctx, resp);
	OCSP_RESPONSE_free(resp);
	return ret;
@


1.2
log
@Ensure handshake is complete before processing an ocsp response for a ctx
ok jsing@@
@
text
@d59 1
a59 1
tls_ocsp_asn1_parse_time(struct tls *ctx, ASN1_GENERALIZEDTIME *gt, time_t *time)
d69 1
a69 1
	if ((*time = timegm(&tm)) == -1)
@


1.1
log
@Add OCSP client side support to libtls.
   - Provide access to certificate OCSP URL
   - Provide ability to check a raw OCSP reply against an
     established TLS ctx
   - Check and validate OCSP stapling info in the TLS handshake
     if a stapled OCSP response is provided.`

Add example code to show OCSP URL and stapled info
into netcat.

ok jsing@@
@
text
@d389 3
@

