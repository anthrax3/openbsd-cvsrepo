head	1.41;
access;
symbols
	OPENBSD_6_1:1.35.0.4
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.41
date	2017.08.10.18.18.30;	author jsing;	state Exp;
branches;
next	1.40;
commitid	JWjAtg2Qibcivg2a;

1.40
date	2017.07.05.15.38.35;	author jsing;	state Exp;
branches;
next	1.39;
commitid	n9VjYvgTDNHulek7;

1.39
date	2017.06.22.18.03.57;	author jsing;	state Exp;
branches;
next	1.38;
commitid	sJFt01yiSZdlHkQV;

1.38
date	2017.06.22.17.34.25;	author jsing;	state Exp;
branches;
next	1.37;
commitid	ZA0q7g60d3iRR8HG;

1.37
date	2017.05.06.20.59.28;	author jsing;	state Exp;
branches;
next	1.36;
commitid	lKAI2ck8n3yTWNjk;

1.36
date	2017.04.10.17.11.13;	author jsing;	state Exp;
branches;
next	1.35;
commitid	3nmBs0stdHQq3Td1;

1.35
date	2017.01.31.15.57.43;	author jsing;	state Exp;
branches;
next	1.34;
commitid	EC9RD1k6ogZfl0mN;

1.34
date	2017.01.26.12.56.37;	author jsing;	state Exp;
branches;
next	1.33;
commitid	fXjilM4ZG2ENdzA8;

1.33
date	2017.01.24.01.48.05;	author claudio;	state Exp;
branches;
next	1.32;
commitid	k0nZBOjpyTl9Tz16;

1.32
date	2017.01.12.16.15.58;	author jsing;	state Exp;
branches;
next	1.31;
commitid	7YglLcbrBOWu1uon;

1.31
date	2016.11.06.16.55.16;	author beck;	state Exp;
branches;
next	1.30;
commitid	wzJHUSizBPLp2tpF;

1.30
date	2016.11.05.15.13.26;	author beck;	state Exp;
branches;
next	1.29;
commitid	3VJnu6rXiOGWa3uh;

1.29
date	2016.11.04.19.01.29;	author jsing;	state Exp;
branches;
next	1.28;
commitid	X75omw5uUPkV0V74;

1.28
date	2016.09.14.11.34.37;	author bcook;	state Exp;
branches;
next	1.27;
commitid	6beuD7AUJU2ce5zU;

1.27
date	2016.09.04.13.20.56;	author jsing;	state Exp;
branches;
next	1.26;
commitid	wbsAjBek9Ycbf7w3;

1.26
date	2016.09.04.12.26.43;	author bcook;	state Exp;
branches;
next	1.25;
commitid	pRMpDkZhqg5jtYzf;

1.25
date	2016.08.22.14.51.37;	author jsing;	state Exp;
branches;
next	1.24;
commitid	8BA0jRjLExCiDXSD;

1.24
date	2016.08.18.15.52.03;	author jsing;	state Exp;
branches;
next	1.23;
commitid	yYdWvFhmUE7iIYoE;

1.23
date	2016.08.15.14.04.23;	author jsing;	state Exp;
branches;
next	1.22;
commitid	skqiBPIfpiAFudga;

1.22
date	2016.08.12.15.10.59;	author jsing;	state Exp;
branches;
next	1.21;
commitid	JoLVmCulWsGsIXUK;

1.21
date	2016.08.02.07.47.11;	author jsing;	state Exp;
branches;
next	1.20;
commitid	0rb7ZAopgz9STgBs;

1.20
date	2016.08.01.17.32.19;	author jsing;	state Exp;
branches;
next	1.19;
commitid	s3UFLNfN0t7jV6pK;

1.19
date	2016.04.28.17.05.59;	author jsing;	state Exp;
branches;
next	1.18;
commitid	DKpbOonvEBeRoW5p;

1.18
date	2015.09.29.10.17.04;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	YDjtN3rqnZIVf1NW;

1.17
date	2015.09.12.19.54.31;	author jsing;	state Exp;
branches;
next	1.16;
commitid	tI7XkG4J1fY7en1u;

1.16
date	2015.09.11.08.31.26;	author beck;	state Exp;
branches;
next	1.15;
commitid	uIHL1qWnZ8RrQ4s0;

1.15
date	2015.09.10.10.14.20;	author jsing;	state Exp;
branches;
next	1.14;
commitid	XGvr88Fsecamv3XQ;

1.14
date	2015.09.10.09.10.42;	author jsing;	state Exp;
branches;
next	1.13;
commitid	QGGZQQxHecOSmNyK;

1.13
date	2015.09.09.19.49.07;	author jsing;	state Exp;
branches;
next	1.12;
commitid	8fjywsQemyYNWdJq;

1.12
date	2015.09.09.19.23.04;	author beck;	state Exp;
branches;
next	1.11;
commitid	nJxZtGxH6XzyXez3;

1.11
date	2015.09.09.14.32.06;	author jsing;	state Exp;
branches;
next	1.10;
commitid	lE2H6vYPmLedqh3T;

1.10
date	2015.08.27.15.26.50;	author jsing;	state Exp;
branches;
next	1.9;
commitid	5FIlAb8mLiRyTsjH;

1.9
date	2015.08.22.14.52.39;	author jsing;	state Exp;
branches;
next	1.8;
commitid	i7ligJ7oJREca2gT;

1.8
date	2015.08.22.14.51.34;	author jsing;	state Exp;
branches;
next	1.7;
commitid	vVrra6TLLBoV3hKj;

1.7
date	2015.03.31.14.03.38;	author jsing;	state Exp;
branches;
next	1.6;
commitid	eUtypBLBDknWtFkM;

1.6
date	2015.03.31.12.21.27;	author jsing;	state Exp;
branches;
next	1.5;
commitid	zTdtFn3A4fRovB4F;

1.5
date	2015.02.07.09.50.09;	author jsing;	state Exp;
branches;
next	1.4;
commitid	QsFM5heC1IRpgG38;

1.4
date	2015.02.07.06.19.26;	author jsing;	state Exp;
branches;
next	1.3;
commitid	cwopaOfpwORA2vUX;

1.3
date	2015.01.30.14.25.37;	author bluhm;	state Exp;
branches;
next	1.2;
commitid	h8UwIM5Ugf2vuzlB;

1.2
date	2015.01.16.14.34.51;	author reyk;	state Exp;
branches;
next	1.1;
commitid	vhVTw19iFGP02KBT;

1.1
date	2014.10.31.13.46.17;	author jsing;	state Exp;
branches;
next	;
commitid	y63FmUITd26yVanM;


desc
@@


1.41
log
@Add a tls_config_set_ecdhecurves() function to libtls, which allows the
names of the elliptic curves that may be used during client and server
key exchange to be specified.

This deprecates tls_config_set_ecdhecurve(), which could only be used to
specify a single supported curve.

ok beck@@
@
text
@/* $OpenBSD: tls_server.c,v 1.40 2017/07/05 15:38:35 jsing Exp $ */
/*
 * Copyright (c) 2014 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/socket.h>

#include <arpa/inet.h>

#include <openssl/ec.h>
#include <openssl/err.h>
#include <openssl/ssl.h>

#include <tls.h>
#include "tls_internal.h"

struct tls *
tls_server(void)
{
	struct tls *ctx;

	if ((ctx = tls_new()) == NULL)
		return (NULL);

	ctx->flags |= TLS_SERVER;

	return (ctx);
}

struct tls *
tls_server_conn(struct tls *ctx)
{
	struct tls *conn_ctx;

	if ((conn_ctx = tls_new()) == NULL)
		return (NULL);

	conn_ctx->flags |= TLS_SERVER_CONN;

	ctx->config->refcount++;
	conn_ctx->config = ctx->config;

	return (conn_ctx);
}

static int
tls_server_alpn_cb(SSL *ssl, const unsigned char **out, unsigned char *outlen,
    const unsigned char *in, unsigned int inlen, void *arg)
{
	struct tls *ctx = arg;

	if (SSL_select_next_proto((unsigned char**)out, outlen,
	    ctx->config->alpn, ctx->config->alpn_len, in, inlen) ==
	    OPENSSL_NPN_NEGOTIATED)
		return (SSL_TLSEXT_ERR_OK);

	return (SSL_TLSEXT_ERR_NOACK);
}

static int
tls_servername_cb(SSL *ssl, int *al, void *arg)
{
	struct tls *ctx = (struct tls *)arg;
	struct tls_sni_ctx *sni_ctx;
	union tls_addr addrbuf;
	struct tls *conn_ctx;
	const char *name;
	int match;

	if ((conn_ctx = SSL_get_app_data(ssl)) == NULL)
		goto err;

	if ((name = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name)) ==
	    NULL) {
		/*
		 * The servername callback gets called even when there is no
		 * TLS servername extension provided by the client. Sigh!
		 */
		return (SSL_TLSEXT_ERR_NOACK);
	}

	/*
	 * Per RFC 6066 section 3: ensure that name is not an IP literal.
	 *
	 * While we should treat this as an error, a number of clients
	 * (Python, Ruby and Safari) are not RFC compliant. To avoid handshake
	 * failures, pretend that we did not receive the extension.
	 */
	if (inet_pton(AF_INET, name, &addrbuf) == 1 ||
            inet_pton(AF_INET6, name, &addrbuf) == 1)
		return (SSL_TLSEXT_ERR_NOACK);

	free((char *)conn_ctx->servername);
	if ((conn_ctx->servername = strdup(name)) == NULL)
		goto err;

	/* Find appropriate SSL context for requested servername. */
	for (sni_ctx = ctx->sni_ctx; sni_ctx != NULL; sni_ctx = sni_ctx->next) {
		if (tls_check_name(ctx, sni_ctx->ssl_cert, name,
		    &match) == -1)
			goto err;
		if (match) {
			SSL_set_SSL_CTX(conn_ctx->ssl_conn, sni_ctx->ssl_ctx);
			return (SSL_TLSEXT_ERR_OK);
		}
	}

	/* No match, use the existing context/certificate. */
	return (SSL_TLSEXT_ERR_OK);

 err:
	/*
	 * There is no way to tell libssl that an internal failure occurred.
	 * The only option we have is to return a fatal alert.
	 */
	*al = TLS1_AD_INTERNAL_ERROR;
	return (SSL_TLSEXT_ERR_ALERT_FATAL);
}

static struct tls_ticket_key *
tls_server_ticket_key(struct tls_config *config, unsigned char *keyname)
{
	struct tls_ticket_key *key = NULL;
	time_t now;
	int i;

	now = time(NULL);
	if (config->ticket_autorekey == 1) {
		if (now - 3 * (config->session_lifetime / 4) >
		    config->ticket_keys[0].time) {
			if (tls_config_ticket_autorekey(config) == -1)
				return (NULL);
		}
	}
	for (i = 0; i < TLS_NUM_TICKETS; i++) {
		struct tls_ticket_key *tk = &config->ticket_keys[i];
		if (now - config->session_lifetime > tk->time)
			continue;
		if (keyname == NULL || timingsafe_memcmp(keyname,
		    tk->key_name, sizeof(tk->key_name)) == 0) {
			key = tk;
			break;
		}
	}
	return (key);
}

static int
tls_server_ticket_cb(SSL *ssl, unsigned char *keyname, unsigned char *iv,
    EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int mode)
{
	struct tls_ticket_key *key;
	struct tls *tls_ctx;

	if ((tls_ctx = SSL_get_app_data(ssl)) == NULL)
		return (-1);

	if (mode == 1) {
		/* create new session */
		key = tls_server_ticket_key(tls_ctx->config, NULL);
		if (key == NULL) {
			tls_set_errorx(tls_ctx, "no valid ticket key found");
			return (-1);
		}

		memcpy(keyname, key->key_name, sizeof(key->key_name));
		arc4random_buf(iv, EVP_MAX_IV_LENGTH);
		EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,
		    key->aes_key, iv);
		HMAC_Init_ex(hctx, key->hmac_key, sizeof(key->hmac_key),
		    EVP_sha256(), NULL);
		return (0);
	} else {
		/* get key by name */
		key = tls_server_ticket_key(tls_ctx->config, keyname);
		if (key == NULL)
			return (0);

		EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,
		    key->aes_key, iv);
		HMAC_Init_ex(hctx, key->hmac_key, sizeof(key->hmac_key),
		    EVP_sha256(), NULL);

		/* time to renew the ticket? is it the primary key? */
		if (key != &tls_ctx->config->ticket_keys[0])
			return (2);
		return (1);
	}
}

static int
tls_keypair_load_cert(struct tls_keypair *keypair, struct tls_error *error,
    X509 **cert)
{
	char *errstr = "unknown";
	BIO *cert_bio = NULL;
	int ssl_err;
	int rv = -1;

	X509_free(*cert);
	*cert = NULL;

	if (keypair->cert_mem == NULL) {
		tls_error_set(error, "keypair has no certificate");
		goto err;
	}
	if ((cert_bio = BIO_new_mem_buf(keypair->cert_mem,
	    keypair->cert_len)) == NULL) {
		tls_error_set(error, "failed to create certificate bio");
		goto err;
	}
	if ((*cert = PEM_read_bio_X509(cert_bio, NULL, tls_password_cb,
	    NULL)) == NULL) {
		if ((ssl_err = ERR_peek_error()) != 0)
		    errstr = ERR_error_string(ssl_err, NULL);
		tls_error_set(error, "failed to load certificate: %s", errstr);
		goto err;
	}

	rv = 0;

 err:
	BIO_free(cert_bio);

	return (rv);
}

static int
tls_configure_server_ssl(struct tls *ctx, SSL_CTX **ssl_ctx,
    struct tls_keypair *keypair)
{
	SSL_CTX_free(*ssl_ctx);

	if ((*ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {
		tls_set_errorx(ctx, "ssl context failure");
		goto err;
	}

	SSL_CTX_set_options(*ssl_ctx, SSL_OP_NO_CLIENT_RENEGOTIATION);

	if (SSL_CTX_set_tlsext_servername_callback(*ssl_ctx,
	    tls_servername_cb) != 1) {
		tls_set_error(ctx, "failed to set servername callback");
		goto err;
	}
	if (SSL_CTX_set_tlsext_servername_arg(*ssl_ctx, ctx) != 1) {
		tls_set_error(ctx, "failed to set servername callback arg");
		goto err;
	}

	if (tls_configure_ssl(ctx, *ssl_ctx) != 0)
		goto err;
	if (tls_configure_ssl_keypair(ctx, *ssl_ctx, keypair, 1) != 0)
		goto err;
	if (ctx->config->verify_client != 0) {
		int verify = SSL_VERIFY_PEER;
		if (ctx->config->verify_client == 1)
			verify |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
		if (tls_configure_ssl_verify(ctx, *ssl_ctx, verify) == -1)
			goto err;
	}

	if (ctx->config->alpn != NULL)
		SSL_CTX_set_alpn_select_cb(*ssl_ctx, tls_server_alpn_cb,
		    ctx);

	if (ctx->config->dheparams == -1)
		SSL_CTX_set_dh_auto(*ssl_ctx, 1);
	else if (ctx->config->dheparams == 1024)
		SSL_CTX_set_dh_auto(*ssl_ctx, 2);

	if (ctx->config->ecdhecurves != NULL) {
		SSL_CTX_set_ecdh_auto(*ssl_ctx, 1);
		if (SSL_CTX_set1_groups(*ssl_ctx, ctx->config->ecdhecurves,
		    ctx->config->ecdhecurves_len) != 1) {
			tls_set_errorx(ctx, "failed to set ecdhe curves");
			goto err;
		}
	}

	if (ctx->config->ciphers_server == 1)
		SSL_CTX_set_options(*ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);

	if (SSL_CTX_set_tlsext_status_cb(*ssl_ctx, tls_ocsp_stapling_cb) != 1) {
		tls_set_errorx(ctx, "failed to add OCSP stapling callback");
		goto err;
	}

	if (ctx->config->session_lifetime > 0) {
		/* set the session lifetime and enable tickets */
		SSL_CTX_set_timeout(*ssl_ctx, ctx->config->session_lifetime);
		SSL_CTX_clear_options(*ssl_ctx, SSL_OP_NO_TICKET);
		if (!SSL_CTX_set_tlsext_ticket_key_cb(*ssl_ctx,
		    tls_server_ticket_cb)) {
			tls_set_error(ctx,
			    "failed to set the TLS ticket callback");
			goto err;
		}
	}

	if (SSL_CTX_set_session_id_context(*ssl_ctx, ctx->config->session_id,
	    sizeof(ctx->config->session_id)) != 1) {
		tls_set_error(ctx, "failed to set session id context");
		goto err;
	}

	return (0);

  err:
	SSL_CTX_free(*ssl_ctx);
	*ssl_ctx = NULL;

	return (-1);
}

static int
tls_configure_server_sni(struct tls *ctx)
{
	struct tls_sni_ctx **sni_ctx;
	struct tls_keypair *kp;

	if (ctx->config->keypair->next == NULL)
		return (0);

	/* Set up additional SSL contexts for SNI. */
	sni_ctx = &ctx->sni_ctx;
	for (kp = ctx->config->keypair->next; kp != NULL; kp = kp->next) {
		if ((*sni_ctx = tls_sni_ctx_new()) == NULL) {
			tls_set_errorx(ctx, "out of memory");
			goto err;
		}
		if (tls_configure_server_ssl(ctx, &(*sni_ctx)->ssl_ctx, kp) == -1)
			goto err;
		if (tls_keypair_load_cert(kp, &ctx->error,
		    &(*sni_ctx)->ssl_cert) == -1)
			goto err;
		sni_ctx = &(*sni_ctx)->next;
	}

	return (0);

 err:
	return (-1);
}

int
tls_configure_server(struct tls *ctx)
{
	if (tls_configure_server_ssl(ctx, &ctx->ssl_ctx,
	    ctx->config->keypair) == -1)
		goto err;
	if (tls_configure_server_sni(ctx) == -1)
		goto err;

	return (0);

 err:
	return (-1);
}

static struct tls *
tls_accept_common(struct tls *ctx)
{
	struct tls *conn_ctx = NULL;

	if ((ctx->flags & TLS_SERVER) == 0) {
		tls_set_errorx(ctx, "not a server context");
		goto err;
	}

	if ((conn_ctx = tls_server_conn(ctx)) == NULL) {
		tls_set_errorx(ctx, "connection context failure");
		goto err;
	}

	if ((conn_ctx->ssl_conn = SSL_new(ctx->ssl_ctx)) == NULL) {
		tls_set_errorx(ctx, "ssl failure");
		goto err;
	}

	if (SSL_set_app_data(conn_ctx->ssl_conn, conn_ctx) != 1) {
		tls_set_errorx(ctx, "ssl application data failure");
		goto err;
	}

	return conn_ctx;

 err:
	tls_free(conn_ctx);

	return (NULL);
}

int
tls_accept_socket(struct tls *ctx, struct tls **cctx, int s)
{
	return (tls_accept_fds(ctx, cctx, s, s));
}

int
tls_accept_fds(struct tls *ctx, struct tls **cctx, int fd_read, int fd_write)
{
	struct tls *conn_ctx;

	if ((conn_ctx = tls_accept_common(ctx)) == NULL)
		goto err;

	if (SSL_set_rfd(conn_ctx->ssl_conn, fd_read) != 1 ||
	    SSL_set_wfd(conn_ctx->ssl_conn, fd_write) != 1) {
		tls_set_errorx(ctx, "ssl file descriptor failure");
		goto err;
	}

	*cctx = conn_ctx;

	return (0);
 err:
	tls_free(conn_ctx);
	*cctx = NULL;

	return (-1);
}

int
tls_accept_cbs(struct tls *ctx, struct tls **cctx,
    tls_read_cb read_cb, tls_write_cb write_cb, void *cb_arg)
{
	struct tls *conn_ctx;

	if ((conn_ctx = tls_accept_common(ctx)) == NULL)
		goto err;

	if (tls_set_cbs(conn_ctx, read_cb, write_cb, cb_arg) != 0)
		goto err;

	*cctx = conn_ctx;

	return (0);
 err:
	tls_free(conn_ctx);
	*cctx = NULL;

	return (-1);
}

int
tls_handshake_server(struct tls *ctx)
{
	int ssl_ret;
	int rv = -1;

	if ((ctx->flags & TLS_SERVER_CONN) == 0) {
		tls_set_errorx(ctx, "not a server connection context");
		goto err;
	}

	ctx->state |= TLS_SSL_NEEDS_SHUTDOWN;

	ERR_clear_error();
	if ((ssl_ret = SSL_accept(ctx->ssl_conn)) != 1) {
		rv = tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "handshake");
		goto err;
	}

	ctx->state |= TLS_HANDSHAKE_COMPLETE;
	rv = 0;

 err:
	return (rv);
}
@


1.40
log
@RFC 6066 states that IP literals are not permitted in "HostName" for a
TLS Server Name extension, however seemingly several clients (including
Python, Ruby and Safari) violate the RFC. Given that this is a fairly
widespread issue, if we receive a TLS Server Name extension that contains
an IP literal, pretend that we did not receive the extension rather than
causing a handshake failure.

Issue raised by jsg@@

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.39 2017/06/22 18:03:57 jsing Exp $ */
a243 2
	EC_KEY *ecdh_key;

d284 1
a284 1
	if (ctx->config->ecdhecurve == -1) {
d286 3
a288 4
	} else if (ctx->config->ecdhecurve != NID_undef) {
		if ((ecdh_key = EC_KEY_new_by_curve_name(
		    ctx->config->ecdhecurve)) == NULL) {
			tls_set_errorx(ctx, "failed to set ECDHE curve");
a290 3
		SSL_CTX_set_options(*ssl_ctx, SSL_OP_SINGLE_ECDH_USE);
		SSL_CTX_set_tmp_ecdh(*ssl_ctx, ecdh_key);
		EC_KEY_free(ecdh_key);
@


1.39
log
@Use the tls_password_cb() callback with all PEM_read_bio_*() calls, so that
we can prevent libcrypto from going behind our back and trying to read
passwords from standard input (which we may not be permitted to do).

Found by jsg@@ with httpd and password protected keys.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.38 2017/06/22 17:34:25 jsing Exp $ */
d94 7
a100 1
	/* Per RFC 6066 section 3: ensure that name is not an IP literal. */
d103 1
a103 1
		goto err;
@


1.38
log
@Use the standard `rv' idiom in tls_keypair_load_cert(), rather than
duplicating clean up code.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.37 2017/05/06 20:59:28 jsing Exp $ */
d218 2
a219 1
	if ((*cert = PEM_read_bio_X509(cert_bio, NULL, NULL, NULL)) == NULL) {
@


1.37
log
@Perform reference counting for tls_config. This allows tls_config_free() to
be called as soon as it has been passed to the final tls_configure() call,
simplifying lifetime tracking for the application.

Requested some time ago by tedu@@.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.36 2017/04/10 17:11:13 jsing Exp $ */
d204 1
d225 1
a225 3
	BIO_free(cert_bio);

	return (0);
d230 1
a230 1
	return (-1);
@


1.36
log
@Rework name verification code so that a match is indicated via an argument,
rather than return codes. More strictly follow RFC 6125, in particular only
check the CN if there are no SAN identifiers present in the certificate
(per section 6.4.4).

Previous behaviour questioned by Daniel Stenberg <daniel at haxx dot se>.

ok beck@@ jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.35 2017/01/31 15:57:43 jsing Exp $ */
d51 2
@


1.35
log
@Disable client-initiated renegotiation for libtls servers.

ok beck@@ reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.34 2017/01/26 12:56:37 jsing Exp $ */
d78 1
d83 2
a84 1
	if ((name = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name)) == NULL) {
d103 4
a106 1
		if (tls_check_name(ctx, sni_ctx->ssl_cert, name) == 0) {
@


1.34
log
@Use a flag to track when we need to call SSL_shutdown(). This avoids an
issue where by calling tls_close() on a TLS context that has not attempted
a handshake, results in an unexpected failure.

Reported by Vinay Sajip.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.33 2017/01/24 01:48:05 claudio Exp $ */
d239 2
@


1.33
log
@Introduce ticket support. To enable them it is enough to set a positive
lifetime with tls_config_set_session_lifetime(). This enables tickets
and uses an internal automatic rekeying mode for the ticket keys.

If multiple processes are involved the following functions can be used to make
tickets work accross all instances:
- tls_config_set_session_id() sets the session identifier
- tls_config_add_ticket_key() adds an encryption and authentication key

For now only the last 4 keys added will be used (unless they are too old).
If tls_config_add_ticket_key() is used the caller must ensure to add new keys
regularly. It is best to do this 4 times per session lifetime (which is also
the ticket key lifetime).

Since tickets break PFS it is best to minimize the session lifetime according
to needs.

With a lot of help, input and OK beck@@, jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.32 2017/01/12 16:15:58 jsing Exp $ */
d459 2
@


1.32
log
@If tls_set_cbs() fails an error will already be specified, so do not
replace it with a less specific one.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.31 2016/11/06 16:55:16 beck Exp $ */
d119 71
a230 1
	unsigned char sid[SSL_MAX_SSL_SESSION_ID_LENGTH];
d292 14
a305 8
	/*
	 * Set session ID context to a random value.  We don't support
	 * persistent caching of sessions so it is OK to set a temporary
	 * session ID context that is valid during run time.
	 */
	arc4random_buf(sid, sizeof(sid));
	if (SSL_CTX_set_session_id_context(*ssl_ctx, sid,
	    sizeof(sid)) != 1) {
@


1.31
log
@Set the callback on the correct ssl_ctx for the SNI case, instead of
the master only.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.30 2016/11/05 15:13:26 beck Exp $ */
d360 1
a360 2
	if (tls_set_cbs(conn_ctx, read_cb, write_cb, cb_arg) != 0) {
		tls_set_errorx(ctx, "callback registration failure");
a361 1
	}
@


1.30
log
@Add support for server side OCSP stapling to libtls.
Add support for server side OCSP stapling to netcat.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.29 2016/11/04 19:01:29 jsing Exp $ */
d217 1
a217 1
	if (SSL_CTX_set_tlsext_status_cb(ctx->ssl_ctx, tls_ocsp_stapling_cb) != 1) {
@


1.29
log
@Avoid shadowing the socket global.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.28 2016/09/14 11:34:37 bcook Exp $ */
d51 1
d216 5
@


1.28
log
@Set callbacks on the right tls ctx on accept.

From Tobias Pape
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.27 2016/09/04 13:20:56 jsing Exp $ */
d316 1
a316 1
tls_accept_socket(struct tls *ctx, struct tls **cctx, int socket)
d318 1
a318 1
	return (tls_accept_fds(ctx, cctx, socket, socket));
@


1.27
log
@Maintain consistency with function naming.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.26 2016/09/04 12:26:43 bcook Exp $ */
d354 1
a354 1
	if (tls_set_cbs(ctx, read_cb, write_cb, cb_arg) != 0) {
@


1.26
log
@Add callback-based interface to libtls.

This allows working with buffers and callback functions instead of directly on
sockets or file descriptors.
Original patch from Tobias Pape <tobias_at_netshed.de>.
ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.25 2016/08/22 14:51:37 jsing Exp $ */
d283 1
a283 1
accept_common(struct tls *ctx)
d326 1
a326 1
	if ((conn_ctx = accept_common(ctx)) == NULL)
d351 1
a351 1
	if ((conn_ctx = accept_common(ctx)) == NULL)
@


1.25
log
@Create contexts for server side SNI - these include the additional SSL_CTX
that is required for certificate switching with libssl and the certificate
itself so that we can match against the subject and SANs. Hook up the
servername callback and switch to the appropriate SSL_CTX if we find a
matching certificate.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.24 2016/08/18 15:52:03 jsing Exp $ */
d282 2
a283 8
int
tls_accept_socket(struct tls *ctx, struct tls **cctx, int socket)
{
	return (tls_accept_fds(ctx, cctx, socket, socket));
}

int
tls_accept_fds(struct tls *ctx, struct tls **cctx, int fd_read, int fd_write)
d301 1
d306 23
d338 6
d345 17
a363 1

@


1.24
log
@Split out the TLS server SSL_CTX allocation and configuration code, so
that it can be reused to allocate the additional SSL_CTXs needed for SNI.

ok reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.23 2016/08/15 14:04:23 jsing Exp $ */
d18 4
d70 86
d169 10
d237 30
d272 2
@


1.23
log
@Explicitly pass in an SSL_CTX * to the functions that operate on one,
instead of assuming that they should use the one associated with the TLS
context. This allows these functions to be used with the additional
SSL contexts that are needed to support server-side SNI.

Also rename tls_configure_keypair() to tls_configure_ssl_keypair(), so that
these functions have a common prefix.

ok reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.22 2016/08/12 15:10:59 jsing Exp $ */
d65 3
a67 2
int
tls_configure_server(struct tls *ctx)
d69 1
a70 1
	unsigned char sid[SSL_MAX_SSL_SESSION_ID_LENGTH];
d72 3
a74 1
	if ((ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {
d79 1
a79 1
	if (tls_configure_ssl(ctx, ctx->ssl_ctx) != 0)
d81 1
a81 2
	if (tls_configure_ssl_keypair(ctx, ctx->ssl_ctx,
	    ctx->config->keypair, 1) != 0)
d87 1
a87 1
		if (tls_configure_ssl_verify(ctx, ctx->ssl_ctx, verify) == -1)
d92 1
a92 1
		SSL_CTX_set_alpn_select_cb(ctx->ssl_ctx, tls_server_alpn_cb,
d96 1
a96 1
		SSL_CTX_set_dh_auto(ctx->ssl_ctx, 1);
d98 1
a98 1
		SSL_CTX_set_dh_auto(ctx->ssl_ctx, 2);
d101 1
a101 1
		SSL_CTX_set_ecdh_auto(ctx->ssl_ctx, 1);
d108 2
a109 2
		SSL_CTX_set_options(ctx->ssl_ctx, SSL_OP_SINGLE_ECDH_USE);
		SSL_CTX_set_tmp_ecdh(ctx->ssl_ctx, ecdh_key);
d114 1
a114 2
		SSL_CTX_set_options(ctx->ssl_ctx,
		    SSL_OP_CIPHER_SERVER_PREFERENCE);
d122 3
a124 2
	if (!SSL_CTX_set_session_id_context(ctx->ssl_ctx, sid, sizeof(sid))) {
		tls_set_errorx(ctx, "failed to set session id context");
d127 16
@


1.22
log
@Add ALPN support to libtls.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.21 2016/08/02 07:47:11 jsing Exp $ */
d76 1
a76 1
	if (tls_configure_ssl(ctx) != 0)
d78 2
a79 1
	if (tls_configure_keypair(ctx, ctx->ssl_ctx, ctx->config->keypair, 1) != 0)
d85 1
a85 1
		if (tls_configure_ssl_verify(ctx, verify) == -1)
@


1.21
log
@Revert previous since it adds new symbols.

Requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.20 2016/08/01 17:32:19 jsing Exp $ */
d51 14
d87 4
@


1.20
log
@Add ALPN support to libtls.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.19 2016/04/28 17:05:59 jsing Exp $ */
a50 14
static int
tls_server_alpn_cb(SSL *ssl, const unsigned char **out, unsigned char *outlen,
    const unsigned char *in, unsigned int inlen, void *arg)
{
	struct tls *ctx = arg;

	if (SSL_select_next_proto((unsigned char**)out, outlen,
	    ctx->config->alpn, ctx->config->alpn_len, in, inlen) ==
	    OPENSSL_NPN_NEGOTIATED)
		return (SSL_TLSEXT_ERR_OK);

	return (SSL_TLSEXT_ERR_NOACK);
}

a72 4

	if (ctx->config->alpn != NULL)
		SSL_CTX_set_alpn_select_cb(ctx->ssl_ctx, tls_server_alpn_cb,
		    ctx);
@


1.19
log
@Factor our the keypair handling in libtls. This results in more readable
and self-contained code, while preparing for the ability to handle
multiple keypairs. Also provide two additional functions that allow
a public certificate and private key to be set with a single function
call.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.18 2015/09/29 10:17:04 deraadt Exp $ */
d51 14
d87 4
@


1.18
log
@clean some ugly intendation warts
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.17 2015/09/12 19:54:31 jsing Exp $ */
d64 1
a64 1
	if (tls_configure_keypair(ctx, 1) != 0)
@


1.17
log
@Ensure that we clear the libssl error stack before we make a function call
that we will pass the result through tls_ssl_error() on failure. Otherwise
we can end up reporting spurious errors due to their being unrelated errors
already on the error stack.

Spotted by Marko Kreen.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.16 2015/09/11 08:31:26 beck Exp $ */
d94 1
a94 1
		    SSL_OP_CIPHER_SERVER_PREFERENCE); 
d123 1
a123 1
	
@


1.16
log
@actually set return value to 0 on success.
ok jsing@@ who wears the cone of shame.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.15 2015/09/10 10:14:20 jsing Exp $ */
d19 1
d171 1
@


1.15
log
@Split tls_handshake() out from tls_accept/tls_connect. By doing this the
tls_accept/tls_connect functions can be guaranteed to succeed or fail and
will no longer return TLS_READ_AGAIN/TLS_WRITE_AGAIN. This also resolves
the semantics of tls_accept_*.

The tls_handshake() function now does I/O and can return
TLS_READ_AGAIN/TLS_WRITE_AGAIN. Calls to tls_read() and tls_write() will
trigger the handshake if it has not already completed, meaning that in many
cases existing code will continue to work.

Discussed over many coffees at l2k15.

ok beck@@ bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.14 2015/09/10 09:10:42 jsing Exp $ */
d176 1
@


1.14
log
@Add support for preferring the server's cipher list or the client's cipher
list. Prefer the server's cipher list by default.

Based on a diff from Kyle Thompson <jmp at giga dot moe>.

ok beck@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.13 2015/09/09 19:49:07 jsing Exp $ */
d113 6
d121 1
a121 2
	struct tls *conn_ctx = *cctx;
	int ret, err;
d128 4
a131 6
	if (conn_ctx == NULL) {
		if ((conn_ctx = tls_server_conn(ctx)) == NULL) {
			tls_set_errorx(ctx, "connection context failure");
			goto err;
		}
		*cctx = conn_ctx;
d133 7
a139 13
		if ((conn_ctx->ssl_conn = SSL_new(ctx->ssl_ctx)) == NULL) {
			tls_set_errorx(ctx, "ssl failure");
			goto err;
		}
		if (SSL_set_app_data(conn_ctx->ssl_conn, conn_ctx) != 1) {
			tls_set_errorx(ctx, "ssl application data failure");
			goto err;
		}
		if (SSL_set_rfd(conn_ctx->ssl_conn, fd_read) != 1 ||
		    SSL_set_wfd(conn_ctx->ssl_conn, fd_write) != 1) {
			tls_set_errorx(ctx, "ssl file descriptor failure");
			goto err;
		}
d141 3
a143 6

	if ((ret = SSL_accept(conn_ctx->ssl_conn)) != 1) {
		err = tls_ssl_error(ctx, conn_ctx->ssl_conn, ret, "accept");
		if (err == TLS_READ_AGAIN || err == TLS_WRITE_AGAIN) {
			return (err);
		}
d147 2
d152 4
d160 1
a160 1
tls_accept_socket(struct tls *ctx, struct tls **cctx, int socket)
d162 17
a178 1
	return (tls_accept_fds(ctx, cctx, socket, socket));
@


1.13
log
@Indent labels with a space so that diff -p is more friendly.

Requested by bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.12 2015/09/09 19:23:04 beck Exp $ */
d90 4
@


1.12
log
@Add client certificate support. Still needs a few tweaks but this will
ride upcoming minor bump
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.11 2015/09/09 14:32:06 jsing Exp $ */
d104 1
a104 1
err:
d151 1
a151 1
err:
@


1.11
log
@Only take ownership of a socket if we allocated it within libtls. If we are
passed a socket then the caller is responsible for closing it.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.10 2015/08/27 15:26:50 jsing Exp $ */
d63 1
a63 1
	if (tls_configure_keypair(ctx) != 0)
d65 7
@


1.10
log
@Improve libtls error messages.

The tls_set_error() function previously stored the errno but did nothing
with it. Change tls_set_error() to append the strerror(3) of the stored
errno so that we include useful information regarding failures.

Provide a tls_set_errorx() function that does not store the errno or
include strerror(3) in the error message. Call this function instead of
tls_set_error() for errors where the errno value has no useful meaning.

With feedback from and ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.9 2015/08/22 14:52:39 jsing Exp $ */
d151 1
a151 7
	int rv;

	rv = tls_accept_fds(ctx, cctx, socket, socket);
	if (*cctx != NULL)
		(*cctx)->socket = socket;

	return (rv);
@


1.9
log
@Unify error message between client and server.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.8 2015/08/22 14:51:34 jsing Exp $ */
d57 1
a57 1
		tls_set_error(ctx, "ssl context failure");
d76 1
a76 1
			tls_set_error(ctx, "failed to set ECDHE curve");
d91 1
a91 1
		tls_set_error(ctx, "failed to set session id context");
d108 1
a108 1
		tls_set_error(ctx, "not a server context");
d114 1
a114 1
			tls_set_error(ctx, "connection context failure");
d120 1
a120 1
			tls_set_error(ctx, "ssl failure");
d124 1
a124 1
			tls_set_error(ctx, "ssl application data failure");
d129 1
a129 1
			tls_set_error(ctx, "ssl file descriptor failure");
@


1.8
log
@SSL_set_app_data is a macro for SSL_set_ex_data(), which is a wrapper
around CRYPTO_set_ex_data(), which can fail. Since this is the case, check
the return value of CRYPTO_set_ex_data^WSSL_set_ex_data^WSSL_set_app_data.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.7 2015/03/31 14:03:38 jsing Exp $ */
d129 1
a129 1
			tls_set_error(ctx, "ssl set fd failure");
@


1.7
log
@Provide a tls_accept_fds() function, which allows a TLS connection to be
accepted via an existing pair of file descriptors.

Based on a diff from Jan Klemkow.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.6 2015/03/31 12:21:27 jsing Exp $ */
d123 4
a126 1

a131 1
		SSL_set_app_data(conn_ctx->ssl_conn, conn_ctx);
@


1.6
log
@Store errors that occur during a tls_accept_socket() call on the context
for the server, rather than on the context for the connection. This makes
more sense than the current behaviour does.

Issue reported by Tim van der Molen.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.5 2015/02/07 09:50:09 jsing Exp $ */
d102 1
a102 1
tls_accept_socket(struct tls *ctx, struct tls **cctx, int socket)
a118 2
		conn_ctx->socket = socket;

d124 2
a125 1
		if (SSL_set_fd(conn_ctx->ssl_conn, socket) != 1) {
d144 12
@


1.5
log
@Convert tls_connect_fds() and tls_accept_socket() to the new OpenSSL error
dance handling code. This means that we get slightly useful messages when
a TLS connection or accept fails.

Requested by reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.4 2015/02/07 06:19:26 jsing Exp $ */
d134 1
a134 1
		err = tls_ssl_error(conn_ctx, ret, "accept");
@


1.4
log
@Add tls_config_set_dheparams() to allow specification of the parameters to
use for DHE. This enables the use of DHE cipher suites.

Rename tls_config_set_ecdhcurve() to tls_config_set_ecdhecurve() since it
is only used to specify the curve for ephemeral ECDH.

Discussed with reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.3 2015/01/30 14:25:37 bluhm Exp $ */
d105 1
a105 1
	int ret, ssl_err;
d134 3
a136 9
		ssl_err = SSL_get_error(conn_ctx->ssl_conn, ret);
		switch (ssl_err) {
		case SSL_ERROR_WANT_READ:
			return (TLS_READ_AGAIN);
		case SSL_ERROR_WANT_WRITE:
			return (TLS_WRITE_AGAIN);
		default:
			tls_set_error(ctx, "TLS accept failed (%i)", ssl_err);
			goto err;
d138 1
@


1.3
log
@Make the TLS connect and accept error messages consistent.
OK jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.2 2015/01/16 14:34:51 reyk Exp $ */
d66 6
a71 1
	if (ctx->config->ecdhcurve == -1) {
d73 1
a73 1
	} else if (ctx->config->ecdhcurve != NID_undef) {
d75 2
a76 2
		    ctx->config->ecdhcurve)) == NULL) {
			tls_set_error(ctx, "failed to set ECDH curve");
@


1.2
log
@The SSL/TLS session Id context is limited to 32 bytes.  Instead of
using the name of relayd relay or smtpd pki, use a 32 byte arc4random
buffer that should be unique for the context.  This fixes an issue in
OpenSMTPD when a long pki name could break the configuration.

OK gilles@@ benno@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.1 2014/10/31 13:46:17 jsing Exp $ */
d136 1
a136 2
			tls_set_error(ctx, "ssl accept failure (%i)",
			    ssl_err);
@


1.1
log
@Rename libressl to libtls to avoid confusion and to make it easier to
distinguish between LibreSSL (the project) and libressl (the library).

Discussed with many.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_server.c,v 1.11 2014/10/15 14:08:26 jsing Exp $ */
d54 1
d77 11
@

