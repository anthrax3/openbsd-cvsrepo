head	1.43;
access;
symbols
	OPENBSD_6_2:1.43.0.4
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15;
locks; strict;
comment	@ * @;


1.43
date	2017.08.10.18.18.30;	author jsing;	state Exp;
branches;
next	1.42;
commitid	JWjAtg2Qibcivg2a;

1.42
date	2017.05.07.03.27.06;	author jsing;	state Exp;
branches;
next	1.41;
commitid	F7xY9fUl97hosMOM;

1.41
date	2017.04.10.17.11.13;	author jsing;	state Exp;
branches;
next	1.40;
commitid	3nmBs0stdHQq3Td1;

1.40
date	2017.01.26.12.56.37;	author jsing;	state Exp;
branches;
next	1.39;
commitid	fXjilM4ZG2ENdzA8;

1.39
date	2017.01.12.16.15.58;	author jsing;	state Exp;
branches;
next	1.38;
commitid	7YglLcbrBOWu1uon;

1.38
date	2016.12.26.16.20.58;	author jsing;	state Exp;
branches;
next	1.37;
commitid	Z4OhofWr8Q2T59FE;

1.37
date	2016.11.02.15.18.42;	author beck;	state Exp;
branches;
next	1.36;
commitid	OsrmWrsuHXqdXb2Z;

1.36
date	2016.09.04.13.20.56;	author jsing;	state Exp;
branches;
next	1.35;
commitid	wbsAjBek9Ycbf7w3;

1.35
date	2016.09.04.12.26.43;	author bcook;	state Exp;
branches;
next	1.34;
commitid	pRMpDkZhqg5jtYzf;

1.34
date	2016.08.15.14.04.23;	author jsing;	state Exp;
branches;
next	1.33;
commitid	skqiBPIfpiAFudga;

1.33
date	2016.04.28.17.05.59;	author jsing;	state Exp;
branches;
next	1.32;
commitid	DKpbOonvEBeRoW5p;

1.32
date	2015.10.09.04.13.34;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	Ljb8NYbGQStgDvIp;

1.31
date	2015.10.08.20.13.45;	author guenther;	state Exp;
branches;
next	1.30;
commitid	gyYZuuS3xJiEGy6N;

1.30
date	2015.09.29.13.10.53;	author jsing;	state Exp;
branches;
next	1.29;
commitid	oxmr750TVHvGS4sq;

1.29
date	2015.09.29.10.17.04;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	YDjtN3rqnZIVf1NW;

1.28
date	2015.09.12.19.54.31;	author jsing;	state Exp;
branches;
next	1.27;
commitid	tI7XkG4J1fY7en1u;

1.27
date	2015.09.11.12.56.55;	author beck;	state Exp;
branches;
next	1.26;
commitid	sb4du43rG1oa1RCm;

1.26
date	2015.09.10.10.14.20;	author jsing;	state Exp;
branches;
next	1.25;
commitid	XGvr88Fsecamv3XQ;

1.25
date	2015.09.09.19.49.07;	author jsing;	state Exp;
branches;
next	1.24;
commitid	8fjywsQemyYNWdJq;

1.24
date	2015.09.09.19.23.04;	author beck;	state Exp;
branches;
next	1.23;
commitid	nJxZtGxH6XzyXez3;

1.23
date	2015.09.09.14.32.06;	author jsing;	state Exp;
branches;
next	1.22;
commitid	lE2H6vYPmLedqh3T;

1.22
date	2015.09.08.15.29.34;	author jsing;	state Exp;
branches;
next	1.21;
commitid	9K0WzhcufWMotXmA;

1.21
date	2015.08.27.15.26.50;	author jsing;	state Exp;
branches;
next	1.20;
commitid	5FIlAb8mLiRyTsjH;

1.20
date	2015.08.27.14.34.46;	author jsing;	state Exp;
branches;
next	1.19;
commitid	VxGExiBacrXbtka4;

1.19
date	2015.08.22.14.51.34;	author jsing;	state Exp;
branches;
next	1.18;
commitid	vVrra6TLLBoV3hKj;

1.18
date	2015.08.22.14.40.25;	author jsing;	state Exp;
branches;
next	1.17;
commitid	oGftGKGpr9tyNfXt;

1.17
date	2015.03.31.12.21.27;	author jsing;	state Exp;
branches;
next	1.16;
commitid	zTdtFn3A4fRovB4F;

1.16
date	2015.03.21.15.35.15;	author sthen;	state Exp;
branches;
next	1.15;
commitid	wcCtLMI6HjneXHG3;

1.15
date	2015.02.11.07.01.10;	author jsing;	state Exp;
branches;
next	1.14;
commitid	ZUCrxL1FSxDDlrBb;

1.14
date	2015.02.11.06.46.33;	author jsing;	state Exp;
branches;
next	1.13;
commitid	IjYTp2gC6lDO8mXr;

1.13
date	2015.02.09.09.23.39;	author reyk;	state Exp;
branches;
next	1.12;
commitid	aTJL8W5je5luIVQI;

1.12
date	2015.02.08.04.12.34;	author reyk;	state Exp;
branches;
next	1.11;
commitid	M0LP1Oylzt5IOxKR;

1.11
date	2015.02.07.09.50.09;	author jsing;	state Exp;
branches;
next	1.10;
commitid	QsFM5heC1IRpgG38;

1.10
date	2015.01.30.14.25.37;	author bluhm;	state Exp;
branches;
next	1.9;
commitid	h8UwIM5Ugf2vuzlB;

1.9
date	2015.01.22.09.16.24;	author reyk;	state Exp;
branches;
next	1.8;
commitid	MIkUgu4UHo6s43H0;

1.8
date	2015.01.13.17.35.35;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	VMyOPyiROGkwXBxx;

1.7
date	2015.01.02.16.38.07;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	HrITOZyv2JdeMrMf;

1.6
date	2014.12.27.19.35.28;	author bcook;	state Exp;
branches;
next	1.5;
commitid	g9HQi924VVXBinVR;

1.5
date	2014.12.07.16.56.17;	author bcook;	state Exp;
branches;
next	1.4;
commitid	ig91zabTuUs7Q4W8;

1.4
date	2014.12.07.15.48.02;	author bcook;	state Exp;
branches;
next	1.3;
commitid	fFnOSh51GKLvzA5B;

1.3
date	2014.12.07.15.00.32;	author bcook;	state Exp;
branches;
next	1.2;
commitid	KH9lDmo5JWgqgo2G;

1.2
date	2014.11.02.14.45.05;	author jsing;	state Exp;
branches;
next	1.1;
commitid	GgBCARgHkY5F5TEV;

1.1
date	2014.10.31.13.46.17;	author jsing;	state Exp;
branches;
next	;
commitid	y63FmUITd26yVanM;


desc
@@


1.43
log
@Add a tls_config_set_ecdhecurves() function to libtls, which allows the
names of the elliptic curves that may be used during client and server
key exchange to be specified.

This deprecates tls_config_set_ecdhecurve(), which could only be used to
specify a single supported curve.

ok beck@@
@
text
@/* $OpenBSD: tls_client.c,v 1.42 2017/05/07 03:27:06 jsing Exp $ */
/*
 * Copyright (c) 2014 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <arpa/inet.h>
#include <netinet/in.h>

#include <netdb.h>
#include <stdlib.h>
#include <unistd.h>

#include <openssl/err.h>
#include <openssl/x509.h>

#include <tls.h>
#include "tls_internal.h"

struct tls *
tls_client(void)
{
	struct tls *ctx;

	if ((ctx = tls_new()) == NULL)
		return (NULL);

	ctx->flags |= TLS_CLIENT;

	return (ctx);
}

int
tls_connect(struct tls *ctx, const char *host, const char *port)
{
	return tls_connect_servername(ctx, host, port, NULL);
}

int
tls_connect_servername(struct tls *ctx, const char *host, const char *port,
    const char *servername)
{
	struct addrinfo hints, *res, *res0;
	const char *h = NULL, *p = NULL;
	char *hs = NULL, *ps = NULL;
	int rv = -1, s = -1, ret;

	if ((ctx->flags & TLS_CLIENT) == 0) {
		tls_set_errorx(ctx, "not a client context");
		goto err;
	}

	if (host == NULL) {
		tls_set_errorx(ctx, "host not specified");
		goto err;
	}

	/*
	 * If port is NULL try to extract a port from the specified host,
	 * otherwise use the default.
	 */
	if ((p = (char *)port) == NULL) {
		ret = tls_host_port(host, &hs, &ps);
		if (ret == -1) {
			tls_set_errorx(ctx, "memory allocation failure");
			goto err;
		}
		if (ret != 0) {
			tls_set_errorx(ctx, "no port provided");
			goto err;
		}
	}

	h = (hs != NULL) ? hs : host;
	p = (ps != NULL) ? ps : port;

	/*
	 * First check if the host is specified as a numeric IP address,
	 * either IPv4 or IPv6, before trying to resolve the host.
	 * The AI_ADDRCONFIG resolver option will not return IPv4 or IPv6
	 * records if it is not configured on an interface;  not considering
	 * loopback addresses.  Checking the numeric addresses first makes
	 * sure that connection attempts to numeric addresses and especially
	 * 127.0.0.1 or ::1 loopback addresses are always possible.
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_STREAM;

	/* try as an IPv4 literal */
	hints.ai_family = AF_INET;
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(h, p, &hints, &res0) != 0) {
		/* try again as an IPv6 literal */
		hints.ai_family = AF_INET6;
		if (getaddrinfo(h, p, &hints, &res0) != 0) {
			/* last try, with name resolution and save the error */
			hints.ai_family = AF_UNSPEC;
			hints.ai_flags = AI_ADDRCONFIG;
			if ((s = getaddrinfo(h, p, &hints, &res0)) != 0) {
				tls_set_error(ctx, "%s", gai_strerror(s));
				goto err;
			}
		}
	}

	/* It was resolved somehow; now try connecting to what we got */
	s = -1;
	for (res = res0; res; res = res->ai_next) {
		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (s == -1) {
			tls_set_error(ctx, "socket");
			continue;
		}
		if (connect(s, res->ai_addr, res->ai_addrlen) == -1) {
			tls_set_error(ctx, "connect");
			close(s);
			s = -1;
			continue;
		}

		break;  /* Connected. */
	}
	freeaddrinfo(res0);

	if (s == -1)
		goto err;

	if (servername == NULL)
		servername = h;

	if (tls_connect_socket(ctx, s, servername) != 0) {
		close(s);
		goto err;
	}

	ctx->socket = s;

	rv = 0;

 err:
	free(hs);
	free(ps);

	return (rv);
}

static int
tls_connect_common(struct tls *ctx, const char *servername)
{
	union tls_addr addrbuf;
	int rv = -1;

	if ((ctx->flags & TLS_CLIENT) == 0) {
		tls_set_errorx(ctx, "not a client context");
		goto err;
	}

	if (servername != NULL) {
		if ((ctx->servername = strdup(servername)) == NULL) {
			tls_set_errorx(ctx, "out of memory");
			goto err;
		}
	}

	if ((ctx->ssl_ctx = SSL_CTX_new(SSLv23_client_method())) == NULL) {
		tls_set_errorx(ctx, "ssl context failure");
		goto err;
	}

	if (tls_configure_ssl(ctx, ctx->ssl_ctx) != 0)
		goto err;

	if (tls_configure_ssl_keypair(ctx, ctx->ssl_ctx,
	    ctx->config->keypair, 0) != 0)
		goto err;

	if (ctx->config->verify_name) {
		if (servername == NULL) {
			tls_set_errorx(ctx, "server name not specified");
			goto err;
		}
	}

	if (tls_configure_ssl_verify(ctx, ctx->ssl_ctx, SSL_VERIFY_PEER) == -1)
		goto err;

	if (ctx->config->ecdhecurves != NULL) {
		if (SSL_CTX_set1_groups(ctx->ssl_ctx, ctx->config->ecdhecurves,
		    ctx->config->ecdhecurves_len) != 1) {
			tls_set_errorx(ctx, "failed to set ecdhe curves");
			goto err;
		}
	}

	if (SSL_CTX_set_tlsext_status_cb(ctx->ssl_ctx, tls_ocsp_verify_cb) != 1) {
		tls_set_errorx(ctx, "ssl OCSP verification setup failure");
		goto err;
	}

	if ((ctx->ssl_conn = SSL_new(ctx->ssl_ctx)) == NULL) {
		tls_set_errorx(ctx, "ssl connection failure");
		goto err;
	}

	if (SSL_set_app_data(ctx->ssl_conn, ctx) != 1) {
		tls_set_errorx(ctx, "ssl application data failure");
		goto err;
	}

	if (SSL_set_tlsext_status_type(ctx->ssl_conn, TLSEXT_STATUSTYPE_ocsp) != 1) {
		tls_set_errorx(ctx, "ssl OCSP extension setup failure");
		goto err;
	}

	/*
	 * RFC4366 (SNI): Literal IPv4 and IPv6 addresses are not
	 * permitted in "HostName".
	 */
	if (servername != NULL &&
	    inet_pton(AF_INET, servername, &addrbuf) != 1 &&
	    inet_pton(AF_INET6, servername, &addrbuf) != 1) {
		if (SSL_set_tlsext_host_name(ctx->ssl_conn, servername) == 0) {
			tls_set_errorx(ctx, "server name indication failure");
			goto err;
		}
	}

	ctx->state |= TLS_CONNECTED;
	rv = 0;

 err:
	return (rv);
}

int
tls_connect_socket(struct tls *ctx, int s, const char *servername)
{
	return tls_connect_fds(ctx, s, s, servername);
}

int
tls_connect_fds(struct tls *ctx, int fd_read, int fd_write,
    const char *servername)
{
	int rv = -1;

	if (fd_read < 0 || fd_write < 0) {
		tls_set_errorx(ctx, "invalid file descriptors");
		goto err;
	}

	if (tls_connect_common(ctx, servername) != 0)
		goto err;

	if (SSL_set_rfd(ctx->ssl_conn, fd_read) != 1 ||
	    SSL_set_wfd(ctx->ssl_conn, fd_write) != 1) {
		tls_set_errorx(ctx, "ssl file descriptor failure");
		goto err;
	}

	rv = 0;
 err:
	return (rv);
}

int
tls_connect_cbs(struct tls *ctx, tls_read_cb read_cb,
    tls_write_cb write_cb, void *cb_arg, const char *servername)
{
	int rv = -1;

	if (tls_connect_common(ctx, servername) != 0)
		goto err;

	if (tls_set_cbs(ctx, read_cb, write_cb, cb_arg) != 0)
		goto err;

	rv = 0;

 err:
	return (rv);
}

int
tls_handshake_client(struct tls *ctx)
{
	X509 *cert = NULL;
	int match, ssl_ret;
	int rv = -1;

	if ((ctx->flags & TLS_CLIENT) == 0) {
		tls_set_errorx(ctx, "not a client context");
		goto err;
	}

	if ((ctx->state & TLS_CONNECTED) == 0) {
		tls_set_errorx(ctx, "context not connected");
		goto err;
	}

	ctx->state |= TLS_SSL_NEEDS_SHUTDOWN;

	ERR_clear_error();
	if ((ssl_ret = SSL_connect(ctx->ssl_conn)) != 1) {
		rv = tls_ssl_error(ctx, ctx->ssl_conn, ssl_ret, "handshake");
		goto err;
	}

	if (ctx->config->verify_name) {
		cert = SSL_get_peer_certificate(ctx->ssl_conn);
		if (cert == NULL) {
			tls_set_errorx(ctx, "no server certificate");
			goto err;
		}
		if (tls_check_name(ctx, cert, ctx->servername, &match) == -1)
			goto err;
		if (!match) {
			tls_set_errorx(ctx, "name `%s' not present in"
			    " server certificate", ctx->servername);
			goto err;
		}
	}

	ctx->state |= TLS_HANDSHAKE_COMPLETE;
	rv = 0;

 err:
	X509_free(cert);

	return (rv);
}
@


1.42
log
@Ensure that a client context has been connected before attempting to
complete a TLS handshake.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.41 2017/04/10 17:11:13 jsing Exp $ */
d200 8
@


1.41
log
@Rework name verification code so that a match is indicated via an argument,
rather than return codes. More strictly follow RFC 6125, in particular only
check the CN if there are no SAN identifiers present in the certificate
(per section 6.4.4).

Previous behaviour questioned by Daniel Stenberg <daniel at haxx dot se>.

ok beck@@ jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.40 2017/01/26 12:56:37 jsing Exp $ */
d233 2
d299 5
@


1.40
log
@Use a flag to track when we need to call SSL_shutdown(). This avoids an
issue where by calling tls_close() on a TLS context that has not attempted
a handshake, results in an unexpected failure.

Reported by Vinay Sajip.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.39 2017/01/12 16:15:58 jsing Exp $ */
d292 1
a292 1
	int ssl_ret;
d314 5
a318 5
		if ((rv = tls_check_name(ctx, cert,
		    ctx->servername)) != 0) {
			if (rv != -2)
				tls_set_errorx(ctx, "name `%s' not present in"
				    " server certificate", ctx->servername);
@


1.39
log
@If tls_set_cbs() fails an error will already be specified, so do not
replace it with a less specific one.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.38 2016/12/26 16:20:58 jsing Exp $ */
d299 2
@


1.38
log
@Hook up a certificate verify callback so that we can set user friendly
error messages, instead of libssl error strings. This gives us messages
like:

  certificate verification failed: certificate has expired

Instead of:

  14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed

This also lets us always enable peer verification since the no verification
case is now handled via the callback.

Tested by tedu@@

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.37 2016/11/02 15:18:42 beck Exp $ */
d279 1
a279 2
	if (tls_set_cbs(ctx, read_cb, write_cb, cb_arg) != 0) {
		tls_set_errorx(ctx, "callback registration failure");
a280 1
	}
@


1.37
log
@Add OCSP client side support to libtls.
   - Provide access to certificate OCSP URL
   - Provide ability to check a raw OCSP reply against an
     established TLS ctx
   - Check and validate OCSP stapling info in the TLS handshake
     if a stapled OCSP response is provided.`

Add example code to show OCSP URL and stapled info
into netcat.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.36 2016/09/04 13:20:56 jsing Exp $ */
d198 1
a198 3
	if (ctx->config->verify_cert &&
	    (tls_configure_ssl_verify(ctx, ctx->ssl_ctx,
	     SSL_VERIFY_PEER) == -1))
@


1.36
log
@Maintain consistency with function naming.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.35 2016/09/04 12:26:43 bcook Exp $ */
d203 5
d215 5
@


1.35
log
@Add callback-based interface to libtls.

This allows working with buffers and callback functions instead of directly on
sockets or file descriptors.
Original patch from Tobias Pape <tobias_at_netshed.de>.
ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.34 2016/08/15 14:04:23 jsing Exp $ */
d162 1
a162 1
connect_common(struct tls *ctx, const char *servername)
d248 1
a248 1
	if (connect_common(ctx, servername) != 0)
d268 1
a268 1
	if (connect_common(ctx, servername) != 0)
@


1.34
log
@Explicitly pass in an SSL_CTX * to the functions that operate on one,
instead of assuming that they should use the one associated with the TLS
context. This allows these functions to be used with the additional
SSL contexts that are needed to support server-side SNI.

Also rename tls_configure_keypair() to tls_configure_ssl_keypair(), so that
these functions have a common prefix.

ok reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.33 2016/04/28 17:05:59 jsing Exp $ */
d161 2
a162 9
int
tls_connect_socket(struct tls *ctx, int s, const char *servername)
{
	return tls_connect_fds(ctx, s, s, servername);
}

int
tls_connect_fds(struct tls *ctx, int fd_read, int fd_write,
    const char *servername)
a171 5
	if (fd_read < 0 || fd_write < 0) {
		tls_set_errorx(ctx, "invalid file descriptors");
		goto err;
	}

d186 1
d197 1
d207 1
a211 5
	if (SSL_set_rfd(ctx->ssl_conn, fd_read) != 1 ||
	    SSL_set_wfd(ctx->ssl_conn, fd_write) != 1) {
		tls_set_errorx(ctx, "ssl file descriptor failure");
		goto err;
	}
d224 50
@


1.33
log
@Factor our the keypair handling in libtls. This results in more readable
and self-contained code, while preparing for the ability to handle
multiple keypairs. Also provide two additional functions that allow
a public certificate and private key to be set with a single function
call.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.32 2015/10/09 04:13:34 deraadt Exp $ */
d196 1
a196 1
	if (tls_configure_ssl(ctx) != 0)
d198 2
a199 1
	if (tls_configure_keypair(ctx, ctx->ssl_ctx, ctx->config->keypair, 0) != 0)
a207 1

d209 2
a210 1
	    (tls_configure_ssl_verify(ctx, SSL_VERIFY_PEER) == -1))
@


1.32
log
@fix a gotcha in the connect refactoring, that could result in dropping
through and trying to bind failed v6 connects.
ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.31 2015/10/08 20:13:45 guenther Exp $ */
d198 1
a198 1
	if (tls_configure_keypair(ctx, 0) != 0)
@


1.31
log
@If getaddrinfo() succeeds, then don't try look ups with other flags, even
if the connect()s failed.  In concert with some resolver fixes in libc,
this lets ntpd be tame()ed

problem isolated by theo, who had fun untangling the libc and libtls
behaviors to place blame for not being able to tame ntpd

ok beck@@ deraadt@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.30 2015/09/29 13:10:53 jsing Exp $ */
d121 1
d138 3
@


1.30
log
@Instead of declaring a union in multiple places, move it to tls_internal.h.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.29 2015/09/29 10:17:04 deraadt Exp $ */
a46 36
static int
tls_connect_host(struct tls *ctx, const char *host, const char *port,
    int af, int flag)
{
	struct addrinfo hints, *res, *res0;
	int s = -1;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = af;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = flag;

	if ((s = getaddrinfo(host, port, &hints, &res0)) != 0) {
		tls_set_error(ctx, "%s", gai_strerror(s));
		return (-1);
	}
	for (res = res0; res; res = res->ai_next) {
		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (s == -1) {
			tls_set_error(ctx, "socket");
			continue;
		}
		if (connect(s, res->ai_addr, res->ai_addrlen) == -1) {
			tls_set_error(ctx, "connect");
			close(s);
			s = -1;
			continue;
		}

		break;  /* Connected. */
	}
	freeaddrinfo(res0);

	return (s);
}

d57 1
d100 37
a136 4
	if ((s = tls_connect_host(ctx, h, p, AF_INET, AI_NUMERICHOST)) == -1 &&
	    (s = tls_connect_host(ctx, h, p, AF_INET6, AI_NUMERICHOST)) == -1 &&
	    (s = tls_connect_host(ctx, h, p, AF_UNSPEC, AI_ADDRCONFIG)) == -1)
		goto err;
@


1.29
log
@clean some ugly intendation warts
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.28 2015/09/12 19:54:31 jsing Exp $ */
d169 1
a169 4
	union {
		struct in_addr ip4;
		struct in6_addr ip6;
	} addrbuf;
@


1.28
log
@Ensure that we clear the libssl error stack before we make a function call
that we will pass the result through tls_ssl_error() on failure. Otherwise
we can end up reporting spurious errors due to their being unrelated errors
already on the error stack.

Spotted by Marko Kreen.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.27 2015/09/11 12:56:55 beck Exp $ */
d169 4
a172 1
	union { struct in_addr ip4; struct in6_addr ip6; } addrbuf;
@


1.27
log
@add tls_peer functions for checking names and issuers of peer certificates.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.26 2015/09/10 10:14:20 jsing Exp $ */
d28 1
d255 1
@


1.26
log
@Split tls_handshake() out from tls_accept/tls_connect. By doing this the
tls_accept/tls_connect functions can be guaranteed to succeed or fail and
will no longer return TLS_READ_AGAIN/TLS_WRITE_AGAIN. This also resolves
the semantics of tls_accept_*.

The tls_handshake() function now does I/O and can return
TLS_READ_AGAIN/TLS_WRITE_AGAIN. Calls to tls_read() and tls_write() will
trigger the handshake if it has not already completed, meaning that in many
cases existing code will continue to work.

Discussed over many coffees at l2k15.

ok beck@@ bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.25 2015/09/09 19:49:07 jsing Exp $ */
d265 1
a265 1
		if ((rv = tls_check_servername(ctx, cert,
@


1.25
log
@Indent labels with a space so that diff -p is more friendly.

Requested by bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.24 2015/09/09 19:23:04 beck Exp $ */
d169 1
a169 2
	X509 *cert = NULL;
	int ret, err;
a175 3
	if (ctx->state & TLS_STATE_CONNECTING)
		goto connecting;

d178 8
a185 1
		return (-1);
d236 20
a255 7
 connecting:
	if ((ret = SSL_connect(ctx->ssl_conn)) != 1) {
		err = tls_ssl_error(ctx, ctx->ssl_conn, ret, "connect");
		if (err == TLS_READ_AGAIN || err == TLS_WRITE_AGAIN) {
			ctx->state |= TLS_STATE_CONNECTING;
			return (err);
		}
a257 1
	ctx->state &= ~TLS_STATE_CONNECTING;
d265 3
a267 2
		if ((ret = tls_check_servername(ctx, cert, servername)) != 0) {
			if (ret != -2)
d269 1
a269 1
				    " server certificate", servername);
a271 1
		X509_free(cert);
d274 2
a275 1
	return (0);
d280 1
a280 1
	return (-1);
@


1.24
log
@Add client certificate support. Still needs a few tweaks but this will
ride upcoming minor bump
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.23 2015/09/09 14:32:06 jsing Exp $ */
d151 1
a151 1
err:
d233 1
a233 1
connecting:
d261 1
a261 1
err:
@


1.23
log
@Only take ownership of a socket if we allocated it within libtls. If we are
passed a socket then the caller is responsible for closing it.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.22 2015/09/08 15:29:34 jsing Exp $ */
a23 1
#include <limits.h>
d192 2
d202 3
a204 24
	if (ctx->config->verify_cert) {
		SSL_CTX_set_verify(ctx->ssl_ctx, SSL_VERIFY_PEER, NULL);

		if (ctx->config->ca_mem != NULL) {
			if (ctx->config->ca_len > INT_MAX) {
				tls_set_errorx(ctx, "ca too long");
				goto err;
			}

			if (SSL_CTX_load_verify_mem(ctx->ssl_ctx,
			    ctx->config->ca_mem, ctx->config->ca_len) != 1) {
				tls_set_errorx(ctx,
				    "ssl verify memory setup failure");
				goto err;
			}
		} else if (SSL_CTX_load_verify_locations(ctx->ssl_ctx,
		    ctx->config->ca_file, ctx->config->ca_path) != 1) {
			tls_set_errorx(ctx, "ssl verify setup failure");
			goto err;
		}
		if (ctx->config->verify_depth >= 0)
			SSL_CTX_set_verify_depth(ctx->ssl_ctx,
			    ctx->config->verify_depth);
	}
@


1.22
log
@Remove the default HTTPS port from tls_connect() - this is a TLS library,
not a HTTPS library.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.21 2015/08/27 15:26:50 jsing Exp $ */
d148 2
a161 2
	ctx->socket = s;

@


1.21
log
@Improve libtls error messages.

The tls_set_error() function previously stored the errno but did nothing
with it. Change tls_set_error() to append the strerror(3) of the stored
errno so that we include useful information regarding failures.

Provide a tls_set_errorx() function that does not store the errno or
include strerror(3) in the error message. Call this function instead of
tls_set_error() for errors where the errno value has no useful meaning.

With feedback from and ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.20 2015/08/27 14:34:46 jsing Exp $ */
d117 4
a120 2
		if (ret != 0)
			port = HTTPS_PORT;
@


1.20
log
@Split the persistent/configuration flags from temporary state flags and
ensure that the temporary state flags get cleared in tls_reset(). Fixes a
bug spotted by Marko Kreen whereby TLS_CONNECTING could remain on reset.

While here, also move the TLS_STATE_CONNECTING check to after the
TLS_CLIENT check - if TLS_STATE_CONNECTING was ever set on any other
context type it would allow a bypass.

ok bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.19 2015/08/22 14:51:34 jsing Exp $ */
d98 1
a98 1
		tls_set_error(ctx, "not a client context");
d103 1
a103 1
		tls_set_error(ctx, "host not specified");
d114 1
a114 1
			tls_set_error(ctx, "memory allocation failure");
d172 1
a172 1
		tls_set_error(ctx, "not a client context");
d180 1
a180 1
		tls_set_error(ctx, "invalid file descriptors");
d185 1
a185 1
		tls_set_error(ctx, "ssl context failure");
d194 1
a194 1
			tls_set_error(ctx, "server name not specified");
d204 1
a204 1
				tls_set_error(ctx, "ca too long");
d210 1
a210 1
				tls_set_error(ctx,
d216 1
a216 1
			tls_set_error(ctx, "ssl verify setup failure");
d225 1
a225 1
		tls_set_error(ctx, "ssl connection failure");
d229 1
a229 1
		tls_set_error(ctx, "ssl application data failure");
d234 1
a234 1
		tls_set_error(ctx, "ssl file descriptor failure");
d246 1
a246 1
			tls_set_error(ctx, "server name indication failure");
d265 1
a265 1
			tls_set_error(ctx, "no server certificate");
d270 1
a270 1
				tls_set_error(ctx, "name `%s' not present in"
@


1.19
log
@SSL_set_app_data is a macro for SSL_set_ex_data(), which is a wrapper
around CRYPTO_set_ex_data(), which can fail. Since this is the case, check
the return value of CRYPTO_set_ex_data^WSSL_set_ex_data^WSSL_set_app_data.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.18 2015/08/22 14:40:25 jsing Exp $ */
a170 3
	if (ctx->flags & TLS_CONNECTING)
		goto connecting;

d176 3
d251 1
a251 1
 connecting:
d255 1
a255 1
			ctx->flags |= TLS_CONNECTING;
d260 1
a260 1
	ctx->flags &= ~TLS_CONNECTING;
@


1.18
log
@Store a reference to the libtls context in the SSL client connection app
data (as is already done for server connections).

From Marko Kreen.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.17 2015/03/31 12:21:27 jsing Exp $ */
d228 4
a231 2
	SSL_set_app_data(ctx->ssl_conn, ctx);

@


1.17
log
@Store errors that occur during a tls_accept_socket() call on the context
for the server, rather than on the context for the connection. This makes
more sense than the current behaviour does.

Issue reported by Tim van der Molen.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.16 2015/03/21 15:35:15 sthen Exp $ */
d228 2
@


1.16
log
@free the server certificate in tls_connect_fds(); fixes a memory leak with
repeated use of tls_connect.  ok jsing
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.15 2015/02/11 07:01:10 jsing Exp $ */
d249 1
a249 1
		err = tls_ssl_error(ctx, ret, "connect");
@


1.15
log
@Provide a tls_connect_servername() function that has the same behaviour
as tls_connect(), however allows the name to use for verification to be
explicitly provided, rather than being inferred from the host value.

Requested by reyk@@

ok reyk@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.14 2015/02/11 06:46:33 jsing Exp $ */
d270 1
@


1.14
log
@Be consistent with naming - only use "host" and "hostname" when referring
to an actual host and use "servername" when referring to the name of the
TLS server that we expect to be indentified in the server certificate.

Likewise, rename verify_host to verify_name and use the term "name"
throughout the verification code (rather than host or hostname).

Requested by and ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.13 2015/02/09 09:23:39 reyk Exp $ */
d86 7
d138 4
a141 1
	if (tls_connect_socket(ctx, s, h) != 0) {
a148 1

@


1.13
log
@When parsing the host in tls_connect(), first check if it is a numeric
IPv4 or IPv6 address before trying to resolve the address with the
AI_ADDRCONFIG flag set.  This makes sure that attempts to connect to
numeric IPs or loopback addresses are always possible and not
prevented by AI_ADDRCONFIG.

OK jsing@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.12 2015/02/08 04:12:34 reyk Exp $ */
d147 1
a147 1
tls_connect_socket(struct tls *ctx, int s, const char *hostname)
d151 1
a151 1
	return tls_connect_fds(ctx, s, s, hostname);
d156 1
a156 1
    const char *hostname)
d183 2
a184 2
	if (ctx->config->verify_host) {
		if (hostname == NULL) {
d229 5
a233 5
	if (hostname != NULL &&
	    inet_pton(AF_INET, hostname, &addrbuf) != 1 &&
	    inet_pton(AF_INET6, hostname, &addrbuf) != 1) {
		if (SSL_set_tlsext_host_name(ctx->ssl_conn, hostname) == 0) {
			tls_set_error(ctx, "SNI host name failed");
d249 1
a249 1
	if (ctx->config->verify_host) {
d255 1
a255 1
		if ((ret = tls_check_hostname(ctx, cert, hostname)) != 0) {
d257 2
a258 2
				tls_set_error(ctx, "host `%s' not present in"
				    " server certificate", hostname);
@


1.12
log
@Use the AI_ADDRCONFIG flag in tls_connect().  This tells the resolver
to ignore unsupported address families - eg. don't resolv IPv6 on
IPv4-only hosts.

OK jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.11 2015/02/07 09:50:09 jsing Exp $ */
d47 36
a85 1
	struct addrinfo hints, *res, *res0;
d117 12
a128 27
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_ADDRCONFIG;

	if ((ret = getaddrinfo(h, p, &hints, &res0)) != 0) {
		tls_set_error(ctx, "%s", gai_strerror(ret));
		goto err;
	}
	for (res = res0; res; res = res->ai_next) {
		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (s == -1) {
			tls_set_error(ctx, "socket");
			continue;
		}
		if (connect(s, res->ai_addr, res->ai_addrlen) == -1) {
			tls_set_error(ctx, "connect");
			close(s);
			s = -1;
			continue;
		}

		break;  /* Connected. */
	}
	freeaddrinfo(res0);

	if (s == -1)
@


1.11
log
@Convert tls_connect_fds() and tls_accept_socket() to the new OpenSSL error
dance handling code. This means that we get slightly useful messages when
a TLS connection or accept fails.

Requested by reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.10 2015/01/30 14:25:37 bluhm Exp $ */
d85 1
@


1.10
log
@Make the TLS connect and accept error messages consistent.
OK jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.9 2015/01/22 09:16:24 reyk Exp $ */
d139 1
a139 1
	int ret, ssl_err;
d219 2
a220 3
		ssl_err = SSL_get_error(ctx->ssl_conn, ret);
		switch (ssl_err) {
		case SSL_ERROR_WANT_READ:
d222 1
a222 7
			return (TLS_READ_AGAIN);
		case SSL_ERROR_WANT_WRITE:
			ctx->flags |= TLS_CONNECTING;
			return (TLS_WRITE_AGAIN);
		default:
			tls_set_error(ctx, "TLS connect failed (%i)", ssl_err);
			goto err;
d224 1
@


1.9
log
@Allow to to load the CA chain directly from memory instead of
specifying a file.  This enables CA verification in privsep'ed
processes that are running chroot'ed without direct access to the
certificate files.

With feedback, tests, and OK from bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.8 2015/01/13 17:35:35 bluhm Exp $ */
d228 1
a228 1
			tls_set_error(ctx, "SSL connect failed: %i", ssl_err);
@


1.8
log
@For non-blocking sockets tls_connect_fds() could fail with EAGAIN.
Use the same logic from the read, write, accept functions to inform
the caller wether a readable or writable socket is needed.  After
that event, the connect function must be called again.  All the
checks before connecting are done only once.
OK tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.7 2015/01/02 16:38:07 bluhm Exp $ */
d24 1
d172 13
a184 1
		if (SSL_CTX_load_verify_locations(ctx->ssl_ctx,
@


1.7
log
@Rename the tls_connect_socket() parameter 'socket' to 's' to avoid
a compiler warning about shadowing a global declaration.
OK jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.6 2014/12/27 19:35:28 bcook Exp $ */
d138 4
a141 1
	int ret;
d204 1
d206 12
a217 3
		tls_set_error(ctx, "SSL connect failed: %i",
		    SSL_get_error(ctx->ssl_conn, ret));
		goto err;
d219 1
@


1.6
log
@include netinet/in.h to define struct in6_addr.

Noticed while testing libtls on FreeBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.5 2014/12/07 16:56:17 bcook Exp $ */
d125 1
a125 1
tls_connect_socket(struct tls *ctx, int socket, const char *hostname)
d127 1
a127 1
	ctx->socket = socket;
d129 1
a129 1
	return tls_connect_fds(ctx, socket, socket, hostname);
@


1.5
log
@Allow specific libtls hostname validation errors to propagate.

Remove direct calls to printf from the tls_check_hostname() path. This allows
NUL byte error messages to bubble up to the caller, to be logged in a
program-appropriate way. It also removes non-portable calls to getprogname().

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.4 2014/12/07 15:48:02 bcook Exp $ */
d22 1
@


1.4
log
@revert previous change for now, adjusting based on comments from jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.3 2014/12/07 15:00:32 bcook Exp $ */
d212 4
a215 3
		if (tls_check_hostname(cert, hostname) != 0) {
			tls_set_error(ctx, "host `%s' not present in"
			    " server certificate", hostname);
@


1.3
log
@Allow specific libtls hostname validation errors to propagate.

Remove direct calls to printf from the tls_check_hostname() path. This allows
NUL byte error messages to bubble up to the caller, to be logged in a
program-appropriate way. It also removes non-portable calls to getprogname().

The semantics of tls_error() are changed slightly: the last error message is
not necessarily preserved between subsequent calls into the library.
When the previous call to libtls succeeds, client programs should treat the
return value of tls_error() as undefined.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.2 2014/11/02 14:45:05 jsing Exp $ */
d212 3
a214 5
		tls_clear_error(ctx);
		if (tls_check_hostname(ctx, cert, hostname) != 0) {
			if (tls_error(ctx) == NULL)
				tls_set_error(ctx, "host `%s' not present in"
				    " server certificate", hostname);
@


1.2
log
@Add a tls_connect_fds() function that allows a secure connection to be
established using a pair of existing file descriptors.

Based on a diff/request from Jan Klemkow.

Rides previous libtls rename/library bump.

Discussed with tedu@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.1 2014/10/31 13:46:17 jsing Exp $ */
d212 5
a216 3
		if (tls_check_hostname(cert, hostname) != 0) {
			tls_set_error(ctx, "host `%s' not present in"
			    " server certificate", hostname);
@


1.1
log
@Rename libressl to libtls to avoid confusion and to make it easier to
distinguish between LibreSSL (the project) and libressl (the library).

Discussed with many.
@
text
@d1 1
a1 1
/* $OpenBSD: tls_client.c,v 1.5 2014/10/03 14:14:40 tedu Exp $ */
d126 9
d144 4
a147 1
	ctx->socket = socket;
d181 2
a182 1
	if (SSL_set_fd(ctx->ssl_conn, ctx->socket) != 1) {
@

