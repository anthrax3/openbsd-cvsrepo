head	1.9;
access;
symbols
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2013.11.13.22.37.00;	author deraadt;	state dead;
branches;
next	1.8;

1.8
date	2009.10.27.23.59.30;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.14.18.27.49;	author dhill;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.19.18.31.48;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.05.00.49.25;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.24.02.24.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.14.00.56.15;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	97.04.04.09.06.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	97.02.26.03.06.51;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.9
log
@fix_options() is not used by anything; remove API, crank major
ok sthen
@
text
@/*	$OpenBSD: fix_options.c,v 1.8 2009/10/27 23:59:30 deraadt Exp $	*/

 /*
  * Routine to disable IP-level socket options. This code was taken from 4.4BSD
  * rlogind and kernel source, but all mistakes in it are my fault.
  *
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip_var.h>
#include <netinet/ip.h>
#include <netdb.h>
#include <stdio.h>
#include <syslog.h>

#ifndef IPOPT_OPTVAL
#define IPOPT_OPTVAL	0
#define IPOPT_OLEN	1
#endif

#include "tcpd.h"

#define BUFFER_SIZE	512		/* Was: BUFSIZ */

/* fix_options - get rid of IP-level socket options */

void
fix_options(request)
struct request_info *request;
{
#ifdef IP_OPTIONS
    struct ipoption optbuf;
    char    lbuf[BUFFER_SIZE], *lp, *cp;
    int     ipproto;
    socklen_t optsize = sizeof(optbuf);
    size_t  lps;
    struct protoent *ip;
    int     fd = request->fd;
    int     i;
    struct sockaddr_storage ss;
    socklen_t sslen;

    /*
     * check if this is AF_INET socket
     * XXX IPv6 support?
     */
    sslen = sizeof(ss);
    if (getsockname(fd, (struct sockaddr *)&ss, &sslen) < 0) {
	syslog(LOG_ERR, "getsockname: %m");
	clean_exit(request);
    }
    if (ss.ss_family != AF_INET)
	return;
  
    if ((ip = getprotobyname("ip")) != 0)
	ipproto = ip->p_proto;
    else
	ipproto = IPPROTO_IP;

    if (getsockopt(fd, ipproto, IP_OPTIONS, (char *) &optbuf, &optsize) == 0
	&& optsize != 0) {

	/*
	 * Properly deal with source routing entries.  The original code
	 * here was wrong.
	 */
	for (i = 0; (void *)&optbuf.ipopt_list[i] - (void *)&optbuf <
	    optsize; ) {
		u_char c = (u_char)optbuf.ipopt_list[i];
		if (c == IPOPT_LSRR || c == IPOPT_SSRR) {
			syslog(LOG_WARNING,
			   "refused connect from %s with IP source routing options",
			       eval_client(request));
			clean_exit(request);
		}
		if (c == IPOPT_EOL)
			break;
		i += (c == IPOPT_NOP) ? 1 : (u_char)optbuf.ipopt_list[i+1];
	}

	lp = lbuf;
	lps = sizeof(lbuf);
	for (cp = (char *)&optbuf; optsize > 0 && lps > 0;
	     cp++, optsize--, lp += 3, lps -= 3)
		snprintf(lp, lps, " %2.2x", *cp);
	syslog(LOG_NOTICE,
	       "connect from %s with IP options (ignored):%s",
	       eval_client(request), lbuf);
	if (setsockopt(fd, ipproto, IP_OPTIONS, (char *) 0, optsize) != 0) {
	    syslog(LOG_ERR, "setsockopt IP_OPTIONS NULL: %m");
	    clean_exit(request);
	}
    }
#endif
}
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fix_options.c,v 1.7 2006/04/14 18:27:49 dhill Exp $	*/
@


1.7
log
@delint

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fix_options.c,v 1.6 2003/04/19 18:31:48 avsm Exp $	*/
a8 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#) fix_options.c 1.4 97/02/12 02:13:22";
#else
static char rcsid[] = "$OpenBSD: fix_options.c,v 1.6 2003/04/19 18:31:48 avsm Exp $";
#endif
#endif
@


1.6
log
@- kill unused var
- sscanf format string should scan for u_short not u_int
- some missing includes
- convert u_short -> in_port_t (from millert)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fix_options.c,v 1.5 2003/04/05 00:49:25 tdeval Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: fix_options.c,v 1.5 2003/04/05 00:49:25 tdeval Exp $";
d47 2
a48 1
    int     optsize = sizeof(optbuf), ipproto;
d54 1
a54 1
    int sslen;
@


1.5
log
@sprintf -> snprintf
ok tedu@@, krw@@; hints deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fix_options.c,v 1.4 2002/02/24 02:24:37 deraadt Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: fix_options.c,v 1.4 2002/02/24 02:24:37 deraadt Exp $";
a50 1
    unsigned int opt;
@


1.4
log
@wrong error message
@
text
@d1 1
a1 1
/*	$OpenBSD: fix_options.c,v 1.3 2000/10/14 00:56:15 itojun Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: fix_options.c,v 1.3 2000/10/14 00:56:15 itojun Exp $";
d48 1
d52 1
a52 1
    int     optlen, i;
d95 4
a98 3
	for (cp = (char *)&optbuf; optsize > 0 && lp < &lbuf[sizeof lbuf-1];
	    cp++, optsize--, lp += 3)
		sprintf(lp, " %2.2x", *cp);
@


1.3
log
@tcp wrapper support for IPv6.  from netbsd.
TODO: scoped address support may need more consideration (we are taking
safer side now - rejects too much).
@
text
@d1 1
a1 1
/*	$OpenBSD: fix_options.c,v 1.2 1997/04/04 09:06:28 deraadt Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: fix_options.c,v 1.2 1997/04/04 09:06:28 deraadt Exp $";
d61 1
a61 1
	syslog(LOG_ERR, "getpeername: %m");
@


1.2
log
@do source routing check correctly; this could use a test
@
text
@d1 1
a1 1
/*	$OpenBSD: fix_options.c,v 1.1 1997/02/26 03:06:51 downsj Exp $	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD: fix_options.c,v 1.1 1997/02/26 03:06:51 downsj Exp $";
d52 2
d55 12
@


1.1
log
@Initial integration of a much cleaned up libwrap.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d14 1
a14 1
static char rcsid[] = "$OpenBSD$";
d23 1
d45 2
a46 2
    unsigned char optbuf[BUFFER_SIZE / 3], *cp;
    char    lbuf[BUFFER_SIZE], *lp;
d51 1
a51 2
    int     optlen;
    unsigned char *first_option = optbuf;
d58 1
a58 1
    if (getsockopt(fd, ipproto, IP_OPTIONS, (char *) optbuf, &optsize) == 0
d62 2
a63 10
	 * Horror! 4.[34] BSD getsockopt() prepends the first-hop destination
	 * address to the result IP options list when source routing options
	 * are present (see <netinet/ip_var.h>), but produces no output for
	 * other IP options. Solaris 2.x getsockopt() does produce output for
	 * non-routing IP options, and uses the same format as BSD even when
	 * the space for the destination address is unused. However, we must
	 * be prepared to deal with systems that return the options only. The
	 * code below does the right thing with 4.[34]BSD derivatives and
	 * Solaris 2, but may occasionally miss source routing options on
	 * incompatible systems such as Linux. Their choice.
d65 12
a76 14
#define ADDR_LEN sizeof(struct in_addr)

	for (cp = optbuf + ADDR_LEN; cp < optbuf + optsize; cp++) {
	    opt = cp[IPOPT_OPTVAL];
	    if (opt != IPOPT_NOP) {
		if (opt == IPOPT_RR
		    || opt == IPOPT_TS
		    || opt == IPOPT_SECURITY
		    || opt == IPOPT_LSRR
		    || opt == IPOPT_SATID
		    || opt == IPOPT_SSRR)
		    first_option = cp;
		break;
	    }
a78 31
	/*
	 * Look for source routing options. Drop the connection when one is
	 * found. Just wiping the IP options is insufficient: we would still
	 * help the attacker by providing a real TCP sequence number, and the
	 * attacker would still be able to send packets (blind spoofing). I
	 * discussed this attack with Niels Provos, half a year before the
	 * attack was described in open mailing lists.
	 * 
	 * It would be cleaner to just return a yes/no reply and let the caller
	 * decide how to deal with it. Resident servers should not terminate.
	 * However I am not prepared to make changes to internal interfaces
	 * on short notice.
	 */
	for (cp = first_option; cp < optbuf + optsize; cp += optlen) {
	    opt = cp[IPOPT_OPTVAL];
	    if (opt == IPOPT_LSRR || opt == IPOPT_SSRR) {
		syslog(LOG_WARNING,
		   "refused connect from %s with IP source routing options",
		       eval_client(request));
		clean_exit(request);
	    }
	    if (opt == IPOPT_EOL)
		break;
	    if (opt == IPOPT_NOP) {
		optlen = 1;
	    } else {
		optlen = cp[IPOPT_OLEN];
		if (optlen <= 0)		/* Do not loop! */
		    break;
	    }
	}
d80 3
a82 2
	for (cp = optbuf; optsize > 0; cp++, optsize--, lp += 3)
	    sprintf(lp, " %2.2x", *cp);
@
