head	1.13;
access;
symbols
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2014.03.24.17.17.12;	author tedu;	state dead;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.30;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.19.18.31.48;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.31.02.29.17;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.22.02.13.12;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.07.03.32.04;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.13.17.44.47;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.14.00.56.15;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.01.03.23.17;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.06.06.15.34.44;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.06.30.06.05.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.03.29.04.14.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.02.26.03.06.52;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.13
log
@The secret of steel has always carried with it a mystery. You must learn
its riddle, Conan. You must learn its discipline. For no one, no one in
this world can you trust. Not men, not women, not beasts.
@
text
@/*	$OpenBSD: hosts_access.c,v 1.12 2009/10/27 23:59:30 deraadt Exp $	*/

 /*
  * This module implements a simple access control language that is based on
  * host (or domain) names, NIS (host) netgroup names, IP addresses (or
  * network numbers) and daemon process names. When a match is found the
  * search is terminated, and depending on whether PROCESS_OPTIONS is defined,
  * a list of options is executed or an optional shell command is executed.
  * 
  * Host and user names are looked up on demand, provided that suitable endpoint
  * information is available as sockaddr_in structures or TLI netbufs. As a
  * side effect, the pattern matching process may change the contents of
  * request structure fields.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Compile with -DNETGROUP if your library provides support for netgroups.
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */

/* System libraries. */

#include <sys/types.h>
#include <sys/param.h>
#ifdef INET6
#include <sys/socket.h>
#endif
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <syslog.h>
#include <ctype.h>
#include <errno.h>
#include <setjmp.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <limits.h>
#ifdef NETGROUP
#include <netgroup.h>
#endif
#include <netdb.h>


/* Local stuff. */

#include "tcpd.h"

/* Error handling. */

extern jmp_buf tcpd_buf;

/* Delimiters for lists of daemons or clients. */

static char sep[] = ", \t\r\n";

/* Constants to be used in assignments only, not in comparisons... */

#define	YES		1
#define	NO		0

 /*
  * These variables are globally visible so that they can be redirected in
  * verification mode.
  */

char   *hosts_allow_table = HOSTS_ALLOW;
char   *hosts_deny_table = HOSTS_DENY;
int     hosts_access_verbose = 0;

 /*
  * In a long-running process, we are not at liberty to just go away.
  */

int     resident = (-1);		/* -1, 0: unknown; +1: yes */

/* Forward declarations. */

static int table_match(char *, struct request_info *);
static int list_match(char *, struct request_info *,
    int (*)(char *, struct request_info *));
static int server_match(char *, struct request_info *);
static int client_match(char *, struct request_info *);
static int host_match(char *, struct host_info *);
static int string_match(char *, char *);
static int masked_match(char *, char *, char *);
static int masked_match4(char *, char *, char *);
#ifdef INET6
static int masked_match6(char *, char *, char *);
#endif

/* Size of logical line buffer. */

#define	BUFLEN 2048

/* hosts_access - host access control facility */

int     hosts_access(request)
struct request_info *request;
{
    int     verdict;

    /*
     * If the (daemon, client) pair is matched by an entry in the file
     * /etc/hosts.allow, access is granted. Otherwise, if the (daemon,
     * client) pair is matched by an entry in the file /etc/hosts.deny,
     * access is denied. Otherwise, access is granted. A non-existent
     * access-control file is treated as an empty file.
     * 
     * After a rule has been matched, the optional language extensions may
     * decide to grant or refuse service anyway. Or, while a rule is being
     * processed, a serious error is found, and it seems better to play safe
     * and deny service. All this is done by jumping back into the
     * hosts_access() routine, bypassing the regular return from the
     * table_match() function calls below.
     */

    if (resident <= 0)
	resident++;
    verdict = setjmp(tcpd_buf);
    if (verdict != 0)
	return (verdict == AC_PERMIT);
    if (table_match(hosts_allow_table, request))
	return (YES);
    if (table_match(hosts_deny_table, request))
	return (NO);
    return (YES);
}

/* table_match - match table entries with (daemon, client) pair */

static int table_match(table, request)
char   *table;
struct request_info *request;
{
    FILE   *fp;
    char    sv_list[BUFLEN];		/* becomes list of daemons */
    char   *cl_list;			/* becomes list of clients */
    char   *sh_cmd;			/* becomes optional shell command */
    int     match = NO;
    struct tcpd_context saved_context;

    saved_context = tcpd_context;		/* stupid compilers */

    /*
     * Between the fopen() and fclose() calls, avoid jumps that may cause
     * file descriptor leaks.
     */

    if ((fp = fopen(table, "r")) != 0) {
	tcpd_context.file = table;
	tcpd_context.line = 0;
	while (match == NO && xgets(sv_list, sizeof(sv_list), fp) != 0) {
	    if (sv_list[strlen(sv_list) - 1] != '\n') {
		tcpd_warn("missing newline or line too long");
		continue;
	    }
	    if (sv_list[0] == '#' || sv_list[strspn(sv_list, " \t\r\n")] == 0)
		continue;
	    if ((cl_list = split_at(sv_list, ':')) == 0) {
		tcpd_warn("missing \":\" separator");
		continue;
	    }
	    sh_cmd = split_at(cl_list, ':');
	    match = list_match(sv_list, request, server_match)
		&& list_match(cl_list, request, client_match);
	}
	(void) fclose(fp);
    } else if (errno != ENOENT) {
	tcpd_warn("cannot open %s: %m", table);
    }
    if (match) {
	if (hosts_access_verbose > 1)
	    syslog(LOG_DEBUG, "matched:  %s line %d",
		   tcpd_context.file, tcpd_context.line);
	if (sh_cmd) {
#ifdef PROCESS_OPTIONS
	    process_options(sh_cmd, request);
#else
	    char    cmd[BUFSIZ];
	    shell_cmd(percent_x(cmd, sizeof(cmd), sh_cmd, request));
#endif
	}
    }
    tcpd_context = saved_context;
    return (match);
}

/* list_match - match a request against a list of patterns with exceptions */

static int list_match(list, request, match_fn)
char   *list;
struct request_info *request;
int   (*match_fn)(char *, struct request_info *);
{
    char   *tok;
    static char *last;
    int l;

    /*
     * Process tokens one at a time. We have exhausted all possible matches
     * when we reach an "EXCEPT" token or the end of the list. If we do find
     * a match, look for an "EXCEPT" list and recurse to determine whether
     * the match is affected by any exceptions.
     */

    for (tok = strtok_r(list, sep, &last); tok != 0;
      tok = strtok_r(NULL, sep, &last)) {
	if (STR_EQ(tok, "EXCEPT"))		/* EXCEPT: give up */
	    return (NO);
	l = strlen(tok);
	if (*tok == '[' && tok[l - 1] == ']') {
	    tok[l - 1] = '\0';
	    tok++;
	}
	if (match_fn(tok, request)) {		/* YES: look for exceptions */
	    while ((tok = strtok_r(NULL, sep, &last)) && STR_NE(tok, "EXCEPT"))
		 /* VOID */ ;
	    return (tok == 0 || list_match(NULL, request, match_fn) == 0);
	}
    }
    return (NO);
}

/* server_match - match server information */

static int server_match(tok, request)
char   *tok;
struct request_info *request;
{
    char   *host;

    if ((host = split_at(tok + 1, '@@')) == 0) {	/* plain daemon */
	return (string_match(tok, eval_daemon(request)));
    } else {					/* daemon@@host */
	return (string_match(tok, eval_daemon(request))
		&& host_match(host, request->server));
    }
}

/* client_match - match client information */

static int client_match(tok, request)
char   *tok;
struct request_info *request;
{
    char   *host;

    if ((host = split_at(tok + 1, '@@')) == 0) {	/* plain host */
	return (host_match(tok, request->client));
    } else {					/* user@@host */
	return (host_match(host, request->client)
		&& string_match(tok, eval_user(request)));
    }
}

/* host_match - match host name and/or address against pattern */

static int host_match(tok, host)
char   *tok;
struct host_info *host;
{
    char   *mask;

    /*
     * This code looks a little hairy because we want to avoid unnecessary
     * hostname lookups.
     * 
     * The KNOWN pattern requires that both address AND name be known; some
     * patterns are specific to host names or to host addresses; all other
     * patterns are satisfied when either the address OR the name match.
     */

    if (tok[0] == '@@') {			/* netgroup: look it up */
#ifdef  NETGROUP
	static char mydomain[MAXHOSTNAMELEN];
	if (mydomain[0] == '\0')
	    getdomainname(mydomain, sizeof(mydomain));
	return (innetgr(tok + 1, eval_hostname(host), NULL, mydomain));
#else
	tcpd_warn("netgroup support is disabled");	/* not tcpd_jump() */
	return (NO);
#endif
    } else if (STR_EQ(tok, "KNOWN")) {		/* check address and name */
	char   *name = eval_hostname(host);
	return (STR_NE(eval_hostaddr(host), unknown) && HOSTNAME_KNOWN(name));
    } else if (STR_EQ(tok, "LOCAL")) {		/* local: no dots in name */
	char   *name = eval_hostname(host);
	return (strchr(name, '.') == 0 && HOSTNAME_KNOWN(name));
    } else if ((mask = split_at(tok, '/')) != 0) {	/* net/mask */
	return (masked_match(tok, mask, eval_hostaddr(host)));
    } else {					/* anything else */
	return (string_match(tok, eval_hostaddr(host))
	    || (NOT_INADDR(tok) && string_match(tok, eval_hostname(host))));
    }
}

/* string_match - match string against pattern */

static int string_match(tok, string)
char   *tok;
char   *string;
{
    int     n;

    if (tok[0] == '.') {			/* suffix */
	n = strlen(string) - strlen(tok);
	return (n > 0 && STR_EQ(tok, string + n));
    } else if (STR_EQ(tok, "ALL")) {		/* all: match any */
	return (YES);
    } else if (STR_EQ(tok, "KNOWN")) {		/* not unknown */
	return (STR_NE(string, unknown));
    } else if (tok[(n = strlen(tok)) - 1] == '.') {	/* prefix */
	return (STRN_EQ(tok, string, n));
    } else {					/* exact match */
	return (STR_EQ(tok, string));
    }
}

/* masked_match - match address against netnumber/netmask */

static int masked_match(net_tok, mask_tok, string)
char   *net_tok;
char   *mask_tok;
char   *string;
{
#ifndef INET6
    return masked_match4(net_tok, mask_tok, string);
#else
    /*
     * masked_match4() is kept just for supporting shortened IPv4 address form.
     * If we could get rid of shortened IPv4 form, we could just always use
     * masked_match6().
     */
    if (dot_quad_addr_new(net_tok, NULL) &&
        dot_quad_addr_new(mask_tok, NULL) &&
        dot_quad_addr_new(string, NULL)) {
	return masked_match4(net_tok, mask_tok, string);
    } else
	return masked_match6(net_tok, mask_tok, string);
#endif
}

static int masked_match4(net_tok, mask_tok, string)
char   *net_tok;
char   *mask_tok;
char   *string;
{
    in_addr_t net;
    in_addr_t mask;
    in_addr_t addr;

    /*
     * Disallow forms other than dotted quad: the treatment that inet_addr()
     * gives to forms with less than four components is inconsistent with the
     * access control language. John P. Rouillard <rouilj@@cs.umb.edu>.
     */

    if (!dot_quad_addr_new(string, &addr))
	return (NO);
    if (!dot_quad_addr_new(net_tok, &net) ||
        !dot_quad_addr_new(mask_tok, &mask)) {
	tcpd_warn("bad net/mask expression: %s/%s", net_tok, mask_tok);
	return (NO);				/* not tcpd_jump() */
    }

    if ((net & ~mask) != 0)
	tcpd_warn("host bits not all zero in %s/%s", net_tok, mask_tok);

    return ((addr & mask) == net);
}

#ifdef INET6
static int masked_match6(net_tok, mask_tok, string)
char   *net_tok;
char   *mask_tok;
char   *string;
{
    union {
	struct sockaddr sa;
	struct sockaddr_in sin;
	struct sockaddr_in6 sin6;
    } net, mask, addr;
    struct addrinfo hints, *res;
    unsigned long masklen;
    char *ep;
    int i;
    char *np, *mp, *ap;
    int alen;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
    hints.ai_flags = AI_NUMERICHOST;
    if (getaddrinfo(net_tok, "0", &hints, &res) == 0) {
	if (res->ai_addrlen > sizeof(net) || res->ai_next) {
	    freeaddrinfo(res);
	    return NO;
	}
	memcpy(&net, res->ai_addr, res->ai_addrlen);
	freeaddrinfo(res);
    } else
	return NO;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = net.sa.sa_family;
    hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
    hints.ai_flags = AI_NUMERICHOST;
    ep = NULL;
    if (getaddrinfo(mask_tok, "0", &hints, &res) == 0) {
	if (res->ai_family == AF_INET6 &&
	    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id) {
	    freeaddrinfo(res);
	    return NO;
	}
	if (res->ai_addrlen > sizeof(mask) || res->ai_next) {
	    freeaddrinfo(res);
	    return NO;
	}
	memcpy(&mask, res->ai_addr, res->ai_addrlen);
	freeaddrinfo(res);
    } else {
	ep = NULL;
	masklen = strtoul(mask_tok, &ep, 10);
	if (ep && !*ep) {
	    memset(&mask, 0, sizeof(mask));
	    mask.sa.sa_family = net.sa.sa_family;
	    mask.sa.sa_len = net.sa.sa_len;
	    switch (mask.sa.sa_family) {
	    case AF_INET:
		mp = (char *)&mask.sin.sin_addr;
		alen = sizeof(mask.sin.sin_addr);
		break;
	    case AF_INET6:
		mp = (char *)&mask.sin6.sin6_addr;
		alen = sizeof(mask.sin6.sin6_addr);
		break;
	    default:
		return NO;
	    }
	    if (masklen / 8 > alen)
		return NO;
	    memset(mp, 0xff, masklen / 8);
	    if (masklen % 8)
		mp[masklen / 8] = 0xff00 >> (masklen % 8);
	} else
	    return NO;
    }

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
    hints.ai_flags = AI_NUMERICHOST;
    if (getaddrinfo(string, "0", &hints, &res) == 0) {
	if (res->ai_addrlen > sizeof(addr) || res->ai_next) {
	    freeaddrinfo(res);
	    return NO;
	}
	/* special case - IPv4 mapped address */
	if (net.sa.sa_family == AF_INET && res->ai_family == AF_INET6 && 
	    IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)res->ai_addr)->sin6_addr)) {
	    memset(&addr, 0, sizeof(addr));
	    addr.sa.sa_family = net.sa.sa_family;
	    addr.sa.sa_len = net.sa.sa_len;
	    memcpy(&addr.sin.sin_addr,
	        &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr.s6_addr[12],
		sizeof(addr.sin.sin_addr));
	} else
	    memcpy(&addr, res->ai_addr, res->ai_addrlen);
	freeaddrinfo(res);
    } else
	return NO;

    if (net.sa.sa_family != mask.sa.sa_family ||
        net.sa.sa_family != addr.sa.sa_family) {
	return NO;
    }
     
    switch (net.sa.sa_family) {
    case AF_INET:
	np = (char *)&net.sin.sin_addr;
	mp = (char *)&mask.sin.sin_addr;
	ap = (char *)&addr.sin.sin_addr;
	alen = sizeof(net.sin.sin_addr);
	break;
    case AF_INET6:
	np = (char *)&net.sin6.sin6_addr;
	mp = (char *)&mask.sin6.sin6_addr;
	ap = (char *)&addr.sin6.sin6_addr;
	alen = sizeof(net.sin6.sin6_addr);
	break;
    default:
	return NO;
    }

    for (i = 0; i < alen; i++)
	if (np[i] & ~mp[i]) {
	    tcpd_warn("host bits not all zero in %s/%s", net_tok, mask_tok);
	    break;
	}

    for (i = 0; i < alen; i++)
	ap[i] &= mp[i];

    if (addr.sa.sa_family == AF_INET6 && addr.sin6.sin6_scope_id &&
        addr.sin6.sin6_scope_id != net.sin6.sin6_scope_id)
	return NO;
    return (memcmp(ap, np, alen) == 0);
}
#endif
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.11 2003/04/19 18:31:48 avsm Exp $	*/
@


1.11
log
@- kill unused var
- sscanf format string should scan for u_short not u_int
- some missing includes
- convert u_short -> in_port_t (from millert)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.10 2002/12/31 02:29:17 itojun Exp $	*/
a20 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#) hosts_access.c 1.21 97/02/12 02:13:22";
#else
static char rcsid[] = "$OpenBSD: hosts_access.c,v 1.10 2002/12/31 02:29:17 itojun Exp $";
#endif
#endif
@


1.10
log
@If we're going to replace strtok() with strtok_r(), and the caller of the
latter is invoked recursively, use static (instead of automatic) storage
for the "last" pointer so that we remember where we're up to ...

Fixes bug with hosts.deny rules such as "rpcbind: ALL EXCEPT some.domain".

netbsd lib/libwrap/hosts_access.c 1.17
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.9 2002/06/22 02:13:12 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: hosts_access.c,v 1.9 2002/06/22 02:13:12 deraadt Exp $";
d45 3
@


1.9
log
@use strtok_r() instead of strtok(); millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.8 2002/06/07 03:32:04 itojun Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: hosts_access.c,v 1.8 2002/06/07 03:32:04 itojun Exp $";
d202 2
a203 1
    char   *tok, *last;
@


1.8
log
@support scoped IPv6 address.
no visible API change, old config files work just fine.
now  you can use expressions like "ALL: [fe80::%lo0/64]".  theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.7 2001/12/13 17:44:47 beck Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: hosts_access.c,v 1.7 2001/12/13 17:44:47 beck Exp $";
d202 1
a202 1
    char   *tok;
d212 2
a213 1
    for (tok = strtok(list, sep); tok != 0; tok = strtok((char *) 0, sep)) {
d222 1
a222 1
	    while ((tok = strtok((char *) 0, sep)) && STR_NE(tok, "EXCEPT"))
d224 1
a224 1
	    return (tok == 0 || list_match((char *) 0, request, match_fn) == 0);
d284 1
a284 1
	return (innetgr(tok + 1, eval_hostname(host), (char *) 0, mydomain));
@


1.7
log
@atoi->strtoul
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.6 2000/10/14 00:56:15 itojun Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: hosts_access.c,v 1.6 2000/10/14 00:56:15 itojun Exp $";
d48 1
a50 4
#ifndef	INADDR_NONE
#define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
#endif

d85 9
a93 8
static int table_match();
static int list_match();
static int server_match();
static int client_match();
static int host_match();
static int string_match();
static int masked_match();
static int masked_match4();
d95 1
a95 1
static int masked_match6();
d200 1
a200 1
int   (*match_fn) ();
d334 8
a341 3
    if (dot_quad_addr_new(net_tok, NULL)
     && dot_quad_addr_new(mask_tok, NULL)
     && dot_quad_addr_new(string, NULL)) {
d366 1
a366 1
	!dot_quad_addr_new(mask_tok, &mask)) {
d370 4
a377 1
/* Ugly because it covers IPv4 mapped address.  I hate mapped addresses. */
d383 8
a390 5
    struct in6_addr net;
    struct in6_addr mask;
    struct in6_addr addr;
    u_long masklen;
    int fail;
d392 2
a393 12
    int maskoff;
    int netaf;
    char *p;
    const int sizoff64 = sizeof(struct in6_addr) - sizeof(struct in_addr);

    memset(&addr, 0, sizeof(addr));
    if (inet_pton(AF_INET6, string, &addr) == 1)
	; /* okay */
    else if (inet_pton(AF_INET, string, &addr.s6_addr[sizoff64]) == 1)
	addr.s6_addr[10] = addr.s6_addr[11] = 0xff;
    else
	return NO;
d395 11
a405 8
    memset(&net, 0, sizeof(net));
    if (inet_pton(AF_INET6, net_tok, &net) == 1) {
	netaf = AF_INET6;
	maskoff = 0;
    } else if (inet_pton(AF_INET, net_tok, &net.s6_addr[sizoff64]) == 1) {
	netaf = AF_INET;
	maskoff = sizoff64;
	net.s6_addr[10] = net.s6_addr[11] = 0xff;
d409 21
a429 8
    fail = 0;
    if (mask_tok[strspn(mask_tok, "0123456789")] == '\0') {
	errno = 0;   
	masklen = strtoul(mask_tok, &p, 10);
	if (!*mask_tok || *p || (errno == ERANGE && masklen == ULONG_MAX))
	    goto bogusmask;
	masklen += maskoff * 8;
	if (0 <= masklen && masklen <= 128) {
d431 13
a443 4
	    memset(&mask, 0xff, masklen / 8);
	    if (masklen % 8) {
		((u_char *)&mask)[masklen / 8] =
			(0xff00 >> (masklen % 8)) & 0xff;
d445 5
d451 24
a474 6
	    fail++;
    } else if (netaf == AF_INET6 && inet_pton(AF_INET6, mask_tok, &mask) == 1)
	; /* okay */
    else if (netaf == AF_INET
	  && inet_pton(AF_INET, mask_tok, &mask.s6_addr[12]) == 1) {
	memset(&mask, 0xff, sizoff64);
d476 22
a497 5
bogusmask:	    
	fail++;
    if (fail) {
	tcpd_warn("bad net/mask expression: %s/%s", net_tok, mask_tok);
	return (NO);				/* not tcpd_jump() */
d500 13
a512 3
    for (i = 0; i < sizeof(addr); i++)
	addr.s6_addr[i] &= mask.s6_addr[i];
    return (memcmp(&addr, &net, sizeof(addr)) == 0);
@


1.6
log
@tcp wrapper support for IPv6.  from netbsd.
TODO: scoped address support may need more consideration (we are taking
safer side now - rejects too much).
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.5 2000/02/01 03:23:17 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: hosts_access.c,v 1.5 2000/02/01 03:23:17 deraadt Exp $";
d380 1
a380 1
    int masklen;
d385 1
d409 5
a413 1
	masklen = atoi(mask_tok) + maskoff * 8;
d429 1
@


1.5
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.4 1999/06/06 15:34:44 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: hosts_access.c,v 1.4 1999/06/06 15:34:44 deraadt Exp $";
d34 3
d95 4
d205 1
d217 5
d333 17
d369 66
@


1.4
log
@add dot_quad_addr_new(); which can handle 255.255.255.255 addresses
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.3 1997/06/30 06:05:59 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: hosts_access.c,v 1.3 1997/06/30 06:05:59 deraadt Exp $";
a45 1
extern int errno;
@


1.3
log
@alpha bits
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.2 1997/03/29 04:14:56 millert Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: hosts_access.c,v 1.2 1997/03/29 04:14:56 millert Exp $";
d331 1
a331 1
    if ((addr = dot_quad_addr(string)) == INADDR_NONE)
d333 2
a334 2
    if ((net = dot_quad_addr(net_tok)) == INADDR_NONE
	|| (mask = dot_quad_addr(mask_tok)) == INADDR_NONE) {
@


1.2
log
@Use getdomainname() not yp_get_default_domain().
@
text
@d1 1
a1 1
/*	$OpenBSD: hosts_access.c,v 1.1 1997/02/26 03:06:52 downsj Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: hosts_access.c,v 1.1 1997/02/26 03:06:52 downsj Exp $";
d321 3
a323 3
    unsigned long net;
    unsigned long mask;
    unsigned long addr;
@


1.1
log
@Initial integration of a much cleaned up libwrap.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD$";
d270 3
a272 3
	static char *mydomain = 0;
	if (mydomain == 0)
	    yp_get_default_domain(&mydomain);
@
