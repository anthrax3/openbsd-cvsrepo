head	1.14;
access;
symbols
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.16
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.12
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.14
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.12
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.10
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.8
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.6
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.03.24.17.17.12;	author tedu;	state dead;
branches;
next	1.13;

1.13
date	2013.11.13.22.37.15;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.30;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.14.18.27.49;	author dhill;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.10.18.44.54;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.19.18.31.48;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.03.12.04.08;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.25.10.58.39;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.17.20.03.54;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.17.19.57.36;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.16.02.15.59;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.15.20.55.12;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.14.00.56.15;	author itojun;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.02.26.03.06.56;	author downsj;	state Exp;
branches;
next	;

1.2.2.1
date	2001.02.16.06.05.02;	author jason;	state Exp;
branches;
next	;


desc
@@


1.14
log
@The secret of steel has always carried with it a mystery. You must learn
its riddle, Conan. You must learn its discipline. For no one, no one in
this world can you trust. Not men, not women, not beasts.
@
text
@/*	$OpenBSD: rfc931.c,v 1.13 2013/11/13 22:37:15 deraadt Exp $	*/

/* rfc1413 does an attempt at an ident query to a client. Originally written
 * by Wietse Venema, rewritten by Bob Beck <beck@@openbsd.org> to avoid 
 * potential longjmp problems and get rid of stdio usage on sockets. 
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>

/* Local stuff for tcpd. */

#include "tcpd.h"

#define	IDENT_PORT	113

static volatile sig_atomic_t ident_timeout;

int rfc931_timeout = RFC931_TIMEOUT; /* global, legacy from tcpwrapper stuff */

/*ARGSUSED*/
static void
timeout(int s)
{     
	ident_timeout = 1;
}

/*
 * The old rfc931 from original libwrap for compatibility. Now it calls
 * rfc1413 with the default global parameters, but puts in the string
 * "unknown" (from global unknown) on failure just like the original.
 */

void
rfc931(rmt_sin, our_sin, dest)
	struct sockaddr *rmt_sin;
	struct sockaddr *our_sin;
	char   *dest; 
{
	if (rfc1413(rmt_sin, our_sin, dest, STRING_LENGTH, rfc931_timeout) ==
	    -1)
		strlcpy(dest, unknown, STRING_LENGTH);
}


/*
 * rfc1413, an rfc1413 client request for user name given a socket
 * structure, with a timeout in seconds on the whole operation.  On
 * success returns 0 and saves dsize-1 characters of the username
 * provided by remote ident daemon into "dest", stripping off any
 * terminating CRLF, and terminating with a nul byte. Returns -1 on
 * failure (timeout, remote daemon didn't answer, etc). 
 */

int
rfc1413(rmt_sin, our_sin, dest, dsize, ident_timeout_time)
	struct sockaddr *rmt_sin;
	struct sockaddr *our_sin;
	char   *dest;
	size_t dsize;
	int ident_timeout_time;
{
	in_port_t rmt_port, our_port;
	int s, i, gotit, salen;
	char *cp;
	in_port_t *rmt_portp;
	in_port_t *our_portp;
	fd_set *readfds = NULL;
	fd_set *writefds = NULL;
	struct sockaddr_storage rmt_query_sin;
	struct sockaddr_storage our_query_sin;
	struct sigaction new_sa, old_sa;
	char user[256];	 
	char tbuf[1024];	 
	size_t rsize, wsize;
	
	gotit = 0;
	s = -1;
	
	/* address family must be the same */
	if (rmt_sin->sa_family != our_sin->sa_family)
		goto out1;
	switch (rmt_sin->sa_family) {
	case AF_INET:
		salen = sizeof(struct sockaddr_in);
		rmt_portp = &(((struct sockaddr_in *)rmt_sin)->sin_port);
		break;
#ifdef INET6
	case AF_INET6:
		salen = sizeof(struct sockaddr_in6);
		rmt_portp = &(((struct sockaddr_in6 *)rmt_sin)->sin6_port);
		break;
#endif
	default:
		goto out1;
	}
	switch (our_sin->sa_family) {
	case AF_INET:
		our_portp = &(((struct sockaddr_in *)our_sin)->sin_port);
		break;
#ifdef INET6
	case AF_INET6:
		our_portp = &(((struct sockaddr_in6 *)our_sin)->sin6_port);
		break;
#endif
	default:
		goto out1;
	}

	if ((s = socket(rmt_sin->sa_family, SOCK_STREAM, 0)) == -1)
		goto out1;

	/*
	 * Set up a timer so we won't get stuck while waiting for the server.
	 * timer sets volatile sig_atomic_t ident_timeout when it fires. 
	 * this has to be checked after system calls in case we timed out.
	 */
	
	ident_timeout = 0;
	memset(&new_sa, 0, sizeof(new_sa));
	new_sa.sa_handler = timeout;
	new_sa.sa_flags = SA_RESTART;
	if (sigemptyset(&new_sa.sa_mask) == -1)
		goto out1;
	if (sigaction(SIGALRM, &new_sa, &old_sa) == -1)
		goto out1;
	alarm(ident_timeout_time);
	
	/*
	 * Bind the local and remote ends of the query socket to the same
	 * IP addresses as the connection under investigation. We go
	 * through all this trouble because the local or remote system
	 * might have more than one network address. The IDENT etc.
	 * client sends only port numbers; the server takes the IP
	 * addresses from the query socket.
	 */
	
	memcpy(&our_query_sin, our_sin, salen);
	switch (our_query_sin.ss_family) {
	case AF_INET:
		((struct sockaddr_in *)&our_query_sin)->sin_port = htons(0);
		break;
#ifdef INET6
	case AF_INET6:
		((struct sockaddr_in6 *)&our_query_sin)->sin6_port = htons(0);
		break;
#endif
	}
	memcpy(&rmt_query_sin, rmt_sin, salen);
	switch (rmt_query_sin.ss_family) {
	case AF_INET:
		((struct sockaddr_in *)&rmt_query_sin)->sin_port =
		    htons(IDENT_PORT);
		break;
#ifdef INET6
	case AF_INET6:
		((struct sockaddr_in6 *)&rmt_query_sin)->sin6_port =
		    htons(IDENT_PORT);
		break;
#endif
	}
	
	if (bind(s, (struct sockaddr *) & our_query_sin, salen) == -1)
		goto out;
	if ((connect(s, (struct sockaddr *) & rmt_query_sin, salen) == -1) ||
	    ident_timeout)
		goto out;

	/* We are connected,  build an ident query and send it. */ 
	
	rsize = howmany(s+1, NFDBITS);
	readfds = calloc(rsize, sizeof(fd_mask));
	if (readfds == NULL) 
		goto out;

	wsize = howmany(s+1, NFDBITS);
	writefds = calloc(wsize, sizeof(fd_mask));
	if (writefds == NULL) 
		goto out;
	snprintf(tbuf, sizeof(tbuf), "%u,%u\r\n", ntohs(*rmt_portp),
	    ntohs(*our_portp));
	i = 0;
	while (i < strlen(tbuf)) { 
		int j;

		memset(writefds, 0, wsize * sizeof(fd_mask));
		FD_SET(s, writefds);
		do { 
			j = select(s + 1, NULL, writefds, NULL, NULL);
			if (ident_timeout)			    
				goto out;
		} while ( j == -1 && (errno == EAGAIN || errno == EINTR ));
		if (j == -1)
			goto out;
		if (FD_ISSET(s, writefds)) {
			j = write(s, tbuf + i, strlen(tbuf + i));
			if ((j == -1 && errno != EAGAIN && errno != EINTR) ||
			    ident_timeout) 
				goto out;
			if  (j != -1) 
				i += j;
		} else 
			goto out;
	} 

	
	/* Read the answer back. */
	i = 0;
	tbuf[0] = '\0';
	while ((cp = strchr(tbuf, '\n')) == NULL && i < sizeof(tbuf) - 1) {
		int j;

		memset(readfds, 0, rsize * sizeof(fd_mask));
		FD_SET(s, readfds);
		do { 
			j = select(s + 1, readfds, NULL, NULL, NULL);
			if (ident_timeout)
				goto out;
		} while ( j == -1 && (errno == EAGAIN || errno == EINTR ));
		if (j == -1)
			goto out;
		if (FD_ISSET(s, readfds)) {
			j = read(s, tbuf + i, sizeof(tbuf) - 1 - i);
			if ((j == -1 && errno != EAGAIN && errno != EINTR) ||
			    j == 0 || ident_timeout) 
				goto out;
			if  (j != -1) 
				i += j;
			tbuf[i] = '\0';
		} else
			goto out;
	}
	
	if ((sscanf(tbuf,"%hu , %hu : USERID :%*[^:]:%255s", &rmt_port,
	    &our_port, user) == 3) &&
	    (ntohs(*rmt_portp) == rmt_port) &&
	    (ntohs(*our_portp) == our_port)) {
		if ((cp = strchr(user, '\r')) != NULL)
			*cp = '\0';
		gotit = 1;
	}

out:
	alarm(0);
	sigaction(SIGALRM, &old_sa, NULL);
	if (readfds != NULL)
		free(readfds);
	if (writefds != NULL)
		free(writefds);
out1:
	if (s != -1) 
		close(s);
	if (gotit) {
		strlcpy(dest, user, dsize);
		return(0);
	}
	return(-1);
}
@


1.13
log
@repair prototypes
reviewed by chris
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.12 2009/10/27 23:59:30 deraadt Exp $	*/
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.11 2006/04/14 18:27:49 dhill Exp $	*/
d32 1
a32 2
timeout(s)
	int s;
@


1.11
log
@delint

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.10 2005/11/10 18:44:54 otto Exp $	*/
a6 4

#ifndef lint
static char rcsid[] = "$OpenBSD: rfc931.c,v 1.10 2005/11/10 18:44:54 otto Exp $";
#endif
@


1.10
log
@Use correct size when zeroing fd sets. From Michael Shuldman in PR
4603 with a twist by me. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.9 2003/04/19 18:31:48 avsm Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: rfc931.c,v 1.9 2003/04/19 18:31:48 avsm Exp $";
d34 1
@


1.9
log
@- kill unused var
- sscanf format string should scan for u_short not u_int
- some missing includes
- convert u_short -> in_port_t (from millert)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.8 2002/06/03 12:04:08 deraadt Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: rfc931.c,v 1.8 2002/06/03 12:04:08 deraadt Exp $";
d88 1
d184 2
a185 1
	readfds = calloc(howmany(s+1, NFDBITS), sizeof(fd_mask));
d188 3
a190 1
	writefds = calloc(howmany(s+1, NFDBITS), sizeof(fd_mask));
d199 1
a199 1
		FD_ZERO(writefds);
d226 1
a226 1
		FD_ZERO(readfds);
@


1.8
log
@compatiblity -> compatibility
decriptor -> descriptor
authentciated -> authenticated
transmition -> transmission
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.7 2002/04/25 10:58:39 mpech Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: rfc931.c,v 1.7 2002/04/25 10:58:39 mpech Exp $";
d76 1
a76 1
	u_short rmt_port, our_port;
d79 2
a80 2
	u_short *rmt_portp;
	u_short *our_portp;
d243 1
a243 1
	if ((sscanf(tbuf,"%u , %u : USERID :%*[^:]:%255s", &rmt_port,
@


1.7
log
@Protect IPv6 code with #ifdef INET6

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.6 2001/11/17 20:03:54 deraadt Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: rfc931.c,v 1.6 2001/11/17 20:03:54 deraadt Exp $";
d42 1
a42 1
 * The old rfc931 from original libwrap for compatiblity. Now it calls
@


1.6
log
@fix a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.5 2001/11/17 19:57:36 deraadt Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: rfc931.c,v 1.5 2001/11/17 19:57:36 deraadt Exp $";
d100 1
d105 1
d113 1
d117 1
d155 1
d159 1
d167 1
d172 1
@


1.5
log
@volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.4 2001/02/16 02:15:59 beck Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: rfc931.c,v 1.4 2001/02/16 02:15:59 beck Exp $";
d123 1
a123 1
	 * timer sets sig_atomic_t ident_timeout when it fires. 
@


1.4
log
@Rewrite rfc931.c to eliminate problematic setjmp/longjmp and stdio usage
on sockets. Adds new documented rfc1413 routine to do client side ident
stuff. leaves compatible rfc931() routine in lib which calls new routine,
incremenent shlib minor.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: rfc931.c,v 1.2 2000/10/14 00:56:15 itojun Exp $";
d30 1
a30 1
static sig_atomic_t ident_timeout;
@


1.3
log
@fix change from previous commit that didn't get the ports correctly
out of sockaddr_inX's for client side ident.
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.2 2000/10/14 00:56:15 itojun Exp $	*/
d3 4
a6 10
 /*
  * rfc931() speaks a common subset of the RFC 931, AUTH, TAP, IDENT and RFC
  * 1413 protocols. It queries an RFC 931 etc. compatible daemon on a remote
  * host to look up the owner of a connection. The information should not be
  * used for authentication purposes. This routine intercepts alarm signals.
  * 
  * Diagnostics are reported through syslog(3).
  * 
  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
  */
a8 3
#if 0
static char sccsid[] = "@@(#) rfc931.c 1.10 95/01/02 16:11:34";
#else
a10 3
#endif

/* System libraries. */
a12 1
#include <syslog.h>
d14 1
d16 1
a17 1
#include <setjmp.h>
d21 2
d24 1
a24 1
/* Local stuff. */
d28 1
a28 2
#define	RFC931_PORT	113		/* Semi-well-known port */
#define	ANY_PORT	0		/* Any old port will do */
d30 1
a30 1
int     rfc931_timeout = RFC931_TIMEOUT;/* Global so it can be changed */
d32 1
a32 1
static jmp_buf timebuf;
d34 5
a38 20
/* fsocket - open stdio stream on top of socket */

static FILE *fsocket(domain, type, protocol)
int     domain;
int     type;
int     protocol;
{
    int     s;
    FILE   *fp;

    if ((s = socket(domain, type, protocol)) < 0) {
	tcpd_warn("socket: %m");
	return (0);
    } else {
	if ((fp = fdopen(s, "r+")) == 0) {
	    tcpd_warn("fdopen: %m");
	    close(s);
	}
	return (fp);
    }
d41 11
a51 4
/* timeout - handle timeouts */

static void timeout(sig)
int     sig;
d53 3
a55 1
    longjmp(timebuf, sig);
a57 1
/* rfc931 - return remote user name, given socket structures */
d59 16
a74 4
void    rfc931(rmt_sin, our_sin, dest)
struct sockaddr *rmt_sin;
struct sockaddr *our_sin;
char   *dest;
d76 41
a116 51
    unsigned rmt_port;
    unsigned our_port;
    struct sockaddr_storage rmt_query_sin;
    struct sockaddr_storage our_query_sin;
    char    user[256];			/* XXX */
    char    buffer[512];		/* XXX */
    char   *cp;
    char   *result = unknown;
    FILE   *fp;
    int salen;
    u_short *rmt_portp;
    u_short *our_portp;

    /* address family must be the same */
    if (rmt_sin->sa_family != our_sin->sa_family) {
	STRN_CPY(dest, result, STRING_LENGTH);
	return;
    }
    switch (rmt_sin->sa_family) {
    case AF_INET:
	salen = sizeof(struct sockaddr_in);
	rmt_portp = &(((struct sockaddr_in *)rmt_sin)->sin_port);
	break;
#ifdef INET6
    case AF_INET6:
	salen = sizeof(struct sockaddr_in6);
	rmt_portp = &(((struct sockaddr_in6 *)rmt_sin)->sin6_port);
	break;
#endif
    default:
	STRN_CPY(dest, result, STRING_LENGTH);
	return;
    }
    switch (our_sin->sa_family) {
    case AF_INET:
	our_portp = &(((struct sockaddr_in *)our_sin)->sin_port);
	break;
#ifdef INET6
    case AF_INET6:
	our_portp = &(((struct sockaddr_in6 *)our_sin)->sin6_port);
	break;
#endif
    default:
	STRN_CPY(dest, result, STRING_LENGTH);
	return;
    }

#ifdef __GNUC__
    (void)&result;	/* Avoid longjmp clobbering */
    (void)&fp;		/* XXX gcc */
#endif
d118 2
a119 12
    /*
     * Use one unbuffered stdio stream for writing to and for reading from
     * the RFC931 etc. server. This is done because of a bug in the SunOS
     * 4.1.x stdio library. The bug may live in other stdio implementations,
     * too. When we use a single, buffered, bidirectional stdio stream ("r+"
     * or "w+" mode) we read our own output. Such behaviour would make sense
     * with resources that support random-access operations, but not with
     * sockets.
     */

    if ((fp = fsocket(rmt_sin->sa_family, SOCK_STREAM, 0)) != 0) {
	setbuf(fp, (char *) 0);
d123 2
d126 27
a152 24

	if (setjmp(timebuf) == 0) {
	    signal(SIGALRM, timeout);
	    alarm(rfc931_timeout);

	    /*
	     * Bind the local and remote ends of the query socket to the same
	     * IP addresses as the connection under investigation. We go
	     * through all this trouble because the local or remote system
	     * might have more than one network address. The RFC931 etc.
	     * client sends only port numbers; the server takes the IP
	     * addresses from the query socket.
	     */

	    memcpy(&our_query_sin, our_sin, salen);
	    switch (our_query_sin.ss_family) {
	    case AF_INET:
		((struct sockaddr_in *)&our_query_sin)->sin_port =
			htons(ANY_PORT);
		break;
#ifdef INET6
	    case AF_INET6:
		((struct sockaddr_in6 *)&our_query_sin)->sin6_port =
			htons(ANY_PORT);
d154 4
a157 5
#endif
	    }
	    memcpy(&rmt_query_sin, rmt_sin, salen);
	    switch (rmt_query_sin.ss_family) {
	    case AF_INET:
d159 1
a159 1
			htons(RFC931_PORT);
d161 3
a163 4
#ifdef INET6
	    case AF_INET6:
		((struct sockaddr_in6 *)&rmt_query_sin)->sin6_port = 
			htons(RFC931_PORT);
d165 78
a242 2
#endif
	    }
d244 15
a258 46
	    if (bind(fileno(fp), (struct sockaddr *) & our_query_sin,
		     salen) >= 0 &&
		connect(fileno(fp), (struct sockaddr *) & rmt_query_sin,
			salen) >= 0) {

		/*
		 * Send query to server. Neglect the risk that a 13-byte
		 * write would have to be fragmented by the local system and
		 * cause trouble with buggy System V stdio libraries.
		 */

		fprintf(fp, "%u,%u\r\n",
			ntohs(*rmt_portp),
			ntohs(*our_portp));
		fflush(fp);

		/*
		 * Read response from server. Use fgets()/sscanf() so we can
		 * work around System V stdio libraries that incorrectly
		 * assume EOF when a read from a socket returns less than
		 * requested.
		 */

		if (fgets(buffer, sizeof(buffer), fp) != 0
		    && ferror(fp) == 0 && feof(fp) == 0
		    && sscanf(buffer, "%u , %u : USERID :%*[^:]:%255s",
			      &rmt_port, &our_port, user) == 3
		    && ntohs(*rmt_portp) == rmt_port
		    && ntohs(*our_portp) == our_port) {

		    /*
		     * Strip trailing carriage return. It is part of the
		     * protocol, not part of the data.
		     */

		    cp = strchr(user, '\r');
		    if (cp)
			*cp = 0;
		    result = user;
		}
	    }
	    alarm(0);
	}
	fclose(fp);
    }
    STRN_CPY(dest, result, STRING_LENGTH);
@


1.2
log
@tcp wrapper support for IPv6.  from netbsd.
TODO: scoped address support may need more consideration (we are taking
safer side now - rejects too much).
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.1 1997/02/26 03:06:56 downsj Exp $	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD: rfc931.c,v 1.1 1997/02/26 03:06:56 downsj Exp $";
d103 1
a103 1
	rmt_portp = &((struct sockaddr_in *)&rmt_sin)->sin_port;
d108 1
a108 1
	rmt_portp = &((struct sockaddr_in6 *)&rmt_sin)->sin6_port;
d117 1
a117 1
	our_portp = &((struct sockaddr_in *)&our_sin)->sin_port;
d121 1
a121 1
	our_portp = &((struct sockaddr_in6 *)&our_sin)->sin6_port;
@


1.2.2.1
log
@Pull in patch from current:
Errata 020 (beck):
fix change from previous commit that didn't get the ports correctly
out of sockaddr_inX's for client side ident.
@
text
@d1 1
a1 1
/*	$OpenBSD: rfc931.c,v 1.3 2001/02/15 20:55:12 beck Exp $	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD: rfc931.c,v 1.3 2001/02/15 20:55:12 beck Exp $";
d103 1
a103 1
	rmt_portp = &(((struct sockaddr_in *)rmt_sin)->sin_port);
d108 1
a108 1
	rmt_portp = &(((struct sockaddr_in6 *)rmt_sin)->sin6_port);
d117 1
a117 1
	our_portp = &(((struct sockaddr_in *)our_sin)->sin_port);
d121 1
a121 1
	our_portp = &(((struct sockaddr_in6 *)our_sin)->sin6_port);
@


1.1
log
@Initial integration of a much cleaned up libwrap.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD$";
d78 2
a79 2
struct sockaddr_in *rmt_sin;
struct sockaddr_in *our_sin;
d84 2
a85 2
    struct sockaddr_in rmt_query_sin;
    struct sockaddr_in our_query_sin;
d91 42
d144 1
a144 1
    if ((fp = fsocket(AF_INET, SOCK_STREAM, 0)) != 0) {
d164 26
a189 4
	    our_query_sin = *our_sin;
	    our_query_sin.sin_port = htons(ANY_PORT);
	    rmt_query_sin = *rmt_sin;
	    rmt_query_sin.sin_port = htons(RFC931_PORT);
d192 1
a192 1
		     sizeof(our_query_sin)) >= 0 &&
d194 1
a194 1
			sizeof(rmt_query_sin)) >= 0) {
d203 2
a204 2
			ntohs(rmt_sin->sin_port),
			ntohs(our_sin->sin_port));
d218 2
a219 2
		    && ntohs(rmt_sin->sin_port) == rmt_port
		    && ntohs(our_sin->sin_port) == our_port) {
@

