head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.10
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.8
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.33.0.8
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.26
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.24
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.22
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.20
	OPENBSD_5_0:1.30.0.18
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.16
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.14
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.10
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.12
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.8
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.6
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.8
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.6
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.18.0.10
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.8
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.18.0.6
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.4
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.17.0.4
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2015.10.06.15.07.45;	author tim;	state Exp;
branches;
next	1.33;
commitid	Fm7GlFSUap7neKN9;

1.33
date	2014.03.25.04.28.28;	author lteo;	state Exp;
branches;
next	1.32;

1.32
date	2014.03.20.20.39.13;	author naddy;	state Exp;
branches;
next	1.31;

1.31
date	2013.11.29.19.00.51;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.17.04.34.50;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.10.08.06.08;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.28.19.37.09;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.26.23.19.53;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.03.17.48.50;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.29.18.53.15;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.24.21.33.09;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.16.21.27.28;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.24.23.01.19;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.14.20.53.03;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.23.21.03.47;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.26.16.06.40;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	98.07.03.01.08.14;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	97.07.27.21.36.06;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.07.24.23.00.27;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.07.17.05.48.38;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.07.11.01.32.57;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.07.10.22.53.37;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.11.03.18.57.30;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.10.22.01.37.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	96.10.14.03.09.13;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.09.30.23.54.38;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.09.30.23.26.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.09.30.18.55.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.09.30.04.10.47;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.29.23.35.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.29.21.27.02;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.27.20.40.17;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.09.27.15.39.00;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Don't burden keycrunch_{md5,sha1,rmd160}() with identical code to prepare a
buffer based on whether they are called by keycrunch() or f(). Instead let
keycrunch() and f() take care of this themselves.

OK millert@@
@
text
@/* OpenBSD S/Key (skeysubr.c)
 *
 * Authors:
 *          Neil M. Haller <nmh@@thumper.bellcore.com>
 *          Philip R. Karn <karn@@chicago.qualcomm.com>
 *          John S. Walden <jsw@@thumper.bellcore.com>
 *          Scott Chasin <chasin@@crimelab.com>
 *          Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * S/Key misc routines.
 *
 * $OpenBSD: skeysubr.c,v 1.33 2014/03/25 04:28:28 lteo Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <signal.h>
#include <termios.h>
#include <unistd.h>
#include <md5.h>
#include <sha1.h>
#include <rmd160.h>

#include "skey.h"

/* Default hash function to use (index into skey_algorithm_table array) */
#ifndef SKEY_HASH_DEFAULT
#define SKEY_HASH_DEFAULT	0	/* md5 */
#endif

static void keycrunch_md5(char *, char *, size_t);
static void keycrunch_sha1(char *, char *, size_t);
static void keycrunch_rmd160(char *, char *, size_t);
static void skey_echo(int);
static void trapped(int);

/* Current hash type (index into skey_algorithm_table array) */
static int skey_hash_type = SKEY_HASH_DEFAULT;

/*
 * Hash types we support.
 * Each has an associated keycrunch() and f() function.
 */
struct skey_algorithm_table {
	const char *name;
	void (*keycrunch)(char *, char *, size_t);
};
static struct skey_algorithm_table skey_algorithm_table[] = {
	{ "md5", keycrunch_md5 },
	{ "sha1", keycrunch_sha1 },
	{ "rmd160", keycrunch_rmd160 },
	{ NULL }
};


/*
 * Crunch a key:
 *  Concatenate the seed and the password, run through hash function and
 *  collapse to 64 bits.  This is defined as the user's starting key.
 *  The result pointer must have at least SKEY_BINKEY_SIZE bytes of storage.
 *  The seed and password may be of any length.
 */
int
keycrunch(char *result, char *seed, char *passwd)
{
	char *buf, *p;
	size_t buflen;

	buflen = strlen(seed) + strlen(passwd);
	if ((buf = malloc(buflen + 1)) == NULL)
		return(-1);

	(void)strlcpy(buf, seed, buflen + 1);
	for (p = buf; *p; p++)
		*p = (char)tolower((unsigned char)*p);

	(void)strlcat(buf, passwd, buflen + 1);
	sevenbit(buf);

	skey_algorithm_table[skey_hash_type].keycrunch(result, buf, buflen);

	(void)free(buf);
	return(0);
}

static void
keycrunch_md5(char *result, char *buf, size_t buflen)
{
	MD5_CTX md;
	u_int32_t results[4];

	/* Crunch the key through MD5 */
	MD5Init(&md);
	MD5Update(&md, (unsigned char *)buf, buflen);
	MD5Final((unsigned char *)results, &md);

	/* Fold result from 128 to 64 bits */
	results[0] ^= results[2];
	results[1] ^= results[3];

	(void)memcpy((void *)result, (void *)results, SKEY_BINKEY_SIZE);
}

static void
keycrunch_sha1(char *result, char *buf, size_t buflen)
{
	SHA1_CTX sha;
	int i, j;

	/* Crunch the key through SHA1 */
	SHA1Init(&sha);
	SHA1Update(&sha, (unsigned char *)buf, buflen);
	SHA1Pad(&sha);

	/* Fold 160 to 64 bits */
	sha.state[0] ^= sha.state[2];
	sha.state[1] ^= sha.state[3];
	sha.state[0] ^= sha.state[4];

	/*
	 * SHA1 is a big endian algorithm but RFC2289 mandates that
	 * the result be in little endian form, so we copy to the
	 * result buffer manually.
	 */
	for (i = 0, j = 0; j < 8; i++, j += 4) {
		result[j]   = (u_char)(sha.state[i] & 0xff);
		result[j+1] = (u_char)((sha.state[i] >> 8)  & 0xff);
		result[j+2] = (u_char)((sha.state[i] >> 16) & 0xff);
		result[j+3] = (u_char)((sha.state[i] >> 24) & 0xff);
	}
}

static void
keycrunch_rmd160(char *result, char *buf, size_t buflen)
{
	RMD160_CTX rmd;
	u_int32_t results[5];

	/* Crunch the key through RMD-160 */
	RMD160Init(&rmd);
	RMD160Update(&rmd, (unsigned char *)buf, buflen);
	RMD160Final((unsigned char *)results, &rmd);

	/* Fold 160 to 64 bits */
	results[0] ^= results[2];
	results[1] ^= results[3];
	results[0] ^= results[4];

	(void)memcpy((void *)result, (void *)results, SKEY_BINKEY_SIZE);
}

/*
 * The one-way hash function f().
 * Takes SKEY_BINKEY_SIZE bytes and returns SKEY_BINKEY_SIZE bytes in place.
 */
void
f(char *x)
{
	skey_algorithm_table[skey_hash_type].keycrunch(x, x, SKEY_BINKEY_SIZE);
}

/* Strip trailing cr/lf from a line of text */
void
rip(char *buf)
{
	buf += strcspn(buf, "\r\n");

	if (*buf)
		*buf = '\0';
}

/* Read in secret password (turns off echo) */
char *
readpass(char *buf, int n)
{
	void (*old_handler)(int);

	/* Turn off echoing */
	skey_echo(0);

	/* Catch SIGINT and save old signal handler */
	old_handler = signal(SIGINT, trapped);

	if (fgets(buf, n, stdin) == NULL)
		buf[0] = '\0';
	rip(buf);

	(void)putc('\n', stderr);
	(void)fflush(stderr);

	/* Restore signal handler and turn echo back on */
	if (old_handler != SIG_ERR)
		(void)signal(SIGINT, old_handler);
	skey_echo(1);

	sevenbit(buf);

	return(buf);
}

/* Read in an s/key OTP (does not turn off echo) */
char *
readskey(char *buf, int n)
{
	if (fgets(buf, n, stdin) == NULL)
		buf[0] = '\0';
	rip(buf);

	sevenbit(buf);

	return(buf);
}

/* Signal handler for trapping ^C */
/*ARGSUSED*/
static void
trapped(int sig)
{
	write(STDERR_FILENO, "^C\n", 3);

	/* Turn on echo if necessary */
	skey_echo(1);

	_exit(1);
}

/*
 * Convert 16-byte hex-ascii string to 8-byte binary array
 * Returns 0 on success, -1 on error
 */
int
atob8(char *out, char *in)
{
	int i;
	int val;

	if (in == NULL || out == NULL)
		return(-1);

	for (i=0; i < 8; i++) {
		if ((in = skipspace(in)) == NULL)
			return(-1);
		if ((val = htoi(*in++)) == -1)
			return(-1);
		*out = val << 4;

		if ((in = skipspace(in)) == NULL)
			return(-1);
		if ((val = htoi(*in++)) == -1)
			return(-1);
		*out++ |= val;
	}
	return(0);
}

/* Convert 8-byte binary array to 16-byte hex-ascii string */
int
btoa8(char *out, char *in)
{
	if (in == NULL || out == NULL)
		return(-1);

	(void)snprintf(out, 17, "%02x%02x%02x%02x%02x%02x%02x%02x",
	    in[0] & 0xff, in[1] & 0xff, in[2] & 0xff, in[3] & 0xff,
	    in[4] & 0xff, in[5] & 0xff, in[6] & 0xff, in[7] & 0xff);

	return(0);
}

/* Convert hex digit to binary integer */
int
htoi(int c)
{
	if ('0' <= c && c <= '9')
		return(c - '0');
	if ('a' <= c && c <= 'f')
		return(10 + c - 'a');
	if ('A' <= c && c <= 'F')
		return(10 + c - 'A');
	return(-1);
}

/* Skip leading spaces from the string */
char *
skipspace(char *cp)
{
	while (*cp == ' ' || *cp == '\t')
		cp++;

	if (*cp == '\0')
		return(NULL);
	else
		return(cp);
}

/* Remove backspaced over characters from the string */
void
backspace(char *buf)
{
	char bs = 0x8;
	char *cp = buf;
	char *out = buf;

	while (*cp) {
		if (*cp == bs) {
			if (out == buf) {
				cp++;
				continue;
			} else {
				cp++;
				out--;
			}
		} else {
			*out++ = *cp++;
		}

	}
	*out = '\0';
}

/* Make sure line is all seven bits */
void
sevenbit(char *s)
{
	while (*s)
		*s++ &= 0x7f;
}

/* Set hash algorithm type */
char *
skey_set_algorithm(char *new)
{
	int i;

	for (i = 0; skey_algorithm_table[i].name; i++) {
		if (strcmp(new, skey_algorithm_table[i].name) == 0) {
			skey_hash_type = i;
			return(new);
		}
	}

	return(NULL);
}

/* Get current hash type */
const char *
skey_get_algorithm(void)
{
	return(skey_algorithm_table[skey_hash_type].name);
}

/* Turn echo on/off */
static void
skey_echo(int action)
{
	static struct termios term;
	static int echo = 0;

	if (action == 0) {
		/* Turn echo off */
		(void) tcgetattr(fileno(stdin), &term);
		if ((echo = (term.c_lflag & ECHO))) {
			term.c_lflag &= ~ECHO;
			(void) tcsetattr(fileno(stdin), TCSAFLUSH|TCSASOFT, &term);
		}
	} else if (action && echo) {
		/* Turn echo on */
		term.c_lflag |= ECHO;
		(void) tcsetattr(fileno(stdin), TCSAFLUSH|TCSASOFT, &term);
		echo = 0;
	}
}
@


1.33
log
@Fix two bugs introduced after MD4 removal: Change the default algorithm
back to md5 (as documented on the man pages), and do not let
skey_set_algorithm() cause a segfault if an unsupported algorithm is
specified.

earlier version ok tedu@@
help/ok millert@@, ok naddy@@
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.32 2014/03/20 20:39:13 naddy Exp $
d33 3
a35 4
static int keycrunch_md5(char *, char *, char *);
static int keycrunch_sha1(char *, char *, char *);
static int keycrunch_rmd160(char *, char *, char *);
static void lowcase(char *);
d48 1
a48 1
	int (*keycrunch)(char *, char *, char *);
d68 18
a85 1
	return(skey_algorithm_table[skey_hash_type].keycrunch(result, seed, passwd));
d88 2
a89 2
static int
keycrunch_md5(char *result, char *seed, char *passwd)
a90 1
	char *buf;
a92 18
	unsigned int buflen;

	/*
	 * If seed and passwd are defined we are in keycrunch() mode,
	 * else we are in f() mode.
	 */
	if (seed && passwd) {
		buflen = strlen(seed) + strlen(passwd);
		if ((buf = malloc(buflen + 1)) == NULL)
			return(-1);
		(void)strlcpy(buf, seed, buflen + 1);
		lowcase(buf);
		(void)strlcat(buf, passwd, buflen + 1);
		sevenbit(buf);
	} else {
		buf = result;
		buflen = SKEY_BINKEY_SIZE;
	}
a103 5

	if (buf != result)
		(void)free(buf);

	return(0);
d106 2
a107 2
static int
keycrunch_sha1(char *result, char *seed, char *passwd)
a108 1
	char *buf;
a109 1
	unsigned int buflen;
a111 17
	/*
	 * If seed and passwd are defined we are in keycrunch() mode,
	 * else we are in f() mode.
	 */
	if (seed && passwd) {
		buflen = strlen(seed) + strlen(passwd);
		if ((buf = malloc(buflen + 1)) == NULL)
			return(-1);
		(void)strlcpy(buf, seed, buflen + 1);
		lowcase(buf);
		(void)strlcat(buf, passwd, buflen + 1);
		sevenbit(buf);
	} else {
		buf = result;
		buflen = SKEY_BINKEY_SIZE;
	}

a132 5

	if (buf != result)
		(void)free(buf);

	return(0);
d135 2
a136 2
static int
keycrunch_rmd160(char *result, char *seed, char *passwd)
a137 1
	char *buf;
a139 18
	unsigned int buflen;

	/*
	 * If seed and passwd are defined we are in keycrunch() mode,
	 * else we are in f() mode.
	 */
	if (seed && passwd) {
		buflen = strlen(seed) + strlen(passwd);
		if ((buf = malloc(buflen + 1)) == NULL)
			return(-1);
		(void)strlcpy(buf, seed, buflen + 1);
		lowcase(buf);
		(void)strlcat(buf, passwd, buflen + 1);
		sevenbit(buf);
	} else {
		buf = result;
		buflen = SKEY_BINKEY_SIZE;
	}
a151 5

	if (buf != result)
		(void)free(buf);

	return(0);
d161 1
a161 1
	(void)skey_algorithm_table[skey_hash_type].keycrunch(x, NULL, NULL);
a372 12
	}
}

/* Convert string to lower case */
static void
lowcase(char *s)
{
	char *p;

	for (p = s; *p; p++) {
		if (isupper((unsigned char)*p))
			*p = (char)tolower((unsigned char)*p);
@


1.32
log
@Remove the (non-default) MD4 hash algorithm from S/Key.
ok millert, man pages ok jmc@@
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.31 2013/11/29 19:00:51 deraadt Exp $
d28 1
a28 1
/* Default hash function to use (index into skey_hash_types array) */
d30 1
a30 1
#define SKEY_HASH_DEFAULT	1
d40 1
a40 1
/* Current hash type (index into skey_hash_types array) */
a46 1
#define SKEY_ALGORITH_LAST	4
d54 2
a55 1
	{ "rmd160", keycrunch_rmd160 }
d393 1
a393 1
	for (i = 0; i < SKEY_ALGORITH_LAST; i++) {
@


1.31
log
@fairly simple unsigned char casts for ctype
ok krw
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.30 2007/05/17 04:34:50 ray Exp $
a21 1
#include <md4.h>
a32 1
static int keycrunch_md4(char *, char *, char *);
a52 1
	{ "md4", keycrunch_md4 },
a69 42
}

static int
keycrunch_md4(char *result, char *seed, char *passwd)
{
	char *buf = NULL;
	MD4_CTX md;
	u_int32_t results[4];
	unsigned int buflen;

	/*
	 * If seed and passwd are defined we are in keycrunch() mode,
	 * else we are in f() mode.
	 */
	if (seed && passwd) {
		buflen = strlen(seed) + strlen(passwd);
		if ((buf = malloc(buflen + 1)) == NULL)
			return(-1);
		(void)strlcpy(buf, seed, buflen + 1);
		lowcase(buf);
		(void)strlcat(buf, passwd, buflen + 1);
		sevenbit(buf);
	} else {
		buf = result;
		buflen = SKEY_BINKEY_SIZE;
	}

	/* Crunch the key through MD4 */
	MD4Init(&md);
	MD4Update(&md, (unsigned char *)buf, buflen);
	MD4Final((unsigned char *)results, &md);

	/* Fold result from 128 to 64 bits */
	results[0] ^= results[2];
	results[1] ^= results[3];

	(void)memcpy((void *)result, (void *)results, SKEY_BINKEY_SIZE);

	if (buf != result)
		(void)free(buf);

	return(0);
@


1.30
log
@Check fgets return value, from Charles Longeau.

OK millert@@.
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.29 2006/04/10 08:06:08 deraadt Exp $
d484 2
a485 2
		if (isupper(*p))
			*p = (char)tolower(*p);
@


1.29
log
@minimal cleanups lint begs for
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.28 2004/07/28 19:37:09 millert Exp $
d287 2
a288 1
	(void)fgets(buf, n, stdin);
d308 2
a309 1
	(void)fgets(buf, n, stdin);
@


1.28
log
@Use SHA1Pad() instead of relying on unspecified behavior.
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.27 2003/06/26 23:19:53 deraadt Exp $
d89 1
a89 1
		if ((buf = (char *)malloc(buflen + 1)) == NULL)
d131 1
a131 1
		if ((buf = (char *)malloc(buflen + 1)) == NULL)
d173 1
a173 1
		if ((buf = (char *)malloc(buflen + 1)) == NULL)
d226 1
a226 1
		if ((buf = (char *)malloc(buflen + 1)) == NULL)
d316 1
d325 1
a325 1
	_exit(-1);
d483 1
a483 1
			*p = tolower(*p);
@


1.27
log
@simple protos
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.26 2003/04/03 17:48:50 millert Exp $
d187 1
a187 1
	SHA1Final(NULL, &sha);
@


1.26
log
@Use snprintf() and strlcpy() throughout.
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.25 2002/05/29 18:53:15 deraadt Exp $
d279 1
a279 1
	void (*old_handler)();
@


1.25
log
@strlcat bounds
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.24 2002/05/24 21:33:09 deraadt Exp $
d64 4
a67 2
 * concatenate the seed and the password, run through hash function and
 * collapse to 64 bits. This is defined as the user's starting key.
d70 1
a70 4
keycrunch(result, seed, passwd)
	char *result;	/* SKEY_BINKEY_SIZE result */
	char *seed;	/* Seed, any length */
	char *passwd;	/* Password, any length */
d76 1
a76 4
keycrunch_md4(result, seed, passwd)
	char *result;	/* SKEY_BINKEY_SIZE result */
	char *seed;	/* Seed, any length */
	char *passwd;	/* Password, any length */
d118 1
a118 4
keycrunch_md5(result, seed, passwd)
	char *result;	/* SKEY_BINKEY_SIZE result */
	char *seed;	/* Seed, any length */
	char *passwd;	/* Password, any length */
d160 1
a160 4
keycrunch_sha1(result, seed, passwd)
	char *result;	/* SKEY_BINKEY_SIZE result */
	char *seed;	/* Seed, any length */
	char *passwd;	/* Password, any length */
d213 1
a213 4
keycrunch_rmd160(result, seed, passwd)
	char *result;	/* SKEY_BINKEY_SIZE result */
	char *seed;	/* Seed, any length */
	char *passwd;	/* Password, any length */
d260 1
a260 2
f(x)
	char *x;
d267 1
a267 2
rip(buf)
	char *buf;
d277 1
a277 3
readpass(buf, n)
	char *buf;
	int n;
d305 1
a305 3
readskey(buf, n)
	char *buf;
	int n;
d317 1
a317 2
trapped(sig)
	int sig;
d328 1
a328 1
 * Convert 8-byte hex-ascii string to binary array
d332 1
a332 3
atob8(out, in)
	char *out;
	char *in;
d356 1
a356 1
/* Convert 8-byte binary array to hex-ascii string */
d358 1
a358 3
btoa8(out, in)
	char *out;
	char *in;
a359 2
	int i;

d363 4
a366 4
	for (i=0; i < 8; i++) {
		(void)sprintf(out, "%02x", *in++ & 0xff);
		out += 2;
	}
d372 1
a372 2
htoi(c)
	int c;
d385 1
a385 2
skipspace(cp)
	char *cp;
d398 1
a398 2
backspace(buf)
	char *buf;
d423 1
a423 2
sevenbit(s)
	char *s;
d431 1
a431 2
skey_set_algorithm(new)
	char *new;
d447 1
a447 1
skey_get_algorithm()
d454 1
a454 2
skey_echo(action)
	int action;
d476 1
a476 2
lowcase(s)
	char *s;
d480 1
a480 1
	for (p = s; *p; p++)
d483 1
@


1.24
log
@replace strcpy with strlcpy
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.23 2002/02/16 21:27:28 millert Exp $
d97 1
a97 1
		(void)strcat(buf, passwd);
d142 1
a142 1
		(void)strcat(buf, passwd);
d187 1
a187 1
		(void)strcat(buf, passwd);
d243 1
a243 1
		(void)strcat(buf, passwd);
@


1.23
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.22 2002/01/24 23:01:19 millert Exp $
d95 1
a95 1
		(void)strcpy(buf, seed);
d140 1
a140 1
		(void)strcpy(buf, seed);
d185 1
a185 1
		(void)strcpy(buf, seed);
d241 1
a241 1
		(void)strcpy(buf, seed);
@


1.22
log
@Fix `necesary' typos; Alexander Yurchenko

Alas many of these were introduced by yours truly as necessary
just doesn't look right to me for some reason ;-)
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.21 2001/11/14 20:53:03 deraadt Exp $
d34 7
a40 7
static int keycrunch_md4 __P((char *, char *, char *));
static int keycrunch_md5 __P((char *, char *, char *));
static int keycrunch_sha1 __P((char *, char *, char *));
static int keycrunch_rmd160 __P((char *, char *, char *));
static void lowcase __P((char *));
static void skey_echo __P((int));
static void trapped __P((int));
d52 1
a52 1
	int (*keycrunch) __P((char *, char *, char *));
d296 1
a296 1
	void (*old_handler) __P(());
@


1.21
log
@avoid stdio in a signal handler; millert ok
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.20 2001/06/23 21:03:47 millert Exp $
d341 1
a341 1
	/* Turn on echo if necesary */
@


1.20
log
@Get rid of f_HASH() and fold its functionality into keycrunch_HASH().
This means we now only need to add one new function when adding a
new hash type.

Somehow missed from last S/Key commit (changes are static to skeysubr.c).
@
text
@d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.19 2001/01/26 16:06:40 millert Exp $
d21 1
d339 1
a339 2
	(void)fputs("^C\n", stderr);
	(void)fflush(stderr);
d344 1
a344 1
	exit(-1);
@


1.19
log
@SHA1 is a big endian algorithm but RFC2289 mandates that results be
stored in little endian form (like MD4/MD5).  So, instead of having
SHA1Final copy the result buffer, we do it ourselves with a loop
stolen from RFC2289, Appendix A.  Closes PR1650.
@
text
@d1 1
a1 1
/* S/KEY v1.1b (skeysubr.c)
a6 2
 *
 * Modifications: 
d10 1
a10 1
 * S/KEY misc routines.
d12 1
a12 1
 * $OpenBSD: skeysubr.c,v 1.18 1998/07/03 01:08:14 angelos Exp $
d33 7
a39 11
static void f_md4 __P((char *x));
static void f_md5 __P((char *x));
static void f_sha1 __P((char *x));
static void f_rmd160 __P((char *x));
static int keycrunch_md4 __P((char *result, char *seed, char *passwd));
static int keycrunch_md5 __P((char *result, char *seed, char *passwd));
static int keycrunch_sha1 __P((char *result, char *seed, char *passwd));
static int keycrunch_rmd160 __P((char *result, char *seed, char *passwd));
static void lowcase __P((char *s));
static void skey_echo __P((int action));
static void trapped __P((int sig));
a51 1
	void (*f) __P((char *));
d54 4
a57 4
	{ "md4", keycrunch_md4, f_md4 },
	{ "md5", keycrunch_md5, f_md5 },
	{ "sha1", keycrunch_sha1, f_sha1 },
	{ "rmd160", keycrunch_rmd160, f_rmd160 }
d63 1
a63 1
 * concatenate the seed and the password, run through MD4/5 and
d81 1
a81 1
	char *buf;
d86 16
a101 6
	buflen = strlen(seed) + strlen(passwd);
	if ((buf = (char *)malloc(buflen+1)) == NULL)
		return(-1);
	(void)strcpy(buf, seed);
	lowcase(buf);
	(void)strcat(buf, passwd);
a103 1
	sevenbit(buf);
a106 1
	(void)free(buf);
d114 3
d131 16
a146 6
	buflen = strlen(seed) + strlen(passwd);
	if ((buf = (char *)malloc(buflen+1)) == NULL)
		return(-1);
	(void)strcpy(buf, seed);
	lowcase(buf);
	(void)strcat(buf, passwd);
a148 1
	sevenbit(buf);
a151 1
	(void)free(buf);
d159 3
d176 16
a191 6
	buflen = strlen(seed) + strlen(passwd);
	if ((buf = (char *)malloc(buflen+1)) == NULL)
		return(-1);
	(void)strcpy(buf, seed);
	lowcase(buf);
	(void)strcat(buf, passwd);
a193 1
	sevenbit(buf);
a196 1
	(void)free(buf);
d210 1
a210 1
		result[j+1] = (u_char)((sha.state[i] >> 8) & 0xff);
d215 3
d232 16
a247 6
	buflen = strlen(seed) + strlen(passwd);
	if ((buf = (char *)malloc(buflen+1)) == NULL)
		return(-1);
	(void)strcpy(buf, seed);
	lowcase(buf);
	(void)strcat(buf, passwd);
a249 1
	sevenbit(buf);
a252 1
	(void)free(buf);
d261 3
d268 1
a268 1
 * The one-way function f().
d275 1
a275 85
	skey_algorithm_table[skey_hash_type].f(x);
}

static void
f_md4(x)
	char *x;
{
	MD4_CTX md;
	u_int32_t results[4];

	MD4Init(&md);
	MD4Update(&md, (unsigned char *)x, SKEY_BINKEY_SIZE);
	MD4Final((unsigned char *)results, &md);

	/* Fold 128 to 64 bits */
	results[0] ^= results[2];
	results[1] ^= results[3];

	(void)memcpy((void *)x, (void *)results, SKEY_BINKEY_SIZE);
}

static void
f_md5(x)
	char *x;
{
	MD5_CTX md;
	u_int32_t results[4];

	MD5Init(&md);
	MD5Update(&md, (unsigned char *)x, SKEY_BINKEY_SIZE);
	MD5Final((unsigned char *)results, &md);

	/* Fold 128 to 64 bits */
	results[0] ^= results[2];
	results[1] ^= results[3];

	(void)memcpy((void *)x, (void *)results, SKEY_BINKEY_SIZE);
}

static void
f_sha1(x)
	char *x;
{
	SHA1_CTX sha;
	int i, j;

	SHA1Init(&sha);
	SHA1Update(&sha, (unsigned char *)x, SKEY_BINKEY_SIZE);
	SHA1Final(NULL, &sha);

	/* Fold 160 to 64 bits */
	sha.state[0] ^= sha.state[2];
	sha.state[1] ^= sha.state[3];
	sha.state[0] ^= sha.state[4];

	/*
	 * SHA1 is a big endian algorithm but RFC2289 mandates that
	 * the result be in little endian form, so we copy to the
	 * result buffer manually.
	 */
	for (i = 0, j = 0; j < 8; i++, j += 4) {
		x[j]   = (u_char)(sha.state[i] & 0xff);
		x[j+1] = (u_char)((sha.state[i] >> 8) & 0xff);
		x[j+2] = (u_char)((sha.state[i] >> 16) & 0xff);
		x[j+3] = (u_char)((sha.state[i] >> 24) & 0xff);
	}
}

static void
f_rmd160(x)
	char *x;
{
	RMD160_CTX rmd;
	u_int32_t results[5];

	RMD160Init(&rmd);
	RMD160Update(&rmd, (unsigned char *)x, SKEY_BINKEY_SIZE);
	RMD160Final((unsigned char *)results, &rmd);

	/* Fold 160 to 64 bits */
	results[0] ^= results[2];
	results[1] ^= results[3];
	results[0] ^= results[4];

	(void)memcpy((void *)x, (void *)results, SKEY_BINKEY_SIZE);
d353 2
a354 2
	register char *out;
	register char *in;
d356 2
a357 2
	register int i;
	register int val;
d381 2
a382 2
	register char *out;
	register char *in;
d384 1
a384 1
	register int i;
d399 1
a399 1
	register int c;
d413 1
a413 1
	register char *cp;
@


1.18
log
@Remove user existance disclosure through "s/key" challenges.
@
text
@d14 1
a14 1
 * $OpenBSD: skeysubr.c,v 1.17 1997/07/27 21:36:06 millert Exp $
a157 1
	u_int32_t results[5];
d159 1
d172 1
a172 1
	SHA1Final((unsigned char *)results, &sha);
d176 15
a190 5
	results[0] ^= results[2];
	results[1] ^= results[3];
	results[0] ^= results[4];

	(void)memcpy((void *)result, (void *)results, SKEY_BINKEY_SIZE);
d282 1
a282 1
	u_int32_t results[5];
d286 1
a286 1
	SHA1Final((unsigned char *)results, &sha);
d289 15
a303 5
	results[0] ^= results[2];
	results[1] ^= results[3];
	results[0] ^= results[4];

	(void)memcpy((void *)x, (void *)results, SKEY_BINKEY_SIZE);
@


1.17
log
@- Do coarse locking on /etc/skeykeys.  Fixes a race that could allow
  a replay attempt to succeed.
- OpenBSD tags
@
text
@d14 1
a14 1
 * $OpenBSD: skeysubr.c,v 1.16 1997/07/24 23:00:27 millert Exp $
d451 1
a451 1
/* Remove backspaced over charaters from the string */
@


1.16
log
@Fix one instance of bad strncpy() usage and some KNF.
@
text
@d10 1
d14 1
a14 1
 * $Id: skeysubr.c,v 1.15 1997/07/17 05:48:38 millert Exp $
@


1.15
log
@Add RIPEMD-160 (rmd160) support to OTP (s/key).
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.14 1997/07/11 01:32:57 millert Exp $
d94 1
a94 1
		return -1;
d112 1
a112 1
	return 0;
d128 1
a128 1
		return -1;
d146 1
a146 1
	return 0;
d162 1
a162 1
		return -1;
d181 1
a181 1
	return 0;
d197 1
a197 1
		return -1;
d216 1
a216 1
	return 0;
d342 1
a342 1
	return buf;
d354 1
a354 1
	sevenbit (buf);
d356 1
a356 1
	return buf;
d379 2
a380 1
	register char *out, *in;
d386 1
a386 1
		return -1;
d390 1
a390 1
			return -1;
d392 1
a392 1
			return -1;
d396 1
a396 1
			return -1;
d398 1
a398 1
			return -1;
d401 1
a401 1
	return 0;
d407 2
a408 1
	register char *out, *in;
d413 1
a413 1
		return -1;
d419 1
a419 1
	return 0;
d428 1
a428 1
		return c - '0';
d430 1
a430 1
		return 10 + c - 'a';
d432 2
a433 2
		return 10 + c - 'A';
	return -1;
d445 1
a445 1
		return NULL;
d447 1
a447 1
		return cp;
d495 1
a495 1
			return new;
d499 1
a499 1
	return NULL;
@


1.14
log
@Remove #if 0'd code
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.13 1997/07/10 22:53:37 millert Exp $
d25 1
d37 1
d41 1
d53 1
a53 1
#define SKEY_ALGORITH_LAST	3
d62 2
a63 1
	{ "sha1", keycrunch_sha1, f_sha1 }
d184 35
d276 19
@


1.13
log
@Use new SHA1* functions.
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.12 1996/11/03 18:57:30 millert Exp $
a175 5
#if 0 /* XXX */
#if BYTE_ORDER == LITTLE_ENDIAN
	sha1ByteReverse((u_int32_t *)result, SKEY_BINKEY_SIZE);
#endif /* LITTLE_ENDIAN */
#endif
a243 5
#if 0 /* XXX */
#if BYTE_ORDER == LITTLE_ENDIAN
	sha1ByteReverse((u_int32_t *)x, SKEY_BINKEY_SIZE);
#endif /* LITTLE_ENDIAN */
#endif
@


1.12
log
@Add a bunch of length/size macros and use them.
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.11 1996/10/22 01:37:54 millert Exp $
d152 2
a153 1
	SHA1_INFO sha;
d165 3
a167 3
	sha1Init(&sha);
	sha1Update(&sha, (unsigned char *)buf, buflen);
	sha1Final(&sha);
d171 3
a173 3
	sha.digest[0] ^= sha.digest[2];
	sha.digest[1] ^= sha.digest[3];
	sha.digest[0] ^= sha.digest[4];
d175 2
a176 1
	(void)memcpy((void *)result, (void *)sha.digest, SKEY_BINKEY_SIZE);
d180 1
d236 2
a237 1
	SHA1_INFO sha;
d239 3
a241 3
	sha1Init(&sha);
	sha1Update(&sha, (unsigned char *)x, SKEY_BINKEY_SIZE);
	sha1Final(&sha);
d244 3
a246 3
	sha.digest[0] ^= sha.digest[2];
	sha.digest[1] ^= sha.digest[3];
	sha.digest[0] ^= sha.digest[4];
d248 2
a249 1
	(void)memcpy((void *)x, (void *)sha.digest, SKEY_BINKEY_SIZE);
d253 1
@


1.11
log
@Don't need the extra newline since we never turn off echo for s/key
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.10 1996/10/14 03:09:13 millert Exp $
d50 1
a50 1
#define SKEY_ALGORITH_MAX	3
d70 1
a70 1
	char *result;	/* 8-byte result */
d79 1
a79 1
	char *result;	/* 8-byte result */
d106 1
a106 1
	(void)memcpy((void *)result, (void *)results, 8);
d113 1
a113 1
	char *result;	/* 8-byte result */
d140 1
a140 1
	(void)memcpy((void *)result, (void *)results, 8);
d147 1
a147 1
	char *result;	/* 8-byte result */
d174 1
a174 1
	(void)memcpy((void *)result, (void *)sha.digest, 8);
d176 1
a176 1
	sha1ByteReverse((u_int32_t *)result, 8);
d182 4
a185 1
/* The one-way function f(). Takes 8 bytes and returns 8 bytes in place */
d201 1
a201 1
	MD4Update(&md, (unsigned char *)x, 8);
d208 1
a208 1
	(void)memcpy((void *)x, (void *)results, 8);
d219 1
a219 1
	MD5Update(&md, (unsigned char *)x, 8);
d226 1
a226 1
	(void)memcpy((void *)x, (void *)results, 8);
d236 1
a236 1
	sha1Update(&sha, (unsigned char *)x, 8);
d244 1
a244 1
	(void)memcpy((void *)x, (void *)sha.digest, 8);
d246 1
a246 1
	sha1ByteReverse((u_int32_t *)x, 8);
d333 1
a333 1
	for (i=0; i<8; i++) {
d429 1
a429 1
/* Set hash type type */
d436 1
a436 1
	for (i = 0; i < SKEY_ALGORITH_MAX; i++) {
@


1.10
log
@htoi now takes an int, not char.
Only skey_set_algorithm() for the record that matches target user.
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.9 1996/09/30 23:54:38 millert Exp $
a295 3

	(void)putc('\n', stderr);
	(void)fflush(stderr);
@


1.9
log
@Added missing static's.
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.8 1996/09/30 23:26:28 millert Exp $
d369 1
a369 1
	register char c;
@


1.8
log
@Fix byte order problem with sha1.
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.7 1996/09/30 18:55:56 millert Exp $
d190 1
a190 1
void
d208 1
a208 1
void
d226 1
a226 1
void
@


1.7
log
@More RFC 1938 compliance--convert seed to lower case internally.
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.6 1996/09/30 04:10:47 millert Exp $
d175 3
d242 3
@


1.6
log
@__ARGS -> __P (why does everyone have to do this differently?)
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.5 1996/09/29 23:35:07 millert Exp $
d19 1
a32 1
static void trapped __P((int sig));
a35 1
static void skey_echo __P((int action));
d39 3
d92 1
d126 1
d159 1
d431 1
a431 2
		/* XXX - should be case *sensitive* but need to wait a bit. */
		if (strcasecmp(new, skey_algorithm_table[i].name) == 0) {
d468 12
@


1.5
log
@check skey_set_algorithm() ret val + pedantry.
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.4 1996/09/29 21:27:02 millert Exp $
d32 8
a39 8
static void trapped __ARGS((int sig));
static void f_md4 __ARGS ((char *x));
static void f_md5 __ARGS ((char *x));
static void f_sha1 __ARGS ((char *x));
static void skey_echo __ARGS ((int action));
static int keycrunch_md4 __ARGS ((char *result, char *seed, char *passwd));
static int keycrunch_md5 __ARGS ((char *result, char *seed, char *passwd));
static int keycrunch_sha1 __ARGS ((char *result, char *seed, char *passwd));
d51 2
a52 2
	int (*keycrunch) __ARGS((char *, char *, char *));
	void (*f) __ARGS((char *));
@


1.4
log
@Towards RFC 1938 compliance.  Also, now supports SHA (secure hash algorithm).
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.3 1996/09/27 20:40:17 millert Exp $
d96 1
a96 1
	MD4Final((unsigned char *)results ,&md);
d129 1
a129 1
	MD5Final((unsigned char *)results ,&md);
d426 1
a426 1
		/* XXX - should be case *sensitive* */
d429 1
a429 1
			return(new);
d433 1
a433 1
	return(NULL);
@


1.3
log
@Nicer echo on/off in its own function.
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.2 1996/09/27 15:39:00 millert Exp $
d23 1
d27 3
a29 3
/* Default MDX function to use (currently 4 or 5) */
#ifndef SKEY_MDX_DEFAULT
#define SKEY_MDX_DEFAULT	5
d33 26
a58 5
static void f_MD4 __ARGS ((char *x));
static void f_MD5 __ARGS ((char *x));
static void skey_echo __ARGS ((int));
static int keycrunch_MD4 __ARGS ((char *result, char *seed, char *passwd));
static int keycrunch_MD5 __ARGS ((char *result, char *seed, char *passwd));
a59 1
static int skey_MDX = 0;
d72 1
a72 9
	switch (skey_get_MDX()) {
		/*
		 * Need a default case to appease gc even though 
		 * skey_set_MDX() guantaees we get back 4 or 5
		 */
		case 4  : return(keycrunch_MD4(result, seed, passwd));
		default : return(keycrunch_MD5(result, seed, passwd));
	}
	/* NOTREACHED */
d76 1
a76 1
keycrunch_MD4(result, seed, passwd)
d109 1
a109 1
keycrunch_MD5(result, seed, passwd)
d141 33
d179 1
a179 9
	switch (skey_get_MDX()) {
		/*
		 * Need a default case to appease gc even though 
		 * skey_set_MDX() guantaees we get back 4 or 5
		 */
		case 4  : return(f_MD4(x));
		default : return(f_MD5(x));
	}
	/* NOTREACHED */
d183 1
a183 1
f_MD4(x)
d201 1
a201 1
f_MD5(x)
d218 18
d418 4
a421 4
/* Set MDX type (returns previous) */
int
skey_set_MDX(new)
	int new;
d423 1
a423 1
	int old;
d425 7
a431 2
	if (new != 4 && new != 5)
		return -1;
d433 1
a433 3
	old = skey_get_MDX();
	skey_MDX = new;
	return old;
d436 3
a438 3
/* Get current MDX type */
int
skey_get_MDX()
d440 1
a440 4
	if (skey_MDX == 0)
		skey_MDX = SKEY_MDX_DEFAULT;

	return skey_MDX;
@


1.2
log
@Deal with both MD4 and MD5 s/key's
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.1.1.1 1995/10/18 08:43:11 deraadt Exp $
d34 1
a38 1
static int skey_echo;
d191 1
a196 1
	struct termios term;
d199 3
a204 7
	/* Turn off echoing */
	(void) tcgetattr(fileno(stdin), &term);
	if ((skey_echo = (term.c_lflag & ECHO))) {
		term.c_lflag &= ~ECHO;
		(void)tcsetattr(fileno(stdin), TCSAFLUSH|TCSASOFT, &term);
	}

d211 1
a211 5
	/* Restore echo and signal handler */
	if (skey_echo) {
		term.c_lflag |= ECHO;
		(void)tcsetattr(fileno(stdin), TCSAFLUSH|TCSASOFT, &term);
	}
d214 1
d221 1
d238 1
d246 2
a247 8
	/* Turn on echo if we turned it off */
	if (skey_echo) {
		struct termios term;

		(void) tcgetattr(fileno(stdin), &term);
		term.c_lflag |= ECHO;
		(void)tcsetattr(fileno(stdin), TCSAFLUSH|TCSASOFT, &term);
	}
d385 23
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
 * $Id: skeysubr.c,v 1.5 1995/06/19 22:47:37 jtc Exp $
d21 2
a23 1
#include "md4.h"
d26 4
a29 2
struct termios newtty;
struct termios oldtty;
d32 11
a42 6
static void set_term __ARGS((void));
static void unset_term __ARGS((void));
static void echo_off __ARGS((void));

/* Crunch a key:
 * concatenate the seed and the password, run through MD4 and
d46 21
a66 4
keycrunch(result,seed,passwd)
char *result;	/* 8-byte result */
char *seed;	/* Seed, any length */
char *passwd;	/* Password, any length */
d69 2
a70 1
	MDstruct md;
d72 1
a72 3
	int i;
	register long tmp;
	
d76 2
a77 2
	strcpy(buf,seed);
	strcat(buf,passwd);
d81 24
a104 2
	MDbegin(&md);
	MDupdate(&md,(unsigned char *)buf,8*buflen);
d106 12
a117 1
	free(buf);
d120 2
a121 2
	md.buffer[0] ^= md.buffer[2];
	md.buffer[1] ^= md.buffer[3];
d123 1
a123 13
	/* Default (but slow) code that will convert to
	 * little-endian byte ordering on any machine
	 */
	for (i=0; i<2; i++) {
		tmp = md.buffer[i];
		*result++ = tmp;
		tmp >>= 8;
		*result++ = tmp;
		tmp >>= 8;
		*result++ = tmp;
		tmp >>= 8;
		*result++ = tmp;
	}
d133 17
a149 2
	MDstruct md;
	register long tmp;
d151 3
a153 2
	MDbegin(&md);
	MDupdate(&md,(unsigned char *)x,64);
d156 2
a157 2
	md.buffer[0] ^= md.buffer[2];
	md.buffer[1] ^= md.buffer[3];
d159 19
a177 20
	/* Default (but slow) code that will convert to
	 * little-endian byte ordering on any machine
	 */
	tmp = md.buffer[0];
	*x++ = tmp;
	tmp >>= 8;
	*x++ = tmp;
	tmp >>= 8;
	*x++ = tmp;
	tmp >>= 8;
	*x++ = tmp;

	tmp = md.buffer[1];
	*x++ = tmp;
	tmp >>= 8;
	*x++ = tmp;
	tmp >>= 8;
	*x++ = tmp;
	tmp >>= 8;
	*x = tmp;
d185 1
a185 4
	char *cp;

	if ((cp = strchr(buf,'\r')) != NULL)
		*cp = '\0';
d187 2
a188 2
	if ((cp = strchr(buf,'\n')) != NULL)
		*cp = '\0';
d192 1
a192 1
readpass (buf,n)
d196 2
a197 2
	set_term();
	echo_off();
d199 9
a207 1
	fgets(buf, n, stdin);
d209 1
d211 11
a221 1
	printf("\n");
a224 1
	unset_term();
d233 2
a234 1
	fgets (buf, n, stdin);
d236 2
a237 2
	rip(buf);
	printf ("\n");
d245 2
a246 1
set_term() 
d248 2
a249 6
	fflush(stdout);
	tcgetattr(fileno(stdin), &newtty);
	tcgetattr(fileno(stdin), &oldtty);
 
	signal (SIGINT, trapped);
}
d251 8
a258 10
static void
echo_off()
{
	newtty.c_lflag &= ~(ICANON | ECHO | ECHONL);
	newtty.c_cc[VMIN] = 1;
	newtty.c_cc[VTIME] = 0;
	newtty.c_cc[VINTR] = 3;

	tcsetattr(fileno(stdin), TCSADRAIN, &newtty);
}
a259 13
static void
unset_term()
{
	tcsetattr(fileno(stdin), TCSADRAIN, &oldtty);
}

static void
trapped(sig)
	int sig;
{
	signal(SIGINT, trapped);
	printf("^C\n");
	unset_term();
d263 2
a264 1
/* Convert 8-byte hex-ascii string to binary array
d303 2
a304 2
	for (i=0;i<8;i++) {
		sprintf(out,"%02x",*in++ & 0xff);
a309 1

d324 1
d338 1
a338 1
/* removebackspaced over charaters from the string */
d341 1
a341 1
char *buf;
d352 3
a354 4
			}
			else {
			  cp++;
			  out--;
d364 1
a364 5
/* sevenbit ()
 *
 * Make sure line is all seven bits.
 */
 
d371 25
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
