head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.2
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.10
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.6
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.8
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.42
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.38
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.36
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.34
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.32
	OPENBSD_5_0:1.19.0.30
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.28
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.26
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.22
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.24
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.20
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.18
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.16
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.14
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.12
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.10
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.8
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.8
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.6
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.13.0.8
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.6
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2017.03.20.21.11.21;	author tb;	state Exp;
branches;
next	1.20;
commitid	iymPJkmeBwkR9FqO;

1.20
date	2014.03.20.20.39.13;	author naddy;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.05.13.31.36;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.16.03.50.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.28;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.23.22.28.23;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.23.21.09.11;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.20.22.14.20;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.07.15.14.33.48;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	98.07.03.02.06.21;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	98.07.03.01.08.11;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	97.07.27.21.36.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.23.06.53.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.00.42.26;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.11.03.18.57.29;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.10.14.03.09.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.30.04.10.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.29.21.27.01;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.27.15.38.59;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	95.12.20.09.48.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Generate the bogus challenge using arc4random_buf(3) instead of reading
directly from /var/db/host.random and falling back to ctime. Remove the
_SKEY_RAND_FILE_PATH_ since it's no longer needed.

ok millert, mestre
@
text
@/*
 * OpenBSD S/Key (skey.h)
 *
 * Authors:
 *          Neil M. Haller <nmh@@thumper.bellcore.com>
 *          Philip R. Karn <karn@@chicago.qualcomm.com>
 *          John S. Walden <jsw@@thumper.bellcore.com>
 *          Scott Chasin <chasin@@crimelab.com>
 *          Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Main client header
 *
 * $OpenBSD: skey.h,v 1.20 2014/03/20 20:39:13 naddy Exp $
 */

#ifndef _SKEY_H_
#define _SKEY_H_ 1

#include <dirent.h>

/* Server-side data structure for reading keys file during login */
struct skey {
	FILE *keyfile;
	DIR  *keydir;
	char *logname;
	char *seed;
	char *val;
	unsigned int n;
	char buf[256];
};

/* Client-side structure for scanning data stream for challenge */
struct mc {
	int skip;
	int cnt;
	char buf[256];
};

/* Maximum sequence number we allow */
#define SKEY_MAX_SEQ		10000

/* Minimum secret password length (rfc2289) */
#define SKEY_MIN_PW_LEN		10

/* Max secret password length (rfc2289 says 63 but allows more) */
#define SKEY_MAX_PW_LEN		255

/* Max length of an S/Key seed (rfc2289) */
#define SKEY_MAX_SEED_LEN	16

/* Max length of S/Key challenge (otp-???? 9999 seed) */
#define SKEY_MAX_CHALLENGE	(11 + SKEY_MAX_HASHNAME_LEN + SKEY_MAX_SEED_LEN)

/* Max length of hash algorithm name (md5/sha1/rmd160) */
#define SKEY_MAX_HASHNAME_LEN	6

/* Size of a binary key (not NULL-terminated) */
#define SKEY_BINKEY_SIZE	8

/* Directory for S/Key per-user files */
#define _PATH_SKEYDIR		"/etc/skey"

__BEGIN_DECLS
void f(char *);
int keycrunch(char *, char *, char *);
char *btoe(char *, char *);
char *put8(char *, char *);
int etob(char *, char *);
void rip(char *);
int skeychallenge(struct skey *, char *, char *);
int skeychallenge2(int, struct skey *, char *, char *);
int skeylookup(struct skey *, char *);
int skeyverify(struct skey *, char *);
int skeyzero(struct skey *);
void sevenbit(char *);
void backspace(char *);
char *skipspace(char *);
char *readpass(char *, int);
char *readskey(char *, int);
int skey_authenticate(char *);
int skey_passcheck(char *, char *);
char *skey_keyinfo(char *);
int skey_haskey(char *);
int atob8(char *, char *);
int btoa8(char *, char *);
int htoi(int);
const char *skey_get_algorithm(void);
char *skey_set_algorithm(char *);
int skeygetnext(struct skey *);
int skey_unlock(struct skey *);
__END_DECLS

#endif /* _SKEY_H_ */
@


1.20
log
@Remove the (non-default) MD4 hash algorithm from S/Key.
ok millert, man pages ok jmc@@
@
text
@d13 1
a13 1
 * $OpenBSD: skey.h,v 1.19 2004/08/05 13:31:36 millert Exp $
a58 3

/* Location of random file for bogus challenges */
#define _SKEY_RAND_FILE_PATH_	"/var/db/host.random"
@


1.19
log
@Add skeychallenge2() which is like skeychallenge() but takes an
already open fd.  Will be used to make separate challenge/response
invocations of login_skey keep the record locked.  Also properly
escape minus signs in man page.  OK henning@@ jmc@@
@
text
@d13 1
a13 1
 * $OpenBSD: skey.h,v 1.18 2002/05/16 03:50:42 millert Exp $
d54 1
a54 1
/* Max length of hash algorithm name (md4/md5/sha1/rmd160) */
@


1.18
log
@Change S/Key stuff from using a flat file (/etc/skeykeys) to a directory
where each user gets their own file, which is owned by that user.

An old S/Key database may be converted by running "skeyinit -C" as root.

Programs that need to access the S/Key database no longer need to be
setuid root.  They must now be setgid auth instead.
@
text
@d13 1
a13 1
 * $OpenBSD: skey.h,v 1.17 2002/02/16 21:27:28 millert Exp $
d74 1
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d13 1
a13 1
 * $OpenBSD: skey.h,v 1.16 2001/06/23 22:28:23 millert Exp $
d19 1
a19 1
#include <sys/cdefs.h>
d24 1
d28 1
a28 3
	int n;
	int len;
	long recstart;		/* needed so reread of buffer is efficient */
d62 3
@


1.16
log
@sync skeyzero proto with recent changes
@
text
@d13 1
a13 1
 * $OpenBSD: skey.h,v 1.15 2001/06/23 21:09:11 millert Exp $
d65 26
a90 26
void f __P((char *));
int keycrunch __P((char *, char *, char *));
char *btoe __P((char *, char *));
char *put8 __P((char *, char *));
int etob __P((char *, char *));
void rip __P((char *));
int skeychallenge __P((struct skey *, char *, char *));
int skeylookup __P((struct skey *, char *));
int skeyverify __P((struct skey *, char *));
int skeyzero __P((struct skey *));
void sevenbit __P((char *));
void backspace __P((char *));
char *skipspace __P((char *));
char *readpass __P((char *, int));
char *readskey __P((char *, int));
int skey_authenticate __P((char *));
int skey_passcheck __P((char *, char *));
char *skey_keyinfo __P((char *));
int skey_haskey __P((char *));
int atob8 __P((char *, char *));
int btoa8 __P((char *, char *));
int htoi __P((int));
const char *skey_get_algorithm __P((void));
char *skey_set_algorithm __P((char *));
int skeygetnext __P((struct skey *));
int skey_unlock __P((struct skey *));
@


1.15
log
@getskeyprompt() is gone
@
text
@d13 1
a13 1
 * $OpenBSD: skey.h,v 1.14 2001/06/20 22:14:20 millert Exp $
d74 1
a74 1
int skeyzero __P((struct skey *, char *));
@


1.14
log
@o Add a length parameter to struct skey and rearrange some other structs
o Protect from duplicate inclusion and use __{BEGIN,END}_DECLS
o Prototype new skey_unlock() function and remove proto for getskeyprompt()
  which has been removed.
@
text
@d13 1
a13 1
 * $OpenBSD: skey.h,v 1.13 1999/07/15 14:33:48 provos Exp $
a83 1
int getskeyprompt __P((struct skey *, char *, char *));
@


1.13
log
@change /etc/host.random to /var/db/host.random
@
text
@d2 1
a2 1
 * S/KEY v1.1b (skey.h)
a7 2
 *
 * Modifications:
d13 1
a13 1
 * $OpenBSD: skey.h,v 1.12 1998/07/03 02:06:21 angelos Exp $
d16 5
a23 1
	char buf[256];
a24 1
	int n;
d27 2
d30 1
a34 1
	char buf[256];
d37 1
a40 1
#ifndef SKEY_MAX_SEQ
a41 1
#endif
d43 1
a43 2
/* Minimum secret password length (rfc1938) */
#ifndef SKEY_MIN_PW_LEN
a44 1
#endif
d46 1
a46 2
/* Max secret password length (rfc1938 says 63 but allows more) */
#ifndef SKEY_MAX_PW_LEN
a47 1
#endif
d49 1
a49 2
/* Max length of an S/Key seed (rfc1938) */
#ifndef SKEY_MAX_SEED_LEN
a50 1
#endif
a52 1
#ifndef SKEY_MAX_CHALLENGE
a53 1
#endif
d64 24
a87 24
/* Prototypes */
void f __P((char *x));
int keycrunch __P((char *result, char *seed, char *passwd));
char *btoe __P((char *engout, char *c));
char *put8 __P((char *out, char *s));
int etob __P((char *out, char *e));
void rip __P((char *buf));
int skeychallenge __P((struct skey * mp, char *name, char *ss));
int skeylookup __P((struct skey * mp, char *name));
int skeyverify __P((struct skey * mp, char *response));
int skeyzero __P((struct skey * mp, char *response));
void sevenbit __P((char *s));
void backspace __P((char *s));
char *skipspace __P((char *s));
char *readpass __P((char *buf, int n));
char *readskey __P((char *buf, int n));
int skey_authenticate __P((char *username));
int skey_passcheck __P((char *username, char *passwd));
char *skey_keyinfo __P((char *username));
int skey_haskey __P((char *username));
int getskeyprompt __P((struct skey *mp, char *name, char *prompt));
int atob8 __P((char *out, char *in));
int btoa8 __P((char *out, char *in));
int htoi __P((int c));
d89 6
a94 2
char *skey_set_algorithm __P((char *new));
int skeygetnext __P((struct skey *mp));
@


1.12
log
@Change the random file path, add a sanity check on file size.
@
text
@d15 1
a15 1
 * $OpenBSD: skey.h,v 1.11 1998/07/03 01:08:11 angelos Exp $
d68 1
a68 1
#define _SKEY_RAND_FILE_PATH_	"/etc/host.random"
@


1.11
log
@Remove user existance disclosure through "s/key" challenges.
@
text
@d15 1
a15 1
 * $OpenBSD: skey.h,v 1.10 1997/07/27 21:36:05 millert Exp $
d68 1
a68 1
#define _SKEY_RAND_FILE_PATH_	"/etc/skey.random"
@


1.10
log
@- Do coarse locking on /etc/skeykeys.  Fixes a race that could allow
  a replay attempt to succeed.
- OpenBSD tags
@
text
@d15 1
a15 1
 * $OpenBSD: skey.h,v 1.9 1997/07/23 06:53:12 millert Exp $
d66 3
@


1.9
log
@_PATH_SKEYKEYS now lives in <paths.h>
Add skeygetnext() for iterating over the key file.
@
text
@d11 1
d15 1
a15 1
 * $Id: skey.h,v 1.8 1997/07/23 00:42:26 millert Exp $
@


1.8
log
@Increase max hashname length for rmd160.
@
text
@d14 1
a14 1
 * $Id: skey.h,v 1.7 1996/11/03 18:57:29 millert Exp $
d18 1
a18 2
struct skey
{
d29 1
a29 2
struct mc
{
d90 3
a92 2
const char * skey_get_algorithm __P((void));
char * skey_set_algorithm __P((char *new));
@


1.7
log
@Add a bunch of length/size macros and use them.
@
text
@d14 1
a14 1
 * $Id: skey.h,v 1.6 1996/10/14 03:09:12 millert Exp $
d62 2
a63 2
/* Max length of hash algorithm name (md4/md5/sha1) */
#define SKEY_MAX_HASHNAME_LEN	4
@


1.6
log
@htoi now takes an int, not char.
Only skey_set_algorithm() for the record that matches target user.
@
text
@d14 1
a14 1
 * $Id: skey.h,v 1.5 1996/09/30 04:10:45 millert Exp $
d37 32
@


1.5
log
@__ARGS -> __P (why does everyone have to do this differently?)
@
text
@d14 1
a14 1
 * $Id: skey.h,v 1.4 1996/09/29 21:27:01 millert Exp $
d59 1
a59 1
int htoi __P((char c));
@


1.4
log
@Towards RFC 1938 compliance.  Also, now supports SHA (secure hash algorithm).
@
text
@d14 1
a14 1
 * $Id: skey.h,v 1.3 1996/09/27 15:38:59 millert Exp $
a16 16
#if	defined(__TURBOC__) || defined(__STDC__) || defined(LATTICE)
#define	ANSIPROTO	1
#endif

#ifndef	__ARGS
#ifdef	ANSIPROTO
#define	__ARGS(x)	x
#else
#define	__ARGS(x)	()
#endif
#endif

#ifdef SOLARIS
#define setpriority(x,y,z)      z
#endif

d37 25
a61 25
void f __ARGS ((char *x));
int keycrunch __ARGS ((char *result, char *seed, char *passwd));
char *btoe __ARGS ((char *engout, char *c));
char *put8 __ARGS ((char *out, char *s));
int etob __ARGS ((char *out, char *e));
void rip __ARGS ((char *buf));
int skeychallenge __ARGS ((struct skey * mp, char *name, char *ss));
int skeylookup __ARGS ((struct skey * mp, char *name));
int skeyverify __ARGS ((struct skey * mp, char *response));
int skeyzero __ARGS ((struct skey * mp, char *response));
void sevenbit __ARGS ((char *s));
void backspace __ARGS ((char *s));
char *skipspace __ARGS ((char *s));
char *readpass __ARGS ((char *buf, int n));
char *readskey __ARGS ((char *buf, int n));
int skey_authenticate __ARGS ((char *));
int skey_passcheck __ARGS ((char *, char *));
char *skey_keyinfo __ARGS ((char *));
int skey_haskey __ARGS ((char *));
int getskeyprompt __ARGS ((struct skey *, char *, char *));
int atob8 __ARGS((char *, char *));
int btoa8 __ARGS((char *, char *));
int htoi __ARGS((char));
const char * skey_get_algorithm __ARGS((void));
char * skey_set_algorithm __ARGS((char *));
@


1.3
log
@Deal with both MD4 and MD5 s/key's
@
text
@d14 1
a14 1
 * $Id: skey.h,v 1.2 1995/12/20 09:48:23 deraadt Exp $
d76 2
a77 2
int skey_get_MDX __ARGS(());
int skey_set_MDX __ARGS((int));
@


1.2
log
@add ability to zero out entry; from millert@@cs.colorado.edu; netbsd pr#1851
also add a prototype for skeyzero()
@
text
@d14 1
a14 1
 * $Id: skey.h,v 1.1.1.1 1995/10/18 08:43:11 deraadt Exp $
d36 7
a42 9
  FILE *keyfile;
  char buf[256];
  char *logname;
  int n;
  char *seed;
  char *val;
  long recstart;		/* needed so reread of buffer is efficient */


d48 3
a50 3
  char buf[256];
  int skip;
  int cnt;
d76 2
a77 1

@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
 * $Id: skey.h,v 1.2 1995/06/05 19:48:36 pk Exp $
d64 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
