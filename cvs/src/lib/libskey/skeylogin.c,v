head	1.60;
access;
symbols
	OPENBSD_6_1:1.60.0.2
	OPENBSD_6_1_BASE:1.60
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.57.0.4
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.55.0.6
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.54.0.26
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.54.0.24
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.22
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.20
	OPENBSD_5_0:1.54.0.18
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.54.0.16
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.54.0.14
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.54.0.10
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.54.0.12
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.54.0.8
	OPENBSD_4_5_BASE:1.54
	OPENBSD_4_4:1.54.0.6
	OPENBSD_4_4_BASE:1.54
	OPENBSD_4_3:1.54.0.4
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.54.0.2
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.53.0.4
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.53.0.2
	OPENBSD_4_0_BASE:1.53
	OPENBSD_3_9:1.52.0.8
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.52.0.6
	OPENBSD_3_8_BASE:1.52
	OPENBSD_3_7:1.52.0.4
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.52.0.2
	OPENBSD_3_6_BASE:1.52
	OPENBSD_3_5:1.51.0.2
	OPENBSD_3_5_BASE:1.51
	OPENBSD_3_4:1.50.0.2
	OPENBSD_3_4_BASE:1.50
	OPENBSD_3_3:1.48.0.2
	OPENBSD_3_3_BASE:1.48
	OPENBSD_3_2:1.46.0.2
	OPENBSD_3_2_BASE:1.46
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	OPENBSD_3_0:1.39.0.2
	OPENBSD_3_0_BASE:1.39
	OPENBSD_2_9:1.37.0.2
	OPENBSD_2_9_BASE:1.37
	OPENBSD_2_8:1.35.0.2
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.34.0.2
	OPENBSD_2_7_BASE:1.34
	OPENBSD_2_6:1.32.0.2
	OPENBSD_2_6_BASE:1.32
	OPENBSD_2_5:1.30.0.4
	OPENBSD_2_5_BASE:1.30
	OPENBSD_2_4:1.30.0.2
	OPENBSD_2_4_BASE:1.30
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.60
date	2017.03.20.21.11.21;	author tb;	state Exp;
branches;
next	1.59;
commitid	iymPJkmeBwkR9FqO;

1.59
date	2017.03.20.18.34.52;	author tedu;	state Exp;
branches;
next	1.58;
commitid	e6NoKZGTal7rDyck;

1.58
date	2016.03.17.21.36.48;	author krw;	state Exp;
branches;
next	1.57;
commitid	idWTuX14jOpqz25n;

1.57
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	6b2lLILbgCR1fvia;

1.56
date	2015.01.16.16.48.52;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	0DYulI8hhujBHMcR;

1.55
date	2013.11.29.19.00.51;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2007.03.20.03.40.06;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2006.04.10.08.06.08;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2004.08.05.13.31.36;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.21.23.35.24;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2003.04.28.20.59.13;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2003.04.03.17.48.50;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.11.16.22.54.46;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2002.11.16.22.31.55;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.22.02.13.10;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.24.21.32.56;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.17.15.51.06;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.16.17.09.01;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.16.03.50.42;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.16.21.27.28;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2001.12.07.05.09.33;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.23.21.42.39;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.20.22.15.45;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.04.21.51.52;	author todd;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.20.23.46.39;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.23.17.29.41;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	99.12.06.19.04.58;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	99.11.26.19.26.17;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	99.08.16.14.46.56;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	99.08.16.10.34.48;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	98.07.05.19.47.16;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	98.07.05.19.41.35;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	98.07.03.02.06.22;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	98.07.03.02.02.01;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	98.07.03.01.38.04;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	98.07.03.01.32.49;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	98.07.03.01.08.13;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	98.02.24.20.52.48;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	97.09.12.20.47.39;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.09.04.18.19.47;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.07.27.22.11.41;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.07.27.21.36.05;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.07.27.21.20.27;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.07.26.19.48.19;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.07.26.19.42.46;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.07.23.07.16.57;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.07.23.06.53.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.07.23.03.52.12;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.07.10.21.11.11;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.11.03.18.57.29;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	96.10.22.01.41.25;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.10.14.03.09.13;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.10.02.03.49.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.09.30.04.10.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.09.29.23.35.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.29.21.27.01;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.29.04.30.39;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.27.15.38.59;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	95.12.20.09.48.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.60
log
@Generate the bogus challenge using arc4random_buf(3) instead of reading
directly from /var/db/host.random and falling back to ctime. Remove the
_SKEY_RAND_FILE_PATH_ since it's no longer needed.

ok millert, mestre
@
text
@/* OpenBSD S/Key (skeylogin.c)
 *
 * Authors:
 *          Neil M. Haller <nmh@@thumper.bellcore.com>
 *          Philip R. Karn <karn@@chicago.qualcomm.com>
 *          John S. Walden <jsw@@thumper.bellcore.com>
 *          Scott Chasin <chasin@@crimelab.com>
 *          Todd C. Miller <Todd.Miller@@courtesan.com>
 *	    Angelos D. Keromytis <adk@@adk.gr>
 *
 * S/Key verification check, lookups, and authentication.
 *
 * $OpenBSD: skeylogin.c,v 1.59 2017/03/20 18:34:52 tedu Exp $
 */

#ifdef	QUOTA
#include <sys/quota.h>
#endif
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <sha1.h>

#include "skey.h"

static void skey_fakeprompt(char *, char *);
static char *tgetline(int, char *, size_t, int);
static int skeygetent(int, struct skey *, const char *);

/*
 * Return an skey challenge string for user 'name'. If successful,
 * fill in the caller's skey structure and return (0). If unsuccessful
 * (e.g., if name is unknown) return (-1).
 *
 * The file read/write pointer is left at the start of the record.
 */
int
skeychallenge2(int fd, struct skey *mp, char *name, char *ss)
{
	int rval;

	memset(mp, 0, sizeof(*mp));
	rval = skeygetent(fd, mp, name);

	switch (rval) {
	case 0:		/* Lookup succeeded, return challenge */
		(void)snprintf(ss, SKEY_MAX_CHALLENGE,
		    "otp-%.*s %d %.*s", SKEY_MAX_HASHNAME_LEN,
		    skey_get_algorithm(), mp->n - 1,
		    SKEY_MAX_SEED_LEN, mp->seed);
		return (0);

	case 1:		/* User not found */
		if (mp->keyfile) {
			(void)fclose(mp->keyfile);
			mp->keyfile = NULL;
		}
		/* FALLTHROUGH */

	default:	/* File error */
		skey_fakeprompt(name, ss);
		return (-1);
	}
}

int
skeychallenge(struct skey *mp, char *name, char *ss)
{
	return (skeychallenge2(-1, mp, name, ss));
}

/*
 * Get an entry in the One-time Password database and lock it.
 *
 * Return codes:
 * -1: error in opening database or unable to lock entry
 *  0: entry found, file R/W pointer positioned at beginning of record
 *  1: entry not found
 */
static int
skeygetent(int fd, struct skey *mp, const char *name)
{
	char *cp, filename[PATH_MAX], *last;
	struct stat statbuf;
	const char *errstr;
	size_t nread;
	FILE *keyfile;

	/* Check to see that /etc/skey has not been disabled. */
	if (stat(_PATH_SKEYDIR, &statbuf) != 0)
		return (-1);
	if ((statbuf.st_mode & ALLPERMS) == 0) {
		errno = EPERM;
		return (-1);
	}

	if (fd == -1) {
		/* Open the user's databse entry, creating it as needed. */
		if (snprintf(filename, sizeof(filename), "%s/%s", _PATH_SKEYDIR,
		    name) >= sizeof(filename)) {
			errno = ENAMETOOLONG;
			return (-1);
		}
		if ((fd = open(filename, O_RDWR | O_NOFOLLOW | O_NONBLOCK,
		    S_IRUSR | S_IWUSR)) == -1) {
			if (errno == ENOENT)
				goto not_found;
			return (-1);
		}
	}

	/* Lock and stat the user's skey file. */
	if (flock(fd, LOCK_EX) != 0 || fstat(fd, &statbuf) != 0) {
		close(fd);
		return (-1);
	}
	if (statbuf.st_size == 0)
		goto not_found;

	/* Sanity checks. */
	if ((statbuf.st_mode & ALLPERMS) != (S_IRUSR | S_IWUSR) ||
	    !S_ISREG(statbuf.st_mode) || statbuf.st_nlink != 1 ||
	    (keyfile = fdopen(fd, "r+")) == NULL) {
		close(fd);
		return (-1);
	}

	/* At this point, we are committed. */
	mp->keyfile = keyfile;

	if ((nread = fread(mp->buf, 1, sizeof(mp->buf), keyfile)) == 0 ||
	    !isspace((unsigned char)mp->buf[nread - 1]))
		goto bad_keyfile;
	mp->buf[nread - 1] = '\0';

	if ((mp->logname = strtok_r(mp->buf, " \t\n\r", &last)) == NULL ||
	    strcmp(mp->logname, name) != 0)
		goto bad_keyfile;
	if ((cp = strtok_r(NULL, " \t\n\r", &last)) == NULL)
		goto bad_keyfile;
	if (skey_set_algorithm(cp) == NULL)
		goto bad_keyfile;
	if ((cp = strtok_r(NULL, " \t\n\r", &last)) == NULL)
		goto bad_keyfile;
	mp->n = strtonum(cp, 0, UINT_MAX, &errstr);
	if (errstr)
		goto bad_keyfile;
	if ((mp->seed = strtok_r(NULL, " \t\n\r", &last)) == NULL)
		goto bad_keyfile;
	if ((mp->val = strtok_r(NULL, " \t\n\r", &last)) == NULL)
		goto bad_keyfile;

	(void)fseek(keyfile, 0L, SEEK_SET);
	return (0);

    bad_keyfile:
	fclose(keyfile);
	return (-1);

    not_found:
	/* No existing entry, fill in what we can and return */
	memset(mp, 0, sizeof(*mp));
	strlcpy(mp->buf, name, sizeof(mp->buf));
	mp->logname = mp->buf;
	if (fd != -1)
		close(fd);
	return (1);
}

/*
 * Look up an entry in the One-time Password database and lock it.
 * Zeroes out the passed in struct skey before using it.
 *
 * Return codes:
 * -1: error in opening database or unable to lock entry
 *  0: entry found, file R/W pointer positioned at beginning of record
 *  1: entry not found
 */
int
skeylookup(struct skey *mp, char *name)
{
	memset(mp, 0, sizeof(*mp));
	return (skeygetent(-1, mp, name));
}

/*
 * Get the next entry in the One-time Password database.
 *
 * Return codes:
 * -1: error in opening database
 *  0: next entry found and stored in mp
 *  1: no more entries, keydir is closed.
 */
int
skeygetnext(struct skey *mp)
{
	struct dirent entry, *dp;
	int rval;

	if (mp->keyfile != NULL) {
		fclose(mp->keyfile);
		mp->keyfile = NULL;
	}

	/* Open _PATH_SKEYDIR if it exists, else return an error */
	if (mp->keydir == NULL && (mp->keydir = opendir(_PATH_SKEYDIR)) == NULL)
		return (-1);

	rval = 1;
	while ((readdir_r(mp->keydir, &entry, &dp)) == 0 && dp == &entry) {
		/* Skip dot files and zero-length files. */
		if (entry.d_name[0] != '.' &&
		    (rval = skeygetent(-1, mp, entry.d_name)) != 1)
			break;
	}

	if (dp == NULL) {
		closedir(mp->keydir);
		mp->keydir = NULL;
	}

	return (rval);
}

/*
 * Verify response to a S/Key challenge.
 *
 * Return codes:
 * -1: Error of some sort; database unchanged
 *  0:  Verify successful, database updated
 *  1:  Verify failed, database unchanged
 *
 * The database file is always closed by this call.
 */
int
skeyverify(struct skey *mp, char *response)
{
	char key[SKEY_BINKEY_SIZE], fkey[SKEY_BINKEY_SIZE];
	char filekey[SKEY_BINKEY_SIZE], *cp, *last;
	size_t nread;

	if (response == NULL)
		goto verify_failure;

	/*
	 * The record should already be locked but lock it again
	 * just to be safe.  We don't wait for the lock to become
	 * available since we should already have it...
	 */
	if (flock(fileno(mp->keyfile), LOCK_EX | LOCK_NB) != 0)
		goto verify_failure;

	/* Convert response to binary */
	rip(response);
	if (etob(key, response) != 1 && atob8(key, response) != 0)
		goto verify_failure; /* Neither english words nor ascii hex */

	/* Compute fkey = f(key) */
	(void)memcpy(fkey, key, sizeof(key));
	f(fkey);

	/*
	 * Reread the file record NOW in case it has been modified.
	 * The only field we really need to worry about is mp->val.
	 */
	(void)fseek(mp->keyfile, 0L, SEEK_SET);
	if ((nread = fread(mp->buf, 1, sizeof(mp->buf), mp->keyfile)) == 0 ||
	    !isspace((unsigned char)mp->buf[nread - 1]))
		goto verify_failure;
	if ((mp->logname = strtok_r(mp->buf, " \t\r\n", &last)) == NULL)
		goto verify_failure;
	if ((cp = strtok_r(NULL, " \t\r\n", &last)) == NULL)
		goto verify_failure;
	if ((cp = strtok_r(NULL, " \t\r\n", &last)) == NULL)
		goto verify_failure;
	if ((mp->seed = strtok_r(NULL, " \t\r\n", &last)) == NULL)
		goto verify_failure;
	if ((mp->val = strtok_r(NULL, " \t\r\n", &last)) == NULL)
		goto verify_failure;

	/* Convert file value to hex and compare. */
	atob8(filekey, mp->val);
	if (memcmp(filekey, fkey, SKEY_BINKEY_SIZE) != 0)
		goto verify_failure;	/* Wrong response */

	/*
	 * Update key in database.
	 * XXX - check return values of things that write to disk.
	 */
	btoa8(mp->val,key);
	mp->n--;
	(void)fseek(mp->keyfile, 0L, SEEK_SET);
	(void)fprintf(mp->keyfile, "%s\n%s\n%d\n%s\n%s\n", mp->logname,
	    skey_get_algorithm(), mp->n, mp->seed, mp->val);
	(void)fflush(mp->keyfile);
	(void)ftruncate(fileno(mp->keyfile), ftello(mp->keyfile));
	(void)fclose(mp->keyfile);
	mp->keyfile = NULL;
	return (0);

    verify_failure:
	(void)fclose(mp->keyfile);
	mp->keyfile = NULL;
	return (-1);
}

/*
 * skey_haskey()
 *
 * Returns: 1 user doesn't exist, -1 file error, 0 user exists.
 *
 */
int
skey_haskey(char *username)
{
	struct skey skey;
	int i;

	i = skeylookup(&skey, username);
	if (skey.keyfile != NULL) {
		fclose(skey.keyfile);
		skey.keyfile = NULL;
	}
	return (i);
}

/*
 * skey_keyinfo()
 *
 * Returns the current sequence number and
 * seed for the passed user.
 *
 */
char *
skey_keyinfo(char *username)
{
	static char str[SKEY_MAX_CHALLENGE];
	struct skey skey;
	int i;

	i = skeychallenge(&skey, username, str);
	if (i == -1)
		return (0);

	if (skey.keyfile != NULL) {
		fclose(skey.keyfile);
		skey.keyfile = NULL;
	}
	return (str);
}

/*
 * skey_passcheck()
 *
 * Check to see if answer is the correct one to the current
 * challenge.
 *
 * Returns: 0 success, -1 failure
 *
 */
int
skey_passcheck(char *username, char *passwd)
{
	struct skey skey;
	int i;

	i = skeylookup(&skey, username);
	if (i == -1 || i == 1)
		return (-1);

	if (skeyverify(&skey, passwd) == 0)
		return (skey.n);

	return (-1);
}

#define ROUND(x)   (((x)[0] << 24) + (((x)[1]) << 16) + (((x)[2]) << 8) + \
		    ((x)[3]))

/*
 * hash_collapse()
 */
static u_int32_t
hash_collapse(u_char *s)
{
	int len, target;
	u_int32_t i;

	if ((strlen(s) % sizeof(u_int32_t)) == 0)
		target = strlen(s);    /* Multiple of 4 */
	else
		target = strlen(s) - (strlen(s) % sizeof(u_int32_t));

	for (i = 0, len = 0; len < target; len += 4)
		i ^= ROUND(s + len);

	return i;
}

/*
 * skey_fakeprompt()
 *
 * Generate a fake prompt for the specified user.
 *
 */
static void
skey_fakeprompt(char *username, char *skeyprompt)
{
	char secret[SKEY_MAX_SEED_LEN], pbuf[SKEY_MAX_PW_LEN+1], *p, *u;
	u_char *up;
	SHA1_CTX ctx;
	u_int ptr;
	int i;

	/*
	 * Base first 4 chars of seed on hostname.
	 * Add some filler for short hostnames if necessary.
	 */
	if (gethostname(pbuf, sizeof(pbuf)) == -1)
		*(p = pbuf) = '.';
	else
		for (p = pbuf; isalnum((unsigned char)*p); p++)
			if (isalpha((unsigned char)*p) &&
			    isupper((unsigned char)*p))
				*p = (char)tolower((unsigned char)*p);
	if (*p && pbuf - p < 4)
		(void)strncpy(p, "asjd", 4 - (pbuf - p));
	pbuf[4] = '\0';

	/* Hash the username if possible */
	if ((up = SHA1Data(username, strlen(username), NULL)) != NULL) {
		/* Collapse the hash */
		ptr = hash_collapse(up);
		explicit_bzero(up, strlen(up));

		/* Put that in your pipe and smoke it */
		arc4random_buf(secret, sizeof(secret));

		/* Hash secret value with username */
		SHA1Init(&ctx);
		SHA1Update(&ctx, secret, sizeof(secret));
		SHA1Update(&ctx, username, strlen(username));
		SHA1End(&ctx, up);

		/* Zero out */
		explicit_bzero(secret, sizeof(secret));

		/* Now hash the hash */
		SHA1Init(&ctx);
		SHA1Update(&ctx, up, strlen(up));
		SHA1End(&ctx, up);

		ptr = hash_collapse(up + 4);

		for (i = 4; i < 9; i++) {
			pbuf[i] = (ptr % 10) + '0';
			ptr /= 10;
		}
		pbuf[i] = '\0';

		/* Sequence number */
		ptr = ((up[2] + up[3]) % 99) + 1;

		explicit_bzero(up, 20); /* SHA1 specific */
		free(up);

		(void)snprintf(skeyprompt, SKEY_MAX_CHALLENGE,
		    "otp-%.*s %d %.*s", SKEY_MAX_HASHNAME_LEN,
		    skey_get_algorithm(), ptr, SKEY_MAX_SEED_LEN, pbuf);
	} else {
		/* Base last 8 chars of seed on username */
		u = username;
		i = 8;
		p = &pbuf[4];
		do {
			if (*u == 0) {
				/* Pad remainder with zeros */
				while (--i >= 0)
					*p++ = '0';
				break;
			}

			*p++ = (*u++ % 10) + '0';
		} while (--i != 0);
		pbuf[12] = '\0';

		(void)snprintf(skeyprompt, SKEY_MAX_CHALLENGE,
		    "otp-%.*s %d %.*s", SKEY_MAX_HASHNAME_LEN,
		    skey_get_algorithm(), 99, SKEY_MAX_SEED_LEN, pbuf);
	}
}

/*
 * skey_authenticate()
 *
 * Used when calling program will allow input of the user's
 * response to the challenge.
 *
 * Returns: 0 success, -1 failure
 *
 */
int
skey_authenticate(char *username)
{
	char pbuf[SKEY_MAX_PW_LEN+1], skeyprompt[SKEY_MAX_CHALLENGE+1];
	struct skey skey;
	int i;

	/* Get the S/Key challenge (may be fake) */
	i = skeychallenge(&skey, username, skeyprompt);
	(void)fprintf(stderr, "%s\nResponse: ", skeyprompt);
	(void)fflush(stderr);

	/* Time out on user input after 2 minutes */
	tgetline(fileno(stdin), pbuf, sizeof(pbuf), 120);
	sevenbit(pbuf);
	(void)rewind(stdin);

	/* Is it a valid response? */
	if (i == 0 && skeyverify(&skey, pbuf) == 0) {
		if (skey.n < 5) {
			(void)fprintf(stderr,
			    "\nWarning! Key initialization needed soon.  (%d logins left)\n",
			    skey.n);
		}
		return (0);
	}
	return (-1);
}

/*
 * Unlock current entry in the One-time Password database.
 *
 * Return codes:
 * -1: unable to lock the record
 *  0: record was successfully unlocked
 */
int
skey_unlock(struct skey *mp)
{
	if (mp->logname == NULL || mp->keyfile == NULL)
		return (-1);

	return (flock(fileno(mp->keyfile), LOCK_UN));
}

/*
 * Get a line of input (optionally timing out) and place it in buf.
 */
static char *
tgetline(int fd, char *buf, size_t bufsiz, int timeout)
{
	struct pollfd pfd[1];
	size_t left;
	char c, *cp;
	ssize_t ss;
	int n;

	if (bufsiz == 0)
		return (NULL);			/* sanity */

	cp = buf;
	left = bufsiz;

	/*
	 * Timeout of <= 0 means no timeout.
	 */
	if (timeout > 0) {
		timeout *= 1000;		/* convert to milliseconds */

		pfd[0].fd = fd;
		pfd[0].events = POLLIN;
		while (--left) {
			/* Poll until we are ready or we time out */
			while ((n = poll(pfd, 1, timeout)) == -1 &&
			    (errno == EINTR || errno == EAGAIN))
				;
			if (n <= 0 ||
			    (pfd[0].revents & (POLLERR|POLLHUP|POLLNVAL)))
				break;		/* timeout or error */

			/* Read a character, exit loop on error, EOF or EOL */
			ss = read(fd, &c, 1);
			if (ss != 1 || c == '\n' || c == '\r')
				break;
			*cp++ = c;
		}
	} else {
		/* Keep reading until out of space, EOF, error, or newline */
		while (--left && read(fd, &c, 1) == 1 && c != '\n' && c != '\r')
			*cp++ = c;
	}
	*cp = '\0';

	return (cp == buf ? NULL : buf);
}
@


1.59
log
@use explicit_bzero. one from Ricardo Mestre plus two more.
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.58 2016/03/17 21:36:48 krw Exp $
d422 2
a423 3
	char hseed[SKEY_MAX_SEED_LEN], *secret, pbuf[SKEY_MAX_PW_LEN+1], *p, *u;
	u_char flg = 1, *up;
	size_t secretlen;
a444 4
		struct stat sb;
		time_t t;
		int fd;

d449 2
a450 21
		/* See if the random file's there, else use ctime */
		if ((fd = open(_SKEY_RAND_FILE_PATH_, O_RDONLY)) != -1 &&
		    fstat(fd, &sb) == 0 &&
		    sb.st_size > (off_t)SKEY_MAX_SEED_LEN &&
		    lseek(fd, ptr % (sb.st_size - SKEY_MAX_SEED_LEN),
		    SEEK_SET) != -1 && read(fd, hseed,
		    SKEY_MAX_SEED_LEN) == SKEY_MAX_SEED_LEN) {
			close(fd);
			fd = -1;
			secret = hseed;
			secretlen = SKEY_MAX_SEED_LEN;
			flg = 0;
		} else if (!stat(_PATH_MEM, &sb) || !stat("/", &sb)) {
			t = sb.st_ctime;
			secret = ctime(&t);
			secretlen = strlen(secret);
			flg = 0;
		}
		if (fd != -1)
			close(fd);
	}
a451 2
	/* Put that in your pipe and smoke it */
	if (flg == 0) {
d454 1
a454 1
		SHA1Update(&ctx, secret, secretlen);
d459 1
a459 1
		explicit_bzero(secret, secretlen);
@


1.58
log
@'miliseconds' -> 'milliseconds' in comments.

if_atu.c noted by Michal Mazurek.
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.57 2015/04/18 18:28:37 deraadt Exp $
d452 1
a452 1
		memset(up, 0, strlen(up));
d485 1
a485 1
		memset(secret, 0, secretlen);
d503 1
a503 1
		memset(up, 0, 20); /* SHA1 specific */
@


1.57
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.56 2015/01/16 16:48:52 deraadt Exp $
d608 1
a608 1
		timeout *= 1000;		/* convert to miliseconds */
@


1.56
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.55 2013/11/29 19:00:51 deraadt Exp $
d98 1
d158 3
a160 1
	mp->n = atoi(cp);	/* XXX - use strtol() */
@


1.55
log
@fairly simple unsigned char casts for ctype
ok krw
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.54 2007/03/20 03:40:06 tedu Exp $
a15 1
#include <sys/param.h>
d34 1
@


1.54
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.53 2006/04/10 08:06:08 deraadt Exp $
d144 1
a144 1
	    !isspace(mp->buf[nread - 1]))
d278 1
a278 1
	    !isspace(mp->buf[nread - 1]))
d433 4
a436 3
		for (p = pbuf; isalnum(*p); p++)
			if (isalpha(*p) && isupper(*p))
				*p = (char)tolower(*p);
@


1.53
log
@minimal cleanups lint begs for
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.52 2004/08/05 13:31:36 millert Exp $
d433 1
a433 1
		for (p = pbuf; *p && isalnum(*p); p++)
@


1.52
log
@Add skeychallenge2() which is like skeychallenge() but takes an
already open fd.  Will be used to make separate challenge/response
invocations of login_skey keep the record locked.  Also properly
escape minus signs in man page.  OK henning@@ jmc@@
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.51 2003/09/21 23:35:24 millert Exp $
d62 2
a63 2
			      skey_get_algorithm(), mp->n - 1,
			      SKEY_MAX_SEED_LEN, mp->seed);
d96 1
a98 1
	char *cp, filename[PATH_MAX], *last;
d248 2
a249 3
	char key[SKEY_BINKEY_SIZE];
	char fkey[SKEY_BINKEY_SIZE];
	char filekey[SKEY_BINKEY_SIZE];
a250 1
	char *cp, *last;
a346 1
	int i;
d349 1
d374 1
a375 1
	struct skey skey;
d400 1
a400 1
  		target = strlen(s);    /* Multiple of 4 */
d419 2
a420 5
	int i;
	u_int ptr;
	u_char hseed[SKEY_MAX_SEED_LEN], flg = 1, *up;
	char *secret, pbuf[SKEY_MAX_PW_LEN+1];
	char *p, *u;
d423 2
d435 1
a435 1
				*p = tolower(*p);
d451 2
a452 2
		if ((fd = open(_SKEY_RAND_FILE_PATH_, O_RDONLY)) != -1
		    && fstat(fd, &sb) == 0 &&
a539 1
	int i;
d542 1
d591 1
d618 2
a619 2
			n = read(fd, &c, 1);
			if (n != 1 || c == '\n' || c == '\r')
d625 1
a625 1
		while (--left && (n = read(fd, &c, 1)) == 1 && c != '\n' && c != '\r')
@


1.51
log
@convert tgetline() from select(2) -> poll(2)
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.50 2003/04/28 20:59:13 millert Exp $
d41 1
a41 1
static int skeygetent(struct skey *, const char *);
d48 1
a48 2
 * The file read/write pointer is left at the start of the
 * record.
d51 1
a51 1
skeychallenge(struct skey *mp, char *name, char *ss)
d55 3
a57 1
	rval = skeylookup(mp, name);
d79 6
d94 1
a94 1
skeygetent(struct skey *mp, const char *name)
a99 1
	int fd;
d109 13
a121 12
	/* Open the user's databse entry, creating it as needed. */
	/* XXX - really want "/etc/skey/L/USER" where L is 1st char of USER */
	if (snprintf(filename, sizeof(filename), "%s/%s", _PATH_SKEYDIR,
	    name) >= sizeof(filename)) {
		errno = ENAMETOOLONG;
		return (-1);
	}
	if ((fd = open(filename, O_RDWR | O_NOFOLLOW | O_NONBLOCK,
	    S_IRUSR | S_IWUSR)) == -1) {
		if (errno == ENOENT)
			goto not_found;
		return (-1);
d193 1
a193 1
	return (skeygetent(mp, name));
d223 1
a223 1
		    (rval = skeygetent(mp, entry.d_name)) != 1)
@


1.50
log
@fix skeygetnext()
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.49 2003/04/03 17:48:50 millert Exp $
d29 1
d584 1
d586 1
a587 4
	fd_set *readfds = NULL;
	struct timeval tv;
	char c;
	char *cp;
d599 1
a599 9
		/* Setup for select(2) */
		n = howmany(fd + 1, NFDBITS) * sizeof(fd_mask);
		if ((readfds = (fd_set *) malloc(n)) == NULL)
			return (NULL);
		(void) memset(readfds, 0, n);

		/* Set timeout for select */
		tv.tv_sec = timeout;
		tv.tv_usec = 0;
d601 2
d604 2
a605 4
			FD_SET(fd, readfds);

			/* Make sure there is something to read (or timeout) */
			while ((n = select(fd + 1, readfds, 0, 0, &tv)) == -1 &&
d608 3
a610 4
			if (n == 0) {
				free(readfds);
				return (NULL);		/* timeout */
			}
a617 1
		free(readfds);
@


1.49
log
@Use snprintf() and strlcpy() throughout.
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.48 2002/11/16 22:54:46 millert Exp $
d40 1
d78 1
a78 1
 * Find an entry in the One-time Password database and lock it.
d85 2
a86 2
int
skeylookup(struct skey *mp, char *name)
a93 2
	memset(mp, 0, sizeof(*mp));

d173 16
d215 1
a215 1
		    (rval = skeylookup(mp, entry.d_name) != 1))
d217 1
a217 1
	};
@


1.48
log
@Zero out struct skey early in skeylookup() so callers can reliably check
for keyfile == NULL and not get a garbage value.
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.47 2002/11/16 22:31:55 millert Exp $
d50 1
a50 4
skeychallenge(mp, name, ss)
	struct skey *mp;
	char *name;
	char *ss;
d85 1
a85 3
skeylookup(mp, name)
	struct skey *mp;
	char *name;
d182 1
a182 2
skeygetnext(mp)
	struct skey *mp;
d223 1
a223 3
skeyverify(mp, response)
	struct skey *mp;
	char *response;
d303 1
a303 2
skey_haskey(username)
	char *username;
d324 1
a324 2
skey_keyinfo(username)
	char *username;
d351 1
a351 3
skey_passcheck(username, passwd)
	char *username;
	char *passwd;
d373 1
a373 2
hash_collapse(s)
	u_char *s;
d396 1
a396 3
skey_fakeprompt(username, skeyprompt)
	char *username;
	char *skeyprompt;
d518 1
a518 2
skey_authenticate(username)
	char *username;
d554 1
a554 2
skey_unlock(mp)
	struct skey *mp;
d566 1
a566 5
tgetline(fd, buf, bufsiz, timeout)
	int fd;
	char *buf;
	size_t bufsiz;
	int timeout;
@


1.47
log
@Add a missing check for NULL keyfile in skeychallenge() that
caused a user w/o an S/Key to just get "permission denied" from
login_skey instead of a fake challenge.
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.46 2002/06/22 02:13:10 deraadt Exp $
d98 2
a109 1
	mp->keyfile = NULL;
a138 1
	memset(mp, 0, sizeof(*mp));
@


1.46
log
@use strtok_r() instead of strtok(); millert ok
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.45 2002/05/24 21:32:56 deraadt Exp $
d67 4
a70 2
		(void)fclose(mp->keyfile);
		mp->keyfile = NULL;
@


1.45
log
@enforce SKEY_MAX_CHALLENGE using snprintf()
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.44 2002/05/17 15:51:06 millert Exp $
d92 1
a92 1
	char *cp, filename[PATH_MAX];
d144 1
a144 1
	if ((mp->logname = strtok(mp->buf, " \t\n\r")) == NULL ||
d147 1
a147 1
	if ((cp = strtok(NULL, " \t\n\r")) == NULL)
d151 1
a151 1
	if ((cp = strtok(NULL, " \t\n\r")) == NULL)
d154 1
a154 1
	if ((mp->seed = strtok(NULL, " \t\n\r")) == NULL)
d156 1
a156 1
	if ((mp->val = strtok(NULL, " \t\n\r")) == NULL)
d235 1
a235 1
	char *cp;
d265 1
a265 1
	if ((mp->logname = strtok(mp->buf, " \t\r\n")) == NULL)
d267 1
a267 1
	if ((cp = strtok(NULL, " \t\r\n")) == NULL)
d269 1
a269 1
	if ((cp = strtok(NULL, " \t\r\n")) == NULL)
d271 1
a271 1
	if ((mp->seed = strtok(NULL, " \t\r\n")) == NULL)
d273 1
a273 1
	if ((mp->val = strtok(NULL, " \t\r\n")) == NULL)
@


1.44
log
@Remove skeyzero(), it is no longer needed.
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.43 2002/05/16 17:09:01 millert Exp $
d60 2
a61 1
		(void)sprintf(ss, "otp-%.*s %d %.*s", SKEY_MAX_HASHNAME_LEN,
d495 3
a497 6
		(void)sprintf(skeyprompt,
			      "otp-%.*s %d %.*s",
			      SKEY_MAX_HASHNAME_LEN,
			      skey_get_algorithm(),
			      ptr, SKEY_MAX_SEED_LEN,
			      pbuf);
d515 3
a517 4
		(void)sprintf(skeyprompt, "otp-%.*s %d %.*s",
			      SKEY_MAX_HASHNAME_LEN,
			      skey_get_algorithm(),
			      99, SKEY_MAX_SEED_LEN, pbuf);
@


1.43
log
@Check for disabled /etc/skey directory (mode 0000).  This is needed
because some things (such as login) run as uid 0 and directory modes
won't restrict root.
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.42 2002/05/16 03:50:42 millert Exp $
a560 27
}

/*
 * Comment out user's entry in the S/Key database
 *
 * Return codes:
 * -1: Write error; database unchanged
 *  0:  Database updated
 *
 * The database file is always closed by this call.
 * XXX - do we still need this function?
 */
int
skeyzero(mp)
	struct skey *mp;
{
	int rval;

	/*
	 * We truncate the file rather than unlinking it since we
	 * may not have write perms on the directory.
	 */
	fflush(mp->keyfile);
	rval = ftruncate(fileno(mp->keyfile), (off_t)0);
	(void)fclose(mp->keyfile);
	mp->keyfile = NULL;
	return (rval);
@


1.42
log
@Change S/Key stuff from using a flat file (/etc/skeykeys) to a directory
where each user gets their own file, which is owned by that user.

An old S/Key database may be converted by running "skeyinit -C" as root.

Programs that need to access the S/Key database no longer need to be
setuid root.  They must now be setgid auth instead.
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.41 2002/02/16 21:27:28 millert Exp $
d95 8
d104 1
a104 1
	/* XXX - really want "/etc/skeys/L/USER" where L is 1st char of USER */
d287 1
a287 1
	(void)fprintf(mp->keyfile, "%s\n%s\n%04d\n%s\n%s\n", mp->logname,
@


1.41
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d12 2
a13 2
 * 
 * $OpenBSD: skeylogin.c,v 1.40 2001/12/07 05:09:33 millert Exp $
a22 1
#include <sys/types.h>
d43 2
a44 2
 * fill in the caller's skey structure and return(0). If unsuccessful
 * (e.g., if name is unknown) return(-1).
d63 1
a63 1
		return(0);
d72 1
a72 1
		return(-1);
d76 1
a76 1
/* 
d82 1
a82 1
 *  1: entry not found, file R/W pointer positioned at EOF
d89 3
d93 1
a93 6
	int rval;
	int locked = 0;
	long recstart = 0;
	char *cp, *ht = NULL;
	struct stat statbuf;
	struct flock fl;
d95 29
a123 8
	/* Open _PATH_SKEYKEYS if it exists, else return an error */
	if (stat(_PATH_SKEYKEYS, &statbuf) == 0 &&
	    (keyfile = mp->keyfile = fopen(_PATH_SKEYKEYS, "r+")) != NULL) {
		if ((statbuf.st_mode & 0007777) != 0600)
			fchmod(fileno(keyfile), 0600);
	} else {
		mp->keyfile = NULL;
		return(-1);
d126 3
a128 54
	/* Look up user name in database */
	while (!feof(keyfile)) {
		mp->recstart = recstart = ftell(keyfile);
		if (fgets(mp->buf, sizeof(mp->buf), keyfile) == NULL)
			break;
		if (mp->buf[0] == '#')
			continue;	/* Comment */
		mp->len = strlen(mp->buf);
		cp = mp->buf + mp->len - 1;
		while (cp >= mp->buf && (*cp == '\n' || *cp == '\r'))
			*cp-- = '\0';
		if ((mp->logname = strtok(mp->buf, " \t")) == NULL ||
		    strcmp(mp->logname, name) != 0)
			continue;
		if ((cp = strtok(NULL, " \t")) == NULL)
			continue;
		/* Save hash type if specified, else use md4 */
		if (isalpha(*cp)) {
			ht = cp;
			if ((cp = strtok(NULL, " \t")) == NULL)
				continue;
		} else {
			ht = "md4";
		}
		mp->n = atoi(cp);
		if ((mp->seed = strtok(NULL, " \t")) == NULL)
			continue;
		if ((mp->val = strtok(NULL, " \t")) == NULL)
			continue;

		/* Set hash type */
		if (ht && skey_set_algorithm(ht) == NULL) {
			warnx("Unknown hash algorithm %s, using %s", ht,
			      skey_get_algorithm());
		}
		(void)fseek(keyfile, recstart, SEEK_SET);

		/* If we already aquired the lock we are done */
		if (locked)
			return(0);

		/* Ortherwise, we must lock the record */
		fl.l_start = mp->recstart;
		fl.l_len = mp->len;
		fl.l_pid = getpid();
		fl.l_type = F_WRLCK;
		fl.l_whence = SEEK_SET;

		/* If we get the lock on the first try we are done */
		rval = fcntl(fileno(mp->keyfile), F_SETLK, &fl);
		if (rval == 0)
			return(0);
		else if (errno != EAGAIN)
			break;
d130 26
a155 9
		/*
		 * Wait until we our lock is granted...
		 * Since we didn't get the lock on the first try, someone
		 * else may have modified the record.  We need to make
		 * sure the entry hasn't changed name (it could have been
		 * commented out) and re-read it.
		 */
		if (fcntl(fileno(mp->keyfile), F_SETLKW, &fl) == -1)
			break;
d157 2
a158 13
		rval = fread(mp->logname, fl.l_len, 1, mp->keyfile);
		if (rval != fl.l_len ||
		    memcmp(mp->logname, name, rval) != 0) {
			/* username no longer matches so unlock */
			fl.l_type = F_UNLCK;
			fcntl(fileno(mp->keyfile), F_SETLK, &fl);
		} else {
			locked = 1;
		}
		(void)fseek(keyfile, recstart, SEEK_SET);
	}

	/* No entry found, fill in what we can... */
d162 3
a164 4
	mp->len = strlen(mp->buf);
	mp->keyfile = keyfile;
	mp->recstart = ftell(keyfile);
	return(1);
d173 1
a173 1
 *  1: no more entries, file R/W pointer positioned at EOF
d179 1
a180 4
	int locked = 0;
	char *cp;
	struct stat statbuf;
	struct flock fl;
d182 3
a184 18
	/* Open _PATH_SKEYKEYS if it exists, else return an error */
	if (mp->keyfile == NULL) {
		if (stat(_PATH_SKEYKEYS, &statbuf) == 0 &&
		    (mp->keyfile = fopen(_PATH_SKEYKEYS, "r+")) != NULL) {
			if ((statbuf.st_mode & 0007777) != 0600)
				fchmod(fileno(mp->keyfile), 0600);
		} else {
			return(-1);
		}
	} else {
		/* Unlock existing record */
		fl.l_start = mp->recstart;
		fl.l_len = mp->len;
		fl.l_pid = getpid();
		fl.l_type = F_UNLCK;
		fl.l_whence = SEEK_SET;

		fcntl(fileno(mp->keyfile), F_SETLK, &fl);
d187 9
a195 4
	/* Look up next user in database */
	while (!feof(mp->keyfile)) {
		mp->recstart = ftell(mp->keyfile);
		if (fgets(mp->buf, sizeof(mp->buf), mp->keyfile) != mp->buf)
d197 1
a197 20
		if (mp->buf[0] == '#')
			continue;	/* Comment */
		mp->len = strlen(mp->buf);
		cp = mp->buf + mp->len - 1;
		while (cp >= mp->buf && (*cp == '\n' || *cp == '\r'))
			*cp-- = '\0';
		if ((mp->logname = strtok(mp->buf, " \t")) == NULL)
			continue;
		if ((cp = strtok(NULL, " \t")) == NULL)
			continue;
		/* Save hash type if specified, else use md4 */
		if (isalpha(*cp)) {
			if ((cp = strtok(NULL, " \t")) == NULL)
				continue;
		}
		mp->n = atoi(cp);
		if ((mp->seed = strtok(NULL, " \t")) == NULL)
			continue;
		if ((mp->val = strtok(NULL, " \t")) == NULL)
			continue;
d199 4
a202 3
		/* If we already locked the record, we are done */
		if (locked)
			break;
d204 1
a204 24
		/* Got a real entry, lock it */
		fl.l_start = mp->recstart;
		fl.l_len = mp->len;
		fl.l_pid = getpid();
		fl.l_type = F_WRLCK;
		fl.l_whence = SEEK_SET;

		rval = fcntl(fileno(mp->keyfile), F_SETLK, &fl);
		if (rval == 0)
			break;
		else if (errno != EAGAIN)
			return(-1);

		/*
		 * Someone else has the entry locked, wait
		 * until the lock is free, then re-read the entry.
		 */
		rval = fcntl(fileno(mp->keyfile), F_SETLKW, &fl);
		if (rval == -1)		/* Can't get exclusive lock */
			return(-1);
		locked = 1;
		(void)fseek(mp->keyfile, mp->recstart, SEEK_SET);
	}
	return(feof(mp->keyfile));
d225 1
a225 4
	time_t now;
	struct tm *tm;
	struct flock fl;
	char tbuf[27];
d227 3
a229 1
	int len;
d236 2
a237 10
	fl.l_start = mp->recstart;
	fl.l_len = mp->len;
	fl.l_pid = getpid();
	fl.l_type = F_WRLCK;
	fl.l_whence = SEEK_SET;
	if (fcntl(fileno(mp->keyfile), F_SETLK, &fl) != 0) {
		(void)fclose(mp->keyfile);
		mp->keyfile = NULL;
		return(-1);
	}
d239 1
a239 9
	time(&now);
	tm = localtime(&now);
	(void)strftime(tbuf, sizeof(tbuf), " %b %d,%Y %T", tm);

	if (response == NULL) {
		(void)fclose(mp->keyfile);
		mp->keyfile = NULL;
		return(-1);
	}
d241 2
a242 8

	/* Convert response to binary */
	if (etob(key, response) != 1 && atob8(key, response) != 0) {
		/* Neither english words nor ascii hex */
		(void)fclose(mp->keyfile);
		mp->keyfile = NULL;
		return(-1);
	}
a245 1
        (void)fflush(stdout);
d248 20
a267 18
	/* Reread the file record NOW */
	(void)fseek(mp->keyfile, mp->recstart, SEEK_SET);
	if (fgets(mp->buf, sizeof(mp->buf), mp->keyfile) == NULL) {
		(void)fclose(mp->keyfile);
		mp->keyfile = NULL;
		return(-1);
	}
	len = strlen(mp->buf) - 1;
	cp = mp->buf + len;
	while (cp >= mp->buf && (*cp == '\n' || *cp == '\r'))
		*cp-- = '\0';
	mp->logname = strtok(mp->buf, " \t");
	cp = strtok(NULL, " \t") ;
	if (isalpha(*cp))
		cp = strtok(NULL, " \t") ;
	mp->seed = strtok(NULL, " \t");
	mp->val = strtok(NULL, " \t");
	/* And convert file value to hex for comparison */
d269 2
a270 8

	/* Do actual comparison */
	if (memcmp(filekey, fkey, SKEY_BINKEY_SIZE) != 0){
		/* Wrong response */
		(void)fclose(mp->keyfile);
		mp->keyfile = NULL;
		return(1);
	}
d273 2
a274 3
	 * Update key in database by overwriting entire record. Note
	 * that we must write exactly the same number of bytes as in
	 * the original record (note fixed width field for N)
d278 8
a285 14
	(void)fseek(mp->keyfile, mp->recstart, SEEK_SET);
	len -= strlen(mp->logname) + strlen(skey_get_algorithm()) +
	    strlen(mp->val) + strlen(tbuf) + 9;
	/*
	 * If we run out of room it is because we read an old-style
	 * md4 entry without an explicit hash type.
	 */
	if (len < strlen(mp->seed))
		(void)fprintf(mp->keyfile, "%s %04d %-16s %s %-21s\n",
			      mp->logname, mp->n, mp->seed, mp->val, tbuf);
	else
		(void)fprintf(mp->keyfile, "%s %s %04d %-*s %s %-21s\n",
			      mp->logname, skey_get_algorithm(), mp->n,
			      len, mp->seed, mp->val, tbuf);
d287 1
d290 1
a290 1
	return(0);
d305 1
a305 1
 
d311 1
a311 1
	return(i);
d313 1
a313 1
 
d331 1
a331 1
		return(0);
d337 1
a337 1
	return(str);
d339 1
a339 1
 
d359 1
a359 1
		return(-1);
d362 1
a362 1
		return(skey.n);
d364 1
a364 1
	return(-1);
d375 1
a375 1
        u_char *s;
d377 1
a377 1
        int len, target;
d379 1
a379 1
	
d384 1
a384 1
  
d386 1
a386 1
        	i ^= ROUND(s + len);
d463 1
a463 1
		
d471 1
a471 1
		
d473 1
a473 1
		
d550 1
a550 1
		return(0);
d552 1
a552 1
	return(-1);
d563 1
d569 1
d572 2
a573 2
	 * Seek to the right place and write comment character
	 * which effectively zero's out the entry.
d575 2
a576 7
	(void)fseek(mp->keyfile, mp->recstart, SEEK_SET);
	if (fputc('#', mp->keyfile) == EOF) {
		fclose(mp->keyfile);
		mp->keyfile = NULL;
		return(-1);
	}

d579 1
a579 1
	return(0);
a592 2
	struct flock fl;

d594 1
a594 1
		return(-1);
d596 1
a596 7
	fl.l_start = mp->recstart;
	fl.l_len = mp->len;
	fl.l_pid = getpid();
	fl.l_type = F_UNLCK;
	fl.l_whence = SEEK_SET;

	return(fcntl(fileno(mp->keyfile), F_SETLK, &fl));
d604 57
a660 57
    int fd;
    char *buf;
    size_t bufsiz;
    int timeout;
{
    size_t left;
    int n;
    fd_set *readfds = NULL;
    struct timeval tv;
    char c;
    char *cp;

    if (bufsiz == 0)
	    return(NULL);			/* sanity */

    cp = buf;
    left = bufsiz;

    /*
     * Timeout of <= 0 means no timeout.
     */
    if (timeout > 0) {
	    /* Setup for select(2) */
	    n = howmany(fd + 1, NFDBITS) * sizeof(fd_mask);
	    if ((readfds = (fd_set *) malloc(n)) == NULL)
		    return(NULL);
	    (void) memset(readfds, 0, n);

	    /* Set timeout for select */
	    tv.tv_sec = timeout;
	    tv.tv_usec = 0;

	    while (--left) {
		    FD_SET(fd, readfds);

		    /* Make sure there is something to read (or timeout) */
		    while ((n = select(fd + 1, readfds, 0, 0, &tv)) == -1 &&
			(errno == EINTR || errno == EAGAIN))
			    ;
		    if (n == 0) {
			    free(readfds);
			    return(NULL);		/* timeout */
		    }

		    /* Read a character, exit loop on error, EOF or EOL */
		    n = read(fd, &c, 1);
		    if (n != 1 || c == '\n' || c == '\r')
			    break;
		    *cp++ = c;
	    }
	    free(readfds);
    } else {
	/* Keep reading until out of space, EOF, error, or newline */
	while (--left && (n = read(fd, &c, 1)) == 1 && c != '\n' && c != '\r')
		*cp++ = c;
    }
    *cp = '\0';
d662 1
a662 1
    return(cp == buf ? NULL : buf);
@


1.40
log
@Check for keyfile == NULL in skey_unlock()
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.39 2001/06/23 21:42:39 millert Exp $
d39 2
a40 2
static void skey_fakeprompt __P((char *, char *));
static char *tgetline __P((int, char *, size_t, int));
@


1.39
log
@skeyzero() never uses its 2nd arg so remove it.  Since the only thing
that calls skeyzero() is skeyinit and I just updated the libskey
major I am not going to bump the major again here...
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.38 2001/06/20 22:15:45 millert Exp $
d714 1
a714 1
	if (mp->logname == NULL)
@


1.38
log
@o Do per-record locking instead of whole file locking
o Use said locking to prevent a partial guess race as required by
  RFC 2289.  We now lock the record in skeylookup(), skeygetnext(),
  and skeyverify().
o A little KNF
o Kill deprecated getskeyprompt() function
o Provide a function to unlock a record, skey_unlock()
o Timeout reading of the passphrase in skey_authenticate() and
  skey_passcheck() since we have the record locked (uses select, not alarm).
o Convert old-style md4 entries (that lack an explicit hash) into
  new-style ones with the hash specified if there is space on the line.
@
text
@d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.37 2001/01/04 21:51:52 todd Exp $
d681 1
a681 1
skeyzero(mp, response)
a682 1
	char *response;
d684 1
@


1.37
log
@grammar
@
text
@d1 1
a1 1
/* S/KEY v1.1b (skeylogin.c)
a7 2
 *
 * Modifications:
d11 1
a11 1
 * S/KEY verification check, lookups, and authentication.
d13 1
a13 1
 * $OpenBSD: skeylogin.c,v 1.36 2000/11/20 23:46:39 millert Exp $
d40 1
d42 2
a43 37
/* Issue a skey challenge for user 'name'. If successful,
 * fill in the caller's skey structure and return(0). If unsuccessful
 * (e.g., if name is unknown) return(-1).
 *
 * The file read/write pointer is left at the start of the
 * record.
 */
int
getskeyprompt(mp, name, prompt)
	struct skey *mp;
	char *name;
	char *prompt;
{
	int rval;

	sevenbit(name);
	rval = skeylookup(mp, name);
	switch (rval) {
	case 0:		/* Lookup succeeded, return challenge */
		(void)sprintf(prompt, "otp-%.*s %d %.*s\n",
			      SKEY_MAX_HASHNAME_LEN, skey_get_algorithm(),
			      mp->n - 1, SKEY_MAX_SEED_LEN, mp->seed);
		return(0);

	case 1:		/* User not found */
		(void)fclose(mp->keyfile);
		mp->keyfile = NULL;
		/* FALLTHROUGH */

	default:	/* File error */
		skey_fakeprompt(name, prompt);
		strcat(prompt, "\n");
		return(-1);
	}
}

/* Return  a skey challenge string for user 'name'. If successful,
d77 3
a79 1
/* Find an entry in the One-time Password database.
d81 1
a81 1
 * -1: error in opening database
d90 3
a92 1
	int found = 0;
d96 1
d100 1
a100 1
	    (mp->keyfile = fopen(_PATH_SKEYKEYS, "r+")) != NULL) {
d102 1
a102 1
			fchmod(fileno(mp->keyfile), 0600);
d109 3
a111 4
	while (!feof(mp->keyfile)) {
		recstart = ftell(mp->keyfile);
		mp->recstart = recstart;
		if (fgets(mp->buf, sizeof(mp->buf), mp->keyfile) != mp->buf)
a112 1
		rip(mp->buf);
d115 6
a120 1
		if ((mp->logname = strtok(mp->buf, " \t")) == NULL)
d137 1
a137 7
		if (strcmp(mp->logname, name) == 0) {
			found = 1;
			break;
		}
	}
	if (found) {
		(void)fseek(mp->keyfile, recstart, SEEK_SET);
d143 40
a182 3
		return(0);
	} else {
		return(1);
d184 9
d195 3
a197 1
/* Get the next entry in the One-time Password database.
d207 2
a208 1
	long recstart = 0;
d211 1
d222 9
d235 1
a235 2
		recstart = ftell(mp->keyfile);
		mp->recstart = recstart;
a237 1
		rip(mp->buf);
d240 4
d258 27
a284 2
		/* Got a real entry */
		break;
d289 2
a290 1
/* Verify response to a s/key challenge.
d309 1
d312 17
a328 1
	int i, rval;
d343 1
a343 1
		/* Neither english words or ascii hex */
a353 15
	/*
	 * Obtain an exclusive lock on the key file so the same password
	 * cannot be used twice to get in to the system.
	 */
	for (i = 0; i < 300; i++) {
		if ((rval = flock(fileno(mp->keyfile), LOCK_EX|LOCK_NB)) == 0 ||
		    errno != EWOULDBLOCK)
			break;
		usleep(100000);			/* Sleep for 0.1 seconds */
	}
	if (rval == -1) {			/* Can't get exclusive lock */
		errno = EAGAIN;
		return(-1);
	}

d356 1
a356 1
	if (fgets(mp->buf, sizeof(mp->buf), mp->keyfile) != mp->buf) {
d361 4
a364 1
	rip(mp->buf);
d390 7
a396 2
	/* Don't save algorithm type for md4 (keep record length same) */
	if (strcmp(skey_get_algorithm(), "md4") == 0)
d400 1
a400 1
		(void)fprintf(mp->keyfile, "%s %s %04d %-16s %s %-21s\n",
d402 1
a402 1
			      mp->seed, mp->val, tbuf);
a422 1

d467 2
a468 1
	char *username, *passwd;
d648 1
a648 1
	
d651 1
a651 1
	(void)fprintf(stderr, "%s\n", skeyprompt);
d654 4
a657 2
	(void)fputs("Response: ", stderr);
	readskey(pbuf, sizeof(pbuf));
d671 2
a672 1
/* Comment out user's entry in the s/key database
a678 1
 *
d699 91
@


1.36
log
@Move fake prompt generation from skey_authenticate() to skeychallenge()
and getskeyprompt().  This means that when you get a challenge the
result parameter is always filled in, even if the use is not in the
skeykeys file.
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.35 2000/06/23 17:29:41 markus Exp $
d349 1
a349 1
 * Returns: 1 user doesnt exist, -1 file error, 0 user exists.
@


1.35
log
@set  mp->keyfile = NULL if stat fails
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.34 1999/12/06 19:04:58 deraadt Exp $
d41 1
a41 2
char *skipspace __P((char *));
int skeylookup __P((struct skey *, char *));
a59 1
	(void)strcpy(prompt, "otp-md0 55 latour1\n");
a60 2
	case -1:	/* File error */
		return(-1);
d66 1
d70 5
a76 1
	return(-1);	/* Can't happen */
d94 3
a96 5
	rval = skeylookup(mp,name);
	switch(rval){
	case -1:	/* File error */
		return(-1);
	case 0:		/* Lookup succeeded, issue challenge */
d101 1
d105 4
a110 1
	return(-1);	/* Can't happen */
d445 1
a445 4
 * skey_authenticate()
 *
 * Used when calling program will allow input of the user's
 * response to the challenge.
d447 1
a447 1
 * Returns: 0 success, -1 failure
d450 2
a451 2
int
skey_authenticate(username)
d453 1
d458 2
a459 2
	char pbuf[SKEY_MAX_PW_LEN+1], skeyprompt[SKEY_MAX_CHALLENGE+1];
	char *secret;
a460 1
	struct skey skey;
a461 3
	
	/* Attempt an S/Key challenge */
	i = skeychallenge(&skey, username, skeyprompt);
d463 67
a529 48
	/* Cons up a fake prompt if no entry in keys file */
	if (i != 0) {
		char *p, *u;

		/*
		 * Base first 4 chars of seed on hostname.
		 * Add some filler for short hostnames if necessary.
		 */
		if (gethostname(pbuf, sizeof(pbuf)) == -1)
			*(p = pbuf) = '.';
		else
			for (p = pbuf; *p && isalnum(*p); p++)
				if (isalpha(*p) && isupper(*p))
					*p = tolower(*p);
		if (*p && pbuf - p < 4)
			(void)strncpy(p, "asjd", 4 - (pbuf - p));
		pbuf[4] = '\0';

		/* Hash the username if possible */
		if ((up = SHA1Data(username, strlen(username), NULL)) != NULL) {
			struct stat sb;
			time_t t;
			int fd;

			/* Collapse the hash */
			ptr = hash_collapse(up);
			memset(up, 0, strlen(up));

			/* See if the random file's there, else use ctime */
			if ((fd = open(_SKEY_RAND_FILE_PATH_, O_RDONLY)) != -1
			    && fstat(fd, &sb) == 0 &&
			    sb.st_size > (off_t)SKEY_MAX_SEED_LEN &&
			    lseek(fd, ptr % (sb.st_size - SKEY_MAX_SEED_LEN),
			    SEEK_SET) != -1 && read(fd, hseed,
			    SKEY_MAX_SEED_LEN) == SKEY_MAX_SEED_LEN) {
				close(fd);
				fd = -1;
				secret = hseed;
				secretlen = SKEY_MAX_SEED_LEN;
				flg = 0;
			} else if (!stat(_PATH_MEM, &sb) || !stat("/", &sb)) {
				t = sb.st_ctime;
				secret = ctime(&t);
				secretlen = strlen(secret);
				flg = 0;
			}
			if (fd != -1)
				close(fd);
d531 1
d533 2
a534 23
		/* Put that in your pipe and smoke it */
		if (flg == 0) {
			/* Hash secret value with username */
			SHA1Init(&ctx);
			SHA1Update(&ctx, secret, secretlen);
			SHA1Update(&ctx, username, strlen(username));
			SHA1End(&ctx, up);
			
			/* Zero out */
			memset(secret, 0, secretlen);

			/* Now hash the hash */
			SHA1Init(&ctx);
			SHA1Update(&ctx, up, strlen(up));
			SHA1End(&ctx, up);
			
			ptr = hash_collapse(up + 4);
			
			for (i = 4; i < 9; i++) {
				pbuf[i] = (ptr % 10) + '0';
				ptr /= 10;
			}
			pbuf[i] = '\0';
d536 2
a537 2
			/* Sequence number */
			ptr = ((up[2] + up[3]) % 99) + 1;
d539 18
a556 2
			memset(up, 0, 20); /* SHA1 specific */
			free(up);
d558 8
a565 28
			(void)sprintf(skeyprompt,
				      "otp-%.*s %d %.*s",
				      SKEY_MAX_HASHNAME_LEN,
				      skey_get_algorithm(),
				      ptr, SKEY_MAX_SEED_LEN,
				      pbuf);
		} else {
			/* Base last 8 chars of seed on username */
			u = username;
			i = 8;
			p = &pbuf[4];
			do {
				if (*u == 0) {
					/* Pad remainder with zeros */
					while (--i >= 0)
						*p++ = '0';
					break;
				}

				*p++ = (*u++ % 10) + '0';
			} while (--i != 0);
			pbuf[12] = '\0';

			(void)sprintf(skeyprompt, "otp-%.*s %d %.*s",
				      SKEY_MAX_HASHNAME_LEN,
				      skey_get_algorithm(),
				      99, SKEY_MAX_SEED_LEN, pbuf);
		}
d567 1
d569 19
d613 1
@


1.34
log
@fd leak
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.33 1999/11/26 19:26:17 deraadt Exp $
d132 1
@


1.33
log
@fix descriptor leaks and double fclose(); markus and I; ok from millert
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.32 1999/08/16 14:46:56 millert Exp $
d501 1
d511 2
@


1.32
log
@don't need sys/file.h now that we include fcntl.h
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.31 1999/08/16 10:34:48 millert Exp $
d72 1
d104 1
d262 1
d271 1
d299 1
d316 1
d338 1
a338 1
	
d345 1
a345 1
 * Returns: 1 user doesnt exist, -1 fle error, 0 user exists.
d353 1
d355 7
a361 1
	return(skeylookup(&skey, username));
d383 4
d610 1
d615 1
a615 1
	
@


1.31
log
@missing fcntl.h
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.30 1998/07/05 19:47:16 millert Exp $
a18 1
#include <sys/file.h>
@


1.30
log
@replace open + fstat with stat
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.29 1998/07/05 19:41:35 millert Exp $
d31 1
@


1.29
log
@if there is no /etc/host.random, hash on the ctime of /dev/mem or /.  This is much better than the old fake challenge.
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.28 1998/07/03 02:06:22 angelos Exp $
d487 1
a487 4
			} else if (((fd = open(_PATH_MEM, O_RDONLY)) != -1 ||
			    (fd = open("/", O_RDONLY)) != -1) &&
			    fstat(fd, &sb) == 0 ) {
				close(fd);
@


1.28
log
@Change the random file path, add a sanity check on file size.
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.27 1998/07/03 02:02:01 angelos Exp $
a26 1
#include <sys/stat.h>
d436 1
a436 1
	int i, fd;
d440 2
a442 1
	struct stat sb;
d464 1
a464 2
		p = &pbuf[4];
		*p = '\0';
d466 31
a496 54
		/* See if the random file's there */
		if ((fd = open(_SKEY_RAND_FILE_PATH_, O_RDONLY)) != -1) {
			if ((fstat(fd, &sb) != -1) &&
			    (sb.st_size > SKEY_MAX_SEED_LEN) &&
			    ((up = SHA1Data(username, strlen(username), NULL))
			     != NULL)) {
			        /* Collapse the hash */
				ptr = hash_collapse(up);

				if ((lseek(fd, ptr % (sb.st_size - SKEY_MAX_SEED_LEN), SEEK_SET) != -1) && (read(fd, hseed, SKEY_MAX_SEED_LEN) == SKEY_MAX_SEED_LEN)) {
					memset(up, 0, strlen(up));

					/* Hash secret value with username */
					SHA1Init(&ctx);
					SHA1Update(&ctx, hseed,
						   SKEY_MAX_SEED_LEN);
					SHA1Update(&ctx, username,
						   strlen(username));
					SHA1End(&ctx, up);
					
					/* Zero out */
					memset(hseed, 0, SKEY_MAX_SEED_LEN);

					/* Now hash the hash */
					SHA1Init(&ctx);
					SHA1Update(&ctx, up, strlen(up));
					SHA1End(&ctx, up);
					
					ptr = hash_collapse(up + 4);
					
					for (i = 4; i < 9; i++) {
						pbuf[i] = (ptr % 10) + '0';
						ptr /= 10;
					}

					pbuf[i] = '\0';

					/* Sequence number */
					ptr = ((up[2] + up[3]) % 99) + 1;

					memset(up, 0, 20); /* SHA1 specific */
					free(up);
					flg = 0;

					(void)sprintf(skeyprompt,
						      "otp-%.*s %d %.*s",
			      			      SKEY_MAX_HASHNAME_LEN,
						      skey_get_algorithm(),
						      ptr, SKEY_MAX_SEED_LEN,
						      pbuf);
					/* Done */
				} else
					free(up);
		    	}
d498 57
a554 1
		    	close(fd);
a555 22

		if (flg)
		{
		    /* Base last 8 chars of seed on username */
		    u = username;
		    i = 8;
		    do {
			    if (*u == 0) {
				    /* Pad remainder with zeros */
				    while (--i >= 0)
				    	    *p++ = '0';
				    break;
			    }

		    	    *p++ = (*u++ % 10) + '0';
		    } while (--i != 0);
		    pbuf[12] = '\0';

		    (void)sprintf(skeyprompt, "otp-%.*s %d %.*s",
			          SKEY_MAX_HASHNAME_LEN, skey_get_algorithm(),
			          99, SKEY_MAX_SEED_LEN, pbuf);
	    }
@


1.27
log
@Fix my fix to return sane values.
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.26 1998/07/03 01:38:04 millert Exp $
d470 1
@


1.26
log
@produce credible seeds for non-existent users.
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.25 1998/07/03 01:32:49 angelos Exp $
d437 2
a438 1
	int i, fd, ptr;
d477 1
a477 1
					
d484 1
a484 1
					SHA1Final(up, &ctx);
d492 1
a492 1
					SHA1Final(up, &ctx);
d495 2
a496 4

					for (i = 4;
					     i < SKEY_MAX_SEED_LEN;
					     i++) {
d500 2
@


1.25
log
@Fix some of my indentation badness.
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.24 1998/07/03 01:08:13 angelos Exp $
d495 1
a495 1
					for (i = 0;
d498 1
a498 1
						p[i] = (ptr % 10) + '0';
@


1.24
log
@Remove user existance disclosure through "s/key" challenges.
@
text
@d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.23 1998/02/24 20:52:48 millert Exp $
d414 1
a414 1
  	        target = strlen(s);    /* Multiple of 4 */
d416 1
a416 1
	        target = strlen(s) - (strlen(s) % sizeof(u_int32_t));
d419 1
a419 1
	  i ^= ROUND(s + len);
d468 1
a468 1
		    	if ((fstat(fd, &sb) != -1) &&
d472 1
a472 1
			        ptr = hash_collapse(up);
d474 1
a474 1
			        if ((lseek(fd, ptr % (sb.st_size - SKEY_MAX_SEED_LEN), SEEK_SET) != -1) && (read(fd, hseed, SKEY_MAX_SEED_LEN) == SKEY_MAX_SEED_LEN)) {
d498 2
a499 2
					    p[i] = (ptr % 10) + '0';
					    ptr /= 10;
d517 1
a517 1
				        free(up);
d532 1
a532 1
					    *p++ = '0';
d536 1
a536 1
			    *p++ = (*u++ % 10) + '0';
@


1.23
log
@Allow superuser to disable skey by unlnking /etc/skeykeys.
@
text
@d11 1
d15 1
a15 1
 * $OpenBSD: skeylogin.c,v 1.22 1997/09/12 20:47:39 millert Exp $
d38 1
d400 24
d437 2
a438 1
	int i;
d441 3
a443 1

d466 53
a518 14
		/* Base last 8 chars of seed on username */
		u = username;
		i = 8;
		do {
			if (*u == 0) {
				/* Pad remainder with zeros */
				while (--i >= 0)
					*p++ = '0';
				break;
			}

			*p++ = (*u++ % 10) + '0';
		} while (--i != 0);
		pbuf[12] = '\0';
d520 24
a543 3
		(void)sprintf(skeyprompt, "otp-%.*s %d %.*s",
			      SKEY_MAX_HASHNAME_LEN, skey_get_algorithm(),
			      99, SKEY_MAX_SEED_LEN, pbuf);
@


1.22
log
@Don't let strncpy() get a negative length.  Noted by Theo.
@
text
@d14 1
a14 1
 * $OpenBSD: skeylogin.c,v 1.21 1997/09/04 18:19:47 millert Exp $
d123 4
a126 4
	/* See if _PATH_SKEYKEYS exists, and create it if not */
	if (stat(_PATH_SKEYKEYS, &statbuf) == -1 && errno == ENOENT) {
		mp->keyfile = fopen(_PATH_SKEYKEYS, "w+");
		if (mp->keyfile)
d129 1
a129 4
		/* Otherwise open normally for update */
		mp->keyfile = fopen(_PATH_SKEYKEYS, "r+");
		if (mp->keyfile && (statbuf.st_mode & 0007777) != 0600)
			fchmod(fileno(mp->keyfile), 0600);
a130 2
	if (mp->keyfile == NULL)
		return(-1);
d190 1
a190 1
	/* See if _PATH_SKEYKEYS exists, and create it if not */
d192 3
a194 3
		if (stat(_PATH_SKEYKEYS, &statbuf) == -1 && errno == ENOENT) {
			mp->keyfile = fopen(_PATH_SKEYKEYS, "w+");
			if (mp->keyfile)
d197 1
a197 4
			/* Otherwise open normally for update */
			mp->keyfile = fopen(_PATH_SKEYKEYS, "r+");
			if (mp->keyfile && (statbuf.st_mode & 0007777) != 0600)
				fchmod(fileno(mp->keyfile), 0600);
a198 2
		if (mp->keyfile == NULL)
			return(-1);
@


1.21
log
@Don't unlock skeys file before closing it.  The lock is released
when the file is closed anyway and explicately unlocking before
the file gets flushed defeats the purpose of locking in the first
place.
@
text
@d14 1
a14 1
 * $OpenBSD: skeylogin.c,v 1.20 1997/07/27 22:11:41 millert Exp $
d442 1
a442 1
		if (*p)
@


1.20
log
@Remove debugging info, whoops.
@
text
@d14 1
a14 1
 * $OpenBSD: skeylogin.c,v 1.19 1997/07/27 21:36:05 millert Exp $
a302 1
		(void)flock(fileno(mp->keyfile), LOCK_UN);
a318 1
		(void)flock(fileno(mp->keyfile), LOCK_UN);
a339 1
	(void)flock(fileno(mp->keyfile), LOCK_UN);
@


1.19
log
@- Do coarse locking on /etc/skeykeys.  Fixes a race that could allow
  a replay attempt to succeed.
- OpenBSD tags
@
text
@d14 1
a14 1
 * $OpenBSD: skeylogin.c,v 1.18 1997/07/27 21:20:27 millert Exp $
a295 1
		warn("flock");  /* XXX */
@


1.18
log
@Fix search and replace error introduced in version 1.16.
@
text
@d9 3
d14 1
a14 1
 * $OpenBSD$
d18 1
d261 1
a261 1
	int oldpri;
d286 2
a287 4
	 * In order to make the window of update as short as possible
	 * we must do the comparison here and if OK write it back
	 * other wise the same password can be used twice to get in
	 * to the system
d289 11
a299 2
	oldpri = getpriority(PRIO_PROCESS, 0);
	(void)setpriority(PRIO_PROCESS, 0, -4);
d301 1
a301 1
	/* reread the file record NOW */
d304 1
a304 1
		(void)setpriority(PRIO_PROCESS, 0, oldpri);
d321 1
a321 1
		(void)setpriority(PRIO_PROCESS, 0, oldpri);
d343 1
a345 1
	(void)setpriority(PRIO_PROCESS, 0, oldpri);
@


1.17
log
@Convert upper -> lower case in seed for fake s/key propt.
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.16 1997/07/26 19:42:46 millert Exp $
d41 1
a41 1
 * (e.g., if name is unknown) return(1).
d59 1
a59 1
		return(1);
d67 1
a67 1
		return(1);
d69 1
a69 1
	return(1);	/* Can't happen */
d74 1
a74 1
 * (e.g., if name is unknown) return(1).
d90 1
a90 1
		return(1);
d98 1
a98 1
		return(1);
d100 1
a100 1
	return(1);	/* Can't happen */
d131 1
a131 1
		return(1);
d204 1
a204 1
			return(1);
d265 1
a265 1
		return(1);
d273 1
a273 1
		return(1);
d295 1
a295 1
		return(1);
d393 1
a393 1
		return(1);
d398 1
a398 1
	return(1);
d436 1
a436 1
			strncpy(p, "asjd", 4 - (pbuf - p));
d475 1
a475 1
	return(1);
d498 1
a498 1
		return(1);
@


1.16
log
@ - int -> long fixes
 - restore priority correctly after setpriority (assumed start pri was 0)
 - rfc-compliant challenge when faking it for those w/o a keyfile entry
   on machines with short hostnames or non-alphanum hostnames.
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.15 1997/07/23 07:16:57 millert Exp $
d433 2
a434 1
				;
@


1.15
log
@Fix skeygetnext()
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.14 1997/07/23 06:53:12 millert Exp $
d40 2
a41 2
 * fill in the caller's skey structure and return 0. If unsuccessful
 * (e.g., if name is unknown) return -1.
d59 1
a59 1
		return -1;
d64 1
a64 1
		return 0;
d67 1
a67 1
		return -1;
d69 1
a69 1
	return -1;	/* Can't happen */
d73 2
a74 2
 * fill in the caller's skey structure and return 0. If unsuccessful
 * (e.g., if name is unknown) return -1.
d90 1
a90 1
		return -1;
d95 1
a95 1
		return 0;
d98 1
a98 1
		return -1;
d100 1
a100 1
	return -1;	/* Can't happen */
d131 1
a131 1
		return -1;
d171 1
a171 1
		return 0;
d173 1
a173 1
		return 1;
d204 1
a204 1
			return -1;
d257 1
d265 1
a265 1
		return -1;
d273 1
a273 1
		return -1;
d282 1
a282 1
	 * in order to make the window of update as short as possible
d287 1
d293 1
a293 1
		(void)setpriority(PRIO_PROCESS, 0, 0);
d295 1
a295 1
		return -1;
d310 1
a310 1
		(void)setpriority(PRIO_PROCESS, 0, 0);
d312 1
a312 1
		return 1;
d334 2
a335 2
	(void)setpriority(PRIO_PROCESS, 0, 0);
	return 0;
d370 1
a370 1
		return 0;
d372 1
a372 1
	return str;
d393 1
a393 1
		return -1;
d396 1
a396 1
		return skey.n;
d398 1
a398 1
	return -1;
d425 11
a435 3
		/* Base first 4 chars of seed on hostname */
		if (gethostname(pbuf, sizeof(pbuf)) < 0)
			strcpy(pbuf, "asjd");
d472 1
a472 1
		return 0;
d474 1
a474 1
	return -1;
d497 1
a497 1
		return -1;
d502 1
a502 1
	return 0;
@


1.14
log
@_PATH_SKEYKEYS now lives in <paths.h>
Add skeygetnext() for iterating over the key file.
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.13 1997/07/23 03:52:12 millert Exp $
d180 1
a180 1
 *  0: next entry found, file R/W pointer positioned at beginning of record
d188 1
a188 1
	char *cp, *ht = NULL;
a221 1
			ht = cp;
a223 2
		} else {
			ht = "md4";
d233 1
a233 11
	if (!feof(mp->keyfile)) {
		(void)fseek(mp->keyfile, recstart, SEEK_SET);
		/* Set hash type */
		if (ht && skey_set_algorithm(ht) == NULL) {
			warnx("Unknown hash algorithm %s, using %s", ht,
			      skey_get_algorithm());
		}
		return 0;
	} else {
		return 1;
	}
@


1.13
log
@Mode 0600 /etc/skeykeys
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.12 1997/07/10 21:11:11 millert Exp $
d21 2
d24 1
d26 2
a29 1
#include <unistd.h>
a30 3
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
d32 1
a32 1
#include <errno.h>
a35 4
#ifndef _PATH_KEYFILE
#define	_PATH_KEYFILE	"/etc/skeykeys"
#endif

d101 1
a101 1
}	
d116 1
a116 1
	char *cp, *ht;
d119 3
a121 3
	/* See if _PATH_KEYFILE exists, and create it if not */
	if (stat(_PATH_KEYFILE, &statbuf) == -1 && errno == ENOENT) {
		mp->keyfile = fopen(_PATH_KEYFILE, "w+");
d126 1
a126 1
		mp->keyfile = fopen(_PATH_KEYFILE, "r+");
d167 73
a239 1
		if (skey_set_algorithm(ht) == NULL) {
@


1.12
log
@Need err.h for warnx proto.
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.11 1996/11/03 18:57:29 millert Exp $
d126 1
a126 1
			chmod(_PATH_KEYFILE, 0644);
d130 2
@


1.11
log
@Add a bunch of length/size macros and use them.
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.10 1996/10/22 01:41:25 millert Exp $
d22 1
@


1.10
log
@Fake an s/key challenge if user doesn't have an entry.  Stops info
gathering attack.
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.9 1996/10/14 03:09:13 millert Exp $
d63 3
a65 2
		(void)sprintf(prompt, "otp-%s %d %s\n", skey_get_algorithm(),
			      mp->n - 1, mp->seed);
d94 3
a96 2
		(void)sprintf(ss, "otp-%s %d %s", skey_get_algorithm(),
			      mp->n - 1, mp->seed);
d191 3
a193 3
	char key[8];
	char fkey[8];
	char filekey[8];
d247 1
a247 1
	if (memcmp(filekey, fkey, 8) != 0){
d304 1
a304 1
	static char str[50];
d354 1
a354 1
	char pbuf[256], skeyprompt[50];
d385 3
a387 2
		(void)snprintf(skeyprompt, sizeof(skeyprompt), "otp-%s %d %s",
		    skey_get_algorithm(), 99, pbuf);
a394 1
	rip(pbuf);
@


1.9
log
@htoi now takes an int, not char.
Only skey_set_algorithm() for the record that matches target user.
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.8 1996/10/02 03:49:36 millert Exp $
d358 28
a385 2
	if (i == -2)
		return 0;
@


1.8
log
@Fix a bug wrt handling of old md4 entries.  Now don't save a type with md4
so we don't go over the record size and munge other entries.  Don't export
symbols we don't need to in put.c.
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.7 1996/09/30 04:10:46 millert Exp $
d24 1
d34 1
d36 1
d116 1
a116 1
	char *cp;
d135 1
a135 1
		if (fgets(mp->buf, sizeof(mp->buf), mp->keyfile) != mp->buf) {
a136 1
		}
d144 1
a144 1
		/* Set hash type if specified, else use md4 */
d146 1
a146 3
			if (skey_set_algorithm(cp) == NULL)
				warnx("Unknown hash algorithm %s, using %s",
				      cp, skey_get_algorithm());
d150 1
a150 3
			if (skey_set_algorithm("md4") == NULL)
				warnx("Unknown hash algorithm md4, using %s",
				      skey_get_algorithm());
d164 5
d170 1
a170 1
	} else
d172 1
@


1.7
log
@__ARGS -> __P (why does everyone have to do this differently?)
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.6 1996/09/29 23:35:08 millert Exp $
a19 1
#include <sys/timeb.h>
d233 2
a234 1
	cp = strtok(NULL, " \t") ;
d256 8
a263 2
	(void)fprintf(mp->keyfile, "%s %s %04d %-16s %s %-21s\n",
	    mp->logname, skey_get_algorithm(), mp->n, mp->seed, mp->val, tbuf);
@


1.6
log
@check skey_set_algorithm() ret val + pedantry.
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.5 1996/09/29 21:27:01 millert Exp $
d36 2
a37 2
char *skipspace __ARGS((char *));
int skeylookup __ARGS((struct skey *, char *));
@


1.5
log
@Towards RFC 1938 compliance.  Also, now supports SHA (secure hash algorithm).
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.4 1996/09/29 04:30:39 millert Exp $
d79 1
a79 1
skeychallenge(mp,name, ss)
d108 1
a108 1
skeylookup(mp,name)
d145 3
a147 2
			/* XXX - return val */
			skey_set_algorithm(cp);
d151 3
a153 1
			skey_set_algorithm("md4");
d182 1
a182 1
skeyverify(mp,response)
d212 1
a212 1
	(void)memcpy(fkey,key,sizeof(key));
d233 4
a236 4
	cp = strtok(NULL," \t") ;
	cp = strtok(NULL," \t") ;
	mp->seed = strtok(NULL," \t");
	mp->val = strtok(NULL," \t");
@


1.4
log
@You can now cut and paste skey prompt in an xterm to get the key.
Also removed broken code.
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.3 1996/09/27 15:38:59 millert Exp $
d26 1
d56 1
a56 1
	(void)strcpy(prompt, "skey MD0 55 latour1\n");
d61 1
a61 1
		(void)sprintf(prompt, "skey MD%d %d %s\n", skey_get_MDX(),
d91 1
a91 1
		(void)sprintf(ss, "skey MD%d %d %s", skey_get_MDX(),
d143 4
a146 3
		/* Set MDX if specified, else use MD4 */
		if (cp[0] == 'M' && cp[1] == 'D') {
			skey_set_MDX(atoi(&cp[2]));
d150 1
a150 1
			skey_set_MDX(4);
d253 2
a254 2
	(void)fprintf(mp->keyfile, "%s MD%d %04d %-16s %s %-21s\n",
	    mp->logname, skey_get_MDX(), mp->n, mp->seed, mp->val, tbuf);
@


1.3
log
@Deal with both MD4 and MD5 s/key's
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.2 1995/12/20 09:48:24 deraadt Exp $
d55 1
a55 1
	(void)strcpy(prompt, "s/key MD0 55 latour1\n");
d60 1
a60 1
		(void)sprintf(prompt, "s/key MD%d %d %s\n", skey_get_MDX(),
d90 1
a90 1
		(void)sprintf(ss, "s/key MD%d %d %s", skey_get_MDX(),
d111 1
a111 1
	int found, len;
a128 5
	len = strlen(name);
	/* XXX - do we really want to limit it to 8 char usernames? */
	if (len > 8)
		len = 8;		/*  Added 8/2/91  -  nmh */
	found = 0;
d155 1
a155 2
		if (strlen(mp->logname) == len &&
		    strncmp(mp->logname, name, len) == 0) {
d227 1
a227 1
	mp->logname = strtok(mp->buf," \t");
d233 1
a233 1
	atob8(filekey,mp->val);
d236 1
a236 1
	if (memcmp(filekey,fkey,8) != 0){
d346 1
a346 1
	(void)fprintf(stderr, "[%s]\n", skeyprompt);
@


1.2
log
@add ability to zero out entry; from millert@@cs.colorado.edu; netbsd pr#1851
also add a prototype for skeyzero()
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.1.1.1 1995/10/18 08:43:11 deraadt Exp $
a22 1

d46 1
a46 1
getskeyprompt(mp,name,prompt)
d54 2
a55 2
	rval = skeylookup(mp,name);
	strcpy(prompt,"s/key 55 latour1\n");
d60 2
a61 1
		sprintf(prompt,"s/key %d %s\n",mp->n - 1,mp->seed);
d64 1
a64 1
		fclose(mp->keyfile);
d90 2
a91 1
                sprintf(ss, "s/key %d %s",mp->n - 1,mp->seed);
d94 1
a94 1
		fclose(mp->keyfile);
d111 2
a112 3
	int found;
	int len;
	long recstart;
d116 3
a118 4
	/* See if the _PATH_KEYFILE exists, and create it if not */

	if (stat(_PATH_KEYFILE,&statbuf) == -1 && errno == ENOENT) {
		mp->keyfile = fopen(_PATH_KEYFILE,"w+");
d123 1
a123 1
		mp->keyfile = fopen(_PATH_KEYFILE,"r+");
d130 3
a132 1
	if( len > 8 ) len = 8;		/*  Added 8/2/91  -  nmh */
d137 1
a137 1
		if (fgets(mp->buf,sizeof(mp->buf),mp->keyfile) != mp->buf) {
d143 1
a143 1
		if ((mp->logname = strtok(mp->buf," \t")) == NULL)
d145 1
a145 1
		if ((cp = strtok(NULL," \t")) == NULL)
d147 8
d156 1
a156 1
		if ((mp->seed = strtok(NULL," \t")) == NULL)
d158 1
a158 1
		if ((mp->val = strtok(NULL," \t")) == NULL)
d160 2
a161 2
		if (strlen(mp->logname) == len
		 && strncmp(mp->logname,name,len) == 0){
d167 1
a167 1
		fseek(mp->keyfile,recstart,0);
d172 1
d197 1
a197 1
	strftime(tbuf, sizeof(tbuf), " %b %d,%Y %T", tm);
d200 1
a200 1
		fclose(mp->keyfile);
d208 1
a208 1
		fclose(mp->keyfile);
d213 3
a215 2
	memcpy(fkey,key,sizeof(key));
        fflush (stdout);
a216 1
	f(fkey);
d223 1
d225 5
a229 8
	setpriority(PRIO_PROCESS, 0, -4);

	/* reread the file record NOW*/

	fseek(mp->keyfile,mp->recstart,0);
	if (fgets(mp->buf,sizeof(mp->buf),mp->keyfile) != mp->buf){
		setpriority(PRIO_PROCESS, 0, 0);
		fclose(mp->keyfile);
d235 1
a241 2
        fflush (stdout);

d244 2
a245 2
		setpriority(PRIO_PROCESS, 0, 0);
		fclose(mp->keyfile);
d256 3
a258 3
	fseek(mp->keyfile,mp->recstart,0);
	fprintf(mp->keyfile, "%s %04d %-16s %s %-21s\n",
		mp->logname,mp->n,mp->seed, mp->val, tbuf);
d260 1
a260 1
	fclose(mp->keyfile);
d262 1
a262 1
	setpriority(PRIO_PROCESS, 0, 0);
a265 1

d267 1
a267 1
 * skey_haskey ()
a271 1
 
d273 1
a273 1
skey_haskey (username)
a275 1
	int i;
d278 1
a278 1
	return (skeylookup (&skey, username));
d282 1
a282 1
 * skey_keyinfo ()
d289 1
a289 1
skey_keyinfo (username)
d293 1
a293 1
	static char str [50];
d296 1
a296 1
	i = skeychallenge (&skey, username, str);
d304 1
a304 1
 * skey_passcheck ()
a311 1
 
d313 1
a313 1
skey_passcheck (username, passwd)
d319 1
a319 1
	i = skeylookup (&skey, username);
d323 1
a323 1
	if (skeyverify (&skey, passwd) == 0)
d330 1
a330 1
 * skey_authenticate ()
a337 1
 
d339 1
a339 1
skey_authenticate (username)
d346 2
a347 2
	/* Attempt a S/Key challenge */
	i = skeychallenge (&skey, username, skeyprompt);
d352 2
a353 2
	printf("[%s]\n", skeyprompt);
	fflush(stdout);
d355 2
a356 2
	printf("Response: ");
	readskey(pbuf, sizeof (pbuf));
d360 1
a360 1
	if (i == 0 && skeyverify (&skey, pbuf) == 0) {
d362 3
a364 2
			printf ("\nWarning! Key initialization needed soon.  ");
			printf ("(%d logins left)\n", skey.n);
d388 1
a388 1
	fseek(mp->keyfile, mp->recstart, 0);
d394 1
a394 1
	fclose(mp->keyfile);
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
 * $Id: skeylogin.c,v 1.5 1995/06/05 19:48:38 pk Exp $
d366 28
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

