head	1.46;
access;
symbols
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.44.0.4
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.36.0.16
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.12
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.10
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.8
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.6
	OPENBSD_5_0:1.36.0.4
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.8
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.4
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.12.0.6
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2016.11.20.12.45.26;	author reyk;	state Exp;
branches;
next	1.45;
commitid	PqGbtf4aku75OPpd;

1.45
date	2016.11.16.13.47.27;	author reyk;	state Exp;
branches;
next	1.44;
commitid	XyJooSdwV3dkETpz;

1.44
date	2015.12.22.19.51.04;	author mmcc;	state Exp;
branches;
next	1.43;
commitid	3htqtDr2Y7QvJUxm;

1.43
date	2015.11.17.21.39.23;	author mmcc;	state Exp;
branches;
next	1.42;
commitid	QwVD4AKITH4IBHi1;

1.42
date	2015.11.17.18.19.45;	author mmcc;	state Exp;
branches;
next	1.41;
commitid	XWxlXM1Hks3HcyxP;

1.41
date	2015.09.27.05.25.00;	author guenther;	state Exp;
branches;
next	1.40;
commitid	PQh1CHLROh0mqpnf;

1.40
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	0DYulI8hhujBHMcR;

1.39
date	2014.11.20.14.51.41;	author krw;	state Exp;
branches;
next	1.38;
commitid	dOUqRDzYiPQXkCLL;

1.38
date	2014.03.14.03.45.41;	author lteo;	state Exp;
branches;
next	1.37;

1.37
date	2014.03.14.03.44.13;	author lteo;	state Exp;
branches;
next	1.36;

1.36
date	2010.10.09.08.14.36;	author canacar;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.08.02.04.47;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.27.04.13.34;	author canacar;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.26.16.47.07;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.18.23.32.13;	author bluhm;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.15.02.49.14;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.11.15.02.21;	author dtucker;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.06.10.22.29;	author chl;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.02.18.35.17;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.02.18.31.21;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.18.11.52.12;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.07.19.32.39;	author mpf;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.04.18.00.45;	author joel;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.28.13.19.56;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.21.05.40.37;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.27.06.58.03;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.26.02.20.24;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.14.08.50.37;	author canacar;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.29.18.27.54;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.09.17.03.00;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.23.01.33.16;	author frantzen;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.19.19.39.37;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.17.22.29.47;	author dugsong;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.25.23.03.32;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.26.21.25.52;	author jakob;	state Exp;
branches;
next	1.11;

1.11
date	99.07.20.04.49.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.08.31.19.53.19;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.07.14.00.14.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.06.11.00.01.18;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	98.06.04.23.11.34;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.20.30.18;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.09.16.02.33.05;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.07.12.13.19.08;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.23.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.47.18;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Extend the DLT_OPENFLOW header to include the switch datapath id.

OK rzalamena@@
@
text
@/*	$OpenBSD: gencode.c,v 1.45 2016/11/16 13:47:27 reyk Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/param.h>	/* ALIGN */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>

struct mbuf;
struct rtentry;

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_pflog.h>
#include <net/pfvar.h>

#include <net80211/ieee80211.h>
#include <net80211/ieee80211_radiotap.h>

#include <stdlib.h>
#include <stddef.h>
#include <setjmp.h>
#include <stdarg.h>
#include <string.h>

#include "pcap-int.h"

#include "ethertype.h"
#include "llc.h"
#include "gencode.h"
#include "ppp.h"
#include <pcap-namedb.h>
#ifdef INET6
#include <netdb.h>
#endif /*INET6*/

#ifdef HAVE_OS_PROTO_H
#include "os-proto.h"
#endif

#define JMP(c) ((c)|BPF_JMP|BPF_K)

/* Locals */
static jmp_buf top_ctx;
static pcap_t *bpf_pcap;

/* Hack for updating VLAN offsets. */
static u_int	orig_linktype = -1, orig_nl = -1, orig_nl_nosnap = -1;

/* XXX */
#ifdef PCAP_FDDIPAD
int	pcap_fddipad = PCAP_FDDIPAD;
#else
int	pcap_fddipad;
#endif

__dead void
bpf_error(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	if (bpf_pcap != NULL)
		(void)vsnprintf(pcap_geterr(bpf_pcap), PCAP_ERRBUF_SIZE,
		    fmt, ap);
	va_end(ap);
	longjmp(top_ctx, 1);
	/* NOTREACHED */
}

static void init_linktype(int);

static int alloc_reg(void);
static void free_reg(int);

static struct block *root;

/* initialization code used for variable link header */
static struct slist *init_code = NULL;

/* Flags and registers for variable link type handling */
static int variable_nl;
static int nl_reg, iphl_reg;

/*
 * We divy out chunks of memory rather than call malloc each time so
 * we don't have to worry about leaking memory.  It's probably
 * not a big deal if all this memory was wasted but it this ever
 * goes into a library that would probably not be a good idea.
 */
#define NCHUNKS 16
#define CHUNK0SIZE 1024
struct chunk {
	u_int n_left;
	void *m;
};

static struct chunk chunks[NCHUNKS];
static int cur_chunk;

static void *newchunk(u_int);
static void freechunks(void);
static __inline struct block *new_block(int);
static __inline struct slist *new_stmt(int);
static struct block *gen_retblk(int);
static __inline void syntax(void);

static void backpatch(struct block *, struct block *);
static void merge(struct block *, struct block *);
static struct block *gen_cmp(u_int, u_int, bpf_int32);
static struct block *gen_cmp_gt(u_int, u_int, bpf_int32);
static struct block *gen_cmp_nl(u_int, u_int, bpf_int32);
static struct block *gen_mcmp(u_int, u_int, bpf_int32, bpf_u_int32);
static struct block *gen_mcmp_nl(u_int, u_int, bpf_int32, bpf_u_int32);
static struct block *gen_bcmp(u_int, u_int, const u_char *);
static struct block *gen_uncond(int);
static __inline struct block *gen_true(void);
static __inline struct block *gen_false(void);
static struct block *gen_linktype(int);
static struct block *gen_hostop(bpf_u_int32, bpf_u_int32, int, int, u_int, u_int);
#ifdef INET6
static struct block *gen_hostop6(struct in6_addr *, struct in6_addr *, int, int, u_int, u_int);
#endif
static struct block *gen_ehostop(const u_char *, int);
static struct block *gen_fhostop(const u_char *, int);
static struct block *gen_dnhostop(bpf_u_int32, int, u_int);
static struct block *gen_p80211_hostop(const u_char *, int);
static struct block *gen_p80211_addr(int, u_int, const u_char *);
static struct block *gen_host(bpf_u_int32, bpf_u_int32, int, int);
#ifdef INET6
static struct block *gen_host6(struct in6_addr *, struct in6_addr *, int, int);
#endif
#ifndef INET6
static struct block *gen_gateway(const u_char *, bpf_u_int32 **, int, int);
#endif
static struct block *gen_ipfrag(void);
static struct block *gen_portatom(int, bpf_int32);
#ifdef INET6
static struct block *gen_portatom6(int, bpf_int32);
#endif
struct block *gen_portop(int, int, int);
static struct block *gen_port(int, int, int);
#ifdef INET6
struct block *gen_portop6(int, int, int);
static struct block *gen_port6(int, int, int);
#endif
static int lookup_proto(const char *, int);
static struct block *gen_protochain(int, int, int);
static struct block *gen_proto(int, int, int);
static struct slist *xfer_to_x(struct arth *);
static struct slist *xfer_to_a(struct arth *);
static struct block *gen_len(int, int);

static void *
newchunk(n)
	u_int n;
{
	struct chunk *cp;
	int k, size;

	/* XXX Round to structure boundary. */
	n = ALIGN(n);

	cp = &chunks[cur_chunk];
	if (n > cp->n_left) {
		++cp, k = ++cur_chunk;
		if (k >= NCHUNKS)
			bpf_error("out of memory");
		size = CHUNK0SIZE << k;
		cp->m = calloc(1, size);
		if (cp->m == NULL)
			bpf_error("out of memory");

		cp->n_left = size;
		if (n > size)
			bpf_error("out of memory");
	}
	cp->n_left -= n;
	return (void *)((char *)cp->m + cp->n_left);
}

static void
freechunks()
{
	int i;

	cur_chunk = 0;
	for (i = 0; i < NCHUNKS; ++i) {
		free(chunks[i].m);
		chunks[i].m = NULL;
	}
}

/*
 * A strdup whose allocations are freed after code generation is over.
 */
char *
sdup(s)
	const char *s;
{
	int n = strlen(s) + 1;
	char *cp = newchunk(n);

	strlcpy(cp, s, n);
	return (cp);
}

static __inline struct block *
new_block(code)
	int code;
{
	struct block *p;

	p = (struct block *)newchunk(sizeof(*p));
	p->s.code = code;
	p->head = p;

	return p;
}

static __inline struct slist *
new_stmt(code)
	int code;
{
	struct slist *p;

	p = (struct slist *)newchunk(sizeof(*p));
	p->s.code = code;

	return p;
}

static struct block *
gen_retblk(v)
	int v;
{
	struct block *b = new_block(BPF_RET|BPF_K);

	b->s.k = v;
	return b;
}

static __inline void
syntax()
{
	bpf_error("syntax error in filter expression");
}

static bpf_u_int32 netmask;
static int snaplen;
int no_optimize;

int
pcap_compile(pcap_t *p, struct bpf_program *program,
	     char *buf, int optimize, bpf_u_int32 mask)
{
	extern int n_errors;
	int len;

	no_optimize = 0;
	n_errors = 0;
	root = NULL;
	bpf_pcap = p;
	if (setjmp(top_ctx)) {
		freechunks();
		return (-1);
	}

	netmask = mask;
	snaplen = pcap_snapshot(p);

	lex_init(buf ? buf : "");
	init_linktype(pcap_datalink(p));
	(void)pcap_parse();

	if (n_errors)
		syntax();

	if (root == NULL)
		root = gen_retblk(snaplen);

	if (optimize && !no_optimize) {
		bpf_optimize(&root);
		if (root == NULL ||
		    (root->s.code == (BPF_RET|BPF_K) && root->s.k == 0))
			bpf_error("expression rejects all packets");
	}
	program->bf_insns = icode_to_fcode(root, &len);
	program->bf_len = len;

	freechunks();
	return (0);
}

/*
 * entry point for using the compiler with no pcap open
 * pass in all the stuff that is needed explicitly instead.
 */
int
pcap_compile_nopcap(int snaplen_arg, int linktype_arg,
		    struct bpf_program *program,
	     char *buf, int optimize, bpf_u_int32 mask)
{
	extern int n_errors;
	int len;

	n_errors = 0;
	root = NULL;
	bpf_pcap = NULL;
	if (setjmp(top_ctx)) {
		freechunks();
		return (-1);
	}

	netmask = mask;

	/* XXX needed? I don't grok the use of globals here. */
	snaplen = snaplen_arg;

	lex_init(buf ? buf : "");
	init_linktype(linktype_arg);
	(void)pcap_parse();

	if (n_errors)
		syntax();

	if (root == NULL)
		root = gen_retblk(snaplen_arg);

	if (optimize) {
		bpf_optimize(&root);
		if (root == NULL ||
		    (root->s.code == (BPF_RET|BPF_K) && root->s.k == 0))
			bpf_error("expression rejects all packets");
	}
	program->bf_insns = icode_to_fcode(root, &len);
	program->bf_len = len;

	freechunks();
	return (0);
}

/*
 * Clean up a "struct bpf_program" by freeing all the memory allocated
 * in it.
 */
void
pcap_freecode(struct bpf_program *program)
{
	program->bf_len = 0;
	if (program->bf_insns != NULL) {
		free((char *)program->bf_insns);
		program->bf_insns = NULL;
	}
}

/*
 * Backpatch the blocks in 'list' to 'target'.  The 'sense' field indicates
 * which of the jt and jf fields has been resolved and which is a pointer
 * back to another unresolved block (or nil).  At least one of the fields
 * in each block is already resolved.
 */
static void
backpatch(list, target)
	struct block *list, *target;
{
	struct block *next;

	while (list) {
		if (!list->sense) {
			next = JT(list);
			JT(list) = target;
		} else {
			next = JF(list);
			JF(list) = target;
		}
		list = next;
	}
}

/*
 * Merge the lists in b0 and b1, using the 'sense' field to indicate
 * which of jt and jf is the link.
 */
static void
merge(b0, b1)
	struct block *b0, *b1;
{
	struct block **p = &b0;

	/* Find end of list. */
	while (*p)
		p = !((*p)->sense) ? &JT(*p) : &JF(*p);

	/* Concatenate the lists. */
	*p = b1;
}

void
finish_parse(p)
	struct block *p;
{
	backpatch(p, gen_retblk(snaplen));
	p->sense = !p->sense;
	backpatch(p, gen_retblk(0));
	root = p->head;

	/* prepend initialization code to root */
	if (init_code != NULL && root != NULL) {
		sappend(init_code, root->stmts);
		root->stmts = init_code;
		init_code = NULL;
	}

	if (iphl_reg != -1) {
		free_reg(iphl_reg);
		iphl_reg = -1;
	}
	if (nl_reg != -1) {
		free_reg(nl_reg);
		nl_reg = -1;
	}
}

void
gen_and(b0, b1)
	struct block *b0, *b1;
{
	backpatch(b0, b1->head);
	b0->sense = !b0->sense;
	b1->sense = !b1->sense;
	merge(b1, b0);
	b1->sense = !b1->sense;
	b1->head = b0->head;
}

void
gen_or(b0, b1)
	struct block *b0, *b1;
{
	b0->sense = !b0->sense;
	backpatch(b0, b1->head);
	b0->sense = !b0->sense;
	merge(b1, b0);
	b1->head = b0->head;
}

void
gen_not(b)
	struct block *b;
{
	b->sense = !b->sense;
}

static struct block *
gen_cmp(offset, size, v)
	u_int offset, size;
	bpf_int32 v;
{
	struct slist *s;
	struct block *b;

	s = new_stmt(BPF_LD|BPF_ABS|size);
	s->s.k = offset;

	b = new_block(JMP(BPF_JEQ));
	b->stmts = s;
	b->s.k = v;

	return b;
}

static struct block *
gen_cmp_gt(offset, size, v)
	u_int offset, size;
	bpf_int32 v;
{
	struct slist *s;
	struct block *b;

	s = new_stmt(BPF_LD|BPF_ABS|size);
	s->s.k = offset;

	b = new_block(JMP(BPF_JGT));
	b->stmts = s;
	b->s.k = v;

	return b;
}

static struct block *
gen_mcmp(offset, size, v, mask)
	u_int offset, size;
	bpf_int32 v;
	bpf_u_int32 mask;
{
	struct block *b = gen_cmp(offset, size, v);
	struct slist *s;

	if (mask != 0xffffffff) {
		s = new_stmt(BPF_ALU|BPF_AND|BPF_K);
		s->s.k = mask;
		sappend(b->stmts, s);
	}
	return b;
}

/* Like gen_mcmp with 'dynamic off_nl' added to the offset */
static struct block *
gen_mcmp_nl(offset, size, v, mask)
	u_int offset, size;
	bpf_int32 v;
	bpf_u_int32 mask;
{
	struct block *b = gen_cmp_nl(offset, size, v);
	struct slist *s;

	if (mask != 0xffffffff) {
		s = new_stmt(BPF_ALU|BPF_AND|BPF_K);
		s->s.k = mask;
		sappend(b->stmts, s);
	}
	return b;
}

static struct block *
gen_bcmp(offset, size, v)
	u_int offset, size;
	const u_char *v;
{
	struct block *b, *tmp;

	b = NULL;
	while (size >= 4) {
		const u_char *p = &v[size - 4];
		bpf_int32 w = ((bpf_int32)p[0] << 24) |
		    ((bpf_int32)p[1] << 16) | ((bpf_int32)p[2] << 8) | p[3];

		tmp = gen_cmp(offset + size - 4, BPF_W, w);
		if (b != NULL)
			gen_and(b, tmp);
		b = tmp;
		size -= 4;
	}
	while (size >= 2) {
		const u_char *p = &v[size - 2];
		bpf_int32 w = ((bpf_int32)p[0] << 8) | p[1];

		tmp = gen_cmp(offset + size - 2, BPF_H, w);
		if (b != NULL)
			gen_and(b, tmp);
		b = tmp;
		size -= 2;
	}
	if (size > 0) {
		tmp = gen_cmp(offset, BPF_B, (bpf_int32)v[0]);
		if (b != NULL)
			gen_and(b, tmp);
		b = tmp;
	}
	return b;
}

/*
 * Various code constructs need to know the layout of the data link
 * layer.  These variables give the necessary offsets.  off_linktype
 * is set to -1 for no encapsulation, in which case, IP is assumed.
 */
static u_int off_linktype;
static u_int off_nl;
static u_int off_nl_nosnap;

static int linktype;

/* Generate code to load the dynamic 'off_nl' to the X register */
static struct slist *
nl2X_stmt(void)
{
	struct slist *s, *tmp;

	if (nl_reg == -1) {
		switch (linktype) {
		case DLT_PFLOG:
			/* The pflog header contains PFLOG_REAL_HDRLEN
			   which does NOT include the padding. Round
			   up to the nearest dword boundary */
			s = new_stmt(BPF_LD|BPF_B|BPF_ABS);
			s->s.k = 0;

			tmp = new_stmt(BPF_ALU|BPF_ADD|BPF_K);
			tmp->s.k = 3;
			sappend(s, tmp);

			tmp = new_stmt(BPF_ALU|BPF_AND|BPF_K);
			tmp->s.k = 0xfc;
			sappend(s, tmp);

			nl_reg = alloc_reg();
			tmp = new_stmt(BPF_ST);
			tmp->s.k = nl_reg;
			sappend(s, tmp);

			break;
		default:
			bpf_error("Unknown header size for link type 0x%x",
				  linktype);
		}

		if (init_code == NULL)
			init_code = s;
		else
			sappend(init_code, s);
	}

	s = new_stmt(BPF_LDX|BPF_MEM);
	s->s.k = nl_reg;

	return s;
}

/* Like gen_cmp but adds the dynamic 'off_nl' to the offset */
static struct block *
gen_cmp_nl(offset, size, v)
	u_int offset, size;
	bpf_int32 v;
{
	struct slist *s, *tmp;
	struct block *b;

	if (variable_nl) {
		s = nl2X_stmt();
		tmp = new_stmt(BPF_LD|BPF_IND|size);
		tmp->s.k = offset;
		sappend(s, tmp);
	} else {
		s = new_stmt(BPF_LD|BPF_ABS|size);
		s->s.k = offset + off_nl;
	}
	b = new_block(JMP(BPF_JEQ));
	b->stmts = s;
	b->s.k = v;

	return b;
}

static void
init_linktype(type)
	int type;
{
	linktype = type;
	init_code = NULL;
	nl_reg = iphl_reg = -1;

	switch (type) {

	case DLT_EN10MB:
		off_linktype = 12;
		off_nl = 14;
		return;

	case DLT_SLIP:
		/*
		 * SLIP doesn't have a link level type.  The 16 byte
		 * header is hacked into our SLIP driver.
		 */
		off_linktype = -1;
		off_nl = 16;
		return;

	case DLT_SLIP_BSDOS:
		/* XXX this may be the same as the DLT_PPP_BSDOS case */
		off_linktype = -1;
		/* XXX end */
		off_nl = 24;
		return;

	case DLT_NULL:
		off_linktype = 0;
		off_nl = 4;
		return;

	case DLT_PPP:
		off_linktype = 2;
		off_nl = 4;
		return;

	case DLT_PPP_ETHER:
		/*
		 * This does not include the Ethernet header, and
		 * only covers session state.
 		 */
		off_linktype = 6;
		off_nl = 8;
		return;

	case DLT_PPP_BSDOS:
		off_linktype = 5;
		off_nl = 24;
		return;

	case DLT_FDDI:
		/*
		 * FDDI doesn't really have a link-level type field.
		 * We assume that SSAP = SNAP is being used and pick
		 * out the encapsulated Ethernet type.
		 */
		off_linktype = 19;
#ifdef PCAP_FDDIPAD
		off_linktype += pcap_fddipad;
#endif
		off_nl = 21;
#ifdef PCAP_FDDIPAD
		off_nl += pcap_fddipad;
#endif
		return;

	case DLT_IEEE802:
		off_linktype = 20;
		off_nl = 22;
		return;

	case DLT_IEEE802_11:
		off_linktype = 30; /* XXX variable */
		off_nl = 32;
		return;

	case DLT_IEEE802_11_RADIO: /* XXX variable */
		off_linktype = 30 + IEEE80211_RADIOTAP_HDRLEN;
		off_nl = 32 + IEEE80211_RADIOTAP_HDRLEN;
		return;

	case DLT_ATM_RFC1483:
		/*
		 * assume routed, non-ISO PDUs
		 * (i.e., LLC = 0xAA-AA-03, OUT = 0x00-00-00)
		 */
		off_linktype = 6;
		off_nl = 8;
		return;

	case DLT_LOOP:
		off_linktype = -1;
		off_nl = 4;
		return;

	case DLT_ENC:
		off_linktype = -1;
		off_nl = 12;
		return;

	case DLT_PFLOG:
		off_linktype = 0;
		variable_nl = 1;
		off_nl = 0;
		return;

	case DLT_PFSYNC:
		off_linktype = -1;
		off_nl = 4;
		return;

	case DLT_OPENFLOW:
		off_linktype = -1;
		off_nl = 12;
		return;

	case DLT_RAW:
		off_linktype = -1;
		off_nl = 0;
		return;
	}
	bpf_error("unknown data link type 0x%x", linktype);
	/* NOTREACHED */
}

static struct block *
gen_uncond(rsense)
	int rsense;
{
	struct block *b;
	struct slist *s;

	s = new_stmt(BPF_LD|BPF_IMM);
	s->s.k = !rsense;
	b = new_block(JMP(BPF_JEQ));
	b->stmts = s;

	return b;
}

static __inline struct block *
gen_true()
{
	return gen_uncond(1);
}

static __inline struct block *
gen_false()
{
	return gen_uncond(0);
}

static struct block *
gen_linktype(proto)
	int proto;
{
	struct block *b0, *b1;

	/* If we're not using encapsulation and checking for IP, we're done */
	if (off_linktype == -1 && proto == ETHERTYPE_IP)
		return gen_true();
#ifdef INET6
	/* this isn't the right thing to do, but sometimes necessary */
	if (off_linktype == -1 && proto == ETHERTYPE_IPV6)
		return gen_true();
#endif

	switch (linktype) {

	case DLT_EN10MB:
		if (proto <= ETHERMTU) {
			/* This is an LLC SAP value */
			b0 = gen_cmp_gt(off_linktype, BPF_H, ETHERMTU);
			gen_not(b0);
			b1 = gen_cmp(off_linktype + 2, BPF_B, (bpf_int32)proto);
			gen_and(b0, b1);
			return b1;
		} else {
			/* This is an Ethernet type */
			return gen_cmp(off_linktype, BPF_H, (bpf_int32)proto);
		}
		break;

	case DLT_SLIP:
		return gen_false();

	case DLT_PPP:
	case DLT_PPP_ETHER:
		if (proto == ETHERTYPE_IP)
			proto = PPP_IP;			/* XXX was 0x21 */
#ifdef INET6
		else if (proto == ETHERTYPE_IPV6)
			proto = PPP_IPV6;
#endif
		break;

	case DLT_PPP_BSDOS:
		switch (proto) {

		case ETHERTYPE_IP:
			b0 = gen_cmp(off_linktype, BPF_H, PPP_IP);
			b1 = gen_cmp(off_linktype, BPF_H, PPP_VJC);
			gen_or(b0, b1);
			b0 = gen_cmp(off_linktype, BPF_H, PPP_VJNC);
			gen_or(b1, b0);
			return b0;

#ifdef INET6
		case ETHERTYPE_IPV6:
			proto = PPP_IPV6;
			/* more to go? */
			break;
#endif /* INET6 */

		case ETHERTYPE_DN:
			proto = PPP_DECNET;
			break;

		case ETHERTYPE_ATALK:
			proto = PPP_APPLE;
			break;

		case ETHERTYPE_NS:
			proto = PPP_NS;
			break;
		}
		break;

	case DLT_LOOP:
	case DLT_ENC:
	case DLT_NULL:
		/* XXX */
		if (proto == ETHERTYPE_IP)
			return (gen_cmp(0, BPF_W, (bpf_int32)htonl(AF_INET)));
#ifdef INET6
		else if (proto == ETHERTYPE_IPV6)
			return (gen_cmp(0, BPF_W, (bpf_int32)htonl(AF_INET6)));
#endif /* INET6 */
		else
			return gen_false();
		break;
	case DLT_PFLOG:
		if (proto == ETHERTYPE_IP)
			return (gen_cmp(offsetof(struct pfloghdr, af), BPF_B,
			    (bpf_int32)AF_INET));
#ifdef INET6
		else if (proto == ETHERTYPE_IPV6)
			return (gen_cmp(offsetof(struct pfloghdr, af), BPF_B,
			    (bpf_int32)AF_INET6));
#endif /* INET6 */
		else
			return gen_false();
		break;

	}
	return gen_cmp(off_linktype, BPF_H, (bpf_int32)proto);
}

static struct block *
gen_hostop(addr, mask, dir, proto, src_off, dst_off)
	bpf_u_int32 addr;
	bpf_u_int32 mask;
	int dir, proto;
	u_int src_off, dst_off;
{
	struct block *b0, *b1;
	u_int offset;

	switch (dir) {

	case Q_SRC:
		offset = src_off;
		break;

	case Q_DST:
		offset = dst_off;
		break;

	case Q_AND:
		b0 = gen_hostop(addr, mask, Q_SRC, proto, src_off, dst_off);
		b1 = gen_hostop(addr, mask, Q_DST, proto, src_off, dst_off);
		gen_and(b0, b1);
		return b1;

	case Q_OR:
	case Q_DEFAULT:
		b0 = gen_hostop(addr, mask, Q_SRC, proto, src_off, dst_off);
		b1 = gen_hostop(addr, mask, Q_DST, proto, src_off, dst_off);
		gen_or(b0, b1);
		return b1;

	default:
		bpf_error("direction not supported on linktype 0x%x",
		    linktype);
	}
	b0 = gen_linktype(proto);
	b1 = gen_mcmp_nl(offset, BPF_W, (bpf_int32)addr, mask);
	gen_and(b0, b1);
	return b1;
}

#ifdef INET6
static struct block *
gen_hostop6(addr, mask, dir, proto, src_off, dst_off)
	struct in6_addr *addr;
	struct in6_addr *mask;
	int dir, proto;
	u_int src_off, dst_off;
{
	struct block *b0, *b1;
	u_int offset;
	u_int32_t *a, *m;

	switch (dir) {

	case Q_SRC:
		offset = src_off;
		break;

	case Q_DST:
		offset = dst_off;
		break;

	case Q_AND:
		b0 = gen_hostop6(addr, mask, Q_SRC, proto, src_off, dst_off);
		b1 = gen_hostop6(addr, mask, Q_DST, proto, src_off, dst_off);
		gen_and(b0, b1);
		return b1;

	case Q_OR:
	case Q_DEFAULT:
		b0 = gen_hostop6(addr, mask, Q_SRC, proto, src_off, dst_off);
		b1 = gen_hostop6(addr, mask, Q_DST, proto, src_off, dst_off);
		gen_or(b0, b1);
		return b1;

	default:
		bpf_error("direction not supported on linktype 0x%x",
		    linktype);
	}
	/* this order is important */
	a = (u_int32_t *)addr;
	m = (u_int32_t *)mask;
	b1 = gen_mcmp_nl(offset + 12, BPF_W, ntohl(a[3]), ntohl(m[3]));
	b0 = gen_mcmp_nl(offset + 8, BPF_W, ntohl(a[2]), ntohl(m[2]));
	gen_and(b0, b1);
	b0 = gen_mcmp_nl(offset + 4, BPF_W, ntohl(a[1]), ntohl(m[1]));
	gen_and(b0, b1);
	b0 = gen_mcmp_nl(offset + 0, BPF_W, ntohl(a[0]), ntohl(m[0]));
	gen_and(b0, b1);
	b0 = gen_linktype(proto);
	gen_and(b0, b1);
	return b1;
}
#endif /*INET6*/

static struct block *
gen_ehostop(eaddr, dir)
	const u_char *eaddr;
	int dir;
{
	struct block *b0, *b1;

	switch (dir) {
	case Q_SRC:
		return gen_bcmp(6, 6, eaddr);

	case Q_DST:
		return gen_bcmp(0, 6, eaddr);

	case Q_AND:
		b0 = gen_ehostop(eaddr, Q_SRC);
		b1 = gen_ehostop(eaddr, Q_DST);
		gen_and(b0, b1);
		return b1;

	case Q_DEFAULT:
	case Q_OR:
		b0 = gen_ehostop(eaddr, Q_SRC);
		b1 = gen_ehostop(eaddr, Q_DST);
		gen_or(b0, b1);
		return b1;
	default:
		bpf_error("direction not supported on linktype 0x%x",
		    linktype);
	}
	/* NOTREACHED */
}

/*
 * Like gen_ehostop, but for DLT_FDDI
 */
static struct block *
gen_fhostop(eaddr, dir)
	const u_char *eaddr;
	int dir;
{
	struct block *b0, *b1;

	switch (dir) {
	case Q_SRC:
#ifdef PCAP_FDDIPAD
		return gen_bcmp(6 + 1 + pcap_fddipad, 6, eaddr);
#else
		return gen_bcmp(6 + 1, 6, eaddr);
#endif

	case Q_DST:
#ifdef PCAP_FDDIPAD
		return gen_bcmp(0 + 1 + pcap_fddipad, 6, eaddr);
#else
		return gen_bcmp(0 + 1, 6, eaddr);
#endif

	case Q_AND:
		b0 = gen_fhostop(eaddr, Q_SRC);
		b1 = gen_fhostop(eaddr, Q_DST);
		gen_and(b0, b1);
		return b1;

	case Q_DEFAULT:
	case Q_OR:
		b0 = gen_fhostop(eaddr, Q_SRC);
		b1 = gen_fhostop(eaddr, Q_DST);
		gen_or(b0, b1);
		return b1;
	default:
		bpf_error("direction not supported on linktype 0x%x",
		    linktype);
	}
	/* NOTREACHED */
}

/*
 * This is quite tricky because there may be pad bytes in front of the
 * DECNET header, and then there are two possible data packet formats that
 * carry both src and dst addresses, plus 5 packet types in a format that
 * carries only the src node, plus 2 types that use a different format and
 * also carry just the src node.
 *
 * Yuck.
 *
 * Instead of doing those all right, we just look for data packets with
 * 0 or 1 bytes of padding.  If you want to look at other packets, that
 * will require a lot more hacking.
 *
 * To add support for filtering on DECNET "areas" (network numbers)
 * one would want to add a "mask" argument to this routine.  That would
 * make the filter even more inefficient, although one could be clever
 * and not generate masking instructions if the mask is 0xFFFF.
 */
static struct block *
gen_dnhostop(addr, dir, base_off)
	bpf_u_int32 addr;
	int dir;
	u_int base_off;
{
	struct block *b0, *b1, *b2, *tmp;
	u_int offset_lh;	/* offset if long header is received */
	u_int offset_sh;	/* offset if short header is received */

	switch (dir) {

	case Q_DST:
		offset_sh = 1;	/* follows flags */
		offset_lh = 7;	/* flgs,darea,dsubarea,HIORD */
		break;

	case Q_SRC:
		offset_sh = 3;	/* follows flags, dstnode */
		offset_lh = 15;	/* flgs,darea,dsubarea,did,sarea,ssub,HIORD */
		break;

	case Q_AND:
		/* Inefficient because we do our Calvinball dance twice */
		b0 = gen_dnhostop(addr, Q_SRC, base_off);
		b1 = gen_dnhostop(addr, Q_DST, base_off);
		gen_and(b0, b1);
		return b1;

	case Q_OR:
	case Q_DEFAULT:
		/* Inefficient because we do our Calvinball dance twice */
		b0 = gen_dnhostop(addr, Q_SRC, base_off);
		b1 = gen_dnhostop(addr, Q_DST, base_off);
		gen_or(b0, b1);
		return b1;

	default:
		bpf_error("direction not supported on linktype 0x%x",
		    linktype);
	}
	b0 = gen_linktype(ETHERTYPE_DN);
	/* Check for pad = 1, long header case */
	tmp = gen_mcmp_nl(base_off + 2, BPF_H,
		       (bpf_int32)ntohs(0x0681), (bpf_int32)ntohs(0x07FF));
	b1 = gen_cmp_nl(base_off + 2 + 1 + offset_lh,
	    BPF_H, (bpf_int32)ntohs(addr));
	gen_and(tmp, b1);
	/* Check for pad = 0, long header case */
	tmp = gen_mcmp_nl(base_off + 2, BPF_B, (bpf_int32)0x06, (bpf_int32)0x7);
	b2 = gen_cmp_nl(base_off + 2 + offset_lh, BPF_H, (bpf_int32)ntohs(addr));
	gen_and(tmp, b2);
	gen_or(b2, b1);
	/* Check for pad = 1, short header case */
	tmp = gen_mcmp_nl(base_off + 2, BPF_H,
		       (bpf_int32)ntohs(0x0281), (bpf_int32)ntohs(0x07FF));
	b2 = gen_cmp_nl(base_off + 2 + 1 + offset_sh,
	    BPF_H, (bpf_int32)ntohs(addr));
	gen_and(tmp, b2);
	gen_or(b2, b1);
	/* Check for pad = 0, short header case */
	tmp = gen_mcmp_nl(base_off + 2, BPF_B, (bpf_int32)0x02, (bpf_int32)0x7);
	b2 = gen_cmp_nl(base_off + 2 + offset_sh, BPF_H, (bpf_int32)ntohs(addr));
	gen_and(tmp, b2);
	gen_or(b2, b1);

	/* Combine with test for linktype */
	gen_and(b0, b1);
	return b1;
}

static struct block *
gen_host(addr, mask, proto, dir)
	bpf_u_int32 addr;
	bpf_u_int32 mask;
	int proto;
	int dir;
{
	struct block *b0, *b1;

	switch (proto) {

	case Q_DEFAULT:
		b0 = gen_host(addr, mask, Q_IP, dir);
		b1 = gen_host(addr, mask, Q_ARP, dir);
		gen_or(b0, b1);
		b0 = gen_host(addr, mask, Q_RARP, dir);
		gen_or(b1, b0);
		return b0;

	case Q_IP:
		return gen_hostop(addr, mask, dir, ETHERTYPE_IP,
				  12, 16);

	case Q_RARP:
		return gen_hostop(addr, mask, dir, ETHERTYPE_REVARP,
				  14, 24);

	case Q_ARP:
		return gen_hostop(addr, mask, dir, ETHERTYPE_ARP,
				  14, 24);

	case Q_TCP:
		bpf_error("'tcp' modifier applied to host");

	case Q_UDP:
		bpf_error("'udp' modifier applied to host");

	case Q_ICMP:
		bpf_error("'icmp' modifier applied to host");

	case Q_IGMP:
		bpf_error("'igmp' modifier applied to host");

	case Q_IGRP:
		bpf_error("'igrp' modifier applied to host");

	case Q_PIM:
		bpf_error("'pim' modifier applied to host");

	case Q_STP:
		bpf_error("'stp' modifier applied to host");

	case Q_ATALK:
		bpf_error("ATALK host filtering not implemented");

	case Q_DECNET:
		return gen_dnhostop(addr, dir, 0);

	case Q_SCA:
		bpf_error("SCA host filtering not implemented");

	case Q_LAT:
		bpf_error("LAT host filtering not implemented");

	case Q_MOPDL:
		bpf_error("MOPDL host filtering not implemented");

	case Q_MOPRC:
		bpf_error("MOPRC host filtering not implemented");

#ifdef INET6
	case Q_IPV6:
		bpf_error("'ip6' modifier applied to ip host");

	case Q_ICMPV6:
		bpf_error("'icmp6' modifier applied to host");
#endif /* INET6 */

	case Q_AH:
		bpf_error("'ah' modifier applied to host");

	case Q_ESP:
		bpf_error("'esp' modifier applied to host");

	default:
		bpf_error("direction not supported on linktype 0x%x",
		    linktype);
	}
	/* NOTREACHED */
}

#ifdef INET6
static struct block *
gen_host6(addr, mask, proto, dir)
	struct in6_addr *addr;
	struct in6_addr *mask;
	int proto;
	int dir;
{
	switch (proto) {

	case Q_DEFAULT:
		return gen_host6(addr, mask, Q_IPV6, dir);

	case Q_IP:
		bpf_error("'ip' modifier applied to ip6 host");

	case Q_RARP:
		bpf_error("'rarp' modifier applied to ip6 host");

	case Q_ARP:
		bpf_error("'arp' modifier applied to ip6 host");

	case Q_TCP:
		bpf_error("'tcp' modifier applied to host");

	case Q_UDP:
		bpf_error("'udp' modifier applied to host");

	case Q_ICMP:
		bpf_error("'icmp' modifier applied to host");

	case Q_IGMP:
		bpf_error("'igmp' modifier applied to host");

	case Q_IGRP:
		bpf_error("'igrp' modifier applied to host");

	case Q_PIM:
		bpf_error("'pim' modifier applied to host");

	case Q_STP:
		bpf_error("'stp' modifier applied to host");

	case Q_ATALK:
		bpf_error("ATALK host filtering not implemented");

	case Q_DECNET:
		bpf_error("'decnet' modifier applied to ip6 host");

	case Q_SCA:
		bpf_error("SCA host filtering not implemented");

	case Q_LAT:
		bpf_error("LAT host filtering not implemented");

	case Q_MOPDL:
		bpf_error("MOPDL host filtering not implemented");

	case Q_MOPRC:
		bpf_error("MOPRC host filtering not implemented");

	case Q_IPV6:
		return gen_hostop6(addr, mask, dir, ETHERTYPE_IPV6,
				   8, 24);

	case Q_ICMPV6:
		bpf_error("'icmp6' modifier applied to host");

	case Q_AH:
		bpf_error("'ah' modifier applied to host");

	case Q_ESP:
		bpf_error("'esp' modifier applied to host");

	default:
		abort();
	}
	/* NOTREACHED */
}
#endif /*INET6*/

#ifndef INET6
static struct block *
gen_gateway(eaddr, alist, proto, dir)
	const u_char *eaddr;
	bpf_u_int32 **alist;
	int proto;
	int dir;
{
	struct block *b0, *b1, *tmp;

	if (dir != 0)
		bpf_error("direction applied to 'gateway'");

	switch (proto) {
	case Q_DEFAULT:
	case Q_IP:
	case Q_ARP:
	case Q_RARP:
		if (linktype == DLT_EN10MB)
			b0 = gen_ehostop(eaddr, Q_OR);
		else if (linktype == DLT_FDDI)
			b0 = gen_fhostop(eaddr, Q_OR);
		else
			bpf_error(
			    "'gateway' supported only on ethernet or FDDI");

		b1 = gen_host(**alist++, 0xffffffff, proto, Q_OR);
		while (*alist) {
			tmp = gen_host(**alist++, 0xffffffff, proto, Q_OR);
			gen_or(b1, tmp);
			b1 = tmp;
		}
		gen_not(b1);
		gen_and(b0, b1);
		return b1;
	}
	bpf_error("illegal modifier of 'gateway'");
	/* NOTREACHED */
}
#endif	/*INET6*/

struct block *
gen_proto_abbrev(proto)
	int proto;
{
	struct block *b0 = NULL, *b1;

	switch (proto) {

	case Q_TCP:
		b1 = gen_proto(IPPROTO_TCP, Q_IP, Q_DEFAULT);
#ifdef INET6
		b0 = gen_proto(IPPROTO_TCP, Q_IPV6, Q_DEFAULT);
		gen_or(b0, b1);
#endif
		break;

	case Q_UDP:
		b1 = gen_proto(IPPROTO_UDP, Q_IP, Q_DEFAULT);
#ifdef INET6
		b0 = gen_proto(IPPROTO_UDP, Q_IPV6, Q_DEFAULT);
		gen_or(b0, b1);
#endif
		break;

	case Q_ICMP:
		b1 = gen_proto(IPPROTO_ICMP, Q_IP, Q_DEFAULT);
		break;

#ifndef	IPPROTO_IGMP
#define	IPPROTO_IGMP	2
#endif

	case Q_IGMP:
		b1 = gen_proto(IPPROTO_IGMP, Q_IP, Q_DEFAULT);
		break;

#ifndef	IPPROTO_IGRP
#define	IPPROTO_IGRP	9
#endif
	case Q_IGRP:
		b1 = gen_proto(IPPROTO_IGRP, Q_IP, Q_DEFAULT);
		break;

#ifndef IPPROTO_PIM
#define IPPROTO_PIM	103
#endif

	case Q_PIM:
		b1 = gen_proto(IPPROTO_PIM, Q_IP, Q_DEFAULT);
#ifdef INET6
		b0 = gen_proto(IPPROTO_PIM, Q_IPV6, Q_DEFAULT);
		gen_or(b0, b1);
#endif
		break;

	case Q_IP:
		b1 =  gen_linktype(ETHERTYPE_IP);
		break;

	case Q_ARP:
		b1 =  gen_linktype(ETHERTYPE_ARP);
		break;

	case Q_RARP:
		b1 =  gen_linktype(ETHERTYPE_REVARP);
		break;

	case Q_LINK:
		bpf_error("link layer applied in wrong context");

	case Q_ATALK:
		b1 =  gen_linktype(ETHERTYPE_ATALK);
		break;

	case Q_DECNET:
		b1 =  gen_linktype(ETHERTYPE_DN);
		break;

	case Q_SCA:
		b1 =  gen_linktype(ETHERTYPE_SCA);
		break;

	case Q_LAT:
		b1 =  gen_linktype(ETHERTYPE_LAT);
		break;

	case Q_MOPDL:
		b1 =  gen_linktype(ETHERTYPE_MOPDL);
		break;

	case Q_MOPRC:
		b1 =  gen_linktype(ETHERTYPE_MOPRC);
		break;

	case Q_STP:
		b1 = gen_linktype(LLCSAP_8021D);
		break;

#ifdef INET6
	case Q_IPV6:
		b1 = gen_linktype(ETHERTYPE_IPV6);
		break;

#ifndef IPPROTO_ICMPV6
#define IPPROTO_ICMPV6	58
#endif
	case Q_ICMPV6:
		b1 = gen_proto(IPPROTO_ICMPV6, Q_IPV6, Q_DEFAULT);
		break;
#endif /* INET6 */

#ifndef IPPROTO_AH
#define IPPROTO_AH	51
#endif
	case Q_AH:
		b1 = gen_proto(IPPROTO_AH, Q_IP, Q_DEFAULT);
#ifdef INET6
		b0 = gen_proto(IPPROTO_AH, Q_IPV6, Q_DEFAULT);
		gen_or(b0, b1);
#endif
		break;

#ifndef IPPROTO_ESP
#define IPPROTO_ESP	50
#endif
	case Q_ESP:
		b1 = gen_proto(IPPROTO_ESP, Q_IP, Q_DEFAULT);
#ifdef INET6
		b0 = gen_proto(IPPROTO_ESP, Q_IPV6, Q_DEFAULT);
		gen_or(b0, b1);
#endif
		break;

	default:
		abort();
	}
	return b1;
}

static struct block *
gen_ipfrag()
{
	struct slist *s, *tmp;
	struct block *b;

	/* not ip frag */
	if (variable_nl) {
		s = nl2X_stmt();
		tmp = new_stmt(BPF_LD|BPF_H|BPF_IND);
		tmp->s.k = 6;
		sappend(s, tmp);
	} else {
		s = new_stmt(BPF_LD|BPF_H|BPF_ABS);
		s->s.k = off_nl + 6;
	}
	b = new_block(JMP(BPF_JSET));
	b->s.k = 0x1fff;
	b->stmts = s;
	gen_not(b);

	return b;
}

/* For dynamic off_nl, the BPF_LDX|BPF_MSH instruction does not work
   This function generates code to set X to the start of the IP payload
   X = off_nl + IP header_len.
*/
static struct slist *
iphl_to_x(void)
{
	struct slist *s, *tmp;

	/* XXX clobbers A if variable_nl*/
	if (variable_nl) {
		if (iphl_reg == -1) {
			/* X <- off_nl */
			s = nl2X_stmt();

			/* A = p[X+0] */
			tmp = new_stmt(BPF_LD|BPF_B|BPF_IND);
			tmp->s.k = 0;
			sappend(s, tmp);

			/* A = A & 0x0f */
			tmp = new_stmt(BPF_ALU|BPF_AND|BPF_K);
			tmp->s.k = 0x0f;
			sappend(s, tmp);

			/* A = A << 2 */
			tmp = new_stmt(BPF_ALU|BPF_LSH|BPF_K);
			tmp->s.k = 2;
			sappend(s, tmp);

			/* A = A + X (add off_nl again to compansate) */
			sappend(s, new_stmt(BPF_ALU|BPF_ADD|BPF_X));
			
			/* MEM[iphl_reg] = A */
			iphl_reg = alloc_reg();
			tmp = new_stmt(BPF_ST);
			tmp->s.k = iphl_reg;
			sappend(s, tmp);

			sappend(init_code, s);
		}
		s = new_stmt(BPF_LDX|BPF_MEM);
		s->s.k = iphl_reg;

	} else {
		s = new_stmt(BPF_LDX|BPF_MSH|BPF_B);
		s->s.k = off_nl;
	}

	return s;
}

static struct block *
gen_portatom(off, v)
	int off;
	bpf_int32 v;
{
	struct slist *s, *tmp;
	struct block *b;

	s = iphl_to_x();

	tmp = new_stmt(BPF_LD|BPF_IND|BPF_H);
	tmp->s.k = off_nl + off;	/* off_nl == 0 if variable_nl */
	sappend(s, tmp);

	b = new_block(JMP(BPF_JEQ));
	b->stmts = s;
	b->s.k = v;

	return b;
}

#ifdef INET6
static struct block *
gen_portatom6(off, v)
	int off;
	bpf_int32 v;
{
	return gen_cmp_nl(40 + off, BPF_H, v);
}
#endif/*INET6*/

struct block *
gen_portop(port, proto, dir)
	int port, proto, dir;
{
	struct block *b0, *b1, *tmp;

	/* ip proto 'proto' */
	tmp = gen_cmp_nl(9, BPF_B, (bpf_int32)proto);
	b0 = gen_ipfrag();
	gen_and(tmp, b0);

	switch (dir) {
	case Q_SRC:
		b1 = gen_portatom(0, (bpf_int32)port);
		break;

	case Q_DST:
		b1 = gen_portatom(2, (bpf_int32)port);
		break;

	case Q_OR:
	case Q_DEFAULT:
		tmp = gen_portatom(0, (bpf_int32)port);
		b1 = gen_portatom(2, (bpf_int32)port);
		gen_or(tmp, b1);
		break;

	case Q_AND:
		tmp = gen_portatom(0, (bpf_int32)port);
		b1 = gen_portatom(2, (bpf_int32)port);
		gen_and(tmp, b1);
		break;

	default:
		abort();
	}
	gen_and(b0, b1);

	return b1;
}

static struct block *
gen_port(port, ip_proto, dir)
	int port;
	int ip_proto;
	int dir;
{
	struct block *b0, *b1, *tmp;

	/* ether proto ip */
	b0 =  gen_linktype(ETHERTYPE_IP);

	switch (ip_proto) {
	case IPPROTO_UDP:
	case IPPROTO_TCP:
		b1 = gen_portop(port, ip_proto, dir);
		break;

	case PROTO_UNDEF:
		tmp = gen_portop(port, IPPROTO_TCP, dir);
		b1 = gen_portop(port, IPPROTO_UDP, dir);
		gen_or(tmp, b1);
		break;

	default:
		abort();
	}
	gen_and(b0, b1);
	return b1;
}

#ifdef INET6
struct block *
gen_portop6(port, proto, dir)
	int port, proto, dir;
{
	struct block *b0, *b1, *tmp;

	/* ip proto 'proto' */
	b0 = gen_cmp_nl(6, BPF_B, (bpf_int32)proto);

	switch (dir) {
	case Q_SRC:
		b1 = gen_portatom6(0, (bpf_int32)port);
		break;

	case Q_DST:
		b1 = gen_portatom6(2, (bpf_int32)port);
		break;

	case Q_OR:
	case Q_DEFAULT:
		tmp = gen_portatom6(0, (bpf_int32)port);
		b1 = gen_portatom6(2, (bpf_int32)port);
		gen_or(tmp, b1);
		break;

	case Q_AND:
		tmp = gen_portatom6(0, (bpf_int32)port);
		b1 = gen_portatom6(2, (bpf_int32)port);
		gen_and(tmp, b1);
		break;

	default:
		abort();
	}
	gen_and(b0, b1);

	return b1;
}

static struct block *
gen_port6(port, ip_proto, dir)
	int port;
	int ip_proto;
	int dir;
{
	struct block *b0, *b1, *tmp;

	/* ether proto ip */
	b0 =  gen_linktype(ETHERTYPE_IPV6);

	switch (ip_proto) {
	case IPPROTO_UDP:
	case IPPROTO_TCP:
		b1 = gen_portop6(port, ip_proto, dir);
		break;

	case PROTO_UNDEF:
		tmp = gen_portop6(port, IPPROTO_TCP, dir);
		b1 = gen_portop6(port, IPPROTO_UDP, dir);
		gen_or(tmp, b1);
		break;

	default:
		abort();
	}
	gen_and(b0, b1);
	return b1;
}
#endif /* INET6 */

static int
lookup_proto(name, proto)
	const char *name;
	int proto;
{
	int v;

	switch (proto) {

	case Q_DEFAULT:
	case Q_IP:
		v = pcap_nametoproto(name);
		if (v == PROTO_UNDEF)
			bpf_error("unknown ip proto '%s'", name);
		break;

	case Q_LINK:
		/* XXX should look up h/w protocol type based on linktype */
		v = pcap_nametoeproto(name);
		if (v == PROTO_UNDEF) {
			v = pcap_nametollc(name);
			if (v == PROTO_UNDEF)
				bpf_error("unknown ether proto '%s'", name);
		}
		break;

	default:
		v = PROTO_UNDEF;
		break;
	}
	return v;
}

static struct block *
gen_protochain(v, proto, dir)
	int v;
	int proto;
	int dir;
{
	struct block *b0, *b;
	struct slist *s[100];
	int fix2, fix3, fix4, fix5;
	int ahcheck, again, end;
	int i, max;
	int reg1 = alloc_reg();
	int reg2 = alloc_reg();

	memset(s, 0, sizeof(s));
	fix2 = fix3 = fix4 = fix5 = 0;

	if (variable_nl) {
		bpf_error("'gen_protochain' not supported for variable DLTs");
		/*NOTREACHED*/
	}

	switch (proto) {
	case Q_IP:
	case Q_IPV6:
		break;
	case Q_DEFAULT:
		b0 = gen_protochain(v, Q_IP, dir);
		b = gen_protochain(v, Q_IPV6, dir);
		gen_or(b0, b);
		return b;
	default:
		bpf_error("bad protocol applied for 'protochain'");
		/*NOTREACHED*/
	}

	no_optimize = 1; /*this code is not compatible with optimzer yet */

	/*
	 * s[0] is a dummy entry to protect other BPF insn from damaged
	 * by s[fix] = foo with uninitialized variable "fix".  It is somewhat
	 * hard to find interdependency made by jump table fixup.
	 */
	i = 0;
	s[i] = new_stmt(0);	/*dummy*/
	i++;

	switch (proto) {
	case Q_IP:
		b0 = gen_linktype(ETHERTYPE_IP);

		/* A = ip->ip_p */
		s[i] = new_stmt(BPF_LD|BPF_ABS|BPF_B);
		s[i]->s.k = off_nl + 9;
		i++;
		/* X = ip->ip_hl << 2 */
		s[i] = new_stmt(BPF_LDX|BPF_MSH|BPF_B);
		s[i]->s.k = off_nl;
		i++;
		break;
	case Q_IPV6:
		b0 = gen_linktype(ETHERTYPE_IPV6);

		/* A = ip6->ip_nxt */
		s[i] = new_stmt(BPF_LD|BPF_ABS|BPF_B);
		s[i]->s.k = off_nl + 6;
		i++;
		/* X = sizeof(struct ip6_hdr) */
		s[i] = new_stmt(BPF_LDX|BPF_IMM);
		s[i]->s.k = 40;
		i++;
		break;
	default:
		bpf_error("unsupported proto to gen_protochain");
		/*NOTREACHED*/
	}

	/* again: if (A == v) goto end; else fall through; */
	again = i;
	s[i] = new_stmt(BPF_JMP|BPF_JEQ|BPF_K);
	s[i]->s.k = v;
	s[i]->s.jt = NULL;		/*later*/
	s[i]->s.jf = NULL;		/*update in next stmt*/
	fix5 = i;
	i++;

	/* if (A == IPPROTO_NONE) goto end */
	s[i] = new_stmt(BPF_JMP|BPF_JEQ|BPF_K);
	s[i]->s.jt = NULL;	/*later*/
	s[i]->s.jf = NULL;	/*update in next stmt*/
	s[i]->s.k = IPPROTO_NONE;
	s[fix5]->s.jf = s[i];
	fix2 = i;
	i++;

	if (proto == Q_IPV6) {
		int v6start, v6end, v6advance, j;

		v6start = i;
		/* if (A == IPPROTO_HOPOPTS) goto v6advance */
		s[i] = new_stmt(BPF_JMP|BPF_JEQ|BPF_K);
		s[i]->s.jt = NULL;	/*later*/
		s[i]->s.jf = NULL;	/*update in next stmt*/
		s[i]->s.k = IPPROTO_HOPOPTS;
		s[fix2]->s.jf = s[i];
		i++;
		/* if (A == IPPROTO_DSTOPTS) goto v6advance */
		s[i - 1]->s.jf = s[i] = new_stmt(BPF_JMP|BPF_JEQ|BPF_K);
		s[i]->s.jt = NULL;	/*later*/
		s[i]->s.jf = NULL;	/*update in next stmt*/
		s[i]->s.k = IPPROTO_DSTOPTS;
		i++;
		/* if (A == IPPROTO_ROUTING) goto v6advance */
		s[i - 1]->s.jf = s[i] = new_stmt(BPF_JMP|BPF_JEQ|BPF_K);
		s[i]->s.jt = NULL;	/*later*/
		s[i]->s.jf = NULL;	/*update in next stmt*/
		s[i]->s.k = IPPROTO_ROUTING;
		i++;
		/* if (A == IPPROTO_FRAGMENT) goto v6advance; else goto ahcheck; */
		s[i - 1]->s.jf = s[i] = new_stmt(BPF_JMP|BPF_JEQ|BPF_K);
		s[i]->s.jt = NULL;	/*later*/
		s[i]->s.jf = NULL;	/*later*/
		s[i]->s.k = IPPROTO_FRAGMENT;
		fix3 = i;
		v6end = i;
		i++;

		/* v6advance: */
		v6advance = i;

		/*
		 * in short,
		 * A = P[X + 1];
		 * X = X + (P[X] + 1) * 8;
		 */
		/* A = X */
		s[i] = new_stmt(BPF_MISC|BPF_TXA);
		i++;
		/* MEM[reg1] = A */
		s[i] = new_stmt(BPF_ST);
		s[i]->s.k = reg1;
		i++;
		/* A += 1 */
		s[i] = new_stmt(BPF_ALU|BPF_ADD|BPF_K);
		s[i]->s.k = 1;
		i++;
		/* X = A */
		s[i] = new_stmt(BPF_MISC|BPF_TAX);
		i++;
		/* A = P[X + packet head]; */
		s[i] = new_stmt(BPF_LD|BPF_IND|BPF_B);
		s[i]->s.k = off_nl;
		i++;
		/* MEM[reg2] = A */
		s[i] = new_stmt(BPF_ST);
		s[i]->s.k = reg2;
		i++;
		/* X = MEM[reg1] */
		s[i] = new_stmt(BPF_LDX|BPF_MEM);
		s[i]->s.k = reg1;
		i++;
		/* A = P[X + packet head] */
		s[i] = new_stmt(BPF_LD|BPF_IND|BPF_B);
		s[i]->s.k = off_nl;
		i++;
		/* A += 1 */
		s[i] = new_stmt(BPF_ALU|BPF_ADD|BPF_K);
		s[i]->s.k = 1;
		i++;
		/* A *= 8 */
		s[i] = new_stmt(BPF_ALU|BPF_MUL|BPF_K);
		s[i]->s.k = 8;
		i++;
		/* X = A; */
		s[i] = new_stmt(BPF_MISC|BPF_TAX);
		i++;
		/* A = MEM[reg2] */
		s[i] = new_stmt(BPF_LD|BPF_MEM);
		s[i]->s.k = reg2;
		i++;

		/* goto again; (must use BPF_JA for backward jump) */
		s[i] = new_stmt(BPF_JMP|BPF_JA);
		s[i]->s.k = again - i - 1;
		s[i - 1]->s.jf = s[i];
		i++;

		/* fixup */
		for (j = v6start; j <= v6end; j++)
			s[j]->s.jt = s[v6advance];
	} else {
		/* nop */
		s[i] = new_stmt(BPF_ALU|BPF_ADD|BPF_K);
		s[i]->s.k = 0;
		s[fix2]->s.jf = s[i];
		i++;
	}

	/* ahcheck: */
	ahcheck = i;
	/* if (A == IPPROTO_AH) then fall through; else goto end; */
	s[i] = new_stmt(BPF_JMP|BPF_JEQ|BPF_K);
	s[i]->s.jt = NULL;	/*later*/
	s[i]->s.jf = NULL;	/*later*/
	s[i]->s.k = IPPROTO_AH;
	if (fix3)
		s[fix3]->s.jf = s[ahcheck];
	fix4 = i;
	i++;

	/*
	 * in short,
	 * A = P[X + 1];
	 * X = X + (P[X] + 2) * 4;
	 */
	/* A = X */
	s[i - 1]->s.jt = s[i] = new_stmt(BPF_MISC|BPF_TXA);
	i++;
	/* MEM[reg1] = A */
	s[i] = new_stmt(BPF_ST);
	s[i]->s.k = reg1;
	i++;
	/* A += 1 */
	s[i] = new_stmt(BPF_ALU|BPF_ADD|BPF_K);
	s[i]->s.k = 1;
	i++;
	/* X = A */
	s[i] = new_stmt(BPF_MISC|BPF_TAX);
	i++;
	/* A = P[X + packet head]; */
	s[i] = new_stmt(BPF_LD|BPF_IND|BPF_B);
	s[i]->s.k = off_nl;
	i++;
	/* MEM[reg2] = A */
	s[i] = new_stmt(BPF_ST);
	s[i]->s.k = reg2;
	i++;
	/* X = MEM[reg1] */
	s[i] = new_stmt(BPF_LDX|BPF_MEM);
	s[i]->s.k = reg1;
	i++;
	/* A = P[X + packet head] */
	s[i] = new_stmt(BPF_LD|BPF_IND|BPF_B);
	s[i]->s.k = off_nl;
	i++;
	/* A += 2 */
	s[i] = new_stmt(BPF_ALU|BPF_ADD|BPF_K);
	s[i]->s.k = 2;
	i++;
	/* A *= 4 */
	s[i] = new_stmt(BPF_ALU|BPF_MUL|BPF_K);
	s[i]->s.k = 4;
	i++;
	/* X = A; */
	s[i] = new_stmt(BPF_MISC|BPF_TAX);
	i++;
	/* A = MEM[reg2] */
	s[i] = new_stmt(BPF_LD|BPF_MEM);
	s[i]->s.k = reg2;
	i++;

	/* goto again; (must use BPF_JA for backward jump) */
	s[i] = new_stmt(BPF_JMP|BPF_JA);
	s[i]->s.k = again - i - 1;
	i++;

	/* end: nop */
	end = i;
	s[i] = new_stmt(BPF_ALU|BPF_ADD|BPF_K);
	s[i]->s.k = 0;
	s[fix2]->s.jt = s[end];
	s[fix4]->s.jf = s[end];
	s[fix5]->s.jt = s[end];
	i++;

	/*
	 * make slist chain
	 */
	max = i;
	for (i = 0; i < max - 1; i++)
		s[i]->next = s[i + 1];
	s[max - 1]->next = NULL;

	/*
	 * emit final check
	 */
	b = new_block(JMP(BPF_JEQ));
	b->stmts = s[1];	/*remember, s[0] is dummy*/
	b->s.k = v;

	free_reg(reg1);
	free_reg(reg2);

	gen_and(b0, b);
	return b;
}

static struct block *
gen_proto(v, proto, dir)
	int v;
	int proto;
	int dir;
{
	struct block *b0, *b1;

	if (dir != Q_DEFAULT)
		bpf_error("direction applied to 'proto'");

	switch (proto) {
	case Q_DEFAULT:
#ifdef INET6
		b0 = gen_proto(v, Q_IP, dir);
		b1 = gen_proto(v, Q_IPV6, dir);
		gen_or(b0, b1);
		return b1;
#else
		/*FALLTHROUGH*/
#endif
	case Q_IP:
		b0 = gen_linktype(ETHERTYPE_IP);
#ifndef CHASE_CHAIN
		b1 = gen_cmp_nl(9, BPF_B, (bpf_int32)v);
#else
		b1 = gen_protochain(v, Q_IP);
#endif
		gen_and(b0, b1);
		return b1;

	case Q_ARP:
		bpf_error("arp does not encapsulate another protocol");
		/* NOTREACHED */

	case Q_RARP:
		bpf_error("rarp does not encapsulate another protocol");
		/* NOTREACHED */

	case Q_ATALK:
		bpf_error("atalk encapsulation is not specifiable");
		/* NOTREACHED */

	case Q_DECNET:
		bpf_error("decnet encapsulation is not specifiable");
		/* NOTREACHED */

	case Q_SCA:
		bpf_error("sca does not encapsulate another protocol");
		/* NOTREACHED */

	case Q_LAT:
		bpf_error("lat does not encapsulate another protocol");
		/* NOTREACHED */

	case Q_MOPRC:
		bpf_error("moprc does not encapsulate another protocol");
		/* NOTREACHED */

	case Q_MOPDL:
		bpf_error("mopdl does not encapsulate another protocol");
		/* NOTREACHED */

	case Q_LINK:
		return gen_linktype(v);

	case Q_UDP:
		bpf_error("'udp proto' is bogus");
		/* NOTREACHED */

	case Q_TCP:
		bpf_error("'tcp proto' is bogus");
		/* NOTREACHED */

	case Q_ICMP:
		bpf_error("'icmp proto' is bogus");
		/* NOTREACHED */

	case Q_IGMP:
		bpf_error("'igmp proto' is bogus");
		/* NOTREACHED */

	case Q_IGRP:
		bpf_error("'igrp proto' is bogus");
		/* NOTREACHED */

	case Q_PIM:
		bpf_error("'pim proto' is bogus");
		/* NOTREACHED */

	case Q_STP:
		bpf_error("'stp proto' is bogus");
		/* NOTREACHED */

#ifdef INET6
	case Q_IPV6:
		b0 = gen_linktype(ETHERTYPE_IPV6);
#ifndef CHASE_CHAIN
		b1 = gen_cmp_nl(6, BPF_B, (bpf_int32)v);
#else
		b1 = gen_protochain(v, Q_IPV6);
#endif
		gen_and(b0, b1);
		return b1;

	case Q_ICMPV6:
		bpf_error("'icmp6 proto' is bogus");
#endif /* INET6 */

	case Q_AH:
		bpf_error("'ah proto' is bogus");

	case Q_ESP:
		bpf_error("'ah proto' is bogus");

	default:
		abort();
		/* NOTREACHED */
	}
	/* NOTREACHED */
}

struct block *
gen_scode(name, q)
	const char *name;
	struct qual q;
{
	int proto = q.proto;
	int dir = q.dir;
	int tproto;
	u_char *eaddr;
	bpf_u_int32 mask, addr;
#ifndef INET6
	bpf_u_int32 **alist;
#else
	int tproto6;
	struct sockaddr_in *sin;
	struct sockaddr_in6 *sin6;
	struct addrinfo *res, *res0;
	struct in6_addr mask128;
#endif /*INET6*/
	struct block *b, *tmp;
	int port, real_proto;

	switch (q.addr) {

	case Q_NET:
		addr = pcap_nametonetaddr(name);
		if (addr == 0)
			bpf_error("unknown network '%s'", name);
		/* Left justify network addr and calculate its network mask */
		mask = 0xffffffff;
		while (addr && (addr & 0xff000000) == 0) {
			addr <<= 8;
			mask <<= 8;
		}
		return gen_host(addr, mask, proto, dir);

	case Q_DEFAULT:
	case Q_HOST:
		if (proto == Q_LINK) {
			switch (linktype) {

			case DLT_EN10MB:
				eaddr = pcap_ether_hostton(name);
				if (eaddr == NULL)
					bpf_error(
					    "unknown ether host '%s'", name);
				return gen_ehostop(eaddr, dir);

			case DLT_FDDI:
				eaddr = pcap_ether_hostton(name);
				if (eaddr == NULL)
					bpf_error(
					    "unknown FDDI host '%s'", name);
				return gen_fhostop(eaddr, dir);

			case DLT_IEEE802_11:
			case DLT_IEEE802_11_RADIO:
				eaddr = pcap_ether_hostton(name);
				if (eaddr == NULL)
					bpf_error(
					    "unknown 802.11 host '%s'", name);

				return gen_p80211_hostop(eaddr, dir);

			default:
				bpf_error(
			"only ethernet/FDDI supports link-level host name");
				break;
			}
		} else if (proto == Q_DECNET) {
			unsigned short dn_addr = __pcap_nametodnaddr(name);
			/*
			 * I don't think DECNET hosts can be multihomed, so
			 * there is no need to build up a list of addresses
			 */
			return (gen_host(dn_addr, 0, proto, dir));
		} else {
#ifndef INET6
			alist = pcap_nametoaddr(name);
			if (alist == NULL || *alist == NULL)
				bpf_error("unknown host '%s'", name);
			tproto = proto;
			if (off_linktype == -1 && tproto == Q_DEFAULT)
				tproto = Q_IP;
			b = gen_host(**alist++, 0xffffffff, tproto, dir);
			while (*alist) {
				tmp = gen_host(**alist++, 0xffffffff,
					       tproto, dir);
				gen_or(b, tmp);
				b = tmp;
			}
			return b;
#else
			memset(&mask128, 0xff, sizeof(mask128));
			res0 = res = pcap_nametoaddrinfo(name);
			if (res == NULL)
				bpf_error("unknown host '%s'", name);
			b = tmp = NULL;
			tproto = tproto6 = proto;
			if (off_linktype == -1 && tproto == Q_DEFAULT) {
				tproto = Q_IP;
				tproto6 = Q_IPV6;
			}
			for (res = res0; res; res = res->ai_next) {
				switch (res->ai_family) {
				case AF_INET:
					if (tproto == Q_IPV6)
						continue;

					sin = (struct sockaddr_in *)
						res->ai_addr;
					tmp = gen_host(ntohl(sin->sin_addr.s_addr),
						0xffffffff, tproto, dir);
					break;
				case AF_INET6:
					if (tproto6 == Q_IP)
						continue;

					sin6 = (struct sockaddr_in6 *)
						res->ai_addr;
					tmp = gen_host6(&sin6->sin6_addr,
						&mask128, tproto6, dir);
					break;
				}
				if (b)
					gen_or(b, tmp);
				b = tmp;
			}
			freeaddrinfo(res0);
			if (b == NULL) {
				bpf_error("unknown host '%s'%s", name,
				    (proto == Q_DEFAULT)
					? ""
					: " for specified address family");
			}
			return b;
#endif /*INET6*/
		}

	case Q_PORT:
		if (proto != Q_DEFAULT && proto != Q_UDP && proto != Q_TCP)
			bpf_error("illegal qualifier of 'port'");
		if (pcap_nametoport(name, &port, &real_proto) == 0)
			bpf_error("unknown port '%s'", name);
		if (proto == Q_UDP) {
			if (real_proto == IPPROTO_TCP)
				bpf_error("port '%s' is tcp", name);
			else
				/* override PROTO_UNDEF */
				real_proto = IPPROTO_UDP;
		}
		if (proto == Q_TCP) {
			if (real_proto == IPPROTO_UDP)
				bpf_error("port '%s' is udp", name);
			else
				/* override PROTO_UNDEF */
				real_proto = IPPROTO_TCP;
		}
#ifndef INET6
		return gen_port(port, real_proto, dir);
#else
	    {
		struct block *b;
		b = gen_port(port, real_proto, dir);
		gen_or(gen_port6(port, real_proto, dir), b);
		return b;
	    }
#endif /* INET6 */

	case Q_GATEWAY:
#ifndef INET6
		eaddr = pcap_ether_hostton(name);
		if (eaddr == NULL)
			bpf_error("unknown ether host: %s", name);

		alist = pcap_nametoaddr(name);
		if (alist == NULL || *alist == NULL)
			bpf_error("unknown host '%s'", name);
		return gen_gateway(eaddr, alist, proto, dir);
#else
		bpf_error("'gateway' not supported in this configuration");
#endif /*INET6*/

	case Q_PROTO:
		real_proto = lookup_proto(name, proto);
		if (real_proto >= 0)
			return gen_proto(real_proto, proto, dir);
		else
			bpf_error("unknown protocol: %s", name);

	case Q_PROTOCHAIN:
		real_proto = lookup_proto(name, proto);
		if (real_proto >= 0)
			return gen_protochain(real_proto, proto, dir);
		else
			bpf_error("unknown protocol: %s", name);


	case Q_UNDEF:
		syntax();
		/* NOTREACHED */
	}
	abort();
	/* NOTREACHED */
}

struct block *
gen_mcode(s1, s2, masklen, q)
	const char *s1, *s2;
	int masklen;
	struct qual q;
{
	int nlen, mlen;
	bpf_u_int32 n, m;

	nlen = __pcap_atoin(s1, &n);
	/* Promote short ipaddr */
	n <<= 32 - nlen;

	if (s2 != NULL) {
		mlen = __pcap_atoin(s2, &m);
		/* Promote short ipaddr */
		m <<= 32 - mlen;
		if ((n & ~m) != 0)
			bpf_error("non-network bits set in \"%s mask %s\"",
			    s1, s2);
	} else {
		/* Convert mask len to mask */
		if (masklen > 32)
			bpf_error("mask length must be <= 32");
		m = 0xffffffff << (32 - masklen);
		if ((n & ~m) != 0)
			bpf_error("non-network bits set in \"%s/%d\"",
			    s1, masklen);
	}

	switch (q.addr) {

	case Q_NET:
		return gen_host(n, m, q.proto, q.dir);

	default:
		bpf_error("Mask syntax for networks only");
		/* NOTREACHED */
	}
}

struct block *
gen_ncode(s, v, q)
	const char *s;
	bpf_u_int32 v;
	struct qual q;
{
	bpf_u_int32 mask;
	int proto = q.proto;
	int dir = q.dir;
	int vlen;

	if (s == NULL)
		vlen = 32;
	else if (q.proto == Q_DECNET)
		vlen = __pcap_atodn(s, &v);
	else
		vlen = __pcap_atoin(s, &v);

	switch (q.addr) {

	case Q_DEFAULT:
	case Q_HOST:
	case Q_NET:
		if (proto == Q_DECNET)
			return gen_host(v, 0, proto, dir);
		else if (proto == Q_LINK) {
			bpf_error("illegal link layer address");
		} else {
			mask = 0xffffffff;
			if (s == NULL && q.addr == Q_NET) {
				/* Promote short net number */
				while (v && (v & 0xff000000) == 0) {
					v <<= 8;
					mask <<= 8;
				}
			} else {
				/* Promote short ipaddr */
				v <<= 32 - vlen;
				mask <<= 32 - vlen;
			}
			return gen_host(v, mask, proto, dir);
		}

	case Q_PORT:
		if (proto == Q_UDP)
			proto = IPPROTO_UDP;
		else if (proto == Q_TCP)
			proto = IPPROTO_TCP;
		else if (proto == Q_DEFAULT)
			proto = PROTO_UNDEF;
		else
			bpf_error("illegal qualifier of 'port'");

#ifndef INET6
		return gen_port((int)v, proto, dir);
#else
	    {
		struct block *b;
		b = gen_port((int)v, proto, dir);
		gen_or(gen_port6((int)v, proto, dir), b);
		return b;
	    }
#endif /* INET6 */

	case Q_GATEWAY:
		bpf_error("'gateway' requires a name");
		/* NOTREACHED */

	case Q_PROTO:
		return gen_proto((int)v, proto, dir);

	case Q_PROTOCHAIN:
		return gen_protochain((int)v, proto, dir);

	case Q_UNDEF:
		syntax();
		/* NOTREACHED */

	default:
		abort();
		/* NOTREACHED */
	}
	/* NOTREACHED */
}

#ifdef INET6
struct block *
gen_mcode6(s1, s2, masklen, q)
	const char *s1, *s2;
	int masklen;
	struct qual q;
{
	struct addrinfo *res;
	struct in6_addr *addr;
	struct in6_addr mask;
	struct block *b;
	u_int32_t *a, *m;

	if (s2)
		bpf_error("no mask %s supported", s2);

	res = pcap_nametoaddrinfo(s1);
	if (!res)
		bpf_error("invalid ip6 address %s", s1);
	if (res->ai_next)
		bpf_error("%s resolved to multiple address", s1);
	addr = &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;

	if (sizeof(mask) * 8 < masklen)
		bpf_error("mask length must be <= %u", (unsigned int)(sizeof(mask) * 8));
	memset(&mask, 0, sizeof(mask));
	memset(&mask, 0xff, masklen / 8);
	if (masklen % 8) {
		mask.s6_addr[masklen / 8] =
			(0xff << (8 - masklen % 8)) & 0xff;
	}

	a = (u_int32_t *)addr;
	m = (u_int32_t *)&mask;
	if ((a[0] & ~m[0]) || (a[1] & ~m[1])
	 || (a[2] & ~m[2]) || (a[3] & ~m[3])) {
		bpf_error("non-network bits set in \"%s/%d\"", s1, masklen);
	}

	switch (q.addr) {

	case Q_DEFAULT:
	case Q_HOST:
		if (masklen != 128)
			bpf_error("Mask syntax for networks only");
		/* FALLTHROUGH */

	case Q_NET:
		b = gen_host6(addr, &mask, q.proto, q.dir);
		freeaddrinfo(res);
		return b;

	default:
		bpf_error("invalid qualifier against IPv6 address");
		/* NOTREACHED */
	}
}
#endif /*INET6*/

struct block *
gen_ecode(eaddr, q)
	const u_char *eaddr;
	struct qual q;
{
	if ((q.addr == Q_HOST || q.addr == Q_DEFAULT) && q.proto == Q_LINK) {
		if (linktype == DLT_EN10MB)
			return gen_ehostop(eaddr, (int)q.dir);
		if (linktype == DLT_FDDI)
			return gen_fhostop(eaddr, (int)q.dir);
		if (linktype == DLT_IEEE802_11 ||
		    linktype == DLT_IEEE802_11_RADIO)
			return gen_p80211_hostop(eaddr, (int)q.dir);
	}
	bpf_error("ethernet address used in non-ether expression");
	/* NOTREACHED */
}

void
sappend(s0, s1)
	struct slist *s0, *s1;
{
	/*
	 * This is definitely not the best way to do this, but the
	 * lists will rarely get long.
	 */
	while (s0->next)
		s0 = s0->next;
	s0->next = s1;
}

static struct slist *
xfer_to_x(a)
	struct arth *a;
{
	struct slist *s;

	s = new_stmt(BPF_LDX|BPF_MEM);
	s->s.k = a->regno;
	return s;
}

static struct slist *
xfer_to_a(a)
	struct arth *a;
{
	struct slist *s;

	s = new_stmt(BPF_LD|BPF_MEM);
	s->s.k = a->regno;
	return s;
}

struct arth *
gen_load(proto, index, size)
	int proto;
	struct arth *index;
	int size;
{
	struct slist *s, *tmp;
	struct block *b;
	int regno = alloc_reg();

	free_reg(index->regno);
	switch (size) {

	default:
		bpf_error("data size must be 1, 2, or 4");

	case 1:
		size = BPF_B;
		break;

	case 2:
		size = BPF_H;
		break;

	case 4:
		size = BPF_W;
		break;
	}
	switch (proto) {
	default:
		bpf_error("unsupported index operation");

	case Q_LINK:
		s = xfer_to_x(index);
		tmp = new_stmt(BPF_LD|BPF_IND|size);
		sappend(s, tmp);
		sappend(index->s, s);
		break;

	case Q_IP:
	case Q_ARP:
	case Q_RARP:
	case Q_ATALK:
	case Q_DECNET:
	case Q_SCA:
	case Q_LAT:
	case Q_MOPRC:
	case Q_MOPDL:
#ifdef INET6
	case Q_IPV6:
#endif
		/* XXX Note that we assume a fixed link header here. */
		if (variable_nl) {
			s = nl2X_stmt();
			sappend(s, xfer_to_a(index));
			sappend(s, new_stmt(BPF_ALU|BPF_ADD|BPF_X));
			sappend(s, new_stmt(BPF_MISC|BPF_TAX));
		} else {
			s = xfer_to_x(index);
		}
		tmp = new_stmt(BPF_LD|BPF_IND|size);
		tmp->s.k = off_nl;	/* off_nl == 0 for variable_nl */
		sappend(s, tmp);
		sappend(index->s, s);

		b = gen_proto_abbrev(proto);
		if (index->b)
			gen_and(index->b, b);
		index->b = b;
		break;

	case Q_TCP:
	case Q_UDP:
	case Q_ICMP:
	case Q_IGMP:
	case Q_IGRP:
	case Q_PIM:
		s = iphl_to_x();
		sappend(s, xfer_to_a(index));
		sappend(s, new_stmt(BPF_ALU|BPF_ADD|BPF_X));
		sappend(s, new_stmt(BPF_MISC|BPF_TAX));
		sappend(s, tmp = new_stmt(BPF_LD|BPF_IND|size));
		tmp->s.k = off_nl;	/* off_nl is 0 if variable_nl */
		sappend(index->s, s);

		gen_and(gen_proto_abbrev(proto), b = gen_ipfrag());
		if (index->b)
			gen_and(index->b, b);
#ifdef INET6
		gen_and(gen_proto_abbrev(Q_IP), b);
#endif
		index->b = b;
		break;
#ifdef INET6
	case Q_ICMPV6:
		bpf_error("IPv6 upper-layer protocol is not supported by proto[x]");
		/*NOTREACHED*/
#endif
	}
	index->regno = regno;
	s = new_stmt(BPF_ST);
	s->s.k = regno;
	sappend(index->s, s);

	return index;
}

struct block *
gen_relation(code, a0, a1, reversed)
	int code;
	struct arth *a0, *a1;
	int reversed;
{
	struct slist *s0, *s1, *s2;
	struct block *b, *tmp;

	s0 = xfer_to_x(a1);
	s1 = xfer_to_a(a0);
	s2 = new_stmt(BPF_ALU|BPF_SUB|BPF_X);
	b = new_block(JMP(code));
	if (code == BPF_JGT || code == BPF_JGE) {
		reversed = !reversed;
		b->s.k = 0x80000000;
	}
	if (reversed)
		gen_not(b);

	sappend(s1, s2);
	sappend(s0, s1);
	sappend(a1->s, s0);
	sappend(a0->s, a1->s);

	b->stmts = a0->s;

	free_reg(a0->regno);
	free_reg(a1->regno);

	/* 'and' together protocol checks */
	if (a0->b) {
		if (a1->b) {
			gen_and(a0->b, tmp = a1->b);
		}
		else
			tmp = a0->b;
	} else
		tmp = a1->b;

	if (tmp)
		gen_and(tmp, b);

	return b;
}

struct arth *
gen_loadlen()
{
	int regno = alloc_reg();
	struct arth *a = (struct arth *)newchunk(sizeof(*a));
	struct slist *s;

	s = new_stmt(BPF_LD|BPF_LEN);
	s->next = new_stmt(BPF_ST);
	s->next->s.k = regno;
	a->s = s;
	a->regno = regno;

	return a;
}

struct arth *
gen_loadi(val)
	int val;
{
	struct arth *a;
	struct slist *s;
	int reg;

	a = (struct arth *)newchunk(sizeof(*a));

	reg = alloc_reg();

	s = new_stmt(BPF_LD|BPF_IMM);
	s->s.k = val;
	s->next = new_stmt(BPF_ST);
	s->next->s.k = reg;
	a->s = s;
	a->regno = reg;

	return a;
}

struct arth *
gen_neg(a)
	struct arth *a;
{
	struct slist *s;

	s = xfer_to_a(a);
	sappend(a->s, s);
	s = new_stmt(BPF_ALU|BPF_NEG);
	s->s.k = 0;
	sappend(a->s, s);
	s = new_stmt(BPF_ST);
	s->s.k = a->regno;
	sappend(a->s, s);

	return a;
}

struct arth *
gen_arth(code, a0, a1)
	int code;
	struct arth *a0, *a1;
{
	struct slist *s0, *s1, *s2;

	s0 = xfer_to_x(a1);
	s1 = xfer_to_a(a0);
	s2 = new_stmt(BPF_ALU|BPF_X|code);

	sappend(s1, s2);
	sappend(s0, s1);
	sappend(a1->s, s0);
	sappend(a0->s, a1->s);

	free_reg(a1->regno);

	s0 = new_stmt(BPF_ST);
	a0->regno = s0->s.k = alloc_reg();
	sappend(a0->s, s0);

	return a0;
}

/*
 * Here we handle simple allocation of the scratch registers.
 * If too many registers are alloc'd, the allocator punts.
 */
static int regused[BPF_MEMWORDS];
static int curreg;

/*
 * Return the next free register.
 */
static int
alloc_reg()
{
	int n = BPF_MEMWORDS;

	while (--n >= 0) {
		if (regused[curreg])
			curreg = (curreg + 1) % BPF_MEMWORDS;
		else {
			regused[curreg] = 1;
			return curreg;
		}
	}
	bpf_error("too many registers needed to evaluate expression");
	/* NOTREACHED */
}

/*
 * Return a register to the table so it can
 * be used later.
 */
static void
free_reg(n)
	int n;
{
	regused[n] = 0;
}

static struct block *
gen_len(jmp, n)
	int jmp, n;
{
	struct slist *s;
	struct block *b;

	s = new_stmt(BPF_LD|BPF_LEN);
	b = new_block(JMP(jmp));
	b->stmts = s;
	b->s.k = n;

	return b;
}

struct block *
gen_greater(n)
	int n;
{
	return gen_len(BPF_JGE, n);
}

struct block *
gen_less(n)
	int n;
{
	struct block *b;

	b = gen_len(BPF_JGT, n);
	gen_not(b);

	return b;
}

struct block *
gen_byteop(op, idx, val)
	int op, idx, val;
{
	struct block *b;
	struct slist *s;

	switch (op) {
	default:
		abort();

	case '=':
		return gen_cmp((u_int)idx, BPF_B, (bpf_int32)val);

	case '<':
		b = gen_cmp((u_int)idx, BPF_B, (bpf_int32)val);
		b->s.code = JMP(BPF_JGE);
		gen_not(b);
		return b;

	case '>':
		b = gen_cmp((u_int)idx, BPF_B, (bpf_int32)val);
		b->s.code = JMP(BPF_JGT);
		return b;

	case '|':
		s = new_stmt(BPF_ALU|BPF_OR|BPF_K);
		break;

	case '&':
		s = new_stmt(BPF_ALU|BPF_AND|BPF_K);
		break;
	}
	s->s.k = val;
	b = new_block(JMP(BPF_JEQ));
	b->stmts = s;
	gen_not(b);

	return b;
}

struct block *
gen_broadcast(proto)
	int proto;
{
	bpf_u_int32 hostmask;
	struct block *b0, *b1, *b2;
	static u_char ebroadcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

	switch (proto) {

	case Q_DEFAULT:
	case Q_LINK:
		if (linktype == DLT_EN10MB)
			return gen_ehostop(ebroadcast, Q_DST);
		if (linktype == DLT_FDDI)
			return gen_fhostop(ebroadcast, Q_DST);
		if (linktype == DLT_IEEE802_11 ||
		    linktype == DLT_IEEE802_11_RADIO)
			return gen_p80211_hostop(ebroadcast, Q_DST);
		bpf_error("not a broadcast link");
		break;

	case Q_IP:
		b0 = gen_linktype(ETHERTYPE_IP);
		hostmask = ~netmask;
		b1 = gen_mcmp_nl(16, BPF_W, (bpf_int32)0, hostmask);
		b2 = gen_mcmp_nl(16, BPF_W,
			      (bpf_int32)(~0 & hostmask), hostmask);
		gen_or(b1, b2);
		gen_and(b0, b2);
		return b2;
	}
	bpf_error("only ether/ip broadcast filters supported");
}

struct block *
gen_multicast(proto)
	int proto;
{
	struct block *b0, *b1;
	struct slist *s;

	switch (proto) {

	case Q_DEFAULT:
	case Q_LINK:
		if (linktype == DLT_EN10MB) {
			/* ether[0] & 1 != 0 */
			s = new_stmt(BPF_LD|BPF_B|BPF_ABS);
			s->s.k = 0;
			b0 = new_block(JMP(BPF_JSET));
			b0->s.k = 1;
			b0->stmts = s;
			return b0;
		}

		if (linktype == DLT_FDDI) {
			/* XXX TEST THIS: MIGHT NOT PORT PROPERLY XXX */
			/* fddi[1] & 1 != 0 */
			s = new_stmt(BPF_LD|BPF_B|BPF_ABS);
			s->s.k = 1;
			b0 = new_block(JMP(BPF_JSET));
			b0->s.k = 1;
			b0->stmts = s;
			return b0;
		}
		/* Link not known to support multicasts */
		break;

	case Q_IP:
		b0 = gen_linktype(ETHERTYPE_IP);
		b1 = gen_cmp_nl(16, BPF_B, (bpf_int32)224);
		b1->s.code = JMP(BPF_JGE);
		gen_and(b0, b1);
		return b1;

#ifdef INET6
	case Q_IPV6:
		b0 = gen_linktype(ETHERTYPE_IPV6);
		b1 = gen_cmp_nl(24, BPF_B, (bpf_int32)255);
		gen_and(b0, b1);
		return b1;
#endif /* INET6 */
	}
	bpf_error("only IP multicast filters supported on ethernet/FDDI");
}

/*
 * generate command for inbound/outbound.  It's here so we can
 * make it link-type specific.  'dir' = 0 implies "inbound",
 * = 1 implies "outbound".
 */
struct block *
gen_inbound(dir)
	int dir;
{
	struct block *b0;

	/*
	 * Only SLIP and old-style PPP data link types support
	 * inbound/outbound qualifiers.
	 */
	switch (linktype) {
	case DLT_SLIP:
	case DLT_PPP:
		b0 = gen_relation(BPF_JEQ,
				  gen_load(Q_LINK, gen_loadi(0), 1),
				  gen_loadi(0),
				  dir);
		break;

	case DLT_PFLOG:
		b0 = gen_cmp(offsetof(struct pfloghdr, dir), BPF_B,
		    (bpf_int32)((dir == 0) ? PF_IN : PF_OUT));
		break;

	default:
		bpf_error("inbound/outbound not supported on linktype 0x%x",
		    linktype);
		/* NOTREACHED */
	}

	return (b0);
}


/* PF firewall log matched interface */
struct block *
gen_pf_ifname(char *ifname)
{
	struct block *b0;
	u_int len, off;

	if (linktype == DLT_PFLOG) {
		len = sizeof(((struct pfloghdr *)0)->ifname);
		off = offsetof(struct pfloghdr, ifname);
	} else {
		bpf_error("ifname not supported on linktype 0x%x", linktype);
		/* NOTREACHED */
	}
	if (strlen(ifname) >= len) {
		bpf_error("ifname interface names can only be %d characters",
		    len - 1);
		/* NOTREACHED */
	}
	b0 = gen_bcmp(off, strlen(ifname), ifname);
	return (b0);
}


/* PF firewall log ruleset name */
struct block *
gen_pf_ruleset(char *ruleset)
{
	struct block *b0;

	if (linktype != DLT_PFLOG) {
		bpf_error("ruleset not supported on linktype 0x%x", linktype);
		/* NOTREACHED */
	}
	if (strlen(ruleset) >= sizeof(((struct pfloghdr *)0)->ruleset)) {
		bpf_error("ruleset names can only be %zu characters",
		    sizeof(((struct pfloghdr *)0)->ruleset) - 1);
		/* NOTREACHED */
	}
	b0 = gen_bcmp(offsetof(struct pfloghdr, ruleset),
	    strlen(ruleset), ruleset);
	return (b0);
}


/* PF firewall log rule number */
struct block *
gen_pf_rnr(int rnr)
{
	struct block *b0;

	if (linktype == DLT_PFLOG) {
		b0 = gen_cmp(offsetof(struct pfloghdr, rulenr), BPF_W,
			 (bpf_int32)rnr);
	} else {
		bpf_error("rnr not supported on linktype 0x%x", linktype);
		/* NOTREACHED */
	}

	return (b0);
}


/* PF firewall log sub-rule number */
struct block *
gen_pf_srnr(int srnr)
{
	struct block *b0;

	if (linktype != DLT_PFLOG) {
		bpf_error("srnr not supported on linktype 0x%x", linktype);
		/* NOTREACHED */
	}

	b0 = gen_cmp(offsetof(struct pfloghdr, subrulenr), BPF_W,
	    (bpf_int32)srnr);
	return (b0);
}

/* PF firewall log reason code */
struct block *
gen_pf_reason(int reason)
{
	struct block *b0;

	if (linktype == DLT_PFLOG) {
		b0 = gen_cmp(offsetof(struct pfloghdr, reason), BPF_B,
		    (bpf_int32)reason);
	} else {
		bpf_error("reason not supported on linktype 0x%x", linktype);
		/* NOTREACHED */
	}

	return (b0);
}

/* PF firewall log action */
struct block *
gen_pf_action(int action)
{
	struct block *b0;

	if (linktype == DLT_PFLOG) {
		b0 = gen_cmp(offsetof(struct pfloghdr, action), BPF_B,
		    (bpf_int32)action);
	} else {
		bpf_error("action not supported on linktype 0x%x", linktype);
		/* NOTREACHED */
	}

	return (b0);
}

/* IEEE 802.11 wireless header */
struct block *
gen_p80211_type(int type, int mask)
{
	struct block *b0;
	u_int offset;

	if (!(linktype == DLT_IEEE802_11 ||
	    linktype == DLT_IEEE802_11_RADIO)) {
		bpf_error("type not supported on linktype 0x%x",
		    linktype);
		/* NOTREACHED */
	}
	offset = (u_int)offsetof(struct ieee80211_frame, i_fc[0]);
	if (linktype == DLT_IEEE802_11_RADIO)
		offset += IEEE80211_RADIOTAP_HDRLEN;

	b0 = gen_mcmp(offset, BPF_B, (bpf_int32)type, (bpf_u_int32)mask);

	return (b0);
}

static struct block *
gen_ahostop(eaddr, dir)
	const u_char *eaddr;
	int dir;
{
	struct block *b0, *b1;

	switch (dir) {
	/* src comes first, different from Ethernet */
	case Q_SRC:
		return gen_bcmp(0, 1, eaddr);

	case Q_DST:
		return gen_bcmp(1, 1, eaddr);

	case Q_AND:
		b0 = gen_ahostop(eaddr, Q_SRC);
		b1 = gen_ahostop(eaddr, Q_DST);
		gen_and(b0, b1);
		return b1;

	case Q_DEFAULT:
	case Q_OR:
		b0 = gen_ahostop(eaddr, Q_SRC);
		b1 = gen_ahostop(eaddr, Q_DST);
		gen_or(b0, b1);
		return b1;
	}
	abort();
	/* NOTREACHED */
}

struct block *
gen_acode(eaddr, q)
	const u_char *eaddr;
	struct qual q;
{
	if ((q.addr == Q_HOST || q.addr == Q_DEFAULT) && q.proto == Q_LINK) {
		if (linktype == DLT_ARCNET)
			return gen_ahostop(eaddr, (int)q.dir);
	}
	bpf_error("ARCnet address used in non-arc expression");
	/* NOTREACHED */
}

/*
 * support IEEE 802.1Q VLAN trunk over ethernet
 */
struct block *
gen_vlan(vlan_num)
	int vlan_num;
{
	struct	block	*b0;

	if (variable_nl) {
		bpf_error("'vlan' not supported for variable DLTs");
		/*NOTREACHED*/
	}

	/*
	 * Change the offsets to point to the type and data fields within
	 * the VLAN packet.  This is somewhat of a kludge.
	 */
	if (orig_nl == (u_int)-1) {
		orig_linktype = off_linktype;	/* save original values */
		orig_nl = off_nl;
		orig_nl_nosnap = off_nl_nosnap;

		switch (linktype) {

		case DLT_EN10MB:
			off_linktype = 16;
			off_nl_nosnap = 18;
			off_nl = 18;
			break;

		default:
			bpf_error("no VLAN support for data link type %d",
				  linktype);
			/*NOTREACHED*/
		}
	}

	/* check for VLAN */
	b0 = gen_cmp(orig_linktype, BPF_H, (bpf_int32)ETHERTYPE_8021Q);

	/* If a specific VLAN is requested, check VLAN id */
	if (vlan_num >= 0) {
		struct block *b1;

		b1 = gen_cmp(orig_nl, BPF_H, (bpf_int32)vlan_num);
		gen_and(b0, b1);
		b0 = b1;
	}

	return (b0);
}

struct block *
gen_p80211_fcdir(int fcdir)
{
	struct block *b0;
	u_int offset;

	if (!(linktype == DLT_IEEE802_11 ||
	    linktype == DLT_IEEE802_11_RADIO)) {
		bpf_error("frame direction not supported on linktype 0x%x",
		    linktype);
		/* NOTREACHED */
	}
	offset = (u_int)offsetof(struct ieee80211_frame, i_fc[1]);
	if (linktype == DLT_IEEE802_11_RADIO)
		offset += IEEE80211_RADIOTAP_HDRLEN;

	b0 = gen_mcmp(offset, BPF_B, (bpf_int32)fcdir,
	    (bpf_u_int32)IEEE80211_FC1_DIR_MASK);

	return (b0);
}

static struct block *
gen_p80211_hostop(const u_char *lladdr, int dir)
{
	struct block *b0, *b1, *b2, *b3, *b4;
	u_int offset = 0;

	if (linktype == DLT_IEEE802_11_RADIO)
		offset = IEEE80211_RADIOTAP_HDRLEN;

	switch (dir) {
	case Q_SRC:
		b0 = gen_p80211_addr(IEEE80211_FC1_DIR_NODS, offset +
		    (u_int)offsetof(struct ieee80211_frame, i_addr2),
		    lladdr);
		b1 = gen_p80211_addr(IEEE80211_FC1_DIR_TODS, offset +
		    (u_int)offsetof(struct ieee80211_frame, i_addr2),
		    lladdr);
		b2 = gen_p80211_addr(IEEE80211_FC1_DIR_FROMDS, offset +
		    (u_int)offsetof(struct ieee80211_frame, i_addr3),
		    lladdr);
		b3 = gen_p80211_addr(IEEE80211_FC1_DIR_DSTODS, offset +
		    (u_int)offsetof(struct ieee80211_frame_addr4, i_addr4),
		    lladdr);
		b4 = gen_p80211_addr(IEEE80211_FC1_DIR_DSTODS, offset +
		    (u_int)offsetof(struct ieee80211_frame_addr4, i_addr2),
		    lladdr);

		gen_or(b0, b1);
		gen_or(b1, b2);
		gen_or(b2, b3);
		gen_or(b3, b4);
		return (b4);

	case Q_DST:
		b0 = gen_p80211_addr(IEEE80211_FC1_DIR_NODS, offset +
		    (u_int)offsetof(struct ieee80211_frame, i_addr1),
		    lladdr);
		b1 = gen_p80211_addr(IEEE80211_FC1_DIR_TODS, offset +
		    (u_int)offsetof(struct ieee80211_frame, i_addr3),
		    lladdr);
		b2 = gen_p80211_addr(IEEE80211_FC1_DIR_FROMDS, offset +
		    (u_int)offsetof(struct ieee80211_frame, i_addr1),
		    lladdr);
		b3 = gen_p80211_addr(IEEE80211_FC1_DIR_DSTODS, offset +
		    (u_int)offsetof(struct ieee80211_frame_addr4, i_addr3),
		    lladdr);
		b4 = gen_p80211_addr(IEEE80211_FC1_DIR_DSTODS, offset +
		    (u_int)offsetof(struct ieee80211_frame_addr4, i_addr1),
		    lladdr);

		gen_or(b0, b1);
		gen_or(b1, b2);
		gen_or(b2, b3);
		gen_or(b3, b4);
		return (b4);

	case Q_ADDR1:
		return (gen_bcmp(offset +
		    (u_int)offsetof(struct ieee80211_frame,
		    i_addr1), IEEE80211_ADDR_LEN, lladdr));

	case Q_ADDR2:
		return (gen_bcmp(offset +
		    (u_int)offsetof(struct ieee80211_frame,
		    i_addr2), IEEE80211_ADDR_LEN, lladdr));

	case Q_ADDR3:
		return (gen_bcmp(offset +
		    (u_int)offsetof(struct ieee80211_frame,
		    i_addr3), IEEE80211_ADDR_LEN, lladdr));

	case Q_ADDR4:
		return (gen_p80211_addr(IEEE80211_FC1_DIR_DSTODS, offset +
		    (u_int)offsetof(struct ieee80211_frame_addr4, i_addr4),
		    lladdr));

	case Q_AND:
		b0 = gen_p80211_hostop(lladdr, Q_SRC);
		b1 = gen_p80211_hostop(lladdr, Q_DST);
		gen_and(b0, b1);
		return (b1);

	case Q_DEFAULT:
	case Q_OR:
		b0 = gen_p80211_hostop(lladdr, Q_ADDR1);
		b1 = gen_p80211_hostop(lladdr, Q_ADDR2);
		b2 = gen_p80211_hostop(lladdr, Q_ADDR3);
		b3 = gen_p80211_hostop(lladdr, Q_ADDR4);
		gen_or(b0, b1);
		gen_or(b1, b2);
		gen_or(b2, b3);
		return (b3);

	default:
		bpf_error("direction not supported on linktype 0x%x",
		    linktype);
	}
	/* NOTREACHED */
}

static struct block *
gen_p80211_addr(int fcdir, u_int offset, const u_char *lladdr)
{
	struct block *b0, *b1;

	b0 = gen_mcmp(offset, BPF_B, (bpf_int32)fcdir, IEEE80211_FC1_DIR_MASK);
	b1 = gen_bcmp(offset, IEEE80211_ADDR_LEN, lladdr);
	gen_and(b0, b1);

	return (b1);
}
@


1.45
log
@Add new DLT_OPENFLOW link-type to allow using tcpdump to debug switch(4),
eg. tcpdump -y openflow -i switch0

Includes a minor bump for libpcap.

Feedback and OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.44 2015/12/22 19:51:04 mmcc Exp $	*/
d787 1
a787 1
		off_nl = 4;
@


1.44
log
@remove NULL-checks before free()
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.43 2015/11/17 21:39:23 mmcc Exp $	*/
d781 5
@


1.43
log
@Remove register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.42 2015/11/17 18:19:45 mmcc Exp $	*/
d211 4
a214 5
	for (i = 0; i < NCHUNKS; ++i)
		if (chunks[i].m != NULL) {
			free(chunks[i].m);
			chunks[i].m = NULL;
		}
@


1.42
log
@memory.h -> string.h

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.41 2015/09/27 05:25:00 guenther Exp $	*/
d223 1
a223 1
	register const char *s;
d413 1
a413 1
	register struct block **p = &b0;
d552 2
a553 2
	register u_int offset, size;
	register const u_char *v;
d555 1
a555 1
	register struct block *b, *tmp;
d559 1
a559 1
		register const u_char *p = &v[size - 4];
d570 1
a570 1
		register const u_char *p = &v[size - 2];
d824 1
a824 1
	register int proto;
d1028 2
a1029 2
	register const u_char *eaddr;
	register int dir;
d1064 2
a1065 2
	register const u_char *eaddr;
	register int dir;
d1795 2
a1796 2
	register const char *name;
	register int proto;
d1798 1
a1798 1
	register int v;
d2247 1
a2247 1
	register const char *name;
d2453 2
a2454 2
	register const char *s1, *s2;
	register int masklen;
d2457 1
a2457 1
	register int nlen, mlen;
d2494 1
a2494 1
	register const char *s;
d2501 1
a2501 1
	register int vlen;
d2580 2
a2581 2
	register const char *s1, *s2;
	register int masklen;
d2638 1
a2638 1
	register const u_char *eaddr;
d3075 2
a3076 2
	register struct block *b0, *b1;
	register struct slist *s;
d3132 1
a3132 1
	register struct block *b0;
d3299 2
a3300 2
	register const u_char *eaddr;
	register int dir;
d3302 1
a3302 1
	register struct block *b0, *b1;
d3331 1
a3331 1
	register const u_char *eaddr;
@


1.41
log
@lint is dead: delete the trivial uses of /* VARARGS[0-9]+ */
(others require more care)
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.40 2015/01/16 16:48:51 deraadt Exp $	*/
a44 1
#include <memory.h>
d47 1
@


1.40
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.39 2014/11/20 14:51:41 krw Exp $	*/
a79 1
/* VARARGS */
@


1.39
log
@Yet more #include de-duplication.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.38 2014/03/14 03:45:41 lteo Exp $	*/
d24 1
@


1.38
log
@Remove pointless casts.  No binary change.

suggested by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.37 2014/03/14 03:44:13 lteo Exp $	*/
a56 1
#include <sys/socket.h>
@


1.37
log
@Change a few malloc+memset calls to calloc.

ok deraadt@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.36 2010/10/09 08:14:36 canacar Exp $	*/
d194 1
a194 1
		cp->m = (void *)calloc(1, size);
@


1.36
log
@Fix typo in pflog header size computation. Fixes filtering with the new
pflog headers. reported by jmc@@, tested by jmc@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.35 2010/09/08 02:04:47 krw Exp $	*/
d194 1
a194 1
		cp->m = (void *)malloc(size);
d197 1
a197 2
		
		memset((char *)cp->m, 0, size);
@


1.35
log
@Make tcpdump of pflog interfaces work with 'net <net>' expression.

My problem, canacar@@'s fix.

ok sthen@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.34 2010/07/27 04:13:34 canacar Exp $	*/
d621 1
a621 1
			tmp->s.k = 0xf6;
@


1.34
log
@Properly handle the size field in pflog link header
when generating the filter. This will allow the pflog
header to be extended without adding a new link type.

No change to generated code for other link types.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.33 2010/06/26 16:47:07 henning Exp $	*/
d529 1
a529 1
		b->stmts->next = s;
d547 1
a547 1
		b->stmts->next = s;
@


1.33
log
@remove support for the old pflog format, replaced in 2003
ok ryan theo & herr reyksminister
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.32 2009/09/18 23:32:13 bluhm Exp $	*/
d102 7
d136 1
d138 1
d433 16
d534 18
d601 71
d677 2
d779 2
a780 2
		/* XXX read from header? */
		off_nl = PFLOG_HDRLEN;
d968 1
a968 1
	b1 = gen_mcmp(offset, BPF_W, (bpf_int32)addr, mask);
d1015 2
a1016 2
	b1 = gen_mcmp(offset + 12, BPF_W, ntohl(a[3]), ntohl(m[3]));
	b0 = gen_mcmp(offset + 8, BPF_W, ntohl(a[2]), ntohl(m[2]));
d1018 1
a1018 1
	b0 = gen_mcmp(offset + 4, BPF_W, ntohl(a[1]), ntohl(m[1]));
d1020 1
a1020 1
	b0 = gen_mcmp(offset + 0, BPF_W, ntohl(a[0]), ntohl(m[0]));
d1166 3
a1168 3
	tmp = gen_mcmp(base_off + 2, BPF_H,
	    (bpf_int32)ntohs(0x0681), (bpf_int32)ntohs(0x07FF));
	b1 = gen_cmp(base_off + 2 + 1 + offset_lh,
d1172 2
a1173 2
	tmp = gen_mcmp(base_off + 2, BPF_B, (bpf_int32)0x06, (bpf_int32)0x7);
	b2 = gen_cmp(base_off + 2 + offset_lh, BPF_H, (bpf_int32)ntohs(addr));
d1177 3
a1179 3
	tmp = gen_mcmp(base_off + 2, BPF_H,
	    (bpf_int32)ntohs(0x0281), (bpf_int32)ntohs(0x07FF));
	b2 = gen_cmp(base_off + 2 + 1 + offset_sh,
d1184 2
a1185 2
	tmp = gen_mcmp(base_off + 2, BPF_B, (bpf_int32)0x02, (bpf_int32)0x7);
	b2 = gen_cmp(base_off + 2 + offset_sh, BPF_H, (bpf_int32)ntohs(addr));
d1215 1
a1215 1
				  off_nl + 12, off_nl + 16);
d1219 1
a1219 1
				  off_nl + 14, off_nl + 24);
d1223 1
a1223 1
				  off_nl + 14, off_nl + 24);
d1250 1
a1250 1
		return gen_dnhostop(addr, dir, off_nl);
d1348 1
a1348 1
				  off_nl + 8, off_nl + 24);
d1549 1
a1549 1
	struct slist *s;
d1553 9
a1561 2
	s = new_stmt(BPF_LD|BPF_H|BPF_ABS);
	s->s.k = off_nl + 6;
d1570 52
d1627 1
a1627 1
	struct slist *s;
d1630 1
a1630 2
	s = new_stmt(BPF_LDX|BPF_MSH|BPF_B);
	s->s.k = off_nl;
d1632 3
a1634 2
	s->next = new_stmt(BPF_LD|BPF_IND|BPF_H);
	s->next->s.k = off_nl + off;
d1649 1
a1649 1
	return gen_cmp(off_nl + 40 + off, BPF_H, v);
d1660 1
a1660 1
	tmp = gen_cmp(off_nl + 9, BPF_B, (bpf_int32)proto);
d1732 1
a1732 1
	b0 = gen_cmp(off_nl + 6, BPF_B, (bpf_int32)proto);
d1845 5
d2149 1
a2149 1
		b1 = gen_cmp(off_nl + 9, BPF_B, (bpf_int32)v);
d2223 1
a2223 1
		b1 = gen_cmp(off_nl + 6, BPF_B, (bpf_int32)v);
d2743 8
a2750 1
		s = xfer_to_x(index);
d2752 1
a2752 1
		tmp->s.k = off_nl;
d2768 1
a2768 2
		s = new_stmt(BPF_LDX|BPF_MSH|BPF_B);
		s->s.k = off_nl;
d2773 1
a2773 1
		tmp->s.k = off_nl;
d3063 2
a3064 2
		b1 = gen_mcmp(off_nl + 16, BPF_W, (bpf_int32)0, hostmask);
		b2 = gen_mcmp(off_nl + 16, BPF_W,
d3109 1
a3109 1
		b1 = gen_cmp(off_nl + 16, BPF_B, (bpf_int32)224);
d3117 1
a3117 1
		b1 = gen_cmp(off_nl + 24, BPF_B, (bpf_int32)255);
d3352 5
@


1.32
log
@Zero out IPv6 mask before using it.  This fixes expressions like
'net 2002::/16', which were previously non-deterministic based on
the previous contents of memory.
from upstream;  ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.31 2008/06/15 02:49:14 deraadt Exp $	*/
a660 5
	case DLT_OLD_PFLOG:
		off_linktype = 0;
		off_nl = 28;
		return;

a796 11
	case DLT_OLD_PFLOG:
		if (proto == ETHERTYPE_IP)
			return (gen_cmp(0, BPF_W, (bpf_int32)AF_INET));
#ifdef INET6
		else if (proto == ETHERTYPE_IPV6)
			return (gen_cmp(0, BPF_W, (bpf_int32)AF_INET6));
#endif /* INET6 */
		else
			return gen_false();
		break;

a2967 5
	case DLT_OLD_PFLOG:
		b0 = gen_cmp(offsetof(struct old_pfloghdr, dir), BPF_H,
		    (bpf_int32)((dir == 0) ? PF_IN : PF_OUT));
		break;

a2987 3
	} else if (linktype == DLT_OLD_PFLOG) {
		len = sizeof(((struct old_pfloghdr *)0)->ifname);
		off = offsetof(struct old_pfloghdr, ifname);
a3031 3
	} else if (linktype == DLT_OLD_PFLOG) {
		b0 = gen_cmp(offsetof(struct old_pfloghdr, rnr), BPF_H,
			 (bpf_int32)rnr);
a3065 3
	} else if (linktype == DLT_OLD_PFLOG) {
		b0 = gen_cmp(offsetof(struct old_pfloghdr, reason), BPF_H,
		    (bpf_int32)reason);
a3081 3
		    (bpf_int32)action);
	} else if (linktype == DLT_OLD_PFLOG) {
		b0 = gen_cmp(offsetof(struct old_pfloghdr, action), BPF_H,
@


1.31
log
@Swap the code for a calling function and what it calls, so that the called
function is in scope and a pointer is not returned via an int
ok dtucker
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.30 2008/06/11 15:02:21 dtucker Exp $	*/
d2440 1
@


1.30
log
@Import vlan support from upstream libpcap.  This allows, eg, "tcpdump vla 3"
to work on a vlan parent interface.  ok mcbride@@, "commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.29 2007/11/06 10:22:29 chl Exp $	*/
a3144 13
struct block *
gen_acode(eaddr, q)
	register const u_char *eaddr;
	struct qual q;
{
	if ((q.addr == Q_HOST || q.addr == Q_DEFAULT) && q.proto == Q_LINK) {
		if (linktype == DLT_ARCNET)
			return gen_ahostop(eaddr, (int)q.dir);
	}
	bpf_error("ARCnet address used in non-arc expression");
	/* NOTREACHED */
}

d3174 13
@


1.29
log
@fix format string

ok ray@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.28 2007/01/02 18:35:17 reyk Exp $	*/
d70 3
d554 2
d3141 93
@


1.28
log
@remove extra \n in bpf_error() calls.

figured out by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.27 2007/01/02 18:31:21 reyk Exp $	*/
d3031 1
a3031 1
		bpf_error("ruleset names can only be %d characters",
@


1.27
log
@define bpf filters to match address and header fields in IEEE 802.11
wlan frames (DLT_IEEE802_11 and DLT_IEEE802_11_RADIO linktypes). see
tcpdump(8) for details.

"Works for me" claudio@@
ok jmc@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.26 2006/07/18 11:52:12 dlg Exp $	*/
d2984 1
a2984 1
		bpf_error("inbound/outbound not supported on linktype 0x%x\n",
d3007 1
a3007 1
		bpf_error("ifname not supported on linktype 0x%x\n", linktype);
d3011 1
a3011 1
		bpf_error("ifname interface names can only be %d characters\n",
d3027 1
a3027 1
		bpf_error("ruleset not supported on linktype 0x%x\n", linktype);
d3031 1
a3031 1
		bpf_error("ruleset names can only be %d characters\n",
d3054 1
a3054 1
		bpf_error("rnr not supported on linktype 0x%x\n", linktype);
d3069 1
a3069 1
		bpf_error("srnr not supported on linktype 0x%x\n", linktype);
d3091 1
a3091 1
		bpf_error("reason not supported on linktype 0x%x\n", linktype);
d3111 1
a3111 1
		bpf_error("action not supported on linktype 0x%x\n", linktype);
@


1.26
log
@get rid of arc network support. we have no users of it so this is dead
code. however, it is still cluttering up the kernel namespace a bit. it is
better gone.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.25 2005/10/07 19:32:39 mpf Exp $	*/
d39 3
d139 2
d632 3
a634 3
	case DLT_IEEE802_11_RADIO:
		off_linktype = 30 + 64; /* XXX variable */
		off_nl = 32 + 64;
d859 2
a860 1
		abort();
d904 2
a905 1
		abort();
d949 3
a952 1
	abort();
d993 3
a996 1
	abort();
d1056 2
a1057 1
		abort();
d1174 2
a1175 1
		abort();
d2133 9
d2478 3
d2878 3
d3116 156
@


1.25
log
@Add Spanning Tree Protocol support.
Bump version to 3.1.
OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.24 2005/06/04 18:00:45 joel Exp $	*/
a34 1
#include <netinet/if_arc.h>
a132 1
static struct block *gen_ahostop(const u_char *, int);
a555 5
	case DLT_ARCNET:
		off_linktype = 2;
		off_nl = 6;	/* XXX in reality, variable! */
		return;

a815 32
	case DLT_ARCNET:
		/*
		 * XXX should we check for first fragment if the protocol
		 * uses PHDS?
		 */
		switch(proto) {
		default:
			return gen_false();
#ifdef INET6
		case ETHERTYPE_IPV6:
			return(gen_cmp(2, BPF_B,
					(bpf_int32)htonl(ARCTYPE_INET6)));
#endif /* INET6 */
		case ETHERTYPE_IP:
			b0 = gen_cmp(2, BPF_B, (bpf_int32)htonl(ARCTYPE_IP));
			b1 = gen_cmp(2, BPF_B,
					(bpf_int32)htonl(ARCTYPE_IP_OLD));
			gen_or(b0, b1);
			return(b1);
		case ETHERTYPE_ARP:
			b0 = gen_cmp(2, BPF_B, (bpf_int32)htonl(ARCTYPE_ARP));
			b1 = gen_cmp(2, BPF_B,
					(bpf_int32)htonl(ARCTYPE_ARP_OLD));
			gen_or(b0, b1);
			return(b1);
		case ETHERTYPE_REVARP:
			return(gen_cmp(2, BPF_B,
					(bpf_int32)htonl(ARCTYPE_REVARP)));
		case ETHERTYPE_ATALK:
			return(gen_cmp(2, BPF_B,
					(bpf_int32)htonl(ARCTYPE_ATALK)));
		}
a2836 2
static u_char abroadcast[] = { 0x0 };

a2848 2
		if (linktype == DLT_ARCNET)
			return gen_ahostop(abroadcast, Q_DST);
a2879 4
		if (linktype == DLT_ARCNET)
			/* all ARCnet multicasts use the same address */
			return gen_ahostop(abroadcast, Q_DST);

a3087 45
}

struct block *
gen_acode(eaddr, q)
	register const u_char *eaddr;
	struct qual q;
{
	if ((q.addr == Q_HOST || q.addr == Q_DEFAULT) && q.proto == Q_LINK) {
		if (linktype == DLT_ARCNET)
			return gen_ahostop(eaddr, (int)q.dir);
	}
	bpf_error("ARCnet address used in non-arc expression");
	/* NOTREACHED */
}

static struct block *
gen_ahostop(eaddr, dir)
	register const u_char *eaddr;
	register int dir;
{
	register struct block *b0, *b1;

	switch (dir) {
	/* src comes first, different from Ethernet */
	case Q_SRC:
		return gen_bcmp(0, 1, eaddr);

	case Q_DST:
		return gen_bcmp(1, 1, eaddr);

	case Q_AND:
		b0 = gen_ahostop(eaddr, Q_SRC);
		b1 = gen_ahostop(eaddr, Q_DST);
		gen_and(b0, b1);
		return b1;

	case Q_DEFAULT:
	case Q_OR:
		b0 = gen_ahostop(eaddr, Q_SRC);
		b1 = gen_ahostop(eaddr, Q_DST);
		gen_or(b0, b1);
		return b1;
	}
	abort();
	/* NOTREACHED */
@


1.24
log
@Fix description in a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.23 2005/02/28 13:19:56 reyk Exp $	*/
d49 1
d123 1
d469 18
d727 14
d1165 3
d1246 3
d1422 4
d1676 5
a1680 2
		if (v == PROTO_UNDEF)
			bpf_error("unknown ether proto '%s'", name);
d2070 4
@


1.23
log
@add DLT_IEEE802_11_RADIO (802.11 + radiotap header)

ok jsg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.22 2004/05/21 05:40:37 brad Exp $	*/
d2988 1
a2988 1
/* PF firewall log matched interface */
@


1.22
log
@add DLT_PPP_ETHER support

ok canacar@@

From: Marc Huber <pppoe at pro-bono-publico dot de>
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.21 2004/01/27 06:58:03 tedu Exp $	*/
d612 5
@


1.21
log
@remove $Header,  it was messing up cvs for me.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.20 2004/01/26 02:20:24 fgsch Exp $	*/
d574 9
d706 1
@


1.20
log
@add DLT_IEEE802_11 support; from NetBSD. bump minor.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.19 2003/05/14 08:50:37 canacar Exp $	*/
a22 4
#ifndef lint
static const char rcsid[] =
    "@@(#) $Header: /cvs/src/lib/libpcap/gencode.c,v 1.19 2003/05/14 08:50:37 canacar Exp $ (LBL)";
#endif
@


1.19
log
@libpcap and tcpdump now understand the new pflog datalink type.
old datalink type is still recognized.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.18 2002/11/29 18:27:54 mickey Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/lib/libpcap/gencode.c,v 1.18 2002/11/29 18:27:54 mickey Exp $ (LBL)";
d602 5
@


1.18
log
@tcpdump support for pfsync; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.17 2002/07/09 17:03:00 provos Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/lib/libpcap/gencode.c,v 1.17 2002/07/09 17:03:00 provos Exp $ (LBL)";
d623 5
d630 2
a631 1
		off_nl = 28;
d749 1
a749 1
	case DLT_PFLOG:
d759 14
d2926 6
a2931 1
		b0 = gen_cmp(offsetof(struct pfloghdr, dir), BPF_H,
d2950 1
d2952 7
a2958 1
	if (linktype != DLT_PFLOG) {
d2962 1
a2962 1
	if (strlen(ifname) >= sizeof(((struct pfloghdr *)0)->ifname)) {
d2964 7
a2970 1
		    sizeof(((struct pfloghdr *)0)->ifname) - 1);
d2972 8
d2982 7
a2988 2
	b0 = gen_bcmp(offsetof(struct pfloghdr, ifname), strlen(ifname),
	    ifname);
d2999 21
d3021 1
a3021 1
		bpf_error("rnr not supported on linktype 0x%x\n", linktype);
d3025 2
a3026 1
	b0 = gen_cmp(offsetof(struct pfloghdr, rnr), BPF_H, (bpf_int32)rnr);
d3036 7
a3042 1
	if (linktype != DLT_PFLOG) {
a3046 2
	b0 = gen_cmp(offsetof(struct pfloghdr, reason), BPF_H,
	    (bpf_int32)reason);
d3056 7
a3062 1
	if (linktype != DLT_PFLOG) {
a3066 2
	b0 = gen_cmp(offsetof(struct pfloghdr, action), BPF_H,
	    (bpf_int32)action);
@


1.17
log
@more error checking of memory allocation, from clodder@@acm.org. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.16 2002/03/23 01:33:16 frantzen Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/lib/libpcap/gencode.c,v 1.16 2002/03/23 01:33:16 frantzen Exp $ (LBL)";
d626 5
@


1.16
log
@language extensions for PF logs.  can specify direction, interface, rule
number, reason and action.  fix the ipv4/ipv6 distinction while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.15 2002/02/19 19:39:37 millert Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/lib/libpcap/gencode.c,v 1.15 2002/02/19 19:39:37 millert Exp $ (LBL)";
d182 3
@


1.15
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.14 2001/12/17 22:29:47 dugsong Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/lib/libpcap/gencode.c,v 1.14 2001/12/17 22:29:47 dugsong Exp $ (LBL)";
d41 3
d45 1
d621 1
a621 1
		off_linktype = -1;
a723 1
	case DLT_PFLOG:
d735 10
d2891 9
a2899 1
		/* These are okay. */
d2908 70
a2977 4
	b0 = gen_relation(BPF_JEQ,
			  gen_load(Q_LINK, gen_loadi(0), 1),
			  gen_loadi(0),
			  dir);
@


1.14
log
@fix memory leak associated with compiled BPF program, sync'd from tcpdump.org. ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.13 2001/06/25 23:03:32 provos Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/lib/libpcap/gencode.c,v 1.13 2001/06/25 23:03:32 provos Exp $ (LBL)";
a31 1
#ifdef __STDC__
a33 1
#endif
a43 1
#ifdef __STDC__
a44 3
#else
#include <varargs.h>
#endif
a75 1
#ifdef __STDC__
a76 5
#else
bpf_error(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif
a79 1
#ifdef __STDC__
a80 3
#else
	va_start(ap);
#endif
@


1.13
log
@DLT_PFLOG
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.12 2000/04/26 21:25:52 jakob Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/lib/libpcap/gencode.c,v 1.12 2000/04/26 21:25:52 jakob Exp $ (LBL)";
d363 14
@


1.12
log
@sync with libpcap v0.5
add support for INET6 (kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.11 1999/07/20 04:49:54 deraadt Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/lib/libpcap/gencode.c,v 1.11 1999/07/20 04:49:54 deraadt Exp $ (LBL)";
d618 5
d722 1
@


1.11
log
@changes brought in from v0.4; started by brad, more by me, being tested by mts
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.10 1998/08/31 19:53:19 deraadt Exp $	*/
d25 1
a25 1
    "@@(#) $Header: gencode.c,v 1.94 98/07/12 13:06:49 leres Exp $ (LBL)";
d41 1
d58 4
d145 4
d153 4
d158 1
d161 3
d166 4
d171 1
d184 2
a185 2
	/* XXX Round up to nearest long. */
	n = (n + sizeof(long) - 1) & ~(sizeof(long) - 1);
d273 1
d282 1
d304 48
d537 5
d663 5
d677 4
d694 7
d721 4
d727 33
d806 54
d865 1
a865 1
	register struct block *b0, *b1;
d1067 3
d1088 91
d1184 1
d1186 1
d1225 1
d1231 1
a1231 1
	struct block *b0, *b1;
d1236 5
a1240 3
		b0 = gen_linktype(ETHERTYPE_IP);
		b1 = gen_cmp(off_nl + 9, BPF_B, (bpf_int32)IPPROTO_TCP);
		gen_and(b0, b1);
d1244 5
a1248 3
		b0 =  gen_linktype(ETHERTYPE_IP);
		b1 = gen_cmp(off_nl + 9, BPF_B, (bpf_int32)IPPROTO_UDP);
		gen_and(b0, b1);
d1252 1
a1252 3
		b0 =  gen_linktype(ETHERTYPE_IP);
		b1 = gen_cmp(off_nl + 9, BPF_B, (bpf_int32)IPPROTO_ICMP);
		gen_and(b0, b1);
d1255 4
d1260 1
a1260 3
		b0 =  gen_linktype(ETHERTYPE_IP);
		b1 = gen_cmp(off_nl + 9, BPF_B, (bpf_int32)2);
		gen_and(b0, b1);
d1267 13
a1279 3
		b0 =  gen_linktype(ETHERTYPE_IP);
		b1 = gen_cmp(off_nl + 9, BPF_B, (long)IPPROTO_IGRP);
		gen_and(b0, b1);
d1321 35
d1400 10
d1481 71
d1583 292
d1887 8
d1897 1
d1899 3
d1960 25
d2001 10
a2010 1
	bpf_u_int32 mask, addr, **alist;
d2060 1
d2075 45
d2141 1
d2143 8
d2153 1
d2162 3
d2173 8
d2283 1
d2285 8
d2301 3
d2315 58
d2471 4
a2474 1
		/* XXX Note that we assume a fixed link link header here. */
d2492 1
d2505 3
d2510 5
d2764 2
d2778 2
d2811 4
d2844 8
d2867 16
d2888 45
@


1.10
log
@DLT_LOOP has network byte order header
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.9 1998/07/14 00:14:00 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996
d24 2
a25 2
static char rcsid[] =
    "@@(#) Header: gencode.c,v 1.81 96/06/19 23:09:09 leres Exp (LBL)";
a37 1
#include <net/bpf.h>
a43 2
#include <pcap.h>
#include <pcap-namedb.h>
a50 4
#ifdef HAVE_OS_PROTO_H
#include "os-proto.h"
#endif

d53 1
d55 2
d58 2
a59 14
#ifndef ETHERTYPE_REVARP
#define ETHERTYPE_REVARP	0x8035
#endif
#ifndef	ETHERTYPE_MOPDL
#define	ETHERTYPE_MOPDL		0x6001
#endif
#ifndef	ETHERTYPE_MOPRC
#define	ETHERTYPE_MOPRC		0x6002
#endif
#ifndef	ETHERTYPE_DN
#define	ETHERTYPE_DN		0x6003
#endif
#ifndef	ETHERTYPE_LAT
#define	ETHERTYPE_LAT		0x6004
d134 1
a134 1
static struct block *gen_bcmp(u_int, u_int, u_char *);
d140 2
a141 2
static struct block *gen_ehostop(u_char *, int);
static struct block *gen_fhostop(u_char *, int);
d144 1
a144 1
static struct block *gen_gateway(u_char *, bpf_u_int32 **, int, int);
d149 1
a149 1
static int lookup_proto(char *, int);
a150 1
static bpf_u_int32 net_mask(bpf_u_int32 *);
d199 1
a199 1
	char *s;
d203 2
a204 1
	strcpy(cp, s);
d412 2
a413 2
	u_int offset, size;
	u_char *v;
d415 1
a415 1
	struct block *b, *tmp;
d419 4
a422 2
		u_char *p = &v[size - 4];
		bpf_int32 w = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
d430 3
a432 2
		u_char *p = &v[size - 2];
		bpf_int32 w = (p[0] << 8) | p[1];
d479 2
a480 1
	case DLT_NULL:
d482 2
a483 1
		off_nl = 0;
d486 2
a487 2
	case DLT_LOOP:
		off_linktype = -1;
a490 5
	case DLT_ENC:
		off_linktype = -1;
		off_nl = 12;
		return;

d496 5
d530 15
d579 1
a579 1
	int proto;
d581 6
d588 1
d590 1
a590 4
		if (proto == ETHERTYPE_IP)
			return gen_true();
		else
			return gen_false();
d594 1
a594 1
			proto = 0x0021;		/* XXX - need ppp.h defs */
d597 23
a619 5
	case DLT_LOOP:
		if (proto == ETHERTYPE_IP)
			return (gen_cmp(0, BPF_W, (bpf_int32) AF_INET));
		else
			return gen_false();
d622 1
d627 1
a627 1
			return (gen_cmp(0, BPF_W, htonl((bpf_int32) AF_INET)));
d678 2
a679 2
	u_char *eaddr;
	int dir;
d681 1
a681 1
	struct block *b0, *b1;
d712 2
a713 2
	u_char *eaddr;
	int dir;
d880 6
d889 3
d909 1
a909 1
	u_char *eaddr;
d932 1
a932 1
		b1 = gen_host(**alist++, 0xffffffffL, proto, Q_OR);
d934 1
a934 1
			tmp = gen_host(**alist++, 0xffffffffL, proto, Q_OR);
d978 9
d1002 4
d1010 4
d1143 2
a1144 2
	char *name;
	int proto;
d1146 1
a1146 1
	int v;
d1149 1
d1198 4
d1206 4
d1241 4
a1251 16
/*
 * Left justify 'addr' and return its resulting network mask.
 */
static bpf_u_int32
net_mask(addr)
	bpf_u_int32 *addr;
{
	register bpf_u_int32 m = 0xffffffff;

	if (*addr)
		while ((*addr & 0xff000000) == 0)
			*addr <<= 8, m <<= 8;

	return m;
}

d1254 1
a1254 1
	char *name;
d1259 1
d1271 6
a1276 1
		mask = net_mask(&addr);
d1314 4
a1317 1
			b = gen_host(**alist++, 0xffffffffL, proto, dir);
d1319 2
a1320 2
				tmp = gen_host(**alist++, 0xffffffffL,
					       proto, dir);
d1374 43
a1416 1
gen_ncode(v, q)
d1423 8
d1442 12
a1453 1
			mask = net_mask(&v);
d1489 1
a1489 1
	u_char *eaddr;
d1579 1
d1581 1
d1602 1
@


1.9
log
@buf oflows
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.8 1998/06/11 00:01:18 provos Exp $	*/
d589 7
a596 1
	case DLT_LOOP:
@


1.8
log
@handle IPSec processed packets (DLT_ENC) in libpcap, display them with
tcpdump + additional info (SPI + which type of transforms where passed).
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.7 1998/06/04 23:11:34 deraadt Exp $	*/
d109 2
a110 1
		(void)vsprintf(pcap_geterr(bpf_pcap), fmt, ap);
@


1.7
log
@add DLT_LOOP support; 4-byte header indicates proto; cstone@@pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.6 1997/07/25 20:30:18 mickey Exp $	*/
d501 5
d588 1
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.5 1996/09/16 02:33:05 tholo Exp $	*/
d496 5
d583 1
d587 1
a587 1
			return (gen_cmp(0, BPF_W, (bpf_int32)AF_INET));
@


1.5
log
@Use __inline
@
text
@d1 1
a1 1
/*	$OpenBSD: gencode.c,v 1.4 1996/07/12 13:19:08 mickey Exp $	*/
d32 1
a32 1
#if __STDC__
d48 1
a48 1
#if __STDC__
d93 1
a93 1
#if __STDC__
d103 1
a103 1
#if __STDC__
@


1.4
log
@bring it to the latest 0.2 LBL release.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d140 2
a141 2
static inline struct block *new_block(int);
static inline struct slist *new_stmt(int);
d143 1
a143 1
static inline void syntax(void);
d151 2
a152 2
static inline struct block *gen_true(void);
static inline struct block *gen_false(void);
d223 1
a223 1
static inline struct block *
d236 1
a236 1
static inline struct slist *
d258 1
a258 1
static inline void
d550 1
a550 1
static inline struct block *
d556 1
a556 1
static inline struct block *
@


1.3
log
@merge to latest libpcap
@
text
@d1 1
a1 2
/*	$OpenBSD */
/*	$NetBSD: gencode.c,v 1.2.6.1 1996/06/05 18:04:23 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1990, 1991, 1992, 1993, 1994
d25 1
a25 1
    "@@(#) Header: gencode.c,v 1.55 94/06/20 19:07:53 leres Exp (LBL)";
d28 1
a28 1
#include <sys/param.h>
d32 5
d43 1
a49 1
#include <stdlib.h>
d54 6
a61 4
#ifndef __GNUC__
#define inline
#endif

d80 1
d84 7
d92 3
a94 3
volatile void
#if __STDC__ || defined(SOLARIS)
bpf_error(char *fmt, ...)
d97 1
a97 1
	char *fmt;
d147 2
a148 2
static struct block *gen_cmp(u_int, u_int, int32_t);
static struct block *gen_mcmp(u_int, u_int, int32_t, u_int32_t);
d154 1
a154 1
static struct block *gen_hostop(u_int32_t, u_int32_t, int, int, u_int, u_int);
a155 1
#ifdef FDDI
d157 3
a159 4
#endif
static struct block *gen_dnhostop(u_int32_t, int, u_int);
static struct block *gen_host(u_int32_t, u_int32_t, int, int);
static struct block *gen_gateway(u_char *, u_int32_t **, int, int);
d161 1
a161 1
static struct block *gen_portatom(int, int32_t);
d166 1
a166 2
static u_int32_t net_mask(u_int32_t *);
static u_int32_t net_mask(u_int32_t *);
d178 2
a179 2
	/* XXX Round to structure boundary. */
	n = ALIGN(n);
d202 1
d204 1
a204 1
		if (chunks[i].m)
d206 2
d264 1
a264 1
static u_int32_t netmask;
d269 1
a269 1
	     char *buf, int optimize, u_int32_t mask)
d274 2
d277 2
a278 1
	if (setjmp(top_ctx))
d280 1
d287 1
a287 1
	pcap_parse();
d393 1
a393 1
	int32_t v;
d411 2
a412 2
	int32_t v;
	u_int32_t mask;
d435 1
a435 1
		int32_t w = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
d444 1
a444 1
		int32_t w = (p[0] << 8) | p[1];
d452 1
a452 1
		tmp = gen_cmp(offset, BPF_B, (int32_t)v[0]);
a467 3
#ifdef FDDI
extern int fddipad;
#endif
a500 1
#ifdef FDDI
d507 8
a514 2
		off_linktype = 19 + fddipad;
		off_nl = 21 + fddipad;
a515 1
#endif
d521 9
d577 7
d585 1
a585 1
	return gen_cmp(off_linktype, BPF_H, (int32_t)proto);
d590 2
a591 2
	u_int32_t addr;
	u_int32_t mask;
d625 1
a625 1
	b1 = gen_mcmp(offset, BPF_W, (int32_t)addr, mask);
a660 1
#ifdef FDDI
d673 5
a677 1
		return gen_bcmp(6 + 1 + fddipad, 6, eaddr);
d680 5
a684 1
		return gen_bcmp(0 + 1 + fddipad, 6, eaddr);
a701 1
#endif
d723 1
a723 1
	u_int32_t addr;
d764 3
a766 2
				(int32_t)ntohs(0x0681), (int32_t)ntohs(0x07FF));
	b1 = gen_cmp(base_off + 2 + 1 + offset_lh, BPF_H, (int32_t)ntohs(addr));
d769 2
a770 2
	tmp = gen_mcmp(base_off + 2, BPF_B, (int32_t)0x06, (int32_t)0x7);
	b2 = gen_cmp(base_off + 2 + offset_lh, BPF_H, (int32_t)ntohs(addr));
d775 3
a777 2
				(int32_t)ntohs(0x0281), (int32_t)ntohs(0x07FF));
	b2 = gen_cmp(base_off + 2 + 1 + offset_sh, BPF_H, (int32_t)ntohs(addr));
d781 2
a782 2
	tmp = gen_mcmp(base_off + 2, BPF_B, (int32_t)0x02, (int32_t)0x7);
	b2 = gen_cmp(base_off + 2 + offset_sh, BPF_H, (int32_t)ntohs(addr));
d793 2
a794 2
	u_int32_t addr;
	u_int32_t mask;
d831 3
d855 1
a855 1
	u_int32_t **alist;
a870 1
#ifdef FDDI
a872 1
#endif
d874 2
a875 1
			bpf_error("'gateway' supported only on ethernet or FDDI");
d901 1
a901 1
		b1 = gen_cmp(off_nl + 9, BPF_B, (int32_t)IPPROTO_TCP);
d907 1
a907 1
		b1 = gen_cmp(off_nl + 9, BPF_B, (int32_t)IPPROTO_UDP);
d913 7
a919 1
		b1 = gen_cmp(off_nl + 9, BPF_B, (int32_t)IPPROTO_ICMP);
d980 1
a980 1
	int32_t v;
d1005 1
a1005 1
	tmp = gen_cmp(off_nl + 9, BPF_B, (int32_t)proto);
d1011 1
a1011 1
		b1 = gen_portatom(0, (int32_t)port);
d1015 1
a1015 1
		b1 = gen_portatom(2, (int32_t)port);
d1020 2
a1021 2
		tmp = gen_portatom(0, (int32_t)port);
		b1 = gen_portatom(2, (int32_t)port);
d1026 2
a1027 2
		tmp = gen_portatom(0, (int32_t)port);
		b1 = gen_portatom(2, (int32_t)port);
d1113 1
a1113 1
		b1 = gen_cmp(off_nl + 9, BPF_B, (int32_t)v);
d1156 4
d1170 1
a1170 1
static u_int32_t
d1172 1
a1172 1
	u_int32_t *addr;
d1174 1
a1174 1
	register u_int32_t m = 0xffffffff;
d1191 1
a1191 1
	u_int32_t mask, addr, **alist;
d1208 1
d1212 2
a1213 1
					bpf_error("unknown ether host '%s'", name);
a1215 1
#ifdef FDDI
d1219 2
a1220 1
					bpf_error("unknown FDDI host '%s'", name);
d1222 1
a1222 1
#endif
d1224 2
a1225 1
				bpf_error("only ethernet/FDDI supports link-level host name");
d1297 1
a1297 1
	u_int32_t v;
d1300 1
a1300 1
	u_int32_t mask;
a1355 1
#ifdef FDDI
a1357 1
#endif
d1460 1
d1497 4
a1656 2
	s->next = new_stmt(BPF_ALU|BPF_SUB|BPF_K);
	s->next->s.k = n;
d1659 1
d1695 1
a1695 1
		return gen_cmp((u_int)idx, BPF_B, (int32_t)val);
d1698 1
a1698 1
		b = gen_cmp((u_int)idx, BPF_B, (int32_t)val);
d1704 1
a1704 1
		b = gen_cmp((u_int)idx, BPF_B, (int32_t)val);
d1728 1
a1728 1
	u_int32_t hostmask;
a1737 1
#ifdef FDDI
a1739 1
#endif
d1746 1
a1746 1
		b1 = gen_mcmp(off_nl + 16, BPF_W, (int32_t)0, hostmask);
d1748 1
a1748 1
			      (int32_t)(~0 & hostmask), hostmask);
d1792 1
a1792 1
		b1 = gen_cmp(off_nl + 16, BPF_B, (int32_t)224);
@


1.2
log
@Update to the latest LBL release.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: gencode.c,v 1.2 1995/03/06 11:38:21 mycroft Exp $	*/
d29 1
a29 1
#include <sys/types.h>
d133 2
a134 2
static struct block *gen_cmp(u_int, u_int, long);
static struct block *gen_mcmp(u_int, u_int, long, u_long);
d140 1
a140 1
static struct block *gen_hostop(u_long, u_long, int, int, u_int, u_int);
d145 3
a147 3
static struct block *gen_dnhostop(u_long, int, u_int);
static struct block *gen_host(u_long, u_long, int, int);
static struct block *gen_gateway(u_char *, u_long **, int, int);
d149 1
a149 1
static struct block *gen_portatom(int, long);
d154 2
a155 2
static u_long net_mask(u_long *);
static u_long net_mask(u_long *);
d167 2
a168 2
	/* XXX Round up to nearest long. */
	n = (n + sizeof(long) - 1) & ~(sizeof(long) - 1);
d250 1
a250 1
static u_long netmask;
d255 1
a255 1
	     char *buf, int optimize, u_long mask)
d375 1
a375 1
	long v;
d393 2
a394 2
	long v;
	u_long mask;
d417 1
a417 1
		long w = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
d426 1
a426 1
		long w = (p[0] << 8) | p[1];
d434 1
a434 1
		tmp = gen_cmp(offset, BPF_B, (long)v[0]);
d550 1
a550 1
	return gen_cmp(off_linktype, BPF_H, (long)proto);
d555 2
a556 2
	u_long addr;
	u_long mask;
d590 1
a590 1
	b1 = gen_mcmp(offset, BPF_W, (long)addr, mask);
d682 1
a682 1
	u_long addr;
d723 2
a724 2
				(long)ntohs(0x0681), (long)ntohs(0x07FF));
	b1 = gen_cmp(base_off + 2 + 1 + offset_lh, BPF_H, (long)ntohs(addr));
d727 2
a728 2
	tmp = gen_mcmp(base_off + 2, BPF_B, (long)0x06, (long)0x7);
	b2 = gen_cmp(base_off + 2 + offset_lh, BPF_H, (long)ntohs(addr));
d733 2
a734 2
				(long)ntohs(0x0281), (long)ntohs(0x07FF));
	b2 = gen_cmp(base_off + 2 + 1 + offset_sh, BPF_H, (long)ntohs(addr));
d738 2
a739 2
	tmp = gen_mcmp(base_off + 2, BPF_B, (long)0x02, (long)0x7);
	b2 = gen_cmp(base_off + 2 + offset_sh, BPF_H, (long)ntohs(addr));
d750 2
a751 2
	u_long addr;
	u_long mask;
d809 1
a809 1
	u_long **alist;
d856 1
a856 1
		b1 = gen_cmp(off_nl + 9, BPF_B, (long)IPPROTO_TCP);
d862 1
a862 1
		b1 = gen_cmp(off_nl + 9, BPF_B, (long)IPPROTO_UDP);
d868 1
a868 1
		b1 = gen_cmp(off_nl + 9, BPF_B, (long)IPPROTO_ICMP);
d929 1
a929 1
	long v;
d954 1
a954 1
	tmp = gen_cmp(off_nl + 9, BPF_B, (long)proto);
d960 1
a960 1
		b1 = gen_portatom(0, (long)port);
d964 1
a964 1
		b1 = gen_portatom(2, (long)port);
d969 2
a970 2
		tmp = gen_portatom(0, (long)port);
		b1 = gen_portatom(2, (long)port);
d975 2
a976 2
		tmp = gen_portatom(0, (long)port);
		b1 = gen_portatom(2, (long)port);
d1062 1
a1062 1
		b1 = gen_cmp(off_nl + 9, BPF_B, (long)v);
d1115 1
a1115 1
static u_long
d1117 1
a1117 1
	u_long *addr;
d1119 1
a1119 1
	register u_long m = 0xffffffff;
d1136 1
a1136 1
	u_long mask, addr, **alist;
d1239 1
a1239 1
	u_long v;
d1242 1
a1242 1
	u_long mask;
d1635 1
a1635 1
		return gen_cmp((u_int)idx, BPF_B, (long)val);
d1638 1
a1638 1
		b = gen_cmp((u_int)idx, BPF_B, (long)val);
d1644 1
a1644 1
		b = gen_cmp((u_int)idx, BPF_B, (long)val);
d1668 1
a1668 1
	u_long hostmask;
d1688 1
a1688 1
		b1 = gen_mcmp(off_nl + 16, BPF_W, (long)0, hostmask);
d1690 1
a1690 1
			      (long)(~0 & hostmask), hostmask);
d1734 1
a1734 1
		b1 = gen_cmp(off_nl + 16, BPF_B, (long)224);
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
