head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.32
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.28
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.24
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.26
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.18
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.22
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.20
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2009.10.27.23.59.30;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.04.06.12.06.39;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.11.15.02.21;	author dtucker;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.02.18.31.21;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.26.19.15.13;	author camield;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.07.19.32.39;	author mpf;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.26.17.58.25;	author camield;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.18.23.05.13;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.14.08.50.37;	author canacar;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.23.01.33.16;	author frantzen;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.19.39.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.29.06.56.13;	author dugsong;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.26.21.25.53;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	99.07.20.04.49.54;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.20.30.19;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.07.12.13.19.09;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.23.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.47.21;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@%{
/*	$OpenBSD: grammar.y,v 1.18 2009/04/06 12:06:39 henning Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>

struct mbuf;
struct rtentry;

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/pfvar.h>

#include <net80211/ieee80211.h>

#include <stdio.h>
#include <string.h>

#include "pcap-int.h"

#include "gencode.h"
#include <pcap-namedb.h>

#ifdef HAVE_OS_PROTO_H
#include "os-proto.h"
#endif

#define QSET(q, p, d, a) (q).proto = (p),\
			 (q).dir = (d),\
			 (q).addr = (a)

int n_errors = 0;

static struct qual qerr = { Q_UNDEF, Q_UNDEF, Q_UNDEF, Q_UNDEF };

static void
yyerror(char *msg)
{
	++n_errors;
	bpf_error("%s", msg);
	/* NOTREACHED */
}

#ifndef YYBISON
int yyparse(void);

int
pcap_parse()
{
	return (yyparse());
}
#endif

%}

%union {
	int i;
	bpf_u_int32 h;
	u_char *e;
	char *s;
	struct stmt *stmt;
	struct arth *a;
	struct {
		struct qual q;
		struct block *b;
	} blk;
	struct block *rblk;
}

%type	<blk>	expr id nid pid term rterm qid
%type	<blk>	head
%type	<i>	pqual dqual aqual ndaqual
%type	<a>	arth narth
%type	<i>	byteop pname pnum relop irelop
%type	<blk>	and or paren not null prog
%type	<rblk>	other pfvar p80211

%token  DST SRC HOST GATEWAY
%token  NET MASK PORT LESS GREATER PROTO PROTOCHAIN BYTE
%token  ARP RARP IP TCP UDP ICMP IGMP IGRP PIM
%token  ATALK DECNET LAT SCA MOPRC MOPDL STP
%token  TK_BROADCAST TK_MULTICAST
%token  NUM INBOUND OUTBOUND
%token  PF_IFNAME PF_RSET PF_RNR PF_SRNR PF_REASON PF_ACTION
%token	TYPE SUBTYPE DIR ADDR1 ADDR2 ADDR3 ADDR4
%token  LINK
%token	GEQ LEQ NEQ
%token	ID EID HID HID6
%token	LSH RSH
%token  LEN
%token  IPV6 ICMPV6 AH ESP
%token	VLAN

%type	<s> ID
%type	<e> EID
%type	<s> HID HID6
%type	<i> NUM action reason type subtype dir

%left OR AND
%nonassoc  '!'
%left '|'
%left '&'
%left LSH RSH
%left '+' '-'
%left '*' '/'
%nonassoc UMINUS
%%
prog:	  null expr
{
	finish_parse($2.b);
}
	| null
	;
null:	  /* null */		{ $$.q = qerr; }
	;
expr:	  term
	| expr and term		{ gen_and($1.b, $3.b); $$ = $3; }
	| expr and id		{ gen_and($1.b, $3.b); $$ = $3; }
	| expr or term		{ gen_or($1.b, $3.b); $$ = $3; }
	| expr or id		{ gen_or($1.b, $3.b); $$ = $3; }
	;
and:	  AND			{ $$ = $<blk>0; }
	;
or:	  OR			{ $$ = $<blk>0; }
	;
id:	  nid
	| pnum			{ $$.b = gen_ncode(NULL, (bpf_u_int32)$1,
						   $$.q = $<blk>0.q); }
	| paren pid ')'		{ $$ = $2; }
	;
nid:	  ID			{ $$.b = gen_scode($1, $$.q = $<blk>0.q); }
	| HID '/' NUM		{ $$.b = gen_mcode($1, NULL, $3,
				    $$.q = $<blk>0.q); }
	| HID MASK HID		{ $$.b = gen_mcode($1, $3, 0,
				    $$.q = $<blk>0.q); }
	| HID			{
				  /* Decide how to parse HID based on proto */
				  $$.q = $<blk>0.q;
				  switch ($$.q.proto) {
				  case Q_DECNET:
					$$.b = gen_ncode($1, 0, $$.q);
					break;
				  default:
					$$.b = gen_ncode($1, 0, $$.q);
					break;
				  }
				}
	| HID6 '/' NUM		{
#ifdef INET6
				  $$.b = gen_mcode6($1, NULL, $3,
				    $$.q = $<blk>0.q);
#else
				  bpf_error("'ip6addr/prefixlen' not supported "
					"in this configuration");
#endif /*INET6*/
				}
	| HID6			{
#ifdef INET6
				  $$.b = gen_mcode6($1, 0, 128,
				    $$.q = $<blk>0.q);
#else
				  bpf_error("'ip6addr' not supported "
					"in this configuration");
#endif /*INET6*/
				}
	| EID			{ $$.b = gen_ecode($1, $$.q = $<blk>0.q); }
	| not id		{ gen_not($2.b); $$ = $2; }
	;
not:	  '!'			{ $$ = $<blk>0; }
	;
paren:	  '('			{ $$ = $<blk>0; }
	;
pid:	  nid
	| qid and id		{ gen_and($1.b, $3.b); $$ = $3; }
	| qid or id		{ gen_or($1.b, $3.b); $$ = $3; }
	;
qid:	  pnum			{ $$.b = gen_ncode(NULL, (bpf_u_int32)$1,
						   $$.q = $<blk>0.q); }
	| pid
	;
term:	  rterm
	| not term		{ gen_not($2.b); $$ = $2; }
	;
head:	  pqual dqual aqual	{ QSET($$.q, $1, $2, $3); }
	| pqual dqual		{ QSET($$.q, $1, $2, Q_DEFAULT); }
	| pqual aqual		{ QSET($$.q, $1, Q_DEFAULT, $2); }
	| pqual PROTO		{ QSET($$.q, $1, Q_DEFAULT, Q_PROTO); }
	| pqual PROTOCHAIN	{ QSET($$.q, $1, Q_DEFAULT, Q_PROTOCHAIN); }
	| pqual ndaqual		{ QSET($$.q, $1, Q_DEFAULT, $2); }
	;
rterm:	  head id		{ $$ = $2; }
	| paren expr ')'	{ $$.b = $2.b; $$.q = $1.q; }
	| pname			{ $$.b = gen_proto_abbrev($1); $$.q = qerr; }
	| arth relop arth	{ $$.b = gen_relation($2, $1, $3, 0);
				  $$.q = qerr; }
	| arth irelop arth	{ $$.b = gen_relation($2, $1, $3, 1);
				  $$.q = qerr; }
	| other			{ $$.b = $1; $$.q = qerr; }
	;
/* protocol level qualifiers */
pqual:	  pname
	|			{ $$ = Q_DEFAULT; }
	;
/* 'direction' qualifiers */
dqual:	  SRC			{ $$ = Q_SRC; }
	| DST			{ $$ = Q_DST; }
	| SRC OR DST		{ $$ = Q_OR; }
	| DST OR SRC		{ $$ = Q_OR; }
	| SRC AND DST		{ $$ = Q_AND; }
	| DST AND SRC		{ $$ = Q_AND; }
	| ADDR1			{ $$ = Q_ADDR1; }
	| ADDR2			{ $$ = Q_ADDR2; }
	| ADDR3			{ $$ = Q_ADDR3; }
	| ADDR4			{ $$ = Q_ADDR4; }
	;

/* address type qualifiers */
aqual:	  HOST			{ $$ = Q_HOST; }
	| NET			{ $$ = Q_NET; }
	| PORT			{ $$ = Q_PORT; }
	;
/* non-directional address type qualifiers */
ndaqual:  GATEWAY		{ $$ = Q_GATEWAY; }
	;
pname:	  LINK			{ $$ = Q_LINK; }
	| IP			{ $$ = Q_IP; }
	| ARP			{ $$ = Q_ARP; }
	| RARP			{ $$ = Q_RARP; }
	| TCP			{ $$ = Q_TCP; }
	| UDP			{ $$ = Q_UDP; }
	| ICMP			{ $$ = Q_ICMP; }
	| IGMP			{ $$ = Q_IGMP; }
	| IGRP			{ $$ = Q_IGRP; }
	| PIM			{ $$ = Q_PIM; }
	| ATALK			{ $$ = Q_ATALK; }
	| DECNET		{ $$ = Q_DECNET; }
	| LAT			{ $$ = Q_LAT; }
	| SCA			{ $$ = Q_SCA; }
	| MOPDL			{ $$ = Q_MOPDL; }
	| MOPRC			{ $$ = Q_MOPRC; }
	| IPV6			{ $$ = Q_IPV6; }
	| ICMPV6		{ $$ = Q_ICMPV6; }
	| AH			{ $$ = Q_AH; }
	| ESP			{ $$ = Q_ESP; }
	| STP			{ $$ = Q_STP; }
	;
other:	  pqual TK_BROADCAST	{ $$ = gen_broadcast($1); }
	| pqual TK_MULTICAST	{ $$ = gen_multicast($1); }
	| LESS NUM		{ $$ = gen_less($2); }
	| GREATER NUM		{ $$ = gen_greater($2); }
	| BYTE NUM byteop NUM	{ $$ = gen_byteop($3, $2, $4); }
	| INBOUND		{ $$ = gen_inbound(0); }
	| OUTBOUND		{ $$ = gen_inbound(1); }
	| VLAN pnum		{ $$ = gen_vlan($2); }
	| VLAN			{ $$ = gen_vlan(-1); }
	| pfvar			{ $$ = $1; }
	| pqual p80211		{ $$ = $2; }
	;

pfvar:	  PF_IFNAME ID		{ $$ = gen_pf_ifname($2); }
	| PF_RSET ID		{ $$ = gen_pf_ruleset($2); }
	| PF_RNR NUM		{ $$ = gen_pf_rnr($2); }
	| PF_SRNR NUM		{ $$ = gen_pf_srnr($2); }
	| PF_REASON reason	{ $$ = gen_pf_reason($2); }
	| PF_ACTION action	{ $$ = gen_pf_action($2); }
	;

reason:	  NUM			{ $$ = $1; }
	| ID			{ const char *reasons[] = PFRES_NAMES;
				  int i;
				  for (i = 0; reasons[i]; i++) {
					  if (strcasecmp($1, reasons[i]) == 0) {
						  $$ = i;
						  break;
					  }
				  }
				  if (reasons[i] == NULL)
					  bpf_error("unknown PF reason");
				}
	;

action:	  ID			{ if (strcasecmp($1, "pass") == 0 ||
				      strcasecmp($1, "accept") == 0)
					$$ = PF_PASS;
				  else if (strcasecmp($1, "drop") == 0 ||
				      strcasecmp($1, "block") == 0)
					$$ = PF_DROP;
				  else if (strcasecmp($1, "match") == 0)
					$$ = PF_MATCH;
				  else if (strcasecmp($1, "rdr") == 0)
				  	$$ = PF_RDR;
				  else if (strcasecmp($1, "nat") == 0)
				  	$$ = PF_NAT;
				  else if (strcasecmp($1, "binat") == 0)
				  	$$ = PF_BINAT;
				  else if (strcasecmp($1, "scrub") == 0)
				  	$$ = PF_SCRUB;
				  else
					  bpf_error("unknown PF action");
				}
	;

p80211:   TYPE type SUBTYPE subtype
				{ $$ = gen_p80211_type($2 | $4,
					IEEE80211_FC0_TYPE_MASK |
					IEEE80211_FC0_SUBTYPE_MASK);
				}
	| TYPE type		{ $$ = gen_p80211_type($2,
					IEEE80211_FC0_TYPE_MASK); }
	| SUBTYPE subtype	{ $$ = gen_p80211_type($2,
					IEEE80211_FC0_SUBTYPE_MASK); }
	| DIR dir		{ $$ = gen_p80211_fcdir($2); }
	;

type:	  NUM
	| ID			{ if (strcasecmp($1, "data") == 0)
					$$ = IEEE80211_FC0_TYPE_DATA;
				  else if (strcasecmp($1, "mgt") == 0 ||
					strcasecmp($1, "management") == 0)
					$$ = IEEE80211_FC0_TYPE_MGT;
				  else if (strcasecmp($1, "ctl") == 0 ||
					strcasecmp($1, "control") == 0)
					$$ = IEEE80211_FC0_TYPE_CTL;
				  else
					  bpf_error("unknown 802.11 type");
				}
	;

subtype:  NUM
	| ID			{ if (strcasecmp($1, "assocreq") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_ASSOC_REQ;
				  else if (strcasecmp($1, "assocresp") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_ASSOC_RESP;
				  else if (strcasecmp($1, "reassocreq") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_REASSOC_REQ;
				  else if (strcasecmp($1, "reassocresp") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_REASSOC_RESP;
				  else if (strcasecmp($1, "probereq") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_PROBE_REQ;
				  else if (strcasecmp($1, "proberesp") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_PROBE_RESP;
				  else if (strcasecmp($1, "beacon") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_BEACON;
				  else if (strcasecmp($1, "atim") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_ATIM;
				  else if (strcasecmp($1, "disassoc") == 0 ||
				      strcasecmp($1, "disassociation") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_DISASSOC;
				  else if (strcasecmp($1, "auth") == 0 ||
				      strcasecmp($1, "authentication") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_AUTH;
				  else if (strcasecmp($1, "deauth") == 0 ||
				      strcasecmp($1, "deauthentication") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_DEAUTH;
				  else if (strcasecmp($1, "data") == 0)
					$$ = IEEE80211_FC0_SUBTYPE_DATA;
				  else
					  bpf_error("unknown 802.11 subtype");
				}
	;

dir:	  NUM
	| ID			{ if (strcasecmp($1, "nods") == 0)
					$$ = IEEE80211_FC1_DIR_NODS;
				  else if (strcasecmp($1, "tods") == 0)
					$$ = IEEE80211_FC1_DIR_TODS;
				  else if (strcasecmp($1, "fromds") == 0)
					$$ = IEEE80211_FC1_DIR_FROMDS;
				  else if (strcasecmp($1, "dstods") == 0)
					$$ = IEEE80211_FC1_DIR_DSTODS;
				  else
					bpf_error("unknown 802.11 direction");
				}
	;

relop:	  '>'			{ $$ = BPF_JGT; }
	| GEQ			{ $$ = BPF_JGE; }
	| '='			{ $$ = BPF_JEQ; }
	;
irelop:	  LEQ			{ $$ = BPF_JGT; }
	| '<'			{ $$ = BPF_JGE; }
	| NEQ			{ $$ = BPF_JEQ; }
	;
arth:	  pnum			{ $$ = gen_loadi($1); }
	| narth
	;
narth:	  pname '[' arth ']'		{ $$ = gen_load($1, $3, 1); }
	| pname '[' arth ':' NUM ']'	{ $$ = gen_load($1, $3, $5); }
	| arth '+' arth			{ $$ = gen_arth(BPF_ADD, $1, $3); }
	| arth '-' arth			{ $$ = gen_arth(BPF_SUB, $1, $3); }
	| arth '*' arth			{ $$ = gen_arth(BPF_MUL, $1, $3); }
	| arth '/' arth			{ $$ = gen_arth(BPF_DIV, $1, $3); }
	| arth '&' arth			{ $$ = gen_arth(BPF_AND, $1, $3); }
	| arth '|' arth			{ $$ = gen_arth(BPF_OR, $1, $3); }
	| arth LSH arth			{ $$ = gen_arth(BPF_LSH, $1, $3); }
	| arth RSH arth			{ $$ = gen_arth(BPF_RSH, $1, $3); }
	| '-' arth %prec UMINUS		{ $$ = gen_neg($2); }
	| paren narth ')'		{ $$ = $2; }
	| LEN				{ $$ = gen_loadlen(); }
	;
byteop:	  '&'			{ $$ = '&'; }
	| '|'			{ $$ = '|'; }
	| '<'			{ $$ = '<'; }
	| '>'			{ $$ = '>'; }
	| '='			{ $$ = '='; }
	;
pnum:	  NUM
	| paren pnum ')'	{ $$ = $2; }
	;
%%
@


1.18
log
@teach libpcap about scrub rules
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.17 2008/06/11 15:02:21 dtucker Exp $	*/
a24 4
#ifndef lint
static const char rcsid[] =
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.17 2008/06/11 15:02:21 dtucker Exp $ (LBL)";
#endif
@


1.17
log
@Import vlan support from upstream libpcap.  This allows, eg, "tcpdump vla 3"
to work on a vlan parent interface.  ok mcbride@@, "commit it" deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.16 2007/01/02 18:31:21 reyk Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.16 2007/01/02 18:31:21 reyk Exp $ (LBL)";
d318 2
@


1.16
log
@define bpf filters to match address and header fields in IEEE 802.11
wlan frames (DLT_IEEE802_11 and DLT_IEEE802_11_RADIO linktypes). see
tcpdump(8) for details.

"Works for me" claudio@@
ok jmc@@ deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.15 2006/03/26 19:15:13 camield Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.15 2006/03/26 19:15:13 camield Exp $ (LBL)";
d122 1
d284 2
@


1.15
log
@scrub can log, so it is a valid pf action to filter on

ok dhartmei
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.14 2005/10/07 19:32:39 mpf Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.14 2005/10/07 19:32:39 mpf Exp $ (LBL)";
d44 2
d106 1
a106 1
%type	<rblk>	other pfvar
d115 1
d126 1
a126 1
%type	<i> NUM action reason
d240 4
d245 1
d284 1
d325 73
@


1.14
log
@Add Spanning Tree Protocol support.
Bump version to 3.1.
OK brad@@
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.13 2005/05/26 17:58:25 camield Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.13 2005/05/26 17:58:25 camield Exp $ (LBL)";
d312 2
@


1.13
log
@rdr, nat and binat can appear in pflog now, so make them valid arguments
for the "action" keyword

ok dhartmei
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.12 2003/07/18 23:05:13 david Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.12 2003/07/18 23:05:13 david Exp $ (LBL)";
d109 1
a109 1
%token  ATALK DECNET LAT SCA MOPRC MOPDL
d266 1
@


1.12
log
@add missing includes
ok tedu@@
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.11 2003/05/14 08:50:37 canacar Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.11 2003/05/14 08:50:37 canacar Exp $ (LBL)";
d305 6
@


1.11
log
@libpcap and tcpdump now understand the new pflog datalink type.
old datalink type is still recognized.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.10 2002/03/23 01:33:16 frantzen Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.10 2002/03/23 01:33:16 frantzen Exp $ (LBL)";
d45 1
@


1.10
log
@language extensions for PF logs.  can specify direction, interface, rule
number, reason and action.  fix the ipv4/ipv6 distinction while I'm here.
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.9 2002/02/19 19:39:37 millert Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.9 2002/02/19 19:39:37 millert Exp $ (LBL)";
d111 1
a111 1
%token  PF_IFNAME PF_RNR PF_REASON PF_ACTION
d277 1
d279 1
@


1.9
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.8 2000/06/29 06:56:13 dugsong Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.8 2000/06/29 06:56:13 dugsong Exp $ (LBL)";
d42 2
d103 1
a103 1
%type	<rblk>	other
d111 1
d122 1
a122 1
%type	<i> NUM
d273 21
d295 12
@


1.8
log
@remove legacy over-general :{B} match for MAC addresses, fixing filters like 'arp[6:2] = 2'. ok angelos@@
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.7 2000/04/26 21:25:53 jakob Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.7 2000/04/26 21:25:53 jakob Exp $ (LBL)";
a33 1
#ifdef __STDC__
a35 1
#endif
@


1.7
log
@sync with libpcap v0.5
add support for INET6 (kame)
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.6 1999/07/20 04:49:54 deraadt Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.6 1999/07/20 04:49:54 deraadt Exp $ (LBL)";
d113 1
a113 1
%token	ID EID HID HID6 AID
a119 1
%type	<e> AID
a190 1
	| AID			{ $$.b = gen_acode($1, $$.q = $<blk>0.q); }
@


1.6
log
@changes brought in from v0.4; started by brad, more by me, being tested by mts
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.5 1997/07/25 20:30:19 mickey Exp $	*/
d27 1
a27 1
    "@@(#) $Header: grammar.y,v 1.56 96/11/02 21:54:55 leres Exp $ (LBL)";
d106 2
a107 2
%token  NET MASK PORT LESS GREATER PROTO BYTE
%token  ARP RARP IP TCP UDP ICMP IGMP IGRP
d113 1
a113 1
%token	ID EID HID
d116 1
d120 2
a121 1
%type	<s> HID
d173 18
d192 1
d214 1
d255 1
d262 4
@


1.5
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d2 1
a2 1
/*	$OpenBSD: grammar.y,v 1.4 1996/07/12 13:19:09 mickey Exp $	*/
d26 2
a27 2
static char rcsid[] =
    "@@(#) $Header: /cvs/src/lib/libpcap/grammar.y,v 1.4 1996/07/12 13:19:09 mickey Exp $ (LBL)";
a39 1
#include <net/bpf.h>
d45 4
a48 1
#include <pcap.h>
a54 3
#include "pcap-int.h"
#include "gencode.h"

d67 1
a67 1
	bpf_error(msg);
d85 1
a85 1
	u_long h;
d106 3
a108 3
%token  NET PORT LESS GREATER PROTO BYTE
%token  ARP RARP IP TCP UDP ICMP IGMP
%token  DECNET LAT MOPRC MOPDL
d119 1
a119 1
%type	<h> HID
d150 1
a150 1
	| pnum			{ $$.b = gen_ncode((u_long)$1,
d155 4
d164 1
a164 3
					$$.b =
					    gen_ncode(__pcap_atodn((char *)$1),
					    $$.q);
d167 1
a167 3
					$$.b =
					    gen_ncode(__pcap_atoin((char *)$1),
					    $$.q);
d182 1
a182 1
qid:	  pnum			{ $$.b = gen_ncode((u_long)$1,
d232 2
d236 1
@


1.4
log
@bring it to the latest 0.2 LBL release.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d27 1
a27 1
    "@@(#) $Header: grammar.y,v 1.49 96/06/23 02:23:54 leres Exp $ (LBL)";
d34 1
a34 1
#if __STDC__
@


1.3
log
@merge to latest libpcap
@
text
@d2 1
a2 2
/*	$OpenBSD */
/*	$NetBSD: grammar.y,v 1.2 1995/03/06 11:38:27 mycroft Exp $	*/
d5 1
a5 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
d27 1
a27 1
    "@@(#) Header: grammar.y,v 1.39 94/06/14 20:09:25 leres Exp (LBL)";
d34 5
d49 5
d73 3
d108 1
a108 1
%token  ARP RARP IP TCP UDP ICMP
d232 1
@


1.2
log
@Update to the latest LBL release.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
a72 1
#define	yylval	pcap_lval
@


1.1
log
@Initial revision
@
text
@d2 1
d73 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
