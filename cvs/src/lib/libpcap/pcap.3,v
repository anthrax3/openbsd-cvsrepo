head	1.46;
access;
symbols
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.45.0.2
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.42.0.4
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.35.0.8
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.6
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.33.0.4
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.20
	OPENBSD_5_0:1.30.0.18
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.16
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.14
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.10
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.12
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.8
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.6
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.25.0.12
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.10
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.8
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.6
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.4
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.20.0.8
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.20.0.6
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.20.0.4
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.6.0.8
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.6
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@.\" @;


1.46
date	2016.10.17.02.54.40;	author lteo;	state Exp;
branches;
next	1.45;
commitid	gjeds5iAYjgFCNR8;

1.45
date	2016.04.06.09.10.28;	author jmc;	state Exp;
branches;
next	1.44;
commitid	tJkZhnbxLDwOYOTr;

1.44
date	2016.04.06.08.02.56;	author jasper;	state Exp;
branches;
next	1.43;
commitid	5B5VobgACSkmC9RT;

1.43
date	2015.11.15.23.59.21;	author jmc;	state Exp;
branches;
next	1.42;
commitid	2MnLQBddCRIgEU0v;

1.42
date	2015.04.07.02.38.14;	author lteo;	state Exp;
branches;
next	1.41;
commitid	4B5ppAATSrBWHYH6;

1.41
date	2015.01.16.04.12.45;	author lteo;	state Exp;
branches;
next	1.40;
commitid	s843q17yyFs9N5L7;

1.40
date	2015.01.16.04.03.04;	author lteo;	state Exp;
branches;
next	1.39;
commitid	he0ByrNdQX2ccAYh;

1.39
date	2015.01.16.03.37.10;	author lteo;	state Exp;
branches;
next	1.38;
commitid	84SRJvuO4SXsQ63S;

1.38
date	2015.01.15.19.06.31;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	dven8mWEy4wx3j1c;

1.37
date	2014.12.24.03.25.42;	author lteo;	state Exp;
branches;
next	1.36;
commitid	QDSLRKkfSExQcPRL;

1.36
date	2014.12.12.14.23.17;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	bTVwzlRewzqg0Et5;

1.35
date	2013.06.25.16.49.39;	author jmc;	state Exp;
branches;
next	1.34;

1.34
date	2013.06.25.11.48.50;	author sebastia;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.16.08.55.48;	author giovanni;	state Exp;
branches;
next	1.32;

1.32
date	2012.05.25.17.10.56;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2012.05.25.01.58.08;	author lteo;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.31.19.19.36;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2006.09.09.15.46.22;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.26.20.58.51;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.18.15.27.09;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.18.11.05.39;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.06.20.13.15;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.01.16.23.44;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.01.08.03.30;	author mpech;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.17.22.29.47;	author dugsong;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.06.02.50.46;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.27.14.24.19;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.26.21.25.53;	author jakob;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.14.21.31.46;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.18.21.49.01;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	99.08.30.02.05.36;	author d;	state Exp;
branches;
next	1.15;

1.15
date	99.07.20.04.49.55;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.07.09.13.35.28;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	99.07.07.10.50.06;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	99.07.02.20.11.49;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	99.06.18.02.20.40;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	99.06.17.15.51.08;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	98.09.05.17.41.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.07.22.04.32.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.06.24.16.12.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.09.18.03.10.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.12.13.19.12;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.06.10.07.23.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.04.15.47.27;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.31.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Add missing argument names for pcap_offline_filter.
@
text
@.\"	$OpenBSD: pcap.3,v 1.45 2016/04/06 09:10:28 jmc Exp $
.\"
.\" Copyright (c) 1994, 1996, 1997
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that: (1) source code distributions
.\" retain the above copyright notice and this paragraph in its entirety, (2)
.\" distributions including binary code include the above copyright notice and
.\" this paragraph in its entirety in the documentation or other materials
.\" provided with the distribution, and (3) all advertising materials mentioning
.\" features or use of this software display the following acknowledgement:
.\" ``This product includes software developed by the University of California,
.\" Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
.\" the University nor the names of its contributors may be used to endorse
.\" or promote products derived from this software without specific prior
.\" written permission.
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
.\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
.\"
.Dd $Mdocdate: April 6 2016 $
.Dt PCAP_OPEN_LIVE 3
.Os
.Sh NAME
.Nm pcap_open_live ,
.Nm pcap_open_offline ,
.Nm pcap_dump_open ,
.Nm pcap_dump_fopen ,
.Nm pcap_lookupdev ,
.Nm pcap_lookupnet ,
.Nm pcap_dispatch ,
.Nm pcap_loop ,
.Nm pcap_dump ,
.Nm pcap_inject ,
.Nm pcap_sendpacket ,
.Nm pcap_compile ,
.Nm pcap_setfilter ,
.Nm pcap_freecode ,
.Nm pcap_next ,
.Nm pcap_next_ex ,
.Nm pcap_setdirection ,
.Nm pcap_datalink ,
.Nm pcap_snapshot ,
.Nm pcap_is_swapped ,
.Nm pcap_major_version ,
.Nm pcap_minor_version ,
.Nm pcap_stats ,
.Nm pcap_file ,
.Nm pcap_fileno ,
.Nm pcap_get_selectable_fd ,
.Nm pcap_perror ,
.Nm pcap_geterr ,
.Nm pcap_strerror ,
.Nm pcap_close ,
.Nm pcap_dump_file ,
.Nm pcap_dump_ftell ,
.Nm pcap_dump_flush ,
.Nm pcap_dump_close ,
.Nm pcap_breakloop ,
.Nm pcap_findalldevs ,
.Nm pcap_freealldevs ,
.Nm pcap_getnonblock ,
.Nm pcap_setnonblock ,
.Nm pcap_set_datalink ,
.Nm pcap_list_datalinks ,
.Nm pcap_free_datalinks ,
.Nm pcap_open_dead ,
.Nm pcap_fopen_offline ,
.Nm pcap_lib_version ,
.Nm pcap_datalink_val_to_name ,
.Nm pcap_datalink_val_to_description ,
.Nm pcap_datalink_name_to_val ,
.Nm pcap_create ,
.Nm pcap_set_snaplen ,
.Nm pcap_set_promisc ,
.Nm pcap_can_set_rfmon ,
.Nm pcap_set_rfmon ,
.Nm pcap_set_timeout ,
.Nm pcap_set_buffer_size ,
.Nm pcap_activate ,
.Nm pcap_statustostr ,
.Nm pcap_offline_filter
.Nd Packet Capture library
.Sh SYNOPSIS
.In pcap.h
.Ft "pcap_t *"
.Fn pcap_open_live "const char *source" "int snaplen" "int promisc" "int to_ms" "char *errbuf"
.Ft "pcap_t *"
.Fn pcap_open_offline "char *fname" "char *errbuf"
.Ft "pcap_dumper_t *"
.Fn pcap_dump_open "pcap_t *p" "char *fname"
.Ft "pcap_dumper_t *"
.Fn pcap_dump_fopen "pcap_t *p" "FILE *f"
.Ft "char *"
.Fn pcap_lookupdev "char *errbuf"
.Ft uint
.Fn pcap_lookupnet "const char *device" "bpf_u_int32 *netp" "bpf_u_int32 *maskp" "char *errbuf"
.Ft int
.Fn pcap_dispatch "pcap_t *p" "int cnt" "pcap_handler callback" "u_char *user"
.Ft int
.Fn pcap_loop "pcap_t *p" "int cnt" "pcap_handler callback" "u_char *user"
.Ft void
.Fn pcap_dump "u_char *user" "const struct pcap_pkthdr *h" "const u_char *sp"
.Ft int
.Fn pcap_inject "pcap_t *p" "const void *buf" "size_t len"
.Ft int
.Fn pcap_sendpacket "pcap_t *p" "const u_char *buf" "int size"
.Ft int
.Fn pcap_compile "pcap_t *p" "struct bpf_program *program" "char *buf" "int optimize" "bpf_u_int32 netmask"
.Ft int
.Fn pcap_setfilter "pcap_t *p" "struct bpf_program *fp"
.Ft void
.Fn pcap_freecode "struct bpf_program *program"
.Ft "u_char *"
.Fn pcap_next "pcap_t *p" "struct pcap_pkthdr *h"
.Ft int
.Fn pcap_next_ex "pcap_t *p" "struct pcap_pkthdr **pkt_header" "const u_char **pkt_data"
.Ft int
.Fn pcap_setdirection "pcap_t *p" "pcap_direction_t d"
.Ft int
.Fn pcap_datalink "pcap_t *p"
.Ft int
.Fn pcap_snapshot "pcap_t *p"
.Ft int
.Fn pcap_is_swapped "pcap_t *p"
.Ft int
.Fn pcap_major_version "pcap_t *p"
.Ft int
.Fn pcap_minor_version "pcap_t *p"
.Ft int
.Fn pcap_stats "pcap_t *p" "struct pcap_stat *ps"
.Ft "FILE *"
.Fn pcap_file "pcap_t *p"
.Ft int
.Fn pcap_fileno "pcap_t *p"
.Ft int
.Fn pcap_get_selectable_fd "pcap_t *p"
.Ft void
.Fn pcap_perror "pcap_t *p" "char *prefix"
.Ft "char *"
.Fn pcap_geterr "pcap_t *p"
.Ft "char *"
.Fn pcap_strerror "int errnum"
.Ft void
.Fn pcap_close "pcap_t *p"
.Ft "FILE *"
.Fn pcap_dump_file "pcap_dumper_t *p"
.Ft long
.Fn pcap_dump_ftell "pcap_dumper_t *p"
.Ft int
.Fn pcap_dump_flush "pcap_dumper_t *p"
.Ft void
.Fn pcap_dump_close "pcap_dumper_t *p"
.Ft void
.Fn pcap_breakloop "pcap_t *p"
.Ft int
.Fn pcap_findalldevs "pcap_if_t **alldevsp" "char *errbuf"
.Ft void
.Fn pcap_freealldevs "pcap_if_t *alldevs"
.Ft int
.Fn pcap_getnonblock "pcap_t *p" "char *errbuf"
.Ft int
.Fn pcap_setnonblock "pcap_t *p" "int nonblock" "char *errbuf"
.Ft int
.Fn pcap_set_datalink "pcap_t *p" "int dlt"
.Ft int
.Fn pcap_list_datalinks "pcap_t *p" "int **dlt_buffer"
.Ft void
.Fn pcap_free_datalinks "int *dlt_list"
.Ft pcap_t
.Fn pcap_open_dead "int linktype" "int snaplen"
.Ft pcap_t
.Fn pcap_fopen_offline "FILE *fp" "char *errbuf"
.Ft const char *
.Fn pcap_lib_version "void"
.Ft const char *
.Fn pcap_datalink_val_to_name "int dlt"
.Ft const char *
.Fn pcap_datalink_val_to_description "int dlt"
.Ft int
.Fn pcap_datalink_name_to_val "const char *name"
.Ft "pcap_t *"
.Fn pcap_create "const char *device" "char *errbuf"
.Ft int
.Fn pcap_set_snaplen "pcap_t *p" "int snaplen"
.Ft int
.Fn pcap_set_promisc "pcap_t *p" "int promisc"
.Ft int
.Fn pcap_can_set_rfmon "pcap_t *p"
.Ft int
.Fn pcap_set_rfmon "pcap_t *p" "int rfmon"
.Ft int
.Fn pcap_set_timeout "pcap_t *p" "int timeout_ms"
.Ft int
.Fn pcap_set_buffer_size "pcap_t *p" "int buffer_size"
.Ft int
.Fn pcap_activate "pcap_t *p"
.Ft const char *
.Fn pcap_statustostr "int errnum"
.Ft int
.Fn pcap_offline_filter "const struct bpf_program *fp" "const struct pcap_pkthdr *h" "const u_char *pkt"
.Sh DESCRIPTION
.Nm
provides a high level interface to packet capture systems.
All packets
on the network, even those destined for other hosts, are accessible
through this mechanism.
.Pp
Note that
.Fa errbuf
in
.Fn pcap_open_live ,
.Fn pcap_open_offline ,
.Fn pcap_findalldevs ,
.Fn pcap_lookupdev ,
.Fn pcap_lookupnet ,
.Fn pcap_getnonblock ,
.Fn pcap_setnonblock ,
.Fn pcap_fopen_offline ,
and
.Fn pcap_create
is assumed to be able to hold at least
.Dv PCAP_ERRBUF_SIZE
chars.
.Pp
.Fn pcap_open_live
is used to obtain a packet capture descriptor to look
at packets on the network.
.Fa source
is a string that specifies the network device to open.
.Fa snaplen
specifies the maximum number of bytes to capture from one packet.
.Fa promisc
specifies if the interface is to be put into promiscuous mode.
(Note that even if this parameter is false, the interface
could well be in promiscuous mode for some other reason.)
.Fa to_ms
specifies the read timeout in milliseconds.
.Fa errbuf
is used to return error text and is only set when
.Fn pcap_open_live
fails and returns
.Dv NULL .
.Pp
.Fn pcap_open_offline
is called to open a
.Dq savefile
for reading.
.Fa fname
specifies the name of the file to open.
The file has the same format as those used by
.Xr tcpdump 8 .
.\" and
.\" .BR tcpslice(1) .
The name
.Ql -
is a synonym for
.Dv stdin .
.Fa errbuf
is used to return error text and is only set when
.Fn pcap_open_offline
fails and returns
.Dv NULL .
.Pp
.Fn pcap_dump_open
is called to open a
.Dq savefile
for writing.
The name
.Ql -
is a synonym for
.Dv stdout .
.Dv NULL
is returned on failure.
.Fa p
is a
.Fa pcap
struct as returned by
.Fn pcap_open_offline
or
.Fn pcap_open_live .
.Fa fname
specifies the name of the file to open.
If
.Dv NULL
is returned,
.Fn pcap_geterr
can be used to get the error text.
.Pp
.Fn pcap_dump_fopen
allows the use of savefile functions on the already-opened stream
.Fa f .
.Pp
.Fn pcap_lookupdev
returns a pointer to a network device suitable for use with
.Fn pcap_open_live
and
.Fn pcap_lookupnet .
If there is an error,
.Dv NULL
is returned and
.Fa errbuf
is filled in with an appropriate error message.
.Pp
.Fn pcap_lookupnet
is used to determine the network number and mask
associated with the network device
.Fa device .
Both
.Fa netp
and
.Fa maskp
are
.Fa bpf_u_int32
pointers.
A return of \-1 indicates an error in which case
.Fa errbuf
is filled in with an appropriate error message.
.Pp
.Fn pcap_dispatch
is used to collect and process packets.
.Fa cnt
specifies the maximum number of packets to process before returning.
A
.Fa cnt
of \-1 processes all the packets received in one buffer.
A
.Fa cnt
of 0 processes all packets until an error occurs, EOF is reached,
or the read times out (when doing live reads and a non-zero
read timeout is specified).
.Fa callback
specifies a routine to be called with three arguments: a
.Fa u_char
pointer which is passed in from
.Fn pcap_dispatch ,
a pointer to the
.Fa pcap_pkthdr
struct (which precedes the actual network headers and data),
and a
.Fa u_char
pointer to the packet data.
The number of packets read is returned.
Zero is returned when EOF is reached in a savefile.
A return of \-1 indicates an error in which case
.Fn pcap_perror
or
.Fn pcap_geterr
may be used to display the error text.
.Pp
.Fn pcap_dump
outputs a packet to the savefile opened with
.Fn pcap_dump_open .
Note that its calling arguments are suitable for use with
.Fn pcap_dispatch .
.Pp
.Fn pcap_inject
uses
.Xr write 2
to inject a raw packet through the network interface.
It returns the number of bytes written or \-1 on failure.
.Pp
.Fn pcap_sendpacket
is an alternate interface for packet injection (provided for compatibility).
It returns 0 on success or \-1 on failure.
.Pp
.Fn pcap_compile
is used to compile the string
.Fa buf
into a filter program.
.Fa program
is a pointer to a
.Fa bpf_program
struct and is filled in by
.Fn pcap_compile .
.Fa optimize
controls whether optimization on the resulting code is performed.
.Fa netmask
specifies the netmask of the local net.
.Pp
.Fn pcap_setfilter
is used to specify a filter program.
.Fa fp
is a pointer to an array of
.Fa bpf_program
struct, usually the result of a call to
.Fn pcap_compile .
\-1
is returned on failure;
0
is returned on success.
.Pp
.Fn pcap_freecode
is used to free up allocated memory pointed to by a
.Fa bpf_program
struct generated by
.Fn pcap_compile
when that BPF program is no longer needed, for example after it has
been made the filter program for a pcap structure by a call to
.Fn pcap_setfilter .
.Pp
.Fn pcap_loop
is similar to
.Fn pcap_dispatch
except it keeps reading packets until
.Fa cnt
packets are processed or an error occurs.
It does
.Em not
return when live read timeouts occur.
Rather, specifying a non-zero read timeout to
.Fn pcap_open_live
and then calling
.Fn pcap_loop
allows the reception and processing of any packets that arrive when the
timeout occurs.
A negative
.Fa cnt
causes
.Fn pcap_loop
to loop forever (or at least until an error occurs).
.Fn pcap_loop
may be terminated early through an explicit call to
.Fn pcap_breakloop .
In this case, the return value of
.Fn pcap_loop
will be \-2.
.Pp
.Fn pcap_next
returns a
.Fa u_char
pointer to the next packet.
.Pp
.Fn pcap_next_ex
reads the next packet and returns a success/failure indication: a
return value of 1 indicates success, 0 means that the timeout was exceeded
on a live capture, \-1 indicates that an error occurred whilst reading
the packet and \-2 is returned when there are no more packets to read in a
savefile.
.Pp
.Fn pcap_datalink
returns the link layer type, e.g., DLT_EN10MB.
.Pp
.Fn pcap_snapshot
returns the snapshot length specified when
.Fn pcap_open_live
was called.
.Pp
.Fn pcap_is_swapped
returns true if the current savefile
uses a different byte order than the current system.
.Pp
.Fn pcap_major_version
returns the major number of the version of the pcap used to write the savefile.
.Pp
.Fn pcap_minor_version
returns the minor number of the version of the pcap used to write the savefile.
.Pp
.Fn pcap_file
returns the stream associated with the savefile.
.Pp
.Fn pcap_stats
returns 0 and fills in a
.Fa pcap_stat
struct.
The values represent packet statistics from the start of the
run to the time of the call.
If there is an error or the underlying
packet capture doesn't support packet statistics, \-1 is returned and
the error text can be obtained with
.Fn pcap_perror
or
.Fn pcap_geterr .
.Pp
.Fn pcap_fileno
and
.Fn pcap_get_selectable_fd
return the file descriptor number of the savefile.
.Pp
.Fn pcap_perror
prints the text of the last pcap library error on
.Dv stderr ,
prefixed by
.Fa prefix .
.Pp
.Fn pcap_geterr
returns the error text pertaining to the last pcap library error.
.Pp
.Fn pcap_strerror
is provided in case
.Xr strerror 3
isn't available.
.Pp
.Fn pcap_close
closes the files associated with
.Fa p
and deallocates resources.
.Pp
.Fn pcap_dump_file
returns the stream associated with a savefile.
.Pp
.Fn pcap_dump_ftell
returns the current file offset within a savefile.
.Pp
.Fn pcap_dump_flush
ensures that any buffered data has been written to a savefile.
.Pp
.Fn pcap_dump_close
closes the savefile.
.Pp
.Fn pcap_findalldevs
constructs a linked list of network devices that are suitable for
opening with
.Fn pcap_open_live .
.Pp
.Fn pcap_freealldevs
frees a list of interfaces built by
.Fn pcap_findalldevs .
.Pp
.Fn pcap_getnonblock
returns 1 if the capture file descriptor is in non-blocking mode, 0
if it is in blocking mode, or \-1 on error.
.Pp
.Fn pcap_setnonblock
sets or resets non-blocking mode on a capture file descriptor.
.Pp
.Fn pcap_set_datalink
sets the datalink type on a live capture device that supports multiple
datalink types.
.Pp
.Fn pcap_setdirection
is used to limit the direction that packets must be flowing in order
to be captured.
.Pp
.Fn pcap_list_datalinks
returns an array of the supported datalink types for an opened live capture
device as a \-1 terminated array.
It is the caller's responsibility to free this list with
.Fn pcap_free_datalinks ,
which frees the list of link-layer header types pointed to by
.Dv dlt_list .
.Pp
.Fn pcap_breakloop
safely breaks out of a
.Fn pcap_loop .
This function sets an internal flag and is safe to be called from inside a
signal handler.
.Pp
.Fn pcap_open_dead
is used for creating a pcap_t structure to use when calling the
other functions in libpcap.
It is typically used when just using libpcap for compiling BPF code.
.Pp
.Fn pcap_fopen_offline
may be used to read dumped data from an existing open stream
.Fa fp .
.Pp
.Fn pcap_lib_version
returns a string describing the version of libpcap.
.Pp
.Fn pcap_datalink_val_to_name
and
.Fn pcap_datalink_val_to_description
look up the name or description of a datalink type by number.
These functions return
.Dv NULL
if the specified datalink type is not known.
.Fn pcap_datalink_name_to_val
finds the datalink number for a given datalink name.
Returns \-1 if the name is not known.
.Pp
.Fn pcap_create
is used to create a packet capture handle to look at
packets on the network.
The returned handle must be activated with
.Fn pcap_activate
before packets can be captured with it; options for the
capture, such as promiscuous mode, can be set on the handle
before activating it.
.Pp
.Fn pcap_set_snaplen
sets the snapshot length to be used on a capture handle when the
handle is activated to
.Fa snaplen .
.Pp
.Fn pcap_set_promisc
sets whether promiscuous mode should be set on a capture handle
when the handle is activated.
If
.Fa promisc
is non-zero, promiscuous mode will be set, otherwise it will not be set.
.Pp
.Fn pcap_can_set_rfmon
checks whether monitor mode could be set on a capture handle when the
handle is activated.
.Pp
.Fn pcap_set_rfmon
sets whether monitor mode should be set on a capture handle
when the handle is activated.
If
.Fa rfmon
is non-zero, monitor mode will be set, otherwise it will not be set.
.Pp
.Fn pcap_set_timeout
sets the read timeout that will be used on a capture handle when the
handle is activated to
.Fa to_ms ,
which is in units of milliseconds.
.Pp
.Fn pcap_set_buffer_size
sets the buffer size that will be used on a capture handle when the
handle is activated to
.Fa buffer_size ,
which is in units of bytes.
.Pp
.Fn pcap_activate
is used to activate a packet capture handle to look at
packets on the network, with the options that were set on the handle
being in effect.
.Pp
.Fn pcap_statustostr
converts a PCAP_ERROR_ or PCAP_WARNING_ value returned by a libpcap
routine to an error string.
.Pp
.Fn pcap_offline_filter
checks whether a filter matches a packet.
.Sh SEE ALSO
.Xr pcap-filter 3 ,
.Xr tcpdump 8
.\" , tcpslice(1)
.Sh AUTHORS
.An -nosplit
.An Van Jacobson ,
.An Craig Leres ,
and
.An Steven McCanne ,
all of the
Lawrence Berkeley National Laboratory, University of California, Berkeley, CA.
@


1.45
log
@bad spell of whether...
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.44 2016/04/06 08:02:56 jasper Exp $
d202 1
a202 1
.Fn pcap_offline_filter "const struct bpf_program *" "const struct pcap_pkthdr *" "const u_char *"
@


1.44
log
@add two functions from libpcap-1.7.4 which are required by at least gopacket

ok lteo@@ "go for it" dlg@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.43 2015/11/15 23:59:21 jmc Exp $
d22 1
a22 1
.Dd $Mdocdate: November 15 2015 $
d627 1
a627 1
checks wether a filter matches a packet.
@


1.43
log
@update NAME; ok schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.42 2015/04/07 02:38:14 lteo Exp $
d22 1
a22 1
.Dd $Mdocdate: April 7 2015 $
d67 1
d82 2
a83 1
.Nm pcap_statustostr
d169 2
d201 2
d539 4
a542 1
It is the caller's responsibility to free this list.
d625 3
@


1.42
log
@Fix miscellaneous factual, grammar, and markup errors.

From Jan Stary.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.41 2015/01/16 04:12:45 lteo Exp $
d22 2
a23 2
.Dd $Mdocdate: January 16 2015 $
.Dt PCAP 3
d26 56
a81 1
.Nm pcap
@


1.41
log
@Complete the list of functions in the paragraph that mentions that
errbuf needs to hold at least PCAP_ERRBUF_SIZE chars.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.40 2015/01/16 04:03:04 lteo Exp $
d172 1
a172 1
specifies the maximum number of bytes to capture.
d212 1
a212 1
.Dv stdin .
d232 1
a232 1
.Dq f .
d279 1
a279 1
struct (which precede the actual network headers and data),
d354 1
a354 1
.Fn pcap_dispatch
d493 1
a493 1
.Dq fp .
d497 1
@


1.40
log
@Rename pcap_create()'s ebuf argument to errbuf to match the rest of the
public pcap_* functions that use errbuf.  Mainline libpcap also uses
"errbuf" for pcap_create().

No object file change.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.39 2015/01/16 03:37:10 lteo Exp $
d156 4
d161 1
a161 1
.Fn pcap_lookupnet
@


1.39
log
@Add more missing argument names.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.38 2015/01/15 19:06:31 schwarze Exp $
d22 1
a22 1
.Dd $Mdocdate: January 15 2015 $
d125 1
a125 1
.Fn pcap_create "const char *device" "char *ebuf"
@


1.38
log
@remove .Tn; from Jan Stary <hans at stare dot cz>
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.37 2014/12/24 03:25:42 lteo Exp $
d22 1
a22 1
.Dd $Mdocdate: December 24 2014 $
d109 1
a109 1
.Fn pcap_set_datalink "pcap_t *" "int dlt"
d123 1
a123 1
.Fn pcap_datalink_name_to_val "const char *"
@


1.37
log
@Add missing argument names, and sync the argument types and names with
the ones used in the code.

pointed out by schwarze@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.36 2014/12/12 14:23:17 schwarze Exp $
d22 1
a22 1
.Dd $Mdocdate: December 12 2014 $
d265 2
a266 3
of 0 processes all packets until an error occurs,
.Tn EOF
is reached, or the read times out (when doing live reads and a non-zero
d280 1
a280 3
Zero is returned when
.Tn EOF
is reached in a savefile.
d378 1
a378 2
returns the link layer type, e.g.,
.Tn DLT_EN10MB .
@


1.36
log
@markup fixes, and repair some wrong argument types while here;
from Kaspars at Bankovskis dot net
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.35 2013/06/25 16:49:39 jmc Exp $
d22 1
a22 1
.Dd $Mdocdate: June 25 2013 $
d31 1
a31 1
.Fn pcap_open_live "char *device" "int snaplen" "int promisc" "int to_ms" "char *errbuf"
d47 1
a47 1
.Fn pcap_dump "u_char *user" "struct pcap_pkthdr *h" "u_char *sp"
d53 1
a53 1
.Fn pcap_compile "pcap_t *p" "struct bpf_program *fp" "char *str" "int optimize" "bpf_u_int32 netmask"
d57 1
a57 1
.Fn pcap_freecode "struct bpf_program *fp"
d61 1
a61 1
.Fn pcap_next_ex "pcap_t *p" "struct pcap_pkthdr **hp" "const u_char **pktp"
d63 1
a63 1
.Fn pcap_setdirection "pcap_t *p" "pcap_direction_t dir"
d81 1
a81 1
.Fn pcap_get_selectable_fd "pcap_t *"
d87 1
a87 1
.Fn pcap_strerror "int error"
d111 1
a111 1
.Fn pcap_list_datalinks "pcap_t *p" "int **dlts"
d119 1
a119 1
.Fn pcap_datalink_val_to_name "int"
d121 1
a121 1
.Fn pcap_datalink_val_to_description "int"
d125 1
a125 1
.Fn pcap_create "const char *source" "char *errbuf"
d135 1
a135 1
.Fn pcap_set_timeout "pcap_t *p" "int timeout"
d141 1
a141 1
.Fn pcap_statustostr "int"
d165 1
a165 1
.Fa device
d308 1
a308 1
.Fa str
d310 1
a310 1
.Fa fp
@


1.35
log
@zap trailing whitespace;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.34 2013/06/25 11:48:50 sebastia Exp $
d29 1
a29 1
.Fd #include <pcap.h>
d49 1
a49 1
.Fn pcap_inject "pcap_t *p" "void *, size_t"
d51 1
a51 1
.Fn pcap_sendpacket "pcap_t *p" "void *, int"
d565 6
a570 3
Van Jacobson,
Craig Leres and
Steven McCanne, all of the
@


1.34
log
@bring return value of pcap_breakloop in sync with reality.

OK jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.33 2012/07/16 08:55:48 giovanni Exp $
d22 1
a22 1
.Dd $Mdocdate: July 16 2012 $
d98 1
a98 1
.Ft void 
@


1.33
log
@
Add a man page describing pcap grammar
help from lteo@@, claudio, jmc@@
ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.32 2012/05/25 17:10:56 jmc Exp $
d22 1
a22 1
.Dd $Mdocdate: May 25 2012 $
d98 1
a98 1
.Ft int
@


1.32
log
@tweak previous; ok sthen lteo
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.31 2012/05/25 01:58:08 lteo Exp $
d561 1
a568 3
.Sh BUGS
Please send bug reports to
.Pa libpcap@@ee.lbl.gov .
@


1.31
log
@Import a number of core functions from libpcap-1.2.0 while preserving
local changes: strncpy() -> strlcpy(), malloc(x * y) -> calloc(x, y),
exclude cross-platform cruft, etc.

The new functions are pcap_create(), pcap_set_snaplen(),
pcap_set_promisc(), pcap_can_set_rfmon(), pcap_set_rfmon(),
pcap_set_timeout(), pcap_set_buffer_size(), pcap_activate(), and
pcap_statustostr().

This diff was tested on amd64, i386, macppc, and sparc64, where
regression tests were done on various pcap-based ports (especially amd64
and i386 where regression tests were run on all pcap-based ports).
Testers also tried running pcap-based ports that they are familiar with
to ensure that there is no behavioral change.  tcpdump and pflogd in
base were also tested by different testers.  The new pcap_* functions
were tested with a proof-of-concept Snort 2.9 port for many months.

Thank you to everyone who helped test this diff and provided feedback:
haesbaert@@, sthen@@, matthew@@, gonzalo@@, brett@@, Rodolfo Gouveia,
Aaron Bieber, Markus Lude, and Ray Percival.

ok haesbaert sthen henning
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.30 2007/05/31 19:19:36 jmc Exp $
d22 1
a22 1
.Dd $Mdocdate: May 31 2007 $
d148 2
a149 2
.Sh ROUTINES
.Sy Note:
d524 2
a525 1
when the handle is activated. If
d535 2
a536 1
when the handle is activated. If
@


1.30
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.29 2006/09/09 15:46:22 jmc Exp $
d22 1
a22 1
.Dd $Mdocdate$
d124 18
d507 51
@


1.29
log
@document pcap_get_selectable_fd(); MLINK will happen after unlock

from okan demirmen;
ok djm
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.28 2006/03/26 20:58:51 djm Exp $
d22 1
a22 1
.Dd July 5, 1999
@


1.28
log
@add remaining tcpdump.org libpcap 0.9 APIs, most notably
pcap_setdirection() (which depends on the kernel-side bpf changes
committed yesterday); ok canacar@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.27 2005/11/18 15:27:09 jmc Exp $
d80 2
d398 3
a400 1
returns the file descriptor number of the savefile.
@


1.27
log
@- new sentence, new line
- avoid Xr to self
- lookup(n.) -> look up(v.)
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.26 2005/11/18 11:05:39 djm Exp $
d36 2
d41 1
a41 1
.Fn pcap_lookupnet "char *device" "bpf_u_int32 *netp" "bpf_u_int32 *maskp" "char *errbuf"
d51 2
d61 4
d88 6
d112 2
d206 4
d280 5
d353 7
d417 9
d449 4
d468 4
@


1.26
log
@pull in the good bits of libpcap-0.9.4's API without the cross-platform
cruft. help from deraadt@@, mpf@@, jmc@@; ok mpf@@a

nb. this will break tcpdump unless it updated too
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.25 2003/03/06 20:13:15 jmc Exp $
d168 2
a169 1
for writing. The name
d425 1
a425 2
returns a string describing the version of
.Xr pcap 3 .
d429 1
a429 1
lookup the name or description of a datalink type by number.
@


1.25
log
@.Xr typos;

ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.24 2002/05/01 16:23:44 millert Exp $
d82 24
d118 1
d315 6
d386 50
@


1.24
log
@under lying -> underlying
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.23 2002/05/01 08:03:30 mpech Exp $
d345 1
a345 1
.Xr strerror 1
@


1.23
log
@o) start new sentence on a new line;
o) always close .Bl tags;
o) fix usage of .Xr;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.22 2001/12/17 22:29:47 dugsong Exp $
d324 1
a324 1
If there is an error or the under lying
@


1.22
log
@fix memory leak associated with compiled BPF program, sync'd from tcpdump.org. ok itojun@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.21 2001/12/06 02:50:46 millert Exp $
d84 2
a85 1
provides a high level interface to packet capture systems. All packets
d125 2
a126 2
specifies the name of the file to open. The file has
the same format as those used by
d157 2
a158 1
specifies the name of the file to open. If
d193 2
a194 1
specifies the maximum number of packets to process before returning. A
d196 2
a197 1
of \-1 processes all the packets received in one buffer. A
d213 2
a214 1
pointer to the packet data. The number of packets read is returned.
d321 4
a324 2
struct. The values represent packet statistics from the start of the
run to the time of the call. If there is an error or the under lying
@


1.21
log
@A FILE * is not a file name, dammit.
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.20 2000/04/27 14:24:19 itojun Exp $
d52 2
d255 9
@


1.20
log
@s/PCAP_ERRBUFF_SIZE/PCAP_ERRBUF_SIZE/ (sync with reality)
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.19 2000/04/26 21:25:53 jakob Exp $
d300 1
a300 1
returns the name of the savefile.
@


1.19
log
@sync with libpcap v0.5
add support for INET6 (kame)
@
text
@d1 1
a1 1
.\"	$OpenBSD: pcap.3,v 1.2.6.1 1996/06/05 18:04:43 cgd Exp $
d95 1
a95 1
.Dv PCAP_ERRBUFF_SIZE
@


1.18
log
@Suffix "i.e." and "e.g." with a comma. Just another really picky man page
commit, as we want our documentation to be as consistently formatted as
possible (it's getting there :-)).
@
text
@d1 1
a1 1
.\"	$NetBSD: pcap.3,v 1.2.6.1 1996/06/05 18:04:43 cgd Exp $
@


1.17
log
@Repair duplicate word occurences; (as found by a Perl script sent to us from
Tom Christiansen <tchrist@@perl.com>).
@
text
@d281 1
a281 1
returns the link layer type, e.g.
@


1.16
log
@someone went overboard with Fn. Also Pa the email address. ok aaron@@
@
text
@d184 1
a184 1
is filled in with with an appropriate error message.
@


1.15
log
@changes brought in from v0.4; started by brad, more by me, being tested by mts
@
text
@d249 1
a249 1
.Fn \-1
d251 1
a251 1
.Fn 0
d261 1
a261 1
.Fn not
d264 1
a264 1
.Fn pcap_open_live()
d266 1
a266 1
.Fn pcap_dispatch()
d293 1
a293 1
.Fn pcap_major_version()
d347 1
a347 2
.Xr libpcap@@ee.lbl.gov .
m@


1.14
log
@- remove all trailing whitespace
     * except when it is escaped with a `\' at the end of the line
- fix remaining .Nm usage as well
- this is from a patch I received from kwesterback@@home.com, who has been
  working on some scripts for fixing formatting errors in mdoc'd man pages

Ok, so there could be a cost/benefit debate with this commit, but since I have
the patch we might as well commit it...
@
text
@d3 1
a3 1
.\" Copyright (c) 1994
d22 1
a22 1
.Dd June 4, 1999
d39 1
a39 1
.Fn pcap_lookupnet "char *device" "u_int32_t *netp" "u_int32_t *maskp" "char *errbuf"
d49 1
a49 3
.Fn pcap_immediate "pcap_t *p"
.Ft int
.Fn pcap_compile "pcap_t *p" "struct bpf_program *fp" "char *str" "int optimize" "u_int32_t netmask"
d105 4
d180 1
a180 1
.Fa u_int32_t
d193 1
a193 1
of 0 processes all packets until an error occurs (or
d195 2
a196 1
is reached).
d205 3
a207 1
and a length. The number of packets read is returned.
a227 9
.Fn pcap_immediate
sets
.Dq immediate
mode.  If this isn't supported by the underlying packet capture, \-1 is
returned and the error text can be obtained with
.Fn pcap_perror
or
.Fn pcap_geterr .
.Pp
d243 1
a243 1
is used to specify the filter program.
d249 4
d259 11
a269 1
packets are processed or an error occurs. A negative
d305 2
a306 1
struct with packet statistics. If there is an error or the underlying
d340 9
@


1.13
log
@The proper order of the ``introductory'' macros in a man page is .Dd/.Dt/.Os.
Out of the approximately 1450 man pages, only about 90 of them were wrong.
Thanks to kwesterback@@home.com for coming up with a script and patch to repair
this. The patch also inserted a .Os macro in the few man pages that were
missing one.
@
text
@d96 1
a96 1
is assumed to be able to hold at least 
@


1.12
log
@consistent .Dd usage; proper format is: .Dd Month DD, YYYY
@
text
@d23 1
a24 1
.Dt PCAP 3
@


1.11
log
@new mandoc-style pcap(3) man page; kwesterback@@home.com
@
text
@d22 1
a22 1
.Dd 4 June, 1999
@


1.10
log
@fix RCS tags
@
text
@a0 1
.\"	$OpenBSD$
d22 62
a83 77
.TH PCAP 3  "12 Oct 1994"
.SH NAME
pcap \- Packet Capture library
.SH SYNOPSIS
.nf
.ft B
#include <pcap.h>
.ft
.LP
.ft B
pcap_t *pcap_open_live(char *device, int snaplen,
.ti +8
int promisc, int to_ms, char *ebuf)
pcap_t *pcap_open_offline(char *fname, char *ebuf)
pcap_dumper_t *pcap_dump_open(pcap_t *p, char *fname)
.ft
.LP
.ft B
char errbuf[PCAP_ERRBUF_SIZE];
char *pcap_lookupdev(char *errbuf)
int pcap_lookupnet(char *device, u_int32_t *netp,
.ti +8
u_int32_t *maskp, char *errbuf)
.ft
.LP
.ft B
int pcap_dispatch(pcap_t *p, int cnt,
.ti +8
pcap_handler callback, u_char *user)
int pcap_loop(pcap_t *p, int cnt,
.ti +8
pcap_handler callback, u_char *user)
void pcap_dump(u_char *user, struct pcap_pkthdr *h,
.ti +8
u_char *sp)
.ft
.LP
.ft B
int pcap_inject(pcap_t *p, void *, size_t)
.ft
.LP
.ft B
int pcap_immediate(pcap_t *p)
.ft
.LP
.ft B
int pcap_compile(pcap_t *p, struct bpf_program *fp,
.ti +8
char *str, int optimize, u_int32_t netmask)
int pcap_setfilter(pcap_t *p, struct bpf_program *fp)
.ft
.LP
.ft B
u_char *pcap_next(pcap_t *p, struct pcap_pkthdr *h)
.ft
.LP
.ft B
int pcap_datalink(pcap_t *p)
int pcap_snapshot(pcap_t *p)
int pcap_is_swapped(pcap_t *p)
int pcap_major_version(pcap_t *p)
int pcap_minor_version(pcap_t *p)
int pcap_stats(pcap_t *p, struct pcap_stat *ps)
FILE *pcap_file(pcap_t *p)
int pcap_fileno(pcap_t *p)
void pcap_perror(pcap_t *p, char *prefix)
char *pcap_geterr(pcap_t *p)
char *pcap_strerror(int error)
.ft
.LP
.ft B
void pcap_close(pcap_t *p)
void pcap_dump_close(pcap_dumper_t *p)
.ft
.fi
.SH DESCRIPTION
The Packet Capture library
d87 14
a100 3
.PP
.SH ROUTINES
.B pcap_open_live()
d103 1
a103 1
.I device
d105 1
a105 1
.I snaplen
d107 1
a107 1
.I to_ms
d109 1
a109 1
.I ebuf
d111 1
a111 1
.B pcap_open_live()
d113 7
a119 5
.BR NULL .
.PP
.B pcap_open_offline()
is called to open a ``savefile'' for reading.
.I fname
d122 1
a122 1
.B tcpdump(8) .
d125 5
a129 3
The name "-" is a synonym for
.BR stdin .
.I ebuf
d131 1
a131 1
.B pcap_open_offline()
d133 10
a142 7
.BR NULL .
.PP
.B pcap_dump_open()
is called to open a ``savefile'' for writing. The name "-" is a synonym
for
.BR stdin .
.B NULL
d144 1
a144 1
.I p
d146 1
a146 1
.I pcap
d148 1
a148 1
.B pcap_open_offline()
d150 4
a153 5
.BR pcap_open_live() .
.I fname
specifies the name of the file to open.
If
.B NULL
d155 1
a155 1
.B pcap_geterr()
d157 2
a158 2
.PP
.B pcap_lookupdev()
d160 1
a160 1
.B pcap_open_live()
d162 1
a162 1
.BR pcap_lookupnet() .
d164 1
a164 1
.B NULL
d166 1
a166 1
.I errbuf
d168 2
a169 2
.PP
.B pcap_lookupnet()
d172 1
a172 1
.BR device .
d174 1
a174 1
.I netp
d176 1
a176 1
.I maskp
d178 1
a178 1
.I u_int32_t
d180 2
a181 2
A return of -1 indicates an error in which case
.I errbuf
d183 2
a184 2
.PP
.B pcap_dispatch()
d186 1
a186 1
.I cnt
d188 3
a190 3
.I cnt
of -1 processes all the packets received in one buffer. A
.I cnt
d192 1
a192 1
.B EOF
d194 3
a196 4
.I callback
specifies a routine to be called with three arguments:
a
.I u_char
d198 1
a198 1
.BR pcap_dispatch() ,
d200 1
a200 1
.I pcap_pkthdr
d204 4
a207 4
.B EOF
is reached in a ``savefile.'' A return of -1 indicates
an error in which case
.B pcap_perror()
d209 1
a209 1
.BR pcap_geterr()
d211 4
a214 4
.PP
.B pcap_dump()
outputs a packet to the ``savefile'' opened with
.BR pcap_dump_open() .
d216 3
a218 6
.BR pcap_dispatch() .
.ft B
(??? this guy is kind of weird.)
.ft
.PP
.B pcap_inject()
d220 1
a220 1
.B write(2)
d222 5
a226 4
.PP
.B pcap_immediate()
sets ``immediate'' mode.
If this isn't supported by the underlying packet capture, -1 is
d228 1
a228 1
.B pcap_perror()
d230 3
a232 3
.BR pcap_geterr() .
.PP
.B pcap_compile()
d234 1
a234 1
.I str
d236 1
a236 1
.I program
d238 1
a238 1
.I bpf_program
d240 2
a241 2
.BR pcap_compile() .
.I optimize
d243 1
a243 1
.I netmask
d245 4
a248 4
.PP
.B pcap_setfilter()
is used to specify the a filter program.
.I fp
d250 1
a250 1
.I bpf_program
d252 3
a254 3
.BR pcap_compile() .
.PP
.B pcap_loop()
d256 1
a256 1
.B pcap_dispatch()
d258 3
a260 4
.I cnt
packets are processed or an error occurs.
A negative
.I cnt
d262 1
a262 1
.B pcap_loop()
d264 2
a265 2
.PP
.B pcap_next()
d267 1
a267 1
.I u_char
d269 2
a270 2
.PP
.B pcap_datalink()
d272 3
a274 3
.BR DLT_EN10MB .
.PP
.B pcap_snapshot()
d276 1
a276 1
.B pcap_open_live
d278 15
a292 17
.PP
.B pcap_is_swapped()
returns true if the current ``savefile'' uses a different byte order
than the current system.
.PP
.B pcap_major_version()
returns the major number of the version of the pcap used to write the
savefile.
.PP
.B pcap_minor_version()
returns the minor number of the version of the pcap used to write the
savefile.
.PP
.B pcap_file()
returns the name of the ``savefile.''
.PP
.B int pcap_stats()
d294 1
a294 1
.B pcap_stat
d296 1
a296 1
packet capture doesn't support packet statistics, -1 is returned and
d298 1
a298 1
.B pcap_perror()
d300 6
a305 6
.BR pcap_geterr() .
.PP
.B pcap_fileno()
returns the file descriptor number of the ``savefile.''
.PP
.B pcap_perror()
d307 1
a307 1
.BR stderr ,
d309 3
a311 3
.IR prefix .
.PP
.B pcap_geterr()
d313 2
a314 2
.PP
.B pcap_strerror()
d316 1
a316 1
.BR strerror (1)
d318 2
a319 2
.PP
.B pcap_close()
d321 1
a321 1
.I p
d323 5
a327 6
.PP
.B pcap_dump_close()
closes the ``savefile.''
.PP
.SH SEE ALSO
tcpdump(8)
a328 2
.SH BUGS
.SH HISTORY
@


1.9
log
@more man page repairs; aaron@@ug.cs.dal.ca
@
text
@d1 1
a1 1
.\"	$OpenBSD
@


1.8
log
@remove references to tcpslice as it is not shipped with the system.. this is questionable
@
text
@d128 1
a128 1
The name "-" in a synonym for
d137 1
a137 1
is called to open a ``savefile'' for writing. The name "-" in a synonym
d166 1
a166 1
is filled in with with an appropriate error message.
d228 1
a228 1
If this isn't supported by the under lying packet capture, -1 is
d300 1
a300 1
struct with packet statistics. If there is an error or the under lying
@


1.7
log
@typo; deberg@@mit.edu
@
text
@d125 3
a127 3
.B tcpdump(8)
and
.BR tcpslice(1) .
d333 2
a334 1
tcpdump(8), tcpslice(1)
@


1.6
log
@tcpdump(8) not (1); noted by msaitoh@@spa.is.uec.ac.jp
@
text
@d291 1
a291 1
returns the major number of the version of the pcap used to write the
@


1.5
log
@bring it to the latest 0.2 LBL release.
@
text
@d125 1
a125 1
.B tcpdump(1)
d333 1
a333 1
tcpdump(1), tcpslice(1)
@


1.4
log
@merge to latest libpcap
@
text
@d23 1
a23 1
.TH PCAP 3  "14 Jun 1994"
@


1.3
log
@Update to the latest LBL release.
@
text
@d1 2
a2 2
.\"	$OpenBSD$
.\"	$NetBSD: pcap.3,v 1.2 1995/03/06 11:39:03 mycroft Exp $
d43 1
a43 1
int pcap_lookupnet(char *device, u_long *netp,
d45 1
a45 1
u_long *maskp, char *errbuf)
d71 1
a71 1
char *str, int optimize, u_long netmask)
d177 1
a177 1
.I u_long
@


1.2
log
@pcap inject function is a good idea; from scottr@@edsi.org; netbsd pr#1747
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d60 4
d219 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
