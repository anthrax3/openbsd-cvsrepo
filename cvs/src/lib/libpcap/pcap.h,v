head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.6
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.16.0.6
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.10
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.6
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.24
	OPENBSD_5_0:1.14.0.22
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.20
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.18
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.14
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.16
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.12
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.10
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.10
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.12
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.10
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.8
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.6
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.04.06.08.02.56;	author jasper;	state Exp;
branches;
next	1.17;
commitid	5B5VobgACSkmC9RT;

1.17
date	2016.04.02.08.49.49;	author dlg;	state Exp;
branches;
next	1.16;
commitid	BPyrNLQIxS9UMvYc;

1.16
date	2014.04.11.04.08.58;	author lteo;	state Exp;
branches;
next	1.15;

1.15
date	2012.05.25.01.58.08;	author lteo;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.26.20.58.51;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.18.11.05.39;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.24.18.29.38;	author naddy;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.17.23.29.12;	author ericj;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.17.22.29.47;	author dugsong;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.02.18.04.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.26.21.25.53;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	99.07.20.04.49.55;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.12.13.19.12;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.06.10.07.23.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.05.55.50;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.04.15.47.29;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.31.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@add two functions from libpcap-1.7.4 which are required by at least gopacket

ok lteo@@ "go for it" dlg@@
@
text
@/*	$OpenBSD: pcap.h,v 1.17 2016/04/02 08:49:49 dlg Exp $	*/

/*
 * Copyright (c) 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lib_pcap_h
#define lib_pcap_h

#include <sys/types.h>
#include <sys/time.h>

#include <net/bpf.h>

#include <stdio.h>

#define PCAP_VERSION_MAJOR 2
#define PCAP_VERSION_MINOR 4

#define PCAP_ERRBUF_SIZE 256

/*
 * Compatibility for systems that have a bpf.h that
 * predates the bpf typedefs for 64-bit support.
 */
#if BPF_RELEASE - 0 < 199406
typedef	int bpf_int32;
typedef	u_int bpf_u_int32;
#endif

typedef struct pcap pcap_t;
typedef struct pcap_if pcap_if_t;
typedef struct pcap_addr pcap_addr_t;
typedef struct pcap_dumper pcap_dumper_t;

/*
 * The first record in the file contains saved values for some
 * of the flags used in the printout phases of tcpdump.
 * Many fields here are 32 bit ints so compilers won't insert unwanted
 * padding; these files need to be interchangeable across architectures.
 */
struct pcap_file_header {
	bpf_u_int32 magic;
	u_short version_major;
	u_short version_minor;
	bpf_int32 thiszone;	/* gmt to local correction */
	bpf_u_int32 sigfigs;	/* accuracy of timestamps */
	bpf_u_int32 snaplen;	/* max length saved portion of each pkt */
	bpf_u_int32 linktype;	/* data link type (DLT_*) */
};

typedef enum {
       PCAP_D_INOUT = 0,
       PCAP_D_IN,
       PCAP_D_OUT
} pcap_direction_t;

/*
 * Each packet in the dump file is prepended with this generic header.
 * This gets around the problem of different headers for different
 * packet interfaces.
 */
struct pcap_pkthdr {
	struct bpf_timeval ts;	/* time stamp */
	bpf_u_int32 caplen;	/* length of portion present */
	bpf_u_int32 len;	/* length this packet (off wire) */
};

/*
 * As returned by the pcap_stats()
 */
struct pcap_stat {
	u_int ps_recv;		/* number of packets received */
	u_int ps_drop;		/* number of packets dropped */
	u_int ps_ifdrop;	/* drops by interface XXX not yet supported */
};

/*
 * Item in a list of interfaces.
 */
struct pcap_if {
	struct pcap_if *next;
	char *name;		/* name to hand to "pcap_open_live()" */
	char *description;	/* textual description of interface, or NULL */
	struct pcap_addr *addresses;
	bpf_u_int32 flags;	/* PCAP_IF_ interface flags */
};

#define PCAP_IF_LOOPBACK	0x00000001	/* interface is loopback */

/*
 * Representation of an interface address.
 */
struct pcap_addr {
	struct pcap_addr *next;
	struct sockaddr *addr;		/* address */
	struct sockaddr *netmask;	/* netmask for that address */
	struct sockaddr *broadaddr;	/* broadcast address for that address */
	struct sockaddr *dstaddr;	/* P2P destination address for that address */
};

/*
 * Error codes for the pcap API.
 * These will all be negative, so you can check for the success or
 * failure of a call that returns these codes by checking for a
 * negative value.
 */
#define PCAP_ERROR			-1	/* generic error code */
#define PCAP_ERROR_BREAK		-2	/* loop terminated by pcap_breakloop */
#define PCAP_ERROR_NOT_ACTIVATED	-3	/* the capture needs to be activated */
#define PCAP_ERROR_ACTIVATED		-4	/* the operation can't be performed on already activated captures */
#define PCAP_ERROR_NO_SUCH_DEVICE	-5	/* no such device exists */
#define PCAP_ERROR_RFMON_NOTSUP		-6	/* this device doesn't support rfmon (monitor) mode */
#define PCAP_ERROR_NOT_RFMON		-7	/* operation supported only in monitor mode */
#define PCAP_ERROR_PERM_DENIED		-8	/* no permission to open the device */
#define PCAP_ERROR_IFACE_NOT_UP		-9	/* interface isn't up */
#define PCAP_ERROR_CANTSET_TSTAMP_TYPE	-10	/* this device doesn't support setting the time stamp type */
#define PCAP_ERROR_PROMISC_PERM_DENIED	-11	/* you don't have permission to capture in promiscuous mode */

/*
 * Warning codes for the pcap API.
 * These will all be positive and non-zero, so they won't look like
 * errors.
 */
#define PCAP_WARNING			1	/* generic warning code */
#define PCAP_WARNING_PROMISC_NOTSUP	2	/* this device doesn't support promiscuous mode */
#define PCAP_WARNING_TSTAMP_TYPE_NOTSUP	3	/* the requested time stamp type is not supported */

typedef void (*pcap_handler)(u_char *, const struct pcap_pkthdr *,
			     const u_char *);

__BEGIN_DECLS
char	*pcap_lookupdev(char *);
int	pcap_lookupnet(const char *, bpf_u_int32 *, bpf_u_int32 *, char *);

pcap_t	*pcap_create(const char *, char *);
int	pcap_set_snaplen(pcap_t *, int);
int	pcap_set_promisc(pcap_t *, int);
int	pcap_can_set_rfmon(pcap_t *);
int	pcap_set_rfmon(pcap_t *, int);
int	pcap_set_timeout(pcap_t *, int);
int	pcap_set_buffer_size(pcap_t *, int);
int	pcap_activate(pcap_t *);

pcap_t	*pcap_open_live(const char *, int, int, int, char *);
pcap_t	*pcap_open_dead(int, int);
pcap_t	*pcap_open_offline(const char *, char *);
pcap_t	*pcap_fopen_offline(FILE *, char *);
void	pcap_close(pcap_t *);
int	pcap_loop(pcap_t *, int, pcap_handler, u_char *);
int	pcap_dispatch(pcap_t *, int, pcap_handler, u_char *);
const u_char*
	pcap_next(pcap_t *, struct pcap_pkthdr *);
int 	pcap_next_ex(pcap_t *, struct pcap_pkthdr **, const u_char **);
void	pcap_breakloop(pcap_t *);
int	pcap_stats(pcap_t *, struct pcap_stat *);
int	pcap_setfilter(pcap_t *, struct bpf_program *);
int 	pcap_setdirection(pcap_t *, pcap_direction_t);
int	pcap_getnonblock(pcap_t *, char *);
int	pcap_setnonblock(pcap_t *, int, char *);
void	pcap_perror(pcap_t *, char *);
int	pcap_inject(pcap_t *, const void *, size_t);
int	pcap_sendpacket(pcap_t *, const u_char *, int);
const char *pcap_statustostr(int);
char	*pcap_strerror(int);
char	*pcap_geterr(pcap_t *);
int	pcap_compile(pcap_t *, struct bpf_program *, char *, int,
	    bpf_u_int32);
int	pcap_compile_nopcap(int, int, struct bpf_program *,
	    char *, int, bpf_u_int32);
void	pcap_freecode(struct bpf_program *);
int	pcap_offline_filter(const struct bpf_program *,
	    const struct pcap_pkthdr *, const u_char *);
int	pcap_datalink(pcap_t *);
int	pcap_list_datalinks(pcap_t *, int **);
int	pcap_set_datalink(pcap_t *, int);
void	pcap_free_datalinks(int *);
int	pcap_datalink_name_to_val(const char *);
const char *pcap_datalink_val_to_name(int);
const char *pcap_datalink_val_to_description(int);
int	pcap_snapshot(pcap_t *);
int	pcap_is_swapped(pcap_t *);
int	pcap_major_version(pcap_t *);
int	pcap_minor_version(pcap_t *);

/* XXX */
FILE	*pcap_file(pcap_t *);
int	pcap_fileno(pcap_t *);

pcap_dumper_t *pcap_dump_open(pcap_t *, const char *);
pcap_dumper_t *pcap_dump_fopen(pcap_t *, FILE *fp);
FILE	*pcap_dump_file(pcap_dumper_t *);
long	pcap_dump_ftell(pcap_dumper_t *);
int	pcap_dump_flush(pcap_dumper_t *);
void	pcap_dump_close(pcap_dumper_t *);
void	pcap_dump(u_char *, const struct pcap_pkthdr *, const u_char *);

int	pcap_findalldevs(pcap_if_t **, char *);
void	pcap_freealldevs(pcap_if_t *);

const char *pcap_lib_version(void);

char	*bpf_image(struct bpf_insn *, int);

int	pcap_get_selectable_fd(pcap_t *);

__END_DECLS
#endif
@


1.17
log
@refactor bpf_filter a bit.

the code was confusing around how it dealt with packets in mbufs
vs plain memory buffers with a lenght.

this renames bpf_filter to _bpf_filter, and changes it so the packet
memory is referred to by an opaque pointer, and callers have to
provide a set of operations to extra values from that opaque pointer.

bpf_filter is now provided as a wrapper around _bpf_filter. it
provides a set of operators that work on a straight buffer with a
lenght.

this also adds a bpf_mfilter function which takes an mbuf instead
of a buffer, and it provides explicit operations for extracting
values from mbufs.

if we want to use bpf filters against other data structures (usb
or scsi packets maybe?) we are able to provide functions for
extracting payloads from them and use _bpf_filter as is.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.16 2014/04/11 04:08:58 lteo Exp $	*/
d201 2
d206 1
@


1.16
log
@Zap CVS $Header tags, reduces diff with upstream's repo

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.15 2012/05/25 01:58:08 lteo Exp $	*/
a228 2
/* XXX this guy lives in the bpf tree */
u_int	bpf_filter(struct bpf_insn *, u_char *, u_int, u_int);
@


1.15
log
@Import a number of core functions from libpcap-1.2.0 while preserving
local changes: strncpy() -> strlcpy(), malloc(x * y) -> calloc(x, y),
exclude cross-platform cruft, etc.

The new functions are pcap_create(), pcap_set_snaplen(),
pcap_set_promisc(), pcap_can_set_rfmon(), pcap_set_rfmon(),
pcap_set_timeout(), pcap_set_buffer_size(), pcap_activate(), and
pcap_statustostr().

This diff was tested on amd64, i386, macppc, and sparc64, where
regression tests were done on various pcap-based ports (especially amd64
and i386 where regression tests were run on all pcap-based ports).
Testers also tried running pcap-based ports that they are familiar with
to ensure that there is no behavioral change.  tcpdump and pflogd in
base were also tested by different testers.  The new pcap_* functions
were tested with a proof-of-concept Snort 2.9 port for many months.

Thank you to everyone who helped test this diff and provided feedback:
haesbaert@@, sthen@@, matthew@@, gonzalo@@, brett@@, Rodolfo Gouveia,
Aaron Bieber, Markus Lude, and Ray Percival.

ok haesbaert sthen henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.14 2006/03/26 20:58:51 djm Exp $	*/
a33 2
 *
 * @@(#) $Header: /cvs/src/lib/libpcap/pcap.h,v 1.14 2006/03/26 20:58:51 djm Exp $ (LBL)
@


1.14
log
@add remaining tcpdump.org libpcap 0.9 APIs, most notably
pcap_setdirection() (which depends on the kernel-side bpf changes
committed yesterday); ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.13 2005/11/18 11:05:39 djm Exp $	*/
d35 1
a35 1
 * @@(#) $Header: /cvs/src/lib/libpcap/pcap.h,v 1.13 2005/11/18 11:05:39 djm Exp $ (LBL)
d133 27
d166 10
d195 1
@


1.13
log
@pull in the good bits of libpcap-0.9.4's API without the cross-platform
cruft. help from deraadt@@, mpf@@, jmc@@; ok mpf@@a

nb. this will break tcpdump unless it updated too
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.12 2004/06/24 18:29:38 naddy Exp $	*/
d35 1
a35 1
 * @@(#) $Header: /cvs/src/lib/libpcap/pcap.h,v 1.12 2004/06/24 18:29:38 naddy Exp $ (LBL)
d83 6
d138 1
a138 1
int	pcap_lookupnet(char *, bpf_u_int32 *, bpf_u_int32 *, char *);
d140 1
d142 1
a142 1
pcap_t	*pcap_open_dead(int, int);
d148 2
a150 1
int	pcap_inject(pcap_t *, const void *, size_t);
d152 1
d156 2
a164 1
void	pcap_breakloop(pcap_t *);
a170 1
const char *pcap_lib_version(void);
d181 4
d191 2
d196 3
@


1.12
log
@make safe for inclusion in C++ code; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.11 2002/01/17 23:29:12 ericj Exp $	*/
d35 1
a35 1
 * @@(#) $Header: /cvs/src/lib/libpcap/pcap.h,v 1.11 2002/01/17 23:29:12 ericj Exp $ (LBL)
d63 2
d103 24
d133 1
a133 1
pcap_t	*pcap_open_live(char *, int, int, int, char *);
d135 1
d144 2
d154 1
d156 6
d174 3
@


1.11
log
@
add pcap_inject back into the header file
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.10 2001/12/17 22:29:47 dugsong Exp $	*/
d35 1
a35 1
 * @@(#) $Header: /cvs/src/lib/libpcap/pcap.h,v 1.10 2001/12/17 22:29:47 dugsong Exp $ (LBL)
d104 1
d142 1
@


1.10
log
@fix memory leak associated with compiled BPF program, sync'd from tcpdump.org. ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.9 2001/10/02 18:04:35 deraadt Exp $	*/
d35 1
a35 1
 * @@(#) $Header: /cvs/src/lib/libpcap/pcap.h,v 1.9 2001/10/02 18:04:35 deraadt Exp $ (LBL)
d114 1
@


1.9
log
@change timeval to bpf_timeval; 32 bit in size, permitting much greater portability
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.8 2000/04/26 21:25:53 jakob Exp $	*/
d35 1
a35 1
 * @@(#) $Header: /cvs/src/lib/libpcap/pcap.h,v 1.8 2000/04/26 21:25:53 jakob Exp $ (LBL)
d122 1
a122 2
/* XXX */
int	pcap_freecode(pcap_t *, struct bpf_program *);
@


1.8
log
@sync with libpcap v0.5
add support for INET6 (kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.7 1999/07/20 04:49:55 deraadt Exp $	*/
d35 1
a35 1
 * @@(#) $Header: /cvs/src/lib/libpcap/pcap.h,v 1.7 1999/07/20 04:49:55 deraadt Exp $ (LBL)
d87 1
a87 1
	struct timeval ts;	/* time stamp */
@


1.7
log
@changes brought in from v0.4; started by brad, more by me, being tested by mts
@
text
@d1 1
a1 1
/*	$OpenBSD: pcap.h,v 1.6 1996/07/12 13:19:12 mickey Exp $	*/
d35 1
a35 1
 * @@(#) $Header: pcap.h,v 1.21 97/10/15 21:59:13 leres Exp $ (LBL)
d120 2
@


1.6
log
@bring it to the latest 0.2 LBL release.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1993, 1994, 1995, 1996
d35 1
a35 1
 * @@(#) Header: pcap.h,v 1.19 96/06/16 22:36:28 leres Exp (LBL)
d107 1
a107 1
pcap_t	*pcap_open_offline(char *, char *);
d132 1
a132 1
pcap_dumper_t *pcap_dump_open(pcap_t *, char *);
a138 4

/* XXX */
extern	int pcap_fddipad;

@


1.5
log
@merge to latest libpcap
@
text
@d1 1
a1 2
/*	$OpenBSD */
/*	$NetBSD: pcap.h,v 1.3.4.1 1996/06/05 18:04:46 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1993, 1994
d35 1
a35 1
 * @@(#) Header: pcap.h,v 1.15 94/06/14 20:03:34 leres Exp (LBL)
d58 2
a59 2
typedef	int32_t bpf_int32;
typedef	u_int32_t bpf_u_int32;
d68 1
a68 1
 * Many fields here are longs so compilers won't insert unwanted
d105 1
a105 1
int	pcap_lookupnet(char *, u_int32_t *, u_int32_t *, char *);
d118 2
a119 1
int	pcap_compile(pcap_t *, struct bpf_program *, char *, int, u_int32_t);
d139 3
@


1.4
log
@correct bpf types
@
text
@d1 2
a2 2
/*	$OpenBSD: pcap.h,v 1.3 1996/03/04 15:47:29 mickey Exp $	*/
/*	$NetBSD: pcap.h,v 1.3 1996/05/02 00:18:28 cgd Exp $	*/
d106 1
a106 1
int	pcap_lookupnet(char *, u_long *, u_long *, char *);
a113 1
int	pcap_inject(pcap_t *, const void *, size_t);
d119 1
a119 1
int	pcap_compile(pcap_t *, struct bpf_program *, char *, int, u_long);
@


1.3
log
@Update to the latest LBL release.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pcap.h,v 1.2 1995/03/06 11:39:07 mycroft Exp $	*/
d59 2
a60 2
typedef	long bpf_int32;
typedef	u_long bpf_u_int32;
@


1.2
log
@pcap inject function is a good idea; from scottr@@edsi.org; netbsd pr#1747
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d113 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
