head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.2
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.23.0.8
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.20
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.12
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.16
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.14
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.10
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.8
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.6
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2017.07.09.15.32.09;	author espie;	state Exp;
branches;
next	1.23;
commitid	jLQKtv5gU8KrwpLr;

1.23
date	2015.11.17.21.39.23;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	QwVD4AKITH4IBHi1;

1.22
date	2011.03.28.07.54.16;	author giovanni;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.30;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.11.15.02.21;	author dtucker;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.02.18.31.21;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.18.18.17.52;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.18.16.59.02;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.07.19.32.39;	author mpf;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.27.18.26.57;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.14.08.50.37;	author canacar;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.26.22.43.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.23.01.33.16;	author frantzen;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.06.23.52.24;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.29.06.56.13;	author dugsong;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.26.21.25.53;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	99.07.20.04.49.56;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.06.26.21.01.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.22.07.42.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.12.13.19.13;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.06.18.16.26.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.23.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.47.30;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@use working boilerplate for yacc/lex instead of homemade rules.
okay millert@@
(forgot the obvious scanner.l tweak in my diff)
@
text
@%{
/*	$OpenBSD: scanner.l,v 1.23 2015/11/17 21:39:23 mmcc Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/types.h>
#include <sys/time.h>

#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <vis.h>

#include "pcap-int.h"

#include "gencode.h"
#include <pcap-namedb.h>

#ifdef INET6
#include <netdb.h> 
#include <sys/socket.h>
#endif /*INET6*/

#ifdef HAVE_OS_PROTO_H
#include "os-proto.h"
#endif

#include "grammar.h"

static int stoi(char *);
static inline int xdtoi(int);

#ifdef FLEX_SCANNER
#define YY_NO_UNPUT
#undef YY_INPUT
#define YY_INPUT(buf, result, max)\
 {\
	char *src = in_buffer;\
	int i;\
\
	if (*src == 0)\
		result = YY_NULL;\
	else {\
		for (i = 0; *src && i < max; ++i)\
			buf[i] = *src++;\
		in_buffer += i;\
		result = i;\
	}\
 }
#else
#undef getc
#define getc(fp)  (*in_buffer == 0 ? EOF : *in_buffer++)
#endif

extern YYSTYPE yylval;

static char *in_buffer;

%}

N		([0-9]+|(0X|0x)[0-9A-Fa-f]+)
B		([0-9A-Fa-f][0-9A-Fa-f]?)
W		([0-9A-Fa-f][0-9A-Fa-f]?[0-9A-Fa-f]?[0-9A-Fa-f]?)

%a 15000
%o 17000
%e 6000
%k 4000
%p 19000

V680		{W}:{W}:{W}:{W}:{W}:{W}:{W}:{W}

V670		::{W}:{W}:{W}:{W}:{W}:{W}:{W}
V671		{W}::{W}:{W}:{W}:{W}:{W}:{W}
V672		{W}:{W}::{W}:{W}:{W}:{W}:{W}
V673		{W}:{W}:{W}::{W}:{W}:{W}:{W}
V674		{W}:{W}:{W}:{W}::{W}:{W}:{W}
V675		{W}:{W}:{W}:{W}:{W}::{W}:{W}
V676		{W}:{W}:{W}:{W}:{W}:{W}::{W}
V677		{W}:{W}:{W}:{W}:{W}:{W}:{W}::

V660		::{W}:{W}:{W}:{W}:{W}:{W}
V661		{W}::{W}:{W}:{W}:{W}:{W}
V662		{W}:{W}::{W}:{W}:{W}:{W}
V663		{W}:{W}:{W}::{W}:{W}:{W}
V664		{W}:{W}:{W}:{W}::{W}:{W}
V665		{W}:{W}:{W}:{W}:{W}::{W}
V666		{W}:{W}:{W}:{W}:{W}:{W}::

V650		::{W}:{W}:{W}:{W}:{W}
V651		{W}::{W}:{W}:{W}:{W}
V652		{W}:{W}::{W}:{W}:{W}
V653		{W}:{W}:{W}::{W}:{W}
V654		{W}:{W}:{W}:{W}::{W}
V655		{W}:{W}:{W}:{W}:{W}::

V640		::{W}:{W}:{W}:{W}
V641		{W}::{W}:{W}:{W}
V642		{W}:{W}::{W}:{W}
V643		{W}:{W}:{W}::{W}
V644		{W}:{W}:{W}:{W}::

V630		::{W}:{W}:{W}
V631		{W}::{W}:{W}
V632		{W}:{W}::{W}
V633		{W}:{W}:{W}::

V620		::{W}:{W}
V621		{W}::{W}
V622		{W}:{W}::

V610		::{W}
V611		{W}::

V600		::

V6604		{W}:{W}:{W}:{W}:{W}:{W}:{N}\.{N}\.{N}\.{N}

V6504		::{W}:{W}:{W}:{W}:{W}:{N}\.{N}\.{N}\.{N}
V6514		{W}::{W}:{W}:{W}:{W}:{N}\.{N}\.{N}\.{N}
V6524		{W}:{W}::{W}:{W}:{W}:{N}\.{N}\.{N}\.{N}
V6534		{W}:{W}:{W}::{W}:{W}:{N}\.{N}\.{N}\.{N}
V6544		{W}:{W}:{W}:{W}::{W}:{N}\.{N}\.{N}\.{N}
V6554		{W}:{W}:{W}:{W}:{W}::{N}\.{N}\.{N}\.{N}

V6404		::{W}:{W}:{W}:{W}:{N}\.{N}\.{N}\.{N}
V6414		{W}::{W}:{W}:{W}:{N}\.{N}\.{N}\.{N}
V6424		{W}:{W}::{W}:{W}:{N}\.{N}\.{N}\.{N}
V6434		{W}:{W}:{W}::{W}:{N}\.{N}\.{N}\.{N}
V6444		{W}:{W}:{W}:{W}::{N}\.{N}\.{N}\.{N}

V6304		::{W}:{W}:{W}:{N}\.{N}\.{N}\.{N}
V6314		{W}::{W}:{W}:{N}\.{N}\.{N}\.{N}
V6324		{W}:{W}::{W}:{N}\.{N}\.{N}\.{N}
V6334		{W}:{W}:{W}::{N}\.{N}\.{N}\.{N}

V6204		::{W}:{W}:{N}\.{N}\.{N}\.{N}
V6214		{W}::{W}:{N}\.{N}\.{N}\.{N}
V6224		{W}:{W}::{N}\.{N}\.{N}\.{N}

V6104		::{W}:{N}\.{N}\.{N}\.{N}
V6114		{W}::{N}\.{N}\.{N}\.{N}

V6004		::{N}\.{N}\.{N}\.{N}


V6		({V680}|{V670}|{V671}|{V672}|{V673}|{V674}|{V675}|{V676}|{V677}|{V660}|{V661}|{V662}|{V663}|{V664}|{V665}|{V666}|{V650}|{V651}|{V652}|{V653}|{V654}|{V655}|{V640}|{V641}|{V642}|{V643}|{V644}|{V630}|{V631}|{V632}|{V633}|{V620}|{V621}|{V622}|{V610}|{V611}|{V600}|{V6604}|{V6504}|{V6514}|{V6524}|{V6534}|{V6544}|{V6554}|{V6404}|{V6414}|{V6424}|{V6434}|{V6444}|{V6304}|{V6314}|{V6324}|{V6334}|{V6204}|{V6214}|{V6224}|{V6104}|{V6114}|{V6004})

%%
dst		return DST;
src		return SRC;

link|ether|ppp|slip  return LINK;
fddi		return LINK;
arp		return ARP;
rarp		return RARP;
ip		return IP;
tcp		return TCP;
udp		return UDP;
icmp		return ICMP;
igmp		return IGMP;
igrp		return IGRP;
pim		return PIM;

ip6		return IPV6;
icmp6		return ICMPV6;
ah		return AH;
esp		return ESP;

atalk		return ATALK;
decnet		return DECNET;
lat		return LAT;
sca		return SCA;
moprc		return MOPRC;
mopdl		return MOPDL;
stp		return STP;

host		return HOST;
net		return NET;
mask		return MASK;
port		return PORT;
proto		return PROTO;
protochain	{
#ifdef NO_PROTOCHAIN
		  bpf_error("%s not supported", yytext);
#else
		  return PROTOCHAIN;
#endif
		}

gateway		return GATEWAY;

less		return LESS;
greater		return GREATER;
byte		return BYTE;
broadcast	return TK_BROADCAST;
multicast	return TK_MULTICAST;

and|"&&"	return AND;
or|"||"		return OR;
not		return '!';

len|length	return LEN;
inbound		return INBOUND;
outbound	return OUTBOUND;

vlan		return VLAN;

on|ifname	return PF_IFNAME;
rset|ruleset	return PF_RSET;
rnr|rulenum	return PF_RNR;
srnr|subrulenum	return PF_SRNR;
reason		return PF_REASON;
action		return PF_ACTION;

wlan		return LINK;
type		return TYPE;
subtype		return SUBTYPE;
direction|dir	return DIR;
address1|addr1	return ADDR1;
address2|addr2	return ADDR2;
address3|addr3	return ADDR3;
address4|addr4	return ADDR4;

[ \n\t]			;
[+\-*/:\[\]!<>()&|=]	return yytext[0];
">="			return GEQ;
"<="			return LEQ;
"!="			return NEQ;
"=="			return '=';
"<<"			return LSH;
">>"			return RSH;
{N}			{ yylval.i = stoi((char *)yytext); return NUM; }
({N}\.{N})|({N}\.{N}\.{N})|({N}\.{N}\.{N}\.{N})	{
			yylval.s = sdup((char *)yytext); return HID; }
{B}:{B}:{B}:{B}:{B}:{B} { yylval.e = pcap_ether_aton((char *)yytext);
			  return EID; }
{V6}			{
#ifdef INET6
			  struct addrinfo hints, *res;
			  memset(&hints, 0, sizeof(hints));
			  hints.ai_family = AF_INET6;
			  hints.ai_flags = AI_NUMERICHOST;
			  if (getaddrinfo(yytext, NULL, &hints, &res))
				bpf_error("bogus IPv6 address %s", yytext);
			  else {
				yylval.e = sdup((char *)yytext); return HID6;
			  }
#else
			  bpf_error("IPv6 address %s not supported", yytext);
#endif /*INET6*/
			}
{B}:+({B}:+)+		{ bpf_error("bogus ethernet address %s", yytext); }
icmptype		{ yylval.i = 0; return NUM; }
icmpcode		{ yylval.i = 1; return NUM; }
icmp-echoreply		{ yylval.i = 0; return NUM; }
icmp-unreach		{ yylval.i = 3; return NUM; }
icmp-sourcequench	{ yylval.i = 4; return NUM; }
icmp-redirect		{ yylval.i = 5; return NUM; }
icmp-echo		{ yylval.i = 8; return NUM; }
icmp-routeradvert	{ yylval.i = 9; return NUM; }
icmp-routersolicit	{ yylval.i = 10; return NUM; }
icmp-timxceed		{ yylval.i = 11; return NUM; }
icmp-paramprob		{ yylval.i = 12; return NUM; }
icmp-tstamp		{ yylval.i = 13; return NUM; }
icmp-tstampreply	{ yylval.i = 14; return NUM; }
icmp-ireq		{ yylval.i = 15; return NUM; }
icmp-ireqreply		{ yylval.i = 16; return NUM; }
icmp-maskreq		{ yylval.i = 17; return NUM; }
icmp-maskreply		{ yylval.i = 18; return NUM; }
tcpflags		{ yylval.i = 13; return NUM; }
tcp-fin			{ yylval.i = 0x01; return NUM; }
tcp-syn			{ yylval.i = 0x02; return NUM; }
tcp-rst			{ yylval.i = 0x04; return NUM; }
tcp-push		{ yylval.i = 0x08; return NUM; }
tcp-ack			{ yylval.i = 0x10; return NUM; }
tcp-urg			{ yylval.i = 0x20; return NUM; }
[A-Za-z0-9][-_.A-Za-z0-9]*[.A-Za-z0-9] {
			 yylval.s = sdup((char *)yytext); return ID; }
[A-Za-z] {		 yylval.s = sdup((char *)yytext); return ID; }
"\\"[^ !()\n\t]+	{ yylval.s = sdup((char *)yytext + 1); return ID; }
[^ \[\]\t\n\-_.A-Za-z0-9!<>()&|=]+ {
			size_t len = strlen(yytext) * 4 + 1;
			char *v = malloc(len);
			if (v != NULL)
				strnvis(v, yytext, len, 0);
			bpf_error("illegal token: %s", v);
			free(v);
			}
.			{
			  char v[5];

			  vis(v, *yytext, VIS_OCTAL, 0);
			  bpf_error("illegal char '%s'", v);
			}
%%
void
lex_init(buf)
	char *buf;
{
	in_buffer = buf;
	yyrestart(NULL);
}

/*
 * Also define a yywrap.  Note that if we're using flex, it will
 * define a macro to map this identifier to pcap_wrap.
 */
int
yywrap()
{
	return 1;
}

/* Hex digit to integer. */
static inline int
xdtoi(c)
	int c;
{
	if (isdigit(c))
		return c - '0';
	else if (islower(c))
		return c - 'a' + 10;
	else
		return c - 'A' + 10;
}

/*
 * Convert string to integer.  Just like atoi(), but checks for
 * preceding 0x or 0 and uses hex or octal instead of decimal.
 */
static int
stoi(s)
	char *s;
{
	int base = 10;
	int n = 0;

	if (*s == '0') {
		if (s[1] == 'x' || s[1] == 'X') {
			s += 2;
			base = 16;
		}
		else {
			base = 8;
			s += 1;
		}
	}
	while (*s)
		n = n * base + xdtoi(*s++);

	return n;
}

@


1.23
log
@Remove register keyword.

ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.22 2011/03/28 07:54:16 giovanni Exp $	*/
d47 1
a47 1
#include "grammar.tab.h"
@


1.22
log
@
Add icmptype and tcpflags support to the grammar
ok claudio@@ jsing@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.21 2009/10/27 23:59:30 deraadt Exp $	*/
d337 1
a337 1
	register int c;
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.20 2008/06/11 15:02:21 dtucker Exp $	*/
d273 24
@


1.20
log
@Import vlan support from upstream libpcap.  This allows, eg, "tcpdump vla 3"
to work on a vlan parent interface.  ok mcbride@@, "commit it" deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.19 2007/01/02 18:31:21 reyk Exp $	*/
a23 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.19 2007/01/02 18:31:21 reyk Exp $ (LBL)";
#endif
@


1.19
log
@define bpf filters to match address and header fields in IEEE 802.11
wlan frames (DLT_IEEE802_11 and DLT_IEEE802_11_RADIO linktypes). see
tcpdump(8) for details.

"Works for me" claudio@@
ok jmc@@ deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.18 2006/04/18 18:17:52 otto Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.18 2006/04/18 18:17:52 otto Exp $ (LBL)";
d230 2
@


1.18
log
@strnvis illegal tokens as well and remove a spurious "i" that crept in
the pattern long ago; ok deraadt@@ and markus@@ for the "i" removal
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.17 2006/04/18 16:59:02 deraadt Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.17 2006/04/18 16:59:02 deraadt Exp $ (LBL)";
d237 9
@


1.17
log
@vis() illegal characters; ok otto
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.16 2005/10/07 19:32:39 mpf Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.16 2005/10/07 19:32:39 mpf Exp $ (LBL)";
d271 8
a278 2
[^ \[\]\t\n\-_.A-Za-z0-9!<>()&|=]+i {
			bpf_error("illegal token: %s\n", yytext); }
@


1.16
log
@Add Spanning Tree Protocol support.
Bump version to 3.1.
OK brad@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.15 2005/09/27 18:26:57 deraadt Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.15 2005/09/27 18:26:57 deraadt Exp $ (LBL)";
d36 1
d273 6
a278 1
.			{ bpf_error("illegal char '%c'", *yytext); }
@


1.15
log
@accept hostnames 1 char long; spotted by otto, ok otto
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.14 2003/05/14 08:50:37 canacar Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.14 2003/05/14 08:50:37 canacar Exp $ (LBL)";
d199 1
@


1.14
log
@libpcap and tcpdump now understand the new pflog datalink type.
old datalink type is still recognized.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.13 2002/08/26 22:43:53 deraadt Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.13 2002/08/26 22:43:53 deraadt Exp $ (LBL)";
d267 1
@


1.13
log
@must yyrestart after longjmp; moritz@@jodeit.org
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.12 2002/03/23 01:33:16 frantzen Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.12 2002/03/23 01:33:16 frantzen Exp $ (LBL)";
d230 1
d232 1
@


1.12
log
@language extensions for PF logs.  can specify direction, interface, rule
number, reason and action.  fix the ipv4/ipv6 distinction while I'm here.
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.11 2001/07/06 23:52:24 millert Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.11 2001/07/06 23:52:24 millert Exp $ (LBL)";
d275 1
@


1.11
log
@#include string.h to get memset() prototype
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.10 2000/06/29 06:56:13 dugsong Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.10 2000/06/29 06:56:13 dugsong Exp $ (LBL)";
d228 5
@


1.10
log
@remove legacy over-general :{B} match for MAC addresses, fixing filters like 'arp[6:2] = 2'. ok angelos@@
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.9 2000/04/26 21:25:53 jakob Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.9 2000/04/26 21:25:53 jakob Exp $ (LBL)";
d34 1
@


1.9
log
@sync with libpcap v0.5
add support for INET6 (kame)
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.8 1999/07/20 04:49:56 deraadt Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.8 1999/07/20 04:49:56 deraadt Exp $ (LBL)";
a235 2
:{B}			{ yylval.e = pcap_ether_aton(((char *)yytext)+1);
			  return AID; }
@


1.8
log
@changes brought in from v0.4; started by brad, more by me, being tested by mts
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.7 1998/06/26 21:01:03 deraadt Exp $	*/
d27 1
a27 1
    "@@(#) $Header: scanner.l,v 1.56 97/07/21 13:31:50 leres Exp $ (LBL)";
d41 5
d85 83
d169 1
a169 1
%a 3000
d185 6
d204 7
d236 2
d243 15
@


1.7
log
@handle single char hostnames; jch@@honig.net
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.6 1997/07/22 07:42:32 deraadt Exp $	*/
d26 2
a27 2
static char rcsid[] =
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.6 1997/07/22 07:42:32 deraadt Exp $ (LBL)";
d36 3
a38 1
#include <pcap.h>
a44 2
#include "pcap-int.h"
#include "gencode.h"
d51 1
d96 1
d98 1
d101 1
d107 1
d141 1
a141 1
[A-Za-z0-9]([-_.A-Za-z0-9]*[.A-Za-z0-9])? {
@


1.6
log
@permit numbers at start of hostname; leres@@ee.lbl.gov
@
text
@d2 1
a2 1
/*	$OpenBSD: scanner.l,v 1.5 1996/07/12 13:19:13 mickey Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/lib/libpcap/scanner.l,v 1.5 1996/07/12 13:19:13 mickey Exp $ (LBL)";
d136 1
a136 1
[A-Za-z0-9][-_.A-Za-z0-9]*[.A-Za-z0-9] {
@


1.5
log
@bring it to the latest 0.2 LBL release.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d5 1
a5 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
d27 1
a27 1
    "@@(#) $Header: scanner.l,v 1.49 96/06/05 21:33:22 leres Exp $ (LBL)";
d132 1
a132 2
			yylval.s = sdup((char *)yytext); return HID;
}
d136 2
a137 1
[A-Za-z][-_.A-Za-z0-9]*	{ yylval.s = sdup((char *)yytext); return ID; }
d139 2
a140 1
[^ \[\]\t\n\-_.A-Za-z0-9!<>()&|=]+    { bpf_error("illegal token: %s\n", yytext); }
@


1.4
log
@libpcap used yyparse(), which is bad; netbsd pr#2031; lukem@@supp.cpr.itg.telecom.com.au
@
text
@d2 1
a2 2
/*	$OpenBSD */
/*	$NetBSD: scanner.l,v 1.2 1995/03/06 11:39:12 mycroft Exp $	*/
d5 1
a5 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
d27 1
a27 1
    "@@(#) Header: scanner.l,v 1.40 94/06/10 17:21:44 mccanne Exp (LBL)";
d34 2
d39 5
a46 4
#ifndef __GNUC__
#define inline
#endif

d94 1
@


1.3
log
@merge to latest libpcap
@
text
@d39 1
a39 1
#include "y.tab.h"
@


1.2
log
@Update to the latest LBL release.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d2 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
