head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.10.0.10
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.24
	OPENBSD_5_0:1.9.0.22
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.20
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.18
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.14
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.18
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.16
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.14
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.12
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.10
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.12.22.19.51.04;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	3htqtDr2Y7QvJUxm;

1.15
date	2015.11.17.21.39.23;	author mmcc;	state Exp;
branches;
next	1.14;
commitid	QwVD4AKITH4IBHi1;

1.14
date	2015.11.17.18.19.45;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	XWxlXM1Hks3HcyxP;

1.13
date	2015.01.16.03.19.57;	author lteo;	state Exp;
branches;
next	1.12;
commitid	ueE517C2m8kG4VWx;

1.12
date	2014.03.14.03.45.41;	author lteo;	state Exp;
branches;
next	1.11;

1.11
date	2014.03.14.03.44.13;	author lteo;	state Exp;
branches;
next	1.10;

1.10
date	2012.05.25.01.58.08;	author lteo;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.26.20.58.51;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.27.06.58.03;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	99.07.20.04.49.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.07.19.23.25.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.07.14.00.14.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.12.13.19.13;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.23.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.47.30;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@remove NULL-checks before free()
@
text
@/*	$OpenBSD: savefile.c,v 1.15 2015/11/17 21:39:23 mmcc Exp $	*/

/*
 * Copyright (c) 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * savefile.c - supports offline use of tcpdump
 *	Extraction/creation by Jeffrey Mogul, DECWRL
 *	Modified by Steve McCanne, LBL.
 *
 * Used to save the received packet headers, after filtering, to
 * a file, and then read them later.
 * The first record in the file contains saved values for the machine
 * dependent values so we can print the dump file on any architecture.
 */

#include <sys/types.h>
#include <sys/time.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#ifdef HAVE_OS_PROTO_H
#include "os-proto.h"
#endif

#include "pcap-int.h"

#define TCPDUMP_MAGIC 0xa1b2c3d4

/*
 * We use the "receiver-makes-right" approach to byte order,
 * because time is at a premium when we are writing the file.
 * In other words, the pcap_file_header and pcap_pkthdr,
 * records are written in host byte order.
 * Note that the packets are always written in network byte order.
 *
 * ntoh[ls] aren't sufficient because we might need to swap on a big-endian
 * machine (if the file was written in little-end order).
 */
#define	SWAPLONG(y) \
((((y)&0xff)<<24) | (((y)&0xff00)<<8) | (((y)&0xff0000)>>8) | (((y)>>24)&0xff))
#define	SWAPSHORT(y) \
	( (((y)&0xff)<<8) | ((u_short)((y)&0xff00)>>8) )

#define SFERR_TRUNC		1
#define SFERR_BADVERSION	2
#define SFERR_BADF		3
#define SFERR_EOF		4 /* not really an error, just a status */

static int
sf_write_header(FILE *fp, int linktype, int thiszone, int snaplen)
{
	struct pcap_file_header hdr;

	hdr.magic = TCPDUMP_MAGIC;
	hdr.version_major = PCAP_VERSION_MAJOR;
	hdr.version_minor = PCAP_VERSION_MINOR;

	hdr.thiszone = thiszone;
	hdr.snaplen = snaplen;
	hdr.sigfigs = 0;
	hdr.linktype = linktype;

	if (fwrite((char *)&hdr, sizeof(hdr), 1, fp) != 1)
		return (-1);

	return (0);
}

static void
swap_hdr(struct pcap_file_header *hp)
{
	hp->version_major = SWAPSHORT(hp->version_major);
	hp->version_minor = SWAPSHORT(hp->version_minor);
	hp->thiszone = SWAPLONG(hp->thiszone);
	hp->sigfigs = SWAPLONG(hp->sigfigs);
	hp->snaplen = SWAPLONG(hp->snaplen);
	hp->linktype = SWAPLONG(hp->linktype);
}

pcap_t *
pcap_open_offline(const char *fname, char *errbuf)
{
	pcap_t *p;
	FILE *fp;

	if (fname[0] == '-' && fname[1] == '\0')
		fp = stdin;
	else {
		fp = fopen(fname, "r");
		if (fp == NULL) {
			snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s: %s", fname,
			    pcap_strerror(errno));
			return (NULL);
		}
	}
	p = pcap_fopen_offline(fp, errbuf);
	if (p == NULL) {
		if (fp != stdin)
			fclose(fp);
	}
	return (p);
}

pcap_t *
pcap_fopen_offline(FILE *fp, char *errbuf)
{
	pcap_t *p;
	struct pcap_file_header hdr;
	int linklen;

	p = calloc(1, sizeof(*p));
	if (p == NULL) {
		strlcpy(errbuf, "out of swap", PCAP_ERRBUF_SIZE);
		return (NULL);
	}

	/*
	 * Set this field so we don't double-close in pcap_close!
	 */
	p->fd = -1;

	if (fread((char *)&hdr, sizeof(hdr), 1, fp) != 1) {
		snprintf(errbuf, PCAP_ERRBUF_SIZE, "fread: %s",
		    pcap_strerror(errno));
		goto bad;
	}
	if (hdr.magic != TCPDUMP_MAGIC) {
		if (SWAPLONG(hdr.magic) != TCPDUMP_MAGIC) {
			snprintf(errbuf, PCAP_ERRBUF_SIZE,
			    "bad dump file format");
			goto bad;
		}
		p->sf.swapped = 1;
		swap_hdr(&hdr);
	}
	if (hdr.version_major < PCAP_VERSION_MAJOR) {
		snprintf(errbuf, PCAP_ERRBUF_SIZE, "archaic file format");
		goto bad;
	}
	p->tzoff = hdr.thiszone;
	p->snapshot = hdr.snaplen;
	p->linktype = hdr.linktype;
	p->sf.rfile = fp;
	p->bufsize = hdr.snaplen;

	/* Align link header as required for proper data alignment */
	/* XXX should handle all types */
	switch (p->linktype) {

	case DLT_EN10MB:
		linklen = 14;
		break;

	case DLT_FDDI:
		linklen = 13 + 8;	/* fddi_header + llc */
		break;

	case DLT_NULL:
	default:
		linklen = 0;
		break;
	}

	if (p->bufsize < 0)
		p->bufsize = BPF_MAXBUFSIZE;
	p->sf.base = malloc(p->bufsize + BPF_ALIGNMENT);
	if (p->sf.base == NULL) {
		strlcpy(errbuf, "out of swap", PCAP_ERRBUF_SIZE);
		goto bad;
	}
	p->buffer = p->sf.base + BPF_ALIGNMENT - (linklen % BPF_ALIGNMENT);
	p->sf.version_major = hdr.version_major;
	p->sf.version_minor = hdr.version_minor;
#ifdef PCAP_FDDIPAD
	/* XXX padding only needed for kernel fcode */
	pcap_fddipad = 0;
#endif

	return (p);
 bad:
	free(p);
	return (NULL);
}

/*
 * Read sf_readfile and return the next packet.  Return the header in hdr
 * and the contents in buf.  Return 0 on success, SFERR_EOF if there were
 * no more packets, and SFERR_TRUNC if a partial packet was encountered.
 */
static int
sf_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char *buf, int buflen)
{
	FILE *fp = p->sf.rfile;

	/* read the stamp */
	if (fread((char *)hdr, sizeof(struct pcap_pkthdr), 1, fp) != 1) {
		/* probably an EOF, though could be a truncated packet */
		return (1);
	}

	if (p->sf.swapped) {
		/* these were written in opposite byte order */
		hdr->caplen = SWAPLONG(hdr->caplen);
		hdr->len = SWAPLONG(hdr->len);
		hdr->ts.tv_sec = SWAPLONG(hdr->ts.tv_sec);
		hdr->ts.tv_usec = SWAPLONG(hdr->ts.tv_usec);
	}
	/*
	 * We interchanged the caplen and len fields at version 2.3,
	 * in order to match the bpf header layout.  But unfortunately
	 * some files were written with version 2.3 in their headers
	 * but without the interchanged fields.
	 */
	if (p->sf.version_minor < 3 ||
	    (p->sf.version_minor == 3 && hdr->caplen > hdr->len)) {
		int t = hdr->caplen;
		hdr->caplen = hdr->len;
		hdr->len = t;
	}

	if (hdr->caplen > buflen) {
		/*
		 * This can happen due to Solaris 2.3 systems tripping
		 * over the BUFMOD problem and not setting the snapshot
		 * correctly in the savefile header.  If the caplen isn't
		 * grossly wrong, try to salvage.
		 */
		static u_char *tp = NULL;
		static int tsize = 0;

		if (hdr->caplen > 65535) {
			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
			    "bogus savefile header");
			return (-1);
		}

		if (tsize < hdr->caplen) {
			tsize = ((hdr->caplen + 1023) / 1024) * 1024;
			free(tp);
			tp = malloc(tsize);
			if (tp == NULL) {
				tsize = 0;
				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
				    "BUFMOD hack malloc");
				return (-1);
			}
		}
		if (fread((char *)tp, hdr->caplen, 1, fp) != 1) {
			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
			    "truncated dump file");
			return (-1);
		}
		/*
		 * We can only keep up to buflen bytes.  Since caplen > buflen
		 * is exactly how we got here, we know we can only keep the
		 * first buflen bytes and must drop the remainder.  Adjust
		 * caplen accordingly, so we don't get confused later as
		 * to how many bytes we have to play with.
		 */
		hdr->caplen = buflen;
		memcpy((char *)buf, (char *)tp, buflen);

	} else {
		/* read the packet itself */

		if (fread((char *)buf, hdr->caplen, 1, fp) != 1) {
			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
			    "truncated dump file");
			return (-1);
		}
	}
	return (0);
}

/*
 * Print out packets stored in the file initialized by sf_read_init().
 * If cnt > 0, return after 'cnt' packets, otherwise continue until eof.
 */
int
pcap_offline_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
{
	struct bpf_insn *fcode = p->fcode.bf_insns;
	int status = 0;
	int n = 0;

	while (status == 0) {
		struct pcap_pkthdr h;

		status = sf_next_packet(p, &h, p->buffer, p->bufsize);
		if (status) {
			if (status == 1)
				return (0);
			return (status);
		}

		if (fcode == NULL ||
		    bpf_filter(fcode, p->buffer, h.len, h.caplen)) {
			(*callback)(user, &h, p->buffer);
			if (++n >= cnt && cnt > 0)
				break;
		}
	}
	/*XXX this breaks semantics tcpslice expects */
	return (n);
}

/*
 * Output a packet to the initialized dump file.
 */
void
pcap_dump(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
{
	FILE *f;

	f = (FILE *)user;
	/* XXX we should check the return status */
	(void)fwrite((char *)h, sizeof(*h), 1, f);
	(void)fwrite((char *)sp, h->caplen, 1, f);
}

static pcap_dumper_t *
pcap_setup_dump(pcap_t *p, FILE *f, const char *fname)
{
	if (sf_write_header(f, p->linktype, p->tzoff, p->snapshot) == -1) {
		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Can't write to %s: %s",
		    fname, pcap_strerror(errno));
		if (f != stdout)
			(void)fclose(f);
		return (NULL);
	}
	return ((pcap_dumper_t *)f);
}

/*
 * Initialize so that sf_write() will output to the file named 'fname'.
 */
pcap_dumper_t *
pcap_dump_open(pcap_t *p, const char *fname)
{
	FILE *f;
	if (fname[0] == '-' && fname[1] == '\0')
		f = stdout;
	else {
		f = fopen(fname, "w");
		if (f == NULL) {
			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "%s: %s",
			    fname, pcap_strerror(errno));
			return (NULL);
		}
	}
	return (pcap_setup_dump(p, f, fname));
}

/*
 * Initialize so that sf_write() will output to the given stream.
 */
pcap_dumper_t *
pcap_dump_fopen(pcap_t *p, FILE *f)
{	
	return (pcap_setup_dump(p, f, "stream"));
}

FILE *
pcap_dump_file(pcap_dumper_t *p)
{
	return ((FILE *)p);
}

long
pcap_dump_ftell(pcap_dumper_t *p)
{
	return (ftell((FILE *)p));
}

int
pcap_dump_flush(pcap_dumper_t *p)
{

	if (fflush((FILE *)p) == EOF)
		return (-1);
	else
		return (0);
}

void
pcap_dump_close(pcap_dumper_t *p)
{

#ifdef notyet
	if (ferror((FILE *)p))
		return-an-error;
	/* XXX should check return from fclose() too */
#endif
	(void)fclose((FILE *)p);
}
@


1.15
log
@Remove register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savefile.c,v 1.14 2015/11/17 18:19:45 mmcc Exp $	*/
d260 1
a260 2
			if (tp != NULL)
				free(tp);
@


1.14
log
@memory.h -> string.h

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savefile.c,v 1.13 2015/01/16 03:19:57 lteo Exp $	*/
d335 1
a335 1
	register FILE *f;
@


1.13
log
@Remove pointless casts for several malloc/calloc/free calls.  No object
file change.
@
text
@d1 1
a1 1
/*	$OpenBSD: savefile.c,v 1.12 2014/03/14 03:45:41 lteo Exp $	*/
a36 1
#include <memory.h>
d39 1
@


1.12
log
@Remove pointless casts.  No binary change.

suggested by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savefile.c,v 1.11 2014/03/14 03:44:13 lteo Exp $	*/
d187 1
a187 1
	p->sf.base = (u_char *)malloc(p->bufsize + BPF_ALIGNMENT);
d261 2
a262 2
				free((u_char *)tp);
			tp = (u_char *)malloc(tsize);
@


1.11
log
@Change a few malloc+memset calls to calloc.

ok deraadt@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savefile.c,v 1.10 2012/05/25 01:58:08 lteo Exp $	*/
d132 1
a132 1
	p = (pcap_t *)calloc(1, sizeof(*p));
@


1.10
log
@Import a number of core functions from libpcap-1.2.0 while preserving
local changes: strncpy() -> strlcpy(), malloc(x * y) -> calloc(x, y),
exclude cross-platform cruft, etc.

The new functions are pcap_create(), pcap_set_snaplen(),
pcap_set_promisc(), pcap_can_set_rfmon(), pcap_set_rfmon(),
pcap_set_timeout(), pcap_set_buffer_size(), pcap_activate(), and
pcap_statustostr().

This diff was tested on amd64, i386, macppc, and sparc64, where
regression tests were done on various pcap-based ports (especially amd64
and i386 where regression tests were run on all pcap-based ports).
Testers also tried running pcap-based ports that they are familiar with
to ensure that there is no behavioral change.  tcpdump and pflogd in
base were also tested by different testers.  The new pcap_* functions
were tested with a proof-of-concept Snort 2.9 port for many months.

Thank you to everyone who helped test this diff and provided feedback:
haesbaert@@, sthen@@, matthew@@, gonzalo@@, brett@@, Rodolfo Gouveia,
Aaron Bieber, Markus Lude, and Ray Percival.

ok haesbaert sthen henning
@
text
@d1 1
a1 1
/*	$OpenBSD: savefile.c,v 1.9 2006/03/26 20:58:51 djm Exp $	*/
d132 1
a132 1
	p = (pcap_t *)malloc(sizeof(*p));
a137 1
	memset((char *)p, 0, sizeof(*p));
@


1.9
log
@add remaining tcpdump.org libpcap 0.9 APIs, most notably
pcap_setdirection() (which depends on the kernel-side bpf changes
committed yesterday); ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savefile.c,v 1.8 2004/01/27 06:58:03 tedu Exp $	*/
d398 1
@


1.8
log
@remove $Header,  it was messing up cvs for me.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: savefile.c,v 1.7 1999/07/20 04:49:56 deraadt Exp $	*/
d104 25
a128 2
	register pcap_t *p;
	register FILE *fp;
d140 1
a140 1
	 * Set this field so we don't close stdin in pcap_close!
a143 10
	if (fname[0] == '-' && fname[1] == '\0')
		fp = stdin;
	else {
		fp = fopen(fname, "r");
		if (fp == NULL) {
			snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s: %s", fname,
			    pcap_strerror(errno));
			goto bad;
		}
	}
d344 13
d374 31
a404 2
	(void)sf_write_header(f, p->linktype, p->tzoff, p->snapshot);
	return ((pcap_dumper_t *)f);
@


1.7
log
@changes brought in from v0.4; started by brad, more by me, being tested by mts
@
text
@d1 1
a1 1
/*	$OpenBSD: savefile.c,v 1.5 1998/07/14 00:14:05 deraadt Exp $	*/
a31 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Header: savefile.c,v 1.37 97/10/15 21:58:58 leres Exp $ (LBL)";
#endif
@


1.6
log
@if pcap_dump_open() specified a snaplen of -1, make sure pcap_open_offline() does not malloc -1, but uses max snaplen; pointed out by mts@@nfr.net
@
text
@d4 1
a4 1
 * Copyright (c) 1993, 1994, 1995
d22 1
a22 7
 */
#ifndef lint
static char rcsid[] =
    "@@(#)Header: savefile.c,v 1.28 95/10/07 03:09:06 leres Exp (LBL)";
#endif

/*
d33 5
a40 2
#include <net/bpf.h>

d68 1
a68 1
	( (((y)&0xff)<<8) | (((y)&0xff00)>>8) )
d107 1
a107 1
pcap_open_offline(char *fname, char *errbuf)
d116 1
a116 1
		strcpy(errbuf, "out of swap");
d182 1
a182 1
		strlcpy(errbuf, "out of swap", PCAP_ERRBUFF_SIZE);
d188 4
d245 6
d257 1
d268 8
d340 1
a340 1
pcap_dump_open(pcap_t *p, char *fname)
@


1.5
log
@buf oflows
@
text
@d1 1
a1 1
/*	$OpenBSD: savefile.c,v 1.4 1996/07/12 13:19:13 mickey Exp $	*/
d181 2
d184 4
@


1.4
log
@bring it to the latest 0.2 LBL release.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 2
a135 1
			sprintf(errbuf, "%s: %s", fname, pcap_strerror(errno));
d140 2
a141 1
		sprintf(errbuf, "fread: %s", pcap_strerror(errno));
d146 2
a147 1
			sprintf(errbuf, "bad dump file format");
d154 1
a154 1
		sprintf(errbuf, "archaic file format");
d244 2
a245 1
				sprintf(p->errbuf, "BUFMOD hack malloc");
d250 2
a251 1
			sprintf(p->errbuf, "truncated dump file");
d260 2
a261 1
			sprintf(p->errbuf, "truncated dump file");
d326 1
a326 1
			sprintf(p->errbuf, "%s: %s",
@


1.3
log
@merge to latest libpcap
@
text
@d1 1
a1 2
/*	$OpenBSD */
/*	$NetBSD: savefile.c,v 1.2 1995/03/06 11:39:10 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1993, 1994
d25 1
a25 1
    "@@(#)Header: savefile.c,v 1.16 94/06/20 19:07:56 leres Exp (LBL)";
d50 4
d123 1
a123 5
#ifdef notdef
	bzero(p, sizeof(*p));
#else
	memset(p, 0, sizeof(*p));
#endif
d159 1
d161 17
a177 1
	linklen = 14;					/* XXX */
d226 24
a249 3
		sprintf(p->errbuf, "bad dump file format");
		return (-1);
	}
d251 2
a252 1
	/* read the packet itself */
d254 4
a257 3
	if (fread((char *)buf, hdr->caplen, 1, fp) != 1) {
		sprintf(p->errbuf, "truncated dump file");
		return (-1);
d277 5
a281 2
		if (status)
			return (-1);
d300 4
a303 1
	FILE * f = (FILE *)user;
d332 7
a338 1
	fclose((FILE *)p);
@


1.2
log
@Update to the latest LBL release.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d210 3
a212 24
		/*
		 * This can happen due to Solaris 2.3 systems tripping
		 * over the BUFMOD problem and not setting the snapshot
		 * correctly in the savefile header.  If the caplen isn't
		 * grossly wrong, try to salvage.
		 */
		static u_char *tp = NULL;
		static int tsize = 0;

		if (tsize < hdr->caplen) {
			tsize = ((hdr->caplen + 1023) / 1024) * 1024;
			if (tp != NULL)
				free((u_char *)tp);
			tp = (u_char *)malloc(tsize);
			if (tp == NULL) {
				sprintf(p->errbuf, "BUFMOD hack malloc");
				return (-1);
			}
		}
		if (fread((char *)tp, hdr->caplen, 1, fp) != 1) {
			sprintf(p->errbuf, "truncated dump file");
			return (-1);
		}
		memcpy((char *)buf, (char *)tp, buflen);
d214 1
a214 2
	} else {
		/* read the packet itself */
d216 3
a218 4
		if (fread((char *)buf, hdr->caplen, 1, fp) != 1) {
			sprintf(p->errbuf, "truncated dump file");
			return (-1);
		}
d238 2
a239 5
		if (status) {
			if (status == 1)
				return (0);
			return (status);
		}
@


1.1
log
@Initial revision
@
text
@d1 1
d210 24
a233 3
		sprintf(p->errbuf, "bad dump file format");
		return (-1);
	}
d235 2
a236 1
	/* read the packet itself */
d238 4
a241 3
	if (fread((char *)buf, hdr->caplen, 1, fp) != 1) {
		sprintf(p->errbuf, "truncated dump file");
		return (-1);
d261 5
a265 2
		if (status)
			return (-1);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
