head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.34
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.32
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.28
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.24
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.26
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.18
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.22
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.20
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.38
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.34
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.32
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.30
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.28
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.26
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.24
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.22
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.20
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.18
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.16
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.14
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.12
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.10
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	ncurses:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2010.01.12.23.22.08;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.28.22.58.53;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.22.18.02.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.11.28.17.49.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.11.19.01.14.21;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.09.17.04.14.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.07.24.17.08.22;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.17.56;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.03.56.05;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.21.33.12;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.02.21.33.12;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2004,2005 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1995                    *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/

/* panel.c -- implementation of panels library, some core routines */
#include "panel.priv.h"

MODULE_ID("$Id: panel.c,v 1.23 2005/02/19 18:04:31 tom Exp $")

/*+-------------------------------------------------------------------------
	_nc_retrace_panel (pan)
--------------------------------------------------------------------------*/
#ifdef TRACE
NCURSES_EXPORT(PANEL *)
_nc_retrace_panel(PANEL * pan)
{
  T((T_RETURN("%p"), pan));
  return pan;
}
#endif

/*+-------------------------------------------------------------------------
	_nc_my_visbuf(ptr)
--------------------------------------------------------------------------*/
#ifdef TRACE
#ifndef TRACE_TXT
NCURSES_EXPORT(const char *)
_nc_my_visbuf(const void *ptr)
{
  char temp[32];

  if (ptr != 0)
    sprintf(temp, "ptr:%p", ptr);
  else
    strcpy(temp, "<null>");
  return _nc_visbuf(temp);
}
#endif
#endif

/*+-------------------------------------------------------------------------
	dPanel(text,pan)
--------------------------------------------------------------------------*/
#ifdef TRACE
NCURSES_EXPORT(void)
_nc_dPanel(const char *text, const PANEL * pan)
{
  _tracef("%s id=%s b=%s a=%s y=%d x=%d",
	  text, USER_PTR(pan->user),
	  (pan->below) ? USER_PTR(pan->below->user) : "--",
	  (pan->above) ? USER_PTR(pan->above->user) : "--",
	  PSTARTY(pan), PSTARTX(pan));
}
#endif

/*+-------------------------------------------------------------------------
	dStack(fmt,num,pan)
--------------------------------------------------------------------------*/
#ifdef TRACE
NCURSES_EXPORT(void)
_nc_dStack(const char *fmt, int num, const PANEL * pan)
{
  char s80[80];

  sprintf(s80, fmt, num, pan);
  _tracef("%s b=%s t=%s", s80,
	  (_nc_bottom_panel) ? USER_PTR(_nc_bottom_panel->user) : "--",
	  (_nc_top_panel) ? USER_PTR(_nc_top_panel->user) : "--");
  if (pan)
    _tracef("pan id=%s", USER_PTR(pan->user));
  pan = _nc_bottom_panel;
  while (pan)
    {
      dPanel("stk", pan);
      pan = pan->above;
    }
}
#endif

/*+-------------------------------------------------------------------------
	Wnoutrefresh(pan) - debugging hook for wnoutrefresh
--------------------------------------------------------------------------*/
#ifdef TRACE
NCURSES_EXPORT(void)
_nc_Wnoutrefresh(const PANEL * pan)
{
  dPanel("wnoutrefresh", pan);
  wnoutrefresh(pan->win);
}
#endif

/*+-------------------------------------------------------------------------
	Touchpan(pan)
--------------------------------------------------------------------------*/
#ifdef TRACE
NCURSES_EXPORT(void)
_nc_Touchpan(const PANEL * pan)
{
  dPanel("Touchpan", pan);
  touchwin(pan->win);
}
#endif

/*+-------------------------------------------------------------------------
	Touchline(pan,start,count)
--------------------------------------------------------------------------*/
#ifdef TRACE
NCURSES_EXPORT(void)
_nc_Touchline(const PANEL * pan, int start, int count)
{
  char s80[80];

  sprintf(s80, "Touchline s=%d c=%d", start, count);
  dPanel(s80, pan);
  touchline(pan->win, start, count);
}
#endif

#ifndef TRACE
#  ifndef __GNUC__
     /* Some C compilers need something defined in a source file */
extern void _nc_dummy_panel(void);
void
_nc_dummy_panel(void)
{
}
#  endif
#endif
@


1.9
log
@ncurses-5.2-20010224
@
text
@d1 1
a1 1
/*	$OpenBSD: panel.c,v 1.8 2001/01/22 18:02:10 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d39 1
a39 1
MODULE_ID("$From: panel.c,v 1.20 2001/02/24 23:17:26 tom Exp $")
d41 15
d59 1
a59 1
_nc_my_visbuf (const void *ptr)
d61 7
a67 6
	char temp[32];
	if (ptr != 0)
		snprintf(temp, sizeof(temp), "ptr:%p", ptr);
	else
		strcpy(temp, "<null>");
	return _nc_visbuf(temp);
a71 1

d77 1
a77 2
_nc_dPanel 
(const char *text, const PANEL *pan)
d79 5
a83 5
	_tracef("%s id=%s b=%s a=%s y=%d x=%d",
		text, USER_PTR(pan->user),
		(pan->below) ?  USER_PTR(pan->below->user) : "--",
		(pan->above) ?  USER_PTR(pan->above->user) : "--",
		PSTARTY(pan), PSTARTX(pan));
d92 1
a92 2
_nc_dStack 
(const char *fmt, int num, const PANEL *pan)
d96 5
a100 5
  snprintf(s80,sizeof(s80),fmt,num,pan);
  _tracef("%s b=%s t=%s",s80,
	  (_nc_bottom_panel) ?  USER_PTR(_nc_bottom_panel->user) : "--",
	  (_nc_top_panel)    ?  USER_PTR(_nc_top_panel->user)    : "--");
  if(pan)
d103 1
a103 1
  while(pan)
d105 1
a105 1
      dPanel("stk",pan);
d116 1
a116 1
_nc_Wnoutrefresh (const PANEL *pan)
d118 1
a118 1
  dPanel("wnoutrefresh",pan);
d128 1
a128 1
_nc_Touchpan (const PANEL *pan)
d130 1
a130 1
  dPanel("Touchpan",pan);
d140 1
a140 2
_nc_Touchline 
(const PANEL *pan, int start, int count)
d143 4
a146 3
  snprintf(s80,sizeof(s80),"Touchline s=%d c=%d",start,count);
  dPanel(s80,pan);
  touchline(pan->win,start,count);
d153 5
a157 1
     void _nc_dummy_panel(void) { }
@


1.8
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: panel.c,v 1.7 1999/11/28 17:49:19 millert Exp $	*/
d39 1
a39 1
MODULE_ID("$From: panel.c,v 1.19 2000/12/10 02:20:43 tom Exp $")
d140 1
a140 1
     static char GCC_UNUSED dummy;
@


1.7
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: panel.c,v 1.6 1998/11/19 01:14:21 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d39 1
a39 1
MODULE_ID("$From: panel.c,v 1.18 1999/09/29 15:22:32 juergen Exp $")
d43 2
a44 1
const char *_nc_my_visbuf(const void *ptr)
d61 3
a63 2
void
_nc_dPanel(const char *text, const PANEL *pan)
d77 3
a79 2
void
_nc_dStack(const char *fmt, int num, const PANEL *pan)
d102 2
a103 2
void
_nc_Wnoutrefresh(const PANEL *pan)
d114 2
a115 2
void
_nc_Touchpan(const PANEL *pan)
d126 3
a128 2
void
_nc_Touchline(const PANEL *pan, int start, int count)
@


1.6
log
@Correct $From
@
text
@d1 1
a1 1
/*	$OpenBSD: panel.c,v 1.5 1998/09/17 04:14:49 millert Exp $	*/
d39 1
a39 1
MODULE_ID("$From: panel.c,v 1.16 1998/09/19 21:26:31 Todd.Miller Exp $")
d67 1
a67 1
		pan->wstarty, pan->wstartx);
d133 5
a137 157
/*+-------------------------------------------------------------------------
	__panels_overlapped(pan1,pan2) - check panel overlapped
--------------------------------------------------------------------------*/
static INLINE bool
__panels_overlapped(register const PANEL *pan1, register const PANEL *pan2)
{
  if(!pan1 || !pan2)
    return(FALSE);

  dBug(("__panels_overlapped %s %s", USER_PTR(pan1->user), USER_PTR(pan2->user)));
  /* pan1 intersects with pan2 ? */
  if( (((pan1->wstarty >= pan2->wstarty) && (pan1->wstarty < pan2->wendy)) ||
       ((pan2->wstarty >= pan1->wstarty) && (pan2->wstarty < pan1->wendy))) &&
      (((pan1->wstartx >= pan2->wstartx) && (pan1->wstartx < pan2->wendx)) ||
       ((pan2->wstartx >= pan1->wstartx) && (pan2->wstartx < pan1->wendx)))
      ) return(TRUE);
  else {
    dBug(("  no"));
    return(FALSE);
  }
}

/*+-------------------------------------------------------------------------
	_nc_free_obscure(pan)
--------------------------------------------------------------------------*/
void
_nc_free_obscure(PANEL *pan)
{
  PANELCONS *tobs = pan->obscure;			/* "this" one */
  PANELCONS *nobs;					/* "next" one */

  while(tobs)
    {
      nobs = tobs->above;
      free((char *)tobs);
      tobs = nobs;
    }
  pan->obscure = (PANELCONS *)0;
}

/*+-------------------------------------------------------------------------
	__override(pan,show)
--------------------------------------------------------------------------*/
void
_nc_override(const PANEL *pan, int show)
{
  int y;
  PANEL *pan2;
  PANELCONS *tobs = pan->obscure;			   /* "this" one */

  dBug(("_nc_override %s,%d", USER_PTR(pan->user),show));

  switch (show)
    {
    case P_TOUCH:
      Touchpan(pan);
      /* The following while loop will now mark all panel window lines
       * obscured by use or obscuring us as touched, so they will be
       * updated.
       */
      break;
    case P_UPDATE:
      while(tobs && (tobs->pan != pan))
	tobs = tobs->above;
      /* The next loop will now only go through the panels obscuring pan;
       * it updates all the lines in the obscuring panels in sync. with
       * the lines touched in pan itself. This is called in update_panels()
       * in a loop from the bottom_panel to the top_panel, resulting in
       * the desired update effect.
       */
      break;
    default:
      return;
    }

  while(tobs)
    {
      if((pan2 = tobs->pan) != pan) {
	dBug(("test obs pan=%s pan2=%s", USER_PTR(pan->user), USER_PTR(pan2->user)));
	for(y = pan->wstarty; y < pan->wendy; y++) {
	  if( (y >= pan2->wstarty) && (y < pan2->wendy) &&
	      ((is_linetouched(pan->win,y - pan->wstarty) == TRUE)) )
	    Touchline(pan2,y - pan2->wstarty,1);
	}
      }
      tobs = tobs->above;
    }
}

/*+-------------------------------------------------------------------------
	__calculate_obscure()
--------------------------------------------------------------------------*/
void
_nc_calculate_obscure(void)
{
  PANEL *pan;
  PANEL *pan2;
  PANELCONS *tobs;			/* "this" one */
  PANELCONS *lobs = (PANELCONS *)0;	/* last one */

  pan = _nc_bottom_panel;
  while(pan)
    {
      if(pan->obscure)
	_nc_free_obscure(pan);
      dBug(("--> __calculate_obscure %s", USER_PTR(pan->user)));
      lobs = (PANELCONS *)0;		/* last one */
      pan2 = _nc_bottom_panel;
      /* This loop builds a list of panels obsured by pan or obscuring
	 pan; pan itself is in the list; all panels before pan are
	 obscured by pan, all panels after pan are obscuring pan. */
      while(pan2)
	{
	  if(__panels_overlapped(pan,pan2))
	    {
	      if(!(tobs = (PANELCONS *)malloc(sizeof(PANELCONS))))
		return;
	      tobs->pan = pan2;
	      dPanel("obscured",pan2);
	      tobs->above = (PANELCONS *)0;
	      if(lobs)
		lobs->above = tobs;
	      else
		pan->obscure = tobs;
	      lobs  = tobs;
	    }
	  pan2 = pan2->above;
	}
      _nc_override(pan,P_TOUCH);
      pan = pan->above;
    }
}

/*+-------------------------------------------------------------------------
	_nc_panel_is_linked(pan) - check to see if panel is in the stack
--------------------------------------------------------------------------*/
bool
_nc_panel_is_linked(const PANEL *pan)
{
  /* This works! The only case where it would fail is, when the list has
     only one element. But this could only be the pseudo panel at the bottom */
  return ( ((pan->above!=(PANEL *)0) ||
	    (pan->below!=(PANEL *)0) ||
	    (pan==_nc_bottom_panel)) ? TRUE : FALSE );
}


/*+-------------------------------------------------------------------------
	__panel_link_bottom(pan) - link panel into stack at bottom
--------------------------------------------------------------------------*/
void
_nc_panel_link_bottom(PANEL *pan)
{
#ifdef TRACE
  dStack("<lb%d>",1,pan);
  if(_nc_panel_is_linked(pan))
    return;
a138 20

  pan->above = (PANEL *)0;
  pan->below = (PANEL *)0;
  if(_nc_bottom_panel)
    { /* the stdscr pseudo panel always stays real bottom;
         so we insert after bottom panel*/
      pan->below = _nc_bottom_panel;
      pan->above = _nc_bottom_panel->above;
      if (pan->above)
	pan->above->below = pan;
      _nc_bottom_panel->above = pan;
    }
  else
    _nc_bottom_panel = pan;
  if(!_nc_top_panel)
    _nc_top_panel = pan;
  assert(_nc_bottom_panel == _nc_stdscr_pseudo_panel);
  _nc_calculate_obscure();
  dStack("<lb%d>",9,pan);
}
@


1.5
log
@ncurses-4.2-980912
@
text
@d1 1
a1 1
/*	$OpenBSD: panel.c,v 1.4 1998/07/24 17:08:22 millert Exp $	*/
d39 1
a39 1
MODULE_ID("$From: panel.c,v 1.15 1998/02/11 12:14:01 tom Exp $")
@


1.4
log
@libpanel from ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
	char temp[40];
@


1.3
log
@merge of ncurses-4.1-971129
@
text
@d3 32
a34 21
/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                     panels is copyright (C) 1995                         *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*	      All praise to the original author, Warren Tucker.            *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute panels   *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of panels in any    *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        panels comes AS IS with no warranty, implied or expressed.        *
*                                                                          *
***************************************************************************/
d39 1
a39 1
MODULE_ID("Id: panel.c,v 1.14 1997/10/18 18:34:31 tom Exp $")
@


1.2
log
@libpanel from ncurses 4.1.  Post 4.1 patches to be applied in a separate commit.
@
text
@d1 1
d25 1
a25 1
/* panel.c -- implementation of panels library */
d28 1
a28 1
MODULE_ID("$Id: panel.c,v 1.10 1997/05/05 09:42:11 tom Exp $")
d31 2
a32 5
extern char *_nc_visbuf(const char *);
#ifdef TRACE_TXT
#define USER_PTR(ptr) _nc_visbuf((const char *)ptr)
#else
static char *my_nc_visbuf(const void *ptr)
d36 1
a36 1
		sprintf(temp, "ptr:%p", ptr);
a40 1
#define USER_PTR(ptr) my_nc_visbuf((const char *)ptr)
a43 11
static PANEL *__bottom_panel = (PANEL *)0;
static PANEL *__top_panel    = (PANEL *)0;

static PANEL __stdscr_pseudo_panel = { (WINDOW *)0,
				       0,0,0,0,
				       (PANEL *)0, (PANEL *)0,
				       (void *)0,
				       (PANELCONS *)0 };

/* Prototypes */
static void __panel_link_bottom(PANEL *pan);
d49 2
a50 2
static void
dPanel(const char *text, const PANEL *pan)
d57 1
a57 3
} /* end of dPanel */
#else
#  define dPanel(text,pan)
d64 2
a65 2
static void
dStack(const char *fmt, int num, const PANEL *pan)
d71 2
a72 2
	  (__bottom_panel) ?  USER_PTR(__bottom_panel->user) : "--",
	  (__top_panel)    ?  USER_PTR(__top_panel->user)    : "--");
d75 1
a75 1
  pan = __bottom_panel;
d81 1
a81 3
} /* end of dStack */
#else
#  define dStack(fmt,num,pan)
d88 2
a89 2
static void
Wnoutrefresh(const PANEL *pan)
d93 1
a93 3
} /* end of Wnoutrefresh */
#else
#  define Wnoutrefresh(pan) wnoutrefresh((pan)->win)
d100 2
a101 2
static void
Touchpan(const PANEL *pan)
d105 1
a105 3
} /* end of Touchpan */
#else
#  define Touchpan(pan) touchwin((pan)->win)
d112 2
a113 2
static void
Touchline(const PANEL *pan, int start, int count)
d119 1
a119 3
} /* end of Touchline */
#else
#  define Touchline(pan,start,count) touchline((pan)->win,start,count)
d130 1
d133 10
a142 10
  if((pan1->wstarty >= pan2->wstarty) && (pan1->wstarty < pan2->wendy) &&
     (pan1->wstartx >= pan2->wstartx) && (pan1->wstartx < pan2->wendx))
    return(TRUE);
  /* or vice versa test */
  if((pan2->wstarty >= pan1->wstarty) && (pan2->wstarty < pan1->wendy) &&
     (pan2->wstartx >= pan1->wstartx) && (pan2->wstartx < pan1->wendx))
    return(TRUE);
  dBug(("  no"));
  return(FALSE);
} /* end of __panels_overlapped */
d145 1
a145 1
	__free_obscure(pan)
d147 2
a148 2
static INLINE void
__free_obscure(PANEL *pan)
a159 21
} /* end of __free_obscure */

/*+-------------------------------------------------------------------------
  Get root (i.e. stdscr's) panel.
  Establish the pseudo panel for stdscr if necessary.
--------------------------------------------------------------------------*/
static PANEL*
__root_panel(void)
{
  if(!__stdscr_pseudo_panel.win)
    { /* initialize those fields not already statically initialized */
      assert(stdscr && !__bottom_panel && !__top_panel);
      __stdscr_pseudo_panel.win = stdscr;
      __stdscr_pseudo_panel.wendy = LINES;
      __stdscr_pseudo_panel.wendx = COLS;
#ifdef TRACE
      __stdscr_pseudo_panel.user = "stdscr";
#endif
      __panel_link_bottom(&__stdscr_pseudo_panel);
    }
  return &__stdscr_pseudo_panel;
d165 2
a166 2
static void
__override(const PANEL *pan, int show)
d172 1
a172 1
  dBug(("__override %s,%d", USER_PTR(pan->user),show));
d209 1
a209 1
} /* end of __override */
d214 2
a215 2
static void
__calculate_obscure(void)
d222 1
a222 1
  pan = __bottom_panel;
d226 1
a226 1
	__free_obscure(pan);
d229 1
a229 1
      pan2 = __bottom_panel;
d250 1
a250 1
      __override(pan,P_TOUCH);
d253 1
a253 1
} /* end of __calculate_obscure */
d256 1
a256 1
	__panel_is_linked(pan) - check to see if panel is in the stack
d258 2
a259 2
static INLINE bool
__panel_is_linked(const PANEL *pan)
d265 2
a266 27
	    (pan==__bottom_panel)) ? TRUE : FALSE );
} /* end of __panel_is_linked */

/*+-------------------------------------------------------------------------
	__panel_link_top(pan) - link panel into stack at top
--------------------------------------------------------------------------*/
static void
__panel_link_top(PANEL *pan)
{
#ifdef TRACE
  dStack("<lt%d>",1,pan);
  if(__panel_is_linked(pan))
    return;
#endif

  pan->above = (PANEL *)0;
  pan->below = (PANEL *)0;
  if(__top_panel)
    {
      __top_panel->above = pan;
      pan->below = __top_panel;
    }
  __top_panel = pan;
  if(!__bottom_panel)
    __bottom_panel = pan;
  __calculate_obscure();
  dStack("<lt%d>",9,pan);
a267 1
} /* end of __panel_link_top */
d272 2
a273 2
static void
__panel_link_bottom(PANEL *pan)
d277 1
a277 1
  if(__panel_is_linked(pan))
d283 1
a283 1
  if(__bottom_panel)
d286 2
a287 2
      pan->below = __bottom_panel;
      pan->above = __bottom_panel->above;
d290 1
a290 1
      __bottom_panel->above = pan;
d293 5
a297 5
    __bottom_panel = pan;
  if(!__top_panel)
    __top_panel = pan;
  assert(__bottom_panel == &__stdscr_pseudo_panel);
  __calculate_obscure();
d299 1
a299 296
} /* end of __panel_link_bottom */

/*+-------------------------------------------------------------------------
	__panel_unlink(pan) - unlink panel from stack
--------------------------------------------------------------------------*/
static void
__panel_unlink(PANEL *pan)
{
  PANEL *prev;
  PANEL *next;

#ifdef TRACE
  dStack("<u%d>",1,pan);
  if(!__panel_is_linked(pan))
    return;
#endif

  __override(pan,P_TOUCH);
  __free_obscure(pan);

  prev = pan->below;
  next = pan->above;

  if(prev)
    { /* if non-zero, we will not update the list head */
      prev->above = next;
      if(next)
	next->below = prev;
    }
  else if(next)
    next->below = prev;
  if(pan == __bottom_panel)
    __bottom_panel = next;
  if(pan == __top_panel)
    __top_panel = prev;

  __calculate_obscure();

  pan->above = (PANEL *)0;
  pan->below = (PANEL *)0;
  dStack("<u%d>",9,pan);
} /* end of __panel_unlink */

/*+-------------------------------------------------------------------------
	panel_window(pan) - get window associated with panel
--------------------------------------------------------------------------*/
WINDOW *
panel_window(const PANEL *pan)
{
  return(pan ? pan->win : (WINDOW *)0);
} /* end of panel_window */

/*+-------------------------------------------------------------------------
	update_panels() - wnoutrefresh windows in an orderly fashion
--------------------------------------------------------------------------*/
void
update_panels(void)
{
  PANEL *pan;

  dBug(("--> update_panels"));
  pan = __bottom_panel;
  while(pan)
    {
      __override(pan,P_UPDATE);
      pan = pan->above;
    }

  pan = __bottom_panel;
  while (pan)
    {
      if(is_wintouched(pan->win))
	Wnoutrefresh(pan);
      pan = pan->above;
    }
} /* end of update_panels */

/*+-------------------------------------------------------------------------
	hide_panel(pan) - remove a panel from stack
--------------------------------------------------------------------------*/
int
hide_panel(register PANEL *pan)
{
  if(!pan)
    return(ERR);

  dBug(("--> hide_panel %s", USER_PTR(pan->user)));

  if(!__panel_is_linked(pan))
    {
      pan->above = (PANEL *)0;
      pan->below = (PANEL *)0;
      return(ERR);
    }

  __panel_unlink(pan);
  return(OK);
} /* end of hide_panel */

/*+-------------------------------------------------------------------------
	show_panel(pan) - place a panel on top of stack
may already be in stack
--------------------------------------------------------------------------*/
int
show_panel(register PANEL *pan)
{
  if(!pan)
    return(ERR);
  if(pan == __top_panel)
    return(OK);
  dBug(("--> show_panel %s", USER_PTR(pan->user)));
  if(__panel_is_linked(pan))
    (void)hide_panel(pan);
  __panel_link_top(pan);
  return(OK);
} /* end of show_panel */

/*+-------------------------------------------------------------------------
	top_panel(pan) - place a panel on top of stack
--------------------------------------------------------------------------*/
int
top_panel(register PANEL *pan)
{
  return(show_panel(pan));
} /* end of top_panel */

/*+-------------------------------------------------------------------------
	del_panel(pan) - remove a panel from stack, if in it, and free struct
--------------------------------------------------------------------------*/
int
del_panel(register PANEL *pan)
{
  if(pan)
    {
      dBug(("--> del_panel %s", USER_PTR(pan->user)));
      if(__panel_is_linked(pan))
	(void)hide_panel(pan);
      free((void *)pan);
      return(OK);
    }
  return(ERR);
} /* end of del_panel */

/*+-------------------------------------------------------------------------
	bottom_panel(pan) - place a panel on bottom of stack
may already be in stack
--------------------------------------------------------------------------*/
int
bottom_panel(register PANEL *pan)
{
  if(!pan)
    return(ERR);
  if(pan == __bottom_panel)
    return(OK);
  dBug(("--> bottom_panel %s", USER_PTR(pan->user)));
  if(__panel_is_linked(pan))
    (void)hide_panel(pan);
  __panel_link_bottom(pan);
  return(OK);
} /* end of bottom_panel */

/*+-------------------------------------------------------------------------
	new_panel(win) - create a panel and place on top of stack
--------------------------------------------------------------------------*/
PANEL *
new_panel(WINDOW *win)
{
  PANEL *pan = (PANEL *)malloc(sizeof(PANEL));

  (void)__root_panel();

  if(pan)
    {
      pan->win = win;
      pan->above = (PANEL *)0;
      pan->below = (PANEL *)0;
      getbegyx(win, pan->wstarty, pan->wstartx);
      pan->wendy = pan->wstarty + getmaxy(win);
      pan->wendx = pan->wstartx + getmaxx(win);
#ifdef TRACE
      pan->user = "new";
#else
      pan->user = (char *)0;
#endif
      pan->obscure = (PANELCONS *)0;
      (void)show_panel(pan);
    }
  return(pan);
} /* end of new_panel */

/*+-------------------------------------------------------------------------
	panel_above(pan)
--------------------------------------------------------------------------*/
PANEL *
panel_above(const PANEL *pan)
{
  if(!pan)
    {
      /* if top and bottom are equal, we have no or only the pseudo panel;
	 if not, we return the panel above the pseudo panel */
      return(__bottom_panel==__top_panel ? (PANEL*)0 : __bottom_panel->above);
    }
  else
    return(pan->above);
} /* end of panel_above */

/*+-------------------------------------------------------------------------
	panel_below(pan)
--------------------------------------------------------------------------*/
PANEL *
panel_below(const PANEL *pan)
{
  if(!pan)
    {
      /* if top and bottom are equal, we have no or only the pseudo panel */
      return(__top_panel==__bottom_panel ? (PANEL*)0 : __top_panel);
    }
  else
    {
      /* we must not return the pseudo panel */
      return(pan->below==__bottom_panel ? (PANEL*) 0 : pan->below);
    }
} /* end of panel_below */

/*+-------------------------------------------------------------------------
	set_panel_userptr(pan,uptr)
--------------------------------------------------------------------------*/
int
set_panel_userptr(PANEL *pan, const void *uptr)
{
  if(!pan)
    return(ERR);
  pan->user = uptr;
  return(OK);
} /* end of set_panel_userptr */

/*+-------------------------------------------------------------------------
	panel_userptr(pan)
--------------------------------------------------------------------------*/
const void*
panel_userptr(const PANEL *pan)
{
  return(pan ? pan->user : (void *)0);
} /* end of panel_userptr */

/*+-------------------------------------------------------------------------
	move_panel(pan,starty,startx)
--------------------------------------------------------------------------*/
int
move_panel(PANEL *pan, int starty, int startx)
{
  WINDOW *win;

  if(!pan)
    return(ERR);
  if(__panel_is_linked(pan))
    __override(pan,P_TOUCH);
  win = pan->win;
  if(mvwin(win,starty,startx))
    return(ERR);
  getbegyx(win, pan->wstarty, pan->wstartx);
  pan->wendy = pan->wstarty + getmaxy(win);
  pan->wendx = pan->wstartx + getmaxx(win);
  if(__panel_is_linked(pan))
    __calculate_obscure();
  return(OK);
} /* end of move_panel */

/*+-------------------------------------------------------------------------
	replace_panel(pan,win)
--------------------------------------------------------------------------*/
int
replace_panel(PANEL *pan, WINDOW *win)
{
  if(!pan)
    return(ERR);
  if(__panel_is_linked(pan))
    __override(pan,P_TOUCH);
  pan->win = win;
  if(__panel_is_linked(pan))
    __calculate_obscure();
  return(OK);
} /* end of replace_panel */

/*+-------------------------------------------------------------------------
	panel_hidden(pan)
--------------------------------------------------------------------------*/
int
panel_hidden(const PANEL *pan)
{
  if(!pan)
    return(ERR);
  return(__panel_is_linked(pan) ? TRUE : FALSE);
} /* end of panel_hidden */

/* end of panel.c */
@


1.1
log
@Initial revision
@
text
@d25 1
d27 1
a27 3
#ifdef TRACE         
#define PANEL_DEBUG
#endif
d29 6
a34 4
#include <stdlib.h>
#include "panel.h"

typedef struct panelcons
d36 6
a41 2
	struct panelcons *above;
	struct panel *pan;
d43 3
a45 1
PANELCONS;
d47 2
a48 1
#define STATIC static
d50 5
a54 3
STATIC PANEL *__bottom_panel = (PANEL *)0;
STATIC PANEL *__top_panel = (PANEL *)0;
STATIC PANEL __stdscr_pseudo_panel = { (WINDOW *)0 };
d56 2
a57 5
#ifdef PANEL_DEBUG
#define dBug(x) _tracef x
#else
#define dBug(x)
#endif
d62 3
a64 3
#ifdef PANEL_DEBUG
STATIC void
dPanel(char *text, PANEL *pan)
d67 3
a69 3
		text,pan->user,
		(pan->below) ? pan->below->user : "--",
		(pan->above) ? pan->above->user : "--",
d71 1
a71 1
}	/* end of dPanel */
d73 1
a73 1
#define dPanel(text,pan)
d79 19
a97 19
#ifdef PANEL_DEBUG
STATIC void
dStack(char *fmt, int num, PANEL *pan)
{
char s80[80];

	sprintf(s80,fmt,num,pan);
	_tracef("%s b=%s t=%s",s80,
		(__bottom_panel) ? __bottom_panel->user : "--",
		(__top_panel)    ? __top_panel->user    : "--");
	if(pan)
		_tracef("pan id=%s",pan->user);
	pan = __bottom_panel;
	while(pan)
	{
		dPanel("stk",pan);
		pan = pan->above;
	}
}	/* end of dStack */
d99 1
a99 1
#define dStack(fmt,num,pan)
d105 7
a111 7
#ifdef PANEL_DEBUG
STATIC void
Wnoutrefresh(PANEL *pan)
{
	dPanel("wnoutrefresh",pan);
	wnoutrefresh(pan->win);
}	/* end of Wnoutrefresh */
d113 1
a113 1
#define Wnoutrefresh(pan) wnoutrefresh((pan)->win)
d119 7
a125 7
#ifdef PANEL_DEBUG
STATIC void
Touchpan(PANEL *pan)
{
	dPanel("Touchpan",pan);
	touchwin(pan->win);
}	/* end of Touchpan */
d127 1
a127 1
#define Touchpan(pan) touchwin((pan)->win)
d133 9
a141 9
#ifdef PANEL_DEBUG
STATIC void
Touchline(PANEL *pan, int start, int count)
{
char s80[80];
	sprintf(s80,"Touchline s=%d c=%d",start,count);
	dPanel(s80,pan);
	touchline(pan->win,start,count);
}	/* end of Touchline */
d143 1
a143 1
#define Touchline(pan,start,count) touchline((pan)->win,start,count)
d149 2
a150 2
STATIC int
__panels_overlapped(register PANEL *pan1, register PANEL *pan2)
d152 14
a165 12
	if(!pan1 || !pan2)
		return(0);
	dBug(("__panels_overlapped %s %s",pan1->user,pan2->user));
	if((pan1->wstarty >= pan2->wstarty) && (pan1->wstarty < pan2->wendy) &&
		(pan1->wstartx >= pan2->wstartx) && (pan1->wstartx < pan2->wendx))
		return(1);
	if((pan1->wstarty >= pan1->wstarty) && (pan2->wstarty < pan1->wendy) &&
		(pan1->wstartx >= pan1->wstartx) && (pan2->wstartx < pan1->wendx))
		return(1);
	dBug(("  no"));
	return(0);
}	/* end of __panels_overlapped */
d170 1
a170 1
STATIC void
d173 2
a174 2
PANELCONS *tobs = pan->obscure;				/* "this" one */
PANELCONS *nobs;					/* "next" one */
d176 29
a204 7
	while(tobs) {
		nobs = tobs->above;
		free((char *)tobs);
		tobs = nobs;
	}
	pan->obscure = (PANELCONS *)0;
}	/* end of __free_obscure */
d209 2
a210 2
STATIC void
__override(PANEL *pan, int show)
d212 42
a253 34
register y;
register PANEL *pan2;
PANELCONS *tobs = pan->obscure;				/* "this" one */

	dBug(("__override %s,%d",pan->user,show));

	if(show == 1)
		Touchpan(pan);
	else if(!show) {
		Touchpan(pan);
/*
		Touchline(&__stdscr_pseudo_panel,pan->wendy,getmaxy(pan->win));
*/
		Touchpan(&__stdscr_pseudo_panel);
	} else if(show == -1) {
		while(tobs && (tobs->pan != pan))
			tobs = tobs->above;
	}

	while(tobs) {
		if((pan2 = tobs->pan) != pan) {
			dBug(("test obs pan=%s pan2=%s",pan->user,pan2->user));
			for(y = pan->wstarty; y < pan->wendy; y++) {
				if( (y >= pan2->wstarty) && (y < pan2->wendy) &&
					((is_linetouched(pan->win,y - pan->wstarty) == 1) ||
					(is_linetouched(stdscr,y) == 1)))
				{
					Touchline(pan2,y - pan2->wstarty,1);
				}
			}
		}
		tobs = tobs->above;
	}
}	/* end of __override */
d258 1
a258 1
STATIC void
d261 37
a297 32
PANEL *pan;
register PANEL *pan2;
register PANELCONS *tobs;			/* "this" one */
PANELCONS *lobs = (PANELCONS *)0;		/* last one */

	pan = __bottom_panel;
	while(pan) {
		if(pan->obscure)
			__free_obscure(pan);
		dBug(("--> __calculate_obscure %s",pan->user));
		lobs = (PANELCONS *)0;		/* last one */
		pan2 = __bottom_panel;
		while(pan2) {
			if(__panels_overlapped(pan,pan2)) {
				if(!(tobs = (PANELCONS *)malloc(sizeof(PANELCONS))))
					return;
				tobs->pan = pan2;
				dPanel("obscured",pan2);
				tobs->above = (PANELCONS *)0;
				if(lobs)
					lobs->above = tobs;
				else
					pan->obscure = tobs;
				lobs  = tobs;
			}
			pan2 = pan2->above;
		}
		__override(pan,1);
		pan = pan->above;
	}

}	/* end of __calculate_obscure */
d302 2
a303 2
STATIC int
__panel_is_linked(PANEL *pan)
d305 6
a310 9
register PANEL *pan2 = __bottom_panel;

	while(pan2) {
		if(pan2 == pan)
			return(1);
		pan2 = pan2->above;
	}
	return(OK);
}	/* end of __panel_is_linked */
d315 1
a315 1
STATIC void
d318 18
d337 1
a337 19
#ifdef PANEL_DEBUG
	dStack("<lt%d>",1,pan);
	if(__panel_is_linked(pan))
		return;
#endif

	pan->above = (PANEL *)0;
	pan->below = (PANEL *)0;
	if(__top_panel) {
		__top_panel->above = pan;
		pan->below = __top_panel;
	}
	__top_panel = pan;
	if(!__bottom_panel)
		__bottom_panel = pan;
	__calculate_obscure();
	dStack("<lt%d>",9,pan);

}	/* end of __panel_link_top */
d342 1
a342 1
STATIC void
d345 25
a369 20

#ifdef PANEL_DEBUG
	dStack("<lb%d>",1,pan);
	if(__panel_is_linked(pan))
		return;
#endif

	pan->above = (PANEL *)0;
	pan->below = (PANEL *)0;
	if(__bottom_panel) {
		__bottom_panel->below = pan;
		pan->above = __bottom_panel;
	}
	__bottom_panel = pan;
	if(!__top_panel)
		__top_panel = pan;
	__calculate_obscure();
	dStack("<lb%d>",9,pan);

}	/* end of __panel_link_bottom */
d374 1
a374 1
STATIC void
d377 2
a378 11
register PANEL *prev;
register PANEL *next;

#ifdef PANEL_DEBUG
	dStack("<u%d>",1,pan);
	if(!__panel_is_linked(pan))
		return;
#endif

	__override(pan,0);
	__free_obscure(pan);
d380 31
a410 22
	prev = pan->below;
	next = pan->above;

	if(prev) {		/* if non-zero, we will not update the list head */
		prev->above = next;
		if(next)
			next->below = prev;
	}
	else if(next)
		next->below = prev;
	if(pan == __bottom_panel)
		__bottom_panel = next;
	if(pan == __top_panel)
		__top_panel = prev;

	__calculate_obscure();

	pan->above = (PANEL *)0;
	pan->below = (PANEL *)0;
	dStack("<u%d>",9,pan);

}	/* end of __panel_unlink */
d416 1
a416 1
panel_window(PANEL *pan)
d418 2
a419 2
	return(pan->win);
}	/* end of panel_window */
d427 1
a427 8
PANEL *pan;

	dBug(("--> update_panels"));
	pan = __bottom_panel;
	while(pan) {
		__override(pan,-1);
		pan = pan->above;
	}
d429 16
a444 10
	if(is_wintouched(stdscr) || (stdscr->_flags & _HASMOVED))
		Wnoutrefresh(&__stdscr_pseudo_panel);
	
	if(__bottom_panel) {
		for (pan = __bottom_panel; pan; pan = pan->above) {
			if(is_wintouched(pan->win))
				Wnoutrefresh(pan);
		}
	}
}	/* end of update_panels */
d452 2
d455 1
a455 2
	if(!pan)
		return(ERR);
d457 10
a466 12
	dBug(("--> hide_panel %s",pan->user));

	if(!__panel_is_linked(pan)) {
		pan->above = (PANEL *)0;
		pan->below = (PANEL *)0;
		return(ERR);
	}

	__panel_unlink(pan);

	return(OK);
}	/* end of hide_panel */
d475 10
a484 11

	if(!pan)
		return(ERR);
	if(pan == __top_panel)
		return(OK);
	dBug(("--> show_panel %s",pan->user));
	if(__panel_is_linked(pan))
		(void)hide_panel(pan);
	__panel_link_top(pan);
	return(OK);
}	/* end of show_panel */
d492 2
a493 2
	return(show_panel(pan));
}	/* end of top_panel */
d501 10
a510 10
	if(pan)
	{
		dBug(("--> del_panel %s",pan->user));
		if(__panel_is_linked(pan))
			(void)hide_panel(pan);
		free((char *)pan);
		return(OK);
	}
	return(ERR);
}	/* end of del_panel */
d519 10
a528 10
	if(!pan)
		return(ERR);
	if(pan == __bottom_panel)
		return(OK);
	dBug(("--> bottom_panel %s",pan->user));
	if(__panel_is_linked(pan))
		(void)hide_panel(pan);
	__panel_link_bottom(pan);
	return(OK);
}	/* end of bottom_panel */
d536 1
a536 1
PANEL *pan = (PANEL *)malloc(sizeof(PANEL));
d538 1
a538 9
	if(!__stdscr_pseudo_panel.win) {
		__stdscr_pseudo_panel.win = stdscr;
		__stdscr_pseudo_panel.wstarty = 0;
		__stdscr_pseudo_panel.wstartx = 0;
		__stdscr_pseudo_panel.wendy = LINES;
		__stdscr_pseudo_panel.wendx = COLS;
		__stdscr_pseudo_panel.user = "stdscr";
		__stdscr_pseudo_panel.obscure = (PANELCONS *)0;
	}
d540 10
a549 9
	if(pan) {
		pan->win = win;
		pan->above = (PANEL *)0;
		pan->below = (PANEL *)0;
		getbegyx(win, pan->wstarty, pan->wstartx);
		pan->wendy = pan->wstarty + getmaxy(win);
		pan->wendx = pan->wstartx + getmaxx(win);
#ifdef PANEL_DEBUG
		pan->user = "new";
d551 1
a551 1
		pan->user = (char *)0;
d553 5
a557 6
		pan->obscure = (PANELCONS *)0;
		(void)show_panel(pan);
	}

	return(pan);
}	/* end of new_panel */
d563 1
a563 1
panel_above(PANEL *pan)
d565 9
a573 5
	if(!pan)
		return(__bottom_panel);
	else
		return(pan->above);
}	/* end of panel_above */
d579 1
a579 1
panel_below(PANEL *pan)
d581 11
a591 5
	if(!pan)
		return(__top_panel);
	else
		return(pan->below);
}	/* end of panel_below */
d597 1
a597 1
set_panel_userptr(PANEL *pan, char *uptr)
d599 5
a603 5
	if(!pan)
		return(ERR);
	pan->user = uptr;
	return(OK);
}	/* end of set_panel_userptr */
d608 2
a609 2
char *
panel_userptr(PANEL *pan)
d611 2
a612 4
	if(!pan)
		return((char *)0);
	return(pan->user);
}	/* end of panel_userptr */
d620 1
a620 1
WINDOW *win;
d622 14
a635 14
	if(!pan)
		return(ERR);
	if(__panel_is_linked(pan))
		__override(pan,0);
	win = pan->win;
	if(mvwin(win,starty,startx))
		return(ERR);
	getbegyx(win, pan->wstarty, pan->wstartx);
	pan->wendy = pan->wstarty + getmaxy(win);
	pan->wendx = pan->wstartx + getmaxx(win);
	if(__panel_is_linked(pan))
		__calculate_obscure();
	return(OK);
}	/* end of move_panel */
d643 9
a651 9
	if(!pan)
		return(ERR);
	if(__panel_is_linked(pan))
		__override(pan,0);
	pan->win = win;
	if(__panel_is_linked(pan))
		__calculate_obscure();
	return(OK);
}	/* end of replace_panel */
d657 1
a657 1
panel_hidden(PANEL *pan)
d659 4
a662 4
	if(!pan)
		return(ERR);
	return(__panel_is_linked(pan) ? ERR : OK);
}	/* end of panel_hidden */
@


1.1.1.1
log
@SYSV-style panels library; from ncurses
@
text
@@
