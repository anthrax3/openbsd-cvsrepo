head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.14
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.6
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.10
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.8
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.28
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.26
	OPENBSD_5_0:1.8.0.24
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.22
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.20
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.16
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.18
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.14
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.12
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.10
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.8
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.11.14.23.56.50;	author deraadt;	state dead;
branches;
next	1.9;
commitid	BrKaQHWTbuUdYB4P;

1.9
date	2012.12.05.23.20.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.06.18.53.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.20.18.41;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.17.19.42.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.11.29.06.50.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.12.28.06.10.43;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.07.27.18.32.14;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.06.06.04;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.10
log
@libocurses can go to the Attic.  last consumer of it was ramdisk more(1)
conceptual ok guenther millert nicm
@
text
@/*
 * Copyright (c) 1981, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)curses.h	8.4 (Berkeley) 8/10/94
 */

#ifndef _OCURSES_H_
#define	_OCURSES_H_

#include <sys/types.h>

#include <stdio.h>

#define	bool	char

#ifndef TRUE
#define	TRUE	(1)
#endif
#ifndef FALSE
#define	FALSE	(0)
#endif

/*
 * The following #defines and #includes are present for backward
 * compatibility only.  They should not be used in future code.
 *
 * START BACKWARD COMPATIBILITY ONLY.
 */
#ifndef _CURSES_PRIVATE
#define	_puts(s)	tputs(s, 0, __cputchar)
#define	_putchar(c)	__cputchar(c)

/* Old-style terminal modes access. */
#define	baudrate()	(cfgetospeed(&__baset))
#define	crmode()	cbreak()
#define	erasechar()	(__baset.c_cc[VERASE])
#define	killchar()	(__baset.c_cc[VKILL])
#define	nocrmode()	nocbreak()
#define	ospeed		(cfgetospeed(&__baset))
#endif /* _CURSES_PRIVATE */

extern char	 GT;			/* Gtty indicates tabs. */
extern char	 NONL;			/* Term can't hack LF doing a CR. */
extern char	 UPPERCASE;		/* Terminal is uppercase only. */

extern int	 My_term;		/* Use Def_term regardless. */
extern char	*Def_term;		/* Default terminal type. */

/* Termcap capabilities. */
extern char	AM, BS, CA, DA, EO, HC, IN, MI, MS, NC, NS, OS,
		PC, UL, XB, XN, XT, XS, XX;
extern char	*AL, *BC, *BT, *CD, *CE, *CL, *CM, *CR, *CS, *DC, *DL,
		*DM, *DO, *ED, *EI, *K0, *K1, *K2, *K3, *K4, *K5, *K6,
		*K7, *K8, *K9, *HO, *IC, *IM, *IP, *KD, *KE, *KH, *KL,
		*KR, *KS, *KU, *LL, *MA, *ND, *NL, *RC, *SC, *SE, *SF,
		*SO, *SR, *TA, *TE, *TI, *UC, *UE, *UP, *US, *VB, *VS,
		*VE, *al, *dl, *sf, *sr,
		*AL_PARM, *DL_PARM, *UP_PARM, *DOWN_PARM, *LEFT_PARM,
		*RIGHT_PARM;

/* END BACKWARD COMPATIBILITY ONLY. */

/* 8-bit ASCII characters. */
#define	unctrl(c)		__unctrl[(c) & 0xff]
#define	unctrllen(ch)		__unctrllen[(ch) & 0xff]

extern char	*__unctrl[256];	/* Control strings. */
extern char	 __unctrllen[256];	/* Control strings length. */

/*
 * A window an array of __LINE structures pointed to by the 'lines' pointer.
 * A line is an array of __LDATA structures pointed to by the 'line' pointer.
 *
 * IMPORTANT: the __LDATA structure must NOT induce any padding, so if new
 * fields are added -- padding fields with *constant values* should ensure 
 * that the compiler will not generate any padding when storing an array of
 *  __LDATA structures.  This is to enable consistent use of memcmp, and memcpy
 * for comparing and copying arrays.
 */
typedef struct {
	char ch;			/* the actual character */

#define	__STANDOUT	0x01  		/* Added characters are standout. */
	char attr;			/* attributes of character */
} __LDATA;

#define __LDATASIZE	(sizeof(__LDATA))

typedef struct {
#define	__ISDIRTY	0x01		/* Line is dirty. */
#define __ISPASTEOL	0x02		/* Cursor is past end of line */
#define __FORCEPAINT	0x04		/* Force a repaint of the line */
	unsigned int flags;
	unsigned int hash;			/* Hash value for the line. */
	size_t *firstchp, *lastchp;	/* First and last chngd columns ptrs */
	size_t firstch, lastch;		/* First and last changed columns. */
	__LDATA *line;			/* Pointer to the line text. */
} __LINE;

typedef struct __window {		/* Window structure. */
	struct __window	*nextp, *orig;	/* Subwindows list and parent. */
	size_t begy, begx;		/* Window home. */
	size_t cury, curx;		/* Current x, y coordinates. */
	size_t maxy, maxx;		/* Maximum values for curx, cury. */
	short ch_off;			/* x offset for firstch/lastch. */
	__LINE **lines;			/* Array of pointers to the lines */
	__LINE  *lspace;		/* line space (for cleanup) */
	__LDATA *wspace;		/* window space (for cleanup) */

#define	__ENDLINE	0x001		/* End of screen. */
#define	__FLUSH		0x002		/* Fflush(stdout) after refresh. */
#define	__FULLWIN	0x004		/* Window is a screen. */
#define	__IDLINE	0x008		/* Insert/delete sequences. */
#define	__SCROLLWIN	0x010		/* Last char will scroll window. */
#define	__SCROLLOK	0x020		/* Scrolling ok. */
#define	__CLEAROK	0x040		/* Clear on next refresh. */
#define __WSTANDOUT	0x080		/* Standout window */
#define __LEAVEOK	0x100		/* If curser left */	
	unsigned int flags;
} WINDOW;

/* Curses external declarations. */
extern WINDOW	*curscr;		/* Current screen. */
extern WINDOW	*stdscr;		/* Standard screen. */

extern struct termios __orig_termios;	/* Terminal state before curses */
extern struct termios __baset;		/* Our base terminal state */
extern int __tcaction;			/* If terminal hardware set. */

extern int	 COLS;			/* Columns on the screen. */
extern int	 LINES;			/* Lines on the screen. */

extern char	*ttytype;		/* Full name of current terminal. */

#define	ERR	(0)			/* Error return. */
#define	OK	(1)			/* Success return. */

/* Standard screen pseudo functions. */
#define	addbytes(s, n)			__waddbytes(stdscr, s, n, 0)
#define	addch(ch)			waddch(stdscr, ch)
#define	addnstr(s, n)			waddnstr(stdscr, s, n)
#define	addstr(s)			__waddbytes(stdscr, s, strlen(s), 0)
#define	clear()				wclear(stdscr)
#define	clrtobot()			wclrtobot(stdscr)
#define	clrtoeol()			wclrtoeol(stdscr)
#define	delch()				wdelch(stdscr)
#define	deleteln()			wdeleteln(stdscr)
#define	erase()				werase(stdscr)
#define	getch()				wgetch(stdscr)
#define	getstr(s)			wgetstr(stdscr, s)
#define	inch()				winch(stdscr)
#define	insch(ch)			winsch(stdscr, ch)
#define	insertln()			winsertln(stdscr)
#define	move(y, x)			wmove(stdscr, y, x)
#define	refresh()			wrefresh(stdscr)
#define	standend()			wstandend(stdscr)
#define	standout()			wstandout(stdscr)
#define	waddbytes(w, s, n)		__waddbytes(w, s, n, 0)
#define	waddstr(w, s)			__waddbytes(w, s, strlen(s), 0)

/* Standard screen plus movement pseudo functions. */
#define	mvaddbytes(y, x, s, n)		mvwaddbytes(stdscr, y, x, s, n)
#define	mvaddch(y, x, ch)		mvwaddch(stdscr, y, x, ch)
#define	mvaddnstr(y, x, s, n)		mvwaddnstr(stdscr, y, x, s, n)
#define	mvaddstr(y, x, s)		mvwaddstr(stdscr, y, x, s)
#define	mvdelch(y, x)			mvwdelch(stdscr, y, x)
#define	mvgetch(y, x)			mvwgetch(stdscr, y, x)
#define	mvgetstr(y, x, s)		mvwgetstr(stdscr, y, x, s)
#define	mvinch(y, x)			mvwinch(stdscr, y, x)
#define	mvinsch(y, x, c)		mvwinsch(stdscr, y, x, c)
#define	mvwaddbytes(w, y, x, s, n) \
	(wmove(w, y, x) == ERR ? ERR : __waddbytes(w, s, n, 0))
#define	mvwaddch(w, y, x, ch) \
	(wmove(w, y, x) == ERR ? ERR : waddch(w, ch))
#define	mvwaddnstr(w, y, x, s, n) \
	(wmove(w, y, x) == ERR ? ERR : waddnstr(w, s, n))
#define	mvwaddstr(w, y, x, s) \
	(wmove(w, y, x) == ERR ? ERR : __waddbytes(w, s, strlen(s), 0))
#define	mvwdelch(w, y, x) \
	(wmove(w, y, x) == ERR ? ERR : wdelch(w))
#define	mvwgetch(w, y, x) \
	(wmove(w, y, x) == ERR ? ERR : wgetch(w))
#define	mvwgetstr(w, y, x, s) \
	(wmove(w, y, x) == ERR ? ERR : wgetstr(w, s))
#define	mvwinch(w, y, x) \
	(wmove(w, y, x) == ERR ? ERR : winch(w))
#define	mvwinsch(w, y, x, c) \
	(wmove(w, y, x) == ERR ? ERR : winsch(w, c))

/* Psuedo functions. */
#define	clearok(w, bf) \
	((bf) ? ((w)->flags |= __CLEAROK) : ((w)->flags &= ~__CLEAROK))
#define	flushok(w, bf) \
	((bf) ? ((w)->flags |= __FLUSH) : ((w)->flags &= ~__FLUSH))
#define	getyx(w, y, x) \
	(y) = (w)->cury, (x) = (w)->curx
#define	leaveok(w, bf) \
	((bf) ? ((w)->flags |= __LEAVEOK) : ((w)->flags &= ~__LEAVEOK))
#define	scrollok(w, bf) \
	((bf) ? ((w)->flags |= __SCROLLOK) : ((w)->flags &= ~__SCROLLOK))
#define	winch(w) \
	((w)->lines[(w)->cury]->line[(w)->curx].ch & 0177)

/* Public function prototypes. */
__BEGIN_DECLS
int	 box(WINDOW *, int, int);
int	 cbreak(void);
int	 delwin(WINDOW *);
int	 echo(void);
int	 endwin(void);
char	*fullname(char *, char *);
char	*getcap(char *);
int	 gettmode(void);
void	 idlok(WINDOW *, int);
WINDOW	*initscr(void);
char	*longname(char *, char *);
int	 mvcur(int, int, int, int);
int	 mvprintw(int, int, const char *, ...);
int	 mvscanw(int, int, const char *, ...);
int	 mvwin(WINDOW *, int, int);
int	 mvwprintw(WINDOW *, int, int, const char *, ...);
int	 mvwscanw(WINDOW *, int, int, const char *, ...);
WINDOW	*newwin(int, int, int, int);
int	 nl(void);
int	 nocbreak(void);
int	 noecho(void);
int	 nonl(void);
int	 noraw(void);
int	 overlay(WINDOW *, WINDOW *);
int	 overwrite(WINDOW *, WINDOW *);
int	 printw(const char *, ...);
int	 raw(void);
int	 resetty(void);
int	 savetty(void);
int	 scanw(const char *, ...);
int	 scroll(WINDOW *);
int	 setterm(char *);
int	 sscans(WINDOW *, const char *, ...);
WINDOW	*subwin(WINDOW *, int, int, int, int);
int	 suspendwin(void);
int	 touchline(WINDOW *, int, int, int);
int	 touchoverlap(WINDOW *, WINDOW *);
int	 touchwin(WINDOW *);
int 	 vwprintw(WINDOW *, const char *, __va_list);
int      vwscanw(WINDOW *, const char *, __va_list);
int	 waddch(WINDOW *, int);
int	 waddnstr(WINDOW *, const char *, int);
int	 wclear(WINDOW *);
int	 wclrtobot(WINDOW *);
int	 wclrtoeol(WINDOW *);
int	 wdelch(WINDOW *);
int	 wdeleteln(WINDOW *);
int	 werase(WINDOW *);
int	 wgetch(WINDOW *);
int	 wgetstr(WINDOW *, char *);
int	 winsch(WINDOW *, int);
int	 winsertln(WINDOW *);
int	 wmove(WINDOW *, int, int);
int	 wprintw(WINDOW *, const char *, ...);
int	 wrefresh(WINDOW *);
int	 wscanw(WINDOW *, const char *, ...);
int	 wstandend(WINDOW *);
int	 wstandout(WINDOW *);
int	 vwprintw(WINDOW *, const char *, __va_list);

/* Private functions that are needed for user programs prototypes. */
void	 __cputchar(int);
int	 __waddbytes(WINDOW *, const char *, int, int);
__END_DECLS

/* Private functions. */
#ifdef _CURSES_PRIVATE
void	 __CTRACE(const char *, ...);
unsigned int	 __hash(char *, int);
void	 __id_subwins(WINDOW *);
int	 __mvcur(int, int, int, int, int);
void	 __restore_stophandler(void);
void	 __set_stophandler(void);
void	 __set_subwin(WINDOW *, WINDOW *);
void	 __startwin(void);
void	 __stop_signal_handler(int);
void	 __swflags(WINDOW *);
int	 __touchline(WINDOW *, int, int, int, int);
int	 __touchwin(WINDOW *);
char	*__tscroll(const char *, int, int);
int	 __waddch(WINDOW *, __LDATA *);

/* Private #defines. */
#define	min(a,b)	(a < b ? a : b)
#define	max(a,b)	(a > b ? a : b)

/* Private externs. */
extern int	 __echoit;
extern int	 __endwin;
extern int	 __pfast;
extern int	 __rawmode;
extern int	 __noqch;
#endif

/* Termcap functions. */
__BEGIN_DECLS
int	 tgetent(char *, char *);
int	 tgetnum(char *);
int	 tgetflag(char *);
char	*tgetstr(char *, char **);
char	*tgoto(char *, int, int);
void	 tputs(char *, int, void (*)(int));
__END_DECLS

#endif /* !_OCURSES_H_ */
@


1.9
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@@


1.8
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@a35 1
#include <sys/cdefs.h>
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d270 2
a271 2
int 	 vwprintw(WINDOW *, const char *, _BSD_VA_LIST_);
int      vwscanw(WINDOW *, const char *, _BSD_VA_LIST_);
d290 1
a290 1
int	 vwprintw(WINDOW *, const char *, _BSD_VA_LIST_);
@


1.6
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d337 1
a337 1
void	 tputs __P((char *, int, void (*)(int)));
@


1.4
log
@Move definitions of bool, TRUE, and FALSE out from behind a comment
stating that they are only for backward compatibility--they are not.
@
text
@d236 59
a294 59
int	 box __P((WINDOW *, int, int));
int	 cbreak __P((void));
int	 delwin __P((WINDOW *));
int	 echo __P((void));
int	 endwin __P((void));
char	*fullname __P((char *, char *));
char	*getcap __P((char *));
int	 gettmode __P((void));
void	 idlok __P((WINDOW *, int));
WINDOW	*initscr __P((void));
char	*longname __P((char *, char *));
int	 mvcur __P((int, int, int, int));
int	 mvprintw __P((int, int, const char *, ...));
int	 mvscanw __P((int, int, const char *, ...));
int	 mvwin __P((WINDOW *, int, int));
int	 mvwprintw __P((WINDOW *, int, int, const char *, ...));
int	 mvwscanw __P((WINDOW *, int, int, const char *, ...));
WINDOW	*newwin __P((int, int, int, int));
int	 nl __P((void));
int	 nocbreak __P((void));
int	 noecho __P((void));
int	 nonl __P((void));
int	 noraw __P((void));
int	 overlay __P((WINDOW *, WINDOW *));
int	 overwrite __P((WINDOW *, WINDOW *));
int	 printw __P((const char *, ...));
int	 raw __P((void));
int	 resetty __P((void));
int	 savetty __P((void));
int	 scanw __P((const char *, ...));
int	 scroll __P((WINDOW *));
int	 setterm __P((char *));
int	 sscans __P((WINDOW *, const char *, ...));
WINDOW	*subwin __P((WINDOW *, int, int, int, int));
int	 suspendwin __P((void));
int	 touchline __P((WINDOW *, int, int, int));
int	 touchoverlap __P((WINDOW *, WINDOW *));
int	 touchwin __P((WINDOW *));
int 	 vwprintw __P((WINDOW *, const char *, _BSD_VA_LIST_));
int      vwscanw __P((WINDOW *, const char *, _BSD_VA_LIST_));
int	 waddch __P((WINDOW *, int));
int	 waddnstr __P((WINDOW *, const char *, int));
int	 wclear __P((WINDOW *));
int	 wclrtobot __P((WINDOW *));
int	 wclrtoeol __P((WINDOW *));
int	 wdelch __P((WINDOW *));
int	 wdeleteln __P((WINDOW *));
int	 werase __P((WINDOW *));
int	 wgetch __P((WINDOW *));
int	 wgetstr __P((WINDOW *, char *));
int	 winsch __P((WINDOW *, int));
int	 winsertln __P((WINDOW *));
int	 wmove __P((WINDOW *, int, int));
int	 wprintw __P((WINDOW *, const char *, ...));
int	 wrefresh __P((WINDOW *));
int	 wscanw __P((WINDOW *, const char *, ...));
int	 wstandend __P((WINDOW *));
int	 wstandout __P((WINDOW *));
int	 vwprintw __P((WINDOW *, const char *, _BSD_VA_LIST_));
d297 2
a298 2
void	 __cputchar __P((int));
int	 __waddbytes __P((WINDOW *, const char *, int, int));
d303 14
a316 14
void	 __CTRACE __P((const char *, ...));
unsigned int	 __hash __P((char *, int));
void	 __id_subwins __P((WINDOW *));
int	 __mvcur __P((int, int, int, int, int));
void	 __restore_stophandler __P((void));
void	 __set_stophandler __P((void));
void	 __set_subwin __P((WINDOW *, WINDOW *));
void	 __startwin __P((void));
void	 __stop_signal_handler __P((int));
void	 __swflags __P((WINDOW *));
int	 __touchline __P((WINDOW *, int, int, int, int));
int	 __touchwin __P((WINDOW *));
char	*__tscroll __P((const char *, int, int));
int	 __waddch __P((WINDOW *, __LDATA *));
d332 5
a336 5
int	 tgetent __P((char *, char *));
int	 tgetnum __P((char *));
int	 tgetflag __P((char *));
char	*tgetstr __P((char *, char **));
char	*tgoto __P((char *, int, int));
@


1.3
log
@kill reg #define, nothing uses it and it causes problems elswhere; jwise@@unicast.com
@
text
@a43 7
/*
 * The following #defines and #includes are present for backward
 * compatibility only.  They should not be used in future code.
 *
 * START BACKWARD COMPATIBILITY ONLY.
 */
#ifndef _CURSES_PRIVATE
d53 7
@


1.2
log
@_OCURSES_H_, not _CURSES_H_
@
text
@a51 1
#define	reg	register
@


1.1
log
@Install ncurses as -lcurses and <curses.h>
Install BSD curses library as -locurses and <ocurses.h>
@
text
@d36 2
a37 2
#ifndef _CURSES_H_
#define	_CURSES_H_
d341 1
a341 1
#endif /* !_CURSES_H_ */
@

