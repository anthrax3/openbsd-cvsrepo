head	1.4;
access;
symbols
	OPENBSD_5_3:1.3.0.12
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.10
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.14
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.16
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.12
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.10
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.8
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.1.0.12
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.10
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.8
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.2
	OPENBSD_3_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.06.17.19.18.38;	author robert;	state dead;
branches;
next	1.3;

1.3
date	2010.08.05.07.45.31;	author guenther;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.14.08.24.42;	author biorn;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.17.20.13.52;	author mho;	state Exp;
branches;
next	;


desc
@@


1.4
log
@these libraries are either obsolete or got moved to kerberosV/lib
@
text
@/* Generated from /home/src/src/lib/libkrb5/../../kerberosV/src/lib/hdb/hdb.asn1 */
/* Do not edit */

#ifndef __hdb_asn1_h__
#define __hdb_asn1_h__

#include <stddef.h>
#include <time.h>

#ifndef __asn1_common_definitions__
#define __asn1_common_definitions__

typedef struct heim_octet_string {
  size_t length;
  void *data;
} heim_octet_string;

typedef char *heim_general_string;

typedef char *heim_utf8_string;

typedef struct heim_oid {
  size_t length;
  unsigned *components;
} heim_oid;

#define ASN1_MALLOC_ENCODE(T, B, BL, S, L, R)                  \
  do {                                                         \
    (BL) = length_##T((S));                                    \
    (B) = malloc((BL));                                        \
    if((B) == NULL) {                                          \
      (R) = ENOMEM;                                            \
    } else {                                                   \
      (R) = encode_##T(((unsigned char*)(B)) + (BL) - 1, (BL), \
                       (S), (L));                              \
      if((R) != 0) {                                           \
        free((B));                                             \
        (B) = NULL;                                            \
      }                                                        \
    }                                                          \
  } while (0)

#endif

enum { HDB_DB_FORMAT = 2 };

enum { hdb_pw_salt = 3 };

enum { hdb_afs3_salt = 10 };

/*
Salt ::= SEQUENCE {
  type[0]         UNSIGNED INTEGER,
  salt[1]         OCTET STRING
}
*/

typedef struct Salt {
  unsigned int type;
  heim_octet_string salt;
} Salt;

int    encode_Salt(unsigned char *, size_t, const Salt *, size_t *);
int    decode_Salt(const unsigned char *, size_t, Salt *, size_t *);
void   free_Salt  (Salt *);
size_t length_Salt(const Salt *);
int    copy_Salt  (const Salt *, Salt *);


/*
Key ::= SEQUENCE {
  mkvno[0]        UNSIGNED INTEGER OPTIONAL,
  key[1]          EncryptionKey,
  salt[2]         Salt OPTIONAL
}
*/

typedef struct Key {
  unsigned int *mkvno;
  EncryptionKey key;
  Salt *salt;
} Key;

int    encode_Key(unsigned char *, size_t, const Key *, size_t *);
int    decode_Key(const unsigned char *, size_t, Key *, size_t *);
void   free_Key  (Key *);
size_t length_Key(const Key *);
int    copy_Key  (const Key *, Key *);


/*
Event ::= SEQUENCE {
  time[0]         KerberosTime,
  principal[1]    Principal OPTIONAL
}
*/

typedef struct Event {
  KerberosTime time;
  Principal *principal;
} Event;

int    encode_Event(unsigned char *, size_t, const Event *, size_t *);
int    decode_Event(const unsigned char *, size_t, Event *, size_t *);
void   free_Event  (Event *);
size_t length_Event(const Event *);
int    copy_Event  (const Event *, Event *);


/*
HDBFlags ::= BIT STRING {
  initial(0),
  forwardable(1),
  proxiable(2),
  renewable(3),
  postdate(4),
  server(5),
  client(6),
  invalid(7),
  require-preauth(8),
  change-pw(9),
  require-hwauth(10),
  ok-as-delegate(11),
  user-to-user(12),
  immutable(13)
}
*/

typedef struct HDBFlags {
  unsigned int initial:1;
  unsigned int forwardable:1;
  unsigned int proxiable:1;
  unsigned int renewable:1;
  unsigned int postdate:1;
  unsigned int server:1;
  unsigned int client:1;
  unsigned int invalid:1;
  unsigned int require_preauth:1;
  unsigned int change_pw:1;
  unsigned int require_hwauth:1;
  unsigned int ok_as_delegate:1;
  unsigned int user_to_user:1;
  unsigned int immutable:1;
} HDBFlags;


int    encode_HDBFlags(unsigned char *, size_t, const HDBFlags *, size_t *);
int    decode_HDBFlags(const unsigned char *, size_t, HDBFlags *, size_t *);
void   free_HDBFlags  (HDBFlags *);
size_t length_HDBFlags(const HDBFlags *);
int    copy_HDBFlags  (const HDBFlags *, HDBFlags *);
unsigned HDBFlags2int(HDBFlags);
HDBFlags int2HDBFlags(unsigned);
const struct units * asn1_HDBFlags_units(void);

/*
GENERATION ::= SEQUENCE {
  time[0]         KerberosTime,
  usec[1]         UNSIGNED INTEGER,
  gen[2]          UNSIGNED INTEGER
}
*/

typedef struct GENERATION {
  KerberosTime time;
  unsigned int usec;
  unsigned int gen;
} GENERATION;

int    encode_GENERATION(unsigned char *, size_t, const GENERATION *, size_t *);
int    decode_GENERATION(const unsigned char *, size_t, GENERATION *, size_t *);
void   free_GENERATION  (GENERATION *);
size_t length_GENERATION(const GENERATION *);
int    copy_GENERATION  (const GENERATION *, GENERATION *);


/*
hdb_entry ::= SEQUENCE {
  principal[0]    Principal OPTIONAL,
  kvno[1]         UNSIGNED INTEGER,
  keys[2]         SEQUENCE OF Key,
  created-by[3]   Event,
  modified-by[4]  Event OPTIONAL,
  valid-start[5]  KerberosTime OPTIONAL,
  valid-end[6]    KerberosTime OPTIONAL,
  pw-end[7]       KerberosTime OPTIONAL,
  max-life[8]     UNSIGNED INTEGER OPTIONAL,
  max-renew[9]    UNSIGNED INTEGER OPTIONAL,
  flags[10]       HDBFlags,
  etypes[11]      SEQUENCE OF UNSIGNED INTEGER OPTIONAL,
  generation[12]  GENERATION OPTIONAL
}
*/

typedef struct hdb_entry {
  Principal *principal;
  unsigned int kvno;
  struct  {
    unsigned int len;
    Key *val;
  } keys;
  Event created_by;
  Event *modified_by;
  KerberosTime *valid_start;
  KerberosTime *valid_end;
  KerberosTime *pw_end;
  unsigned int *max_life;
  unsigned int *max_renew;
  HDBFlags flags;
  struct  {
    unsigned int len;
    unsigned int *val;
  } *etypes;
  GENERATION *generation;
} hdb_entry;

int    encode_hdb_entry(unsigned char *, size_t, const hdb_entry *, size_t *);
int    decode_hdb_entry(const unsigned char *, size_t, hdb_entry *, size_t *);
void   free_hdb_entry  (hdb_entry *);
size_t length_hdb_entry(const hdb_entry *);
int    copy_hdb_entry  (const hdb_entry *, hdb_entry *);


#endif /* __hdb_asn1_h__ */
@


1.3
log
@Regenerate files that were affected by changes to asn1_compile that were
made years ago.

ok deraadt@@
@
text
@@


1.2
log
@fix for heimdal 0.7.2
@
text
@d1 1
a1 1
/* Generated from /home/biorn/src/lib/libkrb5/../../kerberosV/src/lib/hdb/hdb.asn1 */
a8 2

time_t timegm (struct tm*);
@


1.1
log
@Generated files. Removes dependency on asn1_compile, etc.
@
text
@d1 1
a1 1
/* Generated from /usr/src/lib/libkrb5/../../kerberosV/src/lib/hdb/hdb.asn1 */
d15 1
a15 1
typedef struct octet_string {
d18 1
a18 1
} octet_string;
d20 1
a20 1
typedef char *general_string;
d22 3
a24 1
typedef struct oid {
d27 1
a27 1
} oid;
d55 1
a55 1
  type[0]         INTEGER,
d61 2
a62 2
  int type;
  octet_string salt;
d74 1
a74 1
  mkvno[0]        INTEGER OPTIONAL,
d81 1
a81 1
  int *mkvno;
d156 1
a156 1
extern struct units HDBFlags_units[];
d161 2
a162 2
  usec[1]         INTEGER,
  gen[2]          INTEGER
d168 2
a169 2
  int usec;
  int gen;
d182 1
a182 1
  kvno[1]         INTEGER,
d189 2
a190 2
  max-life[8]     INTEGER OPTIONAL,
  max-renew[9]    INTEGER OPTIONAL,
d192 1
a192 1
  etypes[11]      SEQUENCE OF INTEGER OPTIONAL,
d199 1
a199 1
  int kvno;
d209 2
a210 2
  int *max_life;
  int *max_renew;
d214 1
a214 1
    int *val;
@

