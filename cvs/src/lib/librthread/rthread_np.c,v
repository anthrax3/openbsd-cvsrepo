head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.18
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.16
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.14
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.10
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.12
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.8
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.6
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.4
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.19
date	2016.05.07.19.05.22;	author guenther;	state Exp;
branches;
next	1.18;
commitid	d9R7VGw9CHTkwXE1;

1.18
date	2016.04.02.19.00.51;	author guenther;	state Exp;
branches;
next	1.17;
commitid	HcJGR3mYEiomHNg2;

1.17
date	2015.01.24.10.35.33;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	GcZWmn28qX2hyH98;

1.16
date	2015.01.16.16.48.52;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	0DYulI8hhujBHMcR;

1.15
date	2014.12.08.18.15.46;	author tedu;	state Exp;
branches;
next	1.14;
commitid	u4EQHE28RkS6Sh6D;

1.14
date	2014.08.09.03.29.35;	author guenther;	state Exp;
branches;
next	1.13;
commitid	zJK2PUOG5534og9W;

1.13
date	2014.07.08.17.19.22;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	EF98ch02VpFassUi;

1.12
date	2014.07.01.03.32.18;	author guenther;	state Exp;
branches;
next	1.11;
commitid	p1Dkx943Gz6X4IpJ;

1.11
date	2014.05.02.21.58.51;	author kurt;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.29.16.27.40;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.13.16.56.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.31.22.43.53;	author kurt;	state Exp;
branches;
next	1.7;

1.7
date	2012.02.18.21.12.09;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2011.12.28.04.59.31;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2007.07.08.01.53.46;	author kurt;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.12.13.34.12;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.01.18.53.25;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.30.20.35.11;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.29.20.34.22;	author otto;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@/*	$OpenBSD: rthread_np.c,v 1.18 2016/04/02 19:00:51 guenther Exp $	*/
/*
 * Copyright (c) 2004,2005 Ted Unangst <tedu@@openbsd.org>
 * Copyright (c) 2005 Otto Moerbeek <otto@@openbsd.org>
 * All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/lock.h>
#include <sys/resource.h>
#include <sys/queue.h>
#include <sys/sysctl.h>

#include <errno.h>
#include <pthread.h>
#include <pthread_np.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <tib.h>
#include <unistd.h>

#include "rthread.h"

REDIRECT_SYSCALL(sysctl);

void
pthread_set_name_np(pthread_t thread, const char *name)
{
	strlcpy(thread->name, name, sizeof(thread->name));
}

int
pthread_main_np(void)
{
	return (!_threads_ready ||
	    (TIB_GET()->tib_thread_flags & TIB_THREAD_INITIAL_STACK) ? 1 : 0);
}


/*
 * Return stack info from the given thread.  Based upon the solaris
 * thr_stksegment function.  Note that the returned ss_sp member is the
 * *top* of the allocated stack area, unlike in sigaltstack() where
 * it's the bottom.  You'll have to ask Sun what they were thinking...
 *
 * This function taken from the uthread library, with the following
 * license: 
 * PUBLIC DOMAIN: No Rights Reserved. Marco S Hyman <marc@@snafu.org> */
int
pthread_stackseg_np(pthread_t thread, stack_t *sinfo)
{
	if (thread->stack) {
#ifdef MACHINE_STACK_GROWS_UP
		sinfo->ss_sp = thread->stack->base;
#else
		sinfo->ss_sp = (char *)thread->stack->base +
		    thread->stack->len;
#endif
		sinfo->ss_size = thread->stack->len;
		if (thread->stack->guardsize != 1)
			sinfo->ss_size -= thread->stack->guardsize;
		sinfo->ss_flags = 0;
		return (0);
	} else if (thread->tib->tib_thread_flags & TIB_THREAD_INITIAL_STACK) {
		static struct _ps_strings _ps;
		static struct rlimit rl;
		static int gotself;

		if (gotself == 0) {
			int mib[2];
			size_t len;

			if (getrlimit(RLIMIT_STACK, &rl) != 0)
				return (EAGAIN);

			mib[0] = CTL_VM;
			mib[1] = VM_PSSTRINGS;
			len = sizeof(_ps);
			if (sysctl(mib, 2, &_ps, &len, NULL, 0) != 0)
				return (EAGAIN);
			gotself = 1;
		}

		/*
		 * Provides a rough estimation of stack bounds.   Caller
		 * likely wants to know for the purpose of inspecting call
		 * frames, but VM_PSSTRINGS points to process arguments...
		 */
#ifdef MACHINE_STACK_GROWS_UP
		sinfo->ss_sp = _ps.val;
#else
		sinfo->ss_sp = (void *)ROUND_TO_PAGE((uintptr_t)_ps.val);
#endif
		sinfo->ss_size = (size_t)rl.rlim_cur;
		sinfo->ss_flags = 0;
		return (0);
	}
	return (EAGAIN);
}
@


1.18
log
@Eliminate the need to explicitly invoke syscalls via their _thread_sys_*
aliases by using a macro REDIRECT_SYSCALL() to map the symbols.  Apply
that to getthrid(), sysctl(), and issetugid() as well.

ok mpi@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.17 2015/01/24 10:35:33 kettenis Exp $	*/
a26 1
#include <stdint.h>
d31 1
d33 1
a35 2
#include <machine/spinlock.h>

d49 2
a50 2
	return (!_threads_ready || (pthread_self()->flags & THREAD_ORIGINAL)
	    ? 1 : 0);
d78 1
a78 1
	} else if (thread->flags & THREAD_INITIAL_STACK) {
@


1.17
log
@Add back <sys/param.h>; it's needed for MACHINE_STACK_GROWS_UP.

ok millert@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.16 2015/01/16 16:48:52 deraadt Exp $	*/
d38 2
@


1.16
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.15 2014/12/08 18:15:46 tedu Exp $	*/
d20 1
@


1.15
log
@avoid void arithmetic. from david carlier
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.14 2014/08/09 03:29:35 guenther Exp $	*/
a19 1
#include <sys/param.h>
@


1.14
log
@Only need <stdint.h> and not <inttypes.h> here
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.13 2014/07/08 17:19:22 deraadt Exp $	*/
d69 2
a70 1
		sinfo->ss_sp = thread->stack->base + thread->stack->len;
@


1.13
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.12 2014/07/01 03:32:18 guenther Exp $	*/
d27 1
a27 1
#include <inttypes.h>
@


1.12
log
@Use a flag on the pthread_t to indicate that the thread's stack was
allocated by the kernel's execve bits.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.11 2014/05/02 21:58:51 kurt Exp $	*/
a34 1
#include <uvm/uvm_extern.h>
@


1.11
log
@- Adjust pthread_stackseg_np to return the page aligned addressable stack
range. okay kettenis@@, guenther@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.10 2013/11/29 16:27:40 guenther Exp $	*/
d77 1
a77 1
	} else if (thread == &_initial_thread) {
@


1.10
log
@Don't try to reuse _initial_thread in the fork() wrapper, as the
thread's existing handle must continue to be valid and it didn't
fully 'change' the thread handle anyway.  For pthread_main_np(),
use a new flag, THREAD_ORIGINAL, to indicate that the flagged thread
is the original thread for *this* process.

Fixes some ConsoleKit failures according to aja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.9 2013/11/13 16:56:17 deraadt Exp $	*/
d27 1
d67 5
a71 1
		sinfo->ss_sp = thread->stack->sp;
a100 2
		 * 
		 * XXXX This interface ignores MACHINE_STACK_GROWS_UP.
d102 1
d104 3
@


1.9
log
@use sysctl vm.psstrings to calculate stack bounds, rather than USRSTACK.
long discussions with guenther, kurt, kettenis etc etc etc
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.8 2013/03/31 22:43:53 kurt Exp $	*/
d48 2
a49 1
	return (!_threads_ready || pthread_self() == &_initial_thread ? 1 : 0);
@


1.8
log
@- Don't include guard pages in the stack size.
  From Christian Schulte (cs at schulte.it)
- Use stack->sp instead of recalculating it. From guenther@@
okay guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.7 2012/02/18 21:12:09 guenther Exp $	*/
d25 1
a63 3
	int ret;
	struct rlimit rl;

d70 1
a70 1
		ret = 0;
d72 18
a89 2
		if (getrlimit(RLIMIT_STACK, &rl) != 0)
			return (EAGAIN);
d92 5
a96 3
		 * round_page() stack rlim_cur and
		 * trunc_page() USRSTACK to be consistent with
		 * the way the kernel sets up the stack.
d98 2
a99 2
		sinfo->ss_size = ROUND_TO_PAGE((size_t)rl.rlim_cur);
		sinfo->ss_sp = (caddr_t) (USRSTACK & ~(_thread_pagesize - 1));
d101 3
a103 6
		ret = 0;

	} else
		ret = EAGAIN;

	return ret;
@


1.7
log
@Fix the handling of the stackaddr, stacksize, and guardsize attributes:
don't try to merge values, round the sizes separately, and don't try to
unmap application-supplied stacks.
Copy from uthread the caching of default-sized stacks.
Have pthread_attr_init() and pthread_create() get the default attributes
from staticly allocated pthread_attr_t.
Cache the pagesize in _rthread_init() and provide a macro for rounding to it

based on suggestions from kettenis@@ and tedu@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.6 2011/12/28 04:59:31 guenther Exp $	*/
a62 1
	char *base;
d67 1
a67 5
		base = thread->stack->base;
#if !defined(MACHINE_STACK_GROWS_UP)
		base += (ptrdiff_t)thread->stack->len;
#endif
		sinfo->ss_sp = base;
d69 2
@


1.6
log
@pthread_self() may be much cheaper and never more expensive than getthrid()
so prefer it for identifying the current thread
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.5 2007/07/08 01:53:46 kurt Exp $	*/
d53 3
a55 1
 * thr_stksegment function.
a63 1
	size_t pgsz;
d79 1
a79 3
		pgsz = (size_t)sysconf(_SC_PAGESIZE);
		if (pgsz == (size_t)-1)
			return (EAGAIN);
d85 2
a86 4
		sinfo->ss_size = (size_t)rl.rlim_cur;
		sinfo->ss_size += (pgsz - 1);
		sinfo->ss_size &= ~(pgsz - 1);
		sinfo->ss_sp = (caddr_t) (USRSTACK & ~(pgsz - 1));
@


1.5
log
@Report the correct stack size and top for the primordial thread in
pthread_stackseg_np(). With input and okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.4 2006/04/12 13:34:12 henning Exp $	*/
d47 1
a47 1
	return (!_threads_ready || getthrid() == _initial_thread.tid ? 1 : 0);
@


1.4
log
@make rthreads compile again
pthreads header changed, char * -> const char *
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.3 2006/01/01 18:53:25 otto Exp $	*/
d21 1
d23 1
d29 1
d64 1
d69 1
a69 1
		base += thread->stack->len;
d76 3
a78 1
		pgsz = sysconf(_SC_PAGESIZE);
d80 12
a91 13
			ret = EAGAIN;
		else {
#if defined(MACHINE_STACK_GROWS_UP)
			base = (caddr_t) USRSTACK;
#else
			base = (caddr_t) ((USRSTACK - DFLSSIZ) & ~(pgsz - 1));
			base += DFLSSIZ;
#endif
			sinfo->ss_sp = base;
			sinfo->ss_size = DFLSSIZ;
			sinfo->ss_flags = 0;
			ret = 0;
		}
@


1.3
log
@Nicer implementation of pthread_main_np(), which avoids the spinlock.
ok tedu@@ marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.2 2005/12/30 20:35:11 otto Exp $	*/
d36 1
a36 1
pthread_set_name_np(pthread_t thread, char *name)
@


1.2
log
@use queue.h macros for thread house keeping; make some vars non-static
and fix a bug in thread creation error path. ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_np.c,v 1.1 2005/12/29 20:34:22 otto Exp $	*/
d44 1
a44 6
	pthread_t me = pthread_self();

	if (me == NULL)
		return (-1);
	else
		return (me == &_initial_thread ? 1 : 0);
@


1.1
log
@Put the existing _np functions into separate file; introduce
pthread_stackseg_np(), from existing pthread lib.
discussed with tedu@@ ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a33 2

extern struct pthread _initial_thread;
@

