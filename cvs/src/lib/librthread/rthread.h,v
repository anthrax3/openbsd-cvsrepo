head	1.60;
access;
symbols
	OPENBSD_6_1:1.60.0.2
	OPENBSD_6_1_BASE:1.60
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.39.0.2
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.10
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17;
locks; strict;
comment	@ * @;


1.60
date	2016.09.04.10.13.35;	author akfaew;	state Exp;
branches;
next	1.59;
commitid	tPNEomz2X1xlRc3u;

1.59
date	2016.09.03.16.44.20;	author akfaew;	state Exp;
branches;
next	1.58;
commitid	A8DISbEBB3jwsSL3;

1.58
date	2016.05.07.19.05.22;	author guenther;	state Exp;
branches;
next	1.57;
commitid	d9R7VGw9CHTkwXE1;

1.57
date	2016.04.15.17.54.17;	author tedu;	state Exp;
branches;
next	1.56;
commitid	umGhJIHgJSbCXeBU;

1.56
date	2016.04.02.19.00.51;	author guenther;	state Exp;
branches;
next	1.55;
commitid	HcJGR3mYEiomHNg2;

1.55
date	2016.01.27.08.40.05;	author kettenis;	state Exp;
branches;
next	1.54;
commitid	mL5c06Fqgo0x5wfa;

1.54
date	2015.11.10.04.30.59;	author guenther;	state Exp;
branches;
next	1.53;
commitid	GTAoVjpQRAdNHXVz;

1.53
date	2015.10.18.08.02.58;	author guenther;	state Exp;
branches;
next	1.52;
commitid	lDpsAqCZ03zHaXJb;

1.52
date	2015.05.19.20.50.06;	author guenther;	state Exp;
branches;
next	1.51;
commitid	9XB6auZflgiDfN67;

1.51
date	2015.04.29.06.01.37;	author guenther;	state Exp;
branches;
next	1.50;
commitid	KgxdDBMASll0o49H;

1.50
date	2014.08.31.04.02.08;	author guenther;	state Exp;
branches;
next	1.49;
commitid	cqt0oliIc4YJXCZZ;

1.49
date	2014.07.01.03.32.18;	author guenther;	state Exp;
branches;
next	1.48;
commitid	p1Dkx943Gz6X4IpJ;

1.48
date	2013.11.29.16.27.40;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.20.23.18.17;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2013.11.18.23.10.48;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2013.06.21.06.08.50;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2013.06.03.04.33.44;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2013.06.01.23.06.26;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2013.06.01.20.47.40;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2013.03.24.19.55.45;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2012.08.22.23.43.32;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	2012.05.03.09.07.17;	author pirofti;	state Exp;
branches;
next	1.38;

1.38
date	2012.04.11.10.18.46;	author pirofti;	state Exp;
branches;
next	1.37;

1.37
date	2012.03.22.15.26.04;	author kurt;	state Exp;
branches;
next	1.36;

1.36
date	2012.03.03.10.02.26;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2012.02.23.04.43.06;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2012.02.18.22.03.21;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2012.02.18.21.12.09;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2012.02.15.04.58.42;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.17.02.34.18;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2011.12.21.00.49.47;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.05.04.02.03;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2011.11.06.12.15.51;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2011.11.06.11.48.59;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2011.10.17.06.39.20;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.27.19.45.54;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.27.19.43.55;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.27.19.42.24;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.21.16.05.48;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.21.12.43.01;	author kurt;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.20.02.38.57;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2008.10.03.04.22.37;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.05.21.06.11;	author kurt;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.05.04.06.48;	author marc;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.04.19.48.52;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.01.19.32.30;	author marc;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.31.21.40.43;	author marc;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.31.08.51.20;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.30.20.35.11;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.30.04.05.55;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.22.06.49.48;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.19.21.30.10;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.19.06.47.40;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.19.06.45.14;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.14.06.07.54;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.14.04.43.04;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.14.04.01.44;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.13.17.22.46;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.13.05.56.55;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.03.18.16.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.60
log
@Get rid of ticket support, replace "struct _spinlock" with "_atomic_lock_t".

ok tedu@@
@
text
@/*	$OpenBSD: rthread.h,v 1.59 2016/09/03 16:44:20 akfaew Exp $ */
/*
 * Copyright (c) 2004,2005 Ted Unangst <tedu@@openbsd.org>
 * All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Private data structures that back up the typedefs in pthread.h.
 * Since only the thread library cares about their size or arrangement,
 * it should be possible to switch libraries without relinking.
 *
 * Do not reorder _atomic_lock_t and sem_t variables in the structs.
 * This is due to alignment requirements of certain arches like hppa.
 * The current requirement is 16 bytes.
 *
 * THE MACHINE DEPENDENT CERROR CODE HAS HARD CODED OFFSETS INTO PTHREAD_T!
 */

#include <sys/queue.h>
#include <semaphore.h>
#include <machine/spinlock.h>

#ifdef __LP64__
#define RTHREAD_STACK_SIZE_DEF (512 * 1024)
#else
#define RTHREAD_STACK_SIZE_DEF (256 * 1024)
#endif

#define	_SPINLOCK_UNLOCKED _ATOMIC_LOCK_UNLOCKED

struct stack {
	SLIST_ENTRY(stack)	link;	/* link for free default stacks */
	void	*sp;			/* machine stack pointer */
	void	*base;			/* bottom of allocated area */
	size_t	guardsize;		/* size of PROT_NONE zone or */
					/* ==1 if application alloced */
	size_t	len;			/* total size of allocated stack */
};

struct __sem {
	_atomic_lock_t lock;
	volatile int waitcount;
	volatile int value;
	int shared;
};

TAILQ_HEAD(pthread_queue, pthread);

struct pthread_mutex {
	_atomic_lock_t lock;
	struct pthread_queue lockers;
	int type;
	pthread_t owner;
	int count;
	int prioceiling;
};

struct pthread_mutex_attr {
	int ma_type;
	int ma_protocol;
	int ma_prioceiling;
};

struct pthread_cond {
	_atomic_lock_t lock;
	struct pthread_queue waiters;
	struct pthread_mutex *mutex;
	clockid_t clock;
};

struct pthread_cond_attr {
	clockid_t ca_clock;
};

struct pthread_rwlock {
	_atomic_lock_t lock;
	pthread_t owner;
	struct pthread_queue writers;
	int readers;
};

struct pthread_rwlockattr {
	int pshared;
};

struct pthread_attr {
	void *stack_addr;
	size_t stack_size;
	size_t guard_size;
	int detach_state;
	int contention_scope;
	int sched_policy;
	struct sched_param sched_param;
	int sched_inherit;
};

#define	PTHREAD_MIN_PRIORITY	0
#define	PTHREAD_MAX_PRIORITY	31

struct rthread_key {
	int used;
	void (*destructor)(void *);
};

struct rthread_storage {
	int keyid;
	struct rthread_storage *next;
	void *data;
};

struct rthread_cleanup_fn {
	void (*fn)(void *);
	void *arg;
	struct rthread_cleanup_fn *next;
};

struct pthread_barrier {
	pthread_mutex_t mutex;
	pthread_cond_t cond;
	int threshold;
	int in;
	int out;
	int generation;
};

struct pthread_barrierattr {
	int pshared;
};

struct pthread_spinlock {
	_atomic_lock_t lock;
	pthread_t owner;
};

struct tib;
struct pthread {
	struct __sem donesem;
	unsigned int flags;
	_atomic_lock_t flags_lock;
	struct tib *tib;
	void *retval;
	void *(*fn)(void *);
	void *arg;
	char name[32];
	struct stack *stack;
	LIST_ENTRY(pthread) threads;
	TAILQ_ENTRY(pthread) waiting;
	pthread_cond_t blocking_cond;
	struct pthread_attr attr;
	struct rthread_storage *local_storage;
	struct rthread_cleanup_fn *cleanup_fns;
	int myerrno;

	/* cancel received in a delayed cancel block? */
	int delayed_cancel;
};
/* flags in pthread->flags */
#define	THREAD_DONE		0x001
#define	THREAD_DETACHED		0x002

/* flags in tib->tib_thread_flags */
#define	TIB_THREAD_ASYNC_CANCEL		0x001
#define	TIB_THREAD_INITIAL_STACK	0x002	/* has stack from exec */

#define ENTER_DELAYED_CANCEL_POINT(tib, self)				\
	(self)->delayed_cancel = 0;					\
	ENTER_CANCEL_POINT_INNER(tib, 1, 1)

#define	ROUND_TO_PAGE(size) \
	(((size) + (_thread_pagesize - 1)) & ~(_thread_pagesize - 1))

__BEGIN_HIDDEN_DECLS
void	_spinlock(volatile _atomic_lock_t *);
int	_spinlocktry(volatile _atomic_lock_t *);
void	_spinunlock(volatile _atomic_lock_t *);
int	_sem_wait(sem_t, int, const struct timespec *, int *);
int	_sem_post(sem_t);

void	_rthread_init(void);
struct stack *_rthread_alloc_stack(pthread_t);
void	_rthread_free_stack(struct stack *);
void	_rthread_tls_destructors(pthread_t);
void	_rthread_debug(int, const char *, ...)
		__attribute__((__format__ (printf, 2, 3)));
void	_rthread_debug_init(void);
#ifndef NO_PIC
void	_rthread_dl_lock(int what);
#endif
void	_thread_malloc_reinit(void);

extern int _threads_ready;
extern size_t _thread_pagesize;
extern LIST_HEAD(listhead, pthread) _thread_list;
extern _atomic_lock_t _thread_lock;
extern struct pthread_attr _rthread_attr_default;
__END_HIDDEN_DECLS

void	_thread_dump_info(void);

/* syscalls not declared in system headers */
#define REDIRECT_SYSCALL(x)		typeof(x) x asm("_thread_sys_"#x)
void	__threxit(pid_t *);
int	__thrsleep(const volatile void *, clockid_t, const struct timespec *,
	    volatile void *, const int *);
int	__thrwakeup(const volatile void *, int n);
int	__thrsigdivert(sigset_t, siginfo_t *, const struct timespec *);
@


1.59
log
@Remove _USING_TICKETS, it's defined as 0. No functional change.

ok tedu@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.58 2016/05/07 19:05:22 guenther Exp $ */
d23 1
a23 1
 * Do not reorder struct _spinlock and sem_t variables in the structs.
d40 1
a40 11
/*
 * tickets don't work yet? (or seem much slower, with lots of system time)
 * until then, keep the struct around to avoid excessive changes going
 * back and forth.
 */
struct _spinlock {
	_atomic_lock_t ticket;
};

#define	_SPINLOCK_UNLOCKED { _ATOMIC_LOCK_UNLOCKED }
extern struct _spinlock _SPINLOCK_UNLOCKED_ASSIGN;
d52 1
a52 1
	struct _spinlock lock;
d61 1
a61 1
	struct _spinlock lock;
d76 1
a76 1
	struct _spinlock lock;
d87 1
a87 1
	struct _spinlock lock;
d142 1
a142 1
	struct _spinlock lock;
d150 1
a150 1
	struct _spinlock flags_lock;
d184 3
a186 3
void	_spinlock(volatile struct _spinlock *);
int	_spinlocktry(volatile struct _spinlock *);
void	_spinunlock(volatile struct _spinlock *);
d205 1
a205 1
extern struct _spinlock _thread_lock;
@


1.58
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.57 2016/04/15 17:54:17 tedu Exp $ */
a39 1
#define _USING_TICKETS 0
@


1.57
log
@make pthread_barrier_wait behave more like it does on other platforms.
from Kari Tristan Helgason
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.56 2016/04/02 19:00:51 guenther Exp $ */
a32 1
#include <machine/tcb.h>		/* for TLS_VARIANT */
d157 1
a159 4
#if TLS_VARIANT == 1
	int *errno_ptr;
#endif
	pid_t tid;
d162 1
a162 1
	void *tcb;
a175 3
	/* currently in a cancel point? */
	int cancel_point;

d179 1
a181 11
#define	THREAD_CANCELED		0x004
#define	THREAD_CANCEL_ENABLE	0x008
#define	THREAD_CANCEL_DEFERRED	0x010
#define	THREAD_CANCEL_DELAY	0x020
#define	THREAD_DYING		0x040
#define	THREAD_ORIGINAL		0x080	/* original thread from fork */
#define	THREAD_INITIAL_STACK	0x100	/* thread with stack from exec */

#define	IS_CANCELED(thread) \
	(((thread)->flags & (THREAD_CANCELED|THREAD_DYING)) == THREAD_CANCELED)

d183 7
a189 5
extern int _threads_ready;
extern size_t _thread_pagesize;
extern LIST_HEAD(listhead, pthread) _thread_list;
extern struct _spinlock _thread_lock;
extern struct pthread_attr _rthread_attr_default;
d194 1
d201 1
a201 3
int	_rthread_init(void);
void	_rthread_setflag(pthread_t, int);
void	_rthread_clearflag(pthread_t, int);
d213 6
a218 5
/* rthread_cancel.c */
void	_enter_cancel(pthread_t);
void	_leave_cancel(pthread_t);
void	_enter_delayed_cancel(pthread_t);
void	_leave_delayed_cancel(pthread_t, int);
@


1.56
log
@Eliminate the need to explicitly invoke syscalls via their _thread_sys_*
aliases by using a macro REDIRECT_SYSCALL() to map the symbols.  Apply
that to getthrid(), sysctl(), and issetugid() as well.

ok mpi@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.55 2016/01/27 08:40:05 kettenis Exp $ */
d144 2
a145 1
	int sofar;
@


1.55
log
@Replace the malloc spinlock with a mutex.  This lock is held over system calls
which run for many cycles and may even sleep.  This leads to other threads
spinning for a long time waiting on the lock.  Using a mutex means those
threads go to sleep and get woken up when the lock is released, which results
in a lot less CPU usage.  More work is needed to improve the performance of
threaded code that suffers from malloc lock contention, but this diff makes
ports like Firefox significantly more usable.

Tested by many.

ok mpi@@, guenther@@, tedu@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.54 2015/11/10 04:30:59 guenther Exp $ */
d236 2
a237 1
/* syscalls */
a242 6
int	sched_yield(void);
int	_thread_sys_sigaction(int, const struct sigaction *,
	    struct sigaction *);
int	_thread_sys_sigprocmask(int, const sigset_t *, sigset_t *);
int	_thread_sys_thrkill(pid_t _tid, int _signum, void *_tcb);

@


1.54
log
@Split the intra-thread functionality from kill(2) into its own syscall
thrkill(2), rolling the kill(2) syscall number with the ABI change to
avoid breaking binaries during during the transition.  thrkill(2) includes
a 'tcb' argument that eliminates the need for locking in pthread_kill()
and simplifies pthread_cancel().  Switch __stack_smash_handler() to use
thrkill(2) and explicitly unblock SIGABRT.

Minor bump to both libc and libpthread: make sure you install a new kernel!

ok semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.53 2015/10/18 08:02:58 guenther Exp $ */
d226 1
@


1.53
log
@ld.so no longer needs or uses a bind lock, so stop setting it.  This
eliminates a chunk of complexity from the libpthread init and the fork
wrapper, as it was the bind lock that needed prebinding before use.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.52 2015/05/19 20:50:06 guenther Exp $ */
d165 1
d245 1
@


1.52
log
@Instead of testing for __ELF__ and/or vax, leave out the bits for interfacing
with ld.so locking whenever building NOPIC

pointless use of __ELF__ noted by brad@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.51 2015/04/29 06:01:37 guenther Exp $ */
a223 1
void	_rthread_bind_lock(int);
@


1.51
log
@Delete the duplicated sched_{policy,param} members from the internal struct
pthread and instead use the values from the embedded struct pthread_attr.
For bonus points, pay attention to the sched_inherit attribute and possibly
set the values from the parent thread.

Problem noted by natano of bitrig.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.50 2014/08/31 04:02:08 guenther Exp $ */
d222 1
a222 1
#if defined(__ELF__)
@


1.50
log
@Declare and document getthrid()

indirectly prodded by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.49 2014/07/01 03:32:18 guenther Exp $ */
a172 1
	int sched_policy;
a173 1
	struct sched_param sched_param;
@


1.49
log
@Use a flag on the pthread_t to indicate that the thread's stack was
allocated by the kernel's execve bits.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.48 2013/11/29 16:27:40 guenther Exp $ */
a237 1
int	getthrid(void);
@


1.48
log
@Don't try to reuse _initial_thread in the fork() wrapper, as the
thread's existing handle must continue to be valid and it didn't
fully 'change' the thread handle anyway.  For pthread_main_np(),
use a new flag, THREAD_ORIGINAL, to indicate that the flagged thread
is the original thread for *this* process.

Fixes some ConsoleKit failures according to aja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.47 2013/11/20 23:18:17 tedu Exp $ */
d193 2
a194 1
#define	THREAD_ORIGINAL		0x080	/* first thread in process */
a202 1
extern struct pthread _initial_thread;
@


1.47
log
@shared semaphore fixes. first, eliminate the sem inside a sem indirection.
it's not needed (mindless holdover from earlier prototype). everything is
simpler and sem_init shared semaphores even work now (confirmed by sthen).
correct the einval checks to not deref a pointer before the null check.
in sem_open, if we created the semaphore, we need to initialize the spinlock.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.46 2013/11/18 23:10:48 tedu Exp $ */
d188 6
a193 5
#define THREAD_CANCELED		0x004
#define THREAD_CANCEL_ENABLE	0x008
#define THREAD_CANCEL_DEFERRED	0x010
#define THREAD_CANCEL_DELAY	0x020
#define THREAD_DYING            0x040
@


1.46
log
@interprocess semaphores ala sem_open. mostly following in the pattern
of shm_open. with some additions and fixes from zhuk.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.45 2013/06/21 06:08:50 guenther Exp $ */
d67 1
a67 1
	struct __sem *shared;
@


1.45
log
@Move the declaration of _thread_sys_sigprocmask() to rthread.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.44 2013/06/03 04:33:44 tedu Exp $ */
d67 1
a67 1
	int __pad;
@


1.44
log
@THE MACHINE DEPENDENT CERROR CODE HAS HARD CODED OFFSETS INTO PTHREAD_T!
found the hard way by miod. resize and realign all the locks and
semaphores back to the way they were. sometimes i just can't win.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.43 2013/06/01 23:06:26 tedu Exp $ */
d246 2
@


1.43
log
@something's not quite right yet. ticket locks result in more CPU usage
and spinning in kernel. partially back out, but in a way that makes going
forward again easy.
seen by ajacoutot
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.42 2013/06/01 20:47:40 tedu Exp $ */
d26 2
a48 3
	uint32_t __waiter;
	uint32_t __ready;
	int __pad;
d51 1
a51 1
#define	_SPINLOCK_UNLOCKED { _ATOMIC_LOCK_UNLOCKED, 0, 0 }
d67 1
d159 3
a164 3
#if TLS_VARIANT == 1
	int *errno_ptr;
#endif
@


1.42
log
@cleanup and consolidate the spinlock_lock (what a name!) code.
it's now atomic_lock to better reflect its usage, and librthread now
features a new spinlock that's really a ticket lock.
thrlseep can handle both types of lock via a flag in the clock arg.
(temp back compat hack)
remove some old stuff that's accumulated along the way and no longer used.
some feedback from dlg, who is concerned with all things ticket lock.
(you need to boot a new kernel before installing librthread)
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.41 2013/03/24 19:55:45 guenther Exp $ */
d39 6
d46 4
a49 4
	_atomic_lock_t atomiclock;
	uint32_t waiter;
	uint32_t ready;
	int pad;
@


1.41
log
@SEM_VALUE_MAX belongs in <limits.h> (via sys/syslimits.h)
struct sem --> struct __sem (doesn't belong in public namespace)
Zap pointless _KERNEL tests

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.40 2012/08/22 23:43:32 matthew Exp $ */
d23 1
a23 1
 * Do not reorder _spinlock_lock_t and sem_t variables in the structs.
d39 10
d59 1
a59 1
	_spinlock_lock_t lock;
a61 1
	int pad;
d67 1
a67 1
	_spinlock_lock_t lock;
d82 1
a82 1
	_spinlock_lock_t lock;
d93 1
a93 1
	_spinlock_lock_t lock;
d147 1
a147 1
	_spinlock_lock_t lock;
d153 3
a158 3
	pid_t tid;
	unsigned int flags;
	_spinlock_lock_t flags_lock;
d196 1
a196 1
extern _spinlock_lock_t _thread_lock;
d202 3
a204 2
void	_spinlock(_spinlock_lock_t *);
void	_spinunlock(_spinlock_lock_t *);
a229 2
int	_atomic_lock(register volatile _spinlock_lock_t *);

d234 1
a234 1
	    void *, const int *);
@


1.40
log
@We want to check that the dynamic linker is available at run-time, so
we should actually check for _DYNAMIC at run-time rather than checking
for __PIC__ at compile time, since the two are actually independent.

Problem and solution identified by guenther; minor tweaks by me.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.39 2012/05/03 09:07:17 pirofti Exp $ */
d48 1
a48 1
struct sem {
d143 1
a143 1
	struct sem donesem;
@


1.39
log
@Add pthread spinlock support.

Implementation, documentation and naive regression tests for:
- pthread_spin_init()
- pthread_spin_destroy()
- pthread_spin_lock()
- pthread_spin_trylock()
- pthread_spin_unlock()

Implementation okay guenther@@, documentation okay jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.38 2012/04/11 10:18:46 pirofti Exp $ */
d207 1
a207 1
#if defined(__ELF__) && defined(PIC)
@


1.38
log
@Add pthread barrier support.

Implementation and documentation for:
 - pthread_barrier_init()
 - pthread_barrier_destroy()
 - pthread_barrier_wait()
 - pthread_barrierattr_init()
 - pthread_barrierattr_destroy()
 - pthread_barrierattr_getpshared()
 - pthread_barrierattr_setpshared()

Currently only private barriers are supported.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.37 2012/03/22 15:26:04 kurt Exp $ */
d135 5
@


1.37
log
@Remove pthread_suspend* and related functions. This is part of the
rthreads major library bump from last night. okay kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.36 2012/03/03 10:02:26 guenther Exp $ */
d123 12
@


1.36
log
@Add sem_timewait() and fix sem_wait()'s handling of signals, so
that it resumes waiting unless the thread was canceled.  As part
of this, change the internal _sem_wait() function to return zero
on success and an errno value on failure instead of 1 on success
and zero on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.35 2012/02/23 04:43:06 guenther Exp $ */
a102 1
	int create_suspended;
@


1.35
log
@Add pthread_condattr_{get,set}clock(), requested by aja@@
Add pthread_mutex_timedlock(), requested by dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.34 2012/02/18 22:03:21 guenther Exp $ */
d179 1
a179 1
int	_sem_wait(sem_t, int, int *);
@


1.34
log
@Fix previous commit: _rthread_init() was static.
Improve consistency of error naming
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.33 2012/02/18 21:12:09 guenther Exp $ */
d76 1
d80 1
a80 1
	int shared;
@


1.33
log
@Fix the handling of the stackaddr, stacksize, and guardsize attributes:
don't try to merge values, round the sizes separately, and don't try to
unmap application-supplied stacks.
Copy from uthread the caching of default-sized stacks.
Have pthread_attr_init() and pthread_create() get the default attributes
from staticly allocated pthread_attr_t.
Cache the pagesize in _rthread_init() and provide a macro for rounding to it

based on suggestions from kettenis@@ and tedu@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.32 2012/02/15 04:58:42 guenther Exp $ */
d181 1
@


1.32
log
@Add pthread_rwlockattr_{get,set}pshared() and
pthread_mutexattr_{get,set}kind_np()

tweaked diff from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.31 2012/01/17 02:34:18 guenther Exp $ */
d40 6
a45 5
	void *sp;
	void *base;
	void *guard;
	size_t guardsize;
	size_t len;
d167 1
d171 4
@


1.31
log
@Reimplement mutexes, condvars, and rwlocks to eliminate bugs,
particularly the "consume the signal you just sent" hang, and putting
the wait queues in userspace.

Do cancellation handling in pthread_cond_*wait(), pthread_join(),
and sem_wait().

Add __ prefix to thr{sleep,wakeup,exit,sigdivert}() syscalls; add
'abort" argument to thrsleep to close cancellation race; make
thr{sleep,wakeup} return errno values via *retval to avoid touching
userspace errno.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.30 2011/12/21 00:49:47 guenther Exp $ */
d89 1
a89 1
	int dummy;
@


1.30
log
@Split out the pthread_mutexattr_* functions from rthread_sync.c to
new file rthread_mutexattr.c.  Add basic implementations of
pthread_mutexattr_{set,get}{protocol,prioceiling}

Requested by aja
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.29 2011/12/05 04:02:03 guenther Exp $ */
d57 2
a58 1
	struct sem sem;
d72 3
a74 1
	struct sem sem;
a81 1
	struct sem sem;
d83 2
a85 1
	int writer;
d139 1
d146 2
d149 3
d158 1
a158 1
#define THREAD_CANCEL_COND	0x020
d161 4
d172 1
a172 2
int	_sem_wait(sem_t, int);
int	_sem_waitl(sem_t, int, clockid_t, const struct timespec *);
a173 2
int	_sem_wakeup(sem_t);
int	_sem_wakeall(sem_t);
d175 2
d189 1
d191 2
a192 1
void	_enter_cancel(pthread_t);
d199 9
a207 8
int getthrid(void);
void threxit(pid_t *);
int thrsleep(const volatile void *, clockid_t, const struct timespec *,
    volatile void *);
int thrwakeup(void *, int n);
int sched_yield(void);
int thrsigdivert(sigset_t, siginfo_t *, const struct timespec *);
int _thread_sys_sigaction(int, const struct sigaction *, struct sigaction *);
@


1.29
log
@Implement cancelation for the basic syscall cancelation points,
using previously allocated SIGTHR to interrupt in-process syscalls
and fixing the spelling of "cancelled" along the way.
Modeled on FreeBSD's libthr
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.28 2011/11/06 12:15:51 guenther Exp $ */
d61 1
d65 3
a67 1
	int type;
@


1.28
log
@Copy support for sched_get_priority_{min,max} from libpthread.
Requested by many to ease substitution of librthread for libpthread
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.27 2011/11/06 11:48:59 guenther Exp $ */
d139 1
d143 1
a143 1
#define THREAD_CANCELLED	0x004
d146 2
d173 3
d189 1
@


1.27
log
@Move <machine/spinlock.h> into rthread.h; strip out unnecessary #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.26 2011/10/17 06:39:20 guenther Exp $ */
d97 3
@


1.26
log
@Use __tfork, __get_tcb, and __set_tcb to have a real TCB and per-thread
errno.  The ASM bits for _cerror are sketchy or missing for some archs
but that can be corrected in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.25 2009/11/27 19:45:54 guenther Exp $ */
d30 1
@


1.25
log
@Convert thrsleep() to an absolute timeout with clockid to eliminate a
race condition and prep for later support of pthread_condattr_setclock()

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.24 2009/11/27 19:43:55 guenther Exp $ */
d30 1
d116 3
d134 1
@


1.24
log
@Convert thrsigdivert to (almost) be sigtimedwait by adding siginfo_t
and struct timespec * argument.  sigtimedwait is just a one line
wrapper after this.

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.23 2009/11/27 19:42:24 guenther Exp $ */
d144 2
a145 2
int	_sem_wait(sem_t, int, int);
int	_sem_waitl(sem_t, int, int);
d169 2
a170 1
int thrsleep(void *, int, void *);
@


1.23
log
@Change threxit() to take a pointer to a pid_t to zero out from the
kernel so that librthread can detect when a thread is completely
done with its stack without need a kqueue.  The dying thread moves
itself to a GC list, other threads scan the GC list on pthread_create()
and pthread_join() and free the stack and handle once the thread's
thread id is zeroed.

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.22 2009/10/21 16:05:48 guenther Exp $ */
d172 1
a172 1
int thrsigdivert(sigset_t);
@


1.22
log
@Add f*lockfile() routines to librthread

ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.21 2009/04/21 12:43:01 kurt Exp $ */
a140 1
extern int _rthread_kq;
a155 3
void	_rthread_add_to_reaper(pid_t, struct stack *);
void 	_rthread_reaper(void);
int	_rthread_open_kqueue(void);
d168 1
a168 1
void threxit(int);
@


1.21
log
@Increase default thread stack size to 256K on 32bit archs and 512K on
64bit archs to accommodate the growing number of ports that put large
buffers on the stack. Supported by many with no objections.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.20 2009/02/20 02:38:57 guenther Exp $ */
d52 2
d124 1
@


1.20
log
@thrsigdivert() takes a sigset_t, not a pointer to one.  Detected by
finally reading the lint warnings (sigh)

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.19 2008/10/03 04:22:37 guenther Exp $ */
d31 5
a35 1
#define RTHREAD_STACK_SIZE_DEF (64 * 1024)
@


1.19
log
@Make sigwait() work correctly.  In particular, it'll work when the
signal is already pending in the calling thread or the main thread
and there's no longer a race condition where the signal could be
diverted but sigwait() would still block.  There were some off-by-one
errors too.

(The checking of the main thread's pending list is just until a
pending list for the process can be added to struct process.  For
now, such signals end up as pending on the main thread.)

oks tedu@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.18 2008/06/05 21:06:11 kurt Exp $ */
d169 1
a169 1
int thrsigdivert(const sigset_t *);
@


1.18
log
@- Add fork/vfork wrapper functions to reset state in the child process.
- Make an effort to protect important libc and ld.so critical areas during
the fork(2)/vfork(2) sys call.
- Add pthread_atfork(3) implementation based on Daniel Eischen's code.

Original diff by Philip Guenther <guenther at gmail.com> with some
additions and refinements by me. Positive test report from brad@@ with
many kde apps. fork(2) and pthread_atfork(3) pthread regresses pass.
okay tedu@@, kettenis@@, marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.17 2006/01/05 04:06:48 marc Exp $ */
a121 1
	int sigpend;
@


1.17
log
@
add -Wstrict-prototypes -Wmissing-prototypes -Wsign-compare
Minor tweaks to compile with the above, primarily in fixing
the conflicts between semaphore.h and rthread.h
"i like the additional warnings" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.16 2006/01/04 19:48:52 otto Exp $ */
d153 5
@


1.16
log
@Cleanup struct pthread and stack after thread exits. This version does
not use a separate reaper thread. ok tedu@@ marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.15 2006/01/01 19:32:30 marc Exp $ */
d29 1
d41 1
a41 1
typedef struct semaphore {
d46 1
a46 1
} *sem_t;
d49 1
a49 1
	struct semaphore sem;
d60 1
a60 1
	struct semaphore sem;
d68 1
a68 1
	struct semaphore sem;
d108 1
a108 1
	struct semaphore donesem;
d150 1
@


1.15
log
@
thread stack handling changes.  Add guard zones and allow stack
size (and guard zone size) to be set using pthread_attr.   Guard
zones are specified in bytes, but implemented in terms of a
page size.

OK Otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.14 2005/12/31 21:40:43 marc Exp $ */
d110 1
d134 1
d149 3
@


1.14
log
@
Add "print debug foo" function safe to use in signal handlers, example:
_rthread_debug(3, "foo = %s", foo);
where output is to stderr and will only be printed if the current
debug level is >= 3.   Messages with a debug level of 0 are always
printed.  The level can be set from the environment (not enabled yet)
or with gdb by modifying variable _rthread_debug_level.
"Fine with me" -Otto
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.13 2005/12/31 08:51:20 otto Exp $ */
d30 2
d35 2
d80 1
d142 2
d147 2
@


1.13
log
@Implement suspend/resume and creation of initially suspended threads.
With this, java seems to be operational.  Also make threads_ready
non-static, which is needed for an upcoming diff.  ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.12 2005/12/30 20:35:11 otto Exp $ */
d138 2
@


1.12
log
@use queue.h macros for thread house keeping; make some vars non-static
and fix a bug in thread creation error path. ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.11 2005/12/30 04:05:55 tedu Exp $ */
d81 1
d112 1
d124 1
@


1.11
log
@prototype all the thread syscalls in rthread.h for now.
update for new thrwakeup that takes a count argument
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.10 2005/12/22 06:49:48 tedu Exp $ */
d28 2
d109 1
a109 1
	pthread_t next;
d121 4
@


1.10
log
@more consistently use _rthread prefix for all not meant to be exported
interfaces that aren't static, and a few that are but which will change
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.9 2005/12/19 21:30:10 marco Exp $ */
d131 8
@


1.9
log
@Fix hppa ldcw alignment issue.

Help deraadt, tedu, kettenis
Ok tedu, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.8 2005/12/19 06:47:40 tedu Exp $ */
d128 1
a128 1
void rthread_tls_destructors(pthread_t);
@


1.8
log
@update copyright to 2005
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.7 2005/12/19 06:45:14 tedu Exp $ */
d22 4
d35 1
d38 1
a38 1
	_spinlock_lock_t lock;
d61 1
a64 1
	struct semaphore sem;
d99 1
a100 1
	struct semaphore donesem;
@


1.7
log
@add pthread_get/set_concurrency (useless for now)
add pthread_get/set_stack[addr] (info not used yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.6 2005/12/14 06:07:54 tedu Exp $ */
d3 1
a3 1
 * Copyright (c) 2004 Ted Unangst <tedu@@openbsd.org>
@


1.6
log
@add pthread_cleanup_push and pthread_cleanup_pop
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.5 2005/12/14 04:43:04 tedu Exp $ */
d67 1
@


1.5
log
@add bits for pthread_cancel.  we don't really have cancellation points yet
but some of the functions are here now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.4 2005/12/14 04:01:44 tedu Exp $ */
d86 6
d106 1
@


1.4
log
@change keys to use table instead of list, makes a sane destructor implementation
possible
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.3 2005/12/13 17:22:46 tedu Exp $ */
d89 1
a89 1
	int flags;
d101 5
a105 2
#define	THREAD_DONE	0x001
#define	THREAD_DETACHED	0x002
@


1.3
log
@make the mutex unlock and sleep in pthread_cond_wait properly atomic
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.2 2005/12/13 05:56:55 tedu Exp $ */
d76 1
a76 2
	int keyid;
	struct rthread_key *next;
d111 2
@


1.2
log
@correct implementation of pthread_cond_signal.  it doesn't raise the sem
value if there are no waiters.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread.h,v 1.1 2005/12/03 18:16:19 tedu Exp $ */
d108 1
@


1.1
log
@add userland thread library.  incomplete, but functional
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d108 1
@

