head	1.18;
access;
symbols
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.11.0.4
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.7.0.14
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.12
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.10
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.6
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.4
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.18
date	2017.05.27.14.20.39;	author mpi;	state Exp;
branches;
next	1.17;
commitid	G5zNzLxMj34pcYsc;

1.17
date	2016.09.04.10.13.35;	author akfaew;	state Exp;
branches;
next	1.16;
commitid	tPNEomz2X1xlRc3u;

1.16
date	2016.09.01.10.56.46;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	HzJta88xKCDy1q89;

1.15
date	2016.09.01.10.41.02;	author otto;	state Exp;
branches;
next	1.14;
commitid	HatwrthzJhfQpDr7;

1.14
date	2016.05.07.19.05.22;	author guenther;	state Exp;
branches;
next	1.13;
commitid	d9R7VGw9CHTkwXE1;

1.13
date	2016.01.27.08.40.05;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	mL5c06Fqgo0x5wfa;

1.12
date	2015.04.07.01.27.07;	author guenther;	state Exp;
branches;
next	1.11;
commitid	oQvh7XA3Kql35r0J;

1.11
date	2013.06.01.20.47.40;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2012.04.17.15.10.11;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.05.04.02.03;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.06.11.48.59;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.13.21.18.43;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.23.02.20.24;	author kurt;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.01.00.43.39;	author kurt;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.05.18.11.49;	author kurt;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.27.02.41.24;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.05.04.24.30;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.05.04.06.48;	author marc;	state Exp;
branches;
next	;


desc
@@


1.18
log
@New mutex and condvar implementations based on futex(2).

Not enabled yet, it needs some SPINLOCK_SPIN_HOOK love and
some bumps.

Tested by many including sthen@@ in a bulk.

ok visa@@, sthen@@, kettenis@@, tedu@@
@
text
@/* $OpenBSD: rthread_libc.c,v 1.17 2016/09/04 10:13:35 akfaew Exp $ */

/* PUBLIC DOMAIN: No Rights Reserved. Marco S Hyman <marc@@snafu.org> */

#include <sys/time.h>

#include <pthread.h>
#include <stdlib.h>
#include <string.h>

#include "thread_private.h"	/* in libc/include */

#include "rthread.h"
#include "rthread_cb.h"

/*
 * A thread tag is a pointer to a structure of this type.  An opaque
 * tag is used to decouple libc from the thread library.
 */
struct _thread_tag {
	pthread_mutex_t	m;	/* the tag's mutex */
	pthread_key_t	k;	/* a key for private data */
};

/*
 * local mutex to protect against tag creation races.
 */
static pthread_mutex_t	_thread_tag_mutex = PTHREAD_MUTEX_INITIALIZER;

/*
 * Initialize a thread tag structure once.   This function is called
 * if the tag is null.  Allocation and initialization are controlled
 * by a mutex.   If the tag is not null when the mutex is obtained
 * the caller lost a race -- some other thread initialized the tag.
 * This function will never return NULL.
 */
static void
_thread_tag_init(void **tag)
{
	struct _thread_tag *tt;
	int result;

	result = pthread_mutex_lock(&_thread_tag_mutex);
	if (result == 0) {
		if (*tag == NULL) {
			tt = malloc(sizeof *tt);
			if (tt != NULL) {
				result = pthread_mutex_init(&tt->m, NULL);
				result |= pthread_key_create(&tt->k, free);
				*tag = tt;
			}
		}
		result |= pthread_mutex_unlock(&_thread_tag_mutex);
	}
	if (result != 0)
		_rthread_debug(1, "tag init failure");
}

/*
 * lock the mutex associated with the given tag
 */
void
_thread_tag_lock(void **tag)
{
	struct _thread_tag *tt;

	if (__isthreaded) {
		if (*tag == NULL)
			_thread_tag_init(tag);
		tt = *tag;
		if (pthread_mutex_lock(&tt->m) != 0)
			_rthread_debug(1, "tag mutex lock failure");
	}
}

/*
 * unlock the mutex associated with the given tag
 */
void
_thread_tag_unlock(void **tag)
{
	struct _thread_tag *tt;

	if (__isthreaded) {
		if (*tag == NULL)
			_thread_tag_init(tag);
		tt = *tag;
		if (pthread_mutex_unlock(&tt->m) != 0)
			_rthread_debug(1, "tag mutex unlock failure");
	}
}

/*
 * return the thread specific data for the given tag.   If there
 * is no data for this thread initialize it from 'storage'.
 * On any error return 'err'.
 */
void *
_thread_tag_storage(void **tag, void *storage, size_t sz, void *err)
{
	struct _thread_tag *tt;
	void *ret;

	if (*tag == NULL)
		_thread_tag_init(tag);
	tt = *tag;

	ret = pthread_getspecific(tt->k);
	if (ret == NULL) {
		ret = malloc(sz);
		if (ret == NULL)
			ret = err;
		else {
			if (pthread_setspecific(tt->k, ret) == 0)
				memcpy(ret, storage, sz);
			else {
				free(ret);
				ret = err;
			}
		}
	}
	return ret;
}

void
_thread_mutex_lock(void **mutex)
{
	pthread_mutex_t	*pmutex = (pthread_mutex_t *)mutex;

	if (pthread_mutex_lock(pmutex) != 0)
		_rthread_debug(1, "mutex lock failure");
}

void
_thread_mutex_unlock(void **mutex)
{
	pthread_mutex_t	*pmutex = (pthread_mutex_t *)mutex;

	if (pthread_mutex_unlock(pmutex) != 0)
		_rthread_debug(1, "mutex unlock failure");
}

void
_thread_mutex_destroy(void **mutex)
{
	pthread_mutex_t	*pmutex = (pthread_mutex_t *)mutex;

	if (pthread_mutex_destroy(pmutex) != 0)
		_rthread_debug(1, "mutex destroy failure");
}

/*
 * the malloc lock
 */
#ifndef FUTEX
#define MALLOC_LOCK_INITIALIZER(n) { \
	_SPINLOCK_UNLOCKED,	\
	TAILQ_HEAD_INITIALIZER(malloc_lock[n].lockers), \
	PTHREAD_MUTEX_DEFAULT,	\
	NULL,			\
	0,			\
	-1 }
#else
#define MALLOC_LOCK_INITIALIZER(n) { \
	_SPINLOCK_UNLOCKED,	\
	PTHREAD_MUTEX_DEFAULT,	\
	NULL,			\
	0,			\
	-1 }
#endif

static struct pthread_mutex malloc_lock[_MALLOC_MUTEXES] = {
	MALLOC_LOCK_INITIALIZER(0),
	MALLOC_LOCK_INITIALIZER(1),
	MALLOC_LOCK_INITIALIZER(2),
	MALLOC_LOCK_INITIALIZER(3)
};

static pthread_mutex_t malloc_mutex[_MALLOC_MUTEXES] = {
	&malloc_lock[0],
	&malloc_lock[1],
	&malloc_lock[2],
	&malloc_lock[3]
};

void
_thread_malloc_lock(int i)
{
	pthread_mutex_lock(&malloc_mutex[i]);
}

void
_thread_malloc_unlock(int i)
{
	pthread_mutex_unlock(&malloc_mutex[i]);
}

void
_thread_malloc_reinit(void)
{
	int i;

	for (i = 0; i < _MALLOC_MUTEXES; i++) {
		malloc_lock[i].lock = _SPINLOCK_UNLOCKED;
#ifndef FUTEX
		TAILQ_INIT(&malloc_lock[i].lockers);
#endif
		malloc_lock[i].owner = NULL;
		malloc_lock[i].count = 0;
	}
}

/*
 * atexit lock
 */
static _atomic_lock_t atexit_lock = _SPINLOCK_UNLOCKED;

void
_thread_atexit_lock(void)
{
	_spinlock(&atexit_lock);
}

void
_thread_atexit_unlock(void)
{
	_spinunlock(&atexit_lock);
}

/*
 * atfork lock
 */
static _atomic_lock_t atfork_lock = _SPINLOCK_UNLOCKED;

void
_thread_atfork_lock(void)
{
	_spinlock(&atfork_lock);
}

void
_thread_atfork_unlock(void)
{
	_spinunlock(&atfork_lock);
}

/*
 * arc4random lock
 */
static _atomic_lock_t arc4_lock = _SPINLOCK_UNLOCKED;

void
_thread_arc4_lock(void)
{
	_spinlock(&arc4_lock);
}

void
_thread_arc4_unlock(void)
{
	_spinunlock(&arc4_lock);
}
@


1.17
log
@Get rid of ticket support, replace "struct _spinlock" with "_atomic_lock_t".

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.16 2016/09/01 10:56:46 deraadt Exp $ */
d155 1
d162 9
a170 1
	-1 }			\
d178 1
d205 1
d207 1
@


1.16
log
@delete wrong cvs $ tags
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.15 2016/09/01 10:41:02 otto Exp $ */
d194 1
a194 1
		malloc_lock[i].lock = _SPINLOCK_UNLOCKED_ASSIGN;
d204 1
a204 1
static struct _spinlock atexit_lock = _SPINLOCK_UNLOCKED;
d221 1
a221 1
static struct _spinlock atfork_lock = _SPINLOCK_UNLOCKED;
d238 1
a238 1
static struct _spinlock arc4_lock = _SPINLOCK_UNLOCKED;
a250 1

@


1.15
log
@Less lock contention by using more pools for mult-threaded programs.
tested by many (thanks!) ok tedu, guenther@@
@
text
@d1 1
a1 2
/* $OpenBSD: rthread_libc.c,v 1.14 2016/05/07 19:05:22 guenther Exp $ */
/* $snafu: libc_tag.c,v 1.4 2004/11/30 07:00:06 marc Exp $ */
@


1.14
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.13 2016/01/27 08:40:05 kettenis Exp $ */
d156 19
a174 7
static struct pthread_mutex malloc_lock = {
	_SPINLOCK_UNLOCKED,
	TAILQ_HEAD_INITIALIZER(malloc_lock.lockers),
	PTHREAD_MUTEX_DEFAULT,
	NULL,
	0,
	-1
a175 1
static pthread_mutex_t malloc_mutex = &malloc_lock;
d178 1
a178 1
_thread_malloc_lock(void)
d180 1
a180 1
	pthread_mutex_lock(&malloc_mutex);
d184 1
a184 1
_thread_malloc_unlock(void)
d186 1
a186 1
	pthread_mutex_unlock(&malloc_mutex);
d192 8
a199 4
	malloc_lock.lock = _SPINLOCK_UNLOCKED_ASSIGN;
	TAILQ_INIT(&malloc_lock.lockers);
	malloc_lock.owner = NULL;
	malloc_lock.count = 0;
@


1.13
log
@Replace the malloc spinlock with a mutex.  This lock is held over system calls
which run for many cycles and may even sleep.  This leads to other threads
spinning for a long time waiting on the lock.  Using a mutex means those
threads go to sleep and get woken up when the lock is released, which results
in a lot less CPU usage.  More work is needed to improve the performance of
threaded code that suffers from malloc lock contention, but this diff makes
ports like Firefox significantly more usable.

Tested by many.

ok mpi@@, guenther@@, tedu@@, jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.12 2015/04/07 01:27:07 guenther Exp $ */
d15 1
@


1.12
log
@Make pthread_atfork() track the DSO that called it like atexit() does,
unregistering callbacks if the DSO is unloaded.  Move the callback
handling from libpthread to libc, though libpthread still overrides the
inner call to handle locking and thread-library reinitialization.
Major version bump for both libc and libpthread.

verification that this fixes various ports ajacoutot@@
asm assistance miod@@; ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.11 2013/06/01 20:47:40 tedu Exp $ */
d155 9
a163 1
static struct _spinlock malloc_lock = _SPINLOCK_UNLOCKED;
d168 1
a168 1
	_spinlock(&malloc_lock);
d174 10
a183 1
	_spinunlock(&malloc_lock);
@


1.11
log
@cleanup and consolidate the spinlock_lock (what a name!) code.
it's now atomic_lock to better reflect its usage, and librthread now
features a new spinlock that's really a ticket lock.
thrlseep can handle both types of lock via a flag in the clock arg.
(temp back compat hack)
remove some old stuff that's accumulated along the way and no longer used.
some feedback from dlg, who is concerned with all things ticket lock.
(you need to boot a new kernel before installing librthread)
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.10 2012/04/17 15:10:11 miod Exp $ */
d184 17
@


1.10
log
@Remove "#define _POSIX_THREADS" line before include <pthread.h>.
The latter contains "#define _POSIX_THREADS 1" which makes gcc 2.95 complain.
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.9 2011/12/05 04:02:03 guenther Exp $ */
d155 1
a155 1
static _spinlock_lock_t malloc_lock = _SPINLOCK_UNLOCKED;
d172 1
a172 1
static _spinlock_lock_t atexit_lock = _SPINLOCK_UNLOCKED;
d189 1
a189 1
static _spinlock_lock_t arc4_lock = _SPINLOCK_UNLOCKED;
@


1.9
log
@Implement cancelation for the basic syscall cancelation points,
using previously allocated SIGTHR to interrupt in-process syscalls
and fixing the spelling of "cancelled" along the way.
Modeled on FreeBSD's libthr
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.8 2011/11/06 11:48:59 guenther Exp $ */
a4 2

#define _POSIX_THREADS
@


1.8
log
@Move <machine/spinlock.h> into rthread.h; strip out unnecessary #includes
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.7 2008/06/13 21:18:43 otto Exp $ */
a204 189
#if 0
/*
 * miscellaneous libc exported symbols we want to override
 */
int
close(int fd)
{
	int rv;

	pthread_testcancel();
	rv = _thread_sys_close(fd);
	pthread_testcancel();
	return (rv);
}

#if 0
/* libc calls open */
int
creat(const char *path, mode_t mode)
{

}
#endif

#if 0
int
fcntl(int fd, int cmd, ...)
{
	va_list ap;
	int rv;

	pthread_testcancel();
	va_start(ap, cmd);
	rv = _thread_sys_fcntl(fd, cmd, va_arg(cmd, void *));
	va_end(ap);
	pthread_testcancel();
	return (rv);
}
#endif

int
fsync(int fd)
{
	int rv;

	pthread_testcancel();
	rv = _thread_sys_fsync(fd);
	pthread_testcancel();
	return (rv);
}

int
msync(void *addr, size_t len, int flags)
{
	int rv;

	pthread_testcancel();
	rv =  _thread_sys_msync(addr, len, flags);
	pthread_testcancel();
	return (rv);
}

int
nanosleep(const struct timespec *rqtp, struct timespec *rmtp)
{
	int rv;

	pthread_testcancel();
	rv = _thread_sys_nanosleep(rqtp, rmtp);
	pthread_testcancel();
	return (rv);
}

#if 0
int
open(const char *path, int flags, ...)
{

	va_list ap;
	int rv;

	pthread_testcancel();
	va_start(ap, cmd);
	rv = _thread_sys_open(fd, cmd, va_arg(cmd, mode_t));
	va_end(ap);
	pthread_testcancel();
	return (rv);
}
#endif

#if 0
int
pause(void)
{

}
#endif

ssize_t
read(int fd, void *buf, size_t nbytes)
{
	ssize_t rv;

	pthread_testcancel();
	rv = read(fd, buf, nbytes);
	pthread_testcancel();
	return (rv);
}

#if 0
int
sigwaitinfo()
{

}
#endif

int
sigsuspend(const sigset_t *sigmask)
{
	int rv;

	pthread_testcancel();
	rv = sigsuspend(sigmask);
	pthread_testcancel();
	return (rv);
}

#if 0
/* libc sleep(3) calls nanosleep(2), so we'll catch it there */
unsigned int
sleep(unsigned int seconds)
{

}
#endif

#if 0
int system(const char *string)
{

}
#endif

#if 0
int
tcdrain(int fd)
{

}
#endif

#if 0
/* wait and waitpid will be handled by libc calling wait4 */
pid_t
wait(int *status)
{

}

pid_t
waitpid(pid_t wpid, int *status, int options)
{

}
#endif

pid_t
wait4(pid_t wpid, int *status, int options, struct rusage *rusage)
{
	pid_t rv;

	pthread_testcancel();
	rv = _thread_sys_wait4(wpid, status, options, rusage);
	pthread_testcancel();
	return (rv);
}

ssize_t
write(int fd, const void *buf, size_t nbytes)
{
	ssize_t rv;

	pthread_testcancel();
	rv = _thread_sys_write(fd, buf, nbytes);
	pthread_testcancel();
	return (rv);
}
#endif
@


1.7
log
@remove _MALLOC_LOCK_INIT; major bump; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.6 2008/01/23 02:20:24 kurt Exp $ */
a8 2

#include <machine/spinlock.h>
@


1.6
log
@- add missing libc locking functions for _thread_atexit_lock() and
  _thread_atexit_unlock(). okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.5 2008/01/01 00:43:39 kurt Exp $ */
a170 5
}

void
_thread_malloc_init(void)
{
@


1.5
log
@- make arc4random*() functions thread safe. Use a custom spinlock function
instead of the generic pthread macros since free(3) uses __arc4_getbyte()
when freeing small sized allocations and the generic pthread macros call
malloc(3).
- eliminate passing pointers to a static variable with global scope (rs)
for additional code clarity and reduction.
- shlib minor bumps for libc and libpthread due to new functions.
From andreas@@ with some bits from me. okay tedu@@ marc@@ w/some spot
checking from millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.4 2007/06/05 18:11:49 kurt Exp $ */
d176 17
@


1.4
log
@_FD_LOCK/UNLOCK() is libpthread specific and not needed for librthread, so
isolate its usage to libpthread only and replace with generic non-static
mutex support in the one place it is needed:
 - remove _FD_LOCK/UNLOCK from lseek and ftruncate in libc and make the
   functions weak so that libpthread can override with its own new
   versions that do the locking.
 - remove _thread_fd_lock/unlock() weak functions from libc and adjust
   libpthread for the change.
 - add generic _thread_mutex_lock/unlock/destroy() weak functions in libc
   to support non-static mutexes in libc and add libpthread and librthread
   implementations for them. libc can utilize non-static mutexes via the
   new _MUTEX_LOCK/UNLOCK/DESTROY() macros. Actually these new macros can
   support both static and non-static mutexes but currently only using
   them for non-static.
 - make opendir/closedir/readdir/readdir_r/seekdir/telldir() thread-safe
   for both thread libraries by using a non-static mutex in the struct
   _dirdesc (typedef DIR), utilizing it in the *dir functions and remove
   remaining and incorrect _FD_LOCK/UNLOCK() use in libc.
 - add comments to both thread libraries to indicate libc depends on the
   current implementation of static mutex initialization. suggested by
   marc@@
 - major bump libc and libpthread due to function removal, structure
   change and weak symbol conversions.
okay marc@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.3 2006/10/27 02:41:24 tedu Exp $ */
d176 17
@


1.3
log
@two comment typos from tbert
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.2 2006/01/05 04:24:30 tedu Exp $ */
d127 27
@


1.2
log
@move malloc lock to libc interface file
@
text
@d1 1
a1 1
/* $OpenBSD: rthread_libc.c,v 1.1 2006/01/05 04:06:48 marc Exp $ */
d99 1
a99 1
 * is no date for this thread initialize it from 'storage'.
d150 190
@


1.1
log
@
add -Wstrict-prototypes -Wmissing-prototypes -Wsign-compare
Minor tweaks to compile with the above, primarily in fixing
the conflicts between semaphore.h and rthread.h
"i like the additional warnings" tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d127 22
@

