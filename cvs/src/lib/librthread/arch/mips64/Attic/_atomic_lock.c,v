head	1.9;
access;
symbols
	OPENBSD_6_1:1.8.0.14
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.4.0.16
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.14
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.12
	OPENBSD_5_0:1.4.0.10
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.8
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.6
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.12
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.10
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.8
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.6
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.4
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2017.09.05.02.40.55;	author guenther;	state dead;
branches;
next	1.8;
commitid	5DW3WOQF0YGGx8lJ;

1.8
date	2014.04.18.15.09.52;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.03.16.19.45;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.01.20.47.40;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2013.05.06.00.23.49;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.01.23.17.53;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.02.15.17.48.58;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.05.22.33.24;	author marc;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.24.12.01.26;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Move mutex, condvar, and thread-specific data routes, pthread_once, and
pthread_exit from libpthread to libc, along with low-level bits to
support them.  Major bump to both libc and libpthread.

Requested by libressl team.  Ports testing by naddy@@
ok kettenis@@
@
text
@/*	$OpenBSD: _atomic_lock.c,v 1.8 2014/04/18 15:09:52 guenther Exp $	*/

/*
 * Atomic lock for mips
 * Written by Miodrag Vallat <miod@@openbsd.org> - placed in the public domain.
 */

#include <machine/spinlock.h>

int
_atomic_lock(volatile _atomic_lock_t *lock)
{
	_atomic_lock_t old;

	__asm__ volatile (
	".set	noreorder\n"
	"1:	ll	%0,	0(%1)\n"
	"	sc	%2,	0(%1)\n"
	"	beqz	%2,	1b\n"
	"	 addi	%2,	$0, %3\n"
	".set	reorder\n"
		: "=&r"(old)
		: "r"(lock), "r"(_ATOMIC_LOCK_LOCKED), "i"(_ATOMIC_LOCK_LOCKED)
		: "memory");

	return (old != _ATOMIC_LOCK_UNLOCKED);
}
@


1.8
log
@It's been a quarter century: we can assume volatile is present with that name.
@
text
@d1 1
a1 1
/*	$OpenBSD: _atomic_lock.c,v 1.7 2013/06/03 16:19:45 miod Exp $	*/
@


1.7
log
@unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: _atomic_lock.c,v 1.6 2013/06/01 20:47:40 tedu Exp $	*/
d15 1
a15 1
	__asm__ __volatile__ (
@


1.6
log
@cleanup and consolidate the spinlock_lock (what a name!) code.
it's now atomic_lock to better reflect its usage, and librthread now
features a new spinlock that's really a ticket lock.
thrlseep can handle both types of lock via a flag in the clock arg.
(temp back compat hack)
remove some old stuff that's accumulated along the way and no longer used.
some feedback from dlg, who is concerned with all things ticket lock.
(you need to boot a new kernel before installing librthread)
@
text
@d1 1
a1 1
/*	$OpenBSD: _atomic_lock.c,v 1.5 2013/05/06 00:23:49 guenther Exp $	*/
d23 1
a23 1
		: "r"(lock), "r"(_ATOMIC_LOCK_LOCKED), "i"(_SPINLOCK_LOCKED)
@


1.5
log
@If the lock is contended, such that the 'sc' fails, then we need to
reset the %2 register with _SPINLOCK_LOCKED before retrying.

tobiasu@@ hit the problem and figured out that ".set noreorder" is
needed in the ASM
@
text
@d1 1
a1 1
/*	$OpenBSD: _atomic_lock.c,v 1.4 2009/06/01 23:17:53 miod Exp $	*/
d8 1
a8 1
#include "spinlock.h"
d11 1
a11 1
_atomic_lock(volatile _spinlock_lock_t *lock)
d13 1
a13 1
	_spinlock_lock_t old;
d23 1
a23 1
		: "r"(lock), "r"(_SPINLOCK_LOCKED), "i"(_SPINLOCK_LOCKED)
d26 1
a26 1
	return (old != _SPINLOCK_UNLOCKED);
@


1.4
log
@A much better atomic lock routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: _atomic_lock.c,v 1.2 2009/02/15 17:48:58 deraadt Exp $	*/
d16 1
d20 5
a24 3
	"	 nop\n" :
		"=r"(old) :
		"r"(lock), "r"(_SPINLOCK_LOCKED) : "memory");
@


1.3
log
@these are public domain, verified with author;  spotted by jj
@
text
@d1 1
a1 3
/*	$OpenBSD: _atomic_lock.c,v 1.2 2006/01/05 22:33:24 marc Exp $	*/

/* Public domain.  Written by David Loenard */
d5 1
d8 1
a8 1
#include <spinlock.h>
a13 1
	_spinlock_lock_t temp;
d15 7
a21 22
	do {
		/*
		 * On a mips2 machine and above, we can use ll/sc.
		 * Read the lock and tag the cache line with a 'load linked'
		 * instruction. (Register 17 (LLAddr) will hold the 
		 * physical address of lock for diagnostic purposes);
		 * (Under pathologically heavy swapping, the physaddr may 
		 * change! XXX)
		 */
		__asm__("ll %0, %1" : "=r"(old) : "m"(*lock));
		if (old != _SPINLOCK_UNLOCKED) 
			break; /* already locked */
		/*
		 * Try and store a 1 at the tagged lock address.  If
		 * anyone else has since written it, the tag on the cache
		 * line will have been wiped, and temp will be set to zero
		 * by the 'store conditional' instruction.
		 */
		temp = _SPINLOCK_LOCKED;
		__asm__("sc  %0, %1" : "=r"(temp), "=m"(*lock)
				     : "0"(temp));
	} while (temp == _SPINLOCK_UNLOCKED);
@


1.2
log
@
Use the system include <spinlock.h> to get the proper function
prototype for _atomic_lock
@
text
@d1 4
a4 1
/*	$OpenBSD: _atomic_lock.c,v 1.1 2005/12/24 12:01:26 miod Exp $	*/
@


1.1
log
@mips64 support code for librthread (_atomic_lock yanked from existing
libpthread code).
@
text
@d1 1
a1 1
/*	$OpenBSD: _atomic_lock.c,v 1.1 2004/08/11 17:41:34 pefo Exp $	*/
d6 1
a6 1
#include <machine/spinlock.h>
@

