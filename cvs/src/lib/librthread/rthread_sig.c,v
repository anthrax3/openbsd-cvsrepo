head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.8
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.4.0.10
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.8
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.6
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.4
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4;
locks; strict;
comment	@ * @;


1.18
date	2016.05.07.19.05.22;	author guenther;	state Exp;
branches;
next	1.17;
commitid	d9R7VGw9CHTkwXE1;

1.17
date	2015.10.23.04.39.24;	author guenther;	state Exp;
branches;
next	1.16;
commitid	OrVNAJkzchWBNbO0;

1.16
date	2014.11.16.05.24.25;	author guenther;	state Exp;
branches;
next	1.15;
commitid	196whQE3UsyDrvWh;

1.15
date	2013.06.21.06.08.50;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2012.11.10.07.22.11;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2012.04.13.08.25.37;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.17.02.34.18;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2011.12.27.17.36.59;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2011.12.05.04.02.03;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.06.11.48.59;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.27.19.43.55;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.20.02.38.57;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.03.04.22.37;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.24.11.44.26;	author kurt;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.30.04.05.55;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.19.06.50.13;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.13.06.04.53;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.03.18.16.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@/*	$OpenBSD: rthread_sig.c,v 1.17 2015/10/23 04:39:24 guenther Exp $ */
/*
 * Copyright (c) 2005 Ted Unangst <tedu@@openbsd.org>
 * All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * signals
 */

#include <signal.h>
#include <errno.h>

#include <pthread.h>

#include "rthread.h"
#include "cancel.h"		/* in libc/include */

int
sigwait(const sigset_t *set, int *sig)
{
	sigset_t s = *set;
	int ret;

	sigdelset(&s, SIGTHR);
	do {
		ENTER_CANCEL_POINT(1);
		ret = __thrsigdivert(s, NULL, NULL);
		LEAVE_CANCEL_POINT(ret == -1);
	} while (ret == -1 && errno == EINTR);
	if (ret == -1)
		return (errno);
	*sig = ret;
	return (0);
}

#if 0		/* need kernel to fill in more siginfo_t bits first */
int
sigwaitinfo(const sigset_t *set, siginfo_t *info)
{
	sigset_t s = *set;
	int ret;

	sigdelset(&s, SIGTHR);
	ENTER_CANCEL_POINT(1);
	ret = __thrsigdivert(s, info, NULL);
	LEAVE_CANCEL_POINT(ret == -1);
	return (ret);
}

int
sigtimedwait(const sigset_t *set, siginfo_t *info,
    const struct timespec *timeout)
{
	sigset_t s = *set;
	int ret;

	sigdelset(&s, SIGTHR);
	ENTER_CANCEL_POINT(1);
	ret = __thrsigdivert(s, info, timeout);
	LEAVE_CANCEL_POINT(ret == -1);
	return (ret);
}
#endif
@


1.17
log
@Merge the sigaction() and sigprocmask() overloads/wrappers from libpthread
into libc, and move pthread_sigmask() as well (just a trivial wrapper).
This provides consistent handling of SIGTHR between single- and multi-threaded
programs and is a step in the merge of all the libpthread overloads, providing
some ASM and Makefile bits that the other wrappers will need.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.16 2014/11/16 05:24:25 guenther Exp $ */
d28 1
a32 1
	pthread_t self = pthread_self();
d38 1
a38 1
		_enter_cancel(self);
d40 1
a40 1
		_leave_cancel(self);
a51 1
	pthread_t self = pthread_self();
d56 1
a56 1
	_enter_cancel(self);
d58 1
a58 1
	_leave_cancel(self);
a65 1
	pthread_t self = pthread_self();
d70 1
a70 1
	_enter_cancel(self);
d72 1
a72 1
	_leave_cancel(self);
@


1.16
log
@Don't assume __thrsigdivert() autorestarts on EINTR.  This lets us check for
cancellation properly when a handled (but not waited for) signal occurs

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.15 2013/06/21 06:08:50 guenther Exp $ */
a29 19
pthread_sigmask(int how, const sigset_t *set, sigset_t *oset)
{
	return (sigprocmask(how, set, oset) ? errno : 0);
}

int
sigprocmask(int how, const sigset_t *set, sigset_t *oset)
{
	sigset_t s;

	if (set != NULL && how != SIG_UNBLOCK && sigismember(set, SIGTHR)) {
		s = *set;
		sigdelset(&s, SIGTHR);
		set = &s;
	}
	return (_thread_sys_sigprocmask(how, set, oset));
}

int
a77 17

int
sigaction(int sig, const struct sigaction *act, struct sigaction *oact)
{
	struct sigaction sa;

	if (sig == SIGTHR) {
		errno = EINVAL;
		return (-1);
	}
	if (act != NULL && sigismember(&act->sa_mask, SIGTHR)) {
		sa = *act;
		sigdelset(&sa.sa_mask, SIGTHR);
		act = &sa;
	}
	return (_thread_sys_sigaction(sig, act, oact));
}
@


1.15
log
@Move the declaration of _thread_sys_sigprocmask() to rthread.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.14 2012/11/10 07:22:11 guenther Exp $ */
d56 5
a60 3
	_enter_cancel(self);
	ret = __thrsigdivert(s, NULL, NULL);
	_leave_cancel(self);
@


1.14
log
@raise() is now correctly defined in libc
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.13 2012/04/13 08:25:37 guenther Exp $ */
a27 2

int	_thread_sys_sigprocmask(int, const sigset_t *, sigset_t *);
@


1.13
log
@Add sigwaitinfo and sigtimedwait stubs under #if 0; a bit more kernel
support is needed before they can be usefully enabled but I don't want
to misplace this diff yet again
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.12 2012/01/17 02:34:18 guenther Exp $ */
a94 8
}
#endif

#if 0		/* belongs in libc */
int
raise(int sig)
{
	return (kill(getthrid(), sig));
@


1.12
log
@Reimplement mutexes, condvars, and rwlocks to eliminate bugs,
particularly the "consume the signal you just sent" hang, and putting
the wait queues in userspace.

Do cancellation handling in pthread_cond_*wait(), pthread_join(),
and sem_wait().

Add __ prefix to thr{sleep,wakeup,exit,sigdivert}() syscalls; add
'abort" argument to thrsleep to close cancellation race; make
thr{sleep,wakeup} return errno values via *retval to avoid touching
userspace errno.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.11 2011/12/27 17:36:59 guenther Exp $ */
d66 39
@


1.11
log
@Don't let applications block, wait for, or handle SIGTHR, as the
thread library uses it internally for cancellation.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.10 2011/12/05 04:02:03 guenther Exp $ */
d59 1
a59 1
	ret = thrsigdivert(s, NULL, NULL);
@


1.10
log
@Implement cancelation for the basic syscall cancelation points,
using previously allocated SIGTHR to interrupt in-process syscalls
and fixing the spelling of "cancelled" along the way.
Modeled on FreeBSD's libthr
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.9 2011/11/06 11:48:59 guenther Exp $ */
d29 2
d38 13
d54 1
d57 1
d59 1
a59 1
	ret = thrsigdivert(*set, NULL, NULL);
d67 16
@


1.9
log
@Move <machine/spinlock.h> into rthread.h; strip out unnecessary #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.8 2009/11/27 19:43:55 guenther Exp $ */
d38 1
d41 1
d43 1
d45 1
a45 1
		return errno;
d47 1
a47 1
	return 0;
@


1.8
log
@Convert thrsigdivert to (almost) be sigtimedwait by adding siginfo_t
and struct timespec * argument.  sigtimedwait is just a one line
wrapper after this.

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.7 2009/02/20 02:38:57 guenther Exp $ */
a21 8
#include <sys/param.h>
#include <sys/mman.h>
#include <sys/wait.h>

#include <machine/spinlock.h>

#include <stdlib.h>
#include <unistd.h>
a22 2
#include <stdio.h>
#include <string.h>
@


1.7
log
@thrsigdivert() takes a sigset_t, not a pointer to one.  Detected by
finally reading the lint warnings (sigh)

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.6 2008/10/03 04:22:37 guenther Exp $ */
d50 1
a50 1
	ret = thrsigdivert(*set);
d56 1
@


1.6
log
@Make sigwait() work correctly.  In particular, it'll work when the
signal is already pending in the calling thread or the main thread
and there's no longer a race condition where the signal could be
diverted but sigwait() would still block.  There were some off-by-one
errors too.

(The checking of the main thread's pending list is just until a
pending list for the process can be added to struct process.  For
now, such signals end up as pending on the main thread.)

oks tedu@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.5 2008/04/24 11:44:26 kurt Exp $ */
d50 1
a50 1
	ret = thrsigdivert(set);
@


1.5
log
@Return the proper values upon failure per POSIX for pthread_sigmask(3) and
sigprocmask(2) in threaded programs.

From Philip Guenther <guenther at sendmail.com> via PR library/5795.
okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.4 2005/12/30 04:05:55 tedu Exp $ */
a44 19
/* 
 * implementation of sigwait:
 * 1.  we install a handler for each masked signal.
 * 2.  we inform the kernel we are interested in this signal set.
 * 3.  sleep.  the handler will wake us up.
 *
 * this is atomic because the kernel will only divert one signal
 * to a thread until it asks for more.
 */
static void
sigwait_handler(int sig)
{
	pthread_t self = pthread_self();
	self->sigpend = sig;
	thrwakeup(&self->sigpend, 0);
}

typedef void (*sigfn)(int);

d48 7
a54 19
	int i;
	sigset_t mask = *set;
	pthread_t self = pthread_self();
	sigfn oldhandlers[NSIG];

	for (i = 0; i < NSIG; i++) {
		if (mask & (1 << i))
			oldhandlers[i] = signal(i, sigwait_handler);
	}

	thrsigdivert(set);
	thrsleep(&self->sigpend, 0, NULL);

	for (i = 0; i < NSIG; i++) {
		if (mask & (1 << i))
			signal(i, oldhandlers[i]);
	}
	*sig = self->sigpend;
	return (0);
@


1.4
log
@prototype all the thread syscalls in rthread.h for now.
update for new thrwakeup that takes a count argument
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.3 2005/12/19 06:50:13 tedu Exp $ */
d42 1
a42 1
	return (sigprocmask(how, set, oset));
@


1.3
log
@this file didn't exist in 2004, so copyright must be 2005
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.2 2005/12/13 06:04:53 tedu Exp $ */
a38 4
int thrwakeup(void *);
int thrsleep(void *, int, void *);
int thrsigdivert(const sigset_t *);

d59 1
a59 1
	thrwakeup(&self->sigpend);
@


1.2
log
@update thrsleep and thrwakeup - first arg changed from long to void *
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_sig.c,v 1.1 2005/12/03 18:16:19 tedu Exp $ */
d3 1
a3 1
 * Copyright (c) 2004 Ted Unangst <tedu@@openbsd.org>
@


1.1
log
@add userland thread library.  incomplete, but functional
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d39 2
a40 2
int thrwakeup(long);
int thrsleep(long, int, void *);
d63 1
a63 1
	thrwakeup((long)&self->sigpend);
d82 1
a82 1
	thrsleep((long)&self->sigpend, 0, NULL);
@

