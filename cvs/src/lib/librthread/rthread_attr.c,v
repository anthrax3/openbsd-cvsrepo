head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.20.0.4
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.12
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.10
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.6
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.4
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.2
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.12
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.10
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.8
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8;
locks; strict;
comment	@ * @;


1.22
date	2016.05.07.19.05.22;	author guenther;	state Exp;
branches;
next	1.21;
commitid	d9R7VGw9CHTkwXE1;

1.21
date	2016.04.02.19.56.53;	author guenther;	state Exp;
branches;
next	1.20;
commitid	8mfZyQLsoIGIAaFG;

1.20
date	2014.08.09.03.29.35;	author guenther;	state Exp;
branches;
next	1.19;
commitid	zJK2PUOG5534og9W;

1.19
date	2012.03.22.15.26.04;	author kurt;	state Exp;
branches;
next	1.18;

1.18
date	2012.03.20.04.16.20;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2012.03.02.23.11.57;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2012.02.19.06.53.58;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2012.02.19.02.07.48;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2012.02.18.22.03.21;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2012.02.18.21.50.27;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2012.02.18.21.12.09;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2012.02.18.07.44.28;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.06.11.48.59;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2008.10.13.05.42.46;	author kevlo;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.05.08.15.16;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.05.04.06.48;	author marc;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.04.08.48.02;	author marc;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.01.19.32.30;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.31.08.51.20;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.19.06.47.40;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.19.06.45.14;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.03.18.16.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@/*	$OpenBSD: rthread_attr.c,v 1.21 2016/04/02 19:56:53 guenther Exp $ */
/*
 * Copyright (c) 2004,2005 Ted Unangst <tedu@@openbsd.org>
 * All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * generic attribute support
 */

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

#include <pthread.h>
#include <pthread_np.h>

#include "rthread.h"

/*
 * Note: stack_size + guard_size == total stack used
 *
 * pthread_attr_init MUST be called before any other attribute function
 * for proper operation.
 *
 * Every call to pthread_attr_init MUST be matched with a call to
 * pthread_attr_destroy to avoid leaking memory.   This is an implementation
 * requirement, not a POSIX requirement.
 */

int
pthread_attr_init(pthread_attr_t *attrp)
{
	pthread_attr_t attr;

	/* make sure _rthread_attr_default has been initialized */
	if (!_threads_ready)
		_rthread_init();

	attr = calloc(1, sizeof(*attr));
	if (!attr)
		return (errno);
	*attr = _rthread_attr_default;
	*attrp = attr;

	return (0);
}

int
pthread_attr_destroy(pthread_attr_t *attrp)
{
	free(*attrp);
	*attrp = NULL;

	return (0);
}

int
pthread_attr_getguardsize(const pthread_attr_t *attrp, size_t *guardsize)
{
	*guardsize = (*attrp)->guard_size;

	return (0);
}

int
pthread_attr_setguardsize(pthread_attr_t *attrp, size_t guardsize)
{
	(*attrp)->guard_size = guardsize;

	return (0);
}

int
pthread_attr_getdetachstate(const pthread_attr_t *attrp, int *detachstate)
{
	*detachstate = (*attrp)->detach_state;

	return (0);
}

int
pthread_attr_setdetachstate(pthread_attr_t *attrp, int detachstate)
{
	int error;

	error = (detachstate == PTHREAD_CREATE_DETACHED ||
		  detachstate == PTHREAD_CREATE_JOINABLE) ? 0 : EINVAL;
	if (error == 0)
		(*attrp)->detach_state = detachstate;

	return (error);
}

int
pthread_attr_getstack(const pthread_attr_t *attrp, void **stackaddr,
    size_t *stacksize)
{
	*stackaddr = (*attrp)->stack_addr;
	*stacksize = (*attrp)->stack_size;

	return (0);
}

int
pthread_attr_setstack(pthread_attr_t *attrp, void *stackaddr, size_t stacksize)
{
	int error;

	/*
	 * XXX Add an alignment test, on stackaddr for stack-grows-up
	 * archs or on stackaddr+stacksize for stack-grows-down archs
	 */
	if (stacksize < PTHREAD_STACK_MIN)
		return (EINVAL);
	if ((error = pthread_attr_setstackaddr(attrp, stackaddr)))
		return (error);
	(*attrp)->stack_size = stacksize;

	return (0);
}

int
pthread_attr_getstacksize(const pthread_attr_t *attrp, size_t *stacksize)
{
	*stacksize = (*attrp)->stack_size;
	
	return (0);
}

int
pthread_attr_setstacksize(pthread_attr_t *attrp, size_t stacksize)
{
	if (stacksize < PTHREAD_STACK_MIN ||
	    stacksize > ROUND_TO_PAGE(stacksize))
		return (EINVAL);
	(*attrp)->stack_size = stacksize;

	return (0);
}

int
pthread_attr_getstackaddr(const pthread_attr_t *attrp, void **stackaddr)
{
	*stackaddr = (*attrp)->stack_addr;

	return (0);
}

int
pthread_attr_setstackaddr(pthread_attr_t *attrp, void *stackaddr)
{
	if (stackaddr == NULL || (uintptr_t)stackaddr & (_thread_pagesize - 1))
		return (EINVAL);
	(*attrp)->stack_addr = stackaddr;

	return (0);
}
DEF_NONSTD(pthread_attr_setstackaddr);

int
pthread_attr_getscope(const pthread_attr_t *attrp, int *contentionscope)
{
	*contentionscope = (*attrp)->contention_scope;

	return (0);
}

int
pthread_attr_setscope(pthread_attr_t *attrp, int contentionscope)
{
	if (contentionscope != PTHREAD_SCOPE_SYSTEM &&
	    contentionscope != PTHREAD_SCOPE_PROCESS)
		return (EINVAL);
	(*attrp)->contention_scope = contentionscope;

	return (0);
}

@


1.21
log
@Wrap <pthread.h> and <pthread_np.h> to eliminate PLT entries for internal
references.  Use _thread_pagesize for the semaphore mmap size instead of
calling getpagesize() each time.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.20 2014/08/09 03:29:35 guenther Exp $ */
a46 1
	int error;
d50 1
a50 2
		if ((error = _rthread_init()))
			return (error);
@


1.20
log
@Only need <stdint.h> and not <inttypes.h> here
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.19 2012/03/22 15:26:04 kurt Exp $ */
d173 1
@


1.19
log
@Remove pthread_suspend* and related functions. This is part of the
rthreads major library bump from last night. okay kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.18 2012/03/20 04:16:20 guenther Exp $ */
d22 1
a22 1
#include <inttypes.h>
@


1.18
log
@Clean up unnecessary prototypes.  Pointed out by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.17 2012/03/02 23:11:57 fgsch Exp $ */
a189 7
	return (0);
}

int
pthread_attr_setcreatesuspend_np(pthread_attr_t *attr)
{
	(*attr)->create_suspended = 1;
@


1.17
log
@fix check when setting the contention scope. harmless atm but still wrong.
guenther@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.16 2012/02/19 06:53:58 guenther Exp $ */
a30 6

/*
 * temp: these need to be added to pthread.h
 */
int	pthread_attr_getguardsize(const pthread_attr_t *, size_t *);
int	pthread_attr_setguardsize(pthread_attr_t *, size_t);
@


1.16
log
@Fix problems revealed by regress/lib/libpthread/stack/stack.c
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.15 2012/02/19 02:07:48 guenther Exp $ */
d191 1
a191 1
	if (contentionscope != PTHREAD_SCOPE_SYSTEM ||
@


1.15
log
@Validate in pthread_attr_set{scope,sched{param,policy},inheritsched}()
the requested new value
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.14 2012/02/18 22:03:21 guenther Exp $ */
d53 6
d120 1
a153 5
	int error;

	if (!_threads_ready)
		if ((error = _rthread_init()))
			return (error);
a172 5
	int error;

	if (!_threads_ready)
		if ((error = _rthread_init()))
			return (error);
@


1.14
log
@Fix previous commit: _rthread_init() was static.
Improve consistency of error naming
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.13 2012/02/18 21:50:27 guenther Exp $ */
d194 3
a196 1
	/* XXX contentionscope should be validated here */
@


1.13
log
@Before using _thread_pagesize, make sure _rthread_init() has been called
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.12 2012/02/18 21:12:09 guenther Exp $ */
d85 1
a85 1
	return 0;
d99 1
a99 1
	int retval;
d101 1
a101 1
	retval = (detachstate == PTHREAD_CREATE_DETACHED ||
d103 1
a103 1
	if (retval == 0)
d106 1
a106 1
	return (retval);
d121 1
a121 1
	int n;
d129 2
a130 2
	if ((n = pthread_attr_setstackaddr(attrp, stackaddr)))
		return (n);
d147 2
d150 2
a151 1
		_rthread_init();
d171 2
d174 2
a175 1
		_rthread_init();
d177 1
a177 1
		return EINVAL;
@


1.12
log
@Fix the handling of the stackaddr, stacksize, and guardsize attributes:
don't try to merge values, round the sizes separately, and don't try to
unmap application-supplied stacks.
Copy from uthread the caching of default-sized stacks.
Have pthread_attr_init() and pthread_create() get the default attributes
from staticly allocated pthread_attr_t.
Cache the pagesize in _rthread_init() and provide a macro for rounding to it

based on suggestions from kettenis@@ and tedu@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.11 2012/02/18 07:44:28 guenther Exp $ */
d147 2
d168 2
@


1.11
log
@Initialize the scope, policy, and inherit members in pthread_attr_init()
so that their pthread_attr_get* don't return bogus values.

issue noted and tested by aja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.10 2011/11/06 11:48:59 guenther Exp $ */
d57 1
a57 7
	attr->stack_size = RTHREAD_STACK_SIZE_DEF;
	attr->guard_size = sysconf(_SC_PAGESIZE);
	attr->stack_size -= attr->guard_size;
	attr->detach_state = PTHREAD_CREATE_JOINABLE;
	attr->contention_scope = PTHREAD_SCOPE_SYSTEM;
	attr->sched_policy = SCHED_OTHER;
	attr->sched_inherit = PTHREAD_INHERIT_SCHED;
d83 1
a83 5
	if ((*attrp)->guard_size != guardsize) {
		(*attrp)->stack_size += (*attrp)->guard_size;
		(*attrp)->guard_size = guardsize;
		(*attrp)->stack_size -= (*attrp)->guard_size;
	}
a113 1
	*stacksize = (*attrp)->stack_size + (*attrp)->guard_size;
d123 6
a131 1
	(*attrp)->stack_size -= (*attrp)->guard_size;
d139 1
a139 1
	*stacksize = (*attrp)->stack_size + (*attrp)->guard_size;
d147 3
a150 4
	if ((*attrp)->stack_size > (*attrp)->guard_size)
		(*attrp)->stack_size -= (*attrp)->guard_size;
	else
		(*attrp)->stack_size = 0;
d166 1
a166 5
	size_t pgsz = sysconf(_SC_PAGESIZE);

	if (pgsz == (size_t)-1)
		return EINVAL;
	if ((uintptr_t)stackaddr & (pgsz - 1))
@


1.10
log
@Move <machine/spinlock.h> into rthread.h; strip out unnecessary #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.9 2008/10/13 05:42:46 kevlo Exp $ */
d61 3
@


1.9
log
@use calloc() instead of malloc() and memset()

"look good" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.8 2006/01/05 08:15:16 otto Exp $ */
a21 6
#include <sys/param.h>
#include <sys/mman.h>
#include <sys/wait.h>

#include <machine/spinlock.h>

a24 3
#include <signal.h>
#include <stdio.h>
#include <string.h>
@


1.8
log
@Remove redundant mprotect() calls (we're unmapping the region anyway)
and check user stack for proper alignment.  ok tedu@@ marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.7 2006/01/05 04:06:48 marc Exp $ */
d63 1
a63 1
	attr = malloc(sizeof(*attr));
a65 1
	memset(attr, 0, sizeof(*attr));
@


1.7
log
@
add -Wstrict-prototypes -Wmissing-prototypes -Wsign-compare
Minor tweaks to compile with the above, primarily in fixing
the conflicts between semaphore.h and rthread.h
"i like the additional warnings" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.6 2006/01/04 08:48:02 marc Exp $ */
d28 1
d139 4
a142 1
	(*attrp)->stack_addr = stackaddr;
d180 6
@


1.6
log
@
allow threads to be created in a detached state
do not allow a join to a detached thread
"it looks good" otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.5 2006/01/01 19:32:30 marc Exp $ */
d36 1
d39 6
@


1.5
log
@
thread stack handling changes.  Add guard zones and allow stack
size (and guard zone size) to be set using pthread_attr.   Guard
zones are specified in bytes, but implemented in terms of a
page size.

OK Otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.4 2005/12/31 08:51:20 otto Exp $ */
d62 1
d108 1
a108 2
	/* XXX detachstate should be validated here */
	(*attrp)->detach_state = detachstate;
d110 6
a115 1
	return (0);
@


1.4
log
@Implement suspend/resume and creation of initially suspended threads.
With this, java seems to be operational.  Also make threads_ready
non-static, which is needed for an upcoming diff.  ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.3 2005/12/19 06:47:40 tedu Exp $ */
d39 11
d59 3
d77 20
d107 1
d118 1
a118 1
	*stacksize = (*attrp)->stack_size;
d128 1
d136 2
a137 2
	*stacksize = (*attrp)->stack_size;

d145 4
d180 1
@


1.3
log
@update copyright to 2005
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.2 2005/12/19 06:45:14 tedu Exp $ */
d144 8
@


1.2
log
@add pthread_get/set_concurrency (useless for now)
add pthread_get/set_stack[addr] (info not used yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_attr.c,v 1.1 2005/12/03 18:16:19 tedu Exp $ */
d3 1
a3 1
 * Copyright (c) 2004 Ted Unangst <tedu@@openbsd.org>
@


1.1
log
@add userland thread library.  incomplete, but functional
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d79 19
a102 1

d109 16
@

