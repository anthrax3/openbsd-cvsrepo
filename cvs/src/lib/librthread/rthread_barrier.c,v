head	1.3;
access;
symbols
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.6
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.2.0.14
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.16
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.8
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.12
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.3
date	2016.04.15.17.54.17;	author tedu;	state Exp;
branches;
next	1.2;
commitid	umGhJIHgJSbCXeBU;

1.2
date	2012.04.23.08.30.33;	author pirofti;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.11.10.18.46;	author pirofti;	state Exp;
branches;
next	;


desc
@@


1.3
log
@make pthread_barrier_wait behave more like it does on other platforms.
from Kari Tristan Helgason
@
text
@/*	$OpenBSD: rthread_barrier.c,v 1.2 2012/04/23 08:30:33 pirofti Exp $	*/
/*
 * Copyright (c) 2012 Paul Irofti <pirofti@@openbsd.org>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <stdlib.h>

#include <pthread.h>

#include "rthread.h"

int
pthread_barrier_init(pthread_barrier_t *barrier, pthread_barrierattr_t *attr,
    unsigned int count) {
	int rc = 0;
	pthread_barrier_t b = NULL;

	if (barrier == NULL)
		return (EINVAL);

	if (attr != NULL) {
		if (*attr == NULL)
			return (EINVAL);

		if ((*attr)->pshared != PTHREAD_PROCESS_PRIVATE)
			return (ENOTSUP);
	}

	b = calloc(1, sizeof *b);
	if (b == NULL)
		return (ENOMEM);

	if ((rc = pthread_mutex_init(&b->mutex, NULL)))
		goto err;
	if ((rc = pthread_cond_init(&b->cond, NULL)))
		goto err;

	b->threshold = count;

	*barrier = b;

	return (0);

err:
	if (b) {
		if (b->mutex)
			pthread_mutex_destroy(&b->mutex);
		if (b->cond)
			pthread_cond_destroy(&b->cond);
		free(b);
	}

	return (rc);
}

int
pthread_barrier_destroy(pthread_barrier_t *barrier)
{
	int rc;
	pthread_barrier_t b;

	if (barrier == NULL || *barrier == NULL)
		return (EINVAL);

	if ((rc = pthread_mutex_lock(&(*barrier)->mutex)))
		return (rc);

	b = *barrier;

	if (b->out > 0 || b->in > 0) {
		pthread_mutex_unlock(&b->mutex);
		return (EBUSY);
	}

	*barrier = NULL;
	pthread_mutex_unlock(&b->mutex);
	pthread_mutex_destroy(&b->mutex);
	pthread_cond_destroy(&b->cond);
	free(b);
	return (0);
}

int
pthread_barrier_wait(pthread_barrier_t *barrier)
{
	pthread_barrier_t b;
	int rc, old_state, gen;
	int done = 0;

	if (barrier == NULL || *barrier == NULL)
		return (EINVAL);

	if ((rc = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &old_state)))
		return (rc);

	b = *barrier;
	if ((rc = pthread_mutex_lock(&b->mutex)))
		goto cancel;

	_rthread_debug(6, "in: %d, threshold: %d\n", b->in, b->threshold);
	if (++b->in == b->threshold) {
		b->out = b->in - 1;
		b->in = 0;
		b->generation++;
		if ((rc = pthread_cond_signal(&b->cond)))
			goto err;
		done = 1;
		_rthread_debug(6, "threshold reached\n");
	} else {
		gen = b->generation;
		_rthread_debug(6, "waiting on condition\n");
		do {
			if ((rc = pthread_cond_wait(&b->cond, &b->mutex)))
				goto err;
		} while (gen == b->generation);
		b->out--; /* mark thread exit */
		if ((rc = pthread_cond_signal(&b->cond)))
			goto err;
	}

err:
	if ((rc = pthread_mutex_unlock(&b->mutex)))
		return (rc);
cancel:
	rc = pthread_setcancelstate(old_state, NULL);
	if (rc == 0 && done)
		rc = PTHREAD_BARRIER_SERIAL_THREAD;

	return (rc);
}
@


1.2
log
@Honor subsystem style.

`Visual inspection looks ok' kurt@@.

>From Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_barrier.c,v 1.1 2012/04/11 10:18:46 pirofti Exp $	*/
d72 1
d78 3
d83 2
a84 1
	if (b->sofar > 0)
d86 1
d89 1
d113 4
a116 3
	_rthread_debug(6, "sofar: %d, threshold: %d\n", b->sofar, b->threshold);
	if (++b->sofar == b->threshold) {
		b->sofar = 0;
d118 1
a118 1
		if ((rc = pthread_cond_broadcast(&b->cond)))
d129 3
@


1.1
log
@Add pthread barrier support.

Implementation and documentation for:
 - pthread_barrier_init()
 - pthread_barrier_destroy()
 - pthread_barrier_wait()
 - pthread_barrierattr_init()
 - pthread_barrierattr_destroy()
 - pthread_barrierattr_getpshared()
 - pthread_barrierattr_setpshared()

Currently only private barriers are supported.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 3
a33 3
	if (barrier == NULL) {
		return EINVAL;
	}
d35 5
a39 6
		if (*attr == NULL) {
			return EINVAL;
		}
		if ((*attr)->pshared != PTHREAD_PROCESS_PRIVATE) {
			return ENOTSUP;
		}
d43 2
a44 3
	if (b == NULL) {
		return ENOMEM;
	}
d46 1
a46 1
	if ((rc = pthread_mutex_init(&b->mutex, NULL))) {
d48 1
a48 2
	}
	if ((rc = pthread_cond_init(&b->cond, NULL))) {
a49 1
	}
d55 1
a55 1
	return 0;
d59 1
a59 1
		if (b->mutex) {
d61 1
a61 2
		}
		if (b->cond) {
a62 1
		}
d65 2
a66 1
	return rc;
d74 2
a75 3
	if (barrier == NULL || *barrier == NULL) {
		return EINVAL;
	}
d79 2
a80 3
	if (b->sofar > 0) {
		return EBUSY;
	}
d86 1
a86 1
	return 0;
d96 2
a97 3
	if (barrier == NULL || *barrier == NULL) {
		return EINVAL;
	}
d99 2
a100 3
	if ((rc = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &old_state))) {
		return rc;
	}
d103 1
a103 1
	if ((rc = pthread_mutex_lock(&b->mutex))) {
a104 1
	}
d110 1
a110 1
		if ((rc = pthread_cond_broadcast(&b->cond))) {
a111 1
		}
d118 1
a118 1
			if ((rc = pthread_cond_wait(&b->cond, &b->mutex))) {
a119 1
			}
d124 2
a125 3
	if ((rc = pthread_mutex_unlock(&b->mutex))) {
		return rc;
	}
d128 1
a128 1
	if (rc == 0 && done) {
d130 2
a131 2
	}
	return rc;
@

