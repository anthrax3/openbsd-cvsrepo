head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.6
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.1.0.8
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.09.04.10.13.35;	author akfaew;	state Exp;
branches;
next	1.18;
commitid	tPNEomz2X1xlRc3u;

1.18
date	2016.09.01.10.41.02;	author otto;	state Exp;
branches;
next	1.17;
commitid	HatwrthzJhfQpDr7;

1.17
date	2016.05.07.19.05.22;	author guenther;	state Exp;
branches;
next	1.16;
commitid	d9R7VGw9CHTkwXE1;

1.16
date	2016.04.02.19.00.51;	author guenther;	state Exp;
branches;
next	1.15;
commitid	HcJGR3mYEiomHNg2;

1.15
date	2016.01.27.08.40.05;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	mL5c06Fqgo0x5wfa;

1.14
date	2015.10.18.08.02.58;	author guenther;	state Exp;
branches;
next	1.13;
commitid	lDpsAqCZ03zHaXJb;

1.13
date	2015.05.19.20.50.06;	author guenther;	state Exp;
branches;
next	1.12;
commitid	9XB6auZflgiDfN67;

1.12
date	2015.05.10.18.33.15;	author guenther;	state Exp;
branches;
next	1.11;
commitid	DJrEhfkYnXxo41SD;

1.11
date	2015.04.07.01.27.07;	author guenther;	state Exp;
branches;
next	1.10;
commitid	oQvh7XA3Kql35r0J;

1.10
date	2013.11.29.16.27.40;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.25.22.51.46;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.21.06.50.49;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.01.20.47.40;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.22.23.43.32;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.22.22.34.57;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.06.11.48.59;	author guenther;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.27.19.42.24;	author guenther;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.21.15.32.01;	author guenther;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.05.21.06.11;	author kurt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Get rid of ticket support, replace "struct _spinlock" with "_atomic_lock_t".

ok tedu@@
@
text
@/*	$OpenBSD: rthread_fork.c,v 1.18 2016/09/01 10:41:02 otto Exp $ */

/*
 * Copyright (c) 2008 Kurt Miller <kurt@@openbsd.org>
 * Copyright (c) 2008 Philip Guenther <guenther@@openbsd.org>
 * Copyright (c) 2003 Daniel Eischen <deischen@@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: /repoman/r/ncvs/src/lib/libc_r/uthread/uthread_atfork.c,v 1.1 2004/12/10 03:36:45 grog Exp $
 */

#ifndef NO_PIC
#include <sys/types.h>
#include <sys/exec_elf.h>
#pragma weak _DYNAMIC
#endif

#include <errno.h>
#include <pthread.h>
#include <stdlib.h>
#include <tib.h>
#include <unistd.h>

#include "thread_private.h"	/* in libc/include */

#include "rthread.h"
#include "rthread_cb.h"

/* make {fork,vfork,getthrid} call _thread_sys_{fork,vfork,getthrid} */
REDIRECT_SYSCALL(fork);
REDIRECT_SYSCALL(vfork);
REDIRECT_SYSCALL(getthrid);

static pid_t
_dofork(pid_t (*sys_fork)(void))
{
	pthread_t me;
	pid_t newid;
	int i;

	if (!_threads_ready)
		return sys_fork();

	me = pthread_self();

	/*
	 * Protect important libc/ld.so critical areas across the fork call.
	 * dlclose() will grab the atexit lock via __cxa_finalize() so lock
	 * the dl_lock first. malloc()/free() can use arc4random(), so lock
	 * malloc_lock before arc4_lock
	 */

#ifndef NO_PIC
	if (_DYNAMIC)
		_rthread_dl_lock(0);
#endif

	_thread_atexit_lock();
	for (i = 0; i < _MALLOC_MUTEXES; i++)
		_thread_malloc_lock(i);
	_thread_arc4_lock();

	newid = sys_fork();

	_thread_arc4_unlock();
	if (newid == 0)
		_thread_malloc_reinit();
	else
		for (i = 0; i < _MALLOC_MUTEXES; i++)
			_thread_malloc_unlock(i);
	_thread_atexit_unlock();

	if (newid == 0) {
		struct tib *tib = me->tib;
#ifndef NO_PIC
		/* reinitialize the lock in the child */
		if (_DYNAMIC)
			_rthread_dl_lock(2);
#endif
		/* update this thread's structure */
		tib->tib_tid = getthrid();
		me->donesem.lock = _SPINLOCK_UNLOCKED;
		me->flags_lock = _SPINLOCK_UNLOCKED;

		/* reinit the thread list */
		LIST_INIT(&_thread_list);
		LIST_INSERT_HEAD(&_thread_list, me, threads);
		_thread_lock = _SPINLOCK_UNLOCKED;

		/* single threaded now */
		__isthreaded = 0;
	}
#ifndef NO_PIC
	else if (_DYNAMIC)
		_rthread_dl_lock(1);
#endif
	return newid;
}

pid_t
_thread_fork(void)
{
	return _dofork(&fork);
}

pid_t
_thread_vfork(void)
{
	return _dofork(&vfork);
}
@


1.18
log
@Less lock contention by using more pools for mult-threaded programs.
tested by many (thanks!) ok tedu, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.17 2016/05/07 19:05:22 guenther Exp $ */
d103 2
a104 2
		me->donesem.lock = _SPINLOCK_UNLOCKED_ASSIGN;
		me->flags_lock = _SPINLOCK_UNLOCKED_ASSIGN;
d109 1
a109 1
		_thread_lock = _SPINLOCK_UNLOCKED_ASSIGN;
@


1.17
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.16 2016/04/02 19:00:51 guenther Exp $ */
d60 1
d80 2
a81 1
	_thread_malloc_lock();
d90 2
a91 1
		_thread_malloc_unlock();
@


1.16
log
@Eliminate the need to explicitly invoke syscalls via their _thread_sys_*
aliases by using a macro REDIRECT_SYSCALL() to map the symbols.  Apply
that to getthrid(), sysctl(), and issetugid() as well.

ok mpi@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.15 2016/01/27 08:40:05 kettenis Exp $ */
d42 1
d48 1
d50 3
d55 2
a56 6
pid_t   _thread_sys_fork(void);
pid_t   _thread_sys_vfork(void);
pid_t	_dofork(int);

pid_t
_dofork(int is_vfork)
a58 1
	pid_t (*sys_fork)(void);
a60 2
	sys_fork = is_vfork ? &_thread_sys_vfork : &_thread_sys_fork;

d92 1
d99 1
a99 1
		me->tid = getthrid();
a100 1
		me->flags &= ~THREAD_DETACHED;
a102 3
		/* this thread is the initial thread for the new process */
		me->flags |= THREAD_ORIGINAL;

d121 1
a121 1
	return _dofork(0);
d125 1
a125 1
vfork(void)
d127 1
a127 1
	return _dofork(1);
@


1.15
log
@Replace the malloc spinlock with a mutex.  This lock is held over system calls
which run for many cycles and may even sleep.  This leads to other threads
spinning for a long time waiting on the lock.  Using a mutex means those
threads go to sleep and get woken up when the lock is released, which results
in a lot less CPU usage.  More work is needed to improve the performance of
threaded code that suffers from malloc lock contention, but this diff makes
ports like Firefox significantly more usable.

Tested by many.

ok mpi@@, guenther@@, tedu@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.14 2015/10/18 08:02:58 guenther Exp $ */
d47 2
@


1.14
log
@ld.so no longer needs or uses a bind lock, so stop setting it.  This
eliminates a chunk of complexity from the libpthread init and the fork
wrapper, as it was the bind lock that needed prebinding before use.
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.13 2015/05/19 20:50:06 guenther Exp $ */
d85 4
a88 1
	_thread_malloc_unlock();
@


1.13
log
@Instead of testing for __ELF__ and/or vax, leave out the bits for interfacing
with ld.so locking whenever building NOPIC

pointless use of __ELF__ noted by brad@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.12 2015/05/10 18:33:15 guenther Exp $ */
a42 1
#include <signal.h>
a57 3
#ifndef NO_PIC
	sigset_t nmask, omask;
#endif
d69 2
a70 3
	 * the dl_lock first. malloc()/free() can grab the arc4 lock so lock
	 * malloc_lock first. Finally lock the bind_lock last so that any lazy
	 * binding in the other locking functions can succeed.
a81 8
#ifndef NO_PIC
	if (_DYNAMIC) {
		sigfillset(&nmask);
		_thread_sys_sigprocmask(SIG_BLOCK, &nmask, &omask);
		_rthread_bind_lock(0);
	}
#endif

a82 7

#ifndef NO_PIC
	if (_DYNAMIC) {
		_rthread_bind_lock(1);
		_thread_sys_sigprocmask(SIG_SETMASK, &omask, NULL);
	}
#endif
@


1.12
log
@In the child after fork, the dl lock has to be forced as its inner spinlock
may have been grabbed by another thread in the parent before the fork

problem report from dcoppa@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.11 2015/04/07 01:27:07 guenther Exp $ */
d33 1
a33 1
#if defined(__ELF__)
d59 1
a59 1
#if defined(__ELF__)
d78 1
a78 1
#if defined(__ELF__)
d87 1
a87 1
#if defined(__ELF__)
d97 1
a97 1
#if defined(__ELF__)
d109 1
a109 1
#if defined(__ELF__)
d131 1
a131 1
#if defined(__ELF__)
@


1.11
log
@Make pthread_atfork() track the DSO that called it like atexit() does,
unregistering callbacks if the DSO is unloaded.  Move the callback
handling from libpthread to libc, though libpthread still overrides the
inner call to handle locking and thread-library reinitialization.
Major version bump for both libc and libpthread.

verification that this fixes various ports ajacoutot@@
asm assistance miod@@; ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.10 2013/11/29 16:27:40 guenther Exp $ */
d108 1
d110 3
a112 2
	if (_DYNAMIC)
		_rthread_dl_lock(1);
a113 2

	if (newid == 0) {
d131 4
@


1.10
log
@Don't try to reuse _initial_thread in the fork() wrapper, as the
thread's existing handle must continue to be valid and it didn't
fully 'change' the thread handle anyway.  For pthread_main_np(),
use a new flag, THREAD_ORIGINAL, to indicate that the flagged thread
is the original thread for *this* process.

Fixes some ConsoleKit failures according to aja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.9 2013/06/25 22:51:46 guenther Exp $ */
d5 1
a5 1
 * Copyright (c) 2008 Philip Guenther <guenther@@gmail.com>
a48 12
struct rthread_atfork {
	TAILQ_ENTRY(rthread_atfork) next;
	void (*prepare)(void);
	void (*parent)(void);
	void (*child)(void);
};

static TAILQ_HEAD(atfork_listhead, rthread_atfork) _atfork_list =
    TAILQ_HEAD_INITIALIZER(_atfork_list);

static struct _spinlock _atfork_lock = _SPINLOCK_UNLOCKED;

d135 1
a135 1
fork(void)
d137 1
a137 19
	struct rthread_atfork *p;
	pid_t newid;

	_spinlock(&_atfork_lock);
	TAILQ_FOREACH_REVERSE(p, &_atfork_list, atfork_listhead, next)
		if (p->prepare)
			p->prepare();
	newid = _dofork(0);
	if (newid == 0) {
		TAILQ_FOREACH(p, &_atfork_list, next)
			if (p->child)
				p->child();
	} else {
		TAILQ_FOREACH(p, &_atfork_list, next)
			if (p->parent)
				p->parent();
	}
	_spinunlock(&_atfork_lock);
	return newid;
a143 18
}

int
pthread_atfork(void (*prepare)(void), void (*parent)(void),
    void (*child)(void))
{
	struct rthread_atfork *af;

	if ((af = malloc(sizeof *af)) == NULL)
		return (ENOMEM);

	af->prepare = prepare;
	af->parent = parent;
	af->child = child;
	_spinlock(&_atfork_lock);
	TAILQ_INSERT_TAIL(&_atfork_list, af, next);
	_spinunlock(&_atfork_lock);
	return (0);
@


1.9
log
@nmask and omask only used on ELF.  Noted by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.8 2013/06/21 06:50:49 guenther Exp $ */
d133 1
a133 1
		_initial_thread = *me;
d137 1
a137 1
		LIST_INSERT_HEAD(&_thread_list, &_initial_thread, threads);
@


1.8
log
@The bind lock must only be grabbed with all signals masked.

backtrace of example case from sthen@@
ok kettenis@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.7 2013/06/01 20:47:40 tedu Exp $ */
d71 1
d73 1
@


1.7
log
@cleanup and consolidate the spinlock_lock (what a name!) code.
it's now atomic_lock to better reflect its usage, and librthread now
features a new spinlock that's really a ticket lock.
thrlseep can handle both types of lock via a flag in the clock arg.
(temp back compat hack)
remove some old stuff that's accumulated along the way and no longer used.
some feedback from dlg, who is concerned with all things ticket lock.
(you need to boot a new kernel before installing librthread)
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.6 2012/08/22 23:43:32 matthew Exp $ */
d43 1
d71 1
d98 3
a100 1
	if (_DYNAMIC)
d102 1
d108 1
a108 1
	if (_DYNAMIC)
d110 2
@


1.6
log
@We want to check that the dynamic linker is available at run-time, so
we should actually check for _DYNAMIC at run-time rather than checking
for __PIC__ at compile time, since the two are actually independent.

Problem and solution identified by guenther; minor tweaks by me.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.5 2012/08/22 22:34:57 matthew Exp $ */
d58 1
a58 1
static _spinlock_lock_t _atfork_lock = _SPINLOCK_UNLOCKED;
d119 1
a119 1
		me->donesem.lock = _SPINLOCK_UNLOCKED;
d121 1
a121 1
		me->flags_lock = _SPINLOCK_UNLOCKED;
d129 1
a129 1
		_thread_lock = _SPINLOCK_UNLOCKED;
@


1.5
log
@Test for __PIC__ instead of PIC in preparation for eliminating -DPIC
from bsd.lib.mk for C source files.

ok deraadt, pascal
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.4 2011/11/06 11:48:59 guenther Exp $ */
d33 6
d86 3
a88 2
#if defined(__ELF__) && defined(__PIC__)
	_rthread_dl_lock(0);
d95 3
a97 2
#if defined(__ELF__) && defined(__PIC__)
	_rthread_bind_lock(0);
d102 3
a104 2
#if defined(__ELF__) && defined(__PIC__)
	_rthread_bind_lock(1);
d111 3
a113 2
#if defined(__ELF__) && defined(__PIC__)
	_rthread_dl_lock(1);
@


1.4
log
@Move <machine/spinlock.h> into rthread.h; strip out unnecessary #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.3 2009/11/27 19:42:24 guenther Exp $ */
d80 1
a80 1
#if defined(__ELF__) && defined(PIC)
d88 1
a88 1
#if defined(__ELF__) && defined(PIC)
d94 1
a94 1
#if defined(__ELF__) && defined(PIC)
d102 1
a102 1
#if defined(__ELF__) && defined(PIC)
@


1.3
log
@Change threxit() to take a pointer to a pid_t to zero out from the
kernel so that librthread can detect when a thread is completely
done with its stack without need a kqueue.  The dying thread moves
itself to a GC list, other threads scan the GC list on pthread_create()
and pthread_join() and free the stack and handle once the thread's
thread id is zeroed.

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.2 2009/10/21 15:32:01 guenther Exp $ */
a31 4

#include <sys/param.h>

#include <machine/spinlock.h>
@


1.2
log
@After forking, the child is single threaded, so tell libc that.  This
is needed to avoid deadlocks in popen() on FILE locking.

ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_fork.c,v 1.1 2008/06/05 21:06:11 kurt Exp $ */
a110 3
		if (_rthread_open_kqueue())
			_exit(126);	/* XXX */

@


1.1
log
@- Add fork/vfork wrapper functions to reset state in the child process.
- Make an effort to protect important libc and ld.so critical areas during
the fork(2)/vfork(2) sys call.
- Add pthread_atfork(3) implementation based on Daniel Eischen's code.

Original diff by Philip Guenther <guenther at gmail.com> with some
additions and refinements by me. Positive test report from brad@@ with
many kde apps. fork(2) and pthread_atfork(3) pthread regresses pass.
okay tedu@@, kettenis@@, marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d127 3
@

