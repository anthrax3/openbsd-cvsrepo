head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.32
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.28
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.24
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.26
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.18
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.22
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.38
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.34
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.32
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.30
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.28
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.26
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.24
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.22
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.20
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.18
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.16
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.14
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.12
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.10
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.8
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	2010.01.12.23.22.05;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.22.18.01.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.08.22.46.58;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.19.03.53.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.16.45.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.10.01.35.02;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.02.22.06.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.11.28.17.49.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.03.15.19.12.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.06.23.27;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.09.39;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/* lib_color.c
 *
 * Handles color emulation of SYS V curses
 */

#include <curses.priv.h>

#include <term.h>
#include <tic.h>

MODULE_ID("$Id: lib_color.c,v 1.85 2007/04/07 17:07:28 tom Exp $")

/*
 * These should be screen structure members.  They need to be globals for
 * historical reasons.  So we assign them in start_color() and also in
 * set_term()'s screen-switching logic.
 */
#if USE_REENTRANT
NCURSES_EXPORT(int)
NCURSES_PUBLIC_VAR(COLOR_PAIRS) (void)
{
    return SP ? SP->_pair_count : -1;
}
NCURSES_EXPORT(int)
NCURSES_PUBLIC_VAR(COLORS) (void)
{
    return SP ? SP->_color_count : -1;
}
#else
NCURSES_EXPORT_VAR(int) COLOR_PAIRS = 0;
NCURSES_EXPORT_VAR(int) COLORS = 0;
#endif

#define DATA(r,g,b) {r,g,b, 0,0,0, 0}

#define TYPE_CALLOC(type,elts) typeCalloc(type, (unsigned)(elts))

#define MAX_PALETTE	8

#define OkColorHi(n)	(((n) < COLORS) && ((n) < max_colors))
#define InPalette(n)	((n) >= 0 && (n) < MAX_PALETTE)

/*
 * Given a RGB range of 0..1000, we'll normally set the individual values
 * to about 2/3 of the maximum, leaving full-range for bold/bright colors.
 */
#define RGB_ON  680
#define RGB_OFF 0
/* *INDENT-OFF* */
static const color_t cga_palette[] =
{
    /*  R               G               B */
    DATA(RGB_OFF,	RGB_OFF,	RGB_OFF),	/* COLOR_BLACK */
    DATA(RGB_ON,	RGB_OFF,	RGB_OFF),	/* COLOR_RED */
    DATA(RGB_OFF,	RGB_ON,		RGB_OFF),	/* COLOR_GREEN */
    DATA(RGB_ON,	RGB_ON,		RGB_OFF),	/* COLOR_YELLOW */
    DATA(RGB_OFF,	RGB_OFF,	RGB_ON),	/* COLOR_BLUE */
    DATA(RGB_ON,	RGB_OFF,	RGB_ON),	/* COLOR_MAGENTA */
    DATA(RGB_OFF,	RGB_ON,		RGB_ON),	/* COLOR_CYAN */
    DATA(RGB_ON,	RGB_ON,		RGB_ON),	/* COLOR_WHITE */
};

static const color_t hls_palette[] =
{
    /*  	H       L       S */
    DATA(	0,	0,	0),		/* COLOR_BLACK */
    DATA(	120,	50,	100),		/* COLOR_RED */
    DATA(	240,	50,	100),		/* COLOR_GREEN */
    DATA(	180,	50,	100),		/* COLOR_YELLOW */
    DATA(	330,	50,	100),		/* COLOR_BLUE */
    DATA(	60,	50,	100),		/* COLOR_MAGENTA */
    DATA(	300,	50,	100),		/* COLOR_CYAN */
    DATA(	0,	50,	100),		/* COLOR_WHITE */
};
/* *INDENT-ON* */

#if NCURSES_EXT_FUNCS
/*
 * These are called from _nc_do_color(), which in turn is called from
 * vidattr - so we have to assume that SP may be null.
 */
static int
default_fg(void)
{
    return (SP != 0) ? SP->_default_fg : COLOR_WHITE;
}

static int
default_bg(void)
{
    return SP != 0 ? SP->_default_bg : COLOR_BLACK;
}
#else
#define default_fg() COLOR_WHITE
#define default_bg() COLOR_BLACK
#endif

/*
 * SVr4 curses is known to interchange color codes (1,4) and (3,6), possibly
 * to maintain compatibility with a pre-ANSI scheme.  The same scheme is
 * also used in the FreeBSD syscons.
 */
static int
toggled_colors(int c)
{
    if (c < 16) {
	static const int table[] =
	{0, 4, 2, 6, 1, 5, 3, 7,
	 8, 12, 10, 14, 9, 13, 11, 15};
	c = table[c];
    }
    return c;
}

static void
set_background_color(int bg, int (*outc) (int))
{
    if (set_a_background) {
	TPUTS_TRACE("set_a_background");
	tputs(TPARM_1(set_a_background, bg), 1, outc);
    } else {
	TPUTS_TRACE("set_background");
	tputs(TPARM_1(set_background, toggled_colors(bg)), 1, outc);
    }
}

static void
set_foreground_color(int fg, int (*outc) (int))
{
    if (set_a_foreground) {
	TPUTS_TRACE("set_a_foreground");
	tputs(TPARM_1(set_a_foreground, fg), 1, outc);
    } else {
	TPUTS_TRACE("set_foreground");
	tputs(TPARM_1(set_foreground, toggled_colors(fg)), 1, outc);
    }
}

static void
init_color_table(void)
{
    const color_t *tp;
    int n;

    tp = (hue_lightness_saturation) ? hls_palette : cga_palette;
    for (n = 0; n < COLORS; n++) {
	if (InPalette(n)) {
	    SP->_color_table[n] = tp[n];
	} else {
	    SP->_color_table[n] = tp[n % MAX_PALETTE];
	    if (hue_lightness_saturation) {
		SP->_color_table[n].green = 100;
	    } else {
		if (SP->_color_table[n].red)
		    SP->_color_table[n].red = 1000;
		if (SP->_color_table[n].green)
		    SP->_color_table[n].green = 1000;
		if (SP->_color_table[n].blue)
		    SP->_color_table[n].blue = 1000;
	    }
	}
    }
}

/*
 * Reset the color pair, e.g., to whatever color pair 0 is.
 */
static bool
reset_color_pair(void)
{
    bool result = FALSE;

    if (orig_pair != 0) {
	TPUTS_TRACE("orig_pair");
	putp(orig_pair);
	result = TRUE;
    }
    return result;
}

/*
 * Reset color pairs and definitions.  Actually we do both more to accommodate
 * badly-written terminal descriptions than for the relatively rare case where
 * someone has changed the color definitions.
 */
bool
_nc_reset_colors(void)
{
    int result = FALSE;

    T((T_CALLED("_nc_reset_colors()")));
    if (SP->_color_defs > 0)
	SP->_color_defs = -(SP->_color_defs);

    if (reset_color_pair())
	result = TRUE;
    if (orig_colors != 0) {
	TPUTS_TRACE("orig_colors");
	putp(orig_colors);
	result = TRUE;
    }
    returnBool(result);
}

NCURSES_EXPORT(int)
start_color(void)
{
    int result = ERR;

    T((T_CALLED("start_color()")));

    if (SP == 0) {
	result = ERR;
    } else if (SP->_coloron) {
	result = OK;
    } else {

	if (reset_color_pair() != TRUE) {
	    set_foreground_color(default_fg(), _nc_outch);
	    set_background_color(default_bg(), _nc_outch);
	}

	if (max_pairs > 0 && max_colors > 0) {
	    SP->_pair_count = max_pairs;
	    SP->_color_count = max_colors;
#if !USE_REENTRANT
	    COLOR_PAIRS = max_pairs;
	    COLORS = max_colors;
#endif

	    if ((SP->_color_pairs = TYPE_CALLOC(colorpair_t,
						max_pairs)) != 0) {
		if ((SP->_color_table = TYPE_CALLOC(color_t,
						    max_colors)) != 0) {
		    SP->_color_pairs[0] = PAIR_OF(default_fg(), default_bg());
		    init_color_table();

		    T(("started color: COLORS = %d, COLOR_PAIRS = %d",
		       COLORS, COLOR_PAIRS));

		    SP->_coloron = 1;
		    result = OK;
		} else if (SP->_color_pairs != 0) {
		    FreeAndNull(SP->_color_pairs);
		}
	    }
	} else {
	    result = OK;
	}
    }
    returnCode(result);
}

/* This function was originally written by Daniel Weaver <danw@@znyx.com> */
static void
rgb2hls(short r, short g, short b, short *h, short *l, short *s)
/* convert RGB to HLS system */
{
    short min, max, t;

    if ((min = g < r ? g : r) > b)
	min = b;
    if ((max = g > r ? g : r) < b)
	max = b;

    /* calculate lightness */
    *l = (min + max) / 20;

    if (min == max) {		/* black, white and all shades of gray */
	*h = 0;
	*s = 0;
	return;
    }

    /* calculate saturation */
    if (*l < 50)
	*s = ((max - min) * 100) / (max + min);
    else
	*s = ((max - min) * 100) / (2000 - max - min);

    /* calculate hue */
    if (r == max)
	t = 120 + ((g - b) * 60) / (max - min);
    else if (g == max)
	t = 240 + ((b - r) * 60) / (max - min);
    else
	t = 360 + ((r - g) * 60) / (max - min);

    *h = t % 360;
}

/*
 * Extension (1997/1/18) - Allow negative f/b values to set default color
 * values.
 */
NCURSES_EXPORT(int)
init_pair(short pair, short f, short b)
{
    colorpair_t result;

    T((T_CALLED("init_pair(%d,%d,%d)"), pair, f, b));

    if ((pair < 0) || (pair >= COLOR_PAIRS) || SP == 0 || !SP->_coloron)
	returnCode(ERR);
#if NCURSES_EXT_FUNCS
    if (SP->_default_color) {
	if (f < 0)
	    f = COLOR_DEFAULT;
	if (b < 0)
	    b = COLOR_DEFAULT;
	if (!OkColorHi(f) && !isDefaultColor(f))
	    returnCode(ERR);
	if (!OkColorHi(b) && !isDefaultColor(b))
	    returnCode(ERR);
    } else
#endif
    {
	if ((f < 0) || !OkColorHi(f)
	    || (b < 0) || !OkColorHi(b)
	    || (pair < 1))
	    returnCode(ERR);
    }

    /*
     * When a pair's content is changed, replace its colors (if pair was
     * initialized before a screen update is performed replacing original
     * pair colors with the new ones).
     */
    result = PAIR_OF(f, b);
    if (SP->_color_pairs[pair] != 0
	&& SP->_color_pairs[pair] != result) {
	int y, x;

	for (y = 0; y <= curscr->_maxy; y++) {
	    struct ldat *ptr = &(curscr->_line[y]);
	    bool changed = FALSE;
	    for (x = 0; x <= curscr->_maxx; x++) {
		if (GetPair(ptr->text[x]) == pair) {
		    /* Set the old cell to zero to ensure it will be
		       updated on the next doupdate() */
		    SetChar(ptr->text[x], 0, 0);
		    CHANGED_CELL(ptr, x);
		    changed = TRUE;
		}
	    }
	    if (changed)
		_nc_make_oldhash(y);
	}
    }
    SP->_color_pairs[pair] = result;
    if (GET_SCREEN_PAIR(SP) == pair)
	SET_SCREEN_PAIR(SP, (chtype) (~0));	/* force attribute update */

    if (initialize_pair && InPalette(f) && InPalette(b)) {
	const color_t *tp = hue_lightness_saturation ? hls_palette : cga_palette;

	TR(TRACE_ATTRS,
	   ("initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));

	TPUTS_TRACE("initialize_pair");
	putp(TPARM_7(initialize_pair,
		     pair,
		     tp[f].red, tp[f].green, tp[f].blue,
		     tp[b].red, tp[b].green, tp[b].blue));
    }

    returnCode(OK);
}

#define okRGB(n) ((n) >= 0 && (n) <= 1000)

NCURSES_EXPORT(int)
init_color(short color, short r, short g, short b)
{
    int result = ERR;

    T((T_CALLED("init_color(%d,%d,%d,%d)"), color, r, g, b));

    if (initialize_color != NULL
	&& SP != 0
	&& SP->_coloron
	&& (color >= 0 && OkColorHi(color))
	&& (okRGB(r) && okRGB(g) && okRGB(b))) {

	SP->_color_table[color].init = 1;
	SP->_color_table[color].r = r;
	SP->_color_table[color].g = g;
	SP->_color_table[color].b = b;

	if (hue_lightness_saturation) {
	    rgb2hls(r, g, b,
		    &SP->_color_table[color].red,
		    &SP->_color_table[color].green,
		    &SP->_color_table[color].blue);
	} else {
	    SP->_color_table[color].red = r;
	    SP->_color_table[color].green = g;
	    SP->_color_table[color].blue = b;
	}

	TPUTS_TRACE("initialize_color");
	putp(TPARM_4(initialize_color, color, r, g, b));
	SP->_color_defs = max(color + 1, SP->_color_defs);
	result = OK;
    }
    returnCode(result);
}

NCURSES_EXPORT(bool)
can_change_color(void)
{
    T((T_CALLED("can_change_color()")));
    returnCode((can_change != 0) ? TRUE : FALSE);
}

NCURSES_EXPORT(bool)
has_colors(void)
{
    T((T_CALLED("has_colors()")));
    returnCode((VALID_NUMERIC(max_colors) && VALID_NUMERIC(max_pairs)
		&& (((set_foreground != NULL)
		     && (set_background != NULL))
		    || ((set_a_foreground != NULL)
			&& (set_a_background != NULL))
		    || set_color_pair)) ? TRUE : FALSE);
}

NCURSES_EXPORT(int)
color_content(short color, short *r, short *g, short *b)
{
    int result;

    T((T_CALLED("color_content(%d,%p,%p,%p)"), color, r, g, b));
    if (color < 0 || !OkColorHi(color) || SP == 0 || !SP->_coloron) {
	result = ERR;
    } else {
	NCURSES_COLOR_T c_r = SP->_color_table[color].red;
	NCURSES_COLOR_T c_g = SP->_color_table[color].green;
	NCURSES_COLOR_T c_b = SP->_color_table[color].blue;

	if (r)
	    *r = c_r;
	if (g)
	    *g = c_g;
	if (b)
	    *b = c_b;

	TR(TRACE_ATTRS, ("...color_content(%d,%d,%d,%d)",
			 color, c_r, c_g, c_b));
	result = OK;
    }
    returnCode(result);
}

NCURSES_EXPORT(int)
pair_content(short pair, short *f, short *b)
{
    int result;

    T((T_CALLED("pair_content(%d,%p,%p)"), pair, f, b));

    if ((pair < 0) || (pair >= COLOR_PAIRS) || SP == 0 || !SP->_coloron) {
	result = ERR;
    } else {
	NCURSES_COLOR_T fg = ((SP->_color_pairs[pair] >> C_SHIFT) & C_MASK);
	NCURSES_COLOR_T bg = (SP->_color_pairs[pair] & C_MASK);

#if NCURSES_EXT_FUNCS
	if (fg == COLOR_DEFAULT)
	    fg = -1;
	if (bg == COLOR_DEFAULT)
	    bg = -1;
#endif

	if (f)
	    *f = fg;
	if (b)
	    *b = bg;

	TR(TRACE_ATTRS, ("...pair_content(%d,%d,%d)", pair, fg, bg));
	result = OK;
    }
    returnCode(result);
}

NCURSES_EXPORT(void)
_nc_do_color(short old_pair, short pair, bool reverse, int (*outc) (int))
{
    NCURSES_COLOR_T fg = COLOR_DEFAULT;
    NCURSES_COLOR_T bg = COLOR_DEFAULT;
    NCURSES_COLOR_T old_fg, old_bg;

    if (pair < 0 || pair >= COLOR_PAIRS) {
	return;
    } else if (pair != 0) {
	if (set_color_pair) {
	    TPUTS_TRACE("set_color_pair");
	    tputs(TPARM_1(set_color_pair, pair), 1, outc);
	    return;
	} else if (SP != 0) {
	    pair_content((short) pair, &fg, &bg);
	}
    }

    if (old_pair >= 0
	&& SP != 0
	&& pair_content(old_pair, &old_fg, &old_bg) != ERR) {
	if ((isDefaultColor(fg) && !isDefaultColor(old_fg))
	    || (isDefaultColor(bg) && !isDefaultColor(old_bg))) {
#if NCURSES_EXT_FUNCS
	    /*
	     * A minor optimization - but extension.  If "AX" is specified in
	     * the terminal description, treat it as screen's indicator of ECMA
	     * SGR 39 and SGR 49, and assume the two sequences are independent.
	     */
	    if (SP->_has_sgr_39_49
		&& isDefaultColor(old_bg)
		&& !isDefaultColor(old_fg)) {
		tputs("\033[39m", 1, outc);
	    } else if (SP->_has_sgr_39_49
		       && isDefaultColor(old_fg)
		       && !isDefaultColor(old_bg)) {
		tputs("\033[49m", 1, outc);
	    } else
#endif
		reset_color_pair();
	}
    } else {
	reset_color_pair();
	if (old_pair < 0)
	    return;
    }

#if NCURSES_EXT_FUNCS
    if (isDefaultColor(fg))
	fg = default_fg();
    if (isDefaultColor(bg))
	bg = default_bg();
#endif

    if (reverse) {
	NCURSES_COLOR_T xx = fg;
	fg = bg;
	bg = xx;
    }

    TR(TRACE_ATTRS, ("setting colors: pair = %d, fg = %d, bg = %d", pair,
		     fg, bg));

    if (!isDefaultColor(fg)) {
	set_foreground_color(fg, outc);
    }
    if (!isDefaultColor(bg)) {
	set_background_color(bg, outc);
    }
}
@


1.10
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.9 2000/10/08 22:46:58 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d47 1
a47 1
MODULE_ID("$From: lib_color.c,v 1.55 2000/12/10 02:43:27 tom Exp $")
d54 24
a77 4
NCURSES_EXPORT_VAR(int)
COLOR_PAIRS = 0;
NCURSES_EXPORT_VAR(int)
COLORS = 0;
d89 8
a96 8
    {RGB_OFF,		RGB_OFF,	RGB_OFF},	/* COLOR_BLACK */
    {RGB_ON,		RGB_OFF,	RGB_OFF},	/* COLOR_RED */
    {RGB_OFF,		RGB_ON,		RGB_OFF},	/* COLOR_GREEN */
    {RGB_ON,		RGB_ON,		RGB_OFF},	/* COLOR_YELLOW */
    {RGB_OFF,		RGB_OFF,	RGB_ON},	/* COLOR_BLUE */
    {RGB_ON,		RGB_OFF,	RGB_ON},	/* COLOR_MAGENTA */
    {RGB_OFF,		RGB_ON,		RGB_ON},	/* COLOR_CYAN */
    {RGB_ON,		RGB_ON,		RGB_ON},	/* COLOR_WHITE */
d101 9
a109 9
    /*  H       L       S */
    {	0,	0,	0},		/* COLOR_BLACK */
    {	120,	50,	100},		/* COLOR_RED */
    {	240,	50,	100},		/* COLOR_GREEN */
    {	180,	50,	100},		/* COLOR_YELLOW */
    {	330,	50,	100},		/* COLOR_BLUE */
    {	60,	50,	100},		/* COLOR_MAGENTA */
    {	300,	50,	100},		/* COLOR_CYAN */
    {	0,	50,	100},		/* COLOR_WHITE */
d118 2
a119 2
     static int
       default_fg(void)
d139 2
a140 2
     static int
       toggled_colors(int c)
d156 1
a156 1
	tputs(tparm(set_a_background, bg), 1, outc);
d159 1
a159 1
	tputs(tparm(set_background, toggled_colors(bg)), 1, outc);
d168 1
a168 1
	tputs(tparm(set_a_foreground, fg), 1, outc);
d171 27
a197 1
	tputs(tparm(set_foreground, toggled_colors(fg)), 1, outc);
d201 3
d205 1
a205 1
set_original_colors(void)
d207 2
d212 22
a233 2
	return TRUE;
    } else if (orig_colors != NULL) {
d236 1
a236 1
	return TRUE;
d238 1
a238 1
    return FALSE;
d244 1
a244 2
    int n;
    const color_t *tp;
d248 10
a257 4
    if (set_original_colors() != TRUE) {
	set_foreground_color(default_fg(), _nc_outch);
	set_background_color(default_bg(), _nc_outch);
    }
d259 7
a265 12
    if (VALID_NUMERIC(max_pairs))
	COLOR_PAIRS = SP->_pair_count = max_pairs;
    else
	returnCode(ERR);
    if ((SP->_color_pairs = typeCalloc(unsigned short, max_pairs)) == 0)
	  returnCode(ERR);
    SP->_color_pairs[0] = PAIR_OF(default_fg(), default_bg());
    if (VALID_NUMERIC(max_colors))
	COLORS = SP->_color_count = max_colors;
    else
	returnCode(ERR);
    SP->_coloron = 1;
d267 16
a282 6
    if ((SP->_color_table = typeMalloc(color_t, COLORS)) == 0)
	returnCode(ERR);
    tp = (hue_lightness_saturation) ? hls_palette : cga_palette;
    for (n = 0; n < COLORS; n++) {
	if (n < 8) {
	    SP->_color_table[n] = tp[n];
d284 1
a284 11
	    SP->_color_table[n] = tp[n % 8];
	    if (hue_lightness_saturation) {
		SP->_color_table[n].green = 100;
	    } else {
		if (SP->_color_table[n].red)
		    SP->_color_table[n].red = 1000;
		if (SP->_color_table[n].green)
		    SP->_color_table[n].green = 1000;
		if (SP->_color_table[n].blue)
		    SP->_color_table[n].blue = 1000;
	    }
d287 1
a287 4

    T(("started color: COLORS = %d, COLOR_PAIRS = %d", COLORS, COLOR_PAIRS));

    returnCode(OK);
d333 1
a333 2
init_pair
(short pair, short f, short b)
d335 1
a335 1
    unsigned result;
d339 1
a339 1
    if ((pair < 0) || (pair >= COLOR_PAIRS))
d344 1
a344 1
	    f = C_MASK;
d346 2
a347 2
	    b = C_MASK;
	if (f >= COLORS && f != C_MASK)
d349 1
a349 1
	if (b >= COLORS && b != C_MASK)
d354 2
a355 2
	if ((f < 0) || (f >= COLORS)
	    || (b < 0) || (b >= COLORS)
a368 1
	attr_t z = COLOR_PAIR(pair);
d374 1
a374 1
		if ((ptr->text[x] & A_COLOR) == z) {
d377 1
a377 1
		    ptr->text[x] = 0;
d387 2
a388 2
    if ((int) (SP->_current_attr & A_COLOR) == COLOR_PAIR(pair))
	SP->_current_attr |= A_COLOR;	/* force attribute update */
d390 1
a390 1
    if (initialize_pair) {
d393 11
a403 12
	T(("initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)",
	   pair,
	   tp[f].red, tp[f].green, tp[f].blue,
	   tp[b].red, tp[b].green, tp[b].blue));

	if (initialize_pair) {
	    TPUTS_TRACE("initialize_pair");
	    putp(tparm(initialize_pair,
		       pair,
		       tp[f].red, tp[f].green, tp[f].blue,
		       tp[b].red, tp[b].green, tp[b].blue));
	}
d409 2
d412 1
a412 2
init_color
(short color, short r, short g, short b)
d414 2
d418 21
a438 2
    if (initialize_color == NULL)
	returnCode(ERR);
a439 17
    if (color < 0 || color >= COLORS)
	returnCode(ERR);
    if (r < 0 || r > 1000 || g < 0 || g > 1000 || b < 0 || b > 1000)
	returnCode(ERR);

    if (hue_lightness_saturation)
	rgb2hls(r, g, b,
		&SP->_color_table[color].red,
		&SP->_color_table[color].green,
		&SP->_color_table[color].blue);
    else {
	SP->_color_table[color].red = r;
	SP->_color_table[color].green = g;
	SP->_color_table[color].blue = b;
    }

    if (initialize_color) {
d441 3
a443 1
	putp(tparm(initialize_color, color, r, g, b));
d445 1
a445 1
    returnCode(OK);
d468 1
a468 2
color_content
(short color, short *r, short *g, short *b)
d470 2
d473 19
a491 10
    if (color < 0 || color >= COLORS)
	returnCode(ERR);

    if (r)
	*r = SP->_color_table[color].red;
    if (g)
	*g = SP->_color_table[color].green;
    if (b)
	*b = SP->_color_table[color].blue;
    returnCode(OK);
d495 1
a495 2
pair_content
(short pair, short *f, short *b)
d497 2
d501 17
a517 6
    if ((pair < 0) || (pair >= COLOR_PAIRS))
	returnCode(ERR);
    if (f)
	*f = ((SP->_color_pairs[pair] >> C_SHIFT) & C_MASK);
    if (b)
	*b = (SP->_color_pairs[pair] & C_MASK);
d519 4
a522 1
    returnCode(OK);
d526 1
a526 2
_nc_do_color
(int old_pair, int pair, bool reverse, int (*outc) (int))
d528 2
a529 1
    NCURSES_COLOR_T fg = C_MASK, bg = C_MASK;
d537 1
a537 1
	    tputs(tparm(set_color_pair, pair), 1, outc);
d540 1
a540 1
	    pair_content(pair, &fg, &bg);
d544 5
a548 4
    if (old_pair >= 0 && SP != 0) {
	pair_content(old_pair, &old_fg, &old_bg);
	if ((fg == C_MASK && old_fg != C_MASK)
	    || (bg == C_MASK && old_bg != C_MASK)) {
d555 3
a557 1
	    if (SP->_has_sgr_39_49 && old_bg == C_MASK && old_fg != C_MASK) {
d559 3
a561 1
	    } else if (SP->_has_sgr_39_49 && old_fg == C_MASK && old_bg != C_MASK) {
d565 1
a565 1
		set_original_colors();
d568 1
a568 1
	set_original_colors();
d574 1
a574 1
    if (fg == C_MASK)
d576 1
a576 1
    if (bg == C_MASK)
d589 1
a589 1
    if (fg != C_MASK) {
d592 1
a592 1
    if (bg != C_MASK) {
@


1.9
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.8 2000/06/19 03:53:40 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_color.c,v 1.53 2000/09/02 18:02:15 tom Exp $")
d53 4
a56 2
int COLOR_PAIRS = 0;
int COLORS = 0;
d97 2
a98 2
static int
default_fg(void)
d118 2
a119 2
static int
toggled_colors(int c)
d124 1
a124 1
	    8, 12, 10, 14, 9, 13, 11, 15};
d169 1
a169 1
int
d263 3
a265 2
int
init_pair(short pair, short f, short b)
d327 3
a329 3
		pair,
		tp[f].red, tp[f].green, tp[f].blue,
		tp[b].red, tp[b].green, tp[b].blue));
d334 3
a336 3
		    pair,
		    tp[f].red, tp[f].green, tp[f].blue,
		    tp[b].red, tp[b].green, tp[b].blue));
d343 3
a345 2
int
init_color(short color, short r, short g, short b)
d359 3
a361 3
	    &SP->_color_table[color].red,
	    &SP->_color_table[color].green,
	    &SP->_color_table[color].blue);
d375 1
a375 1
bool
d382 1
a382 1
bool
d387 5
a391 5
	    && (((set_foreground != NULL)
		    && (set_background != NULL))
		|| ((set_a_foreground != NULL)
		    && (set_a_background != NULL))
		|| set_color_pair)) ? TRUE : FALSE);
d394 3
a396 2
int
color_content(short color, short *r, short *g, short *b)
d411 3
a413 2
int
pair_content(short pair, short *f, short *b)
d427 3
a429 2
void
_nc_do_color(int old_pair, int pair, bool reverse, int (*outc) (int))
d483 2
a484 1
    TR(TRACE_ATTRS, ("setting colors: pair = %d, fg = %d, bg = %d", pair, fg, bg));
@


1.8
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.7 2000/03/26 16:45:03 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_color.c,v 1.51 2000/05/20 20:09:22 tom Exp $")
d90 1
a90 1
#ifdef NCURSES_EXT_FUNCS
d270 1
a270 1
#ifdef NCURSES_EXT_FUNCS
d443 1
a443 1
#ifdef NCURSES_EXT_FUNCS
d463 1
a463 1
#ifdef NCURSES_EXT_FUNCS
d476 1
a476 1
    T(("setting colors: pair = %d, fg = %d, bg = %d", pair, fg, bg));
@


1.7
log
@Update to ncurses-5.0-20000325
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.6 2000/03/10 01:35:02 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_color.c,v 1.49 2000/03/26 03:12:12 tom Exp $")
d317 1
a317 1
    if ((int)(SP->_current_attr & A_COLOR) == COLOR_PAIR(pair))
d424 2
a425 2
    short fg = C_MASK, bg = C_MASK;
    short old_fg, old_bg;
d427 3
a429 1
    if (pair != 0) {
d471 1
a471 1
	short xx = fg;
@


1.6
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.5 2000/01/02 22:06:51 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_color.c,v 1.45 2000/02/27 00:20:31 tom Exp $")
d91 4
d98 1
a98 1
    return (SP->_default_fg != C_MASK) ? SP->_default_fg : COLOR_WHITE;
d104 1
a104 1
    return (SP->_default_bg != C_MASK) ? SP->_default_bg : COLOR_BLACK;
d268 1
a268 1
    if ((pair < 1) || (pair >= COLOR_PAIRS))
d282 1
d284 4
a287 2
	|| (b < 0) || (b >= COLORS))
	returnCode(ERR);
d317 2
d422 1
a422 1
_nc_do_color(int pair, bool reverse, int (*outc) (int))
d424 2
a425 1
    short fg, bg;
d427 1
a427 13
    if (pair == 0) {
	if (
#ifdef NCURSES_EXT_FUNCS
	    !SP->_default_color ||
#endif
	    !set_original_colors()) {
	    fg = default_fg();
	    bg = default_bg();
	} else {
	    fg = C_MASK;
	    bg = C_MASK;
	}
    } else {
d432 1
a432 1
	} else {
d434 7
d442 10
a451 6
	    if (SP->_default_color) {
		if (fg == C_MASK)
		    fg = SP->_default_fg;
		if (bg == C_MASK)
		    bg = SP->_default_bg;
	    }
d453 1
d455 4
d461 6
a466 8
    if (fg == C_MASK || bg == C_MASK) {
	if (set_original_colors() != TRUE) {
	    if (fg == C_MASK)
		fg = default_fg();
	    if (bg == C_MASK)
		bg = default_bg();
	}
    }
@


1.5
log
@+ corrected conversion from terminfo rs2 to termcap rs (cf: 980704)
+ make conversion to termcap ug (underline glitch) more consistently applied.
+ modify read_termtype(), fixing 'toe', which could dump core when it
found an incomplete entry such as "dumb" because it did not
initialize its buffer for _nc_read_file_entry().
+ use explicit VALID_NUMERIC() checks in a few places that had been
overlooked, and add a check to ensure that init_tabs is nonzero,
to avoid divide-by-zero (reported by Todd C Miller).
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.4 1999/11/28 17:49:53 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d46 1
a46 1
MODULE_ID("$From: lib_color.c,v 1.42 2000/01/01 16:42:37 tom Exp $")
d50 1
a50 1
 * hystorical reasons.  So we assign them in start_color() and also in
d94 1
a94 1
    return (SP->_default_fg >= 0) ? SP->_default_fg : COLOR_WHITE;
d100 1
a100 1
    return (SP->_default_bg >= 0) ? SP->_default_bg : COLOR_BLACK;
d423 5
a427 2
	    set_foreground_color(default_fg(), outc);
	    set_background_color(default_bg(), outc);
d433 1
d436 6
a441 4
	    if (reverse) {
		short xx = fg;
		fg = bg;
		bg = xx;
d443 12
d456 7
a462 1
	    T(("setting colors: pair = %d, fg = %d, bg = %d", pair, fg, bg));
d464 5
a468 15
	    if (fg == C_MASK || bg == C_MASK) {
		if (set_original_colors() != TRUE) {
		    if (fg == C_MASK)
			set_foreground_color(default_fg(), outc);
		    if (bg == C_MASK)
			set_background_color(default_bg(), outc);
		}
	    }
	    if (fg != C_MASK) {
		set_foreground_color(fg, outc);
	    }
	    if (bg != C_MASK) {
		set_background_color(bg, outc);
	    }
	}
@


1.4
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.3 1999/03/15 19:12:22 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
d44 1
d46 1
a46 1
MODULE_ID("$From: lib_color.c,v 1.40 1999/11/27 22:24:18 tom Exp $")
d62 1
a62 1

d65 9
a73 9
    /*  R		G		B */
	{RGB_OFF,	RGB_OFF,	RGB_OFF},	/* COLOR_BLACK */
	{RGB_ON,	RGB_OFF,	RGB_OFF},	/* COLOR_RED */
	{RGB_OFF,	RGB_ON,		RGB_OFF},	/* COLOR_GREEN */
	{RGB_ON,	RGB_ON,		RGB_OFF},	/* COLOR_YELLOW */
	{RGB_OFF,	RGB_OFF,	RGB_ON},	/* COLOR_BLUE */
	{RGB_ON,	RGB_OFF,	RGB_ON},	/* COLOR_MAGENTA */
	{RGB_OFF,	RGB_ON,		RGB_ON},	/* COLOR_CYAN */
	{RGB_ON,	RGB_ON,		RGB_ON},	/* COLOR_WHITE */
d75 1
d78 9
a86 9
    /*  H	L	S */
	{0,	0,	0},	/* COLOR_BLACK */
	{120,	50,	100},	/* COLOR_RED */
	{240,	50,	100},	/* COLOR_GREEN */
	{180,	50,	100},	/* COLOR_YELLOW */
	{330,	50,	100},	/* COLOR_BLUE */
	{60,	50,	100},	/* COLOR_MAGENTA */
	{300,	50,	100},	/* COLOR_CYAN */
	{0,	50,	100},	/* COLOR_WHITE */
d88 1
d94 1
a94 1
	return (SP->_default_fg >= 0) ? SP->_default_fg : COLOR_WHITE;
d100 1
a100 1
	return (SP->_default_bg >= 0) ? SP->_default_bg : COLOR_BLACK;
d112 2
a113 1
static int toggled_colors(int c)
d117 2
a118 2
		{ 0,  4,  2,  6,  1,  5,  3,  7,
		  8, 12, 10, 14,  9, 13, 11, 15};
d124 2
a125 1
static void set_background_color(int bg, int  (*outc)(int))
d127 7
a133 10
	if (set_a_background)
	{
	    TPUTS_TRACE("set_a_background");
	    tputs(tparm(set_a_background, bg), 1, outc);
	}
	else
	{
	    TPUTS_TRACE("set_background");
	    tputs(tparm(set_background, toggled_colors(bg)), 1, outc);
	}
d136 2
a137 1
static void set_foreground_color(int fg, int  (*outc)(int))
d139 7
a145 10
	if (set_a_foreground)
	{
	    TPUTS_TRACE("set_a_foreground");
	    tputs(tparm(set_a_foreground, fg), 1, outc);
	}
	else
	{
	    TPUTS_TRACE("set_foreground");
	    tputs(tparm(set_foreground, toggled_colors(fg)), 1, outc);
	}
d148 2
a149 1
static bool set_original_colors(void)
d151 10
a160 12
	if (orig_pair != 0) {
		TPUTS_TRACE("orig_pair");
		putp(orig_pair);
		return TRUE;
	}
	else if (orig_colors != NULL)
	{
		TPUTS_TRACE("orig_colors");
		putp(orig_colors);
		return TRUE;
	}
	return FALSE;
d163 2
a164 1
int start_color(void)
d166 2
a167 2
	int n;
	const color_t *tp;
d169 1
a169 1
	T((T_CALLED("start_color()")));
d171 17
a187 5
	if (set_original_colors() != TRUE)
	{
		set_foreground_color(default_fg(), _nc_outch);
		set_background_color(default_bg(), _nc_outch);
	}
d189 18
a206 32
	if (max_pairs != -1)
		COLOR_PAIRS = SP->_pair_count = max_pairs;
	else
		returnCode(ERR);
	if ((SP->_color_pairs = typeCalloc(unsigned short, max_pairs)) == 0)
		returnCode(ERR);
	SP->_color_pairs[0] = PAIR_OF(default_fg(), default_bg());
	if (max_colors != -1)
		COLORS = SP->_color_count = max_colors;
	else
		returnCode(ERR);
	SP->_coloron = 1;

	if ((SP->_color_table = typeMalloc(color_t, COLORS)) == 0)
		returnCode(ERR);
	tp = (hue_lightness_saturation) ? hls_palette : cga_palette;
	for (n = 0; n < COLORS; n++) {
		if (n < 8) {
			SP->_color_table[n] = tp[n];
		} else {
			SP->_color_table[n] = tp[n % 8];
			if (hue_lightness_saturation) {
				SP->_color_table[n].green = 100;
			} else {
				if (SP->_color_table[n].red)
					SP->_color_table[n].red = 1000;
				if (SP->_color_table[n].green)
					SP->_color_table[n].green = 1000;
				if (SP->_color_table[n].blue)
					SP->_color_table[n].blue = 1000;
			}
		}
d208 1
d210 1
a210 1
	T(("started color: COLORS = %d, COLOR_PAIRS = %d", COLORS, COLOR_PAIRS));
d212 1
a212 1
	returnCode(OK);
d216 2
a217 1
static void rgb2hls(short r, short g, short b, short *h, short *l, short *s)
d222 4
a225 2
    if ((min = g < r ? g : r) > b) min = b;
    if ((max = g > r ? g : r) < b) max = b;
d230 1
a230 2
    if (min == max)		/* black, white and all shades of gray */
    {
d239 2
a240 1
    else *s = ((max - min) * 100) / (2000 - max - min);
d245 2
d248 1
a248 4
	if (g == max)
	    t = 240 + ((b - r) * 60) / (max - min);
	else
	    t = 360 + ((r - g) * 60) / (max - min);
d257 2
a258 1
int init_pair(short pair, short f, short b)
d260 1
a260 1
	unsigned result;
d262 1
a262 1
	T((T_CALLED("init_pair(%d,%d,%d)"), pair, f, b));
d264 2
a265 2
	if ((pair < 1) || (pair >= COLOR_PAIRS))
		returnCode(ERR);
d267 10
a276 12
	if (SP->_default_color)
	{
		if (f < 0)
			f = C_MASK;
		if (b < 0)
			b = C_MASK;
		if (f >= COLORS && f != C_MASK)
			returnCode(ERR);
		if (b >= COLORS && b != C_MASK)
			returnCode(ERR);
	}
	else
d279 2
a280 2
	 || (b < 0) || (b >= COLORS))
		returnCode(ERR);
d282 21
a302 22
	/*
	 * When a pair's content is changed, replace its colors (if pair was
	 * initialized before a screen update is performed replacing original
	 * pair colors with the new ones).
	 */
	result = PAIR_OF(f,b);
	if (SP->_color_pairs[pair] != 0
	 && SP->_color_pairs[pair] != result) {
	    int y, x;
	    attr_t z = COLOR_PAIR(pair);

	    for (y = 0; y <= curscr->_maxy; y++) {
		struct ldat *ptr = &(curscr->_line[y]);
		bool changed = FALSE;
		for (x = 0; x <= curscr->_maxx; x++) {
		    if ((ptr->text[x] & A_COLOR) == z) {
			/* Set the old cell to zero to ensure it will be
			   updated on the next doupdate() */
			ptr->text[x] = 0;
			CHANGED_CELL(ptr,x);
			changed = TRUE;
		    }
a303 2
		if (changed)
			_nc_make_oldhash(y);
d305 2
d308 5
a312 1
	SP->_color_pairs[pair] = result;
d314 11
a324 17
	if (initialize_pair)
	{
	    const color_t *tp = hue_lightness_saturation ? hls_palette : cga_palette;

	    T(("initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)",
	       pair,
	       tp[f].red, tp[f].green, tp[f].blue,
	       tp[b].red, tp[b].green, tp[b].blue));

	    if (initialize_pair)
	    {
		TPUTS_TRACE("initialize_pair");
		putp(tparm(initialize_pair,
			    pair,
			    tp[f].red, tp[f].green, tp[f].blue,
			    tp[b].red, tp[b].green, tp[b].blue));
	    }
d326 1
d328 1
a328 1
	returnCode(OK);
d331 2
a332 1
int init_color(short color, short r, short g, short b)
d334 9
a342 1
	T((T_CALLED("init_color(%d,%d,%d,%d)"), color, r, g, b));
d344 10
a353 19
	if (initialize_color == NULL)
		returnCode(ERR);

	if (color < 0 || color >= COLORS)
		returnCode(ERR);
	if (r < 0 || r > 1000 || g < 0 ||  g > 1000 || b < 0 || b > 1000)
		returnCode(ERR);

	if (hue_lightness_saturation)
	    rgb2hls(r, g, b,
		      &SP->_color_table[color].red,
		      &SP->_color_table[color].green,
		      &SP->_color_table[color].blue);
	else
	{
		SP->_color_table[color].red = r;
		SP->_color_table[color].green = g;
		SP->_color_table[color].blue = b;
	}
d355 5
a359 6
	if (initialize_color)
	{
		TPUTS_TRACE("initialize_color");
		putp(tparm(initialize_color, color, r, g, b));
	}
	returnCode(OK);
d362 2
a363 1
bool can_change_color(void)
d365 2
a366 2
	T((T_CALLED("can_change_color()")));
	returnCode ((can_change != 0) ? TRUE : FALSE);
d369 2
a370 1
bool has_colors(void)
d372 7
a378 7
	T((T_CALLED("has_colors()")));
	returnCode (((max_colors != -1) && (max_pairs != -1)
		     && (((set_foreground != NULL)
			  && (set_background != NULL))
			 || ((set_a_foreground != NULL)
			     && (set_a_background != NULL))
			 || set_color_pair)) ? TRUE : FALSE);
d381 2
a382 1
int color_content(short color, short *r, short *g, short *b)
d388 6
a393 3
    if (r) *r = SP->_color_table[color].red;
    if (g) *g = SP->_color_table[color].green;
    if (b) *b = SP->_color_table[color].blue;
d397 2
a398 1
int pair_content(short pair, short *f, short *b)
d400 1
a400 1
	T((T_CALLED("pair_content(%d,%p,%p)"), pair, f, b));
d402 6
a407 4
	if ((pair < 0) || (pair >= COLOR_PAIRS))
		returnCode(ERR);
	if (f) *f = ((SP->_color_pairs[pair] >> C_SHIFT) & C_MASK);
	if (b) *b =  (SP->_color_pairs[pair] & C_MASK);
d409 1
a409 1
	returnCode(OK);
d412 2
a413 1
void _nc_do_color(int pair, bool reverse, int (*outc)(int))
d417 1
a417 2
    if (pair == 0)
    {
d422 1
a422 2
	    !set_original_colors())
	{
d426 2
a427 5
    }
    else
    {
	if (set_color_pair)
	{
d430 1
a430 3
	}
	else
	{
d440 6
a445 8
	    if (fg == C_MASK || bg == C_MASK)
	    {
		if (set_original_colors() != TRUE)
		{
			if (fg == C_MASK)
				set_foreground_color(default_fg(), outc);
			if (bg == C_MASK)
				set_background_color(default_bg(), outc);
d448 1
a448 2
	    if (fg != C_MASK)
	    {
d451 1
a451 2
	    if (bg != C_MASK)
	    {
@


1.3
log
@ncurses-4.2-990314
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.2 1999/03/02 06:23:27 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a38 1
 *
d45 1
a45 1
MODULE_ID("$From: lib_color.c,v 1.35 1999/03/15 01:45:14 Alexander.V.Lukyanov Exp $")
d52 2
a53 2
int COLOR_PAIRS;
int COLORS;
d87 17
d166 3
d173 2
a174 2
		set_foreground_color(COLOR_WHITE, _nc_outch);
		set_background_color(COLOR_BLACK, _nc_outch);
d183 1
a183 1
	SP->_color_pairs[0] = PAIR_OF(COLOR_WHITE, COLOR_BLACK);
d192 18
a209 4
	if (hue_lightness_saturation)
	    memcpy(SP->_color_table, hls_palette, sizeof(color_t) * COLORS);
	else
	    memcpy(SP->_color_table, cga_palette, sizeof(color_t) * COLORS);
d264 1
d277 1
d385 1
a385 1
    if (color < 0 || color > COLORS)
d398 1
a398 1
	if ((pair < 0) || (pair > COLOR_PAIRS))
d412 5
a416 11
	if (orig_pair)
	{
	    TPUTS_TRACE("orig_pair");
	    tputs(orig_pair, 1, outc);
	}
	else if (set_color_pair)
	{
	    TPUTS_TRACE("set_color_pair");
	    tputs(tparm(set_color_pair, pair), 1, outc);
	}
	else
d418 2
a419 2
	    set_foreground_color(COLOR_WHITE, outc);
	    set_background_color(COLOR_BLACK, outc);
d445 1
a445 1
				set_foreground_color(COLOR_WHITE, outc);
d447 1
a447 1
				set_background_color(COLOR_BLACK, outc);
@


1.2
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.1 1999/01/18 19:09:39 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_color.c,v 1.34 1999/02/27 19:54:51 tom Exp $")
d263 3
a265 1
			ptr->text[x] &= ~A_COLOR;
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.7 1998/10/31 06:30:29 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_color.c,v 1.33 1998/09/20 00:51:51 tom Exp $")
d171 1
a171 1
	if ((SP->_color_table = malloc(sizeof(color_t) * COLORS)) == 0)
@

