head	1.11;
access;
symbols
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.32
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.28
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.24
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.26
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.18
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.22
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.38
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.34
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.32
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.30
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.28
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.26
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.24
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.22
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.20
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.18
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.16
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.14
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.12
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.10
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.8
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.11
date	2010.01.12.23.22.05;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.22.18.01.39;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.22.18.27.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.10.15.10.31;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.08.22.46.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.10.03.06.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.19.03.53.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.10.01.35.02;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.23.04.57.41;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.11.21.03.55;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.09.46;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
**	lib_getch.c
**
**	The routine getch().
**
*/

#include <curses.priv.h>

MODULE_ID("$Id: lib_getch.c,v 1.99 2008/09/20 19:46:13 tom Exp $")

#include <fifo_defs.h>

#if USE_REENTRANT
#define GetEscdelay(sp) (sp)->_ESCDELAY
NCURSES_EXPORT(int)
NCURSES_PUBLIC_VAR(ESCDELAY) (void)
{
    return SP ? GetEscdelay(SP) : 1000;
}
#else
#define GetEscdelay(sp) ESCDELAY
NCURSES_EXPORT_VAR(int)
ESCDELAY = 1000;		/* max interval betw. chars in funkeys, in millisecs */
#endif

#if NCURSES_EXT_FUNCS
NCURSES_EXPORT(int)
set_escdelay(int value)
{
    int code = OK;
#if USE_REENTRANT
    if (SP) {
	SP->_ESCDELAY = value;
    } else {
	code = ERR;
    }
#else
    ESCDELAY = value;
#endif
    return code;
}
#endif

static int
_nc_use_meta(WINDOW *win)
{
    SCREEN *sp = _nc_screen_of(win);
    return (sp ? sp->_use_meta : 0);
}

#ifdef NCURSES_WGETCH_EVENTS
#define TWAIT_MASK 7
#else
#define TWAIT_MASK 3
#endif

/*
 * Check for mouse activity, returning nonzero if we find any.
 */
static int
check_mouse_activity(SCREEN *sp, int delay EVENTLIST_2nd(_nc_eventlist * evl))
{
    int rc;

#if USE_SYSMOUSE
    if ((sp->_mouse_type == M_SYSMOUSE)
	&& (sp->_sysmouse_head < sp->_sysmouse_tail)) {
	return 2;
    }
#endif
    rc = _nc_timed_wait(sp, TWAIT_MASK, delay, (int *) 0 EVENTLIST_2nd(evl));
#if USE_SYSMOUSE
    if ((sp->_mouse_type == M_SYSMOUSE)
	&& (sp->_sysmouse_head < sp->_sysmouse_tail)
	&& (rc == 0)
	&& (errno == EINTR)) {
	rc |= 2;
    }
#endif
    return rc;
}

static NCURSES_INLINE int
fifo_peek(SCREEN *sp)
{
    int ch = sp->_fifo[peek];
    TR(TRACE_IEVENT, ("peeking at %d", peek));

    p_inc();
    return ch;
}

static NCURSES_INLINE int
fifo_pull(SCREEN *sp)
{
    int ch;
    ch = sp->_fifo[head];
    TR(TRACE_IEVENT, ("pulling %s from %d", _nc_tracechar(sp, ch), head));

    if (peek == head) {
	h_inc();
	peek = head;
    } else
	h_inc();

#ifdef TRACE
    if (USE_TRACEF(TRACE_IEVENT)) {
	_nc_fifo_dump(sp);
	_nc_unlock_global(tracef);
    }
#endif
    return ch;
}

static NCURSES_INLINE int
fifo_push(SCREEN *sp EVENTLIST_2nd(_nc_eventlist * evl))
{
    int n;
    int ch = 0;
    int mask = 0;

    (void) mask;
    if (tail == -1)
	return ERR;

#ifdef HIDE_EINTR
  again:
    errno = 0;
#endif

#ifdef NCURSES_WGETCH_EVENTS
    if (evl
#if USE_GPM_SUPPORT || USE_EMX_MOUSE || USE_SYSMOUSE
	|| (sp->_mouse_fd >= 0)
#endif
	) {
	mask = check_mouse_activity(sp, -1 EVENTLIST_2nd(evl));
    } else
	mask = 0;

    if (mask & 4) {
	T(("fifo_push: ungetch KEY_EVENT"));
	_nc_ungetch(sp, KEY_EVENT);
	return KEY_EVENT;
    }
#elif USE_GPM_SUPPORT || USE_EMX_MOUSE || USE_SYSMOUSE
    if (sp->_mouse_fd >= 0) {
	mask = check_mouse_activity(sp, -1 EVENTLIST_2nd(evl));
    }
#endif

#if USE_GPM_SUPPORT || USE_EMX_MOUSE
    if ((sp->_mouse_fd >= 0) && (mask & 2)) {
	sp->_mouse_event(sp);
	ch = KEY_MOUSE;
	n = 1;
    } else
#endif
#if USE_SYSMOUSE
	if ((sp->_mouse_type == M_SYSMOUSE)
	    && (sp->_sysmouse_head < sp->_sysmouse_tail)) {
	sp->_mouse_event(sp);
	ch = KEY_MOUSE;
	n = 1;
    } else if ((sp->_mouse_type == M_SYSMOUSE)
	       && (mask <= 0) && errno == EINTR) {
	sp->_mouse_event(sp);
	ch = KEY_MOUSE;
	n = 1;
    } else
#endif
    {				/* Can block... */
	unsigned char c2 = 0;
	n = read(sp->_ifd, &c2, 1);
	ch = c2;
    }

#ifdef HIDE_EINTR
    /*
     * Under System V curses with non-restarting signals, getch() returns
     * with value ERR when a handled signal keeps it from completing.
     * If signals restart system calls, OTOH, the signal is invisible
     * except to its handler.
     *
     * We don't want this difference to show.  This piece of code
     * tries to make it look like we always have restarting signals.
     */
    if (n <= 0 && errno == EINTR)
	goto again;
#endif

    if ((n == -1) || (n == 0)) {
	TR(TRACE_IEVENT, ("read(%d,&ch,1)=%d, errno=%d", sp->_ifd, n, errno));
	ch = ERR;
    }
    TR(TRACE_IEVENT, ("read %d characters", n));

    sp->_fifo[tail] = ch;
    sp->_fifohold = 0;
    if (head == -1)
	head = peek = tail;
    t_inc();
    TR(TRACE_IEVENT, ("pushed %s at %d", _nc_tracechar(sp, ch), tail));
#ifdef TRACE
    if (USE_TRACEF(TRACE_IEVENT)) {
	_nc_fifo_dump(sp);
	_nc_unlock_global(tracef);
    }
#endif
    return ch;
}

static NCURSES_INLINE void
fifo_clear(SCREEN *sp)
{
    memset(sp->_fifo, 0, sizeof(sp->_fifo));
    head = -1;
    tail = peek = 0;
}

static int kgetch(SCREEN *EVENTLIST_2nd(_nc_eventlist * evl));

static void
recur_wrefresh(WINDOW *win)
{
#ifdef USE_PTHREADS
    SCREEN *sp = _nc_screen_of(win);
    if (_nc_use_pthreads && sp != SP) {
	SCREEN *save_SP;

	/* temporarily switch to the window's screen to check/refresh */
	_nc_lock_global(curses);
	save_SP = SP;
	_nc_set_screen(sp);
	recur_wrefresh(win);
	_nc_set_screen(save_SP);
	_nc_unlock_global(curses);
    } else
#endif
	if ((is_wintouched(win) || (win->_flags & _HASMOVED))
	    && !(win->_flags & _ISPAD)) {
	wrefresh(win);
    }
}

static int
recur_wgetnstr(WINDOW *win, char *buf)
{
    SCREEN *sp = _nc_screen_of(win);
    int rc;

    if (sp != 0) {
#ifdef USE_PTHREADS
	if (_nc_use_pthreads && sp != SP) {
	    SCREEN *save_SP;

	    /* temporarily switch to the window's screen to get cooked input */
	    _nc_lock_global(curses);
	    save_SP = SP;
	    _nc_set_screen(sp);
	    rc = recur_wgetnstr(win, buf);
	    _nc_set_screen(save_SP);
	    _nc_unlock_global(curses);
	} else
#endif
	{
	    sp->_called_wgetch = TRUE;
	    rc = wgetnstr(win, buf, MAXCOLUMNS);
	    sp->_called_wgetch = FALSE;
	}
    } else {
	rc = ERR;
    }
    return rc;
}

NCURSES_EXPORT(int)
_nc_wgetch(WINDOW *win,
	   unsigned long *result,
	   int use_meta
	   EVENTLIST_2nd(_nc_eventlist * evl))
{
    SCREEN *sp;
    int ch;
#ifdef NCURSES_WGETCH_EVENTS
    long event_delay = -1;
#endif

    T((T_CALLED("_nc_wgetch(%p)"), win));

    *result = 0;

    sp = _nc_screen_of(win);
    if (win == 0 || sp == 0) {
	returnCode(ERR);
    }

    if (cooked_key_in_fifo()) {
	recur_wrefresh(win);
	*result = fifo_pull(sp);
	returnCode(*result >= KEY_MIN ? KEY_CODE_YES : OK);
    }
#ifdef NCURSES_WGETCH_EVENTS
    if (evl && (evl->count == 0))
	evl = NULL;
    event_delay = _nc_eventlist_timeout(evl);
#endif

    /*
     * Handle cooked mode.  Grab a string from the screen,
     * stuff its contents in the FIFO queue, and pop off
     * the first character to return it.
     */
    if (head == -1 &&
	!sp->_notty &&
	!sp->_raw &&
	!sp->_cbreak &&
	!sp->_called_wgetch) {
	char buf[MAXCOLUMNS], *bufp;
	int rc;

	TR(TRACE_IEVENT, ("filling queue in cooked mode"));

	rc = recur_wgetnstr(win, buf);

	/* ungetch in reverse order */
#ifdef NCURSES_WGETCH_EVENTS
	if (rc != KEY_EVENT)
#endif
	    _nc_ungetch(sp, '\n');
	for (bufp = buf + strlen(buf); bufp > buf; bufp--)
	    _nc_ungetch(sp, bufp[-1]);

#ifdef NCURSES_WGETCH_EVENTS
	/* Return it first */
	if (rc == KEY_EVENT) {
	    *result = rc;
	} else
#endif
	    *result = fifo_pull(sp);
	returnCode(*result >= KEY_MIN ? KEY_CODE_YES : OK);
    }

    if (win->_use_keypad != sp->_keypad_on)
	_nc_keypad(sp, win->_use_keypad);

    recur_wrefresh(win);

    if (win->_notimeout || (win->_delay >= 0) || (sp->_cbreak > 1)) {
	if (head == -1) {	/* fifo is empty */
	    int delay;
	    int rc;

	    TR(TRACE_IEVENT, ("timed delay in wgetch()"));
	    if (sp->_cbreak > 1)
		delay = (sp->_cbreak - 1) * 100;
	    else
		delay = win->_delay;

#ifdef NCURSES_WGETCH_EVENTS
	    if (event_delay >= 0 && delay > event_delay)
		delay = event_delay;
#endif

	    TR(TRACE_IEVENT, ("delay is %d milliseconds", delay));

	    rc = check_mouse_activity(sp, delay EVENTLIST_2nd(evl));

#ifdef NCURSES_WGETCH_EVENTS
	    if (rc & 4) {
		*result = KEY_EVENT;
		returnCode(KEY_CODE_YES);
	    }
#endif
	    if (!rc) {
		returnCode(ERR);
	    }
	}
	/* else go on to read data available */
    }

    if (win->_use_keypad) {
	/*
	 * This is tricky.  We only want to get special-key
	 * events one at a time.  But we want to accumulate
	 * mouse events until either (a) the mouse logic tells
	 * us it's picked up a complete gesture, or (b)
	 * there's a detectable time lapse after one.
	 *
	 * Note: if the mouse code starts failing to compose
	 * press/release events into clicks, you should probably
	 * increase the wait with mouseinterval().
	 */
	int runcount = 0;
	int rc;

	do {
	    ch = kgetch(sp EVENTLIST_2nd(evl));
	    if (ch == KEY_MOUSE) {
		++runcount;
		if (sp->_mouse_inline(sp))
		    break;
	    }
	    if (sp->_maxclick < 0)
		break;
	} while
	    (ch == KEY_MOUSE
	     && (((rc = check_mouse_activity(sp, sp->_maxclick
					     EVENTLIST_2nd(evl))) != 0
		  && !(rc & 4))
		 || !sp->_mouse_parse(sp, runcount)));
#ifdef NCURSES_WGETCH_EVENTS
	if ((rc & 4) && !ch == KEY_EVENT) {
	    _nc_ungetch(sp, ch);
	    ch = KEY_EVENT;
	}
#endif
	if (runcount > 0 && ch != KEY_MOUSE) {
#ifdef NCURSES_WGETCH_EVENTS
	    /* mouse event sequence ended by an event, report event */
	    if (ch == KEY_EVENT) {
		_nc_ungetch(sp, KEY_MOUSE);	/* FIXME This interrupts a gesture... */
	    } else
#endif
	    {
		/* mouse event sequence ended by keystroke, store keystroke */
		_nc_ungetch(sp, ch);
		ch = KEY_MOUSE;
	    }
	}
    } else {
	if (head == -1)
	    fifo_push(sp EVENTLIST_2nd(evl));
	ch = fifo_pull(sp);
    }

    if (ch == ERR) {
#if USE_SIZECHANGE
	if (_nc_handle_sigwinch(sp)) {
	    _nc_update_screensize(sp);
	    /* resizeterm can push KEY_RESIZE */
	    if (cooked_key_in_fifo()) {
		*result = fifo_pull(sp);
		returnCode(*result >= KEY_MIN ? KEY_CODE_YES : OK);
	    }
	}
#endif
	returnCode(ERR);
    }

    /*
     * If echo() is in effect, display the printable version of the
     * key on the screen.  Carriage return and backspace are treated
     * specially by Solaris curses:
     *
     * If carriage return is defined as a function key in the
     * terminfo, e.g., kent, then Solaris may return either ^J (or ^M
     * if nonl() is set) or KEY_ENTER depending on the echo() mode. 
     * We echo before translating carriage return based on nonl(),
     * since the visual result simply moves the cursor to column 0.
     *
     * Backspace is a different matter.  Solaris curses does not
     * translate it to KEY_BACKSPACE if kbs=^H.  This does not depend
     * on the stty modes, but appears to be a hardcoded special case.
     * This is a difference from ncurses, which uses the terminfo entry.
     * However, we provide the same visual result as Solaris, moving the
     * cursor to the left.
     */
    if (sp->_echo && !(win->_flags & _ISPAD)) {
	chtype backup = (ch == KEY_BACKSPACE) ? '\b' : ch;
	if (backup < KEY_MIN)
	    wechochar(win, backup);
    }

    /*
     * Simulate ICRNL mode
     */
    if ((ch == '\r') && sp->_nl)
	ch = '\n';

    /* Strip 8th-bit if so desired.  We do this only for characters that
     * are in the range 128-255, to provide compatibility with terminals
     * that display only 7-bit characters.  Note that 'ch' may be a
     * function key at this point, so we mustn't strip _those_.
     */
    if (!use_meta)
	if ((ch < KEY_MIN) && (ch & 0x80))
	    ch &= 0x7f;

    T(("wgetch returning : %s", _nc_tracechar(sp, ch)));

    *result = ch;
    returnCode(ch >= KEY_MIN ? KEY_CODE_YES : OK);
}

#ifdef NCURSES_WGETCH_EVENTS
NCURSES_EXPORT(int)
wgetch_events(WINDOW *win, _nc_eventlist * evl)
{
    int code;
    unsigned long value;

    T((T_CALLED("wgetch_events(%p,%p)"), win, evl));
    code = _nc_wgetch(win,
		      &value,
		      _nc_use_meta(win)
		      EVENTLIST_2nd(evl));
    if (code != ERR)
	code = value;
    returnCode(code);
}
#endif

NCURSES_EXPORT(int)
wgetch(WINDOW *win)
{
    int code;
    unsigned long value;

    T((T_CALLED("wgetch(%p)"), win));
    code = _nc_wgetch(win,
		      &value,
		      _nc_use_meta(win)
		      EVENTLIST_2nd((_nc_eventlist *) 0));
    if (code != ERR)
	code = value;
    returnCode(code);
}

/*
**      int
**      kgetch()
**
**      Get an input character, but take care of keypad sequences, returning
**      an appropriate code when one matches the input.  After each character
**      is received, set an alarm call based on ESCDELAY.  If no more of the
**      sequence is received by the time the alarm goes off, pass through
**      the sequence gotten so far.
**
**	This function must be called when there are no cooked keys in queue.
**	(that is head==-1 || peek==head)
**
*/

static int
kgetch(SCREEN *sp EVENTLIST_2nd(_nc_eventlist * evl))
{
    TRIES *ptr;
    int ch = 0;
    int timeleft = GetEscdelay(sp);

    TR(TRACE_IEVENT, ("kgetch() called"));

    ptr = sp->_keytry;

    for (;;) {
	if (cooked_key_in_fifo() && sp->_fifo[head] >= KEY_MIN) {
	    break;
	} else if (!raw_key_in_fifo()) {
	    ch = fifo_push(sp EVENTLIST_2nd(evl));
	    if (ch == ERR) {
		peek = head;	/* the keys stay uninterpreted */
		return ERR;
	    }
#ifdef NCURSES_WGETCH_EVENTS
	    else if (ch == KEY_EVENT) {
		peek = head;	/* the keys stay uninterpreted */
		return fifo_pull(sp);	/* Remove KEY_EVENT from the queue */
	    }
#endif
	}

	ch = fifo_peek(sp);
	if (ch >= KEY_MIN) {
	    /* If not first in queue, somebody put this key there on purpose in
	     * emergency.  Consider it higher priority than the unfinished
	     * keysequence we are parsing.
	     */
	    peek = head;
	    /* assume the key is the last in fifo */
	    t_dec();		/* remove the key */
	    return ch;
	}

	TR(TRACE_IEVENT, ("ch: %s", _nc_tracechar(sp, (unsigned char) ch)));
	while ((ptr != NULL) && (ptr->ch != (unsigned char) ch))
	    ptr = ptr->sibling;

	if (ptr == NULL) {
	    TR(TRACE_IEVENT, ("ptr is null"));
	    break;
	}
	TR(TRACE_IEVENT, ("ptr=%p, ch=%d, value=%d",
			  ptr, ptr->ch, ptr->value));

	if (ptr->value != 0) {	/* sequence terminated */
	    TR(TRACE_IEVENT, ("end of sequence"));
	    if (peek == tail)
		fifo_clear(sp);
	    else
		head = peek;
	    return (ptr->value);
	}

	ptr = ptr->child;

	if (!raw_key_in_fifo()) {
	    int rc;

	    TR(TRACE_IEVENT, ("waiting for rest of sequence"));
	    rc = check_mouse_activity(sp, timeleft EVENTLIST_2nd(evl));
#ifdef NCURSES_WGETCH_EVENTS
	    if (rc & 4) {
		TR(TRACE_IEVENT, ("interrupted by a user event"));
		/* FIXME Should have preserved remainder timeleft for reuse... */
		peek = head;	/* Restart interpreting later */
		return KEY_EVENT;
	    }
#endif
	    if (!rc) {
		TR(TRACE_IEVENT, ("ran out of time"));
		break;
	    }
	}
    }
    ch = fifo_pull(sp);
    peek = head;
    return ch;
}
@


1.10
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.9 2000/10/22 18:27:22 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d46 1
a46 1
MODULE_ID("$From: lib_getch.c,v 1.54 2000/12/10 02:43:27 tom Exp $")
d50 9
d61 1
d63 3
a65 2
     static inline int
       fifo_peek(void)
d67 57
a123 1
    int ch = SP->_fifo[peek];
d130 2
a131 2
static inline int
fifo_pull(void)
d134 2
a135 2
    ch = SP->_fifo[head];
    TR(TRACE_IEVENT, ("pulling %d from %d", ch, head));
d144 4
a147 2
    if (_nc_tracing & TRACE_IEVENT)
	_nc_fifo_dump();
d152 2
a153 2
static inline int
fifo_push(void)
d156 2
a157 1
    int ch;
d159 1
d168 37
a204 4
#if USE_GPM_SUPPORT || defined(USE_EMX_MOUSE)
    if ((SP->_mouse_fd >= 0)
	&& (_nc_timed_wait(3, -1, (int *) 0) & 2)) {
	SP->_mouse_event(SP);
d209 1
a209 1
    {
d211 2
a212 2
	n = read(SP->_ifd, &c2, 1);
	ch = CharOf(c2);
d230 1
a230 1
	TR(TRACE_IEVENT, ("read(%d,&ch,1)=%d, errno=%d", SP->_ifd, n, errno));
d235 2
a236 2
    SP->_fifo[tail] = ch;
    SP->_fifohold = 0;
d240 1
a240 1
    TR(TRACE_IEVENT, ("pushed %#x at %d", ch, tail));
d242 4
a245 2
    if (_nc_tracing & TRACE_IEVENT)
	_nc_fifo_dump();
d250 2
a251 2
static inline void
fifo_clear(void)
d253 1
a253 3
    int i;
    for (i = 0; i < FIFO_SIZE; i++)
	SP->_fifo[i] = 0;
d258 24
a281 1
static int kgetch(WINDOW *);
d283 30
a312 3
#define wgetch_should_refresh(win) (\
	(is_wintouched(win) || (win->_flags & _HASMOVED)) \
	&& !(win->_flags & _ISPAD))
d315 4
a318 1
wgetch(WINDOW *win)
d320 1
d322 5
d328 1
a328 1
    T((T_CALLED("wgetch(%p)"), win));
d330 2
a331 1
    if (!win)
d333 1
d336 3
a338 6
	if (wgetch_should_refresh(win))
	    wrefresh(win);

	ch = fifo_pull();
	T(("wgetch returning (pre-cooked): %#x = %s", ch, _trace_key(ch)));
	returnCode(ch);
d340 5
d351 7
a357 2
    if (head == -1 && !SP->_raw && !SP->_cbreak) {
	char buf[MAXCOLUMNS], *sp;
d361 1
a361 1
	wgetnstr(win, buf, MAXCOLUMNS);
d364 19
a382 3
	ungetch('\n');
	for (sp = buf + strlen(buf); sp > buf; sp--)
	    ungetch(sp[-1]);
d384 1
a384 2
	returnCode(fifo_pull());
    }
d386 10
a395 2
    if (wgetch_should_refresh(win))
	wrefresh(win);
d397 4
a400 2
    if (!win->_notimeout && (win->_delay >= 0 || SP->_cbreak > 1)) {
	int delay;
d402 1
a402 5
	TR(TRACE_IEVENT, ("timed delay in wgetch()"));
	if (SP->_cbreak > 1)
	    delay = (SP->_cbreak - 1) * 100;
	else
	    delay = win->_delay;
d404 1
a404 1
	TR(TRACE_IEVENT, ("delay is %d milliseconds", delay));
d406 7
a412 2
	if (head == -1)		/* fifo is empty */
	    if (!_nc_timed_wait(3, delay, (int *) 0))
d414 2
d432 1
d435 1
a435 1
	    ch = kgetch(win);
d438 1
a438 1
		if (SP->_mouse_inline(SP))
d441 2
d445 10
a454 2
	     && (_nc_timed_wait(3, SP->_maxclick, (int *) 0)
		 || !SP->_mouse_parse(runcount)));
d456 11
a466 3
	    /* mouse event sequence ended by keystroke, push it */
	    ungetch(ch);
	    ch = KEY_MOUSE;
d470 2
a471 2
	    fifo_push();
	ch = fifo_pull();
d476 2
a477 2
	if (SP->_sig_winch) {
	    _nc_update_screensize();
d480 2
a481 3
		ch = fifo_pull();
		T(("wgetch returning (pre-cooked): %#x = %s", ch, _trace_key(ch)));
		returnCode(ch);
a484 1
	T(("wgetch returning ERR"));
d506 1
a506 1
    if (SP->_echo && !(win->_flags & _ISPAD)) {
d515 1
a515 1
    if ((ch == '\r') && SP->_nl)
d523 2
a524 2
    if ((ch < KEY_MIN) && (ch & 0x80))
	if (!SP->_use_meta)
d527 23
a549 1
    T(("wgetch returning : %#x = %s", ch, _trace_key(ch)));
d551 14
a564 1
    returnCode(ch);
d577 1
a577 1
**	This function must be called when there is no cooked keys in queue.
d583 1
a583 1
kgetch(WINDOW *win GCC_UNUSED)
d585 1
a585 1
    struct tries *ptr;
d587 1
a587 1
    int timeleft = ESCDELAY;
d589 1
a589 1
    TR(TRACE_IEVENT, ("kgetch(%p) called", win));
d591 1
a591 1
    ptr = SP->_keytry;
d594 5
a598 2
	if (!raw_key_in_fifo()) {
	    if (fifo_push() == ERR) {
d602 6
d609 2
a610 1
	ch = fifo_peek();
d612 4
d622 1
a622 1
	TR(TRACE_IEVENT, ("ch: %s", _trace_key((unsigned char) ch)));
d625 1
a625 1
#ifdef TRACE
a627 6
	} else
	    TR(TRACE_IEVENT, ("ptr=%p, ch=%d, value=%d",
			      ptr, ptr->ch, ptr->value));
#endif /* TRACE */

	if (ptr == NULL)
d629 3
d636 1
a636 1
		fifo_clear();
d645 2
d648 10
a657 1
	    if (!_nc_timed_wait(3, timeleft, &timeleft)) {
d663 1
a663 1
    ch = fifo_pull();
@


1.9
log
@update to ncurses 5.2
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.8 2000/10/10 15:10:31 millert Exp $	*/
d45 1
a45 1
MODULE_ID("$From: lib_getch.c,v 1.50 2000/10/09 23:53:57 Ilya.Zakharevich Exp $")
d49 2
a50 1
int ESCDELAY = 1000;		/* max interval betw. chars in funkeys, in millisecs */
d52 2
a53 2
static inline int
fifo_peek(void)
d86 1
a86 1
    unsigned int ch;
d107 1
a107 1
	ch = c2 & 0xff;
d159 1
a159 1
int
d241 2
a242 2
	    && (_nc_timed_wait(3, SP->_maxclick, (int *) 0)
		|| !SP->_mouse_parse(runcount)));
d363 1
a363 1
		    ptr, ptr->ch, ptr->value));
@


1.8
log
@Don't ignore $TERMCAP, $TERMINFO, $TERMINFO_DIRS, $TERMPATH, and $HOME
if root but not setugid.

Fix select usage to deal with an arbitrary number of fd's.  This code
is not compiled since we use poll(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.7 2000/10/08 22:46:58 millert Exp $	*/
d45 1
a45 1
MODULE_ID("$From: lib_getch.c,v 1.49 2000/07/29 15:45:24 tom Exp $")
a50 45
#ifdef USE_EMX_MOUSE
#  include <sys/select.h>
static int
kbd_mouse_read(unsigned char *p)
{
    fd_set *fdset;
    size_t fdsetsize;
    int nums = SP->_ifd + 1;

    if (SP->_checkfd >= 0 && SP->_checkfd >= nums)
	nums = SP->_checkfd + 1;
    if (SP->_mouse_fd >= 0 && SP->_mouse_fd >= nums)
	nums = SP->_mouse_fd + 1;
    fdsetsize = howmany(nums, NFDBITS) * sizeof(fd_mask);
    fdset = malloc(fdsetsize);
    if (fdset == NULL)
	return -1;

    for (;;) {
	memset(fdset, 0, fdsetsize);
	FD_SET(SP->_ifd, fdset);
	if (SP->_checkfd >= 0)
	    FD_SET(SP->_checkfd, fdset);
	if (SP->_mouse_fd >= 0)
	    FD_SET(SP->_mouse_fd, fdset);
	if (select(nums, fdset, NULL, NULL, NULL) >= 0) {
	    int n;

	    if (SP->_mouse_fd >= 0
		&& FD_ISSET(SP->_mouse_fd, fdset)) {	/* Prefer mouse */
		n = read(SP->_mouse_fd, p, 1);
	    } else {
		n = read(SP->_ifd, p, 1);
	    }
	    free(fdset);
	    return n;
	}
	if (errno != EINTR) {
	    free(fdset);
	    return -1;
	}
    }
}
#endif /* USE_EMX_MOUSE */

d95 1
a95 1
#if USE_GPM_SUPPORT
a104 3
#ifdef USE_EMX_MOUSE
	n = kbd_mouse_read(&c2);
#else
a105 1
#endif
@


1.7
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.6 2000/07/10 03:06:13 millert Exp $	*/
d56 2
a57 1
    fd_set fdset;
d60 9
d70 7
a76 13
	FD_ZERO(&fdset);
	FD_SET(SP->_ifd, &fdset);
	if (SP->_checkfd >= 0) {
	    FD_SET(SP->_checkfd, &fdset);
	    if (SP->_checkfd >= nums)
		nums = SP->_checkfd + 1;
	}
	if (SP->_mouse_fd >= 0) {
	    FD_SET(SP->_mouse_fd, &fdset);
	    if (SP->_mouse_fd >= nums)
		nums = SP->_mouse_fd + 1;
	}
	if (select(nums, &fdset, NULL, NULL, NULL) >= 0) {
d80 1
a80 1
		&& FD_ISSET(SP->_mouse_fd, &fdset)) {	/* Prefer mouse */
d85 1
d89 1
@


1.6
log
@ncurses 5.1
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.5 2000/06/19 03:53:41 millert Exp $	*/
d45 1
a45 1
MODULE_ID("$From: lib_getch.c,v 1.48 2000/07/08 11:21:51 tom Exp $")
d94 1
a94 1
    T(("peeking at %d", peek));
d105 1
a105 1
    T(("pulling %d from %d", ch, head));
d167 1
a167 1
	T(("read(%d,&ch,1)=%d, errno=%d", SP->_ifd, n, errno));
d170 1
a170 1
    T(("read %d characters", n));
d177 1
a177 1
    T(("pushed %#x at %d", ch, tail));
d228 1
a228 1
	T(("filling queue in cooked mode"));
d246 1
a246 1
	T(("timed delay in wgetch()"));
d252 1
a252 1
	T(("delay is %d milliseconds", delay));
@


1.5
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.4 2000/03/10 01:35:02 millert Exp $	*/
d45 1
a45 1
MODULE_ID("$From: lib_getch.c,v 1.47 2000/05/28 01:12:51 tom Exp $")
d168 1
a168 1
	return ERR;
@


1.4
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.3 2000/01/23 04:57:41 millert Exp $	*/
d45 1
a45 1
MODULE_ID("$From: lib_getch.c,v 1.46 2000/02/20 01:21:33 tom Exp $")
d313 24
a349 3

    if (SP->_echo && ch < KEY_MIN && !(win->_flags & _ISPAD))
	wechochar(win, (chtype) ch);
@


1.3
log
@Update to ncurses-5.0-20000122
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.2 1999/03/11 21:03:55 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d45 1
a45 1
MODULE_ID("$From: lib_getch.c,v 1.44 2000/01/17 19:58:18 tom Exp $")
d49 1
a49 1
int ESCDELAY = 1000;	/* max interval betw. chars in funkeys, in millisecs */
d56 2
a57 2
fd_set fdset;
int nums = SP->_ifd+1;
d59 7
a65 27
	for (;;) {
		FD_ZERO(&fdset);
		FD_SET(SP->_ifd, &fdset);
		if (SP->_checkfd >= 0) {
			FD_SET(SP->_checkfd, &fdset);
			if (SP->_checkfd >= nums)
				nums = SP->_checkfd + 1;
		}
		if (SP->_mouse_fd >= 0) {
			FD_SET(SP->_mouse_fd, &fdset);
			if (SP->_mouse_fd >= nums)
				nums = SP->_mouse_fd + 1;
		}
		if (select(nums, &fdset, NULL, NULL, NULL) >= 0) {
			int n;

			if (SP->_mouse_fd >= 0
			 && FD_ISSET(SP->_mouse_fd, &fdset)) { /* Prefer mouse */
				n = read(SP->_mouse_fd, p, 1);
			} else {
				n = read(SP->_ifd, p, 1);
			}
			return n;
		}
		if (errno != EINTR) {
			return -1;
		}
d67 20
d88 1
a88 1
#endif  /* USE_EMX_MOUSE */
d90 2
a91 1
static inline int fifo_peek(void)
d93 2
a94 2
	int ch = SP->_fifo[peek];
	T(("peeking at %d", peek));
d96 2
a97 2
	p_inc();
	return ch;
d100 6
d107 5
a111 13
static inline int fifo_pull(void)
{
int ch;
	ch = SP->_fifo[head];
	T(("pulling %d from %d", ch, head));

	if (peek == head)
	{
	    h_inc();
	    peek = head;
	}
	else
	    h_inc();
d114 2
a115 1
	if (_nc_tracing & TRACE_IEVENT) _nc_fifo_dump();
d117 1
a117 1
	return ch;
d120 2
a121 1
static inline int fifo_push(void)
d123 2
a124 2
int n;
unsigned int ch;
d126 2
a127 1
	if (tail == -1) return ERR;
d130 2
a131 2
again:
	errno = 0;
d135 6
a140 7
	if ((SP->_mouse_fd >= 0)
	 && (_nc_timed_wait(3, -1, (int *)0) & 2))
	{
		SP->_mouse_event(SP);
		ch = KEY_MOUSE;
		n = 1;
	} else
d142 2
a143 2
	{
		unsigned char c2=0;
d145 1
a145 1
		n = kbd_mouse_read(&c2);
d147 1
a147 1
		n = read(SP->_ifd, &c2, 1);
d149 2
a150 2
		ch = c2 & 0xff;
	}
d153 11
a163 11
	/*
	 * Under System V curses with non-restarting signals, getch() returns
	 * with value ERR when a handled signal keeps it from completing.
	 * If signals restart system calls, OTOH, the signal is invisible
	 * except to its handler.
	 *
	 * We don't want this difference to show.  This piece of code
	 * tries to make it look like we always have restarting signals.
	 */
	if (n <= 0 && errno == EINTR)
		goto again;
d166 12
a177 13
	if ((n == -1) || (n == 0))
	{
	    T(("read(%d,&ch,1)=%d, errno=%d", SP->_ifd, n, errno));
	    return ERR;
	}
	T(("read %d characters", n));

	SP->_fifo[tail] = ch;
	SP->_fifohold = 0;
	if (head == -1)
	    head = peek = tail;
	t_inc();
	T(("pushed %#x at %d", ch, tail));
d179 2
a180 1
	if (_nc_tracing & TRACE_IEVENT) _nc_fifo_dump();
d182 1
a182 1
	return ch;
d185 2
a186 1
static inline void fifo_clear(void)
d188 5
a192 4
int i;
	for (i = 0; i < FIFO_SIZE; i++)
		SP->_fifo[i] = 0;
	head = -1; tail = peek = 0;
d204 15
a218 1
int	ch;
d220 7
a226 1
	T((T_CALLED("wgetch(%p)"), win));
d228 1
a228 2
	if (!win)
	  returnCode(ERR);
d230 1
a230 4
	if (cooked_key_in_fifo())
	{
		if (wgetch_should_refresh(win))
			wrefresh(win);
d232 4
a235 4
		ch = fifo_pull();
		T(("wgetch returning (pre-cooked): %#x = %s", ch, _trace_key(ch));)
		returnCode(ch);
	}
d237 2
a238 8
	/*
	 * Handle cooked mode.  Grab a string from the screen,
	 * stuff its contents in the FIFO queue, and pop off
	 * the first character to return it.
	 */
	if (head == -1 && !SP->_raw && !SP->_cbreak)
	{
		char	buf[MAXCOLUMNS], *sp;
d240 2
a241 1
		T(("filling queue in cooked mode"));
d243 2
a244 1
		wgetnstr(win, buf, MAXCOLUMNS);
d246 5
a250 4
		/* ungetch in reverse order */
		ungetch('\n');
		for (sp = buf+strlen(buf); sp>buf; sp--)
			ungetch(sp[-1]);
d252 1
a252 2
		returnCode(fifo_pull());
	}
d254 5
a258 2
	if (wgetch_should_refresh(win))
		wrefresh(win);
d260 13
a272 17
	if (!win->_notimeout && (win->_delay >= 0 || SP->_cbreak > 1))
	{
	        int delay;

		T(("timed delay in wgetch()"));
		if (SP->_cbreak > 1)
		    delay = (SP->_cbreak - 1) * 100;
		else
		    delay = win->_delay;

		T(("delay is %d milliseconds", delay));

		if (head == -1)	/* fifo is empty */
			if (!_nc_timed_wait(3, delay, (int *)0))
				returnCode(ERR);
		/* else go on to read data available */
	}
d274 15
a288 37
	if (win->_use_keypad) 
        {
		/*
		 * This is tricky.  We only want to get special-key
		 * events one at a time.  But we want to accumulate
		 * mouse events until either (a) the mouse logic tells
		 * us it's picked up a complete gesture, or (b)
		 * there's a detectable time lapse after one.
		 *
		 * Note: if the mouse code starts failing to compose
		 * press/release events into clicks, you should probably
		 * increase the wait with mouseinterval().
		 */
		int runcount = 0;

		do {
			ch = kgetch(win);
			if (ch == KEY_MOUSE)
			{
				++runcount;
				if (SP->_mouse_inline(SP))
				    break;
			}
		} while
		    (ch == KEY_MOUSE
		     && (_nc_timed_wait(3, SP->_maxclick, (int *)0)
			 || !SP->_mouse_parse(runcount)));
		if (runcount > 0 && ch != KEY_MOUSE)
		{
		    /* mouse event sequence ended by keystroke, push it */
		    ungetch(ch);
		    ch = KEY_MOUSE;
		}
	} else {
		if (head == -1)
			fifo_push();
		ch = fifo_pull();
d290 5
d296 1
a296 2
	if (ch == ERR)
	{
d298 7
a304 10
	    if(SP->_sig_winch)
	    {
		_nc_update_screensize();
		/* resizeterm can push KEY_RESIZE */
		if(cooked_key_in_fifo())
		{
		    ch = fifo_pull();
		    T(("wgetch returning (pre-cooked): %#x = %s", ch, _trace_key(ch));)
		    returnCode(ch);
		}
d306 1
d308 18
a325 9
	    T(("wgetch returning ERR"));
	    returnCode(ERR);
	}

	/*
	 * Simulate ICRNL mode
	 */
	if ((ch == '\r') && SP->_nl)
		ch = '\n';
d327 2
a328 11
	/* Strip 8th-bit if so desired.  We do this only for characters that
	 * are in the range 128-255, to provide compatibility with terminals
	 * that display only 7-bit characters.  Note that 'ch' may be a
	 * function key at this point, so we mustn't strip _those_.
	 */
	if ((ch < KEY_MIN) && (ch & 0x80))
		if (!SP->_use_meta)
			ch &= 0x7f;

	if (SP->_echo && ch < KEY_MIN && !(win->_flags & _ISPAD))
		wechochar(win, (chtype)ch);
d330 1
a330 1
	T(("wgetch returning : %#x = %s", ch, _trace_key(ch)));
d332 1
a332 1
	returnCode(ch);
a334 1

d353 26
a378 30
struct tries  *ptr;
int ch = 0;
int timeleft = ESCDELAY;

	TR(TRACE_IEVENT, ("kgetch(%p) called", win));

	ptr = SP->_keytry;

	for(;;)
	{
		if (!raw_key_in_fifo())
		{
		    if(fifo_push() == ERR)
		    {
			peek = head;	/* the keys stay uninterpreted */
			return ERR;
		    }
		}
		ch = fifo_peek();
		if (ch >= KEY_MIN)
		{
		    peek = head;
		    /* assume the key is the last in fifo */
		    t_dec(); /* remove the key */
		    return ch;
		}

		TR(TRACE_IEVENT, ("ch: %s", _trace_key((unsigned char)ch)));
		while ((ptr != NULL) && (ptr->ch != (unsigned char)ch))
			ptr = ptr->sibling;
d380 5
a384 5
		if (ptr == NULL)
			{TR(TRACE_IEVENT, ("ptr is null"));}
		else
			TR(TRACE_IEVENT, ("ptr=%p, ch=%d, value=%d",
					ptr, ptr->ch, ptr->value));
d387 13
a399 2
		if (ptr == NULL)
			break;
d401 6
a406 19
		if (ptr->value != 0) {	/* sequence terminated */
			TR(TRACE_IEVENT, ("end of sequence"));
			if (peek == tail)
			    fifo_clear();
			else
			    head = peek;
			return(ptr->value);
		}

		ptr = ptr->child;

		if (!raw_key_in_fifo())
		{
			TR(TRACE_IEVENT, ("waiting for rest of sequence"));
			if (!_nc_timed_wait(3, timeleft, &timeleft)) {
				TR(TRACE_IEVENT, ("ran out of time"));
				break;
			}
		}
d408 4
a411 3
	ch = fifo_pull();
	peek = head;
	return ch;
@


1.2
log
@ncurses-4.2-990307
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.1 1999/01/18 19:09:46 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d45 1
a45 1
MODULE_ID("$From: lib_getch.c,v 1.43 1999/03/08 02:35:10 tom Exp $")
d61 6
a66 1
		FD_SET(SP->_checkfd, &fdset);
d69 2
a70 2
			if (SP->_mouse_fd > SP->_checkfd)
				nums = SP->_mouse_fd+1;
d75 2
a76 1
			if (FD_ISSET(SP->_mouse_fd, &fdset)) /* Prefer mouse */
d78 1
a78 1
			else
d80 1
d83 1
a83 1
		if (errno != EINTR)
d85 1
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.7 1998/10/31 06:30:29 millert Exp $	*/
d45 1
a45 1
MODULE_ID("$From: lib_getch.c,v 1.41 1998/09/26 23:34:53 tom Exp $")
d234 3
a236 2
	if (!win->_notimeout && (win->_delay >= 0 || SP->_cbreak > 1)) {
	int delay;
d252 2
a253 1
	if (win->_use_keypad) {
@

