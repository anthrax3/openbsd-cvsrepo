head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.32
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.28
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.24
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.26
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.18
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.22
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.20
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.16
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.38
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.34
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.32
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.30
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.28
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.26
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.24
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.22
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.20
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.18
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.16
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.14
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.12
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.10
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2010.01.12.23.22.05;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.22.18.01.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.19.03.53.38;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.08.15.11.40.55;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.09.34;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2006,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/*
**	lib_addch.c
**
**	The routine waddch().
**
*/

#include <curses.priv.h>
#include <ctype.h>

MODULE_ID("$Id: lib_addch.c,v 1.113 2008/08/16 19:20:04 tom Exp $")

static const NCURSES_CH_T blankchar = NewChar(BLANK_TEXT);

/*
 * Ugly microtweaking alert.  Everything from here to end of module is
 * likely to be speed-critical -- profiling data sure says it is!
 * Most of the important screen-painting functions are shells around
 * waddch().  So we make every effort to reduce function-call overhead
 * by inlining stuff, even at the cost of making wrapped copies for
 * export.  Also we supply some internal versions that don't call the
 * window sync hook, for use by string-put functions.
 */

/* Return bit mask for clearing color pair number if given ch has color */
#define COLOR_MASK(ch) (~(attr_t)((ch) & A_COLOR ? A_COLOR : 0))

static NCURSES_INLINE NCURSES_CH_T
render_char(WINDOW *win, NCURSES_CH_T ch)
/* compute a rendition of the given char correct for the current context */
{
    attr_t a = WINDOW_ATTRS(win);
    int pair = GetPair(ch);

    if (ISBLANK(ch)
	&& AttrOf(ch) == A_NORMAL
	&& pair == 0) {
	/* color/pair in attrs has precedence over bkgrnd */
	ch = win->_nc_bkgd;
	SetAttr(ch, a | AttrOf(win->_nc_bkgd));
	if ((pair = GET_WINDOW_PAIR(win)) == 0)
	    pair = GetPair(win->_nc_bkgd);
	SetPair(ch, pair);
    } else {
	/* color in attrs has precedence over bkgrnd */
	a |= AttrOf(win->_nc_bkgd) & COLOR_MASK(a);
	/* color in ch has precedence */
	if (pair == 0) {
	    if ((pair = GET_WINDOW_PAIR(win)) == 0)
		pair = GetPair(win->_nc_bkgd);
	}
#if 0
	if (pair > 255) {
	    NCURSES_CH_T fixme = ch;
	    SetPair(fixme, pair);
	}
#endif
	AddAttr(ch, (a & COLOR_MASK(AttrOf(ch))));
	SetPair(ch, pair);
    }

    TR(TRACE_VIRTPUT,
       ("render_char bkg %s (%d), attrs %s (%d) -> ch %s (%d)",
	_tracech_t2(1, CHREF(win->_nc_bkgd)),
	GetPair(win->_nc_bkgd),
	_traceattr(WINDOW_ATTRS(win)),
	GET_WINDOW_PAIR(win),
	_tracech_t2(3, CHREF(ch)),
	GetPair(ch)));

    return (ch);
}

NCURSES_EXPORT(NCURSES_CH_T)
_nc_render(WINDOW *win, NCURSES_CH_T ch)
/* make render_char() visible while still allowing us to inline it below */
{
    return render_char(win, ch);
}

/* check if position is legal; if not, return error */
#ifndef NDEBUG			/* treat this like an assertion */
#define CHECK_POSITION(win, x, y) \
	if (y > win->_maxy \
	 || x > win->_maxx \
	 || y < 0 \
	 || x < 0) { \
		TR(TRACE_VIRTPUT, ("Alert! Win=%p _curx = %d, _cury = %d " \
				   "(_maxx = %d, _maxy = %d)", win, x, y, \
				   win->_maxx, win->_maxy)); \
		return(ERR); \
	}
#else
#define CHECK_POSITION(win, x, y)	/* nothing */
#endif

static bool
newline_forces_scroll(WINDOW *win, NCURSES_SIZE_T * ypos)
{
    bool result = FALSE;

    if (*ypos >= win->_regtop && *ypos == win->_regbottom) {
	*ypos = win->_regbottom;
	result = TRUE;
    } else {
	*ypos += 1;
    }
    return result;
}

/*
 * The _WRAPPED flag is useful only for telling an application that we've just
 * wrapped the cursor.  We don't do anything with this flag except set it when
 * wrapping, and clear it whenever we move the cursor.  If we try to wrap at
 * the lower-right corner of a window, we cannot move the cursor (since that
 * wouldn't be legal).  So we return an error (which is what SVr4 does). 
 * Unlike SVr4, we can successfully add a character to the lower-right corner
 * (Solaris 2.6 does this also, however).
 */
static int
wrap_to_next_line(WINDOW *win)
{
    win->_flags |= _WRAPPED;
    if (newline_forces_scroll(win, &(win->_cury))) {
	win->_curx = win->_maxx;
	if (!win->_scroll)
	    return (ERR);
	scroll(win);
    }
    win->_curx = 0;
    return (OK);
}

#if USE_WIDEC_SUPPORT
static int waddch_literal(WINDOW *, NCURSES_CH_T);
/*
 * Fill the given number of cells with blanks using the current background
 * rendition.  This saves/restores the current x-position.
 */
static void
fill_cells(WINDOW *win, int count)
{
    NCURSES_CH_T blank = blankchar;
    int save_x = win->_curx;
    int save_y = win->_cury;

    while (count-- > 0) {
	if (waddch_literal(win, blank) == ERR)
	    break;
    }
    win->_curx = save_x;
    win->_cury = save_y;
}
#endif

/*
 * Build up the bytes for a multibyte character, returning the length when
 * complete (a positive number), -1 for error and -2 for incomplete.
 */
#if USE_WIDEC_SUPPORT
NCURSES_EXPORT(int)
_nc_build_wch(WINDOW *win, ARG_CH_T ch)
{
    char *buffer = WINDOW_EXT(win, addch_work);
    int len;
    int x = win->_curx;
    int y = win->_cury;
    mbstate_t state;
    wchar_t result;

    if ((WINDOW_EXT(win, addch_used) != 0) &&
	(WINDOW_EXT(win, addch_x) != x ||
	 WINDOW_EXT(win, addch_y) != y)) {
	/* discard the incomplete multibyte character */
	WINDOW_EXT(win, addch_used) = 0;
	TR(TRACE_VIRTPUT,
	   ("Alert discarded multibyte on move (%d,%d) -> (%d,%d)",
	    WINDOW_EXT(win, addch_y), WINDOW_EXT(win, addch_x),
	    y, x));
    }
    WINDOW_EXT(win, addch_x) = x;
    WINDOW_EXT(win, addch_y) = y;

    init_mb(state);
    buffer[WINDOW_EXT(win, addch_used)] = (char) CharOf(CHDEREF(ch));
    WINDOW_EXT(win, addch_used) += 1;
    buffer[WINDOW_EXT(win, addch_used)] = '\0';
    if ((len = mbrtowc(&result,
		       buffer,
		       WINDOW_EXT(win, addch_used), &state)) > 0) {
	attr_t attrs = AttrOf(CHDEREF(ch));
	if_EXT_COLORS(int pair = GetPair(CHDEREF(ch)));
	SetChar(CHDEREF(ch), result, attrs);
	if_EXT_COLORS(SetPair(CHDEREF(ch), pair));
	WINDOW_EXT(win, addch_used) = 0;
    } else if (len == -1) {
	/*
	 * An error occurred.  We could either discard everything,
	 * or assume that the error was in the previous input.
	 * Try the latter.
	 */
	TR(TRACE_VIRTPUT, ("Alert! mbrtowc returns error"));
	/* handle this with unctrl() */
	WINDOW_EXT(win, addch_used) = 0;
    }
    return len;
}
#endif /* USE_WIDEC_SUPPORT */

static
#if !USE_WIDEC_SUPPORT		/* cannot be inline if it is recursive */
NCURSES_INLINE
#endif
int
waddch_literal(WINDOW *win, NCURSES_CH_T ch)
{
    int x;
    int y;
    struct ldat *line;

    x = win->_curx;
    y = win->_cury;

    CHECK_POSITION(win, x, y);

    ch = render_char(win, ch);

    line = win->_line + y;

    CHANGED_CELL(line, x);

    /*
     * Build up multibyte characters until we have a wide-character.
     */
    if_WIDEC({
	if (WINDOW_EXT(win, addch_used) != 0 || !Charable(ch)) {
	    int len = _nc_build_wch(win, CHREF(ch));

	    if (len >= -1) {
		/* handle EILSEQ */
		if (is8bits(CharOf(ch))) {
		    const char *s = unctrl((chtype) CharOf(ch));
		    if (s[1] != 0) {
			return waddstr(win, s);
		    }
		}
		if (len == -1)
		    return waddch(win, ' ');
	    } else {
		return OK;
	    }
	}
    });

    /*
     * Non-spacing characters are added to the current cell.
     *
     * Spacing characters that are wider than one column require some display
     * adjustments.
     */
    if_WIDEC({
	int len = wcwidth(CharOf(ch));
	int i;
	int j;
	wchar_t *chars;

	if (len == 0) {		/* non-spacing */
	    if ((x > 0 && y >= 0)
		|| (win->_maxx >= 0 && win->_cury >= 1)) {
		if (x > 0 && y >= 0)
		    chars = (win->_line[y].text[x - 1].chars);
		else
		    chars = (win->_line[y - 1].text[win->_maxx].chars);
		for (i = 0; i < CCHARW_MAX; ++i) {
		    if (chars[i] == 0) {
			TR(TRACE_VIRTPUT,
			   ("added non-spacing %d: %x",
			    x, (int) CharOf(ch)));
			chars[i] = CharOf(ch);
			break;
		    }
		}
	    }
	    goto testwrapping;
	} else if (len > 1) {	/* multi-column characters */
	    /*
	     * Check if the character will fit on the current line.  If it does
	     * not fit, fill in the remainder of the line with blanks.  and
	     * move to the next line.
	     */
	    if (len > win->_maxx + 1) {
		TR(TRACE_VIRTPUT, ("character will not fit"));
		return ERR;
	    } else if (x + len > win->_maxx + 1) {
		int count = win->_maxx + 1 - x;
		TR(TRACE_VIRTPUT, ("fill %d remaining cells", count));
		fill_cells(win, count);
		if (wrap_to_next_line(win) == ERR)
		    return ERR;
		x = win->_curx;
		y = win->_cury;
	    }
	    /*
	     * Check for cells which are orphaned by adding this character, set
	     * those to blanks.
	     *
	     * FIXME: this actually could fill j-i cells, more complicated to
	     * setup though.
	     */
	    for (i = 0; i < len; ++i) {
		if (isWidecBase(win->_line[y].text[x + i])) {
		    break;
		} else if (isWidecExt(win->_line[y].text[x + i])) {
		    for (j = i; x + j <= win->_maxx; ++j) {
			if (!isWidecExt(win->_line[y].text[x + j])) {
			    TR(TRACE_VIRTPUT, ("fill %d orphan cells", j));
			    fill_cells(win, j);
			    break;
			}
		    }
		    break;
		}
	    }
	    /*
	     * Finally, add the cells for this character.
	     */
	    for (i = 0; i < len; ++i) {
		NCURSES_CH_T value = ch;
		SetWidecExt(value, i);
		TR(TRACE_VIRTPUT, ("multicolumn %d:%d (%d,%d)",
				   i + 1, len,
				   win->_begy + y, win->_begx + x));
		line->text[x] = value;
		CHANGED_CELL(line, x);
		++x;
	    }
	    goto testwrapping;
	}
    });

    /*
     * Single-column characters.
     */
    line->text[x++] = ch;
    /*
     * This label is used only for wide-characters.
     */
    if_WIDEC(
  testwrapping:
    );

    TR(TRACE_VIRTPUT, ("cell (%ld, %ld..%d) = %s",
		       (long) win->_cury, (long) win->_curx, x - 1,
		       _tracech_t(CHREF(ch))));

    if (x > win->_maxx) {
	return wrap_to_next_line(win);
    }
    win->_curx = x;
    return OK;
}

static NCURSES_INLINE int
waddch_nosync(WINDOW *win, const NCURSES_CH_T ch)
/* the workhorse function -- add a character to the given window */
{
    NCURSES_SIZE_T x, y;
    chtype t = CharOf(ch);
    const char *s = unctrl(t);

    /*
     * If we are using the alternate character set, forget about locale.
     * Otherwise, if unctrl() returns a single-character or the locale
     * claims the code is printable, treat it that way.
     */
    if ((AttrOf(ch) & A_ALTCHARSET)
	|| (
#if USE_WIDEC_SUPPORT
	       (SP != 0 && SP->_legacy_coding) &&
#endif
	       s[1] == 0
	)
	|| (
	       isprint(t)
#if USE_WIDEC_SUPPORT
	       || ((SP == 0 || !SP->_legacy_coding) &&
		   (WINDOW_EXT(win, addch_used)
		    || !_nc_is_charable(CharOf(ch))))
#endif
	))
	return waddch_literal(win, ch);

    /*
     * Handle carriage control and other codes that are not printable, or are
     * known to expand to more than one character according to unctrl().
     */
    x = win->_curx;
    y = win->_cury;

    switch (t) {
    case '\t':
	x += (TABSIZE - (x % TABSIZE));

	/*
	 * Space-fill the tab on the bottom line so that we'll get the
	 * "correct" cursor position.
	 */
	if ((!win->_scroll && (y == win->_regbottom))
	    || (x <= win->_maxx)) {
	    NCURSES_CH_T blank = blankchar;
	    AddAttr(blank, AttrOf(ch));
	    while (win->_curx < x) {
		if (waddch_literal(win, blank) == ERR)
		    return (ERR);
	    }
	    break;
	} else {
	    wclrtoeol(win);
	    win->_flags |= _WRAPPED;
	    if (newline_forces_scroll(win, &y)) {
		x = win->_maxx;
		if (win->_scroll) {
		    scroll(win);
		    x = 0;
		}
	    } else {
		x = 0;
	    }
	}
	break;
    case '\n':
	wclrtoeol(win);
	if (newline_forces_scroll(win, &y)) {
	    if (win->_scroll)
		scroll(win);
	    else
		return (ERR);
	}
	/* FALLTHRU */
    case '\r':
	x = 0;
	win->_flags &= ~_WRAPPED;
	break;
    case '\b':
	if (x == 0)
	    return (OK);
	x--;
	win->_flags &= ~_WRAPPED;
	break;
    default:
	while (*s) {
	    NCURSES_CH_T sch;
	    SetChar(sch, *s++, AttrOf(ch));
	    if_EXT_COLORS(SetPair(sch, GetPair(ch)));
	    if (waddch_literal(win, sch) == ERR)
		return ERR;
	}
	return (OK);
    }

    win->_curx = x;
    win->_cury = y;

    return (OK);
}

NCURSES_EXPORT(int)
_nc_waddch_nosync(WINDOW *win, const NCURSES_CH_T c)
/* export copy of waddch_nosync() so the string-put functions can use it */
{
    return (waddch_nosync(win, c));
}

/*
 * The versions below call _nc_synchook().  We wanted to avoid this in the
 * version exported for string puts; they'll call _nc_synchook once at end
 * of run.
 */

/* These are actual entry points */

NCURSES_EXPORT(int)
waddch(WINDOW *win, const chtype ch)
{
    int code = ERR;
    NCURSES_CH_T wch;
    SetChar2(wch, ch);

    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_CALLED("waddch(%p, %s)"), win,
				      _tracechtype(ch)));

    if (win && (waddch_nosync(win, wch) != ERR)) {
	_nc_synchook(win);
	code = OK;
    }

    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_RETURN("%d"), code));
    return (code);
}

NCURSES_EXPORT(int)
wechochar(WINDOW *win, const chtype ch)
{
    int code = ERR;
    NCURSES_CH_T wch;
    SetChar2(wch, ch);

    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_CALLED("wechochar(%p, %s)"), win,
				      _tracechtype(ch)));

    if (win && (waddch_nosync(win, wch) != ERR)) {
	bool save_immed = win->_immed;
	win->_immed = TRUE;
	_nc_synchook(win);
	win->_immed = save_immed;
	code = OK;
    }
    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_RETURN("%d"), code));
    return (code);
}
@


1.4
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_addch.c,v 1.3 2000/06/19 03:53:38 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
a30 5
/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/

d41 3
a43 1
MODULE_ID("$From: lib_addch.c,v 1.47 2000/12/10 02:43:26 tom Exp $")
d56 1
a56 1
#define COLOR_MASK(ch) (~(chtype)((ch)&A_COLOR?A_COLOR:0))
d58 2
a59 2
static inline chtype
render_char(WINDOW *win, chtype ch)
d62 2
a63 1
    chtype a = win->_attrs;
d65 9
a73 3
    if (ch == ' ') {
	/* color in attrs has precedence over bkgd */
	ch = a | (win->_bkgd & COLOR_MASK(a));
d75 2
a76 2
	/* color in attrs has precedence over bkgd */
	a |= (win->_bkgd & A_ATTRIBUTES) & COLOR_MASK(a);
d78 12
a89 1
	ch |= (a & COLOR_MASK(ch));
d92 8
a99 2
    TR(TRACE_VIRTPUT, ("bkg = %lx, attrs = %lx -> ch = %lx", win->_bkgd,
		       win->_attrs, ch));
d104 2
a105 11
NCURSES_EXPORT(chtype)
_nc_background
(WINDOW *win)
/* make render_char() visible while still allowing us to inline it below */
{
    return (win->_bkgd);
}

NCURSES_EXPORT(chtype)
_nc_render
(WINDOW *win, chtype ch)
d127 119
a245 2
static inline int
waddch_literal(WINDOW *win, chtype ch)
d248 1
d252 1
d254 1
a254 13
    CHECK_POSITION(win, x, win->_cury);

    /*
     * If we're trying to add a character at the lower-right corner more
     * than once, fail.  (Moving the cursor will clear the flag).
     */
#if 0				/* Solaris 2.6 allows updating the corner more than once */
    if (win->_flags & _WRAPPED) {
	if (x >= win->_maxx)
	    return (ERR);
	win->_flags &= ~_WRAPPED;
    }
#endif
a256 1
    TR(TRACE_VIRTPUT, ("win attr = %s", _traceattr(win->_attrs)));
d258 1
a258 1
    line = win->_line + win->_cury;
d262 112
d375 10
a385 1
    TR(TRACE_VIRTPUT, ("(%d, %d) = %s", win->_cury, x, _tracechtype(ch)));
d387 1
a387 20
	/*
	 * The _WRAPPED flag is useful only for telling an application that
	 * we've just wrapped the cursor.  We don't do anything with this flag
	 * except set it when wrapping, and clear it whenever we move the
	 * cursor.  If we try to wrap at the lower-right corner of a window, we
	 * cannot move the cursor (since that wouldn't be legal).  So we return
	 * an error (which is what SVr4 does).  Unlike SVr4, we can
	 * successfully add a character to the lower-right corner (Solaris 2.6
	 * does this also, however).
	 */
	win->_flags |= _WRAPPED;
	if (++win->_cury > win->_regbottom) {
	    win->_cury = win->_regbottom;
	    win->_curx = win->_maxx;
	    if (!win->_scroll)
		return (ERR);
	    scroll(win);
	}
	win->_curx = 0;
	return (OK);
d393 2
a394 2
static inline int
waddch_nosync(WINDOW *win, const chtype ch)
d397 24
a420 7
    int x, y;
    chtype t = 0;
    const char *s = 0;

    if ((ch & A_ALTCHARSET)
	|| ((t = TextOf(ch)) > 127)
	|| ((s = unctrl(t))[1] == 0))
d423 4
d440 2
a441 1
	    chtype blank = (' ' | AttrOf(ch));
d450 1
a450 1
	    if (++y > win->_regbottom) {
a451 1
		y--;
d463 1
a463 2
	if (++y > win->_regbottom) {
	    y--;
d481 5
a485 2
	while (*s)
	    if (waddch_literal(win, (*s++) | AttrOf(ch)) == ERR)
d487 1
d498 1
a498 2
_nc_waddch_nosync
(WINDOW *win, const chtype c)
d505 1
a505 1
 * The versions below call _nc_synhook().  We wanted to avoid this in the
d513 1
a513 2
waddch
(WINDOW *win, const chtype ch)
d516 2
d522 1
a522 1
    if (win && (waddch_nosync(win, ch) != ERR)) {
d532 1
a532 2
wechochar
(WINDOW *win, const chtype ch)
d535 2
d541 1
a541 1
    if (win && (waddch_nosync(win, ch) != ERR)) {
@


1.3
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_addch.c,v 1.2 1999/08/15 11:40:55 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_addch.c,v 1.44 2000/05/20 21:13:11 tom Exp $")
d78 1
a78 1
	    win->_attrs, ch));
d83 3
a85 2
chtype
_nc_background(WINDOW *win)
d91 3
a93 2
chtype
_nc_render(WINDOW *win, chtype ch)
d129 1
a129 1
#if 0	/* Solaris 2.6 allows updating the corner more than once */
d178 1
a178 1
    int t = 0;
d253 3
a255 2
int
_nc_waddch_nosync(WINDOW *win, const chtype c)
d269 3
a271 2
int
waddch(WINDOW *win, const chtype ch)
d276 1
a276 1
	    _tracechtype(ch)));
d287 3
a289 2
int
wechochar(WINDOW *win, const chtype ch)
d294 1
a294 1
	    _tracechtype(ch)));
@


1.2
log
@Update to ncurses-5.0-990814
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_addch.c,v 1.1 1999/01/18 19:09:34 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d46 1
a46 1
MODULE_ID("$From: lib_addch.c,v 1.42 1999/07/24 20:01:05 tom Exp $")
d61 2
a62 1
static inline chtype render_char(WINDOW *win, chtype ch)
d65 11
a75 14
	chtype a = win->_attrs;
	
	if (ch == ' ')
	{
		/* color in attrs has precedence over bkgd */
		ch = a | (win->_bkgd & COLOR_MASK(a));
	}
	else
	{
		/* color in attrs has precedence over bkgd */
		a |= (win->_bkgd & A_ATTRIBUTES) & COLOR_MASK(a);
		/* color in ch has precedence */
		ch |= (a & COLOR_MASK(ch));
	}
d77 2
a78 2
	TR(TRACE_VIRTPUT, ("bkg = %lx, attrs = %lx -> ch = %lx", win->_bkgd,
		win->_attrs, ch));
d80 1
a80 1
	return(ch);
d83 2
a84 1
chtype _nc_background(WINDOW *win)
d87 1
a87 1
	return (win->_bkgd);
d90 2
a91 1
chtype _nc_render(WINDOW *win, chtype ch)
d94 1
a94 1
	return render_char(win, ch);
d110 1
a110 1
#define CHECK_POSITION(win, x, y) /* nothing */
d113 2
a114 2
static inline
int waddch_literal(WINDOW *win, chtype ch)
d116 6
a121 2
	int x;
	struct ldat *line;
d123 16
a138 1
	x = win->_curx;
d140 1
a140 1
	CHECK_POSITION(win, x, win->_cury);
d142 4
d147 8
a154 2
	 * If we're trying to add a character at the lower-right corner more
	 * than once, fail.  (Moving the cursor will clear the flag).
d156 7
a162 37
	if (win->_flags & _WRAPPED) {
		if (x >= win->_maxx)
			return (ERR);
		win->_flags &= ~_WRAPPED;
	}

	ch = render_char(win, ch);
	TR(TRACE_VIRTPUT, ("win attr = %s", _traceattr(win->_attrs)));

	line = win->_line+win->_cury;
	
	CHANGED_CELL(line,x);

	line->text[x++] = ch;
	
	TR(TRACE_VIRTPUT, ("(%d, %d) = %s", win->_cury, x, _tracechtype(ch)));
	if (x > win->_maxx) {
		/*
		 * The _WRAPPED flag is useful only for telling an application
		 * that we've just wrapped the cursor.  We don't do anything
		 * with this flag except set it when wrapping, and clear it
		 * whenever we move the cursor.  If we try to wrap at the
		 * lower-right corner of a window, we cannot move the cursor
		 * (since that wouldn't be legal).  So we return an error
		 * (which is what SVr4 does).  Unlike SVr4, we can successfully
		 * add a character to the lower-right corner.
		 */
		win->_flags |= _WRAPPED;
		if (++win->_cury > win->_regbottom) {
			win->_cury = win->_regbottom;
			win->_curx = win->_maxx;
			if (!win->_scroll)
				return (ERR);
			scroll(win);
		}
		win->_curx = 0;
		return (OK);
d164 5
a168 2
	win->_curx = x;
	return OK;
d171 2
a172 2
static inline
int waddch_nosync(WINDOW *win, const chtype ch)
d175 37
a211 51
	int	x, y;
	int	t = 0;
	const char *s = 0;

	if ((ch & A_ALTCHARSET)
	    || ((t = TextOf(ch)) > 127)
	    || ((s = unctrl(t))[1] == 0))
		return waddch_literal(win, ch);

	x = win->_curx;
	y = win->_cury;

	switch (t) {
	case '\t':
		x += (TABSIZE-(x%TABSIZE));

		/*
		 * Space-fill the tab on the bottom line so that we'll get the
		 * "correct" cursor position.
		 */
		if ((! win->_scroll && (y == win->_regbottom))
		 || (x <= win->_maxx)) {
			chtype blank = (' ' | AttrOf(ch));
			while (win->_curx < x) {
				if (waddch_literal(win, blank) == ERR)
					return(ERR);
			}
			break;
		} else {
			wclrtoeol(win);
			win->_flags |= _WRAPPED;
			if (++y > win->_regbottom) {
				x = win->_maxx;
				y--;
				if (win->_scroll) {
					scroll(win);
					x = 0;
				}
			} else {
				x = 0;
			}
		}
		break;
	case '\n':
		wclrtoeol(win);
		if (++y > win->_regbottom) {
			y--;
			if (win->_scroll)
				scroll(win);
			else
				return (ERR);
d213 1
a213 2
		/* FALLTHRU */
	case '\r':
d215 11
a225 13
		win->_flags &= ~_WRAPPED;
		break;
	case '\b':
		if (x == 0)
			return (OK);
		x--;
		win->_flags &= ~_WRAPPED;
		break;
	default:
		while (*s)
			if (waddch_literal(win, (*s++)|AttrOf(ch)) == ERR)
				return ERR;
		return(OK);
d227 17
d245 2
a246 2
	win->_curx = x;
	win->_cury = y;
d248 1
a248 1
	return(OK);
d251 2
a252 1
int _nc_waddch_nosync(WINDOW *win, const chtype c)
d255 1
a255 1
    return(waddch_nosync(win, c));
d266 2
a267 1
int waddch(WINDOW *win, const chtype ch)
d269 1
a269 1
	int code = ERR;
d271 2
a272 1
	TR(TRACE_VIRTPUT|TRACE_CCALLS, (T_CALLED("waddch(%p, %s)"), win, _tracechtype(ch)));
d274 4
a277 5
	if (win && (waddch_nosync(win, ch) != ERR))
	{
		_nc_synchook(win);
		code = OK;
	}
d279 2
a280 2
	TR(TRACE_VIRTPUT|TRACE_CCALLS, (T_RETURN("%d"), code));
	return(code);
d283 2
a284 1
int wechochar(WINDOW *win, const chtype ch)
d286 1
a286 1
	int code = ERR;
d288 2
a289 1
	TR(TRACE_VIRTPUT|TRACE_CCALLS, (T_CALLED("wechochar(%p, %s)"), win, _tracechtype(ch)));
d291 9
a299 10
	if (win && (waddch_nosync(win, ch) != ERR))
	{
		bool	save_immed = win->_immed;
		win->_immed = TRUE;
		_nc_synchook(win);
		win->_immed = save_immed;
		code = OK;
	}
	TR(TRACE_VIRTPUT|TRACE_CCALLS, (T_RETURN("%d"), code));
	return(code);
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_addch.c,v 1.5 1998/07/23 21:18:25 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_addch.c,v 1.41 1998/06/28 00:10:21 tom Exp $")
d174 2
a175 2
	int	t;
	const char *s;
@

