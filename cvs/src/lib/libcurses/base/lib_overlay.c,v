head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.32
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.28
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.24
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.26
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.18
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.22
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.20
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.16
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.14
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.12
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.10
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.6
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.38
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.34
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.32
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.30
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.28
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.26
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.24
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.22
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.20
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.18
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.16
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.14
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.12
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.10
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.8
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.6
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.22.18.01.42;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.09.55;	author millert;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/

/*
**	lib_overlay.c
**
**	The routines overlay(), copywin(), and overwrite().
**
*/

#include <curses.priv.h>

MODULE_ID("$Id: lib_overlay.c,v 1.27 2008/06/07 23:30:34 tom Exp $")

static int
overlap(const WINDOW *const src, WINDOW *const dst, int const flag)
{
    int rc = ERR;
    int sx1, sy1, sx2, sy2;
    int dx1, dy1, dx2, dy2;
    int sminrow, smincol;
    int dminrow, dmincol;
    int dmaxrow, dmaxcol;

    T((T_CALLED("overlap(%p,%p,%d)"), src, dst, flag));

    if (src != 0 && dst != 0) {
	_nc_lock_global(curses);

	T(("src : begy %ld, begx %ld, maxy %ld, maxx %ld",
	   (long) src->_begy,
	   (long) src->_begx,
	   (long) src->_maxy,
	   (long) src->_maxx));
	T(("dst : begy %ld, begx %ld, maxy %ld, maxx %ld",
	   (long) dst->_begy,
	   (long) dst->_begx,
	   (long) dst->_maxy,
	   (long) dst->_maxx));

	sx1 = src->_begx;
	sy1 = src->_begy;
	sx2 = sx1 + src->_maxx;
	sy2 = sy1 + src->_maxy;

	dx1 = dst->_begx;
	dy1 = dst->_begy;
	dx2 = dx1 + dst->_maxx;
	dy2 = dy1 + dst->_maxy;

	if (dx2 >= sx1 && dx1 <= sx2 && dy2 >= sy1 && dy1 <= sy2) {
	    sminrow = max(sy1, dy1) - sy1;
	    smincol = max(sx1, dx1) - sx1;
	    dminrow = max(sy1, dy1) - dy1;
	    dmincol = max(sx1, dx1) - dx1;
	    dmaxrow = min(sy2, dy2) - dy1;
	    dmaxcol = min(sx2, dx2) - dx1;

	    rc = copywin(src, dst,
			 sminrow, smincol,
			 dminrow, dmincol,
			 dmaxrow, dmaxcol,
			 flag);
	}
	_nc_unlock_global(curses);
    }
    returnCode(rc);
}

/*
**
**	overlay(win1, win2)
**
**
**	overlay() writes the overlapping area of win1 behind win2
**	on win2 non-destructively.
**
**/

NCURSES_EXPORT(int)
overlay(const WINDOW *win1, WINDOW *win2)
{
    T((T_CALLED("overlay(%p,%p)"), win1, win2));
    returnCode(overlap(win1, win2, TRUE));
}

/*
**
**	overwrite(win1, win2)
**
**
**	overwrite() writes the overlapping area of win1 behind win2
**	on win2 destructively.
**
**/

NCURSES_EXPORT(int)
overwrite(const WINDOW *win1, WINDOW *win2)
{
    T((T_CALLED("overwrite(%p,%p)"), win1, win2));
    returnCode(overlap(win1, win2, FALSE));
}

NCURSES_EXPORT(int)
copywin(const WINDOW *src, WINDOW *dst,
	int sminrow, int smincol,
	int dminrow, int dmincol,
	int dmaxrow, int dmaxcol,
	int over)
{
    int rc = ERR;
    int sx, sy, dx, dy;
    bool touched;
    attr_t bk;
    attr_t mask;

    T((T_CALLED("copywin(%p, %p, %d, %d, %d, %d, %d, %d, %d)"),
       src, dst, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol, over));

    if (src && dst) {
	_nc_lock_global(curses);

	bk = AttrOf(dst->_nc_bkgd);
	mask = ~(attr_t) ((bk & A_COLOR) ? A_COLOR : 0);

	/* make sure rectangle exists in source */
	if ((sminrow + dmaxrow - dminrow) <= (src->_maxy + 1) &&
	    (smincol + dmaxcol - dmincol) <= (src->_maxx + 1)) {

	    T(("rectangle exists in source"));

	    /* make sure rectangle fits in destination */
	    if (dmaxrow <= dst->_maxy && dmaxcol <= dst->_maxx) {

		T(("rectangle fits in destination"));

		for (dy = dminrow, sy = sminrow;
		     dy <= dmaxrow;
		     sy++, dy++) {

		    touched = FALSE;
		    for (dx = dmincol, sx = smincol;
			 dx <= dmaxcol;
			 sx++, dx++) {
			if (over) {
			    if ((CharOf(src->_line[sy].text[sx]) != L(' ')) &&
				(!CharEq(dst->_line[dy].text[dx],
					 src->_line[sy].text[sx]))) {
				dst->_line[dy].text[dx] =
				    src->_line[sy].text[sx];
				SetAttr(dst->_line[dy].text[dx],
					((AttrOf(src->_line[sy].text[sx]) &
					  mask) | bk));
				touched = TRUE;
			    }
			} else {
			    if (!CharEq(dst->_line[dy].text[dx],
					src->_line[sy].text[sx])) {
				dst->_line[dy].text[dx] =
				    src->_line[sy].text[sx];
				touched = TRUE;
			    }
			}
		    }
		    if (touched) {
			touchline(dst, dminrow, (dmaxrow - dminrow + 1));
		    }
		}
		T(("finished copywin"));
		rc = OK;
	    }
	}
	_nc_unlock_global(curses);
    }
    returnCode(rc);
}
@


1.2
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_overlay.c,v 1.1 1999/01/18 19:09:55 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d45 1
a45 1
MODULE_ID("$From: lib_overlay.c,v 1.14 2000/12/10 02:43:27 tom Exp $")
d48 1
a48 1
overlap(const WINDOW *const s, WINDOW *const d, int const flag)
d50 50
a99 19
    int sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol;

    T(("overlap : sby %d, sbx %d, smy %d, smx %d, dby %d, dbx %d, dmy %d, dmx %d",
       s->_begy, s->_begx, s->_maxy, s->_maxx,
       d->_begy, d->_begx, d->_maxy, d->_maxx));

    if (!s || !d)
	returnCode(ERR);

    sminrow = max(s->_begy, d->_begy) - s->_begy;
    smincol = max(s->_begx, d->_begx) - s->_begx;
    dminrow = max(s->_begy, d->_begy) - d->_begy;
    dmincol = max(s->_begx, d->_begx) - d->_begx;
    dmaxrow = min(s->_maxy + s->_begy, d->_maxy + d->_begy) - d->_begy;
    dmaxcol = min(s->_maxx + s->_begx, d->_maxx + d->_begx) - d->_begx;

    return (copywin(s, d,
		    sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol,
		    flag));
d137 5
a141 5
copywin
(const WINDOW *src, WINDOW *dst,
 int sminrow, int smincol,
 int dminrow, int dmincol, int dmaxrow, int dmaxcol,
 int over)
d143 1
d146 2
a147 2
    chtype bk = AttrOf(dst->_bkgd);
    chtype mask = ~(chtype) ((bk & A_COLOR) ? A_COLOR : 0);
d152 2
a153 15
    if (!src || !dst)
	returnCode(ERR);

    /* make sure rectangle exists in source */
    if ((sminrow + dmaxrow - dminrow) > (src->_maxy + 1) ||
	(smincol + dmaxcol - dmincol) > (src->_maxx + 1)) {
	returnCode(ERR);
    }

    T(("rectangle exists in source"));

    /* make sure rectangle fits in destination */
    if (dmaxrow > dst->_maxy || dmaxcol > dst->_maxx) {
	returnCode(ERR);
    }
d155 2
a156 1
    T(("rectangle fits in destination"));
d158 42
a199 14
    for (dy = dminrow, sy = sminrow; dy <= dmaxrow; sy++, dy++) {
	touched = FALSE;
	for (dx = dmincol, sx = smincol; dx <= dmaxcol; sx++, dx++) {
	    if (over) {
		if ((TextOf(src->_line[sy].text[sx]) != ' ') &&
		    (dst->_line[dy].text[dx] != src->_line[sy].text[sx])) {
		    dst->_line[dy].text[dx] =
			(src->_line[sy].text[sx] & mask) | bk;
		    touched = TRUE;
		}
	    } else {
		if (dst->_line[dy].text[dx] != src->_line[sy].text[sx]) {
		    dst->_line[dy].text[dx] = src->_line[sy].text[sx];
		    touched = TRUE;
d201 2
d205 1
a205 3
	if (touched) {
	    touchline(dst, 0, getmaxy(dst));
	}
d207 1
a207 2
    T(("finished copywin"));
    returnCode(OK);
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_overlay.c,v 1.6 1998/07/23 21:19:09 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 1

d45 1
a45 1
MODULE_ID("$From: lib_overlay.c,v 1.12 1998/02/11 12:13:59 tom Exp $")
d47 2
a48 1
static int overlap(const WINDOW *const s, WINDOW *const d, int const flag)
d50 1
a50 1
int sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol;
d52 17
a68 17
	T(("overlap : sby %d, sbx %d, smy %d, smx %d, dby %d, dbx %d, dmy %d, dmx %d",
		s->_begy, s->_begx, s->_maxy, s->_maxx,
		d->_begy, d->_begx, d->_maxy, d->_maxx));
	
	if (!s || !d)
		returnCode(ERR);

	sminrow = max(s->_begy, d->_begy) - s->_begy;
	smincol = max(s->_begx, d->_begx) - s->_begx;
	dminrow = max(s->_begy, d->_begy) - d->_begy;
	dmincol = max(s->_begx, d->_begx) - d->_begx;
	dmaxrow = min(s->_maxy+s->_begy, d->_maxy+d->_begy) - d->_begy;
	dmaxcol = min(s->_maxx+s->_begx, d->_maxx+d->_begx) - d->_begx;

	return(copywin(s, d,
		       sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol,
		       flag));
d81 2
a82 1
int overlay(const WINDOW *win1, WINDOW *win2)
d84 2
a85 2
	T((T_CALLED("overlay(%p,%p)"), win1, win2));
	returnCode(overlap(win1, win2, TRUE));
d98 2
a99 1
int overwrite(const WINDOW *win1, WINDOW *win2)
d101 2
a102 2
	T((T_CALLED("overwrite(%p,%p)"), win1, win2));
	returnCode(overlap(win1, win2, FALSE));
d105 6
a110 4
int copywin(const WINDOW *src, WINDOW *dst,
	int sminrow, int smincol,
	int dminrow, int dmincol, int dmaxrow, int dmaxcol,
	int over)
d112 42
a153 22
int sx, sy, dx, dy;
bool touched;
chtype bk = AttrOf(dst->_bkgd);
chtype mask = ~(chtype)((bk&A_COLOR) ? A_COLOR : 0);

	T((T_CALLED("copywin(%p, %p, %d, %d, %d, %d, %d, %d, %d)"),
		src, dst, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol, over));

	if (!src || !dst)
	  returnCode(ERR);

	/* make sure rectangle exists in source */
	if ((sminrow + dmaxrow - dminrow) > (src->_maxy + 1) ||
	    (smincol + dmaxcol - dmincol) > (src->_maxx + 1)) {
		returnCode(ERR);
	}

	T(("rectangle exists in source"));

	/* make sure rectangle fits in destination */
	if (dmaxrow > dst->_maxy || dmaxcol > dst->_maxx) {
		returnCode(ERR);
d155 2
a156 29

	T(("rectangle fits in destination"));

	for (dy = dminrow, sy = sminrow; dy <= dmaxrow; sy++, dy++) {
	   touched = FALSE;
	   for(dx=dmincol, sx=smincol; dx <= dmaxcol; sx++, dx++)
	   {
		if (over)
		{
		   if ((TextOf(src->_line[sy].text[sx]) != ' ') &&
                       (dst->_line[dy].text[dx]!=src->_line[sy].text[sx]))
		   {
			dst->_line[dy].text[dx] =
					(src->_line[sy].text[sx] & mask) | bk;
			touched = TRUE;
		   }
	        }
		else {
		   if (dst->_line[dy].text[dx] != src->_line[sy].text[sx])
		   {
			dst->_line[dy].text[dx] = src->_line[sy].text[sx];
			touched = TRUE;
                   }
                }
           }
	   if (touched)
	   {
	      touchline(dst,0,getmaxy(dst));
	   }
d158 3
a160 2
	T(("finished copywin"));
	returnCode(OK);
@

