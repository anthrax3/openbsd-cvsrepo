head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.28
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.24
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.26
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.18
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.22
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.4.0.38
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.34
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.32
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.30
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.28
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.26
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.24
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.22
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.20
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.18
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.16
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.14
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.12
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.10
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.11.18.34.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.22.18.01.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.19.03.53.43;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.11.28.17.49.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.09.54;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/*	$OpenBSD: lib_newwin.c,v 1.5 2009/11/11 18:34:10 deraadt Exp $	*/

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
**	lib_newwin.c
**
**	The routines newwin(), subwin() and their dependent
**
*/

#include <curses.priv.h>
#include <stddef.h>

MODULE_ID("$Id: lib_newwin.c,v 1.52 2008/06/07 13:58:09 tom Exp $")

#define window_is(name) ((sp)->_##name == win)

#if USE_REENTRANT
#define remove_window(name) \
		sp->_##name = 0
#else
#define remove_window(name) \
		sp->_##name = 0; \
		if (win == name) \
		    name = 0
#endif

static void
remove_window_from_screen(WINDOW *win)
{
    SCREEN *sp;

    for (each_screen(sp)) {
	if (window_is(curscr)) {
	    remove_window(curscr);
	    break;
	} else if (window_is(stdscr)) {
	    remove_window(stdscr);
	    break;
	} else if (window_is(newscr)) {
	    remove_window(newscr);
	    break;
	}
    }
}

NCURSES_EXPORT(int)
_nc_freewin(WINDOW *win)
{
    WINDOWLIST *p, *q;
    int i;
    int result = ERR;

    T((T_CALLED("_nc_freewin(%p)"), win));

    if (win != 0) {
	if (_nc_try_global(curses) == 0) {
	    q = 0;
	    for (each_window(p)) {
		if (&(p->win) == win) {
		    remove_window_from_screen(win);
		    if (q == 0)
			_nc_windows = p->next;
		    else
			q->next = p->next;

		    if (!(win->_flags & _SUBWIN)) {
			for (i = 0; i <= win->_maxy; i++)
			    FreeIfNeeded(win->_line[i].text);
		    }
		    free(win->_line);
		    free(p);

		    result = OK;
		    T(("...deleted win=%p", win));
		    break;
		}
		q = p;
	    }
	    _nc_unlock_global(curses);
	}
    }
    returnCode(result);
}

NCURSES_EXPORT(WINDOW *)
newwin(int num_lines, int num_columns, int begy, int begx)
{
    WINDOW *win;
    NCURSES_CH_T *ptr;
    int i;

    T((T_CALLED("newwin(%d,%d,%d,%d)"), num_lines, num_columns, begy, begx));

    if (begy < 0 || begx < 0 || num_lines < 0 || num_columns < 0)
	returnWin(0);

    if (num_lines == 0)
	num_lines = SP->_lines_avail - begy;
    if (num_columns == 0)
	num_columns = screen_columns - begx;

    if ((win = _nc_makenew(num_lines, num_columns, begy, begx, 0)) == 0)
	returnWin(0);

    for (i = 0; i < num_lines; i++) {
	win->_line[i].text = typeCalloc(NCURSES_CH_T, (unsigned) num_columns);
	if (win->_line[i].text == 0) {
	    (void) _nc_freewin(win);
	    returnWin(0);
	}
	for (ptr = win->_line[i].text;
	     ptr < win->_line[i].text + num_columns;
	     ptr++)
	    SetChar(*ptr, BLANK_TEXT, BLANK_ATTR);
    }

    returnWin(win);
}

NCURSES_EXPORT(WINDOW *)
derwin(WINDOW *orig, int num_lines, int num_columns, int begy, int begx)
{
    WINDOW *win;
    int i;
    int flags = _SUBWIN;

    T((T_CALLED("derwin(%p,%d,%d,%d,%d)"), orig, num_lines, num_columns,
       begy, begx));

    /*
     * make sure window fits inside the original one
     */
    if (begy < 0 || begx < 0 || orig == 0 || num_lines < 0 || num_columns < 0)
	returnWin(0);
    if (begy + num_lines > orig->_maxy + 1
	|| begx + num_columns > orig->_maxx + 1)
	returnWin(0);

    if (num_lines == 0)
	num_lines = orig->_maxy + 1 - begy;

    if (num_columns == 0)
	num_columns = orig->_maxx + 1 - begx;

    if (orig->_flags & _ISPAD)
	flags |= _ISPAD;

    if ((win = _nc_makenew(num_lines, num_columns, orig->_begy + begy,
			   orig->_begx + begx, flags)) == 0)
	returnWin(0);

    win->_pary = begy;
    win->_parx = begx;
    WINDOW_ATTRS(win) = WINDOW_ATTRS(orig);
    win->_nc_bkgd = orig->_nc_bkgd;

    for (i = 0; i < num_lines; i++)
	win->_line[i].text = &orig->_line[begy++].text[begx];

    win->_parent = orig;

    returnWin(win);
}

NCURSES_EXPORT(WINDOW *)
subwin(WINDOW *w, int l, int c, int y, int x)
{
    T((T_CALLED("subwin(%p, %d, %d, %d, %d)"), w, l, c, y, x));
    T(("parent has begy = %ld, begx = %ld", (long) w->_begy, (long) w->_begx));

    returnWin(derwin(w, l, c, y - w->_begy, x - w->_begx));
}

static bool
dimension_limit(int value)
{
    NCURSES_SIZE_T test = value;
    return (test == value && value > 0);
}

NCURSES_EXPORT(WINDOW *)
_nc_makenew(int num_lines, int num_columns, int begy, int begx, int flags)
{
    int i;
    WINDOWLIST *wp;
    WINDOW *win;
    bool is_pad = (flags & _ISPAD);

    T((T_CALLED("_nc_makenew(%d,%d,%d,%d)"), num_lines, num_columns, begy, begx));

    if (SP == 0)
	returnWin(0);

    if (!dimension_limit(num_lines) || !dimension_limit(num_columns))
	returnWin(0);

    if ((wp = typeCalloc(WINDOWLIST, 1)) == 0)
	returnWin(0);

    win = &(wp->win);

    if ((win->_line = typeCalloc(struct ldat, ((unsigned) num_lines))) == 0) {
	free(wp);
	returnWin(0);
    }

    _nc_lock_global(curses);

    win->_curx = 0;
    win->_cury = 0;
    win->_maxy = num_lines - 1;
    win->_maxx = num_columns - 1;
    win->_begy = begy;
    win->_begx = begx;
    win->_yoffset = SP->_topstolen;

    win->_flags = flags;
    WINDOW_ATTRS(win) = A_NORMAL;
    SetChar(win->_nc_bkgd, BLANK_TEXT, BLANK_ATTR);

    win->_clear = is_pad ? FALSE : (num_lines == screen_lines
				    && num_columns == screen_columns);
    win->_idlok = FALSE;
    win->_idcok = TRUE;
    win->_scroll = FALSE;
    win->_leaveok = FALSE;
    win->_use_keypad = FALSE;
    win->_delay = -1;
    win->_immed = FALSE;
    win->_sync = 0;
    win->_parx = -1;
    win->_pary = -1;
    win->_parent = 0;

    win->_regtop = 0;
    win->_regbottom = num_lines - 1;

    win->_pad._pad_y = -1;
    win->_pad._pad_x = -1;
    win->_pad._pad_top = -1;
    win->_pad._pad_bottom = -1;
    win->_pad._pad_left = -1;
    win->_pad._pad_right = -1;

    for (i = 0; i < num_lines; i++) {
	/*
	 * This used to do
	 *
	 * win->_line[i].firstchar = win->_line[i].lastchar = _NOCHANGE;
	 *
	 * which marks the whole window unchanged.  That's how
	 * SVr1 curses did it, but SVr4 curses marks the whole new
	 * window changed.
	 *
	 * With the old SVr1-like code, say you have stdscr full of
	 * characters, then create a new window with newwin(),
	 * then do a printw(win, "foo        ");, the trailing spaces are
	 * completely ignored by the following refreshes.  So, you
	 * get "foojunkjunk" on the screen instead of "foo        " as
	 * you actually intended.
	 *
	 * SVr4 doesn't do this.  Instead the spaces are actually written.
	 * So that's how we want ncurses to behave.
	 */
	win->_line[i].firstchar = 0;
	win->_line[i].lastchar = num_columns - 1;

	if_USE_SCROLL_HINTS(win->_line[i].oldindex = i);
    }

    if (!is_pad && (begx + num_columns == screen_columns)) {
	win->_flags |= _ENDLINE;

	if (begx == 0 && num_lines == screen_lines && begy == 0)
	    win->_flags |= _FULLWIN;

	if (begy + num_lines == screen_lines)
	    win->_flags |= _SCROLLWIN;
    }

    wp->next = _nc_windows;
    wp->screen = SP;
    _nc_windows = wp;

    T((T_CREATE("window %p"), win));

    _nc_unlock_global(curses);
    returnWin(win);
}

/*
 * wgetch() and other functions with a WINDOW* parameter may use a SCREEN*
 * internally, and it is useful to allow those to be invoked without switching
 * SCREEN's, e.g., for multi-threaded applications.
 */
NCURSES_EXPORT(SCREEN *)
_nc_screen_of(WINDOW *win)
{
    SCREEN *sp = 0;

    if (win != 0) {
	WINDOWLIST *wp = (WINDOWLIST *) win;
	sp = wp->screen;
    }
    return (sp);
}
@


1.5
log
@memory leaks, found by parfait; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_newwin.c,v 1.4 2001/01/22 18:01:42 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d45 1
d47 32
a78 1
MODULE_ID("$From: lib_newwin.c,v 1.27 2000/12/10 02:43:27 tom Exp $")
d87 2
d90 20
a109 11
	for (p = _nc_windows, q = 0; p != 0; q = p, p = p->next) {
	    if (p->win == win) {
		if (q == 0)
		    _nc_windows = p->next;
		else
		    q->next = p->next;
		free(p);

		if (!(win->_flags & _SUBWIN)) {
		    for (i = 0; i <= win->_maxy; i++)
			FreeIfNeeded(win->_line[i].text);
d111 1
a111 13
		free(win->_line);
		free(win);

		if (win == curscr)
		    curscr = 0;
		if (win == stdscr)
		    stdscr = 0;
		if (win == newscr)
		    newscr = 0;

		result = OK;
		T(("...deleted win=%p", win));
		break;
d113 1
d116 1
a116 1
    return result;
d120 1
a120 2
newwin
(int num_lines, int num_columns, int begy, int begx)
d123 1
a123 1
    chtype *ptr;
a135 3
    if (num_columns + begx > SP->_columns || num_lines + begy > SP->_lines_avail)
	returnWin(0);

d140 1
a140 1
	win->_line[i].text = typeCalloc(chtype, (unsigned) num_columns);
d145 4
a148 3
	for (ptr = win->_line[i].text; ptr < win->_line[i].text +
	     num_columns;)
	    *ptr++ = ' ';
a150 2
    T(("newwin: returned window is %p", win));

d155 1
a155 2
derwin
(WINDOW *orig, int num_lines, int num_columns, int begy, int begx)
d165 1
a165 1
       ** make sure window fits inside the original one
d188 2
a189 2
    win->_attrs = orig->_attrs;
    win->_bkgd = orig->_bkgd;
a195 2
    T(("derwin: returned window is %p", win));

d200 1
a200 2
subwin
(WINDOW *w, int l, int c, int y, int x)
d203 1
a203 1
    T(("parent has begy = %d, begx = %d", w->_begy, w->_begx));
d216 1
a216 2
_nc_makenew
(int num_lines, int num_columns, int begy, int begx, int flags)
d223 4
a226 1
    T(("_nc_makenew(%d,%d,%d,%d)", num_lines, num_columns, begy, begx));
d229 1
a229 1
	return 0;
d232 1
a232 1
	return 0;
d234 1
a234 4
    if ((win = typeCalloc(WINDOW, 1)) == 0) {
	  free(wp);
	  return 0;
    }
d238 1
a238 2
	free(win);
	return 0;
d241 2
d252 2
a253 2
    win->_attrs = A_NORMAL;
    win->_bkgd = BLANK;
d316 1
a316 1
    wp->win = win;
d321 19
a339 1
    return (win);
@


1.4
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_newwin.c,v 1.3 2000/06/19 03:53:43 millert Exp $	*/
d208 2
a209 1
    if ((win = typeCalloc(WINDOW, 1)) == 0)
d211 1
d214 1
@


1.3
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_newwin.c,v 1.2 1999/11/28 17:49:53 millert Exp $	*/
d45 1
a45 1
MODULE_ID("$From: lib_newwin.c,v 1.24 2000/04/29 18:49:51 tom Exp $")
d47 1
a47 1
void
d52 1
d77 1
d83 1
d86 3
a88 2
WINDOW *
newwin(int num_lines, int num_columns, int begy, int begx)
d113 1
a113 1
	    _nc_freewin(win);
d117 1
a117 1
	    num_columns;)
d126 3
a128 2
WINDOW *
derwin(WINDOW *orig, int num_lines, int num_columns, int begy, int begx)
d135 1
a135 1
	    begy, begx));
d156 1
a156 1
		orig->_begx + begx, flags)) == 0)
d174 3
a176 2
WINDOW *
subwin(WINDOW *w, int l, int c, int y, int x)
d191 3
a193 2
WINDOW *
_nc_makenew(int num_lines, int num_columns, int begy, int begx, int flags)
d228 2
a229 2
    win->_clear = is_pad ? FALSE : (num_lines == screen_lines && num_columns
	== screen_columns);
@


1.2
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_newwin.c,v 1.1 1999/01/18 19:09:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 2


d45 1
a45 1
MODULE_ID("$From: lib_newwin.c,v 1.22 1999/11/25 13:48:24 juergen Exp $")
d47 2
a48 1
void _nc_freewin(WINDOW *win)
d50 2
a51 2
WINDOWLIST *p, *q;
int	i;
d53 12
a64 23
	if (win != 0) {
		for (p = _nc_windows, q = 0; p != 0; q = p, p = p->next) {
			if (p->win == win) {
				if (q == 0)
					_nc_windows = p->next;
				else
					q->next = p->next;
				free(p);

				if (! (win->_flags & _SUBWIN)) {
					for (i = 0; i <= win->_maxy; i++)
						FreeIfNeeded(win->_line[i].text);
				}
				free(win->_line);
				free(win);

				if (win == curscr) curscr = 0;
				if (win == stdscr) stdscr = 0;
				if (win == newscr) newscr = 0;

				T(("...deleted win=%p", win));
				break;
			}
d66 13
d80 1
d83 2
a84 1
WINDOW * newwin(int num_lines, int num_columns, int begy, int begx)
d86 25
a110 27
WINDOW	*win;
chtype	*ptr;
int	i;

	T((T_CALLED("newwin(%d,%d,%d,%d)"), num_lines, num_columns, begy, begx));

	if (begy < 0 || begx < 0 || num_lines < 0 || num_columns < 0)
		returnWin(0);

	if (num_lines == 0)
	    num_lines = SP->_lines_avail - begy;
	if (num_columns == 0)
	    num_columns = screen_columns - begx;

	if (num_columns + begx > SP->_columns || num_lines + begy > SP->_lines_avail)
		returnWin(0);

	if ((win = _nc_makenew(num_lines, num_columns, begy, begx, 0)) == 0)
		returnWin(0);

	for (i = 0; i < num_lines; i++) {
	    if ((win->_line[i].text = typeCalloc(chtype, (unsigned)num_columns)) == 0) {
		_nc_freewin(win);
		returnWin(0);
	    }
	    for (ptr = win->_line[i].text; ptr < win->_line[i].text + num_columns; )
		*ptr++ = ' ';
d112 4
d117 1
a117 1
	T(("newwin: returned window is %p", win));
d119 1
a119 1
	returnWin(win);
d122 2
a123 1
WINDOW * derwin(WINDOW *orig, int num_lines, int num_columns, int begy, int begx)
d125 3
a127 3
WINDOW	*win;
int	i;
int     flags = _SUBWIN;
d129 2
a130 1
	T((T_CALLED("derwin(%p,%d,%d,%d,%d)"), orig, num_lines, num_columns, begy, begx));
d132 8
a139 8
	/*
	** make sure window fits inside the original one
	*/
	if ( begy < 0 || begx < 0 || orig == 0 || num_lines < 0 || num_columns < 0)
	    returnWin(0);
	if ( begy + num_lines > orig->_maxy + 1
		|| begx + num_columns > orig->_maxx + 1)
	    returnWin(0);
d141 2
a142 2
	if (num_lines == 0)
	    num_lines = orig->_maxy + 1 - begy; 
d144 2
a145 2
	if (num_columns == 0)
	    num_columns = orig->_maxx + 1 - begx; 
d147 2
a148 2
	if (orig->_flags & _ISPAD)
	  flags |= _ISPAD;
d150 3
a152 2
	if ((win = _nc_makenew(num_lines, num_columns, orig->_begy + begy, orig->_begx + begx, flags)) == 0)
	    returnWin(0);
d154 4
a157 4
	win->_pary = begy;
	win->_parx = begx;
	win->_attrs = orig->_attrs;
	win->_bkgd = orig->_bkgd;
d159 2
a160 2
	for (i = 0; i < num_lines; i++)
	    win->_line[i].text = &orig->_line[begy++].text[begx];
d162 1
a162 1
	win->_parent = orig;
d164 1
a164 1
	T(("derwin: returned window is %p", win));
d166 1
a166 1
	returnWin(win);
d169 8
d178 2
a179 1
WINDOW *subwin(WINDOW *w, int l, int c, int y, int x)
d181 2
a182 4
	T((T_CALLED("subwin(%p, %d, %d, %d, %d)"), w, l, c, y, x));
	T(("parent has begy = %d, begx = %d", w->_begy, w->_begx));

	returnWin(derwin(w, l, c, y - w->_begy, x - w->_begx));
d188 56
a243 4
int	i;
WINDOWLIST *wp;
WINDOW	*win;
bool    is_pad = (flags & _ISPAD);
d245 39
a283 91
	T(("_nc_makenew(%d,%d,%d,%d)", num_lines, num_columns, begy, begx));

	if (num_lines <= 0 || num_columns <= 0)
		return 0;

	if ((wp = typeCalloc(WINDOWLIST, 1)) == 0)
		return 0;

	if ((win = typeCalloc(WINDOW, 1)) == 0)
		return 0;

	if ((win->_line = typeCalloc(struct ldat, ((unsigned)num_lines))) == 0) {
		free(win);
		return 0;
	}

	win->_curx       = 0;
	win->_cury       = 0;
	win->_maxy       = num_lines - 1;
	win->_maxx       = num_columns - 1;
	win->_begy       = begy;
	win->_begx       = begx;
	win->_yoffset    = SP->_topstolen;

	win->_flags      = flags;
	win->_attrs      = A_NORMAL;
	win->_bkgd       = BLANK;

	win->_clear      = is_pad ? FALSE : (num_lines == screen_lines  &&  num_columns == screen_columns);
	win->_idlok      = FALSE;
	win->_idcok      = TRUE;
	win->_scroll     = FALSE;
	win->_leaveok    = FALSE;
	win->_use_keypad = FALSE;
	win->_delay      = -1;
	win->_immed      = FALSE;
	win->_sync       = 0;
	win->_parx       = -1;
	win->_pary       = -1;
	win->_parent     = 0;

	win->_regtop     = 0;
	win->_regbottom  = num_lines - 1;

	win->_pad._pad_y      = -1;
	win->_pad._pad_x      = -1;
	win->_pad._pad_top    = -1;
	win->_pad._pad_bottom = -1;
	win->_pad._pad_left   = -1;
	win->_pad._pad_right  = -1;

	for (i = 0; i < num_lines; i++)
	{
	    /*
	     * This used to do
	     *
	     * win->_line[i].firstchar = win->_line[i].lastchar = _NOCHANGE;
	     *
	     * which marks the whole window unchanged.  That's how
	     * SVr1 curses did it, but SVr4 curses marks the whole new
	     * window changed.
	     *
	     * With the old SVr1-like code, say you have stdscr full of
	     * characters, then create a new window with newwin(),
	     * then do a printw(win, "foo        ");, the trailing spaces are
	     * completely ignored by the following refreshes.  So, you
	     * get "foojunkjunk" on the screen instead of "foo        " as
	     * you actually intended.
	     *
	     * SVr4 doesn't do this.  Instead the spaces are actually written.
	     * So that's how we want ncurses to behave.
	     */
	    win->_line[i].firstchar = 0;
	    win->_line[i].lastchar = num_columns-1;

	    if_USE_SCROLL_HINTS(win->_line[i].oldindex = i);
	}

	if (!is_pad && (begx + num_columns == screen_columns)) {
		win->_flags |= _ENDLINE;

		if (begx == 0  &&  num_lines == screen_lines  &&  begy == 0)
			win->_flags |= _FULLWIN;

		if (begy + num_lines == screen_lines)
			win->_flags |= _SCROLLWIN;
	}

	wp->next = _nc_windows;
	wp->win  = win;
	_nc_windows = wp;
d285 1
a285 1
	T((T_CREATE("window %p"), win));
d287 1
a287 1
	return(win);
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_newwin.c,v 1.4 1998/07/23 21:19:07 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: lib_newwin.c,v 1.20 1998/05/23 23:21:32 Alexander.V.Lukyanov Exp $")
d64 2
a65 2
					for (i = 0; i <= win->_maxy && win->_line[i].text; i++)
						free(win->_line[i].text);
@

