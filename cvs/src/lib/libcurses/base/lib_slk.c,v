head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.30
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.28
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.24
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.26
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.18
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.22
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.20
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.16
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.38
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.34
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.32
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.30
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.28
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.26
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.24
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.22
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.20
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.18
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.16
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.14
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.12
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.10
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.22.18.01.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.11.28.17.49.53;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.11.21.03.55;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.09.59;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2005,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Authors:                                                                *
 *          Gerhard Fuernkranz                      1993 (original)         *
 *          Zeyd M. Ben-Halim                       1992,1995 (sic)         *
 *          Eric S. Raymond                                                 *
 *          Juergen Pfeifer                         1996-on                 *
 *          Thomas E. Dickey                                                *
 ****************************************************************************/

/*
 *	lib_slk.c
 *	Soft key routines.
 */

#include <curses.priv.h>

#include <ctype.h>
#include <term.h>		/* num_labels, label_*, plab_norm */

MODULE_ID("$Id: lib_slk.c,v 1.35 2008/09/27 14:07:33 juergen Exp $")

/*
 * Free any memory related to soft labels, return an error.
 */
static int
slk_failed(void)
{
    if (SP->_slk) {
	FreeIfNeeded(SP->_slk->ent);
	free(SP->_slk);
	SP->_slk = (SLK *) 0;
    }
    return ERR;
}

/*
 * Initialize soft labels.
 * Called from newterm()
 */
NCURSES_EXPORT(int)
_nc_slk_initialize(WINDOW *stwin, int cols)
{
    int i, x;
    int res = OK;
    unsigned max_length;

    T((T_CALLED("_nc_slk_initialize()")));

    if (SP->_slk) {		/* we did this already, so simply return */
	returnCode(OK);
    } else if ((SP->_slk = typeCalloc(SLK, 1)) == 0)
	returnCode(ERR);

    SP->_slk->ent = NULL;

    /*
     * If we use colors, vidputs() will suppress video attributes that conflict
     * with colors.  In that case, we're still guaranteed that "reverse" would
     * work.
     */
    if ((no_color_video & 1) == 0)
	SetAttr(SP->_slk->attr, A_STANDOUT);
    else
	SetAttr(SP->_slk->attr, A_REVERSE);

    SP->_slk->maxlab = ((num_labels > 0)
			? num_labels
			: MAX_SKEY(_nc_globals.slk_format));
    SP->_slk->maxlen = ((num_labels > 0)
			? label_width * label_height
			: MAX_SKEY_LEN(_nc_globals.slk_format));
    SP->_slk->labcnt = ((SP->_slk->maxlab < MAX_SKEY(_nc_globals.slk_format))
			? MAX_SKEY(_nc_globals.slk_format)
			: SP->_slk->maxlab);

    if (SP->_slk->maxlen <= 0
	|| SP->_slk->labcnt <= 0
	|| (SP->_slk->ent = typeCalloc(slk_ent,
				       (unsigned) SP->_slk->labcnt)) == NULL)
	returnCode(slk_failed());

    max_length = SP->_slk->maxlen;
    for (i = 0; i < SP->_slk->labcnt; i++) {
	size_t used = max_length + 1;

	if ((SP->_slk->ent[i].ent_text = (char *) _nc_doalloc(0, used)) == 0)
	    returnCode(slk_failed());
	memset(SP->_slk->ent[i].ent_text, 0, used);

	if ((SP->_slk->ent[i].form_text = (char *) _nc_doalloc(0, used)) == 0)
	    returnCode(slk_failed());
	memset(SP->_slk->ent[i].form_text, 0, used);

	memset(SP->_slk->ent[i].form_text, ' ', max_length);
	SP->_slk->ent[i].visible = (char) (i < SP->_slk->maxlab);
    }
    if (_nc_globals.slk_format >= 3) {	/* PC style */
	int gap = (cols - 3 * (3 + 4 * max_length)) / 2;

	if (gap < 1)
	    gap = 1;

	for (i = x = 0; i < SP->_slk->maxlab; i++) {
	    SP->_slk->ent[i].ent_x = x;
	    x += max_length;
	    x += (i == 3 || i == 7) ? gap : 1;
	}
    } else {
	if (_nc_globals.slk_format == 2) {	/* 4-4 */
	    int gap = cols - (SP->_slk->maxlab * max_length) - 6;

	    if (gap < 1)
		gap = 1;
	    for (i = x = 0; i < SP->_slk->maxlab; i++) {
		SP->_slk->ent[i].ent_x = x;
		x += max_length;
		x += (i == 3) ? gap : 1;
	    }
	} else {
	    if (_nc_globals.slk_format == 1) {	/* 1 -> 3-2-3 */
		int gap = (cols - (SP->_slk->maxlab * max_length) - 5)
		/ 2;

		if (gap < 1)
		    gap = 1;
		for (i = x = 0; i < SP->_slk->maxlab; i++) {
		    SP->_slk->ent[i].ent_x = x;
		    x += max_length;
		    x += (i == 2 || i == 4) ? gap : 1;
		}
	    } else
		returnCode(slk_failed());
	}
    }
    SP->_slk->dirty = TRUE;
    if ((SP->_slk->win = stwin) == NULL) {
	returnCode(slk_failed());
    }

    /* We now reset the format so that the next newterm has again
     * per default no SLK keys and may call slk_init again to
     * define a new layout. (juergen 03-Mar-1999)
     */
    SP->slk_format = _nc_globals.slk_format;
    _nc_globals.slk_format = 0;
    returnCode(res);
}

/*
 * Restore the soft labels on the screen.
 */
NCURSES_EXPORT(int)
slk_restore(void)
{
    T((T_CALLED("slk_restore()")));

    if (SP->_slk == NULL)
	return (ERR);
    SP->_slk->hidden = FALSE;
    SP->_slk->dirty = TRUE;

    returnCode(slk_refresh());
}
@


1.4
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_slk.c,v 1.3 1999/11/28 17:49:53 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d32 6
a37 2
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
d50 1
a50 1
MODULE_ID("$From: lib_slk.c,v 1.20 2000/12/10 02:43:27 tom Exp $")
d53 1
a53 2
 * We'd like to move these into the screen context structure, but cannot,
 * because slk_init() is called before initscr()/newterm().
d55 2
a56 9
NCURSES_EXPORT_VAR(int)
_nc_slk_format = 0;		/* one more than format specified in slk_init() */

/*
 * Paint the info line for the PC style SLK emulation.
 *
 */
     static void
       slk_paint_info(WINDOW *win)
d58 4
a61 17
    if (win && SP->slk_format == 4) {
	int i;

	mvwhline(win, 0, 0, 0, getmaxx(win));
	wmove(win, 0, 0);

	for (i = 0; i < SP->_slk->maxlab; i++) {
	    if (win && SP->slk_format == 4) {
		mvwaddch(win, 0, SP->_slk->ent[i].x, (chtype) 'F');
		if (i < 9)
		    waddch(win, (chtype) '1' + i);
		else {
		    waddch(win, (chtype) '1');
		    waddch(win, (chtype) '0' + (i - 9));
		}
	    }
	}
d63 1
d75 1
a75 1
    char *p;
d77 1
a77 1
    T(("slk_initialize()"));
d80 1
a80 1
	return (OK);
d82 1
a82 1
	return (ERR);
a84 2
    SP->_slk->buffer = NULL;
    SP->_slk->attr = A_STANDOUT;
d86 25
a110 14
    SP->_slk->maxlab = (num_labels > 0) ?
	num_labels : MAX_SKEY(_nc_slk_format);
    SP->_slk->maxlen = (num_labels > 0) ?
	label_width * label_height : MAX_SKEY_LEN(_nc_slk_format);
    SP->_slk->labcnt = (SP->_slk->maxlab < MAX_SKEY(_nc_slk_format)) ?
	MAX_SKEY(_nc_slk_format) : SP->_slk->maxlab;

    SP->_slk->ent = typeCalloc(slk_ent, SP->_slk->labcnt);
    if (SP->_slk->ent == NULL)
	goto exception;

    p = SP->_slk->buffer = (char *) calloc(2 * SP->_slk->labcnt, (1 + SP->_slk->maxlen));
    if (SP->_slk->buffer == NULL)
	goto exception;
d112 1
d114 12
a125 6
	SP->_slk->ent[i].text = p;
	p += (1 + SP->_slk->maxlen);
	SP->_slk->ent[i].form_text = p;
	p += (1 + SP->_slk->maxlen);
	memset(SP->_slk->ent[i].form_text, ' ', (unsigned) (SP->_slk->maxlen));
	SP->_slk->ent[i].visible = (i < SP->_slk->maxlab);
d127 2
a128 2
    if (_nc_slk_format >= 3) {	/* PC style */
	int gap = (cols - 3 * (3 + 4 * SP->_slk->maxlen)) / 2;
d134 2
a135 2
	    SP->_slk->ent[i].x = x;
	    x += SP->_slk->maxlen;
a137 2
	if (_nc_slk_format == 4)
	    slk_paint_info(stwin);
d139 2
a140 2
	if (_nc_slk_format == 2) {	/* 4-4 */
	    int gap = cols - (SP->_slk->maxlab * SP->_slk->maxlen) - 6;
d145 2
a146 2
		SP->_slk->ent[i].x = x;
		x += SP->_slk->maxlen;
d150 2
a151 2
	    if (_nc_slk_format == 1) {	/* 1 -> 3-2-3 */
		int gap = (cols - (SP->_slk->maxlab * SP->_slk->maxlen) - 5)
d157 2
a158 2
		    SP->_slk->ent[i].x = x;
		    x += SP->_slk->maxlen;
d162 1
a162 1
		goto exception;
d167 1
a167 8
      exception:
	if (SP->_slk) {
	    FreeIfNeeded(SP->_slk->buffer);
	    FreeIfNeeded(SP->_slk->ent);
	    free(SP->_slk);
	    SP->_slk = (SLK *) 0;
	    res = (ERR);
	}
d174 3
a176 3
    SP->slk_format = _nc_slk_format;
    _nc_slk_format = 0;
    return (res);
a190 2
    /* we have to repaint info line eventually */
    slk_paint_info(SP->_slk->win);
@


1.3
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_slk.c,v 1.2 1999/03/11 21:03:55 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
d44 1
a44 1
#include <term.h>	/* num_labels, label_*, plab_norm */
d46 1
a46 1
MODULE_ID("$From: lib_slk.c,v 1.17 1999/10/30 23:00:16 tom Exp $")
d52 2
a53 1
int _nc_slk_format = 0;  /* one more than format specified in slk_init() */
d59 2
a60 2
static void
slk_paint_info(WINDOW *win)
d62 17
a78 20
  if (win && SP->slk_format==4)
    {
      int i;

      mvwhline (win,0,0,0,getmaxx(win));
      wmove (win,0,0);

      for (i = 0; i < SP->_slk->maxlab; i++) {
	if (win && SP->slk_format==4)
	  {
	    mvwaddch(win,0,SP->_slk->ent[i].x,'F');
	    if (i<9)
	      waddch(win,'1'+i);
	    else
	      {
		waddch(win,'1');
		waddch(win,'0' + (i-9));
	      }
	  }
      }
d86 1
a86 1
int
d89 40
a128 44
int i, x;
int res = OK;
char *p;

	T(("slk_initialize()"));

	if (SP->_slk)
	  { /* we did this already, so simply return */
	    return(OK);
	  }
	else
	  if ((SP->_slk = typeCalloc(SLK, 1)) == 0)
	    return(ERR);

	SP->_slk->ent    = NULL;
	SP->_slk->buffer = NULL;
	SP->_slk->attr   = A_STANDOUT;

	SP->_slk->maxlab = (num_labels > 0) ?
	  num_labels : MAX_SKEY(_nc_slk_format);
	SP->_slk->maxlen = (num_labels > 0) ?
	  label_width * label_height : MAX_SKEY_LEN(_nc_slk_format);
	SP->_slk->labcnt = (SP->_slk->maxlab < MAX_SKEY(_nc_slk_format)) ? 
	  MAX_SKEY(_nc_slk_format) : SP->_slk->maxlab;

	SP->_slk->ent = typeCalloc(slk_ent, SP->_slk->labcnt);
	if (SP->_slk->ent == NULL)
	  goto exception;

	p = SP->_slk->buffer = (char*) calloc(2*SP->_slk->labcnt,(1+SP->_slk->maxlen));
	if (SP->_slk->buffer == NULL)
	  goto exception;

	for (i = 0; i < SP->_slk->labcnt; i++) {
		SP->_slk->ent[i].text = p;
		p += (1 + SP->_slk->maxlen);
		SP->_slk->ent[i].form_text = p;
		p += (1 + SP->_slk->maxlen);
		memset(SP->_slk->ent[i].form_text, ' ', (unsigned)(SP->_slk->maxlen));
		SP->_slk->ent[i].visible = (i < SP->_slk->maxlab);
	}
	if (_nc_slk_format >= 3) /* PC style */
	  {
	    int gap = (cols - 3 * (3 + 4*SP->_slk->maxlen))/2;
d130 2
a131 2
	    if (gap < 1)
	      gap = 1;
d133 9
a141 10
	    for (i = x = 0; i < SP->_slk->maxlab; i++) {
	      SP->_slk->ent[i].x = x;
	      x += SP->_slk->maxlen;
	      x += (i==3 || i==7) ? gap : 1;
	    }
	    if (_nc_slk_format == 4)
	      slk_paint_info (stwin);
	  }
	else {
	  if (_nc_slk_format == 2) {	/* 4-4 */
d145 1
a145 1
			gap = 1;
d147 3
a149 3
	      SP->_slk->ent[i].x = x;
	      x += SP->_slk->maxlen;
	      x += (i == 3) ? gap : 1;
d151 4
a154 5
	  }
	  else
	    {
	      if (_nc_slk_format == 1) { /* 1 -> 3-2-3 */
		int gap = (cols - (SP->_slk->maxlab * SP->_slk->maxlen) - 5) / 2;
d157 1
a157 1
		  gap = 1;
d159 3
a161 3
		  SP->_slk->ent[i].x = x;
		  x += SP->_slk->maxlen;
		  x += (i == 2 || i == 4) ? gap : 1;
d163 1
a163 2
	      }
	      else
a164 1
	    }
d166 10
a175 12
	SP->_slk->dirty = TRUE;
	if ((SP->_slk->win = stwin) == NULL)
	{
	exception:
		if (SP->_slk)
		{
		   FreeIfNeeded(SP->_slk->buffer);
		   FreeIfNeeded(SP->_slk->ent);
		   free(SP->_slk);
		   SP->_slk = (SLK*)0;
		   res = (ERR);
		}
d177 1
d179 7
a185 7
	/* We now reset the format so that the next newterm has again
	 * per default no SLK keys and may call slk_init again to
	 * define a new layout. (juergen 03-Mar-1999)
	 */
	SP->slk_format = _nc_slk_format;
	_nc_slk_format = 0;
	return(res);
a187 1

d191 1
a191 1
int
d194 1
a194 1
	T((T_CALLED("slk_restore()")));
d196 6
a201 6
	if (SP->_slk == NULL)
		return(ERR);
	SP->_slk->hidden = FALSE;
	SP->_slk->dirty = TRUE;
	/* we have to repaint info line eventually */
	slk_paint_info(SP->_slk->win);
d203 1
a203 1
	returnCode(slk_refresh());
@


1.2
log
@ncurses-4.2-990307
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_slk.c,v 1.1 1999/01/18 19:09:59 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d46 1
a46 1
MODULE_ID("$From: lib_slk.c,v 1.16 1999/03/03 23:44:22 juergen Exp $")
d52 1
a52 1
int _nc_slk_format;  /* one more than format specified in slk_init() */
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_slk.c,v 1.4 1998/07/23 21:19:24 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_slk.c,v 1.15 1999/01/02 22:56:30 tom Exp $")
d61 1
a61 1
  if (win && _nc_slk_format==4)
d69 1
a69 1
	if (win && _nc_slk_format==4)
d92 1
d109 6
a114 3
	SP->_slk->maxlab = (num_labels > 0) ? num_labels : MAX_SKEY;
	SP->_slk->maxlen = (num_labels > 0) ? label_width * label_height : MAX_SKEY_LEN;
	SP->_slk->labcnt = (SP->_slk->maxlab < MAX_SKEY) ? MAX_SKEY : SP->_slk->maxlab;
d186 1
a186 1
		   return(ERR);
d190 7
a196 1
	return(OK);
@

