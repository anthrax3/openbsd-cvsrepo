head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.28
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.24
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.26
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.18
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.22
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.20
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.38
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.34
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.32
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.30
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.28
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.26
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.24
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.22
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.20
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.18
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.16
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.14
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.12
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.10
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.8
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.6
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.22.18.01.44;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.08.22.46.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.10.03.06.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.19.03.53.46;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.26.16.45.03;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.10.01.35.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.02.22.06.51;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.11.28.17.49.53;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.08.15.11.40.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.03.11.21.03.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.02.24.06.31.08;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.09.59;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
**	lib_set_term.c
**
**	The routine set_term().
**
*/

#include <curses.priv.h>

#include <term.h>		/* cur_term */
#include <tic.h>

MODULE_ID("$Id: lib_set_term.c,v 1.117 2008/08/04 18:11:12 tom Exp $")

NCURSES_EXPORT(SCREEN *)
set_term(SCREEN *screenp)
{
    SCREEN *oldSP;
    SCREEN *newSP;

    T((T_CALLED("set_term(%p)"), screenp));

    _nc_lock_global(curses);

    oldSP = SP;
    _nc_set_screen(screenp);
    newSP = SP;

    if (newSP != 0) {
	set_curterm(newSP->_term);
#if !USE_REENTRANT
	curscr = newSP->_curscr;
	newscr = newSP->_newscr;
	stdscr = newSP->_stdscr;
	COLORS = newSP->_color_count;
	COLOR_PAIRS = newSP->_pair_count;
#endif
    } else {
	set_curterm(0);
#if !USE_REENTRANT
	curscr = 0;
	newscr = 0;
	stdscr = 0;
	COLORS = 0;
	COLOR_PAIRS = 0;
#endif
    }

    _nc_unlock_global(curses);

    T((T_RETURN("%p"), oldSP));
    return (oldSP);
}

static void
_nc_free_keytry(TRIES * kt)
{
    if (kt != 0) {
	_nc_free_keytry(kt->child);
	_nc_free_keytry(kt->sibling);
	free(kt);
    }
}

static bool
delink_screen(SCREEN *sp)
{
    SCREEN *last = 0;
    SCREEN *temp;
    bool result = FALSE;

    for (each_screen(temp)) {
	if (temp == sp) {
	    if (last)
		last = sp->_next_screen;
	    else
		_nc_screen_chain = sp->_next_screen;
	    result = TRUE;
	    break;
	}
	last = temp;
    }
    return result;
}

/*
 * Free the storage associated with the given SCREEN sp.
 */
NCURSES_EXPORT(void)
delscreen(SCREEN *sp)
{
    int i;

    T((T_CALLED("delscreen(%p)"), sp));

    _nc_lock_global(curses);
    if (delink_screen(sp)) {

	(void) _nc_freewin(sp->_curscr);
	(void) _nc_freewin(sp->_newscr);
	(void) _nc_freewin(sp->_stdscr);

	if (sp->_slk != 0) {
	    if (sp->_slk->ent != 0) {
		for (i = 0; i < sp->_slk->labcnt; ++i) {
		    FreeIfNeeded(sp->_slk->ent[i].ent_text);
		    FreeIfNeeded(sp->_slk->ent[i].form_text);
		}
		free(sp->_slk->ent);
	    }
	    free(sp->_slk);
	    sp->_slk = 0;
	}

	_nc_free_keytry(sp->_keytry);
	sp->_keytry = 0;

	_nc_free_keytry(sp->_key_ok);
	sp->_key_ok = 0;

	FreeIfNeeded(sp->_current_attr);

	FreeIfNeeded(sp->_color_table);
	FreeIfNeeded(sp->_color_pairs);

	FreeIfNeeded(sp->oldhash);
	FreeIfNeeded(sp->newhash);
	FreeIfNeeded(sp->hashtab);

	FreeIfNeeded(sp->_acs_map);
	FreeIfNeeded(sp->_screen_acs_map);

	/*
	 * If the associated output stream has been closed, we can discard the
	 * set-buffer.  Limit the error check to EBADF, since fflush may fail
	 * for other reasons than trying to operate upon a closed stream.
	 */
	if (sp->_ofp != 0
	    && sp->_setbuf != 0
	    && fflush(sp->_ofp) != 0
	    && errno == EBADF) {
	    free(sp->_setbuf);
	}

	del_curterm(sp->_term);
	free(sp);

	/*
	 * If this was the current screen, reset everything that the
	 * application might try to use (except cur_term, which may have
	 * multiple references in different screens).
	 */
	if (sp == SP) {
#if !USE_REENTRANT
	    curscr = 0;
	    newscr = 0;
	    stdscr = 0;
	    COLORS = 0;
	    COLOR_PAIRS = 0;
#endif
	    _nc_set_screen(0);
	}
    }
    _nc_unlock_global(curses);

    returnVoid;
}

static bool
no_mouse_event(SCREEN *sp GCC_UNUSED)
{
    return FALSE;
}

static bool
no_mouse_inline(SCREEN *sp GCC_UNUSED)
{
    return FALSE;
}

static bool
no_mouse_parse(SCREEN *sp GCC_UNUSED, int code GCC_UNUSED)
{
    return TRUE;
}

static void
no_mouse_resume(SCREEN *sp GCC_UNUSED)
{
}

static void
no_mouse_wrap(SCREEN *sp GCC_UNUSED)
{
}

#if NCURSES_EXT_FUNCS && USE_COLORFGBG
static char *
extract_fgbg(char *src, int *result)
{
    char *dst = 0;
    long value = strtol(src, &dst, 0);

    if (dst == 0) {
	dst = src;
    } else if (value >= 0) {
	*result = value;
    }
    while (*dst != 0 && *dst != ';')
	dst++;
    if (*dst == ';')
	dst++;
    return dst;
}
#endif

/* OS-independent screen initializations */
NCURSES_EXPORT(int)
_nc_setupscreen(int slines GCC_UNUSED,
		int scolumns GCC_UNUSED,
		FILE *output,
		bool filtered,
		int slk_format)
{
    char *env;
    int bottom_stolen = 0;
    bool support_cookies = USE_XMC_SUPPORT;
    ripoff_t *rop;

    T((T_CALLED("_nc_setupscreen(%d, %d, %p, %d, %d)"),
       slines, scolumns, output, filtered, slk_format));

    assert(SP == 0);		/* has been reset in newterm() ! */
    if (!_nc_alloc_screen()
	|| ((SP->_acs_map = typeCalloc(chtype, ACS_LEN)) == 0)
	|| ((SP->_screen_acs_map = typeCalloc(bool, ACS_LEN)) == 0)) {
	returnCode(ERR);
    }

    T(("created SP %p", SP));
    SP->_next_screen = _nc_screen_chain;
    _nc_screen_chain = SP;

    if ((SP->_current_attr = typeCalloc(NCURSES_CH_T, 1)) == 0)
	returnCode(ERR);

    /*
     * We should always check the screensize, just in case.
     */
    _nc_get_screensize(SP, &slines, &scolumns);
    SET_LINES(slines);
    SET_COLS(scolumns);
    T((T_CREATE("screen %s %dx%d"), termname(), LINES, COLS));

    SP->_filtered = filtered;

    /* implement filter mode */
    if (filtered) {
	slines = 1;
	SET_LINES(slines);
	clear_screen = 0;
	cursor_down = parm_down_cursor = 0;
	cursor_address = 0;
	cursor_up = parm_up_cursor = 0;
	row_address = 0;

	cursor_home = carriage_return;
	T(("filter screensize %dx%d", LINES, COLS));
    }
#ifdef __DJGPP__
    T(("setting output mode to binary"));
    fflush(output);
    setmode(output, O_BINARY);
#endif
    _nc_set_buffer(output, TRUE);
    SP->_term = cur_term;
    SP->_lines = slines;
    SP->_lines_avail = slines;
    SP->_columns = scolumns;
    SP->_cursrow = -1;
    SP->_curscol = -1;
    SP->_nl = TRUE;
    SP->_raw = FALSE;
    SP->_cbreak = 0;
    SP->_echo = TRUE;
    SP->_fifohead = -1;
    SP->_endwin = TRUE;
    SP->_ofp = output;
    SP->_cursor = -1;		/* cannot know real cursor shape */

    SetNoPadding(SP);

#if NCURSES_EXT_FUNCS
    SP->_default_color = FALSE;
    SP->_has_sgr_39_49 = FALSE;

    /*
     * Set our assumption of the terminal's default foreground and background
     * colors.  The curs_color man-page states that we can assume that the
     * background is black.  The origin of this assumption appears to be
     * terminals that displayed colored text, but no colored backgrounds, e.g.,
     * the first colored terminals around 1980.  More recent ones with better
     * technology can display not only colored backgrounds, but all
     * combinations.  So a terminal might be something other than "white" on
     * black (green/black looks monochrome too), but black on white or even
     * on ivory.
     *
     * White-on-black is the simplest thing to use for monochrome.  Almost
     * all applications that use color paint both text and background, so
     * the distinction is moot.  But a few do not - which is why we leave this
     * configurable (a better solution is to use assume_default_colors() for
     * the rare applications that do require that sort of appearance, since
     * is appears that more users expect to be able to make a white-on-black
     * or black-on-white display under control of the application than not).
     */
#ifdef USE_ASSUMED_COLOR
    SP->_default_fg = COLOR_WHITE;
    SP->_default_bg = COLOR_BLACK;
#else
    SP->_default_fg = C_MASK;
    SP->_default_bg = C_MASK;
#endif

    /*
     * Allow those assumed/default color assumptions to be overridden at
     * runtime:
     */
    if ((env = getenv("NCURSES_ASSUMED_COLORS")) != 0) {
	int fg, bg;
	char sep1, sep2;
	int count = sscanf(env, "%d%c%d%c", &fg, &sep1, &bg, &sep2);
	if (count >= 1) {
	    SP->_default_fg = (fg >= 0 && fg < max_colors) ? fg : C_MASK;
	    if (count >= 3) {
		SP->_default_bg = (bg >= 0 && bg < max_colors) ? bg : C_MASK;
	    }
	    TR(TRACE_CHARPUT | TRACE_MOVE,
	       ("from environment assumed fg=%d, bg=%d",
		SP->_default_fg,
		SP->_default_bg));
	}
    }
#if USE_COLORFGBG
    /*
     * If rxvt's $COLORFGBG variable is set, use it to specify the assumed
     * default colors.  Note that rxvt (mis)uses bold colors, equating a bold
     * color to that value plus 8.  We'll only use the non-bold color for now -
     * decide later if it is worth having default attributes as well.
     */
    if (getenv("COLORFGBG") != 0) {
	char *p = getenv("COLORFGBG");
	TR(TRACE_CHARPUT | TRACE_MOVE, ("decoding COLORFGBG %s", p));
	p = extract_fgbg(p, &(SP->_default_fg));
	p = extract_fgbg(p, &(SP->_default_bg));
	if (*p)			/* assume rxvt was compiled with xpm support */
	    p = extract_fgbg(p, &(SP->_default_bg));
	TR(TRACE_CHARPUT | TRACE_MOVE, ("decoded fg=%d, bg=%d",
					SP->_default_fg, SP->_default_bg));
	if (SP->_default_fg >= max_colors) {
	    if (set_a_foreground != ABSENT_STRING
		&& !strcmp(set_a_foreground, "\033[3%p1%dm")) {
		set_a_foreground = "\033[3%?%p1%{8}%>%t9%e%p1%d%;m";
	    } else {
		SP->_default_fg %= max_colors;
	    }
	}
	if (SP->_default_bg >= max_colors) {
	    if (set_a_background != ABSENT_STRING
		&& !strcmp(set_a_background, "\033[4%p1%dm")) {
		set_a_background = "\033[4%?%p1%{8}%>%t9%e%p1%d%;m";
	    } else {
		SP->_default_bg %= max_colors;
	    }
	}
    }
#endif
#endif /* NCURSES_EXT_FUNCS */

    SP->_maxclick = DEFAULT_MAXCLICK;
    SP->_mouse_event = no_mouse_event;
    SP->_mouse_inline = no_mouse_inline;
    SP->_mouse_parse = no_mouse_parse;
    SP->_mouse_resume = no_mouse_resume;
    SP->_mouse_wrap = no_mouse_wrap;
    SP->_mouse_fd = -1;

    /*
     * If we've no magic cookie support, we suppress attributes that xmc would
     * affect, i.e., the attributes that affect the rendition of a space.
     */
    SP->_ok_attributes = termattrs();
    if (has_colors()) {
	SP->_ok_attributes |= A_COLOR;
    }
#if USE_XMC_SUPPORT
    /*
     * If we have no magic-cookie support compiled-in, or if it is suppressed
     * in the environment, reset the support-flag.
     */
    if (magic_cookie_glitch >= 0) {
	if (getenv("NCURSES_NO_MAGIC_COOKIE") != 0) {
	    support_cookies = FALSE;
	}
    }
#endif

    if (!support_cookies && magic_cookie_glitch >= 0) {
	T(("will disable attributes to work w/o magic cookies"));
    }

    if (magic_cookie_glitch > 0) {	/* tvi, wyse */

	SP->_xmc_triggers = SP->_ok_attributes & (
						     A_STANDOUT |
						     A_UNDERLINE |
						     A_REVERSE |
						     A_BLINK |
						     A_DIM |
						     A_BOLD |
						     A_INVIS |
						     A_PROTECT
	    );
#if 0
	/*
	 * We "should" treat colors as an attribute.  The wyse350 (and its
	 * clones) appear to be the only ones that have both colors and magic
	 * cookies.
	 */
	if (has_colors()) {
	    SP->_xmc_triggers |= A_COLOR;
	}
#endif
	SP->_xmc_suppress = SP->_xmc_triggers & (chtype) ~(A_BOLD);

	T(("magic cookie attributes %s", _traceattr(SP->_xmc_suppress)));
	/*
	 * Supporting line-drawing may be possible.  But make the regular
	 * video attributes work first.
	 */
	acs_chars = ABSENT_STRING;
	ena_acs = ABSENT_STRING;
	enter_alt_charset_mode = ABSENT_STRING;
	exit_alt_charset_mode = ABSENT_STRING;
#if USE_XMC_SUPPORT
	/*
	 * To keep the cookie support simple, suppress all of the optimization
	 * hooks except for clear_screen and the cursor addressing.
	 */
	if (support_cookies) {
	    clr_eol = ABSENT_STRING;
	    clr_eos = ABSENT_STRING;
	    set_attributes = ABSENT_STRING;
	}
#endif
    } else if (magic_cookie_glitch == 0) {	/* hpterm */
    }

    /*
     * If magic cookies are not supported, cancel the strings that set
     * video attributes.
     */
    if (!support_cookies && magic_cookie_glitch >= 0) {
	magic_cookie_glitch = ABSENT_NUMERIC;
	set_attributes = ABSENT_STRING;
	enter_blink_mode = ABSENT_STRING;
	enter_bold_mode = ABSENT_STRING;
	enter_dim_mode = ABSENT_STRING;
	enter_reverse_mode = ABSENT_STRING;
	enter_standout_mode = ABSENT_STRING;
	enter_underline_mode = ABSENT_STRING;
    }

    /* initialize normal acs before wide, since we use mapping in the latter */
#if !USE_WIDEC_SUPPORT
    if (_nc_unicode_locale() && _nc_locale_breaks_acs(cur_term)) {
	acs_chars = NULL;
	ena_acs = NULL;
	enter_alt_charset_mode = NULL;
	exit_alt_charset_mode = NULL;
	set_attributes = NULL;
    }
#endif
    _nc_init_acs();
#if USE_WIDEC_SUPPORT
    _nc_init_wacs();

    SP->_screen_acs_fix = (_nc_unicode_locale()
			   && _nc_locale_breaks_acs(cur_term));
#endif
    env = _nc_get_locale();
    SP->_legacy_coding = ((env == 0)
			  || !strcmp(env, "C")
			  || !strcmp(env, "POSIX"));
    T(("legacy-coding %d", SP->_legacy_coding));

    _nc_idcok = TRUE;
    _nc_idlok = FALSE;

    SP->oldhash = 0;
    SP->newhash = 0;

    T(("creating newscr"));
    if ((SP->_newscr = newwin(slines, scolumns, 0, 0)) == 0)
	returnCode(ERR);

    T(("creating curscr"));
    if ((SP->_curscr = newwin(slines, scolumns, 0, 0)) == 0)
	returnCode(ERR);

#if !USE_REENTRANT
    newscr = SP->_newscr;
    curscr = SP->_curscr;
#endif
#if USE_SIZECHANGE
    SP->_resize = resizeterm;
#endif

    newscr->_clear = TRUE;
    curscr->_clear = FALSE;

    def_shell_mode();
    def_prog_mode();

    for (rop = ripoff_stack;
	 rop != ripoff_sp && (rop - ripoff_stack) < N_RIPS;
	 rop++) {

	/* If we must simulate soft labels, grab off the line to be used.
	   We assume that we must simulate, if it is none of the standard
	   formats (4-4 or 3-2-3) for which there may be some hardware
	   support. */
	if (rop->hook == _nc_slk_initialize)
	    if (!(num_labels <= 0 || !SLK_STDFMT(slk_format)))
		continue;
	if (rop->hook) {
	    int count;
	    WINDOW *w;

	    count = (rop->line < 0) ? -rop->line : rop->line;
	    T(("ripping off %i lines at %s", count,
	       ((rop->line < 0)
		? "bottom"
		: "top")));

	    w = newwin(count, scolumns,
		       ((rop->line < 0)
			? SP->_lines_avail - count
			: 0),
		       0);
	    if (w) {
		rop->win = w;
		rop->hook(w, scolumns);
	    } else {
		returnCode(ERR);
	    }
	    if (rop->line < 0)
		bottom_stolen += count;
	    else
		SP->_topstolen += count;
	    SP->_lines_avail -= count;
	}
    }
    /* reset the stack */
    ripoff_sp = ripoff_stack;

    T(("creating stdscr"));
    assert((SP->_lines_avail + SP->_topstolen + bottom_stolen) == slines);
    if ((SP->_stdscr = newwin(SP->_lines_avail, scolumns, 0, 0)) == 0)
	returnCode(ERR);

    SET_LINES(SP->_lines_avail);
#if !USE_REENTRANT
    stdscr = SP->_stdscr;
#endif

    returnCode(OK);
}

/*
 * The internal implementation interprets line as the number of lines to rip
 * off from the top or bottom.
 */
NCURSES_EXPORT(int)
_nc_ripoffline(int line, int (*init) (WINDOW *, int))
{
    T((T_CALLED("_nc_ripoffline(%d, %p)"), line, init));

    if (line != 0) {

	if (ripoff_sp == 0)
	    ripoff_sp = ripoff_stack;
	if (ripoff_sp >= ripoff_stack + N_RIPS)
	    returnCode(ERR);

	ripoff_sp->line = line;
	ripoff_sp->hook = init;
	ripoff_sp++;
    }

    returnCode(OK);
}

NCURSES_EXPORT(int)
ripoffline(int line, int (*init) (WINDOW *, int))
{
    START_TRACE();
    T((T_CALLED("ripoffline(%d,%p)"), line, init));

    if (line == 0)
	returnCode(OK);

    returnCode(_nc_ripoffline((line < 0) ? -1 : 1, init));
}
@


1.12
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.11 2000/10/08 22:46:59 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d49 1
a49 1
MODULE_ID("$From: lib_set_term.c,v 1.61 2000/12/10 02:43:27 tom Exp $")
d52 1
a52 1
set_term(SCREEN * screenp)
d55 1
d59 2
d63 21
d85 1
a85 7
    set_curterm(SP->_term);
    curscr = SP->_curscr;
    newscr = SP->_newscr;
    stdscr = SP->_stdscr;
    COLORS = SP->_color_count;
    COLOR_PAIRS = SP->_pair_count;
    memcpy(acs_map, SP->_acs_map, sizeof(chtype) * ACS_LEN);
d92 1
a92 1
_nc_free_keytry(struct tries *kt)
d101 21
d126 1
a126 1
delscreen(SCREEN * sp)
d128 1
a128 1
    SCREEN **scan = &_nc_screen_chain;
d132 17
a148 4
    while (*scan) {
	if (*scan == sp) {
	    *scan = sp->_next_screen;
	    break;
a149 2
	scan = &(*scan)->_next_screen;
    }
d151 7
a157 5
    (void) _nc_freewin(sp->_curscr);
    (void) _nc_freewin(sp->_newscr);
    (void) _nc_freewin(sp->_stdscr);
    _nc_free_keytry(sp->_keytry);
    _nc_free_keytry(sp->_key_ok);
d159 2
a160 2
    FreeIfNeeded(sp->_color_table);
    FreeIfNeeded(sp->_color_pairs);
d162 3
a164 2
    FreeIfNeeded(sp->oldhash);
    FreeIfNeeded(sp->newhash);
d166 2
a167 1
    del_curterm(sp->_term);
d169 11
a179 11
    /*
     * If the associated output stream has been closed, we can discard the
     * set-buffer.  Limit the error check to EBADF, since fflush may fail
     * for other reasons than trying to operate upon a closed stream.
     */
    if (sp->_ofp != 0
	&& sp->_setbuf != 0
	&& fflush(sp->_ofp) != 0
	&& errno == EBADF) {
	free(sp->_setbuf);
    }
d181 2
a182 1
    free(sp);
d184 15
a198 12
    /*
     * If this was the current screen, reset everything that the
     * application might try to use (except cur_term, which may have
     * multiple references in different screens).
     */
    if (sp == SP) {
	curscr = 0;
	newscr = 0;
	stdscr = 0;
	COLORS = 0;
	COLOR_PAIRS = 0;
	_nc_set_screen(0);
d200 2
a204 4
static ripoff_t rippedoff[5];
static ripoff_t *rsp = rippedoff;
#define N_RIPS SIZEOF(rippedoff)

d206 1
a206 1
no_mouse_event(SCREEN * sp GCC_UNUSED)
d212 1
a212 1
no_mouse_inline(SCREEN * sp GCC_UNUSED)
d218 1
a218 1
no_mouse_parse(int code GCC_UNUSED)
d224 1
a224 1
no_mouse_resume(SCREEN * sp GCC_UNUSED)
d229 1
a229 1
no_mouse_wrap(SCREEN * sp GCC_UNUSED)
d243 1
a243 1
	*result = value % max_colors;
d253 1
d255 5
a259 3
_nc_setupscreen
(short slines, short const scolumns, FILE * output)
/* OS-independent screen initializations */
d261 1
d263 5
a267 1
    size_t i;
d270 5
a274 2
    if (!_nc_alloc_screen())
	return ERR;
d276 1
d280 31
d327 1
a327 5
#if NCURSES_NO_PADDING
    SP->_no_padding = getenv("NCURSES_NO_PADDING") != 0;
    TR(TRACE_CHARPUT | TRACE_MOVE, ("padding will%s be used",
				    SP->_no_padding ? " not" : ""));
#endif
d360 19
d388 1
d391 20
a422 5
    /* initialize the panel hooks */
    SP->_panelHook.top_panel = (struct panel *) 0;
    SP->_panelHook.bottom_panel = (struct panel *) 0;
    SP->_panelHook.stdscr_pseudo_panel = (struct panel *) 0;

d424 11
a434 4
     * If we've no magic cookie support, we suppress attributes that xmc
     * would affect, i.e., the attributes that affect the rendition of a
     * space.  Note that this impacts the alternate character set mapping
     * as well.
d436 10
a445 1
    if (magic_cookie_glitch > 0) {
d447 11
a457 7
	SP->_xmc_triggers = termattrs() & (
					      A_ALTCHARSET |
					      A_BLINK |
					      A_BOLD |
					      A_REVERSE |
					      A_STANDOUT |
					      A_UNDERLINE
d459 11
a469 1
	SP->_xmc_suppress = SP->_xmc_triggers & (chtype) ~ (A_BOLD);
d472 8
d482 2
a483 2
	 * To keep this simple, suppress all of the optimization hooks
	 * except for clear_screen and the cursor addressing.
d485 14
a498 4
	clr_eol = 0;
	clr_eos = 0;
	set_attributes = 0;
#else
d500 18
a517 1
	acs_chars = 0;
a518 1
    }
d520 11
a530 1
    memcpy(SP->_acs_map, acs_map, sizeof(chtype) * ACS_LEN);
a534 2
    _nc_windows = 0;		/* no windows yet */

d539 2
a540 2
    if ((newscr = newwin(slines, scolumns, 0, 0)) == 0)
	return ERR;
d543 2
a544 2
    if ((curscr = newwin(slines, scolumns, 0, 0)) == 0)
	return ERR;
d546 4
a549 2
    SP->_newscr = newscr;
    SP->_curscr = curscr;
d557 16
a572 2
    for (i = 0, rsp = rippedoff; rsp->line && (i < N_RIPS); rsp++, i++) {
	if (rsp->hook) {
a573 1
	    int count = (rsp->line < 0) ? -rsp->line : rsp->line;
d575 14
a588 8
	    if (rsp->line < 0) {
		w = newwin(count, scolumns, SP->_lines_avail - count, 0);
		if (w) {
		    rsp->w = w;
		    rsp->hook(w, scolumns);
		    bottom_stolen += count;
		} else
		    return ERR;
d590 1
a590 7
		w = newwin(count, scolumns, 0, 0);
		if (w) {
		    rsp->w = w;
		    rsp->hook(w, scolumns);
		    SP->_topstolen += count;
		} else
		    return ERR;
d592 4
a597 1
	rsp->line = 0;
d600 1
a600 1
    rsp = rippedoff;
d604 2
a605 3
    if ((stdscr = newwin(LINES = SP->_lines_avail, scolumns, 0, 0)) == 0)
	return ERR;
    SP->_stdscr = stdscr;
d607 4
a610 2
    def_shell_mode();
    def_prog_mode();
d612 1
a612 1
    return OK;
d615 4
a618 3
/* The internal implementation interprets line as the number of
   lines to rip off from the top or bottom.
   */
d622 1
a622 2
    if (line == 0)
	return (OK);
d624 1
a624 2
    if (rsp >= rippedoff + N_RIPS)
	return (ERR);
d626 9
a634 4
    rsp->line = line;
    rsp->hook = init;
    rsp->w = 0;
    rsp++;
d636 1
a636 1
    return (OK);
d642 1
@


1.11
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.10 2000/07/10 03:06:15 millert Exp $	*/
d48 1
a48 1
MODULE_ID("$From: lib_set_term.c,v 1.58 2000/10/04 22:05:48 tom Exp $")
d50 1
a50 1
SCREEN *
d85 1
a85 1
void
d100 3
a102 3
    _nc_freewin(sp->_curscr);
    _nc_freewin(sp->_newscr);
    _nc_freewin(sp->_stdscr);
d196 3
a198 2
int
_nc_setupscreen(short slines, short const scolumns, FILE * output)
d230 1
a230 1
	    SP->_no_padding ? " not" : ""));
d301 6
a306 6
	    A_ALTCHARSET |
	    A_BLINK |
	    A_BOLD |
	    A_REVERSE |
	    A_STANDOUT |
	    A_UNDERLINE
d396 1
a396 1
int
d413 1
a413 1
int
@


1.10
log
@ncurses 5.1
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.9 2000/06/19 03:53:46 millert Exp $	*/
d48 1
a48 1
MODULE_ID("$From: lib_set_term.c,v 1.55 2000/07/02 00:22:18 tom Exp $")
d176 1
a176 1
#if defined(NCURSES_EXT_FUNCS) && defined(USE_COLORFGBG)
d225 2
a226 1
#ifdef NCURSES_NO_PADDING
d231 2
a232 1
#ifdef NCURSES_EXT_FUNCS
d235 21
d258 6
a263 1
#ifdef USE_COLORFGBG
@


1.9
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.8 2000/03/26 16:45:03 millert Exp $	*/
d48 1
a48 1
MODULE_ID("$From: lib_set_term.c,v 1.52 2000/05/27 23:22:36 tom Exp $");
d153 1
d159 1
d165 1
d170 1
d176 20
d227 2
d235 12
d248 1
@


1.8
log
@Update to ncurses-5.0-20000325
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.7 2000/03/10 01:35:02 millert Exp $	*/
d48 1
a48 1
MODULE_ID("$From: lib_set_term.c,v 1.51 2000/03/26 01:03:36 tom Exp $")
d113 12
@


1.7
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.6 2000/01/02 22:06:51 millert Exp $	*/
d48 1
a48 1
MODULE_ID("$From: lib_set_term.c,v 1.50 2000/02/13 00:59:39 tom Exp $")
d193 2
@


1.6
log
@+ corrected conversion from terminfo rs2 to termcap rs (cf: 980704)
+ make conversion to termcap ug (underline glitch) more consistently applied.
+ modify read_termtype(), fixing 'toe', which could dump core when it
found an incomplete entry such as "dumb" because it did not
initialize its buffer for _nc_read_file_entry().
+ use explicit VALID_NUMERIC() checks in a few places that had been
overlooked, and add a check to ensure that init_tabs is nonzero,
to avoid divide-by-zero (reported by Todd C Miller).
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.5 1999/11/28 17:49:53 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d48 1
a48 1
MODULE_ID("$From: lib_set_term.c,v 1.49 2000/01/01 16:44:29 tom Exp $")
@


1.5
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.4 1999/08/15 11:40:55 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d45 2
a46 1
#include <term.h>	/* cur_term */
d48 1
a48 1
MODULE_ID("$From: lib_set_term.c,v 1.47 1999/11/14 00:14:39 tom Exp $")
d50 2
a51 1
SCREEN * set_term(SCREEN *screenp)
d53 1
a53 1
SCREEN	*oldSP;
d55 1
a55 1
	T((T_CALLED("set_term(%p)"), screenp));
d57 2
a58 2
	oldSP = SP;
	_nc_set_screen(screenp);
d60 7
a66 7
	set_curterm(SP->_term);
	curscr      = SP->_curscr;
	newscr      = SP->_newscr;
	stdscr      = SP->_stdscr;
	COLORS      = SP->_color_count;
	COLOR_PAIRS = SP->_pair_count;
	memcpy(acs_map, SP->_acs_map, sizeof(chtype)*ACS_LEN);
d68 2
a69 2
	T((T_RETURN("%p"), oldSP));
	return(oldSP);
d72 2
a73 1
static void _nc_free_keytry(struct tries *kt)
d75 5
a79 5
	if (kt != 0) {
		_nc_free_keytry(kt->child);
		_nc_free_keytry(kt->sibling);
		free(kt);
	}
d85 2
a86 1
void delscreen(SCREEN *sp)
d88 1
a88 1
	SCREEN **scan = &_nc_screen_chain;
d90 1
a90 1
	T((T_CALLED("delscreen(%p)"), sp));
d92 4
a95 8
	while(*scan)
	{
	    if (*scan == sp)
	    {
		*scan = sp->_next_screen;
		break;
	    }
	    scan = &(*scan)->_next_screen;
d97 2
d100 30
a129 30
	_nc_freewin(sp->_curscr);
	_nc_freewin(sp->_newscr);
	_nc_freewin(sp->_stdscr);
	_nc_free_keytry(sp->_keytry);
	_nc_free_keytry(sp->_key_ok);

	FreeIfNeeded(sp->_color_table);
	FreeIfNeeded(sp->_color_pairs);

	FreeIfNeeded(sp->oldhash);
	FreeIfNeeded(sp->newhash);

	del_curterm(sp->_term);

	free(sp);

	/*
	 * If this was the current screen, reset everything that the
	 * application might try to use (except cur_term, which may have
	 * multiple references in different screens).
	 */
	if (sp == SP) {
		curscr = 0;
		newscr = 0;
		stdscr = 0;
		COLORS = 0;
		COLOR_PAIRS = 0;
		_nc_set_screen(0);
	}
	returnVoid;
d136 23
a158 5
static bool no_mouse_event (SCREEN *sp GCC_UNUSED) { return FALSE; }
static bool no_mouse_inline(SCREEN *sp GCC_UNUSED) { return FALSE; }
static bool no_mouse_parse (int code   GCC_UNUSED) { return TRUE; }
static void no_mouse_resume(SCREEN *sp GCC_UNUSED) { }
static void no_mouse_wrap  (SCREEN *sp GCC_UNUSED) { }
d160 2
a161 1
int _nc_setupscreen(short slines, short const scolumns, FILE *output)
d164 2
a165 2
int	bottom_stolen = 0;
size_t	i;
d167 22
a188 22
        assert(SP==0); /* has been reset in newterm() ! */
	if (!_nc_alloc_screen())
		return ERR;

	SP->_next_screen = _nc_screen_chain;
	_nc_screen_chain = SP;

	_nc_set_buffer(output, TRUE);
	SP->_term        = cur_term;
	SP->_lines       = slines;
	SP->_lines_avail = slines;
	SP->_columns     = scolumns;
	SP->_cursrow     = -1;
	SP->_curscol     = -1;
	SP->_nl          = TRUE;
	SP->_raw         = FALSE;
	SP->_cbreak      = 0;
	SP->_echo        = TRUE;
	SP->_fifohead    = -1;
	SP->_endwin      = TRUE;
	SP->_ofp         = output;
	SP->_cursor      = -1;	/* cannot know real cursor shape */
d190 1
a190 1
	SP->_no_padding  = getenv("NCURSES_NO_PADDING") != 0;
d193 2
a194 2
	SP->_default_fg   = COLOR_WHITE;
	SP->_default_bg   = COLOR_BLACK;
d197 30
a226 12
	SP->_maxclick     = DEFAULT_MAXCLICK;
	SP->_mouse_event  = no_mouse_event;
	SP->_mouse_inline = no_mouse_inline;
	SP->_mouse_parse  = no_mouse_parse;
	SP->_mouse_resume = no_mouse_resume;
	SP->_mouse_wrap   = no_mouse_wrap;
	SP->_mouse_fd     = -1;

	/* initialize the panel hooks */
	SP->_panelHook.top_panel = (struct panel*)0;
	SP->_panelHook.bottom_panel = (struct panel*)0;
	SP->_panelHook.stdscr_pseudo_panel = (struct panel*)0;
d228 2
d231 2
a232 4
	 * If we've no magic cookie support, we suppress attributes that xmc
	 * would affect, i.e., the attributes that affect the rendition of a
	 * space.  Note that this impacts the alternate character set mapping
	 * as well.
d234 3
a236 21
	if (magic_cookie_glitch > 0) {

		SP->_xmc_triggers = termattrs() & (
				A_ALTCHARSET |
				A_BLINK |
				A_BOLD |
				A_REVERSE |
				A_STANDOUT |
				A_UNDERLINE
				);
		SP->_xmc_suppress = SP->_xmc_triggers & (chtype)~(A_BOLD);

		T(("magic cookie attributes %s", _traceattr(SP->_xmc_suppress)));
#if USE_XMC_SUPPORT
		/*
		 * To keep this simple, suppress all of the optimization hooks
		 * except for clear_screen and the cursor addressing.
		 */
		clr_eol = 0;
		clr_eos = 0;
		set_attributes = 0;
d238 2
a239 2
		magic_cookie_glitch = -1;
		acs_chars = 0;
d241 3
a243 3
	}
	_nc_init_acs();
	memcpy(SP->_acs_map, acs_map, sizeof(chtype)*ACS_LEN);
d245 2
a246 2
	_nc_idcok = TRUE;
	_nc_idlok = FALSE;
d248 1
a248 1
	_nc_windows = 0; /* no windows yet */
d250 2
a251 2
	SP->oldhash = 0;
	SP->newhash = 0;
d253 3
a255 3
	T(("creating newscr"));
	if ((newscr = newwin(slines, scolumns, 0, 0)) == 0)
		return ERR;
d257 3
a259 3
	T(("creating curscr"));
	if ((curscr = newwin(slines, scolumns, 0, 0)) == 0)
		return ERR;
d261 2
a262 2
	SP->_newscr = newscr;
	SP->_curscr = curscr;
d264 1
a264 1
	SP->_resize = resizeterm;
d267 2
a268 2
	newscr->_clear = TRUE;
	curscr->_clear = FALSE;
d270 12
a281 13
	for (i=0, rsp = rippedoff; rsp->line && (i < N_RIPS); rsp++, i++) {
	  if (rsp->hook) {
	      WINDOW *w;
	      int count = (rsp->line < 0) ? -rsp->line : rsp->line;

	      if (rsp->line < 0) {
		  w = newwin(count,scolumns,SP->_lines_avail - count,0);
		  if (w) {
		      rsp->w = w;
		      rsp->hook(w, scolumns);
		      bottom_stolen += count;
		  }
		  else
d283 7
a289 8
	      } else {
		  w = newwin(count,scolumns, 0, 0);
		  if (w) {
		      rsp->w = w;
		      rsp->hook(w, scolumns);
		      SP->_topstolen += count;
		  }
		  else
d291 2
a292 4
	      }
	      SP->_lines_avail -= count;
	  }
	  rsp->line = 0;
d294 10
a303 8
	/* reset the stack */
	rsp = rippedoff;

	T(("creating stdscr"));
	assert ((SP->_lines_avail + SP->_topstolen + bottom_stolen) == slines);
	if ((stdscr = newwin(LINES = SP->_lines_avail, scolumns, 0, 0)) == 0)
		return ERR;
	SP->_stdscr = stdscr;
d305 2
a306 2
	def_shell_mode();
	def_prog_mode();
d308 1
a308 1
	return OK;
d315 1
a315 1
_nc_ripoffline(int line, int (*init)(WINDOW *,int))
d318 1
a318 1
	return(OK);
d321 1
a321 1
	return(ERR);
d325 1
a325 1
    rsp->w    = 0;
d328 1
a328 1
    return(OK);
d332 1
a332 1
ripoffline(int line, int (*init)(WINDOW *, int))
d339 1
a339 1
    returnCode(_nc_ripoffline ((line<0) ? -1 : 1, init));
@


1.4
log
@Update to ncurses-5.0-990814
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.3 1999/03/11 21:03:55 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: lib_set_term.c,v 1.46 1999/07/24 20:05:49 tom Exp $")
d170 4
@


1.3
log
@ncurses-4.2-990307
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.2 1999/02/24 06:31:08 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: lib_set_term.c,v 1.45 1999/03/06 22:29:13 tom Exp $")
d49 1
a49 1
SCREEN * set_term(SCREEN *screen)
d53 1
a53 1
	T((T_CALLED("set_term(%p)"), screen));
d56 1
a56 1
	_nc_set_screen(screen);
@


1.2
log
@ncurses-4.2-990220; this is a pre-release of 5.0
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.1 1999/01/18 19:09:59 millert Exp $	*/
a35 2


d47 1
a47 1
MODULE_ID("$From: lib_set_term.c,v 1.44 1999/02/18 11:31:47 tom Exp $")
d162 1
a162 1
	SP->_cbreak      = FALSE;
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.9 1998/11/17 03:16:21 millert Exp $	*/
d49 1
a49 1
MODULE_ID("$From: lib_set_term.c,v 1.43 1998/11/08 00:58:25 tom Exp $")
d219 1
a219 1
	init_acs();
@

