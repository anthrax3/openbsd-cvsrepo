head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.32
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.28
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.24
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.26
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.18
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.22
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.20
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.38
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.34
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.32
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.30
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.28
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.26
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.24
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.22
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.20
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.18
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.16
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.14
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.12
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.10
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.8
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.6
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.22.18.01.41;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.22.18.27.22;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.08.22.46.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.10.03.06.14;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.26.16.45.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.10.01.35.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.09.05.06.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.12.28.15.57.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.11.28.17.49.53;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.08.15.11.40.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.05.08.20.29.00;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.20.17.09;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.09.52;	author millert;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 * This module is intended to encapsulate ncurses's interface to pointing
 * devices.
 *
 * The primary method used is xterm's internal mouse-tracking facility.
 * Additional methods depend on the platform:
 *	Alessandro Rubini's GPM server (Linux)
 *	sysmouse (FreeBSD)
 *	special-purpose mouse interface for OS/2 EMX.
 *
 * Notes for implementors of new mouse-interface methods:
 *
 * The code is logically split into a lower level that accepts event reports
 * in a device-dependent format and an upper level that parses mouse gestures
 * and filters events.  The mediating data structure is a circular queue of
 * MEVENT structures.
 *
 * Functionally, the lower level's job is to pick up primitive events and
 * put them on the circular queue.  This can happen in one of two ways:
 * either (a) _nc_mouse_event() detects a series of incoming mouse reports
 * and queues them, or (b) code in lib_getch.c detects the kmous prefix in
 * the keyboard input stream and calls _nc_mouse_inline to queue up a series
 * of adjacent mouse reports.
 *
 * In either case, _nc_mouse_parse() should be called after the series is
 * accepted to parse the digested mouse reports (low-level MEVENTs) into
 * a gesture (a high-level or composite MEVENT).
 *
 * Don't be too shy about adding new event types or modifiers, if you can find
 * room for them in the 32-bit mask.  The API is written so that users get
 * feedback on which theoretical event types they won't see when they call
 * mousemask. There's one bit per button (the RESERVED_EVENT bit) not being
 * used yet, and a couple of bits open at the high end.
 */

#ifdef __EMX__
#  include <io.h>
#  define  INCL_DOS
#  define  INCL_VIO
#  define  INCL_KBD
#  define  INCL_MOU
#  define  INCL_DOSPROCESS
#  include <os2.h>		/* Need to include before the others */
#endif

#include <curses.priv.h>

MODULE_ID("$Id: lib_mouse.c,v 1.102 2008/10/18 21:48:55 tom Exp $")

#include <term.h>
#include <tic.h>

#if USE_GPM_SUPPORT
#include <linux/keyboard.h>	/* defines KG_* macros */

#ifdef HAVE_LIBDL
/* use dynamic loader to avoid linkage dependency */
#include <dlfcn.h>

#ifdef RTLD_NOW
#define my_RTLD RTLD_NOW
#else
#ifdef RTLD_LAZY
#define my_RTLD RTLD_LAZY
#else
make an error
#endif
#endif				/* RTLD_NOW */
#endif				/* HAVE_LIBDL */

#endif				/* USE_GPM_SUPPORT */

#if USE_SYSMOUSE
#undef buttons			/* symbol conflict in consio.h */
#undef mouse_info		/* symbol conflict in consio.h */
#include <osreldate.h>
#if (__FreeBSD_version >= 400017)
#include <sys/consio.h>
#include <sys/fbio.h>
#else
#include <machine/console.h>
#endif
#endif				/* use_SYSMOUSE */

#define MY_TRACE TRACE_ICALLS|TRACE_IEVENT

#define	MASK_RELEASE(x)		NCURSES_MOUSE_MASK(x, 001)
#define	MASK_PRESS(x)		NCURSES_MOUSE_MASK(x, 002)
#define	MASK_CLICK(x)		NCURSES_MOUSE_MASK(x, 004)
#define	MASK_DOUBLE_CLICK(x)	NCURSES_MOUSE_MASK(x, 010)
#define	MASK_TRIPLE_CLICK(x)	NCURSES_MOUSE_MASK(x, 020)
#define	MASK_RESERVED_EVENT(x)	NCURSES_MOUSE_MASK(x, 040)

#if NCURSES_MOUSE_VERSION == 1
#define BUTTON_CLICKED        (BUTTON1_CLICKED        | BUTTON2_CLICKED        | BUTTON3_CLICKED        | BUTTON4_CLICKED)
#define BUTTON_PRESSED        (BUTTON1_PRESSED        | BUTTON2_PRESSED        | BUTTON3_PRESSED        | BUTTON4_PRESSED)
#define BUTTON_RELEASED       (BUTTON1_RELEASED       | BUTTON2_RELEASED       | BUTTON3_RELEASED       | BUTTON4_RELEASED)
#define BUTTON_DOUBLE_CLICKED (BUTTON1_DOUBLE_CLICKED | BUTTON2_DOUBLE_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON4_DOUBLE_CLICKED)
#define BUTTON_TRIPLE_CLICKED (BUTTON1_TRIPLE_CLICKED | BUTTON2_TRIPLE_CLICKED | BUTTON3_TRIPLE_CLICKED | BUTTON4_TRIPLE_CLICKED)
#define MAX_BUTTONS  4
#else
#define BUTTON_CLICKED        (BUTTON1_CLICKED        | BUTTON2_CLICKED        | BUTTON3_CLICKED        | BUTTON4_CLICKED        | BUTTON5_CLICKED)
#define BUTTON_PRESSED        (BUTTON1_PRESSED        | BUTTON2_PRESSED        | BUTTON3_PRESSED        | BUTTON4_PRESSED        | BUTTON5_PRESSED)
#define BUTTON_RELEASED       (BUTTON1_RELEASED       | BUTTON2_RELEASED       | BUTTON3_RELEASED       | BUTTON4_RELEASED       | BUTTON5_RELEASED)
#define BUTTON_DOUBLE_CLICKED (BUTTON1_DOUBLE_CLICKED | BUTTON2_DOUBLE_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON4_DOUBLE_CLICKED | BUTTON5_DOUBLE_CLICKED)
#define BUTTON_TRIPLE_CLICKED (BUTTON1_TRIPLE_CLICKED | BUTTON2_TRIPLE_CLICKED | BUTTON3_TRIPLE_CLICKED | BUTTON4_TRIPLE_CLICKED | BUTTON5_TRIPLE_CLICKED)
#define MAX_BUTTONS  5
#endif

#define INVALID_EVENT	-1
#define NORMAL_EVENT	0

#if USE_GPM_SUPPORT

#ifndef LIBGPM_SONAME
#define LIBGPM_SONAME "libgpm.so"
#endif

#define GET_DLSYM(name) (my_##name = (TYPE_##name) dlsym(SP->_dlopen_gpm, #name))

#endif				/* USE_GPM_SUPPORT */

static bool _nc_mouse_parse(SCREEN *, int);
static void _nc_mouse_resume(SCREEN *);
static void _nc_mouse_wrap(SCREEN *);

/* maintain a circular list of mouse events */

#define FirstEV(sp)	((sp)->_mouse_events)
#define LastEV(sp)	((sp)->_mouse_events + EV_MAX - 1)

#undef  NEXT
#define NEXT(ep)	((ep >= LastEV(sp)) \
			 ? FirstEV(sp) \
			 : ep + 1)

#undef  PREV
#define PREV(ep)	((ep <= FirstEV(sp)) \
			 ? LastEV(sp) \
			 : ep - 1)

#define IndexEV(sp, ep)	(ep - FirstEV(sp))

#define RunParams(sp, eventp, runp) \
		(long) IndexEV(sp, runp), \
		(long) (IndexEV(sp, eventp) + (EV_MAX - 1)) % EV_MAX

#ifdef TRACE
static void
_trace_slot(SCREEN *sp, const char *tag)
{
    MEVENT *ep;

    _tracef(tag);

    for (ep = FirstEV(sp); ep <= LastEV(sp); ep++)
	_tracef("mouse event queue slot %ld = %s",
		(long) IndexEV(sp, ep),
		_nc_tracemouse(sp, ep));
}
#endif

#if USE_EMX_MOUSE

#  define TOP_ROW          0
#  define LEFT_COL         0

#  define M_FD(sp) sp->_mouse_fd

static void
write_event(SCREEN *sp, int down, int button, int x, int y)
{
    char buf[6];
    unsigned long ignore;

    strncpy(buf, key_mouse, 3);	/* should be "\033[M" */
    buf[3] = ' ' + (button - 1) + (down ? 0 : 0x40);
    buf[4] = ' ' + x - LEFT_COL + 1;
    buf[5] = ' ' + y - TOP_ROW + 1;
    DosWrite(sp->_emxmouse_wfd, buf, 6, &ignore);
}

static void
mouse_server(unsigned long param)
{
    SCREEN *sp = (SCREEN *) param;
    unsigned short fWait = MOU_WAIT;
    /* NOPTRRECT mourt = { 0,0,24,79 }; */
    MOUEVENTINFO mouev;
    HMOU hmou;
    unsigned short mask = MOUSE_BN1_DOWN | MOUSE_BN2_DOWN | MOUSE_BN3_DOWN;
    int nbuttons = 3;
    int oldstate = 0;
    char err[80];
    unsigned long rc;

    /* open the handle for the mouse */
    if (MouOpen(NULL, &hmou) == 0) {
	rc = MouSetEventMask(&mask, hmou);
	if (rc) {		/* retry with 2 buttons */
	    mask = MOUSE_BN1_DOWN | MOUSE_BN2_DOWN;
	    rc = MouSetEventMask(&mask, hmou);
	    nbuttons = 2;
	}
	if (rc == 0 && MouDrawPtr(hmou) == 0) {
	    for (;;) {
		/* sit and wait on the event queue */
		rc = MouReadEventQue(&mouev, &fWait, hmou);
		if (rc) {
		    snprintf(err, sizeof(err), "Error reading mouse queue, rc=%lu.\r\n", rc);
		    break;
		}
		if (!sp->_emxmouse_activated)
		    goto finish;

		/*
		 * OS/2 numbers a 3-button mouse inconsistently from other
		 * platforms:
		 *      1 = left
		 *      2 = right
		 *      3 = middle.
		 */
		if ((mouev.fs ^ oldstate) & MOUSE_BN1_DOWN)
		    write_event(sp, mouev.fs & MOUSE_BN1_DOWN,
				sp->_emxmouse_buttons[1], mouev.col, mouev.row);
		if ((mouev.fs ^ oldstate) & MOUSE_BN2_DOWN)
		    write_event(sp, mouev.fs & MOUSE_BN2_DOWN,
				sp->_emxmouse_buttons[3], mouev.col, mouev.row);
		if ((mouev.fs ^ oldstate) & MOUSE_BN3_DOWN)
		    write_event(sp, mouev.fs & MOUSE_BN3_DOWN,
				sp->_emxmouse_buttons[2], mouev.col, mouev.row);

	      finish:
		oldstate = mouev.fs;
	    }
	} else
	    snprintf(err, sizeof(err), "Error setting event mask, buttons=%d, rc=%lu.\r\n",
		    nbuttons, rc);

	DosWrite(2, err, strlen(err), &rc);
	MouClose(hmou);
    }
    DosExit(EXIT_THREAD, 0L);
}

#endif /* USE_EMX_MOUSE */

#if USE_SYSMOUSE
static void
sysmouse_server(SCREEN *sp)
{
    struct mouse_info the_mouse;
    MEVENT *work;

    the_mouse.operation = MOUSE_GETINFO;
    if (sp != 0
	&& sp->_mouse_fd >= 0
	&& sp->_sysmouse_tail < FIFO_SIZE
	&& ioctl(sp->_mouse_fd, CONS_MOUSECTL, &the_mouse) != -1) {

	if (sp->_sysmouse_head > sp->_sysmouse_tail) {
	    sp->_sysmouse_tail = 0;
	    sp->_sysmouse_head = 0;
	}
	work = &(sp->_sysmouse_fifo[sp->_sysmouse_tail]);
	memset(work, 0, sizeof(*work));
	work->id = NORMAL_EVENT;	/* there's only one mouse... */

	sp->_sysmouse_old_buttons = sp->_sysmouse_new_buttons;
	sp->_sysmouse_new_buttons = the_mouse.u.data.buttons & 0x7;

	if (sp->_sysmouse_new_buttons) {
	    if (sp->_sysmouse_new_buttons & 1)
		work->bstate |= BUTTON1_PRESSED;
	    if (sp->_sysmouse_new_buttons & 2)
		work->bstate |= BUTTON2_PRESSED;
	    if (sp->_sysmouse_new_buttons & 4)
		work->bstate |= BUTTON3_PRESSED;
	} else {
	    if (sp->_sysmouse_old_buttons & 1)
		work->bstate |= BUTTON1_RELEASED;
	    if (sp->_sysmouse_old_buttons & 2)
		work->bstate |= BUTTON2_RELEASED;
	    if (sp->_sysmouse_old_buttons & 4)
		work->bstate |= BUTTON3_RELEASED;
	}

	/* for cosmetic bug in syscons.c on FreeBSD 3.[34] */
	the_mouse.operation = MOUSE_HIDE;
	ioctl(sp->_mouse_fd, CONS_MOUSECTL, &the_mouse);
	the_mouse.operation = MOUSE_SHOW;
	ioctl(sp->_mouse_fd, CONS_MOUSECTL, &the_mouse);

	/*
	 * We're only interested if the button is pressed or released.
	 * FIXME: implement continuous event-tracking.
	 */
	if (sp->_sysmouse_new_buttons != sp->_sysmouse_old_buttons) {
	    sp->_sysmouse_tail += 1;
	}
	work->x = the_mouse.u.data.x / sp->_sysmouse_char_width;
	work->y = the_mouse.u.data.y / sp->_sysmouse_char_height;
    }
}

static void
handle_sysmouse(int sig GCC_UNUSED)
{
    sysmouse_server(SP);
}
#endif /* USE_SYSMOUSE */

static void
init_xterm_mouse(SCREEN *sp)
{
    sp->_mouse_type = M_XTERM;
    sp->_mouse_xtermcap = tigetstr("XM");
    if (!VALID_STRING(sp->_mouse_xtermcap))
	sp->_mouse_xtermcap = "\033[?1000%?%p1%{1}%=%th%el%;";
}

static void
enable_xterm_mouse(SCREEN *sp, int enable)
{
#if USE_EMX_MOUSE
    sp->_emxmouse_activated = enable;
#else
    putp(TPARM_1(sp->_mouse_xtermcap, enable));
#endif
    sp->_mouse_active = enable;
}

#if USE_GPM_SUPPORT
static bool
allow_gpm_mouse(void)
{
    bool result = FALSE;

    /* GPM does printf's without checking if stdout is a terminal */
    if (isatty(fileno(stdout))) {
	char *list = getenv("NCURSES_GPM_TERMS");
	char *env = getenv("TERM");
	if (list != 0) {
	    if (env != 0) {
		result = _nc_name_match(list, env, "|:");
	    }
	} else {
	    /* GPM checks the beginning of the $TERM variable to decide if it
	     * should pass xterm events through.  There is no real advantage in
	     * allowing GPM to do this.  Recent versions relax that check, and
	     * pretend that GPM can work with any terminal having the kmous
	     * capability.  Perhaps that works for someone.  If so, they can
	     * set the environment variable (above).
	     */
	    if (env != 0 && strstr(env, "linux") != 0) {
		result = TRUE;
	    }
	}
    }
    return result;
}

#ifdef HAVE_LIBDL
static void
unload_gpm_library(SCREEN *sp)
{
    if (SP->_dlopen_gpm != 0) {
	T(("unload GPM library"));
	sp->_mouse_gpm_loaded = FALSE;
	sp->_mouse_fd = -1;
	dlclose(sp->_dlopen_gpm);
	sp->_dlopen_gpm = 0;
    }
}

static void
load_gpm_library(SCREEN *sp)
{
    sp->_mouse_gpm_found = FALSE;
    if ((sp->_dlopen_gpm = dlopen(LIBGPM_SONAME, my_RTLD)) != 0) {
	if (GET_DLSYM(gpm_fd) == 0 ||
	    GET_DLSYM(Gpm_Open) == 0 ||
	    GET_DLSYM(Gpm_Close) == 0 ||
	    GET_DLSYM(Gpm_GetEvent) == 0) {
	    T(("GPM initialization failed: %s", dlerror()));
	    unload_gpm_library(sp);
	} else {
	    sp->_mouse_gpm_found = TRUE;
	    sp->_mouse_gpm_loaded = TRUE;
	}
    }
}
#endif

static bool
enable_gpm_mouse(SCREEN *sp, bool enable)
{
    bool result;

    T((T_CALLED("enable_gpm_mouse(%d)"), enable));

    if (enable && !sp->_mouse_active) {
#ifdef HAVE_LIBDL
	if (sp->_mouse_gpm_found && !sp->_mouse_gpm_loaded) {
	    load_gpm_library(sp);
	}
#endif
	if (sp->_mouse_gpm_loaded) {
	    /* GPM: initialize connection to gpm server */
	    sp->_mouse_gpm_connect.eventMask = GPM_DOWN | GPM_UP;
	    sp->_mouse_gpm_connect.defaultMask =
		(unsigned short) (~(sp->_mouse_gpm_connect.eventMask | GPM_HARD));
	    sp->_mouse_gpm_connect.minMod = 0;
	    sp->_mouse_gpm_connect.maxMod =
		(unsigned short) (~((1 << KG_SHIFT) |
				    (1 << KG_SHIFTL) |
				    (1 << KG_SHIFTR)));
	    /*
	     * Note: GPM hardcodes \E[?1001s and \E[?1000h during its open.
	     * The former is recognized by wscons (SunOS), and the latter by
	     * xterm.  Those will not show up in ncurses' traces.
	     */
	    result = (my_Gpm_Open(&sp->_mouse_gpm_connect, 0) >= 0);
	} else {
	    result = FALSE;
	}
	sp->_mouse_active = result;
	T(("GPM open %s", result ? "succeeded" : "failed"));
    } else {
	if (!enable && sp->_mouse_active) {
	    /* GPM: close connection to gpm server */
	    my_Gpm_Close();
	    sp->_mouse_active = FALSE;
	    T(("GPM closed"));
	}
	result = enable;
    }
#ifdef HAVE_LIBDL
    if (!result) {
	unload_gpm_library(sp);
    }
#endif
    returnBool(result);
}
#endif /* USE_GPM_SUPPORT */

#define xterm_kmous "\033[M"

static void
initialize_mousetype(SCREEN *sp)
{
    T((T_CALLED("initialize_mousetype()")));

    /* Try gpm first, because gpm may be configured to run in xterm */
#if USE_GPM_SUPPORT
    if (allow_gpm_mouse()) {
	if (!sp->_mouse_gpm_loaded) {
#ifdef HAVE_LIBDL
	    load_gpm_library(sp);
#else /* !HAVE_LIBDL */
	    sp->_mouse_gpm_found = TRUE;
	    sp->_mouse_gpm_loaded = TRUE;
#endif
	}

	/*
	 * The gpm_fd file-descriptor may be negative (xterm).  So we have to
	 * maintain our notion of whether the mouse connection is active
	 * without testing the file-descriptor.
	 */
	if (sp->_mouse_gpm_found && enable_gpm_mouse(sp, TRUE)) {
	    sp->_mouse_type = M_GPM;
	    sp->_mouse_fd = *(my_gpm_fd);
	    T(("GPM mouse_fd %d", sp->_mouse_fd));
	    returnVoid;
	}
    }
#endif /* USE_GPM_SUPPORT */

    /* OS/2 VIO */
#if USE_EMX_MOUSE
    if (!sp->_emxmouse_thread
	&& strstr(cur_term->type.term_names, "xterm") == 0
	&& key_mouse) {
	int handles[2];

	if (pipe(handles) < 0) {
	    perror("mouse pipe error");
	    returnVoid;
	} else {
	    int rc;

	    if (!sp->_emxmouse_buttons[0]) {
		char *s = getenv("MOUSE_BUTTONS_123");

		sp->_emxmouse_buttons[0] = 1;
		if (s && strlen(s) >= 3) {
		    sp->_emxmouse_buttons[1] = s[0] - '0';
		    sp->_emxmouse_buttons[2] = s[1] - '0';
		    sp->_emxmouse_buttons[3] = s[2] - '0';
		} else {
		    sp->_emxmouse_buttons[1] = 1;
		    sp->_emxmouse_buttons[2] = 3;
		    sp->_emxmouse_buttons[3] = 2;
		}
	    }
	    sp->_emxmouse_wfd = handles[1];
	    M_FD(sp) = handles[0];
	    /* Needed? */
	    setmode(handles[0], O_BINARY);
	    setmode(handles[1], O_BINARY);
	    /* Do not use CRT functions, we may single-threaded. */
	    rc = DosCreateThread((unsigned long *) &sp->_emxmouse_thread,
				 mouse_server, (long) sp, 0, 8192);
	    if (rc) {
		printf("mouse thread error %d=%#x", rc, rc);
	    } else {
		sp->_mouse_type = M_XTERM;
	    }
	    returnVoid;
	}
    }
#endif /* USE_EMX_MOUSE */

#if USE_SYSMOUSE
    {
	struct mouse_info the_mouse;
	char *the_device = 0;

	if (isatty(sp->_ifd))
	    the_device = ttyname(sp->_ifd);
	if (the_device == 0)
	    the_device = "/dev/tty";

	sp->_mouse_fd = open(the_device, O_RDWR);

	if (sp->_mouse_fd >= 0) {
	    /*
	     * sysmouse does not have a usable user interface for obtaining
	     * mouse events.  The logical way to proceed (reading data on a
	     * stream) only works if one opens the device as root.  Even in
	     * that mode, careful examination shows we lose events
	     * occasionally.  The interface provided for user programs is to
	     * establish a signal handler.  really.
	     *
	     * Take over SIGUSR2 for this purpose since SIGUSR1 is more
	     * likely to be used by an application.  getch() will have to
	     * handle the misleading EINTR's.
	     */
	    signal(SIGUSR2, SIG_IGN);
	    the_mouse.operation = MOUSE_MODE;
	    the_mouse.u.mode.mode = 0;
	    the_mouse.u.mode.signal = SIGUSR2;
	    if (ioctl(sp->_mouse_fd, CONS_MOUSECTL, &the_mouse) != -1) {
		signal(SIGUSR2, handle_sysmouse);
		the_mouse.operation = MOUSE_SHOW;
		ioctl(sp->_mouse_fd, CONS_MOUSECTL, &the_mouse);

#if defined(FBIO_MODEINFO) || defined(CONS_MODEINFO)	/* FreeBSD > 2.x */
		{
#ifndef FBIO_GETMODE		/* FreeBSD 3.x */
#define FBIO_GETMODE    CONS_GET
#define FBIO_MODEINFO   CONS_MODEINFO
#endif /* FBIO_GETMODE */
		    video_info_t the_video;

		    if (ioctl(sp->_mouse_fd,
			      FBIO_GETMODE,
			      &the_video.vi_mode) != -1
			&& ioctl(sp->_mouse_fd,
				 FBIO_MODEINFO,
				 &the_video) != -1) {
			sp->_sysmouse_char_width = the_video.vi_cwidth;
			sp->_sysmouse_char_height = the_video.vi_cheight;
		    }
		}
#endif /* defined(FBIO_MODEINFO) || defined(CONS_MODEINFO) */

		if (sp->_sysmouse_char_width <= 0)
		    sp->_sysmouse_char_width = 8;
		if (sp->_sysmouse_char_height <= 0)
		    sp->_sysmouse_char_height = 16;
		sp->_mouse_type = M_SYSMOUSE;
		returnVoid;
	    }
	}
    }
#endif /* USE_SYSMOUSE */

    /* we know how to recognize mouse events under "xterm" */
    if (key_mouse != 0) {
	if (!strcmp(key_mouse, xterm_kmous)
	    || strstr(cur_term->type.term_names, "xterm") != 0) {
	    init_xterm_mouse(sp);
	}
    } else if (strstr(cur_term->type.term_names, "xterm") != 0) {
	if (_nc_add_to_try(&(sp->_keytry), xterm_kmous, KEY_MOUSE) == OK)
	    init_xterm_mouse(sp);
    }
    returnVoid;
}

static bool
_nc_mouse_init(SCREEN *sp)
/* initialize the mouse */
{
    bool result = FALSE;
    int i;

    if (sp != 0) {
	if (!sp->_mouse_initialized) {
	    sp->_mouse_initialized = TRUE;

	    TR(MY_TRACE, ("_nc_mouse_init() called"));

	    sp->_mouse_eventp = FirstEV(sp);
	    for (i = 0; i < EV_MAX; i++)
		sp->_mouse_events[i].id = INVALID_EVENT;

	    initialize_mousetype(sp);

	    T(("_nc_mouse_init() set mousetype to %d", sp->_mouse_type));
	}
	result = sp->_mouse_initialized;
    }
    return result;
}

/*
 * Query to see if there is a pending mouse event.  This is called from
 * fifo_push() in lib_getch.c
 */
static bool
_nc_mouse_event(SCREEN *sp GCC_UNUSED)
{
    MEVENT *eventp = sp->_mouse_eventp;
    bool result = FALSE;

    (void) eventp;

    switch (sp->_mouse_type) {
    case M_XTERM:
	/* xterm: never have to query, mouse events are in the keyboard stream */
#if USE_EMX_MOUSE
	{
	    char kbuf[3];

	    int i, res = read(M_FD(sp), &kbuf, 3);	/* Eat the prefix */
	    if (res != 3)
		printf("Got %d chars instead of 3 for prefix.\n", res);
	    for (i = 0; i < res; i++) {
		if (kbuf[i] != key_mouse[i])
		    printf("Got char %d instead of %d for prefix.\n",
			   (int) kbuf[i], (int) key_mouse[i]);
	    }
	    result = TRUE;
	}
#endif /* USE_EMX_MOUSE */
	break;

#if USE_GPM_SUPPORT
    case M_GPM:
	{
	    /* query server for event, return TRUE if we find one */
	    Gpm_Event ev;

	    if (my_Gpm_GetEvent(&ev) == 1) {
		/* there's only one mouse... */
		eventp->id = NORMAL_EVENT;

		eventp->bstate = 0;
		switch (ev.type & 0x0f) {
		case (GPM_DOWN):
		    if (ev.buttons & GPM_B_LEFT)
			eventp->bstate |= BUTTON1_PRESSED;
		    if (ev.buttons & GPM_B_MIDDLE)
			eventp->bstate |= BUTTON2_PRESSED;
		    if (ev.buttons & GPM_B_RIGHT)
			eventp->bstate |= BUTTON3_PRESSED;
		    break;
		case (GPM_UP):
		    if (ev.buttons & GPM_B_LEFT)
			eventp->bstate |= BUTTON1_RELEASED;
		    if (ev.buttons & GPM_B_MIDDLE)
			eventp->bstate |= BUTTON2_RELEASED;
		    if (ev.buttons & GPM_B_RIGHT)
			eventp->bstate |= BUTTON3_RELEASED;
		    break;
		default:
		    break;
		}

		eventp->x = ev.x - 1;
		eventp->y = ev.y - 1;
		eventp->z = 0;

		/* bump the next-free pointer into the circular list */
		sp->_mouse_eventp = eventp = NEXT(eventp);
		result = TRUE;
	    }
	}
	break;
#endif

#if USE_SYSMOUSE
    case M_SYSMOUSE:
	if (sp->_sysmouse_head < sp->_sysmouse_tail) {
	    *eventp = sp->_sysmouse_fifo[sp->_sysmouse_head];

	    /*
	     * Point the fifo-head to the next possible location.  If there
	     * are none, reset the indices.  This may be interrupted by the
	     * signal handler, doing essentially the same reset.
	     */
	    sp->_sysmouse_head += 1;
	    if (sp->_sysmouse_head == sp->_sysmouse_tail) {
		sp->_sysmouse_tail = 0;
		sp->_sysmouse_head = 0;
	    }

	    /* bump the next-free pointer into the circular list */
	    sp->_mouse_eventp = eventp = NEXT(eventp);
	    result = TRUE;
	}
	break;
#endif /* USE_SYSMOUSE */

    case M_NONE:
	break;
    }

    return result;		/* true if we found an event */
}

static bool
_nc_mouse_inline(SCREEN *sp)
/* mouse report received in the keyboard stream -- parse its info */
{
    int b;
    bool result = FALSE;
    MEVENT *eventp = sp->_mouse_eventp;

    TR(MY_TRACE, ("_nc_mouse_inline() called"));

    if (sp->_mouse_type == M_XTERM) {
	unsigned char kbuf[4];
	mmask_t prev;
	size_t grabbed;
	int res;

	/* This code requires that your xterm entry contain the kmous
	 * capability and that it be set to the \E[M documented in the
	 * Xterm Control Sequences reference.  This is how we
	 * arrange for mouse events to be reported via a KEY_MOUSE
	 * return value from wgetch().  After this value is received,
	 * _nc_mouse_inline() gets called and is immediately
	 * responsible for parsing the mouse status information
	 * following the prefix.
	 *
	 * The following quotes from the ctrlseqs.ms document in the
	 * X distribution, describing the X mouse tracking feature:
	 *
	 * Parameters for all mouse tracking escape sequences
	 * generated by xterm encode numeric parameters in a single
	 * character as value+040.  For example, !  is 1.
	 *
	 * On button press or release, xterm sends ESC [ M CbCxCy.
	 * The low two bits of Cb encode button information: 0=MB1
	 * pressed, 1=MB2 pressed, 2=MB3 pressed, 3=release.  The
	 * upper bits encode what modifiers were down when the
	 * button was pressed and are added together.  4=Shift,
	 * 8=Meta, 16=Control.  Cx and Cy are the x and y coordinates
	 * of the mouse event.  The upper left corner is (1,1).
	 *
	 * (End quote)  By the time we get here, we've eaten the
	 * key prefix.  FYI, the loop below is necessary because
	 * mouse click info isn't guaranteed to present as a
	 * single clist item.
	 *
	 * Wheel mice may return buttons 4 and 5 when the wheel is turned.
	 * We encode those as button presses.
	 */
	for (grabbed = 0; grabbed < 3; grabbed += (size_t) res) {

	    /* For VIO mouse we add extra bit 64 to disambiguate button-up. */
#if USE_EMX_MOUSE
	    res = read(M_FD(sp) >= 0 ? M_FD(sp) : sp->_ifd, &kbuf, 3);
#else
	    res = read(sp->_ifd, kbuf + grabbed, 3 - grabbed);
#endif
	    if (res == -1)
		break;
	}
	kbuf[3] = '\0';

	TR(TRACE_IEVENT,
	   ("_nc_mouse_inline sees the following xterm data: '%s'", kbuf));

	/* there's only one mouse... */
	eventp->id = NORMAL_EVENT;

	/* processing code goes here */
	eventp->bstate = 0;
	prev = PREV(eventp)->bstate;

#if USE_EMX_MOUSE
#define PRESS_POSITION(n) \
	eventp->bstate = MASK_PRESS(n); \
	if (kbuf[0] & 0x40) \
	    eventp->bstate = MASK_RELEASE(n)
#else
#define PRESS_POSITION(n) \
	eventp->bstate = (mmask_t) (prev & MASK_PRESS(n) \
				    ? REPORT_MOUSE_POSITION \
				    : MASK_PRESS(n))
#endif

	switch (kbuf[0] & 0x3) {
	case 0x0:
	    if (kbuf[0] & 64)
		eventp->bstate = MASK_PRESS(4);
	    else
		PRESS_POSITION(1);
	    break;

	case 0x1:
#if NCURSES_MOUSE_VERSION == 2
	    if (kbuf[0] & 64)
		eventp->bstate = MASK_PRESS(5);
	    else
#endif
		PRESS_POSITION(2);
	    break;

	case 0x2:
	    PRESS_POSITION(3);
	    break;

	case 0x3:
	    /*
	     * Release events aren't reported for individual buttons, just for
	     * the button set as a whole.  However, because there are normally
	     * no mouse events under xterm that intervene between press and
	     * release, we can infer the button actually released by looking at
	     * the previous event.
	     */
	    if (prev & (BUTTON_PRESSED | BUTTON_RELEASED)) {
		eventp->bstate = BUTTON_RELEASED;
		for (b = 1; b <= MAX_BUTTONS; ++b) {
		    if (!(prev & MASK_PRESS(b)))
			eventp->bstate &= ~MASK_RELEASE(b);
		}
	    } else {
		/*
		 * XFree86 xterm will return a stream of release-events to
		 * let the application know where the mouse is going, if the
		 * private mode 1002 or 1003 is enabled.
		 */
		eventp->bstate = REPORT_MOUSE_POSITION;
	    }
	    break;
	}
	result = (eventp->bstate & REPORT_MOUSE_POSITION) ? TRUE : FALSE;

	if (kbuf[0] & 4) {
	    eventp->bstate |= BUTTON_SHIFT;
	}
	if (kbuf[0] & 8) {
	    eventp->bstate |= BUTTON_ALT;
	}
	if (kbuf[0] & 16) {
	    eventp->bstate |= BUTTON_CTRL;
	}

	eventp->x = (kbuf[1] - ' ') - 1;
	eventp->y = (kbuf[2] - ' ') - 1;
	TR(MY_TRACE,
	   ("_nc_mouse_inline: primitive mouse-event %s has slot %ld",
	    _nc_tracemouse(sp, eventp),
	    (long) IndexEV(sp, eventp)));

	/* bump the next-free pointer into the circular list */
	sp->_mouse_eventp = NEXT(eventp);
#if 0				/* this return would be needed for QNX's mods to lib_getch.c */
	return (TRUE);
#endif
    }

    return (result);
}

static void
mouse_activate(SCREEN *sp, bool on)
{
    if (!on && !sp->_mouse_initialized)
	return;

    if (!_nc_mouse_init(sp))
	return;

    if (on) {

	switch (sp->_mouse_type) {
	case M_XTERM:
#if NCURSES_EXT_FUNCS
	    keyok(KEY_MOUSE, on);
#endif
	    TPUTS_TRACE("xterm mouse initialization");
	    enable_xterm_mouse(sp, 1);
	    break;
#if USE_GPM_SUPPORT
	case M_GPM:
	    if (enable_gpm_mouse(sp, TRUE)) {
		sp->_mouse_fd = *(my_gpm_fd);
		T(("GPM mouse_fd %d", sp->_mouse_fd));
	    }
	    break;
#endif
#if USE_SYSMOUSE
	case M_SYSMOUSE:
	    signal(SIGUSR2, handle_sysmouse);
	    sp->_mouse_active = TRUE;
	    break;
#endif
	case M_NONE:
	    return;
	}
	/* Make runtime binding to cut down on object size of applications that
	 * do not use the mouse (e.g., 'clear').
	 */
	sp->_mouse_event = _nc_mouse_event;
	sp->_mouse_inline = _nc_mouse_inline;
	sp->_mouse_parse = _nc_mouse_parse;
	sp->_mouse_resume = _nc_mouse_resume;
	sp->_mouse_wrap = _nc_mouse_wrap;
    } else {

	switch (sp->_mouse_type) {
	case M_XTERM:
	    TPUTS_TRACE("xterm mouse deinitialization");
	    enable_xterm_mouse(sp, 0);
	    break;
#if USE_GPM_SUPPORT
	case M_GPM:
	    enable_gpm_mouse(sp, FALSE);
	    break;
#endif
#if USE_SYSMOUSE
	case M_SYSMOUSE:
	    signal(SIGUSR2, SIG_IGN);
	    sp->_mouse_active = FALSE;
	    break;
#endif
	case M_NONE:
	    return;
	}
    }
    _nc_flush();
}

/**************************************************************************
 *
 * Device-independent code
 *
 **************************************************************************/

static bool
_nc_mouse_parse(SCREEN *sp, int runcount)
/* parse a run of atomic mouse events into a gesture */
{
    MEVENT *eventp = sp->_mouse_eventp;
    MEVENT *ep, *runp, *next, *prev = PREV(eventp);
    int n;
    int b;
    bool merge;

    TR(MY_TRACE, ("_nc_mouse_parse(%d) called", runcount));

    /*
     * When we enter this routine, the event list next-free pointer
     * points just past a run of mouse events that we know were separated
     * in time by less than the critical click interval. The job of this
     * routine is to collapse this run into a single higher-level event
     * or gesture.
     *
     * We accomplish this in two passes.  The first pass merges press/release
     * pairs into click events.  The second merges runs of click events into
     * double or triple-click events.
     *
     * It's possible that the run may not resolve to a single event (for
     * example, if the user quadruple-clicks).  If so, leading events
     * in the run are ignored.
     *
     * Note that this routine is independent of the format of the specific
     * format of the pointing-device's reports.  We can use it to parse
     * gestures on anything that reports press/release events on a per-
     * button basis, as long as the device-dependent mouse code puts stuff
     * on the queue in MEVENT format.
     */
    if (runcount == 1) {
	TR(MY_TRACE,
	   ("_nc_mouse_parse: returning simple mouse event %s at slot %ld",
	    _nc_tracemouse(sp, prev),
	    (long) IndexEV(sp, prev)));
	return (prev->id >= NORMAL_EVENT)
	    ? ((prev->bstate & sp->_mouse_mask) ? TRUE : FALSE)
	    : FALSE;
    }

    /* find the start of the run */
    runp = eventp;
    for (n = runcount; n > 0; n--) {
	runp = PREV(runp);
    }

#ifdef TRACE
    if (USE_TRACEF(TRACE_IEVENT)) {
	_trace_slot(sp, "before mouse press/release merge:");
	_tracef("_nc_mouse_parse: run starts at %ld, ends at %ld, count %d",
		RunParams(sp, eventp, runp),
		runcount);
	_nc_unlock_global(tracef);
    }
#endif /* TRACE */

    /* first pass; merge press/release pairs */
    do {
	merge = FALSE;
	for (ep = runp; (next = NEXT(ep)) != eventp; ep = next) {

#define MASK_CHANGED(x) (!(ep->bstate & MASK_PRESS(x)) \
		      == !(next->bstate & MASK_RELEASE(x)))

	    if (ep->x == next->x && ep->y == next->y
		&& (ep->bstate & BUTTON_PRESSED)
		&& MASK_CHANGED(1)
		&& MASK_CHANGED(2)
		&& MASK_CHANGED(3)
		&& MASK_CHANGED(4)
#if NCURSES_MOUSE_VERSION == 2
		&& MASK_CHANGED(5)
#endif
		) {
		for (b = 1; b <= MAX_BUTTONS; ++b) {
		    if ((sp->_mouse_mask & MASK_CLICK(b))
			&& (ep->bstate & MASK_PRESS(b))) {
			ep->bstate &= ~MASK_PRESS(b);
			ep->bstate |= MASK_CLICK(b);
			merge = TRUE;
		    }
		}
		if (merge)
		    next->id = INVALID_EVENT;
	    }
	}
    } while
	(merge);

#ifdef TRACE
    if (USE_TRACEF(TRACE_IEVENT)) {
	_trace_slot(sp, "before mouse click merge:");
	_tracef("_nc_mouse_parse: run starts at %ld, ends at %ld, count %d",
		RunParams(sp, eventp, runp),
		runcount);
	_nc_unlock_global(tracef);
    }
#endif /* TRACE */

    /*
     * Second pass; merge click runs.  At this point, click events are
     * each followed by one invalid event. We merge click events
     * forward in the queue.
     *
     * NOTE: There is a problem with this design!  If the application
     * allows enough click events to pile up in the circular queue so
     * they wrap around, it will cheerfully merge the newest forward
     * into the oldest, creating a bogus doubleclick and confusing
     * the queue-traversal logic rather badly.  Generally this won't
     * happen, because calling getmouse() marks old events invalid and
     * ineligible for merges.  The true solution to this problem would
     * be to timestamp each MEVENT and perform the obvious sanity check,
     * but the timer element would have to have sub-second resolution,
     * which would get us into portability trouble.
     */
    do {
	MEVENT *follower;

	merge = FALSE;
	for (ep = runp; (next = NEXT(ep)) != eventp; ep = next)
	    if (ep->id != INVALID_EVENT) {
		if (next->id != INVALID_EVENT)
		    continue;
		follower = NEXT(next);
		if (follower->id == INVALID_EVENT)
		    continue;

		/* merge click events forward */
		if ((ep->bstate & BUTTON_CLICKED)
		    && (follower->bstate & BUTTON_CLICKED)) {
		    for (b = 1; b <= MAX_BUTTONS; ++b) {
			if ((sp->_mouse_mask & MASK_DOUBLE_CLICK(b))
			    && (follower->bstate & MASK_CLICK(b))) {
			    follower->bstate &= ~MASK_CLICK(b);
			    follower->bstate |= MASK_DOUBLE_CLICK(b);
			    merge = TRUE;
			}
		    }
		    if (merge)
			ep->id = INVALID_EVENT;
		}

		/* merge double-click events forward */
		if ((ep->bstate & BUTTON_DOUBLE_CLICKED)
		    && (follower->bstate & BUTTON_CLICKED)) {
		    for (b = 1; b <= MAX_BUTTONS; ++b) {
			if ((sp->_mouse_mask & MASK_TRIPLE_CLICK(b))
			    && (follower->bstate & MASK_CLICK(b))) {
			    follower->bstate &= ~MASK_CLICK(b);
			    follower->bstate |= MASK_TRIPLE_CLICK(b);
			    merge = TRUE;
			}
		    }
		    if (merge)
			ep->id = INVALID_EVENT;
		}
	    }
    } while
	(merge);

#ifdef TRACE
    if (USE_TRACEF(TRACE_IEVENT)) {
	_trace_slot(sp, "before mouse event queue compaction:");
	_tracef("_nc_mouse_parse: run starts at %ld, ends at %ld, count %d",
		RunParams(sp, eventp, runp),
		runcount);
	_nc_unlock_global(tracef);
    }
#endif /* TRACE */

    /*
     * Now try to throw away trailing events flagged invalid, or that
     * don't match the current event mask.
     */
    for (; runcount; prev = PREV(eventp), runcount--)
	if (prev->id == INVALID_EVENT || !(prev->bstate & sp->_mouse_mask)) {
	    sp->_mouse_eventp = eventp = prev;
	}
#ifdef TRACE
    if (USE_TRACEF(TRACE_IEVENT)) {
	_trace_slot(sp, "after mouse event queue compaction:");
	_tracef("_nc_mouse_parse: run starts at %ld, ends at %ld, count %d",
		RunParams(sp, eventp, runp),
		runcount);
	_nc_unlock_global(tracef);
    }
    for (ep = runp; ep != eventp; ep = NEXT(ep))
	if (ep->id != INVALID_EVENT)
	    TR(MY_TRACE,
	       ("_nc_mouse_parse: returning composite mouse event %s at slot %ld",
		_nc_tracemouse(sp, ep),
		(long) IndexEV(sp, ep)));
#endif /* TRACE */

    /* after all this, do we have a valid event? */
    return (PREV(eventp)->id != INVALID_EVENT);
}

static void
_nc_mouse_wrap(SCREEN *sp)
/* release mouse -- called by endwin() before shellout/exit */
{
    TR(MY_TRACE, ("_nc_mouse_wrap() called"));

    switch (sp->_mouse_type) {
    case M_XTERM:
	if (sp->_mouse_mask)
	    mouse_activate(sp, FALSE);
	break;
#if USE_GPM_SUPPORT
	/* GPM: pass all mouse events to next client */
    case M_GPM:
	if (sp->_mouse_mask)
	    mouse_activate(sp, FALSE);
	break;
#endif
#if USE_SYSMOUSE
    case M_SYSMOUSE:
	mouse_activate(sp, FALSE);
	break;
#endif
    case M_NONE:
	break;
    }
}

static void
_nc_mouse_resume(SCREEN *sp)
/* re-connect to mouse -- called by doupdate() after shellout */
{
    TR(MY_TRACE, ("_nc_mouse_resume() called"));

    switch (sp->_mouse_type) {
    case M_XTERM:
	/* xterm: re-enable reporting */
	if (sp->_mouse_mask)
	    mouse_activate(sp, TRUE);
	break;

#if USE_GPM_SUPPORT
    case M_GPM:
	/* GPM: reclaim our event set */
	if (sp->_mouse_mask)
	    mouse_activate(sp, TRUE);
	break;
#endif

#if USE_SYSMOUSE
    case M_SYSMOUSE:
	mouse_activate(sp, TRUE);
	break;
#endif
    case M_NONE:
	break;
    }
}

/**************************************************************************
 *
 * Mouse interface entry points for the API
 *
 **************************************************************************/

static int
_nc_getmouse(SCREEN *sp, MEVENT * aevent)
{
    T((T_CALLED("getmouse(%p)"), aevent));

    if ((aevent != 0) && (sp != 0) && (sp->_mouse_type != M_NONE)) {
	MEVENT *eventp = sp->_mouse_eventp;
	/* compute the current-event pointer */
	MEVENT *prev = PREV(eventp);

	/* copy the event we find there */
	*aevent = *prev;

	TR(TRACE_IEVENT, ("getmouse: returning event %s from slot %ld",
			  _nc_tracemouse(sp, prev),
			  (long) IndexEV(sp, prev)));

	prev->id = INVALID_EVENT;	/* so the queue slot becomes free */
	returnCode(OK);
    }
    returnCode(ERR);
}

/* grab a copy of the current mouse event */
NCURSES_EXPORT(int)
getmouse(MEVENT * aevent)
{
    return _nc_getmouse(SP, aevent);
}

static int
_nc_ungetmouse(SCREEN *sp, MEVENT * aevent)
{
    int result = ERR;

    T((T_CALLED("ungetmouse(%p)"), aevent));

    if (aevent != 0 && sp != 0) {
	MEVENT *eventp = sp->_mouse_eventp;

	/* stick the given event in the next-free slot */
	*eventp = *aevent;

	/* bump the next-free pointer into the circular list */
	sp->_mouse_eventp = NEXT(eventp);

	/* push back the notification event on the keyboard queue */
	result = _nc_ungetch(sp, KEY_MOUSE);
    }
    returnCode(result);
}

/* enqueue a synthesized mouse event to be seen by the next wgetch() */
NCURSES_EXPORT(int)
ungetmouse(MEVENT * aevent)
{
    return _nc_ungetmouse(SP, aevent);
}

NCURSES_EXPORT(mmask_t)
mousemask(mmask_t newmask, mmask_t * oldmask)
/* set the mouse event mask */
{
    mmask_t result = 0;

    T((T_CALLED("mousemask(%#lx,%p)"), (unsigned long) newmask, oldmask));

    if (SP != 0) {
	if (oldmask)
	    *oldmask = SP->_mouse_mask;

	if (newmask || SP->_mouse_initialized) {
	    _nc_mouse_init(SP);
	    if (SP->_mouse_type != M_NONE) {
		result = newmask &
		    (REPORT_MOUSE_POSITION
		     | BUTTON_ALT
		     | BUTTON_CTRL
		     | BUTTON_SHIFT
		     | BUTTON_PRESSED
		     | BUTTON_RELEASED
		     | BUTTON_CLICKED
		     | BUTTON_DOUBLE_CLICKED
		     | BUTTON_TRIPLE_CLICKED);

		mouse_activate(SP, (bool) (result != 0));

		SP->_mouse_mask = result;
	    }
	}
    }
    returnBits(result);
}

NCURSES_EXPORT(bool)
wenclose(const WINDOW *win, int y, int x)
/* check to see if given window encloses given screen location */
{
    bool result = FALSE;

    T((T_CALLED("wenclose(%p,%d,%d)"), win, y, x));

    if (win != 0) {
	y -= win->_yoffset;
	result = ((win->_begy <= y &&
		   win->_begx <= x &&
		   (win->_begx + win->_maxx) >= x &&
		   (win->_begy + win->_maxy) >= y) ? TRUE : FALSE);
    }
    returnBool(result);
}

NCURSES_EXPORT(int)
mouseinterval(int maxclick)
/* set the maximum mouse interval within which to recognize a click */
{
    int oldval;

    T((T_CALLED("mouseinterval(%d)"), maxclick));

    if (SP != 0) {
	oldval = SP->_maxclick;
	if (maxclick >= 0)
	    SP->_maxclick = maxclick;
    } else {
	oldval = DEFAULT_MAXCLICK;
    }

    returnCode(oldval);
}

/* This may be used by other routines to ask for the existence of mouse
   support */
NCURSES_EXPORT(int)
_nc_has_mouse(void)
{
    return (SP->_mouse_type == M_NONE ? 0 : 1);
}

NCURSES_EXPORT(bool)
wmouse_trafo(const WINDOW *win, int *pY, int *pX, bool to_screen)
{
    bool result = FALSE;

    T((T_CALLED("wmouse_trafo(%p,%p,%p,%d)"), win, pY, pX, to_screen));

    if (win && pY && pX) {
	int y = *pY;
	int x = *pX;

	if (to_screen) {
	    y += win->_begy + win->_yoffset;
	    x += win->_begx;
	    if (wenclose(win, y, x))
		result = TRUE;
	} else {
	    if (wenclose(win, y, x)) {
		y -= (win->_begy + win->_yoffset);
		x -= win->_begx;
		result = TRUE;
	    }
	}
	if (result) {
	    *pX = x;
	    *pY = y;
	}
    }
    returnBool(result);
}
@


1.13
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.12 2000/10/22 18:27:22 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d41 5
a45 2
 * The first method used is xterm's internal mouse-tracking facility.
 * The second is Alessandro Rubini's GPM server.
d83 3
d87 1
a89 3
#ifndef LINT			/* don't need this for llib-lncurses */
#undef buttons			/* term.h defines this, and gpm uses it! */
#include <gpm.h>
d91 12
d104 14
d119 1
d121 1
a121 1
MODULE_ID("$From: lib_mouse.c,v 1.57 2000/12/10 02:43:27 tom Exp $")
d123 22
a144 1
#define MY_TRACE TRACE_ICALLS|TRACE_IEVENT
d147 1
d149 1
a149 6
static int mousetype;
#define M_XTERM		-1	/* use xterm's mouse tracking? */
#define M_NONE		0	/* no mouse device */
#define M_GPM		1	/* use GPM */
#define M_QNX		2	/* QNX mouse on console */
#define M_QNX_TERM	3	/* QNX mouse on pterm/xterm (using qansi-m) */
d151 2
a152 4
#if USE_GPM_SUPPORT
#ifndef LINT
static Gpm_Connect gpm_connect;
#endif
d155 3
a157 1
static mmask_t eventmask;	/* current event mask */
d159 1
a159 1
static bool _nc_mouse_parse(int);
d165 18
a182 8
/* The definition of the circular list size (EV_MAX), is in curses.priv.h, so
 * wgetch() may refer to the size and call _nc_mouse_parse() before circular
 * list overflow.
 */
static MEVENT events[EV_MAX];	/* hold the last mouse event seen */
static MEVENT *eventp = events;	/* next free slot in event queue */
#define NEXT(ep)	((ep == events + EV_MAX - 1) ? events : ep + 1)
#define PREV(ep)	((ep == events) ? events + EV_MAX - 1 : ep - 1)
d186 1
a186 1
_trace_slot(const char *tag)
d192 1
a192 1
    for (ep = events; ep < events + EV_MAX; ep++)
d194 2
a195 2
		(long) (ep - events),
		_tracemouse(ep));
d199 1
a199 1
#ifdef USE_EMX_MOUSE
a203 6
static int mouse_wfd;
static int mouse_thread;
static int mouse_activated;
static char mouse_buttons[] =
{0, 1, 3, 2};

d207 1
a207 1
write_event(int down, int button, int x, int y)
d216 1
a216 1
    DosWrite(mouse_wfd, buf, 6, &ignore);
d220 1
a220 1
mouse_server(unsigned long ignored GCC_UNUSED)
d222 1
d246 1
a246 2
		    snprintf(err, sizeof(err),
			     "Error reading mouse queue, rc=%lu.\r\n", rc);
d249 1
a249 1
		if (!mouse_activated)
d260 2
a261 2
		    write_event(mouev.fs & MOUSE_BN1_DOWN,
				mouse_buttons[1], mouev.col, mouev.row);
d263 2
a264 2
		    write_event(mouev.fs & MOUSE_BN2_DOWN,
				mouse_buttons[3], mouev.col, mouev.row);
d266 2
a267 2
		    write_event(mouev.fs & MOUSE_BN3_DOWN,
				mouse_buttons[2], mouev.col, mouev.row);
d273 2
a274 3
	    snprintf(err, sizeof(err),
		     "Error setting event mask, buttons=%d, rc=%lu.\r\n",
		     nbuttons, rc);
d282 67
d350 6
a355 3
server_state(const int state)
{				/* It would be nice to implement pointer-off and stop looping... */
    mouse_activated = state;
d358 7
d366 2
d369 5
a373 1
static int initialized;
d375 25
d401 1
a401 1
initialize_mousetype(void)
d403 86
a488 1
    static const char *xterm_kmous = "\033[M";
d492 21
a512 9
    /* GPM: initialize connection to gpm server */
    gpm_connect.eventMask = GPM_DOWN | GPM_UP;
    gpm_connect.defaultMask = ~(gpm_connect.eventMask | GPM_HARD);
    gpm_connect.minMod = 0;
    gpm_connect.maxMod = ~((1 << KG_SHIFT) | (1 << KG_SHIFTL) | (1 << KG_SHIFTR));
    if (Gpm_Open(&gpm_connect, 0) >= 0) {	/* returns the file-descriptor */
	mousetype = M_GPM;
	SP->_mouse_fd = gpm_fd;
	return;
d514 1
a514 1
#endif
d517 2
a518 2
#ifdef USE_EMX_MOUSE
    if (!mouse_thread
d525 1
a525 1
	    return;
d529 1
a529 1
	    if (!mouse_buttons[0]) {
d532 1
a532 1
		mouse_buttons[0] = 1;
d534 7
a540 3
		    mouse_buttons[1] = s[0] - '0';
		    mouse_buttons[2] = s[1] - '0';
		    mouse_buttons[3] = s[2] - '0';
d543 2
a544 2
	    mouse_wfd = handles[1];
	    M_FD(SP) = handles[0];
d549 2
a550 2
	    rc = DosCreateThread((unsigned long *) &mouse_thread,
				 mouse_server, 0, 0, 8192);
a552 1
		return;
d554 1
a554 2
		mousetype = M_XTERM;
		return;
d556 1
d559 66
a624 1
#endif
d628 3
a630 3
	if (!strcmp(key_mouse, xterm_kmous)) {
	    mousetype = M_XTERM;
	    return;
d633 2
a634 3
	(void) _nc_add_to_try(&(SP->_keytry), xterm_kmous, KEY_MOUSE);
	mousetype = M_XTERM;
	return;
d636 1
d639 2
a640 2
static void
_nc_mouse_init(void)
d643 1
d646 3
a648 2
    if (!initialized) {
	initialized = TRUE;
d650 1
a650 1
	TR(MY_TRACE, ("_nc_mouse_init() called"));
d652 3
a654 2
	for (i = 0; i < EV_MAX; i++)
	    events[i].id = INVALID_EVENT;
d656 1
a656 1
	initialize_mousetype();
d658 3
a660 1
	T(("_nc_mouse_init() set mousetype to %d", mousetype));
d662 1
d665 4
d670 1
a670 2
_nc_mouse_event(SCREEN * sp GCC_UNUSED)
/* query to see if there is a pending mouse event */
d672 25
d698 30
a727 2
    /* GPM: query server for event, return TRUE if we find one */
    Gpm_Event ev;
d729 3
a731 4
    if (gpm_fd >= 0
	&& (_nc_timed_wait(3, 0, (int *) 0) & 2) != 0
	&& Gpm_GetEvent(&ev) == 1) {
	eventp->id = 0;		/* there's only one mouse... */
d733 4
a736 20
	eventp->bstate = 0;
	switch (ev.type & 0x0f) {
	case (GPM_DOWN):
	    if (ev.buttons & GPM_B_LEFT)
		eventp->bstate |= BUTTON1_PRESSED;
	    if (ev.buttons & GPM_B_MIDDLE)
		eventp->bstate |= BUTTON2_PRESSED;
	    if (ev.buttons & GPM_B_RIGHT)
		eventp->bstate |= BUTTON3_PRESSED;
	    break;
	case (GPM_UP):
	    if (ev.buttons & GPM_B_LEFT)
		eventp->bstate |= BUTTON1_RELEASED;
	    if (ev.buttons & GPM_B_MIDDLE)
		eventp->bstate |= BUTTON2_RELEASED;
	    if (ev.buttons & GPM_B_RIGHT)
		eventp->bstate |= BUTTON3_RELEASED;
	    break;
	default:
	    break;
d738 2
d741 4
a744 3
	eventp->x = ev.x - 1;
	eventp->y = ev.y - 1;
	eventp->z = 0;
d746 10
a755 5
	/* bump the next-free pointer into the circular list */
	eventp = NEXT(eventp);
	return (TRUE);
    }
#endif
d757 3
a759 12
#ifdef USE_EMX_MOUSE
    if (SP->_mouse_fd >= 0
	&& (_nc_timed_wait(3, 0, (int *) 0) & 2) != 0) {
	char kbuf[3];

	int i, res = read(M_FD(sp), &kbuf, 3);	/* Eat the prefix */
	if (res != 3)
	    printf("Got %d chars instead of 3 for prefix.\n", res);
	for (i = 0; i < res; i++) {
	    if (kbuf[i] != key_mouse[i])
		printf("Got char %d instead of %d for prefix.\n",
		       (int) kbuf[i], (int) key_mouse[i]);
d761 5
a765 1
	return TRUE;
a766 1
#endif /* USE_EMX_MOUSE */
d768 1
a768 2
    /* xterm: never have to query, mouse events are in the keyboard stream */
    return (FALSE);		/* no event waiting */
d772 1
a772 1
_nc_mouse_inline(SCREEN * sp)
d775 4
d781 1
a781 1
    if (mousetype == M_XTERM) {
d783 1
a783 1
	MEVENT *prev;
d814 4
a817 2
	 * single clist item.  It always does under Linux but often
	 * fails to under Solaris.
d819 1
a819 1
	for (grabbed = 0; grabbed < 3; grabbed += res) {
d822 1
a822 1
#ifdef USE_EMX_MOUSE
d835 2
a836 1
	eventp->id = 0;		/* there's only one mouse... */
d840 14
d856 4
a859 5
	    eventp->bstate = BUTTON1_PRESSED;
#ifdef USE_EMX_MOUSE
	    if (kbuf[0] & 0x40)
		eventp->bstate = BUTTON1_RELEASED;
#endif
d863 4
a866 4
	    eventp->bstate = BUTTON2_PRESSED;
#ifdef USE_EMX_MOUSE
	    if (kbuf[0] & 0x40)
		eventp->bstate = BUTTON2_RELEASED;
d868 1
d872 1
a872 5
	    eventp->bstate = BUTTON3_PRESSED;
#ifdef USE_EMX_MOUSE
	    if (kbuf[0] & 0x40)
		eventp->bstate = BUTTON3_RELEASED;
#endif
d877 5
a881 2
	     * Release events aren't reported for individual buttons,
	     * just for the button set as a whole...
d883 14
a896 17
	    eventp->bstate =
		(BUTTON1_RELEASED |
		 BUTTON2_RELEASED |
		 BUTTON3_RELEASED);
	    /*
	     * ...however, because there are no kinds of mouse events under
	     * xterm that can intervene between press and release, we can
	     * deduce which buttons were actually released by looking at the
	     * previous event.
	     */
	    prev = PREV(eventp);
	    if (!(prev->bstate & BUTTON1_PRESSED))
		eventp->bstate &= ~BUTTON1_RELEASED;
	    if (!(prev->bstate & BUTTON2_PRESSED))
		eventp->bstate &= ~BUTTON2_RELEASED;
	    if (!(prev->bstate & BUTTON3_PRESSED))
		eventp->bstate &= ~BUTTON3_RELEASED;
d899 1
d915 2
a916 2
	    _tracemouse(eventp),
	    (long) (eventp - events)));
d919 1
a919 1
	eventp = NEXT(eventp);
d925 1
a925 1
    return (FALSE);
d929 1
a929 1
mouse_activate(bool on)
d931 1
a931 1
    if (!on && !initialized)
d934 2
a935 1
    _nc_mouse_init();
d939 1
a939 1
	switch (mousetype) {
d945 1
a945 5
#ifdef USE_EMX_MOUSE
	    server_state(1);
#else
	    putp("\033[?1000h");
#endif
d949 10
a958 1
	    SP->_mouse_fd = gpm_fd;
d961 2
d967 5
a971 6
	SP->_mouse_event = _nc_mouse_event;
	SP->_mouse_inline = _nc_mouse_inline;
	SP->_mouse_parse = _nc_mouse_parse;
	SP->_mouse_resume = _nc_mouse_resume;
	SP->_mouse_wrap = _nc_mouse_wrap;

d974 1
a974 1
	switch (mousetype) {
d977 1
a977 5
#ifdef USE_EMX_MOUSE
	    server_state(0);
#else
	    putp("\033[?1000l");
#endif
d981 1
d984 8
d1004 1
a1004 1
_nc_mouse_parse(int runcount)
d1007 1
d1010 1
d1019 1
a1019 1
     * routine is to collaps this run into a single higher-level event
d1039 4
a1042 4
	    _tracemouse(prev),
	    (long) (prev - events)));
	return (prev->id >= 0)
	    ? ((prev->bstate & eventmask) ? TRUE : FALSE)
d1053 2
a1054 2
    if (_nc_tracing & TRACE_IEVENT) {
	_trace_slot("before mouse press/release merge:");
d1056 1
a1056 2
		(long) (runp - events),
		(long) ((eventp - events) + (EV_MAX - 1)) % EV_MAX,
d1058 1
d1065 5
a1069 1
	for (ep = runp; next = NEXT(ep), next != eventp; ep = next) {
d1071 8
a1078 7
		&& (ep->bstate & (BUTTON1_PRESSED | BUTTON2_PRESSED | BUTTON3_PRESSED))
		&& (!(ep->bstate & BUTTON1_PRESSED)
		    == !(next->bstate & BUTTON1_RELEASED))
		&& (!(ep->bstate & BUTTON2_PRESSED)
		    == !(next->bstate & BUTTON2_RELEASED))
		&& (!(ep->bstate & BUTTON3_PRESSED)
		    == !(next->bstate & BUTTON3_RELEASED))
d1080 7
a1086 17
		if ((eventmask & BUTTON1_CLICKED)
		    && (ep->bstate & BUTTON1_PRESSED)) {
		    ep->bstate &= ~BUTTON1_PRESSED;
		    ep->bstate |= BUTTON1_CLICKED;
		    merge = TRUE;
		}
		if ((eventmask & BUTTON2_CLICKED)
		    && (ep->bstate & BUTTON2_PRESSED)) {
		    ep->bstate &= ~BUTTON2_PRESSED;
		    ep->bstate |= BUTTON2_CLICKED;
		    merge = TRUE;
		}
		if ((eventmask & BUTTON3_CLICKED)
		    && (ep->bstate & BUTTON3_PRESSED)) {
		    ep->bstate &= ~BUTTON3_PRESSED;
		    ep->bstate |= BUTTON3_CLICKED;
		    merge = TRUE;
d1096 2
a1097 2
    if (_nc_tracing & TRACE_IEVENT) {
	_trace_slot("before mouse click merge:");
d1099 1
a1099 2
		(long) (runp - events),
		(long) ((eventp - events) + (EV_MAX - 1)) % EV_MAX,
d1101 1
d1125 1
a1125 1
	for (ep = runp; next = NEXT(ep), next != eventp; ep = next)
d1134 9
a1142 21
		if ((ep->bstate &
		     (BUTTON1_CLICKED | BUTTON2_CLICKED | BUTTON3_CLICKED))
		    && (follower->bstate &
			(BUTTON1_CLICKED | BUTTON2_CLICKED | BUTTON3_CLICKED))) {
		    if ((eventmask & BUTTON1_DOUBLE_CLICKED)
			&& (follower->bstate & BUTTON1_CLICKED)) {
			follower->bstate &= ~BUTTON1_CLICKED;
			follower->bstate |= BUTTON1_DOUBLE_CLICKED;
			merge = TRUE;
		    }
		    if ((eventmask & BUTTON2_DOUBLE_CLICKED)
			&& (follower->bstate & BUTTON2_CLICKED)) {
			follower->bstate &= ~BUTTON2_CLICKED;
			follower->bstate |= BUTTON2_DOUBLE_CLICKED;
			merge = TRUE;
		    }
		    if ((eventmask & BUTTON3_DOUBLE_CLICKED)
			&& (follower->bstate & BUTTON3_CLICKED)) {
			follower->bstate &= ~BUTTON3_CLICKED;
			follower->bstate |= BUTTON3_DOUBLE_CLICKED;
			merge = TRUE;
d1149 9
a1157 23
		if ((ep->bstate &
		     (BUTTON1_DOUBLE_CLICKED
		      | BUTTON2_DOUBLE_CLICKED
		      | BUTTON3_DOUBLE_CLICKED))
		    && (follower->bstate &
			(BUTTON1_CLICKED | BUTTON2_CLICKED | BUTTON3_CLICKED))) {
		    if ((eventmask & BUTTON1_TRIPLE_CLICKED)
			&& (follower->bstate & BUTTON1_CLICKED)) {
			follower->bstate &= ~BUTTON1_CLICKED;
			follower->bstate |= BUTTON1_TRIPLE_CLICKED;
			merge = TRUE;
		    }
		    if ((eventmask & BUTTON2_TRIPLE_CLICKED)
			&& (follower->bstate & BUTTON2_CLICKED)) {
			follower->bstate &= ~BUTTON2_CLICKED;
			follower->bstate |= BUTTON2_TRIPLE_CLICKED;
			merge = TRUE;
		    }
		    if ((eventmask & BUTTON3_TRIPLE_CLICKED)
			&& (follower->bstate & BUTTON3_CLICKED)) {
			follower->bstate &= ~BUTTON3_CLICKED;
			follower->bstate |= BUTTON3_TRIPLE_CLICKED;
			merge = TRUE;
d1167 2
a1168 2
    if (_nc_tracing & TRACE_IEVENT) {
	_trace_slot("before mouse event queue compaction:");
d1170 1
a1170 2
		(long) (runp - events),
		(long) ((eventp - events) + (EV_MAX - 1)) % EV_MAX,
d1172 1
d1181 2
a1182 2
	if (prev->id == INVALID_EVENT || !(prev->bstate & eventmask)) {
	    eventp = prev;
d1185 2
a1186 2
    if (_nc_tracing & TRACE_IEVENT) {
	_trace_slot("after mouse event queue compaction:");
d1188 1
a1188 2
		(long) (runp - events),
		(long) ((eventp - events) + (EV_MAX - 1)) % EV_MAX,
d1190 1
d1196 2
a1197 2
		_tracemouse(ep),
		(long) (ep - events)));
d1205 1
a1205 1
_nc_mouse_wrap(SCREEN * sp GCC_UNUSED)
d1210 1
a1210 1
    switch (mousetype) {
d1212 2
a1213 2
	if (eventmask)
	    mouse_activate(FALSE);
d1218 2
d1222 7
d1233 1
a1233 1
_nc_mouse_resume(SCREEN * sp GCC_UNUSED)
d1238 14
a1251 3
    /* xterm: re-enable reporting */
    if (mousetype == M_XTERM && eventmask)
	mouse_activate(TRUE);
d1253 8
a1260 1
    /* GPM: reclaim our event set */
d1269 2
a1270 3
NCURSES_EXPORT(int)
getmouse(MEVENT * aevent)
/* grab a copy of the current mouse event */
d1274 2
a1275 1
    if (aevent && (mousetype != M_NONE)) {
d1283 2
a1284 2
			  _tracemouse(prev),
			  (long) (prev - events)));
d1292 1
d1294 7
a1300 2
ungetmouse(MEVENT * aevent)
/* enqueue a synthesized mouse event to be seen by the next wgetch() */
d1302 3
a1304 2
    /* stick the given event in the next-free slot */
    *eventp = *aevent;
d1306 2
a1307 2
    /* bump the next-free pointer into the circular list */
    eventp = NEXT(eventp);
d1309 17
a1325 2
    /* push back the notification event on the keyboard queue */
    return ungetch(KEY_MOUSE);
d1334 1
a1334 1
    T((T_CALLED("mousemask(%#lx,%p)"), newmask, oldmask));
d1336 3
a1338 2
    if (oldmask)
	*oldmask = eventmask;
d1340 13
a1352 2
    if (!newmask && !initialized)
	returnCode(0);
d1354 1
a1354 10
    _nc_mouse_init();
    if (mousetype != M_NONE) {
	eventmask = newmask &
	    (BUTTON_ALT | BUTTON_CTRL | BUTTON_SHIFT
	     | BUTTON1_PRESSED | BUTTON1_RELEASED | BUTTON1_CLICKED
	     | BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED
	     | BUTTON2_PRESSED | BUTTON2_RELEASED | BUTTON2_CLICKED
	     | BUTTON2_DOUBLE_CLICKED | BUTTON2_TRIPLE_CLICKED
	     | BUTTON3_PRESSED | BUTTON3_RELEASED | BUTTON3_CLICKED
	     | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED);
d1356 3
a1358 3
	mouse_activate(eventmask != 0);

	result = eventmask;
d1360 1
a1360 2

    returnCode(result);
d1367 5
a1371 1
    if (win) {
d1373 4
a1376 4
	return ((win->_begy <= y &&
		 win->_begx <= x &&
		 (win->_begx + win->_maxx) >= x &&
		 (win->_begy + win->_maxy) >= y) ? TRUE : FALSE);
d1378 1
a1378 1
    return FALSE;
d1387 2
d1397 1
a1397 1
    return (oldval);
d1405 1
a1405 1
    return (mousetype == M_NONE ? 0 : 1);
d1409 1
a1409 2
wmouse_trafo
(const WINDOW *win, int *pY, int *pX, bool to_screen)
d1413 2
d1436 1
a1436 1
    return (result);
a1437 2

/* lib_mouse.c ends here */
@


1.12
log
@update to ncurses 5.2
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.11 2000/10/08 22:46:59 millert Exp $	*/
d89 1
a89 1
MODULE_ID("$From: lib_mouse.c,v 1.55 2000/10/10 00:07:28 Ilya.Zakharevich Exp $")
d870 1
a870 1
int
d893 1
a893 1
int
d907 1
a907 1
mmask_t
d940 1
a940 1
bool
d954 1
a954 1
int
d973 1
a973 1
int
d979 3
a981 2
bool
wmouse_trafo(const WINDOW *win, int *pY, int *pX, bool to_screen)
@


1.11
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.10 2000/07/10 03:06:14 millert Exp $	*/
d89 1
a89 1
MODULE_ID("$From: lib_mouse.c,v 1.54 2000/10/03 08:26:34 tom Exp $")
d135 2
a136 2
	    (long) (ep - events),
	    _tracemouse(ep));
d174 1
d176 2
a177 2
    char errmess[] = "Unexpected termination of mouse thread\r\n";
    unsigned long ignore;
d181 7
a187 4

	if (MouSetEventMask(&mask, hmou) == 0
	    && MouDrawPtr(hmou) == 0) {

d190 4
a193 1
		if (MouReadEventQue(&mouev, &fWait, hmou))
d195 1
d208 1
a208 1
			mouse_buttons[1], mouev.col, mouev.row);
d211 1
a211 1
			mouse_buttons[3], mouev.col, mouev.row);
d214 1
a214 1
			mouse_buttons[2], mouev.col, mouev.row);
d219 4
a222 1
	}
d224 1
a224 1
	DosWrite(2, errmess, strlen(errmess), &ignore);
d229 1
d265 1
d268 1
d289 1
a289 1
		mouse_server, 0, 0, 8192);
d292 1
d379 17
d456 1
a456 1
	    ("_nc_mouse_inline sees the following xterm data: '%s'", kbuf));
d494 2
a495 2
		BUTTON2_RELEASED |
		BUTTON3_RELEASED);
d525 3
a527 3
	    ("_nc_mouse_inline: primitive mouse-event %s has slot %ld",
		_tracemouse(eventp),
		(long) (eventp - events)));
d635 3
a637 3
	    ("_nc_mouse_parse: returning simple mouse event %s at slot %ld",
		_tracemouse(prev),
		(long) (prev - events)));
d653 3
a655 3
	    (long) (runp - events),
	    (long) ((eventp - events) + (EV_MAX - 1)) % EV_MAX,
	    runcount);
d701 3
a703 3
	    (long) (runp - events),
	    (long) ((eventp - events) + (EV_MAX - 1)) % EV_MAX,
	    runcount);
d737 1
a737 1
			(BUTTON1_CLICKED | BUTTON2_CLICKED | BUTTON3_CLICKED))
d764 3
a766 3
			(BUTTON1_DOUBLE_CLICKED
			    | BUTTON2_DOUBLE_CLICKED
			    | BUTTON3_DOUBLE_CLICKED))
d798 3
a800 3
	    (long) (runp - events),
	    (long) ((eventp - events) + (EV_MAX - 1)) % EV_MAX,
	    runcount);
d816 3
a818 3
	    (long) (runp - events),
	    (long) ((eventp - events) + (EV_MAX - 1)) % EV_MAX,
	    runcount);
d823 3
a825 3
		("_nc_mouse_parse: returning composite mouse event %s at slot %ld",
		    _tracemouse(ep),
		    (long) (ep - events)));
d884 2
a885 2
		_tracemouse(prev),
		(long) (prev - events)));
d925 6
a930 6
	    | BUTTON1_PRESSED | BUTTON1_RELEASED | BUTTON1_CLICKED
	    | BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED
	    | BUTTON2_PRESSED | BUTTON2_RELEASED | BUTTON2_CLICKED
	    | BUTTON2_DOUBLE_CLICKED | BUTTON2_TRIPLE_CLICKED
	    | BUTTON3_PRESSED | BUTTON3_RELEASED | BUTTON3_CLICKED
	    | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED);
d947 3
a949 3
		win->_begx <= x &&
		(win->_begx + win->_maxx) >= x &&
		(win->_begy + win->_maxy) >= y) ? TRUE : FALSE);
@


1.10
log
@ncurses 5.1
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.9 2000/03/26 16:45:03 millert Exp $	*/
d89 1
a89 1
MODULE_ID("$From: lib_mouse.c,v 1.52 2000/06/29 23:02:26 tom Exp $")
d159 1
a159 1
    strcpy(buf, key_mouse);
d519 1
a519 1
#ifdef NCURSES_EXT_FUNCS
@


1.9
log
@Update to ncurses-5.0-20000325
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.8 2000/03/10 01:35:02 millert Exp $	*/
d89 1
a89 1
MODULE_ID("$From: lib_mouse.c,v 1.51 2000/03/18 22:11:42 tom Exp $")
d328 1
a328 1
	&& _nc_timed_wait(2, 0, (int *) 0)
@


1.8
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.7 2000/01/09 05:06:02 millert Exp $	*/
d89 1
a89 1
MODULE_ID("$From: lib_mouse.c,v 1.50 2000/02/13 00:59:39 tom Exp $")
d231 1
a231 1
    static char *xterm_kmous = "\033[M";
@


1.7
log
@Update to ncurses-5.0-20000108:
+ add prototype for erase() to curses.h
+ add TRACE_DATABASE flag for trace().
+ formatting changes (style)
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.6 1999/12/28 15:57:59 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d89 1
a89 1
MODULE_ID("$From: lib_mouse.c,v 1.48 2000/01/08 17:34:43 tom Exp $");
@


1.6
log
@Update to ncurses-19991218
 o reorder tests during mouse initialization to allow for gpm to run in
   xterm, or for xterm to be used under OS/2 EMX.  Also drop test for
   $DISPLAY in favor of kmous=\E[M or $TERM containing "xterm" (report
   by Christian Weisgerber <naddy@@mips.rhein-neckar.de>).
 o modify raw() and noraw() to clear/restore IEXTEN flag which affects
   stty lnext on systems such as FreeBSD (report by Bruce Evans
   <bde@@zeta.org.au>, via Jason Evans <jasone@@canonware.com>).
 o add manual-page for ncurses extensions, documented curses_version(),
   use_extended_names().
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.5 1999/11/28 17:49:53 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
d69 1
a69 2
#  include "io.h"
#  include "fcntl.h"
d89 1
a89 1
MODULE_ID("$From: lib_mouse.c,v 1.47 1999/12/19 01:49:40 tom Exp $")
d424 1
a424 1
		("_nc_mouse_inline sees the following xterm data: '%s'", kbuf));
d493 1
a493 1
		("_nc_mouse_inline: primitive mouse-event %s has slot %ld",
d603 1
a603 1
		("_nc_mouse_parse: returning simple mouse event %s at slot %ld",
d791 1
a791 1
		    ("_nc_mouse_parse: returning composite mouse event %s at slot %ld",
@


1.5
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.4 1999/08/15 11:40:55 millert Exp $	*/
d90 1
a90 1
MODULE_ID("$From: lib_mouse.c,v 1.45 1999/10/22 21:39:02 tom Exp $")
d96 1
a96 1
static int		mousetype;
d109 1
a109 1
static mmask_t	eventmask;		/* current event mask */
d121 2
a122 2
static MEVENT	events[EV_MAX];		/* hold the last mouse event seen */
static MEVENT	*eventp = events;	/* next free slot in event queue */
d127 2
a128 1
static void _trace_slot(const char *tag)
d130 1
a130 1
	MEVENT *ep;
d132 1
a132 1
	_tracef(tag);
d134 4
a137 4
	for (ep = events; ep < events + EV_MAX; ep++)
		_tracef("mouse event queue slot %ld = %s",
			(long) (ep - events),
			_tracemouse(ep));
d149 2
a150 2
static char mouse_buttons[] = { 0, 1, 3, 2};

d180 1
a180 1
    if (MouOpen(NULL,&hmou) == 0) {
d182 2
a183 2
	if (MouSetEventMask(&mask,hmou) == 0
	 && MouDrawPtr(hmou) == 0) {
d187 2
a188 2
		if (MouReadEventQue(&mouev,&fWait,hmou))
			break;
d195 3
a197 3
		 *	1 = left
		 *	2 = right
		 *	3 = middle.
d200 2
a201 2
		    write_event(mouev.fs  & MOUSE_BN1_DOWN,
				mouse_buttons[1], mouev.col, mouev.row);
d203 2
a204 2
		    write_event(mouev.fs  & MOUSE_BN2_DOWN,
				mouse_buttons[3], mouev.col, mouev.row);
d206 2
a207 2
		    write_event(mouev.fs  & MOUSE_BN3_DOWN,
				mouse_buttons[2], mouev.col, mouev.row);
d217 1
a217 1
    DosExit(EXIT_THREAD, 0L );
d221 1
a221 1
{ /* It would be nice to implement pointer-off and stop looping... */
d229 2
a230 2
static void _nc_mouse_init(void)
/* initialize the mouse */
d232 1
a232 1
    int i;
d234 10
a243 1
    if (initialized) {
a245 25
    initialized = TRUE;

    TR(MY_TRACE, ("_nc_mouse_init() called"));

    for (i = 0; i < EV_MAX; i++)
	events[i].id = INVALID_EVENT;

    /* we know how to recognize mouse events under xterm */
    if (key_mouse != 0
     && getenv("DISPLAY") != 0)
	mousetype = M_XTERM;

#if USE_GPM_SUPPORT
    else if (!strncmp(cur_term->type.term_names, "linux", 5))
    {
	/* GPM: initialize connection to gpm server */
	gpm_connect.eventMask = GPM_DOWN|GPM_UP;
	gpm_connect.defaultMask = ~(gpm_connect.eventMask|GPM_HARD);
	gpm_connect.minMod = 0;
	gpm_connect.maxMod = ~((1<<KG_SHIFT)|(1<<KG_SHIFTL)|(1<<KG_SHIFTR));
	if (Gpm_Open (&gpm_connect, 0) >= 0) { /* returns the file-descriptor */
	    mousetype = M_GPM;
	    SP->_mouse_fd = gpm_fd;
	}
    }
d250 3
a252 1
    if (!mouse_thread && mousetype != M_XTERM && key_mouse) {
d275 3
a277 2
	    rc = DosCreateThread((unsigned long*)&mouse_thread, mouse_server, 0, 0, 8192);
	    if (rc)
d279 1
a279 1
	    else
d281 2
d287 31
a317 1
    T(("_nc_mouse_init() set mousetype to %d", mousetype));
d320 2
a321 1
static bool _nc_mouse_event(SCREEN *sp GCC_UNUSED)
d329 2
a330 3
     && _nc_timed_wait(2, 0, (int *)0)
     && Gpm_GetEvent(&ev) == 1)
    {
d334 16
a349 11
	switch (ev.type & 0x0f)
	{
	case(GPM_DOWN):
	    if (ev.buttons & GPM_B_LEFT)   eventp->bstate |= BUTTON1_PRESSED;
	    if (ev.buttons & GPM_B_MIDDLE) eventp->bstate |= BUTTON2_PRESSED;
	    if (ev.buttons & GPM_B_RIGHT)  eventp->bstate |= BUTTON3_PRESSED;
	    break;
	case(GPM_UP):
	    if (ev.buttons & GPM_B_LEFT)   eventp->bstate |= BUTTON1_RELEASED;
	    if (ev.buttons & GPM_B_MIDDLE) eventp->bstate |= BUTTON2_RELEASED;
	    if (ev.buttons & GPM_B_RIGHT)  eventp->bstate |= BUTTON3_RELEASED;
d366 1
a366 1
    return(FALSE);	/* no event waiting */
d369 2
a370 1
static bool _nc_mouse_inline(SCREEN *sp)
d375 5
a379 6
    if (mousetype == M_XTERM)
    {
	unsigned char	kbuf[4];
	MEVENT	*prev;
	size_t	grabbed;
	int	res;
d411 1
a411 2
	for (grabbed = 0; grabbed < 3; grabbed += res)
	{
d413 1
a413 1
	/* For VIO mouse we add extra bit 64 to disambiguate button-up. */
d415 1
a415 1
	     res = read( M_FD(sp) >= 0 ? M_FD(sp) : sp->_ifd, &kbuf, 3);
d417 1
a417 1
	     res = read(sp->_ifd, kbuf + grabbed, 3-grabbed);
d419 2
a420 2
	     if (res == -1)
		 break;
d424 2
a425 1
	TR(TRACE_IEVENT, ("_nc_mouse_inline sees the following xterm data: '%s'", kbuf));
d431 1
a431 2
	switch (kbuf[0] & 0x3)
	{
d463 2
a464 2
		 BUTTON2_RELEASED |
		 BUTTON3_RELEASED);
d473 1
a473 1
		eventp->bstate &=~ BUTTON1_RELEASED;
d475 1
a475 1
		eventp->bstate &=~ BUTTON2_RELEASED;
d477 1
a477 1
		eventp->bstate &=~ BUTTON3_RELEASED;
d493 2
a494 1
	TR(MY_TRACE, ("_nc_mouse_inline: primitive mouse-event %s has slot %ld",
d500 2
a501 2
#if 0	/* this return would be needed for QNX's mods to lib_getch.c */
	return(TRUE);
d505 1
a505 1
    return(FALSE);
d508 2
a509 1
static void mouse_activate(bool on)
d539 1
a539 1
	SP->_mouse_event  = _nc_mouse_event;
d541 1
a541 1
	SP->_mouse_parse  = _nc_mouse_parse;
d543 1
a543 1
	SP->_mouse_wrap   = _nc_mouse_wrap;
d571 2
a572 1
static bool _nc_mouse_parse(int runcount)
d575 3
a577 3
    MEVENT	*ep, *runp, *next, *prev = PREV(eventp);
    int		n;
    bool	merge;
d602 5
a606 5
    if (runcount == 1)
    {
	TR(MY_TRACE, ("_nc_mouse_parse: returning simple mouse event %s at slot %ld",
	   _tracemouse(prev),
	   (long) (prev - events)));
d608 2
a609 2
		? ((prev->bstate & eventmask) ? TRUE : FALSE)
		: FALSE;
d619 1
a619 2
    if (_nc_tracing & TRACE_IEVENT)
    {
d623 1
a623 1
	    (long) ((eventp - events) + (EV_MAX-1)) % EV_MAX,
d631 1
a631 2
	for (ep = runp; next = NEXT(ep), next != eventp; ep = next)
	{
d633 1
a633 1
		&& (ep->bstate & (BUTTON1_PRESSED|BUTTON2_PRESSED|BUTTON3_PRESSED))
d640 1
a640 2
		)
	    {
d642 2
a643 3
			&& (ep->bstate & BUTTON1_PRESSED))
		{
		    ep->bstate &=~ BUTTON1_PRESSED;
d648 2
a649 3
			&& (ep->bstate & BUTTON2_PRESSED))
		{
		    ep->bstate &=~ BUTTON2_PRESSED;
d654 2
a655 3
			&& (ep->bstate & BUTTON3_PRESSED))
		{
		    ep->bstate &=~ BUTTON3_PRESSED;
d667 1
a667 2
    if (_nc_tracing & TRACE_IEVENT)
    {
d671 1
a671 1
	    (long) ((eventp - events) + (EV_MAX-1)) % EV_MAX,
d693 1
a693 1
	MEVENT	*follower;
d697 1
a697 2
	    if (ep->id != INVALID_EVENT)
	    {
d708 1
a708 2
			(BUTTON1_CLICKED | BUTTON2_CLICKED | BUTTON3_CLICKED)))
		{
d710 2
a711 3
			&& (follower->bstate & BUTTON1_CLICKED))
		    {
			follower->bstate &=~ BUTTON1_CLICKED;
d716 2
a717 3
			&& (follower->bstate & BUTTON2_CLICKED))
		    {
			follower->bstate &=~ BUTTON2_CLICKED;
d722 2
a723 3
			&& (follower->bstate & BUTTON3_CLICKED))
		    {
			follower->bstate &=~ BUTTON3_CLICKED;
d734 2
a735 2
			 | BUTTON2_DOUBLE_CLICKED
			 | BUTTON3_DOUBLE_CLICKED))
d737 1
a737 2
			(BUTTON1_CLICKED | BUTTON2_CLICKED | BUTTON3_CLICKED)))
		{
d739 2
a740 3
			&& (follower->bstate & BUTTON1_CLICKED))
		    {
			follower->bstate &=~ BUTTON1_CLICKED;
d745 2
a746 3
			&& (follower->bstate & BUTTON2_CLICKED))
		    {
			follower->bstate &=~ BUTTON2_CLICKED;
d751 2
a752 3
			&& (follower->bstate & BUTTON3_CLICKED))
		    {
			follower->bstate &=~ BUTTON3_CLICKED;
d764 1
a764 2
    if (_nc_tracing & TRACE_IEVENT)
    {
d768 1
a768 1
	    (long) ((eventp - events) + (EV_MAX-1)) % EV_MAX,
a780 1

d782 1
a782 2
    if (_nc_tracing & TRACE_IEVENT)
    {
d786 1
a786 1
	    (long) ((eventp - events) + (EV_MAX-1)) % EV_MAX,
d791 4
a794 3
	    TR(MY_TRACE, ("_nc_mouse_parse: returning composite mouse event %s at slot %ld",
		_tracemouse(ep),
		(long) (ep - events)));
d798 1
a798 1
    return(PREV(eventp)->id != INVALID_EVENT);
d801 2
a802 1
static void _nc_mouse_wrap(SCREEN *sp GCC_UNUSED)
d814 2
a815 2
	case M_GPM:
	    break;
d820 2
a821 1
static void _nc_mouse_resume(SCREEN *sp GCC_UNUSED)
d839 2
a840 1
int getmouse(MEVENT *aevent)
d845 1
a845 2
    if (aevent && (mousetype != M_NONE))
    {
d847 1
a847 1
	MEVENT	*prev = PREV(eventp);
d853 2
a854 2
	    _tracemouse(prev),
	    (long) (prev - events)));
d862 2
a863 1
int ungetmouse(MEVENT *aevent)
d876 2
a877 1
mmask_t mousemask(mmask_t newmask, mmask_t *oldmask)
d891 1
a891 2
    if ( mousetype != M_NONE )
    {
d894 6
a899 6
	     | BUTTON1_PRESSED | BUTTON1_RELEASED | BUTTON1_CLICKED
	     | BUTTON1_DOUBLE_CLICKED | BUTTON1_TRIPLE_CLICKED
	     | BUTTON2_PRESSED | BUTTON2_RELEASED | BUTTON2_CLICKED
	     | BUTTON2_DOUBLE_CLICKED | BUTTON2_TRIPLE_CLICKED
	     | BUTTON3_PRESSED | BUTTON3_RELEASED | BUTTON3_CLICKED
	     | BUTTON3_DOUBLE_CLICKED | BUTTON3_TRIPLE_CLICKED);
d909 2
a910 1
bool wenclose(const WINDOW *win, int y, int x)
d913 1
a913 2
    if (win)
    {
d916 3
a918 3
		 win->_begx <= x &&
		 (win->_begx + win->_maxx) >= x &&
		 (win->_begy + win->_maxy) >= y) ? TRUE : FALSE);
d923 2
a924 1
int mouseinterval(int maxclick)
d937 1
a937 1
    return(oldval);
d942 4
a945 2
int _nc_has_mouse(void) {
  return (mousetype==M_NONE ? 0:1);
d948 2
a949 1
bool wmouse_trafo(const WINDOW* win, int* pY, int* pX, bool to_screen)
d951 1
a951 1
  bool result = FALSE;
d953 14
a966 18
  if (win && pY && pX)
    {
      int y = *pY; int x = *pX;

      if (to_screen)
	{
	  y += win->_begy + win->_yoffset;
	  x += win->_begx;
	  if (wenclose(win,y,x))
	    result = TRUE;
	}
      else
	{
	  if (wenclose(win,y,x))
	    {
	      y -= (win->_begy + win->_yoffset);
	      x -= win->_begx;
	      result = TRUE;
d969 3
a971 4
      if (result)
	{
	  *pX = x;
	  *pY = y;
d974 1
a974 1
  return(result);
@


1.4
log
@Update to ncurses-5.0-990814
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.3 1999/05/08 20:29:00 millert Exp $	*/
d90 1
a90 1
MODULE_ID("$From: lib_mouse.c,v 1.44 1999/07/24 21:10:48 tom Exp $")
d536 1
a536 1
    (void) fflush(SP->_ofp);
@


1.3
log
@ncurses-4.2-990424
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.2 1999/01/31 20:17:09 millert Exp $	*/
d90 1
a90 1
MODULE_ID("$From: lib_mouse.c,v 1.43 1999/04/18 00:37:50 Klaus.Weide Exp $")
a225 13
/* FIXME: The list of names should be configurable */
static int is_xterm(const char *name)
{
    while (*name != 0) {
      if (!strncmp(name, "xterm", 5)
       || !strncmp(name, "rxvt",  4)
       || !strncmp(name, "kterm", 5))
	    return TRUE;
	name++;
    }
    return FALSE;
}

d245 1
a245 1
     && is_xterm(cur_term->type.term_names))
@


1.2
log
@ncurses-4.2-990130
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.1 1999/01/18 19:09:52 millert Exp $	*/
d76 1
a76 1
#  include <os2.h>			/* Need to include before the others */
d83 2
a84 2
#ifndef LINT		/* don't need this for llib-lncurses */
#undef buttons		/* term.h defines this, and gpm uses it! */
d86 1
d90 1
a90 1
MODULE_ID("$From: lib_mouse.c,v 1.42 1999/01/31 01:17:53 tom Exp $")
d266 1
a266 1
	gpm_connect.defaultMask = ~gpm_connect.eventMask;
d268 1
a268 1
	gpm_connect.maxMod = ~0;
d812 3
a814 3
        if (eventmask)
            mouse_activate(FALSE);
        break;
d968 1
a968 1
	    }	    
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mouse.c,v 1.8 1998/10/31 06:30:30 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d41 1
a41 1
 * The second (not yet implemented) will be Alessandro Rubini's GPM server.
d89 1
a89 1
MODULE_ID("$From: lib_mouse.c,v 1.41 1998/12/02 15:03:22 juergen Exp $")
d228 8
a235 4
    return (!strncmp(name, "xterm", 5)
      ||    !strncmp(name, "rxvt",  4)
      ||    !strncmp(name, "kterm", 5)
      ||    !strncmp(name, "color_xterm", 11));
@

