head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.28
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.24
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.26
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.18
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.22
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.20
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.16
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.38
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.34
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.32
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.30
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.28
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.26
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.24
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.22
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.20
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.18
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.16
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.14
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.12
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.10
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.22.18.01.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.19.03.53.44;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.10.01.35.02;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.09.55;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2004,2006 Free Software Foundation, Inc.                   *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/

/*
 * lib_pad.c
 * newpad	-- create a new pad
 * pnoutrefresh -- refresh a pad, no update
 * pechochar	-- add a char to a pad and refresh
 */

#include <curses.priv.h>

MODULE_ID("$Id: lib_pad.c,v 1.41 2006/10/14 20:47:13 tom Exp $")

NCURSES_EXPORT(WINDOW *)
newpad(int l, int c)
{
    WINDOW *win;
    NCURSES_CH_T *ptr;
    int i;

    T((T_CALLED("newpad(%d, %d)"), l, c));

    if (l <= 0 || c <= 0)
	returnWin(0);

    if ((win = _nc_makenew(l, c, 0, 0, _ISPAD)) == NULL)
	returnWin(0);

    for (i = 0; i < l; i++) {
	if_USE_SCROLL_HINTS(win->_line[i].oldindex = _NEWINDEX);
	if ((win->_line[i].text = typeCalloc(NCURSES_CH_T, ((size_t) c))) == 0) {
	    (void) _nc_freewin(win);
	    returnWin(0);
	}
	for (ptr = win->_line[i].text; ptr < win->_line[i].text + c; ptr++)
	    SetChar(*ptr, BLANK_TEXT, BLANK_ATTR);
    }

    returnWin(win);
}

NCURSES_EXPORT(WINDOW *)
subpad(WINDOW *orig, int l, int c, int begy, int begx)
{
    WINDOW *win = (WINDOW *) 0;

    T((T_CALLED("subpad(%d, %d)"), l, c));

    if (orig) {
	if (!(orig->_flags & _ISPAD)
	    || ((win = derwin(orig, l, c, begy, begx)) == NULL))
	    returnWin(0);
    }
    returnWin(win);
}

NCURSES_EXPORT(int)
prefresh(WINDOW *win,
	 int pminrow,
	 int pmincol,
	 int sminrow,
	 int smincol,
	 int smaxrow,
	 int smaxcol)
{
    T((T_CALLED("prefresh()")));
    if (pnoutrefresh(win, pminrow, pmincol, sminrow, smincol, smaxrow,
		     smaxcol) != ERR
	&& doupdate() != ERR) {
	returnCode(OK);
    }
    returnCode(ERR);
}

NCURSES_EXPORT(int)
pnoutrefresh(WINDOW *win,
	     int pminrow,
	     int pmincol,
	     int sminrow,
	     int smincol,
	     int smaxrow,
	     int smaxcol)
{
    NCURSES_SIZE_T i, j;
    NCURSES_SIZE_T m, n;
    NCURSES_SIZE_T pmaxrow;
    NCURSES_SIZE_T pmaxcol;

#if USE_SCROLL_HINTS
    const int my_len = 2;	/* parameterize the threshold for hardscroll */
    NCURSES_SIZE_T displaced;
    bool wide;
#endif

    T((T_CALLED("pnoutrefresh(%p, %d, %d, %d, %d, %d, %d)"),
       win, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol));

    if (win == 0)
	returnCode(ERR);

    if (!(win->_flags & _ISPAD))
	returnCode(ERR);

    /* negative values are interpreted as zero */
    if (pminrow < 0)
	pminrow = 0;
    if (pmincol < 0)
	pmincol = 0;
    if (sminrow < 0)
	sminrow = 0;
    if (smincol < 0)
	smincol = 0;

    pmaxrow = pminrow + smaxrow - sminrow;
    pmaxcol = pmincol + smaxcol - smincol;

    T((" pminrow + smaxrow - sminrow %ld, win->_maxy %ld",
       (long) pmaxrow, (long) win->_maxy));
    T((" pmincol + smaxcol - smincol %ld, win->_maxx %ld",
       (long) pmaxcol, (long) win->_maxx));

    /*
     * Trim the caller's screen size back to the actual limits.
     */
    if (pmaxrow > win->_maxy) {
	smaxrow -= (pmaxrow - win->_maxy);
	pmaxrow = pminrow + smaxrow - sminrow;
    }
    if (pmaxcol > win->_maxx) {
	smaxcol -= (pmaxcol - win->_maxx);
	pmaxcol = pmincol + smaxcol - smincol;
    }

    if (smaxrow >= screen_lines
	|| smaxcol >= screen_columns
	|| sminrow > smaxrow
	|| smincol > smaxcol)
	returnCode(ERR);

    T(("pad being refreshed"));

#if USE_SCROLL_HINTS
    if (win->_pad._pad_y >= 0) {
	displaced = pminrow - win->_pad._pad_y
	    - (sminrow - win->_pad._pad_top);
	T(("pad being shifted by %d line(s)", displaced));
    } else
	displaced = 0;
#endif

    /*
     * For pure efficiency, we'd want to transfer scrolling information
     * from the pad to newscr whenever the window is wide enough that
     * its update will dominate the cost of the update for the horizontal
     * band of newscr that it occupies.  Unfortunately, this threshold
     * tends to be complex to estimate, and in any case scrolling the
     * whole band and rewriting the parts outside win's image would look
     * really ugly.  So.  What we do is consider the pad "wide" if it
     * either (a) occupies the whole width of newscr, or (b) occupies
     * all but at most one column on either vertical edge of the screen
     * (this caters to fussy people who put boxes around full-screen
     * windows).  Note that changing this formula will not break any code,
     * merely change the costs of various update cases.
     */
#if USE_SCROLL_HINTS
    wide = (smincol < my_len && smaxcol > (newscr->_maxx - my_len));
#endif

    for (i = pminrow, m = sminrow + win->_yoffset;
	 i <= pmaxrow && m <= newscr->_maxy;
	 i++, m++) {
	register struct ldat *nline = &newscr->_line[m];
	register struct ldat *oline = &win->_line[i];
	for (j = pmincol, n = smincol; j <= pmaxcol; j++, n++) {
	    NCURSES_CH_T ch = oline->text[j];
#if USE_WIDEC_SUPPORT
	    /*
	     * Special case for leftmost character of the displayed area.
	     * Only half of a double-width character may be visible.
	     */
	    if (j == pmincol
		&& j > 0
		&& isWidecExt(ch)) {
		SetChar(ch, L(' '), AttrOf(oline->text[j - 1]));
	    }
#endif
	    if (!CharEq(ch, nline->text[n])) {
		nline->text[n] = ch;
		CHANGED_CELL(nline, n);
	    }
	}

#if USE_SCROLL_HINTS
	if (wide) {
	    int nind = m + displaced;
	    if (oline->oldindex < 0
		|| nind < sminrow
		|| nind > smaxrow) {
		nind = _NEWINDEX;
	    } else if (displaced) {
		register struct ldat *pline = &curscr->_line[nind];
		for (j = 0; j <= my_len; j++) {
		    int k = newscr->_maxx - j;
		    if (pline->text[j] != nline->text[j]
			|| pline->text[k] != nline->text[k]) {
			nind = _NEWINDEX;
			break;
		    }
		}
	    }

	    nline->oldindex = nind;
	}
#endif /* USE_SCROLL_HINTS */
	oline->firstchar = oline->lastchar = _NOCHANGE;
	if_USE_SCROLL_HINTS(oline->oldindex = i);
    }

    /*
     * Clean up debris from scrolling or resizing the pad, so we do not
     * accidentally pick up the index value during the next call to this
     * procedure.  The only rows that should have an index value are those
     * that are displayed during this cycle.
     */
#if USE_SCROLL_HINTS
    for (i = pminrow - 1; (i >= 0) && (win->_line[i].oldindex >= 0); i--)
	win->_line[i].oldindex = _NEWINDEX;
    for (i = pmaxrow + 1; (i <= win->_maxy)
	 && (win->_line[i].oldindex >= 0); i++)
	win->_line[i].oldindex = _NEWINDEX;
#endif

    win->_begx = smincol;
    win->_begy = sminrow;

    if (win->_clear) {
	win->_clear = FALSE;
	newscr->_clear = TRUE;
    }

    /*
     * Use the pad's current position, if it will be visible.
     * If not, don't do anything; it's not an error.
     */
    if (win->_leaveok == FALSE
	&& win->_cury >= pminrow
	&& win->_curx >= pmincol
	&& win->_cury <= pmaxrow
	&& win->_curx <= pmaxcol) {
	newscr->_cury = win->_cury - pminrow + win->_begy + win->_yoffset;
	newscr->_curx = win->_curx - pmincol + win->_begx;
    }
    newscr->_leaveok = win->_leaveok;
    win->_flags &= ~_HASMOVED;

    /*
     * Update our cache of the line-numbers that we displayed from the pad.
     * We will use this on subsequent calls to this function to derive
     * values to stuff into 'oldindex[]' -- for scrolling optimization.
     */
    win->_pad._pad_y = pminrow;
    win->_pad._pad_x = pmincol;
    win->_pad._pad_top = sminrow;
    win->_pad._pad_left = smincol;
    win->_pad._pad_bottom = smaxrow;
    win->_pad._pad_right = smaxcol;

    returnCode(OK);
}

NCURSES_EXPORT(int)
pechochar(WINDOW *pad, const chtype ch)
{
    T((T_CALLED("pechochar(%p, %s)"), pad, _tracechtype(ch)));

    if (pad == 0)
	returnCode(ERR);

    if (!(pad->_flags & _ISPAD))
	returnCode(wechochar(pad, ch));

    waddch(pad, ch);
    prefresh(pad, pad->_pad._pad_y,
	     pad->_pad._pad_x,
	     pad->_pad._pad_top,
	     pad->_pad._pad_left,
	     pad->_pad._pad_bottom,
	     pad->_pad._pad_right);

    returnCode(OK);
}
@


1.4
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_pad.c,v 1.3 2000/06/19 03:53:44 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d45 1
a45 1
MODULE_ID("$From: lib_pad.c,v 1.32 2000/12/10 02:43:27 tom Exp $")
d51 1
a51 1
    chtype *ptr;
d64 1
a64 1
	if ((win->_line[i].text = typeCalloc(chtype, ((size_t) c))) == 0) {
d68 2
a69 2
	for (ptr = win->_line[i].text; ptr < win->_line[i].text + c;)
	    *ptr++ = ' ';
d76 1
a76 2
subpad
(WINDOW *orig, int l, int c, int begy, int begx)
d91 7
a97 3
prefresh
(WINDOW *win, int pminrow, int pmincol,
 int sminrow, int smincol, int smaxrow, int smaxcol)
d109 7
a115 3
pnoutrefresh
(WINDOW *win, int pminrow, int pmincol,
 int sminrow, int smincol, int smaxrow, int smaxcol)
d150 4
a153 2
    T((" pminrow + smaxrow - sminrow %d, win->_maxy %d", pmaxrow, win->_maxy));
    T((" pmincol + smaxcol - smincol %d, win->_maxx %d", pmaxcol, win->_maxx));
d167 2
a168 2
    if (smaxrow > screen_lines
	|| smaxcol > screen_columns
a206 1

d208 14
a221 2
	    if (oline->text[j] != nline->text[n]) {
		nline->text[n] = oline->text[j];
@


1.3
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_pad.c,v 1.2 2000/03/10 01:35:02 millert Exp $	*/
d45 1
a45 1
MODULE_ID("$From: lib_pad.c,v 1.29 2000/04/29 21:19:44 tom Exp $")
d47 1
a47 1
WINDOW *
d65 1
a65 1
	    _nc_freewin(win);
d75 3
a77 2
WINDOW *
subpad(WINDOW *orig, int l, int c, int begy, int begx)
d91 4
a94 3
int
prefresh(WINDOW *win, int pminrow, int pmincol,
    int sminrow, int smincol, int smaxrow, int smaxcol)
d98 1
a98 1
	    smaxcol) != ERR
d105 4
a108 3
int
pnoutrefresh(WINDOW *win, int pminrow, int pmincol,
    int sminrow, int smincol, int smaxrow, int smaxcol)
a109 1
    const int my_len = 2;	/* parameterize the threshold for hardscroll */
d114 3
d119 1
d122 1
a122 1
	    win, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol));
d166 1
d173 1
d189 1
d191 1
d194 2
a195 2
	i <= pmaxrow && m <= newscr->_maxy;
	i++, m++) {
d242 1
a242 1
	&& (win->_line[i].oldindex >= 0); i++)
d284 1
a284 1
int
d297 5
a301 5
	pad->_pad._pad_x,
	pad->_pad._pad_top,
	pad->_pad._pad_left,
	pad->_pad._pad_bottom,
	pad->_pad._pad_right);
@


1.2
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_pad.c,v 1.1 1999/01/18 19:09:55 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 1

d45 1
a45 1
MODULE_ID("$From: lib_pad.c,v 1.28 2000/03/05 00:21:55 David.Mosberger Exp $")
d47 2
a48 1
WINDOW *newpad(int l, int c)
d50 17
a66 20
WINDOW *win;
chtype *ptr;
int i;

	T((T_CALLED("newpad(%d, %d)"), l, c));

	if (l <= 0 || c <= 0)
		returnWin(0);

	if ((win = _nc_makenew(l,c,0,0,_ISPAD)) == NULL)
		returnWin(0);

	for (i = 0; i < l; i++) {
	    if_USE_SCROLL_HINTS(win->_line[i].oldindex = _NEWINDEX);
	    if ((win->_line[i].text = typeCalloc(chtype, ((size_t)c))) == 0) {
		_nc_freewin(win);
		returnWin(0);
	    }
	    for (ptr = win->_line[i].text; ptr < win->_line[i].text + c; )
		*ptr++ = ' ';
d68 3
d72 1
a72 1
	returnWin(win);
d75 2
a76 1
WINDOW *subpad(WINDOW *orig, int l, int c, int begy, int begx)
d78 1
a78 1
WINDOW	*win = (WINDOW *)0;
d80 1
a80 1
	T((T_CALLED("subpad(%d, %d)"), l, c));
d82 3
a84 2
	if (orig) {
	  if (!(orig->_flags & _ISPAD) || ((win = derwin(orig, l, c, begy, begx)) == NULL))
d86 2
a87 2
	}
	returnWin(win);
d90 3
a92 2
int prefresh(WINDOW *win, int pminrow, int pmincol,
	int sminrow, int smincol, int smaxrow, int smaxcol)
d94 7
a100 6
	T((T_CALLED("prefresh()")));
	if (pnoutrefresh(win, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol) != ERR
	 && doupdate() != ERR) {
		returnCode(OK);
	}
	returnCode(ERR);
d103 3
a105 2
int pnoutrefresh(WINDOW *win, int pminrow, int pmincol,
	int sminrow, int smincol, int smaxrow, int smaxcol)
d107 10
a116 22
const	int my_len = 2;	/* parameterize the threshold for hardscroll */
short	i, j;
short	m, n;
short	pmaxrow;
short	pmaxcol;
short	displaced;
bool	wide;

	T((T_CALLED("pnoutrefresh(%p, %d, %d, %d, %d, %d, %d)"),
		win, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol));

	if (win == 0)
		returnCode(ERR);

	if (!(win->_flags & _ISPAD))
		returnCode(ERR);

	/* negative values are interpreted as zero */
	if (pminrow < 0) pminrow = 0;
	if (pmincol < 0) pmincol = 0;
	if (sminrow < 0) sminrow = 0;
	if (smincol < 0) smincol = 0;
d118 27
d146 3
d150 1
d152 7
a158 2
	T((" pminrow + smaxrow - sminrow %d, win->_maxy %d", pmaxrow, win->_maxy));
	T((" pmincol + smaxcol - smincol %d, win->_maxx %d", pmaxcol, win->_maxx));
d160 34
a193 10
	/*
	 * Trim the caller's screen size back to the actual limits.
	 */
	if (pmaxrow > win->_maxy) {
		smaxrow -= (pmaxrow - win->_maxy);
		pmaxrow = pminrow + smaxrow - sminrow;
	}
	if (pmaxcol > win->_maxx) {
		smaxcol -= (pmaxcol - win->_maxx);
		pmaxcol = pmincol + smaxcol - smincol;
a195 44
	if (smaxrow > screen_lines
	 || smaxcol > screen_columns
	 || sminrow > smaxrow
	 || smincol > smaxcol)
		returnCode(ERR);

	T(("pad being refreshed"));

	if (win->_pad._pad_y >= 0) {
		displaced = pminrow - win->_pad._pad_y
			  -(sminrow - win->_pad._pad_top);
		T(("pad being shifted by %d line(s)", displaced));
	} else
		displaced = 0;

	/*
	 * For pure efficiency, we'd want to transfer scrolling information
	 * from the pad to newscr whenever the window is wide enough that
	 * its update will dominate the cost of the update for the horizontal
	 * band of newscr that it occupies.  Unfortunately, this threshold
	 * tends to be complex to estimate, and in any case scrolling the
	 * whole band and rewriting the parts outside win's image would look
	 * really ugly.  So.  What we do is consider the pad "wide" if it
	 * either (a) occupies the whole width of newscr, or (b) occupies
	 * all but at most one column on either vertical edge of the screen
	 * (this caters to fussy people who put boxes around full-screen
	 * windows).  Note that changing this formula will not break any code,
	 * merely change the costs of various update cases.
	 */
	wide = (smincol < my_len && smaxcol > (newscr->_maxx - my_len));

	for (i = pminrow, m = sminrow + win->_yoffset;
		i <= pmaxrow && m <= newscr->_maxy;
			i++, m++) {
		register struct ldat	*nline = &newscr->_line[m];
		register struct ldat	*oline = &win->_line[i];

		for (j = pmincol, n = smincol; j <= pmaxcol; j++, n++) {
			if (oline->text[j] != nline->text[n]) {
				nline->text[n] = oline->text[j];
				CHANGED_CELL(nline,n);
			}
		}

d197 12
a208 5
		if (wide) {
		    int nind = m + displaced;
		    if (oline->oldindex < 0
		     || nind < sminrow
		     || nind > smaxrow) {
d210 1
a210 10
		    } else if (displaced) {
			register struct ldat *pline = &curscr->_line[nind];
			for (j = 0; j <= my_len; j++) {
			    int k = newscr->_maxx - j;
			    if (pline->text[j] != nline->text[j]
			     || pline->text[k] != nline->text[k]) {
				nind = _NEWINDEX;
				break;
			    }
			}
d212 2
d215 2
a216 2
		    nline->oldindex = nind;
		}
d218 10
a227 10
		oline->firstchar = oline->lastchar = _NOCHANGE;
		if_USE_SCROLL_HINTS(oline->oldindex = i);
	}

	/*
	 * Clean up debris from scrolling or resizing the pad, so we do not
	 * accidentally pick up the index value during the next call to this
	 * procedure.  The only rows that should have an index value are those
	 * that are displayed during this cycle.
	 */
d229 5
a233 4
	for (i = pminrow-1; (i >= 0) && (win->_line[i].oldindex >= 0); i--)
		win->_line[i].oldindex = _NEWINDEX;
	for (i = pmaxrow+1; (i <= win->_maxy) && (win->_line[i].oldindex >= 0); i++)
		win->_line[i].oldindex = _NEWINDEX;
d236 2
a237 2
	win->_begx = smincol;
	win->_begy = sminrow;
d239 31
a269 31
	if (win->_clear) {
	    win->_clear = FALSE;
	    newscr->_clear = TRUE;
	}

	/*
	 * Use the pad's current position, if it will be visible.
	 * If not, don't do anything; it's not an error.
	 */
	if (win->_leaveok == FALSE
	 && win->_cury  >= pminrow
	 && win->_curx  >= pmincol
	 && win->_cury  <= pmaxrow
	 && win->_curx  <= pmaxcol) {
		newscr->_cury = win->_cury - pminrow + win->_begy + win->_yoffset;
		newscr->_curx = win->_curx - pmincol + win->_begx;
	}
	newscr->_leaveok = win->_leaveok; 
	win->_flags &= ~_HASMOVED;

	/*
	 * Update our cache of the line-numbers that we displayed from the pad.
	 * We will use this on subsequent calls to this function to derive
	 * values to stuff into 'oldindex[]' -- for scrolling optimization.
	 */
	win->_pad._pad_y      = pminrow;
	win->_pad._pad_x      = pmincol;
	win->_pad._pad_top    = sminrow;
	win->_pad._pad_left   = smincol;
	win->_pad._pad_bottom = smaxrow;
	win->_pad._pad_right  = smaxcol;
d271 1
a271 1
	returnCode(OK);
d274 2
a275 1
int pechochar(WINDOW *pad, const chtype ch)
d277 4
a280 1
	T((T_CALLED("pechochar(%p, %s)"), pad, _tracechtype(ch)));
d282 2
a283 2
	if (pad == 0)
	  returnCode(ERR);
d285 7
a291 2
	if (!(pad->_flags & _ISPAD))
		returnCode(wechochar(pad,ch));
d293 1
a293 9
	waddch(pad, ch);
	prefresh(pad, pad->_pad._pad_y,
		      pad->_pad._pad_x,
		      pad->_pad._pad_top,
		      pad->_pad._pad_left,
		      pad->_pad._pad_bottom,
		      pad->_pad._pad_right);
	
	returnCode(OK);
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_pad.c,v 1.4 1998/07/23 21:19:11 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_pad.c,v 1.27 1998/06/28 00:10:16 tom Exp $")
d246 1
@

