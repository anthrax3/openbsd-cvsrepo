head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.30
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.28
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.24
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.26
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.18
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.38
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.34
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.32
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.30
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.28
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.26
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.24
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.22
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.20
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.18
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.16
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.14
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.12
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.15.0.10
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.8
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.6
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.15.0.4
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.16
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.22.04.16.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.22.18.02.01;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.10.15.10.32;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.08.22.47.05;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.24.04.06.11;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.10.03.06.17;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.19.03.53.55;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.26.16.45.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.10.01.35.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.06.07.10.51;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.16.01.35.18;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.11.28.17.49.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.03.02.06.23.30;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.20.17.10;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.27;	author millert;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*-----------------------------------------------------------------
 *
 *	lib_doupdate.c
 *
 * 	The routine doupdate() and its dependents.
 * 	All physical output is concentrated here (except _nc_outch()
  *	in lib_tputs.c).
 *
 *-----------------------------------------------------------------*/

#include <curses.priv.h>

#if defined __HAIKU__ && defined __BEOS__
#undef __BEOS__
#endif

#ifdef __BEOS__
#undef false
#undef true
#include <OS.h>
#endif

#if defined(TRACE) && HAVE_SYS_TIMES_H && HAVE_TIMES
#define USE_TRACE_TIMES 1
#else
#define USE_TRACE_TIMES 0
#endif

#if HAVE_SYS_TIME_H && HAVE_SYS_TIME_SELECT
#include <sys/time.h>
#endif

#if USE_TRACE_TIMES
#include <sys/times.h>
#endif

#if USE_FUNC_POLL
#elif HAVE_SELECT
#if HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
#endif

#include <ctype.h>
#include <term.h>

MODULE_ID("$Id: tty_update.c,v 1.246 2008/08/30 20:08:19 tom Exp $")

/*
 * This define controls the line-breakout optimization.  Every once in a
 * while during screen refresh, we want to check for input and abort the
 * update if there's some waiting.  CHECK_INTERVAL controls the number of
 * changed lines to be emitted between input checks.
 *
 * Note: Input-check-and-abort is no longer done if the screen is being
 * updated from scratch.  This is a feature, not a bug.
 */
#define CHECK_INTERVAL	5

#define FILL_BCE() (SP->_coloron && !SP->_default_color && !back_color_erase)

static const NCURSES_CH_T blankchar = NewChar(BLANK_TEXT);
static NCURSES_CH_T normal = NewChar(BLANK_TEXT);

/*
 * Enable checking to see if doupdate and friends are tracking the true
 * cursor position correctly.  NOTE: this is a debugging hack which will
 * work ONLY on ANSI-compatible terminals!
 */
/* #define POSITION_DEBUG */

static NCURSES_INLINE NCURSES_CH_T ClrBlank(WINDOW *win);
static int ClrBottom(int total);
static void ClearScreen(NCURSES_CH_T blank);
static void ClrUpdate(void);
static void DelChar(int count);
static void InsStr(NCURSES_CH_T * line, int count);
static void TransformLine(int const lineno);

#ifdef POSITION_DEBUG
/****************************************************************************
 *
 * Debugging code.  Only works on ANSI-standard terminals.
 *
 ****************************************************************************/

static void
position_check(int expected_y, int expected_x, char *legend)
/* check to see if the real cursor position matches the virtual */
{
    char buf[20];
    char *s;
    int y, x;

    if (!_nc_tracing || (expected_y < 0 && expected_x < 0))
	return;

    _nc_flush();
    memset(buf, '\0', sizeof(buf));
    putp("\033[6n");		/* only works on ANSI-compatibles */
    _nc_flush();
    *(s = buf) = 0;
    do {
	int ask = sizeof(buf) - 1 - (s - buf);
	int got = read(0, s, ask);
	if (got == 0)
	    break;
	s += got;
    } while (strchr(buf, 'R') == 0);
    _tracef("probe returned %s", _nc_visbuf(buf));

    /* try to interpret as a position report */
    if (sscanf(buf, "\033[%d;%dR", &y, &x) != 2) {
	_tracef("position probe failed in %s", legend);
    } else {
	if (expected_x < 0)
	    expected_x = x - 1;
	if (expected_y < 0)
	    expected_y = y - 1;
	if (y - 1 != expected_y || x - 1 != expected_x) {
	    beep();
	    tputs(tparm("\033[%d;%dH", expected_y + 1, expected_x + 1), 1, _nc_outch);
	    _tracef("position seen (%d, %d) doesn't match expected one (%d, %d) in %s",
		    y - 1, x - 1, expected_y, expected_x, legend);
	} else {
	    _tracef("position matches OK in %s", legend);
	}
    }
}
#else
#define position_check(expected_y, expected_x, legend)	/* nothing */
#endif /* POSITION_DEBUG */

/****************************************************************************
 *
 * Optimized update code
 *
 ****************************************************************************/

static NCURSES_INLINE void
GoTo(int const row, int const col)
{
    TR(TRACE_MOVE, ("GoTo(%d, %d) from (%d, %d)",
		    row, col, SP->_cursrow, SP->_curscol));

    position_check(SP->_cursrow, SP->_curscol, "GoTo");

    mvcur(SP->_cursrow, SP->_curscol, row, col);
    position_check(SP->_cursrow, SP->_curscol, "GoTo2");
}

static NCURSES_INLINE void
PutAttrChar(CARG_CH_T ch)
{
    int chlen = 1;
    NCURSES_CH_T my_ch;
    PUTC_DATA;
    NCURSES_CH_T tilde;
    NCURSES_CH_T attr = CHDEREF(ch);

    TR(TRACE_CHARPUT, ("PutAttrChar(%s) at (%d, %d)",
		       _tracech_t(ch),
		       SP->_cursrow, SP->_curscol));
#if USE_WIDEC_SUPPORT
    /*
     * If this is not a valid character, there is nothing more to do.
     */
    if (isWidecExt(CHDEREF(ch))) {
	TR(TRACE_CHARPUT, ("...skip"));
	return;
    }
    /*
     * Determine the number of character cells which the 'ch' value will use
     * on the screen.  It should be at least one.
     */
    if ((chlen = wcwidth(CharOf(CHDEREF(ch)))) <= 0) {
	static const NCURSES_CH_T blank = NewChar(BLANK_TEXT);

	/*
	 * If the character falls into any of these special cases, do
	 * not force the result to a blank:
	 *
	 * a) it is printable (this works around a bug in wcwidth()).
	 * b) use_legacy_coding() has been called to modify the treatment
	 *    of codes 128-255.
	 * c) the acs_map[] has been initialized to allow codes 0-31
	 *    to be rendered.  This supports Linux console's "PC"
	 *    characters.  Codes 128-255 are allowed though this is
	 *    not checked.
	 */
	if (is8bits(CharOf(CHDEREF(ch)))
	    && (isprint(CharOf(CHDEREF(ch)))
		|| (SP->_legacy_coding > 0 && CharOf(CHDEREF(ch)) >= 160)
		|| (SP->_legacy_coding > 1 && CharOf(CHDEREF(ch)) >= 128)
		|| (AttrOf(attr) & A_ALTCHARSET
		    && ((CharOfD(ch) < ACS_LEN
			 && SP->_acs_map != 0
			 && SP->_acs_map[CharOfD(ch)] != 0)
			|| (CharOfD(ch) >= 128))))) {
	    ;
	} else {
	    ch = CHREF(blank);
	    TR(TRACE_CHARPUT, ("forced to blank"));
	}
	chlen = 1;
    }
#endif

    if ((AttrOf(attr) & A_ALTCHARSET)
	&& SP->_acs_map != 0
	&& CharOfD(ch) < ACS_LEN) {
	my_ch = CHDEREF(ch);	/* work around const param */
#if USE_WIDEC_SUPPORT
	/*
	 * This is crude & ugly, but works most of the time.  It checks if the
	 * acs_chars string specified that we have a mapping for this
	 * character, and uses the wide-character mapping when we expect the
	 * normal one to be broken (by mis-design ;-).
	 */
	if (SP->_screen_acs_fix
	    && SP->_screen_acs_map[CharOf(my_ch)]) {
	    RemAttr(attr, A_ALTCHARSET);
	    my_ch = _nc_wacs[CharOf(my_ch)];
	}
#endif
	/*
	 * If we (still) have alternate character set, it is the normal 8bit
	 * flavor.  The _screen_acs_map[] array tells if the character was
	 * really in acs_chars, needed because of the way wide/normal line
	 * drawing flavors are integrated.
	 */
	if (AttrOf(attr) & A_ALTCHARSET) {
	    int j = CharOfD(ch);
	    chtype temp = UChar(SP->_acs_map[j]);

	    if (!(SP->_screen_acs_map[j])) {
		RemAttr(attr, A_ALTCHARSET);
		if (temp == 0)
		    temp = ' ';
	    }
	    if (temp != 0)
		SetChar(my_ch, temp, AttrOf(attr));
	}
	ch = CHREF(my_ch);
    }
    if (tilde_glitch && (CharOfD(ch) == L('~'))) {
	SetChar(tilde, L('`'), AttrOf(attr));
	ch = CHREF(tilde);
    }

    UpdateAttrs(attr);
#if !USE_WIDEC_SUPPORT
    /* FIXME - we do this special case for signal handling, should see how to
     * make it work for wide characters.
     */
    if (SP->_outch != 0) {
	SP->_outch(UChar(ch));
    } else
#endif
    {
	PUTC(CHDEREF(ch), SP->_ofp);	/* macro's fastest... */
	COUNT_OUTCHARS(1);
    }
    SP->_curscol += chlen;
    if (char_padding) {
	TPUTS_TRACE("char_padding");
	putp(char_padding);
    }
}

static bool
check_pending(void)
/* check for pending input */
{
    bool have_pending = FALSE;

    /*
     * Only carry out this check when the flag is zero, otherwise we'll
     * have the refreshing slow down drastically (or stop) if there's an
     * unread character available.
     */
    if (SP->_fifohold != 0)
	return FALSE;

    if (SP->_checkfd >= 0) {
#if USE_FUNC_POLL
	struct pollfd fds[1];
	fds[0].fd = SP->_checkfd;
	fds[0].events = POLLIN;
	if (poll(fds, 1, 0) > 0) {
	    have_pending = TRUE;
	}
#elif defined(__BEOS__)
	/*
	 * BeOS's select() is declared in socket.h, so the configure script does
	 * not see it.  That's just as well, since that function works only for
	 * sockets.  This (using snooze and ioctl) was distilled from Be's patch
	 * for ncurses which uses a separate thread to simulate select().
	 *
	 * FIXME: the return values from the ioctl aren't very clear if we get
	 * interrupted.
	 */
	int n = 0;
	int howmany = ioctl(0, 'ichr', &n);
	if (howmany >= 0 && n > 0) {
	    have_pending = TRUE;
	}
#elif HAVE_SELECT
	fd_set fdset;
	struct timeval ktimeout;

	ktimeout.tv_sec =
	    ktimeout.tv_usec = 0;

	FD_ZERO(&fdset);
	FD_SET(SP->_checkfd, &fdset);
	if (select(SP->_checkfd + 1, &fdset, NULL, NULL, &ktimeout) != 0) {
	    have_pending = TRUE;
	}
#endif
    }
    if (have_pending) {
	SP->_fifohold = 5;
	_nc_flush();
    }
    return FALSE;
}

/* put char at lower right corner */
static void
PutCharLR(const ARG_CH_T ch)
{
    if (!auto_right_margin) {
	/* we can put the char directly */
	PutAttrChar(ch);
    } else if (enter_am_mode && exit_am_mode) {
	/* we can suppress automargin */
	TPUTS_TRACE("exit_am_mode");
	putp(exit_am_mode);

	PutAttrChar(ch);
	SP->_curscol--;
	position_check(SP->_cursrow, SP->_curscol, "exit_am_mode");

	TPUTS_TRACE("enter_am_mode");
	putp(enter_am_mode);
    } else if ((enter_insert_mode && exit_insert_mode)
	       || insert_character || parm_ich) {
	GoTo(screen_lines - 1, screen_columns - 2);
	PutAttrChar(ch);
	GoTo(screen_lines - 1, screen_columns - 2);
	InsStr(newscr->_line[screen_lines - 1].text + screen_columns - 2, 1);
    }
}

/*
 * Wrap the cursor position, i.e., advance to the beginning of the next line.
 */
static void
wrap_cursor(void)
{
    if (eat_newline_glitch) {
	/*
	 * xenl can manifest two different ways.  The vt100 way is that, when
	 * you'd expect the cursor to wrap, it stays hung at the right margin
	 * (on top of the character just emitted) and doesn't wrap until the
	 * *next* graphic char is emitted.  The c100 way is to ignore LF
	 * received just after an am wrap.
	 *
	 * An aggressive way to handle this would be to emit CR/LF after the
	 * char and then assume the wrap is done, you're on the first position
	 * of the next line, and the terminal out of its weird state.  Here
	 * it's safe to just tell the code that the cursor is in hyperspace and
	 * let the next mvcur() call straighten things out.
	 */
	SP->_curscol = -1;
	SP->_cursrow = -1;
    } else if (auto_right_margin) {
	SP->_curscol = 0;
	SP->_cursrow++;
	/*
	 * We've actually moved - but may have to work around problems with
	 * video attributes not working.
	 */
	if (!move_standout_mode && AttrOf(SCREEN_ATTRS(SP))) {
	    TR(TRACE_CHARPUT, ("turning off (%#lx) %s before wrapping",
			       (unsigned long) AttrOf(SCREEN_ATTRS(SP)),
			       _traceattr(AttrOf(SCREEN_ATTRS(SP)))));
	    (void) VIDATTR(A_NORMAL, 0);
	}
    } else {
	SP->_curscol--;
    }
    position_check(SP->_cursrow, SP->_curscol, "wrap_cursor");
}

static NCURSES_INLINE void
PutChar(const ARG_CH_T ch)
/* insert character, handling automargin stuff */
{
    if (SP->_cursrow == screen_lines - 1 && SP->_curscol == screen_columns - 1)
	PutCharLR(ch);
    else
	PutAttrChar(ch);

    if (SP->_curscol >= screen_columns)
	wrap_cursor();

    position_check(SP->_cursrow, SP->_curscol, "PutChar");
}

/*
 * Check whether the given character can be output by clearing commands.  This
 * includes test for being a space and not including any 'bad' attributes, such
 * as A_REVERSE.  All attribute flags which don't affect appearance of a space
 * or can be output by clearing (A_COLOR in case of bce-terminal) are excluded.
 */
static NCURSES_INLINE bool
can_clear_with(ARG_CH_T ch)
{
    if (!back_color_erase && SP->_coloron) {
#if NCURSES_EXT_FUNCS
	int pair;

	if (!SP->_default_color)
	    return FALSE;
	if (SP->_default_fg != C_MASK || SP->_default_bg != C_MASK)
	    return FALSE;
	if ((pair = GetPair(CHDEREF(ch))) != 0) {
	    short fg, bg;
	    pair_content(pair, &fg, &bg);
	    if (fg != C_MASK || bg != C_MASK)
		return FALSE;
	}
#else
	if (AttrOfD(ch) & A_COLOR)
	    return FALSE;
#endif
    }
    return (ISBLANK(CHDEREF(ch)) &&
	    (AttrOfD(ch) & ~(NONBLANK_ATTR | A_COLOR)) == BLANK_ATTR);
}

/*
 * Issue a given span of characters from an array.
 * Must be functionally equivalent to:
 *	for (i = 0; i < num; i++)
 *	    PutChar(ntext[i]);
 * but can leave the cursor positioned at the middle of the interval.
 *
 * Returns: 0 - cursor is at the end of interval
 *	    1 - cursor is somewhere in the middle
 *
 * This code is optimized using ech and rep.
 */
static int
EmitRange(const NCURSES_CH_T * ntext, int num)
{
    int i;

    TR(TRACE_CHARPUT, ("EmitRange %d:%s", num, _nc_viscbuf(ntext, num)));

    if (erase_chars || repeat_char) {
	while (num > 0) {
	    int runcount;
	    NCURSES_CH_T ntext0;

	    while (num > 1 && !CharEq(ntext[0], ntext[1])) {
		PutChar(CHREF(ntext[0]));
		ntext++;
		num--;
	    }
	    ntext0 = ntext[0];
	    if (num == 1) {
		PutChar(CHREF(ntext0));
		return 0;
	    }
	    runcount = 2;

	    while (runcount < num && CharEq(ntext[runcount], ntext0))
		runcount++;

	    /*
	     * The cost expression in the middle isn't exactly right.
	     * _cup_ch_cost is an upper bound on the cost for moving to the
	     * end of the erased area, but not the cost itself (which we
	     * can't compute without emitting the move).  This may result
	     * in erase_chars not getting used in some situations for
	     * which it would be marginally advantageous.
	     */
	    if (erase_chars
		&& runcount > SP->_ech_cost + SP->_cup_ch_cost
		&& can_clear_with(CHREF(ntext0))) {
		UpdateAttrs(ntext0);
		putp(TPARM_1(erase_chars, runcount));

		/*
		 * If this is the last part of the given interval,
		 * don't bother moving cursor, since it can be the
		 * last update on the line.
		 */
		if (runcount < num) {
		    GoTo(SP->_cursrow, SP->_curscol + runcount);
		} else {
		    return 1;	/* cursor stays in the middle */
		}
	    } else if (repeat_char && runcount > SP->_rep_cost) {
		bool wrap_possible = (SP->_curscol + runcount >= screen_columns);
		int rep_count = runcount;

		if (wrap_possible)
		    rep_count--;

		UpdateAttrs(ntext0);
		tputs(TPARM_2(repeat_char, CharOf(ntext0), rep_count),
		      rep_count, _nc_outch);
		SP->_curscol += rep_count;

		if (wrap_possible)
		    PutChar(CHREF(ntext0));
	    } else {
		for (i = 0; i < runcount; i++)
		    PutChar(CHREF(ntext[i]));
	    }
	    ntext += runcount;
	    num -= runcount;
	}
	return 0;
    }

    for (i = 0; i < num; i++)
	PutChar(CHREF(ntext[i]));
    return 0;
}

/*
 * Output the line in the given range [first .. last]
 *
 * If there's a run of identical characters that's long enough to justify
 * cursor movement, use that also.
 *
 * Returns: same as EmitRange
 */
static int
PutRange(const NCURSES_CH_T * otext,
	 const NCURSES_CH_T * ntext,
	 int row,
	 int first, int last)
{
    int i, j, same;

    TR(TRACE_CHARPUT, ("PutRange(%p, %p, %d, %d, %d)",
		       otext, ntext, row, first, last));

    if (otext != ntext
	&& (last - first + 1) > SP->_inline_cost) {
	for (j = first, same = 0; j <= last; j++) {
	    if (!same && isWidecExt(otext[j]))
		continue;
	    if (CharEq(otext[j], ntext[j])) {
		same++;
	    } else {
		if (same > SP->_inline_cost) {
		    EmitRange(ntext + first, j - same - first);
		    GoTo(row, first = j);
		}
		same = 0;
	    }
	}
	i = EmitRange(ntext + first, j - same - first);
	/*
	 * Always return 1 for the next GoTo() after a PutRange() if we found
	 * identical characters at end of interval
	 */
	return (same == 0 ? i : 1);
    }
    return EmitRange(ntext + first, last - first + 1);
}

/* leave unbracketed here so 'indent' works */
#define MARK_NOCHANGE(win,row) \
		win->_line[row].firstchar = _NOCHANGE; \
		win->_line[row].lastchar = _NOCHANGE; \
		if_USE_SCROLL_HINTS(win->_line[row].oldindex = row)

NCURSES_EXPORT(int)
doupdate(void)
{
    int i;
    int nonempty;
#if USE_TRACE_TIMES
    struct tms before, after;
#endif /* USE_TRACE_TIMES */

    T((T_CALLED("doupdate()")));

    if (curscr == 0
	|| newscr == 0)
	returnCode(ERR);

#ifdef TRACE
    if (USE_TRACEF(TRACE_UPDATE)) {
	if (curscr->_clear)
	    _tracef("curscr is clear");
	else
	    _tracedump("curscr", curscr);
	_tracedump("newscr", newscr);
	_nc_unlock_global(tracef);
    }
#endif /* TRACE */

    _nc_signal_handler(FALSE);

    if (SP->_fifohold)
	SP->_fifohold--;

#if USE_SIZECHANGE
    if (SP->_endwin || _nc_handle_sigwinch(SP)) {
	/*
	 * This is a transparent extension:  XSI does not address it,
	 * and applications need not know that ncurses can do it.
	 *
	 * Check if the terminal size has changed while curses was off
	 * (this can happen in an xterm, for example), and resize the
	 * ncurses data structures accordingly.
	 */
	_nc_update_screensize(SP);
    }
#endif

    if (SP->_endwin) {

	T(("coming back from shell mode"));
	reset_prog_mode();

	_nc_mvcur_resume();
	_nc_screen_resume();
	SP->_mouse_resume(SP);

	SP->_endwin = FALSE;
    }
#if USE_TRACE_TIMES
    /* zero the metering machinery */
    RESET_OUTCHARS();
    (void) times(&before);
#endif /* USE_TRACE_TIMES */

    /*
     * This is the support for magic-cookie terminals.  The theory:  we scan
     * the virtual screen looking for attribute turnons.  Where we find one,
     * check to make sure it's realizable by seeing if the required number of
     * un-attributed blanks are present before and after the attributed range;
     * try to shift the range boundaries over blanks (not changing the screen
     * display) so this becomes true.  If it is, shift the beginning attribute
     * change appropriately (the end one, if we've gotten this far, is
     * guaranteed room for its cookie).  If not, nuke the added attributes out
     * of the span.
     */
#if USE_XMC_SUPPORT
    if (magic_cookie_glitch > 0) {
	int j, k;
	attr_t rattr = A_NORMAL;

	for (i = 0; i < screen_lines; i++) {
	    for (j = 0; j < screen_columns; j++) {
		bool failed = FALSE;
		NCURSES_CH_T *thisline = newscr->_line[i].text;
		attr_t thisattr = AttrOf(thisline[j]) & SP->_xmc_triggers;
		attr_t turnon = thisattr & ~rattr;

		/* is an attribute turned on here? */
		if (turnon == 0) {
		    rattr = thisattr;
		    continue;
		}

		TR(TRACE_ATTRS, ("At (%d, %d): from %s...", i, j, _traceattr(rattr)));
		TR(TRACE_ATTRS, ("...to %s", _traceattr(turnon)));

		/*
		 * If the attribute change location is a blank with a "safe"
		 * attribute, undo the attribute turnon.  This may ensure
		 * there's enough room to set the attribute before the first
		 * non-blank in the run.
		 */
#define SAFE(a)	(!((a) & SP->_xmc_triggers))
		if (ISBLANK(thisline[j]) && SAFE(turnon)) {
		    RemAttr(thisline[j], turnon);
		    continue;
		}

		/* check that there's enough room at start of span */
		for (k = 1; k <= magic_cookie_glitch; k++) {
		    if (j - k < 0
			|| !ISBLANK(thisline[j - k])
			|| !SAFE(AttrOf(thisline[j - k]))) {
			failed = TRUE;
			TR(TRACE_ATTRS, ("No room at start in %d,%d%s%s",
					 i, j - k,
					 (ISBLANK(thisline[j - k])
					  ? ""
					  : ":nonblank"),
					 (SAFE(AttrOf(thisline[j - k]))
					  ? ""
					  : ":unsafe")));
			break;
		    }
		}
		if (!failed) {
		    bool end_onscreen = FALSE;
		    int m, n = j;

		    /* find end of span, if it's onscreen */
		    for (m = i; m < screen_lines; m++) {
			for (; n < screen_columns; n++) {
			    attr_t testattr = AttrOf(newscr->_line[m].text[n]);
			    if ((testattr & SP->_xmc_triggers) == rattr) {
				end_onscreen = TRUE;
				TR(TRACE_ATTRS,
				   ("Range attributed with %s ends at (%d, %d)",
				    _traceattr(turnon), m, n));
				goto foundit;
			    }
			}
			n = 0;
		    }
		    TR(TRACE_ATTRS,
		       ("Range attributed with %s ends offscreen",
			_traceattr(turnon)));
		  foundit:;

		    if (end_onscreen) {
			NCURSES_CH_T *lastline = newscr->_line[m].text;

			/*
			 * If there are safely-attributed blanks at the end of
			 * the range, shorten the range.  This will help ensure
			 * that there is enough room at end of span.
			 */
			while (n >= 0
			       && ISBLANK(lastline[n])
			       && SAFE(AttrOf(lastline[n]))) {
			    RemAttr(lastline[n--], turnon);
			}

			/* check that there's enough room at end of span */
			for (k = 1; k <= magic_cookie_glitch; k++) {
			    if (n + k >= screen_columns
				|| !ISBLANK(lastline[n + k])
				|| !SAFE(AttrOf(lastline[n + k]))) {
				failed = TRUE;
				TR(TRACE_ATTRS,
				   ("No room at end in %d,%d%s%s",
				    i, j - k,
				    (ISBLANK(lastline[n + k])
				     ? ""
				     : ":nonblank"),
				    (SAFE(AttrOf(lastline[n + k]))
				     ? ""
				     : ":unsafe")));
				break;
			    }
			}
		    }
		}

		if (failed) {
		    int p, q = j;

		    TR(TRACE_ATTRS,
		       ("Clearing %s beginning at (%d, %d)",
			_traceattr(turnon), i, j));

		    /* turn off new attributes over span */
		    for (p = i; p < screen_lines; p++) {
			for (; q < screen_columns; q++) {
			    attr_t testattr = AttrOf(newscr->_line[p].text[q]);
			    if ((testattr & SP->_xmc_triggers) == rattr)
				goto foundend;
			    RemAttr(newscr->_line[p].text[q], turnon);
			}
			q = 0;
		    }
		  foundend:;
		} else {
		    TR(TRACE_ATTRS,
		       ("Cookie space for %s found before (%d, %d)",
			_traceattr(turnon), i, j));

		    /*
		     * Back up the start of range so there's room for cookies
		     * before the first nonblank character.
		     */
		    for (k = 1; k <= magic_cookie_glitch; k++)
			AddAttr(thisline[j - k], turnon);
		}

		rattr = thisattr;
	    }
	}

#ifdef TRACE
	/* show altered highlights after magic-cookie check */
	if (USE_TRACEF(TRACE_UPDATE)) {
	    _tracef("After magic-cookie check...");
	    _tracedump("newscr", newscr);
	    _nc_unlock_global(tracef);
	}
#endif /* TRACE */
    }
#endif /* USE_XMC_SUPPORT */

    nonempty = 0;
    if (curscr->_clear || newscr->_clear) {	/* force refresh ? */
	ClrUpdate();
	curscr->_clear = FALSE;	/* reset flag */
	newscr->_clear = FALSE;	/* reset flag */
    } else {
	int changedlines = CHECK_INTERVAL;

	if (check_pending())
	    goto cleanup;

	nonempty = min(screen_lines, newscr->_maxy + 1);

	if (SP->_scrolling) {
	    _nc_scroll_optimize();
	}

	nonempty = ClrBottom(nonempty);

	TR(TRACE_UPDATE, ("Transforming lines, nonempty %d", nonempty));
	for (i = 0; i < nonempty; i++) {
	    /*
	     * Here is our line-breakout optimization.
	     */
	    if (changedlines == CHECK_INTERVAL) {
		if (check_pending())
		    goto cleanup;
		changedlines = 0;
	    }

	    /*
	     * newscr->line[i].firstchar is normally set
	     * by wnoutrefresh.  curscr->line[i].firstchar
	     * is normally set by _nc_scroll_window in the
	     * vertical-movement optimization code,
	     */
	    if (newscr->_line[i].firstchar != _NOCHANGE
		|| curscr->_line[i].firstchar != _NOCHANGE) {
		TransformLine(i);
		changedlines++;
	    }

	    /* mark line changed successfully */
	    if (i <= newscr->_maxy) {
		MARK_NOCHANGE(newscr, i);
	    }
	    if (i <= curscr->_maxy) {
		MARK_NOCHANGE(curscr, i);
	    }
	}
    }

    /* put everything back in sync */
    for (i = nonempty; i <= newscr->_maxy; i++) {
	MARK_NOCHANGE(newscr, i);
    }
    for (i = nonempty; i <= curscr->_maxy; i++) {
	MARK_NOCHANGE(curscr, i);
    }

    if (!newscr->_leaveok) {
	curscr->_curx = newscr->_curx;
	curscr->_cury = newscr->_cury;

	GoTo(curscr->_cury, curscr->_curx);
    }

  cleanup:
    /*
     * We would like to keep the physical screen in normal mode in case we get
     * other processes writing to the screen.  This goal cannot be met for
     * magic cookies since it interferes with attributes that may propagate
     * past the current position.
     */
#if USE_XMC_SUPPORT
    if (magic_cookie_glitch != 0)
#endif
	UpdateAttrs(normal);

    _nc_flush();
    WINDOW_ATTRS(curscr) = WINDOW_ATTRS(newscr);

#if USE_TRACE_TIMES
    (void) times(&after);
    TR(TRACE_TIMES,
       ("Update cost: %ld chars, %ld clocks system time, %ld clocks user time",
	_nc_outchars,
	(long) (after.tms_stime - before.tms_stime),
	(long) (after.tms_utime - before.tms_utime)));
#endif /* USE_TRACE_TIMES */

    _nc_signal_handler(TRUE);

    returnCode(OK);
}

/*
 *	ClrBlank(win)
 *
 *	Returns the attributed character that corresponds to the "cleared"
 *	screen.  If the terminal has the back-color-erase feature, this will be
 *	colored according to the wbkgd() call.
 *
 *	We treat 'curscr' specially because it isn't supposed to be set directly
 *	in the wbkgd() call.  Assume 'stdscr' for this case.
 */
#define BCE_ATTRS (A_NORMAL|A_COLOR)
#define BCE_BKGD(win) (((win) == curscr ? stdscr : (win))->_nc_bkgd)

static NCURSES_INLINE NCURSES_CH_T
ClrBlank(WINDOW *win)
{
    NCURSES_CH_T blank = blankchar;
    if (back_color_erase)
	AddAttr(blank, (AttrOf(BCE_BKGD(win)) & BCE_ATTRS));
    return blank;
}

/*
**	ClrUpdate()
**
**	Update by clearing and redrawing the entire screen.
**
*/

static void
ClrUpdate(void)
{
    int i;
    NCURSES_CH_T blank = ClrBlank(stdscr);
    int nonempty = min(screen_lines, newscr->_maxy + 1);

    TR(TRACE_UPDATE, (T_CALLED("ClrUpdate")));

    ClearScreen(blank);

    TR(TRACE_UPDATE, ("updating screen from scratch"));

    nonempty = ClrBottom(nonempty);

    for (i = 0; i < nonempty; i++)
	TransformLine(i);

    TR(TRACE_UPDATE, (T_RETURN("")));
}

/*
**	ClrToEOL(blank)
**
**	Clear to end of current line, starting at the cursor position
*/

static void
ClrToEOL(NCURSES_CH_T blank, bool needclear)
{
    int j;

    if (curscr != 0
	&& SP->_cursrow >= 0) {
	for (j = SP->_curscol; j < screen_columns; j++) {
	    if (j >= 0) {
		NCURSES_CH_T *cp = &(curscr->_line[SP->_cursrow].text[j]);

		if (!CharEq(*cp, blank)) {
		    *cp = blank;
		    needclear = TRUE;
		}
	    }
	}
    } else {
	needclear = TRUE;
    }

    if (needclear) {
	UpdateAttrs(blank);
	TPUTS_TRACE("clr_eol");
	if (clr_eol && SP->_el_cost <= (screen_columns - SP->_curscol)) {
	    putp(clr_eol);
	} else {
	    int count = (screen_columns - SP->_curscol);
	    while (count-- > 0)
		PutChar(CHREF(blank));
	}
    }
}

/*
**	ClrToEOS(blank)
**
**	Clear to end of screen, starting at the cursor position
*/

static void
ClrToEOS(NCURSES_CH_T blank)
{
    int row, col;

    row = SP->_cursrow;
    col = SP->_curscol;

    UpdateAttrs(blank);
    TPUTS_TRACE("clr_eos");
    tputs(clr_eos, screen_lines - row, _nc_outch);

    while (col < screen_columns)
	curscr->_line[row].text[col++] = blank;

    for (row++; row < screen_lines; row++) {
	for (col = 0; col < screen_columns; col++)
	    curscr->_line[row].text[col] = blank;
    }
}

/*
 *	ClrBottom(total)
 *
 *	Test if clearing the end of the screen would satisfy part of the
 *	screen-update.  Do this by scanning backwards through the lines in the
 *	screen, checking if each is blank, and one or more are changed.
 */
static int
ClrBottom(int total)
{
    int row;
    int col;
    int top = total;
    int last = min(screen_columns, newscr->_maxx + 1);
    NCURSES_CH_T blank = newscr->_line[total - 1].text[last - 1];
    bool ok;

    if (clr_eos && can_clear_with(CHREF(blank))) {

	for (row = total - 1; row >= 0; row--) {
	    for (col = 0, ok = TRUE; ok && col < last; col++) {
		ok = (CharEq(newscr->_line[row].text[col], blank));
	    }
	    if (!ok)
		break;

	    for (col = 0; ok && col < last; col++) {
		ok = (CharEq(curscr->_line[row].text[col], blank));
	    }
	    if (!ok)
		top = row;
	}

	/* don't use clr_eos for just one line if clr_eol available */
	if (top < total) {
	    GoTo(top, 0);
	    ClrToEOS(blank);
	    if (SP->oldhash && SP->newhash) {
		for (row = top; row < screen_lines; row++)
		    SP->oldhash[row] = SP->newhash[row];
	    }
	}
    }
    return top;
}

#if USE_XMC_SUPPORT
#if USE_WIDEC_SUPPORT
#define check_xmc_transition(a, b) \
    ((((a)->attr ^ (b)->attr) & ~((a)->attr) & SP->_xmc_triggers) != 0)
#define xmc_turn_on(a,b) check_xmc_transition(&(a), &(b))
#else
#define xmc_turn_on(a,b) ((((a)^(b)) & ~(a) & SP->_xmc_triggers) != 0)
#endif

#define xmc_new(r,c) newscr->_line[r].text[c]
#define xmc_turn_off(a,b) xmc_turn_on(b,a)
#endif /* USE_XMC_SUPPORT */

/*
**	TransformLine(lineno)
**
**	Transform the given line in curscr to the one in newscr, using
**	Insert/Delete Character if _nc_idcok && has_ic().
**
**		firstChar = position of first different character in line
**		oLastChar = position of last different character in old line
**		nLastChar = position of last different character in new line
**
**		move to firstChar
**		overwrite chars up to min(oLastChar, nLastChar)
**		if oLastChar < nLastChar
**			insert newLine[oLastChar+1..nLastChar]
**		else
**			delete oLastChar - nLastChar spaces
*/

static void
TransformLine(int const lineno)
{
    int firstChar, oLastChar, nLastChar;
    NCURSES_CH_T *newLine = newscr->_line[lineno].text;
    NCURSES_CH_T *oldLine = curscr->_line[lineno].text;
    int n;
    bool attrchanged = FALSE;

    TR(TRACE_UPDATE, (T_CALLED("TransformLine(%d)"), lineno));

    /* copy new hash value to old one */
    if (SP->oldhash && SP->newhash)
	SP->oldhash[lineno] = SP->newhash[lineno];

    /*
     * If we have colors, there is the possibility of having two color pairs
     * that display as the same colors.  For instance, Lynx does this.  Check
     * for this case, and update the old line with the new line's colors when
     * they are equivalent.
     */
    if (SP->_coloron) {
	int oldPair;
	int newPair;

	for (n = 0; n < screen_columns; n++) {
	    if (!CharEq(newLine[n], oldLine[n])) {
		oldPair = GetPair(oldLine[n]);
		newPair = GetPair(newLine[n]);
		if (oldPair != newPair
		    && unColor(oldLine[n]) == unColor(newLine[n])) {
		    if (oldPair < COLOR_PAIRS
			&& newPair < COLOR_PAIRS
			&& SP->_color_pairs[oldPair] == SP->_color_pairs[newPair]) {
			SetPair(oldLine[n], GetPair(newLine[n]));
		    }
		}
	    }
	}
    }

    if (ceol_standout_glitch && clr_eol) {
	firstChar = 0;
	while (firstChar < screen_columns) {
	    if (!SameAttrOf(newLine[firstChar], oldLine[firstChar])) {
		attrchanged = TRUE;
		break;
	    }
	    firstChar++;
	}
    }

    firstChar = 0;

    if (attrchanged) {		/* we may have to disregard the whole line */
	GoTo(lineno, firstChar);
	ClrToEOL(ClrBlank(curscr), FALSE);
	PutRange(oldLine, newLine, lineno, 0, (screen_columns - 1));
#if USE_XMC_SUPPORT

	/*
	 * This is a very simple loop to paint characters which may have the
	 * magic cookie glitch embedded.  It doesn't know much about video
	 * attributes which are continued from one line to the next.  It
	 * assumes that we have filtered out requests for attribute changes
	 * that do not get mapped to blank positions.
	 *
	 * FIXME: we are not keeping track of where we put the cookies, so this
	 * will work properly only once, since we may overwrite a cookie in a
	 * following operation.
	 */
    } else if (magic_cookie_glitch > 0) {
	GoTo(lineno, firstChar);
	for (n = 0; n < screen_columns; n++) {
	    int m = n + magic_cookie_glitch;

	    /* check for turn-on:
	     * If we are writing an attributed blank, where the
	     * previous cell is not attributed.
	     */
	    if (ISBLANK(newLine[n])
		&& ((n > 0
		     && xmc_turn_on(newLine[n - 1], newLine[n]))
		    || (n == 0
			&& lineno > 0
			&& xmc_turn_on(xmc_new(lineno - 1, screen_columns - 1),
				       newLine[n])))) {
		n = m;
	    }

	    PutChar(CHREF(newLine[n]));

	    /* check for turn-off:
	     * If we are writing an attributed non-blank, where the
	     * next cell is blank, and not attributed.
	     */
	    if (!ISBLANK(newLine[n])
		&& ((n + 1 < screen_columns
		     && xmc_turn_off(newLine[n], newLine[n + 1]))
		    || (n + 1 >= screen_columns
			&& lineno + 1 < screen_lines
			&& xmc_turn_off(newLine[n], xmc_new(lineno + 1, 0))))) {
		n = m;
	    }

	}
#endif
    } else {
	NCURSES_CH_T blank;

	/* it may be cheap to clear leading whitespace with clr_bol */
	blank = newLine[0];
	if (clr_bol && can_clear_with(CHREF(blank))) {
	    int oFirstChar, nFirstChar;

	    for (oFirstChar = 0; oFirstChar < screen_columns; oFirstChar++)
		if (!CharEq(oldLine[oFirstChar], blank))
		    break;
	    for (nFirstChar = 0; nFirstChar < screen_columns; nFirstChar++)
		if (!CharEq(newLine[nFirstChar], blank))
		    break;

	    if (nFirstChar == oFirstChar) {
		firstChar = nFirstChar;
		/* find the first differing character */
		while (firstChar < screen_columns
		       && CharEq(newLine[firstChar], oldLine[firstChar]))
		    firstChar++;
	    } else if (oFirstChar > nFirstChar) {
		firstChar = nFirstChar;
	    } else {		/* oFirstChar < nFirstChar */
		firstChar = oFirstChar;
		if (SP->_el1_cost < nFirstChar - oFirstChar) {
		    if (nFirstChar >= screen_columns
			&& SP->_el_cost <= SP->_el1_cost) {
			GoTo(lineno, 0);
			UpdateAttrs(blank);
			TPUTS_TRACE("clr_eol");
			putp(clr_eol);
		    } else {
			GoTo(lineno, nFirstChar - 1);
			UpdateAttrs(blank);
			TPUTS_TRACE("clr_bol");
			putp(clr_bol);
		    }

		    while (firstChar < nFirstChar)
			oldLine[firstChar++] = blank;
		}
	    }
	} else {
	    /* find the first differing character */
	    while (firstChar < screen_columns
		   && CharEq(newLine[firstChar], oldLine[firstChar]))
		firstChar++;
	}
	/* if there wasn't one, we're done */
	if (firstChar >= screen_columns) {
	    TR(TRACE_UPDATE, (T_RETURN("")));
	    return;
	}

	blank = newLine[screen_columns - 1];

	if (!can_clear_with(CHREF(blank))) {
	    /* find the last differing character */
	    nLastChar = screen_columns - 1;

	    while (nLastChar > firstChar
		   && CharEq(newLine[nLastChar], oldLine[nLastChar]))
		nLastChar--;

	    if (nLastChar >= firstChar) {
		GoTo(lineno, firstChar);
		PutRange(oldLine, newLine, lineno, firstChar, nLastChar);
		memcpy(oldLine + firstChar,
		       newLine + firstChar,
		       (nLastChar - firstChar + 1) * sizeof(NCURSES_CH_T));
	    }
	    TR(TRACE_UPDATE, (T_RETURN("")));
	    return;
	}

	/* find last non-blank character on old line */
	oLastChar = screen_columns - 1;
	while (oLastChar > firstChar && CharEq(oldLine[oLastChar], blank))
	    oLastChar--;

	/* find last non-blank character on new line */
	nLastChar = screen_columns - 1;
	while (nLastChar > firstChar && CharEq(newLine[nLastChar], blank))
	    nLastChar--;

	if ((nLastChar == firstChar)
	    && (SP->_el_cost < (oLastChar - nLastChar))) {
	    GoTo(lineno, firstChar);
	    if (!CharEq(newLine[firstChar], blank))
		PutChar(CHREF(newLine[firstChar]));
	    ClrToEOL(blank, FALSE);
	} else if ((nLastChar != oLastChar)
		   && (!CharEq(newLine[nLastChar], oldLine[oLastChar])
		       || !(_nc_idcok && has_ic()))) {
	    GoTo(lineno, firstChar);
	    if ((oLastChar - nLastChar) > SP->_el_cost) {
		if (PutRange(oldLine, newLine, lineno, firstChar, nLastChar))
		    GoTo(lineno, nLastChar + 1);
		ClrToEOL(blank, FALSE);
	    } else {
		n = max(nLastChar, oLastChar);
		PutRange(oldLine, newLine, lineno, firstChar, n);
	    }
	} else {
	    int nLastNonblank = nLastChar;
	    int oLastNonblank = oLastChar;

	    /* find the last characters that really differ */
	    /* can be -1 if no characters differ */
	    while (CharEq(newLine[nLastChar], oldLine[oLastChar])) {
		/* don't split a wide char */
		if (isWidecExt(newLine[nLastChar]) &&
		    !CharEq(newLine[nLastChar - 1], oldLine[oLastChar - 1]))
		    break;
		nLastChar--;
		oLastChar--;
		if (nLastChar == -1 || oLastChar == -1)
		    break;
	    }

	    n = min(oLastChar, nLastChar);
	    if (n >= firstChar) {
		GoTo(lineno, firstChar);
		PutRange(oldLine, newLine, lineno, firstChar, n);
	    }

	    if (oLastChar < nLastChar) {
		int m = max(nLastNonblank, oLastNonblank);
#if USE_WIDEC_SUPPORT
		while (isWidecExt(newLine[n + 1]) && n) {
		    --n;
		    --oLastChar;
		}
#endif
		GoTo(lineno, n + 1);
		if ((nLastChar < nLastNonblank)
		    || InsCharCost(nLastChar - oLastChar) > (m - n)) {
		    PutRange(oldLine, newLine, lineno, n + 1, m);
		} else {
		    InsStr(&newLine[n + 1], nLastChar - oLastChar);
		}
	    } else if (oLastChar > nLastChar) {
		GoTo(lineno, n + 1);
		if (DelCharCost(oLastChar - nLastChar)
		    > SP->_el_cost + nLastNonblank - (n + 1)) {
		    if (PutRange(oldLine, newLine, lineno,
				 n + 1, nLastNonblank))
			GoTo(lineno, nLastNonblank + 1);
		    ClrToEOL(blank, FALSE);
		} else {
		    /*
		     * The delete-char sequence will
		     * effectively shift in blanks from the
		     * right margin of the screen.  Ensure
		     * that they are the right color by
		     * setting the video attributes from
		     * the last character on the row.
		     */
		    UpdateAttrs(blank);
		    DelChar(oLastChar - nLastChar);
		}
	    }
	}
    }

    /* update the code's internal representation */
    if (screen_columns > firstChar)
	memcpy(oldLine + firstChar,
	       newLine + firstChar,
	       (screen_columns - firstChar) * sizeof(NCURSES_CH_T));
    TR(TRACE_UPDATE, (T_RETURN("")));
    return;
}

/*
**	ClearScreen(blank)
**
**	Clear the physical screen and put cursor at home
**
*/

static void
ClearScreen(NCURSES_CH_T blank)
{
    int i, j;
    bool fast_clear = (clear_screen || clr_eos || clr_eol);

    TR(TRACE_UPDATE, ("ClearScreen() called"));

#if NCURSES_EXT_FUNCS
    if (SP->_coloron
	&& !SP->_default_color) {
	_nc_do_color(GET_SCREEN_PAIR(SP), 0, FALSE, _nc_outch);
	if (!back_color_erase) {
	    fast_clear = FALSE;
	}
    }
#endif

    if (fast_clear) {
	if (clear_screen) {
	    UpdateAttrs(blank);
	    TPUTS_TRACE("clear_screen");
	    putp(clear_screen);
	    SP->_cursrow = SP->_curscol = 0;
	    position_check(SP->_cursrow, SP->_curscol, "ClearScreen");
	} else if (clr_eos) {
	    SP->_cursrow = SP->_curscol = -1;
	    GoTo(0, 0);

	    UpdateAttrs(blank);
	    TPUTS_TRACE("clr_eos");
	    tputs(clr_eos, screen_lines, _nc_outch);
	} else if (clr_eol) {
	    SP->_cursrow = SP->_curscol = -1;

	    UpdateAttrs(blank);
	    for (i = 0; i < screen_lines; i++) {
		GoTo(i, 0);
		TPUTS_TRACE("clr_eol");
		putp(clr_eol);
	    }
	    GoTo(0, 0);
	}
    } else {
	UpdateAttrs(blank);
	for (i = 0; i < screen_lines; i++) {
	    GoTo(i, 0);
	    for (j = 0; j < screen_columns; j++)
		PutChar(CHREF(blank));
	}
	GoTo(0, 0);
    }

    for (i = 0; i < screen_lines; i++) {
	for (j = 0; j < screen_columns; j++)
	    curscr->_line[i].text[j] = blank;
    }

    TR(TRACE_UPDATE, ("screen cleared"));
}

/*
**	InsStr(line, count)
**
**	Insert the count characters pointed to by line.
**
*/

static void
InsStr(NCURSES_CH_T * line, int count)
{
    TR(TRACE_UPDATE, ("InsStr(%p,%d) called", line, count));

    /* Prefer parm_ich as it has the smallest cost - no need to shift
     * the whole line on each character. */
    /* The order must match that of InsCharCost. */
    if (parm_ich) {
	TPUTS_TRACE("parm_ich");
	tputs(TPARM_1(parm_ich, count), count, _nc_outch);
	while (count) {
	    PutAttrChar(CHREF(*line));
	    line++;
	    count--;
	}
    } else if (enter_insert_mode && exit_insert_mode) {
	TPUTS_TRACE("enter_insert_mode");
	putp(enter_insert_mode);
	while (count) {
	    PutAttrChar(CHREF(*line));
	    if (insert_padding) {
		TPUTS_TRACE("insert_padding");
		putp(insert_padding);
	    }
	    line++;
	    count--;
	}
	TPUTS_TRACE("exit_insert_mode");
	putp(exit_insert_mode);
    } else {
	while (count) {
	    TPUTS_TRACE("insert_character");
	    putp(insert_character);
	    PutAttrChar(CHREF(*line));
	    if (insert_padding) {
		TPUTS_TRACE("insert_padding");
		putp(insert_padding);
	    }
	    line++;
	    count--;
	}
    }
    position_check(SP->_cursrow, SP->_curscol, "InsStr");
}

/*
**	DelChar(count)
**
**	Delete count characters at current position
**
*/

static void
DelChar(int count)
{
    int n;

    TR(TRACE_UPDATE, ("DelChar(%d) called, position = (%ld,%ld)",
		      count,
		      (long) newscr->_cury,
		      (long) newscr->_curx));

    if (parm_dch) {
	TPUTS_TRACE("parm_dch");
	tputs(TPARM_1(parm_dch, count), count, _nc_outch);
    } else {
	for (n = 0; n < count; n++) {
	    TPUTS_TRACE("delete_character");
	    putp(delete_character);
	}
    }
}

/*
 * Physical-scrolling support
 *
 * This code was adapted from Keith Bostic's hardware scrolling
 * support for 4.4BSD curses.  I (esr) translated it to use terminfo
 * capabilities, narrowed the call interface slightly, and cleaned
 * up some convoluted tests.  I also added support for the memory_above
 * memory_below, and non_dest_scroll_region capabilities.
 *
 * For this code to work, we must have either
 * change_scroll_region and scroll forward/reverse commands, or
 * insert and delete line capabilities.
 * When the scrolling region has been set, the cursor has to
 * be at the last line of the region to make the scroll up
 * happen, or on the first line of region to scroll down.
 *
 * This code makes one aesthetic decision in the opposite way from
 * BSD curses.  BSD curses preferred pairs of il/dl operations
 * over scrolls, allegedly because il/dl looked faster.  We, on
 * the other hand, prefer scrolls because (a) they're just as fast
 * on many terminals and (b) using them avoids bouncing an
 * unchanged bottom section of the screen up and down, which is
 * visually nasty.
 *
 * (lav): added more cases, used dl/il when bot==maxy and in csr case.
 *
 * I used assumption that capabilities il/il1/dl/dl1 work inside
 * changed scroll region not shifting screen contents outside of it.
 * If there are any terminals behaving different way, it would be
 * necessary to add some conditions to scroll_csr_forward/backward.
 */

/* Try to scroll up assuming given csr (miny, maxy). Returns ERR on failure */
static int
scroll_csr_forward(int n, int top, int bot, int miny, int maxy, NCURSES_CH_T blank)
{
    int i;

    if (n == 1 && scroll_forward && top == miny && bot == maxy) {
	GoTo(bot, 0);
	UpdateAttrs(blank);
	TPUTS_TRACE("scroll_forward");
	putp(scroll_forward);
    } else if (n == 1 && delete_line && bot == maxy) {
	GoTo(top, 0);
	UpdateAttrs(blank);
	TPUTS_TRACE("delete_line");
	putp(delete_line);
    } else if (parm_index && top == miny && bot == maxy) {
	GoTo(bot, 0);
	UpdateAttrs(blank);
	TPUTS_TRACE("parm_index");
	tputs(TPARM_2(parm_index, n, 0), n, _nc_outch);
    } else if (parm_delete_line && bot == maxy) {
	GoTo(top, 0);
	UpdateAttrs(blank);
	TPUTS_TRACE("parm_delete_line");
	tputs(TPARM_2(parm_delete_line, n, 0), n, _nc_outch);
    } else if (scroll_forward && top == miny && bot == maxy) {
	GoTo(bot, 0);
	UpdateAttrs(blank);
	for (i = 0; i < n; i++) {
	    TPUTS_TRACE("scroll_forward");
	    putp(scroll_forward);
	}
    } else if (delete_line && bot == maxy) {
	GoTo(top, 0);
	UpdateAttrs(blank);
	for (i = 0; i < n; i++) {
	    TPUTS_TRACE("delete_line");
	    putp(delete_line);
	}
    } else
	return ERR;

#if NCURSES_EXT_FUNCS
    if (FILL_BCE()) {
	int j;
	for (i = 0; i < n; i++) {
	    GoTo(bot - i, 0);
	    for (j = 0; j < screen_columns; j++)
		PutChar(CHREF(blank));
	}
    }
#endif
    return OK;
}

/* Try to scroll down assuming given csr (miny, maxy). Returns ERR on failure */
/* n > 0 */
static int
scroll_csr_backward(int n, int top, int bot, int miny, int maxy,
		    NCURSES_CH_T blank)
{
    int i;

    if (n == 1 && scroll_reverse && top == miny && bot == maxy) {
	GoTo(top, 0);
	UpdateAttrs(blank);
	TPUTS_TRACE("scroll_reverse");
	putp(scroll_reverse);
    } else if (n == 1 && insert_line && bot == maxy) {
	GoTo(top, 0);
	UpdateAttrs(blank);
	TPUTS_TRACE("insert_line");
	putp(insert_line);
    } else if (parm_rindex && top == miny && bot == maxy) {
	GoTo(top, 0);
	UpdateAttrs(blank);
	TPUTS_TRACE("parm_rindex");
	tputs(TPARM_2(parm_rindex, n, 0), n, _nc_outch);
    } else if (parm_insert_line && bot == maxy) {
	GoTo(top, 0);
	UpdateAttrs(blank);
	TPUTS_TRACE("parm_insert_line");
	tputs(TPARM_2(parm_insert_line, n, 0), n, _nc_outch);
    } else if (scroll_reverse && top == miny && bot == maxy) {
	GoTo(top, 0);
	UpdateAttrs(blank);
	for (i = 0; i < n; i++) {
	    TPUTS_TRACE("scroll_reverse");
	    putp(scroll_reverse);
	}
    } else if (insert_line && bot == maxy) {
	GoTo(top, 0);
	UpdateAttrs(blank);
	for (i = 0; i < n; i++) {
	    TPUTS_TRACE("insert_line");
	    putp(insert_line);
	}
    } else
	return ERR;

#if NCURSES_EXT_FUNCS
    if (FILL_BCE()) {
	int j;
	for (i = 0; i < n; i++) {
	    GoTo(top + i, 0);
	    for (j = 0; j < screen_columns; j++)
		PutChar(CHREF(blank));
	}
    }
#endif
    return OK;
}

/* scroll by using delete_line at del and insert_line at ins */
/* n > 0 */
static int
scroll_idl(int n, int del, int ins, NCURSES_CH_T blank)
{
    int i;

    if (!((parm_delete_line || delete_line) && (parm_insert_line || insert_line)))
	return ERR;

    GoTo(del, 0);
    UpdateAttrs(blank);
    if (n == 1 && delete_line) {
	TPUTS_TRACE("delete_line");
	putp(delete_line);
    } else if (parm_delete_line) {
	TPUTS_TRACE("parm_delete_line");
	tputs(TPARM_2(parm_delete_line, n, 0), n, _nc_outch);
    } else {			/* if (delete_line) */
	for (i = 0; i < n; i++) {
	    TPUTS_TRACE("delete_line");
	    putp(delete_line);
	}
    }

    GoTo(ins, 0);
    UpdateAttrs(blank);
    if (n == 1 && insert_line) {
	TPUTS_TRACE("insert_line");
	putp(insert_line);
    } else if (parm_insert_line) {
	TPUTS_TRACE("parm_insert_line");
	tputs(TPARM_2(parm_insert_line, n, 0), n, _nc_outch);
    } else {			/* if (insert_line) */
	for (i = 0; i < n; i++) {
	    TPUTS_TRACE("insert_line");
	    putp(insert_line);
	}
    }

    return OK;
}

/*
 * Note:  some terminals require the cursor to be within the scrolling margins
 * before setting them.  Generally, the cursor must be at the appropriate end
 * of the scrolling margins when issuing an indexing operation (it is not
 * apparent whether it must also be at the left margin; we do this just to be
 * safe).  To make the related cursor movement a little faster, we use the
 * save/restore cursor capabilities if the terminal has them.
 */
NCURSES_EXPORT(int)
_nc_scrolln(int n, int top, int bot, int maxy)
/* scroll region from top to bot by n lines */
{
    NCURSES_CH_T blank = ClrBlank(stdscr);
    int i;
    bool cursor_saved = FALSE;
    int res;

    TR(TRACE_MOVE, ("mvcur_scrolln(%d, %d, %d, %d)", n, top, bot, maxy));

#if USE_XMC_SUPPORT
    /*
     * If we scroll, we might remove a cookie.
     */
    if (magic_cookie_glitch > 0) {
	return (ERR);
    }
#endif

    if (n > 0) {		/* scroll up (forward) */
	/*
	 * Explicitly clear if stuff pushed off top of region might
	 * be saved by the terminal.
	 */
	res = scroll_csr_forward(n, top, bot, 0, maxy, blank);

	if (res == ERR && change_scroll_region) {
	    if ((((n == 1 && scroll_forward) || parm_index)
		 && (SP->_cursrow == bot || SP->_cursrow == bot - 1))
		&& save_cursor && restore_cursor) {
		cursor_saved = TRUE;
		TPUTS_TRACE("save_cursor");
		putp(save_cursor);
	    }
	    TPUTS_TRACE("change_scroll_region");
	    putp(TPARM_2(change_scroll_region, top, bot));
	    if (cursor_saved) {
		TPUTS_TRACE("restore_cursor");
		putp(restore_cursor);
	    } else {
		SP->_cursrow = SP->_curscol = -1;
	    }

	    res = scroll_csr_forward(n, top, bot, top, bot, blank);

	    TPUTS_TRACE("change_scroll_region");
	    putp(TPARM_2(change_scroll_region, 0, maxy));
	    SP->_cursrow = SP->_curscol = -1;
	}

	if (res == ERR && _nc_idlok)
	    res = scroll_idl(n, top, bot - n + 1, blank);

	/*
	 * Clear the newly shifted-in text.
	 */
	if (res != ERR
	    && (non_dest_scroll_region || (memory_below && bot == maxy))) {
	    static const NCURSES_CH_T blank2 = NewChar(BLANK_TEXT);
	    if (bot == maxy && clr_eos) {
		GoTo(bot - n + 1, 0);
		ClrToEOS(blank2);
	    } else {
		for (i = 0; i < n; i++) {
		    GoTo(bot - i, 0);
		    ClrToEOL(blank2, FALSE);
		}
	    }
	}

    } else {			/* (n < 0) - scroll down (backward) */
	res = scroll_csr_backward(-n, top, bot, 0, maxy, blank);

	if (res == ERR && change_scroll_region) {
	    if (top != 0 && (SP->_cursrow == top || SP->_cursrow == top - 1)
		&& save_cursor && restore_cursor) {
		cursor_saved = TRUE;
		TPUTS_TRACE("save_cursor");
		putp(save_cursor);
	    }
	    TPUTS_TRACE("change_scroll_region");
	    putp(TPARM_2(change_scroll_region, top, bot));
	    if (cursor_saved) {
		TPUTS_TRACE("restore_cursor");
		putp(restore_cursor);
	    } else {
		SP->_cursrow = SP->_curscol = -1;
	    }

	    res = scroll_csr_backward(-n, top, bot, top, bot, blank);

	    TPUTS_TRACE("change_scroll_region");
	    putp(TPARM_2(change_scroll_region, 0, maxy));
	    SP->_cursrow = SP->_curscol = -1;
	}

	if (res == ERR && _nc_idlok)
	    res = scroll_idl(-n, bot + n + 1, top, blank);

	/*
	 * Clear the newly shifted-in text.
	 */
	if (res != ERR
	    && (non_dest_scroll_region || (memory_above && top == 0))) {
	    static const NCURSES_CH_T blank2 = NewChar(BLANK_TEXT);
	    for (i = 0; i < -n; i++) {
		GoTo(i + top, 0);
		ClrToEOL(blank2, FALSE);
	    }
	}
    }

    if (res == ERR)
	return (ERR);

    _nc_scroll_window(curscr, n, top, bot, blank);

    /* shift hash values too - they can be reused */
    _nc_scroll_oldhash(n, top, bot);

    return (OK);
}

NCURSES_EXPORT(void)
_nc_screen_resume(void)
{
    /* make sure terminal is in a sane known state */
    SetAttr(SCREEN_ATTRS(SP), A_NORMAL);
    newscr->_clear = TRUE;

    /* reset color pairs and definitions */
    if (SP->_coloron || SP->_color_defs)
	_nc_reset_colors();

    /* restore user-defined colors, if any */
    if (SP->_color_defs < 0) {
	int n;
	SP->_color_defs = -(SP->_color_defs);
	for (n = 0; n < SP->_color_defs; ++n) {
	    if (SP->_color_table[n].init) {
		init_color(n,
			   SP->_color_table[n].r,
			   SP->_color_table[n].g,
			   SP->_color_table[n].b);
	    }
	}
    }

    if (exit_attribute_mode)
	putp(exit_attribute_mode);
    else {
	/* turn off attributes */
	if (exit_alt_charset_mode)
	    putp(exit_alt_charset_mode);
	if (exit_standout_mode)
	    putp(exit_standout_mode);
	if (exit_underline_mode)
	    putp(exit_underline_mode);
    }
    if (exit_insert_mode)
	putp(exit_insert_mode);
    if (enter_am_mode && exit_am_mode)
	putp(auto_right_margin ? enter_am_mode : exit_am_mode);
}

NCURSES_EXPORT(void)
_nc_screen_init(void)
{
    _nc_screen_resume();
}

/* wrap up screen handling */
NCURSES_EXPORT(void)
_nc_screen_wrap(void)
{
    UpdateAttrs(normal);
#if NCURSES_EXT_FUNCS
    if (SP->_coloron
	&& !SP->_default_color) {
	static const NCURSES_CH_T blank = NewChar(BLANK_TEXT);
	SP->_default_color = TRUE;
	_nc_do_color(-1, 0, FALSE, _nc_outch);
	SP->_default_color = FALSE;

	mvcur(SP->_cursrow, SP->_curscol, screen_lines - 1, 0);

	ClrToEOL(blank, TRUE);
    }
#endif
    if (SP->_color_defs) {
	_nc_reset_colors();
    }
}

#if USE_XMC_SUPPORT
NCURSES_EXPORT(void)
_nc_do_xmc_glitch(attr_t previous)
{
    attr_t chg = XMC_CHANGES(previous ^ AttrOf(SCREEN_ATTRS(SP)));

    while (chg != 0) {
	if (chg & 1) {
	    SP->_curscol += magic_cookie_glitch;
	    if (SP->_curscol >= SP->_columns)
		wrap_cursor();
	    TR(TRACE_UPDATE, ("bumped to %d,%d after cookie", SP->_cursrow, SP->_curscol));
	}
	chg >>= 1;
    }
}
#endif /* USE_XMC_SUPPORT */
@


1.15
log
@Update to ncurses-5.2-20010210:
o remove macro callPutChar() from tty_update.c, since this is no longer
  needed (reported by Philippe Blain).
o add a null-pointer check in tic.c to handle the case when the input
  file is really empty.  Modify the next_char() function in comp_scan.c
  to allow arbitrarily long lines, and incidentally supply a newline to
  files that do not end in a newline.  These changes improve tic's
  recovery from attempts to read binary files, e.g., its output from
  the terminfo database (reported by Bernhard Rosenkraenzer).
o revert change to c++/demo.cc from 20001209, which changed definition
  of main() apparently to accommodate cygwin linker, but broke the demo
  program.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.14 2001/01/22 18:02:01 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000,2001 Free Software Foundation, Inc.         *
d34 1
d41 3
a43 3
 *	The routine doupdate() and its dependents.  Also _nc_outstr(),
 *	so all physical output is concentrated here (except _nc_outch()
 *	in lib_tputs.c).
d47 6
d54 2
a58 2
#include <curses.priv.h>

d80 1
d83 1
a83 1
MODULE_ID("$From: tty_update.c,v 1.151 2001/02/03 23:41:55 tom Exp $")
d98 3
d108 1
a108 1
static inline chtype ClrBlank(WINDOW *win);
d110 1
a110 1
static void ClearScreen(chtype blank);
d113 1
a113 1
static void InsStr(chtype * line, int count);
d176 1
a176 1
static inline void
a178 2
    chtype oldattr = SP->_current_attr;

a183 12
    /*
     * Force restore even if msgr is on when we're in an alternate
     * character set -- these have a strong tendency to screw up the
     * CR & LF used for local character motions!
     */
    if ((oldattr & A_ALTCHARSET)
	|| (oldattr && !move_standout_mode)) {
	TR(TRACE_CHARPUT, ("turning off (%#lx) %s before move",
			   oldattr, _traceattr(oldattr)));
	vidattr(A_NORMAL);
    }

a184 2
    SP->_cursrow = row;
    SP->_curscol = col;
d188 2
a189 2
static inline void
PutAttrChar(chtype ch)
d191 5
a195 4
    int data;

    if (tilde_glitch && (TextOf(ch) == '~'))
	ch = ('`' | AttrOf(ch));
d198 1
a198 1
		       _tracechtype(ch),
d200 92
a291 2
    UpdateAttrs(ch);
    data = TextOf(ch);
d293 6
a298 6
	SP->_outch(data);
    } else {
	putc(data, SP->_ofp);	/* macro's fastest... */
#ifdef TRACE
	_nc_outchars++;
#endif /* TRACE */
d300 1
a300 1
    SP->_curscol++;
d345 1
a345 1
	fd_set *fdset;
d351 4
a354 7
	fdset = calloc(howmany(SP->_checkfd + 1, NFDBITS), sizeof(fd_mask));
	if (fdset != NULL) {
	    FD_SET(SP->_checkfd, fdset);
	    if (select(SP->_checkfd + 1, fdset, NULL, NULL, &ktimeout) != 0) {
		have_pending = TRUE;
	    }
	    free(fdset);
d367 1
a367 1
PutCharLR(chtype const ch)
d392 3
d400 5
a404 6
	 * xenl can manifest two different ways.  The vt100
	 * way is that, when you'd expect the cursor to wrap,
	 * it stays hung at the right margin (on top of the
	 * character just emitted) and doesn't wrap until the
	 * *next* graphic char is emitted.  The c100 way is
	 * to ignore LF received just after an am wrap.
d406 5
a410 7
	 * An aggressive way to handle this would be to
	 * emit CR/LF after the char and then assume the wrap
	 * is done, you're on the first position of the next
	 * line, and the terminal out of its weird state.
	 * Here it's safe to just tell the code that the
	 * cursor is in hyperspace and let the next mvcur()
	 * call straighten things out.
d417 10
d433 2
a434 2
static inline void
PutChar(chtype const ch)
d454 2
a455 2
static inline bool
can_clear_with(chtype ch)
a457 2
	if (ch & A_COLOR)
	    return FALSE;
d459 2
d465 9
d476 2
a477 1
    return ((ch & ~(NONBLANK_ATTR | A_COLOR)) == BLANK);
d493 1
a493 1
EmitRange(const chtype * ntext, int num)
d497 2
d502 1
a502 1
	    chtype ntext0;
d504 2
a505 2
	    while (num > 1 && ntext[0] != ntext[1]) {
		PutChar(ntext[0]);
d511 1
a511 1
		PutChar(ntext0);
d516 1
a516 1
	    while (runcount < num && ntext[runcount] == ntext0)
d529 1
a529 1
		&& can_clear_with(ntext0)) {
d531 1
a531 1
		putp(tparm(erase_chars, runcount));
d551 2
a552 1
		putp(tparm(repeat_char, TextOf(ntext0), rep_count));
d556 1
a556 1
		    PutChar(ntext0);
d559 1
a559 1
		    PutChar(ntext[i]);
d568 1
a568 1
	PutChar(ntext[i]);
d581 4
a584 5
PutRange(
	    const chtype * otext,
	    const chtype * ntext,
	    int row,
	    int first, int last)
d586 1
a586 1
    int j, run;
d593 5
a597 3
	for (j = first, run = 0; j <= last; j++) {
	    if (otext[j] == ntext[j]) {
		run++;
d599 2
a600 3
		if (run > SP->_inline_cost) {
		    int before_run = (j - run);
		    EmitRange(ntext + first, before_run - first);
d603 1
a603 1
		run = 0;
d606 6
d633 4
d638 1
a638 1
    if (_nc_tracing & TRACE_UPDATE) {
d644 1
d654 1
a654 1
    if (SP->_endwin || SP->_sig_winch) {
d663 1
a663 1
	_nc_update_screensize();
d680 1
a680 1
    _nc_outchars = 0;
d685 9
a693 11
     * This is the support for magic-cookie terminals.  The
     * theory: we scan the virtual screen looking for attribute
     * turnons.  Where we find one, check to make sure it's
     * realizable by seeing if the required number of
     * un-attributed blanks are present before and after the
     * attributed range; try to shift the range boundaries over
     * blanks (not changing the screen display) so this becomes
     * true.  If it is, shift the beginning attribute change
     * appropriately (the end one, if we've gotten this far, is
     * guaranteed room for its cookie). If not, nuke the added
     * attributes out of the span.
d703 3
a705 1
		chtype turnon = AttrOf(newscr->_line[i].text[j]) & ~rattr;
d709 1
a709 1
		    rattr = AttrOf(newscr->_line[i].text[j]);
d717 4
a720 4
		 * If the attribute change location is a blank with a
		 * "safe" attribute, undo the attribute turnon.  This may
		 * ensure there's enough room to set the attribute before
		 * the first non-blank in the run.
d722 3
a724 3
#define SAFE(a)	(!((a) & (chtype)~NONBLANK_ATTR))
		if (TextOf(newscr->_line[i].text[j]) == ' ' && SAFE(turnon)) {
		    newscr->_line[i].text[j] &= ~turnon;
d731 2
a732 2
			|| TextOf(newscr->_line[i].text[j - k]) != ' '
			|| !SAFE(AttrOf(newscr->_line[i].text[j - k])))
d734 10
d752 2
a753 1
			    if (AttrOf(newscr->_line[m].text[n]) == rattr) {
d769 1
a769 1
			chtype *lastline = newscr->_line[m].text;
d772 3
a774 4
			 * If there are safely-attributed blanks at the
			 * end of the range, shorten the range.  This will
			 * help ensure that there is enough room at end
			 * of span.
d777 4
a780 3
			       && TextOf(lastline[n]) == ' '
			       && SAFE(AttrOf(lastline[n])))
			    lastline[n--] &= ~turnon;
d783 1
a783 1
			for (k = 1; k <= magic_cookie_glitch; k++)
d785 2
a786 2
				|| TextOf(lastline[n + k]) != ' '
				|| !SAFE(AttrOf(lastline[n + k])))
d788 12
d813 2
a814 1
			    if (AttrOf(newscr->_line[p].text[q]) == rattr)
d816 1
a816 1
			    newscr->_line[p].text[q] &= ~turnon;
d827 2
a828 2
		     * back up the start of range so there's room
		     * for cookies before the first nonblank character
d831 1
a831 1
			newscr->_line[i].text[j - k] |= turnon;
d834 1
a834 1
		rattr = AttrOf(newscr->_line[i].text[j]);
d840 1
a840 1
	if (_nc_tracing & TRACE_UPDATE) {
d843 1
a850 1
	TR(TRACE_UPDATE, ("clearing and updating from scratch"));
d918 4
a921 2
     * Keep the physical screen in normal mode in case we get other
     * processes writing to the screen.
d923 4
a926 1
    UpdateAttrs(A_NORMAL);
d929 1
a929 1
    curscr->_attrs = newscr->_attrs;
d936 2
a937 2
	after.tms_stime - before.tms_stime,
	after.tms_utime - before.tms_utime));
d956 1
a956 1
#define BCE_BKGD(win) (((win) == curscr ? stdscr : (win))->_bkgd)
d958 1
a958 1
static inline chtype
d961 1
a961 1
    chtype blank = BLANK;
d963 1
a963 1
	blank |= (BCE_BKGD(win) & BCE_ATTRS);
d978 1
a978 1
    chtype blank = ClrBlank(stdscr);
d981 1
a981 1
    TR(TRACE_UPDATE, ("ClrUpdate() called"));
d991 2
d1002 1
a1002 1
ClrToEOL(chtype blank, bool needclear)
d1010 1
a1010 1
		chtype *cp = &(curscr->_line[SP->_cursrow].text[j]);
d1012 1
a1012 1
		if (*cp != blank) {
d1025 3
a1027 1
	if (SP->_el_cost > (screen_columns - SP->_curscol)) {
d1030 1
a1030 3
		PutChar(blank);
	} else {
	    putp(clr_eol);
d1042 1
a1042 1
ClrToEOS(chtype blank)
d1076 1
a1076 1
    chtype blank = ClrBlank(stdscr);
d1079 1
a1079 1
    if (clr_eos && can_clear_with(blank)) {
d1083 1
a1083 1
		ok = (newscr->_line[row].text[col] == blank);
d1089 1
a1089 1
		ok = (curscr->_line[row].text[col] == blank);
d1096 1
a1096 1
	if (top < total - 1 || (top < total && !clr_eol && !clr_bol)) {
a1098 1
	    total = top;
d1105 1
a1105 1
    return total;
d1108 13
d1143 2
a1144 2
    chtype *newLine = newscr->_line[lineno].text;
    chtype *oldLine = curscr->_line[lineno].text;
d1148 1
a1148 1
    TR(TRACE_UPDATE, ("TransformLine(%d) called", lineno));
a1153 2
#define ColorOf(n) ((n) & A_COLOR)
#define unColor(n) ((n) & ALL_BUT_COLOR)
a1160 2
	chtype oldColor;
	chtype newColor;
d1165 4
a1168 4
	    if (newLine[n] != oldLine[n]) {
		oldColor = ColorOf(oldLine[n]);
		newColor = ColorOf(newLine[n]);
		if (oldColor != newColor
a1169 2
		    oldPair = PAIR_NUMBER(oldColor);
		    newPair = PAIR_NUMBER(newColor);
d1173 1
a1173 2
			oldLine[n] &= ~A_COLOR;
			oldLine[n] |= ColorOf(newLine[n]);
d1183 1
a1183 1
	    if (AttrOf(newLine[firstChar]) != AttrOf(oldLine[firstChar]))
d1185 2
a1198 4
#define NEW(r,c) newscr->_line[r].text[c]
#define xmc_turn_on(a,b) ((((a)^(b)) & ~(a) & SP->_xmc_triggers) != 0)
#define xmc_turn_off(a,b) xmc_turn_on(b,a)

d1219 1
a1219 1
	    if (TextOf(newLine[n]) == ' '
d1224 1
a1224 1
			&& xmc_turn_on(NEW(lineno - 1, screen_columns - 1),
d1229 1
a1229 1
	    PutChar(newLine[n]);
d1235 1
a1235 1
	    if (TextOf(newLine[n]) != ' '
d1240 1
a1240 1
			&& xmc_turn_off(newLine[n], NEW(lineno + 1, 0))))) {
a1244 1
#undef NEW
d1247 1
a1247 10
	chtype blank;

	/* find the first differing character */
	while (firstChar < screen_columns &&
	       newLine[firstChar] == oldLine[firstChar])
	    firstChar++;

	/* if there wasn't one, we're done */
	if (firstChar >= screen_columns)
	    return;
d1250 2
a1251 1
	if (clr_bol && can_clear_with(blank = newLine[0])) {
d1255 1
a1255 1
		if (oldLine[oFirstChar] != blank)
d1258 1
a1258 1
		if (newLine[nFirstChar] != blank)
d1261 26
a1286 11
	    if (nFirstChar > oFirstChar + SP->_el1_cost) {
		if (nFirstChar >= screen_columns && SP->_el_cost <= SP->_el1_cost) {
		    GoTo(lineno, 0);
		    UpdateAttrs(blank);
		    TPUTS_TRACE("clr_eol");
		    putp(clr_eol);
		} else {
		    GoTo(lineno, nFirstChar - 1);
		    UpdateAttrs(blank);
		    TPUTS_TRACE("clr_bol");
		    putp(clr_bol);
a1287 6

		while (firstChar < nFirstChar)
		    oldLine[firstChar++] = blank;

		if (firstChar >= screen_columns)
		    return;
d1289 10
d1303 1
a1303 1
	if (!can_clear_with(blank)) {
d1308 1
a1308 1
		   && newLine[nLastChar] == oldLine[nLastChar])
d1316 1
a1316 1
		       (nLastChar - firstChar + 1) * sizeof(chtype));
d1318 1
d1324 1
a1324 1
	while (oLastChar > firstChar && oldLine[oLastChar] == blank)
d1329 1
a1329 1
	while (nLastChar > firstChar && newLine[nLastChar] == blank)
d1335 2
a1336 2
	    if (newLine[firstChar] != blank)
		PutChar(newLine[firstChar]);
d1339 1
a1339 1
		   && (newLine[nLastChar] != oldLine[oLastChar]
d1355 9
a1363 6
	    while (newLine[nLastChar] == oldLine[oLastChar]) {
		if (nLastChar != 0
		    && oLastChar != 0) {
		    nLastChar--;
		    oLastChar--;
		} else {
a1364 1
		}
d1375 6
d1382 2
a1383 2
		if (InsCharCost(nLastChar - oLastChar)
		    > (m - n)) {
d1416 3
a1418 1
	       (screen_columns - firstChar) * sizeof(chtype));
d1429 1
a1429 1
ClearScreen(chtype blank)
d1439 1
a1439 1
	_nc_do_color((int) COLOR_PAIR(SP->_current_attr), 0, FALSE, _nc_outch);
d1459 1
a1459 1
	    putp(clr_eos);
d1476 1
a1476 1
		PutChar(blank);
d1497 1
a1497 1
InsStr(chtype * line, int count)
d1506 1
a1506 1
	tputs(tparm(parm_ich, count), count, _nc_outch);
d1508 1
a1508 1
	    PutAttrChar(*line);
d1516 1
a1516 1
	    PutAttrChar(*line);
d1530 1
a1530 1
	    PutAttrChar(*line);
d1554 4
a1557 2
    TR(TRACE_UPDATE, ("DelChar(%d) called, position = (%d,%d)", count,
		      newscr->_cury, newscr->_curx));
d1561 1
a1561 1
	tputs(tparm(parm_dch, count), count, _nc_outch);
a1570 13
**	_nc_outstr(char *str)
**
**	Emit a string without waiting for update.
*/

NCURSES_EXPORT(void)
_nc_outstr(const char *str)
{
    (void) putp(str);
    _nc_flush();
}

/*
d1604 1
a1604 1
scroll_csr_forward(int n, int top, int bot, int miny, int maxy, chtype blank)
d1606 1
a1606 1
    int i, j;
d1612 1
a1612 1
	tputs(scroll_forward, 0, _nc_outch);
d1617 1
a1617 1
	tputs(delete_line, 0, _nc_outch);
d1622 1
a1622 1
	tputs(tparm(parm_index, n, 0), n, _nc_outch);
d1627 1
a1627 1
	tputs(tparm(parm_delete_line, n, 0), n, _nc_outch);
d1633 1
a1633 1
	    tputs(scroll_forward, 0, _nc_outch);
d1640 1
a1640 1
	    tputs(delete_line, 0, _nc_outch);
d1647 1
d1651 1
a1651 1
		PutChar(blank);
d1661 2
a1662 1
scroll_csr_backward(int n, int top, int bot, int miny, int maxy, chtype blank)
d1664 1
a1664 1
    int i, j;
d1670 1
a1670 1
	tputs(scroll_reverse, 0, _nc_outch);
d1675 1
a1675 1
	tputs(insert_line, 0, _nc_outch);
d1680 1
a1680 1
	tputs(tparm(parm_rindex, n, 0), n, _nc_outch);
d1685 1
a1685 1
	tputs(tparm(parm_insert_line, n, 0), n, _nc_outch);
d1691 1
a1691 1
	    tputs(scroll_reverse, 0, _nc_outch);
d1698 1
a1698 1
	    tputs(insert_line, 0, _nc_outch);
d1705 1
d1709 1
a1709 1
		PutChar(blank);
d1719 1
a1719 1
scroll_idl(int n, int del, int ins, chtype blank)
d1730 1
a1730 1
	tputs(delete_line, 0, _nc_outch);
d1733 1
a1733 1
	tputs(tparm(parm_delete_line, n, 0), n, _nc_outch);
d1737 1
a1737 1
	    tputs(delete_line, 0, _nc_outch);
d1745 1
a1745 1
	tputs(insert_line, 0, _nc_outch);
d1748 1
a1748 1
	tputs(tparm(parm_insert_line, n, 0), n, _nc_outch);
d1752 1
a1752 1
	    tputs(insert_line, 0, _nc_outch);
d1759 8
d1768 1
a1768 2
_nc_scrolln
(int n, int top, int bot, int maxy)
d1771 1
a1771 1
    chtype blank = ClrBlank(stdscr);
d1800 1
a1800 1
		tputs(save_cursor, 0, _nc_outch);
d1803 1
a1803 1
	    tputs(tparm(change_scroll_region, top, bot), 0, _nc_outch);
d1806 1
a1806 1
		tputs(restore_cursor, 0, _nc_outch);
d1814 1
a1814 1
	    tputs(tparm(change_scroll_region, 0, maxy), 0, _nc_outch);
d1826 1
d1828 2
a1829 2
		GoTo(bot - n, 0);
		ClrToEOS(BLANK);
d1833 1
a1833 1
		    ClrToEOL(BLANK, FALSE);
d1846 1
a1846 1
		tputs(save_cursor, 0, _nc_outch);
d1849 1
a1849 1
	    tputs(tparm(change_scroll_region, top, bot), 0, _nc_outch);
d1852 1
a1852 1
		tputs(restore_cursor, 0, _nc_outch);
d1860 1
a1860 1
	    tputs(tparm(change_scroll_region, 0, maxy), 0, _nc_outch);
d1872 1
d1875 1
a1875 1
		ClrToEOL(BLANK, FALSE);
d1895 1
a1895 1
    SP->_current_attr = A_NORMAL;
d1898 18
a1915 2
    if (SP->_coloron == TRUE && orig_pair)
	putp(orig_pair);
d1943 1
a1943 1
    UpdateAttrs(A_NORMAL);
d1947 1
a1952 2
	SP->_cursrow = screen_lines - 1;
	SP->_curscol = 0;
d1954 1
a1954 1
	ClrToEOL(BLANK, TRUE);
d1957 3
d1966 1
a1966 1
    attr_t chg = XMC_CHANGES(previous ^ SP->_current_attr);
@


1.14
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.13 2000/10/10 15:10:32 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d75 1
a75 1
MODULE_ID("$From: tty_update.c,v 1.150 2001/01/14 00:16:22 tom Exp $")
a281 12
/*
 * No one supports recursive inline functions.  However, gcc is quieter if we
 * instantiate the recursive part separately.
 */
#if CC_HAS_INLINE_FUNCS
static void callPutChar(chtype const);
#else
#define callPutChar(ch) PutChar(ch)
#endif

static inline void PutChar(chtype const ch);	/* forward declaration */

d303 1
a303 1
	callPutChar(ch);
a502 8

#if CC_HAS_INLINE_FUNCS
static void
callPutChar(chtype const ch)
{
    PutChar(ch);
}
#endif
@


1.13
log
@Don't ignore $TERMCAP, $TERMINFO, $TERMINFO_DIRS, $TERMPATH, and $HOME
if root but not setugid.

Fix select usage to deal with an arbitrary number of fd's.  This code
is not compiled since we use poll(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.12 2000/10/08 22:47:05 millert Exp $	*/
d75 1
a75 1
MODULE_ID("$From: tty_update.c,v 1.146 2000/10/07 01:11:44 tom Exp $")
d530 1
a530 1
int
d772 1
a772 1
		MARK_NOCHANGE(newscr, i)
d775 1
a775 1
		MARK_NOCHANGE(curscr, i)
d782 1
a782 1
	MARK_NOCHANGE(newscr, i)
d785 1
a785 1
	MARK_NOCHANGE(curscr, i)
d1287 1
a1287 1
	_nc_do_color(COLOR_PAIR(SP->_current_attr), 0, FALSE, _nc_outch);
d1422 1
a1422 1
void
d1615 3
a1617 2
int
_nc_scrolln(int n, int top, int bot, int maxy)
d1738 1
a1738 1
void
d1764 1
a1764 1
void
d1771 1
a1771 1
void
d1792 1
a1792 1
void
@


1.12
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.11 2000/07/24 04:06:11 millert Exp $	*/
d259 1
a259 1
	fd_set fdset;
d265 7
a271 4
	FD_ZERO(&fdset);
	FD_SET(SP->_checkfd, &fdset);
	if (select(SP->_checkfd + 1, &fdset, NULL, NULL, &ktimeout) != 0) {
	    have_pending = TRUE;
@


1.11
log
@Update to ncurses-5.1-20000722
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.10 2000/07/10 03:06:17 millert Exp $	*/
d75 1
a75 1
MODULE_ID("$From: tty_update.c,v 1.142 2000/07/23 01:41:17 tom Exp $")
d117 1
d123 1
d127 8
a134 1
    (void) read(0, buf, sizeof(buf) - 1);
d147 1
d149 1
a149 1
		y - 1, x - 1, expected_y, expected_x, legend);
d171 1
a171 1
	    row, col, SP->_cursrow, SP->_curscol));
d183 1
a183 1
		oldattr, _traceattr(oldattr)));
d202 2
a203 2
	    _tracechtype(ch),
	    SP->_cursrow, SP->_curscol));
d310 1
a310 1
	|| insert_character || parm_ich) {
d376 1
a376 1
#ifdef NCURSES_EXT_FUNCS
d442 1
a442 1
		if (runcount < num)
d444 1
a444 1
		else
d446 1
d485 4
a488 4
    const chtype * otext,
    const chtype * ntext,
    int row,
    int first, int last)
d493 1
a493 1
	    otext, ntext, row, first, last));
d613 2
a614 2
		T(("At (%d, %d): from %s...", i, j, _traceattr(rattr)));
		T(("...to %s", _traceattr(turnon)));
d644 3
a646 2
				T(("Range attributed with %s ends at (%d, %d)",
					_traceattr(turnon), m, n));
d652 3
a654 2
		    T(("Range attributed with %s ends offscreen",
			    _traceattr(turnon)));
d667 2
a668 2
			    && TextOf(lastline[n]) == ' '
			    && SAFE(AttrOf(lastline[n])))
d683 3
a685 2
		    T(("Clearing %s beginning at (%d, %d)",
			    _traceattr(turnon), i, j));
d698 3
a700 2
		    T(("Cookie space for %s found before (%d, %d)",
			    _traceattr(turnon), i, j));
d726 1
a726 1
	T(("clearing and updating from scratch"));
d744 1
a744 1
	T(("Transforming lines, nonempty %d", nonempty));
d805 4
a808 4
	("Update cost: %ld chars, %ld clocks system time, %ld clocks user time",
	    _nc_outchars,
	    after.tms_stime - before.tms_stime,
	    after.tms_utime - before.tms_utime));
d852 1
a852 1
    T(("ClrUpdate() called"));
d856 1
a856 1
    T(("updating screen from scratch"));
d954 2
a955 1
	    if (!ok) break;
d960 2
a961 1
	    if (!ok) top = row;
d1005 1
a1005 1
    T(("TransformLine(%d) called", lineno));
d1087 1
a1087 1
			&& xmc_turn_on(newLine[n - 1], newLine[n]))
d1091 1
a1091 1
			    newLine[n])))) {
d1103 1
a1103 1
			&& xmc_turn_off(newLine[n], newLine[n + 1]))
d1118 1
a1118 1
	    newLine[firstChar] == oldLine[firstChar])
d1164 1
a1164 1
		&& newLine[nLastChar] == oldLine[nLastChar])
d1171 2
a1172 2
		    newLine + firstChar,
		    (nLastChar - firstChar + 1) * sizeof(chtype));
d1194 2
a1195 2
		&& (newLine[nLastChar] != oldLine[oLastChar]
		|| !(_nc_idcok && has_ic()))) {
d1240 1
a1240 1
			    n + 1, nLastNonblank))
d1262 2
a1263 2
	    newLine + firstChar,
	    (screen_columns - firstChar) * sizeof(chtype));
d1279 1
a1279 1
    T(("ClearScreen() called"));
d1281 1
a1281 1
#ifdef NCURSES_EXT_FUNCS
d1331 1
a1331 1
    T(("screen cleared"));
d1344 1
a1344 1
    T(("InsStr(%p,%d) called", line, count));
d1399 2
a1400 1
    T(("DelChar(%d) called, position = (%d,%d)", count, newscr->_cury, newscr->_curx));
d1501 1
a1501 1
#ifdef NCURSES_EXT_FUNCS
d1557 1
a1557 1
#ifdef NCURSES_EXT_FUNCS
a1636 7
	if (non_dest_scroll_region || (memory_above && top == 0)) {
	    for (i = 0; i < n; i++) {
		GoTo(i, 0);
		ClrToEOL(BLANK, FALSE);
	    }
	}

d1641 1
a1641 1
		    && (SP->_cursrow == bot || SP->_cursrow == bot - 1))
d1665 1
a1665 1
    } else {			/* (n < 0) - scroll down (backward) */
d1667 1
a1667 2
	 * Do explicit clear to end of region if it's possible that the
	 * terminal might hold on to stuff we push off the end.
d1669 2
a1670 1
	if (non_dest_scroll_region || (memory_below && bot == maxy)) {
d1672 1
a1672 1
		GoTo(maxy + n, 0);
d1674 3
a1676 3
	    } else if (clr_eol) {
		for (i = 0; i < -n; i++) {
		    GoTo(maxy + n + i, 0);
d1682 1
d1710 11
d1771 1
a1771 1
#ifdef NCURSES_EXT_FUNCS
d1798 1
a1798 1
	    T(("bumped to %d,%d after cookie", SP->_cursrow, SP->_curscol));
@


1.10
log
@ncurses 5.1
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.9 2000/06/19 03:53:55 millert Exp $	*/
d75 1
a75 1
MODULE_ID("$From: tty_update.c,v 1.141 2000/07/04 21:01:40 tom Exp $")
d861 1
a861 2
	&& SP->_cursrow >= 0
	&& SP->_curscol >= 0) {
d863 2
a864 1
	    chtype *cp = &(curscr->_line[SP->_cursrow].text[j]);
d866 4
a869 3
	    if (*cp != blank) {
		*cp = blank;
		needclear = TRUE;
d903 3
a905 5
    {
	UpdateAttrs(blank);
	TPUTS_TRACE("clr_eos");
	tputs(clr_eos, screen_lines - row, _nc_outch);
    }
@


1.9
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.8 2000/03/26 16:45:04 millert Exp $	*/
d75 1
a75 1
MODULE_ID("$From: tty_update.c,v 1.136 2000/05/20 23:28:00 tom Exp $")
d415 1
a415 1
	     * _cup_cost is an upper bound on the cost for moving to the
d422 1
a422 1
		&& runcount > SP->_ech_cost + SP->_cup_cost
a479 1
    int cost = min(SP->_cup_ch_cost, SP->_hpa_ch_cost);
d485 1
a485 1
	&& (last - first + 1) > cost) {
d490 1
a490 1
		if (run > cost) {
a926 3
    static chtype *tstLine;
    static size_t lenLine;

d928 1
a928 1
    size_t col;
d931 4
a934 2
    size_t length = sizeof(chtype) * last;
    chtype blank = newscr->_line[total - 1].text[last - 1];	/* lower right char */
d936 11
a946 2
    if (!clr_eos || !can_clear_with(blank))
	return total;
d948 10
a957 32
    if ((tstLine == 0) || (last > (int) lenLine)) {
	tstLine = typeRealloc(chtype, last, tstLine);
	if (tstLine == 0)
	    return total;
	lenLine = last;
	tstLine[0] = ~blank;	/* force the fill below */
    }
    if (tstLine[0] != blank) {
	for (col = 0; col < lenLine; col++)
	    tstLine[col] = blank;
    }

    for (row = total - 1; row >= 0; row--) {
	if (memcmp(tstLine, newscr->_line[row].text, length))
	    break;
	if (memcmp(tstLine, curscr->_line[row].text, length))
	    top = row;
    }

    /* don't use clr_eos for just one line if clr_eol available */
    if (top < total - 1 || (top < total && !clr_eol && !clr_bol)) {
	GoTo(top, 0);
	ClrToEOS(blank);
	total = top;
	if (SP->oldhash && SP->newhash) {
	    for (row = top; row < screen_lines; row++)
		SP->oldhash[row] = SP->newhash[row];
	}
    }
#if NO_LEAKS
    if (tstLine != 0) {
	FreeAndNull(tstLine);
a958 1
#endif
d995 33
d1292 1
a1294 1
		UpdateAttrs(blank);
d1301 1
a1303 1
	    UpdateAttrs(blank);
@


1.8
log
@Update to ncurses-5.0-20000325
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.7 2000/03/10 01:35:05 millert Exp $	*/
d75 1
a75 1
MODULE_ID("$From: tty_update.c,v 1.134 2000/03/26 02:17:10 tom Exp $")
d186 2
d195 3
a197 2
    if (SP->_cleanup) {
	_nc_outch((int) TextOf(ch));
d199 1
a199 1
	putc((int) TextOf(ch), SP->_ofp);	/* macro's fastest... */
d857 1
a857 1
ClrToEOL(chtype blank)
a859 1
    bool needclear = FALSE;
d861 10
a870 6
    for (j = SP->_curscol; j < screen_columns; j++) {
	chtype *cp = &(curscr->_line[SP->_cursrow].text[j]);

	if (*cp != blank) {
	    *cp = blank;
	    needclear = TRUE;
d872 2
d883 1
a883 1
	} else
d885 1
d1024 1
a1024 1
	ClrToEOL(ClrBlank(curscr));
d1159 1
a1159 1
	    ClrToEOL(blank);
d1167 1
a1167 1
		ClrToEOL(blank);
d1209 1
a1209 1
		    ClrToEOL(blank);
d1470 1
a1470 1
	    GoTo(bot-i, 0);
d1526 1
a1526 1
	    GoTo(top+i, 0);
d1606 1
a1606 1
		ClrToEOL(BLANK);
d1650 1
a1650 1
		    ClrToEOL(BLANK);
d1738 6
@


1.7
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.6 2000/02/06 07:10:51 millert Exp $	*/
d75 1
a75 1
MODULE_ID("$From: tty_update.c,v 1.131 2000/02/26 23:22:11 tom Exp $")
d363 1
d368 1
d1242 1
a1242 1
	_nc_do_color(0, FALSE, _nc_outch);
d1727 1
a1727 1
	_nc_do_color(0, FALSE, _nc_outch);
@


1.6
log
@ncurses-5.0-20000205
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.5 2000/01/16 01:35:18 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
a35 1

d75 1
a75 1
MODULE_ID("$From: tty_update.c,v 1.124 2000/02/06 01:57:25 tom Exp $")
d89 1
d97 1
a97 1
static inline chtype ClrBlank ( WINDOW *win );
d99 5
a103 5
static void ClearScreen( chtype blank );
static void ClrUpdate( void );
static void DelChar( int count );
static void InsStr( chtype *line, int count );
static void TransformLine( int const lineno );
d112 2
a113 1
static void position_check(int expected_y, int expected_x, char *legend)
d116 1
a116 1
    char  buf[20];
d123 1
a123 1
    putp("\033[6n");	/* only works on ANSI-compatibles */
d125 1
a125 1
    (void) read(0, buf, sizeof(buf)-1);
d139 1
a139 1
		    y-1, x-1, expected_y, expected_x, legend);
d146 1
a146 1
#define position_check(expected_y, expected_x, legend) /* nothing */
d155 2
a156 1
static inline void GoTo(int const row, int const col)
d158 1
a158 1
	chtype	oldattr = SP->_current_attr;
d160 2
a161 2
	TR(TRACE_MOVE, ("GoTo(%d, %d) from (%d, %d)",
			row, col, SP->_cursrow, SP->_curscol));
d163 1
a163 1
	position_check(SP->_cursrow, SP->_curscol, "GoTo");
d165 32
a196 32
	/*
	 * Force restore even if msgr is on when we're in an alternate
	 * character set -- these have a strong tendency to screw up the
	 * CR & LF used for local character motions!
	 */
	if ((oldattr & A_ALTCHARSET)
	    || (oldattr && !move_standout_mode))
	{
		TR(TRACE_CHARPUT, ("turning off (%#lx) %s before move",
		   oldattr, _traceattr(oldattr)));
		vidattr(A_NORMAL);
	}

	mvcur(SP->_cursrow, SP->_curscol, row, col);
	SP->_cursrow = row;
	SP->_curscol = col;
	position_check(SP->_cursrow, SP->_curscol, "GoTo2");
}

static inline void PutAttrChar(chtype ch)
{
	if (tilde_glitch && (TextOf(ch) == '~'))
		ch = ('`' | AttrOf(ch));

	TR(TRACE_CHARPUT, ("PutAttrChar(%s) at (%d, %d)",
			  _tracechtype(ch),
			   SP->_cursrow, SP->_curscol));
	UpdateAttrs(ch);
	if (SP->_cleanup) {
		_nc_outch((int)TextOf(ch));
	} else {
		putc((int)TextOf(ch), SP->_ofp); /* macro's fastest... */
d198 1
a198 1
		_nc_outchars++;
d200 6
a205 6
	}
	SP->_curscol++;
	if (char_padding) {
		TPUTS_TRACE("char_padding");
		putp(char_padding);
	}
d208 2
a209 1
static bool check_pending(void)
d212 1
a212 1
	bool have_pending = FALSE;
d214 7
a220 7
	/*
	 * Only carry out this check when the flag is zero, otherwise we'll
	 * have the refreshing slow down drastically (or stop) if there's an
	 * unread character available.
	 */
	if(SP->_fifohold != 0)
		return FALSE;
d222 1
a222 1
	if (SP->_checkfd >= 0) {
d224 6
a229 7
		struct pollfd fds[1];
		fds[0].fd = SP->_checkfd;
		fds[0].events = POLLIN;
		if (poll(fds, 1, 0) > 0)
		{
			have_pending = TRUE;
		}
d231 14
a244 14
		/*
		 * BeOS's select() is declared in socket.h, so the configure script does
		 * not see it.  That's just as well, since that function works only for
		 * sockets.  This (using snooze and ioctl) was distilled from Be's patch
		 * for ncurses which uses a separate thread to simulate select().
		 *
		 * FIXME: the return values from the ioctl aren't very clear if we get
		 * interrupted.
		 */
		int n = 0;
		int howmany = ioctl(0, 'ichr', &n);
		if (howmany >= 0 && n > 0) {
			have_pending = TRUE;
		}
d246 2
a247 2
		fd_set fdset;
		struct timeval ktimeout;
d249 2
a250 2
		ktimeout.tv_sec =
		ktimeout.tv_usec = 0;
d252 5
a256 6
		FD_ZERO(&fdset);
		FD_SET(SP->_checkfd, &fdset);
		if (select(SP->_checkfd+1, &fdset, NULL, NULL, &ktimeout) != 0)
		{
			have_pending = TRUE;
		}
d258 6
a263 6
	}
	if (have_pending) {
		SP->_fifohold = 5;
		_nc_flush();
	}
	return FALSE;
d279 2
a280 1
static void PutCharLR(chtype const ch)
d282 1
a282 2
    if (!auto_right_margin)
    {
d285 1
a285 3
    }
    else if (enter_am_mode && exit_am_mode)
    {
d296 3
a298 5
    }
    else if ((enter_insert_mode && exit_insert_mode)
	     || insert_character || parm_ich)
    {
	GoTo(screen_lines-1,screen_columns-2);
d300 2
a301 2
	GoTo(screen_lines-1,screen_columns-2);
	InsStr(newscr->_line[screen_lines-1].text+screen_columns-2,1);
d305 2
a306 1
static void wrap_cursor(void)
d308 1
a308 2
    if (eat_newline_glitch)
    {
d327 1
a327 3
    }
    else if (auto_right_margin)
    {
d330 1
a330 3
    }
    else
    {
d336 2
a337 1
static inline void PutChar(chtype const ch)
d340 1
a340 1
    if (SP->_cursrow == screen_lines-1 && SP->_curscol == screen_columns-1)
d352 20
d383 2
a384 1
static int EmitRange(const chtype *ntext, int num)
d386 1
a386 1
    int	i;
d388 3
a390 5
    if (erase_chars || repeat_char)
    {
	while (num > 0)
	{
	    int	runcount;
d393 1
a393 2
	    while (num>1 && ntext[0]!=ntext[1])
	    {
d399 1
a399 2
	    if (num==1)
	    {
d418 1
a418 2
		&& can_clear_with(ntext0))
	    {
d431 1
a431 3
	    }
	    else if (repeat_char && runcount > SP->_rep_cost)
	    {
d444 1
a444 3
	    }
	    else
	    {
d467 23
a489 25
static int PutRange(
	const chtype *otext,
	const chtype *ntext,
	int row,
	int first, int last)
{
	int j, run;
	int cost = min(SP->_cup_ch_cost, SP->_hpa_ch_cost);

	TR(TRACE_CHARPUT, ("PutRange(%p, %p, %d, %d, %d)",
			 otext, ntext, row, first, last));

	if (otext != ntext
	 && (last-first+1) > cost) {
		for (j = first, run = 0; j <= last; j++) {
			if (otext[j] == ntext[j]) {
				run++;
			} else {
				if (run > cost) {
					int before_run = (j - run);
					EmitRange(ntext+first, before_run-first);
					GoTo(row, first = j);
				}
				run = 0;
			}
d491 2
d494 2
a495 1
	return EmitRange(ntext + first, last-first+1);
d499 2
a500 1
static void callPutChar(chtype const ch)
d502 1
a502 1
	PutChar(ch);
d506 1
a507 1
	{ \
d510 1
a510 2
		if_USE_SCROLL_HINTS(win->_line[row].oldindex = row); \
	}
d512 2
a513 1
int doupdate(void)
d515 2
a516 2
int	i;
int	nonempty;
d518 1
a518 1
struct tms before, after;
d521 1
a521 1
	T((T_CALLED("doupdate()")));
d524 7
a530 8
	if (_nc_tracing & TRACE_UPDATE)
	{
	    if (curscr->_clear)
		_tracef("curscr is clear");
	    else
		_tracedump("curscr", curscr);
	    _tracedump("newscr", newscr);
	}
d533 1
a533 1
	_nc_signal_handler(FALSE);
d535 2
a536 2
	if (SP->_fifohold)
		SP->_fifohold--;
d539 11
a549 12
	if (SP->_endwin || SP->_sig_winch)
	{
		/*
		 * This is a transparent extension:  XSI does not address it,
		 * and applications need not know that ncurses can do it.
		 *
		 * Check if the terminal size has changed while curses was off
		 * (this can happen in an xterm, for example), and resize the
		 * ncurses data structures accordingly.
		 */
		_nc_update_screensize();
	}
d552 1
a552 1
	if (SP->_endwin) {
d554 2
a555 2
		T(("coming back from shell mode"));
		reset_prog_mode();
d557 3
a559 6
		_nc_mvcur_resume();
		_nc_screen_resume();
		SP->_mouse_resume(SP);

		SP->_endwin = FALSE;
	}
d561 2
d564 3
a566 3
	/* zero the metering machinery */
	_nc_outchars = 0;
	(void) times(&before);
d569 13
a581 13
	/*
	 * This is the support for magic-cookie terminals.  The
	 * theory: we scan the virtual screen looking for attribute
	 * turnons.  Where we find one, check to make sure it's
	 * realizable by seeing if the required number of
	 * un-attributed blanks are present before and after the
	 * attributed range; try to shift the range boundaries over
	 * blanks (not changing the screen display) so this becomes
	 * true.  If it is, shift the beginning attribute change
	 * appropriately (the end one, if we've gotten this far, is
	 * guaranteed room for its cookie). If not, nuke the added
	 * attributes out of the span.
	 */
d583 8
a590 15
	if (magic_cookie_glitch > 0) {
	    int	j, k;
	    attr_t rattr = A_NORMAL;

	    for (i = 0; i < screen_lines; i++)
		for (j = 0; j < screen_columns; j++)
		{
		    bool failed = FALSE;
		    chtype turnon = AttrOf(newscr->_line[i].text[j]) & ~rattr;

		    /* is an attribute turned on here? */
		    if (turnon == 0) {
			rattr = AttrOf(newscr->_line[i].text[j]);
			continue;
		    }
d592 5
a596 2
		    T(("At (%d, %d): from %s...", i, j, _traceattr(rattr)));
		    T(("...to %s",_traceattr(turnon)));
d598 2
a599 12
		    /*
		     * If the attribute change location is a blank with a
		     * "safe" attribute, undo the attribute turnon.  This may
		     * ensure there's enough room to set the attribute before
		     * the first non-blank in the run.
		     */
#define SAFE(a)	!((a) & (chtype)~NONBLANK_ATTR)
		    if (TextOf(newscr->_line[i].text[j])==' ' && SAFE(turnon))
		    {
			newscr->_line[i].text[j] &= ~turnon;
			continue;
		    }
d601 31
a631 23
		    /* check that there's enough room at start of span */
		    for (k = 1; k <= magic_cookie_glitch; k++)
			if (j-k < 0
				|| TextOf(newscr->_line[i].text[j-k]) != ' '
				|| !SAFE(AttrOf(newscr->_line[i].text[j-k])))
			    failed = TRUE;
		    if (!failed)
		    {
			bool	end_onscreen = FALSE;
			int	m, n = j;

			/* find end of span, if it's onscreen */
			for (m = i; m < screen_lines; m++)
			{
			    for ( ; n < screen_columns; n++)
			    {
				if (AttrOf(newscr->_line[m].text[n]) == rattr)
				{
				    end_onscreen = TRUE;
				    T(("Range attributed with %s ends at (%d, %d)",
				       _traceattr(turnon),m,n));
				    goto foundit;
				}
a632 1
			    n = 0;
d634 3
a636 1
			T(("Range attributed with %s ends offscreen",
d638 1
a638 1
		    foundit:;
d640 2
a641 48
			if (end_onscreen)
			{
			    chtype	*lastline = newscr->_line[m].text;

			    /*
			     * If there are safely-attributed blanks at the
			     * end of the range, shorten the range.  This will
			     * help ensure that there is enough room at end
			     * of span.
			     */
			    while (n >= 0
				   && TextOf(lastline[n]) == ' '
				   && SAFE(AttrOf(lastline[n])))
				lastline[n--] &= ~turnon;

			    /* check that there's enough room at end of span */
			    for (k = 1; k <= magic_cookie_glitch; k++)
				if (n + k >= screen_columns
					|| TextOf(lastline[n + k]) != ' '
					|| !SAFE(AttrOf(lastline[n+k])))
				    failed = TRUE;
			}
		    }

		    if (failed)
		    {
			int p, q = j;

			T(("Clearing %s beginning at (%d, %d)",
						_traceattr(turnon), i, j));

			/* turn off new attributes over span */
			for (p = i; p < screen_lines; p++)
			{
			    for ( ; q < screen_columns; q++)
			    {
				if (AttrOf(newscr->_line[p].text[q]) == rattr)
				    goto foundend;
				newscr->_line[p].text[q] &= ~turnon;
			    }
			    q = 0;
			}
		    foundend:;
		    }
		    else
		    {
			T(("Cookie space for %s found before (%d, %d)",
						_traceattr(turnon), i, j));
d644 4
a647 2
			 * back up the start of range so there's room
			 * for cookies before the first nonblank character
d649 6
d656 4
a659 1
			    newscr->_line[i].text[j-k] |= turnon;
d661 7
d669 20
a688 1
		    rattr = AttrOf(newscr->_line[i].text[j]);
d691 4
d696 5
a700 6
	    /* show altered highlights after magic-cookie check */
	    if (_nc_tracing & TRACE_UPDATE)
	    {
		_tracef("After magic-cookie check...");
		_tracedump("newscr", newscr);
	    }
d702 2
a703 2
	}
#endif	/* USE_XMC_SUPPORT */
d705 8
a712 8
	nonempty = 0;
	if (curscr->_clear || newscr->_clear) {		/* force refresh ? */
		T(("clearing and updating from scratch"));
		ClrUpdate();
		curscr->_clear = FALSE;	/* reset flag */
		newscr->_clear = FALSE;	/* reset flag */
	} else {
		int changedlines = CHECK_INTERVAL;
d714 2
a715 2
		if(check_pending())
		    goto cleanup;
d717 1
a717 1
		nonempty = min(screen_lines, newscr->_maxy+1);
d719 3
a721 3
		if (SP->_scrolling) {
			_nc_scroll_optimize();
		}
d723 1
a723 1
		nonempty = ClrBottom(nonempty);
d725 10
a734 11
		T(("Transforming lines, nonempty %d", nonempty));
		for (i = 0; i < nonempty; i++) {
			/*
			 * Here is our line-breakout optimization.
			 */
			if (changedlines == CHECK_INTERVAL)
			{
			    if (check_pending())
				goto cleanup;
			    changedlines = 0;
			}
d736 11
a746 12
			/*
			 * newscr->line[i].firstchar is normally set
			 * by wnoutrefresh.  curscr->line[i].firstchar
			 * is normally set by _nc_scroll_window in the
			 * vertical-movement optimization code,
			 */
			if (newscr->_line[i].firstchar != _NOCHANGE
			 || curscr->_line[i].firstchar != _NOCHANGE)
			{
				TransformLine(i);
				changedlines++;
			}
d748 7
a754 6
			/* mark line changed successfully */
			if (i <= newscr->_maxy)
				MARK_NOCHANGE(newscr,i)
			if (i <= curscr->_maxy)
				MARK_NOCHANGE(curscr,i)
		}
d756 1
d758 7
a764 5
	/* put everything back in sync */
	for (i = nonempty; i <= newscr->_maxy; i++)
		MARK_NOCHANGE(newscr,i)
	for (i = nonempty; i <= curscr->_maxy; i++)
		MARK_NOCHANGE(curscr,i)
d766 3
a768 4
	if (!newscr->_leaveok)
	{
		curscr->_curx = newscr->_curx;
		curscr->_cury = newscr->_cury;
d770 2
a771 2
		GoTo(curscr->_cury, curscr->_curx);
	}
d773 6
a778 6
    cleanup:
	/*
	 * Keep the physical screen in normal mode in case we get other
	 * processes writing to the screen.
	 */
	UpdateAttrs(A_NORMAL);
d780 2
a781 3
	_nc_flush();
	curscr->_attrs = newscr->_attrs;
/*	curscr->_bkgd  = newscr->_bkgd; */
d784 3
a786 2
	(void) times(&after);
	TR(TRACE_TIMES, ("Update cost: %ld chars, %ld clocks system time, %ld clocks user time",
d788 2
a789 2
	    after.tms_stime-before.tms_stime,
	    after.tms_utime-before.tms_utime));
d792 1
a792 1
	_nc_signal_handler(TRUE);
d794 1
a794 1
	returnCode(OK);
d810 2
a811 1
static inline chtype ClrBlank (WINDOW *win)
d813 4
a816 4
chtype	blank = BLANK;
	if (back_color_erase)
		blank |= (BCE_BKGD(win) & BCE_ATTRS);
	return blank;
d826 2
a827 1
static void ClrUpdate(void)
d829 3
a831 3
	int i;
	chtype blank = ClrBlank(stdscr);
	int nonempty = min(screen_lines, newscr->_maxy+1);
d833 1
a833 1
	T(("ClrUpdate() called"));
d835 1
a835 1
	ClearScreen(blank);
d837 1
a837 1
	T(("updating screen from scratch"));
d839 1
a839 1
	nonempty = ClrBottom(nonempty);
d841 2
a842 2
	for (i = 0; i < nonempty; i++)
		TransformLine(i);
d851 2
a852 1
static void ClrToEOL(chtype blank)
d854 2
a855 2
int	j;
bool	needclear = FALSE;
d857 2
a858 3
	for (j = SP->_curscol; j < screen_columns; j++)
	{
	    chtype *cp = &(curscr->_line[SP->_cursrow].text[j]);
d860 3
a862 5
	    if (*cp != blank)
	    {
		*cp = blank;
		needclear = TRUE;
	    }
d864 1
d866 10
a875 17
	if (needclear)
	{
	    UpdateAttrs(blank);
	    TPUTS_TRACE("clr_eol");
	    if (SP->_el_cost > (screen_columns - SP->_curscol)
#ifdef NCURSES_EXT_FUNCS
	    || FILL_BCE()
#endif
	    )
	    {
		int count = (screen_columns - SP->_curscol);
		while (count-- > 0)
			PutChar(blank);
	    }
	    else
		putp(clr_eol);
	}
d884 2
a885 1
static void ClrToEOS(chtype blank)
d887 1
a887 1
int row, col;
d889 2
a890 2
	row = SP->_cursrow;
	col = SP->_curscol;
d892 5
a896 18
#ifdef NCURSES_EXT_FUNCS
	if (FILL_BCE()) {
		int i, j, k = col;
		for (i = row; i < screen_lines; i++) {
			GoTo(i, k);
			UpdateAttrs(blank);
			for (j = k; j < screen_columns; j++)
				PutChar(blank);
			k = 0;
		}
		GoTo(row, col);
	} else
#endif
	{
		UpdateAttrs(blank);
		TPUTS_TRACE("clr_eos");
		tputs(clr_eos, screen_lines-row, _nc_outch);
	}
d898 2
a899 2
	while (col < screen_columns)
		curscr->_line[row].text[col++] = blank;
d901 4
a904 5
	for (row++; row < screen_lines; row++)
	{
		for (col = 0; col < screen_columns; col++)
			curscr->_line[row].text[col] = blank;
	}
d914 2
a915 1
static int ClrBottom(int total)
d917 9
a925 2
static	chtype	*tstLine;
static	size_t	lenLine;
d927 2
a928 17
int	row, col;
int	top    = total;
int	last   = min(screen_columns, newscr->_maxx+1);
size_t	length = sizeof(chtype) * last;
chtype	blank  = newscr->_line[total-1].text[last-1]; /* lower right char */

	if(!clr_eos || !can_clear_with(blank))
		return total;

	if ((tstLine == 0) || (last > (int)lenLine)) {
		tstLine = typeRealloc(chtype, last, tstLine);
		if (tstLine != 0) {
			lenLine = last;
			for (col = 0; col < last; col++)
				tstLine[col] = blank;
		}
	}
d930 18
a947 7
	if (tstLine != 0) {
		for (row = total-1; row >= 0; row--) {
			if (memcmp(tstLine, newscr->_line[row].text, length))
				break;
			if (memcmp(tstLine, curscr->_line[row].text, length))
				top = row;
		}
d949 8
a956 11
		/* don't use clr_eos for just one line if clr_eol available */
		if (top < total-1 || (top < total && !clr_eol && !clr_bol)) {
			GoTo(top,0);
			ClrToEOS(blank);
			total = top;
			if (SP->oldhash && SP->newhash)
			{
				for (row = top; row < screen_lines; row++)
					SP->oldhash[row] = SP->newhash[row];
			}
		}
d958 1
d960 3
a962 3
	if (tstLine != 0) {
		FreeAndNull(tstLine);
	}
d964 1
a964 1
	return total;
a966 1

d985 2
a986 1
static void TransformLine(int const lineno)
d988 18
a1005 19
int	firstChar, oLastChar, nLastChar;
chtype	*newLine = newscr->_line[lineno].text;
chtype	*oldLine = curscr->_line[lineno].text;
int	n;
bool	attrchanged = FALSE;

	T(("TransformLine(%d) called", lineno));

	/* copy new hash value to old one */
	if (SP->oldhash && SP->newhash)
		SP->oldhash[lineno] = SP->newhash[lineno];

	if(ceol_standout_glitch && clr_eol) {
		firstChar = 0;
		while(firstChar < screen_columns) {
			if(AttrOf(newLine[firstChar]) != AttrOf(oldLine[firstChar]))
				attrchanged = TRUE;
			firstChar++;
		}
d1007 1
d1009 1
a1009 1
	firstChar = 0;
d1011 4
a1014 4
	if (attrchanged) {	/* we may have to disregard the whole line */
		GoTo(lineno, firstChar);
		ClrToEOL(ClrBlank(curscr));
		PutRange(oldLine, newLine, lineno, 0, (screen_columns-1));
d1032 18
a1049 4
	} else if (magic_cookie_glitch > 0) {
		GoTo(lineno, firstChar);
		for (n = 0; n < screen_columns; n++) {
			int m = n + magic_cookie_glitch;
d1051 1
a1051 12
			/* check for turn-on:
			 * If we are writing an attributed blank, where the
			 * previous cell is not attributed.
			 */
			if (TextOf(newLine[n]) == ' '
			 && ((n > 0
			   && xmc_turn_on(newLine[n-1], newLine[n]))
			  || (n == 0
			   && lineno > 0
			   && xmc_turn_on(NEW(lineno-1,screen_columns-1), newLine[n])))) {
				n = m;
			}
d1053 12
a1064 1
			PutChar(newLine[n]);
d1066 5
a1070 12
			/* check for turn-off:
			 * If we are writing an attributed non-blank, where the
			 * next cell is blank, and not attributed.
			 */
			if (TextOf(newLine[n]) != ' '
			 && ((n+1 < screen_columns
			   && xmc_turn_off(newLine[n], newLine[n+1]))
			  || (n+1 >= screen_columns
			   && lineno+1 < screen_lines
			   && xmc_turn_off(newLine[n], NEW(lineno+1,0))))) {
				n = m;
			}
d1072 31
a1103 4
#undef NEW
#endif
	} else {
		chtype blank;
d1105 2
a1106 4
		/* find the first differing character */
		while (firstChar < screen_columns  &&
				newLine[firstChar] == oldLine[firstChar])
			firstChar++;
a1107 1
		/* if there wasn't one, we're done */
d1109 3
a1111 1
			return;
d1113 1
a1113 28
		/* it may be cheap to clear leading whitespace with clr_bol */
		if (clr_bol && can_clear_with(blank=newLine[0]))
		{
			int oFirstChar, nFirstChar;

			for (oFirstChar = 0; oFirstChar < screen_columns; oFirstChar++)
				if (oldLine[oFirstChar] != blank)
					break;
			for (nFirstChar = 0; nFirstChar < screen_columns; nFirstChar++)
				if (newLine[nFirstChar] != blank)
					break;

			if (nFirstChar > oFirstChar + SP->_el1_cost)
			{
			    if (nFirstChar >= screen_columns && SP->_el_cost <= SP->_el1_cost)
			    {
				GoTo(lineno, 0);
				UpdateAttrs(blank);
				TPUTS_TRACE("clr_eol");
				putp(clr_eol);
			    }
			    else
			    {
				GoTo(lineno, nFirstChar - 1);
				UpdateAttrs(blank);
				TPUTS_TRACE("clr_bol");
				putp(clr_bol);
			    }
d1115 3
a1117 2
			    while (firstChar < nFirstChar)
				oldLine[firstChar++] = blank;
d1119 3
a1121 4
			    if (firstChar >= screen_columns)
				return;
			}
		}
d1123 9
a1131 1
		blank = newLine[screen_columns-1];
d1133 31
a1163 18
		if(!can_clear_with(blank))
		{
			/* find the last differing character */
			nLastChar = screen_columns - 1;

			while (nLastChar > firstChar
			 && newLine[nLastChar] == oldLine[nLastChar])
				nLastChar--;

			if (nLastChar >= firstChar) {
				GoTo(lineno, firstChar);
				PutRange(oldLine, newLine, lineno, firstChar, nLastChar);
				memcpy( oldLine + firstChar,
					newLine + firstChar,
					(nLastChar - firstChar + 1) * sizeof(chtype));
			}
			return;
		}
d1165 6
a1170 28
		/* find last non-blank character on old line */
		oLastChar = screen_columns - 1;
		while (oLastChar > firstChar  &&  oldLine[oLastChar] == blank)
			oLastChar--;

		/* find last non-blank character on new line */
		nLastChar = screen_columns - 1;
		while (nLastChar > firstChar  &&  newLine[nLastChar] == blank)
			nLastChar--;

		if((nLastChar == firstChar)
		 && (SP->_el_cost < (oLastChar - nLastChar))) {
			GoTo(lineno, firstChar);
			if(newLine[firstChar] != blank )
				PutChar(newLine[firstChar]);
			ClrToEOL(blank);
		} else if( (nLastChar != oLastChar)
			&& (newLine[nLastChar] != oldLine[oLastChar]
				|| !(_nc_idcok && has_ic())) ) {
			GoTo(lineno, firstChar);
			if ((oLastChar - nLastChar) > SP->_el_cost) {
				if(PutRange(oldLine, newLine, lineno, firstChar, nLastChar))
				    GoTo(lineno, nLastChar+1);
				ClrToEOL(blank);
			} else {
				n = max( nLastChar , oLastChar );
				PutRange(oldLine, newLine, lineno, firstChar, n);
			}
d1172 3
a1174 2
			int nLastNonblank = nLastChar;
			int oLastNonblank = oLastChar;
d1176 5
a1180 10
			/* find the last characters that really differ */
			while (newLine[nLastChar] == oldLine[oLastChar]) {
				if (nLastChar != 0
				 && oLastChar != 0) {
					nLastChar--;
					oLastChar--;
				 } else {
					break;
				 }
			}
d1182 28
a1209 36
			n = min(oLastChar, nLastChar);
			if (n >= firstChar) {
				GoTo(lineno, firstChar);
				PutRange(oldLine, newLine, lineno, firstChar, n);
			}

			if (oLastChar < nLastChar) {
				int m = max(nLastNonblank, oLastNonblank);
				GoTo(lineno, n+1);
				if (InsCharCost(nLastChar - oLastChar)
				 > (m - n)) {
					PutRange(oldLine, newLine, lineno, n+1, m);
				} else {
					InsStr(&newLine[n+1], nLastChar - oLastChar);
				}
			} else if (oLastChar > nLastChar ) {
				GoTo(lineno, n+1);
				if (DelCharCost(oLastChar - nLastChar)
				    > SP->_el_cost + nLastNonblank - (n+1)) {
					if(PutRange(oldLine, newLine, lineno,
							n+1, nLastNonblank))
						GoTo(lineno, nLastNonblank+1);
					ClrToEOL(blank);
				} else {
					/*
					 * The delete-char sequence will
					 * effectively shift in blanks from the
					 * right margin of the screen.  Ensure
					 * that they are the right color by
					 * setting the video attributes from
					 * the last character on the row.
					 */
					UpdateAttrs(blank);
					DelChar(oLastChar - nLastChar);
				}
			}
d1211 1
d1213 1
d1215 5
a1219 5
	/* update the code's internal representation */
	if (screen_columns > firstChar)
		memcpy( oldLine + firstChar,
			newLine + firstChar,
			(screen_columns - firstChar) * sizeof(chtype));
d1229 2
a1230 1
static void ClearScreen(chtype blank)
d1232 2
a1233 2
	int	i, j;
	bool	fast_clear = (clear_screen || clr_eos || clr_eol);
d1235 1
a1235 1
	T(("ClearScreen() called"));
d1238 5
a1242 6
	if (SP->_coloron
	 && !SP->_default_color) {
		_nc_do_color(0, FALSE, _nc_outch);
		if (!back_color_erase) {
			fast_clear = FALSE;
		}
d1244 1
d1247 24
a1270 33
	if (fast_clear) {
		if (clear_screen) {
			UpdateAttrs(blank);
			TPUTS_TRACE("clear_screen");
			putp(clear_screen);
			SP->_cursrow = SP->_curscol = 0;
			position_check(SP->_cursrow, SP->_curscol, "ClearScreen");
		} else if (clr_eos) {
			SP->_cursrow = SP->_curscol = -1;
			GoTo(0,0);

			UpdateAttrs(blank);
			TPUTS_TRACE("clr_eos");
			putp(clr_eos);
		} else if (clr_eol) {
			SP->_cursrow = SP->_curscol = -1;

			for (i = 0; i < screen_lines; i++) {
				GoTo(i, 0);
				UpdateAttrs(blank);
				TPUTS_TRACE("clr_eol");
				putp(clr_eol);
			}
			GoTo(0,0);
		}
	} else {
		for (i = 0; i < screen_lines; i++) {
			GoTo(i, 0);
			UpdateAttrs(blank);
			for (j = 0; j < screen_columns; j++)
				PutChar(blank);
		}
		GoTo(0,0);
d1272 1
a1272 1

d1274 4
a1277 2
		for (j = 0; j < screen_columns; j++)
			curscr->_line[i].text[j] = blank;
d1279 7
d1287 1
a1287 1
	T(("screen cleared"));
d1297 2
a1298 1
static void InsStr(chtype *line, int count)
d1300 1
a1300 1
	T(("InsStr(%p,%d) called", line, count));
d1302 36
a1337 39
	/* Prefer parm_ich as it has the smallest cost - no need to shift
	 * the whole line on each character. */
	/* The order must match that of InsCharCost. */
	if (parm_ich) {
		TPUTS_TRACE("parm_ich");
		tputs(tparm(parm_ich, count), count, _nc_outch);
		while (count) {
			PutAttrChar(*line);
			line++;
			count--;
		}
	} else if (enter_insert_mode  &&  exit_insert_mode) {
		TPUTS_TRACE("enter_insert_mode");
		putp(enter_insert_mode);
		while (count) {
			PutAttrChar(*line);
			if (insert_padding)
			{
				TPUTS_TRACE("insert_padding");
				putp(insert_padding);
			}
			line++;
			count--;
		}
		TPUTS_TRACE("exit_insert_mode");
		putp(exit_insert_mode);
	} else {
		while (count) {
			TPUTS_TRACE("insert_character");
			putp(insert_character);
			PutAttrChar(*line);
			if (insert_padding)
			{
				TPUTS_TRACE("insert_padding");
				putp(insert_padding);
			}
			line++;
			count--;
		}
d1339 2
a1340 1
	position_check(SP->_cursrow, SP->_curscol, "InsStr");
d1350 2
a1351 1
static void DelChar(int count)
d1353 1
a1353 1
	int n;
d1355 1
a1355 1
	T(("DelChar(%d) called, position = (%d,%d)", count, newscr->_cury, newscr->_curx));
d1357 7
a1363 8
	if (parm_dch) {
		TPUTS_TRACE("parm_dch");
		tputs(tparm(parm_dch, count), count, _nc_outch);
	} else {
		for (n = 0; n < count; n++) {
			TPUTS_TRACE("delete_character");
			putp(delete_character);
		}
d1365 1
a1365 10
#ifdef NCURSES_EXT_FUNCS
	if (FILL_BCE()) {
		chtype blank = ClrBlank(stdscr);
		GoTo(SP->_cursrow, screen_columns - count);
		UpdateAttrs(blank);
		for (n = 0; n < count; n++) {
			PutChar(blank);
		}
	}
#endif
d1374 2
a1375 1
void _nc_outstr(const char *str)
d1414 2
a1415 1
static int scroll_csr_forward(int n, int top, int bot, int miny, int maxy, chtype blank)
d1419 1
a1419 2
    if (n == 1 && scroll_forward && top == miny && bot == maxy)
    {
d1424 1
a1424 3
    }
    else if (n == 1 && delete_line && bot == maxy)
    {
d1429 1
a1429 3
    }
    else if (parm_index && top == miny && bot == maxy)
    {
d1434 1
a1434 3
    }
    else if (parm_delete_line && bot == maxy)
    {
d1439 1
a1439 3
    }
    else if (scroll_forward && top == miny && bot == maxy)
    {
d1442 1
a1442 2
	for (i = 0; i < n; i++)
	{
d1446 1
a1446 3
    }
    else if (delete_line && bot == maxy)
    {
d1449 1
a1449 2
	for (i = 0; i < n; i++)
	{
d1453 1
a1453 2
    }
    else
d1470 2
a1471 1
static int scroll_csr_backward(int n, int top, int bot, int miny, int maxy, chtype blank)
d1475 1
a1475 2
    if (n == 1 && scroll_reverse && top == miny && bot == maxy)
    {
d1480 1
a1480 3
    }
    else if (n == 1 && insert_line && bot == maxy)
    {
d1485 1
a1485 3
    }
    else if (parm_rindex && top == miny && bot == maxy)
    {
d1490 1
a1490 3
    }
    else if (parm_insert_line && bot == maxy)
    {
d1495 1
a1495 3
    }
    else if (scroll_reverse && top == miny && bot == maxy)
    {
d1498 1
a1498 2
	for (i = 0; i < n; i++)
	{
d1502 1
a1502 3
    }
    else if (insert_line && bot == maxy)
    {
d1505 1
a1505 2
	for (i = 0; i < n; i++)
	{
d1509 1
a1509 2
    }
    else
d1526 2
a1527 1
static int scroll_idl(int n, int del, int ins, chtype blank)
d1531 1
a1531 1
    if(!((parm_delete_line || delete_line) && (parm_insert_line || insert_line)))
d1536 1
a1536 2
    if (n == 1 && delete_line)
    {
d1539 1
a1539 3
    }
    else if (parm_delete_line)
    {
d1542 2
a1543 5
    }
    else /* if (delete_line) */
    {
	for (i = 0; i < n; i++)
	{
d1551 1
a1551 2
    if (n == 1 && insert_line)
    {
d1554 1
a1554 3
    }
    else if (parm_insert_line)
    {
d1557 2
a1558 5
    }
    else /* if (insert_line) */
    {
	for (i = 0; i < n; i++)
	{
d1567 2
a1568 1
int _nc_scrolln(int n, int top, int bot, int maxy)
d1571 1
a1571 1
    chtype blank=ClrBlank(stdscr);
d1573 1
a1573 1
    bool cursor_saved=FALSE;
d1587 1
a1587 2
    if (n > 0) /* scroll up (forward) */
    {
d1593 1
a1593 2
	    for (i = 0; i < n; i++)
	    {
d1601 5
a1605 7
	if (res == ERR && change_scroll_region)
	{
	    if ((((n==1 && scroll_forward) || parm_index)
		 && (SP->_cursrow == bot || SP->_cursrow == bot-1))
		&& save_cursor && restore_cursor)
	    {
		cursor_saved=TRUE;
d1611 1
a1611 2
	    if (cursor_saved)
	    {
d1614 1
a1614 3
	    }
	    else
	    {
d1626 2
a1627 4
	    res = scroll_idl(n, top, bot-n+1, blank);
    }
    else /* (n < 0) - scroll down (backward) */
    {
d1632 2
a1633 4
	if (non_dest_scroll_region || (memory_below && bot == maxy))
	{
	    if (bot == maxy && clr_eos)
	    {
d1636 2
a1637 5
	    }
	    else if (clr_eol)
	    {
		for (i = 0; i < -n; i++)
		{
d1646 4
a1649 6
	if (res == ERR && change_scroll_region)
	{
	    if (top != 0 && (SP->_cursrow == top || SP->_cursrow == top-1)
		&& save_cursor && restore_cursor)
	    {
		cursor_saved=TRUE;
d1655 1
a1655 2
	    if (cursor_saved)
	    {
d1658 1
a1658 3
	    }
	    else
	    {
d1670 1
a1670 1
	    res = scroll_idl(-n, bot+n+1, top, blank);
d1674 1
a1674 1
	return(ERR);
d1681 1
a1681 1
    return(OK);
d1684 2
a1685 2

void _nc_screen_resume()
d1695 1
a1695 2
    else
    {
d1710 2
a1711 1
void _nc_screen_init()
d1717 2
a1718 1
void _nc_screen_wrap()
d1723 1
a1723 1
     && !SP->_default_color) {
d1732 2
a1733 1
void _nc_do_xmc_glitch(attr_t previous)
d1735 1
a1735 1
	attr_t chg = XMC_CHANGES(previous ^ SP->_current_attr);
d1737 6
a1742 8
	while (chg != 0) {
		if (chg & 1) {
			SP->_curscol += magic_cookie_glitch;
			if (SP->_curscol >= SP->_columns)
				wrap_cursor();
			T(("bumped to %d,%d after cookie", SP->_cursrow, SP->_curscol));
		}
		chg >>= 1;
d1744 2
@


1.5
log
@Update to ncurses-5.0-20000115:
+ additional fixes for non-bce terminals (handling of delete_character)
to work when assume_default_colors() is not specified.
+ modify warning message from _nc_parse_entry() regarding extended
capability names to print only if tic/infocmp/toe have the -v flag
set, and not at all in ordinary user applications.  Otherwise, this
warning would be shown for screen's extended capabilities in programs
that use the termcap interface.
+ modify use of _nc_tracing from programs such as tic so their debug
level is not in the same range as values set by trace() function.
+ small panel header cleanup (patch by Juergen Pfeifer).
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.4 1999/11/28 17:49:55 millert Exp $	*/
a67 2
#include <stropts.h>
#include <poll.h>
d76 1
a76 1
MODULE_ID("$From: tty_update.c,v 1.123 2000/01/15 23:49:36 tom Exp $")
@


1.4
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.3 1999/03/02 06:23:30 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d78 1
a78 1
MODULE_ID("$From: tty_update.c,v 1.122 1999/11/28 03:07:38 tom Exp $")
d91 1
d878 1
a878 1
	    || (SP->_coloron && !SP->_default_color && !back_color_erase)
d905 1
a905 1
	if (SP->_coloron && !SP->_default_color && !back_color_erase) {
d1381 2
d1389 1
a1389 2
		while (count--)
		{
d1394 10
d1507 1
a1507 1
    if (SP->_coloron && !SP->_default_color && !back_color_erase) {
d1576 1
a1576 1
    if (SP->_coloron && !SP->_default_color && !back_color_erase) {
@


1.3
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.2 1999/01/31 20:17:10 millert Exp $	*/
d47 4
a75 6
#ifdef __BEOS__
/* BeOS select() only works on sockets.  Use the tty hack instead */
#include <socket.h>
#define select check_select
#endif

d78 1
a78 1
MODULE_ID("$From: tty_update.c,v 1.111 1999/02/27 20:07:56 tom Exp $")
a99 1
static int InsStr( chtype *line, int count );
d103 1
d113 1
a113 1
void position_check(int expected_y, int expected_x, char *legend)
d116 1
a116 1
    static char  buf[9];
d119 1
a119 1
    if (_nc_tracing)
d123 3
a125 2
    (void) write(1, "\033[6n", 4);	/* only works on ANSI-compatibles */
    (void) read(0, (void *)buf, 8);
d129 1
a129 1
    if (sscanf(buf, "\033[%d;%dR", &y, &x) != 2)
d131 13
a143 5
    else if (y - 1 != expected_y || x - 1 != expected_x)
	_tracef("position seen (%d, %d) doesn't match expected one (%d, %d) in %s",
		y-1, x-1, expected_y, expected_x, legend);
    else
	_tracef("position matches OK in %s", legend);
d145 2
a161 1
#ifdef POSITION_DEBUG
a162 1
#endif /* POSITION_DEBUG */
d180 1
d192 4
a195 1
	putc((int)TextOf(ch), SP->_ofp);
d197 1
a197 1
	_nc_outchars++;
d199 1
d229 15
d261 1
a261 1
		fflush(SP->_ofp);
d293 2
d341 1
a354 1
#ifdef POSITION_DEBUG
a355 1
#endif /* POSITION_DEBUG */
d786 1
a786 1
	fflush(SP->_ofp);
d875 5
a879 1
	    if (SP->_el_cost > (screen_columns - SP->_curscol))
a899 2
	UpdateAttrs(blank);
	TPUTS_TRACE("clr_eos");
d901 20
a920 1
	tputs(clr_eos, screen_lines-row, _nc_outch);
d922 2
a923 2
	for (col = SP->_curscol; col < screen_columns; col++)
		curscr->_line[row].text[col] = blank;
d955 5
a962 4
		lenLine = last;
		for (col = 0; col < last; col++)
			tstLine[col] = blank;

d983 1
a983 1
	if (tstLine != 0)
d985 1
d1260 1
d1264 20
a1283 11
	if (clear_screen) {
		UpdateAttrs(blank);
		TPUTS_TRACE("clear_screen");
		putp(clear_screen);
		SP->_cursrow = SP->_curscol = 0;
#ifdef POSITION_DEBUG
		position_check(SP->_cursrow, SP->_curscol, "ClearScreen");
#endif /* POSITION_DEBUG */
	} else if (clr_eos) {
		SP->_cursrow = SP->_curscol = -1;
		GoTo(0,0);
d1285 5
a1289 5
		UpdateAttrs(blank);
		TPUTS_TRACE("clr_eos");
		putp(clr_eos);
	} else if (clr_eol) {
		SP->_cursrow = SP->_curscol = -1;
d1291 9
d1303 2
a1304 2
			TPUTS_TRACE("clr_eol");
			putp(clr_eol);
a1306 3
	} else {
		T(("cannot clear screen"));
		return;
d1324 1
a1324 1
static int InsStr(chtype *line, int count)
a1338 1
		return(OK);
a1353 1
		return(OK);
a1366 1
		return(OK);
d1368 1
d1402 2
a1403 8
    FILE *ofp = SP ? SP->_ofp : stdout;

    (void) fputs(str, ofp);
    (void) fflush(ofp);

#ifdef TRACE
    _nc_outchars += strlen(str);
#endif /* TRACE */
d1441 1
a1441 1
    int i;
d1494 9
d1510 1
a1510 1
    int i;
d1563 9
d1800 8
@


1.2
log
@ncurses-4.2-990130
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_update.c,v 1.1 1999/01/18 19:10:27 millert Exp $	*/
d80 1
a80 1
MODULE_ID("$From: tty_update.c,v 1.110 1999/01/31 01:45:37 Alexander.V.Lukyanov Exp $")
d904 2
a905 2
	if (tstLine == 0 || length > lenLine) {
		tstLine = (chtype *)_nc_doalloc(tstLine, length);
d909 1
a909 1
		lenLine = length;
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 1
MODULE_ID("$From: tty_update.c,v 1.109 1998/10/03 19:08:33 tom Exp $")
d104 1
a104 1
static void ClrUpdate( WINDOW *win );
d685 3
a687 7
	if (curscr->_clear) {		/* force refresh ? */
		/* yes, clear all & update */
		T(("clearing and updating curscr"));
		if (is_wintouched(newscr))
			ClrUpdate(newscr);
		else
			ClrUpdate(curscr);
a689 4
	} else if (newscr->_clear) {
		T(("clearing and updating newscr"));
		ClrUpdate(newscr);
		newscr->_clear = FALSE;
d797 1
a797 1
**	ClrUpdate(win)
d803 1
a803 1
static void ClrUpdate(WINDOW *win)
d806 1
a806 1
	chtype blank = ClrBlank(win);
a809 9

	if (win == curscr) {
		/* discard updates */
		for (i = 0; i < screen_lines ; i++) {
			memcpy( newscr->_line[i].text,
				curscr->_line[i].text,
				screen_columns * sizeof(chtype));
		}
	}
@

