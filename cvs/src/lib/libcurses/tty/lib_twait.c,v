head	1.9;
access;
symbols
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.32
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.28
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.24
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.26
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.18
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.22
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.20
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.38
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.34
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.32
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.30
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.28
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.26
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.24
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.22
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.20
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.18
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.16
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.14
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.12
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.10
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.8
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.6
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.22.18.02.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.10.15.10.32;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.08.22.47.05;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.10.03.06.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.10.01.35.05;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.06.07.10.51;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.11.28.17.49.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.27;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
**	lib_twait.c
**
**	The routine _nc_timed_wait().
**
**	(This file was originally written by Eric Raymond; however except for
**	comments, none of the original code remains - T.Dickey).
*/

#include <curses.priv.h>

#if defined __HAIKU__ && defined __BEOS__
#undef __BEOS__
#endif

#ifdef __BEOS__
#undef false
#undef true
#include <OS.h>
#endif

#if USE_FUNC_POLL
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# endif
#elif HAVE_SELECT
# if HAVE_SYS_TIME_H && HAVE_SYS_TIME_SELECT
#  include <sys/time.h>
# endif
# if HAVE_SYS_SELECT_H
#  include <sys/select.h>
# endif
#endif

#undef CUR

MODULE_ID("$Id: lib_twait.c,v 1.59 2008/08/30 20:08:19 tom Exp $")

static long
_nc_gettime(TimeType * t0, bool first)
{
    long res;

#if PRECISE_GETTIME
    TimeType t1;
    gettimeofday(&t1, (struct timezone *) 0);
    if (first) {
	*t0 = t1;
	res = 0;
    } else {
	/* .tv_sec and .tv_usec are unsigned, be careful when subtracting */
	if (t0->tv_usec > t1.tv_usec) {
	    t1.tv_usec += 1000000;	/* Convert 1s in 1e6 microsecs */
	    t1.tv_sec--;
	}
	res = (t1.tv_sec - t0->tv_sec) * 1000
	    + (t1.tv_usec - t0->tv_usec) / 1000;
    }
#else
    time_t t1 = time((time_t *) 0);
    if (first) {
	*t0 = t1;
    }
    res = (t1 - *t0) * 1000;
#endif
    TR(TRACE_IEVENT, ("%s time: %ld msec", first ? "get" : "elapsed", res));
    return res;
}

#ifdef NCURSES_WGETCH_EVENTS
NCURSES_EXPORT(int)
_nc_eventlist_timeout(_nc_eventlist * evl)
{
    int event_delay = -1;
    int n;

    if (evl != 0) {

	for (n = 0; n < evl->count; ++n) {
	    _nc_event *ev = evl->events[n];

	    if (ev->type == _NC_EVENT_TIMEOUT_MSEC) {
		event_delay = ev->data.timeout_msec;
		if (event_delay < 0)
		    event_delay = INT_MAX;	/* FIXME Is this defined? */
	    }
	}
    }
    return event_delay;
}
#endif /* NCURSES_WGETCH_EVENTS */

/*
 * Wait a specified number of milliseconds, returning nonzero if the timer
 * didn't expire before there is activity on the specified file descriptors.
 * The file-descriptors are specified by the mode:
 *	0 - none (absolute time)
 *	1 - ncurses' normal input-descriptor
 *	2 - mouse descriptor, if any
 *	3 - either input or mouse.
 *
 * Experimental:  if NCURSES_WGETCH_EVENTS is defined, (mode & 4) determines
 * whether to pay attention to evl argument.  If set, the smallest of
 * millisecond and of timeout of evl is taken.
 *
 * We return a mask that corresponds to the mode (e.g., 2 for mouse activity).
 *
 * If the milliseconds given are -1, the wait blocks until activity on the
 * descriptors.
 */
NCURSES_EXPORT(int)
_nc_timed_wait(SCREEN *sp,
	       int mode,
	       int milliseconds,
	       int *timeleft
	       EVENTLIST_2nd(_nc_eventlist * evl))
{
    int fd;
    int count;
    int result = 0;
    TimeType t0;

#ifdef NCURSES_WGETCH_EVENTS
    int timeout_is_event = 0;
    int n;
#endif

#if USE_FUNC_POLL
#define MIN_FDS 2
    struct pollfd fd_list[MIN_FDS];
    struct pollfd *fds = fd_list;
#elif defined(__BEOS__)
#elif HAVE_SELECT
    fd_set set;
#endif

    long starttime, returntime;

    TR(TRACE_IEVENT, ("start twait: %d milliseconds, mode: %d",
		      milliseconds, mode));

#ifdef NCURSES_WGETCH_EVENTS
    if (mode & 4) {
	int event_delay = _nc_eventlist_timeout(evl);

	if (event_delay >= 0
	    && (milliseconds >= event_delay || milliseconds < 0)) {
	    milliseconds = event_delay;
	    timeout_is_event = 1;
	}
    }
#endif

#if PRECISE_GETTIME && HAVE_NANOSLEEP
  retry:
#endif
    starttime = _nc_gettime(&t0, TRUE);

    count = 0;

#ifdef NCURSES_WGETCH_EVENTS
    if ((mode & 4) && evl)
	evl->result_flags = 0;
#endif

#if USE_FUNC_POLL
    memset(fd_list, 0, sizeof(fd_list));

#ifdef NCURSES_WGETCH_EVENTS
    if ((mode & 4) && evl)
	fds = typeMalloc(struct pollfd, MIN_FDS + evl->count);
#endif

    if (mode & 1) {
	fds[count].fd = sp->_ifd;
	fds[count].events = POLLIN;
	count++;
    }
    if ((mode & 2)
	&& (fd = sp->_mouse_fd) >= 0) {
	fds[count].fd = fd;
	fds[count].events = POLLIN;
	count++;
    }
#ifdef NCURSES_WGETCH_EVENTS
    if ((mode & 4) && evl) {
	for (n = 0; n < evl->count; ++n) {
	    _nc_event *ev = evl->events[n];

	    if (ev->type == _NC_EVENT_FILE
		&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {
		fds[count].fd = ev->data.fev.fd;
		fds[count].events = POLLIN;
		count++;
	    }
	}
    }
#endif

    result = poll(fds, (unsigned) count, milliseconds);

#ifdef NCURSES_WGETCH_EVENTS
    if ((mode & 4) && evl) {
	int c;

	if (!result)
	    count = 0;

	for (n = 0; n < evl->count; ++n) {
	    _nc_event *ev = evl->events[n];

	    if (ev->type == _NC_EVENT_FILE
		&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {
		ev->data.fev.result = 0;
		for (c = 0; c < count; c++)
		    if (fds[c].fd == ev->data.fev.fd
			&& fds[c].revents & POLLIN) {
			ev->data.fev.result |= _NC_EVENT_FILE_READABLE;
			evl->result_flags |= _NC_EVENT_FILE_READABLE;
		    }
	    } else if (ev->type == _NC_EVENT_TIMEOUT_MSEC
		       && !result && timeout_is_event) {
		evl->result_flags |= _NC_EVENT_TIMEOUT_MSEC;
	    }
	}
    }

    if (fds != fd_list)
	free((char *) fds);

#endif

#elif defined(__BEOS__)
    /*
     * BeOS's select() is declared in socket.h, so the configure script does
     * not see it.  That's just as well, since that function works only for
     * sockets.  This (using snooze and ioctl) was distilled from Be's patch
     * for ncurses which uses a separate thread to simulate select().
     *
     * FIXME: the return values from the ioctl aren't very clear if we get
     * interrupted.
     *
     * FIXME: this assumes mode&1 if milliseconds < 0 (see lib_getch.c).
     */
    result = 0;
    if (mode & 1) {
	int step = (milliseconds < 0) ? 0 : 5000;
	bigtime_t d;
	bigtime_t useconds = milliseconds * 1000;
	int n, howmany;

	if (useconds <= 0)	/* we're here to go _through_ the loop */
	    useconds = 1;

	for (d = 0; d < useconds; d += step) {
	    n = 0;
	    howmany = ioctl(0, 'ichr', &n);
	    if (howmany >= 0 && n > 0) {
		result = 1;
		break;
	    }
	    if (useconds > 1 && step > 0) {
		snooze(step);
		milliseconds -= (step / 1000);
		if (milliseconds <= 0) {
		    milliseconds = 0;
		    break;
		}
	    }
	}
    } else if (milliseconds > 0) {
	snooze(milliseconds * 1000);
	milliseconds = 0;
    }
#elif HAVE_SELECT
    /*
     * select() modifies the fd_set arguments; do this in the
     * loop.
     */
    FD_ZERO(&set);

    if (mode & 1) {
	FD_SET(sp->_ifd, &set);
	count = sp->_ifd + 1;
    }
    if ((mode & 2)
	&& (fd = sp->_mouse_fd) >= 0) {
	FD_SET(fd, &set);
	count = max(fd, count) + 1;
    }
#ifdef NCURSES_WGETCH_EVENTS
    if ((mode & 4) && evl) {
	for (n = 0; n < evl->count; ++n) {
	    _nc_event *ev = evl->events[n];

	    if (ev->type == _NC_EVENT_FILE
		&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {
		FD_SET(ev->data.fev.fd, &set);
		count = max(ev->data.fev.fd + 1, count);
	    }
	}
    }
#endif

    if (milliseconds >= 0) {
	struct timeval ntimeout;
	ntimeout.tv_sec = milliseconds / 1000;
	ntimeout.tv_usec = (milliseconds % 1000) * 1000;
	result = select(count, &set, NULL, NULL, &ntimeout);
    } else {
	result = select(count, &set, NULL, NULL, NULL);
    }

#ifdef NCURSES_WGETCH_EVENTS
    if ((mode & 4) && evl) {
	evl->result_flags = 0;
	for (n = 0; n < evl->count; ++n) {
	    _nc_event *ev = evl->events[n];

	    if (ev->type == _NC_EVENT_FILE
		&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {
		ev->data.fev.result = 0;
		if (FD_ISSET(ev->data.fev.fd, &set)) {
		    ev->data.fev.result |= _NC_EVENT_FILE_READABLE;
		    evl->result_flags |= _NC_EVENT_FILE_READABLE;
		}
	    } else if (ev->type == _NC_EVENT_TIMEOUT_MSEC
		       && !result && timeout_is_event)
		evl->result_flags |= _NC_EVENT_TIMEOUT_MSEC;
	}
    }
#endif

#endif /* USE_FUNC_POLL, etc */

    returntime = _nc_gettime(&t0, FALSE);

    if (milliseconds >= 0)
	milliseconds -= (returntime - starttime);

#ifdef NCURSES_WGETCH_EVENTS
    if (evl) {
	evl->result_flags = 0;
	for (n = 0; n < evl->count; ++n) {
	    _nc_event *ev = evl->events[n];

	    if (ev->type == _NC_EVENT_TIMEOUT_MSEC) {
		long diff = (returntime - starttime);
		if (ev->data.timeout_msec <= diff)
		    ev->data.timeout_msec = 0;
		else
		    ev->data.timeout_msec -= diff;
	    }

	}
    }
#endif

#if PRECISE_GETTIME && HAVE_NANOSLEEP
    /*
     * If the timeout hasn't expired, and we've gotten no data,
     * this is probably a system where 'select()' needs to be left
     * alone so that it can complete.  Make this process sleep,
     * then come back for more.
     */
    if (result == 0 && milliseconds > 100) {
	napms(100);		/* FIXME: this won't be right if I recur! */
	milliseconds -= 100;
	goto retry;
    }
#endif

    /* return approximate time left in milliseconds */
    if (timeleft)
	*timeleft = milliseconds;

    TR(TRACE_IEVENT, ("end twait: returned %d (%d), remaining time %d msec",
		      result, errno, milliseconds));

    /*
     * Both 'poll()' and 'select()' return the number of file descriptors
     * that are active.  Translate this back to the mask that denotes which
     * file-descriptors, so that we don't need all of this system-specific
     * code everywhere.
     */
    if (result != 0) {
	if (result > 0) {
	    result = 0;
#if USE_FUNC_POLL
	    for (count = 0; count < MIN_FDS; count++) {
		if ((mode & (1 << count))
		    && (fds[count].revents & POLLIN)) {
		    result |= (1 << count);
		}
	    }
#elif defined(__BEOS__)
	    result = 1;		/* redundant, but simple */
#elif HAVE_SELECT
	    if ((mode & 2)
		&& (fd = sp->_mouse_fd) >= 0
		&& FD_ISSET(fd, &set))
		result |= 2;
	    if ((mode & 1)
		&& FD_ISSET(sp->_ifd, &set))
		result |= 1;
#endif
	} else
	    result = 0;
    }
#ifdef NCURSES_WGETCH_EVENTS
    if ((mode & 4) && evl && evl->result_flags)
	result |= 4;
#endif

    return (result);
}
@


1.8
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_twait.c,v 1.7 2000/10/10 15:10:32 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d46 6
d53 2
a57 2
#include <curses.priv.h>

d71 3
a73 1
MODULE_ID("$From: lib_twait.c,v 1.41 2000/12/10 03:04:30 tom Exp $")
d76 1
a76 1
_nc_gettime(bool first)
d80 2
a81 4
#if HAVE_GETTIMEOFDAY
# define PRECISE_GETTIME 1
    static struct timeval t0;
    struct timeval t1;
d84 10
a93 1
	t0 = t1;
a94 2
    res = (t1.tv_sec - t0.tv_sec) * 1000
	+ (t1.tv_usec - t0.tv_usec) / 1000;
a95 2
# define PRECISE_GETTIME 0
    static time_t t0;
d98 1
a98 1
	t0 = t1;
d100 1
a100 1
    res = (t1 - t0) * 1000;
d102 1
a102 1
    T(("%s time: %ld msec", first ? "get" : "elapsed", res));
d106 23
d137 5
d148 5
a152 2
_nc_timed_wait
(int mode, int milliseconds, int *timeleft)
d156 2
d159 4
a162 1
    int result;
d165 3
a167 1
    struct pollfd fds[2];
d170 1
a170 4
    static fd_set *set;
    static size_t setsize;
    size_t nsetsize;
    int readfd;
d175 14
a188 1
    T(("start twait: %d milliseconds, mode: %d", milliseconds, mode));
d190 1
a190 1
#if PRECISE_GETTIME
d193 1
a193 1
    starttime = _nc_gettime(TRUE);
d197 5
d203 7
a209 1
    memset(fds, 0, sizeof(fds));
d211 1
a211 1
	fds[count].fd = SP->_ifd;
d216 1
a216 1
	&& (fd = SP->_mouse_fd) >= 0) {
d221 47
a267 1
    result = poll(fds, count, milliseconds);
d278 2
d283 1
d288 1
a288 1
	if (useconds == 0)	/* we're here to go _through_ the loop */
d291 1
a291 1
	for (d = 0; d < useconds; d += 5000) {
d298 8
a305 3
	    if (useconds > 1)
		snooze(5000);
	    milliseconds -= 5;
a311 18
    if (mode & 1) {
	count = SP->_ifd;
	readfd = SP->_ifd;
    }
    if ((mode & 2) && (fd = SP->_mouse_fd) >= 0) {
	count = max(fd, count);
	readfd = fd;
    }

    /*
     * grow set as needed.
     */
    nsetsize = howmany(count, NFDBITS) * sizeof(fd_mask);
    if (setsize == 0 || setsize < nsetsize) {
	setsize = nsetsize;
	set = _nc_doalloc(set, setsize);
    }

d316 24
a339 2
    memset(set, 0, setsize);
    FD_SET(readfd, set);
d345 1
a345 1
	result = select(count + 1, set, NULL, NULL, &ntimeout);
d347 20
a366 1
	result = select(count + 1, set, NULL, NULL, NULL);
d370 3
a372 1
    returntime = _nc_gettime(FALSE);
d377 19
a395 1
#if PRECISE_GETTIME
d403 1
a403 1
	napms(100);
d413 2
a414 2
    T(("end twait: returned %d (%d), remaining time %d msec",
       result, errno, milliseconds));
d426 1
a426 1
	    for (count = 0; count < 2; count++) {
d436 2
a437 2
		&& (fd = SP->_mouse_fd) >= 0
		&& FD_ISSET(fd, set))
d440 1
a440 1
		&& FD_ISSET(SP->_ifd, set))
d446 4
@


1.7
log
@Don't ignore $TERMCAP, $TERMINFO, $TERMINFO_DIRS, $TERMPATH, and $HOME
if root but not setugid.

Fix select usage to deal with an arbitrary number of fd's.  This code
is not compiled since we use poll(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_twait.c,v 1.6 2000/10/08 22:47:05 millert Exp $	*/
d64 1
a64 1
MODULE_ID("$From: lib_twait.c,v 1.39 2000/08/26 19:34:15 tom Exp $")
d107 3
a109 2
int
_nc_timed_wait(int mode, int milliseconds, int *timeleft)
@


1.6
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_twait.c,v 1.5 2000/07/10 03:06:16 millert Exp $	*/
d119 4
a122 1
    static fd_set set;
d186 18
d208 2
a209 11
    FD_ZERO(&set);

    if (mode & 1) {
	FD_SET(SP->_ifd, &set);
	count = SP->_ifd + 1;
    }
    if ((mode & 2)
	&& (fd = SP->_mouse_fd) >= 0) {
	FD_SET(fd, &set);
	count = max(fd, count) + 1;
    }
d215 1
a215 1
	result = select(count, &set, NULL, NULL, &ntimeout);
d217 1
a217 1
	result = select(count, &set, NULL, NULL, NULL);
d268 1
a268 1
		&& FD_ISSET(fd, &set))
d271 1
a271 1
		&& FD_ISSET(SP->_ifd, &set))
@


1.5
log
@ncurses 5.1
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_twait.c,v 1.4 2000/03/10 01:35:05 millert Exp $	*/
d64 1
a64 1
MODULE_ID("$From: lib_twait.c,v 1.37 2000/06/29 23:03:09 tom Exp $")
d66 2
a67 1
static long _nc_gettime(bool first)
d69 1
a69 1
	long res;
d73 8
a80 8
	static struct timeval t0;
	struct timeval t1;
	gettimeofday(&t1, (struct timezone *)0);
	if (first) {
		t0 = t1;
	}
	res = (t1.tv_sec  - t0.tv_sec)  * 1000
	    + (t1.tv_usec - t0.tv_usec) / 1000;
d83 6
a88 6
	static time_t t0;
	time_t t1 = time((time_t*)0);
	if (first) {
		t0 = t1;
	}
	res = (t1 - t0) * 1000;
d90 2
a91 2
	T(("%s time: %ld msec", first ? "get" : "elapsed", res));
	return res;
d107 2
a108 1
int _nc_timed_wait(int mode, int milliseconds, int *timeleft)
d110 2
a111 2
int	fd;
int	count;
d113 1
a113 1
int result;
d116 1
a116 1
struct pollfd fds[2];
d119 1
a119 1
static fd_set set;
d122 1
a122 1
long starttime, returntime;
d124 1
a124 1
	T(("start twait: %d milliseconds, mode: %d", milliseconds, mode));
d127 1
a127 1
retry:
d129 1
a129 1
	starttime = _nc_gettime(TRUE);
d131 1
a131 1
	count = 0;
d134 13
a146 12
	if (mode & 1) {
		fds[count].fd     = SP->_ifd;
		fds[count].events = POLLIN;
		count++;
	}
	if ((mode & 2)
	 && (fd = SP->_mouse_fd) >= 0) {
		fds[count].fd     = fd;
		fds[count].events = POLLIN;
		count++;
	}
	result = poll(fds, count, milliseconds);
d149 28
a176 32
	/*
	 * BeOS's select() is declared in socket.h, so the configure script does
	 * not see it.  That's just as well, since that function works only for
	 * sockets.  This (using snooze and ioctl) was distilled from Be's patch
	 * for ncurses which uses a separate thread to simulate select().
	 *
	 * FIXME: the return values from the ioctl aren't very clear if we get
	 * interrupted.
	 */
	result = 0;
	if (mode & 1) {
		bigtime_t d;
		bigtime_t useconds = milliseconds * 1000;
		int n, howmany;

		if (useconds == 0) /* we're here to go _through_ the loop */
			useconds = 1;

		for (d = 0; d < useconds; d += 5000) {
			n = 0;
			howmany = ioctl(0, 'ichr', &n);
			if (howmany >= 0 && n > 0) {
				result = 1;
				break;
			}
			if (useconds > 1)
				snooze(5000);
			milliseconds -= 5;
		}
	} else if (milliseconds > 0) {
		snooze(milliseconds * 1000);
		milliseconds = 0;
d178 4
d183 24
a206 24
	/*
	 * select() modifies the fd_set arguments; do this in the
	 * loop.
	 */
	FD_ZERO(&set);

	if (mode & 1) {
		FD_SET(SP->_ifd, &set);
		count = SP->_ifd + 1;
	}
	if ((mode & 2)
	 && (fd = SP->_mouse_fd) >= 0) {
		FD_SET(fd, &set);
		count = max(fd, count) + 1;
	}

	if (milliseconds >= 0) {
		struct timeval ntimeout;
		ntimeout.tv_sec  = milliseconds / 1000;
		ntimeout.tv_usec = (milliseconds % 1000) * 1000;
		result = select(count, &set, NULL, NULL, &ntimeout);
	} else {
		result = select(count, &set, NULL, NULL, NULL);
	}
d209 1
a209 1
	returntime = _nc_gettime(FALSE);
d211 2
a212 2
	if (milliseconds >= 0)
		milliseconds -= (returntime - starttime);
d215 11
a225 11
	/*
	 * If the timeout hasn't expired, and we've gotten no data,
	 * this is probably a system where 'select()' needs to be left
	 * alone so that it can complete.  Make this process sleep,
	 * then come back for more.
	 */
	if (result == 0 && milliseconds > 100) {
		napms(100);
		milliseconds -= 100;
		goto retry;
	}
d228 16
a243 16
	/* return approximate time left in milliseconds */
	if (timeleft)
		*timeleft = milliseconds;

	T(("end twait: returned %d (%d), remaining time %d msec",
		result, errno, milliseconds));

	/*
	 * Both 'poll()' and 'select()' return the number of file descriptors
	 * that are active.  Translate this back to the mask that denotes which
	 * file-descriptors, so that we don't need all of this system-specific
	 * code everywhere.
	 */
	if (result != 0) {
		if (result > 0) {
			result = 0;
d245 6
a250 6
			for (count = 0; count < 2; count++) {
				if ((mode & (1 << count))
				 && (fds[count].revents & POLLIN)) {
					result |= (1 << count);
				}
			}
d252 1
a252 1
			result = 1;	/* redundant, but simple */
d254 7
a260 7
			if ((mode & 2)
			 && (fd = SP->_mouse_fd) >= 0
			 && FD_ISSET(fd, &set))
				result |= 2;
			if ((mode & 1)
			 && FD_ISSET(SP->_ifd, &set))
				result |= 1;
d262 3
a264 4
		}
		else
			result = 0;
	}
d266 1
a266 1
	return (result);
@


1.4
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_twait.c,v 1.3 2000/02/06 07:10:51 millert Exp $	*/
d64 1
a64 1
MODULE_ID("$From: lib_twait.c,v 1.36 2000/02/13 01:02:34 tom Exp $")
a245 1
					count++;
@


1.3
log
@ncurses-5.0-20000205
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_twait.c,v 1.2 1999/11/28 17:49:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d64 1
a64 1
MODULE_ID("$From: lib_twait.c,v 1.35 2000/02/06 01:57:16 tom Exp $")
@


1.2
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_twait.c,v 1.1 1999/01/18 19:10:27 millert Exp $	*/
a51 2
# include <stropts.h>
# include <poll.h>
d64 1
a64 1
MODULE_ID("$From: lib_twait.c,v 1.34 1999/10/16 21:25:10 tom Exp $")
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_twait.c,v 1.4 1998/07/23 21:19:45 millert Exp $	*/
d45 4
d66 1
a66 7
#ifdef __BEOS__
/* BeOS select() only works on sockets.  Use the tty hack instead */
#include <socket.h>
#define select check_select
#endif

MODULE_ID("$From: lib_twait.c,v 1.32 1998/06/06 22:44:14 tom Exp $")
d68 1
a68 1
static int _nc_gettime(void)
d70 1
a70 1
	int res;
d74 8
a81 3
	struct timeval t;
	gettimeofday(&t, (struct timezone *)0);
	res = t.tv_sec*1000 + t.tv_usec/1000;
d84 6
a89 1
	res = time(0)*1000;
d91 1
a91 1
	T(("time: %d msec", res));
d117 1
d122 1
a122 1
int starttime, returntime;
d129 1
a129 1
	starttime = _nc_gettime();
d147 34
d208 1
a208 1
	returntime = _nc_gettime();
d211 1
a211 1
		milliseconds -= returntime-starttime;
d251 2
@

