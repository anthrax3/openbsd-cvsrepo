head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.28
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.24
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.26
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.18
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.22
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.20
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.12
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.18
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.16
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.14
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.12
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.10
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.8
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.6
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.4
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.8
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.17.04.34.50;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.22.18.02.00;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.08.22.47.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.10.03.06.16;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.19.03.53.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.10.01.35.05;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.02.22.06.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.11.28.17.49.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.06.27.08.14.21;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.02.11.00.09.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.26;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
**	lib_mvcur.c
**
**	The routines for moving the physical cursor and scrolling:
**
**		void _nc_mvcur_init(void)
**
**		void _nc_mvcur_resume(void)
**
**		int mvcur(int old_y, int old_x, int new_y, int new_x)
**
**		void _nc_mvcur_wrap(void)
**
** Comparisons with older movement optimizers:
**    SVr3 curses mvcur() can't use cursor_to_ll or auto_left_margin.
**    4.4BSD curses can't use cuu/cud/cuf/cub/hpa/vpa/tab/cbt for local
** motions.  It doesn't use tactics based on auto_left_margin.  Weirdly
** enough, it doesn't use its own hardware-scrolling routine to scroll up
** destination lines for out-of-bounds addresses!
**    old ncurses optimizer: less accurate cost computations (in fact,
** it was broken and had to be commented out!).
**
** Compile with -DMAIN to build an interactive tester/timer for the movement
** optimizer.  You can use it to investigate the optimizer's behavior.
** You can also use it for tuning the formulas used to determine whether
** or not full optimization is attempted.
**
** This code has a nasty tendency to find bugs in terminfo entries, because it
** exercises the non-cup movement capabilities heavily.  If you think you've
** found a bug, try deleting subsets of the following capabilities (arranged
** in decreasing order of suspiciousness): it, tab, cbt, hpa, vpa, cuu, cud,
** cuf, cub, cuu1, cud1, cuf1, cub1.  It may be that one or more are wrong.
**
** Note: you should expect this code to look like a resource hog in a profile.
** That's because it does a lot of I/O, through the tputs() calls.  The I/O
** cost swamps the computation overhead (and as machines get faster, this
** will become even more true).  Comments in the test exerciser at the end
** go into detail about tuning and how you can gauge the optimizer's
** effectiveness.
**/

/****************************************************************************
 *
 * Constants and macros for optimizer tuning.
 *
 ****************************************************************************/

/*
 * The average overhead of a full optimization computation in character
 * transmission times.  If it's too high, the algorithm will be a bit
 * over-biased toward using cup rather than local motions; if it's too
 * low, the algorithm may spend more time than is strictly optimal
 * looking for non-cup motions.  Profile the optimizer using the `t'
 * command of the exerciser (see below), and round to the nearest integer.
 *
 * Yes, I (esr) thought about computing expected overhead dynamically, say
 * by derivation from a running average of optimizer times.  But the
 * whole point of this optimization is to *decrease* the frequency of
 * system calls. :-)
 */
#define COMPUTE_OVERHEAD	1	/* I use a 90MHz Pentium @@ 9.6Kbps */

/*
 * LONG_DIST is the distance we consider to be just as costly to move over as a
 * cup sequence is to emit.  In other words, it's the length of a cup sequence
 * adjusted for average computation overhead.  The magic number is the length
 * of "\033[yy;xxH", the typical cup sequence these days.
 */
#define LONG_DIST		(8 - COMPUTE_OVERHEAD)

/*
 * Tell whether a motion is optimizable by local motions.  Needs to be cheap to
 * compute. In general, all the fast moves go to either the right or left edge
 * of the screen.  So any motion to a location that is (a) further away than
 * LONG_DIST and (b) further inward from the right or left edge than LONG_DIST,
 * we'll consider nonlocal.
 */
#define NOT_LOCAL(fy, fx, ty, tx)	((tx > LONG_DIST) \
 		 && (tx < screen_columns - 1 - LONG_DIST) \
		 && (abs(ty-fy) + abs(tx-fx) > LONG_DIST))

/****************************************************************************
 *
 * External interfaces
 *
 ****************************************************************************/

/*
 * For this code to work OK, the following components must live in the
 * screen structure:
 *
 *	int		_char_padding;	// cost of character put
 *	int		_cr_cost;	// cost of (carriage_return)
 *	int		_cup_cost;	// cost of (cursor_address)
 *	int		_home_cost;	// cost of (cursor_home)
 *	int		_ll_cost;	// cost of (cursor_to_ll)
 *#if USE_HARD_TABS
 *	int		_ht_cost;	// cost of (tab)
 *	int		_cbt_cost;	// cost of (back_tab)
 *#endif USE_HARD_TABS
 *	int		_cub1_cost;	// cost of (cursor_left)
 *	int		_cuf1_cost;	// cost of (cursor_right)
 *	int		_cud1_cost;	// cost of (cursor_down)
 *	int		_cuu1_cost;	// cost of (cursor_up)
 *	int		_cub_cost;	// cost of (parm_cursor_left)
 *	int		_cuf_cost;	// cost of (parm_cursor_right)
 *	int		_cud_cost;	// cost of (parm_cursor_down)
 *	int		_cuu_cost;	// cost of (parm_cursor_up)
 *	int		_hpa_cost;	// cost of (column_address)
 *	int		_vpa_cost;	// cost of (row_address)
 *	int		_ech_cost;	// cost of (erase_chars)
 *	int		_rep_cost;	// cost of (repeat_char)
 *
 * The USE_HARD_TABS switch controls whether it is reliable to use tab/backtabs
 * for local motions.  On many systems, it's not, due to uncertainties about
 * tab delays and whether or not tabs will be expanded in raw mode.  If you
 * have parm_right_cursor, tab motions don't win you a lot anyhow.
 */

#include <curses.priv.h>
#include <term.h>
#include <ctype.h>

MODULE_ID("$Id: lib_mvcur.c,v 1.113 2008/08/16 19:30:58 tom Exp $")

#define WANT_CHAR(y, x)	SP->_newscr->_line[y].text[x]	/* desired state */
#define BAUDRATE	cur_term->_baudrate	/* bits per second */

#if defined(MAIN) || defined(NCURSES_TEST)
#include <sys/time.h>

static bool profiling = FALSE;
static float diff;
#endif /* MAIN */

#define OPT_SIZE 512

static int normalized_cost(const char *const cap, int affcnt);

/****************************************************************************
 *
 * Initialization/wrapup (including cost pre-computation)
 *
 ****************************************************************************/

#ifdef TRACE
static int
trace_cost_of(const char *capname, const char *cap, int affcnt)
{
    int result = _nc_msec_cost(cap, affcnt);
    TR(TRACE_CHARPUT | TRACE_MOVE,
       ("CostOf %s %d %s", capname, result, _nc_visbuf(cap)));
    return result;
}
#define CostOf(cap,affcnt) trace_cost_of(#cap,cap,affcnt);

static int
trace_normalized_cost(const char *capname, const char *cap, int affcnt)
{
    int result = normalized_cost(cap, affcnt);
    TR(TRACE_CHARPUT | TRACE_MOVE,
       ("NormalizedCost %s %d %s", capname, result, _nc_visbuf(cap)));
    return result;
}
#define NormalizedCost(cap,affcnt) trace_normalized_cost(#cap,cap,affcnt);

#else

#define CostOf(cap,affcnt) _nc_msec_cost(cap,affcnt);
#define NormalizedCost(cap,affcnt) normalized_cost(cap,affcnt);

#endif

NCURSES_EXPORT(int)
_nc_msec_cost(const char *const cap, int affcnt)
/* compute the cost of a given operation */
{
    if (cap == 0)
	return (INFINITY);
    else {
	const char *cp;
	float cum_cost = 0.0;

	for (cp = cap; *cp; cp++) {
	    /* extract padding, either mandatory or required */
	    if (cp[0] == '$' && cp[1] == '<' && strchr(cp, '>')) {
		float number = 0.0;

		for (cp += 2; *cp != '>'; cp++) {
		    if (isdigit(UChar(*cp)))
			number = number * 10 + (*cp - '0');
		    else if (*cp == '*')
			number *= affcnt;
		    else if (*cp == '.' && (*++cp != '>') && isdigit(UChar(*cp)))
			number += (*cp - '0') / 10.0;
		}

#if NCURSES_NO_PADDING
		if (!GetNoPadding(SP))
#endif
		    cum_cost += number * 10;
	    } else
		cum_cost += SP->_char_padding;
	}

	return ((int) cum_cost);
    }
}

static int
normalized_cost(const char *const cap, int affcnt)
/* compute the effective character-count for an operation (round up) */
{
    int cost = _nc_msec_cost(cap, affcnt);
    if (cost != INFINITY)
	cost = (cost + SP->_char_padding - 1) / SP->_char_padding;
    return cost;
}

static void
reset_scroll_region(void)
/* Set the scroll-region to a known state (the default) */
{
    if (change_scroll_region) {
	TPUTS_TRACE("change_scroll_region");
	putp(TPARM_2(change_scroll_region, 0, screen_lines - 1));
    }
}

NCURSES_EXPORT(void)
_nc_mvcur_resume(void)
/* what to do at initialization time and after each shellout */
{
    /* initialize screen for cursor access */
    if (enter_ca_mode) {
	TPUTS_TRACE("enter_ca_mode");
	putp(enter_ca_mode);
    }

    /*
     * Doing this here rather than in _nc_mvcur_wrap() ensures that
     * ncurses programs will see a reset scroll region even if a
     * program that messed with it died ungracefully.
     *
     * This also undoes the effects of terminal init strings that assume
     * they know the screen size.  This is useful when you're running
     * a vt100 emulation through xterm.
     */
    reset_scroll_region();
    SP->_cursrow = SP->_curscol = -1;

    /* restore cursor shape */
    if (SP->_cursor != -1) {
	int cursor = SP->_cursor;
	SP->_cursor = -1;
	curs_set(cursor);
    }
}

NCURSES_EXPORT(void)
_nc_mvcur_init(void)
/* initialize the cost structure */
{
    if (isatty(fileno(SP->_ofp)))
	SP->_char_padding = ((BAUDBYTE * 1000 * 10)
			     / (BAUDRATE > 0 ? BAUDRATE : 9600));
    else
	SP->_char_padding = 1;	/* must be nonzero */
    if (SP->_char_padding <= 0)
	SP->_char_padding = 1;	/* must be nonzero */
    TR(TRACE_CHARPUT | TRACE_MOVE, ("char_padding %d msecs", SP->_char_padding));

    /* non-parameterized local-motion strings */
    SP->_cr_cost = CostOf(carriage_return, 0);
    SP->_home_cost = CostOf(cursor_home, 0);
    SP->_ll_cost = CostOf(cursor_to_ll, 0);
#if USE_HARD_TABS
    if (getenv("NCURSES_NO_HARD_TABS") == 0) {
	SP->_ht_cost = CostOf(tab, 0);
	SP->_cbt_cost = CostOf(back_tab, 0);
    } else {
	SP->_ht_cost = INFINITY;
	SP->_cbt_cost = INFINITY;
    }
#endif /* USE_HARD_TABS */
    SP->_cub1_cost = CostOf(cursor_left, 0);
    SP->_cuf1_cost = CostOf(cursor_right, 0);
    SP->_cud1_cost = CostOf(cursor_down, 0);
    SP->_cuu1_cost = CostOf(cursor_up, 0);

    SP->_smir_cost = CostOf(enter_insert_mode, 0);
    SP->_rmir_cost = CostOf(exit_insert_mode, 0);
    SP->_ip_cost = 0;
    if (insert_padding) {
	SP->_ip_cost = CostOf(insert_padding, 0);
    }

    /*
     * Assumption: if the terminal has memory_relative addressing, the
     * initialization strings or smcup will set single-page mode so we
     * can treat it like absolute screen addressing.  This seems to be true
     * for all cursor_mem_address terminal types in the terminfo database.
     */
    SP->_address_cursor = cursor_address ? cursor_address : cursor_mem_address;

    /*
     * Parametrized local-motion strings.  This static cost computation
     * depends on the following assumptions:
     *
     * (1) They never have * padding.  In the entire master terminfo database
     *     as of March 1995, only the obsolete Zenith Z-100 pc violates this.
     *     (Proportional padding is found mainly in insert, delete and scroll
     *     capabilities).
     *
     * (2) The average case of cup has two two-digit parameters.  Strictly,
     *     the average case for a 24 * 80 screen has ((10*10*(1 + 1)) +
     *     (14*10*(1 + 2)) + (10*70*(2 + 1)) + (14*70*4)) / (24*80) = 3.458
     *     digits of parameters.  On a 25x80 screen the average is 3.6197.
     *     On larger screens the value gets much closer to 4.
     *
     * (3) The average case of cub/cuf/hpa/ech/rep has 2 digits of parameters
     *     (strictly, (((10 * 1) + (70 * 2)) / 80) = 1.8750).
     *
     * (4) The average case of cud/cuu/vpa has 2 digits of parameters
     *     (strictly, (((10 * 1) + (14 * 2)) / 24) = 1.5833).
     *
     * All these averages depend on the assumption that all parameter values
     * are equally probable.
     */
    SP->_cup_cost = CostOf(TPARM_2(SP->_address_cursor, 23, 23), 1);
    SP->_cub_cost = CostOf(TPARM_1(parm_left_cursor, 23), 1);
    SP->_cuf_cost = CostOf(TPARM_1(parm_right_cursor, 23), 1);
    SP->_cud_cost = CostOf(TPARM_1(parm_down_cursor, 23), 1);
    SP->_cuu_cost = CostOf(TPARM_1(parm_up_cursor, 23), 1);
    SP->_hpa_cost = CostOf(TPARM_1(column_address, 23), 1);
    SP->_vpa_cost = CostOf(TPARM_1(row_address, 23), 1);

    /* non-parameterized screen-update strings */
    SP->_ed_cost = NormalizedCost(clr_eos, 1);
    SP->_el_cost = NormalizedCost(clr_eol, 1);
    SP->_el1_cost = NormalizedCost(clr_bol, 1);
    SP->_dch1_cost = NormalizedCost(delete_character, 1);
    SP->_ich1_cost = NormalizedCost(insert_character, 1);

    /*
     * If this is a bce-terminal, we want to bias the choice so we use clr_eol
     * rather than spaces at the end of a line.
     */
    if (back_color_erase)
	SP->_el_cost = 0;

    /* parameterized screen-update strings */
    SP->_dch_cost = NormalizedCost(TPARM_1(parm_dch, 23), 1);
    SP->_ich_cost = NormalizedCost(TPARM_1(parm_ich, 23), 1);
    SP->_ech_cost = NormalizedCost(TPARM_1(erase_chars, 23), 1);
    SP->_rep_cost = NormalizedCost(TPARM_2(repeat_char, ' ', 23), 1);

    SP->_cup_ch_cost = NormalizedCost(TPARM_2(SP->_address_cursor, 23, 23), 1);
    SP->_hpa_ch_cost = NormalizedCost(TPARM_1(column_address, 23), 1);
    SP->_cuf_ch_cost = NormalizedCost(TPARM_1(parm_right_cursor, 23), 1);
    SP->_inline_cost = min(SP->_cup_ch_cost,
			   min(SP->_hpa_ch_cost,
			       SP->_cuf_ch_cost));

    /*
     * If save_cursor is used within enter_ca_mode, we should not use it for
     * scrolling optimization, since the corresponding restore_cursor is not
     * nested on the various terminals (vt100, xterm, etc.) which use this
     * feature.
     */
    if (save_cursor != 0
	&& enter_ca_mode != 0
	&& strstr(enter_ca_mode, save_cursor) != 0) {
	T(("...suppressed sc/rc capability due to conflict with smcup/rmcup"));
	save_cursor = 0;
	restore_cursor = 0;
    }

    /*
     * A different, possibly better way to arrange this would be to set
     * SP->_endwin = TRUE at window initialization time and let this be
     * called by doupdate's return-from-shellout code.
     */
    _nc_mvcur_resume();
}

NCURSES_EXPORT(void)
_nc_mvcur_wrap(void)
/* wrap up cursor-addressing mode */
{
    /* leave cursor at screen bottom */
    mvcur(-1, -1, screen_lines - 1, 0);

    /* set cursor to normal mode */
    if (SP->_cursor != -1) {
	int cursor = SP->_cursor;
	curs_set(1);
	SP->_cursor = cursor;
    }

    if (exit_ca_mode) {
	TPUTS_TRACE("exit_ca_mode");
	putp(exit_ca_mode);
    }
    /*
     * Reset terminal's tab counter.  There's a long-time bug that
     * if you exit a "curses" program such as vi or more, tab
     * forward, and then backspace, the cursor doesn't go to the
     * right place.  The problem is that the kernel counts the
     * escape sequences that reset things as column positions.
     * Utter a \r to reset this invisibly.
     */
    _nc_outch('\r');
}

/****************************************************************************
 *
 * Optimized cursor movement
 *
 ****************************************************************************/

/*
 * Perform repeated-append, returning cost
 */
static NCURSES_INLINE int
repeated_append(string_desc * target, int total, int num, int repeat, const char *src)
{
    size_t need = repeat * strlen(src);

    if (need < target->s_size) {
	while (repeat-- > 0) {
	    if (_nc_safe_strcat(target, src)) {
		total += num;
	    } else {
		total = INFINITY;
		break;
	    }
	}
    } else {
	total = INFINITY;
    }
    return total;
}

#ifndef NO_OPTIMIZE
#define NEXTTAB(fr)	(fr + init_tabs - (fr % init_tabs))

/*
 * Assume back_tab (CBT) does not wrap backwards at the left margin, return
 * a negative value at that point to simplify the loop.
 */
#define LASTTAB(fr)	((fr > 0) ? ((fr - 1) / init_tabs) * init_tabs : -1)

static int
relative_move(string_desc * target, int from_y, int from_x, int to_y, int
	      to_x, bool ovw)
/* move via local motions (cuu/cuu1/cud/cud1/cub1/cub/cuf1/cuf/vpa/hpa) */
{
    string_desc save;
    int n, vcost = 0, hcost = 0;

    (void) _nc_str_copy(&save, target);

    if (to_y != from_y) {
	vcost = INFINITY;

	if (row_address != 0
	    && _nc_safe_strcat(target, TPARM_1(row_address, to_y))) {
	    vcost = SP->_vpa_cost;
	}

	if (to_y > from_y) {
	    n = (to_y - from_y);

	    if (parm_down_cursor
		&& SP->_cud_cost < vcost
		&& _nc_safe_strcat(_nc_str_copy(target, &save),
				   TPARM_1(parm_down_cursor, n))) {
		vcost = SP->_cud_cost;
	    }

	    if (cursor_down
		&& (*cursor_down != '\n' || SP->_nl)
		&& (n * SP->_cud1_cost < vcost)) {
		vcost = repeated_append(_nc_str_copy(target, &save), 0,
					SP->_cud1_cost, n, cursor_down);
	    }
	} else {		/* (to_y < from_y) */
	    n = (from_y - to_y);

	    if (parm_up_cursor
		&& SP->_cuu_cost < vcost
		&& _nc_safe_strcat(_nc_str_copy(target, &save),
				   TPARM_1(parm_up_cursor, n))) {
		vcost = SP->_cuu_cost;
	    }

	    if (cursor_up && (n * SP->_cuu1_cost < vcost)) {
		vcost = repeated_append(_nc_str_copy(target, &save), 0,
					SP->_cuu1_cost, n, cursor_up);
	    }
	}

	if (vcost == INFINITY)
	    return (INFINITY);
    }

    save = *target;

    if (to_x != from_x) {
	char str[OPT_SIZE];
	string_desc check;

	hcost = INFINITY;

	if (column_address
	    && _nc_safe_strcat(_nc_str_copy(target, &save),
			       TPARM_1(column_address, to_x))) {
	    hcost = SP->_hpa_cost;
	}

	if (to_x > from_x) {
	    n = to_x - from_x;

	    if (parm_right_cursor
		&& SP->_cuf_cost < hcost
		&& _nc_safe_strcat(_nc_str_copy(target, &save),
				   TPARM_1(parm_right_cursor, n))) {
		hcost = SP->_cuf_cost;
	    }

	    if (cursor_right) {
		int lhcost = 0;

		(void) _nc_str_init(&check, str, sizeof(str));

#if USE_HARD_TABS
		/* use hard tabs, if we have them, to do as much as possible */
		if (init_tabs > 0 && tab) {
		    int nxt, fr;

		    for (fr = from_x; (nxt = NEXTTAB(fr)) <= to_x; fr = nxt) {
			lhcost = repeated_append(&check, lhcost,
						 SP->_ht_cost, 1, tab);
			if (lhcost == INFINITY)
			    break;
		    }

		    n = to_x - fr;
		    from_x = fr;
		}
#endif /* USE_HARD_TABS */

		if (n <= 0 || n >= (int) check.s_size)
		    ovw = FALSE;
#if BSD_TPUTS
		/*
		 * If we're allowing BSD-style padding in tputs, don't generate
		 * a string with a leading digit.  Otherwise, that will be
		 * interpreted as a padding value rather than sent to the
		 * screen.
		 */
		if (ovw
		    && n > 0
		    && n < (int) check.s_size
		    && vcost == 0
		    && str[0] == '\0') {
		    int wanted = CharOf(WANT_CHAR(to_y, from_x));
		    if (is8bits(wanted) && isdigit(wanted))
			ovw = FALSE;
		}
#endif
		/*
		 * If we have no attribute changes, overwrite is cheaper.
		 * Note: must suppress this by passing in ovw = FALSE whenever
		 * WANT_CHAR would return invalid data.  In particular, this
		 * is true between the time a hardware scroll has been done
		 * and the time the structure WANT_CHAR would access has been
		 * updated.
		 */
		if (ovw) {
		    int i;

		    for (i = 0; i < n; i++) {
			NCURSES_CH_T ch = WANT_CHAR(to_y, from_x + i);
			if (!SameAttrOf(ch, SCREEN_ATTRS(SP))
#if USE_WIDEC_SUPPORT
			    || !Charable(ch)
#endif
			    ) {
			    ovw = FALSE;
			    break;
			}
		    }
		}
		if (ovw) {
		    int i;

		    for (i = 0; i < n; i++)
			*check.s_tail++ = (char) CharOf(WANT_CHAR(to_y,
								  from_x + i));
		    *check.s_tail = '\0';
		    check.s_size -= n;
		    lhcost += n * SP->_char_padding;
		} else {
		    lhcost = repeated_append(&check, lhcost, SP->_cuf1_cost,
					     n, cursor_right);
		}

		if (lhcost < hcost
		    && _nc_safe_strcat(_nc_str_copy(target, &save), str)) {
		    hcost = lhcost;
		}
	    }
	} else {		/* (to_x < from_x) */
	    n = from_x - to_x;

	    if (parm_left_cursor
		&& SP->_cub_cost < hcost
		&& _nc_safe_strcat(_nc_str_copy(target, &save),
				   TPARM_1(parm_left_cursor, n))) {
		hcost = SP->_cub_cost;
	    }

	    if (cursor_left) {
		int lhcost = 0;

		(void) _nc_str_init(&check, str, sizeof(str));

#if USE_HARD_TABS
		if (init_tabs > 0 && back_tab) {
		    int nxt, fr;

		    for (fr = from_x; (nxt = LASTTAB(fr)) >= to_x; fr = nxt) {
			lhcost = repeated_append(&check, lhcost,
						 SP->_cbt_cost, 1, back_tab);
			if (lhcost == INFINITY)
			    break;
		    }

		    n = fr - to_x;
		}
#endif /* USE_HARD_TABS */

		lhcost = repeated_append(&check, lhcost, SP->_cub1_cost, n, cursor_left);

		if (lhcost < hcost
		    && _nc_safe_strcat(_nc_str_copy(target, &save), str)) {
		    hcost = lhcost;
		}
	    }
	}

	if (hcost == INFINITY)
	    return (INFINITY);
    }

    return (vcost + hcost);
}
#endif /* !NO_OPTIMIZE */

/*
 * With the machinery set up above, it's conceivable that
 * onscreen_mvcur could be modified into a recursive function that does
 * an alpha-beta search of motion space, as though it were a chess
 * move tree, with the weight function being boolean and the search
 * depth equated to length of string.  However, this would jack up the
 * computation cost a lot, especially on terminals without a cup
 * capability constraining the search tree depth.  So we settle for
 * the simpler method below.
 */

static NCURSES_INLINE int
onscreen_mvcur(int yold, int xold, int ynew, int xnew, bool ovw)
/* onscreen move from (yold, xold) to (ynew, xnew) */
{
    string_desc result;
    char buffer[OPT_SIZE];
    int tactic = 0, newcost, usecost = INFINITY;
    int t5_cr_cost;

#if defined(MAIN) || defined(NCURSES_TEST)
    struct timeval before, after;

    gettimeofday(&before, NULL);
#endif /* MAIN */

#define NullResult _nc_str_null(&result, sizeof(buffer))
#define InitResult _nc_str_init(&result, buffer, sizeof(buffer))

    /* tactic #0: use direct cursor addressing */
    if (_nc_safe_strcpy(InitResult, TPARM_2(SP->_address_cursor, ynew, xnew))) {
	tactic = 0;
	usecost = SP->_cup_cost;

#if defined(TRACE) || defined(NCURSES_TEST)
	if (!(_nc_optimize_enable & OPTIMIZE_MVCUR))
	    goto nonlocal;
#endif /* TRACE */

	/*
	 * We may be able to tell in advance that the full optimization
	 * will probably not be worth its overhead.  Also, don't try to
	 * use local movement if the current attribute is anything but
	 * A_NORMAL...there are just too many ways this can screw up
	 * (like, say, local-movement \n getting mapped to some obscure
	 * character because A_ALTCHARSET is on).
	 */
	if (yold == -1 || xold == -1 || NOT_LOCAL(yold, xold, ynew, xnew)) {
#if defined(MAIN) || defined(NCURSES_TEST)
	    if (!profiling) {
		(void) fputs("nonlocal\n", stderr);
		goto nonlocal;	/* always run the optimizer if profiling */
	    }
#else
	    goto nonlocal;
#endif /* MAIN */
	}
    }
#ifndef NO_OPTIMIZE
    /* tactic #1: use local movement */
    if (yold != -1 && xold != -1
	&& ((newcost = relative_move(NullResult, yold, xold, ynew, xnew,
				     ovw)) != INFINITY)
	&& newcost < usecost) {
	tactic = 1;
	usecost = newcost;
    }

    /* tactic #2: use carriage-return + local movement */
    if (yold != -1 && carriage_return
	&& ((newcost = relative_move(NullResult, yold, 0, ynew, xnew, ovw))
	    != INFINITY)
	&& SP->_cr_cost + newcost < usecost) {
	tactic = 2;
	usecost = SP->_cr_cost + newcost;
    }

    /* tactic #3: use home-cursor + local movement */
    if (cursor_home
	&& ((newcost = relative_move(NullResult, 0, 0, ynew, xnew, ovw)) != INFINITY)
	&& SP->_home_cost + newcost < usecost) {
	tactic = 3;
	usecost = SP->_home_cost + newcost;
    }

    /* tactic #4: use home-down + local movement */
    if (cursor_to_ll
	&& ((newcost = relative_move(NullResult, screen_lines - 1, 0, ynew,
				     xnew, ovw)) != INFINITY)
	&& SP->_ll_cost + newcost < usecost) {
	tactic = 4;
	usecost = SP->_ll_cost + newcost;
    }

    /*
     * tactic #5: use left margin for wrap to right-hand side,
     * unless strange wrap behavior indicated by xenl might hose us.
     */
    t5_cr_cost = (xold > 0 ? SP->_cr_cost : 0);
    if (auto_left_margin && !eat_newline_glitch
	&& yold > 0 && cursor_left
	&& ((newcost = relative_move(NullResult, yold - 1, screen_columns -
				     1, ynew, xnew, ovw)) != INFINITY)
	&& t5_cr_cost + SP->_cub1_cost + newcost < usecost) {
	tactic = 5;
	usecost = t5_cr_cost + SP->_cub1_cost + newcost;
    }

    /*
     * These cases are ordered by estimated relative frequency.
     */
    if (tactic)
	InitResult;
    switch (tactic) {
    case 1:
	(void) relative_move(&result, yold, xold, ynew, xnew, ovw);
	break;
    case 2:
	(void) _nc_safe_strcpy(&result, carriage_return);
	(void) relative_move(&result, yold, 0, ynew, xnew, ovw);
	break;
    case 3:
	(void) _nc_safe_strcpy(&result, cursor_home);
	(void) relative_move(&result, 0, 0, ynew, xnew, ovw);
	break;
    case 4:
	(void) _nc_safe_strcpy(&result, cursor_to_ll);
	(void) relative_move(&result, screen_lines - 1, 0, ynew, xnew, ovw);
	break;
    case 5:
	if (xold > 0)
	    (void) _nc_safe_strcat(&result, carriage_return);
	(void) _nc_safe_strcat(&result, cursor_left);
	(void) relative_move(&result, yold - 1, screen_columns - 1, ynew,
			     xnew, ovw);
	break;
    }
#endif /* !NO_OPTIMIZE */

  nonlocal:
#if defined(MAIN) || defined(NCURSES_TEST)
    gettimeofday(&after, NULL);
    diff = after.tv_usec - before.tv_usec
	+ (after.tv_sec - before.tv_sec) * 1000000;
    if (!profiling)
	(void) fprintf(stderr,
		       "onscreen: %d microsec, %f 28.8Kbps char-equivalents\n",
		       (int) diff, diff / 288);
#endif /* MAIN */

    if (usecost != INFINITY) {
	TPUTS_TRACE("mvcur");
	tputs(buffer, 1, _nc_outch);
	SP->_cursrow = ynew;
	SP->_curscol = xnew;
	return (OK);
    } else
	return (ERR);
}

NCURSES_EXPORT(int)
mvcur(int yold, int xold, int ynew, int xnew)
/* optimized cursor move from (yold, xold) to (ynew, xnew) */
{
    NCURSES_CH_T oldattr;
    int code;

    TR(TRACE_CALLS | TRACE_MOVE, (T_CALLED("mvcur(%d,%d,%d,%d)"),
				  yold, xold, ynew, xnew));

    if (SP == 0) {
	code = ERR;
    } else if (yold == ynew && xold == xnew) {
	code = OK;
    } else {

	/*
	 * Most work here is rounding for terminal boundaries getting the
	 * column position implied by wraparound or the lack thereof and
	 * rolling up the screen to get ynew on the screen.
	 */
	if (xnew >= screen_columns) {
	    ynew += xnew / screen_columns;
	    xnew %= screen_columns;
	}

	/*
	 * Force restore even if msgr is on when we're in an alternate
	 * character set -- these have a strong tendency to screw up the CR &
	 * LF used for local character motions!
	 */
	oldattr = SCREEN_ATTRS(SP);
	if ((AttrOf(oldattr) & A_ALTCHARSET)
	    || (AttrOf(oldattr) && !move_standout_mode)) {
	    TR(TRACE_CHARPUT, ("turning off (%#lx) %s before move",
			       (unsigned long) AttrOf(oldattr),
			       _traceattr(AttrOf(oldattr))));
	    (void) VIDATTR(A_NORMAL, 0);
	}

	if (xold >= screen_columns) {
	    int l;

	    if (SP->_nl) {
		l = (xold + 1) / screen_columns;
		yold += l;
		if (yold >= screen_lines)
		    l -= (yold - screen_lines - 1);

		if (l > 0) {
		    if (carriage_return) {
			TPUTS_TRACE("carriage_return");
			putp(carriage_return);
		    } else
			_nc_outch('\r');
		    xold = 0;

		    while (l > 0) {
			if (newline) {
			    TPUTS_TRACE("newline");
			    putp(newline);
			} else
			    _nc_outch('\n');
			l--;
		    }
		}
	    } else {
		/*
		 * If caller set nonl(), we cannot really use newlines to
		 * position to the next row.
		 */
		xold = -1;
		yold = -1;
	    }
	}

	if (yold > screen_lines - 1)
	    yold = screen_lines - 1;
	if (ynew > screen_lines - 1)
	    ynew = screen_lines - 1;

	/* destination location is on screen now */
	code = onscreen_mvcur(yold, xold, ynew, xnew, TRUE);

	/*
	 * Restore attributes if we disabled them before moving.
	 */
	if (!SameAttrOf(oldattr, SCREEN_ATTRS(SP))) {
	    TR(TRACE_CHARPUT, ("turning on (%#lx) %s after move",
			       (unsigned long) AttrOf(oldattr),
			       _traceattr(AttrOf(oldattr))));
	    (void) VIDATTR(AttrOf(oldattr), GetPair(oldattr));
	}
    }
    returnCode(code);
}

#if defined(TRACE) || defined(NCURSES_TEST)
NCURSES_EXPORT_VAR(int) _nc_optimize_enable = OPTIMIZE_ALL;
#endif

#if defined(MAIN) || defined(NCURSES_TEST)
/****************************************************************************
 *
 * Movement optimizer test code
 *
 ****************************************************************************/

#include <tic.h>
#include <dump_entry.h>
#include <time.h>

NCURSES_EXPORT_VAR(const char *) _nc_progname = "mvcur";

static unsigned long xmits;

/* these override lib_tputs.c */
NCURSES_EXPORT(int)
tputs(const char *string, int affcnt GCC_UNUSED, int (*outc) (int) GCC_UNUSED)
/* stub tputs() that dumps sequences in a visible form */
{
    if (profiling)
	xmits += strlen(string);
    else
	(void) fputs(_nc_visbuf(string), stdout);
    return (OK);
}

NCURSES_EXPORT(int)
putp(const char *string)
{
    return (tputs(string, 1, _nc_outch));
}

NCURSES_EXPORT(int)
_nc_outch(int ch)
{
    putc(ch, stdout);
    return OK;
}

NCURSES_EXPORT(int)
delay_output(int ms GCC_UNUSED)
{
    return OK;
}

static char tname[PATH_MAX];

static void
load_term(void)
{
    (void) setupterm(tname, STDOUT_FILENO, NULL);
}

static int
roll(int n)
{
    int i, j;

    i = (RAND_MAX / n) * n;
    while ((j = rand()) >= i)
	continue;
    return (j % n);
}

int
main(int argc GCC_UNUSED, char *argv[]GCC_UNUSED)
{
    strlcpy(tname, sizeof(tname), getenv("TERM"));
    load_term();
    _nc_setupscreen(lines, columns, stdout, FALSE, 0);
    baudrate();

    _nc_mvcur_init();
    NC_BUFFERED(FALSE);

    (void) puts("The mvcur tester.  Type ? for help");

    fputs("smcup:", stdout);
    putchar('\n');

    for (;;) {
	int fy, fx, ty, tx, n, i;
	char buf[BUFSIZ], capname[BUFSIZ];

	(void) fputs("> ", stdout);
	if (fgets(buf, sizeof(buf), stdin) == NULL) {
		if (ferror(stdin))
			fputs("ferror on stdin", stderr);
		break;
	}

	if (buf[0] == '?') {
	    (void) puts("?                -- display this help message");
	    (void)
		puts("fy fx ty tx      -- (4 numbers) display (fy,fx)->(ty,tx) move");
	    (void) puts("s[croll] n t b m -- display scrolling sequence");
	    (void)
		printf("r[eload]         -- reload terminal info for %s\n",
		       termname());
	    (void)
		puts("l[oad] <term>    -- load terminal info for type <term>");
	    (void) puts("d[elete] <cap>   -- delete named capability");
	    (void) puts("i[nspect]        -- display terminal capabilities");
	    (void)
		puts("c[ost]           -- dump cursor-optimization cost table");
	    (void) puts("o[optimize]      -- toggle movement optimization");
	    (void)
		puts("t[orture] <num>  -- torture-test with <num> random moves");
	    (void) puts("q[uit]           -- quit the program");
	} else if (sscanf(buf, "%d %d %d %d", &fy, &fx, &ty, &tx) == 4) {
	    struct timeval before, after;

	    putchar('"');

	    gettimeofday(&before, NULL);
	    mvcur(fy, fx, ty, tx);
	    gettimeofday(&after, NULL);

	    printf("\" (%ld msec)\n",
		   (long) (after.tv_usec - before.tv_usec
			   + (after.tv_sec - before.tv_sec)
			   * 1000000));
	} else if (sscanf(buf, "s %d %d %d %d", &fy, &fx, &ty, &tx) == 4) {
	    struct timeval before, after;

	    putchar('"');

	    gettimeofday(&before, NULL);
	    _nc_scrolln(fy, fx, ty, tx);
	    gettimeofday(&after, NULL);

	    printf("\" (%ld msec)\n",
		   (long) (after.tv_usec - before.tv_usec + (after.tv_sec -
							     before.tv_sec)
			   * 1000000));
	} else if (buf[0] == 'r') {
	    (void) strlcpy(tname, sizeof(tname), termname());
	    load_term();
	} else if (sscanf(buf, "l %s", tname) == 1) {
	    load_term();
	} else if (sscanf(buf, "d %s", capname) == 1) {
	    struct name_table_entry const *np = _nc_find_entry(capname,
							       _nc_get_hash_table(FALSE));

	    if (np == NULL)
		(void) printf("No such capability as \"%s\"\n", capname);
	    else {
		switch (np->nte_type) {
		case BOOLEAN:
		    cur_term->type.Booleans[np->nte_index] = FALSE;
		    (void)
			printf("Boolean capability `%s' (%d) turned off.\n",
			       np->nte_name, np->nte_index);
		    break;

		case NUMBER:
		    cur_term->type.Numbers[np->nte_index] = ABSENT_NUMERIC;
		    (void) printf("Number capability `%s' (%d) set to -1.\n",
				  np->nte_name, np->nte_index);
		    break;

		case STRING:
		    cur_term->type.Strings[np->nte_index] = ABSENT_STRING;
		    (void) printf("String capability `%s' (%d) deleted.\n",
				  np->nte_name, np->nte_index);
		    break;
		}
	    }
	} else if (buf[0] == 'i') {
	    dump_init((char *) NULL, F_TERMINFO, S_TERMINFO, 70, 0, FALSE);
	    dump_entry(&cur_term->type, FALSE, TRUE, 0, 0);
	    putchar('\n');
	} else if (buf[0] == 'o') {
	    if (_nc_optimize_enable & OPTIMIZE_MVCUR) {
		_nc_optimize_enable &= ~OPTIMIZE_MVCUR;
		(void) puts("Optimization is now off.");
	    } else {
		_nc_optimize_enable |= OPTIMIZE_MVCUR;
		(void) puts("Optimization is now on.");
	    }
	}
	/*
	 * You can use the `t' test to profile and tune the movement
	 * optimizer.  Use iteration values in three digits or more.
	 * At above 5000 iterations the profile timing averages are stable
	 * to within a millisecond or three.
	 *
	 * The `overhead' field of the report will help you pick a
	 * COMPUTE_OVERHEAD figure appropriate for your processor and
	 * expected line speed.  The `total estimated time' is
	 * computation time plus a character-transmission time
	 * estimate computed from the number of transmits and the baud
	 * rate.
	 *
	 * Use this together with the `o' command to get a read on the
	 * optimizer's effectiveness.  Compare the total estimated times
	 * for `t' runs of the same length in both optimized and un-optimized
	 * modes.  As long as the optimized times are less, the optimizer
	 * is winning.
	 */
	else if (sscanf(buf, "t %d", &n) == 1) {
	    float cumtime = 0.0, perchar;
	    int speeds[] =
	    {2400, 9600, 14400, 19200, 28800, 38400, 0};

	    srand((unsigned) (getpid() + time((time_t *) 0)));
	    profiling = TRUE;
	    xmits = 0;
	    for (i = 0; i < n; i++) {
		/*
		 * This does a move test between two random locations,
		 * Random moves probably short-change the optimizer,
		 * which will work better on the short moves probably
		 * typical of doupdate()'s usage pattern.  Still,
		 * until we have better data...
		 */
#ifdef FIND_COREDUMP
		int from_y = roll(lines);
		int to_y = roll(lines);
		int from_x = roll(columns);
		int to_x = roll(columns);

		printf("(%d,%d) -> (%d,%d)\n", from_y, from_x, to_y, to_x);
		mvcur(from_y, from_x, to_y, to_x);
#else
		mvcur(roll(lines), roll(columns), roll(lines), roll(columns));
#endif /* FIND_COREDUMP */
		if (diff)
		    cumtime += diff;
	    }
	    profiling = FALSE;

	    /*
	     * Average milliseconds per character optimization time.
	     * This is the key figure to watch when tuning the optimizer.
	     */
	    perchar = cumtime / n;

	    (void) printf("%d moves (%ld chars) in %d msec, %f msec each:\n",
			  n, xmits, (int) cumtime, perchar);

	    for (i = 0; speeds[i]; i++) {
		/*
		 * Total estimated time for the moves, computation and
		 * transmission both. Transmission time is an estimate
		 * assuming 9 bits/char, 8 bits + 1 stop bit.
		 */
		float totalest = cumtime + xmits * 9 * 1e6 / speeds[i];

		/*
		 * Per-character optimization overhead in character transmits
		 * at the current speed.  Round this to the nearest integer
		 * to figure COMPUTE_OVERHEAD for the speed.
		 */
		float overhead = speeds[i] * perchar / 1e6;

		(void)
		    printf("%6d bps: %3.2f char-xmits overhead; total estimated time %15.2f\n",
			   speeds[i], overhead, totalest);
	    }
	} else if (buf[0] == 'c') {
	    (void) printf("char padding: %d\n", SP->_char_padding);
	    (void) printf("cr cost: %d\n", SP->_cr_cost);
	    (void) printf("cup cost: %d\n", SP->_cup_cost);
	    (void) printf("home cost: %d\n", SP->_home_cost);
	    (void) printf("ll cost: %d\n", SP->_ll_cost);
#if USE_HARD_TABS
	    (void) printf("ht cost: %d\n", SP->_ht_cost);
	    (void) printf("cbt cost: %d\n", SP->_cbt_cost);
#endif /* USE_HARD_TABS */
	    (void) printf("cub1 cost: %d\n", SP->_cub1_cost);
	    (void) printf("cuf1 cost: %d\n", SP->_cuf1_cost);
	    (void) printf("cud1 cost: %d\n", SP->_cud1_cost);
	    (void) printf("cuu1 cost: %d\n", SP->_cuu1_cost);
	    (void) printf("cub cost: %d\n", SP->_cub_cost);
	    (void) printf("cuf cost: %d\n", SP->_cuf_cost);
	    (void) printf("cud cost: %d\n", SP->_cud_cost);
	    (void) printf("cuu cost: %d\n", SP->_cuu_cost);
	    (void) printf("hpa cost: %d\n", SP->_hpa_cost);
	    (void) printf("vpa cost: %d\n", SP->_vpa_cost);
	} else if (buf[0] == 'x' || buf[0] == 'q')
	    break;
	else
	    (void) puts("Invalid command.");
    }

    (void) fputs("rmcup:", stdout);
    _nc_mvcur_wrap();
    putchar('\n');

    return (0);
}

#endif /* MAIN */

/* lib_mvcur.c ends here */
@


1.12
log
@Check fgets return value, from Charles Longeau.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.11 2003/03/18 16:55:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d114 3
a116 1
#define NOT_LOCAL(fy, fx, ty, tx)	((tx > LONG_DIST) && (tx < screen_lines - 1 - LONG_DIST) && (abs(ty-fy) + abs(tx-fx) > LONG_DIST))
d160 1
a160 1
MODULE_ID("$From: lib_mvcur.c,v 1.77 2000/12/10 03:04:30 tom Exp $")
a161 4
#define CURRENT_ROW	SP->_cursrow	/* phys cursor row */
#define CURRENT_COLUMN	SP->_curscol	/* phys cursor column */
#define CURRENT_ATTR	SP->_current_attr	/* current phys attribute */
#define REAL_ATTR	SP->_current_attr	/* phys current attribute */
d211 1
a211 2
_nc_msec_cost
(const char *const cap, int affcnt)
d226 1
a226 1
		    if (isdigit(CharOf(*cp)))
d230 1
a230 1
		    else if (*cp == '.' && (*++cp != '>') && isdigit(CharOf(*cp)))
d235 1
a235 1
		if (!(SP->_no_padding))
d262 1
a262 1
	putp(tparm(change_scroll_region, 0, screen_lines - 1));
d300 5
a304 4
    /*
     * 9 = 7 bits + 1 parity + 1 stop.
     */
    SP->_char_padding = (9 * 1000 * 10) / (BAUDRATE > 0 ? BAUDRATE : 9600);
d314 7
a320 2
    SP->_ht_cost = CostOf(tab, 0);
    SP->_cbt_cost = CostOf(back_tab, 0);
d366 7
a372 7
    SP->_cup_cost = CostOf(tparm(SP->_address_cursor, 23, 23), 1);
    SP->_cub_cost = CostOf(tparm(parm_left_cursor, 23), 1);
    SP->_cuf_cost = CostOf(tparm(parm_right_cursor, 23), 1);
    SP->_cud_cost = CostOf(tparm(parm_down_cursor, 23), 1);
    SP->_cuu_cost = CostOf(tparm(parm_up_cursor, 23), 1);
    SP->_hpa_cost = CostOf(tparm(column_address, 23), 1);
    SP->_vpa_cost = CostOf(tparm(row_address, 23), 1);
d381 7
d389 8
a396 8
    SP->_dch_cost = NormalizedCost(tparm(parm_dch, 23), 1);
    SP->_ich_cost = NormalizedCost(tparm(parm_ich, 23), 1);
    SP->_ech_cost = NormalizedCost(tparm(erase_chars, 23), 1);
    SP->_rep_cost = NormalizedCost(tparm(repeat_char, ' ', 23), 1);

    SP->_cup_ch_cost = NormalizedCost(tparm(SP->_address_cursor, 23, 23), 1);
    SP->_hpa_ch_cost = NormalizedCost(tparm(column_address, 23), 1);
    SP->_cuf_ch_cost = NormalizedCost(tparm(parm_right_cursor, 23), 1);
d431 2
a432 1
    if (SP->_cursor != -1)
d434 2
d461 1
a461 1
static inline int
d504 1
a504 1
	    && _nc_safe_strcat(target, tparm(row_address, to_y))) {
d514 1
a514 1
				   tparm(parm_down_cursor, n))) {
d518 3
a520 1
	    if (cursor_down && (n * SP->_cud1_cost < vcost)) {
d528 1
a528 1
		&& SP->_cup_cost < vcost
d530 2
a531 2
				   tparm(parm_up_cursor, n))) {
		vcost = SP->_cup_cost;
d554 1
a554 1
			       tparm(column_address, to_x))) {
d564 1
a564 1
				   tparm(parm_right_cursor, n))) {
a589 1
#if defined(REAL_ATTR) && defined(WANT_CHAR)
d603 5
a607 3
		    && str[0] == '\0'
		    && isdigit(TextOf(WANT_CHAR(to_y, from_x))))
		    ovw = FALSE;
d620 7
a626 2
		    for (i = 0; i < n; i++)
			if ((WANT_CHAR(to_y, from_x + i) & A_ATTRIBUTES) != CURRENT_ATTR) {
d630 1
d636 2
a637 1
			*check.s_tail++ = WANT_CHAR(to_y, from_x + i);
d641 1
a641 3
		} else
#endif /* defined(REAL_ATTR) && defined(WANT_CHAR) */
		{
d657 1
a657 1
				   tparm(parm_left_cursor, n))) {
d709 1
a709 1
static inline int
d728 1
a728 1
    if (_nc_safe_strcpy(InitResult, tparm(SP->_address_cursor, ynew, xnew))) {
d837 1
d844 1
a844 1
		       "onscreen: %d msec, %f 28.8Kbps char-equivalents\n",
a847 1
  nonlocal:
d851 2
d859 1
a859 2
mvcur
(int yold, int xold, int ynew, int xnew)
d862 5
a866 1
    TR(TRACE_MOVE, ("mvcur(%d,%d,%d,%d) called", yold, xold, ynew, xnew));
d868 15
a882 2
    if (yold == ynew && xold == xnew)
	return (OK);
d884 13
a896 5
    /*
     * Most work here is rounding for terminal boundaries getting the
     * column position implied by wraparound or the lack thereof and
     * rolling up the screen to get ynew on the screen.
     */
d898 2
a899 6
    if (xnew >= screen_columns) {
	ynew += xnew / screen_columns;
	xnew %= screen_columns;
    }
    if (xold >= screen_columns) {
	int l;
d901 30
a930 19
	l = (xold + 1) / screen_columns;
	yold += l;
	if (yold >= screen_lines)
	    l -= (yold - screen_lines - 1);

	while (l > 0) {
	    if (newline) {
		TPUTS_TRACE("newline");
		tputs(newline, 0, _nc_outch);
	    } else
		putchar('\n');
	    l--;
	    if (xold > 0) {
		if (carriage_return) {
		    TPUTS_TRACE("carriage_return");
		    tputs(carriage_return, 0, _nc_outch);
		} else
		    putchar('\r');
		xold = 0;
a932 1
    }
d934 7
a940 4
    if (yold > screen_lines - 1)
	yold = screen_lines - 1;
    if (ynew > screen_lines - 1)
	ynew = screen_lines - 1;
d942 11
a952 2
    /* destination location is on screen now */
    return (onscreen_mvcur(yold, xold, ynew, xnew, TRUE));
d968 1
d970 1
a970 2
NCURSES_EXPORT_VAR(const char *)
_nc_progname = "mvcur";
d972 1
a972 1
     static unsigned long xmits;
d976 1
a976 2
tputs
(const char *string, int affcnt GCC_UNUSED, int (*outc) (int) GCC_UNUSED)
a998 5
NCURSES_EXPORT_VAR(char) PC = 0;	/* used by termcap library */
NCURSES_EXPORT_VAR(NCURSES_OSPEED) ospeed = 0;	/* used by termcap library */
NCURSES_EXPORT_VAR(int)
_nc_nulls_sent = 0;		/* used by 'tack' program */

d1005 1
a1005 1
static char tname[MAX_ALIAS];
d1027 1
a1027 1
    (void) strlcpy(tname, termname(), sizeof(tname));
d1029 1
a1029 1
    _nc_setupscreen(lines, columns, stdout);
d1046 3
a1048 3
	    if (ferror(stdin))
	    	fputs("ferror on stdin", stderr);
	    break;
d1096 1
a1096 1
	    (void) strlcpy(tname, termname(), sizeof(tname));
d1102 1
a1102 1
							       _nc_info_hash_table);
d1130 1
a1130 1
	    dump_entry(&cur_term->type, FALSE, TRUE, 0);
@


1.11
log
@Use strlcpy() / strlcat() throughout.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.10 2001/01/22 18:02:00 millert Exp $	*/
d985 5
a989 1
	(void) fgets(buf, sizeof(buf), stdin);
@


1.10
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.9 2000/10/08 22:47:04 millert Exp $	*/
d967 1
a967 1
    (void) strcpy(tname, termname());
d1032 1
a1032 1
	    (void) strcpy(tname, termname());
@


1.9
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.8 2000/07/10 03:06:16 millert Exp $	*/
d157 1
a157 1
MODULE_ID("$From: lib_mvcur.c,v 1.72 2000/10/08 00:58:25 tom Exp $")
d211 3
a213 2
int
_nc_msec_cost(const char *const cap, int affcnt)
d228 1
a228 1
		    if (isdigit(*cp))
d232 1
a232 1
		    else if (*cp == '.' && (*++cp != '>') && isdigit(*cp))
d268 1
a268 1
void
d298 1
a298 1
void
d412 1
a412 1
void
d575 2
d834 3
a836 2
int
mvcur(int yold, int xold, int ynew, int xnew)
d890 1
a890 1
int _nc_optimize_enable = OPTIMIZE_ALL;
d903 2
a904 1
const char *_nc_progname = "mvcur";
d906 1
a906 1
static unsigned long xmits;
d909 3
a911 2
int
tputs(const char *string, int affcnt GCC_UNUSED, int (*outc) (int) GCC_UNUSED)
d921 1
a921 1
int
d927 1
a927 1
int
d934 4
a937 3
char PC = 0;			/* used by termcap library */
short ospeed = 0;		/* used by termcap library */
int _nc_nulls_sent = 0;		/* used by 'tack' program */
d939 1
a939 1
int
@


1.8
log
@ncurses 5.1
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.7 2000/06/19 03:53:53 millert Exp $	*/
d157 1
a157 3
MODULE_ID("$From: lib_mvcur.c,v 1.67 2000/06/24 21:13:51 tom Exp $")

#define STRLEN(s)       (s != 0) ? strlen(s) : 0
a176 19
#if !HAVE_STRSTR
char *
_nc_strstr(const char *haystack, const char *needle)
{
    size_t len1 = strlen(haystack);
    size_t len2 = strlen(needle);
    char *result = 0;

    while ((len1 != 0) && (len1-- >= len2)) {
	if (!strncmp(haystack, needle, len2)) {
	    result = haystack;
	    break;
	}
	haystack++;
    }
    return result;
}
#endif

d189 1
a189 1
	("CostOf %s %d %s", capname, result, _nc_visbuf(cap)));
d199 1
a199 1
	("NormalizedCost %s %d %s", capname, result, _nc_visbuf(cap)));
d219 1
a219 1
	float cum_cost = 0;
d224 1
a224 1
		float number = 0;
d235 1
a235 1
#ifdef NCURSES_NO_PADDING
d386 2
a387 7
	min(SP->_hpa_ch_cost,
	    SP->_cuf_ch_cost));

    /* pre-compute some capability lengths */
    SP->_carriage_return_length = STRLEN(carriage_return);
    SP->_cursor_home_length = STRLEN(cursor_home);
    SP->_cursor_to_ll_length = STRLEN(cursor_to_ll);
d447 1
a447 1
repeated_append(int total, int num, int repeat, char *dst, const char *src)
d449 1
a449 2
    register size_t src_len = strlen(src);
    register size_t dst_len = STRLEN(dst);
d451 7
a457 7
    if ((dst_len + repeat * src_len) < OPT_SIZE - 1) {
	total += (num * repeat);
	if (dst) {
	    dst += dst_len;
	    while (repeat-- > 0) {
		(void) strcpy(dst, src);
		dst += src_len;
a474 2
/* Note: we'd like to inline this for speed, but GNU C barfs on the attempt. */

d476 2
a477 1
relative_move(char *result, int from_y, int from_x, int to_y, int to_x, bool ovw)
d480 1
d483 1
a483 2
    if (result)
	result[0] = '\0';
d488 2
a489 3
	if (row_address) {
	    if (result)
		(void) strcpy(result, tparm(row_address, to_y));
d496 4
a499 3
	    if (parm_down_cursor && SP->_cud_cost < vcost) {
		if (result)
		    (void) strcpy(result, tparm(parm_down_cursor, n));
d504 2
a505 3
		if (result)
		    result[0] = '\0';
		vcost = repeated_append(0, SP->_cud1_cost, n, result, cursor_down);
d510 4
a513 3
	    if (parm_up_cursor && SP->_cup_cost < vcost) {
		if (result)
		    (void) strcpy(result, tparm(parm_up_cursor, n));
d518 2
a519 3
		if (result)
		    result[0] = '\0';
		vcost = repeated_append(0, SP->_cuu1_cost, n, result, cursor_up);
d527 1
a527 2
    if (result)
	result += strlen(result);
d531 1
d535 3
a537 3
	if (column_address) {
	    if (result)
		(void) strcpy(result, tparm(column_address, to_x));
d544 4
a547 3
	    if (parm_right_cursor && SP->_cuf_cost < hcost) {
		if (result)
		    (void) strcpy(result, tparm(parm_right_cursor, n));
d554 1
a554 1
		str[0] = '\0';
d562 2
a563 2
			lhcost = repeated_append(lhcost, SP->_ht_cost, 1,
			    str, tab);
d574 1
a574 1
#ifdef BSD_TPUTS
d583 1
a606 1
		    char *sp;
a608 2
		    sp = str + strlen(str);

d610 3
a612 2
			*sp++ = WANT_CHAR(to_y, from_x + i);
		    *sp = '\0';
d617 2
a618 1
		    lhcost = repeated_append(lhcost, SP->_cuf1_cost, n, str, cursor_right);
d621 2
a622 3
		if (lhcost < hcost) {
		    if (result)
			(void) strcpy(result, str);
d629 4
a632 3
	    if (parm_left_cursor && SP->_cub_cost < hcost) {
		if (result)
		    (void) strcpy(result, tparm(parm_left_cursor, n));
d639 1
a639 1
		str[0] = '\0';
d646 2
a647 2
			lhcost = repeated_append(lhcost, SP->_cbt_cost, 1,
			    str, back_tab);
d656 1
a656 1
		lhcost = repeated_append(lhcost, SP->_cub1_cost, n, str, cursor_left);
d658 2
a659 3
		if (lhcost < hcost) {
		    if (result)
			(void) strcpy(result, str);
d688 2
a689 1
    char use[OPT_SIZE], *sp;
d699 3
d703 1
a703 2
    sp = tparm(SP->_address_cursor, ynew, xnew);
    if (sp) {
a704 1
	(void) strcpy(use, sp);
d734 2
a735 1
	&& ((newcost = relative_move(NULL, yold, xold, ynew, xnew, ovw)) != INFINITY)
d743 2
a744 1
	&& ((newcost = relative_move(NULL, yold, 0, ynew, xnew, ovw)) != INFINITY)
d752 1
a752 1
	&& ((newcost = relative_move(NULL, 0, 0, ynew, xnew, ovw)) != INFINITY)
d760 2
a761 2
	&& ((newcost = relative_move(NULL, screen_lines - 1, 0, ynew, xnew,
		    ovw)) != INFINITY)
d774 2
a775 2
	&& ((newcost = relative_move(NULL, yold - 1, screen_columns - 1,
		    ynew, xnew, ovw)) != INFINITY)
d784 2
d788 1
a788 1
	(void) relative_move(use, yold, xold, ynew, xnew, ovw);
d791 2
a792 3
	(void) strcpy(use, carriage_return);
	(void) relative_move(use + SP->_carriage_return_length,
	    yold, 0, ynew, xnew, ovw);
d795 2
a796 3
	(void) strcpy(use, cursor_home);
	(void) relative_move(use + SP->_cursor_home_length,
	    0, 0, ynew, xnew, ovw);
d799 2
a800 3
	(void) strcpy(use, cursor_to_ll);
	(void) relative_move(use + SP->_cursor_to_ll_length,
	    screen_lines - 1, 0, ynew, xnew, ovw);
a802 1
	use[0] = '\0';
d804 4
a807 4
	    (void) strcat(use, carriage_return);
	(void) strcat(use, cursor_left);
	(void) relative_move(use + strlen(use),
	    yold - 1, screen_columns - 1, ynew, xnew, ovw);
d818 2
a819 2
	    "onscreen: %d msec, %f 28.8Kbps char-equivalents\n",
	    (int) diff, diff / 288);
d825 1
a825 1
	tputs(use, 1, _nc_outch);
d929 1
a929 1
speed_t ospeed = 0;		/* used by termcap library */
d987 1
a987 1
		termname());
d1008 3
a1010 2
		(long) (after.tv_usec - before.tv_usec + (after.tv_sec -
			before.tv_sec) * 1000000));
d1021 3
a1023 2
		(long) (after.tv_usec - before.tv_usec + (after.tv_sec -
			before.tv_sec) * 1000000));
d1031 1
a1031 1
		_nc_info_hash_table);
d1041 1
a1041 1
			np->nte_name, np->nte_index);
d1047 1
a1047 1
			np->nte_name, np->nte_index);
d1053 1
a1053 1
			np->nte_name, np->nte_index);
d1090 1
a1090 1
	    float cumtime = 0, perchar;
d1128 1
a1128 1
		n, xmits, (int) cumtime, perchar);
d1147 1
a1147 1
		    speeds[i], overhead, totalest);
@


1.7
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.6 2000/03/10 01:35:05 millert Exp $	*/
d157 1
a157 1
MODULE_ID("$From: lib_mvcur.c,v 1.64 2000/05/14 01:25:28 tom Exp $")
d209 2
a210 1
    TR(TRACE_CHARPUT | TRACE_MOVE, ("CostOf %s %d", capname, result));
d219 2
a220 1
    TR(TRACE_CHARPUT | TRACE_MOVE, ("NormalizedCost %s %d", capname, result));
d256 4
a259 1
		cum_cost += number * 10;
d405 4
@


1.6
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.5 2000/01/02 22:06:51 millert Exp $	*/
d157 1
a157 1
MODULE_ID("$From: lib_mvcur.c,v 1.63 2000/02/13 01:02:34 tom Exp $")
d777 1
a777 1
	    ovw)) != INFINITY)
d800 27
a826 23
    if (tactic) {
	if (tactic == 1)
	    (void) relative_move(use, yold, xold, ynew, xnew, ovw);
	else if (tactic == 2) {
	    (void) strcpy(use, carriage_return);
	    (void) relative_move(use + SP->_carriage_return_length,
		yold, 0, ynew, xnew, ovw);
	} else if (tactic == 3) {
	    (void) strcpy(use, cursor_home);
	    (void) relative_move(use + SP->_cursor_home_length,
		0, 0, ynew, xnew, ovw);
	} else if (tactic == 4) {
	    (void) strcpy(use, cursor_to_ll);
	    (void) relative_move(use + SP->_cursor_to_ll_length,
		screen_lines - 1, 0, ynew, xnew, ovw);
	} else {		/* if (tactic == 5) */
	    use[0] = '\0';
	    if (xold > 0)
		(void) strcat(use, carriage_return);
	    (void) strcat(use, cursor_left);
	    (void) relative_move(use + strlen(use),
		yold - 1, screen_columns - 1, ynew, xnew, ovw);
	}
d1027 1
a1027 1
		    before.tv_sec) * 1000000));
d1039 1
a1039 1
		    before.tv_sec) * 1000000));
@


1.5
log
@+ corrected conversion from terminfo rs2 to termcap rs (cf: 980704)
+ make conversion to termcap ug (underline glitch) more consistently applied.
+ modify read_termtype(), fixing 'toe', which could dump core when it
found an incomplete entry such as "dumb" because it did not
initialize its buffer for _nc_read_file_entry().
+ use explicit VALID_NUMERIC() checks in a few places that had been
overlooked, and add a check to ensure that init_tabs is nonzero,
to avoid divide-by-zero (reported by Todd C Miller).
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.4 1999/11/28 17:49:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d157 1
a157 1
MODULE_ID("$From: lib_mvcur.c,v 1.62 2000/01/01 16:54:37 tom Exp $")
@


1.4
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.3 1999/06/27 08:14:21 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 1

d157 1
a157 1
MODULE_ID("$From: lib_mvcur.c,v 1.60 1999/10/03 01:08:27 Alexander.V.Lukyanov Exp $")
d161 2
a163 2
#define CURRENT_ROW	SP->_cursrow		/* phys cursor row */
#define CURRENT_COLUMN	SP->_curscol		/* phys cursor column */
d180 2
a181 1
char * _nc_strstr(const char *haystack, const char *needle)
d183 8
a190 10
	size_t len1 = strlen(haystack);
	size_t len2 = strlen(needle);
	char *result = 0;

	while ((len1 != 0) && (len1-- >= len2)) {
		if (!strncmp(haystack, needle, len2)) {
			result = haystack;
			break;
		}
		haystack++;
d192 3
a194 1
	return result;
d208 3
a210 3
	int result = _nc_msec_cost(cap,affcnt);
	TR(TRACE_CHARPUT|TRACE_MOVE, ("CostOf %s %d", capname, result));
	return result;
d217 3
a219 3
	int result = normalized_cost(cap,affcnt);
	TR(TRACE_CHARPUT|TRACE_MOVE, ("NormalizedCost %s %d", capname, result));
	return result;
d230 2
a231 1
int _nc_msec_cost(const char *const cap, int affcnt)
d235 4
a238 5
	return(INFINITY);
    else
    {
	const	char	*cp;
	float	cum_cost = 0;
d240 1
a240 2
	for (cp = cap; *cp; cp++)
	{
d242 2
a243 3
	    if (cp[0] == '$' && cp[1] == '<' && strchr(cp, '>'))
	    {
		float	number = 0;
d245 1
a245 2
		for (cp += 2; *cp != '>'; cp++)
		{
d255 1
a255 2
	    }
	    else
d259 1
a259 1
	return((int)cum_cost);
d263 2
a264 1
static int normalized_cost(const char *const cap, int affcnt)
d267 4
a270 4
	int cost = _nc_msec_cost(cap, affcnt);
	if (cost != INFINITY)
		cost = (cost + SP->_char_padding - 1) / SP->_char_padding;
	return cost;
d273 2
a274 1
static void reset_scroll_region(void)
d277 1
a277 2
    if (change_scroll_region)
    {
d283 2
a284 1
void _nc_mvcur_resume(void)
d288 1
a288 2
    if (enter_ca_mode)
    {
d306 1
a306 2
    if (SP->_cursor != -1)
    {
d309 1
a309 1
	curs_set (cursor);
d313 2
a314 1
void _nc_mvcur_init(void)
d323 1
a323 1
    TR(TRACE_CHARPUT|TRACE_MOVE, ("char_padding %d msecs", SP->_char_padding));
d326 1
a326 1
    SP->_cr_cost   = CostOf(carriage_return, 0);
d328 1
a328 1
    SP->_ll_cost   = CostOf(cursor_to_ll, 0);
d330 2
a331 2
    SP->_ht_cost   = CostOf(tab, 0);
    SP->_cbt_cost  = CostOf(back_tab, 0);
d359 1
a359 1
     *	   (Proportional padding is found mainly in insert, delete and scroll
d377 7
a383 7
    SP->_cup_cost  = CostOf(tparm(SP->_address_cursor, 23, 23), 1);
    SP->_cub_cost  = CostOf(tparm(parm_left_cursor, 23), 1);
    SP->_cuf_cost  = CostOf(tparm(parm_right_cursor, 23), 1);
    SP->_cud_cost  = CostOf(tparm(parm_down_cursor, 23), 1);
    SP->_cuu_cost  = CostOf(tparm(parm_up_cursor, 23), 1);
    SP->_hpa_cost  = CostOf(tparm(column_address, 23), 1);
    SP->_vpa_cost  = CostOf(tparm(row_address, 23), 1);
d386 3
a388 3
    SP->_ed_cost   = NormalizedCost(clr_eos, 1);
    SP->_el_cost   = NormalizedCost(clr_eol, 1);
    SP->_el1_cost  = NormalizedCost(clr_bol, 1);
d393 4
a396 4
    SP->_dch_cost  = NormalizedCost(tparm(parm_dch, 23), 1);
    SP->_ich_cost  = NormalizedCost(tparm(parm_ich, 23), 1);
    SP->_ech_cost  = NormalizedCost(tparm(erase_chars, 23), 1);
    SP->_rep_cost  = NormalizedCost(tparm(repeat_char, ' ', 23), 1);
d403 2
a404 2
    SP->_cursor_home_length     = STRLEN(cursor_home);
    SP->_cursor_to_ll_length    = STRLEN(cursor_to_ll);
d413 2
a414 2
     && enter_ca_mode != 0
     && strstr(enter_ca_mode, save_cursor) != 0) {
d428 2
a429 1
void _nc_mvcur_wrap(void)
d439 1
a439 2
    if (exit_ca_mode)
    {
d464 1
a464 1
repeated_append (int total, int num, int repeat, char *dst, const char *src)
d466 2
a467 2
	register size_t src_len = strlen(src);
	register size_t dst_len = STRLEN(dst);
d469 8
a476 11
	if ((dst_len + repeat * src_len) < OPT_SIZE-1) {
		total += (num * repeat);
		if (dst) {
		    dst += dst_len;
		    while (repeat-- > 0) {
			(void) strcpy(dst, src);
			dst += src_len;
		    }
		}
	} else {
		total = INFINITY;
d478 4
a481 1
	return total;
d496 1
a496 1
relative_move(char *result, int from_y,int from_x,int to_y,int to_x, bool ovw)
d499 1
a499 1
    int		n, vcost = 0, hcost = 0;
d504 1
a504 2
    if (to_y != from_y)
    {
d507 1
a507 2
	if (row_address)
	{
d513 1
a513 2
	if (to_y > from_y)
	{
d516 1
a516 2
	    if (parm_down_cursor && SP->_cud_cost < vcost)
	    {
d522 1
a522 2
	    if (cursor_down && (n * SP->_cud1_cost < vcost))
	    {
d527 1
a527 3
	}
	else /* (to_y < from_y) */
	{
d530 1
a530 2
	    if (parm_up_cursor && SP->_cup_cost < vcost)
	    {
d536 1
a536 2
	    if (cursor_up && (n * SP->_cuu1_cost < vcost))
	    {
d544 1
a544 1
	    return(INFINITY);
d550 2
a551 3
    if (to_x != from_x)
    {
	char	str[OPT_SIZE];
d555 1
a555 2
	if (column_address)
	{
d561 1
a561 2
	if (to_x > from_x)
	{
d564 1
a564 2
	    if (parm_right_cursor && SP->_cuf_cost < hcost)
	    {
d570 2
a571 3
	    if (cursor_right)
	    {
		int	lhcost = 0;
d577 2
a578 3
		if (init_tabs > 0 && tab)
		{
		    int	nxt, fr;
d580 3
a582 3
		    for (fr = from_x; (nxt = NEXTTAB(fr)) <= to_x; fr = nxt)
		    {
			lhcost = repeated_append(lhcost, SP->_ht_cost, 1, str, tab);
d584 1
a584 1
				break;
d601 5
a605 5
		 && n > 0
		 && vcost == 0
		 && str[0] == '\0'
		 && isdigit(TextOf(WANT_CHAR(to_y, from_x))))
			ovw = FALSE;
d615 2
a616 3
		if (ovw)
		{
		    int	i;
d619 1
a619 2
			if ((WANT_CHAR(to_y, from_x + i) & A_ATTRIBUTES) != CURRENT_ATTR)
			{
d624 3
a626 4
		if (ovw)
		{
		    char	*sp;
		    int	i;
d634 1
a634 2
		}
		else
d640 1
a640 2
		if (lhcost < hcost)
		{
d646 1
a646 3
	}
	else /* (to_x < from_x) */
	{
d649 1
a649 2
	    if (parm_left_cursor && SP->_cub_cost < hcost)
	    {
d655 2
a656 3
	    if (cursor_left)
	    {
		int	lhcost = 0;
d661 2
a662 3
		if (init_tabs > 0 && back_tab)
		{
		    int	nxt, fr;
d664 3
a666 3
		    for (fr = from_x; (nxt = LASTTAB(fr)) >= to_x; fr = nxt)
		    {
			lhcost = repeated_append(lhcost, SP->_cbt_cost, 1, str, back_tab);
d668 1
a668 1
				break;
d677 1
a677 2
		if (lhcost < hcost)
		{
d686 1
a686 1
	    return(INFINITY);
d689 1
a689 1
    return(vcost + hcost);
d705 1
a705 1
onscreen_mvcur(int yold,int xold,int ynew,int xnew, bool ovw)
d708 3
a710 3
    char	use[OPT_SIZE], *sp;
    int		tactic = 0, newcost, usecost = INFINITY;
    int		t5_cr_cost;
d720 1
a720 2
    if (sp)
    {
d738 1
a738 2
	if (yold == -1 || xold == -1 || NOT_LOCAL(yold, xold, ynew, xnew))
	{
d740 1
a740 2
	    if (!profiling)
	    {
a748 1

d752 2
a753 3
		&& ((newcost=relative_move(NULL, yold, xold, ynew, xnew, ovw))!=INFINITY)
		&& newcost < usecost)
    {
d760 2
a761 3
		&& ((newcost=relative_move(NULL, yold,0,ynew,xnew, ovw)) != INFINITY)
		&& SP->_cr_cost + newcost < usecost)
    {
d768 2
a769 3
	&& ((newcost=relative_move(NULL, 0, 0, ynew, xnew, ovw)) != INFINITY)
	&& SP->_home_cost + newcost < usecost)
    {
d776 3
a778 3
	&& ((newcost=relative_move(NULL, screen_lines-1, 0, ynew, xnew, ovw)) != INFINITY)
	&& SP->_ll_cost + newcost < usecost)
    {
d787 1
a787 1
    t5_cr_cost = (xold>0 ? SP->_cr_cost : 0);
d790 3
a792 3
	&& ((newcost=relative_move(NULL, yold-1, screen_columns-1, ynew, xnew, ovw)) != INFINITY)
	&& t5_cr_cost + SP->_cub1_cost + newcost < usecost)
    {
d800 1
a800 2
    if (tactic)
    {
d803 1
a803 2
	else if (tactic == 2)
	{
d806 2
a807 4
				 yold,0,ynew,xnew, ovw);
	}
	else if (tactic == 3)
	{
d810 2
a811 4
				 0, 0, ynew, xnew, ovw);
	}
	else if (tactic == 4)
	{
d814 2
a815 4
				 screen_lines-1, 0, ynew, xnew, ovw);
	}
	else /* if (tactic == 5) */
	{
d821 1
a821 1
				 yold-1, screen_columns-1, ynew, xnew, ovw);
d831 3
a833 2
	(void) fprintf(stderr, "onscreen: %d msec, %f 28.8Kbps char-equivalents\n",
		       (int)diff, diff/288);
d836 2
a837 3
 nonlocal:
    if (usecost != INFINITY)
    {
d840 3
a842 4
	return(OK);
    }
    else
	return(ERR);
d845 2
a846 1
int mvcur(int yold, int xold, int ynew, int xnew)
d852 1
a852 1
	return(OK);
d860 1
a860 2
    if (xnew >= screen_columns)
    {
d864 2
a865 3
    if (xold >= screen_columns)
    {
	int	l;
d870 1
a870 1
		l -= (yold - screen_lines - 1);
d873 14
a886 19
		if (newline)
		{
			TPUTS_TRACE("newline");
			tputs(newline, 0, _nc_outch);
		}
		else
			putchar('\n');
		l--;
		if (xold > 0)
		{
			if (carriage_return)
			{
				TPUTS_TRACE("carriage_return");
				tputs(carriage_return, 0, _nc_outch);
			}
			else
				putchar('\r');
			xold = 0;
		}
d896 1
a896 1
    return(onscreen_mvcur(yold, xold, ynew, xnew, TRUE));
d917 3
a919 1
int tputs(const char *string, int affcnt GCC_UNUSED, int (*outc)(int) GCC_UNUSED)
d926 1
a926 1
    return(OK);
d929 2
a930 1
int putp(const char *string)
d932 1
a932 1
    return(tputs(string, 1, _nc_outch));
d935 2
a936 1
int _nc_outch(int ch)
d942 11
a952 1
static char	tname[MAX_ALIAS];
d954 2
a955 1
static void load_term(void)
d960 2
a961 1
static int roll(int n)
d971 2
a972 1
int main(int argc GCC_UNUSED, char *argv[] GCC_UNUSED)
d987 3
a989 4
    for (;;)
    {
	int	fy, fx, ty, tx, n, i;
	char	buf[BUFSIZ], capname[BUFSIZ];
d994 19
a1012 16
	if (buf[0] == '?')
	{
(void) puts("?                -- display this help message");
(void) puts("fy fx ty tx      -- (4 numbers) display (fy,fx)->(ty,tx) move");
(void) puts("s[croll] n t b m -- display scrolling sequence");
(void) printf("r[eload]         -- reload terminal info for %s\n", termname());
(void) puts("l[oad] <term>    -- load terminal info for type <term>");
(void) puts("d[elete] <cap>   -- delete named capability");
(void) puts("i[nspect]        -- display terminal capabilities");
(void) puts("c[ost]           -- dump cursor-optimization cost table");
(void) puts("o[optimize]      -- toggle movement optimization");
(void) puts("t[orture] <num>  -- torture-test with <num> random moves");
(void) puts("q[uit]           -- quit the program");
	}
	else if (sscanf(buf, "%d %d %d %d", &fy, &fx, &ty, &tx) == 4)
	{
d1022 3
a1024 4
		(long)(after.tv_usec - before.tv_usec + (after.tv_sec - before.tv_sec) * 1000000));
	}
	else if (sscanf(buf, "s %d %d %d %d", &fy, &fx, &ty, &tx) == 4)
	{
d1034 3
a1036 4
		(long)(after.tv_usec - before.tv_usec + (after.tv_sec - before.tv_sec) * 1000000));
	}
	else if (buf[0] == 'r')
	{
d1039 1
a1039 3
	}
	else if (sscanf(buf, "l %s", tname) == 1)
	{
d1041 3
a1043 5
	}
	else if (sscanf(buf, "d %s", capname) == 1)
	{
	    struct name_table_entry const	*np = _nc_find_entry(capname,
							 _nc_info_hash_table);
d1047 2
a1048 4
	    else
	    {
		switch(np->nte_type)
		{
d1051 3
a1053 2
		    (void) printf("Boolean capability `%s' (%d) turned off.\n",
				  np->nte_name, np->nte_index);
d1057 1
a1057 1
		    cur_term->type.Numbers[np->nte_index] = -1;
d1059 1
a1059 1
				  np->nte_name, np->nte_index);
d1063 1
a1063 1
		    cur_term->type.Strings[np->nte_index] = (char *)NULL;
d1065 1
a1065 1
				  np->nte_name, np->nte_index);
d1069 12
a1080 19
	}
	else if (buf[0] == 'i')
	{
	     dump_init((char *)NULL, F_TERMINFO, S_TERMINFO, 70, 0, FALSE);
	     dump_entry(&cur_term->type, FALSE, TRUE, 0);
	     putchar('\n');
	}
	else if (buf[0] == 'o')
	{
	     if (_nc_optimize_enable & OPTIMIZE_MVCUR)
	     {
		 _nc_optimize_enable &=~ OPTIMIZE_MVCUR;
		 (void) puts("Optimization is now off.");
	     }
	     else
	     {
		 _nc_optimize_enable |= OPTIMIZE_MVCUR;
		 (void) puts("Optimization is now on.");
	     }
d1101 1
a1101 2
	else if (sscanf(buf, "t %d", &n) == 1)
	{
d1103 2
a1104 1
	    int speeds[] = {2400, 9600, 14400, 19200, 28800, 38400, 0};
d1106 1
a1106 1
	    srand((unsigned)(getpid() + time((time_t *)0)));
d1109 1
a1109 2
	    for (i = 0; i < n; i++)
	    {
d1140 1
a1140 1
			  n, xmits, (int)cumtime, perchar);
d1142 1
a1142 2
	    for (i = 0; speeds[i]; i++)
	    {
d1157 3
a1159 2
		(void) printf("%6d bps: %3.2f char-xmits overhead; total estimated time %15.2f\n",
			      speeds[i], overhead, totalest);
d1161 1
a1161 3
	}
	else if (buf[0] == 'c')
	{
d1181 1
a1181 2
	}
	else if (buf[0] == 'x' || buf[0] == 'q')
d1191 1
a1191 1
    return(0);
@


1.3
log
@ncurses-5.0-990626
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.2 1999/02/11 00:09:37 millert Exp $	*/
d158 1
a158 1
MODULE_ID("$From: lib_mvcur.c,v 1.57 1999/06/26 22:16:04 tom Exp $")
a250 2
		    else if (*cp == '.')
			number += (*++cp - 10) / 10.0;
d253 2
d739 1
d823 1
d827 1
a827 1
	&& SP->_cr_cost + SP->_cub1_cost + newcost + newcost < usecost)
d830 1
a830 1
	usecost = SP->_cr_cost + SP->_cub1_cost + newcost;
@


1.2
log
@Update to ncurses-4.2-990206:
    suppress sc/rc capabilities from terminal description if they appear
    in smcup/rmcup.  This affects only scrolling optimization, to fix a
    problem reported by several people with xterm's alternate screen,
    though the problem is more general.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.1 1999/01/18 19:10:26 millert Exp $	*/
d158 1
a158 1
MODULE_ID("$From: lib_mvcur.c,v 1.56 1999/02/01 12:04:15 tom Exp $")
d179 18
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_mvcur.c,v 1.12 1998/10/31 06:30:30 millert Exp $	*/
d158 1
a158 1
MODULE_ID("$From: lib_mvcur.c,v 1.55 1998/12/05 02:04:48 tom Exp $")
d390 14
@

