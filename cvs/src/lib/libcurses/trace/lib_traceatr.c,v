head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.32
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.28
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.24
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.26
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.18
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.22
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.3.0.8
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.17.19.16.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.22.18.01.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.08.22.47.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.23;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Thomas Dickey                           1996-on                 *
 *     and: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/

/*
 *	lib_traceatr.c - Tracing/Debugging routines (attributes)
 */

#include <curses.priv.h>
#include <term.h>		/* acs_chars */

MODULE_ID("$Id: lib_traceatr.c,v 1.63 2008/08/03 16:24:53 tom Exp $")

#define COLOR_OF(c) ((c < 0) ? "default" : (c > 7 ? color_of(c) : colors[c].name))

#ifdef TRACE

static const char l_brace[] = StringOf(L_BRACE);
static const char r_brace[] = StringOf(R_BRACE);

#ifndef USE_TERMLIB

#define my_buffer _nc_globals.traceatr_color_buf
#define my_select _nc_globals.traceatr_color_sel
#define my_cached _nc_globals.traceatr_color_last

static char *
color_of(int c)
{
    if (c != my_cached) {
	my_cached = c;
	my_select = !my_select;
	if (c == COLOR_DEFAULT)
	    strlcpy(my_buffer[my_select], "default", _nc_globals_traceatr_color_buf_size);
	else
	    snprintf(my_buffer[my_select], _nc_globals_traceatr_color_buf_size, "color%d", c);
    }
    return my_buffer[my_select];
}

#undef my_buffer
#undef my_select
#endif /* !USE_TERMLIB */

NCURSES_EXPORT(char *)
_traceattr2(int bufnum, chtype newmode)
{
    static const struct {
	unsigned int val;
	const char *name;
    } names[] =
    {
	/* *INDENT-OFF* */
	{ A_STANDOUT,		"A_STANDOUT" },
	{ A_UNDERLINE,		"A_UNDERLINE" },
	{ A_REVERSE,		"A_REVERSE" },
	{ A_BLINK,		"A_BLINK" },
	{ A_DIM,		"A_DIM" },
	{ A_BOLD,		"A_BOLD" },
	{ A_ALTCHARSET,		"A_ALTCHARSET" },
	{ A_INVIS,		"A_INVIS" },
	{ A_PROTECT,		"A_PROTECT" },
	{ A_CHARTEXT,		"A_CHARTEXT" },
	{ A_NORMAL,		"A_NORMAL" },
	{ A_COLOR,		"A_COLOR" },
	/* *INDENT-ON* */

    }
#ifndef USE_TERMLIB
    ,
	colors[] =
    {
	/* *INDENT-OFF* */
	{ COLOR_BLACK,		"COLOR_BLACK" },
	{ COLOR_RED,		"COLOR_RED" },
	{ COLOR_GREEN,		"COLOR_GREEN" },
	{ COLOR_YELLOW,		"COLOR_YELLOW" },
	{ COLOR_BLUE,		"COLOR_BLUE" },
	{ COLOR_MAGENTA,	"COLOR_MAGENTA" },
	{ COLOR_CYAN,		"COLOR_CYAN" },
	{ COLOR_WHITE,		"COLOR_WHITE" },
	/* *INDENT-ON* */

    }
#endif /* !USE_TERMLIB */
    ;
    size_t n;
    char temp[80];
    char *result = _nc_trace_buf(bufnum, BUFSIZ);

    if (result != 0) {
	unsigned save_nc_tracing = _nc_tracing;

	_nc_tracing = 0;

	strlcpy(result, l_brace, BUFSIZ);

	for (n = 0; n < SIZEOF(names); n++) {
	    if ((newmode & names[n].val) != 0) {
		if (result[1] != '\0')
		    result = _nc_trace_bufcat(bufnum, "|");
		result = _nc_trace_bufcat(bufnum, names[n].name);

		if (names[n].val == A_COLOR) {
		    short pairnum = PAIR_NUMBER(newmode);
#ifdef USE_TERMLIB
		    /* pair_content lives in libncurses */
		    (void) snprintf(temp, sizeof(temp), "{%d}", pairnum);
#else
		    short fg, bg;

		    if (pair_content(pairnum, &fg, &bg) == OK) {
			(void) snprintf(temp, sizeof(temp),
				       "{%d = {%s, %s}}",
				       pairnum,
				       COLOR_OF(fg),
				       COLOR_OF(bg));
		    } else {
			(void) snprintf(temp, sizeof(temp), "{%d}", pairnum);
		    }
#endif
		    result = _nc_trace_bufcat(bufnum, temp);
		}
	    }
	}
	if (ChAttrOf(newmode) == A_NORMAL) {
	    if (result != 0 && result[1] != '\0')
		(void) _nc_trace_bufcat(bufnum, "|");
	    (void) _nc_trace_bufcat(bufnum, "A_NORMAL");
	}

	_nc_tracing = save_nc_tracing;
	result = _nc_trace_bufcat(bufnum, r_brace);
    }
    return result;
}

NCURSES_EXPORT(char *)
_traceattr(attr_t newmode)
{
    return _traceattr2(0, newmode);
}

/* Trace 'int' return-values */
NCURSES_EXPORT(attr_t)
_nc_retrace_attr_t(attr_t code)
{
    T((T_RETURN("%s"), _traceattr(code)));
    return code;
}

const char *
_nc_altcharset_name(attr_t attr, chtype ch)
{
    typedef struct {
	unsigned int val;
	const char *name;
    } ALT_NAMES;
    static const ALT_NAMES names[] =
    {
	{'l', "ACS_ULCORNER"},	/* upper left corner */
	{'m', "ACS_LLCORNER"},	/* lower left corner */
	{'k', "ACS_URCORNER"},	/* upper right corner */
	{'j', "ACS_LRCORNER"},	/* lower right corner */
	{'t', "ACS_LTEE"},	/* tee pointing right */
	{'u', "ACS_RTEE"},	/* tee pointing left */
	{'v', "ACS_BTEE"},	/* tee pointing up */
	{'w', "ACS_TTEE"},	/* tee pointing down */
	{'q', "ACS_HLINE"},	/* horizontal line */
	{'x', "ACS_VLINE"},	/* vertical line */
	{'n', "ACS_PLUS"},	/* large plus or crossover */
	{'o', "ACS_S1"},	/* scan line 1 */
	{'s', "ACS_S9"},	/* scan line 9 */
	{'`', "ACS_DIAMOND"},	/* diamond */
	{'a', "ACS_CKBOARD"},	/* checker board (stipple) */
	{'f', "ACS_DEGREE"},	/* degree symbol */
	{'g', "ACS_PLMINUS"},	/* plus/minus */
	{'~', "ACS_BULLET"},	/* bullet */
	{',', "ACS_LARROW"},	/* arrow pointing left */
	{'+', "ACS_RARROW"},	/* arrow pointing right */
	{'.', "ACS_DARROW"},	/* arrow pointing down */
	{'-', "ACS_UARROW"},	/* arrow pointing up */
	{'h', "ACS_BOARD"},	/* board of squares */
	{'i', "ACS_LANTERN"},	/* lantern symbol */
	{'0', "ACS_BLOCK"},	/* solid square block */
	{'p', "ACS_S3"},	/* scan line 3 */
	{'r', "ACS_S7"},	/* scan line 7 */
	{'y', "ACS_LEQUAL"},	/* less/equal */
	{'z', "ACS_GEQUAL"},	/* greater/equal */
	{'{', "ACS_PI"},	/* Pi */
	{'|', "ACS_NEQUAL"},	/* not equal */
	{'}', "ACS_STERLING"},	/* UK pound sign */
	{'\0', (char *) 0}
    };

    const char *result = 0;

    if ((attr & A_ALTCHARSET) && (acs_chars != 0)) {
	char *cp;
	char *found = 0;
	const ALT_NAMES *sp;

	for (cp = acs_chars; cp[0] && cp[1]; cp += 2) {
	    if (ChCharOf(cp[1]) == ChCharOf(ch)) {
		found = cp;
		/* don't exit from loop - there may be redefinitions */
	    }
	}

	if (found != 0) {
	    ch = ChCharOf(*found);
	    for (sp = names; sp->val; sp++)
		if (sp->val == ch) {
		    result = sp->name;
		    break;
		}
	}
    }
    return result;
}

NCURSES_EXPORT(char *)
_tracechtype2(int bufnum, chtype ch)
{
    const char *found;
    char *result = _nc_trace_buf(bufnum, BUFSIZ);

    if (result != 0) {
	strlcpy(result, l_brace, BUFSIZ);
	if ((found = _nc_altcharset_name(ChAttrOf(ch), ch)) != 0) {
	    (void) _nc_trace_bufcat(bufnum, found);
	} else
	    (void) _nc_trace_bufcat(bufnum, _nc_tracechar(SP, (int) ChCharOf(ch)));

	if (ChAttrOf(ch) != A_NORMAL) {
	    (void) _nc_trace_bufcat(bufnum, " | ");
	    (void) _nc_trace_bufcat(bufnum,
				    _traceattr2(bufnum + 20, ChAttrOf(ch)));
	}

	result = _nc_trace_bufcat(bufnum, r_brace);
    }
    return result;
}

NCURSES_EXPORT(char *)
_tracechtype(chtype ch)
{
    return _tracechtype2(0, ch);
}

/* Trace 'chtype' return-values */
NCURSES_EXPORT(chtype)
_nc_retrace_chtype(chtype code)
{
    T((T_RETURN("%s"), _tracechtype(code)));
    return code;
}

#if USE_WIDEC_SUPPORT
NCURSES_EXPORT(char *)
_tracecchar_t2(int bufnum, const cchar_t *ch)
{
    char *result = _nc_trace_buf(bufnum, BUFSIZ);
    attr_t attr;
    const char *found;

    if (result != 0) {
	    strlcpy(result, l_brace, BUFSIZ);
	if (ch != 0) {
	    attr = AttrOfD(ch);
	    if ((found = _nc_altcharset_name(attr, (chtype) CharOfD(ch))) != 0) {
		(void) _nc_trace_bufcat(bufnum, found);
		attr &= ~A_ALTCHARSET;
	    } else if (isWidecExt(CHDEREF(ch))) {
		(void) _nc_trace_bufcat(bufnum, "{NAC}");
		attr &= ~A_CHARTEXT;
	    } else {
		PUTC_DATA;
		int n;

		PUTC_INIT;
		(void) _nc_trace_bufcat(bufnum, "{ ");
		for (PUTC_i = 0; PUTC_i < CCHARW_MAX; ++PUTC_i) {
		    PUTC_ch = ch->chars[PUTC_i];
		    if (PUTC_ch == L'\0')
			break;
		    PUTC_n = wcrtomb(PUTC_buf, ch->chars[PUTC_i], &PUT_st);
		    if (PUTC_n <= 0) {
			if (PUTC_ch != L'\0') {
			    /* it could not be a multibyte sequence */
			    (void) _nc_trace_bufcat(bufnum,
						    _nc_tracechar(SP,
								  UChar(ch->chars[PUTC_i])));
			}
			break;
		    }
		    for (n = 0; n < PUTC_n; n++) {
			if (n)
			    (void) _nc_trace_bufcat(bufnum, ", ");
			(void) _nc_trace_bufcat(bufnum,
						_nc_tracechar(SP,
							      UChar(PUTC_buf[n])));
		    }
		}
		(void) _nc_trace_bufcat(bufnum, " }");
	    }
	    if (attr != A_NORMAL) {
		(void) _nc_trace_bufcat(bufnum, " | ");
		(void) _nc_trace_bufcat(bufnum, _traceattr2(bufnum + 20, attr));
	    }
	}

	result = _nc_trace_bufcat(bufnum, r_brace);
    }
    return result;
}

NCURSES_EXPORT(char *)
_tracecchar_t(const cchar_t *ch)
{
    return _tracecchar_t2(0, ch);
}
#endif

#else
EMPTY_MODULE(_nc_lib_traceatr)
#endif /* TRACE */
@


1.5
log
@Use strlcpy() / strlcat() throughout.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_traceatr.c,v 1.4 2003/03/17 19:16:59 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d32 2
a33 1
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
d44 1
a44 1
MODULE_ID("$From: lib_traceatr.c,v 1.32 2000/12/10 03:02:45 tom Exp $")
d46 1
a46 1
#define COLOR_OF(c) (c < 0 || c > 7 ? "default" : colors[c].name)
d49 28
d78 1
a78 1
_traceattr2(int bufnum, attr_t newmode)
a79 2
    char *buf = _nc_trace_buf(bufnum, BUFSIZ);
    char *tmp = buf;
d100 3
a102 1
    },
d116 3
a118 1
    };
d120 2
a121 2
    unsigned save_nc_tracing = _nc_tracing;
    _nc_tracing = 0;
d123 2
a124 2
    *tmp++ = '{';
    *tmp = '\0';
d126 30
a155 20
    for (n = 0; n < SIZEOF(names); n++) {
	if ((newmode & names[n].val) != 0) {
	    if (buf[1] != '\0')
		strlcat(tmp, "|", BUFSIZ - (tmp - buf));
	    strlcat(tmp, names[n].name, BUFSIZ - (tmp - buf));
	    tmp += strlen(tmp);

	    if (names[n].val == A_COLOR) {
		short pairnum = PAIR_NUMBER(newmode);
		short fg, bg;

		if (pair_content(pairnum, &fg, &bg) == OK)
		    (void) snprintf(tmp, BUFSIZ - (tmp - buf),
				    "{%d = {%s, %s}}",
				    pairnum,
				    COLOR_OF(fg),
				    COLOR_OF(bg)
			);
		else
		    (void) snprintf(tmp, BUFSIZ - (tmp - buf), "{%d}", pairnum);
d158 8
d167 1
a167 9
    if (AttrOf(newmode) == A_NORMAL) {
	if (buf[1] != '\0')
	    strlcat(tmp, "|", BUFSIZ - (tmp - buf));
	strlcat(tmp, "A_NORMAL", BUFSIZ - (tmp - buf));
    }

    _nc_tracing = save_nc_tracing;
    strlcat(buf, "}", BUFSIZ);
    return (buf);
d184 2
a185 2
NCURSES_EXPORT(char *)
_tracechtype2(int bufnum, chtype ch)
d187 42
a228 2
    char *buf = _nc_trace_buf(bufnum, BUFSIZ);
    char *found = 0;
d230 1
a230 3
    buf[0] = '{';
    buf[1] = '\0';
    if (ch & A_ALTCHARSET) {
d232 2
a233 42
	static const struct {
	    unsigned int val;
	    const char *name;
	} names[] =
	{
	    /* *INDENT-OFF* */
	    { 'l', "ACS_ULCORNER" },	/* upper left corner */
	    { 'm', "ACS_LLCORNER" },	/* lower left corner */
	    { 'k', "ACS_URCORNER" },	/* upper right corner */
	    { 'j', "ACS_LRCORNER" },	/* lower right corner */
	    { 't', "ACS_LTEE" },	/* tee pointing right */
	    { 'u', "ACS_RTEE" },	/* tee pointing left */
	    { 'v', "ACS_BTEE" },	/* tee pointing up */
	    { 'w', "ACS_TTEE" },	/* tee pointing down */
	    { 'q', "ACS_HLINE" },	/* horizontal line */
	    { 'x', "ACS_VLINE" },	/* vertical line */
	    { 'n', "ACS_PLUS" },	/* large plus or crossover */
	    { 'o', "ACS_S1" },		/* scan line 1 */
	    { 's', "ACS_S9" },		/* scan line 9 */
	    { '`', "ACS_DIAMOND" },	/* diamond */
	    { 'a', "ACS_CKBOARD" },	/* checker board (stipple) */
	    { 'f', "ACS_DEGREE" },	/* degree symbol */
	    { 'g', "ACS_PLMINUS" },	/* plus/minus */
	    { '~', "ACS_BULLET" },	/* bullet */
	    { ',', "ACS_LARROW" },	/* arrow pointing left */
	    { '+', "ACS_RARROW" },	/* arrow pointing right */
	    { '.', "ACS_DARROW" },	/* arrow pointing down */
	    { '-', "ACS_UARROW" },	/* arrow pointing up */
	    { 'h', "ACS_BOARD" },	/* board of squares */
	    { 'i', "ACS_LANTERN" },	/* lantern symbol */
	    { '0', "ACS_BLOCK" },	/* solid square block */
	    { 'p', "ACS_S3" },		/* scan line 3 */
	    { 'r', "ACS_S7" },		/* scan line 7 */
	    { 'y', "ACS_LEQUAL" },	/* less/equal */
	    { 'z', "ACS_GEQUAL" },	/* greater/equal */
	    { '{', "ACS_PI" },		/* Pi */
	    { '|', "ACS_NEQUAL" },	/* not equal */
	    { '}', "ACS_STERLING" },	/* UK pound sign */
	    { '\0', (char *) 0 }
		/* *INDENT-OFF* */
	},
	    *sp;
d236 1
a236 1
	    if (TextOf(cp[1]) == TextOf(ch)) {
d243 1
a243 1
	    ch = TextOf(*found);
d246 1
a246 2
		    (void) strlcat(buf, sp->name, BUFSIZ);
		    ch &= ~A_ALTCHARSET;
d251 2
d254 5
a258 2
    if (found == 0)
	(void) strlcat(buf, _tracechar(TextOf(ch)), BUFSIZ);
d260 12
a271 3
    if (AttrOf(ch) != A_NORMAL)
	(void) snprintf(buf + strlen(buf), BUFSIZ - strlen(buf), " | %s",
		_traceattr2(bufnum + 20, AttrOf(ch)));
d273 3
a275 2
    strlcat(buf, "}", BUFSIZ);
    return (buf);
d279 1
a279 1
_tracechtype (chtype ch)
d285 2
a286 2
NCURSES_EXPORT(attr_t)
_nc_retrace_chtype (attr_t code)
d292 61
a352 3
#else
extern NCURSES_EXPORT(void) _nc_lib_traceatr (void);
NCURSES_EXPORT(void) _nc_lib_traceatr (void)
d354 1
d356 4
@


1.4
log
@use snprintf throughout
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_traceatr.c,v 1.3 2001/01/22 18:01:58 millert Exp $	*/
d92 2
a93 1
    strcpy(tmp++, "{");
d98 2
a99 2
		strcat(tmp, "|");
	    strcat(tmp, names[n].name);
d120 2
a121 2
	    strcat(tmp, "|");
	strcat(tmp, "A_NORMAL");
d125 2
a126 1
    return (strcat(buf, "}"));
d149 2
a150 1
    strcpy(buf, "{");
d207 1
a207 1
		    (void) strcat(buf, sp->name);
d215 1
a215 1
	(void) strcat(buf, _tracechar(TextOf(ch)));
d221 1
a221 1
    strcat(buf, "}");
@


1.3
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_traceatr.c,v 1.2 2000/10/08 22:47:03 millert Exp $	*/
d106 5
a110 5
		    (void) sprintf(tmp,
				   "{%d = {%s, %s}}",
				   pairnum,
				   COLOR_OF(fg),
				   COLOR_OF(bg)
d113 1
a113 1
		    (void) sprintf(tmp, "{%d}", pairnum);
d215 1
a215 1
	(void) sprintf(buf + strlen(buf), " | %s",
@


1.2
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_traceatr.c,v 1.1 1999/01/18 19:10:23 millert Exp $	*/
d43 1
a43 1
MODULE_ID("$From: lib_traceatr.c,v 1.30 2000/07/29 18:06:09 tom Exp $")
d48 1
a48 1
char *
d127 1
a127 1
char *
d134 1
a134 1
attr_t
d141 1
a141 1
char *
d222 2
a223 2
char *
_tracechtype(chtype ch)
d229 2
a230 2
attr_t
_nc_retrace_chtype(attr_t code)
d237 2
a238 3
extern void _nc_lib_traceatr(void);
void
_nc_lib_traceatr(void)
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_traceatr.c,v 1.4 1998/07/23 21:19:39 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 2


d41 1
a41 1
#include <term.h>	/* acs_chars */
d43 1
a43 1
MODULE_ID("$From: lib_traceatr.c,v 1.28 1998/03/21 18:39:36 tom Exp $")
d48 2
a49 1
char *_traceattr2(int bufnum, attr_t newmode)
d51 6
a56 4
char	*buf = _nc_trace_buf(bufnum, BUFSIZ);
char	*tmp = buf;
static const	struct {unsigned int val; const char *name;}
names[] =
d58 1
d71 2
d74 1
a74 1
colors[] =
d76 1
d85 2
d88 27
a114 34
size_t n;
unsigned save_nc_tracing = _nc_tracing;
	_nc_tracing = 0;

	strcpy(tmp++, "{");

	for (n = 0; n < SIZEOF(names); n++) {
		if ((newmode & names[n].val) != 0) {
			if (buf[1] != '\0')
				strcat(tmp, "|");
			strcat(tmp, names[n].name);
			tmp += strlen(tmp);

			if (names[n].val == A_COLOR)
			{
				short pairnum = PAIR_NUMBER(newmode);
				short fg, bg;
	
				if (pair_content(pairnum, &fg, &bg) == OK)
					(void) sprintf(tmp,
						"{%d = {%s, %s}}",
						pairnum,
						COLOR_OF(fg),
						COLOR_OF(bg)
						);
				else
					(void) sprintf(tmp, "{%d}", pairnum);
			}
		}
	}
	if (AttrOf(newmode) == A_NORMAL) {
		if (buf[1] != '\0')
			strcat(tmp, "|");
		strcat(tmp, "A_NORMAL");
d116 6
d123 2
a124 2
	_nc_tracing = save_nc_tracing;
	return (strcat(buf,"}"));
d127 2
a128 1
char *_traceattr(attr_t newmode)
d130 1
a130 1
	return _traceattr2(0, newmode);
d134 2
a135 1
attr_t _nc_retrace_attr_t(attr_t code)
d137 2
a138 2
	T((T_RETURN("%s"), _traceattr(code)));
	return code;
d141 2
a142 1
char *_tracechtype2(int bufnum, chtype ch)
d144 2
a145 2
char	*buf = _nc_trace_buf(bufnum, BUFSIZ);
char	*found = 0;
d148 6
a153 5
    if (ch & A_ALTCHARSET)
    {
	char	*cp;
	static const	struct {unsigned int val; const char *name;}
	names[] =
d155 35
a189 33
	    {'l', "ACS_ULCORNER"},	/* upper left corner */
	    {'m', "ACS_LLCORNER"},	/* lower left corner */
	    {'k', "ACS_URCORNER"},	/* upper right corner */
	    {'j', "ACS_LRCORNER"},	/* lower right corner */
	    {'t', "ACS_LTEE"},		/* tee pointing right */
	    {'u', "ACS_RTEE"},		/* tee pointing left */
	    {'v', "ACS_BTEE"},		/* tee pointing up */
	    {'w', "ACS_TTEE"},		/* tee pointing down */
	    {'q', "ACS_HLINE"},		/* horizontal line */
	    {'x', "ACS_VLINE"},		/* vertical line */
	    {'n', "ACS_PLUS"},		/* large plus or crossover */
	    {'o', "ACS_S1"},		/* scan line 1 */
	    {'s', "ACS_S9"},		/* scan line 9 */
	    {'`', "ACS_DIAMOND"},	/* diamond */
	    {'a', "ACS_CKBOARD"},	/* checker board (stipple) */
	    {'f', "ACS_DEGREE"},	/* degree symbol */
	    {'g', "ACS_PLMINUS"},	/* plus/minus */
	    {'~', "ACS_BULLET"},	/* bullet */
	    {',', "ACS_LARROW"},	/* arrow pointing left */
	    {'+', "ACS_RARROW"},	/* arrow pointing right */
	    {'.', "ACS_DARROW"},	/* arrow pointing down */
	    {'-', "ACS_UARROW"},	/* arrow pointing up */
	    {'h', "ACS_BOARD"},		/* board of squares */
	    {'i', "ACS_LANTERN"},	/* lantern symbol */
	    {'0', "ACS_BLOCK"},		/* solid square block */
	    {'p', "ACS_S3"},		/* scan line 3 */
	    {'r', "ACS_S7"},		/* scan line 7 */
	    {'y', "ACS_LEQUAL"},	/* less/equal */
	    {'z', "ACS_GEQUAL"},	/* greater/equal */
	    {'{', "ACS_PI"},		/* Pi */
	    {'|', "ACS_NEQUAL"},	/* not equal */
	    {'}', "ACS_STERLING"},	/* UK pound sign */
	    {'\0',(char *)0}
d191 1
a191 1
	*sp;
d193 2
a194 4
	for (cp = acs_chars; cp[0] && cp[1]; cp += 2)
	{
	    if (TextOf(cp[1]) == TextOf(ch))
	    {
d200 1
a200 2
	if (found != 0)
	{
d203 1
a203 2
		if (sp->val == ch)
		{
d215 2
a216 1
	(void) sprintf(buf + strlen(buf), " | %s", _traceattr2(bufnum+20,AttrOf(ch)));
d219 1
a219 1
    return(buf);
d222 2
a223 1
char *_tracechtype(chtype ch)
d225 1
a225 1
	return _tracechtype2(0, ch);
d227 9
d237 5
a241 2
extern	void _nc_lib_traceatr(void);
	void _nc_lib_traceatr(void) { }
@

