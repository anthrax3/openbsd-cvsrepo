head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.30
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.32
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.28
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.24
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.26
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.18
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.30
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.26
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.24
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.22
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.20
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.18
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.16
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.14
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.8
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.6
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.17.19.16.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.22.18.01.58;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.04.16.49.59;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.10.01.35.05;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.09.05.06.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.11.28.17.49.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.23;	author millert;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 *	lib_trace.c - Tracing/Debugging routines
 *
 * The _tracef() function is originally from pcurses (by Pavel Curtis) in 1982. 
 * pcurses allowed one to enable/disable tracing using traceon() and traceoff()
 * functions.  ncurses provides a trace() function which allows one to
 * selectively enable or disable several tracing features.
 */

#include <curses.priv.h>
#include <tic.h>

#include <ctype.h>

MODULE_ID("$Id: lib_trace.c,v 1.71 2008/08/23 18:04:29 tom Exp $")

NCURSES_EXPORT_VAR(unsigned) _nc_tracing = 0; /* always define this */

#ifdef TRACE

#if USE_REENTRANT
NCURSES_EXPORT(const char *)
NCURSES_PUBLIC_VAR(_nc_tputs_trace) (void)
{
    return SP ? SP->_tputs_trace : _nc_prescreen._tputs_trace;
}
NCURSES_EXPORT(long)
NCURSES_PUBLIC_VAR(_nc_outchars) (void)
{
    return SP ? SP->_outchars : _nc_prescreen._outchars;
}
NCURSES_EXPORT(void)
_nc_set_tputs_trace(const char *s)
{
    if (SP)
	SP->_tputs_trace = s;
    else
	_nc_prescreen._tputs_trace = s;
}
NCURSES_EXPORT(void)
_nc_count_outchars(long increment)
{
    if (SP)
	SP->_outchars += increment;
    else
	_nc_prescreen._outchars += increment;
}
#else
NCURSES_EXPORT_VAR(const char *) _nc_tputs_trace = "";
NCURSES_EXPORT_VAR(long) _nc_outchars = 0;
#endif

#define TraceFP		_nc_globals.trace_fp
#define TracePath	_nc_globals.trace_fname
#define TraceLevel	_nc_globals.trace_level

NCURSES_EXPORT(void)
trace(const unsigned int tracelevel)
{
    if ((TraceFP == 0) && tracelevel) {
	const char *mode = _nc_globals.init_trace ? "ab" : "wb";

	if (TracePath[0] == '\0') {
	    int size = sizeof(TracePath) - 12;
	    if (getcwd(TracePath, size) == 0) {
		perror("curses: Can't get working directory");
		exit(EXIT_FAILURE);
	    }
	    TracePath[size] = '\0';
	    assert(strlen(TracePath) <= size);
	    strlcat(TracePath, "/trace", sizeof(TracePath));
	    if (_nc_is_dir_path(TracePath)) {
		strlcat(TracePath, ".log", sizeof(TracePath));
	    }
	}

	_nc_globals.init_trace = TRUE;
	_nc_tracing = tracelevel;
	if (_nc_access(TracePath, W_OK) < 0
	    || (TraceFP = fopen(TracePath, mode)) == 0) {
	    perror("curses: Can't open 'trace' file");
	    exit(EXIT_FAILURE);
	}
	/* Try to set line-buffered mode, or (failing that) unbuffered,
	 * so that the trace-output gets flushed automatically at the
	 * end of each line.  This is useful in case the program dies. 
	 */
#if HAVE_SETVBUF		/* ANSI */
	(void) setvbuf(TraceFP, (char *) 0, _IOLBF, 0);
#elif HAVE_SETBUF		/* POSIX */
	(void) setbuffer(TraceFP, (char *) 0);
#endif
	_tracef("TRACING NCURSES version %s.%d (tracelevel=%#x)",
		NCURSES_VERSION,
		NCURSES_VERSION_PATCH,
		tracelevel);
    } else if (tracelevel == 0) {
	if (TraceFP != 0) {
	    fclose(TraceFP);
	    TraceFP = 0;
	}
	_nc_tracing = tracelevel;
    } else if (_nc_tracing != tracelevel) {
	_nc_tracing = tracelevel;
	_tracef("tracelevel=%#x", tracelevel);
    }
}

static void
_nc_va_tracef(const char *fmt, va_list ap)
{
    static const char Called[] = T_CALLED("");
    static const char Return[] = T_RETURN("");

    bool before = FALSE;
    bool after = FALSE;
    unsigned doit = _nc_tracing;
    int save_err = errno;

    if (strlen(fmt) >= sizeof(Called) - 1) {
	if (!strncmp(fmt, Called, sizeof(Called) - 1)) {
	    before = TRUE;
	    TraceLevel++;
	} else if (!strncmp(fmt, Return, sizeof(Return) - 1)) {
	    after = TRUE;
	}
	if (before || after) {
	    if ((TraceLevel <= 1)
		|| (doit & TRACE_ICALLS) != 0)
		doit &= (TRACE_CALLS | TRACE_CCALLS);
	    else
		doit = 0;
	}
    }

    if (doit != 0) {
	if (TraceFP == 0)
	    TraceFP = stderr;
#ifdef USE_PTHREADS
	/*
	 * TRACE_ICALLS is "really" needed to show normal use with threaded
	 * applications, since anything can be running during a napms(),
	 * making it appear in the hierarchical trace as it other functions
	 * are being called.
	 *
	 * Rather than add the complication of a per-thread stack, just
	 * show the thread-id in each line of the trace.
	 */
# if USE_WEAK_SYMBOLS
	if ((pthread_self))
# endif
	    fprintf(TraceFP, "%#lx:", (long) (void *) pthread_self());
#endif
	if (before || after) {
	    int n;
	    for (n = 1; n < TraceLevel; n++)
		fputs("+ ", TraceFP);
	}
	vfprintf(TraceFP, fmt, ap);
	fputc('\n', TraceFP);
	fflush(TraceFP);
    }

    if (after && TraceLevel)
	TraceLevel--;

    errno = save_err;
}

NCURSES_EXPORT(void)
_tracef(const char *fmt,...)
{
    va_list ap;

    va_start(ap, fmt);
    _nc_va_tracef(fmt, ap);
    va_end(ap);
}

/* Trace 'bool' return-values */
NCURSES_EXPORT(NCURSES_BOOL)
_nc_retrace_bool(NCURSES_BOOL code)
{
    T((T_RETURN("%s"), code ? "TRUE" : "FALSE"));
    return code;
}

/* Trace 'int' return-values */
NCURSES_EXPORT(int)
_nc_retrace_int(int code)
{
    T((T_RETURN("%d"), code));
    return code;
}

/* Trace 'unsigned' return-values */
NCURSES_EXPORT(unsigned)
_nc_retrace_unsigned(unsigned code)
{
    T((T_RETURN("%#x"), code));
    return code;
}

/* Trace 'char*' return-values */
NCURSES_EXPORT(char *)
_nc_retrace_ptr(char *code)
{
    T((T_RETURN("%s"), _nc_visbuf(code)));
    return code;
}

/* Trace 'const char*' return-values */
NCURSES_EXPORT(const char *)
_nc_retrace_cptr(const char *code)
{
    T((T_RETURN("%s"), _nc_visbuf(code)));
    return code;
}

/* Trace 'NCURSES_CONST void*' return-values */
NCURSES_EXPORT(NCURSES_CONST void *)
_nc_retrace_cvoid_ptr(NCURSES_CONST void *code)
{
    T((T_RETURN("%p"), code));
    return code;
}

/* Trace 'void*' return-values */
NCURSES_EXPORT(void *)
_nc_retrace_void_ptr(void *code)
{
    T((T_RETURN("%p"), code));
    return code;
}

/* Trace 'SCREEN *' return-values */
NCURSES_EXPORT(SCREEN *)
_nc_retrace_sp(SCREEN *code)
{
    T((T_RETURN("%p"), code));
    return code;
}

/* Trace 'WINDOW *' return-values */
NCURSES_EXPORT(WINDOW *)
_nc_retrace_win(WINDOW *code)
{
    T((T_RETURN("%p"), code));
    return code;
}

#if USE_REENTRANT
/*
 * Check if the given trace-mask is enabled.
 *
 * This function may be called from within one of the functions that fills
 * in parameters for _tracef(), but in that case we do not want to lock the
 * mutex, since it is already locked.
 */
NCURSES_EXPORT(int)
_nc_use_tracef(unsigned mask)
{
    bool result = FALSE;

    _nc_lock_global(tst_tracef);
    if (!_nc_globals.nested_tracef++) {
	if ((result = (_nc_tracing & (mask))) != 0
	    && _nc_try_global(tracef) == 0) {
	    /* we will call _nc_locked_tracef(), no nesting so far */
	} else {
	    /* we will not call _nc_locked_tracef() */
	    _nc_globals.nested_tracef = 0;
	}
    } else {
	/* we may call _nc_locked_tracef(), but with nested_tracef > 0 */
	result = (_nc_tracing & (mask));
    }
    _nc_unlock_global(tst_tracef);
    return result;
}

/*
 * We call this if _nc_use_tracef() returns true, which means we must unlock
 * the tracef mutex.
 */
NCURSES_EXPORT(void)
_nc_locked_tracef(const char *fmt,...)
{
    va_list ap;

    va_start(ap, fmt);
    _nc_va_tracef(fmt, ap);
    va_end(ap);

    if (--(_nc_globals.nested_tracef) == 0)
	_nc_unlock_global(tracef);
}
#endif /* USE_REENTRANT */

#endif /* TRACE */
@


1.7
log
@use snprintf throughout
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_trace.c,v 1.6 2001/01/22 18:01:58 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d39 5
d51 1
a51 1
MODULE_ID("$From: lib_trace.c,v 1.38 2000/12/10 03:02:45 tom Exp $")
d53 1
a53 2
NCURSES_EXPORT_VAR(unsigned)
_nc_tracing = 0;		/* always define this */
a55 4
NCURSES_EXPORT_VAR(const char *)
_nc_tputs_trace = "";
NCURSES_EXPORT_VAR(long)
_nc_outchars = 0;
d57 35
a91 1
     static FILE *tracefp;	/* default to writing to stderr */
d94 1
a94 1
trace(const unsigned int tracelevel GCC_UNUSED)
d96 16
a111 2
    static bool been_here = FALSE;
    static char my_name[] = "trace";
d113 5
a117 7
    _nc_tracing = tracelevel;
    if (!been_here && tracelevel) {
	been_here = TRUE;

	if (_nc_access(my_name, W_OK) < 0
	    || (tracefp = fopen(my_name, "wb")) == 0) {
	    perror("curses: Can't open 'trace' file: ");
d125 1
a125 1
	(void) setvbuf(tracefp, (char *) 0, _IOLBF, 0);
d127 1
a127 30
	(void) setbuffer(tracefp, (char *) 0);
#endif
	_tracef("TRACING NCURSES version %s", curses_version());
    }
}
#endif

NCURSES_EXPORT(const char *)
_nc_visbuf2(int bufnum, const char *buf)
/* visibilize a given string */
{
    size_t vbsize;
    char *vbuf;
    char *tp;
    int c;

    if (buf == 0)
	return ("(null)");
    if (buf == CANCELLED_STRING)
	return ("(cancelled)");

    vbsize = (strlen(buf) * 4) + 5;
#ifdef TRACE
    tp = vbuf = _nc_trace_buf(bufnum, vbsize);
#else
    {
	static char *mybuf[2];
	mybuf[bufnum] = _nc_doalloc(mybuf[bufnum], vbsize);
	tp = vbuf = mybuf[bufnum];
    }
d129 8
a136 26
    *tp++ = '"';
    while ((c = *buf++) != '\0') {
	if (c == '"') {
	    *tp++ = '\\';
	    *tp++ = '"';
	} else if (is7bits(c) && (isgraph(c) || c == ' ')) {
	    *tp++ = c;
	} else if (c == '\n') {
	    *tp++ = '\\';
	    *tp++ = 'n';
	} else if (c == '\r') {
	    *tp++ = '\\';
	    *tp++ = 'r';
	} else if (c == '\b') {
	    *tp++ = '\\';
	    *tp++ = 'b';
	} else if (c == '\033') {
	    *tp++ = '\\';
	    *tp++ = 'e';
	} else if (is7bits(c) && iscntrl(c)) {
	    *tp++ = '\\';
	    *tp++ = '^';
	    *tp++ = '@@' + c;
	} else {
	    snprintf(tp, vbsize - (tp - vbuf), "\\%03o", CharOf(c));
	    tp += strlen(tp);
d138 4
a142 9
    *tp++ = '"';
    *tp++ = '\0';
    return (vbuf);
}

NCURSES_EXPORT(const char *)
_nc_visbuf(const char *buf)
{
    return _nc_visbuf2(0, buf);
d145 2
a146 3
#ifdef TRACE
NCURSES_EXPORT(void)
_tracef(const char *fmt,...)
d150 1
a150 2
    static int level;
    va_list ap;
d153 1
a153 1
    int doit = _nc_tracing;
d159 1
a159 1
	    level++;
d164 1
a164 1
	    if ((level <= 1)
d173 17
a189 2
	if (tracefp == 0)
	    tracefp = stderr;
d192 2
a193 2
	    for (n = 1; n < level; n++)
		fputs("+ ", tracefp);
d195 3
a197 5
	va_start(ap, fmt);
	vfprintf(tracefp, fmt, ap);
	fputc('\n', tracefp);
	va_end(ap);
	fflush(tracefp);
d200 3
a202 2
    if (after && level)
	level--;
d206 18
d232 8
d248 32
d287 49
@


1.6
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_trace.c,v 1.5 2000/04/04 16:49:59 millert Exp $	*/
d91 1
d101 1
d103 1
a103 1
    tp = vbuf = _nc_trace_buf(bufnum, (strlen(buf) * 4) + 5);
d107 1
a107 1
	mybuf[bufnum] = _nc_doalloc(mybuf[bufnum], (strlen(buf) * 4) + 5);
d135 1
a135 1
	    sprintf(tp, "\\%03o", CharOf(c));
@


1.5
log
@Update to ncurses-5.0-20000401:
 o change unctrl() to render C1 characters (128-159) as ~@@, ~A, etc.
 o trace() function is provided only if TRACE is defined, e.g., in the debug
   library.  Modify related calls to _tracechar() to use unctrl() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_trace.c,v 1.4 2000/03/10 01:35:05 millert Exp $	*/
d45 1
a45 1
MODULE_ID("$From: lib_trace.c,v 1.34 2000/04/01 20:25:47 tom Exp $")
d47 2
a48 1
unsigned _nc_tracing = 0;	/* always define this */
d51 4
a54 2
const char *_nc_tputs_trace = "";
long _nc_outchars = 0;
d56 1
a56 1
static FILE *tracefp;		/* default to writing to stderr */
d58 1
a58 1
void
d69 1
a69 1
	    || (tracefp = fopen(my_name, "w")) == 0) {
d82 1
a82 2
	_tracef("TRACING NCURSES version %s (%d)",
	    NCURSES_VERSION, NCURSES_VERSION_PATCH);
d87 1
a87 1
const char *
d104 3
a106 3
    static char *mybuf[2];
    mybuf[bufnum] = _nc_doalloc(mybuf[bufnum], (strlen(buf) * 4) + 5);
    tp = vbuf = mybuf[bufnum];
d133 1
a133 1
	    sprintf(tp, "\\%03o", c & 0xff);
d142 1
a142 1
const char *
d149 1
a149 1
void
d198 1
a198 1
int
d206 1
a206 1
char *
d214 1
a214 1
WINDOW *
@


1.4
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_trace.c,v 1.3 2000/01/09 05:06:02 millert Exp $	*/
d45 1
a45 1
MODULE_ID("$From: lib_trace.c,v 1.33 2000/02/13 01:01:55 tom Exp $")
a53 1
#endif
a57 1
#ifdef TRACE
d82 1
a83 1
}
d98 1
d100 7
@


1.3
log
@Update to ncurses-5.0-20000108:
+ add prototype for erase() to curses.h
+ add TRACE_DATABASE flag for trace().
+ formatting changes (style)
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_trace.c,v 1.2 1999/11/28 17:49:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d45 1
a45 1
MODULE_ID("$From: lib_trace.c,v 1.32 2000/01/08 17:37:04 tom Exp $")
@


1.2
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_trace.c,v 1.1 1999/01/18 19:10:23 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
d43 1
a43 1
MODULE_ID("$From: lib_trace.c,v 1.31 1999/10/30 23:00:15 tom Exp $")
d45 1
a45 4
#include <ctype.h>
#if HAVE_FCNTL_H
#include <fcntl.h>
#endif
d53 1
a53 1
static FILE *	tracefp;	/* default to writing to stderr */
d56 2
a57 1
void trace(const unsigned int tracelevel GCC_UNUSED)
d60 2
a61 2
static bool	been_here = FALSE;
static char	my_name[] = "trace";
d63 17
a79 17
   	_nc_tracing = tracelevel;
	if (! been_here && tracelevel) {
		been_here = TRUE;

		if (_nc_access(my_name, W_OK) < 0
		 || (tracefp = fopen(my_name, "w")) == 0) {
			perror("curses: Can't open 'trace' file: ");
			exit(EXIT_FAILURE);
		}
		/* Try to set line-buffered mode, or (failing that) unbuffered,
		 * so that the trace-output gets flushed automatically at the
		 * end of each line.  This is useful in case the program dies. 
		 */
#if HAVE_SETVBUF	/* ANSI */
		(void) setvbuf(tracefp, (char *)0, _IOLBF, 0);
#elif HAVE_SETBUF	/* POSIX */
		(void) setbuffer(tracefp, (char *)0);
d81 3
a83 3
		_tracef("TRACING NCURSES version %s (%d)",
			NCURSES_VERSION, NCURSES_VERSION_PATCH);
	}
d87 2
a88 1
const char *_nc_visbuf2(int bufnum, const char *buf)
d91 36
a126 30
char *vbuf;
char *tp;
int c;

	if (buf == 0)
	    return("(null)");
	if (buf == CANCELLED_STRING)
	    return("(cancelled)");

	tp = vbuf = _nc_trace_buf(bufnum, (strlen(buf) * 4) + 5);
	*tp++ = '"';
    	while ((c = *buf++) != '\0') {
		if (c == '"') {
			*tp++ = '\\'; *tp++ = '"';
		} else if (is7bits(c) && (isgraph(c) || c == ' ')) {
			*tp++ = c;
		} else if (c == '\n') {
			*tp++ = '\\'; *tp++ = 'n';
		} else if (c == '\r') {
			*tp++ = '\\'; *tp++ = 'r';
		} else if (c == '\b') {
			*tp++ = '\\'; *tp++ = 'b';
		} else if (c == '\033') {
			*tp++ = '\\'; *tp++ = 'e';
		} else if (is7bits(c) && iscntrl(c)) {
			*tp++ = '\\'; *tp++ = '^'; *tp++ = '@@' + c;
		} else {
			sprintf(tp, "\\%03o", c & 0xff);
			tp += strlen(tp);
		}
d128 4
a131 3
	*tp++ = '"';
	*tp++ = '\0';
	return(vbuf);
d134 2
a135 1
const char *_nc_visbuf(const char *buf)
d137 1
a137 1
	return _nc_visbuf2(0, buf);
d142 1
a142 1
_tracef(const char *fmt, ...)
d144 15
a158 23
static const char Called[] = T_CALLED("");
static const char Return[] = T_RETURN("");
static int level;
va_list ap;
bool	before = FALSE;
bool	after = FALSE;
int	doit = _nc_tracing;
int	save_err = errno;

	if (strlen(fmt) >= sizeof(Called) - 1) {
		if (!strncmp(fmt, Called, sizeof(Called)-1)) {
			before = TRUE;
			level++;
		} else if (!strncmp(fmt, Return, sizeof(Return)-1)) {
			after = TRUE;
		}
		if (before || after) {
			if ((level <= 1)
			 || (doit & TRACE_ICALLS) != 0)
				doit &= (TRACE_CALLS|TRACE_CCALLS);
			else
				doit = 0;
		}
d160 8
d169 7
a175 13
	if (doit != 0) {
		if (tracefp == 0)
			tracefp = stderr;
		if (before || after) {
			int n;
			for (n = 1; n < level; n++)
				fputs("+ ", tracefp);
		}
		va_start(ap, fmt);
		vfprintf(tracefp, fmt, ap);
		fputc('\n', tracefp);
		va_end(ap);
		fflush(tracefp);
d177 10
a186 4

	if (after && level)
		level--;
	errno = save_err;
d190 2
a191 1
int _nc_retrace_int(int code)
d193 2
a194 2
	T((T_RETURN("%d"), code));
	return code;
d198 2
a199 1
char * _nc_retrace_ptr(char * code)
d201 2
a202 2
	T((T_RETURN("%s"), _nc_visbuf(code)));
	return code;
d206 2
a207 1
WINDOW *_nc_retrace_win(WINDOW *code)
d209 2
a210 2
	T((T_RETURN("%p"), code));
	return code;
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_trace.c,v 1.5 1998/10/31 06:30:30 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d43 1
a43 1
MODULE_ID("$From: lib_trace.c,v 1.30 1998/10/03 23:41:42 tom Exp $")
d54 1
a54 1
long _nc_outchars;
@

