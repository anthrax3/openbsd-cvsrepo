head	1.34;
access;
symbols
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.24
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.20
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.22
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.14
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.34.0.18
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.16
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.12
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.10
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.8
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.6
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.28
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.24
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.22
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.20
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.18
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.16
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.14
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.12
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.10
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.32.0.8
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.6
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.32.0.4
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	OPENBSD_3_3:1.31.0.10
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.31.0.8
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.31.0.6
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.31.0.4
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_8:1.30.0.2
	OPENBSD_2_8_BASE:1.30
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.34
date	2010.09.06.17.26.17;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.12.23.21.59;	author nicm;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.13.11.20.47;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2001.01.22.18.01.34;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.10.15.10.29;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.08.22.46.55;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.10.03.06.10;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.19.03.53.35;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.26.16.45.03;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.10.01.35.01;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.06.07.10.50;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.09.05.06.01;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	99.12.06.02.13.31;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	99.11.28.17.53.40;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	99.07.04.12.43.22;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	99.06.27.08.15.19;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.06.14.17.26.04;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.03.16.15.25.08;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	99.03.15.19.12.21;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.03.12.04.36.02;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.03.02.06.23.27;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.02.24.06.31.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.02.24.05.36.10;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.01.18.19.07.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.10.31.06.30.28;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.09.17.04.14.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.09.13.19.16.25;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.07.27.03.37.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.07.23.21.18.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.01.17.16.27.32;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.12.06.19.11.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.21.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.20;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.06.05.11;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Enable wide character support in ncurses. It is built into libcurses,
libform, libmenu, libpanel and each library is also linked to a
corresponding "w" version.

This is a major bump for all four libraries.

Thanks to landry, stsp, sthen, naddy, oga, Martin Pieuchot, and anyone
else I've forgotten for testing.

ok naddy krw deraadt
@
text
@/* $OpenBSD: curses.priv.h,v 1.33 2010/01/12 23:21:59 nicm Exp $ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/


/*
 * $Id: curses.priv.h,v 1.33 2010/01/12 23:21:59 nicm Exp $
 *
 *	curses.priv.h
 *
 *	Header file for curses library objects which are private to
 *	the library.
 *
 */

#ifndef CURSES_PRIV_H
#define CURSES_PRIV_H 1

#if !defined(NCURSES_IMPEXP)
#  define NCURSES_IMPEXP /* nothing */
#endif
#if !defined(NCURSES_API)
#  define NCURSES_API /* nothing */
#endif
#if !defined(NCURSES_EXPORT)
#  define NCURSES_EXPORT(type) NCURSES_IMPEXP type NCURSES_API
#endif
#if !defined(NCURSES_EXPORT_VAR)
#  define NCURSES_EXPORT_VAR(type) NCURSES_IMPEXP type
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <ncurses_cfg.h>

#if USE_RCS_IDS
#define MODULE_ID(id) static const char Ident[] = id;
#else
#define MODULE_ID(id) /*nothing*/
#endif

#include <stdlib.h>
#include <string.h>
#include <sys/types.h>

#if HAVE_UNISTD_H
#include <unistd.h>
#endif

#if HAVE_SYS_BSDTYPES_H
#include <sys/bsdtypes.h>	/* needed for ISC */
#endif

#if HAVE_LIMITS_H
# include <limits.h>
#elif HAVE_SYS_PARAM_H
# include <sys/param.h>
#endif

#include <assert.h>
#include <stdio.h>

#include <errno.h>

#ifndef PATH_MAX
# if defined(_POSIX_PATH_MAX)
#  define PATH_MAX _POSIX_PATH_MAX
# elif defined(MAXPATHLEN)
#  define PATH_MAX MAXPATHLEN
# else
#  define PATH_MAX 255	/* the Posix minimum path-size */
# endif
#endif

#if DECL_ERRNO
extern int errno;
#endif

#include <nc_panel.h>

/* Some systems have a broken 'select()', but workable 'poll()'.  Use that */
#if HAVE_WORKING_POLL
#define USE_FUNC_POLL 1
#if HAVE_POLL_H
#include <poll.h>
#else
#include <sys/poll.h>
#endif
#else
#define USE_FUNC_POLL 0
#endif

/* include signal.h before curses.h to work-around defect in glibc 2.1.3 */
#include <signal.h>

/* Alessandro Rubini's GPM (general-purpose mouse) */
#if HAVE_LIBGPM && HAVE_GPM_H
#define USE_GPM_SUPPORT 1
#else
#define USE_GPM_SUPPORT 0
#endif

/* QNX mouse support */
#if defined(__QNX__) && !defined(__QNXNTO__)
#define USE_QNX_MOUSE 1
#else
#define USE_QNX_MOUSE 0
#endif

/* EMX mouse support */
#ifdef __EMX__
#define USE_EMX_MOUSE 1
#else
#define USE_EMX_MOUSE 0
#endif

#define DEFAULT_MAXCLICK 166
#define EV_MAX		8	/* size of mouse circular event queue */

/*
 * If we don't have signals to support it, don't add a sigwinch handler.
 * In any case, resizing is an extended feature.  Use it if we've got it.
 */
#if !NCURSES_EXT_FUNCS
#undef HAVE_SIZECHANGE
#define HAVE_SIZECHANGE 0
#endif

#if HAVE_SIZECHANGE && USE_SIGWINCH && defined(SIGWINCH)
#define USE_SIZECHANGE 1
#else
#define USE_SIZECHANGE 0
#undef USE_SIGWINCH
#define USE_SIGWINCH 0
#endif

/*
 * If desired, one can configure this, disabling environment variables that
 * point to custom terminfo/termcap locations.
 */
#ifdef USE_ROOT_ENVIRON
#ifdef __OpenBSD__
#define use_terminfo_vars() (!issetugid())
#else
#define use_terminfo_vars() 1
#endif
#else
#define use_terminfo_vars() _nc_env_access()
extern NCURSES_EXPORT(int) _nc_env_access (void);
#endif

/*
 * Not all platforms have memmove; some have an equivalent bcopy.  (Some may
 * have neither).
 */
#if USE_OK_BCOPY
#define memmove(d,s,n) bcopy(s,d,n)
#elif USE_MY_MEMMOVE
#define memmove(d,s,n) _nc_memmove(d,s,n)
extern NCURSES_EXPORT(void *) _nc_memmove (void *, const void *, size_t);
#endif

/*
 * Scroll hints are useless when hashmap is used
 */
#if !USE_SCROLL_HINTS
#if !USE_HASHMAP
#define USE_SCROLL_HINTS 1
#else
#define USE_SCROLL_HINTS 0
#endif
#endif

#if USE_SCROLL_HINTS
#define if_USE_SCROLL_HINTS(stmt) stmt
#else
#define if_USE_SCROLL_HINTS(stmt) /*nothing*/
#endif

/*
 * Note:  ht/cbt expansion flakes out randomly under Linux 1.1.47, but only
 * when we're throwing control codes at the screen at high volume.  To see
 * this, re-enable USE_HARD_TABS and run worm for a while.  Other systems
 * probably don't want to define this either due to uncertainties about tab
 * delays and expansion in raw mode.
 */

#define TRIES struct tries
typedef TRIES {
	TRIES    *child;            /* ptr to child.  NULL if none          */
	TRIES    *sibling;          /* ptr to sibling.  NULL if none        */
	unsigned char    ch;        /* character at this node               */
	unsigned short   value;     /* code of string so far.  0 if none.   */
#undef TRIES
} TRIES;

/*
 * Common/troublesome character definitions
 */
#define StringOf(ch) {ch, 0}

#define L_BRACE '{'
#define R_BRACE '}'
#define S_QUOTE '\''
#define D_QUOTE '"'

#define VT_ACSC "``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~"

/*
 * Structure for palette tables
 */

typedef struct
{
    short red, green, blue;	/* what color_content() returns */
    short r, g, b;		/* params to init_color() */
    int init;			/* true if we called init_color() */
}
color_t;

#define MAXCOLUMNS    135
#define MAXLINES      66
#define FIFO_SIZE     MAXCOLUMNS+2  /* for nocbreak mode input */

#define ACS_LEN       128

#define WINDOWLIST struct _win_list

#if USE_WIDEC_SUPPORT
#define _nc_bkgd    _bkgrnd
#define _XOPEN_SOURCE_EXTENDED 1
#else
#undef _XOPEN_SOURCE_EXTENDED
#define _nc_bkgd    _bkgd
#define wgetbkgrnd(win, wch)	*wch = win->_bkgd
#define wbkgrnd	    wbkgd
#endif

#undef NCURSES_OPAQUE
#define NCURSES_INTERNALS 1
#define NCURSES_OPAQUE 0

#include <curses.h>	/* we'll use -Ipath directive to get the right one! */
#include <term.h>
#include <term_entry.h>
#include <nc_tparm.h>

#if NCURSES_EXT_COLORS && USE_WIDEC_SUPPORT
#define if_EXT_COLORS(stmt)	stmt
#define NetPair(value,p)	(value).ext_color = (p), \
				AttrOf(value) &= ALL_BUT_COLOR, \
				AttrOf(value) |= (A_COLOR & COLOR_PAIR((p > 255) ? 255 : p))
#define SetPair(value,p)	(value).ext_color = (p)
#define GetPair(value)		(value).ext_color
#define unColor(n)		(AttrOf(n) & ALL_BUT_COLOR)
#define GET_WINDOW_PAIR(w)	(w)->_color
#define SET_WINDOW_PAIR(w,p)	(w)->_color = (p)
#define SameAttrOf(a,b)		(AttrOf(a) == AttrOf(b) && GetPair(a) == GetPair(b))
#define VIDATTR(attr, pair)	vid_attr(attr, pair, 0)
#else
#define if_EXT_COLORS(stmt)	/* nothing */
#define SetPair(value,p)	RemAttr(value, A_COLOR), \
				SetAttr(value, AttrOf(value) | (A_COLOR & COLOR_PAIR(p)))
#define GetPair(value)		PAIR_NUMBER(AttrOf(value))
#define unColor(n)		(AttrOf(n) & ALL_BUT_COLOR)
#define GET_WINDOW_PAIR(w)	PAIR_NUMBER(WINDOW_ATTRS(w))
#define SET_WINDOW_PAIR(w,p)	WINDOW_ATTRS(w) &= ALL_BUT_COLOR, \
				WINDOW_ATTRS(w) |= (A_COLOR & COLOR_PAIR(p))
#define SameAttrOf(a,b)		(AttrOf(a) == AttrOf(b))
#define VIDATTR(attr, pair)	vidattr(attr)
#endif

#if NCURSES_NO_PADDING
#define GetNoPadding(sp)	((sp) ? (sp)->_no_padding : _nc_prescreen._no_padding)
#define SetNoPadding(sp)	_nc_set_no_padding(sp)
extern NCURSES_EXPORT(void) _nc_set_no_padding(SCREEN *);
#else
#define GetNoPadding(sp)	FALSE
#define SetNoPadding(sp)	/*nothing*/
#endif

#define WINDOW_ATTRS(w)		((w)->_attrs)

#define SCREEN_ATTRS(s)		(*((s)->_current_attr))
#define GET_SCREEN_PAIR(s)	GetPair(SCREEN_ATTRS(s))
#define SET_SCREEN_PAIR(s,p)	SetPair(SCREEN_ATTRS(s), p)

#if USE_REENTRANT
NCURSES_EXPORT(int *) _nc_ptr_Lines (void);
NCURSES_EXPORT(int *) _nc_ptr_Cols (void);
#define ptrLines() (SP ? &(SP->_LINES) : &(_nc_prescreen._LINES))
#define ptrCols()  (SP ? &(SP->_COLS)  : &(_nc_prescreen._COLS))
#define SET_LINES(value) *_nc_ptr_Lines() = value
#define SET_COLS(value)  *_nc_ptr_Cols() = value
#else
#define ptrLines() &LINES
#define ptrCols()  &COLS
#define SET_LINES(value) LINES = value
#define SET_COLS(value)  COLS = value
#endif

#define TR_MUTEX(data) _tracef("%s@@%d: me:%08lX COUNT:%2u/%2d/%6d/%2d/%s%9u: " #data, \
	    __FILE__, __LINE__, \
	    (unsigned long) (pthread_self()), \
	    data.__data.__lock, \
	    data.__data.__count, \
	    data.__data.__owner, \
	    data.__data.__kind, \
	    (data.__data.__nusers > 5) ? " OOPS " : "", \
	    data.__data.__nusers)
#define TR_GLOBAL_MUTEX(name) TR_MUTEX(_nc_globals.mutex_##name)

#ifdef USE_PTHREADS

#if USE_REENTRANT
#include <pthread.h>
extern NCURSES_EXPORT(void) _nc_init_pthreads(void);
extern NCURSES_EXPORT(void) _nc_mutex_init(pthread_mutex_t *);
extern NCURSES_EXPORT(int) _nc_mutex_lock(pthread_mutex_t *);
extern NCURSES_EXPORT(int) _nc_mutex_trylock(pthread_mutex_t *);
extern NCURSES_EXPORT(int) _nc_mutex_unlock(pthread_mutex_t *);
#define _nc_lock_global(name)	_nc_mutex_lock(&_nc_globals.mutex_##name)
#define _nc_try_global(name)    _nc_mutex_trylock(&_nc_globals.mutex_##name)
#define _nc_unlock_global(name)	_nc_mutex_unlock(&_nc_globals.mutex_##name)

#else
#error POSIX threads requires --enable-reentrant option
#endif

#if USE_WEAK_SYMBOLS
#if defined(__GNUC__)
#  if defined __USE_ISOC99
#    define _cat_pragma(exp)	_Pragma(#exp)
#    define _weak_pragma(exp)	_cat_pragma(weak name)
#  else
#    define _weak_pragma(exp)
#  endif
#  define _declare(name)	__extension__ extern __typeof__(name) name
#  define weak_symbol(name)	_weak_pragma(name) _declare(name) __attribute__((weak))
#endif
#endif

#ifdef USE_PTHREADS
#  if USE_WEAK_SYMBOLS
weak_symbol(pthread_sigmask);
weak_symbol(pthread_self);
weak_symbol(pthread_equal);
weak_symbol(pthread_mutex_init);
weak_symbol(pthread_mutex_lock);
weak_symbol(pthread_mutex_unlock);
weak_symbol(pthread_mutex_trylock);
weak_symbol(pthread_mutexattr_settype);
weak_symbol(pthread_mutexattr_init);
extern NCURSES_EXPORT(int) _nc_sigprocmask(int, const sigset_t *, sigset_t *);
#    undef  sigprocmask
#    define sigprocmask _nc_sigprocmask
#  endif
#endif

#if HAVE_NANOSLEEP
#undef HAVE_NANOSLEEP
#define HAVE_NANOSLEEP 0	/* nanosleep suspends all threads */
#endif

#else /* !USE_PTHREADS */

#define _nc_init_pthreads()	/* nothing */
#define _nc_mutex_init(obj)	/* nothing */

#define _nc_lock_global(name)	/* nothing */
#define _nc_try_global(name)    0
#define _nc_unlock_global(name)	/* nothing */

#endif /* USE_PTHREADS */

#if HAVE_GETTIMEOFDAY
# define PRECISE_GETTIME 1
# define TimeType struct timeval
#else
# define PRECISE_GETTIME 0
# define TimeType time_t
#endif

/*
 * Definitions for color pairs
 */
typedef unsigned colorpair_t;	/* type big enough to store PAIR_OF() */
#define C_SHIFT 9		/* we need more bits than there are colors */
#define C_MASK			((1 << C_SHIFT) - 1)
#define PAIR_OF(fg, bg)		((((fg) & C_MASK) << C_SHIFT) | ((bg) & C_MASK))
#define isDefaultColor(c)	((c) >= COLOR_DEFAULT || (c) < 0)

#define COLOR_DEFAULT		C_MASK

#if defined(USE_TERMLIB) && !defined(NEED_NCURSES_CH_T)

#undef NCURSES_CH_T		/* this is not a termlib feature */
#define NCURSES_CH_T void	/* ...but we need a pointer in SCREEN */

#endif	/* USE_TERMLIB */

#ifndef USE_TERMLIB
struct ldat
{
	NCURSES_CH_T	*text;		/* text of the line */
	NCURSES_SIZE_T	firstchar;	/* first changed character in the line */
	NCURSES_SIZE_T	lastchar;	/* last changed character in the line */
	NCURSES_SIZE_T	oldindex;	/* index of the line at last update */
};
#endif	/* USE_TERMLIB */

typedef enum {
	M_XTERM	= -1		/* use xterm's mouse tracking? */
	,M_NONE = 0		/* no mouse device */
#if USE_GPM_SUPPORT
	,M_GPM			/* use GPM */
#endif
#if USE_SYSMOUSE
	,M_SYSMOUSE		/* FreeBSD sysmouse on console */
#endif
} MouseType;

/*
 * Structures for scrolling.
 */

typedef struct {
	unsigned long hashval;
	int oldcount, newcount;
	int oldindex, newindex;
} HASHMAP;

/*
 * Structures for soft labels.
 */

struct _SLK;

#ifndef USE_TERMLIB

typedef struct
{
	char *ent_text;		/* text for the label */
	char *form_text;	/* formatted text (left/center/...) */
	int ent_x;		/* x coordinate of this field */
	char dirty;		/* this label has changed */
	char visible;		/* field is visible */
} slk_ent;

typedef struct _SLK {
	char dirty;		/* all labels have changed */
	char hidden;		/* soft labels are hidden */
	WINDOW *win;
	slk_ent *ent;
	short  maxlab;		/* number of available labels */
	short  labcnt;		/* number of allocated labels */
	short  maxlen;		/* length of labels */
	NCURSES_CH_T attr;	/* soft label attribute */
} SLK;

#endif	/* USE_TERMLIB */

typedef	struct {
	WINDOW *win;		/* the window used in the hook      */
	int	line;		/* lines to take, < 0 => from bottom*/
	int	(*hook)(WINDOW *, int); /* callback for user	    */
} ripoff_t;

#if USE_GPM_SUPPORT
#undef buttons			/* term.h defines this, and gpm uses it! */
#include <gpm.h>

#ifdef HAVE_LIBDL
/* link dynamically to GPM */
typedef int *TYPE_gpm_fd;
typedef int (*TYPE_Gpm_Open) (Gpm_Connect *, int);
typedef int (*TYPE_Gpm_Close) (void);
typedef int (*TYPE_Gpm_GetEvent) (Gpm_Event *);

#define my_gpm_fd       SP->_mouse_gpm_fd
#define my_Gpm_Open     SP->_mouse_Gpm_Open
#define my_Gpm_Close    SP->_mouse_Gpm_Close
#define my_Gpm_GetEvent SP->_mouse_Gpm_GetEvent
#else
/* link statically to GPM */
#define my_gpm_fd       &gpm_fd
#define my_Gpm_Open     Gpm_Open
#define my_Gpm_Close    Gpm_Close
#define my_Gpm_GetEvent Gpm_GetEvent
#endif /* HAVE_LIBDL */
#endif /* USE_GPM_SUPPORT */

typedef struct {
    long sequence;
    bool last_used;
    char *fix_sgr0;		/* this holds the filtered sgr0 string */
    char *last_bufp;		/* help with fix_sgr0 leak */
    TERMINAL *last_term;
} TGETENT_CACHE;

#define TGETENT_MAX 4

/*
 * State of tparm().
 */
#define STACKSIZE 20

typedef struct {
	union {
		int	num;
		char	*str;
	} data;
	bool num_type;
} STACK_FRAME;

#define NUM_VARS 26

typedef struct {
#ifdef TRACE
	const char	*tname;
#endif
	const char	*tparam_base;

	STACK_FRAME	stack[STACKSIZE];
	int		stack_ptr;

	char		*out_buff;
	size_t		out_size;
	size_t		out_used;

	char		*fmt_buff;
	size_t		fmt_size;

	int		dynamic_var[NUM_VARS];
	int		static_vars[NUM_VARS];
} TPARM_STATE;

typedef struct {
    char *text;
    size_t size;
} TRACEBUF;

/*
 * The filesystem database normally uses a single-letter for the lower level
 * of directories.  Use a hexadecimal code for filesystems which do not
 * preserve mixed-case names.
 */
#if MIXEDCASE_FILENAMES
#define LEAF_FMT "%c"
#else
#define LEAF_FMT "%02x"
#endif

/*
 * TRACEMSE_FMT is no longer than 80 columns, there are 5 numbers that
 * could at most have 10 digits, and the mask contains no more than 32 bits
 * with each bit representing less than 15 characters.  Usually the whole
 * string is less than 80 columns, but this buffer size is an absolute
 * limit.
 */
#define TRACEMSE_MAX	(80 + (5 * 10) + (32 * 15))
#define TRACEMSE_FMT	"id %2d  at (%2d, %2d, %2d) state %4lx = {" /* } */

/*
 * Global data which is not specific to a screen.
 */
typedef struct {
	SIG_ATOMIC_T	have_sigwinch;
	SIG_ATOMIC_T	cleanup_nested;

	bool		init_signals;
	bool		init_screen;

	const char	*comp_sourcename;
	char		*comp_termtype;

	bool		have_tic_directory;
	bool		keep_tic_directory;
	const char	*tic_directory;

	char		*dbi_list;
	int		dbi_size;

	char		*first_name;
	char		**keyname_table;

	int		slk_format;

	char		*safeprint_buf;
	size_t		safeprint_used;

	TGETENT_CACHE	tgetent_cache[TGETENT_MAX];
	int		tgetent_index;
	long		tgetent_sequence;

	WINDOWLIST	*_nc_windowlist;
#define _nc_windows	_nc_globals._nc_windowlist

#if USE_HOME_TERMINFO
	char		*home_terminfo;
#endif

#if !USE_SAFE_SPRINTF
	int		safeprint_cols;
	int		safeprint_rows;
#endif

#ifdef TRACE
	bool		init_trace;
	char		trace_fname[PATH_MAX];
	int		trace_level;
	FILE		*trace_fp;

	char		*tracearg_buf;
	size_t		tracearg_used;

	TRACEBUF	*tracebuf_ptr;
	size_t		tracebuf_used;

	char		tracechr_buf[40];

	char		*tracedmp_buf;
	size_t		tracedmp_used;

	unsigned char	*tracetry_buf;
	size_t		tracetry_used;

#define _nc_globals_traceatr_color_buf_size 80
	char		traceatr_color_buf[2][_nc_globals_traceatr_color_buf_size];
	int		traceatr_color_sel;
	int		traceatr_color_last;

#endif	/* TRACE */

#ifdef USE_PTHREADS
	pthread_mutex_t	mutex_curses;
	pthread_mutex_t	mutex_tst_tracef;
	pthread_mutex_t	mutex_tracef;
	int		nested_tracef;
	int		use_pthreads;
#define _nc_use_pthreads	_nc_globals.use_pthreads
#endif
} NCURSES_GLOBALS;

extern NCURSES_EXPORT_VAR(NCURSES_GLOBALS) _nc_globals;

#define N_RIPS 5

/*
 * Global data which can be swept up into a SCREEN when one is created.
 * It may be modified before the next SCREEN is created.
 */
typedef struct {
	bool		use_env;
	bool		filter_mode;
	attr_t		previous_attr;
	ripoff_t	rippedoff[N_RIPS];
	ripoff_t	*rsp;
	TPARM_STATE	tparm_state;
	TTY		*saved_tty;	/* savetty/resetty information	    */
#if NCURSES_NO_PADDING
	bool		_no_padding;	/* flag to set if padding disabled  */
#endif
#if BROKEN_LINKER || USE_REENTRANT
	chtype		*real_acs_map;
	int		_LINES;
	int		_COLS;
	TERMINAL	*_cur_term;
#ifdef TRACE
	long		_outchars;
	const char	*_tputs_trace;
#endif
#endif
} NCURSES_PRESCREEN;

#define ripoff_sp	_nc_prescreen.rsp
#define ripoff_stack	_nc_prescreen.rippedoff

extern NCURSES_EXPORT_VAR(NCURSES_PRESCREEN) _nc_prescreen;

/*
 * The SCREEN structure.
 */

struct screen {
	int		_ifd;		/* input file ptr for screen	    */
	FILE		*_ofp;		/* output file ptr for screen	    */
	char		*_setbuf;	/* buffered I/O for output	    */
	bool		_filtered;	/* filter() was called		    */
	bool		_buffered;	/* setvbuf uses _setbuf data	    */
	int		_checkfd;	/* filedesc for typeahead check	    */
	TERMINAL	*_term;		/* terminal type information	    */
	TTY		_saved_tty;	/* savetty/resetty information	    */
	NCURSES_SIZE_T	_lines;		/* screen lines			    */
	NCURSES_SIZE_T	_columns;	/* screen columns		    */

	NCURSES_SIZE_T	_lines_avail;	/* lines available for stdscr	    */
	NCURSES_SIZE_T	_topstolen;	/* lines stolen from top	    */

	WINDOW		*_curscr;	/* current screen		    */
	WINDOW		*_newscr;	/* virtual screen to be updated to  */
	WINDOW		*_stdscr;	/* screen's full-window context	    */

	TRIES		*_keytry;	/* "Try" for use with keypad mode   */
	TRIES		*_key_ok;	/* Disabled keys via keyok(,FALSE)  */
	bool		_tried;		/* keypad mode was initialized	    */
	bool		_keypad_on;	/* keypad mode is currently on	    */

	bool		_called_wgetch;	/* check for recursion in wgetch()  */
	int		_fifo[FIFO_SIZE];	/* input push-back buffer   */
	short		_fifohead,	/* head of fifo queue		    */
			_fifotail,	/* tail of fifo queue		    */
			_fifopeek,	/* where to peek for next char	    */
			_fifohold;	/* set if breakout marked	    */

	int		_endwin;	/* are we out of window mode?	    */
	NCURSES_CH_T	*_current_attr; /* holds current attributes set	    */
	int		_coloron;	/* is color enabled?		    */
	int		_color_defs;	/* are colors modified		    */
	int		_cursor;	/* visibility of the cursor	    */
	int		_cursrow;	/* physical cursor row		    */
	int		_curscol;	/* physical cursor column	    */
	bool		_notty;		/* true if we cannot switch non-tty */
	int		_nl;		/* True if NL -> CR/NL is on	    */
	int		_raw;		/* True if in raw mode		    */
	int		_cbreak;	/* 1 if in cbreak mode		    */
					/* > 1 if in halfdelay mode	    */
	int		_echo;		/* True if echo on		    */
	int		_use_meta;	/* use the meta key?		    */
	struct _SLK	*_slk;		/* ptr to soft key struct / NULL    */
	int		slk_format;	/* selected format for this screen  */
	/* cursor movement costs; units are 10ths of milliseconds */
#if NCURSES_NO_PADDING
	bool		_no_padding;	/* flag to set if padding disabled  */
#endif
	int		_char_padding;	/* cost of character put	    */
	int		_cr_cost;	/* cost of (carriage_return)	    */
	int		_cup_cost;	/* cost of (cursor_address)	    */
	int		_home_cost;	/* cost of (cursor_home)	    */
	int		_ll_cost;	/* cost of (cursor_to_ll)	    */
#if USE_HARD_TABS
	int		_ht_cost;	/* cost of (tab)		    */
	int		_cbt_cost;	/* cost of (backtab)		    */
#endif /* USE_HARD_TABS */
	int		_cub1_cost;	/* cost of (cursor_left)	    */
	int		_cuf1_cost;	/* cost of (cursor_right)	    */
	int		_cud1_cost;	/* cost of (cursor_down)	    */
	int		_cuu1_cost;	/* cost of (cursor_up)		    */
	int		_cub_cost;	/* cost of (parm_cursor_left)	    */
	int		_cuf_cost;	/* cost of (parm_cursor_right)	    */
	int		_cud_cost;	/* cost of (parm_cursor_down)	    */
	int		_cuu_cost;	/* cost of (parm_cursor_up)	    */
	int		_hpa_cost;	/* cost of (column_address)	    */
	int		_vpa_cost;	/* cost of (row_address)	    */
	/* used in tty_update.c, must be chars */
	int		_ed_cost;	/* cost of (clr_eos)		    */
	int		_el_cost;	/* cost of (clr_eol)		    */
	int		_el1_cost;	/* cost of (clr_bol)		    */
	int		_dch1_cost;	/* cost of (delete_character)	    */
	int		_ich1_cost;	/* cost of (insert_character)	    */
	int		_dch_cost;	/* cost of (parm_dch)		    */
	int		_ich_cost;	/* cost of (parm_ich)		    */
	int		_ech_cost;	/* cost of (erase_chars)	    */
	int		_rep_cost;	/* cost of (repeat_char)	    */
	int		_hpa_ch_cost;	/* cost of (column_address)	    */
	int		_cup_ch_cost;	/* cost of (cursor_address)	    */
	int		_cuf_ch_cost;	/* cost of (parm_cursor_right)	    */
	int		_inline_cost;	/* cost of inline-move		    */
	int		_smir_cost;	/* cost of (enter_insert_mode)	    */
	int		_rmir_cost;	/* cost of (exit_insert_mode)	    */
	int		_ip_cost;	/* cost of (insert_padding)	    */
	/* used in lib_mvcur.c */
	char *		_address_cursor;
	/* used in tty_update.c */
	int		_scrolling;	/* 1 if terminal's smart enough to  */

	/* used in lib_color.c */
	color_t		*_color_table;	/* screen's color palette	     */
	int		_color_count;	/* count of colors in palette	     */
	colorpair_t	*_color_pairs;	/* screen's color pair list	     */
	int		_pair_count;	/* count of color pairs		     */
#if NCURSES_EXT_FUNCS
	bool		_default_color; /* use default colors		     */
	bool		_has_sgr_39_49; /* has ECMA default color support    */
	int		_default_fg;	/* assumed default foreground	     */
	int		_default_bg;	/* assumed default background	     */
#endif
	chtype		_ok_attributes; /* valid attributes for terminal     */
	chtype		_xmc_suppress;	/* attributes to suppress if xmc     */
	chtype		_xmc_triggers;	/* attributes to process if xmc	     */
	chtype *	_acs_map;	/* the real alternate-charset map    */
	bool *		_screen_acs_map;


	/* used in lib_vidattr.c */
	bool		_use_rmso;	/* true if we may use 'rmso'	     */
	bool		_use_rmul;	/* true if we may use 'rmul'	     */

	/*
	 * These data correspond to the state of the idcok() and idlok()
	 * functions.  A caveat is in order here:  the XSI and SVr4
	 * documentation specify that these functions apply to the window which
	 * is given as an argument.  However, ncurses implements this logic
	 * only for the newscr/curscr update process, _not_ per-window.
	 */
	bool		_nc_sp_idlok;
	bool		_nc_sp_idcok;
#define _nc_idlok SP->_nc_sp_idlok
#define _nc_idcok SP->_nc_sp_idcok

	/*
	 * These are the data that support the mouse interface.
	 */
	bool		_mouse_initialized;
	MouseType	_mouse_type;
	int		_maxclick;
	bool		(*_mouse_event) (SCREEN *);
	bool		(*_mouse_inline)(SCREEN *);
	bool		(*_mouse_parse) (SCREEN *, int);
	void		(*_mouse_resume)(SCREEN *);
	void		(*_mouse_wrap)	(SCREEN *);
	int		_mouse_fd;	/* file-descriptor, if any */
	bool		_mouse_active;	/* true if initialized */
	mmask_t		_mouse_mask;
	NCURSES_CONST char *_mouse_xtermcap; /* string to enable/disable mouse */
	MEVENT		_mouse_events[EV_MAX];	/* hold the last mouse event seen */
	MEVENT		*_mouse_eventp;	/* next free slot in event queue */

#if USE_GPM_SUPPORT
	bool		_mouse_gpm_loaded;
	bool		_mouse_gpm_found;
#ifdef HAVE_LIBDL
	void		*_dlopen_gpm;
	TYPE_gpm_fd	_mouse_gpm_fd;
	TYPE_Gpm_Open	_mouse_Gpm_Open;
	TYPE_Gpm_Close	_mouse_Gpm_Close;
	TYPE_Gpm_GetEvent _mouse_Gpm_GetEvent;
#endif
	Gpm_Connect	_mouse_gpm_connect;
#endif /* USE_GPM_SUPPORT */

#if USE_EMX_MOUSE
	int		_emxmouse_wfd;
	int		_emxmouse_thread;
	int		_emxmouse_activated;
	char		_emxmouse_buttons[4];
#endif

#if USE_SYSMOUSE
	MEVENT		_sysmouse_fifo[FIFO_SIZE];
	int		_sysmouse_head;
	int		_sysmouse_tail;
	int		_sysmouse_char_width;	/* character width */
	int		_sysmouse_char_height;	/* character height */
	int		_sysmouse_old_buttons;
	int		_sysmouse_new_buttons;
#endif

	/*
	 * This supports automatic resizing
	 */
#if USE_SIZECHANGE
	int		(*_resize)(int,int);
#endif

	/*
	 * These are data that support the proper handling of the panel stack on an
	 * per screen basis.
	 */
	struct panelhook _panelHook;

	bool		_sig_winch;
	SCREEN		*_next_screen;

	/* hashes for old and new lines */
	unsigned long	*oldhash, *newhash;
	HASHMAP		*hashtab;
	int		hashtab_len;
	int		*_oldnum_list;
	int		_oldnum_size;

	bool		_cleanup;	/* cleanup after int/quit signal */
	int		(*_outch)(int); /* output handler if not putc */

	int		_legacy_coding;	/* see use_legacy_coding() */

#if USE_REENTRANT
	char		_ttytype[NAMESIZE];
	int		_ESCDELAY;
	int		_TABSIZE;
	int		_LINES;
	int		_COLS;
#ifdef TRACE
	long		_outchars;
	const char	*_tputs_trace;
#endif
#endif

#ifdef TRACE
#define _nc_screen_tracechr_buf_size 40
	char		tracechr_buf[_nc_screen_tracechr_buf_size];
	char		tracemse_buf[TRACEMSE_MAX];
#endif
	/*
	 * ncurses/ncursesw are the same up to this point.
	 */
#if USE_WIDEC_SUPPORT
	/* recent versions of 'screen' have partially-working support for
	 * UTF-8, but do not permit ACS at the same time (see tty_update.c).
	 */
	bool		_screen_acs_fix;
#endif
};

extern NCURSES_EXPORT_VAR(SCREEN *) _nc_screen_chain;
extern NCURSES_EXPORT_VAR(SIG_ATOMIC_T) _nc_have_sigwinch;

	WINDOWLIST {
	WINDOW	win;		/* first, so WINDOW_EXT() works */
	WINDOWLIST *next;
	SCREEN *screen;		/* screen containing the window */
#ifdef _XOPEN_SOURCE_EXTENDED
	char addch_work[(MB_LEN_MAX * 9) + 1];
	unsigned addch_used;	/* number of bytes in addch_work[] */
	int addch_x;		/* x-position for addch_work[] */
	int addch_y;		/* y-position for addch_work[] */
#endif
};

#define WINDOW_EXT(win,field) (((WINDOWLIST *)(win))->field)

/* usually in <limits.h> */
#ifndef UCHAR_MAX
#define UCHAR_MAX 255
#endif

/* The terminfo source is assumed to be 7-bit ASCII */
#define is7bits(c)	((unsigned)(c) < 128)

/* Checks for isprint() should be done on 8-bit characters (non-wide) */
#define is8bits(c)	((unsigned)(c) <= UCHAR_MAX)

#ifndef min
#define min(a,b)	((a) > (b)  ?  (b)  :  (a))
#endif

#ifndef max
#define max(a,b)	((a) < (b)  ?  (b)  :  (a))
#endif

/* usually in <unistd.h> */
#ifndef STDIN_FILENO
#define STDIN_FILENO 0
#endif

#ifndef STDOUT_FILENO
#define STDOUT_FILENO 1
#endif

#ifndef STDERR_FILENO
#define STDERR_FILENO 2
#endif

#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0
#endif

#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif

#ifndef R_OK
#define	R_OK	4		/* Test for read permission.  */
#endif
#ifndef W_OK
#define	W_OK	2		/* Test for write permission.  */
#endif
#ifndef X_OK
#define	X_OK	1		/* Test for execute permission.  */
#endif
#ifndef F_OK
#define	F_OK	0		/* Test for existence.  */
#endif

#if HAVE_FCNTL_H
#include <fcntl.h>		/* may define O_BINARY	*/
#endif

#ifndef O_BINARY
#define O_BINARY 0
#endif

#ifdef TRACE
#if USE_REENTRANT
#define COUNT_OUTCHARS(n) _nc_count_outchars(n);
#else
#define COUNT_OUTCHARS(n) _nc_outchars += (n);
#endif
#else
#define COUNT_OUTCHARS(n) /* nothing */
#endif

#define RESET_OUTCHARS() COUNT_OUTCHARS(-_nc_outchars)

#define UChar(c)	((unsigned char)(c))
#define ChCharOf(c)	((c) & (chtype)A_CHARTEXT)
#define ChAttrOf(c)	((c) & (chtype)A_ATTRIBUTES)

#ifndef MB_LEN_MAX
#define MB_LEN_MAX 8 /* should be >= MB_CUR_MAX, but that may be a function */
#endif

#if USE_WIDEC_SUPPORT /* { */
#define isEILSEQ(status) (((size_t)status == (size_t)-1) && (errno == EILSEQ))

#define init_mb(state)	memset(&state, 0, sizeof(state))

#if NCURSES_EXT_COLORS
#define NulColor	, 0
#else
#define NulColor	/* nothing */
#endif

#define NulChar		0,0,0,0	/* FIXME: see CCHARW_MAX */
#define CharOf(c)	((c).chars[0])
#define AttrOf(c)	((c).attr)

#define AddAttr(c,a)	AttrOf(c) |=  ((a) & A_ATTRIBUTES)
#define RemAttr(c,a)	AttrOf(c) &= ~((a) & A_ATTRIBUTES)
#define SetAttr(c,a)	AttrOf(c) =   ((a) & A_ATTRIBUTES) | WidecExt(c)

#define NewChar2(c,a)	{ a, { c, NulChar } NulColor }
#define NewChar(ch)	NewChar2(ChCharOf(ch), ChAttrOf(ch))

#if CCHARW_MAX == 5
#define CharEq(a,b)	(((a).attr == (b).attr) \
		       && (a).chars[0] == (b).chars[0] \
		       && (a).chars[1] == (b).chars[1] \
		       && (a).chars[2] == (b).chars[2] \
		       && (a).chars[3] == (b).chars[3] \
		       && (a).chars[4] == (b).chars[4] \
			if_EXT_COLORS(&& (a).ext_color == (b).ext_color))
#else
#define CharEq(a,b)	(!memcmp(&(a), &(b), sizeof(a)))
#endif

#define SetChar(ch,c,a) do {							    \
			    NCURSES_CH_T *_cp = &ch;				    \
			    memset(_cp, 0, sizeof(ch));				    \
			    _cp->chars[0] = (c);					    \
			    _cp->attr = (a);					    \
			    if_EXT_COLORS(SetPair(ch, PAIR_NUMBER(a)));		    \
			} while (0)
#define CHREF(wch)	(&wch)
#define CHDEREF(wch)	(*wch)
#define ARG_CH_T	NCURSES_CH_T *
#define CARG_CH_T	const NCURSES_CH_T *
#define PUTC_DATA	char PUTC_buf[MB_LEN_MAX]; int PUTC_i, PUTC_n; \
			mbstate_t PUT_st; wchar_t PUTC_ch
#define PUTC_INIT	init_mb (PUT_st)
#define PUTC(ch,b)	do { if(!isWidecExt(ch)) {				    \
			if (Charable(ch)) {					    \
			    fputc(CharOf(ch), b);				    \
			    COUNT_OUTCHARS(1);					    \
			} else {						    \
			    PUTC_INIT;						    \
			    for (PUTC_i = 0; PUTC_i < CCHARW_MAX; ++PUTC_i) {	    \
				PUTC_ch = (ch).chars[PUTC_i];			    \
				if (PUTC_ch == L'\0')				    \
				    break;					    \
				PUTC_n = wcrtomb(PUTC_buf,			    \
						 (ch).chars[PUTC_i], &PUT_st);	    \
				if (PUTC_n <= 0) {				    \
				    if (PUTC_ch && is8bits(PUTC_ch) && PUTC_i == 0) \
					putc(PUTC_ch,b);			    \
				    break;					    \
				}						    \
				fwrite(PUTC_buf, (unsigned) PUTC_n, 1, b);	    \
			    }							    \
			    COUNT_OUTCHARS(PUTC_i);				    \
			} } } while (0)

#define BLANK		NewChar2(' ', WA_NORMAL)
#define ZEROS		NewChar2('\0', WA_NORMAL)
#define ISBLANK(ch)	((ch).chars[0] == L' ' && (ch).chars[1] == L'\0')

	/*
	 * Wide characters cannot be represented in the A_CHARTEXT mask of
	 * attr_t's but an application might have set a narrow character there.
	 * But even in that case, it would only be a printable character, or
	 * zero.  Otherwise we can use those bits to tell if a cell is the
	 * first or extension part of a wide character.
	 */
#define WidecExt(ch)	(AttrOf(ch) & A_CHARTEXT)
#define isWidecBase(ch)	(WidecExt(ch) == 1)
#define isWidecExt(ch)	(WidecExt(ch) > 1 && WidecExt(ch) < 32)
#define SetWidecExt(dst, ext)	AttrOf(dst) &= ~A_CHARTEXT,		\
				AttrOf(dst) |= (ext + 1)

#define if_WIDEC(code)  code
#define Charable(ch)	((SP != 0 && SP->_legacy_coding)		\
			 || (AttrOf(ch) & A_ALTCHARSET)			\
			 || (!isWidecExt(ch) &&				\
			     (ch).chars[1] == L'\0' &&			\
			     _nc_is_charable(CharOf(ch))))

#define L(ch)		L ## ch
#else /* }{ */
#define CharOf(c)	ChCharOf(c)
#define AttrOf(c)	ChAttrOf(c)
#define AddAttr(c,a)	c |= (a)
#define RemAttr(c,a)	c &= ~((a) & A_ATTRIBUTES)
#define SetAttr(c,a)	c = ((c) & ~A_ATTRIBUTES) | (a)
#define NewChar(ch)	(ch)
#define NewChar2(c,a)	((c) | (a))
#define CharEq(a,b)	((a) == (b))
#define SetChar(ch,c,a)	ch = (c) | (a)
#define CHREF(wch)	wch
#define CHDEREF(wch)	wch
#define ARG_CH_T	NCURSES_CH_T
#define CARG_CH_T	NCURSES_CH_T
#define PUTC_DATA	int data = 0
#define PUTC(ch,b)	do { data = CharOf(ch); putc(data,b); } while (0)

#define BLANK		(' '|A_NORMAL)
#define ZEROS		('\0'|A_NORMAL)
#define ISBLANK(ch)	(CharOf(ch) == ' ')

#define isWidecExt(ch)	(0)
#define if_WIDEC(code) /* nothing */

#define L(ch)		ch
#endif /* } */

#define AttrOfD(ch)	AttrOf(CHDEREF(ch))
#define CharOfD(ch)	CharOf(CHDEREF(ch))
#define SetChar2(wch,ch)    SetChar(wch,ChCharOf(ch),ChAttrOf(ch))

#define BLANK_ATTR	A_NORMAL
#define BLANK_TEXT	L(' ')

#define CHANGED     -1

#define LEGALYX(w, y, x) \
	      ((w) != 0 && \
		((x) >= 0 && (x) <= (w)->_maxx && \
		 (y) >= 0 && (y) <= (w)->_maxy))

#define CHANGED_CELL(line,col) \
	if (line->firstchar == _NOCHANGE) \
		line->firstchar = line->lastchar = col; \
	else if ((col) < line->firstchar) \
		line->firstchar = col; \
	else if ((col) > line->lastchar) \
		line->lastchar = col

#define CHANGED_RANGE(line,start,end) \
	if (line->firstchar == _NOCHANGE \
	 || line->firstchar > (start)) \
		line->firstchar = start; \
	if (line->lastchar == _NOCHANGE \
	 || line->lastchar < (end)) \
		line->lastchar = end

#define CHANGED_TO_EOL(line,start,end) \
	if (line->firstchar == _NOCHANGE \
	 || line->firstchar > (start)) \
		line->firstchar = start; \
	line->lastchar = end

#define SIZEOF(v) (sizeof(v)/sizeof(v[0]))

#define FreeIfNeeded(p)  if ((p) != 0) free(p)

/* FreeAndNull() is not a comma-separated expression because some compilers
 * do not accept a mixture of void with values.
 */
#define FreeAndNull(p)   free(p); p = 0

#include <nc_alloc.h>

/*
 * TTY bit definition for converting tabs to spaces.
 */
#ifdef TAB3
# define OFLAGS_TABS TAB3	/* POSIX specifies TAB3 */
#else
# ifdef XTABS
#  define OFLAGS_TABS XTABS	/* XTABS is usually the "same" */
# else
#  ifdef OXTABS
#   define OFLAGS_TABS OXTABS	/* the traditional BSD equivalent */
#  else
#   define OFLAGS_TABS 0
#  endif
# endif
#endif

/*
 * Standardize/simplify common loops
 */
#define each_screen(p) p = _nc_screen_chain; p != 0; p = (p)->_next_screen
#define each_window(p) p = _nc_windows; p != 0; p = (p)->next
#define each_ripoff(p) p = ripoff_stack; (p - ripoff_stack) < N_RIPS; ++p

/*
 * Prefixes for call/return points of library function traces.  We use these to
 * instrument the public functions so that the traces can be easily transformed
 * into regression scripts.
 */
#define T_CALLED(fmt) "called {" fmt
#define T_CREATE(fmt) "create :" fmt
#define T_RETURN(fmt) "return }" fmt

#ifdef TRACE

#if USE_REENTRANT
#define TPUTS_TRACE(s)	_nc_set_tputs_trace(s);
#else
#define TPUTS_TRACE(s)	_nc_tputs_trace = s;
#endif

#define START_TRACE() \
	if ((_nc_tracing & TRACE_MAXIMUM) == 0) { \
	    int t = _nc_getenv_num("NCURSES_TRACE"); \
	    if (t >= 0) \
		trace((unsigned) t); \
	}

/*
 * Many of the _tracef() calls use static buffers; lock the trace state before
 * trying to fill them.
 */
#if USE_REENTRANT
#define USE_TRACEF(mask) _nc_use_tracef(mask)
extern NCURSES_EXPORT(int)	_nc_use_tracef (unsigned);
extern NCURSES_EXPORT(void)	_nc_locked_tracef (const char *, ...) GCC_PRINTFLIKE(1,2);
#else
#define USE_TRACEF(mask) (_nc_tracing & (mask))
#define _nc_locked_tracef _tracef
#endif

#define TR(n, a)	if (USE_TRACEF(n)) _nc_locked_tracef a
#define T(a)		TR(TRACE_CALLS, a)
#define TRACE_RETURN(value,type) return _nc_retrace_##type(value)

#define returnAttr(code)	TRACE_RETURN(code,attr_t)
#define returnBits(code)	TRACE_RETURN(code,unsigned)
#define returnBool(code)	TRACE_RETURN(code,bool)
#define returnCPtr(code)	TRACE_RETURN(code,cptr)
#define returnCVoidPtr(code)	TRACE_RETURN(code,cvoid_ptr)
#define returnChar(code)	TRACE_RETURN(code,chtype)
#define returnCode(code)	TRACE_RETURN(code,int)
#define returnPtr(code)		TRACE_RETURN(code,ptr)
#define returnSP(code)		TRACE_RETURN(code,sp)
#define returnVoid		T((T_RETURN(""))); return
#define returnVoidPtr(code)	TRACE_RETURN(code,void_ptr)
#define returnWin(code)		TRACE_RETURN(code,win)

extern NCURSES_EXPORT(NCURSES_BOOL)     _nc_retrace_bool (NCURSES_BOOL);
extern NCURSES_EXPORT(NCURSES_CONST void *) _nc_retrace_cvoid_ptr (NCURSES_CONST void *);
extern NCURSES_EXPORT(SCREEN *)         _nc_retrace_sp (SCREEN *);
extern NCURSES_EXPORT(WINDOW *)         _nc_retrace_win (WINDOW *);
extern NCURSES_EXPORT(attr_t)           _nc_retrace_attr_t (attr_t);
extern NCURSES_EXPORT(char *)           _nc_retrace_ptr (char *);
extern NCURSES_EXPORT(char *)           _nc_trace_ttymode(TTY *tty);
extern NCURSES_EXPORT(char *)           _nc_varargs (const char *, va_list);
extern NCURSES_EXPORT(chtype)           _nc_retrace_chtype (chtype);
extern NCURSES_EXPORT(const char *)     _nc_altcharset_name(attr_t, chtype);
extern NCURSES_EXPORT(const char *)     _nc_retrace_cptr (const char *);
extern NCURSES_EXPORT(int)              _nc_retrace_int (int);
extern NCURSES_EXPORT(unsigned)         _nc_retrace_unsigned (unsigned);
extern NCURSES_EXPORT(void *)           _nc_retrace_void_ptr (void *);
extern NCURSES_EXPORT(void)             _nc_fifo_dump (SCREEN *);

#if USE_REENTRANT
NCURSES_WRAPPED_VAR(long, _nc_outchars);
NCURSES_WRAPPED_VAR(const char *, _nc_tputs_trace);
#define _nc_outchars       NCURSES_PUBLIC_VAR(_nc_outchars())
#define _nc_tputs_trace    NCURSES_PUBLIC_VAR(_nc_tputs_trace())
extern NCURSES_EXPORT(void)		_nc_set_tputs_trace (const char *);
extern NCURSES_EXPORT(void)		_nc_count_outchars (long);
#else
extern NCURSES_EXPORT_VAR(const char *) _nc_tputs_trace;
extern NCURSES_EXPORT_VAR(long)         _nc_outchars;
#endif

extern NCURSES_EXPORT_VAR(unsigned)     _nc_tracing;

#if USE_WIDEC_SUPPORT
extern NCURSES_EXPORT(const char *) _nc_viswbuf2 (int, const wchar_t *);
extern NCURSES_EXPORT(const char *) _nc_viswbufn (const wchar_t *, int);
#endif

extern NCURSES_EXPORT(const char *) _nc_viscbuf2 (int, const NCURSES_CH_T *, int);
extern NCURSES_EXPORT(const char *) _nc_viscbuf (const NCURSES_CH_T *, int);

#else /* !TRACE */

#define START_TRACE() /* nothing */

#define T(a)
#define TR(n, a)
#define TPUTS_TRACE(s)

#define returnAttr(code)	return code
#define returnBits(code)	return code
#define returnBool(code)	return code
#define returnCPtr(code)	return code
#define returnCVoidPtr(code)	return code
#define returnChar(code)	return code
#define returnCode(code)	return code
#define returnPtr(code)		return code
#define returnSP(code)		return code
#define returnVoid		return
#define returnVoidPtr(code)	return code
#define returnWin(code)		return code

#endif /* TRACE/!TRACE */

/*
 * Return-codes for tgetent() and friends.
 */
#define TGETENT_YES  1		/* entry is found */
#define TGETENT_NO   0		/* entry is not found */
#define TGETENT_ERR -1		/* an error occurred */

extern NCURSES_EXPORT(const char *) _nc_visbuf2 (int, const char *);
extern NCURSES_EXPORT(const char *) _nc_visbufn (const char *, int);

#define EMPTY_MODULE(name) \
extern	NCURSES_EXPORT(void) name (void); \
	NCURSES_EXPORT(void) name (void) { }

#define ALL_BUT_COLOR ((chtype)~(A_COLOR))
#define NONBLANK_ATTR (A_NORMAL|A_BOLD|A_DIM|A_BLINK)
#define XMC_CHANGES(c) ((c) & SP->_xmc_suppress)

#define toggle_attr_on(S,at) {\
   if (PAIR_NUMBER(at) > 0) {\
      (S) = ((S) & ALL_BUT_COLOR) | (at);\
   } else {\
      (S) |= (at);\
   }\
   TR(TRACE_ATTRS, ("new attribute is %s", _traceattr((S))));}


#define toggle_attr_off(S,at) {\
   if (PAIR_NUMBER(at) > 0) {\
      (S) &= ~(at|A_COLOR);\
   } else {\
      (S) &= ~(at);\
   }\
   TR(TRACE_ATTRS, ("new attribute is %s", _traceattr((S))));}

#define DelCharCost(count) \
		((parm_dch != 0) \
		? SP->_dch_cost \
		: ((delete_character != 0) \
			? (SP->_dch1_cost * count) \
			: INFINITY))

#define InsCharCost(count) \
		((parm_ich != 0) \
		? SP->_ich_cost \
		: ((enter_insert_mode && exit_insert_mode) \
		  ? SP->_smir_cost + SP->_rmir_cost + (SP->_ip_cost * count) \
		  : ((insert_character != 0) \
		    ? ((SP->_ich1_cost + SP->_ip_cost) * count) \
		    : INFINITY)))

#if USE_XMC_SUPPORT
#define UpdateAttrs(c)	if (!SameAttrOf(SCREEN_ATTRS(SP), c)) { \
				attr_t chg = AttrOf(SCREEN_ATTRS(SP)); \
				VIDATTR(AttrOf(c), GetPair(c)); \
				if (magic_cookie_glitch > 0 \
				 && XMC_CHANGES((chg ^ AttrOf(SCREEN_ATTRS(SP))))) { \
					T(("%s @@%d before glitch %d,%d", \
						__FILE__, __LINE__, \
						SP->_cursrow, \
						SP->_curscol)); \
					_nc_do_xmc_glitch(chg); \
				} \
			}
#else
#define UpdateAttrs(c)	if (!SameAttrOf(SCREEN_ATTRS(SP), c)) \
				VIDATTR(AttrOf(c), GetPair(c));
#endif

/*
 * Macros to make additional parameter to implement wgetch_events()
 */
#ifdef NCURSES_WGETCH_EVENTS
#define EVENTLIST_0th(param) param
#define EVENTLIST_1st(param) param
#define EVENTLIST_2nd(param) , param
#else
#define EVENTLIST_0th(param) void
#define EVENTLIST_1st(param) /* nothing */
#define EVENTLIST_2nd(param) /* nothing */
#endif

#if NCURSES_EXPANDED && NCURSES_EXT_FUNCS

#undef  toggle_attr_on
#define toggle_attr_on(S,at) _nc_toggle_attr_on(&(S), at)
extern NCURSES_EXPORT(void) _nc_toggle_attr_on (attr_t *, attr_t);

#undef  toggle_attr_off
#define toggle_attr_off(S,at) _nc_toggle_attr_off(&(S), at)
extern NCURSES_EXPORT(void) _nc_toggle_attr_off (attr_t *, attr_t);

#undef  DelCharCost
#define DelCharCost(count) _nc_DelCharCost(count)
extern NCURSES_EXPORT(int) _nc_DelCharCost (int);

#undef  InsCharCost
#define InsCharCost(count) _nc_InsCharCost(count)
extern NCURSES_EXPORT(int) _nc_InsCharCost (int);

#undef  UpdateAttrs
#define UpdateAttrs(c) _nc_UpdateAttrs(c)
extern NCURSES_EXPORT(void) _nc_UpdateAttrs (NCURSES_CH_T);

#else

extern NCURSES_EXPORT(void) _nc_expanded (void);

#endif

#if !NCURSES_EXT_FUNCS
#define set_escdelay(value) ESCDELAY = value
#endif

#if !HAVE_GETCWD
#define getcwd(buf,len) getwd(buf)
#endif

/* charable.c */
#if USE_WIDEC_SUPPORT
extern NCURSES_EXPORT(bool) _nc_is_charable(wchar_t);
extern NCURSES_EXPORT(int) _nc_to_char(wint_t);
extern NCURSES_EXPORT(wint_t) _nc_to_widechar(int);
#endif

/* comp_captab.c */
typedef struct {
	short	nte_name;	/* offset of name to hash on */
	int	nte_type;	/* BOOLEAN, NUMBER or STRING */
	short	nte_index;	/* index of associated variable in its array */
	short	nte_link;	/* index in table of next hash, or -1 */
} name_table_data;

typedef struct
{
	short	from;
	short	to;
	short	source;
} alias_table_data;

/* doupdate.c */
#if USE_XMC_SUPPORT
extern NCURSES_EXPORT(void) _nc_do_xmc_glitch (attr_t);
#endif

/* hardscroll.c */
#if defined(TRACE) || defined(SCROLLDEBUG) || defined(HASHDEBUG)
extern NCURSES_EXPORT(void) _nc_linedump (void);
#endif

/* lib_acs.c */
extern NCURSES_EXPORT(void) _nc_init_acs (void);	/* corresponds to traditional 'init_acs()' */
extern NCURSES_EXPORT(int) _nc_msec_cost (const char *const, int);  /* used by 'tack' program */

/* lib_addch.c */
#if USE_WIDEC_SUPPORT
NCURSES_EXPORT(int) _nc_build_wch(WINDOW *win, ARG_CH_T ch);
#endif

/* lib_addstr.c */
#if USE_WIDEC_SUPPORT && !defined(USE_TERMLIB)
extern NCURSES_EXPORT(int) _nc_wchstrlen(const cchar_t *);
#endif

/* lib_color.c */
extern NCURSES_EXPORT(bool) _nc_reset_colors(void);

/* lib_getch.c */
extern NCURSES_EXPORT(int) _nc_wgetch(WINDOW *, unsigned long *, int EVENTLIST_2nd(_nc_eventlist *));

/* lib_insch.c */
extern NCURSES_EXPORT(int) _nc_insert_ch(WINDOW *, chtype);

/* lib_mvcur.c */
#define INFINITY	1000000	/* cost: too high to use */

extern NCURSES_EXPORT(void) _nc_mvcur_init (void);
extern NCURSES_EXPORT(void) _nc_mvcur_resume (void);
extern NCURSES_EXPORT(void) _nc_mvcur_wrap (void);

extern NCURSES_EXPORT(int) _nc_scrolln (int, int, int, int);

extern NCURSES_EXPORT(void) _nc_screen_init (void);
extern NCURSES_EXPORT(void) _nc_screen_resume (void);
extern NCURSES_EXPORT(void) _nc_screen_wrap (void);

/* lib_mouse.c */
extern NCURSES_EXPORT(int) _nc_has_mouse (void);

/* lib_mvcur.c */
#define INFINITY	1000000	/* cost: too high to use */
#define BAUDBYTE	9	/* 9 = 7 bits + 1 parity + 1 stop */

/* lib_setup.c */
extern NCURSES_EXPORT(char *) _nc_get_locale(void);
extern NCURSES_EXPORT(int) _nc_unicode_locale(void);
extern NCURSES_EXPORT(int) _nc_locale_breaks_acs(TERMINAL *);
extern NCURSES_EXPORT(int) _nc_setupterm(NCURSES_CONST char *, int, int *, bool);
extern NCURSES_EXPORT(void) _nc_get_screensize(SCREEN *, int *, int *);

/* lib_tstp.c */
#if USE_SIGWINCH
extern NCURSES_EXPORT(int) _nc_handle_sigwinch(SCREEN *);
#else
#define _nc_handle_sigwinch(a) /* nothing */
#endif

/* lib_ungetch.c */
extern NCURSES_EXPORT(int) _nc_ungetch (SCREEN *, int);

/* lib_wacs.c */
#if USE_WIDEC_SUPPORT
extern NCURSES_EXPORT(void) _nc_init_wacs(void);
#endif

typedef struct {
    char *s_head;	/* beginning of the string (may be null) */
    char *s_tail;	/* end of the string (may be null) */
    size_t s_size;	/* current remaining size available */
    size_t s_init;	/* total size available */
} string_desc;

/* strings.c */
extern NCURSES_EXPORT(string_desc *) _nc_str_init (string_desc *, char *, size_t);
extern NCURSES_EXPORT(string_desc *) _nc_str_null (string_desc *, size_t);
extern NCURSES_EXPORT(string_desc *) _nc_str_copy (string_desc *, string_desc *);
extern NCURSES_EXPORT(bool) _nc_safe_strcat (string_desc *, const char *);
extern NCURSES_EXPORT(bool) _nc_safe_strcpy (string_desc *, const char *);

#if !HAVE_STRSTR
#define strstr _nc_strstr
extern NCURSES_EXPORT(char *) _nc_strstr (const char *, const char *);
#endif

/* safe_sprintf.c */
extern NCURSES_EXPORT(char *) _nc_printf_string (const char *, va_list);

/* tries.c */
extern NCURSES_EXPORT(int) _nc_add_to_try (TRIES **, const char *, unsigned);
extern NCURSES_EXPORT(char *) _nc_expand_try (TRIES *, unsigned, int *, size_t);
extern NCURSES_EXPORT(int) _nc_remove_key (TRIES **, unsigned);
extern NCURSES_EXPORT(int) _nc_remove_string (TRIES **, const char *);

/* elsewhere ... */
extern NCURSES_EXPORT(ENTRY *) _nc_delink_entry (ENTRY *, TERMTYPE *);
extern NCURSES_EXPORT(NCURSES_CONST char *) _nc_keyname (SCREEN *, int);
extern NCURSES_EXPORT(NCURSES_CONST char *) _nc_unctrl (SCREEN *, chtype);
extern NCURSES_EXPORT(SCREEN *) _nc_screen_of (WINDOW *);
extern NCURSES_EXPORT(WINDOW *) _nc_makenew (int, int, int, int, int);
extern NCURSES_EXPORT(char *) _nc_trace_buf (int, size_t);
extern NCURSES_EXPORT(char *) _nc_trace_bufcat (int, const char *);
extern NCURSES_EXPORT(char *) _nc_tracechar (SCREEN *, int);
extern NCURSES_EXPORT(char *) _nc_tracemouse (SCREEN *, MEVENT const *);
extern NCURSES_EXPORT(int) _nc_access (const char *, int);
extern NCURSES_EXPORT(int) _nc_baudrate (int);
extern NCURSES_EXPORT(int) _nc_freewin (WINDOW *);
extern NCURSES_EXPORT(int) _nc_getenv_num (const char *);
extern NCURSES_EXPORT(int) _nc_keypad (SCREEN *, bool);
extern NCURSES_EXPORT(int) _nc_ospeed (int);
extern NCURSES_EXPORT(int) _nc_outch (int);
extern NCURSES_EXPORT(int) _nc_read_termcap_entry (const char *const, TERMTYPE *const);
extern NCURSES_EXPORT(int) _nc_setupscreen (int, int, FILE *, bool, int);
extern NCURSES_EXPORT(int) _nc_timed_wait (SCREEN *, int, int, int * EVENTLIST_2nd(_nc_eventlist *));
extern NCURSES_EXPORT(void) _nc_do_color (short, short, bool, int (*)(int));
extern NCURSES_EXPORT(void) _nc_flush (void);
extern NCURSES_EXPORT(void) _nc_free_and_exit (int);
extern NCURSES_EXPORT(void) _nc_free_entry (ENTRY *, TERMTYPE *);
extern NCURSES_EXPORT(void) _nc_freeall (void);
extern NCURSES_EXPORT(void) _nc_hash_map (void);
extern NCURSES_EXPORT(void) _nc_init_keytry (SCREEN *);
extern NCURSES_EXPORT(void) _nc_keep_tic_dir (const char *);
extern NCURSES_EXPORT(void) _nc_make_oldhash (int i);
extern NCURSES_EXPORT(void) _nc_scroll_oldhash (int n, int top, int bot);
extern NCURSES_EXPORT(void) _nc_scroll_optimize (void);
extern NCURSES_EXPORT(void) _nc_set_buffer (FILE *, bool);
extern NCURSES_EXPORT(void) _nc_signal_handler (bool);
extern NCURSES_EXPORT(void) _nc_synchook (WINDOW *);
extern NCURSES_EXPORT(void) _nc_trace_tries (TRIES *);

#if NO_LEAKS
extern NCURSES_EXPORT(void) _nc_alloc_entry_leaks(void);
extern NCURSES_EXPORT(void) _nc_captoinfo_leaks(void);
extern NCURSES_EXPORT(void) _nc_codes_leaks(void);
extern NCURSES_EXPORT(void) _nc_comp_captab_leaks(void);
extern NCURSES_EXPORT(void) _nc_comp_scan_leaks(void);
extern NCURSES_EXPORT(void) _nc_keyname_leaks(void);
extern NCURSES_EXPORT(void) _nc_names_leaks(void);
extern NCURSES_EXPORT(void) _nc_tgetent_leaks(void);
#endif

#ifndef USE_TERMLIB
extern NCURSES_EXPORT(NCURSES_CH_T) _nc_render (WINDOW *, NCURSES_CH_T);
extern NCURSES_EXPORT(int) _nc_waddch_nosync (WINDOW *, const NCURSES_CH_T);
extern NCURSES_EXPORT(void) _nc_scroll_window (WINDOW *, int const, NCURSES_SIZE_T const, NCURSES_SIZE_T const, NCURSES_CH_T);
#endif

#if USE_WIDEC_SUPPORT && !defined(USE_TERMLIB)
extern NCURSES_EXPORT(size_t) _nc_wcrtomb (char *, wchar_t, mbstate_t *);
#endif

#if USE_SIZECHANGE
extern NCURSES_EXPORT(void) _nc_update_screensize (SCREEN *);
#endif

#if HAVE_RESIZETERM
extern NCURSES_EXPORT(void) _nc_resize_margins (WINDOW *);
#else
#define _nc_resize_margins(wp) /* nothing */
#endif

#ifdef NCURSES_WGETCH_EVENTS
extern NCURSES_EXPORT(int) _nc_eventlist_timeout(_nc_eventlist *);
#else
#define wgetch_events(win, evl) wgetch(win)
#define wgetnstr_events(win, str, maxlen, evl) wgetnstr(win, str, maxlen)
#endif

/*
 * Not everyone has vsscanf(), but we'd like to use it for scanw().
 */
#if !HAVE_VSSCANF
extern int vsscanf(const char *str, const char *format, va_list __arg);
#endif

/* scroll indices */
extern NCURSES_EXPORT_VAR(int *) _nc_oldnums;

#define USE_SETBUF_0 0

#define NC_BUFFERED(flag) _nc_set_buffer(SP->_ofp, flag)

#define NC_OUTPUT ((SP != 0) ? SP->_ofp : stdout)

/*
 * On systems with a broken linker, define 'SP' as a function to force the
 * linker to pull in the data-only module with 'SP'.
 */
#if BROKEN_LINKER
#define SP _nc_screen()
extern NCURSES_EXPORT(SCREEN *) _nc_screen (void);
extern NCURSES_EXPORT(int) _nc_alloc_screen (void);
extern NCURSES_EXPORT(void) _nc_set_screen (SCREEN *);
#else
/* current screen is private data; avoid possible linking conflicts too */
extern NCURSES_EXPORT_VAR(SCREEN *) SP;
#define _nc_alloc_screen() ((SP = typeCalloc(SCREEN, 1)) != 0)
#define _nc_set_screen(sp) SP = sp
#endif

/*
 * We don't want to use the lines or columns capabilities internally, because
 * if the application is running multiple screens under X, it's quite possible
 * they could all have type xterm but have different sizes!  So...
 */
#define screen_lines	SP->_lines
#define screen_columns	SP->_columns

extern NCURSES_EXPORT(int) _nc_slk_initialize (WINDOW *, int);

/*
 * Some constants related to SLK's
 */
#define MAX_SKEY_OLD	   8	/* count of soft keys */
#define MAX_SKEY_LEN_OLD   8	/* max length of soft key text */
#define MAX_SKEY_PC       12    /* This is what most PC's have */
#define MAX_SKEY_LEN_PC    5

/* Macro to check whether or not we use a standard format */
#define SLK_STDFMT(fmt) (fmt < 3)
/* Macro to determine height of label window */
#define SLK_LINES(fmt)  (SLK_STDFMT(fmt) ? 1 : ((fmt) - 2))

#define MAX_SKEY(fmt)     (SLK_STDFMT(fmt)? MAX_SKEY_OLD : MAX_SKEY_PC)
#define MAX_SKEY_LEN(fmt) (SLK_STDFMT(fmt)? MAX_SKEY_LEN_OLD : MAX_SKEY_LEN_PC)

extern NCURSES_EXPORT(int) _nc_ripoffline (int line, int (*init)(WINDOW *,int));

/*
 * Common error messages
 */
#define MSG_NO_MEMORY "Out of memory"
#define MSG_NO_INPUTS "Premature EOF"

#ifdef __cplusplus
}
#endif

#endif /* CURSES_PRIV_H */
@


1.33
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d39 1
a39 1
 * $Id: curses.priv.h,v 1.394 2008/10/04 21:37:45 tom Exp $
d265 1
@


1.32
log
@try to use the X Window System, X11 or XFree86 consistently.

diffs from Paul Weismann, via mickey@@
aided, abetted and ok'd matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.31 2001/01/22 18:01:34 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d39 1
a39 1
 * $From: curses.priv.h,v 1.171 2000/12/10 00:13:52 tom Exp $
d94 5
a108 5
#include <assert.h>
#include <stdio.h>

#include <errno.h>

d127 3
d146 3
a148 1
#define USE_EMX_MOUSE
d160 1
d163 1
a163 1
#if HAVE_SIZECHANGE
d166 1
d168 1
d222 4
a225 3
struct tries {
	struct tries    *child;     /* ptr to child.  NULL if none          */
	struct tries    *sibling;   /* ptr to sibling.  NULL if none        */
d228 2
a229 1
};
d232 1
a232 1
 * Definitions for color pairs
d234 1
a234 4
#define C_SHIFT 8		/* we need more bits than there are colors */
#define C_MASK  ((1 << C_SHIFT) - 1)

#define PAIR_OF(fg, bg) ((((fg) & C_MASK) << C_SHIFT) | ((bg) & C_MASK))
a235 3
/*
 * Common/troublesome character definitions
 */
d239 3
d249 3
a251 1
    short red, green, blue;
d263 13
d277 178
d457 1
a457 1
 * Structure for soft labels.
d460 14
d476 5
a480 5
	char *text;             /* text for the label */
	char *form_text;        /* formatted text (left/center/...) */
	int x;                  /* x coordinate of this field */
	char dirty;             /* this label has changed */
	char visible;           /* field is visible */
d483 4
a486 4
typedef struct {
	char dirty;             /* all labels have changed */
	char hidden;            /* soft labels are hidden */
	struct _win_st *win;
d488 4
a491 5
	char*  buffer;           /* buffer for labels */
	short  maxlab;           /* number of available labels */
	short  labcnt;           /* number of allocated labels */
	short  maxlen;           /* length of labels */
        chtype attr;             /* soft label attribute */
d494 224
d719 46
a764 39
	int             _ifd;           /* input file ptr for screen        */
	FILE            *_ofp;          /* output file ptr for screen       */
	char            *_setbuf;       /* buffered I/O for output          */
	int		_buffered;      /* setvbuf uses _setbuf data        */
	int             _checkfd;       /* filedesc for typeahead check     */
	struct term     *_term;         /* terminal type information        */
	short           _lines;         /* screen lines                     */
	short           _columns;       /* screen columns                   */
	short           _lines_avail;   /* lines available for stdscr       */
	short           _topstolen;     /* lines stolen from top            */

	WINDOW          *_curscr;       /* current screen                   */
	WINDOW          *_newscr;       /* virtual screen to be updated to  */
	WINDOW          *_stdscr;       /* screen's full-window context     */

	struct tries    *_keytry;       /* "Try" for use with keypad mode   */
	struct tries    *_key_ok;       /* Disabled keys via keyok(,FALSE)  */
	int             _tried;         /* keypad mode was initialized      */

	unsigned int    _fifo[FIFO_SIZE];       /* input push-back buffer   */
	short           _fifohead,      /* head of fifo queue               */
	                _fifotail,      /* tail of fifo queue               */
	                _fifopeek,      /* where to peek for next char      */
	                _fifohold;      /* set if breakout marked           */

	int             _endwin;        /* are we out of window mode?       */
	unsigned long   _current_attr;  /* terminal attribute current set   */
	int             _coloron;       /* is color enabled?                */
	int             _cursor;        /* visibility of the cursor         */
	int             _cursrow;       /* physical cursor row              */
	int             _curscol;       /* physical cursor column           */
	int             _nl;            /* True if NL -> CR/NL is on        */
	int             _raw;           /* True if in raw mode              */
	int             _cbreak;        /* 1 if in cbreak mode              */
	                                /* > 1 if in halfdelay mode         */
	int             _echo;          /* True if echo on                  */
	int             _use_meta;      /* use the meta key?                */
	SLK             *_slk;          /* ptr to soft key struct / NULL    */
        int             slk_format;     /* selected format for this screen  */
d767 1
a767 1
	int             _no_padding;    /* flag to set if padding disabled  */
d769 5
a773 5
	int             _char_padding;  /* cost of character put            */
	int             _cr_cost;       /* cost of (carriage_return)        */
	int             _cup_cost;      /* cost of (cursor_address)         */
	int             _home_cost;     /* cost of (cursor_home)            */
	int             _ll_cost;       /* cost of (cursor_to_ll)           */
d775 2
a776 2
	int             _ht_cost;       /* cost of (tab)                    */
	int             _cbt_cost;      /* cost of (backtab)                */
d778 10
a787 10
	int             _cub1_cost;     /* cost of (cursor_left)            */
	int             _cuf1_cost;     /* cost of (cursor_right)           */
	int             _cud1_cost;     /* cost of (cursor_down)            */
	int             _cuu1_cost;     /* cost of (cursor_up)              */
	int             _cub_cost;      /* cost of (parm_cursor_left)       */
	int             _cuf_cost;      /* cost of (parm_cursor_right)      */
	int             _cud_cost;      /* cost of (parm_cursor_down)       */
	int             _cuu_cost;      /* cost of (parm_cursor_up)         */
	int             _hpa_cost;      /* cost of (column_address)         */
	int             _vpa_cost;      /* cost of (row_address)            */
d789 16
a804 16
	int             _ed_cost;       /* cost of (clr_eos)                */
	int             _el_cost;       /* cost of (clr_eol)                */
	int             _el1_cost;      /* cost of (clr_bol)                */
	int             _dch1_cost;     /* cost of (delete_character)       */
	int             _ich1_cost;     /* cost of (insert_character)       */
	int             _dch_cost;      /* cost of (parm_dch)               */
	int             _ich_cost;      /* cost of (parm_ich)               */
	int             _ech_cost;      /* cost of (erase_chars)            */
	int             _rep_cost;      /* cost of (repeat_char)            */
	int             _hpa_ch_cost;   /* cost of (column_address)         */
	int             _cup_ch_cost;   /* cost of (cursor_address)         */
	int             _cuf_ch_cost;   /* cost of (parm_cursor_right)      */
	int             _inline_cost;   /* cost of inline-move              */
	int             _smir_cost;	/* cost of (enter_insert_mode)      */
	int             _rmir_cost;	/* cost of (exit_insert_mode)       */
	int             _ip_cost;       /* cost of (insert_padding)         */
d806 1
a806 1
	char *          _address_cursor;
d808 1
a808 1
	int             _scrolling;     /* 1 if terminal's smart enough to  */
d811 4
a814 4
	color_t         *_color_table;  /* screen's color palette            */
	int             _color_count;   /* count of colors in palette        */
	unsigned short  *_color_pairs;  /* screen's color pair list          */
	int             _pair_count;    /* count of color pairs              */
d816 11
a826 8
	bool            _default_color; /* use default colors                */
	bool            _has_sgr_39_49; /* has ECMA default color support    */
	int             _default_fg;    /* assumed default foreground        */
	int             _default_bg;    /* assumed default background        */
#endif
	chtype          _xmc_suppress;  /* attributes to suppress if xmc     */
	chtype          _xmc_triggers;  /* attributes to process if xmc      */
	chtype          _acs_map[ACS_LEN];
d829 2
a830 2
	bool            _use_rmso;	/* true if we may use 'rmso'         */
	bool            _use_rmul;	/* true if we may use 'rmul'         */
d839 2
a840 2
	bool            _nc_sp_idlok;
	bool            _nc_sp_idcok;
d847 44
a890 7
	int             _maxclick;
	bool            (*_mouse_event) (SCREEN *);
	bool            (*_mouse_inline)(SCREEN *);
	bool            (*_mouse_parse) (int);
	void            (*_mouse_resume)(SCREEN *);
	void            (*_mouse_wrap)  (SCREEN *);
	int             _mouse_fd;      /* file-descriptor, if any */
d899 1
a899 1
        /*
d903 1
a903 7
        struct panelhook _panelHook;
	/*
	 * Linked-list of all windows, to support '_nc_resizeall()' and
	 * '_nc_freeall()'
	 */
	WINDOWLIST      *_nc_sp_windows;
#define _nc_windows SP->_nc_sp_windows
d905 2
a906 2
	bool            _sig_winch;
	SCREEN          *_next_screen;
d910 21
d932 14
a945 2
	bool            _cleanup;	/* cleanup after int/quit signal */
	int             (*_outch)(int);	/* output handler if not putc */
d949 1
a949 4

#if NCURSES_NOMACROS
#include <nomacros.h>
#endif
d952 1
d954 7
a960 1
	WINDOW	*win;
d963 6
a968 5
typedef	struct {
	int	line;                   /* lines to take, < 0 => from bottom*/
	int	(*hook)(struct _win_st *, int); /* callback for user        */
	struct _win_st *w;              /* maybe we need this for cleanup   */
} ripoff_t;
d973 3
d1026 93
a1118 3
#define CharOf(c)    ((unsigned char)(c))
#define TextOf(c)    ((c) & (chtype)A_CHARTEXT)
#define AttrOf(c)    ((c) & (chtype)A_ATTRIBUTES)
d1120 54
a1173 1
#define BLANK        (' '|A_NORMAL)
d1177 5
d1216 24
d1244 3
a1246 3
#define T_CALLED(fmt) "called " fmt
#define T_CREATE(fmt) "create " fmt
#define T_RETURN(fmt) "return " fmt
d1249 28
a1276 1
#define TR(n, a)	if (_nc_tracing & (n)) _tracef a
a1277 1
#define TPUTS_TRACE(s)	_nc_tputs_trace = s;
d1279 38
a1316 10
#define returnAttr(code) TRACE_RETURN(code,attr_t)
#define returnChar(code) TRACE_RETURN(code,chtype)
#define returnCode(code) TRACE_RETURN(code,int)
#define returnPtr(code)  TRACE_RETURN(code,ptr)
#define returnVoid       T((T_RETURN(""))); return
#define returnWin(code)  TRACE_RETURN(code,win)
extern NCURSES_EXPORT(WINDOW *) _nc_retrace_win (WINDOW *);
extern NCURSES_EXPORT(attr_t) _nc_retrace_attr_t (attr_t);
extern NCURSES_EXPORT(attr_t) _nc_retrace_chtype (chtype);
extern NCURSES_EXPORT(char *) _nc_retrace_ptr (char *);
d1318 17
a1334 4
extern NCURSES_EXPORT(int) _nc_retrace_int (int);
extern NCURSES_EXPORT_VAR(long) _nc_outchars;
extern NCURSES_EXPORT(void) _nc_fifo_dump (void);
#else
a1337 7
#define returnAttr(code) return code
#define returnChar(code) return code
#define returnCode(code) return code
#define returnPtr(code)  return code
#define returnVoid       return
#define returnWin(code)  return code
#endif
d1339 22
a1360 1
extern NCURSES_EXPORT_VAR(unsigned) _nc_tracing;
d1362 1
d1364 3
a1366 1
#define _trace_key(ch) ((ch > KEY_MIN) ? keyname(ch) : _tracechar((unsigned char)ch))
d1369 1
a1369 2
#define IGNORE_COLOR_OFF FALSE
#define NONBLANK_ATTR (A_BOLD|A_DIM|A_BLINK)
a1371 1

d1373 1
a1373 1
   if (PAIR_NUMBER(at) > 0)\
d1375 1
a1375 1
   else\
d1377 1
d1382 2
a1383 5
   if (IGNORE_COLOR_OFF == TRUE) {\
      if (PAIR_NUMBER(at) == 0xff) /* turn off color */\
	 (S) &= ~(at);\
      else /* leave color alone */\
	 (S) &= ~((at)&ALL_BUT_COLOR);\
d1385 1
a1385 4
      if (PAIR_NUMBER(at) > 0x00) /* turn off color */\
	 (S) &= ~(at|A_COLOR);\
      else /* leave color alone */\
	 (S) &= ~(at);\
d1402 1
a1402 1
		    ? (SP->_ich1_cost * count) \
d1406 3
a1408 3
#define UpdateAttrs(c)	if (SP->_current_attr != AttrOf(c)) { \
				attr_t chg = SP->_current_attr; \
				vidattr(AttrOf(c)); \
d1410 2
a1411 3
				 && XMC_CHANGES((chg ^ SP->_current_attr))) { \
					TR(TRACE_ATTRS, \
						("%s @@%d before glitch %d,%d", \
d1419 15
a1433 2
#define UpdateAttrs(c)	if (SP->_current_attr != AttrOf(c)) \
				vidattr(AttrOf(c))
d1456 1
a1456 1
extern NCURSES_EXPORT(void) _nc_UpdateAttrs (chtype);
d1464 4
d1472 22
d1508 19
d1545 23
d1570 4
a1573 3
    char *s_head;
    char *s_tail;
    size_t s_size;
d1577 5
a1581 15
extern NCURSES_EXPORT(string_desc *) _nc_str_init (string_desc * dst, char *src, size_t len);
extern NCURSES_EXPORT(string_desc *) _nc_str_null (string_desc * dst, size_t len);
extern NCURSES_EXPORT(string_desc *) _nc_str_copy (string_desc * dst, string_desc * src);
extern NCURSES_EXPORT(bool) _nc_safe_strcat (string_desc * dst, const char *src);
extern NCURSES_EXPORT(bool) _nc_safe_strcpy (string_desc * dst, const char *src);

extern NCURSES_EXPORT(void) _nc_mvcur_init (void);
extern NCURSES_EXPORT(void) _nc_mvcur_resume (void);
extern NCURSES_EXPORT(void) _nc_mvcur_wrap (void);

extern NCURSES_EXPORT(int) _nc_scrolln (int, int, int, int);

extern NCURSES_EXPORT(void) _nc_screen_init (void);
extern NCURSES_EXPORT(void) _nc_screen_resume (void);
extern NCURSES_EXPORT(void) _nc_screen_wrap (void);
d1589 1
a1589 1
extern NCURSES_EXPORT(char *) _nc_printf_string (const char *fmt, va_list ap);
d1592 4
a1595 4
extern NCURSES_EXPORT(void) _nc_add_to_try (struct tries **tree, const char *str, unsigned short code);
extern NCURSES_EXPORT(char *) _nc_expand_try (struct tries *tree, unsigned short code, int *count, size_t len);
extern NCURSES_EXPORT(int) _nc_remove_key (struct tries **tree, unsigned short code);
extern NCURSES_EXPORT(int) _nc_remove_string (struct tries **tree, char *string);
d1598 4
a1602 1
extern NCURSES_EXPORT(char *) _nc_home_terminfo (void);
d1604 4
a1607 3
extern NCURSES_EXPORT(chtype) _nc_background (WINDOW *);
extern NCURSES_EXPORT(chtype) _nc_render (WINDOW *, chtype);
extern NCURSES_EXPORT(int)  _nc_access (const char *, int);
d1609 1
a1609 1
extern NCURSES_EXPORT(int) _nc_freewin (WINDOW *win);
d1611 1
a1611 1
extern NCURSES_EXPORT(int) _nc_keypad (bool);
d1614 4
a1617 4
extern NCURSES_EXPORT(int) _nc_setupscreen (short, short const, FILE *);
extern NCURSES_EXPORT(int) _nc_timed_wait (int, int, int *);
extern NCURSES_EXPORT(int) _nc_waddch_nosync (WINDOW *, const chtype);
extern NCURSES_EXPORT(void) _nc_do_color (int, int, bool, int (*)(int));
d1619 2
d1623 1
a1623 1
extern NCURSES_EXPORT(void) _nc_init_keytry (void);
a1625 1
extern NCURSES_EXPORT(void) _nc_outstr (const char *str);
a1627 1
extern NCURSES_EXPORT(void) _nc_scroll_window (WINDOW *, int const, short const, short const, chtype);
d1630 23
a1652 2
extern NCURSES_EXPORT(void) _nc_synchook (WINDOW *win);
extern NCURSES_EXPORT(void) _nc_trace_tries (struct tries *tree);
d1655 1
a1655 1
extern NCURSES_EXPORT(void) _nc_update_screensize (void);
d1658 18
a1675 2
#if USE_WIDEC_SUPPORT
extern NCURSES_EXPORT(int) _nc_utf8_outch (int);
d1683 1
a1683 3
#define NC_BUFFERED(flag) \
	if ((SP->_buffered != 0) != flag) \
		_nc_set_buffer(SP->_ofp, flag)
d1704 3
a1706 4
 * We don't want to use the lines or columns capabilities internally,
 * because if the application is running multiple screens under
 * the X Window System, it's quite possible they could all have type xterm
 * but have different sizes!  So...
a1710 1
extern NCURSES_EXPORT_VAR(int) _nc_slk_format;  /* != 0 if slk_init() called */
d1730 6
@


1.31
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.30 2000/10/10 15:10:29 millert Exp $	*/
d827 1
a827 1
 * X windows, it's quite possible they could all have type xterm
@


1.30
log
@Don't ignore $TERMCAP, $TERMINFO, $TERMINFO_DIRS, $TERMPATH, and $HOME
if root but not setugid.

Fix select usage to deal with an arbitrary number of fd's.  This code
is not compiled since we use poll(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.29 2000/10/08 22:46:55 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.168 2000/10/08 01:24:59 tom Exp $
d50 13
d174 1
a174 1
extern int _nc_env_access(void);
d185 1
a185 1
extern void * _nc_memmove(void *, const void *, size_t);
d436 1
a436 1
extern SCREEN *_nc_screen_chain;
d506 1
d567 8
a574 8
extern WINDOW * _nc_retrace_win(WINDOW *);
extern attr_t _nc_retrace_attr_t(attr_t);
extern attr_t _nc_retrace_chtype(chtype);
extern char *_nc_retrace_ptr(char *);
extern const char *_nc_tputs_trace;
extern int _nc_retrace_int(int);
extern long _nc_outchars;
extern void _nc_fifo_dump(void);
d587 2
a588 2
extern unsigned _nc_tracing;
extern const char *_nc_visbuf2(int, const char *);
d659 1
a659 1
extern void _nc_toggle_attr_on(attr_t *, attr_t);
d663 1
a663 1
extern void _nc_toggle_attr_off(attr_t *, attr_t);
d667 1
a667 1
extern int _nc_DelCharCost(int);
d671 1
a671 1
extern int _nc_InsCharCost(int);
d675 1
a675 1
extern void _nc_UpdateAttrs(chtype);
d679 1
a679 1
extern void _nc_expanded(void);
d689 1
a689 1
extern void _nc_do_xmc_glitch(attr_t);
d694 1
a694 1
extern void _nc_linedump(void);
d698 2
a699 2
extern void _nc_init_acs(void);	/* corresponds to traditional 'init_acs()' */
extern int _nc_msec_cost(const char *const, int);  /* used by 'tack' program */
d704 9
a712 9
extern void _nc_mvcur_init(void);
extern void _nc_mvcur_resume(void);
extern void _nc_mvcur_wrap(void);

extern int _nc_scrolln(int, int, int, int);

extern void _nc_screen_init(void);
extern void _nc_screen_resume(void);
extern void _nc_screen_wrap(void);
d715 1
a715 1
extern int _nc_has_mouse(void);
d727 15
a741 15
extern string_desc *_nc_str_init(string_desc * dst, char *src, size_t len);
extern string_desc *_nc_str_null(string_desc * dst, size_t len);
extern string_desc *_nc_str_copy(string_desc * dst, string_desc * src);
extern bool _nc_safe_strcat(string_desc * dst, const char *src);
extern bool _nc_safe_strcpy(string_desc * dst, const char *src);

extern void _nc_mvcur_init(void);
extern void _nc_mvcur_resume(void);
extern void _nc_mvcur_wrap(void);

extern int _nc_scrolln(int, int, int, int);

extern void _nc_screen_init(void);
extern void _nc_screen_resume(void);
extern void _nc_screen_wrap(void);
d745 1
a745 1
extern char *_nc_strstr(const char *, const char *);
d749 1
a749 1
extern char * _nc_printf_string(const char *fmt, va_list ap);
d752 4
a755 4
extern void _nc_add_to_try(struct tries **tree, const char *str, unsigned short code);
extern char *_nc_expand_try(struct tries *tree, unsigned short code, int *count, size_t len);
extern int _nc_remove_key(struct tries **tree, unsigned short code);
extern int _nc_remove_string(struct tries **tree, char *string);
d758 30
a787 30
extern WINDOW *_nc_makenew(int, int, int, int, int);
extern char *_nc_home_terminfo(void);
extern char *_nc_trace_buf(int, size_t);
extern chtype _nc_background(WINDOW *);
extern chtype _nc_render(WINDOW *, chtype);
extern int _nc_access(const char *, int);
extern int _nc_baudrate(int);
extern int _nc_getenv_num(const char *);
extern int _nc_keypad(bool);
extern int _nc_ospeed(int);
extern int _nc_outch(int);
extern int _nc_setupscreen(short, short const, FILE *);
extern int _nc_timed_wait(int, int, int *);
extern int _nc_waddch_nosync(WINDOW *, const chtype);
extern void _nc_do_color(int, int, bool, int (*)(int));
extern void _nc_freeall(void);
extern void _nc_freewin(WINDOW *win);
extern void _nc_hash_map(void);
extern void _nc_init_keytry(void);
extern void _nc_keep_tic_dir(const char *);
extern void _nc_make_oldhash(int i);
extern void _nc_flush(void);
extern void _nc_outstr(const char *str);
extern void _nc_scroll_oldhash(int n, int top, int bot);
extern void _nc_scroll_optimize(void);
extern void _nc_scroll_window(WINDOW *, int const, short const, short const, chtype);
extern void _nc_set_buffer(FILE *, bool);
extern void _nc_signal_handler(bool);
extern void _nc_synchook(WINDOW *win);
extern void _nc_trace_tries(struct tries *tree);
d790 1
a790 1
extern void _nc_update_screensize(void);
d794 1
a794 1
extern int _nc_utf8_outch(int);
d798 1
a798 1
extern int *_nc_oldnums;
d814 3
a816 3
extern SCREEN *_nc_screen(void);
extern int _nc_alloc_screen(void);
extern void _nc_set_screen(SCREEN *);
d819 1
a819 1
extern SCREEN *SP;
d833 2
a834 2
extern int _nc_slk_format;  /* != 0 if slk_init() called */
extern int _nc_slk_initialize(WINDOW *, int);
d852 1
a852 1
extern int _nc_ripoffline(int line, int (*init)(WINDOW *,int));
@


1.29
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.28 2000/07/10 03:06:10 millert Exp $	*/
d154 3
d158 1
@


1.28
log
@ncurses 5.1
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.27 2000/06/19 03:53:35 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.162 2000/06/24 21:06:10 tom Exp $
d104 1
a104 1
#ifdef HAVE_POLL_H
d139 1
a139 1
#ifndef NCURSES_EXT_FUNCS
d150 11
d304 1
a304 1
#ifdef NCURSES_NO_PADDING
d345 1
a345 3
	int             _carriage_return_length;
	int             _cursor_home_length;
	int             _cursor_to_ll_length;
d353 1
a353 1
#ifdef NCURSES_EXT_FUNCS
d421 1
a421 1
#ifdef NCURSES_NOMACROS
d544 1
d551 1
d562 1
d585 1
a585 1
   T(("new attribute is %s", _traceattr((S))));}
d600 1
a600 1
   T(("new attribute is %s", _traceattr((S))));}
d624 2
a625 1
					T(("%s @@%d before glitch %d,%d", \
d637 1
a637 1
#if defined(NCURSES_EXPANDED) && defined(NCURSES_EXT_FUNCS)
d696 29
a729 3
/* lib_mouse.c */
extern int _nc_has_mouse(void);

d775 1
a775 1
#ifdef USE_WIDEC_SUPPORT
a793 4
#ifndef BROKEN_LINKER
#define BROKEN_LINKER 0
#endif

@


1.27
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.26 2000/03/26 16:45:03 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.161 2000/05/27 23:10:03 tom Exp $
d315 1
a315 1
	/* used in lib_doupdate.c, must be chars */
d327 2
@


1.26
log
@Update to ncurses-5.0-20000325
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.25 2000/03/10 01:35:01 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.157 2000/03/26 01:01:14 tom Exp $
d405 1
a508 4
#define typeMalloc(type,elts) (type *)malloc((elts)*sizeof(type))
#define typeCalloc(type,elts) (type *)calloc((elts),sizeof(type))
#define typeRealloc(type,elts,ptr) (type *)_nc_doalloc(ptr, (elts)*sizeof(type))

a653 7
/* doalloc.c */
extern void *_nc_doalloc(void *, size_t);
#if !HAVE_STRDUP
#define strdup _nc_strdup
extern char *_nc_strdup(const char *);
#endif

d720 1
d725 1
a725 1
extern void _nc_set_buffer(FILE *ofp, bool buffered);
d734 4
a747 1
#define _nc_flush() (void)fflush(NC_OUTPUT)
@


1.25
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.24 2000/02/06 07:10:50 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.153 2000/02/19 23:31:39 tom Exp $
d343 2
a344 1
	int             _default_color; /* use default colors                */
d625 1
a625 1
#ifdef NCURSES_EXPANDED
d703 1
a703 1
extern void _nc_add_to_try(struct tries **tree, char *str, unsigned short code);
d723 1
a723 1
extern void _nc_do_color(int, bool, int (*)(int));
@


1.24
log
@ncurses-5.0-20000205
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.23 2000/01/09 05:06:01 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d38 1
a38 1
 * $From: curses.priv.h,v 1.151 2000/02/06 01:57:01 tom Exp $
a623 9
/*
 * Check whether the given character can be output by clearing commands.  This
 * includes test for being a space and not including any 'bad' attributes, such
 * as A_REVERSE.  All attribute flags which don't affect appearance of a space
 * or can be output by clearing (A_COLOR in case of bce-terminal) are excluded.
 */
#define can_clear_with(ch) \
	((ch & ~(NONBLANK_ATTR|(back_color_erase ? A_COLOR:0))) == BLANK)

a632 4

#undef  can_clear_with
#define can_clear_with(ch) _nc_can_clear_with(ch)
extern int _nc_can_clear_with(chtype);
@


1.23
log
@Update to ncurses-5.0-20000108:
+ add prototype for erase() to curses.h
+ add TRACE_DATABASE flag for trace().
+ formatting changes (style)
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.22 1999/12/06 02:13:31 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.149 2000/01/08 17:17:39 tom Exp $
d102 1
a102 1
#if HAVE_POLL && HAVE_SYS_STROPTS_H && HAVE_POLL_H
d104 5
@


1.22
log
@update to ncurses-5.0-19991204
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.21 1999/11/28 17:53:40 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.148 1999/12/04 18:09:40 tom Exp $
d461 8
@


1.21
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.20 1999/07/04 12:43:22 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.147 1999/11/28 00:10:37 tom Exp $
d493 1
d497 7
a503 2
#define FreeIfNeeded(p)  if(p != 0) free(p)
#define FreeAndNull(p)   free(p); p = 0;
@


1.20
log
@ncurses-5.0-990703 -- better support for mixing termcap and terminfo/curses routines
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.19 1999/06/27 08:15:19 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.142 1999/07/04 01:21:35 tom Exp $
d337 1
d339 3
d397 2
d497 1
a497 1
#define FreeAndNull(p)   free(p); p = 0
d549 1
a549 1
#define toggle_attr_on(S,at) \
d554 1
a554 1
   T(("new attribute is %s", _traceattr((S))))
d557 1
a557 1
#define toggle_attr_off(S,at) \
d569 1
a569 1
   T(("new attribute is %s", _traceattr((S))));
d602 1
a602 1
				vidattr(AttrOf(c));
d744 3
@


1.19
log
@ncurses-5.0-990626
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.18 1999/06/14 17:26:04 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.141 1999/06/26 22:00:49 tom Exp $
d424 4
@


1.18
log
@cvs skipped these files in the previous commit for mysterious reasons
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.17 1999/03/16 15:25:08 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.140 1999/06/12 21:19:47 tom Exp $
d673 5
@


1.17
log
@ncurses-4.2-990316
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.16 1999/03/15 19:12:21 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.139 1999/03/16 01:45:35 tom Exp $
d341 4
@


1.16
log
@ncurses-4.2-990314
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.15 1999/03/12 04:36:02 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.138 1999/03/14 12:25:18 tom Exp $
d630 4
@


1.15
log
@these somehow got missed in the earlier curses commit
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.14 1999/03/02 06:23:27 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.137 1999/03/03 23:43:39 juergen Exp $
d636 1
a636 1
extern char *_nc_strdup(char *);
@


1.14
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.13 1999/02/24 06:31:07 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.136 1999/02/28 01:50:50 tom Exp $
d286 1
a286 1

a761 3
#define MAX_SKEY          (SLK_STDFMT ? MAX_SKEY_OLD : MAX_SKEY_PC)
#define MAX_SKEY_LEN      (SLK_STDFMT ? MAX_SKEY_LEN_OLD : MAX_SKEY_LEN_PC)

d763 1
a763 1
#define SLK_STDFMT (_nc_slk_format < 3)
d765 4
a768 1
#define SLK_LINES  (SLK_STDFMT ? 1 : (_nc_slk_format - 2))
@


1.13
log
@ncurses-4.2-990220; this is a pre-release of 5.0
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.12 1999/02/24 05:36:10 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.131 1999/02/19 11:38:48 tom Exp $
d479 3
a481 1
#define typeCalloc(type,elts) (type *)calloc(elts,sizeof(type))
d634 4
@


1.12
log
@ncurses-990213
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.11 1999/01/18 19:07:18 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.127 1999/02/09 23:24:52 tom Exp $
d644 1
a644 1
extern void init_acs(void);	/* no prefix, this name is traditional */
d668 1
a668 1
extern char *_nc_expand_try(struct tries *tree, unsigned short code, size_t len);
d670 1
d691 1
d701 1
@


1.11
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.10 1998/10/31 06:30:28 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.126 1999/01/03 01:00:41 tom Exp $
d706 2
@


1.10
log
@update to ncurses 4.2-981017
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.9 1998/09/17 04:14:30 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.123 1998/10/03 23:35:34 tom Exp $
d288 3
d678 1
d681 1
d690 1
@


1.9
log
@ncurses-4.2-980912
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.8 1998/09/13 19:16:25 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.110 1998/09/12 22:50:21 tom Exp $
d122 5
d145 12
a156 1
 * As currently coded, hashmap relies on the scroll-hints logic.
d159 1
a159 1
#if USE_HASHMAP
d196 7
d251 1
d319 3
d383 3
a500 1
extern unsigned _nc_tracing;
d519 1
d562 5
a566 3
		: ((insert_character != 0) \
			? (SP->_ich1_cost * count) \
			: INFINITY))
d636 1
a636 1
#if defined(TRACE) || defined(SCROLLDEBUG)
a662 4
/* softscroll.c */
extern void _nc_setup_scroll(void);
extern void _nc_perform_scroll(void);

d670 1
d675 1
d685 1
d687 1
d698 3
d702 1
a702 1
	if ((SP->_setbuf == 0) != flag) \
d737 2
a738 2
/* 
 * Some constants related to SLK's 
@


1.8
log
@ncurses-4.2-980905
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.7 1998/07/27 03:37:30 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.109 1998/09/05 22:10:02 tom Exp $
d665 4
@


1.7
log
@update to ncurses-4.2-980725
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.6 1998/07/23 21:18:12 millert Exp $	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.106 1998/07/25 20:07:29 tom Exp $
a489 1
extern const char *_nc_visbuf(const char *);
d595 3
a607 5
/* hardscroll.c */
#if defined(TRACE) || defined(SCROLLDEBUG)
extern void _nc_linedump(void);
#endif

a651 1
extern void _nc_free_and_exit(int);
@


1.6
log
@ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
 * $From: curses.priv.h,v 1.105 1998/06/28 00:11:47 tom Exp $
d648 1
@


1.5
log
@Use _ti_get_screensize() from libtermlib to update screen size if changed
    after a program is suspended.
Define EXTERN_TERMINFO in curses.h.
Update to ncurses-4.1-980103 and crank minor.
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.4 1997/12/06 19:11:03 millert Exp $	*/
d3 32
a34 20

/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d38 1
a38 1
 * Id: curses.priv.h,v 1.97 1998/01/03 19:57:54 tom Exp $
d115 7
d123 1
a228 3
#ifdef EXTERN_TERMINFO
	struct _terminal *_term;         /* terminal type information        */
#else
a229 1
#endif
d241 1
a261 1
	int		_baudrate;	/* used to compute padding          */
d423 22
a475 2
extern const char *_nc_visbuf(const char *);
extern const char *_nc_visbuf2(int, const char *);
d490 3
a648 3
#ifdef EXTERN_TERMINFO
#define	_nc_outch _ti_outc
#endif
d653 1
a653 1
extern void _nc_do_color(int, int (*)(int));
a688 14
#if !HAVE_USLEEP
extern int _nc_usleep(unsigned int);
#define usleep(msecs) _nc_usleep(msecs)
#endif

/*
 * ncurses' terminfo defines these but since we use our own terminfo
 * we need to fake it here.
 */
#ifdef EXTERN_TERMINFO
#define	_nc_get_curterm(buf) tcgetattr(cur_term->Filedes, buf)
#define	_nc_set_curterm(buf) tcsetattr(cur_term->Filedes, TCSADRAIN, buf)
#endif

d701 2
a702 2
/*
 * Some constants related to SLK's
a717 2

#define UNINITIALISED ((struct tries * ) -1)
@


1.4
log
@#ifdef out call to _nc_update_screensize
@
text
@d1 1
a1 1
/*	$OpenBSD: curses.priv.h,v 1.3 1997/12/03 05:21:07 millert Exp $	*/
d26 1
a26 1
 * Id: curses.priv.h,v 1.93 1997/11/01 23:01:54 tom Exp $
d106 14
d284 1
d322 1
d324 1
a556 3
/* comp_scan.c */
extern char _nc_trans_string(char *); /* used by 'tack' program */

d610 3
a612 3
#ifdef EXTERN_TERMINFO                                                      
#define	_nc_outch _ti_outc                                                  
#endif                                                                      
d628 2
a629 1
#ifndef EXTERN_TERMINFO
d662 1
a662 1
#ifdef EXTERN_TERMINFO                                                      
d665 1
a665 1
#endif                                                                      
d679 2
a680 2
/* 
 * Some constants related to SLK's 
@


1.3
log
@Merge of ncurses-4.1-971129
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d614 1
d616 1
@


1.2
log
@ncurses 4.1 + changes to work with our terminfo libs (instead of
the ncurses ones).  Changes are #ifdef EXTERN_TERMINFO.
Post 4.1 patches will be applied in a separate commit.
@
text
@d1 2
d26 1
a26 1
 * Id: curses.priv.h,v 1.61 1997/04/26 20:54:54 tom Exp $
d38 4
d44 1
a44 1
#ifdef USE_RCS_IDS
d83 1
a83 1
#if !HAVE_EXTERN_ERRNO
d87 2
d103 2
d106 1
a106 5
 * ht/cbt expansion flakes out randomly under Linux 1.1.47, but only when
 * we're throwing control codes at the screen at high volume.  To see this,
 * re-enable TABS_OK and run worm for a while.  Other systems probably don't
 * want to define this either due to uncertainties about tab delays and
 * expansion in raw mode.
d108 13
a120 1
#undef TABS_OK	/* OK to use tab/backtab for local motions? */
d123 5
a127 2
 * The internal types (e.g., struct screen) must precede <curses.h>, otherwise
 * we cannot construct lint-libraries (structures must be fully-defined).
a137 24
 * Structure for soft labels.
 */

typedef struct
{
	char *text;             /* text for the label */
	char *form_text;        /* formatted text (left/center/...) */
	int x;                  /* x coordinate of this field */
	char dirty;             /* this label has changed */
	char visible;           /* field is visible */
} slk_ent;

typedef struct {
	char dirty;             /* all labels have changed */
	char hidden;            /* soft labels are hidden */
	struct _win_st *win;
	slk_ent *ent;
	char *buffer;           /* buffer for labels */
	short maxlab;           /* number of available labels */
	short labcnt;           /* number of allocated labels */
	short maxlen;           /* length of labels */
} SLK;

/*
d157 32
a188 1
#define FIFO_SIZE     MAXLINES
d204 5
a208 3
	struct _win_st  *_curscr;       /* current screen                   */
	struct _win_st  *_newscr;       /* virtual screen to be updated to  */
	struct _win_st  *_stdscr;       /* screen's full-window context     */
d210 2
d213 1
a213 1
	signed char     _fifohead,      /* head of fifo queue               */
d215 3
a217 1
	                _fifopeek;      /* where to peek for next char      */
d231 1
a231 1
	int             _baudrate;      /* used to compute padding          */
d239 1
a239 1
#ifdef TABS_OK
d242 1
a242 1
#endif /* TABS_OK */
d270 1
d277 46
d325 1
a325 2
/* Ncurses' public interface follows the internal types */
#include <curses.h>	/* we'll use -Ipath directive to get the right one! */
a330 1
#define WINDOWLIST struct _win_list
d390 1
d411 2
a412 1
#define returnWin(code)  TRACE_RETURN(code,win)
a413 1
#define returnCode(code) TRACE_RETURN(code,int)
d415 1
d418 1
d425 1
d430 1
a430 1
#define returnWin(code)  return code
d432 1
d434 1
d441 2
a442 7


/* Macro to put together character and attribute info and return it.
   If colors are in the attribute, they have precedence. */
#define ch_or_attr(ch,at) \
    ((PAIR_NUMBER(at) > 0) ? \
     ((((chtype)ch) & ALL_BUT_COLOR) | (at)) : ((((chtype)ch) | (at))))
d481 14
d497 1
a504 1
#define NONBLANK_ATTR (A_BOLD|A_DIM|A_BLINK)
a509 4
#undef  ch_or_attr
#define ch_or_attr(ch,at) _nc_ch_or_attr(ch,at)
extern chtype _nc_ch_or_attr(chtype, attr_t);

d540 18
d560 1
d568 6
a573 1
extern int _nc_mvcur_scrolln(int, int, int, int);
d576 13
a588 8
extern void _nc_mouse_init(SCREEN *);
extern bool _nc_mouse_event(SCREEN *);
extern bool _nc_mouse_inline(SCREEN *);
extern bool _nc_mouse_parse(int);
extern void _nc_mouse_wrap(SCREEN *);
extern void _nc_mouse_resume(SCREEN *);
extern int _nc_max_click_interval;
extern int _nc_mouse_fd(void);
d592 1
a594 2
extern char *_nc_trace_buf(int, size_t);
extern int _nc_initscr(void);
a602 1
extern void _nc_backspace(WINDOW *win);
d604 1
a605 1
extern void _nc_free_and_exit(int);
a606 1
extern void _nc_get_screensize(void);
d610 1
a610 1
extern void _nc_scroll_window(WINDOW *, int const, short const, short const);
d614 1
d630 1
d642 2
a643 2
 * ncurses' term.h defines this but since we use our own terminfo
 * we need to define it here.
d646 2
a647 2
#define	GET_TTY(fd, buf) tcgetattr(fd, buf)
#define	SET_TTY(fd, buf) tcsetattr(fd, TCSADRAIN, buf)
d662 11
d682 3
a684 3
extern bool _nc_idlok, _nc_idcok;

extern WINDOWLIST *_nc_windows;
@


1.1
log
@Install ncurses as -lcurses and <curses.h>
Install BSD curses library as -locurses and <ocurses.h>
@
text
@d24 2
d33 14
a46 1
#include <config.h>
d52 4
d68 1
a68 1
#  define PATH_MAX 255	/* the Posix minimum pathsize */
d73 84
d158 87
d247 16
d283 8
d311 6
d318 3
a320 5
 * ht/cbt expansion flakes out randomly under Linux 1.1.47, but only when
 * we're throwing control codes at the screen at high volume.  To see this, 
 * re-enable TABS_OK and run worm for a while.  Other systems probably don't
 * want to define this either due to uncertainties about tab delays and
 * expansion in raw mode. 
d322 3
a324 1
#undef TABS_OK	/* OK to use tab/backtab for local motions? */
d327 2
a328 2
#define T(a)	if (_nc_tracing & TRACE_CALLS) _tracef a 
#define TR(n, a)	if (_nc_tracing & (n)) _tracef a 
d330 5
d336 8
a343 3
extern char *_nc_tputs_trace;
extern char *_nc_visbuf(const char *);
#else	
d347 101
d454 4
a457 1
extern void _nc_mvcur_init(SCREEN *sp);
d469 1
d472 9
a480 5
extern int _nc_keypad(bool flag);
extern WINDOW *_nc_makenew(int, int, int, int);
#ifdef EXTERN_TERMINFO
#define _nc_outch _ti_outc
#endif
d482 2
a483 1
extern chtype _nc_render(WINDOW *, chtype, chtype);
d485 8
d495 1
a495 3
extern int _nc_setupscreen(short, short const);
extern void _nc_backspace(WINDOW *win);
extern void _nc_outstr(char *str);
a497 84
extern int _nc_timed_wait(int fd, int wait, int *timeleft);
extern void _nc_do_color(int, int (*)(int));

struct try {
        struct try      *child;     /* ptr to child.  NULL if none          */
        struct try      *sibling;   /* ptr to sibling.  NULL if none        */
        unsigned char    ch;        /* character at this node               */
        unsigned short   value;     /* code of string so far.  0 if none.   */
};
  
/*
 * Structure for soft labels.
 */
  
typedef struct {
	char dirty;			/* all labels have changed */
	char hidden;			/* soft lables are hidden */
	WINDOW *win;
 	struct slk_ent {
 	    char text[9];		/* text for the label */
 	    char form_text[9];		/* formatted text (left/center/...) */
 	    int x;			/* x coordinate of this field */
 	    char dirty;			/* this label has changed */
 	    char visible;		/* field is visible */
	} ent[8];
} SLK;

#define FIFO_SIZE	32

struct screen {
       	int		_ifd;	    	/* input file ptr for screen        */
   	FILE		*_ofp;	    	/* output file ptr for screen       */
   	int		_checkfd;	/* filedesc for typeahead check     */ 
#ifdef EXTERN_TERMINFO
	struct _terminal *_term;    	/* terminal type information        */
#else
	struct term	*_term;	    	/* terminal type information        */
#endif
	short		_lines;		/* screen lines			    */
	short		_columns;	/* screen columns		    */
	WINDOW		*_curscr;   	/* current screen                   */
	WINDOW		*_newscr;	/* virtual screen to be updated to  */
	WINDOW		*_stdscr;	/* screen's full-window context     */
	struct try  	*_keytry;   	/* "Try" for use with keypad mode   */
	unsigned int	_fifo[FIFO_SIZE]; 	/* input pushback buffer    */
	signed char	_fifohead, 	/* head of fifo queue               */
			_fifotail, 	/* tail of fifo queue               */
			_fifopeek;	/* where to peek for next char      */
	bool		_endwin;	/* are we out of window mode?       */
	chtype		_current_attr;	/* terminal attribute current set   */
	bool		_coloron;	/* is color enabled?                */
	int		_cursor;	/* visibility of the cursor         */
	int         	_cursrow;   	/* physical cursor row              */
	int         	_curscol;   	/* physical cursor column           */
	bool		_nl;	    	/* True if NL -> CR/NL is on        */
	bool		_raw;	    	/* True if in raw mode              */
	int		_cbreak;    	/* 1 if in cbreak mode              */
                       		    	/* > 1 if in halfdelay mode         */
	bool		_echo;	    	/* True if echo on                  */
	bool		_use_meta;      /* use the meta key?		    */
 	SLK		*_slk;	    	/* ptr to soft key struct / NULL    */
	int		_baudrate;	/* used to compute padding	    */

	/* cursor movement costs; units are 10ths of milliseconds */
	int		_char_padding;	/* cost of character put	    */
	int		_cr_cost;	/* cost of (carriage_return)	    */
	int		_cup_cost;	/* cost of (cursor_address)	    */
	int		_home_cost;	/* cost of (cursor_home)	    */
	int		_ll_cost;	/* cost of (cursor_to_ll)	    */
#ifdef TABS_OK
	int		_ht_cost;	/* cost of (tab)		    */
	int		_cbt_cost;	/* cost of (backtab)		    */
#endif /* TABS_OK */
	int		_cub1_cost;	/* cost of (cursor_left)	    */
	int		_cuf1_cost;	/* cost of (cursor_right)	    */
	int		_cud1_cost;	/* cost of (cursor_down)	    */
	int		_cuu1_cost;	/* cost of (cursor_up)		    */
	int		_cub_cost;	/* cost of (parm_cursor_left)	    */
	int		_cuf_cost;	/* cost of (parm_cursor_right)	    */
	int		_cud_cost;	/* cost of (parm_cursor_down)	    */
	int		_cuu_cost;	/* cost of (parm_cursor_up)	    */
	int		_hpa_cost;	/* cost of (column_address)	    */
	int		_vpa_cost;	/* cost of (row_address)	    */
};
d514 1
a514 1
#define _nc_alloc_screen() ((SP = (SCREEN *) calloc(1, sizeof(*SP))) != NULL)
d518 14
d541 2
a542 2
extern int _slk_init;			/* TRUE if slk_init() called */
extern int slk_initialize(WINDOW *, int);
d544 14
a557 3
#define MAXCOLUMNS    135
#define MAXLINES      66
#define UNINITIALISED ((struct try * ) -1)
@
