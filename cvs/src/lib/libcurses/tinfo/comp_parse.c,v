head	1.12;
access;
symbols
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.32
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.28
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.24
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.26
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.18
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.30
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.26
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.24
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.22
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.20
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.18
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.16
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.14
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.12
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.10
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.8
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.6
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.4
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.8
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.12
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.22.18.01.51;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.22.18.27.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.08.22.47.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.19.03.53.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.26.16.45.03;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.13.23.53.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.11.28.17.49.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.03.02.06.23.28;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.02.24.06.31.10;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.14;	author millert;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 *	comp_parse.c -- parser driver loop and use handling.
 *
 *	_nc_read_entry_source(FILE *, literal, bool, bool (*hook)())
 *	_nc_resolve_uses2(void)
 *	_nc_free_entries(void)
 *
 *	Use this code by calling _nc_read_entry_source() on as many source
 *	files as you like (either terminfo or termcap syntax).  If you
 *	want use-resolution, call _nc_resolve_uses2().  To free the list
 *	storage, do _nc_free_entries().
 *
 */

#include <curses.priv.h>

#include <ctype.h>

#include <tic.h>
#include <term_entry.h>

MODULE_ID("$Id: comp_parse.c,v 1.69 2008/08/16 21:58:16 tom Exp $")

static void sanity_check2(TERMTYPE *, bool);
NCURSES_IMPEXP void NCURSES_API(*_nc_check_termtype2) (TERMTYPE *, bool) = sanity_check2;

/* obsolete: 20040705 */
static void sanity_check(TERMTYPE *);
NCURSES_IMPEXP void NCURSES_API(*_nc_check_termtype) (TERMTYPE *) = sanity_check;

static void
enqueue(ENTRY * ep)
/* add an entry to the in-core list */
{
    ENTRY *newp = _nc_copy_entry(ep);

    if (newp == 0)
	_nc_err_abort(MSG_NO_MEMORY);

    newp->last = _nc_tail;
    _nc_tail = newp;

    newp->next = 0;
    if (newp->last)
	newp->last->next = newp;
}

static char *
force_bar(char *dst, char *src, size_t siz)
{
    if (strchr(src, '|') == 0) {
	    size_t len;

	    len = strlcpy(dst, src, siz);
	    if (len > siz - 2)
		len = siz - 2;
	    dst[len++] = '|';
	    dst[len] = '\0';
	    src = dst;
    }
    return src;
}

NCURSES_EXPORT(bool)
_nc_entry_match(char *n1, char *n2)
/* do any of the aliases in a pair of terminal names match? */
{
    char *pstart, *qstart, *pend, *qend;
    char nc1[MAX_NAME_SIZE + 2], nc2[MAX_NAME_SIZE + 2];

    n1 = force_bar(nc1, n1, sizeof(nc1));
    n2 = force_bar(nc2, n2, sizeof(nc2));

    for (pstart = n1; (pend = strchr(pstart, '|')); pstart = pend + 1)
	for (qstart = n2; (qend = strchr(qstart, '|')); qstart = qend + 1)
	    if ((pend - pstart == qend - qstart)
		&& memcmp(pstart, qstart, (size_t) (pend - pstart)) == 0)
		return (TRUE);

    return (FALSE);
}

/****************************************************************************
 *
 * Entry compiler and resolution logic
 *
 ****************************************************************************/

NCURSES_EXPORT(void)
_nc_read_entry_source(FILE *fp, char *buf,
		      int literal, bool silent,
		      bool(*hook) (ENTRY *))
/* slurp all entries in the given file into core */
{
    ENTRY thisentry;
    bool oldsuppress = _nc_suppress_warnings;
    int immediate = 0;

    if (silent)
	_nc_suppress_warnings = TRUE;	/* shut the lexer up, too */

    _nc_reset_input(fp, buf);
    for (;;) {
	memset(&thisentry, 0, sizeof(thisentry));
	if (_nc_parse_entry(&thisentry, literal, silent) == ERR)
	    break;
	if (!isalnum(UChar(thisentry.tterm.term_names[0])))
	    _nc_err_abort("terminal names must start with letter or digit");

	/*
	 * This can be used for immediate compilation of entries with no "use="
	 * references to disk.  That avoids consuming a lot of memory when the
	 * resolution code could fetch entries off disk.
	 */
	if (hook != NULLHOOK && (*hook) (&thisentry)) {
	    immediate++;
	} else {
	    enqueue(&thisentry);
	    /*
	     * The enqueued entry is copied with _nc_copy_termtype(), so we can
	     * free some of the data from thisentry, i.e., the arrays.
	     */
	    FreeIfNeeded(thisentry.tterm.Booleans);
	    FreeIfNeeded(thisentry.tterm.Numbers);
	    FreeIfNeeded(thisentry.tterm.Strings);
#if NCURSES_XNAMES
	    FreeIfNeeded(thisentry.tterm.ext_Names);
#endif
	}
    }

    if (_nc_tail) {
	/* set up the head pointer */
	for (_nc_head = _nc_tail; _nc_head->last; _nc_head = _nc_head->last)
	    continue;

	DEBUG(1, ("head = %s", _nc_head->tterm.term_names));
	DEBUG(1, ("tail = %s", _nc_tail->tterm.term_names));
    }
#ifdef TRACE
    else if (!immediate)
	DEBUG(1, ("no entries parsed"));
#endif

    _nc_suppress_warnings = oldsuppress;
}

NCURSES_EXPORT(int)
_nc_resolve_uses2(bool fullresolve, bool literal)
/* try to resolve all use capabilities */
{
    ENTRY *qp, *rp, *lastread = 0;
    bool keepgoing;
    unsigned i;
    int unresolved, total_unresolved, multiples;

    DEBUG(2, ("RESOLUTION BEGINNING"));

    /*
     * Check for multiple occurrences of the same name.
     */
    multiples = 0;
    for_entry_list(qp) {
	int matchcount = 0;

	for_entry_list(rp) {
	    if (qp > rp
		&& _nc_entry_match(qp->tterm.term_names, rp->tterm.term_names)) {
		matchcount++;
		if (matchcount == 1) {
		    (void) fprintf(stderr, "Name collision between %s",
				   _nc_first_name(qp->tterm.term_names));
		    multiples++;
		}
		if (matchcount >= 1)
		    (void) fprintf(stderr, " %s", _nc_first_name(rp->tterm.term_names));
	    }
	}
	if (matchcount >= 1)
	    (void) putc('\n', stderr);
    }
    if (multiples > 0)
	return (FALSE);

    DEBUG(2, ("NO MULTIPLE NAME OCCURRENCES"));

    /*
     * First resolution stage: compute link pointers corresponding to names.
     */
    total_unresolved = 0;
    _nc_curr_col = -1;
    for_entry_list(qp) {
	unresolved = 0;
	for (i = 0; i < qp->nuses; i++) {
	    bool foundit;
	    char *child = _nc_first_name(qp->tterm.term_names);
	    char *lookfor = qp->uses[i].name;
	    long lookline = qp->uses[i].line;

	    foundit = FALSE;

	    _nc_set_type(child);

	    /* first, try to resolve from in-core records */
	    for_entry_list(rp) {
		if (rp != qp
		    && _nc_name_match(rp->tterm.term_names, lookfor, "|")) {
		    DEBUG(2, ("%s: resolving use=%s (in core)",
			      child, lookfor));

		    qp->uses[i].link = rp;
		    foundit = TRUE;
		}
	    }

	    /* if that didn't work, try to merge in a compiled entry */
	    if (!foundit) {
		TERMTYPE thisterm;
		char filename[PATH_MAX];

		memset(&thisterm, 0, sizeof(thisterm));
		if (_nc_read_entry(lookfor, filename, &thisterm) == 1) {
		    DEBUG(2, ("%s: resolving use=%s (compiled)",
			      child, lookfor));

		    rp = typeMalloc(ENTRY, 1);
		    if (rp == 0)
			_nc_err_abort(MSG_NO_MEMORY);
		    rp->tterm = thisterm;
		    rp->nuses = 0;
		    rp->next = lastread;
		    lastread = rp;

		    qp->uses[i].link = rp;
		    foundit = TRUE;
		}
	    }

	    /* no good, mark this one unresolvable and complain */
	    if (!foundit) {
		unresolved++;
		total_unresolved++;

		_nc_curr_line = lookline;
		_nc_warning("resolution of use=%s failed", lookfor);
		qp->uses[i].link = 0;
	    }
	}
    }
    if (total_unresolved) {
	/* free entries read in off disk */
	_nc_free_entries(lastread);
	return (FALSE);
    }

    DEBUG(2, ("NAME RESOLUTION COMPLETED OK"));

    /*
     * OK, at this point all (char *) references in `name' members
     * have been successfully converted to (ENTRY *) pointers in
     * `link' members.  Time to do the actual merges.
     */
    if (fullresolve) {
	do {
	    TERMTYPE merged;

	    keepgoing = FALSE;

	    for_entry_list(qp) {
		if (qp->nuses > 0) {
		    DEBUG(2, ("%s: attempting merge",
			      _nc_first_name(qp->tterm.term_names)));
		    /*
		     * If any of the use entries we're looking for is
		     * incomplete, punt.  We'll catch this entry on a
		     * subsequent pass.
		     */
		    for (i = 0; i < qp->nuses; i++)
			if (qp->uses[i].link->nuses) {
			    DEBUG(2, ("%s: use entry %d unresolved",
				      _nc_first_name(qp->tterm.term_names), i));
			    goto incomplete;
			}

		    /*
		     * First, make sure there is no garbage in the
		     * merge block.  As a side effect, copy into
		     * the merged entry the name field and string
		     * table pointer.
		     */
		    _nc_copy_termtype(&merged, &(qp->tterm));

		    /*
		     * Now merge in each use entry in the proper
		     * (reverse) order.
		     */
		    for (; qp->nuses; qp->nuses--)
			_nc_merge_entry(&merged,
					&qp->uses[qp->nuses - 1].link->tterm);

		    /*
		     * Now merge in the original entry.
		     */
		    _nc_merge_entry(&merged, &qp->tterm);

		    /*
		     * Replace the original entry with the merged one.
		     */
		    FreeIfNeeded(qp->tterm.Booleans);
		    FreeIfNeeded(qp->tterm.Numbers);
		    FreeIfNeeded(qp->tterm.Strings);
#if NCURSES_XNAMES
		    FreeIfNeeded(qp->tterm.ext_Names);
#endif
		    qp->tterm = merged;
		    _nc_wrap_entry(qp, TRUE);

		    /*
		     * We know every entry is resolvable because name resolution
		     * didn't bomb.  So go back for another pass.
		     */
		    /* FALLTHRU */
		  incomplete:
		    keepgoing = TRUE;
		}
	    }
	} while
	    (keepgoing);

	DEBUG(2, ("MERGES COMPLETED OK"));
    }

    /*
     * We'd like to free entries read in off disk at this point, but can't.
     * The merge_entry() code doesn't copy the strings in the use entries,
     * it just aliases them.  If this ever changes, do a
     * free_entries(lastread) here.
     */

    DEBUG(2, ("RESOLUTION FINISHED"));

    if (fullresolve)
	if (_nc_check_termtype != 0) {
	    _nc_curr_col = -1;
	    for_entry_list(qp) {
		_nc_curr_line = qp->startline;
		_nc_set_type(_nc_first_name(qp->tterm.term_names));
		_nc_check_termtype2(&qp->tterm, literal);
	    }
	    DEBUG(2, ("SANITY CHECK FINISHED"));
	}

    return (TRUE);
}

/* obsolete: 20040705 */
NCURSES_EXPORT(int)
_nc_resolve_uses(bool fullresolve)
{
    return _nc_resolve_uses2(fullresolve, FALSE);
}

/*
 * This bit of legerdemain turns all the terminfo variable names into
 * references to locations in the arrays Booleans, Numbers, and Strings ---
 * precisely what's needed.
 */

#undef CUR
#define CUR tp->

static void
sanity_check2(TERMTYPE *tp, bool literal)
{
    if (!PRESENT(exit_attribute_mode)) {
#ifdef __UNUSED__		/* this casts too wide a net */
	bool terminal_entry = !strchr(tp->term_names, '+');
	if (terminal_entry &&
	    (PRESENT(set_attributes)
	     || PRESENT(enter_standout_mode)
	     || PRESENT(enter_underline_mode)
	     || PRESENT(enter_blink_mode)
	     || PRESENT(enter_bold_mode)
	     || PRESENT(enter_dim_mode)
	     || PRESENT(enter_secure_mode)
	     || PRESENT(enter_protected_mode)
	     || PRESENT(enter_reverse_mode)))
	    _nc_warning("no exit_attribute_mode");
#endif /* __UNUSED__ */
	PAIRED(enter_standout_mode, exit_standout_mode);
	PAIRED(enter_underline_mode, exit_underline_mode);
    }

    /* we do this check/fix in postprocess_termcap(), but some packagers
     * prefer to bypass it...
     */
    if (!literal) {
	if (acs_chars == 0
	    && enter_alt_charset_mode != 0
	    && exit_alt_charset_mode != 0)
	    acs_chars = strdup(VT_ACSC);
	ANDMISSING(enter_alt_charset_mode, acs_chars);
	ANDMISSING(exit_alt_charset_mode, acs_chars);
    }

    /* listed in structure-member order of first argument */
    PAIRED(enter_alt_charset_mode, exit_alt_charset_mode);
    ANDMISSING(enter_blink_mode, exit_attribute_mode);
    ANDMISSING(enter_bold_mode, exit_attribute_mode);
    PAIRED(exit_ca_mode, enter_ca_mode);
    PAIRED(enter_delete_mode, exit_delete_mode);
    ANDMISSING(enter_dim_mode, exit_attribute_mode);
    PAIRED(enter_insert_mode, exit_insert_mode);
    ANDMISSING(enter_secure_mode, exit_attribute_mode);
    ANDMISSING(enter_protected_mode, exit_attribute_mode);
    ANDMISSING(enter_reverse_mode, exit_attribute_mode);
    PAIRED(from_status_line, to_status_line);
    PAIRED(meta_off, meta_on);

    PAIRED(prtr_on, prtr_off);
    PAIRED(save_cursor, restore_cursor);
    PAIRED(enter_xon_mode, exit_xon_mode);
    PAIRED(enter_am_mode, exit_am_mode);
    ANDMISSING(label_off, label_on);
#ifdef remove_clock
    PAIRED(display_clock, remove_clock);
#endif
    ANDMISSING(set_color_pair, initialize_pair);
}

/* obsolete: 20040705 */
static void
sanity_check(TERMTYPE *tp)
{
    sanity_check2(tp, FALSE);
}

#if NO_LEAKS
NCURSES_EXPORT(void)
_nc_leaks_tic(void)
{
    _nc_alloc_entry_leaks();
    _nc_captoinfo_leaks();
    _nc_comp_captab_leaks();
    _nc_comp_scan_leaks();
#if BROKEN_LINKER || USE_REENTRANT
    _nc_names_leaks();
    _nc_codes_leaks();
#endif
    _nc_tic_expand(0, FALSE, 0);
}

NCURSES_EXPORT(void)
_nc_free_tic(int code)
{
    _nc_leaks_tic();
    _nc_free_tinfo(code);
}
#endif
@


1.11
log
@Use strlcpy() / strlcat() throughout.
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.10 2001/01/22 18:01:51 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d41 1
a41 1
 *	_nc_resolve_uses(void)
d46 1
a46 1
 *	want use-resolution, call _nc_resolve_uses().  To free the list
d58 1
a58 1
MODULE_ID("$From: comp_parse.c,v 1.48 2001/01/15 00:44:51 tom Exp $")
d60 4
d67 2
a68 26
/****************************************************************************
 *
 * Entry queue handling
 *
 ****************************************************************************/
/*
 *  The entry list is a doubly linked list with NULLs terminating the lists:
 *
 *	  ---------   ---------   ---------
 *	  |       |   |       |   |       |   offset
 *        |-------|   |-------|   |-------|
 *	  |   ----+-->|   ----+-->|  NULL |   next
 *	  |-------|   |-------|   |-------|
 *	  |  NULL |<--+----   |<--+----   |   last
 *	  ---------   ---------   ---------
 *	      ^                       ^
 *	      |                       |
 *	      |                       |
 *	   _nc_head                _nc_tail
 */

NCURSES_EXPORT_VAR(ENTRY *) _nc_head = 0;
NCURSES_EXPORT_VAR(ENTRY *) _nc_tail = 0;

     static void
       enqueue(ENTRY * ep)
d74 1
a74 1
	_nc_err_abort("Out of memory");
a83 25
NCURSES_EXPORT(void)
_nc_free_entries(ENTRY * headp)
/* free the allocated storage consumed by list entries */
{
    ENTRY *ep, *next;

    for (ep = headp; ep; ep = next) {
	/*
	 * This conditional lets us disconnect storage from the list.
	 * To do this, copy an entry out of the list, then null out
	 * the string-table member in the original and any use entries
	 * it references.
	 */
	FreeIfNeeded(ep->tterm.str_table);

	next = ep->next;

	free(ep);
	if (ep == _nc_head)
	    _nc_head = 0;
	if (ep == _nc_tail)
	    _nc_tail = 0;
    }
}

d88 1
a88 1
	size_t len;
d90 6
a95 6
	len = strlcpy(dst, src, siz);
	if (len > siz - 2)
	    len = siz - 2;
	dst[len++] = '|';
	dst[len] = '\0';
	src = dst;
d126 1
a126 1
_nc_read_entry_source(FILE * fp, char *buf,
d143 1
a143 1
	if (!isalnum(CharOf(thisentry.tterm.term_names[0])))
d147 3
a149 3
	 * This can be used for immediate compilation of entries with no
	 * use references to disk, so as to avoid chewing up a lot of
	 * core when the resolution code could fetch entries off disk.
d151 1
a151 1
	if (hook != NULLHOOK && (*hook) (&thisentry))
d153 1
a153 1
	else
d155 11
d185 1
a185 1
_nc_resolve_uses(bool fullresolve)
d190 2
a191 1
    int i, j, unresolved, total_unresolved, multiples;
d264 1
a264 1
			_nc_err_abort("Out of memory");
d295 2
a296 2
     * OK, at this point all (char *) references in `name' mwmbers
     * have been successfully converred to (ENTRY *) pointers in
d322 4
a325 4
		       * First, make sure there's no garbage in the
		       * merge block.  as a side effect, copy into
		       * the merged entry the name field and string
		       * table pointer.
d348 3
a366 20

	/*
	 * The exit condition of the loop above is such that all entries
	 * must now be resolved.  Now handle cancellations.  In a resolved
	 * entry there should be no cancellation markers.
	 */
	for_entry_list(qp) {
	    for_each_boolean(j, &(qp->tterm)) {
		if ((int) qp->tterm.Booleans[j] == CANCELLED_BOOLEAN)
		    qp->tterm.Booleans[j] = ABSENT_BOOLEAN;
	    }
	    for_each_number(j, &(qp->tterm)) {
		if (qp->tterm.Numbers[j] == CANCELLED_NUMERIC)
		    qp->tterm.Numbers[j] = ABSENT_NUMERIC;
	    }
	    for_each_string(j, &(qp->tterm)) {
		if (qp->tterm.Strings[j] == CANCELLED_STRING)
		    qp->tterm.Strings[j] = ABSENT_STRING;
	    }
	}
d384 1
a384 1
		_nc_check_termtype(&qp->tterm);
d392 7
d409 1
a409 1
sanity_check(TERMTYPE * tp)
d426 14
a439 2
	PAIRED(enter_standout_mode, exit_standout_mode)
	    PAIRED(enter_underline_mode, exit_underline_mode)
a443 2
    ANDMISSING(enter_alt_charset_mode, acs_chars);
    ANDMISSING(exit_alt_charset_mode, acs_chars);
d461 1
d463 1
d466 30
@


1.10
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.9 2000/10/22 18:27:23 millert Exp $	*/
d135 4
a138 3
	if (len >= siz - 2)
	    len = siz - 2;;
	(void) strcpy(dst + len, "|");
@


1.9
log
@update to ncurses 5.2
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.8 2000/10/08 22:47:00 millert Exp $	*/
d57 1
a57 1
MODULE_ID("$From: comp_parse.c,v 1.42 2000/10/14 17:50:45 Bernhard.Rosenkraenzer Exp $")
d60 1
a60 1
void (*_nc_check_termtype) (TERMTYPE *) = sanity_check;
d83 2
a84 1
ENTRY *_nc_head = 0, *_nc_tail = 0;
d86 2
a87 2
static void
enqueue(ENTRY * ep)
d103 1
a103 1
void
d143 1
a143 1
bool
d168 1
a168 1
void
d170 2
a171 2
    int literal, bool silent,
    bool(*hook) (ENTRY *))
d186 1
a186 1
	if (!isalnum(thisentry.tterm.term_names[0]))
d216 1
a216 1
int
d233 1
a233 1
	for_entry_list(rp)
d235 9
a243 6
	    && _nc_entry_match(qp->tterm.term_names, rp->tterm.term_names)) {
	    matchcount++;
	    if (matchcount == 1) {
		(void) fprintf(stderr, "Name collision between %s",
		    _nc_first_name(qp->tterm.term_names));
		multiples++;
a244 2
	    if (matchcount >= 1)
		(void) fprintf(stderr, " %s", _nc_first_name(rp->tterm.term_names));
d272 1
a272 1
	    for_entry_list(rp)
d274 3
a276 3
		&& _nc_name_match(rp->tterm.term_names, lookfor, "|")) {
		DEBUG(2, ("%s: resolving use=%s (in core)",
			child, lookfor));
d278 3
a280 2
		qp->uses[i].link = rp;
		foundit = TRUE;
d291 1
a291 1
			    child, lookfor));
d339 1
a339 1
			    _nc_first_name(qp->tterm.term_names)));
d348 1
a348 1
				    _nc_first_name(qp->tterm.term_names), i));
d366 1
a366 1
			    &qp->uses[qp->nuses - 1].link->tterm);
d380 1
d402 5
a406 4
	    for_each_boolean(j, &(qp->tterm))
		if (qp->tterm.Booleans[j] == CANCELLED_BOOLEAN)
		qp->tterm.Booleans[j] = ABSENT_BOOLEAN;
	    for_each_number(j, &(qp->tterm))
d408 3
a410 2
		qp->tterm.Numbers[j] = ABSENT_NUMERIC;
	    for_each_string(j, &(qp->tterm))
d412 2
a413 1
		qp->tterm.Strings[j] = ABSENT_STRING;
d457 8
a464 8
		|| PRESENT(enter_standout_mode)
		|| PRESENT(enter_underline_mode)
		|| PRESENT(enter_blink_mode)
		|| PRESENT(enter_bold_mode)
		|| PRESENT(enter_dim_mode)
		|| PRESENT(enter_secure_mode)
		|| PRESENT(enter_protected_mode)
		|| PRESENT(enter_reverse_mode)))
@


1.8
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.7 2000/06/19 03:53:48 millert Exp $	*/
d57 1
a57 1
MODULE_ID("$From: comp_parse.c,v 1.41 2000/10/03 09:53:49 tom Exp $")
@


1.7
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.6 2000/03/26 16:45:03 millert Exp $	*/
d57 1
a57 1
MODULE_ID("$From: comp_parse.c,v 1.40 2000/04/15 16:57:08 tom Exp $")
d127 15
d147 1
a147 10
    char nc1[MAX_NAME_SIZE + 1], nc2[MAX_NAME_SIZE + 1];
    size_t n;

    if (strchr(n1, '|') == NULL) {
	if ((n = strlcpy(nc1, n1, sizeof(nc1))) > sizeof(nc1) - 2)
	    n = sizeof(nc1) - 2;
	nc1[n++] = '|';
	nc1[n] = '\0';
	n1 = nc1;
    }
d149 2
a150 7
    if (strchr(n2, '|') == NULL) {
	if ((n = strlcpy(nc2, n2, sizeof(nc2))) > sizeof(nc2) - 2)
	    n = sizeof(nc2) - 2;
	nc2[n++] = '|';
	nc2[n] = '\0';
	n2 = nc2;
    }
@


1.6
log
@Update to ncurses-5.0-20000325
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.5 2000/03/13 23:53:40 millert Exp $	*/
d57 1
a57 1
MODULE_ID("$From: comp_parse.c,v 1.39 2000/03/25 17:07:30 tom Exp $")
d464 22
a485 22
    PAIRED(enter_alt_charset_mode, exit_alt_charset_mode)
	ANDMISSING(enter_alt_charset_mode, acs_chars)
	ANDMISSING(exit_alt_charset_mode, acs_chars)
	ANDMISSING(enter_blink_mode, exit_attribute_mode)
	ANDMISSING(enter_bold_mode, exit_attribute_mode)
	PAIRED(exit_ca_mode, enter_ca_mode)
	PAIRED(enter_delete_mode, exit_delete_mode)
	ANDMISSING(enter_dim_mode, exit_attribute_mode)
	PAIRED(enter_insert_mode, exit_insert_mode)
	ANDMISSING(enter_secure_mode, exit_attribute_mode)
	ANDMISSING(enter_protected_mode, exit_attribute_mode)
	ANDMISSING(enter_reverse_mode, exit_attribute_mode)
	PAIRED(from_status_line, to_status_line)
	PAIRED(meta_off, meta_on)

	PAIRED(prtr_on, prtr_off)
	PAIRED(save_cursor, restore_cursor)
	PAIRED(enter_xon_mode, exit_xon_mode)
	PAIRED(enter_am_mode, exit_am_mode)
	ANDMISSING(label_off, label_on)
	PAIRED(display_clock, remove_clock)
	ANDMISSING(set_color_pair, initialize_pair)
@


1.5
log
@update to ncurses-5.0-20000311
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.4 1999/11/28 17:49:53 millert Exp $	*/
d57 1
a57 1
MODULE_ID("$From: comp_parse.c,v 1.38 2000/03/12 00:14:46 tom Exp $")
d179 5
a183 3
    memset(&thisentry, 0, sizeof(thisentry));
    for (_nc_reset_input(fp, buf); _nc_parse_entry(&thisentry, literal,
	    silent) != ERR;) {
@


1.4
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.3 1999/03/02 06:23:28 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
a35 2


d57 1
a57 1
MODULE_ID("$From: comp_parse.c,v 1.36 1999/10/31 00:56:12 tom Exp $")
d60 1
a60 1
void (*_nc_check_termtype)(TERMTYPE *) = sanity_check;
d85 2
a86 1
static void enqueue(ENTRY *ep)
d89 1
a89 1
	ENTRY	*newp = _nc_copy_entry(ep);
d91 2
a92 2
	if (newp == NULL)
	    _nc_err_abort("Out of memory");
d94 2
a95 2
	newp->last = _nc_tail;
	_nc_tail = newp;
d97 3
a99 3
	newp->next = (ENTRY *)NULL;
	if (newp->last)
	    newp->last->next = newp;
d102 2
a103 1
void _nc_free_entries(ENTRY *headp)
d106 1
a106 1
    ENTRY	*ep, *next;
d108 1
a108 2
    for (ep = headp; ep; ep = next)
    {
d120 4
a123 2
	if (ep == _nc_head) _nc_head = 0;
	if (ep == _nc_tail) _nc_tail = 0;
d127 2
a128 1
bool _nc_entry_match(char *n1, char *n2)
d131 3
a133 3
    char	*pstart, *qstart, *pend, *qend;
    char	nc1[MAX_NAME_SIZE+1], nc2[MAX_NAME_SIZE+1];
    size_t	n;
d135 1
a135 2
    if (strchr(n1, '|') == NULL)
    {
d143 1
a143 2
    if (strchr(n2, '|') == NULL)
    {
d153 3
a155 3
	    if ((pend-pstart == qend-qstart)
	     && memcmp(pstart, qstart, (size_t)(pend-pstart)) == 0)
		return(TRUE);
d157 1
a157 1
	return(FALSE);
d166 4
a169 3
void _nc_read_entry_source(FILE *fp, char *buf,
			   int literal, bool silent,
			   bool (*hook)(ENTRY *))
d172 3
a174 3
    ENTRY	thisentry;
    bool	oldsuppress = _nc_suppress_warnings;
    int		immediate = 0;
d180 2
a181 2
    for (_nc_reset_input(fp, buf); _nc_parse_entry(&thisentry, literal, silent) != ERR; )
    {
d190 1
a190 1
	if (hook != NULLHOOK && (*hook)(&thisentry))
d196 1
a196 2
    if (_nc_tail)
    {
d212 2
a213 1
int _nc_resolve_uses(void)
d216 3
a218 3
    ENTRY	*qp, *rp, *lastread = NULL;
    bool	keepgoing;
    int		i, j, unresolved, total_unresolved, multiples;
d226 1
a226 2
    for_entry_list(qp)
    {
d231 6
a236 11
		&& _nc_entry_match(qp->tterm.term_names, rp->tterm.term_names))
	    {
		matchcount++;
		if (matchcount == 1)
		{
		    (void) fprintf(stderr, "Name collision between %s",
			   _nc_first_name(qp->tterm.term_names));
		    multiples++;
		}
		if (matchcount >= 1)
		    (void) fprintf(stderr, " %s", _nc_first_name(rp->tterm.term_names));
d238 3
d245 1
a245 1
	return(FALSE);
d250 1
a250 3
     * First resolution stage: replace names in use arrays with entry
     * pointers.  By doing this, we avoid having to do the same name
     * match once for each time a use entry is itself unresolved.
d254 1
a254 2
    for_entry_list(qp)
    {
d256 5
a260 6
	for (i = 0; i < qp->nuses; i++)
	{
	    bool	foundit;
	    char	*child = _nc_first_name(qp->tterm.term_names);
	    char	*lookfor = (char *)(qp->uses[i].parent);
	    long	lookline = qp->uses[i].line;
d269 3
a271 4
		    && _nc_name_match(rp->tterm.term_names, lookfor, "|"))
		{
		    DEBUG(2, ("%s: resolving use=%s (in core)",
			      child, lookfor));
d273 3
a275 3
		    qp->uses[i].parent = rp;
		    foundit = TRUE;
		}
d278 3
a280 4
	    if (!foundit)
	    {
		TERMTYPE	thisterm;
		char		filename[PATH_MAX];
d283 1
a283 2
		if (_nc_read_entry(lookfor, filename, &thisterm) == 1)
		{
d285 1
a285 1
			      child, lookfor));
d287 2
a288 2
		    rp = typeMalloc(ENTRY,1);
		    if (rp == NULL)
d295 1
a295 1
		    qp->uses[i].parent = rp;
d301 1
a301 2
	    if (!foundit)
	    {
d307 1
a307 1
		qp->uses[i].parent = (ENTRY *)NULL;
d311 1
a311 2
    if (total_unresolved)
    {
d314 1
a314 1
	return(FALSE);
d320 3
a322 2
     * OK, at this point all (char *) references have been successfully
     * replaced by (ENTRY *) pointers.  Time to do the actual merges.
d324 59
a382 58
    do {
	TERMTYPE	merged;

	keepgoing = FALSE;

	for_entry_list(qp)
	{
	    if (qp->nuses > 0)
	    {
		DEBUG(2, ("%s: attempting merge", _nc_first_name(qp->tterm.term_names)));
		/*
		 * If any of the use entries we're looking for is
		 * incomplete, punt.  We'll catch this entry on a
		 * subsequent pass.
		 */
		for (i = 0; i < qp->nuses; i++)
		    if (((ENTRY *)qp->uses[i].parent)->nuses)
		    {
			DEBUG(2, ("%s: use entry %d unresolved",
				  _nc_first_name(qp->tterm.term_names), i));
			goto incomplete;
		    }

		/*
		 * First, make sure there's no garbage in the merge block.
		 * as a side effect, copy into the merged entry the name
		 * field and string table pointer.
		 */
		_nc_copy_termtype(&merged, &(qp->tterm));

		/*
		 * Now merge in each use entry in the proper
		 * (reverse) order.
		 */
		for (; qp->nuses; qp->nuses--)
		    _nc_merge_entry(&merged,
				&((ENTRY *)qp->uses[qp->nuses-1].parent)->tterm);

		/*
		 * Now merge in the original entry.
		 */
		_nc_merge_entry(&merged, &qp->tterm);

		/*
		 * Replace the original entry with the merged one.
		 */
		FreeIfNeeded(qp->tterm.Booleans);
		FreeIfNeeded(qp->tterm.Numbers);
		FreeIfNeeded(qp->tterm.Strings);
		qp->tterm = merged;

		/*
		 * We know every entry is resolvable because name resolution
		 * didn't bomb.  So go back for another pass.
		 */
		/* FALLTHRU */
	    incomplete:
		keepgoing = TRUE;
d384 2
a385 3
	}
    } while
	(keepgoing);
d387 1
a387 1
    DEBUG(2, ("MERGES COMPLETED OK"));
d389 11
a399 12
    /*
     * The exit condition of the loop above is such that all entries
     * must now be resolved.  Now handle cancellations.  In a resolved
     * entry there should be no cancellation markers.
     */
    for_entry_list(qp)
    {
	for_each_boolean(j, &(qp->tterm))
	    if (qp->tterm.Booleans[j] == CANCELLED_BOOLEAN)
		qp->tterm.Booleans[j] = FALSE;
	for_each_number(j, &(qp->tterm))
	    if (qp->tterm.Numbers[j] == CANCELLED_NUMERIC)
d401 2
a402 2
	for_each_string(j, &(qp->tterm))
	    if (qp->tterm.Strings[j] == CANCELLED_STRING)
d404 1
d416 9
a424 8
    if (_nc_check_termtype != 0)
    {
	_nc_curr_col = -1;
	for_entry_list(qp)
	{
	    _nc_curr_line = qp->startline;
	    _nc_set_type(_nc_first_name(qp->tterm.term_names));
	    _nc_check_termtype(&qp->tterm);
a425 2
	DEBUG(2, ("SANITY CHECK FINISHED"));
    }
d427 1
a427 1
    return(TRUE);
d439 2
a440 1
static void sanity_check(TERMTYPE *tp)
d442 3
a444 4
    if (!PRESENT(exit_attribute_mode))
    {
#ifdef __UNUSED__	/* this casts too wide a net */
        bool       terminal_entry = !strchr(tp->term_names, '+');
d446 1
a446 1
		(PRESENT(set_attributes)
d457 2
a458 2
	PAIRED(enter_standout_mode,     exit_standout_mode)
	PAIRED(enter_underline_mode,    exit_underline_mode)
d461 23
a483 23
     /* listed in structure-member order of first argument */
     PAIRED(enter_alt_charset_mode,          exit_alt_charset_mode)
     ANDMISSING(enter_alt_charset_mode,      acs_chars)
     ANDMISSING(exit_alt_charset_mode,       acs_chars)
     ANDMISSING(enter_blink_mode,            exit_attribute_mode)
     ANDMISSING(enter_bold_mode,             exit_attribute_mode)
     PAIRED(exit_ca_mode,                    enter_ca_mode)
     PAIRED(enter_delete_mode,               exit_delete_mode)
     ANDMISSING(enter_dim_mode,              exit_attribute_mode)
     PAIRED(enter_insert_mode,               exit_insert_mode)
     ANDMISSING(enter_secure_mode,           exit_attribute_mode)
     ANDMISSING(enter_protected_mode,        exit_attribute_mode)
     ANDMISSING(enter_reverse_mode,          exit_attribute_mode)
     PAIRED(from_status_line,                to_status_line)
     PAIRED(meta_off,                        meta_on)

     PAIRED(prtr_on,                         prtr_off)
     PAIRED(save_cursor,                     restore_cursor)
     PAIRED(enter_xon_mode,                  exit_xon_mode)
     PAIRED(enter_am_mode,                   exit_am_mode)
     ANDMISSING(label_off,                   label_on)
     PAIRED(display_clock,                   remove_clock)
     ANDMISSING(set_color_pair,              initialize_pair)
@


1.3
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.2 1999/02/24 06:31:10 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d59 1
a59 1
MODULE_ID("$From: comp_parse.c,v 1.34 1999/02/27 22:13:02 tom Exp $")
d85 1
a85 1
ENTRY *_nc_head, *_nc_tail;
d103 1
a103 1
void _nc_free_entries(ENTRY *head)
d108 1
a108 1
    for (ep = head; ep; ep = next)
@


1.2
log
@ncurses-4.2-990220; this is a pre-release of 5.0
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.1 1999/01/18 19:10:14 millert Exp $	*/
a56 1
#include <term.h>
d59 1
a59 1
MODULE_ID("$From: comp_parse.c,v 1.26 1999/02/19 10:38:13 tom Exp $")
d90 1
a90 1
	ENTRY	*newp = (ENTRY *)malloc(sizeof(ENTRY));
a94 2
	(void) memcpy(newp, ep, sizeof(ENTRY));

d178 1
d290 1
d296 1
a296 1
		    rp = (ENTRY *)malloc(sizeof(ENTRY));
d299 1
a299 1
		    memcpy(&rp->tterm, &thisterm, sizeof(TERMTYPE));
d340 1
d362 1
a362 1
		memcpy(&merged, &qp->tterm, sizeof(TERMTYPE));
d380 4
a383 1
		memcpy(&qp->tterm, &merged, sizeof(TERMTYPE));
d393 1
d406 1
a406 1
	for (j = 0; j < BOOLCOUNT; j++)
d409 1
a409 1
	for (j = 0; j < NUMCOUNT; j++)
d412 1
a412 1
	for (j = 0; j < STRCOUNT; j++)
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_parse.c,v 1.2 1998/11/17 03:16:20 millert Exp $	*/
d60 1
a60 1
MODULE_ID("$From: comp_parse.c,v 1.23 1998/05/30 23:38:15 Todd.Miller Exp $")
d63 1
d422 1
a422 2
    _nc_curr_col = -1;
    for_entry_list(qp)
d424 8
a431 3
	_nc_curr_line = qp->startline;
	_nc_set_type(_nc_first_name(qp->tterm.term_names));
	sanity_check(&qp->tterm);
a433 2
    DEBUG(2, ("SANITY CHECK FINISHED"));

a445 18
/*
 * Note that WANTED and PRESENT are not simple inverses!  If a capability
 * has been explicitly cancelled, it's not considered WANTED.
 */
#define WANTED(s)	((s) == ABSENT_STRING)
#define PRESENT(s)	(((s) != ABSENT_STRING) && ((s) != CANCELLED_STRING))

#define ANDMISSING(p,q) \
		{if (PRESENT(p) && !PRESENT(q)) _nc_warning(#p " but no " #q);}

#define PAIRED(p,q) \
		{ \
		if (PRESENT(q) && !PRESENT(p)) \
			_nc_warning(#q " but no " #p); \
		if (PRESENT(p) && !PRESENT(q)) \
			_nc_warning(#p " but no " #q); \
		}

a447 4
#ifdef __UNUSED__	/* this casts too wide a net */
    bool       terminal_entry = !strchr(tp->term_names, '+');
#endif

d451 1
a468 4
#ifdef __UNUSED__
     ANDMISSING(cursor_invisible,            cursor_normal)
     ANDMISSING(cursor_visible,              cursor_normal)
#endif /* __UNUSED__ */
a490 26

     /* Some checks that we should make, but don't want to confuse people
      * with.  Put those under the tic -v option so we can still get them.
      */
     if (_nc_tracing) {

	/*
	 * From XSI & O'Reilly, we gather that sc/rc are required if csr is
	 * given, because the cursor position after the scrolling operation is
	 * performed is undefined.
	 */
         ANDMISSING(change_scroll_region,        save_cursor)
         ANDMISSING(change_scroll_region,        restore_cursor)

         /*
	  * Some non-curses applications (e.g., jove) get confused if we have
	  * both ich/ich1 and smir/rmir.  Let's be nice and warn about that,
	  * too, even though ncurses handles it.
          */
         if ((PRESENT(enter_insert_mode) || PRESENT(exit_insert_mode))
          && (PRESENT(insert_character)  || PRESENT(parm_ich))) {
	    _nc_warning("non-curses applications may be confused by ich/ich1 with smir/rmir");
         }
     }
#undef PAIRED
#undef ANDMISSING
@

