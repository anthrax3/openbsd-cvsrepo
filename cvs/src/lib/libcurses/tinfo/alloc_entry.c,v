head	1.6;
access;
symbols
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.32
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.28
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.24
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.26
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.18
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.22
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.22.18.01.50;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.13.23.53.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.06.23.28;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.13;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2006,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 * alloc_entry.c -- allocation functions for terminfo entries
 *
 *	_nc_copy_entry()
 *	_nc_init_entry()
 *	_nc_merge_entry()
 *	_nc_save_str()
 *	_nc_wrap_entry()
 *
 */

#include <curses.priv.h>

#include <tic.h>
#include <term_entry.h>

MODULE_ID("$Id: alloc_entry.c,v 1.48 2008/08/16 16:25:31 tom Exp $")

#define ABSENT_OFFSET    -1
#define CANCELLED_OFFSET -2

#define MAX_STRTAB	4096	/* documented maximum entry size */

static char *stringbuf;		/* buffer for string capabilities */
static size_t next_free;	/* next free character in stringbuf */

NCURSES_EXPORT(void)
_nc_init_entry(TERMTYPE *const tp)
/* initialize a terminal type data block */
{
    unsigned i;

#if NO_LEAKS
    if (tp == 0 && stringbuf != 0) {
	FreeAndNull(stringbuf);
	return;
    }
#endif

    if (stringbuf == 0)
	stringbuf = (char *) malloc(MAX_STRTAB);

#if NCURSES_XNAMES
    tp->num_Booleans = BOOLCOUNT;
    tp->num_Numbers = NUMCOUNT;
    tp->num_Strings = STRCOUNT;
    tp->ext_Booleans = 0;
    tp->ext_Numbers = 0;
    tp->ext_Strings = 0;
#endif
    if (tp->Booleans == 0)
	tp->Booleans = typeMalloc(NCURSES_SBOOL, BOOLCOUNT);
    if (tp->Numbers == 0)
	tp->Numbers = typeMalloc(short, NUMCOUNT);
    if (tp->Strings == 0)
	tp->Strings = typeMalloc(char *, STRCOUNT);

    for_each_boolean(i, tp)
	tp->Booleans[i] = FALSE;

    for_each_number(i, tp)
	tp->Numbers[i] = ABSENT_NUMERIC;

    for_each_string(i, tp)
	tp->Strings[i] = ABSENT_STRING;

    next_free = 0;
}

NCURSES_EXPORT(ENTRY *)
_nc_copy_entry(ENTRY * oldp)
{
    ENTRY *newp = typeCalloc(ENTRY, 1);

    if (newp != 0) {
	*newp = *oldp;
	_nc_copy_termtype(&(newp->tterm), &(oldp->tterm));
    }
    return newp;
}

/* save a copy of string in the string buffer */
NCURSES_EXPORT(char *)
_nc_save_str(const char *const string)
{
    char *result = 0;
    size_t old_next_free = next_free;
    size_t len = strlen(string) + 1;

    if (len == 1 && next_free != 0) {
	/*
	 * Cheat a little by making an empty string point to the end of the
	 * previous string.
	 */
	if (next_free < MAX_STRTAB) {
	    result = (stringbuf + next_free - 1);
	}
    } else if (next_free + len < MAX_STRTAB) {
	strlcpy(&stringbuf[next_free], string, MAX_STRTAB - next_free);
	DEBUG(7, ("Saved string %s", _nc_visbuf(string)));
	DEBUG(7, ("at location %d", (int) next_free));
	next_free += len;
	result = (stringbuf + old_next_free);
    } else {
	_nc_warning("Too much data, some is lost");
    }
    return result;
}

NCURSES_EXPORT(void)
_nc_wrap_entry(ENTRY * const ep, bool copy_strings)
/* copy the string parts to allocated storage, preserving pointers to it */
{
    int offsets[MAX_ENTRY_SIZE / sizeof(short)];
    int useoffsets[MAX_USES];
    unsigned i, n;
    unsigned nuses = ep->nuses;
    TERMTYPE *tp = &(ep->tterm);

    if (copy_strings) {
	next_free = 0;		/* clear static storage */

	/* copy term_names, Strings, uses */
	tp->term_names = _nc_save_str(tp->term_names);
	for_each_string(i, tp) {
	    if (tp->Strings[i] != ABSENT_STRING &&
		tp->Strings[i] != CANCELLED_STRING) {
		tp->Strings[i] = _nc_save_str(tp->Strings[i]);
	    }
	}

	for (i = 0; i < nuses; i++) {
	    if (ep->uses[i].name == 0) {
		ep->uses[i].name = _nc_save_str(ep->uses[i].name);
	    }
	}

	free(tp->str_table);
    }

    assert(tp->term_names >= stringbuf);
    n = (unsigned) (tp->term_names - stringbuf);
    for_each_string(i, &(ep->tterm)) {
	if (i < SIZEOF(offsets)) {
	    if (tp->Strings[i] == ABSENT_STRING) {
		offsets[i] = ABSENT_OFFSET;
	    } else if (tp->Strings[i] == CANCELLED_STRING) {
		offsets[i] = CANCELLED_OFFSET;
	    } else {
		offsets[i] = tp->Strings[i] - stringbuf;
	    }
	}
    }

    for (i = 0; i < nuses; i++) {
	if (ep->uses[i].name == 0)
	    useoffsets[i] = ABSENT_OFFSET;
	else
	    useoffsets[i] = ep->uses[i].name - stringbuf;
    }

    if ((tp->str_table = typeMalloc(char, next_free)) == (char *) 0)
	  _nc_err_abort(MSG_NO_MEMORY);
    (void) memcpy(tp->str_table, stringbuf, next_free);

    tp->term_names = tp->str_table + n;
    for_each_string(i, &(ep->tterm)) {
	if (i < SIZEOF(offsets)) {
	    if (offsets[i] == ABSENT_OFFSET) {
		tp->Strings[i] = ABSENT_STRING;
	    } else if (offsets[i] == CANCELLED_OFFSET) {
		tp->Strings[i] = CANCELLED_STRING;
	    } else {
		tp->Strings[i] = tp->str_table + offsets[i];
	    }
	}
    }

#if NCURSES_XNAMES
    if (!copy_strings) {
	if ((n = (unsigned) NUM_EXT_NAMES(tp)) != 0) {
	    if (n < SIZEOF(offsets)) {
		size_t copied, length, strtabsize = 0;
		for (i = 0; i < n; i++) {
		    strtabsize += strlen(tp->ext_Names[i]) + 1;
		    offsets[i] = tp->ext_Names[i] - stringbuf;
		}
		if ((tp->ext_str_table = typeMalloc(char, strtabsize)) == 0)
		      _nc_err_abort(MSG_NO_MEMORY);
		for (i = 0, length = 0; i < n; i++) {
		    tp->ext_Names[i] = tp->ext_str_table + length;
		    copied = strlcpy(tp->ext_Names[i], stringbuf + offsets[i],
			strtabsize) + 1;
		    if (copied > strtabsize)
			    _nc_err_abort("Buffer overflow");
		    length += copied;
		    strtabsize -= copied;
		}
	    }
	}
    }
#endif

    for (i = 0; i < nuses; i++) {
	if (useoffsets[i] == ABSENT_OFFSET)
	    ep->uses[i].name = 0;
	else
	    ep->uses[i].name = (tp->str_table + useoffsets[i]);
    }
}

NCURSES_EXPORT(void)
_nc_merge_entry(TERMTYPE *const to, TERMTYPE *const from)
/* merge capabilities from `from' entry into `to' entry */
{
    unsigned i;

#if NCURSES_XNAMES
    _nc_align_termtype(to, from);
#endif
    for_each_boolean(i, from) {
	if (to->Booleans[i] != (char) CANCELLED_BOOLEAN) {
	    int mergebool = from->Booleans[i];

	    if (mergebool == CANCELLED_BOOLEAN)
		to->Booleans[i] = FALSE;
	    else if (mergebool == TRUE)
		to->Booleans[i] = (char) mergebool;
	}
    }

    for_each_number(i, from) {
	if (to->Numbers[i] != CANCELLED_NUMERIC) {
	    short mergenum = from->Numbers[i];

	    if (mergenum == CANCELLED_NUMERIC)
		to->Numbers[i] = ABSENT_NUMERIC;
	    else if (mergenum != ABSENT_NUMERIC)
		to->Numbers[i] = mergenum;
	}
    }

    /*
     * Note: the copies of strings this makes don't have their own
     * storage.  This is OK right now, but will be a problem if we
     * we ever want to deallocate entries.
     */
    for_each_string(i, from) {
	if (to->Strings[i] != CANCELLED_STRING) {
	    char *mergestring = from->Strings[i];

	    if (mergestring == CANCELLED_STRING)
		to->Strings[i] = ABSENT_STRING;
	    else if (mergestring != ABSENT_STRING)
		to->Strings[i] = mergestring;
	}
    }
}

#if NO_LEAKS
NCURSES_EXPORT(void)
_nc_alloc_entry_leaks(void)
{
    if (stringbuf != 0) {
	FreeAndNull(stringbuf);
    }
    next_free = 0;
}
#endif
@


1.5
log
@Use strlcpy() / strlcat() throughout.
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc_entry.c,v 1.4 2001/01/22 18:01:50 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d34 1
d53 1
a53 1
MODULE_ID("$From: alloc_entry.c,v 1.35 2001/01/13 22:40:17 tom Exp $")
d60 1
a60 1
static char stringbuf[MAX_STRTAB];	/* buffer for string capabilities */
d64 1
a64 1
_nc_init_entry(TERMTYPE * const tp)
d67 11
a77 1
    int i;
d88 1
a88 1
	tp->Booleans = typeMalloc(char, BOOLCOUNT);
d118 1
a120 1
/* save a copy of string in the string buffer */
d122 1
d124 1
a124 1
    size_t len;
d126 10
a135 2
    len = strlcpy(stringbuf + next_free, string, sizeof(stringbuf) - next_free);
    if (++len < sizeof(stringbuf) - next_free) {
d139 3
d143 1
a143 1
    return (stringbuf + old_next_free);
d150 4
a153 2
    int offsets[MAX_ENTRY_SIZE / 2], useoffsets[MAX_USES];
    int i, n;
d168 1
a168 1
	for (i = 0; i < ep->nuses; i++) {
d177 2
a178 1
    n = tp->term_names - stringbuf;
d180 9
a188 6
	if (tp->Strings[i] == ABSENT_STRING)
	    offsets[i] = ABSENT_OFFSET;
	else if (tp->Strings[i] == CANCELLED_STRING)
	    offsets[i] = CANCELLED_OFFSET;
	else
	    offsets[i] = tp->Strings[i] - stringbuf;
d191 1
a191 1
    for (i = 0; i < ep->nuses; i++) {
d199 1
a199 1
	  _nc_err_abort("Out of memory");
d204 9
a212 6
	if (offsets[i] == ABSENT_OFFSET)
	    tp->Strings[i] = ABSENT_STRING;
	else if (offsets[i] == CANCELLED_OFFSET)
	    tp->Strings[i] = CANCELLED_STRING;
	else
	    tp->Strings[i] = tp->str_table + offsets[i];
d217 18
a234 16
	if ((n = NUM_EXT_NAMES(tp)) != 0) {
	    size_t copied, length, strtabsize = 0;
	    for (i = 0; i < n; i++) {
		strtabsize += strlen(tp->ext_Names[i]) + 1;
		offsets[i] = tp->ext_Names[i] - stringbuf;
	    }
	    if ((tp->ext_str_table = typeMalloc(char, strtabsize)) == 0)
		  _nc_err_abort("Out of memory");
	    for (i = 0, length = 0; i < n; i++) {
		tp->ext_Names[i] = tp->ext_str_table + length;
		copied = strlcpy(tp->ext_Names[i], stringbuf + offsets[i],
		    strtabsize) + 1;
		if (copied > strtabsize)
		    _nc_err_abort("Buffer overflow");
		length += copied;
		strtabsize -= copied;
d240 1
a240 1
    for (i = 0; i < ep->nuses; i++) {
d249 1
a249 2
_nc_merge_entry
(TERMTYPE * const to, TERMTYPE * const from)
d252 1
a252 1
    int i;
d258 2
a259 1
	int mergebool = from->Booleans[i];
d261 5
a265 4
	if (mergebool == CANCELLED_BOOLEAN)
	    to->Booleans[i] = FALSE;
	else if (mergebool == TRUE)
	    to->Booleans[i] = mergebool;
d269 2
a270 1
	int mergenum = from->Numbers[i];
d272 5
a276 4
	if (mergenum == CANCELLED_NUMERIC)
	    to->Numbers[i] = ABSENT_NUMERIC;
	else if (mergenum != ABSENT_NUMERIC)
	    to->Numbers[i] = mergenum;
d285 10
a294 1
	char *mergestring = from->Strings[i];
d296 6
a301 4
	if (mergestring == CANCELLED_STRING)
	    to->Strings[i] = ABSENT_STRING;
	else if (mergestring != ABSENT_STRING)
	    to->Strings[i] = mergestring;
d303 1
d305 1
@


1.4
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc_entry.c,v 1.3 2000/03/13 23:53:39 millert Exp $	*/
d112 1
a112 1
    size_t len = strlen(string) + 1;
d114 2
a115 2
    if (next_free + len < MAX_STRTAB) {
	strcpy(&stringbuf[next_free], string);
d186 1
a186 1
	    unsigned length = 0;
d188 1
a188 1
		length += strlen(tp->ext_Names[i]) + 1;
d191 1
a191 1
	    if ((tp->ext_str_table = typeMalloc(char, length)) == 0)
d195 6
a200 2
		strcpy(tp->ext_Names[i], stringbuf + offsets[i]);
		length += strlen(tp->ext_Names[i]) + 1;
@


1.3
log
@update to ncurses-5.0-20000311
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc_entry.c,v 1.2 1999/03/02 06:23:28 millert Exp $	*/
d52 1
a52 1
MODULE_ID("$From: alloc_entry.c,v 1.32 2000/03/12 00:16:31 tom Exp $")
d62 1
a62 1
void
d95 1
a95 1
ENTRY *
d107 1
a107 1
char *
d123 2
a124 2
void
_nc_wrap_entry(ENTRY * const ep)
d131 21
d184 14
a197 12
    if ((n = NUM_EXT_NAMES(tp)) != 0) {
	unsigned length = 0;
	for (i = 0; i < n; i++) {
	    length += strlen(tp->ext_Names[i]) + 1;
	    offsets[i] = tp->ext_Names[i] - stringbuf;
	}
	if ((tp->ext_str_table = typeMalloc(char, length)) == 0)
	      _nc_err_abort("Out of memory");
	for (i = 0, length = 0; i < n; i++) {
	    tp->ext_Names[i] = tp->ext_str_table + length;
	    strcpy(tp->ext_Names[i], stringbuf + offsets[i]);
	    length += strlen(tp->ext_Names[i]) + 1;
d210 3
a212 2
void
_nc_merge_entry(TERMTYPE * const to, TERMTYPE * const from)
@


1.2
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc_entry.c,v 1.1 1999/01/18 19:10:13 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 1

d52 1
a52 1
MODULE_ID("$From: alloc_entry.c,v 1.30 1999/03/01 02:03:45 tom Exp $")
d59 2
a60 2
static char	stringbuf[MAX_STRTAB];	/* buffer for string capabilities */
static size_t	next_free;		/* next free character in stringbuf */
d62 2
a63 1
void _nc_init_entry(TERMTYPE *const tp)
d66 1
a66 1
int	i;
d69 6
a74 6
	tp->num_Booleans = BOOLCOUNT;
	tp->num_Numbers  = NUMCOUNT;
	tp->num_Strings  = STRCOUNT;
	tp->ext_Booleans = 0;
	tp->ext_Numbers  = 0;
	tp->ext_Strings  = 0;
d76 9
a84 9
	if (tp->Booleans == 0)
	    tp->Booleans = typeMalloc(char,BOOLCOUNT);
	if (tp->Numbers == 0)
	    tp->Numbers = typeMalloc(short,NUMCOUNT);
	if (tp->Strings == 0)
	    tp->Strings = typeMalloc(char *,STRCOUNT);

	for_each_boolean(i,tp)
		tp->Booleans[i] = FALSE;
d86 2
a87 2
	for_each_number(i,tp)
		tp->Numbers[i] = ABSENT_NUMERIC;
d89 2
a90 2
	for_each_string(i,tp)
		tp->Strings[i] = ABSENT_STRING;
d92 1
a92 1
	next_free = 0;
d95 2
a96 1
ENTRY *_nc_copy_entry(ENTRY *oldp)
d98 1
a98 1
	ENTRY *newp = typeCalloc(ENTRY,1);
d100 5
a104 5
	if (newp != 0) {
	    *newp = *oldp;
	    _nc_copy_termtype(&(newp->tterm), &(oldp->tterm));
	}
	return newp;
d107 2
a108 1
char *_nc_save_str(const char *const string)
d111 2
a112 2
size_t	old_next_free = next_free;
size_t	len = strlen(string) + 1;
d114 7
a120 8
	if (next_free + len < MAX_STRTAB)
	{
		strcpy(&stringbuf[next_free], string);
		DEBUG(7, ("Saved string %s", _nc_visbuf(string)));
		DEBUG(7, ("at location %d", (int) next_free));
		next_free += len;
	}
	return(stringbuf + old_next_free);
d123 2
a124 1
void _nc_wrap_entry(ENTRY *const ep)
d127 13
a139 13
int	offsets[MAX_ENTRY_SIZE/2], useoffsets[MAX_USES];
int	i, n;
TERMTYPE *tp = &(ep->tterm);

	n = tp->term_names - stringbuf;
	for_each_string(i, &(ep->tterm)) {
		if (tp->Strings[i] == ABSENT_STRING)
			offsets[i] = ABSENT_OFFSET;
		else if (tp->Strings[i] == CANCELLED_STRING)
			offsets[i] = CANCELLED_OFFSET;
		else
			offsets[i] = tp->Strings[i] - stringbuf;
	}
d141 6
a146 6
	for (i=0; i < ep->nuses; i++) {
		if (ep->uses[i].parent == (void *)0)
			useoffsets[i] = ABSENT_OFFSET;
		else
			useoffsets[i] = (char *)(ep->uses[i].parent) - stringbuf;
	}
d148 13
a160 13
	if ((tp->str_table = typeMalloc(char, next_free)) == (char *)0)
		_nc_err_abort("Out of memory");
	(void) memcpy(tp->str_table, stringbuf, next_free);

	tp->term_names = tp->str_table + n;
	for_each_string(i, &(ep->tterm)) {
		if (offsets[i] == ABSENT_OFFSET)
			tp->Strings[i] = ABSENT_STRING;
		else if (offsets[i] == CANCELLED_OFFSET)
			tp->Strings[i] = CANCELLED_STRING;
		else
			tp->Strings[i] = tp->str_table + offsets[i];
	}
d163 12
a174 13
	if ((n = NUM_EXT_NAMES(tp)) != 0) {
		unsigned length = 0;
		for (i = 0; i < n; i++) {
			length += strlen(tp->ext_Names[i]) + 1;
			offsets[i] = tp->ext_Names[i] - stringbuf;
		}
		if ((tp->ext_str_table = typeMalloc(char, length)) == 0)
			_nc_err_abort("Out of memory");
		for (i = 0, length = 0; i < n; i++) {
			tp->ext_Names[i] = tp->ext_str_table + length;
			strcpy(tp->ext_Names[i], stringbuf + offsets[i]);
			length += strlen(tp->ext_Names[i]) + 1;
		}
d176 1
d179 6
a184 6
	for (i=0; i < ep->nuses; i++) {
		if (useoffsets[i] == ABSENT_OFFSET)
			ep->uses[i].parent = (void *)0;
		else
			ep->uses[i].parent = (char *)(tp->str_table + useoffsets[i]);
	}
d187 2
a188 1
void _nc_merge_entry(TERMTYPE *const to, TERMTYPE *const from)
d191 1
a191 1
    int	i;
d196 2
a197 3
    for_each_boolean(i, from)
    {
	int	mergebool = from->Booleans[i];
d205 2
a206 3
    for_each_number(i, from)
    {
	int	mergenum = from->Numbers[i];
d219 2
a220 3
    for_each_string(i, from)
    {
	char	*mergestring = from->Strings[i];
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc_entry.c,v 1.1 1998/07/23 21:17:25 millert Exp $	*/
d40 1
d42 1
d44 1
a44 2
 *	_nc_merge_entry();
 *	_nc_wrap_entry();
a50 1
#include <term.h>
d53 1
a53 1
MODULE_ID("$From: alloc_entry.c,v 1.14 1998/07/04 23:17:42 tom Exp $")
d68 14
a81 2
	for (i=0; i < BOOLCOUNT; i++)
		tp->Booleans[i] = FALSE; /* FIXME: why not ABSENT_BOOLEAN? */
d83 4
a86 1
	for (i=0; i < NUMCOUNT; i++)
d89 1
a89 1
	for (i=0; i < STRCOUNT; i++)
d95 11
d125 1
a125 1
int	offsets[STRCOUNT], useoffsets[MAX_USES];
d127 1
d129 3
a131 3
	n = ep->tterm.term_names - stringbuf;
	for (i=0; i < STRCOUNT; i++)
		if (ep->tterm.Strings[i] == ABSENT_STRING)
d133 1
a133 1
		else if (ep->tterm.Strings[i] == CANCELLED_STRING)
d136 2
a137 1
			offsets[i] = ep->tterm.Strings[i] - stringbuf;
d139 1
a139 1
	for (i=0; i < ep->nuses; i++)
d144 1
d146 1
a146 1
	if ((ep->tterm.str_table = (char *)malloc(next_free)) == (char *)0)
d148 1
a148 1
	(void) memcpy(ep->tterm.str_table, stringbuf, next_free);
d150 2
a151 2
	ep->tterm.term_names = ep->tterm.str_table + n;
	for (i=0; i < STRCOUNT; i++)
d153 1
a153 1
			ep->tterm.Strings[i] = ABSENT_STRING;
d155 1
a155 1
			ep->tterm.Strings[i] = CANCELLED_STRING;
d157 19
a175 1
			ep->tterm.Strings[i] = ep->tterm.str_table + offsets[i];
d177 1
a177 1
	for (i=0; i < ep->nuses; i++)
d181 2
a182 1
			ep->uses[i].parent = (char *)(ep->tterm.str_table + useoffsets[i]);
d190 4
a193 1
    for (i=0; i < BOOLCOUNT; i++)
d203 1
a203 1
    for (i=0; i < NUMCOUNT; i++)
d218 1
a218 1
    for (i=0; i < STRCOUNT; i++)
a227 1

@

