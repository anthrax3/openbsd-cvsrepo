head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.34
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.32
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.28
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.24
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.26
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.18
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.38
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.34
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.32
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.30
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.28
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.26
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.24
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.22
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.20
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.18
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.16
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.14
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.12
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.10
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.8
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.22.18.01.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.08.22.47.01;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.10.01.35.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.09.05.06.02;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.12.28.15.57.59;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.11.21.03.57;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.19;	author millert;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2002,2007 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey 1998 on                                        *
 ****************************************************************************/

/*
 *	raw.c
 *
 *	Routines:
 *		raw()
 *		cbreak()
 *		noraw()
 *		nocbreak()
 *		qiflush()
 *		noqiflush()
 *		intrflush()
 *
 */

#include <curses.priv.h>
#include <term.h>		/* cur_term */

MODULE_ID("$Id: lib_raw.c,v 1.14 2007/09/29 21:50:22 tom Exp $")

#if SVR4_TERMIO && !defined(_POSIX_SOURCE)
#define _POSIX_SOURCE
#endif

#if HAVE_SYS_TERMIO_H
#include <sys/termio.h>		/* needed for ISC */
#endif

#ifdef __EMX__
#include <io.h>
#define _nc_setmode(mode) setmode(SP->_ifd, mode)
#else
#define _nc_setmode(mode)	/* nothing */
#endif

#define COOKED_INPUT	(IXON|BRKINT|PARMRK)

#ifdef TRACE
#define BEFORE(N)	if (USE_TRACEF(TRACE_BITS)) _nc_locked_tracef("%s before bits: %s", N, _nc_tracebits())
#define AFTER(N)	if (USE_TRACEF(TRACE_BITS)) _nc_locked_tracef("%s after bits: %s", N, _nc_tracebits())
#else
#define BEFORE(s)
#define AFTER(s)
#endif /* TRACE */

NCURSES_EXPORT(int)
raw(void)
{
    int result = ERR;

    T((T_CALLED("raw()")));

    if (SP != 0 && cur_term != 0) {
	TTY buf;

	BEFORE("raw");
	_nc_setmode(O_BINARY);

	buf = cur_term->Nttyb;
#ifdef TERMIOS
	buf.c_lflag &= ~(ICANON | ISIG | IEXTEN);
	buf.c_iflag &= ~(COOKED_INPUT);
	buf.c_cc[VMIN] = 1;
	buf.c_cc[VTIME] = 0;
#else
	buf.sg_flags |= RAW;
#endif
	if ((result = _nc_set_tty_mode(&buf)) == OK) {
	    SP->_raw = TRUE;
	    SP->_cbreak = 1;
	    cur_term->Nttyb = buf;
	}
	AFTER("raw");
    }
    returnCode(result);
}

NCURSES_EXPORT(int)
cbreak(void)
{
    int result = ERR;

    T((T_CALLED("cbreak()")));

    if (SP != 0 && cur_term != 0) {
	TTY buf;

	BEFORE("cbreak");
	_nc_setmode(O_BINARY);

	buf = cur_term->Nttyb;
#ifdef TERMIOS
	buf.c_lflag &= ~ICANON;
	buf.c_iflag &= ~ICRNL;
	buf.c_lflag |= ISIG;
	buf.c_cc[VMIN] = 1;
	buf.c_cc[VTIME] = 0;
#else
	buf.sg_flags |= CBREAK;
#endif
	if ((result = _nc_set_tty_mode(&buf)) == OK) {
	    SP->_cbreak = 1;
	    cur_term->Nttyb = buf;
	}
	AFTER("cbreak");
    }
    returnCode(result);
}

/*
 * Note:
 * this implementation may be wrong.  See the comment under intrflush().
 */
NCURSES_EXPORT(void)
qiflush(void)
{
    int result = ERR;

    T((T_CALLED("qiflush()")));

    if (cur_term != 0) {
	TTY buf;

	BEFORE("qiflush");
	buf = cur_term->Nttyb;
#ifdef TERMIOS
	buf.c_lflag &= ~(NOFLSH);
	result = _nc_set_tty_mode(&buf);
#else
	/* FIXME */
#endif
	if (result == OK)
	    cur_term->Nttyb = buf;
	AFTER("qiflush");
    }
    returnVoid;
}

NCURSES_EXPORT(int)
noraw(void)
{
    int result = ERR;

    T((T_CALLED("noraw()")));

    if (SP != 0 && cur_term != 0) {
	TTY buf;

	BEFORE("noraw");
	_nc_setmode(O_TEXT);

	buf = cur_term->Nttyb;
#ifdef TERMIOS
	buf.c_lflag |= ISIG | ICANON |
	    (cur_term->Ottyb.c_lflag & IEXTEN);
	buf.c_iflag |= COOKED_INPUT;
#else
	buf.sg_flags &= ~(RAW | CBREAK);
#endif
	if ((result = _nc_set_tty_mode(&buf)) == OK) {
	    SP->_raw = FALSE;
	    SP->_cbreak = 0;
	    cur_term->Nttyb = buf;
	}
	AFTER("noraw");
    }
    returnCode(result);
}

NCURSES_EXPORT(int)
nocbreak(void)
{
    int result = ERR;

    T((T_CALLED("nocbreak()")));

    if (SP != 0 && cur_term != 0) {
	TTY buf;

	BEFORE("nocbreak");
	_nc_setmode(O_TEXT);

	buf = cur_term->Nttyb;
#ifdef TERMIOS
	buf.c_lflag |= ICANON;
	buf.c_iflag |= ICRNL;
#else
	buf.sg_flags &= ~CBREAK;
#endif
	if ((result = _nc_set_tty_mode(&buf)) == OK) {
	    SP->_cbreak = 0;
	    cur_term->Nttyb = buf;
	}
	AFTER("nocbreak");
    }
    returnCode(result);
}

/*
 * Note:
 * this implementation may be wrong.  See the comment under intrflush().
 */
NCURSES_EXPORT(void)
noqiflush(void)
{
    int result = ERR;

    T((T_CALLED("noqiflush()")));

    if (cur_term != 0) {
	TTY buf;

	BEFORE("noqiflush");
	buf = cur_term->Nttyb;
#ifdef TERMIOS
	buf.c_lflag |= NOFLSH;
	result = _nc_set_tty_mode(&buf);
#else
	/* FIXME */
#endif
	if (result == OK) {
	    cur_term->Nttyb = buf;
	}
	AFTER("noqiflush");
    }
    returnVoid;
}

/*
 * This call does the same thing as the qiflush()/noqiflush() pair.  We know
 * for certain that SVr3 intrflush() tweaks the NOFLSH bit; on the other hand,
 * the match (in the SVr4 man pages) between the language describing NOFLSH in
 * termio(7) and the language describing qiflush()/noqiflush() in
 * curs_inopts(3x) is too exact to be coincidence.
 */
NCURSES_EXPORT(int)
intrflush(WINDOW *win GCC_UNUSED, bool flag)
{
    int result = ERR;

    T((T_CALLED("intrflush(%d)"), flag));

    if (cur_term != 0) {
	TTY buf;

	BEFORE("intrflush");
	buf = cur_term->Nttyb;
#ifdef TERMIOS
	if (flag)
	    buf.c_lflag &= ~(NOFLSH);
	else
	    buf.c_lflag |= (NOFLSH);
	result = _nc_set_tty_mode(&buf);
#else
	/* FIXME */
#endif
	if (result == OK) {
	    cur_term->Nttyb = buf;
	}
	AFTER("intrflush");
    }
    returnCode(result);
}
@


1.7
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_raw.c,v 1.6 2000/10/08 22:47:01 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d54 1
a54 1
MODULE_ID("$From: lib_raw.c,v 1.10 2000/12/10 02:55:07 tom Exp $")
d66 3
d74 2
a75 2
#define BEFORE(N)	if (_nc_tracing&TRACE_BITS) _tracef("%s before bits: %s", N, _nc_tracebits())
#define AFTER(N)	if (_nc_tracing&TRACE_BITS) _tracef("%s after bits: %s", N, _nc_tracebits())
d84 2
d87 1
d89 1
d91 2
a92 6
	SP->_raw = TRUE;
	SP->_cbreak = 1;

#ifdef __EMX__
	setmode(SP->_ifd, O_BINARY);
#endif
d94 1
d96 4
a99 6
	BEFORE("raw");
	cur_term->Nttyb.c_lflag &= ~(ICANON | ISIG | IEXTEN);
	cur_term->Nttyb.c_iflag &= ~(COOKED_INPUT);
	cur_term->Nttyb.c_cc[VMIN] = 1;
	cur_term->Nttyb.c_cc[VTIME] = 0;
	AFTER("raw");
d101 1
a101 1
	cur_term->Nttyb.sg_flags |= RAW;
d103 6
a108 1
	returnCode(_nc_set_tty_mode(&cur_term->Nttyb));
d110 1
a110 1
    returnCode(ERR);
d116 2
d120 2
a121 1
    SP->_cbreak = 1;
d123 2
a124 3
#ifdef __EMX__
    setmode(SP->_ifd, O_BINARY);
#endif
d126 1
d128 5
a132 7
    BEFORE("cbreak");
    cur_term->Nttyb.c_lflag &= ~ICANON;
    cur_term->Nttyb.c_iflag &= ~ICRNL;
    cur_term->Nttyb.c_lflag |= ISIG;
    cur_term->Nttyb.c_cc[VMIN] = 1;
    cur_term->Nttyb.c_cc[VTIME] = 0;
    AFTER("cbreak");
d134 1
a134 1
    cur_term->Nttyb.sg_flags |= CBREAK;
d136 7
a142 1
    returnCode(_nc_set_tty_mode(&cur_term->Nttyb));
d145 4
d152 2
d156 2
a157 4
    /*
     * Note: this implementation may be wrong.  See the comment under
     * intrflush().
     */
d159 2
d162 9
a170 4
    BEFORE("qiflush");
    cur_term->Nttyb.c_lflag &= ~(NOFLSH);
    AFTER("qiflush");
    (void) _nc_set_tty_mode(&cur_term->Nttyb);
a171 1
#endif
d177 2
d181 2
a182 2
    SP->_raw = FALSE;
    SP->_cbreak = 0;
d184 2
a185 3
#ifdef __EMX__
    setmode(SP->_ifd, O_TEXT);
#endif
d187 1
d189 3
a191 5
    BEFORE("noraw");
    cur_term->Nttyb.c_lflag |= ISIG | ICANON |
	(cur_term->Ottyb.c_lflag & IEXTEN);
    cur_term->Nttyb.c_iflag |= COOKED_INPUT;
    AFTER("noraw");
d193 1
a193 1
    cur_term->Nttyb.sg_flags &= ~(RAW | CBREAK);
d195 8
a202 1
    returnCode(_nc_set_tty_mode(&cur_term->Nttyb));
d208 2
d212 2
a213 1
    SP->_cbreak = 0;
d215 2
a216 3
#ifdef __EMX__
    setmode(SP->_ifd, O_TEXT);
#endif
d218 1
d220 2
a221 4
    BEFORE("nocbreak");
    cur_term->Nttyb.c_lflag |= ICANON;
    cur_term->Nttyb.c_iflag |= ICRNL;
    AFTER("nocbreak");
d223 1
a223 1
    cur_term->Nttyb.sg_flags &= ~CBREAK;
d225 7
a231 1
    returnCode(_nc_set_tty_mode(&cur_term->Nttyb));
d234 4
d241 2
d245 2
a246 4
    /*
     * Note: this implementation may be wrong.  See the comment under
     * intrflush().
     */
d248 2
d251 10
a260 4
    BEFORE("noqiflush");
    cur_term->Nttyb.c_lflag |= NOFLSH;
    AFTER("noqiflush");
    (void) _nc_set_tty_mode(&cur_term->Nttyb);
a261 1
#endif
d264 7
d274 2
d278 11
a288 16
    /*
     * This call does the same thing as the qiflush()/noqiflush() pair.  We
     * know for certain that SVr3 intrflush() tweaks the NOFLSH bit; on the
     * other hand, the match (in the SVr4 man pages) between the language
     * describing NOFLSH in termio(7) and the language describing
     * qiflush()/noqiflush() in curs_inopts(3x) is too exact to be coincidence.
     */

#ifdef TERMIOS
    BEFORE("intrflush");
    if (flag)
	cur_term->Nttyb.c_lflag &= ~(NOFLSH);
    else
	cur_term->Nttyb.c_lflag |= (NOFLSH);
    AFTER("intrflush");
    returnCode(_nc_set_tty_mode(&cur_term->Nttyb));
d290 1
a290 1
    returnCode(ERR);
d292 6
@


1.6
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_raw.c,v 1.5 2000/03/10 01:35:04 millert Exp $	*/
d53 1
a53 1
MODULE_ID("$From: lib_raw.c,v 1.8 2000/09/02 18:08:48 tom Exp $")
d77 1
a77 1
int
d105 1
a105 1
int
d130 1
a130 1
void
d149 1
a149 1
int
d173 1
a173 1
int
d195 1
a195 1
void
d214 1
a214 1
int
@


1.5
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_raw.c,v 1.4 2000/01/09 05:06:02 millert Exp $	*/
d53 1
a53 1
MODULE_ID("$From: lib_raw.c,v 1.7 2000/02/13 01:01:26 tom Exp $")
d55 1
a55 1
#if defined(SVR4_TERMIO) && !defined(_POSIX_SOURCE)
@


1.4
log
@Update to ncurses-5.0-20000108:
+ add prototype for erase() to curses.h
+ add TRACE_DATABASE flag for trace().
+ formatting changes (style)
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_raw.c,v 1.3 1999/12/28 15:57:59 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d53 1
a53 1
MODULE_ID("$From: lib_raw.c,v 1.6 2000/01/08 17:28:48 tom Exp $")
@


1.3
log
@Update to ncurses-19991218
 o reorder tests during mouse initialization to allow for gpm to run in
   xterm, or for xterm to be used under OS/2 EMX.  Also drop test for
   $DISPLAY in favor of kmous=\E[M or $TERM containing "xterm" (report
   by Christian Weisgerber <naddy@@mips.rhein-neckar.de>).
 o modify raw() and noraw() to clear/restore IEXTEN flag which affects
   stty lnext on systems such as FreeBSD (report by Bruce Evans
   <bde@@zeta.org.au>, via Jason Evans <jasone@@canonware.com>).
 o add manual-page for ncurses extensions, documented curses_version(),
   use_extended_names().
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_raw.c,v 1.2 1999/03/11 21:03:57 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
d53 1
a53 1
MODULE_ID("$From: lib_raw.c,v 1.5 1999/12/19 01:57:23 tom Exp $")
a64 1
#include <fcntl.h>
d220 5
a224 6
     * This call does the same thing as the qiflush()/noqiflush()
     * pair.  We know for certain that SVr3 intrflush() tweaks the
     * NOFLSH bit; on the other hand, the match (in the SVr4 man
     * pages) between the language describing NOFLSH in termio(7)
     * and the language describing qiflush()/noqiflush() in
     * curs_inopts(3x) is too exact to be coincidence.
@


1.2
log
@ncurses-4.2-990307
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_raw.c,v 1.1 1999/01/18 19:10:19 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 1

d51 1
a51 1
#include <term.h>	/* cur_term */
d53 1
a53 1
MODULE_ID("$From: lib_raw.c,v 1.3 1999/03/06 22:28:24 tom Exp $")
d60 1
a60 1
#include <sys/termio.h>	/* needed for ISC */
d78 2
a79 1
int raw(void)
d81 2
a82 2
	T((T_CALLED("raw()")));
	if (SP != 0 && cur_term != 0) {
d84 2
a85 2
		SP->_raw = TRUE;
		SP->_cbreak = 1;
d88 1
a88 1
		setmode(SP->_ifd, O_BINARY);
d92 6
a97 6
		BEFORE("raw");
		cur_term->Nttyb.c_lflag &= ~(ICANON|ISIG);
		cur_term->Nttyb.c_iflag &= ~(COOKED_INPUT);
		cur_term->Nttyb.c_cc[VMIN] = 1;
		cur_term->Nttyb.c_cc[VTIME] = 0;
		AFTER("raw");
d99 1
a99 1
		cur_term->Nttyb.sg_flags |= RAW;
d101 3
a103 3
		returnCode(_nc_set_tty_mode(&cur_term->Nttyb));
	}
	returnCode(ERR);
d106 2
a107 1
int cbreak(void)
d109 1
a109 1
	T((T_CALLED("cbreak()")));
d111 1
a111 1
	SP->_cbreak = 1;
d114 1
a114 1
	setmode(SP->_ifd, O_BINARY);
d118 7
a124 7
	BEFORE("cbreak");
	cur_term->Nttyb.c_lflag &= ~ICANON;
	cur_term->Nttyb.c_iflag &= ~ICRNL;
	cur_term->Nttyb.c_lflag |= ISIG;
	cur_term->Nttyb.c_cc[VMIN] = 1;
	cur_term->Nttyb.c_cc[VTIME] = 0;
	AFTER("cbreak");
d126 1
a126 1
	cur_term->Nttyb.sg_flags |= CBREAK;
d128 1
a128 1
	returnCode(_nc_set_tty_mode( &cur_term->Nttyb));
d131 2
a132 1
void qiflush(void)
d134 1
a134 1
	T((T_CALLED("qiflush()")));
d136 4
a139 4
	/*
	 * Note: this implementation may be wrong.  See the comment under
	 * intrflush().
	 */
d142 5
a146 5
	BEFORE("qiflush");
	cur_term->Nttyb.c_lflag &= ~(NOFLSH);
	AFTER("qiflush");
	(void)_nc_set_tty_mode( &cur_term->Nttyb);
	returnVoid;
d150 2
a151 2

int noraw(void)
d153 1
a153 1
	T((T_CALLED("noraw()")));
d155 2
a156 2
	SP->_raw = FALSE;
	SP->_cbreak = 0;
d159 1
a159 1
	setmode(SP->_ifd, O_TEXT);
d163 5
a167 4
	BEFORE("noraw");
	cur_term->Nttyb.c_lflag |= ISIG|ICANON;
	cur_term->Nttyb.c_iflag |= COOKED_INPUT;
	AFTER("noraw");
d169 1
a169 1
	cur_term->Nttyb.sg_flags &= ~(RAW|CBREAK);
d171 1
a171 1
	returnCode(_nc_set_tty_mode( &cur_term->Nttyb));
d174 2
a175 2

int nocbreak(void)
d177 1
a177 1
	T((T_CALLED("nocbreak()")));
d179 1
a179 1
	SP->_cbreak = 0;
d182 1
a182 1
	setmode(SP->_ifd, O_TEXT);
d186 4
a189 4
	BEFORE("nocbreak");
	cur_term->Nttyb.c_lflag |= ICANON;
	cur_term->Nttyb.c_iflag |= ICRNL;
	AFTER("nocbreak");
d191 1
a191 1
	cur_term->Nttyb.sg_flags &= ~CBREAK;
d193 1
a193 1
	returnCode(_nc_set_tty_mode( &cur_term->Nttyb));
d196 2
a197 1
void noqiflush(void)
d199 1
a199 1
	T((T_CALLED("noqiflush()")));
d201 4
a204 4
	/*
	 * Note: this implementation may be wrong.  See the comment under
	 * intrflush().
	 */
d207 5
a211 5
	BEFORE("noqiflush");
	cur_term->Nttyb.c_lflag |= NOFLSH;
	AFTER("noqiflush");
	(void)_nc_set_tty_mode( &cur_term->Nttyb);
	returnVoid;
d215 2
a216 1
int intrflush(WINDOW *win GCC_UNUSED, bool flag)
d218 1
a218 1
	T((T_CALLED("intrflush(%d)"), flag));
d220 8
a227 8
	/*
	 * This call does the same thing as the qiflush()/noqiflush()
	 * pair.  We know for certain that SVr3 intrflush() tweaks the
	 * NOFLSH bit; on the other hand, the match (in the SVr4 man
	 * pages) between the language describing NOFLSH in termio(7)
	 * and the language describing qiflush()/noqiflush() in
	 * curs_inopts(3x) is too exact to be coincidence.
	 */
d230 7
a236 7
	BEFORE("intrflush");
	if (flag)
		cur_term->Nttyb.c_lflag &= ~(NOFLSH);
	else
		cur_term->Nttyb.c_lflag |= (NOFLSH);
	AFTER("intrflush");
	returnCode(_nc_set_tty_mode( &cur_term->Nttyb));
d238 1
a238 1
	returnCode(ERR);
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_raw.c,v 1.6 1998/11/17 03:16:21 millert Exp $	*/
d54 1
a54 1
MODULE_ID("$From: lib_raw.c,v 1.2 1998/12/20 00:42:58 tom Exp $")
d85 1
a85 1
		SP->_cbreak = TRUE;
d110 1
a110 1
	SP->_cbreak = TRUE;
d154 1
a154 1
	SP->_cbreak = FALSE;
d176 1
a176 1
	SP->_cbreak = FALSE;
@

