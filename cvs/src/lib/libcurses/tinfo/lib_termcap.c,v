head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.32
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.28
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.24
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.26
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.18
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.22
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.20
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.30
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.26
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.24
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.22
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.20
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.18
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.16
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.14
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.12
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.10
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.8
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.8
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.6
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.22.18.01.53;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.08.22.47.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.10.01.35.04;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.16.01.35.18;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.02.22.06.51;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.11.28.17.49.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.06.23.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.19;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 *                                                                          *
 * some of the code in here was contributed by:                             *
 * Magnus Bengtsson, d6mbeng@@dtek.chalmers.se (Nov'93)                      *
 * (but it has changed a lot)                                               *
 ****************************************************************************/

#define __INTERNAL_CAPS_VISIBLE
#include <curses.priv.h>

#include <termcap.h>
#include <tic.h>
#include <ctype.h>

#include <term_entry.h>

MODULE_ID("$Id: lib_termcap.c,v 1.63 2008/08/16 19:22:55 tom Exp $")

NCURSES_EXPORT_VAR(char *) UP = 0;
NCURSES_EXPORT_VAR(char *) BC = 0;

#define MyCache  _nc_globals.tgetent_cache
#define CacheInx _nc_globals.tgetent_index
#define CacheSeq _nc_globals.tgetent_sequence

#define FIX_SGR0 MyCache[CacheInx].fix_sgr0
#define LAST_TRM MyCache[CacheInx].last_term
#define LAST_BUF MyCache[CacheInx].last_bufp
#define LAST_USE MyCache[CacheInx].last_used
#define LAST_SEQ MyCache[CacheInx].sequence

/***************************************************************************
 *
 * tgetent(bufp, term)
 *
 * In termcap, this function reads in the entry for terminal `term' into the
 * buffer pointed to by bufp. It must be called before any of the functions
 * below are called.
 * In this terminfo emulation, tgetent() simply calls setupterm() (which
 * does a bit more than tgetent() in termcap does), and returns its return
 * value (1 if successful, 0 if no terminal with the given name could be
 * found, or -1 if no terminal descriptions have been installed on the
 * system).  The bufp argument is ignored.
 *
 ***************************************************************************/

NCURSES_EXPORT(int)
tgetent(char *bufp, const char *name)
{
    int errcode;
    int n;
    bool found_cache = FALSE;

    START_TRACE();
    T((T_CALLED("tgetent()")));

    _nc_setupterm((NCURSES_CONST char *) name, STDOUT_FILENO, &errcode, TRUE);

    /*
     * In general we cannot tell if the fixed sgr0 is still used by the
     * caller, but if tgetent() is called with the same buffer, that is
     * good enough, since the previous data would be invalidated by the
     * current call.
     *
     * bufp may be a null pointer, e.g., GNU termcap.  That allocates data,
     * which is good until the next tgetent() call.  The conventional termcap
     * is inconvenient because of the fixed buffer size, but because it uses
     * caller-supplied buffers, can have multiple terminal descriptions in
     * use at a given time.
     */
    for (n = 0; n < TGETENT_MAX; ++n) {
	bool same_result = (MyCache[n].last_used && MyCache[n].last_bufp == bufp);
	if (same_result) {
	    CacheInx = n;
	    if (FIX_SGR0 != 0) {
		FreeAndNull(FIX_SGR0);
	    }
	    /*
	     * Also free the terminfo data that we loaded (much bigger leak).
	     */
	    if (LAST_TRM != 0 && LAST_TRM != cur_term) {
		TERMINAL *trm = LAST_TRM;
		del_curterm(LAST_TRM);
		for (CacheInx = 0; CacheInx < TGETENT_MAX; ++CacheInx)
		    if (LAST_TRM == trm)
			LAST_TRM = 0;
		CacheInx = n;
	    }
	    found_cache = TRUE;
	    break;
	}
    }
    if (!found_cache) {
	int best = 0;

	for (CacheInx = 0; CacheInx < TGETENT_MAX; ++CacheInx) {
	    if (LAST_SEQ < MyCache[best].sequence) {
		best = CacheInx;
	    }
	}
	CacheInx = best;
    }
    LAST_TRM = cur_term;
    LAST_SEQ = ++CacheSeq;

    PC = 0;
    UP = 0;
    BC = 0;
    FIX_SGR0 = 0;		/* don't free it - application may still use */

    if (errcode == 1) {

	if (cursor_left)
	    if ((backspaces_with_bs = (char) !strcmp(cursor_left, "\b")) == 0)
		backspace_if_not_bs = cursor_left;

	/* we're required to export these */
	if (pad_char != NULL)
	    PC = pad_char[0];
	if (cursor_up != NULL)
	    UP = cursor_up;
	if (backspace_if_not_bs != NULL)
	    BC = backspace_if_not_bs;

	if ((FIX_SGR0 = _nc_trim_sgr0(&(cur_term->type))) != 0) {
	    if (!strcmp(FIX_SGR0, exit_attribute_mode)) {
		if (FIX_SGR0 != exit_attribute_mode) {
		    free(FIX_SGR0);
		}
		FIX_SGR0 = 0;
	    }
	}
	LAST_BUF = bufp;
	LAST_USE = TRUE;

	SetNoPadding(SP);
	(void) baudrate();	/* sets ospeed as a side-effect */

/* LINT_PREPRO
#if 0*/
#include <capdefaults.c>
/* LINT_PREPRO
#endif*/

    }
    returnCode(errcode);
}

/***************************************************************************
 *
 * tgetflag(str)
 *
 * Look up boolean termcap capability str and return its value (TRUE=1 if
 * present, FALSE=0 if not).
 *
 ***************************************************************************/

NCURSES_EXPORT(int)
tgetflag(NCURSES_CONST char *id)
{
    unsigned i;

    T((T_CALLED("tgetflag(%s)"), id));
    if (cur_term != 0) {
	TERMTYPE *tp = &(cur_term->type);
	for_each_boolean(i, tp) {
	    const char *capname = ExtBoolname(tp, i, boolcodes);
	    if (!strncmp(id, capname, 2)) {
		/* setupterm forces invalid booleans to false */
		returnCode(tp->Booleans[i]);
	    }
	}
    }
    returnCode(0);		/* Solaris does this */
}

/***************************************************************************
 *
 * tgetnum(str)
 *
 * Look up numeric termcap capability str and return its value, or -1 if
 * not given.
 *
 ***************************************************************************/

NCURSES_EXPORT(int)
tgetnum(NCURSES_CONST char *id)
{
    unsigned i;

    T((T_CALLED("tgetnum(%s)"), id));
    if (cur_term != 0) {
	TERMTYPE *tp = &(cur_term->type);
	for_each_number(i, tp) {
	    const char *capname = ExtNumname(tp, i, numcodes);
	    if (!strncmp(id, capname, 2)) {
		if (!VALID_NUMERIC(tp->Numbers[i]))
		    returnCode(ABSENT_NUMERIC);
		returnCode(tp->Numbers[i]);
	    }
	}
    }
    returnCode(ABSENT_NUMERIC);
}

/***************************************************************************
 *
 * tgetstr(str, area)
 *
 * Look up string termcap capability str and return a pointer to its value,
 * or NULL if not given.
 *
 ***************************************************************************/

NCURSES_EXPORT(char *)
tgetstr(NCURSES_CONST char *id, char **area)
{
    unsigned i;
    char *result = NULL, *base;

    if (area != 0 && *area != 0)
        base = *area;
    T((T_CALLED("tgetstr(%s,%p)"), id, area));
    if (cur_term != 0) {
	TERMTYPE *tp = &(cur_term->type);
	for_each_string(i, tp) {
	    const char *capname = ExtStrname(tp, i, strcodes);
	    if (!strncmp(id, capname, 2)) {
		result = tp->Strings[i];
		TR(TRACE_DATABASE, ("found match : %s", _nc_visbuf(result)));
		/* setupterm forces canceled strings to null */
		if (VALID_STRING(result)) {
		    if (result == exit_attribute_mode
			&& FIX_SGR0 != 0) {
			result = FIX_SGR0;
			TR(TRACE_DATABASE, ("altered to : %s", _nc_visbuf(result)));
		    }
		    if (area != 0 && *area != 0) {
			(void) strlcpy(*area, result, 1024 - (*area - base));
			result = *area;
			*area += strlen(*area) + 1;
		    }
		}
		break;
	    }
	}
    }
    returnPtr(result);
}

#if NO_LEAKS
NCURSES_EXPORT(void)
_nc_tgetent_leaks(void)
{
    for (CacheInx = 0; CacheInx < TGETENT_MAX; ++CacheInx) {
	FreeIfNeeded(FIX_SGR0);
	if (LAST_TRM != 0)
	    del_curterm(LAST_TRM);
    }
}
#endif
@


1.9
log
@Use strlcpy() / strlcat() throughout.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_termcap.c,v 1.8 2001/01/22 18:01:53 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 5
d41 1
d46 1
a47 1
#define __INTERNAL_CAPS_VISIBLE
d50 1
a50 1
MODULE_ID("$From: lib_termcap.c,v 1.39 2000/12/10 02:56:30 tom Exp $")
d52 12
a63 9
/*
   some of the code in here was contributed by:
   Magnus Bengtsson, d6mbeng@@dtek.chalmers.se
*/

NCURSES_EXPORT_VAR(char *)
UP = 0;
NCURSES_EXPORT_VAR(char *)
BC = 0;
d81 1
a81 2
tgetent
(char *bufp GCC_UNUSED, const char *name)
d84 2
d87 1
d90 53
a142 1
    setupterm((NCURSES_CONST char *) name, STDOUT_FILENO, &errcode);
d147 1
a147 1
	    if ((backspaces_with_bs = !strcmp(cursor_left, "\b")) == 0)
d158 12
d194 1
a194 1
    int i;
d222 1
a222 1
    int i;
d249 1
a249 2
tgetstr
(NCURSES_CONST char *id, char **area)
d251 2
a252 1
    int i;
d254 2
d262 2
a263 1
		TR(TRACE_DATABASE, ("found match : %s", _nc_visbuf(tp->Strings[i])));
d265 11
a275 5
		if (area != 0
		    && *area != 0
		    && VALID_STRING(tp->Strings[i])) {
		    (void) strlcpy(*area, tp->Strings[i], 1024);
		    *area += strlen(*area) + 1;
d277 1
a277 1
		returnPtr(tp->Strings[i]);
d281 12
a292 1
    returnPtr(NULL);
d294 1
@


1.8
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_termcap.c,v 1.7 2000/10/08 22:47:02 millert Exp $	*/
d190 1
a190 1
		    (void) strcpy(*area, tp->Strings[i]);
@


1.7
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_termcap.c,v 1.6 2000/03/10 01:35:04 millert Exp $	*/
d44 1
a44 1
MODULE_ID("$From: lib_termcap.c,v 1.37 2000/09/16 20:30:16 tom Exp $")
d51 4
a54 2
char *UP = 0;
char *BC = 0;
d71 3
a73 2
int
tgetent(char *bufp GCC_UNUSED, const char *name)
d116 1
a116 1
int
d144 1
a144 1
int
d173 3
a175 2
char *
tgetstr(NCURSES_CONST char *id, char **area)
d185 1
a185 1
		TR(TRACE_DATABASE,("found match : %s", _nc_visbuf(tp->Strings[i])));
@


1.6
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_termcap.c,v 1.5 2000/01/16 01:35:18 millert Exp $	*/
d44 1
a44 1
MODULE_ID("$From: lib_termcap.c,v 1.36 2000/02/13 01:01:26 tom Exp $")
a193 16
}

/*
 *	char *
 *	tgoto(string, x, y)
 *
 *	Retained solely for upward compatibility.  Note the intentional
 *	reversing of the last two arguments.
 *
 */

char *
tgoto(const char *string, int x, int y)
{
    T((T_CALLED("tgoto(%s,%d,%d)"), string, x, y));
    returnPtr(tparm((NCURSES_CONST char *) string, y, x));
@


1.5
log
@Update to ncurses-5.0-20000115:
+ additional fixes for non-bce terminals (handling of delete_character)
to work when assume_default_colors() is not specified.
+ modify warning message from _nc_parse_entry() regarding extended
capability names to print only if tic/infocmp/toe have the -v flag
set, and not at all in ordinary user applications.  Otherwise, this
warning would be shown for screen's extended capabilities in programs
that use the termcap interface.
+ modify use of _nc_tracing from programs such as tic so their debug
level is not in the same range as values set by trace() function.
+ small panel header cleanup (patch by Juergen Pfeifer).
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_termcap.c,v 1.4 2000/01/02 22:06:51 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d44 1
a44 1
MODULE_ID("$From: lib_termcap.c,v 1.35 2000/01/15 20:47:21 tom Exp $")
@


1.4
log
@+ corrected conversion from terminfo rs2 to termcap rs (cf: 980704)
+ make conversion to termcap ug (underline glitch) more consistently applied.
+ modify read_termtype(), fixing 'toe', which could dump core when it
found an incomplete entry such as "dumb" because it did not
initialize its buffer for _nc_read_file_entry().
+ use explicit VALID_NUMERIC() checks in a few places that had been
overlooked, and add a check to ensure that init_tabs is nonzero,
to avoid divide-by-zero (reported by Todd C Miller).
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_termcap.c,v 1.3 1999/11/28 17:49:54 millert Exp $	*/
d44 1
a44 1
MODULE_ID("$From: lib_termcap.c,v 1.32 2000/01/01 16:49:54 tom Exp $")
d153 1
a153 1
		    return ABSENT_NUMERIC;
a179 1
	    T(("trying %s", capname));
d181 2
a182 2
		T(("found match : %s", _nc_visbuf(tp->Strings[i])));
		/* setupterm forces cancelled strings to null */
@


1.3
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_termcap.c,v 1.2 1999/03/02 06:23:29 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
d44 1
a44 1
MODULE_ID("$From: lib_termcap.c,v 1.30 1999/10/30 23:00:16 tom Exp $")
d69 2
a70 1
int tgetent(char *bufp GCC_UNUSED, const char *name)
d72 1
a72 1
int errcode;
d74 1
a74 1
	T((T_CALLED("tgetent()")));
d76 1
a76 1
	setupterm((NCURSES_CONST char *)name, STDOUT_FILENO, &errcode);
d78 1
a78 1
	if (errcode == 1) {
d80 3
a82 3
		if (cursor_left)
		    if ((backspaces_with_bs = !strcmp(cursor_left, "\b")) == 0)
			backspace_if_not_bs = cursor_left;
d84 7
a90 7
		/* we're required to export these */
		if (pad_char != NULL)
			PC = pad_char[0];
		if (cursor_up != NULL)
			UP = cursor_up;
		if (backspace_if_not_bs != NULL)
			BC = backspace_if_not_bs;
d92 1
a92 1
		(void) baudrate();	/* sets ospeed as a side-effect */
d100 2
a101 2
	}
	returnCode(errcode);
d113 2
a114 1
int tgetflag(NCURSES_CONST char *id)
d116 1
a116 1
int i;
d118 8
a125 9
	T((T_CALLED("tgetflag(%s)"), id));
	if (cur_term != 0) {
	    TERMTYPE *tp = &(cur_term->type);
	    for_each_boolean(i, tp) {
		const char *capname = ExtBoolname(tp, i, boolcodes);
		if (!strncmp(id, capname, 2)) {
		    /* setupterm forces invalid booleans to false */
		    returnCode(tp->Booleans[i]);
		}
d128 2
a129 1
	returnCode(0);	/* Solaris does this */
d141 2
a142 1
int tgetnum(NCURSES_CONST char *id)
d144 1
a144 1
int i;
d146 9
a154 10
	T((T_CALLED("tgetnum(%s)"), id));
	if (cur_term != 0) {
	    TERMTYPE *tp = &(cur_term->type);
	    for_each_number(i, tp) {
		const char *capname = ExtNumname(tp, i, numcodes);
		if (!strncmp(id, capname, 2)) {
		    if (!VALID_NUMERIC(tp->Numbers[i]))
			return -1;
		    returnCode(tp->Numbers[i]);
		}
d157 2
a158 1
	returnCode(ERR);
d170 2
a171 1
char *tgetstr(NCURSES_CONST char *id, char **area)
d173 1
a173 1
int i;
d175 14
a188 16
	T((T_CALLED("tgetstr(%s,%p)"), id, area));
	if (cur_term != 0) {
	    TERMTYPE *tp = &(cur_term->type);
	    for_each_string(i, tp) {
		const char *capname = ExtStrname(tp, i, strcodes);
		T(("trying %s", capname));
		if (!strncmp(id, capname, 2)) {
		    T(("found match : %s", _nc_visbuf(tp->Strings[i])));
		    /* setupterm forces cancelled strings to null */
		    if (area != 0
		     && *area != 0
		     && VALID_STRING(tp->Strings[i])) {
			(void) strcpy(*area, tp->Strings[i]);
			*area += strlen(*area) + 1;
		    }
		    returnPtr(tp->Strings[i]);
d190 1
d193 2
a194 1
	returnPtr(NULL);
d206 2
a207 1
char *tgoto(const char *string, int x, int y)
d209 2
a210 2
	T((T_CALLED("tgoto(%s,%d,%d)"), string, x, y));
	returnPtr(tparm((NCURSES_CONST char *)string, y, x));
@


1.2
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_termcap.c,v 1.1 1999/01/18 19:10:19 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d44 1
a44 1
MODULE_ID("$From: lib_termcap.c,v 1.28 1999/02/27 22:12:58 tom Exp $")
d51 2
a52 2
char *UP;
char *BC;
d167 1
a167 1
char *tgetstr(NCURSES_CONST char *id, char **area GCC_UNUSED)
d180 6
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_termcap.c,v 1.4 1998/11/17 03:16:21 millert Exp $	*/
d42 1
a42 1
#include <term.h>
d44 1
a44 1
MODULE_ID("$From: lib_termcap.c,v 1.25 1999/01/10 00:48:11 tom Exp $")
d118 6
a123 5
		for (i = 0; i < BOOLCOUNT; i++) {
			if (!strncmp(id, boolcodes[i], 2)) {
				/* setupterm forces invalid booleans to false */
				returnCode(cur_term->type.Booleans[i]);
			}
d125 1
d145 7
a151 6
		for (i = 0; i < NUMCOUNT; i++) {
			if (!strncmp(id, numcodes[i], 2)) {
				if (!VALID_NUMERIC(cur_term->type.Numbers[i]))
					return -1;
				returnCode(cur_term->type.Numbers[i]);
			}
d153 1
d173 8
a180 7
		for (i = 0; i < STRCOUNT; i++) {
			T(("trying %s", strcodes[i]));
			if (!strncmp(id, strcodes[i], 2)) {
				T(("found match : %s", _nc_visbuf(cur_term->type.Strings[i])));
				/* setupterm forces cancelled strings to null */
				returnPtr(cur_term->type.Strings[i]);
			}
d182 1
@

