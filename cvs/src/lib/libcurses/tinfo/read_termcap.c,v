head	1.22;
access;
symbols
	OPENBSD_6_0:1.22.0.28
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.24
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.26
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.18
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.22
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.20
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.16
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.14
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.12
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.10
	OPENBSD_5_0:1.22.0.8
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.20.0.20
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.16
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.14
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.12
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.10
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.8
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.6
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.16.0.8
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.6
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.16.0.4
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.19.14.01.00;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.04.21.47.59;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.17.19.16.59;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.22.04.37.56;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.22.18.01.55;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.22.18.27.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.20.15.33.41;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.08.22.47.03;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.02.22.31.10;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.02.04.10.47;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.19.03.53.52;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.14.19.14.02;	author millert;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.03.26.16.45.04;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.13.23.53.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.10.01.35.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.09.05.06.02;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.05.08.20.29.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.06.23.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.22;	author millert;	state Exp;
branches;
next	;

1.8.2.1
date	2000.10.10.15.33.04;	author jason;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2005,2006 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 * Termcap compatibility support
 *
 * If your OS integrator didn't install a terminfo database, you can call
 * _nc_read_termcap_entry() to support reading and translating capabilities
 * from the system termcap file.  This is a kludge; it will bulk up and slow
 * down every program that uses ncurses, and translated termcap entries cannot
 * use full terminfo capabilities.  Don't use it unless you absolutely have to;
 * instead, get your system people to run tic(1) from root on the terminfo
 * master included with ncurses to translate it into a terminfo database.
 *
 * If USE_GETCAP is enabled, we use what is effectively a copy of the 4.4BSD
 * getcap code to fetch entries.  There are disadvantages to this; mainly that
 * getcap(3) does its own resolution, meaning that entries read in in this way
 * can't reference the terminfo tree.  The only thing it buys is faster startup
 * time, getcap(3) is much faster than our tic parser.
 */

#include <curses.priv.h>

#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <tic.h>
#include <term_entry.h>

MODULE_ID("$Id: read_termcap.c,v 1.71 2006/07/29 12:06:51 tom Exp $")

#if !PURE_TERMINFO

#define TC_SUCCESS     0
#define TC_NOT_FOUND  -1
#define TC_SYS_ERR    -2
#define TC_REF_LOOP   -3
#define TC_UNRESOLVED -4	/* this is not returned by BSD cgetent */

static NCURSES_CONST char *
get_termpath(void)
{
    NCURSES_CONST char *result;

    if (!use_terminfo_vars() || (result = getenv("TERMPATH")) == 0)
	result = TERMPATH;
    T(("TERMPATH is %s", result));
    return result;
}

#if USE_GETCAP

#if HAVE_BSD_CGETENT
#define _nc_cgetcap   cgetcap
#define _nc_cgetent(buf, oline, db_array, name) cgetent(buf, db_array, name)
#define _nc_cgetmatch cgetmatch
#define _nc_cgetset   cgetset
#else
static int _nc_cgetmatch(char *, const char *);
static int _nc_getent(char **, unsigned *, int *, int, char **, int, const char
		      *, int, char *);
static int _nc_nfcmp(const char *, char *);

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Casey Leedom of Lawrence Livermore National Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define	BFRAG		1024
#define	BSIZE		1024
#define	MAX_RECURSION	32	/* maximum getent recursion */

static size_t topreclen;	/* toprec length */
static char *toprec;		/* Additional record specified by cgetset() */
static int gottoprec;		/* Flag indicating retrieval of toprecord */

/*
 * Cgetset() allows the addition of a user specified buffer to be added to the
 * database array, in effect "pushing" the buffer on top of the virtual
 * database.  0 is returned on success, -1 on failure.
 */
static int
_nc_cgetset(const char *ent)
{
    if (ent == 0) {
	FreeIfNeeded(toprec);
	toprec = 0;
	topreclen = 0;
	return (0);
    }
    topreclen = strlen(ent);
    if ((toprec = typeMalloc(char, topreclen + 1)) == 0) {
	errno = ENOMEM;
	return (-1);
    }
    gottoprec = 0;
    (void) strlcpy(toprec, ent, topreclen + 1);
    return (0);
}

/*
 * Cgetcap searches the capability record buf for the capability cap with type
 * `type'.  A pointer to the value of cap is returned on success, 0 if the
 * requested capability couldn't be found.
 *
 * Specifying a type of ':' means that nothing should follow cap (:cap:).  In
 * this case a pointer to the terminating ':' or NUL will be returned if cap is
 * found.
 *
 * If (cap, '@@') or (cap, terminator, '@@') is found before (cap, terminator)
 * return 0.
 */
static char *
_nc_cgetcap(char *buf, const char *cap, int type)
{
    register const char *cp;
    register char *bp;

    bp = buf;
    for (;;) {
	/*
	 * Skip past the current capability field - it's either the
	 * name field if this is the first time through the loop, or
	 * the remainder of a field whose name failed to match cap.
	 */
	for (;;) {
	    if (*bp == '\0')
		return (0);
	    else if (*bp++ == ':')
		break;
	}

	/*
	 * Try to match (cap, type) in buf.
	 */
	for (cp = cap; *cp == *bp && *bp != '\0'; cp++, bp++)
	    continue;
	if (*cp != '\0')
	    continue;
	if (*bp == '@@')
	    return (0);
	if (type == ':') {
	    if (*bp != '\0' && *bp != ':')
		continue;
	    return (bp);
	}
	if (*bp != type)
	    continue;
	bp++;
	return (*bp == '@@' ? 0 : bp);
    }
    /* NOTREACHED */
}

/*
 * Cgetent extracts the capability record name from the NULL terminated file
 * array db_array and returns a pointer to a malloc'd copy of it in buf.  Buf
 * must be retained through all subsequent calls to cgetcap, cgetnum, cgetflag,
 * and cgetstr, but may then be freed.
 *
 * Returns:
 *
 * positive #    on success (i.e., the index in db_array)
 * TC_NOT_FOUND  if the requested record couldn't be found
 * TC_SYS_ERR    if a system error was encountered (e.g.,couldn't open a file)
 * TC_REF_LOOP   if a potential reference loop is detected
 * TC_UNRESOLVED if we had too many recurrences to resolve
 */
static int
_nc_cgetent(char **buf, int *oline, char **db_array, const char *name)
{
    unsigned dummy;

    return (_nc_getent(buf, &dummy, oline, 0, db_array, -1, name, 0, 0));
}

/*
 * Getent implements the functions of cgetent.  If fd is non-negative,
 * *db_array has already been opened and fd is the open file descriptor.  We
 * do this to save time and avoid using up file descriptors for tc=
 * recursions.
 *
 * Getent returns the same success/failure codes as cgetent.  On success, a
 * pointer to a malloc'd capability record with all tc= capabilities fully
 * expanded and its length (not including trailing ASCII NUL) are left in
 * *cap and *len.
 *
 * Basic algorithm:
 *	+ Allocate memory incrementally as needed in chunks of size BFRAG
 *	  for capability buffer.
 *	+ Recurse for each tc=name and interpolate result.  Stop when all
 *	  names interpolated, a name can't be found, or depth exceeds
 *	  MAX_RECURSION.
 */
#define DOALLOC(size) typeRealloc(char, size, record)
static int
_nc_getent(
	      char **cap,	/* termcap-content */
	      unsigned *len,	/* length, needed for recursion */
	      int *beginning,	/* line-number at match */
	      int in_array,	/* index in 'db_array[] */
	      char **db_array,	/* list of files to search */
	      int fd,
	      const char *name,
	      int depth,
	      char *nfield)
{
    register char *r_end, *rp;
    int myfd = FALSE;
    char *record = 0;
    int tc_not_resolved;
    int current;
    int lineno;

    /*
     * Return with ``loop detected'' error if we've recurred more than
     * MAX_RECURSION times.
     */
    if (depth > MAX_RECURSION)
	return (TC_REF_LOOP);

    /*
     * Check if we have a top record from cgetset().
     */
    if (depth == 0 && toprec != 0 && _nc_cgetmatch(toprec, name) == 0) {
	if ((record = DOALLOC(topreclen + BFRAG)) == 0) {
	    errno = ENOMEM;
	    return (TC_SYS_ERR);
	}
        (void) strlcpy(record, toprec, topreclen + BFRAG);
	rp = record + topreclen + 1;
	r_end = rp + BFRAG;
	current = in_array;
    } else {
	int foundit;

	/*
	 * Allocate first chunk of memory.
	 */
	if ((record = DOALLOC(BFRAG)) == 0) {
	    errno = ENOMEM;
	    return (TC_SYS_ERR);
	}
	rp = r_end = record + BFRAG;
	foundit = FALSE;

	/*
	 * Loop through database array until finding the record.
	 */
	for (current = in_array; db_array[current] != 0; current++) {
	    int eof = FALSE;

	    /*
	     * Open database if not already open.
	     */
	    if (fd >= 0) {
		(void) lseek(fd, (off_t) 0, SEEK_SET);
	    } else if ((_nc_access(db_array[current], R_OK) < 0)
		       || (fd = open(db_array[current], O_RDONLY, 0)) < 0) {
		/* No error on unfound file. */
		if (errno == ENOENT)
		    continue;
		free(record);
		return (TC_SYS_ERR);
	    } else {
		myfd = TRUE;
	    }
	    lineno = 0;

	    /*
	     * Find the requested capability record ...
	     */
	    {
		char buf[2048];
		register char *b_end = buf;
		register char *bp = buf;
		register int c;

		/*
		 * Loop invariants:
		 *      There is always room for one more character in record.
		 *      R_end always points just past end of record.
		 *      Rp always points just past last character in record.
		 *      B_end always points just past last character in buf.
		 *      Bp always points at next character in buf.
		 */

		for (;;) {
		    int first = lineno + 1;

		    /*
		     * Read in a line implementing (\, newline)
		     * line continuation.
		     */
		    rp = record;
		    for (;;) {
			if (bp >= b_end) {
			    int n;

			    n = read(fd, buf, sizeof(buf));
			    if (n <= 0) {
				if (myfd)
				    (void) close(fd);
				if (n < 0) {
				    free(record);
				    return (TC_SYS_ERR);
				}
				fd = -1;
				eof = TRUE;
				break;
			    }
			    b_end = buf + n;
			    bp = buf;
			}

			c = *bp++;
			if (c == '\n') {
			    lineno++;
			    if (rp == record || *(rp - 1) != '\\')
				break;
			}
			*rp++ = c;

			/*
			 * Enforce loop invariant: if no room
			 * left in record buffer, try to get
			 * some more.
			 */
			if (rp >= r_end) {
			    unsigned pos;
			    size_t newsize;

			    pos = rp - record;
			    newsize = r_end - record + BFRAG;
			    record = DOALLOC(newsize);
			    if (record == 0) {
				if (myfd)
				    (void) close(fd);
				errno = ENOMEM;
				return (TC_SYS_ERR);
			    }
			    r_end = record + newsize;
			    rp = record + pos;
			}
		    }
		    /* loop invariant lets us do this */
		    *rp++ = '\0';

		    /*
		     * If encountered eof check next file.
		     */
		    if (eof)
			break;

		    /*
		     * Toss blank lines and comments.
		     */
		    if (*record == '\0' || *record == '#')
			continue;

		    /*
		     * See if this is the record we want ...
		     */
		    if (_nc_cgetmatch(record, name) == 0
			&& (nfield == 0
			    || !_nc_nfcmp(nfield, record))) {
			foundit = TRUE;
			*beginning = first;
			break;	/* found it! */
		    }
		}
	    }
	    if (foundit)
		break;
	}

	if (!foundit)
	    return (TC_NOT_FOUND);
    }

    /*
     * Got the capability record, but now we have to expand all tc=name
     * references in it ...
     */
    {
	register char *newicap, *s;
	register int newilen;
	unsigned ilen;
	int diff, iret, tclen, oline;
	char *icap, *scan, *tc, *tcstart, *tcend;

	/*
	 * Loop invariants:
	 *      There is room for one more character in record.
	 *      R_end points just past end of record.
	 *      Rp points just past last character in record.
	 *      Scan points at remainder of record that needs to be
	 *      scanned for tc=name constructs.
	 */
	scan = record;
	tc_not_resolved = FALSE;
	for (;;) {
	    if ((tc = _nc_cgetcap(scan, "tc", '=')) == 0)
		break;

	    /*
	     * Find end of tc=name and stomp on the trailing `:'
	     * (if present) so we can use it to call ourselves.
	     */
	    s = tc;
	    while (*s != '\0') {
		if (*s++ == ':') {
		    *(s - 1) = '\0';
		    break;
		}
	    }
	    tcstart = tc - 3;
	    tclen = s - tcstart;
	    tcend = s;

	    iret = _nc_getent(&icap, &ilen, &oline, current, db_array, fd,
			      tc, depth + 1, 0);
	    newicap = icap;	/* Put into a register. */
	    newilen = ilen;
	    if (iret != TC_SUCCESS) {
		/* an error */
		if (iret < TC_NOT_FOUND) {
		    if (myfd)
			(void) close(fd);
		    free(record);
		    return (iret);
		}
		if (iret == TC_UNRESOLVED)
		    tc_not_resolved = TRUE;
		/* couldn't resolve tc */
		if (iret == TC_NOT_FOUND) {
		    *(s - 1) = ':';
		    scan = s - 1;
		    tc_not_resolved = TRUE;
		    continue;
		}
	    }

	    /* not interested in name field of tc'ed record */
	    s = newicap;
	    while (*s != '\0' && *s++ != ':') ;
	    newilen -= s - newicap;
	    newicap = s;

	    /* make sure interpolated record is `:'-terminated */
	    s += newilen;
	    if (*(s - 1) != ':') {
		*s = ':';	/* overwrite NUL with : */
		newilen++;
	    }

	    /*
	     * Make sure there's enough room to insert the
	     * new record.
	     */
	    diff = newilen - tclen;
	    if (diff >= r_end - rp) {
		unsigned pos, tcpos, tcposend;
		size_t newsize;

		pos = rp - record;
		newsize = r_end - record + diff + BFRAG;
		tcpos = tcstart - record;
		tcposend = tcend - record;
		record = DOALLOC(newsize);
		if (record == 0) {
		    if (myfd)
			(void) close(fd);
		    free(icap);
		    errno = ENOMEM;
		    return (TC_SYS_ERR);
		}
		r_end = record + newsize;
		rp = record + pos;
		tcstart = record + tcpos;
		tcend = record + tcposend;
	    }

	    /*
	     * Insert tc'ed record into our record.
	     */
	    s = tcstart + newilen;
	    memmove(s, tcend, (size_t) (rp - tcend));
	    memmove(tcstart, newicap, (size_t) newilen);
	    rp += diff;
	    free(icap);

	    /*
	     * Start scan on `:' so next cgetcap works properly
	     * (cgetcap always skips first field).
	     */
	    scan = s - 1;
	}
    }

    /*
     * Close file (if we opened it), give back any extra memory, and
     * return capability, length and success.
     */
    if (myfd)
	(void) close(fd);
    *len = rp - record - 1;	/* don't count NUL */
    if (r_end > rp) {
	if ((record = DOALLOC((size_t) (rp - record))) == 0) {
	    errno = ENOMEM;
	    return (TC_SYS_ERR);
	}
    }

    *cap = record;
    if (tc_not_resolved)
	return (TC_UNRESOLVED);
    return (current);
}

/*
 * Cgetmatch will return 0 if name is one of the names of the capability
 * record buf, -1 if not.
 */
static int
_nc_cgetmatch(char *buf, const char *name)
{
    register const char *np;
    register char *bp;

    /*
     * Start search at beginning of record.
     */
    bp = buf;
    for (;;) {
	/*
	 * Try to match a record name.
	 */
	np = name;
	for (;;) {
	    if (*np == '\0') {
		if (*bp == '|' || *bp == ':' || *bp == '\0')
		    return (0);
		else
		    break;
	    } else if (*bp++ != *np++) {
		break;
	    }
	}

	/*
	 * Match failed, skip to next name in record.
	 */
	bp--;			/* a '|' or ':' may have stopped the match */
	for (;;) {
	    if (*bp == '\0' || *bp == ':')
		return (-1);	/* match failed totally */
	    else if (*bp++ == '|')
		break;		/* found next name */
	}
    }
}

/*
 * Compare name field of record.
 */
static int
_nc_nfcmp(const char *nf, char *rec)
{
    char *cp, tmp;
    int ret;

    for (cp = rec; *cp != ':'; cp++) ;

    tmp = *(cp + 1);
    *(cp + 1) = '\0';
    ret = strcmp(nf, rec);
    *(cp + 1) = tmp;

    return (ret);
}
#endif /* HAVE_BSD_CGETENT */

/*
 * Since ncurses provides its own 'tgetent()', we cannot use the native one.
 * So we reproduce the logic to get down to cgetent() -- or our cut-down
 * version of that -- to circumvent the problem of configuring against the
 * termcap library.
 */
#define USE_BSD_TGETENT 1

#if USE_BSD_TGETENT
/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgment:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define	PBUFSIZ		512	/* max length of filename path */
#define	PVECSIZ		32	/* max number of names in path */
#define TBUFSIZ (2048*2)

static char *tbuf;

/*
 * On entry, srcp points to a non ':' character which is the beginning of the
 * token, if any.  We'll try to return a string that doesn't end with a ':'.
 */
static char *
get_tc_token(char **srcp, int *endp)
{
    int ch;
    bool found = FALSE;
    char *s, *base;
    char *tok = 0;

    *endp = TRUE;
    for (s = base = *srcp; *s != '\0';) {
	ch = *s++;
	if (ch == '\\') {
	    if (*s == '\0') {
		break;
	    } else if (*s++ == '\n') {
		while (isspace(UChar(*s)))
		    s++;
	    } else {
		found = TRUE;
	    }
	} else if (ch == ':') {
	    if (found) {
		tok = base;
		s[-1] = '\0';
		*srcp = s;
		*endp = FALSE;
		break;
	    }
	    base = s;
	} else if (isgraph(UChar(ch))) {
	    found = TRUE;
	}
    }

    /* malformed entry may end without a ':' */
    if (tok == 0 && found) {
	tok = base;
    }

    return tok;
}

static char *
copy_tc_token(char *dst, const char *src, size_t len)
{
    int ch;

    while ((ch = *src++) != '\0') {
	if (ch == '\\' && *src == '\n') {
	    while (isspace(UChar(*src)))
		src++;
	    continue;
	}
	if (--len == 0) {
	    dst = 0;
	    break;
	}
	*dst++ = ch;
    }
    return dst;
}

/*
 * Get an entry for terminal name in buffer bp from the termcap file.
 */
static int
_nc_tgetent(char *bp, char **sourcename, int *lineno, const char *name)
{
    static char *the_source;
    register char *p;
    register char *cp;
    char *dummy = NULL;
    char **fname;
    char *home;
    int i;
    char pathbuf[PBUFSIZ];	/* holds raw path of filenames */
    char *pathvec[PVECSIZ];	/* to point to names in pathbuf */
    char **pvec;		/* holds usable tail of path vector */
    NCURSES_CONST char *termpath;
    string_desc desc;

    fname = pathvec;
    pvec = pathvec;
    tbuf = bp;
    p = pathbuf;
    cp = use_terminfo_vars()? getenv("TERMCAP") : NULL;

    /*
     * TERMCAP can have one of two things in it.  It can be the name of a file
     * to use instead of /etc/termcap.  In this case it better start with a
     * "/".  Or it can be an entry to use so we don't have to read the file. 
     * In this case it has to already have the newlines crunched out.  If
     * TERMCAP does not hold a file name then a path of names is searched
     * instead.  The path is found in the TERMPATH variable, or becomes
     * "$HOME/.termcap /etc/termcap" if no TERMPATH exists.
     */
    _nc_str_init(&desc, pathbuf, sizeof(pathbuf));
    if (cp == NULL) {
	_nc_safe_strcpy(&desc, get_termpath());
    } else if (!_nc_is_abs_path(cp)) {	/* TERMCAP holds an entry */
	if ((termpath = get_termpath()) != 0) {
	    _nc_safe_strcat(&desc, termpath);
	} else {
	    char temp[PBUFSIZ];
	    temp[0] = 0;
	    if ((home = getenv("HOME")) != 0 && *home != '\0'
		&& strchr(home, ' ') == 0
		&& strlen(home) < sizeof(temp) - 10) {	/* setup path */
		snprintf(temp, sizeof(temp), "%s/", home);	/* $HOME first */
	    }
	    /* if no $HOME look in current directory */
	    strlcat(temp, ".termcap", sizeof temp);
	    _nc_safe_strcat(&desc, temp);
	    _nc_safe_strcat(&desc, " ");
	    _nc_safe_strcat(&desc, get_termpath());
	}
    } else {			/* user-defined name in TERMCAP */
	_nc_safe_strcat(&desc, cp);	/* still can be tokenized */
    }

    *fname++ = pathbuf;		/* tokenize path into vector of names */
    while (*++p) {
	if (*p == ' ' || *p == NCURSES_PATHSEP) {
	    *p = '\0';
	    while (*++p)
		if (*p != ' ' && *p != NCURSES_PATHSEP)
		    break;
	    if (*p == '\0')
		break;
	    *fname++ = p;
	    if (fname >= pathvec + PVECSIZ) {
		fname--;
		break;
	    }
	}
    }
    *fname = 0;			/* mark end of vector */
    if (_nc_is_abs_path(cp)) {
	if (_nc_cgetset(cp) < 0) {
	    return (TC_SYS_ERR);
	}
    }

    i = _nc_cgetent(&dummy, lineno, pathvec, name);

    /* ncurses' termcap-parsing routines cannot handle multiple adjacent
     * empty fields, and mistakenly use the last valid cap entry instead of
     * the first (breaks tc= includes)
     */
    if (i >= 0) {
	char *pd, *ps, *tok;
	int endflag = FALSE;
	char *list[1023];
	size_t n, count = 0;

	pd = bp;
	ps = dummy;
	while (!endflag && (tok = get_tc_token(&ps, &endflag)) != 0) {
	    bool ignore = FALSE;

	    for (n = 1; n < count; n++) {
		char *s = list[n];
		if (s[0] == tok[0]
		    && s[1] == tok[1]) {
		    ignore = TRUE;
		    break;
		}
	    }
	    if (ignore != TRUE) {
		list[count++] = tok;
		pd = copy_tc_token(pd, tok, TBUFSIZ - (2 + pd - bp));
		if (pd == 0) {
		    i = -1;
		    break;
		}
		*pd++ = ':';
		*pd = '\0';
	    }
	}
    }

    FreeIfNeeded(dummy);
    FreeIfNeeded(the_source);
    the_source = 0;

    /* This is not related to the BSD cgetent(), but to fake up a suitable
     * filename for ncurses' error reporting.  (If we are not using BSD
     * cgetent, then it is the actual filename).
     */
    if (i >= 0) {
#if HAVE_BSD_CGETENT
	char temp[PATH_MAX];

	_nc_str_init(&desc, temp, sizeof(temp));
	_nc_safe_strcpy(&desc, pathvec[i]);
	_nc_safe_strcat(&desc, ".db");
	if (_nc_access(temp, R_OK) == 0) {
	    _nc_safe_strcpy(&desc, pathvec[i]);
	}
	if ((the_source = strdup(temp)) != 0)
	    *sourcename = the_source;
#else
	if ((the_source = strdup(pathvec[i])) != 0)
	    *sourcename = the_source;
#endif
    }

    return (i);
}
#endif /* USE_BSD_TGETENT */
#endif /* USE_GETCAP */

#define MAXPATHS	32

/*
 * Add a filename to the list in 'termpaths[]', checking that we really have
 * a right to open the file.
 */
#if !USE_GETCAP
static int
add_tc(char *termpaths[], char *path, int count)
{
    char *save = strchr(path, NCURSES_PATHSEP);
    if (save != 0)
	*save = '\0';
    if (count < MAXPATHS
	&& _nc_access(path, R_OK) == 0) {
	termpaths[count++] = path;
	T(("Adding termpath %s", path));
    }
    termpaths[count] = 0;
    if (save != 0)
	*save = NCURSES_PATHSEP;
    return count;
}
#define ADD_TC(path, count) filecount = add_tc(termpaths, path, count)
#endif /* !USE_GETCAP */

NCURSES_EXPORT(int)
_nc_read_termcap_entry(const char *const tn, TERMTYPE *const tp)
{
    int found = TGETENT_NO;
    ENTRY *ep;
#if USE_GETCAP_CACHE
    char cwd_buf[PATH_MAX];
#endif
#if USE_GETCAP
    char *p, tc[TBUFSIZ];
    int status;
    static char *source;
    static int lineno;

    T(("read termcap entry for %s", tn));

    if (strlen(tn) == 0
	|| strcmp(tn, ".") == 0
	|| strcmp(tn, "..") == 0
	|| _nc_pathlast(tn) != 0) {
	T(("illegal or missing entry name '%s'", tn));
	return TGETENT_NO;
    }

    if (use_terminfo_vars() && (p = getenv("TERMCAP")) != 0
	&& !_nc_is_abs_path(p) && _nc_name_match(p, tn, "|:")) {
	/* TERMCAP holds a termcap entry */
	strncpy(tc, p, sizeof(tc) - 1);
	tc[sizeof(tc) - 1] = '\0';
	_nc_set_source("TERMCAP");
    } else {
	/* we're using getcap(3) */
	if ((status = _nc_tgetent(tc, &source, &lineno, tn)) < 0)
	    return (status == TC_NOT_FOUND ? TGETENT_NO : TGETENT_ERR);

	_nc_curr_line = lineno;
	_nc_set_source(source);
    }
    _nc_read_entry_source((FILE *) 0, tc, FALSE, FALSE, NULLHOOK);
#else
    /*
     * Here is what the 4.4BSD termcap(3) page prescribes:
     *
     * It will look in the environment for a TERMCAP variable.  If found, and
     * the value does not begin with a slash, and the terminal type name is the
     * same as the environment string TERM, the TERMCAP string is used instead
     * of reading a termcap file.  If it does begin with a slash, the string is
     * used as a path name of the termcap file to search.  If TERMCAP does not
     * begin with a slash and name is different from TERM, tgetent() searches
     * the files $HOME/.termcap and /usr/share/misc/termcap, in that order,
     * unless the environment variable TERMPATH exists, in which case it
     * specifies a list of file pathnames (separated by spaces or colons) to be
     * searched instead.
     *
     * It goes on to state:
     *
     * Whenever multiple files are searched and a tc field occurs in the
     * requested entry, the entry it names must be found in the same file or
     * one of the succeeding files.
     *
     * However, this restriction is relaxed in ncurses; tc references to
     * previous files are permitted.
     *
     * This routine returns 1 if an entry is found, 0 if not found, and -1 if
     * the database is not accessible.
     */
    FILE *fp;
    char *tc, *termpaths[MAXPATHS];
    int filecount = 0;
    int j, k;
    bool use_buffer = FALSE;
    bool normal = TRUE;
    char tc_buf[1024];
    char pathbuf[PATH_MAX];
    char *copied = 0;
    char *cp;
    struct stat test_stat[MAXPATHS];

    termpaths[filecount] = 0;
    if (use_terminfo_vars() && (tc = getenv("TERMCAP")) != 0) {
	if (_nc_is_abs_path(tc)) {	/* interpret as a filename */
	    ADD_TC(tc, 0);
	    normal = FALSE;
	} else if (_nc_name_match(tc, tn, "|:")) {	/* treat as a capability file */
	    use_buffer = TRUE;
	    (void) snprintf(tc_buf, sizeof(tc_buf), "%.*s\n", (int) sizeof(tc_buf) - 2, tc);
	    normal = FALSE;
	}
    }

    if (normal) {		/* normal case */
	char envhome[PATH_MAX], *h;

	copied = strdup(get_termpath());
	for (cp = copied; *cp; cp++) {
	    if (*cp == NCURSES_PATHSEP)
		*cp = '\0';
	    else if (cp == copied || cp[-1] == '\0') {
		ADD_TC(cp, filecount);
	    }
	}

#define PRIVATE_CAP "%s/.termcap"

	if (use_terminfo_vars() && (h = getenv("HOME")) != NULL && *h != '\0'
	    && (strlen(h) + sizeof(PRIVATE_CAP)) < PATH_MAX) {
	    /* user's .termcap, if any, should override it */
            (void) strlcpy(envhome, h, sizeof(envhome);
	    (void) snprintf(pathbuf, sizeof(pathbuf), PRIVATE_CAP, envhome);
	    ADD_TC(pathbuf, filecount);
	}
    }

    /*
     * Probably /etc/termcap is a symlink to /usr/share/misc/termcap.
     * Avoid reading the same file twice.
     */
#if HAVE_LINK
    for (j = 0; j < filecount; j++) {
	bool omit = FALSE;
	if (stat(termpaths[j], &test_stat[j]) != 0
	    || (test_stat[j].st_mode & S_IFMT) != S_IFREG) {
	    omit = TRUE;
	} else {
	    for (k = 0; k < j; k++) {
		if (test_stat[k].st_dev == test_stat[j].st_dev
		    && test_stat[k].st_ino == test_stat[j].st_ino) {
		    omit = TRUE;
		    break;
		}
	    }
	}
	if (omit) {
	    T(("Path %s is a duplicate", termpaths[j]));
	    for (k = j + 1; k < filecount; k++) {
		termpaths[k - 1] = termpaths[k];
		test_stat[k - 1] = test_stat[k];
	    }
	    --filecount;
	    --j;
	}
    }
#endif

    /* parse the sources */
    if (use_buffer) {
	_nc_set_source("TERMCAP");

	/*
	 * We don't suppress warning messages here.  The presumption is
	 * that since it's just a single entry, they won't be a pain.
	 */
	_nc_read_entry_source((FILE *) 0, tc_buf, FALSE, FALSE, NULLHOOK);
    } else {
	int i;

	for (i = 0; i < filecount; i++) {

	    T(("Looking for %s in %s", tn, termpaths[i]));
	    if (_nc_access(termpaths[i], R_OK) == 0
		&& (fp = fopen(termpaths[i], "r")) != (FILE *) 0) {
		_nc_set_source(termpaths[i]);

		/*
		 * Suppress warning messages.  Otherwise you get 400 lines of
		 * crap from archaic termcap files as ncurses complains about
		 * all the obsolete capabilities.
		 */
		_nc_read_entry_source(fp, (char *) 0, FALSE, TRUE, NULLHOOK);

		(void) fclose(fp);
	    }
	}
    }
    if (copied != 0)
	free(copied);
#endif /* USE_GETCAP */

    if (_nc_head == 0)
	return (TGETENT_ERR);

    /* resolve all use references */
    _nc_resolve_uses2(TRUE, FALSE);

    /* find a terminal matching tn, if we can */
#if USE_GETCAP_CACHE
    if (getcwd(cwd_buf, sizeof(cwd_buf)) != 0) {
	_nc_set_writedir((char *) 0);	/* note: this does a chdir */
#endif
	for_entry_list(ep) {
	    if (_nc_name_match(ep->tterm.term_names, tn, "|:")) {
		/*
		 * Make a local copy of the terminal capabilities, delinked
		 * from the list.
		 */
		*tp = ep->tterm;
		_nc_delink_entry(_nc_head, &(ep->tterm));
		free(ep);

		/*
		 * OK, now try to write the type to user's terminfo directory. 
		 * Next time he loads this, it will come through terminfo.
		 *
		 * Advantage:  Second and subsequent fetches of this entry will
		 * be very fast.
		 *
		 * Disadvantage:  After the first time a termcap type is loaded
		 * by its user, editing it in the /etc/termcap file, or in
		 * TERMCAP, or in a local ~/.termcap, will be ineffective
		 * unless the terminfo entry is explicitly removed.
		 */
#if USE_GETCAP_CACHE
		(void) _nc_write_entry(tp);
#endif
		found = TGETENT_YES;
		break;
	    }
	}
#if USE_GETCAP_CACHE
	chdir(cwd_buf);
    }
#endif

    return (found);
}
#else
extern
NCURSES_EXPORT(void)
_nc_read_termcap(void);
NCURSES_EXPORT(void)
_nc_read_termcap(void)
{
}
#endif /* PURE_TERMINFO */
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d58 2
d63 1
a63 1
MODULE_ID("$From: read_termcap.c,v 1.55 2000/12/10 02:55:08 tom Exp $")
d67 10
a76 6
#ifdef __EMX__
#define is_pathname(s) ((((s) != 0) && ((s)[0] == '/')) \
		  || (((s)[0] != 0) && ((s)[1] == ':')))
#else
#define is_pathname(s) ((s) != 0 && (s)[0] == '/')
#endif
d78 5
a82 5
#define TC_SUCCESS     0
#define TC_UNRESOLVED -1
#define TC_NOT_FOUND  -2
#define TC_SYS_ERR    -3
#define TC_REF_LOOP   -4
a130 1
#define	ESC		('[' & 037)	/* ASCII ESC */
a131 5
#define	SFRAG		100	/* cgetstr mallocs in SFRAG chunks */

#define RECOK	(char)0
#define TCERR	(char)1
#define	SHADOW	(char)2
a223 1
 * TC_UNRESOLVED if we had too many recurrences to resolve
d227 1
d290 1
a290 1
	(void) strlcpy(record, toprec, topreclen + BFRAG);
d665 5
a669 1
 * 3. Neither the name of the University nor the names of its contributors
d711 1
a711 1
		while (isspace(*s))
d725 1
a725 1
	} else if (isgraph(ch)) {
d745 1
a745 1
	    while (isspace(*src))
a764 1

d774 1
a774 1
    char *termpath;
d794 3
a796 3
	_nc_safe_strcpy(&desc, "/usr/share/misc/termcap /etc/termcap");
    } else if (!is_pathname(cp)) {	/* TERMCAP holds an entry */
	if ((termpath = getenv("TERMPATH")) != 0) {
a799 1
	    size_t len;
d802 3
a804 5
	     && strchr(home, ' ') == 0) { /* setup path */
		len = snprintf(temp, sizeof(temp), "%s/.termcap", home);
		if (len < sizeof(temp)) {
		    _nc_safe_strcat(&desc, temp);
		}
d806 5
a810 2
	    _nc_safe_strcat(&desc, " /usr/share/misc/termcap");
	    _nc_safe_strcat(&desc, " /etc/termcap");
d833 1
a833 1
    if (is_pathname(cp)) {
d886 12
d900 1
d918 3
d922 1
a922 1
	&& _nc_access(path, R_OK) == 0)
d924 2
d927 2
d935 1
a935 2
_nc_read_termcap_entry
(const char *const tn, TERMTYPE * const tp)
d937 1
a937 1
    int found = FALSE;
d948 10
d959 1
a959 1
	&& !is_pathname(p) && _nc_name_match(p, tn, "|:")) {
d961 2
a962 1
	strlcpy(tc, p, sizeof(tc));
d967 1
a967 1
	    return (status == -1 ? 0 : -1);
d972 1
a972 1
    _nc_read_entry_source((FILE *) 0, tc, FALSE, TRUE, NULLHOOK);
d1003 1
d1005 1
d1008 3
d1014 1
a1014 1
	if (is_pathname(tc)) {	/* interpret as a filename */
d1016 1
d1019 2
a1020 12
	    (void) snprintf(tc_buf, sizeof(tc_buf), "%.*s\n",
		(int) sizeof(tc_buf) - 2, tc);
	} else if ((tc = getenv("TERMPATH")) != 0) {
	    char *cp;

	    for (cp = tc; *cp; cp++) {
		if (*cp == NCURSES_PATHSEP)
		    *cp = '\0';
		else if (cp == tc || cp[-1] == '\0') {
		    ADD_TC(cp, filecount);
		}
	    }
d1022 3
a1024 1
    } else {			/* normal case */
d1027 8
a1034 10
	filecount = 0;

	/*
	 * Probably /etc/termcap is a symlink to /usr/share/misc/termcap.
	 * Avoid reading the same file twice.
	 */
	if (_nc_access("/etc/termcap", F_OK) == 0)
	    ADD_TC("/etc/termcap", filecount);
	else
	    ADD_TC("/usr/share/misc/termcap", filecount);
d1041 1
a1041 1
	    (void) strlcpy(envhome, h, sizeof(envhome));
d1047 31
d1081 6
a1086 1
	_nc_read_entry_source((FILE *) 0, tc_buf, FALSE, TRUE, NULLHOOK);
d1093 2
a1094 1
	    if ((fp = fopen(termpaths[i], "r")) != (FILE *) 0) {
d1108 2
d1113 1
a1113 1
	return (ERR);
d1116 1
a1116 1
    _nc_resolve_uses(TRUE);
d1126 2
a1127 4
		 * Make a local copy of the terminal capabilities.  Free all
		 * entry storage except the string table for the loaded type
		 * (which we disconnected from the list by NULLing out
		 * ep->tterm.str_table above).
d1130 2
a1131 1
		ep->tterm.str_table = (char *) 0;
d1148 1
a1148 1
		found = TRUE;
a1156 1
    _nc_free_entries(_nc_head);
@


1.20
log
@Convert return value of cgetent(3) to what the curses routines expect.
Fixes a problem where an unknown terminal type would be reported as
"database not found".  Noticed by grunk@@
@
text
@a119 2
/* static char sccsid[] = "@@(#)getcap.c	8.3 (Berkeley) 3/25/94"; */

a677 2

/* static char sccsid[] = "@@(#)termcap.c	8.1 (Berkeley) 6/4/93" */
@


1.19
log
@mop up some more 3/4 license issues
@
text
@d923 1
d934 2
a935 2
	if (_nc_tgetent(tc, &source, &lineno, tn) < 0)
	    return (ERR);
@


1.18
log
@Use strlcpy() / strlcat() throughout.
@
text
@d103 1
a103 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgment:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d664 1
a664 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgment:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@use snprintf throughout
@
text
@d160 1
a160 1
    (void) strcpy(toprec, ent);
d293 1
a293 1
	(void) strcpy(record, toprec);
d1020 1
a1020 1
	    (void) strcpy(envhome, h);
@


1.16
log
@Make _nc_get_token() take a "silent" argument and only warn if it
is not set.  Propagate "silent" flag in _nc_parse_entry() to _nc_get_token().
Set the silent flag when reading termcap files, including $TERMCAP.
@
text
@d988 2
a989 1
	    (void) sprintf(tc_buf, "%.*s\n", (int) sizeof(tc_buf) - 2, tc);
d1021 1
a1021 1
	    (void) sprintf(pathbuf, PRIVATE_CAP, envhome);
@


1.15
log
@Update to ncurses-5.2-20010114
@
text
@d947 1
a947 1
    _nc_read_entry_source((FILE *) 0, tc, FALSE, FALSE, NULLHOOK);
d1028 1
a1028 6

	/*
	 * We don't suppress warning messages here.  The presumption is
	 * that since it's just a single entry, they won't be a pain.
	 */
	_nc_read_entry_source((FILE *) 0, tc_buf, FALSE, FALSE, NULLHOOK);
@


1.14
log
@update to ncurses 5.2
@
text
@d58 1
a58 1
MODULE_ID("$From: read_termcap.c,v 1.51 2000/10/21 00:34:11 Philip.Guenther Exp $")
d787 1
a787 1
    cp = use_terminfo_vars() ? getenv("TERMCAP") : NULL;
d824 1
a824 1
	if (*p == ' ' || *p == ':') {
d827 1
a827 1
		if (*p != ' ' && *p != ':')
d920 3
a922 2
int
_nc_read_termcap_entry(const char *const tn, TERMTYPE * const tp)
d993 1
a993 1
		if (*cp == ':')
d1106 4
a1109 2
extern void _nc_read_termcap(void);
void
@


1.13
log
@Don't attempt to free uninitialized variable; guenther@@gac.edu
@
text
@d58 1
a58 1
MODULE_ID("$From: read_termcap.c,v 1.49 2000/10/05 00:37:19 tom Exp $")
d84 2
a85 1
static int _nc_getent(char **, unsigned *, int *, int, char **, int, const char *, int, char *);
d261 9
a269 9
    char **cap,			/* termcap-content */
    unsigned *len,		/* length, needed for recursion */
    int *beginning,		/* line-number at match */
    int in_array,		/* index in 'db_array[] */
    char **db_array,		/* list of files to search */
    int fd,
    const char *name,
    int depth,
    char *nfield)
d322 1
a322 1
		|| (fd = open(db_array[current], O_RDONLY, 0)) < 0) {
d485 1
a485 1
		tc, depth + 1, 0);
@


1.12
log
@update to ncurses-5.1-20001007
@
text
@d772 1
a772 1
    char *dummy;
@


1.11
log
@Don't call cgetset() on $TERMCAP if setugid.  The logic has been reworked
a bit to make it clear what is supposed to happen.  Also fix some policy
wrt setugid in code we don't actually compile for consistency's sake.
@
text
@a0 2
/*	$OpenBSD: read_termcap.c,v 1.10 2000/08/02 04:10:47 millert Exp $	 */

d58 1
a58 1
MODULE_ID("$From: read_termcap.c,v 1.47 2000/04/15 16:53:19 Todd.C.Miller Exp $")
d60 1
a60 1
#ifndef PURE_TERMINFO
d780 1
d786 1
a786 1
    cp = issetugid() ? NULL : getenv("TERMCAP");
d797 16
a812 16
#define	MY_PATH_DEF	"/etc/termcap /usr/share/misc/termcap"
    if (issetugid())
	strlcpy(pathbuf, MY_PATH_DEF, PBUFSIZ);
    else {
	if (!is_pathname(cp)) {	/* no TERMCAP or it holds an entry */
	    if ((termpath = getenv("TERMPATH")) != 0) {
		strlcpy(pathbuf, termpath, PBUFSIZ);
	    } else {
		if ((home = getenv("HOME")) != 0 && *home != '\0' &&
		    strlen(home) < PBUFSIZ) {	/* setup path */
		    p += strlen(home);	/* path, looking in */
		    strcpy(pathbuf, home);	/* $HOME first */
		    *p++ = '/';
		}			/* if no $HOME look in cwd */
		strlcpy(p, ".termcap " MY_PATH_DEF,
		    (size_t) (PBUFSIZ - (p - pathbuf)));
d814 5
a818 2
	} else			/* user-defined name in TERMCAP */
	    strlcpy(pathbuf, cp, PBUFSIZ);	/* still can be tokenized */
d932 1
a932 1
    if (!issetugid() && (p = getenv("TERMCAP")) != 0
d981 1
a981 1
    if (!issetugid() && (tc = getenv("TERMCAP"))) {
d1014 1
a1014 1
	if (!issetugid() && (h = getenv("HOME")) != NULL && *home != '\0'
@


1.10
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.9 2000/06/19 03:53:52 millert Exp $	 */
d787 1
a787 1
    cp = getenv("TERMCAP");
d801 17
a817 15
    else if (!is_pathname(cp)) {	/* no TERMCAP or it holds an entry */
	if ((termpath = getenv("TERMPATH")) != 0) {
	    strlcpy(pathbuf, termpath, PBUFSIZ);
	} else {
	    if ((home = getenv("HOME")) != 0 && *home != '\0' &&
		strlen(home) < PBUFSIZ) {	/* setup path */
		p += strlen(home);	/* path, looking in */
		strcpy(pathbuf, home);	/* $HOME first */
		*p++ = '/';
	    }			/* if no $HOME look in current directory */
	    strlcpy(p, ".termcap " MY_PATH_DEF,
		(size_t) (PBUFSIZ - (p - pathbuf)));
	}
    } else			/* user-defined name in TERMCAP */
	strlcpy(pathbuf, cp, PBUFSIZ);	/* still can be tokenized */
d979 1
a979 1
    if ((tc = getenv("TERMCAP")) != 0 && (!issetugid() || !is_pathname(tc))) {
@


1.9
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.8 2000/04/14 19:14:02 millert Exp $	 */
d805 1
a805 1
	    if ((home = getenv("HOME")) != 0 &&
d1010 1
a1010 1
	if (!issetugid() && (h = getenv("HOME")) != NULL
@


1.8
log
@Check $TERMCAP for a termcap entry even when we are using the system's
getcap(3) routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.7 2000/03/26 16:45:04 millert Exp $	 */
d60 1
a60 1
MODULE_ID("$From: read_termcap.c,v 1.46 2000/03/18 21:53:26 tom Exp $")
d928 3
a930 3
    if (!issetugid() && (p = getenv("TERMCAP")) != 0 && !is_pathname(p) &&
	_nc_name_match(p, tn, "|:")) {

@


1.8.2.1
log
@Pull in patch from current:
Errata:
libcurses honored terminal descriptions in the $HOME/.terminfo directory as
well as in the TERMCAP environment variable for setuid and setgid applications.
Fix (millert):
Don't call cgetset() on $TERMCAP if setugid.  The logic has been reworked
a bit to make it clear what is supposed to happen.  Also fix some policy
wrt setugid in code we don't actually compile for consistency's sake.
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.8 2000/04/14 19:14:02 millert Exp $	 */
d787 1
a787 1
    cp = issetugid() ? NULL : getenv("TERMCAP");
d801 15
a815 17
    else {
	if (!is_pathname(cp)) {	/* no TERMCAP or it holds an entry */
	    if ((termpath = getenv("TERMPATH")) != 0) {
		strlcpy(pathbuf, termpath, PBUFSIZ);
	    } else {
		if ((home = getenv("HOME")) != 0 && *home != '\0' &&
		    strlen(home) < PBUFSIZ) {	/* setup path */
		    p += strlen(home);	/* path, looking in */
		    strcpy(pathbuf, home);	/* $HOME first */
		    *p++ = '/';
		}			/* if no $HOME look in cwd */
		strlcpy(p, ".termcap " MY_PATH_DEF,
		    (size_t) (PBUFSIZ - (p - pathbuf)));
	    }
	} else			/* user-defined name in TERMCAP */
	    strlcpy(pathbuf, cp, PBUFSIZ);	/* still can be tokenized */
    }
d977 1
a977 1
    if (!issetugid() && (tc = getenv("TERMCAP"))) {
d1010 1
a1010 1
	if (!issetugid() && (h = getenv("HOME")) != NULL && *h != '\0'
@


1.7
log
@Update to ncurses-5.0-20000325
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.6 2000/03/13 23:53:40 millert Exp $	 */
d924 1
a924 1
    char tc[TBUFSIZ];
d928 2
a929 3
    /* we're using getcap(3) */
    if (_nc_tgetent(tc, &source, &lineno, tn) < 0)
	return (ERR);
d931 10
a940 2
    _nc_curr_line = lineno;
    _nc_set_source(source);
@


1.6
log
@update to ncurses-5.0-20000311
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.5 2000/03/10 01:35:04 millert Exp $	 */
d60 1
a60 1
MODULE_ID("$From: read_termcap.c,v 1.45 2000/02/13 01:01:26 tom Exp $")
@


1.5
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.4 2000/01/09 05:06:02 millert Exp $	 */
d1047 1
a1047 1
    _nc_resolve_uses();
@


1.4
log
@Update to ncurses-5.0-20000108:
+ add prototype for erase() to curses.h
+ add TRACE_DATABASE flag for trace().
+ formatting changes (style)
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.3 1999/05/08 20:29:02 millert Exp $	 */
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d60 1
a60 1
MODULE_ID("$From: read_termcap.c,v 1.44 2000/01/08 17:27:31 tom Exp $")
@


1.3
log
@ncurses-4.2-990424
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.2 1999/03/02 06:23:29 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 1

d60 1
a60 5
#if HAVE_FCNTL_H
#include <fcntl.h>
#endif

MODULE_ID("$From: read_termcap.c,v 1.43 1999/04/10 20:52:52 tom Exp $")
d86 1
a86 1
static int _nc_getent(char **, unsigned int *, int *, int, char **, int, const char *, int, char *);
d130 2
a131 2
#define	MAX_RECURSION	32		/* maximum getent recursion */
#define	SFRAG		100		/* cgetstr mallocs in SFRAG chunks */
d137 3
a139 3
static size_t	 topreclen;	/* toprec length */
static char	*toprec;	/* Additional record specified by cgetset() */
static int	 gottoprec;	/* Flag indicating retrieval of toprecord */
d149 4
a152 13
	if (ent == 0) {
		FreeIfNeeded(toprec);
		toprec = 0;
		topreclen = 0;
		return (0);
	}
	topreclen = strlen(ent);
	if ((toprec = typeMalloc(char, topreclen + 1)) == 0) {
		errno = ENOMEM;
		return (-1);
	}
	gottoprec = 0;
	(void)strcpy(toprec, ent);
d154 9
d180 2
a181 2
	register const char *cp;
	register char *bp;
d183 7
a189 1
	bp = buf;
d191 5
a195 11
		/*
		 * Skip past the current capability field - it's either the
		 * name field if this is the first time through the loop, or
		 * the remainder of a field whose name failed to match cap.
		 */
		for (;;) {
			if (*bp == '\0')
				return (0);
			else if (*bp++ == ':')
				break;
		}
d197 13
a209 18
		/*
		 * Try to match (cap, type) in buf.
		 */
		for (cp = cap; *cp == *bp && *bp != '\0'; cp++, bp++)
			continue;
		if (*cp != '\0')
			continue;
		if (*bp == '@@')
			return (0);
		if (type == ':') {
			if (*bp != '\0' && *bp != ':')
				continue;
			return(bp);
		}
		if (*bp != type)
			continue;
		bp++;
		return (*bp == '@@' ? 0 : bp);
d211 6
a216 1
	/* NOTREACHED */
d236 1
a236 1
	unsigned int dummy;
d238 1
a238 1
	return (_nc_getent(buf, &dummy, oline, 0, db_array, -1, name, 0, 0));
d262 9
a270 9
	char **cap,         /* termcap-content */
	unsigned int *len,  /* length, needed for recursion */
	int *beginning,     /* line-number at match */
	int in_array,       /* index in 'db_array[] */
	char **db_array,    /* list of files to search */
	int fd,
	const char *name,
	int depth,
	char *nfield)
d272 28
a299 6
	register char *r_end, *rp;
	int myfd = FALSE;
	char *record = 0;
	int tc_not_resolved;
	int current;
	int lineno;
d302 1
a302 2
	 * Return with ``loop detected'' error if we've recurred more than
	 * MAX_RECURSION times.
d304 6
a309 2
	if (depth > MAX_RECURSION)
		return (TC_REF_LOOP);
d312 1
a312 1
	 * Check if we have a top record from cgetset().
d314 2
a315 11
	if (depth == 0 && toprec != 0 && _nc_cgetmatch(toprec, name) == 0) {
		if ((record = DOALLOC(topreclen + BFRAG)) == 0) {
			errno = ENOMEM;
			return (TC_SYS_ERR);
		}
		(void)strcpy(record, toprec);
		rp = record + topreclen + 1;
		r_end = rp + BFRAG;
		current = in_array;
	} else {
		int foundit;
d317 25
a341 9
		/*
		 * Allocate first chunk of memory.
		 */
		if ((record = DOALLOC(BFRAG)) == 0) {
			errno = ENOMEM;
			return (TC_SYS_ERR);
		}
		rp = r_end = record + BFRAG;
		foundit = FALSE;
d344 6
a349 1
		 * Loop through database array until finding the record.
a350 2
		for (current = in_array; db_array[current] != 0; current++) {
			int eof = FALSE;
d352 2
a353 16
			/*
			 * Open database if not already open.
			 */
			if (fd >= 0) {
				(void)lseek(fd, (off_t)0, SEEK_SET);
			} else if ((_nc_access(db_array[current], R_OK) < 0)
			  || (fd = open(db_array[current], O_RDONLY, 0)) < 0) {
				/* No error on unfound file. */
				if (errno == ENOENT)
					continue;
				free(record);
				return (TC_SYS_ERR);
			} else {
				myfd = TRUE;
			}
			lineno = 0;
d355 16
a370 101
			/*
			 * Find the requested capability record ...
			 */
			{
				char buf[2048];
				register char *b_end = buf;
				register char *bp = buf;
				register int c;

				/*
				 * Loop invariants:
				 *	There is always room for one more character in record.
				 *	R_end always points just past end of record.
				 *	Rp always points just past last character in record.
				 *	B_end always points just past last character in buf.
				 *	Bp always points at next character in buf.
				 */

				for (;;) {
					int first = lineno + 1;

					/*
					 * Read in a line implementing (\, newline)
					 * line continuation.
					 */
					rp = record;
					for (;;) {
						if (bp >= b_end) {
							int n;

							n = read(fd, buf, sizeof(buf));
							if (n <= 0) {
								if (myfd)
									(void)close(fd);
								if (n < 0) {
									free(record);
									return (TC_SYS_ERR);
								}
								fd = -1;
								eof = TRUE;
								break;
							}
							b_end = buf+n;
							bp = buf;
						}

						c = *bp++;
						if (c == '\n') {
							lineno++;
							if (rp == record || *(rp-1) != '\\')
								break;
						}
						*rp++ = c;

						/*
						 * Enforce loop invariant: if no room
						 * left in record buffer, try to get
						 * some more.
						 */
						if (rp >= r_end) {
							unsigned int pos;
							size_t newsize;

							pos = rp - record;
							newsize = r_end - record + BFRAG;
							record = DOALLOC(newsize);
							if (record == 0) {
								if (myfd)
									(void)close(fd);
								errno = ENOMEM;
								return (TC_SYS_ERR);
							}
							r_end = record + newsize;
							rp = record + pos;
						}
					}
					/* loop invariant lets us do this */
					*rp++ = '\0';

					/*
					 * If encountered eof check next file.
					 */
					if (eof)
						break;

					/*
					 * Toss blank lines and comments.
					 */
					if (*record == '\0' || *record == '#')
						continue;

					/*
					 * See if this is the record we want ...
					 */
					if (_nc_cgetmatch(record, name) == 0
					 && (nfield == 0
					  || !_nc_nfcmp(nfield, record))) {
						foundit = TRUE;
						*beginning = first;
						break;	/* found it! */
					}
d372 6
a378 18
			if (foundit)
				break;
		}

		if (!foundit)
			return (TC_NOT_FOUND);
	}

	/*
	 * Got the capability record, but now we have to expand all tc=name
	 * references in it ...
	 */
	{
		register char *newicap, *s;
		register int newilen;
		unsigned int ilen;
		int diff, iret, tclen, oline;
		char *icap, *scan, *tc, *tcstart, *tcend;
d380 4
a383 12
		/*
		 * Loop invariants:
		 *	There is room for one more character in record.
		 *	R_end points just past end of record.
		 *	Rp points just past last character in record.
		 *	Scan points at remainder of record that needs to be
		 *	scanned for tc=name constructs.
		 */
		scan = record;
		tc_not_resolved = FALSE;
		for (;;) {
			if ((tc = _nc_cgetcap(scan, "tc", '=')) == 0)
a384 50

			/*
			 * Find end of tc=name and stomp on the trailing `:'
			 * (if present) so we can use it to call ourselves.
			 */
			s = tc;
			while (*s != '\0') {
				if (*s++ == ':') {
					*(s - 1) = '\0';
					break;
				}
			}
			tcstart = tc - 3;
			tclen = s - tcstart;
			tcend = s;

			iret = _nc_getent(&icap, &ilen, &oline, current, db_array, fd, tc, depth+1, 0);
			newicap = icap;		/* Put into a register. */
			newilen = ilen;
			if (iret != TC_SUCCESS) {
				/* an error */
				if (iret < TC_NOT_FOUND) {
					if (myfd)
						(void)close(fd);
					free(record);
					return (iret);
				}
				if (iret == TC_UNRESOLVED)
					tc_not_resolved = TRUE;
				/* couldn't resolve tc */
				if (iret == TC_NOT_FOUND) {
					*(s - 1) = ':';
					scan = s - 1;
					tc_not_resolved = TRUE;
					continue;
				}
			}

			/* not interested in name field of tc'ed record */
			s = newicap;
			while (*s != '\0' && *s++ != ':')
				;
			newilen -= s - newicap;
			newicap = s;

			/* make sure interpolated record is `:'-terminated */
			s += newilen;
			if (*(s-1) != ':') {
				*s = ':';	/* overwrite NUL with : */
				newilen++;
d386 1
d389 3
a391 2
			 * Make sure there's enough room to insert the
			 * new record.
d393 15
a407 21
			diff = newilen - tclen;
			if (diff >= r_end - rp) {
				unsigned int pos, tcpos, tcposend;
				size_t newsize;

				pos = rp - record;
				newsize = r_end - record + diff + BFRAG;
				tcpos = tcstart - record;
				tcposend = tcend - record;
				record = DOALLOC(newsize);
				if (record == 0) {
					if (myfd)
						(void)close(fd);
					free(icap);
					errno = ENOMEM;
					return (TC_SYS_ERR);
				}
				r_end = record + newsize;
				rp = record + pos;
				tcstart = record + tcpos;
				tcend = record + tcposend;
d409 9
d419 5
a423 8
			/*
			 * Insert tc'ed record into our record.
			 */
			s = tcstart + newilen;
			memmove(s, tcend, (size_t)(rp - tcend));
			memmove(tcstart, newicap, (size_t)newilen);
			rp += diff;
			free(icap);
d425 14
a438 6
			/*
			 * Start scan on `:' so next cgetcap works properly
			 * (cgetcap always skips first field).
			 */
			scan = s-1;
		}
d441 15
d457 6
a462 2
	 * Close file (if we opened it), give back any extra memory, and
	 * return capability, length and success.
d464 112
a575 8
	if (myfd)
		(void)close(fd);
	*len = rp - record - 1; /* don't count NUL */
	if (r_end > rp) {
		if ((record = DOALLOC((size_t)(rp - record))) == 0) {
			errno = ENOMEM;
			return (TC_SYS_ERR);
		}
d577 1
d579 4
a582 4
	*cap = record;
	if (tc_not_resolved)
		return (TC_UNRESOLVED);
	return (current);
d592 2
a593 2
	register const char *np;
	register char *bp;
d595 5
d601 1
a601 1
	 * Start search at beginning of record.
d603 1
a603 1
	bp = buf;
d605 9
a613 14
		/*
		 * Try to match a record name.
		 */
		np = name;
		for (;;) {
			if (*np == '\0') {
				if (*bp == '|' || *bp == ':' || *bp == '\0')
					return (0);
				else
					break;
			} else if (*bp++ != *np++) {
				break;
			}
		}
d615 9
a623 10
		/*
		 * Match failed, skip to next name in record.
		 */
		bp--;	/* a '|' or ':' may have stopped the match */
		for (;;) {
			if (*bp == '\0' || *bp == ':')
				return (-1);	/* match failed totally */
			else if (*bp++ == '|')
				break;	/* found next name */
		}
d625 1
d634 2
a635 2
	char *cp, tmp;
	int ret;
d637 1
a637 2
	for (cp = rec; *cp != ':'; cp++)
		;
d639 4
a642 4
	tmp = *(cp + 1);
	*(cp + 1) = '\0';
	ret = strcmp(nf, rec);
	*(cp + 1) = tmp;
d644 1
a644 1
	return (ret);
d705 28
a732 29
	int ch;
	bool found = FALSE;
	char *s, *base;
	char *tok = 0;

	*endp = TRUE;
	for (s = base = *srcp; *s != '\0'; ) {
		ch = *s++;
		if (ch == '\\') {
			if (*s == '\0') {
				break;
			} else if (*s++ == '\n') {
				while (isspace(*s))
					s++;
			} else {
				found = TRUE;
			}
		} else if (ch == ':') {
			if (found) {
				tok = base;
				s[-1] = '\0';
				*srcp = s;
				*endp = FALSE;
				break;
			}
			base = s;
		} else if (isgraph(ch)) {
			found = TRUE;
		}
d734 1
d736 4
a739 4
	/* malformed entry may end without a ':' */
	if (tok == 0 && found) {
		tok = base;
	}
d741 1
a741 1
	return tok;
d747 1
a747 1
	int ch;
d749 9
a757 11
	while ((ch = *src++) != '\0') {
		if (ch == '\\' && *src == '\n') {
			while (isspace(*src))
				src++;
			continue;
		}
		if (--len == 0) {
			dst = 0;
			break;
		}
		*dst++ = ch;
d759 3
a761 1
	return dst;
d770 1
a770 18
	static char *the_source;

	register char *p;
	register char *cp;
	char  *dummy;
	char **fname;
	char  *home;
	int    i;
	char   pathbuf[PBUFSIZ];	/* holds raw path of filenames */
	char  *pathvec[PVECSIZ];	/* to point to names in pathbuf */
	char **pvec;			/* holds usable tail of path vector */
	char  *termpath;

	fname = pathvec;
	pvec = pathvec;
	tbuf = bp;
	p = pathbuf;
	cp = getenv("TERMCAP");
d772 26
a797 9
	/*
	 * TERMCAP can have one of two things in it.  It can be the name of a
	 * file to use instead of /etc/termcap.  In this case it better start
	 * with a "/".  Or it can be an entry to use so we don't have to read
	 * the file.  In this case it has to already have the newlines crunched
	 * out.  If TERMCAP does not hold a file name then a path of names is
	 * searched instead.  The path is found in the TERMPATH variable, or
	 * becomes "$HOME/.termcap /etc/termcap" if no TERMPATH exists.
	 */
d799 14
a812 15
	if (issetugid())
		strlcpy(pathbuf, MY_PATH_DEF, PBUFSIZ);
	else if (!is_pathname(cp)) {	/* no TERMCAP or it holds an entry */
		if ((termpath = getenv("TERMPATH")) != 0) {
			strlcpy(pathbuf, termpath, PBUFSIZ);
		} else {
			if ((home = getenv("HOME")) != 0 &&
			    strlen(home) < PBUFSIZ) { /* setup path */
				p += strlen(home);	/* path, looking in */
				strcpy(pathbuf, home);	/* $HOME first */
				*p++ = '/';
			}	/* if no $HOME look in current directory */
			strlcpy(p, ".termcap " MY_PATH_DEF,
			    (size_t)(PBUFSIZ - (p - pathbuf)));
		}
d814 2
a815 2
	else				/* user-defined name in TERMCAP */
		strlcpy(pathbuf, cp, PBUFSIZ); /* still can be tokenized */
d817 14
a830 15
	*fname++ = pathbuf;	/* tokenize path into vector of names */
	while (*++p) {
		if (*p == ' ' || *p == ':') {
			*p = '\0';
			while (*++p)
				if (*p != ' ' && *p != ':')
					break;
			if (*p == '\0')
				break;
			*fname++ = p;
			if (fname >= pathvec + PVECSIZ) {
				fname--;
				break;
			}
		}
d832 5
a836 5
	*fname = 0;			/* mark end of vector */
	if (is_pathname(cp)) {
		if (_nc_cgetset(cp) < 0) {
			return(TC_SYS_ERR);
		}
d838 1
d840 1
a840 1
	i = _nc_cgetent(&dummy, lineno, pathvec, name);
d842 33
a874 34
	/* ncurses' termcap-parsing routines cannot handle multiple adjacent
	 * empty fields, and mistakenly use the last valid cap entry instead of
	 * the first (breaks tc= includes)
	 */
	if (i >= 0) {
		char *pd, *ps, *tok;
		int endflag = FALSE;
		char *list[1023];
		size_t n, count = 0;

		pd = bp;
		ps = dummy;
		while (!endflag && (tok = get_tc_token(&ps, &endflag)) != 0) {
			bool ignore = FALSE;

			for (n = 1; n < count; n++) {
				char *s = list[n];
				if (s[0] == tok[0]
				 && s[1] == tok[1]) {
					ignore = TRUE;
					break;
				}
			}
			if (ignore != TRUE) {
				list[count++] = tok;
				pd = copy_tc_token(pd, tok, TBUFSIZ - (2+pd-bp));
				if (pd == 0) {
					i = -1;
					break;
				}
				*pd++ = ':';
				*pd = '\0';
			}
		}
d876 1
d878 12
a889 12
	FreeIfNeeded(dummy);
	FreeIfNeeded(the_source);
	the_source = 0;

	/* This is not related to the BSD cgetent(), but to fake up a suitable
	 * filename for ncurses' error reporting.  (If we are not using BSD
	 * cgetent, then it is the actual filename).
	 */
	if (i >= 0) {
		if ((the_source = strdup(pathvec[i])) != 0)
			*sourcename = the_source;
	}
d891 1
a891 1
	return(i);
d903 2
a904 1
static int add_tc(char *termpaths[], char *path, int count)
d906 5
a910 5
	if (count < MAXPATHS
	 && _nc_access(path, R_OK) == 0)
		termpaths[count++] = path;
	termpaths[count] = 0;
	return count;
d915 2
a916 1
int _nc_read_termcap_entry(const char *const tn, TERMTYPE *const tp)
d918 2
a919 2
	int found = FALSE;
	ENTRY	*ep;
d921 1
a921 1
	char	cwd_buf[PATH_MAX];
d924 11
a934 11
	char	tc[TBUFSIZ];
	static char	*source;
	static int lineno;

	/* we're using getcap(3) */
	if (_nc_tgetent(tc, &source, &lineno, tn) < 0)
		return (ERR);

	_nc_curr_line = lineno;
	_nc_set_source(source);
	_nc_read_entry_source((FILE *)0, tc, FALSE, FALSE, NULLHOOK);
d936 48
a983 58
	/*
	 * Here is what the 4.4BSD termcap(3) page prescribes:
	 *
	 * It will look in the environment for a TERMCAP variable.  If found,
	 * and the value does not begin with a slash, and the terminal type
	 * name is the same as the environment string TERM, the TERMCAP string
	 * is used instead of reading a termcap file.  If it does begin with a
	 * slash, the string is used as a path name of the termcap file to
	 * search.  If TERMCAP does not begin with a slash and name is
	 * different from TERM, tgetent() searches the files $HOME/.termcap and
	 * /usr/share/misc/termcap, in that order, unless the environment
	 * variable TERMPATH exists, in which case it specifies a list of file
	 * pathnames (separated by spaces or colons) to be searched instead.
	 *
	 * It goes on to state:
	 *
	 * Whenever multiple files are searched and a tc field occurs in the
	 * requested entry, the entry it names must be found in the same file
	 * or one of the succeeding files.
	 *
	 * However, this restriction is relaxed in ncurses; tc references to
	 * previous files are permitted.
	 *
	 * This routine returns 1 if an entry is found, 0 if not found, and -1
	 * if the database is not accessible.
	 */
	FILE	*fp;
	char	*tc, *termpaths[MAXPATHS];
	int	filecount = 0;
	bool	use_buffer = FALSE;
	char	tc_buf[1024];
	char	pathbuf[PATH_MAX];

	termpaths[filecount] = 0;
	if ((tc = getenv("TERMCAP")) != 0 && (!issetugid() || !is_pathname(tc)))
	{
		if (is_pathname(tc))	/* interpret as a filename */
		{
			ADD_TC(tc, 0);
		}
		else if (_nc_name_match(tc, tn, "|:")) /* treat as a capability file */
		{
			use_buffer = TRUE;
			(void) sprintf(tc_buf, "%.*s\n", (int)sizeof(tc_buf)-2, tc);
		}
		else if ((tc = getenv("TERMPATH")) != 0)
		{
			char    *cp;

			for (cp = tc; *cp; cp++)
			{
				if (*cp == ':')
					*cp = '\0';
				else if (cp == tc || cp[-1] == '\0')
				{
					ADD_TC(cp, filecount);
				}
			}
d985 1
d987 2
a988 3
	else	/* normal case */
	{
		char	envhome[PATH_MAX], *h;
d990 1
a990 1
		filecount = 0;
d992 8
a999 8
		/*
		 * Probably /etc/termcap is a symlink to /usr/share/misc/termcap.
		 * Avoid reading the same file twice.
		 */
		if (_nc_access("/etc/termcap", F_OK) == 0)
			ADD_TC("/etc/termcap", filecount);
		else
			ADD_TC("/usr/share/misc/termcap", filecount);
d1003 6
a1008 8
		if (!issetugid() && (h = getenv("HOME")) != NULL
		 && (strlen(h) + sizeof(PRIVATE_CAP)) < PATH_MAX)
		{
		    /* user's .termcap, if any, should override it */
		    (void) strcpy(envhome, h);
		    (void) sprintf(pathbuf, PRIVATE_CAP, envhome);
		    ADD_TC(pathbuf, filecount);
		}
d1010 5
d1016 13
a1028 4
	/* parse the sources */
	if (use_buffer)
	{
		_nc_set_source("TERMCAP");
d1031 3
a1033 2
		 * We don't suppress warning messages here.  The presumption is
		 * that since it's just a single entry, they won't be a pain.
d1035 1
a1035 18
		_nc_read_entry_source((FILE *)0, tc_buf, FALSE, FALSE, NULLHOOK);
	} else {
		int	i;

		for (i = 0; i < filecount; i++) {

			T(("Looking for %s in %s", tn, termpaths[i]));
			if ((fp = fopen(termpaths[i], "r")) != (FILE *)0)
			{
				_nc_set_source(termpaths[i]);

				/*
				 * Suppress warning messages.  Otherwise you
				 * get 400 lines of crap from archaic termcap
				 * files as ncurses complains about all the
				 * obsolete capabilities.
				 */
				_nc_read_entry_source(fp, (char*)0, FALSE, TRUE, NULLHOOK);
d1037 2
a1038 3
				(void) fclose(fp);
			}
		}
d1040 1
d1043 2
a1044 2
	if (_nc_head == 0)
		return(ERR);
d1046 2
a1047 2
	/* resolve all use references */
	_nc_resolve_uses();
d1049 1
a1049 1
	/* find a terminal matching tn, if we can */
d1051 2
a1052 3
	if (getcwd(cwd_buf, sizeof(cwd_buf)) != 0)
	{
		_nc_set_writedir((char *)0); /* note: this does a chdir */
d1054 23
a1076 28
		for_entry_list(ep) {
			if (_nc_name_match(ep->tterm.term_names, tn, "|:"))
			{
				/*
				 * Make a local copy of the terminal
				 * capabilities.  Free all entry storage except
				 * the string table for the loaded type (which
				 * we disconnected from the list by NULLing out
				 * ep->tterm.str_table above).
				 */
				*tp = ep->tterm;
				ep->tterm.str_table = (char *)0;

				/*
				 * OK, now try to write the type to user's
				 * terminfo directory.  Next time he loads
				 * this, it will come through terminfo.
				 *
				 * Advantage:  Second and subsequent fetches of
				 * this entry will be very fast.
				 *
				 * Disadvantage:  After the first time a
				 * termcap type is loaded by its user, editing
				 * it in the /etc/termcap file, or in TERMCAP,
				 * or in a local ~/.termcap, will be
				 * ineffective unless the terminfo entry is
				 * explicitly removed.
				 */
d1078 1
a1078 1
				(void) _nc_write_entry(tp);
d1080 4
a1083 4
				found = TRUE;
				break;
			}
		}
d1085 2
a1086 2
		chdir(cwd_buf);
	}
d1089 2
a1090 2
	_nc_free_entries(_nc_head);
	return(found);
d1093 6
a1098 3
extern	void _nc_read_termcap(void);
	void _nc_read_termcap(void) { }
#endif	/* PURE_TERMINFO */
@


1.2
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.1 1999/01/18 19:10:22 millert Exp $	*/
d65 1
a65 1
MODULE_ID("$From: read_termcap.c,v 1.41 1999/02/27 22:12:54 tom Exp $")
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: read_termcap.c,v 1.7 1998/11/19 17:22:23 millert Exp $	*/
a57 1
#include <term.h>
d65 1
a65 1
MODULE_ID("$From: read_termcap.c,v 1.37 1998/09/19 21:42:14 tom Exp $")
d161 1
a161 1
	if ((toprec = malloc (topreclen + 1)) == 0) {
d264 1
a264 1
#define DOALLOC(size) (char *)_nc_doalloc(record, size)
d894 2
a895 3
		the_source = malloc(strlen(pathvec[i]) + 1);
		if (the_source != 0)
			*sourcename = strcpy(the_source, pathvec[i]);
d1084 1
a1084 1
				memcpy(tp, &ep->tterm, sizeof(TERMTYPE));
@

