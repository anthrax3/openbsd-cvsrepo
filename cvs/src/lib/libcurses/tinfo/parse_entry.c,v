head	1.13;
access;
symbols
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.32
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.28
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.24
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.26
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.18
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.22
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.20
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.30
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.26
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.24
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.22
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.20
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.18
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.16
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.14
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.12
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.10
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.8
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.10.0.8
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.17.19.16.59;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.10.04.02.49;	author david;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.22.04.37.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.22.18.01.55;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.08.22.47.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.19.03.53.51;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.13.23.53.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.10.01.35.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.16.01.35.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.11.28.17.49.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.06.23.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.21;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 *	parse_entry.c -- compile one terminfo or termcap entry
 *
 *	Get an exact in-core representation of an entry.  Don't
 *	try to resolve use or tc capabilities, that is someone
 *	else's job.  Depends on the lexical analyzer to get tokens
 *	from the input stream.
 */

#define __INTERNAL_CAPS_VISIBLE
#include <curses.priv.h>

#include <ctype.h>
#include <tic.h>
#include <term_entry.h>

MODULE_ID("$Id: parse_entry.c,v 1.69 2008/08/16 21:52:03 tom Exp $")

#ifdef LINT
static short const parametrized[] =
{0};
#else
#include <parametrized.h>
#endif

static void postprocess_termcap(TERMTYPE *, bool);
static void postprocess_terminfo(TERMTYPE *);
static struct name_table_entry const *lookup_fullname(const char *name);

#if NCURSES_XNAMES

static struct name_table_entry const *
_nc_extend_names(ENTRY * entryp, char *name, int token_type)
{
    static struct name_table_entry temp;
    TERMTYPE *tp = &(entryp->tterm);
    unsigned offset = 0;
    unsigned actual;
    unsigned tindex;
    unsigned first, last, n;
    bool found;

    switch (token_type) {
    case BOOLEAN:
	first = 0;
	last = tp->ext_Booleans;
	offset = tp->ext_Booleans;
	tindex = tp->num_Booleans;
	break;
    case NUMBER:
	first = tp->ext_Booleans;
	last = tp->ext_Numbers + first;
	offset = tp->ext_Booleans + tp->ext_Numbers;
	tindex = tp->num_Numbers;
	break;
    case STRING:
	first = tp->ext_Booleans + tp->ext_Numbers;
	last = tp->ext_Strings + first;
	offset = tp->ext_Booleans + tp->ext_Numbers + tp->ext_Strings;
	tindex = tp->num_Strings;
	break;
    case CANCEL:
	actual = NUM_EXT_NAMES(tp);
	for (n = 0; n < actual; n++) {
	    if (!strcmp(name, tp->ext_Names[n])) {
		if (n > (unsigned) (tp->ext_Booleans + tp->ext_Numbers)) {
		    token_type = STRING;
		} else if (n > tp->ext_Booleans) {
		    token_type = NUMBER;
		} else {
		    token_type = BOOLEAN;
		}
		return _nc_extend_names(entryp, name, token_type);
	    }
	}
	/* Well, we are given a cancel for a name that we don't recognize */
	return _nc_extend_names(entryp, name, STRING);
    default:
	return 0;
    }

    /* Adjust the 'offset' (insertion-point) to keep the lists of extended
     * names sorted.
     */
    for (n = first, found = FALSE; n < last; n++) {
	int cmp = strcmp(tp->ext_Names[n], name);
	if (cmp == 0)
	    found = TRUE;
	if (cmp >= 0) {
	    offset = n;
	    tindex = n - first;
	    switch (token_type) {
	    case BOOLEAN:
		tindex += BOOLCOUNT;
		break;
	    case NUMBER:
		tindex += NUMCOUNT;
		break;
	    case STRING:
		tindex += STRCOUNT;
		break;
	    }
	    break;
	}
    }
    if (!found) {
	switch (token_type) {
	case BOOLEAN:
	    tp->ext_Booleans += 1;
	    tp->num_Booleans += 1;
	    tp->Booleans = typeRealloc(NCURSES_SBOOL, tp->num_Booleans, tp->Booleans);
	    for (last = tp->num_Booleans - 1; last > tindex; last--)
		tp->Booleans[last] = tp->Booleans[last - 1];
	    break;
	case NUMBER:
	    tp->ext_Numbers += 1;
	    tp->num_Numbers += 1;
	    tp->Numbers = typeRealloc(short, tp->num_Numbers, tp->Numbers);
	    for (last = tp->num_Numbers - 1; last > tindex; last--)
		tp->Numbers[last] = tp->Numbers[last - 1];
	    break;
	case STRING:
	    tp->ext_Strings += 1;
	    tp->num_Strings += 1;
	    tp->Strings = typeRealloc(char *, tp->num_Strings, tp->Strings);
	    for (last = tp->num_Strings - 1; last > tindex; last--)
		tp->Strings[last] = tp->Strings[last - 1];
	    break;
	}
	actual = NUM_EXT_NAMES(tp);
	tp->ext_Names = typeRealloc(char *, actual, tp->ext_Names);
	while (--actual > offset)
	    tp->ext_Names[actual] = tp->ext_Names[actual - 1];
	tp->ext_Names[offset] = _nc_save_str(name);
    }

    temp.nte_name = tp->ext_Names[offset];
    temp.nte_type = token_type;
    temp.nte_index = tindex;
    temp.nte_link = -1;

    return &temp;
}
#endif /* NCURSES_XNAMES */

/*
 *	int
 *	_nc_parse_entry(entry, literal, silent)
 *
 *	Compile one entry.  Doesn't try to resolve use or tc capabilities.
 *
 *	found-forward-use = FALSE
 *	re-initialise internal arrays
 *	get_token();
 *	if the token was not a name in column 1, complain and die
 *	save names in entry's string table
 *	while (get_token() is not EOF and not NAMES)
 *	        check for existence and type-correctness
 *	        enter cap into structure
 *	        if STRING
 *	            save string in entry's string table
 *	push back token
 */

#define BAD_TC_USAGE if (!bad_tc_usage) \
 	{ bad_tc_usage = TRUE; \
	 _nc_warning("Legacy termcap allows only a trailing tc= clause"); }

NCURSES_EXPORT(int)
_nc_parse_entry(struct entry *entryp, int literal, bool silent)
{
    int token_type;
    struct name_table_entry const *entry_ptr;
    char *ptr, *base;
    bool bad_tc_usage = FALSE;

    token_type = _nc_get_token(silent);

    if (token_type == EOF)
	return (EOF);
    if (token_type != NAMES)
	_nc_err_abort("Entry does not start with terminal names in column one");

    _nc_init_entry(&entryp->tterm);

    entryp->cstart = _nc_comment_start;
    entryp->cend = _nc_comment_end;
    entryp->startline = _nc_start_line;
    DEBUG(2, ("Comment range is %ld to %ld", entryp->cstart, entryp->cend));

    /*
     * Strip off the 2-character termcap name, if present.  Originally termcap
     * used that as an indexing aid.  We can retain 2-character terminfo names,
     * but note that they would be lost if we translate to/from termcap.  This
     * feature is supposedly obsolete since "newer" BSD implementations do not
     * use it; however our reference for this feature is SunOS 4.x, which
     * implemented it.  Note that the resulting terminal type was never the
     * 2-character name, but was instead the first alias after that.
     */
    ptr = _nc_curr_token.tk_name;
    if (_nc_syntax == SYN_TERMCAP
#if NCURSES_XNAMES
	&& !_nc_user_definable
#endif
	) {
	if (ptr[2] == '|') {
	    ptr += 3;
	    _nc_curr_token.tk_name[2] = '\0';
	}
    }

    entryp->tterm.str_table = entryp->tterm.term_names = _nc_save_str(ptr);

    if (entryp->tterm.str_table == 0)
	return (ERR);

    DEBUG(1, ("Starting '%s'", ptr));

    /*
     * We do this because the one-token lookahead in the parse loop
     * results in the terminal type getting prematurely set to correspond
     * to that of the next entry.
     */
    _nc_set_type(_nc_first_name(entryp->tterm.term_names));

    /* check for overly-long names and aliases */
    for (base = entryp->tterm.term_names; (ptr = strchr(base, '|')) != 0;
	 base = ptr + 1) {
	if (ptr - base > MAX_ALIAS) {
	    _nc_warning("%s `%.*s' may be too long",
			(base == entryp->tterm.term_names)
			? "primary name"
			: "alias",
			(int) (ptr - base), base);
	}
    }

    entryp->nuses = 0;

    for (token_type = _nc_get_token(silent);
	 token_type != EOF && token_type != NAMES;
	 token_type = _nc_get_token(silent)) {
	bool is_use = (strcmp(_nc_curr_token.tk_name, "use") == 0);
	bool is_tc = !is_use && (strcmp(_nc_curr_token.tk_name, "tc") == 0);
	if (is_use || is_tc) {
	    entryp->uses[entryp->nuses].name = _nc_save_str(_nc_curr_token.tk_valstring);
	    entryp->uses[entryp->nuses].line = _nc_curr_line;
	    entryp->nuses++;
	    if (entryp->nuses > 1 && is_tc) {
		BAD_TC_USAGE
	    }
	} else {
	    /* normal token lookup */
	    entry_ptr = _nc_find_entry(_nc_curr_token.tk_name,
				       _nc_get_hash_table(_nc_syntax));

	    /*
	     * Our kluge to handle aliasing.  The reason it's done
	     * this ugly way, with a linear search, is so the hashing
	     * machinery doesn't have to be made really complicated
	     * (also we get better warnings this way).  No point in
	     * making this case fast, aliased caps aren't common now
	     * and will get rarer.
	     */
	    if (entry_ptr == NOTFOUND) {
		const struct alias *ap;

		if (_nc_syntax == SYN_TERMCAP) {
		    if (entryp->nuses != 0) {
			BAD_TC_USAGE
		    }
		    for (ap = _nc_get_alias_table(TRUE); ap->from; ap++)
			if (strcmp(ap->from, _nc_curr_token.tk_name) == 0) {
			    if (ap->to == (char *) 0) {
				_nc_warning("%s (%s termcap extension) ignored",
					    ap->from, ap->source);
				goto nexttok;
			    }

			    entry_ptr = _nc_find_entry(ap->to,
						       _nc_get_hash_table(TRUE));
			    if (entry_ptr && !silent)
				_nc_warning("%s (%s termcap extension) aliased to %s",
					    ap->from, ap->source, ap->to);
			    break;
			}
		} else {	/* if (_nc_syntax == SYN_TERMINFO) */
		    for (ap = _nc_get_alias_table(FALSE); ap->from; ap++)
			if (strcmp(ap->from, _nc_curr_token.tk_name) == 0) {
			    if (ap->to == (char *) 0) {
				_nc_warning("%s (%s terminfo extension) ignored",
					    ap->from, ap->source);
				goto nexttok;
			    }

			    entry_ptr = _nc_find_entry(ap->to,
						       _nc_get_hash_table(FALSE));
			    if (entry_ptr && !silent)
				_nc_warning("%s (%s terminfo extension) aliased to %s",
					    ap->from, ap->source, ap->to);
			    break;
			}

		    if (entry_ptr == NOTFOUND) {
			entry_ptr = lookup_fullname(_nc_curr_token.tk_name);
		    }
		}
	    }
#if NCURSES_XNAMES
	    /*
	     * If we have extended-names active, we will automatically
	     * define a name based on its context.
	     */
	    if (entry_ptr == NOTFOUND
		&& _nc_user_definable
		&& (entry_ptr = _nc_extend_names(entryp,
						 _nc_curr_token.tk_name,
						 token_type)) != 0) {
		if (_nc_tracing >= DEBUG_LEVEL(1))
		    _nc_warning("extended capability '%s'", _nc_curr_token.tk_name);
	    }
#endif /* NCURSES_XNAMES */

	    /* can't find this cap name, not even as an alias */
	    if (entry_ptr == NOTFOUND) {
		if (!silent)
		    _nc_warning("unknown capability '%s'",
				_nc_curr_token.tk_name);
		continue;
	    }

	    /* deal with bad type/value combinations. */
	    if (token_type != CANCEL && entry_ptr->nte_type != token_type) {
		/*
		 * Nasty special cases here handle situations in which type
		 * information can resolve name clashes.  Normal lookup
		 * finds the last instance in the capability table of a
		 * given name, regardless of type.  find_type_entry looks
		 * for a first matching instance with given type.  So as
		 * long as all ambiguous names occur in pairs of distinct
		 * type, this will do the job.
		 */

		if (token_type == NUMBER
		    && !strcmp("ma", _nc_curr_token.tk_name)) {
		    /* tell max_attributes from arrow_key_map */
		    entry_ptr = _nc_find_type_entry("ma", NUMBER,
						    _nc_get_table(_nc_syntax
								  != 0));
		    assert(entry_ptr != 0);

		} else if (token_type == STRING
			   && !strcmp("MT", _nc_curr_token.tk_name)) {
		    /* map terminfo's string MT to MT */
		    entry_ptr = _nc_find_type_entry("MT", STRING,
						    _nc_get_table(_nc_syntax
								  != 0));
		    assert(entry_ptr != 0);

		} else if (token_type == BOOLEAN
			   && entry_ptr->nte_type == STRING) {
		    /* treat strings without following "=" as empty strings */
		    token_type = STRING;
		} else {
		    /* we couldn't recover; skip this token */
		    if (!silent) {
			const char *type_name;
			switch (entry_ptr->nte_type) {
			case BOOLEAN:
			    type_name = "boolean";
			    break;
			case STRING:
			    type_name = "string";
			    break;
			case NUMBER:
			    type_name = "numeric";
			    break;
			default:
			    type_name = "unknown";
			    break;
			}
			_nc_warning("wrong type used for %s capability '%s'",
				    type_name, _nc_curr_token.tk_name);
		    }
		    continue;
		}
	    }

	    /* now we know that the type/value combination is OK */
	    switch (token_type) {
	    case CANCEL:
		switch (entry_ptr->nte_type) {
		case BOOLEAN:
		    entryp->tterm.Booleans[entry_ptr->nte_index] = CANCELLED_BOOLEAN;
		    break;

		case NUMBER:
		    entryp->tterm.Numbers[entry_ptr->nte_index] = CANCELLED_NUMERIC;
		    break;

		case STRING:
		    entryp->tterm.Strings[entry_ptr->nte_index] = CANCELLED_STRING;
		    break;
		}
		break;

	    case BOOLEAN:
		entryp->tterm.Booleans[entry_ptr->nte_index] = TRUE;
		break;

	    case NUMBER:
		entryp->tterm.Numbers[entry_ptr->nte_index] =
		    _nc_curr_token.tk_valnumber;
		break;

	    case STRING:
		ptr = _nc_curr_token.tk_valstring;
		if (_nc_syntax == SYN_TERMCAP)
		    ptr = _nc_captoinfo(_nc_curr_token.tk_name,
					ptr,
					parametrized[entry_ptr->nte_index]);
		entryp->tterm.Strings[entry_ptr->nte_index] = _nc_save_str(ptr);
		break;

	    default:
		if (!silent)
		    _nc_warning("unknown token type");
		_nc_panic_mode((char) ((_nc_syntax == SYN_TERMCAP) ? ':' : ','));
		continue;
	    }
	}			/* end else cur_token.name != "use" */
      nexttok:
	continue;		/* cannot have a label w/o statement */
    }				/* endwhile (not EOF and not NAMES) */

    _nc_push_token(token_type);
    _nc_set_type(_nc_first_name(entryp->tterm.term_names));

    /*
     * Try to deduce as much as possible from extension capabilities
     * (this includes obsolete BSD capabilities).  Sigh...it would be more
     * space-efficient to call this after use resolution, but it has
     * to be done before entry allocation is wrapped up.
     */
    if (!literal) {
	if (_nc_syntax == SYN_TERMCAP) {
	    bool has_base_entry = FALSE;
	    unsigned i;

	    /*
	     * Don't insert defaults if this is a `+' entry meant only
	     * for inclusion in other entries (not sure termcap ever
	     * had these, actually).
	     */
	    if (strchr(entryp->tterm.term_names, '+'))
		has_base_entry = TRUE;
	    else
		/*
		 * Otherwise, look for a base entry that will already
		 * have picked up defaults via translation.
		 */
		for (i = 0; i < entryp->nuses; i++)
		    if (!strchr((char *) entryp->uses[i].name, '+'))
			has_base_entry = TRUE;

	    postprocess_termcap(&entryp->tterm, has_base_entry);
	} else
	    postprocess_terminfo(&entryp->tterm);
    }
    _nc_wrap_entry(entryp, FALSE);

    return (OK);
}

NCURSES_EXPORT(int)
_nc_capcmp(const char *s, const char *t)
/* compare two string capabilities, stripping out padding */
{
    if (!s && !t)
	return (0);
    else if (!s || !t)
	return (1);

    for (;;) {
	if (s[0] == '$' && s[1] == '<') {
	    for (s += 2;; s++)
		if (!(isdigit(UChar(*s))
		      || *s == '.'
		      || *s == '*'
		      || *s == '/'
		      || *s == '>'))
		    break;
	}

	if (t[0] == '$' && t[1] == '<') {
	    for (t += 2;; t++)
		if (!(isdigit(UChar(*t))
		      || *t == '.'
		      || *t == '*'
		      || *t == '/'
		      || *t == '>'))
		    break;
	}

	/* we've now pushed s and t past any padding they were pointing at */

	if (*s == '\0' && *t == '\0')
	    return (0);

	if (*s != *t)
	    return (*t - *s);

	/* else *s == *t but one is not NUL, so continue */
	s++, t++;
    }
}

static void
append_acs0(string_desc * dst, int code, int src)
{
    if (src != 0) {
	char temp[3];
	temp[0] = (char) code;
	temp[1] = (char) src;
	temp[2] = 0;
	_nc_safe_strcat(dst, temp);
    }
}

static void
append_acs(string_desc * dst, int code, char *src)
{
    if (src != 0 && strlen(src) == 1) {
	append_acs0(dst, code, *src);
    }
}

/*
 * The ko capability, if present, consists of a comma-separated capability
 * list.  For each capability, we may assume there is a keycap that sends the
 * string which is the value of that capability.
 */
typedef struct {
    const char *from;
    const char *to;
} assoc;
static assoc const ko_xlate[] =
{
    {"al", "kil1"},		/* insert line key  -> KEY_IL    */
    {"bt", "kcbt"},		/* back tab         -> KEY_BTAB  */
    {"cd", "ked"},		/* clear-to-eos key -> KEY_EOL   */
    {"ce", "kel"},		/* clear-to-eol key -> KEY_EOS   */
    {"cl", "kclr"},		/* clear key        -> KEY_CLEAR */
    {"ct", "tbc"},		/* clear all tabs   -> KEY_CATAB */
    {"dc", "kdch1"},		/* delete char      -> KEY_DC    */
    {"dl", "kdl1"},		/* delete line      -> KEY_DL    */
    {"do", "kcud1"},		/* down key         -> KEY_DOWN  */
    {"ei", "krmir"},		/* exit insert key  -> KEY_EIC   */
    {"ho", "khome"},		/* home key         -> KEY_HOME  */
    {"ic", "kich1"},		/* insert char key  -> KEY_IC    */
    {"im", "kIC"},		/* insert-mode key  -> KEY_SIC   */
    {"le", "kcub1"},		/* le key           -> KEY_LEFT  */
    {"nd", "kcuf1"},		/* nd key           -> KEY_RIGHT */
    {"nl", "kent"},		/* new line key     -> KEY_ENTER */
    {"st", "khts"},		/* set-tab key      -> KEY_STAB  */
    {"ta", CANCELLED_STRING},
    {"up", "kcuu1"},		/* up-arrow key     -> KEY_UP    */
    {(char *) 0, (char *) 0},
};

/*
 * This routine fills in string caps that either had defaults under
 * termcap or can be manufactured from obsolete termcap capabilities.
 * It was lifted from Ross Ridge's mytinfo package.
 */

static const char C_CR[] = "\r";
static const char C_LF[] = "\n";
static const char C_BS[] = "\b";
static const char C_HT[] = "\t";

/*
 * Note that WANTED and PRESENT are not simple inverses!  If a capability
 * has been explicitly cancelled, it's not considered WANTED.
 */
#define WANTED(s)	((s) == ABSENT_STRING)
#define PRESENT(s)	(((s) != ABSENT_STRING) && ((s) != CANCELLED_STRING))

/*
 * This bit of legerdemain turns all the terminfo variable names into
 * references to locations in the arrays Booleans, Numbers, and Strings ---
 * precisely what's needed.
 */

#undef CUR
#define CUR tp->

static void
postprocess_termcap(TERMTYPE *tp, bool has_base)
{
    char buf[MAX_LINE * 2 + 2];
    string_desc result;

    /*
     * TERMCAP DEFAULTS AND OBSOLETE-CAPABILITY TRANSLATIONS
     *
     * This first part of the code is the functional inverse of the
     * fragment in capdefaults.c.
     * ----------------------------------------------------------------------
     */

    /* if there was a tc entry, assume we picked up defaults via that */
    if (!has_base) {
	if (WANTED(init_3string) && termcap_init2)
	    init_3string = _nc_save_str(termcap_init2);

	if (WANTED(reset_2string) && termcap_reset)
	    reset_2string = _nc_save_str(termcap_reset);

	if (WANTED(carriage_return)) {
	    if (carriage_return_delay > 0) {
	        snprintf(buf, sizeof(buf), "%s$<%d>", C_CR, carriage_return_delay);
		carriage_return = _nc_save_str(buf);
	    } else
		carriage_return = _nc_save_str(C_CR);
	}
	if (WANTED(cursor_left)) {
	    if (backspace_delay > 0) {
		snprintf(buf, sizeof(buf), "%s$<%d>", C_BS, backspace_delay);
		cursor_left = _nc_save_str(buf);
	    } else if (backspaces_with_bs == 1)
		cursor_left = _nc_save_str(C_BS);
	    else if (PRESENT(backspace_if_not_bs))
		cursor_left = backspace_if_not_bs;
	}
	/* vi doesn't use "do", but it does seems to use nl (or '\n') instead */
	if (WANTED(cursor_down)) {
	    if (PRESENT(linefeed_if_not_lf))
		cursor_down = linefeed_if_not_lf;
	    else if (linefeed_is_newline != 1) {
		if (new_line_delay > 0) {
		    snprintf(buf, sizeof(buf), "%s$<%d>", C_LF, new_line_delay);
		    cursor_down = _nc_save_str(buf);
		} else
		    cursor_down = _nc_save_str(C_LF);
	    }
	}
	if (WANTED(scroll_forward) && crt_no_scrolling != 1) {
	    if (PRESENT(linefeed_if_not_lf))
		cursor_down = linefeed_if_not_lf;
	    else if (linefeed_is_newline != 1) {
		if (new_line_delay > 0) {
		    snprintf(buf, sizeof(buf), "%s$<%d>", C_LF, new_line_delay);
		    scroll_forward = _nc_save_str(buf);
		} else
		    scroll_forward = _nc_save_str(C_LF);
	    }
	}
	if (WANTED(newline)) {
	    if (linefeed_is_newline == 1) {
		if (new_line_delay > 0) {
		    snprintf(buf, sizeof(buf), "%s$<%d>", C_LF, new_line_delay);
		    newline = _nc_save_str(buf);
		} else
		    newline = _nc_save_str(C_LF);
	    } else if (PRESENT(carriage_return) && PRESENT(scroll_forward)) {
		_nc_str_init(&result, buf, sizeof(buf));
		if (_nc_safe_strcat(&result, carriage_return)
		    && _nc_safe_strcat(&result, scroll_forward))
		    newline = _nc_save_str(buf);
	    } else if (PRESENT(carriage_return) && PRESENT(cursor_down)) {
		_nc_str_init(&result, buf, sizeof(buf));
		if (_nc_safe_strcat(&result, carriage_return)
		    && _nc_safe_strcat(&result, cursor_down))
		    newline = _nc_save_str(buf);
	    }
	}
    }

    /*
     * Inverse of capdefaults.c code ends here.
     * ----------------------------------------------------------------------
     *
     * TERMCAP-TO TERMINFO MAPPINGS FOR SOURCE TRANSLATION
     *
     * These translations will *not* be inverted by tgetent().
     */

    if (!has_base) {
	/*
	 * We wait until now to decide if we've got a working cr because even
	 * one that doesn't work can be used for newline. Unfortunately the
	 * space allocated for it is wasted.
	 */
	if (return_does_clr_eol == 1 || no_correctly_working_cr == 1)
	    carriage_return = ABSENT_STRING;

	/*
	 * Supposedly most termcap entries have ta now and '\t' is no longer a
	 * default, but it doesn't seem to be true...
	 */
	if (WANTED(tab)) {
	    if (horizontal_tab_delay > 0) {
		snprintf(buf, sizeof(buf), "%s$<%d>", C_HT, horizontal_tab_delay);
		tab = _nc_save_str(buf);
	    } else
		tab = _nc_save_str(C_HT);
	}
	if (init_tabs == ABSENT_NUMERIC && has_hardware_tabs == TRUE)
	    init_tabs = 8;

	/*
	 * Assume we can beep with ^G unless we're given bl@@.
	 */
	if (WANTED(bell))
	    bell = _nc_save_str("\007");
    }

    /*
     * Translate the old termcap :pt: capability to it#8 + ht=\t
     */
    if (has_hardware_tabs == TRUE) {
	if (init_tabs != 8 && init_tabs != ABSENT_NUMERIC)
	    _nc_warning("hardware tabs with a width other than 8: %d", init_tabs);
	else {
	    if (tab && _nc_capcmp(tab, C_HT))
		_nc_warning("hardware tabs with a non-^I tab string %s",
			    _nc_visbuf(tab));
	    else {
		if (WANTED(tab))
		    tab = _nc_save_str(C_HT);
		init_tabs = 8;
	    }
	}
    }
    /*
     * Now translate the ko capability, if there is one.  This
     * isn't from mytinfo...
     */
    if (PRESENT(other_non_function_keys)) {
	char *base = other_non_function_keys;
	char *bp, *cp, *dp;
	struct name_table_entry const *from_ptr;
	struct name_table_entry const *to_ptr;
	assoc const *ap;
	char buf2[MAX_TERMINFO_LENGTH];
	bool foundim;

	/* we're going to use this for a special case later */
	dp = strchr(other_non_function_keys, 'i');
	foundim = (dp != 0) && (dp[1] == 'm');

	/* look at each comma-separated capability in the ko string... */
	for (base = other_non_function_keys;
	     (cp = strchr(base, ',')) != 0;
	     base = cp + 1) {
	    size_t len = cp - base;

	    for (ap = ko_xlate; ap->from; ap++) {
		if (len == strlen(ap->from)
		    && strncmp(ap->from, base, len) == 0)
		    break;
	    }
	    if (!(ap->from && ap->to)) {
		_nc_warning("unknown capability `%.*s' in ko string",
			    (int) len, base);
		continue;
	    } else if (ap->to == CANCELLED_STRING)	/* ignore it */
		continue;

	    /* now we know we found a match in ko_table, so... */

	    from_ptr = _nc_find_entry(ap->from, _nc_get_hash_table(TRUE));
	    to_ptr = _nc_find_entry(ap->to, _nc_get_hash_table(FALSE));

	    if (!from_ptr || !to_ptr)	/* should never happen! */
		_nc_err_abort("ko translation table is invalid, I give up");

	    if (WANTED(tp->Strings[from_ptr->nte_index])) {
		_nc_warning("no value for ko capability %s", ap->from);
		continue;
	    }

	    if (tp->Strings[to_ptr->nte_index]) {
		/* There's no point in warning about it if it's the same
		 * string; that's just an inefficiency.
		 */
		if (strcmp(
			      tp->Strings[from_ptr->nte_index],
			      tp->Strings[to_ptr->nte_index]) != 0)
		    _nc_warning("%s (%s) already has an explicit value %s, ignoring ko",
				ap->to, ap->from,
				_nc_visbuf(tp->Strings[to_ptr->nte_index]));
		continue;
	    }

	    /*
	     * The magic moment -- copy the mapped key string over,
	     * stripping out padding.
	     */
	    for (dp = buf2, bp = tp->Strings[from_ptr->nte_index]; *bp; bp++) {
		if (bp[0] == '$' && bp[1] == '<') {
		    while (*bp && *bp != '>') {
			++bp;
		    }
		} else
		    *dp++ = *bp;
	    }
	    *dp++ = '\0';

	    tp->Strings[to_ptr->nte_index] = _nc_save_str(buf2);
	}

	/*
	 * Note: ko=im and ko=ic both want to grab the `Insert'
	 * keycap.  There's a kich1 but no ksmir, so the ic capability
	 * got mapped to kich1 and im to kIC to avoid a collision.
	 * If the description has im but not ic, hack kIC back to kich1.
	 */
	if (foundim && WANTED(key_ic) && key_sic) {
	    key_ic = key_sic;
	    key_sic = ABSENT_STRING;
	}
    }

    if (!has_base) {
	if (!hard_copy) {
	    if (WANTED(key_backspace))
		key_backspace = _nc_save_str(C_BS);
	    if (WANTED(key_left))
		key_left = _nc_save_str(C_BS);
	    if (WANTED(key_down))
		key_down = _nc_save_str(C_LF);
	}
    }

    /*
     * Translate XENIX forms characters.
     */
    if (PRESENT(acs_ulcorner) ||
	PRESENT(acs_llcorner) ||
	PRESENT(acs_urcorner) ||
	PRESENT(acs_lrcorner) ||
	PRESENT(acs_ltee) ||
	PRESENT(acs_rtee) ||
	PRESENT(acs_btee) ||
	PRESENT(acs_ttee) ||
	PRESENT(acs_hline) ||
	PRESENT(acs_vline) ||
	PRESENT(acs_plus)) {
	char buf2[MAX_TERMCAP_LENGTH];

	_nc_str_init(&result, buf2, sizeof(buf2));
	_nc_safe_strcat(&result, acs_chars);

	append_acs(&result, 'j', acs_lrcorner);
	append_acs(&result, 'k', acs_urcorner);
	append_acs(&result, 'l', acs_ulcorner);
	append_acs(&result, 'm', acs_llcorner);
	append_acs(&result, 'n', acs_plus);
	append_acs(&result, 'q', acs_hline);
	append_acs(&result, 't', acs_ltee);
	append_acs(&result, 'u', acs_rtee);
	append_acs(&result, 'v', acs_btee);
	append_acs(&result, 'w', acs_ttee);
	append_acs(&result, 'x', acs_vline);

	if (buf2[0]) {
	    acs_chars = _nc_save_str(buf2);
	    _nc_warning("acsc string synthesized from XENIX capabilities");
	}
    } else if (acs_chars == 0
	       && enter_alt_charset_mode != 0
	       && exit_alt_charset_mode != 0) {
	acs_chars = _nc_save_str(VT_ACSC);
    }
}

static void
postprocess_terminfo(TERMTYPE *tp)
{
    /*
     * TERMINFO-TO-TERMINFO MAPPINGS FOR SOURCE TRANSLATION
     * ----------------------------------------------------------------------
     */

    /*
     * Translate AIX forms characters.
     */
    if (PRESENT(box_chars_1)) {
	char buf2[MAX_TERMCAP_LENGTH];
	string_desc result;

	_nc_str_init(&result, buf2, sizeof(buf2));
	_nc_safe_strcat(&result, acs_chars);

	append_acs0(&result, 'l', box_chars_1[0]);	/* ACS_ULCORNER */
	append_acs0(&result, 'q', box_chars_1[1]);	/* ACS_HLINE */
	append_acs0(&result, 'k', box_chars_1[2]);	/* ACS_URCORNER */
	append_acs0(&result, 'x', box_chars_1[3]);	/* ACS_VLINE */
	append_acs0(&result, 'j', box_chars_1[4]);	/* ACS_LRCORNER */
	append_acs0(&result, 'm', box_chars_1[5]);	/* ACS_LLCORNER */
	append_acs0(&result, 'w', box_chars_1[6]);	/* ACS_TTEE */
	append_acs0(&result, 'u', box_chars_1[7]);	/* ACS_RTEE */
	append_acs0(&result, 'v', box_chars_1[8]);	/* ACS_BTEE */
	append_acs0(&result, 't', box_chars_1[9]);	/* ACS_LTEE */
	append_acs0(&result, 'n', box_chars_1[10]);	/* ACS_PLUS */

	if (buf2[0]) {
	    acs_chars = _nc_save_str(buf2);
	    _nc_warning("acsc string synthesized from AIX capabilities");
	    box_chars_1 = ABSENT_STRING;
	}
    }
    /*
     * ----------------------------------------------------------------------
     */
}

/*
 * Do a linear search through the terminfo tables to find a given full-name.
 * We don't expect to do this often, so there's no hashing function.
 *
 * In effect, this scans through the 3 lists of full-names, and looks them
 * up in _nc_info_table, which is organized so that the nte_index fields are
 * sorted, but the nte_type fields are not necessarily grouped together.
 */
static struct name_table_entry const *
lookup_fullname(const char *find)
{
    int state = -1;

    for (;;) {
	int count = 0;
	NCURSES_CONST char *const *names;

	switch (++state) {
	case BOOLEAN:
	    names = boolfnames;
	    break;
	case STRING:
	    names = strfnames;
	    break;
	case NUMBER:
	    names = numfnames;
	    break;
	default:
	    return NOTFOUND;
	}

	for (count = 0; names[count] != 0; count++) {
	    if (!strcmp(names[count], find)) {
		struct name_table_entry const *entry_ptr = _nc_get_table(FALSE);
		while (entry_ptr->nte_type != state
		       || entry_ptr->nte_index != count)
		    entry_ptr++;
		return entry_ptr;
	    }
	}
    }
}

/* parse_entry.c ends here */
@


1.12
log
@use snprintf throughout
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.11 2003/03/10 04:02:49 david Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d46 1
a50 1
#define __INTERNAL_CAPS_VISIBLE
d53 1
a53 1
MODULE_ID("$From: parse_entry.c,v 1.52 2001/01/13 22:44:29 tom Exp $")
d147 1
a147 1
	    tp->Booleans = typeRealloc(char, tp->num_Booleans, tp->Booleans);
d201 4
d206 1
a206 2
_nc_parse_entry
(struct entry *entryp, int literal, bool silent)
d211 1
d227 9
a235 1
    /* junk the 2-character termcap name, if present */
d237 9
a245 3
    if (ptr[2] == '|') {
	ptr = _nc_curr_token.tk_name + 3;
	_nc_curr_token.tk_name[2] = '\0';
d250 3
d270 1
a270 1
			ptr - base, base);
d279 3
a281 2
	if (strcmp(_nc_curr_token.tk_name, "use") == 0
	    || strcmp(_nc_curr_token.tk_name, "tc") == 0) {
d285 3
d291 1
a291 1
				       _nc_syntax ? _nc_cap_hash_table : _nc_info_hash_table);
d305 4
a308 1
		    for (ap = _nc_capalias_table; ap->from; ap++)
d316 2
a317 1
			    entry_ptr = _nc_find_entry(ap->to, _nc_cap_hash_table);
d324 1
a324 1
		    for (ap = _nc_infoalias_table; ap->from; ap++)
d332 2
a333 1
			    entry_ptr = _nc_find_entry(ap->to, _nc_info_hash_table);
d380 3
a382 2
		/* tell max_attributes from arrow_key_map */
		if (token_type == NUMBER && !strcmp("ma", _nc_curr_token.tk_name))
d386 1
d388 3
a390 2
		/* map terminfo's string MT to MT */
		else if (token_type == STRING && !strcmp("MT", _nc_curr_token.tk_name))
d394 1
d396 3
a398 2
		/* treat strings without following "=" as empty strings */
		else if (token_type == BOOLEAN && entry_ptr->nte_type == STRING)
d400 2
a401 2
		/* we couldn't recover; skip this token */
		else {
d464 1
a464 1
		_nc_panic_mode((_nc_syntax == SYN_TERMCAP) ? ':' : ',');
d484 1
a484 1
	    int i;
d523 1
a523 1
		if (!(isdigit(CharOf(*s))
d533 1
a533 1
		if (!(isdigit(CharOf(*t))
d559 2
a560 2
	temp[0] = code;
	temp[1] = src;
d635 1
a635 1
postprocess_termcap(TERMTYPE * tp, bool has_base)
d658 1
a658 1
		snprintf(buf, sizeof(buf), "%s$<%d>", C_CR, carriage_return_delay);
d795 1
a795 1
	    for (ap = ko_xlate; ap->from; ap++)
d799 2
a800 1
	    if (!ap->to) {
d809 2
a810 2
	    from_ptr = _nc_find_entry(ap->from, _nc_cap_hash_table);
	    to_ptr = _nc_find_entry(ap->to, _nc_info_hash_table);
d911 1
a911 2
	acs_chars =
	    _nc_save_str("``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~");
d916 1
a916 1
postprocess_terminfo(TERMTYPE * tp)
@


1.11
log
@duplicate words and spelling fixes in comments
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.10 2001/02/22 04:37:56 millert Exp $	*/
d622 1
a622 1
		sprintf(buf, "%s$<%d>", C_CR, carriage_return_delay);
d629 1
a629 1
		sprintf(buf, "%s$<%d>", C_BS, backspace_delay);
d642 1
a642 1
		    sprintf(buf, "%s$<%d>", C_LF, new_line_delay);
d653 1
a653 1
		    sprintf(buf, "%s$<%d>", C_LF, new_line_delay);
d662 1
a662 1
		    sprintf(buf, "%s$<%d>", C_LF, new_line_delay);
d704 1
a704 1
		sprintf(buf, "%s$<%d>", C_HT, horizontal_tab_delay);
@


1.10
log
@Make _nc_get_token() take a "silent" argument and only warn if it
is not set.  Propagate "silent" flag in _nc_parse_entry() to _nc_get_token().
Set the silent flag when reading termcap files, including $TERMCAP.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.9 2001/01/22 18:01:55 millert Exp $	*/
d193 1
a193 1
 *	        check for existance and type-correctness
@


1.9
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.8 2000/10/08 22:47:02 millert Exp $	*/
d208 1
a208 1
    token_type = _nc_get_token();
d254 1
a254 1
    for (token_type = _nc_get_token();
d256 1
a256 1
	 token_type = _nc_get_token()) {
@


1.8
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.7 2000/06/19 03:53:51 millert Exp $	*/
d52 1
a52 1
MODULE_ID("$From: parse_entry.c,v 1.48 2000/10/03 09:38:48 tom Exp $")
d200 3
a202 2
int
_nc_parse_entry(struct entry *entryp, int literal, bool silent)
d470 1
a470 1
    _nc_wrap_entry(entryp);
d475 1
a475 1
int
d487 5
a491 2
		if (!(isdigit(*s) || *s == '.' || *s == '*' || *s == '/' ||
		      *s == '>'))
d497 5
a501 2
		if (!(isdigit(*t) || *t == '.' || *t == '*' || *t == '/' ||
		      *t == '>'))
d519 1
a519 1
append_acs0(string_desc *dst, int code, int src)
d531 1
a531 1
append_acs(string_desc *dst, int code, char *src)
d669 1
a669 1
		 && _nc_safe_strcat(&result, scroll_forward))
d674 1
a674 1
		 && _nc_safe_strcat(&result, cursor_down))
d825 9
a833 7
    if (!hard_copy) {
	if (WANTED(key_backspace))
	    key_backspace = _nc_save_str(C_BS);
	if (WANTED(key_left))
	    key_left = _nc_save_str(C_BS);
	if (WANTED(key_down))
	    key_down = _nc_save_str(C_LF);
d855 11
a865 11
	append_acs (&result, 'j', acs_lrcorner);
	append_acs (&result, 'k', acs_urcorner);
	append_acs (&result, 'l', acs_ulcorner);
	append_acs (&result, 'm', acs_llcorner);
	append_acs (&result, 'n', acs_plus);
	append_acs (&result, 'q', acs_hline);
	append_acs (&result, 't', acs_ltee);
	append_acs (&result, 'u', acs_rtee);
	append_acs (&result, 'v', acs_btee);
	append_acs (&result, 'w', acs_ttee);
	append_acs (&result, 'x', acs_vline);
d897 11
a907 11
	append_acs0 (&result, 'l', box_chars_1[0]);	/* ACS_ULCORNER */
	append_acs0 (&result, 'q', box_chars_1[1]);	/* ACS_HLINE */
	append_acs0 (&result, 'k', box_chars_1[2]);	/* ACS_URCORNER */
	append_acs0 (&result, 'x', box_chars_1[3]);	/* ACS_VLINE */
	append_acs0 (&result, 'j', box_chars_1[4]);	/* ACS_LRCORNER */
	append_acs0 (&result, 'm', box_chars_1[5]);	/* ACS_LLCORNER */
	append_acs0 (&result, 'w', box_chars_1[6]);	/* ACS_TTEE */
	append_acs0 (&result, 'u', box_chars_1[7]);	/* ACS_RTEE */
	append_acs0 (&result, 'v', box_chars_1[8]);	/* ACS_BTEE */
	append_acs0 (&result, 't', box_chars_1[9]);	/* ACS_LTEE */
	append_acs0 (&result, 'n', box_chars_1[10]);	/* ACS_PLUS */
@


1.7
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.6 2000/03/13 23:53:40 millert Exp $	*/
d52 1
a52 1
MODULE_ID("$From: parse_entry.c,v 1.44 2000/04/30 00:17:42 tom Exp $")
d205 1
a205 1
    char *ptr, namecpy[MAX_NAME_SIZE + 1];
d240 10
a249 9
    (void) strlcpy(namecpy, entryp->tterm.term_names, sizeof(namecpy));
    if ((ptr = strrchr(namecpy, '|')) != (char *) 0)
	*ptr = '\0';
    ptr = strtok(namecpy, "|");
    if (strlen(ptr) > MAX_ALIAS)
	_nc_warning("primary name may be too long");
    while ((ptr = strtok((char *) 0, "|")) != (char *) 0)
	if (strlen(ptr) > MAX_ALIAS)
	    _nc_warning("alias `%s' may be too long", ptr);
d254 2
a255 2
	token_type != EOF && token_type != NAMES;
	token_type = _nc_get_token()) {
d264 1
a264 1
		_nc_syntax ? _nc_cap_hash_table : _nc_info_hash_table);
d282 1
a282 1
				    ap->from, ap->source);
d289 1
a289 1
				    ap->from, ap->source, ap->to);
d297 1
a297 1
				    ap->from, ap->source);
d304 1
a304 1
				    ap->from, ap->source, ap->to);
d321 2
a322 1
			_nc_curr_token.tk_name, token_type)) != 0) {
d332 1
a332 1
			_nc_curr_token.tk_name);
d351 2
a352 1
			_nc_get_table(_nc_syntax != 0));
d357 2
a358 1
			_nc_get_table(_nc_syntax != 0));
d382 1
a382 1
			    type_name, _nc_curr_token.tk_name);
d419 2
a420 2
			ptr,
			parametrized[entry_ptr->nte_index]);
d487 1
a487 1
			*s == '>'))
d494 1
a494 1
			*t == '>'))
d511 20
d591 1
a591 2
static
void
d595 1
d660 4
a663 3
		strlcpy(buf, carriage_return, MAX_LINE + 1);
		strlcat(buf, scroll_forward, MAX_LINE + 1);
		newline = _nc_save_str(buf);
d665 4
a668 3
		strlcpy(buf, carriage_return, MAX_LINE + 1);
		strlcat(buf, cursor_down, MAX_LINE + 1);
		newline = _nc_save_str(buf);
d721 1
a721 1
		    _nc_visbuf(tab));
d734 2
a735 1
	char *dp, *cp = strtok(other_non_function_keys, ",");
d744 1
a744 1
	foundim = dp && dp[1] == 'm';
d747 5
a751 1
	do {
d753 2
a754 1
		if (strcmp(ap->from, cp) == 0)
d757 2
a758 1
		_nc_warning("unknown capability `%s' in ko string", cp);
d781 2
a782 2
			tp->Strings[from_ptr->nte_index],
			tp->Strings[to_ptr->nte_index]) != 0)
d784 2
a785 2
			ap->to, ap->from,
			_nc_visbuf(tp->Strings[to_ptr->nte_index]));
d793 5
a797 8
	    dp = buf2;
	    for (cp = tp->Strings[from_ptr->nte_index]; *cp; cp++) {
		if (cp[0] == '$' && cp[1] == '<') {
		    while (*cp && *cp != '>')
			if (!*cp)
			    break;
			else
			    ++cp;
d799 1
a799 1
		    *dp++ = *cp;
d804 1
a804 2
	} while
	    ((cp = strtok((char *) 0, ",")) != 0);
d841 1
a841 1
	char buf2[MAX_TERMCAP_LENGTH], *bp = buf2;
d843 2
a844 4
	if (acs_chars) {
	    (void) strcpy(bp, acs_chars);
	    bp += strlen(bp);
	}
d846 11
a856 45
	if (acs_ulcorner && acs_ulcorner[1] == '\0') {
	    *bp++ = 'l';
	    *bp++ = *acs_ulcorner;
	}
	if (acs_llcorner && acs_llcorner[1] == '\0') {
	    *bp++ = 'm';
	    *bp++ = *acs_llcorner;
	}
	if (acs_urcorner && acs_urcorner[1] == '\0') {
	    *bp++ = 'k';
	    *bp++ = *acs_urcorner;
	}
	if (acs_lrcorner && acs_lrcorner[1] == '\0') {
	    *bp++ = 'j';
	    *bp++ = *acs_lrcorner;
	}
	if (acs_ltee && acs_ltee[1] == '\0') {
	    *bp++ = 't';
	    *bp++ = *acs_ltee;
	}
	if (acs_rtee && acs_rtee[1] == '\0') {
	    *bp++ = 'u';
	    *bp++ = *acs_rtee;
	}
	if (acs_btee && acs_btee[1] == '\0') {
	    *bp++ = 'v';
	    *bp++ = *acs_btee;
	}
	if (acs_ttee && acs_ttee[1] == '\0') {
	    *bp++ = 'w';
	    *bp++ = *acs_ttee;
	}
	if (acs_hline && acs_hline[1] == '\0') {
	    *bp++ = 'q';
	    *bp++ = *acs_hline;
	}
	if (acs_vline && acs_vline[1] == '\0') {
	    *bp++ = 'x';
	    *bp++ = *acs_vline;
	}
	if (acs_plus) {
	    *bp++ = 'n';
	    strcpy(bp, acs_plus);
	    bp = buf2 + strlen(buf2);
	}
d858 1
a858 2
	if (bp != buf2) {
	    *bp++ = '\0';
d863 2
a864 2
	    && enter_alt_charset_mode != 0
	&& exit_alt_charset_mode != 0) {
d870 1
a870 2
static
void
d882 2
a883 1
	char buf2[MAX_TERMCAP_LENGTH], *bp = buf2;
d885 2
a886 4
	if (acs_chars) {
	    (void) strcpy(bp, acs_chars);
	    bp += strlen(bp);
	}
d888 11
a898 44
	if (box_chars_1[0]) {	/* ACS_ULCORNER */
	    *bp++ = 'l';
	    *bp++ = box_chars_1[0];
	}
	if (box_chars_1[1]) {	/* ACS_HLINE */
	    *bp++ = 'q';
	    *bp++ = box_chars_1[1];
	}
	if (box_chars_1[2]) {	/* ACS_URCORNER */
	    *bp++ = 'k';
	    *bp++ = box_chars_1[2];
	}
	if (box_chars_1[3]) {	/* ACS_VLINE */
	    *bp++ = 'x';
	    *bp++ = box_chars_1[3];
	}
	if (box_chars_1[4]) {	/* ACS_LRCORNER */
	    *bp++ = 'j';
	    *bp++ = box_chars_1[4];
	}
	if (box_chars_1[5]) {	/* ACS_LLCORNER */
	    *bp++ = 'm';
	    *bp++ = box_chars_1[5];
	}
	if (box_chars_1[6]) {	/* ACS_TTEE */
	    *bp++ = 'w';
	    *bp++ = box_chars_1[6];
	}
	if (box_chars_1[7]) {	/* ACS_RTEE */
	    *bp++ = 'u';
	    *bp++ = box_chars_1[7];
	}
	if (box_chars_1[8]) {	/* ACS_BTEE */
	    *bp++ = 'v';
	    *bp++ = box_chars_1[8];
	}
	if (box_chars_1[9]) {	/* ACS_LTEE */
	    *bp++ = 't';
	    *bp++ = box_chars_1[9];
	}
	if (box_chars_1[10]) {	/* ACS_PLUS */
	    *bp++ = 'n';
	    *bp++ = box_chars_1[10];
	}
d900 1
a900 2
	if (bp != buf2) {
	    *bp++ = '\0';
d919 1
a919 2
static
struct name_table_entry const *
d946 1
a946 1
		    || entry_ptr->nte_index != count)
@


1.6
log
@update to ncurses-5.0-20000311
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.5 2000/03/10 01:35:04 millert Exp $	*/
d52 1
a52 1
MODULE_ID("$From: parse_entry.c,v 1.43 2000/03/12 00:09:06 tom Exp $")
a59 3

struct token _nc_curr_token =
{0, 0, 0};
@


1.5
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.4 2000/01/16 01:35:18 millert Exp $	*/
d52 1
a52 1
MODULE_ID("$From: parse_entry.c,v 1.42 2000/02/13 01:01:26 tom Exp $")
d260 1
a260 1
	    entryp->uses[entryp->nuses].parent = (void *) _nc_save_str(_nc_curr_token.tk_valstring);
d461 1
a461 1
		    if (!strchr((char *) entryp->uses[i].parent, '+'))
@


1.4
log
@Update to ncurses-5.0-20000115:
+ additional fixes for non-bce terminals (handling of delete_character)
to work when assume_default_colors() is not specified.
+ modify warning message from _nc_parse_entry() regarding extended
capability names to print only if tic/infocmp/toe have the -v flag
set, and not at all in ordinary user applications.  Otherwise, this
warning would be shown for screen's extended capabilities in programs
that use the termcap interface.
+ modify use of _nc_tracing from programs such as tic so their debug
level is not in the same range as values set by trace() function.
+ small panel header cleanup (patch by Juergen Pfeifer).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.3 1999/11/28 17:49:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d52 1
a52 1
MODULE_ID("$From: parse_entry.c,v 1.41 2000/01/15 22:30:27 tom Exp $")
@


1.3
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.2 1999/03/02 06:23:29 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999,1999 Free Software Foundation, Inc.                   *
a35 1

d52 1
a52 1
MODULE_ID("$From: parse_entry.c,v 1.40 1999/10/30 23:00:16 tom Exp $")
d55 2
a56 1
static short const parametrized[] = { 0 };
d61 2
a62 1
struct token	_nc_curr_token = { 0, 0, 0 };
d64 3
a66 3
static	void postprocess_termcap(TERMTYPE *, bool);
static	void postprocess_terminfo(TERMTYPE *);
static	struct name_table_entry	const * lookup_fullname(const char *name);
d70 2
a71 2
static struct name_table_entry	const *
_nc_extend_names(ENTRY *entryp, char *name, int token_type)
d83 2
a84 2
	first  = 0;
	last   = tp->ext_Booleans;
d89 2
a90 2
	first  = tp->ext_Booleans;
	last   = tp->ext_Numbers  + first;
d95 2
a96 2
	first  = tp->ext_Booleans + tp->ext_Numbers;
	last   = tp->ext_Strings  + first;
d104 1
a104 1
		if (n > (unsigned)(tp->ext_Booleans + tp->ext_Numbers)) {
d131 9
a139 3
	    case BOOLEAN:	tindex += BOOLCOUNT;	break;
	    case NUMBER:	tindex += NUMCOUNT;	break;
	    case STRING:	tindex += STRCOUNT;	break;
d150 2
a151 2
	    for (last = tp->num_Booleans-1; last > tindex; last--)
		tp->Booleans[last] = tp->Booleans[last-1];
d157 2
a158 2
	    for (last = tp->num_Numbers-1; last > tindex; last--)
		tp->Numbers[last] = tp->Numbers[last-1];
d164 2
a165 2
	    for (last = tp->num_Strings-1; last > tindex; last--)
		tp->Strings[last] = tp->Strings[last-1];
d169 1
a169 1
	tp->ext_Names  = typeRealloc(char *, actual, tp->ext_Names);
d171 1
a171 1
	    tp->ext_Names[actual] = tp->ext_Names[actual-1];
d175 2
a176 2
    temp.nte_name  = tp->ext_Names[offset];
    temp.nte_type  = token_type;
d178 1
a178 1
    temp.nte_link  = -1;
d203 2
a204 1
int _nc_parse_entry(struct entry *entryp, int literal, bool silent)
d206 3
a208 3
    int			token_type;
    struct name_table_entry	const *entry_ptr;
    char			*ptr, namecpy[MAX_NAME_SIZE+1];
d213 1
a213 1
	return(EOF);
d226 1
a226 2
    if (ptr[2] == '|')
    {
d244 1
a244 1
    if ((ptr = strrchr(namecpy, '|')) != (char *)0)
d249 1
a249 1
    while ((ptr = strtok((char *)0, "|")) != (char *)0)
d256 2
a257 3
	 token_type != EOF  &&  token_type != NAMES;
	 token_type = _nc_get_token())
    {
d260 1
a260 1
	    entryp->uses[entryp->nuses].parent = (void *)_nc_save_str(_nc_curr_token.tk_valstring);
d266 1
a266 1
				       _nc_syntax ? _nc_cap_hash_table : _nc_info_hash_table);
d276 2
a277 3
	    if (entry_ptr == NOTFOUND)
	    {
		const struct alias	*ap;
d279 1
a279 2
		if (_nc_syntax == SYN_TERMCAP)
		{
d281 2
a282 4
			if (strcmp(ap->from, _nc_curr_token.tk_name) == 0)
			{
			    if (ap->to == (char *)0)
			    {
d284 1
a284 1
					    ap->from, ap->source);
d290 2
a291 1
				_nc_warning("%s (%s termcap extension) aliased to %s", ap->from, ap->source, ap->to);
d294 1
a294 3
		}
		else /* if (_nc_syntax == SYN_TERMINFO) */
		{
d296 2
a297 4
			if (strcmp(ap->from, _nc_curr_token.tk_name) == 0)
			{
			    if (ap->to == (char *)0)
			    {
d299 1
a299 1
					    ap->from, ap->source);
d305 2
a306 1
				_nc_warning("%s (%s terminfo extension) aliased to %s", ap->from, ap->source, ap->to);
a314 1

d321 5
a325 3
	     && _nc_user_definable
	     && (entry_ptr = _nc_extend_names(entryp, _nc_curr_token.tk_name, token_type)) != 0) {
		_nc_warning("extended capability '%s'", _nc_curr_token.tk_name);
d333 1
a333 1
				_nc_curr_token.tk_name);
d338 1
a338 2
	    if (token_type != CANCEL &&  entry_ptr->nte_type != token_type)
	    {
d352 1
a352 1
					_nc_get_table(_nc_syntax != 0));
d355 1
a355 1
		else if (token_type==STRING &&!strcmp("MT",_nc_curr_token.tk_name))
d357 1
a357 1
					_nc_get_table(_nc_syntax != 0));
d360 1
a360 1
		else if (token_type==BOOLEAN && entry_ptr->nte_type==STRING)
d363 2
a364 4
		else
		{
		    if (!silent)
		    {
d366 1
a366 2
			switch (entry_ptr->nte_type)
			{
d368 2
a369 2
				type_name = "boolean";
				break;
d371 2
a372 2
				type_name = "string";
				break;
d374 2
a375 2
				type_name = "numeric";
				break;
d377 2
a378 2
				type_name = "unknown";
				break;
d381 1
a381 1
				type_name, _nc_curr_token.tk_name);
d416 1
a416 1
		if (_nc_syntax==SYN_TERMCAP)
d418 2
a419 2
				    ptr,
				    parametrized[entry_ptr->nte_index]);
d426 1
a426 1
		_nc_panic_mode((_nc_syntax==SYN_TERMCAP) ? ':' : ',');
d429 4
a432 4
	} /* end else cur_token.name != "use" */
    nexttok:
	continue;	/* cannot have a label w/o statement */
    } /* endwhile (not EOF and not NAMES) */
d444 3
a446 4
	if (_nc_syntax == SYN_TERMCAP)
	{
	    bool	has_base_entry = FALSE;
	    int		i;
d461 1
a461 1
		    if (!strchr((char *)entryp->uses[i].parent, '+'))
d465 1
a465 2
        }
	else
d470 1
a470 1
    return(OK);
d473 2
a474 1
int _nc_capcmp(const char *s, const char *t)
d478 1
a478 1
	return(0);
d480 1
a480 1
	return(1);
d482 5
a486 6
    for (;;)
    {
	if (s[0] == '$' && s[1] == '<')
	{
	    for (s += 2; ; s++)
		if (!(isdigit(*s) || *s=='.' || *s=='*' || *s=='/' || *s=='>'))
d490 4
a493 4
	if (t[0] == '$' && t[1] == '<')
	{
	    for (t += 2; ; t++)
		if (!(isdigit(*t) || *t=='.' || *t=='*' || *t=='/' || *t=='>'))
d500 1
a500 1
		return(0);
d503 1
a503 1
	    return(*t - *s);
d515 4
a518 1
typedef struct {const char *from; const char *to;} assoc;
d521 20
a540 20
    {"al",	"kil1"},	/* insert line key  -> KEY_IL    */
    {"bt",	"kcbt"},	/* back tab         -> KEY_BTAB  */
    {"cd",	"ked"},		/* clear-to-eos key -> KEY_EOL   */
    {"ce",	"kel"},		/* clear-to-eol key -> KEY_EOS   */
    {"cl",	"kclr"},	/* clear key        -> KEY_CLEAR */
    {"ct",	"tbc"},		/* clear all tabs   -> KEY_CATAB */
    {"dc",	"kdch1"},	/* delete char      -> KEY_DC    */
    {"dl",	"kdl1"},	/* delete line      -> KEY_DL    */
    {"do",	"kcud1"},	/* down key         -> KEY_DOWN  */
    {"ei",	"krmir"},	/* exit insert key  -> KEY_EIC   */
    {"ho",	"khome"},	/* home key         -> KEY_HOME  */
    {"ic",	"kich1"},	/* insert char key  -> KEY_IC    */
    {"im",	"kIC"},		/* insert-mode key  -> KEY_SIC   */
    {"le",	"kcub1"},	/* le key           -> KEY_LEFT  */
    {"nd",	"kcuf1"},	/* nd key           -> KEY_RIGHT */
    {"nl",	"kent"},	/* new line key     -> KEY_ENTER */
    {"st",	"khts"},	/* set-tab key      -> KEY_STAB  */
    {"ta",	CANCELLED_STRING},
    {"up",	"kcuu1"},	/* up-arrow key     -> KEY_UP    */
    {(char *)0, (char *)0},
d571 2
a572 1
void postprocess_termcap(TERMTYPE *tp, bool has_base)
d585 1
a585 2
    if (!has_base)
    {
d639 2
a640 2
		strlcpy(buf, carriage_return, MAX_LINE+1);
		strlcat(buf, scroll_forward, MAX_LINE+1);
d643 2
a644 2
		strlcpy(buf, carriage_return, MAX_LINE+1);
		strlcat(buf, cursor_down, MAX_LINE+1);
d659 1
a659 2
    if (!has_base)
    {
d695 1
a695 2
        else
	{
d698 2
a699 3
			    _nc_visbuf(tab));
	    else
	    {
d710 7
a716 8
    if (PRESENT(other_non_function_keys))
    {
	char	*dp, *cp = strtok(other_non_function_keys, ",");
	struct name_table_entry	const *from_ptr;
	struct name_table_entry	const *to_ptr;
	assoc	const *ap;
	char	buf2[MAX_TERMINFO_LENGTH];
	bool	foundim;
d727 1
a727 2
	    if (!ap->to)
	    {
d730 1
a730 2
	    }
	    else if (ap->to == CANCELLED_STRING)	/* ignore it */
d736 1
a736 1
	    to_ptr   = _nc_find_entry(ap->to,   _nc_info_hash_table);
d741 1
a741 2
	    if (WANTED(tp->Strings[from_ptr->nte_index]))
	    {
d746 1
a746 2
	    if (tp->Strings[to_ptr->nte_index])
	    {
d754 2
a755 2
			    ap->to, ap->from,
			    _nc_visbuf(tp->Strings[to_ptr->nte_index]) );
d764 2
a765 4
	    for (cp = tp->Strings[from_ptr->nte_index]; *cp; cp++)
	    {
		if (cp[0] == '$' && cp[1] == '<')
		{
d769 1
a769 1
		        else
d771 1
a771 2
		}
		else
d778 1
a778 1
	    ((cp = strtok((char *)0, ",")) != 0);
d786 1
a786 2
	if (foundim && WANTED(key_ic) && key_sic)
	{
d792 1
a792 2
    if (!hard_copy)
    {
d814 5
a818 7
	PRESENT(acs_plus))
    {
	char	buf2[MAX_TERMCAP_LENGTH], *bp = buf2;

	if (acs_chars)
	{
	    (void)strcpy(bp, acs_chars);
d822 1
a822 2
	if (acs_ulcorner && acs_ulcorner[1] == '\0')
	{
d826 1
a826 2
	if (acs_llcorner && acs_llcorner[1] == '\0')
	{
d830 1
a830 2
	if (acs_urcorner && acs_urcorner[1] == '\0')
	{
d834 1
a834 2
	if (acs_lrcorner && acs_lrcorner[1] == '\0')
	{
d838 1
a838 2
	if (acs_ltee && acs_ltee[1] == '\0')
	{
d842 1
a842 2
	if (acs_rtee && acs_rtee[1] == '\0')
	{
d846 1
a846 2
	if (acs_btee && acs_btee[1] == '\0')
	{
d850 1
a850 2
	if (acs_ttee && acs_ttee[1] == '\0')
	{
d854 1
a854 2
	if (acs_hline && acs_hline[1] == '\0')
	{
d858 1
a858 2
	if (acs_vline && acs_vline[1] == '\0')
	{
d862 1
a862 2
	if (acs_plus)
	{
d868 1
a868 2
	if (bp != buf2)
	{
d873 5
a877 6
    }
    else if (acs_chars == 0
	&& enter_alt_charset_mode != 0
	&& exit_alt_charset_mode != 0)
    {
	acs_chars = _nc_save_str("``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~");
d882 2
a883 1
void postprocess_terminfo(TERMTYPE *tp)
d893 5
a897 7
    if (PRESENT(box_chars_1))
    {
	char	buf2[MAX_TERMCAP_LENGTH], *bp = buf2;

	if (acs_chars)
	{
	    (void)strcpy(bp, acs_chars);
d901 1
a901 2
	if (box_chars_1[0])	/* ACS_ULCORNER */
	{
d905 1
a905 2
	if (box_chars_1[1])	/* ACS_HLINE */
	{
d909 1
a909 2
	if (box_chars_1[2])	/* ACS_URCORNER */
	{
d913 1
a913 2
	if (box_chars_1[3])	/* ACS_VLINE */
	{
d917 1
a917 2
	if (box_chars_1[4])	/* ACS_LRCORNER */
	{
d921 1
a921 2
	if (box_chars_1[5])	/* ACS_LLCORNER */
	{
d925 1
a925 2
	if (box_chars_1[6])	/* ACS_TTEE */
	{
d929 1
a929 2
	if (box_chars_1[7])	/* ACS_RTEE */
	{
d933 1
a933 2
	if (box_chars_1[8])	/* ACS_BTEE */
	{
d937 1
a937 2
	if (box_chars_1[9])	/* ACS_LTEE */
	{
d941 1
a941 2
	if (box_chars_1[10])	/* ACS_PLUS */
	{
d946 1
a946 2
	if (bp != buf2)
	{
d967 2
a968 1
struct name_table_entry	const * lookup_fullname(const char *find)
d992 2
a993 2
		struct name_table_entry	const *entry_ptr = _nc_get_table(FALSE);
		while (entry_ptr->nte_type  != state
d995 1
a995 1
			entry_ptr++;
@


1.2
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.1 1999/01/18 19:10:21 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Free Software Foundation, Inc.                        *
d53 1
a53 1
MODULE_ID("$From: parse_entry.c,v 1.39 1999/03/01 02:28:51 tom Exp $")
d61 1
a61 1
struct token	_nc_curr_token;
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: parse_entry.c,v 1.1 1998/07/23 21:19:58 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a50 1
#include <term.h>
d53 1
a53 1
MODULE_ID("$From: parse_entry.c,v 1.24 1998/07/04 23:08:38 tom Exp $")
d67 110
a309 1
		    /* last chance: a full-name */
d316 12
d465 1
a465 1
		    if (!strchr(entryp->uses[i].parent, '+'))
@

