head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.32
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.28
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.24
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.26
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.18
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.22
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.38
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.34
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.32
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.30
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.28
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.26
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.24
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.22
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.20
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.18
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.16
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.14
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.12
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.10
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.8
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.22.18.01.50;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.08.22.47.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.26.16.45.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.05.08.20.29.00;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.03.02.06.23.28;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1999-2006,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Thomas E. Dickey <dickey@@clark.net> 1999-on                     *
 ****************************************************************************/

/*
 * align_ttype.c --  functions for TERMTYPE
 *
 *	_nc_align_termtype()
 *	_nc_copy_termtype()
 *
 */

#include <curses.priv.h>

#include <tic.h>
#include <term_entry.h>

MODULE_ID("$Id: alloc_ttype.c,v 1.17 2008/10/12 16:12:00 tom Exp $")

#if NCURSES_XNAMES
/*
 * Merge the a/b lists into dst.  Both a/b are sorted (see _nc_extend_names()),
 * so we do not have to worry about order dependencies.
 */
static int
merge_names(char **dst, char **a, int na, char **b, int nb)
{
    int n = 0;
    while (na > 0 && nb > 0) {
	int cmp = strcmp(*a, *b);
	if (cmp < 0) {
	    dst[n++] = *a++;
	    na--;
	} else if (cmp > 0) {
	    dst[n++] = *b++;
	    nb--;
	} else if (cmp == 0) {
	    dst[n++] = *a;
	    a++, b++;
	    na--, nb--;
	}
    }
    while (na-- > 0) {
	dst[n++] = *a++;
    }
    while (nb-- > 0) {
	dst[n++] = *b++;
    }
    DEBUG(4, ("merge_names -> %d", n));
    return n;
}

static bool
find_name(char **table, int length, char *name)
{
    while (length-- > 0) {
	if (!strcmp(*table++, name)) {
	    DEBUG(4, ("found name '%s'", name));
	    return TRUE;
	}
    }
    DEBUG(4, ("did not find name '%s'", name));
    return FALSE;
}

static void
realign_data(TERMTYPE *to, char **ext_Names,
	     int ext_Booleans,
	     int ext_Numbers,
	     int ext_Strings)
{
    int n, m, base;
    int limit = (to->ext_Booleans + to->ext_Numbers + to->ext_Strings);

    if (to->ext_Booleans != ext_Booleans) {
	to->num_Booleans += (ext_Booleans - to->ext_Booleans);
	to->Booleans = typeRealloc(NCURSES_SBOOL, to->num_Booleans, to->Booleans);
	for (n = to->ext_Booleans - 1,
	     m = ext_Booleans - 1,
	     base = to->num_Booleans - (m + 1); m >= 0; m--) {
	    if (find_name(to->ext_Names, limit, ext_Names[m])) {
		to->Booleans[base + m] = to->Booleans[base + n--];
	    } else {
		to->Booleans[base + m] = FALSE;
	    }
	}
	to->ext_Booleans = ext_Booleans;
    }
    if (to->ext_Numbers != ext_Numbers) {
	to->num_Numbers += (ext_Numbers - to->ext_Numbers);
	to->Numbers = typeRealloc(short, to->num_Numbers, to->Numbers);
	for (n = to->ext_Numbers - 1,
	     m = ext_Numbers - 1,
	     base = to->num_Numbers - (m + 1); m >= 0; m--) {
	    if (find_name(to->ext_Names, limit, ext_Names[m + ext_Booleans])) {
		to->Numbers[base + m] = to->Numbers[base + n--];
	    } else {
		to->Numbers[base + m] = ABSENT_NUMERIC;
	    }
	}
	to->ext_Numbers = ext_Numbers;
    }
    if (to->ext_Strings != ext_Strings) {
	to->num_Strings += (ext_Strings - to->ext_Strings);
	to->Strings = typeRealloc(char *, to->num_Strings, to->Strings);
	for (n = to->ext_Strings - 1,
	     m = ext_Strings - 1,
	     base = to->num_Strings - (m + 1); m >= 0; m--) {
	    if (find_name(to->ext_Names, limit, ext_Names[m + ext_Booleans + ext_Numbers])) {
		to->Strings[base + m] = to->Strings[base + n--];
	    } else {
		to->Strings[base + m] = ABSENT_STRING;
	    }
	}
	to->ext_Strings = ext_Strings;
    }
}

/*
 * Returns the first index in ext_Names[] for the given token-type
 */
static int
_nc_first_ext_name(TERMTYPE *tp, int token_type)
{
    int first;

    switch (token_type) {
    case BOOLEAN:
	first = 0;
	break;
    case NUMBER:
	first = tp->ext_Booleans;
	break;
    case STRING:
	first = tp->ext_Booleans + tp->ext_Numbers;
	break;
    default:
	first = 0;
	break;
    }
    return first;
}

/*
 * Returns the last index in ext_Names[] for the given token-type
 */
static int
_nc_last_ext_name(TERMTYPE *tp, int token_type)
{
    int last;

    switch (token_type) {
    case BOOLEAN:
	last = tp->ext_Booleans;
	break;
    case NUMBER:
	last = tp->ext_Booleans + tp->ext_Numbers;
	break;
    default:
    case STRING:
	last = NUM_EXT_NAMES(tp);
	break;
    }
    return last;
}

/*
 * Lookup an entry from extended-names, returning -1 if not found
 */
static int
_nc_find_ext_name(TERMTYPE *tp, char *name, int token_type)
{
    unsigned j;
    unsigned first = _nc_first_ext_name(tp, token_type);
    unsigned last = _nc_last_ext_name(tp, token_type);

    for (j = first; j < last; j++) {
	if (!strcmp(name, tp->ext_Names[j])) {
	    return j;
	}
    }
    return -1;
}

/*
 * Translate an index into ext_Names[] into the corresponding index into data
 * (e.g., Booleans[]).
 */
static int
_nc_ext_data_index(TERMTYPE *tp, int n, int token_type)
{
    switch (token_type) {
    case BOOLEAN:
	n += (tp->num_Booleans - tp->ext_Booleans);
	break;
    case NUMBER:
	n += (tp->num_Numbers - tp->ext_Numbers)
	    - (tp->ext_Booleans);
	break;
    default:
    case STRING:
	n += (tp->num_Strings - tp->ext_Strings)
	    - (tp->ext_Booleans + tp->ext_Numbers);
    }
    return n;
}

/*
 * Adjust tables to remove (not free) an extended name and its corresponding
 * data.
 */
static bool
_nc_del_ext_name(TERMTYPE *tp, char *name, int token_type)
{
    int j;
    int first, last;

    if ((first = _nc_find_ext_name(tp, name, token_type)) >= 0) {
	last = NUM_EXT_NAMES(tp) - 1;
	for (j = first; j < last; j++) {
	    tp->ext_Names[j] = tp->ext_Names[j + 1];
	}
	first = _nc_ext_data_index(tp, first, token_type);
	switch (token_type) {
	case BOOLEAN:
	    last = tp->num_Booleans - 1;
	    for (j = first; j < last; j++)
		tp->Booleans[j] = tp->Booleans[j + 1];
	    tp->ext_Booleans -= 1;
	    tp->num_Booleans -= 1;
	    break;
	case NUMBER:
	    last = tp->num_Numbers - 1;
	    for (j = first; j < last; j++)
		tp->Numbers[j] = tp->Numbers[j + 1];
	    tp->ext_Numbers -= 1;
	    tp->num_Numbers -= 1;
	    break;
	case STRING:
	    last = tp->num_Strings - 1;
	    for (j = first; j < last; j++)
		tp->Strings[j] = tp->Strings[j + 1];
	    tp->ext_Strings -= 1;
	    tp->num_Strings -= 1;
	    break;
	}
	return TRUE;
    }
    return FALSE;
}

/*
 * Adjust tables to insert an extended name, making room for new data.  The
 * index into the corresponding data array is returned.
 */
static int
_nc_ins_ext_name(TERMTYPE *tp, char *name, int token_type)
{
    unsigned first = _nc_first_ext_name(tp, token_type);
    unsigned last = _nc_last_ext_name(tp, token_type);
    unsigned total = NUM_EXT_NAMES(tp) + 1;
    unsigned j, k;

    for (j = first; j < last; j++) {
	int cmp = strcmp(name, tp->ext_Names[j]);
	if (cmp == 0)
	    /* already present */
	    return _nc_ext_data_index(tp, (int) j, token_type);
	if (cmp < 0) {
	    break;
	}
    }

    tp->ext_Names = typeRealloc(char *, total, tp->ext_Names);
    for (k = total - 1; k > j; k--)
	tp->ext_Names[k] = tp->ext_Names[k - 1];
    tp->ext_Names[j] = name;
    j = _nc_ext_data_index(tp, (int) j, token_type);

    switch (token_type) {
    case BOOLEAN:
	tp->ext_Booleans += 1;
	tp->num_Booleans += 1;
	tp->Booleans = typeRealloc(NCURSES_SBOOL, tp->num_Booleans, tp->Booleans);
	for (k = tp->num_Booleans - 1; k > j; k--)
	    tp->Booleans[k] = tp->Booleans[k - 1];
	break;
    case NUMBER:
	tp->ext_Numbers += 1;
	tp->num_Numbers += 1;
	tp->Numbers = typeRealloc(short, tp->num_Numbers, tp->Numbers);
	for (k = tp->num_Numbers - 1; k > j; k--)
	    tp->Numbers[k] = tp->Numbers[k - 1];
	break;
    case STRING:
	tp->ext_Strings += 1;
	tp->num_Strings += 1;
	tp->Strings = typeRealloc(char *, tp->num_Strings, tp->Strings);
	for (k = tp->num_Strings - 1; k > j; k--)
	    tp->Strings[k] = tp->Strings[k - 1];
	break;
    }
    return j;
}

/*
 * Look for strings that are marked cancelled, which happen to be the same name
 * as a boolean or number.  We'll get this as a special case when we get a
 * cancellation of a name that is inherited from another entry.
 */
static void
adjust_cancels(TERMTYPE *to, TERMTYPE *from)
{
    int first = to->ext_Booleans + to->ext_Numbers;
    int last = first + to->ext_Strings;
    int j, k;

    for (j = first; j < last;) {
	char *name = to->ext_Names[j];
	unsigned j_str = to->num_Strings - first - to->ext_Strings;

	if (to->Strings[j + j_str] == CANCELLED_STRING) {
	    if ((k = _nc_find_ext_name(from, to->ext_Names[j], BOOLEAN)) >= 0) {
		if (_nc_del_ext_name(to, name, STRING)
		    || _nc_del_ext_name(to, name, NUMBER)) {
		    k = _nc_ins_ext_name(to, name, BOOLEAN);
		    to->Booleans[k] = FALSE;
		} else {
		    j++;
		}
	    } else if ((k = _nc_find_ext_name(from, to->ext_Names[j],
					      NUMBER)) >= 0) {
		if (_nc_del_ext_name(to, name, STRING)
		    || _nc_del_ext_name(to, name, BOOLEAN)) {
		    k = _nc_ins_ext_name(to, name, NUMBER);
		    to->Numbers[k] = CANCELLED_NUMERIC;
		} else {
		    j++;
		}
	    } else if ((k = _nc_find_ext_name(from, to->ext_Names[j],
					      STRING)) >= 0) {
		if (_nc_del_ext_name(to, name, NUMBER)
		    || _nc_del_ext_name(to, name, BOOLEAN)) {
		    k = _nc_ins_ext_name(to, name, STRING);
		    to->Strings[k] = CANCELLED_STRING;
		} else {
		    j++;
		}
	    } else {
		j++;
	    }
	} else {
	    j++;
	}
    }
}

NCURSES_EXPORT(void)
_nc_align_termtype(TERMTYPE *to, TERMTYPE *from)
{
    int na = NUM_EXT_NAMES(to);
    int nb = NUM_EXT_NAMES(from);
    int n;
    bool same;
    char **ext_Names;
    int ext_Booleans, ext_Numbers, ext_Strings;
    bool used_ext_Names = FALSE;

    DEBUG(2, ("align_termtype to(%d:%s), from(%d:%s)", na, to->term_names,
	      nb, from->term_names));

    if (na != 0 || nb != 0) {
	if ((na == nb)		/* check if the arrays are equivalent */
	    &&(to->ext_Booleans == from->ext_Booleans)
	    && (to->ext_Numbers == from->ext_Numbers)
	    && (to->ext_Strings == from->ext_Strings)) {
	    for (n = 0, same = TRUE; n < na; n++) {
		if (strcmp(to->ext_Names[n], from->ext_Names[n])) {
		    same = FALSE;
		    break;
		}
	    }
	    if (same)
		return;
	}
	/*
	 * This is where we pay for having a simple extension representation. 
	 * Allocate a new ext_Names array and merge the two ext_Names arrays
	 * into it, updating to's counts for booleans, etc.  Fortunately we do
	 * this only for the terminfo compiler (tic) and comparer (infocmp).
	 */
	ext_Names = typeMalloc(char *, na + nb);

	if (to->ext_Strings && (from->ext_Booleans + from->ext_Numbers))
	    adjust_cancels(to, from);

	if (from->ext_Strings && (to->ext_Booleans + to->ext_Numbers))
	    adjust_cancels(from, to);

	ext_Booleans = merge_names(ext_Names,
				   to->ext_Names,
				   to->ext_Booleans,
				   from->ext_Names,
				   from->ext_Booleans);
	ext_Numbers = merge_names(ext_Names + ext_Booleans,
				  to->ext_Names
				  + to->ext_Booleans,
				  to->ext_Numbers,
				  from->ext_Names
				  + from->ext_Booleans,
				  from->ext_Numbers);
	ext_Strings = merge_names(ext_Names + ext_Numbers + ext_Booleans,
				  to->ext_Names
				  + to->ext_Booleans
				  + to->ext_Numbers,
				  to->ext_Strings,
				  from->ext_Names
				  + from->ext_Booleans
				  + from->ext_Numbers,
				  from->ext_Strings);
	/*
	 * Now we must reallocate the Booleans, etc., to allow the data to be
	 * overlaid.
	 */
	if (na != (ext_Booleans + ext_Numbers + ext_Strings)) {
	    realign_data(to, ext_Names, ext_Booleans, ext_Numbers, ext_Strings);
	    FreeIfNeeded(to->ext_Names);
	    to->ext_Names = ext_Names;
	    DEBUG(2, ("realigned %d extended names for '%s' (to)",
		      NUM_EXT_NAMES(to), to->term_names));
	    used_ext_Names = TRUE;
	}
	if (nb != (ext_Booleans + ext_Numbers + ext_Strings)) {
	    nb = (ext_Booleans + ext_Numbers + ext_Strings);
	    realign_data(from, ext_Names, ext_Booleans, ext_Numbers, ext_Strings);
	    from->ext_Names = typeRealloc(char *, nb, from->ext_Names);
	    memcpy(from->ext_Names, ext_Names, sizeof(char *) * nb);
	    DEBUG(2, ("realigned %d extended names for '%s' (from)",
		      NUM_EXT_NAMES(from), from->term_names));
	}
	if (!used_ext_Names)
	    free(ext_Names);
    }
}
#endif

NCURSES_EXPORT(void)
_nc_copy_termtype(TERMTYPE *dst, TERMTYPE *src)
{
    unsigned i;

    *dst = *src;		/* ...to copy the sizes and string-tables */
    dst->Booleans = typeMalloc(NCURSES_SBOOL, NUM_BOOLEANS(dst));
    dst->Numbers = typeMalloc(short, NUM_NUMBERS(dst));
    dst->Strings = typeMalloc(char *, NUM_STRINGS(dst));

    /* FIXME: use memcpy for these and similar loops */
    for_each_boolean(i, dst)
	dst->Booleans[i] = src->Booleans[i];
    for_each_number(i, dst)
	dst->Numbers[i] = src->Numbers[i];
    for_each_string(i, dst)
	dst->Strings[i] = src->Strings[i];

    /* FIXME: we probably should also copy str_table and ext_str_table,
     * but tic and infocmp are not written to exploit that (yet).
     */

#if NCURSES_XNAMES
    if ((i = NUM_EXT_NAMES(src)) != 0) {
	dst->ext_Names = typeMalloc(char *, i);
	memcpy(dst->ext_Names, src->ext_Names, i * sizeof(char *));
    } else {
	dst->ext_Names = 0;
    }
#endif

}
@


1.5
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc_ttype.c,v 1.4 2000/10/08 22:47:00 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999,2000 Free Software Foundation, Inc.                   *
d32 1
a32 1
 *  Author: Thomas E. Dickey <dickey@@clark.net> 1999                        *
d48 1
a48 1
MODULE_ID("$From: alloc_ttype.c,v 1.12 2000/12/10 02:55:07 tom Exp $")
d97 4
a100 2
realign_data(TERMTYPE * to, char **ext_Names, int ext_Booleans, int
	     ext_Numbers, int ext_Strings)
d107 1
a107 1
	to->Booleans = typeRealloc(char, to->num_Booleans, to->Booleans);
d153 1
a153 1
_nc_first_ext_name(TERMTYPE * tp, int token_type)
d178 1
a178 1
_nc_last_ext_name(TERMTYPE * tp, int token_type)
d201 1
a201 1
_nc_find_ext_name(TERMTYPE * tp, char *name, int token_type)
d220 1
a220 1
_nc_ext_data_index(TERMTYPE * tp, int n, int token_type)
d243 1
a243 1
_nc_del_ext_name(TERMTYPE * tp, char *name, int token_type)
d287 1
a287 1
_nc_ins_ext_name(TERMTYPE * tp, char *name, int token_type)
d298 1
a298 1
	    return _nc_ext_data_index(tp, j, token_type);
d308 1
a308 1
    j = _nc_ext_data_index(tp, j, token_type);
d314 1
a314 1
	tp->Booleans = typeRealloc(char, tp->num_Booleans, tp->Booleans);
d342 1
a342 1
adjust_cancels(TERMTYPE * to, TERMTYPE * from)
d370 11
d389 1
a389 2
_nc_align_termtype
(TERMTYPE * to, TERMTYPE * from)
d397 1
d461 1
d471 2
d478 1
a478 2
_nc_copy_termtype
(TERMTYPE * dst, TERMTYPE * src)
d480 1
a480 1
    int i;
d483 1
a483 1
    dst->Booleans = typeMalloc(char, NUM_BOOLEANS(dst));
@


1.4
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc_ttype.c,v 1.3 2000/03/26 16:45:03 millert Exp $	*/
d48 1
a48 1
MODULE_ID("$From: alloc_ttype.c,v 1.10 2000/08/12 21:56:24 tom Exp $")
d375 3
a377 2
void
_nc_align_termtype(TERMTYPE * to, TERMTYPE * from)
d461 3
a463 2
void
_nc_copy_termtype(TERMTYPE * dst, TERMTYPE * src)
@


1.3
log
@Update to ncurses-5.0-20000325
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc_ttype.c,v 1.2 1999/05/08 20:29:00 millert Exp $	*/
d48 1
a48 1
MODULE_ID("$From: alloc_ttype.c,v 1.8 2000/03/25 17:03:11 tom Exp $")
d59 1
a59 1
    while (na && nb) {
d98 1
a98 1
    ext_Numbers, int ext_Strings)
d107 2
a108 2
	    m = ext_Booleans - 1,
	    base = to->num_Booleans - (m + 1); m >= 0; m--) {
d121 2
a122 2
	    m = ext_Numbers - 1,
	    base = to->num_Numbers - (m + 1); m >= 0; m--) {
d135 2
a136 2
	    m = ext_Strings - 1,
	    base = to->num_Strings - (m + 1); m >= 0; m--) {
d240 1
a240 1
static void
d275 1
d277 1
d352 7
a358 3
		_nc_del_ext_name(to, name, STRING);
		k = _nc_ins_ext_name(to, name, BOOLEAN);
		to->Booleans[k] = FALSE;
d360 8
a367 4
		NUMBER)) >= 0) {
		_nc_del_ext_name(to, name, STRING);
		k = _nc_ins_ext_name(to, name, NUMBER);
		to->Numbers[k] = CANCELLED_NUMERIC;
d386 1
a386 1
	    nb, from->term_names));
d417 4
a420 4
	    to->ext_Names,
	    to->ext_Booleans,
	    from->ext_Names,
	    from->ext_Booleans);
d422 6
a427 6
	    to->ext_Names
	    + to->ext_Booleans,
	    to->ext_Numbers,
	    from->ext_Names
	    + from->ext_Booleans,
	    from->ext_Numbers);
d429 8
a436 8
	    to->ext_Names
	    + to->ext_Booleans
	    + to->ext_Numbers,
	    to->ext_Strings,
	    from->ext_Names
	    + from->ext_Booleans
	    + from->ext_Numbers,
	    from->ext_Strings);
d446 1
a446 1
		    NUM_EXT_NAMES(to), to->term_names));
d454 1
a454 1
		    NUM_EXT_NAMES(from), from->term_names));
@


1.2
log
@ncurses-4.2-990424
@
text
@d1 1
a1 1
/*	$OpenBSD: alloc_ttype.c,v 1.1 1999/03/02 06:23:28 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Free Software Foundation, Inc.                        *
a34 1

d48 1
a48 1
MODULE_ID("$From: alloc_ttype.c,v 1.6 1999/03/01 22:10:44 tom Exp $")
d55 2
a56 1
static int merge_names(char **dst, char **a, int na, char **b, int nb)
d83 2
a84 1
static bool find_name(char **table, int length, char *name)
d96 3
a98 1
static void realign_data(TERMTYPE *to, char **ext_Names, int ext_Booleans, int ext_Numbers, int ext_Strings)
d106 3
a108 3
	for (n = to->ext_Booleans-1,
	     m = ext_Booleans-1,
	     base = to->num_Booleans - (m+1); m >= 0; m--) {
d120 4
a123 4
	for (n = to->ext_Numbers-1,
	     m = ext_Numbers-1,
	     base = to->num_Numbers - (m+1); m >= 0; m--) {
	    if (find_name(to->ext_Names, limit, ext_Names[m+ext_Booleans])) {
d129 1
a129 1
	to->ext_Numbers  = ext_Numbers;
d133 5
a137 5
	to->Strings = typeRealloc(char*, to->num_Strings, to->Strings);
	for (n = to->ext_Strings-1,
	     m = ext_Strings-1,
	     base = to->num_Strings - (m+1); m >= 0; m--) {
	    if (find_name(to->ext_Names, limit, ext_Names[m+ext_Booleans+ext_Numbers])) {
d150 2
a151 1
static int _nc_first_ext_name(TERMTYPE *tp, int token_type)
d175 2
a176 1
static int _nc_last_ext_name(TERMTYPE *tp, int token_type)
d182 1
a182 1
	last  = tp->ext_Booleans;
d185 1
a185 1
	last  = tp->ext_Booleans + tp->ext_Numbers;
d189 1
a189 1
	last  = NUM_EXT_NAMES(tp);
d198 2
a199 1
static int _nc_find_ext_name(TERMTYPE *tp, char *name, int token_type)
d203 1
a203 1
    unsigned last  = _nc_last_ext_name(tp, token_type);
d217 2
a218 1
static int _nc_ext_data_index(TERMTYPE *tp, int n, int token_type)
d226 1
a226 1
	   - (tp->ext_Booleans);
d231 1
a231 1
	   - (tp->ext_Booleans + tp->ext_Numbers);
d240 2
a241 1
static void _nc_del_ext_name(TERMTYPE *tp, char *name, int token_type)
d249 1
a249 1
	    tp->ext_Names[j] = tp->ext_Names[j+1];
d256 1
a256 1
		tp->Booleans[j] = tp->Booleans[j+1];
d263 1
a263 1
		tp->Numbers[j] = tp->Numbers[j+1];
d270 1
a270 1
		tp->Strings[j] = tp->Strings[j+1];
d282 2
a283 1
static int _nc_ins_ext_name(TERMTYPE *tp, char *name, int token_type)
d286 1
a286 1
    unsigned last  = _nc_last_ext_name(tp, token_type);
d301 2
a302 2
    for (k = total-1; k > j; k--)
	tp->ext_Names[k] = tp->ext_Names[k-1];
d311 2
a312 2
	for (k = tp->num_Booleans-1; k > j; k--)
	    tp->Booleans[k] = tp->Booleans[k-1];
d318 2
a319 2
	for (k = tp->num_Numbers-1; k > j; k--)
	    tp->Numbers[k] = tp->Numbers[k-1];
d325 2
a326 2
	for (k = tp->num_Strings-1; k > j; k--)
	    tp->Strings[k] = tp->Strings[k-1];
d337 2
a338 1
static void adjust_cancels(TERMTYPE *to, TERMTYPE *from)
d341 1
a341 1
    int last  = first + to->ext_Strings;
d344 1
a344 1
    for (j = first; j < last; ) {
d353 2
a354 1
	    } else if ((k = _nc_find_ext_name(from, to->ext_Names[j], NUMBER)) >= 0) {
d365 2
a366 1
void _nc_align_termtype(TERMTYPE *to, TERMTYPE *from)
d375 2
a376 1
    DEBUG(2, ("align_termtype to(%d:%s), from(%d:%s)", na, to->term_names, nb, from->term_names));
d380 3
a382 3
	 && (to->ext_Booleans == from->ext_Booleans)
	 && (to->ext_Numbers  == from->ext_Numbers)
	 && (to->ext_Strings  == from->ext_Strings)) {
d398 1
a398 1
	ext_Names = typeMalloc(char *, na+nb);
d407 20
a426 20
				    to->ext_Names,
				    to->ext_Booleans,
				    from->ext_Names,
				    from->ext_Booleans);
	ext_Numbers  = merge_names(ext_Names + ext_Booleans,
				    to->ext_Names
				    + to->ext_Booleans,
				    to->ext_Numbers,
				    from->ext_Names
				    + from->ext_Booleans,
				    from->ext_Numbers);
	ext_Strings  = merge_names(ext_Names + ext_Numbers + ext_Booleans,
				    to->ext_Names
				    + to->ext_Booleans
				    + to->ext_Numbers,
				    to->ext_Strings,
				    from->ext_Names
				    + from->ext_Booleans
				    + from->ext_Numbers,
				    from->ext_Strings);
d433 1
a433 1
	    free(to->ext_Names);
d435 2
a436 1
	    DEBUG(2, ("realigned %d extended names for '%s' (to)", NUM_EXT_NAMES(to), to->term_names));
d443 2
a444 1
	    DEBUG(2, ("realigned %d extended names for '%s' (from)", NUM_EXT_NAMES(from), from->term_names));
d450 2
a451 1
void _nc_copy_termtype(TERMTYPE *dst, TERMTYPE *src)
d455 4
a458 4
    *dst = *src;	/* ...to copy the sizes and string-tables */
    dst->Booleans = typeMalloc(char,   NUM_BOOLEANS(dst));
    dst->Numbers  = typeMalloc(short,  NUM_NUMBERS(dst));
    dst->Strings  = typeMalloc(char *, NUM_STRINGS(dst));
d461 1
a461 1
    for_each_boolean(i,dst)
d463 1
a463 1
    for_each_number(i,dst)
d465 1
a465 1
    for_each_string(i,dst)
d476 2
@


1.1
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
MODULE_ID("$Id: alloc_ttype.c,v 1.6 1999/03/01 22:10:44 tom Exp $")
@

