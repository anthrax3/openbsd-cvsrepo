head	1.8;
access;
symbols
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.32
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.28
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.24
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.26
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.18
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.12
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.4.0.14
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.12
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.10
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.8
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.20.03.40.06;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.17.19.16.59;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.06.27.08.14.21;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.03.15.19.12.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.06.23.28;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.14;	author millert;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 *	comp_hash.c --- Routines to deal with the hashtable of capability
 *			names.
 *
 */

#define USE_TERMLIB 1
#include <curses.priv.h>

#include <tic.h>
#include <hashsize.h>

#ifdef MAIN_PROGRAM
#include <ctype.h>
#undef  DEBUG
#define DEBUG(level, params)	/*nothing */
#endif

MODULE_ID("$Id: comp_hash.c,v 1.36 2008/08/16 17:06:53 tom Exp $")

static int hash_function(const char *);

/*
 *	_nc_make_hash_table()
 *
 *	Takes the entries in table[] and hashes them into hash_table[]
 *	by name.  There are CAPTABSIZE entries in table[] and HASHTABSIZE
 *	slots in hash_table[].
 *
 */

#ifdef MAIN_PROGRAM

#undef MODULE_ID
#define MODULE_ID(id)		/*nothing */
#include <tinfo/doalloc.c>

static void
_nc_make_hash_table(struct name_table_entry *table,
		    short *hash_table)
{
    short i;
    int hashvalue;
    int collisions = 0;

    for (i = 0; i < HASHTABSIZE; i++) {
	hash_table[i] = -1;
    }
    for (i = 0; i < CAPTABSIZE; i++) {
	hashvalue = hash_function(table[i].nte_name);

	if (hash_table[hashvalue] >= 0)
	    collisions++;

	if (hash_table[hashvalue] != 0)
	    table[i].nte_link = hash_table[hashvalue];
	hash_table[hashvalue] = i;
    }

    DEBUG(4, ("Hash table complete: %d collisions out of %d entries",
	      collisions, CAPTABSIZE));
}
#endif

/*
 *	int hash_function(string)
 *
 *	Computes the hashing function on the given string.
 *
 *	The current hash function is the sum of each consectutive pair
 *	of characters, taken as two-byte integers, mod HASHTABSIZE.
 *
 */

static int
hash_function(const char *string)
{
    long sum = 0;

    DEBUG(9, ("hashing %s", string));
    while (*string) {
	sum += (long) (*string + (*(string + 1) << 8));
	string++;
    }

    DEBUG(9, ("sum is %ld", sum));
    return (int) (sum % HASHTABSIZE);
}

/*
 *	struct name_table_entry *
 *	find_entry(string)
 *
 *	Finds the entry for the given string in the hash table if present.
 *	Returns a pointer to the entry in the table or 0 if not found.
 *
 */

#ifndef MAIN_PROGRAM
NCURSES_EXPORT(struct name_table_entry const *)
_nc_find_entry(const char *string,
	       const short *hash_table)
{
    int hashvalue;
    struct name_table_entry const *ptr = 0;
    struct name_table_entry const *real_table;

    hashvalue = hash_function(string);

    if (hash_table[hashvalue] >= 0) {
	real_table = _nc_get_table(hash_table != _nc_get_hash_table(FALSE));
	ptr = real_table + hash_table[hashvalue];
	while (strcmp(ptr->nte_name, string) != 0) {
	    if (ptr->nte_link < 0)
		return 0;
	    ptr = real_table + (ptr->nte_link + hash_table[HASHTABSIZE]);
	}
    }

    return (ptr);
}

/*
 *	struct name_table_entry *
 *	find_type_entry(string, type, table)
 *
 *	Finds the first entry for the given name with the given type in the
 *	given table if present (as distinct from find_entry, which finds the
 *	the last entry regardless of type).  You can use this if you detect
 *	a name clash.  It's slower, though.  Returns a pointer to the entry
 *	in the table or 0 if not found.
 */

NCURSES_EXPORT(struct name_table_entry const *)
_nc_find_type_entry(const char *string,
		    int type,
		    const struct name_table_entry *table)
{
    struct name_table_entry const *ptr;

    for (ptr = table; ptr < table + CAPTABSIZE; ptr++) {
	if (ptr->nte_type == type && strcmp(string, ptr->nte_name) == 0)
	    return (ptr);
    }

    return ((struct name_table_entry *) NULL);
}
#endif

#ifdef MAIN_PROGRAM
/*
 * This filter reads from standard input a list of tab-delimited columns,
 * (e.g., from Caps.filtered) computes the hash-value of a specified column and
 * writes the hashed tables to standard output.
 *
 * By compiling the hash table at build time, we're able to make the entire
 * set of terminfo and termcap tables readonly (and also provide some runtime
 * performance enhancement).
 */

#define MAX_COLUMNS BUFSIZ	/* this _has_ to be worst-case */

static char **
parse_columns(char *buffer)
{
    static char **list;

    int col = 0;

    if (list == 0 && (list = typeCalloc(char *, MAX_COLUMNS)) == 0)
	  return (0);

    if (*buffer != '#') {
	while (*buffer != '\0') {
	    char *s;
	    for (s = buffer; (*s != '\0') && !isspace(UChar(*s)); s++)
		/*EMPTY */ ;
	    if (s != buffer) {
		char mark = *s;
		*s = '\0';
		if ((s - buffer) > 1
		    && (*buffer == '"')
		    && (s[-1] == '"')) {	/* strip the quotes */
		    assert(s > buffer + 1);
		    s[-1] = '\0';
		    buffer++;
		}
		list[col] = buffer;
		col++;
		if (mark == '\0')
		    break;
		while (*++s && isspace(UChar(*s)))
		    /*EMPTY */ ;
		buffer = s;
	    } else
		break;
	}
    }
    return col ? list : 0;
}

int
main(int argc, char **argv)
{
    struct name_table_entry *name_table = typeCalloc(struct
						     name_table_entry, CAPTABSIZE);
    short *hash_table = typeCalloc(short, HASHTABSIZE);
    const char *root_name = "";
    int column = 0;
    int bigstring = 0;
    int n;
    char buffer[BUFSIZ];

    static const char *typenames[] =
    {"BOOLEAN", "NUMBER", "STRING"};

    short BoolCount = 0;
    short NumCount = 0;
    short StrCount = 0;

    /* The first argument is the column-number (starting with 0).
     * The second is the root name of the tables to generate.
     */
    if (argc <= 3
	|| (column = atoi(argv[1])) <= 0
	|| (column >= MAX_COLUMNS)
	|| *(root_name = argv[2]) == 0
	|| (bigstring = atoi(argv[3])) < 0
	|| name_table == 0
	|| hash_table == 0) {
	fprintf(stderr, "usage: make_hash column root_name bigstring\n");
	exit(EXIT_FAILURE);
    }

    /*
     * Read the table into our arrays.
     */
    for (n = 0; (n < CAPTABSIZE) && fgets(buffer, BUFSIZ, stdin);) {
	char **list, *nlp = strchr(buffer, '\n');
	if (nlp)
	    *nlp = '\0';
	list = parse_columns(buffer);
	if (list == 0)		/* blank or comment */
	    continue;
	name_table[n].nte_link = -1;	/* end-of-hash */
	name_table[n].nte_name = strdup(list[column]);
	if (!strcmp(list[2], "bool")) {
	    name_table[n].nte_type = BOOLEAN;
	    name_table[n].nte_index = BoolCount++;
	} else if (!strcmp(list[2], "num")) {
	    name_table[n].nte_type = NUMBER;
	    name_table[n].nte_index = NumCount++;
	} else if (!strcmp(list[2], "str")) {
	    name_table[n].nte_type = STRING;
	    name_table[n].nte_index = StrCount++;
	} else {
	    fprintf(stderr, "Unknown type: %s\n", list[2]);
	    exit(EXIT_FAILURE);
	}
	n++;
    }
    _nc_make_hash_table(name_table, hash_table);

    /*
     * Write the compiled tables to standard output
     */
    if (bigstring) {
	int len = 0;
	int nxt;

	printf("static const char %s_names_text[] = \\\n", root_name);
	for (n = 0; n < CAPTABSIZE; n++) {
	    nxt = (int) strlen(name_table[n].nte_name) + 5;
	    if (nxt + len > 72) {
		printf("\\\n");
		len = 0;
	    }
	    printf("\"%s\\0\" ", name_table[n].nte_name);
	    len += nxt;
	}
	printf(";\n\n");

	len = 0;
	printf("static name_table_data const %s_names_data[] =\n",
	       root_name);
	printf("{\n");
	for (n = 0; n < CAPTABSIZE; n++) {
	    printf("\t{ %15d,\t%10s,\t%3d, %3d }%c\n",
		   len,
		   typenames[name_table[n].nte_type],
		   name_table[n].nte_index,
		   name_table[n].nte_link,
		   n < CAPTABSIZE - 1 ? ',' : ' ');
	    len += (int) strlen(name_table[n].nte_name) + 1;
	}
	printf("};\n\n");
	printf("static struct name_table_entry *_nc_%s_table = 0;\n\n", root_name);
    } else {

	printf("static struct name_table_entry %s _nc_%s_table[] =\n",
	       bigstring ? "" : "const",
	       root_name);
	printf("{\n");
	for (n = 0; n < CAPTABSIZE; n++) {
	    snprintf(buffer, sizeof(buffer), "\"%s\"",
		    name_table[n].nte_name);
	    printf("\t{ %15s,\t%10s,\t%3d, %3d }%c\n",
		   buffer,
		   typenames[name_table[n].nte_type],
		   name_table[n].nte_index,
		   name_table[n].nte_link,
		   n < CAPTABSIZE - 1 ? ',' : ' ');
	}
	printf("};\n\n");
    }

    printf("static const short _nc_%s_hash_table[%d] =\n",
	   root_name,
	   HASHTABSIZE + 1);
    printf("{\n");
    for (n = 0; n < HASHTABSIZE; n++) {
	printf("\t%3d,\n", hash_table[n]);
    }
    printf("\t0\t/* base-of-table */\n");
    printf("};\n\n");

    printf("#if (BOOLCOUNT!=%d)||(NUMCOUNT!=%d)||(STRCOUNT!=%d)\n",
	   BoolCount, NumCount, StrCount);
    printf("#error\t--> term.h and comp_captab.c disagree about the <--\n");
    printf("#error\t--> numbers of booleans, numbers and/or strings <--\n");
    printf("#endif\n\n");

    free(hash_table);
    return EXIT_SUCCESS;
}
#endif
@


1.7
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_hash.c,v 1.6 2003/03/18 16:55:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d34 1
a36 1

d43 1
d52 1
a52 1
#define DEBUG(level, params) /*nothing*/
d55 1
a55 1
MODULE_ID("$From: comp_hash.c,v 1.21 1999/06/26 21:25:11 tom Exp $")
d57 1
a57 1
static  int hash_function(const char *);
d71 1
a71 1
#define MODULE_ID(id) /*nothing*/
d74 3
a76 2
static void _nc_make_hash_table(struct name_table_entry *table,
		     struct name_table_entry **hash_table)
d78 17
a94 14
int	i;
int	hashvalue;
int	collisions = 0;

	for (i = 0; i < CAPTABSIZE; i++) {
	    hashvalue = hash_function(table[i].nte_name);

	    if (hash_table[hashvalue] != (struct name_table_entry *) 0)
		collisions++;

	    if (hash_table[hashvalue] != 0)
		table[i].nte_link = (short)(hash_table[hashvalue] - table);
	    hash_table[hashvalue] = &table[i];
	}
d96 2
a97 1
	DEBUG(4, ("Hash table complete: %d collisions out of %d entries", collisions, CAPTABSIZE));
a100 1

d107 1
a107 1
 *	of characters, taken as two-byte integers, mod Hashtabsize.
d111 1
a111 2
static
int
d114 1
a114 1
long	sum = 0;
d116 5
a120 5
	DEBUG(9, ("hashing %s", string));
	while (*string) {
	    sum += (long)(*string + (*(string + 1) << 8));
	    string++;
	}
d122 2
a123 2
	DEBUG(9, ("sum is %ld", sum));
	return (int)(sum % HASHTABSIZE);
a125 1

d136 3
a138 2
struct name_table_entry const *
_nc_find_entry(const char *string, const struct name_table_entry *const *hash_table)
d140 13
a152 11
int	hashvalue;
struct name_table_entry	const *ptr;

	hashvalue = hash_function(string);

	if ((ptr = hash_table[hashvalue]) != 0) {
		while (strcmp(ptr->nte_name, string) != 0) {
			if (ptr->nte_link < 0)
				return 0;
			ptr = ptr->nte_link + hash_table[HASHTABSIZE];
		}
d154 1
d156 1
a156 1
	return (ptr);
d170 1
a170 1
struct name_table_entry const *
d175 1
a175 1
struct name_table_entry	const *ptr;
d177 4
a180 4
	for (ptr = table; ptr < table + CAPTABSIZE; ptr++) {
	    if (ptr->nte_type == type && strcmp(string, ptr->nte_name) == 0)
		return(ptr);
	}
d182 1
a182 1
	return ((struct name_table_entry *)NULL);
d199 2
a200 1
static char **parse_columns(char *buffer)
d202 1
a202 1
	static char **list;
d204 1
a204 1
	int col = 0;
d206 2
a207 2
	if (list == 0 && (list = typeCalloc(char *, MAX_COLUMNS)) == 0)
		return(0);
d209 14
a222 23
	if (*buffer != '#') {
		while (*buffer != '\0') {
			char *s;
			for (s = buffer; (*s != '\0') && !isspace(*s); s++)
				/*EMPTY*/;
			if (s != buffer) {
				char mark = *s;
				*s = '\0';
				if ((s - buffer) > 1
				 && (*buffer == '"')
				 && (s[-1] == '"')) {	/* strip the quotes */
					buffer++;
					s[-1] = '\0';
				}
				list[col] = buffer;
				col++;
				if (mark == '\0')
					break;
				while (isspace(*++s))
					/*EMPTY*/;
				buffer = s;
			} else
				break;
d224 9
d234 2
a235 1
	return col ? list : 0;
d238 2
a239 1
int main(int argc, char **argv)
d241 54
a294 22
	struct name_table_entry *name_table = typeCalloc(struct name_table_entry, CAPTABSIZE);
	struct name_table_entry **hash_table = typeCalloc(struct name_table_entry *, HASHTABSIZE);
	const char *root_name = "";
	int  column = 0;
	int  n;
	char buffer[BUFSIZ];

	static const char * typenames[] = { "BOOLEAN", "NUMBER", "STRING" };

	short BoolCount = 0;
	short NumCount  = 0;
	short StrCount  = 0;

	/* The first argument is the column-number (starting with 0).
	 * The second is the root name of the tables to generate.
	 */
	if (argc <= 2
	 || (column = atoi(argv[1])) <= 0
	 || (column >= MAX_COLUMNS)
	 || *(root_name = argv[2]) == 0) {
		fprintf(stderr, "usage: make_hash column root_name\n");
		exit(EXIT_FAILURE);
d296 10
d307 9
a315 26
	/*
	 * Read the table into our arrays.
	 */
	for (n = 0; (n < CAPTABSIZE) && fgets(buffer, BUFSIZ, stdin); ) {
		char **list, *nlp = strchr(buffer, '\n');
		if (nlp)
		    *nlp = '\0';
		list = parse_columns(buffer);
		if (list == 0)	/* blank or comment */
		    continue;
		name_table[n].nte_link = -1;	/* end-of-hash */
		name_table[n].nte_name = strdup(list[column]);
		if (!strcmp(list[2], "bool")) {
			name_table[n].nte_type  = BOOLEAN;
			name_table[n].nte_index = BoolCount++;
		} else if (!strcmp(list[2], "num")) {
			name_table[n].nte_type  = NUMBER;
			name_table[n].nte_index = NumCount++;
		} else if (!strcmp(list[2], "str")) {
			name_table[n].nte_type  = STRING;
			name_table[n].nte_index = StrCount++;
		} else {
			fprintf(stderr, "Unknown type: %s\n", list[2]);
			exit(EXIT_FAILURE);
		}
		n++;
d317 1
a317 1
	_nc_make_hash_table(name_table, hash_table);
d319 3
a321 5
	/*
	 * Write the compiled tables to standard output
	 */
	printf("static struct name_table_entry const _nc_%s_table[] =\n",
		root_name);
d324 7
a330 8
		snprintf(buffer, sizeof(buffer), "\"%s\"",
			 name_table[n].nte_name);
		printf("\t{ %15s,\t%10s,\t%3d, %3d }%c\n",
			buffer,
			typenames[name_table[n].nte_type],
			name_table[n].nte_index,
			name_table[n].nte_link,
			n < CAPTABSIZE - 1 ? ',' : ' ');
d333 2
d336 3
a338 3
	printf("const struct name_table_entry * const _nc_%s_hash_table[%d] =\n",
		root_name,
		HASHTABSIZE+1);
d340 9
a348 10
	for (n = 0; n < HASHTABSIZE; n++) {
		if (hash_table[n] != 0) {
			snprintf(buffer, sizeof(buffer), "_nc_%s_table + %3ld",
				 root_name,
				(long) (hash_table[n] - name_table));
		} else {
			buffer[0] = '0';
			buffer[1] = '\0';
		}
		printf("\t%s,\n", buffer);
a349 1
	printf("\t_nc_%s_table\t/* base-of-table */\n", root_name);
d351 1
d353 15
a367 5
	printf("#if (BOOLCOUNT!=%d)||(NUMCOUNT!=%d)||(STRCOUNT!=%d)\n",
		BoolCount, NumCount, StrCount);
	printf("#error\t--> term.h and comp_captab.c disagree about the <--\n");
	printf("#error\t--> numbers of booleans, numbers and/or strings <--\n");
	printf("#endif\n\n");
d369 2
a370 1
	return EXIT_SUCCESS;
@


1.6
log
@Use strlcpy() / strlcat() throughout.
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_hash.c,v 1.5 2003/03/17 19:16:59 millert Exp $	*/
d219 1
a219 1
				while (*++s && isspace(*s))
@


1.5
log
@use snprintf throughout
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_hash.c,v 1.4 1999/06/27 08:14:21 millert Exp $	*/
d312 2
a313 1
			strcpy(buffer, "0");
@


1.4
log
@ncurses-5.0-990626
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_hash.c,v 1.3 1999/03/15 19:12:22 millert Exp $	*/
d291 2
a292 2
		sprintf(buffer, "\"%s\"",
			name_table[n].nte_name);
d308 2
a309 2
			sprintf(buffer, "_nc_%s_table + %3ld",
				root_name,
@


1.3
log
@ncurses-4.2-990314
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_hash.c,v 1.2 1999/03/02 06:23:28 millert Exp $	*/
d54 1
a54 1
MODULE_ID("$From: comp_hash.c,v 1.20 1999/03/14 12:23:26 tom Exp $")
d69 2
a70 1
#undef USE_RCS_IDS
@


1.2
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_hash.c,v 1.1 1999/01/18 19:10:14 millert Exp $	*/
d54 1
a54 1
MODULE_ID("$From: comp_hash.c,v 1.19 1999/02/22 22:49:43 tom Exp $")
d68 4
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_hash.c,v 1.2 1998/09/13 19:16:15 millert Exp $	*/
d54 1
a54 1
MODULE_ID("$From: comp_hash.c,v 1.18 1998/08/22 18:01:18 tom Exp $")
a183 12

#if !HAVE_STRDUP
static char *strdup (char *s)
{
  char *p;

  p = malloc(strlen(s)+1);
  if (p)
    strcpy(p,s);
  return(p);
}
#endif /* not HAVE_STRDUP */
@

