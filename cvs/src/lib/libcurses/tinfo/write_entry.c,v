head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.28
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.24
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.26
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.18
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.22
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.20
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.30
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.26
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.24
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.22
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.20
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.18
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.16
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.14
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.12
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.10
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.8
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.10.0.8
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.17.19.16.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.22.18.01.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.08.22.47.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.13.23.53.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.10.01.35.04;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.02.22.06.51;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.12.06.02.12.46;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.07.11.14.10.11;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.03.11.21.03.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.06.23.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.23;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 *	write_entry.c -- write a terminfo structure onto the file system
 */

#include <curses.priv.h>
#include <hashed_db.h>

#include <sys/stat.h>

#include <tic.h>
#include <term_entry.h>

#ifndef S_ISDIR
#define S_ISDIR(mode) ((mode & S_IFMT) == S_IFDIR)
#endif

#if 1
#define TRACE_OUT(p) DEBUG(2, p)
#else
#define TRACE_OUT(p)		/*nothing */
#endif

MODULE_ID("$Id: write_entry.c,v 1.72 2008/08/03 19:24:00 tom Exp $")

static int total_written;

static int make_db_root(const char *);
static int write_object(TERMTYPE *, char *, unsigned *, unsigned);

#if !USE_HASHED_DB
static void
write_file(char *filename, TERMTYPE *tp)
{
    char buffer[MAX_ENTRY_SIZE];
    unsigned limit = sizeof(buffer);
    unsigned offset = 0;

    FILE *fp = (_nc_access(filename, W_OK) == 0) ? fopen(filename, "wb") : 0;
    if (fp == 0) {
	perror(filename);
	_nc_syserr_abort("can't open %s/%s", _nc_tic_dir(0), filename);
    }
    DEBUG(1, ("Created %s", filename));

    if (write_object(tp, buffer, &offset, limit) == ERR
	|| fwrite(buffer, sizeof(char), offset, fp) != offset) {
	_nc_syserr_abort("error writing %s/%s", _nc_tic_dir(0), filename);
    }

    fclose(fp);
}

/*
 * Check for access rights to destination directories
 * Create any directories which don't exist.
 *
 * Note:  there's no reason to return the result of make_db_root(), since
 * this function is called only in instances where that has to succeed.
 */
static void
check_writeable(int code)
{
    static const char dirnames[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    static bool verified[sizeof(dirnames)];

    char dir[sizeof(LEAF_FMT)];
    char *s = 0;

    if (code == 0 || (s = strchr(dirnames, code)) == 0)
	_nc_err_abort("Illegal terminfo subdirectory \"" LEAF_FMT "\"", code);

    if (verified[s - dirnames])
	return;

    snprintf(dir, sizeof(dir), LEAF_FMT, code);
    if (make_db_root(dir) < 0) {
	_nc_err_abort("%s/%s: permission denied", _nc_tic_dir(0), dir);
    }

    verified[s - dirnames] = TRUE;
}
#endif /* !USE_HASHED_DB */

static int
make_db_path(char *dst, const char *src, unsigned limit)
{
    int rc = -1;
    const char *top = _nc_tic_dir(0);

    if (src == top || _nc_is_abs_path(src)) {
	if (strlen(src) + 1 <= limit) {
		(void) strlcpy(dst, src, limit);
	    rc = 0;
	}
    } else {
	if (strlen(top) + strlen(src) + 2 <= limit) {
		(void) snprintf(dst, limit, "%s/%s", top, src);
	    rc = 0;
	}
    }
#if USE_HASHED_DB
    if (rc == 0) {
	if (_nc_is_dir_path(dst)) {
	    rc = -1;
	} else {
	    unsigned have = strlen(dst);
	    if (have > 3 && strcmp(dst + have - 3, DBM_SUFFIX)) {
		if (have + 3 <= limit)
		    strlcat(dst, DBM_SUFFIX, limit);
		else
		    rc = -1;
	    }
	}
    }
#endif
    return rc;
}

/*
 * Make a database-root if it doesn't exist.
 */
static int
make_db_root(const char *path)
{
    int rc;
    char fullpath[PATH_MAX];

    if ((rc = make_db_path(fullpath, path, sizeof(fullpath))) == 0) {
#if USE_HASHED_DB
	DB *capdbp;

	if ((capdbp = _nc_db_open(fullpath, TRUE)) == NULL)
	    rc = -1;
	else if (_nc_db_close(capdbp) < 0)
	    rc = -1;
#else
	struct stat statbuf;

	if ((rc = stat(path, &statbuf)) < 0) {
	    rc = mkdir(path, 0777);
	} else if (_nc_access(path, R_OK | W_OK | X_OK) < 0) {
	    rc = -1;		/* permission denied */
	} else if (!(S_ISDIR(statbuf.st_mode))) {
	    rc = -1;		/* not a directory */
	}
#endif
    }
    return rc;
}

/*
 * Set the write directory for compiled entries.
 */
NCURSES_EXPORT(void)
_nc_set_writedir(char *dir)
{
    const char *destination;
    char actual[PATH_MAX];

    if (dir == 0
	&& use_terminfo_vars())
	dir = getenv("TERMINFO");

    if (dir != 0)
	(void) _nc_tic_dir(dir);

    destination = _nc_tic_dir(0);
    if (make_db_root(destination) < 0) {
	char *home = _nc_home_terminfo();

	if (home != 0) {
	    destination = home;
	    if (make_db_root(destination) < 0)
		_nc_err_abort("%s: permission denied (errno %d)",
			      destination, errno);
	}
    }

    /*
     * Note: because of this code, this logic should be exercised
     * *once only* per run.
     */
#if USE_HASHED_DB
    make_db_path(actual, destination, sizeof(actual));
#else
    if (chdir(_nc_tic_dir(destination)) < 0
	|| getcwd(actual, sizeof(actual)) == 0)
	_nc_err_abort("%s: not a directory", destination);
#endif
    _nc_keep_tic_dir(strdup(actual));
}

/*
 *	Save the compiled version of a description in the filesystem.
 *
 *	make a copy of the name-list
 *	break it up into first-name and all-but-last-name
 *	creat(first-name)
 *	write object information to first-name
 *	close(first-name)
 *      for each name in all-but-last-name
 *	    link to first-name
 *
 *	Using 'time()' to obtain a reference for file timestamps is unreliable,
 *	e.g., with NFS, because the filesystem may have a different time
 *	reference.  We check for pre-existence of links by latching the first
 *	timestamp from a file that we create.
 *
 *	The _nc_warning() calls will report a correct line number only if
 *	_nc_curr_line is properly set before the write_entry() call.
 */

NCURSES_EXPORT(void)
_nc_write_entry(TERMTYPE *const tp)
{
#if USE_HASHED_DB

    char buffer[MAX_ENTRY_SIZE + 1];
    unsigned limit = sizeof(buffer);
    unsigned offset = 0;

#else /* !USE_HASHED_DB */

    struct stat statbuf;
    char filename[PATH_MAX];
    char linkname[PATH_MAX];
#if USE_SYMLINKS
    char symlinkname[PATH_MAX];
#if !HAVE_LINK
#undef HAVE_LINK
#define HAVE_LINK 1
#endif
#endif /* USE_SYMLINKS */

    static int call_count;
    static time_t start_time;	/* time at start of writes */

#endif /* USE_HASHED_DB */

    char name_list[MAX_TERMINFO_LENGTH];
    char *first_name, *other_names;
    char *ptr;

    assert(strlen(tp->term_names) != 0);
    assert(strlen(tp->term_names) < sizeof(name_list));

    (void) strlcpy(name_list, tp->term_names, sizeof(name_list));
    DEBUG(7, ("Name list = '%s'", name_list));

    first_name = name_list;

    ptr = &name_list[strlen(name_list) - 1];
    other_names = ptr + 1;

    while (ptr > name_list && *ptr != '|')
	ptr--;

    if (ptr != name_list) {
	*ptr = '\0';

	for (ptr = name_list; *ptr != '\0' && *ptr != '|'; ptr++)
	    continue;

	if (*ptr == '\0')
	    other_names = ptr;
	else {
	    *ptr = '\0';
	    other_names = ptr + 1;
	}
    }

    DEBUG(7, ("First name = '%s'", first_name));
    DEBUG(7, ("Other names = '%s'", other_names));

    _nc_set_type(first_name);

#if USE_HASHED_DB
    if (write_object(tp, buffer + 1, &offset, limit - 1) != ERR) {
	DB *capdb = _nc_db_open(_nc_tic_dir(0), TRUE);
	DBT key, data;

	if (capdb != 0) {
	    buffer[0] = 0;

	    memset(&key, 0, sizeof(key));
	    key.data = tp->term_names;
	    key.size = strlen(tp->term_names);

	    memset(&data, 0, sizeof(data));
	    data.data = buffer;
	    data.size = offset + 1;

	    _nc_db_put(capdb, &key, &data);

	    buffer[0] = 2;

	    key.data = name_list;
	    key.size = strlen(name_list);

	    strlcpy(buffer + 1, tp->term_names, sizeof(buffer) - 1);
	    data.size = strlen(tp->term_names) + 1;

	    _nc_db_put(capdb, &key, &data);

	    while (*other_names != '\0') {
		ptr = other_names++;
		while (*other_names != '|' && *other_names != '\0')
		    other_names++;

		if (*other_names != '\0')
		    *(other_names++) = '\0';

		key.data = ptr;
		key.size = strlen(ptr);

		_nc_db_put(capdb, &key, &data);
	    }
	    _nc_db_close(capdb);
	}
    }
#else /* !USE_HASHED_DB */
    if (call_count++ == 0) {
	start_time = 0;
    }

    if (strlen(first_name) >= sizeof(filename) - 3)
	_nc_warning("terminal name too long.");

    snprintf(filename, sizeof(filename), LEAF_FMT "/%s", first_name[0], first_name);

    /*
     * Has this primary name been written since the first call to
     * write_entry()?  If so, the newer write will step on the older,
     * so warn the user.
     */
    if (start_time > 0 &&
	stat(filename, &statbuf) >= 0
	&& statbuf.st_mtime >= start_time) {
	_nc_warning("name multiply defined.");
    }

    check_writeable(first_name[0]);
    write_file(filename, tp);

    if (start_time == 0) {
	if (stat(filename, &statbuf) < 0
	    || (start_time = statbuf.st_mtime) == 0) {
	    _nc_syserr_abort("error obtaining time from %s/%s",
			     _nc_tic_dir(0), filename);
	}
    }
    while (*other_names != '\0') {
	ptr = other_names++;
	assert(ptr < buffer + sizeof(buffer) - 1);
	while (*other_names != '|' && *other_names != '\0')
	    other_names++;

	if (*other_names != '\0')
	    *(other_names++) = '\0';

	if (strlen(ptr) > sizeof(linkname) - 3) {
	    _nc_warning("terminal alias %s too long.", ptr);
	    continue;
	}
	if (strchr(ptr, '/') != 0) {
	    _nc_warning("cannot link alias %s.", ptr);
	    continue;
	}

	check_writeable(ptr[0]);
	snprintf(linkname, sizeof(linkname), LEAF_FMT "/%s", ptr[0], ptr);

	if (strcmp(filename, linkname) == 0) {
	    _nc_warning("self-synonym ignored");
	} else if (stat(linkname, &statbuf) >= 0 &&
		   statbuf.st_mtime < start_time) {
	    _nc_warning("alias %s multiply defined.", ptr);
	} else if (_nc_access(linkname, W_OK) == 0)
#if HAVE_LINK
	{
	    int code;
#if USE_SYMLINKS
            strlcpy(symlinkname, "../", sizeof(symlinkname));
            strlcat(symlinkname, filename, sizeof(symlinkname));
#endif /* USE_SYMLINKS */
#if HAVE_REMOVE
	    code = remove(linkname);
#else
	    code = unlink(linkname);
#endif
	    if (code != 0 && errno == ENOENT)
		code = 0;
#if USE_SYMLINKS
	    if (symlink(symlinkname, linkname) < 0)
#else
	    if (link(filename, linkname) < 0)
#endif /* USE_SYMLINKS */
	    {
		/*
		 * If there wasn't anything there, and we cannot
		 * link to the target because it is the same as the
		 * target, then the source must be on a filesystem
		 * that uses caseless filenames, such as Win32, etc.
		 */
		if (code == 0 && errno == EEXIST)
		    _nc_warning("can't link %s to %s", filename, linkname);
		else if (code == 0 && (errno == EPERM || errno == ENOENT))
		    write_file(linkname, tp);
		else {
#if MIXEDCASE_FILENAMES
		    _nc_syserr_abort("can't link %s to %s", filename, linkname);
#else
		    _nc_warning("can't link %s to %s (errno=%d)", filename,
				linkname, errno);
#endif
		}
	    } else {
		DEBUG(1, ("Linked %s", linkname));
	    }
	}
#else /* just make copies */
	    write_file(linkname, tp);
#endif /* HAVE_LINK */
    }
#endif /* USE_HASHED_DB */
}

static unsigned
fake_write(char *dst,
	   unsigned *offset,
	   unsigned limit,
	   char *src,
	   unsigned want,
	   unsigned size)
{
    int have = (limit - *offset);

    want *= size;
    if (have > 0) {
	if ((int) want > have)
	    want = have;
	memcpy(dst + *offset, src, want);
	*offset += want;
    } else {
	want = 0;
    }
    return (int) (want / size);
}

#define Write(buf, size, count) fake_write(buffer, offset, limit, (char *) buf, count, size)

#undef LITTLE_ENDIAN		/* BSD/OS defines this as a feature macro */
#define HI(x)			((x) / 256)
#define LO(x)			((x) % 256)
#define LITTLE_ENDIAN(p, x)	(p)[0] = LO(x), (p)[1] = HI(x)

#define WRITE_STRING(str) (Write(str, sizeof(char), strlen(str) + 1) == strlen(str) + 1)

static int
compute_offsets(char **Strings, unsigned strmax, short *offsets)
{
    size_t nextfree = 0;
    unsigned i;

    for (i = 0; i < strmax; i++) {
	if (Strings[i] == ABSENT_STRING) {
	    offsets[i] = -1;
	} else if (Strings[i] == CANCELLED_STRING) {
	    offsets[i] = -2;
	} else {
	    offsets[i] = nextfree;
	    nextfree += strlen(Strings[i]) + 1;
	    TRACE_OUT(("put Strings[%d]=%s(%d)", (int) i,
		       _nc_visbuf(Strings[i]), (int) nextfree));
	}
    }
    return nextfree;
}

static void
convert_shorts(unsigned char *buf, short *Numbers, unsigned count)
{
    unsigned i;
    for (i = 0; i < count; i++) {
	if (Numbers[i] == ABSENT_NUMERIC) {	/* HI/LO won't work */
	    buf[2 * i] = buf[2 * i + 1] = 0377;
	} else if (Numbers[i] == CANCELLED_NUMERIC) {	/* HI/LO won't work */
	    buf[2 * i] = 0376;
	    buf[2 * i + 1] = 0377;
	} else {
	    LITTLE_ENDIAN(buf + 2 * i, Numbers[i]);
	    TRACE_OUT(("put Numbers[%d]=%d", i, Numbers[i]));
	}
    }
}

#define even_boundary(value) \
	    ((value) % 2 != 0 && Write(&zero, sizeof(char), 1) != 1)

#if NCURSES_XNAMES
static unsigned
extended_Booleans(TERMTYPE *tp)
{
    unsigned short result = 0;
    unsigned short i;

    for (i = 0; i < tp->ext_Booleans; ++i) {
	if (tp->Booleans[BOOLCOUNT + i] == TRUE)
	    result = (i + 1);
    }
    return result;
}

static unsigned
extended_Numbers(TERMTYPE *tp)
{
    unsigned short result = 0;
    unsigned short i;

    for (i = 0; i < tp->ext_Numbers; ++i) {
	if (tp->Numbers[NUMCOUNT + i] != ABSENT_NUMERIC)
	    result = (i + 1);
    }
    return result;
}

static unsigned
extended_Strings(TERMTYPE *tp)
{
    unsigned short result = 0;
    unsigned short i;

    for (i = 0; i < tp->ext_Strings; ++i) {
	if (tp->Strings[STRCOUNT + i] != ABSENT_STRING)
	    result = (i + 1);
    }
    return result;
}

/*
 * _nc_align_termtype() will extend entries that are referenced in a use=
 * clause - discard the unneeded data.
 */
static bool
extended_object(TERMTYPE *tp)
{
    bool result = FALSE;

    if (_nc_user_definable) {
	result = ((extended_Booleans(tp)
		   + extended_Numbers(tp)
		   + extended_Strings(tp)) != 0);
    }
    return result;
}
#endif

static int
write_object(TERMTYPE *tp, char *buffer, unsigned *offset, unsigned limit)
{
    char *namelist;
    size_t namelen, boolmax, nummax, strmax;
    char zero = '\0';
    size_t i;
    short nextfree;
    short offsets[MAX_ENTRY_SIZE / 2];
    unsigned char buf[MAX_ENTRY_SIZE];
    unsigned last_bool = BOOLWRITE;
    unsigned last_num = NUMWRITE;
    unsigned last_str = STRWRITE;

#if NCURSES_XNAMES
    /*
     * Normally we limit the list of values to exclude the "obsolete"
     * capabilities.  However, if we are accepting extended names, add
     * these as well, since they are used for supporting translation
     * to/from termcap.
     */
    if (_nc_user_definable) {
	last_bool = BOOLCOUNT;
	last_num = NUMCOUNT;
	last_str = STRCOUNT;
    }
#endif

    namelist = tp->term_names;
    namelen = strlen(namelist) + 1;

    boolmax = 0;
    for (i = 0; i < last_bool; i++) {
	if (tp->Booleans[i] == TRUE)
	    boolmax = i + 1;
    }

    nummax = 0;
    for (i = 0; i < last_num; i++) {
	if (tp->Numbers[i] != ABSENT_NUMERIC)
	    nummax = i + 1;
    }

    strmax = 0;
    for (i = 0; i < last_str; i++) {
	if (tp->Strings[i] != ABSENT_STRING)
	    strmax = i + 1;
    }

    nextfree = compute_offsets(tp->Strings, strmax, offsets);

    /* fill in the header */
    LITTLE_ENDIAN(buf, MAGIC);
    LITTLE_ENDIAN(buf + 2, min(namelen, MAX_NAME_SIZE + 1));
    LITTLE_ENDIAN(buf + 4, boolmax);
    LITTLE_ENDIAN(buf + 6, nummax);
    LITTLE_ENDIAN(buf + 8, strmax);
    LITTLE_ENDIAN(buf + 10, nextfree);

    /* write out the header */
    TRACE_OUT(("Header of %s @@%d", namelist, *offset));
    if (Write(buf, 12, 1) != 1
	|| Write(namelist, sizeof(char), namelen) != namelen)
	  return (ERR);

    for (i = 0; i < boolmax; i++)
	if (tp->Booleans[i] == TRUE)
	    buf[i] = TRUE;
	else
	    buf[i] = FALSE;
    if (Write(buf, sizeof(char), boolmax) != boolmax)
	  return (ERR);

    if (even_boundary(namelen + boolmax))
	return (ERR);

    TRACE_OUT(("Numerics begin at %04x", *offset));

    /* the numerics */
    convert_shorts(buf, tp->Numbers, nummax);
    if (Write(buf, 2, nummax) != nummax)
	return (ERR);

    TRACE_OUT(("String offsets begin at %04x", *offset));

    /* the string offsets */
    convert_shorts(buf, offsets, strmax);
    if (Write(buf, 2, strmax) != strmax)
	return (ERR);

    TRACE_OUT(("String table begins at %04x", *offset));

    /* the strings */
    for (i = 0; i < strmax; i++)
	if (VALID_STRING(tp->Strings[i]))
	    if (!WRITE_STRING(tp->Strings[i]))
		return (ERR);

#if NCURSES_XNAMES
    if (extended_object(tp)) {
	unsigned extcnt = NUM_EXT_NAMES(tp);

	if (even_boundary(nextfree))
	    return (ERR);

	nextfree = compute_offsets(tp->Strings + STRCOUNT,
				   tp->ext_Strings,
				   offsets);
	TRACE_OUT(("after extended string capabilities, nextfree=%d", nextfree));

	if (tp->ext_Strings >= SIZEOF(offsets))
	    return (ERR);

	nextfree += compute_offsets(tp->ext_Names,
				    extcnt,
				    offsets + tp->ext_Strings);
	TRACE_OUT(("after extended capnames, nextfree=%d", nextfree));
	strmax = tp->ext_Strings + extcnt;

	/*
	 * Write the extended header
	 */
	LITTLE_ENDIAN(buf + 0, tp->ext_Booleans);
	LITTLE_ENDIAN(buf + 2, tp->ext_Numbers);
	LITTLE_ENDIAN(buf + 4, tp->ext_Strings);
	LITTLE_ENDIAN(buf + 6, strmax);
	LITTLE_ENDIAN(buf + 8, nextfree);
	TRACE_OUT(("WRITE extended-header @@%d", *offset));
	if (Write(buf, 10, 1) != 1)
	    return (ERR);

	TRACE_OUT(("WRITE %d booleans @@%d", tp->ext_Booleans, *offset));
	if (tp->ext_Booleans
	    && Write(tp->Booleans + BOOLCOUNT, sizeof(char),
		     tp->ext_Booleans) != tp->ext_Booleans)
	      return (ERR);

	if (even_boundary(tp->ext_Booleans))
	    return (ERR);

	TRACE_OUT(("WRITE %d numbers @@%d", tp->ext_Numbers, *offset));
	if (tp->ext_Numbers) {
	    convert_shorts(buf, tp->Numbers + NUMCOUNT, tp->ext_Numbers);
	    if (Write(buf, 2, tp->ext_Numbers) != tp->ext_Numbers)
		return (ERR);
	}

	/*
	 * Convert the offsets for the ext_Strings and ext_Names tables,
	 * in that order.
	 */
	convert_shorts(buf, offsets, strmax);
	TRACE_OUT(("WRITE offsets @@%d", *offset));
	if (Write(buf, 2, strmax) != strmax)
	    return (ERR);

	/*
	 * Write the string table after the offset tables so we do not
	 * have to do anything about alignment.
	 */
	for (i = 0; i < tp->ext_Strings; i++) {
	    if (VALID_STRING(tp->Strings[i + STRCOUNT])) {
		TRACE_OUT(("WRITE ext_Strings[%d]=%s", (int) i,
			   _nc_visbuf(tp->Strings[i + STRCOUNT])));
		if (!WRITE_STRING(tp->Strings[i + STRCOUNT]))
		    return (ERR);
	    }
	}

	/*
	 * Write the extended names
	 */
	for (i = 0; i < extcnt; i++) {
	    TRACE_OUT(("WRITE ext_Names[%d]=%s", (int) i, tp->ext_Names[i]));
	    if (!WRITE_STRING(tp->ext_Names[i]))
		return (ERR);
	}

    }
#endif /* NCURSES_XNAMES */

    total_written++;
    return (OK);
}

/*
 * Returns the total number of entries written by this process
 */
NCURSES_EXPORT(int)
_nc_tic_written(void)
{
    return total_written;
}
@


1.12
log
@Use strlcpy() / strlcat() throughout.
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.11 2003/03/17 19:16:59 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d42 1
d53 1
a53 1
#if 0
d59 1
a59 1
MODULE_ID("$From: write_entry.c,v 1.56 2000/12/10 02:55:08 tom Exp $")
d63 2
a64 1
static int write_object(FILE *, TERMTYPE *);
d66 1
d68 1
a68 1
write_file(char *filename, TERMTYPE * tp)
d70 4
d81 2
a82 1
    if (write_object(fp, tp) == ERR) {
d85 1
d90 2
a91 1
 *	make_directory(char *path)
d93 2
a94 1
 *	Make a directory if it doesn't exist.
d96 24
d121 39
a159 1
make_directory(const char *path)
a161 1
    struct stat statbuf;
a162 1
    const char *destination = _nc_tic_dir(0);
d164 10
a173 8
    if (path == destination || *path == '/') {
	if (strlcpy(fullpath, path, sizeof(fullpath)) >= sizeof(fullpath))
	    return (-1);
    } else {
	if (strlen(destination) + strlen(path) + 2 > sizeof(fullpath))
	    return (-1);
	(void) snprintf(fullpath, sizeof(fullpath), "%s/%s", destination, path);
    }
d175 3
a177 4
    if ((rc = stat(path, &statbuf)) < 0) {
	rc = mkdir(path, 0777);
    } else {
	if (_nc_access(path, R_OK | W_OK | X_OK) < 0) {
d182 1
d187 3
a191 1
/* set the write directory for compiled entries */
d204 1
a204 1
    if (make_directory(destination) < 0) {
d209 1
a209 1
	    if (make_directory(destination) < 0)
d219 3
d225 1
a229 38
 *	check_writeable(char code)
 *
 *	Miscellaneous initialisations
 *
 *	Check for access rights to destination directories
 *	Create any directories which don't exist.
 *	Note: there's no reason to return the result of make_directory(), since
 *	this function is called only in instances where that has to succeed.
 *
 */

static void
check_writeable(int code)
{
    static const char dirnames[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    static bool verified[sizeof(dirnames)];

    char dir[2];
    char *s = 0;

    if (code == 0 || (s = strchr(dirnames, code)) == 0)
	_nc_err_abort("Illegal terminfo subdirectory \"%c\"", code);

    if (verified[s - dirnames])
	return;

    dir[0] = code;
    dir[1] = '\0';
    if (make_directory(dir) < 0) {
	_nc_err_abort("%s/%s: permission denied", _nc_tic_dir(0), dir);
    }

    verified[s - dirnames] = TRUE;
}

/*
 *	_nc_write_entry()
 *
d249 2
a250 2
void
_nc_write_entry(TERMTYPE * const tp)
d252 8
a260 3
    char name_list[MAX_TERMINFO_LENGTH];
    char *first_name, *other_names;
    char *ptr;
d265 4
d270 1
d274 8
a281 3
    if (call_count++ == 0) {
	start_time = 0;
    }
d313 50
a362 1
    if (strlen(first_name) > sizeof(filename) - 3)
d365 1
a365 1
    snprintf(filename, sizeof(filename), "%c/%s", first_name[0], first_name);
d390 1
d407 1
a407 1
	snprintf(linkname, sizeof(linkname), "%c/%s", ptr[0], ptr);
d419 2
a420 2
	    strlcpy(symlinkname, "../", sizeof(symlinkname));
	    strlcat(symlinkname, filename, sizeof(symlinkname));
d461 1
d464 24
d493 1
a493 1
#define WRITE_STRING(str) (fwrite(str, sizeof(char), strlen(str) + 1, fp) == strlen(str) + 1)
d496 1
a496 1
compute_offsets(char **Strings, int strmax, short *offsets)
d499 1
a499 1
    int i;
d509 2
a510 1
	    TRACE_OUT(("put Strings[%d]=%s(%d)", i, _nc_visbuf(Strings[i]), nextfree));
d517 1
a517 1
convert_shorts(unsigned char *buf, short *Numbers, int count)
d519 1
a519 1
    int i;
d534 59
a592 1
	    ((value) % 2 != 0 && fwrite(&zero, sizeof(char), 1, fp) != 1)
d595 1
a595 1
write_object(FILE * fp, TERMTYPE * tp)
d654 3
a656 3
    TRACE_OUT(("Header of %s @@%ld", namelist, ftell(fp)));
    if (fwrite(buf, 12, 1, fp) != 1
	|| fwrite(namelist, sizeof(char), namelen, fp) != namelen)
d664 1
a664 1
    if (fwrite(buf, sizeof(char), boolmax, fp) != boolmax)
d670 1
a670 1
    TRACE_OUT(("Numerics begin at %04lx", ftell(fp)));
d674 1
a674 1
    if (fwrite(buf, 2, nummax, fp) != nummax)
d677 1
a677 1
    TRACE_OUT(("String offsets begin at %04lx", ftell(fp)));
d681 1
a681 1
    if (fwrite(buf, 2, strmax, fp) != strmax)
d684 1
a684 1
    TRACE_OUT(("String table begins at %04lx", ftell(fp)));
d693 1
a693 1
    if (NUM_EXT_NAMES(tp)) {
d699 3
a701 1
	nextfree = compute_offsets(tp->Strings + STRCOUNT, tp->ext_Strings, offsets);
d703 7
a709 1
	nextfree += compute_offsets(tp->ext_Names, extcnt, offsets + tp->ext_Strings);
d721 2
a722 2
	TRACE_OUT(("WRITE extended-header @@%ld", ftell(fp)));
	if (fwrite(buf, 10, 1, fp) != 1)
d725 1
a725 1
	TRACE_OUT(("WRITE %d booleans @@%ld", tp->ext_Booleans, ftell(fp)));
d727 2
a728 2
	    && fwrite(tp->Booleans + BOOLCOUNT, sizeof(char),
		      tp->ext_Booleans, fp) != tp->ext_Booleans)
d734 1
a734 1
	TRACE_OUT(("WRITE %d numbers @@%ld", tp->ext_Numbers, ftell(fp)));
d737 1
a737 1
	    if (fwrite(buf, 2, tp->ext_Numbers, fp) != tp->ext_Numbers)
d746 2
a747 2
	TRACE_OUT(("WRITE offsets @@%ld", ftell(fp)));
	if (fwrite(buf, 2, strmax, fp) != strmax)
d756 1
a756 1
		TRACE_OUT(("WRITE ext_Strings[%d]=%s", i,
d767 1
a767 1
	    TRACE_OUT(("WRITE ext_Names[%d]=%s", i, tp->ext_Names[i]));
@


1.11
log
@use snprintf throughout
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.10 2001/01/22 18:01:57 millert Exp $	*/
d93 1
a93 1
	if (strlen(path) + 1 > sizeof(fullpath))
a94 1
	(void) strcpy(fullpath, path);
d226 1
a226 1
    (void) strcpy(name_list, tp->term_names);
d312 2
a313 3
	    strcpy(symlinkname, "../");
	    strncat(symlinkname, filename, sizeof(symlinkname) - 4);
	    symlinkname[sizeof(symlinkname) - 1] = '\0';
@


1.10
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.9 2000/10/08 22:47:03 millert Exp $	*/
d99 1
a99 1
	(void) sprintf(fullpath, "%s/%s", destination, path);
d260 1
a260 1
    sprintf(filename, "%c/%s", first_name[0], first_name);
d301 1
a301 1
	sprintf(linkname, "%c/%s", ptr[0], ptr);
@


1.9
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.8 2000/03/13 23:53:40 millert Exp $	*/
d57 1
a57 1
MODULE_ID("$From: write_entry.c,v 1.53 2000/10/04 02:32:14 tom Exp $")
d114 1
a114 1
void
d122 1
a122 1
     && use_terminfo_vars())
d136 1
a136 1
		    destination, errno);
d169 1
a169 1
    char *s;
d280 1
a280 1
		_nc_tic_dir(0), filename);
d306 1
a306 1
	    statbuf.st_mtime < start_time) {
d338 1
a338 1
		else if (code == 0 && errno == EPERM)
d340 2
a341 1
		else
d343 5
d531 1
a531 1
		tp->ext_Booleans, fp) != tp->ext_Booleans)
d560 1
a560 1
			_nc_visbuf(tp->Strings[i + STRCOUNT])));
d585 1
a585 1
int
@


1.8
log
@update to ncurses-5.0-20000311
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.7 2000/03/10 01:35:04 millert Exp $	*/
d57 1
a57 1
MODULE_ID("$From: write_entry.c,v 1.52 2000/03/11 12:23:42 tom Exp $")
d121 4
a126 2
    else if (getenv("TERMINFO") != NULL)
	(void) _nc_tic_dir(getenv("TERMINFO"));
@


1.7
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.6 2000/01/02 22:06:51 millert Exp $	*/
d57 1
a57 1
MODULE_ID("$From: write_entry.c,v 1.51 2000/02/13 01:01:26 tom Exp $")
d430 1
a430 1
	if (tp->Booleans[i])
d459 9
a467 2
	|| fwrite(namelist, sizeof(char), namelen, fp) != namelen
	|| fwrite(tp->Booleans, sizeof(char), boolmax, fp) != boolmax)
@


1.6
log
@+ corrected conversion from terminfo rs2 to termcap rs (cf: 980704)
+ make conversion to termcap ug (underline glitch) more consistently applied.
+ modify read_termtype(), fixing 'toe', which could dump core when it
found an incomplete entry such as "dumb" because it did not
initialize its buffer for _nc_read_file_entry().
+ use explicit VALID_NUMERIC() checks in a few places that had been
overlooked, and add a check to ensure that init_tabs is nonzero,
to avoid divide-by-zero (reported by Todd C Miller).
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.5 1999/12/06 02:12:46 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d57 1
a57 1
MODULE_ID("$From: write_entry.c,v 1.50 2000/01/01 16:35:44 tom Exp $")
@


1.5
log
@update to ncurses-5.0-19991204
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.4 1999/07/11 14:10:11 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 2


d54 1
a54 1
#define TRACE_OUT(p) /*nothing*/
d57 1
a57 1
MODULE_ID("$From: write_entry.c,v 1.48 1999/12/04 23:02:59 tom Exp $")
d63 2
a64 1
static void write_file(char *filename, TERMTYPE *tp)
d66 6
a71 6
	FILE *fp = (_nc_access(filename, W_OK) == 0) ? fopen(filename, "wb") : 0;
	if (fp == 0) {
		perror(filename);
		_nc_syserr_abort("can't open %s/%s", _nc_tic_dir(0), filename);
	}
	DEBUG(1, ("Created %s", filename));
d73 4
a76 4
	if (write_object(fp, tp) == ERR) {
		_nc_syserr_abort("error writing %s/%s", _nc_tic_dir(0), filename);
	}
	fclose(fp);
d84 2
a85 1
static int make_directory(const char *path)
d87 14
a100 14
int	rc;
struct	stat	statbuf;
char	fullpath[PATH_MAX];
const char *destination = _nc_tic_dir(0);

	if (path == destination || *path == '/') {
		if (strlen(path) + 1 > sizeof(fullpath))
			return(-1);
		(void)strcpy(fullpath, path);
	} else {
		if (strlen(destination) + strlen(path) + 2 > sizeof(fullpath))
			return(-1);
		(void)sprintf(fullpath, "%s/%s", destination, path);
	}
d102 7
a108 8
	if ((rc = stat(path, &statbuf)) < 0) {
		rc = mkdir(path, 0777);
	} else {
		if (_nc_access(path, R_OK|W_OK|X_OK) < 0) {
			rc = -1;	/* permission denied */
		} else if (!(S_ISDIR(statbuf.st_mode))) {
			rc = -1;	/* not a directory */
		}
d110 2
a111 1
	return rc;
d114 2
a115 1
void  _nc_set_writedir(char *dir)
d127 2
a128 3
    if (make_directory(destination) < 0)
    {
	char	*home = _nc_home_terminfo();
d134 1
a134 1
			destination, errno);
d143 1
a143 1
     || getcwd(actual, sizeof(actual)) == 0)
d160 2
a161 1
static void check_writeable(int code)
d163 2
a164 2
static const char dirnames[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
static bool verified[sizeof(dirnames)];
d166 2
a167 2
char		dir[2];
char		*s;
d169 2
a170 2
	if (code == 0 || (s = strchr(dirnames, code)) == 0)
	    _nc_err_abort("Illegal terminfo subdirectory \"%c\"", code);
d172 8
a179 8
	if (verified[s-dirnames])
	    return;

	dir[0] = code;
	dir[1] = '\0';
	if (make_directory(dir) < 0) {
		_nc_err_abort("%s/%s: permission denied", _nc_tic_dir(0), dir);
	}
d181 1
a181 1
	verified[s-dirnames] = TRUE;
d206 2
a207 1
void _nc_write_entry(TERMTYPE *const tp)
d209 6
a214 6
struct stat	statbuf;
char		name_list[MAX_TERMINFO_LENGTH];
char		*first_name, *other_names;
char		*ptr;
char		filename[PATH_MAX];
char		linkname[PATH_MAX];
d216 1
a216 1
char		symlinkname[PATH_MAX];
d218 2
a219 2
static int	call_count;
static time_t	start_time;		/* time at start of writes */
d221 3
a223 3
	if (call_count++ == 0) {
		start_time = 0;
	}
d225 2
a226 2
	(void) strcpy(name_list, tp->term_names);
	DEBUG(7, ("Name list = '%s'", name_list));
d228 1
a228 1
	first_name = name_list;
d230 2
a231 2
	ptr = &name_list[strlen(name_list) - 1];
	other_names = ptr + 1;
d233 2
a234 2
	while (ptr > name_list  &&  *ptr != '|')
		ptr--;
d236 2
a237 2
	if (ptr != name_list) {
		*ptr = '\0';
d239 2
a240 2
		for (ptr = name_list; *ptr != '\0' && *ptr != '|'; ptr++)
			continue;
d242 5
a246 6
		if (*ptr == '\0')
			other_names = ptr;
		else {
			*ptr = '\0';
			other_names = ptr + 1;
		}
d248 1
d250 2
a251 2
	DEBUG(7, ("First name = '%s'", first_name));
	DEBUG(7, ("Other names = '%s'", other_names));
d253 1
a253 1
	_nc_set_type(first_name);
d255 2
a256 2
	if (strlen(first_name) > sizeof(filename)-3)
		_nc_warning("terminal name too long.");
d258 1
a258 1
	sprintf(filename, "%c/%s", first_name[0], first_name);
d260 10
a269 11
	/*
	 * Has this primary name been written since the first call to
	 * write_entry()?  If so, the newer write will step on the older,
	 * so warn the user.
	 */
	if (start_time > 0 &&
	    stat(filename, &statbuf) >= 0
	    && statbuf.st_mtime >= start_time)
	{
		_nc_warning("name multiply defined.");
	}
d271 2
a272 2
	check_writeable(first_name[0]);
	write_file(filename, tp);
d274 33
a306 36
	if (start_time == 0) {
		if (stat(filename, &statbuf) < 0
		 || (start_time = statbuf.st_mtime) == 0) {
			_nc_syserr_abort("error obtaining time from %s/%s",
				_nc_tic_dir(0), filename);
		}
	}
	while (*other_names != '\0') {
		ptr = other_names++;
		while (*other_names != '|'  &&	*other_names != '\0')
			other_names++;

		if (*other_names != '\0')
			*(other_names++) = '\0';

		if (strlen(ptr) > sizeof(linkname)-3) {
			_nc_warning("terminal alias %s too long.", ptr);
			continue;
		}
		if (strchr(ptr, '/') != 0) {
			_nc_warning("cannot link alias %s.", ptr);
			continue;
		}

		check_writeable(ptr[0]);
		sprintf(linkname, "%c/%s", ptr[0], ptr);

		if (strcmp(filename, linkname) == 0) {
			_nc_warning("self-synonym ignored");
		}
		else if (stat(linkname, &statbuf) >= 0	&&
						statbuf.st_mtime < start_time)
		{
			_nc_warning("alias %s multiply defined.", ptr);
		}
		else if (_nc_access(linkname, W_OK) == 0)
d308 2
a309 2
		{
			int code;
d311 3
a313 3
			strcpy(symlinkname, "../");
			strncat(symlinkname, filename, sizeof(symlinkname) - 4);
			symlinkname[sizeof(symlinkname) - 1] = '\0';
d316 1
a316 1
			code = remove(linkname);
d318 1
a318 1
			code = unlink(linkname);
d320 2
a321 2
			if (code != 0 && errno == ENOENT)
				code = 0;
d323 1
a323 1
			if (symlink(symlinkname, linkname) < 0)
d325 1
a325 1
			if (link(filename, linkname) < 0)
d327 17
a343 19
			{
			    /*
			     * If there wasn't anything there, and we cannot
			     * link to the target because it is the same as the
			     * target, then the source must be on a filesystem
			     * that uses caseless filenames, such as Win32, etc.
			     */
			    if (code == 0 && errno == EEXIST)
				_nc_warning("can't link %s to %s", filename, linkname);
			    else if (code == 0 && errno == EPERM)
				write_file(linkname, tp);
			    else
				_nc_syserr_abort("can't link %s to %s", filename, linkname);
			}
			else
			{
			    DEBUG(1, ("Linked %s", linkname));
			}
		}
d345 1
a345 1
		write_file(linkname, tp);
d347 1
a347 1
	}
d350 1
a350 1
#undef LITTLE_ENDIAN	/* BSD/OS defines this as a feature macro */
d357 2
a358 1
static int compute_offsets(char **Strings, int strmax, short *offsets)
d377 2
a378 1
static void convert_shorts(unsigned char *buf, short *Numbers, int count)
d382 5
a386 5
	if (Numbers[i] == -1) {		/* HI/LO won't work */
	    buf[2*i] = buf[2*i + 1] = 0377;
	} else if (Numbers[i] == -2) {	/* HI/LO won't work */
	    buf[2*i] = 0376;
	    buf[2*i + 1] = 0377;
d388 1
a388 1
	    LITTLE_ENDIAN(buf + 2*i, Numbers[i]);
d397 2
a398 1
static int write_object(FILE *fp, TERMTYPE *tp)
d400 10
a409 10
char		*namelist;
size_t		namelen, boolmax, nummax, strmax;
char		zero = '\0';
size_t		i;
short		nextfree;
short		offsets[MAX_ENTRY_SIZE/2];
unsigned char	buf[MAX_ENTRY_SIZE];
unsigned	last_bool = BOOLWRITE;
unsigned	last_num = NUMWRITE;
unsigned	last_str = STRWRITE;
d412 11
a422 11
	/*
	 * Normally we limit the list of values to exclude the "obsolete"
	 * capabilities.  However, if we are accepting extended names, add
	 * these as well, since they are used for supporting translation
	 * to/from termcap.
	 */
	if (_nc_user_definable) {
	    last_bool = BOOLCOUNT;
	    last_num = NUMCOUNT;
	    last_str = STRCOUNT;
	}
d425 2
a426 2
	namelist = tp->term_names;
	namelen = strlen(namelist) + 1;
d428 5
a432 5
	boolmax = 0;
	for (i = 0; i < last_bool; i++) {
	    if (tp->Booleans[i])
		boolmax = i+1;
	}
d434 5
a438 5
	nummax = 0;
	for (i = 0; i < last_num; i++) {
	    if (tp->Numbers[i] != ABSENT_NUMERIC)
		nummax = i+1;
	}
d440 5
a444 5
	strmax = 0;
	for (i = 0; i < last_str; i++) {
	    if (tp->Strings[i] != ABSENT_STRING)
		strmax = i+1;
	}
d446 1
a446 1
	nextfree = compute_offsets(tp->Strings, strmax, offsets);
d448 39
a486 7
	/* fill in the header */
	LITTLE_ENDIAN(buf,    MAGIC);
	LITTLE_ENDIAN(buf+2,  min(namelen, MAX_NAME_SIZE + 1));
	LITTLE_ENDIAN(buf+4,  boolmax);
	LITTLE_ENDIAN(buf+6,  nummax);
	LITTLE_ENDIAN(buf+8,  strmax);
	LITTLE_ENDIAN(buf+10, nextfree);
d488 3
a490 6
	/* write out the header */
	TRACE_OUT(("Header of %s @@%ld", namelist, ftell(fp)));
	if (fwrite(buf, 12, 1, fp) != 1
	    ||  fwrite(namelist, sizeof(char), namelen, fp) != namelen
	    ||  fwrite(tp->Booleans, sizeof(char), boolmax, fp) != boolmax)
	    return(ERR);
d492 2
a493 2
	if (even_boundary(namelen+boolmax))
	    return(ERR);
d495 5
a499 1
	TRACE_OUT(("Numerics begin at %04lx", ftell(fp)));
d501 27
a527 4
	/* the numerics */
	convert_shorts(buf, tp->Numbers, nummax);
	if (fwrite(buf, 2, nummax, fp) != nummax)
	    return(ERR);
d529 4
a532 3
	TRACE_OUT(("String offsets begin at %04lx", ftell(fp)));

	/* the string offsets */
d534 1
d536 1
a536 1
	    return(ERR);
d538 10
a547 46
	TRACE_OUT(("String table begins at %04lx", ftell(fp)));

	/* the strings */
	for (i = 0; i < strmax; i++)
	    if (VALID_STRING(tp->Strings[i]))
		if (!WRITE_STRING(tp->Strings[i]))
		    return(ERR);

#if NCURSES_XNAMES
	if (NUM_EXT_NAMES(tp)) {
	    unsigned extcnt = NUM_EXT_NAMES(tp);

	    if (even_boundary(nextfree))
		return(ERR);

	    nextfree = compute_offsets(tp->Strings + STRCOUNT, tp->ext_Strings, offsets);
	    TRACE_OUT(("after extended string capabilities, nextfree=%d", nextfree));
	    nextfree += compute_offsets(tp->ext_Names, extcnt, offsets + tp->ext_Strings);
	    TRACE_OUT(("after extended capnames, nextfree=%d", nextfree));
	    strmax = tp->ext_Strings + extcnt;

	    /*
	     * Write the extended header
	     */
	    LITTLE_ENDIAN(buf+0, tp->ext_Booleans);
	    LITTLE_ENDIAN(buf+2, tp->ext_Numbers);
	    LITTLE_ENDIAN(buf+4, tp->ext_Strings);
	    LITTLE_ENDIAN(buf+6, strmax);
	    LITTLE_ENDIAN(buf+8, nextfree);
	    TRACE_OUT(("WRITE extended-header @@%ld", ftell(fp)));
	    if (fwrite(buf, 10, 1, fp) != 1)
		return(ERR);

	    TRACE_OUT(("WRITE %d booleans @@%ld", tp->ext_Booleans, ftell(fp)));
	    if (tp->ext_Booleans
	     && fwrite(tp->Booleans + BOOLCOUNT, sizeof(char), tp->ext_Booleans, fp) != tp->ext_Booleans)
		return(ERR);

	    if (even_boundary(tp->ext_Booleans))
		return(ERR);

	    TRACE_OUT(("WRITE %d numbers @@%ld", tp->ext_Numbers, ftell(fp)));
	    if (tp->ext_Numbers) {
		convert_shorts(buf, tp->Numbers + NUMCOUNT, tp->ext_Numbers);
		if (fwrite(buf, 2, tp->ext_Numbers, fp) != tp->ext_Numbers)
		    return(ERR);
d549 1
d551 8
a558 20
	    /*
	     * Convert the offsets for the ext_Strings and ext_Names tables,
	     * in that order.
	     */
	    convert_shorts(buf, offsets, strmax);
	    TRACE_OUT(("WRITE offsets @@%ld", ftell(fp)));
	    if (fwrite(buf, 2, strmax, fp) != strmax)
		return(ERR);

	    /*
	     * Write the string table after the offset tables so we do not
	     * have to do anything about alignment.
	     */
	    for (i = 0; i < tp->ext_Strings; i++) {
		if (VALID_STRING(tp->Strings[i+STRCOUNT])) {
		    TRACE_OUT(("WRITE ext_Strings[%d]=%s", i, _nc_visbuf(tp->Strings[i+STRCOUNT])));
		    if (!WRITE_STRING(tp->Strings[i+STRCOUNT]))
			return(ERR);
		}
	    }
d560 1
a560 10
	    /*
	     * Write the extended names
	     */
	    for (i = 0; i < extcnt; i++) {
		TRACE_OUT(("WRITE ext_Names[%d]=%s", i, tp->ext_Names[i]));
		if (!WRITE_STRING(tp->ext_Names[i]))
		    return(ERR);
	    }

	}
d563 2
a564 2
	total_written++;
	return(OK);
d570 2
a571 1
int _nc_tic_written(void)
d573 1
a573 1
	return total_written;
@


1.4
log
@ncurses-990710:
Correct logic in write_entry from split-out of home_terminfo in
980919, which prevented update of $HOME/.terminfo
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.3 1999/03/11 21:03:57 millert Exp $	*/
d59 1
a59 1
MODULE_ID("$From: write_entry.c,v 1.47 1999/07/10 20:29:22 tom Exp $")
d408 17
a428 4
	/*
	 * BOOLWRITE, etc., are less than BOOLCOUNT because we store some
	 * values internally.
	 */
d430 1
a430 1
	for (i = 0; i < BOOLWRITE; i++) {
d436 1
a436 1
	for (i = 0; i < NUMWRITE; i++) {
d442 1
a442 1
	for (i = 0; i < STRWRITE; i++) {
@


1.3
log
@ncurses-4.2-990307
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.2 1999/03/02 06:23:29 millert Exp $	*/
d59 1
a59 1
MODULE_ID("$From: write_entry.c,v 1.46 1999/03/06 22:48:21 tom Exp $")
d131 1
a131 1

a134 2

	    destination = home;
@


1.2
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.1 1999/01/18 19:10:23 millert Exp $	*/
d59 1
a59 1
MODULE_ID("$From: write_entry.c,v 1.45 1999/02/28 22:26:33 tom Exp $")
d382 1
a382 1
static void convert_shorts(char *buf, short *Numbers, int count)
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: write_entry.c,v 1.5 1998/10/31 06:30:31 millert Exp $	*/
a46 1
#include <term.h>
d53 7
a59 1
MODULE_ID("$From: write_entry.c,v 1.34 1998/12/20 02:49:27 tom Exp $")
d147 1
a147 1
    _nc_keep_tic_dir(strcpy(malloc(strlen(actual)+1), actual));
d361 40
d408 1
a408 1
short		offsets[STRCOUNT];
d414 4
d419 4
a422 3
	for (i = 0; i < BOOLWRITE; i++)
		if (tp->Booleans[i])
			boolmax = i+1;
d425 4
a428 3
	for (i = 0; i < NUMWRITE; i++)
		if (tp->Numbers[i] != ABSENT_NUMERIC)
			nummax = i+1;
d431 4
a434 3
	for (i = 0; i < STRWRITE; i++)
		if (tp->Strings[i] != ABSENT_STRING)
			strmax = i+1;
d436 1
a436 11
	nextfree = 0;
	for (i = 0; i < strmax; i++)
	    if (tp->Strings[i] == ABSENT_STRING)
		offsets[i] = -1;
	    else if (tp->Strings[i] == CANCELLED_STRING)
		offsets[i] = -2;
	    else
	    {
		offsets[i] = nextfree;
		nextfree += strlen(tp->Strings[i]) + 1;
	    }
d447 1
d449 34
a482 2
		||  fwrite(namelist, sizeof(char), (size_t)namelen, fp) != namelen
		||  fwrite(tp->Booleans, sizeof(char), (size_t)boolmax, fp) != boolmax)
d485 16
a500 2
	/* the even-boundary padding byte */
	if ((namelen+boolmax) % 2 != 0 &&  fwrite(&zero, sizeof(char), 1, fp) != 1)
d503 4
a506 3
#ifdef SHOWOFFSET
	(void) fprintf(stderr, "Numerics begin at %04lx\n", ftell(fp));
#endif /* SHOWOFFSET */
d508 1
a508 11
	/* the numerics */
	for (i = 0; i < nummax; i++)
	{
		if (tp->Numbers[i] == -1)	/* HI/LO won't work */
			buf[2*i] = buf[2*i + 1] = 0377;
		else if (tp->Numbers[i] == -2)	/* HI/LO won't work */
			buf[2*i] = 0376, buf[2*i + 1] = 0377;
		else
			LITTLE_ENDIAN(buf + 2*i, tp->Numbers[i]);
	}
	if (fwrite(buf, 2, (size_t)nummax, fp) != nummax)
d511 6
a516 3
#ifdef SHOWOFFSET
	(void) fprintf(stderr, "String offets begin at %04lx\n", ftell(fp));
#endif /* SHOWOFFSET */
d518 7
a524 12
	/* the string offsets */
	for (i = 0; i < strmax; i++)
		if (offsets[i] == -1)	/* HI/LO won't work */
			buf[2*i] = buf[2*i + 1] = 0377;
		else if (offsets[i] == -2)	/* HI/LO won't work */
		{
			buf[2*i] = 0376;
			buf[2*i + 1] = 0377;
		}
		else
			LITTLE_ENDIAN(buf + 2*i, offsets[i]);
	if (fwrite(buf, 2, (size_t)strmax, fp) != strmax)
d527 11
a537 3
#ifdef SHOWOFFSET
	(void) fprintf(stderr, "String table begins at %04lx\n", ftell(fp));
#endif /* SHOWOFFSET */
d539 6
a544 4
	/* the strings */
	for (i = 0; i < strmax; i++)
	    if (tp->Strings[i] != ABSENT_STRING && tp->Strings[i] != CANCELLED_STRING)
		if (fwrite(tp->Strings[i], sizeof(char), strlen(tp->Strings[i]) + 1, fp) != strlen(tp->Strings[i]) + 1)
d546 4
@

