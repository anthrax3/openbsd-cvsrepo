head	1.17;
access;
symbols
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.26
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.18
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.20
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.18
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.16
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.14
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.12
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.10
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.8
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.6
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.8
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.6
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.17
date	2015.12.03.11.29.55;	author nicm;	state Exp;
branches;
next	1.16;
commitid	5hoMCFvEUcTQqvPZ;

1.16
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.29.13.02.31;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.17.19.16.59;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.22.18.01.55;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.22.18.27.23;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.08.22.47.03;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.13.23.53.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.10.01.35.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.09.05.06.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.02.22.06.51;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.08.15.11.40.56;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.03.02.06.23.29;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.01.23.18.31.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.01.22.04.50.43;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.22;	author millert;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Instead of using our own custom BDB terminfo databases, use the ncurses
files in /usr/share/terminfo/*. This removes a large difference from
upstream ncurses and other systems.

ok millert
@
text
@/* $OpenBSD: read_entry.c,v 1.16 2010/01/12 23:22:06 nicm Exp $ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 *	read_entry.c -- Routine for reading in a compiled terminfo file
 */

#include <curses.priv.h>
#include <hashed_db.h>

#include <tic.h>
#include <term_entry.h>

MODULE_ID("$Id: read_entry.c,v 1.16 2010/01/12 23:22:06 nicm Exp $")

#define TYPE_CALLOC(type,elts) typeCalloc(type, (unsigned)(elts))

#if USE_DATABASE
static void
convert_shorts(char *buf, short *Numbers, int count)
{
    int i;
    for (i = 0; i < count; i++) {
	if (IS_NEG1(buf + 2 * i))
	    Numbers[i] = ABSENT_NUMERIC;
	else if (IS_NEG2(buf + 2 * i))
	    Numbers[i] = CANCELLED_NUMERIC;
	else
	    Numbers[i] = LOW_MSB(buf + 2 * i);
	TR(TRACE_DATABASE, ("get Numbers[%d]=%d", i, Numbers[i]));
    }
}

static void
convert_strings(char *buf, char **Strings, int count, int size, char *table)
{
    int i;
    char *p;

    for (i = 0; i < count; i++) {
	if (IS_NEG1(buf + 2 * i)) {
	    Strings[i] = ABSENT_STRING;
	} else if (IS_NEG2(buf + 2 * i)) {
	    Strings[i] = CANCELLED_STRING;
	} else if ((int) LOW_MSB(buf + 2 * i) > size) {
	    Strings[i] = ABSENT_STRING;
	} else {
	    Strings[i] = (LOW_MSB(buf + 2 * i) + table);
	    TR(TRACE_DATABASE, ("Strings[%d] = %s", i, _nc_visbuf(Strings[i])));
	}

	/* make sure all strings are NUL terminated */
	if (VALID_STRING(Strings[i])) {
	    for (p = Strings[i]; p <= table + size; p++)
		if (*p == '\0')
		    break;
	    /* if there is no NUL, ignore the string */
	    if (p > table + size)
		Strings[i] = ABSENT_STRING;
	}
    }
}

static int
fake_read(char *src, int *offset, int limit, char *dst, unsigned want)
{
    int have = (limit - *offset);

    if (have > 0) {
	if ((int) want > have)
	    want = have;
	memcpy(dst, src + *offset, want);
	*offset += want;
    } else {
	want = 0;
    }
    return (int) want;
}

#define Read(buf, count) fake_read(buffer, &offset, limit, buf, count)

#define read_shorts(buf, count) \
	(Read(buf, (unsigned) (count)*2) == (int) (count)*2)

#define even_boundary(value) \
    if ((value) % 2 != 0) Read(buf, 1)

NCURSES_EXPORT(int)
_nc_read_termtype(TERMTYPE *ptr, char *buffer, int limit)
/* return 1 if read, 0 if not found or garbled */
{
    int offset = 0;
    int name_size, bool_count, num_count, str_count, str_size;
    int i;
    char buf[MAX_ENTRY_SIZE + 1];
    char *string_table;
    unsigned want, have;

    TR(TRACE_DATABASE, ("READ termtype header @@%d", offset));

    memset(ptr, 0, sizeof(*ptr));

    /* grab the header */
    if (!read_shorts(buf, 6)
	|| !IS_TIC_MAGIC(buf)) {
	return (TGETENT_NO);
    }

    name_size = LOW_MSB(buf + 2);
    bool_count = LOW_MSB(buf + 4);
    num_count = LOW_MSB(buf + 6);
    str_count = LOW_MSB(buf + 8);
    str_size = LOW_MSB(buf + 10);

    TR(TRACE_DATABASE,
       ("TERMTYPE name_size=%d, bool=%d/%d, num=%d/%d str=%d/%d(%d)",
	name_size, bool_count, BOOLCOUNT, num_count, NUMCOUNT,
	str_count, STRCOUNT, str_size));
    if (name_size < 0
	|| bool_count < 0
	|| num_count < 0
	|| str_count < 0
	|| str_size < 0) {
	return (TGETENT_NO);
    }

    want = str_size + name_size + 1;
    if (str_size) {
	/* try to allocate space for the string table */
	if (str_count * 2 >= (int) sizeof(buf)
	    || (string_table = typeMalloc(char, want)) == 0) {
	    return (TGETENT_NO);
	}
    } else {
	str_count = 0;
	if ((string_table = typeMalloc(char, want)) == 0) {
	    return (TGETENT_NO);
	}
    }

    /* grab the name (a null-terminated string) */
    want = min(MAX_NAME_SIZE, (unsigned) name_size);
    ptr->str_table = string_table;
    ptr->term_names = string_table;
    if ((have = Read(ptr->term_names, want)) != want) {
	memset(ptr->term_names + have, 0, want - have);
    }
    ptr->term_names[want] = '\0';
    string_table += (want + 1);

    if (have > MAX_NAME_SIZE)
	offset = (have - MAX_NAME_SIZE);

    /* grab the booleans */
    if ((ptr->Booleans = TYPE_CALLOC(NCURSES_SBOOL,
				     max(BOOLCOUNT, bool_count))) == 0
	|| Read(ptr->Booleans, (unsigned) bool_count) < bool_count) {
	return (TGETENT_NO);
    }

    /*
     * If booleans end on an odd byte, skip it.  The machine they
     * originally wrote terminfo on must have been a 16-bit
     * word-oriented machine that would trap out if you tried a
     * word access off a 2-byte boundary.
     */
    even_boundary(name_size + bool_count);

    /* grab the numbers */
    if ((ptr->Numbers = TYPE_CALLOC(short, max(NUMCOUNT, num_count))) == 0
	|| !read_shorts(buf, num_count)) {
	return (TGETENT_NO);
    }
    convert_shorts(buf, ptr->Numbers, num_count);

    if ((ptr->Strings = TYPE_CALLOC(char *, max(STRCOUNT, str_count))) == 0)
	  return (TGETENT_NO);

    if (str_count) {
	/* grab the string offsets */
	if (!read_shorts(buf, str_count)) {
	    return (TGETENT_NO);
	}
	/* finally, grab the string table itself */
	if (Read(string_table, (unsigned) str_size) != str_size)
	    return (TGETENT_NO);
	convert_strings(buf, ptr->Strings, str_count, str_size, string_table);
    }
#if NCURSES_XNAMES

    ptr->num_Booleans = BOOLCOUNT;
    ptr->num_Numbers = NUMCOUNT;
    ptr->num_Strings = STRCOUNT;

    /*
     * Read extended entries, if any, after the normal end of terminfo data.
     */
    even_boundary(str_size);
    TR(TRACE_DATABASE, ("READ extended_header @@%d", offset));
    if (_nc_user_definable && read_shorts(buf, 5)) {
	int ext_bool_count = LOW_MSB(buf + 0);
	int ext_num_count = LOW_MSB(buf + 2);
	int ext_str_count = LOW_MSB(buf + 4);
	int ext_str_size = LOW_MSB(buf + 6);
	int ext_str_limit = LOW_MSB(buf + 8);
	unsigned need = (ext_bool_count + ext_num_count + ext_str_count);
	int base = 0;

	if (need >= sizeof(buf)
	    || ext_str_size >= (int) sizeof(buf)
	    || ext_str_limit >= (int) sizeof(buf)
	    || ext_bool_count < 0
	    || ext_num_count < 0
	    || ext_str_count < 0
	    || ext_str_size < 0
	    || ext_str_limit < 0)
	    return (TGETENT_NO);

	ptr->num_Booleans = BOOLCOUNT + ext_bool_count;
	ptr->num_Numbers = NUMCOUNT + ext_num_count;
	ptr->num_Strings = STRCOUNT + ext_str_count;

	ptr->Booleans = typeRealloc(NCURSES_SBOOL, ptr->num_Booleans, ptr->Booleans);
	ptr->Numbers = typeRealloc(short, ptr->num_Numbers, ptr->Numbers);
	ptr->Strings = typeRealloc(char *, ptr->num_Strings, ptr->Strings);

	TR(TRACE_DATABASE, ("extended header is %d/%d/%d(%d:%d)",
			    ext_bool_count, ext_num_count, ext_str_count,
			    ext_str_size, ext_str_limit));

	TR(TRACE_DATABASE, ("READ %d extended-booleans @@%d",
			    ext_bool_count, offset));
	if ((ptr->ext_Booleans = ext_bool_count) != 0) {
	    if (Read(ptr->Booleans + BOOLCOUNT, (unsigned)
		     ext_bool_count) != ext_bool_count)
		return (TGETENT_NO);
	}
	even_boundary(ext_bool_count);

	TR(TRACE_DATABASE, ("READ %d extended-numbers @@%d",
			    ext_num_count, offset));
	if ((ptr->ext_Numbers = ext_num_count) != 0) {
	    if (!read_shorts(buf, ext_num_count))
		return (TGETENT_NO);
	    TR(TRACE_DATABASE, ("Before converting extended-numbers"));
	    convert_shorts(buf, ptr->Numbers + NUMCOUNT, ext_num_count);
	}

	TR(TRACE_DATABASE, ("READ extended-offsets @@%d", offset));
	if ((ext_str_count || need)
	    && !read_shorts(buf, ext_str_count + need))
	    return (TGETENT_NO);

	TR(TRACE_DATABASE, ("READ %d bytes of extended-strings @@%d",
			    ext_str_limit, offset));

	if (ext_str_limit) {
	    if ((ptr->ext_str_table = typeMalloc(char, ext_str_limit)) == 0)
		  return (TGETENT_NO);
	    if (Read(ptr->ext_str_table, (unsigned) ext_str_limit) != ext_str_limit)
		return (TGETENT_NO);
	    TR(TRACE_DATABASE, ("first extended-string is %s", _nc_visbuf(ptr->ext_str_table)));
	}

	if ((ptr->ext_Strings = ext_str_count) != 0) {
	    TR(TRACE_DATABASE,
	       ("Before computing extended-string capabilities str_count=%d, ext_str_count=%d",
		str_count, ext_str_count));
	    convert_strings(buf, ptr->Strings + str_count, ext_str_count,
			    ext_str_limit, ptr->ext_str_table);
	    for (i = ext_str_count - 1; i >= 0; i--) {
		TR(TRACE_DATABASE, ("MOVE from [%d:%d] %s",
				    i, i + str_count,
				    _nc_visbuf(ptr->Strings[i + str_count])));
		ptr->Strings[i + STRCOUNT] = ptr->Strings[i + str_count];
		if (VALID_STRING(ptr->Strings[i + STRCOUNT]))
		    base += (strlen(ptr->Strings[i + STRCOUNT]) + 1);
		TR(TRACE_DATABASE, ("... to    [%d] %s",
				    i + STRCOUNT,
				    _nc_visbuf(ptr->Strings[i + STRCOUNT])));
	    }
	}

	if (need) {
	    if (ext_str_count >= (MAX_ENTRY_SIZE * 2))
		  return (TGETENT_NO);
	    if ((ptr->ext_Names = TYPE_CALLOC(char *, need)) == 0)
		  return (TGETENT_NO);
	    TR(TRACE_DATABASE,
	       ("ext_NAMES starting @@%d in extended_strings, first = %s",
		base, _nc_visbuf(ptr->ext_str_table + base)));
	    convert_strings(buf + (2 * ext_str_count),
			    ptr->ext_Names,
			    (int) need,
			    ext_str_limit, ptr->ext_str_table + base);
	}

	T(("...done reading terminfo bool %d(%d) num %d(%d) str %d(%d)",
	   ptr->num_Booleans, ptr->ext_Booleans,
	   ptr->num_Numbers, ptr->ext_Numbers,
	   ptr->num_Strings, ptr->ext_Strings));

	TR(TRACE_DATABASE, ("extend: num_Booleans:%d", ptr->num_Booleans));
    } else
#endif /* NCURSES_XNAMES */
    {
	T(("...done reading terminfo bool %d num %d str %d",
	   bool_count, num_count, str_count));
#if NCURSES_XNAMES
	TR(TRACE_DATABASE, ("normal: num_Booleans:%d", ptr->num_Booleans));
#endif
    }

    for (i = bool_count; i < BOOLCOUNT; i++)
	ptr->Booleans[i] = FALSE;
    for (i = num_count; i < NUMCOUNT; i++)
	ptr->Numbers[i] = ABSENT_NUMERIC;
    for (i = str_count; i < STRCOUNT; i++)
	ptr->Strings[i] = ABSENT_STRING;

    return (TGETENT_YES);
}

/*
 *	int
 *	_nc_read_file_entry(filename, ptr)
 *
 *	Read the compiled terminfo entry in the given file into the
 *	structure pointed to by ptr, allocating space for the string
 *	table.
 */
NCURSES_EXPORT(int)
_nc_read_file_entry(const char *const filename, TERMTYPE *ptr)
/* return 1 if read, 0 if not found or garbled */
{
    int code, fd = -1;
    int limit;
    char buffer[MAX_ENTRY_SIZE + 1];

    if (_nc_access(filename, R_OK) < 0
	|| (fd = open(filename, O_RDONLY | O_BINARY)) < 0) {
	T(("cannot open terminfo %s (errno=%d)", filename, errno));
	code = TGETENT_NO;
    } else {
	if ((limit = read(fd, buffer, sizeof(buffer))) > 0) {

	    T(("read terminfo %s", filename));
	    if ((code = _nc_read_termtype(ptr, buffer, limit)) == TGETENT_NO) {
		_nc_free_termtype(ptr);
	    }
	} else {
	    code = TGETENT_NO;
	}
	close(fd);
    }

    return (code);
}

/*
 * Build a terminfo pathname and try to read the data.  Returns TGETENT_YES on
 * success, TGETENT_NO on failure.
 */
static int
_nc_read_tic_entry(char *filename,
		   unsigned limit,
		   const char *const path,
		   const char *name,
		   TERMTYPE *const tp)
{
    int result = TGETENT_NO;

    /*
     * If we are looking in a directory, assume the entry is a file under that,
     * according to the normal rules.
     *
     * FIXME - add caseless-filename fixup.
     */
    unsigned need = 4 + strlen(path) + strlen(name);
    if (need <= limit) {
	    (void) snprintf(filename, limit, "%s/" LEAF_FMT "/%s", path, *name, name);
	    if (_nc_is_dir_path(path))
		    result = _nc_read_file_entry(filename, tp);
    }

#if USE_HASHED_DB
    else {
	static const char suffix[] = DBM_SUFFIX;
	DB *capdbp;
	unsigned lens = sizeof(suffix) - 1;
	unsigned size = strlen(path);
	unsigned need = lens + size;

	if (need <= limit) {
	    if (size >= lens
		&& !strcmp(path + size - lens, suffix))
		(void) strlcpy(filename, path, limit);
	    else
		(void) snprintf(filename, limit, "%s%s", path, suffix);

	    /*
	     * It would be nice to optimize the dbopen/close activity, as
	     * done in the cgetent implementation for tc= clauses.  However,
	     * since we support multiple database locations, we cannot do
	     * that.
	     */
	    if ((capdbp = _nc_db_open(filename, FALSE)) != 0) {
		DBT key, data;
		int reccnt = 0;
		char *save = strdup(name);

		memset(&key, 0, sizeof(key));
		key.data = save;
		key.size = strlen(save);

		/*
		 * This lookup could return termcap data, which we do not want. 
		 * We are looking for compiled (binary) terminfo data.
		 *
		 * cgetent uses a two-level lookup.  On the first it uses the
		 * given name to return a record containing only the aliases
		 * for an entry.  On the second (using that list of aliases as
		 * a key), it returns the content of the terminal description. 
		 * We expect second lookup to return data beginning with the
		 * same set of aliases.
		 *
		 * For compiled terminfo, the list of aliases in the second
		 * case will be null-terminated.  A termcap entry will not be,
		 * and will run on into the description.  So we can easily
		 * distinguish between the two (source/binary) by checking the
		 * lengths.
		 */
		while (_nc_db_get(capdbp, &key, &data) == 0) {
		    int used = data.size - 1;
		    char *have = (char *) data.data;

		    if (*have++ == 0) {
			if (data.size > key.size
			    && IS_TIC_MAGIC(have)) {
			    result = _nc_read_termtype(tp, have, used);
			    if (result == TGETENT_NO) {
				_nc_free_termtype(tp);
			    }
			}
			break;
		    }

		    /*
		     * Just in case we have a corrupt database, do not waste
		     * time with it.
		     */
		    if (++reccnt >= 3)
			break;

		    /*
		     * Prepare for the second level.
		     */
		    key.data = have;
		    key.size = used;
		}

		_nc_db_close(capdbp);
		free(save);
	    }
	}
    }
#endif
    return result;
}
#endif /* USE_DATABASE */

/*
 *	_nc_read_entry(char *name, char *filename, TERMTYPE *tp)
 *
 *	Find and read the compiled entry for a given terminal type,
 *	if it exists.  We take pains here to make sure no combination
 *	of environment variables and terminal type name can be used to
 *	overrun the file buffer.
 */

NCURSES_EXPORT(int)
_nc_read_entry(const char *const name, char *const filename, TERMTYPE *const tp)
{
    int code = TGETENT_NO;

    snprintf(filename, PATH_MAX, "%s", name);
    if (strlen(name) == 0
	|| strcmp(name, ".") == 0
	|| strcmp(name, "..") == 0
	|| _nc_pathlast(name) != 0
	|| strchr(name, NCURSES_PATHSEP) != 0) {
	T(("illegal or missing entry name '%s'", name));
    } else {
#if USE_DATABASE
	DBDIRS state = dbdTIC;
	int offset = 0;
	const char *path;

	while ((path = _nc_next_db(&state, &offset)) != 0) {
	    code = _nc_read_tic_entry(filename, PATH_MAX, path, name, tp);
	    if (code == TGETENT_YES) {
		_nc_last_db();
		break;
	    }
	}
#endif
#if USE_TERMCAP
	if (code != TGETENT_YES) {
	    code = _nc_read_termcap_entry(name, tp);
	    snprintf(filename, PATH_MAX, "%s", _nc_get_source());
	}
#endif
    }
    return code;
}
@


1.16
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d47 1
a47 1
MODULE_ID("$Id: read_entry.c,v 1.102 2008/08/03 19:33:04 tom Exp $")
a372 5
#ifdef __OpenBSD__
    if (_nc_read_bsd_terminfo_file(filename, ptr) == 1)
	return (1);
#endif /* __OpenBSD__ */

a517 6

#ifdef __OpenBSD__
    /* First check the BSD terminfo.db file */
    if (_nc_read_bsd_terminfo_entry(name, filename, tp) == 1)
	return (1);
#endif /* __OpenBSD__ */
@


1.15
log
@More read/write result checking fixes to avoid unsigned comparisons vs
-1.

ok henning@@ beck@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.14 2003/03/18 16:55:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
a38 1
 *
d42 1
d47 1
a47 46
MODULE_ID("$From: read_entry.c,v 1.72 2000/12/10 02:55:08 tom Exp $")

#if !HAVE_TELL
#define tell(fd) 0		/* lseek() is POSIX, but not tell() - odd... */
#endif

/*
 *	int
 *	_nc_read_file_entry(filename, ptr)
 *
 *	Read the compiled terminfo entry in the given file into the
 *	structure pointed to by ptr, allocating space for the string
 *	table.
 */

#undef  BYTE
#define BYTE(p,n)	(unsigned char)((p)[n])

#define IS_NEG1(p)	((BYTE(p,0) == 0377) && (BYTE(p,1) == 0377))
#define IS_NEG2(p)	((BYTE(p,0) == 0376) && (BYTE(p,1) == 0377))
#define LOW_MSB(p)	(BYTE(p,0) + 256*BYTE(p,1))

static bool have_tic_directory = FALSE;
static bool keep_tic_directory = FALSE;

/*
 * Record the "official" location of the terminfo directory, according to
 * the place where we're writing to, or the normal default, if not.
 */
NCURSES_EXPORT(const char *)
_nc_tic_dir(const char *path)
{
    static const char *result = TERMINFO;

    if (!keep_tic_directory) {
	if (path != 0) {
	    result = path;
	    have_tic_directory = TRUE;
	} else if (!have_tic_directory && use_terminfo_vars()) {
	    char *envp;
	    if ((envp = getenv("TERMINFO")) != 0)
		return _nc_tic_dir(envp);
	}
    }
    return result;
}
d49 1
a49 11
/*
 * Special fix to prevent the terminfo directory from being moved after tic
 * has chdir'd to it.  If we let it be changed, then if $TERMINFO has a
 * relative path, we'll lose track of the actual directory.
 */
NCURSES_EXPORT(void)
_nc_keep_tic_dir(const char *path)
{
    _nc_tic_dir(path);
    keep_tic_directory = TRUE;
}
d51 1
d78 1
a78 1
	} else if (LOW_MSB(buf + 2 * i) > size) {
d97 20
a116 1
#define read_shorts(fd, buf, count) (read(fd, buf, (count)*2) == (count)*2)
d119 1
a119 1
    if ((value) % 2 != 0) read(fd, buf, 1)
d121 2
a122 2
static int
read_termtype(int fd, TERMTYPE * ptr)
d125 1
d128 3
a130 2
    size_t bsize;
    char buf[MAX_ENTRY_SIZE];
d132 1
a132 1
    TR(TRACE_DATABASE, ("READ termtype header @@%d", tell(fd)));
d137 3
a139 3
    if (!read_shorts(fd, buf, 6)
	|| LOW_MSB(buf) != MAGIC) {
	return (0);
a141 1
    _nc_free_termtype(ptr);
d157 1
a157 1
	return (0);
d160 1
d164 2
a165 2
	    || (ptr->str_table = typeMalloc(char, (unsigned) str_size)) == 0) {
	    return (0);
d169 3
d174 12
a185 11
    /* grab the name (a null-terminate string) */
    read(fd, buf, min(MAX_NAME_SIZE, (unsigned) name_size));
    buf[MAX_NAME_SIZE] = '\0';
    bsize = strlen(buf) + 1;
    ptr->term_names = typeCalloc(char, bsize);
    if (ptr->term_names == NULL) {
	return (0);
    }
    (void) strlcpy(ptr->term_names, buf, bsize);
    if (name_size > MAX_NAME_SIZE)
	lseek(fd, (off_t) (name_size - MAX_NAME_SIZE), 1);
d188 4
a191 3
    if ((ptr->Booleans = typeCalloc(char, max(BOOLCOUNT, bool_count))) == 0
	|| read(fd, ptr->Booleans, (unsigned) bool_count) != bool_count) {
	return (0);
d203 3
a205 3
    if ((ptr->Numbers = typeCalloc(short, max(NUMCOUNT, num_count))) == 0
	|| !read_shorts(fd, buf, num_count)) {
	return (0);
d209 2
a210 2
    if ((ptr->Strings = typeCalloc(char *, max(STRCOUNT, str_count))) == 0)
	  return (0);
d214 2
a215 2
	if (!read_shorts(fd, buf, str_count)) {
	    return (0);
d218 3
a220 3
	if (read(fd, ptr->str_table, (unsigned) str_size) != str_size)
	    return (0);
	convert_strings(buf, ptr->Strings, str_count, str_size, ptr->str_table);
d232 2
a233 2
    TR(TRACE_DATABASE, ("READ extended_header @@%d", tell(fd)));
    if (_nc_user_definable && read_shorts(fd, buf, 5)) {
d239 1
a239 1
	int need = (ext_bool_count + ext_num_count + ext_str_count);
d242 1
a242 1
	if (need >= (int) sizeof(buf)
d250 1
a250 1
	    return (0);
d256 1
a256 1
	ptr->Booleans = typeRealloc(char, ptr->num_Booleans, ptr->Booleans);
d265 1
a265 1
			    ext_bool_count, tell(fd)));
d267 1
a267 1
	    if (read(fd, ptr->Booleans + BOOLCOUNT, (unsigned)
d269 1
a269 1
		return (0);
d274 1
a274 1
			    ext_num_count, tell(fd)));
d276 2
a277 2
	    if (!read_shorts(fd, buf, ext_num_count))
		return (0);
d282 1
a282 1
	TR(TRACE_DATABASE, ("READ extended-offsets @@%d", tell(fd)));
d284 2
a285 2
	    && !read_shorts(fd, buf, ext_str_count + need))
	    return (0);
d288 1
a288 1
			    ext_str_limit, tell(fd)));
d292 3
a294 3
		  return (0);
	    if (read(fd, ptr->ext_str_table, ext_str_limit) != ext_str_limit)
		return (0);
d318 4
a321 2
	    if ((ptr->ext_Names = typeCalloc(char *, need)) == 0)
		  return (0);
d325 3
a327 1
	    convert_strings(buf + (2 * ext_str_count), ptr->ext_Names, need,
d354 1
a354 1
    return (1);
d357 8
d366 1
a366 2
_nc_read_file_entry
(const char *const filename, TERMTYPE * ptr)
d370 2
d381 12
a392 1
	return (0);
a394 5
    T(("read terminfo %s", filename));
    if ((code = read_termtype(fd, ptr)) == 0)
	_nc_free_termtype(ptr);
    close(fd);

d399 2
a400 2
 * Build a terminfo pathname and try to read the data.  Returns 1 on success,
 * 0 on failure.
d403 5
a407 2
_nc_read_tic_entry(char *const filename,
		   const char *const dir, const char *ttn, TERMTYPE * const tp)
d409 1
a409 2
/* maximum safe length of terminfo root directory name */
#define MAX_TPATH	(PATH_MAX - MAX_ALIAS - 6)
d411 88
a498 5
    if (strlen(dir) > MAX_TPATH)
	return 0;
    (void) snprintf(filename, MAX_TPATH + 1, "%s/%s", dir, ttn);
    return _nc_read_file_entry(filename, tp);
}
d500 2
a501 25
/*
 * Process the list of :-separated directories, looking for the terminal type.
 * We don't use strtok because it does not show us empty tokens.
 */
static int
_nc_read_terminfo_dirs(const char *dirs, char *const filename, const char *const
		       ttn, TERMTYPE * const tp)
{
    char *list, *a;
    const char *b;
    int code = 0;

    /* we'll modify the argument, so we must copy */
    if ((b = a = list = strdup(dirs)) == NULL)
	return (0);

    for (;;) {
	int c = *a;
	if (c == 0 || c == NCURSES_PATHSEP) {
	    *a = 0;
	    if ((b + 1) >= a)
		b = TERMINFO;
	    if (_nc_read_tic_entry(filename, b, ttn, tp) == 1) {
		code = 1;
		break;
a502 3
	    b = a + 1;
	    if (c == 0)
		break;
a503 1
	a++;
d505 2
a506 3

    free(list);
    return (code);
d508 1
d511 1
a511 1
 *	_nc_read_entry(char *tn, char *filename, TERMTYPE *tp)
d520 1
a520 2
_nc_read_entry
(const char *const tn, char *const filename, TERMTYPE * const tp)
d522 1
a522 2
    char *envp;
    char ttn[MAX_ALIAS + 3];
d526 1
a526 1
    if (_nc_read_bsd_terminfo_entry(tn, filename, tp) == 1)
d530 18
a547 19
    /* truncate the terminal name to prevent dangerous buffer airline */
    (void) snprintf(ttn, sizeof(ttn), "%c/%.*s", *tn, MAX_ALIAS, tn);

    /* This is System V behavior, in conjunction with our requirements for
     * writing terminfo entries.
     */
    if (have_tic_directory
	&& _nc_read_tic_entry(filename, _nc_tic_dir(0), ttn, tp) == 1)
	return 1;

    if (use_terminfo_vars()) {
	if ((envp = getenv("TERMINFO")) != 0
	    && _nc_read_tic_entry(filename, _nc_tic_dir(envp), ttn, tp) == 1)
	    return 1;

	/* this is an ncurses extension */
	if ((envp = _nc_home_terminfo()) != 0) {
	    if (_nc_read_tic_entry(filename, envp, ttn, tp) == 1) {
		return (1);
d550 7
a556 4

	/* this is an ncurses extension */
	if ((envp = getenv("TERMINFO_DIRS")) != 0)
	    return _nc_read_terminfo_dirs(envp, filename, ttn, tp);
d558 1
a558 10

    /* Try the system directory.  Note that the TERMINFO_DIRS value, if
     * defined by the configure script, begins with a ":", which will be
     * interpreted as TERMINFO.
     */
#ifdef TERMINFO_DIRS
    return _nc_read_terminfo_dirs(TERMINFO_DIRS, filename, ttn, tp);
#else
    return _nc_read_tic_entry(filename, TERMINFO, ttn, tp);
#endif
@


1.14
log
@Use strlcpy() / strlcat() throughout.
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.13 2003/03/17 19:16:59 millert Exp $	*/
d217 1
a217 1
	|| read(fd, ptr->Booleans, (unsigned) bool_count) < bool_count) {
@


1.13
log
@use snprintf throughout
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.12 2001/01/22 18:01:55 millert Exp $	*/
d161 1
d206 2
a207 1
    ptr->term_names = typeCalloc(char, strlen(buf) + 1);
d211 1
a211 1
    (void) strcpy(ptr->term_names, buf);
@


1.12
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.11 2000/10/22 18:27:23 millert Exp $	*/
d417 1
a417 1
    (void) sprintf(filename, "%s/%s", dir, ttn);
d481 1
a481 1
    (void) sprintf(ttn, "%c/%.*s", *tn, MAX_ALIAS, tn);
@


1.11
log
@update to ncurses 5.2
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.10 2000/10/08 22:47:03 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: read_entry.c,v 1.69 2000/10/10 00:57:40 Todd.Miller Exp $")
d75 1
a75 1
const char *
d98 1
a98 1
void
d378 3
a380 2
int
_nc_read_file_entry(const char *const filename, TERMTYPE * ptr)
d439 1
a439 1
	if (c == 0 || c == ':') {
d467 3
a469 2
int
_nc_read_entry(const char *const tn, char *const filename, TERMTYPE * const tp)
@


1.10
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.9 2000/03/13 23:53:40 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: read_entry.c,v 1.68 2000/10/04 02:32:04 tom Exp $")
d181 3
a183 3
	    ("TERMTYPE name_size=%d, bool=%d/%d, num=%d/%d str=%d/%d(%d)",
	    name_size, bool_count, BOOLCOUNT, num_count, NUMCOUNT,
	    str_count, STRCOUNT, str_size));
d286 2
a287 1
		ext_bool_count, ext_num_count, ext_str_count, ext_str_size, ext_str_limit));
d290 1
a290 1
		ext_bool_count, tell(fd)));
d293 1
a293 1
		    ext_bool_count) != ext_bool_count)
d299 1
a299 1
		ext_num_count, tell(fd)));
d313 1
a313 1
		ext_str_limit, tell(fd)));
d325 2
a326 2
		("Before computing extended-string capabilities str_count=%d, ext_str_count=%d",
		    str_count, ext_str_count));
d328 1
a328 1
		ext_str_limit, ptr->ext_str_table);
d331 2
a332 2
			i, i + str_count,
			_nc_visbuf(ptr->Strings[i + str_count])));
d337 2
a338 2
			i + STRCOUNT,
			_nc_visbuf(ptr->Strings[i + STRCOUNT])));
d346 2
a347 2
		("ext_NAMES starting @@%d in extended_strings, first = %s",
		    base, _nc_visbuf(ptr->ext_str_table + base)));
d349 1
a349 1
		ext_str_limit, ptr->ext_str_table + base);
d353 3
a355 3
		ptr->num_Booleans, ptr->ext_Booleans,
		ptr->num_Numbers, ptr->ext_Numbers,
		ptr->num_Strings, ptr->ext_Strings));
d362 1
a362 1
		bool_count, num_count, str_count));
d409 1
a409 1
    const char *const dir, const char *ttn, TERMTYPE * const tp)
d426 1
a426 1
    ttn, TERMTYPE * const tp)
@


1.9
log
@update to ncurses-5.0-20000311
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.8 2000/03/10 01:35:04 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: read_entry.c,v 1.67 2000/03/11 12:35:45 tom Exp $")
d84 1
a84 1
	} else if (!have_tic_directory) {
d86 1
a86 1
	    if (!issetugid() && (envp = getenv("TERMINFO")) != 0)
d487 11
a497 3
    if (!issetugid() && (envp = getenv("TERMINFO")) != 0
	&& _nc_read_tic_entry(filename, _nc_tic_dir(envp), ttn, tp) == 1)
	return 1;
d499 3
a501 4
    if ((envp = _nc_home_terminfo()) != 0) {
	if (_nc_read_tic_entry(filename, envp, ttn, tp) == 1) {
	    return (1);
	}
a502 4

    /* this is an ncurses extension */
    if (!issetugid() && (envp = getenv("TERMINFO_DIRS")) != 0)
	return _nc_read_terminfo_dirs(envp, filename, ttn, tp);
@


1.8
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.7 2000/01/09 05:06:02 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: read_entry.c,v 1.66 2000/02/13 01:01:26 tom Exp $")
d362 1
d364 1
@


1.7
log
@Update to ncurses-5.0-20000108:
+ add prototype for erase() to curses.h
+ add TRACE_DATABASE flag for trace().
+ formatting changes (style)
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.6 2000/01/02 22:06:51 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d46 1
a46 1
MODULE_ID("$From: read_entry.c,v 1.65 2000/01/08 18:59:49 tom Exp $")
@


1.6
log
@+ corrected conversion from terminfo rs2 to termcap rs (cf: 980704)
+ make conversion to termcap ug (underline glitch) more consistently applied.
+ modify read_termtype(), fixing 'toe', which could dump core when it
found an incomplete entry such as "dumb" because it did not
initialize its buffer for _nc_read_file_entry().
+ use explicit VALID_NUMERIC() checks in a few places that had been
overlooked, and add a check to ensure that init_tabs is nonzero,
to avoid divide-by-zero (reported by Todd C Miller).
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.5 1999/08/15 11:40:56 millert Exp $	*/
a42 4
#if HAVE_FCNTL_H
#include <fcntl.h>
#endif

d46 1
a46 1
MODULE_ID("$From: read_entry.c,v 1.63 2000/01/01 23:06:40 tom Exp $")
d48 2
a49 8
#ifndef O_BINARY
#define O_BINARY 0
#endif

#if 0
#define TRACE_IN(p) DEBUG(2, p)
#else
#define TRACE_IN(p)		/*nothing */
d116 1
a116 1
	TRACE_IN(("get Numbers[%d]=%d", i, Numbers[i]));
d135 1
a135 1
	    TRACE_IN(("Strings[%d] = %s", i, _nc_visbuf(Strings[i])));
d163 1
a163 1
    TRACE_IN(("READ termtype header @@%d", tell(fd)));
d180 4
a183 2
    TRACE_IN(("header is %d/%d/%d/%d(%d)", name_size, bool_count, num_count,
	    str_count, str_size));
d257 1
a257 1
    TRACE_IN(("READ extended_header @@%d", tell(fd)));
d285 2
a286 2
	TRACE_IN(("extended header is %d/%d/%d(%d:%d)", ext_bool_count,
		ext_num_count, ext_str_count, ext_str_size, ext_str_limit));
d288 2
a289 1
	TRACE_IN(("READ %d extended-booleans @@%d", ext_bool_count, tell(fd)));
d292 1
a292 1
		ext_bool_count) != ext_bool_count)
d297 2
a298 1
	TRACE_IN(("READ %d extended-numbers @@%d", ext_num_count, tell(fd)));
d302 1
a302 1
	    TRACE_IN(("Before converting extended-numbers"));
d306 1
a306 1
	TRACE_IN(("READ extended-offsets @@%d", tell(fd)));
d311 3
a313 2
	TRACE_IN(("READ %d bytes of extended-strings @@%d", ext_str_limit,
		tell(fd)));
d319 1
a319 1
	    TRACE_IN(("first extended-string is %s", _nc_visbuf(ptr->ext_str_table)));
d323 2
a324 1
	    TRACE_IN(("Before computing extended-string capabilities str_count=%d, ext_str_count=%d",
d329 2
a330 1
		TRACE_IN(("MOVE from [%d:%d] %s", i, i + str_count,
d335 3
a337 2
		TRACE_IN(("... to    [%d] %s", i + STRCOUNT,
			    _nc_visbuf(ptr->Strings[i + STRCOUNT])));
d344 2
a345 1
	    TRACE_IN(("ext_NAMES starting @@%d in extended_strings, first = %s",
d356 1
a356 1
	TRACE_IN(("extend: num_Booleans:%d", ptr->num_Booleans));
d361 2
a362 4
		bool_count,
		num_count,
		str_count));
	TRACE_IN(("normal: num_Booleans:%d", ptr->num_Booleans));
@


1.5
log
@Update to ncurses-5.0-990814
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.4 1999/03/02 06:23:29 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Free Software Foundation, Inc.                        *
a35 2


d50 1
a50 1
MODULE_ID("$From: read_entry.c,v 1.61 1999/07/24 20:07:20 tom Exp $")
d59 1
a59 1
#define TRACE_IN(p) /*nothing*/
d85 2
a86 1
const char *_nc_tic_dir(const char *path)
d108 2
a109 1
void _nc_keep_tic_dir(const char *path)
d115 2
a116 1
static void convert_shorts(char *buf, short *Numbers, int count)
d119 2
a120 3
    for (i = 0; i < count; i++)
    {
	if (IS_NEG1(buf + 2*i))
d122 1
a122 1
	else if (IS_NEG2(buf + 2*i))
d125 1
a125 1
	    Numbers[i] = LOW_MSB(buf + 2*i);
d130 2
a131 1
static void convert_strings(char *buf, char **Strings, int count, int size, char *table)
d137 1
a137 1
	if (IS_NEG1(buf + 2*i)) {
d139 1
a139 1
	} else if (IS_NEG2(buf + 2*i)) {
d141 1
a141 1
	} else if (LOW_MSB(buf + 2*i) > size) {
d144 1
a144 1
	    Strings[i] = (LOW_MSB(buf+2*i) + table);
d165 2
a166 1
static int read_termtype(int fd, TERMTYPE *ptr)
d169 3
a171 3
    int		name_size, bool_count, num_count, str_count, str_size;
    int		i;
    char	buf[MAX_ENTRY_SIZE];
d175 2
d179 2
a180 2
     || LOW_MSB(buf) != MAGIC) {
	return(0);
d184 1
a184 1
    name_size  = LOW_MSB(buf + 2);
d186 12
a197 11
    num_count  = LOW_MSB(buf + 6);
    str_count  = LOW_MSB(buf + 8);
    str_size   = LOW_MSB(buf + 10);

    TRACE_IN(("header is %d/%d/%d/%d(%d)", name_size, bool_count, num_count, str_count, str_size));
    if (name_size  < 0
     || bool_count < 0
     || num_count  < 0
     || str_count  < 0
     || str_size   < 0) {
	return(0);
d202 3
a204 3
	if (str_count*2 >= (int) sizeof(buf)
	 || (ptr->str_table = typeMalloc(char, (unsigned)str_size)) == 0) {
	    return(0);
d211 1
a211 1
    read(fd, buf, min(MAX_NAME_SIZE, (unsigned)name_size));
d215 1
a215 1
	return(0);
d223 2
a224 2
     || read(fd, ptr->Booleans, (unsigned)bool_count) < bool_count) {
	return(0);
d237 2
a238 2
     || !read_shorts(fd, buf, num_count)) {
	return(0);
d243 1
a243 1
	return(0);
d245 1
a245 2
    if (str_count)
    {
d248 1
a248 1
	    return(0);
d251 2
a252 2
	if (read(fd, ptr->str_table, (unsigned)str_size) != str_size)
	    return(0);
a254 1

d258 2
a259 2
    ptr->num_Numbers  = NUMCOUNT;
    ptr->num_Strings  = STRCOUNT;
d268 4
a271 4
	int ext_num_count  = LOW_MSB(buf + 2);
	int ext_str_count  = LOW_MSB(buf + 4);
	int ext_str_size   = LOW_MSB(buf + 6);
	int ext_str_limit  = LOW_MSB(buf + 8);
d276 8
a283 8
	 || ext_str_size >= (int) sizeof(buf)
	 || ext_str_limit >= (int) sizeof(buf)
	 || ext_bool_count < 0
	 || ext_num_count  < 0
	 || ext_str_count  < 0
	 || ext_str_size   < 0
	 || ext_str_limit  < 0)
	    return(0);
d286 2
a287 2
	ptr->num_Numbers  = NUMCOUNT + ext_num_count;
	ptr->num_Strings  = STRCOUNT + ext_str_count;
d289 1
a289 1
	ptr->Booleans = typeRealloc(char, ptr->num_Booleans,ptr->Booleans);
d291 1
a291 1
	ptr->Strings = typeRealloc(char*, ptr->num_Strings, ptr->Strings);
d293 2
a294 1
	TRACE_IN(("extended header is %d/%d/%d(%d:%d)", ext_bool_count, ext_num_count, ext_str_count, ext_str_size, ext_str_limit));
d298 3
a300 2
	    if (read(fd, ptr->Booleans + BOOLCOUNT, (unsigned)ext_bool_count) != ext_bool_count)
		return(0);
d307 1
a307 1
		return(0);
d314 2
a315 2
	 && !read_shorts(fd, buf, ext_str_count+need))
	    return(0);
d317 2
a318 1
	TRACE_IN(("READ %d bytes of extended-strings @@%d", ext_str_limit, tell(fd)));
d321 1
a321 1
		return(0);
d323 1
a323 1
		return(0);
d328 12
a339 8
	    TRACE_IN(("Before computing extended-string capabilities str_count=%d, ext_str_count=%d", str_count, ext_str_count));
	    convert_strings(buf, ptr->Strings + str_count, ext_str_count, ext_str_limit, ptr->ext_str_table);
	    for (i = ext_str_count-1; i >= 0; i--) {
		TRACE_IN(("MOVE from [%d:%d] %s", i, i+str_count, _nc_visbuf(ptr->Strings[i+str_count])));
		ptr->Strings[i+STRCOUNT] = ptr->Strings[i+str_count];
		if (VALID_STRING(ptr->Strings[i+STRCOUNT])) 
		    base += (strlen(ptr->Strings[i+STRCOUNT]) + 1);
		TRACE_IN(("... to    [%d] %s", i+STRCOUNT, _nc_visbuf(ptr->Strings[i+STRCOUNT])));
d345 5
a349 3
		return(0);
	    TRACE_IN(("ext_NAMES starting @@%d in extended_strings, first = %s", base, _nc_visbuf(ptr->ext_str_table+base)));
	    convert_strings(buf + (2 * ext_str_count), ptr->ext_Names, need, ext_str_limit, ptr->ext_str_table + base);
d353 3
a355 3
	    ptr->num_Booleans, ptr->ext_Booleans,
	    ptr->num_Numbers,  ptr->ext_Numbers,
	    ptr->num_Strings,  ptr->ext_Strings));
d362 3
a364 3
	    bool_count,
	    num_count,
	    str_count));
d375 1
a375 1
    return(1);
d378 2
a379 1
int _nc_read_file_entry(const char *const filename, TERMTYPE *ptr)
d386 1
a386 1
	return(1);
d390 1
a390 1
     || (fd = open(filename, O_RDONLY|O_BINARY)) < 0) {
d392 1
a392 1
	return(0);
d407 3
a409 2
static int _nc_read_tic_entry(char *const filename,
	const char *const dir, const char *ttn, TERMTYPE *const tp)
d414 4
a417 4
	if (strlen(dir) > MAX_TPATH)
		return 0;
	(void) sprintf(filename, "%s/%s", dir, ttn);
	return _nc_read_file_entry(filename, tp);
d424 3
a426 1
static int _nc_read_terminfo_dirs(const char *dirs, char *const filename, const char *const ttn, TERMTYPE *const tp)
d428 21
a448 23
	char *list, *a;
	const char *b;
	int code = 0;

	/* we'll modify the argument, so we must copy */
	if ((b = a = list = strdup(dirs)) == NULL)
		return(0);

	for (;;) {
		int c = *a;
		if (c == 0 || c == ':') {
			*a = 0;
			if ((b + 1) >= a)
				b = TERMINFO;
			if (_nc_read_tic_entry(filename, b, ttn, tp) == 1) {
				code = 1;
				break;
			}
			b = a + 1;
			if (c == 0)
				break;
		}
		a++;
d450 2
d453 2
a454 2
	free(list);
	return(code);
d466 2
a467 1
int _nc_read_entry(const char *const tn, char *const filename, TERMTYPE *const tp)
d469 2
a470 2
char		*envp;
char		ttn[MAX_ALIAS + 3];
d473 3
a475 3
	/* First check the BSD terminfo.db file */
	if (_nc_read_bsd_terminfo_entry(tn, filename, tp) == 1)
		return 1;
d478 23
a500 2
	/* truncate the terminal name to prevent dangerous buffer airline */
	(void) sprintf(ttn, "%c/%.*s", *tn, MAX_ALIAS, tn);
d502 4
a505 25
	/* This is System V behavior, in conjunction with our requirements for
	 * writing terminfo entries.
	 */
	if (have_tic_directory
	 && _nc_read_tic_entry(filename, _nc_tic_dir(0), ttn, tp) == 1)
		return 1;

	if (!issetugid() && (envp = getenv("TERMINFO")) != 0
	 && _nc_read_tic_entry(filename, _nc_tic_dir(envp), ttn, tp) == 1)
		return 1;

	if ((envp = _nc_home_terminfo()) != 0) {
		if (_nc_read_tic_entry(filename, envp, ttn, tp) == 1) {
			return(1);
		}
	}

	/* this is an ncurses extension */
	if (!issetugid() && (envp = getenv("TERMINFO_DIRS")) != 0)
		return _nc_read_terminfo_dirs(envp, filename, ttn, tp);

	/* Try the system directory.  Note that the TERMINFO_DIRS value, if
	 * defined by the configure script, begins with a ":", which will be
	 * interpreted as TERMINFO.
	 */
d507 1
a507 1
	return _nc_read_terminfo_dirs(TERMINFO_DIRS, filename, ttn, tp);
d509 1
a509 1
	return _nc_read_tic_entry(filename, TERMINFO, ttn, tp);
a511 1

@


1.4
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.3 1999/01/23 18:31:02 millert Exp $	*/
d52 1
a52 1
MODULE_ID("$From: read_entry.c,v 1.60 1999/03/01 23:59:28 tom Exp $")
d369 1
a369 1
    int code, fd;
@


1.3
log
@make _nc_read_file_entry() look in terminfo.db too.  Makes the -A and -B flags of infocmp more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.2 1999/01/22 04:50:43 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a48 1
#include <term.h>
d52 1
a52 1
MODULE_ID("$From: read_entry.c,v 1.47 1998/12/20 02:51:50 tom Exp $")
d58 6
d115 50
a164 1
int _nc_read_file_entry(const char *const filename, TERMTYPE *ptr)
d168 1
a168 1
    int		i, fd, numread;
d171 1
a171 12
#ifdef __OpenBSD__
    if (_nc_read_bsd_terminfo_file(filename, ptr) == 1)
	return(1);
#endif /* __OpenBSD__ */

    if (_nc_access(filename, R_OK) < 0
     || (fd = open(filename, O_RDONLY|O_BINARY)) < 0) {
	T(("cannot open terminfo %s (errno=%d)", filename, errno));
	return(0);
    }

    T(("read terminfo %s", filename));
d174 2
a175 4
    (void) read(fd, buf, 12);
    if (LOW_MSB(buf) != MAGIC)
    {
	close(fd);
d178 2
d186 10
a195 2
    if (str_size)
    {
d197 2
a198 4
	ptr->str_table = malloc((unsigned)str_size);
	if (ptr->str_table == 0)
	{
	    close(fd);
d201 2
a203 2
    else
	str_count = 0;
d205 1
a205 1
    /* grab the name */
d208 1
a208 1
    ptr->term_names = calloc(strlen(buf) + 1, sizeof(char));
a209 3
	if (str_size)
	    free(ptr->str_table);
	close(fd);
d217 4
a220 6
    read(fd, ptr->Booleans, min(BOOLCOUNT, (unsigned)bool_count));
    if (bool_count > BOOLCOUNT)
	lseek(fd, (off_t) (bool_count - BOOLCOUNT), 1);
    else
	for (i=bool_count; i < BOOLCOUNT; i++)
	    ptr->Booleans[i] = 0;
d228 1
a228 2
    if ((name_size + bool_count) % 2 != 0)
	read(fd, buf, 1);
d231 3
a233 9
    (void) read(fd, buf, min(NUMCOUNT*2, (unsigned)num_count*2));
    for (i = 0; i < min(num_count, NUMCOUNT); i++)
    {
	if (IS_NEG1(buf + 2*i))
	    ptr->Numbers[i] = ABSENT_NUMERIC;
	else if (IS_NEG2(buf + 2*i))
	    ptr->Numbers[i] = CANCELLED_NUMERIC;
	else
	    ptr->Numbers[i] = LOW_MSB(buf + 2*i);
d235 4
a238 5
    if (num_count > NUMCOUNT)
	lseek(fd, (off_t) (2 * (num_count - NUMCOUNT)), 1);
    else
	for (i=num_count; i < NUMCOUNT; i++)
	    ptr->Numbers[i] = ABSENT_NUMERIC;
d242 2
a243 3
	if (str_count*2 >= MAX_ENTRY_SIZE)
	{
	    close(fd);
d246 64
a309 5
	/* grab the string offsets */
	numread = read(fd, buf, (unsigned)(str_count*2));
	if (numread < str_count*2)
	{
	    close(fd);
d311 8
d320 11
a330 12
	for (i = 0; i < numread/2; i++)
	{
	    if (i >= STRCOUNT)
		break;
	    if (IS_NEG1(buf + 2*i))
		ptr->Strings[i] = ABSENT_STRING;
	    else if (IS_NEG2(buf + 2*i))
		ptr->Strings[i] = CANCELLED_STRING;
	    else if (LOW_MSB(buf + 2*i) > str_size)
		ptr->Strings[i] = ABSENT_STRING;
	    else
		ptr->Strings[i] = (LOW_MSB(buf+2*i) + ptr->str_table);
a331 1
    }
d333 6
a338 5
    if (str_count > STRCOUNT)
	lseek(fd, (off_t) (2 * (str_count - STRCOUNT)), 1);
    else
	for (i = str_count; i < STRCOUNT; i++)
	    ptr->Strings[i] = ABSENT_STRING;
d340 8
a347 1
    if (str_size)
d349 5
a353 7
	/* finally, grab the string table itself */
	numread = read(fd, ptr->str_table, (unsigned)str_size);
	if (numread != str_size)
	{
	    close(fd);
	    return(0);
	}
d356 19
a374 3
    /* make sure all strings are NUL terminated */
    for (i = str_count; i < STRCOUNT; i++) {
	char *p;
d376 4
a379 8
	if (VALID_STRING(ptr->Strings[i])) {
	    for (p = ptr->Strings[i]; p <= ptr->str_table + str_size; p++)
		if (*p == '\0')
		    break;
	    /* if there is no NUL, ignore the string */
	    if (p > ptr->str_table + str_size)
		ptr->Strings[i] = ABSENT_STRING;
	}
d382 3
d386 2
a387 1
    return(1);
d417 1
a417 1
	if ((b = a = list = malloc(strlen(dirs) + 1)) == NULL)
a418 1
	(void) strcpy(list, dirs);
d475 1
a475 1
	if (!issetugid() && (envp = _nc_home_terminfo()) != 0) {
@


1.2
log
@Move call to _nc_read_bsd_terminfo_entry() to _nc_read_entry() so reading
terminfo.db is transparent.  This requires us to be able to tell which
of the entries in pathvec held the terminfo entry.  To make that work
we only pass one pathname to cgetent(3) at a time.  This might be a
slight performance hit but should not be noticable in normal use.
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.1 1999/01/18 19:10:22 millert Exp $	*/
d116 5
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: read_entry.c,v 1.5 1998/10/31 06:30:31 millert Exp $	*/
d51 1
d328 6
@

