head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.28
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.24
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.26
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.18
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.14
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.10
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.8
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.4
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.16
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.24.17.25.48;	author moritz;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.10.21.38.16;	author cloder;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.12.00.29.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.15.23.33.48;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.17.19.16.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.22.18.01.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.04.16.49.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.16.45.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.13.23.53.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.12.12.04.49.19;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.12.06.02.12.46;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.08.15.11.40.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.06.23.28;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.13;	author millert;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2006,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 *	captoinfo.c --- conversion between termcap and terminfo formats
 *
 *	The captoinfo() code was swiped from Ross Ridge's mytinfo package,
 *	adapted to fit ncurses by Eric S. Raymond <esr@@snark.thyrsus.com>.
 *
 *	There is just one entry point:
 *
 *	char *_nc_captoinfo(n, s, parameterized)
 *
 *	Convert value s for termcap string capability named n into terminfo
 *	format.
 *
 *	This code recognizes all the standard 4.4BSD %-escapes:
 *
 *	%%       output `%'
 *	%d       output value as in printf %d
 *	%2       output value as in printf %2d
 *	%3       output value as in printf %3d
 *	%.       output value as in printf %c
 *	%+x      add x to value, then do %.
 *	%>xy     if value > x then add y, no output
 *	%r       reverse order of two parameters, no output
 *	%i       increment by one, no output
 *	%n       exclusive-or all parameters with 0140 (Datamedia 2500)
 *	%B       BCD (16*(value/10)) + (value%10), no output
 *	%D       Reverse coding (value - 2*(value%16)), no output (Delta Data).
 *
 *	Also, %02 and %03 are accepted as synonyms for %2 and %3.
 *
 *	Besides all the standard termcap escapes, this translator understands
 *	the following extended escapes:
 *
 *	used by GNU Emacs termcap libraries
 *		%a[+*-/=][cp]x	GNU arithmetic.
 *		%m		xor the first two parameters by 0177
 *		%b		backup to previous parameter
 *		%f		skip this parameter
 *
 *	used by the University of Waterloo (MFCF) termcap libraries
 *		%-x	 subtract parameter FROM char x and output it as a char
 *		%ax	 add the character x to parameter
 *
 *	If #define WATERLOO is on, also enable these translations:
 *
 *		%sx	 subtract parameter FROM the character x
 *
 *	By default, this Waterloo translations are not compiled in, because
 *	the Waterloo %s conflicts with the way terminfo uses %s in strings for
 *	function programming.
 *
 *	Note the two definitions of %a: the GNU definition is translated if the
 *	characters after the 'a' are valid for it, otherwise the UW definition
 *	is translated.
 */

#include <curses.priv.h>

#include <ctype.h>
#include <tic.h>

MODULE_ID("$Id: captoinfo.c,v 1.52 2008/08/16 19:24:51 tom Exp $")

#define MAX_PUSHED	16	/* max # args we can push onto the stack */

static int stack[MAX_PUSHED];	/* the stack */
static int stackptr;		/* the next empty place on the stack */
static int onstack;		/* the top of stack */
static int seenm;		/* seen a %m */
static int seenn;		/* seen a %n */
static int seenr;		/* seen a %r */
static int param;		/* current parameter */
static char *dp;		/* pointer to end of the converted string */

static char *my_string;
static size_t my_length;

static char *
init_string(void)
/* initialize 'my_string', 'my_length' */
{
    if (my_string == 0)
	my_string = typeMalloc(char, my_length = 256);
    if (my_string == 0)
	_nc_err_abort(MSG_NO_MEMORY);

    *my_string = '\0';
    return my_string;
}

static char *
save_string(char *d, const char *const s)
{
    size_t have = (d - my_string);
    size_t need = have + strlen(s) + 2;
    size_t copied;
    if (need > my_length) {
	my_string = (char *) realloc(my_string, my_length = (need + need));
	if (my_string == 0)
	    _nc_err_abort(MSG_NO_MEMORY);
	d = my_string + have;
    }
    if ((copied = strlcpy(d, s, my_length - have)) >= my_length - have)
	    _nc_err_abort("Buffer overflow");
    return d + copied;
}

static NCURSES_INLINE char *
save_char(char *s, int c)
{
    static char temp[2];
    temp[0] = (char) c;
    return save_string(s, temp);
}

static void
push(void)
/* push onstack on to the stack */
{
    if (stackptr >= MAX_PUSHED)
	_nc_warning("string too complex to convert");
    else
	stack[stackptr++] = onstack;
}

static void
pop(void)
/* pop the top of the stack into onstack */
{
    if (stackptr == 0) {
	if (onstack == 0)
	    _nc_warning("I'm confused");
	else
	    onstack = 0;
    } else
	onstack = stack[--stackptr];
    param++;
}

static int
cvtchar(register const char *sp)
/* convert a character to a terminfo push */
{
    unsigned char c = 0;
    int len;

    switch (*sp) {
    case '\\':
	switch (*++sp) {
	case '\'':
	case '$':
	case '\\':
	case '%':
	    c = (unsigned char) (*sp);
	    len = 2;
	    break;
	case '\0':
	    c = '\\';
	    len = 1;
	    break;
	case '0':
	case '1':
	case '2':
	case '3':
	    len = 1;
	    while (isdigit(UChar(*sp))) {
		c = 8 * c + (*sp++ - '0');
		len++;
	    }
	    break;
	default:
	    c = (unsigned char) (*sp);
	    len = 2;
	    break;
	}
	break;
    case '^':
	c = (*++sp & 0x1f);
	len = 2;
	break;
    default:
	c = (unsigned char) (*sp);
	len = 1;
    }
    if (isgraph(c) && c != ',' && c != '\'' && c != '\\' && c != ':') {
	dp = save_string(dp, "%\'");
	dp = save_char(dp, c);
	dp = save_char(dp, '\'');
    } else {
	dp = save_string(dp, "%{");
	if (c > 99)
	    dp = save_char(dp, c / 100 + '0');
	if (c > 9)
	    dp = save_char(dp, ((int) (c / 10)) % 10 + '0');
	dp = save_char(dp, c % 10 + '0');
	dp = save_char(dp, '}');
    }
    return len;
}

static void
getparm(int parm, int n)
/* push n copies of param on the terminfo stack if not already there */
{
    if (seenr) {
	if (parm == 1)
	    parm = 2;
	else if (parm == 2)
	    parm = 1;
    }
    if (onstack == parm) {
	if (n > 1) {
	    _nc_warning("string may not be optimal");
	    dp = save_string(dp, "%Pa");
	    while (n--) {
		dp = save_string(dp, "%ga");
	    }
	}
	return;
    }
    if (onstack != 0)
	push();

    onstack = parm;

    while (n--) {
	dp = save_string(dp, "%p");
	dp = save_char(dp, '0' + parm);
    }

    if (seenn && parm < 3) {
	dp = save_string(dp, "%{96}%^");
    }

    if (seenm && parm < 3) {
	dp = save_string(dp, "%{127}%^");
    }
}

/*
 * Convert a termcap string to terminfo format.
 * 'cap' is the relevant terminfo capability index.
 * 's' is the string value of the capability.
 * 'parameterized' tells what type of translations to do:
 *	% translations if 1
 *	pad translations if >=0
 */
NCURSES_EXPORT(char *)
_nc_captoinfo(const char *cap, const char *s, int const parameterized)
{
    const char *capstart;

    stackptr = 0;
    onstack = 0;
    seenm = 0;
    seenn = 0;
    seenr = 0;
    param = 1;

    dp = init_string();

    /* skip the initial padding (if we haven't been told not to) */
    capstart = 0;
    if (s == 0)
	s = "";
    if (parameterized >= 0 && isdigit(UChar(*s)))
	for (capstart = s;; s++)
	    if (!(isdigit(UChar(*s)) || *s == '*' || *s == '.'))
		break;

    while (*s != '\0') {
	switch (*s) {
	case '%':
	    s++;
	    if (parameterized < 1) {
		dp = save_char(dp, '%');
		break;
	    }
	    switch (*s++) {
	    case '%':
		dp = save_char(dp, '%');
		break;
	    case 'r':
		if (seenr++ == 1) {
		    _nc_warning("saw %%r twice in %s", cap);
		}
		break;
	    case 'm':
		if (seenm++ == 1) {
		    _nc_warning("saw %%m twice in %s", cap);
		}
		break;
	    case 'n':
		if (seenn++ == 1) {
		    _nc_warning("saw %%n twice in %s", cap);
		}
		break;
	    case 'i':
		dp = save_string(dp, "%i");
		break;
	    case '6':
	    case 'B':
		getparm(param, 1);
		dp = save_string(dp, "%{10}%/%{16}%*");
		getparm(param, 1);
		dp = save_string(dp, "%{10}%m%+");
		break;
	    case '8':
	    case 'D':
		getparm(param, 2);
		dp = save_string(dp, "%{2}%*%-");
		break;
	    case '>':
		getparm(param, 2);
		/* %?%{x}%>%t%{y}%+%; */
		dp = save_string(dp, "%?");
		s += cvtchar(s);
		dp = save_string(dp, "%>%t");
		s += cvtchar(s);
		dp = save_string(dp, "%+%;");
		break;
	    case 'a':
		if ((*s == '=' || *s == '+' || *s == '-'
		     || *s == '*' || *s == '/')
		    && (s[1] == 'p' || s[1] == 'c')
		    && s[2] != '\0') {
		    int l;
		    l = 2;
		    if (*s != '=')
			getparm(param, 1);
		    if (s[1] == 'p') {
			getparm(param + s[2] - '@@', 1);
			if (param != onstack) {
			    pop();
			    param--;
			}
			l++;
		    } else
			l += cvtchar(s + 2);
		    switch (*s) {
		    case '+':
			dp = save_string(dp, "%+");
			break;
		    case '-':
			dp = save_string(dp, "%-");
			break;
		    case '*':
			dp = save_string(dp, "%*");
			break;
		    case '/':
			dp = save_string(dp, "%/");
			break;
		    case '=':
			if (seenr) {
			    if (param == 1)
				onstack = 2;
			    else if (param == 2)
				onstack = 1;
			    else
				onstack = param;
			} else
			    onstack = param;
			break;
		    }
		    s += l;
		    break;
		}
		getparm(param, 1);
		s += cvtchar(s);
		dp = save_string(dp, "%+");
		break;
	    case '+':
		getparm(param, 1);
		s += cvtchar(s);
		dp = save_string(dp, "%+%c");
		pop();
		break;
	    case 's':
#ifdef WATERLOO
		s += cvtchar(s);
		getparm(param, 1);
		dp = save_string(dp, "%-");
#else
		getparm(param, 1);
		dp = save_string(dp, "%s");
		pop();
#endif /* WATERLOO */
		break;
	    case '-':
		s += cvtchar(s);
		getparm(param, 1);
		dp = save_string(dp, "%-%c");
		pop();
		break;
	    case '.':
		getparm(param, 1);
		dp = save_string(dp, "%c");
		pop();
		break;
	    case '0':		/* not clear any of the historical termcaps did this */
		if (*s == '3')
		    goto see03;
		else if (*s != '2')
		    goto invalid;
		/* FALLTHRU */
	    case '2':
		getparm(param, 1);
		dp = save_string(dp, "%2d");
		pop();
		break;
	    case '3':
	      see03:
		getparm(param, 1);
		dp = save_string(dp, "%3d");
		pop();
		break;
	    case 'd':
		getparm(param, 1);
		dp = save_string(dp, "%d");
		pop();
		break;
	    case 'f':
		param++;
		break;
	    case 'b':
		param--;
		break;
	    case '\\':
		dp = save_string(dp, "%\\");
		break;
	    default:
	      invalid:
		dp = save_char(dp, '%');
		s--;
		_nc_warning("unknown %% code %s (%#x) in %s",
			    unctrl((chtype) *s), UChar(*s), cap);
		break;
	    }
	    break;
#ifdef REVISIBILIZE
	case '\\':
	    dp = save_char(dp, *s++);
	    dp = save_char(dp, *s++);
	    break;
	case '\n':
	    dp = save_string(dp, "\\n");
	    s++;
	    break;
	case '\t':
	    dp = save_string(dp, "\\t");
	    s++;
	    break;
	case '\r':
	    dp = save_string(dp, "\\r");
	    s++;
	    break;
	case '\200':
	    dp = save_string(dp, "\\0");
	    s++;
	    break;
	case '\f':
	    dp = save_string(dp, "\\f");
	    s++;
	    break;
	case '\b':
	    dp = save_string(dp, "\\b");
	    s++;
	    break;
	case ' ':
	    dp = save_string(dp, "\\s");
	    s++;
	    break;
	case '^':
	    dp = save_string(dp, "\\^");
	    s++;
	    break;
	case ':':
	    dp = save_string(dp, "\\:");
	    s++;
	    break;
	case ',':
	    dp = save_string(dp, "\\,");
	    s++;
	    break;
	default:
	    if (*s == '\033') {
		dp = save_string(dp, "\\E");
		s++;
	    } else if (*s > 0 && *s < 32) {
		dp = save_char(dp, '^');
		dp = save_char(dp, *s + '@@');
		s++;
	    } else if (*s <= 0 || *s >= 127) {
		dp = save_char(dp, '\\');
		dp = save_char(dp, ((*s & 0300) >> 6) + '0');
		dp = save_char(dp, ((*s & 0070) >> 3) + '0');
		dp = save_char(dp, (*s & 0007) + '0');
		s++;
	    } else
		dp = save_char(dp, *s++);
	    break;
#else
	default:
	    dp = save_char(dp, *s++);
	    break;
#endif
	}
    }

    /*
     * Now, if we stripped off some leading padding, add it at the end
     * of the string as mandatory padding.
     */
    if (capstart) {
	dp = save_string(dp, "$<");
	for (s = capstart;; s++)
	    if (isdigit(UChar(*s)) || *s == '*' || *s == '.')
		dp = save_char(dp, *s);
	    else
		break;
	dp = save_string(dp, "/>");
    }

    (void) save_char(dp, '\0');
    return (my_string);
}

/*
 * Check for an expression that corresponds to "%B" (BCD):
 *	(parameter / 10) * 16 + (parameter % 10)
 */
static int
bcd_expression(const char *str)
{
    /* leave this non-const for HPUX */
    static char fmt[] = "%%p%c%%{10}%%/%%{16}%%*%%p%c%%{10}%%m%%+";
    int len = 0;
    char ch1, ch2;

    if (sscanf(str, fmt, &ch1, &ch2) == 2
	&& isdigit(UChar(ch1))
	&& isdigit(UChar(ch2))
	&& (ch1 == ch2)) {
	len = 28;
#ifndef NDEBUG
	{
	    char buffer[80];
	    int tst;
	    snprintf(buffer, sizeof(buffer), fmt, ch1, ch2);
	    tst = strlen(buffer) - 1;
	    assert(len == tst);
	}
#endif
    }
    return len;
}

static char *
save_tc_char(char *bufptr, int c1)
{
    char temp[80];

    if (is7bits(c1) && isprint(c1)) {
	if (c1 == ':' || c1 == '\\')
	    bufptr = save_char(bufptr, '\\');
	bufptr = save_char(bufptr, c1);
    } else {
	if (c1 == (c1 & 0x1f))	/* iscntrl() returns T on 255 */
	    (void) strlcpy(temp, unctrl((chtype) c1), sizeof(temp));
	else
	    (void) snprintf(temp, sizeof(temp), "\\%03o", c1);
	bufptr = save_string(bufptr, temp);
    }
    return bufptr;
}

static char *
save_tc_inequality(char *bufptr, int c1, int c2)
{
    bufptr = save_string(bufptr, "%>");
    bufptr = save_tc_char(bufptr, c1);
    bufptr = save_tc_char(bufptr, c2);
    return bufptr;
}

/*
 * Here are the capabilities infotocap assumes it can translate to:
 *
 *     %%       output `%'
 *     %d       output value as in printf %d
 *     %2       output value as in printf %2d
 *     %3       output value as in printf %3d
 *     %.       output value as in printf %c
 *     %+c      add character c to value, then do %.
 *     %>xy     if value > x then add y, no output
 *     %r       reverse order of two parameters, no output
 *     %i       increment by one, no output
 *     %n       exclusive-or all parameters with 0140 (Datamedia 2500)
 *     %B       BCD (16*(value/10)) + (value%10), no output
 *     %D       Reverse coding (value - 2*(value%16)), no output (Delta Data).
 *     %m       exclusive-or all parameters with 0177 (not in 4.4BSD)
 */

/*
 * Convert a terminfo string to termcap format.  Parameters are as in
 * _nc_captoinfo().
 */
NCURSES_EXPORT(char *)
_nc_infotocap(const char *cap GCC_UNUSED, const char *str, int const parameterized)
{
    int seenone = 0, seentwo = 0, saw_m = 0, saw_n = 0;
    const char *padding;
    const char *trimmed = 0;
    char ch1 = 0, ch2 = 0;
    char *bufptr = init_string();
    int len;
    bool syntax_error = FALSE;

    /* we may have to move some trailing mandatory padding up front */
    padding = str + strlen(str) - 1;
    if (padding > str && *padding == '>' && *--padding == '/') {
	--padding;
	while (isdigit(UChar(*padding)) || *padding == '.' || *padding == '*')
	    padding--;
	if (padding > str && *padding == '<' && *--padding == '$')
	    trimmed = padding;
	padding += 2;

	while (isdigit(UChar(*padding)) || *padding == '.' || *padding == '*')
	    bufptr = save_char(bufptr, *padding++);
    }

    for (; *str && str != trimmed; str++) {
	int c1, c2;
	char *cp = 0;

	if (str[0] == '\\' && (str[1] == '^' || str[1] == ',')) {
	    bufptr = save_char(bufptr, *++str);
	} else if (str[0] == '$' && str[1] == '<') {	/* discard padding */
	    str += 2;
	    while (isdigit(UChar(*str))
		   || *str == '.'
		   || *str == '*'
		   || *str == '/'
		   || *str == '>')
		str++;
	    --str;
	} else if (str[0] == '%' && str[1] == '%') {	/* escaped '%' */
	    bufptr = save_string(bufptr, "%%");
	    ++str;
	} else if (*str != '%' || (parameterized < 1)) {
	    bufptr = save_char(bufptr, *str);
	} else if (sscanf(str, "%%?%%{%d}%%>%%t%%{%d}%%+%%;", &c1, &c2) == 2) {
	    str = strchr(str, ';');
	    bufptr = save_tc_inequality(bufptr, c1, c2);
	} else if (sscanf(str, "%%?%%{%d}%%>%%t%%'%c'%%+%%;", &c1, &ch2) == 2) {
	    str = strchr(str, ';');
	    bufptr = save_tc_inequality(bufptr, c1, c2);
	} else if (sscanf(str, "%%?%%'%c'%%>%%t%%{%d}%%+%%;", &ch1, &c2) == 2) {
	    str = strchr(str, ';');
	    bufptr = save_tc_inequality(bufptr, c1, c2);
	} else if (sscanf(str, "%%?%%'%c'%%>%%t%%'%c'%%+%%;", &ch1, &ch2) == 2) {
	    str = strchr(str, ';');
	    bufptr = save_tc_inequality(bufptr, c1, c2);
	} else if ((len = bcd_expression(str)) != 0) {
	    str += len;
	    bufptr = save_string(bufptr, "%B");
	} else if ((sscanf(str, "%%{%d}%%+%%c", &c1) == 1
		    || sscanf(str, "%%'%c'%%+%%c", &ch1) == 1)
		   && (cp = strchr(str, '+'))) {
	    str = cp + 2;
	    bufptr = save_string(bufptr, "%+");

	    if (ch1)
		c1 = ch1;
	    bufptr = save_tc_char(bufptr, c1);
	}
	/* FIXME: this "works" for 'delta' */
	else if (strncmp(str, "%{2}%*%-", 8) == 0) {
	    str += 7;
	    bufptr = save_string(bufptr, "%D");
	} else if (strncmp(str, "%{96}%^", 7) == 0) {
	    str += 6;
	    if (saw_m++ == 0) {
		bufptr = save_string(bufptr, "%n");
	    }
	} else if (strncmp(str, "%{127}%^", 8) == 0) {
	    str += 7;
	    if (saw_n++ == 0) {
		bufptr = save_string(bufptr, "%m");
	    }
	} else {		/* cm-style format element */
	    str++;
	    switch (*str) {
	    case '%':
		bufptr = save_char(bufptr, '%');
		break;

	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
	    case '9':
		bufptr = save_char(bufptr, '%');
		while (isdigit(UChar(*str)))
		    bufptr = save_char(bufptr, *str++);
		if (strchr("doxX.", *str)) {
		    if (*str != 'd')	/* termcap doesn't have octal, hex */
			return 0;
		}
		break;

	    case 'd':
		bufptr = save_string(bufptr, "%d");
		break;

	    case 'c':
		bufptr = save_string(bufptr, "%.");
		break;

		/*
		 * %s isn't in termcap, but it's convenient to pass it through
		 * so we can represent things like terminfo pfkey strings in
		 * termcap notation.
		 */
	    case 's':
		bufptr = save_string(bufptr, "%s");
		break;

	    case 'p':
		str++;
		if (*str == '1')
		    seenone = 1;
		else if (*str == '2') {
		    if (!seenone && !seentwo) {
			bufptr = save_string(bufptr, "%r");
			seentwo++;
		    }
		} else if (*str >= '3')
		    return (0);
		break;

	    case 'i':
		bufptr = save_string(bufptr, "%i");
		break;

	    default:
		bufptr = save_char(bufptr, *str);
		syntax_error = TRUE;
		break;
	    }			/* endswitch (*str) */
	}			/* endelse (*str == '%') */

	/*
	 * 'str' always points to the end of what was scanned in this step,
	 * but that may not be the end of the string.
	 */
	assert(str != 0);
	if (*str == '\0')
	    break;

    }				/* endwhile (*str) */

    return (syntax_error ? NULL : my_string);
}

#ifdef MAIN

int curr_line;

int
main(int argc, char *argv[])
{
    int c, tc = FALSE;

    while ((c = getopt(argc, argv, "c")) != EOF)
	switch (c) {
	case 'c':
	    tc = TRUE;
	    break;
	}

    curr_line = 0;
    for (;;) {
	char buf[BUFSIZ];

	++curr_line;
	if (fgets(buf, sizeof(buf), stdin) == NULL)
	    break;
	buflen = strlen(buf);
	if (buflen > 0 && buf[buflen - 1] == '\n')
		buf[buflen - 1] = '\0';
	_nc_set_source(buf);

	if (tc) {
	    char *cp = _nc_infotocap("to termcap", buf, 1);

	    if (cp)
		(void) fputs(cp, stdout);
	} else
	    (void) fputs(_nc_captoinfo("to terminfo", buf, 1), stdout);
	(void) putchar('\n');
    }
    return (0);
}
#endif /* MAIN */

#if NO_LEAKS
NCURSES_EXPORT(void)
_nc_captoinfo_leaks(void)
{
    if (my_string != 0) {
	FreeAndNull(my_string);
    }
    my_length = 0;
}
#endif
@


1.15
log
@Check strlen(buf) to be > 0 before accessing buf[strlen(buf)-1].
OK ray@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.14 2006/10/10 21:38:16 cloder Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d45 1
a45 1
 *	char *_nc_captoinfo(n, s, parametrized)
d98 1
a98 1
MODULE_ID("$From: captoinfo.c,v 1.40 2000/11/05 00:22:36 tom Exp $")
d121 1
a121 1
	_nc_err_abort("Out of memory");
d136 1
a136 1
	    _nc_err_abort("Out of memory");
d140 1
a140 1
	_nc_err_abort("Buffer overflow");
d144 2
a145 2
static inline char *
save_char(char *s, char c)
d148 1
a148 1
    temp[0] = c;
d156 1
a156 1
    if (stackptr > MAX_PUSHED)
d190 1
a190 1
	    c = *sp;
d202 1
a202 1
	    while (isdigit(CharOf(*sp))) {
d208 1
a208 1
	    c = *sp;
d218 1
a218 1
	c = *sp;
d280 1
a280 1
 * 'parametrized' tells what type of translations to do:
d284 2
a285 2
char *
_nc_captoinfo(const char *cap, const char *s, int const parametrized)
d302 1
a302 1
    if (parametrized >= 0 && isdigit(CharOf(*s)))
d304 1
a304 1
	    if (!(isdigit(CharOf(*s)) || *s == '*' || *s == '.'))
d311 1
a311 1
	    if (parametrized < 1) {
d472 1
a472 1
			    unctrl((chtype) * s), CharOf(*s), cap);
d553 1
a553 1
	    if (isdigit(CharOf(*s)) || *s == '*' || *s == '.')
d577 2
a578 2
	&& isdigit(CharOf(ch1))
	&& isdigit(CharOf(ch2))
d644 2
a645 2
char *
_nc_infotocap(const char *cap GCC_UNUSED, const char *str, int const parametrized)
d659 1
a659 1
	while (isdigit(CharOf(*padding)) || *padding == '.' || *padding == '*')
d665 1
a665 1
	while (isdigit(CharOf(*padding)) || *padding == '.' || *padding == '*')
d677 1
a677 1
	    while (isdigit(CharOf(*str))
d686 2
a687 1
	} else if (*str != '%' || (parametrized < 1)) {
d746 1
a746 1
		while (isdigit(CharOf(*str)))
d795 5
d817 1
a817 1
    while ((c = getopt(argc, argv, "c")) != -1)
a826 1
	size_t buflen;
d849 10
a858 1
/* captoinfo.c ends here */
@


1.14
log
@fgets(3) returns NULL on error, not 0. No functional change, but it makes
the code easier to read.
OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.13 2006/03/12 00:29:34 deraadt Exp $	*/
d820 1
d825 3
a827 1
	buf[strlen(buf) - 1] = '\0';
@


1.13
log
@more getopt() EOF crud; adobriyan@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.12 2003/10/15 23:33:48 tedu Exp $	*/
d822 1
a822 1
	if (fgets(buf, sizeof(buf), stdin) == 0)
@


1.12
log
@fix out of bounds access.  found by david@@ running with malloc guards and
randomization.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.11 2003/03/18 16:55:54 millert Exp $	*/
d810 1
a810 1
    while ((c = getopt(argc, argv, "c")) != EOF)
@


1.11
log
@Use strlcpy() / strlcat() throughout.
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.10 2003/03/17 19:16:59 millert Exp $	*/
d656 1
a656 1
    if (*padding == '>' && *--padding == '/') {
d660 1
a660 1
	if (*padding == '<' && *--padding == '$')
@


1.10
log
@use snprintf throughout
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.9 2001/01/22 18:01:50 millert Exp $	*/
d131 1
d138 3
a140 2
    (void) strcpy(d, s);
    return d + strlen(d);
d604 1
a604 1
	    (void) strcpy(temp, unctrl((chtype) c1));
@


1.9
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.8 2000/04/04 16:49:59 millert Exp $	*/
d582 1
a582 1
	    sprintf(buffer, fmt, ch1, ch2);
d604 1
a604 1
	    (void) sprintf(temp, "\\%03o", c1);
@


1.8
log
@Update to ncurses-5.0-20000401:
 o change unctrl() to render C1 characters (128-159) as ~@@, ~A, etc.
 o trace() function is provided only if TRACE is defined, e.g., in the debug
   library.  Modify related calls to _tracechar() to use unctrl() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.7 2000/03/26 16:45:03 millert Exp $	*/
d44 1
a44 1
 *	char *captoinfo(n, s, parametrized)
d97 1
a97 1
MODULE_ID("$From: captoinfo.c,v 1.37 2000/04/01 20:07:34 tom Exp $")
d199 1
a199 1
	    while (isdigit(*sp)) {
d273 8
d282 1
a282 6
_nc_captoinfo(
/* convert a termcap string to terminfo format */
    register const char *cap,	/* relevant terminfo capability index */
    register const char *s,	/* string value of the capability */
    int const parametrized	/* do % translations if 1, pad translations if >=0 */
)
d299 1
a299 1
    if (parametrized >= 0 && isdigit(*s))
d301 1
a301 1
	    if (!(isdigit(*s) || *s == '*' || *s == '.'))
d357 1
a357 1
			|| *s == '*' || *s == '/')
d469 1
a469 1
		    unctrl(*s), (*s) & 0xff, cap);
d550 1
a550 1
	    if (isdigit(*s) || *s == '*' || *s == '.')
d574 2
a575 2
	&& isdigit(ch1)
	&& isdigit(ch2)
d602 1
a602 1
	    (void) strcpy(temp, unctrl(c1));
d637 4
d642 1
a642 6
_nc_infotocap(
/* convert a terminfo string to termcap format */
    register const char *cap GCC_UNUSED,	/* relevant termcap capability index */
    register const char *str,	/* string value of the capability */
    int const parametrized	/* do % translations if 1, pad translations if >=0 */
)
d656 1
a656 1
	while (isdigit(*padding) || *padding == '.' || *padding == '*')
d662 1
a662 1
	while (isdigit(*padding) || *padding == '.' || *padding == '*')
d674 5
a678 2
	    while (isdigit(*str) || *str == '.' || *str == '*' || *str ==
		'/' || *str == '>')
d702 1
a702 1
	    && (cp = strchr(str, '+'))) {
d742 1
a742 1
		while (isdigit(*str))
@


1.7
log
@Update to ncurses-5.0-20000325
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.6 2000/03/13 23:53:40 millert Exp $	*/
d97 1
a97 1
MODULE_ID("$From: captoinfo.c,v 1.36 2000/03/19 23:04:26 tom Exp $")
d465 2
a466 2
		_nc_warning("unknown %% code %s in %s",
		    _tracechar(*s), cap);
@


1.6
log
@update to ncurses-5.0-20000311
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.5 1999/12/12 04:49:19 millert Exp $	*/
d97 1
a97 1
MODULE_ID("$From: captoinfo.c,v 1.35 2000/03/11 12:27:55 tom Exp $")
d739 1
a739 1
		if (strchr("doxX", *str)) {
a741 1
  		    str++;
@


1.5
log
@Update to ncurses-19991211:
 o treat as untranslatable to termcap those terminfo strings which
   contain non-decimal formatting, e.g., hexadecimal or octal.
 o correct commented-out capabilities that cannot be translated to
   termcap, which did not check if a colon must be escaped.
 o correct termcap translation for "%>" and "%+", which did not check
   if a colon must be escaped, for instance.
 o use save_string/save_char for _nc_captoinfo() to eliminate fixed
   buffer (originally for _nc_infotocap() in 960301 -TD).
 o correct expression used for terminfo equivalent of termcap %B,
   adjust regent100 entry which uses this.
 o some cleanup and commenting of ad hoc cases in _nc_infotocap().
 o eliminate a fixed-buffer in tic, used for translating comments.
 o add manpage for infotocap.
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.4 1999/12/06 02:12:46 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
d97 1
a97 1
MODULE_ID("$From: captoinfo.c,v 1.33 1999/12/12 02:25:56 tom Exp $")
d648 1
d719 1
a719 1
	} else {
d739 5
a743 2
		if (*str != 'd') /* termcap doesn't have octal, hex */
		    return 0;
d781 3
a783 2
		return (0);

d792 1
a792 1
    return (my_string);
@


1.4
log
@update to ncurses-5.0-19991204
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.3 1999/08/15 11:40:55 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 2


d97 1
a97 1
MODULE_ID("$From: captoinfo.c,v 1.25 1999/12/05 02:24:05 tom Exp $")
a99 1
#define MAX_ENTRY	2048	/* maximum chars in a translated capability */
d110 1
a110 1
static char  *my_string;
d113 2
a114 1
static char *init_string(void)
d117 4
a120 4
	if (my_string == 0)
		my_string = typeMalloc(char, my_length = 256);
	if (my_string == 0)
	    _nc_err_abort("Out of memory");
d122 2
a123 2
	*my_string = '\0';
	return my_string;
d126 2
a127 1
static char *save_string(char *d, const char *const s)
d129 10
a138 10
	size_t have = (d - my_string);
	size_t need = have + strlen(s) + 2;
	if (need > my_length) {
		my_string = (char *)realloc(my_string, my_length = (need + need));
		if (my_string == 0)
		    _nc_err_abort("Out of memory");
		d = my_string + have;
	}
	(void) strcpy(d, s);
	return d + strlen(d);
d141 2
a142 1
static inline char *save_char(char *s, char c)
d144 3
a146 3
	static char temp[2];
	temp[0] = c;
	return save_string(s, temp);
d149 2
a150 1
static void push(void)
d159 2
a160 1
static void pop(void)
d168 1
a168 2
    }
    else
d173 2
a174 1
static int cvtchar(register const char *sp)
d180 1
a180 1
    switch(*sp) {
d182 1
a182 1
	switch(*++sp) {
d199 1
a199 2
	    while (isdigit(*sp))
	    {
d219 3
a221 1
	*dp++ = '%'; *dp++ = '\''; *dp++ = c; *dp++ = '\'';
d223 1
a223 1
	*dp++ = '%'; *dp++ = '{';
d225 1
a225 1
	    *dp++ = c / 100 + '0';
d227 3
a229 3
	    *dp++ = ((int)(c / 10)) % 10 + '0';
	*dp++ = c % 10 + '0';
	*dp++ = '}';
d234 2
a235 1
static void getparm(int parm, int n)
d238 13
a250 15
	if (seenr) {
		if (parm == 1)
			parm = 2;
		else if (parm == 2)
			parm = 1;
		}
	if (onstack == parm) {
		if (n > 1) {
			_nc_warning("string may not be optimal");
			*dp++ = '%'; *dp++ = 'P'; *dp++ = 'a';
			while(n--) {
				*dp++ = '%'; *dp++ = 'g'; *dp++ = 'a';
			}
		}
		return;
d252 4
a255 2
	if (onstack != 0)
		push();
d257 1
a257 1
	onstack = parm;
d259 4
a262 3
	while(n--) {		/* %p0 */
		*dp++ = '%'; *dp++ = 'p'; *dp++ = '0' + parm;
	}
d264 3
a266 4
	if (seenn && parm < 3) {	/* %{96}%^ */
		*dp++ = '%'; *dp++ = '{'; *dp++ = '9'; *dp++ = '6'; *dp++ = '}';
		*dp++ = '%'; *dp++ = '^';
	}
d268 3
a270 4
	if (seenm && parm < 3) {	/* %{127}%^ */
		*dp++ = '%'; *dp++ = '{'; *dp++ = '1'; *dp++ = '2'; *dp++ = '7';
		*dp++ = '}'; *dp++ = '%'; *dp++ = '^';
	}
d273 2
a274 1
char *_nc_captoinfo(
d276 4
a279 3
register const char *cap,	/* relevant terminfo capability index */
register const char *s,		/* string value of the capability */
int const parametrized)		/* do % translations if 1, pad translations if >=0 */
a280 1
    static char line[MAX_ENTRY];
d290 1
a290 1
    dp = line;
d297 1
a297 1
	for (capstart = s; ; s++)
d301 2
a302 2
    while(*s != '\0') {
	switch(*s) {
d306 1
a306 1
		*dp++ = '%';
d309 4
a312 2
	    switch(*s++) {
	    case '%': *dp++ = '%'; break;
d328 3
a330 1
	    case 'i': *dp++ = '%'; *dp++ = 'i'; break;
d333 4
a336 5
		getparm(param, 2);
		/* %{6}%*%+ */
		*dp++ = '%'; *dp++ = '{'; *dp++ = '6';
		*dp++ = '}'; *dp++ = '%'; *dp++ = '*';
		*dp++ = '%'; *dp++ = '+';
d341 1
a341 4
		/* %{2}%*%- */
		*dp++ = '%'; *dp++ = '{'; *dp++ = '2';
		*dp++ = '}'; *dp++ = '%'; *dp++ = '*';
		*dp++ = '%'; *dp++ = '-';
d346 1
a346 1
		*dp++ = '%'; *dp++ = '?';
d348 1
a348 2
		*dp++ = '%'; *dp++ = '>';
		*dp++ = '%'; *dp++ = 't';
d350 1
a350 2
		*dp++ = '%'; *dp++ = '+';
		*dp++ = '%'; *dp++ = ';';
d354 1
a354 1
		     || *s == '*' || *s == '/')
d370 1
a370 1
		    switch(*s) {
d372 1
a372 1
			*dp++ = '%'; *dp++ = '+';
d375 1
a375 1
			*dp++ = '%'; *dp++ = '-';
d378 1
a378 1
			*dp++ = '%'; *dp++ = '*';
d381 1
a381 1
			*dp++ = '%'; *dp++ = '/';
d391 1
a391 2
			}
			else
d400 1
a400 1
		*dp++ = '%'; *dp++ = '+';
d405 1
a405 2
		*dp++ = '%'; *dp++ = '+';
		*dp++ = '%'; *dp++ = 'c';
d412 1
a412 1
		*dp++ = '%'; *dp++ = '-';
d415 1
a415 1
		*dp++ = '%'; *dp++ = 's';
d422 1
a422 2
		*dp++ = '%'; *dp++ = '-';
		*dp++ = '%'; *dp++ = 'c';
d427 1
a427 1
		*dp++ = '%'; *dp++ = 'c';
d430 1
a430 1
	    case '0':	/* not clear any of the historical termcaps did this */
d438 1
a438 2
		*dp++ = '%'; /* *dp++ = '0'; */
		*dp++ = '2'; *dp++ = 'd';
d441 2
a442 1
	    case '3': see03:
d444 1
a444 2
		*dp++ = '%'; /* *dp++ = '0'; */
		*dp++ = '3'; *dp++ = 'd';
d449 1
a449 1
		*dp++ = '%'; *dp++ = 'd';
d459 1
a459 2
		*dp++ = '%';
		*dp++ = '\\';
d461 3
a463 2
	    default: invalid:
		*dp++ = '%';
d466 1
a466 1
			_tracechar(*s), cap);
d472 3
a474 1
	    *dp++ = *s++; *dp++ = *s++; break;
d476 3
a478 1
	    *dp++ = '\\'; *dp++ = 'n'; s++; break;
d480 3
a482 1
	    *dp++ = '\\'; *dp++ = 't'; s++; break;
d484 3
a486 1
	    *dp++ = '\\'; *dp++ = 'r'; s++; break;
d488 3
a490 1
	    *dp++ = '\\'; *dp++ = '0'; s++; break;
d492 3
a494 1
	    *dp++ = '\\'; *dp++ = 'f'; s++; break;
d496 3
a498 1
	    *dp++ = '\\'; *dp++ = 'b'; s++; break;
d500 3
a502 1
	    *dp++ = '\\'; *dp++ = 's'; s++; break;
d504 3
a506 1
	    *dp++ = '\\'; *dp++ = '^'; s++; break;
d508 3
a510 1
	    *dp++ = '\\'; *dp++ = ':'; s++; break;
d512 3
a514 1
	    *dp++ = '\\'; *dp++ = ','; s++; break;
d517 1
a517 2
		*dp++ = '\\';
		*dp++ = 'E';
d520 2
a521 2
		*dp++ = '^';
		*dp++ = *s + '@@';
d524 4
a527 4
		*dp++ = '\\';
		*dp++ = ((*s & 0300) >> 6) + '0';
		*dp++ = ((*s & 0070) >> 3) + '0';
		*dp++ = (*s & 0007) + '0';
d530 1
a530 1
		*dp++ = *s++;
d534 1
a534 1
	    *dp++ = *s++;
d544 3
a546 5
    if (capstart)
    {
	*dp++ = '$';
	*dp++ = '<';
	for (s = capstart; ; s++)
d548 1
a548 1
		*dp++ = *s;
d551 52
a602 2
	*dp++ = '/';
	*dp++ = '>';
d604 2
d607 7
a613 2
    *dp = '\0';
    return(line);
d634 2
a635 1
char *_nc_infotocap(
d637 4
a640 3
register const char *cap GCC_UNUSED, /* relevant termcap capability index */
register const char *str,	/* string value of the capability */
int const parametrized)		/* do % translations if 1, pad translations if >=0 */
d642 1
a642 1
    int	seenone = 0, seentwo = 0, saw_m = 0, saw_n = 0;
d647 1
a647 1
    char temp[256];
d651 1
a651 2
    if (*padding == '>' && *--padding == '/')
    {
d663 3
a665 4
    for (; *str && str != trimmed; str++)
    {
	int	c1, c2;
	char	*cp = 0;
d667 1
a667 2
	if (str[0] == '\\' && (str[1] == '^' || str[1] == ','))
	{
d669 1
a669 3
	}
	else if (str[0] == '$' && str[1] == '<')	/* discard padding */
	{
d671 2
a672 1
	    while (isdigit(*str) || *str == '.' || *str == '*' || *str == '/' || *str == '>')
d675 1
a675 3
	}
	else if (str[0] == '%' && str[1] == '%')	/* escaped '%' */
	{
d677 1
a677 2
	}
	else if (*str != '%' || (parametrized < 1))
d679 1
a679 2
	else if (sscanf(str, "%%?%%{%d}%%>%%t%%{%d}%%+%%;", &c1,&c2) == 2)
	{
d681 2
a682 5
	    (void) sprintf(temp, "%%>%s%s", unctrl(c1), unctrl(c2));
	    bufptr = save_string(bufptr, temp);
	}
	else if (sscanf(str, "%%?%%{%d}%%>%%t%%'%c'%%+%%;", &c1,&ch2) == 2)
	{
d684 2
a685 5
	    (void) sprintf(temp, "%%>%s%c", unctrl(c1), ch2);
	    bufptr = save_string(bufptr, temp);
	}
	else if (sscanf(str, "%%?%%'%c'%%>%%t%%{%d}%%+%%;", &ch1,&c2) == 2)
	{
d687 2
a688 5
	    (void) sprintf(temp, "%%>%c%c", ch1, c2);
	    bufptr = save_string(bufptr, temp);
	}
	else if (sscanf(str, "%%?%%'%c'%%>%%t%%'%c'%%+%%;", &ch1, &ch2) == 2)
	{
d690 7
a696 13
	    (void) sprintf(temp, "%%>%c%c", ch1, ch2);
	    bufptr = save_string(bufptr, temp);
	}
	else if (strncmp(str, "%{6}%*%+", 8) == 0)
	{
	    str += 7;
	    (void) sprintf(temp, "%%B");
	    bufptr = save_string(bufptr, temp);
	}
	else if ((sscanf(str, "%%{%d}%%+%%c", &c1) == 1
		  || sscanf(str, "%%'%c'%%+%%c", &ch1) == 1)
		 && (cp = strchr(str, '+')))
	{
d698 1
a698 2
	    bufptr = save_char(bufptr, '%');
	    bufptr = save_char(bufptr, '+');
d702 1
a702 10
	    if (is7bits(c1) && isprint(c1))
		bufptr = save_char(bufptr, (char)c1);
	    else
	    {
		if (c1 == (c1 & 0x1f)) /* iscntrl() returns T on 255 */
		    (void) strcpy(temp, unctrl(c1));
		else
		    (void) sprintf(temp, "\\%03o", c1);
		bufptr = save_string(bufptr, temp);
	    }
d704 2
a705 2
	else if (strncmp(str, "%{2}%*%-", 8) == 0)
	{
d707 2
a708 5
	    (void) sprintf(temp, "%%D");
	    bufptr = save_string(bufptr, temp);
	}
	else if (strncmp(str, "%{96}%^", 7) == 0)
	{
d710 2
a711 4
	    if (saw_m++ == 0)
	    {
		(void) sprintf(temp, "%%n");
		bufptr = save_string(bufptr, temp);
d713 1
a713 3
	}
	else if (strncmp(str, "%{127}%^", 8) == 0)
	{
d715 2
a716 4
	    if (saw_n++ == 0)
	    {
		(void) sprintf(temp, "%%m");
		bufptr = save_string(bufptr, temp);
d718 1
a718 3
	}
	else
	{
d738 2
a739 6
		if (*str == 'd')
		    str++;
		else
		    _nc_warning("numeric prefix is missing trailing d in %s",
				cap);
		--str;
d743 1
a743 2
		bufptr = save_char(bufptr, '%');
		bufptr = save_char(bufptr, 'd');
d747 1
a747 2
		bufptr = save_char(bufptr, '%');
		bufptr = save_char(bufptr, '.');
d750 5
a754 5
	    /*
	     * %s isn't in termcap, but it's convenient to pass it through
	     * so we can represent things like terminfo pfkey strings in
	     * termcap notation.
	     */
d756 1
a756 2
		bufptr = save_char(bufptr, '%');
		bufptr = save_char(bufptr, 's');
d763 3
a765 6
		else if (*str == '2')
		{
		    if (!seenone && !seentwo)
		    {
			bufptr = save_char(bufptr, '%');
			bufptr = save_char(bufptr, 'r');
d768 2
a769 3
		}
		else if (*str >= '3')
		    return(0);
d773 1
a773 2
		bufptr = save_char(bufptr, '%');
		bufptr = save_char(bufptr, 'i');
d777 1
a777 1
		return(0);
d779 2
a780 2
	    } /* endswitch (*str) */
	} /* endelse (*str == '%') */
d785 1
a785 1
    } /* endwhile (*str) */
d787 1
a787 1
    return(my_string);
d794 2
a795 1
int main(int argc, char *argv[])
d800 1
a800 2
	switch (c)
	{
d807 2
a808 3
    for (;;)
    {
	char	buf[BUFSIZ];
d816 2
a817 3
	if (tc)
	{
	    char	*cp = _nc_infotocap("to termcap", buf, 1);
d821 1
a821 2
	}
	else
d825 1
a825 1
    return(0);
a829 1

@


1.3
log
@Update to ncurses-5.0-990814
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.2 1999/03/02 06:23:28 millert Exp $	*/
d99 1
a99 1
MODULE_ID("$From: captoinfo.c,v 1.24 1999/07/24 20:06:13 tom Exp $")
d603 4
@


1.2
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.1 1999/01/18 19:10:13 millert Exp $	*/
d99 1
a99 1
MODULE_ID("$From: captoinfo.c,v 1.23 1999/02/28 23:42:20 tom Exp $")
d591 1
a591 1
	char	*cp;
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: captoinfo.c,v 1.1 1998/07/23 21:17:25 millert Exp $	*/
d99 1
a99 1
MODULE_ID("$From: captoinfo.c,v 1.21 1998/05/30 23:32:15 Todd.Miller Exp $")
d120 1
a120 1
		my_string = malloc(my_length = 256);
d133 1
a133 1
		my_string = realloc(my_string, my_length = (need + need));
@

