head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.28
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.24
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.26
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.18
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.22
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.20
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.30
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.26
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.24
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.22
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.20
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.18
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.16
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.14
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.12
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.10
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.8
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.17.19.16.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.22.18.01.54;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.22.18.27.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.08.22.47.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.06.06.15.55.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.05.13.03.01.47;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	99.03.02.06.23.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.20;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey, 1996 on                                       *
 ****************************************************************************/

/*
 *	tparm.c
 *
 */

#include <curses.priv.h>

#include <ctype.h>
#include <term.h>
#include <tic.h>

MODULE_ID("$Id: lib_tparm.c,v 1.76 2008/08/16 19:22:55 tom Exp $")

/*
 *	char *
 *	tparm(string, ...)
 *
 *	Substitute the given parameters into the given string by the following
 *	rules (taken from terminfo(5)):
 *
 *	     Cursor addressing and other strings  requiring  parame-
 *	ters in the terminal are described by a parameterized string
 *	capability, with like escapes %x in  it.   For  example,  to
 *	address  the  cursor, the cup capability is given, using two
 *	parameters: the row and column to  address  to.   (Rows  and
 *	columns  are  numbered  from  zero and refer to the physical
 *	screen visible to the user, not to any  unseen  memory.)  If
 *	the terminal has memory relative cursor addressing, that can
 *	be indicated by
 *
 *	     The parameter mechanism uses  a  stack  and  special  %
 *	codes  to manipulate it.  Typically a sequence will push one
 *	of the parameters onto the stack and then print it  in  some
 *	format.  Often more complex operations are necessary.
 *
 *	     The % encodings have the following meanings:
 *
 *	     %%        outputs `%'
 *	     %c        print pop() like %c in printf()
 *	     %s        print pop() like %s in printf()
 *           %[[:]flags][width[.precision]][doxXs]
 *                     as in printf, flags are [-+#] and space
 *                     The ':' is used to avoid making %+ or %-
 *                     patterns (see below).
 *
 *	     %p[1-9]   push ith parm
 *	     %P[a-z]   set dynamic variable [a-z] to pop()
 *	     %g[a-z]   get dynamic variable [a-z] and push it
 *	     %P[A-Z]   set static variable [A-Z] to pop()
 *	     %g[A-Z]   get static variable [A-Z] and push it
 *	     %l        push strlen(pop)
 *	     %'c'      push char constant c
 *	     %{nn}     push integer constant nn
 *
 *	     %+ %- %* %/ %m
 *	               arithmetic (%m is mod): push(pop() op pop())
 *	     %& %| %^  bit operations: push(pop() op pop())
 *	     %= %> %<  logical operations: push(pop() op pop())
 *	     %A %O     logical and & or operations for conditionals
 *	     %! %~     unary operations push(op pop())
 *	     %i        add 1 to first two parms (for ANSI terminals)
 *
 *	     %? expr %t thenpart %e elsepart %;
 *	               if-then-else, %e elsepart is optional.
 *	               else-if's are possible ala Algol 68:
 *	               %? c1 %t b1 %e c2 %t b2 %e c3 %t b3 %e c4 %t b4 %e b5 %;
 *
 *	For those of the above operators which are binary and not commutative,
 *	the stack works in the usual way, with
 *			%gx %gy %m
 *	resulting in x mod y, not the reverse.
 */

NCURSES_EXPORT_VAR(int) _nc_tparm_err = 0;

#define TPS(var) _nc_prescreen.tparm_state.var

#if NO_LEAKS
NCURSES_EXPORT(void)
_nc_free_tparm(void)
{
    if (TPS(out_buff) != 0) {
	FreeAndNull(TPS(out_buff));
	TPS(out_size) = 0;
	TPS(out_used) = 0;
	FreeAndNull(TPS(fmt_buff));
	TPS(fmt_size) = 0;
    }
}
#endif

static NCURSES_INLINE void
get_space(size_t need)
{
    need += TPS(out_used);
    if (need > TPS(out_size)) {
	TPS(out_size) = need * 2;
	TPS(out_buff) = typeRealloc(char, TPS(out_size), TPS(out_buff));
	if (TPS(out_buff) == 0)
	    _nc_err_abort(MSG_NO_MEMORY);
    }
}

static NCURSES_INLINE void
save_text(const char *fmt, const char *s, int len)
{
    size_t s_len = strlen(s);
    if (len > (int) s_len)
	s_len = len;

    get_space(s_len + 1);

    (void) snprintf(TPS(out_buff) + TPS(out_used), TPS(out_size) - TPS(out_used), fmt, s);
    TPS(out_used) += strlen(TPS(out_buff) + TPS(out_used));
}

static NCURSES_INLINE void
save_number(const char *fmt, int number, int len)
{
    if (len < 30)
	len = 30;		/* actually log10(MAX_INT)+1 */

    get_space((unsigned) len + 1);

    (void) snprintf(TPS(out_buff) + TPS(out_used), TPS(out_size) - TPS(out_used), fmt, number);
    TPS(out_used) += strlen(TPS(out_buff) + TPS(out_used));
}

static NCURSES_INLINE void
save_char(int c)
{
    if (c == 0)
	c = 0200;
    get_space(1);
    TPS(out_buff)[TPS(out_used)++] = (char) c;
}

static NCURSES_INLINE void
npush(int x)
{
    if (TPS(stack_ptr) < STACKSIZE) {
	TPS(stack)[TPS(stack_ptr)].num_type = TRUE;
	TPS(stack)[TPS(stack_ptr)].data.num = x;
	TPS(stack_ptr)++;
    } else {
	DEBUG(2, ("npush: stack overflow: %s", _nc_visbuf(TPS(tparam_base))));
	_nc_tparm_err++;
    }
}

static NCURSES_INLINE int
npop(void)
{
    int result = 0;
    if (TPS(stack_ptr) > 0) {
	TPS(stack_ptr)--;
	if (TPS(stack)[TPS(stack_ptr)].num_type)
	    result = TPS(stack)[TPS(stack_ptr)].data.num;
    } else {
	DEBUG(2, ("npop: stack underflow: %s", _nc_visbuf(TPS(tparam_base))));
	_nc_tparm_err++;
    }
    return result;
}

static NCURSES_INLINE void
spush(char *x)
{
    if (TPS(stack_ptr) < STACKSIZE) {
	TPS(stack)[TPS(stack_ptr)].num_type = FALSE;
	TPS(stack)[TPS(stack_ptr)].data.str = x;
	TPS(stack_ptr)++;
    } else {
	DEBUG(2, ("spush: stack overflow: %s", _nc_visbuf(TPS(tparam_base))));
	_nc_tparm_err++;
    }
}

static NCURSES_INLINE char *
spop(void)
{
    static char dummy[] = "";	/* avoid const-cast */
    char *result = dummy;
    if (TPS(stack_ptr) > 0) {
	TPS(stack_ptr)--;
	if (!TPS(stack)[TPS(stack_ptr)].num_type
	    && TPS(stack)[TPS(stack_ptr)].data.str != 0)
	    result = TPS(stack)[TPS(stack_ptr)].data.str;
    } else {
	DEBUG(2, ("spop: stack underflow: %s", _nc_visbuf(TPS(tparam_base))));
	_nc_tparm_err++;
    }
    return result;
}

static NCURSES_INLINE const char *
parse_format(const char *s, char *format, int *len)
{
    *len = 0;
    if (format != 0) {
	bool done = FALSE;
	bool allowminus = FALSE;
	bool dot = FALSE;
	bool err = FALSE;
	char *fmt = format;
	int my_width = 0;
	int my_prec = 0;
	int value = 0;

	*len = 0;
	*format++ = '%';
	while (*s != '\0' && !done) {
	    switch (*s) {
	    case 'c':		/* FALLTHRU */
	    case 'd':		/* FALLTHRU */
	    case 'o':		/* FALLTHRU */
	    case 'x':		/* FALLTHRU */
	    case 'X':		/* FALLTHRU */
	    case 's':
		*format++ = *s;
		done = TRUE;
		break;
	    case '.':
		*format++ = *s++;
		if (dot) {
		    err = TRUE;
		} else {	/* value before '.' is the width */
		    dot = TRUE;
		    my_width = value;
		}
		value = 0;
		break;
	    case '#':
		*format++ = *s++;
		break;
	    case ' ':
		*format++ = *s++;
		break;
	    case ':':
		s++;
		allowminus = TRUE;
		break;
	    case '-':
		if (allowminus) {
		    *format++ = *s++;
		} else {
		    done = TRUE;
		}
		break;
	    default:
		if (isdigit(UChar(*s))) {
		    value = (value * 10) + (*s - '0');
		    if (value > 10000)
			err = TRUE;
		    *format++ = *s++;
		} else {
		    done = TRUE;
		}
	    }
	}

	/*
	 * If we found an error, ignore (and remove) the flags.
	 */
	if (err) {
	    my_width = my_prec = value = 0;
	    format = fmt;
	    *format++ = '%';
	    *format++ = *s;
	}

	/*
	 * Any value after '.' is the precision.  If we did not see '.', then
	 * the value is the width.
	 */
	if (dot)
	    my_prec = value;
	else
	    my_width = value;

	*format = '\0';
	/* return maximum string length in print */
	*len = (my_width > my_prec) ? my_width : my_prec;
    }
    return s;
}

#define isUPPER(c) ((c) >= 'A' && (c) <= 'Z')
#define isLOWER(c) ((c) >= 'a' && (c) <= 'z')

/*
 * Analyze the string to see how many parameters we need from the varargs list,
 * and what their types are.  We will only accept string parameters if they
 * appear as a %l or %s format following an explicit parameter reference (e.g.,
 * %p2%s).  All other parameters are numbers.
 *
 * 'number' counts coarsely the number of pop's we see in the string, and
 * 'popcount' shows the highest parameter number in the string.  We would like
 * to simply use the latter count, but if we are reading termcap strings, there
 * may be cases that we cannot see the explicit parameter numbers.
 */
NCURSES_EXPORT(int)
_nc_tparm_analyze(const char *string, char *p_is_s[NUM_PARM], int *popcount)
{
    size_t len2;
    int i;
    int lastpop = -1;
    int len;
    int number = 0;
    const char *cp = string;
    static char dummy[] = "";

    if (cp == 0)
	return 0;

    if ((len2 = strlen(cp)) > TPS(fmt_size)) {
	TPS(fmt_size) = len2 + TPS(fmt_size) + 2;
	TPS(fmt_buff) = typeRealloc(char, TPS(fmt_size), TPS(fmt_buff));
	if (TPS(fmt_buff) == 0)
	    return 0;
    }

    memset(p_is_s, 0, sizeof(p_is_s[0]) * NUM_PARM);
    *popcount = 0;

    while ((cp - string) < (int) len2) {
	if (*cp == '%') {
	    cp++;
	    cp = parse_format(cp, TPS(fmt_buff), &len);
	    switch (*cp) {
	    default:
		break;

	    case 'd':		/* FALLTHRU */
	    case 'o':		/* FALLTHRU */
	    case 'x':		/* FALLTHRU */
	    case 'X':		/* FALLTHRU */
	    case 'c':		/* FALLTHRU */
		if (lastpop <= 0)
		    number++;
		lastpop = -1;
		break;

	    case 'l':
	    case 's':
		if (lastpop > 0)
		    p_is_s[lastpop - 1] = dummy;
		++number;
		break;

	    case 'p':
		cp++;
		i = (UChar(*cp) - '0');
		if (i >= 0 && i <= NUM_PARM) {
		    lastpop = i;
		    if (lastpop > *popcount)
			*popcount = lastpop;
		}
		break;

	    case 'P':
		++number;
		++cp;
		break;

	    case 'g':
		cp++;
		break;

	    case S_QUOTE:
		cp += 2;
		lastpop = -1;
		break;

	    case L_BRACE:
		cp++;
		while (isdigit(UChar(*cp))) {
		    cp++;
		}
		break;

	    case '+':
	    case '-':
	    case '*':
	    case '/':
	    case 'm':
	    case 'A':
	    case 'O':
	    case '&':
	    case '|':
	    case '^':
	    case '=':
	    case '<':
	    case '>':
		lastpop = -1;
		number += 2;
		break;

	    case '!':
	    case '~':
		lastpop = -1;
		++number;
		break;

	    case 'i':
		/* will add 1 to first (usually two) parameters */
		break;
	    }
	}
	if (*cp != '\0')
	    cp++;
    }

    if (number > NUM_PARM)
	number = NUM_PARM;
    return number;
}

static NCURSES_INLINE char *
tparam_internal(const char *string, va_list ap)
{
    char *p_is_s[NUM_PARM];
    TPARM_ARG param[NUM_PARM];
    int popcount;
    int number;
    int len;
    int level;
    int x, y;
    int i;
    const char *cp = string;
    size_t len2;

    if (cp == NULL)
	return NULL;

    TPS(out_used) = 0;
    len2 = strlen(cp);

    /*
     * Find the highest parameter-number referred to in the format string.
     * Use this value to limit the number of arguments copied from the
     * variable-length argument list.
     */
    number = _nc_tparm_analyze(cp, p_is_s, &popcount);
    if (TPS(fmt_buff) == 0)
	return NULL;

    for (i = 0; i < max(popcount, number); i++) {
	/*
	 * A few caps (such as plab_norm) have string-valued parms.
	 * We'll have to assume that the caller knows the difference, since
	 * a char* and an int may not be the same size on the stack.  The
	 * normal prototype for this uses 9 long's, which is consistent with
	 * our va_arg() usage.
	 */
	if (p_is_s[i] != 0) {
	    p_is_s[i] = va_arg(ap, char *);
	} else {
	    param[i] = va_arg(ap, TPARM_ARG);
	}
    }

    /*
     * This is a termcap compatibility hack.  If there are no explicit pop
     * operations in the string, load the stack in such a way that
     * successive pops will grab successive parameters.  That will make
     * the expansion of (for example) \E[%d;%dH work correctly in termcap
     * style, which means tparam() will expand termcap strings OK.
     */
    TPS(stack_ptr) = 0;
    if (popcount == 0) {
	popcount = number;
	for (i = number - 1; i >= 0; i--) {
	    if (p_is_s[i])
		spush(p_is_s[i]);
	    else
		npush(param[i]);
	}
    }
#ifdef TRACE
    if (USE_TRACEF(TRACE_CALLS)) {
	for (i = 0; i < popcount; i++) {
	    if (p_is_s[i] != 0)
		save_text(", %s", _nc_visbuf(p_is_s[i]), 0);
	    else
		save_number(", %d", param[i], 0);
	}
	_tracef(T_CALLED("%s(%s%s)"), TPS(tname), _nc_visbuf(cp), TPS(out_buff));
	TPS(out_used) = 0;
	_nc_unlock_global(tracef);
    }
#endif /* TRACE */

    while ((cp - string) < (int) len2) {
	if (*cp != '%') {
	    save_char(UChar(*cp));
	} else {
	    TPS(tparam_base) = cp++;
	    cp = parse_format(cp, TPS(fmt_buff), &len);
	    switch (*cp) {
	    default:
		break;
	    case '%':
		save_char('%');
		break;

	    case 'd':		/* FALLTHRU */
	    case 'o':		/* FALLTHRU */
	    case 'x':		/* FALLTHRU */
	    case 'X':		/* FALLTHRU */
		save_number(TPS(fmt_buff), npop(), len);
		break;

	    case 'c':		/* FALLTHRU */
		save_char(npop());
		break;

	    case 'l':
		save_number("%d", (int) strlen(spop()), 0);
		break;

	    case 's':
		save_text(TPS(fmt_buff), spop(), len);
		break;

	    case 'p':
		cp++;
		i = (UChar(*cp) - '1');
		if (i >= 0 && i < NUM_PARM) {
		    if (p_is_s[i])
			spush(p_is_s[i]);
		    else
			npush(param[i]);
		}
		break;

	    case 'P':
		cp++;
		if (isUPPER(*cp)) {
		    i = (UChar(*cp) - 'A');
		    TPS(static_vars)[i] = npop();
		} else if (isLOWER(*cp)) {
		    i = (UChar(*cp) - 'a');
		    TPS(dynamic_var)[i] = npop();
		}
		break;

	    case 'g':
		cp++;
		if (isUPPER(*cp)) {
		    i = (UChar(*cp) - 'A');
		    npush(TPS(static_vars)[i]);
		} else if (isLOWER(*cp)) {
		    i = (UChar(*cp) - 'a');
		    npush(TPS(dynamic_var)[i]);
		}
		break;

	    case S_QUOTE:
		cp++;
		npush(UChar(*cp));
		cp++;
		break;

	    case L_BRACE:
		number = 0;
		cp++;
		while (isdigit(UChar(*cp))) {
		    number = (number * 10) + (UChar(*cp) - '0');
		    cp++;
		}
		npush(number);
		break;

	    case '+':
		npush(npop() + npop());
		break;

	    case '-':
		y = npop();
		x = npop();
		npush(x - y);
		break;

	    case '*':
		npush(npop() * npop());
		break;

	    case '/':
		y = npop();
		x = npop();
		npush(y ? (x / y) : 0);
		break;

	    case 'm':
		y = npop();
		x = npop();
		npush(y ? (x % y) : 0);
		break;

	    case 'A':
		npush(npop() && npop());
		break;

	    case 'O':
		npush(npop() || npop());
		break;

	    case '&':
		npush(npop() & npop());
		break;

	    case '|':
		npush(npop() | npop());
		break;

	    case '^':
		npush(npop() ^ npop());
		break;

	    case '=':
		y = npop();
		x = npop();
		npush(x == y);
		break;

	    case '<':
		y = npop();
		x = npop();
		npush(x < y);
		break;

	    case '>':
		y = npop();
		x = npop();
		npush(x > y);
		break;

	    case '!':
		npush(!npop());
		break;

	    case '~':
		npush(~npop());
		break;

	    case 'i':
		if (p_is_s[0] == 0)
		    param[0]++;
		if (p_is_s[1] == 0)
		    param[1]++;
		break;

	    case '?':
		break;

	    case 't':
		x = npop();
		if (!x) {
		    /* scan forward for %e or %; at level zero */
		    cp++;
		    level = 0;
		    while (*cp) {
			if (*cp == '%') {
			    cp++;
			    if (*cp == '?')
				level++;
			    else if (*cp == ';') {
				if (level > 0)
				    level--;
				else
				    break;
			    } else if (*cp == 'e' && level == 0)
				break;
			}

			if (*cp)
			    cp++;
		    }
		}
		break;

	    case 'e':
		/* scan forward for a %; at level zero */
		cp++;
		level = 0;
		while (*cp) {
		    if (*cp == '%') {
			cp++;
			if (*cp == '?')
			    level++;
			else if (*cp == ';') {
			    if (level > 0)
				level--;
			    else
				break;
			}
		    }

		    if (*cp)
			cp++;
		}
		break;

	    case ';':
		break;

	    }			/* endswitch (*cp) */
	}			/* endelse (*cp == '%') */

	if (*cp == '\0')
	    break;

	cp++;
    }				/* endwhile (*cp) */

    get_space(1);
    TPS(out_buff)[TPS(out_used)] = '\0';

    T((T_RETURN("%s"), _nc_visbuf(TPS(out_buff))));
    return (TPS(out_buff));
}

#if NCURSES_TPARM_VARARGS
#define tparm_varargs tparm
#else
#define tparm_proto tparm
#endif

NCURSES_EXPORT(char *)
tparm_varargs(NCURSES_CONST char *string,...)
{
    va_list ap;
    char *result;

    _nc_tparm_err = 0;
    va_start(ap, string);
#ifdef TRACE
    TPS(tname) = "tparm";
#endif /* TRACE */
    result = tparam_internal(string, ap);
    va_end(ap);
    return result;
}

#if !NCURSES_TPARM_VARARGS
NCURSES_EXPORT(char *)
tparm_proto(NCURSES_CONST char *string,
	    TPARM_ARG a1,
	    TPARM_ARG a2,
	    TPARM_ARG a3,
	    TPARM_ARG a4,
	    TPARM_ARG a5,
	    TPARM_ARG a6,
	    TPARM_ARG a7,
	    TPARM_ARG a8,
	    TPARM_ARG a9)
{
    return tparm_varargs(string, a1, a2, a3, a4, a5, a6, a7, a8, a9);
}
#endif /* NCURSES_TPARM_VARARGS */
@


1.8
log
@use snprintf throughout
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_tparm.c,v 1.7 2001/01/22 18:01:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d34 1
d48 1
a48 1
MODULE_ID("$From: lib_tparm.c,v 1.51 2000/12/10 02:55:08 tom Exp $")
d110 1
a110 1
#define STACKSIZE	20
d112 1
a112 18
typedef struct {
    union {
	unsigned int num;
	char *str;
    } data;
    bool num_type;
} stack_frame;

static stack_frame stack[STACKSIZE];
static int stack_ptr;

#ifdef TRACE
static const char *tname;
#endif /* TRACE */

static char *out_buff;
static size_t out_size;
static size_t out_used;
d118 6
a123 4
    if (out_buff != 0) {
	FreeAndNull(out_buff);
	out_size = 0;
	out_used = 0;
d128 1
a128 10
static void
really_get_space(size_t need)
{
    out_size = need * 2;
    out_buff = typeRealloc(char, out_size, out_buff);
    if (out_buff == 0)
	_nc_err_abort("Out of memory");
}

static inline void
d131 7
a137 3
    need += out_used;
    if (need > out_size)
	really_get_space(need);
d140 1
a140 1
static inline void
d149 2
a150 2
    (void) snprintf(out_buff + out_used, out_size - out_used, fmt, s);
    out_used += strlen(out_buff + out_used);
d153 1
a153 1
static inline void
d159 1
a159 1
    get_space(len + 1);
d161 2
a162 2
    (void) snprintf(out_buff + out_used, out_size - out_used, fmt, number);
    out_used += strlen(out_buff + out_used);
d165 1
a165 1
static inline void
d171 1
a171 1
    out_buff[out_used++] = c;
d174 1
a174 1
static inline void
d177 7
a183 4
    if (stack_ptr < STACKSIZE) {
	stack[stack_ptr].num_type = TRUE;
	stack[stack_ptr].data.num = x;
	stack_ptr++;
d187 1
a187 1
static inline int
d191 7
a197 4
    if (stack_ptr > 0) {
	stack_ptr--;
	if (stack[stack_ptr].num_type)
	    result = stack[stack_ptr].data.num;
d202 1
a202 1
static inline void
d205 7
a211 4
    if (stack_ptr < STACKSIZE) {
	stack[stack_ptr].num_type = FALSE;
	stack[stack_ptr].data.str = x;
	stack_ptr++;
d215 1
a215 1
static inline char *
d220 8
a227 4
    if (stack_ptr > 0) {
	stack_ptr--;
	if (!stack[stack_ptr].num_type && stack[stack_ptr].data.str != 0)
	    result = stack[stack_ptr].data.str;
d232 1
a232 1
static inline const char *
d235 10
a244 8
    bool done = FALSE;
    bool allowminus = FALSE;
    bool dot = FALSE;
    bool err = FALSE;
    char *fmt = format;
    int prec = 0;
    int width = 0;
    int value = 0;
d246 14
a259 35
    *len = 0;
    *format++ = '%';
    while (*s != '\0' && !done) {
	switch (*s) {
	case 'c':		/* FALLTHRU */
	case 'd':		/* FALLTHRU */
	case 'o':		/* FALLTHRU */
	case 'x':		/* FALLTHRU */
	case 'X':		/* FALLTHRU */
	case 's':
	    *format++ = *s;
	    done = TRUE;
	    break;
	case '.':
	    *format++ = *s++;
	    if (dot) {
		err = TRUE;
	    } else {
		dot = TRUE;
		prec = value;
	    }
	    value = 0;
	    break;
	case '#':
	    *format++ = *s++;
	    break;
	case ' ':
	    *format++ = *s++;
	    break;
	case ':':
	    s++;
	    allowminus = TRUE;
	    break;
	case '-':
	    if (allowminus) {
d261 1
a261 8
	    } else {
		done = TRUE;
	    }
	    break;
	default:
	    if (isdigit(CharOf(*s))) {
		value = (value * 10) + (*s - '0');
		if (value > 10000)
d263 7
d271 24
a294 2
	    } else {
		done = TRUE;
a296 1
    }
d298 22
a319 8
    /*
     * If we found an error, ignore (and remove) the flags.
     */
    if (err) {
	prec = width = value = 0;
	format = fmt;
	*format++ = '%';
	*format++ = *s;
a320 9

    if (dot)
	width = value;
    else
	prec = value;

    *format = '\0';
    /* return maximum string length in print */
    *len = (prec > width) ? prec : width;
d327 13
a339 2
static inline char *
tparam_internal(const char *string, va_list ap)
d341 3
a343 6
#define NUM_VARS 26
    char *p_is_s[9];
    int param[9];
    int lastpop;
    int popcount;
    int number;
d345 2
a346 6
    int level;
    int x, y;
    int i;
    size_t len2;
    register const char *cp;
    static size_t len_fmt;
a347 3
    static char *format;
    static int dynamic_var[NUM_VARS];
    static int static_vars[NUM_VARS];
d349 2
a350 3
    out_used = 0;
    if (string == NULL)
	return NULL;
d352 5
a356 4
    if ((len2 = strlen(string)) > len_fmt) {
	len_fmt = len2 + len_fmt + 2;
	if ((format = typeRealloc(char, len_fmt, format)) == 0)
	      return 0;
d359 2
a360 10
    /*
     * Find the highest parameter-number referred to in the format string.
     * Use this value to limit the number of arguments copied from the
     * variable-length argument list.
     */

    number = 0;
    lastpop = -1;
    popcount = 0;
    memset(p_is_s, 0, sizeof(p_is_s));
d362 1
a362 13
    /*
     * Analyze the string to see how many parameters we need from the varargs
     * list, and what their types are.  We will only accept string parameters
     * if they appear as a %l or %s format following an explicit parameter
     * reference (e.g., %p2%s).  All other parameters are numbers.
     *
     * 'number' counts coarsely the number of pop's we see in the string, and
     * 'popcount' shows the highest parameter number in the string.  We would
     * like to simply use the latter count, but if we are reading termcap
     * strings, there may be cases that we cannot see the explicit parameter
     * numbers.
     */
    for (cp = string; (cp - string) < (int) len2;) {
d365 1
a365 1
	    cp = parse_format(cp, format, &len);
d375 2
a376 1
		number++;
d389 2
a390 2
		i = (*cp - '0');
		if (i >= 0 && i <= 9) {
d392 2
a393 2
		    if (lastpop > popcount)
			popcount = lastpop;
d398 4
d413 1
a413 1
		while (*cp >= '0' && *cp <= '9') {
d431 4
d438 1
a438 1
		number += 2;
d442 1
a442 3
		lastpop = -1;
		if (popcount < 2)
		    popcount = 2;
d450 34
a483 2
    if (number > 9)
	number = 9;
d488 3
a490 1
	 * a char* and an int may not be the same size on the stack.
d495 1
a495 1
	    param[i] = va_arg(ap, int);
d506 1
a506 1
    stack_ptr = 0;
d509 6
a514 2
	for (i = number - 1; i >= 0; i--)
	    npush(param[i]);
d517 1
a517 1
    if (_nc_tracing & TRACE_CALLS) {
d524 3
a526 2
	_tracef(T_CALLED("%s(%s%s)"), tname, _nc_visbuf(string), out_buff);
	out_used = 0;
d530 3
a532 3
    while (*string) {
	if (*string != '%') {
	    save_char(*string);
d534 3
a536 3
	    string++;
	    string = parse_format(string, format, &len);
	    switch (*string) {
d547 3
d551 1
a551 1
		save_number(format, npop(), len);
d555 1
a555 1
		save_number("%d", strlen(spop()), 0);
d559 1
a559 1
		save_text(format, spop(), len);
d563 3
a565 3
		string++;
		i = (*string - '1');
		if (i >= 0 && i < 9) {
d574 7
a580 7
		string++;
		if (isUPPER(*string)) {
		    i = (*string - 'A');
		    static_vars[i] = npop();
		} else if (isLOWER(*string)) {
		    i = (*string - 'a');
		    dynamic_var[i] = npop();
d585 7
a591 7
		string++;
		if (isUPPER(*string)) {
		    i = (*string - 'A');
		    npush(static_vars[i]);
		} else if (isLOWER(*string)) {
		    i = (*string - 'a');
		    npush(dynamic_var[i]);
d596 3
a598 3
		string++;
		npush(*string);
		string++;
d603 4
a606 4
		string++;
		while (*string >= '0' && *string <= '9') {
		    number = number * 10 + *string - '0';
		    string++;
d697 1
a697 1
		    string++;
d699 4
a702 4
		    while (*string) {
			if (*string == '%') {
			    string++;
			    if (*string == '?')
d704 1
a704 1
			    else if (*string == ';') {
d709 1
a709 1
			    } else if (*string == 'e' && level == 0)
d713 2
a714 2
			if (*string)
			    string++;
d721 1
a721 1
		string++;
d723 4
a726 4
		while (*string) {
		    if (*string == '%') {
			string++;
			if (*string == '?')
d728 1
a728 1
			else if (*string == ';') {
d736 2
a737 2
		    if (*string)
			string++;
d744 2
a745 2
	    }			/* endswitch (*string) */
	}			/* endelse (*string == '%') */
d747 1
a747 1
	if (*string == '\0')
d750 2
a751 2
	string++;
    }				/* endwhile (*string) */
d754 1
a754 1
    out_buff[out_used] = '\0';
d756 2
a757 2
    T((T_RETURN("%s"), _nc_visbuf(out_buff)));
    return (out_buff);
d760 6
d767 1
a767 2
tparm
(NCURSES_CONST char *string,...)
d772 1
d775 1
a775 1
    tname = "tparm";
d781 17
@


1.7
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_tparm.c,v 1.6 2000/10/22 18:27:23 millert Exp $	*/
d168 1
a168 1
    (void) sprintf(out_buff + out_used, fmt, s);
d180 1
a180 1
    (void) sprintf(out_buff + out_used, fmt, number);
@


1.6
log
@update to ncurses 5.2
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_tparm.c,v 1.5 2000/10/08 22:47:02 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: lib_tparm.c,v 1.48 2000/10/14 17:45:00 Sergei.Ivanov Exp $")
d131 1
a131 1
void
d291 1
a291 1
	    if (isdigit(*s)) {
d729 3
a731 2
char *
tparm(NCURSES_CONST char *string,...)
@


1.5
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_tparm.c,v 1.4 1999/06/06 15:55:18 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: lib_tparm.c,v 1.47 2000/10/04 00:57:13 tom Exp $")
d722 1
a722 2
    if (out_buff == 0 && (out_buff = typeCalloc(char, 1)) == NULL)
	  return (NULL);
@


1.4
log
@ncurses-4.2-990605
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_tparm.c,v 1.3 1999/05/13 03:01:47 aaron Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 1

d47 1
a47 1
MODULE_ID("$From: lib_tparm.c,v 1.39 1999/06/06 00:04:55 tom Exp $")
d78 2
d111 6
a116 3
typedef union {
	unsigned int	num;
	char	       *str;
d119 3
a121 2
static  stack_frame	stack[STACKSIZE];
static	int	stack_ptr;
d126 1
a126 1
static char  *out_buff;
d131 2
a132 1
void _nc_free_tparm(void)
d134 5
a138 5
	if (out_buff != 0) {
		FreeAndNull(out_buff);
		out_size = 0;
		out_used = 0;
	}
d142 2
a143 28
static void really_get_space(size_t need)
{
	out_size = need * 2;
	out_buff = typeRealloc(char, out_size, out_buff);
	if (out_buff == 0)
		_nc_err_abort("Out of memory");
}

static inline void get_space(size_t need)
{
	need += out_used;
	if (need > out_size)
		really_get_space(need);
}

static inline void save_text(const char *fmt, char *s, int len)
{
	size_t s_len = strlen(s);
	if (len > (int)s_len)
		s_len = len;

	get_space(s_len + 1);

	(void)sprintf(out_buff+out_used, fmt, s);
	out_used += strlen(out_buff+out_used);
}

static inline void save_number(const char *fmt, int number, int len)
d145 154
a298 22
	if (len < 30)
		len = 30; /* actually log10(MAX_INT)+1 */

	get_space(len + 1);

	(void)sprintf(out_buff+out_used, fmt, number);
	out_used += strlen(out_buff+out_used);
}

static inline void save_char(int c)
{
	if (c == 0)
		c = 0200;
	get_space(1);
	out_buff[out_used++] = c;
}

static inline void npush(int x)
{
	if (stack_ptr < STACKSIZE) {
		stack[stack_ptr].num = x;
		stack_ptr++;
d300 1
a300 1
}
d302 9
a310 10
static inline int npop(void)
{
	return   (stack_ptr > 0  ?  stack[--stack_ptr].num  :  0);
}

static inline char *spop(void)
{
	static char dummy[] = "";	/* avoid const-cast */
	return   (stack_ptr > 0  ?  stack[--stack_ptr].str  :  dummy);
}
d312 9
a320 58
static inline const char *parse_format(const char *s, char *format, int *len)
{
	bool done = FALSE;
	bool allowminus = FALSE;
	bool dot = FALSE;
	int prec  = 0;
	int width = 0;

	*len = 0;
	*format++ = '%';
	while (*s != '\0' && !done) {
		switch (*s) {
		case 'c':	/* FALLTHRU */
		case 'd':	/* FALLTHRU */
		case 'o':	/* FALLTHRU */
		case 'x':	/* FALLTHRU */
		case 'X':	/* FALLTHRU */
		case 's':
			*format++ = *s;
			done = TRUE;
			break;
		case '.':
			*format++ = *s++;
			dot = TRUE;
			break;
		case '#':
			*format++ = *s++;
			break;
		case ' ':
			*format++ = *s++;
			break;
		case ':':
			s++;
			allowminus = TRUE;
			break;
		case '-':
			if (allowminus) {
				*format++ = *s++;
			} else {
				done = TRUE;
			}
			break;
		default:
			if (isdigit(*s)) {
				if (dot)
					prec  = (prec * 10) + (*s - '0');
				else
					width = (width * 10) + (*s - '0');
				*format++ = *s++;
			} else {
				done = TRUE;
			}
		}
	}
	*format = '\0';
	/* return maximum string length in print */
	*len = (prec > width) ? prec : width;
	return s;
d326 2
a327 1
static inline char *tparam_internal(const char *string, va_list ap)
d330 83
a412 16
int	param[9];
int	popcount;
int	number;
int	len;
int	level;
int	x, y;
int	i;
register const char *cp;
static	size_t len_fmt;
static	char *format;
static	int dynamic_var[NUM_VARS];
static	int static_vars[NUM_VARS];

	out_used = 0;
	if (string == NULL)
		return NULL;
d414 14
a427 29
	/*
	 * Find the highest parameter-number referred to in the format string.
	 * Use this value to limit the number of arguments copied from the
	 * variable-length argument list.
	 */
	for (cp = string, popcount = number = 0; *cp != '\0'; cp++) {
		if (cp[0] == '%' && cp[1] != '\0') {
			switch (cp[1]) {
			case '%':
				cp++;
				break;
			case 'i':
				if (popcount < 2)
					popcount = 2;
				break;
			case 'p':
				cp++;
				if (cp[1] >= '1' && cp[1] <= '9') {
					int c = cp[1] - '0';
					if (c > popcount)
						popcount = c;
				}
				break;
			case '0': case '1': case '2': case '3': case '4':
			case '5': case '6': case '7': case '8': case '9':
			case 'd': case 'c': case 's':
				++number;
				break;
			}
d429 1
a429 6
	}
	if ((size_t)(cp - string) > len_fmt) {
		len_fmt = (cp - string) + len_fmt + 2;
		if ((format = typeRealloc(char, len_fmt, format)) == 0)
			return 0;
	}
d431 25
a455 7
	if (number > 9) number = 9;
	for (i = 0; i < max(popcount, number); i++) {
		/*
		 * FIXME: potential loss here if sizeof(int) != sizeof(char *).
		 * A few caps (such as plab_norm) have string-valued parms.
		 */
		param[i] = va_arg(ap, int);
d457 7
a463 1

d465 3
a467 5
	 * This is a termcap compatibility hack.  If there are no explicit pop
	 * operations in the string, load the stack in such a way that
	 * successive pops will grab successive parameters.  That will make
	 * the expansion of (for example) \E[%d;%dH work correctly in termcap
	 * style, which means tparam() will expand termcap strings OK.
d469 4
a472 5
	stack_ptr = 0;
	if (popcount == 0) {
		popcount = number;
		for (i = number - 1; i >= 0; i--)
			npush(param[i]);
d474 1
d476 13
d490 6
a495 5
	if (_nc_tracing & TRACE_CALLS) {
		for (i = 0; i < popcount; i++)
			save_number(", %d", param[i], 0);
		_tracef(T_CALLED("%s(%s%s)"), tname, _nc_visbuf(string), out_buff);
		out_used = 0;
d497 3
d502 28
a529 12
	while (*string) {
		if (*string != '%') {
			save_char(*string);
		} else {
			string++;
			string = parse_format(string, format, &len);
			switch (*string) {
			default:
				break;
			case '%':
				save_char('%');
				break;
d531 10
a540 7
			case 'd':	/* FALLTHRU */
			case 'o':	/* FALLTHRU */
			case 'x':	/* FALLTHRU */
			case 'X':	/* FALLTHRU */
			case 'c':
				save_number(format, npop(), len);
				break;
d542 10
a551 3
			case 'l':
				save_number("%d", strlen(spop()), 0);
				break;
d553 10
a562 3
			case 's':
				save_text(format, spop(), len);
				break;
d564 5
a568 5
			case 'p':
				string++;
				if (*string >= '1'  &&  *string <= '9')
					npush(param[*string - '1']);
				break;
d570 9
a578 10
			case 'P':
				string++;
				if (isUPPER(*string)) {
					i = (*string - 'A');
					static_vars[i] = npop();
				} else if (isLOWER(*string)) {
					i = (*string - 'a');
					dynamic_var[i] = npop();
				}
				break;
d580 99
a678 9
			case 'g':
				string++;
				if (isUPPER(*string)) {
					i = (*string - 'A');
					npush(static_vars[i]);
				} else if (isLOWER(*string)) {
					i = (*string - 'a');
					npush(dynamic_var[i]);
				}
d680 1
d682 5
a686 5
			case S_QUOTE:
				string++;
				npush(*string);
				string++;
				break;
d688 13
a700 8
			case L_BRACE:
				number = 0;
				string++;
				while (*string >= '0'  &&  *string <= '9') {
					number = number * 10 + *string - '0';
					string++;
				}
				npush(number);
d702 2
d705 4
a708 25
			case '+':
				npush(npop() + npop());
				break;

			case '-':
				y = npop();
				x = npop();
				npush(x - y);
				break;

			case '*':
				npush(npop() * npop());
				break;

			case '/':
				y = npop();
				x = npop();
				npush(y ? (x / y) : 0);
				break;

			case 'm':
				y = npop();
				x = npop();
				npush(y ? (x % y) : 0);
				break;
d710 2
a711 37
			case 'A':
				npush(npop() && npop());
				break;

			case 'O':
				npush(npop() || npop());
				break;

			case '&':
				npush(npop() & npop());
				break;

			case '|':
				npush(npop() | npop());
				break;

			case '^':
				npush(npop() ^ npop());
				break;

			case '=':
				y = npop();
				x = npop();
				npush(x == y);
				break;

			case '<':
				y = npop();
				x = npop();
				npush(x < y);
				break;

			case '>':
				y = npop();
				x = npop();
				npush(x > y);
				break;
d713 2
a714 15
			case '!':
				npush(! npop());
				break;

			case '~':
				npush(~ npop());
				break;

			case 'i':
				param[0]++;
				param[1]++;
				break;

			case '?':
				break;
d716 2
a717 26
			case 't':
				x = npop();
				if (!x) {
					/* scan forward for %e or %; at level zero */
					string++;
					level = 0;
					while (*string) {
						if (*string == '%') {
							string++;
							if (*string == '?')
								level++;
							else if (*string == ';') {
								if (level > 0)
									level--;
								else
									break;
							}
							else if (*string == 'e'  && level == 0)
								break;
						}

						if (*string)
							string++;
					}
				}
				break;
d719 2
a720 33
			case 'e':
				/* scan forward for a %; at level zero */
				string++;
				level = 0;
				while (*string) {
					if (*string == '%') {
						string++;
						if (*string == '?')
							level++;
						else if (*string == ';') {
							if (level > 0)
								level--;
							else
								break;
						}
					}

					if (*string)
						string++;
				}
				break;

			case ';':
				break;

			} /* endswitch (*string) */
		} /* endelse (*string == '%') */

		if (*string == '\0')
			break;

		string++;
	} /* endwhile (*string) */
d722 3
a724 3
	if (out_buff == 0 && (out_buff = typeCalloc(char,1)) == NULL)
		return(NULL);
	out_buff[out_used] = '\0';
d726 2
a727 2
	T((T_RETURN("%s"), _nc_visbuf(out_buff)));
	return(out_buff);
d730 2
a731 1
char *tparm(NCURSES_CONST char *string, ...)
d733 2
a734 2
va_list	ap;
char *result;
d736 1
a736 1
	va_start(ap, string);
d738 1
a738 1
	tname = "tparm";
d740 3
a742 3
	result = tparam_internal(string, ap);
	va_end(ap);
	return result;
@


1.3
log
@dividing by zero is bad++, patch sent to millert@@ for forwarding to curses ppl
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_tparm.c,v 1.2 1999/03/02 06:23:29 millert Exp $	*/
d48 1
a48 1
MODULE_ID("$From: lib_tparm.c,v 1.38 1999/02/27 20:08:22 tom Exp $")
d443 1
a443 2
				if (y)
					npush(x / y);
d449 1
a449 2
				if (y)
					npush(x % y);
@


1.2
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_tparm.c,v 1.1 1999/01/18 19:10:20 millert Exp $	*/
d443 2
a444 1
				npush(x / y);
d450 2
a451 1
				npush(x % y);
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_tparm.c,v 1.5 1998/10/31 06:30:30 millert Exp $	*/
d48 1
a48 1
MODULE_ID("$From: lib_tparm.c,v 1.37 1999/01/02 22:38:25 tom Exp $")
d139 1
a139 1
	out_buff = (char *)_nc_doalloc(out_buff, out_size);
d317 1
a317 1
		if ((format = _nc_doalloc(format, len_fmt)) == 0)
d567 1
a567 1
	if (out_buff == 0 && (out_buff = calloc(1,1)) == NULL)
@

