head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.28
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.24
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.26
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.18
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.22
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.20
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.38
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.34
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.32
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.30
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.28
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.26
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.24
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.22
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.20
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.18
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.16
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.14
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.12
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.10
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.22.18.01.53;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.08.22.47.01;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.13.23.53.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.10.01.35.04;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.02.22.06.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.11.28.17.49.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.07.04.12.43.16;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.02.24.06.31.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.18;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2006,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
**	lib_options.c
**
**	The routines to handle option setting.
**
*/

#include <curses.priv.h>

#include <term.h>

MODULE_ID("$Id: lib_options.c,v 1.58 2008/08/16 21:20:48 Werner.Fink Exp $")

static int _nc_curs_set(SCREEN *, int);
static int _nc_meta(SCREEN *, bool);

NCURSES_EXPORT(int)
idlok(WINDOW *win, bool flag)
{
    T((T_CALLED("idlok(%p,%d)"), win, flag));

    if (win) {
	_nc_idlok = win->_idlok = (flag && (has_il() || change_scroll_region));
	returnCode(OK);
    } else
	returnCode(ERR);
}

NCURSES_EXPORT(void)
idcok(WINDOW *win, bool flag)
{
    T((T_CALLED("idcok(%p,%d)"), win, flag));

    if (win)
	_nc_idcok = win->_idcok = (flag && has_ic());

    returnVoid;
}

NCURSES_EXPORT(int)
halfdelay(int t)
{
    T((T_CALLED("halfdelay(%d)"), t));

    if (t < 1 || t > 255 || SP == 0)
	returnCode(ERR);

    cbreak();
    SP->_cbreak = t + 1;
    returnCode(OK);
}

NCURSES_EXPORT(int)
nodelay(WINDOW *win, bool flag)
{
    T((T_CALLED("nodelay(%p,%d)"), win, flag));

    if (win) {
	if (flag == TRUE)
	    win->_delay = 0;
	else
	    win->_delay = -1;
	returnCode(OK);
    } else
	returnCode(ERR);
}

NCURSES_EXPORT(int)
notimeout(WINDOW *win, bool f)
{
    T((T_CALLED("notimeout(%p,%d)"), win, f));

    if (win) {
	win->_notimeout = f;
	returnCode(OK);
    } else
	returnCode(ERR);
}

NCURSES_EXPORT(void)
wtimeout(WINDOW *win, int delay)
{
    T((T_CALLED("wtimeout(%p,%d)"), win, delay));

    if (win) {
	win->_delay = delay;
    }
    returnVoid;
}

NCURSES_EXPORT(int)
keypad(WINDOW *win, bool flag)
{
    T((T_CALLED("keypad(%p,%d)"), win, flag));

    if (win) {
	win->_use_keypad = flag;
	returnCode(_nc_keypad(SP, flag));
    } else
	returnCode(ERR);
}

NCURSES_EXPORT(int)
meta(WINDOW *win GCC_UNUSED, bool flag)
{
    int result;

    /* Ok, we stay relaxed and don't signal an error if win is NULL */
    T((T_CALLED("meta(%p,%d)"), win, flag));
    result = _nc_meta(SP, flag);
    returnCode(result);
}

/* curs_set() moved here to narrow the kernel interface */

NCURSES_EXPORT(int)
curs_set(int vis)
{
    int result;

    T((T_CALLED("curs_set(%d)"), vis));
    result = _nc_curs_set(SP, vis);
    returnCode(result);
}

NCURSES_EXPORT(int)
typeahead(int fd)
{
    T((T_CALLED("typeahead(%d)"), fd));
    if (SP != 0) {
	SP->_checkfd = fd;
	returnCode(OK);
    } else {
	returnCode(ERR);
    }
}

/*
**      has_key()
**
**      Return TRUE if the current terminal has the given key
**
*/

#if NCURSES_EXT_FUNCS
static int
has_key_internal(int keycode, TRIES * tp)
{
    if (tp == 0)
	return (FALSE);
    else if (tp->value == keycode)
	return (TRUE);
    else
	return (has_key_internal(keycode, tp->child)
		|| has_key_internal(keycode, tp->sibling));
}

NCURSES_EXPORT(int)
has_key(int keycode)
{
    T((T_CALLED("has_key(%d)"), keycode));
    returnCode(SP != 0 ? has_key_internal(keycode, SP->_keytry) : FALSE);
}
#endif /* NCURSES_EXT_FUNCS */

/*
 * Internal entrypoints use SCREEN* parameter to obtain capabilities rather
 * than cur_term.
 */
#undef CUR
#define CUR (sp->_term)->type.

static int
_nc_putp(const char *name GCC_UNUSED, const char *value)
{
    int rc = ERR;

    if (value) {
	TPUTS_TRACE(name);
	rc = putp(value);
    }
    return rc;
}

static int
_nc_putp_flush(const char *name, const char *value)
{
    int rc = _nc_putp(name, value);
    if (rc != ERR) {
	_nc_flush();
    }
    return rc;
}

/* Turn the keypad on/off
 *
 * Note:  we flush the output because changing this mode causes some terminals
 * to emit different escape sequences for cursor and keypad keys.  If we don't
 * flush, then the next wgetch may get the escape sequence that corresponds to
 * the terminal state _before_ switching modes.
 */
NCURSES_EXPORT(int)
_nc_keypad(SCREEN *sp, bool flag)
{
    int rc = ERR;

    if (sp != 0) {
#ifdef USE_PTHREADS
	/*
	 * We might have this situation in a multithreaded application that
	 * has wgetch() reading in more than one thread.  putp() and below
	 * may use SP explicitly.
	 */
	if (_nc_use_pthreads && sp != SP) {
	    SCREEN *save_sp;

	    /* cannot use use_screen(), since that is not in tinfo library */
	    _nc_lock_global(curses);
	    save_sp = SP;
	    _nc_set_screen(sp);
	    rc = _nc_keypad(sp, flag);
	    _nc_set_screen(save_sp);
	    _nc_unlock_global(curses);
	} else
#endif
	{
	    if (flag) {
		(void) _nc_putp_flush("keypad_xmit", keypad_xmit);
	    } else if (!flag && keypad_local) {
		(void) _nc_putp_flush("keypad_local", keypad_local);
	    }

	    if (flag && !sp->_tried) {
		_nc_init_keytry(sp);
		sp->_tried = TRUE;
	    }
	    sp->_keypad_on = flag;
	    rc = OK;
	}
    }
    return (rc);
}

static int
_nc_curs_set(SCREEN *sp, int vis)
{
    int result = ERR;

    T((T_CALLED("curs_set(%d)"), vis));
    if (sp != 0 && vis >= 0 && vis <= 2) {
	int cursor = sp->_cursor;

	if (vis == cursor) {
	    result = cursor;
	} else {
	    switch (vis) {
	    case 2:
		result = _nc_putp_flush("cursor_visible", cursor_visible);
		break;
	    case 1:
		result = _nc_putp_flush("cursor_normal", cursor_normal);
		break;
	    case 0:
		result = _nc_putp_flush("cursor_invisible", cursor_invisible);
		break;
	    }
	    if (result != ERR)
		result = (cursor == -1 ? 1 : cursor);
	    sp->_cursor = vis;
	}
    }
    returnCode(result);
}

static int
_nc_meta(SCREEN *sp, bool flag)
{
    int result = ERR;

    /* Ok, we stay relaxed and don't signal an error if win is NULL */

    if (SP != 0) {
	SP->_use_meta = flag;

	if (flag) {
	    _nc_putp("meta_on", meta_on);
	} else {
	    _nc_putp("meta_off", meta_off);
	}
	result = OK;
    }
    return result;
}
@


1.9
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_options.c,v 1.8 2000/10/08 22:47:01 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d48 4
a51 1
MODULE_ID("$From: lib_options.c,v 1.42 2000/12/10 02:55:07 tom Exp $")
d81 1
a81 1
    if (t < 1 || t > 255)
d107 1
a107 1
    T((T_CALLED("notimout(%p,%d)"), win, f));
d124 1
d134 1
a134 1
	returnCode(_nc_keypad(flag));
d142 2
d146 2
a147 11

    SP->_use_meta = flag;

    if (flag && meta_on) {
	TPUTS_TRACE("meta_on");
	putp(meta_on);
    } else if (!flag && meta_off) {
	TPUTS_TRACE("meta_off");
	putp(meta_off);
    }
    returnCode(OK);
d155 1
a155 1
    int cursor = SP->_cursor;
d158 2
a159 34

    if (vis < 0 || vis > 2)
	returnCode(ERR);

    if (vis == cursor)
	returnCode(cursor);

    switch (vis) {
    case 2:
	if (cursor_visible) {
	    TPUTS_TRACE("cursor_visible");
	    putp(cursor_visible);
	} else
	    returnCode(ERR);
	break;
    case 1:
	if (cursor_normal) {
	    TPUTS_TRACE("cursor_normal");
	    putp(cursor_normal);
	} else
	    returnCode(ERR);
	break;
    case 0:
	if (cursor_invisible) {
	    TPUTS_TRACE("cursor_invisible");
	    putp(cursor_invisible);
	} else
	    returnCode(ERR);
	break;
    }
    SP->_cursor = vis;
    _nc_flush();

    returnCode(cursor == -1 ? 1 : cursor);
d166 6
a171 2
    SP->_checkfd = fd;
    returnCode(OK);
d183 1
a183 1
has_key_internal(int keycode, struct tries *tp)
d198 1
a198 1
    returnCode(has_key_internal(keycode, SP->_keytry));
d202 29
d239 1
a239 1
_nc_keypad(bool flag)
d241 66
a306 8
    if (flag && keypad_xmit) {
	TPUTS_TRACE("keypad_xmit");
	putp(keypad_xmit);
	_nc_flush();
    } else if (!flag && keypad_local) {
	TPUTS_TRACE("keypad_local");
	putp(keypad_local);
	_nc_flush();
d308 12
d321 6
a326 3
    if (flag && !SP->_tried) {
	_nc_init_keytry();
	SP->_tried = TRUE;
d328 1
a328 1
    return (OK);
@


1.8
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_options.c,v 1.7 2000/03/13 23:53:40 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: lib_options.c,v 1.40 2000/09/02 18:02:05 tom Exp $")
d49 1
a49 1
int
d61 1
a61 1
void
d72 1
a72 1
int
d85 1
a85 1
int
d100 1
a100 1
int
d112 1
a112 1
void
d122 1
a122 1
int
d134 1
a134 1
int
d154 1
a154 1
int
d196 1
a196 1
int
d221 1
a221 1
	    || has_key_internal(keycode, tp->sibling));
d224 1
a224 1
int
d239 1
a239 1
int
@


1.7
log
@update to ncurses-5.0-20000311
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_options.c,v 1.6 2000/03/10 01:35:04 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: lib_options.c,v 1.39 2000/03/12 00:19:11 tom Exp $")
d211 1
a211 1
#ifdef NCURSES_EXT_FUNCS
@


1.6
log
@Update to ncurses-5.0-20000304
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_options.c,v 1.5 2000/01/02 22:06:51 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: lib_options.c,v 1.38 2000/02/13 01:01:26 tom Exp $")
d55 1
a55 1
	_nc_idlok = win->_idlok = flag && (has_il() || change_scroll_region);
d67 1
a67 1
	_nc_idcok = win->_idcok = flag && has_ic();
@


1.5
log
@+ corrected conversion from terminfo rs2 to termcap rs (cf: 980704)
+ make conversion to termcap ug (underline glitch) more consistently applied.
+ modify read_termtype(), fixing 'toe', which could dump core when it
found an incomplete entry such as "dumb" because it did not
initialize its buffer for _nc_read_file_entry().
+ use explicit VALID_NUMERIC() checks in a few places that had been
overlooked, and add a check to ensure that init_tabs is nonzero,
to avoid divide-by-zero (reported by Todd C Miller).
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_options.c,v 1.4 1999/11/28 17:49:54 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d47 1
a47 1
MODULE_ID("$From: lib_options.c,v 1.37 2000/01/01 16:59:50 tom Exp $")
@


1.4
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_options.c,v 1.3 1999/07/04 12:43:16 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a35 1

d45 1
a45 2
#include <term.h>	/* keypad_xmit, keypad_local, meta_on, meta_off */
			/* cursor_visible,cursor_normal,cursor_invisible */
d47 1
a47 1
MODULE_ID("$From: lib_options.c,v 1.36 1999/10/22 21:38:57 tom Exp $")
d49 2
a50 1
int idlok(WINDOW *win,  bool flag)
d52 1
a52 1
	T((T_CALLED("idlok(%p,%d)"), win, flag));
d54 5
a58 6
	if (win) {
	  _nc_idlok = win->_idlok = flag && (has_il() || change_scroll_region);
	  returnCode(OK);
	}
	else
	  returnCode(ERR);
d61 2
a62 2

void idcok(WINDOW *win, bool flag)
d64 1
a64 1
	T((T_CALLED("idcok(%p,%d)"), win, flag));
d66 2
a67 2
	if (win)
	  _nc_idcok = win->_idcok = flag && has_ic();
d69 1
a69 1
	returnVoid;
d72 2
a73 1
int halfdelay(int t)
d75 1
a75 1
	T((T_CALLED("halfdelay(%d)"), t));
d77 2
a78 2
	if (t < 1 || t > 255)
		returnCode(ERR);
d80 3
a82 3
	cbreak();
	SP->_cbreak = t+1;
	returnCode(OK);
d85 2
a86 1
int nodelay(WINDOW *win, bool flag)
d88 1
a88 1
	T((T_CALLED("nodelay(%p,%d)"), win, flag));
d90 2
a91 2
	if (win) {
	  if (flag == TRUE)
a92 3
	  else win->_delay = -1;
	  returnCode(OK);
	}
d94 4
a97 1
	  returnCode(ERR);
d100 2
a101 1
int notimeout(WINDOW *win, bool f)
d103 1
a103 1
	T((T_CALLED("notimout(%p,%d)"), win, f));
d105 5
a109 6
	if (win) {
	  win->_notimeout = f;
	  returnCode(OK);
	}
	else
	  returnCode(ERR);
d112 2
a113 1
void wtimeout(WINDOW *win, int delay)
d115 1
a115 1
	T((T_CALLED("wtimeout(%p,%d)"), win, delay));
d117 3
a119 3
	if (win) {
	  win->_delay = delay;
	}
d122 2
a123 1
int keypad(WINDOW *win, bool flag)
d125 1
a125 1
	T((T_CALLED("keypad(%p,%d)"), win, flag));
d127 5
a131 6
	if (win) {
	  win->_use_keypad = flag;
	  returnCode(_nc_keypad(flag));
	}
	else
	  returnCode(ERR);
d134 2
a135 2

int meta(WINDOW *win GCC_UNUSED, bool flag)
d137 2
a138 2
        /* Ok, we stay relaxed and don't signal an error if win is NULL */
	T((T_CALLED("meta(%p,%d)"), win, flag));
d140 1
a140 1
	SP->_use_meta = flag;
d142 8
a149 11
	if (flag  &&  meta_on)
	{
	    TPUTS_TRACE("meta_on");
	    putp(meta_on);
	}
	else if (! flag  &&  meta_off)
	{
	    TPUTS_TRACE("meta_off");
	    putp(meta_off);
	}
	returnCode(OK);
d154 2
a155 1
int curs_set(int vis)
d157 1
a157 1
int cursor = SP->_cursor;
d159 1
a159 1
	T((T_CALLED("curs_set(%d)"), vis));
d161 41
a201 46
	if (vis < 0 || vis > 2)
		returnCode(ERR);

	if (vis == cursor)
		returnCode(cursor);

	switch(vis) {
	case 2:
		if (cursor_visible)
		{
			TPUTS_TRACE("cursor_visible");
			putp(cursor_visible);
		}
		else
			returnCode(ERR);
		break;
	case 1:
		if (cursor_normal)
		{
			TPUTS_TRACE("cursor_normal");
			putp(cursor_normal);
		}
		else
			returnCode(ERR);
		break;
	case 0:
		if (cursor_invisible)
		{
			TPUTS_TRACE("cursor_invisible");
			putp(cursor_invisible);
		}
		else
			returnCode(ERR);
		break;
	}
	SP->_cursor = vis;
	_nc_flush();

	returnCode(cursor==-1 ? 1 : cursor);
}

int typeahead(int fd)
{
	T((T_CALLED("typeahead(%d)"), fd));
	SP->_checkfd = fd;
	returnCode(OK);
d212 2
a213 1
static int has_key_internal(int keycode, struct tries *tp)
d216 1
a216 1
	return(FALSE);
d218 1
a218 1
	return(TRUE);
d220 2
a221 2
	return(has_key_internal(keycode, tp->child)
	       || has_key_internal(keycode, tp->sibling));
d224 2
a225 1
int has_key(int keycode)
d239 2
a240 1
int _nc_keypad(bool flag)
d242 15
a256 18
	if (flag  &&  keypad_xmit)
	{
	    TPUTS_TRACE("keypad_xmit");
	    putp(keypad_xmit);
	    _nc_flush();
	}
	else if (! flag  &&  keypad_local)
	{
	    TPUTS_TRACE("keypad_local");
	    putp(keypad_local);
	    _nc_flush();
	}

	if (flag && !SP->_tried) {
	    _nc_init_keytry();
	    SP->_tried = TRUE;
	}
	return(OK);
@


1.3
log
@ncurses-5.0-990703 -- better support for mixing termcap and terminfo/curses routines
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_options.c,v 1.2 1999/02/24 06:31:11 millert Exp $	*/
d49 1
a49 1
MODULE_ID("$From: lib_options.c,v 1.35 1999/07/04 00:18:28 tom Exp $")
d198 1
a198 1
	(void) fflush(SP->_ofp);
d249 1
a249 1
	    (void) fflush(SP->_ofp);
d255 1
a255 1
	    (void) fflush(SP->_ofp);
@


1.2
log
@ncurses-4.2-990220; this is a pre-release of 5.0
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_options.c,v 1.1 1999/01/18 19:10:18 millert Exp $	*/
d49 1
a49 1
MODULE_ID("$From: lib_options.c,v 1.34 1999/02/18 11:56:16 tom Exp $")
d258 1
a258 1
	if (!SP->_tried) {
@


1.1
log
@ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_options.c,v 1.5 1998/07/23 21:19:08 millert Exp $	*/
d49 1
a49 1
MODULE_ID("$From: lib_options.c,v 1.32 1998/12/19 23:09:50 tom Exp $")
a235 28
/*
**      init_keytry()
**
**      Construct the try for the current terminal's keypad keys.
**
*/

static void init_keytry(void)
{
/* LINT_PREPRO
#if 0*/
#include <keys.tries>
/* LINT_PREPRO
#endif*/
	size_t n;

	/* The SP->_keytry value is initialized in newterm(), where the SP
	 * structure is created, because we can not tell where keypad() or
	 * mouse_activate() (which will call keyok()) are first called.
	 */

	for (n = 0; n < SIZEOF(table); n++)
		if (table[n].offset < STRCOUNT)
		_nc_add_to_try(&(SP->_keytry),
			CUR Strings[table[n].offset],
			table[n].code);
}

d259 1
a259 1
	    init_keytry();
@

