head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.34
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.32
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.28
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.24
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.26
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.18
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.22
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.30
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.26
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.24
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.22
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.20
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.18
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.16
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.14
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.12
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.10
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.8
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.6
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.8
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.6
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2010.01.12.23.22.06;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.18.16.55.54;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.22.04.37.56;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.22.04.16.35;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.21.15.47.23;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.22.18.01.51;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.08.22.47.00;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.10.03.06.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.19.03.53.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.04.16.49.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.26.16.45.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.10.01.35.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.16.01.35.18;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.11.28.17.49.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.18.19.10.14;	author millert;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2006,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996 on                 *
 ****************************************************************************/

/*
 *	comp_scan.c --- Lexical scanner for terminfo compiler.
 *
 *	_nc_reset_input()
 *	_nc_get_token()
 *	_nc_panic_mode()
 *	int _nc_syntax;
 *	int _nc_curr_line;
 *	long _nc_curr_file_pos;
 *	long _nc_comment_start;
 *	long _nc_comment_end;
 */

#include <curses.priv.h>

#include <ctype.h>
#include <term_entry.h>
#include <tic.h>

MODULE_ID("$Id: comp_scan.c,v 1.83 2008/08/16 19:22:55 tom Exp $")

/*
 * Maximum length of string capability we'll accept before raising an error.
 * Yes, there is a real capability in /etc/termcap this long, an "is".
 */
#define MAXCAPLEN	600

#define iswhite(ch)	(ch == ' '  ||  ch == '\t')

NCURSES_EXPORT_VAR(int)
_nc_syntax = 0;			/* termcap or terminfo? */
NCURSES_EXPORT_VAR(long)
_nc_curr_file_pos = 0;		/* file offset of current line */
NCURSES_EXPORT_VAR(long)
_nc_comment_start = 0;		/* start of comment range before name */
NCURSES_EXPORT_VAR(long)
_nc_comment_end = 0;		/* end of comment range before name */
NCURSES_EXPORT_VAR(long)
_nc_start_line = 0;		/* start line of current entry */

NCURSES_EXPORT_VAR(struct token)
_nc_curr_token =
{
    0, 0, 0
};

/*****************************************************************************
 *
 * Token-grabbing machinery
 *
 *****************************************************************************/

static bool first_column;	/* See 'next_char()' below */
static bool had_newline;
static char separator;		/* capability separator */
static int pushtype;		/* type of pushback token */
static char *pushname;

#if NCURSES_EXT_FUNCS
NCURSES_EXPORT_VAR(bool)
_nc_disable_period = FALSE;	/* used by tic -a option */
#endif

/*****************************************************************************
 *
 * Character-stream handling
 *
 *****************************************************************************/

#define LEXBUFSIZ	1024

static char *bufptr;		/* otherwise, the input buffer pointer */
static char *bufstart;		/* start of buffer so we can compute offsets */
static FILE *yyin;		/* scanner's input file descriptor */

/*
 *	_nc_reset_input()
 *
 *	Resets the input-reading routines.  Used on initialization,
 *	or after a seek has been done.  Exactly one argument must be
 *	non-null.
 */

NCURSES_EXPORT(void)
_nc_reset_input(FILE *fp, char *buf)
{
    pushtype = NO_PUSHBACK;
    if (pushname != 0)
	pushname[0] = '\0';
    yyin = fp;
    bufstart = bufptr = buf;
    _nc_curr_file_pos = 0L;
    if (fp != 0)
	_nc_curr_line = 0;
    _nc_curr_col = 0;
}

/*
 *	int last_char()
 *
 *	Returns the final nonblank character on the current input buffer
 */
static int
last_char(void)
{
    size_t len = strlen(bufptr);
    while (len--) {
	if (!isspace(UChar(bufptr[len])))
	    return bufptr[len];
    }
    return 0;
}

/*
 *	int next_char()
 *
 *	Returns the next character in the input stream.  Comments and leading
 *	white space are stripped.
 *
 *	The global state variable 'firstcolumn' is set TRUE if the character
 *	returned is from the first column of the input line.
 *
 *	The global variable _nc_curr_line is incremented for each new line.
 *	The global variable _nc_curr_file_pos is set to the file offset of the
 *	beginning of each line.
 */

static int
next_char(void)
{
    static char *result;
    static size_t allocated;
    int the_char;

    if (!yyin) {
	if (result != 0) {
	    FreeAndNull(result);
	    FreeAndNull(pushname);
	    allocated = 0;
	}
	/*
	 * An string with an embedded null will truncate the input.  This is
	 * intentional (we don't read binary files here).
	 */
	if (bufptr == 0 || *bufptr == '\0')
	    return (EOF);
	if (*bufptr == '\n') {
	    _nc_curr_line++;
	    _nc_curr_col = 0;
	} else if (*bufptr == '\t') {
	    _nc_curr_col = (_nc_curr_col | 7);
	}
    } else if (!bufptr || !*bufptr) {
	/*
	 * In theory this could be recoded to do its I/O one character at a
	 * time, saving the buffer space.  In practice, this turns out to be
	 * quite hard to get completely right.  Try it and see.  If you
	 * succeed, don't forget to hack push_back() correspondingly.
	 */
	size_t used;
	size_t len;

	do {
	    bufstart = 0;
	    used = 0;
	    do {
		if (used + (LEXBUFSIZ / 4) >= allocated) {
		    allocated += (allocated + LEXBUFSIZ);
		    result = typeRealloc(char, allocated, result);
		    if (result == 0)
			return (EOF);
		    bufstart = result;
		}
		if (used == 0)
		    _nc_curr_file_pos = ftell(yyin);

		if (fgets(result + used, (int) (allocated - used), yyin) != 0) {
		    bufstart = result;
		    if (used == 0) {
			_nc_curr_line++;
			_nc_curr_col = 0;
		    }
		} else {
		    if (used != 0)
			strlcat(result, "\n", allocated);
		}
		if ((bufptr = bufstart) != 0) {
		    used = strlen(bufptr);
		    while (iswhite(*bufptr)) {
			if (*bufptr == '\t') {
			    _nc_curr_col = (_nc_curr_col | 7) + 1;
			} else {
			    _nc_curr_col++;
			}
			bufptr++;
		    }

		    /*
		     * Treat a trailing <cr><lf> the same as a <newline> so we
		     * can read files on OS/2, etc.
		     */
		    if ((len = strlen(bufptr)) > 1) {
			if (bufptr[len - 1] == '\n'
			    && bufptr[len - 2] == '\r') {
			    len--;
			    bufptr[len - 1] = '\n';
			    bufptr[len] = '\0';
			}
		    }
		} else {
		    return (EOF);
		}
	    } while (bufptr[len - 1] != '\n');	/* complete a line */
	} while (result[0] == '#');	/* ignore comments */
    } else if (*bufptr == '\t') {
	_nc_curr_col = (_nc_curr_col | 7);
    }

    first_column = (bufptr == bufstart);
    if (first_column)
	had_newline = FALSE;

    _nc_curr_col++;
    the_char = *bufptr++;
    return UChar(the_char);
}

static void
push_back(char c)
/* push a character back onto the input stream */
{
    if (bufptr == bufstart)
	_nc_syserr_abort("Can't backspace off beginning of line");
    *--bufptr = c;
    _nc_curr_col--;
}

static long
stream_pos(void)
/* return our current character position in the input stream */
{
    return (yyin ? ftell(yyin) : (bufptr ? bufptr - bufstart : 0));
}

static bool
end_of_stream(void)
/* are we at end of input? */
{
    return ((yyin ? feof(yyin) : (bufptr && *bufptr == '\0'))
	    ? TRUE : FALSE);
}

/* Assume we may be looking at a termcap-style continuation */
static NCURSES_INLINE int
eat_escaped_newline(int ch)
{
    if (ch == '\\')
	while ((ch = next_char()) == '\n' || iswhite(ch))
	    continue;
    return ch;
}

#define TOK_BUF_SIZE MAX_ENTRY_SIZE

#define OkToAdd() \
	((tok_ptr - tok_buf) < (TOK_BUF_SIZE - 2))

#define AddCh(ch) \
	*tok_ptr++ = (char) ch; \
	*tok_ptr = '\0'

/*
 *	int
 *	get_token()
 *
 *	Scans the input for the next token, storing the specifics in the
 *	global structure 'curr_token' and returning one of the following:
 *
 *		NAMES		A line beginning in column 1.  'name'
 *				will be set to point to everything up to but
 *				not including the first separator on the line.
 *		BOOLEAN		An entry consisting of a name followed by
 *				a separator.  'name' will be set to point to
 *				the name of the capability.
 *		NUMBER		An entry of the form
 *					name#digits,
 *				'name' will be set to point to the capability
 *				name and 'valnumber' to the number given.
 *		STRING		An entry of the form
 *					name=characters,
 *				'name' is set to the capability name and
 *				'valstring' to the string of characters, with
 *				input translations done.
 *		CANCEL		An entry of the form
 *					name@@,
 *				'name' is set to the capability name and
 *				'valnumber' to -1.
 *		EOF		The end of the file has been reached.
 *
 *	A `separator' is either a comma or a semicolon, depending on whether
 *	we are in termcap or terminfo mode.
 *
 */

NCURSES_EXPORT(int)
_nc_get_token(bool silent)
{
    static const char terminfo_punct[] = "@@%&*!#";
    static char *tok_buf;

    char *after_list;
    char *after_name;
    char *numchk;
    char *tok_ptr;
    char *s;
    char numbuf[80];
    int ch;
    int dot_flag = FALSE;
    int type;
    long number;
    long token_start;
    unsigned found;
#ifdef TRACE
    int old_line;
    int old_col;
#endif

    if (pushtype != NO_PUSHBACK) {
	int retval = pushtype;

	_nc_set_type(pushname != 0 ? pushname : "");
	DEBUG(3, ("pushed-back token: `%s', class %d",
		  _nc_curr_token.tk_name, pushtype));

	pushtype = NO_PUSHBACK;
	if (pushname != 0)
	    pushname[0] = '\0';

	/* currtok wasn't altered by _nc_push_token() */
	return (retval);
    }

    if (end_of_stream()) {
	yyin = 0;
	next_char();		/* frees its allocated memory */
	if (tok_buf != 0) {
	    if (_nc_curr_token.tk_name == tok_buf)
		_nc_curr_token.tk_name = 0;
	    FreeAndNull(tok_buf);
	}
	return (EOF);
    }

  start_token:
    token_start = stream_pos();
    while ((ch = next_char()) == '\n' || iswhite(ch)) {
	if (ch == '\n')
	    had_newline = TRUE;
	continue;
    }

    ch = eat_escaped_newline(ch);

#ifdef TRACE
    old_line = _nc_curr_line;
    old_col = _nc_curr_col;
#endif
    if (ch == EOF)
	type = EOF;
    else {
	/* if this is a termcap entry, skip a leading separator */
	if (separator == ':' && ch == ':')
	    ch = next_char();

	if (ch == '.'
#if NCURSES_EXT_FUNCS
	    && !_nc_disable_period
#endif
	    ) {
	    dot_flag = TRUE;
	    DEBUG(8, ("dot-flag set"));

	    while ((ch = next_char()) == '.' || iswhite(ch))
		continue;
	}

	if (ch == EOF) {
	    type = EOF;
	    goto end_of_token;
	}

	/* have to make some punctuation chars legal for terminfo */
	if (!isalnum(UChar(ch))
#if NCURSES_EXT_FUNCS
	    && !(ch == '.' && _nc_disable_period)
#endif
	    && !strchr(terminfo_punct, (char) ch)) {
	    if (!silent)
		_nc_warning("Illegal character (expected alphanumeric or %s) - '%s'",
			    terminfo_punct, unctrl((chtype) ch));
	    _nc_panic_mode(separator);
	    goto start_token;
	}

	if (tok_buf == 0)
	    tok_buf = typeMalloc(char, TOK_BUF_SIZE);

#ifdef TRACE
	old_line = _nc_curr_line;
	old_col = _nc_curr_col;
#endif
	tok_ptr = tok_buf;
	AddCh(ch);

	if (first_column) {
	    _nc_comment_start = token_start;
	    _nc_comment_end = _nc_curr_file_pos;
	    _nc_start_line = _nc_curr_line;

	    _nc_syntax = ERR;
	    after_name = 0;
	    after_list = 0;
	    while ((ch = next_char()) != '\n') {
		if (ch == EOF) {
		    _nc_err_abort(MSG_NO_INPUTS);
		} else if (ch == '|') {
		    after_list = tok_ptr;
		    if (after_name == 0)
			after_name = tok_ptr;
		} else if (ch == ':' && last_char() != ',') {
		    _nc_syntax = SYN_TERMCAP;
		    separator = ':';
		    break;
		} else if (ch == ',') {
		    _nc_syntax = SYN_TERMINFO;
		    separator = ',';
		    /*
		     * If we did not see a '|', then we found a name with no
		     * aliases or description.
		     */
		    if (after_name == 0)
			break;
		    /*
		     * If we see a comma, we assume this is terminfo unless we
		     * subsequently run into a colon.  But we don't stop
		     * looking for a colon until hitting a newline.  This
		     * allows commas to be embedded in description fields of
		     * either syntax.
		     */
		} else
		    ch = eat_escaped_newline(ch);

		if (OkToAdd()) {
		    AddCh(ch);
		} else {
		    ch = EOF;
		    break;
		}
	    }
	    *tok_ptr = '\0';
	    if (_nc_syntax == ERR) {
		/*
		 * Grrr...what we ought to do here is barf, complaining that
		 * the entry is malformed.  But because a couple of name fields
		 * in the 8.2 termcap file end with |\, we just have to assume
		 * it's termcap syntax.
		 */
		_nc_syntax = SYN_TERMCAP;
		separator = ':';
	    } else if (_nc_syntax == SYN_TERMINFO) {
		/* throw away trailing /, *$/ */
		for (--tok_ptr;
		     iswhite(*tok_ptr) || *tok_ptr == ',';
		     tok_ptr--)
		    continue;
		tok_ptr[1] = '\0';
	    }

	    /*
	     * This is the soonest we have the terminal name fetched.  Set up
	     * for following warning messages.  If there's no '|', then there
	     * is no description.
	     */
	    if (after_name != 0) {
		ch = *after_name;
		*after_name = '\0';
		_nc_set_type(tok_buf);
		*after_name = (char) ch;
	    }

	    /*
	     * Compute the boundary between the aliases and the description
	     * field for syntax-checking purposes.
	     */
	    if (after_list != 0) {
		if (!silent) {
		    if (*after_list == '\0')
			_nc_warning("empty longname field");
		    else if (strchr(after_list, ' ') == 0)
			_nc_warning("older tic versions may treat the description field as an alias");
		}
	    } else {
		after_list = tok_buf + strlen(tok_buf);
		DEBUG(1, ("missing description"));
	    }

	    /*
	     * Whitespace in a name field other than the long name can confuse
	     * rdist and some termcap tools.  Slashes are a no-no.  Other
	     * special characters can be dangerous due to shell expansion.
	     */
	    for (s = tok_buf; s < after_list; ++s) {
		if (isspace(UChar(*s))) {
		    if (!silent)
			_nc_warning("whitespace in name or alias field");
		    break;
		} else if (*s == '/') {
		    if (!silent)
			_nc_warning("slashes aren't allowed in names or aliases");
		    break;
		} else if (strchr("$[]!*?", *s)) {
		    if (!silent)
			_nc_warning("dubious character `%c' in name or alias field", *s);
		    break;
		}
	    }

	    _nc_curr_token.tk_name = tok_buf;
	    type = NAMES;
	} else {
	    if (had_newline && _nc_syntax == SYN_TERMCAP) {
		_nc_warning("Missing backslash before newline");
		had_newline = FALSE;
	    }
	    while ((ch = next_char()) != EOF) {
		if (!isalnum(UChar(ch))) {
		    if (_nc_syntax == SYN_TERMINFO) {
			if (ch != '_')
			    break;
		    } else {	/* allow ';' for "k;" */
			if (ch != ';')
			    break;
		    }
		}
		if (OkToAdd()) {
		    AddCh(ch);
		} else {
		    ch = EOF;
		    break;
		}
	    }

	    *tok_ptr++ = '\0';	/* separate name/value in buffer */
	    switch (ch) {
	    case ',':
	    case ':':
		if (ch != separator)
		    _nc_err_abort("Separator inconsistent with syntax");
		_nc_curr_token.tk_name = tok_buf;
		type = BOOLEAN;
		break;
	    case '@@':
		if ((ch = next_char()) != separator && !silent)
		    _nc_warning("Missing separator after `%s', have %s",
				tok_buf, unctrl((chtype) ch));
		_nc_curr_token.tk_name = tok_buf;
		type = CANCEL;
		break;

	    case '#':
		found = 0;
		while (isalnum(ch = next_char())) {
		    numbuf[found++] = (char) ch;
		    if (found >= sizeof(numbuf) - 1)
			break;
		}
		numbuf[found] = '\0';
		number = strtol(numbuf, &numchk, 0);
		if (!silent) {
		    if (numchk == numbuf)
			_nc_warning("no value given for `%s'", tok_buf);
		    if ((*numchk != '\0') || (ch != separator))
			_nc_warning("Missing separator");
		}
		_nc_curr_token.tk_name = tok_buf;
		_nc_curr_token.tk_valnumber = number;
		type = NUMBER;
		break;

	    case '=':
		ch = _nc_trans_string(tok_ptr, tok_buf + TOK_BUF_SIZE);
		if (!silent && ch != separator)
		    _nc_warning("Missing separator");
		_nc_curr_token.tk_name = tok_buf;
		_nc_curr_token.tk_valstring = tok_ptr;
		type = STRING;
		break;

	    case EOF:
		type = EOF;
		break;
	    default:
		/* just to get rid of the compiler warning */
		type = UNDEF;
		if (!silent)
		    _nc_warning("Illegal character - '%s'", unctrl((chtype) ch));
	    }
	}			/* end else (first_column == FALSE) */
    }				/* end else (ch != EOF) */

  end_of_token:

#ifdef TRACE
    if (dot_flag == TRUE)
	DEBUG(8, ("Commented out "));

    if (_nc_tracing >= DEBUG_LEVEL(8)) {
	_tracef("parsed %d.%d to %d.%d",
		old_line, old_col,
		_nc_curr_line, _nc_curr_col);
    }
    if (_nc_tracing >= DEBUG_LEVEL(7)) {
	switch (type) {
	case BOOLEAN:
	    _tracef("Token: Boolean; name='%s'",
		    _nc_curr_token.tk_name);
	    break;

	case NUMBER:
	    _tracef("Token: Number;  name='%s', value=%d",
		    _nc_curr_token.tk_name,
		    _nc_curr_token.tk_valnumber);
	    break;

	case STRING:
	    _tracef("Token: String;  name='%s', value=%s",
		    _nc_curr_token.tk_name,
		    _nc_visbuf(_nc_curr_token.tk_valstring));
	    break;

	case CANCEL:
	    _tracef("Token: Cancel; name='%s'",
		    _nc_curr_token.tk_name);
	    break;

	case NAMES:

	    _tracef("Token: Names; value='%s'",
		    _nc_curr_token.tk_name);
	    break;

	case EOF:
	    _tracef("Token: End of file");
	    break;

	default:
	    _nc_warning("Bad token type");
	}
    }
#endif

    if (dot_flag == TRUE)	/* if commented out, use the next one */
	type = _nc_get_token(silent);

    DEBUG(3, ("token: `%s', class %d",
	      ((_nc_curr_token.tk_name != 0)
	       ? _nc_curr_token.tk_name
	       : "<null>"),
	      type));

    return (type);
}

/*
 *	char
 *	trans_string(ptr)
 *
 *	Reads characters using next_char() until encountering a separator, nl,
 *	or end-of-file.  The returned value is the character which caused
 *	reading to stop.  The following translations are done on the input:
 *
 *		^X  goes to  ctrl-X (i.e. X & 037)
 *		{\E,\n,\r,\b,\t,\f}  go to
 *			{ESCAPE,newline,carriage-return,backspace,tab,formfeed}
 *		{\^,\\}  go to  {carat,backslash}
 *		\ddd (for ddd = up to three octal digits)  goes to the character ddd
 *
 *		\e == \E
 *		\0 == \200
 *
 */

NCURSES_EXPORT(int)
_nc_trans_string(char *ptr, char *last)
{
    int count = 0;
    int number = 0;
    int i, c;
    chtype ch, last_ch = '\0';
    bool ignored = FALSE;
    bool long_warning = FALSE;

    while ((ch = c = next_char()) != (chtype) separator && c != EOF) {
	if (ptr >= (last - 1)) {
	    if (c != EOF) {
		while ((c = next_char()) != separator && c != EOF) {
		    ;
		}
		ch = c;
	    }
	    break;
	}
	if ((_nc_syntax == SYN_TERMCAP) && c == '\n')
	    break;
	if (ch == '^' && last_ch != '%') {
	    ch = c = next_char();
	    if (c == EOF)
		_nc_err_abort(MSG_NO_INPUTS);

	    if (!(is7bits(ch) && isprint(ch))) {
		_nc_warning("Illegal ^ character - '%s'", unctrl(ch));
	    }
	    if (ch == '?') {
		*(ptr++) = '\177';
		if (_nc_tracing)
		    _nc_warning("Allow ^? as synonym for \\177");
	    } else {
		if ((ch &= 037) == 0)
		    ch = 128;
		*(ptr++) = (char) (ch);
	    }
	} else if (ch == '\\') {
	    ch = c = next_char();
	    if (c == EOF)
		_nc_err_abort(MSG_NO_INPUTS);

	    if (ch >= '0' && ch <= '7') {
		number = ch - '0';
		for (i = 0; i < 2; i++) {
		    ch = c = next_char();
		    if (c == EOF)
			_nc_err_abort(MSG_NO_INPUTS);

		    if (c < '0' || c > '7') {
			if (isdigit(c)) {
			    _nc_warning("Non-octal digit `%c' in \\ sequence", c);
			    /* allow the digit; it'll do less harm */
			} else {
			    push_back((char) c);
			    break;
			}
		    }

		    number = number * 8 + c - '0';
		}

		if (number == 0)
		    number = 0200;
		*(ptr++) = (char) number;
	    } else {
		switch (c) {
		case 'E':
		case 'e':
		    *(ptr++) = '\033';
		    break;

		case 'a':
		    *(ptr++) = '\007';
		    break;

		case 'l':
		case 'n':
		    *(ptr++) = '\n';
		    break;

		case 'r':
		    *(ptr++) = '\r';
		    break;

		case 'b':
		    *(ptr++) = '\010';
		    break;

		case 's':
		    *(ptr++) = ' ';
		    break;

		case 'f':
		    *(ptr++) = '\014';
		    break;

		case 't':
		    *(ptr++) = '\t';
		    break;

		case '\\':
		    *(ptr++) = '\\';
		    break;

		case '^':
		    *(ptr++) = '^';
		    break;

		case ',':
		    *(ptr++) = ',';
		    break;

		case ':':
		    *(ptr++) = ':';
		    break;

		case '\n':
		    continue;

		default:
		    _nc_warning("Illegal character '%s' in \\ sequence",
				unctrl(ch));
		    /* FALLTHRU */
		case '|':
		    *(ptr++) = (char) ch;
		}		/* endswitch (ch) */
	    }			/* endelse (ch < '0' ||  ch > '7') */
	}
	/* end else if (ch == '\\') */
	else if (ch == '\n' && (_nc_syntax == SYN_TERMINFO)) {
	    /*
	     * Newlines embedded in a terminfo string are ignored, provided
	     * that the next line begins with whitespace.
	     */
	    ignored = TRUE;
	} else {
	    *(ptr++) = (char) ch;
	}

	if (!ignored) {
	    if (_nc_curr_col <= 1) {
		push_back((char) ch);
		ch = '\n';
		break;
	    }
	    last_ch = ch;
	    count++;
	}
	ignored = FALSE;

	if (count > MAXCAPLEN && !long_warning) {
	    _nc_warning("Very long string found.  Missing separator?");
	    long_warning = TRUE;
	}
    }				/* end while */

    *ptr = '\0';

    return (ch);
}

/*
 *	_nc_push_token()
 *
 *	Push a token of given type so that it will be reread by the next
 *	get_token() call.
 */

NCURSES_EXPORT(void)
_nc_push_token(int tokclass)
{
    /*
     * This implementation is kind of bogus, it will fail if we ever do more
     * than one pushback at a time between get_token() calls.  It relies on the
     * fact that _nc_curr_token is static storage that nothing but
     * _nc_get_token() touches.
     */
    pushtype = tokclass;
    if (pushname == 0)
	pushname = typeMalloc(char, MAX_NAME_SIZE + 1);
    _nc_get_type(pushname);

    DEBUG(3, ("pushing token: `%s', class %d",
	      ((_nc_curr_token.tk_name != 0)
	       ? _nc_curr_token.tk_name
	       : "<null>"),
	      pushtype));
}

/*
 * Panic mode error recovery - skip everything until a "ch" is found.
 */
NCURSES_EXPORT(void)
_nc_panic_mode(char ch)
{
    int c;

    for (;;) {
	c = next_char();
	if (c == ch)
	    return;
	if (c == EOF)
	    return;
    }
}

#if NO_LEAKS
NCURSES_EXPORT(void)
_nc_comp_scan_leaks(void)
{
    if (pushname != 0) {
	FreeAndNull(pushname);
    }
}
#endif
@


1.14
log
@Use strlcpy() / strlcat() throughout.
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1998,1999,2000,2001 Free Software Foundation, Inc.         *
d34 1
d56 1
a56 1
MODULE_ID("$From: comp_scan.c,v 1.54 2001/02/04 01:09:26 tom Exp $")
d90 1
d93 1
a93 1
static char pushname[MAX_NAME_SIZE + 1];
d100 188
a287 5
static int last_char(void);
static int next_char(void);
static long stream_pos(void);
static bool end_of_stream(void);
static void push_back(char c);
d290 1
a290 1
static inline int
d299 9
d345 4
a348 3
    long number;
    int type;
    int ch;
d350 2
d353 1
a353 3
    unsigned found;
    static char buffer[MAX_ENTRY_SIZE];
    char *ptr;
d355 2
d358 5
d367 1
a367 1
	_nc_set_type(pushname);
d372 2
a373 1
	pushname[0] = '\0';
d379 8
a386 1
    if (end_of_stream())
d388 1
d392 3
a394 1
    while ((ch = next_char()) == '\n' || iswhite(ch))
d396 1
d400 4
d429 1
a429 1
	if (!isalnum(ch)
d435 1
a435 1
		_nc_warning("Illegal character (expected alphanumeric or %s) - %s",
d441 9
a449 2
	ptr = buffer;
	*(ptr++) = ch;
a451 2
	    char *desc;

d457 2
d460 7
a466 3
		if (ch == EOF)
		    _nc_err_abort("premature EOF");
		else if (ch == ':' && last_char() != ',') {
d474 9
a482 4
		     * Fall-through here is not an accident.  The idea is that
		     * if we see a comma, we figure this is terminfo unless we
		     * subsequently run into a colon -- but we don't stop
		     * looking for that colon until hitting a newline.  This
a485 1
		    /* FALLTHRU */
d489 6
a494 1
		*ptr++ = ch;
d496 1
a496 1
	    ptr[0] = '\0';
d508 3
a510 1
		for (--ptr; iswhite(*ptr) || *ptr == ','; ptr--)
d512 1
a512 1
		ptr[1] = '\0';
d517 2
a518 1
	     * for following warning messages.
d520 6
a525 7
	    ptr = strchr(buffer, '|');
	    if (ptr == (char *) NULL)
		ptr = buffer + strlen(buffer);
	    ch = *ptr;
	    *ptr = '\0';
	    _nc_set_type(buffer);
	    *ptr = ch;
d531 10
a540 6
	    desc = strrchr(buffer, '|');
	    if (!silent && desc) {
		if (*desc == '\0')
		    _nc_warning("empty longname field");
		else if (strchr(desc, ' ') == (char *) NULL)
		    _nc_warning("older tic versions may treat the description field as an alias");
a541 2
	    if (!desc)
		desc = buffer + strlen(buffer);
d548 2
a549 2
	    for (ptr = buffer; ptr < desc; ptr++) {
		if (isspace(CharOf(*ptr))) {
d553 1
a553 1
		} else if (*ptr == '/') {
d557 1
a557 1
		} else if (strchr("$[]!*?", *ptr)) {
d559 1
a559 1
			_nc_warning("dubious character `%c' in name or alias field", *ptr);
d564 1
a564 3
	    ptr = buffer;

	    _nc_curr_token.tk_name = buffer;
d567 4
d572 1
a572 1
		if (!isalnum(ch)) {
d581 6
a586 1
		*(ptr++) = ch;
d589 1
a589 1
	    *ptr++ = '\0';
d595 1
a595 1
		_nc_curr_token.tk_name = buffer;
d601 2
a602 2
				buffer, unctrl((chtype) ch));
		_nc_curr_token.tk_name = buffer;
d609 1
a609 1
		    numbuf[found++] = ch;
d617 1
a617 1
			_nc_warning("no value given for `%s'", buffer);
d621 1
a621 1
		_nc_curr_token.tk_name = buffer;
d627 1
a627 1
		ch = _nc_trans_string(ptr, buffer + sizeof(buffer));
d630 2
a631 2
		_nc_curr_token.tk_name = buffer;
		_nc_curr_token.tk_valstring = ptr;
d642 1
a642 1
		    _nc_warning("Illegal character - %s", unctrl((chtype) ch));
d653 5
d702 3
a704 2
	      _nc_curr_token.tk_name != 0 ? _nc_curr_token.tk_name :
	      "<null>",
d729 1
a729 1
NCURSES_EXPORT(char)
d740 7
a746 1
	if (ptr == (last - 1))
d748 1
d754 1
a754 1
		_nc_err_abort("Premature EOF");
d757 1
a757 1
		_nc_warning("Illegal ^ character - %s", unctrl(ch));
d771 1
a771 1
		_nc_err_abort("Premature EOF");
d778 1
a778 1
			_nc_err_abort("Premature EOF");
d852 1
a852 1
		    _nc_warning("Illegal character %s in \\ sequence",
d854 2
d862 4
a865 1
	    /* newlines embedded in a terminfo string are ignored */
d872 5
d906 2
a907 2
     * fact that curr_tok is static storage that nothing but get_token()
     * touches.
d910 2
d915 4
a918 1
	      _nc_curr_token.tk_name, pushtype));
d938 1
a938 20
/*****************************************************************************
 *
 * Character-stream handling
 *
 *****************************************************************************/

#define LEXBUFSIZ	1024

static char *bufptr;		/* otherwise, the input buffer pointer */
static char *bufstart;		/* start of buffer so we can compute offsets */
static FILE *yyin;		/* scanner's input file descriptor */

/*
 *	_nc_reset_input()
 *
 *	Resets the input-reading routines.  Used on initialization,
 *	or after a seek has been done.  Exactly one argument must be
 *	non-null.
 */

d940 1
a940 1
_nc_reset_input(FILE * fp, char *buf)
d942 2
a943 22
    pushtype = NO_PUSHBACK;
    pushname[0] = '\0';
    yyin = fp;
    bufstart = bufptr = buf;
    _nc_curr_file_pos = 0L;
    if (fp != 0)
	_nc_curr_line = 0;
    _nc_curr_col = 0;
}

/*
 *	int last_char()
 *
 *	Returns the final nonblank character on the current input buffer
 */
static int
last_char(void)
{
    size_t len = strlen(bufptr);
    while (len--) {
	if (!isspace(CharOf(bufptr[len])))
	    return bufptr[len];
a944 118
    return 0;
}

/*
 *	int next_char()
 *
 *	Returns the next character in the input stream.  Comments and leading
 *	white space are stripped.
 *
 *	The global state variable 'firstcolumn' is set TRUE if the character
 *	returned is from the first column of the input line.
 *
 *	The global variable _nc_curr_line is incremented for each new line.
 *	The global variable _nc_curr_file_pos is set to the file offset of the
 *	beginning of each line.
 */

static int
next_char(void)
{
    if (!yyin) {
	/*
	 * An string with an embedded null will truncate the input.  This is
	 * intentional (we don't read binary files here).
	 */
	if (*bufptr == '\0')
	    return (EOF);
	if (*bufptr == '\n') {
	    _nc_curr_line++;
	    _nc_curr_col = 0;
	}
    } else if (!bufptr || !*bufptr) {
	/*
	 * In theory this could be recoded to do its I/O one character at a
	 * time, saving the buffer space.  In practice, this turns out to be
	 * quite hard to get completely right.  Try it and see.  If you
	 * succeed, don't forget to hack push_back() correspondingly.
	 */
	static char *result;
	static size_t allocated;
	size_t used;
	size_t len;

	do {
	    bufstart = 0;
	    used = 0;
	    do {
		if (used + (LEXBUFSIZ / 4) >= allocated) {
		    allocated += (allocated + LEXBUFSIZ);
		    result = _nc_doalloc(result, allocated);
		    if (result == 0)
			return (EOF);
		}
		if (used == 0)
		    _nc_curr_file_pos = ftell(yyin);

		if (fgets(result + used, allocated - used, yyin) != NULL) {
		    bufstart = result;
		    if (used == 0) {
			_nc_curr_line++;
			_nc_curr_col = 0;
		    }
		} else {
		    if (used != 0)
			strlcat(result, "\n", allocated);
		}
		if ((bufptr = bufstart) != 0) {
		    used = strlen(bufptr);
		    while (iswhite(*bufptr))
			bufptr++;

		    /*
		     * Treat a trailing <cr><lf> the same as a <newline> so we
		     * can read files on OS/2, etc.
		     */
		    if ((len = strlen(bufptr)) > 1) {
			if (bufptr[len - 1] == '\n'
			    && bufptr[len - 2] == '\r') {
			    len--;
			    bufptr[len - 1] = '\n';
			    bufptr[len] = '\0';
			}
		    }
		} else {
		    return (EOF);
		}
	    } while (bufptr[len - 1] != '\n');	/* complete a line */
	} while (result[0] == '#');	/* ignore comments */
    }

    first_column = (bufptr == bufstart);

    _nc_curr_col++;
    return (*bufptr++);
}

static void
push_back(char c)
/* push a character back onto the input stream */
{
    if (bufptr == bufstart)
	_nc_syserr_abort("Can't backspace off beginning of line");
    *--bufptr = c;
}

static long
stream_pos(void)
/* return our current character position in the input stream */
{
    return (yyin ? ftell(yyin) : (bufptr ? bufptr - bufstart : 0));
}

static bool
end_of_stream(void)
/* are we at end of input? */
{
    return ((yyin ? feof(yyin) : (bufptr && *bufptr == '\0'))
	    ? TRUE : FALSE);
d946 1
@


1.13
log
@Make _nc_get_token() take a "silent" argument and only warn if it
is not set.  Propagate "silent" flag in _nc_parse_entry() to _nc_get_token().
Set the silent flag when reading termcap files, including $TERMCAP.
@
text
@d769 1
a769 1
			strcat(result, "\n");
@


1.12
log
@Update to ncurses-5.2-20010210:
o remove macro callPutChar() from tty_update.c, since this is no longer
  needed (reported by Philippe Blain).
o add a null-pointer check in tic.c to handle the case when the input
  file is really empty.  Modify the next_char() function in comp_scan.c
  to allow arbitrarily long lines, and incidentally supply a newline to
  files that do not end in a newline.  These changes improve tic's
  recovery from attempts to read binary files, e.g., its output from
  the terminfo database (reported by Bernhard Rosenkraenzer).
o revert change to c++/demo.cc from 20001209, which changed definition
  of main() apparently to accommodate cygwin linker, but broke the demo
  program.
@
text
@d146 1
a146 1
_nc_get_token(void)
d214 3
a216 2
	    _nc_warning("Illegal character (expected alphanumeric or %s) - %s",
			terminfo_punct, unctrl((chtype) ch));
d290 1
a290 1
	    if (desc) {
a292 1
#ifndef __OpenBSD__
a294 1
#endif
d306 2
a307 1
		    _nc_warning("whitespace in name or alias field");
d310 2
a311 1
		    _nc_warning("slashes aren't allowed in names or aliases");
d314 2
a315 1
		    _nc_warning("dubious character `%c' in name or alias field", *ptr);
d348 1
a348 1
		if ((ch = next_char()) != separator)
d364 6
a369 4
		if (numchk == numbuf)
		    _nc_warning("no value given for `%s'", buffer);
		if ((*numchk != '\0') || (ch != separator))
		    _nc_warning("Missing separator");
d377 1
a377 1
		if (ch != separator)
d390 2
a391 1
		_nc_warning("Illegal character - %s", unctrl((chtype) ch));
d443 1
a443 1
	type = _nc_get_token();
@


1.11
log
@#ifdef out the "older tic versions may treat the description field
as an alias" warning since it hits people with $TERMCAP set when
there is no terminfo file present.  A better fix would be to make
_nc_get_token() take a quiet flag.
@
text
@d2 1
a2 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d53 1
a53 1
MODULE_ID("$From: comp_scan.c,v 1.52 2000/12/10 02:55:07 tom Exp $")
d92 2
a93 1
NCURSES_EXPORT_VAR(bool) _nc_disable_period = FALSE;	/* used by tic -a option */
d96 5
a100 5
     static int last_char(void);
     static int next_char(void);
     static long stream_pos(void);
     static bool end_of_stream(void);
     static void push_back(char c);
d103 2
a104 2
     static inline int
       eat_escaped_newline(int ch)
d242 5
a246 7
		     * Fall-through here is not an accident.
		     * The idea is that if we see a comma, we
		     * figure this is terminfo unless we
		     * subsequently run into a colon -- but
		     * we don't stop looking for that colon until
		     * hitting a newline.  This allows commas to
		     * be embedded in description fields of
d258 4
a261 5
		 * Grrr...what we ought to do here is barf,
		 * complaining that the entry is malformed.
		 * But because a couple of name fields in the
		 * 8.2 termcap file end with |\, we just have
		 * to assume it's termcap syntax.
d273 2
a274 2
	     * This is the soonest we have the terminal name
	     * fetched.  Set up for following warning messages.
d285 2
a286 2
	     * Compute the boundary between the aliases and the
	     * description field for syntax-checking purposes.
d301 3
a303 4
	     * Whitespace in a name field other than the long name
	     * can confuse rdist and some termcap tools.  Slashes
	     * are a no-no.  Other special characters can be
	     * dangerous due to shell expansion.
d440 4
a443 1
    DEBUG(3, ("token: `%s', class %d", _nc_curr_token.tk_name, type));
d625 4
a628 4
     * This implementation is kind of bogus, it will fail if we ever do
     * more than one pushback at a time between get_token() calls.  It
     * relies on the fact that curr_tok is static storage that nothing
     * but get_token() touches.
d721 4
d733 4
a736 5
	 * In theory this could be recoded to do its I/O one
	 * character at a time, saving the buffer space.  In
	 * practice, this turns out to be quite hard to get
	 * completely right.  Try it and see.  If you succeed,
	 * don't forget to hack push_back() correspondingly.
d738 3
a740 1
	static char line[LEXBUFSIZ];
d744 11
a754 1
	    _nc_curr_file_pos = ftell(yyin);
d756 14
a769 7
	    if ((bufstart = fgets(line, LEXBUFSIZ, yyin)) != NULL) {
		_nc_curr_line++;
		_nc_curr_col = 0;
	    }
	    bufptr = bufstart;
	} while
	    (bufstart != NULL && line[0] == '#');
d771 17
a787 26
	if (bufstart == NULL || *bufstart == 0)
	    return (EOF);

	while (iswhite(*bufptr))
	    bufptr++;

	/*
	 * Treat a trailing <cr><lf> the same as a <newline> so we can read
	 * files on OS/2, etc.
	 */
	if ((len = strlen(bufptr)) > 1) {
	    if (bufptr[len - 1] == '\n'
		&& bufptr[len - 2] == '\r') {
		len--;
		bufptr[len - 1] = '\n';
		bufptr[len] = '\0';
	    }
	}

	/*
	 * If we don't have a trailing newline, it's because the line is simply
	 * too long.  Give up.  (FIXME:  We could instead reallocate the line
	 * buffer and allow arbitrary-length lines).
	 */
	if (len == 0 || (bufptr[len - 1] != '\n'))
	    return (EOF);
a818 2

/* comp_scan.c ends here */
@


1.10
log
@Update to ncurses-5.2-20010114
@
text
@d294 1
d297 1
@


1.9
log
@update to ncurses-5.1-20001007
@
text
@d53 1
a53 1
MODULE_ID("$From: comp_scan.c,v 1.47 2000/09/24 01:15:17 tom Exp $")
d63 10
a72 5
int _nc_syntax = 0;		/* termcap or terminfo? */
long _nc_curr_file_pos = 0;	/* file offset of current line */
long _nc_comment_start = 0;	/* start of comment range before name */
long _nc_comment_end = 0;	/* end of comment range before name */
long _nc_start_line = 0;	/* start line of current entry */
d74 5
a78 2
struct token _nc_curr_token =
{0, 0, 0};
d92 1
a92 1
bool _nc_disable_period = FALSE;	/* used by tic -a option */
d95 5
a99 5
static int last_char(void);
static int next_char(void);
static long stream_pos(void);
static bool end_of_stream(void);
static void push_back(char c);
d102 2
a103 2
static inline int
eat_escaped_newline(int ch)
d144 1
a144 1
int
d214 1
a214 1
			terminfo_punct, unctrl(ch));
d307 1
a307 1
		if (isspace(*ptr)) {
d349 1
a349 1
				buffer, unctrl(ch));
d387 1
a387 1
		_nc_warning("Illegal character - %s", unctrl(ch));
d465 1
a465 1
char
d469 1
a469 1
    int number;
d619 1
a619 1
void
d638 1
a638 1
void
d672 1
a672 1
void
d695 1
a695 1
	if (!isspace(bufptr[len]))
@


1.8
log
@ncurses 5.1
@
text
@d53 1
a53 1
MODULE_ID("$From: comp_scan.c,v 1.45 2000/07/08 00:43:55 tom Exp $")
d83 2
a84 2
#ifdef NCURSES_EXT_FUNCS
bool _nc_disable_period = FALSE; /* used by tic -a option */
d156 1
a156 1
		_nc_curr_token.tk_name, pushtype));
d183 2
a184 2
#ifdef NCURSES_EXT_FUNCS
	 && !_nc_disable_period
d186 1
a186 1
	) {
d201 2
a202 2
#ifdef NCURSES_EXT_FUNCS
	 && !(ch == '.' && _nc_disable_period)
d204 1
a204 1
	 && !strchr(terminfo_punct, (char) ch)) {
d206 1
a206 1
		terminfo_punct, unctrl(ch));
d341 1
a341 1
			buffer, unctrl(ch));
d394 1
a394 1
		_nc_curr_token.tk_name);
d399 2
a400 2
		_nc_curr_token.tk_name,
		_nc_curr_token.tk_valnumber);
d405 2
a406 2
		_nc_curr_token.tk_name,
		_nc_visbuf(_nc_curr_token.tk_valstring));
d411 1
a411 1
		_nc_curr_token.tk_name);
d417 1
a417 1
		_nc_curr_token.tk_name);
d574 1
a574 1
			unctrl(ch));
d624 1
a624 1
	    _nc_curr_token.tk_name, pushtype));
d739 1
a739 1
	if (bufstart == NULL)
d752 3
a754 2
		bufptr[len - 2] = '\n';
		bufptr[len - 1] = '\0';
d757 8
d794 1
a794 1
	? TRUE : FALSE);
@


1.7
log
@ncurses-5.0-20000617
@
text
@d53 1
a53 1
MODULE_ID("$From: comp_scan.c,v 1.44 2000/06/10 21:59:21 tom Exp $")
d82 4
@


1.6
log
@Update to ncurses-5.0-20000401:
 o change unctrl() to render C1 characters (128-159) as ~@@, ~A, etc.
 o trace() function is provided only if TRACE is defined, e.g., in the debug
   library.  Modify related calls to _tracechar() to use unctrl() instead.
@
text
@d53 1
a53 1
MODULE_ID("$From: comp_scan.c,v 1.42 2000/04/01 19:08:36 tom Exp $")
d69 3
d478 2
@


1.5
log
@Update to ncurses-5.0-20000325
@
text
@d53 1
a53 1
MODULE_ID("$From: comp_scan.c,v 1.41 2000/03/25 17:25:33 tom Exp $")
d199 1
a199 1
		terminfo_punct, _tracechar((chtype) ch));
d334 1
a334 1
			buffer, _tracechar((chtype) ch));
d372 1
a372 2
		_nc_warning("Illegal character - %s",
		    _tracechar((chtype) ch));
d471 1
a471 2
		_nc_warning("Illegal ^ character - %s",
		    _tracechar((unsigned char) ch));
d565 1
a565 1
			_tracechar((unsigned char) ch));
@


1.4
log
@Update to ncurses-5.0-20000304
@
text
@d50 1
d53 1
a53 1
MODULE_ID("$From: comp_scan.c,v 1.38 2000/02/13 01:01:26 tom Exp $")
d175 5
a179 1
	if (ch == '.') {
d193 5
a197 1
	if (!isalnum(ch) && !strchr(terminfo_punct, (char) ch)) {
d358 1
a358 1
		ch = _nc_trans_string(ptr);
d452 1
a452 1
_nc_trans_string(char *ptr)
d459 1
d462 2
d586 1
a586 1
	if (count > MAXCAPLEN)
d588 2
@


1.3
log
@Update to ncurses-5.0-20000115:
+ additional fixes for non-bce terminals (handling of delete_character)
to work when assume_default_colors() is not specified.
+ modify warning message from _nc_parse_entry() regarding extended
capability names to print only if tic/infocmp/toe have the -v flag
set, and not at all in ordinary user applications.  Otherwise, this
warning would be shown for screen's extended capabilities in programs
that use the termcap interface.
+ modify use of _nc_tracing from programs such as tic so their debug
level is not in the same range as values set by trace() function.
+ small panel header cleanup (patch by Juergen Pfeifer).
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d52 1
a52 1
MODULE_ID("$From: comp_scan.c,v 1.37 2000/01/15 21:52:23 tom Exp $")
@


1.2
log
@update to ncurses-5.0-19991127
@
text
@d2 1
a2 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
d52 1
a52 1
MODULE_ID("$From: comp_scan.c,v 1.35 1999/10/30 23:00:16 tom Exp $")
d62 5
a66 5
int	_nc_syntax = 0;		/* termcap or terminfo? */
long	_nc_curr_file_pos = 0;	/* file offset of current line */
long	_nc_comment_start = 0;	/* start of comment range before name */
long	_nc_comment_end = 0;	/* end of comment range before name */
long	_nc_start_line = 0;	/* start line of current entry */
d77 1
a77 1
static char pushname[MAX_NAME_SIZE+1];
d79 2
a80 2
static int  last_char(void);
static int  next_char(void);
d86 2
a87 1
static inline int eat_escaped_newline(int ch)
d89 4
a92 4
	if (ch == '\\')
		while ((ch = next_char()) == '\n'  ||  iswhite(ch))
			continue;
	return ch;
d128 2
a129 1
int _nc_get_token(void)
d131 25
a155 19
static const char terminfo_punct[] = "@@%&*!#";
long		number;
int		type;
int		ch;
char *		numchk;
char		numbuf[80];
unsigned	found;
static char	buffer[MAX_ENTRY_SIZE];
char		*ptr;
int		dot_flag = FALSE;
long		token_start;

	if (pushtype != NO_PUSHBACK)
	{
	    int retval = pushtype;

	    _nc_set_type(pushname);
	    DEBUG(3, ("pushed-back token: `%s', class %d",
		      _nc_curr_token.tk_name, pushtype));
d157 2
a158 2
	    pushtype = NO_PUSHBACK;
	    pushname[0] = '\0';
d160 25
a184 2
	    /* currtok wasn't altered by _nc_push_token() */
	    return(retval);
d187 7
a193 2
	if (end_of_stream())
	    return(EOF);
d195 2
a196 4
start_token:
	token_start = stream_pos();
	while ((ch = next_char()) == '\n'  ||  iswhite(ch))
	    continue;
d198 2
a199 1
	ch = eat_escaped_newline(ch);
d201 28
a228 10
	if (ch == EOF)
	    type = EOF;
	else {
	    /* if this is a termcap entry, skip a leading separator */
	    if (separator == ':' && ch == ':')
		ch = next_char();

	    if (ch == '.') {
			dot_flag = TRUE;
			DEBUG(8, ("dot-flag set"));
d230 18
a247 2
			while ((ch = next_char())=='.' || iswhite(ch))
			    continue;
d250 22
a271 3
	    if (ch == EOF) {
		type = EOF;
		goto end_of_token;
d273 2
d276 17
a292 6
	    /* have to make some punctuation chars legal for terminfo */
	    if (!isalnum(ch) && !strchr(terminfo_punct, (char)ch)) {
		 _nc_warning("Illegal character (expected alphanumeric or %s) - %s",
			terminfo_punct, _tracechar((chtype)ch));
		 _nc_panic_mode(separator);
		 goto start_token;
a295 1
	    *(ptr++) = ch;
d297 15
a311 2
	    if (first_column) {
			char	*desc;
d313 16
a328 33
			_nc_comment_start = token_start;
			_nc_comment_end = _nc_curr_file_pos;
			_nc_start_line = _nc_curr_line;

			_nc_syntax = ERR;
			while ((ch = next_char()) != '\n')
			{
			    if (ch == EOF)
				_nc_err_abort("premature EOF");
			    else if (ch == ':' && last_char() != ',')
			    {
				_nc_syntax = SYN_TERMCAP;
				separator = ':';
				break;
			    }
			    else if (ch == ',')
			    {
				_nc_syntax = SYN_TERMINFO;
				separator = ',';
				/*
				 * Fall-through here is not an accident.
				 * The idea is that if we see a comma, we
				 * figure this is terminfo unless we
				 * subsequently run into a colon -- but
				 * we don't stop looking for that colon until
				 * hitting a newline.  This allows commas to
				 * be embedded in description fields of
				 * either syntax.
				 */
				/* FALLTHRU */
			    }
			    else
				ch = eat_escaped_newline(ch);
d330 17
a346 22
			    *ptr++ = ch;
			}
			ptr[0] = '\0';
			if (_nc_syntax == ERR)
			{
			    /*
			     * Grrr...what we ought to do here is barf,
			     * complaining that the entry is malformed.
			     * But because a couple of name fields in the
			     * 8.2 termcap file end with |\, we just have
			     * to assume it's termcap syntax.
			     */
			    _nc_syntax = SYN_TERMCAP;
			    separator = ':';
			}
			else if (_nc_syntax == SYN_TERMINFO)
			{
			    /* throw away trailing /, *$/ */
			    for (--ptr; iswhite(*ptr) || *ptr == ','; ptr--)
				continue;
			    ptr[1] = '\0';
			}
d348 8
a355 25
			/*
			 * This is the soonest we have the terminal name
			 * fetched.  Set up for following warning messages.
			 */
			ptr = strchr(buffer, '|');
			if (ptr == (char *)NULL)
			    ptr = buffer + strlen(buffer);
			ch = *ptr;
			*ptr = '\0';
			_nc_set_type(buffer);
			*ptr = ch;

			/*
			 * Compute the boundary between the aliases and the
			 * description field for syntax-checking purposes.
			 */
			desc = strrchr(buffer, '|');
			if (desc) {
			    if (*desc == '\0')
				_nc_warning("empty longname field");
			    else if (strchr(desc, ' ') == (char *)NULL)
				_nc_warning("older tic versions may treat the description field as an alias");
			}
			if (!desc)
			    desc = buffer + strlen(buffer);
d357 11
a367 24
			/*
			 * Whitespace in a name field other than the long name
			 * can confuse rdist and some termcap tools.  Slashes
			 * are a no-no.  Other special characters can be
			 * dangerous due to shell expansion.
			 */
			for (ptr = buffer; ptr < desc; ptr++)
			{
			    if (isspace(*ptr))
			    {
				_nc_warning("whitespace in name or alias field");
				break;
			    }
			    else if (*ptr == '/')
			    {
				_nc_warning("slashes aren't allowed in names or aliases");
				break;
			    }
			    else if (strchr("$[]!*?", *ptr))
			    {
				_nc_warning("dubious character `%c' in name or alias field", *ptr);
				break;
			    }
			}
d369 1
a369 75
			ptr = buffer;

			_nc_curr_token.tk_name = buffer;
			type = NAMES;
	    } else {
			while ((ch = next_char()) != EOF) {
				if (!isalnum(ch)) {
					if (_nc_syntax == SYN_TERMINFO) {
						if (ch != '_')
							break;
					} else { /* allow ';' for "k;" */
						if (ch != ';')
							break;
					}
				}
				*(ptr++) = ch;
			}

			*ptr++ = '\0';
			switch (ch) {
			case ',':
			case ':':
				if (ch != separator)
					_nc_err_abort("Separator inconsistent with syntax");
				_nc_curr_token.tk_name = buffer;
				type = BOOLEAN;
				break;
			case '@@':
				if ((ch = next_char()) != separator)
					_nc_warning("Missing separator after `%s', have %s",
						buffer, _tracechar((chtype)ch));
				_nc_curr_token.tk_name = buffer;
				type = CANCEL;
				break;

			case '#':
				found  = 0;
				while (isalnum(ch = next_char())) {
					numbuf[found++] = ch;
					if (found >= sizeof(numbuf)-1)
						break;
				}
				numbuf[found] = '\0';
				number = strtol(numbuf, &numchk, 0);
				if (numchk == numbuf)
					_nc_warning("no value given for `%s'", buffer);
				if ((*numchk != '\0') || (ch != separator))
					_nc_warning("Missing separator");
				_nc_curr_token.tk_name = buffer;
				_nc_curr_token.tk_valnumber = number;
				type = NUMBER;
				break;

			case '=':
				ch = _nc_trans_string(ptr);
				if (ch != separator)
					_nc_warning("Missing separator");
				_nc_curr_token.tk_name = buffer;
				_nc_curr_token.tk_valstring = ptr;
				type = STRING;
				break;

			case EOF:
				type = EOF;
				break;
			default:
				/* just to get rid of the compiler warning */
				type = UNDEF;
				_nc_warning("Illegal character - %s",
					_tracechar((chtype)ch));
			}
		} /* end else (first_column == FALSE) */
	} /* end else (ch != EOF) */

end_of_token:
d372 2
a373 2
	if (dot_flag == TRUE)
	    DEBUG(8, ("Commented out "));
d375 33
a407 15
	if (_nc_tracing & TRACE_IEVENT)
	{
	    fprintf(stderr, "Token: ");
	    switch (type)
	    {
		case BOOLEAN:
		    fprintf(stderr, "Boolean; name='%s'\n",
			    _nc_curr_token.tk_name);
		    break;

		case NUMBER:
		    fprintf(stderr, "Number;  name='%s', value=%d\n",
			    _nc_curr_token.tk_name,
			    _nc_curr_token.tk_valnumber);
		    break;
d409 2
a410 24
		case STRING:
		    fprintf(stderr, "String;  name='%s', value=%s\n",
			    _nc_curr_token.tk_name,
			    _nc_visbuf(_nc_curr_token.tk_valstring));
		    break;

		case CANCEL:
		    fprintf(stderr, "Cancel; name='%s'\n",
			    _nc_curr_token.tk_name);
		    break;

		case NAMES:

		    fprintf(stderr, "Names; value='%s'\n",
			    _nc_curr_token.tk_name);
		    break;

		case EOF:
		    fprintf(stderr, "End of file\n");
		    break;

		default:
		    _nc_warning("Bad token type");
	    }
d412 1
d415 2
a416 2
	if (dot_flag == TRUE)		/* if commented out, use the next one */
	    type = _nc_get_token();
d418 1
a418 1
	DEBUG(3, ("token: `%s', class %d", _nc_curr_token.tk_name, type));
d420 1
a420 1
	return(type);
d445 24
a468 25
int	count = 0;
int	number;
int	i, c;
chtype	ch, last_ch = '\0';
bool	ignored = FALSE;

	while ((ch = c = next_char()) != (chtype)separator && c != EOF) {
	    if ((_nc_syntax == SYN_TERMCAP) && c == '\n')
		break;
	    if (ch == '^' && last_ch != '%') {
		ch = c = next_char();
		if (c == EOF)
		    _nc_err_abort("Premature EOF");

		if (! (is7bits(ch) && isprint(ch))) {
		    _nc_warning("Illegal ^ character - %s",
			_tracechar((unsigned char)ch));
		}
		if (ch == '?') {
		    *(ptr++) = '\177';
		} else {
		    if ((ch &= 037) == 0)
		        ch = 128;
		    *(ptr++) = (char)(ch);
		}
d470 19
a488 20
	    else if (ch == '\\') {
		ch = c = next_char();
		if (c == EOF)
		    _nc_err_abort("Premature EOF");

		if (ch >= '0'  &&  ch <= '7') {
		    number = ch - '0';
		    for (i=0; i < 2; i++) {
			ch = c = next_char();
			if (c == EOF)
			    _nc_err_abort("Premature EOF");

			if (c < '0'  ||  c > '7') {
			    if (isdigit(c)) {
				_nc_warning("Non-octal digit `%c' in \\ sequence", c);
				/* allow the digit; it'll do less harm */
			    } else {
				push_back((char)c);
				break;
			    }
a489 2

			number = number * 8 + c - '0';
d492 2
a493 7
		    if (number == 0)
			number = 0200;
		    *(ptr++) = (char) number;
		} else {
		    switch (c) {
			case 'E':
			case 'e':	*(ptr++) = '\033';	break;
d495 9
a503 1
			case 'a':	*(ptr++) = '\007';	break;
d505 3
a507 2
			case 'l':
			case 'n':	*(ptr++) = '\n';	break;
d509 4
a512 1
			case 'r':	*(ptr++) = '\r';	break;
d514 3
a516 1
			case 'b':	*(ptr++) = '\010';	break;
d518 3
a520 1
			case 's':	*(ptr++) = ' ';		break;
d522 3
a524 1
			case 'f':	*(ptr++) = '\014';	break;
d526 7
a532 1
			case 't':	*(ptr++) = '\t';	break;
d534 3
a536 1
			case '\\':	*(ptr++) = '\\';	break;
d538 3
a540 1
			case '^':	*(ptr++) = '^';		break;
d542 3
a544 1
			case ',':	*(ptr++) = ',';		break;
d546 3
a548 1
			case ':':	*(ptr++) = ':';		break;
d550 2
a551 2
			case '\n':
			    continue;
d553 14
a566 13
			default:
			    _nc_warning("Illegal character %s in \\ sequence",
				    _tracechar((unsigned char)ch));
			    *(ptr++) = (char)ch;
		    } /* endswitch (ch) */
		} /* endelse (ch < '0' ||  ch > '7') */
	    } /* end else if (ch == '\\') */
	    else if (ch == '\n' && (_nc_syntax == SYN_TERMINFO)) {
		/* newlines embedded in a terminfo string are ignored */
		ignored = TRUE;
	    } else {
		*(ptr++) = (char)ch;
	    }
d568 5
a572 5
	    if (!ignored) {
		last_ch = ch;
		count ++;
	    }
	    ignored = FALSE;
d574 3
a576 3
	    if (count > MAXCAPLEN)
		_nc_warning("Very long string found.  Missing separator?");
	} /* end while */
d578 1
a578 1
	*ptr = '\0';
d580 1
a580 1
	return(ch);
d590 2
a591 1
void _nc_push_token(int tokclass)
d603 1
a603 1
	      _nc_curr_token.tk_name, pushtype));
d609 2
a610 1
void _nc_panic_mode(char ch)
d612 1
a612 1
	int c;
d614 7
a620 7
	for (;;) {
		c = next_char();
		if (c == ch)
			return;
		if (c == EOF)
			return;
	}
d643 2
a644 1
void _nc_reset_input(FILE *fp, char *buf)
d646 8
a653 8
	pushtype = NO_PUSHBACK;
	pushname[0] = '\0';
	yyin = fp;
	bufstart = bufptr = buf;
	_nc_curr_file_pos = 0L;
	if (fp != 0)
		_nc_curr_line = 0;
	_nc_curr_col = 0;
d664 6
a669 6
	size_t len = strlen(bufptr);
	while (len--) {
		if (!isspace(bufptr[len]))
			return bufptr[len];
	}
	return 0;
d689 1
a689 2
    if (!yyin)
    {
d691 1
a691 1
	    return(EOF);
d696 1
a696 3
    }
    else if (!bufptr || !*bufptr)
    {
d708 1
a708 1
	       _nc_curr_file_pos = ftell(yyin);
d710 7
a716 7
	       if ((bufstart = fgets(line, LEXBUFSIZ, yyin)) != NULL) {
		   _nc_curr_line++;
		   _nc_curr_col = 0;
	       }
	       bufptr = bufstart;
	   } while
	       (bufstart != NULL && line[0] == '#');
d729 4
a732 4
	    if (bufptr[len-1] == '\n'
	     && bufptr[len-2] == '\r') {
		bufptr[len-2] = '\n';
		bufptr[len-1] = '\0';
d740 1
a740 1
    return(*bufptr++);
d743 2
a744 1
static void push_back(char c)
d748 1
a748 1
	    _nc_syserr_abort("Can't backspace off beginning of line");
d752 2
a753 1
static long stream_pos(void)
d759 2
a760 1
static bool end_of_stream(void)
d764 1
a764 1
	    ? TRUE : FALSE);
@


1.1
log
@ncurses-4.2-990116
@
text
@d2 1
a2 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d52 1
a52 1
MODULE_ID("$From: comp_scan.c,v 1.34 1998/11/01 00:56:39 tom Exp $")
d62 5
a66 5
int	_nc_syntax;		/* termcap or terminfo? */
long	_nc_curr_file_pos;	/* file offset of current line */
long	_nc_comment_start;	/* start of comment range before name */
long	_nc_comment_end;	/* end of comment range before name */
long	_nc_start_line;		/* start line of current entry */
@

