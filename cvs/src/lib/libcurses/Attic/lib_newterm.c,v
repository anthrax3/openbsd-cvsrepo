head	1.7;
access;
symbols
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	99.01.18.19.08.11;	author millert;	state dead;
branches;
next	1.6;

1.6
date	98.10.31.06.30.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.07.23.21.19.06;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.01.17.16.27.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.21.25;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.44;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.06.05.29;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.7
log
@ncurses-4.2-990116
@
text
@/*	$OpenBSD: lib_newterm.c,v 1.6 1998/10/31 06:30:30 millert Exp $	*/

/****************************************************************************
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/



/*
**	lib_newterm.c
**
**	The newterm() function.
**
*/

#include <curses.priv.h>

#if defined(SVR4_TERMIO) && !defined(_POSIX_SOURCE)
#define _POSIX_SOURCE
#endif

#include <term.h>	/* clear_screen, cup & friends, cur_term */

MODULE_ID("$From: lib_newterm.c,v 1.35 1998/09/19 21:43:22 tom Exp $")

#ifndef ONLCR		/* Allows compilation under the QNX 4.2 OS */
#define ONLCR 0
#endif

/*
 * SVr4/XSI Curses specify that hardware echo is turned off in initscr, and not
 * restored during the curses session.  The library simulates echo in software.
 * (The behavior is unspecified if the application enables hardware echo).
 *
 * The newterm function also initializes terminal settings, and since initscr
 * is supposed to behave as if it calls newterm, we do it here.
 */
static inline int _nc_initscr(void)
{
	/* for extended XPG4 conformance requires cbreak() at this point */
	/* (SVr4 curses does this anyway) */
	cbreak();

#ifdef TERMIOS
	cur_term->Nttyb.c_lflag &= ~(ECHO|ECHONL);
	cur_term->Nttyb.c_iflag &= ~(ICRNL|INLCR|IGNCR);
	cur_term->Nttyb.c_oflag &= ~(ONLCR);
#else
	cur_term->Nttyb.sg_flags &= ~(ECHO|CRMOD);
#endif
	return _nc_set_curterm(&cur_term->Nttyb);
}

/*
 * filter() has to be called before either initscr() or newterm(), so there is
 * apparently no way to make this flag apply to some terminals and not others,
 * aside from possibly delaying a filter() call until some terminals have been
 * initialized.
 */
static int filter_mode = FALSE;

void filter(void)
{
    filter_mode = TRUE;
}

SCREEN * newterm(NCURSES_CONST char *term, FILE *ofp, FILE *ifp)
{
int	errret;
SCREEN* current;
#ifdef TRACE
int t = _nc_getenv_num("NCURSES_TRACE");

	if (t >= 0)
               trace(t);
#endif

	T((T_CALLED("newterm(\"%s\",%p,%p)"), term, ofp, ifp));

	/* this loads the capability entry, then sets LINES and COLS */
	if (setupterm(term, fileno(ofp), &errret) == ERR)
		return 0;

	/*
	 * Check for mismatched graphic-rendition capabilities.  Most SVr4
	 * terminfo trees contain entries that have rmul or rmso equated to
	 * sgr0 (Solaris curses copes with those entries).  We do this only for
	 * curses, since many termcap applications assume that smso/rmso and
	 * smul/rmul are paired, and will not function properly if we remove
	 * rmso or rmul.  Curses applications shouldn't be looking at this
	 * detail.
	 */
	if (exit_attribute_mode) {
#define SGR0_FIX(mode) if (mode != 0 && !strcmp(mode, exit_attribute_mode)) \
			mode = 0
		SGR0_FIX(exit_underline_mode);
		SGR0_FIX(exit_standout_mode);
	}

	/* implement filter mode */
	if (filter_mode) {
		LINES = 1;

#ifdef init_tabs
		if (init_tabs != -1)
			TABSIZE = init_tabs;
		else
#endif /* init_tabs */
			TABSIZE = 8;

		T(("TABSIZE = %d", TABSIZE));

#ifdef clear_screen
		clear_screen = 0;
		cursor_down = parm_down_cursor = 0;
		cursor_address = 0;
		cursor_up = parm_up_cursor = 0;
		row_address = 0;

		cursor_home = carriage_return;
#endif /* clear_screen */
	}

	/* If we must simulate soft labels, grab off the line to be used.
	   We assume that we must simulate, if it is none of the standard
	   formats (4-4  or 3-2-3) for which there may be some hardware
	   support. */
#ifdef num_labels
	if (num_labels <= 0 || !SLK_STDFMT)
#endif /* num_labels */
	    if (_nc_slk_format)
	      {
		if (ERR==_nc_ripoffline(-SLK_LINES, _nc_slk_initialize))
		  return 0;
	      }
	/* this actually allocates the screen structure, and saves the
	 * original terminal settings.
	 */
	current = SP;
	_nc_set_screen(0);
	if (_nc_setupscreen(LINES, COLS, ofp) == ERR) {
	        _nc_set_screen(current);
		return 0;
	}

#ifdef num_labels
	/* if the terminal type has real soft labels, set those up */
	if (_nc_slk_format && num_labels > 0 && SLK_STDFMT)
	    _nc_slk_initialize(stdscr, COLS);
#endif /* num_labels */

	SP->_ifd        = fileno(ifp);
	SP->_checkfd	= fileno(ifp);
	typeahead(fileno(ifp));
#ifdef TERMIOS
	SP->_use_meta   = ((cur_term->Ottyb.c_cflag & CSIZE) == CS8 &&
			    !(cur_term->Ottyb.c_iflag & ISTRIP));
#else
	SP->_use_meta   = FALSE;
#endif
	SP->_endwin	= FALSE;

	/* Check whether we can optimize scrolling under dumb terminals in case
	 * we do not have any of these capabilities, scrolling optimization
	 * will be useless.
	 */
	SP->_scrolling = ((scroll_forward && scroll_reverse) ||
			  ((parm_rindex || parm_insert_line || insert_line) &&
			   (parm_index  || parm_delete_line || delete_line)));

	baudrate();	/* sets a field in the SP structure */

	SP->_keytry = 0;

	/* compute movement costs so we can do better move optimization */
	_nc_mvcur_init();

	_nc_signal_handler(TRUE);

	/* initialize terminal to a sane state */
	_nc_screen_init();

	/* Initialize the terminal line settings. */
	_nc_initscr();

	T((T_RETURN("%p"), SP));
	return(SP);
}
@


1.6
log
@update to ncurses 4.2-981017
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_newterm.c,v 1.5 1998/07/23 21:19:06 millert Exp $	*/
@


1.5
log
@ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
a53 1
MODULE_ID("$From: lib_newterm.c,v 1.34 1998/04/11 22:53:05 tom Exp $")
d101 1
a101 1
char *t = getenv("NCURSES_TRACE");
d103 2
a104 2
	if (t)
               trace((unsigned) strtol(t, 0, 0));
@


1.4
log
@Use _ti_get_screensize() from libtermlib to update screen size if changed
    after a program is suspended.
Define EXTERN_TERMINFO in curses.h.
Update to ncurses-4.1-980103 and crank minor.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_newterm.c,v 1.3 1997/12/03 05:21:25 millert Exp $	*/
d3 32
a34 20

/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d53 1
a53 1
MODULE_ID("Id: lib_newterm.c,v 1.31 1997/12/28 00:36:51 tom Exp $")
d96 1
a96 1
SCREEN * newterm(const char *term, FILE *ofp, FILE *ifp)
d201 2
@


1.3
log
@Merge of ncurses-4.1-971129
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
MODULE_ID("Id: lib_newterm.c,v 1.30 1997/11/08 17:32:31 tom Exp $")
d179 8
@


1.2
log
@ncurses 4.1 + changes to work with our terminfo libs (instead of
the ncurses ones).  Changes are #ifdef EXTERN_TERMINFO.
Post 4.1 patches will be applied in a separate commit.
@
text
@d1 2
d35 1
a35 1
#ifdef SVR4_TERMIO
d41 29
a69 1
MODULE_ID("Id: lib_newterm.c,v 1.23 1997/03/30 01:42:01 tom Exp $")
d71 6
a76 1
/* This should be moved to TERMINAL */
d87 1
d99 1
a99 1
		return NULL;
d103 2
a104 2
	 * terminfo tree contain entries that have rmul or rmso equated to sgr0
	 * (Solaris curses copes with those entries).  We do this only for
d131 6
a136 6
		clear_screen = (char *)NULL;
		cursor_down = parm_down_cursor = (char *)NULL;
		cursor_address = (char *)NULL;
		cursor_up = parm_up_cursor = (char *)NULL;
		row_address = (char *)NULL;
		
d151 1
a151 1
		  return NULL;
d156 6
a161 2
	if (_nc_setupscreen(LINES, COLS, ofp) == ERR)
		return NULL;
d187 2
a188 2
	/* open a connection to the screen's associated mouse, if any */
	_nc_mouse_init(SP);
@


1.1
log
@Install ncurses as -lcurses and <curses.h>
Install BSD curses library as -locurses and <ocurses.h>
@
text
@d27 1
a27 1
** 	The newterm() function.
d31 1
a31 3
#include "curses.priv.h"
#include <stdlib.h>
#include "term.h"	/* clear_screen, cup & friends, cur_term */
d33 10
a42 2
/* This should moved to TERMINAL */
static filter_mode = FALSE;
d56 1
a56 1
               trace(strtol(t, 0, 0));
d59 1
a59 1
	T(("newterm(\"%s\",%p,%p) called", term, ofp, ifp));
d62 2
a63 2
	if (setupterm(term, fileno(ofp), &errret) != 1)
	    	return NULL;
d65 14
a78 52
	/* optional optimization hack -- do before any output to ofp */
#if HAVE_SETVBUF || HAVE_SETBUFFER
	{
	  /* 
	   * If the output file descriptor is connected to a tty
	   * (the typical case) it will probably be line-buffered.
	   * Keith Bostic pointed out that we don't want this; it
	   * hoses people running over networks by forcing out a
	   * bunch of small packets instead of one big one, so
	   * screen updates on ptys look jerky.  Restore block
	   * buffering to prevent this minor lossage.
	   *
	   * The buffer size is a compromise.  Ideally we'd like a
	   * buffer that can hold the maximum possible update size
	   * (the whole screen plus cup commands to change lines as
	   * it's painted).  On a modern 66-line xterm this can
	   * become excessive.  So we min it with the amount of data
	   * we think we can get through two Ethernet packets
	   * (maximum packet size - 100 for TCP/IP overhead).
	   *
	   * Why two ethernet packets?  It used to be one, on the theory
	   * that said packets define the maximum size of atomic update.
	   * But that's less than the 2000 chars on a 25 x 80 screen, and
	   * we don't want local updates to flicker either.  Two packet
	   * lengths will handle up to a 35 x 80 screen.
	   *
	   * The magic '6' is the estimated length of the end-of-line
	   * cup sequence to go to the next line.  It's generous.  We
	   * used to mess with the buffering in init_mvcur() after cost
	   * computation, but that lost the sequences emitted by init_acs()
	   * in setupscreen().
	   *
	   * "The setvbuf function may be used only after the stream pointed
	   * to by stream as been associated with an open file and before any
	   * other operation is performed on the stream." (ISO 7.9.5.6.)
	   *
	   * Grrrr...
	   */
	  unsigned int bufsiz = min(LINES * (COLS + 6), 2800);

#if HAVE_SETVBUF
	  /*
	   * If your code core-dumps here, you are probably running
	   * some bastard offspring of an SVR3 on which the setvbuffer(3)
	   * arguments are reversed.  Autoconf has a test macro for this
	   * but I have too much else to do to figure out how it works.
	   * Send us a patch if you care.
	   */
	  (void) setvbuf(ofp, malloc(bufsiz), _IOFBF, bufsiz);
#elif HAVE_SETBUFFER
	  (void) setbuffer(ofp, malloc(bufsiz), (int)bufsiz);
#endif
a79 1
#endif /* HAVE_SETVBUF || HAVE_SETBUFFER */
d83 1
a83 1
	    LINES = 1;
d86 3
a88 3
	if (init_tabs != -1)
		TABSIZE = init_tabs;
	else
d90 1
a90 1
		TABSIZE = 8;
d92 1
a92 1
	T(("TABSIZE = %d", TABSIZE));
d95 7
a101 7
	    clear_screen = (char *)NULL;
	    cursor_down = parm_down_cursor = (char *)NULL;
	    cursor_address = (char *)NULL;
	    cursor_up = parm_up_cursor = (char *)NULL;
	    row_address = (char *)NULL;

	    cursor_home = carriage_return;
d105 4
a108 1
	/* if we must simulate soft labels, grab off the line to be used */
d110 1
a110 1
	if (num_labels <= 0)
d112 10
a121 6
	    if (_slk_init)
		ripoffline(-1, slk_initialize);

	/* this actually allocates the screen structure */
	if (_nc_setupscreen(LINES, COLS) == ERR)
	    	return NULL;
d125 2
a126 2
	if (_slk_init && num_labels > 0)
	    slk_initialize(stdscr, COLS);
a131 1
	SP->_ofp        = ofp;
d143 1
a143 1
	_nc_mvcur_init(SP);
a144 8
#if 0
	/* initialize soft labels */
	if (_slk_init)
	    if (num_labels <= 0)
		ripoffline(-1, slk_initialize);
	    else
		slk_initialize(stdscr, COLS);
#endif
d150 2
a151 1
	T(("newterm returns %p", SP));
d153 1
a155 1

@
