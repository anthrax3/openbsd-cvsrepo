head	1.10;
access;
symbols
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	99.01.18.19.08.27;	author millert;	state dead;
branches;
next	1.9;

1.9
date	98.11.17.03.16.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.10.31.06.30.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.09.17.04.14.31;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.07.23.21.19.22;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.01.17.16.27.36;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.12.03.05.21.31;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.11.29.05.01.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.06.05.34;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.10
log
@ncurses-4.2-990116
@
text
@/*	$OpenBSD: lib_set_term.c,v 1.9 1998/11/17 03:16:21 millert Exp $	*/

/****************************************************************************
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/



/*
**	lib_set_term.c
**
**	The routine set_term().
**
*/

#include <curses.priv.h>

#include <term.h>	/* cur_term */

MODULE_ID("$From: lib_set_term.c,v 1.43 1998/11/08 00:58:25 tom Exp $")

SCREEN * set_term(SCREEN *screen)
{
SCREEN	*oldSP;

	T((T_CALLED("set_term(%p)"), screen));

	oldSP = SP;
	_nc_set_screen(screen);

	set_curterm(SP->_term);
	curscr      = SP->_curscr;
	newscr      = SP->_newscr;
	stdscr      = SP->_stdscr;
	COLORS      = SP->_color_count;
	COLOR_PAIRS = SP->_pair_count;
	memcpy(acs_map, SP->_acs_map, sizeof(chtype)*ACS_LEN);

	T((T_RETURN("%p"), oldSP));
	return(oldSP);
}

static void _nc_free_keytry(struct tries *kt)
{
	if (kt != 0) {
		_nc_free_keytry(kt->child);
		_nc_free_keytry(kt->sibling);
		free(kt);
	}
}

/*
 * Free the storage associated with the given SCREEN sp.
 */
void delscreen(SCREEN *sp)
{
	SCREEN **scan = &_nc_screen_chain;

	T((T_CALLED("delscreen(%p)"), sp));

	while(*scan)
	{
	    if (*scan == sp)
	    {
		*scan = sp->_next_screen;
		break;
	    }
	    scan = &(*scan)->_next_screen;
	}

	_nc_freewin(sp->_curscr);
	_nc_freewin(sp->_newscr);
	_nc_freewin(sp->_stdscr);
	_nc_free_keytry(sp->_keytry);
	_nc_free_keytry(sp->_key_ok);

	FreeIfNeeded(sp->_color_table);
	FreeIfNeeded(sp->_color_pairs);

	FreeIfNeeded(sp->oldhash);
	FreeIfNeeded(sp->newhash);

	del_curterm(sp->_term);

	free(sp);

	/*
	 * If this was the current screen, reset everything that the
	 * application might try to use (except cur_term, which may have
	 * multiple references in different screens).
	 */
	if (sp == SP) {
		curscr = 0;
		newscr = 0;
		stdscr = 0;
		COLORS = 0;
		COLOR_PAIRS = 0;
		_nc_set_screen(0);
	}
	returnVoid;
}

static ripoff_t rippedoff[5];
static ripoff_t *rsp = rippedoff;
#define N_RIPS SIZEOF(rippedoff)

static bool no_mouse_event (SCREEN *sp GCC_UNUSED) { return FALSE; }
static bool no_mouse_inline(SCREEN *sp GCC_UNUSED) { return FALSE; }
static bool no_mouse_parse (int code   GCC_UNUSED) { return TRUE; }
static void no_mouse_resume(SCREEN *sp GCC_UNUSED) { }
static void no_mouse_wrap  (SCREEN *sp GCC_UNUSED) { }

int _nc_setupscreen(short slines, short const scolumns, FILE *output)
/* OS-independent screen initializations */
{
int	bottom_stolen = 0;
size_t	i;

        assert(SP==0); /* has been reset in newterm() ! */
	if (!_nc_alloc_screen())
		return ERR;

	SP->_next_screen = _nc_screen_chain;
	_nc_screen_chain = SP;

	_nc_set_buffer(output, TRUE);
	SP->_term        = cur_term;
	SP->_lines       = slines;
	SP->_lines_avail = slines;
	SP->_columns     = scolumns;
	SP->_cursrow     = -1;
	SP->_curscol     = -1;
	SP->_nl          = TRUE;
	SP->_raw         = FALSE;
	SP->_cbreak      = FALSE;
	SP->_echo        = TRUE;
	SP->_fifohead    = -1;
	SP->_endwin      = TRUE;
	SP->_ofp         = output;
	SP->_cursor      = -1;	/* cannot know real cursor shape */
#ifdef NCURSES_NO_PADDING
	SP->_no_padding  = getenv("NCURSES_NO_PADDING") != 0;
#endif

	SP->_maxclick     = DEFAULT_MAXCLICK;
	SP->_mouse_event  = no_mouse_event;
	SP->_mouse_inline = no_mouse_inline;
	SP->_mouse_parse  = no_mouse_parse;
	SP->_mouse_resume = no_mouse_resume;
	SP->_mouse_wrap   = no_mouse_wrap;
	SP->_mouse_fd     = -1;

	/* initialize the panel hooks */
	SP->_panelHook.top_panel = (struct panel*)0;
	SP->_panelHook.bottom_panel = (struct panel*)0;
	SP->_panelHook.stdscr_pseudo_panel = (struct panel*)0;

	/*
	 * If we've no magic cookie support, we suppress attributes that xmc
	 * would affect, i.e., the attributes that affect the rendition of a
	 * space.  Note that this impacts the alternate character set mapping
	 * as well.
	 */
	if (magic_cookie_glitch > 0) {

		SP->_xmc_triggers = termattrs() & (
				A_ALTCHARSET |
				A_BLINK |
				A_BOLD |
				A_REVERSE |
				A_STANDOUT |
				A_UNDERLINE
				);
		SP->_xmc_suppress = SP->_xmc_triggers & (chtype)~(A_BOLD);

		T(("magic cookie attributes %s", _traceattr(SP->_xmc_suppress)));
#if USE_XMC_SUPPORT
		/*
		 * To keep this simple, suppress all of the optimization hooks
		 * except for clear_screen and the cursor addressing.
		 */
		clr_eol = 0;
		clr_eos = 0;
		set_attributes = 0;
#else
		magic_cookie_glitch = -1;
		acs_chars = 0;
#endif
	}
	init_acs();
	memcpy(SP->_acs_map, acs_map, sizeof(chtype)*ACS_LEN);

	_nc_idcok = TRUE;
	_nc_idlok = FALSE;

	_nc_windows = 0; /* no windows yet */

	SP->oldhash = 0;
	SP->newhash = 0;

	T(("creating newscr"));
	if ((newscr = newwin(slines, scolumns, 0, 0)) == 0)
		return ERR;

	T(("creating curscr"));
	if ((curscr = newwin(slines, scolumns, 0, 0)) == 0)
		return ERR;

	SP->_newscr = newscr;
	SP->_curscr = curscr;
#if USE_SIZECHANGE
	SP->_resize = resizeterm;
#endif

	newscr->_clear = TRUE;
	curscr->_clear = FALSE;

	for (i=0, rsp = rippedoff; rsp->line && (i < N_RIPS); rsp++, i++) {
	  if (rsp->hook) {
	      WINDOW *w;
	      int count = (rsp->line < 0) ? -rsp->line : rsp->line;

	      if (rsp->line < 0) {
		  w = newwin(count,scolumns,SP->_lines_avail - count,0);
		  if (w) {
		      rsp->w = w;
		      rsp->hook(w, scolumns);
		      bottom_stolen += count;
		  }
		  else
		    return ERR;
	      } else {
		  w = newwin(count,scolumns, 0, 0);
		  if (w) {
		      rsp->w = w;
		      rsp->hook(w, scolumns);
		      SP->_topstolen += count;
		  }
		  else
		    return ERR;
	      }
	      SP->_lines_avail -= count;
	  }
	  rsp->line = 0;
	}
	/* reset the stack */
	rsp = rippedoff;

	T(("creating stdscr"));
	assert ((SP->_lines_avail + SP->_topstolen + bottom_stolen) == slines);
	if ((stdscr = newwin(LINES = SP->_lines_avail, scolumns, 0, 0)) == 0)
		return ERR;
	SP->_stdscr = stdscr;

	def_shell_mode();
	def_prog_mode();

	return OK;
}

/* The internal implementation interprets line as the number of
   lines to rip off from the top or bottom.
   */
int
_nc_ripoffline(int line, int (*init)(WINDOW *,int))
{
    if (line == 0)
	return(OK);

    if (rsp >= rippedoff + N_RIPS)
	return(ERR);

    rsp->line = line;
    rsp->hook = init;
    rsp->w    = 0;
    rsp++;

    return(OK);
}

int
ripoffline(int line, int (*init)(WINDOW *, int))
{
    T((T_CALLED("ripoffline(%d,%p)"), line, init));

    if (line == 0)
	returnCode(OK);

    returnCode(_nc_ripoffline ((line<0) ? -1 : 1, init));
}
@


1.9
log
@update to ncurses-4.2-981114
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.8 1998/10/31 06:30:30 millert Exp $	*/
@


1.8
log
@update to ncurses 4.2-981017
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.7 1998/09/17 04:14:31 millert Exp $	*/
d49 1
a49 88
MODULE_ID("$From: lib_set_term.c,v 1.42 1998/09/20 03:58:06 tom Exp $")

/*
 * If the output file descriptor is connected to a tty (the typical case) it
 * will probably be line-buffered.  Keith Bostic pointed out that we don't want
 * this; it hoses people running over networks by forcing out a bunch of small
 * packets instead of one big one, so screen updates on ptys look jerky.
 * Restore block buffering to prevent this minor lossage.
 *
 * The buffer size is a compromise.  Ideally we'd like a buffer that can hold
 * the maximum possible update size (the whole screen plus cup commands to
 * change lines as it's painted).  On a 66-line xterm this can become
 * excessive.  So we min it with the amount of data we think we can get through
 * two Ethernet packets (maximum packet size - 100 for TCP/IP overhead).
 *
 * Why two ethernet packets?  It used to be one, on the theory that said
 * packets define the maximum size of atomic update.  But that's less than the
 * 2000 chars on a 25 x 80 screen, and we don't want local updates to flicker
 * either.  Two packet lengths will handle up to a 35 x 80 screen.
 *
 * The magic '6' is the estimated length of the end-of-line cup sequence to go
 * to the next line.  It's generous.  We used to mess with the buffering in
 * init_mvcur() after cost computation, but that lost the sequences emitted by
 * init_acs() in setupscreen().
 *
 * "The setvbuf function may be used only after the stream pointed to by stream
 * has been associated with an open file and before any other operation is
 * performed on the stream." (ISO 7.9.5.6.)
 *
 * Grrrr...
 *
 * On a lighter note, many implementations do in fact allow an application to
 * reset the buffering after it has been written to.  We try to do this because
 * otherwise we leave stdout in buffered mode after endwin() is called.  (This
 * also happens with SVr4 curses).
 *
 * There are pros/cons:
 *
 * con:
 *	There is no guarantee that we can reestablish buffering once we've
 *	dropped it.
 *
 *	We _may_ lose data if the implementation does not coordinate this with
 *	fflush.
 *
 * pro:
 *	An implementation is more likely to refuse to change the buffering than
 *	to do it in one of the ways mentioned above.
 *
 *	The alternative is to have the application try to change buffering
 *	itself, which is certainly no improvement.
 *
 * Just in case it does not work well on a particular system, the calls to
 * change buffering are all via the macro NC_BUFFERED.
 */
void _nc_set_buffer(FILE *ofp, bool buffered)
{
	/* optional optimization hack -- do before any output to ofp */
#if HAVE_SETVBUF || HAVE_SETBUFFER
	unsigned buf_len;
	char *buf_ptr;

	fflush(ofp);
	if ((SP->_buffered = buffered) != 0) {
		buf_len = min(LINES * (COLS + 6), 2800);
	 	if ((buf_ptr = SP->_setbuf) == 0) {
			if ((buf_ptr = malloc(buf_len)) == NULL)
				return;
			SP->_setbuf = buf_ptr;
			/* Don't try to free this! */
		}
	} else {
		buf_len = 0;
		buf_ptr = 0;
	}

#if HAVE_SETVBUF
#ifdef SETVBUF_REVERSED	/* pre-svr3? */
	(void) setvbuf(ofp, buf_ptr, buf_len, buf_len ? _IOFBF : _IOLBF);
#else
	(void) setvbuf(ofp, buf_ptr, buf_len ? _IOFBF : _IOLBF, buf_len);
#endif
#elif HAVE_SETBUFFER
	(void) setbuffer(ofp, buf_ptr, (int)buf_len);
#endif

#endif /* HAVE_SETVBUF || HAVE_SETBUFFER */
}
@


1.7
log
@ncurses-4.2-980912
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.6 1998/07/23 21:19:22 millert Exp $	*/
d49 1
a49 1
MODULE_ID("$From: lib_set_term.c,v 1.40 1998/09/12 23:16:41 tom Exp $")
d111 2
a112 1
	if (buffered) {
d114 6
a119 2
		if ((buf_ptr = malloc(buf_len)) == NULL)
			return;
a134 5
	if (!buffered) {
		FreeIfNeeded(SP->_setbuf);
	}
	SP->_setbuf = buf_ptr;

d196 5
d313 3
@


1.6
log
@ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
MODULE_ID("$From: lib_set_term.c,v 1.39 1998/05/30 23:44:18 Todd.Miller Exp $")
d79 24
d122 1
a122 1
	(void) setvbuf(ofp, buf_ptr, buf_len, buf_len ? _IOFBF : _IONBF);
d124 1
a124 1
	(void) setvbuf(ofp, buf_ptr, buf_len ? _IOFBF : _IONBF, buf_len);
@


1.5
log
@Use _ti_get_screensize() from libtermlib to update screen size if changed
    after a program is suspended.
Define EXTERN_TERMINFO in curses.h.
Update to ncurses-4.1-980103 and crank minor.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_set_term.c,v 1.4 1997/12/03 05:21:31 millert Exp $	*/
d3 32
a34 20

/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d49 1
a49 1
MODULE_ID("Id: lib_set_term.c,v 1.36 1997/12/20 22:21:48 tom Exp $")
d55 1
a55 1
 * packets instead of one big one, so screen updates on ptys look jerky. 
d83 1
a83 1
#if HAVE_SETVBUF || HAVE_SETBUFFER  
d206 1
a206 1
        assert(SP==0); /* has been reset in newterm() ! */ 
d212 1
a212 1
	
d228 3
d282 1
a282 1
	
@


1.4
log
@Merge of ncurses-4.1-971129
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
MODULE_ID("Id: lib_set_term.c,v 1.35 1997/11/08 21:23:37 tom Exp $")
d280 1
d282 1
@


1.3
log
@Check malloc() return vals.
@
text
@d1 2
d37 1
a37 1
MODULE_ID("Id: lib_set_term.c,v 1.17 1997/05/01 23:46:18 Alexander.V.Lukyanov Exp $")
d111 1
a111 1
	cur_term    = SP->_term;
d117 1
d137 2
d141 10
d155 1
d178 9
a186 2
ripoff_t rippedoff[5], *rsp = rippedoff;
#define N_RIPS (int)(sizeof(rippedoff)/sizeof(rippedoff[0]))
d191 2
a192 1
int	bottom_stolen = 0, i;
d194 1
d198 3
a207 1
	SP->_keytry      = UNINITIALISED;
d211 1
a211 1
	SP->_echo        = FALSE;
a212 2
	SP->_fifotail    = 0;
	SP->_fifopeek    = 0;
a214 5
	SP->_coloron     = 0;
	SP->_curscr      = 0;
	SP->_newscr      = 0;
	SP->_stdscr      = 0;
	SP->_topstolen   = 0;
d217 45
d263 6
d280 1
d311 1
d313 2
@


1.2
log
@ncurses 4.1 + changes to work with our terminfo libs (instead of
the ncurses ones).  Changes are #ifdef EXTERN_TERMINFO.
Post 4.1 patches will be applied in a separate commit.
@
text
@d75 2
a76 1
		buf_ptr = malloc(buf_len);
@


1.1
log
@Install ncurses as -lcurses and <curses.h>
Install BSD curses library as -locurses and <ocurses.h>
@
text
@d31 1
a31 3
#include "curses.priv.h"
#include <stdlib.h>
#include "term.h"	/* cur_term */
d33 34
a66 1
struct screen * set_term(struct screen *screen)
d68 12
a79 1
struct screen	*oldSP;
d81 23
a103 1
	T(("set_term(%p) called", screen));
d108 6
a113 4
	cur_term = SP->_term;
	curscr   = SP->_curscr;
	newscr   = SP->_newscr;
	stdscr   = SP->_stdscr;
d115 1
d119 12
d133 10
d144 15
d161 2
a162 6
struct ripoff_t
{
	int	line;
	int	(*hook)(WINDOW *, int);
}
rippedoff[5], *rsp = rippedoff;
d164 1
a164 1
int _nc_setupscreen(short slines, short const scolumns)
d167 1
a167 1
int	stolen, topstolen;
d170 1
a170 1
	    	return ERR;
d172 23
a194 16
	SP->_term      	= cur_term;
	SP->_lines	= slines;
	SP->_columns	= scolumns;
	SP->_cursrow   	= -1;
	SP->_curscol   	= -1;
	SP->_keytry    	= UNINITIALISED;
	SP->_nl        	= TRUE;
	SP->_raw       	= FALSE;
	SP->_cbreak    	= FALSE;
	SP->_echo      	= TRUE;
	SP->_fifohead	= -1;
	SP->_fifotail 	= 0;
	SP->_fifopeek	= 0;
	SP->_endwin	= TRUE;
	SP->_ofp	= stdout;	/* (may be overridden later) */
	SP->_coloron	= 0;
d196 1
a196 1
	init_acs(); 
d199 2
a200 2
	if ((newscr = newwin(slines, scolumns, 0, 0)) == (WINDOW *)NULL)
	    	return ERR;
d203 2
a204 2
	if ((curscr = newwin(slines, scolumns, 0, 0)) == (WINDOW *)NULL)
	    	return ERR;
d212 26
a237 9
	stolen = topstolen = 0;
	for (rsp = rippedoff; rsp->line; rsp++) {
		if (rsp->hook)
			if (rsp->line < 0)
				rsp->hook(newwin(1,scolumns, slines-1,0), scolumns);
			else
				rsp->hook(newwin(1,scolumns, topstolen++,0), scolumns);
		--slines;
		stolen++;
d241 2
a242 1
    	if ((stdscr = newwin(LINES = slines, scolumns, topstolen, 0)) == NULL)
d252 3
d256 1
a256 1
ripoffline(int line, int (*init)(WINDOW *, int))
d261 1
a261 1
    if (rsp >= rippedoff + sizeof(rippedoff)/sizeof(rippedoff[0]))
d266 1
d270 11
@
