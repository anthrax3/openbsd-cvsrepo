head	1.8;
access;
symbols
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	99.01.18.19.07.40;	author millert;	state dead;
branches;
next	1.7;

1.7
date	98.10.31.06.30.29;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.08.03.17.02.45;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.07.23.21.18.36;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.12.03.05.21.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.11.29.05.01.21;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.30;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.06.05.21;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.8
log
@ncurses-4.2-990116
@
text
@/*	$OpenBSD: lib_color.c,v 1.7 1998/10/31 06:30:29 millert Exp $	*/

/****************************************************************************
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/

/* lib_color.c
 *
 * Handles color emulation of SYS V curses
 *
 */

#include <curses.priv.h>

#include <term.h>

MODULE_ID("$From: lib_color.c,v 1.33 1998/09/20 00:51:51 tom Exp $")

/*
 * These should be screen structure members.  They need to be globals for
 * hystorical reasons.  So we assign them in start_color() and also in
 * set_term()'s screen-switching logic.
 */
int COLOR_PAIRS;
int COLORS;

/*
 * Given a RGB range of 0..1000, we'll normally set the individual values
 * to about 2/3 of the maximum, leaving full-range for bold/bright colors.
 */
#define RGB_ON  680
#define RGB_OFF 0

static const color_t cga_palette[] =
{
    /*  R		G		B */
	{RGB_OFF,	RGB_OFF,	RGB_OFF},	/* COLOR_BLACK */
	{RGB_ON,	RGB_OFF,	RGB_OFF},	/* COLOR_RED */
	{RGB_OFF,	RGB_ON,		RGB_OFF},	/* COLOR_GREEN */
	{RGB_ON,	RGB_ON,		RGB_OFF},	/* COLOR_YELLOW */
	{RGB_OFF,	RGB_OFF,	RGB_ON},	/* COLOR_BLUE */
	{RGB_ON,	RGB_OFF,	RGB_ON},	/* COLOR_MAGENTA */
	{RGB_OFF,	RGB_ON,		RGB_ON},	/* COLOR_CYAN */
	{RGB_ON,	RGB_ON,		RGB_ON},	/* COLOR_WHITE */
};
static const color_t hls_palette[] =
{
    /*  H	L	S */
	{0,	0,	0},	/* COLOR_BLACK */
	{120,	50,	100},	/* COLOR_RED */
	{240,	50,	100},	/* COLOR_GREEN */
	{180,	50,	100},	/* COLOR_YELLOW */
	{330,	50,	100},	/* COLOR_BLUE */
	{60,	50,	100},	/* COLOR_MAGENTA */
	{300,	50,	100},	/* COLOR_CYAN */
	{0,	50,	100},	/* COLOR_WHITE */
};

/*
 * SVr4 curses is known to interchange color codes (1,4) and (3,6), possibly
 * to maintain compatibility with a pre-ANSI scheme.  The same scheme is
 * also used in the FreeBSD syscons.
 */
static int toggled_colors(int c)
{
    if (c < 16) {
	static const int table[] =
		{ 0,  4,  2,  6,  1,  5,  3,  7,
		  8, 12, 10, 14,  9, 13, 11, 15};
	c = table[c];
    }
    return c;
}

static void set_background_color(int bg, int  (*outc)(int))
{
	if (set_a_background)
	{
	    TPUTS_TRACE("set_a_background");
	    tputs(tparm(set_a_background, bg), 1, outc);
	}
	else
	{
	    TPUTS_TRACE("set_background");
	    tputs(tparm(set_background, toggled_colors(bg)), 1, outc);
	}
}

static void set_foreground_color(int fg, int  (*outc)(int))
{
	if (set_a_foreground)
	{
	    TPUTS_TRACE("set_a_foreground");
	    tputs(tparm(set_a_foreground, fg), 1, outc);
	}
	else
	{
	    TPUTS_TRACE("set_foreground");
	    tputs(tparm(set_foreground, toggled_colors(fg)), 1, outc);
	}
}

static bool set_original_colors(void)
{
	if (orig_pair != 0) {
		TPUTS_TRACE("orig_pair");
		putp(orig_pair);
		return TRUE;
	}
	else if (orig_colors != NULL)
	{
		TPUTS_TRACE("orig_colors");
		putp(orig_colors);
		return TRUE;
	}
	return FALSE;
}

int start_color(void)
{
	T((T_CALLED("start_color()")));

	if (set_original_colors() != TRUE)
	{
		set_foreground_color(COLOR_WHITE, _nc_outch);
		set_background_color(COLOR_BLACK, _nc_outch);
	}

	if (max_pairs != -1)
		COLOR_PAIRS = SP->_pair_count = max_pairs;
	else
		returnCode(ERR);
	if ((SP->_color_pairs = typeCalloc(unsigned short, max_pairs)) == 0)
		returnCode(ERR);
	SP->_color_pairs[0] = PAIR_OF(COLOR_WHITE, COLOR_BLACK);
	if (max_colors != -1)
		COLORS = SP->_color_count = max_colors;
	else
		returnCode(ERR);
	SP->_coloron = 1;

	if ((SP->_color_table = malloc(sizeof(color_t) * COLORS)) == 0)
		returnCode(ERR);
	if (hue_lightness_saturation)
	    memcpy(SP->_color_table, hls_palette, sizeof(color_t) * COLORS);
	else
	    memcpy(SP->_color_table, cga_palette, sizeof(color_t) * COLORS);

	T(("started color: COLORS = %d, COLOR_PAIRS = %d", COLORS, COLOR_PAIRS));

	returnCode(OK);
}

/* This function was originally written by Daniel Weaver <danw@@znyx.com> */
static void rgb2hls(short r, short g, short b, short *h, short *l, short *s)
/* convert RGB to HLS system */
{
    short min, max, t;

    if ((min = g < r ? g : r) > b) min = b;
    if ((max = g > r ? g : r) < b) max = b;

    /* calculate lightness */
    *l = (min + max) / 20;

    if (min == max)		/* black, white and all shades of gray */
    {
	*h = 0;
	*s = 0;
	return;
    }

    /* calculate saturation */
    if (*l < 50)
	*s = ((max - min) * 100) / (max + min);
    else *s = ((max - min) * 100) / (2000 - max - min);

    /* calculate hue */
    if (r == max)
	t = 120 + ((g - b) * 60) / (max - min);
    else
	if (g == max)
	    t = 240 + ((b - r) * 60) / (max - min);
	else
	    t = 360 + ((r - g) * 60) / (max - min);

    *h = t % 360;
}

/*
 * Extension (1997/1/18) - Allow negative f/b values to set default color
 * values.
 */
int init_pair(short pair, short f, short b)
{
	unsigned result;

	T((T_CALLED("init_pair(%d,%d,%d)"), pair, f, b));

	if ((pair < 1) || (pair >= COLOR_PAIRS))
		returnCode(ERR);
	if (SP->_default_color)
	{
		if (f < 0)
			f = C_MASK;
		if (b < 0)
			b = C_MASK;
		if (f >= COLORS && f != C_MASK)
			returnCode(ERR);
		if (b >= COLORS && b != C_MASK)
			returnCode(ERR);
	}
	else
	if ((f < 0) || (f >= COLORS)
	 || (b < 0) || (b >= COLORS))
		returnCode(ERR);

	/*
	 * When a pair's content is changed, replace its colors (if pair was
	 * initialized before a screen update is performed replacing original
	 * pair colors with the new ones).
	 */
	result = PAIR_OF(f,b);
	if (SP->_color_pairs[pair] != 0
	 && SP->_color_pairs[pair] != result) {
	    int y, x;
	    attr_t z = COLOR_PAIR(pair);

	    for (y = 0; y <= curscr->_maxy; y++) {
		struct ldat *ptr = &(curscr->_line[y]);
		bool changed = FALSE;
		for (x = 0; x <= curscr->_maxx; x++) {
		    if ((ptr->text[x] & A_COLOR) == z) {
			ptr->text[x] &= ~A_COLOR;
			CHANGED_CELL(ptr,x);
			changed = TRUE;
		    }
		}
		if (changed)
			_nc_make_oldhash(y);
	    }
	}
	SP->_color_pairs[pair] = result;

	if (initialize_pair)
	{
	    const color_t *tp = hue_lightness_saturation ? hls_palette : cga_palette;

	    T(("initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)",
	       pair,
	       tp[f].red, tp[f].green, tp[f].blue,
	       tp[b].red, tp[b].green, tp[b].blue));

	    if (initialize_pair)
	    {
		TPUTS_TRACE("initialize_pair");
		putp(tparm(initialize_pair,
			    pair,
			    tp[f].red, tp[f].green, tp[f].blue,
			    tp[b].red, tp[b].green, tp[b].blue));
	    }
	}

	returnCode(OK);
}

int init_color(short color, short r, short g, short b)
{
	T((T_CALLED("init_color(%d,%d,%d,%d)"), color, r, g, b));

	if (initialize_color == NULL)
		returnCode(ERR);

	if (color < 0 || color >= COLORS)
		returnCode(ERR);
	if (r < 0 || r > 1000 || g < 0 ||  g > 1000 || b < 0 || b > 1000)
		returnCode(ERR);

	if (hue_lightness_saturation)
	    rgb2hls(r, g, b,
		      &SP->_color_table[color].red,
		      &SP->_color_table[color].green,
		      &SP->_color_table[color].blue);
	else
	{
		SP->_color_table[color].red = r;
		SP->_color_table[color].green = g;
		SP->_color_table[color].blue = b;
	}

	if (initialize_color)
	{
		TPUTS_TRACE("initialize_color");
		putp(tparm(initialize_color, color, r, g, b));
	}
	returnCode(OK);
}

bool can_change_color(void)
{
	T((T_CALLED("can_change_color()")));
	returnCode ((can_change != 0) ? TRUE : FALSE);
}

bool has_colors(void)
{
	T((T_CALLED("has_colors()")));
	returnCode (((max_colors != -1) && (max_pairs != -1)
		     && (((set_foreground != NULL)
			  && (set_background != NULL))
			 || ((set_a_foreground != NULL)
			     && (set_a_background != NULL))
			 || set_color_pair)) ? TRUE : FALSE);
}

int color_content(short color, short *r, short *g, short *b)
{
    T((T_CALLED("color_content(%d,%p,%p,%p)"), color, r, g, b));
    if (color < 0 || color > COLORS)
	returnCode(ERR);

    if (r) *r = SP->_color_table[color].red;
    if (g) *g = SP->_color_table[color].green;
    if (b) *b = SP->_color_table[color].blue;
    returnCode(OK);
}

int pair_content(short pair, short *f, short *b)
{
	T((T_CALLED("pair_content(%d,%p,%p)"), pair, f, b));

	if ((pair < 0) || (pair > COLOR_PAIRS))
		returnCode(ERR);
	if (f) *f = ((SP->_color_pairs[pair] >> C_SHIFT) & C_MASK);
	if (b) *b =  (SP->_color_pairs[pair] & C_MASK);

	returnCode(OK);
}

void _nc_do_color(int pair, bool reverse, int (*outc)(int))
{
    short fg, bg;

    if (pair == 0)
    {
	if (orig_pair)
	{
	    TPUTS_TRACE("orig_pair");
	    tputs(orig_pair, 1, outc);
	}
	else if (set_color_pair)
	{
	    TPUTS_TRACE("set_color_pair");
	    tputs(tparm(set_color_pair, pair), 1, outc);
	}
	else
	{
	    set_foreground_color(COLOR_WHITE, outc);
	    set_background_color(COLOR_BLACK, outc);
	}
    }
    else
    {
	if (set_color_pair)
	{
	    TPUTS_TRACE("set_color_pair");
	    tputs(tparm(set_color_pair, pair), 1, outc);
	}
	else
	{
	    pair_content(pair, &fg, &bg);
	    if (reverse) {
		short xx = fg;
		fg = bg;
		bg = xx;
	    }

	    T(("setting colors: pair = %d, fg = %d, bg = %d", pair, fg, bg));

	    if (fg == C_MASK || bg == C_MASK)
	    {
		if (set_original_colors() != TRUE)
		{
			if (fg == C_MASK)
				set_foreground_color(COLOR_WHITE, outc);
			if (bg == C_MASK)
				set_background_color(COLOR_BLACK, outc);
		}
	    }
	    if (fg != C_MASK)
	    {
		set_foreground_color(fg, outc);
	    }
	    if (bg != C_MASK)
	    {
		set_background_color(bg, outc);
	    }
	}
    }
}
@


1.7
log
@update to ncurses 4.2-981017
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.6 1998/08/03 17:02:45 millert Exp $	*/
@


1.6
log
@update to ncurses-4.2-980801
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_color.c,v 1.5 1998/07/23 21:18:36 millert Exp $	*/
d46 1
a46 1
MODULE_ID("$From: lib_color.c,v 1.31 1998/08/01 22:21:29 tom Exp $")
d260 1
d265 1
d268 2
@


1.5
log
@ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
MODULE_ID("$From: lib_color.c,v 1.30 1998/06/28 00:10:19 tom Exp $")
a367 3

    if (reverse)
    	pair = -pair;
@


1.4
log
@Merge of ncurses-4.1-971129
@
text
@d3 32
a34 20

/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d46 1
a46 7
MODULE_ID("Id: lib_color.c,v 1.21 1997/11/30 00:19:33 tom Exp $")

/*
 * Only 8 ANSI colors are defined; the ISO 6429 control sequences work only
 * for 8 values (0-7).
 */
#define MAX_ANSI_COLOR 8
d88 17
a104 1
int start_color(void)
d106 11
a116 1
	T((T_CALLED("start_color()")));
d118 8
a125 2
#ifdef orig_pair
	if (orig_pair != NULL)
d127 8
d137 1
d139 1
a139 3
#endif /* orig_pair */
#ifdef orig_colors
	if (orig_colors != NULL)
d143 1
d145 13
a157 5
#endif /* orig_colors */
#if defined(orig_pair) && defined(orig_colors)
	if (!orig_pair && !orig_colors)
		returnCode(ERR);
#endif /* defined(orig_pair) && defined(orig_colors) */
d162 2
a163 1
	SP->_color_pairs = typeCalloc(unsigned short, max_pairs);
d171 1
a171 2
	if ((SP->_color_table = malloc(sizeof(color_t) * COLORS)) == NULL) {
		errno = ENOMEM;
a172 2
	}
#ifdef hue_lightness_saturation
a175 1
#endif /* hue_lightness_saturation */
a177 6
	if (orig_colors)
	{
	    TPUTS_TRACE("orig_colors");
	    putp(orig_colors);
	}

a182 1
#ifdef hue_lightness_saturation
d188 1
a188 1
    
a217 1
#endif /* hue_lightness_saturation */
d225 2
d248 3
a250 3
	 * FIXME: when a pair's content is changed, replace its colors
	 * (if pair was initialized before a screen update is performed
	 * replacing original pair colors with the new ones)
d252 17
a268 2

	SP->_color_pairs[pair] = PAIR_OF(f,b);
d272 1
a272 1
	    const color_t	*tp = hue_lightness_saturation ? hls_palette : cga_palette;
d295 1
a295 1
#ifdef initialize_color
a297 1
#endif /* initialize_color */
a303 1
#ifdef hue_lightness_saturation
a309 1
#endif /* hue_lightness_saturation */
a315 1
#ifdef initialize_color
a320 1
#endif /* initialize_color */
d333 1
a333 2
	returnCode (((orig_pair != NULL || orig_colors != NULL)
		     && (max_colors != -1) && (max_pairs != -1)
d365 1
a365 6
/*
 * SVr4 curses is known to interchange color codes (1,4) and (3,6), possibly
 * to maintain compatibility with a pre-ANSI scheme.  The same scheme is
 * also used in the FreeBSD syscons.
 */
static int toggled_colors(int c)
d367 1
a367 8
    if (c < 16) {
	static const int table[] =
		{ 0,  4,  2,  6,  1,  5,  3,  7,
		  8, 12, 10, 14,  9, 13, 11, 15};
	c = table[c];
    }
    return c;
}
d369 2
a370 3
void _nc_do_color(int pair, int  (*outc)(int))
{
    short fg, bg;
d379 10
d400 5
d410 1
a410 6
		if (orig_pair)
		{
		    TPUTS_TRACE("orig_pair");
		    tputs(orig_pair, 1, outc);
		}
		else
d412 4
a415 2
		    TPUTS_TRACE("orig_colors");
		    tputs(orig_colors, 1, outc);
d420 1
a420 10
		if (set_a_foreground && fg <= MAX_ANSI_COLOR)
		{
		    TPUTS_TRACE("set_a_foreground");
		    tputs(tparm(set_a_foreground, fg), 1, outc);
		}
		else
		{
		    TPUTS_TRACE("set_foreground");
		    tputs(tparm(set_foreground, toggled_colors(fg)), 1, outc);
		}
d424 1
a424 10
		if (set_a_background && bg <= MAX_ANSI_COLOR)
		{
		    TPUTS_TRACE("set_a_background");
		    tputs(tparm(set_a_background, bg), 1, outc);
		}
		else
		{
		    TPUTS_TRACE("set_background");
		    tputs(tparm(set_background, toggled_colors(bg)), 1, outc);
		}
@


1.3
log
@Check malloc() return vals.
@
text
@d1 2
d34 7
a40 1
MODULE_ID("Id: lib_color.c,v 1.17 1997/05/03 19:16:05 tom Exp $")
d50 7
d59 9
a67 9
    /*  R	G	B */
	{0,	0,	0},	/* COLOR_BLACK */
	{1000,	0,	0},	/* COLOR_RED */
	{0,	1000,	0},	/* COLOR_GREEN */
	{1000,	1000,	0},	/* COLOR_YELLOW */
	{0,	0,	1000},	/* COLOR_BLUE */
	{1000,	0,	1000},	/* COLOR_MAGENTA */
	{0,	1000,	1000},	/* COLOR_CYAN */
	{1000,	1000,	1000},	/* COLOR_WHITE */
d139 1
d144 1
a144 1

d242 2
a243 8
#ifdef hue_lightness_saturation
	if (hue_lightness_saturation == TRUE)
		if (r < 0 || r > 360 || g < 0 || g > 100 || b < 0 || b > 100)
			returnCode(ERR);
	if (hue_lightness_saturation == FALSE)
#endif /* hue_lightness_saturation */
		if (r < 0 || r > 1000 || g < 0 ||  g > 1000 || b < 0 || b > 1000)
			returnCode(ERR);
d272 1
a272 1
	returnCode(can_change != 0);
d278 7
a284 7
	returnCode((orig_pair != NULL || orig_colors != NULL)
		&& (max_colors != -1) && (max_pairs != -1)
		&&
		(((set_foreground != NULL) && (set_background != NULL))
		|| ((set_a_foreground != NULL) && (set_a_background != NULL))
		|| set_color_pair)
		);
d293 3
a295 3
    *r = SP->_color_table[color].red;
    *g = SP->_color_table[color].green;
    *b = SP->_color_table[color].blue;
d305 2
a306 2
	*f = ((SP->_color_pairs[pair] >> C_SHIFT) & C_MASK);
	*b =  (SP->_color_pairs[pair] & C_MASK);
d367 1
a367 1
		if (set_a_foreground)
d380 1
a380 1
		if (set_a_background)
@


1.2
log
@ncurses 4.1 + changes to work with our terminfo libs (instead of
the ncurses ones).  Changes are #ifdef EXTERN_TERMINFO.
Post 4.1 patches will be applied in a separate commit.
@
text
@d101 4
a104 1
	SP->_color_table = malloc(sizeof(color_t) * COLORS);
@


1.1
log
@Install ncurses as -lcurses and <curses.h>
Install BSD curses library as -locurses and <ocurses.h>
@
text
@d22 2
a23 2
/* lib_color.c 
 *  
d28 5
a32 4
#include "curses.priv.h"
#include <stdlib.h>
#include <string.h>
#include "term.h"
d34 5
a40 8
unsigned char *color_pairs;

typedef struct
{
    short red, green, blue;
}
color_t;
static color_t	*color_table;
d69 1
a69 1
	T(("start_color() called."));
d87 1
a87 1
		return ERR;
d90 1
a90 1
		COLOR_PAIRS = max_pairs;
d92 3
a94 2
		return ERR;
	color_pairs = calloc((unsigned int)max_pairs, sizeof(char));
d96 1
a96 1
		COLORS = max_colors;
d98 1
a98 1
		return ERR;
d101 1
a102 1
	color_table = malloc(sizeof(color_t) * COLORS);
d104 1
a104 1
	    memcpy(color_table, hls_palette, sizeof(color_t) * COLORS);
d107 1
a107 1
	    memcpy(color_table, cga_palette, sizeof(color_t) * COLORS);
d117 1
a117 1
	return OK;
d157 4
d163 1
a163 1
	T(("init_pair( %d, %d, %d )", pair, f, b));
d166 16
a181 3
		return ERR;
	if ((f  < 0) || (f >= COLORS) || (b < 0) || (b >= COLORS))
		return ERR;
d183 1
a183 1
	/* 
d189 1
a189 1
	color_pairs[pair] = ( (f & 0x0f) | (b & 0x0f) << 4 );
d195 1
a195 1
	    T(("initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)\n",
d207 1
a207 1
	    }		
d210 1
a210 1
	return OK;
d215 1
d218 1
a218 1
		return ERR;
d222 1
a222 1
		return ERR;
d226 1
a226 1
			return ERR;	
d230 2
a231 2
			return ERR;
				
d235 3
a237 3
		      &color_table[color].red,
		      &color_table[color].green,
		      &color_table[color].blue);
d241 3
a243 3
		color_table[color].red = r;
		color_table[color].green = g;
		color_table[color].blue = b;
d253 1
a253 1
	return OK;
d258 2
a259 1
	return (can_change != 0);
d262 1
a262 1
int has_colors(void)
d264 2
a265 1
	return ((orig_pair != NULL || orig_colors != NULL) 
d267 1
a267 1
		&& 
d276 1
d278 1
a278 1
	return ERR;
d280 4
a283 4
    *r = color_table[color].red;
    *g = color_table[color].green;
    *b = color_table[color].blue;
    return OK;
d288 1
d290 6
a295 6
	if ((pair < 1) || (pair > COLOR_PAIRS))
		return ERR;
	*f = color_pairs[pair] & 0x0f;
	*b = color_pairs[pair] & 0xf0;
	*b >>= 4;
	return OK;
d298 15
d318 1
a318 1
    if (pair == 0) 
d337 1
a337 1
	    T(("setting colors: pair = %d, fg = %d, bg = %d\n", pair, fg, bg));
d339 1
a339 6
	    if (set_a_foreground)
	    {
		TPUTS_TRACE("set_a_foreground");
		tputs(tparm(set_a_foreground, fg), 1, outc);
	    }
	    else
d341 10
a350 2
		TPUTS_TRACE("set_foreground");
		tputs(tparm(set_foreground, fg), 1, outc);
d352 1
a352 1
	    if (set_a_background)
d354 10
a363 2
		TPUTS_TRACE("set_a_background");
		tputs(tparm(set_a_background, bg), 1, outc);
d365 1
a365 1
	    else
d367 10
a376 2
		TPUTS_TRACE("set_background");
		tputs(tparm(set_background, bg), 1, outc);
@
