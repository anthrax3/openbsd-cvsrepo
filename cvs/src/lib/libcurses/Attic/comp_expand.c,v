head	1.6;
access;
symbols
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.6
date	99.01.18.19.07.06;	author millert;	state dead;
branches;
next	1.5;

1.5
date	98.10.31.06.30.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.09.13.19.16.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.08.15.18.44.43;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.08.14.21.11.38;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	98.07.23.21.17.25;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@ncurses-4.2-990116
@
text
@/*	$OpenBSD: comp_expand.c,v 1.5 1998/10/31 06:30:28 millert Exp $	*/

/****************************************************************************
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Thomas E. Dickey <dickey@@clark.net> 1998                        *
 ****************************************************************************/

#include <curses.priv.h>

#include <ctype.h>
#include <tic.h>

MODULE_ID("$From: comp_expand.c,v 1.9 1998/09/26 13:41:40 tom Exp $")

static int trailing_spaces(const char *src)
{
	while (*src == ' ')
		src++;
	return *src == 0;
}

/* this deals with differences over whether 0x7f and 0x80..0x9f are controls */
#define CHAR_OF(s) (*(unsigned const char *)(s))
#define REALCTL(s) (CHAR_OF(s) < 127 && iscntrl(CHAR_OF(s)))
#define REALPRINT(s) (CHAR_OF(s) < 127 && isprint(CHAR_OF(s)))

char *_nc_tic_expand(const char *srcp, bool tic_format, bool numbers)
{
static char *	buffer;
static size_t	length;

int		bufp;
const char	*ptr, *str = VALID_STRING(srcp) ? srcp : "";
bool		islong = (strlen(str) > 3);
size_t		need = (2 + strlen(str)) * 4;
int		ch;

	if (buffer == 0 || need > length) {
		if ((buffer = (char *)_nc_doalloc(buffer, length = need)) == 0)
			return 0;
	}

	bufp = 0;
	ptr = str;
	while ((ch = (*str & 0xff)) != 0) {
		if (ch == '%' && REALPRINT(str+1)) {
			buffer[bufp++] = *str++;
			/*
			 * Though the character literals are more compact, most
			 * terminal descriptions use numbers and are not easy
			 * to read in character-literal form.  This is the
			 * default option for tic/infocmp.
			 */
			if (numbers
			 && str[0] == S_QUOTE
			 && str[1] != '\\'
			 && REALPRINT(str+1)
			 && str[2] == S_QUOTE) {
				sprintf(buffer+bufp, "{%d}", str[1]);
				bufp += strlen(buffer+bufp);
				str += 2;
			}
			/*
			 * If we have a "%{number}", try to translate it into
			 * a "%'char'" form, since that will run a little faster
			 * when we're interpreting it.  Also, having one form
			 * for the constant makes it simpler to compare terminal
			 * descriptions.
			 */
			else if (!numbers
			 && str[0] == L_BRACE
			 && isdigit(str[1])) {
				char *dst = 0;
				long value = strtol(str+1, &dst, 0);
				if (dst != 0
				 && *dst == R_BRACE
				 && value < 127
				 && value != '\\'	/* FIXME */
				 && isprint((int)value)) {
					ch = (int)value;
					buffer[bufp++] = S_QUOTE;
					if (ch == '\\'
					 || ch == S_QUOTE)
						buffer[bufp++] = '\\';
					buffer[bufp++] = ch;
					buffer[bufp++] = S_QUOTE;
					str = dst;
				} else {
					buffer[bufp++] = *str;
				}
			} else {
				buffer[bufp++] = *str;
			}
		}
		else if (ch == 128) {
			buffer[bufp++] = '\\';
			buffer[bufp++] = '0';
		}
		else if (ch == '\033') {
			buffer[bufp++] = '\\';
			buffer[bufp++] = 'E';
		}
		else if (ch == '\\' && tic_format && (str == srcp || str[-1] != '^')) {
			buffer[bufp++] = '\\';
			buffer[bufp++] = '\\';
		}
		else if (ch == ' ' && tic_format && (str == srcp || trailing_spaces(str))) {
			buffer[bufp++] = '\\';
			buffer[bufp++] = 's';
		}
		else if ((ch == ',' || ch == ':' || ch == '^') && tic_format) {
			buffer[bufp++] = '\\';
			buffer[bufp++] = ch;
		}
		else if (REALPRINT(str) && (ch != ',' && ch != ':' && !(ch == '!' && !tic_format) && ch != '^'))
			buffer[bufp++] = ch;
#if 0		/* FIXME: this would be more readable (in fact the whole 'islong' logic should be removed) */
		else if (ch == '\b') {
			buffer[bufp++] = '\\';
			buffer[bufp++] = 'b';
		}
		else if (ch == '\f') {
			buffer[bufp++] = '\\';
			buffer[bufp++] = 'f';
		}
		else if (ch == '\t' && islong) {
			buffer[bufp++] = '\\';
			buffer[bufp++] = 't';
		}
#endif
		else if (ch == '\r' && (islong || (strlen(srcp) > 2 && str[1] == '\0'))) {
			buffer[bufp++] = '\\';
			buffer[bufp++] = 'r';
		}
		else if (ch == '\n' && islong) {
			buffer[bufp++] = '\\';
			buffer[bufp++] = 'n';
		}
#define UnCtl(c) ((c) + '@@')
		else if (REALCTL(str) && ch != '\\' && (!islong || isdigit(str[1])))
		{
			(void) sprintf(&buffer[bufp], "^%c", UnCtl(ch));
			bufp += 2;
		}
		else
		{
			(void) sprintf(&buffer[bufp], "\\%03o", ch);
			bufp += 4;
		}

		str++;
	}

	buffer[bufp] = '\0';
	return(buffer);
}
@


1.5
log
@update to ncurses 4.2-981017
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_expand.c,v 1.4 1998/09/13 19:16:15 millert Exp $	*/
@


1.4
log
@ncurses-4.2-980905
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_expand.c,v 1.3 1998/08/15 18:44:43 millert Exp $	*/
d40 1
a40 1
MODULE_ID("$From: comp_expand.c,v 1.8 1998/08/15 23:01:54 tom Exp $")
d54 1
a54 1
char *_nc_tic_expand(const char *srcp, bool tic_format)
d75 46
a120 1
			buffer[bufp++] = *str;
@


1.3
log
@fix broken realloc fix from yesterday
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_expand.c,v 1.2 1998/08/14 21:11:38 millert Exp $	*/
d40 1
a40 1
MODULE_ID("$From: comp_expand.c,v 1.7 1998/05/30 23:32:45 Todd.Miller Exp $")
a60 1
char		*nbuffer;
d66 2
a67 8
		length = need;
		nbuffer = buffer ? realloc(buffer, length) : malloc(length);
		if (nbuffer == 0) {
			if (buffer != 0)
				free(buffer);
			return(NULL);
		}
		buffer = nbuffer;
@


1.2
log
@fix realloc usage
@
text
@d1 1
a1 1
/*	$OpenBSD: comp_expand.c,v 1.1 1998/07/23 21:17:25 millert Exp $	*/
d66 9
a74 4
	if (buffer == 0) {
		nbuffer = malloc(length = need);
	} else if (need > length) {
		nbuffer = realloc(buffer, length = need);
a75 6
	if (nbuffer == 0) {
		if (buffer != 0)
			free(buffer);
		return(NULL);
	}
	buffer = nbuffer;
@


1.1
log
@ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 1
d67 1
a67 1
		buffer = malloc(length = need);
d69 1
a69 1
		buffer = realloc(buffer, length = need);
d71 3
a73 1
	if (buffer == 0)
d75 2
@

