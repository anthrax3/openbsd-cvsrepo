head	1.5;
access;
symbols
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	99.01.18.19.08.29;	author millert;	state dead;
branches;
next	1.4;

1.4
date	98.07.23.21.19.24;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.21.31;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.06.05.34;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.5
log
@ncurses-4.2-990116
@
text
@/*	$OpenBSD: lib_slk.c,v 1.4 1998/07/23 21:19:24 millert Exp $	*/

/****************************************************************************
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/

/*
 *	lib_slk.c
 *	Soft key routines.
 */

#include <curses.priv.h>

#include <ctype.h>
#include <term.h>	/* num_labels, label_*, plab_norm */

MODULE_ID("$From: lib_slk.c,v 1.14 1998/02/11 12:13:56 tom Exp $")

/*
 * We'd like to move these into the screen context structure, but cannot,
 * because slk_init() is called before initscr()/newterm().
 */
int _nc_slk_format;  /* one more than format specified in slk_init() */

/*
 * Paint the info line for the PC style SLK emulation.
 *
 */
static void
slk_paint_info(WINDOW *win)
{
  if (win && _nc_slk_format==4)
    {
      int i;

      mvwhline (win,0,0,0,getmaxx(win));
      wmove (win,0,0);

      for (i = 0; i < SP->_slk->maxlab; i++) {
	if (win && _nc_slk_format==4)
	  {
	    mvwaddch(win,0,SP->_slk->ent[i].x,'F');
	    if (i<9)
	      waddch(win,'1'+i);
	    else
	      {
		waddch(win,'1');
		waddch(win,'0' + (i-9));
	      }
	  }
      }
    }
}

/*
 * Initialize soft labels.
 * Called from newterm()
 */
int
_nc_slk_initialize(WINDOW *stwin, int cols)
{
int i, x;
char *p;

	T(("slk_initialize()"));

	if (SP->_slk)
	  { /* we did this already, so simply return */
	    return(OK);
	  }
	else
	  if ((SP->_slk = typeCalloc(SLK, 1)) == 0)
	    return(ERR);

	SP->_slk->ent    = NULL;
	SP->_slk->buffer = NULL;
	SP->_slk->attr   = A_STANDOUT;

#ifdef num_labels
	SP->_slk->maxlab = (num_labels > 0) ? num_labels : MAX_SKEY;
	SP->_slk->maxlen = (num_labels > 0) ? label_width * label_height : MAX_SKEY_LEN;
	SP->_slk->labcnt = (SP->_slk->maxlab < MAX_SKEY) ? MAX_SKEY : SP->_slk->maxlab;
#else
	SP->_slk->labcnt = SP->_slk->maxlab = MAX_SKEY;
	SP->_slk->maxlen = MAX_SKEY_LEN;
#endif /* num_labels */

	SP->_slk->ent = typeCalloc(slk_ent, SP->_slk->labcnt);
	if (SP->_slk->ent == NULL)
	  goto exception;

	p = SP->_slk->buffer = (char*) calloc(2*SP->_slk->labcnt,(1+SP->_slk->maxlen));
	if (SP->_slk->buffer == NULL)
	  goto exception;

	for (i = 0; i < SP->_slk->labcnt; i++) {
		SP->_slk->ent[i].text = p;
		p += (1 + SP->_slk->maxlen);
		SP->_slk->ent[i].form_text = p;
		p += (1 + SP->_slk->maxlen);
		memset(SP->_slk->ent[i].form_text, ' ', (unsigned)(SP->_slk->maxlen));
		SP->_slk->ent[i].visible = (i < SP->_slk->maxlab);
	}
	if (_nc_slk_format >= 3) /* PC style */
	  {
	    int gap = (cols - 3 * (3 + 4*SP->_slk->maxlen))/2;

	    if (gap < 1)
	      gap = 1;

	    for (i = x = 0; i < SP->_slk->maxlab; i++) {
	      SP->_slk->ent[i].x = x;
	      x += SP->_slk->maxlen;
	      x += (i==3 || i==7) ? gap : 1;
	    }
	    if (_nc_slk_format == 4)
	      slk_paint_info (stwin);
	  }
	else {
	  if (_nc_slk_format == 2) {	/* 4-4 */
	    int gap = cols - (SP->_slk->maxlab * SP->_slk->maxlen) - 6;

	    if (gap < 1)
			gap = 1;
	    for (i = x = 0; i < SP->_slk->maxlab; i++) {
	      SP->_slk->ent[i].x = x;
	      x += SP->_slk->maxlen;
	      x += (i == 3) ? gap : 1;
	    }
	  }
	  else
	    {
	      if (_nc_slk_format == 1) { /* 1 -> 3-2-3 */
		int gap = (cols - (SP->_slk->maxlab * SP->_slk->maxlen) - 5) / 2;

		if (gap < 1)
		  gap = 1;
		for (i = x = 0; i < SP->_slk->maxlab; i++) {
		  SP->_slk->ent[i].x = x;
		  x += SP->_slk->maxlen;
		  x += (i == 2 || i == 4) ? gap : 1;
		}
	      }
	      else
		goto exception;
	    }
	}
	SP->_slk->dirty = TRUE;
	if ((SP->_slk->win = stwin) == NULL)
	{
	exception:
		if (SP->_slk)
		{
		   FreeIfNeeded(SP->_slk->buffer);
		   FreeIfNeeded(SP->_slk->ent);
		   free(SP->_slk);
		   SP->_slk = (SLK*)0;
		   return(ERR);
		}
	}

	return(OK);
}


/*
 * Restore the soft labels on the screen.
 */
int
slk_restore(void)
{
	T((T_CALLED("slk_restore()")));

	if (SP->_slk == NULL)
		return(ERR);
	SP->_slk->hidden = FALSE;
	SP->_slk->dirty = TRUE;
	/* we have to repaint info line eventually */
	slk_paint_info(SP->_slk->win);

	returnCode(slk_refresh());
}
@


1.4
log
@ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3
log
@Merge of ncurses-4.1-971129
@
text
@d3 27
d31 4
a34 19
/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d46 1
a46 1
MODULE_ID("Id: lib_slk.c,v 1.13 1997/10/18 18:10:12 tom Exp $")
@


1.2
log
@ncurses 4.1 + changes to work with our terminfo libs (instead of
the ncurses ones).  Changes are #ifdef EXTERN_TERMINFO.
Post 4.1 patches will be applied in a separate commit.
@
text
@d1 2
d34 1
a34 6
MODULE_ID("Id: lib_slk.c,v 1.11 1997/01/18 23:06:32 tom Exp $")

#define MAX_SKEY_OLD	   8	/* count of soft keys */
#define MAX_SKEY_LEN_OLD   8	/* max length of soft key text */
#define MAX_SKEY_PC       12    /* This is what most PC's have */
#define MAX_SKEY_LEN_PC    5
a35 2
#define MAX_SKEY      (SLK_STDFMT ? MAX_SKEY_OLD : MAX_SKEY_PC)
#define MAX_SKEY_LEN  (SLK_STDFMT ? MAX_SKEY_LEN_OLD : MAX_SKEY_LEN_PC)
d40 1
a40 215
int _nc_slk_format;			/* one more than format specified in slk_init() */

static chtype _slk_attr = A_STANDOUT;	/* soft label attribute */
static SLK *_slk;
static void slk_paint_info(WINDOW *win);

/*
 * Fetch the label text.
 */

char *
slk_label(int n)
{
	T(("slk_label(%d)", n));

	if (SP->_slk == NULL || n < 1 || n > SP->_slk->labcnt)
		return NULL;
	return(SP->_slk->ent[n-1].text);
}

/*
 * Write the soft labels to the soft-key window.
 */

static void
slk_intern_refresh(SLK *slk)
{
int i;
	for (i = 0; i < slk->labcnt; i++) {
		if (slk->dirty || slk->ent[i].dirty) {
			if (slk->ent[i].visible) {
#ifdef num_labels
				if (num_labels > 0 && SLK_STDFMT)
				{
				  if (i < num_labels) {
				    TPUTS_TRACE("plab_norm");
				    putp(tparm(plab_norm, i, slk->win,slk->ent[i].form_text));
				  }
				}
				else
#endif /* num_labels */
				{
					wmove(slk->win,SLK_LINES-1,slk->ent[i].x);
					wattrset(slk->win,_slk_attr);
					waddnstr(slk->win,slk->ent[i].form_text, MAX_SKEY_LEN);
					/* if we simulate SLK's, it's looking much more
					   natural to use the current ATTRIBUTE also
					   for the label window */
					wattrset(slk->win,stdscr->_attrs);
				}
			}
			slk->ent[i].dirty = FALSE;
		}
	}
	slk->dirty = FALSE;

#ifdef num_labels
	if (num_labels > 0)
	    if (slk->hidden)
	    {
		TPUTS_TRACE("label_off");
		putp(label_off);
	    }
	    else
	    {
		TPUTS_TRACE("label_on");
		putp(label_on);
	    }
#endif /* num_labels */
}

/*
 * Refresh the soft labels.
 */

int
slk_noutrefresh(void)
{
	T(("slk_noutrefresh()"));

	if (SP->_slk == NULL)
		return(ERR);
	if (SP->_slk->hidden)
		return(OK);
	slk_intern_refresh(SP->_slk);
	return(wnoutrefresh(SP->_slk->win));
}

/*
 * Refresh the soft labels.
 */

int
slk_refresh(void)
{
	T(("slk_refresh()"));

	if (SP->_slk == NULL)
		return(ERR);
	if (SP->_slk->hidden)
		return(OK);
	slk_intern_refresh(SP->_slk);
	return(wrefresh(SP->_slk->win));
}

/*
 * Restore the soft labels on the screen.
 */

int
slk_restore(void)
{
	T(("slk_restore()"));

	if (SP->_slk == NULL)
		return(ERR);
	SP->_slk->hidden = FALSE;
	SP->_slk->dirty = TRUE;
	/* we have to repaint info line eventually */
	slk_paint_info(SP->_slk->win); 
	return slk_refresh();
}

/*
 * Set soft label text.
 */

int
slk_set(int i, const char *astr, int format)
{
SLK *slk = SP->_slk;
size_t len;
const char *str = astr;
const char *p;

	T(("slk_set(%d, \"%s\", %d)", i, str, format));

	if (slk == NULL || i < 1 || i > slk->labcnt || format < 0 || format > 2)
		return(ERR);
	if (str == NULL)
		str = "";

	while (isspace(*str)) str++; /* skip over leading spaces  */
	p = str;
	while (isprint(*p)) p++;     /* The first non-print stops */

	--i; /* Adjust numbering of labels */

	len = (size_t)(p - str);
	if (len > (unsigned)slk->maxlen)
	  len = slk->maxlen;
	if (len==0)
	  slk->ent[i].text[0] = 0;
	else
	  (void) strncpy(slk->ent[i].text, str, len);
	memset(slk->ent[i].form_text,' ', (unsigned)slk->maxlen);
	slk->ent[i].text[slk->maxlen] = 0;
	/* len = strlen(slk->ent[i].text); */

	switch(format) {
	case 0: /* left-justified */
		memcpy(slk->ent[i].form_text,
		       slk->ent[i].text,
		       len);
		break;
	case 1: /* centered */
		memcpy(slk->ent[i].form_text+(slk->maxlen - len)/2,
		       slk->ent[i].text,
		       len);
		break;
	case 2: /* right-justified */
		memcpy(slk->ent[i].form_text+ slk->maxlen - len,
		       slk->ent[i].text,
		       len);
		break;
	}
	slk->ent[i].form_text[slk->maxlen] = 0;
	slk->ent[i].dirty = TRUE;
	return(OK);
}

/*
 * Force the code to believe that the soft keys have been changed.
 */

int
slk_touch(void)
{
	T(("slk_touch()"));

	if (SP->_slk == NULL)
		return(ERR);
	SP->_slk->dirty = TRUE;
	return(OK);
}

/*
 * Remove soft labels from the screen.
 */

int
slk_clear(void)
{
	T(("slk_clear()"));

	if (SP->_slk == NULL)
		return(ERR);
	SP->_slk->hidden = TRUE;
	/* For simulated SLK's it's looks much more natural to
	   inherit those attributes from the standard screen */
	SP->_slk->win->_bkgd  = stdscr->_bkgd;
	SP->_slk->win->_attrs = stdscr->_attrs;
	werase(SP->_slk->win);
	return wrefresh(SP->_slk->win);
}
d44 1
a44 1
 * 
a45 1

d52 1
a52 1
  
d55 2
a56 2
      
      for (i = 0; i < _slk->maxlab; i++) {
d59 1
a59 1
	    mvwaddch(win,0,_slk->ent[i].x,'F');
a75 1

d84 1
a84 1
	if (_slk)
a85 1
	    SP->_slk = _slk;
d89 1
a89 1
	  if ((SP->_slk = _slk = typeCalloc(SLK, 1)) == 0)
d92 3
a94 2
	_slk->ent = NULL;
	_slk->buffer = NULL;
d97 3
a99 3
	_slk->maxlab = (num_labels > 0) ? num_labels : MAX_SKEY;
	_slk->maxlen = (num_labels > 0) ? label_width * label_height : MAX_SKEY_LEN;
	_slk->labcnt = (_slk->maxlab < MAX_SKEY) ? MAX_SKEY : _slk->maxlab;
d101 2
a102 2
	_slk->labcnt = _slk->maxlab = MAX_SKEY;
	_slk->maxlen = MAX_SKEY_LEN;
d105 2
a106 2
	_slk->ent = typeCalloc(slk_ent, _slk->labcnt);
	if (_slk->ent == NULL)
d109 2
a110 2
	p = _slk->buffer = (char*) calloc(2*_slk->labcnt,(1+_slk->maxlen));
	if (_slk->buffer == NULL)
d113 7
a119 7
	for (i = 0; i < _slk->labcnt; i++) {
		_slk->ent[i].text = p;
		p += (1 + _slk->maxlen);
		_slk->ent[i].form_text = p;
		p += (1 + _slk->maxlen);
		memset(_slk->ent[i].form_text, ' ', (unsigned)_slk->maxlen);
		_slk->ent[i].visible = (i < _slk->maxlab);
d123 1
a123 1
	    int gap = (cols - 3 * (3 + 4*_slk->maxlen))/2;
d128 3
a130 3
	    for (i = x = 0; i < _slk->maxlab; i++) {
	      _slk->ent[i].x = x;
	      x += _slk->maxlen;
d138 1
a138 1
	    int gap = cols - (_slk->maxlab * _slk->maxlen) - 6;
d142 3
a144 3
	    for (i = x = 0; i < _slk->maxlab; i++) {
	      _slk->ent[i].x = x;
	      x += _slk->maxlen;
d151 1
a151 1
		int gap = (cols - (_slk->maxlab * _slk->maxlen) - 5) / 2;
d155 3
a157 3
		for (i = x = 0; i < _slk->maxlab; i++) {
		  _slk->ent[i].x = x;
		  x += _slk->maxlen;
d165 2
a166 2
	_slk->dirty = TRUE;
	if ((_slk->win = stwin) == NULL)
d169 1
a169 1
		if (_slk)
d171 4
a174 4
		   FreeIfNeeded(_slk->buffer);
		   FreeIfNeeded(_slk->ent);
		   free(_slk);
		   SP->_slk = _slk = (SLK*)0;
d182 1
d184 1
a184 1
 * Initialize soft labels.  Called by the user before initscr().
a185 1

d187 1
a187 1
slk_init(int format)
d189 3
a191 1
	if (format < 0 || format > 3)
d193 4
a196 26
	_nc_slk_format = 1 + format;
	return(OK);
}

/* Functions to manipulate the soft-label attribute */

int
slk_attrset(const attr_t attr)
{
    _slk_attr = attr;
    return(OK);
}

int
slk_attron(const attr_t attr)
{
    toggle_attr_on(_slk_attr,attr);
    return(OK);
}

int
slk_attroff(const attr_t attr)
{
    toggle_attr_off(_slk_attr,attr);
    return(OK);
}
d198 1
a198 4
attr_t
slk_attr(void)
{
  return _slk_attr;
@


1.1
log
@Install ncurses as -lcurses and <curses.h>
Install BSD curses library as -locurses and <ocurses.h>
@
text
@d27 1
a27 4
#include "curses.priv.h"
#include <string.h>
#include <stdlib.h>
#include "term.h"	/* num_labels, label_*, plab_norm */
d29 2
a30 2
#define MAX_SKEY	8	/* count of soft keys */
#define MAX_SKEY_LEN	8	/* max length of soft key text */
d32 9
d45 1
a45 1
int	_slk_init;			/* TRUE if slk_init() called */
a46 1
static int _slk_format;			/* format specified in slk_init() */
d48 2
a49 2
static int maxlab;			/* number of labels */
static int maxlen;			/* maximum length of label */
d60 1
a60 1
	if (SP->_slk == NULL || n < 1 || n > MAX_SKEY)
d73 1
a73 1
	for (i = 0; i < MAX_SKEY; i++) {
d77 1
a77 1
				if (num_labels > 0)
d79 4
a82 2
					TPUTS_TRACE("plab_norm");
					putp(tparm(plab_norm, i, slk->win,slk->ent[i].form_text));
d87 1
a87 1
					wmove(slk->win,0,slk->ent[i].x);
d89 5
a93 2
					waddstr(slk->win,slk->ent[i].form_text);
					wattrset(slk->win,A_NORMAL);
d124 1
a124 1
	
d141 1
a141 1
	
d158 1
a158 1
	
d163 2
d178 1
d182 1
a182 1
	if (slk == NULL || i < 1 || i > maxlab || format < 0 || format > 2)
d186 17
a202 6
	--i;
	(void) strncpy(slk->ent[i].text, str, (unsigned)maxlen);
	memset(slk->ent[i].form_text,' ', (unsigned)maxlen);
	slk->ent[i].text[maxlen] = 0;
	slk->ent[i].form_text[maxlen] = 0;
	len = strlen(slk->ent[i].text);
d211 1
a211 1
		memcpy(slk->ent[i].form_text+(MAX_SKEY_LEN-len)/2,
d216 1
a216 1
		memcpy(slk->ent[i].form_text+MAX_SKEY_LEN-len,
d221 1
d234 1
a234 1
	
d249 1
a249 1
	
d253 4
d262 31
d298 1
a298 1
slk_initialize(WINDOW *stwin, int cols)
a299 1
SLK *slk;
d301 1
d305 11
a315 2
	if ((SP->_slk = slk = (SLK*) calloc(1,sizeof(SLK))) == NULL)
		return(OK);
d318 3
a320 2
	maxlab = (num_labels > 0) ? num_labels : MAX_SKEY;
	maxlen = (num_labels > 0) ? label_width * label_height : MAX_SKEY_LEN;
d322 2
a323 2
	maxlab = MAX_SKEY;
	maxlen = MAX_SKEY_LEN;
d326 15
a340 3
	for (i = 0; i < MAX_SKEY; i++) {
		memset(slk->ent[i].form_text, ' ', (unsigned)maxlen);
		slk->ent[i].visible = i < maxlab;
d342 18
a359 2
	if (_slk_format == 1) {	/* 4-4 */
		int gap = cols - (MAX_SKEY * MAX_SKEY_LEN) - 6;
d361 1
a361 1
		if (gap < 1)
d363 10
a372 8
		for (i = x = 0; i < MAX_SKEY; i++) {
			slk->ent[i].x = x;
		x += MAX_SKEY_LEN;
		x += (i == 3) ? gap : 1;
		}
	}
	else {			/* 0 -> 3-2-3 */
		int gap = (cols - (MAX_SKEY * MAX_SKEY_LEN) - 5) / 2;
d375 5
a379 5
			gap = 1;
		for (i = x = 0; i < MAX_SKEY; i++) {
			slk->ent[i].x = x;
			x += MAX_SKEY_LEN;
			x += (i == 2 || i == 4) ? gap : 1;
d381 4
d386 2
a387 2
	slk->dirty = TRUE;
	if ((slk->win = stwin) == NULL)
d389 9
a397 2
		free(slk);
		return(ERR);
d410 1
a410 1
	if (format < 0 || format > 1)
d412 1
a412 2
	_slk_format = format;
	_slk_init = TRUE;
d418 2
a419 2
int 
slk_attrset(attr_t attr)
d425 2
a426 2
int 
slk_attron(attr_t attr)
d428 1
a428 1
    _slk_attr |= attr;
d432 2
a433 2
int 
slk_attroff(attr_t attr)
d435 1
a435 1
    _slk_attr &=~ attr;
d439 5
@
