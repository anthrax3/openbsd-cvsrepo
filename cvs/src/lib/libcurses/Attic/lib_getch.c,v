head	1.8;
access;
symbols
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	99.01.18.19.07.53;	author millert;	state dead;
branches;
next	1.7;

1.7
date	98.10.31.06.30.29;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.07.23.21.18.47;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.01.17.16.27.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.12.06.19.11.04;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.21.18;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.35;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.06.05.24;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.8
log
@ncurses-4.2-990116
@
text
@/*	$OpenBSD: lib_getch.c,v 1.7 1998/10/31 06:30:29 millert Exp $	*/

/****************************************************************************
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/

/*
**	lib_getch.c
**
**	The routine getch().
**
*/

#include <curses.priv.h>

MODULE_ID("$From: lib_getch.c,v 1.41 1998/09/26 23:34:53 tom Exp $")

#include <fifo_defs.h>

int ESCDELAY = 1000;	/* max interval betw. chars in funkeys, in millisecs */

#ifdef USE_EMX_MOUSE
#  include <sys/select.h>
static int
kbd_mouse_read(unsigned char *p)
{
fd_set fdset;
int nums = SP->_ifd+1;

	for (;;) {
		FD_ZERO(&fdset);
		FD_SET(SP->_checkfd, &fdset);
		if (SP->_mouse_fd >= 0) {
			FD_SET(SP->_mouse_fd, &fdset);
			if (SP->_mouse_fd > SP->_checkfd)
				nums = SP->_mouse_fd+1;
		}
		if (select(nums, &fdset, NULL, NULL, NULL) >= 0) {
			int n;

			if (FD_ISSET(SP->_mouse_fd, &fdset)) /* Prefer mouse */
				n = read(SP->_mouse_fd, p, 1);
			else
				n = read(SP->_ifd, p, 1);
			return n;
		}
		if (errno != EINTR)
			return -1;
	}
}
#endif  /* USE_EMX_MOUSE */

static inline int fifo_peek(void)
{
	int ch = SP->_fifo[peek];
	T(("peeking at %d", peek));

	p_inc();
	return ch;
}


static inline int fifo_pull(void)
{
int ch;
	ch = SP->_fifo[head];
	T(("pulling %d from %d", ch, head));

	if (peek == head)
	{
	    h_inc();
	    peek = head;
	}
	else
	    h_inc();

#ifdef TRACE
	if (_nc_tracing & TRACE_IEVENT) _nc_fifo_dump();
#endif
	return ch;
}

static inline int fifo_push(void)
{
int n;
unsigned int ch;

	if (tail == -1) return ERR;

#ifdef HIDE_EINTR
again:
	errno = 0;
#endif

#if USE_GPM_SUPPORT
	if ((SP->_mouse_fd >= 0)
	 && (_nc_timed_wait(3, -1, (int *)0) & 2))
	{
		SP->_mouse_event(SP);
		ch = KEY_MOUSE;
		n = 1;
	} else
#endif
	{
		unsigned char c2=0;
#ifdef USE_EMX_MOUSE
		n = kbd_mouse_read(&c2);
#else
		n = read(SP->_ifd, &c2, 1);
#endif
		ch = c2 & 0xff;
	}

#ifdef HIDE_EINTR
	/*
	 * Under System V curses with non-restarting signals, getch() returns
	 * with value ERR when a handled signal keeps it from completing.
	 * If signals restart system calls, OTOH, the signal is invisible
	 * except to its handler.
	 *
	 * We don't want this difference to show.  This piece of code
	 * tries to make it look like we always have restarting signals.
	 */
	if (n <= 0 && errno == EINTR)
		goto again;
#endif

	if ((n == -1) || (n == 0))
	{
	    T(("read(%d,&ch,1)=%d, errno=%d", SP->_ifd, n, errno));
	    return ERR;
	}
	T(("read %d characters", n));

	SP->_fifo[tail] = ch;
	SP->_fifohold = 0;
	if (head == -1)
	    head = peek = tail;
	t_inc();
	T(("pushed %#x at %d", ch, tail));
#ifdef TRACE
	if (_nc_tracing & TRACE_IEVENT) _nc_fifo_dump();
#endif
	return ch;
}

static inline void fifo_clear(void)
{
int i;
	for (i = 0; i < FIFO_SIZE; i++)
		SP->_fifo[i] = 0;
	head = -1; tail = peek = 0;
}

static int kgetch(WINDOW *);

#define wgetch_should_refresh(win) (\
	(is_wintouched(win) || (win->_flags & _HASMOVED)) \
	&& !(win->_flags & _ISPAD))

int
wgetch(WINDOW *win)
{
int	ch;

	T((T_CALLED("wgetch(%p)"), win));

	if (!win)
	  returnCode(ERR);

	if (cooked_key_in_fifo())
	{
		if (wgetch_should_refresh(win))
			wrefresh(win);

		ch = fifo_pull();
		T(("wgetch returning (pre-cooked): %#x = %s", ch, _trace_key(ch));)
		returnCode(ch);
	}

	/*
	 * Handle cooked mode.  Grab a string from the screen,
	 * stuff its contents in the FIFO queue, and pop off
	 * the first character to return it.
	 */
	if (head == -1 && !SP->_raw && !SP->_cbreak)
	{
		char	buf[MAXCOLUMNS], *sp;

		T(("filling queue in cooked mode"));

		wgetnstr(win, buf, MAXCOLUMNS);

		/* ungetch in reverse order */
		ungetch('\n');
		for (sp = buf+strlen(buf); sp>buf; sp--)
			ungetch(sp[-1]);

		returnCode(fifo_pull());
	}

	if (wgetch_should_refresh(win))
		wrefresh(win);

	if (!win->_notimeout && (win->_delay >= 0 || SP->_cbreak > 1)) {
	int delay;

		T(("timed delay in wgetch()"));
		if (SP->_cbreak > 1)
		    delay = (SP->_cbreak - 1) * 100;
		else
		    delay = win->_delay;

		T(("delay is %d milliseconds", delay));

		if (head == -1)	/* fifo is empty */
			if (!_nc_timed_wait(3, delay, (int *)0))
				returnCode(ERR);
		/* else go on to read data available */
	}

	if (win->_use_keypad) {
		/*
		 * This is tricky.  We only want to get special-key
		 * events one at a time.  But we want to accumulate
		 * mouse events until either (a) the mouse logic tells
		 * us it's picked up a complete gesture, or (b)
		 * there's a detectable time lapse after one.
		 *
		 * Note: if the mouse code starts failing to compose
		 * press/release events into clicks, you should probably
		 * increase the wait with mouseinterval().
		 */
		int runcount = 0;

		do {
			ch = kgetch(win);
			if (ch == KEY_MOUSE)
			{
				++runcount;
				if (SP->_mouse_inline(SP))
				    break;
			}
		} while
		    (ch == KEY_MOUSE
		     && (_nc_timed_wait(3, SP->_maxclick, (int *)0)
			 || !SP->_mouse_parse(runcount)));
		if (runcount > 0 && ch != KEY_MOUSE)
		{
		    /* mouse event sequence ended by keystroke, push it */
		    ungetch(ch);
		    ch = KEY_MOUSE;
		}
	} else {
		if (head == -1)
			fifo_push();
		ch = fifo_pull();
	}

	if (ch == ERR)
	{
#if USE_SIZECHANGE
	    if(SP->_sig_winch)
	    {
		_nc_update_screensize();
		/* resizeterm can push KEY_RESIZE */
		if(cooked_key_in_fifo())
		{
		    ch = fifo_pull();
		    T(("wgetch returning (pre-cooked): %#x = %s", ch, _trace_key(ch));)
		    returnCode(ch);
		}
	    }
#endif
	    T(("wgetch returning ERR"));
	    returnCode(ERR);
	}

	/*
	 * Simulate ICRNL mode
	 */
	if ((ch == '\r') && SP->_nl)
		ch = '\n';

	/* Strip 8th-bit if so desired.  We do this only for characters that
	 * are in the range 128-255, to provide compatibility with terminals
	 * that display only 7-bit characters.  Note that 'ch' may be a
	 * function key at this point, so we mustn't strip _those_.
	 */
	if ((ch < KEY_MIN) && (ch & 0x80))
		if (!SP->_use_meta)
			ch &= 0x7f;

	if (SP->_echo && ch < KEY_MIN && !(win->_flags & _ISPAD))
		wechochar(win, (chtype)ch);

	T(("wgetch returning : %#x = %s", ch, _trace_key(ch)));

	returnCode(ch);
}


/*
**      int
**      kgetch()
**
**      Get an input character, but take care of keypad sequences, returning
**      an appropriate code when one matches the input.  After each character
**      is received, set an alarm call based on ESCDELAY.  If no more of the
**      sequence is received by the time the alarm goes off, pass through
**      the sequence gotten so far.
**
**	This function must be called when there is no cooked keys in queue.
**	(that is head==-1 || peek==head)
**
*/

static int
kgetch(WINDOW *win GCC_UNUSED)
{
struct tries  *ptr;
int ch = 0;
int timeleft = ESCDELAY;

	TR(TRACE_IEVENT, ("kgetch(%p) called", win));

	ptr = SP->_keytry;

	for(;;)
	{
		if (!raw_key_in_fifo())
		{
		    if(fifo_push() == ERR)
		    {
			peek = head;	/* the keys stay uninterpreted */
			return ERR;
		    }
		}
		ch = fifo_peek();
		if (ch >= KEY_MIN)
		{
		    peek = head;
		    /* assume the key is the last in fifo */
		    t_dec(); /* remove the key */
		    return ch;
		}

		TR(TRACE_IEVENT, ("ch: %s", _trace_key((unsigned char)ch)));
		while ((ptr != NULL) && (ptr->ch != (unsigned char)ch))
			ptr = ptr->sibling;
#ifdef TRACE
		if (ptr == NULL)
			{TR(TRACE_IEVENT, ("ptr is null"));}
		else
			TR(TRACE_IEVENT, ("ptr=%p, ch=%d, value=%d",
					ptr, ptr->ch, ptr->value));
#endif /* TRACE */

		if (ptr == NULL)
			break;

		if (ptr->value != 0) {	/* sequence terminated */
			TR(TRACE_IEVENT, ("end of sequence"));
			if (peek == tail)
			    fifo_clear();
			else
			    head = peek;
			return(ptr->value);
		}

		ptr = ptr->child;

		if (!raw_key_in_fifo())
		{
			TR(TRACE_IEVENT, ("waiting for rest of sequence"));
			if (!_nc_timed_wait(3, timeleft, &timeleft)) {
				TR(TRACE_IEVENT, ("ran out of time"));
				break;
			}
		}
	}
	ch = fifo_pull();
	peek = head;
	return ch;
}
@


1.7
log
@update to ncurses 4.2-981017
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.6 1998/07/23 21:18:47 millert Exp $	*/
@


1.6
log
@ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
MODULE_ID("$From: lib_getch.c,v 1.40 1998/02/11 12:13:58 tom Exp $")
d51 31
d86 1
a86 1
	
d105 1
a105 1
	    
d124 2
a125 2
#if USE_GPM_SUPPORT	
	if ((SP->_mouse_fd >= 0) 
d135 3
d139 2
a140 1
		ch = c2;
d146 1
a146 1
	 * with value ERR when a handled signal keeps it from completing.  
d149 1
a149 1
	 * 
@


1.5
log
@Use _ti_get_screensize() from libtermlib to update screen size if changed
    after a program is suspended.
Define EXTERN_TERMINFO in curses.h.
Update to ncurses-4.1-980103 and crank minor.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.4 1997/12/06 19:11:04 millert Exp $	*/
d3 32
a34 20

/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d45 1
a45 1
MODULE_ID("Id: lib_getch.c,v 1.38 1997/12/20 22:22:57 tom Exp $")
d171 1
a171 1
    		T(("wgetch returning (pre-cooked): %#x = %s", ch, _trace_key(ch));)
d291 1
a291 1
	T(("wgetch returning : %#x = %s", ch, _trace_key(ch));)
@


1.4
log
@#ifdef out call to _nc_update_screensize
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_getch.c,v 1.3 1997/12/03 05:21:18 millert Exp $	*/
d33 1
a33 1
MODULE_ID("Id: lib_getch.c,v 1.37 1997/11/30 00:37:38 tom Exp $")
d244 1
a246 1
#ifndef EXTERN_TERMINFO
a247 1
#endif
d256 1
@


1.3
log
@Merge of ncurses-4.1-971129
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d246 1
d248 1
@


1.2
log
@ncurses 4.1 + changes to work with our terminfo libs (instead of
the ncurses ones).  Changes are #ifdef EXTERN_TERMINFO.
Post 4.1 patches will be applied in a separate commit.
@
text
@d1 2
d33 1
a33 1
MODULE_ID("Id: lib_getch.c,v 1.24 1997/02/15 21:12:16 tom Exp $")
d35 1
a35 8
#define head	SP->_fifohead
#define tail	SP->_fifotail
#define peek	SP->_fifopeek

#define h_inc() { head == FIFO_SIZE-1 ? head = 0 : head++; if (head == tail) head = -1, tail = 0;}
#define h_dec() { head == 0 ?  head = FIFO_SIZE-1 : head--; if (head == tail) tail = -1;}
#define t_inc() { tail == FIFO_SIZE-1 ? tail = 0 : tail++; if (tail == head) tail = -1;}
#define p_inc() { peek == FIFO_SIZE-1 ? peek = 0 : peek++;}
d39 1
a39 1
static int fifo_peek(void)
d41 5
a45 2
	T(("peeking at %d", peek+1));
	return SP->_fifo[++peek];
a47 9
#ifdef TRACE
static inline void fifo_dump(void)
{
int i;
	T(("head = %d, tail = %d, peek = %d", head, tail, peek));
	for (i = 0; i < 10; i++)
		T(("char %d = %s", i, _trace_key(SP->_fifo[i])));
}
#endif /* TRACE */
d55 8
a62 1
	h_inc();
d64 1
a64 1
	if (_nc_tracing & TRACE_IEVENT) fifo_dump();
a68 18
int ungetch(int ch)
{
	if (tail == -1)
		return ERR;
	if (head == -1) {
		head = 0;
		t_inc()
	} else
		h_dec();

	SP->_fifo[head] = ch;
	T(("ungetch ok"));
#ifdef TRACE
	if (_nc_tracing & TRACE_IEVENT) fifo_dump();
#endif
	return OK;
}

d75 2
a76 1
	/* FALLTHRU */
d79 2
d82 1
a82 1
	if ((_nc_mouse_fd() >= 0) 
d85 1
a85 1
		_nc_mouse_event(SP);
d91 1
a91 1
		unsigned char c2;
d96 1
d108 1
d112 1
a112 1
	    T(("read(%d,&ch,1)=%d", SP->_ifd, n));
d118 3
a120 1
	if (head == -1) head = tail;
d124 1
a124 1
	if (_nc_tracing & TRACE_IEVENT) fifo_dump();
d139 3
a141 28
void _nc_backspace(WINDOW *win)
{
	if (win->_curx == 0)
	{
	    beep();
	    return;
	}

	mvwaddstr(curscr, win->_begy + win->_cury + win->_yoffset,
		  win->_begx + win->_curx, "\b \b");
	waddstr(win, "\b \b");

	/*
	 * This used to do the equivalent of _nc_outstr("\b \b"), which
	 * would fail on terminals with a non-backspace cursor_left
	 * character.
	 */
	mvcur(win->_begy + win->_cury + win->_yoffset,
	      win->_begx + win->_curx,
	      win->_begy + win->_cury + win->_yoffset,
	      win->_begx + win->_curx - 1);
	_nc_outstr(" ");
	mvcur(win->_begy + win->_cury + win->_yoffset,
	      win->_begx + win->_curx,
	      win->_begy + win->_cury + win->_yoffset,
	      win->_begx + win->_curx - 1);
	SP->_curscol--;
}
d150 13
d176 1
a176 2
		for (sp = buf; *sp; sp++)
			ungetch(*sp);
d178 2
d181 1
a181 1
		return(fifo_pull());
d184 1
a184 10
	/* this should be eliminated */
	if (!has_ic()
	 && !win->_scroll
	 &&  (SP->_echo)
	 &&  (win->_flags & _FULLWIN)
	 &&  win->_curx == win->_maxx
	 &&  win->_cury == win->_maxy)
		returnCode(ERR);

	if ((is_wintouched(win) || (win->_flags & _HASMOVED)) && !(win->_flags & _ISPAD))
d192 1
a192 1
		    delay = (SP->_cbreak-1) * 100;
d196 1
a196 1
		T(("delay is %d microseconds", delay));
d214 1
a214 1
		 * increase _nc_max_click_interval.
d223 1
a223 1
				if (_nc_mouse_inline(SP))
d228 2
a229 2
		     && (_nc_timed_wait(3, _nc_max_click_interval, (int *)0)
			 || !_nc_mouse_parse(runcount)));
d244 11
d274 2
a275 14
	if (!(win->_flags & _ISPAD) && SP->_echo) {
	    /* there must be a simpler way of doing this */
	    if (ch == erasechar() || ch == KEY_BACKSPACE || ch == KEY_LEFT)
		_nc_backspace(win);
	    else if (ch < KEY_MIN) {
		mvwaddch(curscr,
			 win->_begy + win->_cury + win->_yoffset,
			 win->_begx + win->_curx,
			 ch);
		waddch(win, (chtype)ch);
	    }
	    else
		beep();
	}
d293 3
d309 22
a330 8
	if (head == -1)  {
		if ((ch = fifo_push()) == ERR)
		    return ERR;
		peek = 0;
		while (ptr != NULL) {
			TR(TRACE_IEVENT, ("ch: %s", _trace_key((unsigned char)ch)));
			while ((ptr != NULL) && (ptr->ch != (unsigned char)ch))
				ptr = ptr->sibling;
d332 14
a345 2
			if (ptr == NULL)
				{TR(TRACE_IEVENT, ("ptr is null"));}
d347 5
a351 3
				TR(TRACE_IEVENT, ("ptr=%p, ch=%d, value=%d",
						ptr, ptr->ch, ptr->value));
#endif /* TRACE */
d353 7
a359 20
			if (ptr != NULL)
				if (ptr->value != 0) {	/* sequence terminated */
					TR(TRACE_IEVENT, ("end of sequence"));
					fifo_clear();
					return(ptr->value);
				} else {		/* go back for another character */
					ptr = ptr->child;
					TR(TRACE_IEVENT, ("going back for more"));
				} else
					break;

				TR(TRACE_IEVENT, ("waiting for rest of sequence"));
				if (!_nc_timed_wait(3, timeleft, &timeleft)) {
					TR(TRACE_IEVENT, ("ran out of time"));
					return(fifo_pull());
				} else {
					TR(TRACE_IEVENT, ("got more!"));
					fifo_push();
					ch = fifo_peek();
				}
d362 3
a364 1
	return(fifo_pull());
@


1.1
log
@Install ncurses as -lcurses and <curses.h>
Install BSD curses library as -locurses and <ocurses.h>
@
text
@d29 3
a31 7
#include "curses.priv.h"
#include <sys/types.h>
#include <string.h>
#include <errno.h>
#if !HAVE_EXTERN_ERRNO
extern int errno;
#endif
d51 1
a51 1
static __inline void fifo_dump(void)
d56 1
a56 1
		T(("char %d = %s", i, _tracechar(SP->_fifo[i])));
d60 1
a60 1
static __inline int fifo_pull(void)
d63 1
a63 1
 	ch = SP->_fifo[head];
d68 1
a68 1
	if (_nc_tracing & TRACE_FIFO) fifo_dump();
d82 1
a82 1
	
d86 1
a86 1
	if (_nc_tracing & TRACE_FIFO) fifo_dump();
d91 1
a91 1
static __inline int fifo_push(void)
d94 1
a94 1
unsigned char ch;
d98 27
a124 3
again:    
	n = read(SP->_ifd, &ch, 1);
	if (n == -1 && errno == EINTR)
d126 6
d139 1
a139 1
	if (_nc_tracing & TRACE_FIFO) fifo_dump();
d144 1
a144 1
static __inline void fifo_clear(void)
d162 2
a163 1
	mvwaddstr(curscr, win->_begy + win->_cury, win->_begx + win->_curx, "\b \b");
d171 4
a174 2
	mvcur(win->_begy + win->_cury, win->_begx + win->_curx,
	      win->_begy + win->_cury, win->_begx + win->_curx - 1);
d176 5
a180 3
	mvcur(win->_begy + win->_cury, win->_begx + win->_curx,
	      win->_begy + win->_cury, win->_begx + win->_curx - 1);
	SP->_curscol--; 
d186 14
a199 2
bool	setHere = FALSE;	/* cbreak mode was set here */
int	ch; 
d201 8
a208 1
	T(("wgetch(%p) called", win));
d211 7
a217 3
	if (! win->_scroll  &&  (SP->_echo) &&  (win->_flags & _FULLWIN)
	   &&  win->_curx == win->_maxx &&  win->_cury == win->_maxy)
		return(ERR);
a221 5
	if (SP->_echo  &&  ! (SP->_raw  ||  SP->_cbreak)) {
		cbreak();
		setHere = TRUE;
	}

d234 2
a235 2
			if (_nc_timed_wait(SP->_ifd, delay, NULL) == 0)
				return ERR;
d239 2
a240 8
	/*
	 * Give the mouse interface a chance to pick up an event.
	 * If no mouse event, check for keyboard input.
	 */
	if (_nc_mouse_event(SP))
		ch = KEY_MOUSE;
	else if (win->_use_keypad) {
	        /* 
d249 1
a249 1
		 * increase _nc_max_click_interval.  
d251 1
a251 1
	    	int runcount = 0;
d263 1
a263 1
		     && (_nc_timed_wait(SP->_ifd, _nc_max_click_interval, NULL)
d277 12
d298 1
a298 1
        if (!(win->_flags & _ISPAD) && SP->_echo) {
d304 4
a307 4
			 win->_begy + win->_cury,
                         win->_begx + win->_curx,
			 (chtype)(ch | win->_attrs));
		waddch(win, (chtype)(ch | win->_attrs));
a311 2
	if (setHere)
	    nocbreak();
d313 1
a313 3
	T(("wgetch returning : 0x%x = %s",
	   ch,
	   (ch > KEY_MIN) ? keyname(ch) : unctrl(ch)));
d315 1
a315 1
	return(ch);
d332 1
a332 1
kgetch(WINDOW *win)
d334 1
a334 1
struct try  *ptr;
d338 1
a338 1
    	TR(TRACE_FIFO, ("kgetch(%p) called", win));
d340 1
a340 1
    	ptr = SP->_keytry;
d343 2
a344 1
		ch = fifo_push();
d346 2
a347 2
    		while (ptr != NULL) {
			TR(TRACE_FIFO, ("ch: %s", _tracechar((unsigned char)ch)));
d352 1
a352 1
				{TR(TRACE_FIFO, ("ptr is null"));}
d354 1
a354 1
				TR(TRACE_FIFO, ("ptr=%p, ch=%d, value=%d",
d359 3
a361 3
	    			if (ptr->value != 0) {	/* sequence terminated */
	    				TR(TRACE_FIFO, ("end of sequence"));
	    				fifo_clear();
d363 1
a363 1
	    			} else {		/* go back for another character */
d365 2
a366 2
					TR(TRACE_FIFO, ("going back for more"));
	    			} else
d369 3
a371 3
	    			TR(TRACE_FIFO, ("waiting for rest of sequence"));
   				if (_nc_timed_wait(SP->_ifd, timeleft, &timeleft) < 1) {
					TR(TRACE_FIFO, ("ran out of time"));
d373 5
a377 5
   				} else {
   					TR(TRACE_FIFO, ("got more!"));
   					fifo_push();
   					ch = fifo_peek();
   				}
d379 1
a379 1
    	}	 
@
