head	1.6;
access;
symbols
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	99.01.18.19.07.29;	author millert;	state dead;
branches;
next	1.5;

1.5
date	98.07.23.21.18.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.12.14.23.15.46;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.21.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.23;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.06.05.18;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.6
log
@ncurses-4.2-990116
@
text
@/*	$OpenBSD: lib_addch.c,v 1.5 1998/07/23 21:18:25 millert Exp $	*/

/****************************************************************************
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 ****************************************************************************/

/*
**	lib_addch.c
**
**	The routine waddch().
**
*/

#include <curses.priv.h>
#include <ctype.h>

MODULE_ID("$From: lib_addch.c,v 1.41 1998/06/28 00:10:21 tom Exp $")

/*
 * Ugly microtweaking alert.  Everything from here to end of module is
 * likely to be speed-critical -- profiling data sure says it is!
 * Most of the important screen-painting functions are shells around
 * waddch().  So we make every effort to reduce function-call overhead
 * by inlining stuff, even at the cost of making wrapped copies for
 * export.  Also we supply some internal versions that don't call the
 * window sync hook, for use by string-put functions.
 */

/* Return bit mask for clearing color pair number if given ch has color */
#define COLOR_MASK(ch) (~(chtype)((ch)&A_COLOR?A_COLOR:0))

static inline chtype render_char(WINDOW *win, chtype ch)
/* compute a rendition of the given char correct for the current context */
{
	chtype a = win->_attrs;
	
	if (ch == ' ')
	{
		/* color in attrs has precedence over bkgd */
		ch = a | (win->_bkgd & COLOR_MASK(a));
	}
	else
	{
		/* color in attrs has precedence over bkgd */
		a |= (win->_bkgd & A_ATTRIBUTES) & COLOR_MASK(a);
		/* color in ch has precedence */
		ch |= (a & COLOR_MASK(ch));
	}

	TR(TRACE_VIRTPUT, ("bkg = %lx, attrs = %lx -> ch = %lx", win->_bkgd,
		win->_attrs, ch));

	return(ch);
}

chtype _nc_background(WINDOW *win)
/* make render_char() visible while still allowing us to inline it below */
{
	return (win->_bkgd);
}

chtype _nc_render(WINDOW *win, chtype ch)
/* make render_char() visible while still allowing us to inline it below */
{
	return render_char(win, ch);
}

/* check if position is legal; if not, return error */
#ifndef NDEBUG			/* treat this like an assertion */
#define CHECK_POSITION(win, x, y) \
	if (y > win->_maxy \
	 || x > win->_maxx \
	 || y < 0 \
	 || x < 0) { \
		TR(TRACE_VIRTPUT, ("Alert! Win=%p _curx = %d, _cury = %d " \
				   "(_maxx = %d, _maxy = %d)", win, x, y, \
				   win->_maxx, win->_maxy)); \
		return(ERR); \
	}
#else
#define CHECK_POSITION(win, x, y) /* nothing */
#endif

static inline
int waddch_literal(WINDOW *win, chtype ch)
{
	int x;
	struct ldat *line;

	x = win->_curx;

	CHECK_POSITION(win, x, win->_cury);

	/*
	 * If we're trying to add a character at the lower-right corner more
	 * than once, fail.  (Moving the cursor will clear the flag).
	 */
	if (win->_flags & _WRAPPED) {
		if (x >= win->_maxx)
			return (ERR);
		win->_flags &= ~_WRAPPED;
	}

	ch = render_char(win, ch);
	TR(TRACE_VIRTPUT, ("win attr = %s", _traceattr(win->_attrs)));

	line = win->_line+win->_cury;
	
	CHANGED_CELL(line,x);

	line->text[x++] = ch;
	
	TR(TRACE_VIRTPUT, ("(%d, %d) = %s", win->_cury, x, _tracechtype(ch)));
	if (x > win->_maxx) {
		/*
		 * The _WRAPPED flag is useful only for telling an application
		 * that we've just wrapped the cursor.  We don't do anything
		 * with this flag except set it when wrapping, and clear it
		 * whenever we move the cursor.  If we try to wrap at the
		 * lower-right corner of a window, we cannot move the cursor
		 * (since that wouldn't be legal).  So we return an error
		 * (which is what SVr4 does).  Unlike SVr4, we can successfully
		 * add a character to the lower-right corner.
		 */
		win->_flags |= _WRAPPED;
		if (++win->_cury > win->_regbottom) {
			win->_cury = win->_regbottom;
			win->_curx = win->_maxx;
			if (!win->_scroll)
				return (ERR);
			scroll(win);
		}
		win->_curx = 0;
		return (OK);
	}
	win->_curx = x;
	return OK;
}

static inline
int waddch_nosync(WINDOW *win, const chtype ch)
/* the workhorse function -- add a character to the given window */
{
	int	x, y;
	int	t;
	const char *s;

	if ((ch & A_ALTCHARSET)
	    || ((t = TextOf(ch)) > 127)
	    || ((s = unctrl(t))[1] == 0))
		return waddch_literal(win, ch);

	x = win->_curx;
	y = win->_cury;

	switch (t) {
	case '\t':
		x += (TABSIZE-(x%TABSIZE));

		/*
		 * Space-fill the tab on the bottom line so that we'll get the
		 * "correct" cursor position.
		 */
		if ((! win->_scroll && (y == win->_regbottom))
		 || (x <= win->_maxx)) {
			chtype blank = (' ' | AttrOf(ch));
			while (win->_curx < x) {
				if (waddch_literal(win, blank) == ERR)
					return(ERR);
			}
			break;
		} else {
			wclrtoeol(win);
			win->_flags |= _WRAPPED;
			if (++y > win->_regbottom) {
				x = win->_maxx;
				y--;
				if (win->_scroll) {
					scroll(win);
					x = 0;
				}
			} else {
				x = 0;
			}
		}
		break;
	case '\n':
		wclrtoeol(win);
		if (++y > win->_regbottom) {
			y--;
			if (win->_scroll)
				scroll(win);
			else
				return (ERR);
		}
		/* FALLTHRU */
	case '\r':
		x = 0;
		win->_flags &= ~_WRAPPED;
		break;
	case '\b':
		if (x == 0)
			return (OK);
		x--;
		win->_flags &= ~_WRAPPED;
		break;
	default:
		while (*s)
			if (waddch_literal(win, (*s++)|AttrOf(ch)) == ERR)
				return ERR;
		return(OK);
	}

	win->_curx = x;
	win->_cury = y;

	return(OK);
}

int _nc_waddch_nosync(WINDOW *win, const chtype c)
/* export copy of waddch_nosync() so the string-put functions can use it */
{
    return(waddch_nosync(win, c));
}

/*
 * The versions below call _nc_synhook().  We wanted to avoid this in the
 * version exported for string puts; they'll call _nc_synchook once at end
 * of run.
 */

/* These are actual entry points */

int waddch(WINDOW *win, const chtype ch)
{
	int code = ERR;

	TR(TRACE_VIRTPUT|TRACE_CCALLS, (T_CALLED("waddch(%p, %s)"), win, _tracechtype(ch)));

	if (win && (waddch_nosync(win, ch) != ERR))
	{
		_nc_synchook(win);
		code = OK;
	}

	TR(TRACE_VIRTPUT|TRACE_CCALLS, (T_RETURN("%d"), code));
	return(code);
}

int wechochar(WINDOW *win, const chtype ch)
{
	int code = ERR;

	TR(TRACE_VIRTPUT|TRACE_CCALLS, (T_CALLED("wechochar(%p, %s)"), win, _tracechtype(ch)));

	if (win && (waddch_nosync(win, ch) != ERR))
	{
		bool	save_immed = win->_immed;
		win->_immed = TRUE;
		_nc_synchook(win);
		win->_immed = save_immed;
		code = OK;
	}
	TR(TRACE_VIRTPUT|TRACE_CCALLS, (T_RETURN("%d"), code));
	return(code);
}
@


1.5
log
@ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4
log
@ncurses-4.1-971213
@
text
@d1 1
a1 1
/*	$OpenBSD: lib_addch.c,v 1.3 1997/12/03 05:21:10 millert Exp $	*/
d3 32
a34 20

/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d39 1
a39 1
**	The routines waddch(), wchgat().
d46 1
a46 20
MODULE_ID("Id: lib_addch.c,v 1.37 1997/12/02 20:17:46 Alexander.V.Lukyanov Exp $")

int wchgat(WINDOW *win, int n, attr_t attr, short color, const void *opts GCC_UNUSED)
{
    int	i;

    T((T_CALLED("wchgat(%p,%d,%s,%d)"), win, n, _traceattr(attr), color));

    if (win) {
      toggle_attr_on(attr,COLOR_PAIR(color));

      for (i = win->_curx; i <= win->_maxx && (n == -1 || (n-- > 0)); i++)
	win->_line[win->_cury].text[i]
	  = TextOf(win->_line[win->_cury].text[i]) | attr;

      returnCode(OK);
    }
    else
      returnCode(ERR);
}
d138 1
a138 6
	if (line->firstchar == _NOCHANGE)
		line->firstchar = line->lastchar = x;
	else if (x < line->firstchar)
		line->firstchar = x;
	else if (x > line->lastchar)
		line->lastchar = x;
@


1.3
log
@Merge of ncurses-4.1-971129
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
MODULE_ID("Id: lib_addch.c,v 1.36 1997/10/08 09:38:17 jtc Exp $")
d189 3
a191 1
	if (ch & A_ALTCHARSET)
a193 5
	t = TextOf(ch);
	s = unctrl(t);
	if (s[1] == 0)	/* not a control char */
		return waddch_literal(win, ch);
	
d249 4
a252 1
		return(waddstr(win, s));
@


1.2
log
@ncurses 4.1 + changes to work with our terminfo libs (instead of
the ncurses ones).  Changes are #ifdef EXTERN_TERMINFO.
Post 4.1 patches will be applied in a separate commit.
@
text
@d1 2
d27 1
a27 1
**	The routines waddch(), wattr_on(), wattr_off(), wchgat().
d34 1
a34 17
MODULE_ID("Id: lib_addch.c,v 1.30 1997/04/12 17:45:55 tom Exp $")

int wattr_on(WINDOW *win, const attr_t at)
{
	T((T_CALLED("wattr_on(%p,%s)"), win, _traceattr(at)));
	T(("... current %s", _traceattr(win->_attrs)));
	toggle_attr_on(win->_attrs,at);
	returnCode(OK);
}

int wattr_off(WINDOW *win, const attr_t at)
{
	T((T_CALLED("wattr_off(%p,%s)"), win, _traceattr(at)));
	T(("... current %s", _traceattr(win->_attrs)));
	toggle_attr_off(win->_attrs,at);
	returnCode(OK);
}
d42 2
a43 1
    toggle_attr_on(attr,COLOR_PAIR(color));
d45 1
a45 1
    for (i = win->_curx; i <= win->_maxx && (n == -1 || (n-- > 0)); i++)
d47 1
a47 1
	    = ch_or_attr(TextOf(win->_line[win->_cury].text[i]),attr);
d49 4
a52 1
    returnCode(OK);
d65 3
d71 17
a87 5
	if (TextOf(ch) == ' ')
		ch = ch_or_attr(ch, win->_bkgd);
	else if (!(ch & A_ATTRIBUTES))
		ch = ch_or_attr(ch, (win->_bkgd & A_ATTRIBUTES));
	TR(TRACE_VIRTPUT, ("bkg = %#lx -> ch = %#lx", win->_bkgd, ch));
d95 1
a95 1
    return(render_char(win, BLANK));
d101 1
a101 2
    chtype c = render_char(win,ch);
    return (ch_or_attr(c,win->_attrs));
d105 1
a105 1
#ifdef NDEBUG			/* treat this like an assertion */
d123 2
a124 1
register int x, y;
a126 1
	y = win->_cury;
d128 1
a128 1
	CHECK_POSITION(win, x, y);
a140 1
	ch = ch_or_attr(ch,win->_attrs);
d143 12
a154 12
	if (win->_line[y].text[x] != ch) {
		if (win->_line[y].firstchar == _NOCHANGE)
			win->_line[y].firstchar = win->_line[y].lastchar = x;
		else if (x < win->_line[y].firstchar)
			win->_line[y].firstchar = x;
		else if (x > win->_line[y].lastchar)
			win->_line[y].lastchar = x;

	}

	win->_line[y].text[x++] = ch;
	TR(TRACE_VIRTPUT, ("(%d, %d) = %s", y, x, _tracechtype(ch)));
d167 4
a170 8
		if (++y > win->_regbottom) {
			y = win->_regbottom;
			x = win->_maxx;
			if (win->_scroll)
				scroll(win);
			else {
				win->_curx = x;
				win->_cury = y;
d172 1
a172 1
			}
d174 2
a175 1
		x = 0;
a176 1

a177 2
	win->_cury = y;

d182 1
a182 1
int waddch_nosync(WINDOW *win, const chtype c)
d185 6
a190 2
register chtype	ch = c;
register int	x, y;
d192 5
d200 1
a200 6
	CHECK_POSITION(win, x, y);

	if (ch & A_ALTCHARSET)
		goto noctrl;

	switch ((int)TextOf(ch)) {
d210 1
d212 1
a212 1
				if (waddch_literal(win, (' ' | AttrOf(ch))) == ERR)
d246 4
a249 4
		if (x > 0) {
			x--;
			win->_flags &= ~_WRAPPED;
		}
d252 1
a252 6
		if (is7bits(TextOf(ch)) && iscntrl(TextOf(ch)))
			return(waddstr(win, unctrl((unsigned char)ch)));

		/* FALLTHRU */
	noctrl:
		return waddch_literal(win, ch);
d281 1
a281 1
	if (waddch_nosync(win, ch) != ERR)
d297 1
a297 1
	if (waddch_literal(win, ch) != ERR)
@


1.1
log
@Install ncurses as -lcurses and <curses.h>
Install BSD curses library as -locurses and <ocurses.h>
@
text
@d29 1
a29 1
#include "curses.priv.h"
a30 1
#include "unctrl.h"
d32 1
a32 1
#define ALL_BUT_COLOR ((chtype)~(A_COLOR))
d36 4
a39 9
	T(("wattr_on(%p,%s) current = %s", win, _traceattr(at), _traceattr(win->_attrs)));
	if (PAIR_NUMBER(at) > 0x00) {
		win->_attrs = (win->_attrs & ALL_BUT_COLOR) | at ;
		T(("new attribute is %s", _traceattr(win->_attrs)));
	} else {
		win->_attrs |= at;
		T(("new attribute is %s", _traceattr(win->_attrs)));
	}
	return OK;
d44 4
a47 16
#define IGNORE_COLOR_OFF FALSE

	T(("wattr_off(%p,%s) current = %s", win, _traceattr(at), _traceattr(win->_attrs)));
	if (IGNORE_COLOR_OFF == TRUE) {
		if (PAIR_NUMBER(at) == 0xff) /* turn off color */
			win->_attrs &= ~at;
		else /* leave color alone */
			win->_attrs &= ~(at|ALL_BUT_COLOR);
	} else {
		if (PAIR_NUMBER(at) > 0x00) /* turn off color */
			win->_attrs &= ~at;
		else /* leave color alone */
			win->_attrs &= ~(at|ALL_BUT_COLOR);
	}
	T(("new attribute is %s", _traceattr(win->_attrs)));
	return OK;
d50 1
a50 1
int wchgat(WINDOW *win, int n, attr_t attr, short color, const void *opts)
d54 4
d60 1
a60 3
	    = (win->_line[win->_cury].text[i] & A_CHARTEXT)
		| attr
		| COLOR_PAIR(color);
d62 1
a62 1
    return OK;
d75 1
a75 1
static __inline chtype render_char(WINDOW *win, chtype oldch, chtype newch)
d78 5
a82 5
	if ((oldch & A_CHARTEXT) == ' ')
		newch |= win->_bkgd;
	else if (!(newch & A_ATTRIBUTES))
		newch |= (win->_bkgd & A_ATTRIBUTES);
	TR(TRACE_VIRTPUT, ("bkg = %lx -> ch = %lx", win->_bkgd, newch));
d84 1
a84 1
	return(newch);
d87 1
a87 1
chtype _nc_render(WINDOW *win, chtype oldch, chtype newch)
d90 1
a90 1
    return(render_char(win, oldch, newch));
d93 6
a98 9
/* actions needed to process a newline within addch_nosync() */
#define DO_NEWLINE	x = 0; \
			win->_flags &= ~_NEED_WRAP; \
			y++; \
			if (y > win->_regbottom) { \
				y--; \
				if (win->_scroll) \
					scroll(win); \
			}
d101 1
d103 4
a106 1
	if (y > win->_maxy || x > win->_maxx || y < 0 || x < 0) { \
d110 1
a110 3
	  	win->_curx = win->_cury = 0; \
		win->_flags &= ~_NEED_WRAP; \
	    	return(ERR); \
d112 3
d116 1
a116 1
static __inline
a125 5
	if (win->_flags & _NEED_WRAP) {
		TR(TRACE_MOVE, ("new char when NEED_WRAP set at %d,%d",y,x));
		DO_NEWLINE
	}

d127 2
a128 4
	 * We used to pass in
	 *	win->_line[y].text[x]
	 * as a second argument, but the value of the old character
	 * is not relevant here.
d130 5
a134 1
	ch = render_char(win, 0, ch);
d136 2
a138 1
	ch |= win->_attrs;
d151 1
a151 4
	TR(TRACE_VIRTPUT, ("(%d, %d) = %s | %s", 
			   y, x,
			   _tracechar((unsigned char)(ch & A_CHARTEXT)),
			   _traceattr((ch & (chtype)A_ATTRIBUTES))));
d153 23
a175 3
		TR(TRACE_MOVE, ("NEED_WRAP set at %d,%d",y,x));
		win->_flags |= _NEED_WRAP;
		x--;
d184 1
a184 1
static __inline
a189 1
int		newx;
d199 28
a226 10
	switch ((int)(ch&A_CHARTEXT)) {
    	case '\t':
		if (win->_flags & _NEED_WRAP) {
		  	x = 0;
			newx = min(TABSIZE, win->_maxx+1);
		} else
			newx = min(x + (TABSIZE-(x%TABSIZE)), win->_maxx+1);
		while (win->_curx < newx) {
	    		if (waddch_literal(win, ' ' | (ch&A_ATTRIBUTES)) == ERR)
				return(ERR);
d228 2
a229 2
		return(OK);
    	case '\n':
d231 9
a239 3
		DO_NEWLINE
		break;
    	case '\r':
d241 1
a241 1
		win->_flags &= ~_NEED_WRAP;
d243 5
a247 5
    	case '\b':
		if (win->_flags & _NEED_WRAP)
			win->_flags &= ~_NEED_WRAP;
		else if (--x < 0)
			x = 0;
d249 3
a251 3
    	default:
		if (is7bits(ch & A_CHARTEXT) && iscntrl(ch & A_CHARTEXT))
		    	return(waddstr(win, unctrl((unsigned char)ch)));
d254 2
a255 3
        noctrl:
		waddch_literal(win, ch);
		return(OK);
a263 2
#undef DO_NEWLINE

d280 5
a284 7
	TR(TRACE_VIRTPUT, ("waddch(%p, %s | %s) called", win,
			  _tracechar((unsigned char)(ch & A_CHARTEXT)),
			  _traceattr((ch & (chtype)A_ATTRIBUTES))));

	if (waddch_nosync(win, ch) == ERR)
		return(ERR);
	else
d287 1
a287 2
		TR(TRACE_VIRTPUT, ("waddch() is done"));
		return(OK);
d289 3
d296 5
a300 7
	TR(TRACE_VIRTPUT, ("wechochar(%p,%s (%s)) called", win,
			  _tracechar((unsigned char)(ch & A_CHARTEXT)),
			  _traceattr((ch & (chtype)A_ATTRIBUTES))));

	if (waddch_literal(win, ch) == ERR)
		return(ERR);
	else
d302 2
d305 2
a306 2
		TR(TRACE_VIRTPUT, ("wechochar() is done"));
		return(OK);
d308 2
@
