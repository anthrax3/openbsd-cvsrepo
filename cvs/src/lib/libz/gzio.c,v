head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.46
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.42
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.44
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.36
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.40
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.38
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.34
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.32
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.30
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.28
	OPENBSD_5_0:1.14.0.26
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.24
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.22
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.18
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.20
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.16
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.14
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.12
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.10
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2005.07.20.15.56.41;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.03.03.06.36;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.16.22.33.02;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.02.21.00.19;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.27.17.29.35;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.09.00.45.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.06.00.11.40;	author millert;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2002.03.12.00.25.57;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.03.02.00.29.52;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	98.08.08.20.57.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.19.17.11.23;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.10.27.00.29.33;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.07.27.02.39.45;	author tholo;	state Exp;
branches;
next	;

1.6.2.1
date	2002.03.13.16.07.26;	author jason;	state Exp;
branches;
next	;

1.8.2.1
date	2003.03.05.03.54.34;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to zlib 1.2.3; OK deraadt@@
@
text
@/*	$OpenBSD: gzio.c,v 1.13 2004/12/03 03:06:36 djm Exp $	*/
/* gzio.c -- IO on .gz files
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 *
 * Compile this file with -DNO_GZCOMPRESS to avoid the compression code.
 */


#include <stdio.h>

#include "zutil.h"

#ifdef NO_DEFLATE       /* for compatibility with old definition */
#  define NO_GZCOMPRESS
#endif

#ifndef NO_DUMMY_DECL
struct internal_state {int dummy;}; /* for buggy compilers */
#endif

#ifndef Z_BUFSIZE
#  ifdef MAXSEG_64K
#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
#  else
#    define Z_BUFSIZE 16384
#  endif
#endif
#ifndef Z_PRINTF_BUFSIZE
#  define Z_PRINTF_BUFSIZE 4096
#endif

#ifdef __MVS__
#  pragma map (fdopen , "\174\174FDOPEN")
   FILE *fdopen(int, const char *);
#endif

#ifndef STDC
extern voidp  malloc OF((uInt size));
extern void   free   OF((voidpf ptr));
#endif

#define ALLOC(size) malloc(size)
#define TRYFREE(p) {if (p) free(p);}

static int const gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */

/* gzip flag byte */
#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
#define COMMENT      0x10 /* bit 4 set: file comment present */
#define RESERVED     0xE0 /* bits 5..7: reserved */

typedef struct gz_stream {
    z_stream stream;
    int      z_err;   /* error code for last stream operation */
    int      z_eof;   /* set if end of input file */
    FILE     *file;   /* .gz file */
    Byte     *inbuf;  /* input buffer */
    Byte     *outbuf; /* output buffer */
    uLong    crc;     /* crc32 of uncompressed data */
    char     *msg;    /* error message */
    char     *path;   /* path name for debugging only */
    int      transparent; /* 1 if input file is not a .gz file */
    char     mode;    /* 'w' or 'r' */
    z_off_t  start;   /* start of compressed data in file (header skipped) */
    z_off_t  in;      /* bytes into deflate or inflate */
    z_off_t  out;     /* bytes out of deflate or inflate */
    int      back;    /* one character push-back */
    int      last;    /* true if push-back is last character */
} gz_stream;


local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
local int do_flush        OF((gzFile file, int flush));
local int    get_byte     OF((gz_stream *s));
local void   check_header OF((gz_stream *s));
local int    destroy      OF((gz_stream *s));
local void   putLong      OF((FILE *file, uLong x));
local uLong  getLong      OF((gz_stream *s));

/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb"). The file is given either by file descriptor
   or path name (if fd == -1).
     gz_open returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).
*/
local gzFile gz_open (path, mode, fd)
    const char *path;
    const char *mode;
    int  fd;
{
    int err;
    int level = Z_DEFAULT_COMPRESSION; /* compression level */
    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
    char *p = (char*)mode;
    gz_stream *s;
    char fmode[80]; /* copy of mode, without the compression level */
    char *m = fmode;
    size_t len;

    if (!path || !mode) return Z_NULL;

    s = (gz_stream *)ALLOC(sizeof(gz_stream));
    if (!s) return Z_NULL;

    s->stream.zalloc = (alloc_func)0;
    s->stream.zfree = (free_func)0;
    s->stream.opaque = (voidpf)0;
    s->stream.next_in = s->inbuf = Z_NULL;
    s->stream.next_out = s->outbuf = Z_NULL;
    s->stream.avail_in = s->stream.avail_out = 0;
    s->file = NULL;
    s->z_err = Z_OK;
    s->z_eof = 0;
    s->in = 0;
    s->out = 0;
    s->back = EOF;
    s->crc = crc32(0L, Z_NULL, 0);
    s->msg = NULL;
    s->transparent = 0;

    len = strlen(path)+1;
    s->path = (char*)ALLOC(len);
    if (s->path == NULL) {
        return destroy(s), (gzFile)Z_NULL;
    }
    strlcpy(s->path, path, len); /* do this early for debugging */

    s->mode = '\0';
    do {
        if (*p == 'r') s->mode = 'r';
        if (*p == 'w' || *p == 'a') s->mode = 'w';
        if (*p >= '0' && *p <= '9') {
            level = *p - '0';
        } else if (*p == 'f') {
          strategy = Z_FILTERED;
        } else if (*p == 'h') {
          strategy = Z_HUFFMAN_ONLY;
        } else if (*p == 'R') {
          strategy = Z_RLE;
        } else {
            *m++ = *p; /* copy the mode */
        }
    } while (*p++ && m != fmode + sizeof(fmode));
    if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;

    if (s->mode == 'w') {
#ifdef NO_GZCOMPRESS
        err = Z_STREAM_ERROR;
#else
        err = deflateInit2(&(s->stream), level,
                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
        /* windowBits is passed < 0 to suppress zlib header */

        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
#endif
        if (err != Z_OK || s->outbuf == Z_NULL) {
            return destroy(s), (gzFile)Z_NULL;
        }
    } else {
        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);

        err = inflateInit2(&(s->stream), -MAX_WBITS);
        /* windowBits is passed < 0 to tell that there is no zlib header.
         * Note that in this case inflate *requires* an extra "dummy" byte
         * after the compressed stream in order to complete decompression and
         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
         * present after the compressed stream.
         */
        if (err != Z_OK || s->inbuf == Z_NULL) {
            return destroy(s), (gzFile)Z_NULL;
        }
    }
    s->stream.avail_out = Z_BUFSIZE;

    errno = 0;
    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);

    if (s->file == NULL) {
        return destroy(s), (gzFile)Z_NULL;
    }
    if (s->mode == 'w') {
        /* Write a very simple .gz header:
         */
        fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
        s->start = 10L;
        /* We use 10L instead of ftell(s->file) to because ftell causes an
         * fflush on some systems. This version of the library doesn't use
         * start anyway in write mode, so this initialization is not
         * necessary.
         */
    } else {
        check_header(s); /* skip the .gz header */
        s->start = ftell(s->file) - s->stream.avail_in;
    }

    return (gzFile)s;
}

/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing.
*/
gzFile ZEXPORT gzopen (path, mode)
    const char *path;
    const char *mode;
{
    return gz_open (path, mode, -1);
}

/* ===========================================================================
     Associate a gzFile with the file descriptor fd. fd is not dup'ed here
   to mimic the behavio(u)r of fdopen.
*/
gzFile ZEXPORT gzdopen (fd, mode)
    int fd;
    const char *mode;
{
    char name[46];      /* allow for up to 128-bit integers */

    if (fd < 0) return (gzFile)Z_NULL;
    snprintf(name, sizeof name, "<fd:%d>", fd); /* for debugging */

    return gz_open (name, mode, fd);
}

/* ===========================================================================
 * Update the compression level and strategy
 */
int ZEXPORT gzsetparams (file, level, strategy)
    gzFile file;
    int level;
    int strategy;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    /* Make room to allow flushing */
    if (s->stream.avail_out == 0) {

        s->stream.next_out = s->outbuf;
        if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
            s->z_err = Z_ERRNO;
        }
        s->stream.avail_out = Z_BUFSIZE;
    }

    return deflateParams (&(s->stream), level, strategy);
}

/* ===========================================================================
     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
   for end of file.
   IN assertion: the stream s has been successfully opened for reading.
*/
local int get_byte(s)
    gz_stream *s;
{
    if (s->z_eof) return EOF;
    if (s->stream.avail_in == 0) {
        errno = 0;
        s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);
        if (s->stream.avail_in == 0) {
            s->z_eof = 1;
            if (ferror(s->file)) s->z_err = Z_ERRNO;
            return EOF;
        }
        s->stream.next_in = s->inbuf;
    }
    s->stream.avail_in--;
    return *(s->stream.next_in)++;
}

/* ===========================================================================
      Check the gzip header of a gz_stream opened for reading. Set the stream
    mode to transparent if the gzip magic header is not present; set s->err
    to Z_DATA_ERROR if the magic header is present but the rest of the header
    is incorrect.
    IN assertion: the stream s has already been created successfully;
       s->stream.avail_in is zero for the first time, but may be non-zero
       for concatenated .gz files.
*/
local void check_header(s)
    gz_stream *s;
{
    int method; /* method byte */
    int flags;  /* flags byte */
    uInt len;
    int c;

    /* Assure two bytes in the buffer so we can peek ahead -- handle case
       where first byte of header is at the end of the buffer after the last
       gzip segment */
    len = s->stream.avail_in;
    if (len < 2) {
        if (len) s->inbuf[0] = s->stream.next_in[0];
        errno = 0;
        len = (uInt)fread(s->inbuf + len, 1, Z_BUFSIZE >> len, s->file);
        if (len == 0 && ferror(s->file)) s->z_err = Z_ERRNO;
        s->stream.avail_in += len;
        s->stream.next_in = s->inbuf;
        if (s->stream.avail_in < 2) {
            s->transparent = s->stream.avail_in;
            return;
        }
    }

    /* Peek ahead to check the gzip magic header */
    if (s->stream.next_in[0] != gz_magic[0] ||
        s->stream.next_in[1] != gz_magic[1]) {
        s->transparent = 1;
        return;
    }
    s->stream.avail_in -= 2;
    s->stream.next_in += 2;

    /* Check the rest of the gzip header */
    method = get_byte(s);
    flags = get_byte(s);
    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
        s->z_err = Z_DATA_ERROR;
        return;
    }

    /* Discard time, xflags and OS code: */
    for (len = 0; len < 6; len++) (void)get_byte(s);

    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
        len  =  (uInt)get_byte(s);
        len += ((uInt)get_byte(s))<<8;
        /* len is garbage if EOF but the loop below will quit anyway */
        while (len-- != 0 && get_byte(s) != EOF) ;
    }
    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
        while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
        while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
        for (len = 0; len < 2; len++) (void)get_byte(s);
    }
    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
}

 /* ===========================================================================
 * Cleanup then free the given gz_stream. Return a zlib error code.
   Try freeing in the reverse order of allocations.
 */
local int destroy (s)
    gz_stream *s;
{
    int err = Z_OK;

    if (!s) return Z_STREAM_ERROR;

    TRYFREE(s->msg);

    if (s->stream.state != NULL) {
        if (s->mode == 'w') {
#ifdef NO_GZCOMPRESS
            err = Z_STREAM_ERROR;
#else
            err = deflateEnd(&(s->stream));
#endif
        } else if (s->mode == 'r') {
            err = inflateEnd(&(s->stream));
        }
    }
    if (s->file != NULL && fclose(s->file)) {
#ifdef ESPIPE
        if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */
#endif
            err = Z_ERRNO;
    }
    if (s->z_err < 0) err = s->z_err;

    TRYFREE(s->inbuf);
    TRYFREE(s->outbuf);
    TRYFREE(s->path);
    TRYFREE(s);
    return err;
}

/* ===========================================================================
     Reads the given number of uncompressed bytes from the compressed file.
   gzread returns the number of bytes actually read (0 for end of file).
*/
int ZEXPORT gzread (file, buf, len)
    gzFile file;
    voidp buf;
    unsigned len;
{
    gz_stream *s = (gz_stream*)file;
    Bytef *start = (Bytef*)buf; /* starting point for crc computation */
    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */

    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;

    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */

    next_out = (Byte*)buf;
    s->stream.next_out = (Bytef*)buf;
    s->stream.avail_out = len;

    if (s->stream.avail_out && s->back != EOF) {
        *next_out++ = s->back;
        s->stream.next_out++;
        s->stream.avail_out--;
        s->back = EOF;
        s->out++;
        start++;
        if (s->last) {
            s->z_err = Z_STREAM_END;
            return 1;
        }
    }

    while (s->stream.avail_out != 0) {

        if (s->transparent) {
            /* Copy first the lookahead bytes: */
            uInt n = s->stream.avail_in;
            if (n > s->stream.avail_out) n = s->stream.avail_out;
            if (n > 0) {
                zmemcpy(s->stream.next_out, s->stream.next_in, n);
                next_out += n;
                s->stream.next_out = next_out;
                s->stream.next_in   += n;
                s->stream.avail_out -= n;
                s->stream.avail_in  -= n;
            }
            if (s->stream.avail_out > 0) {
                s->stream.avail_out -=
                    (uInt)fread(next_out, 1, s->stream.avail_out, s->file);
            }
            len -= s->stream.avail_out;
            s->in  += len;
            s->out += len;
            if (len == 0) s->z_eof = 1;
            return (int)len;
        }
        if (s->stream.avail_in == 0 && !s->z_eof) {

            errno = 0;
            s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);
            if (s->stream.avail_in == 0) {
                s->z_eof = 1;
                if (ferror(s->file)) {
                    s->z_err = Z_ERRNO;
                    break;
                }
            }
            s->stream.next_in = s->inbuf;
        }
        s->in += s->stream.avail_in;
        s->out += s->stream.avail_out;
        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);
        s->in -= s->stream.avail_in;
        s->out -= s->stream.avail_out;

        if (s->z_err == Z_STREAM_END) {
            /* Check CRC and original size */
            s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
            start = s->stream.next_out;

            if (getLong(s) != s->crc) {
                s->z_err = Z_DATA_ERROR;
            } else {
                (void)getLong(s);
                /* The uncompressed length returned by above getlong() may be
                 * different from s->out in case of concatenated .gz files.
                 * Check for such files:
                 */
                check_header(s);
                if (s->z_err == Z_OK) {
                    inflateReset(&(s->stream));
                    s->crc = crc32(0L, Z_NULL, 0);
                }
            }
        }
        if (s->z_err != Z_OK || s->z_eof) break;
    }
    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

    if (len == s->stream.avail_out &&
        (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO))
        return -1;
    return (int)(len - s->stream.avail_out);
}


/* ===========================================================================
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/
int ZEXPORT gzgetc(file)
    gzFile file;
{
    unsigned char c;

    return gzread(file, &c, 1) == 1 ? c : -1;
}


/* ===========================================================================
      Push one byte back onto the stream.
*/
int ZEXPORT gzungetc(c, file)
    int c;
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'r' || c == EOF || s->back != EOF) return EOF;
    s->back = c;
    s->out--;
    s->last = (s->z_err == Z_STREAM_END);
    if (s->last) s->z_err = Z_OK;
    s->z_eof = 0;
    return c;
}


/* ===========================================================================
      Reads bytes from the compressed file until len-1 characters are
   read, or a newline character is read and transferred to buf, or an
   end-of-file condition is encountered.  The string is then terminated
   with a null character.
      gzgets returns buf, or Z_NULL in case of error.

      The current implementation is not optimized at all.
*/
char * ZEXPORT gzgets(file, buf, len)
    gzFile file;
    char *buf;
    int len;
{
    char *b = buf;
    if (buf == Z_NULL || len <= 0) return Z_NULL;

    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
    *buf = '\0';
    return b == buf && len > 0 ? Z_NULL : b;
}


#ifndef NO_GZCOMPRESS
/* ===========================================================================
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of bytes actually written (0 in case of error).
*/
int ZEXPORT gzwrite (file, buf, len)
    gzFile file;
    voidpc buf;
    unsigned len;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    s->stream.next_in = (Bytef*)buf;
    s->stream.avail_in = len;

    while (s->stream.avail_in != 0) {

        if (s->stream.avail_out == 0) {

            s->stream.next_out = s->outbuf;
            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
                s->z_err = Z_ERRNO;
                break;
            }
            s->stream.avail_out = Z_BUFSIZE;
        }
        s->in += s->stream.avail_in;
        s->out += s->stream.avail_out;
        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
        s->in -= s->stream.avail_in;
        s->out -= s->stream.avail_out;
        if (s->z_err != Z_OK) break;
    }
    s->crc = crc32(s->crc, (const Bytef *)buf, len);

    return (int)(len - s->stream.avail_in);
}


/* ===========================================================================
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/
#ifdef STDC
#include <stdarg.h>

int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
{
    char buf[Z_PRINTF_BUFSIZE];
    va_list va;
    int len;

    va_start(va, format);
#ifdef HAS_vsnprintf
    len = vsnprintf(buf, sizeof(buf), format, va);
#else
    (void)vsprintf(buf, format, va);
    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
#endif
    va_end(va);
    if (len <= 0 || len >= sizeof(buf)) return 0;

    return gzwrite(file, buf, (unsigned)len);
}
#else /* not ANSI C */

int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    gzFile file;
    const char *format;
    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
{
    char buf[Z_PRINTF_BUFSIZE];
    int len;

#ifdef HAS_snprintf
    len = snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
	     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#else
    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
	    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
#endif
    if (len <= 0 || len >= sizeof(buf)) return 0;

    return gzwrite(file, buf, len);
}
#endif

/* ===========================================================================
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/
int ZEXPORT gzputc(file, c)
    gzFile file;
    int c;
{
    unsigned char cc = (unsigned char) c; /* required for big endian systems */

    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
}


/* ===========================================================================
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/
int ZEXPORT gzputs(file, s)
    gzFile file;
    const char *s;
{
    return gzwrite(file, (char*)s, (unsigned)strlen(s));
}


/* ===========================================================================
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function.
*/
local int do_flush (file, flush)
    gzFile file;
    int flush;
{
    uInt len;
    int done = 0;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    s->stream.avail_in = 0; /* should be zero already anyway */

    for (;;) {
        len = Z_BUFSIZE - s->stream.avail_out;

        if (len != 0) {
            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {
                s->z_err = Z_ERRNO;
                return Z_ERRNO;
            }
            s->stream.next_out = s->outbuf;
            s->stream.avail_out = Z_BUFSIZE;
        }
        if (done) break;
        s->out += s->stream.avail_out;
        s->z_err = deflate(&(s->stream), flush);
        s->out -= s->stream.avail_out;

        /* Ignore the second of two consecutive flushes: */
        if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;

        /* deflate has finished flushing only when it hasn't used up
         * all the available space in the output buffer:
         */
        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);

        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
    }
    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
}

int ZEXPORT gzflush (file, flush)
     gzFile file;
     int flush;
{
    gz_stream *s = (gz_stream*)file;
    int err = do_flush (file, flush);

    if (err) return err;
    fflush(s->file);
    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
}
#endif /* NO_GZCOMPRESS */

/* ===========================================================================
      Sets the starting position for the next gzread or gzwrite on the given
   compressed file. The offset represents a number of bytes in the
      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error.
      SEEK_END is not implemented, returns error.
      In this version of the library, gzseek can be extremely slow.
*/
z_off_t ZEXPORT gzseek (file, offset, whence)
    gzFile file;
    z_off_t offset;
    int whence;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || whence == SEEK_END ||
	s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
	return -1L;
    }
    
    if (s->mode == 'w') {
#ifdef NO_GZCOMPRESS
	return -1L;
#else
	if (whence == SEEK_SET) {
	    offset -= s->in;
	}
	if (offset < 0) return -1L;

	/* At this point, offset is the number of zero bytes to write. */
	if (s->inbuf == Z_NULL) {
	    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
	    if (s->inbuf == Z_NULL) return -1L;
	    zmemzero(s->inbuf, Z_BUFSIZE);
	}
	while (offset > 0)  {
	    uInt size = Z_BUFSIZE;
	    if (offset < Z_BUFSIZE) size = (uInt)offset;

	    size = gzwrite(file, s->inbuf, size);
	    if (size == 0) return -1L;

	    offset -= size;
	}
	return s->in;
#endif
    }
    /* Rest of function is for reading only */

    /* compute absolute position */
    if (whence == SEEK_CUR) {
	offset += s->out;
    }
    if (offset < 0) return -1L;

    if (s->transparent) {
	/* map to fseek */
	s->back = EOF;
	s->stream.avail_in = 0;
	s->stream.next_in = s->inbuf;
        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;

	s->in = s->out = offset;
	return offset;
    }

    /* For a negative seek, rewind and use positive seek */
    if (offset >= s->out) {
	offset -= s->out;
    } else if (gzrewind(file) < 0) {
	return -1L;
    }
    /* offset is now the number of bytes to skip. */

    if (offset != 0 && s->outbuf == Z_NULL) {
	s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
	if (s->outbuf == Z_NULL) return -1L;
    }
    if (offset && s->back != EOF) {
        s->back = EOF;
        s->out++;
        offset--;
        if (s->last) s->z_err = Z_STREAM_END;
    }
    while (offset > 0)  {
	int size = Z_BUFSIZE;
	if (offset < Z_BUFSIZE) size = (int)offset;

	size = gzread(file, s->outbuf, (uInt)size);
	if (size <= 0) return -1L;
	offset -= size;
    }
    return s->out;
}

/* ===========================================================================
     Rewinds input file. 
*/
int ZEXPORT gzrewind (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'r') return -1;

    s->z_err = Z_OK;
    s->z_eof = 0;
    s->back = EOF;
    s->stream.avail_in = 0;
    s->stream.next_in = s->inbuf;
    s->crc = crc32(0L, Z_NULL, 0);
    if (!s->transparent) (void)inflateReset(&s->stream);
    s->in = 0;
    s->out = 0;
    return fseek(s->file, s->start, SEEK_SET);
}

/* ===========================================================================
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.
*/
z_off_t ZEXPORT gztell (file)
    gzFile file;
{
    return gzseek(file, 0L, SEEK_CUR);
}

/* ===========================================================================
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/
int ZEXPORT gzeof (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;

    /* With concatenated compressed files that can have embedded
     * crc trailers, z_eof is no longer the only/best indicator of EOF
     * on a gz_stream. Handle end-of-stream error explicitly here.
     */
    if (s == NULL || s->mode != 'r') return 0;
    if (s->z_eof) return 1;
    return s->z_err == Z_STREAM_END;
}

/* ===========================================================================
     Returns 1 if reading and doing so transparently, otherwise zero.
*/
int ZEXPORT gzdirect (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'r') return 0;
    return s->transparent;
}

/* ===========================================================================
   Outputs a long in LSB order to the given file
*/
local void putLong (file, x)
    FILE *file;
    uLong x;
{
    int n;
    for (n = 0; n < 4; n++) {
        fputc((int)(x & 0xff), file);
        x >>= 8;
    }
}

/* ===========================================================================
   Reads a long in LSB order from the given gz_stream. Sets z_err in case
   of error.
*/
local uLong getLong (s)
    gz_stream *s;
{
    uLong x = (uLong)get_byte(s);
    int c;

    x += ((uLong)get_byte(s))<<8;
    x += ((uLong)get_byte(s))<<16;
    c = get_byte(s);
    if (c == EOF) s->z_err = Z_DATA_ERROR;
    x += ((uLong)c)<<24;
    return x;
}

/* ===========================================================================
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state.
*/
int ZEXPORT gzclose (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) return Z_STREAM_ERROR;

    if (s->mode == 'w') {
#ifdef NO_GZCOMPRESS
        return Z_STREAM_ERROR;
#else
        if (do_flush (file, Z_FINISH) != Z_OK)
            return destroy((gz_stream*)file);

        putLong (s->file, s->crc);
        putLong (s->file, (uLong)(s->in & 0xffffffff));
#endif
    }
    return destroy((gz_stream*)file);
}

#ifdef STDC
#  define zstrerror(errnum) strerror(errnum)
#else
#  define zstrerror(errnum) ""
#endif

/* ===========================================================================
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/
const char * ZEXPORT gzerror (file, errnum)
    gzFile file;
    int *errnum;
{
    char *m;
    gz_stream *s = (gz_stream*)file;
    size_t len;

    if (s == NULL) {
        *errnum = Z_STREAM_ERROR;
        return (const char*)ERR_MSG(Z_STREAM_ERROR);
    }
    *errnum = s->z_err;
    if (*errnum == Z_OK) return (const char*)"";

    m = (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);

    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);

    TRYFREE(s->msg);
    len = strlen(s->path) + strlen(m) + 3;
    s->msg = (char*)ALLOC(len);
    if (s->msg == Z_NULL) return (const char*)ERR_MSG(Z_MEM_ERROR);
    strlcpy(s->msg, s->path, len);
    strlcat(s->msg, ": ", len);
    strlcat(s->msg, m, len);
    return (const char*)s->msg;
}

/* ===========================================================================
     Clear the error and end-of-file flags, and do the same for the real file.
*/
void ZEXPORT gzclearerr (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) return;
    if (s->z_err != Z_STREAM_END) s->z_err = Z_OK;
    s->z_eof = 0;
    clearerr(s->file);
}
@


1.13
log
@update to zlib-1.21 (we already have the CAN-2004-0797 security fixes)
"in it goes" deraadt@@, in the near-total absence of feedback from others
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.12 2003/12/16 22:33:02 henning Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-2003 Jean-loup Gailly.
d14 1
a14 1
#ifdef NO_DEFLATE       /* for compatiblity with old definition */
d225 1
a225 1
    char name[20];
d269 1
a269 1
        s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
d305 1
a305 1
        len = fread(s->inbuf + len, 1, Z_BUFSIZE >> len, s->file);
d420 1
d442 2
a443 2
                s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,
                                             s->file);
d454 1
a454 1
            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
a460 4
                if (feof(s->file)) {        /* avoid error for empty file */
                    s->z_err = Z_STREAM_END;
                    break;
                }
d494 3
d881 12
a930 1
    int err;
d939 2
a940 2
        err = do_flush (file, Z_FINISH);
        if (err != Z_OK) return destroy((gz_stream*)file);
d948 6
@


1.12
log
@update to zlib 1.2.1

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.11 2003/04/02 21:00:19 deraadt Exp $	*/
d458 4
@


1.11
log
@use strlcpy; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.10 2003/02/27 17:29:35 millert Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-2002 Jean-loup Gailly.
d6 1
a6 1
 * Compile this file with -DNO_DEFLATE to avoid the compression code.
d14 5
d20 1
d33 10
d46 1
a46 1
static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
d68 5
a72 1
    long     startpos; /* start of compressed data in file (header skipped) */
d88 1
a88 1
     gz_open return NULL if the file could not be opened or if there was
d121 3
d140 10
a149 8
	    level = *p - '0';
	} else if (*p == 'f') {
	  strategy = Z_FILTERED;
	} else if (*p == 'h') {
	  strategy = Z_HUFFMAN_ONLY;
	} else {
	    *m++ = *p; /* copy the mode */
	}
d152 1
a152 1
    
d154 1
a154 1
#ifdef NO_DEFLATE
d193 2
a194 2
	s->startpos = 10L;
	/* We use 10L instead of ftell(s->file) to because ftell causes an
d196 1
a196 1
         * startpos anyway in write mode, so this initialization is not
d200 2
a201 2
	check_header(s); /* skip the .gz header */
	s->startpos = (ftell(s->file) - s->stream.avail_in);
d203 1
a203 1
    
d248 5
a252 5
	s->stream.next_out = s->outbuf;
	if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
	    s->z_err = Z_ERRNO;
	}
	s->stream.avail_out = Z_BUFSIZE;
d268 8
a275 8
	errno = 0;
	s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
	if (s->stream.avail_in == 0) {
	    s->z_eof = 1;
	    if (ferror(s->file)) s->z_err = Z_ERRNO;
	    return EOF;
	}
	s->stream.next_in = s->inbuf;
d298 22
a319 12
    /* Check the gzip magic header */
    for (len = 0; len < 2; len++) {
	c = get_byte(s);
	if (c != gz_magic[len]) {
	    if (len != 0) s->stream.avail_in++, s->stream.next_in--;
	    if (c != EOF) {
		s->stream.avail_in++, s->stream.next_in--;
		s->transparent = 1;
	    }
	    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
	    return;
	}
d321 4
d328 2
a329 2
	s->z_err = Z_DATA_ERROR;
	return;
d336 4
a339 4
	len  =  (uInt)get_byte(s);
	len += ((uInt)get_byte(s))<<8;
	/* len is garbage if EOF but the loop below will quit anyway */
	while (len-- != 0 && get_byte(s) != EOF) ;
d342 1
a342 1
	while ((c = get_byte(s)) != 0 && c != EOF) ;
d345 1
a345 1
	while ((c = get_byte(s)) != 0 && c != EOF) ;
d348 1
a348 1
	for (len = 0; len < 2; len++) (void)get_byte(s);
d367 3
a369 3
	if (s->mode == 'w') {
#ifdef NO_DEFLATE
	    err = Z_STREAM_ERROR;
d371 1
a371 1
	    err = deflateEnd(&(s->stream));
d373 3
a375 3
	} else if (s->mode == 'r') {
	    err = inflateEnd(&(s->stream));
	}
d379 1
a379 1
	if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */
d381 1
a381 1
	    err = Z_ERRNO;
d414 12
d428 19
a446 19
	if (s->transparent) {
	    /* Copy first the lookahead bytes: */
	    uInt n = s->stream.avail_in;
	    if (n > s->stream.avail_out) n = s->stream.avail_out;
	    if (n > 0) {
		zmemcpy(s->stream.next_out, s->stream.next_in, n);
		next_out += n;
		s->stream.next_out = next_out;
		s->stream.next_in   += n;
		s->stream.avail_out -= n;
		s->stream.avail_in  -= n;
	    }
	    if (s->stream.avail_out > 0) {
		s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,
					     s->file);
	    }
	    len -= s->stream.avail_out;
	    s->stream.total_in  += (uLong)len;
	    s->stream.total_out += (uLong)len;
d448 2
a449 2
	    return (int)len;
	}
d456 4
a459 4
		if (ferror(s->file)) {
		    s->z_err = Z_ERRNO;
		    break;
		}
d463 2
d466 2
d469 21
a489 26
	if (s->z_err == Z_STREAM_END) {
	    /* Check CRC and original size */
	    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
	    start = s->stream.next_out;

	    if (getLong(s) != s->crc) {
		s->z_err = Z_DATA_ERROR;
	    } else {
	        (void)getLong(s);
                /* The uncompressed length returned by above getlong() may
                 * be different from s->stream.total_out) in case of
		 * concatenated .gz files. Check for such files:
		 */
		check_header(s);
		if (s->z_err == Z_OK) {
		    uLong total_in = s->stream.total_in;
		    uLong total_out = s->stream.total_out;

		    inflateReset(&(s->stream));
		    s->stream.total_in = total_in;
		    s->stream.total_out = total_out;
		    s->crc = crc32(0L, Z_NULL, 0);
		}
	    }
	}
	if (s->z_err != Z_OK || s->z_eof) break;
d511 19
d552 1
a552 1
#ifndef NO_DEFLATE
d559 1
a559 1
    const voidp buf;
d580 2
d583 2
d592 1
d700 1
d702 1
d704 2
a705 2
	/* Ignore the second of two consecutive flushes: */
	if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;
d708 1
a708 1
         * all the available space in the output buffer: 
d711 1
a711 1
 
d728 1
a728 1
#endif /* NO_DEFLATE */
d751 1
a751 1
#ifdef NO_DEFLATE
d755 1
a755 1
	    offset -= s->stream.total_in;
d774 1
a774 1
	return (z_off_t)s->stream.total_in;
d781 1
a781 1
	offset += s->stream.total_out;
d787 1
d792 1
a792 1
	s->stream.total_in = s->stream.total_out = (uLong)offset;
d797 2
a798 2
    if ((uLong)offset >= s->stream.total_out) {
	offset -= s->stream.total_out;
d808 6
d822 1
a822 1
    return (z_off_t)s->stream.total_out;
d832 1
a832 1
    
d837 1
d841 4
a844 8
	
    if (s->startpos == 0) { /* not a compressed file */
	rewind(s->file);
	return 0;
    }

    (void) inflateReset(&s->stream);
    return fseek(s->file, s->startpos, SEEK_SET);
d866 8
a873 2
    
    return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;
d921 2
a922 2
#ifdef NO_DEFLATE
	return Z_STREAM_ERROR;
d928 1
a928 1
        putLong (s->file, s->stream.total_in);
d941 1
a941 1
const char*  ZEXPORT gzerror (file, errnum)
d968 14
@


1.10
log
@Check snprintf() return value for truncation; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.9 2002/12/09 00:45:37 millert Exp $	*/
d85 1
d105 2
a106 1
    s->path = (char*)ALLOC(strlen(path)+1);
d110 1
a110 1
    strcpy(s->path, path); /* do this early for debugging */
d203 1
a203 1
    sprintf(name, "<fd:%d>", fd); /* for debugging */
d861 1
d875 2
a876 1
    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
d878 3
a880 3
    strcpy(s->msg, s->path);
    strcat(s->msg, ": ");
    strcat(s->msg, m);
@


1.9
log
@From Andrushock, s/sucess/success/g
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.8 2002/07/06 00:11:40 millert Exp $	*/
d533 1
a533 1
    (void)vsnprintf(buf, sizeof(buf), format, va);
d536 1
d539 1
a539 2
    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
    if (len <= 0) return 0;
d556 1
a556 1
    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
d561 1
d563 1
a563 2
    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
    if (len <= 0) return 0;
@


1.8
log
@Add some missing checks for malloc() returning NULL.
Noticed by Lars J. Buitinck.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.7 2002/03/12 00:25:57 millert Exp $	*/
d234 1
a234 1
   IN assertion: the stream s has been sucessfully opened for reading.
d259 1
a259 1
    IN assertion: the stream s has already been created sucessfully;
@


1.8.2.1
log
@Pull patch from current:
Fix by millert@@
Check snprintf() return value for truncation.

deraadt@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.10 2003/02/27 17:29:35 millert Exp $	*/
d533 1
a533 1
    len = vsnprintf(buf, sizeof(buf), format, va);
a535 1
    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
d538 2
a539 1
    if (len <= 0 || len >= sizeof(buf)) return 0;
d556 1
a556 1
    len = snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
d561 1
d563 1
a563 2
#endif
    if (len <= 0 || len >= sizeof(buf)) return 0;
@


1.7
log
@Update to zlib-1.1.4
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.6 2001/09/19 10:58:07 mpech Exp $	*/
d684 1
d727 1
d867 1
a867 1
    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);
d873 1
@


1.6
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.5 2000/03/02 00:29:52 todd Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-1998 Jean-loup Gailly.
@


1.6.2.1
log
@Pull in patch from current:
Fix (millert):
Update to zlib-1.1.4
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.7 2002/03/12 00:25:57 millert Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-2002 Jean-loup Gailly.
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: gzio.c,v 1.4 1998/08/08 20:57:14 millert Exp $	*/
d845 1
a845 1
     Returns the error message for the last error which occured on the
d847 1
a847 1
   error occured in the file system and not in the compression library,
@


1.4
log
@zlib 1.1.3
@
text
@d1 1
a8 1
/* @@(#) $Id$ */
@


1.3
log
@zlib 1.0.4
@
text
@d2 1
a2 1
 * Copyright (C) 1995-1996 Jean-loup Gailly.
d4 2
d8 1
a8 1
/* $Id: gzio.c,v 1.14 1996/07/24 13:41:01 me Exp $ */
d16 10
a25 1
#define Z_BUFSIZE 4096
d52 1
d57 1
d80 1
d116 4
d127 3
d131 1
a131 1
                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, 0);
d135 1
a135 1

a139 1
        err = inflateInit2(&(s->stream), -MAX_WBITS);
d142 7
d156 1
a156 1
    s->file = fd < 0 ? FOPEN(path, fmode) : (FILE*)fdopen(fd, fmode);
d166 6
d174 1
d176 1
d183 1
a183 1
gzFile gzopen (path, mode)
d194 1
a194 1
gzFile gzdopen (fd, mode)
d207 25
d275 5
a279 2
	    s->transparent = 1;
	    if (c != EOF) s->stream.avail_in++, s->stream.next_in--;
d326 9
a334 5
       if (s->mode == 'w') {
           err = deflateEnd(&(s->stream));
       } else if (s->mode == 'r') {
           err = inflateEnd(&(s->stream));
       }
d337 4
a340 1
        err = Z_ERRNO;
d355 1
a355 1
int gzread (file, buf, len)
d361 1
a361 1
    Bytef *start = buf; /* starting point for crc computation */
d369 2
a370 1
    s->stream.next_out = next_out = buf;
d391 5
a395 1
	    return (int)(len - s->stream.avail_out);
d417 1
a417 1
	    if (getLong(s) != s->crc || getLong(s) != s->stream.total_out) {
d420 5
a424 1
		/* Check for concatenated .gz files: */
d427 3
d431 2
d444 38
d486 1
a486 1
int gzwrite (file, buf, len)
d495 1
a495 1
    s->stream.next_in = buf;
d512 1
a512 1
    s->crc = crc32(s->crc, buf, len);
d518 79
a598 2
     gzflush should be called only when strictly necessary because it can
   degrade compression.
d600 1
a600 1
int gzflush (file, flush)
d626 3
d636 11
d650 135
d801 2
a802 1
   Reads a long in LSB order from the given gz_stream. Sets 
d822 1
a822 1
int gzclose (file)
d831 5
a835 2
        err = gzflush (file, Z_FINISH);
        if (err != Z_OK) return destroy(file);
d839 1
a839 1

d841 1
a841 1
    return destroy(file);
d851 1
a851 1
const char*  gzerror (file, errnum)
@


1.2
log
@Adds gz_iszipped() function.
@
text
@d6 1
a6 1
/* $Id: gzio.c,v 1.1 1996/07/27 02:39:45 tholo Exp $ */
d499 1
a499 1
char*  gzerror (file, errnum)
d508 1
a508 1
        return ERR_MSG(Z_STREAM_ERROR);
d511 1
a511 1
    if (*errnum == Z_OK) return (char*)"";
d515 1
a515 1
    if (m == NULL || *m == '\0') m = ERR_MSG(s->z_err);
d522 1
a522 12
    return s->msg;
}

/* ===========================================================================
     Returns true (1) if file is zipped, else returns false (0).
*/
int  gz_iszipped (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;

    return(!(s->transparent));
@


1.1
log
@Integrate zlib v1.0.3
@
text
@d6 1
a6 1
/* $Id: gzio.c,v 1.13 1996/05/22 11:52:24 me Exp $ */
d523 11
@
