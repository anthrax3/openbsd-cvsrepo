head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.48
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.46
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.42
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.44
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.36
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.40
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.38
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.34
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.32
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.30
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.28
	OPENBSD_5_0:1.9.0.26
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.24
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.22
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.18
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.20
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.16
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.14
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.12
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.10
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.8
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.07.20.15.56.42;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.03.03.06.37;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.16.22.33.02;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.12.00.25.58;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.02.00.29.52;	author todd;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	98.09.08.04.05.19;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.08.08.20.57.34;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.19.17.11.26;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.07.27.02.39.51;	author tholo;	state Exp;
branches;
next	;

1.5.8.1
date	2002.03.13.16.07.26;	author jason;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to zlib 1.2.3; OK deraadt@@
@
text
@/*	$OpenBSD: zutil.h,v 1.8 2004/12/03 03:06:37 djm Exp $	*/
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */


#ifndef ZUTIL_H
#define ZUTIL_H

#define ZLIB_INTERNAL
#include "zlib.h"

#ifdef _STANDALONE
#include <stand.h>
#else
#ifdef STDC
#  ifndef _WIN32_WCE
#    include <stddef.h>
#  endif
#  include <string.h>
#  include <stdlib.h>
#endif
#ifdef NO_ERRNO_H
#   ifdef _WIN32_WCE
      /* The Microsoft C Run-Time Library for Windows CE doesn't have
       * errno.  We define it as a global variable to simplify porting.
       * Its value is always 0 and should not be used.  We rename it to
       * avoid conflict with other libraries that use the same workaround.
       */
#     define errno z_errno
#   endif
    extern int errno;
#else
#  ifndef _WIN32_WCE
#    include <errno.h>
#  endif
#endif
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = (char*)ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
#  define OS_CODE  0x00
#  if defined(__TURBOC__) || defined(__BORLANDC__)
#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
       /* Allow compilation with ANSI keywords only enabled */
       void _Cdecl farfree( void *block );
       void *_Cdecl farmalloc( unsigned long nbytes );
#    else
#      include <alloc.h>
#    endif
#  else /* MSC or DJGPP */
#    include <malloc.h>
#  endif
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#ifdef OS2
#  define OS_CODE  0x06
#  ifdef M_I86
     #include <malloc.h>
#  endif
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#    include <unix.h> /* for fdopen */
#  else
#    ifndef fdopen
#      define fdopen(fd,mode) NULL /* No fdopen() */
#    endif
#  endif
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#ifdef WIN32
#  ifndef __CYGWIN__  /* Cygwin is Unix, not Win32 */
#    define OS_CODE  0x0b
#  endif
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0f
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600))
#  if defined(_WIN32_WCE)
#    define fdopen(fd,mode) NULL /* No fdopen() */
#    ifndef _PTRDIFF_T_DEFINED
       typedef int ptrdiff_t;
#      define _PTRDIFF_T_DEFINED
#    endif
#  else
#    define fdopen(fd,type)  _fdopen(fd,type)
#  endif
#endif

        /* common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif
#if defined(__CYGWIN__)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif
#ifndef HAVE_VSNPRINTF
#  ifdef MSDOS
     /* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
        but for now we just assume it doesn't. */
#    define NO_vsnprintf
#  endif
#  ifdef __TURBOC__
#    define NO_vsnprintf
#  endif
#  ifdef WIN32
     /* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
#      define vsnprintf _vsnprintf
#    endif
#  endif
#  ifdef __SASC
#    define NO_vsnprintf
#  endif
#endif
#ifdef VMS
#  define NO_vsnprintf
#endif

#if defined(pyr)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
   extern void zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  include <stdio.h>
   extern int z_verbose;
   extern void z_error    OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif


voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
void   zcfree  OF((voidpf opaque, voidpf ptr));

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

#endif /* ZUTIL_H */
@


1.8
log
@update to zlib-1.21 (we already have the CAN-2004-0797 security fixes)
"in it goes" deraadt@@, in the near-total absence of feedback from others
@
text
@d1 1
a1 1
/*	$OpenBSD: zutil.h,v 1.7 2003/12/16 22:33:02 henning Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-2003 Jean-loup Gailly.
d23 3
a25 1
#  include <stddef.h>
d30 8
d40 3
a42 1
#   include <errno.h>
d124 3
a212 9
#endif

#ifdef HAVE_STRERROR
#  ifndef VMS
     extern char *strerror OF((int));
#  endif
#  define zstrerror(errnum) strerror(errnum)
#else
#  define zstrerror(errnum) ""
@


1.7
log
@update to zlib 1.2.1

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zutil.h,v 1.6 2002/03/12 00:25:58 millert Exp $	*/
d196 3
d201 3
a203 1
   extern char *strerror OF((int));
@


1.6
log
@Update to zlib-1.1.4
@
text
@d1 1
a1 1
/*	$OpenBSD: zutil.h,v 1.5 2000/03/02 00:29:52 todd Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-2002 Jean-loup Gailly.
d13 2
a14 2
#ifndef _Z_UTIL_H
#define _Z_UTIL_H
d16 1
d45 1
a45 1
extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
d81 1
a81 1
#ifdef MSDOS
d89 1
a89 1
#     include <alloc.h>
d96 2
a97 6
#ifdef OS2
#  define OS_CODE  0x06
#endif

#ifdef WIN32 /* Window 95 & Windows NT */
#  define OS_CODE  0x0b
d106 2
a107 2
#ifdef AMIGA
#  define OS_CODE  0x01
d110 2
a111 2
#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
d125 8
a132 2
#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0F
d135 2
a136 2
#ifdef TOPS20
#  define OS_CODE  0x0a
d144 9
a152 1
#  define fdopen(fd,type)  _fdopen(fd,type)
d155 1
a155 2

        /* Common defaults */
d167 30
a253 2
typedef uLong (ZEXPORT *check_func) OF((uLong check, const Bytef *buf,
				       uInt len));
d262 1
a262 1
#endif /* _Z_UTIL_H */
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: zutil.h,v 1.4 1998/09/08 04:05:19 millert Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-1998 Jean-loup Gailly.
@


1.5.8.1
log
@Pull in patch from current:
Fix (millert):
Update to zlib-1.1.4
@
text
@d1 1
a1 1
/*	$OpenBSD: zutil.h,v 1.6 2002/03/12 00:25:58 millert Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-2002 Jean-loup Gailly.
@


1.4
log
@include stand.h if -D_STANDALONE
@
text
@d1 1
a11 1
/* @@(#) $Id: zutil.h,v 1.3 1998/08/08 20:57:34 millert Exp $ */
@


1.3
log
@zlib 1.1.3
@
text
@d11 1
a11 1
/* @@(#) $Id$ */
d18 3
d30 1
@


1.2
log
@zlib 1.0.4
@
text
@d2 1
a2 1
 * Copyright (C) 1995-1996 Jean-loup Gailly.
d11 1
a11 1
/* $Id: zutil.h,v 1.16 1996/07/24 13:41:13 me Exp $ */
a17 6
#if defined(MSDOS)||defined(VMS)||defined(CRAY)||defined(WIN32)||defined(RISCOS)
#   include <stddef.h>
#   include <errno.h>
#else
    extern int errno;
#endif
d19 1
d23 5
d78 8
a85 2
#  ifdef __TURBOC__
#    include <alloc.h>
d101 1
a101 1
#  define FOPEN(name, mode) \
d113 1
a113 1
#ifdef MACOS
d115 7
d136 5
d147 2
a148 2
#ifndef FOPEN
#  define FOPEN(name, mode) fopen((name), (mode))
d163 1
a163 1
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(_MSC_VER)
d166 1
d184 2
a185 2
   extern void zmemcpy  OF((Bytef* dest, Bytef* source, uInt len));
   extern int  zmemcmp  OF((Bytef* s1,   Bytef* s2, uInt len));
d192 1
a192 3
#  ifndef verbose
#    define verbose 0
#  endif
d195 5
a199 5
#  define Trace(x) fprintf x
#  define Tracev(x) {if (verbose) fprintf x ;}
#  define Tracevv(x) {if (verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
d210 2
a211 2
typedef uLong (*check_func) OF((uLong check, const Bytef *buf, uInt len));

@


1.1
log
@Integrate zlib v1.0.3
@
text
@d11 1
a11 1
/* $Id: zutil.h,v 1.15 1996/07/02 12:41:25 me Exp $ */
d18 1
a18 1
#if defined(MSDOS) || defined(VMS) || defined(CRAY) || defined(WIN32)
d43 1
a43 1
#define ERR_MSG(err) (char*)z_errmsg[Z_NEED_DICT-(err)]
d46 1
a46 1
  return (strm->msg = ERR_MSG(err), (err))
d119 1
a119 1
#ifdef _BEOS_
d176 1
a193 2

extern void z_error    OF((char *m));
@
