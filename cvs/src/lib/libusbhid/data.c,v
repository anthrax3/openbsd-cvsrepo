head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.14
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.6.0.10
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.0.2
	OPENBSD_3_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.06.04.12.13.30;	author mpi;	state Exp;
branches;
next	1.7;
commitid	vNYC9qqjEjbRUMPa;

1.7
date	2014.05.12.17.03.28;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2012.07.16.19.57.17;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.12.10.17.43;	author yuo;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.11.13.43.54;	author yuo;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.04.00.47.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.10.00.09.17;	author nate;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.30.07.04.38;	author pvalchev;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Do not skip or add a byte for the report ID when manipulating data.

This is not compatible to our current schema where one kernel device
is attached per report ID of every USB HID device since the drivers
already strip the data buffers.

Fix a parsing issue reported by henning@@
@
text
@/*	$OpenBSD: data.c,v 1.7 2014/05/12 17:03:28 mpi Exp $	*/
/*	$NetBSD: data.c,v 1.1 2001/12/28 17:45:26 augustss Exp $	*/

/*
 * Copyright (c) 1999 Lennart Augustsson <augustss@@netbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdlib.h>
#include "usbhid.h"

int32_t
hid_get_data(const void *p, const hid_item_t *h)
{
	const uint8_t *buf;
	uint32_t hpos;
	uint32_t hsize;
	uint32_t data;
	int i, end, offs;

	buf = p;

#if 0
	/* Skip report ID byte. */
	if (h->report_ID > 0)
		buf++;
#endif

	hpos = h->pos;			/* bit position of data */
	hsize = h->report_size;		/* bit length of data */

	/* Range check and limit */
	if (hsize == 0)
		return (0);
	if (hsize > 32)
		hsize = 32;

	offs = hpos / 8;
	end = (hpos + hsize) / 8 - offs;
	data = 0;
	for (i = 0; i <= end; i++)
		data |= buf[offs + i] << (i*8);

	/* Correctly shift down data */
	data >>= hpos % 8;
	hsize = 32 - hsize;

	/* Mask and sign extend in one */
	if ((h->logical_minimum < 0) || (h->logical_maximum < 0))
		data = (int32_t)((int32_t)data << hsize) >> hsize;
	else
		data = (uint32_t)((uint32_t)data << hsize) >> hsize;

	return (data);
}

void
hid_set_data(void *p, const hid_item_t *h, int32_t data)
{
	uint8_t *buf;
	uint32_t hpos;
	uint32_t hsize;
	uint32_t mask;
	int i;
	int end;
	int offs;

	buf = p;

#if 0
	/* Set report ID byte. */
	if (h->report_ID > 0)
		*buf++ = h->report_ID & 0xff;
#endif

	hpos = h->pos;			/* bit position of data */
	hsize = h->report_size;		/* bit length of data */

	if (hsize != 32) {
		mask = (1 << hsize) - 1;
		data &= mask;
	} else
		mask = ~0;

	data <<= (hpos % 8);
	mask <<= (hpos % 8);
	mask = ~mask;

	offs = hpos / 8;
	end = (hpos + hsize) / 8 - offs;

	for (i = 0; i <= end; i++)
		buf[offs + i] = (buf[offs + i] & (mask >> (i*8))) |
		    ((data >> (i*8)) & 0xff);
}
@


1.7
log
@Keep libusbhid's HID parser in sync with the kernel one.  This is mostly
a backport from FreeBSD's r205728, r224511 and 225839 without the new
functions to set/get a report ID nor the usbhidctl(1) & usbhidaction(1)
bits.

Committing now to open the "Monday's Bump Parade".
@
text
@d1 1
a1 1
/*	$OpenBSD: data.c,v 1.6 2012/07/16 19:57:17 jasper Exp $	*/
d44 1
d48 1
d91 1
d95 1
@


1.6
log
@revert previous, it was hardly tested and is causing too many issues too close to release.

as discussed with and ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: data.c,v 1.3 2004/06/04 00:47:32 deraadt Exp $	*/
d33 1
a33 1
int
d36 5
a40 3
	const unsigned char *buf = p;
	unsigned int hpos = h->pos, hsize = h->report_size;
	int data, i, end, offs;
d42 10
d54 3
d62 2
d65 8
a72 6
	data &= (1 << hsize) - 1;
	if (h->logical_minimum < 0) {
		/* Need to sign extend */
		hsize = sizeof data * 8 - hsize;
		data = (data << hsize) >> hsize;
	}
d77 1
a77 1
hid_set_data(void *p, const hid_item_t *h, int data)
d79 16
a94 3
	unsigned char *buf = p;
	unsigned int hpos = h->pos, hsize = h->report_size;
	int i, end, offs, mask;
@


1.5
log
@add support to get signed/unsigned HID data
@
text
@d1 1
a1 1
/*	$OpenBSD: data.c,v 1.4 2012/07/11 13:43:54 yuo Exp $	*/
d36 3
a38 12
	const uint8_t *buf;
	uint32_t hpos, hsize, data;
	int i, end, offs;

	buf = p;

	/* skip report ID byte */
	if (h->report_ID > 0)
		buf++;

	hpos = h->pos;		/* bit position of data */
	hsize = h->report_size;	/* bit length of data */
a41 3
	if (hsize > 32)
		hsize = 32;

a46 2

	/* Correctly shift down data */
d48 6
a53 8
	hsize = 32 - hsize;

	/* Mask and sign extend in one */
	if ((h->logical_minimum < 0) || (h->logical_maximum < 0))
		data = (int32_t)((int32_t)data << hsize) >> hsize;
	else
		data = (uint32_t)((uint32_t)data << hsize) >> hsize;

d60 2
a61 2
	uint32_t *buf;
	uint32_t hpos, hsize;
a62 9

	buf = p;

	/* Set report ID byte */
	if (h->report_ID > 0)
		*buf++ = h->report_ID & 0xff;

	hpos = h->pos;		/* bit position of data */
	hsize = h->report_size;	/* bit length of data */
@


1.4
log
@- port multiple report ID support for HID parser from FreeBSD code
 (rev. 205728, 224511 and 225839)

- add hid_get_report_id(3) to get id of a descriptor.

- crank the major in shlib_version 3.0 -> 4.0

ok deraadt@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: data.c,v 1.3 2004/06/04 00:47:32 deraadt Exp $	*/
d60 1
d62 7
a68 1
	data &= (1 << hsize) - 1;
a69 5
	if (h->logical_minimum < 0) {
		/* Need to sign extend */
		hsize = sizeof data * 8 - hsize;
		data = (data << hsize) >> hsize;
	}
@


1.3
log
@knf + new interface: hid_start() is non-exit non-stderr spewing version of hid_init(); ok matthieu millert
@
text
@d1 1
a1 1
/*	$OpenBSD: data.c,v 1.2 2002/05/10 00:09:17 nate Exp $	*/
d36 12
a47 3
	const unsigned char *buf = p;
	unsigned int hpos = h->pos, hsize = h->report_size;
	int data, i, end, offs;
d51 3
d59 1
d62 1
d74 2
a75 2
	unsigned char *buf = p;
	unsigned int hpos = h->pos, hsize = h->report_size;
d77 9
@


1.2
log
@Update usb userland stuff to reflect hid changes in the kernel.
This adds the new program usbhidaction which can be used to assign actions
to events that occur on a uhid device.  For example, you can now make the
volume buttons on some newer keyboards actually do something.
@
text
@d1 1
a1 1
/*	$OpenBSD: data.c,v 1.1 2001/12/30 07:04:38 pvalchev Exp $	*/
d36 3
a38 9
	const unsigned char *buf;
	unsigned int hpos;
	unsigned int hsize;
	int data;
	int i, end, offs;

	buf = p;
	hpos = h->pos;			/* bit position of data */
	hsize = h->report_size;		/* bit length of data */
d60 2
a61 3
	unsigned char *buf;
	unsigned int hpos;
	unsigned int hsize;
a63 4
	buf = p;
	hpos = h->pos;			/* bit position of data */
	hsize = h->report_size;		/* bit length of data */

d79 1
a79 1
			((data >> (i*8)) & 0xff);
@


1.1
log
@Rename libusb to libusbhid, a better name, per NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: data.c,v 1.1 2001/09/02 17:50:40 pvalchev Exp $	*/
/*	$NetBSD: data.c,v 1.8 2000/04/02 11:10:53 augustss Exp $	*/
@

