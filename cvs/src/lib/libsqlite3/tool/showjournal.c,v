head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.2.0.8
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.4
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.6
	OPENBSD_5_8_BASE:1.1.1.2
	sqlite_3_8_9:1.1.1.2
	sqlite_3_8_8_3:1.1.1.2
	sqlite_3_8_7_4:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	sqlite_3_8_6:1.1.1.2
	OPENBSD_5_6:1.1.1.1.0.12
	OPENBSD_5_6_BASE:1.1.1.1
	sqlite_3_8_4_3:1.1.1.1
	sqlite_3_8_4:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.10
	OPENBSD_5_5_BASE:1.1.1.1
	sqlite_3_8_0_2:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.6
	OPENBSD_5_4_BASE:1.1.1.1
	sqlite_3_7_17:1.1.1.1
	sqlite_3_7_15_2:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.4
	OPENBSD_5_3_BASE:1.1.1.1
	sqlite_3_7_14_1:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.2
	OPENBSD_5_2_BASE:1.1.1.1
	sqlite_3_7_13:1.1.1.1
	sqlite_3_7_12_1:1.1.1.1
	sqlite_3_7_12:1.1.1.1
	sqlite_3_7_11:1.1.1.1
	sqlite3:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2012.04.14.13.13.17;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.04.14.13.13.17;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.09.29.22.56.13;	author jturner;	state Exp;
branches;
next	;
commitid	EgaYTAubI6bUPDKk;


desc
@@


1.1
log
@Initial revision
@
text
@/*
** A utility for printing an SQLite database journal.
*/
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

/*
** state information
*/
static int pageSize = 1024;
static int sectorSize = 512;
static FILE *db = 0;
static int showPageContent = 0;
static int fileSize = 0;
static unsigned cksumNonce = 0;

/* Report a memory allocation error */
static void out_of_memory(void){
  fprintf(stderr,"Out of memory...\n");
  exit(1);
}

/*
** Read N bytes of memory starting at iOfst into space obtained
** from malloc().
*/
static char *read_content(int N, int iOfst){
  int got;
  char *pBuf = malloc(N);
  if( pBuf==0 ) out_of_memory();
  fseek(db, iOfst, SEEK_SET);
  got = fread(pBuf, 1, N, db);
  if( got<0 ){
    fprintf(stderr, "I/O error reading %d bytes from %d\n", N, iOfst);
    memset(pBuf, 0, N);
  }else if( got<N ){
    fprintf(stderr, "Short read: got only %d of %d bytes from %d\n",
                     got, N, iOfst);
    memset(&pBuf[got], 0, N-got);
  }
  return pBuf;
}

/* Print a line of decode output showing a 4-byte integer.
*/
static unsigned print_decode_line(
  unsigned char *aData,      /* Content being decoded */
  int ofst, int nByte,       /* Start and size of decode */
  const char *zMsg           /* Message to append */
){
  int i, j;
  unsigned val = aData[ofst];
  char zBuf[100];
  sprintf(zBuf, " %03x: %02x", ofst, aData[ofst]);
  i = strlen(zBuf);
  for(j=1; j<4; j++){
    if( j>=nByte ){
      sprintf(&zBuf[i], "   ");
    }else{
      sprintf(&zBuf[i], " %02x", aData[ofst+j]);
      val = val*256 + aData[ofst+j];
    }
    i += strlen(&zBuf[i]);
  }
  sprintf(&zBuf[i], "   %10u", val);
  printf("%s  %s\n", zBuf, zMsg);
  return val;
}

/*
** Read and print a journal header.  Store key information (page size, etc)
** in global variables.
*/
static unsigned decode_journal_header(int iOfst){
  char *pHdr = read_content(64, iOfst);
  unsigned nPage;
  printf("Header at offset %d:\n", iOfst);
  print_decode_line(pHdr, 0, 4, "Header part 1 (3654616569)");
  print_decode_line(pHdr, 4, 4, "Header part 2 (547447767)");
  nPage =
  print_decode_line(pHdr, 8, 4, "page count");
  cksumNonce =
  print_decode_line(pHdr, 12, 4, "chksum nonce");
  print_decode_line(pHdr, 16, 4, "initial database size in pages");
  sectorSize =
  print_decode_line(pHdr, 20, 4, "sector size");
  pageSize =
  print_decode_line(pHdr, 24, 4, "page size");
  print_decode_line(pHdr, 28, 4, "zero");
  print_decode_line(pHdr, 32, 4, "zero");
  print_decode_line(pHdr, 36, 4, "zero");
  print_decode_line(pHdr, 40, 4, "zero");
  free(pHdr);
  return nPage;
}

static void print_page(int iOfst){
  unsigned char *aData;
  char zTitle[50];
  aData = read_content(pageSize+8, iOfst);
  sprintf(zTitle, "page number for page at offset %d", iOfst);
  print_decode_line(aData, 0, 4, zTitle);
  free(aData);
}

int main(int argc, char **argv){
  int rc;
  int nPage, cnt;
  int iOfst;
  if( argc!=2 ){
    fprintf(stderr,"Usage: %s FILENAME\n", argv[0]);
    exit(1);
  }
  db = fopen(argv[1], "rb");
  if( db==0 ){
    fprintf(stderr,"%s: can't open %s\n", argv[0], argv[1]);
    exit(1);
  }
  fseek(db, 0, SEEK_END);
  fileSize = ftell(db);
  printf("journal file size: %d bytes\n", fileSize);
  fseek(db, 0, SEEK_SET);
  iOfst = 0;
  while( iOfst<fileSize ){
    cnt = nPage = (int)decode_journal_header(iOfst);
    if( cnt==0 ){
      cnt = (fileSize - sectorSize)/(pageSize+8);
    }
    iOfst += sectorSize;
    while( cnt && iOfst<fileSize ){
      print_page(iOfst);
      iOfst += pageSize+8;
    }
    iOfst = (iOfst/sectorSize + 1)*sectorSize;
  }
  fclose(db);
}
@


1.1.1.1
log
@sqlite 3.7.11 library, vendor sources
@
text
@@


1.1.1.2
log
@Update sqlite3 to 3.8.6. A list of changes are available here:
http://sqlite.org/releaselog/3_8_6.html.

Tested in a bulk and ok landry@@
@
text
@d15 1
d29 1
a29 1
static unsigned char *read_content(int N, int iOfst){
d31 1
a31 1
  unsigned char *pBuf = malloc(N);
d49 3
a51 3
  const unsigned char *aData,  /* Content being decoded */
  int ofst, int nByte,         /* Start and size of decode */
  const char *zMsg             /* Message to append */
d56 1
a56 1
  sprintf(zBuf, " %05x: %02x", ofst, aData[ofst]);
d77 1
a77 1
  unsigned char *pHdr = read_content(64, iOfst);
d104 1
a104 1
  print_decode_line(aData-iOfst, iOfst, 4, zTitle);
d109 1
a138 1
  return 0;
@

