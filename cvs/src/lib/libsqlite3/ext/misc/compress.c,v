head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.2.0.6
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.2
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.4
	OPENBSD_5_8_BASE:1.1.1.2
	sqlite_3_8_9:1.1.1.2
	sqlite_3_8_8_3:1.1.1.1
	sqlite_3_8_7_4:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.2
	OPENBSD_5_7_BASE:1.1.1.1
	sqlite_3_8_6:1.1.1.1
	sqlite3:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2014.09.29.22.56.01;	author jturner;	state Exp;
branches
	1.1.1.1;
next	;
commitid	EgaYTAubI6bUPDKk;

1.1.1.1
date	2014.09.29.22.56.01;	author jturner;	state Exp;
branches;
next	1.1.1.2;
commitid	EgaYTAubI6bUPDKk;

1.1.1.2
date	2015.04.19.14.21.38;	author jturner;	state Exp;
branches;
next	;
commitid	lYm71IL7iNcGJ6xR;


desc
@@


1.1
log
@Initial revision
@
text
@/*
** 2014-06-13
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements SQL compression functions
** compress() and uncompress() using ZLIB.
*/
#include "sqlite3ext.h"
SQLITE_EXTENSION_INIT1
#include <zlib.h>

/*
** Implementation of the "compress(X)" SQL function.  The input X is
** compressed using zLib and the output is returned.
**
** The output is a BLOB that begins with a variable-length integer that
** is the input size in bytes (the size of X before compression).  The
** variable-length integer is implemented as 1 to 5 bytes.  There are
** seven bits per integer stored in the lower seven bits of each byte.
** More significant bits occur first.  The most significant bit (0x80)
** is a flag to indicate the end of the integer.
*/
static void compressFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *pIn;
  unsigned char *pOut;
  unsigned int nIn;
  unsigned long int nOut;
  unsigned char x[8];
  int i, j;

  pIn = sqlite3_value_blob(argv[0]);
  nIn = sqlite3_value_bytes(argv[0]);
  nOut = 13 + nIn + (nIn+999)/1000;
  pOut = sqlite3_malloc( nOut+5 );
  for(i=4; i>=0; i--){
    x[i] = (nIn >> (7*(4-i)))&0x7f;
  }
  for(i=0; i<4 && x[i]==0; i++){}
  for(j=0; i<=4; i++, j++) pOut[j] = x[i];
  pOut[j-1] |= 0x80;
  compress(&pOut[j], &nOut, pIn, nIn);
  sqlite3_result_blob(context, pOut, nOut+j, sqlite3_free);
}

/*
** Implementation of the "uncompress(X)" SQL function.  The argument X
** is a blob which was obtained from compress(Y).  The output will be
** the value Y.
*/
static void uncompressFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *pIn;
  unsigned char *pOut;
  unsigned int nIn;
  unsigned long int nOut;
  int rc;
  int i;

  pIn = sqlite3_value_blob(argv[0]);
  nIn = sqlite3_value_bytes(argv[0]);
  nOut = 0;
  for(i=0; i<nIn && i<5; i++){
    nOut = (nOut<<7) | (pIn[i]&0x7f);
    if( (pIn[i]&0x80)!=0 ){ i++; break; }
  }
  pOut = sqlite3_malloc( nOut+1 );
  rc = uncompress(pOut, &nOut, &pIn[i], nIn-i);
  if( rc==Z_OK ){
    sqlite3_result_blob(context, pOut, nOut, sqlite3_free);
  }
}


#ifdef _WIN32
__declspec(dllexport)
#endif
int sqlite3_compress_init(
  sqlite3 *db, 
  char **pzErrMsg, 
  const sqlite3_api_routines *pApi
){
  int rc = SQLITE_OK;
  SQLITE_EXTENSION_INIT2(pApi);
  (void)pzErrMsg;  /* Unused parameter */
  rc = sqlite3_create_function(db, "compress", 1, SQLITE_UTF8, 0,
                               compressFunc, 0, 0);
  if( rc==SQLITE_OK ){
    rc = sqlite3_create_function(db, "uncompress", 1, SQLITE_UTF8, 0,
                                 uncompressFunc, 0, 0);
  }
  return rc;
}
@


1.1.1.1
log
@Update sqlite3 to 3.8.6. A list of changes are available here:
http://sqlite.org/releaselog/3_8_6.html.

Tested in a bulk and ok landry@@
@
text
@@


1.1.1.2
log
@Update sqlite3 to 3.8.9. Changes available here:
http://sqlite.org/releaselog/3_8_9.html

Tested in bulk and ok landry@@
@
text
@a40 1
  int rc;
d53 2
a54 6
  rc = compress(&pOut[j], &nOut, pIn, nIn);
  if( rc==Z_OK ){
    sqlite3_result_blob(context, pOut, nOut+j, sqlite3_free);
  }else{
    sqlite3_free(pOut);
  }
a84 2
  }else{
    sqlite3_free(pOut);
@

