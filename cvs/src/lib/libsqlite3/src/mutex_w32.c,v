head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.4
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.1.1.8.0.4
	OPENBSD_5_8_BASE:1.1.1.8
	sqlite_3_8_9:1.1.1.8
	sqlite_3_8_8_3:1.1.1.7
	sqlite_3_8_7_4:1.1.1.6
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	sqlite_3_8_6:1.1.1.5
	OPENBSD_5_6:1.1.1.4.0.4
	OPENBSD_5_6_BASE:1.1.1.4
	sqlite_3_8_4_3:1.1.1.4
	sqlite_3_8_4:1.1.1.4
	OPENBSD_5_5:1.1.1.3.0.8
	OPENBSD_5_5_BASE:1.1.1.3
	sqlite_3_8_0_2:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.4
	OPENBSD_5_4_BASE:1.1.1.3
	sqlite_3_7_17:1.1.1.3
	sqlite_3_7_15_2:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.2
	OPENBSD_5_3_BASE:1.1.1.3
	sqlite_3_7_14_1:1.1.1.3
	OPENBSD_5_2:1.1.1.2.0.2
	OPENBSD_5_2_BASE:1.1.1.2
	sqlite_3_7_13:1.1.1.2
	sqlite_3_7_12_1:1.1.1.1
	sqlite_3_7_12:1.1.1.1
	sqlite_3_7_11:1.1.1.1
	sqlite3:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2015.12.23.20.07.37;	author jturner;	state Exp;
branches;
next	1.2;
commitid	0BPXWRtlG51z3eXf;

1.2
date	2015.09.12.02.08.35;	author jturner;	state Exp;
branches;
next	1.1;
commitid	1p2nIN8G7Ftfeiww;

1.1
date	2012.04.14.13.13.11;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.04.14.13.13.11;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.06.22.17.48.17;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.11.29.05.10.15;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.03.24.01.37.37;	author jturner;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.09.29.22.56.05;	author jturner;	state Exp;
branches;
next	1.1.1.6;
commitid	EgaYTAubI6bUPDKk;

1.1.1.6
date	2015.03.16.00.06.43;	author jturner;	state Exp;
branches;
next	1.1.1.7;
commitid	7NgmCduQCVQ2Dyrr;

1.1.1.7
date	2015.04.04.23.24.52;	author jturner;	state Exp;
branches;
next	1.1.1.8;
commitid	EIMtpJwjH1YSLvhn;

1.1.1.8
date	2015.04.19.14.21.42;	author jturner;	state Exp;
branches;
next	;
commitid	lYm71IL7iNcGJ6xR;


desc
@@


1.3
log
@Update sqlite3 to 3.9.2. Bump major, regen .pc and header. Changes
available here: http://sqlite.org/changes.html

Tested in bulk by aja@@. ok landry@@
@
text
@/*
** 2007 August 14
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains the C functions that implement mutexes for Win32.
*/
#include "sqliteInt.h"

#if SQLITE_OS_WIN
/*
** Include code that is common to all os_*.c files
*/
#include "os_common.h"

/*
** Include the header file for the Windows VFS.
*/
#include "os_win.h"
#endif

/*
** The code in this file is only used if we are compiling multithreaded
** on a Win32 system.
*/
#ifdef SQLITE_MUTEX_W32

/*
** Each recursive mutex is an instance of the following structure.
*/
struct sqlite3_mutex {
  CRITICAL_SECTION mutex;    /* Mutex controlling the lock */
  int id;                    /* Mutex type */
#ifdef SQLITE_DEBUG
  volatile int nRef;         /* Number of enterances */
  volatile DWORD owner;      /* Thread holding this mutex */
  volatile int trace;        /* True to trace changes */
#endif
};

/*
** These are the initializer values used when declaring a "static" mutex
** on Win32.  It should be noted that all mutexes require initialization
** on the Win32 platform.
*/
#define SQLITE_W32_MUTEX_INITIALIZER { 0 }

#ifdef SQLITE_DEBUG
#define SQLITE3_MUTEX_INITIALIZER { SQLITE_W32_MUTEX_INITIALIZER, 0, \
                                    0L, (DWORD)0, 0 }
#else
#define SQLITE3_MUTEX_INITIALIZER { SQLITE_W32_MUTEX_INITIALIZER, 0 }
#endif

#ifdef SQLITE_DEBUG
/*
** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are
** intended for use only inside assert() statements.
*/
static int winMutexHeld(sqlite3_mutex *p){
  return p->nRef!=0 && p->owner==GetCurrentThreadId();
}

static int winMutexNotheld2(sqlite3_mutex *p, DWORD tid){
  return p->nRef==0 || p->owner!=tid;
}

static int winMutexNotheld(sqlite3_mutex *p){
  DWORD tid = GetCurrentThreadId();
  return winMutexNotheld2(p, tid);
}
#endif

/*
** Try to provide a memory barrier operation, needed for initialization
** and also for the xShmBarrier method of the VFS in cases when SQLite is
** compiled without mutexes (SQLITE_THREADSAFE=0).
*/
void sqlite3MemoryBarrier(void){
#if defined(SQLITE_MEMORY_BARRIER)
  SQLITE_MEMORY_BARRIER;
#elif defined(__GNUC__)
  __sync_synchronize();
#elif !defined(SQLITE_DISABLE_INTRINSIC) && \
      defined(_MSC_VER) && _MSC_VER>=1300
  _ReadWriteBarrier();
#elif defined(MemoryBarrier)
  MemoryBarrier();
#endif
}

/*
** Initialize and deinitialize the mutex subsystem.
*/
static sqlite3_mutex winMutex_staticMutexes[] = {
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER
};

static int winMutex_isInit = 0;
static int winMutex_isNt = -1; /* <0 means "need to query" */

/* As the winMutexInit() and winMutexEnd() functions are called as part
** of the sqlite3_initialize() and sqlite3_shutdown() processing, the
** "interlocked" magic used here is probably not strictly necessary.
*/
static LONG SQLITE_WIN32_VOLATILE winMutex_lock = 0;

int sqlite3_win32_is_nt(void); /* os_win.c */
void sqlite3_win32_sleep(DWORD milliseconds); /* os_win.c */

static int winMutexInit(void){
  /* The first to increment to 1 does actual initialization */
  if( InterlockedCompareExchange(&winMutex_lock, 1, 0)==0 ){
    int i;
    for(i=0; i<ArraySize(winMutex_staticMutexes); i++){
#if SQLITE_OS_WINRT
      InitializeCriticalSectionEx(&winMutex_staticMutexes[i].mutex, 0, 0);
#else
      InitializeCriticalSection(&winMutex_staticMutexes[i].mutex);
#endif
    }
    winMutex_isInit = 1;
  }else{
    /* Another thread is (in the process of) initializing the static
    ** mutexes */
    while( !winMutex_isInit ){
      sqlite3_win32_sleep(1);
    }
  }
  return SQLITE_OK;
}

static int winMutexEnd(void){
  /* The first to decrement to 0 does actual shutdown
  ** (which should be the last to shutdown.) */
  if( InterlockedCompareExchange(&winMutex_lock, 0, 1)==1 ){
    if( winMutex_isInit==1 ){
      int i;
      for(i=0; i<ArraySize(winMutex_staticMutexes); i++){
        DeleteCriticalSection(&winMutex_staticMutexes[i].mutex);
      }
      winMutex_isInit = 0;
    }
  }
  return SQLITE_OK;
}

/*
** The sqlite3_mutex_alloc() routine allocates a new
** mutex and returns a pointer to it.  If it returns NULL
** that means that a mutex could not be allocated.  SQLite
** will unwind its stack and return an error.  The argument
** to sqlite3_mutex_alloc() is one of these integer constants:
**
** <ul>
** <li>  SQLITE_MUTEX_FAST
** <li>  SQLITE_MUTEX_RECURSIVE
** <li>  SQLITE_MUTEX_STATIC_MASTER
** <li>  SQLITE_MUTEX_STATIC_MEM
** <li>  SQLITE_MUTEX_STATIC_OPEN
** <li>  SQLITE_MUTEX_STATIC_PRNG
** <li>  SQLITE_MUTEX_STATIC_LRU
** <li>  SQLITE_MUTEX_STATIC_PMEM
** <li>  SQLITE_MUTEX_STATIC_APP1
** <li>  SQLITE_MUTEX_STATIC_APP2
** <li>  SQLITE_MUTEX_STATIC_APP3
** <li>  SQLITE_MUTEX_STATIC_VFS1
** <li>  SQLITE_MUTEX_STATIC_VFS2
** <li>  SQLITE_MUTEX_STATIC_VFS3
** </ul>
**
** The first two constants cause sqlite3_mutex_alloc() to create
** a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVE
** is used but not necessarily so when SQLITE_MUTEX_FAST is used.
** The mutex implementation does not need to make a distinction
** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does
** not want to.  But SQLite will only request a recursive mutex in
** cases where it really needs one.  If a faster non-recursive mutex
** implementation is available on the host platform, the mutex subsystem
** might return such a mutex in response to SQLITE_MUTEX_FAST.
**
** The other allowed parameters to sqlite3_mutex_alloc() each return
** a pointer to a static preexisting mutex.  Six static mutexes are
** used by the current version of SQLite.  Future versions of SQLite
** may add additional static mutexes.  Static mutexes are for internal
** use by SQLite only.  Applications that use SQLite mutexes should
** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or
** SQLITE_MUTEX_RECURSIVE.
**
** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST
** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()
** returns a different mutex on every call.  But for the static
** mutex types, the same mutex is returned on every call that has
** the same type number.
*/
static sqlite3_mutex *winMutexAlloc(int iType){
  sqlite3_mutex *p;

  switch( iType ){
    case SQLITE_MUTEX_FAST:
    case SQLITE_MUTEX_RECURSIVE: {
      p = sqlite3MallocZero( sizeof(*p) );
      if( p ){
        p->id = iType;
#ifdef SQLITE_DEBUG
#ifdef SQLITE_WIN32_MUTEX_TRACE_DYNAMIC
        p->trace = 1;
#endif
#endif
#if SQLITE_OS_WINRT
        InitializeCriticalSectionEx(&p->mutex, 0, 0);
#else
        InitializeCriticalSection(&p->mutex);
#endif
      }
      break;
    }
    default: {
#ifdef SQLITE_ENABLE_API_ARMOR
      if( iType-2<0 || iType-2>=ArraySize(winMutex_staticMutexes) ){
        (void)SQLITE_MISUSE_BKPT;
        return 0;
      }
#endif
      p = &winMutex_staticMutexes[iType-2];
      p->id = iType;
#ifdef SQLITE_DEBUG
#ifdef SQLITE_WIN32_MUTEX_TRACE_STATIC
      p->trace = 1;
#endif
#endif
      break;
    }
  }
  return p;
}


/*
** This routine deallocates a previously
** allocated mutex.  SQLite is careful to deallocate every
** mutex that it allocates.
*/
static void winMutexFree(sqlite3_mutex *p){
  assert( p );
  assert( p->nRef==0 && p->owner==0 );
  if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ){
    DeleteCriticalSection(&p->mutex);
    sqlite3_free(p);
  }else{
#ifdef SQLITE_ENABLE_API_ARMOR
    (void)SQLITE_MISUSE_BKPT;
#endif
  }
}

/*
** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt
** to enter a mutex.  If another thread is already within the mutex,
** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return
** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OK
** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE can
** be entered multiple times by the same thread.  In such cases the,
** mutex must be exited an equal number of times before another thread
** can enter.  If the same thread tries to enter any other kind of mutex
** more than once, the behavior is undefined.
*/
static void winMutexEnter(sqlite3_mutex *p){
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
  DWORD tid = GetCurrentThreadId();
#endif
#ifdef SQLITE_DEBUG
  assert( p );
  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );
#else
  assert( p );
#endif
  assert( winMutex_isInit==1 );
  EnterCriticalSection(&p->mutex);
#ifdef SQLITE_DEBUG
  assert( p->nRef>0 || p->owner==0 );
  p->owner = tid;
  p->nRef++;
  if( p->trace ){
    OSTRACE(("ENTER-MUTEX tid=%lu, mutex=%p (%d), nRef=%d\n",
             tid, p, p->trace, p->nRef));
  }
#endif
}

static int winMutexTry(sqlite3_mutex *p){
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
  DWORD tid = GetCurrentThreadId();
#endif
  int rc = SQLITE_BUSY;
  assert( p );
  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );
  /*
  ** The sqlite3_mutex_try() routine is very rarely used, and when it
  ** is used it is merely an optimization.  So it is OK for it to always
  ** fail.
  **
  ** The TryEnterCriticalSection() interface is only available on WinNT.
  ** And some windows compilers complain if you try to use it without
  ** first doing some #defines that prevent SQLite from building on Win98.
  ** For that reason, we will omit this optimization for now.  See
  ** ticket #2685.
  */
#if defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x0400
  assert( winMutex_isInit==1 );
  assert( winMutex_isNt>=-1 && winMutex_isNt<=1 );
  if( winMutex_isNt<0 ){
    winMutex_isNt = sqlite3_win32_is_nt();
  }
  assert( winMutex_isNt==0 || winMutex_isNt==1 );
  if( winMutex_isNt && TryEnterCriticalSection(&p->mutex) ){
#ifdef SQLITE_DEBUG
    p->owner = tid;
    p->nRef++;
#endif
    rc = SQLITE_OK;
  }
#else
  UNUSED_PARAMETER(p);
#endif
#ifdef SQLITE_DEBUG
  if( p->trace ){
    OSTRACE(("TRY-MUTEX tid=%lu, mutex=%p (%d), owner=%lu, nRef=%d, rc=%s\n",
             tid, p, p->trace, p->owner, p->nRef, sqlite3ErrName(rc)));
  }
#endif
  return rc;
}

/*
** The sqlite3_mutex_leave() routine exits a mutex that was
** previously entered by the same thread.  The behavior
** is undefined if the mutex is not currently entered or
** is not currently allocated.  SQLite will never do either.
*/
static void winMutexLeave(sqlite3_mutex *p){
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
  DWORD tid = GetCurrentThreadId();
#endif
  assert( p );
#ifdef SQLITE_DEBUG
  assert( p->nRef>0 );
  assert( p->owner==tid );
  p->nRef--;
  if( p->nRef==0 ) p->owner = 0;
  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );
#endif
  assert( winMutex_isInit==1 );
  LeaveCriticalSection(&p->mutex);
#ifdef SQLITE_DEBUG
  if( p->trace ){
    OSTRACE(("LEAVE-MUTEX tid=%lu, mutex=%p (%d), nRef=%d\n",
             tid, p, p->trace, p->nRef));
  }
#endif
}

sqlite3_mutex_methods const *sqlite3DefaultMutex(void){
  static const sqlite3_mutex_methods sMutex = {
    winMutexInit,
    winMutexEnd,
    winMutexAlloc,
    winMutexFree,
    winMutexEnter,
    winMutexTry,
    winMutexLeave,
#ifdef SQLITE_DEBUG
    winMutexHeld,
    winMutexNotheld
#else
    0,
    0
#endif
  };
  return &sMutex;
}

#endif /* SQLITE_MUTEX_W32 */
@


1.2
log
@Update sqlite3 to 3.8.11.1. Bump major, regen .pc and header. Changes
available here: http://sqlite.org/changes.html

Tested in bulk by aja@@. ok landry@@ "Please crank sqlite when you get
this mail." deraadt@@
@
text
@d81 18
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
** This file contains the C functions that implement mutexes for win32
d16 12
d30 1
a30 1
** on a win32 system.
d43 1
a43 1
  int trace;                 /* True to trace changes */
d46 6
d53 1
d55 2
a56 1
#define SQLITE3_MUTEX_INITIALIZER { SQLITE_W32_MUTEX_INITIALIZER, 0, 0L, (DWORD)0, 0 }
a60 34
/*
** Return true (non-zero) if we are running under WinNT, Win2K, WinXP,
** or WinCE.  Return false (zero) for Win95, Win98, or WinME.
**
** Here is an interesting observation:  Win95, Win98, and WinME lack
** the LockFileEx() API.  But we can still statically link against that
** API as long as we don't call it win running Win95/98/ME.  A call to
** this routine is used to determine if the host is Win95/98/ME or
** WinNT/2K/XP so that we will know whether or not we can safely call
** the LockFileEx() API.
**
** mutexIsNT() is only used for the TryEnterCriticalSection() API call,
** which is only available if your application was compiled with 
** _WIN32_WINNT defined to a value >= 0x0400.  Currently, the only
** call to TryEnterCriticalSection() is #ifdef'ed out, so #ifdef 
** this out as well.
*/
#if 0
#if SQLITE_OS_WINCE
# define mutexIsNT()  (1)
#else
  static int mutexIsNT(void){
    static int osType = 0;
    if( osType==0 ){
      OSVERSIONINFO sInfo;
      sInfo.dwOSVersionInfoSize = sizeof(sInfo);
      GetVersionEx(&sInfo);
      osType = sInfo.dwPlatformId==VER_PLATFORM_WIN32_NT ? 2 : 1;
    }
    return osType==2;
  }
#endif /* SQLITE_OS_WINCE */
#endif

d69 1
d73 1
d75 1
a75 1
  DWORD tid = GetCurrentThreadId(); 
a79 1

d83 7
a89 1
static sqlite3_mutex winMutex_staticMutexes[6] = {
d97 1
d99 5
a103 4
/* As winMutexInit() and winMutexEnd() are called as part
** of the sqlite3_initialize and sqlite3_shutdown()
** processing, the "interlocked" magic is probably not
** strictly necessary.
d105 4
a108 1
static long winMutex_lock = 0;
d110 1
a110 1
static int winMutexInit(void){ 
d115 3
d119 1
d123 2
a124 1
    /* Someone else is in the process of initing the static mutexes */
d126 1
a126 1
      Sleep(1);
d129 1
a129 1
  return SQLITE_OK; 
d132 2
a133 2
static int winMutexEnd(void){ 
  /* The first to decrement to 0 does actual shutdown 
d144 1
a144 1
  return SQLITE_OK; 
d159 1
a159 1
** <li>  SQLITE_MUTEX_STATIC_MEM2
d163 6
d191 1
a191 1
** returns a different mutex on every call.  But for the static 
d202 2
a203 1
      if( p ){  
d205 3
a207 1
        p->id = iType;
d209 3
d213 1
d218 6
a223 3
      assert( winMutex_isInit==1 );
      assert( iType-2 >= 0 );
      assert( iType-2 < ArraySize(winMutex_staticMutexes) );
d225 1
d227 3
a229 1
      p->id = iType;
d246 8
a253 3
  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );
  DeleteCriticalSection(&p->mutex);
  sqlite3_free(p);
d268 3
d272 1
a272 1
  DWORD tid = GetCurrentThreadId(); 
d274 2
d277 1
d281 1
a281 1
  p->owner = tid; 
d284 2
a285 1
    printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);
d289 1
d291 2
a292 2
#ifndef NDEBUG
  DWORD tid = GetCurrentThreadId(); 
d295 1
d300 1
a300 1
  ** fail.  
d308 9
a316 2
#if 0
  if( mutexIsNT() && TryEnterCriticalSection(&p->mutex) ){
d319 1
d326 3
a328 2
  if( rc==SQLITE_OK && p->trace ){
    printf("try mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);
d341 1
a341 1
#ifndef NDEBUG
d343 3
d352 1
d356 2
a357 1
    printf("leave mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);
a378 1

d381 1
@


1.1.1.1
log
@sqlite 3.7.11 library, vendor sources
@
text
@@


1.1.1.2
log
@import 3.7.13
okay jasper@@
@
text
@d59 1
a59 1
#if SQLITE_OS_WINCE || SQLITE_OS_WINRT
a111 2
extern void sqlite3_win32_sleep(DWORD milliseconds); /* os_win.c */

a116 3
#if SQLITE_OS_WINRT
      InitializeCriticalSectionEx(&winMutex_staticMutexes[i].mutex, 0, 0);
#else
a117 1
#endif
d123 1
a123 1
      sqlite3_win32_sleep(1);
a196 3
#if SQLITE_OS_WINRT
        InitializeCriticalSectionEx(&p->mutex, 0, 0);
#else
a197 1
#endif
@


1.1.1.3
log
@minor update to 3.7.14.1
@
text
@d112 1
a112 1
void sqlite3_win32_sleep(DWORD milliseconds); /* os_win.c */
@


1.1.1.4
log
@Update sqlite to 3.8.4. A list of changes are available here:
http://sqlite.org/changes.html.

Tested in a bulk and ok landry@@
@
text
@d72 1
a72 1
#endif /* SQLITE_OS_WINCE || SQLITE_OS_WINRT */
d110 1
a110 1
static LONG winMutex_lock = 0;
@


1.1.1.5
log
@Update sqlite3 to 3.8.6. A list of changes are available here:
http://sqlite.org/releaselog/3_8_6.html.

Tested in a bulk and ok landry@@
@
text
@d12 1
a12 1
** This file contains the C functions that implement mutexes for Win32.
a15 12
#if SQLITE_OS_WIN
/*
** Include code that is common to all os_*.c files
*/
#include "os_common.h"

/*
** Include the header file for the Windows VFS.
*/
#include "os_win.h"
#endif

d18 1
a18 1
** on a Win32 system.
d31 1
a31 1
  volatile int trace;        /* True to trace changes */
a33 6

/*
** These are the initializer values used when declaring a "static" mutex
** on Win32.  It should be noted that all mutexes require initialization
** on the Win32 platform.
*/
a34 1

d36 1
a36 2
#define SQLITE3_MUTEX_INITIALIZER { SQLITE_W32_MUTEX_INITIALIZER, 0, \
                                    0L, (DWORD)0, 0 }
d41 34
a82 1

a85 1

d87 1
a87 1
  DWORD tid = GetCurrentThreadId();
d92 1
d96 1
a96 4
static sqlite3_mutex winMutex_staticMutexes[] = {
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
  SQLITE3_MUTEX_INITIALIZER,
a103 1

d105 4
a108 5
static int winMutex_isNt = -1; /* <0 means "need to query" */

/* As the winMutexInit() and winMutexEnd() functions are called as part
** of the sqlite3_initialize() and sqlite3_shutdown() processing, the
** "interlocked" magic used here is probably not strictly necessary.
d110 1
a110 1
static LONG volatile winMutex_lock = 0;
a111 1
int sqlite3_win32_is_nt(void); /* os_win.c */
d114 1
a114 1
static int winMutexInit(void){
d127 1
a127 2
    /* Another thread is (in the process of) initializing the static
    ** mutexes */
d132 1
a132 1
  return SQLITE_OK;
d135 2
a136 2
static int winMutexEnd(void){
  /* The first to decrement to 0 does actual shutdown
d147 1
a147 1
  return SQLITE_OK;
d162 1
a162 1
** <li>  SQLITE_MUTEX_STATIC_OPEN
a165 3
** <li>  SQLITE_MUTEX_STATIC_APP1
** <li>  SQLITE_MUTEX_STATIC_APP2
** <li>  SQLITE_MUTEX_STATIC_APP3
d188 1
a188 1
** returns a different mutex on every call.  But for the static
d199 1
a199 1
      if( p ){
a201 3
#ifdef SQLITE_WIN32_MUTEX_TRACE_DYNAMIC
        p->trace = 1;
#endif
d212 1
a214 1
      assert( winMutex_isInit==1 );
a217 3
#ifdef SQLITE_WIN32_MUTEX_TRACE_STATIC
      p->trace = 1;
#endif
a232 1
#ifdef SQLITE_DEBUG
a234 2
#endif
  assert( winMutex_isInit==1 );
a250 3
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
  DWORD tid = GetCurrentThreadId();
#endif
d252 1
a252 1
  assert( p );
a253 2
#else
  assert( p );
a254 1
  assert( winMutex_isInit==1 );
d258 1
a258 1
  p->owner = tid;
d261 1
a261 2
    OSTRACE(("ENTER-MUTEX tid=%lu, mutex=%p (%d), nRef=%d\n",
             tid, p, p->trace, p->nRef));
a264 1

d266 2
a267 2
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
  DWORD tid = GetCurrentThreadId();
a269 1
  assert( p );
d274 1
a274 1
  ** fail.
d282 2
a283 9
#if defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x0400
  assert( winMutex_isInit==1 );
  assert( winMutex_isNt>=-1 && winMutex_isNt<=1 );
  if( winMutex_isNt<0 ){
    winMutex_isNt = sqlite3_win32_is_nt();
  }
  assert( winMutex_isNt==0 || winMutex_isNt==1 );
  if( winMutex_isNt && TryEnterCriticalSection(&p->mutex) ){
#ifdef SQLITE_DEBUG
a285 1
#endif
d292 2
a293 3
  if( p->trace ){
    OSTRACE(("TRY-MUTEX tid=%lu, mutex=%p (%d), owner=%lu, nRef=%d, rc=%s\n",
             tid, p, p->trace, p->owner, p->nRef, sqlite3ErrName(rc)));
d306 1
a306 1
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
a307 3
#endif
  assert( p );
#ifdef SQLITE_DEBUG
a313 1
  assert( winMutex_isInit==1 );
d317 1
a317 2
    OSTRACE(("LEAVE-MUTEX tid=%lu, mutex=%p (%d), nRef=%d\n",
             tid, p, p->trace, p->nRef));
d339 1
a341 1

@


1.1.1.6
log
@Update sqlite3 to 3.8.7.4. Changes available here: http://sqlite.org/changes.html#version_3_8_7_4

ok landry@@
@
text
@d102 1
a102 1
static LONG SQLITE_WIN32_VOLATILE winMutex_lock = 0;
@


1.1.1.7
log
@Update sqlite3 to 3.8.8.3. Changes available here:
http://sqlite.org/releaselog/3_8_8_3.html

Tested in bulk and ok landry@@
@
text
@a211 6
#ifdef SQLITE_ENABLE_API_ARMOR
      if( iType-2<0 || iType-2>=ArraySize(winMutex_staticMutexes) ){
        (void)SQLITE_MISUSE_BKPT;
        return 0;
      }
#endif
@


1.1.1.8
log
@Update sqlite3 to 3.8.9. Changes available here:
http://sqlite.org/releaselog/3_8_9.html

Tested in bulk and ok landry@@
@
text
@d197 1
a198 1
#ifdef SQLITE_DEBUG
d218 3
d222 1
a223 1
#ifdef SQLITE_DEBUG
d242 1
d244 1
a244 6
  if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ){
    DeleteCriticalSection(&p->mutex);
    sqlite3_free(p);
  }else{
#ifdef SQLITE_ENABLE_API_ARMOR
    (void)SQLITE_MISUSE_BKPT;
d246 3
a248 1
  }
@


