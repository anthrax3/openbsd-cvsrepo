head	1.29;
access;
symbols
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8;
locks; strict;
comment	@ * @;


1.29
date	2017.08.21.21.41.13;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	GetnLYY8Up3nxFbI;

1.28
date	2016.05.24.19.24.46;	author okan;	state Exp;
branches;
next	1.27;
commitid	eVCm0GHQHDffS3hd;

1.27
date	2015.12.24.17.02.37;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	VwzNkIKMCYMcyn8h;

1.26
date	2015.07.07.13.56.45;	author ajacoutot;	state Exp;
branches;
next	1.25;
commitid	lbwEAXoS1RPiMm5U;

1.25
date	2015.02.10.07.49.22;	author ajacoutot;	state Exp;
branches;
next	1.24;
commitid	1pWy5MgFqLLJ3M6K;

1.24
date	2014.05.20.13.32.22;	author syl;	state Exp;
branches;
next	1.23;

1.23
date	2014.05.20.13.22.06;	author syl;	state Exp;
branches;
next	1.22;

1.22
date	2014.05.19.13.43.30;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.03.24.07.24.32;	author syl;	state Exp;
branches;
next	1.20;

1.20
date	2014.02.05.20.47.38;	author syl;	state Exp;
branches;
next	1.19;

1.19
date	2014.02.05.20.13.58;	author syl;	state Exp;
branches;
next	1.18;

1.18
date	2013.12.10.10.07.48;	author syl;	state Exp;
branches;
next	1.17;

1.17
date	2013.11.11.14.23.01;	author stsp;	state Exp;
branches;
next	1.16;

1.16
date	2013.11.09.13.39.37;	author stsp;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.09.10.35.31;	author stsp;	state Exp;
branches;
next	1.14;

1.14
date	2013.11.07.18.15.09;	author syl;	state Exp;
branches;
next	1.13;

1.13
date	2013.11.06.19.53.20;	author syl;	state Exp;
branches;
next	1.12;

1.12
date	2013.11.02.09.00.49;	author syl;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.07.18.08.51;	author syl;	state Exp;
branches;
next	1.10;

1.10
date	2013.08.10.09.51.50;	author jca;	state Exp;
branches;
next	1.9;

1.9
date	2013.08.10.00.30.43;	author syl;	state Exp;
branches;
next	1.8;

1.8
date	2013.07.05.11.08.15;	author syl;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.21.21.30.38;	author syl;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.14.20.49.06;	author syl;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.14.20.40.41;	author syl;	state Exp;
branches;
next	1.4;

1.4
date	2013.06.12.22.44.42;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.12.22.36.06;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.03.16.21.08;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.16.00.50;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Use waitpid()/EINTR idiom for the specific pid, rather than generic wait(),
in case the parent process was started with a dangling child.  This style
ensures any potential parent:child interlock isn't disrupted due to the
"wrong" child being waited on first.  Then the other other childs can safely
zombie.
ok millert jca brynet
@
text
@/* $OpenBSD: fuse.c,v 1.28 2016/05/24 19:24:46 okan Exp $ */
/*
 * Copyright (c) 2013 Sylvestre Gallon <ccna.syl@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/wait.h>
#include <sys/types.h>
#include <sys/ioctl.h>

#include <miscfs/fuse/fusefs.h>

#include <errno.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "fuse_opt.h"
#include "fuse_private.h"
#include "debug.h"

static struct fuse_session *sigse;
static struct fuse_context *ictx = NULL;
static int max_read = FUSEBUFMAXSIZE;

enum {
	KEY_HELP,
	KEY_HELP_WITHOUT_HEADER,
	KEY_VERSION,
	KEY_MAXREAD,
	KEY_STUB
};

static struct fuse_opt fuse_core_opts[] = {
	FUSE_OPT_KEY("-h",			KEY_HELP),
	FUSE_OPT_KEY("--help",			KEY_HELP),
	FUSE_OPT_KEY("-ho",			KEY_HELP_WITHOUT_HEADER),
	FUSE_OPT_KEY("-V",			KEY_VERSION),
	FUSE_OPT_KEY("--version",		KEY_VERSION),
	FUSE_OPT_KEY("max_read=",		KEY_MAXREAD),
	FUSE_OPT_KEY("debug",			KEY_STUB),
	FUSE_OPT_KEY("-d",			KEY_STUB),
	FUSE_OPT_KEY("-f",			KEY_STUB),
	FUSE_OPT_KEY("-s",			KEY_STUB),
	FUSE_OPT_KEY("use_ino",			KEY_STUB),
	FUSE_OPT_KEY("big_writes",		KEY_STUB),
	FUSE_OPT_KEY("default_permissions",	KEY_STUB),
	FUSE_OPT_KEY("fsname=",			KEY_STUB),
	FUSE_OPT_END
};

int
fuse_loop(struct fuse *fuse)
{
	struct fusebuf fbuf;
	struct fuse_context ctx;
	struct fb_ioctl_xch ioexch;
	struct kevent ev;
	ssize_t n;
	int ret;

	fuse->fc->kq = kqueue();
	if (fuse->fc->kq == -1)
		return (-1);

	EV_SET(&fuse->fc->event, fuse->fc->fd, EVFILT_READ, EV_ADD |
	    EV_ENABLE, 0, 0, 0);

	while (!fuse->fc->dead) {
		ret = kevent(fuse->fc->kq, &fuse->fc->event, 1, &ev, 1, NULL);
		if (ret == -1)
			DPERROR(__func__);
		else if (ret > 0) {
			n = read(fuse->fc->fd, &fbuf, sizeof(fbuf));
			if (n != sizeof(fbuf)) {
				fprintf(stderr, "%s: bad fusebuf read\n",
				    __func__);
				return (-1);
			}

			/* check if there is data something present */
			if (fbuf.fb_len) {
				fbuf.fb_dat = malloc(fbuf.fb_len);
				if (fbuf.fb_dat == NULL)
					return (-1);
				ioexch.fbxch_uuid = fbuf.fb_uuid;
				ioexch.fbxch_len = fbuf.fb_len;
				ioexch.fbxch_data = fbuf.fb_dat;

				if (ioctl(fuse->fc->fd, FIOCGETFBDAT,
				    &ioexch)) {
					free(fbuf.fb_dat);
					return (-1);
				}
			}

			ctx.fuse = fuse;
			ctx.uid = fuse->conf.uid;
			ctx.gid = fuse->conf.gid;
			ctx.pid = fuse->conf.pid;
			ctx.umask = fuse->conf.umask;
			ctx.private_data = fuse->private_data;
			ictx = &ctx;

			ret = ifuse_exec_opcode(fuse, &fbuf);
			if (ret) {
				ictx = NULL;
				return (-1);
			}

			n = write(fuse->fc->fd, &fbuf, sizeof(fbuf));
			if (fbuf.fb_len) {
				if (fbuf.fb_dat == NULL) {
					fprintf(stderr, "%s: fb_dat is Null\n",
					    __func__);
					return (-1);
				}
				ioexch.fbxch_uuid = fbuf.fb_uuid;
				ioexch.fbxch_len = fbuf.fb_len;
				ioexch.fbxch_data = fbuf.fb_dat;

				if (ioctl(fuse->fc->fd, FIOCSETFBDAT, &ioexch)) {
					free(fbuf.fb_dat);
					return (-1);
				}
				free(fbuf.fb_dat);
			}
			ictx = NULL;

			if (n != FUSEBUFSIZE) {
				errno = EINVAL;
				return (-1);
			}
		}
	}

	return (0);
}

struct fuse_chan *
fuse_mount(const char *dir, unused struct fuse_args *args)
{
	struct fusefs_args fargs;
	struct fuse_chan *fc;
	const char *errcause;

	fc = calloc(1, sizeof(*fc));
	if (fc == NULL)
		return (NULL);

	fc->dir = realpath(dir, NULL);
	if (fc->dir == NULL)
		goto bad;

	if ((fc->fd = open("/dev/fuse0", O_RDWR)) == -1) {
		perror(__func__);
		goto bad;
	}

	fargs.fd = fc->fd;
	fargs.max_read = max_read;
	if (mount(MOUNT_FUSEFS, fc->dir, 0, &fargs)) {
		switch (errno) {
		case EMFILE:
			errcause = "mount table full";
			break;
		case EOPNOTSUPP:
			errcause = "filesystem not supported by kernel";
			break;
		default:
			errcause = strerror(errno);
			break;
		}
		fprintf(stderr, "%s on %s: %s\n", __func__, dir, errcause);
		goto bad;
	}

	return (fc);
bad:
	if (fc->fd != -1)
		close(fc->fd);
	free(fc->dir);
	free(fc);
	return (NULL);
}

void
fuse_unmount(const char *dir, unused struct fuse_chan *ch)
{
	if (ch->dead)
		return;

	if (unmount(dir, MNT_UPDATE) == -1)
		DPERROR(__func__);
}

int
fuse_is_lib_option(unused const char *opt)
{
	return (fuse_opt_match(fuse_core_opts, opt));
}

int
fuse_chan_fd(struct fuse_chan *ch)
{
	return (ch->fd);
}

struct fuse_session *
fuse_get_session(struct fuse *f)
{
	return (&f->se);
}

int
fuse_loop_mt(unused struct fuse *fuse)
{
	return (0);
}

struct fuse *
fuse_new(struct fuse_chan *fc, unused struct fuse_args *args,
    const struct fuse_operations *ops, unused size_t size,
    unused void *userdata)
{
	struct fuse *fuse;
	struct fuse_vnode *root;

	if ((fuse = calloc(1, sizeof(*fuse))) == NULL)
		return (NULL);

	/* copy fuse ops to their own structure */
	memcpy(&fuse->op, ops, sizeof(fuse->op));

	fuse->fc = fc;
	fuse->max_ino = FUSE_ROOT_INO;
	fuse->se.args = fuse;
	fuse->private_data = userdata;

	if ((root = alloc_vn(fuse, "/", FUSE_ROOT_INO, 0)) == NULL) {
		free(fuse);
		return (NULL);
	}

	tree_init(&fuse->vnode_tree);
	tree_init(&fuse->name_tree);
	if (!set_vn(fuse, root)) {
		free(fuse);
		return (NULL);
	}

	return (fuse);
}

int
fuse_daemonize(unused int foreground)
{
#ifdef DEBUG
	return (daemon(0,1));
#else
	return (daemon(0,0));
#endif
}

void
fuse_destroy(unused struct fuse *f)
{
	close(f->fc->fd);
	free(f->fc->dir);
	free(f->fc);
	free(f);
}

static void
ifuse_get_signal(unused int num)
{
	struct fuse *f;
	pid_t child;
	int status;

	if (sigse != NULL) {
		child = fork();

		if (child < 0)
			return;

		f = sigse->args;
		if (child == 0) {
			fuse_unmount(f->fc->dir, f->fc);
			sigse = NULL;
			exit(0);
		}

		fuse_loop(f);
		while (waitpid(child, &status, 0) == -1) {
			if (errno != EINTR)
				break;
		}
	}
}

void
fuse_remove_signal_handlers(unused struct fuse_session *se)
{
	sigse = NULL;
	signal(SIGHUP, SIG_DFL);
	signal(SIGINT, SIG_DFL);
	signal(SIGTERM, SIG_DFL);
	signal(SIGPIPE, SIG_DFL);
}

int
fuse_set_signal_handlers(unused struct fuse_session *se)
{
	sigse = se;
	signal(SIGHUP, ifuse_get_signal);
	signal(SIGINT, ifuse_get_signal);
	signal(SIGTERM, ifuse_get_signal);
	signal(SIGPIPE, SIG_IGN);
	return (0);
}

static void
dump_help(void)
{
	fprintf(stderr, "FUSE options:\n"
	    "    -d   -o debug          enable debug output (implies -f)\n"
	    "    -V                     print fuse version\n"
	    "\n");
}

static void
dump_version(void)
{
	fprintf(stderr, "FUSE library version %i\n", FUSE_USE_VERSION);
}

static int
ifuse_process_opt(void *data, const char *arg, int key,
    unused struct fuse_args *args)
{
	struct fuse_core_opt *opt = data;
	struct stat st;
	const char *err;
	int res;

	switch (key) {
		case KEY_STUB:
			return (0);
		case KEY_HELP:
		case KEY_HELP_WITHOUT_HEADER:
			dump_help();
			return (-1);
		case KEY_VERSION:
			dump_version();
			return (-1);
		case KEY_MAXREAD:
			res = strtonum(arg, 0, FUSEBUFMAXSIZE, &err);
			if (err) {
				fprintf(stderr, "fuse: max_read %s\n", err);
				return (-1);
			}
			max_read = res;
			break;
		case FUSE_OPT_KEY_NONOPT:
			if (opt->mp == NULL) {
				opt->mp = realpath(arg, opt->mp);
				if (opt->mp == NULL) {
					fprintf(stderr, "fuse: realpath: "
					    "%s : %s\n", arg, strerror(errno));
					return (-1);
				}

				res = stat(opt->mp, &st);
				if (res == -1) {
					fprintf(stderr, "fuse: bad mount point "
					    "%s : %s\n", arg, strerror(errno));
					return (-1);
				}

				if (!S_ISDIR(st.st_mode)) {
					fprintf(stderr, "fuse: bad mount point "
					    "%s : %s\n", arg,
					    strerror(ENOTDIR));
					return (-1);
				}
			} else {
				fprintf(stderr, "fuse: invalid argument %s\n",
				    arg);
				return (-1);
			}
			break;
		default:
			fprintf(stderr, "fuse: unknown option %s\n", arg);
			return (-1);
	}
	return (0);
}

int
fuse_parse_cmdline(struct fuse_args *args, char **mp, int *mt, unused int *fg)
{
	struct fuse_core_opt opt;

#ifdef DEBUG
	ifuse_debug_init();
#endif
	bzero(&opt, sizeof(opt));
	if (fuse_opt_parse(args, &opt, fuse_core_opts, ifuse_process_opt) == -1)
		return (-1);

	if (opt.mp == NULL) {
		fprintf(stderr, "fuse: missing mountpoint parameter\n");
		return (-1);
	}

	*mp = strdup(opt.mp);
	if (*mp == NULL)
		return (-1);
	*mt = 0;

	return (0);
}

struct fuse_context *
fuse_get_context(void)
{
	return (ictx);
}

int
fuse_version(void)
{
	return (FUSE_VERSION);
}

void
fuse_teardown(struct fuse *fuse, char *mp)
{
	fuse_unmount(mp, fuse->fc);
	fuse_destroy(fuse);
}

int
fuse_invalidate(unused struct fuse *f, unused const char *path)
{
	return (EINVAL);
}

struct fuse *
fuse_setup(int argc, char **argv, const struct fuse_operations *ops,
    size_t size, char **mp, int *mt, void *data)
{
	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
	struct fuse_chan *fc;
	struct fuse *fuse;
	int fg;

	if (fuse_parse_cmdline(&args, mp, mt, &fg))
		goto err;

	fuse_daemonize(0);

	if ((fc = fuse_mount(*mp, NULL)) == NULL)
		goto err;

	if ((fuse = fuse_new(fc, NULL, ops, size, data)) == NULL) {
		free(fc);
		goto err;
	}

	return (fuse);
err:
	free(*mp);
	return (NULL);
}

int
fuse_main(int argc, char **argv, const struct fuse_operations *ops, void *data)
{
	struct fuse *fuse;
	char *mp = NULL;
	int mt;

	fuse = fuse_setup(argc, argv, ops, sizeof(*ops), &mp, &mt, data);
	if (!fuse)
		return (-1);

	return (fuse_loop(fuse));
}
@


1.28
log
@Add missing strdup NULL checks; from Ray Lai.

ok mpi@@ beck@@ mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.27 2015/12/24 17:02:37 mmcc Exp $ */
d297 1
a297 1
			return ;
d307 4
a310 1
		wait(&status);
@


1.27
log
@remove NULL-check before free()
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.26 2015/07/07 13:56:45 ajacoutot Exp $ */
d427 2
@


1.26
log
@Skip mountpoint checking in case we only want the version or help
(-V, -h).

ok syl@@ mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.25 2015/02/10 07:49:22 ajacoutot Exp $ */
d481 1
a481 2
	if (*mp)
		free(*mp);
@


1.25
log
@Add a stub option for big_writes. This is needed by gvfs.
committing on behalf of slacker syl@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.24 2014/05/20 13:32:22 syl Exp $ */
d362 1
a362 1
			return (0);
d365 1
a365 1
			return (1);
@


1.24
log
@Add -o max_read=XXX support in fuse. This is needed by usmb to have a
working read() and write().

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.23 2014/05/20 13:22:06 syl Exp $ */
d58 1
@


1.23
log
@Add support for -o XXX or -oXXX options in libfuse.

inputs from tedu@@, ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.22 2014/05/19 13:43:30 tedu Exp $ */
d172 1
@


1.22
log
@as reported by Helg, should use realpath for mounts. ok guenther syl
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.21 2014/03/24 07:24:32 syl Exp $ */
d36 1
d42 2
a43 1
	KEY_DEBUG
d47 13
a59 9
	FUSE_OPT_KEY("-h",		KEY_HELP),
	FUSE_OPT_KEY("--help",		KEY_HELP),
	FUSE_OPT_KEY("-ho",		KEY_HELP_WITHOUT_HEADER),
	FUSE_OPT_KEY("-V",		KEY_VERSION),
	FUSE_OPT_KEY("--version",	KEY_VERSION),
	FUSE_OPT_KEY("debug",		KEY_DEBUG),
	FUSE_OPT_KEY("-d",		KEY_DEBUG),
	FUSE_OPT_KEY("-f",		KEY_DEBUG),
	FUSE_OPT_KEY("-s",		KEY_DEBUG),
d351 1
d355 1
a355 1
		case KEY_DEBUG:
d364 8
@


1.21
log
@Warn the user if there is a missing mountpoint parameter.

ok ajacoutot@@, tedu@@, pelikan@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.20 2014/02/05 20:47:38 syl Exp $ */
d156 1
a156 1
	fc->dir = strdup(dir);
d166 1
a166 1
	if (mount(MOUNT_FUSEFS, dir, 0, &fargs)) {
@


1.20
log
@Allow libfuse to compile with WARNINGS=yes. No functional change.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.19 2014/02/05 20:13:58 syl Exp $ */
d404 2
a405 1
	if (opt.mp == NULL)
d407 1
@


1.19
log
@check return values in libfuse.

inputs from stsp@@.
ok stsp@@.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.18 2013/12/10 10:07:48 syl Exp $ */
d340 2
a341 1
ifuse_process_opt(void *data, const char *arg, int key, struct fuse_args *args)
d433 1
a433 1
fuse_invalidate(struct fuse *f, const char *path)
@


1.18
log
@Remove an attempt to free a non-heap object.

from David Hill thanks.
ok stsp@@.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.17 2013/11/11 14:23:01 stsp Exp $ */
d113 1
a113 1
				return (ret);
@


1.17
log
@In fuse_loop(), use ssize_t to store return values from read(2) and write(2).
ok syl@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.16 2013/11/09 13:39:37 stsp Exp $ */
d461 2
a462 2
	if (mp)
		free(mp);
@


1.16
log
@Simplify fuse_unmount(). No functional change.
ok jung@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.15 2013/11/09 10:35:31 stsp Exp $ */
d64 1
a64 1
	int error = 0;
d79 2
a80 2
			error = read(fuse->fc->fd, &fbuf, sizeof(fbuf));
			if (error != sizeof(fbuf)) {
d116 1
a116 1
			ret = write(fuse->fc->fd, &fbuf, sizeof(fbuf));
d135 1
a135 1
			if (ret != FUSEBUFSIZE) {
@


1.15
log
@Properly check realpath() return value during argv processing in libfuse.
tweak & ok syl@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.14 2013/11/07 18:15:09 syl Exp $ */
a193 2
	int ret;

d195 1
a195 1
		return ;
d197 1
a197 1
	if ((ret = unmount(dir, MNT_UPDATE)) == -1)
a198 2

	return ;
@


1.14
log
@add fuse_invalidate() and fuse_setup() functions.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.13 2013/11/06 19:53:20 syl Exp $ */
d363 6
d370 1
a370 2

				if (!opt->mp || res == -1) {
@


1.13
log
@Handle fuse client private data. Needed by encfs.
Bump shlib_version.

ok stsp@@.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.12 2013/11/02 09:00:49 syl Exp $ */
d431 8
a438 1
fuse_main(int argc, char **argv, const struct fuse_operations *ops, void *data)
d443 1
a443 3
	char *mp = NULL;
	int mt, fg;
	int error = -1;
d445 1
a445 1
	if (fuse_parse_cmdline(&args, &mp, &mt, &fg))
d450 1
a450 1
	if ((fc = fuse_mount(mp, NULL)) == NULL)
d453 1
a453 1
	if ((fuse = fuse_new(fc, NULL, ops, sizeof(*(ops)), data)) == NULL) {
d458 1
a458 1
	error = fuse_loop(fuse);
d462 15
a476 1
	return (error);
@


1.12
log
@Update the fuse_opt to have option like -h working.

ok ajacoutot@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.11 2013/10/07 18:08:51 syl Exp $ */
d107 1
d246 1
@


1.11
log
@Adapt libfuse to FUSE kernel changes
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.10 2013/08/10 09:51:50 jca Exp $ */
d37 20
d207 1
a207 1
	return (0);
d326 62
d391 1
a391 1
	int i;
d396 6
d403 1
a403 3
	for (i = args->argc - 1; i > 0 && *args->argv[i] == '-'; --i)
		;
	*mp = args->argv[i];
d431 2
d434 1
a434 3
	struct fuse_chan *fc;
	struct fuse_args args;
	char *mountpoint;
d436 1
d438 2
a439 3
	args.argc = argc;
	args.argv = argv;
	fuse_parse_cmdline(&args, &mountpoint, &mt, &fg);
d443 2
a444 2
	if ((fc = fuse_mount(mountpoint, NULL)) == NULL)
		return (-1);
d448 1
a448 1
		return (-1);
d451 5
a455 1
	return (fuse_loop(fuse));
@


1.10
log
@Plug fd and mem leak in fuse_open's error path.  ok syl@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.9 2013/08/10 00:30:43 syl Exp $ */
d19 4
d42 1
a44 1
	size_t len = 0;
d59 4
a62 4
			error = read(fuse->fc->fd, &fbuf, sizeof(fbuf.fb_hdr));
			if (error != sizeof(fbuf.fb_hdr)) {
				DPRINTF("%s: bad hdr read\n", __func__);
				errno = EINVAL;
d66 12
a77 6
			if (fbuf.fb_len != 0) {
				error = read(fuse->fc->fd, (char *)&fbuf.F_dat,
				    fbuf.fb_len);

				if (error != (int)fbuf.fb_len) {
					errno = EINVAL;
d95 17
a111 2
			len = sizeof(fbuf.fb_hdr) + fbuf.fb_len;
			ret = write(fuse->fc->fd, &fbuf, len);
d114 1
a114 1
			if (ret != (int)len) {
@


1.9
log
@Remove some useless DPRINTF.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.8 2013/07/05 11:08:15 syl Exp $ */
d114 1
a114 1
	if ((fc->fd = open("/dev/fuse0", O_RDWR)) < 0) {
d138 1
a138 1
	if (fc->fd > 0)
d140 2
a141 2
	if (fc->dir != NULL)
		free(fc->dir);
@


1.8
log
@Add support for fuse_teardown(3). This function
is needed by zipfs.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.7 2013/06/21 21:30:38 syl Exp $ */
a161 1
	DPRINTF("option %s\n", opt);
@


1.7
log
@Make fuse device clonable.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.6 2013/06/14 20:49:06 syl Exp $ */
d309 7
@


1.6
log
@Add support for fuse_get_context(3) needed by ntfs-3g.

OK pirofti@@ and beck@@ "assuming I am getting to setting
the initial pid/gid/uid values correctly soon".
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.5 2013/06/14 20:40:41 syl Exp $ */
a98 3
#define	DEVPATH	"/dev/"
#define	FUSEDEV	DEVPATH "fuse"

d104 1
a104 4
	struct stat st;
	char busnode[16];
	dev_t minor;
	int i;
d114 2
a115 23
	for (i = 0; i < 8 ; i++) {
		minor = -1;
		snprintf(busnode, sizeof(busnode), FUSEDEV "%d", i);

		DPRINTF("trying %s\n", busnode);
		if ((fc->fd = open(busnode, O_RDWR)) < 0) {
			if (errno == EBUSY)
				DPRINTF("device %s already opened\n", busnode);
			else if (errno != ENOENT && errno != ENXIO)
				DPRINTF("could not open %s\n", busnode);
			continue;
		}

		if (fstat(fc->fd, &st) != 0)
			goto bad;

		minor = st.st_rdev;
		break;
	}

	if (minor == -1) {
		fprintf(stderr, "%s: Cannot find a suitable fuse device\n",
		    __func__);
d119 1
a119 1
	fargs.dev = minor;
d121 12
a132 7
		if (errno == EOPNOTSUPP)
			fprintf(stderr,
			    "%s: %s: FS not supported by kernel\n", __func__,
			    dir);
		else
			perror("fuse_mount failure:");

@


1.5
log
@add support for fuse_version(3). Needed by ntfs-3g.

Ok beck@@ and pirofti@@.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.4 2013/06/12 22:44:42 tedu Exp $ */
d31 1
d37 1
d72 7
d81 1
d87 1
d319 6
@


1.4
log
@style for loops
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.3 2013/06/12 22:36:06 tedu Exp $ */
d308 6
@


1.3
log
@fuse_opt support from Sylvestre
@
text
@d1 1
a1 1
/* $OpenBSD: fuse.c,v 1.2 2013/06/03 16:21:08 tedu Exp $ */
d302 2
a303 1
	for (i = args->argc - 1 ; i > 0 && *args->argv[i] == '-' ; --i);
@


1.2
log
@rcsids
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d26 1
@


1.1
log
@add userland fuse library. ok beck deraadt
from Sylvestre Gallon ccna.syl gmail.com
@
text
@d1 1
@

