head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.2
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.24.0.12
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.8
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.10
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5;
locks; strict;
comment	@ * @;


1.26
date	2016.09.07.17.53.35;	author natano;	state Exp;
branches;
next	1.25;
commitid	bTUYWm2clD2A9qNB;

1.25
date	2016.08.30.16.45.54;	author natano;	state Exp;
branches;
next	1.24;
commitid	bR1BHPSoghZ5Wk7v;

1.24
date	2014.02.05.20.13.58;	author syl;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.29.20.37.18;	author syl;	state Exp;
branches;
next	1.22;

1.22
date	2014.01.23.12.29.38;	author syl;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.20.11.52.55;	author syl;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.16.09.31.44;	author syl;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.02.15.39.12;	author syl;	state Exp;
branches;
next	1.18;

1.18
date	2013.12.20.22.03.26;	author syl;	state Exp;
branches;
next	1.17;

1.17
date	2013.12.09.14.59.08;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2013.12.03.10.07.58;	author syl;	state Exp;
branches;
next	1.15;

1.15
date	2013.12.03.09.59.40;	author syl;	state Exp;
branches;
next	1.14;

1.14
date	2013.11.21.22.03.26;	author syl;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.08.04.57.39;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2013.10.07.18.41.01;	author syl;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.07.18.22.18;	author syl;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.07.18.20.31;	author syl;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.07.18.16.43;	author syl;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.07.18.08.51;	author syl;	state Exp;
branches;
next	1.7;

1.7
date	2013.08.10.00.30.43;	author syl;	state Exp;
branches;
next	1.6;

1.6
date	2013.08.08.03.16.13;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.14.20.56.11;	author syl;	state Exp;
branches;
next	1.4;

1.4
date	2013.06.05.18.26.06;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.04.20.53.27;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.03.16.21.08;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.16.00.50;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Fix fuse node lookups. Currently fusefs nodes in the kernel remember the
parent inode number for ".." lookups. This only works until the kernel
starts to reuse vnodes and the parent's vnode is reclaimed and the ino
to path mapping is removed from the userland process by libfuse. Fix
this by using reference counting in libfuse, so that parent mapping are
retained as long as a child uses them. Also, don't free the root node.

This commit resolves following issue:

$ doas fuse-zip ~/Downloads/foo.zip /mnt
$ ls /mnt
openbsd-www
$ grep -IR foo /usr/src > /dev/null	# force vfs to reclaim vnodes
$ ls /mnt
ls: /mnt: No such file or directory
$

ok tedu
@
text
@/* $OpenBSD: fuse_ops.c,v 1.25 2016/08/30 16:45:54 natano Exp $ */
/*
 * Copyright (c) 2013 Sylvestre Gallon <ccna.syl@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <string.h>
#include <stdlib.h>

#include "fuse_private.h"
#include "debug.h"

#define CHECK_OPT(opname)	DPRINTF("Opcode:\t%s\n", #opname);	\
				DPRINTF("Inode:\t%llu\n",		\
				    (unsigned long long)fbuf->fb_ino);	\
				if (!f->op.opname) {			\
					fbuf->fb_err = -ENOSYS;		\
					return (0);			\
				}

static int
update_attr(struct fuse *f, struct stat *attr, const char *realname,
    struct fuse_vnode *vn)
{
	int ret;

	memset(attr, 0, sizeof(struct stat));
	ret = f->op.getattr(realname, attr);

	if (attr->st_blksize == 0)
		attr->st_blksize = 512;
	if (attr->st_blocks == 0)
		attr->st_blocks = 4;

	attr->st_ino = vn->ino;

	if (f->conf.set_mode)
		attr->st_mode = (attr->st_mode & S_IFMT) | (0777 & ~f->conf.umask);

	if (f->conf.set_uid)
		attr->st_uid = f->conf.uid;

	if (f->conf.set_gid)
		attr->st_gid = f->conf.gid;

	return (ret);
}

static int
ifuse_ops_init(struct fuse *f)
{
	struct fuse_conn_info fci;

	DPRINTF("Opcode:\tinit\n");

	if (f->op.init) {
		bzero(&fci, sizeof fci);
		fci.proto_minor = FUSE_MINOR_VERSION;
		fci.proto_major = FUSE_MAJOR_VERSION;

		f->op.init(&fci);
	}
	return (0);
}

static int
ifuse_ops_getattr(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;

	DPRINTF("Opcode:\tgetattr\n");
	DPRINTF("Inode:\t%llu\n", (unsigned long long)fbuf->fb_ino);

	memset(&fbuf->fb_attr, 0, sizeof(struct stat));

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	fbuf->fb_err = update_attr(f, &fbuf->fb_attr, realname, vn);
	free(realname);

	return (0);
}

static int
ifuse_ops_access(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;

	CHECK_OPT(access);

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	fbuf->fb_err = f->op.access(realname, fbuf->fb_io_mode);
	free(realname);

	return (0);
}

static int
ifuse_ops_open(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_file_info ffi;
	struct fuse_vnode *vn;
	char *realname;

	CHECK_OPT(open);

	bzero(&ffi, sizeof(ffi));
	ffi.flags = fbuf->fb_io_flags;

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	fbuf->fb_err = f->op.open(realname, &ffi);
	free(realname);

	if (!fbuf->fb_err)
		fbuf->fb_io_fd = ffi.fh;

	return (0);
}

static int
ifuse_ops_opendir(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_file_info ffi;
	struct fuse_vnode *vn;
	char *realname;

	DPRINTF("Opcode:\topendir\n");
	DPRINTF("Inode:\t%llu\n", (unsigned long long)fbuf->fb_ino);

	memset(&ffi, 0, sizeof(ffi));
	ffi.flags = fbuf->fb_io_flags;

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	if (f->op.opendir) {
		realname = build_realname(f, vn->ino);
		if (realname == NULL) {
			fbuf->fb_err = -errno;
			return (0);
		}

		fbuf->fb_err = f->op.opendir(realname, &ffi);
		free(realname);
	}

	if (!fbuf->fb_err) {
		fbuf->fb_io_fd = ffi.fh;

		vn->fd = calloc(1, sizeof(*vn->fd));
		if (vn->fd == NULL) {
			fbuf->fb_err = -errno;
			return (0);
		}

		vn->fd->filled = 0;
		vn->fd->size = 0;
		vn->fd->start = 0;
	}

	return (0);
}

#define GENERIC_DIRSIZ(NLEN) \
((sizeof (struct dirent) - (MAXNAMLEN+1)) + ((NLEN+1 + 7) &~ 7))

static int
ifuse_fill_readdir(void *dh, const char *name, const struct stat *stbuf,
    off_t off)
{
	struct fuse_dirhandle *fd = dh;
	struct fusebuf *fbuf;
	struct dirent *dir;
	uint32_t namelen;
	uint32_t len;

	fbuf = fd->buf;
	namelen = strnlen(name, MAXNAMLEN);
	len = GENERIC_DIRSIZ(namelen);

	if (fd->full || (fbuf->fb_len + len > fd->size)) {
		fd->full = 1;
		return (0);
	}

	if (fd->start != 0 &&  fd->idx < fd->start) {
		fd->idx += len;
		return (0);
	}

	dir = (struct dirent *) &fbuf->fb_dat[fbuf->fb_len];

	if (off)
		fd->filled = 0;

	if (stbuf) {
		dir->d_fileno = stbuf->st_ino;
		dir->d_type = IFTODT(stbuf->st_mode);
	} else {
		dir->d_fileno = 0xffffffff;
		dir->d_type = DT_UNKNOWN;
	}
	dir->d_reclen = len;
	dir->d_off = off + len;		/* XXX */
	strlcpy(dir->d_name, name, sizeof(dir->d_name));
	dir->d_namlen = strlen(dir->d_name);

	fbuf->fb_len += len;
	fd->start += len;
	fd->idx += len;

	return (0);
}

static int
ifuse_fill_getdir(fuse_dirh_t fd, const char *name, int type, ino_t ino)
{
	struct stat st;

	bzero(&st, sizeof(st));
	st.st_mode = type << 12;
	if (ino == 0)
		st.st_ino = 0xffffffff;
	else
		st.st_ino = ino;

	return (fd->filler(fd, name, &st, 0));
}

static int
ifuse_ops_readdir(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_file_info ffi;
	struct fuse_vnode *vn;
	char *realname;
	uint64_t offset;
	uint32_t size;
	uint32_t startsave;

	DPRINTF("Opcode:\treaddir\n");
	DPRINTF("Inode:\t%llu\n", (unsigned long long)fbuf->fb_ino);
	DPRINTF("Offset:\t%llu\n", fbuf->fb_io_off);
	DPRINTF("Size:\t%lu\n", fbuf->fb_io_len);

	bzero(&ffi, sizeof(ffi));
	ffi.fh = fbuf->fb_io_fd;
	offset = fbuf->fb_io_off;
	size = fbuf->fb_io_len;
	startsave = 0;

	fbuf->fb_dat = calloc(1, size);

	if (fbuf->fb_dat == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	if (!vn->fd->filled) {
		vn->fd->filler = ifuse_fill_readdir;
		vn->fd->buf = fbuf;
		vn->fd->filled = 0;
		vn->fd->full = 0;
		vn->fd->size = size;
		vn->fd->off = offset;
		vn->fd->idx = 0;
		startsave = vn->fd->start;

		realname = build_realname(f, vn->ino);
		if (realname == NULL) {
			fbuf->fb_err = -errno;
			free(fbuf->fb_dat);
			return (0);
		}

		if (f->op.readdir)
			fbuf->fb_err = f->op.readdir(realname, vn->fd,
			    ifuse_fill_readdir, offset, &ffi);
		else if (f->op.getdir)
			fbuf->fb_err = f->op.getdir(realname, vn->fd,
			    ifuse_fill_getdir);
		else
			fbuf->fb_err = -ENOSYS;
		free(realname);
	}

	if (!vn->fd->full && vn->fd->start == startsave)
		vn->fd->filled = 1;

	if (fbuf->fb_err) {
		fbuf->fb_len = 0;
		vn->fd->filled = 1;
	}

	if (fbuf->fb_len == 0)
		free(fbuf->fb_dat);

	return (0);
}

static int
ifuse_ops_releasedir(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_file_info ffi;
	struct fuse_vnode *vn;
	char *realname;

	DPRINTF("Opcode:\treleasedir\n");
	DPRINTF("Inode:\t%llu\n", (unsigned long long)fbuf->fb_ino);

	bzero(&ffi, sizeof(ffi));
	ffi.fh = fbuf->fb_io_fd;
	ffi.fh_old = ffi.fh;
	ffi.flags = fbuf->fb_io_flags;

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	if (f->op.releasedir) {
		realname = build_realname(f, vn->ino);
		if (realname == NULL) {
			fbuf->fb_err = -errno;
			return (0);
		}

		fbuf->fb_err = f->op.releasedir(realname, &ffi);
		free(realname);
	}

	if (!fbuf->fb_err)
		free(vn->fd);

	return (0);
}

static int
ifuse_ops_release(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_file_info ffi;
	struct fuse_vnode *vn;
	char *realname;

	CHECK_OPT(release);

	bzero(&ffi, sizeof(ffi));
	ffi.fh = fbuf->fb_io_fd;
	ffi.fh_old = ffi.fh;
	ffi.flags = fbuf->fb_io_flags;

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}
	fbuf->fb_err = f->op.release(realname, &ffi);
	free(realname);

	return (0);
}

static int
ifuse_ops_lookup(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;

	DPRINTF("Opcode:\tlookup\n");
	DPRINTF("Inode:\t%llu\n", (unsigned long long)fbuf->fb_ino);
	DPRINTF("For file %s\n", fbuf->fb_dat);

	if (strcmp((const char *)fbuf->fb_dat, "..") == 0) {
		vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
		if (vn == NULL || vn->parent == NULL) {
			fbuf->fb_err = -ENOENT;
			return (0);
		}
		vn = vn->parent;
		if (vn->ino != FUSE_ROOT_INO)
			ref_vn(vn);
	} else {
		vn = get_vn_by_name_and_parent(f, fbuf->fb_dat, fbuf->fb_ino);
		if (vn == NULL) {
			vn = alloc_vn(f, (const char *)fbuf->fb_dat, -1,
			    fbuf->fb_ino);
			if (vn == NULL) {
				fbuf->fb_err = -errno;
				free(fbuf->fb_dat);
				return (0);
			}
			set_vn(f, vn); /*XXX*/
		} else if (vn->ino != FUSE_ROOT_INO)
			ref_vn(vn);
	}

	DPRINTF("new ino %llu\n", (unsigned long long)vn->ino);
	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	fbuf->fb_err = update_attr(f, &fbuf->fb_attr, realname, vn);
	free(fbuf->fb_dat);
	free(realname);

	return (0);
}

static int
ifuse_ops_read(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_file_info ffi;
	struct fuse_vnode *vn;
	char *realname;
	uint64_t offset;
	uint32_t size;
	int ret;

	CHECK_OPT(read);

	bzero(&ffi, sizeof(ffi));
	ffi.fh = fbuf->fb_io_fd;
	size = fbuf->fb_io_len;
	offset = fbuf->fb_io_off;

	fbuf->fb_dat = malloc(size);
	if (fbuf->fb_dat == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	ret = f->op.read(realname, (char *)fbuf->fb_dat, size, offset, &ffi);
	free(realname);
	if (ret >= 0)
		fbuf->fb_len = ret;
	else
		fbuf->fb_err = ret;

	if (fbuf->fb_len == 0)
		free(fbuf->fb_dat);

	return (0);
}

static int
ifuse_ops_write(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_file_info ffi;
	struct fuse_vnode *vn;
	char *realname;
	uint64_t offset;
	uint32_t size;
	int ret;

	CHECK_OPT(write);

	bzero(&ffi, sizeof(ffi));
	ffi.fh = fbuf->fb_io_fd;
	ffi.fh_old = ffi.fh;
	ffi.writepage = fbuf->fb_io_flags & 1;
	size = fbuf->fb_io_len;
	offset = fbuf->fb_io_off;

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	ret = f->op.write(realname, (char *)fbuf->fb_dat, size, offset, &ffi);
	free(realname);
	free(fbuf->fb_dat);

	if (ret >= 0)
		fbuf->fb_io_len = ret;
	else
		fbuf->fb_err = ret;

	return (0);
}

static int
ifuse_ops_create(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_file_info ffi;
	struct fuse_vnode *vn;
	uint32_t mode;

	char *realname;

	DPRINTF("Opcode:\tcreate\n");
	DPRINTF("Inode:\t%llu\n", (unsigned long long)fbuf->fb_ino);

	bzero(&ffi, sizeof(ffi));
	ffi.flags = fbuf->fb_io_flags;
	mode = fbuf->fb_io_mode;

	vn = get_vn_by_name_and_parent(f, fbuf->fb_dat, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	free(fbuf->fb_dat);
	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	if (f->op.create)
		fbuf->fb_err = f->op.create(realname, mode,  &ffi);
	else if (f->op.mknod)
		fbuf->fb_err = f->op.mknod(realname, S_IFREG | mode, 0);
	else
		fbuf->fb_err = -ENOSYS;

	if (!fbuf->fb_err) {
		fbuf->fb_err = update_attr(f, &fbuf->fb_attr, realname, vn);
		fbuf->fb_ino = fbuf->fb_attr.st_ino;
		fbuf->fb_io_mode = fbuf->fb_attr.st_mode;
	}
	free(realname);

	return (0);
}

static int
ifuse_ops_mkdir(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;
	uint32_t mode;

	CHECK_OPT(mkdir);

	mode = fbuf->fb_io_mode;
	vn = get_vn_by_name_and_parent(f, fbuf->fb_dat, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	free(fbuf->fb_dat);
	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	fbuf->fb_err = f->op.mkdir(realname, mode);

	if (!fbuf->fb_err) {
		fbuf->fb_err = update_attr(f, &fbuf->fb_attr, realname, vn);
		fbuf->fb_io_mode = fbuf->fb_attr.st_mode;
		fbuf->fb_ino = vn->ino;
	}
	free(realname);

	return (0);
}

static int
ifuse_ops_rmdir(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;

	CHECK_OPT(rmdir);
	vn = get_vn_by_name_and_parent(f, fbuf->fb_dat, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	free(fbuf->fb_dat);
	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	fbuf->fb_err = f->op.rmdir(realname);
	free(realname);

	return (0);
}

static int
ifuse_ops_readlink(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;
	char name[PATH_MAX + 1];
	int len, ret;

	DPRINTF("Opcode:\treadlink\n");
	DPRINTF("Inode:\t%llu\n", (unsigned long long)fbuf->fb_ino);

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	if (f->op.readlink)
		ret = f->op.readlink(realname, name, sizeof(name));
	else
		ret = -ENOSYS;
	free(realname);

	fbuf->fb_err = ret;
	if (!ret) {
		len = strnlen(name, PATH_MAX);
		fbuf->fb_len = len;
		fbuf->fb_dat = malloc(fbuf->fb_len);
		if (fbuf->fb_dat == NULL) {
			fbuf->fb_err = -errno;
			return (0);
		}
		memcpy(fbuf->fb_dat, name, len);
	} else
		fbuf->fb_len = 0;

	return (0);
}

static int
ifuse_ops_unlink(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;

	CHECK_OPT(unlink);

	vn = get_vn_by_name_and_parent(f, fbuf->fb_dat, fbuf->fb_ino);
	if (vn == NULL) {
		free(fbuf->fb_dat);
		fbuf->fb_err = -errno;
		return (0);
	}

	free(fbuf->fb_dat);
	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	fbuf->fb_err = f->op.unlink(realname);
	free(realname);

	return (0);
}

static int
ifuse_ops_statfs(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;

	bzero(&fbuf->fb_stat, sizeof(fbuf->fb_stat));

	CHECK_OPT(statfs);

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	fbuf->fb_err = f->op.statfs(realname, &fbuf->fb_stat);
	free(realname);

	return (0);
}

static int
ifuse_ops_link(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;
	char *realname_ln;
	ino_t oldnodeid;

	CHECK_OPT(link);
	oldnodeid = fbuf->fb_io_ino;
	vn = get_vn_by_name_and_parent(f, fbuf->fb_dat, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	free(fbuf->fb_dat);
	realname = build_realname(f, oldnodeid);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	realname_ln = build_realname(f, vn->ino);
	if (realname_ln == NULL) {
		fbuf->fb_err = -errno;
		free(realname);
		return (0);
	}

	fbuf->fb_err = f->op.link(realname, realname_ln);
	free(realname);
	free(realname_ln);

	return (0);
}

static int
ifuse_ops_setattr(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	struct timespec ts[2];
	struct utimbuf tbuf;
	struct fb_io *io;
	char *realname;
	uid_t uid;
	gid_t gid;

	DPRINTF("Opcode:\tsetattr\n");
	DPRINTF("Inode:\t%llu\n", (unsigned long long)fbuf->fb_ino);

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}
	io = fbtod(fbuf, struct fb_io *);

	if (io->fi_flags & FUSE_FATTR_MODE) {
		if (f->op.chmod)
			fbuf->fb_err = f->op.chmod(realname,
			    fbuf->fb_attr.st_mode);
		else
			fbuf->fb_err = -ENOSYS;
	}

	if (!fbuf->fb_err && (io->fi_flags & FUSE_FATTR_UID ||
	    io->fi_flags & FUSE_FATTR_GID) ) {
		uid = (io->fi_flags & FUSE_FATTR_UID) ?
		    fbuf->fb_attr.st_uid : (gid_t)-1;
		gid = (io->fi_flags & FUSE_FATTR_GID) ?
		    fbuf->fb_attr.st_gid : (uid_t)-1;
		if (f->op.chown)
			fbuf->fb_err = f->op.chown(realname, uid, gid);
		else
			fbuf->fb_err = -ENOSYS;
	}

	if (!fbuf->fb_err && ( io->fi_flags & FUSE_FATTR_MTIME ||
		io->fi_flags & FUSE_FATTR_ATIME)) {
		ts[0] = fbuf->fb_attr.st_atim;
		ts[1] = fbuf->fb_attr.st_mtim;
		tbuf.actime = ts[0].tv_sec;
		tbuf.modtime = ts[1].tv_sec;

		if (f->op.utimens)
			fbuf->fb_err = f->op.utimens(realname, ts);
		else if (f->op.utime)
			fbuf->fb_err = f->op.utime(realname, &tbuf);
		else
			fbuf->fb_err = -ENOSYS;
	}

	if (!fbuf->fb_err && (io->fi_flags & FUSE_FATTR_SIZE)) {
		if (f->op.truncate)
			fbuf->fb_err = f->op.truncate(realname,
			    fbuf->fb_attr.st_size);
		else
			fbuf->fb_err = -ENOSYS;
	}

	memset(&fbuf->fb_attr, 0, sizeof(struct stat));

	if (!fbuf->fb_err)
		fbuf->fb_err = update_attr(f, &fbuf->fb_attr, realname, vn);
	free(realname);
	free(fbuf->fb_dat);

	return (0);
}

static int
ifuse_ops_symlink(unused struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;
	int len;

	CHECK_OPT(symlink);

	vn = get_vn_by_name_and_parent(f, fbuf->fb_dat, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	len = strlen((char *)fbuf->fb_dat);

	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	/* fuse invert the symlink params */
	fbuf->fb_err = f->op.symlink((const char *)&fbuf->fb_dat[len + 1],
	    realname);
	fbuf->fb_ino = vn->ino;
	free(fbuf->fb_dat);
	free(realname);

	return (0);
}

static int
ifuse_ops_rename(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vnt;
	struct fuse_vnode *vnf;
	char *realnamef;
	char *realnamet;
	int len;

	CHECK_OPT(rename);

	len = strlen((char *)fbuf->fb_dat);
	vnf = get_vn_by_name_and_parent(f, fbuf->fb_dat, fbuf->fb_ino);
	if (vnf == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	vnt = get_vn_by_name_and_parent(f, &fbuf->fb_dat[len + 1],
	    fbuf->fb_io_ino);
	if (vnt == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	free(fbuf->fb_dat);

	realnamef = build_realname(f, vnf->ino);
	if (realnamef == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	realnamet = build_realname(f, vnt->ino);
	if (realnamet == NULL) {
		fbuf->fb_err = -errno;
		free(realnamef);
		return (0);
	}

	fbuf->fb_err = f->op.rename(realnamef, realnamet);
	free(realnamef);
	free(realnamet);

	return (0);
}

static int
ifuse_ops_destroy(struct fuse *f)
{
	struct fuse_context *ctx;

	DPRINTF("Opcode:\tdestroy\n");

	if (f->op.destroy) {
		ctx = fuse_get_context();

		f->op.destroy((ctx)?ctx->private_data:NULL);
	}

	f->fc->dead = 1;

	return (0);
}

static int
ifuse_ops_reclaim(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;

	vn = tree_get(&f->vnode_tree, fbuf->fb_ino);
	if (vn != NULL)
		unref_vn(f, vn);

	return (0);
}

static int
ifuse_ops_mknod(struct fuse *f, struct fusebuf *fbuf)
{
	struct fuse_vnode *vn;
	char *realname;
	uint32_t mode;
	dev_t dev;

	CHECK_OPT(mknod);

	mode = fbuf->fb_io_mode;
	dev = fbuf->fb_io_rdev;
	vn = get_vn_by_name_and_parent(f, fbuf->fb_dat, fbuf->fb_ino);
	if (vn == NULL) {
		fbuf->fb_err = -errno;
		free(fbuf->fb_dat);
		return (0);
	}

	free(fbuf->fb_dat);
	realname = build_realname(f, vn->ino);
	if (realname == NULL) {
		fbuf->fb_err = -errno;
		return (0);
	}

	fbuf->fb_err = f->op.mknod(realname, mode, dev);

	if (!fbuf->fb_err) {
		fbuf->fb_err = update_attr(f, &fbuf->fb_attr, realname, vn);
		fbuf->fb_io_mode = fbuf->fb_attr.st_mode;
		fbuf->fb_ino = fbuf->fb_attr.st_ino;
	}
	free(realname);

	return (0);
}

int
ifuse_exec_opcode(struct fuse *f, struct fusebuf *fbuf)
{
	int ret = 0;

	fbuf->fb_len = 0;
	fbuf->fb_err = 0;

	switch (fbuf->fb_type) {
	case FBT_LOOKUP:
		ret = ifuse_ops_lookup(f, fbuf);
		break;
	case FBT_GETATTR:
		ret = ifuse_ops_getattr(f, fbuf);
		break;
	case FBT_SETATTR:
		ret = ifuse_ops_setattr(f, fbuf);
		break;
	case FBT_READLINK:
		ret = ifuse_ops_readlink(f, fbuf);
		break;
	case FBT_MKDIR:
		ret = ifuse_ops_mkdir(f, fbuf);
		break;
	case FBT_UNLINK:
		ret = ifuse_ops_unlink(f, fbuf);
		break;
	case FBT_RMDIR:
		ret = ifuse_ops_rmdir(f, fbuf);
		break;
	case FBT_LINK:
		ret = ifuse_ops_link(f, fbuf);
		break;
	case FBT_OPEN:
		ret = ifuse_ops_open(f, fbuf);
		break;
	case FBT_READ:
		ret = ifuse_ops_read(f, fbuf);
		break;
	case FBT_WRITE:
		ret = ifuse_ops_write(f, fbuf);
		break;
	case FBT_STATFS:
		ret = ifuse_ops_statfs(f, fbuf);
		break;
	case FBT_RELEASE:
		ret = ifuse_ops_release(f, fbuf);
		break;
	case FBT_INIT:
		ret = ifuse_ops_init(f);
		break;
	case FBT_OPENDIR:
		ret = ifuse_ops_opendir(f, fbuf);
		break;
	case FBT_READDIR:
		ret = ifuse_ops_readdir(f, fbuf);
		break;
	case FBT_RELEASEDIR:
		ret = ifuse_ops_releasedir(f, fbuf);
		break;
	case FBT_ACCESS:
		ret = ifuse_ops_access(f, fbuf);
		break;
	case FBT_CREATE:
		ret = ifuse_ops_create(f, fbuf);
		break;
	case FBT_SYMLINK:
		ret = ifuse_ops_symlink(f, fbuf);
		break;
	case FBT_RENAME:
		ret = ifuse_ops_rename(f, fbuf);
		break;
	case FBT_DESTROY:
		ret = ifuse_ops_destroy(f);
		break;
	case FBT_RECLAIM:
		ret = ifuse_ops_reclaim(f, fbuf);
		break;
	case FBT_MKNOD:
		ret = ifuse_ops_mknod(f, fbuf);
		break;
	default:
		DPRINTF("Opcode:\t%i not supported\n", fbuf->fb_type);
		DPRINTF("Inode:\t%llu\n", (unsigned long long)fbuf->fb_ino);

		fbuf->fb_err = -ENOSYS;
		fbuf->fb_len = 0;
	}
	DPRINTF("\n");

	/* fuse api use negative errno */
	fbuf->fb_err = -fbuf->fb_err;
	return (ret);
}
@


1.25
log
@Use struct stat for storing attributes in fusebufs, because using struct
vattr in userspace is suboptimal as some related helpers are not
available, e.g. VATTR_NULL() and IFTOVT(). The conversion is now done in
the kernel where it belongs. As a side effect the <sys/vnode.h> include
can be removed from libfuse.

tweaks and ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.24 2014/02/05 20:13:58 syl Exp $ */
d435 4
a438 6
	vn = get_vn_by_name_and_parent(f, fbuf->fb_dat, fbuf->fb_ino);
	if (vn == NULL) {
		vn = alloc_vn(f, (const char *)fbuf->fb_dat, -1, fbuf->fb_ino);
		if (vn == NULL) {
			fbuf->fb_err = -errno;
			free(fbuf->fb_dat);
d441 16
a456 1
		set_vn(f, vn); /*XXX*/
d1007 3
a1009 5
	vn = tree_pop(&f->vnode_tree, fbuf->fb_ino);
	if (vn) {
		remove_vnode_from_name_tree(f, vn);
		free(vn);
	}
@


1.24
log
@check return values in libfuse.

inputs from stsp@@.
ok stsp@@.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.23 2014/01/29 20:37:18 syl Exp $ */
a32 20
static void
stat2attr(struct vattr *v, struct stat *st)
{
	v->va_fileid = st->st_ino;
	v->va_bytes = st->st_blocks;
	v->va_mode = st->st_mode;
	v->va_nlink = st->st_nlink;
	v->va_uid = st->st_uid;
	v->va_gid = st->st_gid;
	v->va_rdev = st->st_rdev;
	v->va_size = st->st_size;
	v->va_blocksize = st->st_blksize;
	v->va_atime.tv_sec = st->st_atime;
	v->va_atime.tv_nsec = st->st_atimensec;
	v->va_mtime.tv_sec = st->st_mtime;
	v->va_mtime.tv_nsec = st->st_mtimensec;
	v->va_ctime.tv_sec = st->st_ctime;
	v->va_ctime.tv_nsec = st->st_ctimensec;
}

d34 1
a34 1
update_vattr(struct fuse *f, struct vattr *attr, const char *realname,
a36 1
	struct stat st;
d39 2
a40 2
	bzero(&st, sizeof(st));
	ret = f->op.getattr(realname, &st);
d42 4
a45 4
	if (st.st_blksize == 0)
		st.st_blksize = 512;
	if (st.st_blocks == 0)
		st.st_blocks = 4;
d47 1
a47 1
	st.st_ino = vn->ino;
d50 1
a50 1
		st.st_mode = (st.st_mode & S_IFMT) | (0777 & ~f->conf.umask);
d53 1
a53 1
		st.st_uid = f->conf.uid;
d56 1
a56 3
		st.st_gid = f->conf.gid;

	stat2attr(attr, &st);
d87 1
a87 1
	bzero(&fbuf->fb_vattr, sizeof(fbuf->fb_vattr));
d101 1
a101 1
	fbuf->fb_err = update_vattr(f, &fbuf->fb_vattr, realname, vn);
d454 1
a454 1
	fbuf->fb_err = update_vattr(f, &fbuf->fb_vattr, realname, vn);
d594 3
a596 3
		fbuf->fb_err = update_vattr(f, &fbuf->fb_vattr, realname, vn);
		fbuf->fb_ino = fbuf->fb_vattr.va_fileid;
		fbuf->fb_io_mode = fbuf->fb_vattr.va_mode;
d630 2
a631 2
		fbuf->fb_err = update_vattr(f, &fbuf->fb_vattr, realname, vn);
		fbuf->fb_io_mode = fbuf->fb_vattr.va_mode;
d837 1
a837 1
			    fbuf->fb_vattr.va_mode);
d845 1
a845 1
		    fbuf->fb_vattr.va_uid : (gid_t)-1;
d847 1
a847 1
		    fbuf->fb_vattr.va_gid : (uid_t)-1;
d856 2
a857 4
		ts[0].tv_sec = fbuf->fb_vattr.va_atime.tv_sec;
		ts[0].tv_nsec = fbuf->fb_vattr.va_atime.tv_nsec;
		ts[1].tv_sec = fbuf->fb_vattr.va_mtime.tv_sec;
		ts[1].tv_nsec = fbuf->fb_vattr.va_mtime.tv_nsec;
d872 1
a872 1
			    fbuf->fb_vattr.va_size);
d877 1
a877 1
	bzero(&fbuf->fb_vattr, sizeof(fbuf->fb_vattr));
d880 1
a880 1
		fbuf->fb_err = update_vattr(f, &fbuf->fb_vattr, realname, vn);
d1032 3
a1034 3
		fbuf->fb_err = update_vattr(f, &fbuf->fb_vattr, realname, vn);
		fbuf->fb_io_mode = fbuf->fb_vattr.va_mode;
		fbuf->fb_ino = fbuf->fb_vattr.va_fileid;
@


1.23
log
@Add fuse support for IO_APPEND.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.22 2014/01/23 12:29:38 syl Exp $ */
d113 4
d119 5
d139 4
d145 5
d169 4
d175 5
d203 4
d210 5
d223 4
a226 2
		if (vn->fd == NULL)
			return (errno);
d326 1
a326 1
		fbuf->fb_err = errno;
d329 1
d331 5
d348 6
d395 4
d402 5
d432 4
d438 4
d462 1
a462 1
			fbuf->fb_err = -ENOMEM;
d471 6
d503 1
a503 1
		fbuf->fb_err = errno;
d508 5
d515 6
d554 5
d561 6
d594 1
d596 5
d604 5
d637 5
d645 5
d670 5
d678 5
d701 4
d707 5
d724 1
a724 1
			fbuf->fb_err = errno;
d743 6
d750 5
a755 1
	realname = build_realname(f, vn->ino);
d773 4
d779 5
d801 5
d809 5
d815 6
d843 6
d850 5
d922 6
d931 6
d960 6
d968 6
d977 5
d983 6
d1041 5
d1049 5
@


1.22
log
@Fix .readdir() code following what is done in .getdir().

Issue reported by Helg Bredow and Derrik Pates, thanks !
ok pelikan@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.21 2014/01/20 11:52:55 syl Exp $ */
a66 2
	if (st.st_size == 0)
		st.st_size = 512;
@


1.21
log
@hook mknod() if create() implementation is not present.

from Derrik Pates (daemon AT now DOT ai), thanks!
ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.20 2014/01/16 09:31:44 syl Exp $ */
d217 1
a217 2
	if ((fd->full || (fbuf->fb_len + len > fd->size)) ||
	    (!fd->isgetdir && fd->off != off)) {
d222 1
a222 1
	if (fd->isgetdir && fd->start != 0 &&  fd->idx < fd->start) {
d245 3
a247 4
	if (fd->isgetdir) {
		fd->start += len;
		fd->idx += len;
	}
d288 1
a288 1
	
a299 1
		vn->fd->isgetdir = 0;
d302 2
d309 1
a309 4
		else if (f->op.getdir) {
			vn->fd->isgetdir = 1;
			vn->fd->idx = 0;
			startsave = vn->fd->start;
d312 1
a312 1
		} else
d317 1
a317 1
	if (!vn->fd->full && vn->fd->isgetdir && vn->fd->start == startsave)
@


1.20
log
@Add support for mknod in fuse.

OK tedu@@
"it looks good to me" from guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.19 2014/01/02 15:39:12 syl Exp $ */
d499 2
a500 1
	CHECK_OPT(create);
d509 6
a514 1
	fbuf->fb_err = f->op.create(realname, mode,  &ffi);
@


1.19
log
@Call fuse callbacks on FBT_INIT and FBT_DESTROY.

Issue reported by Helg Bredow, thanks!

With inputs from tedu@@
ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.18 2013/12/20 22:03:26 syl Exp $ */
d812 28
d917 3
@


1.18
log
@Add support for truncate in fuse.

Input from millert@@.

Ok millert@@, tedu@@.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.17 2013/12/09 14:59:08 beck Exp $ */
d87 1
a87 1
ifuse_ops_init(void)
d89 2
d92 8
d783 2
d787 6
d861 1
a861 1
		ret = ifuse_ops_init();
@


1.17
log
@Fix issues with dirent returning junk due to removal of bzero in version 1.14.
Ensure d_name string is nul terminated and the correct length in d_namlen.
noticed by pelikan@@
ok syl@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.16 2013/12/03 10:07:58 syl Exp $ */
d699 8
@


1.16
log
@Does not append a NUL character to buf in readlink(2).
Add some check for malloc(3) return values.

From Derrik Pates (daemon AT now DOT ai), thanks.
OK millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.15 2013/12/03 09:59:40 syl Exp $ */
a229 1
	dir->d_namlen = namelen;
d232 2
a233 1
	memcpy(dir->d_name, name, namelen);
d279 2
a280 1
	fbuf->fb_dat = malloc(size);
@


1.15
log
@Add support for FBT_RECLAIM that allow us to free the representation
of vnode in userspace.

"I think it's right" from tedu@@.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.14 2013/11/21 22:03:26 syl Exp $ */
d280 4
d424 4
d575 1
a575 1
		fbuf->fb_len = len + 1;
d577 4
a581 1
		fbuf->fb_dat[len] = '\0';
@


1.14
log
@Fix a big memory leak in libfuse.

Spotted by sthen@@
With some input from stsp@@ and tested by mpk@@ and sthen@@
ok sthen@@, stsp@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.13 2013/10/08 04:57:39 guenther Exp $ */
d760 14
d848 3
@


1.13
log
@1) our dirent entries are now 8 byte aligned.
2) d_type isn't the file's st_mode, but rather a type that can be derived
   from the file's mode.
3) the readdir callback should be setting d_off.  Assume for now that
   fuse-based filesystems can operate with length based offsets
4) if the file type is unknown, use DT_UNKNOWN explictly instead
   of assuming that's equal to zero

ok syl@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.12 2013/10/07 18:41:01 syl Exp $ */
d279 1
a279 3
	fbuf->fb_dat = malloc(FUSEBUFMAXSIZE);
	bzero(fbuf->fb_dat, FUSEBUFMAXSIZE);

d314 3
d431 3
a563 6
	if (!ret)
		len = strnlen(name, PATH_MAX);
	else
		len = -1;

	fbuf->fb_len = len + 1;
a564 1

d566 2
@


1.12
log
@Fix some different signedness error. this commit make clang happier.

Thanks to Pedro Martelletto.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.11 2013/10/07 18:22:18 syl Exp $ */
d191 1
a191 1
((sizeof (struct dirent) - (MAXNAMLEN+1)) + ((NLEN+1 + 3) &~ 3))
d225 1
a225 1
		dir->d_type = stbuf->st_mode;
d228 1
a228 1
		dir->d_type = 0;
d232 1
@


1.11
log
@Remove an unused variable and a useless bzero
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.10 2013/10/07 18:20:31 syl Exp $ */
d382 1
a382 1
		vn = alloc_vn(f, fbuf->fb_dat, -1, fbuf->fb_ino);
d422 1
a422 1
	ret = f->op.read(realname, fbuf->fb_dat, size, offset, &ffi);
d454 1
a454 1
	ret = f->op.write(realname, fbuf->fb_dat, size, offset, &ffi);
d711 1
a711 1
	len = strlen(fbuf->fb_dat);
d715 2
a716 1
	fbuf->fb_err = f->op.symlink(&fbuf->fb_dat[len + 1], realname);
d735 1
a735 1
	len = strlen(fbuf->fb_dat);
@


1.10
log
@Refactor fb_len and fb_err handling in libfuse.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.9 2013/10/07 18:16:43 syl Exp $ */
a96 1
	struct stat st;
a100 1
	bzero(&st, sizeof(st));
@


1.9
log
@Remove useless debug code from libfuse
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.8 2013/10/07 18:08:51 syl Exp $ */
a29 1
					fbuf->fb_len = 0;		\
d87 1
a87 1
ifuse_ops_init(struct fusebuf *fbuf)
a89 2
	fbuf->fb_len = 0;

a103 1
	fbuf->fb_len = 0;
a111 3
	if (fbuf->fb_err)
		fbuf->fb_len = 0;

a122 2
	fbuf->fb_len = 0;

a143 2
	fbuf->fb_len = 0;

a168 2
	fbuf->fb_len = 0;

a178 1
		fbuf->fb_len = 0;
a279 1
	fbuf->fb_len = 0;
a334 2
	fbuf->fb_len = 0;

d341 1
a341 2
	} else
		fbuf->fb_err = 0;
a362 2
	fbuf->fb_len = 0;

a386 1
			fbuf->fb_len = 0;
a393 2
	fbuf->fb_len = 0;

a398 3
	if (fbuf->fb_err)
		fbuf->fb_len = 0;

a418 1
	fbuf->fb_len = 0;
d426 1
a426 1
	if (ret >= 0) {
d428 1
a428 3
		fbuf->fb_err = 0;
	} else	{
		fbuf->fb_len = 0;
a429 1
	}
a452 2
	fbuf->fb_len = 0;

d460 1
a460 1
	if (ret >= 0) {
d462 1
a462 3
		fbuf->fb_err = 0;
		fbuf->fb_len = 0;
	} else
a483 1
	fbuf->fb_len = 0;
a484 1

a491 3

		if (!fbuf->fb_err)
			fbuf->fb_len = 0;
a509 1
	fbuf->fb_len = 0;
a510 1

a517 3

		if (!fbuf->fb_err)
			fbuf->fb_len = 0;
a530 2

	fbuf->fb_len = 0;
a584 2
	fbuf->fb_len = 0;

a602 1
	fbuf->fb_len = 0;
a612 3
	if (fbuf->fb_err)
		fbuf->fb_len = 0;

a627 1
	fbuf->fb_len = 0;
a628 1

a692 1
	fbuf->fb_len = 0;
a697 3

	if (fbuf->fb_err)
		fbuf->fb_len = 0;
a713 1
	fbuf->fb_len = 0;
a739 1
	fbuf->fb_len = 0;
d752 1
a752 1
ifuse_ops_destroy(struct fuse *f, struct fusebuf *fbuf)
a755 3
	fbuf->fb_len = 0;

	fbuf->fb_err = 0;
d766 3
d810 1
a810 1
		ret = ifuse_ops_init(fbuf);
d834 1
a834 1
		ret = ifuse_ops_destroy(f, fbuf);
@


1.8
log
@Adapt libfuse to FUSE kernel changes
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.7 2013/08/10 00:30:43 syl Exp $ */
a30 1
					DPRINTF("\n");			\
a147 3
	DPRINTF("Opcode:\topen\n");
	DPRINTF("Inode:\t%llu\n", (unsigned long long)fbuf->fb_ino);

d195 1
a195 2
		if (vn->fd == NULL) {
			DPRINTF("\n");
a196 1
		}
a407 1
			DPRINTF("\n");
@


1.7
log
@Remove some useless DPRINTF.
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.6 2013/08/08 03:16:13 guenther Exp $ */
d108 1
a108 1
	fbuf->fb_len = FUSEFDSIZE;
d157 1
a157 1
	fbuf->fb_len = FUSEFDSIZE;
d196 1
a196 1
		fbuf->fb_len = FUSEFDSIZE;
d229 1
a229 1
	if ((fd->full || fbdatsize(fbuf) + len > fd->size) ||
d240 1
a240 1
	dir = (struct dirent *) &fbuf->fb_dat[fbdatsize(fbuf)];
d300 3
a302 2
	fbuf->fb_len = FUSEFDSIZE;
	bzero(fbuf->fb_dat, FUSELEN);
d415 1
d422 1
a422 1
	fbuf->fb_len = FUSEFDSIZE;
d426 1
d452 2
a453 1
	fbuf->fb_len = FUSEFDSIZE + size;
d461 1
a461 1
		fbuf->fb_len = FUSEFDSIZE + ret;
d497 1
d502 1
a502 2

		fbuf->fb_len = FUSEFDSIZE;
d526 1
d537 1
a537 1
			fbuf->fb_len = FUSEFDSIZE;
d557 1
d568 1
a568 1
			fbuf->fb_len = FUSEFDSIZE;
a583 1

d586 1
d619 1
a619 1
	fbuf->fb_len = FUSEFDSIZE + len + 1;
d623 1
d643 1
d658 1
a658 1
	fbuf->fb_len = FUSEFDSIZE;
d688 1
d754 1
a754 1
	fbuf->fb_len = FUSEFDSIZE;
d763 1
d785 1
d807 1
@


1.6
log
@Prep for big ino_t: cast to unsigned long long and format with %ll or %q

httpd correction and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.5 2013/06/14 20:56:11 syl Exp $ */
a92 1
	DPRINTF("\n");
a119 1
	DPRINTF("\n");
a138 1
	DPRINTF("\n");
a167 1
	DPRINTF("\n");
a208 1
	DPRINTF("\n");
a336 1
	DPRINTF("\n");
a368 1
	DPRINTF("\n");
a393 1
	DPRINTF("\n");
a428 1
	DPRINTF("\n");
a463 1
	DPRINTF("\n");
a501 1
	DPRINTF("\n");
a535 1
	DPRINTF("\n");
a565 1
	DPRINTF("\n");
a584 1
	DPRINTF("\n");
a621 1
	DPRINTF("\n");
a640 1
	DPRINTF("\n");
a663 1
	DPRINTF("\n");
a686 1
	DPRINTF("\n");
a754 1
	DPRINTF("\n");
a776 1
	DPRINTF("\n");
a802 1
	DPRINTF("\n");
a815 1
	DPRINTF("\n");
a896 1
		DPRINTF("\n");
d898 1
@


1.5
log
@hard code default values in the struct stat returned by getattr.
Some poor fuse client does not set all the struct stat fields...

OK pirofti@@ and beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.4 2013/06/05 18:26:06 tedu Exp $ */
d26 2
a27 1
				DPRINTF("Inode:\t%i\n", fbuf->fb_ino);	\
d106 1
a106 1
	DPRINTF("Inode:\t%i\n", fbuf->fb_ino);
d153 1
a153 1
	DPRINTF("Inode:\t%i\n", fbuf->fb_ino);
d183 1
a183 1
	DPRINTF("Inode:\t%i\n", fbuf->fb_ino);
d295 1
a295 1
	DPRINTF("Inode:\t%i\n", fbuf->fb_ino);
d354 1
a354 1
	DPRINTF("Inode:\t%i\n", fbuf->fb_ino);
d412 1
a412 1
	DPRINTF("Inode:\t%i\n", fbuf->fb_ino);
d427 1
a427 1
	DPRINTF("new ino %i\n", vn->ino);
d611 1
a611 1
	DPRINTF("Inode:\t%i\n", fbuf->fb_ino);
d720 1
a720 1
	DPRINTF("Inode:\t%i\n", fbuf->fb_ino);
d915 1
a915 1
		DPRINTF("Inode:\t%i\n", fbuf->fb_ino);
@


1.4
log
@rename should be working now, from Sylvestre Gallon
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.3 2013/06/04 20:53:27 tedu Exp $ */
d63 7
@


1.3
log
@fix readdir, from sylvestre
@
text
@d1 1
a1 1
/* $OpenBSD: fuse_ops.c,v 1.2 2013/06/03 16:21:08 tedu Exp $ */
d793 27
d898 3
@


1.2
log
@rcsids
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d226 2
a227 1
	if (fd->full || fbdatsize(fbuf) + len > fd->size) {
d239 1
a239 1
	if (!off)
d309 1
@


1.1
log
@add userland fuse library. ok beck deraadt
from Sylvestre Gallon ccna.syl gmail.com
@
text
@d1 1
@

