head	1.10;
access;
symbols
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9;
locks; strict;
comment	@.\" @;


1.10
date	2013.08.08.06.41.05;	author jmc;	state dead;
branches;
next	1.9;

1.9
date	2013.07.05.11.08.15;	author syl;	state Exp;
branches;
next	1.8;

1.8
date	2013.07.05.06.45.07;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.14.20.49.06;	author syl;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.14.20.40.41;	author syl;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.12.06.00.54;	author jmc;	state Exp;
branches;
next	1.4;

1.4
date	2013.06.03.19.46.05;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.03.19.13.21;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.03.16.21.08;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.16.00.50;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@rename fuse docs after existent functions;
@
text
@.\" $OpenBSD: fuse.3,v 1.9 2013/07/05 11:08:15 syl Exp $
.\"
.\" Copyright (c) 2013 Sylvestre Gallon <ccna.syl@@gmail.com>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: July 5 2013 $
.Dt FUSE 3
.Os
.Sh NAME
.Nm fuse ,
.Nm fuse_version ,
.Nm fuse_main ,
.Nm fuse_new ,
.Nm fuse_parse_cmdline ,
.Nm fuse_mount ,
.Nm fuse_remove_signal_handlers ,
.Nm fuse_set_signal_handlers ,
.Nm fuse_get_session ,
.Nm fuse_get_context ,
.Nm fuse_is_lib_option ,
.Nm fuse_loop ,
.Nm fuse_loop_mt ,
.Nm fuse_chan_fd ,
.Nm fuse_unmount ,
.Nm fuse_daemonize ,
.Nm fuse_destroy ,
.Nm fuse_teardown
.Nd FUSE implementation routines
.Sh SYNOPSIS
.In fuse.h
.Ft int
.Fn fuse_version "void"
.Ft int
.Fn fuse_main "int argc" "char **argv" "const struct fuse_operations *ops" \
    "void *data"
.Ft struct fuse *
.Fn fuse_new "struct fuse_chan *fc" "struct fuse_args *args" \
    "const struct fuse_operations *ops" "size_t size" "void *userdata"
.Ft int
.Fn fuse_parse_cmdline "struct fuse_args *args" "char **mp" "int *mt" "int *fg"
.Ft struct fuse_chan *
.Fn fuse_mount "const char *dir" "struct fuse_args *args"
.Ft void
.Fn fuse_remove_signal_handlers "struct fuse_session *se"
.Ft int
.Fn fuse_set_signal_handlers "struct fuse_session *se"
.Ft struct fuse_session *
.Fn fuse_get_session "struct fuse *f"
.Ft struct fuse_context *
.Fn fuse_get_context "void"
.Ft int
.Fn fuse_is_lib_option "const char *opt"
.Ft int
.Fn fuse_loop "struct fuse *fuse"
.Ft int
.Fn fuse_loop_mt "struct fuse *fuse"
.Ft int
.Fn fuse_chan_fd "struct fuse_chan *ch"
.Ft void
.Fn fuse_unmount "const char *dir" "struct fuse_chan *ch"
.Ft int
.Fn fuse_daemonize "int foreground"
.Ft void
.Fn fuse_destroy "struct fuse *f"
.Ft void
.Fn fuse_teardown "struct fuse *f" "char *mp"
.Sh DESCRIPTION
The
.Nm
library provides routines to implement a filesystem in userspace.
.Pp
There are two ways of implementing a FUSE filesystem:
by calling only
.Fn fuse_main
and passing this function the
.Em ops
argument containing all the callbacks of the filesystem,
or by using the other functions,
as detailed below.
.Pp
.Fn fuse_version
returns the FUSE version number.
.Pp
.Fn fuse_new
returns a
.Fa struct fuse
that will be needed by
.Fn fuse_loop .
.Pp
.Fn fuse_parse_cmdline
parses the
.Fa struct fuse_args
given by the user and will set
.Fa mp
with a char * containing the mountpoint directory.
.Pp
.Fn fuse_mount
looks for an empty
.Xr fuse 4
device to create a connection.
If this function finds an available device it will open it for FUSE
communication with the FUSE VFS driver and will mount the filesystem.
This function will return a
.Fa struct fuse_chan
that will be needed by
.Fn fuse_new .
.Pp
.Fn fuse_remove_signal_handlers
is currently undocumented.
.Pp
.Fn fuse_set_signal_handlers
is currently undocumented.
.Pp
.Fn fuse_get_session
returns a pointer to the structure
.Fa fuse_session
contained in a
.Fa struct fuse .
.Pp
.Fn fuse_get_context
returns a pointer to the structure
.Fa fuse_context .
The returned fuse_context is only available during the lifetime of a FUSE
operation.
.Pp
.Fn fuse_is_lib_option
checks if the string
.Fa opt
is an option handled by libfuse or by the FUSE client.
It returns 1 if it is handled by the lib and 0 otherwise.
.Pp
.Fn fuse_loop_mt
is unsupported.
.Pp
.Fn fuse_loop
is the main loop of a FUSE program.
This function looks for FUSE requests from the kernel and responds to them
using the
.Fa struct fuse_operation
present in the structure
.Fa fuse .
It will return only if something goes wrong
or if the kernel sends a
.Fa FUSE_DESTROY
opcode to libfuse.
.Pp
.Fn fuse_chan_fd
returns the filedescriptor used by the given
.Fa fuse_chan
structure.
.Pp
.Fn fuse_unmount
unmounts the
.Fa dir
mountpoint.
.Pp
.Fn fuse_daemonize
daemonises the FUSE library.
It runs the FUSE program in the background,
whilst continuing to handle kernel filesystem opcodes.
.Pp
.Fn fuse_destroy
is currently undocumented.
.Pp
.Fn fuse_teardown
calls
.Fn fuse_unmount
and
.Fn fuse_destroy .
.Sh EXAMPLES
Here is a simple example of a FUSE implementation:
.Bd -literal
#include <errno.h>
#include <fuse.h>
#include <string.h>

static int
fs_readdir(const char *path, void *data, fuse_fill_dir_t filler,
    off_t off, struct fuse_file_info *ffi)
{
	if (strcmp(path, "/") != 0)
		return (-ENOENT);

	filler(data, ".", NULL, 0);
	filler(data, "..", NULL, 0);
	filler(data, "file", NULL, 0);
	return (0);
}

static int
fs_read(const char *path, char *buf, size_t size, off_t off,
    struct fuse_file_info *ffi)
{
	if (off >= 5)
		return (0);

	size = 5 - off;
	memcpy(buf, "data." + off, size);
	return (size);
}

static int
fs_open(const char *path, struct fuse_file_info *ffi)
{
	if (strncmp(path, "/file", 10) != 0)
		return (-ENOENT);

	if ((ffi->flags & 3) != O_RDONLY)
		return (-EACCES);

	return (0);
}

static int
fs_getattr(const char *path, struct stat *st)
{
	if (strcmp(path, "/") == 0) {
		st->st_blksize = 512;
		st->st_mode = 0755;
		st->st_nlink = 2;
	} else if (strcmp(path, "/file") == 0) {
		st->st_mode = 0644;
		st->st_blksize = 512;
		st->st_nlink = 1;
		st->st_size = 5;
	} else {
		return (-ENOENT);
	}

	return (0);
}

struct fuse_operations fsops = {
	.readdir = fs_readdir,
	.read = fs_read,
	.open = fs_open,
	.getattr = fs_getattr,
};

int
main(int ac, char **av)
{
	return (fuse_main(ac, av, &fsops, NULL));
}
.Ed
.Sh SEE ALSO
The FUSE specifications and orignal implementation can be found at:
.Lk http://fuse.sourceforge.net/
.Pp
.Xr fuse 4
.Sh HISTORY
The
.Nm
library first appeared in
.Ox 5.4 .
.Sh BUGS
This man page is woefully incomplete.
@


1.9
log
@Add support for fuse_teardown(3). This function
is needed by zipfs.

ok tedu@@
@
text
@d1 1
a1 1
.\" $OpenBSD: fuse.3,v 1.8 2013/07/05 06:45:07 jmc Exp $
@


1.8
log
@various tidy up;
ok tedu sobrado Sylvestre Gallon
@
text
@d1 1
a1 1
.\" $OpenBSD: fuse.3,v 1.7 2013/06/14 20:49:06 syl Exp $
d17 1
a17 1
.Dd $Mdocdate: June 14 2013 $
d37 2
a38 1
.Nm fuse_destroy
d76 2
d175 6
@


1.7
log
@Add support for fuse_get_context(3) needed by ntfs-3g.

OK pirofti@@ and beck@@ "assuming I am getting to setting
the initial pid/gid/uid values correctly soon".
@
text
@d1 1
a1 1
.\" $OpenBSD: fuse.3,v 1.6 2013/06/14 20:40:41 syl Exp $
d80 2
a81 2
There are two ways of Implementing a Fuse filesystem.
You can implement a FS by calling only
d85 4
a88 3
argument containing all the callbacks of the filesystem.
Or you can use all others functions.
.Ss FUNCTIONS
d90 1
a90 1
returns the fuse version number.
d106 1
a106 1
will look for an empty
d109 2
a110 2
If this function finds an available device it will open it for fuse
communication with the fuse VFS driver and will mount the filesystem.
d117 1
a117 1
I do not know yet what this function is supposed to do...
d120 1
a120 1
I do not know yet what this function is supposed to do...
d131 1
a131 1
The returned fuse_context is only available during the lifetime of a fuse
d137 1
a137 1
is an option handled by the libfuse or by the fuse client.
d141 1
a141 2
Do not use!
It is not supported yet (and we will probably never need it...)
d144 2
a145 2
is the main loop of a fuse program.
This function will look for fuse requests from kernel and will respond to them
d166 3
a168 3
daemonises the fuse library.
It will permit to background the fuse program that will continue to handle
kernel filesystem opcodes.
d171 1
a171 1
I do not know yet what this function is supposed to do...
d173 1
a173 1
Here is a simple example of a fuse implementation:
d249 1
a249 3
The
.Tn FUSE
specifications and orignal implementation can be found at:
@


1.6
log
@add support for fuse_version(3). Needed by ntfs-3g.

Ok beck@@ and pirofti@@.
@
text
@d1 1
a1 1
.\" $OpenBSD: fuse.3,v 1.5 2013/06/12 06:00:54 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: June 12 2013 $
d30 1
d59 2
d126 6
@


1.5
log
@some simple initial fixes; this file still needs read properly
@
text
@d1 1
a1 1
.\" $OpenBSD: fuse.3,v 1.4 2013/06/03 19:46:05 tedu Exp $
d17 1
a17 1
.Dd $Mdocdate: June 3 2013 $
d22 1
d41 2
d85 3
@


1.4
log
@first stab at rewording
@
text
@d1 1
a1 1
.\" $OpenBSD: fuse.3,v 1.3 2013/06/03 19:13:21 tedu Exp $
d34 1
a34 1
.Nm fuse_daemonize,
d38 1
a38 1
.Fd #include \*[Lt]fuse.h\*[Gt]
d73 1
a73 1
.Ss INTRODUCTION
d157 1
a157 1
.Sh EXAMPLE
@


1.3
log
@5.4
@
text
@d1 1
a1 1
.\" $OpenBSD: fuse.3,v 1.2 2013/06/03 16:21:08 tedu Exp $
d72 1
a72 1
library provides routine to implement a filesystem in userspace.
d74 2
a75 2
There is two way of Implementing a Fuse filesystem. You can implement a fs only
by calling
d77 1
a77 1
and giving this function the
d79 2
a80 2
argument containing all the callbacks of your filesystems. Or you can use all
others functions.
d83 1
a83 1
Fuse new return a
d85 2
a86 2
That will be needed by
.Fn fuse_loop
d89 1
a89 1
This function will parse the
d96 1
a96 1
Will look for an empty
d98 4
a101 3
device to create a connection. If this function find an available device it will
open it to use it for fuse communication with the fuse VFS driver and will mount
the filesystem. This function will return a
d104 1
a104 1
.Fn fuse_new
d113 1
a113 1
returns a pointer on the structure
d116 1
a116 1
.Fa struct fuse
d119 1
a119 1
check if the string
d121 2
a122 2
is an option handled by the libfuse or by the fuse client. It returns 1 if it is
handled by the lib and 0 in the other case.
d125 2
a126 1
Do not use! It is not supported yet (and we will probably never need it...)
d129 3
a131 2
This is the mainloop of a fuse program. This function will look for fuse
request from kernel and will respond to it using the
d134 1
a134 1
.Fa fuse.
d136 1
a136 1
or if the kernel send a
d146 1
a146 1
unmount the
d151 3
a153 2
daemonise the fuse library. It will permit to background the fuse program that
will continue to handles kernel filesystems opcodes.
d246 1
a246 1
This man page is woefully incomplete
@


1.2
log
@rcsids
@
text
@d1 1
a1 1
.\" $OpenBSD$
d240 1
a240 1
.Ox ??? .
@


1.1
log
@add userland fuse library. ok beck deraadt
from Sylvestre Gallon ccna.syl gmail.com
@
text
@d1 1
d17 1
a17 1
.Dd $Mdocdate: April 16 2013 $
@

