head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.8
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.6
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.8
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.20
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.18
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.16
	OPENBSD_5_0:1.16.0.14
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.12
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.10
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.6
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.9.0.8
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.2.0.12
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	ossaudio00:1.1.1.1
	ossaudio:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.04.19.08.42.19;	author ratchov;	state Exp;
branches;
next	1.17;
commitid	IWsUM9VuLDWvThtp;

1.17
date	2013.03.27.20.28.22;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.26.05.42.05;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.04.05.03.19;	author jakemsr;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.12.05.43.59;	author jakemsr;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.12.05.11.16;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.06.04.24.39;	author jakemsr;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.08.01.00.13;	author jakemsr;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.28.01.15.15;	author jakemsr;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.13.12.01.11;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.25.21.32.23;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.19.18.35.04;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.03.19.01.48;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.24.21.59.53;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.18.19.33.30;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.24.04.21.03;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	98.05.25.21.37.46;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	98.05.01.09.23.00;	author provos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.05.01.09.23.00;	author provos;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Make SNDCLT_DSP_* ioctls return ENOTTY, and remove the corresponding
code. No ABI change.

ok armani@@, guenther@@, sthen@@
@
text
@/*	$OpenBSD: ossaudio.c,v 1.17 2013/03/27 20:28:22 tedu Exp $	*/
/*	$NetBSD: ossaudio.c,v 1.14 2001/05/10 01:53:48 augustss Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This is an OSS (Linux) sound API emulator.
 * It provides the essentials of the API.
 */

/* XXX This file is essentially the same as sys/compat/ossaudio.c.
 * With some preprocessor magic it could be the same file.
 */

#include <stdarg.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>
#include <sys/stat.h>
#include <errno.h>

#include "soundcard.h"
#undef ioctl

#define GET_DEV(com) ((com) & 0xff)

#define TO_OSSVOL(x)	(((x) * 100 + 127) / 255)
#define FROM_OSSVOL(x)	((((x) > 100 ? 100 : (x)) * 255 + 50) / 100)

static struct audiodevinfo *getdevinfo(int);

static int mixer_ioctl(int, unsigned long, void *);
static int opaque_to_enum(struct audiodevinfo *di, audio_mixer_name_t *label, int opq);
static int enum_to_ord(struct audiodevinfo *di, int enm);
static int enum_to_mask(struct audiodevinfo *di, int enm);

#define INTARG (*(int*)argp)

int
_oss_ioctl(int fd, unsigned long com, ...)
{
	va_list ap;
	void *argp;

	va_start(ap, com);
	argp = va_arg(ap, void *);
	va_end(ap);
	if (IOCGROUP(com) == 'P')
		return ENOTTY;
	else if (IOCGROUP(com) == 'M')
		return mixer_ioctl(fd, com, argp);
	else
		return ioctl(fd, com, argp);
}

/* If the mixer device should have more than MAX_MIXER_DEVS devices
 * some will not be available to Linux */
#define MAX_MIXER_DEVS 64
struct audiodevinfo {
	int done;
	dev_t dev;
	ino_t ino;
	int16_t devmap[SOUND_MIXER_NRDEVICES],
	        rdevmap[MAX_MIXER_DEVS];
	char names[MAX_MIXER_DEVS][MAX_AUDIO_DEV_LEN];
	int enum2opaque[MAX_MIXER_DEVS];
        u_long devmask, recmask, stereomask;
	u_long caps, recsource;
};

static int
opaque_to_enum(struct audiodevinfo *di, audio_mixer_name_t *label, int opq)
{
	int i, o;

	for (i = 0; i < MAX_MIXER_DEVS; i++) {
		o = di->enum2opaque[i];
		if (o == opq)
			break;
		if (o == -1 && label != NULL &&
		    !strncmp(di->names[i], label->name, sizeof di->names[i])) {
			di->enum2opaque[i] = opq;
			break;
		}
	}
	if (i >= MAX_MIXER_DEVS)
		i = -1;
	/*printf("opq_to_enum %s %d -> %d\n", label->name, opq, i);*/
	return (i);
}

static int
enum_to_ord(struct audiodevinfo *di, int enm)
{
	if (enm >= MAX_MIXER_DEVS)
		return (-1);

	/*printf("enum_to_ord %d -> %d\n", enm, di->enum2opaque[enm]);*/
	return (di->enum2opaque[enm]);
}

static int
enum_to_mask(struct audiodevinfo *di, int enm)
{
	int m;
	if (enm >= MAX_MIXER_DEVS)
		return (0);

	m = di->enum2opaque[enm];
	if (m == -1)
		m = 0;
	/*printf("enum_to_mask %d -> %d\n", enm, di->enum2opaque[enm]);*/
	return (m);
}

/*
 * Collect the audio device information to allow faster
 * emulation of the Linux mixer ioctls.  Cache the information
 * to eliminate the overhead of repeating all the ioctls needed
 * to collect the information.
 */
static struct audiodevinfo *
getdevinfo(int fd)
{
	mixer_devinfo_t mi, cl;
	int i, j, e;
	static struct {
		char *name;
		int code;
	} *dp, devs[] = {
		{ AudioNmicrophone,	SOUND_MIXER_MIC },
		{ AudioNline,		SOUND_MIXER_LINE },
		{ AudioNcd,		SOUND_MIXER_CD },
		{ AudioNdac,		SOUND_MIXER_PCM },
		{ AudioNaux,		SOUND_MIXER_LINE1 },
		{ AudioNrecord,		SOUND_MIXER_IMIX },
		{ AudioNmaster,		SOUND_MIXER_VOLUME },
		{ AudioNtreble,		SOUND_MIXER_TREBLE },
		{ AudioNbass,		SOUND_MIXER_BASS },
		{ AudioNspeaker,	SOUND_MIXER_SPEAKER },
		{ AudioNoutput,		SOUND_MIXER_OGAIN },
		{ AudioNinput,		SOUND_MIXER_IGAIN },
		{ AudioNfmsynth,	SOUND_MIXER_SYNTH },
		{ AudioNmidi,		SOUND_MIXER_SYNTH },
		{ 0, -1 }
	};
	static struct audiodevinfo devcache = { 0 };
	struct audiodevinfo *di = &devcache;
	struct stat sb;

	/* Figure out what device it is so we can check if the
	 * cached data is valid.
	 */
	if (fstat(fd, &sb) < 0)
		return 0;
	if (di->done && (di->dev == sb.st_dev && di->ino == sb.st_ino))
		return di;

	di->done = 1;
	di->dev = sb.st_dev;
	di->ino = sb.st_ino;
	di->devmask = 0;
	di->recmask = 0;
	di->stereomask = 0;
	di->recsource = ~0;
	di->caps = 0;
	for(i = 0; i < SOUND_MIXER_NRDEVICES; i++)
		di->devmap[i] = -1;
	for(i = 0; i < MAX_MIXER_DEVS; i++) {
		di->rdevmap[i] = -1;
		di->names[i][0] = '\0';
		di->enum2opaque[i] = -1;
	}
	for(i = 0; i < MAX_MIXER_DEVS; i++) {
		mi.index = i;
		if (ioctl(fd, AUDIO_MIXER_DEVINFO, &mi) < 0)
			break;
		switch(mi.type) {
		case AUDIO_MIXER_VALUE:
			for(dp = devs; dp->name; dp++)
		    		if (strcmp(dp->name, mi.label.name) == 0)
					break;
			if (dp->code >= 0) {
				di->devmap[dp->code] = i;
				di->rdevmap[i] = dp->code;
				di->devmask |= 1 << dp->code;
				if (mi.un.v.num_channels == 2)
					di->stereomask |= 1 << dp->code;
				strncpy(di->names[i], mi.label.name,
					sizeof di->names[i]);
			}
			break;
		}
	}
	for(i = 0; i < MAX_MIXER_DEVS; i++) {
		mi.index = i;
		if (ioctl(fd, AUDIO_MIXER_DEVINFO, &mi) < 0)
			break;
		if (strcmp(mi.label.name, AudioNsource) != 0)
			continue;
		cl.index = mi.mixer_class;
		if (ioctl(fd, AUDIO_MIXER_DEVINFO, &cl) < 0)
			break;
		if ((cl.type != AUDIO_MIXER_CLASS) ||
		    (strcmp(cl.label.name, AudioCrecord) != 0))
			continue;
		di->recsource = i;
		switch(mi.type) {
		case AUDIO_MIXER_ENUM:
			for(j = 0; j < mi.un.e.num_mem; j++) {
				e = opaque_to_enum(di,
						   &mi.un.e.member[j].label,
						   mi.un.e.member[j].ord);
				if (e >= 0)
					di->recmask |= 1 << di->rdevmap[e];
			}
			di->caps = SOUND_CAP_EXCL_INPUT;
			break;
		case AUDIO_MIXER_SET:
			for(j = 0; j < mi.un.s.num_mem; j++) {
				e = opaque_to_enum(di,
						   &mi.un.s.member[j].label,
						   mi.un.s.member[j].mask);
				if (e >= 0)
					di->recmask |= 1 << di->rdevmap[e];
			}
			break;
		}
	}
	return di;
}

int
mixer_ioctl(int fd, unsigned long com, void *argp)
{
	struct audiodevinfo *di;
	struct mixer_info *omi;
	struct audio_device adev;
	mixer_ctrl_t mc;
	int idat = 0;
	int i;
	int retval;
	int l, r, n, error, e;

	di = getdevinfo(fd);
	if (di == 0)
		return -1;

	switch (com) {
	case OSS_GETVERSION:
		idat = SOUND_VERSION;
		break;
	case SOUND_MIXER_INFO:
	case SOUND_OLD_MIXER_INFO:
		error = ioctl(fd, AUDIO_GETDEV, &adev);
		if (error)
			return (error);
		omi = argp;
		if (com == SOUND_MIXER_INFO)
			omi->modify_counter = 1;
		strncpy(omi->id, adev.name, sizeof omi->id);
		strncpy(omi->name, adev.name, sizeof omi->name);
		return 0;
	case SOUND_MIXER_READ_RECSRC:
		if (di->recsource == -1)
			return EINVAL;
		mc.dev = di->recsource;
		if (di->caps & SOUND_CAP_EXCL_INPUT) {
			mc.type = AUDIO_MIXER_ENUM;
			retval = ioctl(fd, AUDIO_MIXER_READ, &mc);
			if (retval < 0)
				return retval;
			e = opaque_to_enum(di, NULL, mc.un.ord);
			if (e >= 0)
				idat = 1 << di->rdevmap[e];
		} else {
			mc.type = AUDIO_MIXER_SET;
			retval = ioctl(fd, AUDIO_MIXER_READ, &mc);
			if (retval < 0)
				return retval;
			e = opaque_to_enum(di, NULL, mc.un.mask);
			if (e >= 0)
				idat = 1 << di->rdevmap[e];
		}
		break;
	case SOUND_MIXER_READ_DEVMASK:
		idat = di->devmask;
		break;
	case SOUND_MIXER_READ_RECMASK:
		idat = di->recmask;
		break;
	case SOUND_MIXER_READ_STEREODEVS:
		idat = di->stereomask;
		break;
	case SOUND_MIXER_READ_CAPS:
		idat = di->caps;
		break;
	case SOUND_MIXER_WRITE_RECSRC:
	case SOUND_MIXER_WRITE_R_RECSRC:
		if (di->recsource == -1)
			return EINVAL;
		mc.dev = di->recsource;
		idat = INTARG;
		if (di->caps & SOUND_CAP_EXCL_INPUT) {
			mc.type = AUDIO_MIXER_ENUM;
			for(i = 0; i < SOUND_MIXER_NRDEVICES; i++)
				if (idat & (1 << i))
					break;
			if (i >= SOUND_MIXER_NRDEVICES ||
			    di->devmap[i] == -1)
				return EINVAL;
			mc.un.ord = enum_to_ord(di, di->devmap[i]);
		} else {
			mc.type = AUDIO_MIXER_SET;
			mc.un.mask = 0;
			for(i = 0; i < SOUND_MIXER_NRDEVICES; i++) {
				if (idat & (1 << i)) {
					if (di->devmap[i] == -1)
						return EINVAL;
					mc.un.mask |= enum_to_mask(di, di->devmap[i]);
				}
			}
		}
		return ioctl(fd, AUDIO_MIXER_WRITE, &mc);
	default:
		if (MIXER_READ(SOUND_MIXER_FIRST) <= com &&
		    com < MIXER_READ(SOUND_MIXER_NRDEVICES)) {
			n = GET_DEV(com);
			if (di->devmap[n] == -1)
				return EINVAL;
			mc.dev = di->devmap[n];
			mc.type = AUDIO_MIXER_VALUE;
		    doread:
			mc.un.value.num_channels = di->stereomask & (1<<n) ? 2 : 1;
			retval = ioctl(fd, AUDIO_MIXER_READ, &mc);
			if (retval < 0)
				return retval;
			if (mc.type != AUDIO_MIXER_VALUE)
				return EINVAL;
			if (mc.un.value.num_channels != 2) {
				l = r = mc.un.value.level[AUDIO_MIXER_LEVEL_MONO];
			} else {
				l = mc.un.value.level[AUDIO_MIXER_LEVEL_LEFT];
				r = mc.un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
			}
			idat = TO_OSSVOL(l) | (TO_OSSVOL(r) << 8);
			break;
		} else if ((MIXER_WRITE_R(SOUND_MIXER_FIRST) <= com &&
			   com < MIXER_WRITE_R(SOUND_MIXER_NRDEVICES)) ||
			   (MIXER_WRITE(SOUND_MIXER_FIRST) <= com &&
			   com < MIXER_WRITE(SOUND_MIXER_NRDEVICES))) {
			n = GET_DEV(com);
			if (di->devmap[n] == -1)
				return EINVAL;
			idat = INTARG;
			l = FROM_OSSVOL( idat       & 0xff);
			r = FROM_OSSVOL((idat >> 8) & 0xff);
			mc.dev = di->devmap[n];
			mc.type = AUDIO_MIXER_VALUE;
			if (di->stereomask & (1<<n)) {
				mc.un.value.num_channels = 2;
				mc.un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;
				mc.un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;
			} else {
				mc.un.value.num_channels = 1;
				mc.un.value.level[AUDIO_MIXER_LEVEL_MONO] = (l+r)/2;
			}
			retval = ioctl(fd, AUDIO_MIXER_WRITE, &mc);
			if (retval < 0)
				return retval;
			if (MIXER_WRITE(SOUND_MIXER_FIRST) <= com &&
			   com < MIXER_WRITE(SOUND_MIXER_NRDEVICES))
				return 0;
			goto doread;
		} else {
			errno = EINVAL;
			return -1;
		}
	}
	INTARG = idat;
	return 0;
}
@


1.17
log
@rename define to reflect current operating system, as in sys/compat
from tim van der molen
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.16 2008/06/26 05:42:05 ray Exp $	*/
a56 3
static void setblocksize(int, struct audio_info *);

static int audio_ioctl(int, unsigned long, void *);
d74 1
a74 1
		return audio_ioctl(fd, com, argp);
a80 375
static int
audio_ioctl(int fd, unsigned long com, void *argp)
{

	struct audio_info tmpinfo;
	struct audio_offset tmpoffs;
	struct audio_buf_info bufinfo;
	struct count_info cntinfo;
	struct audio_encoding tmpenc;
	struct audio_bufinfo tmpab;
	u_long ldat;
	u_int u;
	int idat, idata;
	int tempret, retval = 0, rerr = 0;

	switch (com) {
	case SNDCTL_DSP_RESET:
		retval = ioctl(fd, AUDIO_FLUSH, 0);
		rerr = errno;
		break;
	case SNDCTL_DSP_SYNC:
		retval = ioctl(fd, AUDIO_DRAIN, 0);
		rerr = errno;
		break;
	case SNDCTL_DSP_POST:
		/* This call is merely advisory, and may be a nop. */
		break;
	case SNDCTL_DSP_SPEED:
		AUDIO_INITINFO(&tmpinfo);
		tmpinfo.play.sample_rate =
		tmpinfo.record.sample_rate = INTARG;
		retval = ioctl(fd, AUDIO_SETINFO, &tmpinfo);
		rerr = errno;
		/* FALLTHRU */
	case SOUND_PCM_READ_RATE:
		tempret = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval >= 0) {
			retval = tempret;
			rerr = errno;
		}
		INTARG = tmpinfo.play.sample_rate;
		break;
	case SNDCTL_DSP_STEREO:
		AUDIO_INITINFO(&tmpinfo);
		tmpinfo.play.channels =
		tmpinfo.record.channels = INTARG ? 2 : 1;
		retval = ioctl(fd, AUDIO_SETINFO, &tmpinfo);
		rerr = errno;
		tempret = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval >= 0) {
			retval = tempret;
			rerr = errno;
		}
		INTARG = tmpinfo.play.channels - 1;
		break;
	case SNDCTL_DSP_GETBLKSIZE:
		retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		rerr = errno;
		setblocksize(fd, &tmpinfo);
		INTARG = tmpinfo.blocksize;
		break;
	case SNDCTL_DSP_SETFMT:
		AUDIO_INITINFO(&tmpinfo);
		switch (INTARG) {
		case AFMT_MU_LAW:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 8;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_ULAW;
			break;
		case AFMT_A_LAW:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 8;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_ALAW;
			break;
		case AFMT_U8:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 8;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_ULINEAR;
			break;
		case AFMT_S8:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 8;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_SLINEAR;
			break;
		case AFMT_S16_LE:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 16;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_SLINEAR_LE;
			break;
		case AFMT_S16_BE:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 16;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_SLINEAR_BE;
			break;
		case AFMT_U16_LE:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 16;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_ULINEAR_LE;
			break;
		case AFMT_U16_BE:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 16;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_ULINEAR_BE;
			break;
		default:
			retval = -1;
			rerr = EINVAL;
			break;
		}
		if (retval == -1) {
			break;
		} else {
			retval = ioctl(fd, AUDIO_SETINFO, &tmpinfo);
			rerr = errno;
		}
		/* FALLTHRU */
	case SOUND_PCM_READ_BITS:
		(void) ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		switch (tmpinfo.play.encoding) {
		case AUDIO_ENCODING_ULAW:
			idat = AFMT_MU_LAW;
			break;
		case AUDIO_ENCODING_ALAW:
			idat = AFMT_A_LAW;
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
			if (tmpinfo.play.precision == 16)
				idat = AFMT_S16_LE;
			else
				idat = AFMT_S8;
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			if (tmpinfo.play.precision == 16)
				idat = AFMT_S16_BE;
			else
				idat = AFMT_S8;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (tmpinfo.play.precision == 16)
				idat = AFMT_U16_LE;
			else
				idat = AFMT_U8;
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			if (tmpinfo.play.precision == 16)
				idat = AFMT_U16_BE;
			else
				idat = AFMT_U8;
			break;
		case AUDIO_ENCODING_ADPCM:
			idat = AFMT_IMA_ADPCM;
			break;
		default:
			idat = AFMT_MU_LAW;  /* XXX default encoding */
			break;
		}
		INTARG = idat;
		break;
	case SNDCTL_DSP_CHANNELS:
		AUDIO_INITINFO(&tmpinfo);
		tmpinfo.play.channels =
		tmpinfo.record.channels = INTARG;
		retval = ioctl(fd, AUDIO_SETINFO, &tmpinfo);
		rerr = errno;
		/* FALLTHRU */
	case SOUND_PCM_READ_CHANNELS:
		tempret = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval >= 0) {
			retval = tempret;
			rerr = errno;
		}
		INTARG = tmpinfo.play.channels;
		break;
	case SOUND_PCM_WRITE_FILTER:
	case SOUND_PCM_READ_FILTER:
		rerr = EINVAL;
		retval = -1; /* XXX unimplemented */
		break;
	case SNDCTL_DSP_SUBDIVIDE:
		retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval < 0)
			return retval;
		setblocksize(fd, &tmpinfo);
		idat = INTARG;
		if (idat == 0)
			idat = tmpinfo.play.buffer_size / tmpinfo.blocksize;
		idat = (tmpinfo.play.buffer_size / idat) & -4;
		AUDIO_INITINFO(&tmpinfo);
		tmpinfo.blocksize = idat;
		retval = ioctl(fd, AUDIO_SETINFO, &tmpinfo);
		if (retval < 0)
			return retval;
		INTARG = tmpinfo.play.buffer_size / tmpinfo.blocksize;
		break;
	case SNDCTL_DSP_SETFRAGMENT:
		AUDIO_INITINFO(&tmpinfo);
		idat = INTARG;
		if ((idat & 0xffff) < 4 || (idat & 0xffff) > 17)
			return EINVAL;
		tmpinfo.blocksize = 1 << (idat & 0xffff);
		tmpinfo.hiwat = ((unsigned)idat >> 16) & 0x7fff;
		if (tmpinfo.hiwat == 0)	/* 0 means set to max */
			tmpinfo.hiwat = 65536;
		retval = ioctl(fd, AUDIO_SETINFO, &tmpinfo);
		rerr = errno;
		tempret = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval >= 0) {
			retval = tempret;
			rerr = errno;
		}
		u = tmpinfo.blocksize;
		for(idat = 0; u > 1; idat++, u >>= 1)
			;
		idat |= (tmpinfo.hiwat & 0x7fff) << 16;
		INTARG = idat;
		break;
	case SNDCTL_DSP_GETFMTS:
		for(idat = 0, tmpenc.index = 0;
		    ioctl(fd, AUDIO_GETENC, &tmpenc) == 0;
		    tmpenc.index++) {
			switch(tmpenc.encoding) {
			case AUDIO_ENCODING_ULAW:
				idat |= AFMT_MU_LAW;
				break;
			case AUDIO_ENCODING_ALAW:
				idat |= AFMT_A_LAW;
				break;
			case AUDIO_ENCODING_SLINEAR:
				idat |= AFMT_S8;
				break;
			case AUDIO_ENCODING_SLINEAR_LE:
				if (tmpenc.precision == 16)
					idat |= AFMT_S16_LE;
				else
					idat |= AFMT_S8;
				break;
			case AUDIO_ENCODING_SLINEAR_BE:
				if (tmpenc.precision == 16)
					idat |= AFMT_S16_BE;
				else
					idat |= AFMT_S8;
				break;
			case AUDIO_ENCODING_ULINEAR:
				idat |= AFMT_U8;
				break;
			case AUDIO_ENCODING_ULINEAR_LE:
				if (tmpenc.precision == 16)
					idat |= AFMT_U16_LE;
				else
					idat |= AFMT_U8;
				break;
			case AUDIO_ENCODING_ULINEAR_BE:
				if (tmpenc.precision == 16)
					idat |= AFMT_U16_BE;
				else
					idat |= AFMT_U8;
				break;
			case AUDIO_ENCODING_ADPCM:
				idat |= AFMT_IMA_ADPCM;
				break;
			default:
				break;
			}
		}
		INTARG = idat;
		break;
	case SNDCTL_DSP_GETOSPACE:
		retval = ioctl(fd, AUDIO_GETPRINFO, &tmpab);
		rerr = errno;
		bufinfo.fragsize = tmpab.blksize;
		bufinfo.fragstotal = tmpab.hiwat;
		bufinfo.bytes = tmpab.hiwat * tmpab.blksize - tmpab.seek;
		if (tmpab.blksize != 0)
			bufinfo.fragments = bufinfo.bytes / tmpab.blksize;
		else
			bufinfo.fragments = 0;
		*(struct audio_buf_info *)argp = bufinfo;
		break;
	case SNDCTL_DSP_GETISPACE:
		retval = ioctl(fd, AUDIO_GETRRINFO, &tmpab);
		rerr = errno;
		bufinfo.fragsize = tmpab.blksize;
		bufinfo.fragstotal = tmpab.hiwat;
		bufinfo.bytes = tmpab.seek;
		if (tmpab.blksize != 0 )
			bufinfo.fragments = bufinfo.bytes / tmpab.blksize;
		else
			bufinfo.fragments = 0;
		*(struct audio_buf_info *)argp = bufinfo;
		break;
	case SNDCTL_DSP_NONBLOCK:
		idat = 1;
		retval = ioctl(fd, FIONBIO, &idat);
		rerr = errno;
		break;
	case SNDCTL_DSP_GETCAPS:
		retval = ioctl(fd, AUDIO_GETPROPS, &idata);
		rerr = errno;
		idat = DSP_CAP_TRIGGER;
		if (idata & AUDIO_PROP_FULLDUPLEX)
			idat |= DSP_CAP_DUPLEX;
		if (idata & AUDIO_PROP_MMAP)
			idat |= DSP_CAP_MMAP;
		INTARG = idat;
		break;
	case SNDCTL_DSP_SETTRIGGER:
		idat = INTARG;
		AUDIO_INITINFO(&tmpinfo);
		if (idat & PCM_ENABLE_OUTPUT)
			tmpinfo.play.pause = 0;
		if (idat & PCM_ENABLE_INPUT)
			tmpinfo.record.pause = 0;
		retval = ioctl(fd, AUDIO_SETINFO, &tmpinfo);
		rerr = errno;
		/* FALLTHRU */
	case SNDCTL_DSP_GETTRIGGER:
		tempret = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval >= 0) {
			retval = tempret;
			rerr = errno;
		}
		idat = (tmpinfo.play.pause ? 0 : PCM_ENABLE_OUTPUT) |
		       (tmpinfo.record.pause ? 0 : PCM_ENABLE_INPUT);
		INTARG = idat;
		break;
	case SNDCTL_DSP_GETIPTR:
		retval = ioctl(fd, AUDIO_GETIOFFS, &tmpoffs);
		rerr = errno;
		cntinfo.bytes = tmpoffs.samples;
		cntinfo.blocks = tmpoffs.deltablks;
		cntinfo.ptr = tmpoffs.offset;
		*(struct count_info *)argp = cntinfo;
		break;
	case SNDCTL_DSP_GETOPTR:
		retval = ioctl(fd, AUDIO_GETOOFFS, &tmpoffs);
		rerr = errno;
		cntinfo.bytes = tmpoffs.samples;
		cntinfo.blocks = tmpoffs.deltablks;
		cntinfo.ptr = tmpoffs.offset;
		*(struct count_info *)argp = cntinfo;
		break;
	case SNDCTL_DSP_SETDUPLEX:
		idat = 1;
		retval = ioctl(fd, AUDIO_SETFD, &idat);
		rerr = errno;
		break;
	case SNDCTL_DSP_GETODELAY:
		retval = ioctl(fd, AUDIO_WSEEK, &ldat);
		INTARG = (int)ldat;
		break;
	case SNDCTL_DSP_MAPINBUF:
	case SNDCTL_DSP_MAPOUTBUF:
	case SNDCTL_DSP_SETSYNCRO:
	case SNDCTL_DSP_PROFILE:
		rerr = EINVAL;
		retval = -1; /* XXX unimplemented */
		break;
	default:
		rerr = EINVAL;
		retval = -1;
		break;
	}
	errno = rerr;
	return retval;
}


a406 20
}

/*
 * Check that the blocksize is a power of 2 as OSS wants.
 * If not, set it to be.
 */
static void
setblocksize(int fd, struct audio_info *info)
{
	struct audio_info set;
	int s;

	if (info->blocksize & (info->blocksize-1)) {
		for(s = 32; s < info->blocksize; s <<= 1)
			;
		AUDIO_INITINFO(&set);
		set.blocksize = s;
		ioctl(fd, AUDIO_SETINFO, &set);
		ioctl(fd, AUDIO_GETINFO, info);
	}
@


1.16
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.15 2008/04/04 05:03:19 jakemsr Exp $	*/
d459 1
a459 1
/* If the NetBSD mixer device should have more than NETBSD_MAXDEVS devices
d461 1
a461 1
#define NETBSD_MAXDEVS 64
d467 3
a469 3
	        rdevmap[NETBSD_MAXDEVS];
	char names[NETBSD_MAXDEVS][MAX_AUDIO_DEV_LEN];
	int enum2opaque[NETBSD_MAXDEVS];
d479 1
a479 1
	for (i = 0; i < NETBSD_MAXDEVS; i++) {
d489 1
a489 1
	if (i >= NETBSD_MAXDEVS)
d498 1
a498 1
	if (enm >= NETBSD_MAXDEVS)
d509 1
a509 1
	if (enm >= NETBSD_MAXDEVS)
a543 1
/*		{ AudioNheadphone,	?? },*/
a545 3
/*		{ AudioNmaster,		SOUND_MIXER_SPEAKER },*/
/*		{ AudioNstereo,		?? },*/
/*		{ AudioNmono,		?? },*/
a546 1
/*		{ AudioNwave,		SOUND_MIXER_PCM },*/
a547 1
/*		{ AudioNmixerout,	?? },*/
d572 1
a572 1
	for(i = 0; i < NETBSD_MAXDEVS; i++) {
d577 1
a577 1
	for(i = 0; i < NETBSD_MAXDEVS; i++) {
d598 1
a598 1
	for(i = 0; i < NETBSD_MAXDEVS; i++) {
@


1.15
log
@simplify SNDCTL_DSP_SETTRIGGER

- don't mess with the operational mode.  that was primarily to be able to
set record|play mode for full-duplex, which isn't needed any more.

- don't set pause=1.  this ioctl isn't supposed to be used for stopping
streams.

suggestions, ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.14 2007/11/12 05:43:59 jakemsr Exp $	*/
a15 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.14
log
@
this is the recording source.  rename 'source' to 'recsource' and be
sure to only use 'record.source' instead of possibly 'inputs.source'.
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.12 2007/11/06 04:24:39 jakemsr Exp $	*/
d407 1
a407 3
		tmpinfo.mode = 0;
		if (idat & PCM_ENABLE_OUTPUT) {
			tmpinfo.mode |= (AUMODE_PLAY | AUMODE_PLAY_ALL);
d409 1
a409 4
		} else
			tmpinfo.play.pause = 1;
		if (idat & PCM_ENABLE_INPUT) {
			tmpinfo.mode |= AUMODE_RECORD;
a410 2
		} else
			tmpinfo.record.pause = 1;
@


1.13
log
@
implement SNDCTL_DSP_GETODELAY

bump minor version

ok deanna@@
@
text
@d485 1
a485 1
	u_long caps, source;
d542 1
a542 1
	mixer_devinfo_t mi;
d588 1
a588 1
	di->source = ~0;
d624 7
a630 1
		di->source = i;
d688 1
a688 1
		if (di->source == -1)
d690 1
a690 1
		mc.dev = di->source;
d723 1
a723 1
		if (di->source == -1)
d725 1
a725 1
		mc.dev = di->source;
@


1.12
log
@
- when we need to do both AUDIO_SETINFO and AUDIO_GETINFO to emulate
  a single OSS ioctl, return the return value and errno from from
  AUDIO_SETINFO if there was an error, since it's more informative
  than the return value and errno from AUDIO_GETINFO.  also, don't
  bail if AUDIO_SETINFO fails, because OSS ioctls should return the
  current value of the parameter they are setting, even if there was
  an error.

- avoid a possible (though highly unlikely) divide by zero in
  SNDCTL_DSP_GET[IO]SPACE.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.11 2007/10/08 01:00:13 jakemsr Exp $	*/
d101 1
d451 4
@


1.11
log
@- make SNDCTL_DSP_GETOSPACE much more efficient by using AUDIO_GETPRINO
  instead of AUDIO_GETINFO
- make SNDCTL_DSP_GETISPACE return correct values by using AUDIO_GETRRINFO
  instead of AUDIO_GETINFO
- remove calls to setblocksize() from SNDCTL_DSP_GET[IO]SPACE.  changing
  the blocksize inside play or record loops, where these ioctls are most
  often used, can have serious negative consequences.  the blocksize
  should be "fixed" to a power of 2 before these ioctls are called by
  using SNDCTL_DSP_SETFRAGMENT or SNDCTL_DSP_GETBLKSIZE.

heavily tested by myself.  no negative feedback from anyone else.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.10 2007/09/28 01:15:15 jakemsr Exp $	*/
d103 1
a103 1
	int retval;
d108 1
a108 2
		if (retval < 0)
			return retval;
d112 1
a112 2
		if (retval < 0)
			return retval;
d121 2
a122 1
		(void) ioctl(fd, AUDIO_SETINFO, &tmpinfo);
d125 5
a129 3
		retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval < 0)
			return retval;
d136 7
a142 4
		(void) ioctl(fd, AUDIO_SETINFO, &tmpinfo);
		retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval < 0)
			return retval;
d147 1
a147 2
		if (retval < 0)
			return retval;
d203 9
a211 1
			return EINVAL;
a212 1
		(void) ioctl(fd, AUDIO_SETINFO, &tmpinfo);
d215 1
a215 3
		retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval < 0)
			return retval;
d250 3
d260 2
a261 1
		(void) ioctl(fd, AUDIO_SETINFO, &tmpinfo);
d264 5
a268 3
		retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval < 0)
			return retval;
d273 3
a275 2
		errno = EINVAL;
		return -1; /* XXX unimplemented */
d301 7
a307 4
		(void) ioctl(fd, AUDIO_SETINFO, &tmpinfo);
		retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval < 0)
			return retval;
d366 1
a366 2
		if (retval < 0)
			return retval;
d370 4
a373 1
		bufinfo.fragments = bufinfo.bytes / tmpab.blksize;
d378 1
a378 2
		if (retval < 0)
			return retval;
d382 4
a385 1
		bufinfo.fragments = bufinfo.bytes / tmpab.blksize;
d391 1
a391 2
		if (retval < 0)
			return retval;
d395 1
a395 2
		if (retval < 0)
			return retval;
d418 1
a418 2
		if (retval < 0)
			return retval;
d421 5
a425 3
		retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
		if (retval < 0)
			return retval;
d432 1
a432 2
		if (retval < 0)
			return retval;
d440 1
a440 2
		if (retval < 0)
			return retval;
d449 1
a449 2
		if (retval < 0)
			return retval;
d455 3
a457 2
		errno = EINVAL;
		return -1; /* XXX unimplemented */
d459 3
a461 2
		errno = EINVAL;
		return -1;
d463 2
a464 2

	return 0;
@


1.10
log
@implement SNDCTL_DSP_[G|S]ETTRIGGER

SNDCTL_DSP_SETTRIGGER is used to pause and unpause recording and
playback data transfers.  SNDCTL_DSP_GETTRIGGER returns the paused
states.

this implementation of SNDCTL_DSP_SETTRIGGER also sets the audio(4)
mode (AUMODE_[PLAY|RECORD]), depending on which direction (play, record
or both) is to be triggered.

this can be used allow OSS audio programs to work in full-duplex
mode without changing the audio(4) layer itself.  according to
OSS docs, SNDCTL_DSP_SETTRIGGER is a fairly important ioctl, and
should be used "when even the first read() cannot block."

tested to not break any ports currently using SNDCTL_DSP_SETTRIGGER
which has been a no-op for quite some time.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.9 2006/02/13 12:01:11 espie Exp $	*/
d100 1
d347 1
a347 1
		retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
d350 4
a353 6
		setblocksize(fd, &tmpinfo);
		bufinfo.fragsize = tmpinfo.blocksize;
		bufinfo.fragments = tmpinfo.hiwat -
			(tmpinfo.play.seek + tmpinfo.blocksize - 1)/tmpinfo.blocksize;
		bufinfo.fragstotal = tmpinfo.hiwat;
		bufinfo.bytes = tmpinfo.hiwat * tmpinfo.blocksize - tmpinfo.play.seek;
d357 1
a357 1
		retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
d360 4
a363 6
		setblocksize(fd, &tmpinfo);
		bufinfo.fragsize = tmpinfo.blocksize;
		bufinfo.fragments = tmpinfo.hiwat -
			(tmpinfo.record.seek + tmpinfo.blocksize - 1)/tmpinfo.blocksize;
		bufinfo.fragstotal = tmpinfo.hiwat;
		bufinfo.bytes = tmpinfo.hiwat * tmpinfo.blocksize - tmpinfo.record.seek;
@


1.9
log
@revert change that breaks KDE, until we figure out what's wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.7 2005/01/19 18:35:04 jason Exp $	*/
d379 1
a379 1
		idat = DSP_CAP_TRIGGER; /* pretend we have trigger */
d386 18
a403 1
#if 0
d410 1
a410 21
		retval = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (retval < 0)
			return retval;
		break;
	case SNDCTL_DSP_SETTRIGGER:
		AUDIO_INITINFO(&tmpinfo);
		retval = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (retval < 0)
			return retval;
		tmpinfo.play.pause = (idat & PCM_ENABLE_OUTPUT) == 0;
		tmpinfo.record.pause = (idat & PCM_ENABLE_INPUT) == 0;
		(void) ioctl(fd, AUDIO_SETINFO, &tmpinfo);
		retval = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (retval < 0)
			return retval;
		break;
#else
	case SNDCTL_DSP_GETTRIGGER:
	case SNDCTL_DSP_SETTRIGGER:
		/* XXX Do nothing for now. */
		INTARG = PCM_ENABLE_OUTPUT;
a411 1
#endif
@


1.8
log
@Fix problem in ioctl() handling in OSS audio emulation which caused
unintentional changes of the audio settings e.g. when running "kphone".

Adapted to the userland library from a similar change in the kernel code.

ok jakemsr@@
@
text
@d119 1
a119 1
		(void) ioctl(fd, AUDIO_GETINFO, &tmpinfo);
d131 1
a131 1
		(void) ioctl(fd, AUDIO_GETINFO, &tmpinfo);
d148 1
a148 1
		(void) ioctl(fd, AUDIO_GETINFO, &tmpinfo);
d245 1
a245 1
		(void) ioctl(fd, AUDIO_GETINFO, &tmpinfo);
d269 1
a269 1
		(void) ioctl(fd, AUDIO_GETINFO, &tmpinfo);
d277 1
a277 1
		(void) ioctl(fd, AUDIO_GETINFO, &tmpinfo);
d398 1
a398 1
		(void) ioctl(fd, AUDIO_GETINFO, &tmpinfo);
d796 1
a796 1
		ioctl(fd, AUDIO_GETINFO, &set);
@


1.7
log
@compare st_dev/st_ino before declaring the cached values valid; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.6 2003/05/03 19:01:48 avsm Exp $	*/
d119 1
a119 1
		AUDIO_INITINFO(&tmpinfo);
d131 1
a131 1
		AUDIO_INITINFO(&tmpinfo);
d148 1
a148 1
		AUDIO_INITINFO(&tmpinfo);
d245 1
a245 1
		AUDIO_INITINFO(&tmpinfo);
d269 1
a269 1
		AUDIO_INITINFO(&tmpinfo);
d277 1
a277 1
		AUDIO_INITINFO(&tmpinfo);
d398 1
a398 1
		AUDIO_INITINFO(&tmpinfo);
d796 1
a796 1
		AUDIO_INITINFO(&set);
@


1.6
log
@- make it -Wall clean
- add SNDCTL_DSP_SETDUPLEX emulation (netbsd)
- SNDCTL_DSP_POST is a noop to prevent some apps blocking (netbsd)
- some man pages fixes (from me and netbsd)
- add some more missing #defines for SOUND_MIXER_*  (netbsd)
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.5 2002/04/24 21:59:53 espie Exp $	*/
d461 1
d561 1
a561 1
	if (di->done && di->dev == sb.st_dev)
d566 1
@


1.5
log
@make oss_ioctl varargs.
this is not standard C, but it works on the arches we support,
and osscompat is a dirty hack in the first place.
ok millert@@, tested naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.4 2001/08/18 19:33:30 brad Exp $	*/
a110 1
	case SNDCTL_DSP_POST:
d115 3
d434 6
a442 1
	case SNDCTL_DSP_SETDUPLEX:
d637 1
a637 1
	int idat;
@


1.4
log
@sync up libossaudio with NetBSD changes.
--
- Add __BEGIN_DECLS & __END_DECLS for C++
- Make protection against multiple inclusion non-invasive wrt. name space
- Use EAGAIN instead of EWOULDBLOCK.  The actual numeric value is
same, but EAGAIN is the posixly correct name
- Remove white space
- Change the behaviour to report emulated encodings, too
- Implement SOUND_MIXER_INFO
- Implement OSS_GETVERSION
- Accept mixer values above max (100)
- Handle the info from AUDIO_MIXER_DEVINFO properly, parts of it is opaque
- Use accurate rounding in conversion between OSS and OpenBSD volume values
- Map OSS mixer device "line1" to native mixer device "aux"
--
Some testing by pvalchev@@, no response from other testers in over a month
and a half.
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.3 2001/05/24 04:21:03 aaron Exp $	*/
d46 1
d75 1
a75 1
_oss_ioctl(int fd, unsigned long com, void *argp)
d77 6
@


1.3
log
@Fix fragment handling for SNDCTL_DSP_GETxSPACE ioctls; per NetBSD PR/12796.
The kernel part of this fixes sound emulation for version 1.37c of the Linux
binary of Snes9x (Super Nintendo emulator). The userland equivalent fix should
allow espie to remove his local audio hacks in the squeak port.
@
text
@d1 2
a2 2
/*	$OpenBSD: ossaudio.c,v 1.2 1998/05/25 21:37:46 provos Exp $	*/
/*	$NetBSD: ossaudio.c,v 1.5 1998/03/23 00:39:18 augustss Exp $	*/
d4 1
a4 1
/*
d58 2
a59 2
#define TO_OSSVOL(x) ((x) * 100 / 255)
#define FROM_OSSVOL(x) ((x) * 255 / 100)
d67 3
d87 1
a87 1
	       
d114 1
a114 1
		/* fall into ... */
d193 1
a193 1
		/* fall into ... */
d240 1
a240 1
		/* fall into ... */
d273 1
a273 1
		tmpinfo.hiwat = (idat >> 16) & 0x7fff;
d281 1
a281 1
		for(idat = 0; u>1; idat++, u >>= 1)
d287 2
a288 2
		for(idat = 0, tmpenc.index = 0; 
		    ioctl(fd, AUDIO_GETENC, &tmpenc) == 0; 
a289 2
			if (tmpenc.flags & AUDIO_ENCODINGFLAG_EMULATED)
				continue; /* Don't report emulated modes */
d343 1
a343 1
		    (tmpinfo.play.seek + tmpinfo.blocksize - 1)/tmpinfo.blocksize;
d349 1
a349 1
		retval = ioctl(fd, AUDIO_GETINFO, (caddr_t)&tmpinfo);
d355 1
a355 1
		    (tmpinfo.record.seek + tmpinfo.blocksize - 1)/tmpinfo.blocksize;
d367 1
a367 1
		retval = ioctl(fd, AUDIO_GETPROPS, (caddr_t)&idata);
d379 1
a379 1
		retval = ioctl(fd, AUDIO_GETINFO, (caddr_t)&tmpinfo);
d395 1
a395 1
		(void) ioctl(fd, AUDIO_SETINFO, (caddr_t)&tmpinfo);
d441 1
a441 1
/* If the NetBSD mixer device should have more than 32 devices
d443 1
a443 1
#define NETBSD_MAXDEVS 32
d447 1
a447 1
	int16_t devmap[SOUND_MIXER_NRDEVICES], 
d449 2
d455 46
a500 1
/* 
d510 1
a510 1
	int i;
d519 1
d554 1
a554 1
	di->source = -1;
d558 1
a558 1
	for(i = 0; i < NETBSD_MAXDEVS; i++)
d560 3
d578 2
d582 10
d593 6
a598 6
			if (strcmp(mi.label.name, AudioNsource) == 0) {
				int j;
				di->source = i;
				for(j = 0; j < mi.un.e.num_mem; j++)
					di->recmask |= 1 << di->rdevmap[mi.un.e.member[j].ord];
				di->caps = SOUND_CAP_EXCL_INPUT;
d600 1
d603 6
a608 11
			if (strcmp(mi.label.name, AudioNsource) == 0) {
				int j;
				di->source = i;
				for(j = 0; j < mi.un.s.num_mem; j++) {
					int k, mask = mi.un.s.member[j].mask;
					if (mask) {
						for(k = 0; !(mask & 1); mask >>= 1, k++)
							;
						di->recmask |= 1 << di->rdevmap[k];
					}
				}
d618 1
a618 1
{	       
d620 2
d626 1
a626 1
	int l, r, n;
d633 14
d656 3
a658 1
			idat = 1 << di->rdevmap[mc.un.ord];
a659 2
			int k;
			unsigned int mask;
d664 3
a666 4
			idat = 0;
			for(mask = mc.un.mask, k = 0; mask; mask >>= 1, k++)
				if (mask & 1)
					idat |= 1 << di->rdevmap[k];
d695 1
a695 1
			mc.un.ord = di->devmap[i];
d703 1
a703 1
					mc.un.mask |= 1 << di->devmap[i];
d771 1
a771 1
static void 
a785 1

@


1.2
log
@fix off by one error, reported by nathanw@@MIT.EDU.
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.1.1.1 1998/05/01 09:23:00 provos Exp $	*/
d336 11
d353 4
a356 3
		bufinfo.fragments = /* XXX */
		bufinfo.fragstotal = tmpinfo.play.buffer_size / bufinfo.fragsize;
		bufinfo.bytes = tmpinfo.play.buffer_size;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d278 1
a278 1
		for(idat = 0; u; idat++, u >>= 1)
@


1.1.1.1
log
@libossaudio from NetBSD mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@@
