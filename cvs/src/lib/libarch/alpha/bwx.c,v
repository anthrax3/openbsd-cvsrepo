head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.10
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.4.0.36
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.34
	OPENBSD_5_0:1.4.0.32
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.30
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.28
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.24
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.26
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.22
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.20
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.18
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.16
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.14
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.12
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.10
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.8
date	2014.12.13.16.26.13;	author miod;	state Exp;
branches;
next	1.7;
commitid	9PJRrhNAxBc3PvY9;

1.7
date	2014.04.18.15.09.52;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2012.12.20.21.05.07;	author naddy;	state Exp;
branches;
next	1.5;

1.5
date	2012.12.05.23.19.58;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.06.22.29.45;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.24.17.21.44;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.13.20.00.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.07.14.24.04;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Provide our own copy of {round,trunc}_page() now that uvm's is unreachable from
non-_KERNEL code.
@
text
@/* $OpenBSD: bwx.c,v 1.7 2014/04/18 15:09:52 guenther Exp $ */
/*-
 * Copyright (c) 1998 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mman.h>
#include <sys/fcntl.h>
#include <sys/sysctl.h>
#include <err.h>
#include <paths.h>
#include <machine/bwx.h>
#include <machine/cpu.h>
#include <machine/sysarch.h>
#include <stdlib.h>
#include <unistd.h>

#include "io.h"

#define	round_page(x)	(((x) + PAGE_MASK) & ~PAGE_MASK)
#define	trunc_page(x)	((x) & ~PAGE_MASK)

#define PATH_APERTURE "/dev/xf86"

#define mb()	__asm__ volatile("mb"  : : : "memory")
#define wmb()	__asm__ volatile("wmb" : : : "memory")

static int		mem_fd = -1;	/* file descriptor to /dev/mem */
static void	       *bwx_int1_ports = MAP_FAILED; /* mapped int1 io ports */
static void	       *bwx_int2_ports = MAP_FAILED; /* mapped int2 io ports */
static void	       *bwx_int4_ports = MAP_FAILED; /* mapped int4 io ports */
static u_int64_t	bwx_io_base;	/* physical address of ports */
static u_int64_t	bwx_mem_base;	/* physical address of bwx mem */

static void
bwx_open_mem(void)
{

	if (mem_fd != -1) 
		return;
	mem_fd = open(_PATH_MEM, O_RDWR);
	if (mem_fd < 0) 
		mem_fd = open(PATH_APERTURE, O_RDWR);
	if (mem_fd < 0)
		err(1, "Failed to open both %s and %s", _PATH_MEM, 
		    PATH_APERTURE);
}

static void 
bwx_close_mem(void)
{

	if (mem_fd != -1) {
		close(mem_fd);
		mem_fd = -1;
	}
}

static void
bwx_init(void)
{
	size_t len = sizeof(u_int64_t);
	int error;
	int mib[3];
	
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CHIPSET;
	mib[2] = CPU_CHIPSET_PORTS;
	if ((error = sysctl(mib, 3, &bwx_io_base, &len, NULL, 0)) < 0)
		err(1, "machdep.chipset.ports_base");
	mib[2] = CPU_CHIPSET_MEM;
	if ((error = sysctl(mib, 3, &bwx_mem_base, &len, 0, 0)) < 0)
		err(1, "machdep.chipset.memory");
}

static int
bwx_ioperm(u_int32_t from, u_int32_t num, int on)
{
	u_int32_t start, end;

	if (bwx_int1_ports == MAP_FAILED)
		bwx_init();

	if (!on)
		return -1;		/* XXX can't unmap yet */

	if (bwx_int1_ports != MAP_FAILED)
		return 0;
	
	bwx_open_mem();
	start = trunc_page(from);
	end = round_page(from + num);
	if ((bwx_int1_ports = mmap(0, end-start, PROT_READ|PROT_WRITE,
	    MAP_SHARED, mem_fd, bwx_io_base + BWX_EV56_INT1 + start)) ==
	    MAP_FAILED) 
		err(1, "mmap int1");
	if ((bwx_int2_ports = mmap(0, end-start, PROT_READ|PROT_WRITE,
	    MAP_SHARED, mem_fd, bwx_io_base + BWX_EV56_INT2 + start)) ==
	    MAP_FAILED)
		err(1, "mmap int2");
	if ((bwx_int4_ports = mmap(0, end-start, PROT_READ|PROT_WRITE,
	    MAP_SHARED, mem_fd, bwx_io_base + BWX_EV56_INT4 + start)) ==
	    MAP_FAILED) 
		err(1, "mmap int4");
	bwx_close_mem();
	return 0;
}

static u_int8_t
bwx_inb(u_int32_t port)
{
	mb();
	return alpha_ldbu(bwx_int1_ports + port);
}

static u_int16_t
bwx_inw(u_int32_t port)
{
	mb();
	return alpha_ldwu(bwx_int2_ports + port);
}

static u_int32_t
bwx_inl(u_int32_t port)
{
	mb();
	return alpha_ldlu(bwx_int4_ports + port);
}

static void
bwx_outb(u_int32_t port, u_int8_t val)
{
	alpha_stb(bwx_int1_ports + port, val);
	mb();
	wmb();
}

static void
bwx_outw(u_int32_t port, u_int16_t val)
{
	alpha_stw(bwx_int2_ports + port, val);
	mb();
	wmb();
}

static void
bwx_outl(u_int32_t port, u_int32_t val)
{
	alpha_stl(bwx_int4_ports + port, val);
	mb();
	wmb();
}

struct bwx_mem_handle {
	void	*virt1;		/* int1 address in user address-space */
	void	*virt2;		/* int2 address in user address-space */
	void	*virt4;		/* int4 address in user address-space */
};

static void *
bwx_map_memory(u_int32_t address, u_int32_t size)
{
	struct bwx_mem_handle *h;
	size_t sz = (size_t)size << 5;

	h = malloc(sizeof(struct bwx_mem_handle));
	if (h == NULL) return NULL;
	bwx_open_mem();
	h->virt1 = mmap(0, sz, PROT_READ|PROT_WRITE, MAP_SHARED,
	    mem_fd, bwx_mem_base + BWX_EV56_INT1 + address);
	if (h->virt1 == MAP_FAILED) {
		bwx_close_mem();
		free(h);
		return NULL;
	}
	h->virt2 = mmap(0, sz, PROT_READ|PROT_WRITE, MAP_SHARED,
	    mem_fd, bwx_mem_base + BWX_EV56_INT2 + address);
	if (h->virt2 == MAP_FAILED) {
		munmap(h->virt1, sz);
		bwx_close_mem();
		free(h);
		return NULL;
	}
	h->virt4 = mmap(0, sz, PROT_READ|PROT_WRITE, MAP_SHARED,
	    mem_fd, bwx_mem_base + BWX_EV56_INT4 + address);
	if (h->virt4 == MAP_FAILED) {
		munmap(h->virt1, sz);
		munmap(h->virt2, sz);
		bwx_close_mem();
		free(h);
		return NULL;
	}
	bwx_close_mem();
	return h;
}

static void
bwx_unmap_memory(void *handle, u_int32_t size)
{
	struct bwx_mem_handle *h = handle;
	size_t sz = (size_t)size << 5;

	munmap(h->virt1, sz);
	munmap(h->virt2, sz);
	munmap(h->virt4, sz);
	free(h);
}

static u_int8_t
bwx_readb(void *handle, u_int32_t offset)
{
	struct bwx_mem_handle *h = handle;

	return alpha_ldbu(h->virt1 + offset);
}

static u_int16_t
bwx_readw(void *handle, u_int32_t offset)
{
	struct bwx_mem_handle *h = handle;

	return alpha_ldwu(h->virt2 + offset);
}

static u_int32_t
bwx_readl(void *handle, u_int32_t offset)
{
	struct bwx_mem_handle *h = handle;

	return alpha_ldlu(h->virt4 + offset);
}

static void
bwx_writeb(void *handle, u_int32_t offset, u_int8_t val)
{
	struct bwx_mem_handle *h = handle;

	alpha_stb(h->virt1 + offset, val);
}

static void
bwx_writew(void *handle, u_int32_t offset, u_int16_t val)
{
	struct bwx_mem_handle *h = handle;

	alpha_stw(h->virt2 + offset, val);
}

static void
bwx_writel(void *handle, u_int32_t offset, u_int32_t val)
{
	struct bwx_mem_handle *h = handle;

	alpha_stl(h->virt4 + offset, val);
}

struct io_ops bwx_io_ops = {
	bwx_ioperm,
	bwx_inb,
	bwx_inw,
	bwx_inl,
	bwx_outb,
	bwx_outw,
	bwx_outl,
	bwx_map_memory,
	bwx_unmap_memory,
	bwx_readb,
	bwx_readw,
	bwx_readl,
	bwx_writeb,
	bwx_writew,
	bwx_writel,
};
@


1.7
log
@It's been a quarter century: we can assume volatile is present with that name.
@
text
@d1 1
a1 1
/* $OpenBSD: bwx.c,v 1.6 2012/12/20 21:05:07 naddy Exp $ */
a27 1
#define vm_page_size (sysconf(_SC_PAGESIZE)) /* XXX  */
d41 3
@


1.6
log
@include machine/cpu.h now that is isn't any longer pulled in indirectly
by sys/sysctl.h; ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: bwx.c,v 1.5 2012/12/05 23:19:58 deraadt Exp $ */
d45 2
a46 2
#define mb()	__asm__ __volatile__("mb"  : : : "memory")
#define wmb()	__asm__ __volatile__("wmb" : : : "memory")
@


1.5
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: bwx.c,v 1.4 2003/10/06 22:29:45 miod Exp $ */
d36 1
@


1.4
log
@munmap() the correct size; adapted from PR #3462

ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: bwx.c,v 1.3 2002/08/24 17:21:44 matthieu Exp $ */
a26 2

#include <sys/cdefs.h>
@


1.3
log
@aperture driver for alpha. It works here the same as on i386
to allow access to VGA card's memory by mmapping /dev/xf86.
The macdep.allowaperture does also control /dev/pci access.
Ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bwx.c,v 1.2 2002/07/13 20:00:47 deraadt Exp $ */
d185 1
d190 1
a190 1
	h->virt1 = mmap(0, size << 5, PROT_READ|PROT_WRITE, MAP_SHARED,
d197 1
a197 1
	h->virt2 = mmap(0, size << 5, PROT_READ|PROT_WRITE, MAP_SHARED,
d200 1
a200 1
		munmap(h->virt1, size);
d205 1
a205 1
	h->virt4 = mmap(0, size << 5, PROT_READ|PROT_WRITE, MAP_SHARED,
d208 2
a209 2
		munmap(h->virt1, size);
		munmap(h->virt2, size);
d222 1
d224 3
a226 3
	munmap(h->virt1, size);
	munmap(h->virt2, size);
	munmap(h->virt4, size);
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: bwx.c,v 1.1 2002/07/07 14:24:04 matthieu Exp $ */
d44 2
d49 4
a52 4
static int		mem_fd;		/* file descriptor to /dev/mem */
static void	       *bwx_int1_ports;	/* mapped int1 io ports */
static void	       *bwx_int2_ports;	/* mapped int2 io ports */
static void	       *bwx_int4_ports;	/* mapped int4 io ports */
d57 24
a86 4
	mem_fd = open(_PATH_MEM, O_RDWR);
	if (mem_fd < 0)
		err(1, _PATH_MEM);
	
d102 1
a102 1
	if (!bwx_int1_ports)
d107 3
d111 1
d126 1
d187 2
a188 1
	if (!h) return 0;
d191 2
a192 1
	if ((long) h->virt1 == -1) {
d194 1
a194 1
		return 0;
d198 1
a198 1
	if ((long) h->virt2 == -1) {
d200 1
d202 1
a202 1
		return 0;
d206 1
a206 1
	if ((long) h->virt4 == -1) {
d209 1
d211 1
a211 1
		return 0;
d213 1
@


1.1
log
@Add a port of FreeBSD/alpha's libio as libalpha. This library enable
access to devices I/O ports from userland. Only BWX machines supported
for now. Added a man page.
Ok deraadt@@, miod@@.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d88 3
a90 4
	if ((bwx_int1_ports = mmap(0, end-start, 
				   PROT_READ|PROT_WRITE, MAP_SHARED, mem_fd, 
				   bwx_io_base + BWX_EV56_INT1 + start))
	     == MAP_FAILED) 
d92 3
a94 4
	if ((bwx_int2_ports = mmap(0, end-start, 
				   PROT_READ|PROT_WRITE, MAP_SHARED, mem_fd, 
				   bwx_io_base + BWX_EV56_INT2 + start))
	    == MAP_FAILED)
d96 3
a98 4
	if ((bwx_int4_ports = mmap(0, end-start, 
				   PROT_READ|PROT_WRITE, MAP_SHARED, mem_fd, 
				   bwx_io_base + BWX_EV56_INT4 + start))
	    == MAP_FAILED) 
d162 1
a162 1
			mem_fd, bwx_mem_base + BWX_EV56_INT1 + address);
d168 1
a168 1
			mem_fd, bwx_mem_base + BWX_EV56_INT2 + address);
d175 1
a175 1
			mem_fd, bwx_mem_base + BWX_EV56_INT4 + address);
@

