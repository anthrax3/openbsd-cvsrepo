head	1.48;
access;
symbols
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.46.0.12
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.4
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.46.0.8
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.6
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.6
	OPENBSD_5_0:1.43.0.4
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.40.0.6
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.40.0.4
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.38.0.8
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.6
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.4
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.37.0.6
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.4
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.35.0.4
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.27.0.6
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.27.0.4
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.22.0.2
	OPENBSD_2_7_BASE:1.22
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@.\" @;


1.48
date	2015.11.10.23.48.18;	author jmc;	state Exp;
branches;
next	1.47;
commitid	QU70QaxjyBAtj4Rv;

1.47
date	2015.09.14.13.08.01;	author schwarze;	state Exp;
branches;
next	1.46;
commitid	YV9Btzibn39kPFq6;

1.46
date	2013.06.05.03.39.23;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2012.09.27.11.31.58;	author jmc;	state Exp;
branches;
next	1.44;

1.44
date	2012.03.04.17.42.32;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2010.10.29.12.43.09;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2010.09.07.19.52.37;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.03.19.54.44;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.02.14.11.39;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.31.19.19.30;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.02.15.18.27;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.01.07.44.04;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.28.06.28.23;	author jmc;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.31.03.27.23;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.29.13.42.40;	author jmc;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.30.22.12.43;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.07.08.52.43;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.17.09.52.21;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.18.07.47.00;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.14.23.24.12;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.16.19.12.31;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.06.10.42.26;	author mpech;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.21.21.11.31;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.09.23.00.52;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.02.15.58.09;	author provos;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.25.16.45.25;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.18.03.01.34;	author aaron;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.15.02.15.23;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	99.06.16.08.45.11;	author alex;	state Exp;
branches;
next	1.18;

1.18
date	99.05.25.13.06.45;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	99.05.24.12.15.33;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	99.05.20.15.22.52;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	99.05.15.02.18.00;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	99.02.04.01.08.31;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.12.30.22.18.46;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.12.21.08.21.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.08.29.18.57.18;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.03.11.18.55.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.02.25.12.23.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.02.25.12.21.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.02.25.11.46.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.02.24.12.58.09;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.19.08.31.44;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.08.13.06.36.59;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.20.06.12.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.05.16.36.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@update NAME section to include all documented functions,
or otherwise change Dt to reflect the name of an existing function;

feedback/ok schwarze
@
text
@.\"	$OpenBSD: rpc.3,v 1.47 2015/09/14 13:08:01 schwarze Exp $
.\"
.\" Copyright (c) 1998 Theo de Raadt
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.\" Copyright (c) 2010, Oracle America, Inc.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions are
.\" met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"     * Redistributions in binary form must reproduce the above
.\"       copyright notice, this list of conditions and the following
.\"       disclaimer in the documentation and/or other materials
.\"       provided with the distribution.
.\"     * Neither the name of the "Oracle America, Inc." nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\"   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\"   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\"   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
.\"   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
.\"   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
.\"   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\"   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
.\"   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\"   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
.\"   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
.\"   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\"   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: September 14 2015 $
.Dt CALLRPC 3
.Os
.Sh NAME
.Nm callrpc ,
.Nm clnt_broadcast ,
.Nm clnt_call ,
.Nm clnt_control ,
.Nm clnt_create ,
.Nm clnt_destroy ,
.Nm clnt_freeres ,
.Nm clnt_pcreateerror ,
.Nm clnt_perrno ,
.Nm clnt_perror ,
.Nm clnt_spcreateerror ,
.Nm clnt_sperrno ,
.Nm clnt_sperror ,
.Nm clntraw_create ,
.Nm clnttcp_create ,
.Nm clntudp_bufcreate ,
.Nm clntudp_create ,
.Nm clnt_geterr ,
.Nm get_myaddress ,
.Nm pmap_getmaps ,
.Nm pmap_getport ,
.Nm pmap_rmtcall ,
.Nm pmap_set ,
.Nm pmap_unset ,
.Nm registerrpc ,
.Nm rpc_createerr ,
.Nm svc_destroy ,
.Nm svc_fds ,
.Nm svc_fdset ,
.Nm svc_freeargs ,
.Nm svc_getargs ,
.Nm svc_getcaller ,
.Nm svc_getreq ,
.Nm svc_getreq_common ,
.Nm svc_getreq_poll ,
.Nm svc_getreqset ,
.Nm svc_getreqset2 ,
.Nm svc_register ,
.Nm svc_max_pollfd ,
.Nm svc_pollfd ,
.Nm svc_run ,
.Nm svc_sendreply ,
.Nm svc_unregister ,
.Nm svcerr_auth ,
.Nm svcerr_decode ,
.Nm svcerr_noproc ,
.Nm svcerr_noprog ,
.Nm svcerr_progvers ,
.Nm svcerr_systemerr ,
.Nm svcerr_weakauth ,
.Nm svcfd_create ,
.Nm svcraw_create ,
.Nm svctcp_create ,
.Nm svcudp_create ,
.Nm svcudp_bufcreate ,
.Nm xdr_accepted_reply ,
.Nm xdr_authunix_parms ,
.Nm xdr_callhdr ,
.Nm xdr_callmsg ,
.Nm xdr_opaque_auth ,
.Nm xdr_pmap ,
.Nm xdr_pmaplist ,
.Nm xdr_rejected_reply ,
.Nm xdr_replymsg ,
.Nm xprt_register ,
.Nm xprt_unregister
.Nd library routines for remote procedure calls
.Sh SYNOPSIS
.In rpc/rpc.h
.Ft int
.Fn callrpc "char *host" "u_long prognum" "u_long versnum" "u_long procnum" "xdrproc_t inproc" "char *in" "xdrproc_t outproc" "char *out"
.Ft "enum clnt_stat"
.Fn clnt_broadcast "u_long prognum" "u_long versnum" "u_long procnum" "xdrproc_t inproc" "char *in" "xdrproc_t outproc" "char *out" "resultproc_t eachresult"
.Ft "enum clnt_stat"
.Fn clnt_call "CLIENT *clnt" "u_long procnum" "xdrproc_t inproc" "char *in" "xdrproc_t outproc" "char *out" "struct timeval tout"
.Ft int
.Fn clnt_destroy "CLIENT *clnt"
.Ft CLIENT *
.Fn clnt_create "char *host" "u_long prog" "u_long vers" "char *proto"
.Ft bool_t
.Fn clnt_control "CLIENT *cl" "int req" "char *info"
.Ft int
.Fn clnt_freeres "CLIENT *clnt" "xdrproc_t outproc" "char *out"
.Ft void
.Fn clnt_geterr "CLIENT *clnt" "struct rpc_err *errp"
.Ft void
.Fn clnt_pcreateerror "char *s"
.Ft void
.Fn clnt_perrno "enum clnt_stat stat"
.Ft int
.Fn clnt_perror "CLIENT *clnt" "char *s"
.Ft char *
.Fn clnt_spcreateerror "char *s"
.Ft char *
.Fn clnt_sperrno "enum clnt_stat stat"
.Ft char *
.Fn clnt_sperror "CLIENT *rpch" "char *s"
.Ft CLIENT *
.Fn clntraw_create "u_long prognum" "u_long versnum"
.Ft CLIENT *
.Fn clnttcp_create "struct sockaddr_in *addr" "u_long prognum" "u_long versnum" "int *sockp" "u_int sendsz" "u_int recvsz"
.Ft CLIENT *
.Fn clntudp_create "struct sockaddr_in *addr" "u_long prognum" "u_long versnum" "struct timeval wait" "int *sockp"
.Ft CLIENT *
.Fn clntudp_bufcreate "struct sockaddr_in *addr" "u_long prognum" "u_long versnum" "struct timeval wait" "int *sockp" "unsigned int sendsize" "unsigned int recosize"
.Ft int
.Fn get_myaddress "struct sockaddr_in *addr"
.Ft struct pmaplist *
.Fn pmap_getmaps "struct sockaddr_in *addr"
.Ft u_short
.Fn pmap_getport "struct sockaddr_in *addr" "u_long prognum" "u_long versnum" "u_long protocol"
.Ft "enum clnt_stat"
.Fn pmap_rmtcall "struct sockaddr_in *" "u_long prog" "u_long vers" "u_long proc" "xdrproc_t inp" "char *in" "xdrproc_t outp" "char *out" "struct timeval tv" "u_long *portp"
.Ft int
.Fn pmap_set "u_long prognum" "u_long versnum" "u_int protocol" "int port"
.Ft int
.Fn pmap_unset "u_long prognum" "u_long versnum"
.Ft int
.Fn registerrpc "u_long prognum" "u_long versnum" "u_long procnum" "char *(*procname)() " "xdrproc_t inproc" "xdrproc_t outproc"
.Vt struct rpc_createerr rpc_createerr ;
.Ft int
.Fn svc_destroy "SVCXPRT *xprt"
.Vt struct pollfd *svc_pollfd ;
.Vt int svc_max_pollfd ;
.Vt fd_set svc_fdset ;
.Vt fd_set *__svc_fdset ;
.Vt int __svc_fdsetsize ;
.Vt int svc_fds ;
.Ft int
.Fn svc_freeargs "SVCXPRT *xprt" "xdrproc_t inproc" "char *in"
.Ft int
.Fn svc_getargs "SVCXPRT *xprt" "xdrproc_t inproc" "char *in"
.Ft struct sockaddr_in *
.Fn svc_getcaller "SVCXPRT *xprt"
.Ft int
.Fn svc_getreq_common "int fd"
.Ft int
.Fn svc_getreq_poll "struct pollfd *pfds" "const int pollretval"
.Ft int
.Fn svc_getreqset "fd_set *rdfds"
.Ft int
.Fn svc_getreqset2 "fd_set *rdfds" "int width"
.Ft int
.Fn svc_getreq "int rdfds"
.Ft int
.Fn svc_register "SVCXPRT *xprt" "u_long prognum" "u_long versnum" "void (*dispatch)()" "u_long protocol"
.Ft int
.Fn svc_run "void"
.Ft int
.Fn svc_sendreply "SVCXPRT *xprt" "xdrproc_t outproc" "char *out"
.Ft void
.Fn svc_unregister "u_long prognum" "u_long versnum"
.Ft void
.Fn svcerr_auth "SVCXPRT *xprt" "enum auth_stat why"
.Ft void
.Fn svcerr_decode "SVCXPRT *xprt"
.Ft void
.Fn svcerr_noproc "SVCXPRT *xprt"
.Ft void
.Fn svcerr_noprog "SVCXPRT *xprt"
.Ft void
.Fn svcerr_progvers "SVCXPRT *xprt"
.Ft void
.Fn svcerr_systemerr "SVCXPRT *xprt"
.Ft void
.Fn svcerr_weakauth "SVCXPRT *xprt"
.Ft SVCXPRT *
.Fn svcraw_create "void"
.Ft SVCXPRT *
.Fn svctcp_create "int sock" "u_int send_buf_size" "u_int recv_buf_size"
.Ft SVCXPRT *
.Fn svcfd_create "int fd" "u_int sendsize" "u_int recvsize"
.Ft SVCXPRT *
.Fn svcudp_create "int sock"
.Ft SVCXPRT *
.Fn svcudp_bufcreate "int sock" "u_int sendsz" "u_int recvsz"
.Ft bool_t
.Fn xdr_accepted_reply "XDR *xdrs" "struct accepted_reply *ar"
.Ft bool_t
.Fn xdr_authunix_parms "XDR *xdrs" "struct authunix_parms *aupp"
.Ft void
.Fn xdr_callhdr "XDR *xdrs" "struct rpc_msg *chdr"
.Ft int
.Fn xdr_callmsg "XDR *xdrs" "struct rpc_msg *cmsg"
.Ft int
.Fn xdr_opaque_auth "XDR *xdrs" "struct opaque_auth *ap"
.Ft int
.Fn xdr_pmap "XDR *xdrs" "struct pmap *regs"
.Ft int
.Fn xdr_pmaplist "XDR *xdrs" "struct pmaplist **rp"
.Ft int
.Fn xdr_rejected_reply "XDR *xdrs" "struct rejected_reply *rr"
.Ft int
.Fn xdr_replymsg "XDR *xdrs" "struct rpc_msg *rmsg"
.Ft void
.Fn xprt_register "SVCXPRT *xprt"
.Ft void
.Fn xprt_unregister "SVCXPRT *xprt"
.Sh DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.Pp
.\"Routines that are used for Secure RPC (DES authentication) are described in
.\".Xr rpc_secure 3 .
.\"Secure RPC can be used only if DES encryption is available.
.Fn callrpc
calls the remote procedure associated with
.Fa prognum ,
.Fa versnum ,
and
.Fa procnum
on the machine,
.Fa host .
The parameter
.Fa in
is the address of the procedure's argument(s), and
.Fa out
is the address of where to place the result(s);
.Fa inproc
is used to encode the procedure's parameters, and
.Fa outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.Fa enum clnt_stat
cast to an integer if it fails.
The routine
.Fn clnt_perrno
is handy for translating failure statuses into messages.
.Pp
.Sy Warning:
calling remote procedures with this routine uses UDP/IP
as a transport; see
.Fn clntudp_create
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.Pp
.Fn clnt_broadcast
is like
.Fn callrpc ,
except the call message is broadcast to all locally
connected broadcast nets.
Each time it receives a response, this routine calls
.Fa eachresult ,
whose form is:
.Bd -literal -offset indent
.Ft int
.Fn eachresult "char *out" "struct sockaddr_in *addr"
.Ed
.Pp
where
.Fa out
is the same as
.Fa out
passed to
.Fn clnt_broadcast ,
except that the remote procedure's output is decoded there;
.Fa addr
points to the address of the machine that sent the results.
If
.Fa eachresult
returns zero,
.Fn clnt_broadcast
waits for more replies; otherwise it returns with appropriate
status.
.Pp
.Sy Warning:
broadcast sockets are limited in size to the
maximum transfer unit of the data link.
For Ethernet, this value is 1500 bytes.
.Pp
.Fn clnt_call
is a macro that calls the remote procedure
.Fa procnum
associated with the client handle,
.Fa clnt ,
which is obtained with an RPC client creation routine such as
.Fn clnt_create .
The parameter
.Fa in
is the address of the procedure's argument(s), and
.Fa out
is the address of where to place the result(s);
.Fa inproc
is used to encode the procedure's parameters, and
.Fa outproc
is used to decode the procedure's results;
.Fa tout
is the time allowed for results to come back.
.Pp
.Fn clnt_destroy
is a macro that destroys the client's RPC handle.
Destruction usually involves deallocation of private data structures, including
.Fa clnt
itself.
Use of
.Fa clnt
is undefined after calling
.Fn clnt_destroy .
If the RPC library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.Pp
.Fn clnt_create
is a generic client creation routine.
.Fa host
identifies the name of the remote host where the server
is located.
.Fa proto
indicates which kind of transport protocol to use.
The currently supported values for this field are
.Qq udp
and
.Qq tcp .
Default timeouts are set, but can be modified using
.Fn clnt_control .
This routine returns
.Dv NULL
if it fails.
.Pp
.Sy Warning:
Using UDP has its shortcomings.
Since UDP-based RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.Pp
.Fn clnt_control
is a macro used to change or retrieve various information
about a client object.
.Fa req
indicates the type of operation, and
.Fa info
is a pointer to the information.
For both UDP and TCP,
the supported values of
.Fa req
and their argument types and what they do are:
.Bd -literal -offset indent
CLSET_TIMEOUT	struct timeval	set total timeout
CLGET_TIMEOUT	struct timeval	get total timeout
.Ed
.Pp
.Sy Note:
if you set the timeout using
.Fn clnt_control ,
the timeout parameter passed to
.Fn clnt_call
will be ignored in all future calls.
.Bd -literal -offset indent
CLGET_SERVER_ADDR	struct sockaddr_in 	get server's address
.Ed
.Pp
The following operations are valid for UDP only:
.Bd -literal -offset indent
CLSET_RETRY_TIMEOUT   struct timeval	set the retry timeout
CLGET_RETRY_TIMEOUT   struct timeval	get the retry timeout
.Ed
.Pp
The retry timeout is the time that UDP RPC
waits for the server to reply before
retransmitting the request.
.Pp
.Fn clnt_freeres
is a macro that frees any data allocated by the RPC/XDR
system when it decoded the results of an RPC call.
The parameter
.Fa out
is the address of the results, and
.Fa outproc
is the XDR routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.Pp
.Fn clnt_geterr
is a macro that copies the error structure out of the client
handle
to the structure at address
.Fa errp .
.Pp
.Fn clnt_pcreateerror
prints a message to standard error indicating
why a client RPC handle could not be created.
The message is prepended with string
.Fa s
and a colon.
Used when a
.Fn clnt_create ,
.Fn clntraw_create ,
.Fn clnttcp_create ,
or
.Fn clntudp_create
call fails.
.Pp
.Fn clnt_perrno
prints a message to standard error corresponding
to the condition indicated by
.Fa stat .
Used after
.Fn callrpc .
.Pp
.Fn clnt_perror
prints a message to standard error indicating why an RPC call failed;
.Fa clnt
is the handle used to do the call.
The message is prepended with string
.Fa s
and a colon.
Used after
.Fn clnt_call .
.Pp
.Fn clnt_spcreateerror
is like
.Fn clnt_pcreateerror ,
except that it returns a string
instead of printing to the standard error.
.Pp
.Sy Bugs:
returns pointer to static data that is overwritten
on each call.
.Pp
.Fn clnt_sperrno
takes the same arguments as
.Fn clnt_perrno ,
but instead of sending a message to the standard error
indicating why an RPC
call failed, returns a pointer to a string which contains
the message.
Unlike
.Fn clnt_perror ,
it does not append a newline character
to the end of the message.
.Pp
.Fn clnt_sperrno
is used instead of
.Fn clnt_perrno
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.Fn printf ,
or if a message format different than that supported by
.Fn clnt_perrno
is to be used.
.Pp
.Sy Note:
unlike
.Fn clnt_sperror
and
.Fn clnt_spcreaterror ,
.Fn clnt_sperrno
returns a pointer to static data, but the
result will not get overwritten on each call.
.Pp
.Fn clnt_sperror
is like
.Fn clnt_perror ,
except that (like
.Fn clnt_sperrno )
it returns a string instead of printing to standard error.
.Pp
.Sy Bugs:
returns pointer to static data that is overwritten
on each call.
.Pp
.Fn clntraw_create
is a routine which creates a toy RPC client for the remote program
.Fa prognum ,
version
.Fa versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding RPC server should live in the same address space; see
.Fn svcraw_create .
This allows simulation of RPC and acquisition of RPC
overheads, such as round trip times, without any
kernel interference.
This routine returns
.Dv NULL
if it fails.
.Pp
.Fn clnttcp_create
is a routine which creates an RPC client for the remote program
.Fa prognum ,
version
.Fa versnum ;
the client uses TCP/IP as a transport.
The remote program is located at Internet address
.Fa *addr .
If
.Fa addr-\*(Gtsin_port
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.Xr portmap 8
service is consulted for this information).
The parameter
.Fa sockp
is a socket; if it is
.Fa RPC_ANYSOCK ,
then this routine opens a new one and sets
.Fa sockp .
Since TCP-based RPC uses buffered I/O,
the user may specify the size of the send and receive buffers
with the parameters
.Fa sendsz
and
.Fa recvsz ;
values of zero choose suitable defaults.
This routine returns
.Dv NULL
if it fails.
.Pp
.Fn clntudp_create
is a routine which creates an RPC client for the remote program
.Fa prognum ,
on
.Fa versnum ;
the client uses use UDP/IP as a transport.
The remote program is located at Internet address
.Fa addr .
If
.Fa addr-\*(Gtsin_port
is zero, then it is set to actual port that the remote
program is listening on (the remote
.Xr portmap 8
service is consulted for this information).
The parameter
.Fa sockp
is a socket; if it is
.Fa RPC_ANYSOCK ,
then this routine opens a new one and sets
.Fa sockp .
The UDP transport resends the call message in intervals of
.Fa wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.Fn clnt_call .
This routine returns
.Dv NULL
if it fails.
.Pp
.Fn clntudp_bufcreate
is like
.Fn clntudp_create ,
except that it allows the user to specify the maximum packet size for sending
and receiving UDP-based RPC
messages instead of using the default size limit of 8800 bytes.
.Pp
.Fn get_myaddress
stuffs the machine's IP address into
.Fa *addr ,
without consulting the library routines that deal with
.Pa /etc/hosts .
The port number is always set to
.Fa htons(PMAPPORT) .
Returns zero on success, non-zero on failure.
.Pp
.Fn pmap_getmaps
is a function interface to the
.Xr portmap 8
service, which returns a list of the current RPC program-to-port mappings
on the host located at IP address
.Fa *addr .
This routine can return
.Dv NULL .
The command
.Qq Li rpcinfo \-p
uses this routine.
.Pp
.Fn pmap_getport
is a user interface to the
.Xr portmap 8
service, which returns the port number
on which waits a service that supports program number
.Fa prognum ,
version
.Fa versnum ,
and speaks the transport protocol associated with
.Fa protocol .
The value of
.Fa protocol
is most likely
.Dv IPPROTO_UDP
or
.Dv IPPROTO_TCP .
A return value of zero means that the mapping does not exist
or that
the RPC system failured to contact the remote
.Xr portmap 8
service.
In the latter case, the global variable
.Va rpc_createerr
contains the RPC status.
.Pp
.Fn pmap_rmtcall
is a user interface to the
.Xr portmap 8
service, which instructs
.Xr portmap 8
on the host at IP address
.Fa *addr
to make an RPC call on your behalf to a procedure on that host.
The parameter
.Fa *portp
will be modified to the program's port number if the
procedure
succeeds.
The definitions of other parameters are discussed in
.Fn callrpc
and
.Fn clnt_call .
This procedure should be used for a
.Qq ping
and nothing else.
See also
.Fn clnt_broadcast .
.Pp
.Fn pmap_set
is a user interface to the
.Xr portmap 8
service, which establishes a mapping between the triple
.Fa [ prognum , versnum , protocol ]
and
.Fa port
on the machine's
.Xr portmap 8
service.
The value of
.Fa protocol
is most likely
.Dv IPPROTO_UDP
or
.Dv IPPROTO_TCP .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.Fn svc_register .
.Pp
.Fn pmap_unset
is a user interface to the
.Xr portmap 8
service, which destroys all mapping between the triple
.Fa [ prognum , versnum , * ]
and
.Fa ports
on the machine's
.Xr portmap 8
service.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn registerrpc
will register a procedure
.Fa procname
with the RPC service package.
If a request arrives for program
.Fa prognum ,
version
.Fa versnum ,
and procedure
.Fa procnum ,
.Fa procname
is called with a pointer to its parameter(s);
.Fa procname
should return a pointer to its static result(s);
.Fa inproc
is used to decode the parameters while
.Fa outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.Pp
.Sy Warning:
remote procedures registered in this form
are accessed using the UDP/IP transport; see
.Fn svcudp_create
for restrictions.
.Pp
.Va rpc_createerr
is a global variable whose value is set by any RPC client creation routine
that does not succeed.
Use the routine
.Fn clnt_pcreateerror
to print the reason why.
.Pp
.Fn svc_destroy
is a macro that destroys the RPC service transport handle,
.Fa xprt .
Destruction usually involves deallocation
of private data structures, including
.Fa xprt
itself.
Use of
.Fa xprt
is undefined after calling this routine.
.Pp
.Va svc_pollfd
is a global variable reflecting the RPC service side's
read file descriptor array.
This variable is only of interest if service implementors do not call
.Fn svc_run ,
but rather do their own asynchronous event processing.
This variable is read-only, and it may change after calls to
.Fn svc_getreq_poll
or any creation routines.
Do not pass it directly to
.Xr poll 2 !
Instead, make a copy and pass that instead.
.Pp
.Va svc_max_pollfd
is a global variable containing the maximum length of the
.Va svc_pollfd
array.
.Va svc_max_pollfd
is not a hard limit; it will grow automatically as needed.
This variable is read-only, and it may change after calls to
.Fn svc_getreq_poll
or any creation routines.
The purpose of
.Va svc_max_pollfd
is to allow a service implementor to make a copy of
.Va svc_pollfd
that may in turn be passed to
.Xr poll 2 .
.Pp
.Va __svc_fdset
and
.Va __svc_fdsetsize
are global variables reflecting the RPC service side's
read file descriptor bit mask.
.Va __svc_fdsetsize
is a count of the number of checkable bits in
.Va __svc_fdset ,
and can expand to the full size that
.Xr select 2
supports, hence exceeding
.Fa FD_SETSIZE
if required.
These variables are only of interest
if service implementors do not call
.Fn svc_run ,
but rather do their own asynchronous event processing.
This variable is read-only, and it may change after calls to
.Fn svc_getreqset
or any creation routines.
Do not pass its address to
.Xr select 2 !
Instead, pass the address of a copy.
These variables are considered obsolete; new programs should use
.Va svc_pollfd
and
.Va svc_max_pollfd
instead.
.Pp
.Va svc_fdset
is similar to
.Va __svc_fdset
but limited to
.Fa FD_SETSIZE
descriptors.
This is only of interest
if service implementors do not call
.Fn svc_run ,
but rather do their own asynchronous event processing.
This variable is read-only, and it may change after calls to
.Fn svc_getreqset
or any creation routines.
Do not pass it directly to
.Xr select 2 !
Instead, make a copy and pass that instead.
.Pp
Additionally, note that if the process has descriptor limits
which are extended beyond
.Fa FD_SETSIZE ,
this variable will only be usable for the first
.Fa FD_SETSIZE
descriptors.
This variable is considered obsolete; new programs should use
.Va svc_pollfd
which does not have this limit.
.Pp
.Va svc_fds
is similar to
.Va svc_fdset ,
but limited to 32 descriptors.
This interface is obsoleted by
.Va svc_fdset
and is included for source compatibility only.
.Pp
.Fn svc_freeargs
is a macro that frees any data allocated by the RPC/XDR
system when it decoded the arguments to a service procedure
using
.Fn svc_getargs .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.Pp
.Fn svc_getargs
is a macro that decodes the arguments of an RPC request
associated with the RPC service transport handle,
.Fa xprt .
The parameter
.Fa in
is the address where the arguments will be placed;
.Fa inproc
is the XDR routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.Pp
.Fn svc_getcaller
is the approved way of getting the network address of the caller
of a procedure associated with the RPC service transport handle,
.Fa xprt .
.Pp
.Fn svc_getreq_common
is called to handle a request on the given socket.
It is used internally by
.Fn svc_getreq_poll ,
.Fn svc_getreqset ,
.Fn svc_getreqset2 ,
and
.Fn svc_getreq .
.Pp
.Fn svc_getreq_poll
is a routine which is only of interest if a service implementor
does not call
.Fn svc_run ,
but instead implements custom asynchronous event processing.
It is called when the
.Xr poll 2
system call has determined that an RPC request has arrived on some RPC
.Fa socket(s) ;
.Fa pollretval
is the value returned by
.Xr poll 2
and
.Fa pfds
is the array of
.Fa pollfd
structures passed to
.Xr poll 2 .
The routine returns when all sockets described by
.Fa pollfd
have been serviced.
.Pp
.Fn svc_getreqset
is a routine which is only of interest if a service implementor
does not call
.Fn svc_run ,
but instead implements custom asynchronous event processing.
It is called when the
.Xr select 2
system call has determined that an RPC request has arrived on some RPC
.Fa socket(s) ;
.Fa rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.Fa rdfds
have been serviced.
.Pp
.Fn svc_getreqset2
is a non-standard routine which is only of interest if a service
implementor does not call
.Fn svc_run ,
but instead implements custom asynchronous event processing.
It is called when the
.Xr select 2
system call has determined that an RPC request has arrived on some RPC
.Fa socket(s) ;
.Fa rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.Fa rdfds
have been serviced.
This interface is non-portable, but provided for applications which
need to deal with large fd_set sizes.
.Pp
.Fn svc_getreq
is similar to
.Fa svc_getreqset ,
but limited to 32 descriptors.
This interface is obsoleted by
.Fa svc_getreq_poll
and
.Fa svc_getreqset .
.Pp
.Fn svc_register
associates
.Fa prognum
and
.Fa versnum
with the service dispatch procedure,
.Fa dispatch .
If
.Fa protocol
is zero, the service is not registered with the
.Xr portmap 8
service.
If
.Fa protocol
is non-zero, then a mapping of the triple
.Fa [ prognum , versnum , protocol ]
to
.Fa xprt-\*(Gtxp_port
is established with the local
.Xr portmap 8
service (generally
.Fa protocol
is zero,
.Dv IPPROTO_UDP
or
.Dv IPPROTO_TCP ) .
The procedure
.Fa dispatch
has the following form:
.Ft int
.Fn dispatch "struct svc_req *request" "SVCXPRT *xprt"
The
.Fn svc_register
routine returns one if it succeeds, and zero otherwise.
.Pp
.Fn svc_run
never returns.
It waits for RPC requests to arrive, and calls the appropriate service
procedure using
.Fn svc_getreq_poll
when one arrives.
This procedure is usually waiting for a
.Xr poll 2
system call to return.
.Pp
.Fn svc_sendreply
is called by an RPC service's dispatch routine to send the results of a
remote procedure call.
The parameter
.Fa xprt
is the request's associated transport handle;
.Fa outproc
is the XDR routine which is used to encode the results; and
.Fa out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn svc_unregister
removes all mapping of the double
.Fa [ prognum , versnum ]
to dispatch routines, and of the triple
.Fa [ prognum , versnum , * ]
to port number.
.Pp
.Fn svcerr_auth
is called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.Pp
.Fn svcerr_decode
is called by a service dispatch routine that cannot successfully
decode its parameters.
See also
.Fn svc_getargs .
.Pp
.Fn svcerr_noproc
is called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.Pp
.Fn svcerr_noprog
is called when the desired program is not registered with the RPC
package.
Service implementors usually do not need this routine.
.Pp
.Fn svcerr_progvers
is called when the desired version of a program is not registered
with the RPC package.
Service implementors usually do not need this routine.
.Pp
.Fn svcerr_systemerr
is called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.Pp
.Fn svcerr_weakauth
is called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.
The routine calls
.Fa "svcerr_auth(xprt, AUTH_TOOWEAK)" .
.Pp
.Fn svcraw_create
is a routine which creates a toy RPC
service transport, to which it returns a pointer.
The transport is really a buffer within the process's address space,
so the corresponding RPC client should live in the same
address space;
see
.Fn clntraw_create .
This routine allows simulation of RPC and acquisition of RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.Dv NULL
if it fails.
.Pp
.Fn svctcp_create
is a routine which creates a TCP/IP-based RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.Fa sock ,
which may be
.Fa RPC_ANYSOCK ,
in which case a new socket is created.
If the socket is not bound to a local TCP
port, then this routine binds it to an arbitrary port.
Upon completion,
.Fa xprt-\*(Gtxp_sock
is the transport's socket descriptor, and
.Fa xprt-\*(Gtxp_port
is the transport's port number.
This routine returns
.Dv NULL
if it fails.
Since TCP-based RPC uses buffered I/O,
users may specify the size of buffers; values of zero
choose suitable defaults.
.Pp
.Fn svcfd_create
will create a service on top of any open descriptor.
Typically, this descriptor is a connected socket for a stream protocol such
as TCP.
.Fa sendsize
and
.Fa recvsize
indicate sizes for the send and receive buffers.
If they are zero, a reasonable default is chosen.
.Pp
.Fn svcudp_create
is a routine which creates a UDP/IP-based RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.Fa sock ,
which may be
.Fa RPC_ANYSOCK ,
in which case a new socket is created.
If the socket is not bound to a local UDP
port, then this routine binds it to an arbitrary port.
Upon completion,
.Fa xprt-\*(Gtxp_sock
is the transport's socket descriptor, and
.Fa xprt-\*(Gtxp_port
is the transport's port number.
This routine returns
.Dv NULL
if it fails.
.Pp
.Fn svcudp_bufcreate
is like
.Fn svcudp_create ,
except that it allows the user to specify the maximum packet size for sending
and receiving UDP-based RPC
messages instead of using the default size limit of 8800 bytes.
.Pp
.Fn xdr_accepted_reply
is used for encoding RPC reply messages.
This routine is useful for users who wish to generate RPC-style
messages without using the RPC package.
.Pp
.Fn xdr_authunix_parms
is used for describing
.Ux
credentials.
This routine is useful for users
who wish to generate these credentials without using the RPC
authentication package.
.Pp
.Fn xdr_callhdr
is used for describing RPC call header messages.
This routine is useful for users who wish to generate RPC-style
messages without using the RPC package.
.Pp
.Fn xdr_callmsg
is used for describing RPC call messages.
This routine is useful for users who wish to generate RPC-style
messages without using the RPC package.
.Pp
.Fn xdr_opaque_auth
is used for describing RPC authentication information messages.
This routine is useful for users who wish to generate RPC-style
messages without using the RPC package.
.Pp
.Fn xdr_pmap
is used for describing parameters to various
.Xr portmap 8
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the pmap interface.
.Pp
.Fn xdr_pmaplist
is used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the pmap interface.
.Pp
.Fn xdr_rejected_reply
is used for describing RPC reply messages.
This routine is useful for users who wish to generate RPC-style
messages without using the RPC package.
.Pp
.Fn xdr_replymsg
is used for describing RPC reply messages.
This routine is useful for users who wish to generate RPC-style
messages without using the RPC package.
.Pp
.Fn xprt_register
is used to register transport handles.
After RPC service transport handles are created,
they should register themselves with the RPC service package.
This routine modifies the global variables
.Va svc_pollfd ,
.Va svc_fdset ,
.Va __svc_fdset
and may modify
.Va svc_max_pollfd
and
.Va __svc_fdsetsize .
Service implementors usually do not need this routine.
.Pp
.Fn xprt_unregister
is used to unregister a transport handle.
Before an RPC service transport handle is destroyed,
it should unregister itself with the RPC service package.
This routine modifies the global variable
.Va svc_pollfd ,
.Va svc_fdset ,
and
.Va __svc_fdset .
Service implementors usually do not need this routine.
.Sh SEE ALSO
.\"Xr rpc_secure 3 ,
.Xr rpcgen 1 ,
.Xr poll 2 ,
.Xr select 2 ,
.Xr authnone_create 3 ,
.Xr getrpcent 3 ,
.Xr getrpcport 3 ,
.Xr xdr 3 ,
.Xr rpc 5 ,
.Xr portmap 8
.Rs
.%Q Sun Microsystems, Inc.
.%T Remote Procedure Calls: Protocol Specification
.Re
.Rs
.%Q Sun Microsystems, Inc.
.%T Remote Procedure Call Programming Guide
.Re
.Rs
.%Q Sun Microsystems, Inc.
.%T rpcgen Programming Guide
.Re
.Sh STANDARDS
.Rs
.%D June 1988
.%Q Sun Microsystems, Inc.
.%R RFC 1057
.%T RPC: Remote Procedure Call Protocol Specification Version 2
.Re
@


1.47
log
@use .Va for global variables, and .Vt where the type is included
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.46 2013/06/05 03:39:23 tedu Exp $
d55 2
a56 2
.Dd $Mdocdate: June 5 2013 $
.Dt RPC 3
@


1.46
log
@Use the fancy .In macro for includes. From Jan Klemkow. ok jmc schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.45 2012/09/27 11:31:58 jmc Exp $
d55 1
a55 1
.Dd $Mdocdate: September 27 2012 $
d178 1
a178 2
.Ft struct rpc_createerr
.Fa rpc_createerr ;
d181 6
a186 12
.Ft struct pollfd *
.Fa svc_pollfd ;
.Ft int
.Fa svc_max_pollfd ;
.Ft fd_set
.Fa svc_fdset ;
.Ft fd_set
.Fa *__svc_fdset ;
.Ft int
.Fa __svc_fdsetsize ;
.Ft int
.Fa svc_fds ;
d657 1
a657 1
.Fn rpc_createerr
d742 1
a742 1
.Fa rpc_createerr
d760 1
a760 1
.Fa svc_pollfd
d773 1
a773 1
.Fa svc_max_pollfd
d775 1
a775 1
.Fa svc_pollfd
d777 1
a777 1
.Fa svc_max_pollfd
d783 1
a783 1
.Fa svc_max_pollfd
d785 1
a785 1
.Fa svc_pollfd
d789 1
a789 1
.Fa __svc_fdset
d791 1
a791 1
.Fa __svc_fdsetsize
d794 1
a794 1
.Fa __svc_fdsetsize
d796 1
a796 1
.Fa __svc_fdset ,
d813 1
a813 1
.Fa svc_pollfd
d815 1
a815 1
.Fa svc_max_pollfd
d818 1
a818 1
.Fa svc_fdset
d820 1
a820 1
.Fa __svc_fdset
d842 1
a842 1
.Fa svc_pollfd
d845 1
a845 1
.Fa svc_fds
d847 1
a847 1
.Fa svc_fedset ,
d850 1
a850 1
.Fa svc_fdset
d1183 3
a1185 3
.Fa svc_pollfd ,
.Fa svc_fdset ,
.Fa __svc_fdset
d1187 1
a1187 1
.Fa svc_max_pollfd
d1189 1
a1189 1
.Fa __svc_fdsetsize .
d1197 2
a1198 2
.Fa svc_pollfd ,
.Fa svc_fdset ,
d1200 1
a1200 1
.Fa __svc_fdset .
@


1.45
log
@last stage of rfc changes, using consistent Rs/Re blocks, and moving the
references into a STANDARDS section;
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.44 2012/03/04 17:42:32 schwarze Exp $
d55 1
a55 1
.Dd $Mdocdate: March 4 2012 $
d127 1
a127 1
.Fd #include <rpc/rpc.h>
@


1.44
log
@Drop the rpcauth(3) MLINK, there is no function of that name.
Joint work with and OK  haesbaert@@ jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.43 2010/10/29 12:43:09 jmc Exp $
d55 1
a55 1
.Dd $Mdocdate: October 29 2010 $
a1219 6
.Pp
The following manuals:
.Rs
.%A "Sun Microsystems, Inc."
.%T "Remote Procedure Calls: Protocol Specification"
.Re
d1221 2
a1222 2
.%A "Sun Microsystems, Inc."
.%T "Remote Procedure Call Programming Guide"
d1225 2
a1226 2
.%A "Sun Microsystems, Inc."
.%T "rpcgen Programming Guide"
d1229 2
a1230 2
.%A "Sun Microsystems, Inc."
.%T "RPC: Remote Procedure Call Protocol Specification"
d1232 1
d1234 4
a1237 3
.%A "Sun Microsystems, Inc."
.%D "June 1988"
.%T "RFC 1057"
@


1.43
log
@- the nroff workaround is no longer needed
- use some Fn and \*(Gt
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.42 2010/09/07 19:52:37 schwarze Exp $
d55 1
a55 1
.Dd $Mdocdate: September 7 2010 $
d1214 1
a1216 1
.Xr rpcauth 3 ,
@


1.42
log
@do not use .B, which is man(7), not mdoc(7); and stop .Tn abuse
feedback and ok jmc@@, ok millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.41 2010/09/01 14:43:34 millert Exp $
d55 1
a55 1
.Dd $Mdocdate: September 1 2010 $
a169 1
.\" XXX the following works around an apparent nroff line length bug.
d171 1
a171 1
.Fn pmap_rmtcall "struct sockaddr_in *" "u_long prog, vers, proc" "xdrproc_t inp" "char *in" "xdrproc_t outp" "char *out" "struct timeval tv" "u_long *portp"
d562 1
a562 1
.Fa addr\->sin_port
d593 1
a593 1
.Fa addr\->sin_port
d773 3
a775 2
This variable is read-only, and it may change after calls
to svc_getreq_poll() or any creation routines.
d786 3
a788 2
This variable is read-only, and it may change after calls
to svc_getreq_poll() or any creation routines.
d813 3
a815 2
This variable is read-only, and it may change after calls
to svc_getreqset() or any creation routines.
d835 3
a837 2
This variable is read-only, and it may change after calls
to svc_getreqset() or any creation routines.
d977 1
a977 1
.Fa xprt\->xp_port
d1088 1
a1088 1
.Fa xprt\->xp_sock
d1090 1
a1090 1
.Fa xprt\->xp_port
d1120 1
a1120 1
.Fa xprt\->xp_sock
d1122 1
a1122 1
.Fa xprt\->xp_port
@


1.41
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.40 2009/06/03 19:54:44 schwarze Exp $
d55 1
a55 1
.Dd $Mdocdate: June 3 2009 $
d303 1
a303 2
calling remote procedures with this routine uses
.Tn UDP/IP
d349 1
a349 3
which is obtained with an
.Tn RPC
client creation routine such as
d364 1
a364 3
is a macro that destroys the client's
.Tn RPC
handle.
d372 1
a372 3
If the
.Tn RPC
library opened the associated socket, it will close it also.
d389 1
a389 1
.Tn NULL
d393 2
a394 6
Using
.Tn UDP
has its shortcomings.
Since
.Tn UDP-based
.Tn RPC
d406 1
a406 4
For both
.Tn UDP
and
.Tn TCP ,
d411 2
a412 2
.Tn CLSET_TIMEOUT	struct timeval	set total timeout
.Tn CLGET_TIMEOUT	struct timeval	get total timeout
d422 1
a422 1
.Tn CLGET_SERVER_ADDR	struct sockaddr_in 	get server's address
d425 1
a425 3
The following operations are valid for
.Tn UDP
only:
d427 2
a428 2
.Tn CLSET_RETRY_TIMEOUT   struct timeval	set the retry timeout
.Tn CLGET_RETRY_TIMEOUT   struct timeval	get the retry timeout
d431 1
a431 2
The retry timeout is the time that
.Tn "UDP RPC"
d436 2
a437 5
is a macro that frees any data allocated by the
.Tn RPC/XDR
system when it decoded the results of an
.Tn RPC
call.
d442 1
a442 3
is the
.Tn XDR
routine describing the results.
d455 1
a455 3
why a client
.Tn RPC
handle could not be created.
d475 1
a475 3
prints a message to standard error indicating why an
.Tn RPC
call failed;
d498 1
a498 2
indicating why an
.Tn RPC
d503 1
a503 2
it does not append a
.Tn NEWLINE
d539 1
a539 3
is a routine which creates a toy
.Tn RPC
client for the remote program
d545 1
a545 3
corresponding
.Tn RPC
server should live in the same address space; see
d547 1
a547 4
This allows simulation of
.Tn RPC
and acquisition of
.Tn RPC
d551 1
a551 1
.Tn NULL
d555 1
a555 3
is a routine which creates an
.Tn RPC
client for the remote program
d559 1
a559 3
the client uses
.Tn TCP/IP
as a transport.
d574 1
a574 5
Since
.Tn TCP-based
.Tn RPC
uses buffered
.Tn I/O ,
d582 1
a582 1
.Tn NULL
d586 1
a586 3
is a routine which creates an
.Tn RPC
client for the remote program
d590 1
a590 3
the client uses use
.Tn UDP/IP
as a transport.
d605 1
a605 3
The
.Tn UDP
transport resends the call message in intervals of
d612 1
a612 1
.Tn NULL
d619 1
a619 3
and receiving
.Tn UDP-based
.Tn RPC
d623 1
a623 3
stuffs the machine's
.Tn IP
address into
d634 2
a635 6
service, which returns a list of the current
.Tn RPC
program-to-port mappings
on the host located at
.Tn IP
address
d638 1
a638 1
.Tn NULL .
d656 1
a656 2
.B
.Tn IPPROTO_UDP
d658 1
a658 1
.Fa IPPROTO_TCP .
d661 1
a661 3
the
.Tn RPC
system failured to contact the remote
d666 1
a666 3
contains the
.Tn RPC
status.
d673 1
a673 3
on the host at
.Tn IP
address
d675 1
a675 3
to make an
.Tn RPC
call on your behalf to a procedure on that host.
d704 1
a704 2
.B
.Tn IPPROTO_UDP
d706 1
a706 1
.Fa IPPROTO_TCP .
d726 1
a726 3
with the
.Tn RPC
service package.
d746 1
a746 3
are accessed using the
.Tn UDP/IP
transport; see
d751 1
a751 3
is a global variable whose value is set by any
.Tn RPC
client creation routine
d758 1
a758 3
is a macro that destroys the
.Tn RPC
service transport handle,
d769 1
a769 3
is a global variable reflecting the
.Tn RPC
service side's
d798 1
a798 3
are global variables reflecting the
.Tn RPC
service side's
d858 1
a858 2
is a macro that frees any data allocated by the
.Tn RPC/XDR
d867 2
a868 6
is a macro that decodes the arguments of an
.Tn RPC
request
associated with the
.Tn RPC
service transport handle,
d874 1
a874 3
is the
.Tn XDR
routine used to decode the arguments.
d880 1
a880 3
of a procedure associated with the
.Tn RPC
service transport handle,
d899 1
a899 4
system call has determined that an
.Tn RPC
request has arrived on some
.Tn RPC
d921 1
a921 4
system call has determined that an
.Tn RPC
request has arrived on some
.Tn RPC
d937 1
a937 4
system call has determined that an
.Tn RPC
request has arrived on some
.Tn RPC
d980 1
a980 2
.B
.Tn IPPROTO_UDP
d982 1
a982 2
.B
.Tn IPPROTO_TCP ) .
d994 1
a994 3
It waits for
.Tn RPC
requests to arrive, and calls the appropriate service
d1003 1
a1003 3
is called by an
.Tn RPC
service's dispatch routine to send the results of a
d1009 1
a1009 3
is the
.Tn XDR
routine which is used to encode the results; and
d1036 1
a1036 2
is called when the desired program is not registered with the
.Tn RPC
d1042 1
a1042 3
with the
.Tn RPC
package.
d1060 1
a1060 2
is a routine which creates a toy
.Tn RPC
d1063 1
a1063 3
so the corresponding
.Tn RPC
client should live in the same
d1067 1
a1067 4
This routine allows simulation of
.Tn RPC
and acquisition of
.Tn RPC
d1071 1
a1071 1
.Tn NULL
d1075 1
a1075 3
is a routine which creates a
.Tn TCP/IP-based
.Tn RPC
d1082 1
a1082 2
If the socket is not bound to a local
.Tn TCP
d1090 1
a1090 1
.Tn NULL
d1092 1
a1092 5
Since
.Tn TCP-based
.Tn RPC
uses buffered
.Tn I/O ,
d1099 1
a1099 2
as
.Tn TCP .
d1107 1
a1107 3
is a routine which creates a
.Tn UDP/IP-based
.Tn RPC
d1114 1
a1114 2
If the socket is not bound to a local
.Tn UDP
d1122 1
a1122 1
.Tn NULL
d1129 1
a1129 3
and receiving
.Tn UDP-based
.Tn RPC
d1133 1
a1133 3
is used for encoding
.Tn RPC
reply messages.
d1135 1
a1135 3
messages without using the
.Tn RPC
package.
d1139 1
a1139 1
.Tn UNIX
d1142 1
a1142 2
who wish to generate these credentials without using the
.Tn RPC
d1146 3
a1148 8
is used for describing
.Tn RPC
call header messages.
This routine is useful for users who wish to generate
.Tn RPC-style
messages without using the
.Tn RPC
package.
d1151 3
a1153 8
is used for describing
.Tn RPC
call messages.
This routine is useful for users who wish to generate
.Tn RPC-style
messages without using the
.Tn RPC
package.
d1156 3
a1158 8
is used for describing
.Tn RPC
authentication information messages.
This routine is useful for users who wish to generate
.Tn RPC-style
messages without using the
.Tn RPC
package.
d1173 3
a1175 8
is used for describing
.Tn RPC
reply messages.
This routine is useful for users who wish to generate
.Tn RPC-style
messages without using the
.Tn RPC
package.
d1178 3
a1180 8
is used for describing
.Tn RPC
reply messages.
This routine is useful for users who wish to generate
.Tn RPC
style messages without using the
.Tn RPC
package.
d1184 2
a1185 6
After
.Tn RPC
service transport handles are created,
they should register themselves with the
.Tn RPC
service package.
d1198 2
a1199 6
Before an
.Tn RPC
service transport handle is destroyed,
it should unregister itself with the
.Tn RPC
service package.
@


1.40
log
@State that clnt{raw,udp}_create can fail.
"no objection" millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.39 2009/06/02 14:11:39 schwarze Exp $
d26 1
d28 26
a53 53
.\" Sun RPC is a product of Sun Microsystems, Inc. and is provided for
.\" unrestricted use provided that this legend is included on all tape
.\" media and as a part of the software program in whole or part.  Users
.\" may copy or modify Sun RPC without charge, but are not authorized
.\" to license or distribute it to anyone else except as part of a product or
.\" program developed by the user.
.\"
.\" SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
.\" WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
.\"
.\" Sun RPC is provided with no support and without any obligation on the
.\" part of Sun Microsystems, Inc. to assist in its use, correction,
.\" modification or enhancement.
.\"
.\" SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
.\" INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
.\" OR ANY PART THEREOF.
.\"
.\" In no event will Sun Microsystems, Inc. be liable for any lost revenue
.\" or profits or other special, indirect and consequential damages, even if
.\" Sun has been advised of the possibility of such damages.
.\"
.\" Sun Microsystems, Inc.
.\" 2550 Garcia Avenue
.\" Mountain View, California  94043
.\"
.\" Sun RPC is a product of Sun Microsystems, Inc. and is provided for
.\" unrestricted use provided that this legend is included on all tape
.\" media and as a part of the software program in whole or part.  Users
.\" may copy or modify Sun RPC without charge, but are not authorized
.\" to license or distribute it to anyone else except as part of a product or
.\" program developed by the user.
.\"
.\" SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
.\" WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
.\"
.\" Sun RPC is provided with no support and without any obligation on the
.\" part of Sun Microsystems, Inc. to assist in its use, correction,
.\" modification or enhancement.
.\"
.\" SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
.\" INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
.\" OR ANY PART THEREOF.
.\"
.\" In no event will Sun Microsystems, Inc. be liable for any lost revenue
.\" or profits or other special, indirect and consequential damages, even if
.\" Sun has been advised of the possibility of such damages.
.\"
.\" Sun Microsystems, Inc.
.\" 2550 Garcia Avenue
.\" Mountain View, California  94043
d55 1
a55 1
.Dd $Mdocdate: June 2 2009 $
@


1.39
log
@make the documentation of {svc,clnt}*create complete and correct
ok millert@@ jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.38 2007/05/31 19:19:30 jmc Exp $
d81 1
a81 1
.Dd $Mdocdate: May 31 2007 $
d421 3
d686 3
@


1.38
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.37 2005/10/02 15:18:27 jmc Exp $
d81 1
a81 1
.Dd $Mdocdate$
d136 1
d138 1
d266 3
a268 1
.Fn svcudp_bufcreate "int sock"
d684 4
a687 1
This allows the user to specify the maximum packet size for sending
d691 1
a691 1
messages.
d1248 1
a1248 1
.Fn svcudp_bufcreate
d1270 5
a1274 2
This allows the user to specify the maximum packet size for sending and
receiving
d1277 1
a1277 1
messages.
@


1.37
log
@some fixes to the .Nm list:

- remove duplicate entry for clntudp_create
- add missing entries for svc_{destroy,fds,run}
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.36 2005/04/01 07:44:04 otto Exp $
d81 1
a81 1
.Dd February 16, 1988
@


1.36
log
@ansify. ok deraadt@@ jaredy@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.35 2004/04/28 06:28:23 jmc Exp $
a101 1
.Nm clntudp_create ,
d111 2
d125 1
@


1.35
log
@typo from Jared Yanovich;
ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.34 2003/12/31 03:27:23 millert Exp $
d196 1
a196 1
.Fn pmap_set "u_long prognum" "u_long versnum" "u_int protocol" "u_short port"
@


1.34
log
@Implement svc_getreq_poll(3) and friends and use poll(2) instead of select(2)
in the libc rpc code.  The main difference between this and the previous
version is the use of a simple free list that simplifies the logic when
adding a socket to svc_pollfd.  I've also added code to pack svc_pollfd
when the free list gets too big.  The idea general idea is to keep
svc_pollfd as tightly packed as possible to make poll(2) efficient.
Tested by many people and OK deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.33 2003/06/29 13:42:40 jmc Exp $
d815 1
a815 1
.Fa progname
@


1.33
log
@remove some old groff macros and replace them with -mdoc ones;
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.32 2003/05/30 22:12:43 jmc Exp $
d117 2
d122 2
d205 4
d224 4
d230 1
a230 1
.Fn svc_getreqset2 "fd_set *rdfds, int width"
a440 1
.Pp
a451 1
.Pp
a458 1
.Pp
d854 29
d907 5
a918 1
This is the preferred interface for portability though.
d925 1
a925 1
Do not pass its address to
d927 1
a927 1
Instead, pass the address of a copy.
d935 3
d944 2
a945 1
.Fa svc_fdset .
d982 34
a1054 2
.Tn RPC
internals use it.
d1061 2
d1108 1
a1108 1
.Fn svc_getreq
d1111 1
a1111 1
.Xr select 2
d1355 8
a1362 2
This routine modifies the global variable
.Fa svc_fds .
d1374 4
a1377 1
.Fa svc_fds .
d1382 1
@


1.32
log
@- whitespace at EOL
- remove unnecessary macros
- section reorder in getrpcent(3)
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.31 2003/05/07 08:52:43 jmc Exp $
d397 4
a400 2
The currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
d699 1
a699 1
.Pa ` "rpcinfo \-p" '
d753 3
a755 2
This procedure should be used for a \(lqping\(rq and nothing
else.
@


1.31
log
@typos;
@
text
@d1 2
a2 2
.\"	$OpenBSD: rpc.3,v 1.30 2003/03/17 09:52:21 jmc Exp $
.\" 
d5 1
a5 1
.\" 
d14 1
a14 1
.\" 
d25 2
a26 2
.\" 
.\" 
d80 1
a80 1
.\" 
@


1.30
log
@some small typos;
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.29 2003/02/18 07:47:00 jmc Exp $
d304 1
a304 1
.Fa enum clnt_stat"
d482 1
a482 1
print a message to standard error indicating
d532 1
a532 1
call failed, return a pointer to a string which contains
d558 1
a558 1
returns pointer to static data, but the
d760 1
a760 1
.Fa [ prognum , versnum , protocol]
d781 1
a781 1
.Fa [ prognum , versnum , *]
d851 2
a852 1
.Fa __svc_fdset, and can expand to the full size that
d884 1
a884 1
As well, note that if the process has descriptor limits
d997 1
a997 1
.Fa [ prognum , versnum , protocol]
d1051 1
a1051 1
.Fa [ prognum , versnum , *]
@


1.29
log
@copyrights added;

these are all Sun Microsystems
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.28 2003/02/14 23:24:12 deraadt Exp $
d667 1
a667 1
This allows the user to specify the maximun packet size for sending
d1177 1
a1177 1
This allows the user to specify the maximun packet size for sending and
@


1.28
log
@put my copyrights on here
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.27 2001/09/16 19:12:31 millert Exp $
d54 27
@


1.27
log
@It is not legal to have multiple .%T entries in a reference so split
the manual references up.  This is still not as nice as it could be
but at least groff no longer spits out an error.
@
text
@d1 52
a52 2
.\"	$OpenBSD: rpc.3,v 1.26 2001/08/06 10:42:26 mpech Exp $
.\" Mostly converted to mandoc by Theo de Raadt, Tue Feb 24 04:04:46 MST 1998
@


1.26
log
@o) We always close .Bl and .Bd tags;
o) .Sh AUTHOR -> .Sh AUTHORS;
o) We don't like .Pp before/after .Sh;
o) We don't like .Pp before/after .Rs/.Re;
o) NetBSD -> .Nx;
o) OpenBSD -> .Ox;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.25 2000/12/21 21:11:31 deraadt Exp $
d1222 19
a1240 6
.%T "Remote Procedure Calls: Protocol Specification;"
.%T "Remote Procedure Call Programming Guide;"
.%T "rpcgen Programming Guide;"
.%T "RPC: Remote Procedure Call Protocol Specification;"
.%T "RFC1057"
.%A "Sun Microsystems, Inc., USC-ISI."
@


1.25
log
@document svc_getreqset2(), a non-standard interface
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.25 2000/12/21 21:04:13 deraadt Exp $
d1221 1
a1221 1
.Re
@


1.24
log
@typo
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.23 2000/08/02 15:58:09 provos Exp $
d41 1
d141 2
d873 23
@


1.23
log
@update other obsoleted rfcs
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.22 2000/04/25 16:45:25 espie Exp $
d224 1
a224 1
.Fa"enum clnt_stat"
@


1.22
log
@Typo
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.21 2000/04/18 03:01:34 aaron Exp $
d1200 1
a1200 1
.%T "RFC1050"
@


1.21
log
@Repairs, mostly removing hard sentence breaks.
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.20 2000/04/15 02:15:23 aaron Exp $
d26 1
a26 1
.Nm cnlt_geterr ,
@


1.20
log
@Mostly punctuation fixes.
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.19 1999/06/16 08:45:11 alex Exp $
d243 2
a244 2
connected broadcast nets. Each time it receives a
response, this routine calls
d270 2
a271 2
maximum transfer unit of the data link. For Ethernet,
this value is 1500 bytes.
d297 2
a298 2
handle. Destruction usually involves deallocation
of private data structures, including
d300 2
a301 1
itself.  Use of
d316 2
a317 2
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
d325 2
a326 1
has its shortcomings.  Since
d339 2
a340 1
is a pointer to the information. For both
d383 2
a384 2
call.  The
parameter
d453 2
a454 1
the message.  Unlike
d510 2
a511 1
kernel interference. This routine returns
d524 2
a525 2
as a transport. The remote program is located at Internet
address
d532 2
a533 1
service is consulted for this information). The parameter
d563 2
a564 2
as a transport. The remote program is located at Internet
address
d571 2
a572 1
service is consulted for this information). The parameter
d643 2
a644 1
service.  In the latter case, the global variable
d666 2
a667 2
succeeds. The definitions of other parameters are discussed
in
d685 2
a686 1
service. The value of
d706 2
a707 2
service. This routine returns one if it succeeds, zero
otherwise.
d714 2
a715 1
service package.  If a request arrives for program
d744 2
a745 1
that does not succeed.  Use the routine
d757 2
a758 1
itself.  Use of
d813 2
a814 2
but limited to 32 descriptors. This
interface is obsoleted by
d874 2
a875 1
but limited to 32 descriptors. This interface is obsoleted by
d889 2
a890 1
service.  If
d916 2
a917 1
never returns. It waits for
d922 2
a923 1
when one arrives. This procedure is usually waiting for a
d931 2
a932 1
remote procedure call.  The parameter
d956 2
a957 1
decode its parameters. See also
d967 2
a968 1
package. Service implementors usually do not need this routine.
d974 2
a975 1
package. Service implementors usually do not need this routine.
d987 2
a988 1
authentication parameters.  The routine calls
d994 2
a995 3
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
d1024 2
a1025 2
port, then this routine binds it to an arbitrary port.  Upon
completion,
d1032 2
a1033 1
if it fails. Since
d1042 2
a1043 3
will create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
d1049 2
a1050 2
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
d1064 2
a1065 2
port, then this routine binds it to an arbitrary port. Upon
completion,
d1083 2
a1084 3
reply messages. This routine is useful for users who
wish to generate
RPC-style
d1092 2
a1093 1
credentials. This routine is useful for users
d1161 2
a1162 1
is used to register transport handles.  After
d1173 2
a1174 1
is used to unregister a transport handle.  Before an
@


1.19
log
@More xref sorting under SEE ALSO.
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.18 1999/05/25 13:06:45 aaron Exp $
d891 1
a891 2
.Tn IPPROTO_TCP
).
@


1.18
log
@punctuation
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.17 1999/05/24 12:15:33 aaron Exp $
d1169 1
d1171 1
a1171 2
.Xr portmap 8 ,
.Xr xdr 3
@


1.17
log
@replace some old macros with new ones, make use of .Sy for warnings etc; d@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.16 1999/05/20 15:22:52 aaron Exp $
d1026 1
a1026 1
.Tn TCP.
d1058 2
a1059 1
.Tn RPC messages.
@


1.16
log
@repair SYNOPSIS
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.15 1999/05/15 02:18:00 aaron Exp $
d230 2
a231 2
Warning: calling remote procedures with this routine
uses
d267 3
a269 2
.IP
Warning: broadcast sockets are limited in size to the
d320 3
a322 2
.IP
Warning: Using
d350 2
a351 1
Note: if you set the timeout using
d438 3
a440 2
.IP
Bugs: returns pointer to static data that is overwritten
d454 2
a455 2
to the end of the message. 
.IP
d467 3
a469 1
Note: unlike
d483 3
a485 2
.IP
Bugs: returns pointer to static data that is overwritten
d579 3
a581 2
.IP
This allows the user to specify the maximun packet size for sending and receiving 
d592 1
a592 1
.BR /etc/hosts .
d628 1
a628 1
or 
d682 1
a682 1
or 
d721 3
a723 2
.IP
Warning: remote procedures registered in this form
d790 1
a790 1
.br
d889 1
a889 1
or 
d1054 2
a1055 2
.IP
This allows the user to specify the maximun packet size for sending and 
d1163 2
d1167 2
d1170 2
a1171 6
.Xr rpc 5 ,
.Xr rpcauth 3 ,
.Xr rpcgen 1 ,
.Xr select 2 ,
.Xr xdr 3 .
.br
d1173 8
a1180 13
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.Fa "RPC: Remote Procedure Call Protocol Specification" ,
.Tn RFC1050, Sun Microsystems, Inc.,
.Tn USC-ISI.
@


1.15
log
@ethernet -> Ethernet, other repairs
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.14 1999/02/04 01:08:31 deraadt Exp $
d67 1
a67 1
.Fd #include <rpc.h>
@


1.14
log
@correct clnt_control() args; alex@@freebsd
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.13 1998/12/30 22:18:46 deraadt Exp $
d269 1
a269 1
maximum transfer unit of the data link. For ethernet,
@


1.13
log
@doc fix: clnt_sperrno does not append a NEWLINE
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.12 1998/12/21 08:21:59 deraadt Exp $
d79 1
a79 1
.Fn clnt_control "CLIENT *cl" "char *info"
@


1.12
log
@missed some function return types
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.11 1998/08/29 18:57:18 deraadt Exp $
d446 5
a450 2
the message.  The string ends with a
.Tn NEWLINE .
@


1.11
log
@change pmap_set() protocol to u_int, similar to solaris; ref: casper
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.10 1998/03/11 18:55:40 deraadt Exp $
d171 1
d173 1
@


1.10
log
@a start at splitting rpc.3 up a bit; plus fix other errors
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.9 1998/02/25 12:23:17 deraadt Exp $
d114 1
a114 1
.Fn pmap_set "u_long prognum" "u_long versnum" "u_long protocol" "u_short port"
@


1.9
log
@remove unneccessary section
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.8 1998/02/25 12:21:16 deraadt Exp $
a7 4
.Nm auth_destroy ,
.Nm authnone_create ,
.Nm authunix_create ,
.Nm authunix_create_default ,
a67 8
.Ft void
.Fn auth_destroy "AUTH *auth"
.Ft AUTH *
.Fn authnone_create "void"
.Ft AUTH *
.Fn authunix_create "char *host" "int uid" "int gid" "int len" "int *aup.gids"
.Ft AUTH *
.Fn authunix_create_default "void"
a203 44
.Pp
.Fn auth_destroy
is a macro that destroys the authentication information associated with
.Fa auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.Fn auth_destroy .
.Pp
.Fn authnone_create
creates and returns an
.Tn RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.Tn RPC.
.Pp
.Fn authunix_create
creates and returns an
.Tn RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.Tn ID ;
.I gid
is the user's current group
.Tn ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.Pp
.Fn authunix_create_default
calls
.Fn authunix_create
with the appropriate parameters.
d209 1
a209 1
.I procnum
d213 1
a213 1
.I in
d215 1
a215 1
.I out
d217 1
a217 1
.I inproc
d219 1
a219 1
.I outproc
d227 1
a227 1
.IP
d1153 1
@


1.8
log
@__svc_fdsetsize is a max bitcount; like FDSETSIZE before it
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.7 1998/02/25 11:46:51 deraadt Exp $
a814 7
.br
As well, note that if the process has descriptor limits
which are extended beyond
.Fa FD_SETSIZE ,
this variable will only be usable for the first
.Fa FD_SETSIZE
descriptors.
@


1.7
log
@doc __svc_fdset & __svc_fdsetsize
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.6 1998/02/24 12:58:09 deraadt Exp $
d798 4
a801 1
read file descriptor bit mask.  This can expand to the full size that
d803 1
a803 1
can support and hence exceed
@


1.6
log
@mandocmania. there were old mistakes, now it has new mistakes
@
text
@d1 1
a1 1
.\"	$OpenBSD: rpc.3,v 1.5 1996/08/19 08:31:44 tholo Exp $
d137 4
a771 1
.Ft struct rpc_createerr
d792 4
a795 3
.Ft fd_set
.Fa svc_fdset
is a global variable reflecting the
d798 29
a826 1
read file descriptor bit mask.
a843 1
.Ft int
@


1.5
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 2
a2 1
.\"	$OpenBSD: rpc.3,v 1.4 1996/08/13 06:36:59 deraadt Exp $
d4 196
a199 4
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
d208 8
a215 25
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
d220 5
a224 14
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
d228 5
a232 15
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
d242 1
a242 1
.SM ID ;
d245 1
a245 1
.SM ID ;
d251 4
a254 13
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
d256 4
a259 17
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
d263 1
a263 1
.IR host .
d274 1
a274 1
.B "enum clnt_stat"
d277 1
a277 1
.B clnt_perrno(\|)
d282 1
a282 1
.SM UDP/IP
d284 1
a284 1
.B clntudp_create(\|)
d288 4
a291 17
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
d295 1
a295 1
.BR eachresult(\|) ,
d297 5
a301 11
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
d303 1
a303 1
.I out
d305 1
a305 1
.I out
d307 1
a307 1
.BR clnt_broadcast(\|) ,
d309 1
a309 1
.I addr
d312 1
a312 1
.B eachresult(\|)
d314 1
a314 1
.B clnt_broadcast(\|)
d321 4
a324 19
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
d326 1
a326 1
.IR clnt ,
d328 1
a328 1
.SM RPC
d330 1
a330 1
.BR clnt_create(\|) .
d332 1
a332 1
.I in
d334 1
a334 1
.I out
d336 1
a336 1
.I inproc
d338 1
a338 1
.I outproc
d340 1
a340 1
.I tout
d342 4
a345 13
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
d348 1
a348 1
.I clnt
d350 1
a350 1
.I clnt
d352 1
a352 1
.BR clnt_destroy(\|) .
d354 1
a354 1
.SM RPC
d357 4
a360 16
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
d363 1
a363 1
.I proto
d368 1
a368 1
.BR clnt_control(\|) .
d371 1
a371 1
.SM UDP
d373 2
a374 2
.SM UDP\s0-based
.SM RPC
d378 3
a380 14
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
d382 1
a382 1
.I req
d384 1
a384 1
.I info
d386 1
a386 1
.SM UDP
d388 1
a388 1
.SM TCP\s0,
d390 1
a390 1
.I req
d392 6
a397 7
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT	struct timeval	set total timeout
.SM CLGET_TIMEOUT	struct timeval	get total timeout
.fi
.IP
d399 1
a399 1
.BR clnt_control(\|) ,
d401 1
a401 1
.B clnt_call(\|)
d403 5
a407 7
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLGET_SERVER_ADDR	struct sockaddr_in 	get server's address
.fi
.br
.IP
d409 1
a409 1
.SM UDP
d411 6
a416 8
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT   struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT   struct timeval	get the retry timeout
.fi
.br
.IP
d418 1
a418 1
.SM "UDP RPC"
d421 4
a424 15
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
d426 1
a426 1
.SM RPC
d429 1
a429 1
.I out
d431 1
a431 1
.I outproc
d433 1
a433 1
.SM XDR
d438 3
a440 14
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
d443 4
a446 14
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
d448 1
a448 1
.SM RPC
d451 1
a451 1
.I s
d454 3
a456 3
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
d458 1
a458 1
.B clntudp_create(\|)
d460 3
a462 13
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
d464 1
a464 1
.IR stat .
d466 5
a470 15
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
d472 1
a472 1
.I clnt
d475 1
a475 1
.I s
d478 5
a482 15
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
d488 4
a491 14
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
d494 1
a494 1
.SM RPC
d497 1
a497 1
.SM NEWLINE\s0.
d499 1
a499 1
.B clnt_sperrno(\|)
d501 1
a501 1
.B clnt_perrno(\|)
d506 1
a506 1
.BR printf(\|) ,
d508 1
a508 1
.B clnt_perrno(\|)
d511 1
a511 1
.B clnt_sperror(\|)
d513 2
a514 2
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
d517 4
a520 15
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
d522 1
a522 1
.BR clnt_sperrno(\|) )
d527 4
a530 14
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
d532 1
a532 1
.IR prognum ,
d534 1
a534 1
.IR versnum .
d538 1
a538 1
.SM RPC
d540 1
a540 1
.BR svcraw_create(\|) .
d542 1
a542 1
.SM RPC
d544 1
a544 1
.SM RPC
d547 1
a547 1
.SM NULL
d549 4
a552 17
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
d554 1
a554 1
.IR prognum ,
d556 1
a556 1
.IR versnum ;
d558 1
a558 1
.SM TCP/IP
d561 1
a561 1
.IR *addr .
d563 1
a563 2
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
d566 1
a566 1
.B portmap
d568 1
a568 1
.I sockp
d570 1
a570 1
.BR \s-1RPC_ANYSOCK\s0 ,
d572 1
a572 1
.IR sockp .
d574 2
a575 2
.SM TCP\s0-based
.SM RPC
d577 1
a577 1
.SM I/O ,
d580 1
a580 1
.I sendsz
d582 1
a582 1
.IR recvsz ;
d585 1
a585 1
.SM NULL
d587 4
a590 71
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.I wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
d592 1
a592 1
.IR prognum ,
d594 1
a594 1
.IR versnum ;
d596 1
a596 1
.SM UDP/IP
d599 1
a599 1
.IR addr .
d601 1
a601 1
\fB\%addr\->sin_port\fR
d604 1
a604 1
.B portmap
d606 1
a606 1
.I sockp
d608 1
a608 1
.BR \s-1RPC_ANYSOCK\s0 ,
d610 1
a610 1
.BR sockp .
d612 1
a612 1
.SM UDP
d614 1
a614 1
.I wait
d618 1
a618 1
.BR clnt_call(\|) .
d621 2
a622 2
.SM UDP\s0-based
.SM RPC
d624 4
a627 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
int
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
d629 1
a629 1
.IR *addr ,
d633 1
a633 1
.BR htons(\s-1PMAPPORT\s0) .
d635 4
a638 14
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
d640 1
a640 1
.SM RPC
d643 1
a643 1
.SM IP
d645 1
a645 1
.IR *addr .
d647 1
a647 1
.SM NULL .
d649 1
a649 1
.RB ` "rpcinfo \-p" '
d651 4
a654 15
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
d657 1
a657 1
.IR prognum ,
d659 1
a659 1
.IR versnum ,
d661 1
a661 1
.IR protocol .
d663 1
a663 1
.I protocol
d666 1
a666 1
.SM IPPROTO_UDP
d668 1
a668 1
.BR \s-1IPPROTO_TCP\s0 .
d672 1
a672 1
.SM RPC
d674 1
a674 1
.B portmap
d676 1
a676 1
.B rpc_createerr(\|)
d678 1
a678 1
.SM RPC
d680 4
a683 19
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
d685 1
a685 1
.B portmap
d687 1
a687 1
.SM IP
d689 1
a689 1
.I *addr
d691 1
a691 1
.SM RPC
d694 1
a694 1
.I *portp
d699 1
a699 1
.B callrpc(\|)
d701 1
a701 1
.BR clnt_call(\|) .
d705 5
a709 15
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
d711 1
a711 1
.RI [ prognum , versnum , protocol\fR]
d713 1
a713 1
.I port
d715 1
a715 1
.B portmap
d717 1
a717 1
.I protocol
d720 1
a720 1
.SM IPPROTO_UDP
d722 1
a722 1
.BR \s-1IPPROTO_TCP\s0 .
d725 5
a729 14
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
d731 1
a731 1
.RI [ prognum , versnum , *\fR]
d733 1
a733 1
.B ports
d735 1
a735 1
.B portmap
d738 4
a741 15
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
d743 1
a743 1
.SM RPC
d745 1
a745 1
.IR prognum ,
d747 1
a747 1
.IR versnum ,
d749 2
a750 2
.IR procnum ,
.I procname
d752 1
a752 1
.I progname
d754 1
a754 1
.I inproc
d756 1
a756 1
.I outproc
d763 1
a763 1
.SM UDP/IP
d765 1
a765 1
.B svcudp_create(\|)
d767 5
a771 12
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
d774 1
a774 1
.B clnt_pcreateerror(\|)
d776 4
a779 13
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
d781 1
a781 1
.IR xprt .
d784 1
a784 1
.I xprt
d786 1
a786 1
.I xprt
d788 5
a792 12
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
d797 1
a797 1
.BR svc_run(\|) ,
d802 1
a802 1
.BR select(\|) !
d807 1
a807 1
.BR FD_SETSIZE ,
d809 1
a809 1
.BR FD_SETSIZE
d811 5
a815 12
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset ,
d818 5
a822 16
.BR svc_fdset .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
d825 1
a825 1
.BR svc_getargs(\|) .
d829 4
a832 15
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
d835 1
a835 1
.SM RPC
d837 1
a837 1
.IR xprt .
d839 1
a839 1
.I in
d841 1
a841 1
.I inproc
d843 1
a843 1
.SM XDR
d847 3
a849 13
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
d851 1
a851 1
.SM RPC
d853 4
a856 13
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
d858 1
a858 1
.BR svc_run(\|) ,
d861 1
a861 1
.B select
d863 1
a863 1
.SM RPC
d865 3
a867 3
.SM RPC
.B socket(s) ;
.I rdfds
d871 1
a871 1
.I rdfds
d873 4
a876 13
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
d878 5
a882 17
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
d884 1
a884 1
.I versnum
d886 1
a886 1
.IR dispatch .
d888 1
a888 1
.I protocol
d890 1
a890 1
.B portmap
d892 1
a892 1
.I protocol
d894 1
a894 1
.RI [ prognum , versnum , protocol\fR]
d896 1
a896 1
\fB\%xprt\->xp_port\fR
d898 1
a898 1
.B portmap
d900 1
a900 1
.I protocol
d903 1
a903 1
.SM IPPROTO_UDP
d906 1
a906 1
.SM IPPROTO_TCP
d909 1
a909 1
.I dispatch
d911 2
a912 10
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
d914 1
a914 1
.B svc_register(\|)
d916 4
a919 12
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
d922 1
a922 1
.B svc_getreq(\|)
d924 1
a924 1
.B select(\|)
d926 4
a929 15
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
d932 1
a932 1
.I xprt
d934 1
a934 1
.I outproc
d936 1
a936 1
.SM XDR
d938 1
a938 1
.I out
d941 4
a944 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
d946 1
a946 1
.RI [ prognum , versnum , *\fR]
d948 3
a950 14
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
d952 3
a954 13
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
d956 4
a959 14
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
d961 4
a964 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
d966 3
a968 13
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
d970 1
a970 1
.SM RPC
d972 3
a974 13
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
d979 3
a981 13
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
d984 5
a988 14
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
d993 1
a993 1
.SM RPC
d997 1
a997 1
.BR clntraw_create(\|) .
d999 1
a999 1
.SM RPC
d1001 1
a1001 1
.SM RPC
d1005 1
a1005 1
.SM NULL
d1007 5
a1011 16
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
d1014 1
a1014 1
.IR sock ,
d1016 1
a1016 1
.BR \s-1RPC_ANYSOCK\s0 ,
d1019 1
a1019 1
.SM TCP
d1022 1
a1022 1
\fB\%xprt\->xp_sock\fR
d1024 1
a1024 1
\fB\%xprt\->xp_port\fR
d1027 1
a1027 1
.SM NULL
d1029 2
a1030 2
.SM TCP\s0-based
.SM RPC
d1032 1
a1032 1
.SM I/O ,
d1035 3
a1037 15
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
d1041 2
a1042 2
.SM TCP\s0.
.I sendsize
d1044 1
a1044 1
.I recvsize
d1047 5
a1051 15
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
d1054 1
a1054 1
.IR sock ,
d1056 1
a1056 1
.B \s-1RPC_ANYSOCK\s0 ,
d1059 1
a1059 1
.SM UDP
d1062 1
a1062 1
\fB\%xprt\->xp_sock\fR
d1064 1
a1064 1
\fB\%xprt\->xp_port\fR
d1067 1
a1067 1
.SM NULL
d1072 6
a1077 16
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
d1080 1
a1080 1
\s-1RPC\s0-style
d1082 1
a1082 1
.SM RPC
d1084 4
a1087 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
d1090 1
a1090 1
.SM RPC
d1092 4
a1095 15
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
d1098 1
a1098 1
.SM RPC\s0-style
d1100 1
a1100 1
.SM RPC
d1102 4
a1105 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
d1108 1
a1108 1
.SM RPC\s0-style
d1110 1
a1110 1
.SM RPC
d1112 4
a1115 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
d1118 1
a1118 1
.SM RPC\s0-style
d1120 1
a1120 1
.SM RPC
d1122 4
a1125 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
d1128 4
a1131 16
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
d1133 5
a1137 17
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
d1140 1
a1140 1
.SM RPC\s0-style
d1142 1
a1142 1
.SM RPC
d1144 4
a1147 14
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
d1150 1
a1150 1
.SM RPC
d1152 1
a1152 1
.SM RPC
d1154 4
a1157 14
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
d1160 1
a1160 1
.SM RPC
d1163 1
a1163 1
.BR svc_fds(\|) .
d1165 4
a1168 14
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
d1171 1
a1171 1
.SM RPC
d1174 1
a1174 1
.BR svc_fds(\|) .
d1176 9
a1184 3
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
d1197 3
a1199 4
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

@


1.4
log
@fix some fn/arg decls; strengthen reminder that svc_fdset is readonly
@
text
@d1 1
a1 3
.\"	@@(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$OpenBSD: rpc.3,v 1.3 1996/07/20 06:12:36 deraadt Exp $
.\"	$NetBSD: rpc.3,v 1.3 1996/01/04 20:09:53 pk Exp $
@


1.3
log
@bcopy->memcpy & tag
@
text
@d2 1
a2 1
.\"	$OpenBSD: rpc.3,v 1.3 1996/01/04 20:09:53 pk Exp $
d328 2
a329 2
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
d339 2
a340 1
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
d350 2
a351 2
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
d516 1
a516 1
.BR printf ,
d672 1
a672 1
.B wait
d726 1
a726 1
.B wait
d1005 3
a1007 5
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
d1009 13
a1021 6
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
d1033 1
a1033 1
.BR svc_fedset(\|) ,
d1036 1
a1036 1
.BR svc_fdset(\|) .
@


1.2
log
@from netbsd; make get_myaddress() return failure if it is unable to
determine address, make other code understand this failure.
@
text
@d2 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
.\"	$NetBSD: rpc.3,v 1.2 1995/02/25 03:01:53 cgd Exp $
d740 1
a740 1
void
d754 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

