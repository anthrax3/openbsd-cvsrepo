head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.6
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.17.0.42
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.34
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.38
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.36
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.32
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.30
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.28
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.26
	OPENBSD_5_0:1.17.0.24
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.22
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.20
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.16
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.18
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.14
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.12
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.10
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.10
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.8
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.6
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.4
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.9.0.14
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.12
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.10
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.8
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.6
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.4
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.09.14.11.01.47;	author guenther;	state Exp;
branches;
next	1.17;
commitid	0UySDzUm2zFk2635;

1.17
date	2005.12.21.01.40.22;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.01.07.44.03;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.20.22.42.35;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.06.18.35.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.26.03.43.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.24.02.24.21;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.12.17.19.22.08;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.12.16.21.30.35;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.09.15.09.31.30;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.08.19.08.31.24;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.07.30.16.25.47;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.07.30.10.55.22;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.30.10.52.49;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.06.51.25;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.07.29.06.11.57;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.07.20.06.12.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Wrap <ifaddrs.h>, <netinet/in.h>, and <netinet/if_ether.h> so internal
calls go direct and all the symbols are weak
@
text
@/*	$OpenBSD: bindresvport.c,v 1.17 2005/12/21 01:40:22 millert Exp $	*/

/*
 * Copyright 1996, Jason Downs.  All rights reserved.
 * Copyright 1998, Theo de Raadt.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

/*
 * Bind a socket to a privileged IP port
 */
int
bindresvport(int sd, struct sockaddr_in *sin)
{
	return bindresvport_sa(sd, (struct sockaddr *)sin);
}
DEF_WEAK(bindresvport);

/*
 * Bind a socket to a privileged port for whatever protocol.
 */
int
bindresvport_sa(int sd, struct sockaddr *sa)
{
	int old, error, af;
	struct sockaddr_storage myaddr;
	struct sockaddr_in *sin;
	struct sockaddr_in6 *sin6;
	int proto, portrange, portlow;
	u_int16_t port;
	socklen_t salen;

	if (sa == NULL) {
		salen = sizeof(myaddr);
		sa = (struct sockaddr *)&myaddr;

		if (getsockname(sd, sa, &salen) == -1)
			return -1;	/* errno is correctly set */

		af = sa->sa_family;
		memset(&myaddr, 0, salen);
	} else
		af = sa->sa_family;

	if (af == AF_INET) {
		proto = IPPROTO_IP;
		portrange = IP_PORTRANGE;
		portlow = IP_PORTRANGE_LOW;
		sin = (struct sockaddr_in *)sa;
		salen = sizeof(struct sockaddr_in);
		port = sin->sin_port;
	} else if (af == AF_INET6) {
		proto = IPPROTO_IPV6;
		portrange = IPV6_PORTRANGE;
		portlow = IPV6_PORTRANGE_LOW;
		sin6 = (struct sockaddr_in6 *)sa;
		salen = sizeof(struct sockaddr_in6);
		port = sin6->sin6_port;
	} else {
		errno = EPFNOSUPPORT;
		return (-1);
	}
	sa->sa_family = af;
	sa->sa_len = salen;

	if (port == 0) {
		socklen_t oldlen = sizeof(old);

		error = getsockopt(sd, proto, portrange, &old, &oldlen);
		if (error < 0)
			return (error);

		error = setsockopt(sd, proto, portrange, &portlow,
		    sizeof(portlow));
		if (error < 0)
			return (error);
	}

	error = bind(sd, sa, salen);

	if (port == 0) {
		int saved_errno = errno;

		if (error) {
			if (setsockopt(sd, proto, portrange, &old,
			    sizeof(old)) < 0)
				errno = saved_errno;
			return (error);
		}

		if (sa != (struct sockaddr *)&myaddr) {
			/* Hmm, what did the kernel assign... */
			if (getsockname(sd, sa, &salen) < 0)
				errno = saved_errno;
			return (error);
		}
	}
	return (error);
}
DEF_WEAK(bindresvport_sa);
@


1.17
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bindresvport.c,v 1.16 2005/04/01 07:44:03 otto Exp $	*/
d42 1
d125 1
@


1.16
log
@ansify. ok deraadt@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bindresvport.c,v 1.15 2003/05/20 22:42:35 deraadt Exp $	*/
d28 1
a30 1
#include <sys/errno.h>
@


1.15
log
@this is all new code.  copyright to downsj and myself who managed to
erradicate the old stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 3
bindresvport(sd, sin)
	int sd;
	struct sockaddr_in *sin;
d47 1
a47 3
bindresvport_sa(sd, sa)
	int sd;
	struct sockaddr *sa;
@


1.14
log
@use socklen_t where needed; henning pvalchev ok
@
text
@d1 1
a1 32
/*
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.13 2000/01/26 03:43:21 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */
d4 11
a14 1
 * Copyright (c) 1987 by Sun Microsystems, Inc.
d16 10
a25 1
 * Portions Copyright(C) 1996, Jason Downs.  All rights reserved.
@


1.13
log
@new bindresvport() semantics that itojun, shin, jean-luc and i have agreed on, which will be happy for the future. bindresvport_sa() for sockaddr *, too.  docs later..
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.12 2000/01/24 02:24:21 deraadt Exp $";
d71 1
a71 1
	int salen;
d107 1
a107 1
		int oldlen = sizeof(old);
@


1.12
log
@in bindresvport(), if sin is non-NULL, example sin->sin_family for the actual family being processed
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.11 1999/12/17 19:22:08 deraadt Exp $";
d54 1
a54 3
	if (sin)
		return bindresvport_af(sd, (struct sockaddr *)sin, sin->sin_family);
	return bindresvport_af(sd, NULL, AF_INET);
d58 1
a58 1
 * Bind a socket to a privileged IP port
d61 1
a61 1
bindresvport_af(sd, sa, af)
a63 1
	int af;
d65 1
a65 1
	int old, error;
d70 1
a70 1
	u_int16_t *portp;
d74 1
a74 1
		memset(&myaddr, 0, sizeof(myaddr));
d76 8
a83 1
	}
d91 1
a91 1
		portp = &sin->sin_port;
d98 1
a98 1
		portp = &sin6->sin6_port;
d106 1
a106 1
	if (*portp == 0) {
d111 1
a111 1
			return(error);
d116 1
a116 1
			return(error);
d121 1
a121 1
	if (*portp == 0) {
@


1.11
log
@set sa_len too
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.10 1999/12/16 21:30:35 deraadt Exp $";
d54 3
a56 1
	return bindresvport_af(sd, (struct sockaddr *)sin, AF_INET);
@


1.10
log
@rresvport_af() and bindresvport_af()
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.9 1996/09/15 09:31:30 tholo Exp $";
d98 1
@


1.9
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.8 1996/08/19 08:31:24 tholo Exp $";
d54 40
a93 10
	int on, old, error;
	struct sockaddr_in myaddr;
	int sinlen = sizeof(struct sockaddr_in);

	if (sin == (struct sockaddr_in *)0) {
		sin = &myaddr;
		memset(sin, 0, sinlen);
		sin->sin_len = sinlen;
		sin->sin_family = AF_INET;
	} else if (sin->sin_family != AF_INET) {
d97 1
d99 1
a99 1
	if (sin->sin_port == 0) {
d101 2
a102 2
		error = getsockopt(sd, IPPROTO_IP, IP_PORTRANGE,
				   &old, &oldlen);
d106 2
a107 3
		on = IP_PORTRANGE_LOW;
		error = setsockopt(sd, IPPROTO_IP, IP_PORTRANGE,
		           	   &on, sizeof(on));
d112 1
a112 1
	error = bind(sd, (struct sockaddr *)sin, sinlen);
d114 1
a114 1
	if (sin->sin_port == 0) {
d118 2
a119 2
			if (setsockopt(sd, IPPROTO_IP, IP_PORTRANGE,
			    &old, sizeof(old)) < 0)
d124 1
a124 1
		if (sin != &myaddr) {
d126 1
a126 2
			if (getsockname(sd, (struct sockaddr *)sin,
			    &sinlen) < 0)
@


1.8
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.7 1996/07/30 16:25:47 downsj Exp $";
d60 2
a61 2
		memset(sin, 0, sizeof(*sin));
		sin->sin_len = sizeof(*sin);
d82 1
a82 1
	error = bind(sd, (struct sockaddr *)sin, sizeof(*sin));
a94 2
			int sinlen = sizeof(*sin);

@


1.7
log
@errno restore was reversed.
@
text
@a0 3
/*	$OpenBSD: bindresvport.c,v 1.6 1996/07/30 10:55:22 deraadt Exp $	*/
/*	$NetBSD: bindresvport.c,v 1.5 1995/06/03 22:37:19 mycroft Exp $	*/

d31 2
a32 4
/*static char *sccsid = "from: @@(#)bindresvport.c 1.8 88/02/08 SMI";*/
/*static char *sccsid = "from: @@(#)bindresvport.c	2.2 88/07/29 4.0 RPCSRC";*/
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.6 1996/07/30 10:55:22 deraadt Exp $";
#endif
@


1.6
log
@if (beer-tonight) test-before-commit();
@
text
@d1 1
a1 1
/*	$OpenBSD: bindresvport.c,v 1.5 1996/07/30 10:52:49 deraadt Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.5 1996/07/30 10:52:49 deraadt Exp $";
d105 1
a105 1
				saved_errno = errno;
@


1.5
log
@only reset port-range if modified initially; if needed call getsockname
@
text
@d1 1
a1 1
/*	$OpenBSD: bindresvport.c,v 1.4 1996/07/29 06:51:25 downsj Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.4 1996/07/29 06:51:25 downsj Exp $";
d89 1
a89 1
	if (sin.sin_port == 0) {
d100 2
d104 1
a104 1
			    sizeof(*sin)) < 0)
@


1.4
log
@Reset port range if bind() fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: bindresvport.c,v 1.3 1996/07/29 06:11:57 downsj Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.3 1996/07/29 06:11:57 downsj Exp $";
d61 1
d65 2
a66 2
		memset(sin, 0, sizeof (*sin));
		sin->sin_len = sizeof(struct sockaddr_in);
d87 3
a89 3
	error = bind(sd, (struct sockaddr *)sin, sizeof(struct sockaddr_in));
	if (error < 0) {
		/* Don't change error or errno. */
d92 14
a105 3
		if (setsockopt(sd, IPPROTO_IP, IP_PORTRANGE,
			       &old, sizeof(old)) < 0)
			errno = saved_errno;
d107 1
a107 1
	return(error);
@


1.3
log
@Use new bind() kernel semantics.
@
text
@d1 1
a1 1
/*	$OpenBSD: bindresvport.c,v 1.2 1996/07/20 06:12:20 deraadt Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.2 1996/07/20 06:12:20 deraadt Exp $";
d41 2
d59 1
a59 1
	int on, error;
d73 6
d81 1
a81 1
		           	   (char *)&on, sizeof(on));
d87 8
@


1.2
log
@bcopy->memcpy & tag
@
text
@d1 1
a1 1
/*	$OpenBSD: bindresvport.c,v 1.5 1995/06/03 22:37:19 mycroft Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: bindresvport.c,v 1.5 1995/06/03 22:37:19 mycroft Exp $";
d52 1
d57 1
a57 2
	int res;
	static short port;
a58 5
	int i;

#define STARTPORT 600
#define ENDPORT (IPPORT_RESERVED - 1)
#define NPORTS	(ENDPORT - STARTPORT + 1)
d69 7
a75 2
	if (port == 0) {
		port = (getpid() % NPORTS) + STARTPORT;
d77 3
a79 11
	res = -1;
	errno = EADDRINUSE;
	for (i = 0; i < NPORTS && res < 0 && errno == EADDRINUSE; i++) {
		sin->sin_port = htons(port++);
		if (port > ENDPORT) {
			port = STARTPORT;
		}
		res = bind(sd,
		    (struct sockaddr *)sin, sizeof(struct sockaddr_in));
	}
	return (res);
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
static char *rcsid = "$NetBSD: bindresvport.c,v 1.5 1995/06/03 22:37:19 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
