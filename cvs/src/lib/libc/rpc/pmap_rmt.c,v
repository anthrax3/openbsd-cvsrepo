head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.10
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.8
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.6
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.12
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.10
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.8
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.6
	OPENBSD_5_0:1.29.0.4
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.28.0.12
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.8
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.10
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.6
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.4
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.4
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.20.0.6
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.4
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.18.0.4
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.16.0.8
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.16.0.6
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.4
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.15.0.4
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2015.12.28.22.08.18;	author mmcc;	state Exp;
branches;
next	1.33;
commitid	0uXuF2O13NH9q2e1;

1.33
date	2015.09.13.15.36.56;	author guenther;	state Exp;
branches;
next	1.32;
commitid	FxNpAvmgpSFQVav0;

1.32
date	2015.08.20.21.49.29;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	jeIpGH0zlTW3huPH;

1.31
date	2014.11.11.04.51.49;	author guenther;	state Exp;
branches;
next	1.30;
commitid	LYakkpp5DP76DW3H;

1.30
date	2013.11.12.06.59.12;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.02.15.19.17;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.09.22.18.42.04;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.31.17.31.59;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.08.08.05.35;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.01.07.44.04;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.08.19.17.39;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.17.03.24.20;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.31.03.27.23;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.06.18.35.12;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.15.13.51.01;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.24.17.03.15;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.19.17.33.42;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	98.08.14.21.39.37;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.07.09.03.05.05;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.01.22.18.50.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.02.09.21.07;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.12.10.07.46.43;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.11.14.06.23.50;	author etheisen;	state Exp;
branches;
next	1.10;

1.10
date	96.09.15.09.31.37;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	96.09.02.05.01.14;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.08.20.23.47.42;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.19.08.31.42;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.08.15.07.27.49;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.10.05.12.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.10.04.31.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.20.06.12.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.21.54.38;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Remove NULL-checks before free() and a few related dead assignments.

ok and valuable input from millert@@
@
text
@/*	$OpenBSD: pmap_rmt.c,v 1.33 2015/09/13 15:36:56 guenther Exp $ */

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * pmap_rmt.c
 * Client interface to pmap rpc service.
 * remote call and broadcast service
 */

#include <rpc/rpc.h>
#include <rpc/pmap_prot.h>
#include <rpc/pmap_clnt.h>
#include <rpc/pmap_rmt.h>
#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <ifaddrs.h>
#define MAX_BROADCAST_SIZE 1400

static struct timeval timeout = { 3, 0 };


/*
 * pmapper remote-call-service interface.
 * This routine is used to call the pmapper remote call service
 * which will look up a service program in the port maps, and then
 * remotely call that routine with the given parameters.  This allows
 * programs to do a lookup and call in one step.
*/
enum clnt_stat
pmap_rmtcall(struct sockaddr_in *addr, u_long prog, u_long vers, u_long proc,
    xdrproc_t xdrargs, caddr_t argsp, xdrproc_t xdrres, caddr_t resp,
    struct timeval tout, u_long *port_ptr)
{
	int sock = -1;
	CLIENT *client;
	struct rmtcallargs a;
	struct rmtcallres r;
	enum clnt_stat stat;

	addr->sin_port = htons(PMAPPORT);
	client = clntudp_create(addr, PMAPPROG, PMAPVERS, timeout, &sock);
	if (client != NULL) {
		a.prog = prog;
		a.vers = vers;
		a.proc = proc;
		a.args_ptr = argsp;
		a.xdr_args = xdrargs;
		r.port_ptr = port_ptr;
		r.results_ptr = resp;
		r.xdr_results = xdrres;
		stat = CLNT_CALL(client, PMAPPROC_CALLIT, xdr_rmtcall_args, &a,
		    xdr_rmtcallres, &r, tout);
		CLNT_DESTROY(client);
	} else {
		stat = RPC_FAILED;
	}
	addr->sin_port = 0;
	return (stat);
}


/*
 * XDR remote call arguments
 * written for XDR_ENCODE direction only
 */
bool_t
xdr_rmtcall_args(XDR *xdrs, struct rmtcallargs *cap)
{
	u_int lenposition, argposition, position;

	if (xdr_u_long(xdrs, &(cap->prog)) &&
	    xdr_u_long(xdrs, &(cap->vers)) &&
	    xdr_u_long(xdrs, &(cap->proc))) {
		lenposition = XDR_GETPOS(xdrs);
		if (! xdr_u_long(xdrs, &(cap->arglen)))
		    return (FALSE);
		argposition = XDR_GETPOS(xdrs);
		if (! (*(cap->xdr_args))(xdrs, cap->args_ptr))
		    return (FALSE);
		position = XDR_GETPOS(xdrs);
		cap->arglen = (u_long)position - (u_long)argposition;
		XDR_SETPOS(xdrs, lenposition);
		if (! xdr_u_long(xdrs, &(cap->arglen)))
		    return (FALSE);
		XDR_SETPOS(xdrs, position);
		return (TRUE);
	}
	return (FALSE);
}
DEF_WEAK(xdr_rmtcall_args);

/*
 * XDR remote call results
 * written for XDR_DECODE direction only
 */
bool_t
xdr_rmtcallres(XDR *xdrs, struct rmtcallres *crp)
{
	caddr_t port_ptr;

	port_ptr = (caddr_t)crp->port_ptr;
	if (xdr_reference(xdrs, &port_ptr, sizeof (u_long),
	    xdr_u_long) && xdr_u_long(xdrs, &crp->resultslen)) {
		crp->port_ptr = (u_long *)port_ptr;
		return ((*(crp->xdr_results))(xdrs, crp->results_ptr));
	}
	return (FALSE);
}
DEF_WEAK(xdr_rmtcallres);


/*
 * The following is kludged-up support for simple rpc broadcasts.
 * Someday a large, complicated system will replace these trivial 
 * routines which only support udp/ip .
 */
static int
newgetbroadcastnets(struct in_addr **addrsp)
{
	struct ifaddrs *ifap, *ifa;
	struct sockaddr_in *sin;
	struct in_addr *addrs;
	int i = 0, n = 0;

	if (getifaddrs(&ifap) != 0)
		return 0;

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;
		if ((ifa->ifa_flags & IFF_BROADCAST) &&
		    (ifa->ifa_flags & IFF_UP) &&
		    ifa->ifa_broadaddr &&
		    ifa->ifa_broadaddr->sa_family == AF_INET) {
			n++;
		}
	}

	addrs = calloc(n, sizeof(*addrs));
	if (addrs == NULL) {
		freeifaddrs(ifap);
		return 0;
	}

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;
		if ((ifa->ifa_flags & IFF_BROADCAST) &&
		    (ifa->ifa_flags & IFF_UP) &&
		    ifa->ifa_broadaddr &&
		    ifa->ifa_broadaddr->sa_family == AF_INET) {
			sin = (struct sockaddr_in *)ifa->ifa_broadaddr;
			addrs[i++] = sin->sin_addr;
		}
	}

	freeifaddrs(ifap);
	*addrsp = addrs;
	return i;
}

typedef bool_t (*resultproc_t)(caddr_t, struct sockaddr_in *);

enum clnt_stat 
clnt_broadcast(u_long prog,	/* program number */
    u_long vers,		/* version number */
    u_long proc,		/* procedure number */
    xdrproc_t xargs,		/* xdr routine for args */
    caddr_t argsp,		/* pointer to args */
    xdrproc_t xresults,		/* xdr routine for results */
    caddr_t resultsp,		/* pointer to results */
    resultproc_t eachresult)	/* call with each result obtained */
{
	enum clnt_stat stat;
	AUTH *unix_auth;
	XDR xdr_stream;
	XDR *xdrs = &xdr_stream;
	int outlen, inlen, nets;
	socklen_t fromlen;
	int sock = -1;
	int on = 1;
	struct pollfd pfd[1];
	int i;
	int timo;
	bool_t done = FALSE;
	u_long xid;
	u_long port;
	struct in_addr *addrs = NULL;
	struct sockaddr_in baddr, raddr; /* broadcast and response addresses */
	struct rmtcallargs a;
	struct rmtcallres r;
	struct rpc_msg msg;
	char outbuf[MAX_BROADCAST_SIZE], inbuf[UDPMSGSIZE];

	if ((unix_auth = authunix_create_default()) == NULL) {
		stat = RPC_AUTHERROR;
		goto done_broad;
	}

	/*
	 * initialization: create a socket, a broadcast address, and
	 * preserialize the arguments into a send buffer.
	 */
	if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
		stat = RPC_CANTSEND;
		goto done_broad;
	}
#ifdef SO_BROADCAST
	if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0) {
		stat = RPC_CANTSEND;
		goto done_broad;
	}
#endif /* def SO_BROADCAST */

	pfd[0].fd = sock;
	pfd[0].events = POLLIN;

	nets = newgetbroadcastnets(&addrs);
	if (nets == 0) {
		stat = RPC_CANTSEND;
		goto done_broad;
	}

	memset(&baddr, 0, sizeof (baddr));
	baddr.sin_len = sizeof(struct sockaddr_in);
	baddr.sin_family = AF_INET;
	baddr.sin_port = htons(PMAPPORT);
	baddr.sin_addr.s_addr = htonl(INADDR_ANY);
	msg.rm_xid = xid = arc4random();
	msg.rm_direction = CALL;
	msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;
	msg.rm_call.cb_prog = PMAPPROG;
	msg.rm_call.cb_vers = PMAPVERS;
	msg.rm_call.cb_proc = PMAPPROC_CALLIT;
	msg.rm_call.cb_cred = unix_auth->ah_cred;
	msg.rm_call.cb_verf = unix_auth->ah_verf;
	a.prog = prog;
	a.vers = vers;
	a.proc = proc;
	a.xdr_args = xargs;
	a.args_ptr = argsp;
	r.port_ptr = &port;
	r.xdr_results = xresults;
	r.results_ptr = resultsp;
	xdrmem_create(xdrs, outbuf, MAX_BROADCAST_SIZE, XDR_ENCODE);
	if (!xdr_callmsg(xdrs, &msg) || !xdr_rmtcall_args(xdrs, &a)) {
		stat = RPC_CANTENCODEARGS;
		goto done_broad;
	}
	outlen = (int)xdr_getpos(xdrs);
	xdr_destroy(xdrs);

	/*
	 * Basic loop: broadcast a packet and wait a while for response(s).
	 * The response timeout grows larger per iteration.
	 *
	 * XXX This will loop about 5 times the stop. If there are
	 * lots of signals being received by the process it will quit
	 * send them all in one quick burst, not paying attention to
	 * the intended function of sending them slowly over half a
	 * minute or so
	 */
	for (timo = 4000; timo <= 14000; timo += 2000) {
		for (i = 0; i < nets; i++) {
			baddr.sin_addr = addrs[i];
			if (sendto(sock, outbuf, outlen, 0,
			    (struct sockaddr *)&baddr,
			    sizeof (struct sockaddr)) != outlen) {
				stat = RPC_CANTSEND;
				goto done_broad;
			}
		}
		if (eachresult == NULL) {
			stat = RPC_SUCCESS;
			goto done_broad;
		}
	recv_again:
		msg.acpted_rply.ar_verf = _null_auth;
		msg.acpted_rply.ar_results.where = (caddr_t)&r;
		msg.acpted_rply.ar_results.proc = xdr_rmtcallres;

		switch (poll(pfd, 1, timo)) {
		case 0:  /* timed out */
			stat = RPC_TIMEDOUT;
			continue;
		case 1:
			if (pfd[0].revents & POLLNVAL)
				errno = EBADF;
			else if (pfd[0].revents & POLLERR)
				errno = EIO;
			else
				break;
			/* FALLTHROUGH */
		case -1:  /* some kind of error */
			if (errno == EINTR)
				goto recv_again;
			stat = RPC_CANTRECV;
			goto done_broad;
		}
	try_again:
		fromlen = sizeof(struct sockaddr);
		inlen = recvfrom(sock, inbuf, UDPMSGSIZE, 0,
		    (struct sockaddr *)&raddr, &fromlen);
		if (inlen < 0) {
			if (errno == EINTR)
				goto try_again;
			stat = RPC_CANTRECV;
			goto done_broad;
		}
		if (inlen < sizeof(u_int32_t))
			goto recv_again;
		/*
		 * see if reply transaction id matches sent id.
		 * If so, decode the results.
		 */
		xdrmem_create(xdrs, inbuf, (u_int)inlen, XDR_DECODE);
		if (xdr_replymsg(xdrs, &msg)) {
			if ((msg.rm_xid == xid) &&
			    (msg.rm_reply.rp_stat == MSG_ACCEPTED) &&
			    (msg.acpted_rply.ar_stat == SUCCESS)) {
				raddr.sin_port = htons((u_short)port);
				done = (*eachresult)(resultsp, &raddr);
			}
			/* otherwise, we just ignore the errors ... */
		}
		xdrs->x_op = XDR_FREE;
		msg.acpted_rply.ar_results.proc = xdr_void;
		(void)xdr_replymsg(xdrs, &msg);
		(void)(*xresults)(xdrs, resultsp);
		xdr_destroy(xdrs);
		if (done) {
			stat = RPC_SUCCESS;
			goto done_broad;
		} else {
			goto recv_again;
		}
	}
done_broad:
	free(addrs);
	if (sock >= 0)
		(void)close(sock);
	if (unix_auth != NULL)
		AUTH_DESTROY(unix_auth);
	return (stat);
}
@


1.33
log
@Wrap <rpc/*.h> so that calls go direct and the symbols are all weak.
Hide __xprt_register() and _authenticate(); truncate <rpc/svc_auth.h>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_rmt.c,v 1.32 2015/08/20 21:49:29 deraadt Exp $ */
d376 1
a376 2
	if (addrs)
		free(addrs);
@


1.32
log
@All these files include <stdlib.h>, so do not need to cast
malloc/calloc/realloc* returns.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_rmt.c,v 1.31 2014/11/11 04:51:49 guenther Exp $ */
d127 1
d146 1
@


1.31
log
@Merge from NetBSD from 1999-03-25:"
 * don't close the socket unless it was opened by the function
 * note (in the comments) that the client is responsible for closing
  the socket if they opened it, or they didn't use CLNT_DESTROY()

  fixes a couple of unnecessary closing of already-closed sockets.
  noted by: Matthias Drochner <M.Drochner@@fz-juelich.de>"

tested by many in snaps
ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_rmt.c,v 1.30 2013/11/12 06:59:12 deraadt Exp $ */
d174 1
a174 1
	addrs = (struct in_addr *)calloc(n, sizeof(*addrs));
@


1.30
log
@insert the proper arguments into a prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_rmt.c,v 1.29 2010/09/01 14:43:34 millert Exp $ */
a93 2
	if (sock != -1)
		(void)close(sock);
@


1.29
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_rmt.c,v 1.28 2007/09/02 15:19:17 deraadt Exp $ */
d199 1
a199 1
typedef bool_t (*resultproc_t)();
@


1.28
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 2
a2 1
/*	$OpenBSD: pmap_rmt.c,v 1.27 2006/09/22 18:42:04 otto Exp $ */
d4 28
a31 26
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a37 2
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
@


1.27
log
@Check return value of authunix_create_default(); from bret lambert
with some guidance by me; ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_rmt.c,v 1.26 2006/03/31 17:31:59 deraadt Exp $ */
d175 1
a175 1
	addrs = (struct in_addr *)malloc(n * sizeof(*addrs));
@


1.26
log
@internal API newgetbroadcastnets() does not need a sock
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_rmt.c,v 1.25 2005/08/08 08:05:35 espie Exp $ */
d211 1
a211 1
	AUTH *unix_auth = authunix_create_default();
d231 5
d379 2
a380 1
	AUTH_DESTROY(unix_auth);
@


1.25
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a152 1

d154 1
a154 2
newgetbroadcastnets(struct in_addr **addrsp,
	int sock)	/* any valid socket will do */
d249 1
a249 1
	nets = newgetbroadcastnets(&addrs, sock);
@


1.24
log
@ansify. ok deraadt@@ jaredy@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.23 2005/01/08 19:17:39 krw Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.23
log
@Bit of KNF - replace (<type> *)0 and (<type> *)NULL with NULL. Pointed
out by mickey@@, seconded by millert@@.

ok deraadt@@.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.22 2004/12/17 03:24:20 krw Exp $";
d69 3
a71 7
pmap_rmtcall(addr, prog, vers, proc, xdrargs, argsp, xdrres, resp, tout, port_ptr)
	struct sockaddr_in *addr;
	u_long prog, vers, proc;
	xdrproc_t xdrargs, xdrres;
	caddr_t argsp, resp;
	struct timeval tout;
	u_long *port_ptr;
d108 1
a108 3
xdr_rmtcall_args(xdrs, cap)
	XDR *xdrs;
	struct rmtcallargs *cap;
d137 1
a137 3
xdr_rmtcallres(xdrs, crp)
	XDR *xdrs;
	struct rmtcallres *crp;
d158 2
a159 3
newgetbroadcastnets(addrsp, sock)
	struct in_addr **addrsp;
	int sock;  /* any valid socket will do */
d206 8
a213 9
clnt_broadcast(prog, vers, proc, xargs, argsp, xresults, resultsp, eachresult)
	u_long		prog;		/* program number */
	u_long		vers;		/* version number */
	u_long		proc;		/* procedure number */
	xdrproc_t	xargs;		/* xdr routine for args */
	caddr_t		argsp;		/* pointer to args */
	xdrproc_t	xresults;	/* xdr routine for results */
	caddr_t		resultsp;	/* pointer to results */
	resultproc_t	eachresult;	/* call with each result obtained */
@


1.22
log
@Ensure that 'addrs' is always initialized before use (from Yamamoto
Takashi).

If no broadcast networks are found then just return RPC_CANTSEND.

Eliminate perror() calls (suggested by Yamamoto Takashi and seconded
by deraadt@@, otto@@ and millert@@) and just let return values speak.

ok millert@@
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.21 2003/12/31 03:27:23 millert Exp $";
d85 1
a85 1
	if (client != (CLIENT *)NULL) {
@


1.21
log
@Implement svc_getreq_poll(3) and friends and use poll(2) instead of select(2)
in the libc rpc code.  The main difference between this and the previous
version is the use of a simple free list that simplifies the logic when
adding a socket to svc_pollfd.  I've also added code to pack svc_pollfd
when the free list gets too big.  The idea general idea is to keep
svc_pollfd as tightly packed as possible to make poll(2) efficient.
Tested by many people and OK deraadt@@
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.20 2002/09/06 18:35:12 deraadt Exp $";
d175 1
a175 2
	if (getifaddrs(&ifap) != 0) {
		perror("broadcast: getifaddrs");
a176 1
	}
a191 1
		*addrsp = NULL;
d239 1
a239 1
	struct in_addr *addrs;
a250 1
		perror("Cannot create socket for broadcast rpc");
a255 1
		perror("Cannot set socket option SO_BROADCAST");
d265 5
a314 1
				perror("Cannot send broadcast packet");
a342 1
			perror("Broadcast poll problem");
a352 1
			perror("Cannot receive reply to broadcast");
@


1.20
log
@use socklen_t where needed; henning pvalchev ok
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.19 2001/09/15 13:51:01 deraadt Exp $";
d236 1
a236 1
	fd_set *fds = NULL, readfds;
d238 1
a246 1
	struct timeval t; 
d266 2
a267 12
	if (sock+1 > FD_SETSIZE) {
		int bytes = howmany(sock+1, NFDBITS) * sizeof(fd_mask);
		fds = (fd_set *)malloc(bytes);
		if (fds == NULL) {
			stat = RPC_CANTSEND;
			goto done_broad;
		}
		memset(fds, 0, bytes);
	} else {
		fds = &readfds;
		FD_ZERO(fds);
	}
a274 1
	(void)gettimeofday(&t, (struct timezone *)0);
a275 1
	t.tv_usec = 0;
d309 1
a309 1
	for (t.tv_sec = 4; t.tv_sec <= 14; t.tv_sec += 2) {
d329 1
a329 3
		/* XXX we know the other bits are still clear */
		FD_SET(sock, fds);
		switch (select(sock+1, fds, NULL, NULL, &t)) {
d333 8
d344 1
a344 1
			perror("Broadcast select problem");
a389 2
	if (fds != &readfds)
		free(fds);
@


1.19
log
@prototype cleanup
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.18 2000/08/24 17:03:15 deraadt Exp $";
d232 2
a233 1
	int outlen, inlen, fromlen, nets;
@


1.18
log
@uninit variables
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.17 2000/05/19 17:33:42 itojun Exp $";
d78 1
a78 1
	register CLIENT *client;
d113 2
a114 2
	register XDR *xdrs;
	register struct rmtcallargs *cap;
d144 2
a145 2
	register XDR *xdrs;
	register struct rmtcallres *crp;
d231 1
a231 1
	register XDR *xdrs = &xdr_stream;
d233 1
a233 1
	register int sock = -1;
d236 1
a236 1
	register int i;
d238 1
a238 1
	register u_long xid;
@


1.17
log
@use getifaddrs(3) instead of SIOCGIFCONF, to avoid alignment issues.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.16 1998/08/14 21:39:37 deraadt Exp $";
d235 1
a235 1
	fd_set *fds, readfds;
@


1.16
log
@realloc repair
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.15 1997/07/09 03:05:05 deraadt Exp $";
d55 1
d170 1
a170 3
	char *inbuf = NULL, *ninbuf;
	struct ifconf ifc;
	struct ifreq ifreq, *ifr;
a171 2
	char *cp, *cplim;
	int inbuflen = 256;
d173 1
a173 1
	int i = 0;
d175 13
a187 13
	while (1) {
		ifc.ifc_len = inbuflen;
		ninbuf = realloc(inbuf, inbuflen);
		if (ninbuf == NULL) {
			if (inbuf)
				free(inbuf);
			return (0);
		}
		ifc.ifc_buf = inbuf = ninbuf;
		if (ioctl(sock, SIOCGIFCONF, (char *)&ifc) < 0) {
			perror("broadcast: ioctl (get interface configuration)");
			free(inbuf);
			return (0);
a188 3
		if (ifc.ifc_len + sizeof(ifreq) < inbuflen)
			break;
		inbuflen *= 2;
d190 2
a191 1
	addrs = (struct in_addr *)malloc((inbuflen / sizeof *sin) * sizeof sin);
d193 1
d195 1
a195 2
		free(inbuf);
		return (0);
d198 2
a199 11
#define max(a, b) (a > b ? a : b)
#define size(p)	max((p).sa_len, sizeof(p))
	cplim = inbuf + ifc.ifc_len; /*skip over if's with big ifr_addr's */
	for (cp = inbuf; cp < cplim;
	    cp += sizeof (ifr->ifr_name) + size(ifr->ifr_addr)) {
		ifr = (struct ifreq *)cp;
		if (ifr->ifr_addr.sa_family != AF_INET)
			continue;
		ifreq = *ifr;
		if (ioctl(sock, SIOCGIFFLAGS, (char *)&ifreq) < 0) {
			perror("broadcast: ioctl (get interface flags)");
d201 6
a206 12
		}
		if ((ifreq.ifr_flags & IFF_BROADCAST) &&
		    (ifreq.ifr_flags & IFF_UP)) {
			sin = (struct sockaddr_in *)&ifr->ifr_addr;
			if (ioctl(sock, SIOCGIFBRDADDR, (char *)&ifreq) < 0) {
				addrs[i++] =
				    inet_makeaddr(inet_netof(sin->sin_addr),
				    INADDR_ANY);
			} else {
				addrs[i++] = ((struct sockaddr_in*)
				  &ifreq.ifr_addr)->sin_addr;
			}
d209 2
a210 1
	free(inbuf);
d212 1
a212 1
	return (i);
@


1.15
log
@avoid close(closed_socket) or close(-1); it looks disgusting in kdump
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.14 1997/01/22 18:50:41 deraadt Exp $";
d169 1
a169 1
	char *inbuf = NULL;
d180 4
a183 2
		ifc.ifc_buf = inbuf = realloc(inbuf, inbuflen);
		if (inbuf == NULL)
d185 2
@


1.14
log
@handle SIOCGIFCONF for as many interfaces as provided
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.13 1997/01/02 09:21:07 deraadt Exp $";
d76 1
a76 1
	int socket = -1;
d83 1
a83 1
	client = clntudp_create(addr, PMAPPROG, PMAPVERS, timeout, &socket);
d99 2
a100 2
	if (socket != -1)
		(void)close(socket);
d248 1
a248 1
	register int sock;
a416 1

@


1.13
log
@use arc4random for xid generation
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.12 1996/12/10 07:46:43 deraadt Exp $";
d165 2
a166 2
getbroadcastnets(addrs, sock, buf)
	struct in_addr *addrs;
a167 1
	char *buf;  /* why allocxate more when we can use existing... */
d169 1
d171 1
a171 1
        struct ifreq ifreq, *ifr;
d173 25
a197 2
        char *cp, *cplim;
        int i = 0;
a198 6
        ifc.ifc_len = UDPMSGSIZE;
        ifc.ifc_buf = buf;
        if (ioctl(sock, SIOCGIFCONF, (char *)&ifc) < 0) {
                perror("broadcast: ioctl (get interface configuration)");
                return (0);
        }
d201 2
a202 2
	cplim = buf + ifc.ifc_len; /*skip over if's with big ifr_addr's */
	for (cp = buf; cp < cplim;
d208 5
a212 5
                if (ioctl(sock, SIOCGIFFLAGS, (char *)&ifreq) < 0) {
                        perror("broadcast: ioctl (get interface flags)");
                        continue;
                }
                if ((ifreq.ifr_flags & IFF_BROADCAST) &&
d225 2
d255 1
a255 1
	struct in_addr addrs[20];
d293 1
a293 1
	nets = getbroadcastnets(addrs, sock, inbuf);
d353 1
a353 1
                msg.acpted_rply.ar_results.proc = xdr_rmtcallres;
d408 2
@


1.12
log
@avoid close(-1) cases
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.11 1996/11/14 06:23:50 etheisen Exp $";
a242 4
	static u_int32_t disrupt;

	if (disrupt == 0)
		disrupt = (u_int32_t)(long)resultsp;
d281 1
a281 1
	msg.rm_xid = xid = (++disrupt) ^ getpid() ^ t.tv_sec ^ t.tv_usec;
@


1.11
log
@More Alpha casts.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.10 1996/09/15 09:31:37 tholo Exp $";
d99 2
a100 1
	(void)close(socket);
@


1.10
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.9 1996/09/02 05:01:14 deraadt Exp $";
d245 1
a245 1
		disrupt = (u_int32_t)resultsp;
@


1.9
log
@perturb xid further. confuse the world
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.8 1996/08/20 23:47:42 deraadt Exp $";
d48 1
@


1.8
log
@memset 0; also fix for byte order botch in __svc_fdset handling; thanks to mw@@openbsd.org
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.7 1996/08/19 08:31:42 tholo Exp $";
d241 4
d283 1
a283 1
	msg.rm_xid = xid = getpid() ^ t.tv_sec ^ t.tv_usec;
@


1.7
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.6 1996/08/15 07:27:49 deraadt Exp $";
d260 2
a261 1
		fds = (fd_set *)malloc(howmany(sock+1, NBBY));
d266 1
a266 1
		memset(fds, '\0', howmany(sock+1, NBBY));
@


1.6
log
@support descriptors > FD_SETSIZE and correct timeout handling
@
text
@a0 3
/*	$OpenBSD: pmap_rmt.c,v 1.5 1996/08/10 05:12:09 deraadt Exp $	*/
/*	$NetBSD: pmap_rmt.c,v 1.6 1995/06/03 22:37:25 mycroft Exp $	*/

d31 2
a32 4
/*static char *sccsid = "from: @@(#)pmap_rmt.c 1.21 87/08/27 Copyr 1984 Sun Micro";*/
/*static char *sccsid = "from: @@(#)pmap_rmt.c	2.2 88/08/01 4.0 RPCSRC";*/
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.5 1996/08/10 05:12:09 deraadt Exp $";
#endif
@


1.5
log
@idle cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_rmt.c,v 1.4 1996/08/10 04:31:23 deraadt Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.4 1996/08/10 04:31:23 deraadt Exp $";
d189 1
a189 1
			cp += sizeof (ifr->ifr_name) + size(ifr->ifr_addr)) {
a200 1
#ifdef SIOCGIFBRDADDR   /* 4.3BSD */
a208 4
#else /* 4.2 BSD */
			addrs[i++] = inet_makeaddr(inet_netof(sin->sin_addr),
			    INADDR_ANY);
#endif
d234 1
a234 2
	fd_set mask;
	fd_set readfds;
d263 13
a275 2
	FD_ZERO(&mask);
	FD_SET(sock, &mask);
d311 6
a336 2
		readfds = mask;
		switch (select(sock+1, &readfds, NULL, NULL, &t)) {
d338 3
a343 1

d350 1
a350 2

		}  /* end of select results switch */
d391 4
a394 1
	(void)close(sock);
@


1.4
log
@idle cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_rmt.c,v 1.3 1996/07/20 06:12:35 deraadt Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.3 1996/07/20 06:12:35 deraadt Exp $";
d296 1
a296 1
	if ((! xdr_callmsg(xdrs, &msg)) || (! xdr_rmtcall_args(xdrs, &a))) {
d302 1
d344 1
a344 1
			(struct sockaddr *)&raddr, &fromlen);
@


1.3
log
@bcopy->memcpy & tag
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_rmt.c,v 1.6 1995/06/03 22:37:25 mycroft Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: pmap_rmt.c,v 1.6 1995/06/03 22:37:25 mycroft Exp $";
a276 1
/*	baddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY); */
d310 2
a311 2
				(struct sockaddr *)&baddr,
				sizeof (struct sockaddr)) != outlen) {
d360 2
a361 2
				(msg.rm_reply.rp_stat == MSG_ACCEPTED) &&
				(msg.acpted_rply.ar_stat == SUCCESS)) {
a365 7
		} else {
#ifdef notdef
			/* some kind of deserialization problem ... */
			if (msg.rm_xid == xid)
				fprintf(stderr, "Broadcast deserialization problem");
			/* otherwise, just random garbage */
#endif
@


1.2
log
@Pull prototypes into scope
Remove graticious casts
@
text
@d1 1
d36 1
a36 1
static char *rcsid = "$NetBSD: pmap_rmt.c,v 1.6 1995/06/03 22:37:25 mycroft Exp $";
@


1.1
log
@Initial revision
@
text
@d52 1
d176 1
a176 1
        int n, i = 0;
d326 1
a326 2
		switch (select(sock+1, &readfds, (int *)NULL, 
			       (int *)NULL, &t)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
