head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.8
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.18
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.16
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.12
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.10
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.8
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.6
	OPENBSD_5_0:1.25.0.4
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.21.0.14
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.12
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.10
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.8
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.6
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.8
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.11.0.8
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2015.10.05.01.23.17;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	dHXSEU00or35aoES;

1.28
date	2015.09.13.15.36.56;	author guenther;	state Exp;
branches;
next	1.27;
commitid	FxNpAvmgpSFQVav0;

1.27
date	2015.08.20.21.49.29;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	jeIpGH0zlTW3huPH;

1.26
date	2014.10.08.05.29.07;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	ZP2GVeWXsou2vO0h;

1.25
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.14.23.57.22;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.11.22.03.08;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.05.20.23.38;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.21.01.40.22;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.08.08.05.35;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.01.07.44.04;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.17.02.37.21;	author jolan;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.08.19.17.39;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.31.03.27.23;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.24;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.15.13.51.01;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.03.06.50.28;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.11.23.22.37.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.02.25.12.21.18;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.09.22.05.11.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.03.29.05.55.06;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.15.09.31.38;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.08.20.23.47.43;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.19.08.31.51;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.08.15.07.27.49;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.20.06.12.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.12.15.31;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.04.12.57.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@user land -> userland; from Rob Pierce
@
text
@/*	$OpenBSD: svc.c,v 1.28 2015/09/13 15:36:56 guenther Exp $ */

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * svc.c, Server-side remote procedure call interface.
 *
 * There are two sets of procedures here.  The xprt routines are
 * for handling transport handles.  The svc routines handle the
 * list of service routines.
 */

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include <rpc/rpc.h>
#include <rpc/pmap_clnt.h>

static SVCXPRT **xports;
static int xportssize;

#define	RQCRED_SIZE	400		/* this size is excessive */

#define max(a, b) (a > b ? a : b)

/*
 * The services list
 * Each entry represents a set of procedures (an rpc program).
 * The dispatch routine takes request structs and runs the
 * appropriate procedure.
 */
static struct svc_callout {
	struct svc_callout *sc_next;
	u_long		    sc_prog;
	u_long		    sc_vers;
	void		    (*sc_dispatch)();
} *svc_head;

static struct svc_callout *svc_find(u_long, u_long, struct svc_callout **);
static int svc_fd_insert(int);
static int svc_fd_remove(int);

int __svc_fdsetsize = FD_SETSIZE;
fd_set *__svc_fdset = &svc_fdset;
static int svc_pollfd_size;		/* number of slots in svc_pollfd */
static int svc_used_pollfd;		/* number of used slots in svc_pollfd */
static int *svc_pollfd_freelist;	/* svc_pollfd free list */
static int svc_max_free;		/* number of used slots in free list */

/* ***************  SVCXPRT related stuff **************** */

/*
 * Activate a transport handle.
 */
void
xprt_register(SVCXPRT *xprt)
{
	/* ignore failure conditions */
	(void) __xprt_register(xprt);
}

/*
 * Activate a transport handle.
 */
int
__xprt_register(SVCXPRT *xprt)
{
	int sock = xprt->xp_sock;

	if (xports == NULL || sock + 1 > xportssize) {
		SVCXPRT **xp;
		int size = FD_SETSIZE;

		while (sock + 1 > size)
			size += FD_SETSIZE;
		xp = calloc(size, sizeof(SVCXPRT *));
		if (xp == NULL)
			return (0);
		if (xports) {
			memcpy(xp, xports, xportssize * sizeof(SVCXPRT *));
			free(xports);
		}
		xportssize = size;
		xports = xp;
	}

	if (!svc_fd_insert(sock))
		return (0);
	xports[sock] = xprt;

	return (1);
}

/*
 * Insert a socket into svc_pollfd, svc_fdset and __svc_fdset.
 * If we are out of space, we allocate ~128 more slots than we
 * need now for future expansion.
 * We try to keep svc_pollfd well packed (no holes) as possible
 * so that poll(2) is efficient.
 */
static int
svc_fd_insert(int sock)
{
	int slot;

	/*
	 * Find a slot for sock in svc_pollfd; four possible cases:
	 *  1) need to allocate more space for svc_pollfd
	 *  2) there is an entry on the free list
	 *  3) the free list is empty (svc_used_pollfd is the next slot)
	 */
	if (svc_pollfd == NULL || svc_used_pollfd == svc_pollfd_size) {
		struct pollfd *pfd;
		int new_size, *new_freelist;

		new_size = svc_pollfd ? svc_pollfd_size + 128 : FD_SETSIZE;
		pfd = reallocarray(svc_pollfd, new_size, sizeof(*svc_pollfd));
		if (pfd == NULL)
			return (0);			/* no changes */
		new_freelist = realloc(svc_pollfd_freelist, new_size / 2);
		if (new_freelist == NULL) {
			free(pfd);
			return (0);			/* no changes */
		}
		svc_pollfd = pfd;
		svc_pollfd_size = new_size;
		svc_pollfd_freelist = new_freelist;
		for (slot = svc_used_pollfd; slot < svc_pollfd_size; slot++) {
			svc_pollfd[slot].fd = -1;
			svc_pollfd[slot].events = svc_pollfd[slot].revents = 0;
		}
		slot = svc_used_pollfd;
	} else if (svc_max_free != 0) {
		/* there is an entry on the free list, use it */
		slot = svc_pollfd_freelist[--svc_max_free];
	} else {
		/* nothing on the free list but we have room to grow */
		slot = svc_used_pollfd;
	}
	if (sock + 1 > __svc_fdsetsize) {
		fd_set *fds;
		size_t bytes;

		bytes = howmany(sock + 128, NFDBITS) * sizeof(fd_mask);
		/* realloc() would be nicer but it gets tricky... */
		if ((fds = (fd_set *)mem_alloc(bytes)) != NULL) {
			memset(fds, 0, bytes);
			memcpy(fds, __svc_fdset,
			    howmany(__svc_fdsetsize, NFDBITS) * sizeof(fd_mask));
			if (__svc_fdset != &svc_fdset)
				free(__svc_fdset);
			__svc_fdset = fds;
			__svc_fdsetsize = bytes / sizeof(fd_mask) * NFDBITS;
		}
	}

	svc_pollfd[slot].fd = sock;
	svc_pollfd[slot].events = POLLIN;
	svc_used_pollfd++;
	if (svc_max_pollfd < slot + 1)
		svc_max_pollfd = slot + 1;
	if (sock < FD_SETSIZE)
		FD_SET(sock, &svc_fdset);
	if (sock < __svc_fdsetsize && __svc_fdset != &svc_fdset)
		FD_SET(sock, __svc_fdset);
	svc_maxfd = max(svc_maxfd, sock);

	return (1);
}

/*
 * Remove a socket from svc_pollfd, svc_fdset and __svc_fdset.
 * Freed slots are placed on the free list.  If the free list fills
 * up, we compact svc_pollfd (free list size == svc_pollfd_size /2).
 */
static int
svc_fd_remove(int sock)
{
	int slot;

	if (svc_pollfd == NULL)
		return (0);

	for (slot = 0; slot < svc_max_pollfd; slot++) {
		if (svc_pollfd[slot].fd == sock) {
			svc_pollfd[slot].fd = -1;
			svc_pollfd[slot].events = svc_pollfd[slot].revents = 0;
			svc_used_pollfd--;
			if (sock < FD_SETSIZE)
				FD_CLR(sock, &svc_fdset);
			if (sock < __svc_fdsetsize && __svc_fdset != &svc_fdset)
				FD_CLR(sock, __svc_fdset);
			if (sock == svc_maxfd) {
				for (svc_maxfd--; svc_maxfd >= 0; svc_maxfd--)
					if (xports[svc_maxfd])
						break;
			}
			if (svc_max_free == svc_pollfd_size / 2) {
				int i, j;

				/*
				 * Out of space in the free list; this means
				 * that svc_pollfd is half full.  Pack things
				 * such that svc_max_pollfd == svc_used_pollfd
				 * and svc_pollfd_freelist is empty.
				 */
				for (i = svc_used_pollfd, j = 0;
				    i < svc_max_pollfd && j < svc_max_free; i++) {
					if (svc_pollfd[i].fd == -1)
						continue;
					/* be sure to use a low-numbered slot */
					while (svc_pollfd_freelist[j] >=
					    svc_used_pollfd)
						j++;
					svc_pollfd[svc_pollfd_freelist[j++]] =
					    svc_pollfd[i];
					svc_pollfd[i].fd = -1;
					svc_pollfd[i].events =
					    svc_pollfd[i].revents = 0;
				}
				svc_max_pollfd = svc_used_pollfd;
				svc_max_free = 0;
				/* could realloc if svc_pollfd_size is big */
			} else {
				/* trim svc_max_pollfd from the end */
				while (svc_max_pollfd > 0 &&
				    svc_pollfd[svc_max_pollfd - 1].fd == -1)
					svc_max_pollfd--;
			}
			svc_pollfd_freelist[svc_max_free++] = slot;

			return (1);
		}
	}
	return (0);		/* not found, shouldn't happen */
}

/*
 * De-activate a transport handle. 
 */
void
xprt_unregister(SVCXPRT *xprt)
{ 
	int sock = xprt->xp_sock;

	if (xports[sock] == xprt) {
		xports[sock] = NULL;
		svc_fd_remove(sock);
	}
}
DEF_WEAK(xprt_unregister);


/* ********************** CALLOUT list related stuff ************* */

/*
 * Add a service program to the callout list.
 * The dispatch routine will be called when a rpc request for this
 * program number comes in.
 */
bool_t
svc_register(SVCXPRT *xprt, u_long prog, u_long vers, void (*dispatch)(),
    int protocol)
{
	struct svc_callout *prev;
	struct svc_callout *s;

	if ((s = svc_find(prog, vers, &prev)) != NULL) {
		if (s->sc_dispatch == dispatch)
			goto pmap_it;  /* he is registering another xptr */
		return (FALSE);
	}
	s = (struct svc_callout *)mem_alloc(sizeof(struct svc_callout));
	if (s == NULL) {
		return (FALSE);
	}
	s->sc_prog = prog;
	s->sc_vers = vers;
	s->sc_dispatch = dispatch;
	s->sc_next = svc_head;
	svc_head = s;
pmap_it:
	/* now register the information with the local binder service */
	if (protocol) {
		return (pmap_set(prog, vers, protocol, xprt->xp_port));
	}
	return (TRUE);
}
DEF_WEAK(svc_register);

/*
 * Remove a service program from the callout list.
 */
void
svc_unregister(u_long prog, u_long vers)
{
	struct svc_callout *prev;
	struct svc_callout *s;

	if ((s = svc_find(prog, vers, &prev)) == NULL)
		return;
	if (prev == NULL) {
		svc_head = s->sc_next;
	} else {
		prev->sc_next = s->sc_next;
	}
	s->sc_next = NULL;
	mem_free((char *) s, (u_int) sizeof(struct svc_callout));
	/* now unregister the information with the local binder service */
	(void)pmap_unset(prog, vers);
}

/*
 * Search the callout list for a program number, return the callout
 * struct.
 */
static struct svc_callout *
svc_find(u_long prog, u_long vers, struct svc_callout **prev)
{
	struct svc_callout *s, *p;

	p = NULL;
	for (s = svc_head; s != NULL; s = s->sc_next) {
		if ((s->sc_prog == prog) && (s->sc_vers == vers))
			goto done;
		p = s;
	}
done:
	*prev = p;
	return (s);
}

/* ******************* REPLY GENERATION ROUTINES  ************ */

/*
 * Send a reply to an rpc request
 */
bool_t
svc_sendreply(SVCXPRT *xprt, xdrproc_t xdr_results, caddr_t xdr_location)
{
	struct rpc_msg rply; 

	rply.rm_direction = REPLY;
	rply.rm_reply.rp_stat = MSG_ACCEPTED; 
	rply.acpted_rply.ar_verf = xprt->xp_verf; 
	rply.acpted_rply.ar_stat = SUCCESS;
	rply.acpted_rply.ar_results.where = xdr_location;
	rply.acpted_rply.ar_results.proc = xdr_results;
	return (SVC_REPLY(xprt, &rply)); 
}
DEF_WEAK(svc_sendreply);

/*
 * No procedure error reply
 */
void
svcerr_noproc(SVCXPRT *xprt)
{
	struct rpc_msg rply;

	rply.rm_direction = REPLY;
	rply.rm_reply.rp_stat = MSG_ACCEPTED;
	rply.acpted_rply.ar_verf = xprt->xp_verf;
	rply.acpted_rply.ar_stat = PROC_UNAVAIL;
	SVC_REPLY(xprt, &rply);
}

/*
 * Can't decode args error reply
 */
void
svcerr_decode(SVCXPRT *xprt)
{
	struct rpc_msg rply; 

	rply.rm_direction = REPLY; 
	rply.rm_reply.rp_stat = MSG_ACCEPTED; 
	rply.acpted_rply.ar_verf = xprt->xp_verf;
	rply.acpted_rply.ar_stat = GARBAGE_ARGS;
	SVC_REPLY(xprt, &rply); 
}
DEF_WEAK(svcerr_decode);

/*
 * Some system error
 */
void
svcerr_systemerr(SVCXPRT *xprt)
{
	struct rpc_msg rply; 

	rply.rm_direction = REPLY; 
	rply.rm_reply.rp_stat = MSG_ACCEPTED; 
	rply.acpted_rply.ar_verf = xprt->xp_verf;
	rply.acpted_rply.ar_stat = SYSTEM_ERR;
	SVC_REPLY(xprt, &rply); 
}

/*
 * Authentication error reply
 */
void
svcerr_auth(SVCXPRT *xprt, enum auth_stat why)
{
	struct rpc_msg rply;

	rply.rm_direction = REPLY;
	rply.rm_reply.rp_stat = MSG_DENIED;
	rply.rjcted_rply.rj_stat = AUTH_ERROR;
	rply.rjcted_rply.rj_why = why;
	SVC_REPLY(xprt, &rply);
}
DEF_WEAK(svcerr_auth);

/*
 * Auth too weak error reply
 */
void
svcerr_weakauth(SVCXPRT *xprt)
{

	svcerr_auth(xprt, AUTH_TOOWEAK);
}

/*
 * Program unavailable error reply
 */
void 
svcerr_noprog(SVCXPRT *xprt)
{
	struct rpc_msg rply;

	rply.rm_direction = REPLY;
	rply.rm_reply.rp_stat = MSG_ACCEPTED;
	rply.acpted_rply.ar_verf = xprt->xp_verf;
	rply.acpted_rply.ar_stat = PROG_UNAVAIL;
	SVC_REPLY(xprt, &rply);
}
DEF_WEAK(svcerr_noprog);

/*
 * Program version mismatch error reply
 */
void
svcerr_progvers(SVCXPRT *xprt, u_long low_vers, u_long high_vers)
{
	struct rpc_msg rply;

	rply.rm_direction = REPLY;
	rply.rm_reply.rp_stat = MSG_ACCEPTED;
	rply.acpted_rply.ar_verf = xprt->xp_verf;
	rply.acpted_rply.ar_stat = PROG_MISMATCH;
	rply.acpted_rply.ar_vers.low = low_vers;
	rply.acpted_rply.ar_vers.high = high_vers;
	SVC_REPLY(xprt, &rply);
}
DEF_WEAK(svcerr_progvers);

/* ******************* SERVER INPUT STUFF ******************* */

/*
 * Get server side input from some transport.
 *
 * Statement of authentication parameters management:
 * This function owns and manages all authentication parameters, specifically
 * the "raw" parameters (msg.rm_call.cb_cred and msg.rm_call.cb_verf) and
 * the "cooked" credentials (rqst->rq_clntcred).
 * However, this function does not know the structure of the cooked
 * credentials, so it make the following assumptions: 
 *   a) the structure is contiguous (no pointers), and
 *   b) the cred structure size does not exceed RQCRED_SIZE bytes. 
 * In all events, all three parameters are freed upon exit from this routine.
 * The storage is trivially management on the call stack in userland, but
 * is mallocated in kernel land.
 */

void
svc_getreq(int rdfds)
{
	int bit;

	for (; (bit = ffs(rdfds)); rdfds ^= (1 << (bit - 1)))
		svc_getreq_common(bit - 1);
}
DEF_WEAK(svc_getreq);

void
svc_getreqset(fd_set *readfds)
{
	svc_getreqset2(readfds, FD_SETSIZE);
}

void
svc_getreqset2(fd_set *readfds, int width)
{
	fd_mask mask, *maskp;
	int bit, sock;

	maskp = readfds->fds_bits;
	for (sock = 0; sock < width; sock += NFDBITS) {
		for (mask = *maskp++; (bit = ffs(mask));
		    mask ^= (1 << (bit - 1)))
			svc_getreq_common(sock + bit - 1);
	}
}
DEF_WEAK(svc_getreqset2);

void
svc_getreq_poll(struct pollfd *pfd, const int nready)
{
	int i, n;

	for (n = nready, i = 0; n > 0; i++) {
		if (pfd[i].fd == -1)
			continue;
		if (pfd[i].revents != 0)
			n--;
		if ((pfd[i].revents & (POLLIN | POLLHUP)) == 0)
			continue;
		svc_getreq_common(pfd[i].fd);
	}
}
DEF_WEAK(svc_getreq_poll);

void
svc_getreq_common(int fd)
{
	enum xprt_stat stat;
	struct rpc_msg msg;
	int prog_found;
	u_long low_vers;
	u_long high_vers;
	struct svc_req r;
	SVCXPRT *xprt;
	char cred_area[2*MAX_AUTH_BYTES + RQCRED_SIZE];

	msg.rm_call.cb_cred.oa_base = cred_area;
	msg.rm_call.cb_verf.oa_base = &(cred_area[MAX_AUTH_BYTES]);
	r.rq_clntcred = &(cred_area[2*MAX_AUTH_BYTES]);

	/* sock has input waiting */
	xprt = xports[fd];
	if (xprt == NULL)
		/* But do we control the fd? */
		return;
	/* now receive msgs from xprtprt (support batch calls) */
	do {
		if (SVC_RECV(xprt, &msg)) {
			/* find the exported program and call it */
			struct svc_callout *s;
			enum auth_stat why;

			r.rq_xprt = xprt;
			r.rq_prog = msg.rm_call.cb_prog;
			r.rq_vers = msg.rm_call.cb_vers;
			r.rq_proc = msg.rm_call.cb_proc;
			r.rq_cred = msg.rm_call.cb_cred;
			/* first authenticate the message */
			if ((why= _authenticate(&r, &msg)) != AUTH_OK) {
				svcerr_auth(xprt, why);
				goto call_done;
			}
			/* now match message with a registered service*/
			prog_found = FALSE;
			low_vers = (u_long) -1;
			high_vers = 0;
			for (s = svc_head; s != NULL; s = s->sc_next) {
				if (s->sc_prog == r.rq_prog) {
					if (s->sc_vers == r.rq_vers) {
						(*s->sc_dispatch)(&r, xprt);
						goto call_done;
					}  /* found correct version */
					prog_found = TRUE;
					if (s->sc_vers < low_vers)
						low_vers = s->sc_vers;
					if (s->sc_vers > high_vers)
						high_vers = s->sc_vers;
				}   /* found correct program */
			}
			/*
			 * if we got here, the program or version
			 * is not served ...
			 */
			if (prog_found)
				svcerr_progvers(xprt, low_vers, high_vers);
			else
				 svcerr_noprog(xprt);
			/* Fall through to ... */
		}
	call_done:
		if ((stat = SVC_STAT(xprt)) == XPRT_DIED){
			SVC_DESTROY(xprt);
			break;
		}
	} while (stat == XPRT_MOREREQS);
}
DEF_WEAK(svc_getreq_common);
@


1.28
log
@Wrap <rpc/*.h> so that calls go direct and the symbols are all weak.
Hide __xprt_register() and _authenticate(); truncate <rpc/svc_auth.h>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.c,v 1.27 2015/08/20 21:49:29 deraadt Exp $ */
d503 1
a503 1
 * The storage is trivially management on the call stack in user land, but
@


1.27
log
@All these files include <stdlib.h>, so do not need to cast
malloc/calloc/realloc* returns.
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.c,v 1.26 2014/10/08 05:29:07 deraadt Exp $ */
d281 1
d319 1
d381 1
d412 1
d443 1
d469 1
d487 1
d515 1
d536 1
d553 1
d627 1
@


1.26
log
@obvious conversion of realloc() to reallocarray().  Luckily this is
using pollfd, because if this was fd_set... it would not be obvious
(or easy)
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.c,v 1.25 2010/09/01 14:43:34 millert Exp $ */
d106 1
a106 1
		xp = (SVCXPRT **)calloc(size, sizeof(SVCXPRT *));
@


1.25
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.c,v 1.24 2009/12/14 23:57:22 schwarze Exp $ */
d147 1
a147 1
		pfd = realloc(svc_pollfd, sizeof(*svc_pollfd) * new_size);
@


1.24
log
@Keep all bits of __svc_fdset up to date, not just those beyond FD_SETSIZE.

Bug found while auditing the same complaint by parfait,
see the previous commit; still not shutting parfait up.

"wow, that's nasty" deraadt@@
@
text
@d1 2
a2 1
/*	$OpenBSD: svc.c,v 1.23 2009/12/11 22:03:08 schwarze Exp $ */
d4 28
a31 26
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a39 2
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
@


1.23
log
@__svc_fdsetsize is counted in bits, not in array elements

When exceeding fd 1024, this bug cleared flag bits for all file descriptors
except those <= 64.

Found while auditing a (false positive) complaint by parfait.
This bugfix does not shut parfait up, though.

OK millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.c,v 1.22 2009/06/05 20:23:38 deraadt Exp $ */
d193 1
a193 1
	else if (sock < __svc_fdsetsize)
d220 1
a220 1
			else if (sock < __svc_fdsetsize)
@


1.22
log
@use calloc() to provide size * nitems safety
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.c,v 1.21 2005/12/21 01:40:22 millert Exp $ */
d182 1
a182 1
			__svc_fdsetsize = bytes / sizeof(fd_mask);
@


1.21
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.c,v 1.20 2005/08/08 08:05:35 espie Exp $ */
d105 1
a105 1
		xp = (SVCXPRT **)mem_alloc(size * sizeof(SVCXPRT *));
a107 1
		memset(xp, 0, size * sizeof(SVCXPRT *));
@


1.20
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d41 1
a44 1
#include <sys/errno.h>
@


1.19
log
@ansify. ok deraadt@@ jaredy@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint) 
static char *rcsid = "$OpenBSD: svc.c,v 1.18 2005/02/17 02:37:21 jolan Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.18
log
@alyte spelling-in-comment fixes
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.17 2005/01/08 19:17:39 krw Exp $";
d88 1
a88 2
xprt_register(xprt)
	SVCXPRT *xprt;
d98 1
a98 2
__xprt_register(xprt)
	SVCXPRT *xprt;
d275 1
a275 2
xprt_unregister(xprt) 
	SVCXPRT *xprt;
d294 2
a295 6
svc_register(xprt, prog, vers, dispatch, protocol)
	SVCXPRT *xprt;
	u_long prog;
	u_long vers;
	void (*dispatch)();
	int protocol;
d326 1
a326 3
svc_unregister(prog, vers)
	u_long prog;
	u_long vers;
d349 1
a349 4
svc_find(prog, vers, prev)
	u_long prog;
	u_long vers;
	struct svc_callout **prev;
d370 1
a370 4
svc_sendreply(xprt, xdr_results, xdr_location)
	SVCXPRT *xprt;
	xdrproc_t xdr_results;
	caddr_t xdr_location;
d387 1
a387 2
svcerr_noproc(xprt)
	SVCXPRT *xprt;
d402 1
a402 2
svcerr_decode(xprt)
	SVCXPRT *xprt;
d417 1
a417 2
svcerr_systemerr(xprt)
	SVCXPRT *xprt;
d432 1
a432 3
svcerr_auth(xprt, why)
	SVCXPRT *xprt;
	enum auth_stat why;
d447 1
a447 2
svcerr_weakauth(xprt)
	SVCXPRT *xprt;
d457 1
a457 2
svcerr_noprog(xprt)
	SVCXPRT *xprt;
d472 1
a472 4
svcerr_progvers(xprt, low_vers, high_vers)
	SVCXPRT *xprt; 
	u_long low_vers;
	u_long high_vers;
d504 1
a504 2
svc_getreq(rdfds)
	int rdfds;
d513 1
a513 2
svc_getreqset(readfds)
	fd_set *readfds;
d519 1
a519 3
svc_getreqset2(readfds, width)
	fd_set *readfds;
	int width;
d533 1
a533 3
svc_getreq_poll(pfd, nready)
	struct pollfd *pfd;
	const int nready;
d549 1
a549 2
svc_getreq_common(fd)
	int fd;
@


1.17
log
@Bit of KNF - replace (<type> *)0 and (<type> *)NULL with NULL. Pointed
out by mickey@@, seconded by millert@@.

ok deraadt@@.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.16 2003/12/31 03:27:23 millert Exp $";
d62 1
a62 1
 * apropriate procedure.
@


1.16
log
@Implement svc_getreq_poll(3) and friends and use poll(2) instead of select(2)
in the libc rpc code.  The main difference between this and the previous
version is the use of a simple free list that simplifies the logic when
adding a socket to svc_pollfd.  I've also added code to pack svc_pollfd
when the free list gets too big.  The idea general idea is to keep
svc_pollfd as tightly packed as possible to make poll(2) efficient.
Tested by many people and OK deraadt@@
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.15 2002/02/16 21:27:24 millert Exp $";
a53 1
#define NULL_SVC ((struct svc_callout *)0)
d307 1
a307 1
	if ((s = svc_find(prog, vers, &prev)) != NULL_SVC) {
d313 1
a313 1
	if (s == (struct svc_callout *)0) {
d340 1
a340 1
	if ((s = svc_find(prog, vers, &prev)) == NULL_SVC)
d342 1
a342 1
	if (prev == NULL_SVC) {
d347 1
a347 1
	s->sc_next = NULL_SVC;
d365 2
a366 2
	p = NULL_SVC;
	for (s = svc_head; s != NULL_SVC; s = s->sc_next) {
d622 1
a622 1
			for (s = svc_head; s != NULL_SVC; s = s->sc_next) {
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.14 2001/09/15 13:51:01 deraadt Exp $";
d73 2
d76 6
a81 2
int __svc_fdsetsize;
fd_set *__svc_fdset;
d105 1
a105 22
	if (sock+1 > __svc_fdsetsize) {
		int bytes = howmany(sock+1, NFDBITS) * sizeof(fd_mask);
		fd_set *fds;

		fds = (fd_set *)malloc(bytes);
		if (fds == NULL)
			return (0);
		memset(fds, 0, bytes);
		if (__svc_fdset) {
			memcpy(fds, __svc_fdset, howmany(__svc_fdsetsize,
			    NFDBITS) * sizeof(fd_mask));
			free(__svc_fdset);
		}
		__svc_fdset = fds;
		__svc_fdsetsize = sock+1;
	}

	if (sock < FD_SETSIZE)
		FD_SET(sock, &svc_fdset);
	FD_SET(sock, __svc_fdset);

	if (xports == NULL || sock+1 > xportssize) {
d109 2
a110 2
		if (sock+1 > size)
			size = sock+1;
d122 3
d126 76
d203 1
d208 67
d284 2
a285 13
		xports[sock] = (SVCXPRT *)0;
		if (sock < FD_SETSIZE)
			FD_CLR(sock, &svc_fdset);
		FD_CLR(sock, __svc_fdset);
		if (sock == svc_maxfd) {
			for (svc_maxfd--; svc_maxfd>=0; svc_maxfd--)
				if (xports[svc_maxfd])
					break;
		}
		/*
		 * XXX could use svc_maxfd as a hint to
		 * decrease the size of __svc_fdset
		 */
d533 1
a533 1
	fd_set readfds;
d535 2
a536 3
	FD_ZERO(&readfds);
	readfds.fds_bits[0] = rdfds;
	svc_getreqset(&readfds);
a538 2
void	svc_getreqset2(fd_set *, int);

d551 33
a590 3
	int bit;
	fd_mask mask, *maskp;
	int sock;
d592 1
d597 21
a617 53
	maskp = readfds->fds_bits;
	for (sock = 0; sock < width; sock += NFDBITS) {
	    for (mask = *maskp++; (bit = ffs(mask)); mask ^= (1 << (bit - 1))) {
		/* sock has input waiting */
		xprt = xports[sock + bit - 1];
		if (xprt == NULL)
			/* But do we control sock? */
			continue;
		/* now receive msgs from xprtprt (support batch calls) */
		do {
			if (SVC_RECV(xprt, &msg)) {

				/* now find the exported program and call it */
				register struct svc_callout *s;
				enum auth_stat why;

				r.rq_xprt = xprt;
				r.rq_prog = msg.rm_call.cb_prog;
				r.rq_vers = msg.rm_call.cb_vers;
				r.rq_proc = msg.rm_call.cb_proc;
				r.rq_cred = msg.rm_call.cb_cred;
				/* first authenticate the message */
				if ((why= _authenticate(&r, &msg)) != AUTH_OK) {
					svcerr_auth(xprt, why);
					goto call_done;
				}
				/* now match message with a registered service*/
				prog_found = FALSE;
				low_vers = (u_long) -1;
				high_vers = 0;
				for (s = svc_head; s != NULL_SVC; s = s->sc_next) {
					if (s->sc_prog == r.rq_prog) {
						if (s->sc_vers == r.rq_vers) {
							(*s->sc_dispatch)(&r, xprt);
							goto call_done;
						}  /* found correct version */
						prog_found = TRUE;
						if (s->sc_vers < low_vers)
							low_vers = s->sc_vers;
						if (s->sc_vers > high_vers)
							high_vers = s->sc_vers;
					}   /* found correct program */
				}
				/*
				 * if we got here, the program or version
				 * is not served ...
				 */
				if (prog_found)
					svcerr_progvers(xprt,
					low_vers, high_vers);
				else
					 svcerr_noprog(xprt);
				/* Fall through to ... */
d619 16
a634 4
		call_done:
			if ((stat = SVC_STAT(xprt)) == XPRT_DIED){
				SVC_DESTROY(xprt);
				break;
d636 16
a651 3
		} while (stat == XPRT_MOREREQS);
	    }
	}
@


1.14
log
@prototype cleanup
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.13 2001/03/03 06:50:28 deraadt Exp $";
d419 1
a419 1
void	svc_getreqset2 __P((fd_set *, int));
@


1.13
log
@plug many memory leaks
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.12 1999/11/23 22:37:28 deraadt Exp $";
d72 1
a72 1
static struct svc_callout *svc_find();
d97 1
a97 1
	register int sock = xprt->xp_sock;
d149 1
a149 1
	register int sock = xprt->xp_sock;
d185 1
a185 1
	register struct svc_callout *s;
d218 1
a218 1
	register struct svc_callout *s;
d243 1
a243 1
	register struct svc_callout *s, *p;
d263 1
a263 1
	register SVCXPRT *xprt;
d283 1
a283 1
	register SVCXPRT *xprt;
d299 1
a299 1
	register SVCXPRT *xprt;
d315 1
a315 1
	register SVCXPRT *xprt;
d359 1
a359 1
	register SVCXPRT *xprt;
d375 1
a375 1
	register SVCXPRT *xprt; 
d439 4
a442 4
	register SVCXPRT *xprt;
	register int bit;
	register fd_mask mask, *maskp;
	register int sock;
@


1.12
log
@mark some places that malloc is not checked
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.11 1998/02/25 12:21:18 deraadt Exp $";
d86 11
d104 2
a105 1
		/* XXX */
d127 2
a128 1
		/* XXX */
d139 1
@


1.11
log
@__svc_fdsetsize is a max bitcount; like FDSETSIZE before it
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.10 1997/09/22 05:11:09 millert Exp $";
d93 1
d115 1
@


1.10
log
@Some -Wall.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.9 1997/03/29 05:55:06 deraadt Exp $";
d100 1
a100 1
		__svc_fdsetsize = howmany(sock+1, NFDBITS);
@


1.9
log
@delete extra spaces
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.8 1996/09/15 09:31:38 tholo Exp $";
d434 1
a434 1
	    for (mask = *maskp++; bit = ffs(mask); mask ^= (1 << (bit - 1))) {
@


1.8
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.7 1996/08/20 23:47:43 deraadt Exp $";
d253 1
a253 1
	rply.rm_direction = REPLY;  
d345 1
a345 1
	struct rpc_msg rply;  
d347 3
a349 3
	rply.rm_direction = REPLY;   
	rply.rm_reply.rp_stat = MSG_ACCEPTED;  
	rply.acpted_rply.ar_verf = xprt->xp_verf;  
d357 1
a357 1
void  
@


1.7
log
@memset 0; also fix for byte order botch in __svc_fdset handling; thanks to mw@@openbsd.org
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.6 1996/08/19 08:31:51 tholo Exp $";
d425 1
a425 1
	register u_int32_t mask, *maskp;
d460 1
a460 1
				low_vers = 0 - 1;
@


1.6
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc.c,v 1.5 1996/08/15 07:27:49 deraadt Exp $";
d52 1
a87 6
	if (xports == NULL) {
		xports = (SVCXPRT **)mem_alloc(FD_SETSIZE *
		    sizeof(SVCXPRT *));
		memset(xports, '\0', FD_SETSIZE * sizeof(SVCXPRT *));
	}

d89 1
d92 2
a93 2
		fds = (fd_set *)malloc(howmany(sock+1, NBBY));
		memset(fds, '\0', howmany(sock+1, NBBY));
d95 2
a96 2
			memcpy(fds, __svc_fdset,
			    howmany(__svc_fdsetsize, NBBY));
d100 1
a100 1
		__svc_fdsetsize = sock+1;
d106 16
@


1.5
log
@support descriptors > FD_SETSIZE and correct timeout handling
@
text
@a0 3
/*	$OpenBSD: svc.c,v 1.4 1996/07/20 06:12:40 deraadt Exp $	*/
/*	$NetBSD: svc.c,v 1.9 1996/05/17 00:32:22 jtc Exp $	*/

d31 2
a32 4
/*static char *sccsid = "from: @@(#)svc.c 1.44 88/02/08 Copyr 1984 Sun Micro";*/
/*static char *sccsid = "from: @@(#)svc.c	2.4 88/08/11 4.0 RPCSRC";*/
static char *rcsid = "$OpenBSD: svc.c,v 1.4 1996/07/20 06:12:40 deraadt Exp $";
#endif
@


1.4
log
@bcopy->memcpy & tag
@
text
@d1 1
a1 1
/*	$OpenBSD: svc.c,v 1.9 1996/05/17 00:32:22 jtc Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: svc.c,v 1.9 1996/05/17 00:32:22 jtc Exp $";
d78 3
d93 3
a95 3
		xports = (SVCXPRT **)
			mem_alloc(FD_SETSIZE * sizeof(SVCXPRT *));
		memset(xports, 0, FD_SETSIZE * sizeof(SVCXPRT *));
d97 16
a112 2
	if (sock < FD_SETSIZE) {
		xports[sock] = xprt;
d114 3
a116 2
		svc_maxfd = max(svc_maxfd, sock);
	}
d128 1
a128 1
	if ((sock < FD_SETSIZE) && (xports[sock] == xprt)) {
d130 3
a132 1
		FD_CLR(sock, &svc_fdset);
d138 4
d396 2
d402 8
a424 1

d426 1
a426 1
	for (sock = 0; sock < FD_SETSIZE; sock += NFDBITS) {
@


1.3
log
@need string.h
@
text
@d1 1
d36 1
a36 1
static char *rcsid = "$NetBSD: svc.c,v 1.9 1996/05/17 00:32:22 jtc Exp $";
@


1.2
log
@clear xports after allocating it; netbsd pr#2194; from ragge@@my28.sm.luth.se
@
text
@d1 1
a1 1
/*	$NetBSD: svc.c,v 1.7 1995/02/25 03:01:57 cgd Exp $	*/
d35 1
a35 1
static char *rcsid = "$NetBSD: svc.c,v 1.7 1995/02/25 03:01:57 cgd Exp $";
d49 1
@


1.1
log
@Initial revision
@
text
@d90 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

