head	1.37;
access;
symbols
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.4
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.32.0.8
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.6
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.30.0.10
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.8
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.6
	OPENBSD_5_0:1.30.0.4
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.6
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.28.0.12
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.10
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.8
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.6
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.6
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.18.0.10
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.8
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.18.0.6
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.4
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.15.0.4
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2015.11.01.03.45.29;	author guenther;	state Exp;
branches;
next	1.36;
commitid	CfNWDWdDpm7mVO8i;

1.36
date	2015.09.13.15.36.56;	author guenther;	state Exp;
branches;
next	1.35;
commitid	FxNpAvmgpSFQVav0;

1.35
date	2015.09.01.19.54.01;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	1kc6QzxBpplZkdjp;

1.34
date	2015.09.01.17.31.39;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	wNBber7PJsiacqv9;

1.33
date	2014.10.25.03.18.58;	author lteo;	state Exp;
branches;
next	1.32;
commitid	A0rFNarRQqxSt93q;

1.32
date	2013.04.15.13.08.39;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.11.17.40.09;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.05.20.23.06;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.02.00.36.05;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.10.12.00.52;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.08.08.05.35;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.01.07.44.04;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.08.19.17.39;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.31.03.27.23;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.06.18.35.12;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.02.23.00.10;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.15.13.51.01;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.03.06.50.28;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.05.22.04.23.01;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.05.22.04.21.38;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.05.19.06.59.43;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.07.09.03.05.05;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.04.30.05.50.17;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	97.03.29.06.09.58;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.02.17.00.03.57;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.02.13.22.33.13;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.02.13.22.29.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.02.13.22.21.11;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.07.06.27.19;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.20.23.47.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.19.08.31.57;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.08.15.07.27.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.05.00.34.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.20.06.12.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.21.54.40;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@delete old lint ARGSUSED comments
@
text
@/*	$OpenBSD: svc_tcp.c,v 1.36 2015/09/13 15:36:56 guenther Exp $ */

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * svc_tcp.c, Server side for TCP/IP based RPC. 
 *
 * Actually implements two flavors of transporter -
 * a tcp rendezvouser (a listner and connection establisher)
 * and a record/tcp stream.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <rpc/rpc.h>
#include <sys/socket.h>
#include <errno.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

/*
 * Ops vector for TCP/IP based rpc service handle
 */
static bool_t		svctcp_recv(SVCXPRT *xprt, struct rpc_msg *msg);
static enum xprt_stat	svctcp_stat(SVCXPRT *xprt);
static bool_t		svctcp_getargs(SVCXPRT *xprt, xdrproc_t xdr_args,
			    caddr_t args_ptr);
static bool_t		svctcp_reply(SVCXPRT *xprt, struct rpc_msg *msg);
static bool_t		svctcp_freeargs(SVCXPRT *xprt, xdrproc_t xdr_args,
			    caddr_t args_ptr);
static void		svctcp_destroy(SVCXPRT *xprt);

static struct xp_ops svctcp_op = {
	svctcp_recv,
	svctcp_stat,
	svctcp_getargs,
	svctcp_reply,
	svctcp_freeargs,
	svctcp_destroy
};

/*
 * Ops vector for TCP/IP rendezvous handler
 */
static bool_t		rendezvous_request(SVCXPRT *xprt, struct rpc_msg *);
static enum xprt_stat	rendezvous_stat(SVCXPRT *xprt);

static struct xp_ops svctcp_rendezvous_op = {
	rendezvous_request,
	rendezvous_stat,
	/* XXX abort illegal in library */
	(bool_t (*)(struct __rpc_svcxprt *, xdrproc_t, caddr_t))abort,
	(bool_t (*)(struct __rpc_svcxprt *, struct rpc_msg *))abort,
	(bool_t (*)(struct __rpc_svcxprt *, xdrproc_t, caddr_t))abort,
	svctcp_destroy
};

static int readtcp(SVCXPRT *xprt, caddr_t buf, int len),
    writetcp(SVCXPRT *xprt, caddr_t buf, int len);
static SVCXPRT *makefd_xprt(int fd, u_int sendsize, u_int recvsize);

struct tcp_rendezvous { /* kept in xprt->xp_p1 */
	u_int sendsize;
	u_int recvsize;
};

struct tcp_conn {  /* kept in xprt->xp_p1 */
	enum xprt_stat strm_stat;
	u_long x_id;
	XDR xdrs;
	char verf_body[MAX_AUTH_BYTES];
};

/*
 * Usage:
 *	xprt = svctcp_create(sock, send_buf_size, recv_buf_size);
 *
 * Creates, registers, and returns a (rpc) tcp based transporter.
 * Once *xprt is initialized, it is registered as a transporter
 * see (svc.h, xprt_register).  This routine returns
 * a NULL if a problem occurred.
 *
 * If sock<0 then a socket is created, else sock is used.
 * If the socket, sock is not bound to a port then svctcp_create
 * binds it to an arbitrary port.  The routine then starts a tcp
 * listener on the socket's associated port.  In any (successful) case,
 * xprt->xp_sock is the registered socket number and xprt->xp_port is the
 * associated port number.
 *
 * Since tcp streams do buffered io similar to stdio, the caller can specify
 * how big the send and receive buffers are via the second and third parms;
 * 0 => use the system default.
 */
SVCXPRT *
svctcp_create(int sock, u_int sendsize, u_int recvsize)
{
	bool_t madesock = FALSE;
	SVCXPRT *xprt;
	struct tcp_rendezvous *r;
	struct sockaddr_in addr;
	socklen_t len = sizeof(struct sockaddr_in);

	if (sock == RPC_ANYSOCK) {
		if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
			return (NULL);
		madesock = TRUE;
	}
	memset(&addr, 0, sizeof (addr));
	addr.sin_len = sizeof(struct sockaddr_in);
	addr.sin_family = AF_INET;
	if (bindresvport(sock, &addr)) {
		addr.sin_port = 0;
		(void)bind(sock, (struct sockaddr *)&addr, len);
	}
	if ((getsockname(sock, (struct sockaddr *)&addr, &len) != 0)  ||
	    (listen(sock, 2) != 0)) {
		if (madesock)
			(void)close(sock);
		return (NULL);
	}
	r = (struct tcp_rendezvous *)mem_alloc(sizeof(*r));
	if (r == NULL) {
		if (madesock)
			(void)close(sock);
		return (NULL);
	}
	r->sendsize = sendsize;
	r->recvsize = recvsize;
	xprt = (SVCXPRT *)mem_alloc(sizeof(SVCXPRT));
	if (xprt == NULL) {
		if (madesock)
			(void)close(sock);
		free(r);
		return (NULL);
	}
	xprt->xp_p2 = NULL;
	xprt->xp_p1 = (caddr_t)r;
	xprt->xp_verf = _null_auth;
	xprt->xp_ops = &svctcp_rendezvous_op;
	xprt->xp_port = ntohs(addr.sin_port);
	xprt->xp_sock = sock;
	if (__xprt_register(xprt) == 0) {
		if (madesock)
			(void)close(sock);
		free(r);
		free(xprt);
		return (NULL);
	}
	return (xprt);
}
DEF_WEAK(svctcp_create);

/*
 * Like svtcp_create(), except the routine takes any *open* UNIX file
 * descriptor as its first input.
 */
SVCXPRT *
svcfd_create(int fd, u_int sendsize, u_int recvsize)
{

	return (makefd_xprt(fd, sendsize, recvsize));
}

static SVCXPRT *
makefd_xprt(int fd, u_int sendsize, u_int recvsize)
{
	SVCXPRT *xprt;
	struct tcp_conn *cd;
 
	xprt = (SVCXPRT *)mem_alloc(sizeof(SVCXPRT));
	if (xprt == NULL)
		goto done;
	cd = (struct tcp_conn *)mem_alloc(sizeof(struct tcp_conn));
	if (cd == NULL) {
		mem_free((char *) xprt, sizeof(SVCXPRT));
		xprt = NULL;
		goto done;
	}
	cd->strm_stat = XPRT_IDLE;
	xdrrec_create(&(cd->xdrs), sendsize, recvsize,
	    (caddr_t)xprt, (int(*)(caddr_t, caddr_t, int))readtcp,
	    (int(*)(caddr_t, caddr_t, int))writetcp);
	xprt->xp_p2 = NULL;
	xprt->xp_p1 = (caddr_t)cd;
	xprt->xp_verf.oa_base = cd->verf_body;
	xprt->xp_addrlen = 0;
	xprt->xp_ops = &svctcp_op;  /* truely deals with calls */
	xprt->xp_port = 0;  /* this is a connection, not a rendezvouser */
	xprt->xp_sock = fd;
	if (__xprt_register(xprt) == 0) {
		free(xprt);
		free(cd);
		return (NULL);
	}
    done:
	return (xprt);
}

static bool_t
rendezvous_request(SVCXPRT *xprt, struct rpc_msg *ignored)
{
	int sock;
	struct tcp_rendezvous *r;
	struct sockaddr_in addr;
	socklen_t len;

	r = (struct tcp_rendezvous *)xprt->xp_p1;
    again:
	len = sizeof(struct sockaddr_in);
	if ((sock = accept(xprt->xp_sock, (struct sockaddr *)&addr,
	    &len)) < 0) {
		if (errno == EINTR || errno == EWOULDBLOCK ||
		    errno == ECONNABORTED)
			goto again;
	       return (FALSE);
	}

#ifdef IP_OPTIONS
	{
		struct ipoption opts;
		socklen_t optsize = sizeof(opts);
		int i;

		if (!getsockopt(sock, IPPROTO_IP, IP_OPTIONS, (char *)&opts,
		    &optsize) && optsize != 0) {
			for (i = 0; (char *)&opts.ipopt_list[i] - (char *)&opts <
			    optsize; ) {	
				u_char c = (u_char)opts.ipopt_list[i];
				if (c == IPOPT_LSRR || c == IPOPT_SSRR) {
					close(sock);
					return (FALSE);
				}
				if (c == IPOPT_EOL)
					break;
				i += (c == IPOPT_NOP) ? 1 :
				    (u_char)opts.ipopt_list[i+1];
			}
		}
	}
#endif

	/*
	 * XXX careful for ftp bounce attacks. If discovered, close the
	 * socket and look for another connection.
	 */
	if (addr.sin_port == htons(20)) {
		close(sock);
		return (FALSE);
	}

	/*
	 * make a new transporter (re-uses xprt)
	 */
	xprt = makefd_xprt(sock, r->sendsize, r->recvsize);
	xprt->xp_raddr = addr;
	xprt->xp_addrlen = len;
	return (FALSE); /* there is never an rpc msg to be processed */
}

static enum xprt_stat
rendezvous_stat(SVCXPRT *xprt)
{

	return (XPRT_IDLE);
}

static void
svctcp_destroy(SVCXPRT *xprt)
{
	struct tcp_conn *cd = (struct tcp_conn *)xprt->xp_p1;

	xprt_unregister(xprt);
	if (xprt->xp_sock != -1)
		(void)close(xprt->xp_sock);
	xprt->xp_sock = -1;
	if (xprt->xp_port != 0) {
		/* a rendezvouser socket */
		xprt->xp_port = 0;
	} else {
		/* an actual connection socket */
		XDR_DESTROY(&(cd->xdrs));
	}
	mem_free((caddr_t)cd, sizeof(struct tcp_conn));
	mem_free((caddr_t)xprt, sizeof(SVCXPRT));
}

/*
 * All read operations timeout after 35 seconds.
 * A timeout is fatal for the connection.
 */
static struct timeval wait_per_try = { 35, 0 };

/*
 * reads data from the tcp conection.
 * any error is fatal and the connection is closed.
 * (And a read of zero bytes is a half closed stream => error.)
 */
static int
readtcp(SVCXPRT *xprt, caddr_t buf, int len)
{
	int sock = xprt->xp_sock;
	int delta, nready;
	struct timeval start;
	struct timeval tmp1, tmp2;
	struct pollfd pfd[1];

	/*
	 * All read operations timeout after 35 seconds.
	 * A timeout is fatal for the connection.
	 */
	delta = wait_per_try.tv_sec * 1000;
	gettimeofday(&start, NULL);
	pfd[0].fd = sock;
	pfd[0].events = POLLIN;
	do {
		nready = poll(pfd, 1, delta);
		switch (nready) {
		case -1:
			if (errno != EINTR)
				goto fatal_err;
			gettimeofday(&tmp1, NULL);
			timersub(&tmp1, &start, &tmp2);
			timersub(&wait_per_try, &tmp2, &tmp1);
			if (tmp1.tv_sec < 0 || !timerisset(&tmp1))
				goto fatal_err;
			delta = tmp1.tv_sec * 1000 + tmp1.tv_usec / 1000;
			continue;
		case 0:
			goto fatal_err;
		}
	} while (pfd[0].revents == 0);
	if ((len = read(sock, buf, len)) > 0)
		return (len);
fatal_err:
	((struct tcp_conn *)(xprt->xp_p1))->strm_stat = XPRT_DIED;
	return (-1);
}

/*
 * writes data to the tcp connection.
 * Any error is fatal and the connection is closed.
 */
static int
writetcp(SVCXPRT *xprt, caddr_t buf, int len)
{
	int i, cnt;

	for (cnt = len; cnt > 0; cnt -= i, buf += i) {
		if ((i = write(xprt->xp_sock, buf, cnt)) < 0) {
			((struct tcp_conn *)(xprt->xp_p1))->strm_stat =
			    XPRT_DIED;
			return (-1);
		}
	}
	return (len);
}

static enum xprt_stat
svctcp_stat(SVCXPRT *xprt)
{
	struct tcp_conn *cd =
	    (struct tcp_conn *)(xprt->xp_p1);

	if (cd->strm_stat == XPRT_DIED)
		return (XPRT_DIED);
	if (! xdrrec_eof(&(cd->xdrs)))
		return (XPRT_MOREREQS);
	return (XPRT_IDLE);
}

static bool_t
svctcp_recv(SVCXPRT *xprt, struct rpc_msg *msg)
{
	struct tcp_conn *cd =
	    (struct tcp_conn *)(xprt->xp_p1);
	XDR *xdrs = &(cd->xdrs);

	xdrs->x_op = XDR_DECODE;
	(void)xdrrec_skiprecord(xdrs);
	if (xdr_callmsg(xdrs, msg)) {
		cd->x_id = msg->rm_xid;
		return (TRUE);
	}
	cd->strm_stat = XPRT_DIED;	/* XXX */
	return (FALSE);
}

static bool_t
svctcp_getargs(SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
{

	return ((*xdr_args)(&(((struct tcp_conn *)(xprt->xp_p1))->xdrs), args_ptr));
}

static bool_t
svctcp_freeargs(SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
{
	XDR *xdrs =
	    &(((struct tcp_conn *)(xprt->xp_p1))->xdrs);

	xdrs->x_op = XDR_FREE;
	return ((*xdr_args)(xdrs, args_ptr));
}

static bool_t
svctcp_reply(SVCXPRT *xprt, struct rpc_msg *msg)
{
	struct tcp_conn *cd =
	    (struct tcp_conn *)(xprt->xp_p1);
	XDR *xdrs = &(cd->xdrs);
	bool_t stat;

	xdrs->x_op = XDR_ENCODE;
	msg->rm_xid = cd->x_id;
	stat = xdr_replymsg(xdrs, msg);
	(void)xdrrec_endofrecord(xdrs, TRUE);
	return (stat);
}
@


1.36
log
@Wrap <rpc/*.h> so that calls go direct and the symbols are all weak.
Hide __xprt_register() and _authenticate(); truncate <rpc/svc_auth.h>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.35 2015/09/01 19:54:01 deraadt Exp $ */
a231 1
/* ARGSUSED */
a292 1
/* ARGSUSED */
@


1.35
log
@Remove all bogus writes to stderr.  Only explicit requests should
go that way.
ok miod beck
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.34 2015/09/01 17:31:39 deraadt Exp $ */
d184 1
@


1.34
log
@Remove calls to perror(); the error returns are sufficient, and these
library may not assume stderr is useable.
ok millert miod beck
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.33 2014/10/25 03:18:58 lteo Exp $ */
a155 1
		(void)fprintf(stderr, "svctcp_create: out of memory\n");
a163 1
		(void)fprintf(stderr, "svctcp_create: out of memory\n");
d203 1
a203 2
	if (xprt == NULL) {
		(void) fprintf(stderr, "svc_tcp: makefd_xprt: out of memory\n");
a204 1
	}
a206 1
		(void) fprintf(stderr, "svc_tcp: makefd_xprt: out of memory\n");
@


1.33
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.32 2013/04/15 13:08:39 millert Exp $ */
d137 1
a137 2
		if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
			perror("svctcp_.c - udp socket creation problem");
a138 1
		}
a149 1
		perror("svctcp_.c - cannot getsockname or listen");
@


1.32
log
@Back out r1.17 and its subsequent conversion to poll.  Otherwise
we can get into a svc_getreq_poll() -> readtcp() -> svc_getreq_poll()
loop until we run out of stack.  If we want to avoid blocking on
the new fd in readtcp() we need to poll() in svc_getreq_poll(),
which will require a more elaborate change.  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.31 2013/03/11 17:40:09 deraadt Exp $ */
a49 1
#include <netinet/in_systm.h>
@


1.31
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.30 2010/09/01 14:43:34 millert Exp $ */
d348 1
a348 8
	struct pollfd *pfd = NULL;

	pfd = (struct pollfd *)calloc(sizeof(*pfd), (svc_max_pollfd + 1));
	if (pfd == NULL)
		goto fatal_err;
	pfd[0].fd = sock;
	pfd[0].events = POLLIN;
	memcpy(&pfd[1], svc_pollfd, (sizeof(*pfd) * svc_max_pollfd));
d356 2
d359 1
a359 1
		nready = poll(pfd, svc_max_pollfd + 1, delta);
a372 11
		default:
			if (pfd[0].revents == 0) {
				svc_getreq_poll(&pfd[1], nready);
				gettimeofday(&tmp1, NULL);
				timersub(&tmp1, &start, &tmp2);
				timersub(&wait_per_try, &tmp2, &tmp1);
				if (tmp1.tv_sec < 0 || !timerisset(&tmp1))
					goto fatal_err;
				delta = tmp1.tv_sec * 1000 + tmp1.tv_usec / 1000;
				continue;
			}
d375 1
a375 3
	if ((len = read(sock, buf, len)) > 0) {
		if (pfd)
			free(pfd);
a376 1
	}
a378 2
	if (pfd)
		free(pfd);
@


1.30
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.29 2009/06/05 20:23:06 deraadt Exp $ */
d254 2
a255 1
		if (errno == EINTR)
@


1.29
log
@use calloc() to provide size * nitems safety; ok millert
@
text
@d1 2
a2 1
/*	$OpenBSD: svc_tcp.c,v 1.28 2006/04/02 00:36:05 deraadt Exp $ */
d4 28
a31 26
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a35 2
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
@


1.28
log
@sprinkle a socklen_t
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.27 2005/10/10 12:00:52 espie Exp $ */
d348 1
a348 1
	pfd = (struct pollfd *)malloc(sizeof(*pfd) * (svc_max_pollfd + 1));
a352 1
	pfd[0].revents = 0;
@


1.27
log
@Remove a few warnings. Those were not apparent thanks to a bug in gcc 2.95.

Patch by Leonardo Chiquitto Filho <leonardo@@iken.com.br>
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.26 2005/08/08 08:05:35 espie Exp $ */
d261 2
a262 1
		int optsize = sizeof(opts), i;
@


1.26
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a345 1
	int prevbytes = 0, bytes;
@


1.25
log
@ansify. ok deraadt@@ jaredy@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.24 2005/01/08 19:17:39 krw Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.24
log
@Bit of KNF - replace (<type> *)0 and (<type> *)NULL with NULL. Pointed
out by mickey@@, seconded by millert@@.

ok deraadt@@.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.23 2003/12/31 03:27:23 millert Exp $";
d60 8
a67 6
static bool_t		svctcp_recv();
static enum xprt_stat	svctcp_stat();
static bool_t		svctcp_getargs();
static bool_t		svctcp_reply();
static bool_t		svctcp_freeargs();
static void		svctcp_destroy();
d81 2
a82 2
static bool_t		rendezvous_request();
static enum xprt_stat	rendezvous_stat();
d87 4
a90 3
	(bool_t (*)())abort,	/* XXX abort illegal in library */
	(bool_t (*)())abort,	/* XXX abort illegal in library */
	(bool_t (*)())abort,	/* XXX abort illegal in library */
d94 3
a96 2
static int readtcp(), writetcp();
static SVCXPRT *makefd_xprt();
d131 1
a131 4
svctcp_create(sock, sendsize, recvsize)
	int sock;
	u_int sendsize;
	u_int recvsize;
d198 1
a198 4
svcfd_create(fd, sendsize, recvsize)
	int fd;
	u_int sendsize;
	u_int recvsize;
d205 1
a205 4
makefd_xprt(fd, sendsize, recvsize)
	int fd;
	u_int sendsize;
	u_int recvsize;
d224 2
a225 1
	    (caddr_t)xprt, readtcp, writetcp);
d242 1
d244 1
a244 2
rendezvous_request(xprt)
	SVCXPRT *xprt;
d302 1
d304 1
a304 1
rendezvous_stat()
d311 1
a311 2
svctcp_destroy(xprt)
	SVCXPRT *xprt;
d342 1
a342 4
readtcp(xprt, buf, len)
	SVCXPRT *xprt;
	caddr_t buf;
	int len;
d410 1
a410 4
writetcp(xprt, buf, len)
	SVCXPRT *xprt;
	caddr_t buf;
	int len;
d425 1
a425 2
svctcp_stat(xprt)
	SVCXPRT *xprt;
d438 1
a438 3
svctcp_recv(xprt, msg)
	SVCXPRT *xprt;
	struct rpc_msg *msg;
d455 1
a455 4
svctcp_getargs(xprt, xdr_args, args_ptr)
	SVCXPRT *xprt;
	xdrproc_t xdr_args;
	caddr_t args_ptr;
d462 1
a462 4
svctcp_freeargs(xprt, xdr_args, args_ptr)
	SVCXPRT *xprt;
	xdrproc_t xdr_args;
	caddr_t args_ptr;
d472 1
a472 3
svctcp_reply(xprt, msg)
	SVCXPRT *xprt;
	struct rpc_msg *msg;
@


1.23
log
@Implement svc_getreq_poll(3) and friends and use poll(2) instead of select(2)
in the libc rpc code.  The main difference between this and the previous
version is the use of a simple free list that simplifies the logic when
adding a socket to svc_pollfd.  I've also added code to pack svc_pollfd
when the free list gets too big.  The idea general idea is to keep
svc_pollfd as tightly packed as possible to make poll(2) efficient.
Tested by many people and OK deraadt@@
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.22 2002/09/06 18:35:12 deraadt Exp $";
d141 1
a141 1
			return ((SVCXPRT *)NULL);
d157 1
a157 1
		return ((SVCXPRT *)NULL);
d216 1
a216 1
	if (xprt == (SVCXPRT *)NULL) {
d221 1
a221 1
	if (cd == (struct tcp_conn *)NULL) {
d224 1
a224 1
		xprt = (SVCXPRT *)NULL;
@


1.22
log
@use socklen_t where needed; henning pvalchev ok
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.21 2002/01/02 23:00:10 deraadt Exp $";
d352 2
a353 1
	struct timeval start, delta;
d355 1
a355 1
	fd_set *fds = NULL;
a356 2
	extern int __svc_fdsetsize;
	extern fd_set *__svc_fdset;
d358 13
a370 1
	delta = wait_per_try;
d373 2
a374 13
		bytes = howmany(__svc_fdsetsize, NFDBITS) * sizeof(fd_mask);
		if (bytes != prevbytes) {
			if (fds)
				free(fds);
			fds = (fd_set *)malloc(bytes);
			prevbytes = bytes;
		}
		if (fds == NULL)
			goto fatal_err;
		memcpy(fds, __svc_fdset, bytes);

		FD_SET(sock, fds);
		switch (select(svc_maxfd+1, fds, NULL, NULL, &delta)) {
d383 1
a383 1
			delta = tmp1;
d388 2
a389 2
			if (!FD_ISSET(sock, fds)) {
				svc_getreqset2(fds, svc_maxfd+1);
d395 1
a395 1
				delta = tmp1;
d399 1
a399 1
	} while (!FD_ISSET(sock, fds));
d401 2
a402 2
		if (fds)
			free(fds);
d407 2
a408 2
	if (fds)
		free(fds);
@


1.21
log
@label abort() from inside library as ILLEGAL
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.20 2001/09/15 13:51:01 deraadt Exp $";
d136 1
a136 1
	int len = sizeof(struct sockaddr_in);
d253 1
a253 1
	int len;
@


1.20
log
@prototype cleanup
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.19 2001/03/03 06:50:28 deraadt Exp $";
d85 3
a87 3
	(bool_t (*)())abort,
	(bool_t (*)())abort,
	(bool_t (*)())abort,
@


1.19
log
@plug many memory leaks
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.18 1998/05/22 04:23:01 deraadt Exp $";
d128 1
a128 1
	register int sock;
d133 2
a134 2
	register SVCXPRT *xprt;
	register struct tcp_rendezvous *r;
d212 2
a213 2
	register SVCXPRT *xprt;
	register struct tcp_conn *cd;
d248 1
a248 1
	register SVCXPRT *xprt;
d315 1
a315 1
	register SVCXPRT *xprt;
d317 1
a317 1
	register struct tcp_conn *cd = (struct tcp_conn *)xprt->xp_p1;
d347 1
a347 1
	register SVCXPRT *xprt;
d349 1
a349 1
	register int len;
d351 1
a351 1
	register int sock = xprt->xp_sock;
d418 1
a418 1
	register SVCXPRT *xprt;
d422 1
a422 1
	register int i, cnt;
d438 1
a438 1
	register struct tcp_conn *cd =
d451 1
a451 1
	register struct rpc_msg *msg;
d453 1
a453 1
	register struct tcp_conn *cd =
d455 1
a455 1
	register XDR *xdrs = &(cd->xdrs);
d483 1
a483 1
	register XDR *xdrs =
d493 1
a493 1
	register struct rpc_msg *msg;
d495 1
a495 1
	register struct tcp_conn *cd =
d497 2
a498 2
	register XDR *xdrs = &(cd->xdrs);
	register bool_t stat;
@


1.18
log
@make svctcp_recv kill sockets that fail in xdr_callmsg(); wpaul
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.17 1998/05/22 04:21:38 deraadt Exp $";
d182 7
a188 1
	xprt_register(xprt);
d237 5
a241 1
	xprt_register(xprt);
@


1.17
log
@make readtcp() call svc_getreqset2() for activity on other sockets; wpaul
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.16 1998/05/19 06:59:43 deraadt Exp $";
d453 1
@


1.16
log
@incorrect timeout handling
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.15 1997/07/09 03:05:05 deraadt Exp $";
d344 4
a347 1
	fd_set *fds, readfds;
d349 10
a358 3
	if (sock+1 > FD_SETSIZE) {
		int bytes = howmany(sock+1, NFDBITS) * sizeof(fd_mask);
		fds = (fd_set *)malloc(bytes);
d361 1
a361 5
		memset(fds, 0, bytes);
	} else {
		fds = &readfds;
		FD_ZERO(fds);
	}
a362 4
	delta = wait_per_try;
	gettimeofday(&start, NULL);
	do {
		/* XXX we know the other bits are still clear */
d364 1
a364 1
		switch (select(sock+1, fds, NULL, NULL, &delta)) {
d377 11
d391 1
a391 1
		if (fds != &readfds)
d397 1
a397 1
	if (fds != &readfds)
@


1.15
log
@avoid close(closed_socket) or close(-1); it looks disgusting in kdump
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.14 1997/04/30 05:50:17 tholo Exp $";
d368 1
a368 1
			timersub(&delta, &tmp2, &tmp1);
@


1.14
log
@Don't do pointer arithmetic on void pointers
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.13 1997/03/29 06:09:58 deraadt Exp $";
d310 3
a312 1
	(void)close(xprt->xp_sock);
@


1.13
log
@if a bad socket is accept()ed, bail without trying another accept()
in svctcp_create(), only close socket if we created it
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.12 1997/02/17 00:03:57 deraadt Exp $";
d262 1
a262 1
			for (i = 0; (void *)&opts.ipopt_list[i] - (void *)&opts <
@


1.12
log
@do not leak descriptors and mem
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.11 1997/02/13 22:33:13 deraadt Exp $";
d132 1
d143 1
d155 2
a156 1
		(void)close(sock);
d162 2
a163 1
		(void)close(sock);
d171 2
a172 1
		(void)close(sock);
d267 1
a267 1
					goto again;
d284 1
a284 1
		goto again;
@


1.11
log
@if i find one more little problem, and have to make one more little
tweak to this ip option handling code I am going to absolutely scream
in rage, following which I will rip the bloody innards out of netinet
and build my own new incompatible option checking/processing interface
that does not make it so hidiously difficult to check if a session has
source routes active!
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.10 1997/02/13 22:29:12 deraadt Exp $";
a131 1
	bool_t madesock = FALSE;
a141 1
		madesock = TRUE;
d153 1
a153 2
		if (madesock)
		       (void)close(sock);
d158 2
a159 1
		(void) fprintf(stderr, "svctcp_create: out of memory\n");
d166 3
a168 1
		(void) fprintf(stderr, "svctcp_create: out of memory\n");
@


1.10
log
@option handling is a bitch
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.9 1997/02/13 22:21:11 deraadt Exp $";
d258 1
a258 1
			    sizeof opts; ) {	
@


1.9
log
@ok, i finally learned about struct ipoption
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.8 1997/02/07 06:27:19 deraadt Exp $";
d257 2
a258 1
			for (i = 0; i < optsize; ) {
@


1.8
log
@destroy everything with source routes
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.7 1996/08/20 23:47:46 deraadt Exp $";
d55 1
d252 2
a253 2
		u_char optbuf[BUFSIZ/3];
		int optsize = sizeof(optbuf), i;
d255 1
a255 1
		if (!getsockopt(sock, IPPROTO_IP, IP_OPTIONS, (char *)optbuf,
d258 1
a258 1
				u_char c = optbuf[i];
d265 2
a266 1
				i += (c == IPOPT_NOP) ? 1 : optbuf[i+1];
@


1.7
log
@memset 0; also fix for byte order botch in __svc_fdset handling; thanks to mw@@openbsd.org
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.6 1996/08/19 08:31:57 tholo Exp $";
d52 4
d248 22
d278 1
@


1.6
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.5 1996/08/15 07:27:50 deraadt Exp $";
d310 2
a311 1
		fds = (fd_set *)malloc(howmany(sock+1, NBBY));
d314 1
a314 1
		memset(fds, '\0', howmany(sock+1, NBBY));
@


1.5
log
@support descriptors > FD_SETSIZE and correct timeout handling
@
text
@a0 3
/*	$OpenBSD: svc_tcp.c,v 1.4 1996/08/05 00:34:28 deraadt Exp $	*/
/*	$NetBSD: svc_tcp.c,v 1.6 1995/06/03 22:37:27 mycroft Exp $	*/

d31 2
a32 4
/*static char *sccsid = "from: @@(#)svc_tcp.c 1.21 87/08/11 Copyr 1984 Sun Micro";*/
/*static char *sccsid = "from: @@(#)svc_tcp.c	2.2 88/08/01 4.0 RPCSRC";*/
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.4 1996/08/05 00:34:28 deraadt Exp $";
#endif
@


1.4
log
@if port 20 incoming, kill it and try again
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.3 1996/07/20 06:12:45 deraadt Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.3 1996/07/20 06:12:45 deraadt Exp $";
d310 13
a322 2
	fd_set mask;
	fd_set readfds;
d324 2
a325 2
	FD_ZERO(&mask);
	FD_SET(sock, &mask);
d327 14
a340 6
		readfds = mask;
		if (select(sock+1, &readfds, NULL, NULL, 
			   &wait_per_try) <= 0) {
			if (errno == EINTR) {
				continue;
			}
d343 1
a343 1
	} while (!FD_ISSET(sock, &readfds));
d345 2
d351 2
@


1.3
log
@bcopy->memcpy & tag
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_tcp.c,v 1.6 1995/06/03 22:37:27 mycroft Exp $	*/
d36 1
a36 1
static char *rcsid = "$OpenBSD: svc_tcp.c,v 1.6 1995/06/03 22:37:27 mycroft Exp $";
d248 8
@


1.2
log
@Pull prototypes into scope
Remove graticious casts
@
text
@d1 1
d36 1
a36 1
static char *rcsid = "$NetBSD: svc_tcp.c,v 1.6 1995/06/03 22:37:27 mycroft Exp $";
@


1.1
log
@Initial revision
@
text
@d51 1
d308 1
a308 1
		if (select(sock+1, &readfds, (int*)NULL, (int*)NULL, 
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
