head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.8
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.15.0.22
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.14
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.18
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.16
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.12
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.8
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.6
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.6.0.18
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.16
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2015.11.01.03.45.29;	author guenther;	state Exp;
branches;
next	1.16;
commitid	CfNWDWdDpm7mVO8i;

1.16
date	2015.09.13.15.36.56;	author guenther;	state Exp;
branches;
next	1.15;
commitid	FxNpAvmgpSFQVav0;

1.15
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.09.19.40.10;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.31.18.28.55;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.08.08.05.36;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.01.07.44.04;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.14.22.20.01;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.11.22.55.39;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.17.18.34.51;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.15.13.51.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.11.14.06.33.13;	author etheisen;	state Exp;
branches;
next	1.5;

1.5
date	96.09.15.09.31.43;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.08.32.04;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.07.20.06.12.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.09.02.42.53;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@delete old lint ARGSUSED comments
@
text
@/*	$OpenBSD: xdr_mem.c,v 1.16 2015/09/13 15:36:56 guenther Exp $ */

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * xdr_mem.h, XDR implementation using memory buffers.
 *
 * If you have some data to be interpreted as external data representation
 * or to be converted to external data representation in a memory buffer,
 * then this is the package for you.
 *
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <string.h>

#include <rpc/types.h>
#include <rpc/xdr.h>

static bool_t	xdrmem_getlong_aligned(XDR *, long *);
static bool_t	xdrmem_putlong_aligned(XDR *, long *);
static bool_t	xdrmem_getlong_unaligned(XDR *, long *);
static bool_t	xdrmem_putlong_unaligned(XDR *, long *);
static bool_t	xdrmem_getbytes(XDR *, caddr_t, u_int);
static bool_t	xdrmem_putbytes(XDR *, caddr_t, u_int);
static u_int	xdrmem_getpos(XDR *); /* XXX w/64-bit pointers, u_int not enough! */
static bool_t	xdrmem_setpos(XDR *, u_int);
static int32_t *xdrmem_inline_aligned(XDR *, u_int);
static int32_t *xdrmem_inline_unaligned(XDR *, u_int);
static void	xdrmem_destroy(XDR *);

static struct	xdr_ops xdrmem_ops_aligned = {
	xdrmem_getlong_aligned,
	xdrmem_putlong_aligned,
	xdrmem_getbytes,
	xdrmem_putbytes,
	xdrmem_getpos,
	xdrmem_setpos,
	xdrmem_inline_aligned,
	xdrmem_destroy,
	NULL,	/* xdrmem_control */
};

static struct	xdr_ops xdrmem_ops_unaligned = {
	xdrmem_getlong_unaligned,
	xdrmem_putlong_unaligned,
	xdrmem_getbytes,
	xdrmem_putbytes,
	xdrmem_getpos,
	xdrmem_setpos,
	xdrmem_inline_unaligned,
	xdrmem_destroy,
	NULL,	/* xdrmem_control */
};

/*
 * The procedure xdrmem_create initializes a stream descriptor for a
 * memory buffer.  
 */
void
xdrmem_create(XDR *xdrs, caddr_t addr, u_int size, enum xdr_op op)
{

	xdrs->x_op = op;
	xdrs->x_ops = ((size_t)addr & (sizeof(int32_t) - 1))
	    ? &xdrmem_ops_unaligned : &xdrmem_ops_aligned;
	xdrs->x_private = xdrs->x_base = addr;
	xdrs->x_handy = size;
}
DEF_WEAK(xdrmem_create);

static void
xdrmem_destroy(XDR *xdrs)
{
}

static bool_t
xdrmem_getlong_aligned(XDR *xdrs, long int *lp)
{

	if (xdrs->x_handy < sizeof(int32_t))
		return (FALSE);
	xdrs->x_handy -= sizeof(int32_t);
	*lp = ntohl(*(int32_t *)xdrs->x_private);
	xdrs->x_private += sizeof(int32_t);
	return (TRUE);
}

static bool_t
xdrmem_putlong_aligned(XDR *xdrs, long int *lp)
{

	if (xdrs->x_handy < sizeof(int32_t))
		return (FALSE);
	xdrs->x_handy -= sizeof(int32_t);
	*(int32_t *)xdrs->x_private = htonl((u_int32_t)*lp);
	xdrs->x_private += sizeof(int32_t);
	return (TRUE);
}

static bool_t
xdrmem_getlong_unaligned(XDR *xdrs, long int *lp)
{
	int32_t l;

	if (xdrs->x_handy < sizeof(int32_t))
		return (FALSE);
	xdrs->x_handy -= sizeof(int32_t);
	memcpy(&l, xdrs->x_private, sizeof(int32_t));
	*lp = ntohl(l);
	xdrs->x_private += sizeof(int32_t);
	return (TRUE);
}

static bool_t
xdrmem_putlong_unaligned(XDR *xdrs, long int *lp)
{
	int32_t l;

	if (xdrs->x_handy < sizeof(int32_t))
		return (FALSE);
	xdrs->x_handy -= sizeof(int32_t);
	l = htonl((u_int32_t)*lp);
	memcpy(xdrs->x_private, &l, sizeof(int32_t));
	xdrs->x_private += sizeof(int32_t);
	return (TRUE);
}

static bool_t
xdrmem_getbytes(XDR *xdrs, caddr_t addr, u_int len)
{

	if (xdrs->x_handy < len)
		return (FALSE);
	xdrs->x_handy -= len;
	memcpy(addr, xdrs->x_private, len);
	xdrs->x_private += len;
	return (TRUE);
}

static bool_t
xdrmem_putbytes(XDR *xdrs, caddr_t addr, u_int len)
{

	if (xdrs->x_handy < len)
		return (FALSE);
	xdrs->x_handy -= len;
	memcpy(xdrs->x_private, addr, len);
	xdrs->x_private += len;
	return (TRUE);
}

static u_int
xdrmem_getpos(XDR *xdrs)
{

	/* XXX w/64-bit pointers, u_int not enough! */
	return ((u_long)xdrs->x_private - (u_long)xdrs->x_base);
}

static bool_t
xdrmem_setpos(XDR *xdrs, u_int pos)
{
	caddr_t newaddr = xdrs->x_base + pos;
	caddr_t lastaddr = xdrs->x_private + xdrs->x_handy;

	if (newaddr > lastaddr)
		return (FALSE);
	xdrs->x_private = newaddr;
	xdrs->x_handy = (u_int)(lastaddr - newaddr);	/* XXX w/64-bit pointers, u_int not enough! */
	return (TRUE);
}

static int32_t *
xdrmem_inline_aligned(XDR *xdrs, u_int len)
{
	int32_t *buf = 0;

	if (xdrs->x_handy >= len) {
		xdrs->x_handy -= len;
		buf = (int32_t *)xdrs->x_private;
		xdrs->x_private += len;
	}
	return (buf);
}

static int32_t *
xdrmem_inline_unaligned(XDR *xdrs, u_int len)
{

	return (0);
}
@


1.16
log
@Wrap <rpc/*.h> so that calls go direct and the symbols are all weak.
Hide __xprt_register() and _authenticate(); truncate <rpc/svc_auth.h>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr_mem.c,v 1.15 2010/09/01 14:43:34 millert Exp $ */
a101 1
/*ARGSUSED*/
a216 1
/* ARGSUSED */
@


1.15
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr_mem.c,v 1.14 2008/12/09 19:40:10 otto Exp $ */
d100 1
@


1.14
log
@Commit requested by marco:
Add nonblock support for xdrrecs
ok millert blambert & otto; from NetBSD. libc bump to follow soon.
@
text
@d1 2
a2 1
/*	$OpenBSD: xdr_mem.c,v 1.13 2006/03/31 18:28:55 deraadt Exp $ */
d4 28
a31 26
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a35 2
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
@


1.13
log
@sprinkle a bit of ARGSUSED
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr_mem.c,v 1.12 2005/08/08 08:05:36 espie Exp $ */
d42 2
a47 1
#include <netinet/in.h>
d69 2
a70 1
	xdrmem_destroy
d81 2
a82 1
	xdrmem_destroy
@


1.12
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d97 1
@


1.11
log
@ansify. ok deraadt@@ jaredy@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: xdr_mem.c,v 1.10 2004/09/14 22:20:01 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.10
log
@spacing
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_mem.c,v 1.9 2002/12/11 22:55:39 millert Exp $";
d90 1
a90 5
xdrmem_create(xdrs, addr, size, op)
	XDR *xdrs;
	caddr_t addr;
	u_int size;
	enum xdr_op op;
d106 1
a106 3
xdrmem_getlong_aligned(xdrs, lp)
	XDR *xdrs;
	long *lp;
d118 1
a118 3
xdrmem_putlong_aligned(xdrs, lp)
	XDR *xdrs;
	long *lp;
d130 1
a130 3
xdrmem_getlong_unaligned(xdrs, lp)
	XDR *xdrs;
	long *lp;
d144 1
a144 3
xdrmem_putlong_unaligned(xdrs, lp)
	XDR *xdrs;
	long *lp;
d158 1
a158 4
xdrmem_getbytes(xdrs, addr, len)
	XDR *xdrs;
	caddr_t addr;
	u_int len;
d170 1
a170 4
xdrmem_putbytes(xdrs, addr, len)
	XDR *xdrs;
	caddr_t addr;
	u_int len;
d182 1
a182 2
xdrmem_getpos(xdrs)
	XDR *xdrs;
d190 1
a190 3
xdrmem_setpos(xdrs, pos)
	XDR *xdrs;
	u_int pos;
d203 1
a203 3
xdrmem_inline_aligned(xdrs, len)
	XDR *xdrs;
	u_int len;
d217 1
a217 3
xdrmem_inline_unaligned(xdrs, len)
	XDR *xdrs;
	u_int len;
@


1.9
log
@Make x_handy in XDR u_int, not int since there are places in the
code that assign a u_int value to x_handy.  However, this means
that we need to be careful checking for overflow as we can no longer
subtract a value and check the result for < 0.  We reorder the
expression instead to avoid this problem (basic algebra).
deraadt@@ OK
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_mem.c,v 1.8 2001/09/17 18:34:51 jason Exp $";
a105 1
	
a106 1

@


1.8
log
@cast a few more long's to int32_t
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_mem.c,v 1.7 2001/09/15 13:51:01 deraadt Exp $";
d117 1
a117 1
	if ((xdrs->x_handy -= sizeof(int32_t)) < 0)
d119 1
d131 1
a131 1
	if ((xdrs->x_handy -= sizeof(int32_t)) < 0)
d133 1
d146 1
a146 1
	if ((xdrs->x_handy -= sizeof(int32_t)) < 0)
d148 1
d162 1
a162 1
	if ((xdrs->x_handy -= sizeof(int32_t)) < 0)
d164 1
d178 1
a178 1
	if ((xdrs->x_handy -= len) < 0)
d180 1
d193 1
a193 1
	if ((xdrs->x_handy -= len) < 0)
d195 1
d218 1
a218 1
	if ((long)newaddr > (long)lastaddr)
d221 1
a221 1
	xdrs->x_handy = (long)lastaddr - (long)newaddr;
@


1.7
log
@prototype cleanup
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_mem.c,v 1.6 1996/11/14 06:33:13 etheisen Exp $";
d132 1
a132 1
	*(int32_t *)xdrs->x_private = htonl(*lp);
d161 1
a161 1
	l = htonl(*lp);
@


1.6
log
@memcpy needs string.h.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_mem.c,v 1.5 1996/09/15 09:31:43 tholo Exp $";
d51 11
a61 11
static bool_t	xdrmem_getlong_aligned();
static bool_t	xdrmem_putlong_aligned();
static bool_t	xdrmem_getlong_unaligned();
static bool_t	xdrmem_putlong_unaligned();
static bool_t	xdrmem_getbytes();
static bool_t	xdrmem_putbytes();
static u_int	xdrmem_getpos(); /* XXX w/64-bit pointers, u_int not enough! */
static bool_t	xdrmem_setpos();
static int32_t *xdrmem_inline_aligned();
static int32_t *xdrmem_inline_unaligned();
static void	xdrmem_destroy();
d91 1
a91 1
	register XDR *xdrs;
d105 2
a106 2
xdrmem_destroy(/*xdrs*/)
	/*XDR *xdrs;*/
d113 1
a113 1
	register XDR *xdrs;
d126 1
a126 1
	register XDR *xdrs;
d139 1
a139 1
	register XDR *xdrs;
d154 1
a154 1
	register XDR *xdrs;
d169 1
a169 1
	register XDR *xdrs;
d171 1
a171 1
	register u_int len;
d183 1
a183 1
	register XDR *xdrs;
d185 1
a185 1
	register u_int len;
d197 1
a197 1
	register XDR *xdrs;
d206 1
a206 1
	register XDR *xdrs;
d209 2
a210 2
	register caddr_t newaddr = xdrs->x_base + pos;
	register caddr_t lastaddr = xdrs->x_private + xdrs->x_handy;
d221 2
a222 2
	register XDR *xdrs;
	int len;
d237 2
a238 2
	register XDR *xdrs;
	int len;
@


1.5
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_mem.c,v 1.4 1996/08/19 08:32:04 tholo Exp $";
d45 1
@


1.4
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_mem.c,v 1.4 1996/02/08 08:06:05 mycroft Exp $";
d233 1
@


1.3
log
@bcopy->memcpy & tag
@
text
@a0 3
/*	$OpenBSD$	*/
/*	$NetBSD: xdr_mem.c,v 1.4 1996/02/08 08:06:05 mycroft Exp $	*/

d31 2
a32 4
/*static char *sccsid = "from: @@(#)xdr_mem.c 1.19 87/08/11 Copyr 1984 Sun Micro";*/
/*static char *sccsid = "from: @@(#)xdr_mem.c	2.1 88/07/29 4.0 RPCSRC";*/
static char *rcsid = "$NetBSD: xdr_mem.c,v 1.4 1996/02/08 08:06:05 mycroft Exp $";
#endif
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d150 1
a150 1
	bcopy(xdrs->x_private, &l, sizeof(int32_t));
d166 1
a166 1
	bcopy(&l, xdrs->x_private, sizeof(int32_t));
d180 1
a180 1
	bcopy(xdrs->x_private, addr, len);
d194 1
a194 1
	bcopy(addr, xdrs->x_private, len);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: xdr_mem.c,v 1.3 1995/02/25 03:02:07 cgd Exp $	*/
d36 1
a36 1
static char *rcsid = "$NetBSD: xdr_mem.c,v 1.3 1995/02/25 03:02:07 cgd Exp $";
d55 4
a58 2
static bool_t	xdrmem_getlong();
static bool_t	xdrmem_putlong();
d63 2
a64 1
static int32_t *xdrmem_inline();
d67 3
a69 3
static struct	xdr_ops xdrmem_ops = {
	xdrmem_getlong,
	xdrmem_putlong,
d74 12
a85 1
	xdrmem_inline,
d102 2
a103 1
	xdrs->x_ops = &xdrmem_ops;
d112 14
d129 1
a129 1
xdrmem_getlong(xdrs, lp)
d136 1
a136 1
	*lp = (long)ntohl((u_int32_t)(*((int32_t *)(xdrs->x_private))));
d142 1
a142 1
xdrmem_putlong(xdrs, lp)
d146 1
d150 17
a166 1
	*(int32_t *)xdrs->x_private = (int32_t)htonl((int32_t)(*lp));
d224 1
a224 1
xdrmem_inline(xdrs, len)
d232 1
a232 1
		buf = (int32_t *) xdrs->x_private;
d236 9
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
