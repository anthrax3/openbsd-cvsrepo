head	1.26;
access;
symbols
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.22.0.22
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.14
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.18
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.16
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.14
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.10
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.12
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.8
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.6
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.8
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.6
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2015.11.01.03.45.29;	author guenther;	state Exp;
branches;
next	1.25;
commitid	CfNWDWdDpm7mVO8i;

1.25
date	2015.09.13.15.36.56;	author guenther;	state Exp;
branches;
next	1.24;
commitid	FxNpAvmgpSFQVav0;

1.24
date	2015.09.02.06.47.19;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	ZlfeVQ0KiiWxE5wv;

1.23
date	2015.09.01.19.54.00;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	1kc6QzxBpplZkdjp;

1.22
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.25.18.49.13;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.10.17.29.31;	author grunk;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.08.08.05.35;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.01.07.44.03;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.08.19.17.39;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.20.00.39.39;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.02.23.00.10;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.15.13.51.00;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.03.06.50.28;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.24.17.03.20;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.12.20.23.45.41;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.07.09.06.11.56;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.11.08.20.51.23;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.17.06.36.46;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.14.06.49.40;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.11.14.05.45.16;	author etheisen;	state Exp;
branches;
next	1.5;

1.5
date	96.09.15.09.31.29;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.08.31.21;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.07.20.06.12.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.21.54.35;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@delete old lint ARGSUSED comments
@
text
@/*	$OpenBSD: auth_unix.c,v 1.25 2015/09/13 15:36:56 guenther Exp $ */

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * auth_unix.c, Implements UNIX style authentication parameters. 
 *  
 * The system is very weak.  The client uses no encryption for it's
 * credentials and only sends null verifiers.  The server sends backs
 * null verifiers or optionally a verifier that suggests a new short hand
 * for the credentials.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include <rpc/types.h>
#include <rpc/xdr.h>
#include <rpc/rpc.h>
#include <rpc/auth.h>
#include <rpc/auth_unix.h>

/*
 * Unix authenticator operations vector
 */
static void	authunix_nextverf(struct __rpc_auth *);
static bool_t	authunix_marshal(struct __rpc_auth *, XDR *);
static bool_t	authunix_validate(struct __rpc_auth *, struct opaque_auth *);
static bool_t	authunix_refresh(struct __rpc_auth *);
static void	authunix_destroy(struct __rpc_auth *);

static struct auth_ops auth_unix_ops = {
	authunix_nextverf,
	authunix_marshal,
	authunix_validate,
	authunix_refresh,
	authunix_destroy
};

/*
 * This struct is pointed to by the ah_private field of an auth_handle.
 */
struct audata {
	struct opaque_auth	au_origcred;	/* original credentials */
	struct opaque_auth	au_shcred;	/* short hand cred */
	u_long			au_shfaults;	/* short hand cache faults */
	char			au_marshed[MAX_AUTH_BYTES];
	u_int			au_mpos;	/* xdr pos at end of marshed */
};
#define	AUTH_PRIVATE(auth)	((struct audata *)auth->ah_private)

static void marshal_new_auth(AUTH *auth);


/*
 * Create a unix style authenticator.
 * Returns an auth handle with the given stuff in it.
 */
AUTH *
authunix_create(char *machname, int uid, int gid, int len, int *aup_gids)
{
	struct authunix_parms aup;
	char mymem[MAX_AUTH_BYTES];
	struct timeval now;
	XDR xdrs;
	AUTH *auth;
	struct audata *au;

	/*
	 * Allocate and set up auth handle
	 */
	auth = (AUTH *)mem_alloc(sizeof(*auth));
#ifndef KERNEL
	if (auth == NULL)
		return (NULL);
#endif
	au = (struct audata *)mem_alloc(sizeof(*au));
#ifndef KERNEL
	if (au == NULL) {
		free(auth);
		return (NULL);
	}
#endif
	auth->ah_ops = &auth_unix_ops;
	auth->ah_private = (caddr_t)au;
	auth->ah_verf = au->au_shcred = _null_auth;
	au->au_shfaults = 0;

	/*
	 * fill in param struct from the given params
	 */
	(void)gettimeofday(&now,  NULL);
	aup.aup_time = now.tv_sec;
	aup.aup_machname = machname;
	aup.aup_uid = uid;
	aup.aup_gid = gid;
	aup.aup_len = (u_int)len;
	aup.aup_gids = aup_gids;

	/*
	 * Serialize the parameters into origcred
	 */
	xdrmem_create(&xdrs, mymem, MAX_AUTH_BYTES, XDR_ENCODE);
	if (!xdr_authunix_parms(&xdrs, &aup)) 
		goto authfail;	
	au->au_origcred.oa_length = len = XDR_GETPOS(&xdrs);
	au->au_origcred.oa_flavor = AUTH_UNIX;
#ifdef KERNEL
	au->au_origcred.oa_base = mem_alloc((u_int) len);
#else
	if ((au->au_origcred.oa_base = mem_alloc((u_int) len)) == NULL)
		goto authfail;	
#endif
	memcpy(au->au_origcred.oa_base, mymem, (u_int)len);

	/*
	 * set auth handle to reflect new cred.
	 */
	auth->ah_cred = au->au_origcred;
	marshal_new_auth(auth);
	return (auth);

authfail:
	XDR_DESTROY(&xdrs);
	free(au);
	free(auth);
	return (NULL);
}
DEF_WEAK(authunix_create);


/*
 * Some servers will refuse mounts if the group list is larger
 * than it expects (like 8). This allows the application to set
 * the maximum size of the group list that will be sent.
 */
static int maxgrplist = NGRPS;

void
set_rpc_maxgrouplist(int num)
{
	if (num < NGRPS)
		maxgrplist = num;
}

/*
 * Returns an auth handle with parameters determined by doing lots of
 * syscalls.
 */
AUTH *
authunix_create_default(void)
{
	int len, i;
	char machname[MAX_MACHINE_NAME + 1];
	uid_t uid;
	gid_t gid;
	gid_t gids[NGRPS];
	int gids2[NGRPS];

	if (gethostname(machname, sizeof machname) == -1)
		return (NULL);
	machname[MAX_MACHINE_NAME] = 0;
	uid = geteuid();
	gid = getegid();
	if ((len = getgroups(NGRPS, gids)) < 0)
		return (NULL);
	if (len > maxgrplist)
		len = maxgrplist;
	for (i = 0; i < len; i++)
		gids2[i] = gids[i];
	return (authunix_create(machname, uid, gid, len, gids2));
}
DEF_WEAK(authunix_create_default);

/*
 * authunix operations
 */
static void
authunix_nextverf(AUTH *auth)
{
	/* no action necessary */
}

static bool_t
authunix_marshal(AUTH *auth, XDR *xdrs)
{
	struct audata *au = AUTH_PRIVATE(auth);

	return (XDR_PUTBYTES(xdrs, au->au_marshed, au->au_mpos));
}

static bool_t
authunix_validate(AUTH *auth, struct opaque_auth *verf)
{
	struct audata *au;
	XDR xdrs;

	if (verf->oa_flavor == AUTH_SHORT) {
		au = AUTH_PRIVATE(auth);
		xdrmem_create(&xdrs, verf->oa_base, verf->oa_length, XDR_DECODE);

		if (au->au_shcred.oa_base != NULL) {
			mem_free(au->au_shcred.oa_base,
			    au->au_shcred.oa_length);
			au->au_shcred.oa_base = NULL;
		}
		if (xdr_opaque_auth(&xdrs, &au->au_shcred)) {
			auth->ah_cred = au->au_shcred;
		} else {
			xdrs.x_op = XDR_FREE;
			(void)xdr_opaque_auth(&xdrs, &au->au_shcred);
			au->au_shcred.oa_base = NULL;
			auth->ah_cred = au->au_origcred;
		}
		marshal_new_auth(auth);
	}
	return (TRUE);
}

static bool_t
authunix_refresh(AUTH *auth)
{
	struct audata *au = AUTH_PRIVATE(auth);
	struct authunix_parms aup;
	struct timeval now;
	XDR xdrs;
	int stat;

	if (auth->ah_cred.oa_base == au->au_origcred.oa_base) {
		/* there is no hope.  Punt */
		return (FALSE);
	}
	au->au_shfaults ++;

	/* first deserialize the creds back into a struct authunix_parms */
	aup.aup_machname = NULL;
	aup.aup_gids = NULL;
	xdrmem_create(&xdrs, au->au_origcred.oa_base,
	    au->au_origcred.oa_length, XDR_DECODE);
	stat = xdr_authunix_parms(&xdrs, &aup);
	if (! stat) 
		goto done;

	/* update the time and serialize in place */
	(void)gettimeofday(&now, NULL);
	aup.aup_time = now.tv_sec;
	xdrs.x_op = XDR_ENCODE;
	XDR_SETPOS(&xdrs, 0);
	stat = xdr_authunix_parms(&xdrs, &aup);
	if (! stat)
		goto done;
	auth->ah_cred = au->au_origcred;
	marshal_new_auth(auth);
done:
	/* free the struct authunix_parms created by deserializing */
	xdrs.x_op = XDR_FREE;
	(void)xdr_authunix_parms(&xdrs, &aup);
	XDR_DESTROY(&xdrs);
	return (stat);
}

static void
authunix_destroy(AUTH *auth)
{
	struct audata *au = AUTH_PRIVATE(auth);

	mem_free(au->au_origcred.oa_base, au->au_origcred.oa_length);

	if (au->au_shcred.oa_base != NULL)
		mem_free(au->au_shcred.oa_base, au->au_shcred.oa_length);

	mem_free(auth->ah_private, sizeof(struct audata));

	if (auth->ah_verf.oa_base != NULL)
		mem_free(auth->ah_verf.oa_base, auth->ah_verf.oa_length);

	mem_free((caddr_t)auth, sizeof(*auth));
}

/*
 * Marshals (pre-serializes) an auth struct.
 * sets private data, au_marshed and au_mpos
 */
static void
marshal_new_auth(AUTH *auth)
{
	XDR		xdr_stream;
	XDR	*xdrs = &xdr_stream;
	struct audata *au = AUTH_PRIVATE(auth);

	xdrmem_create(xdrs, au->au_marshed, MAX_AUTH_BYTES, XDR_ENCODE);
	if ((! xdr_opaque_auth(xdrs, &(auth->ah_cred))) ||
	    (! xdr_opaque_auth(xdrs, &(auth->ah_verf)))) {
		/* XXX nothing we can do */
	} else {
		au->au_mpos = XDR_GETPOS(xdrs);
	}
	XDR_DESTROY(xdrs);
}
@


1.25
log
@Wrap <rpc/*.h> so that calls go direct and the symbols are all weak.
Hide __xprt_register() and _authenticate(); truncate <rpc/svc_auth.h>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_unix.c,v 1.24 2015/09/02 06:47:19 deraadt Exp $ */
a209 1
/* ARGSUSED */
@


1.24
log
@Delete 3 more stderr messages, right before returning a proper error.
Code from way in the past.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_unix.c,v 1.23 2015/09/01 19:54:00 deraadt Exp $ */
d161 1
d205 1
@


1.23
log
@Remove all bogus writes to stderr.  Only explicit requests should
go that way.
ok miod beck
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_unix.c,v 1.22 2010/09/01 14:43:34 millert Exp $ */
d325 1
a325 1
		perror("auth_none.c - Fatal marshalling problem");
@


1.22
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_unix.c,v 1.21 2007/03/25 18:49:13 otto Exp $ */
d106 1
a106 2
	if (auth == NULL) {
		(void)fprintf(stderr, "authunix_create: out of memory\n");
a107 1
	}
a111 1
		(void)fprintf(stderr, "authunix_create: out of memory\n");
d143 1
a143 2
	if ((au->au_origcred.oa_base = mem_alloc((u_int) len)) == NULL) {
		(void)fprintf(stderr, "authunix_create: out of memory\n");
a144 1
	}
@


1.21
log
@eliminate call to abort(), which is very bad in libs. I forgat how
this diff came into my tree, apologies for not naming the contributor.
ok tedu@@ deraadt@@
@
text
@d1 2
a2 1
/*	$OpenBSD: auth_unix.c,v 1.20 2006/11/10 17:29:31 grunk Exp $ */
d4 5
a8 14
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
d10 22
a31 11
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a36 2
 * Copyright (C) 1984, Sun Microsystems, Inc.
 *
@


1.20
log
@add void set_rpc_maxgrouplist(int), to be able to make mount_nfs -g
working again.

help from millert@@, ok deraadt@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_unix.c,v 1.19 2005/08/08 08:05:35 espie Exp $ */
d139 1
a139 1
		abort();	/* XXX abort illegal in library */
d147 1
a147 4
		XDR_DESTROY(&xdrs);
		free(au);
		free(auth);
		return (NULL);
d158 6
@


1.19
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d163 15
d199 2
@


1.18
log
@ansify. ok deraadt@@ jaredy@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.17 2005/01/08 19:17:39 krw Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.17
log
@Bit of KNF - replace (<type> *)0 and (<type> *)NULL with NULL. Pointed
out by mickey@@, seconded by millert@@.

ok deraadt@@.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.16 2003/09/20 00:39:39 deraadt Exp $";
d86 1
a86 1
static void marshal_new_auth();
d94 1
a94 6
authunix_create(machname, uid, gid, len, aup_gids)
	char *machname;
	int uid;
	int gid;
	int len;
	int *aup_gids;
d171 1
a171 1
authunix_create_default()
d197 1
a197 2
authunix_nextverf(auth)
	AUTH *auth;
d203 1
a203 3
authunix_marshal(auth, xdrs)
	AUTH *auth;
	XDR *xdrs;
d211 1
a211 3
authunix_validate(auth, verf)
	AUTH *auth;
	struct opaque_auth *verf;
d239 1
a239 2
authunix_refresh(auth)
	AUTH *auth;
d281 1
a281 2
authunix_destroy(auth)
	AUTH *auth;
d303 1
a303 2
marshal_new_auth(auth)
	AUTH *auth;
@


1.16
log
@do not leak if mem_alloc fails
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.15 2002/01/02 23:00:10 deraadt Exp $";
d134 1
a134 1
	(void)gettimeofday(&now,  (struct timezone *)0);
d266 1
a266 1
	aup.aup_gids = (int *)NULL;
d274 1
a274 1
	(void)gettimeofday(&now, (struct timezone *)0);
@


1.15
log
@label abort() from inside library as ILLEGAL
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.14 2001/09/15 13:51:00 deraadt Exp $";
d155 3
@


1.14
log
@prototype cleanup
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.13 2001/03/03 06:50:28 deraadt Exp $";
d146 2
a147 2
	if (! xdr_authunix_parms(&xdrs, &aup)) 
		abort();
@


1.13
log
@plug many memory leaks
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.12 2000/08/24 17:03:20 deraadt Exp $";
d60 5
a64 5
static void	authunix_destroy();
static void	authunix_nextverf();
static bool_t	authunix_marshal();
static bool_t	authunix_refresh();
static bool_t	authunix_validate();
d98 1
a98 1
	register int len;
d105 2
a106 2
	register AUTH *auth;
	register struct audata *au;
d175 1
a175 1
	register int len, i;
d177 2
a178 2
	register uid_t uid;
	register gid_t gid;
d210 1
a210 1
	register struct audata *au = AUTH_PRIVATE(auth);
d217 1
a217 1
	register AUTH *auth;
d220 1
a220 1
	register struct audata *au;
d247 1
a247 1
	register AUTH *auth;
d249 1
a249 1
	register struct audata *au = AUTH_PRIVATE(auth);
d253 1
a253 1
	register int stat;
d290 1
a290 1
	register AUTH *auth;
d292 1
a292 1
	register struct audata *au = AUTH_PRIVATE(auth);
d313 1
a313 1
	register AUTH *auth;
d316 2
a317 2
	register XDR	*xdrs = &xdr_stream;
	register struct audata *au = AUTH_PRIVATE(auth);
@


1.12
log
@fix includes
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.11 1998/12/20 23:45:41 millert Exp $";
d122 1
@


1.11
log
@alphabetize function forward decls for prettiness
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.10 1998/07/09 06:11:56 deraadt Exp $";
d53 1
@


1.10
log
@clarify gethostname() call
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.9 1997/11/08 20:51:23 deraadt Exp $";
d59 1
d62 1
a63 2
static bool_t	authunix_refresh();
static void	authunix_destroy();
@


1.9
log
@avoid more abort()
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.8 1997/07/17 06:36:46 deraadt Exp $";
d180 1
a180 1
	if (gethostname(machname, MAX_MACHINE_NAME) == -1)
@


1.8
log
@verf is a ptr
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.7 1996/12/14 06:49:40 tholo Exp $";
d181 1
a181 1
		abort();
d186 1
a186 1
		abort();
@


1.7
log
@Clean up lint and compile warnings
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.6 1996/11/14 05:45:16 etheisen Exp $";
d216 1
a216 1
	struct opaque_auth verf;
d221 1
a221 1
	if (verf.oa_flavor == AUTH_SHORT) {
d223 1
a223 1
		xdrmem_create(&xdrs, verf.oa_base, verf.oa_length, XDR_DECODE);
@


1.6
log
@memcpy needs proto from string.h.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.5 1996/09/15 09:31:29 tholo Exp $";
d173 1
a173 1
	register int len;
d178 1
d187 3
a189 1
	return (authunix_create(machname, uid, gid, len, gids));
@


1.5
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.4 1996/08/19 08:31:21 tholo Exp $";
d49 1
@


1.4
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.3 1996/07/20 06:12:17 deraadt Exp $";
d191 1
a191 1

@


1.3
log
@bcopy->memcpy & tag
@
text
@a0 3
/*	$OpenBSD: auth_unix.c,v 1.2 1995/02/25 03:01:35 cgd Exp $	*/
/*	$NetBSD: auth_unix.c,v 1.2 1995/02/25 03:01:35 cgd Exp $	*/

d31 2
a32 4
/*static char *sccsid = "from: @@(#)auth_unix.c 1.19 87/08/11 Copyr 1984 Sun Micro";*/
/*static char *sccsid = "from: @@(#)auth_unix.c	2.2 88/08/01 4.0 RPCSRC";*/
static char *rcsid = "$OpenBSD: auth_unix.c,v 1.2 1995/02/25 03:01:35 cgd Exp $";
#endif
@


1.2
log
@Pull prototypes into scope
Remove graticious casts
@
text
@d1 1
d36 1
a36 1
static char *rcsid = "$NetBSD: auth_unix.c,v 1.2 1995/02/25 03:01:35 cgd Exp $";
d160 1
a160 1
	bcopy(mymem, au->au_origcred.oa_base, (u_int)len);
@


1.1
log
@Initial revision
@
text
@d52 1
d88 1
a88 1
static bool_t marshal_new_auth();
d178 3
a180 3
	register int uid;
	register int gid;
	int gids[NGRPS];
d309 1
a309 1
static bool_t
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
