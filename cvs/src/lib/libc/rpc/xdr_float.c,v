head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.8
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.4
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.14
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.10
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.10
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.8
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.6
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.03.09.16.28.47;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	OSDG2O3Cgeifnf1W;

1.22
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	0DYulI8hhujBHMcR;

1.21
date	2014.07.21.01.51.11;	author guenther;	state Exp;
branches;
next	1.20;
commitid	ro8JUTvBpvQMiFY9;

1.20
date	2011.07.26.11.43.01;	author martynas;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.26.09.36.25;	author martynas;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.25.15.54.12;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.10.22.03.21;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.08.08.05.36;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.05.08.39.10;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.01.07.44.04;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.01.07.11.24;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.28.01.51.39;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.15.13.51.01;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.30.04.58.23;	author bjc;	state Exp;
branches;
next	1.8;

1.8
date	98.08.28.20.29.51;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.03.25.17.07.29;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	97.02.21.19.35.33;	author gvf;	state Exp;
branches;
next	1.5;

1.5
date	96.12.21.21.08.17;	author rahnds;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.08.32.03;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.03.19.23.30.28;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.03.19.23.15.09;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@We are done providing support for the vax.
lots of agreement.
@
text
@/*	$OpenBSD: xdr_float.c,v 1.22 2015/01/16 16:48:51 deraadt Exp $ */

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * xdr_float.c, Generic XDR routines implementation.
 *
 * These are the "floating point" xdr routines used to (de)serialize
 * most common data items.  See xdr.h for more info on the interface to
 * xdr.
 */

#include <stdio.h>
#include <sys/types.h>
#include <rpc/types.h>
#include <rpc/xdr.h>

/*
 * NB: Not portable.
 * This routine works on machines with IEEE754 FP.
 */

#include <endian.h>

bool_t
xdr_float(XDR *xdrs, float *fp)
{
	bool_t rv;
	long tmpl;
	switch (xdrs->x_op) {

	case XDR_ENCODE:
		tmpl = *(int32_t *)fp;
		return (XDR_PUTLONG(xdrs, &tmpl));

	case XDR_DECODE:
		rv = XDR_GETLONG(xdrs, &tmpl);
		*(int32_t *)fp = tmpl;
		return (rv);

	case XDR_FREE:
		return (TRUE);
	}
	return (FALSE);
}

bool_t
xdr_double(XDR *xdrs, double *dp)
{
	int32_t *i32p;
	bool_t rv;
	long tmpl;

	switch (xdrs->x_op) {

	case XDR_ENCODE:
		i32p = (int32_t *)dp;
#if (BYTE_ORDER == BIG_ENDIAN) || (defined(__arm__) && !defined(__VFP_FP__))
		tmpl = *i32p++;
		rv = XDR_PUTLONG(xdrs, &tmpl);
		if (!rv)
			return (rv);
		tmpl = *i32p;
		rv = XDR_PUTLONG(xdrs, &tmpl);
#else
		tmpl = *(i32p+1);
		rv = XDR_PUTLONG(xdrs, &tmpl);
		if (!rv)
			return (rv);
		tmpl = *i32p;
		rv = XDR_PUTLONG(xdrs, &tmpl);
#endif
		return (rv);

	case XDR_DECODE:
		i32p = (int32_t *)dp;
#if (BYTE_ORDER == BIG_ENDIAN) || (defined(__arm__) && !defined(__VFP_FP__))
		rv = XDR_GETLONG(xdrs, &tmpl);
		*i32p++ = tmpl;
		if (!rv)
			return (rv);
		rv = XDR_GETLONG(xdrs, &tmpl);
		*i32p = tmpl;
#else
		rv = XDR_GETLONG(xdrs, &tmpl);
		*(i32p+1) = tmpl;
		if (!rv)
			return (rv);
		rv = XDR_GETLONG(xdrs, &tmpl);
		*i32p = tmpl;
#endif
		return (rv);

	case XDR_FREE:
		return (TRUE);
	}
	return (FALSE);
}
@


1.22
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr_float.c,v 1.21 2014/07/21 01:51:11 guenther Exp $ */
d49 1
a49 1
 * This routine works on machines with IEEE754 FP and Vaxen.
a51 31
#ifdef __vax__

/* What IEEE single precision floating point looks like on a Vax */
struct	ieee_single {
	unsigned int	mantissa: 23;
	unsigned int	exp     : 8;
	unsigned int	sign    : 1;
};

/* Vax single precision floating point */
struct	vax_single {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
};

#define VAX_SNG_BIAS	0x81
#define IEEE_SNG_BIAS	0x7f

static struct sgl_limits {
	struct vax_single s;
	struct ieee_single ieee;
} sgl_limits[2] = {
	{{ 0x7f, 0xff, 0x0, 0xffff },	/* Max Vax */
	{ 0x0, 0xff, 0x0 }},		/* Max IEEE */
	{{ 0x0, 0x0, 0x0, 0x0 },	/* Min Vax */
	{ 0x0, 0x0, 0x0 }}		/* Min IEEE */
};

#else
a52 2
#define IEEEFP
#endif
a56 1
#ifdef IEEEFP
a58 6
#else
	struct ieee_single is;
	struct vax_single vs, *vsp;
	struct sgl_limits *lim;
	int i;
#endif
a61 1
#ifdef IEEEFP 
a63 18
#else
		vs = *((struct vax_single *)fp);
		for (i = 0, lim = sgl_limits;
			i < sizeof(sgl_limits)/sizeof(struct sgl_limits);
			i++, lim++) {
			if ((vs.mantissa2 == lim->s.mantissa2) &&
				(vs.exp == lim->s.exp) &&
				(vs.mantissa1 == lim->s.mantissa1)) {
				is = lim->ieee;
				goto shipit;
			}
		}
		is.exp = vs.exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
		is.mantissa = (vs.mantissa1 << 16) | vs.mantissa2;
	shipit:
		is.sign = vs.sign;
		return (XDR_PUTLONG(xdrs, (long *)&is));
#endif
a65 1
#ifdef IEEEFP
a68 20
#else
		vsp = (struct vax_single *)fp;
		if (!XDR_GETLONG(xdrs, (long *)&is))
			return (FALSE);
		for (i = 0, lim = sgl_limits;
			i < sizeof(sgl_limits)/sizeof(struct sgl_limits);
			i++, lim++) {
			if ((is.exp == lim->ieee.exp) &&
				(is.mantissa == lim->ieee.mantissa)) {
				*vsp = lim->s;
				goto doneit;
			}
		}
		vsp->exp = is.exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
		vsp->mantissa2 = is.mantissa;
		vsp->mantissa1 = (is.mantissa >> 16);
	doneit:
		vsp->sign = is.sign;
		return (TRUE);
#endif
a75 36
#ifdef __vax__
/* What IEEE double precision floating point looks like on a Vax */
struct	ieee_double {
	unsigned int	mantissa1 : 20;
	unsigned int	exp       : 11;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 32;
};

/* Vax double precision floating point */
struct  vax_double {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
	unsigned int	mantissa3 : 16;
	unsigned int	mantissa4 : 16;
};

#define VAX_DBL_BIAS	0x81
#define IEEE_DBL_BIAS	0x3ff
#define MASK(nbits)	((1 << nbits) - 1)

static struct dbl_limits {
	struct	vax_double d;
	struct	ieee_double ieee;
} dbl_limits[2] = {
	{{ 0x7f, 0xff, 0x0, 0xffff, 0xffff, 0xffff },	/* Max Vax */
	{ 0x0, 0x7ff, 0x0, 0x0 }},			/* Max IEEE */
	{{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},		/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0 }}				/* Min IEEE */
};

#endif /* __vax__ */


a78 1
#ifdef IEEEFP
a81 7
#else
	long *lp;
	struct	ieee_double id;
	struct	vax_double vd;
	struct dbl_limits *lim;
	int i;
#endif
a85 1
#ifdef IEEEFP
a102 24
#else
		vd = *((struct vax_double *)dp);
		for (i = 0, lim = dbl_limits;
			i < sizeof(dbl_limits)/sizeof(struct dbl_limits);
			i++, lim++) {
			if ((vd.mantissa4 == lim->d.mantissa4) &&
				(vd.mantissa3 == lim->d.mantissa3) &&
				(vd.mantissa2 == lim->d.mantissa2) &&
				(vd.mantissa1 == lim->d.mantissa1) &&
				(vd.exp == lim->d.exp)) {
				id = lim->ieee;
				goto shipit;
			}
		}
		id.exp = vd.exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
		id.mantissa1 = (vd.mantissa1 << 13) | (vd.mantissa2 >> 3);
		id.mantissa2 = ((vd.mantissa2 & MASK(3)) << 29) |
				(vd.mantissa3 << 13) |
				((vd.mantissa4 >> 3) & MASK(13));
	shipit:
		id.sign = vd.sign;
		lp = (long *)&id;
		return (XDR_PUTLONG(xdrs, lp++) && XDR_PUTLONG(xdrs, lp));
#endif
a104 1
#ifdef IEEEFP
a121 25
#else
		lp = (long *)&id;
		if (!XDR_GETLONG(xdrs, lp++) || !XDR_GETLONG(xdrs, lp))
			return (FALSE);
		for (i = 0, lim = dbl_limits;
			i < sizeof(dbl_limits)/sizeof(struct dbl_limits);
			i++, lim++) {
			if ((id.mantissa2 == lim->ieee.mantissa2) &&
				(id.mantissa1 == lim->ieee.mantissa1) &&
				(id.exp == lim->ieee.exp)) {
				vd = lim->d;
				goto doneit;
			}
		}
		vd.exp = id.exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
		vd.mantissa1 = (id.mantissa1 >> 13);
		vd.mantissa2 = ((id.mantissa1 & MASK(13)) << 3) |
				(id.mantissa2 >> 29);
		vd.mantissa3 = (id.mantissa2 >> 13);
		vd.mantissa4 = (id.mantissa2 << 3);
	doneit:
		vd.sign = id.sign;
		*dp = *((double *)&vd);
		return (TRUE);
#endif
@


1.21
log
@Switch from <sys/endian.h> or <machine/endian.h> to the new,
being-standardized <endian.h>

ok deraadt@@ millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr_float.c,v 1.20 2011/07/26 11:43:01 martynas Exp $ */
a43 1
#include <sys/param.h>
@


1.20
log
@At some point we've switched to the VFP floating-point--unlike FPA
it actually stores floats in natural-endian--therefore the existing
checks became wrong.

Take into account __VFP_FP__, effectively bringing back the old
behavior.  This way it will work now, and in the future when some
of our platforms are switched to FPA, where it's much faster.
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr_float.c,v 1.19 2011/07/26 09:36:25 martynas Exp $ */
d84 1
a84 1
#include <machine/endian.h>
@


1.19
log
@Assumptions about floating-point word order based on BYTE_ORDER are
wrong on ARM.  A more elegant solution is pending, but this is good
for now.  OK miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr_float.c,v 1.18 2010/09/01 14:43:34 millert Exp $ */
d213 1
a213 1
#if (BYTE_ORDER == BIG_ENDIAN) || defined(__arm__)
d257 1
a257 1
#if (BYTE_ORDER == BIG_ENDIAN) || defined(__arm__)
@


1.18
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr_float.c,v 1.17 2008/06/25 15:54:12 deraadt Exp $ */
d213 1
a213 1
#if BYTE_ORDER == BIG_ENDIAN
d257 1
a257 1
#if BYTE_ORDER == BIG_ENDIAN
@


1.17
log
@Change a very long selective list of all architectures which do IEEE into
just handling the vax different (just vax for now, 'cause tahoe might even
be too legacy for Miod)
ok miod
@
text
@d1 2
a2 1
/*	$OpenBSD: xdr_float.c,v 1.16 2006/10/10 22:03:21 miod Exp $ */
d4 28
a31 26
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a35 2
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
@


1.16
log
@Teach'em about cpus in spandex
@
text
@d1 1
a1 1
/*	$OpenBSD: xdr_float.c,v 1.15 2005/08/08 08:05:36 espie Exp $ */
a51 8
#if defined(__m68k__) || defined(__sparc__) || defined(__i386__) || \
    defined(__mips__) || defined(__ns32k__) || defined(__alpha__) || \
    defined(__arm__) || defined(__powerpc__) || defined(__m88k__) || \
    defined(__hppa__) || defined(__x86_64__) || defined(__sh__)
#include <machine/endian.h>
#define IEEEFP
#endif

d81 5
a85 1
#endif /* __vax__ */
@


1.15
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d55 1
a55 1
    defined(__hppa__) || defined(__x86_64__)
@


1.14
log
@impelmentation -> implementation

yes, new typo for an old friend.
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.13 2005/04/01 07:44:04 otto Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.13
log
@ansify. ok deraadt@@ jaredy@@
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.12 2004/02/01 07:11:24 drahn Exp $";
d35 1
a35 1
 * xdr_float.c, Generic XDR routines impelmentation.
@


1.12
log
@s/arm32/arm/ with VFP bit to match netbsd.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.11 2004/01/28 01:51:39 mickey Exp $";
d95 1
a95 3
xdr_float(xdrs, fp)
	XDR *xdrs;
	float *fp;
d200 1
a200 3
xdr_double(xdrs, dp)
	XDR *xdrs;
	double *dp;
@


1.11
log
@the rest of the libs stuff; from art@@ again
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.10 2001/09/15 13:51:01 deraadt Exp $";
d57 1
a57 1
    defined(__arm32__) || defined(__powerpc__) || defined(__m88k__) || \
@


1.10
log
@prototype cleanup
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.9 2000/04/30 04:58:23 bjc Exp $";
d58 1
a58 1
    defined(__hppa__)
@


1.9
log
@#ifdef vax -> #ifdef __vax__
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.8 1998/08/28 20:29:51 mickey Exp $";
d96 2
a97 2
	register XDR *xdrs;
	register float *fp;
d203 1
a203 1
	register XDR *xdrs;
d207 1
a207 1
	register int32_t *i32p;
d211 1
a211 1
	register long *lp;
d214 1
a214 1
	register struct dbl_limits *lim;
@


1.8
log
@hppa is ieee fp too
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.7 1997/03/25 17:07:29 rahnds Exp $";
d63 1
a63 1
#ifdef vax
d92 1
a92 1
#endif /* vax */
d165 1
a165 1
#ifdef vax
d198 1
a198 1
#endif /* vax */
@


1.7
log
@Ok here is the mvme88k userland, minus a few important pieces.
as, ld change need to be merged. It is known that shared libraries and C++
do not work.
If anyone wants to step forward and take over the mvme88k port please do.
It was dumped on me when the original developer, Nivas, left his previous
job and started a new one.

I am trying to get the port in a shape that someone could take over.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.6 1997/02/21 19:35:33 gvf Exp $";
d57 2
a58 1
    defined(__arm32__) || defined(__powerpc__) || defined(__m88k__)
@


1.6
log
@sync to __powerpc__
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.5 1996/12/21 21:08:17 rahnds Exp $";
d57 1
a57 1
    defined(__arm32__) || defined(__powerpc__)
@


1.5
log
@Change to support the powerpc port. To bad this define isn't put in
a machine header, such as machine/endian.h so that every new
architecture would not have to modify this file.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.4 1996/08/19 08:32:03 tholo Exp $";
d57 1
a57 1
    defined(__arm32__) || defined(__ppc__)
@


1.4
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.3 1996/03/19 23:30:28 niklas Exp $";
d57 1
a57 1
    defined(__arm32__)
@


1.3
log
@Fix RCS Id botch in last change
@
text
@a0 3
/*	$OpenBSD: xdr_float.c,v 1.2 1996/03/19 23:15:09 niklas Exp $	*/
/*	$NetBSD: xdr_float.c,v 1.10 1996/02/16 21:14:03 mark Exp $	*/

d31 2
a32 4
/*static char *sccsid = "from: @@(#)xdr_float.c 1.12 87/08/11 Copyr 1984 Sun Micro";*/
/*static char *sccsid = "from: @@(#)xdr_float.c	2.1 88/07/29 4.0 RPCSRC";*/
static char *rcsid = "$OpenBSD: xdr_float.c,v 1.2 1996/03/19 23:15:09 niklas Exp $";
#endif
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 2
static char *rcsid = "$OpenBSD$";
static char *rcsid = "$NetBSD: xdr_float.c,v 1.10 1996/02/16 21:14:03 mark Exp $";
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: xdr_float.c,v 1.9 1995/06/05 11:48:26 pk Exp $	*/
d36 2
a37 1
static char *rcsid = "$NetBSD: xdr_float.c,v 1.9 1995/06/05 11:48:26 pk Exp $";
d62 2
a63 1
    defined(__mips__) || defined(__ns32k__) || defined(__alpha__)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
