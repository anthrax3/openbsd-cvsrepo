head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.2
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.26.0.8
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.10
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.8
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.12
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.10
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.8
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.6
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.4
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@.\" @;


1.27
date	2017.06.10.13.24.03;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	jDGeU1qDa03DvdDz;

1.26
date	2015.11.10.23.48.18;	author jmc;	state Exp;
branches;
next	1.25;
commitid	QU70QaxjyBAtj4Rv;

1.25
date	2014.01.21.03.15.45;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.05.03.39.23;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.27.11.31.58;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.07.19.52.37;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.07.14.59.41;	author marco;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.13.23.39.26;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.31.19.19.30;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.22.03.23.37;	author jaredy;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.08.09.26.02;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.30.22.12.43;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.18.07.47.00;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.18.03.01.34;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	99.07.09.13.35.22;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	99.07.05.06.08.05;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	99.05.25.21.16.25;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	99.05.25.13.06.46;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	98.09.06.22.23.19;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	98.03.11.18.54.17;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.02.24.12.57.52;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.02.24.11.13.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.02.24.11.05.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.32.00;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.07.20.06.12.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@fix a sentence that used unusual terminology, the wrong macro,
and broken delimiter syntax; found with mandoc -Tlint
@
text
@.\"	$OpenBSD: xdr.3,v 1.26 2015/11/10 23:48:18 jmc Exp $
.\" Mostly converted to mandoc by Theo de Raadt, Tue Feb 24 04:04:46 MST 1998
.\"
.\" Copyright (c) 2010, Oracle America, Inc.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions are
.\" met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"     * Redistributions in binary form must reproduce the above
.\"       copyright notice, this list of conditions and the following
.\"       disclaimer in the documentation and/or other materials
.\"       provided with the distribution.
.\"     * Neither the name of the "Oracle America, Inc." nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\"   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\"   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\"   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
.\"   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
.\"   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
.\"   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\"   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
.\"   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\"   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
.\"   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
.\"   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\"   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: November 10 2015 $
.Dt XDR_ARRAY 3
.Os
.Sh NAME
.Nm xdr_array ,
.Nm xdr_bool ,
.Nm xdr_bytes ,
.Nm xdr_char ,
.Nm xdr_destroy ,
.Nm xdr_double ,
.Nm xdr_enum ,
.Nm xdr_float ,
.Nm xdr_free ,
.Nm xdr_getpos ,
.Nm xdr_inline ,
.Nm xdr_int ,
.Nm xdr_long ,
.Nm xdr_int64_t ,
.Nm xdrmem_create ,
.Nm xdr_opaque ,
.Nm xdr_pointer ,
.Nm xdrrec_create ,
.Nm xdrrec_endofrecord ,
.Nm xdrrec_eof ,
.Nm xdrrec_skiprecord ,
.Nm xdr_reference ,
.Nm xdr_setpos ,
.Nm xdr_short ,
.Nm xdrstdio_create ,
.Nm xdr_string ,
.Nm xdr_u_char ,
.Nm xdr_u_int ,
.Nm xdr_u_long ,
.Nm xdr_u_int64_t ,
.Nm xdr_u_short ,
.Nm xdr_union ,
.Nm xdr_vector ,
.Nm xdr_void ,
.Nm xdr_wrapstring
.Nd library routines for external data representation
.Sh SYNOPSIS
.In sys/types.h
.In rpc/xdr.h
.Ft int
.Fn xdr_array "XDR *xdrs" "char **arrp" "u_int *sizep" "u_int maxsize" "u_int elsize" "xdrproc_t elproc"
.Ft int
.Fn xdr_bool "XDR *xdrs" "bool_t *bp"
.Ft int
.Fn xdr_bytes "XDR *xdrs" "char **sp" "u_int *sizep" "u_int maxsize"
.Ft int
.Fn xdr_char "XDR *xdrs" "char *cp"
.Ft void
.Fn xdr_destroy "XDR *xdrs"
.Ft int
.Fn xdr_double "XDR *xdrs" "double *dp"
.Ft int
.Fn xdr_enum "XDR *xdrs" "enum_t *ep"
.Ft int
.Fn xdr_float "XDR *xdrs" "float *fp"
.Ft void
.Fn xdr_free "xdrproc_t proc" "char *objp"
.Ft u_int
.Fn xdr_getpos "XDR *xdrs"
.Ft long *
.Fn xdr_inline "XDR *xdrs" "int len"
.Ft int
.Fn xdr_int "XDR *xdrs" "int *ip"
.Ft int
.Fn xdr_long "XDR *xdrs" "long *lp"
.Ft int
.Fn xdr_int64_t "XDR *xdrs" "int64_t *lp"
.Ft void
.Fn xdrmem_create "XDR *xdrs" "char *addr" "u_int size" "enum xdr_op op"
.Ft int
.Fn xdr_opaque "XDR *xdrs" "char *cp" "u_int cnt"
.Ft int
.Fn xdr_pointer "XDR *xdrs" "char **objpp" "u_int objsize" "xdrproc_t xdrobj"
.Ft void
.Fn xdrrec_create "XDR *xdrs" "u_int sendsize" "u_int recvsize" "char *handle" "int (*readit)()" "int (*writeit)()"
.Ft int
.Fn xdrrec_endofrecord "XDR *xdrs" "int sendnow"
.Ft int
.Fn xdrrec_eof "XDR *xdrs"
.Ft int
.Fn xdrrec_skiprecord "XDR *xdrs"
.Ft int
.Fn xdr_reference "XDR *xdrs" "char **pp" "u_int size" "xdrproc_t proc"
.Ft int
.Fn xdr_setpos "XDR *xdrs" "u_int pos"
.Ft int
.Fn xdr_short "XDR *xdrs" "short *sp"
.Ft void
.Fn xdrstdio_create "XDR *xdrs" "FILE *file" "enum xdr_op op"
.Ft int
.Fn xdr_string "XDR *xdrs" "char **sp" "u_int maxsize"
.Ft int
.Fn xdr_u_char "XDR *xdrs" "unsigned char *ucp"
.Ft int
.Fn xdr_u_int "XDR *xdrs" "unsigned int *up"
.Ft int
.Fn xdr_u_long "XDR *xdrs" "unsigned long *ulp"
.Ft int
.Fn xdr_u_int64_t "XDR *xdrs" "u_int64_t *ullp"
.Ft int
.Fn xdr_u_short "XDR *xdrs" "unsigned short *usp"
.Ft int
.Fn xdr_union "XDR *xdrs" "int *dscmp" "char *unp" "struct xdr_discrim *choices" "bool_t (*defaultarm)()"
.Ft int
.Fn xdr_vector "XDR *xdrs" "char *arrp" "u_int size" "u_int elsize" "xdrproc_t elproc"
.Ft int
.Fn xdr_void "void"
.Ft int
.Fn xdr_wrapstring "XDR *xdrs" "char **sp"
.Sh DESCRIPTION
These routines allow C programmers to describe
arbitrary data structures in a machine-independent fashion.
Data for remote procedure calls are transmitted using these
routines.
.Pp
.Fn xdr_array
is a filter primitive that translates between variable-length arrays
and their corresponding external representations.
The parameter
.Fa arrp
is the address of the pointer to the array, while
.Fa sizep
is the address of the element count of the array;
this element count cannot exceed
.Fa maxsize .
The parameter
.Fa elsize
is the size of each of the array's elements, and
.Fa elproc
is an XDR filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_bool
is a filter primitive that translates between booleans (C integers)
and their external representations.
When encoding data, this
filter produces values of either one or zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_bytes
is a filter primitive that translates between counted byte
strings and their external representations.
The parameter
.Fa sp
is the address of the string pointer.
The length of the string is located at address
.Fa sizep ;
strings cannot be longer than
.Fa maxsize .
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_char
is a filter primitive that translates between C characters
and their external representations.
This routine returns one if it succeeds, zero otherwise.
Note: encoded characters are not packed, and occupy 4 bytes each.
For arrays of characters, it is worthwhile to consider
.Fn xdr_bytes ,
.Fn xdr_opaque ,
or
.Fn xdr_string .
.Pp
.Fn xdr_destroy
is a macro that invokes the destroy routine associated with the XDR stream
.Fa xdrs .
Destruction usually involves freeing private data structures
associated with the stream.
Using
.Fa xdrs
after invoking
.Fn xdr_destroy
is undefined.
.Pp
.Fn xdr_double
is a filter primitive that translates between C
.Li double
precision numbers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_enum
is a filter primitive that translates between the C
.Li enum
type (actually an integer) and its external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_float
is a filter primitive that translates between the C
.Li float
type and its external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_free
is a generic freeing routine.
The first argument is the XDR routine for the object being freed.
The second argument
is a pointer to the object itself.
Note: the pointer passed to this routine is
.Fa not
freed, but what it points to is freed (recursively).
.Pp
.Fn xdr_getpos
is a macro that invokes the get-position routine associated with the XDR
stream
.Fa xdrs .
The routine returns an unsigned integer,
which indicates the position of the XDR byte stream.
A desirable feature of XDR
streams is that simple arithmetic works with this number,
although the XDR stream instances need not guarantee this.
.Pp
.Fn xdr_inline
is a macro that invokes the in-line routine associated with the XDR stream
.Fa xdrs .
The routine returns a pointer
to a contiguous piece of the stream's buffer;
.Fa len
is the byte length of the desired buffer.
Note: pointer is cast to
.Li long * .
Warning:
.Fn xdr_inline
may return
.Dv NULL
if it cannot allocate a contiguous piece of a buffer.
Therefore the behavior may vary among stream instances;
it exists for the sake of efficiency.
.Pp
.Fn xdr_int
is a filter primitive that translates between C integers
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_long
is a filter primitive that translates between C
.Li long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_int64_t
is a filter primitive that translates between C
.Li int64_t
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdrmem_create
is a routine which initializes the XDR stream object pointed to by
.Fa xdrs .
The stream's data is written to, or read from,
a chunk of memory at location
.Fa addr
whose length is no more than
.Fa size
bytes long.
The
.Fa op
determines the direction of the XDR stream
(either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
.Pp
.Fn xdr_opaque
is a filter primitive that translates between fixed size opaque
data
and its external representation.
The parameter
.Fa cp
is the address of the opaque object, and
.Fa cnt
is its size in bytes.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_pointer
is like
.Fn xdr_reference
except that it serializes
.Dv NULL
pointers, whereas
.Fn xdr_reference
does not.
Thus,
.Fn xdr_pointer
can represent
recursive data structures, such as binary trees or
linked lists.
.Pp
.Fn xdrrec_create
is a routine which initializes the XDR stream object pointed to by
.Fa xdrs .
The stream's data is written to a buffer of size
.Fa sendsize ;
a value of zero indicates the system should use a suitable
default.
The stream's data is read from a buffer of size
.Fa recvsize ;
it too can be set to a suitable default by passing a zero
value.
When a stream's output buffer is full,
.Fn (*writeit)
is called.
Similarly, when a stream's input buffer is empty,
.Fn (*readit)
is called.
The behavior of these two routines is similar to the system calls
.Fn read
and
.Fn write ,
except that
.Fa handle
is passed to the former routines as the first parameter.
Note: the XDR stream's
.Fa op
field must be set by the caller.
Warning: this XDR stream implements an intermediate record stream.
Therefore there are additional bytes in the stream
to provide record boundary information.
.Pp
.Fn xdrrec_endofrecord
is a routine which can be invoked only on
streams created by
.Fn xdrrec_create .
The data in the output buffer is marked as a completed record,
and the output buffer is optionally written out if
.Fa sendnow
is non-zero.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdrrec_eof
is a routine which can be invoked only on
streams created by
.Fn xdrrec_create .
After consuming the rest of the current record in the stream,
this routine returns one if the stream has no more input,
zero otherwise.
.Pp
.Fn xdrrec_skiprecord
is a routine which can be invoked only on
streams created by
.Fn xdrrec_create .
It tells the XDR implementation that the rest of the current record
in the stream's input buffer should be discarded.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_reference
is a primitive that provides pointer chasing within structures.
The parameter
.Fa pp
is the address of the pointer;
.Fa size
is the size of the structure that
.Fa *pp
points to; and
.Fa proc
is an XDR procedure that filters the structure
between its C form and its external representation.
This routine returns one if it succeeds, zero otherwise.
Warning: this routine does not understand
.Dv NULL
pointers.
Use
.Fn xdr_pointer
instead.
.Pp
.Fn xdr_setpos
is a macro that invokes the set position routine associated with the XDR
stream
.Fa xdrs .
The parameter
.Fa pos
is a position value obtained from
.Fn xdr_getpos .
This routine returns one if the XDR stream could be repositioned,
and zero otherwise.
Warning: it is difficult to reposition some types of XDR
streams, so this routine may fail with one
type of stream and succeed with another.
.Pp
.Fn xdr_short
is a filter primitive that translates between C
.Li short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdrstdio_create
is a routine which initializes the XDR stream object pointed to by
.Fa xdrs .
The XDR stream data is written to, or read from, the Standard I/O
stream
.Fa file .
The parameter
.Fa op
determines the direction of the XDR stream (either
.Dv XDR_ENCODE ,
.Dv XDR_DECODE ,
or
.Dv XDR_FREE ) .
Warning: the destroy routine associated with such XDR streams calls
.Fn fflush
on the
.Fa file
stream, but never
.Fn fclose .
.Pp
.Fn xdr_string
is a filter primitive that translates between C strings and their
corresponding external representations.
Strings cannot be longer than
.Fa maxsize .
Note:
.Fa sp
is the address of the string's pointer.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_u_char
is a filter primitive that translates between
.Li unsigned
C characters and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_u_int
is a filter primitive that translates between C
.Li unsigned
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_u_long
is a filter primitive that translates between C
.Li unsigned long
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_u_int64_t
is a filter primitive that translates between C
.Li u_int64_t
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_u_short
is a filter primitive that translates between C
.Li unsigned short
integers and their external representations.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_union
is a filter primitive that translates between a discriminated C
.Li union
and its corresponding external representation.
It first translates the discriminant of the union located at
.Fa dscmp .
This discriminant is always an
.Li enum_t .
Next the union located at
.Fa unp
is translated.
The parameter
.Fa choices
is a pointer to an array of
.Li struct xdr_discrim
structures, containing the two members
.Fa value
and
.Fa proc .
If the union's discriminant is equal to the associated
.Fa value ,
then the
.Fa proc
is called to translate the union.
The end of the
.Li struct xdr_discrim
structure array is denoted by a routine of value
.Dv NULL .
If the discriminant is not found in the
.Fa choices
array, then the
.Fn (*defaultarm)
procedure is called (if it is not
.Dv NULL ) .
Returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_vector
is a filter primitive that translates between fixed-length arrays
and their corresponding external representations.
The parameter
.Fa arrp
is the address of the pointer to the array, while
.Fa size
is the element count of the array.
The parameter
.Fa elsize
is the size of each of the array's elements, and
.Fa elproc
is an XDR
filter that translates between the array elements' C form, and their
external representation.
This routine returns one if it succeeds, zero otherwise.
.Pp
.Fn xdr_void
is a routine which always returns one.
It may be passed to RPC
routines that require a function parameter, but where nothing is to be done.
.Pp
.Fn xdr_wrapstring
is a primitive that calls
.Nm xdr_string Ns Pq Fa xdrs , sp , Dv MAXUN.UNSIGNED
where
.Dv MAXUN.UNSIGNED
is the maximum value of an unsigned integer.
.Fn xdr_wrapstring
is handy because the RPC package passes a maximum of two XDR
routines as parameters, and
.Fn xdr_string ,
one of the most frequently used primitives, requires three.
Returns one if it succeeds, zero otherwise.
.Sh SEE ALSO
.Xr rpc 3
.Rs
.%T eXternal Data Representation Standard: Protocol Specification
.Re
.Rs
.%T eXternal Data Representation: Sun Technical Notes
.Re
.Sh STANDARDS
.Rs
.%D June 1987
.%Q Sun Microsystems, Inc.
.%R RFC 1014
.%T XDR: External Data Representation Standard
.Re
@


1.26
log
@update NAME section to include all documented functions,
or otherwise change Dt to reflect the name of an existing function;

feedback/ok schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.25 2014/01/21 03:15:45 schwarze Exp $
d33 1
a33 1
.Dd $Mdocdate: January 21 2014 $
d498 4
a501 3
structures.
Each structure contains an ordered pair of
.Ft [ value , proc ].
@


1.25
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.24 2013/06/05 03:39:23 tedu Exp $
d33 2
a34 2
.Dd $Mdocdate: June 5 2013 $
.Dt XDR 3
@


1.24
log
@Use the fancy .In macro for includes. From Jan Klemkow. ok jmc schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.23 2012/09/27 11:31:58 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: September 27 2012 $
d542 1
a542 1
.Pa "xdr_string(xdrs, sp, MAXUN.UNSIGNED );"
@


1.23
log
@last stage of rfc changes, using consistent Rs/Re blocks, and moving the
references into a STANDARDS section;
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.22 2010/09/07 19:52:37 schwarze Exp $
d33 1
a33 1
.Dd $Mdocdate: September 7 2010 $
d74 2
a75 2
.Fd #include <sys/types.h>
.Fd #include <rpc/xdr.h>
@


1.22
log
@do not use .B, which is man(7), not mdoc(7); and stop .Tn abuse
feedback and ok jmc@@, ok millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.21 2010/09/01 14:43:34 millert Exp $
d33 1
a33 1
.Dd $Mdocdate: September 1 2010 $
d560 1
d562 4
a565 3
.%A "Sun Microsystems, Inc."
.%T "XDR: External Data Representation Standard"
.%R "RFC 1014, USC-ISI"
@


1.21
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.20 2008/09/07 14:59:41 marco Exp $
d33 1
a33 1
.Dd $Mdocdate: September 7 2008 $
d166 1
a166 3
is an
.Tn XDR
filter that translates between
d202 1
a202 3
is a macro that invokes the destroy routine associated with the
.Tn XDR
stream
d232 1
a232 3
The first argument is the
.Tn XDR
routine for the object being freed.
d240 1
a240 2
is a macro that invokes the get-position routine associated with the
.Tn XDR
d244 2
a245 5
which indicates the position of the
.Tn XDR
byte stream.
A desirable feature of
.Tn XDR
d247 1
a247 3
although the
.Tn XDR
stream instances need not guarantee this.
d250 1
a250 3
is a macro that invokes the in-line routine associated with the
.Tn XDR
stream
d284 1
a284 3
is a routine which initializes the
.Tn XDR
stream object pointed to by
d294 1
a294 3
determines the direction of the
.Tn XDR
stream
d327 1
a327 3
is a routine which initializes the
.Tn XDR
stream object pointed to by
d350 1
a350 3
Note: the
.Tn XDR
stream's
d353 1
a353 3
Warning: this
.Tn XDR
stream implements an intermediate record stream.
d379 1
a379 3
It tells the
.Tn XDR
implementation that the rest of the current record
d393 1
a393 3
is an
.Tn XDR
procedure that filters the structure
d404 1
a404 2
is a macro that invokes the set position routine associated with the
.Tn XDR
d411 1
a411 3
This routine returns one if the
.Tn XDR
stream could be repositioned,
d413 1
a413 2
Warning: it is difficult to reposition some types of
.Tn XDR
d424 1
a424 3
is a routine which initializes the
.Tn XDR
stream object pointed to by
d426 1
a426 3
The
.Tn XDR
stream data is written to, or read from, the Standard I/O
d431 1
a431 3
determines the direction of the
.Tn XDR
stream (either
d436 1
a436 3
Warning: the destroy routine associated with such
.Tn XDR
streams calls
d530 1
a530 2
is an
.Tn XDR
d537 1
a537 2
It may be passed to
.Tn RPC
d544 1
a544 1
.Tn MAXUN.UNSIGNED
d547 1
a547 4
is handy because the
.Tn RPC
package passes a maximum of two
.Tn XDR
@


1.20
log
@Fix param list for xdrrec_eof.  Found during coding some stuff that uses
xdr goo.
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.19 2008/06/13 23:39:26 deraadt Exp $
d4 1
a4 6
.\" Sun RPC is a product of Sun Microsystems, Inc. and is provided for
.\" unrestricted use provided that this legend is included on all tape
.\" media and as a part of the software program in whole or part.  Users
.\" may copy or modify Sun RPC without charge, but are not authorized
.\" to license or distribute it to anyone else except as part of a product or
.\" program developed by the user.
d6 26
a31 3
.\" SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
.\" WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
d33 1
a33 17
.\" Sun RPC is provided with no support and without any obligation on the
.\" part of Sun Microsystems, Inc. to assist in its use, correction,
.\" modification or enhancement.
.\"
.\" SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
.\" INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
.\" OR ANY PART THEREOF.
.\"
.\" In no event will Sun Microsystems, Inc. be liable for any lost revenue
.\" or profits or other special, indirect and consequential damages, even if
.\" Sun has been advised of the possibility of such damages.
.\"
.\" Sun Microsystems, Inc.
.\" 2550 Garcia Avenue
.\" Mountain View, California  94043
.\"
.Dd $Mdocdate: June 13 2008 $
@


1.19
log
@document xdr_{u_}int64_t() functions
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.18 2007/05/31 19:19:30 jmc Exp $
d31 1
a31 1
.Dd $Mdocdate: May 31 2007 $
d113 1
a113 1
.Fn xdrrec_eof "XDR *xdrs" "int empty"
@


1.18
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.17 2005/07/22 03:23:37 jaredy Exp $
d31 1
a31 1
.Dd $Mdocdate$
d48 1
d64 1
d100 2
d133 2
d289 6
d506 6
@


1.17
log
@- sync prototypes and header excerpts to reality
- punctuation, rewording, typos/spelling, macro, and layout fixes
- add crossrefs where relevant

ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.16 2003/08/08 09:26:02 jmc Exp $
d31 1
a31 1
.Dd February 16, 1988
@


1.16
log
@refer to RFCs consistently (RFC XXXX);
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.15 2003/05/30 22:12:43 jmc Exp $
d319 1
a319 1
execpt that it serializes
@


1.15
log
@- whitespace at EOL
- remove unnecessary macros
- section reorder in getrpcent(3)
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.14 2003/02/18 07:47:00 jmc Exp $
d588 1
a588 1
.%R "RFC1014, USC-ISI"
@


1.14
log
@copyrights added;

these are all Sun Microsystems
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.13 2000/04/18 03:01:34 aaron Exp $
d30 1
a30 1
.\" 
d303 1
a303 1
.Dv XDR_FREE Ns ).
d459 1
a459 1
.Dv XDR_FREE Ns ).
d535 1
a535 1
.Dv NULL Ns ).
@


1.13
log
@Repairs, mostly removing hard sentence breaks.
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.12 1999/07/09 13:35:22 aaron Exp $
d4 27
@


1.12
log
@- remove all trailing whitespace
     * except when it is escaped with a `\' at the end of the line
- fix remaining .Nm usage as well
- this is from a patch I received from kwesterback@@home.com, who has been
  working on some scripts for fixing formatting errors in mdoc'd man pages

Ok, so there could be a cost/benefit debate with this commit, but since I have
the patch we might as well commit it...
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.11 1999/07/05 06:08:05 aaron Exp $
d119 2
a120 1
and their corresponding external representations. The parameter
d140 2
a141 1
and their external representations. When encoding data, this
d150 2
a151 2
is the address of the string pointer. The length of the
string is located at address
d161 2
a162 3
Note: encoded characters are not packed, and occupy 4 bytes
each. For arrays of characters, it is worthwhile to
consider
d174 2
a175 1
associated with the stream.  Using
d200 2
a201 1
is a generic freeing routine. The first argument is the
d203 4
a206 3
routine for the object being freed. The second argument
is a pointer to the object itself.  Note: the pointer passed
to this routine is
d266 2
a267 1
bytes long.  The
d296 2
a297 1
does not.  Thus,
d311 2
a312 1
default. The stream's data is read from a buffer of size
d318 2
a319 1
is called.  Similarly, when a stream's input buffer is empty,
d321 2
a322 3
is called.  The behavior of these two routines is similar to
the
system calls
d347 2
a348 1
is non-zero. This routine returns one if it succeeds, zero otherwise.
d385 2
a386 1
pointers. Use
d444 2
a445 1
corresponding external representations.  Strings cannot be longer than
d479 2
a480 2
and its corresponding external representation. It first
translates the discriminant of the union located at
d486 2
a487 1
is translated.  The parameter
d491 2
a492 1
structures. Each structure contains an ordered pair of
d498 2
a499 1
is called to translate the union.  The end of the
d513 2
a514 1
and their corresponding external representations.  The parameter
d518 2
a519 1
is the element count of the array.  The parameter
d526 2
a527 2
external representation.  This routine returns one if it succeeds, zero
otherwise.
d530 2
a531 1
is a routine which always returns one. It may be passed to
@


1.11
log
@use .Li to refer to data types
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.10 1999/05/25 21:16:25 aaron Exp $
d437 1
a437 1
Note: 
@


1.10
log
@kill some old macros
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.9 1999/05/25 13:06:46 aaron Exp $
d44 1
a44 1
.Fd #include <xdr.h>
d181 1
a181 1
.Ft double
d187 1
a187 1
.Ft enum
d193 1
a193 1
.Ft float
d232 1
a232 1
.Ft "long *" .
d236 1
a236 1
.Tn NULL
d248 1
a248 1
.Ft long
d268 2
a269 2
.Tn XDR_ENCODE ,
.Tn XDR_DECODE ,
d271 1
a271 1
.Tn XDR_FREE Ns ).
d288 1
a288 1
.Tn NULL
d376 1
a376 1
.Tn NULL
d401 1
a401 1
.Ft short
d420 2
a421 2
.Tn XDR_ENCODE ,
.Tn XDR_DECODE ,
d423 1
a423 1
.Tn XDR_FREE Ns ).
d444 1
a444 1
.Ft unsigned
d450 1
a450 1
.Ft unsigned
d456 1
a456 1
.Ft "unsigned long"
d462 1
a462 1
.Ft "unsigned short"
d468 1
a468 1
.Ft union
d473 1
a473 1
.Ft enum_t .
d479 1
a479 1
.Ft struct xdr_discrim
d487 1
a487 1
.Fa struct xdr_discrim
d489 1
a489 1
.Tn NULL .
d495 1
a495 1
.Tn NULL Ns ).
@


1.9
log
@punctuation
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.8 1998/09/06 22:23:19 aaron Exp $
d535 12
a546 13
.Xr rpc 3 .
.Pp
The following manuals:
.RS
.ft I
eXternal Data Representation Standard: Protocol Specification
.br
eXternal Data Representation: Sun Technical Notes
.ft R
.br
.Tn "XDR: External Data Representation Standard" ,
.Tn RFC1014, Sun Microsystems, Inc.,
.Tn USC-ISI .
@


1.8
log
@More man page fixes. Spelling, grammar, some typos. Lots of double-word
occurrences squashed as well.
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.7 1998/03/11 18:54:17 deraadt Exp $
d489 1
a489 1
.Tn NULL.
d547 1
a547 1
.Tn USC-ISI.
@


1.7
log
@nroff cleanup
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.6 1998/02/24 12:57:52 deraadt Exp $
d504 1
a504 1
is is the element count of the array.  The parameter
@


1.6
log
@cleanup a bit more
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.5 1998/02/24 11:13:54 deraadt Exp $
d521 1
a521 1
.B "xdr_string(xdrs, sp, MAXUN.UNSIGNED );"
a522 1
.B
@


1.5
log
@commas are good
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.4 1998/02/24 11:05:17 deraadt Exp $
d43 2
@


1.4
log
@mandocmania
@
text
@d1 1
a1 1
.\"	$OpenBSD: xdr.3,v 1.3 1996/08/19 08:32:00 tholo Exp $
d8 32
a39 32
.Nm xdr_array
.Nm xdr_bool
.Nm xdr_bytes
.Nm xdr_char
.Nm xdr_destroy
.Nm xdr_double
.Nm xdr_enum
.Nm xdr_float
.Nm xdr_free
.Nm xdr_getpos
.Nm xdr_inline
.Nm xdr_int
.Nm xdr_long
.Nm xdrmem_create
.Nm xdr_opaque
.Nm xdr_pointer
.Nm xdrrec_create
.Nm xdrrec_endofrecord
.Nm xdrrec_eof
.Nm xdrrec_skiprecord
.Nm xdr_reference
.Nm xdr_setpos
.Nm xdr_short
.Nm xdrstdio_create
.Nm xdr_string
.Nm xdr_u_char
.Nm xdr_u_int
.Nm xdr_u_long
.Nm xdr_u_short
.Nm xdr_union
.Nm xdr_vector
.Nm xdr_void
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 2
a2 1
.\"	$OpenBSD: xdr.3,v 1.2 1996/07/20 06:12:48 deraadt Exp $
d4 106
a109 5
.TH XDR 3N "16 February 1988"
.SH NAME
xdr \- library routines for external data representation
.SH SYNOPSIS AND DESCRIPTION
.LP
d114 5
a118 17
.LP
.ft B
.nf
.sp .5
xdr_array(xdrs, arrp, sizep, maxsize, elsize, elproc)
\s-1XDR\s0 *xdrs;
char **arrp;
u_int *sizep, maxsize, elsize;
xdrproc_t elproc;
.fi
.ft R
.IP
A filter primitive that translates between variable-length
arrays
and their corresponding external representations. The
parameter
.I arrp
d120 1
a120 1
.I sizep
d123 1
a123 1
.IR maxsize .
d125 3
a127 5
.I elsize
is the
.I sizeof
each of the array's elements, and
.I elproc
d129 1
a129 1
.SM XDR
d134 3
a136 14
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_bool(xdrs, bp)
\s-1XDR\s0 *xdrs;
bool_t *bp;
.fi
.ft R
.IP
A filter primitive that translates between booleans (C
integers)
d140 3
a142 14
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
xdr_bytes(xdrs, sp, sizep, maxsize)
\s-1XDR\s0 *xdrs;
char **sp;
u_int *sizep, maxsize;
.fi
.ft R
.IP
A filter primitive that translates between counted byte
d145 1
a145 1
.I sp
d148 1
a148 1
.IR sizep ;
d150 1
a150 1
.IR maxsize .
d152 3
a154 13
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_char(xdrs, cp)
\s-1XDR\s0 *xdrs;
char *cp;
.fi
.ft R
.IP
A filter primitive that translates between C characters
d160 2
a161 2
.BR xdr_bytes(\|) ,
.B xdr_opaque(\|)
d163 7
a169 17
.BR xdr_string(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xdr_destroy(xdrs)
\s-1XDR\s0 *xdrs;
.fi
.ft R
.IP
A macro that invokes the destroy routine associated with the
.SM XDR
stream,
.IR xdrs .
d172 1
a172 1
.I xdrs
d174 1
a174 1
.B xdr_destroy(\|)
d176 4
a179 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_double(xdrs, dp)
\s-1XDR\s0 *xdrs;
double *dp;
.fi
.ft R
.IP
A filter primitive that translates between C
.B double
d182 16
a197 47
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_enum(xdrs, ep)
\s-1XDR\s0 *xdrs;
enum_t *ep;
.fi
.ft R
.IP
A filter primitive that translates between C
.BR enum s
(actually integers) and their external representations.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_float(xdrs, fp)
\s-1XDR\s0 *xdrs;
float *fp;
.fi
.ft R
.IP
A filter primitive that translates between C
.BR float s
and their external representations.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
xdr_free(proc, objp)
xdrproc_t proc;
char *objp;
.fi
.ft R
.IP
Generic freeing routine. The first argument is the
.SM XDR
d199 1
a199 1
is a pointer to the object itself. Note: the pointer passed
d201 8
a208 21
.I not
freed, but what it points to
.I is
freed (recursively).
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
u_int
xdr_getpos(xdrs)
\s-1XDR\s0 *xdrs;
.fi
.ft R
.IP
A macro that invokes the get-position routine
associated with the
.SM XDR
stream,
.IR xdrs .
d211 1
a211 1
.SM XDR
d214 1
a214 1
.SM XDR
d217 1
a217 1
.SM XDR
d219 6
a224 18
.br
.if t .ne 4
.LP
.ft B
.nf
.sp .5
.br
long *
xdr_inline(xdrs, len)
\s-1XDR\s0 *xdrs;
int len;
.fi
.ft R
.IP
A macro that invokes the in-line routine associated with the
.SM XDR
stream,
.IR xdrs .
d227 1
a227 1
.I len
d230 1
a230 2
.BR "long *" .
.IP
d232 1
a232 1
.B xdr_inline(\|)
d234 1
a234 2
.SM NULL
(0)
d238 3
a240 13
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_int(xdrs, ip)
\s-1XDR\s0 *xdrs;
int *ip;
.fi
.ft R
.IP
A filter primitive that translates between C integers
d243 4
a246 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_long(xdrs, lp)
\s-1XDR\s0 *xdrs;
long *lp;
.fi
.ft R
.IP
A filter primitive that translates between C
.B long
d249 4
a252 17
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
void
xdrmem_create(xdrs, addr, size, op)
\s-1XDR\s0 *xdrs;
char *addr;
u_int size;
enum xdr_op op;
.fi
.ft R
.IP
This routine initializes the
.SM XDR
d254 1
a254 1
.IR xdrs .
d257 1
a257 1
.I addr
d259 1
a259 1
.I size
d261 1
a261 1
.I op
d263 1
a263 1
.SM XDR
d266 2
a267 2
.BR \s-1XDR_ENCODE\s0 ,
.BR \s-1XDR_DECODE\s0 ,
d269 4
a272 15
.BR \s-1XDR_FREE\s0 ).
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
xdr_opaque(xdrs, cp, cnt)
\s-1XDR\s0 *xdrs;
char *cp;
u_int cnt;
.fi
.ft R
.IP
A filter primitive that translates between fixed size opaque
d276 1
a276 1
.I cp
d278 1
a278 1
.I cnt
d281 4
a284 16
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
xdr_pointer(xdrs, objpp, objsize, xdrobj)
\s-1XDR\s0 *xdrs;
char **objpp;
u_int objsize;
xdrproc_t xdrobj;
.fi
.ft R
.IP
Like
.B xdr_reference(\|)
d286 1
a286 1
.SM NULL
d288 1
a288 1
.B xdr_reference(\|)
d290 1
a290 1
.B xdr_pointer(\|)
d294 4
a297 17
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
void
xdrrec_create(xdrs, sendsize, recvsize, handle, readit, writeit)
\s-1XDR\s0 *xdrs;
u_int sendsize, recvsize;
char *handle;
int (*readit) (\|), (*writeit) (\|);
.fi
.ft R
.IP
This routine initializes the
.SM XDR
d299 1
a299 1
.IR xdrs .
d301 1
a301 1
.IR sendsize ;
d304 1
a304 1
.IR recvsize ;
d308 1
a308 1
.I writeit
d310 1
a310 1
.I readit
d314 1
a314 1
.B read
d316 1
a316 1
.BR write ,
d318 1
a318 1
.I handle
d321 1
a321 1
.SM XDR
d323 1
a323 1
.I op
a324 1
.IP
d326 1
a326 1
.SM XDR
d330 3
a332 13
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
xdrrec_endofrecord(xdrs, sendnow)
\s-1XDR\s0 *xdrs;
int sendnow;
.fi
.ft R
.IP
This routine can be invoked only on
d334 2
a335 3
.BR xdrrec_create(\|) .
The data in the output buffer is marked as a completed
record,
d337 5
a341 16
.I sendnow
is non-zero. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdrrec_eof(xdrs)
\s-1XDR\s0 *xdrs;
int empty;
.fi
.ft R
.IP
This routine can be invoked only on
d343 1
a343 1
.BR xdrrec_create(\|) .
d347 3
a349 12
.br
.if t .ne 3
.LP
.ft B
.nf
.sp .5
xdrrec_skiprecord(xdrs)
\s-1XDR\s0 *xdrs;
.fi
.ft R
.IP
This routine can be invoked only on
d351 1
a351 1
.BR xdrrec_create(\|) .
d353 1
a353 1
.SM XDR
d357 3
a359 15
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
xdr_reference(xdrs, pp, size, proc)
\s-1XDR\s0 *xdrs;
char **pp;
u_int size;
xdrproc_t proc;
.fi
.ft R
.IP
A primitive that provides pointer chasing within structures.
d361 1
a361 1
.I pp
d363 3
a365 5
.I size
is the
.I sizeof
the structure that
.I *pp
d367 1
a367 1
.I proc
d369 1
a369 1
.SM XDR
a372 1
.IP
d374 1
a374 1
.SM NULL
d376 1
a376 1
.B xdr_pointer(\|)
d378 4
a381 15
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
xdr_setpos(xdrs, pos)
\s-1XDR\s0 *xdrs;
u_int pos;
.fi
.ft R
.IP
A macro that invokes the set position routine associated with
the
.SM XDR
d383 1
a383 1
.IR xdrs .
d385 1
a385 1
.I pos
d387 1
a387 1
.BR xdr_getpos(\|) .
d389 1
a389 1
.SM XDR
a391 1
.IP
d393 1
a393 1
.SM XDR
d396 4
a399 14
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_short(xdrs, sp)
\s-1XDR\s0 *xdrs;
short *sp;
.fi
.ft R
.IP
A filter primitive that translates between C
.B short
d402 4
a405 16
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
void
xdrstdio_create(xdrs, file, op)
\s-1XDR\s0 *xdrs;
\s-1FILE\s0 *file;
enum xdr_op op;
.fi
.ft R
.IP
This routine initializes the
.SM XDR
d407 1
a407 1
.IR xdrs .
d409 2
a410 3
.SM XDR
stream data is written to, or read from, the Standard
.B I/O
d412 1
a412 1
.IR file .
d414 1
a414 1
.I op
d416 1
a416 1
.SM XDR
d418 2
a419 2
.BR \s-1XDR_ENCODE\s0 ,
.BR \s-1XDR_DECODE\s0 ,
d421 1
a421 2
.BR \s-1XDR_FREE\s0 ).
.IP
d423 1
a423 1
.SM XDR
d425 1
a425 1
.B fflush(\|)
d427 1
a427 1
.I file
d429 6
a434 20
.BR fclose(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
xdr_string(xdrs, sp, maxsize)
\s-1XDR\s0
*xdrs;
char **sp;
u_int maxsize;
.fi
.ft R
.IP
A filter primitive that translates between C strings and
their
corresponding external representations.
Strings cannot be longer than
.IR maxsize .
d436 1
a436 1
.I sp
d439 4
a442 14
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_u_char(xdrs, ucp)
\s-1XDR\s0 *xdrs;
unsigned char *ucp;
.fi
.ft R
.IP
A filter primitive that translates between
.B unsigned
d445 4
a448 14
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
xdr_u_int(xdrs, up)
\s-1XDR\s0 *xdrs;
unsigned *up;
.fi
.ft R
.IP
A filter primitive that translates between C
.B unsigned
d451 4
a454 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_u_long(xdrs, ulp)
\s-1XDR\s0 *xdrs;
unsigned long *ulp;
.fi
.ft R
.IP
A filter primitive that translates between C
.B "unsigned long"
d457 4
a460 14
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_u_short(xdrs, usp)
\s-1XDR\s0 *xdrs;
unsigned short *usp;
.fi
.ft R
.IP
A filter primitive that translates between C
.B "unsigned short"
d463 4
a466 17
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
xdr_union(xdrs, dscmp, unp, choices, dfault)
\s-1XDR\s0 *xdrs;
int *dscmp;
char *unp;
struct xdr_discrim *choices;
bool_t (*defaultarm) (\|);  /* may equal \s-1NULL\s0 */
.fi
.ft R
.IP
A filter primitive that translates between a discriminated C
.B union
d469 1
a469 1
.IR dscmp .
d471 1
a471 1
.BR enum_t .
d473 1
a473 1
.I unp
d475 1
a475 1
.I choices
d477 1
a477 1
.B xdr_discrim(\|)
d479 1
a479 1
.RI [ value , proc ].
d481 1
a481 1
.IR value ,
d483 1
a483 1
.I proc
d485 1
a485 1
.B xdr_discrim(\|)
d487 1
a487 1
.SM NULL\s0.
d489 1
a489 1
.I choices
d491 1
a491 1
.I defaultarm
d493 1
a493 1
.SM NULL\s0).
d495 5
a499 19
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
xdr_vector(xdrs, arrp, size, elsize, elproc)
\s-1XDR\s0 *xdrs;
char *arrp;
u_int size, elsize;
xdrproc_t elproc;
.fi
.ft R
.IP
A filter primitive that translates between fixed-length
arrays
and their corresponding external representations.  The
parameter
.I arrp
d501 1
a501 1
.I size
d503 3
a505 5
.I elsize
is the
.I sizeof
each of the array's elements, and
.I elproc
d507 13
a519 34
.SM XDR
filter that translates between
the array elements' C form, and their external
representation.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
xdr_void(\|)
.fi
.ft R
.IP
This routine always returns one.
It may be passed to
.SM RPC
routines that require a function parameter,
where nothing is to be done.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
xdr_wrapstring(xdrs, sp)
\s-1XDR\s0 *xdrs;
char **sp;
.fi
.ft R
.IP
A primitive that calls
.B "xdr_string(xdrs, sp,\s-1MAXUN.UNSIGNED\s0 );"
d522 1
a522 1
.SM MAXUN.UNSIGNED
d524 1
a524 1
.B xdr_wrapstring(\|)
d526 1
a526 1
.SM RPC
d528 1
a528 1
.SM XDR
d530 1
a530 1
.BR xdr_string(\|) ,
d533 3
a535 3
.SH SEE ALSO
.BR rpc (3N)
.LP
d544 3
a546 3
.IR "\s-1XDR\s0: External Data Representation Standard" ,
.SM RFC1014, Sun Microsystems, Inc.,
.SM USC-ISI\s0.
@


1.2
log
@bcopy->memcpy & tag
@
text
@d1 1
a1 3
.\"	@@(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
.\"	$OpenBSD: xdr.3,v 1.2 1995/02/25 03:02:03 cgd Exp $
.\"	$NetBSD: xdr.3,v 1.2 1995/02/25 03:02:03 cgd Exp $
@


1.1
log
@Initial revision
@
text
@d2 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

