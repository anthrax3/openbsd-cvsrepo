head	1.25;
access;
symbols
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.14
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.18
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.16
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.12
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.6
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.16.0.16
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.14
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.12
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.10
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.8
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.6
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.12
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.10
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.8
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.6
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2015.11.01.03.45.29;	author guenther;	state Exp;
branches;
next	1.24;
commitid	CfNWDWdDpm7mVO8i;

1.24
date	2015.09.13.15.36.56;	author guenther;	state Exp;
branches;
next	1.23;
commitid	FxNpAvmgpSFQVav0;

1.23
date	2015.09.01.19.54.01;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	1kc6QzxBpplZkdjp;

1.22
date	2015.09.01.17.31.39;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	wNBber7PJsiacqv9;

1.21
date	2015.08.20.21.49.29;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	jeIpGH0zlTW3huPH;

1.20
date	2015.05.18.13.57.34;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	eytVtAAZCjcfQ0Eg;

1.19
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.07.01.21.00;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.06.03.28.34;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.08.08.05.35;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.01.07.44.04;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.08.19.17.39;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.20.00.40.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.06.18.35.12;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.24;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.15.13.51.01;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.03.06.50.28;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.03.19.00.27.26;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.09.03.05.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.03.29.06.08.56;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.02.17.00.04.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.09.31.42;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.31.59;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.07.20.06.12.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@delete old lint ARGSUSED comments
@
text
@/*	$OpenBSD: svc_udp.c,v 1.24 2015/09/13 15:36:56 guenther Exp $ */

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * svc_udp.c,
 * Server side for UDP/IP based RPC.  (Does some caching in the hopes of
 * achieving execute-at-most-once semantics.)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rpc/rpc.h>
#include <sys/socket.h>
#include <stdint.h>
#include <errno.h>
#include <unistd.h>


#define rpc_buffer(xprt) ((xprt)->xp_p1)
#define MAX(a, b)     ((a > b) ? a : b)

static bool_t		svcudp_recv(SVCXPRT *, struct rpc_msg *);
static enum xprt_stat	svcudp_stat(SVCXPRT *);
static bool_t		svcudp_getargs(SVCXPRT *, xdrproc_t, caddr_t);
static bool_t		svcudp_reply(SVCXPRT *, struct rpc_msg *);
static bool_t		svcudp_freeargs(SVCXPRT *, xdrproc_t, caddr_t);
static void		svcudp_destroy(SVCXPRT *);
static void		cache_set(SVCXPRT *, u_long);
static int		cache_get(SVCXPRT *, struct rpc_msg *, char **,
			    u_long *);

static struct xp_ops svcudp_op = {
	svcudp_recv,
	svcudp_stat,
	svcudp_getargs,
	svcudp_reply,
	svcudp_freeargs,
	svcudp_destroy
};

/*
 * kept in xprt->xp_p2
 */
struct svcudp_data {
	u_int   su_iosz;	/* byte size of send.recv buffer */
	u_long	su_xid;		/* transaction id */
	XDR	su_xdrs;	/* XDR handle */
	char	su_verfbody[MAX_AUTH_BYTES];	/* verifier body */
	char * 	su_cache;	/* cached data, NULL if no cache */
};
#define	su_data(xprt)	((struct svcudp_data *)(xprt->xp_p2))

/*
 * Usage:
 *	xprt = svcudp_create(sock);
 *
 * If sock<0 then a socket is created, else sock is used.
 * If the socket, sock is not bound to a port then svcudp_create
 * binds it to an arbitrary port.  In any (successful) case,
 * xprt->xp_sock is the registered socket number and xprt->xp_port is the
 * associated port number.
 * Once *xprt is initialized, it is registered as a transporter;
 * see (svc.h, xprt_register).
 * The routines returns NULL if a problem occurred.
 */
SVCXPRT *
svcudp_bufcreate(int sock, u_int sendsz, u_int recvsz)
{
	bool_t madesock = FALSE;
	SVCXPRT *xprt;
	struct svcudp_data *su;
	struct sockaddr_in addr;
	socklen_t len = sizeof(struct sockaddr_in);

	if (sock == RPC_ANYSOCK) {
		if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
			return (NULL);
		madesock = TRUE;
	}
	memset(&addr, 0, sizeof (addr));
	addr.sin_len = sizeof(struct sockaddr_in);
	addr.sin_family = AF_INET;
	if (bindresvport(sock, &addr)) {
		addr.sin_port = 0;
		(void)bind(sock, (struct sockaddr *)&addr, len);
	}
	if (getsockname(sock, (struct sockaddr *)&addr, &len) != 0) {
		if (madesock)
			(void)close(sock);
		return (NULL);
	}
	xprt = malloc(sizeof(SVCXPRT));
	if (xprt == NULL) {
		if (madesock)
			(void)close(sock);
		return (NULL);
	}
	su = malloc(sizeof(*su));
	if (su == NULL) {
		if (madesock)
			(void)close(sock);
		free(xprt);
		return (NULL);
	}
	su->su_iosz = ((MAX(sendsz, recvsz) + 3) / 4) * 4;
	if ((rpc_buffer(xprt) = malloc(su->su_iosz)) == NULL) {
		if (madesock)
			(void)close(sock);
		free(xprt);
		free(su);
		return (NULL);
	}
	xdrmem_create(&(su->su_xdrs), rpc_buffer(xprt), su->su_iosz,
	    XDR_DECODE);
	su->su_cache = NULL;
	xprt->xp_p2 = (caddr_t)su;
	xprt->xp_verf.oa_base = su->su_verfbody;
	xprt->xp_ops = &svcudp_op;
	xprt->xp_port = ntohs(addr.sin_port);
	xprt->xp_sock = sock;
	if (__xprt_register(xprt) == 0) {
		if (madesock)
			(void)close(sock);
		free(rpc_buffer(xprt));
		free(xprt);
		free(su);
		return (NULL);
	}
	return (xprt);
}
DEF_WEAK(svcudp_bufcreate);

SVCXPRT *
svcudp_create(int sock)
{

	return(svcudp_bufcreate(sock, UDPMSGSIZE, UDPMSGSIZE));
}
DEF_WEAK(svcudp_create);

static enum xprt_stat
svcudp_stat(SVCXPRT *xprt)
{

	return (XPRT_IDLE); 
}

static bool_t
svcudp_recv(SVCXPRT *xprt, struct rpc_msg *msg)
{
	struct svcudp_data *su = su_data(xprt);
	XDR *xdrs = &(su->su_xdrs);
	int rlen;
	char *reply;
	u_long replylen;

    again:
	xprt->xp_addrlen = sizeof(struct sockaddr_in);
	rlen = recvfrom(xprt->xp_sock, rpc_buffer(xprt), (int) su->su_iosz,
	    0, (struct sockaddr *)&(xprt->xp_raddr), &(xprt->xp_addrlen));
	if (rlen == -1 && errno == EINTR)
		goto again;
	if (rlen == -1 || rlen < 4*sizeof(u_int32_t))
		return (FALSE);
	xdrs->x_op = XDR_DECODE;
	XDR_SETPOS(xdrs, 0);
	if (! xdr_callmsg(xdrs, msg))
		return (FALSE);
	su->su_xid = msg->rm_xid;
	if (su->su_cache != NULL) {
		if (cache_get(xprt, msg, &reply, &replylen)) {
			(void) sendto(xprt->xp_sock, reply, (int) replylen, 0,
			    (struct sockaddr *) &xprt->xp_raddr,
			    xprt->xp_addrlen);
			return (TRUE);
		}
	}
	return (TRUE);
}

static bool_t
svcudp_reply(SVCXPRT *xprt, struct rpc_msg *msg)
{
	struct svcudp_data *su = su_data(xprt);
	XDR *xdrs = &(su->su_xdrs);
	int slen;
	bool_t stat = FALSE;

	xdrs->x_op = XDR_ENCODE;
	XDR_SETPOS(xdrs, 0);
	msg->rm_xid = su->su_xid;
	if (xdr_replymsg(xdrs, msg)) {
		slen = (int)XDR_GETPOS(xdrs);
		if (sendto(xprt->xp_sock, rpc_buffer(xprt), slen, 0,
		    (struct sockaddr *)&(xprt->xp_raddr), xprt->xp_addrlen)
		    == slen) {
			stat = TRUE;
			if (su->su_cache && slen >= 0) {
				cache_set(xprt, (u_long) slen);
			}
		}
	}
	return (stat);
}

static bool_t
svcudp_getargs(SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
{

	return ((*xdr_args)(&(su_data(xprt)->su_xdrs), args_ptr));
}

static bool_t
svcudp_freeargs(SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
{
	XDR *xdrs = &(su_data(xprt)->su_xdrs);

	xdrs->x_op = XDR_FREE;
	return ((*xdr_args)(xdrs, args_ptr));
}

static void
svcudp_destroy(SVCXPRT *xprt)
{
	struct svcudp_data *su = su_data(xprt);

	xprt_unregister(xprt);
	if (xprt->xp_sock != -1)
		(void)close(xprt->xp_sock);
	xprt->xp_sock = -1;
	XDR_DESTROY(&(su->su_xdrs));
	mem_free(rpc_buffer(xprt), su->su_iosz);
	mem_free((caddr_t)su, sizeof(struct svcudp_data));
	mem_free((caddr_t)xprt, sizeof(SVCXPRT));
}

/*
 * Fifo cache for udp server
 * Copies pointers to reply buffers into fifo cache
 * Buffers are sent again if retransmissions are detected.
 */

#define SPARSENESS 4	/* 75% sparse */

/*
 * An entry in the cache
 */
typedef struct cache_node *cache_ptr;
struct cache_node {
	/*
	 * Index into cache is xid, proc, vers, prog and address
	 */
	u_long cache_xid;
	u_long cache_proc;
	u_long cache_vers;
	u_long cache_prog;
	struct sockaddr_in cache_addr;
	/*
	 * The cached reply and length
	 */
	char * cache_reply;
	u_long cache_replylen;
	/*
 	 * Next node on the list, if there is a collision
	 */
	cache_ptr cache_next;	
};

/*
 * The entire cache
 */
struct udp_cache {
	u_long uc_size;		/* size of cache */
	cache_ptr *uc_entries;	/* hash table of entries in cache */
	cache_ptr *uc_fifo;	/* fifo list of entries in cache */
	u_long uc_nextvictim;	/* points to next victim in fifo list */
	u_long uc_prog;		/* saved program number */
	u_long uc_vers;		/* saved version number */
	u_long uc_proc;		/* saved procedure number */
	struct sockaddr_in uc_addr; /* saved caller's address */
};


/*
 * the hashing function
 */
#define CACHE_LOC(transp, xid)	\
 (xid % (SPARSENESS*((struct udp_cache *) su_data(transp)->su_cache)->uc_size))	


/*
 * Enable use of the cache. 
 * Note: there is no disable.
 */
int
svcudp_enablecache(SVCXPRT *transp, u_long size)
{
	struct svcudp_data *su = su_data(transp);
	struct udp_cache *uc;

	if (su->su_cache != NULL)
		return(0);	
	uc = malloc(sizeof(*uc));
	if (uc == NULL)
		return(0);
	uc->uc_size = size;
	uc->uc_nextvictim = 0;
	if (size > SIZE_MAX / (sizeof(cache_ptr) * SPARSENESS) ||
	    (uc->uc_entries = calloc(size, sizeof(cache_ptr) * SPARSENESS)) == NULL) {
		free(uc);
		return(0);
	}
	uc->uc_fifo = calloc(sizeof(cache_ptr), size);
	if (uc->uc_fifo == NULL) {
		free(uc->uc_entries);
		free(uc);
		return(0);
	}
	su->su_cache = (char *) uc;
	return(1);
}


/*
 * Set an entry in the cache
 */
static void
cache_set(SVCXPRT *xprt, u_long replylen)
{
	cache_ptr victim;	
	cache_ptr *vicp;
	struct svcudp_data *su = su_data(xprt);
	struct udp_cache *uc = (struct udp_cache *) su->su_cache;
	u_int loc;
	char *newbuf;

	/*
 	 * Find space for the new entry, either by
	 * reusing an old entry, or by mallocing a new one
	 */
	victim = uc->uc_fifo[uc->uc_nextvictim];
	if (victim != NULL) {
		loc = CACHE_LOC(xprt, victim->cache_xid);
		for (vicp = &uc->uc_entries[loc]; 
		  *vicp != NULL && *vicp != victim; 
		  vicp = &(*vicp)->cache_next) 
				;
		if (*vicp == NULL) {
			return;
		}
		*vicp = victim->cache_next;	/* remote from cache */
		newbuf = victim->cache_reply;
	} else {
		victim = malloc(sizeof(struct cache_node));
		if (victim == NULL) {
			return;
		}
		newbuf = malloc(su->su_iosz);
		if (newbuf == NULL) {
			free(victim);
			return;
		}
	}

	/*
	 * Store it away
	 */
	victim->cache_replylen = replylen;
	victim->cache_reply = rpc_buffer(xprt);
	rpc_buffer(xprt) = newbuf;
	xdrmem_create(&(su->su_xdrs), rpc_buffer(xprt), su->su_iosz, XDR_ENCODE);
	victim->cache_xid = su->su_xid;
	victim->cache_proc = uc->uc_proc;
	victim->cache_vers = uc->uc_vers;
	victim->cache_prog = uc->uc_prog;
	victim->cache_addr = uc->uc_addr;
	loc = CACHE_LOC(xprt, victim->cache_xid);
	victim->cache_next = uc->uc_entries[loc];	
	uc->uc_entries[loc] = victim;
	uc->uc_fifo[uc->uc_nextvictim++] = victim;
	uc->uc_nextvictim %= uc->uc_size;
}

/*
 * Try to get an entry from the cache
 * return 1 if found, 0 if not found
 */
static int
cache_get(SVCXPRT *xprt, struct rpc_msg *msg, char **replyp, u_long *replylenp)
{
	u_int loc;
	cache_ptr ent;
	struct svcudp_data *su = su_data(xprt);
	struct udp_cache *uc = (struct udp_cache *) su->su_cache;

#	define EQADDR(a1, a2)	(memcmp(&a1, &a2, sizeof(a1)) == 0)

	loc = CACHE_LOC(xprt, su->su_xid);
	for (ent = uc->uc_entries[loc]; ent != NULL; ent = ent->cache_next) {
		if (ent->cache_xid == su->su_xid &&
		  ent->cache_proc == uc->uc_proc &&
		  ent->cache_vers == uc->uc_vers &&
		  ent->cache_prog == uc->uc_prog &&
		  EQADDR(ent->cache_addr, uc->uc_addr)) {
			*replyp = ent->cache_reply;
			*replylenp = ent->cache_replylen;
			return(1);
		}
	}
	/*
	 * Failed to find entry
	 * Remember a few things so we can do a set later
	 */
	uc->uc_proc = msg->rm_call.cb_proc;
	uc->uc_vers = msg->rm_call.cb_vers;
	uc->uc_prog = msg->rm_call.cb_prog;
	uc->uc_addr = xprt->xp_raddr;
	return(0);
}

@


1.24
log
@Wrap <rpc/*.h> so that calls go direct and the symbols are all weak.
Hide __xprt_register() and _authenticate(); truncate <rpc/svc_auth.h>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_udp.c,v 1.23 2015/09/01 19:54:01 deraadt Exp $ */
a171 1
/* ARGSUSED */
@


1.23
log
@Remove all bogus writes to stderr.  Only explicit requests should
go that way.
ok miod beck
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_udp.c,v 1.22 2015/09/01 17:31:39 deraadt Exp $ */
d162 1
d170 1
@


1.22
log
@Remove calls to perror(); the error returns are sufficient, and these
library may not assume stderr is useable.
ok millert miod beck
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_udp.c,v 1.21 2015/08/20 21:49:29 deraadt Exp $ */
a124 1
		(void)fprintf(stderr, "svcudp_create: out of memory\n");
a130 1
		(void)fprintf(stderr, "svcudp_create: out of memory\n");
a137 1
		(void)fprintf(stderr, "svcudp_create: out of memory\n");
@


1.21
log
@All these files include <stdlib.h>, so do not need to cast
malloc/calloc/realloc* returns.
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_udp.c,v 1.20 2015/05/18 13:57:34 deraadt Exp $ */
d107 1
a107 2
		if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
			perror("svcudp_create: socket creation problem");
a108 1
		}
a118 1
		perror("svcudp_create - cannot getsockname");
a277 3
#define CACHE_PERROR(msg)	\
	(void) fprintf(stderr,"%s\n", msg)

d334 1
a334 2
	if (su->su_cache != NULL) {
		CACHE_PERROR("enablecache: cache already enabled");
a335 1
	}
d337 1
a337 2
	if (uc == NULL) {
		CACHE_PERROR("enablecache: could not allocate cache");
a338 1
	}
a342 1
		CACHE_PERROR("enablecache: could not allocate cache data");
a347 1
		CACHE_PERROR("enablecache: could not allocate cache fifo");
a381 1
			CACHE_PERROR("cache_set: victim not found");
a388 1
			CACHE_PERROR("cache_set: victim alloc failed");
a392 1
			CACHE_PERROR("cache_set: could not allocate new rpc_buffer");
@


1.20
log
@swap calloc() arguments for clarity
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_udp.c,v 1.19 2010/09/01 14:43:34 millert Exp $ */
d126 1
a126 1
	xprt = (SVCXPRT *)malloc(sizeof(SVCXPRT));
d133 1
a133 1
	su = (struct svcudp_data *)malloc(sizeof(*su));
@


1.19
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_udp.c,v 1.18 2009/06/07 01:21:00 millert Exp $ */
d352 1
a352 1
	    (uc->uc_entries = calloc(sizeof(cache_ptr) * SPARSENESS, size)) == NULL) {
@


1.18
log
@Modify the uc_entries allocation check such that the lhs is a constant.
OK deraadt@@
@
text
@d1 2
a2 1
/*	$OpenBSD: svc_udp.c,v 1.17 2009/06/06 03:28:34 deraadt Exp $ */
d4 28
a31 26
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 * 
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 * 
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 * 
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 * 
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 * 
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a37 2
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
@


1.17
log
@use calloc() and realloc() more; ok schwarze
@
text
@d1 1
a1 1
/*	$OpenBSD: svc_udp.c,v 1.16 2005/08/08 08:05:35 espie Exp $ */
d350 1
a350 1
	if (size && sizeof(cache_ptr) * SPARSENESS > SIZE_MAX / size ||
@


1.16
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d44 1
d125 1
a125 1
	xprt = (SVCXPRT *)mem_alloc(sizeof(SVCXPRT));
d132 1
a132 1
	su = (struct svcudp_data *)mem_alloc(sizeof(*su));
d141 1
a141 1
	if ((rpc_buffer(xprt) = mem_alloc(su->su_iosz)) == NULL) {
a282 6
#define ALLOC(type, size)	\
	(type *) mem_alloc((unsigned) (sizeof(type) * (size)))

#define BZERO(addr, type, size)	 \
	memset((char *) addr, 0, sizeof(type) * (int) (size)) 

d343 1
a343 1
	uc = ALLOC(struct udp_cache, 1);
d350 2
a351 2
	uc->uc_entries = ALLOC(cache_ptr, size * SPARSENESS);
	if (uc->uc_entries == NULL) {
d356 1
a356 2
	BZERO(uc->uc_entries, cache_ptr, size * SPARSENESS);
	uc->uc_fifo = ALLOC(cache_ptr, size);
a362 1
	BZERO(uc->uc_fifo, cache_ptr, size);
d399 1
a399 1
		victim = ALLOC(struct cache_node, 1);
d404 1
a404 1
		newbuf = mem_alloc(su->su_iosz);
@


1.15
log
@ansify. ok deraadt@@ jaredy@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.14 2005/01/08 19:17:39 krw Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.14
log
@Bit of KNF - replace (<type> *)0 and (<type> *)NULL with NULL. Pointed
out by mickey@@, seconded by millert@@.

ok deraadt@@.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.13 2003/09/20 00:40:36 deraadt Exp $";
d61 2
a62 1
static int		cache_get(SVCXPRT *, struct rpc_msg *, char **, u_long *);
d99 1
a99 3
svcudp_bufcreate(sock, sendsz, recvsz)
	int sock;
	u_int sendsz, recvsz;
d171 1
a171 2
svcudp_create(sock)
	int sock;
d179 1
a179 2
svcudp_stat(xprt)
	SVCXPRT *xprt;
d186 1
a186 3
svcudp_recv(xprt, msg)
	SVCXPRT *xprt;
	struct rpc_msg *msg;
d219 1
a219 3
svcudp_reply(xprt, msg)
	SVCXPRT *xprt; 
	struct rpc_msg *msg; 
d244 1
a244 4
svcudp_getargs(xprt, xdr_args, args_ptr)
	SVCXPRT *xprt;
	xdrproc_t xdr_args;
	caddr_t args_ptr;
d251 1
a251 4
svcudp_freeargs(xprt, xdr_args, args_ptr)
	SVCXPRT *xprt;
	xdrproc_t xdr_args;
	caddr_t args_ptr;
d260 1
a260 2
svcudp_destroy(xprt)
	SVCXPRT *xprt;
d342 1
a342 3
svcudp_enablecache(transp, size)
	SVCXPRT *transp;
	u_long size;
d382 1
a382 3
cache_set(xprt, replylen)
	SVCXPRT *xprt;
	u_long replylen;	
d446 1
a446 5
cache_get(xprt, msg, replyp, replylenp)
	SVCXPRT *xprt;
	struct rpc_msg *msg;
	char **replyp;
	u_long *replylenp;
@


1.13
log
@incorrect ordering of free operations
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.12 2002/09/06 18:35:12 deraadt Exp $";
d111 1
a111 1
			return ((SVCXPRT *)NULL);
d126 1
a126 1
		return ((SVCXPRT *)NULL);
@


1.12
log
@use socklen_t where needed; henning pvalchev ok
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.11 2002/02/16 21:27:24 millert Exp $";
d152 2
a153 2
	xdrmem_create(
	    &(su->su_xdrs), rpc_buffer(xprt), su->su_iosz, XDR_DECODE);
d163 1
a164 1
		free(rpc_buffer(xprt));
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.10 2001/09/15 13:51:01 deraadt Exp $";
d106 1
a106 1
	int len = sizeof(struct sockaddr_in);
@


1.10
log
@prototype cleanup
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.9 2001/03/03 06:50:28 deraadt Exp $";
d60 2
a61 2
static void		cache_set __P((SVCXPRT *, u_long));
static int		cache_get __P((SVCXPRT *, struct rpc_msg *, char **, u_long *));
@


1.9
log
@plug many memory leaks
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.8 1998/03/19 00:27:26 millert Exp $";
d54 6
a59 6
static bool_t		svcudp_recv();
static bool_t		svcudp_reply();
static enum xprt_stat	svcudp_stat();
static bool_t		svcudp_getargs();
static bool_t		svcudp_freeargs();
static void		svcudp_destroy();
d99 1
a99 1
	register int sock;
d103 2
a104 2
	register SVCXPRT *xprt;
	register struct svcudp_data *su;
d190 1
a190 1
	register SVCXPRT *xprt;
d193 3
a195 3
	register struct svcudp_data *su = su_data(xprt);
	register XDR *xdrs = &(su->su_xdrs);
	register int rlen;
d215 2
a216 1
			  (struct sockaddr *) &xprt->xp_raddr, xprt->xp_addrlen);
d225 1
a225 1
	register SVCXPRT *xprt; 
d228 4
a231 4
	register struct svcudp_data *su = su_data(xprt);
	register XDR *xdrs = &(su->su_xdrs);
	register int slen;
	register bool_t stat = FALSE;
d266 1
a266 1
	register XDR *xdrs = &(su_data(xprt)->su_xdrs);
d274 1
a274 1
	register SVCXPRT *xprt;
d276 1
a276 1
	register struct svcudp_data *su = su_data(xprt);
a287 3

/***********this could be a separate file*********************/

a328 2


d402 3
a404 3
	register cache_ptr victim;	
	register cache_ptr *vicp;
	register struct svcudp_data *su = su_data(xprt);
d471 3
a473 3
	register cache_ptr ent;
	register struct svcudp_data *su = su_data(xprt);
	register struct udp_cache *uc = (struct udp_cache *) su->su_cache;
@


1.8
log
@Some -Wall
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.7 1997/07/09 03:05:06 deraadt Exp $";
d160 8
a167 1
	xprt_register(xprt);
d381 1
d388 2
d439 1
@


1.7
log
@avoid close(closed_socket) or close(-1); it looks disgusting in kdump
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.6 1997/03/29 06:08:56 deraadt Exp $";
d48 1
d352 1
d456 1
a456 1
static
@


1.6
log
@in svcudp_bufcreate(), only close socket if we created it
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.5 1997/02/17 00:04:00 deraadt Exp $";
d270 3
a272 1
	(void)close(xprt->xp_sock);
@


1.5
log
@do not leak descriptors and mem
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.4 1996/09/15 09:31:42 tholo Exp $";
d101 1
d112 1
d123 2
a124 1
		(void)close(sock);
d130 2
a131 1
		(void)close(sock);
d137 2
a138 1
		(void)close(sock);
d145 2
a146 1
		(void)close(sock);
@


1.4
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.3 1996/08/19 08:31:59 tholo Exp $";
a100 1
	bool_t madesock = FALSE;
a110 1
		madesock = TRUE;
d121 1
a121 2
		if (madesock)
			(void)close(sock);
d127 1
d133 2
d140 3
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.2 1996/07/20 06:12:46 deraadt Exp $";
d59 2
d162 1
a180 1
	static int cache_get();
a213 1
	static void cache_set();
@


1.2
log
@bcopy->memcpy & tag
@
text
@a0 3
/*	$OpenBSD: svc_udp.c,v 1.6 1995/06/03 22:37:28 mycroft Exp $	*/
/*	$NetBSD: svc_udp.c,v 1.6 1995/06/03 22:37:28 mycroft Exp $	*/

d31 2
a32 4
/*static char *sccsid = "from: @@(#)svc_udp.c 1.24 87/08/11 Copyr 1984 Sun Micro";*/
/*static char *sccsid = "from: @@(#)svc_udp.c	2.2 88/07/29 4.0 RPCSRC";*/
static char *rcsid = "$OpenBSD: svc_udp.c,v 1.6 1995/06/03 22:37:28 mycroft Exp $";
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
d36 1
a36 1
static char *rcsid = "$NetBSD: svc_udp.c,v 1.6 1995/06/03 22:37:28 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

