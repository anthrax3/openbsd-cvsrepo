head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.2
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.10
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.14
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.12
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.8
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.6
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.4
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.24.0.14
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.12
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.10
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.6
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.6
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.4
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.30
date	2017.09.05.02.40.54;	author guenther;	state Exp;
branches;
next	1.29;
commitid	5DW3WOQF0YGGx8lJ;

1.29
date	2016.10.15.18.24.40;	author guenther;	state Exp;
branches;
next	1.28;
commitid	XGWAFLwctKs8oeFL;

1.28
date	2016.09.01.10.41.02;	author otto;	state Exp;
branches;
next	1.27;
commitid	HatwrthzJhfQpDr7;

1.27
date	2016.05.07.19.05.22;	author guenther;	state Exp;
branches;
next	1.26;
commitid	d9R7VGw9CHTkwXE1;

1.26
date	2015.04.07.01.27.07;	author guenther;	state Exp;
branches;
next	1.25;
commitid	oQvh7XA3Kql35r0J;

1.25
date	2011.10.16.06.29.56;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.14.15.43.43;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.13.21.18.42;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.01.00.43.39;	author kurt;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.19.02.54.19;	author kurt;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.05.18.11.48;	author kurt;	state Exp;
branches;
next	1.19;

1.19
date	2006.09.26.14.18.28;	author kurt;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.22.07.16.31;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.15.11.56.40;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.07.21.11.23;	author marc;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.28.04.58.00;	author marc;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.05.22.19.55;	author marc;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.03.23.58.39;	author marc;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.03.20.36.43;	author marc;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.04.22.17.45;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.30.17.47.57;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.30.07.38.27;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.12.12.03.01;	author heko;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.04.21.45.30;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.08.06.11.36;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.06.08.57.29;	author d;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.06.07.47.09;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.06.05.19.32;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.11.20.11.18.41;	author d;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Move mutex, condvar, and thread-specific data routes, pthread_once, and
pthread_exit from libpthread to libc, along with low-level bits to
support them.  Major bump to both libc and libpthread.

Requested by libressl team.  Ports testing by naddy@@
ok kettenis@@
@
text
@/* $OpenBSD: thread_private.h,v 1.29 2016/10/15 18:24:40 guenther Exp $ */

/* PUBLIC DOMAIN: No Rights Reserved. Marco S Hyman <marc@@snafu.org> */

#ifndef _THREAD_PRIVATE_H_
#define _THREAD_PRIVATE_H_

#include <stdio.h>		/* for FILE and __isthreaded */

#define _MALLOC_MUTEXES 4
void _malloc_init(int);
#ifdef __LIBC__
PROTO_NORMAL(_malloc_init);
#endif /* __LIBC__ */

/*
 * The callbacks needed by libc to handle the threaded case.
 * NOTE: Bump the version when you change the struct contents!
 *
 * tc_canceled:
 *	If not NULL, what to do when canceled (otherwise _exit(0))
 *
 * tc_flockfile, tc_ftrylockfile, and tc_funlockfile:
 *	If not NULL, these implement the flockfile() family.
 *	XXX In theory, you should be able to lock a FILE before
 *	XXX loading libpthread and have that be a real lock on it,
 *	XXX but that doesn't work without the libc base version
 *	XXX tracking the recursion count.
 *
 * tc_malloc_lock and tc_malloc_unlock:
 * tc_atexit_lock and tc_atexit_unlock:
 * tc_atfork_lock and tc_atfork_unlock:
 * tc_arc4_lock and tc_arc4_unlock:
 *	The locks used by the malloc, atexit, atfork, and arc4 subsystems.
 *	These have to be ordered specially in the fork/vfork wrappers
 *	and may be implemented differently than the general mutexes
 *	in the callbacks below.
 *
 * tc_mutex_lock and tc_mutex_unlock:
 *	Lock and unlock the given mutex. If the given mutex is NULL
 *	a mutex is allocated and initialized automatically.
 *
 * tc_mutex_destroy:
 *	Destroy/deallocate the given mutex.
 *
 * tc_tag_lock and tc_tag_unlock:
 *	Lock and unlock the mutex associated with the given tag.
 *	If the given tag is NULL a tag is allocated and initialized
 *	automatically.
 *
 * tc_tag_storage:
 *	Returns a pointer to per-thread instance of data associated
 *	with the given tag.  If the given tag is NULL a tag is
 *	allocated and initialized automatically.
 *
 * tc_fork, tc_vfork:
 *	If not NULL, they are called instead of the syscall stub, so that
 *	the thread library can do necessary locking and reinitialization.
 *
 * tc_thread_release:
 *	Handles the release of a thread's TIB and struct pthread and the
 *	notification of other threads...when there are other threads.
 *
 * tc_thread_key_zero:
 *	For each thread, zero out the key data associated with the given key.

 * If <machine/tcb.h> doesn't define TCB_GET(), then locating the TCB in a
 * threaded process requires a syscall (__get_tcb(2)) which is too much
 * overhead for single-threaded processes.  For those archs, there are two
 * additional callbacks, though they are placed first in the struct for
 * convenience in ASM:
 *
 * tc_errnoptr:
 *	Returns the address of the thread's errno.
 *
 * tc_tcb:
 *	Returns the address of the thread's TCB.
 */

struct pthread;
struct thread_callbacks {
	int	*(*tc_errnoptr)(void);		/* MUST BE FIRST */
	void	*(*tc_tcb)(void);
	__dead void	(*tc_canceled)(void);
	void	(*tc_flockfile)(FILE *);
	int	(*tc_ftrylockfile)(FILE *);
	void	(*tc_funlockfile)(FILE *);
	void	(*tc_malloc_lock)(int);
	void	(*tc_malloc_unlock)(int);
	void	(*tc_atexit_lock)(void);
	void	(*tc_atexit_unlock)(void);
	void	(*tc_atfork_lock)(void);
	void	(*tc_atfork_unlock)(void);
	void	(*tc_arc4_lock)(void);
	void	(*tc_arc4_unlock)(void);
	void	(*tc_mutex_lock)(void **);
	void	(*tc_mutex_unlock)(void **);
	void	(*tc_mutex_destroy)(void **);
	void	(*tc_tag_lock)(void **);
	void	(*tc_tag_unlock)(void **);
	void	*(*tc_tag_storage)(void **, void *, size_t, void *);
	__pid_t	(*tc_fork)(void);
	__pid_t	(*tc_vfork)(void);
	void	(*tc_thread_release)(struct pthread *);
	void	(*tc_thread_key_zero)(int);
};

__BEGIN_PUBLIC_DECLS
/*
 *  Set the callbacks used by libc
 */
void	_thread_set_callbacks(const struct thread_callbacks *_cb, size_t _len);
__END_PUBLIC_DECLS

#ifdef __LIBC__
__BEGIN_HIDDEN_DECLS
/* the current set */
extern struct thread_callbacks _thread_cb;
__END_HIDDEN_DECLS
#endif /* __LIBC__ */

/*
 * helper macro to make unique names in the thread namespace
 */
#define __THREAD_NAME(name)	__CONCAT(_thread_tagname_,name)

/*
 * Macros used in libc to access thread mutex, keys, and per thread storage.
 * _THREAD_PRIVATE_KEY and _THREAD_PRIVATE_MUTEX are different macros for
 * historical reasons.   They do the same thing, define a static variable
 * keyed by 'name' that identifies a mutex and a key to identify per thread
 * data.
 */
#define _THREAD_PRIVATE_KEY(name)					\
	static void *__THREAD_NAME(name)
#define _THREAD_PRIVATE_MUTEX(name)					\
	static void *__THREAD_NAME(name)


#ifndef __LIBC__	/* building some sort of reach around */

#define _THREAD_PRIVATE_MUTEX_LOCK(name)		do {} while (0)
#define _THREAD_PRIVATE_MUTEX_UNLOCK(name)		do {} while (0)
#define _THREAD_PRIVATE(keyname, storage, error)	&(storage)
#define _MUTEX_LOCK(mutex)				do {} while (0)
#define _MUTEX_UNLOCK(mutex)				do {} while (0)
#define _MUTEX_DESTROY(mutex)				do {} while (0)
#define _MALLOC_LOCK(n)					do {} while (0)
#define _MALLOC_UNLOCK(n)				do {} while (0)
#define _ATEXIT_LOCK()					do {} while (0)
#define _ATEXIT_UNLOCK()				do {} while (0)
#define _ATFORK_LOCK()					do {} while (0)
#define _ATFORK_UNLOCK()				do {} while (0)
#define _ARC4_LOCK()					do {} while (0)
#define _ARC4_UNLOCK()					do {} while (0)

#else		/* building libc */
#define _THREAD_PRIVATE_MUTEX_LOCK(name)				\
	do {								\
		if (_thread_cb.tc_tag_lock != NULL)			\
			_thread_cb.tc_tag_lock(&(__THREAD_NAME(name)));	\
	} while (0)
#define _THREAD_PRIVATE_MUTEX_UNLOCK(name)				\
	do {								\
		if (_thread_cb.tc_tag_unlock != NULL)			\
			_thread_cb.tc_tag_unlock(&(__THREAD_NAME(name))); \
	} while (0)
#define _THREAD_PRIVATE(keyname, storage, error)			\
	(_thread_cb.tc_tag_storage == NULL ? &(storage) :		\
	    _thread_cb.tc_tag_storage(&(__THREAD_NAME(keyname)),	\
		&(storage), sizeof(storage), error))

/*
 * Macros used in libc to access mutexes.
 */
#define _MUTEX_LOCK(mutex)						\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_mutex_lock(mutex);		\
	} while (0)
#define _MUTEX_UNLOCK(mutex)						\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_mutex_unlock(mutex);		\
	} while (0)
#define _MUTEX_DESTROY(mutex)						\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_mutex_destroy(mutex);		\
	} while (0)

/*
 * malloc lock/unlock prototypes and definitions
 */
#define _MALLOC_LOCK(n)							\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_malloc_lock(n);			\
	} while (0)
#define _MALLOC_UNLOCK(n)						\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_malloc_unlock(n);			\
	} while (0)

#define _ATEXIT_LOCK()							\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_atexit_lock();			\
	} while (0)
#define _ATEXIT_UNLOCK()						\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_atexit_unlock();			\
	} while (0)

#define _ATFORK_LOCK()							\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_atfork_lock();			\
	} while (0)
#define _ATFORK_UNLOCK()						\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_atfork_unlock();			\
	} while (0)

#define _ARC4_LOCK()							\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_arc4_lock();			\
	} while (0)
#define _ARC4_UNLOCK()							\
	do {								\
		if (__isthreaded)					\
			_thread_cb.tc_arc4_unlock();			\
	} while (0)
#endif /* __LIBC__ */


/*
 * Copyright (c) 2004,2005 Ted Unangst <tedu@@openbsd.org>
 * All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Private data structures that back up the typedefs in pthread.h.
 * Since only the thread library cares about their size or arrangement,
 * it should be possible to switch libraries without relinking.
 *
 * Do not reorder _atomic_lock_t and sem_t variables in the structs.
 * This is due to alignment requirements of certain arches like hppa.
 * The current requirement is 16 bytes.
 *
 * THE MACHINE DEPENDENT CERROR CODE HAS HARD CODED OFFSETS INTO PTHREAD_T!
 */

#include <sys/queue.h>
#include <pthread.h>
#include <semaphore.h>
#include <machine/spinlock.h>

#define	_SPINLOCK_UNLOCKED _ATOMIC_LOCK_UNLOCKED

struct __sem {
	_atomic_lock_t lock;
	volatile int waitcount;
	volatile int value;
	int shared;
};

TAILQ_HEAD(pthread_queue, pthread);

#ifdef FUTEX

struct pthread_mutex {
	volatile unsigned int lock;
	int type;
	pthread_t owner;
	int count;
	int prioceiling;
};

struct pthread_cond {
	volatile unsigned int seq;
	clockid_t clock;
	struct pthread_mutex *mutex;
};

#else

struct pthread_mutex {
	_atomic_lock_t lock;
	struct pthread_queue lockers;
	int type;
	pthread_t owner;
	int count;
	int prioceiling;
};

struct pthread_cond {
	_atomic_lock_t lock;
	struct pthread_queue waiters;
	struct pthread_mutex *mutex;
	clockid_t clock;
};
#endif /* FUTEX */

struct pthread_mutex_attr {
	int ma_type;
	int ma_protocol;
	int ma_prioceiling;
};

struct pthread_cond_attr {
	clockid_t ca_clock;
};

struct pthread_attr {
	void *stack_addr;
	size_t stack_size;
	size_t guard_size;
	int detach_state;
	int contention_scope;
	int sched_policy;
	struct sched_param sched_param;
	int sched_inherit;
};

struct rthread_storage {
	int keyid;
	struct rthread_storage *next;
	void *data;
};

struct rthread_cleanup_fn {
	void (*fn)(void *);
	void *arg;
	struct rthread_cleanup_fn *next;
};

struct tib;
struct stack;
struct pthread {
	struct __sem donesem;
	unsigned int flags;
	_atomic_lock_t flags_lock;
	struct tib *tib;
	void *retval;
	void *(*fn)(void *);
	void *arg;
	char name[32];
	struct stack *stack;
	LIST_ENTRY(pthread) threads;
	TAILQ_ENTRY(pthread) waiting;
	pthread_cond_t blocking_cond;
	struct pthread_attr attr;
	struct rthread_storage *local_storage;
	struct rthread_cleanup_fn *cleanup_fns;

	/* cancel received in a delayed cancel block? */
	int delayed_cancel;
};
/* flags in pthread->flags */
#define	THREAD_DONE		0x001
#define	THREAD_DETACHED		0x002

/* flags in tib->tib_thread_flags */
#define	TIB_THREAD_ASYNC_CANCEL		0x001
#define	TIB_THREAD_INITIAL_STACK	0x002	/* has stack from exec */

#define ENTER_DELAYED_CANCEL_POINT(tib, self)				\
	(self)->delayed_cancel = 0;					\
	ENTER_CANCEL_POINT_INNER(tib, 1, 1)

/*
 * Internal functions exported from libc's thread bits for use by libpthread
 */
void	_spinlock(volatile _atomic_lock_t *);
int	_spinlocktry(volatile _atomic_lock_t *);
void	_spinunlock(volatile _atomic_lock_t *);

void	_rthread_debug(int, const char *, ...)
		__attribute__((__format__ (printf, 2, 3)));
pid_t	_thread_dofork(pid_t (*_sys_fork)(void));

/*
 * Threading syscalls not declared in system headers
 */
__dead void	__threxit(pid_t *);
int		__thrsleep(const volatile void *, clockid_t,
		    const struct timespec *, volatile void *, const int *);
int		__thrwakeup(const volatile void *, int n);
int		__thrsigdivert(sigset_t, siginfo_t *, const struct timespec *);

#endif /* _THREAD_PRIVATE_H_ */
@


1.29
log
@Wrap _malloc_init() so internal calls go directly

prodded by otto@@
ok kettenis@@ otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.28 2016/09/01 10:41:02 otto Exp $ */
d60 3
d64 3
d80 1
d104 2
a127 7
 * Resolver code is special cased in that it uses global keys.
 */
extern void *__THREAD_NAME(_res);
extern void *__THREAD_NAME(_res_ext);
extern void *__THREAD_NAME(serv_mutex);

/*
d239 167
@


1.28
log
@Less lock contention by using more pools for mult-threaded programs.
tested by many (thanks!) ok tedu, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.27 2016/05/07 19:05:22 guenther Exp $ */
d12 3
@


1.27
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.26 2015/04/07 01:27:07 guenther Exp $ */
d10 3
d78 2
a79 2
	void	(*tc_malloc_lock)(void);
	void	(*tc_malloc_unlock)(void);
d143 2
a144 2
#define _MALLOC_LOCK()					do {} while (0)
#define _MALLOC_UNLOCK()				do {} while (0)
d190 1
a190 1
#define _MALLOC_LOCK()							\
d193 1
a193 1
			_thread_cb.tc_malloc_lock();			\
d195 1
a195 1
#define _MALLOC_UNLOCK()						\
d198 1
a198 1
			_thread_cb.tc_malloc_unlock();			\
@


1.26
log
@Make pthread_atfork() track the DSO that called it like atexit() does,
unregistering callbacks if the DSO is unloaded.  Move the callback
handling from libpthread to libc, though libpthread still overrides the
inner call to handle locking and thread-library reinitialization.
Major version bump for both libc and libpthread.

verification that this fixes various ports ajacoutot@@
asm assistance miod@@; ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.25 2011/10/16 06:29:56 guenther Exp $ */
d8 1
a8 6
/*
 * This file defines the thread library interface to libc.  Thread
 * libraries must implement the functions described here for proper
 * inter-operation with libc.   libc contains weak versions of the
 * described functions for operation in a non-threaded environment.
 */
d11 95
a105 34
 * This variable is 0 until a second thread is created.
 */
extern int __isthreaded;

/*
 * Weak symbols are used in libc so that the thread library can
 * efficiently wrap libc functions.
 * 
 * Use WEAK_NAME(n) to get a libc-private name for n (_weak_n),
 *     WEAK_ALIAS(n) to generate the weak symbol n pointing to _weak_n,
 *     WEAK_PROTOTYPE(n) to generate a prototype for _weak_n (based on n).
 */
#define WEAK_NAME(name)		__CONCAT(_weak_,name)
#define WEAK_ALIAS(name)	__weak_alias(name, WEAK_NAME(name))
#ifdef __GNUC__
#define WEAK_PROTOTYPE(name)	__typeof__(name) WEAK_NAME(name)
#else
#define WEAK_PROTOTYPE(name)	/* typeof() only in gcc */
#endif

/*
 * Ditto for hand-written syscall stubs:
 * 
 * Use STUB_NAME(n) to get the strong name of the stub: _thread_sys_n
 *     STUB_ALIAS(n) to generate the weak symbol n pointing to _thread_sys_n,
 *     STUB_PROTOTYPE(n) to generate a prototype for _thread_sys_n (based on n).
 */
#define STUB_NAME(name)		__CONCAT(_thread_sys_,name)
#define STUB_ALIAS(name)	__weak_alias(name, STUB_NAME(name))
#ifdef __GNUC__
#define STUB_PROTOTYPE(name)	__typeof__(name) STUB_NAME(name)
#else
#define STUB_PROTOTYPE(name)	/* typeof() only in gcc */
#endif
d113 5
a117 33
 * helper functions that exist as (weak) null functions in libc and
 * (strong) functions in the thread library.   These functions:
 *
 * _thread_tag_lock:
 *	lock the mutex associated with the given tag.   If the given
 *	tag is NULL a tag is first allocated.
 *
 * _thread_tag_unlock:
 *	unlock the mutex associated with the given tag.   If the given
 *	tag is NULL a tag is first allocated.
 *
 * _thread_tag_storage:
 *	return a pointer to per thread instance of data associated
 *	with the given tag.  If the given tag is NULL a tag is first
 *	allocated.
 *
 * _thread_mutex_lock:
 *	lock the given mutex. If the given mutex is NULL,
 *	rely on rthreads/pthreads implementation to initialize
 *	the mutex before locking.
 *
 * _thread_mutex_unlock:
 *	unlock the given mutex.
 *
 * _thread_mutex_destroy:
 *	destroy the given mutex.
 */
void	_thread_tag_lock(void **);
void	_thread_tag_unlock(void **);
void   *_thread_tag_storage(void **, void *, size_t, void *);
void	_thread_mutex_lock(void **);
void	_thread_mutex_unlock(void **);
void	_thread_mutex_destroy(void **);
d130 20
d151 4
a154 1
	_thread_tag_lock(&(__THREAD_NAME(name)))
d156 4
a159 1
	_thread_tag_unlock(&(__THREAD_NAME(name)))
d161 3
a163 2
	_thread_tag_storage(&(__THREAD_NAME(keyname)), &(storage),	\
			    sizeof (storage), error)
d171 1
a171 1
			_thread_mutex_lock(mutex);			\
d176 1
a176 1
			_thread_mutex_unlock(mutex);			\
d181 1
a181 1
			_thread_mutex_destroy(mutex);			\
d185 1
a185 1
 * Resolver code is special cased in that it uses global keys.
d187 10
a196 3
extern void *__THREAD_NAME(_res);
extern void *__THREAD_NAME(_res_ext);
extern void *__THREAD_NAME(serv_mutex);
d198 10
a207 5
/*
 * malloc lock/unlock prototypes and definitions
 */
void	_thread_malloc_lock(void);
void	_thread_malloc_unlock(void);
d209 10
a218 44
#define _MALLOC_LOCK()		do {					\
					if (__isthreaded)		\
						_thread_malloc_lock();	\
				} while (0)
#define _MALLOC_UNLOCK()	do {					\
					if (__isthreaded)		\
						_thread_malloc_unlock();\
				} while (0)

void	_thread_atexit_lock(void);
void	_thread_atexit_unlock(void);

#define _ATEXIT_LOCK()		do {					\
					if (__isthreaded)		\
						_thread_atexit_lock();	\
				} while (0)
#define _ATEXIT_UNLOCK()	do {					\
					if (__isthreaded)		\
						_thread_atexit_unlock();\
				} while (0)

void	_thread_atfork_lock(void);
void	_thread_atfork_unlock(void);

#define _ATFORK_LOCK()		do {					\
					if (__isthreaded)		\
						_thread_atfork_lock();	\
				} while (0)
#define _ATFORK_UNLOCK()	do {					\
					if (__isthreaded)		\
						_thread_atfork_unlock();\
				} while (0)

void	_thread_arc4_lock(void);
void	_thread_arc4_unlock(void);

#define _ARC4_LOCK()		do {					\
					if (__isthreaded)		\
						_thread_arc4_lock();	\
				} while (0)
#define _ARC4_UNLOCK()		do {					\
					if (__isthreaded)		\
						_thread_arc4_unlock();\
				} while (0)
d220 11
a230 4
/*
 * Wrapper for _thread_sys_fork()
 */
pid_t	_thread_fork(void);
@


1.25
log
@Make consistent the syscall stubs for the syscalls that got special
handling to fix up the alignment of 64bit arguments so that they do
the same dance where _thread_sys_FOO is the real stub and FOO is a
weak alias.  For some of them, this is needed for cancellation handling.

From discussions with fgsch@@, ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.24 2008/06/14 15:43:43 otto Exp $ */
d163 12
d186 5
@


1.24
log
@remove _thread_malloc_init prototype
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.23 2008/06/13 21:18:42 otto Exp $ */
d34 15
@


1.23
log
@remove _MALLOC_LOCK_INIT; major bump; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.22 2008/01/01 00:43:39 kurt Exp $ */
a123 1
void	_thread_malloc_init(void);
@


1.22
log
@- make arc4random*() functions thread safe. Use a custom spinlock function
instead of the generic pthread macros since free(3) uses __arc4_getbyte()
when freeing small sized allocations and the generic pthread macros call
malloc(3).
- eliminate passing pointers to a static variable with global scope (rs)
for additional code clarity and reduction.
- shlib minor bumps for libc and libpthread due to new functions.
From andreas@@ with some bits from me. okay tedu@@ marc@@ w/some spot
checking from millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.21 2007/11/19 02:54:19 kurt Exp $ */
a134 4
				} while (0)
#define _MALLOC_LOCK_INIT()	do {					\
					if (__isthreaded)		\
						_thread_malloc_init();\
@


1.21
log
@fix misleading comment; the _MUTEX_LOCK/_MUTEX_UNLOCK macros work with
both static and non-static mutexs.
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.20 2007/06/05 18:11:48 kurt Exp $ */
d151 12
@


1.20
log
@_FD_LOCK/UNLOCK() is libpthread specific and not needed for librthread, so
isolate its usage to libpthread only and replace with generic non-static
mutex support in the one place it is needed:
 - remove _FD_LOCK/UNLOCK from lseek and ftruncate in libc and make the
   functions weak so that libpthread can override with its own new
   versions that do the locking.
 - remove _thread_fd_lock/unlock() weak functions from libc and adjust
   libpthread for the change.
 - add generic _thread_mutex_lock/unlock/destroy() weak functions in libc
   to support non-static mutexes in libc and add libpthread and librthread
   implementations for them. libc can utilize non-static mutexes via the
   new _MUTEX_LOCK/UNLOCK/DESTROY() macros. Actually these new macros can
   support both static and non-static mutexes but currently only using
   them for non-static.
 - make opendir/closedir/readdir/readdir_r/seekdir/telldir() thread-safe
   for both thread libraries by using a non-static mutex in the struct
   _dirdesc (typedef DIR), utilizing it in the *dir functions and remove
   remaining and incorrect _FD_LOCK/UNLOCK() use in libc.
 - add comments to both thread libraries to indicate libc depends on the
   current implementation of static mutex initialization. suggested by
   marc@@
 - major bump libc and libpthread due to function removal, structure
   change and weak symbol conversions.
okay marc@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.19 2006/09/26 14:18:28 kurt Exp $ */
d96 1
a96 1
 * Macros used in libc to access non-static mutexes.
@


1.19
log
@Part 2 of file descriptor race and deadlock corrections.

Adjust design of file descriptor table to eliminate races
with both opening and closing of file descriptor entries
and eliminates one class of deadlocks. One nice side effect
of this change in design should be better performance for
applications that open and close many file descriptors due
to reduced fd_table_lock contention and fd entry reuse.

- Add entry states to manage use of entry and eliminate
some closing races. fd entries are not deallocated upon
close() now.
- Call _thread_fd_table_init with one of five discreet
modes to properly initialize an entry and manage the
state transition to open.
- When closing an entry hold the entry spinlock locked
across the state transition and the _thread_sys_close
call to close another race.
- Introduce a new lock type FD_RDWR_CLOSE that transitions
either a closed entry or an open entry into closing state
and then waits for a RDWR lock so that the lock queue can
unwind normally. All subsequent fd lock attempts for that
entry are rejected with EBADF until the fd is fully closed,
or reopened by dup2(). Once a thread holds the FD_RDWR_LOCK
it is safe to close() it or dup2() on it.
- When a thread creates a new fd there is a window of time
when another thread could attempt to use the fd before the
creating thread has initialized the entry for it. This can
result in improper status_flags for the entry, so record
the entries init mode, detect when this has happened and
correct the status_flags when needed.

reviewed by marc@@ & brad@@, tested by several, okay brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.18 2006/02/22 07:16:31 otto Exp $ */
d57 11
d72 3
d94 20
a119 20

/*
 * File descriptor locking definitions.
 */
#define FD_READ		0x1
#define FD_WRITE	0x2
#define FD_RDWR		(FD_READ | FD_WRITE)
#define FD_RDWR_CLOSE	(FD_RDWR | 0x4)

struct timespec;
int	_thread_fd_lock(int, int, struct timespec *);
void	_thread_fd_unlock(int, int);

/*
 * Macros are used in libc code for historical (debug) reasons.
 * Define them here.
 */
#define _FD_LOCK(_fd,_type,_ts)	_thread_fd_lock(_fd, _type, _ts)
#define _FD_UNLOCK(_fd,_type)	_thread_fd_unlock(_fd, _type)

@


1.18
log
@Avouid a race in atexit() handling by introducing a lock. Problem
originally reported by Gergely Kovacs; help from dhartmei@@;
ok tedu@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.17 2005/11/15 11:56:40 millert Exp $ */
d93 1
@


1.17
log
@Use a forward declaration of struct timespec instead of assuming
it has already been defined by previous includes.  While this
is true at the moment, it will no longer be true after a pending
includes cleanup.  OK marc@@
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.16 2004/06/07 21:11:23 marc Exp $ */
d126 11
@


1.16
log
@
major bump to libc and libpthread to break the dependency of a
particular implementation of libpthread for libc.  libc no longer
needs pthread.h to compile.
OK millert@@, brad@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d94 1
@


1.15
log
@
thread safer libc (note: safer, not safe)
Access to the global _res structure replaced by pointers to a
per thread instance.  If unthreaded the pointer is to the
global structure.

Also replaced a 64k stack array with malloc-ed memory so
threaded aps (with a default 64k stack) have a chance at working.
ok deraadt@@
@
text
@d1 3
a3 1
/* $OpenBSD: thread_private.h,v 1.14 2002/11/05 22:19:55 marc Exp $ */
d8 6
a13 1
#include <pthread.h>
d16 1
a16 2
 * This variable is initially 0 when there is exactly one thread.
 * It should never decrease.
d28 2
a29 2
#define WEAK_NAME(name)			__CONCAT(_weak_,name)
#define WEAK_ALIAS(name)		__weak_alias(name, WEAK_NAME(name))
d31 1
a31 1
#define WEAK_PROTOTYPE(name)		__typeof__(name) WEAK_NAME(name)
d33 1
a33 1
#define WEAK_PROTOTYPE(name)		/* typeof() only in gcc */
d37 1
a37 7
 * These macros help in making persistent storage thread-specific.
 * Libc makes extensive use of private static data structures
 * that hold state across function invocation, and these macros
 * are no-ops when running single-threaded.
 *
 * Linking against the user-thread library causes these macros to
 * allocate storage on a per-thread basis.
d39 1
a39 14
	
#define __THREAD_MUTEX_NAME(name)	__CONCAT(_libc_storage_mutex_,name)
#define __THREAD_KEY_NAME(name)		__CONCAT(_libc_storage_key_,name)

struct _thread_private_key_struct {
	pthread_once_t		once;
	void			(*cleanfn)(void *);
	pthread_key_t		key;
};

void	_libc_private_storage_lock(pthread_mutex_t *);
void	_libc_private_storage_unlock(pthread_mutex_t *);
void *	_libc_private_storage(volatile struct _thread_private_key_struct *,
			      void *, size_t, void *);
d41 20
a60 12
/* Declare a module mutex. */
#define _THREAD_PRIVATE_MUTEX(name)					\
	static pthread_mutex_t __THREAD_MUTEX_NAME(name) = 		\
		PTHREAD_MUTEX_INITIALIZER			
		
/* Lock a module mutex against use by any other threads. */
#define _THREAD_PRIVATE_MUTEX_LOCK(name) 				\
	_libc_private_storage_lock(&__THREAD_MUTEX_NAME(name))
		
/* Unlock a module mutex. */
#define _THREAD_PRIVATE_MUTEX_UNLOCK(name) 				\
	_libc_private_storage_unlock(&__THREAD_MUTEX_NAME(name))
d62 7
a68 1
/* Declare a thread-private storage key. */
d70 16
a85 28
	static volatile struct _thread_private_key_struct		\
	__THREAD_KEY_NAME(name) = {					\
		PTHREAD_ONCE_INIT, 					\
		0							\
	}

/*
 * In threaded mode, return a pointer to thread-private memory of
 * the same size as, and (initially) with the same contents as 'storage'. If
 * an error occurs, the 'error' parameter is returned.
 * In single-threaded mode, no storage is allocated. Instead, a pointer
 * to storage is always returned.
 * The 'cleanfn' function of the key structure is called to free the storage.
 * If 'cleanfn' is NULL, then free() is used. This hook can be useful for
 * getting rid of memory leaks.
 */
#define _THREAD_PRIVATE(keyname, storage, error) 			\
	_libc_private_storage(&__THREAD_KEY_NAME(keyname),		\
			      &(storage), sizeof (storage), error)

/*
 * Keys used to access the per thread instances of resolver global data.
 * These are not static as they are referenced in several places.
 */
extern volatile struct _thread_private_key_struct __THREAD_KEY_NAME(_res);
#ifdef INET6
extern volatile struct _thread_private_key_struct __THREAD_KEY_NAME(_res_ext);
#endif
d90 6
a95 3
#define FD_READ		    0x1
#define FD_WRITE	    0x2
#define FD_RDWR		    (FD_READ | FD_WRITE)
d97 6
a102 4
#define _FD_LOCK(_fd,_type,_ts)						\
		_thread_fd_lock(_fd, _type, _ts, __FILE__, __LINE__)
#define _FD_UNLOCK(_fd,_type)						\
		_thread_fd_unlock(_fd, _type, __FILE__, __LINE__)
a103 2
int	_thread_fd_lock(int, int, struct timespec *, const char *, int);
void	_thread_fd_unlock(int, int, const char *, int);
d106 1
a106 1
 * malloc lock/unlock definitions
d108 5
a112 1
# define _MALLOC_LOCK()		do {					\
d116 1
a116 1
# define _MALLOC_UNLOCK()	do {					\
d120 1
a120 1
# define _MALLOC_LOCK_INIT()do {					\
a124 4

void	_thread_malloc_init(void);
void	_thread_malloc_lock(void);
void	_thread_malloc_unlock(void);
@


1.14
log
@
thread safe libc -- 2nd try.   OK miod@@, millert@@
Thanks to miod@@ for m68k and vax fixes
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.13 2002/11/03 23:58:39 marc Exp $ */
d88 9
@


1.13
log
@back out previous patch.. there are still some vax/m68k issues
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.12 2002/11/03 20:36:43 marc Exp $ */
a20 2
 *
 * If the symbol _NO_WEAK_ALIASES is defined, then symbols will be
a21 10

#ifdef _NO_WEAK_ALIASES
#ifdef _THREAD_SAFE
#define WEAK_NAME(name)			__CONCAT(_weak,name)
#else
#define WEAK_NAME(name)			name
#endif
#define WEAK_ALIAS(name)		/* unavailable */
#define WEAK_PROTOTYPE(name)		/* unnecessary */
#else /* !_NO_WEAK_ALIASES */
a28 1
#endif /* !_NO_WEAK_ALIASES */
d52 1
a52 1
	void *, size_t, void *);
d87 1
a87 12
		&(storage), sizeof (storage), error)

/*
 * Macros for locking and unlocking FILEs. These test if the
 * process is threaded to avoid locking when not required.
 */
#ifdef	_FLOCK_DEBUG
#define FLOCKFILE(fp)		_flockfile_debug(fp, __FILE__, __LINE__)
#else
#define FLOCKFILE(fp)		flockfile(fp)
#endif
#define	FUNLOCKFILE(fp)		funlockfile(fp)
d96 28
a123 14
#ifdef	_LOCK_DEBUG
#define _FD_LOCK(_fd,_type,_ts)		_thread_fd_lock_debug(_fd, _type, \
						_ts, __FILE__, __LINE__)
#define _FD_UNLOCK(_fd,_type)		_thread_fd_unlock_debug(_fd, _type, \
						__FILE__, __LINE__)
#else
#define _FD_LOCK(_fd,_type,_ts)		_thread_fd_lock(_fd, _type, _ts)
#define _FD_UNLOCK(_fd,_type)		_thread_fd_unlock(_fd, _type)
#endif

int	_thread_fd_lock(int, int, struct timespec *);
int	_thread_fd_lock_debug(int, int, struct timespec *, char *, int);
void	_thread_fd_unlock(int, int);
void	_thread_fd_unlock_debug(int, int, char *, int);
@


1.12
log
@
libc changes for thread safety.  Tested on:
alpha (millert@@), i386 (marc@@), m68k (millert@@ and miod@@),
powerpc (drahn@@ and dhartmei@@), sparc (millert@@ and marc@@),
sparc64 (marc@@), and vax (millert@@ and miod@@).
Thanks to millert@@, miod@@, and mickey@@ for fixes along the way.
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.11 2002/02/16 21:27:23 millert Exp $ */
d21 2
d24 10
d41 1
d65 1
a65 1
			      void *, size_t, void *);
d100 12
a111 1
			      &(storage), sizeof (storage), error)
d120 14
a133 28
#define _FD_LOCK(_fd,_type,_ts)						\
		_thread_fd_lock(_fd, _type, _ts, __FILE__, __LINE__)
#define _FD_UNLOCK(_fd,_type)						\
		_thread_fd_unlock(_fd, _type, __FILE__, __LINE__)

int	_thread_fd_lock(int, int, struct timespec *, const char *, int);
void	_thread_fd_unlock(int, int, const char *, int);

/*
 * malloc lock/unlock definitions
 */
# define _MALLOC_LOCK()		do {					\
					if (__isthreaded)		\
						_thread_malloc_lock();	\
				} while (0)
# define _MALLOC_UNLOCK()	do {					\
					if (__isthreaded)		\
						_thread_malloc_unlock();\
				} while (0)
# define _MALLOC_LOCK_INIT()do {					\
					if (__isthreaded)		\
						_thread_malloc_init();\
				} while (0)


void	_thread_malloc_init(void);
void	_thread_malloc_lock(void);
void	_thread_malloc_unlock(void);
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.10 2001/09/04 22:17:45 fgsch Exp $ */
a20 2
 *
 * If the symbol _NO_WEAK_ALIASES is defined, then symbols will be
a21 10

#ifdef _NO_WEAK_ALIASES
#ifdef _THREAD_SAFE
#define WEAK_NAME(name)			__CONCAT(_weak,name)
#else
#define WEAK_NAME(name)			name
#endif
#define WEAK_ALIAS(name)		/* unavailable */
#define WEAK_PROTOTYPE(name)		/* unnecessary */
#else /* !_NO_WEAK_ALIASES */
a28 1
#endif /* !_NO_WEAK_ALIASES */
d52 1
a52 1
	void *, size_t, void *);
d87 1
a87 12
		&(storage), sizeof (storage), error)

/*
 * Macros for locking and unlocking FILEs. These test if the
 * process is threaded to avoid locking when not required.
 */
#ifdef	_FLOCK_DEBUG
#define FLOCKFILE(fp)		_flockfile_debug(fp, __FILE__, __LINE__)
#else
#define FLOCKFILE(fp)		flockfile(fp)
#endif
#define	FUNLOCKFILE(fp)		funlockfile(fp)
d96 28
a123 14
#ifdef	_LOCK_DEBUG
#define _FD_LOCK(_fd,_type,_ts)		_thread_fd_lock_debug(_fd, _type, \
						_ts, __FILE__, __LINE__)
#define _FD_UNLOCK(_fd,_type)		_thread_fd_unlock_debug(_fd, _type, \
						__FILE__, __LINE__)
#else
#define _FD_LOCK(_fd,_type,_ts)		_thread_fd_lock(_fd, _type, _ts)
#define _FD_UNLOCK(_fd,_type)		_thread_fd_unlock(_fd, _type)
#endif

int	_thread_fd_lock(int, int, struct timespec *);
int	_thread_fd_lock_debug(int, int, struct timespec *, char *, int);
void	_thread_fd_unlock(int, int);
void	_thread_fd_unlock_debug(int, int, char *, int);
@


1.10
log
@put changes back, this time ALL the files.
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.9 2001/08/30 17:47:57 todd Exp $ */
d58 1
a58 1
	void			(*cleanfn)__P((void *));
@


1.9
log
@Back out fgsch@@'s tree breaking commits.
Test next time, ok?
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.8 2001/08/30 07:38:27 fgsch Exp $ */
d131 1
a131 1
int	_thread_fd_lock_debug(int, int, struct timespec *, const char *, int);
d133 1
a133 1
void	_thread_fd_unlock_debug(int, int, const char *, int);
@


1.8
log
@fix some const warnings
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.7 2001/08/12 12:03:01 heko Exp $ */
d131 1
a131 1
int	_thread_fd_lock_debug(int, int, struct timespec *, char *, int);
d133 1
a133 1
void	_thread_fd_unlock_debug(int, int, char *, int);
@


1.7
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.6 2001/01/04 21:45:30 todd Exp $ */
d131 1
a131 1
int	_thread_fd_lock_debug(int, int, struct timespec *, const char *, int);
d133 1
a133 1
void	_thread_fd_unlock_debug(int, int, const char *, int);
@


1.6
log
@grammer/spelling
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.5 2000/09/08 06:11:36 brad Exp $ */
d135 1
a135 1
#endif _THREAD_PRIVATE_H_
@


1.5
log
@typo in comment, AILASES -> ALIASES
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.4 2000/01/06 08:57:29 d Exp $ */
d9 1
a9 1
 * This variable is initally 0 when there is exactly one thread.
@


1.4
log
@oops
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.3 2000/01/06 07:47:09 d Exp $ */
d33 1
a33 1
#else /* !_NO_WEAK_AILASES */
@


1.3
log
@rewrite to use the helpers in the thread/ directory and to define weak alias macros
@
text
@d1 1
a1 1
/* $OpenBSD: thread_private.h,v 1.2 1999/01/06 05:19:32 d Exp $ */
d26 1
a26 1
#defined _THREAD_SAFE
@


1.2
log
@clean
@
text
@d1 1
a1 7
/*
 *
 * Support for thread-safety in libc and libc_r common code using macros 
 * to declare thread-safe data structures.
 *
 * $OpenBSD: thread_private.h,v 1.1 1998/11/20 11:18:41 d Exp $
 */
d6 2
d9 2
a10 6
 * Parts of this file are
 * Copyright (c) 1998 John Birrell <jb@@cimlogic.com.au>.
 * All rights reserved.
 *
 * $Id: thread_private.h,v 1.1 1998/11/20 11:18:41 d Exp $
 * $OpenBSD: thread_private.h,v 1.1 1998/11/20 11:18:41 d Exp $
d12 1
d15 8
a22 4
 * This global flag is non-zero when a process has created one
 * or more threads. It is used to avoid calling locking functions
 * when they are not required. In libc, this is always assumed
 * to be zero.
d25 13
a37 14
extern volatile int	__isthreaded;

#ifdef _THREAD_SAFE

#include <pthread.h>
#include "pthread_private.h"

/*
 * File lock contention is difficult to diagnose without knowing
 * where locks were set. Allow a debug library to be built which
 * records the source file and line number of each lock call.
 */
#ifdef	_FLOCK_DEBUG
#define _FLOCKFILE(x)	_flockfile_debug(x, __FILE__, __LINE__)
d39 1
a39 1
#define _FLOCKFILE(x)	flockfile(x)
d41 1
d47 4
a50 3
 * are no-ops when _THREAD_SAFE is not defined. 
 * In a thread-safe library, the static variables are used only for
 * initialising the per-thread instances of the state variables.
d52 9
d62 4
a65 13
/*
 * Give names to the private variables used to hold per-thread
 * data structures.
 */
#ifdef __STDC__
#define __THREAD_MUTEXP_NAME(name)	_thread_mutexp_inst__ ## name
#define __THREAD_MUTEX_NAME(name)	_thread_mutex_inst__ ## name
#define __THREAD_KEY_NAME(name)		_thread_key_inst__ ## name
#else
#define __THREAD_MUTEXP_NAME(name)	_thread_mutexp_inst__/**/name
#define __THREAD_MUTEX_NAME(name)	_thread_mutex_inst__/**/name
#define __THREAD_KEY_NAME(name)		_thread_key_inst__/**/name
#endif
d67 1
a67 3
/*
 * Mutex declare, lock and unlock macros.
 */
a68 2
	static struct pthread_mutex __THREAD_MUTEXP_NAME(name) =	\
		PTHREAD_MUTEX_STATIC_INITIALIZER;			\
d70 1
a70 1
		&__THREAD_MUTEXP_NAME(name);
d72 1
d74 1
a74 1
	pthread_mutex_lock(&__THREAD_MUTEX_NAME(name))
d76 1
d78 1
a78 1
	pthread_mutex_unlock(&__THREAD_MUTEX_NAME(name))
d80 1
a80 13
/*
 * A mutexed data structure used to hold the persistent state's key.
 */
struct _thread_private_key_struct {
	struct pthread_mutex	lockd;
	pthread_mutex_t		lock;
	int			init;
	pthread_key_t		key;
};

/*
 * Declaration of a per-thread state key.
 */
d84 1
a84 2
		PTHREAD_MUTEX_STATIC_INITIALIZER, 			\
		&__THREAD_KEY_NAME(name).lockd,				\
d86 1
a86 1
	};
d89 12
a100 48
 * Initialisation of storage space for a per-thread state variable.
 * A pointer to a per-thread *copy* of the _initv parameter is returned.
 * It calls malloc the first time and the space is automatically free'd
 * when the thread dies. If you need something a bit more complicated
 * than free() you will need to roll-your-own.
 */
#define _THREAD_PRIVATE(keyname, _initv, _errv) 			\
	({								\
		struct _thread_private_key_struct * __k = 		\
			&__THREAD_KEY_NAME(keyname);			\
		void* __p;						\
		extern void free __P((void*));				\
		extern void* malloc __P((size_t));			\
									\
		if (!__isthreaded) {					\
			/* non-threaded behaviour */			\
			__p = &(_initv);				\
			goto _ok;					\
		}							\
									\
		/* create key for first thread */			\
		pthread_mutex_lock(&__k->lock);				\
		if (__k->init == 0) {					\
			if (pthread_key_create(&__k->key, free)) {	\
				pthread_mutex_unlock(&__k->lock);	\
				goto _err;				\
			}						\
			__k->init = 1;					\
		}							\
		pthread_mutex_unlock(&__k->lock);			\
									\
		if ((__p = pthread_getspecific(__k->key)) == NULL) {	\
			/* alloc space on 1st call in this thread */	\
			if ((__p = malloc(sizeof(_initv))) == NULL) 	\
				goto _err;				\
				if (pthread_setspecific(__k->key, __p) != 0) { \
					free(__p);			\
					goto _err;			\
				}					\
			/* initialise with _initv */			\
		memcpy(__p, &_initv, sizeof(_initv));			\
		}							\
		goto _ok;						\
	_err:								\
		__p = (_errv);						\
	_ok:								\
		__p;							\
	})
d106 6
a111 4
#define	FLOCKFILE(fp)		if (__isthreaded) _FLOCKFILE(fp)
#define	FUNLOCKFILE(fp)		if (__isthreaded) funlockfile(fp)

#else /* !_THREAD_SAFE */
d114 1
a114 1
 * Do-nothing macros for single-threaded case.
d116 13
a128 9
#define _FD_LOCK(f,o,p)				(0)
#define _FD_UNLOCK(f,o)				/* nothing */
#define _THREAD_PRIVATE_KEY(_key)		/* nothing */
#define _THREAD_PRIVATE(keyname, _initv, _errv)	(&(_initv))
#define _THREAD_PRIVATE_MUTEX(_name)		/* nothing */
#define _THREAD_PRIVATE_MUTEX_LOCK(_name)	/* nothing */
#define _THREAD_PRIVATE_MUTEX_UNLOCK(_name)	/* nothing */
#define	FLOCKFILE(fp)				/* nothing */
#define	FUNLOCKFILE(fp)				/* nothing */
d130 4
a133 1
#endif /* !_THREAD_SAFE */
@


1.1
log
@Add thread-safety to libc, so that libc_r will build (on i386 at least).
All POSIX libc api now there (to P1003.1c/D10)
  (more md stuff is needed for other libc/arch/*)
  (setlogin is no longer a special syscall)
Add -pthread option to gcc (that makes it use -lc_r and -D_POSIX_THREADS).
Doc some re-entrant routines
Add libc_r to intro(3)
dig() uses some libc srcs and an extra -I was needed there.
Add more md stuff to libc_r.
Update includes for the pthreads api
Update libc_r TODO
@
text
@d6 1
a6 1
 * $OpenBSD$
d17 2
a18 2
 * $Id: libc_private.h,v 1.2 1998/05/05 22:02:29 jb Exp $
 * $OpenBSD$
d35 24
a71 1

d85 1
a85 10
 * These macros help in making persistent storage thread-specific.
 * Libc makes extensive use of private static data structures
 * that hold state across function invocation, and these macros
 * are no-ops when _THREAD_SAFE is not defined. 
 * In a thread-safe library, the static variables are used only for
 * initialising the per-thread instances of the state variables.
 */

/*
 * a mutexed data structure used to hold the persistent state's key
d155 6
a160 1
#else
d162 1
d165 1
a165 1
 * do-nothing macros for single-threaded case
d174 2
d177 1
a177 19
#endif

/*
 * File lock contention is difficult to diagnose without knowing
 * where locks were set. Allow a debug library to be built which
 * records the source file and line number of each lock call.
 */
#ifdef	_FLOCK_DEBUG
#define _FLOCKFILE(x)	_flockfile_debug(x, __FILE__, __LINE__)
#else
#define _FLOCKFILE(x)	flockfile(x)
#endif

/*
 * Macros for locking and unlocking FILEs. These test if the
 * process is threaded to avoid locking when not required.
 */
#define	FLOCKFILE(fp)		if (__isthreaded) _FLOCKFILE(fp)
#define	FUNLOCKFILE(fp)		if (__isthreaded) funlockfile(fp)
@

