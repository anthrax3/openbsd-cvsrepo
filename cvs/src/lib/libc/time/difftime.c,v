head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.10
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.9.0.40
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.38
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.34
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.32
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.30
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.28
	OPENBSD_5_0:1.9.0.26
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.24
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.22
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.18
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.20
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.16
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.14
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.12
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.10
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.6.0.14
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.12
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.10
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.16
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.14
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.12
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.02.10.01.24.28;	author tedu;	state Exp;
branches;
next	1.11;
commitid	9OFmiVkhHbkGfrXG;

1.11
date	2015.02.10.00.58.28;	author tedu;	state Exp;
branches;
next	1.10;
commitid	BJmS9JfSI9TVLFUc;

1.10
date	2015.02.09.08.36.53;	author tedu;	state Exp;
branches;
next	1.9;
commitid	EItAdoRLbJKsaPxo;

1.9
date	2005.08.08.08.05.38;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.19.15.51.29;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.05.13.40.51;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.04.19.12.09;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.01.18.23.24.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.14.03.16.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.34.48;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.02.08.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@now we're cooking with gas...
replace difftime with a clever gift from matthew. ok guenther.
@
text
@/*	$OpenBSD: difftime.c,v 1.11 2015/02/10 00:58:28 tedu Exp $ */
/* This file is placed in the public domain by Matthew Dempsky. */

#include "private.h"

#define HI(t) ((double)(t & 0xffffffff00000000LL))
#define LO(t) ((double)(t & 0x00000000ffffffffLL))

double
difftime(time_t t1, time_t t0)
{
	return (HI(t1) - HI(t0)) + (LO(t1) - LO(t0));
}
@


1.11
log
@matthew suggests a double cast so sf mortgages work right. :)
@
text
@d1 2
a2 2
/*	$OpenBSD: difftime.c,v 1.10 2015/02/09 08:36:53 tedu Exp $ */
/* This file is placed in the public domain by Ted Unangst. */
d6 3
d10 1
a10 1
difftime(time_t time1, time_t time0)
d12 1
a12 1
	return time1 - (double)time0;
@


1.10
log
@greatly simplfy and correct difftime for large time_t. ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: difftime.c,v 1.9 2005/08/08 08:05:38 espie Exp $ */
d9 1
a9 1
	return time1 - time0;
@


1.9
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 2
a2 5
/*	$OpenBSD$ */
/*
** This file is in the public domain, so clarified as of
** 1996-06-05 by Arthur David Olson.
*/
d4 1
a4 3
/*LINTLIBRARY*/

#include "private.h"	/* for time_t, TYPE_INTEGRAL, and TYPE_SIGNED */
d7 1
a7 3
difftime(time1, time0)
const time_t	time1;
const time_t	time0;
d9 1
a9 44
	/*
	** If (sizeof (double) > sizeof (time_t)) simply convert and subtract
	** (assuming that the larger type has more precision).
	** This is the common real-world case circa 2004.
	*/
	if (sizeof (double) > sizeof (time_t))
		return (double) time1 - (double) time0;
	if (!TYPE_INTEGRAL(time_t)) {
		/*
		** time_t is floating.
		*/
		return time1 - time0;
	}
	if (!TYPE_SIGNED(time_t)) {
		/*
		** time_t is integral and unsigned.
		** The difference of two unsigned values can't overflow
		** if the minuend is greater than or equal to the subtrahend.
		*/
		if (time1 >= time0)
			return time1 - time0;
		else	return -((double) (time0 - time1));
	}
	/*
	** time_t is integral and signed.
	** Handle cases where both time1 and time0 have the same sign
	** (meaning that their difference cannot overflow).
	*/
	if ((time1 < 0) == (time0 < 0))
		return time1 - time0;
	/*
	** time1 and time0 have opposite signs.
	** Punt if unsigned long is too narrow.
	*/
	if (sizeof (unsigned long) < sizeof (time_t))
		return (double) time1 - (double) time0;
	/*
	** Stay calm...decent optimizers will eliminate the complexity below.
	*/
	if (time1 >= 0 /* && time0 < 0 */)
		return (unsigned long) time1 +
			(unsigned long) (-(time0 + 1)) + 1;
	return -(double) ((unsigned long) time0 +
		(unsigned long) (-(time1 + 1)) + 1);
@


1.8
log
@update to tzcode2005k
@
text
@d1 1
a5 5

#if defined(LIBC_SCCS) && !defined(lint) && !defined(NOID)
static char elsieid[] = "@@(#)difftime.c	7.19";
static char rcsid[] = "$OpenBSD: difftime.c,v 1.7 2005/07/05 13:40:51 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.7
log
@Update to tzcode2005j.
@
text
@d3 1
a3 1
** 1996-06-05 by Arthur David Olson (arthur_david_olson@@nih.gov).
d7 2
a8 2
static char elsieid[] = "@@(#)difftime.c	7.18";
static char rcsid[] = "$OpenBSD: difftime.c,v 1.6 2002/04/04 19:12:09 millert Exp $";
@


1.6
log
@Minor updates from tzcode2002c
@
text
@d3 1
a3 1
** June 5, 1996 by Arthur David Olson (arthur_david_olson@@nih.gov).
d7 2
a8 2
static char elsieid[] = "@@(#)difftime.c	7.9";
static char rcsid[] = "$OpenBSD: difftime.c,v 1.5 1998/01/18 23:24:51 millert Exp $";
d13 1
a13 12
#include "private.h"

/*
** Algorithm courtesy Paul Eggert (eggert@@twinsun.com).
*/

#ifdef HAVE_LONG_DOUBLE
#define long_double	long double
#endif /* defined HAVE_LONG_DOUBLE */
#ifndef HAVE_LONG_DOUBLE
#define long_double	double
#endif /* !defined HAVE_LONG_DOUBLE */
d20 22
a41 12
	time_t	delta;
	time_t	hibit;

	{
		time_t		tt;
		double		d;
		long_double	ld;

		if (sizeof tt < sizeof d)
			return (double) time1 - (double) time0;
		if (sizeof tt < sizeof ld)
			return (long_double) time1 - (long_double) time0;
a42 2
	if (time1 < time0)
		return -difftime(time0, time1);
d44 3
a46 2
	** As much as possible, avoid loss of precision
	** by computing the difference before converting to double.
d48 2
a49 3
	delta = time1 - time0;
	if (delta >= 0)
		return delta;
d51 2
a52 1
	** Repair delta overflow.
d54 2
a55 1
	hibit = (~ (time_t) 0) << (TYPE_BIT(time_t) - 1);
d57 1
a57 22
	** The following expression rounds twice, which means
	** the result may not be the closest to the true answer.
	** For example, suppose time_t is 64-bit signed int,
	** long_double is IEEE 754 double with default rounding,
	** time1 = 9223372036854775807 and time0 = -1536.
	** Then the true difference is 9223372036854777343,
	** which rounds to 9223372036854777856
	** with a total error of 513.
	** But delta overflows to -9223372036854774273,
	** which rounds to -9223372036854774784, and correcting
	** this by subtracting 2 * (long_double) hibit
	** (i.e. by adding 2**64 = 18446744073709551616)
	** yields 9223372036854776832, which
	** rounds to 9223372036854775808
	** with a total error of 1535 instead.
	** This problem occurs only with very large differences.
	** It's too painful to fix this portably.
	** We are not alone in this problem;
	** some C compilers round twice when converting
	** large unsigned types to small floating types,
	** so if time_t is unsigned the "return delta" above
	** has the same double-rounding problem with those compilers.
d59 5
a63 1
	return delta - 2 * (long_double) hibit;
@


1.5
log
@tzcode1998b from ftp://elsie.nci.nih.gov/pub
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)difftime.c	7.7";
static char rcsid[] = "$OpenBSD: difftime.c,v 1.4 1997/01/14 03:16:44 millert Exp $";
d34 10
a43 4
	if (sizeof(time_t) < sizeof(double))
		return (double) time1 - (double) time0;
	if (sizeof(time_t) < sizeof(long_double))
		return (long_double) time1 - (long_double) time0;
@


1.4
log
@Update to tzcode1996o + our fixes.  Fixes problem pointed out
by cross@@va.pubnix.com.
@
text
@d6 3
a8 6
#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char	elsieid[] = "@@(#)difftime.c	7.7";
#else
static char rcsid[] = "$OpenBSD: difftime.c,v 1.3 1996/08/19 08:34:48 tholo Exp $";
#endif
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 5
d7 5
a11 1
static char rcsid[] = "$OpenBSD$";
@


1.2
log
@new common tz code
@
text
@d1 3
a3 7
/*	$NetBSD: difftime.c,v 1.3 1996/01/20 02:30:46 jtc Exp $	*/

#ifndef lint
#ifndef NOID
static char	elsieid[] = "@@(#)difftime.c	7.6";
#endif /* !defined NOID */
#endif /* !defined lint */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: difftime.c,v 1.2 1995/03/09 23:41:15 jtc Exp $	*/
d5 1
a5 1
static char	elsieid[] = "@@(#)difftime.c	7.5";
d48 1
a48 3
	hibit = 1;
	while ((hibit <<= 1) > 0)
		continue;
d68 1
a68 1
	** many C compilers round twice when converting
d71 1
a71 1
	** has the same double-rounding problem.
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
