head	1.25;
access;
symbols
	OPENBSD_5_6:1.22.0.18
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.16
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.12
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.8
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.10
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.6
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2015.02.09.12.37.47;	author tedu;	state dead;
branches;
next	1.24;
commitid	IrOn8khkOGvoGgaT;

1.24
date	2015.02.09.10.45.56;	author tedu;	state Exp;
branches;
next	1.23;
commitid	ehHQGVw2jVzVRMbg;

1.23
date	2015.02.09.08.25.11;	author tedu;	state Exp;
branches;
next	1.22;
commitid	1GKby7MIpIVNqvkA;

1.22
date	2010.08.23.22.35.34;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.29.22.26.51;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.30.13.20.42;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.06.19.35.16;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.18.21.54.17;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.08.08.05.38;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.05.13.40.51;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.19.05.01.01;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.18.22.33.43;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.01.11.37.02;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.06.00.17.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.05.00.43.20;	author tdeval;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.14.18.24.53;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.27.00.58.57;	author lebel;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.26.15.25.51;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.01.29.07.04.05;	author d;	state Exp;
branches;
next	1.6;

1.6
date	98.01.18.23.25.02;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.21.04.52.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.14.03.16.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.27.03.36.57;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.34.55;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@move zic and zdump source to appropriate directories
@
text
@/*	$OpenBSD: zdump.c,v 1.24 2015/02/09 10:45:56 tedu Exp $ */
/*
** This file is in the public domain, so clarified as of
** 2009-05-17 by Arthur David Olson.
*/

/*
** This code has been made independent of the rest of the time
** conversion package to increase confidence in the verification it provides.
** You can use this code to help in verifying other implementations.
*/

#include "stdio.h"	/* for stdout, stderr, perror */
#include "string.h"	/* for strlcpy */
#include "ctype.h"	/* for isascii, isalpha, isdigit */
#include "sys/types.h"	/* for time_t */
#include "time.h"	/* for struct tm */
#include "stdlib.h"	/* for exit, malloc, atoi */
#include "float.h"	/* for FLT_MAX and DBL_MAX */
#include "ctype.h"	/* for isalpha et al. */

#ifndef ZDUMP_LO_YEAR
#define ZDUMP_LO_YEAR	(-500)
#endif /* !defined ZDUMP_LO_YEAR */

#ifndef ZDUMP_HI_YEAR
#define ZDUMP_HI_YEAR	2500
#endif /* !defined ZDUMP_HI_YEAR */

#ifndef MAX_STRING_LENGTH
#define MAX_STRING_LENGTH	1024
#endif /* !defined MAX_STRING_LENGTH */

#ifndef TRUE
#define TRUE		1
#endif /* !defined TRUE */

#ifndef FALSE
#define FALSE		0
#endif /* !defined FALSE */

#ifndef SECSPERMIN
#define SECSPERMIN	60
#endif /* !defined SECSPERMIN */

#ifndef MINSPERHOUR
#define MINSPERHOUR	60
#endif /* !defined MINSPERHOUR */

#ifndef SECSPERHOUR
#define SECSPERHOUR	(SECSPERMIN * MINSPERHOUR)
#endif /* !defined SECSPERHOUR */

#ifndef HOURSPERDAY
#define HOURSPERDAY	24
#endif /* !defined HOURSPERDAY */

#ifndef EPOCH_YEAR
#define EPOCH_YEAR	1970
#endif /* !defined EPOCH_YEAR */

#ifndef TM_YEAR_BASE
#define TM_YEAR_BASE	1900
#endif /* !defined TM_YEAR_BASE */

#ifndef DAYSPERNYEAR
#define DAYSPERNYEAR	365
#endif /* !defined DAYSPERNYEAR */

#ifndef isleap
#define isleap(y) (((y) % 4) == 0 && (((y) % 100) != 0 || ((y) % 400) == 0))
#endif /* !defined isleap */

#ifndef isleap_sum
/*
** See tzfile.h for details on isleap_sum.
*/
#define isleap_sum(a, b)	isleap((a) % 400 + (b) % 400)
#endif /* !defined isleap_sum */

#define SECSPERDAY	((long) SECSPERHOUR * HOURSPERDAY)
#define SECSPERNYEAR	(SECSPERDAY * DAYSPERNYEAR)
#define SECSPERLYEAR	(SECSPERNYEAR + SECSPERDAY)

#ifndef HAVE_GETTEXT
#define HAVE_GETTEXT 0
#endif
#if HAVE_GETTEXT
#include "locale.h"	/* for setlocale */
#include "libintl.h"
#endif /* HAVE_GETTEXT */

#ifndef GNUC_or_lint
#ifdef lint
#define GNUC_or_lint
#else /* !defined lint */
#ifdef __GNUC__
#define GNUC_or_lint
#endif /* defined __GNUC__ */
#endif /* !defined lint */
#endif /* !defined GNUC_or_lint */

#ifndef INITIALIZE
#ifdef GNUC_or_lint
#define INITIALIZE(x)	((x) = 0)
#else /* !defined GNUC_or_lint */
#define INITIALIZE(x)
#endif /* !defined GNUC_or_lint */
#endif /* !defined INITIALIZE */

/*
** For the benefit of GNU folk...
** `_(MSGID)' uses the current locale's message library string for MSGID.
** The default is to use gettext if available, and use MSGID otherwise.
*/

#ifndef _
#if HAVE_GETTEXT
#define _(msgid) gettext(msgid)
#else /* !HAVE_GETTEXT */
#define _(msgid) msgid
#endif /* !HAVE_GETTEXT */
#endif /* !defined _ */

#ifndef TZ_DOMAIN
#define TZ_DOMAIN "tz"
#endif /* !defined TZ_DOMAIN */

extern char **	environ;
extern int	getopt(int argc, char * const argv[],
			const char * options);
extern char *	optarg;
extern int	optind;
extern char *	tzname[2];

static time_t	absolute_min_time;
static time_t	absolute_max_time;
static size_t	longest;
static char *	progname;
static int	warned;

static char *	abbr(struct tm * tmp);
static void	abbrok(const char * abbrp, const char * zone);
static long	delta(struct tm * newp, struct tm * oldp);
static void	dumptime(const struct tm * tmp);
static time_t	hunt(char * name, time_t lot, time_t	hit);
static void	setabsolutes(void);
static void	show(char * zone, time_t t, int v);
static const char *	tformat(void);
static time_t	yeartot(long y);

#ifndef TYPECHECK
#define my_localtime	localtime
#else /* !defined TYPECHECK */
static struct tm *
my_localtime(tp)
time_t *	tp;
{
	register struct tm *	tmp;

	tmp = localtime(tp);
	if (tp != NULL && tmp != NULL) {
		struct tm	tm;
		register time_t	t;

		tm = *tmp;
		t = mktime(&tm);
		if (t - *tp >= 1 || *tp - t >= 1) {
			(void) fflush(stdout);
			(void) fprintf(stderr, "\n%s: ", progname);
			(void) fprintf(stderr, tformat(), *tp);
			(void) fprintf(stderr, " ->");
			(void) fprintf(stderr, " year=%d", tmp->tm_year);
			(void) fprintf(stderr, " mon=%d", tmp->tm_mon);
			(void) fprintf(stderr, " mday=%d", tmp->tm_mday);
			(void) fprintf(stderr, " hour=%d", tmp->tm_hour);
			(void) fprintf(stderr, " min=%d", tmp->tm_min);
			(void) fprintf(stderr, " sec=%d", tmp->tm_sec);
			(void) fprintf(stderr, " isdst=%d", tmp->tm_isdst);
			(void) fprintf(stderr, " -> ");
			(void) fprintf(stderr, tformat(), t);
			(void) fprintf(stderr, "\n");
		}
	}
	return tmp;
}
#endif /* !defined TYPECHECK */

static void
abbrok(abbrp, zone)
const char * const	abbrp;
const char * const	zone;
{
	register const char *	cp;
	register char *		wp;

	if (warned)
		return;
	cp = abbrp;
	wp = NULL;
	while (isascii((unsigned char) *cp) && isalpha((unsigned char) *cp))
		++cp;
	if (cp - abbrp == 0)
		wp = _("lacks alphabetic at start");
	else if (cp - abbrp < 3)
		wp = _("has fewer than 3 alphabetics");
	else if (cp - abbrp > 6)
		wp = _("has more than 6 alphabetics");
	if (wp == NULL && (*cp == '+' || *cp == '-')) {
		++cp;
		if (isascii((unsigned char) *cp) &&
			isdigit((unsigned char) *cp))
				if (*cp++ == '1' && *cp >= '0' && *cp <= '4')
					++cp;
		if (*cp != '\0')
			wp = _("differs from POSIX standard");
	}
	if (wp == NULL)
		return;
	(void) fflush(stdout);
	(void) fprintf(stderr,
		_("%s: warning: zone \"%s\" abbreviation \"%s\" %s\n"),
		progname, zone, abbrp, wp);
	warned = TRUE;
}

static void
usage(stream, status)
FILE * const	stream;
const int	status;
{
	(void) fprintf(stream,
_("usage: %s [-v] [-c [loyear,]hiyear] zonename ...\n"), progname);
	exit(status);
}

int
main(argc, argv)
int	argc;
char *	argv[];
{
	register int		i;
	register int		c;
	register int		vflag;
	register char *		cutarg;
	register long		cutloyear = ZDUMP_LO_YEAR;
	register long		cuthiyear = ZDUMP_HI_YEAR;
	register time_t		cutlotime;
	register time_t		cuthitime;
	register char **	fakeenv;
	time_t			now;
	time_t			t;
	time_t			newt;
	struct tm		tm;
	struct tm		newtm;
	register struct tm *	tmp;
	register struct tm *	newtmp;

	INITIALIZE(cutlotime);
	INITIALIZE(cuthitime);
#if HAVE_GETTEXT
	(void) setlocale(LC_ALL, "");
#ifdef TZ_DOMAINDIR
	(void) bindtextdomain(TZ_DOMAIN, TZ_DOMAINDIR);
#endif /* defined TEXTDOMAINDIR */
	(void) textdomain(TZ_DOMAIN);
#endif /* HAVE_GETTEXT */
	progname = argv[0];
	vflag = 0;
	cutarg = NULL;
	while ((c = getopt(argc, argv, "c:v")) == 'c' || c == 'v')
		if (c == 'v')
			vflag = 1;
		else	cutarg = optarg;
	if ((c != EOF && c != -1) ||
		(optind == argc - 1 && strcmp(argv[optind], "=") == 0)) {
			usage(stderr, EXIT_FAILURE);
	}
	if (vflag) {
		if (cutarg != NULL) {
			long	lo;
			long	hi;
			char	dummy;

			if (sscanf(cutarg, "%ld%c", &hi, &dummy) == 1) {
				cuthiyear = hi;
			} else if (sscanf(cutarg, "%ld,%ld%c",
				&lo, &hi, &dummy) == 2) {
					cutloyear = lo;
					cuthiyear = hi;
			} else {
(void) fprintf(stderr, _("%s: wild -c argument %s\n"),
					progname, cutarg);
				exit(EXIT_FAILURE);
			}
		}
		setabsolutes();
		cutlotime = yeartot(cutloyear);
		cuthitime = yeartot(cuthiyear);
	}
	(void) time(&now);
	longest = 0;
	for (i = optind; i < argc; ++i)
		if (strlen(argv[i]) > longest)
			longest = strlen(argv[i]);
	{
		register int	from;
		register int	to;

		for (i = 0; environ[i] != NULL; ++i)
			continue;
		fakeenv = (char **) malloc((size_t) ((i + 2) *
			sizeof *fakeenv));
		if (fakeenv == NULL ||
			(fakeenv[0] = (char *) malloc(longest + 4)) == NULL) {
					(void) perror(progname);
					exit(EXIT_FAILURE);
		}
		to = 0;
		strlcpy(fakeenv[to++], "TZ=", longest + 4);
		for (from = 0; environ[from] != NULL; ++from)
			if (strncmp(environ[from], "TZ=", 3) != 0)
				fakeenv[to++] = environ[from];
		fakeenv[to] = NULL;
		environ = fakeenv;
	}
	for (i = optind; i < argc; ++i) {
		static char	buf[MAX_STRING_LENGTH];

		strlcpy(&fakeenv[0][3], argv[i], longest + 1);
		if (!vflag) {
			show(argv[i], now, FALSE);
			continue;
		}
		warned = FALSE;
		t = absolute_min_time;
		show(argv[i], t, TRUE);
		t += SECSPERHOUR * HOURSPERDAY;
		show(argv[i], t, TRUE);
		if (t < cutlotime)
			t = cutlotime;
		tmp = my_localtime(&t);
		if (tmp != NULL) {
			tm = *tmp;
			strlcpy(buf, abbr(&tm), sizeof buf);
		}
		for ( ; ; ) {
			if (t >= cuthitime || t >= cuthitime - SECSPERHOUR * 12)
				break;
			newt = t + SECSPERHOUR * 12;
			newtmp = localtime(&newt);
			if (newtmp != NULL)
				newtm = *newtmp;
			if ((tmp == NULL || newtmp == NULL) ? (tmp != newtmp) :
				(delta(&newtm, &tm) != (newt - t) ||
				newtm.tm_isdst != tm.tm_isdst ||
				strcmp(abbr(&newtm), buf) != 0)) {
					newt = hunt(argv[i], t, newt);
					newtmp = localtime(&newt);
					if (newtmp != NULL) {
						newtm = *newtmp;
						strlcpy(buf, abbr(&newtm),
							sizeof buf);
					}
			}
			t = newt;
			tm = newtm;
			tmp = newtmp;
		}
		t = absolute_max_time;
		t -= SECSPERHOUR * HOURSPERDAY;
		show(argv[i], t, TRUE);
		t += SECSPERHOUR * HOURSPERDAY;
		show(argv[i], t, TRUE);
	}
	if (fflush(stdout) || ferror(stdout)) {
		(void) fprintf(stderr, "%s: ", progname);
		(void) perror(_("Error writing to standard output"));
		exit(EXIT_FAILURE);
	}
	exit(EXIT_SUCCESS);
	/* If exit fails to exit... */
	return EXIT_FAILURE;
}

static void
setabsolutes(void)
{
	if (0.5 == (time_t) 0.5) {
		/*
		** time_t is floating.
		*/
		if (sizeof (time_t) == sizeof (float)) {
			absolute_min_time = (time_t) -FLT_MAX;
			absolute_max_time = (time_t) FLT_MAX;
		} else if (sizeof (time_t) == sizeof (double)) {
			absolute_min_time = (time_t) -DBL_MAX;
			absolute_max_time = (time_t) DBL_MAX;
		} else {
			(void) fprintf(stderr,
_("%s: use of -v on system with floating time_t other than float or double\n"),
				progname);
			exit(EXIT_FAILURE);
		}
	} else if (0 > (time_t) -1) {
		/*
		** time_t is signed.  Assume overflow wraps around.
		*/
		time_t t = 0;
		time_t t1 = 1;

		while (t < t1) {
			t = t1;
			t1 = 2 * t1 + 1;
		}

		absolute_max_time = t;
		t = -t;
		absolute_min_time = t - 1;
		if (t < absolute_min_time)
			absolute_min_time = t;
	} else {
		/*
		** time_t is unsigned.
		*/
		absolute_min_time = 0;
		absolute_max_time = absolute_min_time - 1;
	}
}

static time_t
yeartot(y)
const long	y;
{
	register long	myy;
	register long	seconds;
	register time_t	t;

	myy = EPOCH_YEAR;
	t = 0;
	while (myy != y) {
		if (myy < y) {
			seconds = isleap(myy) ? SECSPERLYEAR : SECSPERNYEAR;
			++myy;
			if (t > absolute_max_time - seconds) {
				t = absolute_max_time;
				break;
			}
			t += seconds;
		} else {
			--myy;
			seconds = isleap(myy) ? SECSPERLYEAR : SECSPERNYEAR;
			if (t < absolute_min_time + seconds) {
				t = absolute_min_time;
				break;
			}
			t -= seconds;
		}
	}
	return t;
}

static time_t
hunt(char *name, time_t lot, time_t hit)
{
	time_t			t;
	long			diff;
	struct tm		lotm;
	register struct tm *	lotmp;
	struct tm		tm;
	register struct tm *	tmp;
	char			loab[MAX_STRING_LENGTH];

	lotmp = my_localtime(&lot);
	if (lotmp != NULL) {
		lotm = *lotmp;
		(void) strlcpy(loab, abbr(&lotm), sizeof loab);
	}
	for ( ; ; ) {
		diff = (long) (hit - lot);
		if (diff < 2)
			break;
		t = lot;
		t += diff / 2;
		if (t <= lot)
			++t;
		else if (t >= hit)
			--t;
		tmp = my_localtime(&t);
		if (tmp != NULL)
			tm = *tmp;
		if ((lotmp == NULL || tmp == NULL) ? (lotmp == tmp) :
			(delta(&tm, &lotm) == (t - lot) &&
			tm.tm_isdst == lotm.tm_isdst &&
			strcmp(abbr(&tm), loab) == 0)) {
				lot = t;
				lotm = tm;
				lotmp = tmp;
		} else	hit = t;
	}
	show(name, lot, TRUE);
	show(name, hit, TRUE);
	return hit;
}

/*
** Thanks to Paul Eggert for logic used in delta.
*/

static long
delta(newp, oldp)
struct tm *	newp;
struct tm *	oldp;
{
	register long	result;
	register int	tmy;

	if (newp->tm_year < oldp->tm_year)
		return -delta(oldp, newp);
	result = 0;
	for (tmy = oldp->tm_year; tmy < newp->tm_year; ++tmy)
		result += DAYSPERNYEAR + isleap_sum(tmy, TM_YEAR_BASE);
	result += newp->tm_yday - oldp->tm_yday;
	result *= HOURSPERDAY;
	result += newp->tm_hour - oldp->tm_hour;
	result *= MINSPERHOUR;
	result += newp->tm_min - oldp->tm_min;
	result *= SECSPERMIN;
	result += newp->tm_sec - oldp->tm_sec;
	return result;
}

static void
show(char *zone, time_t t, int v)
{
	register struct tm *	tmp;

	(void) printf("%-*s  ", (int) longest, zone);
	if (v) {
		tmp = gmtime(&t);
		if (tmp == NULL) {
			(void) printf(tformat(), t);
		} else {
			dumptime(tmp);
			(void) printf(" UTC");
		}
		(void) printf(" = ");
	}
	tmp = my_localtime(&t);
	dumptime(tmp);
	if (tmp != NULL) {
		if (*abbr(tmp) != '\0')
			(void) printf(" %s", abbr(tmp));
		if (v) {
			(void) printf(" isdst=%d", tmp->tm_isdst);
#ifdef TM_GMTOFF
			(void) printf(" gmtoff=%ld", tmp->TM_GMTOFF);
#endif /* defined TM_GMTOFF */
		}
	}
	(void) printf("\n");
	if (tmp != NULL && *abbr(tmp) != '\0')
		abbrok(abbr(tmp), zone);
}

static char *
abbr(tmp)
struct tm *	tmp;
{
	register char *	result;
	static char	nada;

	if (tmp->tm_isdst != 0 && tmp->tm_isdst != 1)
		return &nada;
	result = tzname[tmp->tm_isdst];
	return (result == NULL) ? &nada : result;
}

/*
** The code below can fail on certain theoretical systems;
** it works on all known real-world systems as of 2004-12-30.
*/

static const char *
tformat(void)
{
	if (0.5 == (time_t) 0.5) {	/* floating */
		if (sizeof (time_t) > sizeof (double))
			return "%Lg";
		return "%g";
	}
	if (0 > (time_t) -1) {		/* signed */
		if (sizeof (time_t) > sizeof (long))
			return "%lld";
		if (sizeof (time_t) > sizeof (int))
			return "%ld";
		return "%d";
	}
	if (sizeof (time_t) > sizeof (unsigned long))
		return "%llu";
	if (sizeof (time_t) > sizeof (unsigned int))
		return "%lu";
	return "%u";
}

static void
dumptime(timeptr)
register const struct tm *	timeptr;
{
	static const char	wday_name[][3] = {
		"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
	};
	static const char	mon_name[][3] = {
		"Jan", "Feb", "Mar", "Apr", "May", "Jun",
		"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
	};
	register const char *	wn;
	register const char *	mn;
	register int		lead;
	register int		trail;

	if (timeptr == NULL) {
		(void) printf("NULL");
		return;
	}
	/*
	** The packaged versions of localtime and gmtime never put out-of-range
	** values in tm_wday or tm_mon, but since this code might be compiled
	** with other (perhaps experimental) versions, paranoia is in order.
	*/
	if (timeptr->tm_wday < 0 || timeptr->tm_wday >=
		(int) (sizeof wday_name / sizeof wday_name[0]))
			wn = "???";
	else		wn = wday_name[timeptr->tm_wday];
	if (timeptr->tm_mon < 0 || timeptr->tm_mon >=
		(int) (sizeof mon_name / sizeof mon_name[0]))
			mn = "???";
	else		mn = mon_name[timeptr->tm_mon];
	(void) printf("%.3s %.3s%3d %.2d:%.2d:%.2d ",
		wn, mn,
		timeptr->tm_mday, timeptr->tm_hour,
		timeptr->tm_min, timeptr->tm_sec);
#define DIVISOR	10
	trail = timeptr->tm_year % DIVISOR + TM_YEAR_BASE % DIVISOR;
	lead = timeptr->tm_year / DIVISOR + TM_YEAR_BASE / DIVISOR +
		trail / DIVISOR;
	trail %= DIVISOR;
	if (trail < 0 && lead > 0) {
		trail += DIVISOR;
		--lead;
	} else if (lead < 0 && trail > 0) {
		trail -= DIVISOR;
		++lead;
	}
	if (lead == 0)
		(void) printf("%d", trail);
	else	(void) printf("%d%d", lead, ((trail < 0) ? -trail : trail));
}
@


1.24
log
@if isascii isn't defined, don't define a retarded version
@
text
@d1 1
a1 1
/*	$OpenBSD: zdump.c,v 1.23 2015/02/09 08:25:11 tedu Exp $ */
@


1.23
log
@this removes just a few ifdef checks for things that should always be enabled,
and which we definitely don't want to workaround. no change in the compiled
code (yet).
some of these, like the first chunk are plain silly. the compiler used to
compile asctime has nothing to do with the format strings strftime should
support.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: zdump.c,v 1.22 2010/08/23 22:35:34 millert Exp $ */
a20 3
#ifndef isascii
#define isascii(x) 1
#endif /* !defined isascii */
@


1.22
log
@update to tzcode2010k from elsie.nci.nih.gov; OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zdump.c,v 1.21 2007/12/29 22:26:51 millert Exp $ */
a43 8

#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS	0
#endif /* !defined EXIT_SUCCESS */

#ifndef EXIT_FAILURE
#define EXIT_FAILURE	1
#endif /* !defined EXIT_FAILURE */
@


1.21
log
@update to tzcode2007j from elsie.nci.nih.gov; mostly ANSIfication
@
text
@d1 1
a1 1
/*	$OpenBSD: zdump.c,v 1.20 2007/06/30 13:20:42 millert Exp $ */
d4 2
a5 2
** Feb 14, 2003 by Arthur David Olson.
static char	elsieid[] = "@@(#)zdump.c	8.6";
d238 10
d288 1
a288 4
			(void) fprintf(stderr,
_("usage: %s [-v] [-c [loyear,]hiyear] zonename ...\n"),
				progname);
			exit(EXIT_FAILURE);
d359 1
a359 1
			if (t >= cuthitime)
a361 4
			if (newt >= cuthitime)
				break;
			if (newt <= t)
				break;
@


1.20
log
@Update to tzcode2007f from elsie.nci.nih.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: zdump.c,v 1.19 2007/02/06 19:35:16 millert Exp $ */
d5 1
a5 1
static char	elsieid[] = "@@(#)zdump.c	8.4";
d96 3
a139 4
#ifndef P
#define P(x)	x
#endif /* !defined P */

d141 2
a142 2
extern int	getopt P((int argc, char * const argv[],
			const char * options));
d153 9
a161 9
static char *	abbr P((struct tm * tmp));
static void	abbrok P((const char * abbrp, const char * zone));
static long	delta P((struct tm * newp, struct tm * oldp));
static void	dumptime P((const struct tm * tmp));
static time_t	hunt P((char * name, time_t lot, time_t	hit));
static void	setabsolutes P((void));
static void	show P((char * zone, time_t t, int v));
static const char *	tformat P((void));
static time_t	yeartot P((long y));
d395 1
a395 1
setabsolutes()
d593 1
a593 1
tformat()
@


1.19
log
@Update to tzcode2007a.  This adds support for 64bit time_t in case
we need it in the future.  All of our platforms currently have 32bit
time_t types.  This also extends the timezone data file format to
support both 32bit and 64bit data.  The 64bit data is located after
the 32bit data so binaries linked with the older tzcode simply won't
look at it.  A version field in the file header is used to determine
whether the data file is the old or extended format.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zdump.c,v 1.18 2006/02/18 21:54:17 millert Exp $ */
d5 1
a5 1
static char	elsieid[] = "@@(#)zdump.c	8.3";
d425 1
a425 1
		  
@


1.18
log
@Update to tzcode2006a; primarily just cast and const fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: zdump.c,v 1.17 2005/08/08 08:05:38 espie Exp $ */
d5 1
a5 1
*/
d23 1
a23 1
#endif
a137 1
#ifdef __STDC__
a138 3
#else /* !defined __STDC__ */
#define P(x)	()
#endif /* !defined __STDC__ */
d387 1
a387 1
		(void) perror(_("Error writing standard output"));
d416 1
a416 1
		** time_t is signed.
d418 2
a419 1
		register time_t	hibit;
d421 10
a430 4
		for (hibit = 1; (hibit * 2) != 0; hibit *= 2)
			continue;
		absolute_min_time = hibit;
		absolute_max_time = -(hibit + 1);
d473 1
a473 4
hunt(name, lot, hit)
char *	name;
time_t	lot;
time_t	hit;
d543 1
a543 4
show(zone, t, v)
char *	zone;
time_t	t;
int	v;
@


1.17
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
** Feb 14, 2003 by Arthur David Olson (arthur_david_olson@@nih.gov).
d20 4
d159 1
a159 1
static void	abbrok P((const char * abbr, const char * zone));
d206 2
a207 2
abbrok(abbr, zone)
const char * const	abbr;
d215 1
a215 1
	cp = abbr;
d217 1
a217 1
	while (isascii(*cp) && isalpha(*cp))
d219 1
a219 1
	if (cp - abbr == 0)
d221 1
a221 1
	if (cp - abbr < 3)
d223 1
a223 1
	if (cp - abbr > 6)
d227 6
a232 3
		if (isascii(*cp) && isdigit(*cp))
			if (*cp++ == '1' && *cp >= '0' && *cp <= '4')
				++cp;
a233 2
	if (*cp != '\0')
		wp = _("differs from POSIX standard");
d238 2
a239 2
		"%s: warning: zone \"%s\" abbreviation \"%s\" %s\n",
		progname, zone, abbr, wp);
d284 1
a284 1
_("usage %s [-v] [-c [loyear,]hiyear] zonename ...\n"),
d286 1
a286 1
			(void) exit(EXIT_FAILURE);
d303 1
a303 1
				(void) exit(EXIT_FAILURE);
d326 1
a326 1
					(void) exit(EXIT_FAILURE);
d392 1
a392 1
		(void) exit(EXIT_FAILURE);
d416 1
a416 1
			(void) exit(EXIT_FAILURE);
d516 1
a516 1
** Thanks to Paul Eggert (eggert@@twinsun.com) for logic used in delta.
@


1.16
log
@Update to tzcode2005j.
@
text
@d1 1
a5 5

#if defined(LIBC_SCCS) && !defined(lint) && !defined(NOID)
static char elsieid[] = "@@(#)zdump.c	7.65";
static char rcsid[] = "$OpenBSD: zdump.c,v 1.15 2004/10/19 05:01:01 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.15
log
@did not compile, sigh
@
text
@d7 2
a8 3
static char elsieid[] = "@@(#)zdump.c	7.31";
static char rcsid[] = "$OpenBSD: zdump.c,v 1.14 2004/10/18 22:33:43 millert Exp $";
static char	elsieid[] = "@@(#)zdump.c	7.40";
d19 1
d23 9
d82 1
a82 1
#define isleap(y) ((((y) % 4) == 0 && ((y) % 100) != 0) || ((y) % 400) == 0)
d85 11
d147 1
a147 1
			  const char * options));
d152 6
d159 1
d161 1
d163 1
a163 2
static size_t	longest;
static char *	progname;
d165 76
a240 1
static void	dumptime P((const struct tm * tmp));
d250 6
a255 4
	register char *		cutoff;
	register int		cutyear;
	register long		cuttime;
	char **			fakeenv;
a258 1
	time_t			hibit;
d261 2
d264 2
a265 1
	INITIALIZE(cuttime);
d267 1
a267 1
	(void) setlocale(LC_MESSAGES, "");
d275 1
a275 1
	cutoff = NULL;
d279 1
a279 1
		else	cutoff = optarg;
d283 2
a284 2
_("%s: usage is %s [-v] [-c cutoffyear] zonename ...\n"),
				argv[0], argv[0]);
d287 21
a307 8
	if (cutoff != NULL) {
		int	y;

		cutyear = atoi(cutoff);
		cuttime = 0;
		for (y = EPOCH_YEAR; y < cutyear; ++y)
			cuttime += DAYSPERNYEAR + isleap(y);
		cuttime *= SECSPERHOUR * HOURSPERDAY;
a313 2
	for (hibit = 1; (hibit << 1) != 0; hibit <<= 1)
		continue;
d318 1
a318 1
		for (i = 0;  environ[i] != NULL;  ++i)
d343 2
a344 6
		/*
		** Get lowest value of t.
		*/
		t = hibit;
		if (t > 0)		/* time_t is unsigned */
			t = 0;
d348 7
a354 2
		tm = *localtime(&t);
		strlcpy(buf, abbr(&tm), (sizeof buf));
d356 1
a356 1
			if (cutoff != NULL && t >= cuttime)
d359 1
a359 1
			if (cutoff != NULL && newt >= cuttime)
d363 5
a367 2
			newtm = *localtime(&newt);
			if (delta(&newtm, &tm) != (newt - t) ||
d369 1
a369 1
				strcmp(abbr(&newtm), buf) != 0) {
d371 6
a376 3
					newtm = *localtime(&newt);
					strlcpy(buf, abbr(&newtm),
						(sizeof buf));
d380 1
d382 1
a382 6
		/*
		** Get highest value of t.
		*/
		t = ~((time_t) 0);
		if (t < 0)		/* time_t is signed */
			t &= ~hibit;
d389 1
a389 1
		(void) fprintf(stderr, "%s: ", argv[0]);
d394 28
d423 43
a465 3
	/* gcc -Wall pacifier */
	for ( ; ; )
		continue;
d474 19
a492 9
	time_t		t;
	struct tm	lotm;
	struct tm	tm;
	static char	loab[MAX_STRING_LENGTH];

	lotm = *localtime(&lot);
	strlcpy(loab, abbr(&lotm), (sizeof loab));
	while ((hit - lot) >= 2) {
		t = lot / 2 + hit / 2;
d497 5
a501 2
		tm = *localtime(&t);
		if (delta(&tm, &lotm) == (t - lot) &&
d503 1
a503 1
			strcmp(abbr(&tm), loab) == 0) {
d506 1
d523 2
a524 2
	long	result;
	int	tmy;
d530 1
a530 1
		result += DAYSPERNYEAR + isleap(tmy + (long) TM_YEAR_BASE);
d547 1
a547 1
	struct tm *	tmp;
d551 8
a558 2
		dumptime(gmtime(&t));
		(void) printf(" UTC = ");
d560 1
a560 1
	tmp = localtime(&t);
d562 5
a566 4
	if (*abbr(tmp) != '\0')
		(void) printf(" %s", abbr(tmp));
	if (v) {
		(void) printf(" isdst=%d", tmp->tm_isdst);
d568 1
a568 1
		(void) printf(" gmtoff=%ld", tmp->TM_GMTOFF);
d570 1
d573 2
d590 27
d630 2
d633 4
d650 1
a650 1
	(void) printf("%.3s %.3s%3d %.2d:%.2d:%.2d %ld",
d653 16
a668 2
		timeptr->tm_min, timeptr->tm_sec,
		timeptr->tm_year + (long) TM_YEAR_BASE);
@


1.14
log
@Update to tzcode2004e from elsie.nci.nih.gov
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: zdump.c,v 1.13 2004/04/01 11:37:02 jmc Exp $";
d10 1
@


1.13
log
@sort options, correct SYNOPSIS, and sync usage();
@
text
@d8 2
a9 2
static char rcsid[] = "$OpenBSD: zdump.c,v 1.12 2003/10/06 00:17:13 millert Exp $";
#endif /* LIBC_SCCS and not lint */
d18 1
a18 1
#include "string.h"	/* for strcpy */
d75 1
a75 1
#if HAVE_GETTEXT - 0
d78 1
a78 1
#endif /* HAVE_GETTEXT - 0 */
d83 1
a83 2
#endif /* defined lint */
#ifndef lint
d93 1
a93 2
#endif /* defined GNUC_or_lint */
#ifndef GNUC_or_lint
d105 1
a105 1
#if HAVE_GETTEXT - 0
d107 1
a107 1
#else /* !(HAVE_GETTEXT - 0) */
d109 1
a109 1
#endif /* !(HAVE_GETTEXT - 0) */
d119 1
a119 2
#endif /* defined __STDC__ */
#ifndef __STDC__
d137 1
d159 1
a159 1
#if HAVE_GETTEXT - 0
d163 1
a163 1
#endif /* defined(TEXTDOMAINDIR) */
d165 1
a165 1
#endif /* HAVE_GETTEXT - 0 */
d327 1
a327 1
		result += DAYSPERNYEAR + isleap(tmy + TM_YEAR_BASE);
d347 4
a350 2
	if (v)
		(void) printf("%.24s UTC = ", asctime(gmtime(&t)));
d352 1
a352 1
	(void) printf("%.24s", asctime(tmp));
d375 34
@


1.12
log
@Update to tzcode2003c from elsie.nci.nih.gov
Fixes a pasto and implements better int oflow checking (doesn't rely on
unspecified behavior).
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: zdump.c,v 1.11 2003/04/05 00:43:20 tdeval Exp $";
d178 1
a178 1
_("%s: usage is %s [ -v ] [ -c cutoff ] zonename ...\n"),
@


1.11
log
@strcpy/strcat -> strlcpy/strlcat
ok tedu@@, hints by deraadt@@ and millert@@
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)zdump.c	7.29";
static char rcsid[] = "$OpenBSD: zdump.c,v 1.10 2003/02/14 18:24:53 millert Exp $";
@


1.10
log
@license clarifications; arthur_david_olson@@nih.gov
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: zdump.c,v 1.9 2001/06/27 00:58:57 lebel Exp $";
d212 1
a212 1
		(void) strcpy(fakeenv[to++], "TZ=");
d222 1
a222 1
		(void) strcpy(&fakeenv[0][3], argv[i]);
@


1.9
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d1 5
d8 1
a8 1
static char rcsid[] = "$OpenBSD: zdump.c,v 1.8 2001/03/26 15:25:51 millert Exp $";
@


1.8
log
@cosmetic changes from tzcode2001a
@
text
@d3 1
a3 1
static char rcsid[] = "$OpenBSD: zdump.c,v 1.7 1999/01/29 07:04:05 d Exp $";
d232 1
a232 1
		(void) strncpy(buf, abbr(&tm), (sizeof buf) - 1);
d247 2
a248 2
					(void) strncpy(buf, abbr(&newtm),
						(sizeof buf) - 1);
d288 1
a288 1
	(void) strncpy(loab, abbr(&lotm), (sizeof loab) - 1);
@


1.7
log
@tzcode1999a from ftp://elsie.nci.nih.gov/pub
@
text
@d2 2
a3 2
static char elsieid[] = "@@(#)zdump.c	7.28";
static char rcsid[] = "$OpenBSD: zdump.c,v 1.6 1998/01/18 23:25:02 millert Exp $";
d265 2
a266 3
		(void) fprintf(stderr, _("%s: Error writing "),
			argv[0]);
		(void) perror(_("standard output"));
@


1.6
log
@tzcode1998b from ftp://elsie.nci.nih.gov/pub
@
text
@d2 2
a3 2
static char elsieid[] = "@@(#)zdump.c	7.27";
static char rcsid[] = "$OpenBSD: zdump.c,v 1.5 1997/01/21 04:52:45 millert Exp $";
d131 1
a131 1
static time_t	hunt P((char * name, time_t lot, time_t hit));
d170 1
a170 1
	if (c != -1 ||
d265 1
a265 1
		(void) fprintf(stderr, _("%s: Error writing standard output "),
@


1.5
log
@Remove unnecesary local changes.  The strncpy()'s are safe because
the string is static and so the last element is always init'd to
zero.
@
text
@d1 3
a3 6
#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char	elsieid[] = "@@(#)zdump.c	7.24";
#else
static char rcsid[] = "$OpenBSD: zdump.c,v 1.4 1997/01/14 03:16:56 millert Exp $";
#endif
d113 9
d123 2
a124 1
extern int	getopt();
a126 1
extern time_t	time();
d129 4
a132 4
static char *	abbr();
static long	delta();
static time_t	hunt();
static int	longest;
d134 1
a134 1
static void	show();
d170 1
a170 1
	if (c != EOF ||
d202 1
a202 2
			(fakeenv[0] = (char *) malloc((size_t) (longest +
				4))) == NULL) {
d218 2
a219 2
		show(argv[i], now, FALSE);
		if (!vflag)
d221 1
a289 1
	loab[(sizeof loab) - 1] = '\0';
a335 2
extern struct tm *	localtime();

d344 1
a344 1
	(void) printf("%-*s  ", longest, zone);
d346 1
a346 1
		(void) printf("%.24s GMT = ", asctime(gmtime(&t)));
@


1.4
log
@Update to tzcode1996o + our fixes.  Fixes problem pointed out
by cross@@va.pubnix.com.
@
text
@d5 1
a5 1
static char rcsid[] = "$OpenBSD: zdump.c,v 1.3 1996/08/27 03:36:57 deraadt Exp $";
a226 1
		buf[(sizeof buf) - 1] = '\0';
a242 1
					buf[(sizeof buf) - 1] = '\0';
@


1.3
log
@use strncpy correctly
@
text
@d2 5
a6 1
static char rcsid[] = "$OpenBSD: zdump.c,v 1.2 1996/08/19 08:34:55 tholo Exp $";
d73 5
d98 18
d150 7
d167 1
a167 1
"%s: usage is %s [ -v ] [ -c cutoff ] zonename ...\n",
d226 2
a227 2
		(void) strncpy(buf, abbr(&tm), sizeof(buf) - 1);
		buf[sizeof(buf) - 1] = '\0';
d243 2
a244 2
						sizeof(buf) - 1);
					buf[sizeof(buf) - 1] = '\0';
d261 1
a261 1
		(void) fprintf(stderr, "%s: Error writing standard output ",
d263 1
a263 1
		(void) perror("standard output");
d285 2
a286 2
	(void) strncpy(loab, abbr(&lotm), sizeof(loab) - 1);
	loab[sizeof(loab) - 1] = '\0';
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d2 1
a2 1
static char rcsid[] = "$OpenBSD$";
d192 2
a193 1
		(void) strncpy(buf, abbr(&tm), (sizeof buf) - 1);
d209 2
a210 1
						(sizeof buf) - 1);
d251 2
a252 1
	(void) strncpy(loab, abbr(&lotm), (sizeof loab) - 1);
@


1.1
log
@Initial revision
@
text
@d1 3
a3 7
/*	$NetBSD: zdump.c,v 1.2 1995/03/10 18:12:43 jtc Exp $	*/

#ifndef lint
#ifndef NOID
static char	elsieid[] = "@@(#)zdump.c	7.20";
#endif /* !defined NOID */
#endif /* !defined lint */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
