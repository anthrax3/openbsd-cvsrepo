head	1.38;
access;
symbols
	OPENBSD_5_6:1.35.0.6
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.10
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.8
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.6
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.4
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.31.0.12
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.8
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.10
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.6
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.6
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.15.0.4
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2015.02.09.12.37.47;	author tedu;	state dead;
branches;
next	1.37;
commitid	IrOn8khkOGvoGgaT;

1.37
date	2015.02.09.11.29.19;	author tedu;	state Exp;
branches;
next	1.36;
commitid	tJvDnNK0SzmBKgN8;

1.36
date	2015.02.09.08.25.11;	author tedu;	state Exp;
branches;
next	1.35;
commitid	1GKby7MIpIVNqvkA;

1.35
date	2013.11.24.23.51.29;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.25.13.27.27;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.27.17.45.30;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.23.22.35.34;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.07.01.09.37;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.29.22.26.51;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.30.13.20.42;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.27.16.40.35;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.06.19.35.16;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.18.21.54.17;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.08.08.05.38;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.05.13.40.51;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.28.14.47.41;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.01.11.37.02;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.06.00.17.13;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.06.00.44.36;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.05.04.16.09;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.05.00.48.02;	author tdeval;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.14.18.24.53;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.04.19.12.09;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.06.23.05.12;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.05.20.53.38;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.16.16.24.04;	author d;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.30.23.30.25;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.30.23.26.45;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.07.01.23.05.39;	author d;	state Exp;
branches;
next	1.9;

1.9
date	99.01.29.07.04.05;	author d;	state Exp;
branches;
next	1.8;

1.8
date	99.01.28.23.44.37;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	98.01.18.23.25.04;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.40.55;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.14.03.16.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.08.34.56;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.29.02.08.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.11.17.46.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@move zic and zdump source to appropriate directories
@
text
@/*	$OpenBSD: zic.c,v 1.37 2015/02/09 11:29:19 tedu Exp $	*/
/*
** This file is in the public domain, so clarified as of
** 2006-07-17 by Arthur David Olson.
*/

#include "private.h"
#include "locale.h"
#include "tzfile.h"

#define	ZIC_VERSION	'2'

typedef int_fast64_t	zic_t;

#ifndef ZIC_MAX_ABBR_LEN_WO_WARN
#define ZIC_MAX_ABBR_LEN_WO_WARN	6
#endif /* !defined ZIC_MAX_ABBR_LEN_WO_WARN */

#include <sys/stat.h>
#define MKDIR_UMASK (S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)

/*
** On some ancient hosts, predicates like `isspace(C)' are defined
** only if isascii(C) || C == EOF. Modern hosts obey the C Standard,
** which says they are defined only if C == ((unsigned char) C) || C == EOF.
** Neither the C Standard nor Posix require that `isascii' exist.
** For portability, we check both ancient and modern requirements.
** If isascii is not defined, the isascii check succeeds trivially.
*/
#include "ctype.h"

#define OFFSET_STRLEN_MAXIMUM	(7 + INT_STRLEN_MAXIMUM(long))
#define RULE_STRLEN_MAXIMUM	8	/* "Mdd.dd.d" */

#define end(cp, n)	(memchr((cp), '\0', (n)))

struct rule {
	const char *	r_filename;
	int		r_linenum;
	const char *	r_name;

	int		r_loyear;	/* for example, 1986 */
	int		r_hiyear;	/* for example, 1986 */
	const char *	r_yrtype;
	int		r_lowasnum;
	int		r_hiwasnum;

	int		r_month;	/* 0..11 */

	int		r_dycode;	/* see below */
	int		r_dayofmonth;
	int		r_wday;

	long		r_tod;		/* time from midnight */
	int		r_todisstd;	/* above is standard time if TRUE */
					/* or wall clock time if FALSE */
	int		r_todisgmt;	/* above is GMT if TRUE */
					/* or local time if FALSE */
	long		r_stdoff;	/* offset from standard time */
	const char *	r_abbrvar;	/* variable part of abbreviation */

	int		r_todo;		/* a rule to do (used in outzone) */
	zic_t		r_temp;		/* used in outzone */
};

/*
**	r_dycode		r_dayofmonth	r_wday
*/

#define DC_DOM		0	/* 1..31 */	/* unused */
#define DC_DOWGEQ	1	/* 1..31 */	/* 0..6 (Sun..Sat) */
#define DC_DOWLEQ	2	/* 1..31 */	/* 0..6 (Sun..Sat) */

struct zone {
	const char *	z_filename;
	int		z_linenum;

	const char *	z_name;
	long		z_gmtoff;
	const char *	z_rule;
	const char *	z_format;

	long		z_stdoff;

	struct rule *	z_rules;
	int		z_nrules;

	struct rule	z_untilrule;
	zic_t		z_untiltime;
};

extern int	getopt(int argc, char * const argv[],
			const char * options);
extern int	link(const char * fromname, const char * toname);
extern char *	optarg;
extern int	optind;

static void	addtt(zic_t starttime, int type);
static int	addtype(long gmtoff, const char * abbr, int isdst,
				int ttisstd, int ttisgmt);
static void	leapadd(zic_t t, int positive, int rolling, int count);
static void	adjleap(void);
static void	associate(void);
static int	ciequal(const char * ap, const char * bp);
static void	convert(long val, char * buf);
static void	convert64(zic_t val, char * buf);
static void	dolink(const char * fromfield, const char * tofield);
static void	doabbr(char * abbr, size_t size, const char * format,
			const char * letters, int isdst, int doquotes);
static void	eat(const char * name, int num);
static void	eats(const char * name, int num,
			const char * rname, int rnum);
static long	eitol(int i);
static void	error(const char * message);
static char **	getfields(char * buf);
static long	gethms(const char * string, const char * errstrng,
			int signable);
static void	infile(const char * filename);
static void	inleap(char ** fields, int nfields);
static void	inlink(char ** fields, int nfields);
static void	inrule(char ** fields, int nfields);
static int	inzcont(char ** fields, int nfields);
static int	inzone(char ** fields, int nfields);
static int	inzsub(char ** fields, int nfields, int iscont);
static int	is32(zic_t x);
static int	itsabbr(const char * abbr, const char * word);
static int	itsdir(const char * name);
static int	lowerit(int c);
static char *	memcheck(char * tocheck);
static int	mkdirs(char * filename);
static void	newabbr(const char * abbr);
static long	oadd(long t1, long t2);
static void	outzone(const struct zone * zp, int ntzones);
static void	puttzcode(long code, FILE * fp);
static void	puttzcode64(zic_t code, FILE * fp);
static int	rcomp(const void * leftp, const void * rightp);
static zic_t	rpytime(const struct rule * rp, int wantedy);
static void	rulesub(struct rule * rp,
			const char * loyearp, const char * hiyearp,
			const char * typep, const char * monthp,
			const char * dayp, const char * timep);
static int 	stringoffset(char * result, size_t size, long offset);
static int	stringrule(char * result, size_t size, const struct rule * rp,
			long dstoff, long gmtoff);
static void 	stringzone(char * result, size_t size,
			const struct zone * zp, int ntzones);
static void	setboundaries(void);
static zic_t	tadd(zic_t t1, long t2);
static void	usage(FILE *stream, int status);
static void	writezone(const char * name, const char * string);
static int	yearistype(int year, const char * type);

static int		charcnt;
static int		errors;
static const char *	filename;
static int		leapcnt;
static int		leapseen;
static int		leapminyear;
static int		leapmaxyear;
static int		linenum;
static int		max_abbrvar_len;
static int		max_format_len;
static zic_t		max_time;
static int		max_year;
static zic_t		min_time;
static int		min_year;
static int		noise;
static const char *	rfilename;
static int		rlinenum;
static const char *	progname;
static int		timecnt;
static int		typecnt;

/*
** Line codes.
*/

#define LC_RULE		0
#define LC_ZONE		1
#define LC_LINK		2
#define LC_LEAP		3

/*
** Which fields are which on a Zone line.
*/

#define ZF_NAME		1
#define ZF_GMTOFF	2
#define ZF_RULE		3
#define ZF_FORMAT	4
#define ZF_TILYEAR	5
#define ZF_TILMONTH	6
#define ZF_TILDAY	7
#define ZF_TILTIME	8
#define ZONE_MINFIELDS	5
#define ZONE_MAXFIELDS	9

/*
** Which fields are which on a Zone continuation line.
*/

#define ZFC_GMTOFF	0
#define ZFC_RULE	1
#define ZFC_FORMAT	2
#define ZFC_TILYEAR	3
#define ZFC_TILMONTH	4
#define ZFC_TILDAY	5
#define ZFC_TILTIME	6
#define ZONEC_MINFIELDS	3
#define ZONEC_MAXFIELDS	7

/*
** Which files are which on a Rule line.
*/

#define RF_NAME		1
#define RF_LOYEAR	2
#define RF_HIYEAR	3
#define RF_COMMAND	4
#define RF_MONTH	5
#define RF_DAY		6
#define RF_TOD		7
#define RF_STDOFF	8
#define RF_ABBRVAR	9
#define RULE_FIELDS	10

/*
** Which fields are which on a Link line.
*/

#define LF_FROM		1
#define LF_TO		2
#define LINK_FIELDS	3

/*
** Which fields are which on a Leap line.
*/

#define LP_YEAR		1
#define LP_MONTH	2
#define LP_DAY		3
#define LP_TIME		4
#define LP_CORR		5
#define LP_ROLL		6
#define LEAP_FIELDS	7

/*
** Year synonyms.
*/

#define YR_MINIMUM	0
#define YR_MAXIMUM	1
#define YR_ONLY		2

static struct rule *	rules;
static int		nrules;	/* number of rules */

static struct zone *	zones;
static int		nzones;	/* number of zones */

struct link {
	const char *	l_filename;
	int		l_linenum;
	const char *	l_from;
	const char *	l_to;
};

static struct link *	links;
static int		nlinks;

struct lookup {
	const char *	l_word;
	const int	l_value;
};

static struct lookup const *	byword(const char * string,
					const struct lookup * lp);

static struct lookup const	line_codes[] = {
	{ "Rule",	LC_RULE },
	{ "Zone",	LC_ZONE },
	{ "Link",	LC_LINK },
	{ "Leap",	LC_LEAP },
	{ NULL,		0}
};

static struct lookup const	mon_names[] = {
	{ "January",	TM_JANUARY },
	{ "February",	TM_FEBRUARY },
	{ "March",	TM_MARCH },
	{ "April",	TM_APRIL },
	{ "May",	TM_MAY },
	{ "June",	TM_JUNE },
	{ "July",	TM_JULY },
	{ "August",	TM_AUGUST },
	{ "September",	TM_SEPTEMBER },
	{ "October",	TM_OCTOBER },
	{ "November",	TM_NOVEMBER },
	{ "December",	TM_DECEMBER },
	{ NULL,		0 }
};

static struct lookup const	wday_names[] = {
	{ "Sunday",	TM_SUNDAY },
	{ "Monday",	TM_MONDAY },
	{ "Tuesday",	TM_TUESDAY },
	{ "Wednesday",	TM_WEDNESDAY },
	{ "Thursday",	TM_THURSDAY },
	{ "Friday",	TM_FRIDAY },
	{ "Saturday",	TM_SATURDAY },
	{ NULL,		0 }
};

static struct lookup const	lasts[] = {
	{ "last-Sunday",	TM_SUNDAY },
	{ "last-Monday",	TM_MONDAY },
	{ "last-Tuesday",	TM_TUESDAY },
	{ "last-Wednesday",	TM_WEDNESDAY },
	{ "last-Thursday",	TM_THURSDAY },
	{ "last-Friday",	TM_FRIDAY },
	{ "last-Saturday",	TM_SATURDAY },
	{ NULL,			0 }
};

static struct lookup const	begin_years[] = {
	{ "minimum",	YR_MINIMUM },
	{ "maximum",	YR_MAXIMUM },
	{ NULL,		0 }
};

static struct lookup const	end_years[] = {
	{ "minimum",	YR_MINIMUM },
	{ "maximum",	YR_MAXIMUM },
	{ "only",	YR_ONLY },
	{ NULL,		0 }
};

static struct lookup const	leap_types[] = {
	{ "Rolling",	TRUE },
	{ "Stationary",	FALSE },
	{ NULL,		0 }
};

static const int	len_months[2][MONSPERYEAR] = {
	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
};

static const int	len_years[2] = {
	DAYSPERNYEAR, DAYSPERLYEAR
};

static struct attype {
	zic_t		at;
	unsigned char	type;
}			attypes[TZ_MAX_TIMES];
static long		gmtoffs[TZ_MAX_TYPES];
static char		isdsts[TZ_MAX_TYPES];
static unsigned char	abbrinds[TZ_MAX_TYPES];
static char		ttisstds[TZ_MAX_TYPES];
static char		ttisgmts[TZ_MAX_TYPES];
static char		chars[TZ_MAX_CHARS];
static zic_t		trans[TZ_MAX_LEAPS];
static long		corr[TZ_MAX_LEAPS];
static char		roll[TZ_MAX_LEAPS];

/*
** Memory allocation.
*/

static char *
memcheck(ptr)
char * const	ptr;
{
	if (ptr == NULL) {
		const char *e = strerror(errno);

		(void) fprintf(stderr, _("%s: Memory exhausted: %s\n"),
			progname, e);
		exit(EXIT_FAILURE);
	}
	return ptr;
}

static char *
ecatalloc(char *start, const char *tail)
{
	size_t len;
	char *str;

	len = strlen(start) + strlen(tail) + 1;
	str = memcheck(realloc(start, len));
	strlcat(str, tail, len);
	return str;
}

#define emalloc(size)		memcheck(malloc(size))
#define erealloc(ptr, size)	memcheck(realloc((ptr), (size)))
#define ecpyalloc(ptr)		memcheck(strdup(ptr))

/*
** Error handling.
*/

static void
eats(name, num, rname, rnum)
const char * const	name;
const int		num;
const char * const	rname;
const int		rnum;
{
	filename = name;
	linenum = num;
	rfilename = rname;
	rlinenum = rnum;
}

static void
eat(name, num)
const char * const	name;
const int		num;
{
	eats(name, num, (char *) NULL, -1);
}

static void
error(string)
const char * const	string;
{
	/*
	** Match the format of "cc" to allow sh users to
	**	zic ... 2>&1 | error -t "*" -v
	** on BSD systems.
	*/
	(void) fprintf(stderr, _("\"%s\", line %d: %s"),
		filename, linenum, string);
	if (rfilename != NULL)
		(void) fprintf(stderr, _(" (rule from \"%s\", line %d)"),
			rfilename, rlinenum);
	(void) fprintf(stderr, "\n");
	++errors;
}

static void
warning(string)
const char * const	string;
{
	char *	cp;

	cp = ecpyalloc(_("warning: "));
	cp = ecatalloc(cp, string);
	error(cp);
	free(cp);
	--errors;
}

static void
usage(FILE *stream, int status)
{
	(void) fprintf(stream, _("usage: %s [-v] [-d directory] [-L leapsecondfilename] [-l timezone]\n\t[-p timezone] [-y command] [filename ...]\n"),
		progname);
	exit(status);
}

static const char *	psxrules;
static const char *	lcltime;
static const char *	directory;
static const char *	leapsec;
static const char *	yitcommand;

int
main(argc, argv)
int	argc;
char *	argv[];
{
	register int	i;
	register int	j;
	register int	c;

	(void) umask(umask(S_IWGRP | S_IWOTH) | (S_IWGRP | S_IWOTH));
#if HAVE_GETTEXT
	(void) setlocale(LC_ALL, "");
#ifdef TZ_DOMAINDIR
	(void) bindtextdomain(TZ_DOMAIN, TZ_DOMAINDIR);
#endif /* defined TEXTDOMAINDIR */
	(void) textdomain(TZ_DOMAIN);
#endif /* HAVE_GETTEXT */
	progname = argv[0];
	if (TYPE_BIT(zic_t) < 64) {
		(void) fprintf(stderr, "%s: %s\n", progname,
			_("wild compilation-time specification of zic_t"));
		exit(EXIT_FAILURE);
	}
	while ((c = getopt(argc, argv, "d:l:p:L:vy:")) != -1)
		switch (c) {
			default:
				usage(stderr, EXIT_FAILURE);
			case 'd':
				if (directory == NULL)
					directory = optarg;
				else {
					(void) fprintf(stderr,
_("%s: More than one -d option specified\n"),
						progname);
					exit(EXIT_FAILURE);
				}
				break;
			case 'l':
				if (lcltime == NULL)
					lcltime = optarg;
				else {
					(void) fprintf(stderr,
_("%s: More than one -l option specified\n"),
						progname);
					exit(EXIT_FAILURE);
				}
				break;
			case 'p':
				if (psxrules == NULL)
					psxrules = optarg;
				else {
					(void) fprintf(stderr,
_("%s: More than one -p option specified\n"),
						progname);
					exit(EXIT_FAILURE);
				}
				break;
			case 'y':
				if (yitcommand == NULL)
					yitcommand = optarg;
				else {
					(void) fprintf(stderr,
_("%s: More than one -y option specified\n"),
						progname);
					exit(EXIT_FAILURE);
				}
				break;
			case 'L':
				if (leapsec == NULL)
					leapsec = optarg;
				else {
					(void) fprintf(stderr,
_("%s: More than one -L option specified\n"),
						progname);
					exit(EXIT_FAILURE);
				}
				break;
			case 'v':
				noise = TRUE;
				break;
		}
	if (optind == argc - 1 && strcmp(argv[optind], "=") == 0)
		usage(stderr, EXIT_FAILURE);	/* usage message by request */
	if (directory == NULL)
		directory = TZDIR;
	if (yitcommand == NULL)
		yitcommand = "yearistype";

	setboundaries();

	if (optind < argc && leapsec != NULL) {
		infile(leapsec);
		adjleap();
	}

	for (i = optind; i < argc; ++i)
		infile(argv[i]);
	if (errors)
		exit(EXIT_FAILURE);
	associate();
	for (i = 0; i < nzones; i = j) {
		/*
		** Find the next non-continuation zone entry.
		*/
		for (j = i + 1; j < nzones && zones[j].z_name == NULL; ++j)
			continue;
		outzone(&zones[i], j - i);
	}
	/*
	** Make links.
	*/
	for (i = 0; i < nlinks; ++i) {
		eat(links[i].l_filename, links[i].l_linenum);
		dolink(links[i].l_from, links[i].l_to);
		if (noise)
			for (j = 0; j < nlinks; ++j)
				if (strcmp(links[i].l_to,
					links[j].l_from) == 0)
						warning(_("link to link"));
	}
	if (lcltime != NULL) {
		eat("command line", 1);
		dolink(lcltime, TZDEFAULT);
	}
	if (psxrules != NULL) {
		eat("command line", 1);
		dolink(psxrules, TZDEFRULES);
	}
	return (errors == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}

static void
dolink(fromfield, tofield)
const char * const	fromfield;
const char * const	tofield;
{
	register char *	fromname;
	register char *	toname;

	if (fromfield[0] == '/')
		fromname = ecpyalloc(fromfield);
	else {
		fromname = ecpyalloc(directory);
		fromname = ecatalloc(fromname, "/");
		fromname = ecatalloc(fromname, fromfield);
	}
	if (tofield[0] == '/')
		toname = ecpyalloc(tofield);
	else {
		toname = ecpyalloc(directory);
		toname = ecatalloc(toname, "/");
		toname = ecatalloc(toname, tofield);
	}
	/*
	** We get to be careful here since
	** there's a fair chance of root running us.
	*/
	if (!itsdir(toname))
		(void) remove(toname);
	if (link(fromname, toname) != 0) {
		int	result;

		if (mkdirs(toname) != 0)
			exit(EXIT_FAILURE);

		result = link(fromname, toname);
#if HAVE_SYMLINK
		if (result != 0 && errno == EXDEV)
			result = symlink(fromname, toname);
#endif /* HAVE_SYMLINK */
		if (result != 0) {
			const char *e = strerror(errno);

			(void) fprintf(stderr,
				_("%s: Can't link from %s to %s: %s\n"),
				progname, fromname, toname, e);
			exit(EXIT_FAILURE);
		}
	}
	free(fromname);
	free(toname);
}

#define TIME_T_BITS_IN_FILE	64

static void
setboundaries(void)
{
	register int	i;

	min_time = -1;
	for (i = 0; i < TIME_T_BITS_IN_FILE - 1; ++i)
		min_time *= 2;
	max_time = -(min_time + 1);
}

static int
itsdir(name)
const char * const	name;
{
	register char *	myname;
	register int	accres;

	myname = ecpyalloc(name);
	myname = ecatalloc(myname, "/.");
	accres = access(myname, F_OK);
	free(myname);
	return accres == 0;
}

/*
** Associate sets of rules with zones.
*/

/*
** Sort by rule name.
*/

static int
rcomp(cp1, cp2)
const void *	cp1;
const void *	cp2;
{
	return strcmp(((const struct rule *) cp1)->r_name,
		((const struct rule *) cp2)->r_name);
}

static void
associate(void)
{
	register struct zone *	zp;
	register struct rule *	rp;
	register int		base, out;
	register int		i, j;

	if (nrules != 0) {
		(void) qsort((void *) rules, (size_t) nrules,
			(size_t) sizeof *rules, rcomp);
		for (i = 0; i < nrules - 1; ++i) {
			if (strcmp(rules[i].r_name,
				rules[i + 1].r_name) != 0)
					continue;
			if (strcmp(rules[i].r_filename,
				rules[i + 1].r_filename) == 0)
					continue;
			eat(rules[i].r_filename, rules[i].r_linenum);
			warning(_("same rule name in multiple files"));
			eat(rules[i + 1].r_filename, rules[i + 1].r_linenum);
			warning(_("same rule name in multiple files"));
			for (j = i + 2; j < nrules; ++j) {
				if (strcmp(rules[i].r_name,
					rules[j].r_name) != 0)
						break;
				if (strcmp(rules[i].r_filename,
					rules[j].r_filename) == 0)
						continue;
				if (strcmp(rules[i + 1].r_filename,
					rules[j].r_filename) == 0)
						continue;
				break;
			}
			i = j - 1;
		}
	}
	for (i = 0; i < nzones; ++i) {
		zp = &zones[i];
		zp->z_rules = NULL;
		zp->z_nrules = 0;
	}
	for (base = 0; base < nrules; base = out) {
		rp = &rules[base];
		for (out = base + 1; out < nrules; ++out)
			if (strcmp(rp->r_name, rules[out].r_name) != 0)
				break;
		for (i = 0; i < nzones; ++i) {
			zp = &zones[i];
			if (strcmp(zp->z_rule, rp->r_name) != 0)
				continue;
			zp->z_rules = rp;
			zp->z_nrules = out - base;
		}
	}
	for (i = 0; i < nzones; ++i) {
		zp = &zones[i];
		if (zp->z_nrules == 0) {
			/*
			** Maybe we have a local standard time offset.
			*/
			eat(zp->z_filename, zp->z_linenum);
			zp->z_stdoff = gethms(zp->z_rule, _("unruly zone"),
				TRUE);
			/*
			** Note, though, that if there's no rule,
			** a '%s' in the format is a bad thing.
			*/
			if (strchr(zp->z_format, '%') != 0)
				error(_("%s in ruleless zone"));
		}
	}
	if (errors)
		exit(EXIT_FAILURE);
}

static void
infile(name)
const char *	name;
{
	register FILE *			fp;
	register char **		fields;
	register char *			cp;
	register const struct lookup *	lp;
	register int			nfields;
	register int			wantcont;
	register int			num;
	char				buf[BUFSIZ];

	if (strcmp(name, "-") == 0) {
		name = _("standard input");
		fp = stdin;
	} else if ((fp = fopen(name, "r")) == NULL) {
		const char *e = strerror(errno);

		(void) fprintf(stderr, _("%s: Can't open %s: %s\n"),
			progname, name, e);
		exit(EXIT_FAILURE);
	}
	wantcont = FALSE;
	for (num = 1; ; ++num) {
		eat(name, num);
		if (fgets(buf, (int) sizeof buf, fp) != buf)
			break;
		cp = strchr(buf, '\n');
		if (cp == NULL) {
			error(_("line too long"));
			exit(EXIT_FAILURE);
		}
		*cp = '\0';
		fields = getfields(buf);
		nfields = 0;
		while (fields[nfields] != NULL) {
			static char	nada;

			if (strcmp(fields[nfields], "-") == 0)
				fields[nfields] = &nada;
			++nfields;
		}
		if (nfields == 0) {
			/* nothing to do */
		} else if (wantcont) {
			wantcont = inzcont(fields, nfields);
		} else {
			lp = byword(fields[0], line_codes);
			if (lp == NULL)
				error(_("input line of unknown type"));
			else switch ((int) (lp->l_value)) {
				case LC_RULE:
					inrule(fields, nfields);
					wantcont = FALSE;
					break;
				case LC_ZONE:
					wantcont = inzone(fields, nfields);
					break;
				case LC_LINK:
					inlink(fields, nfields);
					wantcont = FALSE;
					break;
				case LC_LEAP:
					if (name != leapsec)
						(void) fprintf(stderr,
_("%s: Leap line in non leap seconds file %s\n"),
							progname, name);
					else	inleap(fields, nfields);
					wantcont = FALSE;
					break;
				default:	/* "cannot happen" */
					(void) fprintf(stderr,
_("%s: panic: Invalid l_value %d\n"),
						progname, lp->l_value);
					exit(EXIT_FAILURE);
			}
		}
		free((char *) fields);
	}
	if (ferror(fp)) {
		(void) fprintf(stderr, _("%s: Error reading %s\n"),
			progname, filename);
		exit(EXIT_FAILURE);
	}
	if (fp != stdin && fclose(fp)) {
		const char *e = strerror(errno);

		(void) fprintf(stderr, _("%s: Error closing %s: %s\n"),
			progname, filename, e);
		exit(EXIT_FAILURE);
	}
	if (wantcont)
		error(_("expected continuation line not found"));
}

/*
** Convert a string of one of the forms
**	h	-h	hh:mm	-hh:mm	hh:mm:ss	-hh:mm:ss
** into a number of seconds.
** A null string maps to zero.
** Call error with errstring and return zero on errors.
*/

static long
gethms(string, errstring, signable)
const char *		string;
const char * const	errstring;
const int		signable;
{
	long	hh;
	int	mm, ss, sign;

	if (string == NULL || *string == '\0')
		return 0;
	if (!signable)
		sign = 1;
	else if (*string == '-') {
		sign = -1;
		++string;
	} else	sign = 1;
	if (sscanf(string, scheck(string, "%ld"), &hh) == 1)
		mm = ss = 0;
	else if (sscanf(string, scheck(string, "%ld:%d"), &hh, &mm) == 2)
		ss = 0;
	else if (sscanf(string, scheck(string, "%ld:%d:%d"),
		&hh, &mm, &ss) != 3) {
			error(errstring);
			return 0;
	}
	if (hh < 0 ||
		mm < 0 || mm >= MINSPERHOUR ||
		ss < 0 || ss > SECSPERMIN) {
			error(errstring);
			return 0;
	}
	if (LONG_MAX / SECSPERHOUR < hh) {
		error(_("time overflow"));
		return 0;
	}
	if (noise && hh == HOURSPERDAY && mm == 0 && ss == 0)
		warning(_("24:00 not handled by pre-1998 versions of zic"));
	if (noise && (hh > HOURSPERDAY ||
		(hh == HOURSPERDAY && (mm != 0 || ss != 0))))
warning(_("values over 24 hours not handled by pre-2007 versions of zic"));
	return oadd(eitol(sign) * hh * eitol(SECSPERHOUR),
		    eitol(sign) * (eitol(mm) * eitol(SECSPERMIN) + eitol(ss)));
}

static void
inrule(fields, nfields)
register char ** const	fields;
const int		nfields;
{
	static struct rule	r;

	if (nfields != RULE_FIELDS) {
		error(_("wrong number of fields on Rule line"));
		return;
	}
	if (*fields[RF_NAME] == '\0') {
		error(_("nameless rule"));
		return;
	}
	r.r_filename = filename;
	r.r_linenum = linenum;
	r.r_stdoff = gethms(fields[RF_STDOFF], _("invalid saved time"), TRUE);
	rulesub(&r, fields[RF_LOYEAR], fields[RF_HIYEAR], fields[RF_COMMAND],
		fields[RF_MONTH], fields[RF_DAY], fields[RF_TOD]);
	r.r_name = ecpyalloc(fields[RF_NAME]);
	r.r_abbrvar = ecpyalloc(fields[RF_ABBRVAR]);
	if (max_abbrvar_len < strlen(r.r_abbrvar))
		max_abbrvar_len = strlen(r.r_abbrvar);
	rules = (struct rule *) (void *) erealloc((char *) rules,
		(int) ((nrules + 1) * sizeof *rules));
	rules[nrules++] = r;
}

static int
inzone(fields, nfields)
register char ** const	fields;
const int		nfields;
{
	register int	i;
	static char *	buf;
	size_t		len;

	if (nfields < ZONE_MINFIELDS || nfields > ZONE_MAXFIELDS) {
		error(_("wrong number of fields on Zone line"));
		return FALSE;
	}
	if (strcmp(fields[ZF_NAME], TZDEFAULT) == 0 && lcltime != NULL) {
		len = 132 + strlen(TZDEFAULT);
		buf = erealloc(buf, len);
		(void) snprintf(buf, len,
_("\"Zone %s\" line and -l option are mutually exclusive"),
			TZDEFAULT);
		error(buf);
		return FALSE;
	}
	if (strcmp(fields[ZF_NAME], TZDEFRULES) == 0 && psxrules != NULL) {
		len = 132 + strlen(TZDEFRULES);
		buf = erealloc(buf, len);
		(void) snprintf(buf, len,
_("\"Zone %s\" line and -p option are mutually exclusive"),
			TZDEFRULES);
		error(buf);
		return FALSE;
	}
	for (i = 0; i < nzones; ++i)
		if (zones[i].z_name != NULL &&
			strcmp(zones[i].z_name, fields[ZF_NAME]) == 0) {
				len = 132 + strlen(fields[ZF_NAME]) +
					strlen(zones[i].z_filename);
				buf = erealloc(buf, len);
				(void) snprintf(buf, len,
_("duplicate zone name %s (file \"%s\", line %d)"),
					fields[ZF_NAME],
					zones[i].z_filename,
					zones[i].z_linenum);
				error(buf);
				return FALSE;
		}
	return inzsub(fields, nfields, FALSE);
}

static int
inzcont(fields, nfields)
register char ** const	fields;
const int		nfields;
{
	if (nfields < ZONEC_MINFIELDS || nfields > ZONEC_MAXFIELDS) {
		error(_("wrong number of fields on Zone continuation line"));
		return FALSE;
	}
	return inzsub(fields, nfields, TRUE);
}

static int
inzsub(fields, nfields, iscont)
register char ** const	fields;
const int		nfields;
const int		iscont;
{
	register char *		cp;
	static struct zone	z;
	register int		i_gmtoff, i_rule, i_format;
	register int		i_untilyear, i_untilmonth;
	register int		i_untilday, i_untiltime;
	register int		hasuntil;

	if (iscont) {
		i_gmtoff = ZFC_GMTOFF;
		i_rule = ZFC_RULE;
		i_format = ZFC_FORMAT;
		i_untilyear = ZFC_TILYEAR;
		i_untilmonth = ZFC_TILMONTH;
		i_untilday = ZFC_TILDAY;
		i_untiltime = ZFC_TILTIME;
		z.z_name = NULL;
	} else {
		i_gmtoff = ZF_GMTOFF;
		i_rule = ZF_RULE;
		i_format = ZF_FORMAT;
		i_untilyear = ZF_TILYEAR;
		i_untilmonth = ZF_TILMONTH;
		i_untilday = ZF_TILDAY;
		i_untiltime = ZF_TILTIME;
		z.z_name = ecpyalloc(fields[ZF_NAME]);
	}
	z.z_filename = filename;
	z.z_linenum = linenum;
	z.z_gmtoff = gethms(fields[i_gmtoff], _("invalid UTC offset"), TRUE);
	if ((cp = strchr(fields[i_format], '%')) != 0) {
		if (*++cp != 's' || strchr(cp, '%') != 0) {
			error(_("invalid abbreviation format"));
			return FALSE;
		}
	}
	z.z_rule = ecpyalloc(fields[i_rule]);
	z.z_format = ecpyalloc(fields[i_format]);
	if (max_format_len < strlen(z.z_format))
		max_format_len = strlen(z.z_format);
	hasuntil = nfields > i_untilyear;
	if (hasuntil) {
		z.z_untilrule.r_filename = filename;
		z.z_untilrule.r_linenum = linenum;
		rulesub(&z.z_untilrule,
			fields[i_untilyear],
			"only",
			"",
			(nfields > i_untilmonth) ?
			fields[i_untilmonth] : "Jan",
			(nfields > i_untilday) ? fields[i_untilday] : "1",
			(nfields > i_untiltime) ? fields[i_untiltime] : "0");
		z.z_untiltime = rpytime(&z.z_untilrule,
			z.z_untilrule.r_loyear);
		if (iscont && nzones > 0 &&
			z.z_untiltime > min_time &&
			z.z_untiltime < max_time &&
			zones[nzones - 1].z_untiltime > min_time &&
			zones[nzones - 1].z_untiltime < max_time &&
			zones[nzones - 1].z_untiltime >= z.z_untiltime) {
				error(_(
"Zone continuation line end time is not after end time of previous line"
					));
				return FALSE;
		}
	}
	zones = (struct zone *) (void *) erealloc((char *) zones,
		(int) ((nzones + 1) * sizeof *zones));
	zones[nzones++] = z;
	/*
	** If there was an UNTIL field on this line,
	** there's more information about the zone on the next line.
	*/
	return hasuntil;
}

static void
inleap(fields, nfields)
register char ** const	fields;
const int		nfields;
{
	register const char *		cp;
	register const struct lookup *	lp;
	register int			i, j;
	int				year, month, day;
	long				dayoff, tod;
	zic_t				t;

	if (nfields != LEAP_FIELDS) {
		error(_("wrong number of fields on Leap line"));
		return;
	}
	dayoff = 0;
	cp = fields[LP_YEAR];
	if (sscanf(cp, scheck(cp, "%d"), &year) != 1) {
		/*
		** Leapin' Lizards!
		*/
		error(_("invalid leaping year"));
		return;
	}
	if (!leapseen || leapmaxyear < year)
		leapmaxyear = year;
	if (!leapseen || leapminyear > year)
		leapminyear = year;
	leapseen = TRUE;
	j = EPOCH_YEAR;
	while (j != year) {
		if (year > j) {
			i = len_years[isleap(j)];
			++j;
		} else {
			--j;
			i = -len_years[isleap(j)];
		}
		dayoff = oadd(dayoff, eitol(i));
	}
	if ((lp = byword(fields[LP_MONTH], mon_names)) == NULL) {
		error(_("invalid month name"));
		return;
	}
	month = lp->l_value;
	j = TM_JANUARY;
	while (j != month) {
		i = len_months[isleap(year)][j];
		dayoff = oadd(dayoff, eitol(i));
		++j;
	}
	cp = fields[LP_DAY];
	if (sscanf(cp, scheck(cp, "%d"), &day) != 1 ||
		day <= 0 || day > len_months[isleap(year)][month]) {
			error(_("invalid day of month"));
			return;
	}
	dayoff = oadd(dayoff, eitol(day - 1));
	if (dayoff < 0 && !TYPE_SIGNED(zic_t)) {
		error(_("time before zero"));
		return;
	}
	if (dayoff < min_time / SECSPERDAY) {
		error(_("time too small"));
		return;
	}
	if (dayoff > max_time / SECSPERDAY) {
		error(_("time too large"));
		return;
	}
	t = (zic_t) dayoff * SECSPERDAY;
	tod = gethms(fields[LP_TIME], _("invalid time of day"), FALSE);
	cp = fields[LP_CORR];
	{
		register int	positive;
		int		count;

		if (strcmp(cp, "") == 0) { /* infile() turns "-" into "" */
			positive = FALSE;
			count = 1;
		} else if (strcmp(cp, "--") == 0) {
			positive = FALSE;
			count = 2;
		} else if (strcmp(cp, "+") == 0) {
			positive = TRUE;
			count = 1;
		} else if (strcmp(cp, "++") == 0) {
			positive = TRUE;
			count = 2;
		} else {
			error(_("illegal CORRECTION field on Leap line"));
			return;
		}
		if ((lp = byword(fields[LP_ROLL], leap_types)) == NULL) {
			error(_(
				"illegal Rolling/Stationary field on Leap line"
				));
			return;
		}
		leapadd(tadd(t, tod), positive, lp->l_value, count);
	}
}

static void
inlink(fields, nfields)
register char ** const	fields;
const int		nfields;
{
	struct link	l;

	if (nfields != LINK_FIELDS) {
		error(_("wrong number of fields on Link line"));
		return;
	}
	if (*fields[LF_FROM] == '\0') {
		error(_("blank FROM field on Link line"));
		return;
	}
	if (*fields[LF_TO] == '\0') {
		error(_("blank TO field on Link line"));
		return;
	}
	l.l_filename = filename;
	l.l_linenum = linenum;
	l.l_from = ecpyalloc(fields[LF_FROM]);
	l.l_to = ecpyalloc(fields[LF_TO]);
	links = (struct link *) (void *) erealloc((char *) links,
		(int) ((nlinks + 1) * sizeof *links));
	links[nlinks++] = l;
}

static void
rulesub(rp, loyearp, hiyearp, typep, monthp, dayp, timep)
register struct rule * const	rp;
const char * const		loyearp;
const char * const		hiyearp;
const char * const		typep;
const char * const		monthp;
const char * const		dayp;
const char * const		timep;
{
	register const struct lookup *	lp;
	register const char *		cp;
	register char *			dp;
	register char *			ep;

	if ((lp = byword(monthp, mon_names)) == NULL) {
		error(_("invalid month name"));
		return;
	}
	rp->r_month = lp->l_value;
	rp->r_todisstd = FALSE;
	rp->r_todisgmt = FALSE;
	dp = ecpyalloc(timep);
	if (*dp != '\0') {
		ep = dp + strlen(dp) - 1;
		switch (lowerit(*ep)) {
			case 's':	/* Standard */
				rp->r_todisstd = TRUE;
				rp->r_todisgmt = FALSE;
				*ep = '\0';
				break;
			case 'w':	/* Wall */
				rp->r_todisstd = FALSE;
				rp->r_todisgmt = FALSE;
				*ep = '\0';
				break;
			case 'g':	/* Greenwich */
			case 'u':	/* Universal */
			case 'z':	/* Zulu */
				rp->r_todisstd = TRUE;
				rp->r_todisgmt = TRUE;
				*ep = '\0';
				break;
		}
	}
	rp->r_tod = gethms(dp, _("invalid time of day"), FALSE);
	free(dp);
	/*
	** Year work.
	*/
	cp = loyearp;
	lp = byword(cp, begin_years);
	rp->r_lowasnum = lp == NULL;
	if (!rp->r_lowasnum) switch ((int) lp->l_value) {
		case YR_MINIMUM:
			rp->r_loyear = INT_MIN;
			break;
		case YR_MAXIMUM:
			rp->r_loyear = INT_MAX;
			break;
		default:	/* "cannot happen" */
			(void) fprintf(stderr,
				_("%s: panic: Invalid l_value %d\n"),
				progname, lp->l_value);
			exit(EXIT_FAILURE);
	} else if (sscanf(cp, scheck(cp, "%d"), &rp->r_loyear) != 1) {
		error(_("invalid starting year"));
		return;
	}
	cp = hiyearp;
	lp = byword(cp, end_years);
	rp->r_hiwasnum = lp == NULL;
	if (!rp->r_hiwasnum) switch ((int) lp->l_value) {
		case YR_MINIMUM:
			rp->r_hiyear = INT_MIN;
			break;
		case YR_MAXIMUM:
			rp->r_hiyear = INT_MAX;
			break;
		case YR_ONLY:
			rp->r_hiyear = rp->r_loyear;
			break;
		default:	/* "cannot happen" */
			(void) fprintf(stderr,
				_("%s: panic: Invalid l_value %d\n"),
				progname, lp->l_value);
			exit(EXIT_FAILURE);
	} else if (sscanf(cp, scheck(cp, "%d"), &rp->r_hiyear) != 1) {
		error(_("invalid ending year"));
		return;
	}
	if (rp->r_loyear > rp->r_hiyear) {
		error(_("starting year greater than ending year"));
		return;
	}
	if (*typep == '\0')
		rp->r_yrtype = NULL;
	else {
		if (rp->r_loyear == rp->r_hiyear) {
			error(_("typed single year"));
			return;
		}
		rp->r_yrtype = ecpyalloc(typep);
	}
	/*
	** Day work.
	** Accept things such as:
	**	1
	**	last-Sunday
	**	Sun<=20
	**	Sun>=7
	*/
	dp = ecpyalloc(dayp);
	if ((lp = byword(dp, lasts)) != NULL) {
		rp->r_dycode = DC_DOWLEQ;
		rp->r_wday = lp->l_value;
		rp->r_dayofmonth = len_months[1][rp->r_month];
	} else {
		if ((ep = strchr(dp, '<')) != 0)
			rp->r_dycode = DC_DOWLEQ;
		else if ((ep = strchr(dp, '>')) != 0)
			rp->r_dycode = DC_DOWGEQ;
		else {
			ep = dp;
			rp->r_dycode = DC_DOM;
		}
		if (rp->r_dycode != DC_DOM) {
			*ep++ = 0;
			if (*ep++ != '=') {
				error(_("invalid day of month"));
				free(dp);
				return;
			}
			if ((lp = byword(dp, wday_names)) == NULL) {
				error(_("invalid weekday name"));
				free(dp);
				return;
			}
			rp->r_wday = lp->l_value;
		}
		if (sscanf(ep, scheck(ep, "%d"), &rp->r_dayofmonth) != 1 ||
			rp->r_dayofmonth <= 0 ||
			(rp->r_dayofmonth > len_months[1][rp->r_month])) {
				error(_("invalid day of month"));
				free(dp);
				return;
		}
	}
	free(dp);
}

static void
convert(val, buf)
const long	val;
char * const	buf;
{
	register int	i;
	register int	shift;

	for (i = 0, shift = 24; i < 4; ++i, shift -= 8)
		buf[i] = val >> shift;
}

static void
convert64(val, buf)
const zic_t	val;
char * const	buf;
{
	register int	i;
	register int	shift;

	for (i = 0, shift = 56; i < 8; ++i, shift -= 8)
		buf[i] = val >> shift;
}

static void
puttzcode(val, fp)
const long	val;
FILE * const	fp;
{
	char	buf[4];

	convert(val, buf);
	(void) fwrite((void *) buf, (size_t) sizeof buf, (size_t) 1, fp);
}

static void
puttzcode64(val, fp)
const zic_t	val;
FILE * const	fp;
{
	char	buf[8];

	convert64(val, buf);
	(void) fwrite((void *) buf, (size_t) sizeof buf, (size_t) 1, fp);
}

static int
atcomp(avp, bvp)
const void *	avp;
const void *	bvp;
{
	const zic_t	a = ((const struct attype *) avp)->at;
	const zic_t	b = ((const struct attype *) bvp)->at;

	return (a < b) ? -1 : (a > b);
}

static int
is32(x)
const zic_t	x;
{
	return INT32_MIN <= x && x <= INT32_MAX;
}

static void
writezone(name, string)
const char * const	name;
const char * const	string;
{
	register FILE *			fp;
	register int			i, j;
	register int			leapcnt32, leapi32;
	register int			timecnt32, timei32;
	register int			pass;
	static char *			fullname;
	static const struct tzhead	tzh0;
	static struct tzhead		tzh;
	zic_t				ats[TZ_MAX_TIMES];
	unsigned char			types[TZ_MAX_TIMES];
	size_t				len;

	/*
	** Sort.
	*/
	if (timecnt > 1)
		(void) qsort((void *) attypes, (size_t) timecnt,
			(size_t) sizeof *attypes, atcomp);
	/*
	** Optimize.
	*/
	{
		int	fromi;
		int	toi;

		toi = 0;
		fromi = 0;
		while (fromi < timecnt && attypes[fromi].at < min_time)
			++fromi;
		if (isdsts[0] == 0)
			while (fromi < timecnt && attypes[fromi].type == 0)
				++fromi;	/* handled by default rule */
		for ( ; fromi < timecnt; ++fromi) {
			if (toi != 0 && ((attypes[fromi].at +
				gmtoffs[attypes[toi - 1].type]) <=
				(attypes[toi - 1].at + gmtoffs[toi == 1 ? 0
				: attypes[toi - 2].type]))) {
					attypes[toi - 1].type =
						attypes[fromi].type;
					continue;
			}
			if (toi == 0 ||
				attypes[toi - 1].type != attypes[fromi].type)
					attypes[toi++] = attypes[fromi];
		}
		timecnt = toi;
	}
	/*
	** Transfer.
	*/
	for (i = 0; i < timecnt; ++i) {
		ats[i] = attypes[i].at;
		types[i] = attypes[i].type;
	}
	/*
	** Correct for leap seconds.
	*/
	for (i = 0; i < timecnt; ++i) {
		j = leapcnt;
		while (--j >= 0)
			if (ats[i] > trans[j] - corr[j]) {
				ats[i] = tadd(ats[i], corr[j]);
				break;
			}
	}
	/*
	** Figure out 32-bit-limited starts and counts.
	*/
	timecnt32 = timecnt;
	timei32 = 0;
	leapcnt32 = leapcnt;
	leapi32 = 0;
	while (timecnt32 > 0 && !is32(ats[timecnt32 - 1]))
		--timecnt32;
	while (timecnt32 > 0 && !is32(ats[timei32])) {
		--timecnt32;
		++timei32;
	}
	while (leapcnt32 > 0 && !is32(trans[leapcnt32 - 1]))
		--leapcnt32;
	while (leapcnt32 > 0 && !is32(trans[leapi32])) {
		--leapcnt32;
		++leapi32;
	}
	len = strlen(directory) + 1 + strlen(name) + 1;
	fullname = erealloc(fullname, len);
	(void) snprintf(fullname, len, "%s/%s", directory, name);
	/*
	** Remove old file, if any, to snap links.
	*/
	if (!itsdir(fullname) && remove(fullname) != 0 && errno != ENOENT) {
		const char *e = strerror(errno);

		(void) fprintf(stderr, _("%s: Can't remove %s: %s\n"),
			progname, fullname, e);
		exit(EXIT_FAILURE);
	}
	if ((fp = fopen(fullname, "wb")) == NULL) {
		if (mkdirs(fullname) != 0)
			exit(EXIT_FAILURE);
		if ((fp = fopen(fullname, "wb")) == NULL) {
			const char *e = strerror(errno);

			(void) fprintf(stderr, _("%s: Can't create %s: %s\n"),
				progname, fullname, e);
			exit(EXIT_FAILURE);
		}
	}
	for (pass = 1; pass <= 2; ++pass) {
		register int	thistimei, thistimecnt;
		register int	thisleapi, thisleapcnt;
		register int	thistimelim, thisleaplim;
		int		writetype[TZ_MAX_TIMES];
		int		typemap[TZ_MAX_TYPES];
		register int	thistypecnt;
		char		thischars[TZ_MAX_CHARS];
		char		thischarcnt;
		int 		indmap[TZ_MAX_CHARS];

		if (pass == 1) {
			thistimei = timei32;
			thistimecnt = timecnt32;
			thisleapi = leapi32;
			thisleapcnt = leapcnt32;
		} else {
			thistimei = 0;
			thistimecnt = timecnt;
			thisleapi = 0;
			thisleapcnt = leapcnt;
		}
		thistimelim = thistimei + thistimecnt;
		thisleaplim = thisleapi + thisleapcnt;
		for (i = 0; i < typecnt; ++i)
			writetype[i] = thistimecnt == timecnt;
		if (thistimecnt == 0) {
			/*
			** No transition times fall in the current
			** (32- or 64-bit) window.
			*/
			if (typecnt != 0)
				writetype[typecnt - 1] = TRUE;
		} else {
			for (i = thistimei - 1; i < thistimelim; ++i)
				if (i >= 0)
					writetype[types[i]] = TRUE;
			/*
			** For America/Godthab and Antarctica/Palmer
			*/
			if (thistimei == 0)
				writetype[0] = TRUE;
		}
#ifndef LEAVE_SOME_PRE_2011_SYSTEMS_IN_THE_LURCH
		/*
		** For some pre-2011 systems: if the last-to-be-written
		** standard (or daylight) type has an offset different from the
		** most recently used offset,
		** append an (unused) copy of the most recently used type
		** (to help get global "altzone" and "timezone" variables
		** set correctly).
		*/
		{
			register int	mrudst, mrustd, hidst, histd, type;

			hidst = histd = mrudst = mrustd = -1;
			for (i = thistimei; i < thistimelim; ++i)
				if (isdsts[types[i]])
					mrudst = types[i];
				else	mrustd = types[i];
			for (i = 0; i < typecnt; ++i)
				if (writetype[i]) {
					if (isdsts[i])
						hidst = i;
					else	histd = i;
				}
			if (hidst >= 0 && mrudst >= 0 && hidst != mrudst &&
				gmtoffs[hidst] != gmtoffs[mrudst]) {
					isdsts[mrudst] = -1;
					type = addtype(gmtoffs[mrudst],
						&chars[abbrinds[mrudst]],
						TRUE,
						ttisstds[mrudst],
						ttisgmts[mrudst]);
					isdsts[mrudst] = TRUE;
					writetype[type] = TRUE;
			}
			if (histd >= 0 && mrustd >= 0 && histd != mrustd &&
				gmtoffs[histd] != gmtoffs[mrustd]) {
					isdsts[mrustd] = -1;
					type = addtype(gmtoffs[mrustd],
						&chars[abbrinds[mrustd]],
						FALSE,
						ttisstds[mrustd],
						ttisgmts[mrustd]);
					isdsts[mrustd] = FALSE;
					writetype[type] = TRUE;
			}
		}
#endif /* !defined LEAVE_SOME_PRE_2011_SYSTEMS_IN_THE_LURCH */
		thistypecnt = 0;
		for (i = 0; i < typecnt; ++i)
			typemap[i] = writetype[i] ?  thistypecnt++ : -1;
		for (i = 0; i < sizeof indmap / sizeof indmap[0]; ++i)
			indmap[i] = -1;
		thischarcnt = 0;
		for (i = 0; i < typecnt; ++i) {
			register char *	thisabbr;

			if (!writetype[i])
				continue;
			if (indmap[abbrinds[i]] >= 0)
				continue;
			thisabbr = &chars[abbrinds[i]];
			for (j = 0; j < thischarcnt; ++j)
				if (strcmp(&thischars[j], thisabbr) == 0)
					break;
			if (j == thischarcnt) {
				(void) strlcpy(&thischars[(int) thischarcnt],
					thisabbr, sizeof(thischars) - thischarcnt);
				thischarcnt += strlen(thisabbr) + 1;
			}
			indmap[abbrinds[i]] = j;
		}
#define DO(field)	(void) fwrite((void *) tzh.field, \
				(size_t) sizeof tzh.field, (size_t) 1, fp)
		tzh = tzh0;
		(void) strncpy(tzh.tzh_magic, TZ_MAGIC, sizeof tzh.tzh_magic);
		tzh.tzh_version[0] = ZIC_VERSION;
		convert(eitol(thistypecnt), tzh.tzh_ttisgmtcnt);
		convert(eitol(thistypecnt), tzh.tzh_ttisstdcnt);
		convert(eitol(thisleapcnt), tzh.tzh_leapcnt);
		convert(eitol(thistimecnt), tzh.tzh_timecnt);
		convert(eitol(thistypecnt), tzh.tzh_typecnt);
		convert(eitol(thischarcnt), tzh.tzh_charcnt);
		DO(tzh_magic);
		DO(tzh_version);
		DO(tzh_reserved);
		DO(tzh_ttisgmtcnt);
		DO(tzh_ttisstdcnt);
		DO(tzh_leapcnt);
		DO(tzh_timecnt);
		DO(tzh_typecnt);
		DO(tzh_charcnt);
#undef DO
		for (i = thistimei; i < thistimelim; ++i)
			if (pass == 1)
				puttzcode((long) ats[i], fp);
			else	puttzcode64(ats[i], fp);
		for (i = thistimei; i < thistimelim; ++i) {
			unsigned char	uc;

			uc = typemap[types[i]];
			(void) fwrite((void *) &uc,
				(size_t) sizeof uc,
				(size_t) 1,
				fp);
		}
		for (i = 0; i < typecnt; ++i)
			if (writetype[i]) {
				puttzcode(gmtoffs[i], fp);
				(void) putc(isdsts[i], fp);
				(void) putc((unsigned char) indmap[abbrinds[i]], fp);
			}
		if (thischarcnt != 0)
			(void) fwrite((void *) thischars,
				(size_t) sizeof thischars[0],
				(size_t) thischarcnt, fp);
		for (i = thisleapi; i < thisleaplim; ++i) {
			register zic_t	todo;

			if (roll[i]) {
				if (timecnt == 0 || trans[i] < ats[0]) {
					j = 0;
					while (isdsts[j])
						if (++j >= typecnt) {
							j = 0;
							break;
						}
				} else {
					j = 1;
					while (j < timecnt &&
						trans[i] >= ats[j])
							++j;
					j = types[j - 1];
				}
				todo = tadd(trans[i], -gmtoffs[j]);
			} else	todo = trans[i];
			if (pass == 1)
				puttzcode((long) todo, fp);
			else	puttzcode64(todo, fp);
			puttzcode(corr[i], fp);
		}
		for (i = 0; i < typecnt; ++i)
			if (writetype[i])
				(void) putc(ttisstds[i], fp);
		for (i = 0; i < typecnt; ++i)
			if (writetype[i])
				(void) putc(ttisgmts[i], fp);
	}
	(void) fprintf(fp, "\n%s\n", string);
	if (ferror(fp) || fclose(fp)) {
		(void) fprintf(stderr, _("%s: Error writing %s\n"),
			progname, fullname);
		exit(EXIT_FAILURE);
	}
}

static void
doabbr(abbr, size, format, letters, isdst, doquotes)
char * const		abbr;
size_t			size;
const char * const	format;
const char * const	letters;
const int		isdst;
const int		doquotes;
{
	register char *	cp;
	register char *	slashp;
	register int	len;

	slashp = strchr(format, '/');
	if (slashp == NULL) {
		if (letters == NULL)
			(void) strlcpy(abbr, format, size);
		else	(void) snprintf(abbr, size, format, letters);
	} else if (isdst) {
		(void) strlcpy(abbr, slashp + 1, size);
	} else {
		if (slashp - format + 1 < size)
			size = slashp - format + 1;
		(void) strlcpy(abbr, format, size);
	}
	if (!doquotes)
		return;
	for (cp = abbr; *cp != '\0'; ++cp)
		if (strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", *cp) == NULL &&
			strchr("abcdefghijklmnopqrstuvwxyz", *cp) == NULL)
				break;
	len = strlen(abbr);
	if (len > 0 && *cp == '\0')
		return;
	abbr[len + 2] = '\0';
	abbr[len + 1] = '>';
	for ( ; len > 0; --len)
		abbr[len] = abbr[len - 1];
	abbr[0] = '<';
}

static void
updateminmax(x)
const int	x;
{
	if (min_year > x)
		min_year = x;
	if (max_year < x)
		max_year = x;
}

static int
stringoffset(result, size, offset)
char *	result;
size_t	size;
long	offset;
{
	register int	hours;
	register int	minutes;
	register int	seconds;
	register char *	ep;

	result[0] = '\0';
	if (offset < 0) {
		(void) strlcpy(result, "-", size);
		offset = -offset;
	}
	seconds = offset % SECSPERMIN;
	offset /= SECSPERMIN;
	minutes = offset % MINSPERHOUR;
	offset /= MINSPERHOUR;
	hours = offset;
	if (hours >= HOURSPERDAY) {
		result[0] = '\0';
		return -1;
	}
	ep = end(result, size);
	(void) snprintf(ep, size - (ep - result), "%d", hours);
	if (minutes != 0 || seconds != 0) {
		ep = end(result, size);
		(void) snprintf(ep, size - (ep - result), ":%02d", minutes);
		if (seconds != 0) {
			ep = end(result, size);
			(void) snprintf(ep, size - (ep - result), ":%02d", seconds);
		}
	}
	return 0;
}

static int
stringrule(result, size, rp, dstoff, gmtoff)
char *				result;
size_t				size;
const struct rule * const	rp;
const long			dstoff;
const long			gmtoff;
{
	register long	tod;
	register char *	ep;

	ep = end(result, size);
	size -= ep - result;
	result = ep;
	if (rp->r_dycode == DC_DOM) {
		register int	month, total;

		if (rp->r_dayofmonth == 29 && rp->r_month == TM_FEBRUARY)
			return -1;
		total = 0;
		for (month = 0; month < rp->r_month; ++month)
			total += len_months[0][month];
		(void) snprintf(result, size, "J%d", total + rp->r_dayofmonth);
	} else {
		register int	week;

		if (rp->r_dycode == DC_DOWGEQ) {
			if ((rp->r_dayofmonth % DAYSPERWEEK) != 1)
				return -1;
			week = 1 + rp->r_dayofmonth / DAYSPERWEEK;
		} else if (rp->r_dycode == DC_DOWLEQ) {
			if (rp->r_dayofmonth == len_months[1][rp->r_month])
				week = 5;
			else {
				if ((rp->r_dayofmonth % DAYSPERWEEK) != 0)
					return -1;
				week = rp->r_dayofmonth / DAYSPERWEEK;
			}
		} else	return -1;	/* "cannot happen" */
		(void) snprintf(result, size, "M%d.%d.%d",
			rp->r_month + 1, week, rp->r_wday);
	}
	tod = rp->r_tod;
	if (rp->r_todisgmt)
		tod += gmtoff;
	if (rp->r_todisstd && rp->r_stdoff == 0)
		tod += dstoff;
	if (tod < 0) {
		result[0] = '\0';
		return -1;
	}
	if (tod != 2 * SECSPERMIN * MINSPERHOUR) {
		(void) strlcat(result, "/", size);
		ep = end(result, size);
		if (stringoffset(ep, size - (ep - result), tod) != 0)
			return -1;
	}
	return 0;
}

static void
stringzone(result, size, zpfirst, zonecount)
char *				result;
size_t				size;
const struct zone * const	zpfirst;
const int			zonecount;
{
	register const struct zone *	zp;
	register struct rule *		rp;
	register struct rule *		stdrp;
	register struct rule *		dstrp;
	register int			i;
	register const char *		abbrvar;
	register char *			ep;

	result[0] = '\0';
	zp = zpfirst + zonecount - 1;
	stdrp = dstrp = NULL;
	for (i = 0; i < zp->z_nrules; ++i) {
		rp = &zp->z_rules[i];
		if (rp->r_hiwasnum || rp->r_hiyear != INT_MAX)
			continue;
		if (rp->r_yrtype != NULL)
			continue;
		if (rp->r_stdoff == 0) {
			if (stdrp == NULL)
				stdrp = rp;
			else	return;
		} else {
			if (dstrp == NULL)
				dstrp = rp;
			else	return;
		}
	}
	if (stdrp == NULL && dstrp == NULL) {
		/*
		** There are no rules running through "max".
		** Let's find the latest rule.
		*/
		for (i = 0; i < zp->z_nrules; ++i) {
			rp = &zp->z_rules[i];
			if (stdrp == NULL || rp->r_hiyear > stdrp->r_hiyear ||
				(rp->r_hiyear == stdrp->r_hiyear &&
				rp->r_month > stdrp->r_month))
					stdrp = rp;
		}
		if (stdrp != NULL && stdrp->r_stdoff != 0)
			return;	/* We end up in DST (a POSIX no-no). */
		/*
		** Horrid special case: if year is 2037,
		** presume this is a zone handled on a year-by-year basis;
		** do not try to apply a rule to the zone.
		*/
		if (stdrp != NULL && stdrp->r_hiyear == 2037)
			return;
	}
	if (stdrp == NULL && (zp->z_nrules != 0 || zp->z_stdoff != 0))
		return;
	abbrvar = (stdrp == NULL) ? "" : stdrp->r_abbrvar;
	doabbr(result, size, zp->z_format, abbrvar, FALSE, TRUE);
	ep = end(result, size);
	if (stringoffset(ep, size - (ep - result), -zp->z_gmtoff) != 0) {
		result[0] = '\0';
		return;
	}
	if (dstrp == NULL)
		return;
	ep = end(result, size);
	doabbr(ep, size - (ep - result), zp->z_format, dstrp->r_abbrvar, TRUE, TRUE);
	if (dstrp->r_stdoff != SECSPERMIN * MINSPERHOUR) {
		ep = end(result, size);
		if (stringoffset(ep, size - (ep - result),
			-(zp->z_gmtoff + dstrp->r_stdoff)) != 0) {
				result[0] = '\0';
				return;
		}
	}
	(void) strlcat(result, ",", size);
	if (stringrule(result, size, dstrp, dstrp->r_stdoff, zp->z_gmtoff) != 0) {
		result[0] = '\0';
		return;
	}
	(void) strlcat(result, ",", size);
	if (stringrule(result, size, stdrp, dstrp->r_stdoff, zp->z_gmtoff) != 0) {
		result[0] = '\0';
		return;
	}
}

static void
outzone(zpfirst, zonecount)
const struct zone * const	zpfirst;
const int			zonecount;
{
	register const struct zone *	zp;
	register struct rule *		rp;
	register int			i, j;
	register int			usestart, useuntil;
	register zic_t			starttime, untiltime;
	register long			gmtoff;
	register long			stdoff;
	register int			year;
	register long			startoff;
	register int			startttisstd;
	register int			startttisgmt;
	register int			type;
	register char *			startbuf;
	register char *			ab;
	register char *			envvar;
	register int			max_abbr_len;
	register int			max_envvar_len;
	register int			prodstic; /* all rules are min to max */

	max_abbr_len = 2 + max_format_len + max_abbrvar_len;
	max_envvar_len = 2 * max_abbr_len + 5 * 9;
	startbuf = emalloc(max_abbr_len + 1);
	ab = emalloc(max_abbr_len + 1);
	envvar = emalloc(max_envvar_len + 1);
	INITIALIZE(untiltime);
	INITIALIZE(starttime);
	/*
	** Now. . .finally. . .generate some useful data!
	*/
	timecnt = 0;
	typecnt = 0;
	charcnt = 0;
	prodstic = zonecount == 1;
	/*
	** Thanks to Earl Chew
	** for noting the need to unconditionally initialize startttisstd.
	*/
	startttisstd = FALSE;
	startttisgmt = FALSE;
	min_year = max_year = EPOCH_YEAR;
	if (leapseen) {
		updateminmax(leapminyear);
		updateminmax(leapmaxyear + (leapmaxyear < INT_MAX));
	}
	for (i = 0; i < zonecount; ++i) {
		zp = &zpfirst[i];
		if (i < zonecount - 1)
			updateminmax(zp->z_untilrule.r_loyear);
		for (j = 0; j < zp->z_nrules; ++j) {
			rp = &zp->z_rules[j];
			if (rp->r_lowasnum)
				updateminmax(rp->r_loyear);
			if (rp->r_hiwasnum)
				updateminmax(rp->r_hiyear);
			if (rp->r_lowasnum || rp->r_hiwasnum)
				prodstic = FALSE;
		}
	}
	/*
	** Generate lots of data if a rule can't cover all future times.
	*/
	stringzone(envvar, max_envvar_len + 1, zpfirst, zonecount);
	if (noise && envvar[0] == '\0') {
		register char *	wp;

wp = ecpyalloc(_("no POSIX environment variable for zone"));
		wp = ecatalloc(wp, " ");
		wp = ecatalloc(wp, zpfirst->z_name);
		warning(wp);
		free(wp);
	}
	if (envvar[0] == '\0') {
		if (min_year >= INT_MIN + YEARSPERREPEAT)
			min_year -= YEARSPERREPEAT;
		else	min_year = INT_MIN;
		if (max_year <= INT_MAX - YEARSPERREPEAT)
			max_year += YEARSPERREPEAT;
		else	max_year = INT_MAX;
		/*
		** Regardless of any of the above,
		** for a "proDSTic" zone which specifies that its rules
		** always have and always will be in effect,
		** we only need one cycle to define the zone.
		*/
		if (prodstic) {
			min_year = 1900;
			max_year = min_year + YEARSPERREPEAT;
		}
	}
	/*
	** For the benefit of older systems,
	** generate data from 1900 through 2037.
	*/
	if (min_year > 1900)
		min_year = 1900;
	if (max_year < 2037)
		max_year = 2037;
	for (i = 0; i < zonecount; ++i) {
		/*
		** A guess that may well be corrected later.
		*/
		stdoff = 0;
		zp = &zpfirst[i];
		usestart = i > 0 && (zp - 1)->z_untiltime > min_time;
		useuntil = i < (zonecount - 1);
		if (useuntil && zp->z_untiltime <= min_time)
			continue;
		gmtoff = zp->z_gmtoff;
		eat(zp->z_filename, zp->z_linenum);
		*startbuf = '\0';
		startoff = zp->z_gmtoff;
		if (zp->z_nrules == 0) {
			stdoff = zp->z_stdoff;
			doabbr(startbuf, max_abbr_len + 1, zp->z_format,
				(char *) NULL, stdoff != 0, FALSE);
			type = addtype(oadd(zp->z_gmtoff, stdoff),
				startbuf, stdoff != 0, startttisstd,
				startttisgmt);
			if (usestart) {
				addtt(starttime, type);
				usestart = FALSE;
			} else if (stdoff != 0)
				addtt(min_time, type);
		} else for (year = min_year; year <= max_year; ++year) {
			if (useuntil && year > zp->z_untilrule.r_hiyear)
				break;
			/*
			** Mark which rules to do in the current year.
			** For those to do, calculate rpytime(rp, year);
			*/
			for (j = 0; j < zp->z_nrules; ++j) {
				rp = &zp->z_rules[j];
				eats(zp->z_filename, zp->z_linenum,
					rp->r_filename, rp->r_linenum);
				rp->r_todo = year >= rp->r_loyear &&
						year <= rp->r_hiyear &&
						yearistype(year, rp->r_yrtype);
				if (rp->r_todo)
					rp->r_temp = rpytime(rp, year);
			}
			for ( ; ; ) {
				register int	k;
				register zic_t	jtime, ktime;
				register long	offset;

				INITIALIZE(ktime);
				if (useuntil) {
					/*
					** Turn untiltime into UTC
					** assuming the current gmtoff and
					** stdoff values.
					*/
					untiltime = zp->z_untiltime;
					if (!zp->z_untilrule.r_todisgmt)
						untiltime = tadd(untiltime,
							-gmtoff);
					if (!zp->z_untilrule.r_todisstd)
						untiltime = tadd(untiltime,
							-stdoff);
				}
				/*
				** Find the rule (of those to do, if any)
				** that takes effect earliest in the year.
				*/
				k = -1;
				for (j = 0; j < zp->z_nrules; ++j) {
					rp = &zp->z_rules[j];
					if (!rp->r_todo)
						continue;
					eats(zp->z_filename, zp->z_linenum,
						rp->r_filename, rp->r_linenum);
					offset = rp->r_todisgmt ? 0 : gmtoff;
					if (!rp->r_todisstd)
						offset = oadd(offset, stdoff);
					jtime = rp->r_temp;
					if (jtime == min_time ||
						jtime == max_time)
							continue;
					jtime = tadd(jtime, -offset);
					if (k < 0 || jtime < ktime) {
						k = j;
						ktime = jtime;
					}
				}
				if (k < 0)
					break;	/* go on to next year */
				rp = &zp->z_rules[k];
				rp->r_todo = FALSE;
				if (useuntil && ktime >= untiltime)
					break;
				stdoff = rp->r_stdoff;
				if (usestart && ktime == starttime)
					usestart = FALSE;
				if (usestart) {
					if (ktime < starttime) {
						startoff = oadd(zp->z_gmtoff,
							stdoff);
						doabbr(startbuf,
							max_abbr_len + 1,
							zp->z_format,
							rp->r_abbrvar,
							rp->r_stdoff != 0,
							FALSE);
						continue;
					}
					if (*startbuf == '\0' &&
						startoff == oadd(zp->z_gmtoff,
						stdoff)) {
							doabbr(startbuf,
								max_abbr_len + 1,
								zp->z_format,
								rp->r_abbrvar,
								rp->r_stdoff !=
								0,
								FALSE);
					}
				}
				eats(zp->z_filename, zp->z_linenum,
					rp->r_filename, rp->r_linenum);
				doabbr(ab, max_abbr_len + 1, zp->z_format,
					rp->r_abbrvar,
					rp->r_stdoff != 0, FALSE);
				offset = oadd(zp->z_gmtoff, rp->r_stdoff);
				type = addtype(offset, ab, rp->r_stdoff != 0,
					rp->r_todisstd, rp->r_todisgmt);
				addtt(ktime, type);
			}
		}
		if (usestart) {
			if (*startbuf == '\0' &&
				zp->z_format != NULL &&
				strchr(zp->z_format, '%') == NULL &&
				strchr(zp->z_format, '/') == NULL)
					(void) strlcpy(startbuf, zp->z_format,
					    	       max_abbr_len + 1);
			eat(zp->z_filename, zp->z_linenum);
			if (*startbuf == '\0')
error(_("can't determine time zone abbreviation to use just after until time"));
			else	addtt(starttime,
					addtype(startoff, startbuf,
						startoff != zp->z_gmtoff,
						startttisstd,
						startttisgmt));
		}
		/*
		** Now we may get to set starttime for the next zone line.
		*/
		if (useuntil) {
			startttisstd = zp->z_untilrule.r_todisstd;
			startttisgmt = zp->z_untilrule.r_todisgmt;
			starttime = zp->z_untiltime;
			if (!startttisstd)
				starttime = tadd(starttime, -stdoff);
			if (!startttisgmt)
				starttime = tadd(starttime, -gmtoff);
		}
	}
	writezone(zpfirst->z_name, envvar);
	free(startbuf);
	free(ab);
	free(envvar);
}

static void
addtt(starttime, type)
const zic_t	starttime;
int		type;
{
	size_t len;

	if (starttime <= min_time ||
		(timecnt == 1 && attypes[0].at < min_time)) {
		gmtoffs[0] = gmtoffs[type];
		isdsts[0] = isdsts[type];
		ttisstds[0] = ttisstds[type];
		ttisgmts[0] = ttisgmts[type];
		if (abbrinds[type] != 0) {
			len = strlen(&chars[abbrinds[type]]) + 1;
			(void) memmove(chars, &chars[abbrinds[type]], len);
		}
		abbrinds[0] = 0;
		charcnt = strlen(chars) + 1;
		typecnt = 1;
		timecnt = 0;
		type = 0;
	}
	if (timecnt >= TZ_MAX_TIMES) {
		error(_("too many transitions?!"));
		exit(EXIT_FAILURE);
	}
	attypes[timecnt].at = starttime;
	attypes[timecnt].type = type;
	++timecnt;
}

static int
addtype(gmtoff, abbr, isdst, ttisstd, ttisgmt)
const long		gmtoff;
const char * const	abbr;
const int		isdst;
const int		ttisstd;
const int		ttisgmt;
{
	register int	i, j;

	if (isdst != TRUE && isdst != FALSE) {
		error(_("internal error - addtype called with bad isdst"));
		exit(EXIT_FAILURE);
	}
	if (ttisstd != TRUE && ttisstd != FALSE) {
		error(_("internal error - addtype called with bad ttisstd"));
		exit(EXIT_FAILURE);
	}
	if (ttisgmt != TRUE && ttisgmt != FALSE) {
		error(_("internal error - addtype called with bad ttisgmt"));
		exit(EXIT_FAILURE);
	}
	/*
	** See if there's already an entry for this zone type.
	** If so, just return its index.
	*/
	for (i = 0; i < typecnt; ++i) {
		if (gmtoff == gmtoffs[i] && isdst == isdsts[i] &&
			strcmp(abbr, &chars[abbrinds[i]]) == 0 &&
			ttisstd == ttisstds[i] &&
			ttisgmt == ttisgmts[i])
				return i;
	}
	/*
	** There isn't one; add a new one, unless there are already too
	** many.
	*/
	if (typecnt >= TZ_MAX_TYPES) {
		error(_("too many local time types"));
		exit(EXIT_FAILURE);
	}
	if (! (-1L - 2147483647L <= gmtoff && gmtoff <= 2147483647L)) {
		error(_("UTC offset out of range"));
		exit(EXIT_FAILURE);
	}
	gmtoffs[i] = gmtoff;
	isdsts[i] = isdst;
	ttisstds[i] = ttisstd;
	ttisgmts[i] = ttisgmt;

	for (j = 0; j < charcnt; ++j)
		if (strcmp(&chars[j], abbr) == 0)
			break;
	if (j == charcnt)
		newabbr(abbr);
	abbrinds[i] = j;
	++typecnt;
	return i;
}

static void
leapadd(t, positive, rolling, count)
const zic_t	t;
const int	positive;
const int	rolling;
int		count;
{
	register int	i, j;

	if (leapcnt + (positive ? count : 1) > TZ_MAX_LEAPS) {
		error(_("too many leap seconds"));
		exit(EXIT_FAILURE);
	}
	for (i = 0; i < leapcnt; ++i)
		if (t <= trans[i]) {
			if (t == trans[i]) {
				error(_("repeated leap second moment"));
				exit(EXIT_FAILURE);
			}
			break;
		}
	do {
		for (j = leapcnt; j > i; --j) {
			trans[j] = trans[j - 1];
			corr[j] = corr[j - 1];
			roll[j] = roll[j - 1];
		}
		trans[i] = t;
		corr[i] = positive ? 1L : eitol(-count);
		roll[i] = rolling;
		++leapcnt;
	} while (positive && --count != 0);
}

static void
adjleap(void)
{
	register int	i;
	register long	last = 0;

	/*
	** propagate leap seconds forward
	*/
	for (i = 0; i < leapcnt; ++i) {
		trans[i] = tadd(trans[i], last);
		last = corr[i] += last;
	}
}

static int
yearistype(year, type)
const int		year;
const char * const	type;
{
	static char *	buf;
	int		result;
	size_t		len;

	if (type == NULL || *type == '\0')
		return TRUE;
	len = 132 + strlen(yitcommand) + strlen(type);
	buf = erealloc(buf, len);
	(void) snprintf(buf, len, "%s %d %s", yitcommand, year, type);
	result = system(buf);
	if (WIFEXITED(result)) switch (WEXITSTATUS(result)) {
		case 0:
			return TRUE;
		case 1:
			return FALSE;
	}
	error(_("Wild result from command execution"));
	(void) fprintf(stderr, _("%s: command was '%s', result was %d\n"),
		progname, buf, result);
	for ( ; ; )
		exit(EXIT_FAILURE);
}

static int
lowerit(a)
int	a;
{
	a = (unsigned char) a;
	return (isascii(a) && isupper(a)) ? tolower(a) : a;
}

static int
ciequal(ap, bp)		/* case-insensitive equality */
register const char *	ap;
register const char *	bp;
{
	while (lowerit(*ap) == lowerit(*bp++))
		if (*ap++ == '\0')
			return TRUE;
	return FALSE;
}

static int
itsabbr(abbr, word)
register const char *	abbr;
register const char *	word;
{
	if (lowerit(*abbr) != lowerit(*word))
		return FALSE;
	++word;
	while (*++abbr != '\0')
		do {
			if (*word == '\0')
				return FALSE;
		} while (lowerit(*word++) != lowerit(*abbr));
	return TRUE;
}

static const struct lookup *
byword(word, table)
register const char * const		word;
register const struct lookup * const	table;
{
	register const struct lookup *	foundlp;
	register const struct lookup *	lp;

	if (word == NULL || table == NULL)
		return NULL;
	/*
	** Look for exact match.
	*/
	for (lp = table; lp->l_word != NULL; ++lp)
		if (ciequal(word, lp->l_word))
			return lp;
	/*
	** Look for inexact match.
	*/
	foundlp = NULL;
	for (lp = table; lp->l_word != NULL; ++lp)
		if (itsabbr(word, lp->l_word)) {
			if (foundlp == NULL)
				foundlp = lp;
			else	return NULL;	/* multiple inexact matches */
		}
	return foundlp;
}

static char **
getfields(cp)
register char *	cp;
{
	register char *		dp;
	register char **	array;
	register int		nsubs;

	if (cp == NULL)
		return NULL;
	array = (char **) (void *)
		emalloc((int) ((strlen(cp) + 1) * sizeof *array));
	nsubs = 0;
	for ( ; ; ) {
		while (isascii((unsigned char) *cp) &&
			isspace((unsigned char) *cp))
				++cp;
		if (*cp == '\0' || *cp == '#')
			break;
		array[nsubs++] = dp = cp;
		do {
			if ((*dp = *cp++) != '"')
				++dp;
			else while ((*dp = *cp++) != '"')
				if (*dp != '\0')
					++dp;
				else {
					error(_(
						"Odd number of quotation marks"
						));
					exit(1);
				}
		} while (*cp != '\0' && *cp != '#' &&
			(!isascii((unsigned char)*cp) || !isspace((unsigned char) *cp)));
		if (isascii((unsigned char) *cp) && isspace((unsigned char) *cp))
			++cp;
		*dp = '\0';
	}
	array[nsubs] = NULL;
	return array;
}

static long
oadd(t1, t2)
const long	t1;
const long	t2;
{
	register long	t;

	t = t1 + t2;
	if ((t2 > 0 && t <= t1) || (t2 < 0 && t >= t1)) {
		error(_("time overflow"));
		exit(EXIT_FAILURE);
	}
	return t;
}

static zic_t
tadd(t1, t2)
const zic_t	t1;
const long	t2;
{
	register zic_t	t;

	if (t1 == max_time && t2 > 0)
		return max_time;
	if (t1 == min_time && t2 < 0)
		return min_time;
	t = t1 + t2;
	if ((t2 > 0 && t <= t1) || (t2 < 0 && t >= t1)) {
		error(_("time overflow"));
		exit(EXIT_FAILURE);
	}
	return t;
}

/*
** Given a rule, and a year, compute the date - in seconds since January 1,
** 1970, 00:00 LOCAL time - in that year that the rule refers to.
*/

static zic_t
rpytime(rp, wantedy)
register const struct rule * const	rp;
register const int			wantedy;
{
	register int	y, m, i;
	register long	dayoff;			/* with a nod to Margaret O. */
	register zic_t	t;

	if (wantedy == INT_MIN)
		return min_time;
	if (wantedy == INT_MAX)
		return max_time;
	dayoff = 0;
	m = TM_JANUARY;
	y = EPOCH_YEAR;
	while (wantedy != y) {
		if (wantedy > y) {
			i = len_years[isleap(y)];
			++y;
		} else {
			--y;
			i = -len_years[isleap(y)];
		}
		dayoff = oadd(dayoff, eitol(i));
	}
	while (m != rp->r_month) {
		i = len_months[isleap(y)][m];
		dayoff = oadd(dayoff, eitol(i));
		++m;
	}
	i = rp->r_dayofmonth;
	if (m == TM_FEBRUARY && i == 29 && !isleap(y)) {
		if (rp->r_dycode == DC_DOWLEQ)
			--i;
		else {
			error(_("use of 2/29 in non leap-year"));
			exit(EXIT_FAILURE);
		}
	}
	--i;
	dayoff = oadd(dayoff, eitol(i));
	if (rp->r_dycode == DC_DOWGEQ || rp->r_dycode == DC_DOWLEQ) {
		register long	wday;

#define LDAYSPERWEEK	((long) DAYSPERWEEK)
		wday = eitol(EPOCH_WDAY);
		/*
		** Don't trust mod of negative numbers.
		*/
		if (dayoff >= 0)
			wday = (wday + dayoff) % LDAYSPERWEEK;
		else {
			wday -= ((-dayoff) % LDAYSPERWEEK);
			if (wday < 0)
				wday += LDAYSPERWEEK;
		}
		while (wday != eitol(rp->r_wday))
			if (rp->r_dycode == DC_DOWGEQ) {
				dayoff = oadd(dayoff, (long) 1);
				if (++wday >= LDAYSPERWEEK)
					wday = 0;
				++i;
			} else {
				dayoff = oadd(dayoff, (long) -1);
				if (--wday < 0)
					wday = LDAYSPERWEEK - 1;
				--i;
			}
		if (i < 0 || i >= len_months[isleap(y)][m]) {
			if (noise)
				warning(_("rule goes past start/end of month--\
will not work with pre-2004 versions of zic"));
		}
	}
	if (dayoff < min_time / SECSPERDAY)
		return min_time;
	if (dayoff > max_time / SECSPERDAY)
		return max_time;
	t = (zic_t) dayoff * SECSPERDAY;
	return tadd(t, rp->r_tod);
}

static void
newabbr(string)
const char * const	string;
{
	register int	i;

	if (strcmp(string, GRANDPARENTED) != 0) {
		register const char *	cp;
		register char *		wp;

		/*
		** Want one to ZIC_MAX_ABBR_LEN_WO_WARN alphabetics
		** optionally followed by a + or - and a number from 1 to 14.
		*/
		cp = string;
		wp = NULL;
		while (isascii((unsigned char) *cp) &&
			isalpha((unsigned char) *cp))
				++cp;
		if (cp - string == 0)
wp = _("time zone abbreviation lacks alphabetic at start");
		if (noise && cp - string > 3)
wp = _("time zone abbreviation has more than 3 alphabetics");
		if (cp - string > ZIC_MAX_ABBR_LEN_WO_WARN)
wp = _("time zone abbreviation has too many alphabetics");
		if (wp == NULL && (*cp == '+' || *cp == '-')) {
			++cp;
			if (isascii((unsigned char) *cp) &&
				isdigit((unsigned char) *cp))
					if (*cp++ == '1' &&
						*cp >= '0' && *cp <= '4')
							++cp;
		}
		if (*cp != '\0')
wp = _("time zone abbreviation differs from POSIX standard");
		if (wp != NULL) {
			wp = ecpyalloc(wp);
			wp = ecatalloc(wp, " (");
			wp = ecatalloc(wp, string);
			wp = ecatalloc(wp, ")");
			warning(wp);
			free(wp);
		}
	}
	i = strlen(string) + 1;
	if (charcnt + i > TZ_MAX_CHARS) {
		error(_("too many, or too long, time zone abbreviations"));
		exit(EXIT_FAILURE);
	}
	(void) strlcpy(&chars[charcnt], string, sizeof(chars) - charcnt);
	charcnt += eitol(i);
}

static int
mkdirs(argname)
char *		argname;
{
	register char *	name;
	register char *	cp;

	if (argname == NULL || *argname == '\0')
		return 0;
	cp = name = ecpyalloc(argname);
	while ((cp = strchr(cp + 1, '/')) != 0) {
		*cp = '\0';
		if (!itsdir(name)) {
			/*
			** It doesn't seem to exist, so we try to create it.
			** Creation may fail because of the directory being
			** created by some other multiprocessor, so we get
			** to do extra checking.
			*/
			if (mkdir(name, MKDIR_UMASK) != 0) {
				const char *e = strerror(errno);

				if (errno != EEXIST || !itsdir(name)) {
					(void) fprintf(stderr,
_("%s: Can't create directory %s: %s\n"),
						progname, name, e);
					free(name);
					return -1;
				}
			}
		}
		*cp = '/';
	}
	free(name);
	return 0;
}

static long
eitol(i)
const int	i;
{
	long	l;

	l = i;
	if ((i < 0 && l >= 0) || (i == 0 && l != 0) || (i > 0 && l <= 0)) {
		(void) fprintf(stderr,
			_("%s: %d did not sign extend correctly\n"),
			progname, i);
		exit(EXIT_FAILURE);
	}
	return l;
}

/*
** UNIX was a registered trademark of The Open Group in 2003.
*/
@


1.37
log
@stop trying to workaround malloc bugs that have not existed for 20 years.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.36 2015/02/09 08:25:11 tedu Exp $	*/
@


1.36
log
@this removes just a few ifdef checks for things that should always be enabled,
and which we definitely don't want to workaround. no change in the compiled
code (yet).
some of these, like the first chunk are plain silly. the compiler used to
compile asctime has nothing to do with the format strings strftime should
support.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.35 2013/11/24 23:51:29 deraadt Exp $	*/
d385 15
a399 4
#define emalloc(size)		memcheck(imalloc(size))
#define erealloc(ptr, size)	memcheck(irealloc((ptr), (size)))
#define ecpyalloc(ptr)		memcheck(icpyalloc(ptr))
#define ecatalloc(oldp, newp)	memcheck(icatalloc((oldp), (newp)))
d453 1
a453 1
	ifree(cp);
d650 2
a651 2
	ifree(fromname);
	ifree(toname);
d677 1
a677 1
	ifree(myname);
d852 1
a852 1
		ifree((char *) fields);
d1271 1
a1271 1
	ifree(dp);
d1355 1
a1355 1
				ifree(dp);
d1360 1
a1360 1
				ifree(dp);
d1369 1
a1369 1
				ifree(dp);
d1373 1
a1373 1
	ifree(dp);
d2063 1
a2063 1
		ifree(wp);
d2252 3
a2254 3
	ifree(startbuf);
	ifree(ab);
	ifree(envvar);
d2695 1
a2695 1
			ifree(wp);
d2733 1
a2733 1
					ifree(name);
d2740 1
a2740 1
	ifree(name);
@


1.35
log
@most obvious unsigned char casts for ctype
ok jca krw ingo
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.34 2011/04/25 13:27:27 millert Exp $	*/
d19 1
a19 4
#if HAVE_SYS_STAT_H
#include "sys/stat.h"
#endif
#ifdef S_IRUSR
a20 3
#else
#define MKDIR_UMASK 0755
#endif
a30 3
#ifndef isascii
#define isascii(x) 1
#endif
a468 1
#ifdef unix
a469 1
#endif /* defined unix */
a2707 10
#ifndef unix
		/*
		** DOS drive specifier?
		*/
		if (isalpha((unsigned char) name[0]) &&
			name[1] == ':' && name[2] == '\0') {
				*cp = '/';
				continue;
		}
#endif /* !defined unix */
@


1.34
log
@Update to tzcode2011g from elsie.nci.nih.gov.
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.33 2010/09/27 17:45:30 millert Exp $	*/
d2523 2
a2524 2
			(!isascii(*cp) || !isspace((unsigned char) *cp)));
		if (isascii(*cp) && isspace((unsigned char) *cp))
@


1.33
log
@Update to tzcode2010m from elsie.nci.nih.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.32 2010/08/23 22:35:34 millert Exp $	*/
d1614 1
a1614 1
				if (writetype[i])
d1618 1
d1867 2
a1869 2
			if ((week - 1) * DAYSPERWEEK + 1 != rp->r_dayofmonth)
				return -1;
d1874 1
a1874 2
				week = 1 + rp->r_dayofmonth / DAYSPERWEEK;
				if (week * DAYSPERWEEK - 1 != rp->r_dayofmonth)
d1876 1
d2011 1
d2026 1
d2048 2
d2072 10
@


1.32
log
@update to tzcode2010k from elsie.nci.nih.gov; OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.31 2008/01/07 01:09:37 millert Exp $	*/
d1596 46
@


1.31
log
@update to tzcode2007k from elsie.nci.nih.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.30 2007/12/29 22:26:51 millert Exp $	*/
a10 1
#ifdef notyet
a11 3
#else
#define	ZIC_VERSION	'\0'
#endif
d158 1
a158 1
static void	usage(void);
d456 1
a456 1
usage(void)
d458 1
a458 1
	(void) fprintf(stderr, _("usage: %s [-v] [-d directory] [-L leapsecondfilename] [-l timezone]\n\t[-p timezone] [-y command] [filename ...]\n"),
d460 1
a460 1
	exit(EXIT_FAILURE);
d497 1
a497 1
				usage();
d553 1
a553 1
		usage();	/* usage message by request */
a1552 1
#ifdef notyet
a1553 3
#else
	pass = 1; {
#endif
a1695 1
#ifdef notyet
a1696 1
#endif
d1909 1
a1909 1
	if (stdrp == NULL && zp->z_nrules != 0)
d1987 1
a1987 1
		updateminmax(leapmaxyear);
@


1.30
log
@update to tzcode2007j from elsie.nci.nih.gov; mostly ANSIfication
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.29 2007/06/30 13:20:42 millert Exp $	*/
a165 4
#if !HAVE_STRERROR
static char *	strerror(int);
#endif /* !HAVE_STRERROR */

a405 13

#if !HAVE_STRERROR
static char *
strerror(errnum)
int	errnum;
{
	extern char *	sys_errlist[];
	extern int	sys_nerr;

	return (errnum > 0 && errnum <= sys_nerr) ?
		sys_errlist[errnum] : _("Unknown system error");
}
#endif /* !HAVE_STRERROR */
@


1.29
log
@Update to tzcode2007f from elsie.nci.nih.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.28 2007/02/27 16:40:35 millert Exp $	*/
d105 3
a107 3
extern int	getopt P((int argc, char * const argv[],
			const char * options));
extern int	link P((const char * fromname, const char * toname));
d111 41
a151 41
static void	addtt P((zic_t starttime, int type));
static int	addtype P((long gmtoff, const char * abbr, int isdst,
				int ttisstd, int ttisgmt));
static void	leapadd P((zic_t t, int positive, int rolling, int count));
static void	adjleap P((void));
static void	associate P((void));
static int	ciequal P((const char * ap, const char * bp));
static void	convert P((long val, char * buf));
static void	convert64 P((zic_t val, char * buf));
static void	dolink P((const char * fromfield, const char * tofield));
static void	doabbr P((char * abbr, size_t size, const char * format,
			const char * letters, int isdst, int doquotes));
static void	eat P((const char * name, int num));
static void	eats P((const char * name, int num,
			const char * rname, int rnum));
static long	eitol P((int i));
static void	error P((const char * message));
static char **	getfields P((char * buf));
static long	gethms P((const char * string, const char * errstrng,
			int signable));
static void	infile P((const char * filename));
static void	inleap P((char ** fields, int nfields));
static void	inlink P((char ** fields, int nfields));
static void	inrule P((char ** fields, int nfields));
static int	inzcont P((char ** fields, int nfields));
static int	inzone P((char ** fields, int nfields));
static int	inzsub P((char ** fields, int nfields, int iscont));
static int	is32 P((zic_t x));
static int	itsabbr P((const char * abbr, const char * word));
static int	itsdir P((const char * name));
static int	lowerit P((int c));
static char *	memcheck P((char * tocheck));
static int	mkdirs P((char * filename));
static void	newabbr P((const char * abbr));
static long	oadd P((long t1, long t2));
static void	outzone P((const struct zone * zp, int ntzones));
static void	puttzcode P((long code, FILE * fp));
static void	puttzcode64 P((zic_t code, FILE * fp));
static int	rcomp P((const void * leftp, const void * rightp));
static zic_t	rpytime P((const struct rule * rp, int wantedy));
static void	rulesub P((struct rule * rp,
d154 11
a164 11
			const char * dayp, const char * timep));
static int 	stringoffset P((char * result, size_t size, long offset));
static int	stringrule P((char * result, size_t size, const struct rule * rp,
			long dstoff, long gmtoff));
static void 	stringzone P((char * result, size_t size,
			const struct zone * zp, int ntzones));
static void	setboundaries P((void));
static zic_t	tadd P((zic_t t1, long t2));
static void	usage P((void));
static void	writezone P((const char * name, const char * string));
static int	yearistype P((int year, const char * type));
d167 1
a167 1
static char *	strerror P((int));
d293 2
a294 2
static struct lookup const *	byword P((const char * string,
					const struct lookup * lp));
d477 1
a477 1
usage P((void))
d678 1
a678 1
setboundaries P((void))
d720 1
a720 1
associate P((void))
d2018 2
a2019 1
		updateminmax(zp->z_untilrule.r_loyear);
d2050 2
a2051 1
	** For the benefit of older systems, generate data through 2037.
d2053 2
d2350 1
a2350 1
adjleap P((void))
@


1.28
log
@Update to tzcode2007c from elsie.nci.nih.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.27 2007/02/06 19:35:16 millert Exp $	*/
d120 1
a120 1
static void	dolink P((const char * fromfile, const char * tofile));
d624 3
a626 3
dolink(fromfile, tofile)
const char * const	fromfile;
const char * const	tofile;
d631 2
a632 2
	if (fromfile[0] == '/')
		fromname = ecpyalloc(fromfile);
d636 1
a636 1
		fromname = ecatalloc(fromname, fromfile);
d638 2
a639 2
	if (tofile[0] == '/')
		toname = ecpyalloc(tofile);
d643 1
a643 1
		toname = ecatalloc(toname, tofile);
d905 2
a906 1
	int	hh, mm, ss, sign;
d916 1
a916 1
	if (sscanf(string, scheck(string, "%d"), &hh) == 1)
d918 1
a918 1
	else if (sscanf(string, scheck(string, "%d:%d"), &hh, &mm) == 2)
d920 1
a920 1
	else if (sscanf(string, scheck(string, "%d:%d:%d"),
d925 1
a925 1
	if ((hh < 0 || hh >= HOURSPERDAY ||
d927 1
a927 2
		ss < 0 || ss > SECSPERMIN) &&
		!(hh == HOURSPERDAY && mm == 0 && ss == 0)) {
d931 5
a935 1
	if (noise && hh == HOURSPERDAY)
d937 5
a941 3
	return eitol(sign) *
		(eitol(hh * MINSPERHOUR + mm) *
		eitol(SECSPERMIN) + eitol(ss));
d2036 1
a2036 1
		wp = ecatalloc(wp, zpfirst->z_name); 
d2290 4
@


1.27
log
@Update to tzcode2007a.  This adds support for 64bit time_t in case
we need it in the future.  All of our platforms currently have 32bit
time_t types.  This also extends the timezone data file format to
support both 32bit and 64bit data.  The 64bit data is located after
the 32bit data so binaries linked with the older tzcode simply won't
look at it.  A version field in the file header is used to determine
whether the data file is the old or extended format.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.26 2006/02/18 21:54:17 millert Exp $	*/
d2468 2
a2469 1
				else	error(_(
d2472 2
d2661 1
a2661 1
char * const	argname;
@


1.26
log
@Update to tzcode2006a; primarily just cast and const fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: zic.c,v 1.25 2005/08/08 08:05:38 espie Exp $ */
d4 1
a4 1
** Feb 14, 2003 by Arthur David Olson.
a6 6
/*
** Regardless of the type of time_t, we do our work using this type.
*/

typedef int	zic_t;

d11 8
d29 1
a29 1
#define MKDIR_UMASK 0755 
d45 5
d58 2
d119 1
d122 1
a122 1
			const char * letters, int isdst));
d138 1
d148 1
d155 5
d163 1
a163 1
static void	writezone P((const char * name));
d174 3
d178 2
a181 1
static int		max_year_representable;
a183 1
static int		min_year_representable;
d479 1
a479 1
	(void) fprintf(stderr, _("usage: %s [-sv] [-d directory] [-L leapsecondfilename] [-l timezone]\n\t[-p timezone] [-y command] [filename ...]\n"),
a488 1
static int		sflag = FALSE;
d510 6
a515 1
	while ((c = getopt(argc, argv, "d:l:p:L:vsy:")) != -1)
a571 3
			case 's':
				sflag = TRUE;
				break;
d661 1
a661 1
#endif
d675 1
a675 18
#ifndef INT_MAX
#define INT_MAX	((int) (((unsigned)~0)>>1))
#endif /* !defined INT_MAX */

#ifndef INT_MIN
#define INT_MIN	((int) ~(((unsigned)~0)>>1))
#endif /* !defined INT_MIN */

/*
** The tz file format currently allows at most 32-bit quantities.
** This restriction should be removed before signed 32-bit values
** wrap around in 2038, but unfortunately this will require a
** change to the tz file format.
*/

#define MAX_BITS_IN_FILE	32
#define TIME_T_BITS_IN_FILE	((TYPE_BIT(zic_t) < MAX_BITS_IN_FILE) ? \
					TYPE_BIT(zic_t) : MAX_BITS_IN_FILE)
d682 4
a685 24
	if (TYPE_SIGNED(zic_t)) {
		min_time = -1;
		for (i = 0; i < TIME_T_BITS_IN_FILE - 1; ++i)
			min_time *= 2;
		max_time = -(min_time + 1);
		if (sflag)
			min_time = 0;
	} else {
		min_time = 0;
		max_time = 2 - sflag;
		for (i = 0; i < TIME_T_BITS_IN_FILE - 1; ++i)
			max_time *= 2;
		--max_time;
	}
	{
		time_t	t;

		t = (time_t) min_time;
		min_year = TM_YEAR_BASE + gmtime(&t)->tm_year;
		t = (time_t) max_time;
		max_year = TM_YEAR_BASE + gmtime(&t)->tm_year;
	}
	min_year_representable = min_year;
	max_year_representable = max_year;
d960 2
d1070 2
d1133 5
d1292 2
a1293 1
	if (lp != NULL) switch ((int) lp->l_value) {
a1307 5
	} else if (noise) {
		if (rp->r_loyear < min_year_representable)
			warning(_("starting year too low to be represented"));
		else if (rp->r_loyear > max_year_representable)
			warning(_("starting year too high to be represented"));
d1310 3
a1312 1
	if ((lp = byword(cp, end_years)) != NULL) switch ((int) lp->l_value) {
a1329 5
	} else if (noise) {
		if (rp->r_loyear < min_year_representable)
			warning(_("ending year too low to be represented"));
		else if (rp->r_loyear > max_year_representable)
			warning(_("ending year too high to be represented"));
a1343 2
	if (rp->r_loyear < min_year && rp->r_loyear > 0)
		min_year = rp->r_loyear;
d1397 1
a1397 1
	register long	shift;
d1404 12
d1426 11
d1439 2
a1440 2
void *	avp;
void *	bvp;
d1442 11
a1452 5
	if (((struct attype *) avp)->at < ((struct attype *) bvp)->at)
		return -1;
	else if (((struct attype *) avp)->at > ((struct attype *) bvp)->at)
		return 1;
	else	return 0;
d1456 1
a1456 1
writezone(name)
d1458 1
d1460 11
a1470 7
	register FILE *		fp;
	register int		i, j;
	static char *		fullname;
	static struct tzhead	tzh;
	zic_t			ats[TZ_MAX_TIMES];
	unsigned char		types[TZ_MAX_TIMES];
	size_t			len;
d1514 30
a1545 1
		
d1568 71
a1638 7
	convert(eitol(typecnt), tzh.tzh_ttisgmtcnt);
	convert(eitol(typecnt), tzh.tzh_ttisstdcnt);
	convert(eitol(leapcnt), tzh.tzh_leapcnt);
	convert(eitol(timecnt), tzh.tzh_timecnt);
	convert(eitol(typecnt), tzh.tzh_typecnt);
	convert(eitol(charcnt), tzh.tzh_charcnt);
	(void) strncpy(tzh.tzh_magic, TZ_MAGIC, sizeof tzh.tzh_magic);
d1641 18
a1658 8
	DO(tzh_magic);
	DO(tzh_reserved);
	DO(tzh_ttisgmtcnt);
	DO(tzh_ttisstdcnt);
	DO(tzh_leapcnt);
	DO(tzh_timecnt);
	DO(tzh_typecnt);
	DO(tzh_charcnt);
d1660 18
a1677 6
	for (i = 0; i < timecnt; ++i) {
		j = leapcnt;
		while (--j >= 0)
			if (ats[i] >= trans[j]) {
				ats[i] = tadd(ats[i], corr[j]);
				break;
d1679 35
a1713 1
		puttzcode((long) ats[i], fp);
d1715 3
a1717 34
	if (timecnt > 0)
		(void) fwrite((void *) types, (size_t) sizeof types[0],
			(size_t) timecnt, fp);
	for (i = 0; i < typecnt; ++i) {
		puttzcode((long) gmtoffs[i], fp);
		(void) putc(isdsts[i], fp);
		(void) putc(abbrinds[i], fp);
	}
	if (charcnt != 0)
		(void) fwrite((void *) chars, (size_t) sizeof chars[0],
			(size_t) charcnt, fp);
	for (i = 0; i < leapcnt; ++i) {
		if (roll[i]) {
			if (timecnt == 0 || trans[i] < ats[0]) {
				j = 0;
				while (isdsts[j])
					if (++j >= typecnt) {
						j = 0;
						break;
					}
			} else {
				j = 1;
				while (j < timecnt && trans[i] >= ats[j])
					++j;
				j = types[j - 1];
			}
			puttzcode((long) tadd(trans[i], -gmtoffs[j]), fp);
		} else	puttzcode((long) trans[i], fp);
		puttzcode((long) corr[i], fp);
	}
	for (i = 0; i < typecnt; ++i)
		(void) putc(ttisstds[i], fp);
	for (i = 0; i < typecnt; ++i)
		(void) putc(ttisgmts[i], fp);
d1726 1
a1726 1
doabbr(abbr, size, format, letters, isdst)
d1732 1
d1734 6
a1739 1
	if (strchr(format, '/') == NULL) {
d1741 219
a1959 7
			strlcpy(abbr, format, size);
		else	snprintf(abbr, size, format, letters);
	} else if (isdst)
		strlcpy(abbr, strchr(format, '/') + 1, size);
	else {
		strlcpy(abbr, format, size);
		*strchr(abbr, '/') = '\0';
d1980 11
a1990 2
	char				startbuf[BUFSIZ];

d2005 42
d2063 2
a2064 2
			doabbr(startbuf, sizeof(startbuf), zp->z_format,
				(char *) NULL, stdoff != 0);
a2093 1
				char		buf[BUFSIZ];
d2148 1
a2148 1
							sizeof(startbuf),
d2151 2
a2152 1
							rp->r_stdoff != 0);
d2156 10
a2165 7
					    startoff == oadd(zp->z_gmtoff,
					    stdoff))
						doabbr(startbuf,
							sizeof(startbuf),
							zp->z_format,
							rp->r_abbrvar,
							rp->r_stdoff != 0);
d2169 3
a2171 2
				doabbr(buf, sizeof(buf), zp->z_format,
					rp->r_abbrvar, rp->r_stdoff != 0);
d2173 1
a2173 1
				type = addtype(offset, buf, rp->r_stdoff != 0,
d2183 2
a2184 2
					strlcpy(startbuf, zp->z_format,
					    sizeof(startbuf));
d2207 4
a2210 1
	writezone(zpfirst->z_name);
d2218 2
d2226 4
a2229 2
		if (abbrinds[type] != 0)
			strlcpy(chars, &chars[abbrinds[type]], sizeof(chars));
a2594 2
	if (dayoff < 0 && !TYPE_SIGNED(zic_t))
		return min_time;
d2652 1
a2652 1
	strlcpy(&chars[charcnt], string, sizeof(chars) - charcnt);
@


1.25
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
** Feb 14, 2003 by Arthur David Olson (arthur_david_olson@@nih.gov).
d377 1
a377 1
		(void) exit(EXIT_FAILURE);
d461 1
a461 1
	(void) exit(EXIT_FAILURE);
d502 1
a502 1
					(void) exit(EXIT_FAILURE);
d512 1
a512 1
					(void) exit(EXIT_FAILURE);
d522 1
a522 1
					(void) exit(EXIT_FAILURE);
d532 1
a532 1
					(void) exit(EXIT_FAILURE);
d542 1
a542 1
					(void) exit(EXIT_FAILURE);
d569 1
a569 1
		(void) exit(EXIT_FAILURE);
d634 1
a634 1
			(void) exit(EXIT_FAILURE);
d647 1
a647 1
			(void) exit(EXIT_FAILURE);
d808 1
a808 1
		(void) exit(EXIT_FAILURE);
d832 1
a832 1
		(void) exit(EXIT_FAILURE);
d842 1
a842 1
			(void) exit(EXIT_FAILURE);
d886 1
a886 1
					(void) exit(EXIT_FAILURE);
d894 1
a894 1
		(void) exit(EXIT_FAILURE);
d901 1
a901 1
		(void) exit(EXIT_FAILURE);
d1310 1
a1310 1
			(void) exit(EXIT_FAILURE);
d1335 1
a1335 1
			(void) exit(EXIT_FAILURE);
d1508 1
a1508 1
		(void) exit(EXIT_FAILURE);
d1512 1
a1512 1
			(void) exit(EXIT_FAILURE);
d1518 1
a1518 1
			(void) exit(EXIT_FAILURE);
d1585 1
a1585 1
		(void) exit(EXIT_FAILURE);
d1637 1
a1637 1
	** Thanks to Earl Chew (earl@@dnd.icp.nec.com.au)
d1822 1
a1822 1
		(void) exit(EXIT_FAILURE);
d1841 1
a1841 1
		(void) exit(EXIT_FAILURE);
d1845 1
a1845 1
		(void) exit(EXIT_FAILURE);
d1849 1
a1849 1
		(void) exit(EXIT_FAILURE);
d1868 1
a1868 1
		(void) exit(EXIT_FAILURE);
d1896 1
a1896 1
		(void) exit(EXIT_FAILURE);
d1902 1
a1902 1
				(void) exit(EXIT_FAILURE);
d1959 1
a1959 1
		(void) exit(EXIT_FAILURE);
d2040 3
a2042 2
		while (isascii(*cp) && isspace((unsigned char) *cp))
			++cp;
d2075 1
a2075 1
		(void) exit(EXIT_FAILURE);
d2094 1
a2094 1
		(void) exit(EXIT_FAILURE);
d2141 1
a2141 1
			(void) exit(EXIT_FAILURE);
d2205 3
a2207 2
		while (isascii(*cp) && isalpha(*cp))
			++cp;
d2216 5
a2220 3
			if (isascii(*cp) && isdigit(*cp))
				if (*cp++ == '1' && *cp >= '0' && *cp <= '4')
					++cp;
d2236 1
a2236 1
		(void) exit(EXIT_FAILURE);
d2300 1
a2300 1
		(void) exit(EXIT_FAILURE);
@


1.24
log
@Update to tzcode2005j.
@
text
@d1 1
a5 5

#if defined(LIBC_SCCS) && !defined(lint) && !defined(NOID)
static char	elsieid[] = "@@(#)zic.c	7.124";
static char rcsid[] = "$OpenBSD: zic.c,v 1.23 2004/06/28 14:47:41 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.23
log
@merge in tzcode2004a
@
text
@d7 2
a8 2
static char	elsieid[] = "@@(#)zic.c	7.116";
static char rcsid[] = "$OpenBSD: zic.c,v 1.22 2004/04/01 11:37:02 jmc Exp $";
d11 6
d21 4
d36 1
a36 1
** only if isascii(C) || C == EOF.  Modern hosts obey the C Standard,
d71 1
a71 1
	time_t		r_temp;		/* used in outzone */
d97 1
a97 1
	time_t		z_untiltime;
d106 1
a106 1
static void	addtt P((time_t starttime, int type));
d109 1
a109 1
static void	leapadd P((time_t t, int positive, int rolling, int count));
d142 1
a142 1
static time_t	rpytime P((const struct rule * rp, int wantedy));
d148 1
a148 1
static time_t	tadd P((time_t t1, long t2));
d153 1
a153 1
#if !(HAVE_STRERROR - 0)
d155 1
a155 1
#endif /* !(HAVE_STRERROR - 0) */
d162 1
a162 1
static time_t		max_time;
d165 1
a165 1
static time_t		min_time;
d355 1
a355 1
	time_t		at;
d364 1
a364 1
static time_t		trans[TZ_MAX_LEAPS];
d395 1
a395 1
#if !(HAVE_STRERROR - 0)
d406 1
a406 1
#endif /* !(HAVE_STRERROR - 0) */
d463 2
a464 2
	(void) fprintf(stderr, _("%s: usage is %s [-sv] [-d directory] [-L leapsecondfilename] [-l timezone]\n\t[-p timezone] [-y command] [filename ...]\n"),
		progname, progname);
d487 2
a488 2
#if HAVE_GETTEXT - 0
	(void) setlocale(LC_MESSAGES, "");
d493 1
a493 1
#endif /* HAVE_GETTEXT - 0 */
d589 5
d641 1
a641 1
#if (HAVE_SYMLINK - 0) 
d674 2
a675 1
#define TIME_T_BITS_IN_FILE	((TYPE_BIT(time_t) < MAX_BITS_IN_FILE) ? TYPE_BIT(time_t) : MAX_BITS_IN_FILE)
d680 7
a686 4
	if (TYPE_SIGNED(time_t)) {
		min_time = ~ (time_t) 0;
		min_time <<= TIME_T_BITS_IN_FILE - 1;
		max_time = ~ (time_t) 0 - min_time;
d692 2
a693 1
		max_time <<= TIME_T_BITS_IN_FILE - 1;
d696 8
a703 2
	min_year = TM_YEAR_BASE + gmtime(&min_time)->tm_year;
	max_year = TM_YEAR_BASE + gmtime(&max_time)->tm_year;
d802 1
a802 1
					      TRUE);
d1108 3
a1110 1
				error(_("Zone continuation line end time is not after end time of previous line"));
d1134 1
a1134 1
	time_t				t;
d1143 5
a1147 5
			/*
			 * Leapin' Lizards!
			 */
			error(_("invalid leaping year"));
			return;
d1178 1
a1178 1
	if (dayoff < 0 && !TYPE_SIGNED(time_t)) {
d1190 1
a1190 1
	t = (time_t) dayoff * SECSPERDAY;
d1214 3
a1216 1
			error(_("illegal Rolling/Stationary field on Leap line"));
d1454 1
a1454 1
	time_t			ats[TZ_MAX_TIMES];
d1479 7
a1485 8
			if (toi != 0
			    && ((attypes[fromi].at
				 + gmtoffs[attypes[toi - 1].type])
				<= (attypes[toi - 1].at
				    + gmtoffs[toi == 1 ? 0
					      : attypes[toi - 2].type]))) {
				attypes[toi - 1].type = attypes[fromi].type;
				continue;
d1532 2
a1533 1
#define DO(field)	(void) fwrite((void *) tzh.field, (size_t) sizeof tzh.field, (size_t) 1, fp)
d1622 1
a1622 1
	register time_t			starttime, untiltime;
d1691 1
a1691 1
				register time_t	jtime, ktime;
d1756 1
a1756 1
					    stdoff)) {
a1761 1
					}
d1807 1
a1807 1
const time_t	starttime;
d1891 1
a1891 1
const time_t	t;
d2055 3
a2057 1
				else	error(_("Odd number of quotation marks"));
d2083 1
a2083 1
static time_t
d2085 1
a2085 1
const time_t	t1;
d2088 1
a2088 1
	register time_t	t;
d2107 1
a2107 1
static time_t
d2114 1
a2114 1
	register time_t	t;
d2178 2
a2179 1
				warning(_("rule goes past start/end of month--will not work with pre-2004 versions of zic"));
d2182 1
a2182 1
	if (dayoff < 0 && !TYPE_SIGNED(time_t))
d2188 1
a2188 1
	t = (time_t) dayoff * SECSPERDAY;
d2198 35
@


1.22
log
@sort options, correct SYNOPSIS, and sync usage();
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)zic.c	7.113";
static char rcsid[] = "$OpenBSD: zic.c,v 1.21 2003/10/06 00:17:13 millert Exp $";
d925 2
d2146 2
a2147 2
			error(_("no day in month matches rule"));
			(void) exit(EXIT_FAILURE);
d2239 1
a2239 1
** UNIX was a registered trademark of UNIX System Laboratories in 1993.
@


1.21
log
@Update to tzcode2003c from elsie.nci.nih.gov
Fixes a pasto and implements better int oflow checking (doesn't rely on
unspecified behavior).
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: zic.c,v 1.20 2003/04/06 00:44:36 deraadt Exp $";
d453 1
a453 1
	(void) fprintf(stderr, _("%s: usage is %s [-sv] [-l localtime] [-p posixrules] [-d directory]\n\t[-L leapseconds] [-y yearistype] [filename ...]\n"),
@


1.20
log
@string handling; ok millert
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)zic.c	7.107";
static char rcsid[] = "$OpenBSD: zic.c,v 1.19 2003/04/05 04:16:09 pvalchev Exp $";
d1152 6
a1157 6
	t = (time_t) dayoff * SECSPERDAY;
	/*
	** Cheap overflow check.
	*/
	if (t / SECSPERDAY != dayoff) {
		error(_("time overflow"));
d1160 1
d1313 1
a1313 1
			warning(_("starting year too low to be represented"));
d1315 1
a1315 1
			warning(_("starting year too high to be represented"));
d2150 4
a2154 5
	/*
	** Cheap overflow check.
	*/
	if (t / SECSPERDAY != dayoff)
		return (dayoff > 0) ? max_time : min_time;
@


1.19
log
@fix typo, bad tdeval; pt out by emmf26@@umr.edu
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: zic.c,v 1.18 2003/04/05 00:48:02 tdeval Exp $";
d964 1
d971 3
a973 2
		buf = erealloc(buf, (int) (132 + strlen(TZDEFAULT)));
		(void) sprintf(buf,
d980 3
a982 2
		buf = erealloc(buf, (int) (132 + strlen(TZDEFRULES)));
		(void) sprintf(buf,
d991 4
a994 4
				buf = erealloc(buf, (int) (132 +
					strlen(fields[ZF_NAME]) +
					strlen(zones[i].z_filename)));
				(void) sprintf(buf,
d1423 1
d1468 4
a1471 3
	fullname = erealloc(fullname,
		(int) (strlen(directory) + 1 + strlen(name) + 1));
	(void) sprintf(fullname, "%s/%s", directory, name);
d1913 1
d1917 3
a1919 2
	buf = erealloc(buf, (int) (132 + strlen(yitcommand) + strlen(type)));
	(void) sprintf(buf, "%s %d %s", yitcommand, year, type);
@


1.18
log
@add a size parameter to doabbr(), and convert
strcpy/sprintf -> strlcpy/snprintf.
ok tedu@@, krw@@; help from deraadt@@, millert@@
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: zic.c,v 1.17 2003/02/14 18:24:53 millert Exp $";
d1556 1
a1556 1
doabbr(abbr, size_t, format, letters, isdst)
@


1.17
log
@license clarifications; arthur_david_olson@@nih.gov
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: zic.c,v 1.16 2002/04/04 19:12:09 millert Exp $";
d105 1
a105 1
static void	doabbr P((char * abbr, const char * format,
d1556 1
a1556 1
doabbr(abbr, format, letters, isdst)
d1558 1
d1565 2
a1566 2
			(void) strcpy(abbr, format);
		else	(void) sprintf(abbr, format, letters);
d1568 1
a1568 1
		(void) strcpy(abbr, strchr(format, '/') + 1);
d1570 1
a1570 1
		(void) strcpy(abbr, format);
d1624 1
a1624 1
			doabbr(startbuf, zp->z_format,
d1709 3
a1711 1
						doabbr(startbuf, zp->z_format,
d1719 3
a1721 1
						doabbr(startbuf, zp->z_format,
d1728 2
a1729 2
				doabbr(buf, zp->z_format, rp->r_abbrvar,
					rp->r_stdoff != 0);
d1741 2
a1742 1
					(void) strcpy(startbuf, zp->z_format);
d1780 1
a1780 1
			(void) strcpy(chars, &chars[abbrinds[type]]);
d2162 1
a2162 1
	(void) strcpy(&chars[charcnt], string);
@


1.16
log
@Minor updates from tzcode2002c
@
text
@d1 5
d8 1
a8 1
static char rcsid[] = "$OpenBSD: zic.c,v 1.15 2000/09/06 23:05:12 millert Exp $";
@


1.15
log
@Update to tzcode2000f from ftp://elsie.nci.nih.gov/pub/
@
text
@d2 2
a3 2
static char elsieid[] = "@@(#)zic.c	7.101";
static char rcsid[] = "$OpenBSD: zic.c,v 1.14 2000/08/05 20:53:38 deraadt Exp $";
d9 9
a17 3
#ifdef __unix__
#include "sys/stat.h"			/* for umask manifest constants */
#endif /* defined __unix__ */
a1596 4
	** A guess that may well be corrected later.
	*/
	stdoff = 0;
	/*
d1603 4
d1626 1
a1626 2
			}
			else if (stdoff != 0)
d2184 1
a2184 1
			if (mkdir(name, S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) != 0) {
@


1.14
log
@pretty; ok millert
@
text
@d2 2
a3 2
static char elsieid[] = "@@(#)zic.c	7.100";
static char rcsid[] = "$OpenBSD: zic.c,v 1.13 2000/04/16 16:24:04 d Exp $";
@


1.13
log
@sync with ftp://elsie.nci.nih.gov/pub/tzcode2000c.tar.gz, millert@@ ok
@
text
@d3 1
a3 1
static char rcsid[] = "$OpenBSD: zic.c,v 1.12 2000/03/30 23:30:25 millert Exp $";
d442 1
a442 1
	(void) fprintf(stderr, _("%s: usage is %s [ -s ] [ -v ] [ -l localtime ] [ -p posixrules ] [ -d directory ]\n\t[ -L leapseconds ] [ -y yearistype ] [ filename ... ]\n"),
@


1.12
log
@Try a hard link before a soft one since we want hard links in
the zoneinfo dir.
@
text
@d2 2
a3 2
static char elsieid[] = "@@(#)zic.c	7.99";
static char rcsid[] = "$OpenBSD: zic.c,v 1.11 2000/03/30 23:26:45 millert Exp $";
d1898 6
a1903 4
	if (result == 0)
		return TRUE;
	if (result == (1 << 8))
		return FALSE;
@


1.11
log
@Make 'zic -l' actually work.  I guess we all just do the symlink
by hand and thus never noticed.
@
text
@d3 1
a3 1
static char rcsid[] = "$OpenBSD: zic.c,v 1.10 1999/07/01 23:05:39 d Exp $";
d614 1
d616 2
a617 3
		result = symlink(fromname, toname);
#else
		result = link(fromname, toname);
@


1.10
log
@tzcode1999d from ftp://elsie.nci.nih.gov/pub/; ok millert@@
@
text
@d3 1
a3 1
static char rcsid[] = "$OpenBSD: zic.c,v 1.9 1999/01/29 07:04:05 d Exp $";
d614 3
a617 13
#if (HAVE_SYMLINK - 0) 
		if (result != 0) {
		        char *s = (char *) tofile;
		        register char * symlinkcontents = NULL;
		        while ((s = strchr(s+1, '/')) != NULL)
			        symlinkcontents = ecatalloc(symlinkcontents, "../");
			symlinkcontents = ecatalloc(symlinkcontents, fromfile);

			result = symlink(symlinkcontents, toname);
			if (result == 0)
warning(_("hard link failed, symbolic link used"));
			ifree(symlinkcontents);
		}
@


1.9
log
@tzcode1999a from ftp://elsie.nci.nih.gov/pub
@
text
@d2 2
a3 2
static char elsieid[] = "@@(#)zic.c	7.96";
static char rcsid[] = "$OpenBSD: zic.c,v 1.7 1998/01/18 23:25:04 millert Exp $";
d565 2
a566 1
	for (i = 0; i < nlinks; ++i)
d568 3
a570 1
	if (lcltime != NULL)
d572 3
a574 1
	if (psxrules != NULL)
d576 1
d613 1
d617 7
a623 1
			result = symlink(fromname, toname);
d626 1
@


1.8
log
@namespaces: unix --> __unix__
@
text
@d2 1
a2 1
static char elsieid[] = "@@(#)zic.c	7.93";
d383 1
a383 1
		sys_errlist[errnum] : "Unknown system error";
d432 1
a432 1
	cp = ecpyalloc("warning: ");
d603 2
d607 9
a615 1
		if (link(fromname, toname) != 0) {
d903 1
a903 1
	if (hh < 0 || hh >= HOURSPERDAY ||
d905 2
a906 1
		ss < 0 || ss > SECSPERMIN) {
@


1.7
log
@tzcode1998b from ftp://elsie.nci.nih.gov/pub
@
text
@d3 1
a3 1
static char rcsid[] = "$OpenBSD: zic.c,v 1.6 1997/01/15 23:40:55 millert Exp $";
d9 1
a9 1
#ifdef unix
d11 1
a11 1
#endif /* defined unix */
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 3
a3 6
#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char	elsieid[] = "@@(#)zic.c	7.80";
#else
static char rcsid[] = "$OpenBSD: zic.c,v 1.5 1997/01/14 03:16:58 millert Exp $";
#endif
a80 5
extern char *	icatalloc P((char * old, const char * new));
extern char *	icpyalloc P((const char * string));
extern void	ifree P((char * p));
extern char *	imalloc P((int n));
extern void *	irealloc P((void * old, int n));
a83 1
extern char *	scheck P((const char * string, const char * format));
d143 1
d146 1
d434 1
a434 1
	error(string);
d653 2
d1022 1
a1022 1
	z.z_gmtoff = gethms(fields[i_gmtoff], _("invalid GMT offset"), TRUE);
d1224 1
d1256 5
d1281 5
d1300 2
d1410 2
d1413 1
a1413 1
			while (attypes[fromi].type == 0)
d1468 1
d1470 1
d1634 1
a1634 1
					** Turn untiltime into GMT
d1740 1
a1740 1
const int	type;
d1742 14
d1950 1
a1950 1
		if (itsabbr(word, lp->l_word))
d1954 1
d2158 3
d2162 1
a2162 1
			if (mkdir(name, 0755) != 0) {
d2165 7
a2171 5
				(void) fprintf(stderr,
				    _("%s: Can't create directory %s: %s\n"),
				    progname, name, e);
				ifree(name);
				return -1;
@


1.5
log
@Update to tzcode1996o + our fixes.  Fixes problem pointed out
by cross@@va.pubnix.com.
@
text
@d5 1
a5 1
static char rcsid[] = "$OpenBSD: zic.c,v 1.4 1996/08/19 08:34:56 tholo Exp $";
d481 1
a481 1
	while ((c = getopt(argc, argv, "d:l:p:L:vsy:")) != EOF)
@


1.4
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d2 5
a6 1
static char rcsid[] = "$OpenBSD$";
d10 1
d141 4
d340 4
a343 2
static time_t		ats[TZ_MAX_TIMES];
static unsigned char	types[TZ_MAX_TIMES];
d363 4
a366 1
		(void) perror(progname);
d381 13
d424 1
a424 1
	(void) fprintf(stderr, "\"%s\", line %d: %s",
d427 1
a427 1
		(void) fprintf(stderr, " (rule from \"%s\", line %d)",
d434 13
d449 1
a449 3
	(void) fprintf(stderr, "%s: usage is %s \
[ -s ] [ -v ] [ -l localtime ] [ -p posixrules ] [ -d directory ]\n\
\t[ -L leapseconds ] [ -y yearistype ] [ filename ... ]\n",
d473 7
d490 1
a490 1
"%s: More than one -d option specified\n",
d500 1
a500 1
"%s: More than one -l option specified\n",
d510 1
a510 1
"%s: More than one -p option specified\n",
d520 1
a520 1
"%s: More than one -y option specified\n",
d530 1
a530 1
"%s: More than one -L option specified\n",
d613 5
a617 3
			(void) fprintf(stderr, "%s: Can't link from %s to ",
				progname, fromname);
			(void) perror(toname);
d641 1
a641 2
#define TIME_T_BITS_IN_FILE	((TYPE_BIT(time_t) < MAX_BITS_IN_FILE) ? \
					TYPE_BIT(time_t) : MAX_BITS_IN_FILE)
d699 1
a699 1
	register int		i;
d701 1
a701 1
	if (nrules != 0)
d704 26
d755 2
a756 1
			zp->z_stdoff = gethms(zp->z_rule, "unruly zone", TRUE);
d762 1
a762 1
				error("%s in ruleless zone");
d783 1
a783 1
		name = "standard input";
d786 4
a789 2
		(void) fprintf(stderr, "%s: Can't open ", progname);
		(void) perror(name);
d799 1
a799 1
			error("line too long");
d819 1
a819 1
				error("input line of unknown type");
d835 1
a835 1
"%s: Leap line in non leap seconds file %s\n",
d842 1
a842 1
"%s: panic: Invalid l_value %d\n",
d850 2
a851 2
		(void) fprintf(stderr, "%s: Error reading ", progname);
		(void) perror(filename);
d855 4
a858 2
		(void) fprintf(stderr, "%s: Error closing ", progname);
		(void) perror(filename);
d862 1
a862 1
		error("expected continuation line not found");
d917 1
a917 1
		error("wrong number of fields on Rule line");
d921 1
a921 1
		error("nameless rule");
d926 1
a926 1
	r.r_stdoff = gethms(fields[RF_STDOFF], "invalid saved time", TRUE);
d945 1
a945 1
		error("wrong number of fields on Zone line");
d951 1
a951 1
"\"Zone %s\" line and -l option are mutually exclusive",
d959 1
a959 1
"\"Zone %s\" line and -p option are mutually exclusive",
d971 1
a971 1
"duplicate zone name %s (file \"%s\", line %d)",
d987 1
a987 1
		error("wrong number of fields on Zone continuation line");
d1027 1
a1027 1
	z.z_gmtoff = gethms(fields[i_gmtoff], "invalid GMT offset", TRUE);
d1030 1
a1030 1
			error("invalid abbreviation format");
d1056 1
a1056 2
				error("Zone continuation line end time is not \
after end time of previous line");
d1083 1
a1083 1
		error("wrong number of fields on Leap line");
d1092 1
a1092 1
			error("invalid leaping year");
d1107 1
a1107 1
		error("invalid month name");
d1120 1
a1120 1
			error("invalid day of month");
d1125 1
a1125 1
		error("time before zero");
d1133 1
a1133 1
		error("time overflow");
d1136 1
a1136 1
	tod = gethms(fields[LP_TIME], "invalid time of day", FALSE);
d1155 1
a1155 1
			error("illegal CORRECTION field on Leap line");
d1159 1
a1159 1
			error("illegal Rolling/Stationary field on Leap line");
d1174 1
a1174 1
		error("wrong number of fields on Link line");
d1178 1
a1178 1
		error("blank FROM field on Link line");
d1182 1
a1182 1
		error("blank TO field on Link line");
d1210 1
a1210 1
		error("invalid month name");
d1238 1
a1238 1
	rp->r_tod = gethms(dp, "invalid time of day", FALSE);
d1254 1
a1254 1
				"%s: panic: Invalid l_value %d\n",
d1258 1
a1258 1
		error("invalid starting year");
d1274 1
a1274 1
				"%s: panic: Invalid l_value %d\n",
d1278 1
a1278 1
		error("invalid ending year");
d1282 1
a1282 1
		error("starting year greater than ending year");
d1289 1
a1289 1
			error("typed single year");
d1319 1
a1319 1
				error("invalid day of month");
d1324 1
a1324 1
				error("invalid weekday name");
d1333 1
a1333 1
				error("invalid day of month");
d1364 12
d1384 15
d1400 28
d1431 10
d1445 4
a1448 2
			(void) fprintf(stderr, "%s: Can't create ", progname);
			(void) perror(fullname);
d1458 1
a1458 2
#define DO(field)	(void) fwrite((void *) tzh.field, \
		(size_t) sizeof tzh.field, (size_t) 1, fp)
d1511 2
a1512 2
		(void) fprintf(stderr, "%s: Write error on ", progname);
		(void) perror(fullname);
a1549 1
	register int			startisdst;
a1556 1
	INITIALIZE(startoff);
d1581 2
a1582 1
		startisdst = -1;
d1590 1
a1590 1
			if (usestart)
d1592 2
d1664 3
d1668 14
a1681 24
				    if (ktime < starttime) {
					stdoff = rp->r_stdoff;
					startoff = oadd(zp->z_gmtoff,
						rp->r_stdoff);
					doabbr(startbuf, zp->z_format,
						rp->r_abbrvar,
						rp->r_stdoff != 0);
					startisdst = rp->r_stdoff != 0;
					continue;
				    }
				    usestart = FALSE;
				    if (ktime != starttime) {
					if (startisdst < 0 &&
					    zp->z_gmtoff !=
					    (zp - 1)->z_gmtoff) {
						type = (timecnt == 0) ? 0 :
							types[timecnt - 1];
						startoff = oadd(gmtoffs[type],
							-(zp - 1)->z_gmtoff);
						startisdst = startoff != 0;
						startoff = oadd(startoff,
							zp->z_gmtoff);
						(void) strcpy(startbuf,
						    &chars[abbrinds[type]]);
a1682 4
					if (startisdst >= 0)
addtt(starttime, addtype(startoff, startbuf, startisdst, startttisstd,
	startttisgmt));
				    }
a1691 1
				stdoff = rp->r_stdoff;
d1694 15
a1712 1
			starttime = tadd(zp->z_untiltime, -gmtoff);
d1715 1
d1718 2
a1729 4
	if (timecnt != 0 && type == types[timecnt - 1])
		return;	/* easy enough! */
	if (timecnt == 0 && type == 0 && isdsts[0] == 0)
		return; /* handled by default rule */
d1731 1
a1731 1
		error("too many transitions?!");
d1734 2
a1735 2
	ats[timecnt] = starttime;
	types[timecnt] = type;
d1749 12
d1777 1
a1777 1
		error("too many local time types");
d1805 1
a1805 1
		error("too many leap seconds");
d1811 1
a1811 1
				error("repeated leap second moment");
d1861 2
a1862 2
	error("Wild result from command execution");
	(void) fprintf(stderr, "%s: command was '%s', result was %d\n",
d1956 1
a1956 1
				else	error("Odd number of quotation marks");
d1976 1
a1976 1
		error("time overflow");
d1995 1
a1995 1
		error("time overflow");
d2042 1
a2042 1
			error("use of 2/29 in non leap-year");
d2076 1
a2076 1
			error("no day in month matches rule");
d2099 1
a2099 1
		error("too many, or too long, time zone abbreviations");
d2133 2
d2136 2
a2137 3
					"%s: Can't create directory ",
					progname);
				(void) perror(name);
d2157 1
a2157 1
			"%s: %d did not sign extend correctly\n",
@


1.3
log
@new common tz code
@
text
@d1 3
a3 7
/*	$NetBSD: zic.c,v 1.4 1996/01/20 02:31:50 jtc Exp $	*/

#ifndef lint
#ifndef NOID
static char	elsieid[] = "@@(#)zic.c	7.59";
#endif /* !defined NOID */
#endif /* !defined lint */
@


1.2
log
@from netbsd; sync with tzcode96a
@
text
@d1 1
a1 1
/*	$NetBSD: zic.c,v 1.3 1996/01/08 22:51:01 jtc Exp $	*/
d5 1
a5 1
static char	elsieid[] = "@@(#)zic.c	7.57";
a589 3
#define TIME_T_SIGNED (((time_t) -1) < 0)
#define TIME_T_BIT (sizeof (time_t) * CHAR_BIT)

d598 2
a599 2
#define TIME_T_BITS_IN_FILE	((TIME_T_BIT < MAX_BITS_IN_FILE) ? \
					TIME_T_BIT : MAX_BITS_IN_FILE)
d604 1
a604 1
	if (TIME_T_SIGNED) {
d1052 1
a1052 1
	if (dayoff < 0 && !TIME_T_SIGNED) {
d1928 1
a1928 1
	if (dayoff < 0 && !TIME_T_SIGNED)
d1971 1
a1971 1
			name[1] == ':' && name[2] != '\0') {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: zic.c,v 1.2 1995/03/10 18:12:44 jtc Exp $	*/
d5 1
a5 1
static char	elsieid[] = "@@(#)zic.c	7.50";
d15 13
a144 1
static int		max_int;
a146 1
static int		min_int;
a154 1
static int		tt_signed;
d582 22
d607 4
a610 9
	register time_t	bit;
	register int bii;

	for (bit = 1; bit > 0; bit <<= 1)
		continue;
	if (bit == 0) {		/* time_t is an unsigned type */
		tt_signed = FALSE;
		min_time = 0;
		max_time = ~(time_t) 0;
d612 1
a612 1
			max_time >>= 1;
d614 4
a617 7
		tt_signed = TRUE;
		min_time = bit;
		max_time = bit;
		++max_time;
		max_time = -max_time;
		if (sflag)
			min_time = 0;
a620 5

	for (bii = 1; bii > 0; bii <<= 1)
		continue;
	min_int = bii;
	max_int = -1 - bii;
d740 1
a740 1
			if (ciequal(fields[nfields], "-"))
d1055 1
a1055 1
	if (dayoff < 0 && !tt_signed) {
d1178 1
a1178 1
			rp->r_loyear = min_int;
d1181 1
a1181 1
			rp->r_loyear = max_int;
d1195 1
a1195 1
			rp->r_hiyear = min_int;
d1198 1
a1198 1
			rp->r_hiyear = max_int;
d1721 1
a1721 1
const int	a;
d1723 1
d1747 4
a1750 3
		do if (*word == '\0')
			return FALSE;
				while (lowerit(*word++) != lowerit(*abbr));
d1796 1
a1796 1
		while (isascii(*cp) && isspace(*cp))
d1809 2
a1810 2
			(!isascii(*cp) || !isspace(*cp)));
		if (isascii(*cp) && isspace(*cp))
d1866 1
a1866 1
	if (wantedy == min_int)
d1868 1
a1868 1
	if (wantedy == max_int)
d1931 1
a1931 1
	if (dayoff < 0 && !tt_signed)
d1973 2
a1974 2
		if (strlen(name) == 2 && isascii(name[0]) &&
			isalpha(name[0]) && name[1] == ':') {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
