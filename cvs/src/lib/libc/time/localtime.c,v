head	1.59;
access;
symbols
	OPENBSD_6_2:1.59.0.6
	OPENBSD_6_2_BASE:1.59
	OPENBSD_6_1:1.59.0.4
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.38.0.8
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.6
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.37.0.8
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.6
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.34.0.10
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.6
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.8
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.4
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.4
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.19.0.6
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.19.0.4
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.17.0.4
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2016.09.19.12.48.21;	author millert;	state Exp;
branches;
next	1.58;
commitid	Hb8b2NmZGgRrce9e;

1.58
date	2016.03.14.15.26.52;	author mestre;	state Exp;
branches;
next	1.57;
commitid	VwWqZ5sO8B77kGGU;

1.57
date	2015.12.12.21.25.44;	author mmcc;	state Exp;
branches;
next	1.56;
commitid	5eMnW6VVou5MamKT;

1.56
date	2015.11.01.03.45.29;	author guenther;	state Exp;
branches;
next	1.55;
commitid	CfNWDWdDpm7mVO8i;

1.55
date	2015.10.24.18.13.18;	author guenther;	state Exp;
branches;
next	1.54;
commitid	3UUG5rCiAaQfZxGj;

1.54
date	2015.09.19.04.02.21;	author guenther;	state Exp;
branches;
next	1.53;
commitid	xONsWdI5wUyoKz4N;

1.53
date	2015.09.12.14.35.40;	author guenther;	state Exp;
branches;
next	1.52;
commitid	3aozKGzPDVlUxHqo;

1.52
date	2015.04.07.01.47.04;	author millert;	state Exp;
branches;
next	1.51;
commitid	WuVjttMIVorUAdZQ;

1.51
date	2015.02.16.17.51.48;	author tedu;	state Exp;
branches;
next	1.50;
commitid	nyb6lqadPr1tWGKD;

1.50
date	2015.02.16.17.44.03;	author tedu;	state Exp;
branches;
next	1.49;
commitid	LBtIfZRWjbVK3ITP;

1.49
date	2015.02.16.17.35.38;	author tedu;	state Exp;
branches;
next	1.48;
commitid	hGmApVtIoWcT7SuR;

1.48
date	2015.02.16.17.11.54;	author tedu;	state Exp;
branches;
next	1.47;
commitid	ixmRXbwUTO3BdBrW;

1.47
date	2015.02.10.00.46.27;	author tedu;	state Exp;
branches;
next	1.46;
commitid	96qn9TxckGM707IO;

1.46
date	2015.02.09.14.58.08;	author tedu;	state Exp;
branches;
next	1.45;
commitid	Fk4f8CitaztWNLFl;

1.45
date	2015.02.09.14.52.28;	author tedu;	state Exp;
branches;
next	1.44;
commitid	93eVast0s79AHJL6;

1.44
date	2015.02.09.14.46.40;	author tedu;	state Exp;
branches;
next	1.43;
commitid	WjTq7vyEHgzcMgO9;

1.43
date	2015.02.09.14.00.03;	author tedu;	state Exp;
branches;
next	1.42;
commitid	d4VCCcG9HT8Wy2HB;

1.42
date	2015.02.09.13.46.22;	author tedu;	state Exp;
branches;
next	1.41;
commitid	lqdxXphiTozivn2t;

1.41
date	2015.02.09.13.32.51;	author tedu;	state Exp;
branches;
next	1.40;
commitid	QYDQRaNlwjawD1Bd;

1.40
date	2015.02.09.13.03.59;	author tedu;	state Exp;
branches;
next	1.39;
commitid	hM2fRR2l9wlf7blE;

1.39
date	2015.02.09.08.25.11;	author tedu;	state Exp;
branches;
next	1.38;
commitid	1GKby7MIpIVNqvkA;

1.38
date	2013.04.17.17.40.35;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.25.13.27.27;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2010.11.30.00.38.58;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.23.22.35.34;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2008.03.31.14.16.53;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2007.12.29.22.26.51;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.06.19.35.16;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.18.21.54.17;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.09.16.12.12;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.09.03.22.06;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.09.03.21.14;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.08.08.05.38;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.05.13.40.51;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.18.22.33.43;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.28.14.47.41;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.06.00.17.13;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.13.15.47.34;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.04.19.12.09;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.27.00.58.57;	author lebel;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.16.16.24.03;	author d;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.06.08.24.17;	author d;	state Exp;
branches;
next	1.17;

1.17
date	99.03.09.23.06.12;	author pjanzen;	state Exp;
branches;
next	1.16;

1.16
date	99.02.02.00.22.42;	author d;	state Exp;
branches;
next	1.15;

1.15
date	99.02.01.08.19.36;	author d;	state Exp;
branches;
next	1.14;

1.14
date	98.11.20.11.18.55;	author d;	state Exp;
branches;
next	1.13;

1.13
date	98.07.11.23.17.20;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.07.11.23.08.53;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.01.18.23.24.53;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.04.02.03.57.30;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.21.04.52.44;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.01.14.03.16.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.10.30.00.20.14;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.09.05.12.28.23;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.25.10.11.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.08.34.50;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.29.02.08.14;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.11.17.46.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.59
log
@gmtime_r() should return NULL on failure, not the struct tm * result
parameter that was passed in.  From Carlin Bingham.
@
text
@/*	$OpenBSD: localtime.c,v 1.58 2016/03/14 15:26:52 mestre Exp $ */
/*
** This file is in the public domain, so clarified as of
** 1996-06-05 by Arthur David Olson.
*/

/*
** Leap second handling from Bradley White.
** POSIX-style TZ environment variable handling from Guy Harris.
*/

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <float.h>	/* for FLT_MAX and DBL_MAX */
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "private.h"
#include "tzfile.h"
#include "thread_private.h"

#ifndef TZ_ABBR_MAX_LEN
#define TZ_ABBR_MAX_LEN	16
#endif /* !defined TZ_ABBR_MAX_LEN */

#ifndef TZ_ABBR_CHAR_SET
#define TZ_ABBR_CHAR_SET \
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 :+-._"
#endif /* !defined TZ_ABBR_CHAR_SET */

#ifndef TZ_ABBR_ERR_CHAR
#define TZ_ABBR_ERR_CHAR	'_'
#endif /* !defined TZ_ABBR_ERR_CHAR */

#ifndef WILDABBR
/*
** Someone might make incorrect use of a time zone abbreviation:
**	1.	They might reference tzname[0] before calling tzset (explicitly
**		or implicitly).
**	2.	They might reference tzname[1] before calling tzset (explicitly
**		or implicitly).
**	3.	They might reference tzname[1] after setting to a time zone
**		in which Daylight Saving Time is never observed.
**	4.	They might reference tzname[0] after setting to a time zone
**		in which Standard Time is never observed.
**	5.	They might reference tm.TM_ZONE after calling offtime.
** What's best to do in the above cases is open to debate;
** for now, we just set things up so that in any of the five cases
** WILDABBR is used. Another possibility: initialize tzname[0] to the
** string "tzname[0] used before set", and similarly for the other cases.
** And another: initialize tzname[0] to "ERA", with an explanation in the
** manual page of what this "time zone abbreviation" means (doing this so
** that tzname[0] has the "normal" length of three characters).
*/
#define WILDABBR	"   "
#endif /* !defined WILDABBR */

static char		wildabbr[] = WILDABBR;

static const char	gmt[] = "GMT";

/*
** The DST rules to use if TZ has no rules and we can't load TZDEFRULES.
** We default to US rules as of 1999-08-17.
** POSIX 1003.1 section 8.1.1 says that the default DST rules are
** implementation dependent; for historical reasons, US rules are a
** common default.
*/
#ifndef TZDEFRULESTRING
#define TZDEFRULESTRING ",M4.1.0,M10.5.0"
#endif /* !defined TZDEFDST */

struct ttinfo {				/* time type information */
	long		tt_gmtoff;	/* UTC offset in seconds */
	int		tt_isdst;	/* used to set tm_isdst */
	int		tt_abbrind;	/* abbreviation list index */
	int		tt_ttisstd;	/* TRUE if transition is std time */
	int		tt_ttisgmt;	/* TRUE if transition is UTC */
};

struct lsinfo {				/* leap second information */
	time_t		ls_trans;	/* transition time */
	long		ls_corr;	/* correction to apply */
};

#define BIGGEST(a, b)	(((a) > (b)) ? (a) : (b))

#ifdef TZNAME_MAX
#define MY_TZNAME_MAX	TZNAME_MAX
#endif /* defined TZNAME_MAX */
#ifndef TZNAME_MAX
#define MY_TZNAME_MAX	255
#endif /* !defined TZNAME_MAX */

struct state {
	int		leapcnt;
	int		timecnt;
	int		typecnt;
	int		charcnt;
	int		goback;
	int		goahead;
	time_t		ats[TZ_MAX_TIMES];
	unsigned char	types[TZ_MAX_TIMES];
	struct ttinfo	ttis[TZ_MAX_TYPES];
	char		chars[BIGGEST(BIGGEST(TZ_MAX_CHARS + 1, sizeof gmt),
			    (2 * (MY_TZNAME_MAX + 1)))];
	struct lsinfo	lsis[TZ_MAX_LEAPS];
};

struct rule {
	int		r_type;		/* type of rule--see below */
	int		r_day;		/* day number of rule */
	int		r_week;		/* week number of rule */
	int		r_mon;		/* month number of rule */
	long		r_time;		/* transition time of rule */
};

#define JULIAN_DAY		0	/* Jn - Julian day */
#define DAY_OF_YEAR		1	/* n - day of year */
#define MONTH_NTH_DAY_OF_WEEK	2	/* Mm.n.d - month, week, day of week */

/*
** Prototypes for static functions.
*/

static long		detzcode(const char * codep);
static time_t		detzcode64(const char * codep);
static int		differ_by_repeat(time_t t1, time_t t0);
static const char *	getzname(const char * strp);
static const char *	getqzname(const char * strp, const int delim);
static const char *	getnum(const char * strp, int * nump, int min,
				int max);
static const char *	getsecs(const char * strp, long * secsp);
static const char *	getoffset(const char * strp, long * offsetp);
static const char *	getrule(const char * strp, struct rule * rulep);
static void		gmtload(struct state * sp);
static struct tm *	gmtsub(const time_t * timep, long offset,
				struct tm * tmp);
static struct tm *	localsub(const time_t * timep, long offset,
				struct tm * tmp);
static int		increment_overflow(int * number, int delta);
static int		leaps_thru_end_of(int y);
static int		long_increment_overflow(long * number, int delta);
static int		long_normalize_overflow(long * tensptr,
				int * unitsptr, int base);
static int		normalize_overflow(int * tensptr, int * unitsptr,
				int base);
static void		settzname(void);
static time_t		time1(struct tm * tmp,
				struct tm * (*funcp)(const time_t *,
				long, struct tm *),
				long offset);
static time_t		time2(struct tm *tmp,
				struct tm * (*funcp)(const time_t *,
				long, struct tm*),
				long offset, int * okayp);
static time_t		time2sub(struct tm *tmp,
				struct tm * (*funcp)(const time_t *,
				long, struct tm*),
				long offset, int * okayp, int do_norm_secs);
static struct tm *	timesub(const time_t * timep, long offset,
				const struct state * sp, struct tm * tmp);
static int		tmcomp(const struct tm * atmp,
				const struct tm * btmp);
static time_t		transtime(time_t janfirst, int year,
				const struct rule * rulep, long offset);
static int		typesequiv(const struct state * sp, int a, int b);
static int		tzload(const char * name, struct state * sp,
				int doextend);
static int		tzparse(const char * name, struct state * sp,
				int lastditch);

#ifdef STD_INSPIRED
struct tm	*offtime(const time_t *, long);
time_t		time2posix(time_t);
time_t		posix2time(time_t);
PROTO_DEPRECATED(offtime);
PROTO_DEPRECATED(time2posix);
PROTO_DEPRECATED(posix2time);
#endif

static struct state *	lclptr;
static struct state *	gmtptr;


#ifndef TZ_STRLEN_MAX
#define TZ_STRLEN_MAX 255
#endif /* !defined TZ_STRLEN_MAX */

static char		lcl_TZname[TZ_STRLEN_MAX + 1];
static int		lcl_is_set;
static int		gmt_is_set;
_THREAD_PRIVATE_MUTEX(lcl);
_THREAD_PRIVATE_MUTEX(gmt);

char *			tzname[2] = {
	wildabbr,
	wildabbr
};
#if 0
DEF_WEAK(tzname);
#endif

/*
** Section 4.12.3 of X3.159-1989 requires that
**	Except for the strftime function, these functions [asctime,
**	ctime, gmtime, localtime] return values in one of two static
**	objects: a broken-down time structure and an array of char.
** Thanks to Paul Eggert for noting this.
*/

static struct tm	tm;

#ifdef USG_COMPAT
long			timezone = 0;
int			daylight = 0;
#endif /* defined USG_COMPAT */

#ifdef ALTZONE
time_t			altzone = 0;
#endif /* defined ALTZONE */

static long
detzcode(const char *codep)
{
	long	result;
	int	i;

	result = (codep[0] & 0x80) ? ~0L : 0;
	for (i = 0; i < 4; ++i)
		result = (result << 8) | (codep[i] & 0xff);
	return result;
}

static time_t
detzcode64(const char *codep)
{
	time_t	result;
	int	i;

	result = (codep[0] & 0x80) ?  (~(int_fast64_t) 0) : 0;
	for (i = 0; i < 8; ++i)
		result = result * 256 + (codep[i] & 0xff);
	return result;
}

static void
settzname(void)
{
	struct state * const	sp = lclptr;
	int			i;

	tzname[0] = wildabbr;
	tzname[1] = wildabbr;
#ifdef USG_COMPAT
	daylight = 0;
	timezone = 0;
#endif /* defined USG_COMPAT */
#ifdef ALTZONE
	altzone = 0;
#endif /* defined ALTZONE */
	if (sp == NULL) {
		tzname[0] = tzname[1] = (char *)gmt;
		return;
	}
	/*
	** And to get the latest zone names into tzname. . .
	*/
	for (i = 0; i < sp->timecnt; ++i) {
		const struct ttinfo *ttisp = &sp->ttis[sp->types[i]];

		tzname[ttisp->tt_isdst] = &sp->chars[ttisp->tt_abbrind];
#ifdef USG_COMPAT
		if (ttisp->tt_isdst)
			daylight = 1;
		if (!ttisp->tt_isdst)
			timezone = -(ttisp->tt_gmtoff);
#endif /* defined USG_COMPAT */
#ifdef ALTZONE
		if (ttisp->tt_isdst)
			altzone = -(ttisp->tt_gmtoff);
#endif /* defined ALTZONE */
	}
	/*
	** Finally, scrub the abbreviations.
	** First, replace bogus characters.
	*/
	for (i = 0; i < sp->charcnt; ++i) {
		if (strchr(TZ_ABBR_CHAR_SET, sp->chars[i]) == NULL)
			sp->chars[i] = TZ_ABBR_ERR_CHAR;
	}
	/*
	** Second, truncate long abbreviations.
	*/
	for (i = 0; i < sp->typecnt; ++i) {
		const struct ttinfo *ttisp = &sp->ttis[i];
		char *cp = &sp->chars[ttisp->tt_abbrind];

		if (strlen(cp) > TZ_ABBR_MAX_LEN &&
		    strcmp(cp, GRANDPARENTED) != 0)
			*(cp + TZ_ABBR_MAX_LEN) = '\0';
	}
}

static int
differ_by_repeat(time_t t1, time_t t0)
{
	if (TYPE_BIT(time_t) - 1 < SECSPERREPEAT_BITS)
		return 0;
	return (int64_t)t1 - t0 == SECSPERREPEAT;
}

static int
tzload(const char *name, struct state *sp, int doextend)
{
	const char *		p;
	int			i;
	int			fid;
	int			stored;
	int			nread;
	typedef union {
		struct tzhead	tzhead;
		char		buf[2 * sizeof(struct tzhead) +
				    2 * sizeof *sp +
				    4 * TZ_MAX_TIMES];
	} u_t;
	u_t *			up;
	char			fullname[PATH_MAX];

	up = calloc(1, sizeof *up);
	if (up == NULL)
		return -1;

	sp->goback = sp->goahead = FALSE;
	if (name != NULL && issetugid() != 0) {
		if ((name[0] == ':' && (strchr(name, '/') || strstr(name, ".."))) ||
		    name[0] == '/' || strchr(name, '.'))
			name = NULL;
	}
	if (name == NULL && (name = TZDEFAULT) == NULL)
		goto oops;

	if (name[0] == ':')
		++name;
	if (name[0] != '/') {
		if ((p = TZDIR) == NULL)
			goto oops;
		if ((strlen(p) + strlen(name) + 1) >= sizeof fullname)
			goto oops;
		strlcpy(fullname, p, sizeof fullname);
		strlcat(fullname, "/", sizeof fullname);
		strlcat(fullname, name, sizeof fullname);
		name = fullname;
	}
	if ((fid = open(name, O_RDONLY)) == -1)
		goto oops;

	nread = read(fid, up->buf, sizeof up->buf);
	if (close(fid) < 0 || nread <= 0)
		goto oops;
	for (stored = 4; stored <= 8; stored *= 2) {
		int		ttisstdcnt;
		int		ttisgmtcnt;

		ttisstdcnt = (int) detzcode(up->tzhead.tzh_ttisstdcnt);
		ttisgmtcnt = (int) detzcode(up->tzhead.tzh_ttisgmtcnt);
		sp->leapcnt = (int) detzcode(up->tzhead.tzh_leapcnt);
		sp->timecnt = (int) detzcode(up->tzhead.tzh_timecnt);
		sp->typecnt = (int) detzcode(up->tzhead.tzh_typecnt);
		sp->charcnt = (int) detzcode(up->tzhead.tzh_charcnt);
		p = up->tzhead.tzh_charcnt + sizeof up->tzhead.tzh_charcnt;
		if (sp->leapcnt < 0 || sp->leapcnt > TZ_MAX_LEAPS ||
		    sp->typecnt <= 0 || sp->typecnt > TZ_MAX_TYPES ||
		    sp->timecnt < 0 || sp->timecnt > TZ_MAX_TIMES ||
		    sp->charcnt < 0 || sp->charcnt > TZ_MAX_CHARS ||
		    (ttisstdcnt != sp->typecnt && ttisstdcnt != 0) ||
		    (ttisgmtcnt != sp->typecnt && ttisgmtcnt != 0))
			goto oops;
		if (nread - (p - up->buf) <
		    sp->timecnt * stored +		/* ats */
		    sp->timecnt +			/* types */
		    sp->typecnt * 6 +		/* ttinfos */
		    sp->charcnt +			/* chars */
		    sp->leapcnt * (stored + 4) +	/* lsinfos */
		    ttisstdcnt +			/* ttisstds */
		    ttisgmtcnt)			/* ttisgmts */
			goto oops;
		for (i = 0; i < sp->timecnt; ++i) {
			sp->ats[i] = (stored == 4) ?
			    detzcode(p) : detzcode64(p);
			p += stored;
		}
		for (i = 0; i < sp->timecnt; ++i) {
			sp->types[i] = (unsigned char) *p++;
			if (sp->types[i] >= sp->typecnt)
				goto oops;
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *	ttisp;

			ttisp = &sp->ttis[i];
			ttisp->tt_gmtoff = detzcode(p);
			p += 4;
			ttisp->tt_isdst = (unsigned char) *p++;
			if (ttisp->tt_isdst != 0 && ttisp->tt_isdst != 1)
				goto oops;
			ttisp->tt_abbrind = (unsigned char) *p++;
			if (ttisp->tt_abbrind < 0 ||
			    ttisp->tt_abbrind > sp->charcnt)
				goto oops;
		}
		for (i = 0; i < sp->charcnt; ++i)
			sp->chars[i] = *p++;
		sp->chars[i] = '\0';	/* ensure '\0' at end */
		for (i = 0; i < sp->leapcnt; ++i) {
			struct lsinfo *	lsisp;

			lsisp = &sp->lsis[i];
			lsisp->ls_trans = (stored == 4) ?
			    detzcode(p) : detzcode64(p);
			p += stored;
			lsisp->ls_corr = detzcode(p);
			p += 4;
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *	ttisp;

			ttisp = &sp->ttis[i];
			if (ttisstdcnt == 0)
				ttisp->tt_ttisstd = FALSE;
			else {
				ttisp->tt_ttisstd = *p++;
				if (ttisp->tt_ttisstd != TRUE &&
				    ttisp->tt_ttisstd != FALSE)
					goto oops;
			}
		}
		for (i = 0; i < sp->typecnt; ++i) {
			struct ttinfo *	ttisp;

			ttisp = &sp->ttis[i];
			if (ttisgmtcnt == 0)
				ttisp->tt_ttisgmt = FALSE;
			else {
				ttisp->tt_ttisgmt = *p++;
				if (ttisp->tt_ttisgmt != TRUE &&
				    ttisp->tt_ttisgmt != FALSE)
					goto oops;
			}
		}
		/*
		** Out-of-sort ats should mean we're running on a
		** signed time_t system but using a data file with
		** unsigned values (or vice versa).
		*/
		for (i = 0; i < sp->timecnt - 2; ++i)
			if (sp->ats[i] > sp->ats[i + 1]) {
				++i;
				/*
				** Ignore the end (easy).
				*/
				sp->timecnt = i;
				break;
			}
		/*
		** If this is an old file, we're done.
		*/
		if (up->tzhead.tzh_version[0] == '\0')
			break;
		nread -= p - up->buf;
		for (i = 0; i < nread; ++i)
			up->buf[i] = p[i];
		/*
		** If this is a narrow integer time_t system, we're done.
		*/
		if (stored >= sizeof(time_t))
			break;
	}
	if (doextend && nread > 2 &&
	    up->buf[0] == '\n' && up->buf[nread - 1] == '\n' &&
	    sp->typecnt + 2 <= TZ_MAX_TYPES) {
		struct state	ts;
		int	result;

		up->buf[nread - 1] = '\0';
		result = tzparse(&up->buf[1], &ts, FALSE);
		if (result == 0 && ts.typecnt == 2 &&
		    sp->charcnt + ts.charcnt <= TZ_MAX_CHARS) {
			for (i = 0; i < 2; ++i)
				ts.ttis[i].tt_abbrind +=
				    sp->charcnt;
			for (i = 0; i < ts.charcnt; ++i)
				sp->chars[sp->charcnt++] =
				    ts.chars[i];
			i = 0;
			while (i < ts.timecnt &&
			    ts.ats[i] <=
			    sp->ats[sp->timecnt - 1])
				++i;
			while (i < ts.timecnt &&
			    sp->timecnt < TZ_MAX_TIMES) {
				sp->ats[sp->timecnt] =
				    ts.ats[i];
				sp->types[sp->timecnt] =
				    sp->typecnt +
				    ts.types[i];
				++sp->timecnt;
				++i;
			}
			sp->ttis[sp->typecnt++] = ts.ttis[0];
			sp->ttis[sp->typecnt++] = ts.ttis[1];
		}
	}
	if (sp->timecnt > 1) {
		for (i = 1; i < sp->timecnt; ++i) {
			if (typesequiv(sp, sp->types[i], sp->types[0]) &&
			    differ_by_repeat(sp->ats[i], sp->ats[0])) {
				sp->goback = TRUE;
				break;
			}
		}
		for (i = sp->timecnt - 2; i >= 0; --i) {
			if (typesequiv(sp, sp->types[sp->timecnt - 1],
			    sp->types[i]) &&
			    differ_by_repeat(sp->ats[sp->timecnt - 1],
			    sp->ats[i])) {
				sp->goahead = TRUE;
				break;
			}
		}
	}
	free(up);
	return 0;
oops:
	free(up);
	return -1;
}

static int
typesequiv(const struct state *sp, int a, int b)
{
	int	result;

	if (sp == NULL ||
	    a < 0 || a >= sp->typecnt ||
	    b < 0 || b >= sp->typecnt)
		result = FALSE;
	else {
		const struct ttinfo *	ap = &sp->ttis[a];
		const struct ttinfo *	bp = &sp->ttis[b];
		result = ap->tt_gmtoff == bp->tt_gmtoff &&
		    ap->tt_isdst == bp->tt_isdst &&
		    ap->tt_ttisstd == bp->tt_ttisstd &&
		    ap->tt_ttisgmt == bp->tt_ttisgmt &&
		    strcmp(&sp->chars[ap->tt_abbrind],
		    &sp->chars[bp->tt_abbrind]) == 0;
	}
	return result;
}

static const int	mon_lengths[2][MONSPERYEAR] = {
	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
};

static const int	year_lengths[2] = {
	DAYSPERNYEAR, DAYSPERLYEAR
};

/*
** Given a pointer into a time zone string, scan until a character that is not
** a valid character in a zone name is found. Return a pointer to that
** character.
*/

static const char *
getzname(const char *strp)
{
	char	c;

	while ((c = *strp) != '\0' && !isdigit((unsigned char)c) && c != ',' && c != '-' &&
	    c != '+')
		++strp;
	return strp;
}

/*
** Given a pointer into an extended time zone string, scan until the ending
** delimiter of the zone name is located. Return a pointer to the delimiter.
**
** As with getzname above, the legal character set is actually quite
** restricted, with other characters producing undefined results.
** We don't do any checking here; checking is done later in common-case code.
*/

static const char *
getqzname(const char *strp, const int delim)
{
	int	c;

	while ((c = *strp) != '\0' && c != delim)
		++strp;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a number from that string.
** Check that the number is within a specified range; if it is not, return
** NULL.
** Otherwise, return a pointer to the first character not part of the number.
*/

static const char *
getnum(const char *strp, int *nump, int min, int max)
{
	char	c;
	int	num;

	if (strp == NULL || !isdigit((unsigned char)(c = *strp)))
		return NULL;
	num = 0;
	do {
		num = num * 10 + (c - '0');
		if (num > max)
			return NULL;	/* illegal value */
		c = *++strp;
	} while (isdigit((unsigned char)c));
	if (num < min)
		return NULL;		/* illegal value */
	*nump = num;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a number of seconds,
** in hh[:mm[:ss]] form, from the string.
** If any error occurs, return NULL.
** Otherwise, return a pointer to the first character not part of the number
** of seconds.
*/

static const char *
getsecs(const char *strp, long *secsp)
{
	int	num;

	/*
	** `HOURSPERDAY * DAYSPERWEEK - 1' allows quasi-Posix rules like
	** "M10.4.6/26", which does not conform to Posix,
	** but which specifies the equivalent of
	** ``02:00 on the first Sunday on or after 23 Oct''.
	*/
	strp = getnum(strp, &num, 0, HOURSPERDAY * DAYSPERWEEK - 1);
	if (strp == NULL)
		return NULL;
	*secsp = num * (long) SECSPERHOUR;
	if (*strp == ':') {
		++strp;
		strp = getnum(strp, &num, 0, MINSPERHOUR - 1);
		if (strp == NULL)
			return NULL;
		*secsp += num * SECSPERMIN;
		if (*strp == ':') {
			++strp;
			/* `SECSPERMIN' allows for leap seconds. */
			strp = getnum(strp, &num, 0, SECSPERMIN);
			if (strp == NULL)
				return NULL;
			*secsp += num;
		}
	}
	return strp;
}

/*
** Given a pointer into a time zone string, extract an offset, in
** [+-]hh[:mm[:ss]] form, from the string.
** If any error occurs, return NULL.
** Otherwise, return a pointer to the first character not part of the time.
*/

static const char *
getoffset(const char *strp, long *offsetp)
{
	int	neg = 0;

	if (*strp == '-') {
		neg = 1;
		++strp;
	} else if (*strp == '+')
		++strp;
	strp = getsecs(strp, offsetp);
	if (strp == NULL)
		return NULL;		/* illegal time */
	if (neg)
		*offsetp = -*offsetp;
	return strp;
}

/*
** Given a pointer into a time zone string, extract a rule in the form
** date[/time]. See POSIX section 8 for the format of "date" and "time".
** If a valid rule is not found, return NULL.
** Otherwise, return a pointer to the first character not part of the rule.
*/

static const char *
getrule(const char *strp, struct rule *rulep)
{
	if (*strp == 'J') {
		/*
		** Julian day.
		*/
		rulep->r_type = JULIAN_DAY;
		++strp;
		strp = getnum(strp, &rulep->r_day, 1, DAYSPERNYEAR);
	} else if (*strp == 'M') {
		/*
		** Month, week, day.
		*/
		rulep->r_type = MONTH_NTH_DAY_OF_WEEK;
		++strp;
		strp = getnum(strp, &rulep->r_mon, 1, MONSPERYEAR);
		if (strp == NULL)
			return NULL;
		if (*strp++ != '.')
			return NULL;
		strp = getnum(strp, &rulep->r_week, 1, 5);
		if (strp == NULL)
			return NULL;
		if (*strp++ != '.')
			return NULL;
		strp = getnum(strp, &rulep->r_day, 0, DAYSPERWEEK - 1);
	} else if (isdigit((unsigned char)*strp)) {
		/*
		** Day of year.
		*/
		rulep->r_type = DAY_OF_YEAR;
		strp = getnum(strp, &rulep->r_day, 0, DAYSPERLYEAR - 1);
	} else
		return NULL;		/* invalid format */
	if (strp == NULL)
		return NULL;
	if (*strp == '/') {
		/*
		** Time specified.
		*/
		++strp;
		strp = getsecs(strp, &rulep->r_time);
	} else
		rulep->r_time = 2 * SECSPERHOUR;	/* default = 2:00:00 */
	return strp;
}

/*
** Given the Epoch-relative time of January 1, 00:00:00 UTC, in a year, the
** year, a rule, and the offset from UTC at the time that rule takes effect,
** calculate the Epoch-relative time that rule takes effect.
*/

static time_t
transtime(time_t janfirst, int year, const struct rule *rulep, long offset)
{
	int	leapyear;
	time_t	value;
	int	i;
	int		d, m1, yy0, yy1, yy2, dow;

	value = 0;
	leapyear = isleap(year);
	switch (rulep->r_type) {

	case JULIAN_DAY:
		/*
		** Jn - Julian day, 1 == January 1, 60 == March 1 even in leap
		** years.
		** In non-leap years, or if the day number is 59 or less, just
		** add SECSPERDAY times the day number-1 to the time of
		** January 1, midnight, to get the day.
		*/
		value = janfirst + (rulep->r_day - 1) * SECSPERDAY;
		if (leapyear && rulep->r_day >= 60)
			value += SECSPERDAY;
		break;

	case DAY_OF_YEAR:
		/*
		** n - day of year.
		** Just add SECSPERDAY times the day number to the time of
		** January 1, midnight, to get the day.
		*/
		value = janfirst + rulep->r_day * SECSPERDAY;
		break;

	case MONTH_NTH_DAY_OF_WEEK:
		/*
		** Mm.n.d - nth "dth day" of month m.
		*/
		value = janfirst;
		for (i = 0; i < rulep->r_mon - 1; ++i)
			value += mon_lengths[leapyear][i] * SECSPERDAY;

		/*
		** Use Zeller's Congruence to get day-of-week of first day of
		** month.
		*/
		m1 = (rulep->r_mon + 9) % 12 + 1;
		yy0 = (rulep->r_mon <= 2) ? (year - 1) : year;
		yy1 = yy0 / 100;
		yy2 = yy0 % 100;
		dow = ((26 * m1 - 2) / 10 +
		    1 + yy2 + yy2 / 4 + yy1 / 4 - 2 * yy1) % 7;
		if (dow < 0)
			dow += DAYSPERWEEK;

		/*
		** "dow" is the day-of-week of the first day of the month. Get
		** the day-of-month (zero-origin) of the first "dow" day of the
		** month.
		*/
		d = rulep->r_day - dow;
		if (d < 0)
			d += DAYSPERWEEK;
		for (i = 1; i < rulep->r_week; ++i) {
			if (d + DAYSPERWEEK >=
			    mon_lengths[leapyear][rulep->r_mon - 1])
				break;
			d += DAYSPERWEEK;
		}

		/*
		** "d" is the day-of-month (zero-origin) of the day we want.
		*/
		value += d * SECSPERDAY;
		break;
	}

	/*
	** "value" is the Epoch-relative time of 00:00:00 UTC on the day in
	** question. To get the Epoch-relative time of the specified local
	** time on that day, add the transition time and the current offset
	** from UTC.
	*/
	return value + rulep->r_time + offset;
}

/*
** Given a POSIX section 8-style TZ string, fill in the rule tables as
** appropriate.
*/

static int
tzparse(const char *name, struct state *sp, int lastditch)
{
	const char *			stdname;
	const char *			dstname;
	size_t				stdlen;
	size_t				dstlen;
	long				stdoffset;
	long				dstoffset;
	time_t *		atp;
	unsigned char *	typep;
	char *			cp;
	int			load_result;
	static struct ttinfo		zttinfo;

	dstname = NULL;
	stdname = name;
	if (lastditch) {
		stdlen = strlen(name);	/* length of standard zone name */
		name += stdlen;
		if (stdlen >= sizeof sp->chars)
			stdlen = (sizeof sp->chars) - 1;
		stdoffset = 0;
	} else {
		if (*name == '<') {
			name++;
			stdname = name;
			name = getqzname(name, '>');
			if (*name != '>')
				return (-1);
			stdlen = name - stdname;
			name++;
		} else {
			name = getzname(name);
			stdlen = name - stdname;
		}
		if (*name == '\0')
			return -1;
		name = getoffset(name, &stdoffset);
		if (name == NULL)
			return -1;
	}
	load_result = tzload(TZDEFRULES, sp, FALSE);
	if (load_result != 0)
		sp->leapcnt = 0;		/* so, we're off a little */
	if (*name != '\0') {
		if (*name == '<') {
			dstname = ++name;
			name = getqzname(name, '>');
			if (*name != '>')
				return -1;
			dstlen = name - dstname;
			name++;
		} else {
			dstname = name;
			name = getzname(name);
			dstlen = name - dstname; /* length of DST zone name */
		}
		if (*name != '\0' && *name != ',' && *name != ';') {
			name = getoffset(name, &dstoffset);
			if (name == NULL)
				return -1;
		} else
			dstoffset = stdoffset - SECSPERHOUR;
		if (*name == '\0' && load_result != 0)
			name = TZDEFRULESTRING;
		if (*name == ',' || *name == ';') {
			struct rule	start;
			struct rule	end;
			int		year;
			time_t		janfirst;
			time_t		starttime;
			time_t		endtime;

			++name;
			if ((name = getrule(name, &start)) == NULL)
				return -1;
			if (*name++ != ',')
				return -1;
			if ((name = getrule(name, &end)) == NULL)
				return -1;
			if (*name != '\0')
				return -1;
			sp->typecnt = 2;	/* standard time and DST */
			/*
			** Two transitions per year, from EPOCH_YEAR forward.
			*/
			sp->ttis[0] = sp->ttis[1] = zttinfo;
			sp->ttis[0].tt_gmtoff = -dstoffset;
			sp->ttis[0].tt_isdst = 1;
			sp->ttis[0].tt_abbrind = stdlen + 1;
			sp->ttis[1].tt_gmtoff = -stdoffset;
			sp->ttis[1].tt_isdst = 0;
			sp->ttis[1].tt_abbrind = 0;
			atp = sp->ats;
			typep = sp->types;
			janfirst = 0;
			sp->timecnt = 0;
			for (year = EPOCH_YEAR;
			    sp->timecnt + 2 <= TZ_MAX_TIMES;
			    ++year) {
			    	time_t	newfirst;

				starttime = transtime(janfirst, year, &start,
				    stdoffset);
				endtime = transtime(janfirst, year, &end,
				    dstoffset);
				if (starttime > endtime) {
					*atp++ = endtime;
					*typep++ = 1;	/* DST ends */
					*atp++ = starttime;
					*typep++ = 0;	/* DST begins */
				} else {
					*atp++ = starttime;
					*typep++ = 0;	/* DST begins */
					*atp++ = endtime;
					*typep++ = 1;	/* DST ends */
				}
				sp->timecnt += 2;
				newfirst = janfirst;
				newfirst += year_lengths[isleap(year)] *
				    SECSPERDAY;
				if (newfirst <= janfirst)
					break;
				janfirst = newfirst;
			}
		} else {
			long	theirstdoffset;
			long	theirdstoffset;
			long	theiroffset;
			int	isdst;
			int	i;
			int	j;

			if (*name != '\0')
				return -1;
			/*
			** Initial values of theirstdoffset and theirdstoffset.
			*/
			theirstdoffset = 0;
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				if (!sp->ttis[j].tt_isdst) {
					theirstdoffset =
						-sp->ttis[j].tt_gmtoff;
					break;
				}
			}
			theirdstoffset = 0;
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				if (sp->ttis[j].tt_isdst) {
					theirdstoffset =
						-sp->ttis[j].tt_gmtoff;
					break;
				}
			}
			/*
			** Initially we're assumed to be in standard time.
			*/
			isdst = FALSE;
			theiroffset = theirstdoffset;
			/*
			** Now juggle transition times and types
			** tracking offsets as you do.
			*/
			for (i = 0; i < sp->timecnt; ++i) {
				j = sp->types[i];
				sp->types[i] = sp->ttis[j].tt_isdst;
				if (sp->ttis[j].tt_ttisgmt) {
					/* No adjustment to transition time */
				} else {
					/*
					** If summer time is in effect, and the
					** transition time was not specified as
					** standard time, add the summer time
					** offset to the transition time;
					** otherwise, add the standard time
					** offset to the transition time.
					*/
					/*
					** Transitions from DST to DDST
					** will effectively disappear since
					** POSIX provides for only one DST
					** offset.
					*/
					if (isdst && !sp->ttis[j].tt_ttisstd) {
						sp->ats[i] += dstoffset -
						    theirdstoffset;
					} else {
						sp->ats[i] += stdoffset -
						    theirstdoffset;
					}
				}
				theiroffset = -sp->ttis[j].tt_gmtoff;
				if (sp->ttis[j].tt_isdst)
					theirdstoffset = theiroffset;
				else
					theirstdoffset = theiroffset;
			}
			/*
			** Finally, fill in ttis.
			*/
			sp->ttis[0] = sp->ttis[1] = zttinfo;
			sp->ttis[0].tt_gmtoff = -stdoffset;
			sp->ttis[0].tt_isdst = FALSE;
			sp->ttis[0].tt_abbrind = 0;
			sp->ttis[1].tt_gmtoff = -dstoffset;
			sp->ttis[1].tt_isdst = TRUE;
			sp->ttis[1].tt_abbrind = stdlen + 1;
			sp->typecnt = 2;
		}
	} else {
		dstlen = 0;
		sp->typecnt = 1;		/* only standard time */
		sp->timecnt = 0;
		sp->ttis[0] = zttinfo;
		sp->ttis[0].tt_gmtoff = -stdoffset;
		sp->ttis[0].tt_isdst = 0;
		sp->ttis[0].tt_abbrind = 0;
	}
	sp->charcnt = stdlen + 1;
	if (dstlen != 0)
		sp->charcnt += dstlen + 1;
	if ((size_t) sp->charcnt > sizeof sp->chars)
		return -1;
	cp = sp->chars;
	strlcpy(cp, stdname, stdlen + 1);
	cp += stdlen + 1;
	if (dstlen != 0) {
		strlcpy(cp, dstname, dstlen + 1);
	}
	return 0;
}

static void
gmtload(struct state *sp)
{
	if (tzload(gmt, sp, TRUE) != 0)
		(void) tzparse(gmt, sp, TRUE);
}

static void
tzsetwall_basic(void)
{
	if (lcl_is_set < 0)
		return;
	lcl_is_set = -1;

	if (lclptr == NULL) {
		lclptr = calloc(1, sizeof *lclptr);
		if (lclptr == NULL) {
			settzname();	/* all we can do */
			return;
		}
	}
	if (tzload(NULL, lclptr, TRUE) != 0)
		gmtload(lclptr);
	settzname();
}

#ifndef STD_INSPIRED
/*
** A non-static declaration of tzsetwall in a system header file
** may cause a warning about this upcoming static declaration...
*/
static
#endif /* !defined STD_INSPIRED */
void
tzsetwall(void)
{
	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzsetwall_basic();
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
}

static void
tzset_basic(void)
{
	const char *	name;

	name = getenv("TZ");
	if (name == NULL) {
		tzsetwall_basic();
		return;
	}

	if (lcl_is_set > 0 && strcmp(lcl_TZname, name) == 0)
		return;
	lcl_is_set = strlen(name) < sizeof lcl_TZname;
	if (lcl_is_set)
		strlcpy(lcl_TZname, name, sizeof lcl_TZname);

	if (lclptr == NULL) {
		lclptr = calloc(1, sizeof *lclptr);
		if (lclptr == NULL) {
			settzname();	/* all we can do */
			return;
		}
	}
	if (*name == '\0') {
		/*
		** User wants it fast rather than right.
		*/
		lclptr->leapcnt = 0;		/* so, we're off a little */
		lclptr->timecnt = 0;
		lclptr->typecnt = 0;
		lclptr->ttis[0].tt_isdst = 0;
		lclptr->ttis[0].tt_gmtoff = 0;
		lclptr->ttis[0].tt_abbrind = 0;
		strlcpy(lclptr->chars, gmt, sizeof lclptr->chars);
	} else if (tzload(name, lclptr, TRUE) != 0) {
		if (name[0] == ':' || tzparse(name, lclptr, FALSE) != 0)
			gmtload(lclptr);
	}
	settzname();
}

void
tzset(void)
{
	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzset_basic();
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
}
DEF_WEAK(tzset);

/*
** The easy way to behave "as if no library function calls" localtime
** is to not call it--so we drop its guts into "localsub", which can be
** freely called. (And no, the PANS doesn't require the above behavior--
** but it *is* desirable.)
**
** The unused offset argument is for the benefit of mktime variants.
*/

static struct tm *
localsub(const time_t *timep, long offset, struct tm *tmp)
{
	struct state *		sp;
	const struct ttinfo *	ttisp;
	int			i;
	struct tm *		result;
	const time_t			t = *timep;

	sp = lclptr;
	if (sp == NULL)
		return gmtsub(timep, offset, tmp);
	if ((sp->goback && t < sp->ats[0]) ||
	    (sp->goahead && t > sp->ats[sp->timecnt - 1])) {
		time_t			newt = t;
		time_t		seconds;
		time_t		tcycles;
		int_fast64_t	icycles;

		if (t < sp->ats[0])
			seconds = sp->ats[0] - t;
		else
			seconds = t - sp->ats[sp->timecnt - 1];
		--seconds;
		tcycles = seconds / YEARSPERREPEAT / AVGSECSPERYEAR;
		++tcycles;
		icycles = tcycles;
		if (tcycles - icycles >= 1 || icycles - tcycles >= 1)
			return NULL;
		seconds = icycles;
		seconds *= YEARSPERREPEAT;
		seconds *= AVGSECSPERYEAR;
		if (t < sp->ats[0])
			newt += seconds;
		else
			newt -= seconds;
		if (newt < sp->ats[0] ||
		    newt > sp->ats[sp->timecnt - 1])
			return NULL;	/* "cannot happen" */
		result = localsub(&newt, offset, tmp);
		if (result == tmp) {
			time_t	newy;

			newy = tmp->tm_year;
			if (t < sp->ats[0])
				newy -= icycles * YEARSPERREPEAT;
			else
				newy += icycles * YEARSPERREPEAT;
			tmp->tm_year = newy;
			if (tmp->tm_year != newy)
				return NULL;
		}
		return result;
	}
	if (sp->timecnt == 0 || t < sp->ats[0]) {
		i = 0;
		while (sp->ttis[i].tt_isdst) {
			if (++i >= sp->typecnt) {
				i = 0;
				break;
			}
		}
	} else {
		int	lo = 1;
		int	hi = sp->timecnt;

		while (lo < hi) {
			int	mid = (lo + hi) >> 1;

			if (t < sp->ats[mid])
				hi = mid;
			else
				lo = mid + 1;
		}
		i = (int) sp->types[lo - 1];
	}
	ttisp = &sp->ttis[i];
	/*
	** To get (wrong) behavior that's compatible with System V Release 2.0
	** you'd replace the statement below with
	**	t += ttisp->tt_gmtoff;
	**	timesub(&t, 0L, sp, tmp);
	*/
	result = timesub(&t, ttisp->tt_gmtoff, sp, tmp);
	tmp->tm_isdst = ttisp->tt_isdst;
	tzname[tmp->tm_isdst] = &sp->chars[ttisp->tt_abbrind];
#ifdef TM_ZONE
	tmp->TM_ZONE = &sp->chars[ttisp->tt_abbrind];
#endif /* defined TM_ZONE */
	return result;
}

/*
** Re-entrant version of localtime.
*/

struct tm *
localtime_r(const time_t *timep, struct tm *p_tm)
{
	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzset_basic();
	p_tm = localsub(timep, 0L, p_tm);
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
	return p_tm;
}
DEF_WEAK(localtime_r);

struct tm *
localtime(const time_t *timep)
{
	_THREAD_PRIVATE_KEY(localtime);
	struct tm * p_tm = (struct tm*)_THREAD_PRIVATE(localtime, tm, NULL);

	if (p_tm == NULL)
		return NULL;
	return localtime_r(timep, p_tm);
}
DEF_STRONG(localtime);

/*
** gmtsub is to gmtime as localsub is to localtime.
*/

static struct tm *
gmtsub(const time_t *timep, long offset, struct tm *tmp)
{
	struct tm *	result;

	_THREAD_PRIVATE_MUTEX_LOCK(gmt);
	if (!gmt_is_set) {
		gmt_is_set = TRUE;
		gmtptr = calloc(1, sizeof(*gmtptr));
		if (gmtptr != NULL)
			gmtload(gmtptr);
	}
	_THREAD_PRIVATE_MUTEX_UNLOCK(gmt);
	result = timesub(timep, offset, gmtptr, tmp);
#ifdef TM_ZONE
	/*
	** Could get fancy here and deliver something such as
	** "UTC+xxxx" or "UTC-xxxx" if offset is non-zero,
	** but this is no time for a treasure hunt.
	*/
	if (offset != 0)
		tmp->TM_ZONE = wildabbr;
	else {
		if (gmtptr == NULL)
			tmp->TM_ZONE = (char *)gmt;
		else
			tmp->TM_ZONE = gmtptr->chars;
	}
#endif /* defined TM_ZONE */
	return result;
}

/*
** Re-entrant version of gmtime.
*/

struct tm *
gmtime_r(const time_t *timep, struct tm *p_tm)
{
	return gmtsub(timep, 0L, p_tm);
}
DEF_WEAK(gmtime_r);

struct tm *
gmtime(const time_t *timep)
{
	_THREAD_PRIVATE_KEY(gmtime);
	struct tm * p_tm = (struct tm*) _THREAD_PRIVATE(gmtime, tm, NULL);

	if (p_tm == NULL)
		return NULL;
	return gmtime_r(timep, p_tm);

}
DEF_WEAK(gmtime);

#ifdef STD_INSPIRED

struct tm *
offtime(const time_t *timep, long offset)
{
	return gmtsub(timep, offset, &tm);
}

#endif /* defined STD_INSPIRED */

/*
** Return the number of leap years through the end of the given year
** where, to make the math easy, the answer for year zero is defined as zero.
*/

static int
leaps_thru_end_of(int y)
{
	return (y >= 0) ? (y / 4 - y / 100 + y / 400) :
		-(leaps_thru_end_of(-(y + 1)) + 1);
}

static struct tm *
timesub(const time_t *timep, long offset, const struct state *sp, struct tm *tmp)
{
	const struct lsinfo *	lp;
	time_t			tdays;
	int			idays;	/* unsigned would be so 2003 */
	long			rem;
	int			y;
	const int *		ip;
	long			corr;
	int			hit;
	int			i;
	long			seconds;

	corr = 0;
	hit = 0;
	i = (sp == NULL) ? 0 : sp->leapcnt;
	while (--i >= 0) {
		lp = &sp->lsis[i];
		if (*timep >= lp->ls_trans) {
			if (*timep == lp->ls_trans) {
				hit = ((i == 0 && lp->ls_corr > 0) ||
				    lp->ls_corr > sp->lsis[i - 1].ls_corr);
				if (hit) {
					while (i > 0 &&
					    sp->lsis[i].ls_trans ==
					    sp->lsis[i - 1].ls_trans + 1 &&
					    sp->lsis[i].ls_corr ==
					    sp->lsis[i - 1].ls_corr + 1) {
						++hit;
						--i;
					}
				}
			}
			corr = lp->ls_corr;
			break;
		}
	}
	y = EPOCH_YEAR;
	tdays = *timep / SECSPERDAY;
	rem = *timep - tdays * SECSPERDAY;
	while (tdays < 0 || tdays >= year_lengths[isleap(y)]) {
		int		newy;
		time_t	tdelta;
		int	idelta;
		int	leapdays;

		tdelta = tdays / DAYSPERLYEAR;
		idelta = tdelta;
		if (tdelta - idelta >= 1 || idelta - tdelta >= 1)
			return NULL;
		if (idelta == 0)
			idelta = (tdays < 0) ? -1 : 1;
		newy = y;
		if (increment_overflow(&newy, idelta))
			return NULL;
		leapdays = leaps_thru_end_of(newy - 1) -
			leaps_thru_end_of(y - 1);
		tdays -= ((time_t) newy - y) * DAYSPERNYEAR;
		tdays -= leapdays;
		y = newy;
	}

	seconds = tdays * SECSPERDAY + 0.5;
	tdays = seconds / SECSPERDAY;
	rem += seconds - tdays * SECSPERDAY;

	/*
	** Given the range, we can now fearlessly cast...
	*/
	idays = tdays;
	rem += offset - corr;
	while (rem < 0) {
		rem += SECSPERDAY;
		--idays;
	}
	while (rem >= SECSPERDAY) {
		rem -= SECSPERDAY;
		++idays;
	}
	while (idays < 0) {
		if (increment_overflow(&y, -1))
			return NULL;
		idays += year_lengths[isleap(y)];
	}
	while (idays >= year_lengths[isleap(y)]) {
		idays -= year_lengths[isleap(y)];
		if (increment_overflow(&y, 1))
			return NULL;
	}
	tmp->tm_year = y;
	if (increment_overflow(&tmp->tm_year, -TM_YEAR_BASE))
		return NULL;
	tmp->tm_yday = idays;
	/*
	** The "extra" mods below avoid overflow problems.
	*/
	tmp->tm_wday = EPOCH_WDAY +
	    ((y - EPOCH_YEAR) % DAYSPERWEEK) *
	    (DAYSPERNYEAR % DAYSPERWEEK) +
	    leaps_thru_end_of(y - 1) -
	    leaps_thru_end_of(EPOCH_YEAR - 1) +
	    idays;
	tmp->tm_wday %= DAYSPERWEEK;
	if (tmp->tm_wday < 0)
		tmp->tm_wday += DAYSPERWEEK;
	tmp->tm_hour = (int) (rem / SECSPERHOUR);
	rem %= SECSPERHOUR;
	tmp->tm_min = (int) (rem / SECSPERMIN);
	/*
	** A positive leap second requires a special
	** representation. This uses "... ??:59:60" et seq.
	*/
	tmp->tm_sec = (int) (rem % SECSPERMIN) + hit;
	ip = mon_lengths[isleap(y)];
	for (tmp->tm_mon = 0; idays >= ip[tmp->tm_mon]; ++(tmp->tm_mon))
		idays -= ip[tmp->tm_mon];
	tmp->tm_mday = (int) (idays + 1);
	tmp->tm_isdst = 0;
#ifdef TM_GMTOFF
	tmp->TM_GMTOFF = offset;
#endif /* defined TM_GMTOFF */
	return tmp;
}

char *
ctime(const time_t *timep)
{
/*
** Section 4.12.3.2 of X3.159-1989 requires that
**	The ctime function converts the calendar time pointed to by timer
**	to local time in the form of a string. It is equivalent to
**		asctime(localtime(timer))
*/
	return asctime(localtime(timep));
}

char *
ctime_r(const time_t *timep, char *buf)
{
	struct tm	mytm;

	return asctime_r(localtime_r(timep, &mytm), buf);
}

/*
** Adapted from code provided by Robert Elz, who writes:
**	The "best" way to do mktime I think is based on an idea of Bob
**	Kridle's (so its said...) from a long time ago.
**	It does a binary search of the time_t space. Since time_t's are
**	just 32 bits, its a max of 32 iterations (even at 64 bits it
**	would still be very reasonable).
*/

#ifndef WRONG
#define WRONG	(-1)
#endif /* !defined WRONG */

/*
** Normalize logic courtesy Paul Eggert.
*/

static int
increment_overflow(int *ip, int j)
{
	int const	i = *ip;

	/*
	** If i >= 0 there can only be overflow if i + j > INT_MAX
	** or if j > INT_MAX - i; given i >= 0, INT_MAX - i cannot overflow.
	** If i < 0 there can only be overflow if i + j < INT_MIN
	** or if j < INT_MIN - i; given i < 0, INT_MIN - i cannot overflow.
	*/
	if ((i >= 0) ? (j > INT_MAX - i) : (j < INT_MIN - i))
		return TRUE;
	*ip += j;
	return FALSE;
}

static int
long_increment_overflow(long *lp, int m)
{
	long const	l = *lp;

	if ((l >= 0) ? (m > LONG_MAX - l) : (m < LONG_MIN - l))
		return TRUE;
	*lp += m;
	return FALSE;
}

static int
normalize_overflow(int *tensptr, int *unitsptr, int base)
{
	int	tensdelta;

	tensdelta = (*unitsptr >= 0) ?
	    (*unitsptr / base) :
	    (-1 - (-1 - *unitsptr) / base);
	*unitsptr -= tensdelta * base;
	return increment_overflow(tensptr, tensdelta);
}

static int
long_normalize_overflow(long *tensptr, int *unitsptr, int base)
{
	int	tensdelta;

	tensdelta = (*unitsptr >= 0) ?
	    (*unitsptr / base) :
	    (-1 - (-1 - *unitsptr) / base);
	*unitsptr -= tensdelta * base;
	return long_increment_overflow(tensptr, tensdelta);
}

static int
tmcomp(const struct tm *atmp, const struct tm *btmp)
{
	int	result;

	if ((result = (atmp->tm_year - btmp->tm_year)) == 0 &&
	    (result = (atmp->tm_mon - btmp->tm_mon)) == 0 &&
	    (result = (atmp->tm_mday - btmp->tm_mday)) == 0 &&
	    (result = (atmp->tm_hour - btmp->tm_hour)) == 0 &&
	    (result = (atmp->tm_min - btmp->tm_min)) == 0)
		result = atmp->tm_sec - btmp->tm_sec;
	return result;
}

static time_t
time2sub(struct tm *tmp, struct tm *(*funcp)(const time_t *, long, struct tm *),
    long offset, int *okayp, int do_norm_secs)
{
	const struct state *	sp;
	int			dir;
	int			i, j;
	int			saved_seconds;
	long			li;
	time_t			lo;
	time_t			hi;
	long			y;
	time_t			newt;
	time_t			t;
	struct tm		yourtm, mytm;

	*okayp = FALSE;
	yourtm = *tmp;
	if (do_norm_secs) {
		if (normalize_overflow(&yourtm.tm_min, &yourtm.tm_sec,
			SECSPERMIN))
				return WRONG;
	}
	if (normalize_overflow(&yourtm.tm_hour, &yourtm.tm_min, MINSPERHOUR))
		return WRONG;
	if (normalize_overflow(&yourtm.tm_mday, &yourtm.tm_hour, HOURSPERDAY))
		return WRONG;
	y = yourtm.tm_year;
	if (long_normalize_overflow(&y, &yourtm.tm_mon, MONSPERYEAR))
		return WRONG;
	/*
	** Turn y into an actual year number for now.
	** It is converted back to an offset from TM_YEAR_BASE later.
	*/
	if (long_increment_overflow(&y, TM_YEAR_BASE))
		return WRONG;
	while (yourtm.tm_mday <= 0) {
		if (long_increment_overflow(&y, -1))
			return WRONG;
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday += year_lengths[isleap(li)];
	}
	while (yourtm.tm_mday > DAYSPERLYEAR) {
		li = y + (1 < yourtm.tm_mon);
		yourtm.tm_mday -= year_lengths[isleap(li)];
		if (long_increment_overflow(&y, 1))
			return WRONG;
	}
	for ( ; ; ) {
		i = mon_lengths[isleap(y)][yourtm.tm_mon];
		if (yourtm.tm_mday <= i)
			break;
		yourtm.tm_mday -= i;
		if (++yourtm.tm_mon >= MONSPERYEAR) {
			yourtm.tm_mon = 0;
			if (long_increment_overflow(&y, 1))
				return WRONG;
		}
	}
	if (long_increment_overflow(&y, -TM_YEAR_BASE))
		return WRONG;
	yourtm.tm_year = y;
	if (yourtm.tm_year != y)
		return WRONG;
	if (yourtm.tm_sec >= 0 && yourtm.tm_sec < SECSPERMIN)
		saved_seconds = 0;
	else if (y + TM_YEAR_BASE < EPOCH_YEAR) {
		/*
		** We can't set tm_sec to 0, because that might push the
		** time below the minimum representable time.
		** Set tm_sec to 59 instead.
		** This assumes that the minimum representable time is
		** not in the same minute that a leap second was deleted from,
		** which is a safer assumption than using 58 would be.
		*/
		if (increment_overflow(&yourtm.tm_sec, 1 - SECSPERMIN))
			return WRONG;
		saved_seconds = yourtm.tm_sec;
		yourtm.tm_sec = SECSPERMIN - 1;
	} else {
		saved_seconds = yourtm.tm_sec;
		yourtm.tm_sec = 0;
	}
	/*
	** Do a binary search (this works whatever time_t's type is).
	*/
	lo = 1;
	for (i = 0; i < (int) TYPE_BIT(time_t) - 1; ++i)
		lo *= 2;
	hi = -(lo + 1);
	for ( ; ; ) {
		t = lo / 2 + hi / 2;
		if (t < lo)
			t = lo;
		else if (t > hi)
			t = hi;
		if ((*funcp)(&t, offset, &mytm) == NULL) {
			/*
			** Assume that t is too extreme to be represented in
			** a struct tm; arrange things so that it is less
			** extreme on the next pass.
			*/
			dir = (t > 0) ? 1 : -1;
		} else
			dir = tmcomp(&mytm, &yourtm);
		if (dir != 0) {
			if (t == lo) {
				++t;
				if (t <= lo)
					return WRONG;
				++lo;
			} else if (t == hi) {
				--t;
				if (t >= hi)
					return WRONG;
				--hi;
			}
			if (lo > hi)
				return WRONG;
			if (dir > 0)
				hi = t;
			else
				lo = t;
			continue;
		}
		if (yourtm.tm_isdst < 0 || mytm.tm_isdst == yourtm.tm_isdst)
			break;
		/*
		** Right time, wrong type.
		** Hunt for right time, right type.
		** It's okay to guess wrong since the guess
		** gets checked.
		*/
		sp = (const struct state *)
		    ((funcp == localsub) ? lclptr : gmtptr);
		if (sp == NULL)
			return WRONG;
		for (i = sp->typecnt - 1; i >= 0; --i) {
			if (sp->ttis[i].tt_isdst != yourtm.tm_isdst)
				continue;
			for (j = sp->typecnt - 1; j >= 0; --j) {
				if (sp->ttis[j].tt_isdst == yourtm.tm_isdst)
					continue;
				newt = t + sp->ttis[j].tt_gmtoff -
					sp->ttis[i].tt_gmtoff;
				if ((*funcp)(&newt, offset, &mytm) == NULL)
					continue;
				if (tmcomp(&mytm, &yourtm) != 0)
					continue;
				if (mytm.tm_isdst != yourtm.tm_isdst)
					continue;
				/*
				** We have a match.
				*/
				t = newt;
				goto label;
			}
		}
		return WRONG;
	}
label:
	newt = t + saved_seconds;
	if ((newt < t) != (saved_seconds < 0))
		return WRONG;
	t = newt;
	if ((*funcp)(&t, offset, tmp))
		*okayp = TRUE;
	return t;
}

static time_t
time2(struct tm *tmp, struct tm * (*funcp)(const time_t *, long, struct tm *),
    long offset, int *okayp)
{
	time_t	t;

	/*
	** First try without normalization of seconds
	** (in case tm_sec contains a value associated with a leap second).
	** If that fails, try with normalization of seconds.
	*/
	t = time2sub(tmp, funcp, offset, okayp, FALSE);
	return *okayp ? t : time2sub(tmp, funcp, offset, okayp, TRUE);
}

static time_t
time1(struct tm *tmp, struct tm * (*funcp)(const time_t *, long, struct tm *),
    long offset)
{
	time_t			t;
	const struct state *	sp;
	int			samei, otheri;
	int			sameind, otherind;
	int			i;
	int			nseen;
	int			seen[TZ_MAX_TYPES];
	int			types[TZ_MAX_TYPES];
	int			okay;

	if (tmp == NULL) {
		errno = EINVAL;
		return WRONG;
	}
	if (tmp->tm_isdst > 1)
		tmp->tm_isdst = 1;
	t = time2(tmp, funcp, offset, &okay);
#ifdef PCTS
	/*
	** PCTS code courtesy Grant Sullivan.
	*/
	if (okay)
		return t;
	if (tmp->tm_isdst < 0)
		tmp->tm_isdst = 0;	/* reset to std and try again */
#endif /* defined PCTS */
#ifndef PCTS
	if (okay || tmp->tm_isdst < 0)
		return t;
#endif /* !defined PCTS */
	/*
	** We're supposed to assume that somebody took a time of one type
	** and did some math on it that yielded a "struct tm" that's bad.
	** We try to divine the type they started from and adjust to the
	** type they need.
	*/
	sp = (const struct state *) ((funcp == localsub) ?  lclptr : gmtptr);
	if (sp == NULL)
		return WRONG;
	for (i = 0; i < sp->typecnt; ++i)
		seen[i] = FALSE;
	nseen = 0;
	for (i = sp->timecnt - 1; i >= 0; --i) {
		if (!seen[sp->types[i]]) {
			seen[sp->types[i]] = TRUE;
			types[nseen++] = sp->types[i];
		}
	}
	for (sameind = 0; sameind < nseen; ++sameind) {
		samei = types[sameind];
		if (sp->ttis[samei].tt_isdst != tmp->tm_isdst)
			continue;
		for (otherind = 0; otherind < nseen; ++otherind) {
			otheri = types[otherind];
			if (sp->ttis[otheri].tt_isdst == tmp->tm_isdst)
				continue;
			tmp->tm_sec += sp->ttis[otheri].tt_gmtoff -
			    sp->ttis[samei].tt_gmtoff;
			tmp->tm_isdst = !tmp->tm_isdst;
			t = time2(tmp, funcp, offset, &okay);
			if (okay)
				return t;
			tmp->tm_sec -= sp->ttis[otheri].tt_gmtoff -
			    sp->ttis[samei].tt_gmtoff;
			tmp->tm_isdst = !tmp->tm_isdst;
		}
	}
	return WRONG;
}

time_t
mktime(struct tm *tmp)
{
	time_t ret;

	_THREAD_PRIVATE_MUTEX_LOCK(lcl);
	tzset_basic();
	ret = time1(tmp, localsub, 0L);
	_THREAD_PRIVATE_MUTEX_UNLOCK(lcl);
	return ret;
}
DEF_STRONG(mktime);

#ifdef STD_INSPIRED

time_t
timelocal(struct tm *tmp)
{
	if (tmp != NULL)
		tmp->tm_isdst = -1;	/* in case it wasn't initialized */
	return mktime(tmp);
}

time_t
timegm(struct tm *tmp)
{
	if (tmp != NULL)
		tmp->tm_isdst = 0;
	return time1(tmp, gmtsub, 0L);
}

time_t
timeoff(struct tm *tmp, long offset)
{
	if (tmp != NULL)
		tmp->tm_isdst = 0;
	return time1(tmp, gmtsub, offset);
}

#endif /* defined STD_INSPIRED */

/*
** XXX--is the below the right way to conditionalize??
*/

#ifdef STD_INSPIRED

/*
** IEEE Std 1003.1-1988 (POSIX) legislates that 536457599
** shall correspond to "Wed Dec 31 23:59:59 UTC 1986", which
** is not the case if we are accounting for leap seconds.
** So, we provide the following conversion routines for use
** when exchanging timestamps with POSIX conforming systems.
*/

static long
leapcorr(time_t *timep)
{
	struct state *		sp;
	struct lsinfo *	lp;
	int			i;

	sp = lclptr;
	i = sp->leapcnt;
	while (--i >= 0) {
		lp = &sp->lsis[i];
		if (*timep >= lp->ls_trans)
			return lp->ls_corr;
	}
	return 0;
}

time_t
time2posix(time_t t)
{
	tzset();
	return t - leapcorr(&t);
}

time_t
posix2time(time_t t)
{
	time_t	x;
	time_t	y;

	tzset();
	/*
	** For a positive leap second hit, the result
	** is not unique. For a negative leap second
	** hit, the corresponding time doesn't exist,
	** so we return an adjacent second.
	*/
	x = t + leapcorr(&t);
	y = x - leapcorr(&x);
	if (y < t) {
		do {
			x++;
			y = x - leapcorr(&x);
		} while (y < t);
		if (t != y)
			return x - 1;
	} else if (y > t) {
		do {
			--x;
			y = x - leapcorr(&x);
		} while (y > t);
		if (t != y)
			return x + 1;
	}
	return x;
}

#endif /* defined STD_INSPIRED */
@


1.58
log
@Remove doaccess variable and access(2) call since this interfers with
applications like zdump(8) because pledge(2) doesn't allow access(2) to
/usr/share/zoneinfo.

millert@@ better described why this call can go away:

"This looks like an attempt to do access checks based on the real uid instead
of the effective uid.  Basically for setuid programs we don't want to allow a
user to set TZ to a path they should not be able to otherwise access.

However, we already have a check for issetugid() above so I think the doaccess
bits can just be removed and we can rely on open()."

After discussion with tb@@, deraadt@@ and millert@@, this was also OK'ed by them
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.57 2015/12/12 21:25:44 mmcc Exp $ */
d1353 1
a1353 2
	gmtsub(timep, 0L, p_tm);
	return p_tm;
@


1.57
log
@Remove calloc cast, give sizeof parens. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.56 2015/11/01 03:45:29 guenther Exp $ */
a330 1
	int			doaccess;
d348 1
a348 2
	doaccess = name[0] == '/';
	if (!doaccess) {
a355 5
		/*
		** Set doaccess if '.' (as in "../") shows up in name.
		*/
		if (strchr(name, '.') != NULL)
			doaccess = TRUE;
a357 2
	if (doaccess && access(name, R_OK) != 0)
		goto oops;
@


1.56
log
@delete old lint ARGSUSED comments
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.55 2015/10/24 18:13:18 guenther Exp $ */
d1331 1
a1331 1
		gmtptr = (struct state *) calloc(1, sizeof *gmtptr);
@


1.55
log
@Move #includes from private.h to the .c files that need them, getting rid of
several.  Switch from FILENAME_MAX to PATH_MAX (it's for open(), not fopen()).

ok deraadt@@ tedu@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.54 2015/09/19 04:02:21 guenther Exp $ */
a1199 1
/*ARGSUSED*/
@


1.54
log
@Don't wrap initialized variables: binutils appears to be mishandling them
on arm and m88k

problems with optind observed by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.53 2015/09/12 14:35:40 guenther Exp $ */
d13 1
d16 4
d332 1
a332 1
	char			fullname[FILENAME_MAX];
@


1.53
log
@Wrap <time.h> so that internal calls go direct and symbols not in C99 are weak
Add prototypes to localtime.c for offtime(), time2posix(), posix2time() to
	reduce noise with -Wmissing-prototypes
Eliminate unnecessary #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.52 2015/04/07 01:47:04 millert Exp $ */
d198 1
d200 1
@


1.52
log
@Remove obsolete timezone() function.
Add timezone and daylight symbols for XSI compatibility.
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.51 2015/02/16 17:51:48 tedu Exp $ */
d171 9
d198 1
d1182 1
d1299 1
d1311 1
d1359 1
d1372 1
d1894 1
@


1.51
log
@sprinkle braces around multi line statements
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.50 2015/02/16 17:44:03 tedu Exp $ */
d201 1
a201 1
time_t			timezone = 0;
@


1.50
log
@pull scopes without conditionals up into enclosing block
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.49 2015/02/16 17:35:38 tedu Exp $ */
d274 1
a274 1
	for (i = 0; i < sp->charcnt; ++i)
d277 1
d322 1
a322 1
	if (name != NULL && issetugid() != 0)
d326 1
d415 1
a415 1
				detzcode(p) : detzcode64(p);
d510 1
a510 1
		for (i = 1; i < sp->timecnt; ++i)
d516 2
a517 1
		for (i = sp->timecnt - 2; i >= 0; --i)
d525 1
d1158 1
a1158 1
	} else if (tzload(name, lclptr, TRUE) != 0)
d1161 1
d1239 1
a1239 1
		while (sp->ttis[i].tt_isdst)
d1244 1
d1404 1
a1404 1
				if (hit)
d1413 1
d1743 1
a1743 1
			((funcp == localsub) ? lclptr : gmtptr);
d1840 1
a1840 1
	for (i = sp->timecnt - 1; i >= 0; --i)
d1845 1
@


1.49
log
@knf indents to give me a fighting chance at differentiating new blocks
from continuation lines, of which there are many
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.48 2015/02/16 17:11:54 tedu Exp $ */
d313 2
a326 10
	{
		int	doaccess;
		/*
		** Section 4.9.1 of the C standard says that
		** "FILENAME_MAX expands to an integral constant expression
		** that is the size needed for an array of char large enough
		** to hold the longest file name string that the implementation
		** guarantees can be opened."
		*/
		char		fullname[FILENAME_MAX];
d328 5
a332 19
		if (name[0] == ':')
			++name;
		doaccess = name[0] == '/';
		if (!doaccess) {
			if ((p = TZDIR) == NULL)
				goto oops;
			if ((strlen(p) + strlen(name) + 1) >= sizeof fullname)
				goto oops;
			strlcpy(fullname, p, sizeof fullname);
			strlcat(fullname, "/", sizeof fullname);
			strlcat(fullname, name, sizeof fullname);
			/*
			** Set doaccess if '.' (as in "../") shows up in name.
			*/
			if (strchr(name, '.') != NULL)
				doaccess = TRUE;
			name = fullname;
		}
		if (doaccess && access(name, R_OK) != 0)
d334 1
a334 1
		if ((fid = open(name, O_RDONLY)) == -1)
d336 9
d346 5
d1382 1
a1382 1
	int				y;
d1387 1
a1435 2
	{
		long	seconds;
d1437 4
a1440 4
		seconds = tdays * SECSPERDAY + 0.5;
		tdays = seconds / SECSPERDAY;
		rem += seconds - tdays * SECSPERDAY;
	}
@


1.48
log
@drop an ansi bomb on the function definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.47 2015/02/10 00:46:27 tedu Exp $ */
d104 1
a104 1
				(2 * (MY_TZNAME_MAX + 1)))];
d256 1
a256 2
		const struct ttinfo * const	ttisp =
			&sp->ttis[sp->types[i]];
d258 1
a258 2
		tzname[ttisp->tt_isdst] =
			&sp->chars[ttisp->tt_abbrind];
d281 2
a282 2
		const struct ttinfo * const	ttisp = &sp->ttis[i];
		char *				cp = &sp->chars[ttisp->tt_abbrind];
d285 2
a286 2
			strcmp(cp, GRANDPARENTED) != 0)
				*(cp + TZ_ABBR_MAX_LEN) = '\0';
d294 1
a294 1
			return 0;
d309 2
a310 2
					2 * sizeof *sp +
					4 * TZ_MAX_TIMES];
d374 6
a379 6
			sp->typecnt <= 0 || sp->typecnt > TZ_MAX_TYPES ||
			sp->timecnt < 0 || sp->timecnt > TZ_MAX_TIMES ||
			sp->charcnt < 0 || sp->charcnt > TZ_MAX_CHARS ||
			(ttisstdcnt != sp->typecnt && ttisstdcnt != 0) ||
			(ttisgmtcnt != sp->typecnt && ttisgmtcnt != 0))
				goto oops;
d381 8
a388 8
			sp->timecnt * stored +		/* ats */
			sp->timecnt +			/* types */
			sp->typecnt * 6 +		/* ttinfos */
			sp->charcnt +			/* chars */
			sp->leapcnt * (stored + 4) +	/* lsinfos */
			ttisstdcnt +			/* ttisstds */
			ttisgmtcnt)			/* ttisgmts */
				goto oops;
d391 1
a391 1
				detzcode(p) : detzcode64(p);
d410 2
a411 2
				ttisp->tt_abbrind > sp->charcnt)
					goto oops;
d435 2
a436 2
					ttisp->tt_ttisstd != FALSE)
						goto oops;
d448 2
a449 2
					ttisp->tt_ttisgmt != FALSE)
						goto oops;
d481 29
a509 32
		up->buf[0] == '\n' && up->buf[nread - 1] == '\n' &&
		sp->typecnt + 2 <= TZ_MAX_TYPES) {
			struct state	ts;
			int	result;

			up->buf[nread - 1] = '\0';
			result = tzparse(&up->buf[1], &ts, FALSE);
			if (result == 0 && ts.typecnt == 2 &&
				sp->charcnt + ts.charcnt <= TZ_MAX_CHARS) {
					for (i = 0; i < 2; ++i)
						ts.ttis[i].tt_abbrind +=
							sp->charcnt;
					for (i = 0; i < ts.charcnt; ++i)
						sp->chars[sp->charcnt++] =
							ts.chars[i];
					i = 0;
					while (i < ts.timecnt &&
						ts.ats[i] <=
						sp->ats[sp->timecnt - 1])
							++i;
					while (i < ts.timecnt &&
					    sp->timecnt < TZ_MAX_TIMES) {
						sp->ats[sp->timecnt] =
							ts.ats[i];
						sp->types[sp->timecnt] =
							sp->typecnt +
							ts.types[i];
						++sp->timecnt;
						++i;
					}
					sp->ttis[sp->typecnt++] = ts.ttis[0];
					sp->ttis[sp->typecnt++] = ts.ttis[1];
d511 3
d518 4
a521 4
				differ_by_repeat(sp->ats[i], sp->ats[0])) {
					sp->goback = TRUE;
					break;
				}
d524 6
a529 6
				sp->types[i]) &&
				differ_by_repeat(sp->ats[sp->timecnt - 1],
				sp->ats[i])) {
					sp->goahead = TRUE;
					break;
		}
d544 3
a546 3
		a < 0 || a >= sp->typecnt ||
		b < 0 || b >= sp->typecnt)
			result = FALSE;
d551 5
a555 5
			ap->tt_isdst == bp->tt_isdst &&
			ap->tt_ttisstd == bp->tt_ttisstd &&
			ap->tt_ttisgmt == bp->tt_ttisgmt &&
			strcmp(&sp->chars[ap->tt_abbrind],
			&sp->chars[bp->tt_abbrind]) == 0;
d581 2
a582 2
		c != '+')
			++strp;
d739 2
a740 1
	} else	return NULL;		/* invalid format */
d749 2
a750 1
	} else	rulep->r_time = 2 * SECSPERHOUR;	/* default = 2:00:00 */
d811 1
a811 1
			1 + yy2 + yy2 / 4 + yy1 / 4 - 2 * yy1) % 7;
d825 2
a826 2
				mon_lengths[leapyear][rulep->r_mon - 1])
					break;
d913 2
a914 1
		} else	dstoffset = stdoffset - SECSPERHOUR;
d920 2
a921 2
			int	year;
			time_t	janfirst;
d955 1
a955 1
					stdoffset);
d957 1
a957 1
					dstoffset);
d972 1
a972 1
					SECSPERDAY;
d1039 1
a1039 1
							theirdstoffset;
d1042 1
a1042 1
							theirstdoffset;
d1048 2
a1049 1
				else	theirstdoffset = theiroffset;
d1199 29
a1227 5
		(sp->goahead && t > sp->ats[sp->timecnt - 1])) {
			time_t			newt = t;
			time_t		seconds;
			time_t		tcycles;
			int_fast64_t	icycles;
d1229 1
d1231 5
a1235 7
				seconds = sp->ats[0] - t;
			else	seconds = t - sp->ats[sp->timecnt - 1];
			--seconds;
			tcycles = seconds / YEARSPERREPEAT / AVGSECSPERYEAR;
			++tcycles;
			icycles = tcycles;
			if (tcycles - icycles >= 1 || icycles - tcycles >= 1)
d1237 2
a1238 22
			seconds = icycles;
			seconds *= YEARSPERREPEAT;
			seconds *= AVGSECSPERYEAR;
			if (t < sp->ats[0])
				newt += seconds;
			else	newt -= seconds;
			if (newt < sp->ats[0] ||
				newt > sp->ats[sp->timecnt - 1])
					return NULL;	/* "cannot happen" */
			result = localsub(&newt, offset, tmp);
			if (result == tmp) {
				time_t	newy;

				newy = tmp->tm_year;
				if (t < sp->ats[0])
					newy -= icycles * YEARSPERREPEAT;
				else	newy += icycles * YEARSPERREPEAT;
				tmp->tm_year = newy;
				if (tmp->tm_year != newy)
					return NULL;
			}
			return result;
d1256 2
a1257 1
			else	lo = mid + 1;
d1331 2
a1332 1
		else	tmp->TM_ZONE = gmtptr->chars;
d1404 1
a1404 1
					lp->ls_corr > sp->lsis[i - 1].ls_corr);
d1407 6
a1412 6
						sp->lsis[i].ls_trans ==
						sp->lsis[i - 1].ls_trans + 1 &&
						sp->lsis[i].ls_corr ==
						sp->lsis[i - 1].ls_corr + 1) {
							++hit;
							--i;
d1481 5
a1485 5
		((y - EPOCH_YEAR) % DAYSPERWEEK) *
		(DAYSPERNYEAR % DAYSPERWEEK) +
		leaps_thru_end_of(y - 1) -
		leaps_thru_end_of(EPOCH_YEAR - 1) +
		idays;
d1579 2
a1580 2
		(*unitsptr / base) :
		(-1 - (-1 - *unitsptr) / base);
d1591 2
a1592 2
		(*unitsptr / base) :
		(-1 - (-1 - *unitsptr) / base);
d1603 5
a1607 5
		(result = (atmp->tm_mon - btmp->tm_mon)) == 0 &&
		(result = (atmp->tm_mday - btmp->tm_mday)) == 0 &&
		(result = (atmp->tm_hour - btmp->tm_hour)) == 0 &&
		(result = (atmp->tm_min - btmp->tm_min)) == 0)
			result = atmp->tm_sec - btmp->tm_sec;
d1622 4
a1625 4
	long				y;
	time_t				newt;
	time_t				t;
	struct tm			yourtm, mytm;
d1714 2
a1715 1
		} else	dir = tmcomp(&mytm, &yourtm);
d1732 2
a1733 1
			else	lo = t;
d1806 3
a1808 3
	int				seen[TZ_MAX_TYPES];
	int				types[TZ_MAX_TYPES];
	int				okay;
d1856 1
a1856 1
					sp->ttis[samei].tt_gmtoff;
d1862 1
a1862 1
					sp->ttis[samei].tt_gmtoff;
@


1.47
log
@remove CMU gtime
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.46 2015/02/09 14:58:08 tedu Exp $ */
d210 1
a210 2
detzcode(codep)
const char * const	codep;
d222 1
a222 2
detzcode64(codep)
const char * const	codep;
d293 1
a293 3
differ_by_repeat(t1, t0)
const time_t	t1;
const time_t	t0;
d301 1
a301 4
tzload(name, sp, doextend)
const char *		name;
struct state * const	sp;
const int		doextend;
d541 1
a541 4
typesequiv(sp, a, b)
const struct state * const	sp;
const int			a;
const int			b;
d578 1
a578 2
getzname(strp)
const char *	strp;
d615 1
a615 5
getnum(strp, nump, min, max)
const char *	strp;
int * const		nump;
const int		min;
const int		max;
d644 1
a644 3
getsecs(strp, secsp)
const char *	strp;
long * const		secsp;
d684 1
a684 3
getoffset(strp, offsetp)
const char *	strp;
long * const		offsetp;
d709 1
a709 3
getrule(strp, rulep)
const char *			strp;
struct rule * const	rulep;
d761 1
a761 5
transtime(janfirst, year, rulep, offset)
const time_t				janfirst;
const int				year;
const struct rule * const	rulep;
const long				offset;
d852 1
a852 4
tzparse(name, sp, lastditch)
const char *			name;
struct state * const	sp;
const int			lastditch;
d1085 1
a1085 2
gmtload(sp)
struct state * const	sp;
d1090 2
a1091 2
static
void
d1125 1
a1125 2
static
void
d1185 1
a1185 4
localsub(timep, offset, tmp)
const time_t * const	timep;
const long		offset;
struct tm * const	tmp;
d1276 1
a1276 3
localtime_r(timep, p_tm)
const time_t * const	timep;
struct tm *p_tm;
d1286 1
a1286 2
localtime(timep)
const time_t * const	timep;
d1301 1
a1301 4
gmtsub(timep, offset, tmp)
const time_t * const	timep;
const long		offset;
struct tm * const	tmp;
d1336 1
a1336 3
gmtime_r(timep, p_tm)
const time_t *		timep;
struct tm *		p_tm;
d1343 1
a1343 2
gmtime(timep)
const time_t * const	timep;
d1357 1
a1357 3
offtime(timep, offset)
const time_t * const	timep;
const long		offset;
d1370 1
a1370 2
leaps_thru_end_of(y)
const int	y;
d1377 1
a1377 5
timesub(timep, offset, sp, tmp)
const time_t * const			timep;
const long				offset;
const struct state * const	sp;
struct tm * const		tmp;
d1502 1
a1502 2
ctime(timep)
const time_t * const	timep;
d1514 1
a1514 3
ctime_r(timep, buf)
const time_t * const	timep;
char *			buf;
d1539 1
a1539 3
increment_overflow(ip, j)
int * const	ip;
int		j;
d1556 1
a1556 3
long_increment_overflow(lp, m)
long * const	lp;
int const	m;
d1567 1
a1567 4
normalize_overflow(tensptr, unitsptr, base)
int * const	tensptr;
int * const	unitsptr;
const int	base;
d1579 1
a1579 4
long_normalize_overflow(tensptr, unitsptr, base)
long * const	tensptr;
int * const	unitsptr;
const int	base;
d1591 1
a1591 3
tmcomp(atmp, btmp)
const struct tm * const atmp;
const struct tm * const btmp;
d1605 2
a1606 6
time2sub(tmp, funcp, offset, okayp, do_norm_secs)
struct tm * const	tmp;
struct tm * (* const	funcp)(const time_t*, long, struct tm*);
const long		offset;
int * const		okayp;
const int		do_norm_secs;
d1773 2
a1774 5
time2(tmp, funcp, offset, okayp)
struct tm * const	tmp;
struct tm * (* const	funcp)(const time_t*, long, struct tm*);
const long		offset;
int * const		okayp;
d1788 2
a1789 4
time1(tmp, funcp, offset)
struct tm * const	tmp;
struct tm * (* const	funcp)(const time_t *, long, struct tm *);
const long		offset;
d1861 1
a1861 2
mktime(tmp)
struct tm * const	tmp;
d1875 1
a1875 2
timelocal(tmp)
struct tm * const	tmp;
d1883 1
a1883 2
timegm(tmp)
struct tm * const	tmp;
d1891 1
a1891 3
timeoff(tmp, offset)
struct tm * const	tmp;
const long		offset;
d1915 1
a1915 2
leapcorr(timep)
time_t *	timep;
d1932 1
a1932 2
time2posix(t)
time_t	t;
d1939 1
a1939 2
posix2time(t)
time_t	t;
@


1.46
log
@it is not strictly necessary to cast the "return value" of free() to void.
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.45 2015/02/09 14:52:28 tedu Exp $ */
a1976 20

#ifdef CMUCS

/*
** The following is supplied for compatibility with
** previous versions of the CMUCS runtime library.
*/

long
gtime(tmp)
struct tm * const	tmp;
{
	const time_t	t = mktime(tmp);

	if (t == WRONG)
		return -1;
	return t;
}

#endif /* defined CMUCS */
@


1.45
log
@-       register int                    idays;  /* unsigned would be so 2003 */
+       int                     idays;  /* unsigned would be so 2003 */

register is so 1973
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.44 2015/02/09 14:46:40 tedu Exp $ */
d259 1
a259 2
							&sp->ttis[
								sp->types[i]];
d323 1
a323 1
	up = (u_t *) calloc(1, sizeof *up);
d353 3
a355 3
			(void) strlcpy(fullname, p, sizeof fullname);
			(void) strlcat(fullname, "/", sizeof fullname);
			(void) strlcat(fullname, name, sizeof fullname);
d486 1
a486 1
		if (stored >= (int) sizeof(time_t))
d540 1
a540 1
	(void) free((void *) up);
d543 1
a543 1
	(void) free((void *) up);
d1128 1
a1128 1
		lclptr = (struct state *) calloc(1, sizeof *lclptr);
d1134 1
a1134 1
	if (tzload((char *) NULL, lclptr, TRUE) != 0)
d1170 1
a1170 1
		(void) strlcpy(lcl_TZname, name, sizeof lcl_TZname);
d1173 1
a1173 1
		lclptr = (struct state *) calloc(1, sizeof *lclptr);
d1189 1
a1189 1
		(void) strlcpy(lclptr->chars, gmt, sizeof lclptr->chars);
d1192 1
a1192 1
			(void) gmtload(lclptr);
@


1.44
log
@always define ALL_STATE (which, contrary to the name is not about all
states, but rather heap allocating the state) and unifdef the rest
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.43 2015/02/09 14:00:03 tedu Exp $ */
d213 2
a214 2
	register long	result;
	register int	i;
d226 2
a227 2
	register time_t	result;
	register int	i;
d238 2
a239 2
	register struct state * const	sp = lclptr;
	register int			i;
d258 1
a258 1
		register const struct ttinfo * const	ttisp =
d286 2
a287 2
		register const struct ttinfo * const	ttisp = &sp->ttis[i];
		register char *				cp = &sp->chars[ttisp->tt_abbrind];
d307 9
a315 9
register const char *		name;
register struct state * const	sp;
register const int		doextend;
{
	register const char *		p;
	register int			i;
	register int			fid;
	register int			stored;
	register int			nread;
d322 1
a322 1
	register u_t *			up;
d336 1
a336 1
		register int	doaccess;
d410 1
a410 1
			register struct ttinfo *	ttisp;
d427 1
a427 1
			register struct lsinfo *	lsisp;
d437 1
a437 1
			register struct ttinfo *	ttisp;
d450 1
a450 1
			register struct ttinfo *	ttisp;
d494 1
a494 1
			register int	result;
d554 1
a554 1
	register int	result;
d561 2
a562 2
		register const struct ttinfo *	ap = &sp->ttis[a];
		register const struct ttinfo *	bp = &sp->ttis[b];
d590 1
a590 1
register const char *	strp;
d592 1
a592 1
	register char	c;
d610 1
a610 1
getqzname(register const char *strp, const int delim)
d612 1
a612 1
	register int	c;
d628 1
a628 1
register const char *	strp;
d633 2
a634 2
	register char	c;
	register int	num;
d661 1
a661 1
register const char *	strp;
d703 1
a703 1
register const char *	strp;
d706 1
a706 1
	register int	neg = 0;
d731 1
a731 1
register struct rule * const	rulep;
d786 1
a786 1
register const struct rule * const	rulep;
d789 3
a791 3
	register int	leapyear;
	register time_t	value;
	register int	i;
d880 1
a880 1
register struct state * const	sp;
d889 4
a892 4
	register time_t *		atp;
	register unsigned char *	typep;
	register char *			cp;
	register int			load_result;
d948 2
a949 2
			register int	year;
			register time_t	janfirst;
d1006 6
a1011 6
			register long	theirstdoffset;
			register long	theirdstoffset;
			register long	theiroffset;
			register int	isdst;
			register int	i;
			register int	j;
d1159 1
a1159 1
	register const char *	name;
d1221 4
a1224 4
	register struct state *		sp;
	register const struct ttinfo *	ttisp;
	register int			i;
	register struct tm *		result;
d1233 3
a1235 3
			register time_t		seconds;
			register time_t		tcycles;
			register int_fast64_t	icycles;
d1257 1
a1257 1
				register time_t	newy;
d1277 2
a1278 2
		register int	lo = 1;
		register int	hi = sp->timecnt;
d1281 1
a1281 1
			register int	mid = (lo + hi) >> 1;
d1343 1
a1343 1
	register struct tm *	result;
d1416 1
a1416 1
register const int	y;
d1426 2
a1427 2
register const struct state * const	sp;
register struct tm * const		tmp;
d1429 4
a1432 4
	register const struct lsinfo *	lp;
	register time_t			tdays;
	register int			idays;	/* unsigned would be so 2003 */
	register long			rem;
d1434 4
a1437 4
	register const int *		ip;
	register long			corr;
	register int			hit;
	register int			i;
d1467 3
a1469 3
		register time_t	tdelta;
		register int	idelta;
		register int	leapdays;
d1487 1
a1487 1
		register long	seconds;
d1596 1
a1596 1
	register int const	i = *ip;
d1615 1
a1615 1
	register long const	l = *lp;
d1629 1
a1629 1
	register int	tensdelta;
d1644 1
a1644 1
	register int	tensdelta;
d1655 2
a1656 2
register const struct tm * const atmp;
register const struct tm * const btmp;
d1658 1
a1658 1
	register int	result;
d1677 7
a1683 7
	register const struct state *	sp;
	register int			dir;
	register int			i, j;
	register int			saved_seconds;
	register long			li;
	register time_t			lo;
	register time_t			hi;
d1865 6
a1870 6
	register time_t			t;
	register const struct state *	sp;
	register int			samei, otheri;
	register int			sameind, otherind;
	register int			i;
	register int			nseen;
d2017 3
a2019 3
	register struct state *		sp;
	register struct lsinfo *	lp;
	register int			i;
@


1.43
log
@the one true type of time_t is a signed integer
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.42 2015/02/09 13:46:22 tedu Exp $ */
a170 1
#ifdef ALL_STATE
a172 1
#endif /* defined ALL_STATE */
a173 6
#ifndef ALL_STATE
static struct state	lclmem;
static struct state	gmtmem;
#define lclptr		(&lclmem)
#define gmtptr		(&gmtmem)
#endif /* State Farm */
a249 1
#ifdef ALL_STATE
a253 1
#endif /* defined ALL_STATE */
a321 1
#ifdef ALL_STATE
a326 4
#else /* !defined ALL_STATE */
	u_t				u;
	register u_t * const		up = &u;
#endif /* !defined ALL_STATE */
a540 1
#ifdef ALL_STATE
a541 1
#endif /* defined ALL_STATE */
a543 1
#ifdef ALL_STATE
a544 1
#endif /* defined ALL_STATE */
a1127 1
#ifdef ALL_STATE
a1134 1
#endif /* defined ALL_STATE */
a1172 1
#ifdef ALL_STATE
a1179 1
#endif /* defined ALL_STATE */
a1227 1
#ifdef ALL_STATE
a1229 1
#endif /* defined ALL_STATE */
a1347 1
#ifdef ALL_STATE
a1349 1
#endif /* defined ALL_STATE */
a1362 1
#ifdef ALL_STATE
a1365 4
#endif /* defined ALL_STATE */
#ifndef ALL_STATE
		tmp->TM_ZONE = gmtptr->chars;
#endif /* State Farm */
a1440 1
#ifdef ALL_STATE
a1441 4
#endif /* defined ALL_STATE */
#ifndef ALL_STATE
	i = sp->leapcnt;
#endif /* State Farm */
a1805 1
#ifdef ALL_STATE
a1807 1
#endif /* defined ALL_STATE */
a1901 1
#ifdef ALL_STATE
a1903 1
#endif /* defined ALL_STATE */
@


1.42
log
@remove INITIALIZE macro and do it the hard way.
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.41 2015/02/09 13:32:51 tedu Exp $ */
d310 1
a310 2
	if (TYPE_INTEGRAL(time_t) &&
		TYPE_BIT(time_t) - TYPE_SIGNED(time_t) < SECSPERREPEAT_BITS)
d485 4
a488 17
				if (TYPE_SIGNED(time_t)) {
					/*
					** Ignore the end (easy).
					*/
					sp->timecnt = i;
				} else {
					/*
					** Ignore the beginning (harder).
					*/
					register int	j;

					for (j = 0; j + i < sp->timecnt; ++j) {
						sp->ats[j] = sp->ats[j + i];
						sp->types[j] = sp->types[j + i];
					}
					sp->timecnt = j;
				}
d502 1
a502 1
		if (stored >= (int) sizeof(time_t) && TYPE_INTEGRAL(time_t))
d1796 4
a1799 14
	if (!TYPE_SIGNED(time_t)) {
		lo = 0;
		hi = lo - 1;
	} else if (!TYPE_INTEGRAL(time_t)) {
		if (sizeof(time_t) > sizeof(float))
			hi = (time_t) DBL_MAX;
		else	hi = (time_t) FLT_MAX;
		lo = -hi;
	} else {
		lo = 1;
		for (i = 0; i < (int) TYPE_BIT(time_t) - 1; ++i)
			lo *= 2;
		hi = -(lo + 1);
	}
@


1.41
log
@move include lines around a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.40 2015/02/09 13:03:59 tedu Exp $ */
d827 1
a827 1
	INITIALIZE(value);
d928 1
a928 1
	INITIALIZE(dstname);
@


1.40
log
@replace homegrown is_digit with correct calls to isdigit()
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.39 2015/02/09 08:25:11 tedu Exp $ */
d13 2
a17 2
#include "fcntl.h"
#include "float.h"	/* for FLT_MAX and DBL_MAX */
@


1.39
log
@this removes just a few ifdef checks for things that should always be enabled,
and which we definitely don't want to workaround. no change in the compiled
code (yet).
some of these, like the first chunk are plain silly. the compiler used to
compile asctime has nothing to do with the format strings strftime should
support.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.38 2013/04/17 17:40:35 tedu Exp $ */
d12 1
a12 1
/*LINTLIBRARY*/
d627 1
a627 1
	while ((c = *strp) != '\0' && !is_digit(c) && c != ',' && c != '-' &&
d669 1
a669 1
	if (strp == NULL || !is_digit(c = *strp))
d677 1
a677 1
	} while (is_digit(c));
d790 1
a790 1
	} else if (is_digit(*strp)) {
@


1.38
log
@add some prototypes, casts, includes, parenthesis, and whatnot to
silence some warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.37 2011/04/25 13:27:27 millert Exp $ */
a32 11
/*
** SunOS 4.1.1 headers lack O_BINARY.
*/

#ifdef O_BINARY
#define OPEN_MODE	(O_RDONLY | O_BINARY)
#endif /* defined O_BINARY */
#ifndef O_BINARY
#define OPEN_MODE	O_RDONLY
#endif /* !defined O_BINARY */

d382 1
a382 1
		if ((fid = open(name, OPEN_MODE)) == -1)
@


1.37
log
@Update to tzcode2011g from elsie.nci.nih.gov.
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.35 2010/08/23 22:35:34 millert Exp $ */
d271 1
a271 1
		tzname[0] = tzname[1] = gmt;
d324 1
a324 1
	return t1 - t0 == SECSPERREPEAT;
d1417 1
a1417 1
			tmp->TM_ZONE = gmt;
@


1.36
log
@replace a large stack buffer with a malloc call, with help from matthew.
ok deraadt
[passed upstream to the tz list as well]
@
text
@d338 1
a338 1
	union {
d343 11
a353 1
	} *u;
d361 1
a361 1
		return -1;
d378 1
a378 1
				return -1;
d380 1
a380 1
				return -1;
d392 1
a392 1
			return -1;
d394 1
a394 6
			return -1;
	}
	u = malloc(sizeof(*u));
	if (!u) {
		close(fid);
		return -1;
d396 1
a396 1
	nread = read(fid, u->buf, sizeof u->buf);
d398 1
a398 1
		goto bad;
d403 7
a409 7
		ttisstdcnt = (int) detzcode(u->tzhead.tzh_ttisstdcnt);
		ttisgmtcnt = (int) detzcode(u->tzhead.tzh_ttisgmtcnt);
		sp->leapcnt = (int) detzcode(u->tzhead.tzh_leapcnt);
		sp->timecnt = (int) detzcode(u->tzhead.tzh_timecnt);
		sp->typecnt = (int) detzcode(u->tzhead.tzh_typecnt);
		sp->charcnt = (int) detzcode(u->tzhead.tzh_charcnt);
		p = u->tzhead.tzh_charcnt + sizeof u->tzhead.tzh_charcnt;
d416 2
a417 2
				goto bad;
		if (nread - (p - u->buf) <
d425 1
a425 1
				goto bad;
d434 1
a434 1
				goto bad;
d444 1
a444 1
				goto bad;
d448 1
a448 1
					goto bad;
d473 1
a473 1
						goto bad;
d486 1
a486 1
						goto bad;
d519 1
a519 1
		if (u->tzhead.tzh_version[0] == '\0')
d521 1
a521 1
		nread -= p - u->buf;
d523 1
a523 1
			u->buf[i] = p[i];
d531 1
a531 1
		u->buf[0] == '\n' && u->buf[nread - 1] == '\n' &&
d536 2
a537 2
			u->buf[nread - 1] = '\0';
			result = tzparse(&u->buf[1], &ts, FALSE);
d581 3
a583 1
	free(u);
d585 4
a588 2
bad:
	free(u);
d937 1
d1010 1
a1123 1
			** ttisstd and ttisgmt need not be handled.
d1125 1
d1138 1
d1650 1
a1650 1
** Simplified normalize logic courtesy Paul Eggert.
d1654 16
a1669 9
increment_overflow(number, delta)
int *	number;
int	delta;
{
	int	number0;

	number0 = *number;
	*number += delta;
	return (*number < number0) != (delta < 0);
d1673 10
a1682 9
long_increment_overflow(number, delta)
long *	number;
int	delta;
{
	long	number0;

	number0 = *number;
	*number += delta;
	return (*number < number0) != (delta < 0);
@


1.35
log
@update to tzcode2010k from elsie.nci.nih.gov; OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.34 2008/03/31 14:16:53 millert Exp $ */
d343 1
a343 1
	} u;
d386 6
a391 1
	nread = read(fid, u.buf, sizeof u.buf);
d393 1
a393 1
		return -1;
d398 7
a404 7
		ttisstdcnt = (int) detzcode(u.tzhead.tzh_ttisstdcnt);
		ttisgmtcnt = (int) detzcode(u.tzhead.tzh_ttisgmtcnt);
		sp->leapcnt = (int) detzcode(u.tzhead.tzh_leapcnt);
		sp->timecnt = (int) detzcode(u.tzhead.tzh_timecnt);
		sp->typecnt = (int) detzcode(u.tzhead.tzh_typecnt);
		sp->charcnt = (int) detzcode(u.tzhead.tzh_charcnt);
		p = u.tzhead.tzh_charcnt + sizeof u.tzhead.tzh_charcnt;
d411 2
a412 2
				return -1;
		if (nread - (p - u.buf) <
d420 1
a420 1
				return -1;
d429 1
a429 1
				return -1;
d439 1
a439 1
				return -1;
d443 1
a443 1
					return -1;
d468 1
a468 1
						return -1;
d481 1
a481 1
						return -1;
d514 1
a514 1
		if (u.tzhead.tzh_version[0] == '\0')
d516 1
a516 1
		nread -= p - u.buf;
d518 1
a518 1
			u.buf[i] = p[i];
d526 1
a526 1
		u.buf[0] == '\n' && u.buf[nread - 1] == '\n' &&
d531 2
a532 2
			u.buf[nread - 1] = '\0';
			result = tzparse(&u.buf[1], &ts, FALSE);
d576 1
d578 3
@


1.34
log
@Update to tzcode 2008a from elsie.nci.nih.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.33 2007/12/29 22:26:51 millert Exp $ */
d275 7
a281 2
	for (i = 0; i < sp->typecnt; ++i) {
		register const struct ttinfo * const	ttisp = &sp->ttis[i];
d288 1
a288 1
		if (i == 0 || !ttisp->tt_isdst)
d292 1
a292 1
		if (i == 0 || ttisp->tt_isdst)
a296 11
	** And to get the latest zone names into tzname. . .
	*/
	for (i = 0; i < sp->timecnt; ++i) {
		register const struct ttinfo * const	ttisp =
							&sp->ttis[
								sp->types[i]];

		tzname[ttisp->tt_isdst] =
			&sp->chars[ttisp->tt_abbrind];
	}
	/*
d345 1
a554 1
	sp->goback = sp->goahead = FALSE;
d1153 1
a1153 1
		lclptr = (struct state *) malloc(sizeof *lclptr);
d1200 1
a1200 1
		lclptr = (struct state *) malloc(sizeof *lclptr);
d1378 1
a1378 1
		gmtptr = (struct state *) malloc(sizeof *gmtptr);
d1920 4
d2000 2
a2001 1
	tmp->tm_isdst = -1;	/* in case it wasn't initialized */
d2009 2
a2010 1
	tmp->tm_isdst = 0;
d2019 2
a2020 1
	tmp->tm_isdst = 0;
@


1.33
log
@update to tzcode2007j from elsie.nci.nih.gov; mostly ANSIfication
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.32 2007/02/06 19:35:16 millert Exp $ */
d560 17
a576 10
	i = 2 * YEARSPERREPEAT;
	sp->goback = sp->goahead = sp->timecnt > i;
	sp->goback = sp->goback &&
		typesequiv(sp, sp->types[i], sp->types[0]) &&
		differ_by_repeat(sp->ats[i], sp->ats[0]);
	sp->goahead = sp->goahead &&
		typesequiv(sp, sp->types[sp->timecnt - 1],
		sp->types[sp->timecnt - 1 - i]) &&
		differ_by_repeat(sp->ats[sp->timecnt - 1],
			 sp->ats[sp->timecnt - 1 - i]);
@


1.32
log
@Update to tzcode2007a.  This adds support for 64bit time_t in case
we need it in the future.  All of our platforms currently have 32bit
time_t types.  This also extends the timezone data file format to
support both 32bit and 64bit data.  The 64bit data is located after
the 32bit data so binaries linked with the older tzcode simply won't
look at it.  A version field in the file header is used to determine
whether the data file is the old or extended format.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.31 2006/02/18 21:54:17 millert Exp $ */
d135 46
a180 45
static long		detzcode P((const char * codep));
static time_t		detzcode64 P((const char * codep));
static int		differ_by_repeat P((time_t t1, time_t t0));
static const char *	getzname P((const char * strp));
static const char *	getqzname P((const char * strp, const int delim));
static const char *	getnum P((const char * strp, int * nump, int min,
				int max));
static const char *	getsecs P((const char * strp, long * secsp));
static const char *	getoffset P((const char * strp, long * offsetp));
static const char *	getrule P((const char * strp, struct rule * rulep));
static void		gmtload P((struct state * sp));
static struct tm *	gmtsub P((const time_t * timep, long offset,
				struct tm * tmp));
static struct tm *	localsub P((const time_t * timep, long offset,
				struct tm * tmp));
static int		increment_overflow P((int * number, int delta));
static int		leaps_thru_end_of P((int y));
static int		long_increment_overflow P((long * number, int delta));
static int		long_normalize_overflow P((long * tensptr,
				int * unitsptr, int base));
static int		normalize_overflow P((int * tensptr, int * unitsptr,
				int base));
static void		settzname P((void));
static time_t		time1 P((struct tm * tmp,
				struct tm * (*funcp) P((const time_t *,
				long, struct tm *)),
				long offset));
static time_t		time2 P((struct tm *tmp,
				struct tm * (*funcp) P((const time_t *,
				long, struct tm*)),
				long offset, int * okayp));
static time_t		time2sub P((struct tm *tmp,
				struct tm * (*funcp) P((const time_t *,
				long, struct tm*)),
				long offset, int * okayp, int do_norm_secs));
static struct tm *	timesub P((const time_t * timep, long offset,
				const struct state * sp, struct tm * tmp));
static int		tmcomp P((const struct tm * atmp,
				const struct tm * btmp));
static time_t		transtime P((time_t janfirst, int year,
				const struct rule * rulep, long offset));
static int		tzload P((const char * name, struct state * sp,
				int doextend));
static int		tzparse P((const char * name, struct state * sp,
				int lastditch));
d255 1
a255 1
settzname P((void))
d562 2
a563 1
	sp->goback = sp->goback && sp->types[i] == sp->types[0] &&
d566 2
a567 1
		sp->types[sp->timecnt - 1] == sp->types[sp->timecnt - 1 - i] &&
d573 25
d1144 1
a1144 1
tzsetwall_basic P((void))
d1172 1
a1172 1
tzsetwall P((void))
d1181 1
a1181 1
tzset_basic P((void))
d1224 1
a1224 1
tzset P((void))
d1704 1
a1704 1
struct tm * (* const	funcp) P((const time_t*, long, struct tm*));
a1845 3
		/*
		** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
		*/
d1847 1
a1847 2
			(((void *) funcp == (void *) localsub) ?
			lclptr : gmtptr);
d1888 1
a1888 1
struct tm * (* const	funcp) P((const time_t*, long, struct tm*));
d1906 1
a1906 1
struct tm * (* const	funcp) P((const time_t *, long, struct tm *));
d1941 1
a1941 5
	/*
	** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
	*/
	sp = (const struct state *) (((void *) funcp == (void *) localsub) ?
		lclptr : gmtptr);
@


1.31
log
@Update to tzcode2006a; primarily just cast and const fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.30 2005/08/09 16:12:12 millert Exp $ */
d109 2
d136 2
d139 1
a139 1
static const char *	getqzname P((const char * strp, const char delim));
d176 2
a177 1
static int		tzload P((const char * name, struct state * sp));
d234 1
a234 1
	result = (codep[0] & 0x80) ? ~0L : 0L;
d240 13
d322 12
a333 1
tzload(name, sp)
d336 1
d338 11
a348 3
	register const char *	p;
	register int		i;
	register int		fid;
d390 4
a393 6
	{
		struct tzhead *	tzhp;
		union {
			struct tzhead	tzhead;
			char		buf[sizeof *sp + sizeof *tzhp];
		} u;
a396 3
		i = read(fid, u.buf, sizeof u.buf);
		if (close(fid) != 0)
			return -1;
d411 2
a412 1
		if (i - (p - u.buf) < sp->timecnt * 4 +	/* ats */
d414 1
a414 1
			sp->typecnt * (4 + 2) +		/* ttinfos */
d416 1
a416 1
			sp->leapcnt * (4 + 4) +		/* lsinfos */
d421 3
a423 2
			sp->ats[i] = detzcode(p);
			p += 4;
d451 3
a453 2
			lsisp->ls_trans = detzcode(p);
			p += 4;
d510 13
d524 43
d599 1
a599 1
** delimiter of the zone name is located.   Return a pointer to the delimiter.
d603 1
a603 1
** We choose not to care - allowing almost anything to be in the zone abbrev.
d607 1
a607 3
getqzname(strp, delim)
register const char *	strp;
const char		delim;
d609 1
a609 1
	register char	c;
d918 1
a918 1
	load_result = tzload(TZDEFRULES, sp);
d960 1
a960 1
			** Two transitions per year, from EPOCH_YEAR to 2037.
a961 3
			sp->timecnt = 2 * (2037 - EPOCH_YEAR + 1);
			if (sp->timecnt > TZ_MAX_TIMES)
				return -1;
d971 6
a976 1
			for (year = EPOCH_YEAR; year <= 2037; ++year) {
d992 3
a994 1
				janfirst += year_lengths[isleap(year)] *
d996 3
d1111 1
a1111 1
	if (tzload(gmt, sp) != 0)
d1131 1
a1131 1
	if (tzload((char *) NULL, lclptr) != 0)
d1189 1
a1189 1
	} else if (tzload(name, lclptr) != 0)
d1230 39
d1277 11
a1287 4
		for (i = 1; i < sp->timecnt; ++i)
			if (t < sp->ats[i])
				break;
		i = (int) sp->types[i - 1];
@


1.30
log
@Re-add the change from tzcode2005c, this time with an added bounds
check from Arthur David Olson that fixes a possible infinite loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.29 2005/08/09 03:22:06 millert Exp $ */
d4 1
a4 1
** 1996-06-05 by Arthur David Olson (arthur_david_olson@@nih.gov).
d8 2
a9 3
** Leap second handling from Bradley White (bww@@k.gp.cs.cmu.edu).
** POSIX-style TZ environment variable handling from Guy Harris
** (guy@@auspex.com).
d208 1
a208 1
** Thanks to Paul Eggert (eggert@@twinsun.com) for noting this.
a1446 1
**	[kridle@@xinet.com as of 1996-01-16.]
d1457 1
a1457 1
** Simplified normalize logic courtesy Paul Eggert (eggert@@twinsun.com).
d1757 1
a1757 1
	** PCTS code courtesy Grant Sullivan (grant@@osf.org).
@


1.29
log
@Back out a change from tzcode2005c that can cause an infinite loop in mktime().
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.28 2005/08/09 03:21:14 millert Exp $ */
a1541 1
	register int			bits;
d1545 2
d1620 1
a1620 2
	** Divide the search space in half
	** (this works whether time_t is signed or unsigned).
d1622 14
a1635 7
	bits = TYPE_BIT(time_t) - 1;
	/*
	** If time_t is signed, then 0 is just above the median,
	** assuming two's complement arithmetic.
	** If time_t is unsigned, then (1 << bits) is just above the median.
	*/
	t = TYPE_SIGNED(time_t) ? 0 : (((unsigned long) 1) << bits);
d1637 13
a1649 3
		if ((*funcp)(&t, offset, &mytm) == NULL)
			return WRONG;	/* XXX probably wrong */
		dir = tmcomp(&mytm, &yourtm);
d1651 12
a1662 1
			if (bits-- < 0)
d1664 3
a1666 5
			if (bits < 0)
				--t; /* may be needed if new t is minimal */
			else if (dir > 0)
				t -= ((long) 1) << bits;
			else	t += ((long) 1) << bits;
@


1.28
log
@Do not ignore return value of localsub() in localtime_r()
@
text
@d1 1
a1 1
/*	$OpenBSD: localtime.c,v 1.27 2005/08/08 08:05:38 espie Exp $ */
d1542 1
a1545 2
	register time_t			lo;
	register time_t			hi;
d1619 2
a1620 1
	** Do a binary search (this works whatever time_t's type is).
d1622 7
a1628 14
	if (!TYPE_SIGNED(time_t)) {
		lo = 0;
		hi = lo - 1;
	} else if (!TYPE_INTEGRAL(time_t)) {
		if (sizeof(time_t) > sizeof(float))
			hi = (time_t) DBL_MAX;
		else	hi = (time_t) FLT_MAX;
		lo = -hi;
	} else {
		lo = 1;
		for (i = 0; i < (int) TYPE_BIT(time_t) - 1; ++i)
			lo *= 2;
		hi = -(lo + 1);
	}
d1630 3
a1632 13
		t = lo / 2 + hi / 2;
		if (t < lo)
			t = lo;
		else if (t > hi)
			t = hi;
		if ((*funcp)(&t, offset, &mytm) == NULL) {
			/*
			** Assume that t is too extreme to be represented in
			** a struct tm; arrange things so that it is less
			** extreme on the next pass.
			*/
			dir = (t > 0) ? 1 : -1;
		} else	dir = tmcomp(&mytm, &yourtm);
d1634 1
a1634 8
			if (t == lo) {
				++t;
				++lo;
			} else if (t == hi) {
				--t;
				--hi;
			}
			if (lo > hi)
d1636 5
a1640 3
			if (dir > 0)
				hi = t;
			else	lo = t;
@


1.27
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1174 1
a1174 1
	localsub(timep, 0L, p_tm);
@


1.26
log
@Update to tzcode2005j.
@
text
@d1 1
a5 5

#if defined(LIBC_SCCS) && !defined(lint) && !defined(NOID)
static char elsieid[] = "@@(#)localtime.c	7.95";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.25 2004/10/18 22:33:43 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.25
log
@Update to tzcode2004e from elsie.nci.nih.gov
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)localtime.c	7.80";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.24 2004/06/28 14:47:41 millert Exp $";
d22 1
d25 13
d63 1
a63 1
** WILDABBR is used.  Another possibility:  initialize tzname[0] to the
d65 1
a65 1
** And another:  initialize tzname[0] to "ERA", with an explanation in the
d72 1
a72 1
static char		wildabbr[] = "WILDABBR";
d140 1
d147 1
a147 1
static void		gmtsub P((const time_t * timep, long offset,
d149 1
a149 1
static void		localsub P((const time_t * timep, long offset,
d152 1
d160 1
a160 1
				void(*funcp) P((const time_t *,
d164 1
a164 1
				void(*funcp) P((const time_t *,
d168 1
a168 1
				void(*funcp) P((const time_t *,
d171 1
a171 1
static void		timesub P((const time_t * timep, long offset,
d288 18
d452 27
d494 1
a494 1
** a valid character in a zone name is found.  Return a pointer to that
d511 21
d596 1
a596 1
			/* `SECSPERMIN' allows for leap seconds.  */
d635 1
a635 1
** date[/time].  See POSIX section 8 for the format of "date" and "time".
d754 1
a754 1
		** "dow" is the day-of-week of the first day of the month.  Get
d777 1
a777 1
	** question.  To get the Epoch-relative time of the specified local
d815 12
a826 4
		name = getzname(name);
		stdlen = name - stdname;
		if (stdlen < 3)
			return -1;
d837 12
a848 5
		dstname = name;
		name = getzname(name);
		dstlen = name - dstname;	/* length of DST zone name */
		if (dstlen < 3)
			return -1;
d1114 1
a1114 1
** freely called.  (And no, the PANS doesn't require the above behavior--
d1121 1
a1121 1
static void
d1130 1
d1135 2
a1136 4
	if (sp == NULL) {
		gmtsub(timep, offset, tmp);
		return;
	}
d1149 1
a1149 1
		i = sp->types[i - 1];
d1158 1
a1158 1
	timesub(&t, ttisp->tt_gmtoff, sp, tmp);
d1164 1
d1199 1
a1199 1
static void
d1205 2
d1217 1
a1217 1
	timesub(timep, offset, gmtptr, tmp);
d1237 1
d1273 1
a1273 2
	gmtsub(timep, offset, &tm);
	return &tm;
d1278 14
a1291 1
static void
d1299 2
a1300 1
	register long			days;
d1302 1
a1302 2
	register long			y;
	register int			yleap;
d1336 30
a1365 9
	days = *timep / SECSPERDAY;
	rem = *timep % SECSPERDAY;
#ifdef mc68k
	if (*timep == 0x80000000) {
		/*
		** A 3B1 muffs the division on the most negative number.
		*/
		days = -24855;
		rem = -11648;
d1367 5
a1371 2
#endif /* defined mc68k */
	rem += (offset - corr);
d1374 1
a1374 1
		--days;
d1378 1
a1378 1
		++days;
d1380 26
d1407 1
a1407 1
	rem = rem % SECSPERHOUR;
d1411 1
a1411 1
	** representation.  This uses "... ??:59:60" et seq.
d1414 4
a1417 22
	tmp->tm_wday = (int) ((EPOCH_WDAY + days) % DAYSPERWEEK);
	if (tmp->tm_wday < 0)
		tmp->tm_wday += DAYSPERWEEK;
	y = EPOCH_YEAR;
#define LEAPS_THRU_END_OF(y)	((y) / 4 - (y) / 100 + (y) / 400)
	while (days < 0 || days >= (long) year_lengths[yleap = isleap(y)]) {
		register long	newy;

		newy = y + days / DAYSPERNYEAR;
		if (days < 0)
			--newy;
		days -= (newy - y) * DAYSPERNYEAR +
			LEAPS_THRU_END_OF(newy - 1) -
			LEAPS_THRU_END_OF(y - 1);
		y = newy;
	}
	tmp->tm_year = y - TM_YEAR_BASE;
	tmp->tm_yday = (int) days;
	ip = mon_lengths[yleap];
	for (tmp->tm_mon = 0; days >= (long) ip[tmp->tm_mon]; ++(tmp->tm_mon))
		days = days - (long) ip[tmp->tm_mon];
	tmp->tm_mday = (int) (days + 1);
d1422 1
d1432 1
a1432 1
**	to local time in the form of a string.  It is equivalent to
d1443 1
a1443 1
	struct tm	tm;
d1445 1
a1445 1
	return asctime_r(localtime_r(timep, &tm), buf);
d1453 1
a1453 1
**	It does a binary search of the time_t space.  Since time_t's are
d1539 1
a1539 1
void (* const		funcp) P((const time_t*, long, struct tm*));
a1545 1
	register int			bits;
d1549 2
d1603 1
a1603 1
 		return WRONG;
d1624 1
a1624 2
	** Divide the search space in half
	** (this works whether time_t is signed or unsigned).
d1626 14
a1639 7
	bits = TYPE_BIT(time_t) - 1;
	/*
	** If time_t is signed, then 0 is just above the median,
	** assuming two's complement arithmetic.
	** If time_t is unsigned, then (1 << bits) is just above the median.
	*/
	t = TYPE_SIGNED(time_t) ? 0 : (((time_t) 1) << bits);
d1641 13
a1653 2
		(*funcp)(&t, offset, &mytm);
		dir = tmcomp(&mytm, &yourtm);
d1655 8
a1662 1
			if (bits-- < 0)
d1664 3
a1666 5
			if (bits < 0)
				--t; /* may be needed if new t is minimal */
			else if (dir > 0)
				t -= ((time_t) 1) << bits;
			else	t += ((time_t) 1) << bits;
d1695 2
a1696 1
				(*funcp)(&newt, offset, &mytm);
d1715 2
a1716 2
	(*funcp)(&t, offset, tmp);
	*okayp = TRUE;
d1723 1
a1723 1
void (* const		funcp) P((const time_t*, long, struct tm*));
d1741 1
a1741 1
void (* const		funcp) P((const time_t *, long, struct tm *));
d1927 1
a1927 1
	** is not unique.  For a negative leap second
@


1.24
log
@merge in tzcode2004a
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)localtime.c	7.78";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.23 2003/10/06 00:17:13 millert Exp $";
d137 3
d1189 1
a1189 1
	register int			y;
d1258 1
a1258 1
		register int	newy;
d1334 12
d1361 15
d1402 1
a1402 1
	register int			i, j ;
d1404 2
d1421 2
a1422 1
	if (normalize_overflow(&yourtm.tm_year, &yourtm.tm_mon, MONSPERYEAR))
d1425 1
a1425 1
	** Turn yourtm.tm_year into an actual year number for now.
d1428 1
a1428 1
	if (increment_overflow(&yourtm.tm_year, TM_YEAR_BASE))
d1431 1
a1431 1
		if (increment_overflow(&yourtm.tm_year, -1))
d1433 2
a1434 2
		i = yourtm.tm_year + (1 < yourtm.tm_mon);
		yourtm.tm_mday += year_lengths[isleap(i)];
d1437 3
a1439 3
		i = yourtm.tm_year + (1 < yourtm.tm_mon);
		yourtm.tm_mday -= year_lengths[isleap(i)];
		if (increment_overflow(&yourtm.tm_year, 1))
d1443 1
a1443 1
		i = mon_lengths[isleap(yourtm.tm_year)][yourtm.tm_mon];
d1449 1
a1449 1
			if (increment_overflow(&yourtm.tm_year, 1))
d1453 1
a1453 1
	if (increment_overflow(&yourtm.tm_year, -TM_YEAR_BASE))
d1455 3
d1460 1
a1460 1
	else if (yourtm.tm_year + TM_YEAR_BASE < EPOCH_YEAR) {
@


1.23
log
@Update to tzcode2003c from elsie.nci.nih.gov
Fixes a pasto and implements better int oflow checking (doesn't rely on
unspecified behavior).
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)localtime.c	7.76";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.22 2003/03/13 15:47:34 deraadt Exp $";
d1067 4
d1137 4
d1542 5
d1580 10
a1589 1
	for (samei = sp->typecnt - 1; samei >= 0; --samei) {
d1592 2
a1593 1
		for (otheri = sp->typecnt - 1; otheri >= 0; --otheri) {
@


1.22
log
@a few more strlcy; ok from beck & ho
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)localtime.c	7.75";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.21 2002/04/04 19:12:09 millert Exp $";
d332 2
a333 2
		ttisstdcnt = (int) detzcode(u.tzhead.tzh_ttisgmtcnt);
		ttisgmtcnt = (int) detzcode(u.tzhead.tzh_ttisstdcnt);
@


1.21
log
@Minor updates from tzcode2002c
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.20 2001/06/27 00:58:57 lebel Exp $";
d305 3
a307 3
			(void) strcpy(fullname, p);
			(void) strcat(fullname, "/");
			(void) strcat(fullname, name);
d975 1
a975 1
		(void) strcpy(lcl_TZname, name);
d996 1
a996 1
		(void) strcpy(lclptr->chars, gmt);
@


1.20
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)localtime.c	7.70";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.19 2000/04/16 16:24:03 d Exp $";
d323 2
a324 2
		  struct tzhead tzhead;
		  char		buf[sizeof *sp + sizeof *tzhp];
d971 1
a971 1
	if (lcl_is_set > 0  &&  strcmp(lcl_TZname, name) == 0)
d973 1
a973 1
	lcl_is_set = (strlen(name) < sizeof(lcl_TZname));
d992 2
d1414 3
a1416 1
	if (yourtm.tm_year + TM_YEAR_BASE < EPOCH_YEAR) {
@


1.19
log
@sync with ftp://elsie.nci.nih.gov/pub/tzcode2000c.tar.gz, millert@@ ok
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.18 2000/01/06 08:24:17 d Exp $";
d907 2
a908 3
	(void) strncpy(cp, stdname, stdlen);
	cp += stdlen;
	*cp++ = '\0';
d910 1
a910 2
		(void) strncpy(cp, dstname, dstlen);
		*(cp + dstlen) = '\0';
@


1.18
log
@_THREAD_PRIVATE_* macros changed
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)localtime.c	7.66";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.17 1999/03/09 23:06:12 pjanzen Exp $";
d62 11
d754 2
a816 2
				return -1;
			if (load_result != 0)
@


1.17
log
@Back out rev 1.7.  PCTS 151-2 still passes, and mktime() now correctly returns
-1 for calendar times that cannot be represented.
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.16 1999/02/02 00:22:42 d Exp $";
d1072 1
a1072 1
	_THREAD_PRIVATE_KEY(localtime)
d1135 1
a1135 1
	_THREAD_PRIVATE_KEY(gmtime)
@


1.16
log
@typo
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.15 1999/02/01 08:19:36 d Exp $";
a1435 6
#ifdef PCTS
			{
				t += 2;
				break;
			}
#else
a1436 1
#endif
@


1.15
log
@sync with tzcode1999a
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.14 1998/11/20 11:18:55 d Exp $";
d1441 1
a1441 1
#endif
@


1.14
log
@Add thread-safety to libc, so that libc_r will build (on i386 at least).
All POSIX libc api now there (to P1003.1c/D10)
  (more md stuff is needed for other libc/arch/*)
  (setlogin is no longer a special syscall)
Add -pthread option to gcc (that makes it use -lc_r and -D_POSIX_THREADS).
Doc some re-entrant routines
Add libc_r to intro(3)
dig() uses some libc srcs and an extra -I was needed there.
Add more md stuff to libc_r.
Update includes for the pthreads api
Update libc_r TODO
@
text
@d7 2
a8 2
static char elsieid[] = "@@(#)localtime.c	7.64";
static char rcsid[] = "$OpenBSD: localtime.c,v 1.13 1998/07/11 23:17:20 deraadt Exp $";
d202 1
d204 3
a206 17
	/*
        ** The first character must be sign extended on systems with >32bit
        ** longs.  This was solved differently in the master tzcode sources
        ** (the fix first appeared in tzcode95c.tar.gz).  But I believe 
	** that this implementation is superior.
        */

#ifdef __STDC__
#define SIGN_EXTEND_CHAR(x)	((signed char) x)
#else
#define SIGN_EXTEND_CHAR(x)	((x & 0x80) ? ((~0 << 8) | x) : x)
#endif

	result = (SIGN_EXTEND_CHAR(codep[0]) << 24) \
	       | (codep[1] & 0xff) << 16 \
	       | (codep[2] & 0xff) << 8
	       | (codep[3] & 0xff);
d292 1
a292 1
			if ((strlen(p) + 1 + strlen(name)) >= sizeof fullname)
d1264 1
a1264 1
**	The ctime funciton converts the calendar time pointed to by timer
d1274 1
a1274 1
char * buf;
d1276 2
a1277 1
	struct tm tm;
d1441 1
a1441 1
#else
@


1.13
log
@be... slightly more permissive.. but i think this is right, i looked at it for 5 minutes
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.12 1998/07/11 23:08:53 deraadt Exp $";
d22 1
d170 2
a925 6

#ifndef STD_INSPIRED
/*
** A non-static declaration of tzsetwall in a system header file
** may cause a warning about this upcoming static declaration...
*/
a926 1
#endif /* !defined STD_INSPIRED */
d928 1
a928 1
tzsetwall P((void))
d948 16
d965 1
a965 1
tzset P((void))
d971 1
a971 1
		tzsetwall();
d1005 8
d1070 12
d1085 6
a1090 3
	tzset();
	localsub(timep, 0L, &tm);
	return &tm;
d1103 1
d1112 1
d1136 9
d1148 7
a1154 2
	gmtsub(timep, 0L, &tm);
	return &tm;
d1284 9
d1597 7
a1603 2
	tzset();
	return time1(tmp, localsub, 0L);
@


1.12
log
@do not let :relative paths through (how did i miss this before)
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.11 1998/01/18 23:24:53 millert Exp $";
d280 1
a280 1
		if ((name[0] == ':') ||
d294 1
a294 1
		char		fullname[FILENAME_MAX + 1];
d302 1
a302 1
			if ((strlen(p) + strlen(name) + 1) >= sizeof fullname)
@


1.11
log
@tzcode1998b from ftp://elsie.nci.nih.gov/pub
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.10 1997/04/02 03:57:30 deraadt Exp $";
d280 1
a280 1
		if ((name[0] == ':' && name[1] == '/') || 
@


1.10
log
@correctly code the classes of permitted TZ specifications for the
issetugid() case. thanks bitblt and tholo
@
text
@d6 3
a8 6
#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char	elsieid[] = "@@(#)localtime.c	7.59";
#else
static char rcsid[] = "$OpenBSD: localtime.c,v 1.9 1997/01/21 04:52:44 millert Exp $";
#endif
d62 1
a62 1
	long		tt_gmtoff;	/* GMT offset in seconds */
d66 1
a66 1
	int		tt_ttisgmt;	/* TRUE if transition is GMT */
d136 4
d290 1
a290 1
		** that is the sie needed for an array of char large enough
d321 4
a324 1
		char		buf[sizeof *sp + sizeof *tzhp];
d328 1
a328 1
		i = read(fid, buf, sizeof buf);
d331 7
a337 14
		p = buf;
		p += sizeof tzhp->tzh_reserved;
		ttisstdcnt = (int) detzcode(p);
		p += 4;
		ttisgmtcnt = (int) detzcode(p);
		p += 4;
		sp->leapcnt = (int) detzcode(p);
		p += 4;
		sp->timecnt = (int) detzcode(p);
		p += 4;
		sp->typecnt = (int) detzcode(p);
		p += 4;
		sp->charcnt = (int) detzcode(p);
		p += 4;
d345 1
a345 1
		if (i - (p - buf) < sp->timecnt * 4 +	/* ats */
d603 2
a604 2
** Given the Epoch-relative time of January 1, 00:00:00 GMT, in a year, the
** year, a rule, and the offset from GMT at the time that rule takes effect,
d690 1
a690 1
	** "value" is the Epoch-relative time of 00:00:00 GMT on the day in
d693 1
a693 1
	** from GMT.
d727 1
d733 2
a734 4
	}
	if (*name == '\0')
		return -1;	/* was "stdoffset = 0;" */
	else {
d903 1
a903 1
	if (sp->charcnt > sizeof sp->chars)
d1080 1
a1080 1
	** "GMT+xxxx" or "GMT-xxxx" if offset is non-zero,
d1295 1
a1295 1
time2(tmp, funcp, offset, okayp)
d1300 1
d1313 5
d1454 18
d1598 1
a1598 1
** shall correspond to "Wed Dec 31 23:59:59 GMT 1986", which
@


1.9
log
@Remove unnecesary local changes.  The strncpy()'s are safe because
the string is static and so the last element is always init'd to
zero.
@
text
@d10 1
a10 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.8 1997/01/14 03:16:47 millert Exp $";
d278 4
d298 1
a298 1
		if (!doaccess && issetugid() == 0) {
@


1.8
log
@Update to tzcode1996o + our fixes.  Fixes problem pointed out
by cross@@va.pubnix.com.
@
text
@d10 1
a10 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.7 1996/10/30 00:20:14 tholo Exp $";
d297 1
a297 1
			if ((strlen(p) + strlen(name) + 2) >= sizeof fullname)
@


1.7
log
@iUpdate to pass FIPS 151-2 tests
@
text
@d1 5
d7 5
a11 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.6 1996/09/05 12:28:23 deraadt Exp $";
d297 1
a297 1
			if (strlen(p) + 1 + strlen(name) + 1 >= sizeof fullname)
d890 1
d1236 2
a1237 1
**	Kridle's (so its said...) from a long time ago. (mtxinu!kridle now).
d1327 2
a1328 1
		yourtm.tm_mday += year_lengths[isleap(yourtm.tm_year)];
d1331 2
a1332 1
		yourtm.tm_mday -= year_lengths[isleap(yourtm.tm_year)];
@


1.6
log
@1 char oflow
@
text
@d2 1
a2 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.5 1996/08/25 10:11:11 deraadt Exp $";
d1369 6
d1376 1
@


1.5
log
@use issetugid()
@
text
@d2 1
a2 1
static char rcsid[] = "$OpenBSD: localtime.c,v 1.4 1996/08/19 08:34:50 tholo Exp $";
d288 1
a288 1
			if ((strlen(p) + strlen(name) + 1) >= sizeof fullname)
@


1.4
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d2 1
a2 1
static char rcsid[] = "$OpenBSD$";
d285 1
a285 1
		if (!doaccess) {
@


1.3
log
@new common tz code
@
text
@d1 3
a3 7
/*	$NetBSD: localtime.c,v 1.6 1996/01/20 02:31:04 jtc Exp $	*/

#ifndef lint
#ifndef NOID
static char	elsieid[] = "@@(#)localtime.c	7.53";
#endif /* !defined NOID */
#endif /* !defined lint */
@


1.2
log
@from netbsd; sync with tzcode96a
@
text
@d1 1
a1 1
/*	$NetBSD: localtime.c,v 1.5 1996/01/08 22:50:55 jtc Exp $	*/
d5 1
a5 1
static char	elsieid[] = "@@(#)localtime.c	7.50";
d1181 5
a1185 7
	tmp->tm_sec = (int) (rem % SECSPERMIN);
	if (hit)
		/*
		** A positive leap second requires a special
		** representation.  This uses "... ??:59:60" et seq.
		*/
		tmp->tm_sec += hit;
d1358 2
a1359 3
	** Calculate the number of magnitude bits in a time_t
	** (this works regardless of whether time_t is
	** signed or unsigned, though lint complains if unsigned).
d1361 1
a1361 2
	for (bits = 0, t = 1; t > 0; ++bits, t <<= 1)
		continue;
d1363 3
a1365 2
	** If time_t is signed, then 0 is the median value,
	** if time_t is unsigned, then 1 << bits is median.
d1367 1
a1367 1
	t = (t < 0) ? 0 : ((time_t) 1 << bits);
d1375 1
a1375 1
				--t;
d1377 2
a1378 2
				t -= (time_t) 1 << bits;
			else	t += (time_t) 1 << bits;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: localtime.c,v 1.4 1995/03/16 19:14:16 jtc Exp $	*/
d5 1
a5 1
static char	elsieid[] = "@@(#)localtime.c	7.43";
d217 2
a218 2
	register struct state * const		sp = lclptr;
	register int				i;
d433 1
a433 1
	while ((c = *strp) != '\0' && !isdigit(c) && c != ',' && c != '-' &&
d456 1
a456 1
	if (strp == NULL || !isdigit(*strp))
d459 1
a459 1
	while ((c = *strp) != '\0' && isdigit(c)) {
d463 2
a464 2
		++strp;
	}
d526 1
a526 1
	register int	neg;
d531 2
a532 3
	} else if (isdigit(*strp) || *strp++ == '+')
		neg = 0;
	else	return NULL;		/* illegal offset */
d577 1
a577 1
	} else if (isdigit(*strp)) {
d819 2
a820 1
					theirstdoffset = -sp->ttis[j].tt_gmtoff;
d828 2
a829 1
					theirdstoffset = -sp->ttis[j].tt_gmtoff;
d1192 12
a1203 13
	if (days >= 0)
		for ( ; ; ) {
			yleap = isleap(y);
			if (days < (long) year_lengths[yleap])
				break;
			++y;
			days = days - (long) year_lengths[yleap];
		}
	else do {
		--y;
		yleap = isleap(y);
		days = days + (long) year_lengths[yleap];
	} while (days < 0);
d1402 1
a1402 1
		for (i = 0; i < sp->typecnt; ++i) {
d1405 1
a1405 1
			for (j = 0; j < sp->typecnt; ++j) {
d1437 1
a1437 1
void (* const		funcp) P((const time_t*, long, struct tm*));
d1476 1
a1476 1
	for (samei = 0; samei < sp->typecnt; ++samei) {
d1479 1
a1479 1
		for (otheri = 0; otheri < sp->typecnt; ++otheri) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
