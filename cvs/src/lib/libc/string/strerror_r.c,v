head	1.13;
access;
symbols
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.8.0.12
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.8
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.26
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.24
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.22
	OPENBSD_5_0:1.7.0.20
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.18
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.16
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.12
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.14
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.10
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.8
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.6
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.6.0.6
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.1.0.6
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.4
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.10.19.16.26.16;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	ssfIhK1eRgHa6Qqy;

1.12
date	2015.10.25.10.22.09;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	7mBkOAMje05PhuEO;

1.11
date	2015.09.06.20.26.20;	author guenther;	state Exp;
branches;
next	1.10;
commitid	uXV2vgeeQffL6Srn;

1.10
date	2015.09.05.11.25.30;	author guenther;	state Exp;
branches;
next	1.9;
commitid	1yIx001UxX92Imbe;

1.9
date	2015.08.31.02.53.57;	author guenther;	state Exp;
branches;
next	1.8;
commitid	lTMF8Y3C9fQGd6jQ;

1.8
date	2013.06.01.21.26.18;	author stsp;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.01.16.29.09;	author bluhm;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.08.08.05.37;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.26.12.56.01;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.08.06.25.44;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.20.23.38.15;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.03.05.07.34;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.21.20.45.05;	author marc;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove the save_errno dance inside strerror_r(3).  It is from the
time when we had national language support.
OK millert@@
@
text
@/* $OpenBSD: strerror_r.c,v 1.12 2015/10/25 10:22:09 bluhm Exp $ */
/* Public Domain <marc@@snafu.org> */

#include <errno.h>
#include <limits.h>
#include <signal.h>
#include <string.h>

static size_t
__digits10(unsigned int num)
{
	size_t i = 0;

	do {
		num /= 10;
		i++;
	} while (num != 0);

	return i;
}

static int
__itoa(int num, int sign, char *buffer, size_t start, size_t end)
{
	size_t pos;
	unsigned int a;
	int neg;

	if (sign && num < 0) {
		a = -num;
		neg = 1;
	}
	else {
		a = num;
		neg = 0;
	}

	pos = start + __digits10(a);
	if (neg)
	    pos++;

	if (pos < end)
		buffer[pos] = '\0';
	else
		return ERANGE;
	pos--;
	do {
		buffer[pos] = (a % 10) + '0';
		pos--;
		a /= 10;
	} while (a != 0);
	if (neg)
		buffer[pos] = '-';
	return 0;
}


static int
__num2string(int num, int sign, int setid, char *buf, size_t buflen,
    const char * const list[], size_t max, const char *def)
{
	int ret = 0;
	size_t len;

	if (0 <= num && num < max) {
		len = strlcpy(buf, list[num], buflen);
		if (len >= buflen)
			ret = ERANGE;
	} else {
		len = strlcpy(buf, def, buflen);
		if (len >= buflen)
			ret = ERANGE;
		else {
			ret = __itoa(num, sign, buf, len, buflen);
			if (ret == 0)
				ret = EINVAL;
		}
	}

	return ret;
}

#define	UPREFIX	"Unknown error: "

int
strerror_r(int errnum, char *strerrbuf, size_t buflen)
{
	int ret_errno;

	ret_errno = __num2string(errnum, 1, 1, strerrbuf, buflen,
	    sys_errlist, sys_nerr, UPREFIX);

	if (ret_errno)
		errno = ret_errno;
	return (ret_errno);
}
DEF_WEAK(strerror_r);

#define USIGPREFIX "Unknown signal: "

char *
__strsignal(int num, char *buf)
{
	__num2string(num, 0, 2, buf, NL_TEXTMAX, sys_siglist, NSIG,
	    USIGPREFIX);
	return buf;
}
@


1.12
log
@The only thing that was translated into multiple languages in OpenBSD
are the errno messages and signal names.  Everything else is in
English.  We are not planning to translate more text.  Running a
mixed system with less than 1% of the text in native language makes
no sense.  So remove the NLS support from libc messages.  The
catopen(3) functions stay as they are.
OK stsp@@ mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.11 2015/09/06 20:26:20 guenther Exp $ */
a87 1
	int save_errno;
a89 2
	save_errno = errno;

d93 2
a94 1
	errno = ret_errno ? ret_errno : save_errno;
@


1.11
log
@Fix aliasing of sys_errlist, sys_nerr, sys_siglist, and sys_signame
to eliminate duplicate copies of the tables and get direct access internally

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.10 2015/09/05 11:25:30 guenther Exp $ */
a3 4
#ifdef NLS
#include <nl_types.h>
#endif

a64 5
#ifdef NLS
	nl_catd catd;
	catd = catopen("libc", NL_CAT_LOCALE);
#endif

a65 4
#ifdef NLS
		len = strlcpy(buf, catgets(catd, setid, num, list[num]),
		    buflen);
#else
a66 1
#endif
a69 3
#ifdef NLS
		len = strlcpy(buf, catgets(catd, setid, 0xffff, def), buflen);
#else
a70 1
#endif
a78 4

#ifdef NLS
	catclose(catd);
#endif
@


1.10
log
@Use new framework for wrapping cat{open,gets,close}(), eliminating
_cat* in the process.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.9 2015/08/31 02:53:57 guenther Exp $ */
a7 4
#define sys_errlist	_sys_errlist
#define sys_nerr	_sys_nerr
#define sys_siglist	_sys_siglist

d64 1
a64 1
    char * list[], size_t max, const char *def)
d128 1
a128 1
	__num2string(num, 0, 2, buf, NL_TEXTMAX, (char **)sys_siglist, NSIG,
@


1.9
log
@Add framework for resolving (pun intended) libc namespace issues, using
wrapper .h files and asm labels to let internal calls resolve directly and
not be overridable or use the PLT.  Then, apply that framework to most of
the functions in stdio.h, string.h, err.h, and wchar.h.  Delete the
should-have-been-hidden-all-along _v?(err|warn)[cx]? symbols while here.

tests clean on i386, amd64, sparc64, powerpc, and mips64

naming feedback from kettenis@@ and millert@@
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.8 2013/06/01 21:26:18 stsp Exp $ */
a4 3
#define catclose	_catclose
#define catgets		_catgets
#define catopen		_catopen
@


1.8
log
@Fix catopen(3) for UTF-8 locales and update the implementation to POSIX-2008.

Catalogs had an arbitrary character set which was used regardless of locale.
Add UTF-8-encoded catalogs for libc error messages, and rename existing ones
to indicate their character sets. catopen(3) now chooses a catalog which
matches the locale's encoding, if available.

help & ok matthew, man page bits ok jmc, input from naddy and bluhm
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.7 2007/03/01 16:29:09 bluhm Exp $ */
d128 1
@


1.7
log
@If NLS is disabled, strerror does not print the correct error string.
No binary change with NLS enabled.

ok otto millert espie
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.6 2005/08/08 08:05:37 espie Exp $ */
d78 1
a78 1
	catd = catopen("libc", 0);
@


1.6
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.5 2005/05/26 12:56:01 otto Exp $ */
d86 1
a86 1
		len = strlcpy(buf, def, buflen);
@


1.5
log
@Merge common functionality of __strsignal and strerror_r.
ok jaredy@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.4 2005/05/08 06:25:44 otto Exp $ */
a2 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: strerror_r.c,v 1.4 2005/05/08 06:25:44 otto Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.4
log
@Only append number when it fits to avoid truncation and return
appropriate error number. ok miod@@, millert@@ on an earlier version;
ok jaredey@@
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.3 2005/04/20 23:38:15 beck Exp $ */
d5 1
a5 1
static char *rcsid = "$OpenBSD: strerror_r.c,v 1.3 2005/04/20 23:38:15 beck Exp $";
d17 1
d21 1
d38 1
a38 1
__itoa(int num, char *buffer, size_t start, size_t end)
d44 1
a44 1
	if (num < 0) {
d73 3
a75 4
#define	UPREFIX	"Unknown error: "

int
strerror_r(int errnum, char *strerrbuf, size_t buflen)
d77 1
a77 2
	int save_errno;
	int ret_errno;
d79 1
a81 6
#endif

	save_errno = errno;
	ret_errno = 0;

#ifdef NLS
d85 1
a85 1
	if (errnum >= 0 && errnum < sys_nerr) {
d87 2
a88 2
		len = strlcpy(strerrbuf, catgets(catd, 1, errnum,
		    (char *)sys_errlist[errnum]), buflen);
d90 1
a90 1
		len = strlcpy(strerrbuf, sys_errlist[errnum], buflen);
d93 1
a93 1
			ret_errno = ERANGE;
d96 1
a96 2
		len = strlcpy(strerrbuf, catgets(catd, 1, 0xffff, UPREFIX), 
		    buflen);
d98 1
a98 1
		len = strlcpy(strerrbuf, UPREFIX, buflen);
d101 1
a101 1
			ret_errno = ERANGE;
d103 3
a105 3
			ret_errno = __itoa(errnum, strerrbuf, len, buflen);
			if (ret_errno == 0)
				ret_errno = EINVAL;
d113 16
d131 10
@


1.3
log
@correct strlcpy abuse
ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.2 2004/05/03 05:07:34 espie Exp $ */
d5 1
a5 1
static char *rcsid = "$OpenBSD: strerror_r.c,v 1.2 2004/05/03 05:07:34 espie Exp $";
d35 1
a35 1
static void
d57 2
a58 4
	else {
		if (end)
			buffer[--end] = '\0'; /* XXX */
	}
d61 1
a61 3
		
		if (pos < end)
			buffer[pos] = (a % 10) + '0';
d66 2
a67 2
		if (pos < end)
			buffer[pos] = '-';
d109 3
a111 2
			__itoa(errnum, strerrbuf, len, buflen);
			ret_errno = EINVAL;
@


1.2
log
@build the error message in strerror_r.c directly, avoiding one copy there.
handle a few subtle details caught by the regression tests: correct
termination, non copying if buffer length == 0, errno setting.
let all former users of __strerror go through strerror_r.

Work by Todd Miller and I. Okay millert@@.
@
text
@d1 1
a1 1
/* $OpenBSD: strerror_r.c,v 1.1 2002/11/21 20:45:05 marc Exp $ */
d5 1
a5 1
static char *rcsid = "$OpenBSD: strerror_r.c,v 1.1 2002/11/21 20:45:05 marc Exp $";
d110 6
a115 2
		__itoa(errnum, strerrbuf, len, buflen);
		ret_errno = EINVAL;
@


1.1
log
@
Add strerror_r and functions versions of getchar_unlocked and
putchar_unlocked.   Crank the minor on related libs.  OK fgs@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d5 1
a5 1
static char *rcsid = "$OpenBSD$";
d8 10
d22 54
a75 1
extern char *__strerror(int, char *);
d82 4
a85 1
	char buf[NL_TEXTMAX];
d88 29
a116 6
	errno = 0;
	__strerror(errnum, buf);
	if (strlcpy(strerrbuf, buf, buflen) >= buflen)
		errno = ERANGE;
	ret_errno = errno;
	errno = save_errno;
d118 1
@

