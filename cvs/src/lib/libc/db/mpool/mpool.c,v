head	1.21;
access;
symbols
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.32
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.30
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.28
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.26
	OPENBSD_5_0:1.18.0.24
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.22
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.20
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.16
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.18
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.14
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.12
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.10
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.6.0.12
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.10
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2015.11.01.03.45.28;	author guenther;	state Exp;
branches;
next	1.20;
commitid	CfNWDWdDpm7mVO8i;

1.20
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	0DYulI8hhujBHMcR;

1.19
date	2013.12.02.02.28.21;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.25.14.40.03;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.24.16.10.15;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.12.07.25.13;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.10.19.23.41;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.05.13.03.00;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.23.19.34.59;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.01.20.23.40;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.25.23.45.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.01.18.13.33;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.31.03.51.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.02.15.05.11.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.08.28.20.49.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.09.30.51;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.20.52;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.05.07.09.01.59;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.50;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@delete old lint ARGSUSED comments
@
text
@/*	$OpenBSD: mpool.c,v 1.20 2015/01/16 16:48:51 deraadt Exp $	*/

/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/queue.h>
#include <sys/stat.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <db.h>

#define	__MPOOLINTERFACE_PRIVATE
#include <mpool.h>

static BKT *mpool_bkt(MPOOL *);
static BKT *mpool_look(MPOOL *, pgno_t);
static int  mpool_write(MPOOL *, BKT *);

/*
 * mpool_open --
 *	Initialize a memory pool.
 */
MPOOL *
mpool_open(void *key, int fd, pgno_t pagesize, pgno_t maxcache)
{
	struct stat sb;
	MPOOL *mp;
	int entry;

	/*
	 * Get information about the file.
	 *
	 * XXX
	 * We don't currently handle pipes, although we should.
	 */
	if (fstat(fd, &sb))
		return (NULL);
	if (!S_ISREG(sb.st_mode)) {
		errno = ESPIPE;
		return (NULL);
	}

	/* Allocate and initialize the MPOOL cookie. */
	if ((mp = (MPOOL *)calloc(1, sizeof(MPOOL))) == NULL)
		return (NULL);
	TAILQ_INIT(&mp->lqh);
	for (entry = 0; entry < HASHSIZE; ++entry)
		TAILQ_INIT(&mp->hqh[entry]);
	mp->maxcache = maxcache;
	mp->npages = sb.st_size / pagesize;
	mp->pagesize = pagesize;
	mp->fd = fd;
	return (mp);
}

/*
 * mpool_filter --
 *	Initialize input/output filters.
 */
void
mpool_filter(MPOOL *mp, void (*pgin) (void *, pgno_t, void *),
    void (*pgout) (void *, pgno_t, void *), void *pgcookie)
{
	mp->pgin = pgin;
	mp->pgout = pgout;
	mp->pgcookie = pgcookie;
}
	
/*
 * mpool_new --
 *	Get a new page of memory.
 */
void *
mpool_new(MPOOL *mp, pgno_t *pgnoaddr, u_int flags)
{
	struct _hqh *head;
	BKT *bp;

	if (mp->npages == MAX_PAGE_NUMBER) {
		(void)fprintf(stderr, "mpool_new: page allocation overflow.\n");
		abort();
	}
#ifdef STATISTICS
	++mp->pagenew;
#endif
	/*
	 * Get a BKT from the cache.  Assign a new page number, attach
	 * it to the head of the hash chain, the tail of the lru chain,
	 * and return.
	 */
	if ((bp = mpool_bkt(mp)) == NULL)
		return (NULL);
	if (flags == MPOOL_PAGE_REQUEST) {
		mp->npages++;
		bp->pgno = *pgnoaddr;
	} else
		bp->pgno = *pgnoaddr = mp->npages++;

	bp->flags = MPOOL_PINNED | MPOOL_INUSE;

	head = &mp->hqh[HASHKEY(bp->pgno)];
	TAILQ_INSERT_HEAD(head, bp, hq);
	TAILQ_INSERT_TAIL(&mp->lqh, bp, q);
	return (bp->page);
}

int
mpool_delete(MPOOL *mp, void *page)
{
	struct _hqh *head;
	BKT *bp;

	bp = (BKT *)((char *)page - sizeof(BKT));

#ifdef DEBUG
	if (!(bp->flags & MPOOL_PINNED)) {
		(void)fprintf(stderr,
		    "mpool_delete: page %d not pinned\n", bp->pgno);
		abort();
	}
#endif

	/* Remove from the hash and lru queues. */
	head = &mp->hqh[HASHKEY(bp->pgno)];
	TAILQ_REMOVE(head, bp, hq);
	TAILQ_REMOVE(&mp->lqh, bp, q);

	free(bp);
	mp->curcache--;
	return (RET_SUCCESS);
}	
	
/*
 * mpool_get
 *	Get a page.
 */
void *
mpool_get(MPOOL *mp, pgno_t pgno,
    u_int flags)		/* XXX not used? */
{
	struct _hqh *head;
	BKT *bp;
	off_t off;
	int nr;

#ifdef STATISTICS
	++mp->pageget;
#endif

	/* Check for a page that is cached. */
	if ((bp = mpool_look(mp, pgno)) != NULL) {
#ifdef DEBUG
		if (!(flags & MPOOL_IGNOREPIN) && bp->flags & MPOOL_PINNED) {
			(void)fprintf(stderr,
			    "mpool_get: page %d already pinned\n", bp->pgno);
			abort();
		}
#endif
		/*
		 * Move the page to the head of the hash chain and the tail
		 * of the lru chain.
		 */
		head = &mp->hqh[HASHKEY(bp->pgno)];
		TAILQ_REMOVE(head, bp, hq);
		TAILQ_INSERT_HEAD(head, bp, hq);
		TAILQ_REMOVE(&mp->lqh, bp, q);
		TAILQ_INSERT_TAIL(&mp->lqh, bp, q);

		/* Return a pinned page. */
		bp->flags |= MPOOL_PINNED;
		return (bp->page);
	}

	/* Get a page from the cache. */
	if ((bp = mpool_bkt(mp)) == NULL)
		return (NULL);

	/* Read in the contents. */
	off = mp->pagesize * pgno;
	if ((nr = pread(mp->fd, bp->page, mp->pagesize, off)) != mp->pagesize) {
		switch (nr) {
		case -1:
			/* errno is set for us by pread(). */
			free(bp);
			mp->curcache--;
			return (NULL);
		case 0:
			/*
			 * A zero-length read means you need to create a
			 * new page.
			 */
			memset(bp->page, 0, mp->pagesize);
			break;
		default:
			/* A partial read is definitely bad. */
			free(bp);
			mp->curcache--;
			errno = EINVAL;
			return (NULL);
		}
	}
#ifdef STATISTICS
	++mp->pageread;
#endif

	/* Set the page number, pin the page. */
	bp->pgno = pgno;
	if (!(flags & MPOOL_IGNOREPIN))
		bp->flags = MPOOL_PINNED;
	bp->flags |= MPOOL_INUSE;

	/*
	 * Add the page to the head of the hash chain and the tail
	 * of the lru chain.
	 */
	head = &mp->hqh[HASHKEY(bp->pgno)];
	TAILQ_INSERT_HEAD(head, bp, hq);
	TAILQ_INSERT_TAIL(&mp->lqh, bp, q);

	/* Run through the user's filter. */
	if (mp->pgin != NULL)
		(mp->pgin)(mp->pgcookie, bp->pgno, bp->page);

	return (bp->page);
}

/*
 * mpool_put
 *	Return a page.
 */
int
mpool_put(MPOOL *mp, void *page, u_int flags)
{
	BKT *bp;

#ifdef STATISTICS
	++mp->pageput;
#endif
	bp = (BKT *)((char *)page - sizeof(BKT));
#ifdef DEBUG
	if (!(bp->flags & MPOOL_PINNED)) {
		(void)fprintf(stderr,
		    "mpool_put: page %d not pinned\n", bp->pgno);
		abort();
	}
#endif
	bp->flags &= ~MPOOL_PINNED;
	if (flags & MPOOL_DIRTY)
		bp->flags |= flags & MPOOL_DIRTY;
	return (RET_SUCCESS);
}

/*
 * mpool_close
 *	Close the buffer pool.
 */
int
mpool_close(MPOOL *mp)
{
	BKT *bp;

	/* Free up any space allocated to the lru pages. */
	while ((bp = TAILQ_FIRST(&mp->lqh))) {
		TAILQ_REMOVE(&mp->lqh, bp, q);
		free(bp);
	}

	/* Free the MPOOL cookie. */
	free(mp);
	return (RET_SUCCESS);
}

/*
 * mpool_sync
 *	Sync the pool to disk.
 */
int
mpool_sync(MPOOL *mp)
{
	BKT *bp;

	/* Walk the lru chain, flushing any dirty pages to disk. */
	TAILQ_FOREACH(bp, &mp->lqh, q)
		if (bp->flags & MPOOL_DIRTY &&
		    mpool_write(mp, bp) == RET_ERROR)
			return (RET_ERROR);

	/* Sync the file descriptor. */
	return (fsync(mp->fd) ? RET_ERROR : RET_SUCCESS);
}

/*
 * mpool_bkt
 *	Get a page from the cache (or create one).
 */
static BKT *
mpool_bkt(MPOOL *mp)
{
	struct _hqh *head;
	BKT *bp;

	/* If under the max cached, always create a new page. */
	if (mp->curcache < mp->maxcache)
		goto new;

	/*
	 * If the cache is max'd out, walk the lru list for a buffer we
	 * can flush.  If we find one, write it (if necessary) and take it
	 * off any lists.  If we don't find anything we grow the cache anyway.
	 * The cache never shrinks.
	 */
	TAILQ_FOREACH(bp, &mp->lqh, q)
		if (!(bp->flags & MPOOL_PINNED)) {
			/* Flush if dirty. */
			if (bp->flags & MPOOL_DIRTY &&
			    mpool_write(mp, bp) == RET_ERROR)
				return (NULL);
#ifdef STATISTICS
			++mp->pageflush;
#endif
			/* Remove from the hash and lru queues. */
			head = &mp->hqh[HASHKEY(bp->pgno)];
			TAILQ_REMOVE(head, bp, hq);
			TAILQ_REMOVE(&mp->lqh, bp, q);
#ifdef DEBUG
			{ void *spage;
				spage = bp->page;
				memset(bp, 0xff, sizeof(BKT) + mp->pagesize);
				bp->page = spage;
			}
#endif
			bp->flags = 0;
			return (bp);
		}

new:	if ((bp = (BKT *)malloc(sizeof(BKT) + mp->pagesize)) == NULL)
		return (NULL);
#ifdef STATISTICS
	++mp->pagealloc;
#endif
	memset(bp, 0xff, sizeof(BKT) + mp->pagesize);
	bp->page = (char *)bp + sizeof(BKT);
	bp->flags = 0;
	++mp->curcache;
	return (bp);
}

/*
 * mpool_write
 *	Write a page to disk.
 */
static int
mpool_write(MPOOL *mp, BKT *bp)
{
	off_t off;

#ifdef STATISTICS
	++mp->pagewrite;
#endif

	/* Run through the user's filter. */
	if (mp->pgout)
		(mp->pgout)(mp->pgcookie, bp->pgno, bp->page);

	off = mp->pagesize * bp->pgno;
	if (pwrite(mp->fd, bp->page, mp->pagesize, off) != mp->pagesize)
		return (RET_ERROR);

	/*
	 * Re-run through the input filter since this page may soon be
	 * accessed via the cache, and whatever the user's output filter
	 * did may screw things up if we don't let the input filter
	 * restore the in-core copy.
	 */
	if (mp->pgin)
		(mp->pgin)(mp->pgcookie, bp->pgno, bp->page);

	bp->flags &= ~MPOOL_DIRTY;
	return (RET_SUCCESS);
}

/*
 * mpool_look
 *	Lookup a page in the cache.
 */
static BKT *
mpool_look(MPOOL *mp, pgno_t pgno)
{
	struct _hqh *head;
	BKT *bp;

	head = &mp->hqh[HASHKEY(pgno)];
	TAILQ_FOREACH(bp, head, hq)
		if ((bp->pgno == pgno) &&
			((bp->flags & MPOOL_INUSE) == MPOOL_INUSE)) {
#ifdef STATISTICS
			++mp->cachehit;
#endif
			return (bp);
		}
#ifdef STATISTICS
	++mp->cachemiss;
#endif
	return (NULL);
}

#ifdef STATISTICS
/*
 * mpool_stat
 *	Print out cache statistics.
 */
void
mpool_stat(MPOOL *mp)
{
	BKT *bp;
	int cnt;
	char *sep;

	(void)fprintf(stderr, "%lu pages in the file\n", mp->npages);
	(void)fprintf(stderr,
	    "page size %lu, cacheing %lu pages of %lu page max cache\n",
	    mp->pagesize, mp->curcache, mp->maxcache);
	(void)fprintf(stderr, "%lu page puts, %lu page gets, %lu page new\n",
	    mp->pageput, mp->pageget, mp->pagenew);
	(void)fprintf(stderr, "%lu page allocs, %lu page flushes\n",
	    mp->pagealloc, mp->pageflush);
	if (mp->cachehit + mp->cachemiss)
		(void)fprintf(stderr,
		    "%.0f%% cache hit rate (%lu hits, %lu misses)\n", 
		    ((double)mp->cachehit / (mp->cachehit + mp->cachemiss))
		    * 100, mp->cachehit, mp->cachemiss);
	(void)fprintf(stderr, "%lu page reads, %lu page writes\n",
	    mp->pageread, mp->pagewrite);

	sep = "";
	cnt = 0;
	TAILQ_FOREACH(bp, &mp->lqh, q) {
		(void)fprintf(stderr, "%s%d", sep, bp->pgno);
		if (bp->flags & MPOOL_DIRTY)
			(void)fprintf(stderr, "d");
		if (bp->flags & MPOOL_PINNED)
			(void)fprintf(stderr, "P");
		if (++cnt == 10) {
			sep = "\n";
			cnt = 0;
		} else
			sep = ", ";
			
	}
	(void)fprintf(stderr, "\n");
}
#endif
@


1.20
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.19 2013/12/02 02:28:21 krw Exp $	*/
a53 1
/* ARGSUSED */
a167 1
/* ARGSUSED */
a261 1
/* ARGSUSED */
@


1.19
log
@CIRCLEQ begone.

ok miller@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.18 2006/01/25 14:40:03 millert Exp $	*/
a31 1
#include <sys/param.h>
@


1.18
log
@Fix a memory leak that could be trigged by a read error
Update the count of currently cached pages in mpool_delete()
Use CIRCLEQ_EMPTY in the loop that delets the lru cache
Don't update the pageread statistic if there was a read error
With aaron@@, OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.17 2006/01/24 16:10:15 aaron Exp $	*/
d79 1
a79 1
	CIRCLEQ_INIT(&mp->lqh);
d81 1
a81 1
		CIRCLEQ_INIT(&mp->hqh[entry]);
d135 2
a136 2
	CIRCLEQ_INSERT_HEAD(head, bp, hq);
	CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);
d158 2
a159 2
	CIRCLEQ_REMOVE(head, bp, hq);
	CIRCLEQ_REMOVE(&mp->lqh, bp, q);
d198 4
a201 4
		CIRCLEQ_REMOVE(head, bp, hq);
		CIRCLEQ_INSERT_HEAD(head, bp, hq);
		CIRCLEQ_REMOVE(&mp->lqh, bp, q);
		CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);
d251 2
a252 2
	CIRCLEQ_INSERT_HEAD(head, bp, hq);
	CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);
d298 2
a299 3
	while (!CIRCLEQ_EMPTY(&mp->lqh)) {
		bp = CIRCLEQ_FIRST(&mp->lqh);
		CIRCLEQ_REMOVE(&mp->lqh, bp, q);
d318 1
a318 1
	CIRCLEQ_FOREACH(bp, &mp->lqh, q)
d347 1
a347 1
	CIRCLEQ_FOREACH(bp, &mp->lqh, q)
d358 2
a359 2
			CIRCLEQ_REMOVE(head, bp, hq);
			CIRCLEQ_REMOVE(&mp->lqh, bp, q);
d428 1
a428 1
	CIRCLEQ_FOREACH(bp, head, hq)
d472 1
a472 1
	CIRCLEQ_FOREACH(bp, &mp->lqh, q) {
@


1.17
log
@Add missing break; in a switch case statement from r1.7 pread() changes.  From
dhelder AT arbor.net.  millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.16 2005/10/12 07:25:13 otto Exp $	*/
d162 1
a212 3
#ifdef STATISTICS
	++mp->pageread;
#endif
d218 2
d230 2
d236 3
d298 2
a299 1
	while ((bp = CIRCLEQ_FIRST(&mp->lqh)) != CIRCLEQ_END(&mp->lqh)) {
@


1.16
log
@Use queue macros instead of directly accessing fields. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.15 2005/10/10 19:23:41 otto Exp $	*/
d227 1
@


1.15
log
@Pass local var instead of mp->lqh.cqh_first to CIRCLEQ_REMOVE macro.
The latter might fail, depending on the actual implementation of
CIRCLEQ_REMOVE. Found by a strict queue.h I'm working on.
ok pedro@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.14 2005/08/05 13:03:00 espie Exp $	*/
d312 1
a312 2
	for (bp = mp->lqh.cqh_first;
	    bp != (void *)&mp->lqh; bp = bp->q.cqe_next)
d341 1
a341 2
	for (bp = mp->lqh.cqh_first;
	    bp != (void *)&mp->lqh; bp = bp->q.cqe_next)
d422 1
a422 1
	for (bp = head->cqh_first; bp != (void *)head; bp = bp->hq.cqe_next)
d466 1
a466 2
	for (bp = mp->lqh.cqh_first;
	    bp != (void *)&mp->lqh; bp = bp->q.cqe_next) {
@


1.14
log
@zap rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.13 2005/03/23 19:34:59 otto Exp $	*/
d292 2
a293 2
	while ((bp = mp->lqh.cqh_first) != (void *)&mp->lqh) {
		CIRCLEQ_REMOVE(&mp->lqh, mp->lqh.cqh_first, q);
@


1.13
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.12 2003/06/02 20:18:34 millert Exp $	*/
a30 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)mpool.c	8.7 (Berkeley) 11/2/95";
#else
static const char rcsid[] = "$OpenBSD: mpool.c,v 1.12 2003/06/02 20:18:34 millert Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.11 2003/05/01 20:23:40 avsm Exp $	*/
d36 1
a36 1
static const char rcsid[] = "$OpenBSD: mpool.c,v 1.11 2003/05/01 20:23:40 avsm Exp $";
d65 1
a65 4
mpool_open(key, fd, pagesize, maxcache)
	void *key;
	int fd;
	pgno_t pagesize, maxcache;
d102 2
a103 5
mpool_filter(mp, pgin, pgout, pgcookie)
	MPOOL *mp;
	void (*pgin)(void *, pgno_t, void *);
	void (*pgout)(void *, pgno_t, void *);
	void *pgcookie;
d115 1
a115 4
mpool_new(mp, pgnoaddr, flags)
	MPOOL *mp;
	pgno_t *pgnoaddr;
	u_int flags;
d149 1
a149 3
mpool_delete(mp, page)
	MPOOL *mp;
	void *page;
d179 2
a180 4
mpool_get(mp, pgno, flags)
	MPOOL *mp;
	pgno_t pgno;
	u_int flags;				/* XXX not used? */
d269 1
a269 4
mpool_put(mp, page, flags)
	MPOOL *mp;
	void *page;
	u_int flags;
d295 1
a295 2
mpool_close(mp)
	MPOOL *mp;
d315 1
a315 2
mpool_sync(mp)
	MPOOL *mp;
d335 1
a335 2
mpool_bkt(mp)
	MPOOL *mp;
d392 1
a392 3
mpool_write(mp, bp)
	MPOOL *mp;
	BKT *bp;
d426 1
a426 3
mpool_look(mp, pgno)
	MPOOL *mp;
	pgno_t pgno;
d452 1
a452 2
mpool_stat(mp)
	MPOOL *mp;
@


1.11
log
@-Wall cleanup, make rcsid variables const
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.10 2002/02/25 23:45:15 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d36 1
a36 1
static const char rcsid[] = "$OpenBSD: mpool.c,v 1.10 2002/02/25 23:45:15 millert Exp $";
@


1.10
log
@Cosmetic changes such as correct printf format specifiers on LP64
machines and whitespace nits.  Some from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.9 2002/02/16 21:27:22 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: mpool.c,v 1.9 2002/02/16 21:27:22 millert Exp $";
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.8 2002/02/01 18:13:33 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: mpool.c,v 1.8 2002/02/01 18:13:33 millert Exp $";
d461 1
a461 1
			(bp->flags & MPOOL_INUSE == MPOOL_INUSE)) {
@


1.8
log
@After writing a page out to disk, run the page back through the user's
input filter to ensure we don't end up with a cached copy of the page
in the wrong byte-order for the host cpu.

This fixes a fatal bug which bites when the DB 'lorder' is different
to the cpu's, and a cached page is accessed soon after it was flushed
to disk.

From scw@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.7 2002/01/31 03:51:21 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: mpool.c,v 1.7 2002/01/31 03:51:21 millert Exp $";
d59 3
a61 3
static BKT *mpool_bkt __P((MPOOL *));
static BKT *mpool_look __P((MPOOL *, pgno_t));
static int  mpool_write __P((MPOOL *, BKT *));
d111 2
a112 2
	void (*pgin) __P((void *, pgno_t, void *));
	void (*pgout) __P((void *, pgno_t, void *));
@


1.7
log
@Use pread(2) and pwrite(2) instead of lseek(2) + read(2) / write(2).
Based on changes from NetBSD (thorpej).
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.6 1999/02/15 05:11:25 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: mpool.c,v 1.6 1999/02/15 05:11:25 millert Exp $";
d432 9
@


1.6
log
@ o Minor changes from db.1.86 (sleepycat).  Does not include the new hash
   routines since they cannot read a hashed .db file from the old code.
   Most of these files just have their RCS/SCCS tags standardized.
   Note that mpool.3 has not been updated to reflect the new mpool interface.
 o Add a real dbm(3) manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: mpool.c,v 1.5 1998/08/28 20:49:11 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: mpool.c,v 1.5 1998/08/28 20:49:11 deraadt Exp $";
d241 4
a244 7
	if (lseek(mp->fd, off, SEEK_SET) != off)
		return (NULL);

	if ((nr = read(mp->fd, bp->page, mp->pagesize)) != mp->pagesize) {
		if (nr > 0) {
			/* A partial read is definitely bad. */
			errno = EINVAL;
d246 1
a246 1
		} else {
d248 1
a248 1
			 * A zero-length reads, means you need to create a
d252 4
d430 1
a430 3
	if (lseek(mp->fd, off, SEEK_SET) != off)
		return (RET_ERROR);
	if (write(mp->fd, bp->page, mp->pagesize) != mp->pagesize)
@


1.5
log
@do not toss memory dribble into the output files (small performance loss)
@
text
@d1 2
d37 5
a41 1
static char rcsid[] = "$OpenBSD: mpool.c,v 1.4 1996/09/15 09:30:51 tholo Exp $";
d125 1
a125 1
mpool_new(mp, pgnoaddr)
d128 1
d147 7
a153 2
	*pgnoaddr = bp->pgno = mp->npages++;
	bp->flags = MPOOL_PINNED;
d161 27
a203 6
	/* Check for attempt to retrieve a non-existent page. */
	if (pgno >= mp->npages) {
		errno = EINVAL;
		return (NULL);
	}

d211 1
a211 1
		if (bp->flags & MPOOL_PINNED) {
d243 1
d245 11
a255 3
		if (nr >= 0)
			errno = EFTYPE;
		return (NULL);
d260 3
a262 1
	bp->flags = MPOOL_PINNED;
d304 2
a305 1
	bp->flags |= flags & MPOOL_DIRTY;
d393 1
d404 1
d452 2
a453 1
		if (bp->pgno == pgno) {
@


1.4
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mpool.c,v 1.3 1996/08/19 08:20:52 tholo Exp $";
a355 1
#if defined(DEBUG) || defined(PURIFY)
a356 1
#endif
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mpool.c,v 1.6 1996/05/03 21:29:48 cgd Exp $";
d61 1
d153 1
d239 1
@


1.2
log
@db release 1.85
@
text
@a0 2
/*	$NetBSD: mpool.c,v 1.6 1996/05/03 21:29:48 cgd Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)mpool.c	8.5 (Berkeley) 7/26/94";
#else
static char rcsid[] = "$NetBSD: mpool.c,v 1.6 1996/05/03 21:29:48 cgd Exp $";
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mpool.c,v 1.5 1995/02/27 13:24:05 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1990, 1993
d38 1
a38 1
static char sccsid[] = "@@(#)mpool.c	8.2 (Berkeley) 2/21/94";
d40 1
a40 1
static char rcsid[] = "$NetBSD: mpool.c,v 1.5 1995/02/27 13:24:05 cgd Exp $";
d45 1
d55 1
d57 1
a57 1
#include "mpool.h"
a61 3
#ifdef DEBUG
static void __mpoolerr __P((const char *fmt, ...));
#endif
d64 2
a65 10
 * MPOOL_OPEN -- initialize a memory pool.
 *
 * Parameters:
 *	key:		Shared buffer key.
 *	fd:		File descriptor.
 *	pagesize:	File page size.
 *	maxcache:	Max number of cached pages.
 *
 * Returns:
 *	MPOOL pointer, NULL on error.
d69 1
a69 1
	DBT *key;
d77 6
a84 5
	/* XXX
	 * We should only set st_size to 0 for pipes -- 4.4BSD has the fix so
	 * that stat(2) returns true for ISSOCK on pipes.  Until then, this is
	 * fairly close.
	 */
d90 2
a91 1
	if ((mp = (MPOOL *)malloc(sizeof(MPOOL))) == NULL)
d93 1
a93 2
	mp->free.cnext = mp->free.cprev = (BKT *)&mp->free;
	mp->lru.cnext = mp->lru.cprev = (BKT *)&mp->lru;
d95 1
a95 4
		mp->hashtable[entry].hnext = mp->hashtable[entry].hprev = 
		    mp->hashtable[entry].cnext = mp->hashtable[entry].cprev =
		    (BKT *)&mp->hashtable[entry];
	mp->curcache = 0;
d97 1
a98 1
	mp->npages = sb.st_size / pagesize;
a99 8
	mp->pgcookie = NULL;
	mp->pgin = mp->pgout = NULL;

#ifdef STATISTICS
	mp->cachehit = mp->cachemiss = mp->pagealloc = mp->pageflush = 
	    mp->pageget = mp->pagenew = mp->pageput = mp->pageread = 
	    mp->pagewrite = 0;
#endif
d104 2
a105 6
 * MPOOL_FILTER -- initialize input/output filters.
 *
 * Parameters:
 *	pgin:		Page in conversion routine.
 *	pgout:		Page out conversion routine.
 *	pgcookie:	Cookie for page in/out routines.
d120 2
a121 7
 * MPOOL_NEW -- get a new page
 *
 * Parameters:
 *	mp:		mpool cookie
 *	pgnoadddr:	place to store new page number
 * Returns:
 *	RET_ERROR, RET_SUCCESS
d128 2
a129 2
	BKT *b;
	BKTHDR *hp;
d131 4
d139 3
a141 2
	 * Get a BKT from the cache.  Assign a new page number, attach it to
	 * the hash and lru chains and return.
d143 1
a143 1
	if ((b = mpool_bkt(mp)) == NULL)
d145 7
a151 5
	*pgnoaddr = b->pgno = mp->npages++;
	b->flags = MPOOL_PINNED;
	inshash(b, b->pgno);
	inschain(b, &mp->lru);
	return (b->page);
d155 2
a156 9
 * MPOOL_GET -- get a page from the pool
 *
 * Parameters:
 *	mp:	mpool cookie
 *	pgno:	page number
 *	flags:	not used
 *
 * Returns:
 *	RET_ERROR, RET_SUCCESS
d162 1
a162 1
	u_int flags;		/* XXX not used? */
d164 2
a165 2
	BKT *b;
	BKTHDR *hp;
d169 6
a174 5
	/*
	 * If asking for a specific page that is already in the cache, find
	 * it and return it.
	 */
	if (b = mpool_look(mp, pgno)) {
d176 1
a176 1
		++mp->pageget;
d178 3
d182 19
a200 14
		if (b->flags & MPOOL_PINNED)
			__mpoolerr("mpool_get: page %d already pinned",
			    b->pgno);
#endif
		rmchain(b);
		inschain(b, &mp->lru);
		b->flags |= MPOOL_PINNED;
		return (b->page);
	}

	/* Not allowed to retrieve a non-existent page. */
	if (pgno >= mp->npages) {
		errno = EINVAL;
		return (NULL);
d204 1
a204 1
	if ((b = mpool_bkt(mp)) == NULL)
a205 2
	b->pgno = pgno;
	b->flags = MPOOL_PINNED;
d207 1
a210 1
	/* Read in the contents. */
d214 1
a214 1
	if ((nr = read(mp->fd, b->page, mp->pagesize)) != mp->pagesize) {
a218 2
	if (mp->pgin)
		(mp->pgin)(mp->pgcookie, b->pgno, b->page);
d220 17
a236 6
	inshash(b, b->pgno);
	inschain(b, &mp->lru);
#ifdef STATISTICS
	++mp->pageget;
#endif
	return (b->page);
d240 2
a241 9
 * MPOOL_PUT -- return a page to the pool
 *
 * Parameters:
 *	mp:	mpool cookie
 *	page:	page pointer
 *	pgno:	page number
 *
 * Returns:
 *	RET_ERROR, RET_SUCCESS
d249 1
a249 4
	BKT *baddr;
#ifdef DEBUG
	BKT *b;
#endif
d254 1
a254 1
	baddr = (BKT *)((char *)page - sizeof(BKT));
d256 4
a259 7
	if (!(baddr->flags & MPOOL_PINNED))
		__mpoolerr("mpool_put: page %d not pinned", b->pgno);
	for (b = mp->lru.cnext; b != (BKT *)&mp->lru; b = b->cnext) {
		if (b == (BKT *)&mp->lru)
			__mpoolerr("mpool_put: %0x: bad address", baddr);
		if (b == baddr)
			break;
d262 2
a263 2
	baddr->flags &= ~MPOOL_PINNED;
	baddr->flags |= flags & MPOOL_DIRTY;
d268 2
a269 7
 * MPOOL_CLOSE -- close the buffer pool
 *
 * Parameters:
 *	mp:	mpool cookie
 *
 * Returns:
 *	RET_ERROR, RET_SUCCESS
d275 1
a275 1
	BKT *b, *next;
d278 3
a280 3
	for (b = mp->lru.cprev; b != (BKT *)&mp->lru; b = next) {
		next = b->cprev;
		free(b);
d282 2
d289 2
a290 7
 * MPOOL_SYNC -- sync the file to disk.
 *
 * Parameters:
 *	mp:	mpool cookie
 *
 * Returns:
 *	RET_ERROR, RET_SUCCESS
d296 1
a296 1
	BKT *b;
d298 5
a302 2
	for (b = mp->lru.cprev; b != (BKT *)&mp->lru; b = b->cprev)
		if (b->flags & MPOOL_DIRTY && mpool_write(mp, b) == RET_ERROR)
d304 2
d310 2
a311 7
 * MPOOL_BKT -- get/create a BKT from the cache
 *
 * Parameters:
 *	mp:	mpool cookie
 *
 * Returns:
 *	NULL on failure and a pointer to the BKT on success	
d317 2
a318 1
	BKT *b;
d320 1
d325 3
a327 3
	 * If the cache is maxxed out, search the lru list for a buffer we
	 * can flush.  If we find one, write it if necessary and take it off
	 * any lists.  If we don't find anything we grow the cache anyway.
d330 6
a335 4
	for (b = mp->lru.cprev; b != (BKT *)&mp->lru; b = b->cprev)
		if (!(b->flags & MPOOL_PINNED)) {
			if (b->flags & MPOOL_DIRTY &&
			    mpool_write(mp, b) == RET_ERROR)
a336 2
			rmhash(b);
			rmchain(b);
d340 4
d345 4
a348 5
			{
				void *spage;
				spage = b->page;
				memset(b, 0xff, sizeof(BKT) + mp->pagesize);
				b->page = spage;
d351 1
a351 1
			return (b);
d354 1
a354 1
new:	if ((b = (BKT *)malloc(sizeof(BKT) + mp->pagesize)) == NULL)
d359 2
a360 2
#ifdef DEBUG
	memset(b, 0xff, sizeof(BKT) + mp->pagesize);
d362 1
a362 1
	b->page = (char *)b + sizeof(BKT);
d364 1
a364 1
	return (b);
d368 2
a369 7
 * MPOOL_WRITE -- sync a page to disk
 *
 * Parameters:
 *	mp:	mpool cookie
 *
 * Returns:
 *	RET_ERROR, RET_SUCCESS
d372 1
a372 1
mpool_write(mp, b)
d374 1
a374 1
	BKT *b;
a377 3
	if (mp->pgout)
		(mp->pgout)(mp->pgcookie, b->pgno, b->page);

d381 6
a386 1
	off = mp->pagesize * b->pgno;
d389 1
a389 1
	if (write(mp->fd, b->page, mp->pagesize) != mp->pagesize)
d391 2
a392 1
	b->flags &= ~MPOOL_DIRTY;
d397 2
a398 8
 * MPOOL_LOOK -- lookup a page
 *
 * Parameters:
 *	mp:	mpool cookie
 *	pgno:	page number
 *
 * Returns:
 *	NULL on failure and a pointer to the BKT on success
d405 2
a406 2
	register BKT *b;
	register BKTHDR *tb;
d408 3
a410 7
	/* XXX
	 * If find the buffer, put it first on the hash chain so can
	 * find it again quickly.
	 */
	tb = &mp->hashtable[HASHKEY(pgno)];
	for (b = tb->hnext; b != (BKT *)tb; b = b->hnext)
		if (b->pgno == pgno) {
d414 1
a414 1
			return (b);
d424 2
a425 4
 * MPOOL_STAT -- cache statistics
 *
 * Parameters:
 *	mp:	mpool cookie
d431 1
a431 1
	BKT *b;
d453 4
a456 3
	for (b = mp->lru.cnext; b != (BKT *)&mp->lru; b = b->cnext) {
		(void)fprintf(stderr, "%s%d", sep, b->pgno);
		if (b->flags & MPOOL_DIRTY)
d458 1
a458 1
		if (b->flags & MPOOL_PINNED)
a467 30
}
#endif

#ifdef DEBUG
#if __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

static void
#if __STDC__
__mpoolerr(const char *fmt, ...)
#else
__mpoolerr(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
{
	va_list ap;
#if __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
	abort();
	/* NOTREACHED */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
