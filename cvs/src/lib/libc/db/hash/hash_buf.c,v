head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.8
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.26
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.24
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.20
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.18
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.16
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.14
	OPENBSD_5_0:1.18.0.12
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.10
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.8
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.4
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.16.0.14
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.12
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.10
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.8
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	0DYulI8hhujBHMcR;

1.18
date	2008.10.01.20.22.47;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.01.19.56.57;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.05.13.03.00;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.23.19.34.59;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.03.22.46.43;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.01.14.01.18;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.18.33;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.01.20.23.40;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.25.23.45.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.03.18.16.48;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.02.15.05.11.24;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.08.28.20.49.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.03.05.20.42.56;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.10.14.22.17.27;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.20.35;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.05.07.09.01.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.49;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@/*	$OpenBSD: hash_buf.c,v 1.18 2008/10/01 20:22:47 millert Exp $	*/

/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Margo Seltzer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * PACKAGE: hash
 *
 * DESCRIPTION:
 *	Contains buffer management
 *
 * ROUTINES:
 * External
 *	__buf_init
 *	__get_buf
 *	__buf_free
 *	__reclaim_buf
 * Internal
 *	newbuf
 */

#include <errno.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef DEBUG
#include <assert.h>
#endif

#include <db.h>
#include "hash.h"
#include "page.h"
#include "extern.h"

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

static BUFHEAD *newbuf(HTAB *, u_int32_t, BUFHEAD *);

/* Unlink B from its place in the lru */
#define BUF_REMOVE(B) { \
	(B)->prev->next = (B)->next; \
	(B)->next->prev = (B)->prev; \
}

/* Insert B after P */
#define BUF_INSERT(B, P) { \
	(B)->next = (P)->next; \
	(B)->prev = (P); \
	(P)->next = (B); \
	(B)->next->prev = (B); \
}

#define	MRU	hashp->bufhead.next
#define	LRU	hashp->bufhead.prev

#define MRU_INSERT(B)	BUF_INSERT((B), &hashp->bufhead)
#define LRU_INSERT(B)	BUF_INSERT((B), LRU)

/*
 * We are looking for a buffer with address "addr".  If prev_bp is NULL, then
 * address is a bucket index.  If prev_bp is not NULL, then it points to the
 * page previous to an overflow page that we are trying to find.
 *
 * CAVEAT:  The buffer header accessed via prev_bp's ovfl field may no longer
 * be valid.  Therefore, you must always verify that its address matches the
 * address you are seeking.
 */
BUFHEAD *
__get_buf(HTAB *hashp, u_int32_t addr,
    BUFHEAD *prev_bp,	/* If prev_bp set, indicates a new overflow page. */
    int newpage)
{
	BUFHEAD *bp;
	u_int32_t is_disk_mask;
	int is_disk, segment_ndx;
	SEGMENT segp;

	is_disk = 0;
	is_disk_mask = 0;
	if (prev_bp) {
		bp = prev_bp->ovfl;
		if (!bp || (bp->addr != addr))
			bp = NULL;
		if (!newpage)
			is_disk = BUF_DISK;
	} else {
		/* Grab buffer out of directory */
		segment_ndx = addr & (hashp->SGSIZE - 1);

		/* valid segment ensured by __call_hash() */
		segp = hashp->dir[addr >> hashp->SSHIFT];
#ifdef DEBUG
		assert(segp != NULL);
#endif
		bp = PTROF(segp[segment_ndx]);
		is_disk_mask = ISDISK(segp[segment_ndx]);
		is_disk = is_disk_mask || !hashp->new_file;
	}

	if (!bp) {
		bp = newbuf(hashp, addr, prev_bp);
		if (!bp ||
		    __get_page(hashp, bp->page, addr, !prev_bp, is_disk, 0))
			return (NULL);
		if (!prev_bp)
			segp[segment_ndx] =
			    (BUFHEAD *)((ptrdiff_t)bp | is_disk_mask);
	} else {
		BUF_REMOVE(bp);
		MRU_INSERT(bp);
	}
	return (bp);
}

/*
 * We need a buffer for this page. Either allocate one, or evict a resident
 * one (if we have as many buffers as we're allowed) and put this one in.
 *
 * If newbuf finds an error (returning NULL), it also sets errno.
 */
static BUFHEAD *
newbuf(HTAB *hashp, u_int32_t addr, BUFHEAD *prev_bp)
{
	BUFHEAD *bp;		/* The buffer we're going to use */
	BUFHEAD *xbp;		/* Temp pointer */
	BUFHEAD *next_xbp;
	SEGMENT segp;
	int segment_ndx;
	u_int16_t oaddr, *shortp;

	oaddr = 0;
	bp = LRU;

        /* It is bad to overwrite the page under the cursor. */
        if (bp == hashp->cpage) {
                BUF_REMOVE(bp);
                MRU_INSERT(bp);
                bp = LRU;
        }

	/* If prev_bp is part of bp overflow, create a new buffer. */
	if (hashp->nbufs == 0 && prev_bp && bp->ovfl) {
		BUFHEAD *ovfl;

		for (ovfl = bp->ovfl; ovfl ; ovfl = ovfl->ovfl) {
			if (ovfl == prev_bp) {
				hashp->nbufs++;
				break;
			}
		}
	}

	/*
	 * If LRU buffer is pinned, the buffer pool is too small. We need to
	 * allocate more buffers.
	 */
	if (hashp->nbufs || (bp->flags & BUF_PIN) || bp == hashp->cpage) {
		/* Allocate a new one */
		if ((bp = (BUFHEAD *)malloc(sizeof(BUFHEAD))) == NULL)
			return (NULL);
		memset(bp, 0xff, sizeof(BUFHEAD));
		if ((bp->page = (char *)malloc(hashp->BSIZE)) == NULL) {
			free(bp);
			return (NULL);
		}
		memset(bp->page, 0xff, hashp->BSIZE);
		if (hashp->nbufs)
			hashp->nbufs--;
	} else {
		/* Kick someone out */
		BUF_REMOVE(bp);
		/*
		 * If this is an overflow page with addr 0, it's already been
		 * flushed back in an overflow chain and initialized.
		 */
		if ((bp->addr != 0) || (bp->flags & BUF_BUCKET)) {
			/*
			 * Set oaddr before __put_page so that you get it
			 * before bytes are swapped.
			 */
			shortp = (u_int16_t *)bp->page;
			if (shortp[0])
				oaddr = shortp[shortp[0] - 1];
			if ((bp->flags & BUF_MOD) && __put_page(hashp, bp->page,
			    bp->addr, (int)IS_BUCKET(bp->flags), 0))
				return (NULL);
			/*
			 * Update the pointer to this page (i.e. invalidate it).
			 *
			 * If this is a new file (i.e. we created it at open
			 * time), make sure that we mark pages which have been
			 * written to disk so we retrieve them from disk later,
			 * rather than allocating new pages.
			 */
			if (IS_BUCKET(bp->flags)) {
				segment_ndx = bp->addr & (hashp->SGSIZE - 1);
				segp = hashp->dir[bp->addr >> hashp->SSHIFT];
#ifdef DEBUG
				assert(segp != NULL);
#endif

				if (hashp->new_file &&
				    ((bp->flags & BUF_MOD) ||
				    ISDISK(segp[segment_ndx])))
					segp[segment_ndx] = (BUFHEAD *)BUF_DISK;
				else
					segp[segment_ndx] = NULL;
			}
			/*
			 * Since overflow pages can only be access by means of
			 * their bucket, free overflow pages associated with
			 * this bucket.
			 */
			for (xbp = bp; xbp->ovfl;) {
				next_xbp = xbp->ovfl;
				xbp->ovfl = 0;
				xbp = next_xbp;

				/* Check that ovfl pointer is up date. */
				if (IS_BUCKET(xbp->flags) ||
				    (oaddr != xbp->addr))
					break;

				shortp = (u_int16_t *)xbp->page;
				if (shortp[0])
					/* set before __put_page */
					oaddr = shortp[shortp[0] - 1];
				if ((xbp->flags & BUF_MOD) && __put_page(hashp,
				    xbp->page, xbp->addr, 0, 0))
					return (NULL);
				xbp->addr = 0;
				xbp->flags = 0;
				BUF_REMOVE(xbp);
				LRU_INSERT(xbp);
			}
		}
	}

	/* Now assign this buffer */
	bp->addr = addr;
#ifdef DEBUG1
	(void)fprintf(stderr, "NEWBUF1: %d->ovfl was %d is now %d\n",
	    bp->addr, (bp->ovfl ? bp->ovfl->addr : 0), 0);
#endif
	bp->ovfl = NULL;
	if (prev_bp) {
		/*
		 * If prev_bp is set, this is an overflow page, hook it in to
		 * the buffer overflow links.
		 */
#ifdef DEBUG1
		(void)fprintf(stderr, "NEWBUF2: %d->ovfl was %d is now %d\n",
		    prev_bp->addr, (prev_bp->ovfl ? prev_bp->ovfl->addr : 0),
		    (bp ? bp->addr : 0));
#endif
		prev_bp->ovfl = bp;
		bp->flags = 0;
	} else
		bp->flags = BUF_BUCKET;
	MRU_INSERT(bp);
	return (bp);
}

void
__buf_init(HTAB *hashp, int nbytes)
{
	BUFHEAD *bfp;
	int npages;

	bfp = &(hashp->bufhead);
	npages = (nbytes + hashp->BSIZE - 1) >> hashp->BSHIFT;
	npages = MAXIMUM(npages, MIN_BUFFERS);

	hashp->nbufs = npages;
	bfp->next = bfp;
	bfp->prev = bfp;
	/*
	 * This space is calloc'd so these are already null.
	 *
	 * bfp->ovfl = NULL;
	 * bfp->flags = 0;
	 * bfp->page = NULL;
	 * bfp->addr = 0;
	 */
}

int
__buf_free(HTAB *hashp, int do_free, int to_disk)
{
	BUFHEAD *bp;

	/* Need to make sure that buffer manager has been initialized */
	if (!LRU)
		return (0);
	for (bp = LRU; bp != &hashp->bufhead;) {
		/* Check that the buffer is valid */
		if (bp->addr || IS_BUCKET(bp->flags)) {
			if (to_disk && (bp->flags & BUF_MOD) &&
			    __put_page(hashp, bp->page,
			    bp->addr, IS_BUCKET(bp->flags), 0))
				return (-1);
		}
		/* Check if we are freeing stuff */
		if (do_free) {
			if (bp->page) {
				(void)memset(bp->page, 0, hashp->BSIZE);
				free(bp->page);
			}
			BUF_REMOVE(bp);
			free(bp);
			bp = LRU;
		} else
			bp = bp->prev;
	}
	return (0);
}

void
__reclaim_buf(HTAB *hashp, BUFHEAD *bp)
{
	bp->ovfl = 0;
	bp->addr = 0;
	bp->flags = 0;
	BUF_REMOVE(bp);
	LRU_INSERT(bp);
}
@


1.18
log
@Simplify the loop used for bp overflow detection to match what I'm
using on the list server.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.17 2008/10/01 19:56:57 millert Exp $	*/
a50 2
#include <sys/param.h>

d66 2
d303 1
a303 1
	npages = MAX(npages, MIN_BUFFERS);
@


1.17
log
@Fix for sequential retrieval failure when using large key/data pairs.
Closes PR 2764.  Has been running on the list server for years.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.16 2005/08/05 13:03:00 espie Exp $	*/
d173 2
a174 2
	if (hashp->nbufs == 0 && (prev_bp && bp->ovfl)) {
		BUFHEAD *ovfl_head, *ovfl_next;
d176 2
a177 4
		ovfl_head = bp->ovfl; 
		ovfl_next = ovfl_head;
		while (ovfl_next) {
			if (ovfl_next == prev_bp) {
a180 1
			ovfl_next = ovfl_next->ovfl;
@


1.16
log
@zap rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.15 2005/03/23 19:34:59 otto Exp $	*/
d171 15
@


1.15
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.14 2005/01/03 22:46:43 millert Exp $	*/
a33 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)hash_buf.c	8.5 (Berkeley) 7/15/94";
#else
static const char rcsid[] = "$OpenBSD: hash_buf.c,v 1.14 2005/01/03 22:46:43 millert Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.14
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.13 2004/10/01 14:01:18 otto Exp $	*/
d39 1
a39 1
static const char rcsid[] = "$OpenBSD: hash_buf.c,v 1.13 2004/10/01 14:01:18 otto Exp $";
d107 4
a110 6
extern BUFHEAD *
__get_buf(hashp, addr, prev_bp, newpage)
	HTAB *hashp;
	u_int32_t addr;
	BUFHEAD *prev_bp;
	int newpage;	/* If prev_bp set, indicates a new overflow page. */
d161 1
a161 4
newbuf(hashp, addr, prev_bp)
	HTAB *hashp;
	u_int32_t addr;
	BUFHEAD *prev_bp;
d291 2
a292 4
extern void
__buf_init(hashp, nbytes)
	HTAB *hashp;
	int nbytes;
d314 2
a315 4
extern int
__buf_free(hashp, do_free, to_disk)
	HTAB *hashp;
	int do_free, to_disk;
d345 2
a346 4
extern void
__reclaim_buf(hashp, bp)
	HTAB *hashp;
	BUFHEAD *bp;
@


1.13
log
@Avoid overwriting the cursor page when the cursor page becomes the
LRU page. From pacman at manson dot clss dot net.
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.12 2003/06/02 20:18:33 millert Exp $	*/
d39 1
a39 1
static const char rcsid[] = "$OpenBSD: hash_buf.c,v 1.12 2003/06/02 20:18:33 millert Exp $";
d114 3
a116 3
	register BUFHEAD *bp;
	register u_int32_t is_disk_mask;
	register int is_disk, segment_ndx;
d168 3
a170 3
	register BUFHEAD *bp;		/* The buffer we're going to use */
	register BUFHEAD *xbp;		/* Temp pointer */
	register BUFHEAD *next_xbp;
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.11 2003/05/01 20:23:40 avsm Exp $	*/
d39 1
a39 1
static const char rcsid[] = "$OpenBSD: hash_buf.c,v 1.11 2003/05/01 20:23:40 avsm Exp $";
d177 8
d189 1
a189 1
	if (hashp->nbufs || (bp->flags & BUF_PIN)) {
@


1.11
log
@-Wall cleanup, make rcsid variables const
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.10 2002/02/25 23:45:15 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
static const char rcsid[] = "$OpenBSD: hash_buf.c,v 1.10 2002/02/25 23:45:15 millert Exp $";
@


1.10
log
@Cosmetic changes such as correct printf format specifiers on LP64
machines and whitespace nits.  Some from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.9 2002/02/16 21:27:22 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: hash_buf.c,v 1.9 2002/02/16 21:27:22 millert Exp $";
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.8 2000/10/03 18:16:48 mickey Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: hash_buf.c,v 1.8 2000/10/03 18:16:48 mickey Exp $";
a268 1
	bp->ovfl = NULL;
d273 1
a278 1
		prev_bp->ovfl = bp;
d284 1
@


1.8
log
@bt_open.c: parenthesize - and & proper (from freebsd);
hash_bigkey.c: fix NULL dereference exposed on big bsize values;
hash_buf.c: fix DEBUG1 cases to make them print, not crash;
hash.3: document real default values for bsize and ffactor.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_buf.c,v 1.7 1999/02/15 05:11:24 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: hash_buf.c,v 1.7 1999/02/15 05:11:24 millert Exp $";
d80 1
a80 1
static BUFHEAD *newbuf __P((HTAB *, u_int32_t, BUFHEAD *));
@


1.7
log
@ o Minor changes from db.1.86 (sleepycat).  Does not include the new hash
   routines since they cannot read a hashed .db file from the old code.
   Most of these files just have their RCS/SCCS tags standardized.
   Note that mpool.3 has not been updated to reflect the new mpool interface.
 o Add a real dbm(3) manpage
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: hash_buf.c,v 1.6 1998/08/28 20:49:10 deraadt Exp $";
d269 1
a273 1
	bp->ovfl = NULL;
d279 1
d282 1
a282 1
		    prev_bp->addr, (prev_bp->ovfl ? bp->ovfl->addr : 0),
a284 1
		prev_bp->ovfl = bp;
@


1.6
log
@do not toss memory dribble into the output files (small performance loss)
@
text
@d1 2
d40 5
a44 1
static char rcsid[] = "$OpenBSD: hash_buf.c,v 1.5 1998/03/05 20:42:56 deraadt Exp $";
@


1.5
log
@string.h for memset proto
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: hash_buf.c,v 1.4 1996/10/14 22:17:27 downsj Exp $";
a182 1
#ifdef PURIFY
a183 1
#endif
a187 1
#ifdef PURIFY
a188 1
#endif
@


1.4
log
@zero out the page
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: hash_buf.c,v 1.3 1996/08/19 08:20:35 tholo Exp $";
d63 1
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: hash_buf.c,v 1.6 1996/05/03 21:43:51 cgd Exp $";
d334 2
a335 1
			if (bp->page)
d337 1
@


1.2
log
@db release 1.85
@
text
@a0 2
/*	$NetBSD: hash_buf.c,v 1.6 1996/05/03 21:43:51 cgd Exp $	*/

d38 1
a38 5
#if 0
static char sccsid[] = "@@(#)hash_buf.c	8.5 (Berkeley) 7/15/94";
#else
static char rcsid[] = "$NetBSD: hash_buf.c,v 1.6 1996/05/03 21:43:51 cgd Exp $";
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: hash_buf.c,v 1.5 1995/02/27 13:22:23 cgd Exp $	*/
d41 1
a41 1
static char sccsid[] = "@@(#)hash_buf.c	8.4 (Berkeley) 6/4/94";
d43 1
a43 1
static char rcsid[] = "$NetBSD: hash_buf.c,v 1.5 1995/02/27 13:22:23 cgd Exp $";
d188 3
d195 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

