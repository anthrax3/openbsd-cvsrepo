head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.6
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.36
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.34
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.30
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.28
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.26
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.24
	OPENBSD_5_0:1.17.0.22
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.20
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.18
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.14
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.16
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.12.28.22.08.18;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	0uXuF2O13NH9q2e1;

1.18
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	0DYulI8hhujBHMcR;

1.17
date	2006.04.03.19.56.47;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.05.13.03.00;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.23.19.34.59;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.03.22.46.43;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.06.21.08.05;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.18.33;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.01.20.23.40;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.25.23.45.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.01.18.15.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.03.18.16.48;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.02.15.05.11.24;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.03.19.00.29.56;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.09.30.48;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.20.34;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.05.07.09.01.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.49;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove NULL-checks before free() and a few related dead assignments.

ok and valuable input from millert@@
@
text
@/*	$OpenBSD: hash_bigkey.c,v 1.18 2015/01/16 16:48:51 deraadt Exp $	*/

/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Margo Seltzer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * PACKAGE: hash
 * DESCRIPTION:
 *	Big key/data handling for the hashing package.
 *
 * ROUTINES:
 * External
 *	__big_keydata
 *	__big_split
 *	__big_insert
 *	__big_return
 *	__big_delete
 *	__find_last_page
 * Internal
 *	collect_key
 *	collect_data
 */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef DEBUG
#include <assert.h>
#endif

#include <db.h>
#include "hash.h"
#include "page.h"
#include "extern.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

static int collect_key(HTAB *, BUFHEAD *, int, DBT *, int);
static int collect_data(HTAB *, BUFHEAD *, int, int);

/*
 * Big_insert
 *
 * You need to do an insert and the key/data pair is too big
 *
 * Returns:
 * 0 ==> OK
 *-1 ==> ERROR
 */
int
__big_insert(HTAB *hashp, BUFHEAD *bufp, const DBT *key, const DBT *val)
{
	u_int16_t *p;
	int key_size, n, val_size;
	u_int16_t space, move_bytes, off;
	char *cp, *key_data, *val_data;

	cp = bufp->page;		/* Character pointer of p. */
	p = (u_int16_t *)cp;

	key_data = (char *)key->data;
	key_size = key->size;
	val_data = (char *)val->data;
	val_size = val->size;

	/* First move the Key */
	for (space = FREESPACE(p) - BIGOVERHEAD; key_size;
	    space = FREESPACE(p) - BIGOVERHEAD) {
		move_bytes = MINIMUM(space, key_size);
		off = OFFSET(p) - move_bytes;
		memmove(cp + off, key_data, move_bytes);
		key_size -= move_bytes;
		key_data += move_bytes;
		n = p[0];
		p[++n] = off;
		p[0] = ++n;
		FREESPACE(p) = off - PAGE_META(n);
		OFFSET(p) = off;
		p[n] = PARTIAL_KEY;
		bufp = __add_ovflpage(hashp, bufp);
		if (!bufp)
			return (-1);
		n = p[0];
		if (!key_size) {
			space = FREESPACE(p);
			if (space) {
				move_bytes = MINIMUM(space, val_size);
				/*
				 * If the data would fit exactly in the
				 * remaining space, we must overflow it to the
				 * next page; otherwise the invariant that the
				 * data must end on a page with FREESPACE
				 * non-zero would fail.
				 */
				if (space == val_size && val_size == val->size)
					goto toolarge;
				off = OFFSET(p) - move_bytes;
				memmove(cp + off, val_data, move_bytes);
				val_data += move_bytes;
				val_size -= move_bytes;
				p[n] = off;
				p[n - 2] = FULL_KEY_DATA;
				FREESPACE(p) = FREESPACE(p) - move_bytes;
				OFFSET(p) = off;
			} else {
			toolarge:
				p[n - 2] = FULL_KEY;
			}
		}
		p = (u_int16_t *)bufp->page;
		cp = bufp->page;
		bufp->flags |= BUF_MOD;
	}

	/* Now move the data */
	for (space = FREESPACE(p) - BIGOVERHEAD; val_size;
	    space = FREESPACE(p) - BIGOVERHEAD) {
		move_bytes = MINIMUM(space, val_size);
		/*
		 * Here's the hack to make sure that if the data ends on the
		 * same page as the key ends, FREESPACE is at least one.
		 */
		if (space == val_size && val_size == val->size)
			move_bytes--;
		off = OFFSET(p) - move_bytes;
		memmove(cp + off, val_data, move_bytes);
		val_size -= move_bytes;
		val_data += move_bytes;
		n = p[0];
		p[++n] = off;
		p[0] = ++n;
		FREESPACE(p) = off - PAGE_META(n);
		OFFSET(p) = off;
		if (val_size) {
			p[n] = FULL_KEY;
			bufp = __add_ovflpage(hashp, bufp);
			if (!bufp)
				return (-1);
			cp = bufp->page;
			p = (u_int16_t *)cp;
		} else
			p[n] = FULL_KEY_DATA;
		bufp->flags |= BUF_MOD;
	}
	return (0);
}

/*
 * Called when bufp's page  contains a partial key (index should be 1)
 *
 * All pages in the big key/data pair except bufp are freed.  We cannot
 * free bufp because the page pointing to it is lost and we can't get rid
 * of its pointer.
 *
 * Returns:
 * 0 => OK
 *-1 => ERROR
 */
int
__big_delete(HTAB *hashp, BUFHEAD *bufp)
{
	BUFHEAD *last_bfp, *rbufp;
	u_int16_t *bp, pageno;
	int key_done, n;

	rbufp = bufp;
	last_bfp = NULL;
	bp = (u_int16_t *)bufp->page;
	pageno = 0;
	key_done = 0;

	while (!key_done || (bp[2] != FULL_KEY_DATA)) {
		if (bp[2] == FULL_KEY || bp[2] == FULL_KEY_DATA)
			key_done = 1;

		/*
		 * If there is freespace left on a FULL_KEY_DATA page, then
		 * the data is short and fits entirely on this page, and this
		 * is the last page.
		 */
		if (bp[2] == FULL_KEY_DATA && FREESPACE(bp))
			break;
		pageno = bp[bp[0] - 1];
		rbufp->flags |= BUF_MOD;
		rbufp = __get_buf(hashp, pageno, rbufp, 0);
		if (last_bfp)
			__free_ovflpage(hashp, last_bfp);
		last_bfp = rbufp;
		if (!rbufp)
			return (-1);		/* Error. */
		bp = (u_int16_t *)rbufp->page;
	}

	/*
	 * If we get here then rbufp points to the last page of the big
	 * key/data pair.  Bufp points to the first one -- it should now be
	 * empty pointing to the next page after this pair.  Can't free it
	 * because we don't have the page pointing to it.
	 */

	/* This is information from the last page of the pair. */
	n = bp[0];
	pageno = bp[n - 1];

	/* Now, bp is the first page of the pair. */
	bp = (u_int16_t *)bufp->page;
	if (n > 2) {
		/* There is an overflow page. */
		bp[1] = pageno;
		bp[2] = OVFLPAGE;
		bufp->ovfl = rbufp->ovfl;
	} else
		/* This is the last page. */
		bufp->ovfl = NULL;
	n -= 2;
	bp[0] = n;
	FREESPACE(bp) = hashp->BSIZE - PAGE_META(n);
	OFFSET(bp) = hashp->BSIZE;

	bufp->flags |= BUF_MOD;
	if (rbufp)
		__free_ovflpage(hashp, rbufp);
	if (last_bfp && last_bfp != rbufp)
		__free_ovflpage(hashp, last_bfp);

	hashp->NKEYS--;
	return (0);
}
/*
 * Returns:
 *  0 = key not found
 * -1 = get next overflow page
 * -2 means key not found and this is big key/data
 * -3 error
 */
int
__find_bigpair(HTAB *hashp, BUFHEAD *bufp, int ndx, char *key, int size)
{
	u_int16_t *bp;
	char *p;
	int ksize;
	u_int16_t bytes;
	char *kkey;

	bp = (u_int16_t *)bufp->page;
	p = bufp->page;
	ksize = size;
	kkey = key;

	for (bytes = hashp->BSIZE - bp[ndx];
	    bytes <= size && bp[ndx + 1] == PARTIAL_KEY;
	    bytes = hashp->BSIZE - bp[ndx]) {
		if (memcmp(p + bp[ndx], kkey, bytes))
			return (-2);
		kkey += bytes;
		ksize -= bytes;
		bufp = __get_buf(hashp, bp[ndx + 2], bufp, 0);
		if (!bufp)
			return (-3);
		p = bufp->page;
		bp = (u_int16_t *)p;
		ndx = 1;
	}

	if (bytes != ksize || memcmp(p + bp[ndx], kkey, bytes)) {
#ifdef HASH_STATISTICS
		++hash_collisions;
#endif
		return (-2);
	} else
		return (ndx);
}

/*
 * Given the buffer pointer of the first overflow page of a big pair,
 * find the end of the big pair
 *
 * This will set bpp to the buffer header of the last page of the big pair.
 * It will return the pageno of the overflow page following the last page
 * of the pair; 0 if there isn't any (i.e. big pair is the last key in the
 * bucket)
 */
u_int16_t
__find_last_page(HTAB *hashp, BUFHEAD **bpp)
{
	BUFHEAD *bufp;
	u_int16_t *bp, pageno;
	int n;

	bufp = *bpp;
	bp = (u_int16_t *)bufp->page;
	for (;;) {
		n = bp[0];

		/*
		 * This is the last page if: the tag is FULL_KEY_DATA and
		 * either only 2 entries OVFLPAGE marker is explicit there
		 * is freespace on the page.
		 */
		if (bp[2] == FULL_KEY_DATA &&
		    ((n == 2) || (bp[n] == OVFLPAGE) || (FREESPACE(bp))))
			break;

		pageno = bp[n - 1];
		bufp = __get_buf(hashp, pageno, bufp, 0);
		if (!bufp)
			return (0);	/* Need to indicate an error! */
		bp = (u_int16_t *)bufp->page;
	}

	*bpp = bufp;
	if (bp[0] > 2)
		return (bp[3]);
	else
		return (0);
}

/*
 * Return the data for the key/data pair that begins on this page at this
 * index (index should always be 1).
 */
int
__big_return(HTAB *hashp, BUFHEAD *bufp, int ndx, DBT *val, int set_current)
{
	BUFHEAD *save_p;
	u_int16_t *bp, len, off, save_addr;
	char *tp;

	bp = (u_int16_t *)bufp->page;
	while (bp[ndx + 1] == PARTIAL_KEY) {
		bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
		if (!bufp)
			return (-1);
		bp = (u_int16_t *)bufp->page;
		ndx = 1;
	}

	if (bp[ndx + 1] == FULL_KEY) {
		bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
		if (!bufp)
			return (-1);
		bp = (u_int16_t *)bufp->page;
		save_p = bufp;
		save_addr = save_p->addr;
		off = bp[1];
		len = 0;
	} else
		if (!FREESPACE(bp)) {
			/*
			 * This is a hack.  We can't distinguish between
			 * FULL_KEY_DATA that contains complete data or
			 * incomplete data, so we require that if the data
			 * is complete, there is at least 1 byte of free
			 * space left.
			 */
			off = bp[bp[0]];
			len = bp[1] - off;
			save_p = bufp;
			save_addr = bufp->addr;
			bufp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
			if (!bufp)
				return (-1);
			bp = (u_int16_t *)bufp->page;
		} else {
			/* The data is all on one page. */
			tp = (char *)bp;
			off = bp[bp[0]];
			val->data = (u_char *)tp + off;
			val->size = bp[1] - off;
			if (set_current) {
				if (bp[0] == 2) {	/* No more buckets in
							 * chain */
					hashp->cpage = NULL;
					hashp->cbucket++;
					hashp->cndx = 1;
				} else {
					hashp->cpage = __get_buf(hashp,
					    bp[bp[0] - 1], bufp, 0);
					if (!hashp->cpage)
						return (-1);
					hashp->cndx = 1;
					if (!((u_int16_t *)
					    hashp->cpage->page)[0]) {
						hashp->cbucket++;
						hashp->cpage = NULL;
					}
				}
			}
			return (0);
		}

	val->size = (size_t)collect_data(hashp, bufp, (int)len, set_current);
	if (val->size == (size_t)-1)
		return (-1);
	if (save_p->addr != save_addr) {
		/* We are pretty short on buffers. */
		errno = EINVAL;			/* OUT OF BUFFERS */
		return (-1);
	}
	memmove(hashp->tmp_buf, (save_p->page) + off, len);
	val->data = (u_char *)hashp->tmp_buf;
	return (0);
}
/*
 * Count how big the total datasize is by recursing through the pages.  Then
 * allocate a buffer and copy the data as you recurse up.
 */
static int
collect_data(HTAB *hashp, BUFHEAD *bufp, int len, int set)
{
	u_int16_t *bp;
	char *p;
	BUFHEAD *xbp;
	u_int16_t save_addr;
	int mylen, totlen;

	p = bufp->page;
	bp = (u_int16_t *)p;
	mylen = hashp->BSIZE - bp[1];
	save_addr = bufp->addr;

	if (bp[2] == FULL_KEY_DATA) {		/* End of Data */
		totlen = len + mylen;
		free(hashp->tmp_buf);
		if ((hashp->tmp_buf = (char *)malloc(totlen)) == NULL)
			return (-1);
		if (set) {
			hashp->cndx = 1;
			if (bp[0] == 2) {	/* No more buckets in chain */
				hashp->cpage = NULL;
				hashp->cbucket++;
			} else {
				hashp->cpage =
				    __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
				if (!hashp->cpage)
					return (-1);
				else if (!((u_int16_t *)hashp->cpage->page)[0]) {
					hashp->cbucket++;
					hashp->cpage = NULL;
				}
			}
		}
	} else {
		xbp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
		if (!xbp || ((totlen =
		    collect_data(hashp, xbp, len + mylen, set)) < 1))
			return (-1);
	}
	if (bufp->addr != save_addr) {
		errno = EINVAL;			/* Out of buffers. */
		return (-1);
	}
	memmove(&hashp->tmp_buf[len], (bufp->page) + bp[1], mylen);
	return (totlen);
}

/*
 * Fill in the key and data for this big pair.
 */
int
__big_keydata(HTAB *hashp, BUFHEAD *bufp, DBT *key, DBT *val, int set)
{
	key->size = (size_t)collect_key(hashp, bufp, 0, val, set);
	if (key->size == (size_t)-1)
		return (-1);
	key->data = (u_char *)hashp->tmp_key;
	return (0);
}

/*
 * Count how big the total key size is by recursing through the pages.  Then
 * collect the data, allocate a buffer and copy the key as you recurse up.
 */
static int
collect_key(HTAB *hashp, BUFHEAD *bufp, int len, DBT *val, int set)
{
	BUFHEAD *xbp;
	char *p;
	int mylen, totlen;
	u_int16_t *bp, save_addr;

	p = bufp->page;
	bp = (u_int16_t *)p;
	mylen = hashp->BSIZE - bp[1];

	save_addr = bufp->addr;
	totlen = len + mylen;
	if (bp[2] == FULL_KEY || bp[2] == FULL_KEY_DATA) {    /* End of Key. */
		free(hashp->tmp_key);
		if ((hashp->tmp_key = (char *)malloc(totlen)) == NULL)
			return (-1);
		if (__big_return(hashp, bufp, 1, val, set))
			return (-1);
	} else {
		xbp = __get_buf(hashp, bp[bp[0] - 1], bufp, 0);
		if (!xbp || ((totlen =
		    collect_key(hashp, xbp, totlen, val, set)) < 1))
			return (-1);
	}
	if (bufp->addr != save_addr) {
		errno = EINVAL;		/* MIS -- OUT OF BUFFERS */
		return (-1);
	}
	memmove(&hashp->tmp_key[len], (bufp->page) + bp[1], mylen);
	return (totlen);
}

/*
 * Returns:
 *  0 => OK
 * -1 => error
 */
int
__big_split(HTAB *hashp,
    BUFHEAD *op,	/* Pointer to where to put keys that go in old bucket */
    BUFHEAD *np,	/* Pointer to new bucket page */
    BUFHEAD *big_keyp,	/* Pointer to first page containing the big key/data */
    int addr,		/* Address of big_keyp */
    u_int32_t obucket,	/* Old Bucket */
    SPLIT_RETURN *ret)
{
	BUFHEAD *bp, *tmpp;
	DBT key, val;
	u_int32_t change;
	u_int16_t free_space, n, off, *tp;

	bp = big_keyp;

	/* Now figure out where the big key/data goes */
	if (__big_keydata(hashp, big_keyp, &key, &val, 0))
		return (-1);
	change = (__call_hash(hashp, key.data, key.size) != obucket);

	if ((ret->next_addr = __find_last_page(hashp, &big_keyp))) {
		if (!(ret->nextp =
		    __get_buf(hashp, ret->next_addr, big_keyp, 0)))
			return (-1);
	} else
		ret->nextp = NULL;

	/* Now make one of np/op point to the big key/data pair */
#ifdef DEBUG
	assert(np->ovfl == NULL);
#endif
	if (change)
		tmpp = np;
	else
		tmpp = op;

	tmpp->flags |= BUF_MOD;
#ifdef DEBUG1
	(void)fprintf(stderr,
	    "BIG_SPLIT: %d->ovfl was %d is now %d\n", tmpp->addr,
	    (tmpp->ovfl ? tmpp->ovfl->addr : 0), (bp ? bp->addr : 0));
#endif
	tmpp->ovfl = bp;	/* one of op/np point to big_keyp */
	tp = (u_int16_t *)tmpp->page;
#ifdef DEBUG
	assert(FREESPACE(tp) >= OVFLSIZE);
#endif
	n = tp[0];
	off = OFFSET(tp);
	free_space = FREESPACE(tp);
	tp[++n] = (u_int16_t)addr;
	tp[++n] = OVFLPAGE;
	tp[0] = n;
	OFFSET(tp) = off;
	FREESPACE(tp) = free_space - OVFLSIZE;

	/*
	 * Finally, set the new and old return values. BIG_KEYP contains a
	 * pointer to the last page of the big key_data pair. Make sure that
	 * big_keyp has no following page (2 elements) or create an empty
	 * following page.
	 */

	ret->newp = np;
	ret->oldp = op;

	tp = (u_int16_t *)big_keyp->page;
	big_keyp->flags |= BUF_MOD;
	if (tp[0] > 2) {
		/*
		 * There may be either one or two offsets on this page.  If
		 * there is one, then the overflow page is linked on normally
		 * and tp[4] is OVFLPAGE.  If there are two, tp[4] contains
		 * the second offset and needs to get stuffed in after the
		 * next overflow page is added.
		 */
		n = tp[4];
		free_space = FREESPACE(tp);
		off = OFFSET(tp);
		tp[0] -= 2;
		FREESPACE(tp) = free_space + OVFLSIZE;
		OFFSET(tp) = off;
		tmpp = __add_ovflpage(hashp, big_keyp);
		if (!tmpp)
			return (-1);
		tp[4] = n;
	} else
		tmpp = big_keyp;

	if (change)
		ret->newp = tmpp;
	else
		ret->oldp = tmpp;
	return (0);
}
@


1.18
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.17 2006/04/03 19:56:47 deraadt Exp $	*/
d455 1
a455 2
		if (hashp->tmp_buf)
			free(hashp->tmp_buf);
d520 1
a520 2
		if (hashp->tmp_key != NULL)
			free(hashp->tmp_key);
@


1.17
log
@a few size_t casts are needed here; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.16 2005/08/05 13:03:00 espie Exp $	*/
a52 2
#include <sys/param.h>

d67 2
d100 1
a100 1
		move_bytes = MIN(space, key_size);
d118 1
a118 1
				move_bytes = MIN(space, val_size);
d149 1
a149 1
		move_bytes = MIN(space, val_size);
@


1.16
log
@zap rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.15 2005/03/23 19:34:59 otto Exp $	*/
d423 1
a423 1
	val->size = collect_data(hashp, bufp, (int)len, set_current);
d495 1
a495 1
	key->size = collect_key(hashp, bufp, 0, val, set);
@


1.15
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.14 2005/01/03 22:46:43 millert Exp $	*/
a33 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)hash_bigkey.c	8.3 (Berkeley) 5/31/94";
#else
static const char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.14 2005/01/03 22:46:43 millert Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.14
log
@deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.13 2003/08/06 21:08:05 millert Exp $	*/
d39 1
a39 1
static const char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.13 2003/08/06 21:08:05 millert Exp $";
d89 2
a90 5
extern int
__big_insert(hashp, bufp, key, val)
	HTAB *hashp;
	BUFHEAD *bufp;
	const DBT *key, *val;
d198 2
a199 4
extern int
__big_delete(hashp, bufp)
	HTAB *hashp;
	BUFHEAD *bufp;
d275 2
a276 7
extern int
__find_bigpair(hashp, bufp, ndx, key, size)
	HTAB *hashp;
	BUFHEAD *bufp;
	int ndx;
	char *key;
	int size;
d322 2
a323 4
extern u_int16_t
__find_last_page(hashp, bpp)
	HTAB *hashp;
	BUFHEAD **bpp;
d361 2
a362 7
extern int
__big_return(hashp, bufp, ndx, val, set_current)
	HTAB *hashp;
	BUFHEAD *bufp;
	int ndx;
	DBT *val;
	int set_current;
d448 1
a448 4
collect_data(hashp, bufp, len, set)
	HTAB *hashp;
	BUFHEAD *bufp;
	int len, set;
d500 2
a501 6
extern int
__big_keydata(hashp, bufp, key, val, set)
	HTAB *hashp;
	BUFHEAD *bufp;
	DBT *key, *val;
	int set;
d515 1
a515 6
collect_key(hashp, bufp, len, val, set)
	HTAB *hashp;
	BUFHEAD *bufp;
	int len;
	DBT *val;
	int set;
d554 8
a561 10
extern int
__big_split(hashp, op, np, big_keyp, addr, obucket, ret)
	HTAB *hashp;
	BUFHEAD *op;	/* Pointer to where to put keys that go in old bucket */
	BUFHEAD *np;	/* Pointer to new bucket page */
			/* Pointer to first page containing the big key/data */
	BUFHEAD *big_keyp;
	int addr;	/* Address of big_keyp */
	u_int32_t   obucket;/* Old Bucket */
	SPLIT_RETURN *ret;
@


1.13
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.12 2003/06/02 20:18:33 millert Exp $	*/
d39 1
a39 1
static const char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.12 2003/06/02 20:18:33 millert Exp $";
d95 1
a95 1
	register u_int16_t *p;
d206 1
a206 1
	register BUFHEAD *last_bfp, *rbufp;
d288 2
a289 2
	register u_int16_t *bp;
	register char *p;
d470 2
a471 2
	register u_int16_t *bp;
	register char *p;
d594 1
a594 3
	register BUFHEAD *tmpp;
	register u_int16_t *tp;
	BUFHEAD *bp;
d597 1
a597 1
	u_int16_t free_space, n, off;
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.11 2003/05/01 20:23:40 avsm Exp $	*/
d39 1
a39 1
static const char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.11 2003/05/01 20:23:40 avsm Exp $";
d611 1
a611 1
			return (-1);;
@


1.11
log
@-Wall cleanup, make rcsid variables const
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.10 2002/02/25 23:45:15 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
static const char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.10 2002/02/25 23:45:15 millert Exp $";
@


1.10
log
@Cosmetic changes such as correct printf format specifiers on LP64
machines and whitespace nits.  Some from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.9 2002/02/16 21:27:22 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.9 2002/02/16 21:27:22 millert Exp $";
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.8 2002/02/01 18:15:24 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.8 2002/02/01 18:15:24 millert Exp $";
d453 1
a453 1
	if (val->size == (size_t) -1)
d532 1
a532 1
	if (key->size == (size_t) -1)
@


1.8
log
@If (keysize+datasize)%(bsize=14)==0, insertion of a `big key' would cause an
invariant (actually, an ugly hack) to fail, and all Hell would break loose.

When deleting a big key, the offset of an empty page should be bsize, not
bsize-1; otherwise an insertion into the empty page will cause the new key to
be elongated by 1 byte.

Make the packing more dense in a couple of cases.

From mycroft@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.7 2000/10/03 18:16:48 mickey Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.7 2000/10/03 18:16:48 mickey Exp $";
d81 2
a82 2
static int collect_key __P((HTAB *, BUFHEAD *, int, DBT *, int));
static int collect_data __P((HTAB *, BUFHEAD *, int, int));
@


1.7
log
@bt_open.c: parenthesize - and & proper (from freebsd);
hash_bigkey.c: fix NULL dereference exposed on big bsize values;
hash_buf.c: fix DEBUG1 cases to make them print, not crash;
hash.3: document real default values for bsize and ffactor.
@
text
@d1 1
a1 1
/*	$OpenBSD: hash_bigkey.c,v 1.6 1999/02/15 05:11:24 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.6 1999/02/15 05:11:24 millert Exp $";
d131 12
a142 2
			if (FREESPACE(p)) {
				move_bytes = MIN(FREESPACE(p), val_size);
a143 1
				p[n] = off;
d147 1
d151 2
a152 1
			} else
d154 1
d266 1
a266 1
	OFFSET(bp) = hashp->BSIZE - 1;
@


1.6
log
@ o Minor changes from db.1.86 (sleepycat).  Does not include the new hash
   routines since they cannot read a hashed .db file from the old code.
   Most of these files just have their RCS/SCCS tags standardized.
   Note that mpool.3 has not been updated to reflect the new mpool interface.
 o Add a real dbm(3) manpage
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.5 1998/03/19 00:29:56 millert Exp $";
d259 1
a259 1
	if (last_bfp != rbufp)
@


1.5
log
@some -Wall
@
text
@d1 2
d40 5
a44 1
static char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.4 1996/09/15 09:30:48 tholo Exp $";
@


1.4
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.3 1996/08/19 08:20:34 tholo Exp $";
d124 1
a124 1
		if (!key_size)
d137 1
d594 1
a594 1
	if (ret->next_addr = __find_last_page(hashp, &big_keyp)) {
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: hash_bigkey.c,v 1.6 1996/05/03 21:43:49 cgd Exp $";
d434 1
a434 1
	if (val->size == -1)
d513 1
a513 1
	if (key->size == -1)
@


1.2
log
@db release 1.85
@
text
@a0 2
/*	$NetBSD: hash_bigkey.c,v 1.6 1996/05/03 21:43:49 cgd Exp $	*/

d38 1
a38 5
#if 0
static char sccsid[] = "@@(#)hash_bigkey.c	8.3 (Berkeley) 5/31/94";
#else
static char rcsid[] = "$NetBSD: hash_bigkey.c,v 1.6 1996/05/03 21:43:49 cgd Exp $";
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: hash_bigkey.c,v 1.5 1995/02/27 13:22:16 cgd Exp $	*/
d43 1
a43 1
static char rcsid[] = "$NetBSD: hash_bigkey.c,v 1.5 1995/02/27 13:22:16 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

