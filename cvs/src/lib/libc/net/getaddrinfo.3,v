head	1.58;
access;
symbols
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.57.0.4
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.57.0.6
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.57.0.2
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.53.0.2
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.50.0.2
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.2
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.47.0.6
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.47.0.4
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.46.0.4
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.45.0.8
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.6
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.4
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.43.0.4
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.4
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@.\" @;


1.58
date	2016.05.29.06.01.24;	author guenther;	state Exp;
branches;
next	1.57;
commitid	4lz2RlpD7rt4WGS8;

1.57
date	2015.02.16.18.26.56;	author jca;	state Exp;
branches;
next	1.56;
commitid	6h5zpaWjTwXlKhOj;

1.56
date	2014.08.23.07.25.54;	author jmc;	state Exp;
branches;
next	1.55;
commitid	8CxL8ey38kykYzgb;

1.55
date	2014.04.28.21.38.59;	author sperreault;	state Exp;
branches;
next	1.54;

1.54
date	2014.01.21.03.15.45;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2013.06.05.03.39.22;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2013.03.31.19.17.47;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2012.09.27.11.31.58;	author jmc;	state Exp;
branches;
next	1.50;

1.50
date	2012.04.20.16.37.07;	author sthen;	state Exp;
branches;
next	1.49;

1.49
date	2012.01.03.12.06.04;	author jmc;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.05.00.46.06;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	2009.07.09.10.14.41;	author eric;	state Exp;
branches;
next	1.46;

1.46
date	2009.05.06.19.03.09;	author jacekm;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.31.19.19.30;	author jmc;	state Exp;
branches;
next	1.44;

1.44
date	2006.09.25.23.02.43;	author ray;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.15.19.35.31;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.13.13.22.57;	author otto;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.05.22.21.16;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.12.00.02.07;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.29.00.49.47;	author jmc;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.28.01.41.14;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.06.10.07.32;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2005.01.06.03.50.46;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.21.03.40.31;	author jaredy;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.21.01.01.47;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.20.21.35.10;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.20.21.20.56;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.20.21.13.00;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.20.03.26.43;	author itojun;	state dead;
branches;
next	1.29;

1.29
date	2004.12.06.10.46.35;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.14.10.06.03;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.14.07.06.15;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.01.20.25.44;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.08.09.26.02;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.27.15.34.03;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.20.18.35;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.30.21.37.59;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.01.19.10.09;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.30.16.31.42;	author mpech;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.06.10.42.26;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.05.18.57.08;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.23.05.57.03;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.23.02.33.17;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.12.09.24.47;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.26.13.31.35;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.24.00.30.54;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.13.07.23.48;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.09.23.12.04;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.25.04.52.55;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.30.16.52.44;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.22.20.29.00;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.14.13.23.54;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.17.08.20.27;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.17.08.16.58;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.06.22.00.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.07.05.04.40.59;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	99.07.03.20.26.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.07.03.20.22.21;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Prefer AF_* over PF_* and 'address family' over 'protocol family'

ok jung@@
@
text
@.\"	$OpenBSD: getaddrinfo.3,v 1.57 2015/02/16 18:26:56 jca Exp $
.\"	$KAME: getaddrinfo.3,v 1.36 2005/01/05 03:23:05 itojun Exp $
.\"
.\" Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
.\" Copyright (C) 2000, 2001  Internet Software Consortium.
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
.\" REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
.\" AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
.\" INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
.\" LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
.\" OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
.\" PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: February 16 2015 $
.Dt GETADDRINFO 3
.Os
.Sh NAME
.Nm getaddrinfo ,
.Nm freeaddrinfo
.Nd host and service name to socket address structure
.Sh SYNOPSIS
.In sys/types.h
.In sys/socket.h
.In netdb.h
.Ft int
.Fn getaddrinfo "const char *hostname" "const char *servname" \
    "const struct addrinfo *hints" "struct addrinfo **res"
.Ft void
.Fn freeaddrinfo "struct addrinfo *ai"
.Sh DESCRIPTION
The
.Fn getaddrinfo
function is used to get a list of
.Tn IP
addresses and port numbers for host
.Fa hostname
and service
.Fa servname .
It is a replacement for and provides more flexibility than the
.Xr gethostbyname 3
and
.Xr getservbyname 3
functions.
.Pp
The
.Fa hostname
and
.Fa servname
arguments are either pointers to NUL-terminated strings or the null pointer.
An acceptable value for
.Fa hostname
is either a valid host name or a numeric host address string consisting
of a dotted decimal IPv4 address or an IPv6 address.
The
.Fa servname
is either a decimal port number or a service name listed in
.Xr services 5 .
At least one of
.Fa hostname
and
.Fa servname
must be non-null.
.Pp
.Fa hints
is an optional pointer to a
.Li struct addrinfo ,
as defined by
.In netdb.h :
.Bd -literal
struct addrinfo {
	int ai_flags;		/* input flags */
	int ai_family;		/* address family for socket */
	int ai_socktype;	/* socket type */
	int ai_protocol;	/* protocol for socket */
	socklen_t ai_addrlen;	/* length of socket-address */
	struct sockaddr *ai_addr; /* socket-address for socket */
	char *ai_canonname;	/* canonical name for service location */
	struct addrinfo *ai_next; /* pointer to next in list */
};
.Ed
.Pp
This structure can be used to provide hints concerning the type of socket
that the caller supports or wishes to use.
The caller can supply the following structure elements in
.Fa hints :
.Bl -tag -width "ai_socktypeXX"
.It Fa ai_family
The address family that should be used.
When
.Fa ai_family
is set to
.Dv AF_UNSPEC ,
it means the caller will accept any address family supported by the
operating system.
.It Fa ai_socktype
Denotes the type of socket that is wanted:
.Dv SOCK_STREAM ,
.Dv SOCK_DGRAM ,
or
.Dv SOCK_RAW .
When
.Fa ai_socktype
is zero the caller will accept any socket type.
.It Fa ai_protocol
Indicates which transport protocol is desired,
.Dv IPPROTO_UDP
or
.Dv IPPROTO_TCP .
If
.Fa ai_protocol
is zero the caller will accept any protocol.
.It Fa ai_flags
.Fa ai_flags
is formed by
.Tn OR Ns 'ing
the following values:
.Bl -tag -width "AI_CANONNAMEXX"
.It Dv AI_ADDRCONFIG
If the
.Dv AI_ADDRCONFIG
bit is set, IPv4 addresses will be returned only if an IPv4 address is
configured on an interface, and IPv6 addresses will be returned only if an IPv6
address is configured on an interface.
Addresses on a loopback interface and link-local IPv6 addresses are not
considered valid as configured addresses.
This bit is only considered when determining whether a DNS query should
be performed or not.
.It Dv AI_CANONNAME
If the
.Dv AI_CANONNAME
bit is set, a successful call to
.Fn getaddrinfo
will return a NUL-terminated string containing the canonical name
of the specified host name in the
.Fa ai_canonname
element of the first
.Li addrinfo
structure returned.
.It Dv AI_FQDN
If the
.Dv AI_FQDN
bit is set, a successful call to
.Fn getaddrinfo
will return a NUL-terminated string containing the fully qualified domain name
of the specified host name in the
.Fa ai_canonname
element of the first
.Li addrinfo
structure returned.
.Pp
This is different from the
.Dv AI_CANONNAME
bit flag that returns the canonical name registered in DNS,
which may be different from the fully qualified domain name
that the host name resolved to.
Only one of the
.Dv AI_FQDN
and
.Dv AI_CANONNAME
bits can be set.
.It Dv AI_NUMERICHOST
If the
.Dv AI_NUMERICHOST
bit is set, it indicates that
.Fa hostname
should be treated as a numeric string defining an IPv4 or IPv6 address
and no name resolution should be attempted.
.It Dv AI_NUMERICSERV
If the
.Dv AI_NUMERICSERV
bit is set, it indicates that
.Fa servname
should be treated as a numeric port string
and no service name resolution should be attempted.
.It Dv AI_PASSIVE
If the
.Dv AI_PASSIVE
bit is set it indicates that the returned socket address structure
is intended for use in a call to
.Xr bind 2 .
In this case, if the
.Fa hostname
argument is the null pointer, then the IP address portion of the
socket address structure will be set to
.Dv INADDR_ANY
for an IPv4 address or
.Dv IN6ADDR_ANY_INIT
for an IPv6 address.
.Pp
If the
.Dv AI_PASSIVE
bit is not set, the returned socket address structure will be ready
for use in a call to
.Xr connect 2
for a connection-oriented protocol or
.Xr connect 2 ,
.Xr sendto 2 ,
or
.Xr sendmsg 2
if a connectionless protocol was chosen.
The
.Tn IP
address portion of the socket address structure will be set to the
loopback address if
.Fa hostname
is the null pointer and
.Dv AI_PASSIVE
is not set.
.El
.El
.Pp
All other elements of the
.Li addrinfo
structure passed via
.Fa hints
must be zero or the null pointer.
.Pp
If
.Fa hints
is the null pointer,
.Fn getaddrinfo
behaves as if the caller provided a
.Li struct addrinfo
with
.Fa ai_family
set to
.Dv AF_UNSPEC ,
.Fa ai_flags
set to
.Dv AI_ADDRCONFIG ,
and all other elements set to zero or
.Dv NULL .
.Pp
After a successful call to
.Fn getaddrinfo ,
.Fa *res
is a pointer to a linked list of one or more
.Li addrinfo
structures.
The list can be traversed by following the
.Fa ai_next
pointer in each
.Li addrinfo
structure until a null pointer is encountered.
The three members
.Fa ai_family ,
.Fa ai_socktype ,
and
.Fa ai_protocol
in each returned
.Li addrinfo
structure are suitable for a call to
.Xr socket 2 .
For each
.Li addrinfo
structure in the list, the
.Fa ai_addr
member points to a filled-in socket address structure of length
.Fa ai_addrlen .
.Pp
This implementation of
.Fn getaddrinfo
allows numeric IPv6 address notation with scope identifier,
as documented in RFC 4007.
By appending the percent character and scope identifier to addresses,
one can fill the
.Li sin6_scope_id
field for addresses.
This would make management of scoped addresses easier
and allows cut-and-paste input of scoped addresses.
.Pp
At this moment the code supports only link-local addresses with the format.
The scope identifier is hardcoded to the name of the hardware interface
associated
with the link
.Po
such as
.Li ne0
.Pc .
An example is
.Dq Li fe80::1%ne0 ,
which means
.Do
.Li fe80::1
on the link associated with the
.Li ne0
interface
.Dc .
.Pp
The current implementation assumes a one-to-one relationship between
the interface and link, which is not necessarily true from the specification.
.Pp
All of the information returned by
.Fn getaddrinfo
is dynamically allocated: the
.Li addrinfo
structures themselves as well as the socket address structures and
the canonical host name strings included in the
.Li addrinfo
structures.
.Pp
Memory allocated for the dynamically allocated structures created by
a successful call to
.Fn getaddrinfo
is released by the
.Fn freeaddrinfo
function.
The
.Fa ai
pointer should be an
.Li addrinfo
structure created by a call to
.Fn getaddrinfo .
.Sh RETURN VALUES
.Fn getaddrinfo
returns zero on success or one of the error codes listed in
.Xr gai_strerror 3
if an error occurs.
If an error occurs, no memory is allocated by
.Fn getaddrinfo ,
therefore it is not necessary to release the
.Li addrinfo
structure(s).
.Sh EXAMPLES
The following code tries to connect to
.Dq Li www.kame.net
service
.Dq Li www
via a stream socket.
It loops through all the addresses available, regardless of address family.
If the destination resolves to an IPv4 address, it will use an
.Dv AF_INET
socket.
Similarly, if it resolves to IPv6, an
.Dv AF_INET6
socket is used.
Observe that there is no hardcoded reference to a particular address family.
The code works even if
.Fn getaddrinfo
returns addresses that are not IPv4/v6.
.Bd -literal -offset indent
struct addrinfo hints, *res, *res0;
int error;
int save_errno;
int s;
const char *cause = NULL;

memset(&hints, 0, sizeof(hints));
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;
error = getaddrinfo("www.kame.net", "www", &hints, &res0);
if (error)
	errx(1, "%s", gai_strerror(error));
s = -1;
for (res = res0; res; res = res->ai_next) {
	s = socket(res->ai_family, res->ai_socktype,
	    res->ai_protocol);
	if (s == -1) {
		cause = "socket";
		continue;
	}

	if (connect(s, res->ai_addr, res->ai_addrlen) == -1) {
		cause = "connect";
		save_errno = errno;
		close(s);
		errno = save_errno;
		s = -1;
		continue;
	}

	break;	/* okay we got one */
}
if (s == -1)
	err(1, "%s", cause);
freeaddrinfo(res0);
.Ed
.Pp
The following example tries to open a wildcard listening socket onto service
.Dq Li www ,
for all the address families available.
.Bd -literal -offset indent
struct addrinfo hints, *res, *res0;
int error;
int save_errno;
int s[MAXSOCK];
int nsock;
const char *cause = NULL;

memset(&hints, 0, sizeof(hints));
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;
error = getaddrinfo(NULL, "www", &hints, &res0);
if (error)
	errx(1, "%s", gai_strerror(error));
nsock = 0;
for (res = res0; res && nsock < MAXSOCK; res = res->ai_next) {
	s[nsock] = socket(res->ai_family, res->ai_socktype,
	    res->ai_protocol);
	if (s[nsock] == -1) {
		cause = "socket";
		continue;
	}

	if (bind(s[nsock], res->ai_addr, res->ai_addrlen) == -1) {
		cause = "bind";
		save_errno = errno;
		close(s[nsock]);
		errno = save_errno;
		continue;
	}
	(void) listen(s[nsock], 5);

	nsock++;
}
if (nsock == 0)
	err(1, "%s", cause);
freeaddrinfo(res0);
.Ed
.Sh SEE ALSO
.Xr bind 2 ,
.Xr connect 2 ,
.Xr send 2 ,
.Xr socket 2 ,
.Xr gai_strerror 3 ,
.Xr gethostbyname 3 ,
.Xr getnameinfo 3 ,
.Xr getservbyname 3 ,
.Xr resolver 3 ,
.Xr hosts 5 ,
.Xr resolv.conf 5 ,
.Xr services 5 ,
.Xr hostname 7
.Rs
.%A Craig Metz
.%B Proceedings of the Freenix Track: 2000 USENIX Annual Technical Conference
.%D June 2000
.%T Protocol Independence Using the Sockets API
.Re
.Sh STANDARDS
The
.Fn getaddrinfo
function is defined by the
.St -p1003.1g-2000
draft specification and documented in RFC 3493.
.Pp
The
.Dv AI_FQDN
flag bit first appeared in Windows 7.
.Pp
.Rs
.%A R. Gilligan
.%A S. Thomson
.%A J. Bound
.%A J. McCann
.%A W. Stevens
.%D February 2003
.%R RFC 3493
.%T Basic Socket Interface Extensions for IPv6
.Re
.Pp
.Rs
.%A S. Deering
.%A B. Haberman
.%A T. Jinmei
.%A E. Nordmark
.%A B. Zill
.%D March 2005
.%R RFC 4007
.%T IPv6 Scoped Address Architecture
.Re
@


1.57
log
@Amend documentation for AI_ADDRCONFIG

ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.56 2014/08/23 07:25:54 jmc Exp $
d19 1
a19 1
.Dd $Mdocdate: August 23 2014 $
d77 1
a77 1
	int ai_family;		/* protocol family for socket */
d93 1
a93 1
The protocol family that should be used.
d97 2
a98 2
.Dv PF_UNSPEC ,
it means the caller will accept any protocol family supported by the
d232 1
a232 1
.Dv PF_UNSPEC ,
d354 1
a354 1
hints.ai_family = PF_UNSPEC;
d396 1
a396 1
hints.ai_family = PF_UNSPEC;
@


1.56
log
@unbind;
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.55 2014/04/28 21:38:59 sperreault Exp $
d19 1
a19 1
.Dd $Mdocdate: April 28 2014 $
d131 2
@


1.55
log
@Implement AI_ADDRCONFIG

This is a getaddrinfo() flag that is defined thusly in RFC 3493:

   If the AI_ADDRCONFIG flag is specified, IPv4 addresses shall be
   returned only if an IPv4 address is configured on the local system,
   and IPv6 addresses shall be returned only if an IPv6 address is
   configured on the local system.  The loopback address is not
   considered for this case as valid as a configured address.

      For example, when using the DNS, a query for AAAA records should
      occur only if the node has at least one IPv6 address configured
      (other than IPv6 loopback) and a query for A records should occur
      only if the node has at least one IPv4 address configured (other
      than the IPv4 loopback).

The flag is set by default when hints is NULL.

ok Eric Faurot, Jason McIntyre
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.54 2014/01/21 03:15:45 schwarze Exp $
d19 1
a19 1
.Dd $Mdocdate: January 21 2014 $
d437 1
a437 2
.Xr hostname 7 ,
.Xr named 8
@


1.54
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.53 2013/06/05 03:39:22 tedu Exp $
d19 1
a19 1
.Dd $Mdocdate: June 5 2013 $
d123 8
d230 4
a233 1
.Dv PF_UNSPEC
@


1.53
log
@Use the fancy .In macro for includes. From Jan Klemkow. ok jmc schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.52 2013/03/31 19:17:47 brad Exp $
d19 1
a19 1
.Dd $Mdocdate: March 31 2013 $
d73 1
a73 1
.Aq Pa netdb.h :
@


1.52
log
@getaddrinfo is now thread-safe.

ok eric@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.51 2012/09/27 11:31:58 jmc Exp $
d19 1
a19 1
.Dd $Mdocdate: September 27 2012 $
d27 3
a29 3
.Fd #include <sys/types.h>
.Fd #include <sys/socket.h>
.Fd #include <netdb.h>
@


1.51
log
@last stage of rfc changes, using consistent Rs/Re blocks, and moving the
references into a STANDARDS section;
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.50 2012/04/20 16:37:07 sthen Exp $
d19 1
a19 1
.Dd $Mdocdate: April 20 2012 $
a465 4
.Sh BUGS
The implementation of
.Fn getaddrinfo
is not thread-safe.
@


1.50
log
@use "an addrinfo", not "a addrinfo". ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.49 2012/01/03 12:06:04 jmc Exp $
d19 1
a19 1
.Dd $Mdocdate: January 3 2012 $
d429 17
d451 2
a453 2
.%R RFC 3493
.%D February 2003
d455 1
d462 1
a462 1
.%T "IPv6 Scoped Address Architecture"
d464 1
a464 7
.%D March 2005
.Re
.Rs
.%A Craig Metz
.%T Protocol Independence Using the Sockets API
.%B "Proceedings of the Freenix Track: 2000 USENIX Annual Technical Conference"
.%D June 2000
a465 12
.Sh STANDARDS
The
.Fn getaddrinfo
function is defined by the
.St -p1003.1g-2000
draft specification and documented in
.Dv "RFC 3493" ,
.Dq Basic Socket Interface Extensions for IPv6 .
.Pp
The
.Dv AI_FQDN
flag bit first appeared in Windows 7.
@


1.49
log
@draft-ietf-ipv6-scoping-arch-02 has become RFC 4007, as noted by
Poul-Henning Kamp, freebsd pr docs/163771;

ok sthen
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.48 2011/04/05 00:46:06 matthew Exp $
d19 1
a19 1
.Dd $Mdocdate: April 5 2011 $
d302 1
a302 1
pointer should be a
@


1.48
log
@Add AI_FQDN flag to getaddrinfo(3).  Prompted by discussions with djm@@
about cert checking in OpenSSH.  Man page wording tweaks thanks to
jmc@@.

ok henning@@, jmc@@; positive feedback from djm@@, ajacoutat@@

Committing now to reuse guenther@@'s libc minor bump instead of
cranking it again, as suggested by deraadt@@.
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.47 2009/07/09 10:14:41 eric Exp $
d19 1
a19 1
.Dd $Mdocdate: July 9 2009 $
d256 1
a256 1
as documented in chapter 11 of draft-ietf-ipv6-scoping-arch-02.txt.
d445 2
a446 3
.%R internet draft
.%N draft-ietf-ipv6-scoping-arch-02.txt
.%O work in progress material
@


1.47
log
@promote correct style for error checking

ok tedu@@ deraadt@@ krw@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.46 2009/05/06 19:03:09 jacekm Exp $
d19 1
a19 1
.Dd $Mdocdate: May 6 2009 $
d129 1
a129 1
of the specified hostname in the
d134 22
d463 4
@


1.46
log
@Document AI_NUMERICSERV; feedback and ok millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.45 2007/05/31 19:19:30 jmc Exp $
d19 1
a19 1
.Dd $Mdocdate: May 31 2007 $
d328 1
a328 1
	if (s < 0) {
d333 1
a333 1
	if (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
d344 1
a344 1
if (s < 0)
d371 1
a371 1
	if (s[nsock] < 0) {
d376 1
a376 1
	if (bind(s[nsock], res->ai_addr, res->ai_addrlen) < 0) {
@


1.45
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.44 2006/09/25 23:02:43 ray Exp $
d19 1
a19 1
.Dd $Mdocdate$
d141 7
@


1.44
log
@Remove unnecessary /* NOTREACHED */ comments because our lint is
cool and recognizes __dead, and because shorter examples are clearer.

OK otto@@.
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.43 2005/11/15 19:35:31 otto Exp $
d19 1
a19 1
.Dd December 20, 2004
@


1.43
log
@Do not clobber errno when calling close(2) in example code.
From form@@ via mpech@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.42 2005/11/13 13:22:57 otto Exp $
d315 1
a315 1
if (error) {
a316 2
	/*NOTREACHED*/
}
d337 1
a337 1
if (s < 0) {
a338 2
	/*NOTREACHED*/
}
d358 1
a358 1
if (error) {
a359 2
	/*NOTREACHED*/
}
d380 1
a380 1
if (nsock == 0) {
a381 2
	/*NOTREACHED*/
}
@


1.42
log
@save errno in example code. from mpech@@ ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.41 2005/07/05 22:21:16 dlg Exp $
d307 1
a307 1
int save_errno = errno;
d330 1
d352 1
d377 1
d379 1
@


1.41
log
@use "www" as the service name in the example instead of "http" since "www"
is what is used in /etc/services.

ok jmc@@ henning@@ millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.40 2005/03/12 00:02:07 claudio Exp $
d307 1
d331 1
@


1.40
log
@There is no need to call freeaddrinfo() in case of an error.
getaddrinfo() does that already by itself.
OK jmc@@ beck@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.39 2005/01/29 00:49:47 jmc Exp $
d291 1
a291 1
.Dq Li http
d313 1
a313 1
error = getaddrinfo("www.kame.net", "http", &hints, &res0);
d344 1
a344 1
.Dq Li http ,
d357 1
a357 1
error = getaddrinfo(NULL, "http", &hints, &res0);
@


1.39
log
@correct .Rs references;
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.38 2005/01/28 01:41:14 djm Exp $
d282 5
@


1.38
log
@fix reversed short description; ok itojun@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.37 2005/01/06 10:07:32 jmc Exp $
d420 1
a420 1
.%B "Proceedings of the freenix track: 2000 USENIX annual technical conference"
@


1.37
log
@space between macro args and punctuation;
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.36 2005/01/06 03:50:46 itojun Exp $
d25 1
a25 1
.Nd socket address structure to host and service name
@


1.36
log
@IPv6 manpage, wrote from scratch.  deraadt ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.35 2004/12/21 03:40:31 jaredy Exp $
d209 2
a210 2
.Fa ai_family,
.Fa ai_socktype,
@


1.35
log
@- grammar, punctuation, spacing, and mdoc fixes
- remove first person
- EAI_NONAME is already described in gai_strerror(3)
@
text
@d1 2
a2 1
.\"	$OpenBSD: getaddrinfo.3,v 1.34 2004/12/21 01:01:47 itojun Exp $
d226 2
a227 1
allows experimental numeric IPv6 address notation with scope identifiers.
a252 1
The IPv6 implementation is still very experimental and non-standard.
d407 6
a412 3
.%A Tatsuya Jinmei
.%A Atsushi Onoe
.%T "An Extension of Format for IPv6 Scoped Addresses"
d414 1
a414 1
.%N draft-ietf-ipngwg-scopedaddr-format-02.txt
@


1.34
log
@thread-unsafeness comes from the use of _res, YP filehandle, and /etc/hosts
filehandle, not dynamic memory allocation.
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.33 2004/12/20 21:35:10 millert Exp $
d30 2
a31 1
.Fn getaddrinfo "const char *hostname" "const char *servname" "const struct addrinfo *hints" "struct addrinfo **res"
d102 1
a102 1
.Dv SOCK_DGRAM
d144 1
a144 1
is intended for used in a call to
d148 1
a148 1
argument is a the null pointer, then the IP address portion of the
d162 1
a162 1
.Xr sendto 2
d171 1
a171 1
is the null pointer and the
d207 1
a207 1
The three members,
d225 1
a225 1
allows experimental numeric IPv6 address notation with scope identifier.
d227 1
a227 1
you can fill the
d230 2
a231 2
This would make management of scoped address easier,
and allows cut-and-paste input of scoped address.
d234 2
a235 1
Scope identifier is hardcoded to the name of the hardware interface associated
a280 9
If both
.Fa hostname
and
.Fa servname
are
.Dv NULL ,
.Fn getaddrinfo
returns
.Dv EAI_NONAME .
d285 2
a286 2
.Dq Li http .
via stream socket.
d288 1
a288 1
If the destination resolves to an IPv4 address, it will use
d291 1
a291 1
Similarly, if it resolves to IPv6,
d296 1
a296 1
.Nm getaddrinfo
@


1.33
log
@Minor cleanup.
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.32 2004/12/20 21:20:56 millert Exp $
d435 1
a435 1
Due to the use of dynamic allocation,
@


1.32
log
@Add back EXAMPLE section and scopeid info which are from KAME, not the
RFC text.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d34 1
d36 2
a37 2
is used to get a list of
.Dv IP
d48 1
d52 1
a52 1
are either pointers to NUL-terminated strings or the null pointer.
d55 1
a55 1
is either a host name or a numeric host address string consisting
d116 4
a119 1
Flag bits.
d166 1
a166 1
.Dv IP
d188 1
a188 1
initialized to zero and with
d191 3
a193 1
.Dv PF_UNSPEC .
@


1.31
log
@New getaddrinfo.3 man page, derived from the ISC version and fleshed
out a bit by me.  Needs more work.
@
text
@d215 31
d281 99
@


1.30
log
@remove manpages based on RFC.  requested by deraadt
@
text
@d1 1
a1 2
.\"	$OpenBSD: getaddrinfo.3,v 1.29 2004/12/06 10:46:35 jmc Exp $
.\"	$KAME: getaddrinfo.3,v 1.29 2001/02/12 09:24:45 itojun Exp $
d3 2
a4 2
.\" Copyright (c) 1983, 1987, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
d6 11
a16 11
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
d18 1
a18 15
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     From: @@(#)gethostbyname.3	8.4 (Berkeley) 5/25/95
.\"
.Dd May 25, 1995
a20 1
.\"
d24 1
a24 2
.Nd nodename-to-address translation in protocol-independent manner
.\"
d30 1
a30 2
.Fn getaddrinfo "const char *nodename" "const char *servname" \
"const struct addrinfo *hints" "struct addrinfo **res"
a32 1
.\"
a33 1
The
d35 7
a41 2
function is defined for protocol-independent nodename-to-address translation.
It performs the functionality of
d44 2
a45 2
.Xr getservbyname 3 ,
but in a more sophisticated manner.
d47 8
a54 10
All of the information returned by
.Fn getaddrinfo
is dynamically allocated:
the
.Li addrinfo
structures, the socket address structures, and canonical node name
strings pointed to by the addrinfo structures.
To return this information to the system the function
.Fn freeaddrinfo
is called.
d56 8
a63 9
.Fa addrinfo
structure pointed to by the
.Fa ai
argument is freed,
along with any dynamic storage pointed to by the structure.
This operation is repeated until a
.Dv NULL
.Fa ai_next
pointer is encountered.
d65 5
a69 45
To aid applications in printing error messages based on the
.Dv EAI_xxx
codes returned by
.Fn getaddrinfo ,
.Fn gai_strerror
is defined.
See
.Xr gai_strerror 3
for more information.
.Pp
The implementation allows experimental numeric IPv6 address notation with
scope identifier.
By appending the percent character and scope identifier to addresses,
you can fill the
.Li sin6_scope_id
field for addresses.
This would make management of scoped address easier,
and allows cut-and-paste input of scoped address.
.Pp
At this moment the code supports only link-local addresses with the format.
Scope identifier is hardcoded to the name of the hardware interface associated
with the link
.Po
such as
.Li ne0
.Pc .
An example is
.Dq Li fe80::1%ne0 ,
which means
.Do
.Li fe80::1
on the link associated with the
.Li ne0
interface
.Dc .
.Pp
The IPv6 implementation is still very experimental and non-standard.
The current implementation assumes a one-to-one relationship between
the interface and link, which is not necessarily true from the specification.
.Pp
The
.Li addrinfo
structure is defined as a result of including the
.Aq Pa netdb.h
header:
d83 8
a90 39
The
.Fa nodename
and
.Fa servname
arguments are pointers to NUL-terminated strings or
.Dv NULL .
One or both of these two arguments must be a non-null pointer.
In the normal client scenario, both the
.Fa nodename
and
.Fa servname
are specified.
In the normal server scenario, only the
.Fa servname
is specified.
A non-null
.Fa nodename
string can be either a node name or a numeric host address string
(i.e., a dotted-decimal IPv4 address or an IPv6 hex address).
A non-null
.Fa servname
string can be either a service name or a decimal port number.
.Pp
The caller can optionally pass an
.Li addrinfo
structure, pointed to by the third argument,
to provide hints concerning the type of socket that the caller supports.
In this
.Fa hints
structure all members other than
.Fa ai_flags ,
.Fa ai_family ,
.Fa ai_socktype ,
and
.Fa ai_protocol
must be zero or a null pointer.
A value of
.Dv PF_UNSPEC
for
d92 11
a102 2
means the caller will accept any protocol family.
A value of 0 for
d104 7
a110 2
means the caller will accept any socket type.
A value of 0 for
d112 8
a119 6
means the caller will accept any protocol.
For example, if the caller handles only TCP and not UDP, then the
.Fa ai_socktype
member of the hints structure should be set to
.Dv SOCK_STREAM
when
d121 4
a124 13
is called.
If the caller handles only IPv4 and not IPv6, then the
.Fa ai_family
member of the
.Fa hints
structure should be set to
.Dv PF_INET
when
.Fn getaddrinfo
is called.
If the third argument to
.Fn getaddrinfo
is a null pointer, this is the same as if the caller had filled in an
d126 9
a134 37
structure initialized to zero with
.Fa ai_family
set to
.Dv PF_UNSPEC .
.Pp
Upon successful return a pointer to a linked list of one or more
.Li addrinfo
structures is returned through the final argument.
The caller can process each
.Li addrinfo
structure in this list by following the
.Fa ai_next
pointer, until a null pointer is encountered.
In each returned
.Li addrinfo
structure the three members
.Fa ai_family ,
.Fa ai_socktype ,
and
.Fa ai_protocol
are the corresponding arguments for a call to the
.Xr socket 2
function.
In each
.Li addrinfo
structure the
.Fa ai_addr
member points to a filled-in socket address structure whose length is
specified by the
.Fa ai_addrlen
member.
.Pp
The
.Fa ai_flags
argument can be set to any of the following values, OR'd together:
.Bl -tag -width "AI_NUMERICHOSTXX"
.It AI_PASSIVE
d137 2
a138 3
bit is set,
the caller plans to use the returned socket address
structure in a call to
d141 3
a143 3
.Fa nodename
argument is a null pointer, then the IP address portion of the socket
address structure will be set to
d151 2
a152 3
bit is not set,
the returned socket address structure will be ready for a
call to
d154 1
a154 2
.Pq for a connection-oriented protocol
or either
d156 1
a156 1
.Xr sendto 2 ,
d159 13
a171 12
.Pq for a connectionless protocol .
In this case, if the
.Fa nodename
argument is a null pointer, then the IP address portion of the
socket address structure will be set to the loopback address.
.It AI_CANONNAME
If the
.Dv AI_CANONNAME
bit is set,
then upon successful return the
.Fa ai_canonname
member of the first
d173 3
a175 30
structure in the linked list will point to a NUL-terminated string
containing the canonical name of the specified
.Fa nodename .
.It AI_NUMERICHOST
If the
.Dv AI_NUMERICHOST
bit is set,
then a non-null
.Fa nodename
string must be a numeric host address string.
Otherwise an error of
.Dv EAI_NONAME
is returned.
This flag prevents any type of name resolution service,
such as DNS,
from being called.
.It AI_NUMERICSERV
If the
.Dv AI_NUMERICSERV
bit is set,
then a non-null
.Fa servname
string must be a numeric port string.
Otherwise an error of
.Dv EAI_NONAME
is returned.
This flag prevents any type of name resolution service,
such as NIS,
from being called.
.El
d177 1
a177 8
The arguments to
.Fn getaddrinfo
must be sufficiently consistent and unambiguous.
Issues to watch out for are:
.Bl -bullet
.It
.Fn getaddrinfo
will raise an error if members of the
d179 1
a179 2
structure are not consistent.
For example, for internet address families,
d181 21
a201 37
will raise an error if you specify
.Dv SOCK_STREAM
to
.Fa ai_socktype
while you specify
.Dv IPPROTO_UDP
to
.Fa ai_protocol .
.It
If you specify a
.Fa servname
which is defined only for certain
.Fa ai_socktype ,
.Fn getaddrinfo
will raise an error because the arguments are not consistent.
For example,
.Fn getaddrinfo
will raise an error if you ask for
.Dq Li tftp
service on
.Dv SOCK_STREAM .
.It
For internet address families, if you specify
.Fa servname
while you set
.Fa ai_socktype
to
.Dv SOCK_RAW ,
.Fn getaddrinfo
will raise an error, because service names are not defined for the internet
.Dv SOCK_RAW
space.
.It
If you specify a numeric
.Fa servname ,
while leaving
.Fa ai_socktype
d204 12
a215 1
unspecified,
d217 9
a225 4
will raise an error.
This is because the numeric
.Fa servname
does not identify any socket type, and
d227 9
a235 3
is not allowed to glob the argument in such case.
.El
.\"
d238 1
a238 2
returns zero on success, and non-zero on errors.
See
d240 10
a249 102
for a description of the non-zero error codes.
.\"
.Sh EXAMPLES
The following code tries to connect to
.Dq Li www.kame.net
service
.Dq Li http .
via stream socket.
It loops through all the addresses available, regardless of address family.
If the destination resolves to an IPv4 address, it will use
.Dv AF_INET
socket.
Similarly, if it resolves to IPv6,
.Dv AF_INET6
socket is used.
Observe that there is no hardcoded reference to a particular address family.
The code works even if
.Nm getaddrinfo
returns addresses that are not IPv4/v6.
.Bd -literal -offset indent
struct addrinfo hints, *res, *res0;
int error;
int s;
const char *cause = NULL;

memset(&hints, 0, sizeof(hints));
hints.ai_family = PF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;
error = getaddrinfo("www.kame.net", "http", &hints, &res0);
if (error) {
	errx(1, "%s", gai_strerror(error));
	/*NOTREACHED*/
}
s = -1;
for (res = res0; res; res = res->ai_next) {
	s = socket(res->ai_family, res->ai_socktype,
	    res->ai_protocol);
	if (s < 0) {
		cause = "socket";
		continue;
	}

	if (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
		cause = "connect";
		close(s);
		s = -1;
		continue;
	}

	break;	/* okay we got one */
}
if (s < 0) {
	err(1, "%s", cause);
	/*NOTREACHED*/
}
freeaddrinfo(res0);
.Ed
.Pp
The following example tries to open a wildcard listening socket onto service
.Dq Li http ,
for all the address families available.
.Bd -literal -offset indent
struct addrinfo hints, *res, *res0;
int error;
int s[MAXSOCK];
int nsock;
const char *cause = NULL;

memset(&hints, 0, sizeof(hints));
hints.ai_family = PF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;
error = getaddrinfo(NULL, "http", &hints, &res0);
if (error) {
	errx(1, "%s", gai_strerror(error));
	/*NOTREACHED*/
}
nsock = 0;
for (res = res0; res && nsock < MAXSOCK; res = res->ai_next) {
	s[nsock] = socket(res->ai_family, res->ai_socktype,
	    res->ai_protocol);
	if (s[nsock] < 0) {
		cause = "socket";
		continue;
	}

	if (bind(s[nsock], res->ai_addr, res->ai_addrlen) < 0) {
		cause = "bind";
		close(s[nsock]);
		continue;
	}
	(void) listen(s[nsock], 5);

	nsock++;
}
if (nsock == 0) {
	err(1, "%s", cause);
	/*NOTREACHED*/
}
freeaddrinfo(res0);
.Ed
.\"
d251 4
d259 1
a288 1
.\"
d292 5
a296 8
function is defined in IEEE POSIX 1003.1g draft specification,
and documented in
.Dq Basic Socket Interface Extensions for IPv6
.Pq RFC 3493 .
.\"
.Sh HISTORY
The implementation first appeared in WIDE Hydrangea IPv6 protocol stack kit.
.\"
d298 3
a300 1
The current implementation is not thread-safe.
@


1.29
log
@move gai_strerror into its own page, and make the get* pages more readable;
prompted by henning;

ok henning@@ itojun@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.28 2004/04/14 10:06:03 jmc Exp $
@


1.28
log
@remove references to rfc 2553, since 3493 obsoletes it;
ok itojun@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.27 2004/04/14 07:06:15 itojun Exp $
d39 1
a39 2
.Nm freeaddrinfo ,
.Nm gai_strerror
a50 2
.Ft "char *"
.Fn gai_strerror "int ecode"
d62 61
d229 1
a229 1
.Fn socket
d240 5
d247 2
a248 5
bit is set in the
.Fa ai_flags
member of the
.Fa hints
structure, then the caller plans to use the returned socket address
d250 1
a250 1
.Fn bind .
d262 2
a263 5
bit is not set in the
.Fa ai_flags
member of the
.Fa hints
structure, then the returned socket address structure will be ready for a
d265 1
a265 1
.Fn connect
d268 2
a269 2
.Fn connect ,
.Fn sendto ,
d271 1
a271 1
.Fn sendmsg
d277 1
a277 1
.Pp
d280 2
a281 5
bit is set in the
.Fa ai_flags
member of the
.Fa hints
structure, then upon successful return the
d288 1
a288 1
.Pp
d291 2
a292 5
bit is set in the
.Fa ai_flags
member of the
.Fa hints
structure, then a non-null
d298 2
a299 1
This flag prevents any type of name resolution service (e.g., the DNS)
d301 1
a301 1
.Pp
d304 2
a305 5
bit is set in the
.Fa ai_flags
member of the
.Fa hints
structure, then a non-null
d311 2
a312 1
This flag prevents any type of name resolution service (e.g., the NIS)
d314 1
d318 2
a319 2
must sufficiently be consistent and unambiguous.
Here are pitfall cases you may encounter:
d376 2
a377 2
.Pp
All of the information returned by
d379 4
a382 63
is dynamically allocated:
the
.Li addrinfo
structures, the socket address structures, and canonical node name
strings pointed to by the addrinfo structures.
To return this information to the system the function
.Fn freeaddrinfo
is called.
The
.Fa addrinfo
structure pointed to by the
.Fa ai argument
is freed, along with any dynamic storage pointed to by the structure.
This operation is repeated until a
.Dv NULL
.Fa ai_next
pointer is encountered.
.Pp
To aid applications in printing error messages based on the
.Dv EAI_xxx
codes returned by
.Fn getaddrinfo ,
.Fn gai_strerror
is defined.
The argument is one of the
.Dv EAI_xxx
values defined earlier and the return value points to a string describing
the error.
If the argument is not one of the
.Dv EAI_xxx
values, the function still returns a pointer to a string whose contents
indicate an unknown error.
.\"
.Ss Extension for scoped IPv6 address
The implementation allows experimental numeric IPv6 address notation with
scope identifier.
By appending the percent character and scope identifier to addresses,
you can fill the
.Li sin6_scope_id
field for addresses.
This would make management of scoped address easier,
and allows cut-and-paste input of scoped address.
.Pp
At this moment the code supports only link-local addresses with the format.
Scope identifier is hardcoded to the name of the hardware interface associated
with the link.
.Po
such as
.Li ne0
.Pc .
An example is
.Dq Li fe80::1%ne0 ,
which means
.Do
.Li fe80::1
on the link associated with the
.Li ne0
interface
.Dc .
.Pp
The implementation is still very experimental and non-standard.
The current implementation assumes a one-to-one relationship between
the interface and link, which is not necessarily true from the specification.
a483 53
.Sh DIAGNOSTICS
Error return status from
.Fn getaddrinfo
is zero on success and non-zero on errors.
Non-zero error codes are defined in
.Aq Pa netdb.h ,
and as follows:
.Pp
.Bl -tag -width EAI_ADDRFAMILY -compact
.It Dv EAI_ADDRFAMILY
Address family for
.Fa nodename
not supported.
.It Dv EAI_AGAIN
Temporary failure in name resolution.
.It Dv EAI_BADFLAGS
Invalid value for
.Fa ai_flags .
.It Dv EAI_FAIL
Non-recoverable failure in name resolution.
.It Dv EAI_FAMILY
.Fa ai_family
not supported.
.It Dv EAI_MEMORY
Memory allocation failure.
.It Dv EAI_NODATA
No address associated with
.Fa nodename .
.It Dv EAI_NONAME
.Fa nodename
nor
.Fa servname
provided, or not known.
.It Dv EAI_SERVICE
.Fa servname
not supported for
.Fa ai_socktype .
.It Dv EAI_SOCKTYPE
.Fa ai_socktype
not supported.
.It Dv EAI_SYSTEM
System error returned in
.Va errno .
.El
.Pp
If called with proper argument,
.Fn gai_strerror
returns a pointer to a string describing the given error code.
If the argument is not one of the
.Dv EAI_xxx
values, the function still returns a pointer to a string whose contents
indicate an unknown error.
.\"
d485 1
a531 2
.Pp
The text was shamelessly copied from RFC 2553.
@


1.27
log
@implement RFC3493 AI_NUMERICSERV.  tedu ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.26 2004/03/01 20:25:44 deraadt Exp $
a557 9
.%A W. Stevens
.%T Basic Socket Interface Extensions for IPv6
.%R RFC 2553
.%D March 1999
.Re
.Rs
.%A R. Gilligan
.%A S. Thomson
.%A J. Bound
d585 1
a585 1
.Pq RFC 2553 .
@


1.26
log
@do not recommend a format string error..; pbastos@@rdc.puc-rio.br
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.25 2003/08/08 09:26:02 jmc Exp $
d250 15
d562 10
@


1.25
log
@refer to RFCs consistently (RFC XXXX);
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.24 2003/07/27 15:34:03 jmc Exp $
d427 1
a427 1
	err(1, cause);
d471 1
a471 1
	err(1, cause);
@


1.24
log
@sync struct addrinfo with what's in <netdb.h>;
ok itojun@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.23 2003/06/02 20:18:35 millert Exp $
d545 1
a545 1
.%R RFC2553
d569 1
a569 1
.Pq RFC2553 .
d577 1
a577 1
The text was shamelessly copied from RFC2553.
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.22 2003/05/30 21:37:59 jmc Exp $
d70 10
a79 10
.Bd -literal -offset
struct addrinfo {                                                  *
     int     ai_flags;     /* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */
     int     ai_family;    /* PF_xxx */
     int     ai_socktype;  /* SOCK_xxx */
     int     ai_protocol;  /* 0 or IPPROTO_xxx for IPv4 and IPv6 */
     size_t  ai_addrlen;   /* length of ai_addr */
     char   *ai_canonname; /* canonical name for nodename */
     struct sockaddr  *ai_addr; /* binary address */
     struct addrinfo  *ai_next; /* next structure in linked list */
@


1.22
log
@- section reorder
- macro cleanup
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.21 2003/05/01 19:10:09 jmc Exp $
d15 1
a15 5
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
@


1.21
log
@typos;
ok itojun@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.20 2002/04/30 16:31:42 mpech Exp $
a566 3
.Sh HISTORY
The implementation first appeared in WIDE Hydrangea IPv6 protocol stack kit.
.\"
d574 3
@


1.20
log
@Initial cleanup:
o) remove extra space in the end of line;
o) remove extra blank lines in the end of file;
o) remove .Pp before .Ss;
o) CAVEAT -> CAVEATS;
o) fix usage of .Fa;
o) <blank-line> -> .Pp;
o) wrap long lines;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.19 2001/08/06 10:42:26 mpech Exp $
d354 1
a354 1
you can fill
d361 1
a361 1
Scope identifier is hardcoded to name of hardware interface associated
d367 1
a367 1
Example would be like
d372 1
a372 1
on the link associated with
d378 2
a379 2
The current implementation assumes one-by-one relationship between
interface and link, which is not necessarily true from the specification.
d387 2
a388 2
It loops through all the addresses available, regardless from address family.
If the destination resolves to IPv4 address, it will use
d394 1
a394 1
Observe that there is no hardcoded reference to particular address family.
d535 1
a536 1
.Xr gethostbyname 3 ,
@


1.19
log
@o) We always close .Bl and .Bd tags;
o) .Sh AUTHOR -> .Sh AUTHORS;
o) We don't like .Pp before/after .Sh;
o) We don't like .Pp before/after .Rs/.Re;
o) NetBSD -> .Nx;
o) OpenBSD -> .Ox;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.18 2001/08/05 18:57:08 itojun Exp $
d261 1
a261 1
will raise an error if members of the 
@


1.18
log
@there's no no host.conf on openbsd.  pointed out by smb
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.17 2001/06/23 05:57:03 deraadt Exp $
a542 1
.Pp
@


1.17
log
@ok, tmac is now fixed
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.16 2001/06/23 02:33:17 deraadt Exp $
a480 7
.Sh FILES
.Bl -tag -width /etc/resolv.conf -compact
.It Pa /etc/hosts
.It Pa /etc/host.conf
.It Pa /etc/resolv.conf
.El
.\"
d539 1
@


1.16
log
@join .%A entries; most by bk@@rt.fm
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.15 2001/02/12 09:24:47 itojun Exp $
d560 2
a561 1
.%A Tatsuya Jinmei and Atsushi Onoe
@


1.15
log
@correct listener side example.  from deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.14 2001/01/26 13:31:35 itojun Exp $
d560 1
a560 2
.%A Tatsuya Jinmei
.%A Atsushi Onoe
@


1.14
log
@wording updates.  typo in example (s/err1/errx/).
sync with latest kame.
@
text
@d1 2
a2 2
.\"	$OpenBSD: getaddrinfo.3,v 1.13 2000/12/24 00:30:54 aaron Exp $
.\"	$KAME: getaddrinfo.3,v 1.27 2001/01/26 13:27:56 itojun Exp $
d437 1
a437 1
The following example tries to open wildcard listening socket onto service
d465 2
a466 2
	if (connect(s[nsock], res->ai_addr, res->ai_addrlen) < 0) {
		cause = "connect";
d470 1
@


1.13
log
@Various repairs, mostly to get rid of short lines.
@
text
@d1 2
a2 2
.\"	$OpenBSD: getaddrinfo.3,v 1.12 2000/08/13 07:23:48 deraadt Exp $
.\"	$KAME: getaddrinfo.3,v 1.22 2000/08/09 21:16:17 itojun Exp $
d261 1
a261 1
will raise error if members in
d263 1
a263 1
structure is not consistent.
d266 1
a266 1
will raise error if you specify
d280 1
a280 1
will raise error because the arguments are not consistent.
d283 1
a283 1
will raise error if you ask for
d295 1
a295 1
will raise error, because service names are not defined for the internet
d299 1
a299 1
If you specify numeric
d307 1
a307 1
will raise error.
d350 1
a350 1
.Sh EXTENSION
d353 2
a354 1
By appending atmark and scope identifier to addresses, you can fill
d409 1
a409 1
	err1(1, "%s", gai_strerror(error));
d453 1
a453 1
	err1(1, "%s", gai_strerror(error));
d579 1
a579 1
function is defined IEEE POSIX 1003.1g draft specification,
@


1.12
log
@strings are NUL-terminated, not NULL-terminated
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.11 2000/08/09 23:12:04 itojun Exp $
d261 1
a261 1
will raise error if members in 
@


1.11
log
@document that the current implementation is not thread-safe.  sync with kame.
From: "Greg Thompson" <johnnyteardrop@@hotmail.com>
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.10 2000/07/25 04:52:55 itojun Exp $
d91 1
a91 1
arguments are pointers to null-terminated strings or
d105 1
a105 1
(i.e., a dotted-decimal IPv4 address or an IPv6 hex address)
d235 1
a235 1
structure in the linked list will point to a null-terminated string
@


1.10
log
@document pitfall cases in argument parsing.  sync with kame.
@
text
@d1 2
a2 2
.\"	$OpenBSD: getaddrinfo.3,v 1.9 2000/06/30 16:52:44 itojun Exp $
.\"	$KAME: getaddrinfo.3,v 1.21 2000/07/25 04:49:42 itojun Exp $
d584 2
@


1.9
log
@typo in RFC number. KAME PR 263
@
text
@d1 2
a2 2
.\"	$OpenBSD: getaddrinfo.3,v 1.8 2000/06/22 20:29:00 itojun Exp $
.\"	$KAME: getaddrinfo.3,v 1.15 2000/06/30 16:46:00 itojun Exp $
d254 61
d562 1
a562 1
.%N draft-ietf-ipngwg-scopedaddr-format-01.txt
@


1.8
log
@add paper by cmetz.  correct example. (sync with kame)
@
text
@d1 2
a2 2
.\"	$OpenBSD: getaddrinfo.3,v 1.7 2000/02/14 13:23:54 itojun Exp $
.\"	$KAME: getaddrinfo.3,v 1.14 2000/06/22 20:25:50 itojun Exp $
d520 1
a520 1
.Pq RFC2533 .
@


1.7
log
@add BUGS section about getaddrinfo(3) search order.
NetBSD PR: 9413
From: Thilo Manske <Thilo.Manske@@HEH.Uni-Oldenburg.DE>
@
text
@d1 2
a2 1
.\"	$OpenBSD: getaddrinfo.3,v 1.6 2000/01/17 08:20:27 deraadt Exp $
a35 1
.\"     KAME Id: getaddrinfo.3,v 1.8 2000/01/17 08:13:03 itojun Exp
d306 1
a306 1
.Dq Li fe80::1@@ne0 ,
d501 1
a501 1
.%N draft-ietf-ipngwg-scopedaddr-format-00.txt
d504 6
a523 5
.Pp
.Nm
can mistakingly query databases in different order than
.Xr resolv.conf 5
suggests.
@


1.6
log
@indent
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.5 2000/01/17 08:16:58 itojun Exp $
d518 5
@


1.5
log
@sync with latest KAME version.  now includes description on scoped addr
extension.  add examples (good enough? >deraadt)
@
text
@d1 1
a1 1
.\"	$OpenBSD: getaddrinfo.3,v 1.4 2000/01/06 22:00:17 deraadt Exp $
d353 1
a353 1
		res->ai_protocol);
d397 1
a397 1
		res->ai_protocol);
@


1.4
log
@fix includes; bde
@
text
@d1 2
a2 1
.\"	$OpenBSD: getaddrinfo.3,v 1.3 1999/07/05 04:40:59 aaron Exp $
d35 1
a35 1
.\"     $Id: getaddrinfo.3,v 1.3 1999/07/05 04:40:59 aaron Exp $
d40 1
d46 1
d58 1
d288 130
d424 1
d477 1
d487 21
a507 2
R. Gilligan, S.  Thomson, J. Bound, and W. Stevens,
``Basic Socket Interface Extensions for IPv6,'' RFC2553, March 1999.
d515 1
@


1.3
log
@repairs; better English, formatting, etc.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d34 1
a34 1
.\"     $Id: getaddrinfo.3,v 1.2 1999/07/03 20:26:55 deraadt Exp $
d45 1
@


1.2
log
@cleaner
@
text
@d1 1
d34 1
a34 1
.\"     $Id: getaddrinfo.3,v 1.1 1999/07/03 20:22:21 deraadt Exp $
d38 1
a38 1
.Os KAME
d40 1
a40 1
.Nm getaddrinfo
d64 4
a67 2
The addrinfo structure is defined as a result of including the
.Li <netdb.h>
d88 1
a88 3
One or both of these two arguments must be a
.Pf non Dv -NULL
pointer.
d97 1
a97 2
A
.Pf non Dv -NULL
d100 2
a101 5
.Po
i.e., a dotted-decimal IPv4 address or an IPv6 hex address
.Pc .
A
.Pf non Dv -NULL
d117 1
a117 3
must be zero or a
.Dv NULL
pointer.
d147 1
a147 3
is a
.Dv NULL
pointer, this is the same as if the caller had filled in an
d151 2
a152 1
set to PF_UNSPEC.
d161 1
a161 3
pointer, until a
.Dv NULL
pointer is encountered.
d192 1
a192 3
argument is a
.Dv NULL
pointer, then the IP address portion of the socket
d211 2
a212 1
.Fn sendto , or
d217 1
a217 3
argument is a
.Dv NULL
pointer, then the IP address portion of the
d240 1
a240 2
structure, then a
.Pf non Dv -NULL
d254 1
a254 1
structures, and the socket address structures and canonical node name
d294 1
a294 1
.Li <netdb.h> ,
d299 3
a301 1
address family for nodename not supported
d303 1
a303 1
temporary failure in name resolution
d305 2
a306 1
invalid value for ai_flags
d308 1
a308 1
non-recoverable failure in name resolution
d310 2
a311 1
ai_family not supported
d313 1
a313 1
memory allocation failure
d315 2
a316 1
no address associated with nodename
d318 4
a321 1
nodename nor servname provided, or not known
d323 3
a325 1
servname not supported for ai_socktype
d327 2
a328 1
ai_socktype not supported
d330 2
a331 1
system error returned in errno
d356 2
a357 1
and documented in ``Basic Socket Interface Extensions for IPv6''
@


1.1
log
@man pages from WIDE
@
text
@d33 1
a33 1
.\"     $Id: getaddrinfo.3,v 1.1.2.2.10.2 1999/04/08 05:38:57 sumikawa Exp $
d57 1
a57 1
It performs functionality of 
d61 1
a61 1
in more sophisticated manner.
d259 1
a259 1
from being called.                                               
d302 1
a302 1
Error return status from 
d310 1
a310 1
.It Dv EAI_ADDRFAMILY 
@

