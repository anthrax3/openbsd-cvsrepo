head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.10
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.8
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.58
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.50
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.54
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.52
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.48
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.46
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.44
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.42
	OPENBSD_5_0:1.9.0.40
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.38
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.36
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.32
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.34
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.30
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.28
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.26
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.24
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.22
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.20
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.18
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.16
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.14
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.12
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.10
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.11
date	2015.10.23.13.09.19;	author claudio;	state Exp;
branches;
next	1.10;
commitid	mGDeHxFI9a2xgY6t;

1.10
date	2015.09.14.10.47.01;	author guenther;	state Exp;
branches;
next	1.9;
commitid	WOeDgoKYmySSyUqQ;

1.9
date	2002.03.07.22.40.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.05.02.31.34;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.22.19.04.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.12.16.07.46.51;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.07.08.22.29.53;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.07.01.15.35.58;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.06.23.22.50.49;	author cmetz;	state Exp;
branches;
next	1.2;

1.2
date	99.06.23.22.26.03;	author cmetz;	state Exp;
branches;
next	1.1;

1.1
date	99.06.23.21.55.29;	author cmetz;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Switch if_nameindex(3) to use the new NET_RT_IFNAMES sysctl to get the
list of interface names. At the same time switch if_nametoindex(3) and
if_indextoname(3) to use if_nameindex(3) instead of getifaddrs(3).
if_nameindex(3) exposes much less then getifaddrs(3) and is allowed by
pledge(2).
With and OK deraadt@@
@
text
@/*	$OpenBSD: if_indextoname.c,v 1.10 2015/09/14 10:47:01 guenther Exp $	*/
/*	$KAME: if_indextoname.c,v 1.6 2000/11/07 22:33:25 jinmei Exp $	*/

/*-
 * Copyright (c) 2015 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 1997, 2000
 *	Berkeley Software Design, Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI Id: if_indextoname.c,v 2.3 2000/04/17 22:38:05 dab Exp
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

/*
 * From RFC 2533:
 *
 * The second function maps an interface index into its corresponding
 * name.
 *
 *    #include <net/if.h>
 *
 *    char  *if_indextoname(unsigned int ifindex, char *ifname);
 *
 * The ifname argument must point to a buffer of at least IF_NAMESIZE
 * bytes into which the interface name corresponding to the specified
 * index is returned.  (IF_NAMESIZE is also defined in <net/if.h> and
 * its value includes a terminating null byte at the end of the
 * interface name.) This pointer is also the return value of the
 * function.  If there is no interface corresponding to the specified
 * index, NULL is returned, and errno is set to ENXIO, if there was a
 * system error (such as running out of memory), if_indextoname returns
 * NULL and errno would be set to the proper value (e.g., ENOMEM).
 */

char *
if_indextoname(unsigned int ifindex, char *ifname)
{
	struct if_nameindex *ifni, *ifni2;

	if ((ifni = if_nameindex()) == NULL)
		return NULL;

	for (ifni2 = ifni; ifni2->if_index != 0; ifni2++) {
		if (ifni2->if_index == ifindex) {
			strlcpy(ifname, ifni2->if_name, IFNAMSIZ);
			if_freenameindex(ifni);
			return ifname;
		}
	}

	if_freenameindex(ifni);
	errno = ENXIO;
	return NULL;
}
DEF_WEAK(if_indextoname);
@


1.10
log
@Wrap <net/if.h> and <net/if_dl.h> so internal calls go direct and all the
symbols are weak
@
text
@d1 1
a1 1
/*	$OpenBSD: if_indextoname.c,v 1.9 2002/03/07 22:40:23 millert Exp $	*/
d5 1
a31 1
#include <net/if_dl.h>
a32 1
#include <ifaddrs.h>
d61 1
a61 2
	struct ifaddrs *ifaddrs, *ifa;
	int error = 0;
d63 2
a64 2
	if (getifaddrs(&ifaddrs) < 0)
		return(NULL);	/* getifaddrs properly set errno */
d66 6
a71 5
	for (ifa = ifaddrs; ifa != NULL; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr &&
		    ifa->ifa_addr->sa_family == AF_LINK &&
		    ifindex == ((struct sockaddr_dl*)ifa->ifa_addr)->sdl_index)
			break;
d74 3
a76 11
	if (ifa == NULL) {
		error = ENXIO;
		ifname = NULL;
	}
	else
		strlcpy(ifname, ifa->ifa_name, IFNAMSIZ);

	freeifaddrs(ifaddrs);

	errno = error;
	return(ifname);
@


1.9
log
@Replace SIOCGIFCONF-using NRL versions with KAME versions that use
getifaddrs(3).  Fixes problems on LP64 platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 1
@


1.8
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 6
a6 2
/*
 * Copyright (c) 1998-1999, Craig Metz, All rights reserved.
a12 10
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Craig Metz and
 *      by other contributors.
 * 4. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d14 1
a14 1
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
d17 1
a17 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
d25 2
a29 1
#include <stdlib.h>
d31 1
a31 1
#include <sys/ioctl.h>
d33 3
a35 1
#include <net/if_dl.h>
a36 2
#include <unistd.h>
#include <string.h>
d38 20
a57 1
static char __name[IFNAMSIZ];
d60 1
a60 1
if_indextoname(unsigned int index, char *name)
d62 10
a71 27
	int     i, fd = -1, extra, len = 0;
	struct ifconf ifconf;
	char    lastname[IFNAMSIZ], iname[IFNAMSIZ], *retname = NULL, *inbuf;
	struct sockaddr *sa;
	void	*p;

	ifconf.ifc_buf = 0;

	if (!name)
		name = __name;

	if ((fd = socket(PF_INET, SOCK_DGRAM, 0)) < 0)
		goto ret;

	/*
	 * Try ifc_len == 0 hack first, to get the actual length.
	 * If that fails, revert to a loop which grows the ifc_buf
	 * until it is sufficiently large.
	 */
	extra = sizeof(struct ifreq);
	while (1) {
		ifconf.ifc_len = len;
		if (ioctl(fd, SIOCGIFCONF, (void *) &ifconf) == -1 &&
		    ifconf.ifc_buf)
			goto ret;
		if (ifconf.ifc_buf &&
		    ifconf.ifc_len + extra < len)
a72 12
		if (ifconf.ifc_buf) {
			if (len == 0)
				len = 4096;
			ifconf.ifc_len = len *= 2;
		} else {
			len = ifconf.ifc_len;
			extra = 0;
		}
		inbuf = realloc(ifconf.ifc_buf, ifconf.ifc_len);
		if (inbuf == NULL)
			goto ret;
		ifconf.ifc_buf = inbuf;
d75 3
a77 34
	i = 0;
	p = ifconf.ifc_buf;
	len = ifconf.ifc_len;
	lastname[0] = 0;
	lastname[sizeof(lastname)-1] = 0;
	iname[0] = 0;

	while (len > 0) {
		if (len < (IFNAMSIZ + sizeof(struct sockaddr)))
			goto ret;
		if (strncmp(lastname, p, IFNAMSIZ)) {
			if (i == index)
				memcpy(iname, lastname, sizeof(iname));
			strlcpy(lastname, p, sizeof(lastname));
			i++;
		}
		len -= IFNAMSIZ;
		p += IFNAMSIZ;
		sa = p;

		if (sa->sa_family == AF_LINK) {
			struct sockaddr_dl *sd = p;

			if (sd->sdl_index == index) {
				strlcpy(name, lastname, IFNAMSIZ);
				retname = name;
				goto ret;
			}
		}

		if (len < sa->sa_len)
			goto ret;
		len -= sa->sa_len;
		p += sa->sa_len;
d79 2
d82 1
a82 2
	if (i == index)
		strlcpy(iname, lastname, sizeof(iname));
d84 2
a85 10
	if (iname[0]) {
		strlcpy(name, iname, IFNAMSIZ);
		retname = name;
	}
ret:
	if (fd != -1)
		close(fd);
	if (ifconf.ifc_buf)
		free(ifconf.ifc_buf);
	return (retname);
@


1.7
log
@Wall
@
text
@a1 1
 * %%% copyright-cmetz-98-bsd
@


1.6
log
@incorrect bounds on strlcpy()
@
text
@d41 1
@


1.5
log
@use SIOCGIFCONF much more carefully
@
text
@d114 1
a114 1
				strlcpy(name, lastname, sizeof(name));
d130 1
a130 1
		strlcpy(name, iname, sizeof(name));
@


1.4
log
@indent and audit
@
text
@d48 1
a48 1
	int     i, fd, len;
d50 1
a50 1
	char    lastname[IFNAMSIZ], iname[IFNAMSIZ], *retname = NULL;
d54 1
a54 2
	if ((fd = socket(PF_INET, SOCK_DGRAM, 0)) < 0)
		return 0;
d59 1
a59 9
	ifconf.ifc_len = 0;
	ifconf.ifc_buf = 0;
	if (ioctl(fd, SIOCGIFCONF, (void *) &ifconf))
		goto ret;
	if (ifconf.ifc_len < IFNAMSIZ)
		goto ret;
	if (!(ifconf.ifc_buf = malloc(ifconf.ifc_len)))
		goto ret;
	if (ioctl(fd, SIOCGIFCONF, (void *) &ifconf))
d61 28
d134 2
a135 1
	close(fd);
@


1.3
log
@Compilation fixes.
@
text
@d4 1
a4 1
 * 
a19 12
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a20 16
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Craig Metz and
 *      by other contributors.
 * 4. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
a31 1
 *
d41 1
d43 1
a43 1
static char __name[IFNAMSIZ + 1];
d45 2
a46 1
char *if_indextoname(unsigned int index, char *name)
d48 66
a113 62
  int i, fd;
  struct ifconf ifconf;
  void *p;
  int len;
  char lastname[IFNAMSIZ + 1];
  char iname[IFNAMSIZ + 1];
  char *retname = NULL;

  if ((fd = socket(PF_INET, SOCK_DGRAM, 0)) < 0)
    return 0;

  if (!name)
    name = __name;

  ifconf.ifc_len = 0;
  ifconf.ifc_buf = 0;
  if (ioctl(fd, SIOCGIFCONF, (void *)&ifconf))
    goto ret;
  if (ifconf.ifc_len < IFNAMSIZ)
    goto ret;
  if (!(ifconf.ifc_buf = malloc(ifconf.ifc_len)))
    goto ret;
  if (ioctl(fd, SIOCGIFCONF, (void *)&ifconf))
    goto ret;

  i = 0;
  p = ifconf.ifc_buf;
  len = ifconf.ifc_len;
  lastname[0] = 0;
  lastname[IFNAMSIZ] = 0;
  iname[0] = 0;

  while(len > 0) {
    if (len < (IFNAMSIZ + sizeof(struct sockaddr)))
      goto ret;
    if (strncmp(lastname, p, IFNAMSIZ)) {
      if (i == index)
	strcpy(iname, lastname);
      memcpy(lastname, p, IFNAMSIZ);
      i++;
    };
    len -= IFNAMSIZ;
    p += IFNAMSIZ;

    if (((struct sockaddr *)p)->sa_family == AF_LINK)
      if (((struct sockaddr_dl *)p)->sdl_index == index) {
	strcpy(retname = name, lastname);
	goto ret;
      };

    if (len < SA_LEN((struct sockaddr *)p))
      goto ret;
    len -= SA_LEN((struct sockaddr *)p);
    p += SA_LEN((struct sockaddr *)p);
  };

  if (i == index)
    strcpy(iname, lastname);

  if (iname[0])
    strcpy(retname = name, iname);

d115 5
a119 4
  close(fd);
  free(ifconf.ifc_buf);
  return retname;
};
@


1.2
log
@Removed portability ifdefs and calls to nonstandard back-end.
@
text
@d91 1
a91 1
  if (ioctl(fd, SIOCGIFCONF, (void *)ifconf))
d93 1
a93 1
  if (ifconf->ifc_len < IFNAMSIZ)
d95 1
a95 1
  if (!(ifconf->ifc_buf = malloc(ifconf->ifc_len)))
d97 1
a97 1
  if (ioctl(fd, SIOCGIFCONF, (void *)ifconf))
@


1.1
log
@Added some protocol independent interfaces (supposedly IPv6 support APIs, but
ones that are useful for all protocols, not just IPv6).
@
text
@a60 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Craig Metz and
 *      by other contributors.
 * 4. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a67 1
#ifdef AF_LINK
a68 1
#endif /* AF_LINK */
a75 3
#ifdef SIOCGIFNAME
  struct ifreq ifreq;
#else /* SIOCGIFNAME */
a81 1
#endif /* SIOCGIFNAME */
d89 10
a98 14
#ifdef SIOCGIFNAME
  ifreq.ifr_ifindex = index;
  i = ioctl(fd, SIOCGIFNAME, &ifreq);
  close(fd);
  if (i)
    return NULL;

  strcpy(name, ifreq.ifr_name);
  return name;
#else /* SIOCGIFNAME */
  if (__siocgifconf(fd, &ifconf)) {
    close(fd);
    return NULL;
  };
a118 1
#ifdef AF_LINK
a123 1
#endif /* AF_LINK */
a140 1
#endif /* SIOCGIFNAME */
@

