head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.14.0.28
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.26
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.22
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.20
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.18
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.16
	OPENBSD_5_0:1.14.0.14
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.12
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.10
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.6
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.8
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.12
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.18
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.16
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.14
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.12
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.05.01.15.17.29;	author millert;	state Exp;
branches;
next	1.19;
commitid	LAKv5dxlDXuFw0jV;

1.19
date	2015.12.14.03.25.59;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	6idgy7jHjp60ENt8;

1.18
date	2015.10.05.02.57.16;	author guenther;	state Exp;
branches;
next	1.17;
commitid	hN3BtB3F33HLhHuv;

1.17
date	2015.09.13.21.36.08;	author guenther;	state Exp;
branches;
next	1.16;
commitid	3UeBMlmq9gGNKZCC;

1.16
date	2015.01.16.18.18.58;	author millert;	state Exp;
branches;
next	1.15;
commitid	eexzrTnC64Onwk7E;

1.15
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	0DYulI8hhujBHMcR;

1.14
date	2008.04.16.22.35.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.06.20.30.03;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.20.18.36;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.17.19.42.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.09.01.08.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.04.30.05.54.44;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.04.19.10.10.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.03.27.20.45.33;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.03.13.19.07.35;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.29.42;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.02.19.19.53.25;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove old NeXT-specific cruft.  From mmcc@@
@
text
@/*	$OpenBSD: res_comp.c,v 1.19 2015/12/14 03:25:59 mmcc Exp $	*/

/*
 * ++Copyright++ 1985, 1993
 * -
 * Copyright (c) 1985, 1993
 *    The Regents of the University of California.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/nameser.h>

#include <stdio.h>
#include <resolv.h>
#include <ctype.h>

#include <unistd.h>
#include <limits.h>
#include <string.h>

static int dn_find(u_char *, u_char *, u_char **, u_char **);

/*
 * Expand compressed domain name 'comp_dn' to full domain name.
 * 'msg' is a pointer to the beginning of the message,
 * 'eomorig' points to the first location after the message,
 * 'exp_dn' is a pointer to a buffer of size 'length' for the result.
 * Return size of compressed name or -1 if there was an error.
 */
int
dn_expand(const u_char *msg, const u_char *eomorig, const u_char *comp_dn,
    char *exp_dn, int length)
{
	const u_char *cp;
	char *dn;
	int n, c;
	char *eom;
	int len = -1, checked = 0;

	dn = exp_dn;
	cp = comp_dn;
	if (length > HOST_NAME_MAX)
		length = HOST_NAME_MAX;
	eom = exp_dn + length;
	/*
	 * fetch next label in domain name
	 */
	while ((n = *cp++)) {
		/*
		 * Check for indirection
		 */
		switch (n & INDIR_MASK) {
		case 0:
			if (dn != exp_dn) {
				if (dn >= eom)
					return (-1);
				*dn++ = '.';
			}
			if (dn+n >= eom)
				return (-1);
			checked += n + 1;
			while (--n >= 0) {
				if (((c = *cp++) == '.') || (c == '\\')) {
					if (dn + n + 2 >= eom)
						return (-1);
					*dn++ = '\\';
				}
				*dn++ = c;
				if (cp >= eomorig)	/* out of range */
					return (-1);
			}
			break;

		case INDIR_MASK:
			if (len < 0)
				len = cp - comp_dn + 1;
			cp = msg + (((n & 0x3f) << 8) | (*cp & 0xff));
			if (cp < msg || cp >= eomorig)	/* out of range */
				return (-1);
			checked += 2;
			/*
			 * Check for loops in the compressed name;
			 * if we've looked at the whole message,
			 * there must be a loop.
			 */
			if (checked >= eomorig - msg)
				return (-1);
			break;

		default:
			return (-1);			/* flag error */
		}
	}
	*dn = '\0';
	if (len < 0)
		len = cp - comp_dn;
	return (len);
}
DEF_WEAK(dn_expand);

/*
 * Compress domain name 'exp_dn' into 'comp_dn'.
 * Return the size of the compressed name or -1.
 * 'length' is the size of the array pointed to by 'comp_dn'.
 * 'dnptrs' is a list of pointers to previous compressed names. dnptrs[0]
 * is a pointer to the beginning of the message. The list ends with NULL.
 * 'lastdnptr' is a pointer to the end of the arrary pointed to
 * by 'dnptrs'. Side effect is to update the list of pointers for
 * labels inserted into the message as we compress the name.
 * If 'dnptr' is NULL, we don't try to compress names. If 'lastdnptr'
 * is NULL, we don't update the list.
 */
int
dn_comp(const char *exp_dn, u_char *comp_dn, int length, u_char **dnptrs,
    u_char **lastdnptr)
{
	u_char *cp, *dn;
	int c, l;
	u_char **cpp, **lpp, *sp, *eob;
	u_char *msg;

	dn = (u_char *)exp_dn;
	cp = comp_dn;
	eob = cp + length;
	lpp = cpp = NULL;
	if (dnptrs != NULL) {
		if ((msg = *dnptrs++) != NULL) {
			for (cpp = dnptrs; *cpp != NULL; cpp++)
				;
			lpp = cpp;	/* end of list to search */
		}
	} else
		msg = NULL;
	for (c = *dn++; c != '\0'; ) {
		/* look to see if we can use pointers */
		if (msg != NULL) {
			if ((l = dn_find(dn-1, msg, dnptrs, lpp)) >= 0) {
				if (cp+1 >= eob)
					return (-1);
				*cp++ = (l >> 8) | INDIR_MASK;
				*cp++ = l % 256;
				return (cp - comp_dn);
			}
			/* not found, save it */
			if (lastdnptr != NULL && cpp < lastdnptr-1) {
				*cpp++ = cp;
				*cpp = NULL;
			}
		}
		sp = cp++;	/* save ptr to length byte */
		do {
			if (c == '.') {
				c = *dn++;
				break;
			}
			if (c == '\\') {
				if ((c = *dn++) == '\0')
					break;
			}
			if (cp >= eob) {
				if (msg != NULL)
					*lpp = NULL;
				return (-1);
			}
			*cp++ = c;
		} while ((c = *dn++) != '\0');
		/* catch trailing '.'s but not '..' */
		if ((l = cp - sp - 1) == 0 && c == '\0') {
			cp--;
			break;
		}
		if (l <= 0 || l > MAXLABEL) {
			if (msg != NULL)
				*lpp = NULL;
			return (-1);
		}
		*sp = l;
	}
	if (cp >= eob) {
		if (msg != NULL)
			*lpp = NULL;
		return (-1);
	}
	*cp++ = '\0';
	return (cp - comp_dn);
}

/*
 * Skip over a compressed domain name. Return the size or -1.
 */
int
__dn_skipname(const u_char *comp_dn, const u_char *eom)
{
	const u_char *cp;
	int n;

	cp = comp_dn;
	while (cp < eom && (n = *cp++)) {
		/*
		 * check for indirection
		 */
		switch (n & INDIR_MASK) {
		case 0:			/* normal case, n == len */
			cp += n;
			continue;
		case INDIR_MASK:	/* indirection */
			cp++;
			break;
		default:		/* illegal type */
			return (-1);
		}
		break;
	}
	if (cp > eom)
		return (-1);
	return (cp - comp_dn);
}

static int
mklower(int ch)
{
	if (isascii(ch) && isupper(ch))
		return (tolower(ch));
	return (ch);
}

/*
 * Search for expanded name from a list of previously compressed names.
 * Return the offset from msg if found or -1.
 * dnptrs is the pointer to the first name on the list,
 * not the pointer to the start of the message.
 */
static int
dn_find(u_char *exp_dn, u_char *msg, u_char **dnptrs, u_char **lastdnptr)
{
	u_char *dn, *cp, **cpp;
	int n;
	u_char *sp;

	for (cpp = dnptrs; cpp < lastdnptr; cpp++) {
		dn = exp_dn;
		sp = cp = *cpp;
		while ((n = *cp++)) {
			/*
			 * check for indirection
			 */
			switch (n & INDIR_MASK) {
			case 0:		/* normal case, n == len */
				while (--n >= 0) {
					if (*dn == '.')
						goto next;
					if (*dn == '\\')
						dn++;
					if (mklower(*dn++) != mklower(*cp++))
						goto next;
				}
				if ((n = *dn++) == '\0' && *cp == '\0')
					return (sp - msg);
				if (n == '.')
					continue;
				goto next;

			case INDIR_MASK:	/* indirection */
				cp = msg + (((n & 0x3f) << 8) | *cp);
				break;

			default:	/* illegal type */
				return (-1);
			}
		}
		if (*dn == '\0')
			return (sp - msg);
	next:	;
	}
	return (-1);
}

/*
 * Verify that a domain name uses an acceptable character set.
 */

/*
 * Note the conspicuous absence of ctype macros in these definitions.  On
 * non-ASCII hosts, we can't depend on string literals or ctype macros to
 * tell us anything about network-format data.  The rest of the BIND system
 * is not careful about this, but for some reason, we're doing it right here.
 */
#define PERIOD 0x2e
#define	hyphenchar(c) ((c) == 0x2d)
#define bslashchar(c) ((c) == 0x5c)
#define underscorechar(c) ((c) == 0x5f)
#define periodchar(c) ((c) == PERIOD)
#define asterchar(c) ((c) == 0x2a)
#define alphachar(c) (((c) >= 0x41 && (c) <= 0x5a) \
		   || ((c) >= 0x61 && (c) <= 0x7a))
#define digitchar(c) ((c) >= 0x30 && (c) <= 0x39)

#define borderchar(c) (alphachar(c) || digitchar(c))
#define middlechar(c) (borderchar(c) || hyphenchar(c) || underscorechar(c))
#define	domainchar(c) ((c) > 0x20 && (c) < 0x7f)

int
__res_hnok(const char *dn)
{
	int pch = PERIOD, ch = *dn++;

	while (ch != '\0') {
		int nch = *dn++;

		if (periodchar(ch)) {
			;
		} else if (periodchar(pch)) {
			if (!borderchar(ch))
				return (0);
		} else if (periodchar(nch) || nch == '\0') {
			if (!borderchar(ch))
				return (0);
		} else {
			if (!middlechar(ch))
				return (0);
		}
		pch = ch, ch = nch;
	}
	return (1);
}
DEF_STRONG(__res_hnok);

/*
 * hostname-like (A, MX, WKS) owners can have "*" as their first label
 * but must otherwise be as a host name.
 */
int
res_ownok(const char *dn)
{
	if (asterchar(dn[0])) {
		if (periodchar(dn[1]))
			return (res_hnok(dn+2));
		if (dn[1] == '\0')
			return (1);
	}
	return (res_hnok(dn));
}

/*
 * SOA RNAMEs and RP RNAMEs can have any printable character in their first
 * label, but the rest of the name has to look like a host name.
 */
int
res_mailok(const char *dn)
{
	int ch, escaped = 0;

	/* "." is a valid missing representation */
	if (*dn == '\0')
		return(1);

	/* otherwise <label>.<hostname> */
	while ((ch = *dn++) != '\0') {
		if (!domainchar(ch))
			return (0);
		if (!escaped && periodchar(ch))
			break;
		if (escaped)
			escaped = 0;
		else if (bslashchar(ch))
			escaped = 1;
	}
	if (periodchar(ch))
		return (res_hnok(dn));
	return(0);
}

/*
 * This function is quite liberal, since RFC 1034's character sets are only
 * recommendations.
 */
int
res_dnok(const char *dn)
{
	int ch;

	while ((ch = *dn++) != '\0')
		if (!domainchar(ch))
			return (0);
	return (1);
}

/*
 * Routines to insert/extract short/long's.
 */

u_int16_t
_getshort(const u_char *msgp)
{
	u_int16_t u;

	GETSHORT(u, msgp);
	return (u);
}
DEF_STRONG(_getshort);

u_int32_t
_getlong(const u_char *msgp)
{
	u_int32_t u;

	GETLONG(u, msgp);
	return (u);
}
DEF_STRONG(_getlong);

void
__putshort(u_int16_t s, u_char *msgp)
{
	PUTSHORT(s, msgp);
}

void
__putlong(u_int32_t l, u_char *msgp)
{
	PUTLONG(l, msgp);
}
@


1.19
log
@s/begining/beginning/g
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.18 2015/10/05 02:57:16 guenther Exp $	*/
a445 12

#ifdef NeXT
/*
 * nExt machines have some funky library conventions, which we must maintain.
 */
u_int16_t
res_getshort(msgp)
	const u_char *msgp;
{
	return (_getshort(msgp));
}
#endif
@


1.18
log
@Wrap <resolv.h> so that internal calls go direct

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.17 2015/09/13 21:36:08 guenther Exp $	*/
d70 1
a70 1
 * 'msg' is a pointer to the begining of the message,
@


1.17
log
@Wrap <arpa/inet.h> and <arpa/nameser.h> so that calls go direct and the
symbols without underbar prefix are all weak
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.16 2015/01/16 18:18:58 millert Exp $	*/
d144 1
d348 1
a348 1
res_hnok(const char *dn)
d371 1
@


1.16
log
@Replace HOST_NAME_MAX+1-1 with HOST_NAME_MAX.  OK deraad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.15 2015/01/16 16:48:51 deraadt Exp $	*/
d443 1
d465 1
@


1.15
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.14 2008/04/16 22:35:23 deraadt Exp $	*/
d87 2
a88 2
	if (length > HOST_NAME_MAX+1-1)
		length = HOST_NAME_MAX+1-1;
@


1.14
log
@permit _ in the middle of a DNS name component
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.13 2005/08/06 20:30:03 espie Exp $	*/
a54 1
#include <sys/param.h>
d63 1
d87 2
a88 2
	if (length > MAXHOSTNAMELEN-1)
		length = MAXHOSTNAMELEN-1;
@


1.13
log
@zap rcsid.
split functions off res_debug.c so that getnetnamadr.c does not pull it
all when it's used.

okay deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.12 2005/03/25 13:24:12 otto Exp $	*/
d335 1
d343 1
a343 1
#define middlechar(c) (borderchar(c) || hyphenchar(c))
@


1.12
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.11 2003/06/02 20:18:36 millert Exp $	*/
a52 9

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)res_comp.c	8.1 (Berkeley) 6/4/93";
static char rcsid[] = "$From: res_comp.c,v 8.11 1996/12/02 09:17:22 vixie Exp $";
#else
static char rcsid[] = "$OpenBSD: res_comp.c,v 1.11 2003/06/02 20:18:36 millert Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.10 2002/02/19 19:39:36 millert Exp $	*/
d59 1
a59 1
static char rcsid[] = "$OpenBSD: res_comp.c,v 1.10 2002/02/19 19:39:36 millert Exp $";
d85 6
a90 8
dn_expand(msg, eomorig, comp_dn, exp_dn, length)
	const u_char *msg, *eomorig, *comp_dn;
	char *exp_dn;
	int length;
{
	register const u_char *cp;
	register char *dn;
	register int n, c;
d167 2
a168 4
dn_comp(exp_dn, comp_dn, length, dnptrs, lastdnptr)
	const char *exp_dn;
	u_char *comp_dn, **dnptrs, **lastdnptr;
	int length;
d170 2
a171 2
	register u_char *cp, *dn;
	register int c, l;
d245 1
a245 2
__dn_skipname(comp_dn, eom)
	const u_char *comp_dn, *eom;
d247 2
a248 2
	register const u_char *cp;
	register int n;
d273 1
a273 2
mklower(ch)
	register int ch;
d287 1
a287 3
dn_find(exp_dn, msg, dnptrs, lastdnptr)
	u_char *exp_dn, *msg;
	u_char **dnptrs, **lastdnptr;
d289 2
a290 2
	register u_char *dn, *cp, **cpp;
	register int n;
d355 1
a355 2
res_hnok(dn)
	const char *dn;
d384 1
a384 2
res_ownok(dn)
	const char *dn;
d400 1
a400 2
res_mailok(dn)
	const char *dn;
d429 1
a429 2
res_dnok(dn)
	const char *dn;
d444 1
a444 2
_getshort(msgp)
	register const u_char *msgp;
d446 1
a446 1
	register u_int16_t u;
d458 1
a458 1
	register const u_char *msgp;
d465 1
a465 2
_getlong(msgp)
	register const u_char *msgp;
d467 1
a467 1
	register u_int32_t u;
d474 1
a474 1
__putshort(register u_int16_t s, register u_char *msgp)
d480 1
a480 3
__putlong(l, msgp)
	register u_int32_t l;
	register u_char *msgp;
@


1.10
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.9 2002/02/17 19:42:23 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d59 1
a59 1
static char rcsid[] = "$OpenBSD: res_comp.c,v 1.9 2002/02/17 19:42:23 millert Exp $";
@


1.9
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.8 1997/07/09 01:08:49 millert Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_comp.c,v 1.8 1997/07/09 01:08:49 millert Exp $";
d492 1
a492 7
#if defined(__STDC__) || defined(__cplusplus)
__putshort(register u_int16_t s, register u_char *msgp)	/* must match proto */
#else
__putshort(s, msgp)
	register u_int16_t s;
	register u_char *msgp;
#endif
@


1.8
log
@Clean up some -Wall flowers.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.7 1997/04/30 05:54:44 tholo Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_comp.c,v 1.7 1997/04/30 05:54:44 tholo Exp $";
d79 1
a79 2
static int	dn_find __P((u_char *exp_dn, u_char *msg,
			     u_char **dnptrs, u_char **lastdnptr));
@


1.7
log
@Remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.6 1997/04/19 10:10:47 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_comp.c,v 1.6 1997/04/19 10:10:47 deraadt Exp $";
d109 1
a109 1
	while (n = *cp++) {
d309 1
a309 1
		while (n = *cp++) {
@


1.6
log
@constrain to MAXHOSTNAMELEN-1 not MAXDNAME, duh
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.5 1997/03/27 20:45:33 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_comp.c,v 1.5 1997/03/27 20:45:33 deraadt Exp $";
d371 1
a371 1
	int ppch = '\0', pch = PERIOD, ch = *dn++;
d388 1
a388 1
		ppch = pch, pch = ch, ch = nch;
@


1.5
log
@constrain hostnames to MAXHOSTNAMELEN (again), and fix a typo
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.4 1997/03/13 19:07:35 downsj Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_comp.c,v 1.4 1997/03/13 19:07:35 downsj Exp $";
d103 3
a105 1
	eom = exp_dn + (length > MAXDNAME ? MAXDNAME : length);
@


1.4
log
@Integrate BIND 4.9.5 resolver and associated routines.

Includes the DNS aware getnetby*() routines and IPv6 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_comp.c,v 1.1 1997/03/12 10:42:08 downsj Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_comp.c,v 1.1 1997/03/12 10:42:08 downsj Exp $";
d103 1
a103 1
	eom = exp_dn + length;
d375 1
a375 1
			NULL;
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 5
a5 1
/*-
d7 2
a8 2
 *	The Regents of the University of California.  All rights reserved.
 *
d19 2
a20 2
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
d24 1
a24 1
 *
d59 6
a64 1
static char rcsid[] = "$OpenBSD: res_comp.c,v 1.7 1996/02/02 15:22:26 mrg Exp $";
d67 1
d69 1
d71 2
a72 1
#include <netinet/in.h>
a73 1
#include <stdio.h>
d75 1
d79 2
a80 1
static int dn_find __P((u_char *, u_char *, u_char **, u_char **));
d122 1
a122 1
				if ((c = *cp++) == '.' || c == '\\') {
a153 3
	for (dn = exp_dn; (c = *dn) != '\0'; dn++)
		if (isascii(c) && isspace(c))
			return (-1);
d276 1
a276 1
		return -1;
d343 113
a455 5
 * Routines to insert/extract short/long's. Must account for byte
 * order and non-alignment problems. This code at least has the
 * advantage of being portable.
 *
 * used by sendmail.
d458 1
a458 1
u_short
d468 12
d492 1
a492 1
__putshort(register u_int16_t s, register u_char *msgp)
@


1.2
log
@netbsd: bind 4.9.3
@
text
@a0 2
/*	$NetBSD: res_comp.c,v 1.7 1996/02/02 15:22:26 mrg Exp $	*/

d55 1
a55 6
#if 0
static char sccsid[] = "@@(#)res_comp.c	8.1 (Berkeley) 6/4/93";
static char rcsid[] = "$Id: res_comp.c,v 8.3 1995/12/06 20:34:50 vixie Exp ";
#else
static char rcsid[] = "$NetBSD: res_comp.c,v 1.7 1996/02/02 15:22:26 mrg Exp $";
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: res_comp.c,v 1.6 1995/02/25 06:20:55 cgd Exp $	*/
d59 1
a59 1
static char rcsid[] = "$Id: res_comp.c,v 4.9.1.1 1993/05/02 22:43:03 vixie Rel ";
d61 1
a61 1
static char rcsid[] = "$NetBSD: res_comp.c,v 1.6 1995/02/25 06:20:55 cgd Exp $";
d70 3
d74 1
a74 1
static int dn_find();
d83 1
d86 1
a86 1
	u_char *exp_dn;
d89 2
a90 1
	register u_char *cp, *dn;
d92 1
a92 1
	u_char *eom;
d96 1
a96 1
	cp = (u_char *)comp_dn;
d116 1
a116 1
				if ((c = *cp++) == '.') {
d123 1
a123 1
					return(-1);
d130 1
a130 1
			cp = (u_char *)msg + (((n & 0x3f) << 8) | (*cp & 0xff));
d132 1
a132 1
				return(-1);
d148 3
d168 1
d170 1
a170 1
	const u_char *exp_dn;
d182 1
d248 1
d252 1
a252 1
	register u_char *cp;
d255 1
a255 1
	cp = (u_char *)comp_dn;
d277 9
d315 1
a315 1
					if (*dn++ != *cp++)
d324 4
a329 3

			case INDIR_MASK:	/* indirection */
				cp = msg + (((n & 0x3f) << 8) | *cp);
d349 1
a349 1
	register u_char *msgp;
d359 1
a359 1
	register u_char *msgp;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
