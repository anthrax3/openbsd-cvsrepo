head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.6
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.17.0.20
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.18
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.16
	OPENBSD_5_0:1.17.0.14
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.12
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.10
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.12
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.10
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.8
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.12.0.6
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.24
date	2016.04.05.04.29.21;	author guenther;	state Exp;
branches;
next	1.23;
commitid	INw7kjfUlnrMbBig;

1.23
date	2015.10.05.02.57.16;	author guenther;	state Exp;
branches;
next	1.22;
commitid	hN3BtB3F33HLhHuv;

1.22
date	2015.06.04.19.26.39;	author eric;	state Exp;
branches;
next	1.21;
commitid	SF2cZx8L0X6mQ3PV;

1.21
date	2014.07.20.04.22.34;	author guenther;	state Exp;
branches;
next	1.20;
commitid	x7aBoxPF8nZvW5Z0;

1.20
date	2013.11.12.07.00.24;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.17.03.07.40;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.26.17.29.04;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.13.00.28.35;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.12.06.57.12;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.12.03.00.38;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.10.07.21.01;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.27.10.14.02;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.04.21.45.31;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	99.08.26.13.38.10;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.20.30.08;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.04.30.05.57.03;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	97.04.25.07.43.05;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.04.23.22.37.50;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.04.19.10.07.01;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	97.04.19.09.53.25;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	97.04.13.21.30.47;	author provos;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Prefer _MUTEX_*LOCK over _THREAD_PRIVATE_MUTEX_*LOCK() when thread-specific
data isn't necessary.

ok mpi@@, ok&tweak natano@@
@
text
@/* $OpenBSD: res_random.c,v 1.23 2015/10/05 02:57:16 guenther Exp $ */

/*
 * Copyright 1997 Niels Provos <provos@@physnet.uni-hamburg.de>
 * Copyright 2008 Damien Miller <djm@@openbsd.org>
 * All rights reserved.
 *
 * Theo de Raadt <deraadt@@openbsd.org> came up with the idea of using
 * such a mathematical system to generate more random (yet non-repeating)
 * ids to solve the resolver/named problem.  But Niels designed the
 * actual system based on the constraints.
 *
 * Later modified by Damien Miller to wrap the LCG output in a 15-bit
 * permutation generator based on a Luby-Rackoff block cipher. This
 * ensures the output is non-repeating and preserves the MSB twiddle
 * trick, but makes it more resistant to LCG prediction.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* 
 * seed = random 15bit
 * n = prime, g0 = generator to n,
 * j = random so that gcd(j,n-1) == 1
 * g = g0^j mod n will be a generator again.
 *
 * X[0] = random seed.
 * X[n] = a*X[n-1]+b mod m is a Linear Congruential Generator
 * with a = 7^(even random) mod m, 
 *      b = random with gcd(b,m) == 1
 *      m = 31104 and a maximal period of m-1.
 *
 * The transaction id is determined by:
 * id[n] = seed xor (g^X[n] mod n)
 *
 * Effectivly the id is restricted to the lower 15 bits, thus
 * yielding two different cycles by toggling the msb on and off.
 * This avoids reuse issues caused by reseeding.
 *
 * The output of this generator is then randomly permuted though a
 * custom 15 bit Luby-Rackoff block cipher.
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <resolv.h>

#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include "thread_private.h"

#define RU_OUT  	180	/* Time after wich will be reseeded */
#define RU_MAX		30000	/* Uniq cycle, avoid blackjack prediction */
#define RU_GEN		2	/* Starting generator */
#define RU_N		32749	/* RU_N-1 = 2*2*3*2729 */
#define RU_AGEN		7	/* determine ru_a as RU_AGEN^(2*rand) */
#define RU_M		31104	/* RU_M = 2^7*3^5 - don't change */
#define RU_ROUNDS	11	/* Number of rounds for permute (odd) */

struct prf_ctx {
	/* PRF lookup table for odd rounds (7 bits input to 8 bits output) */
	u_char prf7[(RU_ROUNDS / 2) * (1 << 7)];

	/* PRF lookup table for even rounds (8 bits input to 7 bits output) */
	u_char prf8[((RU_ROUNDS + 1) / 2) * (1 << 8)];
};

#define PFAC_N 3
static const u_int16_t pfacts[PFAC_N] = {
	2, 
	3,
	2729
};

static u_int16_t ru_x;
static u_int16_t ru_seed, ru_seed2;
static u_int16_t ru_a, ru_b;
static u_int16_t ru_g;
static u_int16_t ru_counter = 0;
static u_int16_t ru_msb = 0;
static struct prf_ctx *ru_prf = NULL;
static time_t ru_reseed;
static pid_t ru_pid;

static u_int16_t pmod(u_int16_t, u_int16_t, u_int16_t);
static void res_initid(void);

/*
 * Do a fast modular exponation, returned value will be in the range
 * of 0 - (mod-1)
 */
static u_int16_t
pmod(u_int16_t gen, u_int16_t exp, u_int16_t mod)
{
	u_int16_t s, t, u;

	s = 1;
	t = gen;
	u = exp;

	while (u) {
		if (u & 1)
			s = (s * t) % mod;
		u >>= 1;
		t = (t * t) % mod;
	}
	return (s);
}

/*
 * 15-bit permutation based on Luby-Rackoff block cipher
 */
static u_int
permute15(u_int in)
{
	int i;
	u_int left, right, tmp;

	if (ru_prf == NULL)
		return in;

	left = (in >> 8) & 0x7f;
	right = in & 0xff;

	/*
	 * Each round swaps the width of left and right. Even rounds have
	 * a 7-bit left, odd rounds have an 8-bit left.	Since this uses an
	 * odd number of rounds, left is always 8 bits wide at the end.
	 */
	for (i = 0; i < RU_ROUNDS; i++) {
		if ((i & 1) == 0)
			tmp = ru_prf->prf8[(i << (8 - 1)) | right] & 0x7f;
		else
			tmp = ru_prf->prf7[((i - 1) << (7 - 1)) | right];
		tmp ^= left;
		left = right;
		right = tmp;
	}

	return (right << 8) | left;
}

/* 
 * Initializes the seed and chooses a suitable generator. Also toggles 
 * the msb flag. The msb flag is used to generate two distinct
 * cycles of random numbers and thus avoiding reuse of ids.
 *
 * This function is called from res_randomid() when needed, an 
 * application does not have to worry about it.
 */
static void 
res_initid(void)
{
	u_int16_t j, i;
	u_int32_t tmp;
	int noprime = 1;
	struct timespec ts;

	ru_x = arc4random_uniform(RU_M);

	/* 15 bits of random seed */
	tmp = arc4random();
	ru_seed = (tmp >> 16) & 0x7FFF;
	ru_seed2 = tmp & 0x7FFF;

	/* Determine the LCG we use */
	tmp = arc4random();
	ru_b = (tmp & 0xfffe) | 1;
	ru_a = pmod(RU_AGEN, (tmp >> 16) & 0xfffe, RU_M);
	while (ru_b % 3 == 0)
		ru_b += 2;
	
	j = arc4random_uniform(RU_N);

	/* 
	 * Do a fast gcd(j,RU_N-1), so we can find a j with
	 * gcd(j, RU_N-1) == 1, giving a new generator for
	 * RU_GEN^j mod RU_N
	 */

	while (noprime) {
		for (i = 0; i < PFAC_N; i++)
			if (j % pfacts[i] == 0)
				break;

		if (i >= PFAC_N)
			noprime = 0;
		else 
			j = (j + 1) % RU_N;
	}

	ru_g = pmod(RU_GEN, j, RU_N);
	ru_counter = 0;

	/* Initialise PRF for Luby-Rackoff permutation */
	if (ru_prf == NULL)
		ru_prf = malloc(sizeof(*ru_prf));
	if (ru_prf != NULL)
		arc4random_buf(ru_prf, sizeof(*ru_prf));

	clock_gettime(CLOCK_MONOTONIC, &ts);
	ru_reseed = ts.tv_sec + RU_OUT;
	ru_msb = ru_msb == 0x8000 ? 0 : 0x8000; 
}

u_int
__res_randomid(void)
{
	struct timespec ts;
	pid_t pid;
	u_int r;
	static void *randomid_mutex;

	clock_gettime(CLOCK_MONOTONIC, &ts);
	pid = getpid();

	_MUTEX_LOCK(&randomid_mutex);

	if (ru_counter >= RU_MAX || ts.tv_sec > ru_reseed || pid != ru_pid) {
		res_initid();
		ru_pid = pid;
	}

	/* Linear Congruential Generator */
	ru_x = (ru_a * ru_x + ru_b) % RU_M;
	ru_counter++;

	r = permute15(ru_seed ^ pmod(ru_g, ru_seed2 + ru_x, RU_N)) | ru_msb;

	_MUTEX_UNLOCK(&randomid_mutex);

	return (r);
}
DEF_STRONG(__res_randomid);

#if 0
int
main(int argc, char **argv)
{
	int i, n;
	u_int16_t wert;

	res_initid();

	printf("Generator: %u\n", ru_g);
	printf("Seed: %u\n", ru_seed);
	printf("Reseed at %ld\n", ru_reseed);
	printf("Ru_X: %u\n", ru_x);
	printf("Ru_A: %u\n", ru_a);
	printf("Ru_B: %u\n", ru_b);

	n = argc > 1 ? atoi(argv[1]) : 60001;
	for (i=0;i<n;i++) {
		wert = res_randomid();
		printf("%u\n", wert);
	}
	return 0;
}
#endif

@


1.23
log
@Wrap <resolv.h> so that internal calls go direct

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.22 2015/06/04 19:26:39 eric Exp $ */
d233 1
a233 1
	_THREAD_PRIVATE_MUTEX(random);
d238 1
a238 1
	_THREAD_PRIVATE_MUTEX_LOCK(random);
d251 1
a251 1
	_THREAD_PRIVATE_MUTEX_UNLOCK(random);
@


1.22
log
@force reseeding if pid has changed.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.21 2014/07/20 04:22:34 guenther Exp $ */
d228 1
a228 1
res_randomid(void)
d255 1
@


1.21
log
@From ISO/IEC 9899:1999 and 9899:201x,
6.11.5 - Storage-class specifiers:
    The placement of a storage-class specifier other than at the
    beginning of the declaration specifiers in a declaration is
    an obsolescent feature.

Diff from Jean-Philippe Ouellet (jean-philippe (at) ouellet.biz)
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.20 2013/11/12 07:00:24 deraadt Exp $ */
d104 1
d231 1
d236 1
d240 1
a240 1
	if (ru_counter >= RU_MAX || ts.tv_sec > ru_reseed)
d242 2
@


1.20
log
@permute15() should be static.  Not cranking libc now, because it is
not urgent.
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.19 2013/04/17 03:07:40 deraadt Exp $ */
d90 1
a90 1
const static u_int16_t pfacts[PFAC_N] = {
@


1.19
log
@use CLOCK_MONOTONIC, and repair future time_t overflow
ok millert guenther
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.18 2013/03/26 17:29:04 eric Exp $ */
d133 1
a133 1
u_int
@


1.18
log
@protect the PRG state with a mutex in res_randomid().

ok deraadt@@ guenther@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.17 2008/04/13 00:28:35 djm Exp $ */
d103 1
a103 1
static long ru_reseed;
d177 1
a177 1
	struct timeval tv;
d221 2
a222 2
	gettimeofday(&tv, NULL);
	ru_reseed = tv.tv_sec + RU_OUT;
d229 1
a229 1
	struct timeval tv;
d233 1
a233 1
	gettimeofday(&tv, NULL);
d237 1
a237 1
	if (ru_counter >= RU_MAX || tv.tv_sec > ru_reseed)
@


1.17
log
@Improve the libc DNS resolver ID generation algorithm to be more
resistant to prediction atacks by wrapping the existing LCG in a
random permutation generator based on a Luby-Rackoff block cipher.

lots of discussion and final ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.16 2005/03/25 13:24:12 otto Exp $ */
d71 2
d230 2
d234 3
d244 5
a248 1
	return permute15(ru_seed ^ pmod(ru_g, ru_seed2 + ru_x, RU_N)) | ru_msb;
@


1.16
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.15 2003/12/12 06:57:12 itojun Exp $ */
d5 1
d13 5
d58 2
a59 3
 * The 16 bit space is very small and brute force attempts are
 * entirly feasible, we skip a random number of transaction ids
 * so that an attacker will not get sequential ids.
d71 15
a85 6
#define RU_OUT  180             /* Time after wich will be reseeded */
#define RU_MAX	30000		/* Uniq cycle, avoid blackjack prediction */
#define RU_GEN	2		/* Starting generator */
#define RU_N	32749		/* RU_N-1 = 2*2*3*2729 */
#define RU_AGEN	7               /* determine ru_a as RU_AGEN^(2*rand) */
#define RU_M	31104           /* RU_M = 2^7*3^5 - don't change */
d100 1
a101 2
static u_int32_t tmp;                /* Storage for unused random */
static struct timeval tv;
a109 1

d128 33
d173 1
d175 1
d177 1
a177 2
	tmp = arc4random();
	ru_x = (tmp & 0xFFFF) % RU_M;
d180 1
a181 1
	tmp = arc4random();
d184 1
a185 2

	/* Determine the LCG we use */
d191 1
a191 3
	tmp = arc4random();
	j = tmp % RU_N;
	tmp = tmp >> 16;
d213 6
d227 1
a227 1
        int i, n;
d233 3
a235 17
#if 0
	if (!tmp)
	        tmp = arc4random();

	/* Skip a random number of ids */
	n = tmp & 0x7; tmp = tmp >> 3;
	if (ru_counter + n >= RU_MAX)
                res_initid();
#else
	n = 0;
#endif

	for (i = 0; i <= n; i++)
	        /* Linear Congruential Generator */
	        ru_x = (ru_a * ru_x + ru_b) % RU_M;

	ru_counter += i;
d237 1
a237 1
	return (ru_seed ^ pmod(ru_g, ru_seed2 + ru_x, RU_N)) | ru_msb;
d241 1
a241 1
void
d256 1
a256 1
	n = atoi(argv[1]);
d259 1
a259 1
		printf("%06d\n", wert);
d261 1
@


1.15
log
@niels kindly dropped clause 3/4 from the license.  tnx!
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.14 2003/12/12 03:00:38 itojun Exp $ */
d125 1
a125 1
res_initid()
d176 1
a176 1
res_randomid()
@


1.14
log
@we can skip arc4random() call here.  markus
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.13 2003/12/10 07:21:01 itojun Exp $ */
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@correct non-repetitive ID code, based on comments from niels provos.
- seed2 is necessary, but use it as "seed2 + x" not "seed2 ^ x".
- skipping number is not needed, so disable it for 16bit generator (makes
  the repetition period to 30000)
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.12 2002/06/27 10:14:02 itojun Exp $ */
d189 1
a192 1
#if 0
@


1.12
log
@%d -> %u.  mostly in #ifdef DEBUG.
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.11 2002/02/19 19:39:36 millert Exp $ */
d114 1
a114 1
			s = (s*t) % mod;
d116 1
a116 1
		t = (t*t) % mod;
d149 1
a149 1
	  ru_b += 2;
d162 2
a163 2
		for (i=0; i<PFAC_N; i++)
			if (j%pfacts[i] == 0)
d166 1
a166 1
		if (i>=PFAC_N)
d169 1
a169 1
			j = (j+1) % RU_N;
d172 1
a172 1
	ru_g = pmod(RU_GEN,j,RU_N);
d192 1
d197 3
d201 1
a201 1
	for (i=0; i<=n; i++)
d203 1
a203 1
	        ru_x = (ru_a*ru_x + ru_b) % RU_M;
d207 1
a207 1
	return (ru_seed ^ pmod(ru_g,ru_seed2 ^ ru_x,RU_N)) | ru_msb;
@


1.11
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.10 2002/02/16 21:27:23 millert Exp $ */
d215 2
a216 2
	printf("Generator: %d\n", ru_g);
	printf("Seed: %d\n", ru_seed);
d218 3
a220 3
	printf("Ru_X: %d\n", ru_x);
	printf("Ru_A: %d\n", ru_a);
	printf("Ru_B: %d\n", ru_b);
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.9 2001/01/04 21:45:31 todd Exp $ */
a102 1
#ifdef __STDC__
a104 5
#else
static u_int16_t
pmod(gen, exp, mod)
	u_int16_t gen, exp, mod;
#endif
@


1.9
log
@grammer/spelling
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.8 1999/08/26 13:38:10 provos Exp $ */
d95 2
a96 2
static u_int16_t pmod __P((u_int16_t, u_int16_t, u_int16_t));
static void res_initid __P((void));
@


1.8
log
@add an inner xor to make prediction attacks against the ids harder, due
to an attack pointed out by David Wagner.
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.7 1997/07/25 20:30:08 mickey Exp $ */
d128 1
a128 1
 * Initalizes the seed and chooses a suitable generator. Also toggles 
@


1.7
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.6 1997/04/30 05:57:03 tholo Exp $ */
d86 1
a86 1
static u_int16_t ru_seed;
d146 2
d209 1
a209 1
	return (ru_seed ^ pmod(ru_g,ru_x,RU_N)) | ru_msb;
@


1.6
log
@Be more careful about possible type promotion
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.5 1997/04/25 07:43:05 provos Exp $ */
d103 1
a103 1
#if __STDC__
@


1.5
log
@skipped too many ids
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.4 1997/04/23 22:37:50 provos Exp $ */
d103 4
d110 1
@


1.4
log
@pmod to u_int16_t, Angelos kindly reminded me
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.3 1997/04/19 10:07:01 provos Exp $ */
d192 1
a192 1
	n = tmp & 0x2f; tmp = tmp >> 6;
@


1.3
log
@change time() to gettimeofday()
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.2 1997/04/19 09:53:25 provos Exp $ */
d95 1
a95 1
static u_int32_t pmod __P((u_int32_t, u_int32_t, u_int32_t));
d103 1
a103 1
static u_int32_t
d105 1
a105 1
	u_int32_t gen, exp, mod;
d107 1
a107 1
	u_int32_t s, t, u;
@


1.2
log
@make things more complicated.
@
text
@d1 1
a1 1
/* $OpenBSD: res_random.c,v 1.1 1997/04/13 21:30:47 provos Exp $ */
a69 1
#include <time.h>
d91 1
a91 1
static time_t ru_reseed;
d93 1
d174 2
a175 1
	ru_reseed = time(NULL) + RU_OUT;
d184 2
a185 1
	if (ru_counter >= RU_MAX || time(NULL) > ru_reseed)
d216 1
@


1.1
log
@the before mentioned random number generator.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d46 3
a48 1
 * with a = 625, b = 6571, m = 31104 and a maximal period of m-1.
d56 4
d70 1
d72 2
a73 1
#define RU_MAX	20000		/* Uniq cycle, avoid blackjack prediction */
d76 2
a77 3
#define RU_A	625
#define RU_B	6571
#define RU_M	31104
d88 1
d92 2
d123 1
a123 1
 * Initalizes the seed and choosed a suitable generator. Also toggles 
a133 1
	u_int32_t tmp;
d142 11
a152 1
	j = arc4random() % RU_N;
d174 1
d181 3
a183 1
	if (ru_counter % RU_MAX == 0)
d186 11
a196 1
	ru_counter++;
d198 1
a198 2
	/* Linear Congruential Generator */
	ru_x = (RU_A*ru_x + RU_B) % RU_M;
d215 2
@
