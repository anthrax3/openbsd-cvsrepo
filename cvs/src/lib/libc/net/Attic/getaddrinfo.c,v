head	1.73;
access;
symbols
	OPENBSD_5_4:1.72.0.10
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.72.0.8
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.72.0.6
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.4
	OPENBSD_5_0:1.72.0.2
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.71.0.6
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.71.0.4
	OPENBSD_4_8_BASE:1.71
	OPENBSD_4_7:1.71.0.2
	OPENBSD_4_7_BASE:1.71
	OPENBSD_4_6:1.69.0.4
	OPENBSD_4_6_BASE:1.69
	OPENBSD_4_5:1.67.0.8
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.67.0.6
	OPENBSD_4_4_BASE:1.67
	OPENBSD_4_3:1.67.0.4
	OPENBSD_4_3_BASE:1.67
	OPENBSD_4_2:1.67.0.2
	OPENBSD_4_2_BASE:1.67
	OPENBSD_4_1:1.61.0.2
	OPENBSD_4_1_BASE:1.61
	OPENBSD_4_0:1.56.0.2
	OPENBSD_4_0_BASE:1.56
	OPENBSD_3_9:1.53.0.4
	OPENBSD_3_9_BASE:1.53
	OPENBSD_3_8:1.53.0.2
	OPENBSD_3_8_BASE:1.53
	OPENBSD_3_7:1.50.0.4
	OPENBSD_3_7_BASE:1.50
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	OPENBSD_3_5:1.48.0.4
	OPENBSD_3_5_BASE:1.48
	OPENBSD_3_4:1.48.0.2
	OPENBSD_3_4_BASE:1.48
	OPENBSD_3_3:1.46.0.2
	OPENBSD_3_3_BASE:1.46
	OPENBSD_3_2:1.43.0.2
	OPENBSD_3_2_BASE:1.43
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9:1.27.0.4
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.22.0.2
	OPENBSD_2_7_BASE:1.22
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.73
date	2013.11.12.20.37.15;	author eric;	state dead;
branches;
next	1.72;

1.72
date	2011.04.05.00.46.06;	author matthew;	state Exp;
branches;
next	1.71;

1.71
date	2009.11.18.07.43.22;	author guenther;	state Exp;
branches;
next	1.70;

1.70
date	2009.09.02.19.07.12;	author fgsch;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.04.21.38.29;	author pyr;	state Exp;
branches;
next	1.68;

1.68
date	2009.06.04.18.06.35;	author pyr;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.20.03.54.52;	author ray;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.18.01.10.59;	author ray;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.17.03.55.08;	author ray;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.12.21.38.14;	author ray;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.12.16.18.06;	author ray;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.10.02.14.35;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2007.02.18.19.03.11;	author ray;	state Exp;
branches;
next	1.60;

1.60
date	2007.02.17.20.56.38;	author ray;	state Exp;
branches;
next	1.59;

1.59
date	2007.02.15.04.25.35;	author ray;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.14.05.48.46;	author ray;	state Exp;
branches;
next	1.57;

1.57
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	2006.04.18.02.57.10;	author ray;	state Exp;
branches;
next	1.55;

1.55
date	2006.04.14.03.16.02;	author ray;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.22.13.29.26;	author ray;	state Exp;
branches;
next	1.53;

1.53
date	2005.07.18.14.38.39;	author jmc;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.30.02.58.28;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.07.21.11.23;	author marc;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.14.07.06.15;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2003.07.21.23.17.53;	author marc;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.14.05.38.34;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.17.23.16.36;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.04.00.29.17;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2003.01.28.04.58.00;	author marc;	state Exp;
branches;
next	1.43;

1.43
date	2002.08.27.08.53.13;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.08.22.16.35.37;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.25.21.13.45;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.24.01.38.34;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.01.21.57.35;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.01.21.08.13;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.01.07.43.48;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.29.12.25.42;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.27.09.55.49;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.26.06.01.16;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.17.19.42.23;	author millert;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.02.23.00.10;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.20.02.23.05;	author itojun;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.06.27.00.58.54;	author lebel;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.11.10.05.58;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.31.17.41.51;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.22.19.04.42;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.09.04.48.35;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.05.03.00.55;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.15.10.49.55;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.27.05.30.23;	author itojun;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2000.04.26.16.05.20;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.26.14.41.14;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.26.12.31.44;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.25.13.39.02;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.16.14.08.55;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.13.12.26.56;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.25.04.41.41;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.21.04.14.09;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.17.17.09.40;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.16.12.53.35;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.15.18.53.08;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.09.12.22.09;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.26.06.51.26;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.18.10.20.00;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.17.15.58.11;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.17.08.15.26;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	99.12.30.08.54.20;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.12.07.07.49.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.07.03.21.45.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.06.23.22.38.52;	author cmetz;	state Exp;
branches;
next	1.1;

1.1
date	99.06.23.21.55.29;	author cmetz;	state Exp;
branches;
next	;

1.22.2.1
date	2000.06.15.03.34.31;	author jason;	state Exp;
branches;
next	;

1.30.2.1
date	2002.09.09.18.25.08;	author miod;	state Exp;
branches;
next	;

1.33.2.1
date	2002.09.06.05.46.51;	author jason;	state Exp;
branches;
next	;


desc
@@


1.73
log
@remove dead files

ok deraadt@@
@
text
@/*	$OpenBSD: getaddrinfo.c,v 1.72 2011/04/05 00:46:06 matthew Exp $	*/
/*	$KAME: getaddrinfo.c,v 1.31 2000/08/31 17:36:43 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Issues to be discussed:
 * - Thread safe-ness must be checked.
 * - Return values.  There are nonstandard return values defined and used
 *   in the source code.  This is because RFC2553 is silent about which error
 *   code must be returned for which situation.
 * - IPv4 classful (shortened) form.  RFC2553 is silent about it.  XNET 5.2
 *   says to use inet_aton() to convert IPv4 numeric to binary (allows
 *   classful form as a result).
 *   current code - disallow classful form for IPv4 (due to use of inet_pton).
 * - freeaddrinfo(NULL).  RFC2553 is silent about it.  XNET 5.2 says it is
 *   invalid.
 *   current code - SEGV on freeaddrinfo(NULL)
 * Note:
 * - We use getipnodebyname() just for thread-safeness.  There's no intent
 *   to let it do PF_UNSPEC (actually we never pass PF_UNSPEC to
 *   getipnodebyname().
 * - The code filters out AFs that are not supported by the kernel,
 *   when globbing NULL hostname (to loopback, or wildcard).  Is it the right
 *   thing to do?  What is the relationship with post-RFC2553 AI_ADDRCONFIG
 *   in ai_flags?
 * - (post-2553) semantics of AI_ADDRCONFIG itself is too vague.
 *   (1) what should we do against numeric hostname (2) what should we do
 *   against NULL hostname (3) what is AI_ADDRCONFIG itself.  AF not ready?
 *   non-loopback address configured?  global address configured?
 * - To avoid search order issue, we have a big amount of code duplicate
 *   from gethnamaddr.c and some other places.  The issues that there's no
 *   lower layer function to lookup "IPv4 or IPv6" record.  Calling
 *   gethostbyname2 from getaddrinfo will end up in wrong search order, as
 *   follows:
 *	- The code makes use of following calls when asked to resolver with
 *	  ai_family  = PF_UNSPEC:
 *		getipnodebyname(host, AF_INET6);
 *		getipnodebyname(host, AF_INET);
 *	  This will result in the following queries if the node is configure to
 *	  prefer /etc/hosts than DNS:
 *		lookup /etc/hosts for IPv6 address
 *		lookup DNS for IPv6 address
 *		lookup /etc/hosts for IPv4 address
 *		lookup DNS for IPv4 address
 *	  which may not meet people's requirement.
 *	  The right thing to happen is to have underlying layer which does
 *	  PF_UNSPEC lookup (lookup both) and return chain of addrinfos.
 *	  This would result in a bit of code duplicate with _dns_ghbyname() and
 *	  friends.
 */

#ifndef INET6
#define INET6
#endif

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>
#include <resolv.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>
#include <ctype.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>

#include <syslog.h>
#include <stdarg.h>

#ifdef YP
#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include "ypinternal.h"
#endif

#include "thread_private.h"

#define SUCCESS 0
#define ANY 0
#define YES 1
#define NO  0

static const char in_addrany[] = { 0, 0, 0, 0 };
static const char in6_addrany[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
static const char in_loopback[] = { 127, 0, 0, 1 };
static const char in6_loopback[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
};

static const struct afd {
	int a_af;
	int a_addrlen;
	int a_socklen;
	int a_off;
	const char *a_addrany;
	const char *a_loopback;	
	int a_scoped;
} afdl [] = {
#ifdef INET6
	{PF_INET6, sizeof(struct in6_addr),
	 sizeof(struct sockaddr_in6),
	 offsetof(struct sockaddr_in6, sin6_addr),
	 in6_addrany, in6_loopback, 1},
#endif
	{PF_INET, sizeof(struct in_addr),
	 sizeof(struct sockaddr_in),
	 offsetof(struct sockaddr_in, sin_addr),
	 in_addrany, in_loopback, 0},
	{0, 0, 0, 0, NULL, NULL, 0},
};

struct explore {
	int e_af;
	int e_socktype;
	int e_protocol;
	const char *e_protostr;
	int e_wild;
#define WILD_AF(ex)		((ex)->e_wild & 0x01)
#define WILD_SOCKTYPE(ex)	((ex)->e_wild & 0x02)
#define WILD_PROTOCOL(ex)	((ex)->e_wild & 0x04)
};

static const struct explore explore[] = {
#if 0
	{ PF_LOCAL, 0, ANY, ANY, NULL, 0x01 },
#endif
#ifdef INET6
	{ PF_INET6, SOCK_DGRAM, IPPROTO_UDP, "udp", 0x07 },
	{ PF_INET6, SOCK_STREAM, IPPROTO_TCP, "tcp", 0x07 },
	{ PF_INET6, SOCK_RAW, ANY, NULL, 0x05 },
#endif
	{ PF_INET, SOCK_DGRAM, IPPROTO_UDP, "udp", 0x07 },
	{ PF_INET, SOCK_STREAM, IPPROTO_TCP, "tcp", 0x07 },
	{ PF_INET, SOCK_RAW, ANY, NULL, 0x05 },
	{ PF_UNSPEC, SOCK_DGRAM, IPPROTO_UDP, "udp", 0x07 },
	{ PF_UNSPEC, SOCK_STREAM, IPPROTO_TCP, "tcp", 0x07 },
	{ PF_UNSPEC, SOCK_RAW, ANY, NULL, 0x05 },
	{ -1, 0, 0, NULL, 0 },
};

#ifdef INET6
#define PTON_MAX	16
#else
#define PTON_MAX	4
#endif

#define MAXPACKET	(64*1024)

typedef union {
	HEADER hdr;
	u_char buf[MAXPACKET];
} querybuf;

struct res_target {
	struct res_target *next;
	const char *name;	/* domain name */
	int qclass, qtype;	/* class and type of query */
	u_char *answer;		/* buffer to put answer */
	int anslen;		/* size of answer buffer */
	int n;			/* result length */
};

static int explore_fqdn(const struct addrinfo *, const char *,
	const char *, struct addrinfo **);
static int explore_null(const struct addrinfo *,
	const char *, struct addrinfo **);
static int explore_numeric(const struct addrinfo *, const char *,
	const char *, struct addrinfo **, const char *);
static int explore_numeric_scope(const struct addrinfo *, const char *,
	const char *, struct addrinfo **);
static int get_canonname(const struct addrinfo *,
	struct addrinfo *, const char *);
static struct addrinfo *get_ai(const struct addrinfo *,
	const struct afd *, const char *);
static int get_portmatch(const struct addrinfo *, const char *);
static int get_port(struct addrinfo *, const char *, int);
static const struct afd *find_afd(int);
#ifdef INET6
static int ip6_str2scopeid(char *, struct sockaddr_in6 *, u_int32_t *);
#endif

static struct addrinfo * _gethtent(const char *, const struct addrinfo *,
	FILE *);
static struct addrinfo *_files_getaddrinfo(const char *,
	const struct addrinfo *);

#ifdef YP
static struct addrinfo *_yphostent(char *, const struct addrinfo *);
static struct addrinfo *_yp_getaddrinfo(const char *,
	const struct addrinfo *);
#endif

static struct addrinfo *getanswer(const querybuf *, int, const char *, int,
	const struct addrinfo *);
static int res_queryN(const char *, struct res_target *);
static int res_searchN(const char *, struct res_target *);
static int res_querydomainN(const char *, const char *, struct res_target *);
static struct addrinfo *_dns_getaddrinfo(const char *, const struct addrinfo *,
	const struct __res_state *);


/* XXX macros that make external reference is BAD. */

#define GET_AI(ai, afd, addr)						\
do {									\
	/* external reference: pai, error, and label free */		\
	(ai) = get_ai(pai, (afd), (addr));				\
	if ((ai) == NULL) {						\
		error = EAI_MEMORY;					\
		goto free;						\
	}								\
} while (/*CONSTCOND*/0)

#define GET_PORT(ai, serv)						\
do {									\
	/* external reference: error and label free */			\
	error = get_port((ai), (serv), 0);				\
	if (error != 0)							\
		goto free;						\
} while (/*CONSTCOND*/0)

#define GET_CANONNAME(ai, str)						\
do {									\
	/* external reference: pai, error and label free */		\
	error = get_canonname(pai, (ai), (str));			\
	if (error != 0)							\
		goto free;						\
} while (/*CONSTCOND*/0)

#define ERR(err)							\
do {									\
	/* external reference: error, and label bad */			\
	error = (err);							\
	goto bad;							\
	/*NOTREACHED*/							\
} while (/*CONSTCOND*/0)

#define MATCH_FAMILY(x, y, w) \
	((x) == (y) || (/*CONSTCOND*/(w) && ((x) == PF_UNSPEC || (y) == PF_UNSPEC)))
#define MATCH(x, y, w) \
	((x) == (y) || (/*CONSTCOND*/(w) && ((x) == ANY || (y) == ANY)))

int
getaddrinfo(const char *hostname, const char *servname,
    const struct addrinfo *hints, struct addrinfo **res)
{
	struct addrinfo sentinel;
	struct addrinfo *cur;
	int error = 0;
	struct addrinfo ai;
	struct addrinfo ai0;
	struct addrinfo *pai;
	const struct explore *ex;

	memset(&sentinel, 0, sizeof(sentinel));
	cur = &sentinel;
	pai = &ai;
	pai->ai_flags = 0;
	pai->ai_family = PF_UNSPEC;
	pai->ai_socktype = ANY;
	pai->ai_protocol = ANY;
	pai->ai_addrlen = 0;
	pai->ai_canonname = NULL;
	pai->ai_addr = NULL;
	pai->ai_next = NULL;
	
	if (hostname == NULL && servname == NULL)
		return EAI_NONAME;
	if (hints) {
		/* error check for hints */
		if (hints->ai_addrlen || hints->ai_canonname ||
		    hints->ai_addr || hints->ai_next)
			ERR(EAI_BADHINTS); /* xxx */
		if ((hints->ai_flags & ~AI_MASK) != 0 ||
		    (hints->ai_flags & (AI_CANONNAME | AI_FQDN)) ==
		    (AI_CANONNAME | AI_FQDN))
			ERR(EAI_BADFLAGS);
		switch (hints->ai_family) {
		case PF_UNSPEC:
		case PF_INET:
#ifdef INET6
		case PF_INET6:
#endif
			break;
		default:
			ERR(EAI_FAMILY);
		}
		memcpy(pai, hints, sizeof(*pai));

		/*
		 * if both socktype/protocol are specified, check if they
		 * are meaningful combination.
		 */
		if (pai->ai_socktype != ANY && pai->ai_protocol != ANY) {
			for (ex = explore; ex->e_af >= 0; ex++) {
				if (pai->ai_family != ex->e_af)
					continue;
				if (ex->e_socktype == ANY)
					continue;
				if (ex->e_protocol == ANY)
					continue;
				if (pai->ai_socktype == ex->e_socktype
				 && pai->ai_protocol != ex->e_protocol) {
					ERR(EAI_BADHINTS);
				}
			}
		}
	}

	/*
	 * check for special cases.  (1) numeric servname is disallowed if
	 * socktype/protocol are left unspecified. (2) servname is disallowed
	 * for raw and other inet{,6} sockets.
	 */
	if (MATCH_FAMILY(pai->ai_family, PF_INET, 1)
#ifdef PF_INET6
	 || MATCH_FAMILY(pai->ai_family, PF_INET6, 1)
#endif
	    ) {
		ai0 = *pai;	/* backup *pai */

		if (pai->ai_family == PF_UNSPEC) {
#ifdef PF_INET6
			pai->ai_family = PF_INET6;
#else
			pai->ai_family = PF_INET;
#endif
		}
		error = get_portmatch(pai, servname);
		if (error)
			ERR(error);

		*pai = ai0;
	}

	ai0 = *pai;

	/* NULL hostname, or numeric hostname */
	for (ex = explore; ex->e_af >= 0; ex++) {
		*pai = ai0;

		/* PF_UNSPEC entries are prepared for DNS queries only */
		if (ex->e_af == PF_UNSPEC)
			continue;

		if (!MATCH_FAMILY(pai->ai_family, ex->e_af, WILD_AF(ex)))
			continue;
		if (!MATCH(pai->ai_socktype, ex->e_socktype, WILD_SOCKTYPE(ex)))
			continue;
		if (!MATCH(pai->ai_protocol, ex->e_protocol, WILD_PROTOCOL(ex)))
			continue;

		if (pai->ai_family == PF_UNSPEC)
			pai->ai_family = ex->e_af;
		if (pai->ai_socktype == ANY && ex->e_socktype != ANY)
			pai->ai_socktype = ex->e_socktype;
		if (pai->ai_protocol == ANY && ex->e_protocol != ANY)
			pai->ai_protocol = ex->e_protocol;

		if (hostname == NULL)
			error = explore_null(pai, servname, &cur->ai_next);
		else
			error = explore_numeric_scope(pai, hostname, servname,
			    &cur->ai_next);

		if (error)
			goto free;

		while (cur && cur->ai_next)
			cur = cur->ai_next;
	}

	/*
	 * XXX
	 * If numeric representation of AF1 can be interpreted as FQDN
	 * representation of AF2, we need to think again about the code below.
	 */
	if (sentinel.ai_next)
		goto good;

	if (hostname == NULL)
		ERR(EAI_NODATA);
	if (pai->ai_flags & AI_NUMERICHOST)
		ERR(EAI_NONAME);

	/*
	 * hostname as alphabetical name.
	 * we would like to prefer AF_INET6 than AF_INET, so we'll make an
	 * outer loop by AFs.
	 */
	for (ex = explore; ex->e_af >= 0; ex++) {
		*pai = ai0;

		/* require exact match for family field */
		if (pai->ai_family != ex->e_af)
			continue;

		if (!MATCH(pai->ai_socktype, ex->e_socktype,
				WILD_SOCKTYPE(ex))) {
			continue;
		}
		if (!MATCH(pai->ai_protocol, ex->e_protocol,
				WILD_PROTOCOL(ex))) {
			continue;
		}

		if (pai->ai_socktype == ANY && ex->e_socktype != ANY)
			pai->ai_socktype = ex->e_socktype;
		if (pai->ai_protocol == ANY && ex->e_protocol != ANY)
			pai->ai_protocol = ex->e_protocol;

		error = explore_fqdn(pai, hostname, servname,
			&cur->ai_next);

		while (cur && cur->ai_next)
			cur = cur->ai_next;
	}

	/* XXX */
	if (sentinel.ai_next)
		error = 0;

	if (error == 0) {
		if (sentinel.ai_next) {
 good:
			*res = sentinel.ai_next;
			return SUCCESS;
		} else
			error = EAI_FAIL;
	}
 free:
 bad:
	if (sentinel.ai_next)
		freeaddrinfo(sentinel.ai_next);
	*res = NULL;
	return error;
}

/*
 * FQDN hostname, DNS lookup
 */

static int
explore_fqdn(const struct addrinfo *pai, const char *hostname,
    const char *servname, struct addrinfo **res)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	struct addrinfo *result;
	struct addrinfo *cur;
	int error = 0;
	char lookups[MAXDNSLUS];
	int i;
	_THREAD_PRIVATE_MUTEX(_explore_mutex);

	result = NULL;

	/*
	 * if the servname does not match socktype/protocol, ignore it.
	 */
	if (get_portmatch(pai, servname) != 0) {
		return 0;
	}

	if (_res_init(0) == -1)
		strlcpy(lookups, "f", sizeof lookups);
	else {
		bcopy(_resp->lookups, lookups, sizeof lookups);
		if (lookups[0] == '\0')
			strlcpy(lookups, "bf", sizeof lookups);
	}

	/*
	 * The yp/dns/files getaddrinfo functions are not thread safe.
	 * Protect them with a mutex.
	 */
	_THREAD_PRIVATE_MUTEX_LOCK(_explore_mutex);
	for (i = 0; i < MAXDNSLUS && result == NULL && lookups[i]; i++) {
		switch (lookups[i]) {
#ifdef YP
		case 'y':
			result = _yp_getaddrinfo(hostname, pai);
			break;
#endif
		case 'b':
			result = _dns_getaddrinfo(hostname, pai, _resp);
			break;
		case 'f':
			result = _files_getaddrinfo(hostname, pai);
			break;
		}
	}
	_THREAD_PRIVATE_MUTEX_UNLOCK(_explore_mutex);
	if (result) {
		for (cur = result; cur; cur = cur->ai_next) {
			GET_PORT(cur, servname);
			/* canonname should be filled already */
		}
		*res = result;
		return 0;
	} else {
		/* translate error code */
		switch (h_errno) {
		case NETDB_SUCCESS:
			error = EAI_FAIL;	/*XXX strange */
			break;
		case HOST_NOT_FOUND:
			error = EAI_NODATA;
			break;
		case TRY_AGAIN:
			error = EAI_AGAIN;
			break;
		case NO_RECOVERY:
			error = EAI_FAIL;
			break;
		case NO_DATA:
#if NO_ADDRESS != NO_DATA
		case NO_ADDRESS:
#endif
			error = EAI_NODATA;
			break;
		default:			/* unknown ones */
			error = EAI_FAIL;
			break;
		}
	}

free:
	if (result)
		freeaddrinfo(result);
	return error;
}

/*
 * hostname == NULL.
 * passive socket -> anyaddr (0.0.0.0 or ::)
 * non-passive socket -> localhost (127.0.0.1 or ::1)
 */
static int
explore_null(const struct addrinfo *pai, const char *servname,
    struct addrinfo **res)
{
	int s;
	const struct afd *afd;
	struct addrinfo *cur;
	struct addrinfo sentinel;
	int error;

	*res = NULL;
	sentinel.ai_next = NULL;
	cur = &sentinel;

	/*
	 * filter out AFs that are not supported by the kernel
	 * XXX errno?
	 */
	s = socket(pai->ai_family, SOCK_DGRAM, 0);
	if (s < 0) {
		if (errno != EMFILE)
			return 0;
	} else
		close(s);

	/*
	 * if the servname does not match socktype/protocol, ignore it.
	 */
	if (get_portmatch(pai, servname) != 0)
		return 0;

	afd = find_afd(pai->ai_family);
	if (afd == NULL)
		return 0;

	if (pai->ai_flags & AI_PASSIVE) {
		GET_AI(cur->ai_next, afd, afd->a_addrany);
		/* xxx meaningless?
		 * GET_CANONNAME(cur->ai_next, "anyaddr");
		 */
	} else {
		GET_AI(cur->ai_next, afd, afd->a_loopback);
		/* xxx meaningless?
		 * GET_CANONNAME(cur->ai_next, "localhost");
		 */
	}
	GET_PORT(cur->ai_next, servname);
	cur = cur->ai_next;

	*res = sentinel.ai_next;
	return 0;

free:
	if (sentinel.ai_next)
		freeaddrinfo(sentinel.ai_next);
	return error;
}

/*
 * numeric hostname
 */
static int
explore_numeric(const struct addrinfo *pai, const char *hostname,
    const char *servname, struct addrinfo **res, const char *canonname)
{
	const struct afd *afd;
	struct addrinfo *cur;
	struct addrinfo sentinel;
	int error;
	char pton[PTON_MAX];

	*res = NULL;
	sentinel.ai_next = NULL;
	cur = &sentinel;

	/*
	 * if the servname does not match socktype/protocol, ignore it.
	 */
	if (get_portmatch(pai, servname) != 0)
		return 0;

	afd = find_afd(pai->ai_family);
	if (afd == NULL)
		return 0;

	switch (afd->a_af) {
#if 0 /*X/Open spec*/
	case AF_INET:
		error = inet_aton(hostname, (struct in_addr *)pton);
		break;
#endif
	default:
		error = inet_pton(afd->a_af, hostname, pton);
		break;
	}
	if (error == 1) {
		if (pai->ai_family == afd->a_af ||
		    pai->ai_family == PF_UNSPEC /*?*/) {
			GET_AI(cur->ai_next, afd, pton);
			GET_PORT(cur->ai_next, servname);
			/*
			 * Set the numeric address itself as
			 * the canonical name, based on a
			 * clarification in rfc2553bis-03.
			 */
			GET_CANONNAME(cur->ai_next, canonname);

			while (cur && cur->ai_next)
				cur = cur->ai_next;
		} else
			ERR(EAI_FAMILY);	/*xxx*/
	}

	*res = sentinel.ai_next;
	return 0;

free:
bad:
	if (sentinel.ai_next)
		freeaddrinfo(sentinel.ai_next);
	return error;
}

/*
 * numeric hostname with scope
 */
static int
explore_numeric_scope(const struct addrinfo *pai, const char *hostname,
    const char *servname, struct addrinfo **res)
{
#if !defined(SCOPE_DELIMITER) || !defined(INET6)
	return explore_numeric(pai, hostname, servname, res, hostname);
#else
	const struct afd *afd;
	struct addrinfo *cur;
	int error;
	char *cp, *hostname2 = NULL, *scope, *addr;
	struct sockaddr_in6 *sin6;

	/*
	 * if the servname does not match socktype/protocol, ignore it.
	 */
	if (get_portmatch(pai, servname) != 0)
		return 0;

	afd = find_afd(pai->ai_family);
	if (afd == NULL)
		return 0;

	if (!afd->a_scoped)
		return explore_numeric(pai, hostname, servname, res, hostname);

	cp = strchr(hostname, SCOPE_DELIMITER);
	if (cp == NULL)
		return explore_numeric(pai, hostname, servname, res, hostname);

	/*
	 * Handle special case of <scoped_address><delimiter><scope id>
	 */
	hostname2 = strdup(hostname);
	if (hostname2 == NULL)
		return EAI_MEMORY;
	/* terminate at the delimiter */
	hostname2[cp - hostname] = '\0';
	addr = hostname2;
	scope = cp + 1;

	error = explore_numeric(pai, addr, servname, res, hostname);
	if (error == 0) {
		u_int32_t scopeid;

		for (cur = *res; cur; cur = cur->ai_next) {
			if (cur->ai_family != AF_INET6)
				continue;
			sin6 = (struct sockaddr_in6 *)(void *)cur->ai_addr;
			if (ip6_str2scopeid(scope, sin6, &scopeid) == -1) {
				free(hostname2);
				return(EAI_NODATA); /* XXX: is return OK? */
			}
			sin6->sin6_scope_id = scopeid;
		}
	}

	free(hostname2);

	return error;
#endif
}

static int
get_canonname(const struct addrinfo *pai, struct addrinfo *ai, const char *str)
{
	if ((pai->ai_flags & (AI_CANONNAME | AI_FQDN)) != 0) {
		ai->ai_canonname = strdup(str);
		if (ai->ai_canonname == NULL)
			return EAI_MEMORY;
	}
	return 0;
}

static struct addrinfo *
get_ai(const struct addrinfo *pai, const struct afd *afd, const char *addr)
{
	char *p;
	struct addrinfo *ai;

	ai = (struct addrinfo *)malloc(sizeof(struct addrinfo)
		+ (afd->a_socklen));
	if (ai == NULL)
		return NULL;

	memcpy(ai, pai, sizeof(struct addrinfo));
	ai->ai_addr = (struct sockaddr *)(void *)(ai + 1);
	memset(ai->ai_addr, 0, (size_t)afd->a_socklen);
	ai->ai_addr->sa_len = afd->a_socklen;
	ai->ai_addrlen = afd->a_socklen;
	ai->ai_addr->sa_family = ai->ai_family = afd->a_af;
	p = (char *)(void *)(ai->ai_addr);
	memcpy(p + afd->a_off, addr, (size_t)afd->a_addrlen);
	return ai;
}

static int
get_portmatch(const struct addrinfo *ai, const char *servname)
{

	/* get_port does not touch first argument. when matchonly == 1. */
	/* LINTED const cast */
	return get_port((struct addrinfo *)ai, servname, 1);
}

static int
get_port(struct addrinfo *ai, const char *servname, int matchonly)
{
	const char *errstr, *proto;
	int port;
	int allownumeric;

	if (servname == NULL)
		return 0;
	switch (ai->ai_family) {
	case AF_INET:
#ifdef AF_INET6
	case AF_INET6:
#endif
		break;
	default:
		return 0;
	}

	switch (ai->ai_socktype) {
	case SOCK_RAW:
		return EAI_SERVICE;
	case SOCK_DGRAM:
	case SOCK_STREAM:
	case ANY:
		allownumeric = 1;
		break;
	default:
		return EAI_SOCKTYPE;
	}

	port = (int)strtonum(servname, 0, USHRT_MAX, &errstr);
	if (!errstr) {
		if (!allownumeric)
			return EAI_SERVICE;
		port = htons(port);
	} else {
		struct servent sp;
		struct servent_data sd;

		if (errno == ERANGE)
			return EAI_SERVICE;
		if (ai->ai_flags & AI_NUMERICSERV)
			return EAI_NONAME;

		switch (ai->ai_socktype) {
		case SOCK_DGRAM:
			proto = "udp";
			break;
		case SOCK_STREAM:
			proto = "tcp";
			break;
		default:
			proto = NULL;
			break;
		}

		(void)memset(&sd, 0, sizeof(sd));
		if (getservbyname_r(servname, proto, &sp, &sd) == -1)
			return EAI_SERVICE;
		port = sp.s_port;
		endservent_r(&sd);
	}

	if (!matchonly) {
		switch (ai->ai_family) {
		case AF_INET:
			((struct sockaddr_in *)(void *)
			    ai->ai_addr)->sin_port = port;
			break;
#ifdef INET6
		case AF_INET6:
			((struct sockaddr_in6 *)(void *)
			    ai->ai_addr)->sin6_port = port;
			break;
#endif
		}
	}

	return 0;
}

static const struct afd *
find_afd(int af)
{
	const struct afd *afd;

	if (af == PF_UNSPEC)
		return NULL;
	for (afd = afdl; afd->a_af; afd++) {
		if (afd->a_af == af)
			return afd;
	}
	return NULL;
}

#ifdef INET6
/* convert a string to a scope identifier. XXX: IPv6 specific */
static int
ip6_str2scopeid(char *scope, struct sockaddr_in6 *sin6, u_int32_t *scopeid)
{
	struct in6_addr *a6 = &sin6->sin6_addr;
	const char *errstr;

	/* empty scopeid portion is invalid */
	if (*scope == '\0')
		return -1;

	if (IN6_IS_ADDR_LINKLOCAL(a6) || IN6_IS_ADDR_MC_LINKLOCAL(a6) ||
	    IN6_IS_ADDR_MC_INTFACELOCAL(a6)) {
		/*
		 * We currently assume a one-to-one mapping between links
		 * and interfaces, so we simply use interface indices for
		 * like-local scopes.
		 */
		*scopeid = if_nametoindex(scope);
		if (*scopeid == 0)
			goto trynumeric;
		return 0;
	}

	/* still unclear about literal, allow numeric only - placeholder */
	if (IN6_IS_ADDR_SITELOCAL(a6) || IN6_IS_ADDR_MC_SITELOCAL(a6))
		goto trynumeric;
	if (IN6_IS_ADDR_MC_ORGLOCAL(a6))
		goto trynumeric;
	else
		goto trynumeric;	/* global */

	/* try to convert to a numeric id as a last resort */
  trynumeric:
	*scopeid = (u_int32_t)strtonum(scope, 0, UINT32_MAX, &errstr);
	if (errstr)
		return (-1);
	return (0);
}
#endif

/* code duplicate with gethnamaddr.c */

static const char AskedForGot[] =
	"gethostby*.getanswer: asked for \"%s\", got \"%s\"";

static struct addrinfo *
getanswer(const querybuf *answer, int anslen, const char *qname, int qtype,
    const struct addrinfo *pai)
{
	struct addrinfo sentinel, *cur;
	struct addrinfo ai;
	const struct afd *afd;
	char *canonname;
	const HEADER *hp;
	const u_char *cp;
	int n;
	const u_char *eom;
	char *bp, *ep;
	int type, class, ancount, qdcount;
	int haveanswer, had_error;
	char tbuf[MAXDNAME];
	int (*name_ok)(const char *);
	char hostbuf[8*1024];

	memset(&sentinel, 0, sizeof(sentinel));
	cur = &sentinel;

	canonname = NULL;
	eom = answer->buf + anslen;
	switch (qtype) {
	case T_A:
	case T_AAAA:
	case T_ANY:	/*use T_ANY only for T_A/T_AAAA lookup*/
		name_ok = res_hnok;
		break;
	default:
		return (NULL);	/* XXX should be abort() -- but that is illegal */
	}
	/*
	 * find first satisfactory answer
	 */
	hp = &answer->hdr;
	ancount = ntohs(hp->ancount);
	qdcount = ntohs(hp->qdcount);
	bp = hostbuf;
	ep = hostbuf + sizeof hostbuf;
	cp = answer->buf + HFIXEDSZ;
	if (qdcount != 1) {
		h_errno = NO_RECOVERY;
		return (NULL);
	}
	n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
	if ((n < 0) || !(*name_ok)(bp)) {
		h_errno = NO_RECOVERY;
		return (NULL);
	}
	cp += n + QFIXEDSZ;
	if (qtype == T_A || qtype == T_AAAA || qtype == T_ANY) {
		size_t len;

		/* res_send() has already verified that the query name is the
		 * same as the one we sent; this just gets the expanded name
		 * (i.e., with the succeeding search-domain tacked on).
		 */
		len = strlen(bp) + 1;		/* for the \0 */
		if (len >= MAXHOSTNAMELEN) {
			h_errno = NO_RECOVERY;
			return (NULL);
		}
		canonname = bp;
		bp += len;
		/* The qname can be abbreviated, but h_name is now absolute. */
		qname = canonname;
	}
	haveanswer = 0;
	had_error = 0;
	while (ancount-- > 0 && cp < eom && !had_error) {
		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
		if ((n < 0) || !(*name_ok)(bp)) {
			had_error++;
			continue;
		}
		cp += n;			/* name */
		type = _getshort(cp);
 		cp += INT16SZ;			/* type */
		class = _getshort(cp);
 		cp += INT16SZ + INT32SZ;	/* class, TTL */
		n = _getshort(cp);
		cp += INT16SZ;			/* len */
		if (class != C_IN) {
			/* XXX - debug? syslog? */
			cp += n;
			continue;		/* XXX - had_error++ ? */
		}
		if ((qtype == T_A || qtype == T_AAAA || qtype == T_ANY) &&
		    type == T_CNAME) {
			size_t len;

			n = dn_expand(answer->buf, eom, cp, tbuf, sizeof tbuf);
			if ((n < 0) || !(*name_ok)(tbuf)) {
				had_error++;
				continue;
			}
			cp += n;
			/* Get canonical name. */
			len = strlen(tbuf) + 1;	/* for the \0 */
			if (len > ep - bp || len >= MAXHOSTNAMELEN) {
				had_error++;
				continue;
			}
			strlcpy(bp, tbuf, ep - bp);
			canonname = bp;
			bp += len;
			continue;
		}
		if (qtype == T_ANY) {
			if (!(type == T_A || type == T_AAAA)) {
				cp += n;
				continue;
			}
		} else if (type != qtype) {
#ifndef NO_LOG_BAD_DNS_RESPONSES
			if (type != T_KEY && type != T_SIG) {
				struct syslog_data sdata = SYSLOG_DATA_INIT;

				syslog_r(LOG_NOTICE|LOG_AUTH, &sdata,
	       "gethostby*.getanswer: asked for \"%s %s %s\", got type \"%s\"",
				       qname, p_class(C_IN), p_type(qtype),
				       p_type(type));
			}
#endif /* NO_LOG_BAD_DNS_RESPONSES */
			cp += n;
			continue;		/* XXX - had_error++ ? */
		}
		switch (type) {
		case T_A:
		case T_AAAA:
			if (strcasecmp(canonname, bp) != 0) {
				struct syslog_data sdata = SYSLOG_DATA_INIT;

				syslog_r(LOG_NOTICE|LOG_AUTH, &sdata,
				       AskedForGot, canonname, bp);
				cp += n;
				continue;	/* XXX - had_error++ ? */
			}
			if (type == T_A && n != INADDRSZ) {
				cp += n;
				continue;
			}
			if (type == T_AAAA && n != IN6ADDRSZ) {
				cp += n;
				continue;
			}
			if (type == T_AAAA) {
				struct in6_addr in6;
				memcpy(&in6, cp, IN6ADDRSZ);
				if (IN6_IS_ADDR_V4MAPPED(&in6)) {
					cp += n;
					continue;
				}
			}
			if (!haveanswer) {
				canonname = bp;
				bp += strlen(bp) + 1;	/* for the \0 */
			}

			/* don't overwrite pai */
			ai = *pai;
			ai.ai_family = (type == T_A) ? AF_INET : AF_INET6;
			afd = find_afd(ai.ai_family);
			if (afd == NULL) {
				cp += n;
				continue;
			}
			cur->ai_next = get_ai(&ai, afd, (const char *)cp);
			if (cur->ai_next == NULL)
				had_error++;
			while (cur && cur->ai_next)
				cur = cur->ai_next;
			cp += n;
			break;
		default:
			abort();	/* XXX abort illegal in library */
		}
		if (!had_error)
			haveanswer++;
	}
	if (haveanswer) {
		if (!canonname || (pai->ai_flags & AI_FQDN) != 0)
			(void)get_canonname(pai, sentinel.ai_next, qname);
		else
			(void)get_canonname(pai, sentinel.ai_next, canonname);
		h_errno = NETDB_SUCCESS;
		return sentinel.ai_next;
	}

	h_errno = NO_RECOVERY;
	return NULL;
}

/*ARGSUSED*/
static struct addrinfo *
_dns_getaddrinfo(const char *name, const struct addrinfo *pai,
	const struct __res_state *_resp)
{
	struct addrinfo *ai;
	querybuf *buf, *buf2;
	struct addrinfo sentinel, *cur;
	struct res_target q, q2;

	memset(&q, 0, sizeof(q));
	memset(&q2, 0, sizeof(q2));
	memset(&sentinel, 0, sizeof(sentinel));
	cur = &sentinel;

	buf = malloc(sizeof(*buf));
	if (buf == NULL) {
		h_errno = NETDB_INTERNAL;
		return NULL;
	}
	buf2 = malloc(sizeof(*buf2));
	if (buf2 == NULL) {
		free(buf);
		h_errno = NETDB_INTERNAL;
		return NULL;
	}

	switch (pai->ai_family) {
	case AF_UNSPEC:
		/* respect user supplied order */
		q.qclass = C_IN;
		q.qtype = (_resp->family[0] == AF_INET6) ? T_AAAA : T_A;
		q.answer = buf->buf;
		q.anslen = sizeof(buf->buf);
		q.next = &q2;

		if (_resp->family[1] == -1) {
			/* stop here if only one family was given */
			q.next = NULL;
			break;
		}

		q2.qclass = C_IN;
		q2.qtype = (_resp->family[1] == AF_INET6) ? T_AAAA : T_A;
		q2.answer = buf2->buf;
		q2.anslen = sizeof(buf2->buf);
		break;
	case AF_INET:
		q.qclass = C_IN;
		q.qtype = T_A;
		q.answer = buf->buf;
		q.anslen = sizeof(buf->buf);
		break;
	case AF_INET6:
		q.qclass = C_IN;
		q.qtype = T_AAAA;
		q.answer = buf->buf;
		q.anslen = sizeof(buf->buf);
		break;
	default:
		free(buf);
		free(buf2);
		return NULL;
	}
	if (res_searchN(name, &q) < 0) {
		free(buf);
		free(buf2);
		return NULL;
	}
	ai = getanswer(buf, q.n, q.name, q.qtype, pai);
	if (ai) {
		cur->ai_next = ai;
		while (cur && cur->ai_next)
			cur = cur->ai_next;
	}
	if (q.next) {
		ai = getanswer(buf2, q2.n, q2.name, q2.qtype, pai);
		if (ai)
			cur->ai_next = ai;
	}
	free(buf);
	free(buf2);
	return sentinel.ai_next;
}

static struct addrinfo *
_gethtent(const char *name, const struct addrinfo *pai, FILE *hostf)
{
	char *p;
	char *cp, *tname, *cname;
	struct addrinfo hints, *res0, *res;
	int error;
	const char *addr;
	char hostbuf[8*1024];

 again:
	if (!(p = fgets(hostbuf, sizeof hostbuf, hostf)))
		return (NULL);
	if (*p == '#')
		goto again;
	if (!(cp = strpbrk(p, "#\n")))
		goto again;
	*cp = '\0';
	if (!(cp = strpbrk(p, " \t")))
		goto again;
	*cp++ = '\0';
	addr = p;
	/* if this is not something we're looking for, skip it. */
	cname = NULL;
	while (cp && *cp) {
		if (*cp == ' ' || *cp == '\t') {
			cp++;
			continue;
		}
		if (!cname)
			cname = cp;
		tname = cp;
		if ((cp = strpbrk(cp, " \t")) != NULL)
			*cp++ = '\0';
		if (strcasecmp(name, tname) == 0)
			goto found;
	}
	goto again;

found:
	hints = *pai;
	hints.ai_flags = AI_NUMERICHOST;
	error = getaddrinfo(addr, NULL, &hints, &res0);
	if (error)
		goto again;
	for (res = res0; res; res = res->ai_next) {
		/* cover it up */
		res->ai_flags = pai->ai_flags;

		if (get_canonname(pai, res, cname) != 0) {
			freeaddrinfo(res0);
			goto again;
		}
	}
	return res0;
}

/*ARGSUSED*/
static struct addrinfo *
_files_getaddrinfo(const char *name, const struct addrinfo *pai)
{
	struct addrinfo sentinel, *cur;
	struct addrinfo *p;
	FILE *hostf;

	hostf = fopen(_PATH_HOSTS, "r");
	if (hostf == NULL)
		return NULL;

	memset(&sentinel, 0, sizeof(sentinel));
	cur = &sentinel;

	while ((p = _gethtent(name, pai, hostf)) != NULL) {
		cur->ai_next = p;
		while (cur && cur->ai_next)
			cur = cur->ai_next;
	}
	fclose(hostf);

	return sentinel.ai_next;
}

#ifdef YP
static char *__ypdomain;

/*ARGSUSED*/
static struct addrinfo *
_yphostent(char *line, const struct addrinfo *pai)
{
	struct addrinfo sentinel, *cur;
	struct addrinfo hints, *res, *res0;
	int error;
	char *p = line;
	const char *addr, *canonname;
	char *nextline;
	char *cp;

	addr = canonname = NULL;

	memset(&sentinel, 0, sizeof(sentinel));
	cur = &sentinel;

nextline:
	/* terminate line */
	cp = strchr(p, '\n');
	if (cp) {
		*cp++ = '\0';
		nextline = cp;
	} else
		nextline = NULL;

	cp = strpbrk(p, " \t");
	if (cp == NULL) {
		if (canonname == NULL)
			return (NULL);
		else
			goto done;
	}
	*cp++ = '\0';

	addr = p;

	while (cp && *cp) {
		if (*cp == ' ' || *cp == '\t') {
			cp++;
			continue;
		}
		if (!canonname)
			canonname = cp;
		if ((cp = strpbrk(cp, " \t")) != NULL)
			*cp++ = '\0';
	}

	hints = *pai;
	hints.ai_flags = AI_NUMERICHOST;
	error = getaddrinfo(addr, NULL, &hints, &res0);
	if (error == 0) {
		for (res = res0; res; res = res->ai_next) {
			/* cover it up */
			res->ai_flags = pai->ai_flags;

			(void)get_canonname(pai, res, canonname);
		}
	} else
		res0 = NULL;
	if (res0) {
		cur->ai_next = res0;
		while (cur && cur->ai_next)
			cur = cur->ai_next;
	}

	if (nextline) {
		p = nextline;
		goto nextline;
	}

done:
	return sentinel.ai_next;
}

/*ARGSUSED*/
static struct addrinfo *
_yp_getaddrinfo(const char *name, const struct addrinfo *pai)
{
	struct addrinfo sentinel, *cur;
	struct addrinfo *ai = NULL;
	static char *__ypcurrent;
	int __ypcurrentlen, r;

	memset(&sentinel, 0, sizeof(sentinel));
	cur = &sentinel;

	if (!__ypdomain) {
		if (_yp_check(&__ypdomain) == 0)
			return NULL;
	}
	if (__ypcurrent)
		free(__ypcurrent);
	__ypcurrent = NULL;

	/* hosts.byname is only for IPv4 (Solaris8) */
	if (pai->ai_family == PF_UNSPEC || pai->ai_family == PF_INET) {
		r = yp_match(__ypdomain, "hosts.byname", name,
			(int)strlen(name), &__ypcurrent, &__ypcurrentlen);
		if (r == 0) {
			struct addrinfo ai4;

			ai4 = *pai;
			ai4.ai_family = AF_INET;
			ai = _yphostent(__ypcurrent, &ai4);
			if (ai) {
				cur->ai_next = ai;
				while (cur && cur->ai_next)
					cur = cur->ai_next;
			}
		}
	}

	/* ipnodes.byname can hold both IPv4/v6 */
	r = yp_match(__ypdomain, "ipnodes.byname", name,
		(int)strlen(name), &__ypcurrent, &__ypcurrentlen);
	if (r == 0) {
		ai = _yphostent(__ypcurrent, pai);
		if (ai) {
			cur->ai_next = ai;
			while (cur && cur->ai_next)
				cur = cur->ai_next;
		}
	}

	return sentinel.ai_next;
}
#endif


/* resolver logic */

extern const char *__hostalias(const char *);
extern int h_errno;
extern int res_opt(int, u_char *, int, int);

/*
 * Formulate a normal query, send, and await answer.
 * Returned answer is placed in supplied buffer "answer".
 * Perform preliminary check of answer, returning success only
 * if no error is indicated and the answer count is nonzero.
 * Return the size of the response on success, -1 on error.
 * Error number is left in h_errno.
 *
 * Caller must parse answer and determine whether it answers the question.
 */
static int
res_queryN(const char *name, struct res_target *target)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	u_char *buf;
	HEADER *hp;
	int n;
	struct res_target *t;
	int rcode;
	int ancount;

	buf = malloc(MAXPACKET);
	if (buf == NULL) {
		h_errno = NETDB_INTERNAL;
		return (-1);
	}

	rcode = NOERROR;
	ancount = 0;

	if (_res_init(0) == -1) {
		h_errno = NETDB_INTERNAL;
		free(buf);
		return (-1);
	}

	for (t = target; t; t = t->next) {
		int class, type;
		u_char *answer;
		int anslen;

		hp = (HEADER *)(void *)t->answer;
		hp->rcode = NOERROR;	/* default */

		/* make it easier... */
		class = t->qclass;
		type = t->qtype;
		answer = t->answer;
		anslen = t->anslen;
#ifdef DEBUG
		if (_resp->options & RES_DEBUG)
			printf(";; res_query(%s, %d, %d)\n", name, class, type);
#endif

		n = res_mkquery(QUERY, name, class, type, NULL, 0, NULL,
		    buf, MAXPACKET);
		if (n > 0 && (_resp->options & RES_USE_EDNS0) != 0)
			n = res_opt(n, buf, MAXPACKET, anslen);
		if (n <= 0) {
#ifdef DEBUG
			if (_resp->options & RES_DEBUG)
				printf(";; res_query: mkquery failed\n");
#endif
			h_errno = NO_RECOVERY;
			free(buf);
			return (n);
		}
		n = res_send(buf, n, answer, anslen);
#if 0
		if (n < 0) {
#ifdef DEBUG
			if (_resp->options & RES_DEBUG)
				printf(";; res_query: send error\n");
#endif
			h_errno = TRY_AGAIN;
			free(buf);
			return (n);
		}
#endif

		if (n < 0 || hp->rcode != NOERROR || ntohs(hp->ancount) == 0) {
			rcode = hp->rcode;	/* record most recent error */
#ifdef DEBUG
			if (_resp->options & RES_DEBUG)
				printf(";; rcode = %u, ancount=%u\n", hp->rcode,
				    ntohs(hp->ancount));
#endif
			continue;
		}

		ancount += ntohs(hp->ancount);

		t->n = n;
	}

	if (ancount == 0) {
		switch (rcode) {
		case NXDOMAIN:
			h_errno = HOST_NOT_FOUND;
			break;
		case SERVFAIL:
			h_errno = TRY_AGAIN;
			break;
		case NOERROR:
			h_errno = NO_DATA;
			break;
		case FORMERR:
		case NOTIMP:
		case REFUSED:
		default:
			h_errno = NO_RECOVERY;
			break;
		}
		free(buf);
		return (-1);
	}
	free(buf);
	return (ancount);
}

/*
 * Formulate a normal query, send, and retrieve answer in supplied buffer.
 * Return the size of the response on success, -1 on error.
 * If enabled, implement search rules until answer or unrecoverable failure
 * is detected.  Error code, if any, is left in h_errno.
 */
static int
res_searchN(const char *name, struct res_target *target)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	const char *cp, * const *domain;
	HEADER *hp = (HEADER *)(void *)target->answer;	/*XXX*/
	u_int dots;
	int trailing_dot, ret, saved_herrno;
	int got_nodata = 0, got_servfail = 0, tried_as_is = 0;

	if (_res_init(0) == -1) {
		h_errno = NETDB_INTERNAL;
		return (-1);
	}

	errno = 0;
	h_errno = HOST_NOT_FOUND;	/* default, if we never query */
	dots = 0;
	for (cp = name; *cp; cp++)
		dots += (*cp == '.');
	trailing_dot = 0;
	if (cp > name && *--cp == '.')
		trailing_dot++;

	/*
	 * if there aren't any dots, it could be a user-level alias
	 */
	if (!dots && (cp = __hostalias(name)) != NULL)
		return (res_queryN(cp, target));

	/*
	 * If there are dots in the name already, let's just give it a try
	 * 'as is'.  The threshold can be set with the "ndots" option.
	 */
	saved_herrno = -1;
	if (dots >= _resp->ndots) {
		ret = res_querydomainN(name, NULL, target);
		if (ret > 0)
			return (ret);
		saved_herrno = h_errno;
		tried_as_is++;
	}

	/*
	 * We do at least one level of search if
	 *	- there is no dot and RES_DEFNAME is set, or
	 *	- there is at least one dot, there is no trailing dot,
	 *	  and RES_DNSRCH is set.
	 */
	if ((!dots && (_resp->options & RES_DEFNAMES)) ||
	    (dots && !trailing_dot && (_resp->options & RES_DNSRCH))) {
		int done = 0;

		for (domain = (const char * const *)_resp->dnsrch;
		   *domain && !done;
		   domain++) {

			ret = res_querydomainN(name, *domain, target);
			if (ret > 0)
				return (ret);

			/*
			 * If no server present, give up.
			 * If name isn't found in this domain,
			 * keep trying higher domains in the search list
			 * (if that's enabled).
			 * On a NO_DATA error, keep trying, otherwise
			 * a wildcard entry of another type could keep us
			 * from finding this entry higher in the domain.
			 * If we get some other error (negative answer or
			 * server failure), then stop searching up,
			 * but try the input name below in case it's
			 * fully-qualified.
			 */
			if (errno == ECONNREFUSED) {
				h_errno = TRY_AGAIN;
				return (-1);
			}

			switch (h_errno) {
			case NO_DATA:
				got_nodata++;
				/* FALLTHROUGH */
			case HOST_NOT_FOUND:
				/* keep trying */
				break;
			case TRY_AGAIN:
				if (hp->rcode == SERVFAIL) {
					/* try next search element, if any */
					got_servfail++;
					break;
				}
				/* FALLTHROUGH */
			default:
				/* anything else implies that we're done */
				done++;
			}
			/*
			 * if we got here for some reason other than DNSRCH,
			 * we only wanted one iteration of the loop, so stop.
			 */
			if (!(_resp->options & RES_DNSRCH))
			        done++;
		}
	}

	/*
	 * if we have not already tried the name "as is", do that now.
	 * note that we do this regardless of how many dots were in the
	 * name or whether it ends with a dot.
	 */
	if (!tried_as_is) {
		ret = res_querydomainN(name, NULL, target);
		if (ret > 0)
			return (ret);
	}

	/*
	 * if we got here, we didn't satisfy the search.
	 * if we did an initial full query, return that query's h_errno
	 * (note that we wouldn't be here if that query had succeeded).
	 * else if we ever got a nodata, send that back as the reason.
	 * else send back meaningless h_errno, that being the one from
	 * the last DNSRCH we did.
	 */
	if (saved_herrno != -1)
		h_errno = saved_herrno;
	else if (got_nodata)
		h_errno = NO_DATA;
	else if (got_servfail)
		h_errno = TRY_AGAIN;
	return (-1);
}

/*
 * Perform a call on res_query on the concatenation of name and domain,
 * removing a trailing dot from name if domain is NULL.
 */
static int
res_querydomainN(const char *name, const char *domain,
    struct res_target *target)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	char nbuf[MAXDNAME];
	const char *longname = nbuf;
	size_t len;

	if (_res_init(0) == -1) {
		h_errno = NETDB_INTERNAL;
		return (-1);
	}
#ifdef DEBUG
	if (_resp->options & RES_DEBUG)
		printf(";; res_querydomain(%s, %s)\n",
			name, domain?domain:"<Nil>");
#endif
	if (domain == NULL) {
		/*
		 * Check for trailing '.';
		 * copy without '.' if present.
		 */
		len = strlcpy(nbuf, name, sizeof(nbuf));
		if (len >= sizeof(nbuf)) {
			h_errno = NO_RECOVERY;
			return (-1);
		}
		if (len > 0 && nbuf[len - 1] == '.')
			nbuf[len - 1] = '\0';
	} else {
		int i;

		i = snprintf(nbuf, sizeof(nbuf), "%s.%s", name, domain);
		if (i < 0 || i >= sizeof(nbuf)) {
			h_errno = NO_RECOVERY;
			return (-1);
		}
	}
	return (res_queryN(longname, target));
}
@


1.72
log
@Add AI_FQDN flag to getaddrinfo(3).  Prompted by discussions with djm@@
about cert checking in OpenSSH.  Man page wording tweaks thanks to
jmc@@.

ok henning@@, jmc@@; positive feedback from djm@@, ajacoutat@@

Committing now to reuse guenther@@'s libc minor bump instead of
cranking it again, as suggested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.71 2009/11/18 07:43:22 guenther Exp $	*/
@


1.71
log
@More shrinkage, a bit for ramdisks but mostly for static binaries:
- wrap with #ifndef NO_LOG_BAD_DNS_RESPONSES libc code that uses
  p_class() and p_type() for diagnostics, then add that define to
  libstub to avoid pulling in res_debug_syms.o
- split rcmd() and ruserok() into separate files, as nothing uses both
- split readdir_r() to its own file
- split syslog_r() from syslog(), as the latter needs localtime(); many
  binaries no longer need to pull in all the time code after this; switch
  from usleep() to nanosleep() while we're at it

(The profit of analysis of -Wl,-M,--cref output)

Chops 888kB from /bin and /sbin on i386

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.70 2009/09/02 19:07:12 fgsch Exp $	*/
d312 3
a314 1
		if (hints->ai_flags & ~AI_MASK)
d676 7
a682 8
			if ((pai->ai_flags & AI_CANONNAME)) {
				/*
				 * Set the numeric address itself as
				 * the canonical name, based on a
				 * clarification in rfc2553bis-03.
				 */
				GET_CANONNAME(cur->ai_next, canonname);
			}
d768 1
a768 1
	if ((pai->ai_flags & AI_CANONNAME) != 0) {
d1133 1
a1133 1
		if (!canonname)
d1279 3
a1281 5
		if (pai->ai_flags & AI_CANONNAME) {
			if (get_canonname(pai, res, cname) != 0) {
				freeaddrinfo(res0);
				goto again;
			}
d1371 1
a1371 2
			if (pai->ai_flags & AI_CANONNAME)
				(void)get_canonname(pai, res, canonname);
@


1.70
log
@make getaddrinfo(3) accept numeric servname when ai_socktype is not
specified in hint or hints is NULL.
claudio@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.69 2009/06/04 21:38:29 pyr Exp $	*/
d1065 1
d1074 1
@


1.69
log
@simplify the 'family' option parser and make it more evident what we're
now doing.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.68 2009/06/04 18:06:35 pyr Exp $	*/
d830 1
a831 3
		break;
	case ANY:
		allownumeric = 0;
@


1.68
log
@Add a resolv.conf option to specify the order in which getaddrinfo
PF_UNSPEC queries are made. While there change the default from inet6
first then inet4 to inet4 first then inet6, this prevents the many
people with IPv4 only connectivity from constantly trying to contact
IPv6 addresses, and also unbreaks many ports who don't use getaddrinfo
right.

ok deraadt@@, plenty of cheering in the room wrt the idea, not loud
enough complaining from the v6 crowd.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.67 2007/05/20 03:54:52 ray Exp $	*/
a1172 14
		if (_resp->family[0] == -1) {
			/* prefer IPv4 by default*/
			q.qclass = C_IN;
			q.qtype = T_A;
			q.answer = buf->buf;
			q.anslen = sizeof(buf->buf);
			q.next = &q2;
			q2.qclass = C_IN;
			q2.qtype = T_AAAA;
			q2.answer = buf2->buf;
			q2.anslen = sizeof(buf2->buf);
			break;
		}

d1175 1
a1175 4
		if (_resp->family[0] == AF_INET6)
			q.qtype = T_AAAA;
		else
			q.qtype = T_A;
d1178 2
d1181 1
a1184 1
		q.next = &q2;
d1187 1
a1187 4
		if (_resp->family[1] == AF_INET6)
			q2.qtype = T_AAAA;
		else
			q2.qtype = T_A;
@


1.67
log
@Typos.

OK jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.66 2007/05/18 01:10:59 ray Exp $	*/
d236 2
a237 1
static struct addrinfo *_dns_getaddrinfo(const char *, const struct addrinfo *);
d521 1
a521 1
			result = _dns_getaddrinfo(hostname, pai);
d1146 2
a1147 1
_dns_getaddrinfo(const char *name, const struct addrinfo *pai)
d1173 15
a1187 1
		/* prefer IPv6 */
d1189 4
a1192 1
		q.qtype = T_AAAA;
d1195 4
d1200 1
d1202 4
a1205 1
		q2.qtype = T_A;
@


1.66
log
@Remove no-op code.  From tbert.

OK moritz@@ and jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.65 2007/05/17 03:55:08 ray Exp $	*/
d40 1
a40 1
 *   says to use inet_aton() to convert IPv4 numeric to binary (alows
d423 1
a423 1
	 * we would like to prefer AF_INET6 than AF_INET, so we'll make a
@


1.65
log
@Improve reentrancy by not using global variable.  Removes two
wrappers around fopen/fclose.  From tbert.

OK millert@@, tedu@@, and itojun@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.64 2007/05/12 21:38:14 ray Exp $	*/
a457 2
	if (error)
		goto free;
@


1.64
log
@Use size_t for strlen results.

OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.63 2007/05/12 16:18:06 ray Exp $	*/
d220 2
a221 3
static void _sethtent(void);
static void _endhtent(void);
static struct addrinfo * _gethtent(const char *, const struct addrinfo *);
a950 1
static FILE *hostf = NULL;
a1221 20
static FILE *hostf;

static void
_sethtent(void)
{
	if (!hostf)
		hostf = fopen(_PATH_HOSTS, "r" );
	else
		rewind(hostf);
}

static void
_endhtent(void)
{
	if (hostf) {
		(void) fclose(hostf);
		hostf = NULL;
	}
}

d1223 1
a1223 1
_gethtent(const char *name, const struct addrinfo *pai)
a1231 2
	if (!hostf && !(hostf = fopen(_PATH_HOSTS, "r" )))
		return (NULL);
d1287 5
d1296 1
a1296 2
	_sethtent();
	while ((p = _gethtent(name, pai)) != NULL) {
d1301 1
a1301 1
	_endhtent();
@


1.63
log
@Clean up macros according to style.  From tbert <bret dot lambert at gmail>.

OK moritz@@ and jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.62 2007/05/10 02:14:35 ray Exp $	*/
d1007 2
d1013 2
a1014 2
		n = strlen(bp) + 1;		/* for the \0 */
		if (n >= MAXHOSTNAMELEN) {
d1019 1
a1019 1
		bp += n;
@


1.62
log
@Use syslog_r instead of syslog in getaddrinfo.  Slowly making
getaddrinfo reentrant.

OK millert@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.61 2007/02/18 19:03:11 ray Exp $	*/
d242 8
a249 8
#define GET_AI(ai, afd, addr) \
do { \
	/* external reference: pai, error, and label free */ \
	(ai) = get_ai(pai, (afd), (addr)); \
	if ((ai) == NULL) { \
		error = EAI_MEMORY; \
		goto free; \
	} \
d252 6
a257 6
#define GET_PORT(ai, serv) \
do { \
	/* external reference: error and label free */ \
	error = get_port((ai), (serv), 0); \
	if (error != 0) \
		goto free; \
d260 6
a265 6
#define GET_CANONNAME(ai, str) \
do { \
	/* external reference: pai, error and label free */ \
	error = get_canonname(pai, (ai), (str)); \
	if (error != 0) \
		goto free; \
d268 6
a273 6
#define ERR(err) \
do { \
	/* external reference: error, and label bad */ \
	error = (err); \
	goto bad; \
	/*NOTREACHED*/ \
@


1.61
log
@strlen(3) returns size_t.

OK itojun@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.60 2007/02/17 20:56:38 ray Exp $	*/
d1068 4
a1071 2
			if (type != T_KEY && type != T_SIG)
				syslog(LOG_NOTICE|LOG_AUTH,
d1075 1
d1083 3
a1085 1
				syslog(LOG_NOTICE|LOG_AUTH,
@


1.60
log
@Remove duplicate code.  No functional change.

OK itojun@@, moritz@@, and millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.59 2007/02/15 04:25:35 ray Exp $	*/
d1043 2
d1052 2
a1053 2
			n = strlen(tbuf) + 1;	/* for the \0 */
			if (n > ep - bp || n >= MAXHOSTNAMELEN) {
d1059 1
a1059 1
			bp += n;
@


1.59
log
@Remove two mutexes by replacing getservbyname() and getservbyport()
calls with their reentrant versions.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.58 2007/02/14 05:48:46 ray Exp $	*/
a615 1
		GET_PORT(cur->ai_next, servname);
a620 1
		GET_PORT(cur->ai_next, servname);
d622 1
d664 1
a664 18
		if (inet_aton(hostname, (struct in_addr *)pton) == 1) {
			if (pai->ai_family == afd->a_af ||
			    pai->ai_family == PF_UNSPEC /*?*/) {
				GET_AI(cur->ai_next, afd, pton);
				GET_PORT(cur->ai_next, servname);
				if ((pai->ai_flags & AI_CANONNAME)) {
					/*
					 * Set the numeric address itself as
					 * the canonical name, based on a
					 * clarification in rfc2553bis-03.
					 */
					GET_CANONNAME(cur->ai_next, canonname);
				}
				while (cur && cur->ai_next)
					cur = cur->ai_next;
			} else
				ERR(EAI_FAMILY);	/*xxx*/
		}
d668 1
a668 18
		if (inet_pton(afd->a_af, hostname, pton) == 1) {
			if (pai->ai_family == afd->a_af ||
			    pai->ai_family == PF_UNSPEC /*?*/) {
				GET_AI(cur->ai_next, afd, pton);
				GET_PORT(cur->ai_next, servname);
				if ((pai->ai_flags & AI_CANONNAME)) {
					/*
					 * Set the numeric address itself as
					 * the canonical name, based on a
					 * clarification in rfc2553bis-03.
					 */
					GET_CANONNAME(cur->ai_next, canonname);
				}
				while (cur && cur->ai_next)
					cur = cur->ai_next;
			} else
				ERR(EAI_FAMILY);	/*xxx*/
		}
d670 18
@


1.58
log
@Remove int pretending to be a size_t.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.57 2006/11/17 01:11:23 itojun Exp $	*/
a828 1
	struct servent *sp;
a830 2
	/* mutex is defined in getnameinfo.c */
	extern void *__THREAD_NAME(serv_mutex);
d864 3
d884 2
a885 4
		_THREAD_PRIVATE_MUTEX_LOCK(serv_mutex);
		sp = getservbyname(servname, proto);
		_THREAD_PRIVATE_MUTEX_UNLOCK(serv_mutex);
		if (sp == NULL)
d887 2
a888 1
		port = sp->s_port;
@


1.57
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.56 2006/04/18 02:57:10 ray Exp $	*/
a1117 2
				int nn;

d1119 1
a1119 2
				nn = strlen(bp) + 1;	/* for the \0 */
				bp += nn;
@


1.56
log
@Clarify strlcpy code by explicitly naming variable `len' and
separating out each step.  Inspired during miscommunication with
tedu@@.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.55 2006/04/14 03:16:02 ray Exp $	*/
d936 2
a937 1
	if (IN6_IS_ADDR_LINKLOCAL(a6) || IN6_IS_ADDR_MC_LINKLOCAL(a6)) {
@


1.55
log
@Remove str2number(), use strtonum(3) instead.
Fix some type mismatches.
Replace magic numbers.
Remove superfluous strlen(3) calls.

Earlier diff OK kjell@@, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.54 2006/03/22 13:29:26 ray Exp $	*/
d1748 1
a1748 1
	size_t n;
d1764 2
a1765 1
		if ((n = strlcpy(nbuf, name, sizeof(nbuf))) >= sizeof(nbuf)) {
d1769 2
a1770 2
		if (n > 0 && nbuf[n - 1] == '.')
			nbuf[n - 1] = '\0';
@


1.54
log
@Pass size of correct variable to memset().

From Alexey Dobriyan.

OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.53 2005/07/18 14:38:39 jmc Exp $	*/
d94 1
a200 1
static int str2number(const char *);
a280 17
static int
str2number(const char *p)
{
	char *ep;
	unsigned long v;

	if (*p == '\0')
		return -1;
	ep = NULL;
	errno = 0;
	v = strtoul(p, &ep, 10);
	if (errno == 0 && ep && *ep == '\0' && v <= UINT_MAX)
		return v;
	else
		return -1;
}

d828 1
a828 1
	const char *proto;
d861 2
a862 2
	port = str2number(servname);
	if (port >= 0) {
a864 2
		if (port < 0 || port > 65535)
			return EAI_SERVICE;
d867 2
a928 1
	u_long lscopeid;
d930 1
a930 1
	char *ep;
d958 4
a961 7
	errno = 0;
	lscopeid = strtoul(scope, &ep, 10);
	*scopeid = (u_int32_t)(lscopeid & 0xffffffffUL);
	if (errno == 0 && ep && *ep == '\0' && *scopeid == lscopeid)
		return 0;
	else
		return -1;
d1748 1
a1748 1
	size_t n, d;
d1764 1
a1764 2
		n = strlen(name);
		if (n >= MAXDNAME) {
d1768 2
a1769 4
		if (n > 0 && name[--n] == '.') {
			strlcpy(nbuf, name, n + 1);
		} else
			longname = name;
d1771 4
a1774 3
		n = strlen(name);
		d = strlen(domain);
		if (n + d + 1 >= MAXDNAME) {
a1777 1
		snprintf(nbuf, sizeof(nbuf), "%s.%s", name, domain);
@


1.53
log
@fix spelling mistake (in comment);
from ray lai;
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.52 2005/03/30 02:58:28 tedu Exp $	*/
d1188 1
a1188 1
	memset(&q, 0, sizeof(q2));
@


1.52
log
@make the resolver stat resolv.conf and update if it changes.
useful feedback and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.51 2005/03/25 13:24:12 otto Exp $	*/
d428 1
a428 1
	 * If numreic representation of AF1 can be interpreted as FQDN
@


1.51
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.50 2004/06/07 21:11:23 marc Exp $	*/
d519 1
a519 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1)
d1528 1
a1528 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1) {
d1634 1
a1634 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1) {
d1771 1
a1771 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1) {
@


1.50
log
@
major bump to libc and libpthread to break the dependency of a
particular implementation of libpthread for libc.  libc no longer
needs pthread.h to compile.
OK millert@@, brad@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.49 2004/04/14 07:06:15 itojun Exp $	*/
d282 1
a282 2
str2number(p)
	const char *p;
d299 2
a300 4
getaddrinfo(hostname, servname, hints, res)
	const char *hostname, *servname;
	const struct addrinfo *hints;
	struct addrinfo **res;
d499 2
a500 5
explore_fqdn(pai, hostname, servname, res)
	const struct addrinfo *pai;
	const char *hostname;
	const char *servname;
	struct addrinfo **res;
d594 2
a595 4
explore_null(pai, servname, res)
	const struct addrinfo *pai;
	const char *servname;
	struct addrinfo **res;
d656 2
a657 6
explore_numeric(pai, hostname, servname, res, canonname)
	const struct addrinfo *pai;
	const char *hostname;
	const char *servname;
	struct addrinfo **res;
	const char *canonname;
d738 2
a739 5
explore_numeric_scope(pai, hostname, servname, res)
	const struct addrinfo *pai;
	const char *hostname;
	const char *servname;
	struct addrinfo **res;
d801 1
a801 4
get_canonname(pai, ai, str)
	const struct addrinfo *pai;
	struct addrinfo *ai;
	const char *str;
d812 1
a812 4
get_ai(pai, afd, addr)
	const struct addrinfo *pai;
	const struct afd *afd;
	const char *addr;
d834 1
a834 3
get_portmatch(ai, servname)
	const struct addrinfo *ai;
	const char *servname;
d843 1
a843 4
get_port(ai, servname, matchonly)
	struct addrinfo *ai;
	const char *servname;
	int matchonly;
d928 1
a928 2
find_afd(af)
	int af;
d944 1
a944 4
ip6_str2scopeid(scope, sin6, scopeid)
	char *scope;
	struct sockaddr_in6 *sin6;
	u_int32_t *scopeid;
d993 2
a994 6
getanswer(answer, anslen, qname, qtype, pai)
	const querybuf *answer;
	int anslen;
	const char *qname;
	int qtype;
	const struct addrinfo *pai;
d1181 1
a1181 3
_dns_getaddrinfo(name, pai)
	const char *name;
	const struct addrinfo *pai;
d1259 1
a1259 1
_sethtent()
d1268 1
a1268 1
_endhtent()
d1277 1
a1277 3
_gethtent(name, pai)
	const char *name;
	const struct addrinfo *pai;
d1339 1
a1339 3
_files_getaddrinfo(name, pai)
	const char *name;
	const struct addrinfo *pai;
d1363 1
a1363 3
_yphostent(line, pai)
	char *line;
	const struct addrinfo *pai;
d1439 1
a1439 3
_yp_getaddrinfo(name, pai)
	const char *name;
	const struct addrinfo *pai;
d1509 1
a1509 3
res_queryN(name, target)
	const char *name;	/* domain name */
	struct res_target *target;
d1625 1
a1625 3
res_searchN(name, target)
	const char *name;	/* domain name */
	struct res_target *target;
d1763 2
a1764 3
res_querydomainN(name, domain, target)
	const char *name, *domain;
	struct res_target *target;
@


1.49
log
@implement RFC3493 AI_NUMERICSERV.  tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.48 2003/07/21 23:17:53 marc Exp $	*/
d876 1
a876 1
	extern pthread_mutex_t __THREAD_MUTEX_NAME(serv_mutex);
@


1.48
log
@bug library/3297: lib/libc/net/get{addr,name}info should share mutex
'Looks right' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.47 2003/05/14 05:38:34 itojun Exp $	*/
d200 1
a200 1
static int str_isnumber(const char *);
a215 3
#if 0
static int addrconfig(const struct addrinfo *);
#endif
d282 1
a282 1
str_isnumber(p)
d286 1
d289 1
a289 1
		return NO;
d292 3
a294 3
	(void)strtoul(p, &ep, 10);
	if (errno == 0 && ep && *ep == '\0')
		return YES;
d296 1
a296 1
		return NO;
a517 11
#if 0
	/*
	 * If AI_ADDRCONFIG is specified, check if we are expected to
	 * return the address family or not.
	 * XXX does not handle PF_UNSPEC case, should filter final result
	 */
	if ((pai->ai_flags & AI_ADDRCONFIG) != 0 && !addrconfig(pai)) {
		return 0;
	}
#endif

d904 2
a905 1
	if (str_isnumber(servname)) {
a907 1
		port = atoi(servname);
d912 3
a966 22

#if 0
/*
 * post-2553: AI_ADDRCONFIG check.  if we use getipnodeby* as backend, backend
 * will take care of it.
 * the semantics of AI_ADDRCONFIG is not defined well.  we are not sure
 * if the code is right or not.
 */
static int
addrconfig(pai)
	const struct addrinfo *pai;
{
	int s;

	/* XXX errno */
	s = socket(pai->ai_family, SOCK_DGRAM, 0);
	if (s < 0)
		return 0;
	close(s);
	return 1;
}
#endif
@


1.47
log
@fill ai_canonname field for numeric hostname, by the given hostname.
folows new recommendation in RFC3493.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.46 2003/03/17 23:16:36 jason Exp $	*/
d888 2
a889 1
	_THREAD_PRIVATE_MUTEX(serv_mutex);
@


1.46
log
@If hostname != NULL, hostname is not a numeric string, and AI_NUMERICHOST
is set, return EAI_NONAME like RFC2553 specifies.  millert/itojun ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.45 2003/03/04 00:29:17 itojun Exp $	*/
d206 1
a206 1
	const char *, struct addrinfo **);
d421 2
a422 1
			error = explore_numeric_scope(pai, hostname, servname, &cur->ai_next);
d677 1
a677 1
explore_numeric(pai, hostname, servname, res)
d682 1
d712 8
d733 8
d770 1
a770 1
	return explore_numeric(pai, hostname, servname, res);
d789 1
a789 1
		return explore_numeric(pai, hostname, servname, res);
d793 1
a793 1
		return explore_numeric(pai, hostname, servname, res);
d806 1
a806 1
	error = explore_numeric(pai, addr, servname, res);
@


1.45
log
@strlcpy, check retval from sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.44 2003/01/28 04:58:00 marc Exp $	*/
a437 2
	if (pai->ai_flags & AI_NUMERICHOST)
		ERR(EAI_NODATA);
d440 2
@


1.44
log
@
thread safer libc (note: safer, not safe)
Access to the global _res structure replaced by pointers to a
per thread instance.  If unthreaded the pointer is to the
global structure.

Also replaced a 64k stack array with malloc-ed memory so
threaded aps (with a default 64k stack) have a chance at working.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.43 2002/08/27 08:53:13 itojun Exp $	*/
d1140 1
a1140 1
			strcpy(bp, tbuf);
@


1.43
log
@allocate 64K recieve buffer for DNS responses.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.42 2002/08/22 16:35:37 itojun Exp $	*/
a501 2
_THREAD_PRIVATE_MUTEX(getaddrinfo_explore_fqdn);

d509 1
d515 1
a515 2

	_THREAD_PRIVATE_MUTEX_LOCK(getaddrinfo_explore_fqdn);
a525 1
		_THREAD_PRIVATE_MUTEX_UNLOCK(getaddrinfo_explore_fqdn);
a533 1
		_THREAD_PRIVATE_MUTEX_UNLOCK(getaddrinfo_explore_fqdn);
d537 1
a537 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
d540 1
a540 1
		bcopy(_res.lookups, lookups, sizeof lookups);
d545 5
d565 1
a571 1
		_THREAD_PRIVATE_MUTEX_UNLOCK(getaddrinfo_explore_fqdn);
a602 1
	_THREAD_PRIVATE_MUTEX_UNLOCK(getaddrinfo_explore_fqdn);
d870 1
d918 4
a921 1
		if ((sp = getservbyname(servname, proto)) == NULL)
d1570 2
a1571 1
	u_char buf[MAXPACKET];
d1578 6
d1587 1
a1587 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
d1589 1
d1607 1
a1607 1
		if (_res.options & RES_DEBUG)
d1612 3
a1614 3
		    buf, sizeof(buf));
		if (n > 0 && (_res.options & RES_USE_EDNS0) != 0)
			n = res_opt(n, buf, sizeof(buf), anslen);
d1617 1
a1617 1
			if (_res.options & RES_DEBUG)
d1621 1
d1628 1
a1628 1
			if (_res.options & RES_DEBUG)
d1632 1
d1640 1
a1640 1
			if (_res.options & RES_DEBUG)
d1670 1
d1673 1
d1688 1
d1695 1
a1695 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
d1720 1
a1720 1
	if (dots >= _res.ndots) {
d1734 2
a1735 2
	if ((!dots && (_res.options & RES_DEFNAMES)) ||
	    (dots && !trailing_dot && (_res.options & RES_DNSRCH))) {
d1738 1
a1738 1
		for (domain = (const char * const *)_res.dnsrch;
d1786 1
a1786 1
			if (!(_res.options & RES_DNSRCH))
d1828 1
d1833 1
a1833 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
d1838 1
a1838 1
	if (_res.options & RES_DEBUG)
@


1.42
log
@drop AAAA reply with IPv4 mapped address.  sync w/kame
draft-itojun-v6ops-v4mapped-harmful-00.txt
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.41 2002/07/25 21:13:45 deraadt Exp $	*/
d184 1
a184 5
#if PACKETSZ > 1024
#define MAXPACKET	PACKETSZ
#else
#define MAXPACKET	1024
#endif
d1229 1
a1229 1
	querybuf buf, buf2;
d1238 12
d1255 2
a1256 2
		q.answer = buf.buf;
		q.anslen = sizeof(buf);
d1260 2
a1261 2
		q2.answer = buf2.buf;
		q2.anslen = sizeof(buf2);
d1266 2
a1267 2
		q.answer = buf.buf;
		q.anslen = sizeof(buf);
d1272 2
a1273 2
		q.answer = buf.buf;
		q.anslen = sizeof(buf);
d1276 2
d1280 3
a1282 1
	if (res_searchN(name, &q) < 0)
d1284 2
a1285 1
	ai = getanswer(&buf, q.n, q.name, q.qtype, pai);
d1292 1
a1292 1
		ai = getanswer(&buf2, q2.n, q2.name, q2.qtype, pai);
d1296 2
@


1.41
log
@kill more strcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.40 2002/07/24 01:38:34 itojun Exp $	*/
d1175 8
@


1.40
log
@have _THREAD_PRIVATE_MUTEX for DNS/YP/hosts lookup.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.39 2002/07/01 21:57:35 itojun Exp $	*/
d546 1
a546 1
		strncpy(lookups, "f", sizeof lookups);
d550 1
a550 1
			strncpy(lookups, "bf", sizeof lookups);
d821 1
a821 1
		ai->ai_canonname = (char *)malloc(strlen(str) + 1);
a823 1
		strcpy(ai->ai_canonname, str);
@


1.39
log
@more type pedant
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.38 2002/07/01 21:08:13 itojun Exp $	*/
d111 2
d505 3
d521 2
d531 2
a532 1
	if ((pai->ai_flags & AI_ADDRCONFIG) != 0 && !addrconfig(pai))
d534 1
d540 2
a541 1
	if (get_portmatch(pai, servname) != 0)
d543 1
d574 1
d606 1
@


1.38
log
@lint clean (and don't mixup signed/unsigned).  from martin husemann
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.37 2002/07/01 07:43:48 itojun Exp $	*/
d1009 1
a1009 1
	*scopeid = (u_int32_t)(lscopeid & 0xffffffff);
@


1.37
log
@make more pedantic check on strtoul.  from deraadt, sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.36 2002/06/29 12:25:42 itojun Exp $	*/
d222 1
a222 1
static u_int32_t ip6_str2scopeid(char *, struct sockaddr_in6 *);
d787 1
a787 1
			if ((scopeid = ip6_str2scopeid(scope, sin6)) == -1) {
d971 2
a972 2
static u_int32_t
ip6_str2scopeid(scope, sin6)
d975 1
a976 1
	u_int32_t scopeid;
d991 2
a992 2
		scopeid = if_nametoindex(scope);
		if (scopeid == 0)
d994 1
a994 1
		return(scopeid);
d1009 3
a1011 3
	scopeid = lscopeid & 0xffffffff;
	if (errno == 0 && ep && *ep == '\0' && scopeid == lscopeid)
		return scopeid;
@


1.36
log
@correct port range check.  from deraadt.  sync w/kame.  bind-bugs have already notified.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.35 2002/06/27 09:55:49 itojun Exp $	*/
d222 1
a222 1
static int ip6_str2scopeid(char *, struct sockaddr_in6 *);
d295 1
d297 1
a297 1
	if (ep && *ep == '\0')
d781 1
a781 1
		int scopeid;
d971 1
a971 1
static int
d976 2
a977 1
	int scopeid;
d1007 4
a1010 2
	scopeid = (int)strtoul(scope, &ep, 10);
	if (*ep == '\0')
@


1.35
log
@%d/%u mixup (in #ifdef DEBUG)
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.34 2002/06/26 06:01:16 itojun Exp $	*/
d891 1
a891 1
		port = htons(atoi(servname));
d894 1
@


1.34
log
@correct bad practice in the code - it uses two changing variables
to manage buffer (buf and buflen).  we eliminate buflen and use
fixed point (ep) as the ending pointer.

this fix is NOT critical.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.33 2002/02/17 19:42:23 millert Exp $	*/
d1587 1
a1587 1
				printf(";; rcode = %d, ancount=%d\n", hp->rcode,
@


1.33
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.32 2002/02/16 21:27:23 millert Exp $	*/
d1034 2
a1035 2
	char *bp;
	int type, class, buflen, ancount, qdcount;
d1062 1
a1062 1
	buflen = sizeof hostbuf;
d1068 1
a1068 1
	n = dn_expand(answer->buf, eom, cp, bp, buflen);
a1085 1
		buflen -= n;
d1092 1
a1092 1
		n = dn_expand(answer->buf, eom, cp, bp, buflen);
d1119 1
a1119 1
			if (n > buflen || n >= MAXHOSTNAMELEN) {
a1125 1
			buflen -= n;
a1164 1
				buflen -= nn;
@


1.33.2.1
log
@Pull in patch from current:
Fix (itojun):
allocate 64K recieve buffer for DNS responses.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.33 2002/02/17 19:42:23 millert Exp $	*/
d182 5
a186 1
#define MAXPACKET	(64*1024)
d1211 1
a1211 1
	querybuf *buf, *buf2;
a1219 12
	buf = malloc(sizeof(*buf));
	if (buf == NULL) {
		h_errno = NETDB_INTERNAL;
		return NULL;
	}
	buf2 = malloc(sizeof(*buf2));
	if (buf2 == NULL) {
		free(buf);
		h_errno = NETDB_INTERNAL;
		return NULL;
	}

d1225 2
a1226 2
		q.answer = buf->buf;
		q.anslen = sizeof(buf->buf);
d1230 2
a1231 2
		q2.answer = buf2->buf;
		q2.anslen = sizeof(buf2->buf);
d1236 2
a1237 2
		q.answer = buf->buf;
		q.anslen = sizeof(buf->buf);
d1242 2
a1243 2
		q.answer = buf->buf;
		q.anslen = sizeof(buf->buf);
a1245 2
		free(buf);
		free(buf2);
d1248 1
a1248 3
	if (res_searchN(name, &q) < 0) {
		free(buf);
		free(buf2);
d1250 1
a1250 2
	}
	ai = getanswer(buf, q.n, q.name, q.qtype, pai);
d1257 1
a1257 1
		ai = getanswer(buf2, q2.n, q2.name, q2.qtype, pai);
a1260 2
	free(buf);
	free(buf2);
@


1.32
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.31 2002/01/02 23:00:10 deraadt Exp $	*/
d203 12
a214 12
static int explore_fqdn __P((const struct addrinfo *, const char *,
	const char *, struct addrinfo **));
static int explore_null __P((const struct addrinfo *,
	const char *, struct addrinfo **));
static int explore_numeric __P((const struct addrinfo *, const char *,
	const char *, struct addrinfo **));
static int explore_numeric_scope __P((const struct addrinfo *, const char *,
	const char *, struct addrinfo **));
static int get_canonname __P((const struct addrinfo *,
	struct addrinfo *, const char *));
static struct addrinfo *get_ai __P((const struct addrinfo *,
	const struct afd *, const char *));
d228 2
a229 2
static struct addrinfo *_files_getaddrinfo __P((const char *,
	const struct addrinfo *));
d233 2
a234 2
static struct addrinfo *_yp_getaddrinfo __P((const char *,
	const struct addrinfo *));
d237 2
a238 2
static struct addrinfo *getanswer __P((const querybuf *, int, const char *, int,
	const struct addrinfo *));
d241 2
a242 4
static int res_querydomainN __P((const char *, const char *,
	struct res_target *));
static struct addrinfo *_dns_getaddrinfo __P((const char *,
	const struct addrinfo *));
@


1.31
log
@label abort() from inside library as ILLEGAL
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.30 2001/08/20 02:23:05 itojun Exp $	*/
d202 1
a202 1
static int str_isnumber __P((const char *));
d215 3
a217 3
static int get_portmatch __P((const struct addrinfo *, const char *));
static int get_port __P((struct addrinfo *, const char *, int));
static const struct afd *find_afd __P((int));
d219 1
a219 1
static int addrconfig __P((const struct addrinfo *));
d222 1
a222 1
static int ip6_str2scopeid __P((char *, struct sockaddr_in6 *));
d225 3
a227 3
static void _sethtent __P((void));
static void _endhtent __P((void));
static struct addrinfo * _gethtent __P((const char *, const struct addrinfo *));
d232 1
a232 1
static struct addrinfo *_yphostent __P((char *, const struct addrinfo *));
d239 2
a240 2
static int res_queryN __P((const char *, struct res_target *));
static int res_searchN __P((const char *, struct res_target *));
d1040 1
a1040 1
	int (*name_ok) __P((const char *));
d1512 1
a1512 1
extern const char *__hostalias __P((const char *));
d1514 1
a1514 1
extern int res_opt __P((int, u_char *, int, int));
@


1.30
log
@use snprintf, not sprintf.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.29 2001/06/27 00:58:54 lebel Exp $	*/
d1055 1
a1055 1
		return (NULL);	/* XXX should be abort(); */
d1188 1
a1188 1
			abort();
@


1.30.2.1
log
@MFC (itojun):
allocate 64K receive buffer for DNS responses.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.30 2001/08/20 02:23:05 itojun Exp $	*/
d182 5
a186 1
#define MAXPACKET	(64*1024)
d1213 1
a1213 1
	querybuf *buf, *buf2;
a1221 12
	buf = malloc(sizeof(*buf));
	if (buf == NULL) {
		h_errno = NETDB_INTERNAL;
		return NULL;
	}
	buf2 = malloc(sizeof(*buf2));
	if (buf2 == NULL) {
		free(buf);
		h_errno = NETDB_INTERNAL;
		return NULL;
	}

d1227 2
a1228 2
		q.answer = buf->buf;
		q.anslen = sizeof(buf->buf);
d1232 2
a1233 2
		q2.answer = buf2->buf;
		q2.anslen = sizeof(buf2->buf);
d1238 2
a1239 2
		q.answer = buf->buf;
		q.anslen = sizeof(buf->buf);
d1244 2
a1245 2
		q.answer = buf->buf;
		q.anslen = sizeof(buf->buf);
a1247 2
		free(buf);
		free(buf2);
d1250 1
a1250 3
	if (res_searchN(name, &q) < 0) {
		free(buf);
		free(buf2);
d1252 1
a1252 2
	}
	ai = getanswer(buf, q.n, q.name, q.qtype, pai);
d1259 1
a1259 1
		ai = getanswer(buf2, q2.n, q2.name, q2.qtype, pai);
a1262 2
	free(buf);
	free(buf2);
@


1.29
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.28 2001/06/11 10:05:58 itojun Exp $	*/
d1810 1
a1810 1
		sprintf(nbuf, "%s.%s", name, domain);
@


1.28
log
@support EDNS0 (RFC2671) buffer size notification on DNS queries.
"options edns0" in /etc/resolv.conf will enable the behavior.  no behavior
change if you don't have the line.  see resolv.conf(5) for more details.

EDNS0 is useful for avoiding TCP DNS queries/replies on larger DNS responses.
also, draft-ietf-dnsext-message-size-* plans to mandate EDNS0 support for DNS
clients that support IPv6 transport.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.27 2000/08/31 17:41:51 itojun Exp $	*/
d1800 1
a1800 2
			strncpy(nbuf, name, n);
			nbuf[n] = '\0';
@


1.27
log
@on /etc/hosts lookup, set "official host name" (the leftmost hostname)
into ai_canonname.  this is to synchronize with practice in gethostby*.
comment from ume@@mahoroba.org.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.26 2000/08/22 19:04:42 deraadt Exp $	*/
d1514 1
d1566 2
@


1.26
log
@Wall
@
text
@d1 2
a2 2
/*	$OpenBSD: getaddrinfo.c,v 1.25 2000/07/09 04:48:35 itojun Exp $	*/
/*	$KAME: getaddrinfo.c,v 1.30 2000/07/09 04:37:25 itojun Exp $	*/
d1292 1
a1292 1
	char *cp, *tname;
d1313 1
d1319 2
d1340 1
a1340 1
			if (get_canonname(pai, res, name) != 0) {
@


1.25
log
@reject empty scopeid/numeric portname.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.24 2000/07/05 03:00:55 itojun Exp $	*/
d106 1
a106 1
#include <rpcsvc/yp_prot.h>
d108 1
@


1.24
log
@return EAI_NODATA, instead of EAI_NONAME, on name resolution errors.
EAI_NONAME does not make sense in these situations.  from kame.
From: enami@@netbsd.org
@
text
@d1 2
a2 2
/*	$OpenBSD: getaddrinfo.c,v 1.23 2000/05/15 10:49:55 itojun Exp $	*/
/*	$KAME: getaddrinfo.c,v 1.25 2000/07/05 02:59:28 itojun Exp $	*/
d291 10
a300 7
	const char *q = (const char *)p;
	while (*q) {
		if (!isdigit(*q))
			return NO;
		q++;
	}
	return YES;
d978 4
@


1.23
log
@translate DNS error code into getaddrinfo error code (EAI_xxx).  PR 1229.
@
text
@d1 2
a2 2
/*	$OpenBSD: getaddrinfo.c,v 1.22 2000/04/27 05:30:23 itojun Exp $	*/
/*	$KAME: getaddrinfo.c,v 1.21 2000/05/05 07:40:51 itojun Exp $	*/
d195 1
a195 1
	int class, type;	/* class and type of query */
d438 1
a438 1
		ERR(EAI_NONAME);
d440 1
a440 1
		ERR(EAI_NONAME);
d786 1
a786 1
				return(EAI_NONAME); /* XXX: is return OK? */
d1217 2
a1218 2
		q.class = C_IN;
		q.type = T_AAAA;
d1222 2
a1223 2
		q2.class = C_IN;
		q2.type = T_A;
d1228 2
a1229 2
		q.class = C_IN;
		q.type = T_A;
d1234 2
a1235 2
		q.class = C_IN;
		q.type = T_AAAA;
d1244 1
a1244 1
	ai = getanswer(&buf, q.n, q.name, q.type, pai);
d1251 1
a1251 1
		ai = getanswer(&buf2, q2.n, q2.name, q2.type, pai);
d1543 2
a1544 2
		class = t->class;
		type = t->type;
@


1.22
log
@remove unused struct def.  more sanity check for NULL.
@
text
@d1 2
a2 2
/*	$OpenBSD: getaddrinfo.c,v 1.21 2000/04/26 16:05:20 itojun Exp $	*/
/*	$KAME: getaddrinfo.c,v 1.16 2000/04/27 03:37:43 itojun Exp $	*/
d561 25
@


1.22.2.1
log
@Pull in patch from current (itojun):
translate DNS error code into getaddrinfo error code (EAI_xxx).  PR 1229.
@
text
@d1 2
a2 2
/*	$OpenBSD: getaddrinfo.c,v 1.23 2000/05/15 10:49:55 itojun Exp $	*/
/*	$KAME: getaddrinfo.c,v 1.21 2000/05/05 07:40:51 itojun Exp $	*/
a560 25
	} else {
		/* translate error code */
		switch (h_errno) {
		case NETDB_SUCCESS:
			error = EAI_FAIL;	/*XXX strange */
			break;
		case HOST_NOT_FOUND:
			error = EAI_NODATA;
			break;
		case TRY_AGAIN:
			error = EAI_AGAIN;
			break;
		case NO_RECOVERY:
			error = EAI_FAIL;
			break;
		case NO_DATA:
#if NO_ADDRESS != NO_DATA
		case NO_ADDRESS:
#endif
			error = EAI_NODATA;
			break;
		default:			/* unknown ones */
			error = EAI_FAIL;
			break;
		}
@


1.21
log
@add $KAME$ for future version tracking
@
text
@d1 2
a2 2
/*	$OpenBSD: getaddrinfo.c,v 1.20 2000/04/26 14:41:14 itojun Exp $	*/
/*	$KAME: getaddrinfo.c,v 1.14 2000/04/26 15:41:49 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d119 1
a119 1
static const char in_loopback[] = { 127, 0, 0, 1 }; 
a123 7
struct sockinet {
	u_char	si_len;
	u_char	si_family;
	u_short	si_port;
	u_int32_t si_scope_id;
};

d222 1
a222 1
#endif 
d608 2
d662 2
d675 1
a675 1
			} else 
d688 1
a688 1
			} else 
d730 3
d979 1
a979 1
#endif 
@


1.20
log
@remove #if 0'ed portion which we will never revisit (no behavior change).
@
text
@d1 2
a2 1
/*	$OpenBSD: getaddrinfo.c,v 1.19 2000/04/26 12:31:44 itojun Exp $	*/
@


1.19
log
@sync with latest kame.
- completely disable AI_ADDRCONFIG support (post RFC2553) since it does
  not work for PF_UNSPEC.
- remove unused variables, some delint.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.18 2000/04/25 13:39:02 itojun Exp $	*/
a738 12
#if 0
	/*
	 * Handle special case of <scope id><delimiter><scoped_address>
	 */
	hostname2 = strdup(hostname);
	if (hostname2 == NULL)
		return EAI_MEMORY;
	/* terminate at the delimiter */
	hostname2[cp - hostname] = '\0';
	scope = hostname2;
	addr = cp + 1;
#else
a748 1
#endif
@


1.18
log
@correct boundary check.  XXX should avoid code duplicate here...
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.17 2000/03/16 14:08:55 itojun Exp $	*/
d79 1
d81 1
d223 1
a223 1
#ifdef AI_ADDRCONFIG
d285 1
d521 1
a521 1
#ifdef AI_ADDRCONFIG
d525 1
a653 1
	int flags;
a665 1
	flags = pai->ai_flags;
d770 1
a770 1
			sin6 = (struct sockaddr_in6 *)cur->ai_addr;
d815 1
a815 1
	ai->ai_addr = (struct sockaddr *)(ai + 1);
d820 1
a820 1
	p = (char *)(ai->ai_addr);
d832 1
d900 2
a901 1
			((struct sockaddr_in *)ai->ai_addr)->sin_port = port;
d905 2
a906 1
			((struct sockaddr_in6 *)ai->ai_addr)->sin6_port = port;
d930 1
a930 1
#ifdef AI_ADDRCONFIG
a1018 1
	const char *tname;
a1024 1
	tname = qname;
d1159 1
a1159 1
			cur->ai_next = get_ai(&ai, afd, cp);
a1194 1
	int ancount;
d1229 1
a1229 1
	if ((ancount = res_searchN(name, &q)) < 0)
a1363 1
	int more;
d1367 3
a1370 2
	more = 0;

@


1.17
log
@workaround against name servers which return NXDOMAIN/SERVFAIL on IPv4 only
node (the srever server should return acount = 0 without error).
NetBSD PR: 9621
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.16 2000/03/13 12:26:56 itojun Exp $	*/
d1770 1
a1770 1
		if (n-- != 0 && name[n] == '.') {
@


1.16
log
@fix error handling in yp case.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.15 2000/02/25 04:41:41 itojun Exp $	*/
d1548 1
d1557 1
d1559 1
a1559 1
		if (hp->rcode != NOERROR || ntohs(hp->ancount) == 0) {
@


1.15
log
@make getaddrinfo obey search order declared in resolv.conf.
the code duplicate is necessary because there's no low-level resolver
function that looks up database against "any address family" query.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.14 2000/02/21 04:14:09 itojun Exp $	*/
d1410 2
a1411 1
	}
@


1.14
log
@remove extra #ifdef (USE_GETIPNODEBY)
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.13 2000/02/17 17:09:40 itojun Exp $	*/
d57 20
a76 15
 * - The code makes use of following calls when asked to resolver with
 *   ai_family  = PF_UNSPEC:
 *	getipnodebyname(host, AF_INET6);
 *	getipnodebyname(host, AF_INET);
 *   This will result in the following queries if the node is configure to
 *   prefer /etc/hosts than DNS:
 *	lookup /etc/hosts for IPv6 address
 *	lookup DNS for IPv6 address
 *	lookup /etc/hosts for IPv4 address
 *	lookup DNS for IPv4 address
 *   which may not meet people's requirement.
 *   The right thing to happen is to have underlying layer which does
 *   PF_UNSPEC lookup (lookup both) and return chain of addrinfos.
 *   This would result in a bit of code duplicate with _dns_ghbyname() and
 *   friends.
d98 9
d173 3
d185 19
d228 22
a314 1
	const struct afd *afd;
d317 1
a317 1
	sentinel.ai_next = NULL;
d402 4
d450 1
a450 1
	for (afd = afdl; afd->a_af; afd++) {
d453 2
a454 1
		if (!MATCH_FAMILY(pai->ai_family, afd->a_af, 1))
d457 8
a464 2
		for (ex = explore; ex->e_af >= 0; ex++) {
			*pai = ai0;
d466 4
a469 2
			if (pai->ai_family == PF_UNSPEC)
				pai->ai_family = afd->a_af;
d471 2
a472 10
			if (!MATCH_FAMILY(pai->ai_family, ex->e_af, WILD_AF(ex)))
				continue;
			if (!MATCH(pai->ai_socktype, ex->e_socktype,
					WILD_SOCKTYPE(ex))) {
				continue;
			}
			if (!MATCH(pai->ai_protocol, ex->e_protocol,
					WILD_PROTOCOL(ex))) {
				continue;
			}
d474 2
a475 13
			if (pai->ai_family == PF_UNSPEC)
				pai->ai_family = ex->e_af;
			if (pai->ai_socktype == ANY && ex->e_socktype != ANY)
				pai->ai_socktype = ex->e_socktype;
			if (pai->ai_protocol == ANY && ex->e_protocol != ANY)
				pai->ai_protocol = ex->e_protocol;

			error = explore_fqdn(pai, hostname, servname,
				&cur->ai_next);

			while (cur && cur->ai_next)
				cur = cur->ai_next;
		}
d510 4
a513 6
	struct hostent *hp;
	int h_error;
	int af;
	char **aplist = NULL, *apbuf = NULL;
	char *ap;
	struct addrinfo sentinel, *cur;
a514 3
	int naddrs;
	const struct afd *afd;
	int error = 0;
d516 1
a516 3
	*res = NULL;
	sentinel.ai_next = NULL;
	cur = &sentinel;
d533 7
a539 1
	afd = find_afd(pai->ai_family);
d541 5
a545 8
	hp = gethostbyname2(hostname, pai->ai_family);
	h_error = h_errno;

	if (hp == NULL) {
		switch (h_error) {
		case HOST_NOT_FOUND:
		case NO_DATA:
			error = EAI_NODATA;
d547 3
a549 2
		case TRY_AGAIN:
			error = EAI_AGAIN;
d551 2
a552 4
		case NO_RECOVERY:
		case NETDB_INTERNAL:
		default:
			error = EAI_FAIL;
a554 4
	} else if ((hp->h_name == NULL) || (hp->h_name[0] == 0)
			|| (hp->h_addr_list[0] == NULL)) {
		hp = NULL;
		error = EAI_FAIL;
d556 4
a559 22

	if (hp == NULL)
		goto free;

	/*
	 * hp will be overwritten if we use gethostbyname2().
	 * always deep copy for simplification.
	 */
	for (naddrs = 0; hp->h_addr_list[naddrs] != NULL; naddrs++)
		;
	naddrs++;
	aplist = (char **)malloc(sizeof(aplist[0]) * naddrs);
	apbuf = (char *)malloc((size_t)hp->h_length * naddrs);
	if (aplist == NULL || apbuf == NULL) {
		error = EAI_MEMORY;
		goto free;
	}
	memset(aplist, 0, sizeof(aplist[0]) * naddrs);
	for (i = 0; i < naddrs; i++) {
		if (hp->h_addr_list[i] == NULL) {
			aplist[i] = NULL;
			continue;
d561 2
a562 3
		memcpy(&apbuf[i * hp->h_length], hp->h_addr_list[i],
			(size_t)hp->h_length);
		aplist[i] = &apbuf[i * hp->h_length];
a564 33
	for (i = 0; aplist[i] != NULL; i++) {
		af = hp->h_addrtype;
		ap = aplist[i];
#ifdef INET6
		if (af == AF_INET6
		 && IN6_IS_ADDR_V4MAPPED((struct in6_addr *)ap)) {
			af = AF_INET;
			ap = ap + sizeof(struct in6_addr)
				- sizeof(struct in_addr);
		}
#endif

		if (af != pai->ai_family)
			continue;

		GET_AI(cur->ai_next, afd, ap);
		GET_PORT(cur->ai_next, servname);
		if ((pai->ai_flags & AI_CANONNAME) != 0) {
			/*
			 * RFC2553 says that ai_canonname will be set only for
			 * the first element.  we do it for all the elements,
			 * just for convenience.
			 */
			GET_CANONNAME(cur->ai_next, hp->h_name);
		}

		while (cur && cur->ai_next)
			cur = cur->ai_next;
	}

	*res = sentinel.ai_next;
	return 0;

d566 2
a567 6
	if (aplist)
		free(aplist);
	if (apbuf)
		free(apbuf);
	if (sentinel.ai_next)
		freeaddrinfo(sentinel.ai_next);
d987 796
@


1.13
log
@to synchronize with progress of discussion for post
draft-ietf-ipngwg-scopedaddr-format-00.txt (will be 01),
use "address%interface" notation for extended scoped IPv6 address.

NOTE: the change affects link-local addresses only.  I hope it to be
the final change on it.....
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.12 2000/02/16 12:53:35 itojun Exp $	*/
a575 4
#ifdef USE_GETIPNODEBY
	if (hp)
		freehostent(hp);
#endif
a949 3
#ifdef USE_GETIPNODEBY
	return 1;
#else
a957 1
#endif
@


1.12
log
@add more comments from recent kame.

prepare to swap extended scoped address notation.  fe80::1%de0 is the
most promised candidate, but since it is still very draft, i'm not sure
when to switch - if you have any idea please let me know.  in other words,
do i allowed to change it every week? :-P  (NOTE it is only for "extended"
scoped address notation, which is not for daily use)
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.11 2000/02/15 18:53:08 itojun Exp $	*/
d755 1
a755 1
#if 1
@


1.11
log
@make it possible to compile without -DINET6
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.10 2000/02/09 12:22:09 itojun Exp $	*/
d53 19
d545 1
a545 1
#ifdef AF_INET6
d738 1
a738 1
	char *cp, *hostname2 = NULL, *scope;
d755 1
d765 13
a777 1
	cp++;
d779 1
a779 1
	error = explore_numeric(pai, cp, servname, res);
@


1.10
log
@revise extended scoped address format support.  delimiter and the order
is changed, based on discussion in ipngwg scoped address cabal.
past code:	fe80::1@@de0
now:		de0%fe80::1
this will be in sync with next extended address format proposal
(which should be final - I don't want to make this kind of change again).
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.9 2000/01/26 06:51:26 itojun Exp $	*/
d713 1
a713 1
#ifndef SCOPE_DELIMITER
@


1.9
log
@fix RFC2553 conformance.  AI_CANONNAME does not mean reverse query.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.8 2000/01/18 10:20:00 itojun Exp $	*/
a32 2
 * "#ifdef FAITH" part is local hack for supporting IPv4-v6 translator.
 *
d38 7
a78 5
#ifdef FAITH
static int translate = NO;
static struct in6_addr faith_prefix = IN6ADDR_ANY_INIT;
#endif

d153 1
a153 1
static int explore_null __P((const struct addrinfo *, const char *,
d166 6
d183 1
a183 1
} while (0)
d191 1
a191 1
} while (0)
d199 1
a199 1
} while (0)
d206 1
a206 1
} while (0)
d209 1
a209 1
	((x) == (y) || ((w) && ((x) == PF_UNSPEC || (y) == PF_UNSPEC)))
d211 1
a211 1
	((x) == (y) || ((w) && ((x) == ANY || (y) == ANY)))
d217 1
a217 1
	char *q = (char *)p;
d219 1
a219 1
		if (! isdigit(*q))
a239 15
#ifndef AI_MASK
#define AI_MASK (AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST)
#endif

#ifdef FAITH
	static int firsttime = 1;

	if (firsttime) {
		/* translator hack */
		char *q = getenv("GAI");
		if (q && inet_pton(AF_INET6, q, &faith_prefix) == 1)
			translate = YES;
		firsttime = 0;
	}
#endif
d300 5
a304 2
	 || MATCH_FAMILY(pai->ai_family, PF_INET6, 1)) {
		ai0 = *pai;
d306 2
a307 1
		if (pai->ai_family == PF_UNSPEC)
d309 4
d341 1
a341 1
			error = explore_null(pai, hostname, servname, &cur->ai_next);
a446 1
#ifndef USE_GETIPNODEBY
a447 1
#endif
d449 1
a449 1
	int error;
d455 1
d457 2
a458 3
	 * Do not filter unsupported AFs here.  We need to honor content of
	 * databases (/etc/hosts, DNS and others).  Otherwise we cannot
	 * replace gethostbyname() by getaddrinfo().
d460 3
a471 8
	/*
	 * post-RFC2553: should look at (pai->ai_flags & AI_ADDRCONFIG)
	 * rather than hardcoding it.  we may need to add AI_ADDRCONFIG
	 * handling code by ourselves in case we don't have getipnodebyname().
	 */
#ifdef USE_GETIPNODEBY
	hp = getipnodebyname(hostname, pai->ai_family, AI_ADDRCONFIG, &h_error);
#else
a473 1
#endif
a491 3
#ifdef USE_GETIPNODEBY
		freehostent(hp);
#endif
a498 3
#ifdef USE_GETIPNODEBY
	aplist = hp->h_addr_list;
#else
d507 1
a507 1
	apbuf = (char *)malloc(hp->h_length * naddrs);
d519 1
a519 1
			hp->h_length);
a521 1
#endif
d526 1
d533 1
d576 1
a576 1
explore_null(pai, hostname, servname, res)
a577 1
	const char *hostname;
d664 27
a690 9
	if (inet_pton(afd->a_af, hostname, pton) == 1) {
		if (pai->ai_family == afd->a_af ||
		    pai->ai_family == PF_UNSPEC /*?*/) {
			GET_AI(cur->ai_next, afd, pton);
			GET_PORT(cur->ai_next, servname);
			while (cur && cur->ai_next)
				cur = cur->ai_next;
		} else 
			ERR(EAI_FAMILY);	/*xxx*/
d719 1
a719 2
	char *cp, *hostname2 = NULL;
	int scope;
d737 1
a737 1
	 * Handle special case of <scoped_address><delimiter><scope id>
d744 1
a744 1

a745 11
	switch (pai->ai_family) {
#ifdef INET6
	case AF_INET6:
		scope = if_nametoindex(cp);
		if (scope == 0) {
			free(hostname2);
			return (EAI_NONAME);
		}
		break;
#endif
	}
d747 1
a747 1
	error = explore_numeric(pai, hostname2, servname, res);
d749 2
d755 5
a759 3
			if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) ||
			    IN6_IS_ADDR_MC_LINKLOCAL(&sin6->sin6_addr))
				sin6->sin6_scope_id = scope;
d800 1
a800 1
	memset(ai->ai_addr, 0, afd->a_socklen);
d805 1
a805 1
	memcpy(p + afd->a_off, addr, afd->a_addrlen);
d832 7
a838 1
	if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)
d840 1
d910 67
@


1.8
log
@sync comment with code.  remove #if 0'ed portion (AF filtering on name
resolution) and add comment there.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.7 2000/01/17 15:58:11 itojun Exp $	*/
a158 2
static int get_name __P((const char *, const struct afd *, struct addrinfo **,
	char *, const struct addrinfo *, const char *));
d552 3
a554 4
		if ((pai->ai_flags & AI_CANONNAME) == 0) {
			GET_AI(cur->ai_next, afd, ap);
			GET_PORT(cur->ai_next, servname);
		} else {
d556 3
a558 8
			 * if AI_CANONNAME and if reverse lookup
			 * fail, return ai anyway to pacify
			 * calling application.
			 *
			 * XXX getaddrinfo() is a name->address
			 * translation function, and it looks
			 * strange that we do addr->name
			 * translation here.
d560 1
a560 2
			get_name(ap, afd, &cur->ai_next,
				ap, pai, servname);
a679 23
		u_int32_t v4a;
#ifdef INET6
		u_char pfx;
#endif

		switch (afd->a_af) {
		case AF_INET:
			v4a = (u_int32_t)ntohl(((struct in_addr *)pton)->s_addr);
			if (IN_MULTICAST(v4a) || IN_EXPERIMENTAL(v4a))
				flags &= ~AI_CANONNAME;
			v4a >>= IN_CLASSA_NSHIFT;
			if (v4a == 0 || v4a == IN_LOOPBACKNET)
				flags &= ~AI_CANONNAME;
			break;
#ifdef INET6
		case AF_INET6:
			pfx = ((struct in6_addr *)pton)->s6_addr[0];
			if (pfx == 0 || pfx == 0xfe || pfx == 0xff)
				flags &= ~AI_CANONNAME;
			break;
#endif
		}

d682 2
a683 17
			if ((flags & AI_CANONNAME) == 0) {
				GET_AI(cur->ai_next, afd, pton);
				GET_PORT(cur->ai_next, servname);
			} else {
				/*
				 * if AI_CANONNAME and if reverse lookup
				 * fail, return ai anyway to pacify
				 * calling application.
				 *
				 * XXX getaddrinfo() is a name->address
				 * translation function, and it looks
				 * strange that we do addr->name
				 * translation here.
				 */
				get_name(pton, afd, &cur->ai_next,
					pton, pai, servname);
			}
a771 69
}

static int
get_name(addr, afd, res, numaddr, pai, servname)
	const char *addr;
	const struct afd *afd;
	struct addrinfo **res;
	char *numaddr;
	const struct addrinfo *pai;
	const char *servname;
{
	struct hostent *hp = NULL;
	struct addrinfo *cur = NULL;
	int error = 0;
	char *ap = NULL, *cn = NULL;
#ifdef USE_GETIPNODEBY
	int h_error;

	hp = getipnodebyaddr(addr, afd->a_addrlen, afd->a_af, &h_error);
#else
	hp = gethostbyaddr(addr, afd->a_addrlen, afd->a_af);
#endif
	if (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {
#ifdef USE_GETIPNODEBY
		GET_AI(cur, afd, hp->h_addr_list[0]);
		GET_PORT(cur, servname);
		GET_CANONNAME(cur, hp->h_name);
#else
		/* hp will be damaged if we use gethostbyaddr() */
		if ((ap = (char *)malloc(hp->h_length)) == NULL) {
			error = EAI_MEMORY;
			goto free;
		}
		memcpy(ap, hp->h_addr_list[0], hp->h_length);
		if ((cn = strdup(hp->h_name)) == NULL) {
			error = EAI_MEMORY;
			goto free;
		}

		GET_AI(cur, afd, ap);
		GET_PORT(cur, servname);
		GET_CANONNAME(cur, cn);
		free(ap); ap = NULL;
		free(cn); cn = NULL;
#endif
	} else {
		GET_AI(cur, afd, numaddr);
		GET_PORT(cur, servname);
	}
	
#ifdef USE_GETIPNODEBY
	if (hp)
		freehostent(hp);
#endif
	*res = cur;
	return SUCCESS;
 free:
	if (cur)
		freeaddrinfo(cur);
	if (ap)
		free(ap);
	if (cn)
		free(cn);
#ifdef USE_GETIPNODEBY
	if (hp)
		freehostent(hp);
#endif
	*res = NULL;
	return error;
@


1.7
log
@do not filter address families that are not supported by kernel.
it was not a correct behavior.

even if we may be able to connect to the the returned addresses,
filtering them out is not a correct thing to do.  for example, even if
you have partial unreachablility in IPv4, gethostbyname(3) will return
IPv4 addresses in the unreachable network anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.6 2000/01/17 08:15:26 itojun Exp $	*/
d45 1
a45 1
 *   when resolving FQDNs and globbing NULL hostname.  Is it the right
a442 3
#if 0
	int s;
#endif
a459 1
#if 0
d461 3
a463 2
	 * filter out AFs that are not supported by the kernel
	 * XXX errno?
a464 7
	s = socket(pai->ai_family, SOCK_DGRAM, 0);
	if (s < 0) {
		if (errno != EMFILE)
			return 0;
	} else
		close(s);
#endif
@


1.6
log
@remove #if 0'ed part.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo.c,v 1.5 1999/12/30 08:54:20 itojun Exp $	*/
d443 1
d445 1
d463 1
d474 1
@


1.5
log
@replace NRL get{addr,name}info with KAME get{addr,name}info.

removed functionality:
	new code will not return AF_LOCAL addrinfo struct.
added funtionality:
	SOCK_RAW is permitted as ai_socktype (no servname allowed).
	draft-ietf-ipngwg-scopedaddr-format-00.txt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 6
#if 0
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif 
#else
#define HAVE_SOCKADDR_SA_LEN
a50 1
#endif
a53 3
#if 0
#include <sys/sysctl.h>
#endif
a68 22
#if 0
#ifndef HAVE_PORTABLE_PROTOTYPE
#include "cdecl_ext.h"
#endif 

#ifndef HAVE_U_INT32_T
#include "bittypes.h"
#endif 

#ifndef HAVE_SOCKADDR_STORAGE
#include "sockstorage.h"
#endif 

#ifndef HAVE_ADDRINFO
#include "addrinfo.h"
#endif

#if defined(__KAME__) && defined(INET6)
# define FAITH
#endif
#endif

a168 20
#if 0
static char *ai_errlist[] = {
	"Success",
	"Address family for hostname not supported",	/* EAI_ADDRFAMILY */
	"Temporary failure in name resolution",		/* EAI_AGAIN      */
	"Invalid value for ai_flags",		       	/* EAI_BADFLAGS   */
	"Non-recoverable failure in name resolution", 	/* EAI_FAIL       */
	"ai_family not supported",			/* EAI_FAMILY     */
	"Memory allocation failure", 			/* EAI_MEMORY     */
	"No address associated with hostname", 		/* EAI_NODATA     */
	"hostname nor servname provided, or not known",	/* EAI_NONAME     */
	"servname not supported for ai_socktype",	/* EAI_SERVICE    */
	"ai_socktype not supported", 			/* EAI_SOCKTYPE   */
	"System error returned in errno", 		/* EAI_SYSTEM     */
	"Invalid value for hints",			/* EAI_BADHINTS	  */
	"Resolved protocol is unknown",			/* EAI_PROTOCOL   */
	"Unknown error", 				/* EAI_MAX        */
};
#endif

a927 1
#ifdef HAVE_SOCKADDR_SA_LEN
a928 1
#endif
@


1.4
log
@fix DNS; all this is due for squishing in a few days anyways, i suspect; fujiwara@@rcac.tdi.co.jp
@
text
@d1 2
d4 3
a6 3
 * %%% copyright-cmetz-96-bsd
 * Copyright (c) 1996-1999, Craig Metz, All rights reserved.
 *
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Craig Metz and
 *      by other contributors.
 * 4. Neither the name of the author nor the names of contributors
d18 2
a19 2
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
d22 1
a22 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
d32 17
a48 1
/* getaddrinfo() v1.38 */
d50 8
a57 6
/*
   I'd like to thank Matti Aarnio for finding some bugs in this code and
   sending me patches, as well as everyone else who has contributed to this
   code (by reporting bugs, suggesting improvements, and commented on its
   behavior and proposed changes).
*/
d60 4
a63 2
#include <stdlib.h>
#include <unistd.h>
d65 1
a65 4
#include <string.h>
#include <stdio.h>
#include <sys/utsname.h>
#include <sys/un.h>
d68 1
d70 7
d79 40
a118 2
#define GAIH_OKIFUNSPEC	0x0100
#define GAIH_EAI	~(GAIH_OKIFUNSPEC)
d120 5
a124 2
static struct addrinfo nullreq = {
	0, PF_UNSPEC, 0, 0, 0, NULL, NULL, NULL
d127 20
a146 3
struct gaih_service {
	char   *name;
	int     num;
d149 9
a157 5
struct gaih_servtuple {
	struct gaih_servtuple *next;
	int     socktype;
	int     protocol;
	int     port;
d160 13
a172 2
static struct gaih_servtuple nullserv = {
	NULL, 0, 0, 0
d175 43
a217 5
struct gaih_addrtuple {
	struct gaih_addrtuple *next;
	int     family;
	char    addr[16];
	char   *cname;
d219 1
d221 1
a221 10
static struct gaih_typeproto {
	int     socktype;
	int     protocol;
	char   *name;
} gaih_inet_typeproto[] = {
	{ 0, 0, NULL },
	{ SOCK_STREAM, IPPROTO_TCP, "tcp" },
	{ SOCK_DGRAM, IPPROTO_UDP, "udp" },
	{ 0, 0, NULL }
};
d223 50
a272 7
static int 
netdb_lookup_addr(const char *name, int af,
    const struct addrinfo *req, struct gaih_addrtuple **pat)
{
	int     rval = 0, herrno, i;
	char   *prevcname = NULL;
	struct hostent *h;
d274 29
a302 2
	h = gethostbyname2(name, af);
	herrno = h_errno;
d304 28
a331 12
	if (!h) {
		switch (herrno) {
		case NETDB_INTERNAL:
			return -EAI_SYSTEM;
		case HOST_NOT_FOUND:
			return 1;
		case TRY_AGAIN:
			return -EAI_AGAIN;
		case NO_RECOVERY:
			return -EAI_FAIL;
		case NO_DATA:
			return 1;
d333 127
a459 1
			return -EAI_FAIL;
d463 60
a522 3
	for (i = 0; h->h_addr_list[i]; i++) {
		while (*pat)
			pat = &((*pat)->next);
d524 19
a542 3
		if (!(*pat = malloc(sizeof(struct gaih_addrtuple))))
			return -EAI_MEMORY;
		memset(*pat, 0, sizeof(struct gaih_addrtuple));
d544 5
a548 4
		switch ((*pat)->family = af) {
		case AF_INET:
			memcpy((*pat)->addr, h->h_addr_list[i],
			    sizeof(struct in_addr));
d550 2
a551 3
		case AF_INET6:
			memcpy((*pat)->addr, h->h_addr_list[i],
			    sizeof(struct in6_addr));
d553 2
d556 2
a557 1
			return -EAI_FAIL;
d559 8
d568 24
a591 5
		if (req->ai_flags & AI_CANONNAME) {
			if (prevcname && !strcmp(prevcname, h->h_name))
				(*pat)->cname = prevcname;
			else
				prevcname = (*pat)->cname = strdup(h->h_name);
d593 3
a595 1
		pat = &((*pat)->next);
d597 11
a607 2
	return rval;
}
d609 2
a610 8
static int 
gaih_local(const char *name, const struct gaih_service *service,
    const struct addrinfo *req, struct addrinfo **pai)
{
	struct utsname utsname;
	struct addrinfo *ai;
	struct sockaddr_un *sun;
	int siz;
d612 3
a614 37
	if (name || (req->ai_flags & AI_CANONNAME))
		if (uname(&utsname) < 0)
			return (-EAI_SYSTEM);

	if (name && strcmp(name, "localhost") && strcmp(name, "local") &&
	    strcmp(name, "unix") && strcmp(name, utsname.nodename))
		return (GAIH_OKIFUNSPEC | -EAI_NONAME);

	siz = sizeof(struct addrinfo) + sizeof(struct sockaddr_un);
	if (req->ai_flags & AI_CANONNAME)
		siz += strlen(utsname.nodename) + 1;

	if (!(ai = malloc(siz)))
		return -EAI_MEMORY;

	*pai = ai;
	ai->ai_next = NULL;
	ai->ai_flags = req->ai_flags;
	ai->ai_family = AF_LOCAL;
	ai->ai_socktype = req->ai_socktype ? req->ai_socktype : SOCK_STREAM;
	ai->ai_protocol = req->ai_protocol;
	ai->ai_addrlen = sizeof(struct sockaddr_un);
	ai->ai_addr = (void *)ai + sizeof(struct addrinfo);

	sun = (struct sockaddr_un *)ai->ai_addr;
	sun->sun_len = sizeof(struct sockaddr_un);
	sun->sun_family = AF_LOCAL;
	memset(&sun->sun_path, 0, sizeof sun->sun_path);

	if (service) {
		char   *c;

		c = strchr(service->name, '/');
		if (c) {
			if (strlen(service->name) >= sizeof(sun->sun_path))
				return (GAIH_OKIFUNSPEC | -EAI_SERVICE);
			strlcpy(sun->sun_path, service->name, sizeof (sun->sun_path));
d616 12
a627 5
			if (strlen(P_tmpdir "/") + strlen(service->name) + 1 >=
			    sizeof(sun->sun_path))
				return(GAIH_OKIFUNSPEC | -EAI_SERVICE);
			snprintf(sun->sun_path, sizeof(sun->sun_path), "%s/%s",
			    P_tmpdir, service->name);
a628 3
	} else {
		extern char *_mktemp __P((char *));
		char	tmpn[MAXPATHLEN], *c;
d630 2
a631 4
		snprintf(tmpn, sizeof tmpn, "%stmp.XXXXXXXXXXXXX", P_tmpdir);
		if (!(c = _mktemp(tmpn)))
			return (GAIH_OKIFUNSPEC | -EAI_SYSTEM);
		strlcpy(sun->sun_path, c, sizeof(sun->sun_path));
d634 1
a634 6
	ai->ai_canonname = NULL;
	if (req->ai_flags & AI_CANONNAME) {
		ai->ai_canonname = (void *)sun + sizeof(struct sockaddr_un);
		strlcpy(ai->ai_canonname, utsname.nodename,
		    strlen(utsname.nodename)+1);
	}
d636 13
d651 47
a697 65
static int 
gaih_inet_serv(char *servicename, struct gaih_typeproto *tp,
    struct gaih_servtuple **st)
{
	struct servent *s;

	s = getservbyname(servicename, tp->name);
	if (!s)
		return (GAIH_OKIFUNSPEC | -EAI_SERVICE);

	if (!(*st = malloc(sizeof(struct gaih_servtuple))))
		return (-EAI_MEMORY);

	(*st)->next = NULL;
	(*st)->socktype = tp->socktype;
	(*st)->protocol = tp->protocol;
	(*st)->port = s->s_port;
	return (0);
}

static int 
gaih_inet(const char *name, const struct gaih_service *service,
    const struct addrinfo*req, struct addrinfo **pai)
{
	struct gaih_typeproto *tp = gaih_inet_typeproto;
	struct gaih_servtuple *st = &nullserv;
	struct gaih_addrtuple *at = NULL;
	char   *prevcname = NULL;
	struct gaih_servtuple *st2;
	struct gaih_addrtuple *at2 = at;
	struct addrinfo *ai = NULL;
	int     canonlen, addrlen, rval = 0;

	if (req->ai_protocol || req->ai_socktype) {
		for (tp++; tp->name &&
		    ((req->ai_socktype != tp->socktype) || !req->ai_socktype) &&
		    ((req->ai_protocol != tp->protocol) || !req->ai_protocol); tp++);
		if (!tp->name) {
			rval = GAIH_OKIFUNSPEC | -EAI_SERVICE;
			if (req->ai_socktype)
				rval = GAIH_OKIFUNSPEC | -EAI_SOCKTYPE;
			goto ret;
		}
	}
	if (service && (service->num < 0)) {
		if (tp->name) {
			rval = gaih_inet_serv(service->name, tp, &st);
			if (rval)
				goto ret;
		} else {
			struct gaih_servtuple **pst = &st;
			for (tp++; tp->name; tp++) {
				rval = gaih_inet_serv(service->name, tp, pst);
				if (rval) {
					if (rval & GAIH_OKIFUNSPEC)
						continue;
					goto ret;
				}
				pst = &((*pst)->next);
			}
			if (st == &nullserv) {
				rval = GAIH_OKIFUNSPEC | -EAI_SERVICE;
				goto ret;
			}
		}
d699 5
a703 12
		if (!(st = malloc(sizeof(struct gaih_servtuple)))) {
			rval = -EAI_MEMORY;
			goto ret;
		}

		st->next = NULL;
		st->socktype = tp->socktype;
		st->protocol = tp->protocol;
		if (service)
			st->port = htons(service->num);
		else
			st->port = 0;
d705 1
d707 2
a708 5
	if (!name) {
		if (!(at = malloc(sizeof(struct gaih_addrtuple)))) {
			rval = -EAI_MEMORY;
			goto ret;
		}
d710 5
a714 1
		memset(at, 0, sizeof(struct gaih_addrtuple));
d716 35
a750 7
		if (req->ai_family)
			at->family = req->ai_family;
		else {
			if (!(at->next = malloc(sizeof(struct gaih_addrtuple)))) {
				rval = -EAI_MEMORY;
				goto ret;
			}
d752 16
a767 4
			at->family = AF_INET6;

			memset(at->next, 0, sizeof(struct gaih_addrtuple));
			at->next->family = AF_INET;
d770 23
a792 1
		goto build;
d795 9
a803 7
	if (!req->ai_family || (req->ai_family == AF_INET)) {
		struct in_addr in_addr;
		if (inet_pton(AF_INET, name, &in_addr) > 0) {
			if (!(at = malloc(sizeof(struct gaih_addrtuple)))) {
				rval = -EAI_MEMORY;
				goto ret;
			}
d805 55
a859 1
			memset(at, 0, sizeof(struct gaih_addrtuple));
d861 9
a869 3
			at->family = AF_INET;
			memcpy(at->addr, &in_addr, sizeof(struct in_addr));
			goto build;
d873 1
a873 7
	if (!req->ai_family || (req->ai_family == AF_INET6)) {
		struct in6_addr in6_addr;
		if (inet_pton(AF_INET6, name, &in6_addr) > 0) {
			if (!(at = malloc(sizeof(struct gaih_addrtuple)))) {
				rval = -EAI_MEMORY;
				goto ret;
			}
d875 3
a877 1
			memset(at, 0, sizeof(struct gaih_addrtuple));
d879 35
a913 3
			at->family = AF_INET6;
			memcpy(at->addr, &in6_addr, sizeof(struct in6_addr));
			goto build;
d915 10
d926 21
d948 14
a961 30
	if (!(req->ai_flags & AI_NUMERICHOST)) {
		if (!req->ai_family || (req->ai_family == AF_INET6))
			if ((rval = netdb_lookup_addr(name, AF_INET6, req, &at)) < 0)
				goto ret;
		if (!req->ai_family || (req->ai_family == AF_INET))
			if ((rval = netdb_lookup_addr(name, AF_INET, req, &at)) < 0)
				goto ret;

		if (!rval)
			goto build;
	}

	if (!at) {
		rval = GAIH_OKIFUNSPEC | -EAI_NONAME;
		goto ret;
	}

build:
	at2 = at;
	while (at2) {
		if (req->ai_flags & AI_CANONNAME) {
			if (at2->cname)
				canonlen = strlen(at2->cname) + 1;
			else
				if (name)
					canonlen = strlen(name) + 1;
				else
					canonlen = 2;
		} else
			canonlen = 0;
d963 8
a970 4
		if (at2->family == AF_INET6)
			addrlen = sizeof(struct sockaddr_in6);
		else
			addrlen = sizeof(struct sockaddr_in);
d972 17
a988 7
		st2 = st;
		while (st2) {
			if (!(ai = malloc(sizeof(struct addrinfo) +
			    addrlen + canonlen))) {
				rval = -EAI_MEMORY;
				goto ret;
			}
d990 5
a994 2
			*pai = ai;
			memset(ai, 0, sizeof(struct addrinfo) + addrlen + canonlen);
d996 3
a998 29
			ai->ai_flags = req->ai_flags;
			ai->ai_family = at2->family;
			ai->ai_socktype = st2->socktype;
			ai->ai_protocol = st2->protocol;
			ai->ai_addrlen = addrlen;
			ai->ai_addr = (void *)ai + sizeof(struct addrinfo);
			ai->ai_addr->sa_len = addrlen;
			ai->ai_addr->sa_family = at2->family;

			switch (at2->family) {
			case AF_INET6:
			    {
				struct sockaddr_in6 *sin6 = (void *)ai->ai_addr;

				memcpy(&sin6->sin6_addr, at2->addr,
				    sizeof(sin6->sin6_addr));
				sin6->sin6_port = st2->port;
				break;
			    }
			default:
			    {
				struct sockaddr_in *sin = (void *)ai->ai_addr;

				memcpy(&sin->sin_addr, at2->addr,
				    sizeof(sin->sin_addr));
				sin->sin_port = st2->port;
				break;
			    }
			}
d1000 29
a1028 2
			if (canonlen) {
				ai->ai_canonname = (void *) ai->ai_addr + addrlen;
d1030 17
a1046 12
				if (at2->cname) {
					strcpy(ai->ai_canonname, at2->cname);
					if (prevcname != at2->cname) {
						if (prevcname)
							free(prevcname);
						prevcname = at2->cname;
					}
				} else
					strcpy(ai->ai_canonname, name ? name : "*");
			}
			pai = &(ai->ai_next);
			st2 = st2->next;
d1048 4
a1051 1
		at2 = at2->next;
a1052 1
	rval = 0;
d1054 10
a1063 90
ret:
	if (st != &nullserv) {
		struct gaih_servtuple *st2 = st;
		while (st) {
			st2 = st->next;
			free(st);
			st = st2;
		}
	}
	if (at) {
		struct gaih_addrtuple *at2 = at;
		while (at) {
			at2 = at->next;
			free(at);
			at = at2;
		}
	}
	return rval;
}

static struct gaih {
	int     family;
	char   *name;
	int     (*gaih) __P((const char *name,
		    const struct gaih_service *service,
	            const struct addrinfo *req, struct addrinfo **pai));
} gaih[] = {
	{ PF_INET6, "inet6", gaih_inet },
	{ PF_INET, "inet", gaih_inet },
	{ PF_LOCAL, "local", gaih_local },
	{ -1, NULL, NULL}
};

int 
getaddrinfo(const char *name, const char *service,
    const struct addrinfo *req, struct addrinfo **pai)
{
	int     rval = EAI_SYSTEM;	/* XXX */
	int     j = 0;
	struct addrinfo *p = NULL, **end;
	struct gaih *g = gaih, *pg = NULL;
	struct gaih_service gaih_service, *pservice;

	if (name && (name[0] == '*') && !name[1])
		name = NULL;

	if (service && service[0] == '*' && service[1] == '\0')
		service = NULL;

	if (!req)
		req = &nullreq;

	if (req->ai_flags & ~(AI_CANONNAME | AI_PASSIVE | AI_NUMERICHOST | AI_EXT))
		return (EAI_BADFLAGS);

	if (service && *service) {
		char   *c;

		gaih_service.num = strtoul(service, &c, 10);
		if (*c)
			gaih_service.num = -1;
		gaih_service.name = (void *)service;
		pservice = &gaih_service;
	} else
		pservice = NULL;

	if (pai)
		end = &p;
	else
		end = NULL;

	while (g->gaih) {
		if ((req->ai_family == g->family) || !req->ai_family) {
			j++;
			if (!((pg && (pg->gaih == g->gaih)))) {
				pg = g;
				rval = g->gaih(name, pservice, req, end);
				if (rval) {
					if (!req->ai_family && (rval & GAIH_OKIFUNSPEC))
						continue;

					if (p)
						freeaddrinfo(p);

					return -(rval & GAIH_EAI);
				}
				if (end)
					while (*end)
						end = &((*end)->ai_next);
			}
a1064 1
		g++;
d1067 8
a1074 2
	if (!j)
		return (EAI_FAMILY);
d1076 5
a1080 3
	if (p) {
		*pai = p;
		return (0);
d1082 1
a1082 3
	if (!pai && !rval)
		return (0);
	return EAI_NONAME;
@


1.3
log
@cleaned up
@
text
@d384 1
@


1.2
log
@Removed portability ifdefs.
@
text
@d4 1
a4 1
 * 
d20 1
a20 1
 * 
a31 1
 *
d52 1
d56 2
a57 9
#ifndef AF_LOCAL
#define AF_LOCAL AF_UNIX
#endif /* AF_LOCAL */
#ifndef PF_LOCAL
#define PF_LOCAL PF_UNIX
#endif /* PF_LOCAL */
#ifndef UNIX_PATH_MAX
#define UNIX_PATH_MAX 108
#endif /* UNIX_PATH_MAX */
d59 3
a61 5
#define GAIH_OKIFUNSPEC 0x0100
#define GAIH_EAI        ~(GAIH_OKIFUNSPEC)

static struct addrinfo nullreq =
{ 0, PF_UNSPEC, 0, 0, 0, NULL, NULL, NULL };
d64 2
a65 2
  char *name;
  int num;
d69 4
a72 4
  struct gaih_servtuple *next;
  int socktype;
  int protocol;
  int port;
d76 1
a76 1
  NULL, 0, 0, 0
d80 4
a83 4
  struct gaih_addrtuple *next;
  int family;
  char addr[16];
  char *cname;
d86 9
a94 4
struct gaih_typeproto {
  int socktype;
  int protocol;
  char *name;
d97 3
a99 6
#define RETURN_ERROR(x) do { \
    rval = (x); \
    goto ret; \
    } while(0)

static int netdb_lookup_addr(const char *name, int af, const struct addrinfo *req, struct gaih_addrtuple **pat)
d101 23
a123 53
  int rval, herrno, i;
  char *prevcname = NULL;
  struct hostent *h;

  h = gethostbyname2(name, af);
  herrno = h_errno;

  if (!h) {
    switch(herrno) {
      case NETDB_INTERNAL:
	RETURN_ERROR(-EAI_SYSTEM);
      case HOST_NOT_FOUND:
	RETURN_ERROR(1);
      case TRY_AGAIN:
	RETURN_ERROR(-EAI_AGAIN);
      case NO_RECOVERY:
	RETURN_ERROR(-EAI_FAIL);
      case NO_DATA:
	RETURN_ERROR(1);
      default:
	RETURN_ERROR(-EAI_FAIL);
    };
  };

  for (i = 0; h->h_addr_list[i]; i++) {
    while(*pat)
      pat = &((*pat)->next);

    if (!(*pat = malloc(sizeof(struct gaih_addrtuple))))
      RETURN_ERROR(-EAI_MEMORY);

    memset(*pat, 0, sizeof(struct gaih_addrtuple));

    switch((*pat)->family = af) {
      case AF_INET:
	memcpy((*pat)->addr, h->h_addr_list[i], sizeof(struct in_addr));
	break;
      case AF_INET6:
	memcpy((*pat)->addr, h->h_addr_list[i], sizeof(struct in6_addr));
	break;
      default:
	RETURN_ERROR(-EAI_FAIL);
    };

    if (req->ai_flags & AI_CANONNAME) {
      if (prevcname && !strcmp(prevcname, h->h_name))
	(*pat)->cname = prevcname;
      else
	prevcname = (*pat)->cname = strdup(h->h_name);
    };
    
    pat = &((*pat)->next);
  }
d125 31
a155 5
  rval = 0;

ret:
  return rval;
};
d157 3
a159 2
static int gaih_local(const char *name, const struct gaih_service *service,
		     const struct addrinfo *req, struct addrinfo **pai)
d161 58
a218 2
  int rval;
  struct utsname utsname;
d220 8
a227 46
  if (name || (req->ai_flags & AI_CANONNAME))
    if (uname(&utsname) < 0)
      RETURN_ERROR(-EAI_SYSTEM);
  if (name) {
    if (strcmp(name, "localhost") && strcmp(name, "local") && strcmp(name, "unix") && strcmp(name, utsname.nodename))
      RETURN_ERROR(GAIH_OKIFUNSPEC | -EAI_NONAME);
  };

  if (!(*pai = malloc(sizeof(struct addrinfo) + sizeof(struct sockaddr_un) + ((req->ai_flags & AI_CANONNAME) ? (strlen(utsname.nodename) + 1): 0))))
    RETURN_ERROR(-EAI_MEMORY);

  (*pai)->ai_next = NULL;
  (*pai)->ai_flags = req->ai_flags;
  (*pai)->ai_family = AF_LOCAL;
  (*pai)->ai_socktype = req->ai_socktype ? req->ai_socktype : SOCK_STREAM;
  (*pai)->ai_protocol = req->ai_protocol;
  (*pai)->ai_addrlen = sizeof(struct sockaddr_un);
  (*pai)->ai_addr = (void *)(*pai) + sizeof(struct addrinfo);
  ((struct sockaddr_un *)(*pai)->ai_addr)->sun_len = sizeof(struct sockaddr_un);
  ((struct sockaddr_un *)(*pai)->ai_addr)->sun_family = AF_LOCAL;
  memset(((struct sockaddr_un *)(*pai)->ai_addr)->sun_path, 0, UNIX_PATH_MAX);
  if (service) {
    char *c;
    if (c = strchr(service->name, '/')) {
      if (strlen(service->name) >= sizeof(((struct sockaddr_un *)(*pai)->ai_addr)->sun_path))
        RETURN_ERROR(GAIH_OKIFUNSPEC | -EAI_SERVICE);
      strcpy(((struct sockaddr_un *)(*pai)->ai_addr)->sun_path, service->name);
    } else {
      if (strlen(P_tmpdir "/") + 1 + strlen(service->name) >= sizeof(((struct sockaddr_un *)(*pai)->ai_addr)->sun_path))
        RETURN_ERROR(GAIH_OKIFUNSPEC | -EAI_SERVICE);
      strcpy(((struct sockaddr_un *)(*pai)->ai_addr)->sun_path, P_tmpdir "/");
      strcat(((struct sockaddr_un *)(*pai)->ai_addr)->sun_path, service->name);
    };
  } else {
    char *c;
    if (!(c = tmpnam(NULL)))
      RETURN_ERROR(GAIH_OKIFUNSPEC | -EAI_SYSTEM);

    strncpy((((struct sockaddr_un *)(*pai)->ai_addr)->sun_path), c, sizeof(((struct sockaddr_un *)(*pai)->ai_addr)->sun_path) - 1);
    c[sizeof(((struct sockaddr_un *)(*pai)->ai_addr)->sun_path) - 1] = 0;
  };
  if (req->ai_flags & AI_CANONNAME) {
    strncpy((*pai)->ai_canonname = (char *)(*pai) + sizeof(struct addrinfo) + sizeof(struct sockaddr_un), utsname.nodename, sizeof(utsname.nodename) - 1);
    (*pai)->ai_canonname[sizeof(utsname.nodename) - 1] = 0;
  } else
    (*pai)->ai_canonname = NULL;
d229 5
a233 1
  rval = 0;
d235 13
a247 3
ret:
  return rval;
};
d249 3
a251 8
static struct gaih_typeproto gaih_inet_typeproto[] = {
  { 0, 0, NULL },
  { SOCK_STREAM, IPPROTO_TCP, "tcp" },
  { SOCK_DGRAM, IPPROTO_UDP, "udp" },
  { 0, 0, NULL }
};

static int gaih_inet_serv(char *servicename, struct gaih_typeproto *tp, struct gaih_servtuple **st)
d253 55
a307 2
  int rval;
  struct servent *s;
d309 21
a329 2
  if (!(s = getservbyname(servicename, tp->name)))
    RETURN_ERROR(GAIH_OKIFUNSPEC | -EAI_SERVICE);
d331 2
a332 2
  if (!(*st = malloc(sizeof(struct gaih_servtuple))))
    RETURN_ERROR(-EAI_MEMORY);
d334 15
a348 4
  (*st)->next = NULL;
  (*st)->socktype = tp->socktype;
  (*st)->protocol = tp->protocol;
  (*st)->port = s->s_port;
d350 15
a364 1
  rval = 0;
d366 7
a372 3
ret:
  return rval;
}
d374 3
a376 111
static int gaih_inet(const char *name, const struct gaih_service *service,
		     const struct addrinfo *req, struct addrinfo **pai)
{
  int rval;
  struct hostent *h = NULL;
  struct gaih_typeproto *tp = gaih_inet_typeproto;
  struct gaih_servtuple *st = &nullserv;
  struct gaih_addrtuple *at = NULL;
  int i;

  if (req->ai_protocol || req->ai_socktype) {
    for (tp++; tp->name &&
	  ((req->ai_socktype != tp->socktype) || !req->ai_socktype) && 
	  ((req->ai_protocol != tp->protocol) || !req->ai_protocol); tp++);
    if (!tp->name)
      if (req->ai_socktype)
	RETURN_ERROR(GAIH_OKIFUNSPEC | -EAI_SOCKTYPE);
      else
	RETURN_ERROR(GAIH_OKIFUNSPEC | -EAI_SERVICE);
  }

  if (service && (service->num < 0)) {
    if (tp->name) {
      if (rval = gaih_inet_serv(service->name, tp, &st))
	goto ret;
    } else {
      struct gaih_servtuple **pst = &st;
      for (tp++; tp->name; tp++) {
	if (rval = gaih_inet_serv(service->name, tp, pst)) {
	  if (rval & GAIH_OKIFUNSPEC)
	    continue;
	  goto ret;
	};
	pst = &((*pst)->next);
      };
      if (st == &nullserv)
	RETURN_ERROR(GAIH_OKIFUNSPEC | -EAI_SERVICE);
    };
  } else {
    if (!(st = malloc(sizeof(struct gaih_servtuple))))
      RETURN_ERROR(-EAI_MEMORY);

    st->next = NULL;
    st->socktype = tp->socktype;
    st->protocol = tp->protocol;
    if (service)
      st->port = htons(service->num);
    else
      st->port = 0;
  };

  if (!name) {
    if (!(at = malloc(sizeof(struct gaih_addrtuple))))
      RETURN_ERROR(-EAI_MEMORY);

    memset(at, 0, sizeof(struct gaih_addrtuple));

    if (req->ai_family)
      at->family = req->ai_family;
    else {
      if (!(at->next = malloc(sizeof(struct gaih_addrtuple))))
	RETURN_ERROR(-EAI_MEMORY);

      at->family = AF_INET6;

      memset(at->next, 0, sizeof(struct gaih_addrtuple));
      at->next->family = AF_INET;
    };

    goto build;
  };

  if (!req->ai_family || (req->ai_family == AF_INET)) {
    struct in_addr in_addr;
    if (inet_pton(AF_INET, name, &in_addr) > 0) {
      if (!(at = malloc(sizeof(struct gaih_addrtuple))))
	RETURN_ERROR(-EAI_MEMORY);
      
      memset(at, 0, sizeof(struct gaih_addrtuple));
      
      at->family = AF_INET;
      memcpy(at->addr, &in_addr, sizeof(struct in_addr));
      goto build;
    };
  };

  if (!req->ai_family || (req->ai_family == AF_INET6)) {
    struct in6_addr in6_addr;
    if (inet_pton(AF_INET6, name, &in6_addr) > 0) {
      if (!(at = malloc(sizeof(struct gaih_addrtuple))))
	RETURN_ERROR(-EAI_MEMORY);
      
      memset(at, 0, sizeof(struct gaih_addrtuple));
      
      at->family = AF_INET6;
      memcpy(at->addr, &in6_addr, sizeof(struct in6_addr));
      goto build;
    };
  };

  if (!(req->ai_flags & AI_NUMERICHOST)) {
    if (!req->ai_family || (req->ai_family == AF_INET6))
      if ((rval = netdb_lookup_addr(name, AF_INET6, req, &at)) < 0)
	goto ret;
    if (!req->ai_family || (req->ai_family == AF_INET))
      if ((rval = netdb_lookup_addr(name, AF_INET, req, &at)) < 0)
	goto ret;

    if (!rval)
      goto build;
  };
d378 4
a381 2
  if (!at)
    RETURN_ERROR(GAIH_OKIFUNSPEC | -EAI_NONAME);
d384 77
a460 67
  {
    char *prevcname = NULL;
    struct gaih_servtuple *st2;
    struct gaih_addrtuple *at2 = at;
    int j;

    while(at2) {
      if (req->ai_flags & AI_CANONNAME) {
	if (at2->cname)
	  j = strlen(at2->cname) + 1;
	else
	  if (name)
	    j = strlen(name) + 1;
	  else
	    j = 2;
      } else
	j = 0;

      if (at2->family == AF_INET6)
	i = sizeof(struct sockaddr_in6);
      else
	i = sizeof(struct sockaddr_in);

      st2 = st;
      while(st2) {
	if (!(*pai = malloc(sizeof(struct addrinfo) + i + j)))
	  RETURN_ERROR(-EAI_MEMORY);

	memset(*pai, 0, sizeof(struct addrinfo) + i + j);

	(*pai)->ai_flags = req->ai_flags;
	(*pai)->ai_family = at2->family;
	(*pai)->ai_socktype = st2->socktype;
	(*pai)->ai_protocol = st2->protocol;
	(*pai)->ai_addrlen = i;
	(*pai)->ai_addr = (void *)(*pai) + sizeof(struct addrinfo);
	((struct sockaddr_in *)(*pai)->ai_addr)->sin_len = i;
	((struct sockaddr_in *)(*pai)->ai_addr)->sin_family = at2->family;
	((struct sockaddr_in *)(*pai)->ai_addr)->sin_port = st2->port;

	if (at2->family == AF_INET6)
	  memcpy(&((struct sockaddr_in6 *)(*pai)->ai_addr)->sin6_addr, at2->addr, sizeof(struct in6_addr));
	else
	  memcpy(&((struct sockaddr_in *)(*pai)->ai_addr)->sin_addr, at2->addr, sizeof(struct in_addr));

	if (j) {
	  (*pai)->ai_canonname = (void *)(*pai) + sizeof(struct addrinfo) + i;
	  if (at2->cname) {
	    strcpy((*pai)->ai_canonname, at2->cname);
	    if (prevcname != at2->cname) {
	      if (prevcname)
		free(prevcname);
	      prevcname = at2->cname;
	    };
	  } else
	    strcpy((*pai)->ai_canonname, name ? name : "*");
	};

	pai = &((*pai)->ai_next);

	st2 = st2->next;
      };
      at2 = at2->next;
    };
  };

  rval = 0;
d463 17
a479 18
  if (st != &nullserv) {
    struct gaih_servtuple *st2 = st;
    while(st) {
      st2 = st->next;
      free(st);
      st = st2;
    }
  }
  if (at) {
    struct gaih_addrtuple *at2 = at;
    while(at) {
      at2 = at->next;
      free(at);
      at = at2;
    }
  }

  return rval;
d482 11
a492 5
struct gaih {
  int family;
  char *name;
  int (*gaih)(const char *name, const struct gaih_service *service,
	      const struct addrinfo *req, struct addrinfo **pai);
d495 37
a531 6
static struct gaih gaih[] = {
  { PF_INET6, "inet6", gaih_inet },
  { PF_INET, "inet", gaih_inet },
  { PF_LOCAL, "local", gaih_local },
  { -1, NULL, NULL }
};
d533 22
a554 72
int getaddrinfo(const char *name, const char *service,
		const struct addrinfo *req, struct addrinfo **pai)
{
  int rval = EAI_SYSTEM; /* XXX */
  int i, j = 0;
  struct addrinfo *p = NULL, **end;
  struct gaih *g = gaih, *pg = NULL;
  struct gaih_service gaih_service, *pservice;

  if (name && (name[0] == '*') && !name[1])
    name = NULL;

  if (service && (service[0] == '*') && !service[1])
    service = NULL;

  if (!req)
    req = &nullreq;

  if (req->ai_flags & ~(AI_CANONNAME | AI_PASSIVE | AI_NUMERICHOST | AI_EXT))
    RETURN_ERROR(EAI_BADFLAGS);

  if (service && *service) {
    char *c;
    gaih_service.num = strtoul(gaih_service.name = (void *)service, &c, 10);
    if (*c) {
      gaih_service.num = -1;
    }

    pservice = &gaih_service;
  } else
    pservice = NULL;

  if (pai)
    end = &p;
  else
    end = NULL;

  while(g->gaih) {
    if ((req->ai_family == g->family) || !req->ai_family) {
      j++;
      if (!((pg && (pg->gaih == g->gaih)))) {
	pg = g;
	if (rval = g->gaih(name, pservice, req, end)) {
	  if (!req->ai_family && (rval & GAIH_OKIFUNSPEC))
	    continue;

	  if (p)
	    freeaddrinfo(p);

	  rval = -(rval & GAIH_EAI);
	  goto ret;
	}
	if (end)
          while(*end) end = &((*end)->ai_next);
      }
    }
    g++;
  }

  if (!j)
    RETURN_ERROR(EAI_FAMILY);

  if (p) {
    *pai = p;
    rval = 0;
    goto ret;
  }

  if (!pai && !rval) {
    rval = 0;
    goto ret;
  };
d556 2
a557 1
  RETURN_ERROR(EAI_NONAME);
d559 7
a565 2
ret:
  return rval;
a566 1

@


1.1
log
@Added some protocol independent interfaces (supposedly IPv6 support APIs, but
ones that are useful for all protocols, not just IPv6).
@
text
@a32 28
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Craig Metz and
 *      by other contributors.
 * 4. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
a43 48
/*
   Someone merged an earlier version of this code into the GNU libc and
   added support for getservbyname_r and gethostbyname2_r. The support for
   those functions in this version of the code was written using that work
   as a reference. I may have improved on it, or I may have broken it.
*/

/* To do what POSIX says, even when it's broken, define: */
/* #define BROKEN_LIKE_POSIX 1 */
/* Note: real apps will break if you define this, while nothing other than a
   conformance test suite should have a problem with it undefined. */

/* If your C runtime library provides the POSIX p1003.1g D6.6 bit types
   of the form u?int(16|32)_t, define: */
/* #define HAVE_POSIX1G_TYPES 1 */
/* Note: this implementation tries to guess what the correct values are for
   your compiler+processor combination but might not always get it right. */

/* To enable debugging support (REQUIRES NRL support library), define: */
/* #define DEBUG 1 */

#if FOR_GNULIBC
#define HAVE_POSIX1G_TYPES 1
#define INET6 1
#define LOCAL 1
#define NETDB 1
#undef RESOLVER
#undef HOSTTABLE
#undef DEBUG
#define HAVE_GETSERVBYNAME_R 1
#define HAVE_GETHOSTBYNAME2_R 1
#define getservbyname_r __getservbyname_r
#define gethostbyname2_r __gethostbyname2_r
#endif /* FOR_GNULIBC */

#ifdef __OpenBSD__
#define HAVE_POSIX1G_TYPES 1
#define INET6 1
#define LOCAL 1
#define NETDB 1
#define SALEN 1
#undef RESOLVER
#undef HOSTTABLE
#undef DEBUG
#undef HAVE_GETSERVBYNAME_R
#undef HAVE_GETHOSTBYNAME2_R
#endif /* __OpenBSD__ */

a48 1
#if LOCAL
a51 1
#endif /* LOCAL */
a54 7
#if RESOLVER
#include <arpa/nameser.h>
#include <resolv.h>
#endif /* RESOLVER */
#if DEBUG
#include <syslog.h>
#endif /* DEBUG */
a65 41
#if !HAVE_POSIX1G_TYPES
#if (~0UL) == 0xffffffff
#define uint8_t unsigned char
#define int16_t short
#define uint16_t unsigned short
#define int32_t long
#define uint32_t unsigned long
#else /* (~0UL) == 0xffffffff */
#if (~0UL) == 0xffffffffffffffff
#define uint8_t unsigned char
#define int16_t short
#define uint16_t unsigned short
#define int32_t int
#define uint32_t unsigned int
#else /* (~0UL) == 0xffffffffffffffff */
#error Neither 32 bit nor 64 bit word size detected.
#error You need to define the bit types manually.
#endif /* (~0UL) == 0xffffffffffffffff */
#endif /* (~0UL) == 0xffffffff */
#endif /* !HAVE_POSIX1G_TYPES */

#if defined(INET6) && !defined(AF_INET6)
#error Without a definition of AF_INET6, this system cannot support IPv6
#error addresses.
#endif /* defined(INET6) && !defined(AF_INET6) */

#if INET6
#ifndef T_AAAA
#define T_AAAA 28
#endif /* T_AAAA */
#endif /* INET6 */

#if DEBUG
#if RESOLVER
#define DEBUG_MESSAGES (_res.options & RES_DEBUG)
#else /* RESOLVER */
int __getaddrinfo_debug = 0;
#define DEBUG_MESSAGES (__getaddrinfo_debug)
#endif /* RESOLVER */
#endif /* DEBUG */

a100 1
#if DEBUG
a101 2
    if (DEBUG_MESSAGES) \
      fprintf(stderr, "%s:%d: returning %s\n", __FILE__, __LINE__, #x); \
a104 6
#else /* DEBUG */
#define RETURN_ERROR(x) do { \
    rval = (x); \
    goto ret; \
    } while(0)
#endif /* DEBUG */
d106 1
a106 88
#if HOSTTABLE
static int hosttable_lookup_addr(const char *name, const struct addrinfo *req, struct gaih_addrtuple **pat)
{
  FILE *f;
  char buffer[1024];
  char *c, *c2;
  int rval = 1;
  char *prevcname = NULL;
  struct gaih_addrtuple at;

  if (!(f = fopen("/etc/hosts", "r")))
    RETURN_ERROR(-EAI_SYSTEM);

  while(fgets(buffer, sizeof(buffer), f)) {
    if (c = strchr(buffer, '#'))
      *c = 0;

    c = buffer;
    while(*c && !isspace(*c)) c++;
    if (!*c)
      continue;

    *(c++) = 0;

    while(*c && isspace(*c)) c++;
    if (!*c)
      continue;

    if (!(c2 = strstr(c, name)))
      continue;

    if (*(c2 - 1) && !isspace(*(c2 - 1)))
      continue;

    c2 += strlen(name);
    if (*c2 && !isspace(*c2))
      continue;

    c2 = c;
    while(*c2 && !isspace(*c2)) c2++;
    if (!*c2)
      continue;
    *c2 = 0;

    memset(&at, 0, sizeof(struct gaih_addrtuple));

    if (!req->ai_family || (req->ai_family == AF_INET))
      if (inet_pton(AF_INET, buffer, (char *)&at.addr) > 0) {
	at.family = AF_INET;
	goto build;
      };

#if INET6
    if (!req->ai_family || (req->ai_family == AF_INET6))
      if (inet_pton(AF_INET6, buffer, (char *)&at.addr) > 0) {
	at.family = AF_INET6;
	goto build;
      };
#endif /* INET6 */

    continue;

build:
    if (!(*pat = malloc(sizeof(struct gaih_addrtuple))))
      RETURN_ERROR(-EAI_MEMORY);

    memcpy(*pat, &at, sizeof(struct gaih_addrtuple));

    if (req->ai_flags & AI_CANONNAME)
      if (prevcname && !strcmp(prevcname, c))
        (*pat)->cname = prevcname;
      else
        prevcname = (*pat)->cname = strdup(c);

    pat = &((*pat)->next);

    rval = 0;
  };

ret:
  if (f)
    fclose(f);
  return rval;
};
#endif /* HOSTTABLE */

#if NETDB
int netdb_lookup_addr(const char *name, int af, const struct addrinfo *req, struct gaih_addrtuple **pat)
a111 25
#if HAVE_GETHOSTBYNAME2_R
  void *buf;
  int buflen = 1024;
  struct hostent th;
  int herrno, j;

  do {
    if (!(buf = malloc(buflen)))
      RETURN_ERROR(-EAI_MEMORY);

    if (!gethostbyname2_r(name, af, &th, buf, buflen, &h, &herrno))
      break;

    free(buf);
    buf = NULL;

    if ((herrno == NETDB_INTERNAL) && (errno == ERANGE)) {
      if (buflen >= 65536)
	RETURN_ERROR(-EAI_MEMORY);

      buflen = buflen << 1;
      continue;
    };
  } while(0);
#else /* HAVE_GETHOSTBYNAME2_R */
a113 1
#endif /* HAVE_GETHOSTBYNAME2_R */
a115 4
#if DEBUG
    if (DEBUG_MESSAGES)
      fprintf(stderr, "getaddrinfo: gethostbyname2 failed, h_errno=%d\n", herrno);
#endif /* DEBUG */
a144 1
#if INET6
a147 1
#endif /* INET6 */
a164 3
#if HAVE_GETHOSTBYNAME2_R
  free(buf);
#endif /* HAVE_GETHOSTBYNAME2_R */
a166 42
#endif /* NETDB */

#if RESOLVER
#define RRHEADER_SZ 10

int resolver_lookup_addr(const char *name, int type, const struct addrinfo *req, struct gaih_addrtuple **pat)
{
  int rval;
  char answer[PACKETSZ];
  int answerlen;
  char dn[MAXDNAME];
  char *prevcname = NULL;
  void *p, *ep;
  int answers, i, j;
  uint16_t rtype, rclass;

  if ((answerlen = res_search(name, C_IN, type, answer, sizeof(answer))) < 0) {
#if DEBUG
    if (DEBUG_MESSAGES)
      fprintf(stderr, "getaddrinfo: res_search failed, h_errno=%d\n", h_errno);
#endif /* DEBUG */
    switch(h_errno) {
      case NETDB_INTERNAL:
	RETURN_ERROR(-EAI_SYSTEM);
      case HOST_NOT_FOUND:
	RETURN_ERROR(1);
      case TRY_AGAIN:
	RETURN_ERROR(-EAI_AGAIN);
      case NO_RECOVERY:
	RETURN_ERROR(-EAI_FAIL);
      case NO_DATA:
	RETURN_ERROR(1);
      default:
	RETURN_ERROR(-EAI_FAIL);
    };
  };

  p = answer;
  ep = answer + answerlen;
  
  if (answerlen < RRHEADER_SZ)
    RETURN_ERROR(-EAI_FAIL);
a167 86
  {
    HEADER *h = (HEADER *)p;
    if (!h->qr || (h->opcode != QUERY) || (h->qdcount != htons(1)) ||
	!h->ancount)
      RETURN_ERROR(-EAI_FAIL);
    answers = ntohs(h->ancount);
  };
  p += sizeof(HEADER);

  if ((i = dn_expand(answer, ep, p, dn, sizeof(dn))) < 0)
    RETURN_ERROR(-EAI_FAIL);
  p += i;

  if (p + 2*sizeof(uint16_t) >= ep)
    RETURN_ERROR(-EAI_FAIL);

  GETSHORT(rtype, p);
  GETSHORT(rclass, p);

  if ((rtype != type) || (rclass != C_IN))
    RETURN_ERROR(-EAI_FAIL);

  while(answers--) {
    if ((i = dn_expand(answer, ep, p, dn, sizeof(dn))) < 0)
      RETURN_ERROR(-EAI_FAIL);
    p += i;

    if (p + RRHEADER_SZ >= ep)
      RETURN_ERROR(-EAI_FAIL);

    GETSHORT(rtype, p);
    GETSHORT(rclass, p);
    p += sizeof(uint32_t);
    if (rclass != C_IN)
      RETURN_ERROR(-EAI_FAIL);
    GETSHORT(rclass, p);
    i = rclass;

    if (p + i > ep)
      RETURN_ERROR(-EAI_FAIL);

    if (rtype == type) {
      while(*pat)
	pat = &((*pat)->next);

      if (!(*pat = malloc(sizeof(struct gaih_addrtuple))))
	RETURN_ERROR(-EAI_MEMORY);

      memset(*pat, 0, sizeof(struct gaih_addrtuple));
      
      switch(type) {
        case T_A:
	  if (i != sizeof(struct in_addr))
	    RETURN_ERROR(-EAI_FAIL);
	  (*pat)->family = AF_INET;
	  break;
#if INET6
        case T_AAAA:
	  if (i != sizeof(struct in6_addr))
	    RETURN_ERROR(-EAI_FAIL);
	  (*pat)->family = AF_INET6;
	  break;
#endif /* INET6 */
        default:
	  RETURN_ERROR(-EAI_FAIL);
      };

      memcpy((*pat)->addr, p, i);
    
      if (req->ai_flags & AI_CANONNAME)
	if (prevcname && !strcmp(prevcname, dn))
	  (*pat)->cname = prevcname;
	else
	  prevcname = (*pat)->cname = strdup(dn);
    };
    p += i;
  };

  rval = 0;

ret:
  return rval;
};
#endif /* RESOLVER */

#if LOCAL
a191 1
#if SALEN
a192 1
#endif /* SALEN */
a225 1
#endif /* LOCAL */
a237 21
#if HAVE_GETSERVBYNAME_R
  int i;
  void *buf;
  int buflen = 1024;
  struct servent ts;

  do {
    if (!(buf = malloc(buflen)))
      RETURN_ERROR(-EAI_MEMORY);

    if (!getservbyname_r(servicename, tp->name, &ts, buf, buflen, &s))
      break;

    free(buf);
    buf = NULL;

    if (errno != ERANGE)
      RETURN_ERROR(GAIH_OKIFUNSPEC | -EAI_SERVICE);

    if (buflen >= 65536)
      RETURN_ERROR(-EAI_MEMORY);
a238 3
    buflen = buflen << 1;
  } while(1);
#else /* HAVE_GETSERVBYNAME_R */
a240 1
#endif /* HAVE_GETSERVBYNAME_R */
a252 4
#if HAVE_GETSERVBYNAME_R
  if (buf)
    free(buf);
#endif /* HAVE_GETSERVBYNAME_R */
a312 1
#if INET6
a323 3
#else /* INET6 */
    at->family = AF_INET;
#endif /* INET6 */
a341 1
#if INET6
a354 1
#endif /* INET6 */
a356 2
#if NETDB
#if INET6
a359 1
#endif /* INET6 */
a365 35
#else /* NETDB */
#if HOSTTABLE
    if ((rval = hosttable_lookup_addr(name, req, &at)) < 0)
      goto ret;

    if (!rval)
      goto build;
#endif /* HOSTTABLE */

#if RESOLVER
#if INET6
    {
    int rval2;

    if (!req->ai_family || (req->ai_family == AF_INET6))
      if ((rval2 = resolver_lookup_addr(name, T_AAAA, req, &at)) < 0) {
	rval = rval2;
	goto ret;
      };
#endif /* INET6 */

    if (!req->ai_family || (req->ai_family == AF_INET))
      if ((rval = resolver_lookup_addr(name, T_A, req, &at)) < 0)
	goto ret;

#if INET6
    if (!rval || !rval2)
      goto build;
    };
#else /* INET6 */
    if (!rval)
      goto build;
#endif /* INET6 */
#endif /* RESOLVER */
#endif /* NETDB */
a389 1
#if INET6
a392 1
#endif /* INET6 */
a407 1
#if SALEN
a408 1
#endif /* SALEN */
a411 1
#if INET6
a414 1
#endif /* INET6 */
a468 1
#if INET6
a469 1
#endif /* INET6 */
a470 1
#if LOCAL
a471 1
#endif /* LOCAL */
a474 70
#if DEBUG
static void dump_addrinfo(const struct addrinfo *ai, int follownext)
{
  char *c;

loop:
  fprintf(stderr, "addrinfo at ");
  if (!ai) {
    fprintf(stderr, "NULL\n");
    return;
  };
  fprintf(stderr, "%08x:\n", (unsigned int)ai);
  fprintf(stderr, "  flags=%x(", ai->ai_flags);
  c = "";
  if (ai->ai_flags & AI_PASSIVE) {
    fprintf(stderr, "passive");
    c = " ";
  };
  if (ai->ai_flags & AI_CANONNAME) {
    fprintf(stderr, "%scanonname", c);
    c = " ";
  };
  if (ai->ai_flags & AI_NUMERICHOST) {
    fprintf(stderr, "%snumerichost", c);
    c = " ";
  };
  if (ai->ai_flags & AI_EXT) {
    fprintf(stderr, "%sext", c);
  };
  fprintf(stderr, ")\n");
  fprintf(stderr, "  family=%x(%s)\n", ai->ai_family, nrl_afnumtoname(ai->ai_family));
  fprintf(stderr, "  socktype=%x(%s)\n", ai->ai_socktype, nrl_socktypenumtoname(ai->ai_socktype));
  fprintf(stderr, "  protocol=%x\n", ai->ai_protocol);
  fprintf(stderr, "  addrlen=%x\n", ai->ai_addrlen);
  fprintf(stderr, "  addr=%08x", (unsigned int)ai->ai_addr);
  if (ai->ai_addr) {
    fprintf(stderr, ":\n");
#if SALEN
    fprintf(stderr, "    len=%x\n", ai->ai_addr->sa_len);
#endif /* SALEN */
    fprintf(stderr, "    family=%x(%s)\n", ai->ai_addr->sa_family, nrl_afnumtoname(ai->ai_addr->sa_family));
    fprintf(stderr, "    data=");

#if SALEN
    if (ai->ai_addrlen != ai->ai_addr->sa_len) {
      fprintf(stderr, "  (addrlen != len, skipping)");
    } else
#endif /* SALEN */
    {
      uint8_t *p;
      int i;

      p = (uint8_t *)ai->ai_addr->sa_data;
      i = ai->ai_addrlen - ((void *)ai->ai_addr->sa_data - (void *)ai->ai_addr);
      while (i-- > 0)
        fprintf(stderr, "%02x", *(p++));
    };
  };
  fprintf(stderr, "\n  canonname=%08x", (unsigned int)ai->ai_canonname);
  if (ai->ai_canonname)
    fprintf(stderr, "(%s)", ai->ai_canonname);
  fprintf(stderr, "\n  next=%08x\n", (unsigned int)ai->ai_next);

  if (follownext && ai->ai_next) {
    ai = ai->ai_next;
    goto loop;
  };
};
#endif /* DEBUG */

a483 8
#if DEBUG
  if (DEBUG_MESSAGES) {
    fprintf(stderr, "getaddrinfo(name=%s, service=%s, req=%p, pai=%p)\n  req: ", name ? name : "NULL", service ? service : "NULL", req, pai);

    dump_addrinfo(req, 0);
  };
#endif /* DEBUG */

a489 5
#if BROKEN_LIKE_POSIX
  if  (!name && !service && !(req.ai_flags & AI_EXT))
    RETURN_ERROR(EAI_NONAME);
#endif /* BROKEN_LIKE_POSIX */

a495 5
#if BROKEN_LIKE_POSIX
  if ((req->ai_flags & AI_CANONNAME) && !name && !(req.ai_flags & AI_EXT))
    RETURN_ERROR(EAI_BADFLAGS);
#endif /* BROKEN_LIKE_POSIX */

a501 5
#if BROKEN_LIKE_POSIX
      else
        if (!req->ai_socktype && !(req.ai_flags & AI_EXT))
	  RETURN_ERROR(EAI_SERVICE);
#endif /* BROKEN_LIKE_POSIX */
a538 6
#if DEBUG
    if (DEBUG_MESSAGES) {
      fprintf(stderr, "getaddrinfo: Success. *pai:\n");
      dump_addrinfo(p, 1);
    };
#endif /* DEBUG */
a550 4
#if DEBUG
  if (DEBUG_MESSAGES)
    fprintf(stderr, "getaddrinfo=%d\n", rval);
#endif /* DEBUG */
@

