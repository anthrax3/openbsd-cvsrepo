head	1.41;
access;
symbols
	OPENBSD_5_4:1.40.0.18
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.16
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.14
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.12
	OPENBSD_5_0:1.40.0.10
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.8
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.40.0.6
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.40.0.4
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.6
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.4
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.34.0.4
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.18.0.4
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.16.0.6
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.4
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2013.11.12.20.37.16;	author eric;	state dead;
branches;
next	1.40;

1.40
date	2009.06.05.09.52.26;	author pyr;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.04.21.38.29;	author pyr;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.04.18.06.35;	author pyr;	state Exp;
branches;
next	1.37;

1.37
date	2008.08.15.14.57.20;	author djm;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.05.16.11.09;	author ray;	state Exp;
branches;
next	1.35;

1.35
date	2006.09.23.04.56.43;	author ray;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.22.06.52.11;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.06.20.30.04;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.30.02.58.28;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.07.21.11.23;	author marc;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.02.20.18.36;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.28.04.58.00;	author marc;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.25.21.13.45;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.27.10.14.02;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.14.23.49.29;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.30.00.50.21;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.27.00.58.55;	author lebel;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.11.10.06.00;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.10.15.33.04;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.22.07.31.18;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	99.09.03.21.14.51;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.09.03.16.23.19;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.03.16.05.07.01;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.07.15.18.33.50;	author flipk;	state Exp;
branches;
next	1.14;

1.14
date	97.04.13.21.30.43;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	97.04.05.21.13.17;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.04.03.05.53.46;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.03.13.19.07.38;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.09.22.11.52.07;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.09.22.05.14.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.22.02.18.44;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.15.09.31.19;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.08.27.03.32.53;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.25.10.11.02;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.08.29.45;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.18.19.07.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.19.19.53.26;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.41
log
@remove dead files

ok deraadt@@
@
text
@/*	$OpenBSD: res_init.c,v 1.40 2009/06/05 09:52:26 pyr Exp $	*/

/*
 * ++Copyright++ 1985, 1989, 1993
 * -
 * Copyright (c) 1985, 1989, 1993
 *    The Regents of the University of California.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 */

#ifndef INET6
#define INET6
#endif

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <stdio.h>
#include <ctype.h>
#include <resolv.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#ifdef INET6
#include <netdb.h>
#endif /* INET6 */

#include "thread_private.h"

/*-------------------------------------- info about "sortlist" --------------
 * Marc Majka		1994/04/16
 * Allan Nathanson	1994/10/29 (BIND 4.9.3.x)
 *
 * NetInfo resolver configuration directory support.
 *
 * Allow a NetInfo directory to be created in the hierarchy which
 * contains the same information as the resolver configuration file.
 *
 * - The local domain name is stored as the value of the "domain" property.
 * - The Internet address(es) of the name server(s) are stored as values
 *   of the "nameserver" property.
 * - The name server addresses are stored as values of the "nameserver"
 *   property.
 * - The search list for host-name lookup is stored as values of the
 *   "search" property.
 * - The sortlist comprised of IP address netmask pairs are stored as
 *   values of the "sortlist" property. The IP address and optional netmask
 *   should be separated by a slash (/) or ampersand (&) character.
 * - Internal resolver variables can be set from the value of the "options"
 *   property.
 */

static void res_setoptions(char *, char *);

#ifdef RESOLVSORT
static const char sort_mask[] = "/&";
#define ISSORTMASK(ch) (strchr(sort_mask, ch) != NULL)
static u_int32_t net_mask(struct in_addr);
#endif

/*
 * Resolver state default settings.
 */
void *__THREAD_NAME(_res);

struct __res_state _res
# if defined(__BIND_RES_TEXT)
	= { RES_TIMEOUT, }	/* Motorola, et al. */
# endif
	;
#ifdef INET6
void *__THREAD_NAME(_res_ext);

struct __res_state_ext _res_ext;
#endif /* INET6 */

int __res_chktime = 30;

/*
 * Set up default settings.  If the configuration file exist, the values
 * there will have precedence.  Otherwise, the server address is set to
 * INADDR_ANY and the default domain name comes from the gethostname().
 *
 * An interrim version of this code (BIND 4.9, pre-4.4BSD) used 127.0.0.1
 * rather than INADDR_ANY ("0.0.0.0") as the default name server address
 * since it was noted that INADDR_ANY actually meant ``the first interface
 * you "ifconfig"'d at boot time'' and if this was a SLIP or PPP interface,
 * it had to be "up" in order for you to reach your own name server.  It
 * was later decided that since the recommended practice is to always 
 * install local static routes through 127.0.0.1 for all your network
 * interfaces, that we could solve this problem without a code change.
 *
 * The configuration file should always be used, since it is the only way
 * to specify a default domain.  If you are running a server on your local
 * machine, you should say "nameserver 0.0.0.0" or "nameserver 127.0.0.1"
 * in the configuration file.
 *
 * Return 0 if completes successfully, -1 on error
 */
int
res_init(void)
{

	return (_res_init(1));
}

int
_res_init(int usercall)
{
	struct stat sb;
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
#ifdef INET6
	struct __res_state_ext *_res_extp = _THREAD_PRIVATE(_res_ext, _res_ext,
							    &_res_ext);
#endif
	FILE *fp;
	char *cp, **pp;
	int n;
	int findex;
	char buf[BUFSIZ];
	int nserv = 0;    /* number of nameserver records read from file */
	int haveenv = 0;
	int havesearch = 0;
	size_t len;
#ifdef RESOLVSORT
	int nsort = 0;
	char *net;
#endif
#ifndef RFC1535
	int dots;
#endif

	if (!usercall && _resp->options & RES_INIT &&
	    _resp->reschktime >= time(NULL))
		return (0);
	_resp->reschktime = time(NULL) + __res_chktime;
	if (stat(_PATH_RESCONF, &sb) != -1) {
		if (!usercall && timespeccmp(&sb.st_mtimespec,
		    &_resp->restimespec, ==))
			return (0);
		else
			_resp->restimespec = sb.st_mtimespec;
	} else {
		/*
		 * Lost the file, in chroot?
		 * Don't trash settings
		 */
		if (!usercall && timespecisset(&_resp->restimespec))
			return (0);
	}


	/*
	 * These three fields used to be statically initialized.  This made
	 * it hard to use this code in a shared library.  It is necessary,
	 * now that we're doing dynamic initialization here, that we preserve
	 * the old semantics: if an application modifies one of these three
	 * fields of _res before res_init() is called, res_init() will not
	 * alter them.  Of course, if an application is setting them to
	 * _zero_ before calling res_init(), hoping to override what used
	 * to be the static default, we can't detect it and unexpected results
	 * will follow.  Zero for any of these fields would make no sense,
	 * so one can safely assume that the applications were already getting
	 * unexpected results.
	 *
	 * _res.options is tricky since some apps were known to diddle the bits
	 * before res_init() was first called. We can't replicate that semantic
	 * with dynamic initialization (they may have turned bits off that are
	 * set in RES_DEFAULT).  Our solution is to declare such applications
	 * "broken".  They could fool us by setting RES_INIT but none do (yet).
	 */
	if (!_resp->retrans)
		_resp->retrans = RES_TIMEOUT;
	if (!_resp->retry)
		_resp->retry = 4;
	if (!(_resp->options & RES_INIT))
		_resp->options = RES_DEFAULT;

#ifdef USELOOPBACK
	_resp->nsaddr.sin_addr = inet_makeaddr(IN_LOOPBACKNET, 1);
#else
	_resp->nsaddr.sin_addr.s_addr = INADDR_ANY;
#endif
	_resp->nsaddr.sin_family = AF_INET;
	_resp->nsaddr.sin_port = htons(NAMESERVER_PORT);
	_resp->nsaddr.sin_len = sizeof(struct sockaddr_in);
#ifdef INET6
	if (sizeof(_res_extp->nsaddr) >= _resp->nsaddr.sin_len)
		memcpy(&_res_extp->nsaddr, &_resp->nsaddr, _resp->nsaddr.sin_len);
#endif
	_resp->nscount = 1;
	_resp->ndots = 1;
	_resp->pfcode = 0;
	strlcpy(_resp->lookups, "f", sizeof _resp->lookups);

	/* Allow user to override the local domain definition */
	if (issetugid() == 0 && (cp = getenv("LOCALDOMAIN")) != NULL) {
		strlcpy(_resp->defdname, cp, sizeof(_resp->defdname));
		haveenv++;

		/*
		 * Set search list to be blank-separated strings
		 * from rest of env value.  Permits users of LOCALDOMAIN
		 * to still have a search list, and anyone to set the
		 * one that they want to use as an individual (even more
		 * important now that the rfc1535 stuff restricts searches)
		 */
		cp = _resp->defdname;
		pp = _resp->dnsrch;
		*pp++ = cp;
		for (n = 0; *cp && pp < _resp->dnsrch + MAXDNSRCH; cp++) {
			if (*cp == '\n')	/* silly backwards compat */
				break;
			else if (*cp == ' ' || *cp == '\t') {
				*cp = 0;
				n = 1;
			} else if (n) {
				*pp++ = cp;
				n = 0;
				havesearch = 1;
			}
		}
		/* null terminate last domain if there are excess */
		while (*cp != '\0' && *cp != ' ' && *cp != '\t' && *cp != '\n')
			cp++;
		*cp = '\0';
		*pp++ = 0;
	}

#define	MATCH(line, name) \
	(!strncmp(line, name, sizeof(name) - 1) && \
	(line[sizeof(name) - 1] == ' ' || \
	 line[sizeof(name) - 1] == '\t'))

	/* initialize family lookup preference: inet4 first */
	_resp->family[0] = AF_INET;
	_resp->family[1] = AF_INET6;
	if ((fp = fopen(_PATH_RESCONF, "r")) != NULL) {
	    strlcpy(_resp->lookups, "bf", sizeof _resp->lookups);

	    /* read the config file */
	    buf[0] = '\0';
	    while ((cp = fgetln(fp, &len)) != NULL) {
		/* skip lines that are too long */
		if (len >= sizeof(buf))
		    continue;
		(void)memcpy(buf, cp, len);
		buf[len] = '\0';
		/* skip comments */
		if ((cp = strpbrk(buf, ";#")) != NULL)
			*cp = '\0';
		if (buf[0] == '\0')
			continue;
		/* set family lookup order */
		if (MATCH(buf, "family")) {
			cp = buf + sizeof("family") - 1;
			cp += strspn(cp, " \t");
			cp[strcspn(cp, "\n")] = '\0';
			findex = 0;
			_resp->family[0] = _resp->family[1] = -1;
#define INETLEN (sizeof("inetX") - 1)
			while (*cp != '\0' && findex < 2) {
				if (!strncmp(cp, "inet6", INETLEN)) {
					_resp->family[findex] = AF_INET6;
					cp += INETLEN;
				} else if (!strncmp(cp, "inet4", INETLEN)) {
					_resp->family[findex] = AF_INET;
					cp += INETLEN;
				} else {
					_resp->family[0] = -1;
					break;
				}
				if (*cp != ' ' && *cp != '\t' && *cp != '\0') {
					_resp->family[findex] = -1;
					break;
				}
				findex++;
				cp += strspn(cp, " \t");
			}

			if (_resp->family[0] == -1) {
				/* line contains errors, reset to defaults */
				_resp->family[0] = AF_INET;
				_resp->family[1] = AF_INET6;
			}
			if (_resp->family[0] == _resp->family[1])
				_resp->family[1] = -1;
		}
		/* read default domain name */
		if (MATCH(buf, "domain")) {
		    if (haveenv)	/* skip if have from environ */
			    continue;
		    cp = buf + sizeof("domain") - 1;
		    while (*cp == ' ' || *cp == '\t')
			    cp++;
		    if ((*cp == '\0') || (*cp == '\n'))
			    continue;
		    strlcpy(_resp->defdname, cp, sizeof(_resp->defdname));
		    if ((cp = strpbrk(_resp->defdname, " \t\n")) != NULL)
			    *cp = '\0';
		    havesearch = 0;
		    continue;
		}
		/* lookup types */
		if (MATCH(buf, "lookup")) {
		    char *sp = NULL;

		    bzero(_resp->lookups, sizeof _resp->lookups);
		    cp = buf + sizeof("lookup") - 1;
		    for (n = 0;; cp++) {
		    	    if (n == MAXDNSLUS)
				    break;
			    if ((*cp == '\0') || (*cp == '\n')) {
				    if (sp) {
					    if (*sp=='y' || *sp=='b' || *sp=='f')
						    _resp->lookups[n++] = *sp;
					    sp = NULL;
				    }
				    break;
			    } else if ((*cp == ' ') || (*cp == '\t') || (*cp == ',')) {
				    if (sp) {
					    if (*sp=='y' || *sp=='b' || *sp=='f')
						    _resp->lookups[n++] = *sp;
					    sp = NULL;
				    }
			    } else if (sp == NULL)
				    sp = cp;
		    }
		    continue;
		}
		/* set search list */
		if (MATCH(buf, "search")) {
		    if (haveenv)	/* skip if have from environ */
			    continue;
		    cp = buf + sizeof("search") - 1;
		    while (*cp == ' ' || *cp == '\t')
			    cp++;
		    if ((*cp == '\0') || (*cp == '\n'))
			    continue;
		    strlcpy(_resp->defdname, cp, sizeof(_resp->defdname));
		    if ((cp = strchr(_resp->defdname, '\n')) != NULL)
			    *cp = '\0';
		    /*
		     * Set search list to be blank-separated strings
		     * on rest of line.
		     */
		    cp = _resp->defdname;
		    pp = _resp->dnsrch;
		    *pp++ = cp;
		    for (n = 0; *cp && pp < _resp->dnsrch + MAXDNSRCH; cp++) {
			    if (*cp == ' ' || *cp == '\t') {
				    *cp = 0;
				    n = 1;
			    } else if (n) {
				    *pp++ = cp;
				    n = 0;
			    }
		    }
		    /* null terminate last domain if there are excess */
		    while (*cp != '\0' && *cp != ' ' && *cp != '\t')
			    cp++;
		    *cp = '\0';
		    *pp++ = 0;
		    havesearch = 1;
		    continue;
		}
		/* read nameservers to query */
		if (MATCH(buf, "nameserver") && nserv < MAXNS) {
		    char *q;
		    struct addrinfo hints, *res;
		    char pbuf[NI_MAXSERV];

		    cp = buf + sizeof("nameserver") - 1;
		    while (*cp == ' ' || *cp == '\t')
			cp++;
		    if ((*cp == '\0') || (*cp == '\n'))
			continue;
		    for (q = cp; *q; q++) {
			if (isspace(*q)) {
			    *q = '\0';
			    break;
			}
		    }

		    /* Handle addresses enclosed in [] */
		    *pbuf = '\0';
		    if (*cp == '[') {
			cp++;
			if ((q = strchr(cp, ']')) == NULL)
				continue;
			*q++ = '\0';
			/* Extract port, if specified */
			if (*q++ == ':') {
			    if (strlcpy(pbuf, q, sizeof(pbuf)) >= sizeof(pbuf))
				continue;
			}
		    }
		    if (*pbuf == '\0')
		    	snprintf(pbuf, sizeof(pbuf), "%u", NAMESERVER_PORT);

		    memset(&hints, 0, sizeof(hints));
		    hints.ai_flags = AI_NUMERICHOST;
		    hints.ai_socktype = SOCK_DGRAM;
		    res = NULL;
		    if (getaddrinfo(cp, pbuf, &hints, &res) == 0 &&
			    res->ai_next == NULL) {
			if (res->ai_addrlen <= sizeof(_res_extp->nsaddr_list[nserv])) {
			    memcpy(&_res_extp->nsaddr_list[nserv], res->ai_addr,
				res->ai_addrlen);
			} else {
			    memset(&_res_extp->nsaddr_list[nserv], 0,
				sizeof(_res_extp->nsaddr_list[nserv]));
			}
			if (res->ai_addrlen <= sizeof(_resp->nsaddr_list[nserv])) {
			    memcpy(&_resp->nsaddr_list[nserv], res->ai_addr,
				res->ai_addrlen);
			} else {
			    memset(&_resp->nsaddr_list[nserv], 0,
				sizeof(_resp->nsaddr_list[nserv]));
			}
			nserv++;
		    }
		    if (res)
			freeaddrinfo(res);
		    continue;
		}
#ifdef RESOLVSORT
		if (MATCH(buf, "sortlist")) {
		    struct in_addr a;
#ifdef INET6
		    struct in6_addr a6;
		    int m, i;
		    u_char *u;
#endif /* INET6 */

		    cp = buf + sizeof("sortlist") - 1;
		    while (nsort < MAXRESOLVSORT) {
			while (*cp == ' ' || *cp == '\t')
			    cp++;
			if (*cp == '\0' || *cp == '\n' || *cp == ';')
			    break;
			net = cp;
			while (*cp && !ISSORTMASK(*cp) && *cp != ';' &&
			       isascii(*cp) && !isspace(*cp))
				cp++;
			n = *cp;
			*cp = 0;
			if (inet_aton(net, &a)) {
			    _resp->sort_list[nsort].addr = a;
			    if (ISSORTMASK(n)) {
				*cp++ = n;
				net = cp;
				while (*cp && *cp != ';' &&
					isascii(*cp) && !isspace(*cp))
				    cp++;
				n = *cp;
				*cp = 0;
				if (inet_aton(net, &a)) {
				    _resp->sort_list[nsort].mask = a.s_addr;
				} else {
				    _resp->sort_list[nsort].mask = 
					net_mask(_resp->sort_list[nsort].addr);
				}
			    } else {
				_resp->sort_list[nsort].mask = 
				    net_mask(_resp->sort_list[nsort].addr);
			    }
#ifdef INET6
			    _res_extp->sort_list[nsort].af = AF_INET;
			    _res_extp->sort_list[nsort].addr.ina =
				_resp->sort_list[nsort].addr;
			    _res_extp->sort_list[nsort].mask.ina.s_addr =
				_resp->sort_list[nsort].mask;
#endif /* INET6 */
			    nsort++;
			}
#ifdef INET6
			else if (inet_pton(AF_INET6, net, &a6) == 1) {
			    _res_extp->sort_list[nsort].af = AF_INET6;
			    _res_extp->sort_list[nsort].addr.in6a = a6;
			    u = (u_char *)&_res_extp->sort_list[nsort].mask.in6a;
			    *cp++ = n;
			    net = cp;
			    while (*cp && *cp != ';' &&
				    isascii(*cp) && !isspace(*cp))
				cp++;
			    m = n;
			    n = *cp;
			    *cp = 0;
			    switch (m) {
			    case '/':
				m = atoi(net);
				break;
			    case '&':
				if (inet_pton(AF_INET6, net, u) == 1) {
				    m = -1;
				    break;
				}
				/* FALLTHROUGH */
			    default:
				m = sizeof(struct in6_addr) * NBBY;
				break;
			    }
			    if (m >= 0) {
				for (i = 0; i < sizeof(struct in6_addr); i++) {
				    if (m <= 0) {
					*u = 0;
				    } else {
					m -= NBBY;
					*u = (u_char)~0;
					if (m < 0)
					    *u <<= -m;
				    }
				    u++;
				}
			    }
			    nsort++;
			}
#endif /* INET6 */
			*cp = n;
		    }
		    continue;
		}
#endif
		if (MATCH(buf, "options")) {
		    res_setoptions(buf + sizeof("options") - 1, "conf");
		    continue;
		}
	    }
	    if (nserv > 1) 
		_resp->nscount = nserv;
#ifdef RESOLVSORT
	    _resp->nsort = nsort;
#endif
	    (void) fclose(fp);
	}
	if (_resp->defdname[0] == 0 &&
	    gethostname(buf, sizeof(_resp->defdname) - 1) == 0 &&
	    (cp = strchr(buf, '.')) != NULL)
	{
		strlcpy(_resp->defdname, cp + 1,
		        sizeof(_resp->defdname));
	}

	/* find components of local domain that might be searched */
	if (havesearch == 0) {
		pp = _resp->dnsrch;
		*pp++ = _resp->defdname;
		*pp = NULL;

#ifndef RFC1535
		dots = 0;
		for (cp = _resp->defdname; *cp; cp++)
			dots += (*cp == '.');

		cp = _resp->defdname;
		while (pp < _resp->dnsrch + MAXDFLSRCH) {
			if (dots < LOCALDOMAINPARTS)
				break;
			cp = strchr(cp, '.') + 1;    /* we know there is one */
			*pp++ = cp;
			dots--;
		}
		*pp = NULL;
#ifdef DEBUG
		if (_resp->options & RES_DEBUG) {
			printf(";; res_init()... default dnsrch list:\n");
			for (pp = _resp->dnsrch; *pp; pp++)
				printf(";;\t%s\n", *pp);
			printf(";;\t..END..\n");
		}
#endif /* DEBUG */
#endif /* !RFC1535 */
	}

	if (issetugid())
		_resp->options |= RES_NOALIASES;
	else if ((cp = getenv("RES_OPTIONS")) != NULL)
		res_setoptions(cp, "env");
	_resp->options |= RES_INIT;
	return (0);
}

/* ARGSUSED */
static void
res_setoptions(char *options, char *source)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	char *cp = options;
	char *endp;
	long l;

#ifdef DEBUG
	if (_resp->options & RES_DEBUG)
		printf(";; res_setoptions(\"%s\", \"%s\")...\n",
		       options, source);
#endif
	while (*cp) {
		/* skip leading and inner runs of spaces */
		while (*cp == ' ' || *cp == '\t')
			cp++;
		/* search for and process individual options */
		if (!strncmp(cp, "ndots:", sizeof("ndots:") - 1)) {
			char *p = cp + sizeof("ndots:") - 1;
			l = strtol(p, &endp, 10);
			if (l >= 0 && endp != p &&
			    (*endp = '\0' || isspace(*endp))) {
				if (l <= RES_MAXNDOTS)
					_resp->ndots = l;
				else
					_resp->ndots = RES_MAXNDOTS;
#ifdef DEBUG
				if (_resp->options & RES_DEBUG)
					printf(";;\tndots=%u\n", _resp->ndots);
#endif
			}
		} else if (!strncmp(cp, "debug", sizeof("debug") - 1)) {
#ifdef DEBUG
			if (!(_resp->options & RES_DEBUG)) {
				printf(";; res_setoptions(\"%s\", \"%s\")..\n",
				       options, source);
				_resp->options |= RES_DEBUG;
			}
			printf(";;\tdebug\n");
#endif
		} else if (!strncmp(cp, "inet6", sizeof("inet6") - 1)) {
			_resp->options |= RES_USE_INET6;
		} else if (!strncmp(cp, "insecure1", sizeof("insecure1") - 1)) {
			_resp->options |= RES_INSECURE1;
		} else if (!strncmp(cp, "insecure2", sizeof("insecure2") - 1)) {
			_resp->options |= RES_INSECURE2;
		} else if (!strncmp(cp, "edns0", sizeof("edns0") - 1)) {
			_resp->options |= RES_USE_EDNS0;
		} else if (!strncmp(cp, "tcp", sizeof("tcp") - 1)) {
			_resp->options |= RES_USEVC;
		} else {
			/* XXX - print a warning here? */
		}
		/* skip to next run of spaces */
		while (*cp && *cp != ' ' && *cp != '\t')
			cp++;
	}
}

#ifdef RESOLVSORT
/* XXX - should really support CIDR which means explicit masks always. */
static u_int32_t
net_mask(struct in_addr in)	/* XXX - should really use system's version of this */
{
	u_int32_t i = ntohl(in.s_addr);

	if (IN_CLASSA(i))
		return (htonl(IN_CLASSA_NET));
	else if (IN_CLASSB(i))
		return (htonl(IN_CLASSB_NET));
	return (htonl(IN_CLASSC_NET));
}
#endif
@


1.40
log
@compare and shift buffer against a fixed length not strlen derived values.
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.39 2009/06/04 21:38:29 pyr Exp $	*/
@


1.39
log
@simplify the 'family' option parser and make it more evident what we're
now doing.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.38 2009/06/04 18:06:35 pyr Exp $	*/
d310 1
d312 1
a312 1
				if (!strncmp(cp, "inet6", strlen("inet6"))) {
d314 2
a315 3
					cp += strlen("inet6");
				} else if (!strncmp(cp, "inet4",
				     strlen("inet4"))) {
d317 1
a317 1
					cp += strlen("inet4");
@


1.38
log
@Add a resolv.conf option to specify the order in which getaddrinfo
PF_UNSPEC queries are made. While there change the default from inet6
first then inet4 to inet4 first then inet6, this prevents the many
people with IPv4 only connectivity from constantly trying to contact
IPv6 addresses, and also unbreaks many ports who don't use getaddrinfo
right.

ok deraadt@@, plenty of cheering in the room wrt the idea, not loud
enough complaining from the v6 crowd.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.37 2008/08/15 14:57:20 djm Exp $	*/
d284 3
d318 3
d330 5
@


1.37
log
@Add resolv.conf(5) option to force lookups by TCP: "options tcp"

Also Extend "nameserver" declaration syntax to support port
numbers.  To avoid ambiguity these are only parsed when the address
is enclosed in square brackets, e.g. "nameserver [127.0.0.1]:5353"

Together these changes make forwarding DNS over a SSH tunnel very
easy, but unfortunately some programs in ports/ implement their
own resolvers (e.g. firefox). These will need to be modified to
support these options separately.

fixes jsing@@ reyk@@
ok deraadt@@ millert@@ krw@@ + "I like it" from lots
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.36 2007/08/05 16:11:09 ray Exp $	*/
d168 1
d300 27
@


1.36
log
@/*FALLTHRU*/ -> /* FALLTHROUGH */
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.35 2006/09/23 04:56:43 ray Exp $	*/
a378 1
#ifdef INET6
a381 3
#else
		    struct in_addr a;
#endif /* INET6 */
a385 1
#ifdef INET6
d394 17
a413 1
		    snprintf(pbuf, sizeof(pbuf), "%u", NAMESERVER_PORT);
a434 11
#else /* INET6 */
		    if ((*cp != '\0') && (*cp != '\n') && inet_aton(cp, &a)) {
			_resp->nsaddr_list[nserv].sin_addr = a;
			_resp->nsaddr_list[nserv].sin_family = AF_INET;
			_resp->nsaddr_list[nserv].sin_port =
				htons(NAMESERVER_PORT);
			_resp->nsaddr_list[nserv].sin_len =
				sizeof(struct sockaddr_in);
			nserv++;
		    }
#endif /* INET6 */
d644 2
@


1.35
log
@If fgetln() != NULL, len == 0 is impossible, so remove check.

OK otto@@ and jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.34 2005/12/22 06:52:11 tedu Exp $	*/
d509 1
a509 1
				/*FALLTHRU*/
@


1.34
log
@handle chroot and res_init calls better.  diagnosis assistance from otto.
ok deraadt otto.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.33 2005/08/06 20:30:04 espie Exp $	*/
d289 2
a290 2
		/* skip lines that are too long or zero length */
		if (len >= sizeof(buf) || len == 0)
@


1.33
log
@zap rcsid.
split functions off res_debug.c so that getnetnamadr.c does not pull it
all when it's used.

okay deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.32 2005/03/30 02:58:28 tedu Exp $	*/
d181 7
a187 3
	if (usercall == 0) {
		if (_resp->options & RES_INIT &&
		    _resp->reschktime >= time(NULL))
d189 10
a198 17
		_resp->reschktime = time(NULL) + __res_chktime;
		if (stat(_PATH_RESCONF, &sb) != -1) {
			if (timespeccmp(&sb.st_mtimespec,
			    &_resp->restimespec, ==))
				return (0);
			else
				_resp->restimespec = sb.st_mtimespec;
		} else {
			/*
			 * Lost the file, in chroot?
			 * Don' trash settings
			 */
			if (timespecisset(&_resp->restimespec))
				return (0);
		}
	} else
		_resp->reschktime = time(NULL) + __res_chktime;
@


1.32
log
@make the resolver stat resolv.conf and update if it changes.
useful feedback and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.31 2005/03/25 13:24:12 otto Exp $	*/
a56 9

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)res_init.c	8.1 (Berkeley) 6/7/93";
static char rcsid[] = "$From: res_init.c,v 8.7 1996/09/28 06:51:07 vixie Exp $";
#else
static char rcsid[] = "$OpenBSD: res_init.c,v 1.31 2005/03/25 13:24:12 otto Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.31
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.30 2004/06/07 21:11:23 marc Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.30 2004/06/07 21:11:23 marc Exp $";
d71 1
d135 2
d161 8
d189 23
@


1.30
log
@
major bump to libc and libpthread to break the dependency of a
particular implementation of libpthread for libc.  libc no longer
needs pthread.h to compile.
OK millert@@, brad@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.29 2003/06/02 20:18:36 millert Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.29 2003/06/02 20:18:36 millert Exp $";
d156 1
a156 1
res_init()
d163 3
a165 3
	register FILE *fp;
	register char *cp, **pp;
	register int n;
d574 1
a574 2
res_setoptions(options, source)
	char *options, *source;
d634 1
a634 2
net_mask(in)		/* XXX - should really use system's version of this */
	struct in_addr in;
d636 1
a636 1
	register u_int32_t i = ntohl(in.s_addr);
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.28 2003/01/28 04:58:00 marc Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.28 2003/01/28 04:58:00 marc Exp $";
d121 1
a121 3
volatile struct _thread_private_key_struct __THREAD_KEY_NAME(_res) = {
	PTHREAD_ONCE_INIT, 0
};
d129 1
a129 3
volatile struct _thread_private_key_struct __THREAD_KEY_NAME(_res_ext) = {
	PTHREAD_ONCE_INIT, 0
};
@


1.28
log
@
thread safer libc (note: safer, not safe)
Access to the global _res structure replaced by pointers to a
per thread instance.  If unthreaded the pointer is to the
global structure.

Also replaced a 64k stack array with malloc-ed memory so
threaded aps (with a default 64k stack) have a chance at working.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.27 2002/07/25 21:13:45 deraadt Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.27 2002/07/25 21:13:45 deraadt Exp $";
@


1.27
log
@kill more strcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.26 2002/06/27 10:14:02 itojun Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.26 2002/06/27 10:14:02 itojun Exp $";
d89 2
d125 3
d135 4
d166 5
d206 6
a211 6
	if (!_res.retrans)
		_res.retrans = RES_TIMEOUT;
	if (!_res.retry)
		_res.retry = 4;
	if (!(_res.options & RES_INIT))
		_res.options = RES_DEFAULT;
d214 1
a214 1
	_res.nsaddr.sin_addr = inet_makeaddr(IN_LOOPBACKNET, 1);
d216 1
a216 1
	_res.nsaddr.sin_addr.s_addr = INADDR_ANY;
d218 3
a220 3
	_res.nsaddr.sin_family = AF_INET;
	_res.nsaddr.sin_port = htons(NAMESERVER_PORT);
	_res.nsaddr.sin_len = sizeof(struct sockaddr_in);
d222 2
a223 2
	if (sizeof(_res_ext.nsaddr) >= _res.nsaddr.sin_len)
		memcpy(&_res_ext.nsaddr, &_res.nsaddr, _res.nsaddr.sin_len);
d225 4
a228 4
	_res.nscount = 1;
	_res.ndots = 1;
	_res.pfcode = 0;
	strlcpy(_res.lookups, "f", sizeof _res.lookups);
d232 1
a232 1
		strlcpy(_res.defdname, cp, sizeof(_res.defdname));
d242 2
a243 2
		cp = _res.defdname;
		pp = _res.dnsrch;
d245 1
a245 1
		for (n = 0; *cp && pp < _res.dnsrch + MAXDNSRCH; cp++) {
d270 1
a270 1
	    strlcpy(_res.lookups, "bf", sizeof _res.lookups);
d294 2
a295 2
		    strlcpy(_res.defdname, cp, sizeof(_res.defdname));
		    if ((cp = strpbrk(_res.defdname, " \t\n")) != NULL)
d304 1
a304 1
		    bzero(_res.lookups, sizeof _res.lookups);
d312 1
a312 1
						    _res.lookups[n++] = *sp;
d319 1
a319 1
						    _res.lookups[n++] = *sp;
d336 2
a337 2
		    strlcpy(_res.defdname, cp, sizeof(_res.defdname));
		    if ((cp = strchr(_res.defdname, '\n')) != NULL)
d343 2
a344 2
		    cp = _res.defdname;
		    pp = _res.dnsrch;
d346 1
a346 1
		    for (n = 0; *cp && pp < _res.dnsrch + MAXDNSRCH; cp++) {
d392 2
a393 2
			if (res->ai_addrlen <= sizeof(_res_ext.nsaddr_list[nserv])) {
			    memcpy(&_res_ext.nsaddr_list[nserv], res->ai_addr,
d396 2
a397 2
			    memset(&_res_ext.nsaddr_list[nserv], 0,
				sizeof(_res_ext.nsaddr_list[nserv]));
d399 2
a400 2
			if (res->ai_addrlen <= sizeof(_res.nsaddr_list[nserv])) {
			    memcpy(&_res.nsaddr_list[nserv], res->ai_addr,
d403 2
a404 2
			    memset(&_res.nsaddr_list[nserv], 0,
				sizeof(_res.nsaddr_list[nserv]));
d412 3
a414 3
			_res.nsaddr_list[nserv].sin_addr = a;
			_res.nsaddr_list[nserv].sin_family = AF_INET;
			_res.nsaddr_list[nserv].sin_port =
d416 1
a416 1
			_res.nsaddr_list[nserv].sin_len =
d445 1
a445 1
			    _res.sort_list[nsort].addr = a;
d455 1
a455 1
				    _res.sort_list[nsort].mask = a.s_addr;
d457 2
a458 2
				    _res.sort_list[nsort].mask = 
					net_mask(_res.sort_list[nsort].addr);
d461 2
a462 2
				_res.sort_list[nsort].mask = 
				    net_mask(_res.sort_list[nsort].addr);
d465 5
a469 5
			    _res_ext.sort_list[nsort].af = AF_INET;
			    _res_ext.sort_list[nsort].addr.ina =
				_res.sort_list[nsort].addr;
			    _res_ext.sort_list[nsort].mask.ina.s_addr =
				_res.sort_list[nsort].mask;
d475 3
a477 3
			    _res_ext.sort_list[nsort].af = AF_INET6;
			    _res_ext.sort_list[nsort].addr.in6a = a6;
			    u = (u_char *)&_res_ext.sort_list[nsort].mask.in6a;
d527 1
a527 1
		_res.nscount = nserv;
d529 1
a529 1
	    _res.nsort = nsort;
d533 2
a534 2
	if (_res.defdname[0] == 0 &&
	    gethostname(buf, sizeof(_res.defdname) - 1) == 0 &&
d537 2
a538 2
		strlcpy(_res.defdname, cp + 1,
		        sizeof(_res.defdname));
d543 2
a544 2
		pp = _res.dnsrch;
		*pp++ = _res.defdname;
d549 1
a549 1
		for (cp = _res.defdname; *cp; cp++)
d552 2
a553 2
		cp = _res.defdname;
		while (pp < _res.dnsrch + MAXDFLSRCH) {
d562 1
a562 1
		if (_res.options & RES_DEBUG) {
d564 1
a564 1
			for (pp = _res.dnsrch; *pp; pp++)
d573 1
a573 1
		_res.options |= RES_NOALIASES;
d576 1
a576 1
	_res.options |= RES_INIT;
d585 1
d591 1
a591 1
	if (_res.options & RES_DEBUG)
d606 1
a606 1
					_res.ndots = l;
d608 1
a608 1
					_res.ndots = RES_MAXNDOTS;
d610 2
a611 2
				if (_res.options & RES_DEBUG)
					printf(";;\tndots=%u\n", _res.ndots);
d616 1
a616 1
			if (!(_res.options & RES_DEBUG)) {
d619 1
a619 1
				_res.options |= RES_DEBUG;
d624 1
a624 1
			_res.options |= RES_USE_INET6;
d626 1
a626 1
			_res.options |= RES_INSECURE1;
d628 1
a628 1
			_res.options |= RES_INSECURE2;
d630 1
a630 1
			_res.options |= RES_USE_EDNS0;
@


1.26
log
@%d -> %u.  mostly in #ifdef DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.25 2002/02/16 21:27:23 millert Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.25 2002/02/16 21:27:23 millert Exp $";
d214 1
a214 1
	strncpy(_res.lookups, "f", sizeof _res.lookups);
d256 1
a256 1
	    strncpy(_res.lookups, "bf", sizeof _res.lookups);
@


1.25
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.24 2001/09/14 23:49:29 itojun Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.24 2001/09/14 23:49:29 itojun Exp $";
d374 1
a374 1
		    snprintf(pbuf, sizeof(pbuf), "%d", NAMESERVER_PORT);
d596 1
a596 1
					printf(";;\tndots=%d\n", _res.ndots);
@


1.24
log
@add "options insecure[12]" support for /etc/resolv.conf.
insecure1 is necessary for IPv6 dynamic DNS server discovery,
draft-ietf-ipngwg-dns-discovery-02.txt.  sync with kame.
ok'ed by angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.23 2001/06/30 00:50:21 itojun Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.23 2001/06/30 00:50:21 itojun Exp $";
d112 1
a112 1
static void res_setoptions __P((char *, char *));
d117 1
a117 1
static u_int32_t net_mask __P((struct in_addr));
@


1.23
log
@missing freeaddrinfo().  PR 1907
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.22 2001/06/27 00:58:55 lebel Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.22 2001/06/27 00:58:55 lebel Exp $";
d610 4
@


1.22
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.21 2001/06/11 10:06:00 itojun Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.21 2001/06/11 10:06:00 itojun Exp $";
d375 1
d394 2
@


1.21
log
@support EDNS0 (RFC2671) buffer size notification on DNS queries.
"options edns0" in /etc/resolv.conf will enable the behavior.  no behavior
change if you don't have the line.  see resolv.conf(5) for more details.

EDNS0 is useful for avoiding TCP DNS queries/replies on larger DNS responses.
also, draft-ietf-dnsext-message-size-* plans to mandate EDNS0 support for DNS
clients that support IPv6 transport.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.20 2000/11/10 15:33:04 provos Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.20 2000/11/10 15:33:04 provos Exp $";
d218 1
a218 2
		(void)strncpy(_res.defdname, cp, sizeof(_res.defdname) - 1);
		_res.defdname[sizeof(_res.defdname) - 1] = '\0';
d280 1
a280 2
		    strncpy(_res.defdname, cp, sizeof(_res.defdname) - 1);
		    _res.defdname[sizeof(_res.defdname) - 1] = '\0';
d322 1
a322 2
		    strncpy(_res.defdname, cp, sizeof(_res.defdname) - 1);
		    _res.defdname[sizeof(_res.defdname) - 1] = '\0';
d520 2
a521 3
		strncpy(_res.defdname, cp + 1,
		        sizeof(_res.defdname) - 1);
		_res.defdname[sizeof(_res.defdname) - 1] = '\0';
@


1.20
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.19 2000/06/22 07:31:18 itojun Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.19 2000/06/22 07:31:18 itojun Exp $";
d611 2
@


1.19
log
@ipv6 support in resolver.  "nameserver" line in /etc/resolv.conf now takes
ipv6 address.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.18 1999/09/03 21:14:51 deraadt Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.18 1999/09/03 21:14:51 deraadt Exp $";
d107 1
a107 1
 *   should be seperated by a slash (/) or ampersand (&) character.
@


1.18
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.17 1999/09/03 16:23:19 millert Exp $	*/
d58 4
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.17 1999/09/03 16:23:19 millert Exp $";
d85 3
d129 3
d206 5
d354 5
d360 1
d365 32
d402 2
d406 1
d412 5
d450 49
d501 1
@


1.17
log
@Use strtol() and strtoul() instead of atoi().  This allows us to catch
errors reasonably and deal correctly with unsigned quantities.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.16 1998/03/16 05:07:01 millert Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.16 1998/03/16 05:07:01 millert Exp $";
d479 1
a479 1
			    (*endp = '\0' || issapce(*endp))) {
@


1.16
log
@Use fgetln(3) instead of fgets(3) so we can easily recognize lines
that are too long and ignore them instead of corrupting later entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.15 1997/07/15 18:33:50 flipk Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.15 1997/07/15 18:33:50 flipk Exp $";
d462 2
a463 1
	int i;
d476 8
a483 5
			i = atoi(cp + sizeof("ndots:") - 1);
			if (i <= RES_MAXNDOTS)
				_res.ndots = i;
			else
				_res.ndots = RES_MAXNDOTS;
d485 2
a486 2
			if (_res.options & RES_DEBUG)
				printf(";;\tndots=%d\n", _res.ndots);
d488 1
@


1.15
log
@buff overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.14 1997/04/13 21:30:43 provos Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.14 1997/04/13 21:30:43 provos Exp $";
d154 1
d245 7
a251 1
	    while (fgets(buf, sizeof(buf), fp) != NULL) {
d253 3
a255 1
		if (*buf == ';' || *buf == '#')
@


1.14
log
@the before mentioned random number generator.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.13 1997/04/05 21:13:17 millert Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.13 1997/04/05 21:13:17 millert Exp $";
d402 5
a406 1
		strcpy(_res.defdname, cp + 1);
@


1.13
log
@Use in_addr_t not u_long and use in_port_t in some cases instead
of u_short or u_int16_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.12 1997/04/03 05:53:46 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.12 1997/04/03 05:53:46 deraadt Exp $";
a187 7
	/*
	 * This one used to initialize implicitly to zero, so unless the app
	 * has set it to something in particular, we can randomize it now.
	 */
	if (!_res.id)
		_res.id = res_randomid();

a505 6

u_int
res_randomid()
{
	return (0xffff & arc4random());
}
@


1.12
log
@use MATCH()
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.11 1997/03/13 19:07:38 downsj Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.11 1997/03/13 19:07:38 downsj Exp $";
d517 1
a517 4
	struct timeval now;

	gettimeofday(&now, NULL);
	return (0xffff & (now.tv_sec ^ now.tv_usec ^ getpid()));
@


1.11
log
@Integrate BIND 4.9.5 resolver and associated routines.

Includes the DNS aware getnetby*() routines and IPv6 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.1 1997/03/12 10:42:09 downsj Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.1 1997/03/12 10:42:09 downsj Exp $";
d272 1
a272 1
		if (!strncmp(buf, "lookup", sizeof("lookup") -1)) {
@


1.10
log
@cannot be static, named uses it
@
text
@d1 5
a5 1
/*-
d7 2
a8 2
 *	The Regents of the University of California.  All rights reserved.
 *
d19 2
a20 2
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
d24 1
a24 1
 *
d59 6
a64 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.9 1996/09/22 05:14:05 deraadt Exp $";
d67 1
d70 1
d74 3
a78 1
#include <stdio.h>
d82 23
d106 4
d111 1
d114 1
a114 1
 * Resolver state default settings
d117 5
a121 6
struct __res_state _res = {
	RES_TIMEOUT,               	/* retransmition time interval */
	4,                         	/* number of times to retransmit */
	RES_DEFAULT,			/* options flags */
	1,                         	/* number of name servers */
};
d148 1
a148 1
	register char *cp, **pp, *net;
d150 1
a150 1
	char buf[BUFSIZ], buf2[BUFSIZ];
d154 1
d156 5
d162 31
a192 1
	if (_res.id == 0)
a194 3
	_res.nsaddr.sin_len = sizeof(struct sockaddr_in);
	_res.nsaddr.sin_family = AF_INET;
	_res.nsaddr.sin_port = htons(NAMESERVER_PORT);
d200 2
a210 2
		if ((cp = strpbrk(_res.defdname, " \t\n")) != NULL)
			*cp = '\0';
d224 1
a224 1
			if (*cp == '\n')        /* silly backwards compat */
d242 5
d253 1
a253 1
		if ((*buf == ';') || (*buf == '#'))
d256 1
a256 1
		if (!strncmp(buf, "domain", sizeof("domain") - 1)) {
d264 1
a264 2
		    (void)strncpy(_res.defdname, cp,
				  sizeof(_res.defdname) - 1);
d299 1
a299 1
		if (!strncmp(buf, "search", sizeof("search") - 1)) {
d307 1
a307 2
		    (void)strncpy(_res.defdname, cp,
				  sizeof(_res.defdname) - 1);
d336 2
a337 3
		if (!strncmp(buf, "nameserver", sizeof("nameserver") - 1) &&
		   nserv < MAXNS) {
		   struct in_addr a;
d343 1
a343 1
			_res.nsaddr_list[nserv].sin_len = sizeof(struct sockaddr_in);
a346 1
			_res.nsaddr_list[nserv].sin_addr = a;
d351 2
a352 1
		if (!strncmp(buf, "sortlist", sizeof("sortlist") - 1)) {
d356 12
a367 6
		    while (*cp == ' ' || *cp == '\t')
			cp++;
		    while (sscanf(cp,"%[0-9./]s", buf2) && nsort < MAXRESOLVSORT) {
			if (net = strchr(buf2, '/'))
			    *net = '\0';
			if (inet_aton(buf2, &a)) {
d369 14
a382 2
			    if (net && inet_aton(net+1, &a)) {
				_res.sort_list[nsort].mask = a.s_addr;
d384 2
a385 2
				_res.sort_list[nsort].mask =
					net_mask(_res.sort_list[nsort].addr);
d389 1
a389 5
			if (net)
				*net = '/';
			cp += strlen(buf2);
			while (*cp == ' ' || *cp == '\t')
			    cp++;
d393 2
a394 1
		if (!strncmp(buf, "options", sizeof("options") -1)) {
d401 1
d403 1
d406 4
a409 5
	if (_res.defdname[0] == 0) {
		if (gethostname(buf, sizeof(_res.defdname) - 1) == 0 &&
		   (cp = strchr(buf, '.')))
			(void)strcpy(_res.defdname, cp + 1);
	}
a414 1
#ifndef SEARCH_LOCAL_DOMAINS
d416 6
a421 4
#else
		for (cp = _res.defdname, n = 0; *cp; cp++)
			if (*cp == '.')
				n++;
d423 6
a428 4
		for (; n >= LOCALDOMAINPARTS && pp < _res.dnsrch + MAXDFLSRCH;
		    n--) {
			cp = strchr(cp, '.');
			*pp++ = ++cp;
d430 10
a439 2
		*pp++ = 0;
#endif
d459 1
a459 1
	if (_res.options & RES_DEBUG) {
a461 1
	}
d468 1
a468 1
		if (!strncmp(cp, "ndots:", sizeof("ndots:")-1)) {
d475 1
a475 1
			if (_res.options & RES_DEBUG) {
a476 1
			}
d478 1
a478 1
		} else if (!strncmp(cp, "debug", sizeof("debug")-1)) {
d487 2
d498 2
d508 1
a508 1
	if (IN_CLASSB(i))
d512 1
d514 1
a514 1
u_int16_t
@


1.9
log
@random function name
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.8 1996/09/22 02:18:44 deraadt Exp $";
d409 1
a409 1
static u_int16_t
@


1.8
log
@randomize _res.id at start; could do better i hope
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.7 1996/09/15 09:31:19 tholo Exp $";
a70 1
static u_int16_t res_randomid __P((void));
d410 1
a410 1
__res_randomid()
@


1.7
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.6 1996/08/27 03:32:53 deraadt Exp $";
d71 1
d117 3
d410 2
a411 2
u_int16_t
res_randomid()
@


1.6
log
@use strncpy correctly
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.5 1996/08/25 10:11:02 deraadt Exp $";
a114 2
	int dots;
	u_long mask;
d345 1
@


1.5
log
@use issetugid()
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.4 1996/08/19 08:29:45 tholo Exp $";
d134 1
d187 1
d231 1
@


1.4
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: res_init.c,v 1.9 1996/02/02 15:22:30 mrg Exp $";
a116 1
	int notsuid = (getuid() == geteuid());
d132 1
a132 1
	if (notsuid && (cp = getenv("LOCALDOMAIN")) != NULL) {
d336 3
a338 1
	if (notsuid && (cp = getenv("RES_OPTIONS")) != NULL)
@


1.3
log
@if setuid, no env variables
@
text
@a0 2
/*	$NetBSD: res_init.c,v 1.9 1996/02/02 15:22:30 mrg Exp $	*/

d55 1
a55 6
#if 0
static char sccsid[] = "@@(#)res_init.c	8.1 (Berkeley) 6/7/93";
static char rcsid[] = "$Id: res_init.c,v 8.3 1995/06/29 09:26:28 vixie Exp ";
#else
static char rcsid[] = "$NetBSD: res_init.c,v 1.9 1996/02/02 15:22:30 mrg Exp $";
#endif
@


1.2
log
@netbsd: bind 4.9.3
@
text
@d124 1
d140 1
a140 1
	if ((cp = getenv("LOCALDOMAIN")) != NULL) {
d344 1
a344 1
	if ((cp = getenv("RES_OPTIONS")) != NULL)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: res_init.c,v 1.8 1995/06/03 22:33:36 mycroft Exp $	*/
d59 1
a59 1
static char rcsid[] = "$Id: res_init.c,v 4.9.1.1 1993/05/02 22:43:03 vixie Rel ";
d61 1
a61 1
static char rcsid[] = "$NetBSD: res_init.c,v 1.8 1995/06/03 22:33:36 mycroft Exp $";
d95 13
a107 2
 * The configuration file should only be used if you want to redefine your
 * domain or run without a server on your machine.
d111 1
d122 1
d407 9
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

