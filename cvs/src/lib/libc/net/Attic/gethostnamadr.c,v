head	1.74;
access;
symbols
	OPENBSD_5_4:1.73.0.16
	OPENBSD_5_4_BASE:1.73
	OPENBSD_5_3:1.73.0.14
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.73.0.12
	OPENBSD_5_2_BASE:1.73
	OPENBSD_5_1_BASE:1.73
	OPENBSD_5_1:1.73.0.10
	OPENBSD_5_0:1.73.0.8
	OPENBSD_5_0_BASE:1.73
	OPENBSD_4_9:1.73.0.6
	OPENBSD_4_9_BASE:1.73
	OPENBSD_4_8:1.73.0.4
	OPENBSD_4_8_BASE:1.73
	OPENBSD_4_7:1.73.0.2
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.72.0.10
	OPENBSD_4_6_BASE:1.72
	OPENBSD_4_5:1.72.0.6
	OPENBSD_4_5_BASE:1.72
	OPENBSD_4_4:1.72.0.4
	OPENBSD_4_4_BASE:1.72
	OPENBSD_4_3:1.72.0.2
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.71.0.2
	OPENBSD_4_2_BASE:1.71
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.68.0.6
	OPENBSD_4_0_BASE:1.68
	OPENBSD_3_9:1.68.0.4
	OPENBSD_3_9_BASE:1.68
	OPENBSD_3_8:1.68.0.2
	OPENBSD_3_8_BASE:1.68
	OPENBSD_3_7:1.60.0.4
	OPENBSD_3_7_BASE:1.60
	OPENBSD_3_6:1.60.0.2
	OPENBSD_3_6_BASE:1.60
	OPENBSD_3_5:1.59.0.2
	OPENBSD_3_5_BASE:1.59
	OPENBSD_3_4:1.57.0.2
	OPENBSD_3_4_BASE:1.57
	OPENBSD_3_3:1.55.0.2
	OPENBSD_3_3_BASE:1.55
	OPENBSD_3_2:1.53.0.2
	OPENBSD_3_2_BASE:1.53
	OPENBSD_3_1:1.45.0.2
	OPENBSD_3_1_BASE:1.45
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9:1.42.0.4
	OPENBSD_2_9_BASE:1.42
	OPENBSD_2_8:1.42.0.2
	OPENBSD_2_8_BASE:1.42
	OPENBSD_2_7:1.41.0.2
	OPENBSD_2_7_BASE:1.41
	OPENBSD_2_6:1.37.0.2
	OPENBSD_2_6_BASE:1.37
	OPENBSD_2_5:1.31.0.2
	OPENBSD_2_5_BASE:1.31
	OPENBSD_2_4:1.30.0.4
	OPENBSD_2_4_BASE:1.30
	OPENBSD_2_3:1.30.0.2
	OPENBSD_2_3_BASE:1.30
	OPENBSD_2_2:1.26.0.2
	OPENBSD_2_2_BASE:1.26
	OPENBSD_2_1:1.25.0.2
	OPENBSD_2_1_BASE:1.25
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2013.11.12.20.37.15;	author eric;	state dead;
branches;
next	1.73;

1.73
date	2009.11.18.07.43.22;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.11.18.36.41;	author jakob;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.16.04.14.23;	author ray;	state Exp;
branches;
next	1.70;

1.70
date	2007.02.18.20.38.28;	author ray;	state Exp;
branches;
next	1.69;

1.69
date	2007.02.14.10.26.35;	author itojun;	state Exp;
branches;
next	1.68;

1.68
date	2005.08.06.20.30.03;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2005.07.27.14.16.43;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2005.07.27.13.40.28;	author jaredy;	state Exp;
branches;
next	1.65;

1.65
date	2005.07.24.18.47.59;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2005.07.23.04.15.49;	author jaredy;	state Exp;
branches;
next	1.63;

1.63
date	2005.06.08.18.32.34;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2005.05.02.17.38.41;	author moritz;	state Exp;
branches;
next	1.61;

1.61
date	2005.03.30.02.58.28;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2004.07.29.03.09.40;	author itojun;	state Exp;
branches;
next	1.59;

1.59
date	2003.10.06.19.18.09;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2003.10.03.19.48.10;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.27.22.23.05;	author vincent;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.02.20.18.35;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2003.03.04.00.29.17;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.28.04.58.00;	author marc;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.27.08.53.13;	author itojun;	state Exp;
branches;
next	1.52;

1.52
date	2002.08.22.16.35.37;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.30.00.45.19;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2002.07.29.10.15.30;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.25.21.13.45;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.26.06.00.53;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2002.05.22.04.31.14;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.18.00.06.42;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.17.19.42.23;	author millert;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.27.00.58.55;	author lebel;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2000.07.30.14.07.14;	author itojun;	state Exp;
branches
	1.42.4.1;
next	1.41;

1.41
date	2000.01.06.08.24.17;	author d;	state Exp;
branches;
next	1.40;

1.40
date	2000.01.03.11.51.07;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	99.12.11.08.40.17;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	99.12.11.08.32.20;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	99.09.03.18.12.31;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	99.07.03.18.07.53;	author jakob;	state Exp;
branches;
next	1.35;

1.35
date	99.06.04.06.38.10;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	99.05.30.14.20.29;	author niklas;	state Exp;
branches;
next	1.33;

1.33
date	99.05.30.14.06.07;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	99.04.28.19.13.35;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	98.11.20.11.18.44;	author d;	state Exp;
branches;
next	1.30;

1.30
date	98.03.16.05.06.55;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	98.01.20.18.28.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.01.11.19.32.10;	author weingart;	state Exp;
branches;
next	1.27;

1.27
date	97.11.08.20.46.56;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.07.09.01.08.26;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	97.04.29.19.28.38;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.04.29.19.15.46;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.04.27.22.20.47;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.04.15.11.27.56;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.04.14.06.57.44;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.04.13.01.50.21;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.04.03.08.33.03;	author downsj;	state Exp;
branches;
next	1.18;

1.18
date	97.04.03.07.54.01;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.04.03.05.53.23;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.04.03.05.52.35;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.04.02.08.22.35;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.03.13.19.07.24;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	97.01.30.05.56.06;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.09.28.13.26.34;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.09.27.18.50.04;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.09.27.18.37.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.09.26.09.13.21;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.15.10.09.12;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.08.19.08.28.40;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.08.05.15.58.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.24.12.55.31;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.03.25.22.06.52;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.02.19.19.53.21;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	95.11.20.09.34.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.02;	author deraadt;	state Exp;
branches;
next	;

1.42.4.1
date	2002.06.26.06.02.54;	author millert;	state Exp;
branches;
next	;

1.43.2.1
date	2002.06.26.06.03.31;	author millert;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2002.09.09.18.25.08;	author miod;	state Exp;
branches;
next	;

1.45.2.1
date	2002.06.26.06.03.49;	author millert;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2002.09.06.05.46.51;	author jason;	state Exp;
branches;
next	;


desc
@@


1.74
log
@remove dead files

ok deraadt@@
@
text
@/*	$OpenBSD: gethostnamadr.c,v 1.73 2009/11/18 07:43:22 guenther Exp $ */
/*-
 * Copyright (c) 1985, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>
#include <resolv.h>
#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <syslog.h>
#include <stdlib.h>
#ifdef YP
#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include "ypinternal.h"
#endif
#include "thread_private.h"

#define MULTI_PTRS_ARE_ALIASES 1	/* XXX - experimental */

#define	MAXALIASES	35
#define	MAXADDRS	35

static char *h_addr_ptrs[MAXADDRS + 1];

#ifdef YP
static char *__ypdomain;
#endif

static struct hostent host;
static char *host_aliases[MAXALIASES];
static char hostbuf[BUFSIZ+1];
static union {
	struct in_addr _host_in_addr;
	u_char _host_addr[16];		/* IPv4 or IPv6 */
} _host_addr_u;
#define host_addr _host_addr_u._host_addr
static FILE *hostf = NULL;
static int stayopen = 0;

static void map_v4v6_address(const char *src, char *dst);
static void map_v4v6_hostent(struct hostent *hp, char **bp, char *);

#ifdef RESOLVSORT
static void addrsort(char **, int);
#endif

int _hokchar(const char *);

static const char AskedForGot[] =
			  "gethostby*.getanswer: asked for \"%s\", got \"%s\"";

#define	MAXPACKET	(64*1024)

typedef union {
	HEADER hdr;
	u_char buf[MAXPACKET];
} querybuf;

typedef union {
	int32_t al;
	char ac;
} align;

static struct hostent *getanswer(const querybuf *, int, const char *, int);

extern int h_errno;

int
_hokchar(const char *p)
{
	char c;

	/*
	 * Many people do not obey RFC 822 and 1035.  The valid
	 * characters are a-z, A-Z, 0-9, '-' and . But the others
	 * tested for below can happen, and we must be more permissive
	 * than the resolver until those idiots clean up their act.
	 * We let '/' through, but not '..'
	 */
	while ((c = *p++)) {
		if (('a' <= c && c <= 'z') ||
		    ('A' <= c && c <= 'Z') ||
		    ('0' <= c && c <= '9'))
			continue;
		if (strchr("-_/", c))
			continue;
		if (c == '.' && *p != '.')
			continue;
		return 0;
	}
	return 1;
}

static struct hostent *
getanswer(const querybuf *answer, int anslen, const char *qname, int qtype)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	const HEADER *hp;
	const u_char *cp, *eom;
	char tbuf[MAXDNAME];
	char *bp, **ap, **hap, *ep;
	int type, class, ancount, qdcount, n;
	int haveanswer, had_error, toobig = 0;
	const char *tname;
	int (*name_ok)(const char *);

	tname = qname;
	host.h_name = NULL;
	eom = answer->buf + anslen;
	switch (qtype) {
	case T_A:
	case T_AAAA:
#ifdef USE_RESOLV_NAME_OK
		name_ok = res_hnok;
		break;
#endif
	case T_PTR:
#ifdef USE_RESOLV_NAME_OK
		name_ok = res_dnok;
#else
		name_ok = _hokchar;
#endif
		break;
	default:
		return (NULL);
	}
	/*
	 * find first satisfactory answer
	 */
	hp = &answer->hdr;
	ancount = ntohs(hp->ancount);
	qdcount = ntohs(hp->qdcount);
	bp = hostbuf;
	ep = hostbuf + sizeof hostbuf;
	cp = answer->buf + HFIXEDSZ;
	if (qdcount != 1) {
		h_errno = NO_RECOVERY;
		return (NULL);
	}
	n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
	if ((n < 0) || !(*name_ok)(bp)) {
		h_errno = NO_RECOVERY;
		return (NULL);
	}
	cp += n + QFIXEDSZ;
	if (qtype == T_A || qtype == T_AAAA) {
		/* res_send() has already verified that the query name is the
		 * same as the one we sent; this just gets the expanded name
		 * (i.e., with the succeeding search-domain tacked on).
		 */
		host.h_name = bp;
		bp += strlen(bp) + 1;		/* for the \0 */
		/* The qname can be abbreviated, but h_name is now absolute. */
		qname = host.h_name;
	}
	ap = host_aliases;
	*ap = NULL;
	host.h_aliases = host_aliases;
	hap = h_addr_ptrs;
	*hap = NULL;
	host.h_addr_list = h_addr_ptrs;
	haveanswer = 0;
	had_error = 0;
	while (ancount-- > 0 && cp < eom && !had_error) {
		size_t len;

		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
		if ((n < 0) || !(*name_ok)(bp)) {
			had_error++;
			continue;
		}
		cp += n;			/* name */
		if (cp >= eom)
			break;
		type = _getshort(cp);
		cp += INT16SZ;			/* type */
		if (cp >= eom)
			break;
		class = _getshort(cp);
 		cp += INT16SZ + INT32SZ;	/* class, TTL */
		if (cp >= eom)
			break;
		n = _getshort(cp);
		cp += INT16SZ;			/* len */
		if (cp >= eom)
			break;
		if (type == T_SIG || type == T_RRSIG) {
			/* XXX - ignore signatures as we don't use them yet */
			cp += n;
			continue;
		}
		if (class != C_IN) {
			/* XXX - debug? syslog? */
			cp += n;
			continue;		/* XXX - had_error++ ? */
		}
		if ((qtype == T_A || qtype == T_AAAA) && type == T_CNAME) {
			if (ap >= &host_aliases[MAXALIASES-1])
				continue;
			n = dn_expand(answer->buf, eom, cp, tbuf, sizeof tbuf);
			if ((n < 0) || !(*name_ok)(tbuf)) {
				had_error++;
				continue;
			}
			cp += n;
			/* Store alias. */
			*ap++ = bp;
			bp += strlen(bp) + 1;	/* for the \0 */
			/* Get canonical name. */
			len = strlen(tbuf) + 1;	/* for the \0 */
			if (len > ep - bp) {
				had_error++;
				continue;
			}
			strlcpy(bp, tbuf, ep - bp);
			host.h_name = bp;
			bp += len;
			continue;
		}
		if (qtype == T_PTR && type == T_CNAME) {
			n = dn_expand(answer->buf, eom, cp, tbuf, sizeof tbuf);
#ifdef USE_RESOLV_NAME_OK
			if ((n < 0) || !res_hnok(tbuf)) {
#else
			if ((n < 0) || !_hokchar(tbuf)) {
#endif
				had_error++;
				continue;
			}
			cp += n;
			/* Get canonical name. */
			len = strlen(tbuf) + 1;	/* for the \0 */
			if (len > ep - bp) {
				had_error++;
				continue;
			}
			strlcpy(bp, tbuf, ep - bp);
			tname = bp;
			bp += len;
			continue;
		}
		if (type != qtype) {
#ifndef NO_LOG_BAD_DNS_RESPONSES
			syslog(LOG_NOTICE|LOG_AUTH,
	       "gethostby*.getanswer: asked for \"%s %s %s\", got type \"%s\"",
			       qname, p_class(C_IN), p_type(qtype),
			       p_type(type));
#endif /* NO_LOG_BAD_DNS_RESPONSES */
			cp += n;
			continue;		/* XXX - had_error++ ? */
		}
		switch (type) {
		case T_PTR:
			if (strcasecmp(tname, bp) != 0) {
				syslog(LOG_NOTICE|LOG_AUTH,
				       AskedForGot, qname, bp);
				cp += n;
				continue;	/* XXX - had_error++ ? */
			}
			n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
#ifdef USE_RESOLV_NAME_OK
			if ((n < 0) || !res_hnok(bp)) {
#else
			if ((n < 0) || !_hokchar(bp)) {
#endif
				had_error++;
				break;
			}
#if MULTI_PTRS_ARE_ALIASES
			cp += n;
			if (!haveanswer)
				host.h_name = bp;
			else if (ap < &host_aliases[MAXALIASES-1])
				*ap++ = bp;
			else
				n = -1;
			if (n != -1) {
				n = strlen(bp) + 1;	/* for the \0 */
				bp += n;
			}
			break;
#else
			host.h_name = bp;
			if (_resp->options & RES_USE_INET6) {
				n = strlen(bp) + 1;	/* for the \0 */
				bp += n;
				map_v4v6_hostent(&host, &bp, ep);
			}
			h_errno = NETDB_SUCCESS;
			return (&host);
#endif
		case T_A:
		case T_AAAA:
			if (strcasecmp(host.h_name, bp) != 0) {
				syslog(LOG_NOTICE|LOG_AUTH,
				       AskedForGot, host.h_name, bp);
				cp += n;
				continue;	/* XXX - had_error++ ? */
			}
			if (n != host.h_length) {
				cp += n;
				continue;
			}
			if (type == T_AAAA) {
				struct in6_addr in6;
				memcpy(&in6, cp, IN6ADDRSZ);
				if (IN6_IS_ADDR_V4MAPPED(&in6)) {
					cp += n;
					continue;
				}
			}
			if (!haveanswer) {
				host.h_name = bp;
				bp += strlen(bp) + 1;	/* for the \0 */
			}

			bp += sizeof(align) - ((u_long)bp % sizeof(align));

			if (bp + n >= &hostbuf[sizeof hostbuf]) {
#ifdef DEBUG
				if (_resp->options & RES_DEBUG)
					printf("size (%d) too big\n", n);
#endif
				had_error++;
				continue;
			}
			if (hap >= &h_addr_ptrs[MAXADDRS-1]) {
				if (!toobig++)
#ifdef DEBUG
					if (_resp->options & RES_DEBUG)
						printf("Too many addresses (%d)\n", MAXADDRS);
#endif
				cp += n;
				continue;
			}
			bcopy(cp, *hap++ = bp, n);
			bp += n;
			cp += n;
			break;
		}
		if (!had_error)
			haveanswer++;
	}
	if (haveanswer) {
		*ap = NULL;
		*hap = NULL;
# if defined(RESOLVSORT)
		/*
		 * Note: we sort even if host can take only one address
		 * in its return structures - should give it the "best"
		 * address in that case, not some random one
		 */
		if (_resp->nsort && haveanswer > 1 && qtype == T_A)
			addrsort(h_addr_ptrs, haveanswer);
# endif /*RESOLVSORT*/
		if (!host.h_name) {
			size_t len;

			len = strlen(qname) + 1;
			if (len > ep - bp)	/* for the \0 */
				goto try_again;
			strlcpy(bp, qname, ep - bp);
			host.h_name = bp;
			bp += len;
		}
		if (_resp->options & RES_USE_INET6)
			map_v4v6_hostent(&host, &bp, ep);
		h_errno = NETDB_SUCCESS;
		return (&host);
	}
 try_again:
	h_errno = TRY_AGAIN;
	return (NULL);
}

#ifdef notyet
/*
 * XXX This is an extremely bogus implementation.
 *
 * FreeBSD has this interface:
 *    int gethostbyaddr_r(const char *addr, int len, int type,
 *             struct hostent *result, struct hostent_data *buffer)
 */

struct hostent *
gethostbyname_r(const char *name, struct hostent *hp, char *buf, int buflen,
    int *errorp)
{
	struct hostent *res;

	res = gethostbyname(name);
	*errorp = h_errno;
	if (res == NULL)
		return NULL;
	memcpy(hp, res, sizeof *hp); /* XXX not sufficient */
	return hp;
}

/*
 * XXX This is an extremely bogus implementation.
 */
struct hostent *
gethostbyaddr_r(const char *addr, int len, int af, struct hostent *he,
    char *buf, int buflen, int *errorp)
{
	struct hostent * res;

	res = gethostbyaddr(addr, len, af);
	*errorp = h_errno;
	if (res == NULL)
		return NULL;
	memcpy(he, res, sizeof *he); /* XXX not sufficient */
	return he;
}

/* XXX RFC2133 expects a gethostbyname2_r() -- unimplemented */
#endif

struct hostent *
gethostbyname(const char *name)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	struct hostent *hp;
	extern struct hostent *_gethtbyname2(const char *, int);

	if (_res_init(0) == -1)
		hp = _gethtbyname2(name, AF_INET);

	else if (_resp->options & RES_USE_INET6) {
		hp = gethostbyname2(name, AF_INET6);
		if (hp == NULL)
			hp = gethostbyname2(name, AF_INET);
	}
	else
		hp = gethostbyname2(name, AF_INET);
	return hp;
}

struct hostent *
gethostbyname2(const char *name, int af)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	querybuf *buf;
	const char *cp;
	char *bp, *ep;
	int n, size, type, i;
	struct hostent *hp;
	char lookups[MAXDNSLUS];
	extern struct hostent *_gethtbyname2(const char *, int);
#ifdef YP
	extern struct hostent *_yp_gethtbyname(const char *);
#endif

	if (_res_init(0) == -1)
		return (_gethtbyname2(name, af));

	switch (af) {
	case AF_INET:
		size = INADDRSZ;
		type = T_A;
		break;
	case AF_INET6:
		size = IN6ADDRSZ;
		type = T_AAAA;
		break;
	default:
		h_errno = NETDB_INTERNAL;
		errno = EAFNOSUPPORT;
		return (NULL);
	}

	host.h_addrtype = af;
	host.h_length = size;

	/*
	 * if there aren't any dots, it could be a user-level alias.
	 * this is also done in res_query() since we are not the only
	 * function that looks up host names.
	 */
	if (!strchr(name, '.') && (cp = __hostalias(name)))
		name = cp;

	/*
	 * disallow names consisting only of digits/dots, unless
	 * they end in a dot.
	 */
	if (isdigit(name[0]))
		for (cp = name;; ++cp) {
			if (!*cp) {
				if (*--cp == '.')
					break;
				/*
				 * All-numeric, no dot at the end.
				 * Fake up a hostent as if we'd actually
				 * done a lookup.
				 */
				if (inet_pton(af, name, host_addr) <= 0) {
					h_errno = HOST_NOT_FOUND;
					return (NULL);
				}
				strlcpy(hostbuf, name, MAXHOSTNAMELEN);
				bp = hostbuf + MAXHOSTNAMELEN;
				ep = hostbuf + sizeof(hostbuf);
				host.h_name = hostbuf;
				host.h_aliases = host_aliases;
				host_aliases[0] = NULL;
				h_addr_ptrs[0] = (char *)host_addr;
				h_addr_ptrs[1] = NULL;
				host.h_addr_list = h_addr_ptrs;
				if (_resp->options & RES_USE_INET6)
					map_v4v6_hostent(&host, &bp, ep);
				h_errno = NETDB_SUCCESS;
				return (&host);
			}
			if (!isdigit(*cp) && *cp != '.') 
				break;
		}
	if ((isxdigit(name[0]) && strchr(name, ':') != NULL) ||
	    name[0] == ':')
		for (cp = name;; ++cp) {
			if (!*cp) {
				if (*--cp == '.')
					break;
				/*
				 * All-IPv6-legal, no dot at the end.
				 * Fake up a hostent as if we'd actually
				 * done a lookup.
				 */
				if (inet_pton(af, name, host_addr) <= 0) {
					h_errno = HOST_NOT_FOUND;
					return (NULL);
				}
				strlcpy(hostbuf, name, MAXHOSTNAMELEN);
				bp = hostbuf + MAXHOSTNAMELEN;
				ep = hostbuf + sizeof(hostbuf);
				host.h_name = hostbuf;
				host.h_aliases = host_aliases;
				host_aliases[0] = NULL;
				h_addr_ptrs[0] = (char *)host_addr;
				h_addr_ptrs[1] = NULL;
				host.h_addr_list = h_addr_ptrs;
				h_errno = NETDB_SUCCESS;
				return (&host);
			}
			if (!isxdigit(*cp) && *cp != ':' && *cp != '.') 
				break;
		}

	bcopy(_resp->lookups, lookups, sizeof lookups);
	if (lookups[0] == '\0')
		strlcpy(lookups, "bf", sizeof lookups);

	hp = (struct hostent *)NULL;
	for (i = 0; i < MAXDNSLUS && hp == NULL && lookups[i]; i++) {
		switch (lookups[i]) {
#ifdef YP
		case 'y':
			/* YP only supports AF_INET. */
			if (af == AF_INET)
				hp = _yp_gethtbyname(name);
			break;
#endif
		case 'b':
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			if ((n = res_search(name, C_IN, type, buf->buf,
			    sizeof(buf->buf))) < 0) {
				free(buf);
#ifdef DEBUG
				if (_resp->options & RES_DEBUG)
					printf("res_search failed\n");
#endif
				break;
			}
			hp = getanswer(buf, n, name, type);
			free(buf);
			break;
		case 'f':
			hp = _gethtbyname2(name, af);
			break;
		}
	}
	/* XXX h_errno not correct in all cases... */
	return (hp);
}

struct hostent *
gethostbyaddr(const void *addr, socklen_t len, int af)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	const u_char *uaddr = (const u_char *)addr;
	int n, size, i;
	querybuf *buf;
	struct hostent *hp;
	char qbuf[MAXDNAME+1], *qp, *ep;
	char lookups[MAXDNSLUS];
	struct hostent *res;
	extern struct hostent *_gethtbyaddr(const void *, socklen_t, int);
#ifdef YP
	extern struct hostent *_yp_gethtbyaddr(const void *);
#endif
	
	if (_res_init(0) == -1) {
		res = _gethtbyaddr(addr, len, af);
		return (res);
	}

	if (af == AF_INET6 && len == IN6ADDRSZ &&
	    (IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)uaddr) ||
	     IN6_IS_ADDR_SITELOCAL((struct in6_addr *)uaddr))) {
		h_errno = HOST_NOT_FOUND;
		return (NULL);
	}
	if (af == AF_INET6 && len == IN6ADDRSZ &&
	    (IN6_IS_ADDR_V4MAPPED((struct in6_addr *)uaddr) ||
	     IN6_IS_ADDR_V4COMPAT((struct in6_addr *)uaddr))) {
		/* Unmap. */
		uaddr += IN6ADDRSZ - INADDRSZ;
		af = AF_INET;
		len = INADDRSZ;
	}
	switch (af) {
	case AF_INET:
		size = INADDRSZ;
		break;
	case AF_INET6:
		size = IN6ADDRSZ;
		break;
	default:
		errno = EAFNOSUPPORT;
		h_errno = NETDB_INTERNAL;
		return (NULL);
	}
	if (size != len) {
		errno = EINVAL;
		h_errno = NETDB_INTERNAL;
		return (NULL);
	}
	ep = qbuf + sizeof(qbuf);
	switch (af) {
	case AF_INET:
		(void) snprintf(qbuf, sizeof qbuf, "%u.%u.%u.%u.in-addr.arpa",
		    (uaddr[3] & 0xff), (uaddr[2] & 0xff),
		    (uaddr[1] & 0xff), (uaddr[0] & 0xff));
		break;
	case AF_INET6:
		qp = qbuf;
		for (n = IN6ADDRSZ - 1; n >= 0; n--) {
			i = snprintf(qp, ep - qp, "%x.%x.",
			    uaddr[n] & 0xf, (uaddr[n] >> 4) & 0xf);
			if (i <= 0 || i >= ep - qp) {
				errno = EINVAL;
				h_errno = NETDB_INTERNAL;
				return (NULL);
			}
			qp += i;
		}
		strlcpy(qp, "ip6.arpa", ep - qp);
		break;
	}

	bcopy(_resp->lookups, lookups, sizeof lookups);
	if (lookups[0] == '\0')
		strlcpy(lookups, "bf", sizeof lookups);

	hp = (struct hostent *)NULL;
	for (i = 0; i < MAXDNSLUS && hp == NULL && lookups[i]; i++) {
		switch (lookups[i]) {
#ifdef YP
		case 'y':
			/* YP only supports AF_INET. */
			if (af == AF_INET)
				hp = _yp_gethtbyaddr(uaddr);
			break;
#endif
		case 'b':
			buf = malloc(sizeof(*buf));
			if (!buf)
				break;
			n = res_query(qbuf, C_IN, T_PTR, buf->buf,
			    sizeof(buf->buf));
			if (n < 0) {
				free(buf);
#ifdef DEBUG
				if (_resp->options & RES_DEBUG)
					printf("res_query failed\n");
#endif
				break;
			}
			if (!(hp = getanswer(buf, n, qbuf, T_PTR))) {
				free(buf);
				break;
			}
			free(buf);
			hp->h_addrtype = af;
			hp->h_length = len;
			bcopy(uaddr, host_addr, len);
			h_addr_ptrs[0] = (char *)host_addr;
			h_addr_ptrs[1] = NULL;
			if (af == AF_INET && (_resp->options & RES_USE_INET6)) {
				map_v4v6_address((char*)host_addr,
				    (char*)host_addr);
				hp->h_addrtype = AF_INET6;
				hp->h_length = IN6ADDRSZ;
			}
			h_errno = NETDB_SUCCESS;
			break;
		case 'f':
			hp = _gethtbyaddr(uaddr, len, af);
			break;
		}
	}
	/* XXX h_errno not correct in all cases... */
	return (hp);
}

void
_sethtent(int f)
{
	if (hostf == NULL)
		hostf = fopen(_PATH_HOSTS, "r" );
	else
		rewind(hostf);
	stayopen = f;
}

void
_endhtent(void)
{
	if (hostf && !stayopen) {
		(void) fclose(hostf);
		hostf = NULL;
	}
}

static struct hostent *
_gethtent(void)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	char *p, *cp, **q;
	int af;
	size_t len;

	if (!hostf && !(hostf = fopen(_PATH_HOSTS, "r" ))) {
		h_errno = NETDB_INTERNAL;
		return (NULL);
	}
 again:
	if ((p = fgetln(hostf, &len)) == NULL) {
		h_errno = HOST_NOT_FOUND;
		return (NULL);
	}
	if (p[len-1] == '\n')
		len--;
	if (len >= sizeof(hostbuf) || len == 0)
		goto again;
	p = memcpy(hostbuf, p, len);
	hostbuf[len] = '\0';
	if (*p == '#')
		goto again;
	if ((cp = strchr(p, '#')))
		*cp = '\0';
	if (!(cp = strpbrk(p, " \t")))
		goto again;
	*cp++ = '\0';
	if (inet_pton(AF_INET6, p, host_addr) > 0) {
		af = AF_INET6;
		len = IN6ADDRSZ;
	} else if (inet_pton(AF_INET, p, host_addr) > 0) {
		if (_resp->options & RES_USE_INET6) {
			map_v4v6_address((char*)host_addr, (char*)host_addr);
			af = AF_INET6;
			len = IN6ADDRSZ;
		} else {
			af = AF_INET;
			len = INADDRSZ;
		}
	} else {
		goto again;
	}
	/* if this is not something we're looking for, skip it. */
	if (host.h_addrtype != AF_UNSPEC && host.h_addrtype != af)
		goto again;
	if (host.h_length != 0 && host.h_length != len)
		goto again;
	h_addr_ptrs[0] = (char *)host_addr;
	h_addr_ptrs[1] = NULL;
	host.h_addr_list = h_addr_ptrs;
	host.h_length = len;
	host.h_addrtype = af;
	while (*cp == ' ' || *cp == '\t')
		cp++;
	host.h_name = cp;
	q = host.h_aliases = host_aliases;
	if ((cp = strpbrk(cp, " \t")))
		*cp++ = '\0';
	while (cp && *cp) {
		if (*cp == ' ' || *cp == '\t') {
			cp++;
			continue;
		}
		if (q < &host_aliases[MAXALIASES - 1])
			*q++ = cp;
		if ((cp = strpbrk(cp, " \t")))
			*cp++ = '\0';
	}
	*q = NULL;
	if (_resp->options & RES_USE_INET6) {
		char *bp = hostbuf;
		char *ep = hostbuf + sizeof hostbuf;

		map_v4v6_hostent(&host, &bp, ep);
	}
	h_errno = NETDB_SUCCESS;
	return (&host);
}

struct hostent *
_gethtbyname2(const char *name, int af)
{
	struct hostent *p;
	char **cp;
	
	_sethtent(0);
	while ((p = _gethtent())) {
		if (p->h_addrtype != af)
			continue;
		if (strcasecmp(p->h_name, name) == 0)
			break;
		for (cp = p->h_aliases; *cp != 0; cp++)
			if (strcasecmp(*cp, name) == 0)
				goto found;
	}
 found:
	_endhtent();
	return (p);
}

struct hostent *
_gethtbyaddr(const void *addr, socklen_t len, int af)
{
	struct hostent *p;

	host.h_length = len;
	host.h_addrtype = af;

	_sethtent(0);
	while ((p = _gethtent()))
		if (p->h_addrtype == af && p->h_length == len &&
		    !bcmp(p->h_addr, addr, len))
			break;
	_endhtent();
	return (p);
}

#ifdef YP
struct hostent *
_yphostent(char *line)
{
	static struct in_addr host_addrs[MAXADDRS];
	char *p = line;
	char *cp, **q;
	char **hap;
	struct in_addr *buf;
	int more;

	host.h_name = NULL;
	host.h_addr_list = h_addr_ptrs;
	host.h_length = INADDRSZ;
	host.h_addrtype = AF_INET;
	hap = h_addr_ptrs;
	buf = host_addrs;
	q = host.h_aliases = host_aliases;

nextline:
	/* check for host_addrs overflow */
	if (buf >= &host_addrs[sizeof(host_addrs) / sizeof(host_addrs[0])])
		goto done;

	more = 0;
	cp = strpbrk(p, " \t");
	if (cp == NULL)
		goto done;
	*cp++ = '\0';

	*hap++ = (char *)buf;
	(void) inet_aton(p, buf++);

	while (*cp == ' ' || *cp == '\t')
		cp++;
	p = cp;
	cp = strpbrk(p, " \t\n");
	if (cp != NULL) {
		if (*cp == '\n')
			more = 1;
		*cp++ = '\0';
	}
	if (!host.h_name)
		host.h_name = p;
	else if (strcmp(host.h_name, p)==0)
		;
	else if (q < &host_aliases[MAXALIASES - 1])
		*q++ = p;
	p = cp;
	if (more)
		goto nextline;

	while (cp && *cp) {
		if (*cp == ' ' || *cp == '\t') {
			cp++;
			continue;
		}
		if (*cp == '\n') {
			cp++;
			goto nextline;
		}
		if (q < &host_aliases[MAXALIASES - 1])
			*q++ = cp;
		cp = strpbrk(cp, " \t");
		if (cp != NULL)
			*cp++ = '\0';
	}
done:
	if (host.h_name == NULL)
		return (NULL);
	*q = NULL;
	*hap = NULL;
	return (&host);
}

struct hostent *
_yp_gethtbyaddr(const void *addr)
{
	struct hostent *hp = NULL;
	const u_char *uaddr = (const u_char *)addr;
	static char *__ypcurrent;
	int __ypcurrentlen, r;
	char name[sizeof("xxx.xxx.xxx.xxx")];
	
	if (!__ypdomain) {
		if (_yp_check(&__ypdomain) == 0)
			return (hp);
	}
	snprintf(name, sizeof name, "%u.%u.%u.%u", (uaddr[0] & 0xff),
	    (uaddr[1] & 0xff), (uaddr[2] & 0xff), (uaddr[3] & 0xff));
	if (__ypcurrent)
		free(__ypcurrent);
	__ypcurrent = NULL;
	r = yp_match(__ypdomain, "hosts.byaddr", name,
		strlen(name), &__ypcurrent, &__ypcurrentlen);
	if (r==0)
		hp = _yphostent(__ypcurrent);
	if (hp==NULL)
		h_errno = HOST_NOT_FOUND;
	return (hp);
}

struct hostent *
_yp_gethtbyname(const char *name)
{
	struct hostent *hp = (struct hostent *)NULL;
	static char *__ypcurrent;
	int __ypcurrentlen, r;

	if (strlen(name) >= MAXHOSTNAMELEN)
		return (NULL);
	if (!__ypdomain) {
		if (_yp_check(&__ypdomain) == 0)
			return (hp);
	}
	if (__ypcurrent)
		free(__ypcurrent);
	__ypcurrent = NULL;
	r = yp_match(__ypdomain, "hosts.byname", name,
		strlen(name), &__ypcurrent, &__ypcurrentlen);
	if (r == 0)
		hp = _yphostent(__ypcurrent);
	if (hp == NULL)
		h_errno = HOST_NOT_FOUND;
	return (hp);
}
#endif

static void
map_v4v6_address(const char *src, char *dst)
{
	u_char *p = (u_char *)dst;
	char tmp[INADDRSZ];
	int i;

	/* Stash a temporary copy so our caller can update in place. */
	bcopy(src, tmp, INADDRSZ);
	/* Mark this ipv6 addr as a mapped ipv4. */
	for (i = 0; i < 10; i++)
		*p++ = 0x00;
	*p++ = 0xff;
	*p++ = 0xff;
	/* Retrieve the saved copy and we're done. */
	bcopy(tmp, (void*)p, INADDRSZ);
}

static void
map_v4v6_hostent(struct hostent *hp, char **bpp, char *ep)
{
	char **ap;

	if (hp->h_addrtype != AF_INET || hp->h_length != INADDRSZ)
		return;
	hp->h_addrtype = AF_INET6;
	hp->h_length = IN6ADDRSZ;
	for (ap = hp->h_addr_list; *ap; ap++) {
		int i = sizeof(align) - ((u_long)*bpp % sizeof(align));

		if (ep - *bpp < (i + IN6ADDRSZ)) {
			/* Out of memory.  Truncate address list here.  XXX */
			*ap = NULL;
			return;
		}
		*bpp += i;
		map_v4v6_address(*ap, *bpp);
		*ap = *bpp;
		*bpp += IN6ADDRSZ;
	}
}

struct hostent *
gethostent(void)
{
	host.h_addrtype = AF_UNSPEC;
	host.h_length = 0;
	return (_gethtent());
}

#ifdef RESOLVSORT
static void
addrsort(char **ap, int num)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	int i, j;
	char **p;
	short aval[MAXADDRS];
	int needsort = 0;

	p = ap;
	for (i = 0; i < num; i++, p++) {
		for (j = 0 ; (unsigned)j < _resp->nsort; j++)
			if (_resp->sort_list[j].addr.s_addr == 
			    (((struct in_addr *)(*p))->s_addr & 
			    _resp->sort_list[j].mask))
				break;
		aval[i] = j;
		if (needsort == 0 && i > 0 && j < aval[i-1])
			needsort = i;
	}
	if (!needsort)
		return;

	while (needsort < num) {
		for (j = needsort - 1; j >= 0; j--) {
			if (aval[j] > aval[j+1]) {
				char *hp;

				i = aval[j];
				aval[j] = aval[j+1];
				aval[j+1] = i;

				hp = ap[j];
				ap[j] = ap[j+1];
				ap[j+1] = hp;
			} else
				break;
		}
		needsort++;
	}
}
#endif
@


1.73
log
@More shrinkage, a bit for ramdisks but mostly for static binaries:
- wrap with #ifndef NO_LOG_BAD_DNS_RESPONSES libc code that uses
  p_class() and p_type() for diagnostics, then add that define to
  libstub to avoid pulling in res_debug_syms.o
- split rcmd() and ruserok() into separate files, as nothing uses both
- split readdir_r() to its own file
- split syslog_r() from syslog(), as the latter needs localtime(); many
  binaries no longer need to pull in all the time code after this; switch
  from usleep() to nanosleep() while we're at it

(The profit of analysis of -Wl,-M,--cref output)

Chops 888kB from /bin and /sbin on i386

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr.c,v 1.72 2007/10/11 18:36:41 jakob Exp $ */
@


1.72
log
@use RRSIG instead of SIG for DNSSEC. ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr.c,v 1.71 2007/05/16 04:14:23 ray Exp $ */
d297 1
d302 1
@


1.71
log
@Wrap some functions, labels, and variables in #ifdefs corresponding
to #ifdefs where they are used.  Found by lint by bret dot lambert
at gmail.

OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr.c,v 1.70 2007/02/18 20:38:28 ray Exp $ */
d241 1
a241 1
		if (type == T_SIG) {
@


1.70
log
@strlen(3) returns size_t, not int.

Suggested by itojun@@ in response to my getaddrinfo fixes.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr.c,v 1.69 2007/02/14 10:26:35 itojun Exp $ */
d502 1
d504 1
d652 1
d654 1
@


1.69
log
@remove size_t and int mixup.  same as getaddrinfo.c 1.30 -> 1.31.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr.c,v 1.68 2005/08/06 20:30:03 espie Exp $ */
a204 1
		n = strlen(bp) + 1;		/* for the \0 */
d206 1
a206 1
		bp += n;
d219 2
d262 1
a262 2
			n = strlen(bp) + 1;	/* for the \0 */
			bp += n;
d264 2
a265 2
			n = strlen(tbuf) + 1;	/* for the \0 */
			if (n > ep - bp) {
d271 1
a271 1
			bp += n;
d286 2
a287 2
			n = strlen(tbuf) + 1;	/* for the \0 */
			if (n > ep - bp) {
d293 1
a293 1
			bp += n;
d409 4
a412 2
			n = strlen(qname) + 1;	/* for the \0 */
			if (n > ep - bp)
d416 1
a416 1
			bp += n;
@


1.68
log
@zap rcsid.
split functions off res_debug.c so that getnetnamadr.c does not pull it
all when it's used.

okay deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a364 2
				int nn;

d366 1
a366 2
				nn = strlen(bp) + 1;	/* for the \0 */
				bp += nn;
@


1.67
log
@Restore recent changes except for the actual one that causes the problem.
@
text
@d1 1
a49 4

#if defined(LIBC_SCCS) && !defined(lint)
static const char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.65 2005/07/24 18:47:59 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.66
log
@backout gethostent changes for now -- there is fallout, discovered by otto
@
text
@d789 1
a789 1
struct hostent *
d835 1
a835 1
	if (host.h_addrtype != af)
d837 1
a837 1
	if (host.h_length != len)
a871 15
_gethtbyname(const char *name)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	struct hostent *hp;
	extern struct hostent *_gethtbyname2(const char *, int);

	if (_resp->options & RES_USE_INET6) {
		hp = _gethtbyname2(name, AF_INET6);
		if (hp)
			return (hp);
	}
	return (_gethtbyname2(name, AF_INET));
}

struct hostent *
d902 2
a903 1
		if (p->h_addrtype == af && !bcmp(p->h_addr, addr, len))
d1082 2
@


1.65
log
@In _gethtent() ignore host.h_length if it is set to 0.  Previously
we only ignored it if host.h_addrtype was AF_UNSPEC.  Set host.h_length
to 0 in _gethtbyname2() since that function does not take a length
argument.  Problem found by jaredy@@
@
text
@d51 1
a51 1
static const char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.64 2005/07/23 04:15:49 jaredy Exp $";
d789 1
a789 1
static struct hostent *
d835 1
a835 1
	if (host.h_addrtype != AF_UNSPEC && host.h_addrtype != af)
d837 1
a837 1
	if (host.h_length != 0 && host.h_length != len)
d872 15
a891 2
	host.h_addrtype = af;
	host.h_length = 0;
d894 2
d917 1
a917 2
		if (p->h_addrtype == af && p->h_length == len &&
		    !bcmp(p->h_addr, addr, len))
a1095 2
	host.h_addrtype = AF_UNSPEC;
	host.h_length = 0;
@


1.64
log
@*hostent() fixes:
- Make _gethtent() static
- _gethtbyname() is dead code (succeeded by _gethtbyname2), kill it
- _gethtent() requires setting the address family field of the
  file-scope variable `host' to that of the desired type of the entry
  being searched for.  Change the behavior to enforce this if it is not
  AF_UNSPEC, which will now allow stepping through entries, and set it
  to specific values everywhere else.

help & ok millert
@
text
@d51 1
a51 1
static const char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.63 2005/06/08 18:32:34 millert Exp $";
d835 4
a838 6
	if (host.h_addrtype != AF_UNSPEC) {
		if (host.h_addrtype != af)
			goto again;
		if (host.h_length != len)
			goto again;
	}
d878 1
a878 1

a880 2
		if (p->h_addrtype != af)
			continue;
d1083 1
@


1.63
log
@Make gethostbyaddr() prototype match POSIX.  This means len is now
unsigned but there is no ABI change.  OK deraadt@@
@
text
@d51 1
a51 1
static const char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.62 2005/05/02 17:38:41 moritz Exp $";
d789 1
a789 1
struct hostent *
d835 6
a840 4
	if (host.h_addrtype != af)
		goto again;
	if (host.h_length != len)
		goto again;
a873 15
_gethtbyname(const char *name)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	struct hostent *hp;
	extern struct hostent *_gethtbyname2(const char *, int);

	if (_resp->options & RES_USE_INET6) {
		hp = _gethtbyname2(name, AF_INET6);
		if (hp)
			return (hp);
	}
	return (_gethtbyname2(name, AF_INET));
}

struct hostent *
d879 2
d906 2
a907 1
		if (p->h_addrtype == af && !bcmp(p->h_addr, addr, len))
d1086 1
@


1.62
log
@be more careful with snprintf. ok millert@@
@
text
@d51 1
a51 1
static const char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.61 2005/03/30 02:58:28 tedu Exp $";
d643 1
a643 1
gethostbyaddr(const char *addr, int len, int af)
d653 2
a654 2
	extern struct hostent *_gethtbyaddr(const char *, int, int);
	extern struct hostent *_yp_gethtbyaddr(const char *);
a670 1
		addr += IN6ADDRSZ - INADDRSZ;
d726 1
a726 1
				hp = _yp_gethtbyaddr(addr);
d750 1
a750 1
			bcopy(addr, host_addr, len);
d762 1
a762 1
			hp = _gethtbyaddr(addr, len, af);
d908 1
a908 1
_gethtbyaddr(const char *addr, int len, int af)
d999 1
a999 1
_yp_gethtbyaddr(const char *addr)
d1001 2
a1002 1
	struct hostent *hp = (struct hostent *)NULL;
d1011 2
a1012 3
	snprintf(name, sizeof name, "%u.%u.%u.%u",
	    ((unsigned)addr[0] & 0xff), ((unsigned)addr[1] & 0xff),
	    ((unsigned)addr[2] & 0xff), ((unsigned)addr[3] & 0xff));
@


1.61
log
@make the resolver stat resolv.conf and update if it changes.
useful feedback and ok deraadt@@
@
text
@d51 1
a51 1
static const char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.60 2004/07/29 03:09:40 itojun Exp $";
d705 1
a705 1
			if (i <= 0) {
@


1.60
log
@we no longer need to query ip6.int for reverse lookup.  pvalchev ok
@
text
@d51 1
a51 1
static const char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.59 2003/10/06 19:18:09 millert Exp $";
d482 1
a482 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1)
d508 1
a508 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1)
d656 1
a656 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1) {
@


1.59
log
@ANSIfication; most from Patrick Latifi
OK deraadt@@
@
text
@d51 1
a51 1
static const char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.58 2003/10/03 19:48:10 millert Exp $";
d712 1
a730 2
			if (af == AF_INET6)
				strlcpy(qp, "ip6.arpa", ep - qp);
a735 5
			if (n < 0 && af == AF_INET6) {
				strlcpy(qp, "ip6.int", ep - qp);
				n = res_query(qbuf, C_IN, T_PTR,
				    buf->buf, sizeof(buf->buf));
			}
@


1.58
log
@Fix off-by-one, patch from Patrick Latifi; closes PR 3492
@
text
@d51 1
a51 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.57 2003/06/27 22:23:05 vincent Exp $";
d126 1
a126 2
_hokchar(p)
	const char *p;
d152 1
a152 5
getanswer(answer, anslen, qname, qtype)
	const querybuf *answer;
	int anslen;
	const char *qname;
	int qtype;
d368 1
a368 1
				register int nn;
d442 2
a443 6
gethostbyname_r(name, hp, buf, buflen, errorp)
	const char * name;
	struct hostent * hp;
	char * buf;
	int buflen;
	int * errorp;
d459 2
a460 7
gethostbyaddr_r(addr, len, af, he, buf, buflen, errorp)
	const char *addr;	/* XXX should have been def'd as u_char! */
	int len, af;
	struct hostent * he;
	char * buf;
	int buflen;
	int * errorp;
d476 1
a476 2
gethostbyname(name)
	const char *name;
d480 1
a480 1
	extern struct hostent *_gethtbyname2();
d496 1
a496 3
gethostbyname2(name, af)
	const char *name;
	int af;
d500 1
a500 1
	register const char *cp;
d503 1
a503 2
	extern struct hostent *_gethtbyname2(), *_yp_gethtbyname();
	register struct hostent *hp;
d505 2
d643 1
a643 3
gethostbyaddr(addr, len, af)
	const char *addr;	/* XXX should have been def'd as u_char! */
	int len, af;
d649 1
a649 1
	register struct hostent *hp;
a650 1
	extern struct hostent *_gethtbyaddr(), *_yp_gethtbyaddr();
d653 2
d778 1
a778 2
_sethtent(f)
	int f;
d788 1
a788 1
_endhtent()
d797 1
a797 1
_gethtent()
d800 1
a800 2
	char *p;
	register char *cp, **q;
d879 1
a879 2
_gethtbyname(name)
	const char *name;
a881 1
	extern struct hostent *_gethtbyname2();
d883 1
d894 1
a894 3
_gethtbyname2(name, af)
	const char *name;
	int af;
d896 2
a897 2
	register struct hostent *p;
	register char **cp;
d915 1
a915 3
_gethtbyaddr(addr, len, af)
	const char *addr;
	int len, af;
d917 1
a917 1
	register struct hostent *p;
d932 1
a932 2
_yphostent(line)
	char *line;
d1006 1
a1006 2
_yp_gethtbyaddr(addr)
	const char *addr;
d1033 1
a1033 2
_yp_gethtbyname(name)
	const char *name;
d1059 1
a1059 3
map_v4v6_address(src, dst)
	const char *src;
	char *dst;
d1077 1
a1077 4
map_v4v6_hostent(hp, bpp, ep)
	struct hostent *hp;
	char **bpp;
	char *ep;
d1101 1
a1101 1
gethostent()
d1108 1
a1108 3
addrsort(ap, num)
	char **ap;
	int num;
d1120 2
a1121 1
			    (((struct in_addr *)(*p))->s_addr & _resp->sort_list[j].mask))
@


1.57
log
@ensure we stay within the boundaries of our packet

ok itojun
@
text
@d51 1
a51 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.56 2003/06/02 20:18:35 millert Exp $";
d234 1
a234 1
		if (cp > eom)
d238 1
a238 1
		if (cp > eom)
d242 1
a242 1
		if (cp > eom)
d246 1
a246 1
		if (cp > eom)
@


1.56
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d51 1
a51 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.55 2003/03/04 00:29:17 itojun Exp $";
d160 3
a162 4
	register const HEADER *hp;
	register const u_char *cp;
	register int n;
	const u_char *eom;
d164 2
a165 4
	int type, class, ancount, qdcount;
	int haveanswer, had_error;
	int toobig = 0;
	char tbuf[MAXDNAME];
d234 2
d237 3
a239 1
 		cp += INT16SZ;			/* type */
d242 2
d246 2
@


1.55
log
@strlcpy, check retval from sprintf
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d51 1
a51 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.54 2003/01/28 04:58:00 marc Exp $";
@


1.54
log
@
thread safer libc (note: safer, not safe)
Access to the global _res structure replaced by pointers to a
per thread instance.  If unthreaded the pointer is to the
global structure.

Also replaced a 64k stack array with malloc-ed memory so
threaded aps (with a default 64k stack) have a chance at working.
ok deraadt@@
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.53 2002/08/27 08:53:13 itojun Exp $";
d667 1
a667 1
	char qbuf[MAXDNAME+1], *qp;
d709 1
d719 1
a719 1
			qp += sprintf(qp, "%x.%x.",
d721 6
d747 1
a747 1
				strcpy(qp, "ip6.arpa");
d754 1
a754 1
				strcpy(qp, "ip6.int");
@


1.53
log
@allocate 64K recieve buffer for DNS responses.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.52 2002/08/22 16:35:37 itojun Exp $";
d163 1
d343 1
a343 1
			if (_res.options & RES_USE_INET6) {
d383 1
a383 1
				if (_res.options & RES_DEBUG)
d392 1
a392 1
					if (_res.options & RES_DEBUG)
d415 1
a415 1
		if (_res.nsort && haveanswer > 1 && qtype == T_A)
d426 1
a426 1
		if (_res.options & RES_USE_INET6)
a487 2
_THREAD_PRIVATE_MUTEX(gethostnamadr);

d492 1
d496 1
a496 2
	_THREAD_PRIVATE_MUTEX_LOCK(gethostnamadr);
	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
d499 1
a499 1
	else if (_res.options & RES_USE_INET6) {
a505 1
	_THREAD_PRIVATE_MUTEX_UNLOCK(gethostnamadr);
d514 1
d523 1
a523 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
d579 1
a579 1
				if (_res.options & RES_USE_INET6)
d618 1
a618 1
	bcopy(_res.lookups, lookups, sizeof lookups);
d640 1
a640 1
				if (_res.options & RES_DEBUG)
d662 1
d672 1
a672 2
	_THREAD_PRIVATE_MUTEX_LOCK(gethostnamadr);
	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
a673 1
		_THREAD_PRIVATE_MUTEX_UNLOCK(gethostnamadr);
a701 1
		_THREAD_PRIVATE_MUTEX_UNLOCK(gethostnamadr);
a706 1
		_THREAD_PRIVATE_MUTEX_UNLOCK(gethostnamadr);
d724 1
a724 1
	bcopy(_res.lookups, lookups, sizeof lookups);
d754 1
a754 1
				if (_res.options & RES_DEBUG)
d769 1
a769 1
			if (af == AF_INET && (_res.options & RES_USE_INET6)) {
a781 1
	_THREAD_PRIVATE_MUTEX_UNLOCK(gethostnamadr);
d809 1
d841 1
a841 1
		if (_res.options & RES_USE_INET6) {
d879 1
a879 1
	if (_res.options & RES_USE_INET6) {
d893 1
d897 1
a897 1
	if (_res.options & RES_USE_INET6) {
d1136 1
d1144 3
a1146 3
		for (j = 0 ; (unsigned)j < _res.nsort; j++)
			if (_res.sort_list[j].addr.s_addr == 
			    (((struct in_addr *)(*p))->s_addr & _res.sort_list[j].mask))
@


1.52
log
@drop AAAA reply with IPv4 mapped address.  sync w/kame
draft-itojun-v6ops-v4mapped-harmful-00.txt
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.51 2002/07/30 00:45:19 deraadt Exp $";
d113 1
a113 5
#if PACKETSZ > 1024
#define	MAXPACKET	PACKETSZ
#else
#define	MAXPACKET	1024
#endif
d516 1
a516 1
	querybuf buf;
d634 6
a639 2
			if ((n = res_search(name, C_IN, type, buf.buf,
			    sizeof(buf))) < 0) {
d646 2
a647 1
			hp = getanswer(&buf, n, name, type);
d665 1
a665 1
	querybuf buf;
d745 5
a749 2
			n = res_query(qbuf, C_IN, T_PTR, (u_char *)buf.buf,
			    sizeof buf.buf);
d753 1
a753 1
				    (u_char *)buf.buf, sizeof buf.buf);
d756 1
d763 2
a764 1
			if (!(hp = getanswer(&buf, n, qbuf, T_PTR)))
d766 2
@


1.51
log
@more strlcpy; itojun ok
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.50 2002/07/29 10:15:30 itojun Exp $";
d365 8
@


1.50
log
@query ip6.arpa then ip6.int for IPv6 reverse lookup.  follows RFC3152.
(need some string-manipulation cleanup near here)
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.49 2002/07/25 21:13:45 deraadt Exp $";
d279 1
a279 1
			strcpy(bp, tbuf);
d301 1
a301 1
			strcpy(bp, tbuf);
d417 1
a417 1
			strcpy(bp, qname);
@


1.49
log
@kill more strcpy
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.48 2002/06/26 06:00:53 itojun Exp $";
a715 1
		strcpy(qp, "ip6.int");
d734 2
d738 5
@


1.48
log
@avoid remote buffer overrun on hostbuf[].  From: Joost Pol <joost@@pine.nl>

correct bad practice in the code - it uses two changing variables
to manage buffer (buf and buflen).  we eliminate buflen and use
fixed point (ep) as the ending pointer.

this fix is critical.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.47 2002/05/22 04:31:14 deraadt Exp $";
d617 1
a617 1
		strncpy(lookups, "bf", sizeof lookups);
d722 1
a722 1
		strncpy(lookups, "bf", sizeof lookups);
@


1.47
log
@more strlcpy and snprintf
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.46 2002/05/18 00:06:42 itojun Exp $";
d102 1
a102 1
static void map_v4v6_hostent(struct hostent *hp, char **bp, int *len);
d171 2
a172 2
	char *bp, **ap, **hap;
	int type, class, buflen, ancount, qdcount;
d206 1
a206 1
	buflen = sizeof hostbuf;
d212 1
a212 1
	n = dn_expand(answer->buf, eom, cp, bp, buflen);
a225 1
		buflen -= n;
d238 1
a238 1
		n = dn_expand(answer->buf, eom, cp, bp, buflen);
a272 1
			buflen -= n;
d275 1
a275 1
			if (n > buflen) {
a281 1
			buflen -= n;
d297 1
a297 1
			if (n > buflen) {
a303 1
			buflen -= n;
d322 1
a322 1
			n = dn_expand(answer->buf, eom, cp, bp, buflen);
a341 1
				buflen -= n;
d349 1
a349 2
				buflen -= n;
				map_v4v6_hostent(&host, &bp, &buflen);
a371 1
				buflen -= nn;
a394 1
			buflen -= n;
d415 1
a415 1
			if (n > buflen)
a419 1
			buflen -= n;
d422 1
a422 1
			map_v4v6_hostent(&host, &bp, &buflen);
d514 2
a515 2
	char *bp;
	int n, size, type, len, i;
d569 1
a569 1
				len = sizeof hostbuf - MAXHOSTNAMELEN;
d577 1
a577 1
					map_v4v6_hostent(&host, &bp, &len);
d601 1
a601 1
				len = sizeof hostbuf - MAXHOSTNAMELEN;
d863 1
a863 1
		int buflen = sizeof hostbuf;
d865 1
a865 1
		map_v4v6_hostent(&host, &bp, &buflen);
d1079 1
a1079 1
map_v4v6_hostent(hp, bpp, lenp)
d1082 1
a1082 1
	int *lenp;
d1093 1
a1093 1
		if (*lenp < (i + IN6ADDRSZ)) {
a1098 1
		*lenp -= i;
a1101 1
		*lenp -= IN6ADDRSZ;
@


1.46
log
@do not reverse-lookup scoped ipv6 address - it is meaningless as there's
no way to pass scope id.  sync w/kame
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.45 2002/02/17 19:42:23 millert Exp $";
d715 3
a717 5
		(void) sprintf(qbuf, "%u.%u.%u.%u.in-addr.arpa",
			       (uaddr[3] & 0xff),
			       (uaddr[2] & 0xff),
			       (uaddr[1] & 0xff),
			       (uaddr[0] & 0xff));
d723 1
a723 2
				       uaddr[n] & 0xf,
				       (uaddr[n] >> 4) & 0xf);
d1025 3
a1027 5
	sprintf(name, "%u.%u.%u.%u",
		((unsigned)addr[0] & 0xff),
		((unsigned)addr[1] & 0xff),
		((unsigned)addr[2] & 0xff),
		((unsigned)addr[3] & 0xff));
d1135 7
a1141 7
	    for (j = 0 ; (unsigned)j < _res.nsort; j++)
		if (_res.sort_list[j].addr.s_addr == 
		    (((struct in_addr *)(*p))->s_addr & _res.sort_list[j].mask))
			break;
	    aval[i] = j;
	    if (needsort == 0 && i > 0 && j < aval[i-1])
		needsort = i;
d1144 1
a1144 1
	    return;
d1147 15
a1161 16
	    for (j = needsort - 1; j >= 0; j--) {
		if (aval[j] > aval[j+1]) {
		    char *hp;

		    i = aval[j];
		    aval[j] = aval[j+1];
		    aval[j+1] = i;

		    hp = ap[j];
		    ap[j] = ap[j+1];
		    ap[j+1] = hp;

		} else
		    break;
	    }
	    needsort++;
@


1.45
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.44 2002/02/16 21:27:23 millert Exp $";
d679 6
@


1.45.2.1
log
@avoid remote buffer overrun on hostbuf[].  From: Joost Pol <joost@@pine.nl>

correct bad practice in the code - it uses two changing variables
to manage buffer (buf and buflen).  we eliminate buflen and use
fixed point (ep) as the ending pointer.  From: itojun

this fix is critical.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.45 2002/02/17 19:42:23 millert Exp $";
d102 1
a102 1
static void map_v4v6_hostent(struct hostent *hp, char **bp, char *);
d171 2
a172 2
	char *bp, **ap, **hap, *ep;
	int type, class, ancount, qdcount;
d206 1
a206 1
	ep = hostbuf + sizeof hostbuf;
d212 1
a212 1
	n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d226 1
d239 1
a239 1
		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d274 1
d277 1
a277 1
			if (n > ep - bp) {
d284 1
d300 1
a300 1
			if (n > ep - bp) {
d307 1
d326 1
a326 1
			n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d346 1
d354 2
a355 1
				map_v4v6_hostent(&host, &bp, ep);
d378 1
d402 1
d423 1
a423 1
			if (n > ep - bp)
d428 1
d431 1
a431 1
			map_v4v6_hostent(&host, &bp, ep);
d523 2
a524 2
	char *bp, *ep;
	int n, size, type, i;
d578 1
a578 1
				ep = hostbuf + sizeof(hostbuf);
d586 1
a586 1
					map_v4v6_hostent(&host, &bp, ep);
d610 1
a610 1
				ep = hostbuf + sizeof(hostbuf);
d869 1
a869 1
		char *ep = hostbuf + sizeof hostbuf;
d871 1
a871 1
		map_v4v6_hostent(&host, &bp, ep);
d1087 1
a1087 1
map_v4v6_hostent(hp, bpp, ep)
d1090 1
a1090 1
	char *ep;
d1101 1
a1101 1
		if (ep - *bpp < (i + IN6ADDRSZ)) {
d1107 1
d1111 1
@


1.45.2.2
log
@Pull in patch from current:
Fix (itojun):
allocate 64K recieve buffer for DNS responses.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.45.2.1 2002/06/26 06:03:49 millert Exp $";
d113 5
a117 1
#define	MAXPACKET	(64*1024)
d512 1
a512 1
	querybuf *buf;
d630 2
a631 6
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			if ((n = res_search(name, C_IN, type, buf->buf,
			    sizeof(buf->buf))) < 0) {
				free(buf);
d638 1
a638 2
			hp = getanswer(buf, n, name, type);
			free(buf);
d656 1
a656 1
	querybuf *buf;
d732 2
a733 5
			buf = malloc(sizeof(*buf));
			if (!buf)
				break;
			n = res_query(qbuf, C_IN, T_PTR, (u_char *)buf->buf,
			    sizeof(buf->buf));
a734 1
				free(buf);
d741 1
a741 2
			if (!(hp = getanswer(buf, n, qbuf, T_PTR))) {
				free(buf);
a742 2
			}
			free(buf);
@


1.44
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.43 2001/06/27 00:58:55 lebel Exp $";
d129 1
a129 2
static struct hostent *getanswer __P((const querybuf *, int, const char *,
				      int));
@


1.43
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.42 2000/07/30 14:07:14 itojun Exp $";
d101 2
a102 2
static void map_v4v6_address __P((const char *src, char *dst));
static void map_v4v6_hostent __P((struct hostent *hp, char **bp, int *len));
d105 1
a105 1
static void addrsort __P((char **, int));
d108 1
a108 1
int _hokchar __P((const char *));
d178 1
a178 1
	int (*name_ok) __P((const char *));
@


1.43.2.1
log
@avoid remote buffer overrun on hostbuf[].  From: Joost Pol <joost@@pine.nl>

correct bad practice in the code - it uses two changing variables
to manage buffer (buf and buflen).  we eliminate buflen and use
fixed point (ep) as the ending pointer.  From: itojun

this fix is critical.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.43 2001/06/27 00:58:55 lebel Exp $";
d102 1
a102 1
static void map_v4v6_hostent __P((struct hostent *hp, char **bp, char *));
d172 2
a173 2
	char *bp, **ap, **hap, *ep;
	int type, class, ancount, qdcount;
d207 1
a207 1
	ep = hostbuf + sizeof hostbuf;
d213 1
a213 1
	n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d227 1
d240 1
a240 1
		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d275 1
d278 1
a278 1
			if (n > ep - bp) {
d285 1
d301 1
a301 1
			if (n > ep - bp) {
d308 1
d327 1
a327 1
			n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d347 1
d355 2
a356 1
				map_v4v6_hostent(&host, &bp, ep);
d379 1
d403 1
d424 1
a424 1
			if (n > ep - bp)
d429 1
d432 1
a432 1
			map_v4v6_hostent(&host, &bp, ep);
d524 2
a525 2
	char *bp, *ep;
	int n, size, type, i;
d579 1
a579 1
				ep = hostbuf + sizeof(hostbuf);
d587 1
a587 1
					map_v4v6_hostent(&host, &bp, ep);
d611 1
a611 1
				ep = hostbuf + sizeof(hostbuf);
d870 1
a870 1
		char *ep = hostbuf + sizeof hostbuf;
d872 1
a872 1
		map_v4v6_hostent(&host, &bp, ep);
d1088 1
a1088 1
map_v4v6_hostent(hp, bpp, ep)
d1091 1
a1091 1
	char *ep;
d1102 1
a1102 1
		if (ep - *bpp < (i + IN6ADDRSZ)) {
d1108 1
d1112 1
@


1.43.2.2
log
@MFC (itojun):
allocate 64K receive buffer for DNS responses.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.43.2.1 2002/06/26 06:03:31 millert Exp $";
d113 5
a117 1
#define	MAXPACKET	(64*1024)
d513 1
a513 1
	querybuf *buf;
d631 2
a632 6
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			if ((n = res_search(name, C_IN, type, buf->buf,
			    sizeof(buf->buf))) < 0) {
				free(buf);
d639 1
a639 2
			hp = getanswer(buf, n, name, type);
			free(buf);
d657 1
a657 1
	querybuf *buf;
d733 2
a734 5
			buf = malloc(sizeof(*buf));
			if (!buf)
				break;
			n = res_query(qbuf, C_IN, T_PTR, buf->buf,
			    sizeof(buf->buf));
a735 1
				free(buf);
d742 1
a742 2
			if (!(hp = getanswer(buf, n, qbuf, T_PTR))) {
				free(buf);
a743 2
			}
			free(buf);
@


1.42
log
@avoid buffer overrun on too-long reply for NIS hostname lookup.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.41 2000/01/06 08:24:17 d Exp $";
d577 1
a577 2
				strncpy(hostbuf, name, MAXHOSTNAMELEN-1);
				hostbuf[MAXHOSTNAMELEN-1] = '\0';
d609 1
a609 2
				strncpy(hostbuf, name, MAXHOSTNAMELEN-1);
				hostbuf[MAXHOSTNAMELEN-1] = '\0';
@


1.42.4.1
log
@avoid remote buffer overrun on hostbuf[].  From: Joost Pol <joost@@pine.nl>

correct bad practice in the code - it uses two changing variables
to manage buffer (buf and buflen).  we eliminate buflen and use
fixed point (ep) as the ending pointer.  From: itojun

this fix is critical.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.42 2000/07/30 14:07:14 itojun Exp $";
d102 1
a102 1
static void map_v4v6_hostent __P((struct hostent *hp, char **bp, char *));
d172 2
a173 2
	char *bp, **ap, **hap, *ep;
	int type, class, ancount, qdcount;
d207 1
a207 1
	ep = hostbuf + sizeof hostbuf;
d213 1
a213 1
	n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d227 1
d240 1
a240 1
		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d275 1
d278 1
a278 1
			if (n > ep - bp) {
d285 1
d301 1
a301 1
			if (n > ep - bp) {
d308 1
d327 1
a327 1
			n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d347 1
d355 2
a356 1
				map_v4v6_hostent(&host, &bp, ep);
d379 1
d403 1
d424 1
a424 1
			if (n > ep - bp)
d429 1
d432 1
a432 1
			map_v4v6_hostent(&host, &bp, ep);
d524 2
a525 2
	char *bp, *ep;
	int n, size, type, i;
d580 1
a580 1
				ep = hostbuf + sizeof(hostbuf);
d588 1
a588 1
					map_v4v6_hostent(&host, &bp, ep);
d613 1
a613 1
				ep = hostbuf + sizeof(hostbuf);
d872 1
a872 1
		char *ep = hostbuf + sizeof hostbuf;
d874 1
a874 1
		map_v4v6_hostent(&host, &bp, ep);
d1090 1
a1090 1
map_v4v6_hostent(hp, bpp, ep)
d1093 1
a1093 1
	char *ep;
d1104 1
a1104 1
		if (ep - *bpp < (i + IN6ADDRSZ)) {
d1110 1
d1114 1
@


1.41
log
@_THREAD_PRIVATE_* macros changed
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.40 2000/01/03 11:51:07 itojun Exp $";
d957 4
d963 2
a964 6
	if (cp == NULL) {
		if (host.h_name == NULL)
			return (NULL);
		else
			goto done;
	}
d1005 2
@


1.40
log
@always enable IPv6 address in /etc/hosts (via _gethtent()).
clarify RES_USE_INET6.  the use of this bit is not meaningful
on openbsd (as we don't have mapped addr support in kernel).
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.39 1999/12/11 08:40:17 itojun Exp $";
d493 1
a493 1
_THREAD_PRIVATE_MUTEX(gethostnamadr)
@


1.39
log
@prevent bogus reverse query for 1.0.0.0.in-addr.arpa.
this occurs by mixing up ::1 as IPv6 auto-tunnel address like ::10.1.1.1.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.38 1999/12/11 08:32:20 itojun Exp $";
d828 1
a828 2
	if ((_res.options & RES_USE_INET6) &&
	    inet_pton(AF_INET6, p, host_addr) > 0) {
@


1.38
log
@fix gethostbyname2(foo, AF_INET6).

on /etc/hosts lookup, file static variable "hosts" was damaged and prevented
lookup of IPv6 hostnames.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.37 1999/09/03 18:12:31 deraadt Exp $";
a666 2
	static const u_char mapped[] = { 0,0, 0,0, 0,0, 0,0, 0,0, 0xff,0xff };
	static const u_char tunnelled[] = { 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 };
d683 2
a684 2
	    (!bcmp(uaddr, mapped, sizeof mapped) ||
	     !bcmp(uaddr, tunnelled, sizeof tunnelled))) {
d686 2
a687 2
		addr += sizeof mapped;
		uaddr += sizeof mapped;
@


1.37
log
@sizeof("string") includes 0 byte; aazubel@@tatu.cnba.uba.ar
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.36 1999/07/03 18:07:53 jakob Exp $";
d846 5
d927 3
@


1.36
log
@Ignore SIGs in the answer section for now as we don't use them (yet).
OK'd by deraadt.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.35 1999/06/04 06:38:10 niklas Exp $";
d1012 1
a1012 1
	char name[sizeof("xxx.xxx.xxx.xxx") + 1];
@


1.35
log
@Be consistent about the relaxation of invalid host name checking.
This allows CNAMEs to PTRs with names including slashes, something not really
RFC-compliant but still in general use.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.34 1999/05/30 14:20:29 niklas Exp $";
d252 5
@


1.34
log
@Revertion of last change, which was due to emacs' stupid idea
of keeping the "*Shell Command Output*" buffer's wd from its creation instead
of using the last command's wd!!!!
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.32 1999/04/28 19:13:35 niklas Exp $";
d285 1
d287 3
d323 1
d325 3
@


1.33
log
@Some extra error checking, documentation and style wrt connections
@
text
@a284 1
#ifdef USE_RESOLV_NAME_OK
a285 3
#else
			if ((n < 0) || !_hokchar(tbuf)) {
#endif
a318 1
#ifdef USE_RESOLV_NAME_OK
a319 3
#else
			if ((n < 0) || !_hokchar(bp)) {
#endif
@


1.32
log
@Do not provide gethostby.*_r for now, as configure scripts find
the functions using nm(1), but then no prototypes exist and things break.
d@@ will contemplate over the issue and resolve it for real later :-)
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.31 1998/11/20 11:18:44 d Exp $";
d285 1
d287 3
d323 1
d325 3
@


1.31
log
@Add thread-safety to libc, so that libc_r will build (on i386 at least).
All POSIX libc api now there (to P1003.1c/D10)
  (more md stuff is needed for other libc/arch/*)
  (setlogin is no longer a special syscall)
Add -pthread option to gcc (that makes it use -lc_r and -D_POSIX_THREADS).
Doc some re-entrant routines
Add libc_r to intro(3)
dig() uses some libc srcs and an extra -I was needed there.
Add more md stuff to libc_r.
Update includes for the pthreads api
Update libc_r TODO
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.30 1998/03/16 05:06:55 millert Exp $";
d428 1
a428 1
#ifndef notyet
d430 1
a430 1
 * XXX This is an extremely bogus implementations.
d456 1
a456 1
 * XXX This is an extremely bogus implementations.
@


1.30
log
@Use fgetln(3) instead of fgets(3) so we can easily recognize lines
that are too long and ignore them instead of corrupting later entries.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.29 1998/01/20 18:28:33 deraadt Exp $";
d70 1
d77 1
d428 54
d489 1
d491 1
a491 1
		return (_gethtbyname2(name, AF_INET));
d493 1
a493 1
	if (_res.options & RES_USE_INET6) {
d495 2
a496 2
		if (hp)
			return (hp);
d498 4
a501 1
	return (gethostbyname2(name, AF_INET));
d662 1
d664 6
a669 2
	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
		return (_gethtbyaddr(addr, len, af));
d690 1
d696 1
d762 1
@


1.29
log
@for YP lookups, avoid names longer than MAXHOSTNAMELEN
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.28 1998/01/11 19:32:10 weingart Exp $";
d724 2
a725 1
	int af, len;
d732 1
a732 1
	if (!(p = fgets(hostbuf, sizeof hostbuf, hostf))) {
d736 6
d744 2
a745 3
	if (!(cp = strpbrk(p, "#\n")))
		goto again;
	*cp = '\0';
@


1.28
log
@Add gethostent(), as some LEGACY code wants it.  If you write new
code, PLEASE don't use this.  Currently only iterates through the
local /etc/hosts file.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.27 1997/11/08 20:46:56 deraadt Exp $";
d956 2
@


1.27
log
@do not call abort()
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.26 1997/07/09 01:08:26 millert Exp $";
d1020 6
@


1.26
log
@Clean up some -Wall flowers.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.25 1997/04/29 19:28:38 deraadt Exp $";
d196 1
a196 1
		return (NULL);	/* XXX should be abort(); */
a390 2
		default:
			abort();
a648 2
	default:
		abort();
@


1.25
log
@oops
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.24 1997/04/29 19:15:46 deraadt Exp $";
d772 1
a772 1
	if (cp = strpbrk(cp, " \t"))
d781 1
a781 1
		if (cp = strpbrk(cp, " \t"))
d819 1
a819 1
	while (p = _gethtent()) {
d841 1
a841 1
	while (p = _gethtent())
@


1.24
log
@careful buffer handling
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.23 1997/04/27 22:20:47 deraadt Exp $";
d506 4
a509 4
				strncpy(hostbuf, name, MAXHOSTNAME-1);
				hostbuf[MAXHOSTNAME-1] = '\0';
				bp = hostbuf + MAXHOSTNAME;
				len = sizeof hostbuf - MAXHOSTNAME;
d539 4
a542 4
				strncpy(hostbuf, name, MAXHOSTNAME-1);
				hostbuf[MAXHOSTNAME-1] = '\0';
				bp = hostbuf + MAXHOSTNAME;
				len = sizeof hostbuf - MAXHOSTNAME;
@


1.23
log
@handle hex-like hostnames
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.22 1997/04/15 11:27:56 deraadt Exp $";
d506 4
a509 4
				strncpy(hostbuf, name, MAXDNAME);
				hostbuf[MAXDNAME] = '\0';
				bp = hostbuf + MAXDNAME;
				len = sizeof hostbuf - MAXDNAME;
d539 4
a542 4
				strncpy(hostbuf, name, MAXDNAME);
				hostbuf[MAXDNAME] = '\0';
				bp = hostbuf + MAXDNAME;
				len = sizeof hostbuf - MAXDNAME;
@


1.22
log
@correct the paranoia check
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.21 1997/04/14 06:57:44 deraadt Exp $";
d524 2
a525 1
	if (isxdigit(name[0]) || name[0] == ':')
@


1.21
log
@with this here commit i label myself not the swiftest
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.19 1997/04/03 08:33:03 downsj Exp $";
d143 1
d146 3
a148 3
		if (('a' >= c && c <= 'z') ||
		    ('A' >= c && c <= 'Z') ||
		    ('0' >= c && c <= '9'))
d150 5
a154 3
		if (strchr("-_/.[]\\", c) ||
		    (c == '.' && p[1] == '.'))
			return 0;
@


1.20
log
@repair _hokchar
@
text
@a143 2
	if (*p == '.' || *p == '-')
		return 0;
d145 3
a147 3
		if (('a' <= c && c >= 'z') ||
		    ('A' <= c && c >= 'Z') ||
		    ('0' <= c && c >= '9'))
d149 2
a150 2
		if (strchr("-_/[]\\", c) || 
		    (c == '.' && *p == '.'))
@


1.19
log
@hokchar -> _hokchar, and make it non-static.  Use it in getnetnamadr.c as
well.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.18 1997/04/03 07:54:01 deraadt Exp $";
d144 2
d147 3
a149 3
		if (('a' >= c && c <= 'z') ||
		    ('A' >= c && c <= 'Z') ||
		    ('0' >= c && c <= '9'))
d151 2
a152 2
		if (strchr("-_/.[]\\", c) ||
		    (c == '.' && p[1] == '.'))
@


1.18
log
@another lookup[] loop accident
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.17 1997/04/03 05:53:23 deraadt Exp $";
d106 1
a106 1
static int hokchar __P((const char *));
d132 2
a133 2
static int
hokchar(p)
d189 1
a189 1
		name_ok = hokchar;
@


1.17
log
@if dns lookup fails, still honour _res.lookups[]
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.16 1997/04/03 05:52:35 deraadt Exp $";
d582 1
d676 1
a676 1
				return (NULL);	/* h_errno was set by getanswer() */
d695 1
@


1.16
log
@ensure host_addr[] remains nicely aligned; pr#145, grr@@shandakor.tharsis.com
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.15 1997/04/02 08:22:35 deraadt Exp $";
d672 1
a672 1
				return (NULL);
@


1.15
log
@spelling error
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.14 1997/03/13 19:07:24 downsj Exp $";
d91 5
a95 1
static u_char host_addr[16];		/* IPv4 or IPv6 */
@


1.14
log
@Integrate BIND 4.9.5 resolver and associated routines.

Includes the DNS aware getnetby*() routines and IPv6 support.
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.13 1997/01/30 05:56:06 deraadt Exp $";
d557 1
a557 1
			/* YP only suports AF_INET. */
@


1.13
log
@careful about MAXADDRS, abrown@@eecs.harvard.edu
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.12 1996/09/28 13:26:34 deraadt Exp $";
d69 1
d77 2
d91 1
a91 1
static struct in_addr host_addr;
d95 12
d123 2
a124 3
static int qcomp __P((struct in_addr **, struct in_addr **));
static struct hostent *getanswer __P((querybuf *, int, int));
static int hbadchar __P((char *));
d129 2
a130 2
hbadchar(p)
	char *p;
d138 1
a138 1
	 * until those idiots clean up their act.
d147 1
a147 1
			return 1;
d149 1
a149 1
	return 0;
d153 2
a154 2
getanswer(answer, anslen, iquery)
	querybuf *answer;
d156 2
a157 1
	int iquery;
d159 2
a160 2
	register HEADER *hp;
	register u_char *cp;
d162 2
a163 2
	u_char *eom;
	char *bp, **ap;
d165 5
a169 3
	int haveanswer, getclass = C_ANY;
	char **hap;
	int good = 1;
d171 2
d174 17
d198 23
a220 28
	buflen = sizeof(hostbuf);
	cp = answer->buf + sizeof(HEADER);
	if (qdcount) {
		if (iquery) {
			if ((n = dn_expand((u_char *)answer->buf,
			    (u_char *)eom, (u_char *)cp, bp,
			    buflen)) < 0) {
				h_errno = NO_RECOVERY;
				return ((struct hostent *) NULL);
			}
			cp += n + QFIXEDSZ;
			host.h_name = bp;
			n = strlen(bp);
			if (n >= MAXHOSTNAMELEN)
				host.h_name[MAXHOSTNAMELEN-1] = '\0';
			n++;
			bp += n;
			buflen -= n;
		} else
			cp += __dn_skipname(cp, eom) + QFIXEDSZ;
		while (--qdcount > 0)
			cp += __dn_skipname(cp, eom) + QFIXEDSZ;
	} else if (iquery) {
		if (hp->aa)
			h_errno = HOST_NOT_FOUND;
		else
			h_errno = TRY_AGAIN;
		return ((struct hostent *) NULL);
d229 8
a236 7
	if (ancount > MAXADDRS)
		ancount = MAXADDRS;
	while (--ancount >= 0 && cp < eom) {
		if ((n = dn_expand((u_char *)answer->buf, (u_char *)eom,
		    (u_char *)cp, bp, buflen)) < 0)
			break;
		cp += n;
d238 1
a238 1
 		cp += sizeof(u_int16_t);
d240 1
a240 1
 		cp += sizeof(u_int16_t) + sizeof(u_int32_t);
d242 3
a244 2
		cp += sizeof(u_int16_t);
		if (type == T_CNAME) {
d246 3
d251 7
d259 11
a269 3
			n = strlen(bp) + 1;
			if (n > MAXHOSTNAMELEN)
				bp[MAXHOSTNAMELEN-1] = '\0';
d274 38
a311 4
		if (iquery && type == T_PTR) {
			if ((n = dn_expand((u_char *)answer->buf,
			    (u_char *)eom, (u_char *)cp, bp,
			    buflen)) < 0)
d313 2
d316 13
d330 8
a337 10
			n = strlen(host.h_name);
			if (n >= MAXHOSTNAMELEN)
				host.h_name[MAXHOSTNAMELEN-1] = '\0';
			goto gotent;
		}
		if (iquery || type != T_A)  {
#ifdef DEBUG
			if (_res.options & RES_DEBUG)
				printf("unexpected answer type %d, size %d\n",
					type, n);
d339 5
a343 6
			cp += n;
			continue;
		}

		if (haveanswer) {
			if (n != host.h_length) {
d345 1
a345 1
				continue;
d347 1
a347 1
			if (class != getclass) {
d351 3
a353 7
		} else {
			host.h_length = n;
			getclass = class;
			host.h_addrtype = (class == C_IN) ? AF_INET : AF_UNSPEC;
			if (host.h_addrtype == AF_INET)
				host.h_length = INADDRSZ;
			if (!iquery) {
d355 3
a357 3
				bp += strlen(bp) + 1;
				if (strlen(host.h_name) >= MAXHOSTNAMELEN)
					host.h_name[MAXHOSTNAMELEN-1] = '\0';
a358 1
		}
d360 1
a360 1
		bp += sizeof(align) - ((u_long)bp % sizeof(align));
d362 10
a371 1
		if (bp + n >= &hostbuf[sizeof(hostbuf)]) {
d373 2
a374 2
			if (_res.options & RES_DEBUG)
				printf("size (%d) too big\n", n);
d376 7
d384 2
d387 2
a388 4
		bcopy(cp, *hap++ = bp, n);
		bp +=n;
		cp += n;
		haveanswer++;
d390 25
a414 3
	if (!haveanswer) {
		h_errno = TRY_AGAIN;
		return ((struct hostent *) NULL);
d416 3
a418 17
	*ap = NULL;
	*hap = NULL;
	if (_res.nsort) {
		qsort(host.h_addr_list, haveanswer,
		    sizeof(struct in_addr),
		    (int (*)__P((const void *, const void *)))qcomp);
	}
gotent:
	if (hbadchar(host.h_name))
		good = 0;
	for (ap = host_aliases; good && *ap; ap++)
		if (hbadchar(*ap))
			good = 0;
	if (good)
		return (&host);
	h_errno = NO_RECOVERY;
	return ((struct hostent *) NULL);
d425 19
d446 3
a448 2
	int n, i;
	extern struct hostent *_gethtbyname(), *_yp_gethtbyname();
d452 29
d495 1
a495 1
				if (!inet_aton(name, &host_addr)) {
d497 1
a497 1
					return((struct hostent *) NULL);
d499 5
a503 1
				host.h_name = (char *)name;
d506 1
a506 3
				host.h_addrtype = AF_INET;
				host.h_length = sizeof(u_int32_t);
				h_addr_ptrs[0] = (char *)&host_addr;
d509 3
d517 30
a546 3

	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
		return (_gethtbyname(name));
d557 3
a559 1
			hp = _yp_gethtbyname(name);
d563 1
a563 1
			if ((n = res_search(name, C_IN, T_A, buf.buf,
d571 1
a571 1
			hp = getanswer(&buf, n, 0);
d574 1
a574 1
			hp = _gethtbyname(name);
d582 8
a589 5
gethostbyaddr(addr, len, type)
	const char *addr;
	int len, type;
{
	int n, i;
d592 1
a592 1
	char qbuf[MAXDNAME];
d596 2
a597 7
	if (type != AF_INET)
		return ((struct hostent *) NULL);
	(void)sprintf(qbuf, "%u.%u.%u.%u.in-addr.arpa",
		((unsigned)addr[3] & 0xff),
		((unsigned)addr[2] & 0xff),
		((unsigned)addr[1] & 0xff),
		((unsigned)addr[0] & 0xff));
d599 46
a644 2
	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
		return (_gethtbyaddr(addr, len, type));
d655 3
a657 1
			hp = _yp_gethtbyaddr(addr);
d661 2
a662 1
			n = res_query(qbuf, C_IN, T_PTR, (u_char *)&buf, sizeof(buf));
d668 1
a668 1
				break;
d670 3
a672 4
			hp = getanswer(&buf, n, 1);
			if (hp == NULL)
				break;
			hp->h_addrtype = type;
d674 10
a683 3
			h_addr_ptrs[0] = (char *)&host_addr;
			h_addr_ptrs[1] = (char *)0;
			host_addr = *(struct in_addr *)addr;
d686 1
a686 1
			hp = _gethtbyaddr(addr, len, type);
d718 1
d720 2
a721 1
	if (hostf == NULL && (hostf = fopen(_PATH_HOSTS, "r" )) == NULL)
d723 4
a726 2
again:
	if ((p = fgets(hostbuf, BUFSIZ, hostf)) == NULL)
d728 1
d731 1
a731 2
	cp = strpbrk(p, "#\n");
	if (cp == NULL)
d734 1
a734 2
	cp = strpbrk(p, " \t");
	if (cp == NULL)
d737 17
a753 2
	/* THIS STUFF IS INTERNET SPECIFIC */
	h_addr_ptrs[0] = (char *)&host_addr;
a754 1
	(void) inet_aton(p, &host_addr);
d756 2
a757 2
	host.h_length = sizeof(u_int32_t);
	host.h_addrtype = AF_INET;
d762 1
a762 2
	cp = strpbrk(cp, " \t");
	if (cp != NULL) 
d771 1
a771 2
		cp = strpbrk(cp, " \t");
		if (cp != NULL)
d775 7
d789 16
d810 2
d818 1
a818 1
found:
a819 2
	if (p==NULL)
		h_errno = HOST_NOT_FOUND;
d824 1
a824 1
_gethtbyaddr(addr, len, type)
d826 1
a826 1
	int len, type;
d832 1
a832 1
		if (p->h_addrtype == type && !bcmp(p->h_addr, addr, len))
a834 2
	if (p==NULL)
		h_errno = HOST_NOT_FOUND;
a837 17
static int
qcomp(a1, a2)
	struct in_addr **a1, **a2;
{
	int pos1, pos2;

	for (pos1 = 0; pos1 < _res.nsort; pos1++)
		if (_res.sort_list[pos1].addr.s_addr ==
		    ((*a1)->s_addr & _res.sort_list[pos1].mask))
			break;
	for (pos2 = 0; pos2 < _res.nsort; pos2++)
		if (_res.sort_list[pos2].addr.s_addr ==
		    ((*a2)->s_addr & _res.sort_list[pos2].mask))
			break;
	return pos1 - pos2;
}

d959 1
a959 1
	if (r==0)
d961 1
a961 1
	if (hp==NULL)
d964 94
@


1.12
log
@bzzzt
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.10 1996/09/27 18:37:11 deraadt Exp $";
d198 2
@


1.11
log
@more INADDRSZ pedantry
@
text
@a173 1
			host.h_length = INADDRSZ;
d243 11
a253 9
		if (n != host.h_length) {
			cp += n;
			continue;
		}
		if (class != getclass) {
			cp += n;
			continue;
		}
		if (!haveanswer) {
d256 2
@


1.10
log
@use INADDRSZ, more careful length checking
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.9 1996/09/26 09:13:21 deraadt Exp $";
d174 1
d244 9
a252 11
		if (haveanswer) {
			if (n != host.h_length) {
				cp += n;
				continue;
			}
			if (class != getclass) {
				cp += n;
				continue;
			}
		} else {
			host.h_length = n;
a254 2
			if (host.h_addrtype == AF_INET)
				host.h_length = INADDRSZ;
@


1.9
log
@be safer about spoofed hostnames; thanks to bitblt and oliver for help with these ideas
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.8 1996/09/15 10:09:12 tholo Exp $";
d215 2
d242 1
d257 1
a257 1
				host.h_length = sizeof(struct in_addr);
d260 2
a261 1
				if (strlen(bp) >= MAXHOSTNAMELEN)
a262 1
				bp += strlen(bp) + 1;
a275 2
		if (n >= MAXHOSTNAMELEN)
			bp[MAXHOSTNAMELEN-1] = '\0';
d581 1
a581 1
	host.h_length = sizeof(u_int32_t);
@


1.8
log
@Add a couple of syscalls; bring more prototypes into scope
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.7 1996/08/19 08:28:40 tholo Exp $";
d104 2
a105 2
    int32_t al;
    char ac;
d110 1
d114 24
d152 1
d229 1
a229 1
			return(&host);
d253 2
d279 1
a279 10
	if (haveanswer) {
		*ap = NULL;
		*hap = NULL;
		if (_res.nsort) {
			qsort(host.h_addr_list, haveanswer,
			    sizeof(struct in_addr),
			    (int (*)__P((const void *, const void *)))qcomp);
		}
		return (&host);
	} else {
d283 17
@


1.7
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: gethostnamadr.c,v 1.13 1995/05/21 16:21:14 mycroft Exp $";
d73 1
@


1.6
log
@truncate h_name and h_aliases[] to MAXHOSTNAMELEN
@
text
@a0 2
/*	$NetBSD: gethostnamadr.c,v 1.13 1995/05/21 16:21:14 mycroft Exp $	*/

d55 1
a55 6
#if 0
static char sccsid[] = "@@(#)gethostnamadr.c	8.1 (Berkeley) 6/4/93";
static char rcsid[] = "$Id: gethnamaddr.c,v 4.9.1.1 1993/05/02 22:43:03 vixie Rel ";
#else
static char rcsid[] = "$NetBSD: gethostnamadr.c,v 1.13 1995/05/21 16:21:14 mycroft Exp $";
#endif
@


1.5
log
@yp_prot.h lies -> use yp.h (from yp.x) instead, change lots of structure
accesses to match. change xdr_domainname() and some other functions to
take "char **" instead of "char *", as rpcgen intended -- helps programs
linking against rpcgen output of yp.x.  yp_all() should not free it's
return value. split xdryp.c and yplib.c into ~20 files so binaries like
"csh" need not link in functions like yp_maplist(). NIS+'s YP emulation
code lacks YPPROC_ORDER... attempt to deal nicely.
@
text
@d154 4
a157 1
			n = strlen(bp) + 1;
d206 3
d235 2
d251 2
@


1.4
log
@Pull in prototypes
Do the right thing in presense of __STDC__
@
text
@d78 1
a78 1
#include <rpcsvc/yp_prot.h>
@


1.3
log
@netbsd: bind 4.9.3
@
text
@d147 1
a147 1
			    (u_char *)eom, (u_char *)cp, (u_char *)bp,
d177 1
a177 1
		    (u_char *)cp, (u_char *)bp, buflen)) < 0)
d198 1
a198 1
			    (u_char *)eom, (u_char *)cp, (u_char *)bp,
d371 1
a371 1
			hp = _yp_gethtbyaddr(addr, len, type);
d375 1
a375 1
			n = res_query(qbuf, C_IN, T_PTR, (char *)&buf, sizeof(buf));
d472 1
a472 1
	char *name;
d601 1
a601 1
_yp_gethtbyaddr(addr, len, type)
a602 1
	int len, type;
@


1.2
log
@gethostbyname("#.#.#.#") should fail; not return an incompletely and
incorrectly initialized hostent. in particular, h_name is supposed to
be `an official name', and gethostbyname() wasn't even trying to meet
that requirement.
@
text
@a272 1
#ifdef insecure
a303 1
#endif
@


1.1
log
@Initial revision
@
text
@d273 1
d305 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

