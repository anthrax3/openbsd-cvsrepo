head	1.27;
access;
symbols
	OPENBSD_5_4:1.26.0.34
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.32
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.30
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.28
	OPENBSD_5_0:1.26.0.26
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.24
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.22
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.18
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.20
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.16
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.14
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.12
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.10
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.8
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.6
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.23.0.8
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.6
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.8
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.6
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.27
date	2013.11.12.20.37.15;	author eric;	state dead;
branches;
next	1.26;

1.26
date	2005.08.06.20.30.03;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.30.02.58.28;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.03.21.09.00;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.20.18.35;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.05.00.43.19;	author tdeval;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.28.04.58.00;	author marc;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.14.02.48.00;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.27.08.53.13;	author itojun;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2002.07.25.21.13.45;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.26.06.00.54;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.06.27.00.58.55;	author lebel;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	99.06.04.06.38.10;	author niklas;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	99.05.30.14.20.29;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.05.30.14.06.08;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.12.02.01.34.05;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.12.01.23.40.01;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.04.10.34.48;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.14.04.25.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.13.20.38.07;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.04.05.21.13.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.04.03.08.33.06;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.04.03.07.31.55;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.04.03.02.15.16;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	97.03.13.19.07.27;	author downsj;	state Exp;
branches;
next	;

1.13.8.1
date	2002.06.26.06.02.54;	author millert;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.26.06.03.31;	author millert;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.09.09.18.25.08;	author miod;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.11.14.23.44.14;	author millert;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.26.06.03.49;	author millert;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.09.06.05.46.51;	author jason;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.11.14.23.34.39;	author millert;	state Exp;
branches;
next	;

1.18.2.1
date	2002.11.14.23.50.10;	author millert;	state Exp;
branches;
next	;


desc
@@


1.27
log
@remove dead files

ok deraadt@@
@
text
@/*	$OpenBSD: getnetnamadr.c,v 1.26 2005/08/06 20:30:03 espie Exp $	*/

/*
 * Copyright (c) 1997, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/* Copyright (c) 1993 Carlos Leandro and Rui Salgueiro
 *	Dep. Matematica Universidade de Coimbra, Portugal, Europe
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 */
/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <stdio.h>
#include <netdb.h>
#include <resolv.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

#include "thread_private.h"

extern int h_errno;

struct netent *_getnetbyaddr(in_addr_t net, int type);
struct netent *_getnetbyname(const char *name);

int _hokchar(const char *);

#define BYADDR 0
#define BYNAME 1
#define	MAXALIASES	35

#define	MAXPACKET	(64*1024)

typedef union {
	HEADER	hdr;
	u_char	buf[MAXPACKET];
} querybuf;

typedef union {
	long	al;
	char	ac;
} align;

static struct netent *
getnetanswer(querybuf *answer, int anslen, int net_i)
{

	HEADER *hp;
	u_char *cp;
	int n;
	u_char *eom;
	int type, class, ancount, qdcount, haveanswer, i, nchar;
	char aux1[MAXHOSTNAMELEN], aux2[MAXHOSTNAMELEN], ans[MAXHOSTNAMELEN];
	char *in, *st, *pauxt, *bp, **ap, *ep;
	char *paux1 = &aux1[0], *paux2 = &aux2[0];
	static	struct netent net_entry;
	static	char *net_aliases[MAXALIASES], netbuf[BUFSIZ+1];

	/*
	 * find first satisfactory answer
	 *
	 *      answer --> +------------+  ( MESSAGE )
	 *		   |   Header   |
	 *		   +------------+
	 *		   |  Question  | the question for the name server
	 *		   +------------+
	 *		   |   Answer   | RRs answering the question
	 *		   +------------+
	 *		   | Authority  | RRs pointing toward an authority
	 *		   | Additional | RRs holding additional information
	 *		   +------------+
	 */
	eom = answer->buf + anslen;
	hp = &answer->hdr;
	ancount = ntohs(hp->ancount); /* #/records in the answer section */
	qdcount = ntohs(hp->qdcount); /* #/entries in the question section */
	bp = netbuf;
	ep = netbuf + sizeof(netbuf);
	cp = answer->buf + HFIXEDSZ;
	if (!qdcount) {
		if (hp->aa)
			h_errno = HOST_NOT_FOUND;
		else
			h_errno = TRY_AGAIN;
		return (NULL);
	}
	while (qdcount-- > 0) {
		n = __dn_skipname(cp, eom);
		if (n < 0 || (cp + n + QFIXEDSZ) > eom) {
			h_errno = NO_RECOVERY;
			return(NULL);
		}
		cp += n + QFIXEDSZ;
	}
	ap = net_aliases;
	*ap = NULL;
	net_entry.n_aliases = net_aliases;
	haveanswer = 0;
	while (--ancount >= 0 && cp < eom) {
		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
#ifdef USE_RESOLV_NAME_OK
		if ((n < 0) || !res_dnok(bp))
#else
		if ((n < 0) || !_hokchar(bp))
#endif
			break;
		cp += n;
		ans[0] = '\0';
		strlcpy(&ans[0], bp, sizeof ans);
		GETSHORT(type, cp);
		GETSHORT(class, cp);
		cp += INT32SZ;		/* TTL */
		GETSHORT(n, cp);
		if (class == C_IN && type == T_PTR) {
			n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
#ifdef USE_RESOLV_NAME_OK
			if ((n < 0) || !res_hnok(bp))
#else
			if ((n < 0) || !_hokchar(bp))
#endif
			{
				cp += n;
				return (NULL);
			}
			cp += n; 
			if ((ap + 2) < &net_aliases[MAXALIASES]) {
				*ap++ = bp;
				bp += strlen(bp) + 1;
				net_entry.n_addrtype =
					(class == C_IN) ? AF_INET : AF_UNSPEC;
				haveanswer++;
			}
		}
	}
	if (haveanswer) {
		*ap = NULL;
		switch (net_i) {
		case BYADDR:
			net_entry.n_name = *net_entry.n_aliases;
			net_entry.n_net = 0L;
			break;
		case BYNAME:
			ap = net_entry.n_aliases;
		next_alias:
			in = *ap++;
			if (in == NULL) {
				h_errno = HOST_NOT_FOUND;
				return (NULL);
			}
			net_entry.n_name = ans;
			aux2[0] = '\0';
			for (i = 0; i < 4; i++) {
				for (st = in, nchar = 0;
				     isdigit((unsigned char)*st);
				     st++, nchar++)
					;
				if (*st != '.' || nchar == 0 || nchar > 3)
					goto next_alias;
				if (i != 0)
					nchar++;
				strlcpy(paux1, in, nchar+1);
				strlcat(paux1, paux2, MAXHOSTNAMELEN);
				pauxt = paux2;
				paux2 = paux1;
				paux1 = pauxt;
				in = ++st;
			}		  
			if (strcasecmp(in, "IN-ADDR.ARPA") != 0)
				goto next_alias;
			net_entry.n_net = inet_network(paux2);
			break;
		}
		net_entry.n_aliases++;
		return (&net_entry);
	}
	h_errno = TRY_AGAIN;
	return (NULL);
}

struct netent *
getnetbyaddr(in_addr_t net, int net_type)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	unsigned int netbr[4];
	int nn, anslen;
	querybuf *buf;
	char qbuf[MAXDNAME];
	in_addr_t net2;
	struct netent *net_entry = NULL;
	char lookups[MAXDNSLUS];
	int i;

	if (_res_init(0) == -1)
		return(_getnetbyaddr(net, net_type));

	bcopy(_resp->lookups, lookups, sizeof lookups);
	if (lookups[0] == '\0')
		strlcpy(lookups, "bf", sizeof lookups);

	for (i = 0; i < MAXDNSLUS && lookups[i]; i++) {
		switch (lookups[i]) {
#ifdef YP
		case 'y':
			/* There is no YP support. */
			break;
#endif	/* YP */
		case 'b':
			if (net_type != AF_INET)
				break;	/* DNS only supports AF_INET? */

			for (nn = 4, net2 = net; net2; net2 >>= 8)
				netbr[--nn] = net2 & 0xff;
			switch (nn) {
			case 3: 	/* Class A */
				snprintf(qbuf, sizeof(qbuf),
				    "0.0.0.%u.in-addr.arpa", netbr[3]);
				break;
			case 2: 	/* Class B */
				snprintf(qbuf, sizeof(qbuf),
				    "0.0.%u.%u.in-addr.arpa",
		    		    netbr[3], netbr[2]);
				break;
			case 1: 	/* Class C */
				snprintf(qbuf, sizeof(qbuf),
				    "0.%u.%u.%u.in-addr.arpa",
		    		    netbr[3], netbr[2], netbr[1]);
				break;
			case 0: 	/* Class D - E */
				snprintf(qbuf, sizeof(qbuf),
				    "%u.%u.%u.%u.in-addr.arpa",
				    netbr[3], netbr[2], netbr[1], netbr[0]);
				break;
			}
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			anslen = res_query(qbuf, C_IN, T_PTR, buf->buf,
			    sizeof(buf->buf));
			if (anslen < 0) {
				free(buf);
#ifdef DEBUG
				if (_resp->options & RES_DEBUG)
					printf("res_query failed\n");
#endif
				break;
			}
			net_entry = getnetanswer(buf, anslen, BYADDR);
			free(buf);
			if (net_entry != NULL) {
				unsigned u_net = net;	/* maybe net should be unsigned ? */

				/* Strip trailing zeros */
				while ((u_net & 0xff) == 0 && u_net != 0)
					u_net >>= 8;
				net_entry->n_net = u_net;
				return (net_entry);
			}
			break;
		case 'f':
			net_entry = _getnetbyaddr(net, net_type);
			if (net_entry != NULL)
				return (net_entry);
		}
	}

	/* Nothing matched. */
	return (NULL);
}

struct netent *
getnetbyname(const char *net)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	int anslen;
	querybuf *buf;
	char qbuf[MAXDNAME];
	struct netent *net_entry = NULL;
	char lookups[MAXDNSLUS];
	int i;

	if (_res_init(0) == -1)
		return (_getnetbyname(net));

	bcopy(_resp->lookups, lookups, sizeof lookups);
	if (lookups[0] == '\0')
		strlcpy(lookups, "bf", sizeof lookups);

	for (i = 0; i < MAXDNSLUS && lookups[i]; i++) {
		switch (lookups[i]) {
#ifdef YP
		case 'y':
			/* There is no YP support. */
			break;
#endif	/* YP */
		case 'b':
			strlcpy(qbuf, net, sizeof qbuf);
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			anslen = res_search(qbuf, C_IN, T_PTR, buf->buf,
			    sizeof(buf->buf));
			if (anslen < 0) {
				free(buf);
#ifdef DEBUG
				if (_resp->options & RES_DEBUG)
					printf("res_query failed\n");
#endif
				break;
			}
			net_entry = getnetanswer(buf, anslen, BYNAME);
			free(buf);
			if (net_entry != NULL)
				return (net_entry);
			break;
		case 'f':
			net_entry = _getnetbyname(net);
			if (net_entry != NULL)
				return (net_entry);
			break;
		}
	}

	/* Nothing matched. */
	return (NULL);
}
@


1.26
log
@zap rcsid.
split functions off res_debug.c so that getnetnamadr.c does not pull it
all when it's used.

okay deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.25 2005/03/30 02:58:28 tedu Exp $	*/
@


1.25
log
@make the resolver stat resolv.conf and update if it changes.
useful feedback and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.24 2005/03/25 13:24:12 otto Exp $	*/
a61 10

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)getnetbyaddr.c	8.1 (Berkeley) 6/4/93";
static char sccsid_[] = "from getnetnamadr.c	1.4 (Coimbra) 93/06/03";
static char rcsid[] = "$From: getnetnamadr.c,v 8.7 1996/08/05 08:31:35 vixie Exp $";
#else
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.24 2005/03/25 13:24:12 otto Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.24
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.23 2003/06/03 21:09:00 deraadt Exp $	*/
d69 1
a69 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.23 2003/06/03 21:09:00 deraadt Exp $";
d262 1
a262 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1)
d350 1
a350 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1)
@


1.23
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.22 2003/06/02 20:18:35 millert Exp $	*/
d69 1
a69 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.22 2003/06/02 20:18:35 millert Exp $";
d114 1
a114 4
getnetanswer(answer, anslen, net_i)
	querybuf *answer;
	int anslen;
	int net_i;
d117 3
a119 3
	register HEADER *hp;
	register u_char *cp;
	register int n;
d250 1
a250 3
getnetbyaddr(net, net_type)
	register in_addr_t net;
	register int net_type;
d340 1
a340 2
getnetbyname(net)
	register const char *net;
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.21 2003/04/05 00:43:19 tdeval Exp $	*/
a13 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jason Downs for the
 *      OpenBSD system.
 * 4. Neither the name(s) of the author(s) nor the name OpenBSD
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d69 1
a69 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.21 2003/04/05 00:43:19 tdeval Exp $";
@


1.21
log
@strcpy/strcat -> strlcpy/strlcat
ok tedu@@, hints by deraadt@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.20 2003/01/28 04:58:00 marc Exp $	*/
d53 1
a53 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d76 1
a76 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.20 2003/01/28 04:58:00 marc Exp $";
@


1.20
log
@
thread safer libc (note: safer, not safe)
Access to the global _res structure replaced by pointers to a
per thread instance.  If unthreaded the pointer is to the
global structure.

Also replaced a 64k stack array with malloc-ed memory so
threaded aps (with a default 64k stack) have a chance at working.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.19 2002/11/14 02:48:00 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.19 2002/11/14 02:48:00 millert Exp $";
d245 1
d247 1
a247 1
				paux2 = strcat(paux1, paux2);
@


1.19
log
@Updates from http://www.isc.org/products/BIND/patches/bind4910.diff
 o check __dn_skipname() return value for errors
 o fix sanity checking of reverse records, getnetbyname() may not
   have been working before.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.18 2002/08/27 08:53:13 itojun Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.18 2002/08/27 08:53:13 itojun Exp $";
d99 2
d267 1
d277 1
a277 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
d280 1
a280 1
	bcopy(_res.lookups, lookups, sizeof lookups);
d326 1
a326 1
				if (_res.options & RES_DEBUG)
d358 1
d366 1
a366 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
d369 1
a369 1
	bcopy(_res.lookups, lookups, sizeof lookups);
d390 1
a390 1
				if (_res.options & RES_DEBUG)
@


1.18
log
@allocate 64K recieve buffer for DNS responses.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.17 2002/07/25 21:13:45 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.17 2002/07/25 21:13:45 deraadt Exp $";
d136 1
a136 1
	char *paux1 = &aux1[0], *paux2 = &aux2[0], flag = 0;
d168 8
a175 2
	while (qdcount-- > 0)
		cp += __dn_skipname(cp, eom) + QFIXEDSZ;
d207 7
a213 5
			*ap++ = bp;
			bp += strlen(bp) + 1;
			net_entry.n_addrtype =
				(class == C_IN) ? AF_INET : AF_UNSPEC;
			haveanswer++;
d224 8
a231 2
			in = *net_entry.n_aliases;
			net_entry.n_name = &ans[0];
d235 1
a235 1
				     *st != '.';
d238 8
a245 9
				if (nchar != 1 || *in != '0' || flag) {
					flag = 1;
					strlcpy(paux1, 
						(i==0) ? in : in-1, 
						(i==0) ? nchar+1 : nchar+2);
					pauxt = paux2;
					paux2 = strcat(paux1, paux2);
					paux1 = pauxt;
				}
d248 2
@


1.18.2.1
log
@Apply http://www.isc.org/products/BIND/patches/bind4910.diff
Fixes bugs listed in http://www.isc.org/products/BIND/bind-security.html
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.18 2002/08/27 08:53:13 itojun Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.18 2002/08/27 08:53:13 itojun Exp $";
d136 1
a136 1
	char *paux1 = &aux1[0], *paux2 = &aux2[0];
d168 2
a169 8
	while (qdcount-- > 0) {
		n = __dn_skipname(cp, eom);
		if (n < 0 || (cp + n + QFIXEDSZ) > eom) {
			h_errno = NO_RECOVERY;
			return(NULL);
		}
		cp += n + QFIXEDSZ;
	}
d201 5
a205 7
			if ((ap + 2) < &net_aliases[MAXALIASES]) {
				*ap++ = bp;
				bp += strlen(bp) + 1;
				net_entry.n_addrtype =
					(class == C_IN) ? AF_INET : AF_UNSPEC;
				haveanswer++;
			}
d216 2
a217 8
			ap = net_entry.n_aliases;
		next_alias:
			in = *ap++;
			if (in == NULL) {
				h_errno = HOST_NOT_FOUND;
				return (NULL);
			}
			net_entry.n_name = ans;
d221 1
a221 1
				     isdigit((unsigned char)*st);
d224 9
a232 8
				if (*st != '.' || nchar == 0 || nchar > 3)
					goto next_alias;
				if (i != 0)
					nchar++;
				strlcpy(paux1, in, nchar+1);
				pauxt = paux2;
				paux2 = strcat(paux1, paux2);
				paux1 = pauxt;
a234 2
			if (strcasecmp(in, "IN-ADDR.ARPA") != 0)
				goto next_alias;
@


1.17
log
@kill more strcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.16 2002/06/26 06:00:54 itojun Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.16 2002/06/26 06:00:54 itojun Exp $";
d97 1
d110 1
a110 5
#if PACKETSZ > 1024
#define	MAXPACKET	PACKETSZ
#else
#define	MAXPACKET	1024
#endif
d252 1
a252 1
	querybuf buf;
d300 5
a304 2
			anslen = res_query(qbuf, C_IN, T_PTR, (u_char *)&buf,
			    sizeof(buf));
d306 1
d313 2
a314 1
			net_entry = getnetanswer(&buf, anslen, BYADDR);
d341 1
a341 1
	querybuf buf;
d363 5
a367 2
			anslen = res_search(qbuf, C_IN, T_PTR, (u_char *)&buf,
			    sizeof(buf));
d369 1
d376 2
a377 1
			net_entry = getnetanswer(&buf, anslen, BYNAME);
@


1.16
log
@avoid remote buffer overrun on hostbuf[].  From: Joost Pol <joost@@pine.nl>

correct bad practice in the code - it uses two changing variables
to manage buffer (buf and buflen).  we eliminate buflen and use
fixed point (ep) as the ending pointer.

this fix is critical.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.15 2002/02/16 21:27:23 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.15 2002/02/16 21:27:23 millert Exp $";
d267 1
a267 1
		strncpy(lookups, "bf", sizeof lookups);
d350 1
a350 1
		strncpy(lookups, "bf", sizeof lookups);
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.14 2001/06/27 00:58:55 lebel Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.14 2001/06/27 00:58:55 lebel Exp $";
d136 1
a136 1
	int type, class, buflen, ancount, qdcount, haveanswer, i, nchar;
d138 1
a138 1
	char *in, *st, *pauxt, *bp, **ap;
d162 1
a162 1
	buflen = sizeof(netbuf);
d178 1
a178 1
		n = dn_expand(answer->buf, eom, cp, bp, buflen);
d193 1
a193 1
			n = dn_expand(answer->buf, eom, cp, bp, buflen);
d195 1
a195 1
			if ((n < 0) || !res_hnok(bp)) {
d197 1
a197 1
			if ((n < 0) || !_hokchar(bp)) {
d199 1
@


1.15.2.1
log
@avoid remote buffer overrun on hostbuf[].  From: Joost Pol <joost@@pine.nl>

correct bad practice in the code - it uses two changing variables
to manage buffer (buf and buflen).  we eliminate buflen and use
fixed point (ep) as the ending pointer.  From: itojun

this fix is critical.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.15 2002/02/16 21:27:23 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.15 2002/02/16 21:27:23 millert Exp $";
d136 1
a136 1
	int type, class, ancount, qdcount, haveanswer, i, nchar;
d138 1
a138 1
	char *in, *st, *pauxt, *bp, **ap, *ep;
d162 1
a162 1
	ep = netbuf + sizeof(netbuf);
d178 1
a178 1
		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d193 1
a193 1
			n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d195 1
a195 1
			if ((n < 0) || !res_hnok(bp))
d197 1
a197 1
			if ((n < 0) || !_hokchar(bp))
a198 1
			{
@


1.15.2.2
log
@Pull in patch from current:
Fix (itojun):
allocate 64K recieve buffer for DNS responses.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.15.2.1 2002/06/26 06:03:49 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.15.2.1 2002/06/26 06:03:49 millert Exp $";
a96 1
#include <stdlib.h>
d109 5
a113 1
#define	MAXPACKET	(64*1024)
d255 1
a255 1
	querybuf *buf;
d303 2
a304 5
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			anslen = res_query(qbuf, C_IN, T_PTR, buf->buf,
			    sizeof(buf->buf));
a305 1
				free(buf);
d312 1
a312 2
			net_entry = getnetanswer(buf, anslen, BYADDR);
			free(buf);
d339 1
a339 1
	querybuf *buf;
d361 2
a362 5
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			anslen = res_search(qbuf, C_IN, T_PTR, buf->buf,
			    sizeof(buf->buf));
a363 1
				free(buf);
d370 1
a370 2
			net_entry = getnetanswer(buf, anslen, BYNAME);
			free(buf);
@


1.15.2.3
log
@Apply http://www.isc.org/products/BIND/patches/bind4910.diff
Fixes bugs listed in http://www.isc.org/products/BIND/bind-security.html
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.15.2.2 2002/09/06 05:46:51 jason Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.15.2.2 2002/09/06 05:46:51 jason Exp $";
d136 1
a136 1
	char *paux1 = &aux1[0], *paux2 = &aux2[0];
d168 2
a169 8
	while (qdcount-- > 0) {
		n = __dn_skipname(cp, eom);
		if (n < 0 || (cp + n + QFIXEDSZ) > eom) {
			h_errno = NO_RECOVERY;
			return(NULL);
		}
		cp += n + QFIXEDSZ;
	}
d201 5
a205 7
			if ((ap + 2) < &net_aliases[MAXALIASES]) {
				*ap++ = bp;
				bp += strlen(bp) + 1;
				net_entry.n_addrtype =
					(class == C_IN) ? AF_INET : AF_UNSPEC;
				haveanswer++;
			}
d216 2
a217 8
			ap = net_entry.n_aliases;
		next_alias:
			in = *ap++;
			if (in == NULL) {
				h_errno = HOST_NOT_FOUND;
				return (NULL);
			}
			net_entry.n_name = ans;
d221 1
a221 1
				     isdigit((unsigned char)*st);
d224 9
a232 8
				if (*st != '.' || nchar == 0 || nchar > 3)
					goto next_alias;
				if (i != 0)
					nchar++;
				strlcpy(paux1, in, nchar+1);
				pauxt = paux2;
				paux2 = strcat(paux1, paux2);
				paux1 = pauxt;
a234 2
			if (strcasecmp(in, "IN-ADDR.ARPA") != 0)
				goto next_alias;
@


1.14
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.13 1999/06/04 06:38:10 niklas Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.13 1999/06/04 06:38:10 niklas Exp $";
d100 2
a101 2
struct netent *_getnetbyaddr __P((in_addr_t net, int type));
struct netent *_getnetbyname __P((const char *name));
d103 1
a103 1
int _hokchar __P((const char *));
@


1.14.2.1
log
@avoid remote buffer overrun on hostbuf[].  From: Joost Pol <joost@@pine.nl>

correct bad practice in the code - it uses two changing variables
to manage buffer (buf and buflen).  we eliminate buflen and use
fixed point (ep) as the ending pointer.  From: itojun

this fix is critical.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.14 2001/06/27 00:58:55 lebel Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.14 2001/06/27 00:58:55 lebel Exp $";
d136 1
a136 1
	int type, class, ancount, qdcount, haveanswer, i, nchar;
d138 1
a138 1
	char *in, *st, *pauxt, *bp, **ap, *ep;
d162 1
a162 1
	ep = netbuf + sizeof(netbuf);
d178 1
a178 1
		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d193 1
a193 1
			n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d195 1
a195 1
			if ((n < 0) || !res_hnok(bp))
d197 1
a197 1
			if ((n < 0) || !_hokchar(bp))
a198 1
			{
@


1.14.2.2
log
@MFC (itojun):
allocate 64K receive buffer for DNS responses.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.14.2.1 2002/06/26 06:03:31 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.14.2.1 2002/06/26 06:03:31 millert Exp $";
a96 1
#include <stdlib.h>
d109 5
a113 1
#define	MAXPACKET	(64*1024)
d255 1
a255 1
	querybuf *buf;
d303 2
a304 5
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			anslen = res_query(qbuf, C_IN, T_PTR, buf->buf,
			    sizeof(buf->buf));
a305 1
				free(buf);
d312 1
a312 2
			net_entry = getnetanswer(buf, anslen, BYADDR);
			free(buf);
d339 1
a339 1
	querybuf *buf;
d361 2
a362 5
			buf = malloc(sizeof(*buf));
			if (buf == NULL)
				break;
			anslen = res_search(qbuf, C_IN, T_PTR, buf->buf,
			    sizeof(buf->buf));
a363 1
				free(buf);
d370 1
a370 2
			net_entry = getnetanswer(buf, anslen, BYNAME);
			free(buf);
@


1.14.2.3
log
@Apply http://www.isc.org/products/BIND/patches/bind4910.diff
Fixes bugs listed in http://www.isc.org/products/BIND/bind-security.html
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.14.2.2 2002/09/09 18:25:08 miod Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.14.2.2 2002/09/09 18:25:08 miod Exp $";
d136 1
a136 1
	char *paux1 = &aux1[0], *paux2 = &aux2[0];
d168 2
a169 8
	while (qdcount-- > 0) {
		n = __dn_skipname(cp, eom);
		if (n < 0 || (cp + n + QFIXEDSZ) > eom) {
			h_errno = NO_RECOVERY;
			return(NULL);
		}
		cp += n + QFIXEDSZ;
	}
d201 5
a205 7
			if ((ap + 2) < &net_aliases[MAXALIASES]) {
				*ap++ = bp;
				bp += strlen(bp) + 1;
				net_entry.n_addrtype =
					(class == C_IN) ? AF_INET : AF_UNSPEC;
				haveanswer++;
			}
d216 2
a217 8
			ap = net_entry.n_aliases;
		next_alias:
			in = *ap++;
			if (in == NULL) {
				h_errno = HOST_NOT_FOUND;
				return (NULL);
			}
			net_entry.n_name = ans;
d221 1
a221 1
				     isdigit((unsigned char)*st);
d224 9
a232 8
				if (*st != '.' || nchar == 0 || nchar > 3)
					goto next_alias;
				if (i != 0)
					nchar++;
				strlcpy(paux1, in, nchar+1);
				pauxt = paux2;
				paux2 = strcat(paux1, paux2);
				paux1 = pauxt;
a234 2
			if (strcasecmp(in, "IN-ADDR.ARPA") != 0)
				goto next_alias;
@


1.13
log
@Be consistent about the relaxation of invalid host name checking.
This allows CNAMEs to PTRs with names including slashes, something not really
RFC-compliant but still in general use.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.12 1999/05/30 14:20:29 niklas Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.12 1999/05/30 14:20:29 niklas Exp $";
d187 1
a187 2
		(void)strncpy(&ans[0], bp, sizeof ans-1);
		ans[sizeof ans-1] = '\0';
d228 3
a230 4
					(void)strncpy(paux1,
						      (i==0) ? in : in-1,
						      (i==0) ?nchar : nchar+1);
					paux1[(i==0) ? nchar : nchar+1] = '\0';
d359 1
a359 2
			strncpy(qbuf, net, sizeof qbuf-1);
			qbuf[sizeof qbuf-1] = '\0';
@


1.13.8.1
log
@avoid remote buffer overrun on hostbuf[].  From: Joost Pol <joost@@pine.nl>

correct bad practice in the code - it uses two changing variables
to manage buffer (buf and buflen).  we eliminate buflen and use
fixed point (ep) as the ending pointer.  From: itojun

this fix is critical.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.13 1999/06/04 06:38:10 niklas Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.13 1999/06/04 06:38:10 niklas Exp $";
d136 1
a136 1
	int type, class, ancount, qdcount, haveanswer, i, nchar;
d138 1
a138 1
	char *in, *st, *pauxt, *bp, **ap, *ep;
d162 1
a162 1
	ep = netbuf + sizeof(netbuf);
d178 1
a178 1
		n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d194 1
a194 1
			n = dn_expand(answer->buf, eom, cp, bp, ep - bp);
d196 1
a196 1
			if ((n < 0) || !res_hnok(bp))
d198 1
a198 1
			if ((n < 0) || !_hokchar(bp))
a199 1
			{
@


1.12
log
@Revertion of last change, which was due to emacs' stupid idea
of keeping the "*Shell Command Output*" buffer's wd from its creation instead
of using the last command's wd!!!!
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.10 1997/12/02 01:34:05 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.10 1997/12/02 01:34:05 deraadt Exp $";
d195 1
d197 3
@


1.11
log
@Some extra error checking, documentation and style wrt connections
@
text
@a194 1
#ifdef USE_RESOLV_NAME_OK
a195 3
#else
			if ((n < 0) || !_hokchar(bp)) {
#endif
@


1.10
log
@i failed to test compile this before commiting
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.9 1997/12/01 23:40:01 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.9 1997/12/01 23:40:01 deraadt Exp $";
d195 1
d197 3
@


1.9
log
@buf oflow; bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.8 1997/08/04 10:34:48 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.8 1997/08/04 10:34:48 deraadt Exp $";
d137 1
a137 1
	char aux1[MAXHOSTNAMELEN], aux2[MAXHOSTNAMELEN, ans[MAXHOSTNAMELEN];
@


1.8
log
@init net_entry properly
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.7 1997/04/14 04:25:02 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.7 1997/04/14 04:25:02 deraadt Exp $";
d137 3
a139 2
	char aux1[30], aux2[30], ans[30], *in, *st, *pauxt, *bp, **ap,
		*paux1 = &aux1[0], *paux2 = &aux2[0], flag = 0;
d187 2
a188 1
		(void)strcpy(&ans[0], bp);
@


1.7
log
@buf oflow
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.6 1997/04/13 20:38:07 downsj Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.6 1997/04/13 20:38:07 downsj Exp $";
d253 1
a253 1
	struct netent *net_entry;
d336 1
a336 1
	struct netent *net_entry;
@


1.6
log
@copyright foo
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.5 1997/04/05 21:13:08 millert Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.5 1997/04/05 21:13:08 millert Exp $";
d355 2
a356 1
			strcpy(&qbuf[0], net);
@


1.5
log
@Use in_addr_t not u_long and use in_port_t in some cases instead
of u_short or u_int16_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.4 1997/04/03 08:33:06 downsj Exp $	*/
d3 31
d80 1
a80 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.4 1997/04/03 08:33:06 downsj Exp $";
@


1.4
log
@hokchar -> _hokchar, and make it non-static.  Use it in getnetnamadr.c as
well.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.3 1997/04/03 07:31:55 downsj Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.3 1997/04/03 07:31:55 downsj Exp $";
d69 1
a69 1
struct netent *_getnetbyaddr __P((long net, int type));
d214 1
a214 1
	register u_long net;
d221 1
a221 1
	unsigned long net2;
@


1.3
log
@Full implementation of lookups support, plus some bug fixes.  Still no YP.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.2 1997/04/03 02:15:16 kstailey Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.2 1997/04/03 02:15:16 kstailey Exp $";
d72 2
d147 1
d149 3
@


1.2
log
@a start a making getnetbyaddr() respect "lookup" keyword in resolv.conf
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.1 1997/03/13 19:07:27 downsj Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.1 1997/03/13 19:07:27 downsj Exp $";
d106 2
a107 2
static	struct netent net_entry;
static	char *net_aliases[MAXALIASES], netbuf[BUFSIZ+1];
d220 2
a221 2
	if (net_type != AF_INET)
		return (_getnetbyaddr(net, net_type));
d229 1
a229 1
#if 0 /* def YP */
d231 1
a231 3
			/* YP only supports AF_INET. */
			if (af == AF_INET)
				hp = _yp_gethtbyaddr(addr);
d233 34
d268 12
a279 1
		case 'b':
d282 3
a284 1
			return (_getnetbyaddr(net, net_type));
d288 2
a289 40
	for (nn = 4, net2 = net; net2; net2 >>= 8)
		netbr[--nn] = net2 & 0xff;
	switch (nn) {
	case 3: 	/* Class A */
		snprintf(qbuf, sizeof(qbuf), "0.0.0.%u.in-addr.arpa", netbr[3]);
		break;
	case 2: 	/* Class B */
		snprintf(qbuf, sizeof(qbuf), "0.0.%u.%u.in-addr.arpa",
		    netbr[3], netbr[2]);
		break;
	case 1: 	/* Class C */
		snprintf(qbuf, sizeof(qbuf), "0.%u.%u.%u.in-addr.arpa",
		    netbr[3], netbr[2], netbr[1]);
		break;
	case 0: 	/* Class D - E */
		snprintf(qbuf, sizeof(qbuf), "%u.%u.%u.%u.in-addr.arpa",
		    netbr[3], netbr[2], netbr[1], netbr[0]);
		break;
	}
	anslen = res_query(qbuf, C_IN, T_PTR, (u_char *)&buf, sizeof(buf));
	if (anslen < 0) {
#ifdef DEBUG
		if (_res.options & RES_DEBUG)
			printf("res_query failed\n");
#endif
		if (errno == ECONNREFUSED)
			return (_getnetbyaddr(net, net_type));
		return (NULL);
	}
	net_entry = getnetanswer(&buf, anslen, BYADDR);
	if (net_entry) {
		unsigned u_net = net;	/* maybe net should be unsigned ? */

		/* Strip trailing zeros */
		while ((u_net & 0xff) == 0 && u_net != 0)
			u_net >>= 8;
		net_entry->n_net = u_net;
		return (net_entry);
	}
	return (_getnetbyaddr(net, net_type));
d300 5
d306 16
a321 7
	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
		h_errno = NETDB_INTERNAL;
		return (NULL);
	}
	strcpy(&qbuf[0], net);
	anslen = res_search(qbuf, C_IN, T_PTR, (u_char *)&buf, sizeof(buf));
	if (anslen < 0) {
d323 2
a324 2
		if (_res.options & RES_DEBUG)
			printf("res_query failed\n");
d326 12
a337 3
		if (errno == ECONNREFUSED)
			return (_getnetbyname(net));
		return (_getnetbyname(net));
d339 3
a341 4
	net_entry = getnetanswer(&buf, anslen, BYNAME);
	if (net_entry)
		return (net_entry);
	return (_getnetbyname(net));
@


1.1
log
@Integrate BIND 4.9.5 resolver and associated routines.

Includes the DNS aware getnetby*() routines and IPv6 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetnamadr.c,v 1.1 1997/03/12 10:42:04 downsj Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: getnetnamadr.c,v 1.1 1997/03/12 10:42:04 downsj Exp $";
d217 2
d222 20
@
