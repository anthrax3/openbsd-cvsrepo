head	1.13;
access;
symbols
	OPENBSD_5_4:1.12.0.14
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.12
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.10
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.8
	OPENBSD_5_0:1.12.0.6
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.8
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.10
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.13
date	2013.11.12.20.37.15;	author eric;	state dead;
branches;
next	1.12;

1.12
date	2010.06.29.09.22.06;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.11.18.36.41;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.30.02.58.28;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.18.19.07.38;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.07.07.34.14;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.28.04.58.00;	author marc;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.07.20.54.04;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.16.18.16.43;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.07.10.16.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.06.15.00.48;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.06.14.40.47;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.13
log
@remove dead files

ok deraadt@@
@
text
@/* $OpenBSD: getrrsetbyname.c,v 1.12 2010/06/29 09:22:06 deraadt Exp $ */

/*
 * Copyright (c) 2001 Jakob Schlyter. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Portions Copyright (c) 1999-2001 Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <netdb.h>
#include <resolv.h>
#include <stdlib.h>
#include <string.h>

#include "thread_private.h"

#define MAXPACKET 1024*64

struct dns_query {
	char			*name;
	u_int16_t		type;
	u_int16_t		class;
	struct dns_query	*next;
};

struct dns_rr {
	char			*name;
	u_int16_t		type;
	u_int16_t		class;
	u_int16_t		ttl;
	u_int16_t		size;
	void			*rdata;
	struct dns_rr		*next;
};

struct dns_response {
	HEADER			header;
	struct dns_query	*query;
	struct dns_rr		*answer;
	struct dns_rr		*authority;
	struct dns_rr		*additional;
};

static struct dns_response *parse_dns_response(const u_char *, int);
static struct dns_query *parse_dns_qsection(const u_char *, int,
    const u_char **, int);
static struct dns_rr *parse_dns_rrsection(const u_char *, int, const u_char **,
    int);

static void free_dns_query(struct dns_query *);
static void free_dns_rr(struct dns_rr *);
static void free_dns_response(struct dns_response *);

static int count_dns_rr(struct dns_rr *, u_int16_t, u_int16_t);

int
getrrsetbyname(const char *hostname, unsigned int rdclass,
    unsigned int rdtype, unsigned int flags,
    struct rrsetinfo **res)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	int result;
	struct rrsetinfo *rrset = NULL;
	struct dns_response *response = NULL;
	struct dns_rr *rr;
	struct rdatainfo *rdata;
	int length;
	unsigned int index_ans, index_sig;
	union {
		HEADER hdr;
		u_char buf[MAXPACKET];
	} answer;

	/* check for invalid class and type */
	if (rdclass > 0xffff || rdtype > 0xffff) {
		result = ERRSET_INVAL;
		goto fail;
	}

	/* don't allow queries of class or type ANY */
	if (rdclass == 0xff || rdtype == 0xff) {
		result = ERRSET_INVAL;
		goto fail;
	}

	/* don't allow flags yet, unimplemented */
	if (flags) {
		result = ERRSET_INVAL;
		goto fail;
	}

	/* initialize resolver */
	if (_res_init(0) == -1) {
		result = ERRSET_FAIL;
		goto fail;
	}

#ifdef DEBUG
	_resp->options |= RES_DEBUG;
#endif /* DEBUG */

#ifdef RES_USE_DNSSEC
	/* turn on DNSSEC if EDNS0 is configured */
	if (_resp->options & RES_USE_EDNS0)
		_resp->options |= RES_USE_DNSSEC;
#endif /* RES_USE_DNSEC */

	/* make query */
	length = res_query(hostname, (signed int) rdclass, (signed int) rdtype,
	    answer.buf, sizeof(answer.buf));
	if (length < 0) {
		switch(h_errno) {
		case HOST_NOT_FOUND:
			result = ERRSET_NONAME;
			goto fail;
		case NO_DATA:
			result = ERRSET_NODATA;
			goto fail;
		default:
			result = ERRSET_FAIL;
			goto fail;
		}
	}

	/* parse result */
	response = parse_dns_response(answer.buf, length);
	if (response == NULL) {
		result = ERRSET_FAIL;
		goto fail;
	}

	if (response->header.qdcount != 1) {
		result = ERRSET_FAIL;
		goto fail;
	}

	/* initialize rrset */
	rrset = calloc(1, sizeof(struct rrsetinfo));
	if (rrset == NULL) {
		result = ERRSET_NOMEMORY;
		goto fail;
	}
	rrset->rri_rdclass = response->query->class;
	rrset->rri_rdtype = response->query->type;
	rrset->rri_ttl = response->answer->ttl;
	rrset->rri_nrdatas = response->header.ancount;

	/* check for authenticated data */
	if (response->header.ad == 1)
		rrset->rri_flags |= RRSET_VALIDATED;

	/* copy name from answer section */
	rrset->rri_name = strdup(response->answer->name);
	if (rrset->rri_name == NULL) {
		result = ERRSET_NOMEMORY;
		goto fail;
	}

	/* count answers */
	rrset->rri_nrdatas = count_dns_rr(response->answer, rrset->rri_rdclass,
	    rrset->rri_rdtype);
	rrset->rri_nsigs = count_dns_rr(response->answer, rrset->rri_rdclass,
	    T_RRSIG);

	/* allocate memory for answers */
	rrset->rri_rdatas = calloc(rrset->rri_nrdatas,
	    sizeof(struct rdatainfo));
	if (rrset->rri_rdatas == NULL) {
		result = ERRSET_NOMEMORY;
		goto fail;
	}

	/* allocate memory for signatures */
	rrset->rri_sigs = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo));
	if (rrset->rri_sigs == NULL) {
		result = ERRSET_NOMEMORY;
		goto fail;
	}

	/* copy answers & signatures */
	for (rr = response->answer, index_ans = 0, index_sig = 0;
	    rr; rr = rr->next) {

		rdata = NULL;

		if (rr->class == rrset->rri_rdclass &&
		    rr->type  == rrset->rri_rdtype)
			rdata = &rrset->rri_rdatas[index_ans++];

		if (rr->class == rrset->rri_rdclass &&
		    rr->type  == T_RRSIG)
			rdata = &rrset->rri_sigs[index_sig++];

		if (rdata) {
			rdata->rdi_length = rr->size;
			rdata->rdi_data   = malloc(rr->size);

			if (rdata->rdi_data == NULL) {
				result = ERRSET_NOMEMORY;
				goto fail;
			}
			memcpy(rdata->rdi_data, rr->rdata, rr->size);
		}
	}
	free_dns_response(response);

	*res = rrset;
	return (ERRSET_SUCCESS);

fail:
	if (rrset != NULL)
		freerrset(rrset);
	if (response != NULL)
		free_dns_response(response);
	return (result);
}

void
freerrset(struct rrsetinfo *rrset)
{
	u_int16_t i;

	if (rrset == NULL)
		return;

	if (rrset->rri_rdatas) {
		for (i = 0; i < rrset->rri_nrdatas; i++) {
			if (rrset->rri_rdatas[i].rdi_data == NULL)
				break;
			free(rrset->rri_rdatas[i].rdi_data);
		}
		free(rrset->rri_rdatas);
	}

	if (rrset->rri_sigs) {
		for (i = 0; i < rrset->rri_nsigs; i++) {
			if (rrset->rri_sigs[i].rdi_data == NULL)
				break;
			free(rrset->rri_sigs[i].rdi_data);
		}
		free(rrset->rri_sigs);
	}

	if (rrset->rri_name)
		free(rrset->rri_name);
	free(rrset);
}

/*
 * DNS response parsing routines
 */
static struct dns_response *
parse_dns_response(const u_char *answer, int size)
{
	struct dns_response *resp;
	const u_char *cp;

	/* allocate memory for the response */
	resp = calloc(1, sizeof(*resp));
	if (resp == NULL)
		return (NULL);

	/* initialize current pointer */
	cp = answer;

	/* copy header */
	memcpy(&resp->header, cp, HFIXEDSZ);
	cp += HFIXEDSZ;

	/* fix header byte order */
	resp->header.qdcount = ntohs(resp->header.qdcount);
	resp->header.ancount = ntohs(resp->header.ancount);
	resp->header.nscount = ntohs(resp->header.nscount);
	resp->header.arcount = ntohs(resp->header.arcount);

	/* there must be at least one query */
	if (resp->header.qdcount < 1) {
		free_dns_response(resp);
		return (NULL);
	}

	/* parse query section */
	resp->query = parse_dns_qsection(answer, size, &cp,
	    resp->header.qdcount);
	if (resp->header.qdcount && resp->query == NULL) {
		free_dns_response(resp);
		return (NULL);
	}

	/* parse answer section */
	resp->answer = parse_dns_rrsection(answer, size, &cp,
	    resp->header.ancount);
	if (resp->header.ancount && resp->answer == NULL) {
		free_dns_response(resp);
		return (NULL);
	}

	/* parse authority section */
	resp->authority = parse_dns_rrsection(answer, size, &cp,
	    resp->header.nscount);
	if (resp->header.nscount && resp->authority == NULL) {
		free_dns_response(resp);
		return (NULL);
	}

	/* parse additional section */
	resp->additional = parse_dns_rrsection(answer, size, &cp,
	    resp->header.arcount);
	if (resp->header.arcount && resp->additional == NULL) {
		free_dns_response(resp);
		return (NULL);
	}

	return (resp);
}

static struct dns_query *
parse_dns_qsection(const u_char *answer, int size, const u_char **cp, int count)
{
	struct dns_query *head, *curr, *prev;
	int i, length;
	char name[MAXDNAME];

	for (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {

		/* allocate and initialize struct */
		curr = calloc(1, sizeof(struct dns_query));
		if (curr == NULL) {
			free_dns_query(head);
			return (NULL);
		}
		if (head == NULL)
			head = curr;
		if (prev != NULL)
			prev->next = curr;

		/* name */
		length = dn_expand(answer, answer + size, *cp, name,
		    sizeof(name));
		if (length < 0) {
			free_dns_query(head);
			return (NULL);
		}
		curr->name = strdup(name);
		if (curr->name == NULL) {
			free_dns_query(head);
			return (NULL);
		}
		*cp += length;

		/* type */
		curr->type = _getshort(*cp);
		*cp += INT16SZ;

		/* class */
		curr->class = _getshort(*cp);
		*cp += INT16SZ;
	}

	return (head);
}

static struct dns_rr *
parse_dns_rrsection(const u_char *answer, int size, const u_char **cp,
    int count)
{
	struct dns_rr *head, *curr, *prev;
	int i, length;
	char name[MAXDNAME];

	for (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {

		/* allocate and initialize struct */
		curr = calloc(1, sizeof(struct dns_rr));
		if (curr == NULL) {
			free_dns_rr(head);
			return (NULL);
		}
		if (head == NULL)
			head = curr;
		if (prev != NULL)
			prev->next = curr;

		/* name */
		length = dn_expand(answer, answer + size, *cp, name,
		    sizeof(name));
		if (length < 0) {
			free_dns_rr(head);
			return (NULL);
		}
		curr->name = strdup(name);
		if (curr->name == NULL) {
			free_dns_rr(head);
			return (NULL);
		}
		*cp += length;

		/* type */
		curr->type = _getshort(*cp);
		*cp += INT16SZ;

		/* class */
		curr->class = _getshort(*cp);
		*cp += INT16SZ;

		/* ttl */
		curr->ttl = _getlong(*cp);
		*cp += INT32SZ;

		/* rdata size */
		curr->size = _getshort(*cp);
		*cp += INT16SZ;

		/* rdata itself */
		curr->rdata = malloc(curr->size);
		if (curr->rdata == NULL) {
			free_dns_rr(head);
			return (NULL);
		}
		memcpy(curr->rdata, *cp, curr->size);
		*cp += curr->size;
	}

	return (head);
}

static void
free_dns_query(struct dns_query *p)
{
	if (p == NULL)
		return;

	if (p->name)
		free(p->name);
	free_dns_query(p->next);
	free(p);
}

static void
free_dns_rr(struct dns_rr *p)
{
	if (p == NULL)
		return;

	if (p->name)
		free(p->name);
	if (p->rdata)
		free(p->rdata);
	free_dns_rr(p->next);
	free(p);
}

static void
free_dns_response(struct dns_response *p)
{
	if (p == NULL)
		return;

	free_dns_query(p->query);
	free_dns_rr(p->answer);
	free_dns_rr(p->authority);
	free_dns_rr(p->additional);
	free(p);
}

static int
count_dns_rr(struct dns_rr *p, u_int16_t class, u_int16_t type)
{
	int n = 0;

	while(p) {
		if (p->class == class && p->type == type)
			n++;
		p = p->next;
	}

	return (n);
}
@


1.12
log
@use a union to align the dns answer buffer until gcc4 is fixed
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.11 2007/10/11 18:36:41 jakob Exp $ */
@


1.11
log
@use RRSIG instead of SIG for DNSSEC. ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.10 2005/03/30 02:58:28 tedu Exp $ */
d56 1
a56 1
#define ANSWER_BUFFER_SIZE 1024*64
d108 4
a111 1
	u_char answer[ANSWER_BUFFER_SIZE];
d149 1
a149 1
	    answer, sizeof(answer));
d165 1
a165 1
	response = parse_dns_response(answer, length);
@


1.10
log
@make the resolver stat resolv.conf and update if it changes.
useful feedback and ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.9 2005/03/25 13:24:12 otto Exp $ */
d199 1
a199 1
	    T_SIG);
d227 1
a227 1
		    rr->type  == T_SIG)
@


1.9
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.8 2004/07/18 19:07:38 jakob Exp $ */
d129 1
a129 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1) {
@


1.8
log
@fix memory leak; ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.7 2003/03/07 07:34:14 itojun Exp $ */
d400 2
a401 1
parse_dns_rrsection(const u_char *answer, int size, const u_char **cp, int count)
@


1.7
log
@signed/unsigned mixup.  KAME PR 469 by Olivier Courtay.
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.6 2003/01/28 04:58:00 marc Exp $ */
d103 1
a103 1
	struct dns_response *response;
d189 1
a189 2
	length = strlen(response->answer->name);
	rrset->rri_name = malloc(length + 1);
a193 1
	strlcpy(rrset->rri_name, response->answer->name, length + 1);
d241 1
d249 2
@


1.6
log
@
thread safer libc (note: safer, not safe)
Access to the global _res structure replaced by pointers to a
per thread instance.  If unthreaded the pointer is to the
global structure.

Also replaced a 64k stack array with malloc-ed memory so
threaded aps (with a default 64k stack) have a chance at working.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.5 2002/09/07 20:54:04 jakob Exp $ */
d106 2
a107 1
	unsigned int length, index_ans, index_sig;
@


1.5
log
@ansi pedantic. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.4 2001/08/16 18:16:43 ho Exp $ */
d54 2
d100 1
d128 1
a128 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
d134 1
a134 1
	_res.options |= RES_DEBUG;
d139 2
a140 2
	if (_res.options & RES_USE_EDNS0)
		_res.options |= RES_USE_DNSSEC;
@


1.4
log
@Use calloc() to allocate response data. Be more careful when freeing
memory. jakob@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.3 2001/08/07 10:16:00 deraadt Exp $ */
d81 4
a84 4
static struct dns_response *parse_dns_response(const char *, int);
static struct dns_query *parse_dns_qsection(const char *, int, const char **,
    int);
static struct dns_rr *parse_dns_rrsection(const char *, int, const char **,
d104 1
a104 1
	char answer[ANSWER_BUFFER_SIZE];
d141 2
a142 1
	length = res_query(hostname, rdclass, rdtype, answer, sizeof(answer));
d284 1
a284 1
parse_dns_response(const char *answer, int size)
d287 1
a287 1
	const char *cp;
d349 1
a349 1
parse_dns_qsection(const char *answer, int size, const char **cp, int count)
d395 1
a395 1
parse_dns_rrsection(const char *answer, int size, const char **cp, int count)
@


1.3
log
@KNF; and i bonked jakob in the head for it too, with a plastic bottle of coke
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.2 2001/08/06 15:00:48 jakob Exp $ */
d256 7
a262 11
	for (i = 0; i < rrset->rri_nrdatas; i++) {
		if (rrset->rri_rdatas[i].rdi_data == NULL)
			break;
		free(rrset->rri_rdatas[i].rdi_data);
	}
	free(rrset->rri_rdatas);

	for (i = 0; i < rrset->rri_nsigs; i++) {
		if (rrset->rri_sigs[i].rdi_data == NULL)
			break;
		free(rrset->rri_sigs[i].rdi_data);
d264 12
a275 2
	free(rrset->rri_sigs);
	free(rrset->rri_name);
d289 1
a289 1
	resp = malloc(sizeof(*resp));
d462 2
a463 1
	free(p->name);
d474 4
a477 2
	free(p->name);
	free(p->rdata);
@


1.2
log
@OpenBSD id-tags
@
text
@d1 1
a1 1
/* $OpenBSD: getrrsetbyname.c,v 1.1 2001/08/06 14:40:47 jakob Exp $ */
a45 1

a55 1

d95 2
a96 2
	       unsigned int rdtype, unsigned int flags,
	       struct rrsetinfo **res)
d103 1
a103 1
	unsigned length, index_ans, index_sig;
d125 1
a125 1
        if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
d163 1
a163 1
	if (response->header.qdcount != 1 ) {
d217 1
a217 1
	  	rdata = NULL;
d230 1
a230 1
	    
d253 1
a253 1
	if (rrset == NULL) {
a254 1
	}
a268 1

a269 1

d273 1
a273 2

/* 
a275 1

d377 1
a377 1
 		*cp += INT16SZ;
d381 1
a381 1
 		*cp += INT16SZ;
d423 1
a423 1
 		*cp += INT16SZ;
d427 1
a427 1
 		*cp += INT16SZ;
d431 1
a431 1
 		*cp += INT32SZ;
a449 1

d495 1
a495 1
	};
@


1.1
log
@add getrrsetbyname(3) - API to retrieve arbitrary DNS records
@
text
@d1 1
a1 1
/* $Id: getrrsetbyname.c,v 1.27 2001/08/03 17:15:09 jakob Exp $ */
@

