head	1.22;
access;
symbols
	OPENBSD_5_4:1.21.0.22
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.20
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.18
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.16
	OPENBSD_5_0:1.21.0.14
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.12
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.10
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.6
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.19.0.12
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.10
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.8
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.10
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.8
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.6
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2013.11.12.20.37.16;	author eric;	state dead;
branches;
next	1.21;

1.21
date	2008.05.11.05.03.03;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.18.21.36.32;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.06.20.30.04;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.30.02.58.28;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.17.01.42.26;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.20.18.36;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.04.00.19.24;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.28.04.58.00;	author marc;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.06.18.35.12;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.14.23.49.29;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.22.07.31.18;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	98.03.19.00.30.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.06.04.03.18.41;	author dm;	state Exp;
branches;
next	1.6;

1.6
date	97.06.03.22.43.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.05.28.21.38.57;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.03.13.19.07.41;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.29.49;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.02.19.19.53.29;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@remove dead files

ok deraadt@@
@
text
@/*	$OpenBSD: res_send.c,v 1.21 2008/05/11 05:03:03 brad Exp $	*/

/*
 * ++Copyright++ 1985, 1989, 1993
 * -
 * Copyright (c) 1985, 1989, 1993
 *    The Regents of the University of California.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * --Copyright--
 */

#ifndef INET6
#define INET6
#endif

	/* change this to "0"
	 * if you talk to a lot
	 * of multi-homed SunOS
	 * ("broken") name servers.
	 */
#define	CHECK_SRVR_ADDR	1	/* XXX - should be in options.h */

/*
 * Send query to name server and wait for reply.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <arpa/inet.h>

#include <errno.h>
#include <netdb.h>
#include <poll.h>
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "thread_private.h"

static int s = -1;	/* socket used for communications */
static int connected = 0;	/* is the socket connected */
static int vc = 0;	/* is the socket a virtual ciruit? */
static int af = 0;		/* address family of socket */

#define CAN_RECONNECT 1

#ifndef DEBUG
#   define Dprint(cond, args) /*empty*/
#   define DprintQ(cond, args, query, size) /*empty*/
#   define Aerror(file, string, error, address) /*empty*/
#   define Perror(file, string, error) /*empty*/
#else
#   define Dprint(cond, args) if (cond) {fprintf args;} else {}
#   define DprintQ(cond, args, query, size) if (cond) {\
			fprintf args;\
			__fp_nquery(query, size, stdout);\
		} else {}
static char abuf[NI_MAXHOST];
static char pbuf[NI_MAXSERV];
static void Aerror(FILE *, char *, int, struct sockaddr *);
static void Perror(FILE *, char *, int);

    static void
    Aerror(FILE *file, char *string, int error, struct sockaddr *address)
    {
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	int save = errno;

	if (_resp->options & RES_DEBUG) {
		if (getnameinfo(address, address->sa_len, abuf, sizeof(abuf),
		    pbuf, sizeof(pbuf), NI_NUMERICHOST | NI_NUMERICSERV) != 0) {
			strlcpy(abuf, "?", sizeof(abuf));
			strlcpy(pbuf, "?", sizeof(pbuf));
		}
		fprintf(file, "res_send: %s ([%s].%s): %s\n",
			string, abuf, pbuf, strerror(error));
	}
	errno = save;
    }
    static void
    Perror(FILE *file, char *string, int error)
    {
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	int save = errno;

	if (_resp->options & RES_DEBUG) {
		fprintf(file, "res_send: %s: %s\n",
			string, strerror(error));
	}
	errno = save;
    }
#endif

static res_send_qhook Qhook = NULL;
static res_send_rhook Rhook = NULL;

void
res_send_setqhook(res_send_qhook hook)
{

	Qhook = hook;
}

void
res_send_setrhook(res_send_rhook hook)
{

	Rhook = hook;
}

#ifdef INET6
static struct sockaddr * get_nsaddr(size_t);

/*
 * pick appropriate nsaddr_list for use.  see res_init() for initialization.
 */
static struct sockaddr *
get_nsaddr(size_t n)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	struct __res_state_ext *_res_extp = _THREAD_PRIVATE(_res_ext, _res_ext,
							    &_res_ext);

	if (!_resp->nsaddr_list[n].sin_family) {
		/*
		 * - _res_extp->nsaddr_list[n] holds an address that is larger
		 *   than struct sockaddr, and
		 * - user code did not update _resp->nsaddr_list[n].
		 */
		return (struct sockaddr *)&_res_extp->nsaddr_list[n];
	} else {
		/*
		 * - user code updated _res.nsaddr_list[n], or
		 * - _resp->nsaddr_list[n] has the same content as
		 *   _res_extp->nsaddr_list[n].
		 */
		return (struct sockaddr *)&_resp->nsaddr_list[n];
	}
}
#else
#define get_nsaddr(n)	((struct sockaddr *)&_resp->nsaddr_list[(n)])
#endif

/* int
 * res_isourserver(ina)
 *	looks up "ina" in _resp->ns_addr_list[]
 * returns:
 *	0  : not found
 *	>0 : found
 * author:
 *	paul vixie, 29may94
 */
int
res_isourserver(const struct sockaddr_in *inp)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
#ifdef INET6
	const struct sockaddr_in6 *in6p = (const struct sockaddr_in6 *)inp;
	const struct sockaddr_in6 *srv6;
#endif
	const struct sockaddr_in *srv;
	int ns, ret;

	ret = 0;
	switch (inp->sin_family) {
#ifdef INET6
	case AF_INET6:
		for (ns = 0; ns < _resp->nscount; ns++) {
			srv6 = (struct sockaddr_in6 *)get_nsaddr(ns);
			if (srv6->sin6_family == in6p->sin6_family &&
			    srv6->sin6_port == in6p->sin6_port &&
			    srv6->sin6_scope_id == in6p->sin6_scope_id &&
			    (IN6_IS_ADDR_UNSPECIFIED(&srv6->sin6_addr) ||
			     IN6_ARE_ADDR_EQUAL(&srv6->sin6_addr,
			         &in6p->sin6_addr))) {
				ret++;
				break;
			}
		}
		break;
#endif
	case AF_INET:
		for (ns = 0; ns < _resp->nscount; ns++) {
			srv = (struct sockaddr_in *)get_nsaddr(ns);
			if (srv->sin_family == inp->sin_family &&
			    srv->sin_port == inp->sin_port &&
			    (srv->sin_addr.s_addr == INADDR_ANY ||
			     srv->sin_addr.s_addr == inp->sin_addr.s_addr)) {
				ret++;
				break;
			}
		}
		break;
	}
	return (ret);
}

/* int
 * res_nameinquery(name, type, class, buf, eom)
 *	look for (name,type,class) in the query section of packet (buf,eom)
 * returns:
 *	-1 : format error
 *	0  : not found
 *	>0 : found
 * author:
 *	paul vixie, 29may94
 */
int
res_nameinquery(const char *name, int type, int class, const u_char *buf,
    const u_char *eom)
{
	const u_char *cp = buf + HFIXEDSZ;
	int qdcount = ntohs(((HEADER*)buf)->qdcount);

	while (qdcount-- > 0) {
		char tname[MAXDNAME+1];
		int n, ttype, tclass;

		n = dn_expand(buf, eom, cp, tname, sizeof tname);
		if (n < 0)
			return (-1);
		cp += n;
		ttype = _getshort(cp); cp += INT16SZ;
		tclass = _getshort(cp); cp += INT16SZ;
		if (ttype == type &&
		    tclass == class &&
		    strcasecmp(tname, name) == 0)
			return (1);
	}
	return (0);
}

/* int
 * res_queriesmatch(buf1, eom1, buf2, eom2)
 *	is there a 1:1 mapping of (name,type,class)
 *	in (buf1,eom1) and (buf2,eom2)?
 * returns:
 *	-1 : format error
 *	0  : not a 1:1 mapping
 *	>0 : is a 1:1 mapping
 * author:
 *	paul vixie, 29may94
 */
int
res_queriesmatch(const u_char *buf1, const u_char *eom1, const u_char *buf2,
    const u_char *eom2)
{
	const u_char *cp = buf1 + HFIXEDSZ;
	int qdcount = ntohs(((HEADER*)buf1)->qdcount);

	if (qdcount != ntohs(((HEADER*)buf2)->qdcount))
		return (0);
	while (qdcount-- > 0) {
		char tname[MAXDNAME+1];
		int n, ttype, tclass;

		n = dn_expand(buf1, eom1, cp, tname, sizeof tname);
		if (n < 0)
			return (-1);
		cp += n;
		ttype = _getshort(cp);	cp += INT16SZ;
		tclass = _getshort(cp); cp += INT16SZ;
		if (!res_nameinquery(tname, ttype, tclass, buf2, eom2))
			return (0);
	}
	return (1);
}

int
res_send(const u_char *buf, int buflen, u_char *ans, int anssiz)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	HEADER *hp = (HEADER *) buf;
	HEADER *anhp = (HEADER *) ans;
	int gotsomewhere, connreset, terrno, try, v_circuit, resplen, ns;
	int n;
	u_int badns;	/* XXX NSMAX can't exceed #/bits in this var */

	if (_res_init(0) == -1) {
		/* errno should have been set by res_init() in this case. */
		return (-1);
	}
	DprintQ((_resp->options & RES_DEBUG) || (_resp->pfcode & RES_PRF_QUERY),
		(stdout, ";; res_send()\n"), buf, buflen);
	v_circuit = (_resp->options & RES_USEVC) || buflen > PACKETSZ;
	gotsomewhere = 0;
	connreset = 0;
	terrno = ETIMEDOUT;
	badns = 0;

	/*
	 * Send request, RETRY times, or until successful
	 */
	for (try = 0; try < _resp->retry; try++) {
	    for (ns = 0; ns < _resp->nscount; ns++) {
		struct sockaddr *nsap = get_nsaddr(ns);
		socklen_t salen;

		if (nsap->sa_len)
			salen = nsap->sa_len;
#ifdef INET6
		else if (nsap->sa_family == AF_INET6)
			salen = sizeof(struct sockaddr_in6);
#endif
		else if (nsap->sa_family == AF_INET)
			salen = sizeof(struct sockaddr_in);
		else
			salen = 0;	/*unknown, die on connect*/

    same_ns:
		if (badns & (1 << ns)) {
			res_close();
			goto next_ns;
		}

		if (Qhook) {
			int done = 0, loops = 0;

			do {
				res_sendhookact act;

				act = (*Qhook)((struct sockaddr_in **)&nsap,
					       &buf, &buflen,
					       ans, anssiz, &resplen);
				switch (act) {
				case res_goahead:
					done = 1;
					break;
				case res_nextns:
					res_close();
					goto next_ns;
				case res_done:
					return (resplen);
				case res_modified:
					/* give the hook another try */
					if (++loops < 42) /*doug adams*/
						break;
					/*FALLTHROUGH*/
				case res_error:
					/*FALLTHROUGH*/
				default:
					return (-1);
				}
			} while (!done);
		}

		Dprint((_resp->options & RES_DEBUG) &&
		       getnameinfo(nsap, salen, abuf, sizeof(abuf),
			   NULL, 0, NI_NUMERICHOST) == 0,
		       (stdout, ";; Querying server (# %d) address = %s\n",
			ns + 1, abuf));

		if (v_circuit) {
			int truncated;
			struct iovec iov[2];
			u_short len;
			u_char *cp;

			/*
			 * Use virtual circuit;
			 * at most one attempt per server.
			 */
			try = _resp->retry;
			truncated = 0;
			if ((s < 0) || (!vc) || (af != nsap->sa_family)) {
				if (s >= 0)
					res_close();

				af = nsap->sa_family;
				s = socket(af, SOCK_STREAM, 0);
				if (s < 0) {
					terrno = errno;
					Perror(stderr, "socket(vc)", errno);
#if 0
					return (-1);
#else
					badns |= (1 << ns);
					res_close();
					goto next_ns;
#endif
				}
				errno = 0;
				if (connect(s, nsap, salen) < 0) {
					terrno = errno;
					Aerror(stderr, "connect/vc",
					       errno, nsap);
					badns |= (1 << ns);
					res_close();
					goto next_ns;
				}
				vc = 1;
			}
			/*
			 * Send length & message
			 */
			putshort((u_short)buflen, (u_char*)&len);
			iov[0].iov_base = (caddr_t)&len;
			iov[0].iov_len = INT16SZ;
			iov[1].iov_base = (caddr_t)buf;
			iov[1].iov_len = buflen;
			if (writev(s, iov, 2) != (INT16SZ + buflen)) {
				terrno = errno;
				Perror(stderr, "write failed", errno);
				badns |= (1 << ns);
				res_close();
				goto next_ns;
			}
			/*
			 * Receive length & response
			 */
 read_len:
			cp = ans;
			len = INT16SZ;
			while ((n = read(s, (char *)cp, (int)len)) > 0) {
				cp += n;
				if ((len -= n) <= 0)
					break;
			}
			if (n <= 0) {
				terrno = errno;
				Perror(stderr, "read failed", errno);
				res_close();
				/*
				 * A long running process might get its TCP
				 * connection reset if the remote server was
				 * restarted.  Requery the server instead of
				 * trying a new one.  When there is only one
				 * server, this means that a query might work
				 * instead of failing.  We only allow one reset
				 * per query to prevent looping.
				 */
				if (terrno == ECONNRESET && !connreset) {
					connreset = 1;
					res_close();
					goto same_ns;
				}
				res_close();
				goto next_ns;
			}
			resplen = _getshort(ans);
			if (resplen > anssiz) {
				Dprint(_resp->options & RES_DEBUG,
				       (stdout, ";; response truncated\n")
				       );
				truncated = 1;
				len = anssiz;
			} else
				len = resplen;
			cp = ans;
			while (len != 0 &&
			       (n = read(s, (char *)cp, (int)len)) > 0) {
				cp += n;
				len -= n;
			}
			if (n <= 0) {
				terrno = errno;
				Perror(stderr, "read(vc)", errno);
				res_close();
				goto next_ns;
			}
			if (truncated) {
				/*
				 * Flush rest of answer
				 * so connection stays in synch.
				 */
				anhp->tc = 1;
				len = resplen - anssiz;
				while (len != 0) {
					char junk[PACKETSZ];

					n = (len > sizeof(junk)
					     ? sizeof(junk)
					     : len);
					if ((n = read(s, junk, n)) > 0)
						len -= n;
					else
						break;
				}
			}
			/*
			 * The calling applicating has bailed out of
			 * a previous call and failed to arrange to have
			 * the circuit closed or the server has got
			 * itself confused. Anyway drop the packet and
			 * wait for the correct one.
			 */
			if (hp->id != anhp->id) {
				DprintQ((_resp->options & RES_DEBUG) ||
					(_resp->pfcode & RES_PRF_REPLY),
					(stdout, ";; old answer (unexpected):\n"),
					ans, (resplen>anssiz)?anssiz:resplen);
				goto read_len;
			}
		} else {
			/*
			 * Use datagrams.
			 */
			struct pollfd pfd;
			int timeout;
			struct sockaddr_storage from;
			socklen_t fromlen;

			if ((s < 0) || vc || (af != nsap->sa_family)) {
				if (vc)
					res_close();
				af = nsap->sa_family;
				s = socket(af, SOCK_DGRAM, 0);
				if (s < 0) {
#if !CAN_RECONNECT
 bad_dg_sock:
#endif
					terrno = errno;
					Perror(stderr, "socket(dg)", errno);
#if 0
					return (-1);
#else
					badns |= (1 << ns);
					res_close();
					goto next_ns;
#endif
				}
#ifdef IPV6_MINMTU
				if (af == AF_INET6) {
					const int yes = 1;
					(void)setsockopt(s, IPPROTO_IPV6,
					    IPV6_USE_MIN_MTU, &yes,
					    sizeof(yes));
				}
#endif
				connected = 0;
			}
			/*
			 * On a 4.3BSD+ machine (client and server,
			 * actually), sending to a nameserver datagram
			 * port with no nameserver will cause an
			 * ICMP port unreachable message to be returned.
			 * If our datagram socket is "connected" to the
			 * server, we get an ECONNREFUSED error on the next
			 * socket operation, and poll returns if the
			 * error message is received.  We can thus detect
			 * the absence of a nameserver without timing out.
			 * If we have sent queries to at least two servers,
			 * however, we don't want to remain connected,
			 * as we wish to receive answers from the first
			 * server to respond.
			 */
			if (!(_resp->options & RES_INSECURE1) &&
			    (_resp->nscount == 1 || (try == 0 && ns == 0))) {
				/*
				 * Connect only if we are sure we won't
				 * receive a response from another server.
				 */
				if (!connected) {
					if (connect(s, nsap, salen) < 0) {
						Aerror(stderr,
						       "connect(dg)",
						       errno, nsap);
						badns |= (1 << ns);
						res_close();
						goto next_ns;
					}
					connected = 1;
				}
				if (send(s, (char*)buf, buflen, 0) != buflen) {
					Perror(stderr, "send", errno);
					badns |= (1 << ns);
					res_close();
					goto next_ns;
				}
			} else {
				/*
				 * Disconnect if we want to listen
				 * for responses from more than one server.
				 */
				if (connected) {
#if CAN_RECONNECT
#ifdef INET6
					/* XXX: any errornous address */
#endif /* INET6 */
					struct sockaddr_in no_addr;

					no_addr.sin_family = AF_INET;
					no_addr.sin_addr.s_addr = INADDR_ANY;
					no_addr.sin_port = 0;
					(void) connect(s,
						       (struct sockaddr *)
						        &no_addr,
						       sizeof(no_addr));
#else
					int s1 = socket(af, SOCK_DGRAM,0);
					if (s1 < 0)
						goto bad_dg_sock;
					(void) dup2(s1, s);
					(void) close(s1);
					Dprint(_resp->options & RES_DEBUG,
					       (stdout, ";; new DG socket\n"))
#endif
#ifdef IPV6_MINMTU
					if (af == AF_INET6) {
						const int yes = 1;
						(void)setsockopt(s, IPPROTO_IPV6,
						    IPV6_USE_MIN_MTU, &yes,
						    sizeof(yes));
					}
#endif
					connected = 0;
					errno = 0;
				}
				if (sendto(s, (char*)buf, buflen, 0,
					   nsap, salen) != buflen) {
					Aerror(stderr, "sendto", errno, nsap);
					badns |= (1 << ns);
					res_close();
					goto next_ns;
				}
			}

			/*
			 * Wait for reply
			 */
			timeout = 1000 * (_resp->retrans << try);
			if (try > 0)
				timeout /= _resp->nscount;
			if (timeout < 1000)
				timeout = 1000;
    wait:
			pfd.fd = s;
			pfd.events = POLLIN;
			n = poll(&pfd, 1, timeout);
			if (n < 0) {
				if (errno == EINTR)
					goto wait;
				Perror(stderr, "poll", errno);
				res_close();
				goto next_ns;
			}
			if (n == 0) {
				/*
				 * timeout
				 */
				Dprint(_resp->options & RES_DEBUG,
				       (stdout, ";; timeout\n"));
				gotsomewhere = 1;
				res_close();
				goto next_ns;
			}
			errno = 0;
			fromlen = sizeof(from);
			resplen = recvfrom(s, (char*)ans, anssiz, 0,
					   (struct sockaddr *)&from, &fromlen);
			if (resplen <= 0) {
				Perror(stderr, "recvfrom", errno);
				res_close();
				goto next_ns;
			}
			gotsomewhere = 1;
			if (hp->id != anhp->id) {
				/*
				 * response from old query, ignore it.
				 * XXX - potential security hazard could
				 *	 be detected here.
				 */
				DprintQ((_resp->options & RES_DEBUG) ||
					(_resp->pfcode & RES_PRF_REPLY),
					(stdout, ";; old answer:\n"),
					ans, (resplen>anssiz)?anssiz:resplen);
				goto wait;
			}
#if CHECK_SRVR_ADDR
			if (!(_resp->options & RES_INSECURE1) &&
			    !res_isourserver((struct sockaddr_in *)&from)) {
				/*
				 * response from wrong server? ignore it.
				 * XXX - potential security hazard could
				 *	 be detected here.
				 */
				DprintQ((_resp->options & RES_DEBUG) ||
					(_resp->pfcode & RES_PRF_REPLY),
					(stdout, ";; not our server:\n"),
					ans, (resplen>anssiz)?anssiz:resplen);
				goto wait;
			}
#endif
			if (!(_resp->options & RES_INSECURE2) &&
			    !res_queriesmatch(buf, buf + buflen,
					      ans, ans + anssiz)) {
				/*
				 * response contains wrong query? ignore it.
				 * XXX - potential security hazard could
				 *	 be detected here.
				 */
				DprintQ((_resp->options & RES_DEBUG) ||
					(_resp->pfcode & RES_PRF_REPLY),
					(stdout, ";; wrong query name:\n"),
					ans, (resplen>anssiz)?anssiz:resplen);
				goto wait;
			}
			if (anhp->rcode == SERVFAIL ||
			    anhp->rcode == NOTIMP ||
			    anhp->rcode == REFUSED) {
				DprintQ(_resp->options & RES_DEBUG,
					(stdout, "server rejected query:\n"),
					ans, (resplen>anssiz)?anssiz:resplen);
				badns |= (1 << ns);
				res_close();
				/* don't retry if called from dig */
				if (!_resp->pfcode)
					goto next_ns;
			}
			if (!(_resp->options & RES_IGNTC) && anhp->tc) {
				/*
				 * get rest of answer;
				 * use TCP with same server.
				 */
				Dprint(_resp->options & RES_DEBUG,
				       (stdout, ";; truncated answer\n"));
				v_circuit = 1;
				res_close();
				goto same_ns;
			}
		} /*if vc/dg*/
		Dprint((_resp->options & RES_DEBUG) ||
		       ((_resp->pfcode & RES_PRF_REPLY) &&
			(_resp->pfcode & RES_PRF_HEAD1)),
		       (stdout, ";; got answer:\n"));
		DprintQ((_resp->options & RES_DEBUG) ||
			(_resp->pfcode & RES_PRF_REPLY),
			(stdout, "%s", ""),
			ans, (resplen>anssiz)?anssiz:resplen);
		/*
		 * If using virtual circuits, we assume that the first server
		 * is preferred over the rest (i.e. it is on the local
		 * machine) and only keep that one open.
		 * If we have temporarily opened a virtual circuit,
		 * or if we haven't been asked to keep a socket open,
		 * close the socket.
		 */
		if ((v_circuit && (!(_resp->options & RES_USEVC) || ns != 0)) ||
		    !(_resp->options & RES_STAYOPEN)) {
			res_close();
		}
		if (Rhook) {
			int done = 0, loops = 0;

			do {
				res_sendhookact act;

				act = (*Rhook)((struct sockaddr_in *)nsap,
					       buf, buflen,
					       ans, anssiz, &resplen);
				switch (act) {
				case res_goahead:
				case res_done:
					done = 1;
					break;
				case res_nextns:
					res_close();
					goto next_ns;
				case res_modified:
					/* give the hook another try */
					if (++loops < 42) /*doug adams*/
						break;
					/*FALLTHROUGH*/
				case res_error:
					/*FALLTHROUGH*/
				default:
					return (-1);
				}
			} while (!done);

		}
		return (resplen);
    next_ns: ;
	   } /*foreach ns*/
	} /*foreach retry*/
	res_close();
	if (!v_circuit) {
		if (!gotsomewhere)
			errno = ECONNREFUSED;	/* no nameservers found */
		else
			errno = ETIMEDOUT;	/* no answer obtained */
	} else
		errno = terrno;
	return (-1);
}

/*
 * This routine is for closing the socket if a virtual circuit is used and
 * the program wants to close it.  This provides support for endhostent()
 * which expects to close the socket.
 *
 * This routine is not expected to be user visible.
 */
void
res_close(void)
{
	if (s >= 0) {
		(void) close(s);
		s = -1;
		connected = 0;
		vc = 0;
		af = 0;
	}
}
@


1.21
log
@garbage collect the portability bits for the removed select() support.

ok djm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.20 2008/04/18 21:36:32 djm Exp $	*/
@


1.20
log
@convert select() => poll(), saves a runtime malloc+free per retry
feedback deraadt@@ drahn@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.19 2005/08/06 20:30:04 espie Exp $	*/
a92 10

#ifndef FD_SET
/* XXX - should be in portability.h */
#define	NFDBITS		32
#define	FD_SETSIZE	32
#define	FD_SET(n, p)	((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
#define	FD_CLR(n, p)	((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
#define	FD_ISSET(n, p)	((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
#define FD_ZERO(p)	bzero((char *)(p), sizeof(*(p)))
#endif
@


1.19
log
@zap rcsid.
split functions off res_debug.c so that getnetnamadr.c does not pull it
all when it's used.

okay deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.18 2005/03/30 02:58:28 tedu Exp $	*/
d78 1
a78 1
#include <stdio.h>
d80 1
a80 1
#include <errno.h>
d82 1
d470 1
a470 1
read_len:
d557 2
a558 2
			struct timeval timeout;
			fd_set *dsmaskp;
d598 1
a598 1
			 * socket operation, and select returns if the
d680 1
a680 1
			timeout.tv_sec = (_resp->retrans << try);
d682 3
a684 4
				timeout.tv_sec /= _resp->nscount;
			if ((long) timeout.tv_sec <= 0)
				timeout.tv_sec = 1;
			timeout.tv_usec = 0;
d686 3
a688 10
			dsmaskp = (fd_set *)calloc(howmany(s+1, NFDBITS),
						   sizeof(fd_mask));
			if (dsmaskp == NULL) {
				res_close();
				goto next_ns;
			}
			FD_SET(s, dsmaskp);
			n = select(s+1, dsmaskp, (fd_set *)NULL,
				   (fd_set *)NULL, &timeout);
			free(dsmaskp);
d692 1
a692 1
				Perror(stderr, "select", errno);
@


1.18
log
@make the resolver stat resolv.conf and update if it changes.
useful feedback and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.17 2005/03/25 13:24:12 otto Exp $	*/
a56 9

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)res_send.c	8.1 (Berkeley) 6/4/93";
static char rcsid[] = "$From: res_send.c,v 8.12 1996/10/08 04:51:06 vixie Exp $";
#else
static char rcsid[] = "$OpenBSD: res_send.c,v 1.17 2005/03/25 13:24:12 otto Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.17
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.16 2004/11/17 01:42:26 itojun Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.16 2004/11/17 01:42:26 itojun Exp $";
d346 1
a346 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1) {
@


1.16
log
@remove NI_WITHSCOPEID (which is not standard)
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.15 2003/06/02 20:18:36 millert Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.15 2003/06/02 20:18:36 millert Exp $";
d131 1
a131 5
    Aerror(file, string, error, address)
	FILE *file;
	char *string;
	int error;
	struct sockaddr *address;
d148 1
a148 4
    Perror(file, string, error)
	FILE *file;
	char *string;
	int error;
d165 1
a165 2
res_send_setqhook(hook)
	res_send_qhook hook;
d172 1
a172 2
res_send_setrhook(hook)
	res_send_rhook hook;
d185 1
a185 2
get_nsaddr(n)
	size_t n;
d221 1
a221 2
res_isourserver(inp)
	const struct sockaddr_in *inp;
d276 2
a277 4
res_nameinquery(name, type, class, buf, eom)
	const char *name;
	register int type, class;
	const u_char *buf, *eom;
d279 1
a279 1
	register const u_char *cp = buf + HFIXEDSZ;
d284 1
a284 1
		register int n, ttype, tclass;
d312 2
a313 3
res_queriesmatch(buf1, eom1, buf2, eom2)
	const u_char *buf1, *eom1;
	const u_char *buf2, *eom2;
d315 1
a315 1
	register const u_char *cp = buf1 + HFIXEDSZ;
d322 1
a322 1
		register int n, ttype, tclass;
d337 1
a337 5
res_send(buf, buflen, ans, anssiz)
	const u_char *buf;
	int buflen;
	u_char *ans;
	int anssiz;
d343 1
a343 1
	register int n;
d870 1
a870 1
res_close()
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.14 2003/03/04 00:19:24 itojun Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.14 2003/03/04 00:19:24 itojun Exp $";
d142 1
a142 2
		    pbuf, sizeof(pbuf),
		    NI_NUMERICHOST|NI_NUMERICSERV|NI_WITHSCOPEID) != 0) {
d434 1
a434 1
			   NULL, 0, NI_NUMERICHOST | NI_WITHSCOPEID) == 0,
@


1.14
log
@s/strncpy/strlcpy/
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.13 2003/01/28 04:58:00 marc Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.13 2003/01/28 04:58:00 marc Exp $";
@


1.13
log
@
thread safer libc (note: safer, not safe)
Access to the global _res structure replaced by pointers to a
per thread instance.  If unthreaded the pointer is to the
global structure.

Also replaced a 64k stack array with malloc-ed memory so
threaded aps (with a default 64k stack) have a chance at working.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.12 2002/09/06 18:35:12 deraadt Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.12 2002/09/06 18:35:12 deraadt Exp $";
d148 2
a149 2
			strncpy(abuf, "?", sizeof(abuf));
			strncpy(pbuf, "?", sizeof(pbuf));
@


1.12
log
@use socklen_t where needed; henning pvalchev ok
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.11 2002/02/16 21:27:23 millert Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.11 2002/02/16 21:27:23 millert Exp $";
d99 2
d141 1
d144 1
a144 1
	if (_res.options & RES_DEBUG) {
d162 1
d165 1
a165 1
	if (_res.options & RES_DEBUG) {
d202 3
d206 1
a206 1
	if (!_res.nsaddr_list[n].sin_family) {
d208 1
a208 1
		 * - _res_ext.nsaddr_list[n] holds an address that is larger
d210 1
a210 1
		 * - user code did not update _res.nsaddr_list[n].
d212 1
a212 1
		return (struct sockaddr *)&_res_ext.nsaddr_list[n];
d216 2
a217 2
		 * - _res.nsaddr_list[n] has the same content as
		 *   _res_ext.nsaddr_list[n].
d219 1
a219 1
		return (struct sockaddr *)&_res.nsaddr_list[n];
d223 1
a223 1
#define get_nsaddr(n)	((struct sockaddr *)&_res.nsaddr_list[(n)])
d228 1
a228 1
 *	looks up "ina" in _res.ns_addr_list[]
d239 1
d251 1
a251 1
		for (ns = 0; ns < _res.nscount; ns++) {
d266 1
a266 1
		for (ns = 0; ns < _res.nscount; ns++) {
d362 1
d369 1
a369 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
d373 1
a373 1
	DprintQ((_res.options & RES_DEBUG) || (_res.pfcode & RES_PRF_QUERY),
d375 1
a375 1
	v_circuit = (_res.options & RES_USEVC) || buflen > PACKETSZ;
d384 2
a385 2
	for (try = 0; try < _res.retry; try++) {
	    for (ns = 0; ns < _res.nscount; ns++) {
d437 1
a437 1
		Dprint((_res.options & RES_DEBUG) &&
d453 1
a453 1
			try = _res.retry;
d532 1
a532 1
				Dprint(_res.options & RES_DEBUG,
d578 2
a579 2
				DprintQ((_res.options & RES_DEBUG) ||
					(_res.pfcode & RES_PRF_REPLY),
d637 2
a638 2
			if (!(_res.options & RES_INSECURE1) &&
			    (_res.nscount == 1 || (try == 0 && ns == 0))) {
d685 1
a685 1
					Dprint(_res.options & RES_DEBUG,
d711 1
a711 1
			timeout.tv_sec = (_res.retrans << try);
d713 1
a713 1
				timeout.tv_sec /= _res.nscount;
d739 1
a739 1
				Dprint(_res.options & RES_DEBUG,
d761 2
a762 2
				DprintQ((_res.options & RES_DEBUG) ||
					(_res.pfcode & RES_PRF_REPLY),
d768 1
a768 1
			if (!(_res.options & RES_INSECURE1) &&
d775 2
a776 2
				DprintQ((_res.options & RES_DEBUG) ||
					(_res.pfcode & RES_PRF_REPLY),
d782 1
a782 1
			if (!(_res.options & RES_INSECURE2) &&
d790 2
a791 2
				DprintQ((_res.options & RES_DEBUG) ||
					(_res.pfcode & RES_PRF_REPLY),
d799 1
a799 1
				DprintQ(_res.options & RES_DEBUG,
d805 1
a805 1
				if (!_res.pfcode)
d808 1
a808 1
			if (!(_res.options & RES_IGNTC) && anhp->tc) {
d813 1
a813 1
				Dprint(_res.options & RES_DEBUG,
d820 3
a822 3
		Dprint((_res.options & RES_DEBUG) ||
		       ((_res.pfcode & RES_PRF_REPLY) &&
			(_res.pfcode & RES_PRF_HEAD1)),
d824 2
a825 2
		DprintQ((_res.options & RES_DEBUG) ||
			(_res.pfcode & RES_PRF_REPLY),
d836 2
a837 2
		if ((v_circuit && (!(_res.options & RES_USEVC) || ns != 0)) ||
		    !(_res.options & RES_STAYOPEN)) {
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.10 2001/09/14 23:49:29 itojun Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.10 2001/09/14 23:49:29 itojun Exp $";
d582 1
a582 1
			int fromlen;
@


1.10
log
@add "options insecure[12]" support for /etc/resolv.conf.
insecure1 is necessary for IPv6 dynamic DNS server discovery,
draft-ietf-ipngwg-dns-discovery-02.txt.  sync with kame.
ok'ed by angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.9 2000/06/22 07:31:18 itojun Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.9 2000/06/22 07:31:18 itojun Exp $";
d129 2
a130 2
static void Aerror __P((FILE *, char *, int, struct sockaddr *));
static void Perror __P((FILE *, char *, int));
d189 1
a189 1
static struct sockaddr * get_nsaddr __P((size_t));
@


1.9
log
@ipv6 support in resolver.  "nameserver" line in /etc/resolv.conf now takes
ipv6 address.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.8 1998/03/19 00:30:08 millert Exp $	*/
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.8 1998/03/19 00:30:08 millert Exp $";
d628 2
a629 1
			if (_res.nscount == 1 || (try == 0 && ns == 0)) {
@


1.8
log
@some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.7 1997/06/04 03:18:41 dm Exp $	*/
d58 4
d67 1
a67 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.7 1997/06/04 03:18:41 dm Exp $";
d102 1
d127 5
d137 1
a137 1
	struct sockaddr_in address;
d142 8
a149 5
		fprintf(file, "res_send: %s ([%s].%u): %s\n",
			string,
			inet_ntoa(address.sin_addr),
			ntohs(address.sin_port),
			strerror(error));
d188 31
d232 6
a237 2
	struct sockaddr_in ina;
	register int ns, ret;
a238 1
	ina = *inp;
d240 27
a266 9
	for (ns = 0;  ns < _res.nscount;  ns++) {
		register const struct sockaddr_in *srv = &_res.nsaddr_list[ns];

		if (srv->sin_family == ina.sin_family &&
		    srv->sin_port == ina.sin_port &&
		    (srv->sin_addr.s_addr == INADDR_ANY ||
		     srv->sin_addr.s_addr == ina.sin_addr.s_addr)) {
			ret++;
			break;
d268 1
d377 14
a390 1
		struct sockaddr_in *nsap = &_res.nsaddr_list[ns];
d403 2
a404 1
				act = (*Qhook)(&nsap, &buf, &buflen,
d428 3
a430 1
		Dprint(_res.options & RES_DEBUG,
d432 1
a432 1
			ns + 1, inet_ntoa(nsap->sin_addr)));
d446 1
a446 1
			if ((s < 0) || (!vc)) {
d450 2
a451 1
				s = socket(PF_INET, SOCK_STREAM, 0);
d455 1
d457 5
d464 1
a464 2
				if (connect(s, (struct sockaddr *)nsap,
					    sizeof(struct sockaddr)) < 0) {
d467 1
a467 1
					       errno, *nsap);
d581 1
a581 1
			struct sockaddr_in from;
d584 1
a584 1
			if ((s < 0) || vc) {
d587 2
a588 1
				s = socket(PF_INET, SOCK_DGRAM, 0);
d595 1
d597 12
d610 1
d634 1
a634 3
					if (connect(s, (struct sockaddr *)nsap,
						    sizeof(struct sockaddr)
						    ) < 0) {
d637 1
a637 1
						       errno, *nsap);
d657 3
d670 1
a670 1
					int s1 = socket(PF_INET, SOCK_DGRAM,0);
d678 8
d690 2
a691 4
					   (struct sockaddr *)nsap,
					   sizeof(struct sockaddr))
				    != buflen) {
					Aerror(stderr, "sendto", errno, *nsap);
d736 1
a736 1
			fromlen = sizeof(struct sockaddr_in);
d759 1
a759 1
			    !res_isourserver(&from)) {
d816 1
a816 1
			(stdout, ""),
d836 2
a837 1
				act = (*Rhook)(nsap, buf, buflen,
d890 1
@


1.7
log
@use bzero instead of FD_ZERO
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.6 1997/06/03 22:43:43 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.6 1997/06/03 22:43:43 deraadt Exp $";
d754 1
a754 1
	if (!v_circuit)
d759 1
a759 1
	else
@


1.6
log
@howmany(x+1, NFDBITS)
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.5 1997/05/28 21:38:57 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.5 1997/05/28 21:38:57 deraadt Exp $";
d598 2
a599 2
			dsmaskp = (fd_set *)malloc(howmany(s+1, NFDBITS) *
				sizeof(fd_mask));
a603 1
			FD_ZERO(dsmaskp);
@


1.5
log
@malloc fd_set dynamically, for very large fd uses
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.4 1997/03/13 19:07:41 downsj Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.4 1997/03/13 19:07:41 downsj Exp $";
d598 1
a598 1
			dsmaskp = (fd_set *)malloc(howmany(s, NFDBITS) *
@


1.4
log
@Integrate BIND 4.9.5 resolver and associated routines.

Includes the DNS aware getnetby*() routines and IPv6 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send.c,v 1.1 1997/03/12 10:42:11 downsj Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.1 1997/03/12 10:42:11 downsj Exp $";
d492 1
a492 1
			fd_set dsmask;
d598 9
a606 3
			FD_ZERO(&dsmask);
			FD_SET(s, &dsmask);
			n = select(s+1, &dsmask, (fd_set *)NULL,
d608 1
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 5
a5 1
/*-
d59 6
a64 1
static char rcsid[] = "$OpenBSD: res_send.c,v 1.5 1996/02/02 15:22:36 mrg Exp $";
d78 1
d91 3
a93 13
#if defined(BSD) && (BSD >= 199306)
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
#else
# include "../conf/portability.h"
#endif

#if defined(USE_OPTIONS_H)
# include <../conf/options.h>
#endif

void _res_close __P((void));
d99 10
d314 1
a314 1
			_res_close();
d331 1
a331 1
					_res_close();
d366 1
a366 1
					_res_close();
d381 1
a381 1
					_res_close();
d398 1
a398 1
				_res_close();
d404 1
d415 1
a415 1
				_res_close();
d427 1
a427 1
					_res_close();
d430 1
a430 1
				_res_close();
d451 1
a451 1
				_res_close();
d473 14
d498 1
a498 1
					_res_close();
d538 1
a538 1
						_res_close();
d546 1
a546 1
					_res_close();
d583 1
a583 1
					_res_close();
d603 2
d606 1
a606 1
				_res_close();
d616 1
a616 1
				_res_close();
d625 1
a625 1
				_res_close();
d638 1
a638 1
					ans, resplen);
d652 1
a652 1
					ans, resplen);
d667 1
a667 1
					ans, resplen);
d675 1
a675 1
					ans, resplen);
d677 1
a677 1
				_res_close();
d690 1
a690 1
				_res_close();
d701 1
a701 1
			ans, resplen);
d712 1
a712 1
			_res_close();
d728 1
a728 1
					_res_close();
d747 1
a747 1
	_res_close();
d766 1
a766 1
_res_close()
@


1.2
log
@netbsd: bind 4.9.3
@
text
@a0 2
/*	$NetBSD: res_send.c,v 1.5 1996/02/02 15:22:36 mrg Exp $	*/

d55 1
a55 6
#if 0
static char sccsid[] = "@@(#)res_send.c	8.1 (Berkeley) 6/4/93";
static char rcsid[] = "$Id: res_send.c,v 8.7 1995/12/03 08:31:17 vixie Exp ";
#else
static char rcsid[] = "$NetBSD: res_send.c,v 1.5 1996/02/02 15:22:36 mrg Exp $";
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: res_send.c,v 1.4 1995/02/25 06:21:01 cgd Exp $	*/
d5 2
a6 2
 *	The Regents of the University of California.  All rights reserved.
 *
d17 2
a18 2
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
d22 1
a22 1
 *
d59 1
a59 1
static char rcsid[] = "$Id: res_send.c,v 4.9.1.1 1993/05/02 22:43:03 vixie Rel ";
d61 1
a61 1
static char rcsid[] = "$NetBSD: res_send.c,v 1.4 1995/02/25 06:21:01 cgd Exp $";
d65 7
d83 1
d85 1
d88 13
a100 2
#include <unistd.h>
#include <string.h>
d103 4
a106 1
static struct sockaddr no_addr;
d108 43
a150 7
#ifndef FD_SET
#define	NFDBITS		32
#define	FD_SETSIZE	32
#define	FD_SET(n, p)	((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
#define	FD_CLR(n, p)	((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
#define	FD_ISSET(n, p)	((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
#define FD_ZERO(p)	bzero((char *)(p), sizeof(*(p)))
d153 128
a280 2
res_send(buf, buflen, answer, anslen)
	const char *buf;
d282 2
a283 2
	char *answer;
	int anslen;
d285 3
d289 5
a293 18
	int try, v_circuit, resplen, ns;
	int gotsomewhere = 0, connected = 0;
	int connreset = 0;
	u_short id, len;
	char *cp;
	fd_set dsmask;
	struct timeval timeout;
	HEADER *hp = (HEADER *) buf;
	HEADER *anhp = (HEADER *) answer;
	u_int badns;		/* XXX NSMAX can't exceed #/bits per this */
	struct iovec iov[2];
	int terrno = ETIMEDOUT;
	char junk[512];

#ifdef DEBUG
	if ((_res.options & RES_DEBUG) || (_res.pfcode & RES_PRF_QUERY)) {
		printf(";; res_send()\n");
		__p_query(buf);
d295 2
a296 5
#endif
	if (!(_res.options & RES_INIT))
		if (res_init() == -1) {
			return(-1);
		}
d298 3
a300 1
	id = hp->id;
d302 1
d308 41
a348 9
		if (badns & (1<<ns))
			continue;
#ifdef DEBUG
		if (_res.options & RES_DEBUG)
			printf(";; Querying server (# %d) address = %s\n",
			       ns+1,
			       inet_ntoa(_res.nsaddr_list[ns].sin_addr));
#endif
	usevc:
d350 4
a353 1
			int truncated = 0;
d360 6
a365 2
			if (s < 0) {
				s = socket(AF_INET, SOCK_STREAM, 0);
d368 2
a369 5
#ifdef DEBUG
					if (_res.options & RES_DEBUG)
					    perror("socket (vc) failed");
#endif
					continue;
d371 3
a373 3
				if (connect(s,
				    (struct sockaddr *)&(_res.nsaddr_list[ns]),
				    sizeof(struct sockaddr)) < 0) {
d375 5
a379 7
#ifdef DEBUG
					if (_res.options & RES_DEBUG)
					    perror("connect failed");
#endif
					(void) close(s);
					s = -1;
					continue;
d381 1
d386 1
a386 1
			len = htons((u_short)buflen);
d388 2
a389 2
			iov[0].iov_len = sizeof(len);
			iov[1].iov_base = (char *)buf;
d391 1
a391 1
			if (writev(s, iov, 2) != sizeof(len) + buflen) {
d393 4
a396 7
#ifdef DEBUG
				if (_res.options & RES_DEBUG)
					perror("write failed");
#endif
				(void) close(s);
				s = -1;
				continue;
d401 3
a403 4
			cp = answer;
			len = sizeof(short);
			while (len != 0 &&
			    (n = read(s, (char *)cp, (int)len)) > 0) {
d405 2
a406 1
				len -= n;
d410 2
a411 6
#ifdef DEBUG
				if (_res.options & RES_DEBUG)
					perror("read failed");
#endif
				(void) close(s);
				s = -1;
d423 2
a424 1
					ns--;
d426 2
a427 1
				continue;
d429 5
a433 8
			cp = answer;
			if ((resplen = ntohs(*(u_short *)cp)) > anslen) {
#ifdef DEBUG
				if (_res.options & RES_DEBUG)
					fprintf(stderr,
						";; response truncated\n");
#endif
				len = anslen;
d435 1
d438 1
d440 1
a440 1
			   (n = read(s, (char *)cp, (int)len)) > 0) {
d446 3
a448 7
#ifdef DEBUG
				if (_res.options & RES_DEBUG)
					perror("read failed");
#endif
				(void) close(s);
				s = -1;
				continue;
d456 1
a456 1
				len = resplen - anslen;
d458 5
a462 2
					n = (len > sizeof(junk) ?
					    sizeof(junk) : len);
d473 9
a481 2
			if (s < 0) {
				s = socket(AF_INET, SOCK_DGRAM, 0);
d483 3
d487 2
a488 5
#ifdef DEBUG
					if (_res.options & RES_DEBUG)
					    perror("socket (dg) failed");
#endif
					continue;
d490 1
a492 1
			 * I'm tired of answering this question, so:
d509 2
a510 3
				 * Don't use connect if we might
				 * still receive a response
				 * from another server.
d512 10
a521 10
				if (connected == 0) {
					if (connect(s,
					    (struct sockaddr *)
					    &_res.nsaddr_list[ns],
					    sizeof(struct sockaddr)) < 0) {
#ifdef DEBUG
						if (_res.options & RES_DEBUG)
							perror("connect");
#endif
						continue;
d525 5
a529 6
				if (send(s, buf, buflen, 0) != buflen) {
#ifdef DEBUG
					if (_res.options & RES_DEBUG)
						perror("send");
#endif
					continue;
d537 19
a555 2
					(void) connect(s, &no_addr,
					    sizeof(no_addr));
d557 1
d559 8
a566 8
				if (sendto(s, buf, buflen, 0,
				    (struct sockaddr *)&_res.nsaddr_list[ns],
				    sizeof(struct sockaddr)) != buflen) {
#ifdef DEBUG
					if (_res.options & RES_DEBUG)
						perror("sendto");
#endif
					continue;
d579 1
a579 1
wait:
d583 1
a583 1
				(fd_set *)NULL, &timeout);
d585 3
a587 5
#ifdef DEBUG
				if (_res.options & RES_DEBUG)
					perror("select");
#endif
				continue;
d593 2
a594 4
#ifdef DEBUG
				if (_res.options & RES_DEBUG)
					printf(";; timeout\n");
#endif
d596 2
a597 1
				continue;
d599 8
a606 6
			if ((resplen = recv(s, answer, anslen, 0)) <= 0) {
#ifdef DEBUG
				if (_res.options & RES_DEBUG)
					perror("recvfrom");
#endif
				continue;
d609 1
a609 1
			if (id != anhp->id) {
d611 3
a613 1
				 * response from old query, ignore it
d615 20
a634 6
#ifdef DEBUG
				if ((_res.options & RES_DEBUG) ||
				    (_res.pfcode & RES_PRF_REPLY)) {
					printf(";; old answer:\n");
					__p_query(answer);
				}
d636 12
d650 2
a651 1
			if (anhp->rcode == SERVFAIL || anhp->rcode == NOTIMP ||
d653 8
a660 8
#ifdef DEBUG
				if (_res.options & RES_DEBUG) {
					printf("server rejected query:\n");
					__p_query(answer);
				}
#endif
				badns |= (1<<ns);
				continue;
d667 2
a668 6
#ifdef DEBUG
				if (_res.options & RES_DEBUG)
					printf(";; truncated answer\n");
#endif
				(void) close(s);
				s = -1;
d670 2
a671 1
				goto usevc;
d673 9
a681 8
		}
#ifdef DEBUG
		if (_res.options & RES_DEBUG)
			printf(";; got answer:\n");
		if ((_res.options & RES_DEBUG) ||
		    (_res.pfcode & RES_PRF_REPLY))
			__p_query(answer);
#endif
d684 1
a684 1
		 * is preferred * over the rest (i.e. it is on the local
d690 32
a721 5
		if ((v_circuit &&
		    ((_res.options & RES_USEVC) == 0 || ns != 0)) ||
		    (_res.options & RES_STAYOPEN) == 0) {
			(void) close(s);
			s = -1;
d724 6
a729 8
	   }
	}
	if (s >= 0) {
		(void) close(s);
		s = -1;
	}
	if (v_circuit == 0)
		if (gotsomewhere == 0)
d745 1
d748 1
a748 1
	if (s != -1) {
d751 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

